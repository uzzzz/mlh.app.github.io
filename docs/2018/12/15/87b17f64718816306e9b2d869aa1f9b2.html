<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>币本社区-从零开始学习比特币开发：生成地址 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="币本社区-从零开始学习比特币开发：生成地址" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="生成地址 如果有人想发送比特币给你，或者你从别人那里买几个比特币，就要把地址给对方，对方才能把币打到你指定的地址上。那么，如何才能拥有一个地址呢，下面我们就来讲讲这个问题。 比特币核心提供了很多 RPC 来供客户端调用，其中一个就是我们这里要讲的 getnewaddress 生成一个新的地址，通过这个 RPC ，我们就可以生成一个新的地址，有了这个地址，别人就可以给我们转账了。 getnewaddress RPC 可以接收两个参数，第一个地址的标签，第二个是地址的类型。如果没有提供标签，那么默认的标签就是空，地址的类型当前支持：legacy、p2sh-segwit、bech32，默认类型由 -addresstype 参数指定，当前为 p2sh-segwit。 如果我们想看下这个 RPC 的帮助文档，可以执行如下的命令： ./src/bitcoin-cli -regtest help getnewaddress 就会显示帮助信息 这个　RPC 对应的方法实现位于 src/wallet/rpcwallet.cpp 文件，方法名称就是 RPC 名称，下面我们来看这个方法。 生成地址流程 根据请求参数获得对应的钱包。 std::shared_ptr const wallet = GetWalletForJSONRPCRequest(request); CWallet* const pwallet = wallet.get(); GetWalletForJSONRPCRequest 方法内部实现如下： 调用 GetWalletNameFromJSONRPCRequest 方法，从请求对象中取得钱包的名字，如果用户指定了钱包名字，那么把钱包名字保存在参数 wallet_name 上，并返回真，否则返回假。 如果可以获得用户指定的钱包名称，则调用 GetWallet 方法，从钱包集合 vpwallets 中取得指定的钱包，然后返回钱包。 如果用户没有指定钱包或指定的钱包不存在，那么调用 GetWallets 方法，返回钱包集合 vpwallets。如果钱包集合中只有一个钱包，或者在用户指定了帮助的情况下，至少有一个以上的钱包，那么返回第一个钱包，即默认的钱包。默认钱包在系统启动时候创建的。 接下来，要确保钱包可用。如果钱包不可用，则直接 NullUniValue 对象。 if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) { return NullUniValue; } 如果指定了 help 参数或请求参数数量多于2个，则显示钱包的帮助信息。 检查钱包是否设置了禁止私钥，即钱包是只读的 watch-only/pubkeys。如果是，则抛出异常。 if (pwallet-&gt;IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) { throw JSONRPCError(RPC_WALLET_ERROR, “Error: Private keys are disabled for this wallet”); } 如果指定了标签，则调用 LabelFromValue 方法，检查标签，确保其不是 *。如果是，则抛出异常。 std::string label; if (!request.params[0].isNull()) label = LabelFromValue(request.params[0]); 如果指定了地址类型，则调用 ParseOutputType 方法，检查地址类型，确保其是 legacy、p2sh-segwit、bech32 之一，如果不指定则默认是 p2sh-segwit，并把地址类型保存在 output_type 变量中。 OutputType output_type = pwallet-&gt;m_default_address_type; if (!request.params[1].isNull()) { if (!ParseOutputType(request.params[1].get_str(), output_type)) { throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(“Unknown address type ‘%s’”, request.params[1].get_str())); } } 如果钱包没有被锁定，则调用 TopUpKeyPool 方法填充密钥池。 if (!pwallet-&gt;IsLocked()) { pwallet-&gt;TopUpKeyPool(); } TopUpKeyPool 填充密钥这个方法，我们前面已经讲过，这里只简单解释下，不做详细分析。因为在衍生子钥的过程中，setExternalKeyPool、setInternalKeyPool 已经完全填充完了，所以导致 missingExternal、missingInternal 两个变量都为 0，从而不会重新再次衍生子密钥，所以实际上本方法在这里基本没有执行，而直接返回真。 调用钱包的 GetKeyFromPool 方法，从密钥池中生成一个公钥。如果不能生成，则抛出异常。 CPubKey newKey; if (!pwallet-&gt;GetKeyFromPool(newKey)) { throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, “Error: Keypool ran out, please call keypoolrefill first”); } GetKeyFromPool 方法，我们在下面详细讲解，此处略过。 调用钱包对象的 LearnRelatedScripts 方法，对公钥的脚本进行处理。方法内部执行如下：如果公钥是压缩的，并且地址类型是 p2sh-segwit，或者 bech32，那么： 调用 WitnessV0KeyHash 方法，生成 WitnessV0KeyHash 对象。 CTxDestination witdest = WitnessV0KeyHash(key.GetID()); 调用 GetScriptForDestination 方法，获取对应的脚本。 CScript witprog = GetScriptForDestination(witdest); GetScriptForDestination 方法内部调用 boost::apply_visitor(CScriptVisitor(&amp;script), dest)，以访问者模式来根据不同的 id，获取其对应的脚本对象。 CScriptVisitor 对象继承自 boost::static_visitor 对象，实现了访问者模式，并通过重载 () 操作符来定义不同类型的 id。 如果目标参数类型是 CNoDestination，则调用脚本对象的 script 方法，清除脚本内容。 如果目标参数类型是 CKeyID，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(keyID) &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG。 如果目标参数类型是 CScriptID，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(scriptID) &lt;&lt; OP_EQUAL。 如果目标参数类型是 WitnessV0KeyHash，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_0 &lt;&lt; ToByteVector(id)。 如果目标参数类型是 WitnessV0ScriptHash，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_0 &lt;&lt; ToByteVector(id)。 如果目标参数类型是 WitnessUnknown，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; CScript::EncodeOP_N(id.version) &lt;&lt; std::vector(id.program, id.program + id.length)。 调用 AddCScript 方法，保存脚本对象。AddCScript 方法，首先调用 CCryptoKeyStore::AddCScript 方法，把脚本保存到 key store 的 mapScripts 集合中；然后，调用数据库访问对象的 WriteCScript 方法，以 cscript 为键把脚本保存到数据库中。 bool CWallet::AddCScript(const CScript&amp; redeemScript) { if (!CCryptoKeyStore::AddCScript(redeemScript)) return false; return WalletBatch(*database).WriteCScript(Hash160(redeemScript), redeemScript); } 调用 GetDestinationForKey 方法，获取目的地 CTxDestination 对象。CTxDestination 是一个具有特定目标的交易输出脚本模板。定义如下：typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessUnknown&gt; CTxDestination，可能是以下几种类型之一： CNoDestination没有目的地设置 CKeyIDP2PKH 目的 CScriptIDP2SH 目的 WitnessV0ScriptHashP2WSH 目的 WitnessV0KeyHashP2WPKH 目的 WitnessUnknown未知目的 P2W??? GetDestinationForKey 方法，使用 case 表达式来根据不同的地址类型，生成不同的目的 CTxDestination。 如果地址类型是 legacy，则直接返回公钥的 KeyID。内部把公钥的数据通过 SHA256 和 RIPEMD160 双重哈希之后，构造一个 CKeyID 对象。 如果地址类型是 p2sh-segwit，或 bech32，则处理如下： 如果公钥不是压缩的，处理方法 legacy。 if (!key.IsCompressed()) return key.GetID(); 否则，生成 WitnessV0KeyHash 对象，然后调用 GetScriptForDestination 方法，获取对应的脚本，最后根据不同的地址类型生成的目的。 CTxDestination witdest = WitnessV0KeyHash(key.GetID()); CScript witprog = GetScriptForDestination(witdest); if (type == OutputType::P2SH_SEGWIT) { return CScriptID(witprog); } else { return witdest; } 对于默认的、不传地址类型的情况，就会返回 CScriptID 类型的 CTxDestination，这个返回值在下面两步中都会用到。 调用钱包对象的 SetAddressBook 方法，来保存公钥地址。 pwallet-&gt;SetAddressBook(dest, label, “receive”); SetAddressBook 方法执行如下： 从 mapAddressBook 集合中，取得对应的目的数据。 std::map&lt;CTxDestination, CAddressBookData&gt;::iterator mi = mapAddressBook.find(address); 根据集合中是否有对应的数据设置变量是否为更新。 fUpdated = mi != mapAddressBook.end(); 把标签保存为地址对应的 CAddressBookData 的 name 属性。 mapAddressBook[address].name = strName; 如果参数 strPurpose 不空，则更新地址对应的 CAddressBookData 的 purpose 属性。 if (!strPurpose.empty()) mapAddressBook[address].purpose = strPurpose; 调用数据库访问对象的 WritePurpose 方法，保存参数 strPurpose 到数据库中。 if (!strPurpose.empty() &amp;&amp; !WalletBatch(database).WritePurpose(EncodeDestination(address), strPurpose)) return false; 调用数据库访问对象的 WritePurpose 方法，保存地址到数据库中。 WalletBatch(database).WriteName(EncodeDestination(address), strName); strName 为用户提供的标签。EncodeDestination 方法，我们在下一步讲解。 调用 EncodeDestination 方法，解码目的地址，并返回其结果。EncodeDestination 方法同样采用了访问者模式 return boost::apply_visitor(DestinationEncoder(Params()), dest)。DestinationEncoder 类继承了 boost::static_visitor，实现了访问者模式，通过重载 () 操作符来定义不同类型的 id。与前面相对应，这个方法会处理 CKeyID、CScriptID、WitnessV0KeyHash、WitnessV0ScriptHash、WitnessUnknown 这几种不同情况。对于我们的默认情况来说，目的地址类型为 CScriptID，下面我们就看下这种情况的处理，其他情况可自行阅读。 调用当前网络参数的 Base58Prefix 方法，返回脚本前缀。 std::vector data = m_params.Base58Prefix(CChainParams::SCRIPT_ADDRESS); 对于主网络前缀是 5，测试网络是 196，回归测试网络是 196。 把当前 20 个字节的数据加在前缀后面形成 21 个字节的字符串。 data.insert(data.end(), id.begin(), id.end()); 调用 EncodeBase58Check 方法，编码成 Base58Check 格式，并返回其值。 return EncodeBase58Check(data); 下面，我们来看下 EncodeBase58Check 这个方法的处理。它的内部执行流程如下：用 21 个字节的字符串生成一个向量，同时调用 Hash 方法，生成一个 32 字节长的哈希字符串；然后把其最前面的 4个字节作为校验各加在 21 个字节的向量尾部，从而生成一个长度为 25个字节的字符串；最后，调用 EncodeBase58 方法，进行 Base58 编码。 std::vector vch(vchIn); uint256 hash = Hash(vch.begin(), vch.end()); vch.insert(vch.end(), (unsigned char)&amp;hash, (unsigned char)&amp;hash + 4); return EncodeBase58(vch); 在 Hash 这个方法中，使用了双重 SHA256 哈希算法。EncodeBase58 这个方法，读者可以自行阅读，这里不再展开。 GetKeyFromPool 从密钥池中获取公钥 本方法从密钥池中生成一个公钥。第一个参数为公钥的引用，第二个参数 internal，默认为假。 内部逻辑如下： 如果钱包禁止私钥，则返回假。 if (IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) { return false; } 调用 ReserveKeyFromKeyPool 方法，从密钥池中取出一个密钥并获取其公钥。如果不成功，则生成数据库访问对象，然后调用 GenerateNewKey 方法，生成一个公钥。 if (!ReserveKeyFromKeyPool(nIndex, keypool, internal)) { if (IsLocked()) return false; WalletBatch batch(*database); result = GenerateNewKey(batch, internal); return true; } GenerateNewKey 这个方法，在创建钱包过程中，我们已经重点分析，这里不浪费口舌，我们重点看下 ReserveKeyFromKeyPool 方法。这个方法的执行流程如下： 生成一个公钥，并设置为密钥池的 vchPubKey 属性。 nIndex = -1; keypool.vchPubKey = CPubKey(); 如果钱包没有被锁，则填充密钥池。 if (!IsLocked()) TopUpKeyPool(); TopUpKeyPool 这个方法，我们也讲过，这里直接略过。 如果钱包启用了 HD，并且可以支持 HD 分割，并且参数 fRequestedInternal 为真，则设置变量 fReturningInternal 为真。在调用本方法时，这个参数没有指定，而默认为假，所以变量 fRequestedInternal 设置假。 bool fReturningInternal = IsHDEnabled() &amp;&amp; CanSupportFeature(FEATURE_HD_SPLIT) &amp;&amp; fRequestedInternal; 根据集合 set_pre_split_keypool 是否为空，设置变量 use_split_keypool 的值。因为这里 use_split_keypool 集合为空，所以变量 use_split_keypool 为真。 bool use_split_keypool = set_pre_split_keypool.empty(); 根据变量 use_split_keypool、fReturningInternal 确定从哪个集合中获取密钥池对象。根据上面分析，我们最终会从 setExternalKeyPool 集合中取数据。 std::set&lt;int64_t&gt;&amp; setKeyPool = use_split_keypool ? (fReturningInternal ? setInternalKeyPool : setExternalKeyPool) : set_pre_split_keypool; 如果要数据的集合为为空，则返回假。 if (setKeyPool.empty()) { return false; } 生成数据库访问对象。 WalletBatch batch(*database); 从 setKeyPool 取得其第一个元素，并从集合中删除它。 auto it = setKeyPool.begin(); nIndex = *it; setKeyPool.erase(it); 从数据库取得索引对应的密钥池。如果失败，则抛出异常。 if (!batch.ReadPool(nIndex, keypool)) { throw std::runtime_error(std::string(func) + “: read failed”); } 从密钥池中取得公钥对应的 ID，并且检测其是否在 mapKeys、或 mapCryptedKeys 集合之一，如果不在，则抛出异常。我们在创建钱包过程时候讲过，生成的私钥根据是否加密会保存在这两个集合之一。 if (!HaveKey(keypool.vchPubKey.GetID())) { throw std::runtime_error(std::string(func) + “: unknown key in key pool”); } 如果变量 use_split_keypool 为真，并且密钥池的 fInternal 属性不等于变量 fReturningInternal，那么抛出异常。 if (use_split_keypool &amp;&amp; keypool.fInternal != fReturningInternal) { throw std::runtime_error(std::string(func) + “: keypool entry misclassified”); } 如果密钥池中保存的公钥是无效的，那么抛出异常。 if (!keypool.vchPubKey.IsValid()) { throw std::runtime_error(std::string(func) + “: keypool entry invalid”); } 从 m_pool_key_to_index 集合中消除对应的索引。 m_pool_key_to_index.erase(keypool.vchPubKey.GetID()); 返回真。 调用 KeepKey 从密钥池中取出对应的公钥。" />
<meta property="og:description" content="生成地址 如果有人想发送比特币给你，或者你从别人那里买几个比特币，就要把地址给对方，对方才能把币打到你指定的地址上。那么，如何才能拥有一个地址呢，下面我们就来讲讲这个问题。 比特币核心提供了很多 RPC 来供客户端调用，其中一个就是我们这里要讲的 getnewaddress 生成一个新的地址，通过这个 RPC ，我们就可以生成一个新的地址，有了这个地址，别人就可以给我们转账了。 getnewaddress RPC 可以接收两个参数，第一个地址的标签，第二个是地址的类型。如果没有提供标签，那么默认的标签就是空，地址的类型当前支持：legacy、p2sh-segwit、bech32，默认类型由 -addresstype 参数指定，当前为 p2sh-segwit。 如果我们想看下这个 RPC 的帮助文档，可以执行如下的命令： ./src/bitcoin-cli -regtest help getnewaddress 就会显示帮助信息 这个　RPC 对应的方法实现位于 src/wallet/rpcwallet.cpp 文件，方法名称就是 RPC 名称，下面我们来看这个方法。 生成地址流程 根据请求参数获得对应的钱包。 std::shared_ptr const wallet = GetWalletForJSONRPCRequest(request); CWallet* const pwallet = wallet.get(); GetWalletForJSONRPCRequest 方法内部实现如下： 调用 GetWalletNameFromJSONRPCRequest 方法，从请求对象中取得钱包的名字，如果用户指定了钱包名字，那么把钱包名字保存在参数 wallet_name 上，并返回真，否则返回假。 如果可以获得用户指定的钱包名称，则调用 GetWallet 方法，从钱包集合 vpwallets 中取得指定的钱包，然后返回钱包。 如果用户没有指定钱包或指定的钱包不存在，那么调用 GetWallets 方法，返回钱包集合 vpwallets。如果钱包集合中只有一个钱包，或者在用户指定了帮助的情况下，至少有一个以上的钱包，那么返回第一个钱包，即默认的钱包。默认钱包在系统启动时候创建的。 接下来，要确保钱包可用。如果钱包不可用，则直接 NullUniValue 对象。 if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) { return NullUniValue; } 如果指定了 help 参数或请求参数数量多于2个，则显示钱包的帮助信息。 检查钱包是否设置了禁止私钥，即钱包是只读的 watch-only/pubkeys。如果是，则抛出异常。 if (pwallet-&gt;IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) { throw JSONRPCError(RPC_WALLET_ERROR, “Error: Private keys are disabled for this wallet”); } 如果指定了标签，则调用 LabelFromValue 方法，检查标签，确保其不是 *。如果是，则抛出异常。 std::string label; if (!request.params[0].isNull()) label = LabelFromValue(request.params[0]); 如果指定了地址类型，则调用 ParseOutputType 方法，检查地址类型，确保其是 legacy、p2sh-segwit、bech32 之一，如果不指定则默认是 p2sh-segwit，并把地址类型保存在 output_type 变量中。 OutputType output_type = pwallet-&gt;m_default_address_type; if (!request.params[1].isNull()) { if (!ParseOutputType(request.params[1].get_str(), output_type)) { throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(“Unknown address type ‘%s’”, request.params[1].get_str())); } } 如果钱包没有被锁定，则调用 TopUpKeyPool 方法填充密钥池。 if (!pwallet-&gt;IsLocked()) { pwallet-&gt;TopUpKeyPool(); } TopUpKeyPool 填充密钥这个方法，我们前面已经讲过，这里只简单解释下，不做详细分析。因为在衍生子钥的过程中，setExternalKeyPool、setInternalKeyPool 已经完全填充完了，所以导致 missingExternal、missingInternal 两个变量都为 0，从而不会重新再次衍生子密钥，所以实际上本方法在这里基本没有执行，而直接返回真。 调用钱包的 GetKeyFromPool 方法，从密钥池中生成一个公钥。如果不能生成，则抛出异常。 CPubKey newKey; if (!pwallet-&gt;GetKeyFromPool(newKey)) { throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, “Error: Keypool ran out, please call keypoolrefill first”); } GetKeyFromPool 方法，我们在下面详细讲解，此处略过。 调用钱包对象的 LearnRelatedScripts 方法，对公钥的脚本进行处理。方法内部执行如下：如果公钥是压缩的，并且地址类型是 p2sh-segwit，或者 bech32，那么： 调用 WitnessV0KeyHash 方法，生成 WitnessV0KeyHash 对象。 CTxDestination witdest = WitnessV0KeyHash(key.GetID()); 调用 GetScriptForDestination 方法，获取对应的脚本。 CScript witprog = GetScriptForDestination(witdest); GetScriptForDestination 方法内部调用 boost::apply_visitor(CScriptVisitor(&amp;script), dest)，以访问者模式来根据不同的 id，获取其对应的脚本对象。 CScriptVisitor 对象继承自 boost::static_visitor 对象，实现了访问者模式，并通过重载 () 操作符来定义不同类型的 id。 如果目标参数类型是 CNoDestination，则调用脚本对象的 script 方法，清除脚本内容。 如果目标参数类型是 CKeyID，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(keyID) &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG。 如果目标参数类型是 CScriptID，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(scriptID) &lt;&lt; OP_EQUAL。 如果目标参数类型是 WitnessV0KeyHash，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_0 &lt;&lt; ToByteVector(id)。 如果目标参数类型是 WitnessV0ScriptHash，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_0 &lt;&lt; ToByteVector(id)。 如果目标参数类型是 WitnessUnknown，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; CScript::EncodeOP_N(id.version) &lt;&lt; std::vector(id.program, id.program + id.length)。 调用 AddCScript 方法，保存脚本对象。AddCScript 方法，首先调用 CCryptoKeyStore::AddCScript 方法，把脚本保存到 key store 的 mapScripts 集合中；然后，调用数据库访问对象的 WriteCScript 方法，以 cscript 为键把脚本保存到数据库中。 bool CWallet::AddCScript(const CScript&amp; redeemScript) { if (!CCryptoKeyStore::AddCScript(redeemScript)) return false; return WalletBatch(*database).WriteCScript(Hash160(redeemScript), redeemScript); } 调用 GetDestinationForKey 方法，获取目的地 CTxDestination 对象。CTxDestination 是一个具有特定目标的交易输出脚本模板。定义如下：typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessUnknown&gt; CTxDestination，可能是以下几种类型之一： CNoDestination没有目的地设置 CKeyIDP2PKH 目的 CScriptIDP2SH 目的 WitnessV0ScriptHashP2WSH 目的 WitnessV0KeyHashP2WPKH 目的 WitnessUnknown未知目的 P2W??? GetDestinationForKey 方法，使用 case 表达式来根据不同的地址类型，生成不同的目的 CTxDestination。 如果地址类型是 legacy，则直接返回公钥的 KeyID。内部把公钥的数据通过 SHA256 和 RIPEMD160 双重哈希之后，构造一个 CKeyID 对象。 如果地址类型是 p2sh-segwit，或 bech32，则处理如下： 如果公钥不是压缩的，处理方法 legacy。 if (!key.IsCompressed()) return key.GetID(); 否则，生成 WitnessV0KeyHash 对象，然后调用 GetScriptForDestination 方法，获取对应的脚本，最后根据不同的地址类型生成的目的。 CTxDestination witdest = WitnessV0KeyHash(key.GetID()); CScript witprog = GetScriptForDestination(witdest); if (type == OutputType::P2SH_SEGWIT) { return CScriptID(witprog); } else { return witdest; } 对于默认的、不传地址类型的情况，就会返回 CScriptID 类型的 CTxDestination，这个返回值在下面两步中都会用到。 调用钱包对象的 SetAddressBook 方法，来保存公钥地址。 pwallet-&gt;SetAddressBook(dest, label, “receive”); SetAddressBook 方法执行如下： 从 mapAddressBook 集合中，取得对应的目的数据。 std::map&lt;CTxDestination, CAddressBookData&gt;::iterator mi = mapAddressBook.find(address); 根据集合中是否有对应的数据设置变量是否为更新。 fUpdated = mi != mapAddressBook.end(); 把标签保存为地址对应的 CAddressBookData 的 name 属性。 mapAddressBook[address].name = strName; 如果参数 strPurpose 不空，则更新地址对应的 CAddressBookData 的 purpose 属性。 if (!strPurpose.empty()) mapAddressBook[address].purpose = strPurpose; 调用数据库访问对象的 WritePurpose 方法，保存参数 strPurpose 到数据库中。 if (!strPurpose.empty() &amp;&amp; !WalletBatch(database).WritePurpose(EncodeDestination(address), strPurpose)) return false; 调用数据库访问对象的 WritePurpose 方法，保存地址到数据库中。 WalletBatch(database).WriteName(EncodeDestination(address), strName); strName 为用户提供的标签。EncodeDestination 方法，我们在下一步讲解。 调用 EncodeDestination 方法，解码目的地址，并返回其结果。EncodeDestination 方法同样采用了访问者模式 return boost::apply_visitor(DestinationEncoder(Params()), dest)。DestinationEncoder 类继承了 boost::static_visitor，实现了访问者模式，通过重载 () 操作符来定义不同类型的 id。与前面相对应，这个方法会处理 CKeyID、CScriptID、WitnessV0KeyHash、WitnessV0ScriptHash、WitnessUnknown 这几种不同情况。对于我们的默认情况来说，目的地址类型为 CScriptID，下面我们就看下这种情况的处理，其他情况可自行阅读。 调用当前网络参数的 Base58Prefix 方法，返回脚本前缀。 std::vector data = m_params.Base58Prefix(CChainParams::SCRIPT_ADDRESS); 对于主网络前缀是 5，测试网络是 196，回归测试网络是 196。 把当前 20 个字节的数据加在前缀后面形成 21 个字节的字符串。 data.insert(data.end(), id.begin(), id.end()); 调用 EncodeBase58Check 方法，编码成 Base58Check 格式，并返回其值。 return EncodeBase58Check(data); 下面，我们来看下 EncodeBase58Check 这个方法的处理。它的内部执行流程如下：用 21 个字节的字符串生成一个向量，同时调用 Hash 方法，生成一个 32 字节长的哈希字符串；然后把其最前面的 4个字节作为校验各加在 21 个字节的向量尾部，从而生成一个长度为 25个字节的字符串；最后，调用 EncodeBase58 方法，进行 Base58 编码。 std::vector vch(vchIn); uint256 hash = Hash(vch.begin(), vch.end()); vch.insert(vch.end(), (unsigned char)&amp;hash, (unsigned char)&amp;hash + 4); return EncodeBase58(vch); 在 Hash 这个方法中，使用了双重 SHA256 哈希算法。EncodeBase58 这个方法，读者可以自行阅读，这里不再展开。 GetKeyFromPool 从密钥池中获取公钥 本方法从密钥池中生成一个公钥。第一个参数为公钥的引用，第二个参数 internal，默认为假。 内部逻辑如下： 如果钱包禁止私钥，则返回假。 if (IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) { return false; } 调用 ReserveKeyFromKeyPool 方法，从密钥池中取出一个密钥并获取其公钥。如果不成功，则生成数据库访问对象，然后调用 GenerateNewKey 方法，生成一个公钥。 if (!ReserveKeyFromKeyPool(nIndex, keypool, internal)) { if (IsLocked()) return false; WalletBatch batch(*database); result = GenerateNewKey(batch, internal); return true; } GenerateNewKey 这个方法，在创建钱包过程中，我们已经重点分析，这里不浪费口舌，我们重点看下 ReserveKeyFromKeyPool 方法。这个方法的执行流程如下： 生成一个公钥，并设置为密钥池的 vchPubKey 属性。 nIndex = -1; keypool.vchPubKey = CPubKey(); 如果钱包没有被锁，则填充密钥池。 if (!IsLocked()) TopUpKeyPool(); TopUpKeyPool 这个方法，我们也讲过，这里直接略过。 如果钱包启用了 HD，并且可以支持 HD 分割，并且参数 fRequestedInternal 为真，则设置变量 fReturningInternal 为真。在调用本方法时，这个参数没有指定，而默认为假，所以变量 fRequestedInternal 设置假。 bool fReturningInternal = IsHDEnabled() &amp;&amp; CanSupportFeature(FEATURE_HD_SPLIT) &amp;&amp; fRequestedInternal; 根据集合 set_pre_split_keypool 是否为空，设置变量 use_split_keypool 的值。因为这里 use_split_keypool 集合为空，所以变量 use_split_keypool 为真。 bool use_split_keypool = set_pre_split_keypool.empty(); 根据变量 use_split_keypool、fReturningInternal 确定从哪个集合中获取密钥池对象。根据上面分析，我们最终会从 setExternalKeyPool 集合中取数据。 std::set&lt;int64_t&gt;&amp; setKeyPool = use_split_keypool ? (fReturningInternal ? setInternalKeyPool : setExternalKeyPool) : set_pre_split_keypool; 如果要数据的集合为为空，则返回假。 if (setKeyPool.empty()) { return false; } 生成数据库访问对象。 WalletBatch batch(*database); 从 setKeyPool 取得其第一个元素，并从集合中删除它。 auto it = setKeyPool.begin(); nIndex = *it; setKeyPool.erase(it); 从数据库取得索引对应的密钥池。如果失败，则抛出异常。 if (!batch.ReadPool(nIndex, keypool)) { throw std::runtime_error(std::string(func) + “: read failed”); } 从密钥池中取得公钥对应的 ID，并且检测其是否在 mapKeys、或 mapCryptedKeys 集合之一，如果不在，则抛出异常。我们在创建钱包过程时候讲过，生成的私钥根据是否加密会保存在这两个集合之一。 if (!HaveKey(keypool.vchPubKey.GetID())) { throw std::runtime_error(std::string(func) + “: unknown key in key pool”); } 如果变量 use_split_keypool 为真，并且密钥池的 fInternal 属性不等于变量 fReturningInternal，那么抛出异常。 if (use_split_keypool &amp;&amp; keypool.fInternal != fReturningInternal) { throw std::runtime_error(std::string(func) + “: keypool entry misclassified”); } 如果密钥池中保存的公钥是无效的，那么抛出异常。 if (!keypool.vchPubKey.IsValid()) { throw std::runtime_error(std::string(func) + “: keypool entry invalid”); } 从 m_pool_key_to_index 集合中消除对应的索引。 m_pool_key_to_index.erase(keypool.vchPubKey.GetID()); 返回真。 调用 KeepKey 从密钥池中取出对应的公钥。" />
<link rel="canonical" href="https://mlh.app/2018/12/15/87b17f64718816306e9b2d869aa1f9b2.html" />
<meta property="og:url" content="https://mlh.app/2018/12/15/87b17f64718816306e9b2d869aa1f9b2.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-12-15T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"生成地址 如果有人想发送比特币给你，或者你从别人那里买几个比特币，就要把地址给对方，对方才能把币打到你指定的地址上。那么，如何才能拥有一个地址呢，下面我们就来讲讲这个问题。 比特币核心提供了很多 RPC 来供客户端调用，其中一个就是我们这里要讲的 getnewaddress 生成一个新的地址，通过这个 RPC ，我们就可以生成一个新的地址，有了这个地址，别人就可以给我们转账了。 getnewaddress RPC 可以接收两个参数，第一个地址的标签，第二个是地址的类型。如果没有提供标签，那么默认的标签就是空，地址的类型当前支持：legacy、p2sh-segwit、bech32，默认类型由 -addresstype 参数指定，当前为 p2sh-segwit。 如果我们想看下这个 RPC 的帮助文档，可以执行如下的命令： ./src/bitcoin-cli -regtest help getnewaddress 就会显示帮助信息 这个　RPC 对应的方法实现位于 src/wallet/rpcwallet.cpp 文件，方法名称就是 RPC 名称，下面我们来看这个方法。 生成地址流程 根据请求参数获得对应的钱包。 std::shared_ptr const wallet = GetWalletForJSONRPCRequest(request); CWallet* const pwallet = wallet.get(); GetWalletForJSONRPCRequest 方法内部实现如下： 调用 GetWalletNameFromJSONRPCRequest 方法，从请求对象中取得钱包的名字，如果用户指定了钱包名字，那么把钱包名字保存在参数 wallet_name 上，并返回真，否则返回假。 如果可以获得用户指定的钱包名称，则调用 GetWallet 方法，从钱包集合 vpwallets 中取得指定的钱包，然后返回钱包。 如果用户没有指定钱包或指定的钱包不存在，那么调用 GetWallets 方法，返回钱包集合 vpwallets。如果钱包集合中只有一个钱包，或者在用户指定了帮助的情况下，至少有一个以上的钱包，那么返回第一个钱包，即默认的钱包。默认钱包在系统启动时候创建的。 接下来，要确保钱包可用。如果钱包不可用，则直接 NullUniValue 对象。 if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) { return NullUniValue; } 如果指定了 help 参数或请求参数数量多于2个，则显示钱包的帮助信息。 检查钱包是否设置了禁止私钥，即钱包是只读的 watch-only/pubkeys。如果是，则抛出异常。 if (pwallet-&gt;IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) { throw JSONRPCError(RPC_WALLET_ERROR, “Error: Private keys are disabled for this wallet”); } 如果指定了标签，则调用 LabelFromValue 方法，检查标签，确保其不是 *。如果是，则抛出异常。 std::string label; if (!request.params[0].isNull()) label = LabelFromValue(request.params[0]); 如果指定了地址类型，则调用 ParseOutputType 方法，检查地址类型，确保其是 legacy、p2sh-segwit、bech32 之一，如果不指定则默认是 p2sh-segwit，并把地址类型保存在 output_type 变量中。 OutputType output_type = pwallet-&gt;m_default_address_type; if (!request.params[1].isNull()) { if (!ParseOutputType(request.params[1].get_str(), output_type)) { throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(“Unknown address type ‘%s’”, request.params[1].get_str())); } } 如果钱包没有被锁定，则调用 TopUpKeyPool 方法填充密钥池。 if (!pwallet-&gt;IsLocked()) { pwallet-&gt;TopUpKeyPool(); } TopUpKeyPool 填充密钥这个方法，我们前面已经讲过，这里只简单解释下，不做详细分析。因为在衍生子钥的过程中，setExternalKeyPool、setInternalKeyPool 已经完全填充完了，所以导致 missingExternal、missingInternal 两个变量都为 0，从而不会重新再次衍生子密钥，所以实际上本方法在这里基本没有执行，而直接返回真。 调用钱包的 GetKeyFromPool 方法，从密钥池中生成一个公钥。如果不能生成，则抛出异常。 CPubKey newKey; if (!pwallet-&gt;GetKeyFromPool(newKey)) { throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, “Error: Keypool ran out, please call keypoolrefill first”); } GetKeyFromPool 方法，我们在下面详细讲解，此处略过。 调用钱包对象的 LearnRelatedScripts 方法，对公钥的脚本进行处理。方法内部执行如下：如果公钥是压缩的，并且地址类型是 p2sh-segwit，或者 bech32，那么： 调用 WitnessV0KeyHash 方法，生成 WitnessV0KeyHash 对象。 CTxDestination witdest = WitnessV0KeyHash(key.GetID()); 调用 GetScriptForDestination 方法，获取对应的脚本。 CScript witprog = GetScriptForDestination(witdest); GetScriptForDestination 方法内部调用 boost::apply_visitor(CScriptVisitor(&amp;script), dest)，以访问者模式来根据不同的 id，获取其对应的脚本对象。 CScriptVisitor 对象继承自 boost::static_visitor 对象，实现了访问者模式，并通过重载 () 操作符来定义不同类型的 id。 如果目标参数类型是 CNoDestination，则调用脚本对象的 script 方法，清除脚本内容。 如果目标参数类型是 CKeyID，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(keyID) &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG。 如果目标参数类型是 CScriptID，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(scriptID) &lt;&lt; OP_EQUAL。 如果目标参数类型是 WitnessV0KeyHash，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_0 &lt;&lt; ToByteVector(id)。 如果目标参数类型是 WitnessV0ScriptHash，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_0 &lt;&lt; ToByteVector(id)。 如果目标参数类型是 WitnessUnknown，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; CScript::EncodeOP_N(id.version) &lt;&lt; std::vector(id.program, id.program + id.length)。 调用 AddCScript 方法，保存脚本对象。AddCScript 方法，首先调用 CCryptoKeyStore::AddCScript 方法，把脚本保存到 key store 的 mapScripts 集合中；然后，调用数据库访问对象的 WriteCScript 方法，以 cscript 为键把脚本保存到数据库中。 bool CWallet::AddCScript(const CScript&amp; redeemScript) { if (!CCryptoKeyStore::AddCScript(redeemScript)) return false; return WalletBatch(*database).WriteCScript(Hash160(redeemScript), redeemScript); } 调用 GetDestinationForKey 方法，获取目的地 CTxDestination 对象。CTxDestination 是一个具有特定目标的交易输出脚本模板。定义如下：typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessUnknown&gt; CTxDestination，可能是以下几种类型之一： CNoDestination没有目的地设置 CKeyIDP2PKH 目的 CScriptIDP2SH 目的 WitnessV0ScriptHashP2WSH 目的 WitnessV0KeyHashP2WPKH 目的 WitnessUnknown未知目的 P2W??? GetDestinationForKey 方法，使用 case 表达式来根据不同的地址类型，生成不同的目的 CTxDestination。 如果地址类型是 legacy，则直接返回公钥的 KeyID。内部把公钥的数据通过 SHA256 和 RIPEMD160 双重哈希之后，构造一个 CKeyID 对象。 如果地址类型是 p2sh-segwit，或 bech32，则处理如下： 如果公钥不是压缩的，处理方法 legacy。 if (!key.IsCompressed()) return key.GetID(); 否则，生成 WitnessV0KeyHash 对象，然后调用 GetScriptForDestination 方法，获取对应的脚本，最后根据不同的地址类型生成的目的。 CTxDestination witdest = WitnessV0KeyHash(key.GetID()); CScript witprog = GetScriptForDestination(witdest); if (type == OutputType::P2SH_SEGWIT) { return CScriptID(witprog); } else { return witdest; } 对于默认的、不传地址类型的情况，就会返回 CScriptID 类型的 CTxDestination，这个返回值在下面两步中都会用到。 调用钱包对象的 SetAddressBook 方法，来保存公钥地址。 pwallet-&gt;SetAddressBook(dest, label, “receive”); SetAddressBook 方法执行如下： 从 mapAddressBook 集合中，取得对应的目的数据。 std::map&lt;CTxDestination, CAddressBookData&gt;::iterator mi = mapAddressBook.find(address); 根据集合中是否有对应的数据设置变量是否为更新。 fUpdated = mi != mapAddressBook.end(); 把标签保存为地址对应的 CAddressBookData 的 name 属性。 mapAddressBook[address].name = strName; 如果参数 strPurpose 不空，则更新地址对应的 CAddressBookData 的 purpose 属性。 if (!strPurpose.empty()) mapAddressBook[address].purpose = strPurpose; 调用数据库访问对象的 WritePurpose 方法，保存参数 strPurpose 到数据库中。 if (!strPurpose.empty() &amp;&amp; !WalletBatch(database).WritePurpose(EncodeDestination(address), strPurpose)) return false; 调用数据库访问对象的 WritePurpose 方法，保存地址到数据库中。 WalletBatch(database).WriteName(EncodeDestination(address), strName); strName 为用户提供的标签。EncodeDestination 方法，我们在下一步讲解。 调用 EncodeDestination 方法，解码目的地址，并返回其结果。EncodeDestination 方法同样采用了访问者模式 return boost::apply_visitor(DestinationEncoder(Params()), dest)。DestinationEncoder 类继承了 boost::static_visitor，实现了访问者模式，通过重载 () 操作符来定义不同类型的 id。与前面相对应，这个方法会处理 CKeyID、CScriptID、WitnessV0KeyHash、WitnessV0ScriptHash、WitnessUnknown 这几种不同情况。对于我们的默认情况来说，目的地址类型为 CScriptID，下面我们就看下这种情况的处理，其他情况可自行阅读。 调用当前网络参数的 Base58Prefix 方法，返回脚本前缀。 std::vector data = m_params.Base58Prefix(CChainParams::SCRIPT_ADDRESS); 对于主网络前缀是 5，测试网络是 196，回归测试网络是 196。 把当前 20 个字节的数据加在前缀后面形成 21 个字节的字符串。 data.insert(data.end(), id.begin(), id.end()); 调用 EncodeBase58Check 方法，编码成 Base58Check 格式，并返回其值。 return EncodeBase58Check(data); 下面，我们来看下 EncodeBase58Check 这个方法的处理。它的内部执行流程如下：用 21 个字节的字符串生成一个向量，同时调用 Hash 方法，生成一个 32 字节长的哈希字符串；然后把其最前面的 4个字节作为校验各加在 21 个字节的向量尾部，从而生成一个长度为 25个字节的字符串；最后，调用 EncodeBase58 方法，进行 Base58 编码。 std::vector vch(vchIn); uint256 hash = Hash(vch.begin(), vch.end()); vch.insert(vch.end(), (unsigned char)&amp;hash, (unsigned char)&amp;hash + 4); return EncodeBase58(vch); 在 Hash 这个方法中，使用了双重 SHA256 哈希算法。EncodeBase58 这个方法，读者可以自行阅读，这里不再展开。 GetKeyFromPool 从密钥池中获取公钥 本方法从密钥池中生成一个公钥。第一个参数为公钥的引用，第二个参数 internal，默认为假。 内部逻辑如下： 如果钱包禁止私钥，则返回假。 if (IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) { return false; } 调用 ReserveKeyFromKeyPool 方法，从密钥池中取出一个密钥并获取其公钥。如果不成功，则生成数据库访问对象，然后调用 GenerateNewKey 方法，生成一个公钥。 if (!ReserveKeyFromKeyPool(nIndex, keypool, internal)) { if (IsLocked()) return false; WalletBatch batch(*database); result = GenerateNewKey(batch, internal); return true; } GenerateNewKey 这个方法，在创建钱包过程中，我们已经重点分析，这里不浪费口舌，我们重点看下 ReserveKeyFromKeyPool 方法。这个方法的执行流程如下： 生成一个公钥，并设置为密钥池的 vchPubKey 属性。 nIndex = -1; keypool.vchPubKey = CPubKey(); 如果钱包没有被锁，则填充密钥池。 if (!IsLocked()) TopUpKeyPool(); TopUpKeyPool 这个方法，我们也讲过，这里直接略过。 如果钱包启用了 HD，并且可以支持 HD 分割，并且参数 fRequestedInternal 为真，则设置变量 fReturningInternal 为真。在调用本方法时，这个参数没有指定，而默认为假，所以变量 fRequestedInternal 设置假。 bool fReturningInternal = IsHDEnabled() &amp;&amp; CanSupportFeature(FEATURE_HD_SPLIT) &amp;&amp; fRequestedInternal; 根据集合 set_pre_split_keypool 是否为空，设置变量 use_split_keypool 的值。因为这里 use_split_keypool 集合为空，所以变量 use_split_keypool 为真。 bool use_split_keypool = set_pre_split_keypool.empty(); 根据变量 use_split_keypool、fReturningInternal 确定从哪个集合中获取密钥池对象。根据上面分析，我们最终会从 setExternalKeyPool 集合中取数据。 std::set&lt;int64_t&gt;&amp; setKeyPool = use_split_keypool ? (fReturningInternal ? setInternalKeyPool : setExternalKeyPool) : set_pre_split_keypool; 如果要数据的集合为为空，则返回假。 if (setKeyPool.empty()) { return false; } 生成数据库访问对象。 WalletBatch batch(*database); 从 setKeyPool 取得其第一个元素，并从集合中删除它。 auto it = setKeyPool.begin(); nIndex = *it; setKeyPool.erase(it); 从数据库取得索引对应的密钥池。如果失败，则抛出异常。 if (!batch.ReadPool(nIndex, keypool)) { throw std::runtime_error(std::string(func) + “: read failed”); } 从密钥池中取得公钥对应的 ID，并且检测其是否在 mapKeys、或 mapCryptedKeys 集合之一，如果不在，则抛出异常。我们在创建钱包过程时候讲过，生成的私钥根据是否加密会保存在这两个集合之一。 if (!HaveKey(keypool.vchPubKey.GetID())) { throw std::runtime_error(std::string(func) + “: unknown key in key pool”); } 如果变量 use_split_keypool 为真，并且密钥池的 fInternal 属性不等于变量 fReturningInternal，那么抛出异常。 if (use_split_keypool &amp;&amp; keypool.fInternal != fReturningInternal) { throw std::runtime_error(std::string(func) + “: keypool entry misclassified”); } 如果密钥池中保存的公钥是无效的，那么抛出异常。 if (!keypool.vchPubKey.IsValid()) { throw std::runtime_error(std::string(func) + “: keypool entry invalid”); } 从 m_pool_key_to_index 集合中消除对应的索引。 m_pool_key_to_index.erase(keypool.vchPubKey.GetID()); 返回真。 调用 KeepKey 从密钥池中取出对应的公钥。","@type":"BlogPosting","url":"https://mlh.app/2018/12/15/87b17f64718816306e9b2d869aa1f9b2.html","headline":"币本社区-从零开始学习比特币开发：生成地址","dateModified":"2018-12-15T00:00:00+08:00","datePublished":"2018-12-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/12/15/87b17f64718816306e9b2d869aa1f9b2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>币本社区-从零开始学习比特币开发：生成地址</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>生成地址<br> 如果有人想发送比特币给你，或者你从别人那里买几个比特币，就要把地址给对方，对方才能把币打到你指定的地址上。那么，如何才能拥有一个地址呢，下面我们就来讲讲这个问题。<br> 比特币核心提供了很多 RPC 来供客户端调用，其中一个就是我们这里要讲的 getnewaddress 生成一个新的地址，通过这个 RPC ，我们就可以生成一个新的地址，有了这个地址，别人就可以给我们转账了。</p> 
  <p>getnewaddress RPC 可以接收两个参数，第一个地址的标签，第二个是地址的类型。如果没有提供标签，那么默认的标签就是空，地址的类型当前支持：legacy、p2sh-segwit、bech32，默认类型由 -addresstype 参数指定，当前为 p2sh-segwit。</p> 
  <p>如果我们想看下这个 RPC 的帮助文档，可以执行如下的命令：</p> 
  <p>./src/bitcoin-cli -regtest help getnewaddress<br> 就会显示帮助信息<br> 这个　RPC 对应的方法实现位于 src/wallet/rpcwallet.cpp 文件，方法名称就是 RPC 名称，下面我们来看这个方法。</p> 
  <p>生成地址流程<br> 根据请求参数获得对应的钱包。<br> std::shared_ptr const wallet = GetWalletForJSONRPCRequest(request);<br> CWallet* const pwallet = wallet.get();<br> GetWalletForJSONRPCRequest 方法内部实现如下：<br> 调用 GetWalletNameFromJSONRPCRequest 方法，从请求对象中取得钱包的名字，如果用户指定了钱包名字，那么把钱包名字保存在参数 wallet_name 上，并返回真，否则返回假。<br> 如果可以获得用户指定的钱包名称，则调用 GetWallet 方法，从钱包集合 vpwallets 中取得指定的钱包，然后返回钱包。<br> 如果用户没有指定钱包或指定的钱包不存在，那么调用 GetWallets 方法，返回钱包集合 vpwallets。如果钱包集合中只有一个钱包，或者在用户指定了帮助的情况下，至少有一个以上的钱包，那么返回第一个钱包，即默认的钱包。默认钱包在系统启动时候创建的。<br> 接下来，要确保钱包可用。如果钱包不可用，则直接 NullUniValue 对象。<br> if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {<br> return NullUniValue;<br> }<br> 如果指定了 help 参数或请求参数数量多于2个，则显示钱包的帮助信息。<br> 检查钱包是否设置了禁止私钥，即钱包是只读的 watch-only/pubkeys。如果是，则抛出异常。<br> if (pwallet-&gt;IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {<br> throw JSONRPCError(RPC_WALLET_ERROR, “Error: Private keys are disabled for this wallet”);<br> }<br> 如果指定了标签，则调用 LabelFromValue 方法，检查标签，确保其不是 *。如果是，则抛出异常。<br> std::string label;<br> if (!request.params[0].isNull())<br> label = LabelFromValue(request.params[0]);<br> 如果指定了地址类型，则调用 ParseOutputType 方法，检查地址类型，确保其是 legacy、p2sh-segwit、bech32 之一，如果不指定则默认是 p2sh-segwit，并把地址类型保存在 output_type 变量中。<br> OutputType output_type = pwallet-&gt;m_default_address_type;<br> if (!request.params[1].isNull()) {<br> if (!ParseOutputType(request.params[1].get_str(), output_type)) {<br> throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(“Unknown address type ‘%s’”, request.params[1].get_str()));<br> }<br> }<br> 如果钱包没有被锁定，则调用 TopUpKeyPool 方法填充密钥池。<br> if (!pwallet-&gt;IsLocked()) {<br> pwallet-&gt;TopUpKeyPool();<br> }<br> TopUpKeyPool 填充密钥这个方法，我们前面已经讲过，这里只简单解释下，不做详细分析。因为在衍生子钥的过程中，setExternalKeyPool、setInternalKeyPool 已经完全填充完了，所以导致 missingExternal、missingInternal 两个变量都为 0，从而不会重新再次衍生子密钥，所以实际上本方法在这里基本没有执行，而直接返回真。<br> 调用钱包的 GetKeyFromPool 方法，从密钥池中生成一个公钥。如果不能生成，则抛出异常。<br> CPubKey newKey;<br> if (!pwallet-&gt;GetKeyFromPool(newKey)) {<br> throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, “Error: Keypool ran out, please call keypoolrefill first”);<br> }<br> GetKeyFromPool 方法，我们在下面详细讲解，此处略过。<br> 调用钱包对象的 LearnRelatedScripts 方法，对公钥的脚本进行处理。方法内部执行如下：如果公钥是压缩的，并且地址类型是 p2sh-segwit，或者 bech32，那么：<br> 调用 WitnessV0KeyHash 方法，生成 WitnessV0KeyHash 对象。<br> CTxDestination witdest = WitnessV0KeyHash(key.GetID());<br> 调用 GetScriptForDestination 方法，获取对应的脚本。<br> CScript witprog = GetScriptForDestination(witdest);<br> GetScriptForDestination 方法内部调用 boost::apply_visitor(CScriptVisitor(&amp;script), dest)，以访问者模式来根据不同的 id，获取其对应的脚本对象。<br> CScriptVisitor 对象继承自 boost::static_visitor 对象，实现了访问者模式，并通过重载 () 操作符来定义不同类型的 id。</p> 
  <p>如果目标参数类型是 CNoDestination，则调用脚本对象的 script 方法，清除脚本内容。<br> 如果目标参数类型是 CKeyID，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(keyID) &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG。<br> 如果目标参数类型是 CScriptID，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(scriptID) &lt;&lt; OP_EQUAL。<br> 如果目标参数类型是 WitnessV0KeyHash，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_0 &lt;&lt; ToByteVector(id)。<br> 如果目标参数类型是 WitnessV0ScriptHash，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; OP_0 &lt;&lt; ToByteVector(id)。<br> 如果目标参数类型是 WitnessUnknown，则：首先调用脚本对象的 script 方法，清除脚本内容；然后，初始化脚本 *script &lt;&lt; CScript::EncodeOP_N(id.version) &lt;&lt; std::vector(id.program, id.program + id.length)。<br> 调用 AddCScript 方法，保存脚本对象。AddCScript 方法，首先调用 CCryptoKeyStore::AddCScript 方法，把脚本保存到 key store 的 mapScripts 集合中；然后，调用数据库访问对象的 WriteCScript 方法，以 cscript 为键把脚本保存到数据库中。<br> bool CWallet::AddCScript(const CScript&amp; redeemScript)<br> {<br> if (!CCryptoKeyStore::AddCScript(redeemScript))<br> return false;<br> return WalletBatch(*database).WriteCScript(Hash160(redeemScript), redeemScript);<br> }<br> 调用 GetDestinationForKey 方法，获取目的地 CTxDestination 对象。CTxDestination 是一个具有特定目标的交易输出脚本模板。定义如下：typedef boost::variant&lt;CNoDestination, CKeyID, CScriptID, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessUnknown&gt; CTxDestination，可能是以下几种类型之一：<br> CNoDestination没有目的地设置<br> CKeyIDP2PKH 目的<br> CScriptIDP2SH 目的<br> WitnessV0ScriptHashP2WSH 目的<br> WitnessV0KeyHashP2WPKH 目的<br> WitnessUnknown未知目的 P2W???<br> GetDestinationForKey 方法，使用 case 表达式来根据不同的地址类型，生成不同的目的 CTxDestination。<br> 如果地址类型是 legacy，则直接返回公钥的 KeyID。内部把公钥的数据通过 SHA256 和 RIPEMD160 双重哈希之后，构造一个 CKeyID 对象。<br> 如果地址类型是 p2sh-segwit，或 bech32，则处理如下：<br> 如果公钥不是压缩的，处理方法 legacy。<br> if (!key.IsCompressed()) return key.GetID();<br> 否则，生成 WitnessV0KeyHash 对象，然后调用 GetScriptForDestination 方法，获取对应的脚本，最后根据不同的地址类型生成的目的。<br> CTxDestination witdest = WitnessV0KeyHash(key.GetID());<br> CScript witprog = GetScriptForDestination(witdest);<br> if (type == OutputType::P2SH_SEGWIT) {<br> return CScriptID(witprog);<br> } else {<br> return witdest;<br> }<br> 对于默认的、不传地址类型的情况，就会返回 CScriptID 类型的 CTxDestination，这个返回值在下面两步中都会用到。<br> 调用钱包对象的 SetAddressBook 方法，来保存公钥地址。<br> pwallet-&gt;SetAddressBook(dest, label, “receive”);<br> SetAddressBook 方法执行如下：<br> 从 mapAddressBook 集合中，取得对应的目的数据。<br> std::map&lt;CTxDestination, CAddressBookData&gt;::iterator mi = mapAddressBook.find(address);<br> 根据集合中是否有对应的数据设置变量是否为更新。<br> fUpdated = mi != mapAddressBook.end();<br> 把标签保存为地址对应的 CAddressBookData 的 name 属性。<br> mapAddressBook[address].name = strName;<br> 如果参数 strPurpose 不空，则更新地址对应的 CAddressBookData 的 purpose 属性。<br> if (!strPurpose.empty()) mapAddressBook[address].purpose = strPurpose;<br> 调用数据库访问对象的 WritePurpose 方法，保存参数 strPurpose 到数据库中。<br> if (!strPurpose.empty() &amp;&amp; !WalletBatch(<em>database).WritePurpose(EncodeDestination(address), strPurpose))<br> return false;<br> 调用数据库访问对象的 WritePurpose 方法，保存地址到数据库中。<br> WalletBatch(<em>database).WriteName(EncodeDestination(address), strName);<br> strName 为用户提供的标签。EncodeDestination 方法，我们在下一步讲解。<br> 调用 EncodeDestination 方法，解码目的地址，并返回其结果。EncodeDestination 方法同样采用了访问者模式 return boost::apply_visitor(DestinationEncoder(Params()), dest)。DestinationEncoder 类继承了 boost::static_visitor，实现了访问者模式，通过重载 () 操作符来定义不同类型的 id。与前面相对应，这个方法会处理 CKeyID、CScriptID、WitnessV0KeyHash、WitnessV0ScriptHash、WitnessUnknown 这几种不同情况。对于我们的默认情况来说，目的地址类型为 CScriptID，下面我们就看下这种情况的处理，其他情况可自行阅读。<br> 调用当前网络参数的 Base58Prefix 方法，返回脚本前缀。<br> std::vector data = m_params.Base58Prefix(CChainParams::SCRIPT_ADDRESS);<br> 对于主网络前缀是 5，测试网络是 196，回归测试网络是 196。<br> 把当前 20 个字节的数据加在前缀后面形成 21 个字节的字符串。<br> data.insert(data.end(), id.begin(), id.end());<br> 调用 EncodeBase58Check 方法，编码成 Base58Check 格式，并返回其值。<br> return EncodeBase58Check(data);<br> 下面，我们来看下 EncodeBase58Check 这个方法的处理。它的内部执行流程如下：用 21 个字节的字符串生成一个向量，同时调用 Hash 方法，生成一个 32 字节长的哈希字符串；然后把其最前面的 4个字节作为校验各加在 21 个字节的向量尾部，从而生成一个长度为 25个字节的字符串；最后，调用 EncodeBase58 方法，进行 Base58 编码。<br> std::vector vch(vchIn);<br> uint256 hash = Hash(vch.begin(), vch.end());<br> vch.insert(vch.end(), (unsigned char</em>)&amp;hash, (unsigned char</em>)&amp;hash + 4);<br> return EncodeBase58(vch);<br> 在 Hash 这个方法中，使用了双重 SHA256 哈希算法。EncodeBase58 这个方法，读者可以自行阅读，这里不再展开。<br> GetKeyFromPool 从密钥池中获取公钥<br> 本方法从密钥池中生成一个公钥。第一个参数为公钥的引用，第二个参数 internal，默认为假。<br> 内部逻辑如下：</p> 
  <p>如果钱包禁止私钥，则返回假。<br> if (IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {<br> return false;<br> }<br> 调用 ReserveKeyFromKeyPool 方法，从密钥池中取出一个密钥并获取其公钥。如果不成功，则生成数据库访问对象，然后调用 GenerateNewKey 方法，生成一个公钥。<br> if (!ReserveKeyFromKeyPool(nIndex, keypool, internal)) {<br> if (IsLocked()) return false;<br> WalletBatch batch(*database);<br> result = GenerateNewKey(batch, internal);<br> return true;<br> }<br> GenerateNewKey 这个方法，在创建钱包过程中，我们已经重点分析，这里不浪费口舌，我们重点看下 ReserveKeyFromKeyPool 方法。这个方法的执行流程如下：<br> 生成一个公钥，并设置为密钥池的 vchPubKey 属性。<br> nIndex = -1;<br> keypool.vchPubKey = CPubKey();<br> 如果钱包没有被锁，则填充密钥池。<br> if (!IsLocked())<br> TopUpKeyPool();<br> TopUpKeyPool 这个方法，我们也讲过，这里直接略过。<br> 如果钱包启用了 HD，并且可以支持 HD 分割，并且参数 fRequestedInternal 为真，则设置变量 fReturningInternal 为真。在调用本方法时，这个参数没有指定，而默认为假，所以变量 fRequestedInternal 设置假。<br> bool fReturningInternal = IsHDEnabled() &amp;&amp; CanSupportFeature(FEATURE_HD_SPLIT) &amp;&amp; fRequestedInternal;<br> 根据集合 set_pre_split_keypool 是否为空，设置变量 use_split_keypool 的值。因为这里 use_split_keypool 集合为空，所以变量 use_split_keypool 为真。<br> bool use_split_keypool = set_pre_split_keypool.empty();<br> 根据变量 use_split_keypool、fReturningInternal 确定从哪个集合中获取密钥池对象。根据上面分析，我们最终会从 setExternalKeyPool 集合中取数据。<br> std::set&lt;int64_t&gt;&amp; setKeyPool = use_split_keypool ? (fReturningInternal ? setInternalKeyPool : setExternalKeyPool) : set_pre_split_keypool;<br> 如果要数据的集合为为空，则返回假。<br> if (setKeyPool.empty()) {<br> return false;<br> }<br> 生成数据库访问对象。<br> WalletBatch batch(*database);<br> 从 setKeyPool 取得其第一个元素，并从集合中删除它。<br> auto it = setKeyPool.begin();<br> nIndex = *it;<br> setKeyPool.erase(it);<br> 从数据库取得索引对应的密钥池。如果失败，则抛出异常。<br> if (!batch.ReadPool(nIndex, keypool)) {<br> throw std::runtime_error(std::string(<strong>func</strong>) + “: read failed”);<br> }<br> 从密钥池中取得公钥对应的 ID，并且检测其是否在 mapKeys、或 mapCryptedKeys 集合之一，如果不在，则抛出异常。我们在创建钱包过程时候讲过，生成的私钥根据是否加密会保存在这两个集合之一。<br> if (!HaveKey(keypool.vchPubKey.GetID())) {<br> throw std::runtime_error(std::string(<strong>func</strong>) + “: unknown key in key pool”);<br> }<br> 如果变量 use_split_keypool 为真，并且密钥池的 fInternal 属性不等于变量 fReturningInternal，那么抛出异常。<br> if (use_split_keypool &amp;&amp; keypool.fInternal != fReturningInternal) {<br> throw std::runtime_error(std::string(<strong>func</strong>) + “: keypool entry misclassified”);<br> }<br> 如果密钥池中保存的公钥是无效的，那么抛出异常。<br> if (!keypool.vchPubKey.IsValid()) {<br> throw std::runtime_error(std::string(<strong>func</strong>) + “: keypool entry invalid”);<br> }<br> 从 m_pool_key_to_index 集合中消除对应的索引。<br> m_pool_key_to_index.erase(keypool.vchPubKey.GetID());<br> 返回真。<br> 调用 KeepKey<br> 从密钥池中取出对应的公钥。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
