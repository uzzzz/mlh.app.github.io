<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>学习贝叶斯算法的五个步骤 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="学习贝叶斯算法的五个步骤" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。 而朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。 本文将通过6个步骤带领你学习朴素贝叶斯算法。 Step1 什么是朴素贝叶斯算法 朴素贝叶斯算法是一种基于贝叶斯定理的分类技术，假设在预测变量之间具有独立性。 给定一个水果，如果水果是黄色的，圆形的，直径约30厘米，则可以认为它是橘子。 即使对于橘子描述的这些特征彼此依赖或依赖于其他特征的存在，但所有的这些特征都促成了这个水果是橘子的可能性，这就是它被称为“朴素”的原因。 朴素贝叶斯模型易于构建，特别适用于非常大的数据集。 贝叶斯定理提供了一种从P（c），P（x）和P（x | c）计算后验概率P（c | x）的方法。 请看下面的等式： ·P（c | x）是给定预测值（x，属性）的类（c，目标）的后验概率。 ·P（c ）是先验概率。 ·P（x | c）是给定类别的预测概率的似然性。 ·P（x）是预测的先验概率。 简单来说，贝叶斯定理是基于假设的先验概率、给定假设下观察到不同数据的概率，提供了一种计算后验概率的方法。 Step2 朴素贝叶斯算法如何工作 让我们用一个例子来理解它。下面有一个关于天气和空气质量的训练数据集，根据天气记录的空气质量的好坏。 现在，我们需要根据天气情况对空气质量的好坏进行分类。 第1步：将数据集转换为频率表。 第2步：通过找到阴天概率= 0.28和空气质量好概率为0.64的概率来创建似然表。 第3步：现在，使用朴素贝叶斯方程计算每个类的后验概率。具有最高后验概率的类是预测的结果。 问题：如果天气晴朗，空气质量会是好。这个陈述是正确的吗？ 我们可以使用上面讨论的后验概率方法来解决它。 ·P（好|晴天）= P（晴天|好）* P（好）/ P（晴天） ·P（晴天|好）= 3/9 = 0.33 ·P（晴天）= 5/14 = 0.36 ·P（好）= 9/14 = 0.64 ·P（好| 晴天）= 0.33 *0.64 / 0.36 = 0.60 得出结论，天气晴朗空气质量好具有更高的概率。 NaiveBayes使用类似的方法根据各种属性预测不同类别的概率。该算法主要用于文本分类，并且具有多个类的问题。 Step3 朴素贝叶斯的优点和缺点 优点 1）预测测试数据集很容易也很快，在多类预测中表现良好。 2）算法简单，常用于文本分类。 3）朴素贝叶斯模型有稳定的分类效率。 4）适合增量式训练，尤其是数据量超出内存时，可以一批批的去增量训练。 缺点 1）如果分类变量具有在训练数据集中未观察到的类别，则模型将指定0（零）概率并且将无法进行预测。 2）独立预测因子的假设无法实现，我们几乎不可能得到一组完全独立的预测变量。 3）需要知道先验概率，且先验概率很多时候取决于假设。 4）通过先验和数据来决定后验的概率从而决定分类，所以分类决策存在一定的错误率。 5）对输入数据的表达形式很敏感。 step4 朴素贝叶斯算法的应用 1、实时预测 朴素贝叶斯是一个非常快速的学习分类器，因此，它可以用于实时预测。 2、多类预测 可以预测多类目标变量的概率。 3、文本分类/垃圾邮件过滤/情感分析 朴素贝叶斯分类器对于多类问题和独立性规则具有更高的成功率，因此，它被广泛用于文本分类、垃圾邮件过滤和情感分析。 4、推荐系统 朴素贝叶斯分类器和协同过滤一起构建一个推荐系统，这有助于预测用户是否愿意提供资源。 Step5 在Python中使用Naive Bayes构建基本模型 同样，scikit learn（python库）将帮助在这里用Python构建Naive Bayes模型。在scikit学习库下有三种类型的朴素贝叶斯模型： -高斯模型 它用于分类，假设特征属于某个类别的观测值符合高斯分布。在处理连续的特征变量时，采用高斯模型。 -多项式模型 用于离散计数。例如，假设我们有文本分类问题。在这里我们可以考虑更进一步的bernoulli试验，而不是“在文档中出现的单词”，我们“计算文档中出现单词的频率”，你可以将其视为“观察到结果数x_i的次数”超过n次试验“。 -伯努利模型 与多项式模型一样，伯努利模型适用于离散特征的情况，所不同的是，伯努利模型中每个特征的取值只能是1和0(以文本分类为例，某个单词在文档中出现过，则其特征值为1，否则为0). 根据你的数据集，您可以选择上面讨论的任何模型。以下是高斯模型的示例。 Python 代码 #从高斯朴素贝叶斯模型到入库 sklearn. naive _ bayes 中导入 GaussianNB import numpy as np #分配预测变量和目标变量 x= np.array([[-3,7],[1,5], [1,2], [-2,0],[2,3], [-4,0], [-1,1], [1,1], [-2,2], [2,7], [-4,1], [-2,7]]) Y = np.array([3, 3, 3, 3, 4, 3, 3, 4, 3, 4,4, 4]) #创建高斯分类器 model = GaussianNB()# 使用训练集训练模型 model.fit(x, y) #预测输出 predicted= model.predict([[1,2],[3,4]]) print predicted Output: ([3,4]) 以上就是学习朴素贝叶斯的五个简单步骤，现在就开始学习吧！ 欢迎关注公众号：DC学习助手，探索数据科学之旅" />
<meta property="og:description" content="贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。 而朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。 本文将通过6个步骤带领你学习朴素贝叶斯算法。 Step1 什么是朴素贝叶斯算法 朴素贝叶斯算法是一种基于贝叶斯定理的分类技术，假设在预测变量之间具有独立性。 给定一个水果，如果水果是黄色的，圆形的，直径约30厘米，则可以认为它是橘子。 即使对于橘子描述的这些特征彼此依赖或依赖于其他特征的存在，但所有的这些特征都促成了这个水果是橘子的可能性，这就是它被称为“朴素”的原因。 朴素贝叶斯模型易于构建，特别适用于非常大的数据集。 贝叶斯定理提供了一种从P（c），P（x）和P（x | c）计算后验概率P（c | x）的方法。 请看下面的等式： ·P（c | x）是给定预测值（x，属性）的类（c，目标）的后验概率。 ·P（c ）是先验概率。 ·P（x | c）是给定类别的预测概率的似然性。 ·P（x）是预测的先验概率。 简单来说，贝叶斯定理是基于假设的先验概率、给定假设下观察到不同数据的概率，提供了一种计算后验概率的方法。 Step2 朴素贝叶斯算法如何工作 让我们用一个例子来理解它。下面有一个关于天气和空气质量的训练数据集，根据天气记录的空气质量的好坏。 现在，我们需要根据天气情况对空气质量的好坏进行分类。 第1步：将数据集转换为频率表。 第2步：通过找到阴天概率= 0.28和空气质量好概率为0.64的概率来创建似然表。 第3步：现在，使用朴素贝叶斯方程计算每个类的后验概率。具有最高后验概率的类是预测的结果。 问题：如果天气晴朗，空气质量会是好。这个陈述是正确的吗？ 我们可以使用上面讨论的后验概率方法来解决它。 ·P（好|晴天）= P（晴天|好）* P（好）/ P（晴天） ·P（晴天|好）= 3/9 = 0.33 ·P（晴天）= 5/14 = 0.36 ·P（好）= 9/14 = 0.64 ·P（好| 晴天）= 0.33 *0.64 / 0.36 = 0.60 得出结论，天气晴朗空气质量好具有更高的概率。 NaiveBayes使用类似的方法根据各种属性预测不同类别的概率。该算法主要用于文本分类，并且具有多个类的问题。 Step3 朴素贝叶斯的优点和缺点 优点 1）预测测试数据集很容易也很快，在多类预测中表现良好。 2）算法简单，常用于文本分类。 3）朴素贝叶斯模型有稳定的分类效率。 4）适合增量式训练，尤其是数据量超出内存时，可以一批批的去增量训练。 缺点 1）如果分类变量具有在训练数据集中未观察到的类别，则模型将指定0（零）概率并且将无法进行预测。 2）独立预测因子的假设无法实现，我们几乎不可能得到一组完全独立的预测变量。 3）需要知道先验概率，且先验概率很多时候取决于假设。 4）通过先验和数据来决定后验的概率从而决定分类，所以分类决策存在一定的错误率。 5）对输入数据的表达形式很敏感。 step4 朴素贝叶斯算法的应用 1、实时预测 朴素贝叶斯是一个非常快速的学习分类器，因此，它可以用于实时预测。 2、多类预测 可以预测多类目标变量的概率。 3、文本分类/垃圾邮件过滤/情感分析 朴素贝叶斯分类器对于多类问题和独立性规则具有更高的成功率，因此，它被广泛用于文本分类、垃圾邮件过滤和情感分析。 4、推荐系统 朴素贝叶斯分类器和协同过滤一起构建一个推荐系统，这有助于预测用户是否愿意提供资源。 Step5 在Python中使用Naive Bayes构建基本模型 同样，scikit learn（python库）将帮助在这里用Python构建Naive Bayes模型。在scikit学习库下有三种类型的朴素贝叶斯模型： -高斯模型 它用于分类，假设特征属于某个类别的观测值符合高斯分布。在处理连续的特征变量时，采用高斯模型。 -多项式模型 用于离散计数。例如，假设我们有文本分类问题。在这里我们可以考虑更进一步的bernoulli试验，而不是“在文档中出现的单词”，我们“计算文档中出现单词的频率”，你可以将其视为“观察到结果数x_i的次数”超过n次试验“。 -伯努利模型 与多项式模型一样，伯努利模型适用于离散特征的情况，所不同的是，伯努利模型中每个特征的取值只能是1和0(以文本分类为例，某个单词在文档中出现过，则其特征值为1，否则为0). 根据你的数据集，您可以选择上面讨论的任何模型。以下是高斯模型的示例。 Python 代码 #从高斯朴素贝叶斯模型到入库 sklearn. naive _ bayes 中导入 GaussianNB import numpy as np #分配预测变量和目标变量 x= np.array([[-3,7],[1,5], [1,2], [-2,0],[2,3], [-4,0], [-1,1], [1,1], [-2,2], [2,7], [-4,1], [-2,7]]) Y = np.array([3, 3, 3, 3, 4, 3, 3, 4, 3, 4,4, 4]) #创建高斯分类器 model = GaussianNB()# 使用训练集训练模型 model.fit(x, y) #预测输出 predicted= model.predict([[1,2],[3,4]]) print predicted Output: ([3,4]) 以上就是学习朴素贝叶斯的五个简单步骤，现在就开始学习吧！ 欢迎关注公众号：DC学习助手，探索数据科学之旅" />
<link rel="canonical" href="https://mlh.app/2018/12/19/b9b8a37ffc9abb1a97c59a82e4ea3dbe.html" />
<meta property="og:url" content="https://mlh.app/2018/12/19/b9b8a37ffc9abb1a97c59a82e4ea3dbe.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-12-19T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。 而朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。 本文将通过6个步骤带领你学习朴素贝叶斯算法。 Step1 什么是朴素贝叶斯算法 朴素贝叶斯算法是一种基于贝叶斯定理的分类技术，假设在预测变量之间具有独立性。 给定一个水果，如果水果是黄色的，圆形的，直径约30厘米，则可以认为它是橘子。 即使对于橘子描述的这些特征彼此依赖或依赖于其他特征的存在，但所有的这些特征都促成了这个水果是橘子的可能性，这就是它被称为“朴素”的原因。 朴素贝叶斯模型易于构建，特别适用于非常大的数据集。 贝叶斯定理提供了一种从P（c），P（x）和P（x | c）计算后验概率P（c | x）的方法。 请看下面的等式： ·P（c | x）是给定预测值（x，属性）的类（c，目标）的后验概率。 ·P（c ）是先验概率。 ·P（x | c）是给定类别的预测概率的似然性。 ·P（x）是预测的先验概率。 简单来说，贝叶斯定理是基于假设的先验概率、给定假设下观察到不同数据的概率，提供了一种计算后验概率的方法。 Step2 朴素贝叶斯算法如何工作 让我们用一个例子来理解它。下面有一个关于天气和空气质量的训练数据集，根据天气记录的空气质量的好坏。 现在，我们需要根据天气情况对空气质量的好坏进行分类。 第1步：将数据集转换为频率表。 第2步：通过找到阴天概率= 0.28和空气质量好概率为0.64的概率来创建似然表。 第3步：现在，使用朴素贝叶斯方程计算每个类的后验概率。具有最高后验概率的类是预测的结果。 问题：如果天气晴朗，空气质量会是好。这个陈述是正确的吗？ 我们可以使用上面讨论的后验概率方法来解决它。 ·P（好|晴天）= P（晴天|好）* P（好）/ P（晴天） ·P（晴天|好）= 3/9 = 0.33 ·P（晴天）= 5/14 = 0.36 ·P（好）= 9/14 = 0.64 ·P（好| 晴天）= 0.33 *0.64 / 0.36 = 0.60 得出结论，天气晴朗空气质量好具有更高的概率。 NaiveBayes使用类似的方法根据各种属性预测不同类别的概率。该算法主要用于文本分类，并且具有多个类的问题。 Step3 朴素贝叶斯的优点和缺点 优点 1）预测测试数据集很容易也很快，在多类预测中表现良好。 2）算法简单，常用于文本分类。 3）朴素贝叶斯模型有稳定的分类效率。 4）适合增量式训练，尤其是数据量超出内存时，可以一批批的去增量训练。 缺点 1）如果分类变量具有在训练数据集中未观察到的类别，则模型将指定0（零）概率并且将无法进行预测。 2）独立预测因子的假设无法实现，我们几乎不可能得到一组完全独立的预测变量。 3）需要知道先验概率，且先验概率很多时候取决于假设。 4）通过先验和数据来决定后验的概率从而决定分类，所以分类决策存在一定的错误率。 5）对输入数据的表达形式很敏感。 step4 朴素贝叶斯算法的应用 1、实时预测 朴素贝叶斯是一个非常快速的学习分类器，因此，它可以用于实时预测。 2、多类预测 可以预测多类目标变量的概率。 3、文本分类/垃圾邮件过滤/情感分析 朴素贝叶斯分类器对于多类问题和独立性规则具有更高的成功率，因此，它被广泛用于文本分类、垃圾邮件过滤和情感分析。 4、推荐系统 朴素贝叶斯分类器和协同过滤一起构建一个推荐系统，这有助于预测用户是否愿意提供资源。 Step5 在Python中使用Naive Bayes构建基本模型 同样，scikit learn（python库）将帮助在这里用Python构建Naive Bayes模型。在scikit学习库下有三种类型的朴素贝叶斯模型： -高斯模型 它用于分类，假设特征属于某个类别的观测值符合高斯分布。在处理连续的特征变量时，采用高斯模型。 -多项式模型 用于离散计数。例如，假设我们有文本分类问题。在这里我们可以考虑更进一步的bernoulli试验，而不是“在文档中出现的单词”，我们“计算文档中出现单词的频率”，你可以将其视为“观察到结果数x_i的次数”超过n次试验“。 -伯努利模型 与多项式模型一样，伯努利模型适用于离散特征的情况，所不同的是，伯努利模型中每个特征的取值只能是1和0(以文本分类为例，某个单词在文档中出现过，则其特征值为1，否则为0). 根据你的数据集，您可以选择上面讨论的任何模型。以下是高斯模型的示例。 Python 代码 #从高斯朴素贝叶斯模型到入库 sklearn. naive _ bayes 中导入 GaussianNB import numpy as np #分配预测变量和目标变量 x= np.array([[-3,7],[1,5], [1,2], [-2,0],[2,3], [-4,0], [-1,1], [1,1], [-2,2], [2,7], [-4,1], [-2,7]]) Y = np.array([3, 3, 3, 3, 4, 3, 3, 4, 3, 4,4, 4]) #创建高斯分类器 model = GaussianNB()# 使用训练集训练模型 model.fit(x, y) #预测输出 predicted= model.predict([[1,2],[3,4]]) print predicted Output: ([3,4]) 以上就是学习朴素贝叶斯的五个简单步骤，现在就开始学习吧！ 欢迎关注公众号：DC学习助手，探索数据科学之旅","@type":"BlogPosting","url":"https://mlh.app/2018/12/19/b9b8a37ffc9abb1a97c59a82e4ea3dbe.html","headline":"学习贝叶斯算法的五个步骤","dateModified":"2018-12-19T00:00:00+08:00","datePublished":"2018-12-19T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/12/19/b9b8a37ffc9abb1a97c59a82e4ea3dbe.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>学习贝叶斯算法的五个步骤</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="show-content-free"> 
   <p>贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。</p> 
   <p>而朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。</p> 
   <p>本文将通过6个步骤带领你学习朴素贝叶斯算法。</p> 
   <p><strong>Step1</strong></p> 
   <p>什么是朴素贝叶斯算法</p> 
   <p>朴素贝叶斯算法是一种基于贝叶斯定理的分类技术，假设在预测变量之间具有独立性。</p> 
   <p>给定一个水果，如果水果是黄色的，圆形的，直径约30厘米，则可以认为它是橘子。</p> 
   <p>即使对于橘子描述的这些特征彼此依赖或依赖于其他特征的存在，但所有的这些特征都促成了这个水果是橘子的可能性，这就是它被称为“朴素”的原因。</p> 
   <p>朴素贝叶斯模型易于构建，特别适用于非常大的数据集。</p> 
   <p>贝叶斯定理提供了一种从P（c），P（x）和P（x | c）计算后验概率P（c | x）的方法。</p> 
   <p>请看下面的等式：</p> 
   <div class="image-package"> 
    <div class="image-container"> 
     <div class="image-container-fill"></div> 
     <div class="image-view">
      <img src="https://upload-images.jianshu.io/upload_images/8134750-f63a41b1f28575d6" alt="8134750-f63a41b1f28575d6">
     </div> 
    </div> 
    <div class="image-caption"></div> 
   </div> 
   <p>·P（c | x）是给定预测值（x，属性）的类（c，目标）的后验概率。</p> 
   <p>·P（c ）是先验概率。</p> 
   <p>·P（x | c）是给定类别的预测概率的似然性。</p> 
   <p>·P（x）是预测的先验概率。</p> 
   <p>简单来说，贝叶斯定理是基于假设的先验概率、给定假设下观察到不同数据的概率，提供了一种计算后验概率的方法。</p> 
   <p><strong>Step2</strong></p> 
   <p>朴素贝叶斯算法如何工作</p> 
   <p>让我们用一个例子来理解它。下面有一个关于天气和空气质量的训练数据集，根据天气记录的空气质量的好坏。</p> 
   <p>现在，我们需要根据天气情况对空气质量的好坏进行分类。</p> 
   <p>第1步：将数据集转换为频率表。</p> 
   <p>第2步：通过找到阴天概率= 0.28和空气质量好概率为0.64的概率来创建似然表。</p> 
   <div class="image-package"> 
    <div class="image-container"> 
     <div class="image-container-fill"></div> 
     <div class="image-view">
      <img src="https://upload-images.jianshu.io/upload_images/8134750-fe973067f776c527" alt="8134750-fe973067f776c527">
     </div> 
    </div> 
    <div class="image-caption"></div> 
   </div> 
   <p>第3步：现在，使用朴素贝叶斯方程计算每个类的后验概率。具有最高后验概率的类是预测的结果。</p> 
   <p>问题：如果天气晴朗，空气质量会是好。这个陈述是正确的吗？</p> 
   <p>我们可以使用上面讨论的后验概率方法来解决它。</p> 
   <p>·P（好|晴天）= P（晴天|好）* P（好）/ P（晴天）</p> 
   <p>·P（晴天|好）= 3/9 = 0.33</p> 
   <p>·P（晴天）= 5/14 = 0.36</p> 
   <p>·P（好）= 9/14 = 0.64</p> 
   <p>·P（好| 晴天）= 0.33 *0.64 / 0.36 = 0.60</p> 
   <p>得出结论，天气晴朗空气质量好具有更高的概率。</p> 
   <p>NaiveBayes使用类似的方法根据各种属性预测不同类别的概率。该算法主要用于文本分类，并且具有多个类的问题。</p> 
   <p><strong>Step3</strong></p> 
   <p>朴素贝叶斯的优点和缺点</p> 
   <p><strong>优点</strong></p> 
   <p>1）预测测试数据集很容易也很快，在多类预测中表现良好。</p> 
   <p>2）算法简单，常用于文本分类。</p> 
   <p>3）朴素贝叶斯模型有稳定的分类效率。</p> 
   <p>4）适合增量式训练，尤其是数据量超出内存时，可以一批批的去增量训练。</p> 
   <p><strong>缺点</strong></p> 
   <p>1）如果分类变量具有在训练数据集中未观察到的类别，则模型将指定0（零）概率并且将无法进行预测。</p> 
   <p>2）独立预测因子的假设无法实现，我们几乎不可能得到一组完全独立的预测变量。</p> 
   <p>3）需要知道先验概率，且先验概率很多时候取决于假设。</p> 
   <p>4）通过先验和数据来决定后验的概率从而决定分类，所以分类决策存在一定的错误率。</p> 
   <p>5）对输入数据的表达形式很敏感。</p> 
   <p><strong>step4</strong></p> 
   <p>朴素贝叶斯算法的应用</p> 
   <p>1、实时预测</p> 
   <p>朴素贝叶斯是一个非常快速的学习分类器，因此，它可以用于实时预测。</p> 
   <p>2、多类预测</p> 
   <p>可以预测多类目标变量的概率。</p> 
   <p>3、文本分类/垃圾邮件过滤/情感分析</p> 
   <p>朴素贝叶斯分类器对于多类问题和独立性规则具有更高的成功率，因此，它被广泛用于文本分类、垃圾邮件过滤和情感分析。</p> 
   <p>4、推荐系统</p> 
   <p>朴素贝叶斯分类器和协同过滤一起构建一个推荐系统，这有助于预测用户是否愿意提供资源。</p> 
   <p><strong>Step5</strong></p> 
   <p>在Python中使用Naive Bayes构建基本模型</p> 
   <p>同样，scikit learn（python库）将帮助在这里用Python构建Naive Bayes模型。在scikit学习库下有三种类型的朴素贝叶斯模型：</p> 
   <p>-高斯模型</p> 
   <p>它用于分类，假设特征属于某个类别的观测值符合高斯分布。在处理连续的特征变量时，采用高斯模型。</p> 
   <p>-多项式模型</p> 
   <p>用于离散计数。例如，假设我们有文本分类问题。在这里我们可以考虑更进一步的bernoulli试验，而不是“在文档中出现的单词”，我们“计算文档中出现单词的频率”，你可以将其视为“观察到结果数x_i的次数”超过n次试验“。</p> 
   <p>-伯努利模型</p> 
   <p>与多项式模型一样，伯努利模型适用于离散特征的情况，所不同的是，伯努利模型中每个特征的取值只能是1和0(以文本分类为例，某个单词在文档中出现过，则其特征值为1，否则为0).</p> 
   <p>根据你的数据集，您可以选择上面讨论的任何模型。以下是高斯模型的示例。</p> 
   <p>Python 代码</p> 
   <pre><code>#从高斯朴素贝叶斯模型到入库
sklearn. naive _ bayes 中导入 GaussianNB
import numpy as np
#分配预测变量和目标变量
x= np.array([[-3,7],[1,5], [1,2], [-2,0],[2,3], [-4,0], [-1,1], [1,1], [-2,2], [2,7], [-4,1], [-2,7]])
Y = np.array([3, 3, 3, 3, 4, 3, 3, 4, 3, 4,4, 4])
#创建高斯分类器
model = GaussianNB()# 使用训练集训练模型
model.fit(x, y)
#预测输出
predicted= model.predict([[1,2],[3,4]])
print predicted
Output: ([3,4])
</code></pre> 
   <p>以上就是学习朴素贝叶斯的五个简单步骤，现在就开始学习吧！</p> 
   <p>欢迎关注公众号：DC学习助手，探索数据科学之旅</p> 
  </div> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
