<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>用Go来做以太坊开发④智能合约 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="用Go来做以太坊开发④智能合约" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="智能合约 在这个章节中我们会介绍如何用Go来编译，部署，写入和读取智能合约。 智能合约的编译与ABI 与智能合约交互，我们要先生成相应智能合约的应用二进制接口ABI(application binary interface)，并把ABI编译成我们可以在Go应用中调用的格式。 第一步是安装 Solidity编译器 (solc). Solc 在Ubuntu上有snapcraft包。 sudo snap install solc --edge Solc在macOS上有Homebrew的包。 brew update brew tap ethereum/ethereum brew install solidity 其他的平台或者从源码编译的教程请查阅官方solidity文档install guide. 我们还得安装一个叫abigen的工具，来从solidity智能合约生成ABI。 假设您已经在计算机上设置了Go，只需运行以下命令即可安装abigen工具。 go get -u github.com/ethereum/go-ethereum cd $GOPATH/src/github.com/ethereum/go-ethereum/ make make devtools 我们将创建一个简单的智能合约来测试。 学习更复杂的智能合约，或者智能合约的开发的内容则超出了本书的范围。 我强烈建议您查看truffle framework 来学习开发和测试智能合约。 这里只是一个简单的合约，就是一个键/值存储，只有一个外部方法来设置任何人的键/值对。 我们还在设置值后添加了要发出的事件。 pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } 虽然这个智能合约很简单，但它将适用于这个例子。 现在我们可以从一个solidity文件生成ABI。 solc --abi Store.sol 它会将其写入名为“Store_sol_Store.abi”的文件中 现在让我们用abigen将ABI转换为我们可以导入的Go文件。 这个新文件将包含我们可以用来与Go应用程序中的智能合约进行交互的所有可用方法。 abigen --abi=Store_sol_Store.abi --pkg=store --out=Store.go 为了从Go部署智能合约，我们还需要将solidity智能合约编译为EVM字节码。 EVM字节码将在事务的数据字段中发送。 在Go文件上生成部署方法需要bin文件。 solc --bin Store.sol 现在我们编译Go合约文件，其中包括deploy方法，因为我们包含了bin文件。 abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go 在接下来的课程中，我们将学习如何部署智能合约，然后与之交互。 完整代码 Commands go get -u github.com/ethereum/go-ethereum cd $GOPATH/src/github.com/ethereum/go-ethereum/ make make devtools solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 部署智能合约 如果你还没看之前的章节，请先学习编译智能合约的章节因为这节内容，需要先了解如何将智能合约编译为Go文件。 假设你已经导入从abigen生成的新创建的Go包文件，并设置ethclient，加载您的私钥，下一步是创建一个有配置密匙的交易发送器(tansactor)。 首先从go-ethereum导入accounts/abi/bind包，然后调用传入私钥的NewKeyedTransactor。 然后设置通常的属性，如nonce，燃气价格，燃气上线限制和ETH值。 auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice 如果你还记得上个章节的内容, 我们创建了一个非常简单的“Store”合约，用于设置和存储键/值对。 生成的Go合约文件提供了部署方法。 部署方法名称始终以单词Deploy开头，后跟合约名称，在本例中为Store。 deploy函数接受有密匙的事务处理器，ethclient，以及智能合约构造函数可能接受的任何输入参数。我们测试的智能合约接受一个版本号的字符串参数。 此函数将返回新部署的合约地址，事务对象，我们可以交互的合约实例，还有错误（如果有）。 input := &quot;1.0&quot; address, tx, instance, err := store.DeployStore(auth, client, input) if err != nil { log.Fatal(err) } fmt.Println(address.Hex()) // 0x147B8eb97fD247D06C4006D269c90C1908Fb5D54 fmt.Println(tx.Hash().Hex()) // 0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0 _ = instance // will be using the instance in the 下个章节 就这么简单：）你可以用事务哈希来在Etherscan上查询合约的部署状态: https://rinkeby.etherscan.io/tx/0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_deploy.go package main import ( &quot;context&quot; &quot;crypto/ecdsa&quot; &quot;fmt&quot; &quot;log&quot; &quot;math/big&quot; &quot;github.com/ethereum/go-ethereum/accounts/abi/bind&quot; &quot;github.com/ethereum/go-ethereum/crypto&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } privateKey, err := crypto.HexToECDSA(&quot;fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19&quot;) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(&quot;error casting public key to ECDSA&quot;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice input := &quot;1.0&quot; address, tx, instance, err := store.DeployStore(auth, client, input) if err != nil { log.Fatal(err) } fmt.Println(address.Hex()) // 0x147B8eb97fD247D06C4006D269c90C1908Fb5D54 fmt.Println(tx.Hash().Hex()) // 0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0 _ = instance } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 加载智能合约 这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读上一个章节 。 一旦使用abigen工具将智能合约的ABI编译为Go包，下一步就是调用“New”方法，其格式为“New&lt;contractname style=&quot;box-sizing: border-box; font-size: 16px; -ms-text-size-adjust: auto; -webkit-tap-highlight-color: transparent;&quot;&gt;”，所以在我们的例子中如果你 回想一下它将是NewStore。 此初始化方法接收智能合约的地址，并返回可以开始与之交互的合约实例。&lt;/contractname&gt; address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } _ = instance // we&#39;ll be using this in the 下个章节 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_load.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } fmt.Println(&quot;contract is loaded&quot;) _ = instance } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 查询智能合约 Querying a Smart Contract 这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读上一个章节 。 在上个章节我们学习了如何在Go应用程序中初始化合约实例。 现在我们将使用新合约实例提供的方法来阅读智能合约。 如果你还记得我们在部署过程中设置的合约中有一个名为version的全局变量。 因为它是公开的，这意味着它们将成为我们自动创建的getter函数。 常量和view函数也接受bind.CallOpts作为第一个参数。了解可用的具体选项要看相应类的文档 一般情况下我们可以用 nil。 version, err := instance.Version(nil) if err != nil { log.Fatal(err) } fmt.Println(version) // &quot;1.0&quot; 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_read.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } version, err := instance.Version(nil) if err != nil { log.Fatal(err) } fmt.Println(version) // &quot;1.0&quot; } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 写入智能合约 这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读上一个章节 。 写入智能合约需要我们用私钥来对交易事务进行签名。 privateKey, err := crypto.HexToECDSA(&quot;fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19&quot;) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(&quot;error casting public key to ECDSA&quot;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) 我们还需要先查到nonce和燃气价格。 nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } 接下来，我们创建一个新的keyed transactor，它接收私钥。 auth := bind.NewKeyedTransactor(privateKey) 然后我们需要设置keyed transactor的标准交易选项。 auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice 现在我们加载一个智能合约的实例。如果你还记得上个章节 我们创建一个名为Store的合约，并使用abigen工具生成一个Go文件。 要初始化它，我们只需调用合约包的New方法，并提供智能合约地址和ethclient，它返回我们可以使用的合约实例。 address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } 我们创建的智能合约有一个名为SetItem的外部方法，它接受solidity“bytes32”格式的两个参数（key，value）。 这意味着Go合约包要求我们传递一个长度为32个字节的字节数组。 调用SetItem方法需要我们传递我们之前创建的auth对象（keyed transactor）。 在幕后，此方法将使用它的参数对此函数调用进行编码，将其设置为事务的data属性，并使用私钥对其进行签名。 结果将是一个已签名的事务对象。 key := [32]byte{} value := [32]byte{} copy(key[:], []byte(&quot;foo&quot;)) copy(value[:], []byte(&quot;bar&quot;)) tx, err := instance.SetItem(auth, key, value) if err != nil { log.Fatal(err) } fmt.Printf(&quot;tx sent: %s&quot;, tx.Hash().Hex()) // tx sent: 0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870 现在我就可以看到交易已经成功被发送到了以太坊网络了: https://rinkeby.etherscan.io/tx/0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870 要验证键/值是否已设置，我们可以读取智能合约中的值。 result, err := instance.Items(nil, key) if err != nil { log.Fatal(err) } fmt.Println(string(result[:])) // &quot;bar&quot; 搞定！ 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_write.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/accounts/abi/bind&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } privateKey, err := crypto.HexToECDSA(&quot;fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19&quot;) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(&quot;error casting public key to ECDSA&quot;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } key := [32]byte{} value := [32]byte{} copy(key[:], []byte(&quot;foo&quot;)) copy(value[:], []byte(&quot;bar&quot;)) tx, err := instance.SetItem(auth, key, value) if err != nil { log.Fatal(err) } fmt.Printf(&quot;tx sent: %s&quot;, tx.Hash().Hex()) // tx sent: 0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870 result, err := instance.Items(nil, key) if err != nil { log.Fatal(err) } fmt.Println(string(result[:])) // &quot;bar&quot; } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 读取智能合约的字节码 有时您需要读取已部署的智能合约的字节码。 由于所有智能合约字节码都存在于区块链中，因此我们可以轻松获取它。 首先设置客户端和要读取的字节码的智能合约地址。 client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } contractAddress := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) 现在你需要调用客户端的codeAt方法。 codeAt方法接受智能合约地址和可选的块编号，并以字节格式返回字节码。 bytecode, err := client.CodeAt(context.Background(), contractAddress, nil) // nil is latest block if err != nil { log.Fatal(err) } fmt.Println(hex.EncodeToString(bytecode)) // 60806...10029 你也可以在etherscan上查询16进制格式的字节码 https://rinkeby.etherscan.io/address/0x147b8eb97fd247d06c4006d269c90c1908fb5d54#code 完整代码 contract_bytecode.go package main import ( &quot;context&quot; &quot;encoding/hex&quot; &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } contractAddress := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) bytecode, err := client.CodeAt(context.Background(), contractAddress, nil) // nil is latest block if err != nil { log.Fatal(err) } fmt.Println(hex.EncodeToString(bytecode)) // 60806...10029 } 查询ERC20代币智能合约 首先创建一个ERC20智能合约interface。 这只是与您可以调用的函数的函数定义的契约。 pragma solidity ^0.4.24; contract ERC20 { string public constant name = &quot;&quot;; string public constant symbol = &quot;&quot;; uint8 public constant decimals = 0; function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } 然后将interface智能合约编译为JSON ABI，并使用abigen从ABI创建Go包。 solc --abi erc20.sol abigen --abi=erc20_sol_ERC20.abi --pkg=token --out=erc20.go 假设我们已经像往常一样设置了以太坊客户端，我们现在可以将新的token包导入我们的应用程序并实例化它。这个例子里我们用Golem 代币的地址. tokenAddress := common.HexToAddress(&quot;0xa74476443119A942dE498590Fe1f2454d7D4aC0d&quot;) instance, err := token.NewToken(tokenAddress, client) if err != nil { log.Fatal(err) } 我们现在可以调用任何ERC20的方法。 例如，我们可以查询用户的代币余额。 address := common.HexToAddress(&quot;0x0536806df512d6cdde913cf95c9886f65b1d3462&quot;) bal, err := instance.BalanceOf(&amp;bind.CallOpts{}, address) if err != nil { log.Fatal(err) } fmt.Printf(&quot;wei: %s\n&quot;, bal) // &quot;wei: 74605500647408739782407023&quot; 我们还可以读ERC20智能合约的公共变量。 name, err := instance.Name(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } symbol, err := instance.Symbol(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } decimals, err := instance.Decimals(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } fmt.Printf(&quot;name: %s\n&quot;, name) // &quot;name: Golem Network&quot; fmt.Printf(&quot;symbol: %s\n&quot;, symbol) // &quot;symbol: GNT&quot; fmt.Printf(&quot;decimals: %v\n&quot;, decimals) // &quot;decimals: 18&quot; 我们可以做一些简单的数学运算将余额转换为可读的十进制格式。 fbal := new(big.Float) fbal.SetString(bal.String()) value := new(big.Float).Quo(fbal, big.NewFloat(math.Pow10(int(decimals)))) fmt.Printf(&quot;balance: %f&quot;, value) // &quot;balance: 74605500.647409&quot; 同样的信息也可以在etherscan上查询: https://etherscan.io/token/0xa74476443119a942de498590fe1f2454d7d4ac0d?a=0x0536806df512d6cdde913cf95c9886f65b1d3462 完整代码 Commands solc --abi erc20.sol abigen --abi=erc20_sol_ERC20.abi --pkg=token --out=erc20.go erc20.sol pragma solidity ^0.4.24; contract ERC20 { string public constant name = &quot;&quot;; string public constant symbol = &quot;&quot;; uint8 public constant decimals = 0; function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract_read_erc20.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;math&quot; &quot;math/big&quot; &quot;github.com/ethereum/go-ethereum/accounts/abi/bind&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; token &quot;./contracts_erc20&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://mainnet.infura.io&quot;) if err != nil { log.Fatal(err) } // Golem (GNT) Address tokenAddress := common.HexToAddress(&quot;0xa74476443119A942dE498590Fe1f2454d7D4aC0d&quot;) instance, err := token.NewToken(tokenAddress, client) if err != nil { log.Fatal(err) } address := common.HexToAddress(&quot;0x0536806df512d6cdde913cf95c9886f65b1d3462&quot;) bal, err := instance.BalanceOf(&amp;bind.CallOpts{}, address) if err != nil { log.Fatal(err) } name, err := instance.Name(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } symbol, err := instance.Symbol(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } decimals, err := instance.Decimals(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } fmt.Printf(&quot;name: %s\n&quot;, name) // &quot;name: Golem Network&quot; fmt.Printf(&quot;symbol: %s\n&quot;, symbol) // &quot;symbol: GNT&quot; fmt.Printf(&quot;decimals: %v\n&quot;, decimals) // &quot;decimals: 18&quot; fmt.Printf(&quot;wei: %s\n&quot;, bal) // &quot;wei: 74605500647408739782407023&quot; fbal := new(big.Float) fbal.SetString(bal.String()) value := new(big.Float).Quo(fbal, big.NewFloat(math.Pow10(int(decimals)))) fmt.Printf(&quot;balance: %f&quot;, value) // &quot;balance: 74605500.647409&quot; } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 文章不定期更新，小编微信：grey0805，欢迎交流" />
<meta property="og:description" content="智能合约 在这个章节中我们会介绍如何用Go来编译，部署，写入和读取智能合约。 智能合约的编译与ABI 与智能合约交互，我们要先生成相应智能合约的应用二进制接口ABI(application binary interface)，并把ABI编译成我们可以在Go应用中调用的格式。 第一步是安装 Solidity编译器 (solc). Solc 在Ubuntu上有snapcraft包。 sudo snap install solc --edge Solc在macOS上有Homebrew的包。 brew update brew tap ethereum/ethereum brew install solidity 其他的平台或者从源码编译的教程请查阅官方solidity文档install guide. 我们还得安装一个叫abigen的工具，来从solidity智能合约生成ABI。 假设您已经在计算机上设置了Go，只需运行以下命令即可安装abigen工具。 go get -u github.com/ethereum/go-ethereum cd $GOPATH/src/github.com/ethereum/go-ethereum/ make make devtools 我们将创建一个简单的智能合约来测试。 学习更复杂的智能合约，或者智能合约的开发的内容则超出了本书的范围。 我强烈建议您查看truffle framework 来学习开发和测试智能合约。 这里只是一个简单的合约，就是一个键/值存储，只有一个外部方法来设置任何人的键/值对。 我们还在设置值后添加了要发出的事件。 pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } 虽然这个智能合约很简单，但它将适用于这个例子。 现在我们可以从一个solidity文件生成ABI。 solc --abi Store.sol 它会将其写入名为“Store_sol_Store.abi”的文件中 现在让我们用abigen将ABI转换为我们可以导入的Go文件。 这个新文件将包含我们可以用来与Go应用程序中的智能合约进行交互的所有可用方法。 abigen --abi=Store_sol_Store.abi --pkg=store --out=Store.go 为了从Go部署智能合约，我们还需要将solidity智能合约编译为EVM字节码。 EVM字节码将在事务的数据字段中发送。 在Go文件上生成部署方法需要bin文件。 solc --bin Store.sol 现在我们编译Go合约文件，其中包括deploy方法，因为我们包含了bin文件。 abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go 在接下来的课程中，我们将学习如何部署智能合约，然后与之交互。 完整代码 Commands go get -u github.com/ethereum/go-ethereum cd $GOPATH/src/github.com/ethereum/go-ethereum/ make make devtools solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 部署智能合约 如果你还没看之前的章节，请先学习编译智能合约的章节因为这节内容，需要先了解如何将智能合约编译为Go文件。 假设你已经导入从abigen生成的新创建的Go包文件，并设置ethclient，加载您的私钥，下一步是创建一个有配置密匙的交易发送器(tansactor)。 首先从go-ethereum导入accounts/abi/bind包，然后调用传入私钥的NewKeyedTransactor。 然后设置通常的属性，如nonce，燃气价格，燃气上线限制和ETH值。 auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice 如果你还记得上个章节的内容, 我们创建了一个非常简单的“Store”合约，用于设置和存储键/值对。 生成的Go合约文件提供了部署方法。 部署方法名称始终以单词Deploy开头，后跟合约名称，在本例中为Store。 deploy函数接受有密匙的事务处理器，ethclient，以及智能合约构造函数可能接受的任何输入参数。我们测试的智能合约接受一个版本号的字符串参数。 此函数将返回新部署的合约地址，事务对象，我们可以交互的合约实例，还有错误（如果有）。 input := &quot;1.0&quot; address, tx, instance, err := store.DeployStore(auth, client, input) if err != nil { log.Fatal(err) } fmt.Println(address.Hex()) // 0x147B8eb97fD247D06C4006D269c90C1908Fb5D54 fmt.Println(tx.Hash().Hex()) // 0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0 _ = instance // will be using the instance in the 下个章节 就这么简单：）你可以用事务哈希来在Etherscan上查询合约的部署状态: https://rinkeby.etherscan.io/tx/0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_deploy.go package main import ( &quot;context&quot; &quot;crypto/ecdsa&quot; &quot;fmt&quot; &quot;log&quot; &quot;math/big&quot; &quot;github.com/ethereum/go-ethereum/accounts/abi/bind&quot; &quot;github.com/ethereum/go-ethereum/crypto&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } privateKey, err := crypto.HexToECDSA(&quot;fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19&quot;) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(&quot;error casting public key to ECDSA&quot;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice input := &quot;1.0&quot; address, tx, instance, err := store.DeployStore(auth, client, input) if err != nil { log.Fatal(err) } fmt.Println(address.Hex()) // 0x147B8eb97fD247D06C4006D269c90C1908Fb5D54 fmt.Println(tx.Hash().Hex()) // 0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0 _ = instance } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 加载智能合约 这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读上一个章节 。 一旦使用abigen工具将智能合约的ABI编译为Go包，下一步就是调用“New”方法，其格式为“New&lt;contractname style=&quot;box-sizing: border-box; font-size: 16px; -ms-text-size-adjust: auto; -webkit-tap-highlight-color: transparent;&quot;&gt;”，所以在我们的例子中如果你 回想一下它将是NewStore。 此初始化方法接收智能合约的地址，并返回可以开始与之交互的合约实例。&lt;/contractname&gt; address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } _ = instance // we&#39;ll be using this in the 下个章节 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_load.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } fmt.Println(&quot;contract is loaded&quot;) _ = instance } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 查询智能合约 Querying a Smart Contract 这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读上一个章节 。 在上个章节我们学习了如何在Go应用程序中初始化合约实例。 现在我们将使用新合约实例提供的方法来阅读智能合约。 如果你还记得我们在部署过程中设置的合约中有一个名为version的全局变量。 因为它是公开的，这意味着它们将成为我们自动创建的getter函数。 常量和view函数也接受bind.CallOpts作为第一个参数。了解可用的具体选项要看相应类的文档 一般情况下我们可以用 nil。 version, err := instance.Version(nil) if err != nil { log.Fatal(err) } fmt.Println(version) // &quot;1.0&quot; 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_read.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } version, err := instance.Version(nil) if err != nil { log.Fatal(err) } fmt.Println(version) // &quot;1.0&quot; } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 写入智能合约 这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读上一个章节 。 写入智能合约需要我们用私钥来对交易事务进行签名。 privateKey, err := crypto.HexToECDSA(&quot;fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19&quot;) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(&quot;error casting public key to ECDSA&quot;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) 我们还需要先查到nonce和燃气价格。 nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } 接下来，我们创建一个新的keyed transactor，它接收私钥。 auth := bind.NewKeyedTransactor(privateKey) 然后我们需要设置keyed transactor的标准交易选项。 auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice 现在我们加载一个智能合约的实例。如果你还记得上个章节 我们创建一个名为Store的合约，并使用abigen工具生成一个Go文件。 要初始化它，我们只需调用合约包的New方法，并提供智能合约地址和ethclient，它返回我们可以使用的合约实例。 address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } 我们创建的智能合约有一个名为SetItem的外部方法，它接受solidity“bytes32”格式的两个参数（key，value）。 这意味着Go合约包要求我们传递一个长度为32个字节的字节数组。 调用SetItem方法需要我们传递我们之前创建的auth对象（keyed transactor）。 在幕后，此方法将使用它的参数对此函数调用进行编码，将其设置为事务的data属性，并使用私钥对其进行签名。 结果将是一个已签名的事务对象。 key := [32]byte{} value := [32]byte{} copy(key[:], []byte(&quot;foo&quot;)) copy(value[:], []byte(&quot;bar&quot;)) tx, err := instance.SetItem(auth, key, value) if err != nil { log.Fatal(err) } fmt.Printf(&quot;tx sent: %s&quot;, tx.Hash().Hex()) // tx sent: 0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870 现在我就可以看到交易已经成功被发送到了以太坊网络了: https://rinkeby.etherscan.io/tx/0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870 要验证键/值是否已设置，我们可以读取智能合约中的值。 result, err := instance.Items(nil, key) if err != nil { log.Fatal(err) } fmt.Println(string(result[:])) // &quot;bar&quot; 搞定！ 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_write.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/accounts/abi/bind&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } privateKey, err := crypto.HexToECDSA(&quot;fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19&quot;) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(&quot;error casting public key to ECDSA&quot;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } key := [32]byte{} value := [32]byte{} copy(key[:], []byte(&quot;foo&quot;)) copy(value[:], []byte(&quot;bar&quot;)) tx, err := instance.SetItem(auth, key, value) if err != nil { log.Fatal(err) } fmt.Printf(&quot;tx sent: %s&quot;, tx.Hash().Hex()) // tx sent: 0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870 result, err := instance.Items(nil, key) if err != nil { log.Fatal(err) } fmt.Println(string(result[:])) // &quot;bar&quot; } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 读取智能合约的字节码 有时您需要读取已部署的智能合约的字节码。 由于所有智能合约字节码都存在于区块链中，因此我们可以轻松获取它。 首先设置客户端和要读取的字节码的智能合约地址。 client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } contractAddress := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) 现在你需要调用客户端的codeAt方法。 codeAt方法接受智能合约地址和可选的块编号，并以字节格式返回字节码。 bytecode, err := client.CodeAt(context.Background(), contractAddress, nil) // nil is latest block if err != nil { log.Fatal(err) } fmt.Println(hex.EncodeToString(bytecode)) // 60806...10029 你也可以在etherscan上查询16进制格式的字节码 https://rinkeby.etherscan.io/address/0x147b8eb97fd247d06c4006d269c90c1908fb5d54#code 完整代码 contract_bytecode.go package main import ( &quot;context&quot; &quot;encoding/hex&quot; &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } contractAddress := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) bytecode, err := client.CodeAt(context.Background(), contractAddress, nil) // nil is latest block if err != nil { log.Fatal(err) } fmt.Println(hex.EncodeToString(bytecode)) // 60806...10029 } 查询ERC20代币智能合约 首先创建一个ERC20智能合约interface。 这只是与您可以调用的函数的函数定义的契约。 pragma solidity ^0.4.24; contract ERC20 { string public constant name = &quot;&quot;; string public constant symbol = &quot;&quot;; uint8 public constant decimals = 0; function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } 然后将interface智能合约编译为JSON ABI，并使用abigen从ABI创建Go包。 solc --abi erc20.sol abigen --abi=erc20_sol_ERC20.abi --pkg=token --out=erc20.go 假设我们已经像往常一样设置了以太坊客户端，我们现在可以将新的token包导入我们的应用程序并实例化它。这个例子里我们用Golem 代币的地址. tokenAddress := common.HexToAddress(&quot;0xa74476443119A942dE498590Fe1f2454d7D4aC0d&quot;) instance, err := token.NewToken(tokenAddress, client) if err != nil { log.Fatal(err) } 我们现在可以调用任何ERC20的方法。 例如，我们可以查询用户的代币余额。 address := common.HexToAddress(&quot;0x0536806df512d6cdde913cf95c9886f65b1d3462&quot;) bal, err := instance.BalanceOf(&amp;bind.CallOpts{}, address) if err != nil { log.Fatal(err) } fmt.Printf(&quot;wei: %s\n&quot;, bal) // &quot;wei: 74605500647408739782407023&quot; 我们还可以读ERC20智能合约的公共变量。 name, err := instance.Name(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } symbol, err := instance.Symbol(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } decimals, err := instance.Decimals(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } fmt.Printf(&quot;name: %s\n&quot;, name) // &quot;name: Golem Network&quot; fmt.Printf(&quot;symbol: %s\n&quot;, symbol) // &quot;symbol: GNT&quot; fmt.Printf(&quot;decimals: %v\n&quot;, decimals) // &quot;decimals: 18&quot; 我们可以做一些简单的数学运算将余额转换为可读的十进制格式。 fbal := new(big.Float) fbal.SetString(bal.String()) value := new(big.Float).Quo(fbal, big.NewFloat(math.Pow10(int(decimals)))) fmt.Printf(&quot;balance: %f&quot;, value) // &quot;balance: 74605500.647409&quot; 同样的信息也可以在etherscan上查询: https://etherscan.io/token/0xa74476443119a942de498590fe1f2454d7d4ac0d?a=0x0536806df512d6cdde913cf95c9886f65b1d3462 完整代码 Commands solc --abi erc20.sol abigen --abi=erc20_sol_ERC20.abi --pkg=token --out=erc20.go erc20.sol pragma solidity ^0.4.24; contract ERC20 { string public constant name = &quot;&quot;; string public constant symbol = &quot;&quot;; uint8 public constant decimals = 0; function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract_read_erc20.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;math&quot; &quot;math/big&quot; &quot;github.com/ethereum/go-ethereum/accounts/abi/bind&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; token &quot;./contracts_erc20&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://mainnet.infura.io&quot;) if err != nil { log.Fatal(err) } // Golem (GNT) Address tokenAddress := common.HexToAddress(&quot;0xa74476443119A942dE498590Fe1f2454d7D4aC0d&quot;) instance, err := token.NewToken(tokenAddress, client) if err != nil { log.Fatal(err) } address := common.HexToAddress(&quot;0x0536806df512d6cdde913cf95c9886f65b1d3462&quot;) bal, err := instance.BalanceOf(&amp;bind.CallOpts{}, address) if err != nil { log.Fatal(err) } name, err := instance.Name(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } symbol, err := instance.Symbol(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } decimals, err := instance.Decimals(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } fmt.Printf(&quot;name: %s\n&quot;, name) // &quot;name: Golem Network&quot; fmt.Printf(&quot;symbol: %s\n&quot;, symbol) // &quot;symbol: GNT&quot; fmt.Printf(&quot;decimals: %v\n&quot;, decimals) // &quot;decimals: 18&quot; fmt.Printf(&quot;wei: %s\n&quot;, bal) // &quot;wei: 74605500647408739782407023&quot; fbal := new(big.Float) fbal.SetString(bal.String()) value := new(big.Float).Quo(fbal, big.NewFloat(math.Pow10(int(decimals)))) fmt.Printf(&quot;balance: %f&quot;, value) // &quot;balance: 74605500.647409&quot; } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 文章不定期更新，小编微信：grey0805，欢迎交流" />
<link rel="canonical" href="https://mlh.app/2018/12/03/728628.html" />
<meta property="og:url" content="https://mlh.app/2018/12/03/728628.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-12-03T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"智能合约 在这个章节中我们会介绍如何用Go来编译，部署，写入和读取智能合约。 智能合约的编译与ABI 与智能合约交互，我们要先生成相应智能合约的应用二进制接口ABI(application binary interface)，并把ABI编译成我们可以在Go应用中调用的格式。 第一步是安装 Solidity编译器 (solc). Solc 在Ubuntu上有snapcraft包。 sudo snap install solc --edge Solc在macOS上有Homebrew的包。 brew update brew tap ethereum/ethereum brew install solidity 其他的平台或者从源码编译的教程请查阅官方solidity文档install guide. 我们还得安装一个叫abigen的工具，来从solidity智能合约生成ABI。 假设您已经在计算机上设置了Go，只需运行以下命令即可安装abigen工具。 go get -u github.com/ethereum/go-ethereum cd $GOPATH/src/github.com/ethereum/go-ethereum/ make make devtools 我们将创建一个简单的智能合约来测试。 学习更复杂的智能合约，或者智能合约的开发的内容则超出了本书的范围。 我强烈建议您查看truffle framework 来学习开发和测试智能合约。 这里只是一个简单的合约，就是一个键/值存储，只有一个外部方法来设置任何人的键/值对。 我们还在设置值后添加了要发出的事件。 pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } 虽然这个智能合约很简单，但它将适用于这个例子。 现在我们可以从一个solidity文件生成ABI。 solc --abi Store.sol 它会将其写入名为“Store_sol_Store.abi”的文件中 现在让我们用abigen将ABI转换为我们可以导入的Go文件。 这个新文件将包含我们可以用来与Go应用程序中的智能合约进行交互的所有可用方法。 abigen --abi=Store_sol_Store.abi --pkg=store --out=Store.go 为了从Go部署智能合约，我们还需要将solidity智能合约编译为EVM字节码。 EVM字节码将在事务的数据字段中发送。 在Go文件上生成部署方法需要bin文件。 solc --bin Store.sol 现在我们编译Go合约文件，其中包括deploy方法，因为我们包含了bin文件。 abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go 在接下来的课程中，我们将学习如何部署智能合约，然后与之交互。 完整代码 Commands go get -u github.com/ethereum/go-ethereum cd $GOPATH/src/github.com/ethereum/go-ethereum/ make make devtools solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 部署智能合约 如果你还没看之前的章节，请先学习编译智能合约的章节因为这节内容，需要先了解如何将智能合约编译为Go文件。 假设你已经导入从abigen生成的新创建的Go包文件，并设置ethclient，加载您的私钥，下一步是创建一个有配置密匙的交易发送器(tansactor)。 首先从go-ethereum导入accounts/abi/bind包，然后调用传入私钥的NewKeyedTransactor。 然后设置通常的属性，如nonce，燃气价格，燃气上线限制和ETH值。 auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice 如果你还记得上个章节的内容, 我们创建了一个非常简单的“Store”合约，用于设置和存储键/值对。 生成的Go合约文件提供了部署方法。 部署方法名称始终以单词Deploy开头，后跟合约名称，在本例中为Store。 deploy函数接受有密匙的事务处理器，ethclient，以及智能合约构造函数可能接受的任何输入参数。我们测试的智能合约接受一个版本号的字符串参数。 此函数将返回新部署的合约地址，事务对象，我们可以交互的合约实例，还有错误（如果有）。 input := &quot;1.0&quot; address, tx, instance, err := store.DeployStore(auth, client, input) if err != nil { log.Fatal(err) } fmt.Println(address.Hex()) // 0x147B8eb97fD247D06C4006D269c90C1908Fb5D54 fmt.Println(tx.Hash().Hex()) // 0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0 _ = instance // will be using the instance in the 下个章节 就这么简单：）你可以用事务哈希来在Etherscan上查询合约的部署状态: https://rinkeby.etherscan.io/tx/0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_deploy.go package main import ( &quot;context&quot; &quot;crypto/ecdsa&quot; &quot;fmt&quot; &quot;log&quot; &quot;math/big&quot; &quot;github.com/ethereum/go-ethereum/accounts/abi/bind&quot; &quot;github.com/ethereum/go-ethereum/crypto&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } privateKey, err := crypto.HexToECDSA(&quot;fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19&quot;) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(&quot;error casting public key to ECDSA&quot;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice input := &quot;1.0&quot; address, tx, instance, err := store.DeployStore(auth, client, input) if err != nil { log.Fatal(err) } fmt.Println(address.Hex()) // 0x147B8eb97fD247D06C4006D269c90C1908Fb5D54 fmt.Println(tx.Hash().Hex()) // 0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0 _ = instance } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 加载智能合约 这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读上一个章节 。 一旦使用abigen工具将智能合约的ABI编译为Go包，下一步就是调用“New”方法，其格式为“New&lt;contractname style=&quot;box-sizing: border-box; font-size: 16px; -ms-text-size-adjust: auto; -webkit-tap-highlight-color: transparent;&quot;&gt;”，所以在我们的例子中如果你 回想一下它将是NewStore。 此初始化方法接收智能合约的地址，并返回可以开始与之交互的合约实例。&lt;/contractname&gt; address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } _ = instance // we&#39;ll be using this in the 下个章节 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_load.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } fmt.Println(&quot;contract is loaded&quot;) _ = instance } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 查询智能合约 Querying a Smart Contract 这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读上一个章节 。 在上个章节我们学习了如何在Go应用程序中初始化合约实例。 现在我们将使用新合约实例提供的方法来阅读智能合约。 如果你还记得我们在部署过程中设置的合约中有一个名为version的全局变量。 因为它是公开的，这意味着它们将成为我们自动创建的getter函数。 常量和view函数也接受bind.CallOpts作为第一个参数。了解可用的具体选项要看相应类的文档 一般情况下我们可以用 nil。 version, err := instance.Version(nil) if err != nil { log.Fatal(err) } fmt.Println(version) // &quot;1.0&quot; 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_read.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } version, err := instance.Version(nil) if err != nil { log.Fatal(err) } fmt.Println(version) // &quot;1.0&quot; } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 写入智能合约 这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读上一个章节 。 写入智能合约需要我们用私钥来对交易事务进行签名。 privateKey, err := crypto.HexToECDSA(&quot;fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19&quot;) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(&quot;error casting public key to ECDSA&quot;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) 我们还需要先查到nonce和燃气价格。 nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } 接下来，我们创建一个新的keyed transactor，它接收私钥。 auth := bind.NewKeyedTransactor(privateKey) 然后我们需要设置keyed transactor的标准交易选项。 auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice 现在我们加载一个智能合约的实例。如果你还记得上个章节 我们创建一个名为Store的合约，并使用abigen工具生成一个Go文件。 要初始化它，我们只需调用合约包的New方法，并提供智能合约地址和ethclient，它返回我们可以使用的合约实例。 address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } 我们创建的智能合约有一个名为SetItem的外部方法，它接受solidity“bytes32”格式的两个参数（key，value）。 这意味着Go合约包要求我们传递一个长度为32个字节的字节数组。 调用SetItem方法需要我们传递我们之前创建的auth对象（keyed transactor）。 在幕后，此方法将使用它的参数对此函数调用进行编码，将其设置为事务的data属性，并使用私钥对其进行签名。 结果将是一个已签名的事务对象。 key := [32]byte{} value := [32]byte{} copy(key[:], []byte(&quot;foo&quot;)) copy(value[:], []byte(&quot;bar&quot;)) tx, err := instance.SetItem(auth, key, value) if err != nil { log.Fatal(err) } fmt.Printf(&quot;tx sent: %s&quot;, tx.Hash().Hex()) // tx sent: 0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870 现在我就可以看到交易已经成功被发送到了以太坊网络了: https://rinkeby.etherscan.io/tx/0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870 要验证键/值是否已设置，我们可以读取智能合约中的值。 result, err := instance.Items(nil, key) if err != nil { log.Fatal(err) } fmt.Println(string(result[:])) // &quot;bar&quot; 搞定！ 完整代码 Commands solc --abi Store.sol solc --bin Store.sol abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go Store.sol pragma solidity ^0.4.24; contract Store { event ItemSet(bytes32 key, bytes32 value); string public version; mapping (bytes32 =&gt; bytes32) public items; constructor(string _version) public { version = _version; } function setItem(bytes32 key, bytes32 value) external { items[key] = value; emit ItemSet(key, value); } } contract_write.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/accounts/abi/bind&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; store &quot;./contracts&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } privateKey, err := crypto.HexToECDSA(&quot;fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19&quot;) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(&quot;error casting public key to ECDSA&quot;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(300000) // in units auth.GasPrice = gasPrice address := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) instance, err := store.NewStore(address, client) if err != nil { log.Fatal(err) } key := [32]byte{} value := [32]byte{} copy(key[:], []byte(&quot;foo&quot;)) copy(value[:], []byte(&quot;bar&quot;)) tx, err := instance.SetItem(auth, key, value) if err != nil { log.Fatal(err) } fmt.Printf(&quot;tx sent: %s&quot;, tx.Hash().Hex()) // tx sent: 0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870 result, err := instance.Items(nil, key) if err != nil { log.Fatal(err) } fmt.Println(string(result[:])) // &quot;bar&quot; } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 读取智能合约的字节码 有时您需要读取已部署的智能合约的字节码。 由于所有智能合约字节码都存在于区块链中，因此我们可以轻松获取它。 首先设置客户端和要读取的字节码的智能合约地址。 client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } contractAddress := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) 现在你需要调用客户端的codeAt方法。 codeAt方法接受智能合约地址和可选的块编号，并以字节格式返回字节码。 bytecode, err := client.CodeAt(context.Background(), contractAddress, nil) // nil is latest block if err != nil { log.Fatal(err) } fmt.Println(hex.EncodeToString(bytecode)) // 60806...10029 你也可以在etherscan上查询16进制格式的字节码 https://rinkeby.etherscan.io/address/0x147b8eb97fd247d06c4006d269c90c1908fb5d54#code 完整代码 contract_bytecode.go package main import ( &quot;context&quot; &quot;encoding/hex&quot; &quot;fmt&quot; &quot;log&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; ) func main() { client, err := ethclient.Dial(&quot;https://rinkeby.infura.io&quot;) if err != nil { log.Fatal(err) } contractAddress := common.HexToAddress(&quot;0x147B8eb97fD247D06C4006D269c90C1908Fb5D54&quot;) bytecode, err := client.CodeAt(context.Background(), contractAddress, nil) // nil is latest block if err != nil { log.Fatal(err) } fmt.Println(hex.EncodeToString(bytecode)) // 60806...10029 } 查询ERC20代币智能合约 首先创建一个ERC20智能合约interface。 这只是与您可以调用的函数的函数定义的契约。 pragma solidity ^0.4.24; contract ERC20 { string public constant name = &quot;&quot;; string public constant symbol = &quot;&quot;; uint8 public constant decimals = 0; function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } 然后将interface智能合约编译为JSON ABI，并使用abigen从ABI创建Go包。 solc --abi erc20.sol abigen --abi=erc20_sol_ERC20.abi --pkg=token --out=erc20.go 假设我们已经像往常一样设置了以太坊客户端，我们现在可以将新的token包导入我们的应用程序并实例化它。这个例子里我们用Golem 代币的地址. tokenAddress := common.HexToAddress(&quot;0xa74476443119A942dE498590Fe1f2454d7D4aC0d&quot;) instance, err := token.NewToken(tokenAddress, client) if err != nil { log.Fatal(err) } 我们现在可以调用任何ERC20的方法。 例如，我们可以查询用户的代币余额。 address := common.HexToAddress(&quot;0x0536806df512d6cdde913cf95c9886f65b1d3462&quot;) bal, err := instance.BalanceOf(&amp;bind.CallOpts{}, address) if err != nil { log.Fatal(err) } fmt.Printf(&quot;wei: %s\\n&quot;, bal) // &quot;wei: 74605500647408739782407023&quot; 我们还可以读ERC20智能合约的公共变量。 name, err := instance.Name(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } symbol, err := instance.Symbol(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } decimals, err := instance.Decimals(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } fmt.Printf(&quot;name: %s\\n&quot;, name) // &quot;name: Golem Network&quot; fmt.Printf(&quot;symbol: %s\\n&quot;, symbol) // &quot;symbol: GNT&quot; fmt.Printf(&quot;decimals: %v\\n&quot;, decimals) // &quot;decimals: 18&quot; 我们可以做一些简单的数学运算将余额转换为可读的十进制格式。 fbal := new(big.Float) fbal.SetString(bal.String()) value := new(big.Float).Quo(fbal, big.NewFloat(math.Pow10(int(decimals)))) fmt.Printf(&quot;balance: %f&quot;, value) // &quot;balance: 74605500.647409&quot; 同样的信息也可以在etherscan上查询: https://etherscan.io/token/0xa74476443119a942de498590fe1f2454d7d4ac0d?a=0x0536806df512d6cdde913cf95c9886f65b1d3462 完整代码 Commands solc --abi erc20.sol abigen --abi=erc20_sol_ERC20.abi --pkg=token --out=erc20.go erc20.sol pragma solidity ^0.4.24; contract ERC20 { string public constant name = &quot;&quot;; string public constant symbol = &quot;&quot;; uint8 public constant decimals = 0; function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract_read_erc20.go package main import ( &quot;fmt&quot; &quot;log&quot; &quot;math&quot; &quot;math/big&quot; &quot;github.com/ethereum/go-ethereum/accounts/abi/bind&quot; &quot;github.com/ethereum/go-ethereum/common&quot; &quot;github.com/ethereum/go-ethereum/ethclient&quot; token &quot;./contracts_erc20&quot; // for demo ) func main() { client, err := ethclient.Dial(&quot;https://mainnet.infura.io&quot;) if err != nil { log.Fatal(err) } // Golem (GNT) Address tokenAddress := common.HexToAddress(&quot;0xa74476443119A942dE498590Fe1f2454d7D4aC0d&quot;) instance, err := token.NewToken(tokenAddress, client) if err != nil { log.Fatal(err) } address := common.HexToAddress(&quot;0x0536806df512d6cdde913cf95c9886f65b1d3462&quot;) bal, err := instance.BalanceOf(&amp;bind.CallOpts{}, address) if err != nil { log.Fatal(err) } name, err := instance.Name(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } symbol, err := instance.Symbol(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } decimals, err := instance.Decimals(&amp;bind.CallOpts{}) if err != nil { log.Fatal(err) } fmt.Printf(&quot;name: %s\\n&quot;, name) // &quot;name: Golem Network&quot; fmt.Printf(&quot;symbol: %s\\n&quot;, symbol) // &quot;symbol: GNT&quot; fmt.Printf(&quot;decimals: %v\\n&quot;, decimals) // &quot;decimals: 18&quot; fmt.Printf(&quot;wei: %s\\n&quot;, bal) // &quot;wei: 74605500647408739782407023&quot; fbal := new(big.Float) fbal.SetString(bal.String()) value := new(big.Float).Quo(fbal, big.NewFloat(math.Pow10(int(decimals)))) fmt.Printf(&quot;balance: %f&quot;, value) // &quot;balance: 74605500.647409&quot; } solc version used for these examples $ solc --version 0.4.24+commit.e67f0147.Emscripten.clang 文章不定期更新，小编微信：grey0805，欢迎交流","@type":"BlogPosting","url":"https://mlh.app/2018/12/03/728628.html","headline":"用Go来做以太坊开发④智能合约","dateModified":"2018-12-03T00:00:00+08:00","datePublished":"2018-12-03T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/12/03/728628.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>用Go来做以太坊开发④智能合约</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="show-content-free"> 
   <h1>智能合约</h1> 
   <p>在这个章节中我们会介绍如何用Go来编译，部署，写入和读取智能合约。</p> 
   <h1>智能合约的编译与ABI</h1> 
   <p>与智能合约交互，我们要先生成相应智能合约的应用二进制接口ABI(application binary interface)，并把ABI编译成我们可以在Go应用中调用的格式。</p> 
   <p>第一步是安装 <a href="https://solidity.readthedocs.io/en/latest/installing-solidity.html" rel="nofollow">Solidity编译器</a> (<code>solc</code>).</p> 
   <p>Solc 在Ubuntu上有snapcraft包。</p> 
   <pre><code>sudo snap install solc --edge
</code></pre> 
   <p>Solc在macOS上有Homebrew的包。</p> 
   <pre><code>brew update
brew tap ethereum/ethereum
brew install solidity
</code></pre> 
   <p>其他的平台或者从源码编译的教程请查阅官方solidity文档<a href="https://solidity.readthedocs.io/en/latest/installing-solidity.html#building-from-source" rel="nofollow">install guide</a>.</p> 
   <p>我们还得安装一个叫<code>abigen</code>的工具，来从solidity智能合约生成ABI。</p> 
   <p>假设您已经在计算机上设置了Go，只需运行以下命令即可安装<code>abigen</code>工具。</p> 
   <pre><code>go get -u github.com/ethereum/go-ethereum
cd $GOPATH/src/github.com/ethereum/go-ethereum/
make
make devtools
</code></pre> 
   <p>我们将创建一个简单的智能合约来测试。 学习更复杂的智能合约，或者智能合约的开发的内容则超出了本书的范围。 我强烈建议您查看<a href="http://truffleframework.com/" rel="nofollow">truffle framework</a> 来学习开发和测试智能合约。</p> 
   <p>这里只是一个简单的合约，就是一个键/值存储，只有一个外部方法来设置任何人的键/值对。 我们还在设置值后添加了要发出的事件。</p> 
   <pre><code>pragma solidity ^0.4.24;

contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  string public version;
  mapping (bytes32 =&gt; bytes32) public items;

  constructor(string _version) public {
    version = _version;
  }

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}
</code></pre> 
   <p>虽然这个智能合约很简单，但它将适用于这个例子。</p> 
   <p>现在我们可以从一个solidity文件生成ABI。</p> 
   <pre><code>solc --abi Store.sol
</code></pre> 
   <p>它会将其写入名为“Store_sol_Store.abi”的文件中</p> 
   <p>现在让我们用<code>abigen</code>将ABI转换为我们可以导入的Go文件。 这个新文件将包含我们可以用来与Go应用程序中的智能合约进行交互的所有可用方法。</p> 
   <pre><code>abigen --abi=Store_sol_Store.abi --pkg=store --out=Store.go
</code></pre> 
   <p>为了从Go部署智能合约，我们还需要将solidity智能合约编译为EVM字节码。 EVM字节码将在事务的数据字段中发送。 在Go文件上生成部署方法需要bin文件。</p> 
   <pre><code>solc --bin Store.sol
</code></pre> 
   <p>现在我们编译Go合约文件，其中包括deploy方法，因为我们包含了bin文件。</p> 
   <pre><code>abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go
</code></pre> 
   <p>在接下来的课程中，我们将学习如何部署智能合约，然后与之交互。</p> 
   <h3>完整代码</h3> 
   <p>Commands</p> 
   <pre><code>go get -u github.com/ethereum/go-ethereum
cd $GOPATH/src/github.com/ethereum/go-ethereum/
make
make devtools

solc --abi Store.sol
solc --bin Store.sol
abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go
</code></pre> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contracts/Store.sol" rel="nofollow">Store.sol</a></p> 
   <pre><code>pragma solidity ^0.4.24;

contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  string public version;
  mapping (bytes32 =&gt; bytes32) public items;

  constructor(string _version) public {
    version = _version;
  }

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}
</code></pre> 
   <p>solc version used for these examples</p> 
   <pre><code>$ solc --version
0.4.24+commit.e67f0147.Emscripten.clang
</code></pre> 
   <hr>
   <h1>部署智能合约</h1> 
   <p>如果你还没看之前的章节，请先学习<a href="https://goethereumbook.org/zh/smart-contract-compile" rel="nofollow">编译智能合约的章节</a>因为这节内容，需要先了解如何将智能合约编译为Go文件。</p> 
   <p>假设你已经导入从<code>abigen</code>生成的新创建的Go包文件，并设置ethclient，加载您的私钥，下一步是创建一个有配置密匙的交易发送器(tansactor)。 首先从go-ethereum导入<code>accounts/abi/bind</code>包，然后调用传入私钥的<code>NewKeyedTransactor</code>。 然后设置通常的属性，如nonce，燃气价格，燃气上线限制和ETH值。</p> 
   <pre><code>auth := bind.NewKeyedTransactor(privateKey)
auth.Nonce = big.NewInt(int64(nonce))
auth.Value = big.NewInt(0)     // in wei
auth.GasLimit = uint64(300000) // in units
auth.GasPrice = gasPrice
</code></pre> 
   <p>如果你还记得上个章节的内容, 我们创建了一个非常简单的“Store”合约，用于设置和存储键/值对。 生成的Go合约文件提供了部署方法。 部署方法名称始终以单词<em>Deploy</em>开头，后跟合约名称，在本例中为<em>Store</em>。</p> 
   <p>deploy函数接受有密匙的事务处理器，ethclient，以及智能合约构造函数可能接受的任何输入参数。我们测试的智能合约接受一个版本号的字符串参数。 此函数将返回新部署的合约地址，事务对象，我们可以交互的合约实例，还有错误（如果有）。</p> 
   <pre><code>input := "1.0"
address, tx, instance, err := store.DeployStore(auth, client, input)
if err != nil {
  log.Fatal(err)
}

fmt.Println(address.Hex())   // 0x147B8eb97fD247D06C4006D269c90C1908Fb5D54
fmt.Println(tx.Hash().Hex()) // 0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0

_ = instance // will be using the instance in the 下个章节
</code></pre> 
   <p>就这么简单：）你可以用事务哈希来在Etherscan上查询合约的部署状态: <a href="https://rinkeby.etherscan.io/tx/0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0" rel="nofollow">https://rinkeby.etherscan.io/tx/0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0</a></p> 
   <h3>完整代码</h3> 
   <p>Commands</p> 
   <pre><code>solc --abi Store.sol
solc --bin Store.sol
abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go

</code></pre> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contracts/Store.sol" rel="nofollow">Store.sol</a></p> 
   <pre><code>pragma solidity ^0.4.24;

contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  string public version;
  mapping (bytes32 =&gt; bytes32) public items;

  constructor(string _version) public {
    version = _version;
  }

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}
</code></pre> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contract_deploy.go" rel="nofollow">contract_deploy.go</a></p> 
   <pre><code>package main

import (
    "context"
    "crypto/ecdsa"
    "fmt"
    "log"
    "math/big"

    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/crypto"
    "github.com/ethereum/go-ethereum/ethclient"

    store "./contracts" // for demo
)

func main() {
    client, err := ethclient.Dial("https://rinkeby.infura.io")
    if err != nil {
        log.Fatal(err)
    }

    privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")
    if err != nil {
        log.Fatal(err)
    }

    publicKey := privateKey.Public()
    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
    if !ok {
        log.Fatal("error casting public key to ECDSA")
    }

    fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
    nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
    if err != nil {
        log.Fatal(err)
    }

    gasPrice, err := client.SuggestGasPrice(context.Background())
    if err != nil {
        log.Fatal(err)
    }

    auth := bind.NewKeyedTransactor(privateKey)
    auth.Nonce = big.NewInt(int64(nonce))
    auth.Value = big.NewInt(0)     // in wei
    auth.GasLimit = uint64(300000) // in units
    auth.GasPrice = gasPrice

    input := "1.0"
    address, tx, instance, err := store.DeployStore(auth, client, input)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(address.Hex())   // 0x147B8eb97fD247D06C4006D269c90C1908Fb5D54
    fmt.Println(tx.Hash().Hex()) // 0xdae8ba5444eefdc99f4d45cd0c4f24056cba6a02cefbf78066ef9f4188ff7dc0

    _ = instance
}
</code></pre> 
   <p>solc version used for these examples</p> 
   <pre><code>$ solc --version
0.4.24+commit.e67f0147.Emscripten.clang
</code></pre> 
   <hr>
   <h1>加载智能合约</h1> 
   <p>这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读<a href="https://goethereumbook.org/zh/smart-contract-compile" rel="nofollow">上一个章节</a> 。</p> 
   <p>一旦使用<code>abigen</code>工具将智能合约的ABI编译为Go包，下一步就是调用“New”方法，其格式为“New&lt;contractname style="box-sizing: border-box; font-size: 16px; -ms-text-size-adjust: auto; -webkit-tap-highlight-color: transparent;"&gt;”，所以在我们的例子中如果你 回想一下它将是<em>NewStore</em>。 此初始化方法接收智能合约的地址，并返回可以开始与之交互的合约实例。&lt;/contractname&gt;</p> 
   <pre><code>address := common.HexToAddress("0x147B8eb97fD247D06C4006D269c90C1908Fb5D54")
instance, err := store.NewStore(address, client)
if err != nil {
  log.Fatal(err)
}

_ = instance // we'll be using this in the 下个章节
</code></pre> 
   <h3>完整代码</h3> 
   <p>Commands</p> 
   <pre><code>solc --abi Store.sol
solc --bin Store.sol
abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go
</code></pre> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contracts/Store.sol" rel="nofollow">Store.sol</a></p> 
   <pre><code>pragma solidity ^0.4.24;

contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  string public version;
  mapping (bytes32 =&gt; bytes32) public items;

  constructor(string _version) public {
    version = _version;
  }

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}
</code></pre> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contract_load.go" rel="nofollow">contract_load.go</a></p> 
   <pre><code>package main

import (
    "fmt"
    "log"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"

    store "./contracts" // for demo
)

func main() {
    client, err := ethclient.Dial("https://rinkeby.infura.io")
    if err != nil {
        log.Fatal(err)
    }

    address := common.HexToAddress("0x147B8eb97fD247D06C4006D269c90C1908Fb5D54")
    instance, err := store.NewStore(address, client)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("contract is loaded")
    _ = instance
}
</code></pre> 
   <p>solc version used for these examples</p> 
   <pre><code>$ solc --version
0.4.24+commit.e67f0147.Emscripten.clang
</code></pre> 
   <hr>
   <h1>查询智能合约</h1> 
   <h1>Querying a Smart Contract</h1> 
   <p>这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读<a href="https://goethereumbook.org/zh/smart-contract-compile" rel="nofollow">上一个章节</a> 。</p> 
   <p>在上个章节我们学习了如何在Go应用程序中初始化合约实例。 现在我们将使用新合约实例提供的方法来阅读智能合约。 如果你还记得我们在部署过程中设置的合约中有一个名为<code>version</code>的全局变量。 因为它是公开的，这意味着它们将成为我们自动创建的getter函数。 常量和view函数也接受<code>bind.CallOpts</code>作为第一个参数。了解可用的具体选项要看相应类的<a href="https://godoc.org/github.com/ethereum/go-ethereum/accounts/abi/bind#CallOpts" rel="nofollow">文档</a> 一般情况下我们可以用 <code>nil</code>。</p> 
   <pre><code>version, err := instance.Version(nil)
if err != nil {
  log.Fatal(err)
}

fmt.Println(version) // "1.0"
</code></pre> 
   <h3>完整代码</h3> 
   <p>Commands</p> 
   <pre><code>solc --abi Store.sol
solc --bin Store.sol
abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go
</code></pre> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contracts/Store.sol" rel="nofollow">Store.sol</a></p> 
   <pre><code>pragma solidity ^0.4.24;

contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  string public version;
  mapping (bytes32 =&gt; bytes32) public items;

  constructor(string _version) public {
    version = _version;
  }

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}
</code></pre> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contract_read.go" rel="nofollow">contract_read.go</a></p> 
   <pre><code>package main

import (
    "fmt"
    "log"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"

    store "./contracts" // for demo
)

func main() {
    client, err := ethclient.Dial("https://rinkeby.infura.io")
    if err != nil {
        log.Fatal(err)
    }

    address := common.HexToAddress("0x147B8eb97fD247D06C4006D269c90C1908Fb5D54")
    instance, err := store.NewStore(address, client)
    if err != nil {
        log.Fatal(err)
    }

    version, err := instance.Version(nil)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(version) // "1.0"
}
</code></pre> 
   <p>solc version used for these examples</p> 
   <pre><code>$ solc --version
0.4.24+commit.e67f0147.Emscripten.clang
</code></pre> 
   <hr>
   <h1>写入智能合约</h1> 
   <p>这写章节需要了解如何将智能合约的ABI编译成Go的合约文件。如果你还没看， 前先读<a href="https://goethereumbook.org/zh/smart-contract-compile" rel="nofollow">上一个章节</a> 。</p> 
   <p>写入智能合约需要我们用私钥来对交易事务进行签名。</p> 
   <pre><code>privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")
if err != nil {
  log.Fatal(err)
}

publicKey := privateKey.Public()
publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
if !ok {
  log.Fatal("error casting public key to ECDSA")
}

fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
</code></pre> 
   <p>我们还需要先查到nonce和燃气价格。</p> 
   <pre><code>nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
if err != nil {
  log.Fatal(err)
}

gasPrice, err := client.SuggestGasPrice(context.Background())
if err != nil {
  log.Fatal(err)
}
</code></pre> 
   <p>接下来，我们创建一个新的keyed transactor，它接收私钥。</p> 
   <pre><code>auth := bind.NewKeyedTransactor(privateKey)
</code></pre> 
   <p>然后我们需要设置keyed transactor的标准交易选项。</p> 
   <pre><code>auth.Nonce = big.NewInt(int64(nonce))
auth.Value = big.NewInt(0)     // in wei
auth.GasLimit = uint64(300000) // in units
auth.GasPrice = gasPrice
</code></pre> 
   <p>现在我们加载一个智能合约的实例。如果你还记得<a href="https://goethereumbook.org/zh/smart-contract-compile" rel="nofollow">上个章节</a> 我们创建一个名为<em>Store</em>的合约，并使用<code>abigen</code>工具生成一个Go文件。 要初始化它，我们只需调用合约包的<em>New</em>方法，并提供智能合约地址和ethclient，它返回我们可以使用的合约实例。</p> 
   <pre><code>address := common.HexToAddress("0x147B8eb97fD247D06C4006D269c90C1908Fb5D54")
instance, err := store.NewStore(address, client)
if err != nil {
  log.Fatal(err)
}

</code></pre> 
   <p>我们创建的智能合约有一个名为<em>SetItem</em>的外部方法，它接受solidity“bytes32”格式的两个参数（key，value）。 这意味着Go合约包要求我们传递一个长度为32个字节的字节数组。 调用<em>SetItem</em>方法需要我们传递我们之前创建的<code>auth</code>对象（keyed transactor）。 在幕后，此方法将使用它的参数对此函数调用进行编码，将其设置为事务的<code>data</code>属性，并使用私钥对其进行签名。 结果将是一个已签名的事务对象。</p> 
   <pre><code>key := [32]byte{}
value := [32]byte{}
copy(key[:], []byte("foo"))
copy(value[:], []byte("bar"))

tx, err := instance.SetItem(auth, key, value)
if err != nil {
  log.Fatal(err)
}

fmt.Printf("tx sent: %s", tx.Hash().Hex()) // tx sent: 0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870
</code></pre> 
   <p>现在我就可以看到交易已经成功被发送到了以太坊网络了: <a href="https://rinkeby.etherscan.io/tx/0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870" rel="nofollow">https://rinkeby.etherscan.io/tx/0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870</a></p> 
   <p>要验证键/值是否已设置，我们可以读取智能合约中的值。</p> 
   <pre><code>result, err := instance.Items(nil, key)
if err != nil {
  log.Fatal(err)
}

fmt.Println(string(result[:])) // "bar"

</code></pre> 
   <p>搞定！</p> 
   <h3>完整代码</h3> 
   <p>Commands</p> 
   <pre><code>solc --abi Store.sol
solc --bin Store.sol
abigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go
</code></pre> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contracts/Store.sol" rel="nofollow">Store.sol</a></p> 
   <pre><code>pragma solidity ^0.4.24;

contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  string public version;
  mapping (bytes32 =&gt; bytes32) public items;

  constructor(string _version) public {
    version = _version;
  }

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}
</code></pre> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contract_write.go" rel="nofollow">contract_write.go</a></p> 
   <pre><code>package main

import (
    "fmt"
    "log"

    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"

    store "./contracts" // for demo
)

func main() {
    client, err := ethclient.Dial("https://rinkeby.infura.io")
    if err != nil {
        log.Fatal(err)
    }

    privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")
    if err != nil {
        log.Fatal(err)
    }

    publicKey := privateKey.Public()
    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
    if !ok {
        log.Fatal("error casting public key to ECDSA")
    }

    fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
    nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
    if err != nil {
        log.Fatal(err)
    }

    gasPrice, err := client.SuggestGasPrice(context.Background())
    if err != nil {
        log.Fatal(err)
    }

    auth := bind.NewKeyedTransactor(privateKey)
    auth.Nonce = big.NewInt(int64(nonce))
    auth.Value = big.NewInt(0)     // in wei
    auth.GasLimit = uint64(300000) // in units
    auth.GasPrice = gasPrice

    address := common.HexToAddress("0x147B8eb97fD247D06C4006D269c90C1908Fb5D54")
    instance, err := store.NewStore(address, client)
    if err != nil {
        log.Fatal(err)
    }

    key := [32]byte{}
    value := [32]byte{}
    copy(key[:], []byte("foo"))
    copy(value[:], []byte("bar"))

    tx, err := instance.SetItem(auth, key, value)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("tx sent: %s", tx.Hash().Hex()) // tx sent: 0x8d490e535678e9a24360e955d75b27ad307bdfb97a1dca51d0f3035dcee3e870

    result, err := instance.Items(nil, key)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(string(result[:])) // "bar"
}
</code></pre> 
   <p>solc version used for these examples</p> 
   <pre><code>$ solc --version
0.4.24+commit.e67f0147.Emscripten.clang
</code></pre> 
   <hr>
   <h1>读取智能合约的字节码</h1> 
   <p>有时您需要读取已部署的智能合约的字节码。 由于所有智能合约字节码都存在于区块链中，因此我们可以轻松获取它。</p> 
   <p>首先设置客户端和要读取的字节码的智能合约地址。</p> 
   <pre><code>client, err := ethclient.Dial("https://rinkeby.infura.io")
if err != nil {
  log.Fatal(err)
}

contractAddress := common.HexToAddress("0x147B8eb97fD247D06C4006D269c90C1908Fb5D54")
</code></pre> 
   <p>现在你需要调用客户端的<code>codeAt</code>方法。 <code>codeAt</code>方法接受智能合约地址和可选的块编号，并以字节格式返回字节码。</p> 
   <pre><code>bytecode, err := client.CodeAt(context.Background(), contractAddress, nil) // nil is latest block
if err != nil {
  log.Fatal(err)
}

fmt.Println(hex.EncodeToString(bytecode)) // 60806...10029
</code></pre> 
   <p>你也可以在etherscan上查询16进制格式的字节码 <a href="https://rinkeby.etherscan.io/address/0x147b8eb97fd247d06c4006d269c90c1908fb5d54#code" rel="nofollow">https://rinkeby.etherscan.io/address/0x147b8eb97fd247d06c4006d269c90c1908fb5d54#code</a></p> 
   <h3>完整代码</h3> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contract_bytecode.go" rel="nofollow">contract_bytecode.go</a></p> 
   <pre><code>package main

import (
    "context"
    "encoding/hex"
    "fmt"
    "log"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    client, err := ethclient.Dial("https://rinkeby.infura.io")
    if err != nil {
        log.Fatal(err)
    }

    contractAddress := common.HexToAddress("0x147B8eb97fD247D06C4006D269c90C1908Fb5D54")
    bytecode, err := client.CodeAt(context.Background(), contractAddress, nil) // nil is latest block
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(hex.EncodeToString(bytecode)) // 60806...10029
}
</code></pre> 
   <hr>
   <h1>查询ERC20代币智能合约</h1> 
   <p>首先创建一个ERC20智能合约interface。 这只是与您可以调用的函数的函数定义的契约。</p> 
   <pre><code>pragma solidity ^0.4.24;

contract ERC20 {
    string public constant name = "";
    string public constant symbol = "";
    uint8 public constant decimals = 0;

    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}
</code></pre> 
   <p>然后将interface智能合约编译为JSON ABI，并使用<code>abigen</code>从ABI创建Go包。</p> 
   <pre><code>solc --abi erc20.sol
abigen --abi=erc20_sol_ERC20.abi --pkg=token --out=erc20.go
</code></pre> 
   <p>假设我们已经像往常一样设置了以太坊客户端，我们现在可以将新的<em>token</em>包导入我们的应用程序并实例化它。这个例子里我们用<a href="https://etherscan.io/address/0xa74476443119a942de498590fe1f2454d7d4ac0d" rel="nofollow">Golem</a> 代币的地址.</p> 
   <pre><code>tokenAddress := common.HexToAddress("0xa74476443119A942dE498590Fe1f2454d7D4aC0d")
instance, err := token.NewToken(tokenAddress, client)
if err != nil {
  log.Fatal(err)
}
</code></pre> 
   <p>我们现在可以调用任何ERC20的方法。 例如，我们可以查询用户的代币余额。</p> 
   <pre><code>address := common.HexToAddress("0x0536806df512d6cdde913cf95c9886f65b1d3462")
bal, err := instance.BalanceOf(&amp;bind.CallOpts{}, address)
if err != nil {
  log.Fatal(err)
}

fmt.Printf("wei: %s\n", bal) // "wei: 74605500647408739782407023"
</code></pre> 
   <p>我们还可以读ERC20智能合约的公共变量。</p> 
   <pre><code>name, err := instance.Name(&amp;bind.CallOpts{})
if err != nil {
  log.Fatal(err)
}

symbol, err := instance.Symbol(&amp;bind.CallOpts{})
if err != nil {
  log.Fatal(err)
}

decimals, err := instance.Decimals(&amp;bind.CallOpts{})
if err != nil {
  log.Fatal(err)
}

fmt.Printf("name: %s\n", name)         // "name: Golem Network"
fmt.Printf("symbol: %s\n", symbol)     // "symbol: GNT"
fmt.Printf("decimals: %v\n", decimals) // "decimals: 18"
</code></pre> 
   <p>我们可以做一些简单的数学运算将余额转换为可读的十进制格式。</p> 
   <pre><code>fbal := new(big.Float)
fbal.SetString(bal.String())
value := new(big.Float).Quo(fbal, big.NewFloat(math.Pow10(int(decimals))))

fmt.Printf("balance: %f", value) // "balance: 74605500.647409"
</code></pre> 
   <p>同样的信息也可以在etherscan上查询: <a href="https://etherscan.io/token/0xa74476443119a942de498590fe1f2454d7d4ac0d?a=0x0536806df512d6cdde913cf95c9886f65b1d3462" rel="nofollow">https://etherscan.io/token/0xa74476443119a942de498590fe1f2454d7d4ac0d?a=0x0536806df512d6cdde913cf95c9886f65b1d3462</a></p> 
   <h3>完整代码</h3> 
   <p>Commands</p> 
   <pre><code>solc --abi erc20.sol
abigen --abi=erc20_sol_ERC20.abi --pkg=token --out=erc20.go
</code></pre> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contracts_erc20/erc20.sol" rel="nofollow">erc20.sol</a></p> 
   <pre><code>pragma solidity ^0.4.24;

contract ERC20 {
    string public constant name = "";
    string public constant symbol = "";
    uint8 public constant decimals = 0;

    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}
</code></pre> 
   <p><a href="https://github.com/miguelmota/ethereum-development-with-go-book/blob/master/code/contract_read_erc20.go" rel="nofollow">contract_read_erc20.go</a></p> 
   <pre><code>package main

import (
    "fmt"
    "log"
    "math"
    "math/big"

    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"

    token "./contracts_erc20" // for demo
)

func main() {
    client, err := ethclient.Dial("https://mainnet.infura.io")
    if err != nil {
        log.Fatal(err)
    }

    // Golem (GNT) Address
    tokenAddress := common.HexToAddress("0xa74476443119A942dE498590Fe1f2454d7D4aC0d")
    instance, err := token.NewToken(tokenAddress, client)
    if err != nil {
        log.Fatal(err)
    }

    address := common.HexToAddress("0x0536806df512d6cdde913cf95c9886f65b1d3462")
    bal, err := instance.BalanceOf(&amp;bind.CallOpts{}, address)
    if err != nil {
        log.Fatal(err)
    }

    name, err := instance.Name(&amp;bind.CallOpts{})
    if err != nil {
        log.Fatal(err)
    }

    symbol, err := instance.Symbol(&amp;bind.CallOpts{})
    if err != nil {
        log.Fatal(err)
    }

    decimals, err := instance.Decimals(&amp;bind.CallOpts{})
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("name: %s\n", name)         // "name: Golem Network"
    fmt.Printf("symbol: %s\n", symbol)     // "symbol: GNT"
    fmt.Printf("decimals: %v\n", decimals) // "decimals: 18"

    fmt.Printf("wei: %s\n", bal) // "wei: 74605500647408739782407023"

    fbal := new(big.Float)
    fbal.SetString(bal.String())
    value := new(big.Float).Quo(fbal, big.NewFloat(math.Pow10(int(decimals))))

    fmt.Printf("balance: %f", value) // "balance: 74605500.647409"
}
</code></pre> 
   <p>solc version used for these examples</p> 
   <pre><code>$ solc --version
0.4.24+commit.e67f0147.Emscripten.clang
</code></pre> 
   <h2><em>文章不定期更新，小编微信：grey0805，欢迎交流</em></h2> 
  </div> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
