<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>基于以太坊实现代币 基于以太坊实现你自己的加密货币 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="基于以太坊实现代币 基于以太坊实现你自己的加密货币" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="文章内容主要来自于 https://www.ethereum.org/token。 笔者没有过英语4级，翻译的不好请见谅 ^_^ 代币 我们将创建一个数字令牌（digital token）。以太坊生态系统中的token可以代表任何可替换可交易的物品：硬币，金币，游戏内物品等。任何token都以标准方式实现一些基本功能。这意味着您的token可以兼容以太坊钱包和其他任何使用形同标准的contract。 我们所说的代币，绝大多数都是token。 一个基于ERC20发行的token 先看一下代币的样子： 进入网站：https://etherscan.io/。随便找一个代币，点进去查看： 接下来看一下ERC20标准。以下是ERC20标准的接口声明： ERC20标准英文文档 ERC20标准中文文档 // https://github.com/ethereum/EIPs/issues/20 contract ERC20 { string public constant name = &quot;Token Name&quot;;//token的名字、代币名称 string public constant symbol = &quot;SYM&quot;; // token的简写/代币符号 uint8 public constant decimals = 18; // 代币小数点位数，代币的最小单位， 18表示我们可以拥有 .0000000000000000001单位个代币。 官方推荐18。不要轻易改变 function totalSupply() constant returns (uint totalSupply);//发行代币总量。 function balanceOf(address _owner) constant returns (uint balance);//查看对应账号的代币余额。 function transfer(address _to, uint _value) returns (bool success);//实现代币交易，用于给用户发送代币（从我们的账户里）。 function transferFrom(address _from, address _to, uint _value) returns (bool success);//实现代币用户之间的交易。 function approve(address _spender, uint _value) returns (bool success);//允许用户可花费的代币数。 function allowance(address _owner, address _spender) constant returns (uint remaining);//控制代币的交易，如可交易账号及资产。 event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } 直接上代码： pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract LBL { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function LBL ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] &gt;= _value); // Check for overflows require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough balanceOf[msg.sender] -= _value; // Subtract from the sender totalSupply -= _value; // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] &gt;= _value); // Check if the targeted balance is enough require(_value &lt;= allowance[_from][msg.sender]); // Check allowance balanceOf[_from] -= _value; // Subtract from the targeted balance allowance[_from][msg.sender] -= _value; // Subtract from the sender&#39;s allowance totalSupply -= _value; // Update totalSupply emit Burn(_from, _value); return true; } } 将上述代码贴到Remix 中（https://ethereum.github.io/browser-solidity）： 上图中create按钮填入你想要的发行量，名称及代号，就可以创建合约了。 这时MetaMask会弹出一个交易确认框，点SUBMIT。待合约部署交易确认之后，复制合约地址。 如果你没有余额，需要先充值，才能发布成功。复制上述合约地址，牢记，否则合约就白部署了。你的以太币也浪费了。 代币的交易 上面部署好了以后，不方便查看和交易，下面我们将通过MetaMask和myetherwallet两个钱包来实现我们代笔的交易。 以太坊轻钱包MetaMask详细图文教程 参见 以太坊轻钱包MetaMask详细图文教程。 读者请自行安装部署 安装好了以后，打开Metamask界面，切换到TOKENS，点添加合约，出现如下对话框： 填入刚刚复制的地址，点ADD，这时你就可以看到你创建的代币了，如图： 到此为止，我们已经完成了代币的发放部署。可以在Etherscan上查询到我们刚刚部署的代币了 可以在以太坊浏览器上查看到我的代币 https://etherscan.io/address/0xFFCABB58bE7de3579bE5c423451896eb89bF18Ff： 使用MyEtherWallet交易 由于MetaMask插件没有提供代币交易功能，以太坊钱包又受限于网速等原因特别不好用。所以我们选择myetherwallet。 进入myetherwallet网页钱包地址, 第一次进入有一些安全提示需要用户确认。 进入之后，按照下图进行设置： 链接上以后，添加代币地址： 进行代币转账交易 在接下来的交易确认也，点击确认即可。 交易完成后，可以看到MetaMask中代币余额减少了，如图： 阅读更多" />
<meta property="og:description" content="文章内容主要来自于 https://www.ethereum.org/token。 笔者没有过英语4级，翻译的不好请见谅 ^_^ 代币 我们将创建一个数字令牌（digital token）。以太坊生态系统中的token可以代表任何可替换可交易的物品：硬币，金币，游戏内物品等。任何token都以标准方式实现一些基本功能。这意味着您的token可以兼容以太坊钱包和其他任何使用形同标准的contract。 我们所说的代币，绝大多数都是token。 一个基于ERC20发行的token 先看一下代币的样子： 进入网站：https://etherscan.io/。随便找一个代币，点进去查看： 接下来看一下ERC20标准。以下是ERC20标准的接口声明： ERC20标准英文文档 ERC20标准中文文档 // https://github.com/ethereum/EIPs/issues/20 contract ERC20 { string public constant name = &quot;Token Name&quot;;//token的名字、代币名称 string public constant symbol = &quot;SYM&quot;; // token的简写/代币符号 uint8 public constant decimals = 18; // 代币小数点位数，代币的最小单位， 18表示我们可以拥有 .0000000000000000001单位个代币。 官方推荐18。不要轻易改变 function totalSupply() constant returns (uint totalSupply);//发行代币总量。 function balanceOf(address _owner) constant returns (uint balance);//查看对应账号的代币余额。 function transfer(address _to, uint _value) returns (bool success);//实现代币交易，用于给用户发送代币（从我们的账户里）。 function transferFrom(address _from, address _to, uint _value) returns (bool success);//实现代币用户之间的交易。 function approve(address _spender, uint _value) returns (bool success);//允许用户可花费的代币数。 function allowance(address _owner, address _spender) constant returns (uint remaining);//控制代币的交易，如可交易账号及资产。 event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } 直接上代码： pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract LBL { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function LBL ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] &gt;= _value); // Check for overflows require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough balanceOf[msg.sender] -= _value; // Subtract from the sender totalSupply -= _value; // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] &gt;= _value); // Check if the targeted balance is enough require(_value &lt;= allowance[_from][msg.sender]); // Check allowance balanceOf[_from] -= _value; // Subtract from the targeted balance allowance[_from][msg.sender] -= _value; // Subtract from the sender&#39;s allowance totalSupply -= _value; // Update totalSupply emit Burn(_from, _value); return true; } } 将上述代码贴到Remix 中（https://ethereum.github.io/browser-solidity）： 上图中create按钮填入你想要的发行量，名称及代号，就可以创建合约了。 这时MetaMask会弹出一个交易确认框，点SUBMIT。待合约部署交易确认之后，复制合约地址。 如果你没有余额，需要先充值，才能发布成功。复制上述合约地址，牢记，否则合约就白部署了。你的以太币也浪费了。 代币的交易 上面部署好了以后，不方便查看和交易，下面我们将通过MetaMask和myetherwallet两个钱包来实现我们代笔的交易。 以太坊轻钱包MetaMask详细图文教程 参见 以太坊轻钱包MetaMask详细图文教程。 读者请自行安装部署 安装好了以后，打开Metamask界面，切换到TOKENS，点添加合约，出现如下对话框： 填入刚刚复制的地址，点ADD，这时你就可以看到你创建的代币了，如图： 到此为止，我们已经完成了代币的发放部署。可以在Etherscan上查询到我们刚刚部署的代币了 可以在以太坊浏览器上查看到我的代币 https://etherscan.io/address/0xFFCABB58bE7de3579bE5c423451896eb89bF18Ff： 使用MyEtherWallet交易 由于MetaMask插件没有提供代币交易功能，以太坊钱包又受限于网速等原因特别不好用。所以我们选择myetherwallet。 进入myetherwallet网页钱包地址, 第一次进入有一些安全提示需要用户确认。 进入之后，按照下图进行设置： 链接上以后，添加代币地址： 进行代币转账交易 在接下来的交易确认也，点击确认即可。 交易完成后，可以看到MetaMask中代币余额减少了，如图： 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/05/06/6ecaacb5ade862f7c5c01fcfb898de9e.html" />
<meta property="og:url" content="https://mlh.app/2018/05/06/6ecaacb5ade862f7c5c01fcfb898de9e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"文章内容主要来自于 https://www.ethereum.org/token。 笔者没有过英语4级，翻译的不好请见谅 ^_^ 代币 我们将创建一个数字令牌（digital token）。以太坊生态系统中的token可以代表任何可替换可交易的物品：硬币，金币，游戏内物品等。任何token都以标准方式实现一些基本功能。这意味着您的token可以兼容以太坊钱包和其他任何使用形同标准的contract。 我们所说的代币，绝大多数都是token。 一个基于ERC20发行的token 先看一下代币的样子： 进入网站：https://etherscan.io/。随便找一个代币，点进去查看： 接下来看一下ERC20标准。以下是ERC20标准的接口声明： ERC20标准英文文档 ERC20标准中文文档 // https://github.com/ethereum/EIPs/issues/20 contract ERC20 { string public constant name = &quot;Token Name&quot;;//token的名字、代币名称 string public constant symbol = &quot;SYM&quot;; // token的简写/代币符号 uint8 public constant decimals = 18; // 代币小数点位数，代币的最小单位， 18表示我们可以拥有 .0000000000000000001单位个代币。 官方推荐18。不要轻易改变 function totalSupply() constant returns (uint totalSupply);//发行代币总量。 function balanceOf(address _owner) constant returns (uint balance);//查看对应账号的代币余额。 function transfer(address _to, uint _value) returns (bool success);//实现代币交易，用于给用户发送代币（从我们的账户里）。 function transferFrom(address _from, address _to, uint _value) returns (bool success);//实现代币用户之间的交易。 function approve(address _spender, uint _value) returns (bool success);//允许用户可花费的代币数。 function allowance(address _owner, address _spender) constant returns (uint remaining);//控制代币的交易，如可交易账号及资产。 event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } 直接上代码： pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract LBL { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function LBL ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] &gt;= _value); // Check for overflows require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough balanceOf[msg.sender] -= _value; // Subtract from the sender totalSupply -= _value; // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] &gt;= _value); // Check if the targeted balance is enough require(_value &lt;= allowance[_from][msg.sender]); // Check allowance balanceOf[_from] -= _value; // Subtract from the targeted balance allowance[_from][msg.sender] -= _value; // Subtract from the sender&#39;s allowance totalSupply -= _value; // Update totalSupply emit Burn(_from, _value); return true; } } 将上述代码贴到Remix 中（https://ethereum.github.io/browser-solidity）： 上图中create按钮填入你想要的发行量，名称及代号，就可以创建合约了。 这时MetaMask会弹出一个交易确认框，点SUBMIT。待合约部署交易确认之后，复制合约地址。 如果你没有余额，需要先充值，才能发布成功。复制上述合约地址，牢记，否则合约就白部署了。你的以太币也浪费了。 代币的交易 上面部署好了以后，不方便查看和交易，下面我们将通过MetaMask和myetherwallet两个钱包来实现我们代笔的交易。 以太坊轻钱包MetaMask详细图文教程 参见 以太坊轻钱包MetaMask详细图文教程。 读者请自行安装部署 安装好了以后，打开Metamask界面，切换到TOKENS，点添加合约，出现如下对话框： 填入刚刚复制的地址，点ADD，这时你就可以看到你创建的代币了，如图： 到此为止，我们已经完成了代币的发放部署。可以在Etherscan上查询到我们刚刚部署的代币了 可以在以太坊浏览器上查看到我的代币 https://etherscan.io/address/0xFFCABB58bE7de3579bE5c423451896eb89bF18Ff： 使用MyEtherWallet交易 由于MetaMask插件没有提供代币交易功能，以太坊钱包又受限于网速等原因特别不好用。所以我们选择myetherwallet。 进入myetherwallet网页钱包地址, 第一次进入有一些安全提示需要用户确认。 进入之后，按照下图进行设置： 链接上以后，添加代币地址： 进行代币转账交易 在接下来的交易确认也，点击确认即可。 交易完成后，可以看到MetaMask中代币余额减少了，如图： 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/05/06/6ecaacb5ade862f7c5c01fcfb898de9e.html","headline":"基于以太坊实现代币 基于以太坊实现你自己的加密货币","dateModified":"2018-05-06T00:00:00+08:00","datePublished":"2018-05-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/05/06/6ecaacb5ade862f7c5c01fcfb898de9e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>基于以太坊实现代币|基于以太坊实现你自己的加密货币</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <blockquote> 
   <p>文章内容主要来自于 <a href="https://www.ethereum.org/token" rel="nofollow">https://www.ethereum.org/token</a>。 笔者没有过英语4级，翻译的不好请见谅 ^_^</p> 
  </blockquote> 
  <h1 id="代币">代币</h1> 
  <p>我们将创建一个数字令牌（digital token）。以太坊生态系统中的token可以代表任何可替换可交易的物品：硬币，金币，游戏内物品等。任何token都以标准方式实现一些基本功能。这意味着您的token可以兼容以太坊钱包和其他任何使用形同标准的contract。 <br> 我们所说的代币，绝大多数都是token。</p> 
  <h1 id="一个基于erc20发行的token">一个基于ERC20发行的token</h1> 
  <p>先看一下代币的样子： <br> 进入网站：<a href="https://etherscan.io/" rel="nofollow">https://etherscan.io/</a>。随便找一个代币，点进去查看： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180506193925285?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZneWlidXBp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p>接下来看一下ERC20标准。以下是ERC20标准的接口声明：</p> 
  <ul> 
   <li><a href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard" rel="nofollow">ERC20标准英文文档</a></li> 
   <li><a href="https://blog.csdn.net/diandianxiyu_geek/article/details/78082551?utm_source=gold_browser_extension" rel="nofollow">ERC20标准中文文档</a></li> 
  </ul> 
  <pre class="prettyprint"><code class=" hljs php"><span class="hljs-comment">// https://github.com/ethereum/EIPs/issues/20</span>
contract ERC20 {

    string <span class="hljs-keyword">public</span> constant name = <span class="hljs-string">"Token Name"</span>;<span class="hljs-comment">//token的名字、代币名称</span>
    string <span class="hljs-keyword">public</span> constant symbol = <span class="hljs-string">"SYM"</span>; <span class="hljs-comment">// token的简写/代币符号</span>
    uint8 <span class="hljs-keyword">public</span> constant decimals = <span class="hljs-number">18</span>;  <span class="hljs-comment">// 代币小数点位数，代币的最小单位， 18表示我们可以拥有 .0000000000000000001单位个代币。 官方推荐18。不要轻易改变</span>

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">totalSupply</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint totalSupply)</span>;</span><span class="hljs-comment">//发行代币总量。 </span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">balanceOf</span><span class="hljs-params">(address _owner)</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint balance)</span>;</span><span class="hljs-comment">//查看对应账号的代币余额。 </span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address _to, uint _value)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span>;</span><span class="hljs-comment">//实现代币交易，用于给用户发送代币（从我们的账户里）。 </span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transferFrom</span><span class="hljs-params">(address _from, address _to, uint _value)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span>;</span><span class="hljs-comment">//实现代币用户之间的交易。 </span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">approve</span><span class="hljs-params">(address _spender, uint _value)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span>;</span><span class="hljs-comment">//允许用户可花费的代币数。</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">allowance</span><span class="hljs-params">(address _owner, address _spender)</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint remaining)</span>;</span><span class="hljs-comment">//控制代币的交易，如可交易账号及资产。 </span>

      event Transfer(address indexed _from, address indexed _to, uint _value);
      event Approval(address indexed _owner, address indexed _spender, uint _value);
}</code></pre> 
  <p>直接上代码：</p> 
  <pre class="prettyprint"><code class=" hljs java">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }

contract LBL {
    <span class="hljs-comment">// Public variables of the token</span>
    string <span class="hljs-keyword">public</span> name;
    string <span class="hljs-keyword">public</span> symbol;
    uint8 <span class="hljs-keyword">public</span> decimals = <span class="hljs-number">18</span>;
    <span class="hljs-comment">// 18 decimals is the strongly suggested default, avoid changing it</span>
    uint256 <span class="hljs-keyword">public</span> totalSupply;

    <span class="hljs-comment">// This creates an array with all balances</span>
    mapping (address =&gt; uint256) <span class="hljs-keyword">public</span> balanceOf;
    mapping (address =&gt; mapping (address =&gt; uint256)) <span class="hljs-keyword">public</span> allowance;

    <span class="hljs-comment">// This generates a public event on the blockchain that will notify clients</span>
    event Transfer(address indexed from, address indexed to, uint256 value);

    <span class="hljs-comment">// This notifies clients about the amount burnt</span>
    event Burn(address indexed from, uint256 value);

    <span class="hljs-javadoc">/** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */</span>
    function LBL (
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) <span class="hljs-keyword">public</span> {
        totalSupply = initialSupply * <span class="hljs-number">10</span> ** uint256(decimals);  <span class="hljs-comment">// Update total supply with the decimal amount</span>
        balanceOf[msg.sender] = totalSupply;                <span class="hljs-comment">// Give the creator all initial tokens</span>
        name = tokenName;                                   <span class="hljs-comment">// Set the name for display purposes</span>
        symbol = tokenSymbol;                               <span class="hljs-comment">// Set the symbol for display purposes</span>
    }

    <span class="hljs-javadoc">/** * Internal transfer, only can be called by this contract */</span>
    function _transfer(address _from, address _to, uint _value) internal {
        <span class="hljs-comment">// Prevent transfer to 0x0 address. Use burn() instead</span>
        require(_to != <span class="hljs-number">0x0</span>);
        <span class="hljs-comment">// Check if the sender has enough</span>
        require(balanceOf[_from] &gt;= _value);
        <span class="hljs-comment">// Check for overflows</span>
        require(balanceOf[_to] + _value &gt;= balanceOf[_to]);
        <span class="hljs-comment">// Save this for an assertion in the future</span>
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        <span class="hljs-comment">// Subtract from the sender</span>
        balanceOf[_from] -= _value;
        <span class="hljs-comment">// Add the same to the recipient</span>
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        <span class="hljs-comment">// Asserts are used to use static analysis to find bugs in your code. They should never fail</span>
        <span class="hljs-keyword">assert</span>(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    <span class="hljs-javadoc">/** * Transfer tokens * * Send `_value` tokens to `_to` from your account * *<span class="hljs-javadoctag"> @param</span> _to The address of the recipient *<span class="hljs-javadoctag"> @param</span> _value the amount to send */</span>
    function transfer(address _to, uint256 _value) <span class="hljs-keyword">public</span> {
        _transfer(msg.sender, _to, _value);
    }

    <span class="hljs-javadoc">/** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * *<span class="hljs-javadoctag"> @param</span> _from The address of the sender *<span class="hljs-javadoctag"> @param</span> _to The address of the recipient *<span class="hljs-javadoctag"> @param</span> _value the amount to send */</span>
    function transferFrom(address _from, address _to, uint256 _value) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (bool success) {
        require(_value &lt;= allowance[_from][msg.sender]);     <span class="hljs-comment">// Check allowance</span>
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-javadoc">/** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * *<span class="hljs-javadoctag"> @param</span> _spender The address authorized to spend *<span class="hljs-javadoctag"> @param</span> _value the max amount they can spend */</span>
    function approve(address _spender, uint256 _value) <span class="hljs-keyword">public</span>
        <span class="hljs-title">returns</span> (bool success) {
        allowance[msg.sender][_spender] = _value;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-javadoc">/** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * *<span class="hljs-javadoctag"> @param</span> _spender The address authorized to spend *<span class="hljs-javadoctag"> @param</span> _value the max amount they can spend *<span class="hljs-javadoctag"> @param</span> _extraData some extra information to send to the approved contract */</span>
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        <span class="hljs-keyword">public</span>
        <span class="hljs-title">returns</span> (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        <span class="hljs-keyword">if</span> (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, <span class="hljs-keyword">this</span>, _extraData);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
    }

    <span class="hljs-javadoc">/** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * *<span class="hljs-javadoctag"> @param</span> _value the amount of money to burn */</span>
    function burn(uint256 _value) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (bool success) {
        require(balanceOf[msg.sender] &gt;= _value);   <span class="hljs-comment">// Check if the sender has enough</span>
        balanceOf[msg.sender] -= _value;            <span class="hljs-comment">// Subtract from the sender</span>
        totalSupply -= _value;                      <span class="hljs-comment">// Updates totalSupply</span>
        emit Burn(msg.sender, _value);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-javadoc">/** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * *<span class="hljs-javadoctag"> @param</span> _from the address of the sender *<span class="hljs-javadoctag"> @param</span> _value the amount of money to burn */</span>
    function burnFrom(address _from, uint256 _value) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (bool success) {
        require(balanceOf[_from] &gt;= _value);                <span class="hljs-comment">// Check if the targeted balance is enough</span>
        require(_value &lt;= allowance[_from][msg.sender]);    <span class="hljs-comment">// Check allowance</span>
        balanceOf[_from] -= _value;                         <span class="hljs-comment">// Subtract from the targeted balance</span>
        allowance[_from][msg.sender] -= _value;             <span class="hljs-comment">// Subtract from the sender's allowance</span>
        totalSupply -= _value;                              <span class="hljs-comment">// Update totalSupply</span>
        emit Burn(_from, _value);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}</code></pre> 
  <p>将上述代码贴到Remix 中（<a href="https://ethereum.github.io/browser-solidity" rel="nofollow">https://ethereum.github.io/browser-solidity</a>）：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180506200402956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZneWlidXBp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 上图中create按钮填入你想要的发行量，名称及代号，就可以创建合约了。 <br> 这时MetaMask会弹出一个交易确认框，点SUBMIT。待合约部署交易确认之后，复制合约地址。</p> 
  <blockquote> 
   <p><strong>如果你没有余额，需要先充值，才能发布成功</strong>。复制上述合约地址，牢记，否则合约就白部署了。你的以太币也浪费了。</p> 
  </blockquote> 
  <h1 id="代币的交易">代币的交易</h1> 
  <p>上面部署好了以后，不方便查看和交易，下面我们将通过MetaMask和myetherwallet两个钱包来实现我们代笔的交易。</p> 
  <h2 id="以太坊轻钱包metamask详细图文教程">以太坊轻钱包MetaMask详细图文教程</h2> 
  <p>参见 <a href="http://8btc.com/thread-76137-1-5.html" rel="nofollow">以太坊轻钱包MetaMask详细图文教程</a>。 读者请自行安装部署</p> 
  <p>安装好了以后，打开Metamask界面，切换到TOKENS，点添加合约，出现如下对话框： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180506201535148?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZneWlidXBp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 填入刚刚复制的地址，点ADD，这时你就可以看到你创建的代币了，如图： </p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180507151615900?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZneWlidXBp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p><strong>到此为止，我们已经完成了代币的发放部署。可以在Etherscan上查询到我们刚刚部署的代币了</strong></p> 
  <p>可以在以太坊浏览器上查看到我的代币 <a href="https://etherscan.io/address/0xFFCABB58bE7de3579bE5c423451896eb89bF18Ff" rel="nofollow">https://etherscan.io/address/0xFFCABB58bE7de3579bE5c423451896eb89bF18Ff</a>：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018050715204646?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZneWlidXBp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <h2 id="使用myetherwallet交易">使用MyEtherWallet交易</h2> 
  <p>由于MetaMask插件没有提供代币交易功能，以太坊钱包又受限于网速等原因特别不好用。所以我们选择myetherwallet。</p> 
  <ol> 
   <li>进入<a href="https://www.myetherwallet.com/#send-transaction" rel="nofollow">myetherwallet网页钱包地址</a>, 第一次进入有一些安全提示需要用户确认。 </li> 
   <li>进入之后，按照下图进行设置： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180506201812641?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZneWlidXBp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></li> 
   <li>链接上以后，添加代币地址：</li> 
  </ol> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180507151726897?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZneWlidXBp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <ol> 
   <li>进行代币转账交易 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018050620193061?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZneWlidXBp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 在接下来的交易确认也，点击确认即可。 </li> 
   <li>交易完成后，可以看到MetaMask中代币余额减少了，如图： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180506202015742?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZneWlidXBp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></li> 
  </ol> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/liubenlong007/article/details/80217975,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/liubenlong007/article/details/80217975,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
