<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>深度探索Hyperledger技术与应用之超级账本的典型交易流程 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="深度探索Hyperledger技术与应用之超级账本的典型交易流程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="上一篇分享了超级账本的系统逻辑架构和网络节点架构，本篇主要分享超级账本的典型交易流程。 1 典型交易流程 下图所示为Hyperledger Fabric 1.0典型的交易流程图。 从上一节的网络节点架构中，我们已经了解到基于Hyperledger Fabric 1.0的区块链应用中涉及几个节点角色：应用程序、背书节点、排序服务节点和主节点。在图3-4中，假定各节点已经提前颁发好证书，且已正常启动，并加入已经创建好的通道。后面的步骤介绍在已经实例化了的链码通道上从发起一个调用交易到最终记账的全过程。 1、创建交易提案并发送给背书节点 使用应用程序构造交易提案，SignedProposal的结构如下所示： SignedProposal: { ProposalBytes(Proposal): { Header: { ChannelHeader: { Type: &quot;HeaderType_ENDORSER_TRANSACTION&quot;, TxId: TxId, Timestamp: Timestamp, ChannelId: ChannelId, Extension(ChaincodeHeaderExtension): { PayloadVisibility: PayloadVisibility, ChaincodeId: { Path: Path, Name: Name, Version: Version } }, Epoch: Epoch }, SignatureHeader: { Creator: Creator, Nonce: Nonce } }, Payload: { ChaincodeProposalPayload: { Input(ChaincodeInvocationSpec): { ChaincodeSpec: { Type: Type, ChaincodeId: { Name: Name }, Input(ChaincodeInput): { Args: [] } } }, TransientMap: TransientMap } } }, Signature: Signature } 我们来看看上面的结构，SignedProposal是封装了Proposal的结构，添加了调用者的签名信息。背书节点会根据签名信息验证其是否是一个有效的消息。Proposal由两个部分组成：消息头和消息结构。消息结构详细的解释参考后面的章节。这里简单讲一下消息头。 消息头（Header）也包含两项内容。 通道头（ChannelHeader）：通道头包含了与通道和链码调用相关的信息，比如在哪个通道上调用哪个版本的链码。TxId是应用程序本地生成的交易号，跟调用者的身份证书相关，可以避免交易号的冲突，背书节点和记账节点都会校验是否存在重复交易。 签名头（SignatureHeader）：签名头包含了调用者的身份证书和一个随机数，用于消息的有效性校验。 应用程序构造好交易提案请求后，选择背书节点执行并进行背书签名。背书节点是链码背书策略里指定的节点。有一些背书节点是离线的，其他的背书节点可以拒绝对交易进行背书，也可以不背书。应用程序可以尝试使用其他可用的背书节点来满足策略。应用程序以何种顺序给背书节点发送背书请求是没有关系的，正常情况下背书节点执行后的结果是一致的，只有背书节点对结果的签名不一样。 2、背书节点模拟交易并生成背书签名 背书节点在收到交易提案后会进行一些验证，包括： 交易提案的格式是否正确； 交易是否提交过（重复攻击保护）； 交易签名有效（通过 MSP）； 交易提案的提交者在当前通道上是否已授权有写权限。 验证通过后，背书节点会根据当前账本数据模拟执行链码中的业务逻辑并生成读写集（RwSet），其中包含响应值、读写集等。在模拟执行时账本数据不会更新。而后背书节点对这些读写集进行签名成为提案响应（Proposal Response），然后返回给应用程序。 ProposalResponse的结构如下： ProposalResponse: { Version: Version, Timestamp: Timestamp, Response: { Status: Status, Message: Message, Payload: Payload }, Payload(ProposalResponsePayload): { ProposalHash: ProposalHash, Extension(ChaincodeAction): { Results(TxRwSet): { NsRwSets(NsRwSet): [ NameSpace: NameSpace, KvRwSet: { Reads(KVRead): [ Key: Key, Version: { BlockNum: BlockNum, TxNum: TxNum } ], RangeQueriesInfo(RangeQueryInfo): [ StartKey: StartKey, EndKey: EndKey, ItrExhausted: ItrExhausted, ReadsInfo: ReadsInfo ], Writes(KVWrite): [ Key: Key, IsDelete: IsDelete, Value: Value ] } ] }, Events(ChaincodeEvent): { ChaincodeId: ChaincodeId, TxId: TxId, EventName: EventName, Payload: Payload } Response: { Status: Status, Message: Message, Payload: Payload }, ChaincodeId: ChaincodeId } }, Endorsement: { Endorser: Endorser, Signature: Signature } } 返回的ProposalResponse中包含了读写集、背书节点签名以及通道名称等信息。 3、收集交易的背书 应用程序收到ProposalResponse后会对背书节点签名进行验证，所有节点接收到任何消息后都是需要先验证消息合法性的。如果链码只进行账本查询，应用程序会检查查询响应，但不会将交易提交给排序服务节点。如果链码对账本进行Invoke操作，则须提交交易给排序服务进行账本更新，应用程序会在提交交易前判断背书策略是否满足。如果应用程序没有收集到足够的背书就提交交易了，记账节点在提交验证阶段会发现交易不能满足背书策略，标记为无效交易。 如何选择背书节点呢？目前fabric-sdk-go默认的实现是把配置文件选项channels.mychannel.peers（其中的mychannel需要替换成实际的通道名称）里的节点全部添加为背书节点，需要等待所有背书节点的背书签名。应用程序等待每个背书节点执行的超时时间是通过配置文件选项client.peer.timeout.connection设置的，配置文件的示例给出的是3秒，根据实际情况调整，如果没有设置就是5秒的默认值。 4、构造交易请求并发送给排序服务节点 应用程序接收到所有的背书节点签名后，根据背书签名调用SDK生成交易，广播给排序服务节点。生成交易的过程比较简单，确认所有的背书节点的执行结果完全一致，再将交易提案、提案响应和背书签名打包生成交易。交易的结构如下： Envelope: { Payload: { Header: { ChannelHeader: { Type: &quot;HeaderType_ENDORSER_TRANSACTION&quot;, TxId: TxId, Timestamp: Timestamp, ChannelId: ChannelId, Extension(ChaincodeHeaderExtension): { PayloadVisibility: PayloadVisibility, ChaincodeId: { Path: Path, Name: Name, Version: Version } }, Epoch: Epoch }, SignatureHeader: { Creator: Creator, Nonce: Nonce } }, Data(Transaction): { TransactionAction: [ Header(SignatureHeader): { Creator: Creator, Nonce: Nonce }, Payload(ChaincodeActionPayload): { ChaincodeProposalPayload: { Input(ChaincodeInvocationSpec): { ChaincodeSpec: { Type: Type, ChaincodeId: { Name: Name }, Input(ChaincodeInput): { Args: [] } } }, TransientMap: nil }, Action(ChaincodeEndorsedAction): { Payload(ProposalResponsePayload): { ProposalHash: ProposalHash, Extension(ChaincodeAction): { Results(TxRwSet): { NsRwSets(NsRwSet): [ NameSpace: NameSpace, KvRwSet: { Reads(KVRead): [ Key: Key, Version: { BlockNum: BlockNum, TxNum: TxNum } ], RangeQueriesInfo(RangeQueryInfo): [ StartKey: StartKey, EndKey: EndKey, ItrExhausted: ItrExhausted, ReadsInfo: ReadsInfo ], Writes(KVWrite): [ Key: Key, IsDelete: IsDelete, Value: Value ] } ] }, Events(ChaincodeEvent): { ChaincodeId: ChaincodeId, TxId: TxId, EventName: EventName, Payload: Payload } Response: { Status: Status, Message: Message, Payload: Payload }, ChaincodeId: ChaincodeId } }, Endorsement: [ Endorser: Endorser, Signature: Signature ] } } ] } }, Signature: Signature } 我们来看交易信封的几个对应关系： Envelope.Payload.Header同交易提案SignedProposal.Proposal.Header； Envelope.Payload.Data.TransactionAction.Header是交易提案的提交者的身份信息，同SignedProposal.Proposal.Header.SignatureHeader和Envelope.Payload.Header.SignatureHeader是冗余的； Envelope.Payload.Data.TransactionAction.Payload.ChaincodeProposalPayload同交易提案的SignedProposal.Proposal.Payload.ChaincodeProposalPayload，唯一不同的是，TransientMap强制设置为nil，目的是避免在区块中出现一些敏感信息； Envelope.Payload.Data.TransactionAction.Payload.Action.Payload结构，其实和Proposal Response.Payload结构完全一样； Envelope.Payload.Data.TransactionAction.Payload.Action.Endorsement变成了数组，代表多个背书节点的背书签名。 整个信封Envelope的Signature是交易提交者对整个Envelope.Payload的签名。应用程序可以把生成的交易信封内容发送给任意选择的几个排序服务节点。 5、排序服务节点以对交易进行排序并生成区块 排序服务不读取交易的内容，如果在生成交易信封内容的时候伪造了交易模拟执行的结果，排序服务节点也不会发现，但会在最终的交易验证阶段校验出来并标记为无效交易。排序服务要做得很简单，先是接收网络中所有通道发出的交易信息，读取交易信封的Envelope.Payload.Header.ChannelHeader.ChannelId以获取通道名称，按各个通道上交易的接收时间顺序对交易信息进行排序，生成区块。 6、排序服务节点以广播给组织的主节点 排序服务节点生成区块以后会广播给通道上不同组织的主节点。 7、记账节点验证区块内容并写入区块 背书节点是动态角色，只要参与交易的背书就是背书节点，哪些交易选择哪些节点作为背书节点是由应用程序选择的，这需要满足背书策略才能生效。所有的背书节点都属于记账节点。所有的Peer节点都是记账节点，记录的是节点已加入通道的账本数据。记账节点接收到的是排序服务节点生成的区块，验证区块交易的有效性，提交到本地账本后再产生一个生成区块的事件，监听区块事件的应用程序可以进行后续的处理。 如果接收到的区块是配置区块，则会更新缓存的配置信息。记账节点的处理流程如图所示。 交易数据的验证 区块数据的验证是以交易验证为单位的，每次对区块进行验证时都会生成一个交易号的位图TxValidationFlags，它记录每个交易号的交易验证状态，只有状态为TxValidationCode_VALID才是有效的。位图也会写入到区块的元数据BlockMetadataIndex_TRANSACTIONS_FILTER中。交易验证的时候会检查以下内容： 是否为合法的交易：交易格式是否正确，是否有合法的签名，交易内容是否被篡改； 记账节点是否加入了这个通道。 基本的验证通过以后会提交给VSCC进行背书策略的验证。 记账节点与VSCC 链码的交易是隔离的，每个交易的模拟执行结果读写集TxRwSet都包含了交易所属的链码。为了避免错误地更新链码交易数据，在交易提交给系统链码VSCC验证交易内容之前，还会对链码进行校验。下面这些交易都是非法的： 链码的名称或者版本为空； 交易消息头里的链码名称Envelope.Payload.Header.ChannelHeader.Extension.ChaincodeId. Name和交易数据里的链码名称Envelope.Payload.Data.TransactionAction.Payload.ChaincodeProposalPayload.Input.ChaincodeSpec.ChaincodeId.Name不一致； 链码更新当前链码数据时，生成读写集的链码版本不是LSCC记录的最新版本； 应用程序链码更新了LSCC（生命周期管理系统链码）的数据； 应用程序链码更新了不可被外部调用的系统链码的数据； 应用程序链码更新了不可被其他链码调用的系统链码的数据； 调用了不可被外部调用的系统链码。 基于状态数据的验证和MVCC检查 交易通过VSCC检查以后，就进入记账流程。kvledger还会对读写集TxRwSet进行MVCC（Multi-Version Concurrency Control）检查。 kvledger实现的是基于键值对（key-value）的状态数据模型。对状态数据的键有3种操作： 读状态数据； 写状态数据； 删除状态数据。 对状态数据的读操作有两种形式： 基于单一键的读取； 基于键范围的读取。 MVCC检查只对读数据进行校验，基本逻辑是对模拟执行时状态数据的版本和提交交易时状态数据的版本进行比较。如果数据版本发生变化或者某个键的范围数据发生变化，就说明这段时间之内有别的交易改变了状态数据，当前交易基于原有状态的处理就是有问题的。由于交易提交是并行的，所以在交易未打包生成区块之前，并不能确定最终的执行顺序。如果交易执行的顺序存在依赖，在MVCC检查的时候就会出现依赖的状态发生了变化，实际上是数据出现了冲突。图所示为基于状态的数据验证的流程图。 写集合本身包含了写和删除的数据，有一个状态位标识是否删除数据。为了提升效率，状态数据库的提交是批处理的，整个区块交易的状态数据同时提交，这也保证了整个区块的状态数据要么都提交成功，要么都提交失败。这时只会出现记录的账本数据和状态数据库不一致，不会出现区块的状态数据不一致的情况。当账本数据和状态数据库不一致时，可以通过状态数据库的检查点来标记。 无效交易的处理 伪造的交易会导致无效交易，正常的交易也可能出现无效交易。MVCC检查的是背书节点在模拟执行的时候，环境是否和记账节点提交交易时的环境一致，这里的环境是指状态数据库里数据的三元组（key、value、version）是否完全一致。如果正常提交的交易在这个过程中涉及的数据发生了变化，那么也会出现检查失败从而导致无效交易。在这种情况下，需要在上层的应用程序有一些补偿措施，比如调整交易打包的配置，重新提交失败的交易等。 在目前版本的实现中，无效交易也会保留在区块中，可以通过区块记录的元数据确定哪些是无效交易。无效交易的读写集不会提交到状态数据库中，不会导致状态数据库发生变化，只是会占用区块的大小，占用记账节点的硬盘空间。后续的版本会实现账本的精简，过滤掉无效交易。 8、在组织内部同步最新的区块 下篇预告：深度探索Hyperledger技术与应用之超级账本的策略管理 京东有购：https://item.jd.com/12279369.html 深度探索区块链 Hyperledger技术与应用 区块链 张增骏，董宁，朱轩彤，陈剑雄 　著 本书由超级账本执行董事Brian Behlendorf领衔推荐，区块链一线落地实践团队、Hyperleger会员智链骨干团对撰写。深入讲解Hyperledger Fabric 1.0的架构、执行逻辑、核心功能实现、从零部署，并以票据案例为例，讲解具体开发实践，穿插开发所需的最佳实践和遇到的问题解决。 机械工业 出版社 华章科技是机械出版社的旗下品牌，出版了“计算机科学丛书”等近30个经典套系，在各个细分领域均处于领导地位，其中《Java编程思想》、《算法导论》、《编译原理》、《数据挖掘：概念与技术》、《深入理解计算机系统》、《深入理解Java虚拟机》等著作犹如计算机图书领域的璀璨明珠，长销不衰！ HiBlock秉承开放、协作、透明、链接、分享的价值观，致力打造区块链开发者社区。专注于在开发者中推广区块链，帮助开发者真正掌握区块链技术和应用。 本文内容节选自《深度探索区块链：Hyperledger技术与应用》一书的第3章《超级账本的系统架构》。 本书作者：张增骏，董宁，朱轩彤，陈剑雄 感谢机械工业出版社华章分社的支持和分享。 以下是我们的社区介绍，欢迎各种合作、交流、学习：） 阅读更多" />
<meta property="og:description" content="上一篇分享了超级账本的系统逻辑架构和网络节点架构，本篇主要分享超级账本的典型交易流程。 1 典型交易流程 下图所示为Hyperledger Fabric 1.0典型的交易流程图。 从上一节的网络节点架构中，我们已经了解到基于Hyperledger Fabric 1.0的区块链应用中涉及几个节点角色：应用程序、背书节点、排序服务节点和主节点。在图3-4中，假定各节点已经提前颁发好证书，且已正常启动，并加入已经创建好的通道。后面的步骤介绍在已经实例化了的链码通道上从发起一个调用交易到最终记账的全过程。 1、创建交易提案并发送给背书节点 使用应用程序构造交易提案，SignedProposal的结构如下所示： SignedProposal: { ProposalBytes(Proposal): { Header: { ChannelHeader: { Type: &quot;HeaderType_ENDORSER_TRANSACTION&quot;, TxId: TxId, Timestamp: Timestamp, ChannelId: ChannelId, Extension(ChaincodeHeaderExtension): { PayloadVisibility: PayloadVisibility, ChaincodeId: { Path: Path, Name: Name, Version: Version } }, Epoch: Epoch }, SignatureHeader: { Creator: Creator, Nonce: Nonce } }, Payload: { ChaincodeProposalPayload: { Input(ChaincodeInvocationSpec): { ChaincodeSpec: { Type: Type, ChaincodeId: { Name: Name }, Input(ChaincodeInput): { Args: [] } } }, TransientMap: TransientMap } } }, Signature: Signature } 我们来看看上面的结构，SignedProposal是封装了Proposal的结构，添加了调用者的签名信息。背书节点会根据签名信息验证其是否是一个有效的消息。Proposal由两个部分组成：消息头和消息结构。消息结构详细的解释参考后面的章节。这里简单讲一下消息头。 消息头（Header）也包含两项内容。 通道头（ChannelHeader）：通道头包含了与通道和链码调用相关的信息，比如在哪个通道上调用哪个版本的链码。TxId是应用程序本地生成的交易号，跟调用者的身份证书相关，可以避免交易号的冲突，背书节点和记账节点都会校验是否存在重复交易。 签名头（SignatureHeader）：签名头包含了调用者的身份证书和一个随机数，用于消息的有效性校验。 应用程序构造好交易提案请求后，选择背书节点执行并进行背书签名。背书节点是链码背书策略里指定的节点。有一些背书节点是离线的，其他的背书节点可以拒绝对交易进行背书，也可以不背书。应用程序可以尝试使用其他可用的背书节点来满足策略。应用程序以何种顺序给背书节点发送背书请求是没有关系的，正常情况下背书节点执行后的结果是一致的，只有背书节点对结果的签名不一样。 2、背书节点模拟交易并生成背书签名 背书节点在收到交易提案后会进行一些验证，包括： 交易提案的格式是否正确； 交易是否提交过（重复攻击保护）； 交易签名有效（通过 MSP）； 交易提案的提交者在当前通道上是否已授权有写权限。 验证通过后，背书节点会根据当前账本数据模拟执行链码中的业务逻辑并生成读写集（RwSet），其中包含响应值、读写集等。在模拟执行时账本数据不会更新。而后背书节点对这些读写集进行签名成为提案响应（Proposal Response），然后返回给应用程序。 ProposalResponse的结构如下： ProposalResponse: { Version: Version, Timestamp: Timestamp, Response: { Status: Status, Message: Message, Payload: Payload }, Payload(ProposalResponsePayload): { ProposalHash: ProposalHash, Extension(ChaincodeAction): { Results(TxRwSet): { NsRwSets(NsRwSet): [ NameSpace: NameSpace, KvRwSet: { Reads(KVRead): [ Key: Key, Version: { BlockNum: BlockNum, TxNum: TxNum } ], RangeQueriesInfo(RangeQueryInfo): [ StartKey: StartKey, EndKey: EndKey, ItrExhausted: ItrExhausted, ReadsInfo: ReadsInfo ], Writes(KVWrite): [ Key: Key, IsDelete: IsDelete, Value: Value ] } ] }, Events(ChaincodeEvent): { ChaincodeId: ChaincodeId, TxId: TxId, EventName: EventName, Payload: Payload } Response: { Status: Status, Message: Message, Payload: Payload }, ChaincodeId: ChaincodeId } }, Endorsement: { Endorser: Endorser, Signature: Signature } } 返回的ProposalResponse中包含了读写集、背书节点签名以及通道名称等信息。 3、收集交易的背书 应用程序收到ProposalResponse后会对背书节点签名进行验证，所有节点接收到任何消息后都是需要先验证消息合法性的。如果链码只进行账本查询，应用程序会检查查询响应，但不会将交易提交给排序服务节点。如果链码对账本进行Invoke操作，则须提交交易给排序服务进行账本更新，应用程序会在提交交易前判断背书策略是否满足。如果应用程序没有收集到足够的背书就提交交易了，记账节点在提交验证阶段会发现交易不能满足背书策略，标记为无效交易。 如何选择背书节点呢？目前fabric-sdk-go默认的实现是把配置文件选项channels.mychannel.peers（其中的mychannel需要替换成实际的通道名称）里的节点全部添加为背书节点，需要等待所有背书节点的背书签名。应用程序等待每个背书节点执行的超时时间是通过配置文件选项client.peer.timeout.connection设置的，配置文件的示例给出的是3秒，根据实际情况调整，如果没有设置就是5秒的默认值。 4、构造交易请求并发送给排序服务节点 应用程序接收到所有的背书节点签名后，根据背书签名调用SDK生成交易，广播给排序服务节点。生成交易的过程比较简单，确认所有的背书节点的执行结果完全一致，再将交易提案、提案响应和背书签名打包生成交易。交易的结构如下： Envelope: { Payload: { Header: { ChannelHeader: { Type: &quot;HeaderType_ENDORSER_TRANSACTION&quot;, TxId: TxId, Timestamp: Timestamp, ChannelId: ChannelId, Extension(ChaincodeHeaderExtension): { PayloadVisibility: PayloadVisibility, ChaincodeId: { Path: Path, Name: Name, Version: Version } }, Epoch: Epoch }, SignatureHeader: { Creator: Creator, Nonce: Nonce } }, Data(Transaction): { TransactionAction: [ Header(SignatureHeader): { Creator: Creator, Nonce: Nonce }, Payload(ChaincodeActionPayload): { ChaincodeProposalPayload: { Input(ChaincodeInvocationSpec): { ChaincodeSpec: { Type: Type, ChaincodeId: { Name: Name }, Input(ChaincodeInput): { Args: [] } } }, TransientMap: nil }, Action(ChaincodeEndorsedAction): { Payload(ProposalResponsePayload): { ProposalHash: ProposalHash, Extension(ChaincodeAction): { Results(TxRwSet): { NsRwSets(NsRwSet): [ NameSpace: NameSpace, KvRwSet: { Reads(KVRead): [ Key: Key, Version: { BlockNum: BlockNum, TxNum: TxNum } ], RangeQueriesInfo(RangeQueryInfo): [ StartKey: StartKey, EndKey: EndKey, ItrExhausted: ItrExhausted, ReadsInfo: ReadsInfo ], Writes(KVWrite): [ Key: Key, IsDelete: IsDelete, Value: Value ] } ] }, Events(ChaincodeEvent): { ChaincodeId: ChaincodeId, TxId: TxId, EventName: EventName, Payload: Payload } Response: { Status: Status, Message: Message, Payload: Payload }, ChaincodeId: ChaincodeId } }, Endorsement: [ Endorser: Endorser, Signature: Signature ] } } ] } }, Signature: Signature } 我们来看交易信封的几个对应关系： Envelope.Payload.Header同交易提案SignedProposal.Proposal.Header； Envelope.Payload.Data.TransactionAction.Header是交易提案的提交者的身份信息，同SignedProposal.Proposal.Header.SignatureHeader和Envelope.Payload.Header.SignatureHeader是冗余的； Envelope.Payload.Data.TransactionAction.Payload.ChaincodeProposalPayload同交易提案的SignedProposal.Proposal.Payload.ChaincodeProposalPayload，唯一不同的是，TransientMap强制设置为nil，目的是避免在区块中出现一些敏感信息； Envelope.Payload.Data.TransactionAction.Payload.Action.Payload结构，其实和Proposal Response.Payload结构完全一样； Envelope.Payload.Data.TransactionAction.Payload.Action.Endorsement变成了数组，代表多个背书节点的背书签名。 整个信封Envelope的Signature是交易提交者对整个Envelope.Payload的签名。应用程序可以把生成的交易信封内容发送给任意选择的几个排序服务节点。 5、排序服务节点以对交易进行排序并生成区块 排序服务不读取交易的内容，如果在生成交易信封内容的时候伪造了交易模拟执行的结果，排序服务节点也不会发现，但会在最终的交易验证阶段校验出来并标记为无效交易。排序服务要做得很简单，先是接收网络中所有通道发出的交易信息，读取交易信封的Envelope.Payload.Header.ChannelHeader.ChannelId以获取通道名称，按各个通道上交易的接收时间顺序对交易信息进行排序，生成区块。 6、排序服务节点以广播给组织的主节点 排序服务节点生成区块以后会广播给通道上不同组织的主节点。 7、记账节点验证区块内容并写入区块 背书节点是动态角色，只要参与交易的背书就是背书节点，哪些交易选择哪些节点作为背书节点是由应用程序选择的，这需要满足背书策略才能生效。所有的背书节点都属于记账节点。所有的Peer节点都是记账节点，记录的是节点已加入通道的账本数据。记账节点接收到的是排序服务节点生成的区块，验证区块交易的有效性，提交到本地账本后再产生一个生成区块的事件，监听区块事件的应用程序可以进行后续的处理。 如果接收到的区块是配置区块，则会更新缓存的配置信息。记账节点的处理流程如图所示。 交易数据的验证 区块数据的验证是以交易验证为单位的，每次对区块进行验证时都会生成一个交易号的位图TxValidationFlags，它记录每个交易号的交易验证状态，只有状态为TxValidationCode_VALID才是有效的。位图也会写入到区块的元数据BlockMetadataIndex_TRANSACTIONS_FILTER中。交易验证的时候会检查以下内容： 是否为合法的交易：交易格式是否正确，是否有合法的签名，交易内容是否被篡改； 记账节点是否加入了这个通道。 基本的验证通过以后会提交给VSCC进行背书策略的验证。 记账节点与VSCC 链码的交易是隔离的，每个交易的模拟执行结果读写集TxRwSet都包含了交易所属的链码。为了避免错误地更新链码交易数据，在交易提交给系统链码VSCC验证交易内容之前，还会对链码进行校验。下面这些交易都是非法的： 链码的名称或者版本为空； 交易消息头里的链码名称Envelope.Payload.Header.ChannelHeader.Extension.ChaincodeId. Name和交易数据里的链码名称Envelope.Payload.Data.TransactionAction.Payload.ChaincodeProposalPayload.Input.ChaincodeSpec.ChaincodeId.Name不一致； 链码更新当前链码数据时，生成读写集的链码版本不是LSCC记录的最新版本； 应用程序链码更新了LSCC（生命周期管理系统链码）的数据； 应用程序链码更新了不可被外部调用的系统链码的数据； 应用程序链码更新了不可被其他链码调用的系统链码的数据； 调用了不可被外部调用的系统链码。 基于状态数据的验证和MVCC检查 交易通过VSCC检查以后，就进入记账流程。kvledger还会对读写集TxRwSet进行MVCC（Multi-Version Concurrency Control）检查。 kvledger实现的是基于键值对（key-value）的状态数据模型。对状态数据的键有3种操作： 读状态数据； 写状态数据； 删除状态数据。 对状态数据的读操作有两种形式： 基于单一键的读取； 基于键范围的读取。 MVCC检查只对读数据进行校验，基本逻辑是对模拟执行时状态数据的版本和提交交易时状态数据的版本进行比较。如果数据版本发生变化或者某个键的范围数据发生变化，就说明这段时间之内有别的交易改变了状态数据，当前交易基于原有状态的处理就是有问题的。由于交易提交是并行的，所以在交易未打包生成区块之前，并不能确定最终的执行顺序。如果交易执行的顺序存在依赖，在MVCC检查的时候就会出现依赖的状态发生了变化，实际上是数据出现了冲突。图所示为基于状态的数据验证的流程图。 写集合本身包含了写和删除的数据，有一个状态位标识是否删除数据。为了提升效率，状态数据库的提交是批处理的，整个区块交易的状态数据同时提交，这也保证了整个区块的状态数据要么都提交成功，要么都提交失败。这时只会出现记录的账本数据和状态数据库不一致，不会出现区块的状态数据不一致的情况。当账本数据和状态数据库不一致时，可以通过状态数据库的检查点来标记。 无效交易的处理 伪造的交易会导致无效交易，正常的交易也可能出现无效交易。MVCC检查的是背书节点在模拟执行的时候，环境是否和记账节点提交交易时的环境一致，这里的环境是指状态数据库里数据的三元组（key、value、version）是否完全一致。如果正常提交的交易在这个过程中涉及的数据发生了变化，那么也会出现检查失败从而导致无效交易。在这种情况下，需要在上层的应用程序有一些补偿措施，比如调整交易打包的配置，重新提交失败的交易等。 在目前版本的实现中，无效交易也会保留在区块中，可以通过区块记录的元数据确定哪些是无效交易。无效交易的读写集不会提交到状态数据库中，不会导致状态数据库发生变化，只是会占用区块的大小，占用记账节点的硬盘空间。后续的版本会实现账本的精简，过滤掉无效交易。 8、在组织内部同步最新的区块 下篇预告：深度探索Hyperledger技术与应用之超级账本的策略管理 京东有购：https://item.jd.com/12279369.html 深度探索区块链 Hyperledger技术与应用 区块链 张增骏，董宁，朱轩彤，陈剑雄 　著 本书由超级账本执行董事Brian Behlendorf领衔推荐，区块链一线落地实践团队、Hyperleger会员智链骨干团对撰写。深入讲解Hyperledger Fabric 1.0的架构、执行逻辑、核心功能实现、从零部署，并以票据案例为例，讲解具体开发实践，穿插开发所需的最佳实践和遇到的问题解决。 机械工业 出版社 华章科技是机械出版社的旗下品牌，出版了“计算机科学丛书”等近30个经典套系，在各个细分领域均处于领导地位，其中《Java编程思想》、《算法导论》、《编译原理》、《数据挖掘：概念与技术》、《深入理解计算机系统》、《深入理解Java虚拟机》等著作犹如计算机图书领域的璀璨明珠，长销不衰！ HiBlock秉承开放、协作、透明、链接、分享的价值观，致力打造区块链开发者社区。专注于在开发者中推广区块链，帮助开发者真正掌握区块链技术和应用。 本文内容节选自《深度探索区块链：Hyperledger技术与应用》一书的第3章《超级账本的系统架构》。 本书作者：张增骏，董宁，朱轩彤，陈剑雄 感谢机械工业出版社华章分社的支持和分享。 以下是我们的社区介绍，欢迎各种合作、交流、学习：） 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/05/06/513dcadb7e7e37bf37e7f2bcccfae564.html" />
<meta property="og:url" content="https://mlh.app/2018/05/06/513dcadb7e7e37bf37e7f2bcccfae564.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"上一篇分享了超级账本的系统逻辑架构和网络节点架构，本篇主要分享超级账本的典型交易流程。 1 典型交易流程 下图所示为Hyperledger Fabric 1.0典型的交易流程图。 从上一节的网络节点架构中，我们已经了解到基于Hyperledger Fabric 1.0的区块链应用中涉及几个节点角色：应用程序、背书节点、排序服务节点和主节点。在图3-4中，假定各节点已经提前颁发好证书，且已正常启动，并加入已经创建好的通道。后面的步骤介绍在已经实例化了的链码通道上从发起一个调用交易到最终记账的全过程。 1、创建交易提案并发送给背书节点 使用应用程序构造交易提案，SignedProposal的结构如下所示： SignedProposal: { ProposalBytes(Proposal): { Header: { ChannelHeader: { Type: &quot;HeaderType_ENDORSER_TRANSACTION&quot;, TxId: TxId, Timestamp: Timestamp, ChannelId: ChannelId, Extension(ChaincodeHeaderExtension): { PayloadVisibility: PayloadVisibility, ChaincodeId: { Path: Path, Name: Name, Version: Version } }, Epoch: Epoch }, SignatureHeader: { Creator: Creator, Nonce: Nonce } }, Payload: { ChaincodeProposalPayload: { Input(ChaincodeInvocationSpec): { ChaincodeSpec: { Type: Type, ChaincodeId: { Name: Name }, Input(ChaincodeInput): { Args: [] } } }, TransientMap: TransientMap } } }, Signature: Signature } 我们来看看上面的结构，SignedProposal是封装了Proposal的结构，添加了调用者的签名信息。背书节点会根据签名信息验证其是否是一个有效的消息。Proposal由两个部分组成：消息头和消息结构。消息结构详细的解释参考后面的章节。这里简单讲一下消息头。 消息头（Header）也包含两项内容。 通道头（ChannelHeader）：通道头包含了与通道和链码调用相关的信息，比如在哪个通道上调用哪个版本的链码。TxId是应用程序本地生成的交易号，跟调用者的身份证书相关，可以避免交易号的冲突，背书节点和记账节点都会校验是否存在重复交易。 签名头（SignatureHeader）：签名头包含了调用者的身份证书和一个随机数，用于消息的有效性校验。 应用程序构造好交易提案请求后，选择背书节点执行并进行背书签名。背书节点是链码背书策略里指定的节点。有一些背书节点是离线的，其他的背书节点可以拒绝对交易进行背书，也可以不背书。应用程序可以尝试使用其他可用的背书节点来满足策略。应用程序以何种顺序给背书节点发送背书请求是没有关系的，正常情况下背书节点执行后的结果是一致的，只有背书节点对结果的签名不一样。 2、背书节点模拟交易并生成背书签名 背书节点在收到交易提案后会进行一些验证，包括： 交易提案的格式是否正确； 交易是否提交过（重复攻击保护）； 交易签名有效（通过 MSP）； 交易提案的提交者在当前通道上是否已授权有写权限。 验证通过后，背书节点会根据当前账本数据模拟执行链码中的业务逻辑并生成读写集（RwSet），其中包含响应值、读写集等。在模拟执行时账本数据不会更新。而后背书节点对这些读写集进行签名成为提案响应（Proposal Response），然后返回给应用程序。 ProposalResponse的结构如下： ProposalResponse: { Version: Version, Timestamp: Timestamp, Response: { Status: Status, Message: Message, Payload: Payload }, Payload(ProposalResponsePayload): { ProposalHash: ProposalHash, Extension(ChaincodeAction): { Results(TxRwSet): { NsRwSets(NsRwSet): [ NameSpace: NameSpace, KvRwSet: { Reads(KVRead): [ Key: Key, Version: { BlockNum: BlockNum, TxNum: TxNum } ], RangeQueriesInfo(RangeQueryInfo): [ StartKey: StartKey, EndKey: EndKey, ItrExhausted: ItrExhausted, ReadsInfo: ReadsInfo ], Writes(KVWrite): [ Key: Key, IsDelete: IsDelete, Value: Value ] } ] }, Events(ChaincodeEvent): { ChaincodeId: ChaincodeId, TxId: TxId, EventName: EventName, Payload: Payload } Response: { Status: Status, Message: Message, Payload: Payload }, ChaincodeId: ChaincodeId } }, Endorsement: { Endorser: Endorser, Signature: Signature } } 返回的ProposalResponse中包含了读写集、背书节点签名以及通道名称等信息。 3、收集交易的背书 应用程序收到ProposalResponse后会对背书节点签名进行验证，所有节点接收到任何消息后都是需要先验证消息合法性的。如果链码只进行账本查询，应用程序会检查查询响应，但不会将交易提交给排序服务节点。如果链码对账本进行Invoke操作，则须提交交易给排序服务进行账本更新，应用程序会在提交交易前判断背书策略是否满足。如果应用程序没有收集到足够的背书就提交交易了，记账节点在提交验证阶段会发现交易不能满足背书策略，标记为无效交易。 如何选择背书节点呢？目前fabric-sdk-go默认的实现是把配置文件选项channels.mychannel.peers（其中的mychannel需要替换成实际的通道名称）里的节点全部添加为背书节点，需要等待所有背书节点的背书签名。应用程序等待每个背书节点执行的超时时间是通过配置文件选项client.peer.timeout.connection设置的，配置文件的示例给出的是3秒，根据实际情况调整，如果没有设置就是5秒的默认值。 4、构造交易请求并发送给排序服务节点 应用程序接收到所有的背书节点签名后，根据背书签名调用SDK生成交易，广播给排序服务节点。生成交易的过程比较简单，确认所有的背书节点的执行结果完全一致，再将交易提案、提案响应和背书签名打包生成交易。交易的结构如下： Envelope: { Payload: { Header: { ChannelHeader: { Type: &quot;HeaderType_ENDORSER_TRANSACTION&quot;, TxId: TxId, Timestamp: Timestamp, ChannelId: ChannelId, Extension(ChaincodeHeaderExtension): { PayloadVisibility: PayloadVisibility, ChaincodeId: { Path: Path, Name: Name, Version: Version } }, Epoch: Epoch }, SignatureHeader: { Creator: Creator, Nonce: Nonce } }, Data(Transaction): { TransactionAction: [ Header(SignatureHeader): { Creator: Creator, Nonce: Nonce }, Payload(ChaincodeActionPayload): { ChaincodeProposalPayload: { Input(ChaincodeInvocationSpec): { ChaincodeSpec: { Type: Type, ChaincodeId: { Name: Name }, Input(ChaincodeInput): { Args: [] } } }, TransientMap: nil }, Action(ChaincodeEndorsedAction): { Payload(ProposalResponsePayload): { ProposalHash: ProposalHash, Extension(ChaincodeAction): { Results(TxRwSet): { NsRwSets(NsRwSet): [ NameSpace: NameSpace, KvRwSet: { Reads(KVRead): [ Key: Key, Version: { BlockNum: BlockNum, TxNum: TxNum } ], RangeQueriesInfo(RangeQueryInfo): [ StartKey: StartKey, EndKey: EndKey, ItrExhausted: ItrExhausted, ReadsInfo: ReadsInfo ], Writes(KVWrite): [ Key: Key, IsDelete: IsDelete, Value: Value ] } ] }, Events(ChaincodeEvent): { ChaincodeId: ChaincodeId, TxId: TxId, EventName: EventName, Payload: Payload } Response: { Status: Status, Message: Message, Payload: Payload }, ChaincodeId: ChaincodeId } }, Endorsement: [ Endorser: Endorser, Signature: Signature ] } } ] } }, Signature: Signature } 我们来看交易信封的几个对应关系： Envelope.Payload.Header同交易提案SignedProposal.Proposal.Header； Envelope.Payload.Data.TransactionAction.Header是交易提案的提交者的身份信息，同SignedProposal.Proposal.Header.SignatureHeader和Envelope.Payload.Header.SignatureHeader是冗余的； Envelope.Payload.Data.TransactionAction.Payload.ChaincodeProposalPayload同交易提案的SignedProposal.Proposal.Payload.ChaincodeProposalPayload，唯一不同的是，TransientMap强制设置为nil，目的是避免在区块中出现一些敏感信息； Envelope.Payload.Data.TransactionAction.Payload.Action.Payload结构，其实和Proposal Response.Payload结构完全一样； Envelope.Payload.Data.TransactionAction.Payload.Action.Endorsement变成了数组，代表多个背书节点的背书签名。 整个信封Envelope的Signature是交易提交者对整个Envelope.Payload的签名。应用程序可以把生成的交易信封内容发送给任意选择的几个排序服务节点。 5、排序服务节点以对交易进行排序并生成区块 排序服务不读取交易的内容，如果在生成交易信封内容的时候伪造了交易模拟执行的结果，排序服务节点也不会发现，但会在最终的交易验证阶段校验出来并标记为无效交易。排序服务要做得很简单，先是接收网络中所有通道发出的交易信息，读取交易信封的Envelope.Payload.Header.ChannelHeader.ChannelId以获取通道名称，按各个通道上交易的接收时间顺序对交易信息进行排序，生成区块。 6、排序服务节点以广播给组织的主节点 排序服务节点生成区块以后会广播给通道上不同组织的主节点。 7、记账节点验证区块内容并写入区块 背书节点是动态角色，只要参与交易的背书就是背书节点，哪些交易选择哪些节点作为背书节点是由应用程序选择的，这需要满足背书策略才能生效。所有的背书节点都属于记账节点。所有的Peer节点都是记账节点，记录的是节点已加入通道的账本数据。记账节点接收到的是排序服务节点生成的区块，验证区块交易的有效性，提交到本地账本后再产生一个生成区块的事件，监听区块事件的应用程序可以进行后续的处理。 如果接收到的区块是配置区块，则会更新缓存的配置信息。记账节点的处理流程如图所示。 交易数据的验证 区块数据的验证是以交易验证为单位的，每次对区块进行验证时都会生成一个交易号的位图TxValidationFlags，它记录每个交易号的交易验证状态，只有状态为TxValidationCode_VALID才是有效的。位图也会写入到区块的元数据BlockMetadataIndex_TRANSACTIONS_FILTER中。交易验证的时候会检查以下内容： 是否为合法的交易：交易格式是否正确，是否有合法的签名，交易内容是否被篡改； 记账节点是否加入了这个通道。 基本的验证通过以后会提交给VSCC进行背书策略的验证。 记账节点与VSCC 链码的交易是隔离的，每个交易的模拟执行结果读写集TxRwSet都包含了交易所属的链码。为了避免错误地更新链码交易数据，在交易提交给系统链码VSCC验证交易内容之前，还会对链码进行校验。下面这些交易都是非法的： 链码的名称或者版本为空； 交易消息头里的链码名称Envelope.Payload.Header.ChannelHeader.Extension.ChaincodeId. Name和交易数据里的链码名称Envelope.Payload.Data.TransactionAction.Payload.ChaincodeProposalPayload.Input.ChaincodeSpec.ChaincodeId.Name不一致； 链码更新当前链码数据时，生成读写集的链码版本不是LSCC记录的最新版本； 应用程序链码更新了LSCC（生命周期管理系统链码）的数据； 应用程序链码更新了不可被外部调用的系统链码的数据； 应用程序链码更新了不可被其他链码调用的系统链码的数据； 调用了不可被外部调用的系统链码。 基于状态数据的验证和MVCC检查 交易通过VSCC检查以后，就进入记账流程。kvledger还会对读写集TxRwSet进行MVCC（Multi-Version Concurrency Control）检查。 kvledger实现的是基于键值对（key-value）的状态数据模型。对状态数据的键有3种操作： 读状态数据； 写状态数据； 删除状态数据。 对状态数据的读操作有两种形式： 基于单一键的读取； 基于键范围的读取。 MVCC检查只对读数据进行校验，基本逻辑是对模拟执行时状态数据的版本和提交交易时状态数据的版本进行比较。如果数据版本发生变化或者某个键的范围数据发生变化，就说明这段时间之内有别的交易改变了状态数据，当前交易基于原有状态的处理就是有问题的。由于交易提交是并行的，所以在交易未打包生成区块之前，并不能确定最终的执行顺序。如果交易执行的顺序存在依赖，在MVCC检查的时候就会出现依赖的状态发生了变化，实际上是数据出现了冲突。图所示为基于状态的数据验证的流程图。 写集合本身包含了写和删除的数据，有一个状态位标识是否删除数据。为了提升效率，状态数据库的提交是批处理的，整个区块交易的状态数据同时提交，这也保证了整个区块的状态数据要么都提交成功，要么都提交失败。这时只会出现记录的账本数据和状态数据库不一致，不会出现区块的状态数据不一致的情况。当账本数据和状态数据库不一致时，可以通过状态数据库的检查点来标记。 无效交易的处理 伪造的交易会导致无效交易，正常的交易也可能出现无效交易。MVCC检查的是背书节点在模拟执行的时候，环境是否和记账节点提交交易时的环境一致，这里的环境是指状态数据库里数据的三元组（key、value、version）是否完全一致。如果正常提交的交易在这个过程中涉及的数据发生了变化，那么也会出现检查失败从而导致无效交易。在这种情况下，需要在上层的应用程序有一些补偿措施，比如调整交易打包的配置，重新提交失败的交易等。 在目前版本的实现中，无效交易也会保留在区块中，可以通过区块记录的元数据确定哪些是无效交易。无效交易的读写集不会提交到状态数据库中，不会导致状态数据库发生变化，只是会占用区块的大小，占用记账节点的硬盘空间。后续的版本会实现账本的精简，过滤掉无效交易。 8、在组织内部同步最新的区块 下篇预告：深度探索Hyperledger技术与应用之超级账本的策略管理 京东有购：https://item.jd.com/12279369.html 深度探索区块链 Hyperledger技术与应用 区块链 张增骏，董宁，朱轩彤，陈剑雄 　著 本书由超级账本执行董事Brian Behlendorf领衔推荐，区块链一线落地实践团队、Hyperleger会员智链骨干团对撰写。深入讲解Hyperledger Fabric 1.0的架构、执行逻辑、核心功能实现、从零部署，并以票据案例为例，讲解具体开发实践，穿插开发所需的最佳实践和遇到的问题解决。 机械工业 出版社 华章科技是机械出版社的旗下品牌，出版了“计算机科学丛书”等近30个经典套系，在各个细分领域均处于领导地位，其中《Java编程思想》、《算法导论》、《编译原理》、《数据挖掘：概念与技术》、《深入理解计算机系统》、《深入理解Java虚拟机》等著作犹如计算机图书领域的璀璨明珠，长销不衰！ HiBlock秉承开放、协作、透明、链接、分享的价值观，致力打造区块链开发者社区。专注于在开发者中推广区块链，帮助开发者真正掌握区块链技术和应用。 本文内容节选自《深度探索区块链：Hyperledger技术与应用》一书的第3章《超级账本的系统架构》。 本书作者：张增骏，董宁，朱轩彤，陈剑雄 感谢机械工业出版社华章分社的支持和分享。 以下是我们的社区介绍，欢迎各种合作、交流、学习：） 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/05/06/513dcadb7e7e37bf37e7f2bcccfae564.html","headline":"深度探索Hyperledger技术与应用之超级账本的典型交易流程","dateModified":"2018-05-06T00:00:00+08:00","datePublished":"2018-05-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/05/06/513dcadb7e7e37bf37e7f2bcccfae564.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>深度探索Hyperledger技术与应用之超级账本的典型交易流程</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-01813761a7b5522a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>上一篇分享了<a href="http://mp.weixin.qq.com/s?__biz=MzA5NDAxNzIzNg==&amp;mid=2450004316&amp;idx=2&amp;sn=2d07b84759c1848963099d393a738f38&amp;chksm=87a9bae7b0de33f138abd6a060f96883516a4a03e6a43f08d902742eb87692819a2441ba9cdf&amp;scene=21#wechat_redirect" rel="nofollow" target="_blank">超级账本的系统逻辑架构和网络节点架构</a>，本篇主要分享超级账本的典型交易流程。</p> 
  <h1 id="1">1</h1> 
  <h1 id="典型交易流程"><strong>典型交易流程</strong></h1> 
  <p>下图所示为Hyperledger Fabric 1.0典型的交易流程图。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-728ff64588f5a6e5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>从上一节的网络节点架构中，我们已经了解到基于Hyperledger Fabric 1.0的区块链应用中涉及几个节点角色：应用程序、背书节点、排序服务节点和主节点。在图3-4中，假定各节点已经提前颁发好证书，且已正常启动，并加入已经创建好的通道。后面的步骤介绍在已经实例化了的链码通道上从发起一个调用交易到最终记账的全过程。</p> 
  <p><strong>1、创建交易提案并发送给背书节点</strong></p> 
  <p>使用应用程序构造交易提案，SignedProposal的结构如下所示：</p> 
  <pre class="prettyprint"><code class=" hljs http"><span class="hljs-attribute">SignedProposal</span>: <span class="hljs-string">{</span>

<span class="http"> <span class="hljs-attribute">ProposalBytes(Proposal)</span>: <span class="hljs-string">{</span> <span class="http"> <span class="hljs-attribute">Header</span>: <span class="hljs-string">{</span> <span class="http"> <span class="hljs-attribute">ChannelHeader</span>: <span class="hljs-string">{</span> <span class="http"> <span class="hljs-attribute">Type</span>: <span class="hljs-string">"HeaderType_ENDORSER_TRANSACTION",</span> <span class="http"> <span class="hljs-attribute">TxId</span>: <span class="hljs-string">TxId,</span> <span class="http"> <span class="hljs-attribute">Timestamp</span>: <span class="hljs-string">Timestamp,</span> <span class="http"> <span class="hljs-attribute">ChannelId</span>: <span class="hljs-string">ChannelId,</span> <span class="http"> <span class="hljs-attribute">Extension(ChaincodeHeaderExtension)</span>: <span class="hljs-string">{</span> <span class="http"> <span class="hljs-attribute">PayloadVisibility</span>: <span class="hljs-string">PayloadVisibility,</span> <span class="http"> <span class="hljs-attribute">ChaincodeId</span>: <span class="hljs-string">{</span> <span class="http"> <span class="hljs-attribute">Path</span>: <span class="hljs-string">Path,</span> <span class="http"> <span class="hljs-attribute">Name</span>: <span class="hljs-string">Name,</span> <span class="http"> <span class="hljs-attribute">Version</span>: <span class="hljs-string">Version</span> <span class="css"> } }, <span class="hljs-tag">Epoch</span>: <span class="hljs-tag">Epoch</span> }, <span class="hljs-tag">SignatureHeader</span>: <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">Creator</span>:<span class="hljs-value"> Creator, Nonce: Nonce </span></span></span>} }, <span class="hljs-tag">Payload</span>: <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">ChaincodeProposalPayload</span>:<span class="hljs-value"> { <span class="hljs-function">Input(ChaincodeInvocationSpec)</span>: { ChaincodeSpec: { Type: Type, ChaincodeId: { Name: Name </span></span></span>}, <span class="hljs-tag">Input</span>(<span class="hljs-tag">ChaincodeInput</span>): <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">Args</span>:<span class="hljs-value"> [] </span></span></span>} } }, <span class="hljs-tag">TransientMap</span>: <span class="hljs-tag">TransientMap</span> } } }, <span class="hljs-tag">Signature</span>: <span class="hljs-tag">Signature</span> }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
  <p>我们来看看上面的结构，SignedProposal是封装了Proposal的结构，添加了调用者的签名信息。背书节点会根据签名信息验证其是否是一个有效的消息。Proposal由两个部分组成：消息头和消息结构。消息结构详细的解释参考后面的章节。这里简单讲一下消息头。</p> 
  <p><strong>消息头（Header）也包含两项内容。</strong></p> 
  <p><strong>通道头（ChannelHeader）</strong>：通道头包含了与通道和链码调用相关的信息，比如在哪个通道上调用哪个版本的链码。TxId是应用程序本地生成的交易号，跟调用者的身份证书相关，可以避免交易号的冲突，背书节点和记账节点都会校验是否存在重复交易。</p> 
  <p><strong>签名头（SignatureHeader）</strong>：签名头包含了调用者的身份证书和一个随机数，用于消息的有效性校验。</p> 
  <p>应用程序构造好交易提案请求后，选择背书节点执行并进行背书签名。背书节点是链码背书策略里指定的节点。有一些背书节点是离线的，其他的背书节点可以拒绝对交易进行背书，也可以不背书。应用程序可以尝试使用其他可用的背书节点来满足策略。应用程序以何种顺序给背书节点发送背书请求是没有关系的，正常情况下背书节点执行后的结果是一致的，只有背书节点对结果的签名不一样。</p> 
  <p><strong>2、背书节点模拟交易并生成背书签名</strong></p> 
  <p><strong>背书节点在收到交易提案后会进行一些验证，包括：</strong></p> 
  <ul> 
   <li><p>交易提案的格式是否正确；</p></li> 
   <li><p>交易是否提交过（重复攻击保护）；</p></li> 
   <li><p>交易签名有效（通过 MSP）；</p></li> 
   <li><p>交易提案的提交者在当前通道上是否已授权有写权限。</p></li> 
  </ul> 
  <p>验证通过后，背书节点会根据当前账本数据模拟执行链码中的业务逻辑并生成读写集（RwSet），其中包含响应值、读写集等。在模拟执行时账本数据不会更新。而后背书节点对这些读写集进行签名成为提案响应（Proposal Response），然后返回给应用程序。</p> 
  <p><strong>ProposalResponse的结构如下：</strong></p> 
  <pre class="prettyprint"><code class=" hljs http"><span class="hljs-attribute">ProposalResponse</span>: <span class="hljs-string">{</span>

<span class="http"> <span class="hljs-attribute">Version</span>: <span class="hljs-string">Version,</span> <span class="http"> <span class="hljs-attribute">Timestamp</span>: <span class="hljs-string">Timestamp,</span> <span class="http"> <span class="hljs-attribute">Response</span>: <span class="hljs-string">{</span> <span class="http"> <span class="hljs-attribute">Status</span>: <span class="hljs-string">Status,</span> <span class="http"> <span class="hljs-attribute">Message</span>: <span class="hljs-string">Message,</span> <span class="http"> <span class="hljs-attribute">Payload</span>: <span class="hljs-string">Payload</span> <span class="cmake"> }, Payload(ProposalResponsePayload): { ProposalHash: ProposalHash, Extension(ChaincodeAction): { Results(TxRwSet): { NsRwSets(NsRwSet): [ NameSpace: NameSpace, KvRwSet: { Reads(KVRead): [ Key: Key, Version: { BlockNum: BlockNum, TxNum: TxNum } ], RangeQueriesInfo(RangeQueryInfo): [ StartKey: StartKey, EndKey: EndKey, ItrExhausted: ItrExhausted, ReadsInfo: ReadsInfo ], Writes(KVWrite): [ Key: Key, IsDelete: IsDelete, Value: Value ] } ] }, Events(ChaincodeEvent): { ChaincodeId: ChaincodeId, TxId: TxId, EventName: EventName, Payload: Payload } Response: { Status: Status, <span class="hljs-keyword">Message</span>: <span class="hljs-keyword">Message</span>, Payload: Payload }, ChaincodeId: ChaincodeId } }, Endorsement: { Endorser: Endorser, Signature: Signature } }</span></span></span></span></span></span></span></code></pre> 
  <p>返回的ProposalResponse中包含了读写集、背书节点签名以及通道名称等信息。</p> 
  <p><strong>3、收集交易的背书</strong></p> 
  <p>应用程序收到ProposalResponse后会对背书节点签名进行验证，所有节点接收到任何消息后都是需要先验证消息合法性的。如果链码只进行账本查询，应用程序会检查查询响应，但不会将交易提交给排序服务节点。如果链码对账本进行Invoke操作，则须提交交易给排序服务进行账本更新，应用程序会在提交交易前判断背书策略是否满足。如果应用程序没有收集到足够的背书就提交交易了，记账节点在提交验证阶段会发现交易不能满足背书策略，标记为无效交易。</p> 
  <p>如何选择背书节点呢？目前fabric-sdk-go默认的实现是把配置文件选项channels.mychannel.peers（其中的mychannel需要替换成实际的通道名称）里的节点全部添加为背书节点，需要等待所有背书节点的背书签名。应用程序等待每个背书节点执行的超时时间是通过配置文件选项client.peer.timeout.connection设置的，配置文件的示例给出的是3秒，根据实际情况调整，如果没有设置就是5秒的默认值。</p> 
  <p><strong>4、构造交易请求并发送给排序服务节点</strong></p> 
  <p>应用程序接收到所有的背书节点签名后，根据背书签名调用SDK生成交易，广播给排序服务节点。生成交易的过程比较简单，确认所有的背书节点的执行结果完全一致，再将交易提案、提案响应和背书签名打包生成交易。<strong>交易的结构如下：</strong></p> 
  <pre class="prettyprint"><code class=" hljs http"><span class="hljs-attribute">Envelope</span>: <span class="hljs-string">{</span>

<span class="http"> <span class="hljs-attribute">Payload</span>: <span class="hljs-string">{</span> <span class="http"> <span class="hljs-attribute">Header</span>: <span class="hljs-string">{</span> <span class="http"> <span class="hljs-attribute">ChannelHeader</span>: <span class="hljs-string">{</span> <span class="http"> <span class="hljs-attribute">Type</span>: <span class="hljs-string">"HeaderType_ENDORSER_TRANSACTION",</span> <span class="http"> <span class="hljs-attribute">TxId</span>: <span class="hljs-string">TxId,</span> <span class="http"> <span class="hljs-attribute">Timestamp</span>: <span class="hljs-string">Timestamp,</span> <span class="http"> <span class="hljs-attribute">ChannelId</span>: <span class="hljs-string">ChannelId,</span> <span class="http"> <span class="hljs-attribute">Extension(ChaincodeHeaderExtension)</span>: <span class="hljs-string">{</span> <span class="http"> <span class="hljs-attribute">PayloadVisibility</span>: <span class="hljs-string">PayloadVisibility,</span> <span class="http"> <span class="hljs-attribute">ChaincodeId</span>: <span class="hljs-string">{</span> <span class="http"> <span class="hljs-attribute">Path</span>: <span class="hljs-string">Path,</span> <span class="http"> <span class="hljs-attribute">Name</span>: <span class="hljs-string">Name,</span> <span class="http"> <span class="hljs-attribute">Version</span>: <span class="hljs-string">Version</span> <span class="lasso"> } }, Epoch: Epoch }, SignatureHeader: { Creator: Creator, Nonce: Nonce } }, <span class="hljs-built_in">Data</span>(Transaction): { TransactionAction: <span class="hljs-preprocessor">[</span> <span class="hljs-keyword">Header</span>(SignatureHeader): { Creator: Creator, Nonce: Nonce }, Payload(ChaincodeActionPayload): { ChaincodeProposalPayload: { Input(ChaincodeInvocationSpec): { ChaincodeSpec: { <span class="hljs-keyword">Type</span>: <span class="hljs-keyword">Type</span>, ChaincodeId: { Name: Name }, Input(ChaincodeInput): { Args: <span class="hljs-preprocessor">[</span><span class="hljs-preprocessor">]</span><span class="hljs-markup"> } } }, TransientMap: nil }, Action(ChaincodeEndorsedAction): { Payload(ProposalResponsePayload): { ProposalHash: ProposalHash, Extension(ChaincodeAction): { Results(TxRwSet): { NsRwSets(NsRwSet): </span><span class="hljs-preprocessor">[</span> NameSpace: NameSpace, KvRwSet: { Reads(KVRead): <span class="hljs-preprocessor">[</span> Key: Key, Version: { BlockNum: BlockNum, TxNum: TxNum } <span class="hljs-preprocessor">]</span><span class="hljs-markup">, RangeQueriesInfo(RangeQueryInfo): </span><span class="hljs-preprocessor">[</span> StartKey: StartKey, EndKey: EndKey, ItrExhausted: ItrExhausted, ReadsInfo: ReadsInfo <span class="hljs-preprocessor">]</span><span class="hljs-markup">, Writes(KVWrite): </span><span class="hljs-preprocessor">[</span> Key: Key, IsDelete: IsDelete, Value: Value <span class="hljs-preprocessor">]</span><span class="hljs-markup"> } ] }, Events(ChaincodeEvent): { ChaincodeId: ChaincodeId, TxId: TxId, EventName: EventName, Payload: Payload } Response: { Status: Status, Message: Message, Payload: Payload }, ChaincodeId: ChaincodeId } }, Endorsement: </span><span class="hljs-preprocessor">[</span> Endorser: Endorser, Signature: Signature <span class="hljs-preprocessor">]</span><span class="hljs-markup"> } } ] } }, Signature: Signature }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
  <p>我们来看交易信封的几个对应关系：</p> 
  <ul> 
   <li><p>Envelope.Payload.Header同交易提案SignedProposal.Proposal.Header；</p></li> 
   <li><p>Envelope.Payload.Data.TransactionAction.Header是交易提案的提交者的身份信息，同SignedProposal.Proposal.Header.SignatureHeader和Envelope.Payload.Header.SignatureHeader是冗余的；</p></li> 
   <li><p>Envelope.Payload.Data.TransactionAction.Payload.ChaincodeProposalPayload同交易提案的SignedProposal.Proposal.Payload.ChaincodeProposalPayload，唯一不同的是，TransientMap强制设置为nil，目的是避免在区块中出现一些敏感信息；</p></li> 
   <li><p>Envelope.Payload.Data.TransactionAction.Payload.Action.Payload结构，其实和Proposal</p></li> 
   <li><p>Response.Payload结构完全一样；</p></li> 
   <li><p>Envelope.Payload.Data.TransactionAction.Payload.Action.Endorsement变成了数组，代表多个背书节点的背书签名。</p></li> 
  </ul> 
  <p>整个信封Envelope的Signature是交易提交者对整个Envelope.Payload的签名。应用程序可以把生成的交易信封内容发送给任意选择的几个排序服务节点。</p> 
  <p><strong>5、排序服务节点以对交易进行排序并生成区块</strong></p> 
  <p>排序服务不读取交易的内容，如果在生成交易信封内容的时候伪造了交易模拟执行的结果，排序服务节点也不会发现，但会在最终的交易验证阶段校验出来并标记为无效交易。排序服务要做得很简单，先是接收网络中所有通道发出的交易信息，读取交易信封的Envelope.Payload.Header.ChannelHeader.ChannelId以获取通道名称，按各个通道上交易的接收时间顺序对交易信息进行排序，生成区块。</p> 
  <p><strong>6、排序服务节点以广播给组织的主节点</strong></p> 
  <p>排序服务节点生成区块以后会广播给通道上不同组织的主节点。</p> 
  <p><strong>7、记账节点验证区块内容并写入区块</strong></p> 
  <p>背书节点是动态角色，只要参与交易的背书就是背书节点，哪些交易选择哪些节点作为背书节点是由应用程序选择的，这需要满足背书策略才能生效。所有的背书节点都属于记账节点。所有的Peer节点都是记账节点，记录的是节点已加入通道的账本数据。记账节点接收到的是排序服务节点生成的区块，验证区块交易的有效性，提交到本地账本后再产生一个生成区块的事件，监听区块事件的应用程序可以进行后续的处理。</p> 
  <p>如果接收到的区块是配置区块，则会更新缓存的配置信息。记账节点的处理流程如图所示。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-97e9275f8e38130c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p><strong>交易数据的验证</strong></p> 
  <p>区块数据的验证是以交易验证为单位的，每次对区块进行验证时都会生成一个交易号的位图TxValidationFlags，它记录每个交易号的交易验证状态，只有状态为TxValidationCode_VALID才是有效的。位图也会写入到区块的元数据BlockMetadataIndex_TRANSACTIONS_FILTER中。<strong>交易验证的时候会检查以下内容：</strong></p> 
  <ul> 
   <li><p>是否为合法的交易：交易格式是否正确，是否有合法的签名，交易内容是否被篡改；</p></li> 
   <li><p>记账节点是否加入了这个通道。</p></li> 
  </ul> 
  <p>基本的验证通过以后会提交给VSCC进行背书策略的验证。</p> 
  <p><strong>记账节点与VSCC</strong></p> 
  <p>链码的交易是隔离的，每个交易的模拟执行结果读写集TxRwSet都包含了交易所属的链码。为了避免错误地更新链码交易数据，在交易提交给系统链码VSCC验证交易内容之前，还会对链码进行校验。<strong>下面这些交易都是非法的：</strong></p> 
  <ul> 
   <li><p>链码的名称或者版本为空；</p></li> 
   <li><p>交易消息头里的链码名称Envelope.Payload.Header.ChannelHeader.Extension.ChaincodeId. Name和交易数据里的链码名称Envelope.Payload.Data.TransactionAction.Payload.ChaincodeProposalPayload.Input.ChaincodeSpec.ChaincodeId.Name不一致；</p></li> 
   <li><p>链码更新当前链码数据时，生成读写集的链码版本不是LSCC记录的最新版本；</p></li> 
   <li><p>应用程序链码更新了LSCC（生命周期管理系统链码）的数据；</p></li> 
   <li><p>应用程序链码更新了不可被外部调用的系统链码的数据；</p></li> 
   <li><p>应用程序链码更新了不可被其他链码调用的系统链码的数据；</p></li> 
   <li><p>调用了不可被外部调用的系统链码。</p></li> 
  </ul> 
  <p><strong>基于状态数据的验证和MVCC检查</strong></p> 
  <p>交易通过VSCC检查以后，就进入记账流程。kvledger还会对读写集TxRwSet进行MVCC（Multi-Version Concurrency Control）检查。</p> 
  <p>kvledger实现的是基于键值对（key-value）的状态数据模型。<strong>对状态数据的键有3种操作：</strong></p> 
  <ul> 
   <li><p>读状态数据；</p></li> 
   <li><p>写状态数据；</p></li> 
   <li><p>删除状态数据。</p></li> 
  </ul> 
  <p><strong>对状态数据的读操作有两种形式：</strong></p> 
  <ul> 
   <li><p>基于单一键的读取；</p></li> 
   <li><p>基于键范围的读取。</p></li> 
  </ul> 
  <p>MVCC检查只对读数据进行校验，基本逻辑是对模拟执行时状态数据的版本和提交交易时状态数据的版本进行比较。如果数据版本发生变化或者某个键的范围数据发生变化，就说明这段时间之内有别的交易改变了状态数据，当前交易基于原有状态的处理就是有问题的。由于交易提交是并行的，所以在交易未打包生成区块之前，并不能确定最终的执行顺序。如果交易执行的顺序存在依赖，在MVCC检查的时候就会出现依赖的状态发生了变化，实际上是数据出现了冲突。图所示为基于状态的数据验证的流程图。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-f6eaac2ed4549ae8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>写集合本身包含了写和删除的数据，有一个状态位标识是否删除数据。为了提升效率，状态数据库的提交是批处理的，整个区块交易的状态数据同时提交，这也保证了整个区块的状态数据要么都提交成功，要么都提交失败。这时只会出现记录的账本数据和状态数据库不一致，不会出现区块的状态数据不一致的情况。当账本数据和状态数据库不一致时，可以通过状态数据库的检查点来标记。</p> 
  <p><strong>无效交易的处理</strong></p> 
  <p>伪造的交易会导致无效交易，正常的交易也可能出现无效交易。MVCC检查的是背书节点在模拟执行的时候，环境是否和记账节点提交交易时的环境一致，这里的环境是指状态数据库里数据的三元组（key、value、version）是否完全一致。如果正常提交的交易在这个过程中涉及的数据发生了变化，那么也会出现检查失败从而导致无效交易。在这种情况下，需要在上层的应用程序有一些补偿措施，比如调整交易打包的配置，重新提交失败的交易等。</p> 
  <p>在目前版本的实现中，无效交易也会保留在区块中，可以通过区块记录的元数据确定哪些是无效交易。无效交易的读写集不会提交到状态数据库中，不会导致状态数据库发生变化，只是会占用区块的大小，占用记账节点的硬盘空间。后续的版本会实现账本的精简，过滤掉无效交易。</p> 
  <p><strong>8、在组织内部同步最新的区块</strong></p> 
  <p>下篇预告：深度探索Hyperledger技术与应用之超级账本的策略管理</p> 
  <p>京东有购：<a href="https://item.jd.com/12279369.html" rel="nofollow" target="_blank">https://item.jd.com/12279369.html</a></p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-3fc0e02541e61132?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="深度探索区块链 A.jpg"></p> 
  <p>深度探索区块链</p> 
  <p>Hyperledger技术与应用</p> 
  <p>区块链</p> 
  <p>张增骏，董宁，朱轩彤，陈剑雄 　著</p> 
  <p>本书由超级账本执行董事Brian Behlendorf领衔推荐，区块链一线落地实践团队、Hyperleger会员智链骨干团对撰写。深入讲解Hyperledger Fabric 1.0的架构、执行逻辑、核心功能实现、从零部署，并以票据案例为例，讲解具体开发实践，穿插开发所需的最佳实践和遇到的问题解决。</p> 
  <p>机械工业</p> 
  <p>出版社</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-38e957e62c906466?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p>华章科技是机械出版社的旗下品牌，出版了“计算机科学丛书”等近30个经典套系，在各个细分领域均处于领导地位，其中《Java编程思想》、《算法导论》、《编译原理》、《数据挖掘：概念与技术》、《深入理解计算机系统》、《深入理解Java虚拟机》等著作犹如计算机图书领域的璀璨明珠，长销不衰！</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-17503dcfcb1f1e91?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
  <p><strong>HiBlock</strong>秉承开放、协作、透明、链接、分享的价值观，致力打造区块链开发者社区。专注于在开发者中推广区块链，帮助开发者真正掌握区块链技术和应用。</p> 
  <blockquote> 
   <p>本文内容节选自《深度探索区块链：Hyperledger技术与应用》一书的第3章《超级账本的系统架构》。</p> 
   <p>本书作者：张增骏，董宁，朱轩彤，陈剑雄</p> 
   <p>感谢机械工业出版社华章分社的支持和分享。</p> 
  </blockquote> 
  <p>以下是我们的社区介绍，欢迎各种合作、交流、学习：）</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/10818463-baf069e068148c0c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title=""></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/HiBlock/article/details/80212499,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/HiBlock/article/details/80212499,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
