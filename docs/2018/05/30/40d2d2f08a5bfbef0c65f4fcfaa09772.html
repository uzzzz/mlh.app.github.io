<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>第二章 比特币的去中心化的方式 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="第二章 比特币的去中心化的方式" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="比特币的去中心化方式不是单纯的某个技术，多个技术的一个组合，使用了一个非常巧妙的奖励机制。 中心化和去中心化 传统的交易都是使用了中心化策略，比如支付宝、微信等的支付平台。卖家和买家的交易都要通过平台进行同意管理。当然，这些平台在不同的地方，存放多个数据库，数据库的资料要保持一致，防止发生意外。因此，所有的交易记录，用户信息都存储在这个中心化的平台中。而去中心化的策略则没有中心服务器的概念，取而代之的策略是P2P网络。 在研究去中心化的比特币时，要明确5个问题： 谁来记录所有的账本和交易 谁有权利来说明交易的有效性 谁来发行货币 谁来决定系统改变的规则 比特币怎样获取交易价值 分布式共识 给出分布式共识协议。假设有n个结点，每个结点都有一个输入值。但是，这里面有一些错误的结点和恶意结点。一个分布式共识协议有下面两个属性： 所有的城市结点必须都同意输入值 输入值必须由所有的诚实结点保证 为了理解比特币的分布式共识策略的实现，我们必须始终记得比特币是一个P2P的系统。举个例子，Alice想要给Bob支付一笔钱，那么Alice需要向整个P2P的比特币网络中广播这个消息，如下图： 在这里，Bob是否在网络上不重要，只要这个广播发出，而且交易是有效的，那么Bob就会拥有ALice支付给他的比特币。 P2P网络中所有的结点都有一个由块序列组成的账本，每个账本包含一个交易的列表。此外，每个结点都一个存储接收到的但是还没有加入到区块链中的缓冲池区，缓冲池中的交易还没有达成共识。每个结点的缓冲池中的交易信息可能有些差异，实际上，这是因为P2P网络自身不是很完备，因此一些结点可能收到了交易信息，而另一些没有收到。 一种实现共识的方式是：在一个周期性间隔内，系统中的每个结点把缓冲池中的交易加入到下一个区块中。之后，结点执行一些共识协议，每个结点包输入自己的区块。现在，一些恶意结点会在自己的区块中输入无效的交易信息，但是，我们假设其他结点是诚实的。如果共识协议成功了，一个有效的区块就会作为被选择作为输出，即使这个被选择的区块仅由一个结点提出，但只要区块是有效的，那么输出就是有效的。现在，可能还有一些有效的交易信息没有加入到区块中，它们会在之后加入到下一的区块。 上述方式存在3个问题：第一，结点可能会崩溃，或者选择了恶意结点；第二，网络是不完全的，在P2P网络中，不是所有的结点都会与其他的所有结点互相链接，或者网络本本身出现了问题，比如网络链接不好等，所有的结点都参加到网络中是运行共识协议是不现实的；最后，分布式的系统会可能存在很大的延迟。 综上所述：比特币的共识协议必须面对两个主要类型的威胁：网络的不完备性和一些结点可能想故意颠覆交易进程。 使用区块链实现共识 简化的比特币共识算法： 新的交易向全体结点广播 每个结点把新的交易加入到区块 每一轮随机选择结点，把它的区块入链 其他的结点接受这个区块，只要交易是有效的（签名机制保证）。 表示接受的结点，把这个区块的交易信息的哈希值加入到它们各自的下一个区块中。 我们列举出恶意结点可能颠覆系统的方式。假设颠覆者是Alice。 窃取比特币：这种方式是不现实的，因为只要使用了上一节中的签名系统，ALice就无法使用其他人的签名来伪造交易。除非Alice同时用于公钥和私钥。 拒绝服务攻击：假设Alice很讨厌Bob，她的系统拒绝为一切包含与Bob有关的交易信息服务。那么即使Bob的交易信息不会被Alice服务，但是只要有一个其他的诚实的结点接受该信息，那么该信息就会加入到区块链中。 双重支付攻击：这个攻击比较难理解。先做一个假设，Alice去Bob的在线网站购买一个付费软件，之后Alice从自己的地址中向Bob转发一个比特币，并向全网广播这个消息。我们假设一些诚实的结点接收到了这个消息，并把这个交易信息添加到了区块链上。现在，一个诚实的结点创造了一个包含Alice发给Bob比特币交易信息的区块。 回忆我们之前学习的交易信息的数据结构，交易信息的数据结构包含了Alice的签名（公钥），和一个Hash指针，该指针表示上一次的交易信息。该指针必须指向一个已经达成共识的区块链中的区块。 一个诚实的结点产生了最近一次交易的区块，该区块包含了Alice向Bob的支付信息。假设下一次随机选择的区块恰好由Alice控制，现在，Alice将要向区块中写入数据。由于这次写入数据的过程是有Alice控制，那么Alice可以忽略记录了她向Bob支付比特币的区块，而是让Hash指针指向支付的前一个区块那个区块；或者更进一步说，她把支付给Bob的地址改成支付给自己的。那么，如果操作成功了，Alice支付给Bob的交易信息就会消失，Alice等于没花比特币就下载了一个付费软件。 如下图，Alice在获取支付信息后，创造了两个交易：一个是她支付给Bob比特币，另一个是她双重支付这个比特币，她把该比特币发给了自己的一个账户地址。 双重支付策略是否成功，取决于上面连个区块中，哪一个会最终被达成共识的区块链所接受。诚实的区块链结点采取的策略是拓展最长的有效分支。现在，我们也无法确定哪个分支会被采用，因为现在这两个区块链的长度是一样的。双重支付的成功与否取决于伪造的地址那条链是否被采用。 实际上，结点一般拓展P2P网络上第一次接收到的区块。但是，这个规则不是固定的。网络的延迟也可能造成消息接收的次序混乱。而且，如果下一次还是Alice接收到本次的区块，那么她会继续采取类似的策略，这样会直接导致双重支付的区块链更长，从而在后续的验证中，支付给Bob的区块被遗弃。 再重新考虑上述的情景，当Alice向全网广播她给Bob支付的消息时，Bob也在监听网络，并在下一个区块建立前收到了这个消息。如果Bob在接收到该广播后，立刻允许Alice下载软件，这个过程就称为“零确信交易（Zero-confirmation transaction）”。 为了保证双重支付攻击的成功执行，恶意结点的操作者必须控制了下一个区块的生成过程。。但是，向上面提到的那样，如果Bob在收到单个结点确信信息之前就让Alice下载软件，那么Alice可以立刻向网络中广播双重支付信息，那么一个诚实的结点可能会在下一个区块链中创造包含该信息，而不是向Bob支付的信息。 Bob的防范策略：Bob在接收到Alice的广播后，不会立刻让Alice下载软件，而是等待多次确认后，再允许Alice下载软件（下图），这样双重支付的概率会变得和小。但是，完全安全的策略是不存在的。 理论上，确信的次数越多，安全性就越强。 奖励和工作量证明 如果结点的不诚实行为会存在潜在利益，那么就很难保证结点诚实的。但是，我们无法直接去乘法不诚实的结点，因为所有的交易都是匿名的，很难去追踪具体的交易者的踪迹。让结点诚实的最佳方式是给诚实结点奖励。比特币的奖励方式有两个，一个是区块奖励，另一个是交易费。这些奖励是为了给诚实的结点的。 区块奖励。创造一个区块可以在该区块中添加一个特殊的交易，该交易包含特定数目的比特币。创造区块的结点可以可以选择交易的接收地址，那么结点肯定会选择自己的地址作为接收方，那么这些比特币归该节点所有。区块奖励的理由是：如果创造区块的结点想要收集自己的奖励，那么必须要保证它创造的这个区块在最长的共识链上，只有这样，才能保证其他的结点都承认并接受这个区块。因此，如果该区块作假的话，它的创造的取款不会被承认，因此它也不会获得创造区块的奖励。 交易费。区块的创造者可以让交易输出的总价值少于交易输入的总价值。创造区者可以获得输入输出的差额。 之前讲述的简化版的比特币算法存在两大缺陷：选择区块的过程随机的，而且我们必须接受这个随机的结点输出的结果；奖励机制存在问题，每个参与者都想自己创造一个区块来获取奖励，这样会使得系统不稳定。 挖矿和工作量证明。上述的连个缺陷可以通过挖矿和工作量证明来弥补。我们通过结点计算资源所占比例来选择结点，而不是随机地选择。我们的目标是结点的计算能力越强大，那么结点就越有机会获得创建区块的机会。结点通过解决哈希难题来获取创建区块的权利。计算过程是：结点需要寻找一个数或者序列，把这个序列和之前的哈希值、该结点提出所有交易一起进行哈希计算；之后哈希函数会输出一个目标值。我们根据所有结点输出的不同的哈希值，选择最小的哈希值的输出作为可以创建新节点的结点。 51%攻击 假设攻击者控制了P2P网络中的51%的结点。我们考虑一下几种可能发生的情况： 第一个，控制51%结点的攻击者是否可以窃取比特币。答案是否定的，根据加密算法的协议，攻击者没有其他诚实结点的私钥，根据加密协议，他无法得到其他诚实结点的认可。即使它们伪造了新的区块，并创立了包含伪造区块的最长的区块链也不行。 第二个，假设攻击者试图花费无效的比特币。假设上文中的Alice控制了51%的结点，并且用无效的比特币向Bob购买软件。假设Bob自己运行了一个诚实的比特币结点，那么Bob肯定会拒绝这个交易，因为Alice的交易是无效的，交易中没有签名认证。 第三个，假设攻击者试图阻止交易。假设攻击者Alice拒绝为所有包含Carlo的区块提供服务。这也是不行的，因为攻击者无法阻止其他P2P网络上的结点接收到有关消息，因为网络本身是不依靠区块链和共识协议的。因此大多数结点还是可以收到这个交易消息。 第四个，攻击者是否可以更改区块奖励。比如攻击者把区块奖励由25改成50。这相当于改变了系统规则。但是，由于攻击者无法改变其他节点上运行的比特币软件，因此这种篡改无法得到其他结点的认可，因此这也是不行的。 最后一个，攻击者是否可以在一定程度上摧毁比特币的信任机制。假设系统中有大量的双重支付攻击、有大量的结点不去扩展最长的有效区块链和有一些其他的攻击。那么，人们可能认为比特币系统不是它们可信任的去中心化的账本了。之后，比特币交易的速率会直线下降。事实上，如果有一个团体控制了系统中51%的哈希计算能力，我们也会失去对系统的信任，即使该团体不打算发动攻击。 问题总结 再来回顾一下开始提出的5个问题： 1. 谁来记录所有的账本和交易：所有的信息有系统中所有的结点共同维护，所有的信息被记录在一个最长的有效区块链上。 2. 谁有权利来说明交易的有效性：交易的有效性由共识机制完成，并且需要在有效的区块链上记录后，得到诚实结点认同才行。 3. 谁来发行货币 ：发行比特币只有当创建新区块的时候才行， 而创建新区块需要靠结点解决哈希难题，这取决于结点的计算能力，当然，计算能力只是在概率上决定了创建新区块的可能性。 4. 谁来决定系统改变的规则 ：系统规则由共识机制决定。所有结点都需要遵循共识机制。共识机制的维护，通过奖励机制决定。 5. 比特币怎样获取交易价值 ：比特币本身不想一般的货币那样有面值，比如100美金等，它本质上是是一个交易信息的输出。价值在于记录了交易信息。 阅读更多" />
<meta property="og:description" content="比特币的去中心化方式不是单纯的某个技术，多个技术的一个组合，使用了一个非常巧妙的奖励机制。 中心化和去中心化 传统的交易都是使用了中心化策略，比如支付宝、微信等的支付平台。卖家和买家的交易都要通过平台进行同意管理。当然，这些平台在不同的地方，存放多个数据库，数据库的资料要保持一致，防止发生意外。因此，所有的交易记录，用户信息都存储在这个中心化的平台中。而去中心化的策略则没有中心服务器的概念，取而代之的策略是P2P网络。 在研究去中心化的比特币时，要明确5个问题： 谁来记录所有的账本和交易 谁有权利来说明交易的有效性 谁来发行货币 谁来决定系统改变的规则 比特币怎样获取交易价值 分布式共识 给出分布式共识协议。假设有n个结点，每个结点都有一个输入值。但是，这里面有一些错误的结点和恶意结点。一个分布式共识协议有下面两个属性： 所有的城市结点必须都同意输入值 输入值必须由所有的诚实结点保证 为了理解比特币的分布式共识策略的实现，我们必须始终记得比特币是一个P2P的系统。举个例子，Alice想要给Bob支付一笔钱，那么Alice需要向整个P2P的比特币网络中广播这个消息，如下图： 在这里，Bob是否在网络上不重要，只要这个广播发出，而且交易是有效的，那么Bob就会拥有ALice支付给他的比特币。 P2P网络中所有的结点都有一个由块序列组成的账本，每个账本包含一个交易的列表。此外，每个结点都一个存储接收到的但是还没有加入到区块链中的缓冲池区，缓冲池中的交易还没有达成共识。每个结点的缓冲池中的交易信息可能有些差异，实际上，这是因为P2P网络自身不是很完备，因此一些结点可能收到了交易信息，而另一些没有收到。 一种实现共识的方式是：在一个周期性间隔内，系统中的每个结点把缓冲池中的交易加入到下一个区块中。之后，结点执行一些共识协议，每个结点包输入自己的区块。现在，一些恶意结点会在自己的区块中输入无效的交易信息，但是，我们假设其他结点是诚实的。如果共识协议成功了，一个有效的区块就会作为被选择作为输出，即使这个被选择的区块仅由一个结点提出，但只要区块是有效的，那么输出就是有效的。现在，可能还有一些有效的交易信息没有加入到区块中，它们会在之后加入到下一的区块。 上述方式存在3个问题：第一，结点可能会崩溃，或者选择了恶意结点；第二，网络是不完全的，在P2P网络中，不是所有的结点都会与其他的所有结点互相链接，或者网络本本身出现了问题，比如网络链接不好等，所有的结点都参加到网络中是运行共识协议是不现实的；最后，分布式的系统会可能存在很大的延迟。 综上所述：比特币的共识协议必须面对两个主要类型的威胁：网络的不完备性和一些结点可能想故意颠覆交易进程。 使用区块链实现共识 简化的比特币共识算法： 新的交易向全体结点广播 每个结点把新的交易加入到区块 每一轮随机选择结点，把它的区块入链 其他的结点接受这个区块，只要交易是有效的（签名机制保证）。 表示接受的结点，把这个区块的交易信息的哈希值加入到它们各自的下一个区块中。 我们列举出恶意结点可能颠覆系统的方式。假设颠覆者是Alice。 窃取比特币：这种方式是不现实的，因为只要使用了上一节中的签名系统，ALice就无法使用其他人的签名来伪造交易。除非Alice同时用于公钥和私钥。 拒绝服务攻击：假设Alice很讨厌Bob，她的系统拒绝为一切包含与Bob有关的交易信息服务。那么即使Bob的交易信息不会被Alice服务，但是只要有一个其他的诚实的结点接受该信息，那么该信息就会加入到区块链中。 双重支付攻击：这个攻击比较难理解。先做一个假设，Alice去Bob的在线网站购买一个付费软件，之后Alice从自己的地址中向Bob转发一个比特币，并向全网广播这个消息。我们假设一些诚实的结点接收到了这个消息，并把这个交易信息添加到了区块链上。现在，一个诚实的结点创造了一个包含Alice发给Bob比特币交易信息的区块。 回忆我们之前学习的交易信息的数据结构，交易信息的数据结构包含了Alice的签名（公钥），和一个Hash指针，该指针表示上一次的交易信息。该指针必须指向一个已经达成共识的区块链中的区块。 一个诚实的结点产生了最近一次交易的区块，该区块包含了Alice向Bob的支付信息。假设下一次随机选择的区块恰好由Alice控制，现在，Alice将要向区块中写入数据。由于这次写入数据的过程是有Alice控制，那么Alice可以忽略记录了她向Bob支付比特币的区块，而是让Hash指针指向支付的前一个区块那个区块；或者更进一步说，她把支付给Bob的地址改成支付给自己的。那么，如果操作成功了，Alice支付给Bob的交易信息就会消失，Alice等于没花比特币就下载了一个付费软件。 如下图，Alice在获取支付信息后，创造了两个交易：一个是她支付给Bob比特币，另一个是她双重支付这个比特币，她把该比特币发给了自己的一个账户地址。 双重支付策略是否成功，取决于上面连个区块中，哪一个会最终被达成共识的区块链所接受。诚实的区块链结点采取的策略是拓展最长的有效分支。现在，我们也无法确定哪个分支会被采用，因为现在这两个区块链的长度是一样的。双重支付的成功与否取决于伪造的地址那条链是否被采用。 实际上，结点一般拓展P2P网络上第一次接收到的区块。但是，这个规则不是固定的。网络的延迟也可能造成消息接收的次序混乱。而且，如果下一次还是Alice接收到本次的区块，那么她会继续采取类似的策略，这样会直接导致双重支付的区块链更长，从而在后续的验证中，支付给Bob的区块被遗弃。 再重新考虑上述的情景，当Alice向全网广播她给Bob支付的消息时，Bob也在监听网络，并在下一个区块建立前收到了这个消息。如果Bob在接收到该广播后，立刻允许Alice下载软件，这个过程就称为“零确信交易（Zero-confirmation transaction）”。 为了保证双重支付攻击的成功执行，恶意结点的操作者必须控制了下一个区块的生成过程。。但是，向上面提到的那样，如果Bob在收到单个结点确信信息之前就让Alice下载软件，那么Alice可以立刻向网络中广播双重支付信息，那么一个诚实的结点可能会在下一个区块链中创造包含该信息，而不是向Bob支付的信息。 Bob的防范策略：Bob在接收到Alice的广播后，不会立刻让Alice下载软件，而是等待多次确认后，再允许Alice下载软件（下图），这样双重支付的概率会变得和小。但是，完全安全的策略是不存在的。 理论上，确信的次数越多，安全性就越强。 奖励和工作量证明 如果结点的不诚实行为会存在潜在利益，那么就很难保证结点诚实的。但是，我们无法直接去乘法不诚实的结点，因为所有的交易都是匿名的，很难去追踪具体的交易者的踪迹。让结点诚实的最佳方式是给诚实结点奖励。比特币的奖励方式有两个，一个是区块奖励，另一个是交易费。这些奖励是为了给诚实的结点的。 区块奖励。创造一个区块可以在该区块中添加一个特殊的交易，该交易包含特定数目的比特币。创造区块的结点可以可以选择交易的接收地址，那么结点肯定会选择自己的地址作为接收方，那么这些比特币归该节点所有。区块奖励的理由是：如果创造区块的结点想要收集自己的奖励，那么必须要保证它创造的这个区块在最长的共识链上，只有这样，才能保证其他的结点都承认并接受这个区块。因此，如果该区块作假的话，它的创造的取款不会被承认，因此它也不会获得创造区块的奖励。 交易费。区块的创造者可以让交易输出的总价值少于交易输入的总价值。创造区者可以获得输入输出的差额。 之前讲述的简化版的比特币算法存在两大缺陷：选择区块的过程随机的，而且我们必须接受这个随机的结点输出的结果；奖励机制存在问题，每个参与者都想自己创造一个区块来获取奖励，这样会使得系统不稳定。 挖矿和工作量证明。上述的连个缺陷可以通过挖矿和工作量证明来弥补。我们通过结点计算资源所占比例来选择结点，而不是随机地选择。我们的目标是结点的计算能力越强大，那么结点就越有机会获得创建区块的机会。结点通过解决哈希难题来获取创建区块的权利。计算过程是：结点需要寻找一个数或者序列，把这个序列和之前的哈希值、该结点提出所有交易一起进行哈希计算；之后哈希函数会输出一个目标值。我们根据所有结点输出的不同的哈希值，选择最小的哈希值的输出作为可以创建新节点的结点。 51%攻击 假设攻击者控制了P2P网络中的51%的结点。我们考虑一下几种可能发生的情况： 第一个，控制51%结点的攻击者是否可以窃取比特币。答案是否定的，根据加密算法的协议，攻击者没有其他诚实结点的私钥，根据加密协议，他无法得到其他诚实结点的认可。即使它们伪造了新的区块，并创立了包含伪造区块的最长的区块链也不行。 第二个，假设攻击者试图花费无效的比特币。假设上文中的Alice控制了51%的结点，并且用无效的比特币向Bob购买软件。假设Bob自己运行了一个诚实的比特币结点，那么Bob肯定会拒绝这个交易，因为Alice的交易是无效的，交易中没有签名认证。 第三个，假设攻击者试图阻止交易。假设攻击者Alice拒绝为所有包含Carlo的区块提供服务。这也是不行的，因为攻击者无法阻止其他P2P网络上的结点接收到有关消息，因为网络本身是不依靠区块链和共识协议的。因此大多数结点还是可以收到这个交易消息。 第四个，攻击者是否可以更改区块奖励。比如攻击者把区块奖励由25改成50。这相当于改变了系统规则。但是，由于攻击者无法改变其他节点上运行的比特币软件，因此这种篡改无法得到其他结点的认可，因此这也是不行的。 最后一个，攻击者是否可以在一定程度上摧毁比特币的信任机制。假设系统中有大量的双重支付攻击、有大量的结点不去扩展最长的有效区块链和有一些其他的攻击。那么，人们可能认为比特币系统不是它们可信任的去中心化的账本了。之后，比特币交易的速率会直线下降。事实上，如果有一个团体控制了系统中51%的哈希计算能力，我们也会失去对系统的信任，即使该团体不打算发动攻击。 问题总结 再来回顾一下开始提出的5个问题： 1. 谁来记录所有的账本和交易：所有的信息有系统中所有的结点共同维护，所有的信息被记录在一个最长的有效区块链上。 2. 谁有权利来说明交易的有效性：交易的有效性由共识机制完成，并且需要在有效的区块链上记录后，得到诚实结点认同才行。 3. 谁来发行货币 ：发行比特币只有当创建新区块的时候才行， 而创建新区块需要靠结点解决哈希难题，这取决于结点的计算能力，当然，计算能力只是在概率上决定了创建新区块的可能性。 4. 谁来决定系统改变的规则 ：系统规则由共识机制决定。所有结点都需要遵循共识机制。共识机制的维护，通过奖励机制决定。 5. 比特币怎样获取交易价值 ：比特币本身不想一般的货币那样有面值，比如100美金等，它本质上是是一个交易信息的输出。价值在于记录了交易信息。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-30T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"比特币的去中心化方式不是单纯的某个技术，多个技术的一个组合，使用了一个非常巧妙的奖励机制。 中心化和去中心化 传统的交易都是使用了中心化策略，比如支付宝、微信等的支付平台。卖家和买家的交易都要通过平台进行同意管理。当然，这些平台在不同的地方，存放多个数据库，数据库的资料要保持一致，防止发生意外。因此，所有的交易记录，用户信息都存储在这个中心化的平台中。而去中心化的策略则没有中心服务器的概念，取而代之的策略是P2P网络。 在研究去中心化的比特币时，要明确5个问题： 谁来记录所有的账本和交易 谁有权利来说明交易的有效性 谁来发行货币 谁来决定系统改变的规则 比特币怎样获取交易价值 分布式共识 给出分布式共识协议。假设有n个结点，每个结点都有一个输入值。但是，这里面有一些错误的结点和恶意结点。一个分布式共识协议有下面两个属性： 所有的城市结点必须都同意输入值 输入值必须由所有的诚实结点保证 为了理解比特币的分布式共识策略的实现，我们必须始终记得比特币是一个P2P的系统。举个例子，Alice想要给Bob支付一笔钱，那么Alice需要向整个P2P的比特币网络中广播这个消息，如下图： 在这里，Bob是否在网络上不重要，只要这个广播发出，而且交易是有效的，那么Bob就会拥有ALice支付给他的比特币。 P2P网络中所有的结点都有一个由块序列组成的账本，每个账本包含一个交易的列表。此外，每个结点都一个存储接收到的但是还没有加入到区块链中的缓冲池区，缓冲池中的交易还没有达成共识。每个结点的缓冲池中的交易信息可能有些差异，实际上，这是因为P2P网络自身不是很完备，因此一些结点可能收到了交易信息，而另一些没有收到。 一种实现共识的方式是：在一个周期性间隔内，系统中的每个结点把缓冲池中的交易加入到下一个区块中。之后，结点执行一些共识协议，每个结点包输入自己的区块。现在，一些恶意结点会在自己的区块中输入无效的交易信息，但是，我们假设其他结点是诚实的。如果共识协议成功了，一个有效的区块就会作为被选择作为输出，即使这个被选择的区块仅由一个结点提出，但只要区块是有效的，那么输出就是有效的。现在，可能还有一些有效的交易信息没有加入到区块中，它们会在之后加入到下一的区块。 上述方式存在3个问题：第一，结点可能会崩溃，或者选择了恶意结点；第二，网络是不完全的，在P2P网络中，不是所有的结点都会与其他的所有结点互相链接，或者网络本本身出现了问题，比如网络链接不好等，所有的结点都参加到网络中是运行共识协议是不现实的；最后，分布式的系统会可能存在很大的延迟。 综上所述：比特币的共识协议必须面对两个主要类型的威胁：网络的不完备性和一些结点可能想故意颠覆交易进程。 使用区块链实现共识 简化的比特币共识算法： 新的交易向全体结点广播 每个结点把新的交易加入到区块 每一轮随机选择结点，把它的区块入链 其他的结点接受这个区块，只要交易是有效的（签名机制保证）。 表示接受的结点，把这个区块的交易信息的哈希值加入到它们各自的下一个区块中。 我们列举出恶意结点可能颠覆系统的方式。假设颠覆者是Alice。 窃取比特币：这种方式是不现实的，因为只要使用了上一节中的签名系统，ALice就无法使用其他人的签名来伪造交易。除非Alice同时用于公钥和私钥。 拒绝服务攻击：假设Alice很讨厌Bob，她的系统拒绝为一切包含与Bob有关的交易信息服务。那么即使Bob的交易信息不会被Alice服务，但是只要有一个其他的诚实的结点接受该信息，那么该信息就会加入到区块链中。 双重支付攻击：这个攻击比较难理解。先做一个假设，Alice去Bob的在线网站购买一个付费软件，之后Alice从自己的地址中向Bob转发一个比特币，并向全网广播这个消息。我们假设一些诚实的结点接收到了这个消息，并把这个交易信息添加到了区块链上。现在，一个诚实的结点创造了一个包含Alice发给Bob比特币交易信息的区块。 回忆我们之前学习的交易信息的数据结构，交易信息的数据结构包含了Alice的签名（公钥），和一个Hash指针，该指针表示上一次的交易信息。该指针必须指向一个已经达成共识的区块链中的区块。 一个诚实的结点产生了最近一次交易的区块，该区块包含了Alice向Bob的支付信息。假设下一次随机选择的区块恰好由Alice控制，现在，Alice将要向区块中写入数据。由于这次写入数据的过程是有Alice控制，那么Alice可以忽略记录了她向Bob支付比特币的区块，而是让Hash指针指向支付的前一个区块那个区块；或者更进一步说，她把支付给Bob的地址改成支付给自己的。那么，如果操作成功了，Alice支付给Bob的交易信息就会消失，Alice等于没花比特币就下载了一个付费软件。 如下图，Alice在获取支付信息后，创造了两个交易：一个是她支付给Bob比特币，另一个是她双重支付这个比特币，她把该比特币发给了自己的一个账户地址。 双重支付策略是否成功，取决于上面连个区块中，哪一个会最终被达成共识的区块链所接受。诚实的区块链结点采取的策略是拓展最长的有效分支。现在，我们也无法确定哪个分支会被采用，因为现在这两个区块链的长度是一样的。双重支付的成功与否取决于伪造的地址那条链是否被采用。 实际上，结点一般拓展P2P网络上第一次接收到的区块。但是，这个规则不是固定的。网络的延迟也可能造成消息接收的次序混乱。而且，如果下一次还是Alice接收到本次的区块，那么她会继续采取类似的策略，这样会直接导致双重支付的区块链更长，从而在后续的验证中，支付给Bob的区块被遗弃。 再重新考虑上述的情景，当Alice向全网广播她给Bob支付的消息时，Bob也在监听网络，并在下一个区块建立前收到了这个消息。如果Bob在接收到该广播后，立刻允许Alice下载软件，这个过程就称为“零确信交易（Zero-confirmation transaction）”。 为了保证双重支付攻击的成功执行，恶意结点的操作者必须控制了下一个区块的生成过程。。但是，向上面提到的那样，如果Bob在收到单个结点确信信息之前就让Alice下载软件，那么Alice可以立刻向网络中广播双重支付信息，那么一个诚实的结点可能会在下一个区块链中创造包含该信息，而不是向Bob支付的信息。 Bob的防范策略：Bob在接收到Alice的广播后，不会立刻让Alice下载软件，而是等待多次确认后，再允许Alice下载软件（下图），这样双重支付的概率会变得和小。但是，完全安全的策略是不存在的。 理论上，确信的次数越多，安全性就越强。 奖励和工作量证明 如果结点的不诚实行为会存在潜在利益，那么就很难保证结点诚实的。但是，我们无法直接去乘法不诚实的结点，因为所有的交易都是匿名的，很难去追踪具体的交易者的踪迹。让结点诚实的最佳方式是给诚实结点奖励。比特币的奖励方式有两个，一个是区块奖励，另一个是交易费。这些奖励是为了给诚实的结点的。 区块奖励。创造一个区块可以在该区块中添加一个特殊的交易，该交易包含特定数目的比特币。创造区块的结点可以可以选择交易的接收地址，那么结点肯定会选择自己的地址作为接收方，那么这些比特币归该节点所有。区块奖励的理由是：如果创造区块的结点想要收集自己的奖励，那么必须要保证它创造的这个区块在最长的共识链上，只有这样，才能保证其他的结点都承认并接受这个区块。因此，如果该区块作假的话，它的创造的取款不会被承认，因此它也不会获得创造区块的奖励。 交易费。区块的创造者可以让交易输出的总价值少于交易输入的总价值。创造区者可以获得输入输出的差额。 之前讲述的简化版的比特币算法存在两大缺陷：选择区块的过程随机的，而且我们必须接受这个随机的结点输出的结果；奖励机制存在问题，每个参与者都想自己创造一个区块来获取奖励，这样会使得系统不稳定。 挖矿和工作量证明。上述的连个缺陷可以通过挖矿和工作量证明来弥补。我们通过结点计算资源所占比例来选择结点，而不是随机地选择。我们的目标是结点的计算能力越强大，那么结点就越有机会获得创建区块的机会。结点通过解决哈希难题来获取创建区块的权利。计算过程是：结点需要寻找一个数或者序列，把这个序列和之前的哈希值、该结点提出所有交易一起进行哈希计算；之后哈希函数会输出一个目标值。我们根据所有结点输出的不同的哈希值，选择最小的哈希值的输出作为可以创建新节点的结点。 51%攻击 假设攻击者控制了P2P网络中的51%的结点。我们考虑一下几种可能发生的情况： 第一个，控制51%结点的攻击者是否可以窃取比特币。答案是否定的，根据加密算法的协议，攻击者没有其他诚实结点的私钥，根据加密协议，他无法得到其他诚实结点的认可。即使它们伪造了新的区块，并创立了包含伪造区块的最长的区块链也不行。 第二个，假设攻击者试图花费无效的比特币。假设上文中的Alice控制了51%的结点，并且用无效的比特币向Bob购买软件。假设Bob自己运行了一个诚实的比特币结点，那么Bob肯定会拒绝这个交易，因为Alice的交易是无效的，交易中没有签名认证。 第三个，假设攻击者试图阻止交易。假设攻击者Alice拒绝为所有包含Carlo的区块提供服务。这也是不行的，因为攻击者无法阻止其他P2P网络上的结点接收到有关消息，因为网络本身是不依靠区块链和共识协议的。因此大多数结点还是可以收到这个交易消息。 第四个，攻击者是否可以更改区块奖励。比如攻击者把区块奖励由25改成50。这相当于改变了系统规则。但是，由于攻击者无法改变其他节点上运行的比特币软件，因此这种篡改无法得到其他结点的认可，因此这也是不行的。 最后一个，攻击者是否可以在一定程度上摧毁比特币的信任机制。假设系统中有大量的双重支付攻击、有大量的结点不去扩展最长的有效区块链和有一些其他的攻击。那么，人们可能认为比特币系统不是它们可信任的去中心化的账本了。之后，比特币交易的速率会直线下降。事实上，如果有一个团体控制了系统中51%的哈希计算能力，我们也会失去对系统的信任，即使该团体不打算发动攻击。 问题总结 再来回顾一下开始提出的5个问题： 1. 谁来记录所有的账本和交易：所有的信息有系统中所有的结点共同维护，所有的信息被记录在一个最长的有效区块链上。 2. 谁有权利来说明交易的有效性：交易的有效性由共识机制完成，并且需要在有效的区块链上记录后，得到诚实结点认同才行。 3. 谁来发行货币 ：发行比特币只有当创建新区块的时候才行， 而创建新区块需要靠结点解决哈希难题，这取决于结点的计算能力，当然，计算能力只是在概率上决定了创建新区块的可能性。 4. 谁来决定系统改变的规则 ：系统规则由共识机制决定。所有结点都需要遵循共识机制。共识机制的维护，通过奖励机制决定。 5. 比特币怎样获取交易价值 ：比特币本身不想一般的货币那样有面值，比如100美金等，它本质上是是一个交易信息的输出。价值在于记录了交易信息。 阅读更多","@type":"BlogPosting","url":"/2018/05/30/40d2d2f08a5bfbef0c65f4fcfaa09772.html","headline":"第二章 比特币的去中心化的方式","dateModified":"2018-05-30T00:00:00+08:00","datePublished":"2018-05-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/05/30/40d2d2f08a5bfbef0c65f4fcfaa09772.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>第二章 比特币的去中心化的方式</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>比特币的去中心化方式不是单纯的某个技术，多个技术的一个组合，使用了一个非常巧妙的奖励机制。</p> 
  <h2 id="中心化和去中心化">中心化和去中心化</h2> 
  <p>传统的交易都是使用了中心化策略，比如支付宝、微信等的支付平台。卖家和买家的交易都要通过平台进行同意管理。当然，这些平台在不同的地方，存放多个数据库，数据库的资料要保持一致，防止发生意外。因此，所有的交易记录，用户信息都存储在这个中心化的平台中。而去中心化的策略则没有中心服务器的概念，取而代之的策略是P2P网络。</p> 
  <p>在研究去中心化的比特币时，要明确5个问题：</p> 
  <ol> 
   <li>谁来记录所有的账本和交易</li> 
   <li>谁有权利来说明交易的有效性</li> 
   <li>谁来发行货币 </li> 
   <li>谁来决定系统改变的规则 </li> 
   <li>比特币怎样获取交易价值 </li> 
  </ol> 
  <h2 id="分布式共识">分布式共识</h2> 
  <p><strong>给出分布式共识协议</strong>。假设有n个结点，每个结点都有一个输入值。但是，这里面有一些错误的结点和恶意结点。一个分布式共识协议有下面两个属性：</p> 
  <ul> 
   <li>所有的城市结点必须都同意输入值</li> 
   <li>输入值必须由所有的诚实结点保证</li> 
  </ul> 
  <p>为了理解比特币的分布式共识策略的实现，我们必须始终记得比特币是一个P2P的系统。举个例子，Alice想要给Bob支付一笔钱，那么Alice需要向整个P2P的比特币网络中广播这个消息，如下图： <br> <img src="https://img-blog.csdn.net/20180529181121521?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc2MzUx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" title=""> <br> 在这里，Bob是否在网络上不重要，只要这个广播发出，而且交易是有效的，那么Bob就会拥有ALice支付给他的比特币。</p> 
  <p>P2P网络中所有的结点都有一个由块序列组成的账本，每个账本包含一个交易的列表。此外，每个结点都一个存储接收到的但是还没有加入到区块链中的缓冲池区，缓冲池中的交易还没有达成共识。每个结点的缓冲池中的交易信息可能有些差异，实际上，这是因为P2P网络自身不是很完备，因此一些结点可能收到了交易信息，而另一些没有收到。</p> 
  <p>一种实现共识的方式是：在一个周期性间隔内，系统中的每个结点把缓冲池中的交易加入到下一个区块中。之后，结点执行一些共识协议，每个结点包输入自己的区块。现在，一些恶意结点会在自己的区块中输入无效的交易信息，但是，我们假设其他结点是诚实的。如果共识协议成功了，一个有效的区块就会作为被选择作为输出，即使这个被选择的区块仅由一个结点提出，但只要区块是有效的，那么输出就是有效的。现在，可能还有一些有效的交易信息没有加入到区块中，它们会在之后加入到下一的区块。</p> 
  <p>上述方式存在3个问题：第一，结点可能会崩溃，或者选择了恶意结点；第二，网络是不完全的，在P2P网络中，不是所有的结点都会与其他的所有结点互相链接，或者网络本本身出现了问题，比如网络链接不好等，所有的结点都参加到网络中是运行共识协议是不现实的；最后，分布式的系统会可能存在很大的延迟。</p> 
  <p>综上所述：比特币的共识协议必须面对两个主要类型的威胁：网络的不完备性和一些结点可能想故意颠覆交易进程。</p> 
  <h2 id="使用区块链实现共识">使用区块链实现共识</h2> 
  <p>简化的比特币共识算法：</p> 
  <ol> 
   <li>新的交易向全体结点广播</li> 
   <li>每个结点把新的交易加入到区块</li> 
   <li>每一轮随机选择结点，把它的区块入链</li> 
   <li>其他的结点接受这个区块，只要交易是有效的（签名机制保证）。</li> 
   <li>表示接受的结点，把这个区块的交易信息的哈希值加入到它们各自的下一个区块中。</li> 
  </ol> 
  <p>我们列举出恶意结点可能颠覆系统的方式。假设颠覆者是Alice。</p> 
  <p><strong>窃取比特币：</strong>这种方式是不现实的，因为只要使用了上一节中的签名系统，ALice就无法使用其他人的签名来伪造交易。除非Alice同时用于公钥和私钥。</p> 
  <p><strong>拒绝服务攻击：</strong>假设Alice很讨厌Bob，她的系统拒绝为一切包含与Bob有关的交易信息服务。那么即使Bob的交易信息不会被Alice服务，但是只要有一个其他的诚实的结点接受该信息，那么该信息就会加入到区块链中。</p> 
  <p><strong>双重支付攻击：</strong>这个攻击比较难理解。先做一个假设，Alice去Bob的在线网站购买一个付费软件，之后Alice从自己的地址中向Bob转发一个比特币，并向全网广播这个消息。我们假设一些诚实的结点接收到了这个消息，并把这个交易信息添加到了区块链上。现在，一个诚实的结点创造了一个包含Alice发给Bob比特币交易信息的区块。</p> 
  <p>回忆我们之前学习的交易信息的数据结构，交易信息的数据结构包含了Alice的签名（公钥），和一个Hash指针，该指针表示上一次的交易信息。该指针必须指向一个已经达成共识的区块链中的区块。</p> 
  <p>一个诚实的结点产生了最近一次交易的区块，该区块包含了Alice向Bob的支付信息。假设下一次随机选择的区块恰好由Alice控制，现在，Alice将要向区块中写入数据。由于这次写入数据的过程是有Alice控制，那么Alice可以忽略记录了她向Bob支付比特币的区块，而是让Hash指针指向支付的前一个区块那个区块；或者更进一步说，她把支付给Bob的地址改成支付给自己的。那么，如果操作成功了，Alice支付给Bob的交易信息就会消失，Alice等于没花比特币就下载了一个付费软件。</p> 
  <p>如下图，Alice在获取支付信息后，创造了两个交易：一个是她支付给Bob比特币，另一个是她双重支付这个比特币，她把该比特币发给了自己的一个账户地址。 <br> <img src="https://img-blog.csdn.net/20180529193416540?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc2MzUx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="双重支付攻击图片" title=""></p> 
  <p>双重支付策略是否成功，取决于上面连个区块中，哪一个会最终被达成共识的区块链所接受。诚实的区块链结点采取的策略是拓展最长的有效分支。现在，我们也无法确定哪个分支会被采用，因为现在这两个区块链的长度是一样的。双重支付的成功与否取决于伪造的地址那条链是否被采用。</p> 
  <p>实际上，结点一般拓展P2P网络上第一次接收到的区块。但是，这个规则不是固定的。网络的延迟也可能造成消息接收的次序混乱。而且，如果下一次还是Alice接收到本次的区块，那么她会继续采取类似的策略，这样会直接导致双重支付的区块链更长，从而在后续的验证中，支付给Bob的区块被遗弃。</p> 
  <p>再重新考虑上述的情景，当Alice向全网广播她给Bob支付的消息时，Bob也在监听网络，并在下一个区块建立前收到了这个消息。如果Bob在接收到该广播后，立刻允许Alice下载软件，这个过程就称为“零确信交易（Zero-confirmation transaction）”。</p> 
  <p>为了保证双重支付攻击的成功执行，恶意结点的操作者必须控制了下一个区块的生成过程。。但是，向上面提到的那样，如果Bob在收到单个结点确信信息之前就让Alice下载软件，那么Alice可以立刻向网络中广播双重支付信息，那么一个诚实的结点可能会在下一个区块链中创造包含该信息，而不是向Bob支付的信息。</p> 
  <p>Bob的防范策略：Bob在接收到Alice的广播后，不会立刻让Alice下载软件，而是等待多次确认后，再允许Alice下载软件（下图），这样双重支付的概率会变得和小。但是，完全安全的策略是不存在的。</p> 
  <p><img src="https://img-blog.csdn.net/20180529202011524?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc2MzUx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" title=""> <br> 理论上，确信的次数越多，安全性就越强。</p> 
  <h2 id="奖励和工作量证明">奖励和工作量证明</h2> 
  <p>如果结点的不诚实行为会存在潜在利益，那么就很难保证结点诚实的。但是，我们无法直接去乘法不诚实的结点，因为所有的交易都是匿名的，很难去追踪具体的交易者的踪迹。让结点诚实的最佳方式是给诚实结点奖励。比特币的奖励方式有两个，一个是区块奖励，另一个是交易费。这些奖励是为了给诚实的结点的。</p> 
  <p><strong>区块奖励。</strong>创造一个区块可以在该区块中添加一个特殊的交易，该交易包含特定数目的比特币。创造区块的结点可以可以选择交易的接收地址，那么结点肯定会选择自己的地址作为接收方，那么这些比特币归该节点所有。区块奖励的理由是：如果创造区块的结点想要收集自己的奖励，那么必须要保证它创造的这个区块在最长的共识链上，只有这样，才能保证其他的结点都承认并接受这个区块。因此，如果该区块作假的话，它的创造的取款不会被承认，因此它也不会获得创造区块的奖励。</p> 
  <p><strong>交易费。</strong>区块的创造者可以让交易输出的总价值少于交易输入的总价值。创造区者可以获得输入输出的差额。</p> 
  <p>之前讲述的简化版的比特币算法存在两大缺陷：选择区块的过程随机的，而且我们必须接受这个随机的结点输出的结果；奖励机制存在问题，每个参与者都想自己创造一个区块来获取奖励，这样会使得系统不稳定。</p> 
  <p><strong>挖矿和工作量证明。</strong>上述的连个缺陷可以通过挖矿和工作量证明来弥补。我们通过结点计算资源所占比例来选择结点，而不是随机地选择。我们的目标是结点的计算能力越强大，那么结点就越有机会获得创建区块的机会。结点通过解决哈希难题来获取创建区块的权利。计算过程是：结点需要寻找一个数或者序列，把这个序列和之前的哈希值、该结点提出所有交易一起进行哈希计算；之后哈希函数会输出一个目标值。我们根据所有结点输出的不同的哈希值，选择最小的哈希值的输出作为可以创建新节点的结点。</p> 
  <h2 id="51攻击">51%攻击</h2> 
  <p>假设攻击者控制了P2P网络中的51%的结点。我们考虑一下几种可能发生的情况：</p> 
  <p>第一个，控制51%结点的攻击者是否可以窃取比特币。答案是否定的，根据加密算法的协议，攻击者没有其他诚实结点的私钥，根据加密协议，他无法得到其他诚实结点的认可。即使它们伪造了新的区块，并创立了包含伪造区块的最长的区块链也不行。</p> 
  <p>第二个，假设攻击者试图花费无效的比特币。假设上文中的Alice控制了51%的结点，并且用无效的比特币向Bob购买软件。假设Bob自己运行了一个诚实的比特币结点，那么Bob肯定会拒绝这个交易，因为Alice的交易是无效的，交易中没有签名认证。</p> 
  <p>第三个，假设攻击者试图阻止交易。假设攻击者Alice拒绝为所有包含Carlo的区块提供服务。这也是不行的，因为攻击者无法阻止其他P2P网络上的结点接收到有关消息，因为网络本身是不依靠区块链和共识协议的。因此大多数结点还是可以收到这个交易消息。</p> 
  <p>第四个，攻击者是否可以更改区块奖励。比如攻击者把区块奖励由25改成50。这相当于改变了系统规则。但是，由于攻击者无法改变其他节点上运行的比特币软件，因此这种篡改无法得到其他结点的认可，因此这也是不行的。</p> 
  <p>最后一个，攻击者是否可以在一定程度上摧毁比特币的信任机制。假设系统中有大量的双重支付攻击、有大量的结点不去扩展最长的有效区块链和有一些其他的攻击。那么，人们可能认为比特币系统不是它们可信任的去中心化的账本了。之后，比特币交易的速率会直线下降。事实上，如果有一个团体控制了系统中51%的哈希计算能力，我们也会失去对系统的信任，即使该团体不打算发动攻击。</p> 
  <h2 id="问题总结">问题总结</h2> 
  <p>再来回顾一下开始提出的5个问题： <br> 1. <strong>谁来记录所有的账本和交易：</strong>所有的信息有系统中所有的结点共同维护，所有的信息被记录在一个最长的有效区块链上。 <br> 2. <strong>谁有权利来说明交易的有效性：</strong>交易的有效性由共识机制完成，并且需要在有效的区块链上记录后，得到诚实结点认同才行。 <br> 3. <strong>谁来发行货币 ：</strong>发行比特币只有当创建新区块的时候才行， 而创建新区块需要靠结点解决哈希难题，这取决于结点的计算能力，当然，计算能力只是在概率上决定了创建新区块的可能性。 <br> 4. <strong>谁来决定系统改变的规则 ：</strong>系统规则由共识机制决定。所有结点都需要遵循共识机制。共识机制的维护，通过奖励机制决定。 <br> 5. <strong>比特币怎样获取交易价值 ：</strong>比特币本身不想一般的货币那样有面值，比如100美金等，它本质上是是一个交易信息的输出。价值在于记录了交易信息。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_35976351/article/details/80499755,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_35976351/article/details/80499755,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
