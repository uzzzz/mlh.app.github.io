<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码分析–RPC | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码分析–RPC" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&nbsp; &nbsp; 比特币源码为我们提供了一个比特币核心客户端，这个核心客户端也称为中本聪客户端，和SPV轻量级客户端相比，比特币核心客户端包含了比特币的方方面面。比特币核心客户端中包含一个服务端bitcoind和一个命令行工具bitcoin-cli，通过bitcoin-cli，用户可以在命令行进行诸如创建交易、发送交易，查看交易，查看区块等一系列的操作。bitcoin-cli和bitcoind是典型的C/S模式，bitcoind中实现了一个http服务器，bitcoin-cli则是一个http客户端，二者之间的传输数据遵循json-rpc协议。本文将结合源码对比特币json-rpc服务的实现进行分析。 1、比特币核心客户端架构 1.1 示例 &nbsp; &nbsp; 先来看看bitcoin-cli的一个使用示例。我们知道区块链的一个最大特性就是能够追根溯源，任何一笔交易在验证后最终都记录到了区块链上，之后就无法篡改，现在我们通过bitcoin-cli来查看区块链上的一笔交易，这个示例来自于《精通比特币》一书： &nbsp; &nbsp; 假设我们已经下载并且编译好了比特币客户端，并且bitcoind已经运行起来了（可以在命令行输入bitciond &amp;让其在后台运行）现在我们要查看一下交易hash为9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3的详细信息，我们在命令行输入： &nbsp; &nbsp; $ bitcoin-cli gettransaction&nbsp;9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3 &nbsp; &nbsp; 然后，在命令行就能看到服务器返回的json格式表示的交易的信息： { &quot;amount&quot; : 0.05000000, &quot;confirmations&quot; : 0, &quot;txid&quot;:&quot;9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3&quot;, &quot;time&quot; : 1392660908, &quot;timereceived&quot; : 1392660908, &quot;details&quot; : [ { &quot;account&quot; : &quot;&quot;, &quot;address&quot;:&quot;1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL&quot;, &quot;category&quot; : &quot;receive&quot;, &quot;amount&quot; : 0.05000000 } ] } &nbsp; &nbsp; 可以看到这笔交易里向比特币地址1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL转移了0.05个比特币。 &nbsp; &nbsp; 用类似的方式我们还能进行很多操作，比如创建交易，生成钱包地址，查看区块等等。而这种简单的命令背后的实现，就是本文要讲述的基于json-rpc的http服务。 1.2 架构&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bitcoin-cli通过http向bitcoind请求服务，其传输数据格式遵循json-rpc协议，整体架构如下图： &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 搞清楚bitcoin-cli和bicoind的实现原理以及二者之间的交互过程对后续区块链的学习会很有帮助，在搞明白这一部分的原理后，还可以比较容易的在各种平台上（比如android、ios、pc等等）实现自己定制的比特币钱包客户端，下文来一步一步的开始分析。 2、json-rpc介绍&nbsp; &nbsp; json-rpc是一个基于json的跨语言rpc协议，具有传输数据小，便于实现，扩展和调试等优点，目前主流的编程语言比如java，c/c++等都有json-rpc的实现框架。 2.1 请求 &nbsp; &nbsp; json-rpc的请求非常简单，其格式如下： { &quot;jsonrpc&quot; : 2.0, &quot;method&quot; : &quot;getinfo&quot;, &quot;params&quot; : [&quot;&quot;], &quot;id&quot; : 1 } &nbsp; &nbsp; jsonrpc：json-rpc的版本； &nbsp; &nbsp; method：rpc调用的方法名； &nbsp; &nbsp; params：方法传入的参数，没有参数传入nullptr； &nbsp; &nbsp; id：调用的标识符，可以为字符串，也可以为nullptr，但是不建议使用nullptr，因为容易引起混乱。 2.2 响应 { &quot;jsonrpc&quot; : 2.0, &quot;result&quot; : &quot;info&quot;, &quot;error&quot; : null, &quot;id&quot; : 1 } &nbsp; &nbsp; jsonrpc：json-rpc版本； &nbsp; &nbsp; result：rpc调用的返回值，调用成功时不能为nullptr，调用失败必须为nullptr； &nbsp; &nbsp; error：调用错误时用，无错误为nullptr，有错误时返回错误对象，参见下一节； &nbsp; &nbsp; id：调用标识符，与调用方传入的保持一致。 2.3 错误对象 { &quot;code&quot; : 1, &quot;message&quot; : &quot;some error.&quot;, &quot;data&quot;:null } &nbsp; &nbsp; code：错误码； &nbsp; &nbsp; message：错误信息； &nbsp; &nbsp; data：附加信息，可以为nullptr。 &nbsp; &nbsp; 错误码见下表： 错误码 错误 含义 -32700 解析错误 服务器收到无效json，或者解析json出错 -32600 无效的请求 发送的json不是一个有效的请求 -32601 方法未找到 方法不存在或不可见 -36602 无效的参数 无效的方法参数 -36603 内部错误 json-rpc的内部错误 -32000到-32099 服务器端错误 保留给具体服务器实现的服务端错误 &nbsp; &nbsp; 比特币核心实现了一个基于libevent的http服务器，下文会对这个服务器的实现进行介绍。 3、libevent库 3.1 介绍 &nbsp; &nbsp; libevent是一个轻量级、跨平台、基于事件的高性能网络库。它封装了不同平台的io复用技术，对外暴露一致的接口。通常在编写服务器程序时所面临的一个最大问题就是高并发，libevent是解决大量并发请求的一个较好的解决方案。 &nbsp; &nbsp; 常见的处理大量并发请求的方法： &nbsp; &nbsp; (1) IO复用技术 &nbsp; &nbsp; 通过select，poll或epoll等系统api，实现io复用。 &nbsp; &nbsp; (2) 多线程或多进程 &nbsp; &nbsp; 多线程和多进程也可以解决大量并发请求的问题，但是无论多进程还是多线程，都存在问题：多进程不适合短连接，进程的创建和销毁开销比较大；多线程不适合短连接，大量的线程会导致较大的内存开销。 &nbsp; &nbsp; (3) 多线程结合IO复用 &nbsp; &nbsp; 将IO复用和多线程结合起来，这是目前解决大并发的常用方案。最常见的套路就是主线程里监听某个端口以及接受的描述符，当有读写事件产生时，将事件交给工作线程去处理。 &nbsp; &nbsp; libevent封装了select，poll，epoll等io复用技术，同时采用时间驱动的机制：应用向libevent注册事件和相应的回调，当事件发生时libevent调用这些回调，libevent支持三种事件：网络IO，定时器和信号。 3.2 api &nbsp; &nbsp; 关于libevent的实现原理本文不详细展开，有兴趣的同学可以在github自行下载源代码学习。这里只简单介绍几个核心的api。 &nbsp; &nbsp; (1) struct event_base * event_base_new() &nbsp; &nbsp; 创建一个事件集，事件必须加入到事件集里才能接收到回调。 &nbsp; &nbsp; (2) struct event event_new(struct event_base *, evutil_socket_t, short, event_callback_fn, void*) &nbsp; &nbsp; 创建一个事件，其参数如下： &nbsp; &nbsp; event_base：事件所在的事件集； &nbsp; &nbsp; evutil_socket_t：socket描述符； &nbsp; &nbsp; short：事件类型，EV_READ表示等待读事件，EV_WRITE表示写事件，EV_SIGNAL表示要等待的信号； &nbsp; &nbsp; event_callback_fn：事件发生时的回调函数； &nbsp; &nbsp; void* 回调函数的参数 &nbsp; &nbsp; (3) int event_add(struct event *, struct timeval *)&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 添加事件。 &nbsp; &nbsp; event：要添加的时间 &nbsp; &nbsp; timeval：等待事件的超时值，如果为nullptr将是无限等待。 &nbsp; &nbsp; (4) int event_del(struct event *) &nbsp; &nbsp; 删除事件。 &nbsp; &nbsp; (5) struct bufferevent *bufferevent_socket_new(struct event_base *, evutil_socket_t, int options) &nbsp; &nbsp; 创建一个bufferevent，bufferevent封装了read，write等读写函数。 &nbsp; &nbsp; event_base：bufferevent事件所在的事件集； &nbsp; &nbsp; evutil_socket_t：相关的套接字描述符； &nbsp; &nbsp; options：选项。 &nbsp; &nbsp; (6) int bufferevent_enable(struct bufferevent *, short event) &nbsp; &nbsp; 启用bufferevent。 &nbsp; &nbsp; (7) size_t bufferevent_read(struct bufferevent *, void *data, size_t size) &nbsp; &nbsp; 读取bufferevent，返回读取的字节数。 &nbsp; &nbsp; (8) size_t bufferevent_write(struct bufferevent *, const void *data, size_t size) &nbsp; &nbsp; 写入bufferevent。 3.3 libevent示例 &nbsp; &nbsp; 这里用一个简单的示例来看看用libevent如何开发一个简单的服务器。 &nbsp; &nbsp; (1) 首先创建套接字并在指定的端口上监听 int sock_fd = ::socket(AF_INET, SOCK_STREAM, 0); if( sock_fd == -1 ) return -1; &nbsp;&nbsp;&nbsp;&nbsp;evutil_make_listen_socket_reuseable(sock_fd); struct sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_addr.s_addr = 0; sin.sin_port = htons(port); if( ::bind(sock_fd, (SA*)&amp;sin, sizeof(sin)) &lt; 0 ) goto error; if( ::listen(sock_fd, listen_num) &lt; 0) goto error; &nbsp;&nbsp;evutil_make_socket_nonblocking(listener); &nbsp; &nbsp; (2) 创建一个监听客户连接请求的事件： struct event* ev_listen = event_new(base, sock_fd, EV_READ | EV_PERSIST, accept_cb, base); event_add(ev_listen, NULL); event_base_dispatch(base); &nbsp; &nbsp; 当监听套接字有新连接时，事件将被触发，从而执行回调accept_cb： &nbsp; void accept_cb(int fd, short events, void* arg) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;evutil_socket_t sockfd; &nbsp;&nbsp;&nbsp;&nbsp;struct sockaddr_in client; &nbsp;&nbsp;&nbsp;&nbsp;socklen_t len = sizeof(client); &nbsp;&nbsp;&nbsp;&nbsp;sockfd = ::accept(fd, (struct sockaddr*)&amp;client, &amp;len ); &nbsp;&nbsp;&nbsp;&nbsp;evutil_make_socket_nonblocking(sockfd); &nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;accept a client %d\n&quot;, sockfd); &nbsp;&nbsp;&nbsp;&nbsp;struct event_base* base = (event_base*)arg; &nbsp;&nbsp;&nbsp;&nbsp;bufferevent* bev = bufferevent_socket_new(base, sockfd, BEV_OPT_CLOSE_ON_FREE); &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_setcb(bev, socket_read_cb, NULL, event_cb, arg); &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_enable(bev, EV_READ | EV_PERSIST); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 创建一个bufferevent事件，将accept以后的已连接套接字与之关联，这样当套接字上有数据到来时，就会触发bufferevent事件，从而执行socket_read_cb回调： &nbsp;&nbsp;&nbsp;&nbsp;void socket_read_cb(bufferevent* bev, void* arg) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;char msg[4096]; &nbsp;&nbsp;&nbsp;&nbsp;size_t len = bufferevent_read(bev, msg, sizeof(msg)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg[len] = &#39;\0&#39;; &nbsp;&nbsp;&nbsp;&nbsp;char reply_msg[4096] = &quot;recvieced msg:&quot;; &nbsp;&nbsp;&nbsp;&nbsp;strcat(reply_msg + strlen(reply_msg), msg); &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_write(bev, reply_msg, strlen(reply_msg)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 然后就能从bufferevent中读取到客户数据。 3.4 用libevent实现http服务器 &nbsp; &nbsp; libevent提供了http的支持，用libevent很容易实现自己的http服务，步骤如下： &nbsp; &nbsp; (1) 创建事件集和evhttp事件： struct event_base *event_base_new(void); struct evhttp *evhttp_new(struct event_base *base); &nbsp; &nbsp; (2) 绑定地址和端口 int evhttp_bind_socket(struct evhttp *http, const char *address, ev_uint16_t port); &nbsp; &nbsp; (3) 设置回调来处理http请求 void evhttp_set_gencb(struct evhttp *http, void (*cb)(struct evhttp_request *, void *), void *arg); &nbsp; &nbsp; (4) 进入事件循环 int event_base_dispatch(struct event_base *); &nbsp; &nbsp; 在下一节我们结合比特币的源码，来看看比特币中是如使用上面这些api实现http服务的，当然比特币的http服务封装的更为复杂一些。 4、比特币JSONRPC服务器的实现 4.1、JSONRPC服务器框架 &nbsp; &nbsp; 比特币使用libevent实现了一个基于工作队列的http服务器，通过采用工作队列的方式可以提高服务器的并发处理能力。该服务器框架如下： &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 逻辑其实非常简单，在http事件循环中等待http请求的到来，当收到http请求以后，从请求数据中解析出数据并封装到HttpWorkItem，放入到工作队列里，工作队列运行起来以后会开启工作线程检查工作队列，如果队列里有数据就从对头取出并执行相应的动作。 4.2、JSONRPC服务器初始化 4.2.1 注册RPC命令及处理器 &nbsp; &nbsp; JSONRPC服务器的初始化也是在bitcoind的初始化步骤中。在init.cpp的AppInitMain函数里： &nbsp;&nbsp;&nbsp;&nbsp;/* Register RPC commands regardless of -server setting so they will be * available in the GUI RPC console even if external calls are disabled. */ RegisterAllCoreRPCCommands(tableRPC); g_wallet_init_interface.RegisterRPC(tableRPC); /* Start the RPC server already. It will be started in &quot;warmup&quot; mode * and not really process calls already (but it will signify connections * that the server is there and will be ready later). Warmup mode will * be disabled when initialisation is finished. */ if (gArgs.GetBoolArg(&quot;-server&quot;, false)) { uiInterface.InitMessage.connect(SetRPCWarmupStatus); if (!AppInitServers()) return InitError(_(&quot;Unable to start HTTP server. See debug log for details.&quot;)); } &nbsp; &nbsp; 首先调用RegisterAllCoreRPCCommands注册比特币核心客户端所支持的所有RPC指令： &nbsp;&nbsp;&nbsp;&nbsp;static inline void RegisterAllCoreRPCCommands(CRPCTable &amp;t) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;RegisterBlockchainRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterNetRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterMiscRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterMiningRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterRawTransactionRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 这里可以看到对RPC命令进行了分类，操作区块链的、网络相关的、挖矿相关的以及比特币交易相关的RPC命令一应俱全。这里不妨列出来，这样读者对通过客户端能做些什么事情有个大概印象： &nbsp; &nbsp; (1) 区块链相关的rpc，位于blockchain.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;blockchain&quot;, &quot;getblockchaininfo&quot;, &amp;getblockchaininfo, {} }, { &quot;blockchain&quot;, &quot;getchaintxstats&quot;, &amp;getchaintxstats, {&quot;nblocks&quot;, &quot;blockhash&quot;} }, { &quot;blockchain&quot;, &quot;getblockstats&quot;, &amp;getblockstats, {&quot;hash_or_height&quot;, &quot;stats&quot;} }, { &quot;blockchain&quot;, &quot;getbestblockhash&quot;, &amp;getbestblockhash, {} }, { &quot;blockchain&quot;, &quot;getblockcount&quot;, &amp;getblockcount, {} }, { &quot;blockchain&quot;, &quot;getblock&quot;, &amp;getblock, {&quot;blockhash&quot;,&quot;verbosity|verbose&quot;} }, { &quot;blockchain&quot;, &quot;getblockhash&quot;, &amp;getblockhash, {&quot;height&quot;} }, { &quot;blockchain&quot;, &quot;getblockheader&quot;, &amp;getblockheader, {&quot;blockhash&quot;,&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;getchaintips&quot;, &amp;getchaintips, {} }, { &quot;blockchain&quot;, &quot;getdifficulty&quot;, &amp;getdifficulty, {} }, { &quot;blockchain&quot;, &quot;getmempoolancestors&quot;, &amp;getmempoolancestors, {&quot;txid&quot;,&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;getmempooldescendants&quot;, &amp;getmempooldescendants, {&quot;txid&quot;,&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;getmempoolentry&quot;, &amp;getmempoolentry, {&quot;txid&quot;} }, { &quot;blockchain&quot;, &quot;getmempoolinfo&quot;, &amp;getmempoolinfo, {} }, { &quot;blockchain&quot;, &quot;getrawmempool&quot;, &amp;getrawmempool, {&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;gettxout&quot;, &amp;gettxout, {&quot;txid&quot;,&quot;n&quot;,&quot;include_mempool&quot;} }, { &quot;blockchain&quot;, &quot;gettxoutsetinfo&quot;, &amp;gettxoutsetinfo, {} }, { &quot;blockchain&quot;, &quot;pruneblockchain&quot;, &amp;pruneblockchain, {&quot;height&quot;} }, { &quot;blockchain&quot;, &quot;savemempool&quot;, &amp;savemempool, {} }, { &quot;blockchain&quot;, &quot;verifychain&quot;, &amp;verifychain, {&quot;checklevel&quot;,&quot;nblocks&quot;} }, { &quot;blockchain&quot;, &quot;preciousblock&quot;, &amp;preciousblock, {&quot;blockhash&quot;} }, /* Not shown in help */ { &quot;hidden&quot;, &quot;invalidateblock&quot;, &amp;invalidateblock, {&quot;blockhash&quot;} }, { &quot;hidden&quot;, &quot;reconsiderblock&quot;, &amp;reconsiderblock, {&quot;blockhash&quot;} }, { &quot;hidden&quot;, &quot;waitfornewblock&quot;, &amp;waitfornewblock, {&quot;timeout&quot;} }, { &quot;hidden&quot;, &quot;waitforblock&quot;, &amp;waitforblock, {&quot;blockhash&quot;,&quot;timeout&quot;} }, { &quot;hidden&quot;, &quot;waitforblockheight&quot;, &amp;waitforblockheight, {&quot;height&quot;,&quot;timeout&quot;} }, { &quot;hidden&quot;, &quot;syncwithvalidationinterfacequeue&quot;, &amp;syncwithvalidationinterfacequeue, {} }, }; &nbsp; &nbsp; 所有的RPC命令以及对应的回调函数指针都封装在了CRPCCommand中，按分类、rpc方法名，回调函数，参数名封装。基本上通过方法名就能猜出其作用。 &nbsp; &nbsp; (2) 网络相关的rpc，位于net.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;network&quot;, &quot;getconnectioncount&quot;, &amp;getconnectioncount, {} }, { &quot;network&quot;, &quot;ping&quot;, &amp;ping, {} }, { &quot;network&quot;, &quot;getpeerinfo&quot;, &amp;getpeerinfo, {} }, { &quot;network&quot;, &quot;addnode&quot;, &amp;addnode, {&quot;node&quot;,&quot;command&quot;} }, { &quot;network&quot;, &quot;disconnectnode&quot;, &amp;disconnectnode, {&quot;address&quot;, &quot;nodeid&quot;} }, { &quot;network&quot;, &quot;getaddednodeinfo&quot;, &amp;getaddednodeinfo, {&quot;node&quot;} }, { &quot;network&quot;, &quot;getnettotals&quot;, &amp;getnettotals, {} }, { &quot;network&quot;, &quot;getnetworkinfo&quot;, &amp;getnetworkinfo, {} }, { &quot;network&quot;, &quot;setban&quot;, &amp;setban, {&quot;subnet&quot;, &quot;command&quot;, &quot;bantime&quot;, &quot;absolute&quot;} }, { &quot;network&quot;, &quot;listbanned&quot;, &amp;listbanned, {} }, { &quot;network&quot;, &quot;clearbanned&quot;, &amp;clearbanned, {} }, { &quot;network&quot;, &quot;setnetworkactive&quot;, &amp;setnetworkactive, {&quot;state&quot;} }, &nbsp; &nbsp; (3) 挖矿相关的rpc，位于mining.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;mining&quot;, &quot;getnetworkhashps&quot;, &amp;getnetworkhashps, {&quot;nblocks&quot;,&quot;height&quot;} }, { &quot;mining&quot;, &quot;getmininginfo&quot;, &amp;getmininginfo, {} }, { &quot;mining&quot;, &quot;prioritisetransaction&quot;, &amp;prioritisetransaction, {&quot;txid&quot;,&quot;dummy&quot;,&quot;fee_delta&quot;} }, { &quot;mining&quot;, &quot;getblocktemplate&quot;, &amp;getblocktemplate, {&quot;template_request&quot;} }, { &quot;mining&quot;, &quot;submitblock&quot;, &amp;submitblock, {&quot;hexdata&quot;,&quot;dummy&quot;} }, { &quot;generating&quot;, &quot;generatetoaddress&quot;, &amp;generatetoaddress, {&quot;nblocks&quot;,&quot;address&quot;,&quot;maxtries&quot;} }, { &quot;hidden&quot;, &quot;estimatefee&quot;, &amp;estimatefee, {} }, { &quot;util&quot;, &quot;estimatesmartfee&quot;, &amp;estimatesmartfee, {&quot;conf_target&quot;, &quot;estimate_mode&quot;} }, { &quot;hidden&quot;, &quot;estimaterawfee&quot;, &amp;estimaterawfee, {&quot;conf_target&quot;, &quot;threshold&quot;} }, }; &nbsp; &nbsp; (4) 比特币交易相关rpc，位于rawtransaction.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;rawtransactions&quot;, &quot;getrawtransaction&quot;, &amp;getrawtransaction, {&quot;txid&quot;,&quot;verbose&quot;,&quot;blockhash&quot;} }, { &quot;rawtransactions&quot;, &quot;createrawtransaction&quot;, &amp;createrawtransaction, {&quot;inputs&quot;,&quot;outputs&quot;,&quot;locktime&quot;,&quot;replaceable&quot;} }, { &quot;rawtransactions&quot;, &quot;decoderawtransaction&quot;, &amp;decoderawtransaction, {&quot;hexstring&quot;,&quot;iswitness&quot;} }, { &quot;rawtransactions&quot;, &quot;decodescript&quot;, &amp;decodescript, {&quot;hexstring&quot;} }, { &quot;rawtransactions&quot;, &quot;sendrawtransaction&quot;, &amp;sendrawtransaction, {&quot;hexstring&quot;,&quot;allowhighfees&quot;} }, { &quot;rawtransactions&quot;, &quot;combinerawtransaction&quot;, &amp;combinerawtransaction, {&quot;txs&quot;} }, { &quot;rawtransactions&quot;, &quot;signrawtransaction&quot;, &amp;signrawtransaction, {&quot;hexstring&quot;,&quot;prevtxs&quot;,&quot;privkeys&quot;,&quot;sighashtype&quot;} }, /* uses wallet if enabled */ { &quot;rawtransactions&quot;, &quot;signrawtransactionwithkey&quot;, &amp;signrawtransactionwithkey, {&quot;hexstring&quot;,&quot;privkeys&quot;,&quot;prevtxs&quot;,&quot;sighashtype&quot;} }, { &quot;rawtransactions&quot;, &quot;testmempoolaccept&quot;, &amp;testmempoolaccept, {&quot;rawtxs&quot;,&quot;allowhighfees&quot;} }, { &quot;blockchain&quot;, &quot;gettxoutproof&quot;, &amp;gettxoutproof, {&quot;txids&quot;, &quot;blockhash&quot;} }, { &quot;blockchain&quot;, &quot;verifytxoutproof&quot;, &amp;verifytxoutproof, {&quot;proof&quot;} }, }; &nbsp; &nbsp; 当注册完以后，如果用户启用了-server选项，将会调用AppInitServers创建Http服务器。 4.2.2 创建http服务器 &nbsp; &nbsp; AppInitServers实现如下： static bool AppInitServers() { RPCServer::OnStarted(&amp;OnRPCStarted); RPCServer::OnStopped(&amp;OnRPCStopped); if (!InitHTTPServer()) return false; if (!StartRPC()) return false; if (!StartHTTPRPC()) return false; if (gArgs.GetBoolArg(&quot;-rest&quot;, DEFAULT_REST_ENABLE) &amp;&amp; !StartREST()) return false; if (!StartHTTPServer()) return false; return true; } &nbsp; &nbsp; 这里按步骤一步一步的来。首先是调用InitHTTPServer，使用libevent api来建立http服务器，这里截取主要代码来看看，位于httpserver.cpp文件： &nbsp;&nbsp;&nbsp;&nbsp;raii_event_base base_ctr = obtain_event_base(); /* Create a new evhttp object to handle requests. */ raii_evhttp http_ctr = obtain_evhttp(base_ctr.get()); struct evhttp* http = http_ctr.get(); if (!http) { LogPrintf(&quot;couldn&#39;t create evhttp. Exiting.\n&quot;); return false; } evhttp_set_timeout(http, gArgs.GetArg(&quot;-rpcservertimeout&quot;, DEFAULT_HTTP_SERVER_TIMEOUT)); evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE); evhttp_set_max_body_size(http, MAX_SIZE); evhttp_set_gencb(http, http_request_cb, nullptr); if (!HTTPBindAddresses(http)) { LogPrintf(&quot;Unable to bind any endpoint for RPC server\n&quot;); return false; } LogPrint(BCLog::HTTP, &quot;Initialized HTTP server\n&quot;); int workQueueDepth = std::max((long)gArgs.GetArg(&quot;-rpcworkqueue&quot;, DEFAULT_HTTP_WORKQUEUE), 1L); LogPrintf(&quot;HTTP: creating work queue of depth %d\n&quot;, workQueueDepth); workQueue = new WorkQueue&lt;HTTPClosure&gt;(workQueueDepth); // transfer ownership to eventBase/HTTP via .release() eventBase = base_ctr.release(); eventHTTP = http_ctr.release(); &nbsp; &nbsp; 这里的套路和3.4节中用libevent建立http服务器的步骤基本一样，注意两点： &nbsp; &nbsp; (1) 用evhttp_set_gencb设置了http请求的处理函数：http_request_cb; &nbsp; &nbsp; (2) 创建了一个工作队列，队列里的元素类型HTTPClosure，这是一个函数对象接口类，重写了函数调用操作符，HttpWorkItem实现了此接口。 4.2.3 http请求的处理 &nbsp; &nbsp; 我们来看看当bitcoind收到一个http请求以后是如何处理的，就是http_request_cb回调，主要代码如下： &nbsp;&nbsp;&nbsp;&nbsp;// Find registered handler for prefix std::string strURI = hreq-&gt;GetURI(); std::string path; std::vector&lt;HTTPPathHandler&gt;::const_iterator i = pathHandlers.begin(); std::vector&lt;HTTPPathHandler&gt;::const_iterator iend = pathHandlers.end(); for (; i != iend; ++i) { bool match = false; if (i-&gt;exactMatch) match = (strURI == i-&gt;prefix); else match = (strURI.substr(0, i-&gt;prefix.size()) == i-&gt;prefix); if (match) { path = strURI.substr(i-&gt;prefix.size()); break; } } // Dispatch to worker thread if (i != iend) { std::unique_ptr&lt;HTTPWorkItem&gt; item(new HTTPWorkItem(std::move(hreq), path, i-&gt;handler)); assert(workQueue); if (workQueue-&gt;Enqueue(item.get())) item.release(); /* if true, queue took ownership */ else { LogPrintf(&quot;WARNING: request rejected because http work queue depth exceeded, it can be increased with the -rpcworkqueue= setting\n&quot;); item-&gt;req-&gt;WriteReply(HTTP_INTERNAL, &quot;Work queue depth exceeded&quot;); } } else { hreq-&gt;WriteReply(HTTP_NOTFOUND); } &nbsp; &nbsp; 用一句话来概括这个函数的作用就是：将请求的url的path部分与注册过的前缀进行匹配，并生成HttpWorkItem放入到工作队列中。目前注册了两个前缀：/和/wallet/，代码在StartHttpRPC中： bool StartHTTPRPC() { LogPrint(BCLog::RPC, &quot;Starting HTTP RPC server\n&quot;); if (!InitRPCAuthentication()) return false; RegisterHTTPHandler(&quot;/&quot;, true, HTTPReq_JSONRPC); #ifdef ENABLE_WALLET // ifdef can be removed once we switch to better endpoint support and API versioning RegisterHTTPHandler(&quot;/wallet/&quot;, false, HTTPReq_JSONRPC); #endif assert(EventBase()); httpRPCTimerInterface = MakeUnique&lt;HTTPRPCTimerInterface&gt;(EventBase()); RPCSetTimerInterface(httpRPCTimerInterface.get()); return true; } &nbsp; &nbsp; 两个前缀/和/wallet/对应的回调处理函数均为HttpReq_JSONRPC。 &nbsp; &nbsp; 之后调用StartHttpServer让工作队列运行起来： bool StartHTTPServer() { LogPrint(BCLog::HTTP, &quot;Starting HTTP server\n&quot;); int rpcThreads = std::max((long)gArgs.GetArg(&quot;-rpcthreads&quot;, DEFAULT_HTTP_THREADS), 1L); LogPrintf(&quot;HTTP: starting %d worker threads\n&quot;, rpcThreads); std::packaged_task&lt;bool(event_base*, evhttp*)&gt; task(ThreadHTTP); threadResult = task.get_future(); threadHTTP = std::thread(std::move(task), eventBase, eventHTTP); for (int i = 0; i &lt; rpcThreads; i++) { g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue); } return true; } &nbsp; &nbsp; 最终会调用到工作队列的run方法： void Run() { while (true) { std::unique_ptr&lt;WorkItem&gt; i; { std::unique_lock&lt;std::mutex&gt; lock(cs); while (running &amp;&amp; queue.empty()) cond.wait(lock); if (!running) break; i = std::move(queue.front()); queue.pop_front(); } (*i)(); } } &nbsp; &nbsp; 很简单，工作队列为空的时候线程阻塞等待，当收到http请求以后，解析请求并添加HttpWorkItem到队列中并唤醒线程，线程从队列头部取出一个item运行。最终将执行HttpReq_JSONRPC这个回调，这里会将JSONRPC中的rpc方法分发到服务端不同的方法中，来看看其处理： &nbsp; &nbsp; (1) 请求合法性检查及认证 &nbsp; &nbsp; 首先检查请求是否合法，http头部中的auchoization是否合法： static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &amp;) { // JSONRPC handles only POST if (req-&gt;GetRequestMethod() != HTTPRequest::POST) { req-&gt;WriteReply(HTTP_BAD_METHOD, &quot;JSONRPC server handles only POST requests&quot;); return false; } // Check authorization std::pair&lt;bool, std::string&gt; authHeader = req-&gt;GetHeader(&quot;authorization&quot;); if (!authHeader.first) { req-&gt;WriteHeader(&quot;WWW-Authenticate&quot;, WWW_AUTH_HEADER_DATA); req-&gt;WriteReply(HTTP_UNAUTHORIZED); return false; } JSONRPCRequest jreq; jreq.peerAddr = req-&gt;GetPeer().ToString(); if (!RPCAuthorized(authHeader.second, jreq.authUser)) { LogPrintf(&quot;ThreadRPCServer incorrect password attempt from %s\n&quot;, jreq.peerAddr); /* Deter brute-forcing If this results in a DoS the user really shouldn&#39;t have their RPC port exposed. */ MilliSleep(250); req-&gt;WriteHeader(&quot;WWW-Authenticate&quot;, WWW_AUTH_HEADER_DATA); req-&gt;WriteReply(HTTP_UNAUTHORIZED); return false; } &nbsp; &nbsp; 可以看到，比特币的json rpc服务只支持POST。 &nbsp; &nbsp; (2) 读取http请求数据，将rpc请求分发到不同的函数 &nbsp;&nbsp;&nbsp;&nbsp;try { // Parse request UniValue valRequest; if (!valRequest.read(req-&gt;ReadBody())) throw JSONRPCError(RPC_PARSE_ERROR, &quot;Parse error&quot;); // Set the URI jreq.URI = req-&gt;GetURI(); std::string strReply; // singleton request if (valRequest.isObject()) { jreq.parse(valRequest); UniValue result = tableRPC.execute(jreq); // Send reply strReply = JSONRPCReply(result, NullUniValue, jreq.id); // array of requests } else if (valRequest.isArray()) strReply = JSONRPCExecBatch(jreq, valRequest.get_array()); else throw JSONRPCError(RPC_PARSE_ERROR, &quot;Top-level object parse error&quot;); req-&gt;WriteHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); req-&gt;WriteReply(HTTP_OK, strReply); &nbsp; &nbsp; 如果收到的是单个json，则tableRPC.execute执行，否则如果收到的是以数组形式的批量rpc请求，则批量执行，批量执行最终也是走tableRPC.execute()来分发，execute()执行后的结果将写入到http响应包中： UniValue CRPCTable::execute(const JSONRPCRequest &amp;request) const { // Return immediately if in warmup { LOCK(cs_rpcWarmup); if (fRPCInWarmup) throw JSONRPCError(RPC_IN_WARMUP, rpcWarmupStatus); } // Find method const CRPCCommand *pcmd = tableRPC[request.strMethod]; if (!pcmd) throw JSONRPCError(RPC_METHOD_NOT_FOUND, &quot;Method not found&quot;); g_rpcSignals.PreCommand(*pcmd); try { // Execute, convert arguments to array if necessary if (request.params.isObject()) { return pcmd-&gt;actor(transformNamedArguments(request, pcmd-&gt;argNames)); } else { return pcmd-&gt;actor(request); } } catch (const std::exception&amp; e) { throw JSONRPCError(RPC_MISC_ERROR, e.what()); } } &nbsp; &nbsp; 代码也比较容易理解，就是从根据json-rpc协议，从请求中读取method，然后根据method找到对应的CRPCCommand执行体，这些执行体就是4.2.1节中提到那几张分门别类的映射表。 &nbsp; &nbsp; 至此，比特币的json-rpc服务端的脉络我们就梳理的差不多了，整体框架并不难理解，只是封装的略微复杂一点点。 5、小结 &nbsp; &nbsp; 本文对json-rpc协议，libevent进行了简要描述，并结合源码分析了比特币的JSONRPC服务的实现。比特币核心客户端的bitcon-cli只是一个示例性质的命令行工具，如果想自己撸一个特定平台上的带有GUI的比特币钱包客户端，看完本文后相信将能信手拈来。 阅读更多" />
<meta property="og:description" content="&nbsp; &nbsp; 比特币源码为我们提供了一个比特币核心客户端，这个核心客户端也称为中本聪客户端，和SPV轻量级客户端相比，比特币核心客户端包含了比特币的方方面面。比特币核心客户端中包含一个服务端bitcoind和一个命令行工具bitcoin-cli，通过bitcoin-cli，用户可以在命令行进行诸如创建交易、发送交易，查看交易，查看区块等一系列的操作。bitcoin-cli和bitcoind是典型的C/S模式，bitcoind中实现了一个http服务器，bitcoin-cli则是一个http客户端，二者之间的传输数据遵循json-rpc协议。本文将结合源码对比特币json-rpc服务的实现进行分析。 1、比特币核心客户端架构 1.1 示例 &nbsp; &nbsp; 先来看看bitcoin-cli的一个使用示例。我们知道区块链的一个最大特性就是能够追根溯源，任何一笔交易在验证后最终都记录到了区块链上，之后就无法篡改，现在我们通过bitcoin-cli来查看区块链上的一笔交易，这个示例来自于《精通比特币》一书： &nbsp; &nbsp; 假设我们已经下载并且编译好了比特币客户端，并且bitcoind已经运行起来了（可以在命令行输入bitciond &amp;让其在后台运行）现在我们要查看一下交易hash为9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3的详细信息，我们在命令行输入： &nbsp; &nbsp; $ bitcoin-cli gettransaction&nbsp;9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3 &nbsp; &nbsp; 然后，在命令行就能看到服务器返回的json格式表示的交易的信息： { &quot;amount&quot; : 0.05000000, &quot;confirmations&quot; : 0, &quot;txid&quot;:&quot;9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3&quot;, &quot;time&quot; : 1392660908, &quot;timereceived&quot; : 1392660908, &quot;details&quot; : [ { &quot;account&quot; : &quot;&quot;, &quot;address&quot;:&quot;1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL&quot;, &quot;category&quot; : &quot;receive&quot;, &quot;amount&quot; : 0.05000000 } ] } &nbsp; &nbsp; 可以看到这笔交易里向比特币地址1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL转移了0.05个比特币。 &nbsp; &nbsp; 用类似的方式我们还能进行很多操作，比如创建交易，生成钱包地址，查看区块等等。而这种简单的命令背后的实现，就是本文要讲述的基于json-rpc的http服务。 1.2 架构&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bitcoin-cli通过http向bitcoind请求服务，其传输数据格式遵循json-rpc协议，整体架构如下图： &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 搞清楚bitcoin-cli和bicoind的实现原理以及二者之间的交互过程对后续区块链的学习会很有帮助，在搞明白这一部分的原理后，还可以比较容易的在各种平台上（比如android、ios、pc等等）实现自己定制的比特币钱包客户端，下文来一步一步的开始分析。 2、json-rpc介绍&nbsp; &nbsp; json-rpc是一个基于json的跨语言rpc协议，具有传输数据小，便于实现，扩展和调试等优点，目前主流的编程语言比如java，c/c++等都有json-rpc的实现框架。 2.1 请求 &nbsp; &nbsp; json-rpc的请求非常简单，其格式如下： { &quot;jsonrpc&quot; : 2.0, &quot;method&quot; : &quot;getinfo&quot;, &quot;params&quot; : [&quot;&quot;], &quot;id&quot; : 1 } &nbsp; &nbsp; jsonrpc：json-rpc的版本； &nbsp; &nbsp; method：rpc调用的方法名； &nbsp; &nbsp; params：方法传入的参数，没有参数传入nullptr； &nbsp; &nbsp; id：调用的标识符，可以为字符串，也可以为nullptr，但是不建议使用nullptr，因为容易引起混乱。 2.2 响应 { &quot;jsonrpc&quot; : 2.0, &quot;result&quot; : &quot;info&quot;, &quot;error&quot; : null, &quot;id&quot; : 1 } &nbsp; &nbsp; jsonrpc：json-rpc版本； &nbsp; &nbsp; result：rpc调用的返回值，调用成功时不能为nullptr，调用失败必须为nullptr； &nbsp; &nbsp; error：调用错误时用，无错误为nullptr，有错误时返回错误对象，参见下一节； &nbsp; &nbsp; id：调用标识符，与调用方传入的保持一致。 2.3 错误对象 { &quot;code&quot; : 1, &quot;message&quot; : &quot;some error.&quot;, &quot;data&quot;:null } &nbsp; &nbsp; code：错误码； &nbsp; &nbsp; message：错误信息； &nbsp; &nbsp; data：附加信息，可以为nullptr。 &nbsp; &nbsp; 错误码见下表： 错误码 错误 含义 -32700 解析错误 服务器收到无效json，或者解析json出错 -32600 无效的请求 发送的json不是一个有效的请求 -32601 方法未找到 方法不存在或不可见 -36602 无效的参数 无效的方法参数 -36603 内部错误 json-rpc的内部错误 -32000到-32099 服务器端错误 保留给具体服务器实现的服务端错误 &nbsp; &nbsp; 比特币核心实现了一个基于libevent的http服务器，下文会对这个服务器的实现进行介绍。 3、libevent库 3.1 介绍 &nbsp; &nbsp; libevent是一个轻量级、跨平台、基于事件的高性能网络库。它封装了不同平台的io复用技术，对外暴露一致的接口。通常在编写服务器程序时所面临的一个最大问题就是高并发，libevent是解决大量并发请求的一个较好的解决方案。 &nbsp; &nbsp; 常见的处理大量并发请求的方法： &nbsp; &nbsp; (1) IO复用技术 &nbsp; &nbsp; 通过select，poll或epoll等系统api，实现io复用。 &nbsp; &nbsp; (2) 多线程或多进程 &nbsp; &nbsp; 多线程和多进程也可以解决大量并发请求的问题，但是无论多进程还是多线程，都存在问题：多进程不适合短连接，进程的创建和销毁开销比较大；多线程不适合短连接，大量的线程会导致较大的内存开销。 &nbsp; &nbsp; (3) 多线程结合IO复用 &nbsp; &nbsp; 将IO复用和多线程结合起来，这是目前解决大并发的常用方案。最常见的套路就是主线程里监听某个端口以及接受的描述符，当有读写事件产生时，将事件交给工作线程去处理。 &nbsp; &nbsp; libevent封装了select，poll，epoll等io复用技术，同时采用时间驱动的机制：应用向libevent注册事件和相应的回调，当事件发生时libevent调用这些回调，libevent支持三种事件：网络IO，定时器和信号。 3.2 api &nbsp; &nbsp; 关于libevent的实现原理本文不详细展开，有兴趣的同学可以在github自行下载源代码学习。这里只简单介绍几个核心的api。 &nbsp; &nbsp; (1) struct event_base * event_base_new() &nbsp; &nbsp; 创建一个事件集，事件必须加入到事件集里才能接收到回调。 &nbsp; &nbsp; (2) struct event event_new(struct event_base *, evutil_socket_t, short, event_callback_fn, void*) &nbsp; &nbsp; 创建一个事件，其参数如下： &nbsp; &nbsp; event_base：事件所在的事件集； &nbsp; &nbsp; evutil_socket_t：socket描述符； &nbsp; &nbsp; short：事件类型，EV_READ表示等待读事件，EV_WRITE表示写事件，EV_SIGNAL表示要等待的信号； &nbsp; &nbsp; event_callback_fn：事件发生时的回调函数； &nbsp; &nbsp; void* 回调函数的参数 &nbsp; &nbsp; (3) int event_add(struct event *, struct timeval *)&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 添加事件。 &nbsp; &nbsp; event：要添加的时间 &nbsp; &nbsp; timeval：等待事件的超时值，如果为nullptr将是无限等待。 &nbsp; &nbsp; (4) int event_del(struct event *) &nbsp; &nbsp; 删除事件。 &nbsp; &nbsp; (5) struct bufferevent *bufferevent_socket_new(struct event_base *, evutil_socket_t, int options) &nbsp; &nbsp; 创建一个bufferevent，bufferevent封装了read，write等读写函数。 &nbsp; &nbsp; event_base：bufferevent事件所在的事件集； &nbsp; &nbsp; evutil_socket_t：相关的套接字描述符； &nbsp; &nbsp; options：选项。 &nbsp; &nbsp; (6) int bufferevent_enable(struct bufferevent *, short event) &nbsp; &nbsp; 启用bufferevent。 &nbsp; &nbsp; (7) size_t bufferevent_read(struct bufferevent *, void *data, size_t size) &nbsp; &nbsp; 读取bufferevent，返回读取的字节数。 &nbsp; &nbsp; (8) size_t bufferevent_write(struct bufferevent *, const void *data, size_t size) &nbsp; &nbsp; 写入bufferevent。 3.3 libevent示例 &nbsp; &nbsp; 这里用一个简单的示例来看看用libevent如何开发一个简单的服务器。 &nbsp; &nbsp; (1) 首先创建套接字并在指定的端口上监听 int sock_fd = ::socket(AF_INET, SOCK_STREAM, 0); if( sock_fd == -1 ) return -1; &nbsp;&nbsp;&nbsp;&nbsp;evutil_make_listen_socket_reuseable(sock_fd); struct sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_addr.s_addr = 0; sin.sin_port = htons(port); if( ::bind(sock_fd, (SA*)&amp;sin, sizeof(sin)) &lt; 0 ) goto error; if( ::listen(sock_fd, listen_num) &lt; 0) goto error; &nbsp;&nbsp;evutil_make_socket_nonblocking(listener); &nbsp; &nbsp; (2) 创建一个监听客户连接请求的事件： struct event* ev_listen = event_new(base, sock_fd, EV_READ | EV_PERSIST, accept_cb, base); event_add(ev_listen, NULL); event_base_dispatch(base); &nbsp; &nbsp; 当监听套接字有新连接时，事件将被触发，从而执行回调accept_cb： &nbsp; void accept_cb(int fd, short events, void* arg) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;evutil_socket_t sockfd; &nbsp;&nbsp;&nbsp;&nbsp;struct sockaddr_in client; &nbsp;&nbsp;&nbsp;&nbsp;socklen_t len = sizeof(client); &nbsp;&nbsp;&nbsp;&nbsp;sockfd = ::accept(fd, (struct sockaddr*)&amp;client, &amp;len ); &nbsp;&nbsp;&nbsp;&nbsp;evutil_make_socket_nonblocking(sockfd); &nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;accept a client %d\n&quot;, sockfd); &nbsp;&nbsp;&nbsp;&nbsp;struct event_base* base = (event_base*)arg; &nbsp;&nbsp;&nbsp;&nbsp;bufferevent* bev = bufferevent_socket_new(base, sockfd, BEV_OPT_CLOSE_ON_FREE); &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_setcb(bev, socket_read_cb, NULL, event_cb, arg); &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_enable(bev, EV_READ | EV_PERSIST); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 创建一个bufferevent事件，将accept以后的已连接套接字与之关联，这样当套接字上有数据到来时，就会触发bufferevent事件，从而执行socket_read_cb回调： &nbsp;&nbsp;&nbsp;&nbsp;void socket_read_cb(bufferevent* bev, void* arg) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;char msg[4096]; &nbsp;&nbsp;&nbsp;&nbsp;size_t len = bufferevent_read(bev, msg, sizeof(msg)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg[len] = &#39;\0&#39;; &nbsp;&nbsp;&nbsp;&nbsp;char reply_msg[4096] = &quot;recvieced msg:&quot;; &nbsp;&nbsp;&nbsp;&nbsp;strcat(reply_msg + strlen(reply_msg), msg); &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_write(bev, reply_msg, strlen(reply_msg)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 然后就能从bufferevent中读取到客户数据。 3.4 用libevent实现http服务器 &nbsp; &nbsp; libevent提供了http的支持，用libevent很容易实现自己的http服务，步骤如下： &nbsp; &nbsp; (1) 创建事件集和evhttp事件： struct event_base *event_base_new(void); struct evhttp *evhttp_new(struct event_base *base); &nbsp; &nbsp; (2) 绑定地址和端口 int evhttp_bind_socket(struct evhttp *http, const char *address, ev_uint16_t port); &nbsp; &nbsp; (3) 设置回调来处理http请求 void evhttp_set_gencb(struct evhttp *http, void (*cb)(struct evhttp_request *, void *), void *arg); &nbsp; &nbsp; (4) 进入事件循环 int event_base_dispatch(struct event_base *); &nbsp; &nbsp; 在下一节我们结合比特币的源码，来看看比特币中是如使用上面这些api实现http服务的，当然比特币的http服务封装的更为复杂一些。 4、比特币JSONRPC服务器的实现 4.1、JSONRPC服务器框架 &nbsp; &nbsp; 比特币使用libevent实现了一个基于工作队列的http服务器，通过采用工作队列的方式可以提高服务器的并发处理能力。该服务器框架如下： &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 逻辑其实非常简单，在http事件循环中等待http请求的到来，当收到http请求以后，从请求数据中解析出数据并封装到HttpWorkItem，放入到工作队列里，工作队列运行起来以后会开启工作线程检查工作队列，如果队列里有数据就从对头取出并执行相应的动作。 4.2、JSONRPC服务器初始化 4.2.1 注册RPC命令及处理器 &nbsp; &nbsp; JSONRPC服务器的初始化也是在bitcoind的初始化步骤中。在init.cpp的AppInitMain函数里： &nbsp;&nbsp;&nbsp;&nbsp;/* Register RPC commands regardless of -server setting so they will be * available in the GUI RPC console even if external calls are disabled. */ RegisterAllCoreRPCCommands(tableRPC); g_wallet_init_interface.RegisterRPC(tableRPC); /* Start the RPC server already. It will be started in &quot;warmup&quot; mode * and not really process calls already (but it will signify connections * that the server is there and will be ready later). Warmup mode will * be disabled when initialisation is finished. */ if (gArgs.GetBoolArg(&quot;-server&quot;, false)) { uiInterface.InitMessage.connect(SetRPCWarmupStatus); if (!AppInitServers()) return InitError(_(&quot;Unable to start HTTP server. See debug log for details.&quot;)); } &nbsp; &nbsp; 首先调用RegisterAllCoreRPCCommands注册比特币核心客户端所支持的所有RPC指令： &nbsp;&nbsp;&nbsp;&nbsp;static inline void RegisterAllCoreRPCCommands(CRPCTable &amp;t) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;RegisterBlockchainRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterNetRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterMiscRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterMiningRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterRawTransactionRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 这里可以看到对RPC命令进行了分类，操作区块链的、网络相关的、挖矿相关的以及比特币交易相关的RPC命令一应俱全。这里不妨列出来，这样读者对通过客户端能做些什么事情有个大概印象： &nbsp; &nbsp; (1) 区块链相关的rpc，位于blockchain.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;blockchain&quot;, &quot;getblockchaininfo&quot;, &amp;getblockchaininfo, {} }, { &quot;blockchain&quot;, &quot;getchaintxstats&quot;, &amp;getchaintxstats, {&quot;nblocks&quot;, &quot;blockhash&quot;} }, { &quot;blockchain&quot;, &quot;getblockstats&quot;, &amp;getblockstats, {&quot;hash_or_height&quot;, &quot;stats&quot;} }, { &quot;blockchain&quot;, &quot;getbestblockhash&quot;, &amp;getbestblockhash, {} }, { &quot;blockchain&quot;, &quot;getblockcount&quot;, &amp;getblockcount, {} }, { &quot;blockchain&quot;, &quot;getblock&quot;, &amp;getblock, {&quot;blockhash&quot;,&quot;verbosity|verbose&quot;} }, { &quot;blockchain&quot;, &quot;getblockhash&quot;, &amp;getblockhash, {&quot;height&quot;} }, { &quot;blockchain&quot;, &quot;getblockheader&quot;, &amp;getblockheader, {&quot;blockhash&quot;,&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;getchaintips&quot;, &amp;getchaintips, {} }, { &quot;blockchain&quot;, &quot;getdifficulty&quot;, &amp;getdifficulty, {} }, { &quot;blockchain&quot;, &quot;getmempoolancestors&quot;, &amp;getmempoolancestors, {&quot;txid&quot;,&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;getmempooldescendants&quot;, &amp;getmempooldescendants, {&quot;txid&quot;,&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;getmempoolentry&quot;, &amp;getmempoolentry, {&quot;txid&quot;} }, { &quot;blockchain&quot;, &quot;getmempoolinfo&quot;, &amp;getmempoolinfo, {} }, { &quot;blockchain&quot;, &quot;getrawmempool&quot;, &amp;getrawmempool, {&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;gettxout&quot;, &amp;gettxout, {&quot;txid&quot;,&quot;n&quot;,&quot;include_mempool&quot;} }, { &quot;blockchain&quot;, &quot;gettxoutsetinfo&quot;, &amp;gettxoutsetinfo, {} }, { &quot;blockchain&quot;, &quot;pruneblockchain&quot;, &amp;pruneblockchain, {&quot;height&quot;} }, { &quot;blockchain&quot;, &quot;savemempool&quot;, &amp;savemempool, {} }, { &quot;blockchain&quot;, &quot;verifychain&quot;, &amp;verifychain, {&quot;checklevel&quot;,&quot;nblocks&quot;} }, { &quot;blockchain&quot;, &quot;preciousblock&quot;, &amp;preciousblock, {&quot;blockhash&quot;} }, /* Not shown in help */ { &quot;hidden&quot;, &quot;invalidateblock&quot;, &amp;invalidateblock, {&quot;blockhash&quot;} }, { &quot;hidden&quot;, &quot;reconsiderblock&quot;, &amp;reconsiderblock, {&quot;blockhash&quot;} }, { &quot;hidden&quot;, &quot;waitfornewblock&quot;, &amp;waitfornewblock, {&quot;timeout&quot;} }, { &quot;hidden&quot;, &quot;waitforblock&quot;, &amp;waitforblock, {&quot;blockhash&quot;,&quot;timeout&quot;} }, { &quot;hidden&quot;, &quot;waitforblockheight&quot;, &amp;waitforblockheight, {&quot;height&quot;,&quot;timeout&quot;} }, { &quot;hidden&quot;, &quot;syncwithvalidationinterfacequeue&quot;, &amp;syncwithvalidationinterfacequeue, {} }, }; &nbsp; &nbsp; 所有的RPC命令以及对应的回调函数指针都封装在了CRPCCommand中，按分类、rpc方法名，回调函数，参数名封装。基本上通过方法名就能猜出其作用。 &nbsp; &nbsp; (2) 网络相关的rpc，位于net.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;network&quot;, &quot;getconnectioncount&quot;, &amp;getconnectioncount, {} }, { &quot;network&quot;, &quot;ping&quot;, &amp;ping, {} }, { &quot;network&quot;, &quot;getpeerinfo&quot;, &amp;getpeerinfo, {} }, { &quot;network&quot;, &quot;addnode&quot;, &amp;addnode, {&quot;node&quot;,&quot;command&quot;} }, { &quot;network&quot;, &quot;disconnectnode&quot;, &amp;disconnectnode, {&quot;address&quot;, &quot;nodeid&quot;} }, { &quot;network&quot;, &quot;getaddednodeinfo&quot;, &amp;getaddednodeinfo, {&quot;node&quot;} }, { &quot;network&quot;, &quot;getnettotals&quot;, &amp;getnettotals, {} }, { &quot;network&quot;, &quot;getnetworkinfo&quot;, &amp;getnetworkinfo, {} }, { &quot;network&quot;, &quot;setban&quot;, &amp;setban, {&quot;subnet&quot;, &quot;command&quot;, &quot;bantime&quot;, &quot;absolute&quot;} }, { &quot;network&quot;, &quot;listbanned&quot;, &amp;listbanned, {} }, { &quot;network&quot;, &quot;clearbanned&quot;, &amp;clearbanned, {} }, { &quot;network&quot;, &quot;setnetworkactive&quot;, &amp;setnetworkactive, {&quot;state&quot;} }, &nbsp; &nbsp; (3) 挖矿相关的rpc，位于mining.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;mining&quot;, &quot;getnetworkhashps&quot;, &amp;getnetworkhashps, {&quot;nblocks&quot;,&quot;height&quot;} }, { &quot;mining&quot;, &quot;getmininginfo&quot;, &amp;getmininginfo, {} }, { &quot;mining&quot;, &quot;prioritisetransaction&quot;, &amp;prioritisetransaction, {&quot;txid&quot;,&quot;dummy&quot;,&quot;fee_delta&quot;} }, { &quot;mining&quot;, &quot;getblocktemplate&quot;, &amp;getblocktemplate, {&quot;template_request&quot;} }, { &quot;mining&quot;, &quot;submitblock&quot;, &amp;submitblock, {&quot;hexdata&quot;,&quot;dummy&quot;} }, { &quot;generating&quot;, &quot;generatetoaddress&quot;, &amp;generatetoaddress, {&quot;nblocks&quot;,&quot;address&quot;,&quot;maxtries&quot;} }, { &quot;hidden&quot;, &quot;estimatefee&quot;, &amp;estimatefee, {} }, { &quot;util&quot;, &quot;estimatesmartfee&quot;, &amp;estimatesmartfee, {&quot;conf_target&quot;, &quot;estimate_mode&quot;} }, { &quot;hidden&quot;, &quot;estimaterawfee&quot;, &amp;estimaterawfee, {&quot;conf_target&quot;, &quot;threshold&quot;} }, }; &nbsp; &nbsp; (4) 比特币交易相关rpc，位于rawtransaction.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;rawtransactions&quot;, &quot;getrawtransaction&quot;, &amp;getrawtransaction, {&quot;txid&quot;,&quot;verbose&quot;,&quot;blockhash&quot;} }, { &quot;rawtransactions&quot;, &quot;createrawtransaction&quot;, &amp;createrawtransaction, {&quot;inputs&quot;,&quot;outputs&quot;,&quot;locktime&quot;,&quot;replaceable&quot;} }, { &quot;rawtransactions&quot;, &quot;decoderawtransaction&quot;, &amp;decoderawtransaction, {&quot;hexstring&quot;,&quot;iswitness&quot;} }, { &quot;rawtransactions&quot;, &quot;decodescript&quot;, &amp;decodescript, {&quot;hexstring&quot;} }, { &quot;rawtransactions&quot;, &quot;sendrawtransaction&quot;, &amp;sendrawtransaction, {&quot;hexstring&quot;,&quot;allowhighfees&quot;} }, { &quot;rawtransactions&quot;, &quot;combinerawtransaction&quot;, &amp;combinerawtransaction, {&quot;txs&quot;} }, { &quot;rawtransactions&quot;, &quot;signrawtransaction&quot;, &amp;signrawtransaction, {&quot;hexstring&quot;,&quot;prevtxs&quot;,&quot;privkeys&quot;,&quot;sighashtype&quot;} }, /* uses wallet if enabled */ { &quot;rawtransactions&quot;, &quot;signrawtransactionwithkey&quot;, &amp;signrawtransactionwithkey, {&quot;hexstring&quot;,&quot;privkeys&quot;,&quot;prevtxs&quot;,&quot;sighashtype&quot;} }, { &quot;rawtransactions&quot;, &quot;testmempoolaccept&quot;, &amp;testmempoolaccept, {&quot;rawtxs&quot;,&quot;allowhighfees&quot;} }, { &quot;blockchain&quot;, &quot;gettxoutproof&quot;, &amp;gettxoutproof, {&quot;txids&quot;, &quot;blockhash&quot;} }, { &quot;blockchain&quot;, &quot;verifytxoutproof&quot;, &amp;verifytxoutproof, {&quot;proof&quot;} }, }; &nbsp; &nbsp; 当注册完以后，如果用户启用了-server选项，将会调用AppInitServers创建Http服务器。 4.2.2 创建http服务器 &nbsp; &nbsp; AppInitServers实现如下： static bool AppInitServers() { RPCServer::OnStarted(&amp;OnRPCStarted); RPCServer::OnStopped(&amp;OnRPCStopped); if (!InitHTTPServer()) return false; if (!StartRPC()) return false; if (!StartHTTPRPC()) return false; if (gArgs.GetBoolArg(&quot;-rest&quot;, DEFAULT_REST_ENABLE) &amp;&amp; !StartREST()) return false; if (!StartHTTPServer()) return false; return true; } &nbsp; &nbsp; 这里按步骤一步一步的来。首先是调用InitHTTPServer，使用libevent api来建立http服务器，这里截取主要代码来看看，位于httpserver.cpp文件： &nbsp;&nbsp;&nbsp;&nbsp;raii_event_base base_ctr = obtain_event_base(); /* Create a new evhttp object to handle requests. */ raii_evhttp http_ctr = obtain_evhttp(base_ctr.get()); struct evhttp* http = http_ctr.get(); if (!http) { LogPrintf(&quot;couldn&#39;t create evhttp. Exiting.\n&quot;); return false; } evhttp_set_timeout(http, gArgs.GetArg(&quot;-rpcservertimeout&quot;, DEFAULT_HTTP_SERVER_TIMEOUT)); evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE); evhttp_set_max_body_size(http, MAX_SIZE); evhttp_set_gencb(http, http_request_cb, nullptr); if (!HTTPBindAddresses(http)) { LogPrintf(&quot;Unable to bind any endpoint for RPC server\n&quot;); return false; } LogPrint(BCLog::HTTP, &quot;Initialized HTTP server\n&quot;); int workQueueDepth = std::max((long)gArgs.GetArg(&quot;-rpcworkqueue&quot;, DEFAULT_HTTP_WORKQUEUE), 1L); LogPrintf(&quot;HTTP: creating work queue of depth %d\n&quot;, workQueueDepth); workQueue = new WorkQueue&lt;HTTPClosure&gt;(workQueueDepth); // transfer ownership to eventBase/HTTP via .release() eventBase = base_ctr.release(); eventHTTP = http_ctr.release(); &nbsp; &nbsp; 这里的套路和3.4节中用libevent建立http服务器的步骤基本一样，注意两点： &nbsp; &nbsp; (1) 用evhttp_set_gencb设置了http请求的处理函数：http_request_cb; &nbsp; &nbsp; (2) 创建了一个工作队列，队列里的元素类型HTTPClosure，这是一个函数对象接口类，重写了函数调用操作符，HttpWorkItem实现了此接口。 4.2.3 http请求的处理 &nbsp; &nbsp; 我们来看看当bitcoind收到一个http请求以后是如何处理的，就是http_request_cb回调，主要代码如下： &nbsp;&nbsp;&nbsp;&nbsp;// Find registered handler for prefix std::string strURI = hreq-&gt;GetURI(); std::string path; std::vector&lt;HTTPPathHandler&gt;::const_iterator i = pathHandlers.begin(); std::vector&lt;HTTPPathHandler&gt;::const_iterator iend = pathHandlers.end(); for (; i != iend; ++i) { bool match = false; if (i-&gt;exactMatch) match = (strURI == i-&gt;prefix); else match = (strURI.substr(0, i-&gt;prefix.size()) == i-&gt;prefix); if (match) { path = strURI.substr(i-&gt;prefix.size()); break; } } // Dispatch to worker thread if (i != iend) { std::unique_ptr&lt;HTTPWorkItem&gt; item(new HTTPWorkItem(std::move(hreq), path, i-&gt;handler)); assert(workQueue); if (workQueue-&gt;Enqueue(item.get())) item.release(); /* if true, queue took ownership */ else { LogPrintf(&quot;WARNING: request rejected because http work queue depth exceeded, it can be increased with the -rpcworkqueue= setting\n&quot;); item-&gt;req-&gt;WriteReply(HTTP_INTERNAL, &quot;Work queue depth exceeded&quot;); } } else { hreq-&gt;WriteReply(HTTP_NOTFOUND); } &nbsp; &nbsp; 用一句话来概括这个函数的作用就是：将请求的url的path部分与注册过的前缀进行匹配，并生成HttpWorkItem放入到工作队列中。目前注册了两个前缀：/和/wallet/，代码在StartHttpRPC中： bool StartHTTPRPC() { LogPrint(BCLog::RPC, &quot;Starting HTTP RPC server\n&quot;); if (!InitRPCAuthentication()) return false; RegisterHTTPHandler(&quot;/&quot;, true, HTTPReq_JSONRPC); #ifdef ENABLE_WALLET // ifdef can be removed once we switch to better endpoint support and API versioning RegisterHTTPHandler(&quot;/wallet/&quot;, false, HTTPReq_JSONRPC); #endif assert(EventBase()); httpRPCTimerInterface = MakeUnique&lt;HTTPRPCTimerInterface&gt;(EventBase()); RPCSetTimerInterface(httpRPCTimerInterface.get()); return true; } &nbsp; &nbsp; 两个前缀/和/wallet/对应的回调处理函数均为HttpReq_JSONRPC。 &nbsp; &nbsp; 之后调用StartHttpServer让工作队列运行起来： bool StartHTTPServer() { LogPrint(BCLog::HTTP, &quot;Starting HTTP server\n&quot;); int rpcThreads = std::max((long)gArgs.GetArg(&quot;-rpcthreads&quot;, DEFAULT_HTTP_THREADS), 1L); LogPrintf(&quot;HTTP: starting %d worker threads\n&quot;, rpcThreads); std::packaged_task&lt;bool(event_base*, evhttp*)&gt; task(ThreadHTTP); threadResult = task.get_future(); threadHTTP = std::thread(std::move(task), eventBase, eventHTTP); for (int i = 0; i &lt; rpcThreads; i++) { g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue); } return true; } &nbsp; &nbsp; 最终会调用到工作队列的run方法： void Run() { while (true) { std::unique_ptr&lt;WorkItem&gt; i; { std::unique_lock&lt;std::mutex&gt; lock(cs); while (running &amp;&amp; queue.empty()) cond.wait(lock); if (!running) break; i = std::move(queue.front()); queue.pop_front(); } (*i)(); } } &nbsp; &nbsp; 很简单，工作队列为空的时候线程阻塞等待，当收到http请求以后，解析请求并添加HttpWorkItem到队列中并唤醒线程，线程从队列头部取出一个item运行。最终将执行HttpReq_JSONRPC这个回调，这里会将JSONRPC中的rpc方法分发到服务端不同的方法中，来看看其处理： &nbsp; &nbsp; (1) 请求合法性检查及认证 &nbsp; &nbsp; 首先检查请求是否合法，http头部中的auchoization是否合法： static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &amp;) { // JSONRPC handles only POST if (req-&gt;GetRequestMethod() != HTTPRequest::POST) { req-&gt;WriteReply(HTTP_BAD_METHOD, &quot;JSONRPC server handles only POST requests&quot;); return false; } // Check authorization std::pair&lt;bool, std::string&gt; authHeader = req-&gt;GetHeader(&quot;authorization&quot;); if (!authHeader.first) { req-&gt;WriteHeader(&quot;WWW-Authenticate&quot;, WWW_AUTH_HEADER_DATA); req-&gt;WriteReply(HTTP_UNAUTHORIZED); return false; } JSONRPCRequest jreq; jreq.peerAddr = req-&gt;GetPeer().ToString(); if (!RPCAuthorized(authHeader.second, jreq.authUser)) { LogPrintf(&quot;ThreadRPCServer incorrect password attempt from %s\n&quot;, jreq.peerAddr); /* Deter brute-forcing If this results in a DoS the user really shouldn&#39;t have their RPC port exposed. */ MilliSleep(250); req-&gt;WriteHeader(&quot;WWW-Authenticate&quot;, WWW_AUTH_HEADER_DATA); req-&gt;WriteReply(HTTP_UNAUTHORIZED); return false; } &nbsp; &nbsp; 可以看到，比特币的json rpc服务只支持POST。 &nbsp; &nbsp; (2) 读取http请求数据，将rpc请求分发到不同的函数 &nbsp;&nbsp;&nbsp;&nbsp;try { // Parse request UniValue valRequest; if (!valRequest.read(req-&gt;ReadBody())) throw JSONRPCError(RPC_PARSE_ERROR, &quot;Parse error&quot;); // Set the URI jreq.URI = req-&gt;GetURI(); std::string strReply; // singleton request if (valRequest.isObject()) { jreq.parse(valRequest); UniValue result = tableRPC.execute(jreq); // Send reply strReply = JSONRPCReply(result, NullUniValue, jreq.id); // array of requests } else if (valRequest.isArray()) strReply = JSONRPCExecBatch(jreq, valRequest.get_array()); else throw JSONRPCError(RPC_PARSE_ERROR, &quot;Top-level object parse error&quot;); req-&gt;WriteHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); req-&gt;WriteReply(HTTP_OK, strReply); &nbsp; &nbsp; 如果收到的是单个json，则tableRPC.execute执行，否则如果收到的是以数组形式的批量rpc请求，则批量执行，批量执行最终也是走tableRPC.execute()来分发，execute()执行后的结果将写入到http响应包中： UniValue CRPCTable::execute(const JSONRPCRequest &amp;request) const { // Return immediately if in warmup { LOCK(cs_rpcWarmup); if (fRPCInWarmup) throw JSONRPCError(RPC_IN_WARMUP, rpcWarmupStatus); } // Find method const CRPCCommand *pcmd = tableRPC[request.strMethod]; if (!pcmd) throw JSONRPCError(RPC_METHOD_NOT_FOUND, &quot;Method not found&quot;); g_rpcSignals.PreCommand(*pcmd); try { // Execute, convert arguments to array if necessary if (request.params.isObject()) { return pcmd-&gt;actor(transformNamedArguments(request, pcmd-&gt;argNames)); } else { return pcmd-&gt;actor(request); } } catch (const std::exception&amp; e) { throw JSONRPCError(RPC_MISC_ERROR, e.what()); } } &nbsp; &nbsp; 代码也比较容易理解，就是从根据json-rpc协议，从请求中读取method，然后根据method找到对应的CRPCCommand执行体，这些执行体就是4.2.1节中提到那几张分门别类的映射表。 &nbsp; &nbsp; 至此，比特币的json-rpc服务端的脉络我们就梳理的差不多了，整体框架并不难理解，只是封装的略微复杂一点点。 5、小结 &nbsp; &nbsp; 本文对json-rpc协议，libevent进行了简要描述，并结合源码分析了比特币的JSONRPC服务的实现。比特币核心客户端的bitcon-cli只是一个示例性质的命令行工具，如果想自己撸一个特定平台上的带有GUI的比特币钱包客户端，看完本文后相信将能信手拈来。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"&nbsp; &nbsp; 比特币源码为我们提供了一个比特币核心客户端，这个核心客户端也称为中本聪客户端，和SPV轻量级客户端相比，比特币核心客户端包含了比特币的方方面面。比特币核心客户端中包含一个服务端bitcoind和一个命令行工具bitcoin-cli，通过bitcoin-cli，用户可以在命令行进行诸如创建交易、发送交易，查看交易，查看区块等一系列的操作。bitcoin-cli和bitcoind是典型的C/S模式，bitcoind中实现了一个http服务器，bitcoin-cli则是一个http客户端，二者之间的传输数据遵循json-rpc协议。本文将结合源码对比特币json-rpc服务的实现进行分析。 1、比特币核心客户端架构 1.1 示例 &nbsp; &nbsp; 先来看看bitcoin-cli的一个使用示例。我们知道区块链的一个最大特性就是能够追根溯源，任何一笔交易在验证后最终都记录到了区块链上，之后就无法篡改，现在我们通过bitcoin-cli来查看区块链上的一笔交易，这个示例来自于《精通比特币》一书： &nbsp; &nbsp; 假设我们已经下载并且编译好了比特币客户端，并且bitcoind已经运行起来了（可以在命令行输入bitciond &amp;让其在后台运行）现在我们要查看一下交易hash为9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3的详细信息，我们在命令行输入： &nbsp; &nbsp; $ bitcoin-cli gettransaction&nbsp;9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3 &nbsp; &nbsp; 然后，在命令行就能看到服务器返回的json格式表示的交易的信息： { &quot;amount&quot; : 0.05000000, &quot;confirmations&quot; : 0, &quot;txid&quot;:&quot;9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3&quot;, &quot;time&quot; : 1392660908, &quot;timereceived&quot; : 1392660908, &quot;details&quot; : [ { &quot;account&quot; : &quot;&quot;, &quot;address&quot;:&quot;1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL&quot;, &quot;category&quot; : &quot;receive&quot;, &quot;amount&quot; : 0.05000000 } ] } &nbsp; &nbsp; 可以看到这笔交易里向比特币地址1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL转移了0.05个比特币。 &nbsp; &nbsp; 用类似的方式我们还能进行很多操作，比如创建交易，生成钱包地址，查看区块等等。而这种简单的命令背后的实现，就是本文要讲述的基于json-rpc的http服务。 1.2 架构&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bitcoin-cli通过http向bitcoind请求服务，其传输数据格式遵循json-rpc协议，整体架构如下图： &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 搞清楚bitcoin-cli和bicoind的实现原理以及二者之间的交互过程对后续区块链的学习会很有帮助，在搞明白这一部分的原理后，还可以比较容易的在各种平台上（比如android、ios、pc等等）实现自己定制的比特币钱包客户端，下文来一步一步的开始分析。 2、json-rpc介绍&nbsp; &nbsp; json-rpc是一个基于json的跨语言rpc协议，具有传输数据小，便于实现，扩展和调试等优点，目前主流的编程语言比如java，c/c++等都有json-rpc的实现框架。 2.1 请求 &nbsp; &nbsp; json-rpc的请求非常简单，其格式如下： { &quot;jsonrpc&quot; : 2.0, &quot;method&quot; : &quot;getinfo&quot;, &quot;params&quot; : [&quot;&quot;], &quot;id&quot; : 1 } &nbsp; &nbsp; jsonrpc：json-rpc的版本； &nbsp; &nbsp; method：rpc调用的方法名； &nbsp; &nbsp; params：方法传入的参数，没有参数传入nullptr； &nbsp; &nbsp; id：调用的标识符，可以为字符串，也可以为nullptr，但是不建议使用nullptr，因为容易引起混乱。 2.2 响应 { &quot;jsonrpc&quot; : 2.0, &quot;result&quot; : &quot;info&quot;, &quot;error&quot; : null, &quot;id&quot; : 1 } &nbsp; &nbsp; jsonrpc：json-rpc版本； &nbsp; &nbsp; result：rpc调用的返回值，调用成功时不能为nullptr，调用失败必须为nullptr； &nbsp; &nbsp; error：调用错误时用，无错误为nullptr，有错误时返回错误对象，参见下一节； &nbsp; &nbsp; id：调用标识符，与调用方传入的保持一致。 2.3 错误对象 { &quot;code&quot; : 1, &quot;message&quot; : &quot;some error.&quot;, &quot;data&quot;:null } &nbsp; &nbsp; code：错误码； &nbsp; &nbsp; message：错误信息； &nbsp; &nbsp; data：附加信息，可以为nullptr。 &nbsp; &nbsp; 错误码见下表： 错误码 错误 含义 -32700 解析错误 服务器收到无效json，或者解析json出错 -32600 无效的请求 发送的json不是一个有效的请求 -32601 方法未找到 方法不存在或不可见 -36602 无效的参数 无效的方法参数 -36603 内部错误 json-rpc的内部错误 -32000到-32099 服务器端错误 保留给具体服务器实现的服务端错误 &nbsp; &nbsp; 比特币核心实现了一个基于libevent的http服务器，下文会对这个服务器的实现进行介绍。 3、libevent库 3.1 介绍 &nbsp; &nbsp; libevent是一个轻量级、跨平台、基于事件的高性能网络库。它封装了不同平台的io复用技术，对外暴露一致的接口。通常在编写服务器程序时所面临的一个最大问题就是高并发，libevent是解决大量并发请求的一个较好的解决方案。 &nbsp; &nbsp; 常见的处理大量并发请求的方法： &nbsp; &nbsp; (1) IO复用技术 &nbsp; &nbsp; 通过select，poll或epoll等系统api，实现io复用。 &nbsp; &nbsp; (2) 多线程或多进程 &nbsp; &nbsp; 多线程和多进程也可以解决大量并发请求的问题，但是无论多进程还是多线程，都存在问题：多进程不适合短连接，进程的创建和销毁开销比较大；多线程不适合短连接，大量的线程会导致较大的内存开销。 &nbsp; &nbsp; (3) 多线程结合IO复用 &nbsp; &nbsp; 将IO复用和多线程结合起来，这是目前解决大并发的常用方案。最常见的套路就是主线程里监听某个端口以及接受的描述符，当有读写事件产生时，将事件交给工作线程去处理。 &nbsp; &nbsp; libevent封装了select，poll，epoll等io复用技术，同时采用时间驱动的机制：应用向libevent注册事件和相应的回调，当事件发生时libevent调用这些回调，libevent支持三种事件：网络IO，定时器和信号。 3.2 api &nbsp; &nbsp; 关于libevent的实现原理本文不详细展开，有兴趣的同学可以在github自行下载源代码学习。这里只简单介绍几个核心的api。 &nbsp; &nbsp; (1) struct event_base * event_base_new() &nbsp; &nbsp; 创建一个事件集，事件必须加入到事件集里才能接收到回调。 &nbsp; &nbsp; (2) struct event event_new(struct event_base *, evutil_socket_t, short, event_callback_fn, void*) &nbsp; &nbsp; 创建一个事件，其参数如下： &nbsp; &nbsp; event_base：事件所在的事件集； &nbsp; &nbsp; evutil_socket_t：socket描述符； &nbsp; &nbsp; short：事件类型，EV_READ表示等待读事件，EV_WRITE表示写事件，EV_SIGNAL表示要等待的信号； &nbsp; &nbsp; event_callback_fn：事件发生时的回调函数； &nbsp; &nbsp; void* 回调函数的参数 &nbsp; &nbsp; (3) int event_add(struct event *, struct timeval *)&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 添加事件。 &nbsp; &nbsp; event：要添加的时间 &nbsp; &nbsp; timeval：等待事件的超时值，如果为nullptr将是无限等待。 &nbsp; &nbsp; (4) int event_del(struct event *) &nbsp; &nbsp; 删除事件。 &nbsp; &nbsp; (5) struct bufferevent *bufferevent_socket_new(struct event_base *, evutil_socket_t, int options) &nbsp; &nbsp; 创建一个bufferevent，bufferevent封装了read，write等读写函数。 &nbsp; &nbsp; event_base：bufferevent事件所在的事件集； &nbsp; &nbsp; evutil_socket_t：相关的套接字描述符； &nbsp; &nbsp; options：选项。 &nbsp; &nbsp; (6) int bufferevent_enable(struct bufferevent *, short event) &nbsp; &nbsp; 启用bufferevent。 &nbsp; &nbsp; (7) size_t bufferevent_read(struct bufferevent *, void *data, size_t size) &nbsp; &nbsp; 读取bufferevent，返回读取的字节数。 &nbsp; &nbsp; (8) size_t bufferevent_write(struct bufferevent *, const void *data, size_t size) &nbsp; &nbsp; 写入bufferevent。 3.3 libevent示例 &nbsp; &nbsp; 这里用一个简单的示例来看看用libevent如何开发一个简单的服务器。 &nbsp; &nbsp; (1) 首先创建套接字并在指定的端口上监听 int sock_fd = ::socket(AF_INET, SOCK_STREAM, 0); if( sock_fd == -1 ) return -1; &nbsp;&nbsp;&nbsp;&nbsp;evutil_make_listen_socket_reuseable(sock_fd); struct sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_addr.s_addr = 0; sin.sin_port = htons(port); if( ::bind(sock_fd, (SA*)&amp;sin, sizeof(sin)) &lt; 0 ) goto error; if( ::listen(sock_fd, listen_num) &lt; 0) goto error; &nbsp;&nbsp;evutil_make_socket_nonblocking(listener); &nbsp; &nbsp; (2) 创建一个监听客户连接请求的事件： struct event* ev_listen = event_new(base, sock_fd, EV_READ | EV_PERSIST, accept_cb, base); event_add(ev_listen, NULL); event_base_dispatch(base); &nbsp; &nbsp; 当监听套接字有新连接时，事件将被触发，从而执行回调accept_cb： &nbsp; void accept_cb(int fd, short events, void* arg) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;evutil_socket_t sockfd; &nbsp;&nbsp;&nbsp;&nbsp;struct sockaddr_in client; &nbsp;&nbsp;&nbsp;&nbsp;socklen_t len = sizeof(client); &nbsp;&nbsp;&nbsp;&nbsp;sockfd = ::accept(fd, (struct sockaddr*)&amp;client, &amp;len ); &nbsp;&nbsp;&nbsp;&nbsp;evutil_make_socket_nonblocking(sockfd); &nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;accept a client %d\\n&quot;, sockfd); &nbsp;&nbsp;&nbsp;&nbsp;struct event_base* base = (event_base*)arg; &nbsp;&nbsp;&nbsp;&nbsp;bufferevent* bev = bufferevent_socket_new(base, sockfd, BEV_OPT_CLOSE_ON_FREE); &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_setcb(bev, socket_read_cb, NULL, event_cb, arg); &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_enable(bev, EV_READ | EV_PERSIST); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 创建一个bufferevent事件，将accept以后的已连接套接字与之关联，这样当套接字上有数据到来时，就会触发bufferevent事件，从而执行socket_read_cb回调： &nbsp;&nbsp;&nbsp;&nbsp;void socket_read_cb(bufferevent* bev, void* arg) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;char msg[4096]; &nbsp;&nbsp;&nbsp;&nbsp;size_t len = bufferevent_read(bev, msg, sizeof(msg)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg[len] = &#39;\\0&#39;; &nbsp;&nbsp;&nbsp;&nbsp;char reply_msg[4096] = &quot;recvieced msg:&quot;; &nbsp;&nbsp;&nbsp;&nbsp;strcat(reply_msg + strlen(reply_msg), msg); &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_write(bev, reply_msg, strlen(reply_msg)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 然后就能从bufferevent中读取到客户数据。 3.4 用libevent实现http服务器 &nbsp; &nbsp; libevent提供了http的支持，用libevent很容易实现自己的http服务，步骤如下： &nbsp; &nbsp; (1) 创建事件集和evhttp事件： struct event_base *event_base_new(void); struct evhttp *evhttp_new(struct event_base *base); &nbsp; &nbsp; (2) 绑定地址和端口 int evhttp_bind_socket(struct evhttp *http, const char *address, ev_uint16_t port); &nbsp; &nbsp; (3) 设置回调来处理http请求 void evhttp_set_gencb(struct evhttp *http, void (*cb)(struct evhttp_request *, void *), void *arg); &nbsp; &nbsp; (4) 进入事件循环 int event_base_dispatch(struct event_base *); &nbsp; &nbsp; 在下一节我们结合比特币的源码，来看看比特币中是如使用上面这些api实现http服务的，当然比特币的http服务封装的更为复杂一些。 4、比特币JSONRPC服务器的实现 4.1、JSONRPC服务器框架 &nbsp; &nbsp; 比特币使用libevent实现了一个基于工作队列的http服务器，通过采用工作队列的方式可以提高服务器的并发处理能力。该服务器框架如下： &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 逻辑其实非常简单，在http事件循环中等待http请求的到来，当收到http请求以后，从请求数据中解析出数据并封装到HttpWorkItem，放入到工作队列里，工作队列运行起来以后会开启工作线程检查工作队列，如果队列里有数据就从对头取出并执行相应的动作。 4.2、JSONRPC服务器初始化 4.2.1 注册RPC命令及处理器 &nbsp; &nbsp; JSONRPC服务器的初始化也是在bitcoind的初始化步骤中。在init.cpp的AppInitMain函数里： &nbsp;&nbsp;&nbsp;&nbsp;/* Register RPC commands regardless of -server setting so they will be * available in the GUI RPC console even if external calls are disabled. */ RegisterAllCoreRPCCommands(tableRPC); g_wallet_init_interface.RegisterRPC(tableRPC); /* Start the RPC server already. It will be started in &quot;warmup&quot; mode * and not really process calls already (but it will signify connections * that the server is there and will be ready later). Warmup mode will * be disabled when initialisation is finished. */ if (gArgs.GetBoolArg(&quot;-server&quot;, false)) { uiInterface.InitMessage.connect(SetRPCWarmupStatus); if (!AppInitServers()) return InitError(_(&quot;Unable to start HTTP server. See debug log for details.&quot;)); } &nbsp; &nbsp; 首先调用RegisterAllCoreRPCCommands注册比特币核心客户端所支持的所有RPC指令： &nbsp;&nbsp;&nbsp;&nbsp;static inline void RegisterAllCoreRPCCommands(CRPCTable &amp;t) &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;RegisterBlockchainRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterNetRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterMiscRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterMiningRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;RegisterRawTransactionRPCCommands(t); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 这里可以看到对RPC命令进行了分类，操作区块链的、网络相关的、挖矿相关的以及比特币交易相关的RPC命令一应俱全。这里不妨列出来，这样读者对通过客户端能做些什么事情有个大概印象： &nbsp; &nbsp; (1) 区块链相关的rpc，位于blockchain.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;blockchain&quot;, &quot;getblockchaininfo&quot;, &amp;getblockchaininfo, {} }, { &quot;blockchain&quot;, &quot;getchaintxstats&quot;, &amp;getchaintxstats, {&quot;nblocks&quot;, &quot;blockhash&quot;} }, { &quot;blockchain&quot;, &quot;getblockstats&quot;, &amp;getblockstats, {&quot;hash_or_height&quot;, &quot;stats&quot;} }, { &quot;blockchain&quot;, &quot;getbestblockhash&quot;, &amp;getbestblockhash, {} }, { &quot;blockchain&quot;, &quot;getblockcount&quot;, &amp;getblockcount, {} }, { &quot;blockchain&quot;, &quot;getblock&quot;, &amp;getblock, {&quot;blockhash&quot;,&quot;verbosity|verbose&quot;} }, { &quot;blockchain&quot;, &quot;getblockhash&quot;, &amp;getblockhash, {&quot;height&quot;} }, { &quot;blockchain&quot;, &quot;getblockheader&quot;, &amp;getblockheader, {&quot;blockhash&quot;,&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;getchaintips&quot;, &amp;getchaintips, {} }, { &quot;blockchain&quot;, &quot;getdifficulty&quot;, &amp;getdifficulty, {} }, { &quot;blockchain&quot;, &quot;getmempoolancestors&quot;, &amp;getmempoolancestors, {&quot;txid&quot;,&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;getmempooldescendants&quot;, &amp;getmempooldescendants, {&quot;txid&quot;,&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;getmempoolentry&quot;, &amp;getmempoolentry, {&quot;txid&quot;} }, { &quot;blockchain&quot;, &quot;getmempoolinfo&quot;, &amp;getmempoolinfo, {} }, { &quot;blockchain&quot;, &quot;getrawmempool&quot;, &amp;getrawmempool, {&quot;verbose&quot;} }, { &quot;blockchain&quot;, &quot;gettxout&quot;, &amp;gettxout, {&quot;txid&quot;,&quot;n&quot;,&quot;include_mempool&quot;} }, { &quot;blockchain&quot;, &quot;gettxoutsetinfo&quot;, &amp;gettxoutsetinfo, {} }, { &quot;blockchain&quot;, &quot;pruneblockchain&quot;, &amp;pruneblockchain, {&quot;height&quot;} }, { &quot;blockchain&quot;, &quot;savemempool&quot;, &amp;savemempool, {} }, { &quot;blockchain&quot;, &quot;verifychain&quot;, &amp;verifychain, {&quot;checklevel&quot;,&quot;nblocks&quot;} }, { &quot;blockchain&quot;, &quot;preciousblock&quot;, &amp;preciousblock, {&quot;blockhash&quot;} }, /* Not shown in help */ { &quot;hidden&quot;, &quot;invalidateblock&quot;, &amp;invalidateblock, {&quot;blockhash&quot;} }, { &quot;hidden&quot;, &quot;reconsiderblock&quot;, &amp;reconsiderblock, {&quot;blockhash&quot;} }, { &quot;hidden&quot;, &quot;waitfornewblock&quot;, &amp;waitfornewblock, {&quot;timeout&quot;} }, { &quot;hidden&quot;, &quot;waitforblock&quot;, &amp;waitforblock, {&quot;blockhash&quot;,&quot;timeout&quot;} }, { &quot;hidden&quot;, &quot;waitforblockheight&quot;, &amp;waitforblockheight, {&quot;height&quot;,&quot;timeout&quot;} }, { &quot;hidden&quot;, &quot;syncwithvalidationinterfacequeue&quot;, &amp;syncwithvalidationinterfacequeue, {} }, }; &nbsp; &nbsp; 所有的RPC命令以及对应的回调函数指针都封装在了CRPCCommand中，按分类、rpc方法名，回调函数，参数名封装。基本上通过方法名就能猜出其作用。 &nbsp; &nbsp; (2) 网络相关的rpc，位于net.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;network&quot;, &quot;getconnectioncount&quot;, &amp;getconnectioncount, {} }, { &quot;network&quot;, &quot;ping&quot;, &amp;ping, {} }, { &quot;network&quot;, &quot;getpeerinfo&quot;, &amp;getpeerinfo, {} }, { &quot;network&quot;, &quot;addnode&quot;, &amp;addnode, {&quot;node&quot;,&quot;command&quot;} }, { &quot;network&quot;, &quot;disconnectnode&quot;, &amp;disconnectnode, {&quot;address&quot;, &quot;nodeid&quot;} }, { &quot;network&quot;, &quot;getaddednodeinfo&quot;, &amp;getaddednodeinfo, {&quot;node&quot;} }, { &quot;network&quot;, &quot;getnettotals&quot;, &amp;getnettotals, {} }, { &quot;network&quot;, &quot;getnetworkinfo&quot;, &amp;getnetworkinfo, {} }, { &quot;network&quot;, &quot;setban&quot;, &amp;setban, {&quot;subnet&quot;, &quot;command&quot;, &quot;bantime&quot;, &quot;absolute&quot;} }, { &quot;network&quot;, &quot;listbanned&quot;, &amp;listbanned, {} }, { &quot;network&quot;, &quot;clearbanned&quot;, &amp;clearbanned, {} }, { &quot;network&quot;, &quot;setnetworkactive&quot;, &amp;setnetworkactive, {&quot;state&quot;} }, &nbsp; &nbsp; (3) 挖矿相关的rpc，位于mining.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;mining&quot;, &quot;getnetworkhashps&quot;, &amp;getnetworkhashps, {&quot;nblocks&quot;,&quot;height&quot;} }, { &quot;mining&quot;, &quot;getmininginfo&quot;, &amp;getmininginfo, {} }, { &quot;mining&quot;, &quot;prioritisetransaction&quot;, &amp;prioritisetransaction, {&quot;txid&quot;,&quot;dummy&quot;,&quot;fee_delta&quot;} }, { &quot;mining&quot;, &quot;getblocktemplate&quot;, &amp;getblocktemplate, {&quot;template_request&quot;} }, { &quot;mining&quot;, &quot;submitblock&quot;, &amp;submitblock, {&quot;hexdata&quot;,&quot;dummy&quot;} }, { &quot;generating&quot;, &quot;generatetoaddress&quot;, &amp;generatetoaddress, {&quot;nblocks&quot;,&quot;address&quot;,&quot;maxtries&quot;} }, { &quot;hidden&quot;, &quot;estimatefee&quot;, &amp;estimatefee, {} }, { &quot;util&quot;, &quot;estimatesmartfee&quot;, &amp;estimatesmartfee, {&quot;conf_target&quot;, &quot;estimate_mode&quot;} }, { &quot;hidden&quot;, &quot;estimaterawfee&quot;, &amp;estimaterawfee, {&quot;conf_target&quot;, &quot;threshold&quot;} }, }; &nbsp; &nbsp; (4) 比特币交易相关rpc，位于rawtransaction.cpp中： static const CRPCCommand commands[] = { // category name actor (function) argNames // --------------------- ------------------------ ----------------------- ---------- { &quot;rawtransactions&quot;, &quot;getrawtransaction&quot;, &amp;getrawtransaction, {&quot;txid&quot;,&quot;verbose&quot;,&quot;blockhash&quot;} }, { &quot;rawtransactions&quot;, &quot;createrawtransaction&quot;, &amp;createrawtransaction, {&quot;inputs&quot;,&quot;outputs&quot;,&quot;locktime&quot;,&quot;replaceable&quot;} }, { &quot;rawtransactions&quot;, &quot;decoderawtransaction&quot;, &amp;decoderawtransaction, {&quot;hexstring&quot;,&quot;iswitness&quot;} }, { &quot;rawtransactions&quot;, &quot;decodescript&quot;, &amp;decodescript, {&quot;hexstring&quot;} }, { &quot;rawtransactions&quot;, &quot;sendrawtransaction&quot;, &amp;sendrawtransaction, {&quot;hexstring&quot;,&quot;allowhighfees&quot;} }, { &quot;rawtransactions&quot;, &quot;combinerawtransaction&quot;, &amp;combinerawtransaction, {&quot;txs&quot;} }, { &quot;rawtransactions&quot;, &quot;signrawtransaction&quot;, &amp;signrawtransaction, {&quot;hexstring&quot;,&quot;prevtxs&quot;,&quot;privkeys&quot;,&quot;sighashtype&quot;} }, /* uses wallet if enabled */ { &quot;rawtransactions&quot;, &quot;signrawtransactionwithkey&quot;, &amp;signrawtransactionwithkey, {&quot;hexstring&quot;,&quot;privkeys&quot;,&quot;prevtxs&quot;,&quot;sighashtype&quot;} }, { &quot;rawtransactions&quot;, &quot;testmempoolaccept&quot;, &amp;testmempoolaccept, {&quot;rawtxs&quot;,&quot;allowhighfees&quot;} }, { &quot;blockchain&quot;, &quot;gettxoutproof&quot;, &amp;gettxoutproof, {&quot;txids&quot;, &quot;blockhash&quot;} }, { &quot;blockchain&quot;, &quot;verifytxoutproof&quot;, &amp;verifytxoutproof, {&quot;proof&quot;} }, }; &nbsp; &nbsp; 当注册完以后，如果用户启用了-server选项，将会调用AppInitServers创建Http服务器。 4.2.2 创建http服务器 &nbsp; &nbsp; AppInitServers实现如下： static bool AppInitServers() { RPCServer::OnStarted(&amp;OnRPCStarted); RPCServer::OnStopped(&amp;OnRPCStopped); if (!InitHTTPServer()) return false; if (!StartRPC()) return false; if (!StartHTTPRPC()) return false; if (gArgs.GetBoolArg(&quot;-rest&quot;, DEFAULT_REST_ENABLE) &amp;&amp; !StartREST()) return false; if (!StartHTTPServer()) return false; return true; } &nbsp; &nbsp; 这里按步骤一步一步的来。首先是调用InitHTTPServer，使用libevent api来建立http服务器，这里截取主要代码来看看，位于httpserver.cpp文件： &nbsp;&nbsp;&nbsp;&nbsp;raii_event_base base_ctr = obtain_event_base(); /* Create a new evhttp object to handle requests. */ raii_evhttp http_ctr = obtain_evhttp(base_ctr.get()); struct evhttp* http = http_ctr.get(); if (!http) { LogPrintf(&quot;couldn&#39;t create evhttp. Exiting.\\n&quot;); return false; } evhttp_set_timeout(http, gArgs.GetArg(&quot;-rpcservertimeout&quot;, DEFAULT_HTTP_SERVER_TIMEOUT)); evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE); evhttp_set_max_body_size(http, MAX_SIZE); evhttp_set_gencb(http, http_request_cb, nullptr); if (!HTTPBindAddresses(http)) { LogPrintf(&quot;Unable to bind any endpoint for RPC server\\n&quot;); return false; } LogPrint(BCLog::HTTP, &quot;Initialized HTTP server\\n&quot;); int workQueueDepth = std::max((long)gArgs.GetArg(&quot;-rpcworkqueue&quot;, DEFAULT_HTTP_WORKQUEUE), 1L); LogPrintf(&quot;HTTP: creating work queue of depth %d\\n&quot;, workQueueDepth); workQueue = new WorkQueue&lt;HTTPClosure&gt;(workQueueDepth); // transfer ownership to eventBase/HTTP via .release() eventBase = base_ctr.release(); eventHTTP = http_ctr.release(); &nbsp; &nbsp; 这里的套路和3.4节中用libevent建立http服务器的步骤基本一样，注意两点： &nbsp; &nbsp; (1) 用evhttp_set_gencb设置了http请求的处理函数：http_request_cb; &nbsp; &nbsp; (2) 创建了一个工作队列，队列里的元素类型HTTPClosure，这是一个函数对象接口类，重写了函数调用操作符，HttpWorkItem实现了此接口。 4.2.3 http请求的处理 &nbsp; &nbsp; 我们来看看当bitcoind收到一个http请求以后是如何处理的，就是http_request_cb回调，主要代码如下： &nbsp;&nbsp;&nbsp;&nbsp;// Find registered handler for prefix std::string strURI = hreq-&gt;GetURI(); std::string path; std::vector&lt;HTTPPathHandler&gt;::const_iterator i = pathHandlers.begin(); std::vector&lt;HTTPPathHandler&gt;::const_iterator iend = pathHandlers.end(); for (; i != iend; ++i) { bool match = false; if (i-&gt;exactMatch) match = (strURI == i-&gt;prefix); else match = (strURI.substr(0, i-&gt;prefix.size()) == i-&gt;prefix); if (match) { path = strURI.substr(i-&gt;prefix.size()); break; } } // Dispatch to worker thread if (i != iend) { std::unique_ptr&lt;HTTPWorkItem&gt; item(new HTTPWorkItem(std::move(hreq), path, i-&gt;handler)); assert(workQueue); if (workQueue-&gt;Enqueue(item.get())) item.release(); /* if true, queue took ownership */ else { LogPrintf(&quot;WARNING: request rejected because http work queue depth exceeded, it can be increased with the -rpcworkqueue= setting\\n&quot;); item-&gt;req-&gt;WriteReply(HTTP_INTERNAL, &quot;Work queue depth exceeded&quot;); } } else { hreq-&gt;WriteReply(HTTP_NOTFOUND); } &nbsp; &nbsp; 用一句话来概括这个函数的作用就是：将请求的url的path部分与注册过的前缀进行匹配，并生成HttpWorkItem放入到工作队列中。目前注册了两个前缀：/和/wallet/，代码在StartHttpRPC中： bool StartHTTPRPC() { LogPrint(BCLog::RPC, &quot;Starting HTTP RPC server\\n&quot;); if (!InitRPCAuthentication()) return false; RegisterHTTPHandler(&quot;/&quot;, true, HTTPReq_JSONRPC); #ifdef ENABLE_WALLET // ifdef can be removed once we switch to better endpoint support and API versioning RegisterHTTPHandler(&quot;/wallet/&quot;, false, HTTPReq_JSONRPC); #endif assert(EventBase()); httpRPCTimerInterface = MakeUnique&lt;HTTPRPCTimerInterface&gt;(EventBase()); RPCSetTimerInterface(httpRPCTimerInterface.get()); return true; } &nbsp; &nbsp; 两个前缀/和/wallet/对应的回调处理函数均为HttpReq_JSONRPC。 &nbsp; &nbsp; 之后调用StartHttpServer让工作队列运行起来： bool StartHTTPServer() { LogPrint(BCLog::HTTP, &quot;Starting HTTP server\\n&quot;); int rpcThreads = std::max((long)gArgs.GetArg(&quot;-rpcthreads&quot;, DEFAULT_HTTP_THREADS), 1L); LogPrintf(&quot;HTTP: starting %d worker threads\\n&quot;, rpcThreads); std::packaged_task&lt;bool(event_base*, evhttp*)&gt; task(ThreadHTTP); threadResult = task.get_future(); threadHTTP = std::thread(std::move(task), eventBase, eventHTTP); for (int i = 0; i &lt; rpcThreads; i++) { g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue); } return true; } &nbsp; &nbsp; 最终会调用到工作队列的run方法： void Run() { while (true) { std::unique_ptr&lt;WorkItem&gt; i; { std::unique_lock&lt;std::mutex&gt; lock(cs); while (running &amp;&amp; queue.empty()) cond.wait(lock); if (!running) break; i = std::move(queue.front()); queue.pop_front(); } (*i)(); } } &nbsp; &nbsp; 很简单，工作队列为空的时候线程阻塞等待，当收到http请求以后，解析请求并添加HttpWorkItem到队列中并唤醒线程，线程从队列头部取出一个item运行。最终将执行HttpReq_JSONRPC这个回调，这里会将JSONRPC中的rpc方法分发到服务端不同的方法中，来看看其处理： &nbsp; &nbsp; (1) 请求合法性检查及认证 &nbsp; &nbsp; 首先检查请求是否合法，http头部中的auchoization是否合法： static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &amp;) { // JSONRPC handles only POST if (req-&gt;GetRequestMethod() != HTTPRequest::POST) { req-&gt;WriteReply(HTTP_BAD_METHOD, &quot;JSONRPC server handles only POST requests&quot;); return false; } // Check authorization std::pair&lt;bool, std::string&gt; authHeader = req-&gt;GetHeader(&quot;authorization&quot;); if (!authHeader.first) { req-&gt;WriteHeader(&quot;WWW-Authenticate&quot;, WWW_AUTH_HEADER_DATA); req-&gt;WriteReply(HTTP_UNAUTHORIZED); return false; } JSONRPCRequest jreq; jreq.peerAddr = req-&gt;GetPeer().ToString(); if (!RPCAuthorized(authHeader.second, jreq.authUser)) { LogPrintf(&quot;ThreadRPCServer incorrect password attempt from %s\\n&quot;, jreq.peerAddr); /* Deter brute-forcing If this results in a DoS the user really shouldn&#39;t have their RPC port exposed. */ MilliSleep(250); req-&gt;WriteHeader(&quot;WWW-Authenticate&quot;, WWW_AUTH_HEADER_DATA); req-&gt;WriteReply(HTTP_UNAUTHORIZED); return false; } &nbsp; &nbsp; 可以看到，比特币的json rpc服务只支持POST。 &nbsp; &nbsp; (2) 读取http请求数据，将rpc请求分发到不同的函数 &nbsp;&nbsp;&nbsp;&nbsp;try { // Parse request UniValue valRequest; if (!valRequest.read(req-&gt;ReadBody())) throw JSONRPCError(RPC_PARSE_ERROR, &quot;Parse error&quot;); // Set the URI jreq.URI = req-&gt;GetURI(); std::string strReply; // singleton request if (valRequest.isObject()) { jreq.parse(valRequest); UniValue result = tableRPC.execute(jreq); // Send reply strReply = JSONRPCReply(result, NullUniValue, jreq.id); // array of requests } else if (valRequest.isArray()) strReply = JSONRPCExecBatch(jreq, valRequest.get_array()); else throw JSONRPCError(RPC_PARSE_ERROR, &quot;Top-level object parse error&quot;); req-&gt;WriteHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); req-&gt;WriteReply(HTTP_OK, strReply); &nbsp; &nbsp; 如果收到的是单个json，则tableRPC.execute执行，否则如果收到的是以数组形式的批量rpc请求，则批量执行，批量执行最终也是走tableRPC.execute()来分发，execute()执行后的结果将写入到http响应包中： UniValue CRPCTable::execute(const JSONRPCRequest &amp;request) const { // Return immediately if in warmup { LOCK(cs_rpcWarmup); if (fRPCInWarmup) throw JSONRPCError(RPC_IN_WARMUP, rpcWarmupStatus); } // Find method const CRPCCommand *pcmd = tableRPC[request.strMethod]; if (!pcmd) throw JSONRPCError(RPC_METHOD_NOT_FOUND, &quot;Method not found&quot;); g_rpcSignals.PreCommand(*pcmd); try { // Execute, convert arguments to array if necessary if (request.params.isObject()) { return pcmd-&gt;actor(transformNamedArguments(request, pcmd-&gt;argNames)); } else { return pcmd-&gt;actor(request); } } catch (const std::exception&amp; e) { throw JSONRPCError(RPC_MISC_ERROR, e.what()); } } &nbsp; &nbsp; 代码也比较容易理解，就是从根据json-rpc协议，从请求中读取method，然后根据method找到对应的CRPCCommand执行体，这些执行体就是4.2.1节中提到那几张分门别类的映射表。 &nbsp; &nbsp; 至此，比特币的json-rpc服务端的脉络我们就梳理的差不多了，整体框架并不难理解，只是封装的略微复杂一点点。 5、小结 &nbsp; &nbsp; 本文对json-rpc协议，libevent进行了简要描述，并结合源码分析了比特币的JSONRPC服务的实现。比特币核心客户端的bitcon-cli只是一个示例性质的命令行工具，如果想自己撸一个特定平台上的带有GUI的比特币钱包客户端，看完本文后相信将能信手拈来。 阅读更多","@type":"BlogPosting","url":"/2018/05/24/d884316a62cbf8875e1a67451176e310.html","headline":"比特币源码分析–RPC","dateModified":"2018-05-24T00:00:00+08:00","datePublished":"2018-05-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/05/24/d884316a62cbf8875e1a67451176e310.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码分析--RPC</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>&nbsp; &nbsp; 比特币源码为我们提供了一个比特币核心客户端，这个核心客户端也称为中本聪客户端，和SPV轻量级客户端相比，比特币核心客户端包含了比特币的方方面面。比特币核心客户端中包含一个服务端bitcoind和一个命令行工具bitcoin-cli，通过bitcoin-cli，用户可以在命令行进行诸如创建交易、发送交易，查看交易，查看区块等一系列的操作。bitcoin-cli和bitcoind是典型的C/S模式，bitcoind中实现了一个http服务器，bitcoin-cli则是一个http客户端，二者之间的传输数据遵循json-rpc协议。本文将结合源码对比特币json-rpc服务的实现进行分析。</p>
  <h1>1、比特币核心客户端架构</h1>
  <h2>1.1 示例</h2>
  <p>&nbsp; &nbsp; 先来看看bitcoin-cli的一个使用示例。我们知道区块链的一个最大特性就是能够追根溯源，任何一笔交易在验证后最终都记录到了区块链上，之后就无法篡改，现在我们通过bitcoin-cli来查看区块链上的一笔交易，这个示例来自于《精通比特币》一书：</p>
  <p>&nbsp; &nbsp; 假设我们已经下载并且编译好了比特币客户端，并且bitcoind已经运行起来了（可以在命令行输入bitciond &amp;让其在后台运行）现在我们要查看一下交易hash为9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3的详细信息，我们在命令行输入：<br></p>
  <p>&nbsp; &nbsp; $ bitcoin-cli gettransaction&nbsp;9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3<br></p>
  <p>&nbsp; &nbsp; 然后，在命令行就能看到服务器返回的json格式表示的交易的信息：</p>
  <p></p>
  <pre style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:16px;border:none;color:rgb(51,51,51);background:rgb(247,247,247);letter-spacing:.2px;"><code style="font-family:Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:.85em;border:none;color:inherit;background:0px 0px;line-height:inherit;">{
     "amount" : 0.05000000,
     "confirmations" : 0,
     "txid":"9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3",
     "time" : 1392660908,
     "timereceived" : 1392660908,
     "details" : [
    {
     "account" : "",
     "address":"1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL",
     "category" : "receive",
     "amount" : 0.05000000
    }
  ]
}</code></pre>
  <p>&nbsp; &nbsp; 可以看到这笔交易里向比特币地址1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL转移了0.05个比特币。<br></p>
  <p>&nbsp; &nbsp; 用类似的方式我们还能进行很多操作，比如创建交易，生成钱包地址，查看区块等等。而这种简单的命令背后的实现，就是本文要讲述的基于json-rpc的http服务。<br></p>
  <h2>1.2 架构&nbsp;</h2>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;bitcoin-cli通过http向bitcoind请求服务，其传输数据格式遵循json-rpc协议，整体架构如下图：</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180523203755855" alt=""></p>
  <p>&nbsp; &nbsp; 搞清楚bitcoin-cli和bicoind的实现原理以及二者之间的交互过程对后续区块链的学习会很有帮助，在搞明白这一部分的原理后，还可以比较容易的在各种平台上（比如android、ios、pc等等）实现自己定制的比特币钱包客户端，下文来一步一步的开始分析。<br></p>
  <h1>2、json-rpc介绍</h1>&nbsp; &nbsp; json-rpc是一个基于json的跨语言rpc协议，具有传输数据小，便于实现，扩展和调试等优点，目前主流的编程语言比如java，c/c++等都有json-rpc的实现框架。
  <h2>2.1 请求</h2>
  <p>&nbsp; &nbsp; json-rpc的请求非常简单，其格式如下：</p>
  <pre><code class="language-cpp">{ 
    "jsonrpc" : 2.0,
    "method" : "getinfo", 
    "params" : [""], 
    "id" : 1
}</code></pre>
  <p>&nbsp; &nbsp; jsonrpc：json-rpc的版本；</p>
  <p>&nbsp; &nbsp; method：rpc调用的方法名；<br></p>
  <p>&nbsp; &nbsp; params：方法传入的参数，没有参数传入nullptr；<br></p>
  <p>&nbsp; &nbsp; id：调用的标识符，可以为字符串，也可以为nullptr，但是不建议使用nullptr，因为容易引起混乱。<br></p>
  <h2>2.2 响应</h2>
  <pre><code class="language-cpp">{
    "jsonrpc" : 2.0,
    "result" : "info",
    "error" : null,
    "id" : 1
}
</code></pre>
  <p>&nbsp; &nbsp; jsonrpc：json-rpc版本；</p>
  <p>&nbsp; &nbsp; result：rpc调用的返回值，调用成功时不能为nullptr，调用失败必须为nullptr；<br></p>
  <p>&nbsp; &nbsp; error：调用错误时用，无错误为nullptr，有错误时返回错误对象，参见下一节；<br></p>
  <p>&nbsp; &nbsp; id：调用标识符，与调用方传入的保持一致。<br></p>
  <h2>2.3 错误对象</h2>
  <pre><code class="language-cpp">{
    "code" : 1,
    "message" : "some error.",
    "data":null
}</code></pre>
  <p>&nbsp; &nbsp; code：错误码；</p>
  <p>&nbsp; &nbsp; message：错误信息；<br></p>
  <p>&nbsp; &nbsp; data：附加信息，可以为nullptr。<br></p>
  <p>&nbsp; &nbsp; 错误码见下表：<br></p>
  <p></p>
  <table border="1" cellspacing="1" cellpadding="1">
   <tbody>
    <tr>
     <td>错误码</td>
     <td>错误</td>
     <td>含义</td>
    </tr>
    <tr>
     <td><span style="color:rgb(0,0,0);font-family:'Helvetica Neue', Helvetica, Verdana, Arial, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">-32700</span></td>
     <td>解析错误</td>
     <td>服务器收到无效json，或者解析json出错</td>
    </tr>
    <tr>
     <td><span style="color:rgb(0,0,0);font-family:'Helvetica Neue', Helvetica, Verdana, Arial, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">-32600</span></td>
     <td>无效的请求</td>
     <td>发送的json不是一个有效的请求</td>
    </tr>
    <tr>
     <td><span style="color:rgb(0,0,0);font-family:'Helvetica Neue', Helvetica, Verdana, Arial, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">-32601</span></td>
     <td>方法未找到</td>
     <td>方法不存在或不可见</td>
    </tr>
    <tr>
     <td><span style="color:rgb(0,0,0);font-family:'Helvetica Neue', Helvetica, Verdana, Arial, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">-36602</span></td>
     <td>无效的参数</td>
     <td>无效的方法参数</td>
    </tr>
    <tr>
     <td><span style="color:rgb(0,0,0);font-family:'Helvetica Neue', Helvetica, Verdana, Arial, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">-36603</span></td>
     <td>内部错误</td>
     <td>json-rpc的内部错误</td>
    </tr>
    <tr>
     <td><span style="color:rgb(0,0,0);font-family:'Helvetica Neue', Helvetica, Verdana, Arial, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">-32000到-32099</span></td>
     <td>服务器端错误</td>
     <td>保留给具体服务器实现的服务端错误</td>
    </tr>
   </tbody>
  </table>&nbsp; &nbsp; 比特币核心实现了一个基于libevent的http服务器，下文会对这个服务器的实现进行介绍。
  <h1>3、libevent库</h1>
  <h2>3.1 介绍</h2>
  <p>&nbsp; &nbsp; libevent是一个轻量级、跨平台、基于事件的高性能网络库。它封装了不同平台的io复用技术，对外暴露一致的接口。通常在编写服务器程序时所面临的一个最大问题就是高并发，libevent是解决大量并发请求的一个较好的解决方案。<br></p>
  <p>&nbsp; &nbsp; 常见的处理大量并发请求的方法：<br></p>
  <p>&nbsp; &nbsp; (1) IO复用技术<br></p>
  <p>&nbsp; &nbsp; 通过select，poll或epoll等系统api，实现io复用。<br></p>
  <p>&nbsp; &nbsp; (2) 多线程或多进程<br></p>
  <p>&nbsp; &nbsp; 多线程和多进程也可以解决大量并发请求的问题，但是无论多进程还是多线程，都存在问题：多进程不适合短连接，进程的创建和销毁开销比较大；多线程不适合短连接，大量的线程会导致较大的内存开销。<br></p>
  <p>&nbsp; &nbsp; (3) 多线程结合IO复用<br></p>
  <p>&nbsp; &nbsp; 将IO复用和多线程结合起来，这是目前解决大并发的常用方案。最常见的套路就是主线程里监听某个端口以及接受的描述符，当有读写事件产生时，将事件交给工作线程去处理。<br></p>
  <p>&nbsp; &nbsp; libevent封装了select，poll，epoll等io复用技术，同时采用时间驱动的机制：应用向libevent注册事件和相应的回调，当事件发生时libevent调用这些回调，libevent支持三种事件：网络IO，定时器和信号。<br></p>
  <h2>3.2 api</h2>
  <p>&nbsp; &nbsp; 关于libevent的实现原理本文不详细展开，有兴趣的同学可以在github自行下载源代码学习。这里只简单介绍几个核心的api。<br></p>
  <p>&nbsp; &nbsp; (1) struct event_base * event_base_new()<br></p>
  <p>&nbsp; &nbsp; 创建一个事件集，事件必须加入到事件集里才能接收到回调。<br></p>
  <p>&nbsp; &nbsp; (2) struct event event_new(struct event_base *, evutil_socket_t, short, event_callback_fn, void*)<br></p>
  <p>&nbsp; &nbsp; 创建一个事件，其参数如下：<br></p>
  <p>&nbsp; &nbsp; event_base：事件所在的事件集；<br></p>
  <p>&nbsp; &nbsp; evutil_socket_t：socket描述符；<br></p>
  <p>&nbsp; &nbsp; short：事件类型，EV_READ表示等待读事件，EV_WRITE表示写事件，EV_SIGNAL表示要等待的信号；<br></p>
  <p>&nbsp; &nbsp; event_callback_fn：事件发生时的回调函数；<br></p>
  <p>&nbsp; &nbsp; void* 回调函数的参数<br></p>
  <p>&nbsp; &nbsp; (3) int event_add(struct event *, struct timeval *)&nbsp;&nbsp;&nbsp;&nbsp;<br></p>
  <p>&nbsp; &nbsp; 添加事件。<br></p>
  <p>&nbsp; &nbsp; event：要添加的时间<br></p>
  <p>&nbsp; &nbsp; timeval：等待事件的超时值，如果为nullptr将是无限等待。<br></p>
  <p>&nbsp; &nbsp; (4) int event_del(struct event *)<br></p>
  <p>&nbsp; &nbsp; 删除事件。<br></p>
  <p>&nbsp; &nbsp; (5) struct bufferevent *bufferevent_socket_new(struct event_base *, evutil_socket_t, int options)<br></p>
  <p>&nbsp; &nbsp; 创建一个bufferevent，bufferevent封装了read，write等读写函数。<br></p>
  <p>&nbsp; &nbsp; event_base：bufferevent事件所在的事件集；<br></p>
  <p>&nbsp; &nbsp; evutil_socket_t：相关的套接字描述符；<br></p>
  <p>&nbsp; &nbsp; options：选项。<br></p>
  <p>&nbsp; &nbsp; (6) int bufferevent_enable(struct bufferevent *, short event)<br></p>
  <p>&nbsp; &nbsp; 启用bufferevent。<br></p>
  <p>&nbsp; &nbsp; (7) size_t bufferevent_read(struct bufferevent *, void *data, size_t size)<br></p>
  <p>&nbsp; &nbsp; 读取bufferevent，返回读取的字节数。<br></p>
  <p>&nbsp; &nbsp; (8) size_t bufferevent_write(struct bufferevent *, const void *data, size_t size)<br></p>
  <p>&nbsp; &nbsp; 写入bufferevent。<br></p>
  <h2>3.3 libevent示例</h2>
  <p>&nbsp; &nbsp; 这里用一个简单的示例来看看用libevent如何开发一个简单的服务器。<br></p>
  <p>&nbsp; &nbsp; (1) 首先创建套接字并在指定的端口上监听</p>
  <pre><code class="language-cpp">    int sock_fd = ::socket(AF_INET, SOCK_STREAM, 0);  
    if( sock_fd == -1 )  
        return -1;  
&nbsp;&nbsp;&nbsp;&nbsp;evutil_make_listen_socket_reuseable(sock_fd);  
    struct sockaddr_in sin;  
    sin.sin_family = AF_INET;  
    sin.sin_addr.s_addr = 0;  
    sin.sin_port = htons(port);  
    if( ::bind(sock_fd, (SA*)&amp;sin, sizeof(sin)) &lt; 0 )  
        goto error;  
    if( ::listen(sock_fd, listen_num) &lt; 0)  
        goto error;  
  &nbsp;&nbsp;evutil_make_socket_nonblocking(listener);  </code></pre>
  <p>&nbsp; &nbsp; (2) 创建一个监听客户连接请求的事件：</p>
  <pre><code class="language-cpp">    struct event* ev_listen = event_new(base, sock_fd, EV_READ | EV_PERSIST,  
                                        accept_cb, base);  
    event_add(ev_listen, NULL);  
  
    event_base_dispatch(base);</code></pre>
  <p>&nbsp; &nbsp; 当监听套接字有新连接时，事件将被触发，从而执行回调accept_cb：</p>
  <pre><code class="language-cpp">&nbsp;   void accept_cb(int fd, short events, void* arg)  
&nbsp;&nbsp;&nbsp;&nbsp;{  
    &nbsp;&nbsp;&nbsp;&nbsp;evutil_socket_t sockfd;  
  
    &nbsp;&nbsp;&nbsp;&nbsp;struct sockaddr_in client;  
    &nbsp;&nbsp;&nbsp;&nbsp;socklen_t len = sizeof(client);  
  
    &nbsp;&nbsp;&nbsp;&nbsp;sockfd = ::accept(fd, (struct sockaddr*)&amp;client, &amp;len );  
    &nbsp;&nbsp;&nbsp;&nbsp;evutil_make_socket_nonblocking(sockfd);  
  
    &nbsp;&nbsp;&nbsp;&nbsp;printf("accept a client %d\n", sockfd);  
  
    &nbsp;&nbsp;&nbsp;&nbsp;struct event_base* base = (event_base*)arg;  
  
    &nbsp;&nbsp;&nbsp;&nbsp;bufferevent* bev = bufferevent_socket_new(base, sockfd, BEV_OPT_CLOSE_ON_FREE);  
    &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_setcb(bev, socket_read_cb, NULL, event_cb, arg);  
  
    &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_enable(bev, EV_READ | EV_PERSIST);  
&nbsp;&nbsp;&nbsp;&nbsp;} </code></pre>
  <p>&nbsp; &nbsp; 创建一个bufferevent事件，将accept以后的已连接套接字与之关联，这样当套接字上有数据到来时，就会触发bufferevent事件，从而执行socket_read_cb回调：</p>
  <pre><code class="language-cpp">&nbsp;&nbsp;&nbsp;&nbsp;void socket_read_cb(bufferevent* bev, void* arg)  
&nbsp;&nbsp;&nbsp;&nbsp;{  
    &nbsp;&nbsp;&nbsp;&nbsp;char msg[4096];  
    &nbsp;&nbsp;&nbsp;&nbsp;size_t len = bufferevent_read(bev, msg, sizeof(msg));  
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg[len] = '\0';    
    &nbsp;&nbsp;&nbsp;&nbsp;char reply_msg[4096] = "recvieced msg:";  
    &nbsp;&nbsp;&nbsp;&nbsp;strcat(reply_msg + strlen(reply_msg), msg);  
    &nbsp;&nbsp;&nbsp;&nbsp;bufferevent_write(bev, reply_msg, strlen(reply_msg));  
&nbsp;&nbsp;&nbsp;&nbsp;} </code></pre>
  <p>&nbsp; &nbsp; 然后就能从bufferevent中读取到客户数据。</p>
  <h2>3.4 用libevent实现http服务器</h2>
  <p>&nbsp; &nbsp; libevent提供了http的支持，用libevent很容易实现自己的http服务，步骤如下：<br></p>
  <p>&nbsp; &nbsp; (1) 创建事件集和evhttp事件：</p>
  <pre><code class="language-cpp">struct event_base *event_base_new(void);
struct evhttp *evhttp_new(struct event_base *base);</code></pre>
  <p>&nbsp; &nbsp; (2) 绑定地址和端口</p>
  <pre><code class="language-cpp">int evhttp_bind_socket(struct evhttp *http, const char *address, ev_uint16_t port);</code></pre>
  <p>&nbsp; &nbsp; (3) 设置回调来处理http请求</p>
  <pre><code class="language-cpp">void evhttp_set_gencb(struct evhttp *http, void (*cb)(struct evhttp_request *, void *), void *arg);</code></pre>
  <p>&nbsp; &nbsp; (4) 进入事件循环</p>
  <pre><code class="language-cpp">int event_base_dispatch(struct event_base *);</code></pre>
  <p>&nbsp; &nbsp; 在下一节我们结合比特币的源码，来看看比特币中是如使用上面这些api实现http服务的，当然比特币的http服务封装的更为复杂一些。</p>
  <h1>4、比特币JSONRPC服务器的实现</h1>
  <h2>4.1、JSONRPC服务器框架</h2>
  <p>&nbsp; &nbsp; 比特币使用libevent实现了一个基于工作队列的http服务器，通过采用工作队列的方式可以提高服务器的并发处理能力。该服务器框架如下：</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018052416542674" alt=""><br></p>
  <p>&nbsp; &nbsp; 逻辑其实非常简单，在http事件循环中等待http请求的到来，当收到http请求以后，从请求数据中解析出数据并封装到HttpWorkItem，放入到工作队列里，工作队列运行起来以后会开启工作线程检查工作队列，如果队列里有数据就从对头取出并执行相应的动作。<br></p>
  <h2>4.2、JSONRPC服务器初始化</h2>
  <h3>4.2.1 注册RPC命令及处理器</h3>
  <p>&nbsp; &nbsp; JSONRPC服务器的初始化也是在bitcoind的初始化步骤中。在init.cpp的AppInitMain函数里：</p>
  <pre><code class="language-cpp">&nbsp;&nbsp;&nbsp;&nbsp;/* Register RPC commands regardless of -server setting so they will be
     * available in the GUI RPC console even if external calls are disabled.
     */
    RegisterAllCoreRPCCommands(tableRPC);
    g_wallet_init_interface.RegisterRPC(tableRPC);

    /* Start the RPC server already.  It will be started in "warmup" mode
     * and not really process calls already (but it will signify connections
     * that the server is there and will be ready later).  Warmup mode will
     * be disabled when initialisation is finished.
     */
    if (gArgs.GetBoolArg("-server", false))
    {
        uiInterface.InitMessage.connect(SetRPCWarmupStatus);
        if (!AppInitServers())
            return InitError(_("Unable to start HTTP server. See debug log for details."));
    }</code></pre>
  <p>&nbsp; &nbsp; 首先调用RegisterAllCoreRPCCommands注册比特币核心客户端所支持的所有RPC指令：</p>
  <pre><code class="language-cpp">&nbsp;&nbsp;&nbsp;&nbsp;static inline void RegisterAllCoreRPCCommands(CRPCTable &amp;t)
&nbsp;&nbsp;&nbsp;&nbsp;{
    &nbsp;&nbsp;&nbsp;&nbsp;RegisterBlockchainRPCCommands(t);
    &nbsp;&nbsp;&nbsp;&nbsp;RegisterNetRPCCommands(t);
    &nbsp;&nbsp;&nbsp;&nbsp;RegisterMiscRPCCommands(t);
    &nbsp;&nbsp;&nbsp;&nbsp;RegisterMiningRPCCommands(t);
    &nbsp;&nbsp;&nbsp;&nbsp;RegisterRawTransactionRPCCommands(t);
&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre>
  <p>&nbsp; &nbsp; 这里可以看到对RPC命令进行了分类，操作区块链的、网络相关的、挖矿相关的以及比特币交易相关的RPC命令一应俱全。这里不妨列出来，这样读者对通过客户端能做些什么事情有个大概印象：</p>
  <p>&nbsp; &nbsp; (1) 区块链相关的rpc，位于blockchain.cpp中：</p>
  <pre><code class="language-cpp">static const CRPCCommand commands[] =
{ //  category              name                      actor (function)         argNames
  //  --------------------- ------------------------  -----------------------  ----------
    { "blockchain",         "getblockchaininfo",      &amp;getblockchaininfo,      {} },
    { "blockchain",         "getchaintxstats",        &amp;getchaintxstats,        {"nblocks", "blockhash"} },
    { "blockchain",         "getblockstats",          &amp;getblockstats,          {"hash_or_height", "stats"} },
    { "blockchain",         "getbestblockhash",       &amp;getbestblockhash,       {} },
    { "blockchain",         "getblockcount",          &amp;getblockcount,          {} },
    { "blockchain",         "getblock",               &amp;getblock,               {"blockhash","verbosity|verbose"} },
    { "blockchain",         "getblockhash",           &amp;getblockhash,           {"height"} },
    { "blockchain",         "getblockheader",         &amp;getblockheader,         {"blockhash","verbose"} },
    { "blockchain",         "getchaintips",           &amp;getchaintips,           {} },
    { "blockchain",         "getdifficulty",          &amp;getdifficulty,          {} },
    { "blockchain",         "getmempoolancestors",    &amp;getmempoolancestors,    {"txid","verbose"} },
    { "blockchain",         "getmempooldescendants",  &amp;getmempooldescendants,  {"txid","verbose"} },
    { "blockchain",         "getmempoolentry",        &amp;getmempoolentry,        {"txid"} },
    { "blockchain",         "getmempoolinfo",         &amp;getmempoolinfo,         {} },
    { "blockchain",         "getrawmempool",          &amp;getrawmempool,          {"verbose"} },
    { "blockchain",         "gettxout",               &amp;gettxout,               {"txid","n","include_mempool"} },
    { "blockchain",         "gettxoutsetinfo",        &amp;gettxoutsetinfo,        {} },
    { "blockchain",         "pruneblockchain",        &amp;pruneblockchain,        {"height"} },
    { "blockchain",         "savemempool",            &amp;savemempool,            {} },
    { "blockchain",         "verifychain",            &amp;verifychain,            {"checklevel","nblocks"} },

    { "blockchain",         "preciousblock",          &amp;preciousblock,          {"blockhash"} },

    /* Not shown in help */
    { "hidden",             "invalidateblock",        &amp;invalidateblock,        {"blockhash"} },
    { "hidden",             "reconsiderblock",        &amp;reconsiderblock,        {"blockhash"} },
    { "hidden",             "waitfornewblock",        &amp;waitfornewblock,        {"timeout"} },
    { "hidden",             "waitforblock",           &amp;waitforblock,           {"blockhash","timeout"} },
    { "hidden",             "waitforblockheight",     &amp;waitforblockheight,     {"height","timeout"} },
    { "hidden",             "syncwithvalidationinterfacequeue", &amp;syncwithvalidationinterfacequeue, {} },
};</code></pre>
  <p>&nbsp; &nbsp; 所有的RPC命令以及对应的回调函数指针都封装在了CRPCCommand中，按分类、rpc方法名，回调函数，参数名封装。基本上通过方法名就能猜出其作用。</p>
  <p>&nbsp; &nbsp; (2) 网络相关的rpc，位于net.cpp中：</p>
  <pre><code class="language-cpp">static const CRPCCommand commands[] =
{ //  category              name                      actor (function)         argNames
  //  --------------------- ------------------------  -----------------------  ----------
    { "network",            "getconnectioncount",     &amp;getconnectioncount,     {} },
    { "network",            "ping",                   &amp;ping,                   {} },
    { "network",            "getpeerinfo",            &amp;getpeerinfo,            {} },
    { "network",            "addnode",                &amp;addnode,                {"node","command"} },
    { "network",            "disconnectnode",         &amp;disconnectnode,         {"address", "nodeid"} },
    { "network",            "getaddednodeinfo",       &amp;getaddednodeinfo,       {"node"} },
    { "network",            "getnettotals",           &amp;getnettotals,           {} },
    { "network",            "getnetworkinfo",         &amp;getnetworkinfo,         {} },
    { "network",            "setban",                 &amp;setban,                 {"subnet", "command", "bantime", "absolute"} },
    { "network",            "listbanned",             &amp;listbanned,             {} },
    { "network",            "clearbanned",            &amp;clearbanned,            {} },
    { "network",            "setnetworkactive",       &amp;setnetworkactive,       {"state"} },
</code></pre>
  <p>&nbsp; &nbsp; (3) 挖矿相关的rpc，位于mining.cpp中：</p>
  <pre><code class="language-cpp">static const CRPCCommand commands[] =
{ //  category              name                      actor (function)         argNames
  //  --------------------- ------------------------  -----------------------  ----------
    { "mining",             "getnetworkhashps",       &amp;getnetworkhashps,       {"nblocks","height"} },
    { "mining",             "getmininginfo",          &amp;getmininginfo,          {} },
    { "mining",             "prioritisetransaction",  &amp;prioritisetransaction,  {"txid","dummy","fee_delta"} },
    { "mining",             "getblocktemplate",       &amp;getblocktemplate,       {"template_request"} },
    { "mining",             "submitblock",            &amp;submitblock,            {"hexdata","dummy"} },


    { "generating",         "generatetoaddress",      &amp;generatetoaddress,      {"nblocks","address","maxtries"} },

    { "hidden",             "estimatefee",            &amp;estimatefee,            {} },
    { "util",               "estimatesmartfee",       &amp;estimatesmartfee,       {"conf_target", "estimate_mode"} },

    { "hidden",             "estimaterawfee",         &amp;estimaterawfee,         {"conf_target", "threshold"} },
};</code></pre>
  <p>&nbsp; &nbsp; (4) 比特币交易相关rpc，位于rawtransaction.cpp中：</p>
  <pre><code class="language-cpp">static const CRPCCommand commands[] =
{ //  category              name                            actor (function)            argNames
  //  --------------------- ------------------------        -----------------------     ----------
    { "rawtransactions",    "getrawtransaction",            &amp;getrawtransaction,         {"txid","verbose","blockhash"} },
    { "rawtransactions",    "createrawtransaction",         &amp;createrawtransaction,      {"inputs","outputs","locktime","replaceable"} },
    { "rawtransactions",    "decoderawtransaction",         &amp;decoderawtransaction,      {"hexstring","iswitness"} },
    { "rawtransactions",    "decodescript",                 &amp;decodescript,              {"hexstring"} },
    { "rawtransactions",    "sendrawtransaction",           &amp;sendrawtransaction,        {"hexstring","allowhighfees"} },
    { "rawtransactions",    "combinerawtransaction",        &amp;combinerawtransaction,     {"txs"} },
    { "rawtransactions",    "signrawtransaction",           &amp;signrawtransaction,        {"hexstring","prevtxs","privkeys","sighashtype"} }, /* uses wallet if enabled */
    { "rawtransactions",    "signrawtransactionwithkey",    &amp;signrawtransactionwithkey, {"hexstring","privkeys","prevtxs","sighashtype"} },
    { "rawtransactions",    "testmempoolaccept",            &amp;testmempoolaccept,         {"rawtxs","allowhighfees"} },

    { "blockchain",         "gettxoutproof",                &amp;gettxoutproof,             {"txids", "blockhash"} },
    { "blockchain",         "verifytxoutproof",             &amp;verifytxoutproof,          {"proof"} },
};</code></pre>
  <p>&nbsp; &nbsp; 当注册完以后，如果用户启用了-server选项，将会调用AppInitServers创建Http服务器。</p>
  <h3>4.2.2 创建http服务器</h3>
  <p>&nbsp; &nbsp; AppInitServers实现如下：</p>
  <pre><code class="language-cpp">static bool AppInitServers()
{
    RPCServer::OnStarted(&amp;OnRPCStarted);
    RPCServer::OnStopped(&amp;OnRPCStopped);
    if (!InitHTTPServer())
        return false;
    if (!StartRPC())
        return false;
    if (!StartHTTPRPC())
        return false;
    if (gArgs.GetBoolArg("-rest", DEFAULT_REST_ENABLE) &amp;&amp; !StartREST())
        return false;
    if (!StartHTTPServer())
        return false;
    return true;
}</code></pre>
  <p>&nbsp; &nbsp; 这里按步骤一步一步的来。首先是调用InitHTTPServer，使用libevent api来建立http服务器，这里截取主要代码来看看，位于httpserver.cpp文件：</p>
  <pre><code class="language-cpp">&nbsp;&nbsp;&nbsp;&nbsp;raii_event_base base_ctr = obtain_event_base();

    /* Create a new evhttp object to handle requests. */
    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());
    struct evhttp* http = http_ctr.get();
    if (!http) {
        LogPrintf("couldn't create evhttp. Exiting.\n");
        return false;
    }

    evhttp_set_timeout(http, gArgs.GetArg("-rpcservertimeout", DEFAULT_HTTP_SERVER_TIMEOUT));
    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);
    evhttp_set_max_body_size(http, MAX_SIZE);
    evhttp_set_gencb(http, http_request_cb, nullptr);

    if (!HTTPBindAddresses(http)) {
        LogPrintf("Unable to bind any endpoint for RPC server\n");
        return false;
    }

    LogPrint(BCLog::HTTP, "Initialized HTTP server\n");
    int workQueueDepth = std::max((long)gArgs.GetArg("-rpcworkqueue", DEFAULT_HTTP_WORKQUEUE), 1L);
    LogPrintf("HTTP: creating work queue of depth %d\n", workQueueDepth);

    workQueue = new WorkQueue&lt;HTTPClosure&gt;(workQueueDepth);
    // transfer ownership to eventBase/HTTP via .release()
    eventBase = base_ctr.release();
    eventHTTP = http_ctr.release();</code></pre>
  <p>&nbsp; &nbsp; 这里的套路和3.4节中用libevent建立http服务器的步骤基本一样，注意两点：</p>
  <p>&nbsp; &nbsp; (1) 用evhttp_set_gencb设置了http请求的处理函数：http_request_cb;</p>
  <p>&nbsp; &nbsp; (2) 创建了一个工作队列，队列里的元素类型HTTPClosure，这是一个函数对象接口类，重写了函数调用操作符，HttpWorkItem实现了此接口。</p>
  <h3>4.2.3 http请求的处理</h3>
  <p>&nbsp; &nbsp; 我们来看看当bitcoind收到一个http请求以后是如何处理的，就是http_request_cb回调，主要代码如下：</p>
  <pre><code class="language-cpp">&nbsp;&nbsp;&nbsp;&nbsp;// Find registered handler for prefix
    std::string strURI = hreq-&gt;GetURI();
    std::string path;
    std::vector&lt;HTTPPathHandler&gt;::const_iterator i = pathHandlers.begin();
    std::vector&lt;HTTPPathHandler&gt;::const_iterator iend = pathHandlers.end();
    for (; i != iend; ++i) {
        bool match = false;
        if (i-&gt;exactMatch)
            match = (strURI == i-&gt;prefix);
        else
            match = (strURI.substr(0, i-&gt;prefix.size()) == i-&gt;prefix);
        if (match) {
            path = strURI.substr(i-&gt;prefix.size());
            break;
        }
    }

    // Dispatch to worker thread
    if (i != iend) {
        std::unique_ptr&lt;HTTPWorkItem&gt; item(new HTTPWorkItem(std::move(hreq), path, i-&gt;handler));
        assert(workQueue);
        if (workQueue-&gt;Enqueue(item.get()))
            item.release(); /* if true, queue took ownership */
        else {
            LogPrintf("WARNING: request rejected because http work queue depth exceeded, it can be increased with the -rpcworkqueue= setting\n");
            item-&gt;req-&gt;WriteReply(HTTP_INTERNAL, "Work queue depth exceeded");
        }
    } else {
        hreq-&gt;WriteReply(HTTP_NOTFOUND);
    }</code></pre>
  <p>&nbsp; &nbsp; 用一句话来概括这个函数的作用就是：将请求的url的path部分与注册过的前缀进行匹配，并生成HttpWorkItem放入到工作队列中。目前注册了两个前缀：/和/wallet/，代码在StartHttpRPC中：</p>
  <pre><code class="language-cpp">bool StartHTTPRPC()
{
    LogPrint(BCLog::RPC, "Starting HTTP RPC server\n");
    if (!InitRPCAuthentication())
        return false;

    RegisterHTTPHandler("/", true, HTTPReq_JSONRPC);
#ifdef ENABLE_WALLET
    // ifdef can be removed once we switch to better endpoint support and API versioning
    RegisterHTTPHandler("/wallet/", false, HTTPReq_JSONRPC);
#endif
    assert(EventBase());
    httpRPCTimerInterface = MakeUnique&lt;HTTPRPCTimerInterface&gt;(EventBase());
    RPCSetTimerInterface(httpRPCTimerInterface.get());
    return true;
}
</code></pre>
  <p>&nbsp; &nbsp; 两个前缀/和/wallet/对应的回调处理函数均为HttpReq_JSONRPC。</p>
  <p>&nbsp; &nbsp; 之后调用StartHttpServer让工作队列运行起来：</p>
  <pre><code class="language-cpp">bool StartHTTPServer()
{
    LogPrint(BCLog::HTTP, "Starting HTTP server\n");
    int rpcThreads = std::max((long)gArgs.GetArg("-rpcthreads", DEFAULT_HTTP_THREADS), 1L);
    LogPrintf("HTTP: starting %d worker threads\n", rpcThreads);
    std::packaged_task&lt;bool(event_base*, evhttp*)&gt; task(ThreadHTTP);
    threadResult = task.get_future();
    threadHTTP = std::thread(std::move(task), eventBase, eventHTTP);

    for (int i = 0; i &lt; rpcThreads; i++) {
        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue);
    }
    return true;
}</code></pre>
  <p>&nbsp; &nbsp; 最终会调用到工作队列的run方法：</p>
  <pre><code class="language-cpp">void Run()
    {
        while (true) {
            std::unique_ptr&lt;WorkItem&gt; i;
            {
                std::unique_lock&lt;std::mutex&gt; lock(cs);
                while (running &amp;&amp; queue.empty())
                    cond.wait(lock);
                if (!running)
                    break;
                i = std::move(queue.front());
                queue.pop_front();
            }
            (*i)();
        }
    }</code></pre>
  <p>&nbsp; &nbsp; 很简单，工作队列为空的时候线程阻塞等待，当收到http请求以后，解析请求并添加HttpWorkItem到队列中并唤醒线程，线程从队列头部取出一个item运行。最终将执行HttpReq_JSONRPC这个回调，这里会将JSONRPC中的rpc方法分发到服务端不同的方法中，来看看其处理：</p>
  <p>&nbsp; &nbsp; (1) 请求合法性检查及认证<br></p>
  <p>&nbsp; &nbsp; 首先检查请求是否合法，http头部中的auchoization是否合法：</p>
  <pre><code class="language-cpp">static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &amp;)
{
    // JSONRPC handles only POST
    if (req-&gt;GetRequestMethod() != HTTPRequest::POST) {
        req-&gt;WriteReply(HTTP_BAD_METHOD, "JSONRPC server handles only POST requests");
        return false;
    }
    // Check authorization
    std::pair&lt;bool, std::string&gt; authHeader = req-&gt;GetHeader("authorization");
    if (!authHeader.first) {
        req-&gt;WriteHeader("WWW-Authenticate", WWW_AUTH_HEADER_DATA);
        req-&gt;WriteReply(HTTP_UNAUTHORIZED);
        return false;
    }

    JSONRPCRequest jreq;
    jreq.peerAddr = req-&gt;GetPeer().ToString();
    if (!RPCAuthorized(authHeader.second, jreq.authUser)) {
        LogPrintf("ThreadRPCServer incorrect password attempt from %s\n", jreq.peerAddr);

        /* Deter brute-forcing
           If this results in a DoS the user really
           shouldn't have their RPC port exposed. */
        MilliSleep(250);

        req-&gt;WriteHeader("WWW-Authenticate", WWW_AUTH_HEADER_DATA);
        req-&gt;WriteReply(HTTP_UNAUTHORIZED);
        return false;
    }</code></pre>
  <p>&nbsp; &nbsp; 可以看到，比特币的json rpc服务只支持POST。<br></p>
  <p>&nbsp; &nbsp; (2) 读取http请求数据，将rpc请求分发到不同的函数</p>
  <pre><code class="language-cpp">&nbsp;&nbsp;&nbsp;&nbsp;try {
        // Parse request
        UniValue valRequest;
        if (!valRequest.read(req-&gt;ReadBody()))
            throw JSONRPCError(RPC_PARSE_ERROR, "Parse error");

        // Set the URI
        jreq.URI = req-&gt;GetURI();

        std::string strReply;
        // singleton request
        if (valRequest.isObject()) {
            jreq.parse(valRequest);

            UniValue result = tableRPC.execute(jreq);

            // Send reply
            strReply = JSONRPCReply(result, NullUniValue, jreq.id);

        // array of requests
        } else if (valRequest.isArray())
            strReply = JSONRPCExecBatch(jreq, valRequest.get_array());
        else
            throw JSONRPCError(RPC_PARSE_ERROR, "Top-level object parse error");

        req-&gt;WriteHeader("Content-Type", "application/json");
        req-&gt;WriteReply(HTTP_OK, strReply);</code></pre>
  <p>&nbsp; &nbsp; 如果收到的是单个json，则tableRPC.execute执行，否则如果收到的是以数组形式的批量rpc请求，则批量执行，批量执行最终也是走tableRPC.execute()来分发，execute()执行后的结果将写入到http响应包中：</p>
  <pre><code class="language-cpp">UniValue CRPCTable::execute(const JSONRPCRequest &amp;request) const
{
    // Return immediately if in warmup
    {
        LOCK(cs_rpcWarmup);
        if (fRPCInWarmup)
            throw JSONRPCError(RPC_IN_WARMUP, rpcWarmupStatus);
    }

    // Find method
    const CRPCCommand *pcmd = tableRPC[request.strMethod];
    if (!pcmd)
        throw JSONRPCError(RPC_METHOD_NOT_FOUND, "Method not found");

    g_rpcSignals.PreCommand(*pcmd);

    try
    {
        // Execute, convert arguments to array if necessary
        if (request.params.isObject()) {
            return pcmd-&gt;actor(transformNamedArguments(request, pcmd-&gt;argNames));
        } else {
            return pcmd-&gt;actor(request);
        }
    }
    catch (const std::exception&amp; e)
    {
        throw JSONRPCError(RPC_MISC_ERROR, e.what());
    }
}</code></pre>
  <p>&nbsp; &nbsp; 代码也比较容易理解，就是从根据json-rpc协议，从请求中读取method，然后根据method找到对应的CRPCCommand执行体，这些执行体就是4.2.1节中提到那几张分门别类的映射表。</p>
  <p>&nbsp; &nbsp; 至此，比特币的json-rpc服务端的脉络我们就梳理的差不多了，整体框架并不难理解，只是封装的略微复杂一点点。<br></p>
  <h1>5、小结</h1>
  <p>&nbsp; &nbsp; 本文对json-rpc协议，libevent进行了简要描述，并结合源码分析了比特币的JSONRPC服务的实现。比特币核心客户端的bitcon-cli只是一个示例性质的命令行工具，如果想自己撸一个特定平台上的带有GUI的比特币钱包客户端，看完本文后相信将能信手拈来。<br></p>
  <p><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ztemt_sw2/article/details/80425346,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ztemt_sw2/article/details/80425346,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
