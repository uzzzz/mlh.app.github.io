<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊账户管理源码分析 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊账户管理源码分析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/TurkeyCock/article/details/80429377 这篇分析一下以太坊的账户管理。 这部分比较简单，主要分”获取钱包列表“和“订阅钱包事件”两个部分，下面分别介绍。 1. 获取钱包列表 先上一张图，理清组件间的关系： 从图中可以看出wallet、account、address这三者的区别和联系i：wallet中可能包含多个account，而每个account中包含一个address和账户所在路径（URL）。 这里有两个重要接口：Backend和Wallet。 &nbsp; Backend指的是钱包后端，目前实现了两种：KeyStore钱包和USB硬件钱包。可以看到，Backend接口有两个函数Wallets()和Subscribe()，分别对应于获取钱包列表和订阅钱包事件这两个功能。 Wallet指的是单个钱包，可以看到包含了一些打开、关闭、签名相关的接口函数。还有一些函数如Derive()是给分层确定性(HD)钱包使用的，目前KeyStore钱包后端没有实现，USB钱包需要driver支持。 这里主要分析KeyStore钱包。KeyStore实现了Backend接口，看一下相关字段： storage：实现了keyStore接口，用于访问账户关联的私钥 wallets：所有钱包的集合，每个钱包是一个keystoreWallet实例 accountCache：缓存所有账户信息，初始化时会扫描datadir/keystore目录获取所有账号 下面开始分析具体代码。以太坊启动创建Node时调用了makeAccountManager()创建账号管理器： func New(conf *Config) (*Node, error) { …… am, ephemeralKeystore, err := makeAccountManager(conf) …… } 看一下makeAccountManager()的实现，代码位于node/config.go： func makeAccountManager(conf *Config) (*accounts.Manager, string, error) { scryptN, scryptP, keydir, err := conf.AccountConfig() …… &nbsp;&nbsp;&nbsp;&nbsp;if err := os.MkdirAll(keydir, 0700); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, &quot;&quot;, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Assemble the account manager and supported backends &nbsp;&nbsp;&nbsp;&nbsp;backends := []accounts.Backend{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keystore.NewKeyStore(keydir, scryptN, scryptP), &nbsp;&nbsp;&nbsp;&nbsp;} …… return accounts.NewManager(backends...), ephemeral, nil } 首先以700权限创建keystore目录，默认位置是datadir/keystore。 然后初始化backend列表，创建KeyStore实例。看一下NewKeyStore()函数，代码位于accounts/keystore/keystore.go： func NewKeyStore(keydir string, scryptN, scryptP int) *KeyStore { &nbsp;&nbsp;&nbsp;&nbsp;keydir, _ = filepath.Abs(keydir) &nbsp;&nbsp;&nbsp;&nbsp;ks := &amp;KeyStore{storage: &amp;keyStorePassphrase{keydir, scryptN, scryptP}} &nbsp;&nbsp;&nbsp;&nbsp;ks.init(keydir) &nbsp;&nbsp;&nbsp;&nbsp;return ks } 首先初始化KeyStore实例，然后调用init()函数： func (ks *KeyStore) init(keydir string) { …… &nbsp;&nbsp;&nbsp;&nbsp;ks.cache, ks.changes = newAccountCache(keydir) …… &nbsp;&nbsp;&nbsp;&nbsp;accs := ks.cache.accounts() &nbsp;&nbsp;&nbsp;&nbsp;ks.wallets = make([]accounts.Wallet, len(accs)) &nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; len(accs); i++ { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ks.wallets[i] = &amp;keystoreWallet{account: accs[i], keystore: ks} &nbsp;&nbsp;&nbsp;&nbsp;} } 这里首先创建了一个accountCache实例，然后调用它的accounts()函数获取当前账号列表，最后填充KeyStore的钱包列表。看一下accountCache的accounts()函数，代码位于accounts/account_cache.go： func (ac *accountCache) accounts() []accounts.Account { &nbsp;&nbsp;&nbsp;&nbsp;ac.maybeReload() &nbsp;&nbsp;&nbsp;&nbsp;ac.mu.Lock() &nbsp;&nbsp;&nbsp;&nbsp;defer ac.mu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;cpy := make([]accounts.Account, len(ac.all)) &nbsp;&nbsp;&nbsp;&nbsp;copy(cpy, ac.all) &nbsp;&nbsp;&nbsp;&nbsp;return cpy } 先调用maybeReload()函数加载账号列表，然后拷贝到一个数组中返回。看一下maybeReload()函数： func (ac *accountCache) maybeReload() { …… &nbsp;&nbsp;&nbsp;&nbsp;if ac.watcher.running { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ac.mu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return // A watcher is running and will keep the cache up-to-date. &nbsp;&nbsp;&nbsp;&nbsp;} …… ac.watcher.start() &nbsp;&nbsp;&nbsp;&nbsp;ac.scanAccounts() } 这里先判断有没有watcher正在运行，其实就是检查有没有初始化过。这个watch类似于Linux中的inotify，用于监控datadir/keystore目录中有没有文件发生变化，如果有的话会及时刷新cache。 如果没有watcher正在运行，就会调用scanAccount()函数手动扫描一遍获取当前账户列表。 账户列表初始化完成以后，就调用NewManager()函数创建账号管理器了。 2. 订阅钱包事件 还是老规矩先上一张图： 可以看到这张图主要关注订阅相关的组件。 Manager中有一个updates字段，是一个channel类型，用于接收钱包相关的事件。Manager需要调用backend的Subscribe()函数把这个channel注册到后端中去。 KeyStore作为后端的实现，会把这个注册请求转发给一个Feed类型的实例。Feed会把该channel记录在案，同时返回一个feedSub类型的实例，该类型实现了Subscription接口。最后，feedSub实例会被包装进一个scopeSub类型的wrapper中，返回给Manager，Manager可以通过该接口取消事件订阅。 最中间还有一个SubscriptionScope类型，根据注释，主要是为了在大型项目中能够快速取消所有事件订阅，因此该类型包含一个map类型的字段，用于收集所有的Subscription接口实例。 下面开始分析具体代码。首先看一下NewManager()函数，代码位于accounts/manager.go func NewManager(backends ...Backend) *Manager { &nbsp;&nbsp;&nbsp;&nbsp;// Retrieve the initial list of wallets from the backends and sort by URL &nbsp;&nbsp;&nbsp;&nbsp;var wallets []Wallet &nbsp;&nbsp;&nbsp;&nbsp;for _, backend := range backends { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallets = merge(wallets, backend.Wallets()...) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Subscribe to wallet notifications from all backends &nbsp;&nbsp;&nbsp;&nbsp;updates := make(chan WalletEvent, 4*len(backends)) &nbsp;&nbsp;&nbsp;&nbsp;subs := make([]event.Subscription, len(backends)) &nbsp;&nbsp;&nbsp;&nbsp;for i, backend := range backends { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subs[i] = backend.Subscribe(updates) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Assemble the account manager and return &nbsp;&nbsp;&nbsp;&nbsp;am := &amp;Manager{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backends: make(map[reflect.Type][]Backend), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updaters: subs, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updates: updates, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallets: wallets, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quit: make(chan chan error), &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;for _, backend := range backends { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kind := reflect.TypeOf(backend) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.backends[kind] = append(am.backends[kind], backend) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;go am.update() &nbsp;&nbsp;&nbsp;&nbsp;return am } 这段代码比较长，主要做了下面几件事： &nbsp; 调用所有backend的Wallets()方法，合并成完整的钱包列表 创建channel，并调用所有backend的Subscribe()函数进行注册 初始化Manager实例，调用update()函数进入钱包事件监听循环 第一件前面已经介绍过了，看第二件，KeyStore()的Subscribe()函数： func (ks *KeyStore) Subscribe(sink chan&lt;- accounts.WalletEvent) event.Subscription { …… &nbsp;&nbsp;&nbsp;&nbsp;sub := ks.updateScope.Track(ks.updateFeed.Subscribe(sink)) &nbsp;&nbsp;&nbsp;&nbsp;// Subscribers require an active notification loop, start it &nbsp;&nbsp;&nbsp;&nbsp;if !ks.updating { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ks.updating = true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go ks.updater() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return sub } 可以看到，是先调了updateFeed的Subscribe()函数，然后再通过updateScope把结果做一层wrapper返回给调用方。先看Feed的Subscribe()函数： func (f *Feed) Subscribe(channel interface{}) Subscription { …… &nbsp;&nbsp;&nbsp;&nbsp;chanval := reflect.ValueOf(channel) …… &nbsp;&nbsp;&nbsp;&nbsp;sub := &amp;feedSub{feed: f, channel: chanval, err: make(chan error, 1)} …… &nbsp;&nbsp;&nbsp;&nbsp;// Add the select case to the inbox. &nbsp;&nbsp;&nbsp;&nbsp;// The next Send will add it to f.sendCases. &nbsp;&nbsp;&nbsp;&nbsp;cas := reflect.SelectCase{Dir: reflect.SelectSend, Chan: chanval} &nbsp;&nbsp;&nbsp;&nbsp;f.inbox = append(f.inbox, cas) &nbsp;&nbsp;&nbsp;&nbsp;return sub } 这里首先把channel封装进一个feedSub结构返回，同时在inbox数组中添加了一个SelectCase实例。这些SelectCase最终会在需要发送事件时被使用：首先以非阻塞的方式（TrySend()）向这些channel发送事件，如果没有立即成功则阻塞在这些SelectCase上，等待发送完成。具体可以参见Feed的Send()函数。 接着看一下SubscriptionScope的Track()函数： func (sc *SubscriptionScope) Track(s Subscription) Subscription { &nbsp;&nbsp;&nbsp;&nbsp;…… &nbsp;&nbsp;&nbsp;&nbsp;if sc.subs == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sc.subs = make(map[*scopeSub]struct{}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;ss := &amp;scopeSub{sc, s} &nbsp;&nbsp;&nbsp;&nbsp;sc.subs[ss] = struct{}{} &nbsp;&nbsp;&nbsp;&nbsp;return ss } 可以发现其实就是做了一层wrapper，这个scopeSub类型也是实现了Subscription接口的。这样做的目的只是为了把所有的Subscription接口实例都收集到一个map中，从而可以实现快速取消所有订阅。 再看第三件，Manager的update()函数： func (am *Manager) update() { …… &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case event := &lt;-am.updates: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Wallet event arrived, update local cache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.lock.Lock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch event.Kind { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case WalletArrived: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.wallets = merge(am.wallets, event.Wallet) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case WalletDropped: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.wallets = drop(am.wallets, event.Wallet) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.lock.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Notify any listeners of the event &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.feed.Send(event) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case errc := &lt;-am.quit: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Manager terminating, return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errc &lt;- nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } 这就是一个无限循环，监听后端发送过来的钱包事件。 细心的朋友可能发现Manager也有个feed字段，而且还有个Subscribe()函数，这个是干什么用的呢？其实是为了把钱包事件再转发给上层的订阅者，也就是Node。订阅代码参见cmd/geth/main.go中的startNode()函数： func startNode(ctx *cli.Context, stack *node.Node) { …… &nbsp;&nbsp;&nbsp;&nbsp;events := make(chan accounts.WalletEvent, 16) &nbsp;&nbsp;&nbsp;&nbsp;stack.AccountManager().Subscribe(events) …… } 至此，以太坊的账号管理机制就分析完了。 更多文章欢迎关注“鑫鑫点灯”专栏：https://blog.csdn.net/turkeycock/article/category/7669858 或关注飞久微信公众号： 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/TurkeyCock/article/details/80429377 这篇分析一下以太坊的账户管理。 这部分比较简单，主要分”获取钱包列表“和“订阅钱包事件”两个部分，下面分别介绍。 1. 获取钱包列表 先上一张图，理清组件间的关系： 从图中可以看出wallet、account、address这三者的区别和联系i：wallet中可能包含多个account，而每个account中包含一个address和账户所在路径（URL）。 这里有两个重要接口：Backend和Wallet。 &nbsp; Backend指的是钱包后端，目前实现了两种：KeyStore钱包和USB硬件钱包。可以看到，Backend接口有两个函数Wallets()和Subscribe()，分别对应于获取钱包列表和订阅钱包事件这两个功能。 Wallet指的是单个钱包，可以看到包含了一些打开、关闭、签名相关的接口函数。还有一些函数如Derive()是给分层确定性(HD)钱包使用的，目前KeyStore钱包后端没有实现，USB钱包需要driver支持。 这里主要分析KeyStore钱包。KeyStore实现了Backend接口，看一下相关字段： storage：实现了keyStore接口，用于访问账户关联的私钥 wallets：所有钱包的集合，每个钱包是一个keystoreWallet实例 accountCache：缓存所有账户信息，初始化时会扫描datadir/keystore目录获取所有账号 下面开始分析具体代码。以太坊启动创建Node时调用了makeAccountManager()创建账号管理器： func New(conf *Config) (*Node, error) { …… am, ephemeralKeystore, err := makeAccountManager(conf) …… } 看一下makeAccountManager()的实现，代码位于node/config.go： func makeAccountManager(conf *Config) (*accounts.Manager, string, error) { scryptN, scryptP, keydir, err := conf.AccountConfig() …… &nbsp;&nbsp;&nbsp;&nbsp;if err := os.MkdirAll(keydir, 0700); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, &quot;&quot;, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Assemble the account manager and supported backends &nbsp;&nbsp;&nbsp;&nbsp;backends := []accounts.Backend{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keystore.NewKeyStore(keydir, scryptN, scryptP), &nbsp;&nbsp;&nbsp;&nbsp;} …… return accounts.NewManager(backends...), ephemeral, nil } 首先以700权限创建keystore目录，默认位置是datadir/keystore。 然后初始化backend列表，创建KeyStore实例。看一下NewKeyStore()函数，代码位于accounts/keystore/keystore.go： func NewKeyStore(keydir string, scryptN, scryptP int) *KeyStore { &nbsp;&nbsp;&nbsp;&nbsp;keydir, _ = filepath.Abs(keydir) &nbsp;&nbsp;&nbsp;&nbsp;ks := &amp;KeyStore{storage: &amp;keyStorePassphrase{keydir, scryptN, scryptP}} &nbsp;&nbsp;&nbsp;&nbsp;ks.init(keydir) &nbsp;&nbsp;&nbsp;&nbsp;return ks } 首先初始化KeyStore实例，然后调用init()函数： func (ks *KeyStore) init(keydir string) { …… &nbsp;&nbsp;&nbsp;&nbsp;ks.cache, ks.changes = newAccountCache(keydir) …… &nbsp;&nbsp;&nbsp;&nbsp;accs := ks.cache.accounts() &nbsp;&nbsp;&nbsp;&nbsp;ks.wallets = make([]accounts.Wallet, len(accs)) &nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; len(accs); i++ { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ks.wallets[i] = &amp;keystoreWallet{account: accs[i], keystore: ks} &nbsp;&nbsp;&nbsp;&nbsp;} } 这里首先创建了一个accountCache实例，然后调用它的accounts()函数获取当前账号列表，最后填充KeyStore的钱包列表。看一下accountCache的accounts()函数，代码位于accounts/account_cache.go： func (ac *accountCache) accounts() []accounts.Account { &nbsp;&nbsp;&nbsp;&nbsp;ac.maybeReload() &nbsp;&nbsp;&nbsp;&nbsp;ac.mu.Lock() &nbsp;&nbsp;&nbsp;&nbsp;defer ac.mu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;cpy := make([]accounts.Account, len(ac.all)) &nbsp;&nbsp;&nbsp;&nbsp;copy(cpy, ac.all) &nbsp;&nbsp;&nbsp;&nbsp;return cpy } 先调用maybeReload()函数加载账号列表，然后拷贝到一个数组中返回。看一下maybeReload()函数： func (ac *accountCache) maybeReload() { …… &nbsp;&nbsp;&nbsp;&nbsp;if ac.watcher.running { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ac.mu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return // A watcher is running and will keep the cache up-to-date. &nbsp;&nbsp;&nbsp;&nbsp;} …… ac.watcher.start() &nbsp;&nbsp;&nbsp;&nbsp;ac.scanAccounts() } 这里先判断有没有watcher正在运行，其实就是检查有没有初始化过。这个watch类似于Linux中的inotify，用于监控datadir/keystore目录中有没有文件发生变化，如果有的话会及时刷新cache。 如果没有watcher正在运行，就会调用scanAccount()函数手动扫描一遍获取当前账户列表。 账户列表初始化完成以后，就调用NewManager()函数创建账号管理器了。 2. 订阅钱包事件 还是老规矩先上一张图： 可以看到这张图主要关注订阅相关的组件。 Manager中有一个updates字段，是一个channel类型，用于接收钱包相关的事件。Manager需要调用backend的Subscribe()函数把这个channel注册到后端中去。 KeyStore作为后端的实现，会把这个注册请求转发给一个Feed类型的实例。Feed会把该channel记录在案，同时返回一个feedSub类型的实例，该类型实现了Subscription接口。最后，feedSub实例会被包装进一个scopeSub类型的wrapper中，返回给Manager，Manager可以通过该接口取消事件订阅。 最中间还有一个SubscriptionScope类型，根据注释，主要是为了在大型项目中能够快速取消所有事件订阅，因此该类型包含一个map类型的字段，用于收集所有的Subscription接口实例。 下面开始分析具体代码。首先看一下NewManager()函数，代码位于accounts/manager.go func NewManager(backends ...Backend) *Manager { &nbsp;&nbsp;&nbsp;&nbsp;// Retrieve the initial list of wallets from the backends and sort by URL &nbsp;&nbsp;&nbsp;&nbsp;var wallets []Wallet &nbsp;&nbsp;&nbsp;&nbsp;for _, backend := range backends { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallets = merge(wallets, backend.Wallets()...) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Subscribe to wallet notifications from all backends &nbsp;&nbsp;&nbsp;&nbsp;updates := make(chan WalletEvent, 4*len(backends)) &nbsp;&nbsp;&nbsp;&nbsp;subs := make([]event.Subscription, len(backends)) &nbsp;&nbsp;&nbsp;&nbsp;for i, backend := range backends { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subs[i] = backend.Subscribe(updates) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Assemble the account manager and return &nbsp;&nbsp;&nbsp;&nbsp;am := &amp;Manager{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backends: make(map[reflect.Type][]Backend), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updaters: subs, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updates: updates, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallets: wallets, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quit: make(chan chan error), &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;for _, backend := range backends { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kind := reflect.TypeOf(backend) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.backends[kind] = append(am.backends[kind], backend) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;go am.update() &nbsp;&nbsp;&nbsp;&nbsp;return am } 这段代码比较长，主要做了下面几件事： &nbsp; 调用所有backend的Wallets()方法，合并成完整的钱包列表 创建channel，并调用所有backend的Subscribe()函数进行注册 初始化Manager实例，调用update()函数进入钱包事件监听循环 第一件前面已经介绍过了，看第二件，KeyStore()的Subscribe()函数： func (ks *KeyStore) Subscribe(sink chan&lt;- accounts.WalletEvent) event.Subscription { …… &nbsp;&nbsp;&nbsp;&nbsp;sub := ks.updateScope.Track(ks.updateFeed.Subscribe(sink)) &nbsp;&nbsp;&nbsp;&nbsp;// Subscribers require an active notification loop, start it &nbsp;&nbsp;&nbsp;&nbsp;if !ks.updating { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ks.updating = true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go ks.updater() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return sub } 可以看到，是先调了updateFeed的Subscribe()函数，然后再通过updateScope把结果做一层wrapper返回给调用方。先看Feed的Subscribe()函数： func (f *Feed) Subscribe(channel interface{}) Subscription { …… &nbsp;&nbsp;&nbsp;&nbsp;chanval := reflect.ValueOf(channel) …… &nbsp;&nbsp;&nbsp;&nbsp;sub := &amp;feedSub{feed: f, channel: chanval, err: make(chan error, 1)} …… &nbsp;&nbsp;&nbsp;&nbsp;// Add the select case to the inbox. &nbsp;&nbsp;&nbsp;&nbsp;// The next Send will add it to f.sendCases. &nbsp;&nbsp;&nbsp;&nbsp;cas := reflect.SelectCase{Dir: reflect.SelectSend, Chan: chanval} &nbsp;&nbsp;&nbsp;&nbsp;f.inbox = append(f.inbox, cas) &nbsp;&nbsp;&nbsp;&nbsp;return sub } 这里首先把channel封装进一个feedSub结构返回，同时在inbox数组中添加了一个SelectCase实例。这些SelectCase最终会在需要发送事件时被使用：首先以非阻塞的方式（TrySend()）向这些channel发送事件，如果没有立即成功则阻塞在这些SelectCase上，等待发送完成。具体可以参见Feed的Send()函数。 接着看一下SubscriptionScope的Track()函数： func (sc *SubscriptionScope) Track(s Subscription) Subscription { &nbsp;&nbsp;&nbsp;&nbsp;…… &nbsp;&nbsp;&nbsp;&nbsp;if sc.subs == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sc.subs = make(map[*scopeSub]struct{}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;ss := &amp;scopeSub{sc, s} &nbsp;&nbsp;&nbsp;&nbsp;sc.subs[ss] = struct{}{} &nbsp;&nbsp;&nbsp;&nbsp;return ss } 可以发现其实就是做了一层wrapper，这个scopeSub类型也是实现了Subscription接口的。这样做的目的只是为了把所有的Subscription接口实例都收集到一个map中，从而可以实现快速取消所有订阅。 再看第三件，Manager的update()函数： func (am *Manager) update() { …… &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case event := &lt;-am.updates: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Wallet event arrived, update local cache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.lock.Lock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch event.Kind { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case WalletArrived: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.wallets = merge(am.wallets, event.Wallet) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case WalletDropped: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.wallets = drop(am.wallets, event.Wallet) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.lock.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Notify any listeners of the event &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.feed.Send(event) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case errc := &lt;-am.quit: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Manager terminating, return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errc &lt;- nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } 这就是一个无限循环，监听后端发送过来的钱包事件。 细心的朋友可能发现Manager也有个feed字段，而且还有个Subscribe()函数，这个是干什么用的呢？其实是为了把钱包事件再转发给上层的订阅者，也就是Node。订阅代码参见cmd/geth/main.go中的startNode()函数： func startNode(ctx *cli.Context, stack *node.Node) { …… &nbsp;&nbsp;&nbsp;&nbsp;events := make(chan accounts.WalletEvent, 16) &nbsp;&nbsp;&nbsp;&nbsp;stack.AccountManager().Subscribe(events) …… } 至此，以太坊的账号管理机制就分析完了。 更多文章欢迎关注“鑫鑫点灯”专栏：https://blog.csdn.net/turkeycock/article/category/7669858 或关注飞久微信公众号： 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/TurkeyCock/article/details/80429377 这篇分析一下以太坊的账户管理。 这部分比较简单，主要分”获取钱包列表“和“订阅钱包事件”两个部分，下面分别介绍。 1. 获取钱包列表 先上一张图，理清组件间的关系： 从图中可以看出wallet、account、address这三者的区别和联系i：wallet中可能包含多个account，而每个account中包含一个address和账户所在路径（URL）。 这里有两个重要接口：Backend和Wallet。 &nbsp; Backend指的是钱包后端，目前实现了两种：KeyStore钱包和USB硬件钱包。可以看到，Backend接口有两个函数Wallets()和Subscribe()，分别对应于获取钱包列表和订阅钱包事件这两个功能。 Wallet指的是单个钱包，可以看到包含了一些打开、关闭、签名相关的接口函数。还有一些函数如Derive()是给分层确定性(HD)钱包使用的，目前KeyStore钱包后端没有实现，USB钱包需要driver支持。 这里主要分析KeyStore钱包。KeyStore实现了Backend接口，看一下相关字段： storage：实现了keyStore接口，用于访问账户关联的私钥 wallets：所有钱包的集合，每个钱包是一个keystoreWallet实例 accountCache：缓存所有账户信息，初始化时会扫描datadir/keystore目录获取所有账号 下面开始分析具体代码。以太坊启动创建Node时调用了makeAccountManager()创建账号管理器： func New(conf *Config) (*Node, error) { …… am, ephemeralKeystore, err := makeAccountManager(conf) …… } 看一下makeAccountManager()的实现，代码位于node/config.go： func makeAccountManager(conf *Config) (*accounts.Manager, string, error) { scryptN, scryptP, keydir, err := conf.AccountConfig() …… &nbsp;&nbsp;&nbsp;&nbsp;if err := os.MkdirAll(keydir, 0700); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, &quot;&quot;, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Assemble the account manager and supported backends &nbsp;&nbsp;&nbsp;&nbsp;backends := []accounts.Backend{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keystore.NewKeyStore(keydir, scryptN, scryptP), &nbsp;&nbsp;&nbsp;&nbsp;} …… return accounts.NewManager(backends...), ephemeral, nil } 首先以700权限创建keystore目录，默认位置是datadir/keystore。 然后初始化backend列表，创建KeyStore实例。看一下NewKeyStore()函数，代码位于accounts/keystore/keystore.go： func NewKeyStore(keydir string, scryptN, scryptP int) *KeyStore { &nbsp;&nbsp;&nbsp;&nbsp;keydir, _ = filepath.Abs(keydir) &nbsp;&nbsp;&nbsp;&nbsp;ks := &amp;KeyStore{storage: &amp;keyStorePassphrase{keydir, scryptN, scryptP}} &nbsp;&nbsp;&nbsp;&nbsp;ks.init(keydir) &nbsp;&nbsp;&nbsp;&nbsp;return ks } 首先初始化KeyStore实例，然后调用init()函数： func (ks *KeyStore) init(keydir string) { …… &nbsp;&nbsp;&nbsp;&nbsp;ks.cache, ks.changes = newAccountCache(keydir) …… &nbsp;&nbsp;&nbsp;&nbsp;accs := ks.cache.accounts() &nbsp;&nbsp;&nbsp;&nbsp;ks.wallets = make([]accounts.Wallet, len(accs)) &nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; len(accs); i++ { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ks.wallets[i] = &amp;keystoreWallet{account: accs[i], keystore: ks} &nbsp;&nbsp;&nbsp;&nbsp;} } 这里首先创建了一个accountCache实例，然后调用它的accounts()函数获取当前账号列表，最后填充KeyStore的钱包列表。看一下accountCache的accounts()函数，代码位于accounts/account_cache.go： func (ac *accountCache) accounts() []accounts.Account { &nbsp;&nbsp;&nbsp;&nbsp;ac.maybeReload() &nbsp;&nbsp;&nbsp;&nbsp;ac.mu.Lock() &nbsp;&nbsp;&nbsp;&nbsp;defer ac.mu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;cpy := make([]accounts.Account, len(ac.all)) &nbsp;&nbsp;&nbsp;&nbsp;copy(cpy, ac.all) &nbsp;&nbsp;&nbsp;&nbsp;return cpy } 先调用maybeReload()函数加载账号列表，然后拷贝到一个数组中返回。看一下maybeReload()函数： func (ac *accountCache) maybeReload() { …… &nbsp;&nbsp;&nbsp;&nbsp;if ac.watcher.running { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ac.mu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return // A watcher is running and will keep the cache up-to-date. &nbsp;&nbsp;&nbsp;&nbsp;} …… ac.watcher.start() &nbsp;&nbsp;&nbsp;&nbsp;ac.scanAccounts() } 这里先判断有没有watcher正在运行，其实就是检查有没有初始化过。这个watch类似于Linux中的inotify，用于监控datadir/keystore目录中有没有文件发生变化，如果有的话会及时刷新cache。 如果没有watcher正在运行，就会调用scanAccount()函数手动扫描一遍获取当前账户列表。 账户列表初始化完成以后，就调用NewManager()函数创建账号管理器了。 2. 订阅钱包事件 还是老规矩先上一张图： 可以看到这张图主要关注订阅相关的组件。 Manager中有一个updates字段，是一个channel类型，用于接收钱包相关的事件。Manager需要调用backend的Subscribe()函数把这个channel注册到后端中去。 KeyStore作为后端的实现，会把这个注册请求转发给一个Feed类型的实例。Feed会把该channel记录在案，同时返回一个feedSub类型的实例，该类型实现了Subscription接口。最后，feedSub实例会被包装进一个scopeSub类型的wrapper中，返回给Manager，Manager可以通过该接口取消事件订阅。 最中间还有一个SubscriptionScope类型，根据注释，主要是为了在大型项目中能够快速取消所有事件订阅，因此该类型包含一个map类型的字段，用于收集所有的Subscription接口实例。 下面开始分析具体代码。首先看一下NewManager()函数，代码位于accounts/manager.go func NewManager(backends ...Backend) *Manager { &nbsp;&nbsp;&nbsp;&nbsp;// Retrieve the initial list of wallets from the backends and sort by URL &nbsp;&nbsp;&nbsp;&nbsp;var wallets []Wallet &nbsp;&nbsp;&nbsp;&nbsp;for _, backend := range backends { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallets = merge(wallets, backend.Wallets()...) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Subscribe to wallet notifications from all backends &nbsp;&nbsp;&nbsp;&nbsp;updates := make(chan WalletEvent, 4*len(backends)) &nbsp;&nbsp;&nbsp;&nbsp;subs := make([]event.Subscription, len(backends)) &nbsp;&nbsp;&nbsp;&nbsp;for i, backend := range backends { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subs[i] = backend.Subscribe(updates) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Assemble the account manager and return &nbsp;&nbsp;&nbsp;&nbsp;am := &amp;Manager{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backends: make(map[reflect.Type][]Backend), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updaters: subs, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updates: updates, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallets: wallets, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quit: make(chan chan error), &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;for _, backend := range backends { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kind := reflect.TypeOf(backend) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.backends[kind] = append(am.backends[kind], backend) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;go am.update() &nbsp;&nbsp;&nbsp;&nbsp;return am } 这段代码比较长，主要做了下面几件事： &nbsp; 调用所有backend的Wallets()方法，合并成完整的钱包列表 创建channel，并调用所有backend的Subscribe()函数进行注册 初始化Manager实例，调用update()函数进入钱包事件监听循环 第一件前面已经介绍过了，看第二件，KeyStore()的Subscribe()函数： func (ks *KeyStore) Subscribe(sink chan&lt;- accounts.WalletEvent) event.Subscription { …… &nbsp;&nbsp;&nbsp;&nbsp;sub := ks.updateScope.Track(ks.updateFeed.Subscribe(sink)) &nbsp;&nbsp;&nbsp;&nbsp;// Subscribers require an active notification loop, start it &nbsp;&nbsp;&nbsp;&nbsp;if !ks.updating { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ks.updating = true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go ks.updater() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return sub } 可以看到，是先调了updateFeed的Subscribe()函数，然后再通过updateScope把结果做一层wrapper返回给调用方。先看Feed的Subscribe()函数： func (f *Feed) Subscribe(channel interface{}) Subscription { …… &nbsp;&nbsp;&nbsp;&nbsp;chanval := reflect.ValueOf(channel) …… &nbsp;&nbsp;&nbsp;&nbsp;sub := &amp;feedSub{feed: f, channel: chanval, err: make(chan error, 1)} …… &nbsp;&nbsp;&nbsp;&nbsp;// Add the select case to the inbox. &nbsp;&nbsp;&nbsp;&nbsp;// The next Send will add it to f.sendCases. &nbsp;&nbsp;&nbsp;&nbsp;cas := reflect.SelectCase{Dir: reflect.SelectSend, Chan: chanval} &nbsp;&nbsp;&nbsp;&nbsp;f.inbox = append(f.inbox, cas) &nbsp;&nbsp;&nbsp;&nbsp;return sub } 这里首先把channel封装进一个feedSub结构返回，同时在inbox数组中添加了一个SelectCase实例。这些SelectCase最终会在需要发送事件时被使用：首先以非阻塞的方式（TrySend()）向这些channel发送事件，如果没有立即成功则阻塞在这些SelectCase上，等待发送完成。具体可以参见Feed的Send()函数。 接着看一下SubscriptionScope的Track()函数： func (sc *SubscriptionScope) Track(s Subscription) Subscription { &nbsp;&nbsp;&nbsp;&nbsp;…… &nbsp;&nbsp;&nbsp;&nbsp;if sc.subs == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sc.subs = make(map[*scopeSub]struct{}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;ss := &amp;scopeSub{sc, s} &nbsp;&nbsp;&nbsp;&nbsp;sc.subs[ss] = struct{}{} &nbsp;&nbsp;&nbsp;&nbsp;return ss } 可以发现其实就是做了一层wrapper，这个scopeSub类型也是实现了Subscription接口的。这样做的目的只是为了把所有的Subscription接口实例都收集到一个map中，从而可以实现快速取消所有订阅。 再看第三件，Manager的update()函数： func (am *Manager) update() { …… &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case event := &lt;-am.updates: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Wallet event arrived, update local cache &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.lock.Lock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch event.Kind { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case WalletArrived: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.wallets = merge(am.wallets, event.Wallet) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case WalletDropped: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.wallets = drop(am.wallets, event.Wallet) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.lock.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Notify any listeners of the event &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.feed.Send(event) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case errc := &lt;-am.quit: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Manager terminating, return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errc &lt;- nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } 这就是一个无限循环，监听后端发送过来的钱包事件。 细心的朋友可能发现Manager也有个feed字段，而且还有个Subscribe()函数，这个是干什么用的呢？其实是为了把钱包事件再转发给上层的订阅者，也就是Node。订阅代码参见cmd/geth/main.go中的startNode()函数： func startNode(ctx *cli.Context, stack *node.Node) { …… &nbsp;&nbsp;&nbsp;&nbsp;events := make(chan accounts.WalletEvent, 16) &nbsp;&nbsp;&nbsp;&nbsp;stack.AccountManager().Subscribe(events) …… } 至此，以太坊的账号管理机制就分析完了。 更多文章欢迎关注“鑫鑫点灯”专栏：https://blog.csdn.net/turkeycock/article/category/7669858 或关注飞久微信公众号： 阅读更多","@type":"BlogPosting","url":"/2018/05/24/0929f1d468e4f22bcf8ee237c52acb26.html","headline":"以太坊账户管理源码分析","dateModified":"2018-05-24T00:00:00+08:00","datePublished":"2018-05-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/05/24/0929f1d468e4f22bcf8ee237c52acb26.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊账户管理源码分析</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/TurkeyCock/article/details/80429377 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-7f5a1a725b.css"> 
 <div class="htmledit_views"> 
  <p>这篇分析一下以太坊的账户管理。</p> 
  <p>这部分比较简单，主要分”获取钱包列表“和“订阅钱包事件”两个部分，下面分别介绍。</p> 
  <h1>1. 获取钱包列表</h1> 
  <p>先上一张图，理清组件间的关系：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180524085611518"></p> 
  <p>从图中可以看出wallet、account、address这三者的区别和联系i：wallet中可能包含多个account，而每个account中包含一个address和账户所在路径（URL）。</p> 
  <p>这里有两个重要接口：Backend和Wallet。</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>Backend指的是钱包后端，目前实现了两种：KeyStore钱包和USB硬件钱包。可以看到，Backend接口有两个函数Wallets()和Subscribe()，分别对应于获取钱包列表和订阅钱包事件这两个功能。</li> 
   <li>Wallet指的是单个钱包，可以看到包含了一些打开、关闭、签名相关的接口函数。还有一些函数如Derive()是给分层确定性(HD)钱包使用的，目前KeyStore钱包后端没有实现，USB钱包需要driver支持。</li> 
  </ul>
  <p>这里主要分析KeyStore钱包。KeyStore实现了Backend接口，看一下相关字段：</p> 
  <ul>
   <li>storage：实现了keyStore接口，用于访问账户关联的私钥</li> 
   <li>wallets：所有钱包的集合，每个钱包是一个keystoreWallet实例</li> 
   <li>accountCache：缓存所有账户信息，初始化时会扫描datadir/keystore目录获取所有账号</li> 
  </ul>
  <p>下面开始分析具体代码。以太坊启动创建Node时调用了makeAccountManager()创建账号管理器：</p> 
  <pre class="has">
<code class="language-plain">func New(conf *Config) (*Node, error) {
    ……

    am, ephemeralKeystore, err := makeAccountManager(conf)
    ……
}</code></pre> 
  <p>看一下makeAccountManager()的实现，代码位于node/config.go：</p> 
  <pre class="has">
<code class="language-plain">func makeAccountManager(conf *Config) (*accounts.Manager, string, error) {
    scryptN, scryptP, keydir, err := conf.AccountConfig()
    ……

&nbsp;&nbsp;&nbsp;&nbsp;if err := os.MkdirAll(keydir, 0700); err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, "", err
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Assemble the account manager and supported backends
&nbsp;&nbsp;&nbsp;&nbsp;backends := []accounts.Backend{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keystore.NewKeyStore(keydir, scryptN, scryptP),
&nbsp;&nbsp;&nbsp;&nbsp;}

    ……

    return accounts.NewManager(backends...), ephemeral, nil
}</code></pre> 
  <p>首先以700权限创建keystore目录，默认位置是datadir/keystore。</p> 
  <p>然后初始化backend列表，创建KeyStore实例。看一下NewKeyStore()函数，代码位于accounts/keystore/keystore.go：</p> 
  <pre class="has">
<code class="language-plain">func NewKeyStore(keydir string, scryptN, scryptP int) *KeyStore {
&nbsp;&nbsp;&nbsp;&nbsp;keydir, _ = filepath.Abs(keydir)
&nbsp;&nbsp;&nbsp;&nbsp;ks := &amp;KeyStore{storage: &amp;keyStorePassphrase{keydir, scryptN, scryptP}}
&nbsp;&nbsp;&nbsp;&nbsp;ks.init(keydir)
&nbsp;&nbsp;&nbsp;&nbsp;return ks
}</code></pre> 
  <p>首先初始化KeyStore实例，然后调用init()函数：</p> 
  <pre class="has">
<code class="language-plain">func (ks *KeyStore) init(keydir string) {
    ……

&nbsp;&nbsp;&nbsp;&nbsp;ks.cache, ks.changes = newAccountCache(keydir)
    ……

&nbsp;&nbsp;&nbsp;&nbsp;accs := ks.cache.accounts()
&nbsp;&nbsp;&nbsp;&nbsp;ks.wallets = make([]accounts.Wallet, len(accs))
&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; len(accs); i++ {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ks.wallets[i] = &amp;keystoreWallet{account: accs[i], keystore: ks}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</code></pre> 
  <p>这里首先创建了一个accountCache实例，然后调用它的accounts()函数获取当前账号列表，最后填充KeyStore的钱包列表。看一下accountCache的accounts()函数，代码位于accounts/account_cache.go：</p> 
  <pre class="has">
<code class="language-plain">func (ac *accountCache) accounts() []accounts.Account {
&nbsp;&nbsp;&nbsp;&nbsp;ac.maybeReload()
&nbsp;&nbsp;&nbsp;&nbsp;ac.mu.Lock()
&nbsp;&nbsp;&nbsp;&nbsp;defer ac.mu.Unlock()
&nbsp;&nbsp;&nbsp;&nbsp;cpy := make([]accounts.Account, len(ac.all))
&nbsp;&nbsp;&nbsp;&nbsp;copy(cpy, ac.all)
&nbsp;&nbsp;&nbsp;&nbsp;return cpy
}</code></pre> 
  <p>先调用maybeReload()函数加载账号列表，然后拷贝到一个数组中返回。看一下maybeReload()函数：</p> 
  <pre class="has">
<code class="language-plain">func (ac *accountCache) maybeReload() {
    ……

&nbsp;&nbsp;&nbsp;&nbsp;if ac.watcher.running {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ac.mu.Unlock()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return // A watcher is running and will keep the cache up-to-date.
&nbsp;&nbsp;&nbsp;&nbsp;}

    ……

    ac.watcher.start()
&nbsp;&nbsp;&nbsp;&nbsp;ac.scanAccounts()
}</code></pre> 
  <p>这里先判断有没有watcher正在运行，其实就是检查有没有初始化过。这个watch类似于Linux中的inotify，用于监控datadir/keystore目录中有没有文件发生变化，如果有的话会及时刷新cache。</p> 
  <p>如果没有watcher正在运行，就会调用scanAccount()函数手动扫描一遍获取当前账户列表。</p> 
  <p>账户列表初始化完成以后，就调用NewManager()函数创建账号管理器了。</p> 
  <h1>2. 订阅钱包事件</h1> 
  <p>还是老规矩先上一张图：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180524085932350"></p> 
  <p>可以看到这张图主要关注订阅相关的组件。</p> 
  <p>Manager中有一个updates字段，是一个channel类型，用于接收钱包相关的事件。Manager需要调用backend的Subscribe()函数把这个channel注册到后端中去。</p> 
  <p>KeyStore作为后端的实现，会把这个注册请求转发给一个Feed类型的实例。Feed会把该channel记录在案，同时返回一个feedSub类型的实例，该类型实现了Subscription接口。最后，feedSub实例会被包装进一个scopeSub类型的wrapper中，返回给Manager，Manager可以通过该接口取消事件订阅。</p> 
  <p>最中间还有一个SubscriptionScope类型，根据注释，主要是为了在大型项目中能够快速取消所有事件订阅，因此该类型包含一个map类型的字段，用于收集所有的Subscription接口实例。</p> 
  <p>下面开始分析具体代码。首先看一下NewManager()函数，代码位于accounts/manager.go</p> 
  <pre class="has">
<code class="language-plain">func NewManager(backends ...Backend) *Manager {
&nbsp;&nbsp;&nbsp;&nbsp;// Retrieve the initial list of wallets from the backends and sort by URL
&nbsp;&nbsp;&nbsp;&nbsp;var wallets []Wallet
&nbsp;&nbsp;&nbsp;&nbsp;for _, backend := range backends {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallets = merge(wallets, backend.Wallets()...)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Subscribe to wallet notifications from all backends
&nbsp;&nbsp;&nbsp;&nbsp;updates := make(chan WalletEvent, 4*len(backends))

&nbsp;&nbsp;&nbsp;&nbsp;subs := make([]event.Subscription, len(backends))
&nbsp;&nbsp;&nbsp;&nbsp;for i, backend := range backends {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subs[i] = backend.Subscribe(updates)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Assemble the account manager and return
&nbsp;&nbsp;&nbsp;&nbsp;am := &amp;Manager{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backends: make(map[reflect.Type][]Backend),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updaters: subs,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updates:  updates,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallets:  wallets,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quit:     make(chan chan error),
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;for _, backend := range backends {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kind := reflect.TypeOf(backend)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.backends[kind] = append(am.backends[kind], backend)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;go am.update()

&nbsp;&nbsp;&nbsp;&nbsp;return am
}</code></pre> 
  <p>这段代码比较长，主要做了下面几件事：</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>调用所有backend的Wallets()方法，合并成完整的钱包列表</li> 
   <li>创建channel，并调用所有backend的Subscribe()函数进行注册</li> 
   <li>初始化Manager实例，调用update()函数进入钱包事件监听循环</li> 
  </ul>
  <p>第一件前面已经介绍过了，看第二件，KeyStore()的Subscribe()函数：</p> 
  <pre class="has">
<code class="language-plain">func (ks *KeyStore) Subscribe(sink chan&lt;- accounts.WalletEvent) event.Subscription {
    ……

&nbsp;&nbsp;&nbsp;&nbsp;sub := ks.updateScope.Track(ks.updateFeed.Subscribe(sink))

&nbsp;&nbsp;&nbsp;&nbsp;// Subscribers require an active notification loop, start it
&nbsp;&nbsp;&nbsp;&nbsp;if !ks.updating {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ks.updating = true
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go ks.updater()
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return sub
}</code></pre> 
  <p>可以看到，是先调了updateFeed的Subscribe()函数，然后再通过updateScope把结果做一层wrapper返回给调用方。先看Feed的Subscribe()函数：</p> 
  <pre class="has">
<code class="language-plain">func (f *Feed) Subscribe(channel interface{}) Subscription {
    ……

&nbsp;&nbsp;&nbsp;&nbsp;chanval := reflect.ValueOf(channel)
    ……

&nbsp;&nbsp;&nbsp;&nbsp;sub := &amp;feedSub{feed: f, channel: chanval, err: make(chan error, 1)}
    ……

&nbsp;&nbsp;&nbsp;&nbsp;// Add the select case to the inbox.
&nbsp;&nbsp;&nbsp;&nbsp;// The next Send will add it to f.sendCases.
&nbsp;&nbsp;&nbsp;&nbsp;cas := reflect.SelectCase{Dir: reflect.SelectSend, Chan: chanval}
&nbsp;&nbsp;&nbsp;&nbsp;f.inbox = append(f.inbox, cas)
&nbsp;&nbsp;&nbsp;&nbsp;return sub
}</code></pre> 
  <p>这里首先把channel封装进一个feedSub结构返回，同时在inbox数组中添加了一个SelectCase实例。这些SelectCase最终会在需要发送事件时被使用：首先以非阻塞的方式（TrySend()）向这些channel发送事件，如果没有立即成功则阻塞在这些SelectCase上，等待发送完成。具体可以参见Feed的Send()函数。</p> 
  <p>接着看一下SubscriptionScope的Track()函数：</p> 
  <pre class="has">
<code class="language-plain">func (sc *SubscriptionScope) Track(s Subscription) Subscription {
&nbsp;&nbsp;&nbsp;&nbsp;……

&nbsp;&nbsp;&nbsp;&nbsp;if sc.subs == nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sc.subs = make(map[*scopeSub]struct{})
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ss := &amp;scopeSub{sc, s}
&nbsp;&nbsp;&nbsp;&nbsp;sc.subs[ss] = struct{}{}
&nbsp;&nbsp;&nbsp;&nbsp;return ss
}</code></pre> 
  <p>可以发现其实就是做了一层wrapper，这个scopeSub类型也是实现了Subscription接口的。这样做的目的只是为了把所有的Subscription接口实例都收集到一个map中，从而可以实现快速取消所有订阅。</p> 
  <p>再看第三件，Manager的update()函数：</p> 
  <pre class="has">
<code class="language-plain">func (am *Manager) update() {
    ……

 &nbsp;&nbsp;&nbsp;&nbsp;for {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case event := &lt;-am.updates:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Wallet event arrived, update local cache
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.lock.Lock()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch event.Kind {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case WalletArrived:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.wallets = merge(am.wallets, event.Wallet)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case WalletDropped:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.wallets = drop(am.wallets, event.Wallet)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.lock.Unlock()

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Notify any listeners of the event
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;am.feed.Send(event)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case errc := &lt;-am.quit:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Manager terminating, return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errc &lt;- nil
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</code></pre> 
  <p>这就是一个无限循环，监听后端发送过来的钱包事件。</p> 
  <p>细心的朋友可能发现Manager也有个feed字段，而且还有个Subscribe()函数，这个是干什么用的呢？其实是为了把钱包事件再转发给上层的订阅者，也就是Node。订阅代码参见cmd/geth/main.go中的startNode()函数：</p> 
  <pre class="has">
<code class="language-plain">func startNode(ctx *cli.Context, stack *node.Node) {
    ……

&nbsp;&nbsp;&nbsp;&nbsp;events := make(chan accounts.WalletEvent, 16)
&nbsp;&nbsp;&nbsp;&nbsp;stack.AccountManager().Subscribe(events)
    ……
}</code></pre> 
  <p>至此，以太坊的账号管理机制就分析完了。</p> 
  <p><span style="color:#ff6666;">更多文章欢迎关注“鑫鑫点灯”专栏：</span><a href="https://blog.csdn.net/turkeycock/article/category/7669858" rel="nofollow">https://blog.csdn.net/turkeycock/article/category/7669858</a></p> 
  <p><span style="color:#86ca5e;">或关注飞久微信公众号：</span></p> 
  <p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181030103013857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R1cmtleUNvY2s=,size_16,color_FFFFFF,t_70"></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/TurkeyCock/article/details/80429377,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/TurkeyCock/article/details/80429377,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
