<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>JAVA中使用springBoot和Ehcache3.X无xml配置和xml配置 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="JAVA中使用springBoot和Ehcache3.X无xml配置和xml配置" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/Gentlemike/article/details/80403967 ehcache3.3官方文档地址 我用的是springBoot和Ehcache3.3 1.在maven的pom.xml导入ehcache3.3.0依赖 &lt;!-- Ehcache 缓存--&gt; &lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; 一、无xml版本配置 1.创建一个EhcacheUtil.java类用来保存配置 import org.ehcache.Cache; import org.ehcache.CacheManager; import org.ehcache.config.CacheConfiguration; import org.ehcache.config.builders.CacheConfigurationBuilder; import org.ehcache.config.builders.CacheManagerBuilder; import org.ehcache.config.builders.ResourcePoolsBuilder; import org.ehcache.config.units.EntryUnit; import org.ehcache.config.units.MemoryUnit; import org.ehcache.expiry.Duration; import org.ehcache.expiry.Expirations; import org.springframework.cache.annotation.EnableCaching; import org.springframework.context.annotation.Configuration; import java.io.FileNotFoundException; import java.util.concurrent.TimeUnit; /** * ClassName: EhcacheConfig * Description: Ehcache配置 * Author: johnnybro@qq.com * Date: 2018/05/18 14:30:36 */ @Configuration @EnableCaching public class EhcacheUtil { private static CacheManager cacheManager; /** * 初始化Ehcache缓存对象 */ public EhcacheUtil() { System.out.println(&quot;[Ehcache配置初始化&lt;开始&gt;]&quot;); // 配置默认缓存属性 CacheConfiguration&lt;String, String&gt; cacheConfiguration = CacheConfigurationBuilder.newCacheConfigurationBuilder( // 缓存数据K和V的数值类型 // 在ehcache3.3中必须指定缓存键值类型,如果使用中类型与配置的不同,会报类转换异常 String.class, String.class, ResourcePoolsBuilder .newResourcePoolsBuilder() //设置缓存堆容纳元素个数(JVM内存空间)超出个数后会存到offheap中 .heap(1000L,EntryUnit.ENTRIES) //设置堆外储存大小(内存存储) 超出offheap的大小会淘汰规则被淘汰 .offheap(100L, MemoryUnit.MB) // 配置磁盘持久化储存(硬盘存储)用来持久化到磁盘,这里设置为false不启用 .disk(500L, MemoryUnit.MB, false) ).withExpiry(Expirations.timeToLiveExpiration( //设置缓存过期时间 Duration.of(30L, TimeUnit.SECONDS)) ).withExpiry(Expirations.timeToIdleExpiration( //设置被访问后过期时间(同时设置和TTL和TTI之后会被覆盖,这里TTI生效,之前版本xml配置后是两个配置了都会生效) Duration.of(60L, TimeUnit.SECONDS)) ) // 缓存淘汰策略 默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 // 这块还没看 /*.withEvictionAdvisor( new OddKeysEvictionAdvisor&lt;Long, String&gt;())*/ ).build(); // CacheManager管理缓存 cacheManager = CacheManagerBuilder.newCacheManagerBuilder() // 硬盘持久化地址 .with(CacheManagerBuilder.persistence(&quot;D:/ehcacheData&quot;)) // 设置一个默认缓存配置 .withCache(&quot;defaultCache&quot;, cacheConfiguration) //创建之后立即初始化 .build(true); System.out.println(&quot;[Ehcache配置初始化&lt;完成&gt;]&quot;); } ｝ 2.在main方法中进行测试 1）测试heap配置 修改配置 //设置缓存堆容纳元素个数(JVM内存空间) .heap(1L, EntryUnit.ENTRIES) //设置堆外储存大小(内存存储) //.offheap(100L, MemoryUnit.MB) // 配置磁盘持久化储存(硬盘存储) //.disk(500L, MemoryUnit.MB, false) public static void main(String[] args) throws InterruptedException, FileNotFoundException { // 初始化Ehcache对象 new EhcacheUtil(); // 获取初始化的缓存对象 Cache&lt;String, String&gt; mineCache = cacheManager.getCache(&quot;defaultCache&quot;, String.class, String.class); // 创建测试内容 StringBuilder strTemp = new StringBuilder(&quot;测试&quot;); // 存入第1条数据 mineCache.put(&quot;key&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); strTemp = new StringBuilder(&quot;测试2&quot;); // 存入第2条数据 mineCache.put(&quot;key2&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key2:&quot; + mineCache.get(&quot;key2&quot;)); // 取出并输出第一条数据,因为heap的个数设置为1所以当存入第2条数据时,第一条会被淘汰 System.out.println(&quot;key1:&quot; + mineCache.get(&quot;key1&quot;)); // 关闭ehcache cacheManager.close(); } //控制台输出的结果 Connected to the target VM, address: &#39;127.0.0.1:61909&#39;, transport: &#39;socket&#39; [Ehcache配置初始化&lt;开始&gt;] 13:41:55.435 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - Starting 17 Services... 13:41:55.465 [main] DEBUG org.ehcache.impl.persistence.DefaultLocalPersistenceService - RootDirectory Locked 13:41:55.475 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully started, 17 Services in 40ms 13:41:55.485 [main] DEBUG org.ehcache.core.EhcacheManager - Creating Cache &#39;defaultCache&#39; in EhcacheManager. 13:41:55.485 [main] DEBUG org.ehcache.impl.internal.spi.serialization.DefaultSerializationProvider - Serializer for &lt;java.lang.String&gt; : org.ehcache.impl.serialization.StringSerializer@52e677af 13:41:55.485 [main] DEBUG org.ehcache.impl.internal.spi.serialization.DefaultSerializationProvider - Serializer for &lt;java.lang.String&gt; : org.ehcache.impl.serialization.StringSerializer@7d68ef40 13:41:55.495 [main] DEBUG org.ehcache.impl.internal.spi.copy.DefaultCopyProvider - Copier for &lt;java.lang.String&gt; : org.ehcache.impl.copy.IdentityCopier@475e586c 13:41:55.495 [main] DEBUG org.ehcache.impl.internal.spi.copy.DefaultCopyProvider - Copier for &lt;java.lang.String&gt; : org.ehcache.impl.copy.IdentityCopier@657c8ad9 13:41:55.685 [main] DEBUG class org.ehcache.core.Ehcache-defaultCache - Initialize successful. 13:41:55.685 [main] INFO org.ehcache.core.EhcacheManager - Cache &#39;defaultCache&#39; created in EhcacheManager. 13:41:55.685 [main] DEBUG org.ehcache.core.EhcacheManager - Initialize successful. [Ehcache配置初始化&lt;完成&gt;] key:测试 key2:测试2 key1:null Disconnected from the target VM, address: &#39;127.0.0.1:61909&#39;, transport: &#39;socket&#39; 13:41:55.695 [main] DEBUG class org.ehcache.core.Ehcache-defaultCache - Close successful. 13:41:55.695 [main] INFO org.ehcache.core.EhcacheManager - Cache &#39;defaultCache&#39; removed from EhcacheManager. 13:41:55.695 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - Stopping 17 Services... 13:41:55.695 [main] DEBUG org.ehcache.impl.persistence.DefaultLocalPersistenceService - RootDirectory Unlocked 13:41:55.695 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully stopped, 17 Services in 0ms 13:41:55.695 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful. Process finished with exit code 0 2）测试heap和offheap 设置heap个数为1,offheap大小为1MB(offheap最小为1MB) // 测试heap容纳个数和offheap,将配置中其它无关配置注释掉 // 设置缓存堆容纳元素个数(JVM内存空间) .heap(1L, EntryUnit.ENTRIES) // 设置堆外储存大小(内存存储) .offheap(1L, MemoryUnit.MB) // 配置磁盘持久化储存(硬盘存储) //.disk(500L, MemoryUnit.MB, false) public static void main(String[] args) throws InterruptedException, FileNotFoundException { // 初始化Ehcache对象 new EhcacheUtil(); // 获取初始化的缓存对象 Cache&lt;String, String&gt; mineCache = cacheManager.getCache(&quot;defaultCache&quot;, String.class, String.class); // 创建测试内容 StringBuilder strTemp = new StringBuilder(&quot;测试&quot;); strTemp.append(&quot;测试一二三四五六七八九十&quot;); System.out.println(&quot;大小为：&quot; + strTemp.toString().getBytes() + &quot;Byte&quot;); // 存入第1条数据 mineCache.put(&quot;key&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); strTemp = new StringBuilder(&quot;测试2&quot;); // 存入第2条数据 mineCache.put(&quot;key2&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key2:&quot; + mineCache.get(&quot;key2&quot;)); // 取出并输出第一条数据,由于offheap的个存在所以当存入第2条数据时,第一条会被存储到offheap中而不会被淘汰 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); // 关闭ehcache cacheManager.close(); } 由于控制台日志太多下面只截取部分有用日志 [Ehcache配置初始化&lt;开始&gt;] [Ehcache配置初始化&lt;完成&gt;] key:测试测试一二三四五六七八九十 key2:测试2 key:测试测试一二三四五六七八九十 14:01:41.686 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful. Process finished with exit code 0 设置第一条记录的大小大于offheap 的大小 public static void main(String[] args) throws InterruptedException, FileNotFoundException { // 初始化Ehcache对象 new EhcacheUtil(); // 获取初始化的缓存对象 Cache&lt;String, String&gt; mineCache = cacheManager.getCache(&quot;defaultCache&quot;, String.class, String.class); // 创建测试内容 StringBuilder strTemp = new StringBuilder(&quot;测试&quot;); while(strTemp.toString().getBytes().length &lt;= 1024*1024){ strTemp.append(&quot;测试一二三四五六七八九十&quot;); } System.out.println(&quot;大小为：&quot; + strTemp.toString().getBytes().length + &quot; Byte,1MB大小为:&quot; + 1024*1024 + &quot; Byte&quot;); // 存入第1条数据 mineCache.put(&quot;key&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); strTemp = new StringBuilder(&quot;测试2&quot;); // 存入第2条数据 mineCache.put(&quot;key2&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key2:&quot; + mineCache.get(&quot;key2&quot;)); // 取出并输出第一条数据,由于offheap的个存在所以当存入第2条数据时,第一条会被存储到offheap中,但是第一条数据的大小大于offheap所以会被淘汰 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); // 关闭ehcache cacheManager.close(); } [Ehcache配置初始化&lt;开始&gt;] [Ehcache配置初始化&lt;完成&gt;] 大小为：1048578 Byte,1MB大小为:1048576 Byte 14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 1020.0KB to 1022.0KB [occupation=0.0] 14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Allocating a 2KB buffer from chunk 0 &amp;2048 14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 1022.0KB to 1MB [occupation=0.0] 14:06:50.967 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expansion from 1046528 failed 14:06:50.977 [main] INFO org.ehcache.core.internal.resilience.LoggingRobustResilienceStrategy - Ehcache key key recovered from org.ehcache.core.spi.store.StoreAccessException: The element with key &#39;key&#39; is too large to be stored in this offheap store. at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.computeWithRetry(AbstractOffHeapStore.java:1101) at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.put(AbstractOffHeapStore.java:316) at org.ehcache.impl.internal.store.tiering.TieredStore.put(TieredStore.java:138) at org.ehcache.core.Ehcache.put(Ehcache.java:198) at com.linewell.egov.config.EhcacheUtil.main(EhcacheUtil.java:157) Caused by: org.terracotta.offheapstore.exceptions.OversizeMappingException: Storage Engine and Eviction Failed - Empty Map Storage Engine : OffHeapBufferStorageEngine allocated=1022.0KB occupied=0B Storage Area: OffHeapStorageArea 511 2KB pages Allocator: org.terracotta.offheapstore.storage.allocator.IntegerBestFitAllocator@229c6181 Page Source: UpfrontAllocatingPageSource Chunk 1 Size : 1MB Free Allocator : PowerOfTwoAllocator: Occupied 1022.5KB [Largest Available Area 1KB] Victim Allocator : PowerOfTwoAllocator: Occupied 512B [Largest Available Area 512KB] at org.terracotta.offheapstore.AbstractOffHeapClockCache.storageEngineFailure(AbstractOffHeapClockCache.java:84) at org.terracotta.offheapstore.OffHeapHashMap.writeEntry(OffHeapHashMap.java:689) at org.terracotta.offheapstore.OffHeapHashMap.computeWithMetadata(OffHeapHashMap.java:1947) at org.terracotta.offheapstore.AbstractLockedOffHeapHashMap.computeWithMetadata(AbstractLockedOffHeapHashMap.java:582) at org.terracotta.offheapstore.concurrent.AbstractConcurrentOffHeapMap.computeWithMetadata(AbstractConcurrentOffHeapMap.java:743) at org.ehcache.impl.internal.store.offheap.EhcacheConcurrentOffHeapClockCache.compute(EhcacheConcurrentOffHeapClockCache.java:152) at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.computeWithRetry(AbstractOffHeapStore.java:1099) ... 4 common frames omitted key:null 14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Freeing a 2KB buffer from chunk 0 &amp;2048 14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Allocating a 2KB buffer from chunk 0 &amp;1046528 14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 2KB to 4KB [occupation=0.0] key2:测试2 key:null Disconnected from the target VM, address: &#39;127.0.0.1:63287&#39;, transport: &#39;socket&#39; 14:06:56.191 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully stopped, 17 Services in 10ms 14:06:56.191 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful. Process finished with exit code 0 关于TTL和TTI的测试这里就不贴代码了得出结论是TTL和TTI同时配置时，二者不可共存后面的配置会覆盖前面的，XML配置同理 二、xml版本配置 在resource文件夹下创建ehcache.xml文件 &lt;config xmlns:xsi=&#39;http://www.w3.org/2001/XMLSchema-instance&#39; xmlns=&#39;http://www.ehcache.org/v3&#39; xsi:schemaLocation=&quot;http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core.xsd&quot;&gt; &lt;!-- 持久化路径 --&gt; &lt;persistence directory=&quot;D:/ehcacheData&quot;/&gt; &lt;!-- 缓存模版,此处为了显示其用法,也可以不用模版直接在cache中配置与模版参数相同 --&gt; &lt;cache-template name=&quot;template&quot;&gt; &lt;key-type&gt;java.lang.String&lt;/key-type&gt; &lt;value-type&gt;java.lang.String&lt;/value-type&gt; &lt;expiry&gt; &lt;!-- 单位默认为秒当用秒作单位时,可以不填--&gt; &lt;ttl unit=&quot;hours&quot;&gt;1&lt;/ttl&gt; &lt;/expiry&gt; &lt;resources&gt; &lt;!-- 单位默认为entries当用entries作单位时,可以不填--&gt; &lt;heap&gt;1&lt;/heap&gt; &lt;offheap unit=&quot;MB&quot;&gt;1&lt;/offheap&gt; &lt;!-- persistent 默认为false可以不填--&gt; &lt;disk unit=&quot;MB&quot;&gt;20&lt;/disk&gt; &lt;/resources&gt; &lt;/cache-template&gt; &lt;!-- 缓存对象,如果使用了模版会覆盖模版中的内容,使用uses-template=&quot;&quot;来引用模版 --&gt; &lt;cache alias=&quot;defaultCache&quot; uses-template=&quot;template&quot;&gt; &lt;expiry&gt; &lt;!--此处会覆盖模版中的(TTL)配置 --&gt; &lt;tti&gt;60&lt;/tti&gt; &lt;/expiry&gt; &lt;resources&gt; &lt;disk unit=&quot;MB&quot; persistent=&quot;true&quot;&gt; 500&lt;/disk&gt; &lt;/resources&gt; &lt;!-- 没有研究这块,暂时先不管 &lt;eviction-advisor&gt;&lt;/eviction-advisor&gt; --&gt; &lt;/cache&gt; &lt;/config&gt; public EhcacheUtil() { System.out.println(&quot;[Ehcache配置初始化&lt;开始&gt;]&quot;); // 配置默认缓存属性 cacheManager = CacheManagerBuilder.newCacheManager(new XmlConfiguration(getClass().getResource(&quot;/ehcache.xml&quot;))); cacheManager.init(); System.out.println(&quot;[Ehcache配置初始化&lt;完成&gt;]&quot;); } 应该也可以这样配置到application.yml中,可自行尝试 spring: cache: ehcache: config: ehcache.xml // ehcache3.5.2中缓存过期策略有所更新旧的方法参数已经过期新参数设置可以参考下面 // 过期策略设置为不过期 .withExpiry(ExpiryPolicy.NO_EXPIRY) 如需转载求标明出处,&nbsp;https://blog.csdn.net/Gentlemike/article/details/80403967" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/Gentlemike/article/details/80403967 ehcache3.3官方文档地址 我用的是springBoot和Ehcache3.3 1.在maven的pom.xml导入ehcache3.3.0依赖 &lt;!-- Ehcache 缓存--&gt; &lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; 一、无xml版本配置 1.创建一个EhcacheUtil.java类用来保存配置 import org.ehcache.Cache; import org.ehcache.CacheManager; import org.ehcache.config.CacheConfiguration; import org.ehcache.config.builders.CacheConfigurationBuilder; import org.ehcache.config.builders.CacheManagerBuilder; import org.ehcache.config.builders.ResourcePoolsBuilder; import org.ehcache.config.units.EntryUnit; import org.ehcache.config.units.MemoryUnit; import org.ehcache.expiry.Duration; import org.ehcache.expiry.Expirations; import org.springframework.cache.annotation.EnableCaching; import org.springframework.context.annotation.Configuration; import java.io.FileNotFoundException; import java.util.concurrent.TimeUnit; /** * ClassName: EhcacheConfig * Description: Ehcache配置 * Author: johnnybro@qq.com * Date: 2018/05/18 14:30:36 */ @Configuration @EnableCaching public class EhcacheUtil { private static CacheManager cacheManager; /** * 初始化Ehcache缓存对象 */ public EhcacheUtil() { System.out.println(&quot;[Ehcache配置初始化&lt;开始&gt;]&quot;); // 配置默认缓存属性 CacheConfiguration&lt;String, String&gt; cacheConfiguration = CacheConfigurationBuilder.newCacheConfigurationBuilder( // 缓存数据K和V的数值类型 // 在ehcache3.3中必须指定缓存键值类型,如果使用中类型与配置的不同,会报类转换异常 String.class, String.class, ResourcePoolsBuilder .newResourcePoolsBuilder() //设置缓存堆容纳元素个数(JVM内存空间)超出个数后会存到offheap中 .heap(1000L,EntryUnit.ENTRIES) //设置堆外储存大小(内存存储) 超出offheap的大小会淘汰规则被淘汰 .offheap(100L, MemoryUnit.MB) // 配置磁盘持久化储存(硬盘存储)用来持久化到磁盘,这里设置为false不启用 .disk(500L, MemoryUnit.MB, false) ).withExpiry(Expirations.timeToLiveExpiration( //设置缓存过期时间 Duration.of(30L, TimeUnit.SECONDS)) ).withExpiry(Expirations.timeToIdleExpiration( //设置被访问后过期时间(同时设置和TTL和TTI之后会被覆盖,这里TTI生效,之前版本xml配置后是两个配置了都会生效) Duration.of(60L, TimeUnit.SECONDS)) ) // 缓存淘汰策略 默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 // 这块还没看 /*.withEvictionAdvisor( new OddKeysEvictionAdvisor&lt;Long, String&gt;())*/ ).build(); // CacheManager管理缓存 cacheManager = CacheManagerBuilder.newCacheManagerBuilder() // 硬盘持久化地址 .with(CacheManagerBuilder.persistence(&quot;D:/ehcacheData&quot;)) // 设置一个默认缓存配置 .withCache(&quot;defaultCache&quot;, cacheConfiguration) //创建之后立即初始化 .build(true); System.out.println(&quot;[Ehcache配置初始化&lt;完成&gt;]&quot;); } ｝ 2.在main方法中进行测试 1）测试heap配置 修改配置 //设置缓存堆容纳元素个数(JVM内存空间) .heap(1L, EntryUnit.ENTRIES) //设置堆外储存大小(内存存储) //.offheap(100L, MemoryUnit.MB) // 配置磁盘持久化储存(硬盘存储) //.disk(500L, MemoryUnit.MB, false) public static void main(String[] args) throws InterruptedException, FileNotFoundException { // 初始化Ehcache对象 new EhcacheUtil(); // 获取初始化的缓存对象 Cache&lt;String, String&gt; mineCache = cacheManager.getCache(&quot;defaultCache&quot;, String.class, String.class); // 创建测试内容 StringBuilder strTemp = new StringBuilder(&quot;测试&quot;); // 存入第1条数据 mineCache.put(&quot;key&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); strTemp = new StringBuilder(&quot;测试2&quot;); // 存入第2条数据 mineCache.put(&quot;key2&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key2:&quot; + mineCache.get(&quot;key2&quot;)); // 取出并输出第一条数据,因为heap的个数设置为1所以当存入第2条数据时,第一条会被淘汰 System.out.println(&quot;key1:&quot; + mineCache.get(&quot;key1&quot;)); // 关闭ehcache cacheManager.close(); } //控制台输出的结果 Connected to the target VM, address: &#39;127.0.0.1:61909&#39;, transport: &#39;socket&#39; [Ehcache配置初始化&lt;开始&gt;] 13:41:55.435 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - Starting 17 Services... 13:41:55.465 [main] DEBUG org.ehcache.impl.persistence.DefaultLocalPersistenceService - RootDirectory Locked 13:41:55.475 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully started, 17 Services in 40ms 13:41:55.485 [main] DEBUG org.ehcache.core.EhcacheManager - Creating Cache &#39;defaultCache&#39; in EhcacheManager. 13:41:55.485 [main] DEBUG org.ehcache.impl.internal.spi.serialization.DefaultSerializationProvider - Serializer for &lt;java.lang.String&gt; : org.ehcache.impl.serialization.StringSerializer@52e677af 13:41:55.485 [main] DEBUG org.ehcache.impl.internal.spi.serialization.DefaultSerializationProvider - Serializer for &lt;java.lang.String&gt; : org.ehcache.impl.serialization.StringSerializer@7d68ef40 13:41:55.495 [main] DEBUG org.ehcache.impl.internal.spi.copy.DefaultCopyProvider - Copier for &lt;java.lang.String&gt; : org.ehcache.impl.copy.IdentityCopier@475e586c 13:41:55.495 [main] DEBUG org.ehcache.impl.internal.spi.copy.DefaultCopyProvider - Copier for &lt;java.lang.String&gt; : org.ehcache.impl.copy.IdentityCopier@657c8ad9 13:41:55.685 [main] DEBUG class org.ehcache.core.Ehcache-defaultCache - Initialize successful. 13:41:55.685 [main] INFO org.ehcache.core.EhcacheManager - Cache &#39;defaultCache&#39; created in EhcacheManager. 13:41:55.685 [main] DEBUG org.ehcache.core.EhcacheManager - Initialize successful. [Ehcache配置初始化&lt;完成&gt;] key:测试 key2:测试2 key1:null Disconnected from the target VM, address: &#39;127.0.0.1:61909&#39;, transport: &#39;socket&#39; 13:41:55.695 [main] DEBUG class org.ehcache.core.Ehcache-defaultCache - Close successful. 13:41:55.695 [main] INFO org.ehcache.core.EhcacheManager - Cache &#39;defaultCache&#39; removed from EhcacheManager. 13:41:55.695 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - Stopping 17 Services... 13:41:55.695 [main] DEBUG org.ehcache.impl.persistence.DefaultLocalPersistenceService - RootDirectory Unlocked 13:41:55.695 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully stopped, 17 Services in 0ms 13:41:55.695 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful. Process finished with exit code 0 2）测试heap和offheap 设置heap个数为1,offheap大小为1MB(offheap最小为1MB) // 测试heap容纳个数和offheap,将配置中其它无关配置注释掉 // 设置缓存堆容纳元素个数(JVM内存空间) .heap(1L, EntryUnit.ENTRIES) // 设置堆外储存大小(内存存储) .offheap(1L, MemoryUnit.MB) // 配置磁盘持久化储存(硬盘存储) //.disk(500L, MemoryUnit.MB, false) public static void main(String[] args) throws InterruptedException, FileNotFoundException { // 初始化Ehcache对象 new EhcacheUtil(); // 获取初始化的缓存对象 Cache&lt;String, String&gt; mineCache = cacheManager.getCache(&quot;defaultCache&quot;, String.class, String.class); // 创建测试内容 StringBuilder strTemp = new StringBuilder(&quot;测试&quot;); strTemp.append(&quot;测试一二三四五六七八九十&quot;); System.out.println(&quot;大小为：&quot; + strTemp.toString().getBytes() + &quot;Byte&quot;); // 存入第1条数据 mineCache.put(&quot;key&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); strTemp = new StringBuilder(&quot;测试2&quot;); // 存入第2条数据 mineCache.put(&quot;key2&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key2:&quot; + mineCache.get(&quot;key2&quot;)); // 取出并输出第一条数据,由于offheap的个存在所以当存入第2条数据时,第一条会被存储到offheap中而不会被淘汰 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); // 关闭ehcache cacheManager.close(); } 由于控制台日志太多下面只截取部分有用日志 [Ehcache配置初始化&lt;开始&gt;] [Ehcache配置初始化&lt;完成&gt;] key:测试测试一二三四五六七八九十 key2:测试2 key:测试测试一二三四五六七八九十 14:01:41.686 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful. Process finished with exit code 0 设置第一条记录的大小大于offheap 的大小 public static void main(String[] args) throws InterruptedException, FileNotFoundException { // 初始化Ehcache对象 new EhcacheUtil(); // 获取初始化的缓存对象 Cache&lt;String, String&gt; mineCache = cacheManager.getCache(&quot;defaultCache&quot;, String.class, String.class); // 创建测试内容 StringBuilder strTemp = new StringBuilder(&quot;测试&quot;); while(strTemp.toString().getBytes().length &lt;= 1024*1024){ strTemp.append(&quot;测试一二三四五六七八九十&quot;); } System.out.println(&quot;大小为：&quot; + strTemp.toString().getBytes().length + &quot; Byte,1MB大小为:&quot; + 1024*1024 + &quot; Byte&quot;); // 存入第1条数据 mineCache.put(&quot;key&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); strTemp = new StringBuilder(&quot;测试2&quot;); // 存入第2条数据 mineCache.put(&quot;key2&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key2:&quot; + mineCache.get(&quot;key2&quot;)); // 取出并输出第一条数据,由于offheap的个存在所以当存入第2条数据时,第一条会被存储到offheap中,但是第一条数据的大小大于offheap所以会被淘汰 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); // 关闭ehcache cacheManager.close(); } [Ehcache配置初始化&lt;开始&gt;] [Ehcache配置初始化&lt;完成&gt;] 大小为：1048578 Byte,1MB大小为:1048576 Byte 14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 1020.0KB to 1022.0KB [occupation=0.0] 14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Allocating a 2KB buffer from chunk 0 &amp;2048 14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 1022.0KB to 1MB [occupation=0.0] 14:06:50.967 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expansion from 1046528 failed 14:06:50.977 [main] INFO org.ehcache.core.internal.resilience.LoggingRobustResilienceStrategy - Ehcache key key recovered from org.ehcache.core.spi.store.StoreAccessException: The element with key &#39;key&#39; is too large to be stored in this offheap store. at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.computeWithRetry(AbstractOffHeapStore.java:1101) at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.put(AbstractOffHeapStore.java:316) at org.ehcache.impl.internal.store.tiering.TieredStore.put(TieredStore.java:138) at org.ehcache.core.Ehcache.put(Ehcache.java:198) at com.linewell.egov.config.EhcacheUtil.main(EhcacheUtil.java:157) Caused by: org.terracotta.offheapstore.exceptions.OversizeMappingException: Storage Engine and Eviction Failed - Empty Map Storage Engine : OffHeapBufferStorageEngine allocated=1022.0KB occupied=0B Storage Area: OffHeapStorageArea 511 2KB pages Allocator: org.terracotta.offheapstore.storage.allocator.IntegerBestFitAllocator@229c6181 Page Source: UpfrontAllocatingPageSource Chunk 1 Size : 1MB Free Allocator : PowerOfTwoAllocator: Occupied 1022.5KB [Largest Available Area 1KB] Victim Allocator : PowerOfTwoAllocator: Occupied 512B [Largest Available Area 512KB] at org.terracotta.offheapstore.AbstractOffHeapClockCache.storageEngineFailure(AbstractOffHeapClockCache.java:84) at org.terracotta.offheapstore.OffHeapHashMap.writeEntry(OffHeapHashMap.java:689) at org.terracotta.offheapstore.OffHeapHashMap.computeWithMetadata(OffHeapHashMap.java:1947) at org.terracotta.offheapstore.AbstractLockedOffHeapHashMap.computeWithMetadata(AbstractLockedOffHeapHashMap.java:582) at org.terracotta.offheapstore.concurrent.AbstractConcurrentOffHeapMap.computeWithMetadata(AbstractConcurrentOffHeapMap.java:743) at org.ehcache.impl.internal.store.offheap.EhcacheConcurrentOffHeapClockCache.compute(EhcacheConcurrentOffHeapClockCache.java:152) at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.computeWithRetry(AbstractOffHeapStore.java:1099) ... 4 common frames omitted key:null 14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Freeing a 2KB buffer from chunk 0 &amp;2048 14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Allocating a 2KB buffer from chunk 0 &amp;1046528 14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 2KB to 4KB [occupation=0.0] key2:测试2 key:null Disconnected from the target VM, address: &#39;127.0.0.1:63287&#39;, transport: &#39;socket&#39; 14:06:56.191 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully stopped, 17 Services in 10ms 14:06:56.191 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful. Process finished with exit code 0 关于TTL和TTI的测试这里就不贴代码了得出结论是TTL和TTI同时配置时，二者不可共存后面的配置会覆盖前面的，XML配置同理 二、xml版本配置 在resource文件夹下创建ehcache.xml文件 &lt;config xmlns:xsi=&#39;http://www.w3.org/2001/XMLSchema-instance&#39; xmlns=&#39;http://www.ehcache.org/v3&#39; xsi:schemaLocation=&quot;http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core.xsd&quot;&gt; &lt;!-- 持久化路径 --&gt; &lt;persistence directory=&quot;D:/ehcacheData&quot;/&gt; &lt;!-- 缓存模版,此处为了显示其用法,也可以不用模版直接在cache中配置与模版参数相同 --&gt; &lt;cache-template name=&quot;template&quot;&gt; &lt;key-type&gt;java.lang.String&lt;/key-type&gt; &lt;value-type&gt;java.lang.String&lt;/value-type&gt; &lt;expiry&gt; &lt;!-- 单位默认为秒当用秒作单位时,可以不填--&gt; &lt;ttl unit=&quot;hours&quot;&gt;1&lt;/ttl&gt; &lt;/expiry&gt; &lt;resources&gt; &lt;!-- 单位默认为entries当用entries作单位时,可以不填--&gt; &lt;heap&gt;1&lt;/heap&gt; &lt;offheap unit=&quot;MB&quot;&gt;1&lt;/offheap&gt; &lt;!-- persistent 默认为false可以不填--&gt; &lt;disk unit=&quot;MB&quot;&gt;20&lt;/disk&gt; &lt;/resources&gt; &lt;/cache-template&gt; &lt;!-- 缓存对象,如果使用了模版会覆盖模版中的内容,使用uses-template=&quot;&quot;来引用模版 --&gt; &lt;cache alias=&quot;defaultCache&quot; uses-template=&quot;template&quot;&gt; &lt;expiry&gt; &lt;!--此处会覆盖模版中的(TTL)配置 --&gt; &lt;tti&gt;60&lt;/tti&gt; &lt;/expiry&gt; &lt;resources&gt; &lt;disk unit=&quot;MB&quot; persistent=&quot;true&quot;&gt; 500&lt;/disk&gt; &lt;/resources&gt; &lt;!-- 没有研究这块,暂时先不管 &lt;eviction-advisor&gt;&lt;/eviction-advisor&gt; --&gt; &lt;/cache&gt; &lt;/config&gt; public EhcacheUtil() { System.out.println(&quot;[Ehcache配置初始化&lt;开始&gt;]&quot;); // 配置默认缓存属性 cacheManager = CacheManagerBuilder.newCacheManager(new XmlConfiguration(getClass().getResource(&quot;/ehcache.xml&quot;))); cacheManager.init(); System.out.println(&quot;[Ehcache配置初始化&lt;完成&gt;]&quot;); } 应该也可以这样配置到application.yml中,可自行尝试 spring: cache: ehcache: config: ehcache.xml // ehcache3.5.2中缓存过期策略有所更新旧的方法参数已经过期新参数设置可以参考下面 // 过期策略设置为不过期 .withExpiry(ExpiryPolicy.NO_EXPIRY) 如需转载求标明出处,&nbsp;https://blog.csdn.net/Gentlemike/article/details/80403967" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-22T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/Gentlemike/article/details/80403967 ehcache3.3官方文档地址 我用的是springBoot和Ehcache3.3 1.在maven的pom.xml导入ehcache3.3.0依赖 &lt;!-- Ehcache 缓存--&gt; &lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; 一、无xml版本配置 1.创建一个EhcacheUtil.java类用来保存配置 import org.ehcache.Cache; import org.ehcache.CacheManager; import org.ehcache.config.CacheConfiguration; import org.ehcache.config.builders.CacheConfigurationBuilder; import org.ehcache.config.builders.CacheManagerBuilder; import org.ehcache.config.builders.ResourcePoolsBuilder; import org.ehcache.config.units.EntryUnit; import org.ehcache.config.units.MemoryUnit; import org.ehcache.expiry.Duration; import org.ehcache.expiry.Expirations; import org.springframework.cache.annotation.EnableCaching; import org.springframework.context.annotation.Configuration; import java.io.FileNotFoundException; import java.util.concurrent.TimeUnit; /** * ClassName: EhcacheConfig * Description: Ehcache配置 * Author: johnnybro@qq.com * Date: 2018/05/18 14:30:36 */ @Configuration @EnableCaching public class EhcacheUtil { private static CacheManager cacheManager; /** * 初始化Ehcache缓存对象 */ public EhcacheUtil() { System.out.println(&quot;[Ehcache配置初始化&lt;开始&gt;]&quot;); // 配置默认缓存属性 CacheConfiguration&lt;String, String&gt; cacheConfiguration = CacheConfigurationBuilder.newCacheConfigurationBuilder( // 缓存数据K和V的数值类型 // 在ehcache3.3中必须指定缓存键值类型,如果使用中类型与配置的不同,会报类转换异常 String.class, String.class, ResourcePoolsBuilder .newResourcePoolsBuilder() //设置缓存堆容纳元素个数(JVM内存空间)超出个数后会存到offheap中 .heap(1000L,EntryUnit.ENTRIES) //设置堆外储存大小(内存存储) 超出offheap的大小会淘汰规则被淘汰 .offheap(100L, MemoryUnit.MB) // 配置磁盘持久化储存(硬盘存储)用来持久化到磁盘,这里设置为false不启用 .disk(500L, MemoryUnit.MB, false) ).withExpiry(Expirations.timeToLiveExpiration( //设置缓存过期时间 Duration.of(30L, TimeUnit.SECONDS)) ).withExpiry(Expirations.timeToIdleExpiration( //设置被访问后过期时间(同时设置和TTL和TTI之后会被覆盖,这里TTI生效,之前版本xml配置后是两个配置了都会生效) Duration.of(60L, TimeUnit.SECONDS)) ) // 缓存淘汰策略 默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 // 这块还没看 /*.withEvictionAdvisor( new OddKeysEvictionAdvisor&lt;Long, String&gt;())*/ ).build(); // CacheManager管理缓存 cacheManager = CacheManagerBuilder.newCacheManagerBuilder() // 硬盘持久化地址 .with(CacheManagerBuilder.persistence(&quot;D:/ehcacheData&quot;)) // 设置一个默认缓存配置 .withCache(&quot;defaultCache&quot;, cacheConfiguration) //创建之后立即初始化 .build(true); System.out.println(&quot;[Ehcache配置初始化&lt;完成&gt;]&quot;); } ｝ 2.在main方法中进行测试 1）测试heap配置 修改配置 //设置缓存堆容纳元素个数(JVM内存空间) .heap(1L, EntryUnit.ENTRIES) //设置堆外储存大小(内存存储) //.offheap(100L, MemoryUnit.MB) // 配置磁盘持久化储存(硬盘存储) //.disk(500L, MemoryUnit.MB, false) public static void main(String[] args) throws InterruptedException, FileNotFoundException { // 初始化Ehcache对象 new EhcacheUtil(); // 获取初始化的缓存对象 Cache&lt;String, String&gt; mineCache = cacheManager.getCache(&quot;defaultCache&quot;, String.class, String.class); // 创建测试内容 StringBuilder strTemp = new StringBuilder(&quot;测试&quot;); // 存入第1条数据 mineCache.put(&quot;key&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); strTemp = new StringBuilder(&quot;测试2&quot;); // 存入第2条数据 mineCache.put(&quot;key2&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key2:&quot; + mineCache.get(&quot;key2&quot;)); // 取出并输出第一条数据,因为heap的个数设置为1所以当存入第2条数据时,第一条会被淘汰 System.out.println(&quot;key1:&quot; + mineCache.get(&quot;key1&quot;)); // 关闭ehcache cacheManager.close(); } //控制台输出的结果 Connected to the target VM, address: &#39;127.0.0.1:61909&#39;, transport: &#39;socket&#39; [Ehcache配置初始化&lt;开始&gt;] 13:41:55.435 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - Starting 17 Services... 13:41:55.465 [main] DEBUG org.ehcache.impl.persistence.DefaultLocalPersistenceService - RootDirectory Locked 13:41:55.475 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully started, 17 Services in 40ms 13:41:55.485 [main] DEBUG org.ehcache.core.EhcacheManager - Creating Cache &#39;defaultCache&#39; in EhcacheManager. 13:41:55.485 [main] DEBUG org.ehcache.impl.internal.spi.serialization.DefaultSerializationProvider - Serializer for &lt;java.lang.String&gt; : org.ehcache.impl.serialization.StringSerializer@52e677af 13:41:55.485 [main] DEBUG org.ehcache.impl.internal.spi.serialization.DefaultSerializationProvider - Serializer for &lt;java.lang.String&gt; : org.ehcache.impl.serialization.StringSerializer@7d68ef40 13:41:55.495 [main] DEBUG org.ehcache.impl.internal.spi.copy.DefaultCopyProvider - Copier for &lt;java.lang.String&gt; : org.ehcache.impl.copy.IdentityCopier@475e586c 13:41:55.495 [main] DEBUG org.ehcache.impl.internal.spi.copy.DefaultCopyProvider - Copier for &lt;java.lang.String&gt; : org.ehcache.impl.copy.IdentityCopier@657c8ad9 13:41:55.685 [main] DEBUG class org.ehcache.core.Ehcache-defaultCache - Initialize successful. 13:41:55.685 [main] INFO org.ehcache.core.EhcacheManager - Cache &#39;defaultCache&#39; created in EhcacheManager. 13:41:55.685 [main] DEBUG org.ehcache.core.EhcacheManager - Initialize successful. [Ehcache配置初始化&lt;完成&gt;] key:测试 key2:测试2 key1:null Disconnected from the target VM, address: &#39;127.0.0.1:61909&#39;, transport: &#39;socket&#39; 13:41:55.695 [main] DEBUG class org.ehcache.core.Ehcache-defaultCache - Close successful. 13:41:55.695 [main] INFO org.ehcache.core.EhcacheManager - Cache &#39;defaultCache&#39; removed from EhcacheManager. 13:41:55.695 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - Stopping 17 Services... 13:41:55.695 [main] DEBUG org.ehcache.impl.persistence.DefaultLocalPersistenceService - RootDirectory Unlocked 13:41:55.695 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully stopped, 17 Services in 0ms 13:41:55.695 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful. Process finished with exit code 0 2）测试heap和offheap 设置heap个数为1,offheap大小为1MB(offheap最小为1MB) // 测试heap容纳个数和offheap,将配置中其它无关配置注释掉 // 设置缓存堆容纳元素个数(JVM内存空间) .heap(1L, EntryUnit.ENTRIES) // 设置堆外储存大小(内存存储) .offheap(1L, MemoryUnit.MB) // 配置磁盘持久化储存(硬盘存储) //.disk(500L, MemoryUnit.MB, false) public static void main(String[] args) throws InterruptedException, FileNotFoundException { // 初始化Ehcache对象 new EhcacheUtil(); // 获取初始化的缓存对象 Cache&lt;String, String&gt; mineCache = cacheManager.getCache(&quot;defaultCache&quot;, String.class, String.class); // 创建测试内容 StringBuilder strTemp = new StringBuilder(&quot;测试&quot;); strTemp.append(&quot;测试一二三四五六七八九十&quot;); System.out.println(&quot;大小为：&quot; + strTemp.toString().getBytes() + &quot;Byte&quot;); // 存入第1条数据 mineCache.put(&quot;key&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); strTemp = new StringBuilder(&quot;测试2&quot;); // 存入第2条数据 mineCache.put(&quot;key2&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key2:&quot; + mineCache.get(&quot;key2&quot;)); // 取出并输出第一条数据,由于offheap的个存在所以当存入第2条数据时,第一条会被存储到offheap中而不会被淘汰 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); // 关闭ehcache cacheManager.close(); } 由于控制台日志太多下面只截取部分有用日志 [Ehcache配置初始化&lt;开始&gt;] [Ehcache配置初始化&lt;完成&gt;] key:测试测试一二三四五六七八九十 key2:测试2 key:测试测试一二三四五六七八九十 14:01:41.686 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful. Process finished with exit code 0 设置第一条记录的大小大于offheap 的大小 public static void main(String[] args) throws InterruptedException, FileNotFoundException { // 初始化Ehcache对象 new EhcacheUtil(); // 获取初始化的缓存对象 Cache&lt;String, String&gt; mineCache = cacheManager.getCache(&quot;defaultCache&quot;, String.class, String.class); // 创建测试内容 StringBuilder strTemp = new StringBuilder(&quot;测试&quot;); while(strTemp.toString().getBytes().length &lt;= 1024*1024){ strTemp.append(&quot;测试一二三四五六七八九十&quot;); } System.out.println(&quot;大小为：&quot; + strTemp.toString().getBytes().length + &quot; Byte,1MB大小为:&quot; + 1024*1024 + &quot; Byte&quot;); // 存入第1条数据 mineCache.put(&quot;key&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); strTemp = new StringBuilder(&quot;测试2&quot;); // 存入第2条数据 mineCache.put(&quot;key2&quot;, strTemp.toString()); // 取出并输出 System.out.println(&quot;key2:&quot; + mineCache.get(&quot;key2&quot;)); // 取出并输出第一条数据,由于offheap的个存在所以当存入第2条数据时,第一条会被存储到offheap中,但是第一条数据的大小大于offheap所以会被淘汰 System.out.println(&quot;key:&quot; + mineCache.get(&quot;key&quot;)); // 关闭ehcache cacheManager.close(); } [Ehcache配置初始化&lt;开始&gt;] [Ehcache配置初始化&lt;完成&gt;] 大小为：1048578 Byte,1MB大小为:1048576 Byte 14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 1020.0KB to 1022.0KB [occupation=0.0] 14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Allocating a 2KB buffer from chunk 0 &amp;2048 14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 1022.0KB to 1MB [occupation=0.0] 14:06:50.967 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expansion from 1046528 failed 14:06:50.977 [main] INFO org.ehcache.core.internal.resilience.LoggingRobustResilienceStrategy - Ehcache key key recovered from org.ehcache.core.spi.store.StoreAccessException: The element with key &#39;key&#39; is too large to be stored in this offheap store. at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.computeWithRetry(AbstractOffHeapStore.java:1101) at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.put(AbstractOffHeapStore.java:316) at org.ehcache.impl.internal.store.tiering.TieredStore.put(TieredStore.java:138) at org.ehcache.core.Ehcache.put(Ehcache.java:198) at com.linewell.egov.config.EhcacheUtil.main(EhcacheUtil.java:157) Caused by: org.terracotta.offheapstore.exceptions.OversizeMappingException: Storage Engine and Eviction Failed - Empty Map Storage Engine : OffHeapBufferStorageEngine allocated=1022.0KB occupied=0B Storage Area: OffHeapStorageArea 511 2KB pages Allocator: org.terracotta.offheapstore.storage.allocator.IntegerBestFitAllocator@229c6181 Page Source: UpfrontAllocatingPageSource Chunk 1 Size : 1MB Free Allocator : PowerOfTwoAllocator: Occupied 1022.5KB [Largest Available Area 1KB] Victim Allocator : PowerOfTwoAllocator: Occupied 512B [Largest Available Area 512KB] at org.terracotta.offheapstore.AbstractOffHeapClockCache.storageEngineFailure(AbstractOffHeapClockCache.java:84) at org.terracotta.offheapstore.OffHeapHashMap.writeEntry(OffHeapHashMap.java:689) at org.terracotta.offheapstore.OffHeapHashMap.computeWithMetadata(OffHeapHashMap.java:1947) at org.terracotta.offheapstore.AbstractLockedOffHeapHashMap.computeWithMetadata(AbstractLockedOffHeapHashMap.java:582) at org.terracotta.offheapstore.concurrent.AbstractConcurrentOffHeapMap.computeWithMetadata(AbstractConcurrentOffHeapMap.java:743) at org.ehcache.impl.internal.store.offheap.EhcacheConcurrentOffHeapClockCache.compute(EhcacheConcurrentOffHeapClockCache.java:152) at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.computeWithRetry(AbstractOffHeapStore.java:1099) ... 4 common frames omitted key:null 14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Freeing a 2KB buffer from chunk 0 &amp;2048 14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Allocating a 2KB buffer from chunk 0 &amp;1046528 14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 2KB to 4KB [occupation=0.0] key2:测试2 key:null Disconnected from the target VM, address: &#39;127.0.0.1:63287&#39;, transport: &#39;socket&#39; 14:06:56.191 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully stopped, 17 Services in 10ms 14:06:56.191 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful. Process finished with exit code 0 关于TTL和TTI的测试这里就不贴代码了得出结论是TTL和TTI同时配置时，二者不可共存后面的配置会覆盖前面的，XML配置同理 二、xml版本配置 在resource文件夹下创建ehcache.xml文件 &lt;config xmlns:xsi=&#39;http://www.w3.org/2001/XMLSchema-instance&#39; xmlns=&#39;http://www.ehcache.org/v3&#39; xsi:schemaLocation=&quot;http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core.xsd&quot;&gt; &lt;!-- 持久化路径 --&gt; &lt;persistence directory=&quot;D:/ehcacheData&quot;/&gt; &lt;!-- 缓存模版,此处为了显示其用法,也可以不用模版直接在cache中配置与模版参数相同 --&gt; &lt;cache-template name=&quot;template&quot;&gt; &lt;key-type&gt;java.lang.String&lt;/key-type&gt; &lt;value-type&gt;java.lang.String&lt;/value-type&gt; &lt;expiry&gt; &lt;!-- 单位默认为秒当用秒作单位时,可以不填--&gt; &lt;ttl unit=&quot;hours&quot;&gt;1&lt;/ttl&gt; &lt;/expiry&gt; &lt;resources&gt; &lt;!-- 单位默认为entries当用entries作单位时,可以不填--&gt; &lt;heap&gt;1&lt;/heap&gt; &lt;offheap unit=&quot;MB&quot;&gt;1&lt;/offheap&gt; &lt;!-- persistent 默认为false可以不填--&gt; &lt;disk unit=&quot;MB&quot;&gt;20&lt;/disk&gt; &lt;/resources&gt; &lt;/cache-template&gt; &lt;!-- 缓存对象,如果使用了模版会覆盖模版中的内容,使用uses-template=&quot;&quot;来引用模版 --&gt; &lt;cache alias=&quot;defaultCache&quot; uses-template=&quot;template&quot;&gt; &lt;expiry&gt; &lt;!--此处会覆盖模版中的(TTL)配置 --&gt; &lt;tti&gt;60&lt;/tti&gt; &lt;/expiry&gt; &lt;resources&gt; &lt;disk unit=&quot;MB&quot; persistent=&quot;true&quot;&gt; 500&lt;/disk&gt; &lt;/resources&gt; &lt;!-- 没有研究这块,暂时先不管 &lt;eviction-advisor&gt;&lt;/eviction-advisor&gt; --&gt; &lt;/cache&gt; &lt;/config&gt; public EhcacheUtil() { System.out.println(&quot;[Ehcache配置初始化&lt;开始&gt;]&quot;); // 配置默认缓存属性 cacheManager = CacheManagerBuilder.newCacheManager(new XmlConfiguration(getClass().getResource(&quot;/ehcache.xml&quot;))); cacheManager.init(); System.out.println(&quot;[Ehcache配置初始化&lt;完成&gt;]&quot;); } 应该也可以这样配置到application.yml中,可自行尝试 spring: cache: ehcache: config: ehcache.xml // ehcache3.5.2中缓存过期策略有所更新旧的方法参数已经过期新参数设置可以参考下面 // 过期策略设置为不过期 .withExpiry(ExpiryPolicy.NO_EXPIRY) 如需转载求标明出处,&nbsp;https://blog.csdn.net/Gentlemike/article/details/80403967","@type":"BlogPosting","url":"/2018/05/22/da82e140f2f746742573db439a878451.html","headline":"JAVA中使用springBoot和Ehcache3.X无xml配置和xml配置","dateModified":"2018-05-22T00:00:00+08:00","datePublished":"2018-05-22T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/05/22/da82e140f2f746742573db439a878451.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>JAVA中使用springBoot和Ehcache3.X无xml配置和xml配置</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright"> 
  <svg class="icon" title="CSDN认证原创" aria-hidden="true" style="width:53px; height: 18px; vertical-align: -4px;"> 
   <use xlink:href="#CSDN_Cert"></use> 
  </svg> 版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/Gentlemike/article/details/80403967 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f1a9c33fcd.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p><a href="http://www.ehcache.org/documentation/3.3/getting-started.html" rel="nofollow">ehcache3.3官方文档地址</a></p>
  <p>我用的是springBoot和Ehcache3.3</p>
  <p>1.在maven的pom.xml导入ehcache3.3.0依赖</p>
  <pre><code class="language-html">&lt;!-- Ehcache 缓存--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.ehcache&lt;/groupId&gt;
    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
  <p>一、无xml版本配置</p>
  <p>1.创建一个EhcacheUtil.java类用来保存配置</p>
  <pre><code class="language-java">import org.ehcache.Cache;
import org.ehcache.CacheManager;
import org.ehcache.config.CacheConfiguration;
import org.ehcache.config.builders.CacheConfigurationBuilder;
import org.ehcache.config.builders.CacheManagerBuilder;
import org.ehcache.config.builders.ResourcePoolsBuilder;
import org.ehcache.config.units.EntryUnit;
import org.ehcache.config.units.MemoryUnit;
import org.ehcache.expiry.Duration;
import org.ehcache.expiry.Expirations;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Configuration;

import java.io.FileNotFoundException;
import java.util.concurrent.TimeUnit;

/**
 * ClassName: EhcacheConfig
 * Description: Ehcache配置
 * Author: johnnybro@qq.com
 * Date: 2018/05/18 14:30:36
 */
@Configuration
@EnableCaching
public class EhcacheUtil {
    private static CacheManager cacheManager;
    /**
     * 初始化Ehcache缓存对象
     */
    public EhcacheUtil() {
        System.out.println("[Ehcache配置初始化&lt;开始&gt;]");

        // 配置默认缓存属性
        CacheConfiguration&lt;String, String&gt; cacheConfiguration = CacheConfigurationBuilder.newCacheConfigurationBuilder(
                // 缓存数据K和V的数值类型
                // 在ehcache3.3中必须指定缓存键值类型,如果使用中类型与配置的不同,会报类转换异常
                String.class, String.class,
                ResourcePoolsBuilder
                        .newResourcePoolsBuilder()
                        //设置缓存堆容纳元素个数(JVM内存空间)超出个数后会存到offheap中
                        .heap(1000L,EntryUnit.ENTRIES)
                        //设置堆外储存大小(内存存储) 超出offheap的大小会淘汰规则被淘汰
                        .offheap(100L, MemoryUnit.MB)
                        // 配置磁盘持久化储存(硬盘存储)用来持久化到磁盘,这里设置为false不启用
                        .disk(500L, MemoryUnit.MB, false)
        ).withExpiry(Expirations.<span style="color:#ff6666;">t</span>ime<span style="color:#ff6666;">T</span>o<span style="color:#ff6666;">L</span>iveExpiration(
                //设置缓存过期时间
                Duration.of(30L, TimeUnit.SECONDS))
        ).withExpiry(Expirations.<span style="color:#ff6666;">t</span>ime<span style="color:#ff6666;">T</span>o<span style="color:#ff6666;">I</span>dleExpiration(
                //设置被访问后过期时间(<span style="color:#ff6666;">同时设置和TTL和TTI之后会被覆盖,这里TTI生效,之前版本xml配置后是两个配置了都会生效</span>)
                Duration.of(60L, TimeUnit.SECONDS))
        )
        // 缓存淘汰策略 默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
        // 这块还没看
        /*.withEvictionAdvisor(
                new OddKeysEvictionAdvisor&lt;Long, String&gt;())*/
        ).build();
        // CacheManager管理缓存
        cacheManager = CacheManagerBuilder.newCacheManagerBuilder()
        // 硬盘持久化地址
        .with(CacheManagerBuilder.persistence("D:/ehcacheData"))
        // 设置一个默认缓存配置
        .withCache("defaultCache", cacheConfiguration)
        //创建之后立即初始化
        .build(true);

        System.out.println("[Ehcache配置初始化&lt;完成&gt;]");
    }
｝</code></pre>
  <p>2.在main方法中进行测试</p>
  <p>1）测试heap配置</p>
  <p>修改配置</p>
  <pre><code class="language-java">//设置缓存堆容纳元素个数(JVM内存空间)
 .heap(1L, EntryUnit.ENTRIES)
//设置堆外储存大小(内存存储)
//.offheap(100L, MemoryUnit.MB)
// 配置磁盘持久化储存(硬盘存储)
//.disk(500L, MemoryUnit.MB, false)</code></pre>
  <pre><code class="language-java">public static void main(String[] args) throws InterruptedException, FileNotFoundException {
    // 初始化Ehcache对象    
    new EhcacheUtil();
    // 获取初始化的缓存对象
    Cache&lt;String, String&gt; mineCache = cacheManager.getCache("defaultCache", String.class, String.class);
    // 创建测试内容
    StringBuilder strTemp = new StringBuilder("测试");
    // 存入第1条数据
    mineCache.put("key", strTemp.toString());
    // 取出并输出
    System.out.println("key:" + mineCache.get("key"));
    strTemp = new StringBuilder("测试2");
    // 存入第2条数据
    mineCache.put("key2", strTemp.toString());
    // 取出并输出
    System.out.println("key2:" + mineCache.get("key2"));
    // 取出并输出第一条数据,因为heap的个数设置为1所以当存入第2条数据时,第一条会被淘汰
    System.out.println("key1:" + mineCache.get("key1"));
    // 关闭ehcache
    cacheManager.close();
}
</code></pre>
  <pre><code class="language-java">//控制台输出的结果
Connected to the target VM, address: '127.0.0.1:61909', transport: 'socket'
[Ehcache配置初始化&lt;开始&gt;]
13:41:55.435 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - Starting 17 Services...
13:41:55.465 [main] DEBUG org.ehcache.impl.persistence.DefaultLocalPersistenceService - RootDirectory Locked
13:41:55.475 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully started, 17 Services in 40ms
13:41:55.485 [main] DEBUG org.ehcache.core.EhcacheManager - Creating Cache 'defaultCache' in EhcacheManager.
13:41:55.485 [main] DEBUG org.ehcache.impl.internal.spi.serialization.DefaultSerializationProvider - Serializer for &lt;java.lang.String&gt; : org.ehcache.impl.serialization.StringSerializer@52e677af
13:41:55.485 [main] DEBUG org.ehcache.impl.internal.spi.serialization.DefaultSerializationProvider - Serializer for &lt;java.lang.String&gt; : org.ehcache.impl.serialization.StringSerializer@7d68ef40
13:41:55.495 [main] DEBUG org.ehcache.impl.internal.spi.copy.DefaultCopyProvider - Copier for &lt;java.lang.String&gt; : org.ehcache.impl.copy.IdentityCopier@475e586c
13:41:55.495 [main] DEBUG org.ehcache.impl.internal.spi.copy.DefaultCopyProvider - Copier for &lt;java.lang.String&gt; : org.ehcache.impl.copy.IdentityCopier@657c8ad9
13:41:55.685 [main] DEBUG class org.ehcache.core.Ehcache-defaultCache - Initialize successful.
13:41:55.685 [main] INFO org.ehcache.core.EhcacheManager - Cache 'defaultCache' created in EhcacheManager.
13:41:55.685 [main] DEBUG org.ehcache.core.EhcacheManager - Initialize successful.
[Ehcache配置初始化&lt;完成&gt;]
key:测试
key2:测试2
key1:null
Disconnected from the target VM, address: '127.0.0.1:61909', transport: 'socket'
13:41:55.695 [main] DEBUG class org.ehcache.core.Ehcache-defaultCache - Close successful.
13:41:55.695 [main] INFO org.ehcache.core.EhcacheManager - Cache 'defaultCache' removed from EhcacheManager.
13:41:55.695 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - Stopping 17 Services...
13:41:55.695 [main] DEBUG org.ehcache.impl.persistence.DefaultLocalPersistenceService - RootDirectory Unlocked
13:41:55.695 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully stopped, 17 Services in 0ms
13:41:55.695 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful.

Process finished with exit code 0</code></pre>
  <br>
  <p>2）测试heap和offheap</p>
  <p>设置heap个数为1,offheap大小为1MB(<span style="color:#ff6666;">offheap最小为1MB</span>)</p>
  <pre><code class="language-java">// 测试heap容纳个数和offheap,将配置中其它无关配置注释掉
// 设置缓存堆容纳元素个数(JVM内存空间)
.heap(1L, EntryUnit.ENTRIES)
// 设置堆外储存大小(内存存储)
.offheap(1L, MemoryUnit.MB)
// 配置磁盘持久化储存(硬盘存储)
//.disk(500L, MemoryUnit.MB, false)</code></pre>
  <pre><code class="language-java">public static void main(String[] args) throws InterruptedException, FileNotFoundException {
    // 初始化Ehcache对象
    new EhcacheUtil();
    // 获取初始化的缓存对象
    Cache&lt;String, String&gt; mineCache = cacheManager.getCache("defaultCache", String.class, String.class);
    // 创建测试内容
    StringBuilder strTemp = new StringBuilder("测试");
    strTemp.append("测试一二三四五六七八九十");
    System.out.println("大小为：" + strTemp.toString().getBytes() + "Byte");
    // 存入第1条数据
    mineCache.put("key", strTemp.toString());
    // 取出并输出
    System.out.println("key:" + mineCache.get("key"));
    strTemp = new StringBuilder("测试2");
    // 存入第2条数据
    mineCache.put("key2", strTemp.toString());
    // 取出并输出
    System.out.println("key2:" + mineCache.get("key2"));
    // 取出并输出第一条数据,由于offheap的个存在所以当存入第2条数据时,第一条会被存储到offheap中而不会被淘汰
    System.out.println("key:" + mineCache.get("key"));
    // 关闭ehcache
    cacheManager.close();
}</code></pre>
  <strong><span style="color:#ff6666;">由于控制台日志太多下面只截取部分有用日志</span></strong>
  <br>
  <pre><code class="language-java">[Ehcache配置初始化&lt;开始&gt;]
[Ehcache配置初始化&lt;完成&gt;]
key:测试测试一二三四五六七八九十
key2:测试2
key:测试测试一二三四五六七八九十
14:01:41.686 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful.
Process finished with exit code 0</code></pre>
  <p>设置第一条记录的大小<span style="color:#ff6666;">大于offheap</span> 的大小</p>
  <pre><code class="language-java">public static void main(String[] args) throws InterruptedException, FileNotFoundException {
    // 初始化Ehcache对象
    new EhcacheUtil();
    // 获取初始化的缓存对象
    Cache&lt;String, String&gt; mineCache = cacheManager.getCache("defaultCache", String.class, String.class);
    // 创建测试内容
    StringBuilder strTemp = new StringBuilder("测试");
    while(strTemp.toString().getBytes().length &lt;= 1024*1024){
        strTemp.append("测试一二三四五六七八九十");
    }
    System.out.println("大小为：" + strTemp.toString().getBytes().length + " Byte,1MB大小为:" + 1024*1024 + " Byte");
    // 存入第1条数据
    mineCache.put("key", strTemp.toString());
    // 取出并输出
    System.out.println("key:" + mineCache.get("key"));
    strTemp = new StringBuilder("测试2");
    // 存入第2条数据
    mineCache.put("key2", strTemp.toString());
    // 取出并输出
    System.out.println("key2:" + mineCache.get("key2"));
    // 取出并输出第一条数据,由于offheap的个存在所以当存入第2条数据时,第一条会被存储到offheap中,但是第一条数据的大小大于offheap所以会被淘汰
    System.out.println("key:" + mineCache.get("key"));
    // 关闭ehcache
    cacheManager.close();
}</code></pre>
  <pre><code class="language-java">[Ehcache配置初始化&lt;开始&gt;]
[Ehcache配置初始化&lt;完成&gt;]
大小为：1048578 Byte,1MB大小为:1048576 Byte
14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 1020.0KB to 1022.0KB [occupation=0.0]
14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Allocating a 2KB buffer from chunk 0 &amp;2048
14:06:50.926 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 1022.0KB to 1MB [occupation=0.0]
14:06:50.967 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expansion from 1046528 failed
14:06:50.977 [main] INFO org.ehcache.core.internal.resilience.LoggingRobustResilienceStrategy - Ehcache key key recovered from
org.ehcache.core.spi.store.StoreAccessException: The element with key 'key' is too large to be stored in this offheap store.
	at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.computeWithRetry(AbstractOffHeapStore.java:1101)
	at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.put(AbstractOffHeapStore.java:316)
	at org.ehcache.impl.internal.store.tiering.TieredStore.put(TieredStore.java:138)
	at org.ehcache.core.Ehcache.put(Ehcache.java:198)
	at com.linewell.egov.config.EhcacheUtil.main(EhcacheUtil.java:157)
Caused by: org.terracotta.offheapstore.exceptions.OversizeMappingException: Storage Engine and Eviction Failed - Empty Map
Storage Engine : OffHeapBufferStorageEngine allocated=1022.0KB occupied=0B
Storage Area: OffHeapStorageArea
	511 2KB pages
Allocator: org.terracotta.offheapstore.storage.allocator.IntegerBestFitAllocator@229c6181
Page Source: UpfrontAllocatingPageSource
Chunk 1
Size             : 1MB
Free Allocator   : PowerOfTwoAllocator: Occupied 1022.5KB [Largest Available Area 1KB]
Victim Allocator : PowerOfTwoAllocator: Occupied 512B [Largest Available Area 512KB]
	at org.terracotta.offheapstore.AbstractOffHeapClockCache.storageEngineFailure(AbstractOffHeapClockCache.java:84)
	at org.terracotta.offheapstore.OffHeapHashMap.writeEntry(OffHeapHashMap.java:689)
	at org.terracotta.offheapstore.OffHeapHashMap.computeWithMetadata(OffHeapHashMap.java:1947)
	at org.terracotta.offheapstore.AbstractLockedOffHeapHashMap.computeWithMetadata(AbstractLockedOffHeapHashMap.java:582)
	at org.terracotta.offheapstore.concurrent.AbstractConcurrentOffHeapMap.computeWithMetadata(AbstractConcurrentOffHeapMap.java:743)
	at org.ehcache.impl.internal.store.offheap.EhcacheConcurrentOffHeapClockCache.compute(EhcacheConcurrentOffHeapClockCache.java:152)
	at org.ehcache.impl.internal.store.offheap.AbstractOffHeapStore.computeWithRetry(AbstractOffHeapStore.java:1099)
	... 4 common frames omitted
key:null
14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Freeing a 2KB buffer from chunk 0 &amp;2048
14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.UpfrontAllocatingPageSource - Allocating a 2KB buffer from chunk 0 &amp;1046528
14:06:54.070 [main] DEBUG org.terracotta.offheapstore.paging.OffHeapStorageArea - Data area expanded from 2KB to 4KB [occupation=0.0]
key2:测试2
key:null
Disconnected from the target VM, address: '127.0.0.1:63287', transport: 'socket'
14:06:56.191 [main] DEBUG org.ehcache.core.internal.service.ServiceLocator - All Services successfully stopped, 17 Services in 10ms
14:06:56.191 [main] DEBUG org.ehcache.core.EhcacheManager - Close successful.
Process finished with exit code 0</code></pre>
  <p><span style="color:#cc9933;">关于TTL和TTI的测试这里就不贴代码了得出结论是TTL和TTI同时配置时<span style="color:rgb(255,102,102);">，二者不可共存</span></span><span style="color:#ff6666;">后面的配置会覆盖前面的</span><span style="color:#cc9933;">，XML配置同理</span></p>
  <p>二、xml版本配置</p>
  <p>在resource文件夹下创建ehcache.xml文件</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/201805221424348" alt=""><br></p>
  <pre><code class="language-html">&lt;config
        xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
        xmlns='http://www.ehcache.org/v3'
        xsi:schemaLocation="http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core.xsd"&gt;
    &lt;!-- 持久化路径 --&gt;
    &lt;persistence directory="D:/ehcacheData"/&gt;

    &lt;!-- 缓存模版,此处为了显示其用法,也可以不用模版直接在cache中配置与模版参数相同 --&gt;
    &lt;cache-template name="template"&gt;
        &lt;key-type&gt;java.lang.String&lt;/key-type&gt;
        &lt;value-type&gt;java.lang.String&lt;/value-type&gt;
        &lt;expiry&gt;
            &lt;!-- 单位默认为秒当用秒作单位时,可以不填--&gt;
            &lt;ttl unit="hours"&gt;1&lt;/ttl&gt;
        &lt;/expiry&gt;
        &lt;resources&gt;
            &lt;!-- 单位默认为entries当用entries作单位时,可以不填--&gt;
            &lt;heap&gt;1&lt;/heap&gt;
            &lt;offheap unit="MB"&gt;1&lt;/offheap&gt;
            &lt;!-- persistent 默认为false可以不填--&gt;
            &lt;disk unit="MB"&gt;20&lt;/disk&gt;
        &lt;/resources&gt;
    &lt;/cache-template&gt;

    &lt;!-- 缓存对象,如果使用了模版会覆盖模版中的内容,使用uses-template=""来引用模版 --&gt;
    &lt;cache alias="defaultCache" uses-template="template"&gt;
        &lt;expiry&gt;
            &lt;!--此处会覆盖模版中的(TTL)配置 --&gt;
            &lt;tti&gt;60&lt;/tti&gt;
        &lt;/expiry&gt;
        &lt;resources&gt;
            &lt;disk unit="MB" persistent="true"&gt; 500&lt;/disk&gt;
        &lt;/resources&gt;
        &lt;!-- 没有研究这块,暂时先不管
        &lt;eviction-advisor&gt;&lt;/eviction-advisor&gt;
        --&gt;
    &lt;/cache&gt;
&lt;/config&gt;</code></pre>
  <pre><code class="language-java">   public EhcacheUtil() {
        System.out.println("[Ehcache配置初始化&lt;开始&gt;]");
        // 配置默认缓存属性
        cacheManager = CacheManagerBuilder.newCacheManager(new XmlConfiguration(getClass().getResource("/ehcache.xml")));
        cacheManager.init();
        System.out.println("[Ehcache配置初始化&lt;完成&gt;]");
    }</code></pre>
  <p>应该也可以这样配置到application.yml中,可自行尝试</p>
  <pre><code class="language-plain">spring:
  cache:
    ehcache:
      config: ehcache.xml</code></pre>
  <pre><code class="language-java">// ehcache3.5.2中缓存过期策略有所更新旧的方法参数已经过期新参数设置可以参考下面
// 过期策略设置为不过期</code></pre>
  <pre><code class="language-java">.withExpiry(ExpiryPolicy.NO_EXPIRY)</code></pre>
  <p>如需转载求标明出处,&nbsp;https://blog.csdn.net/Gentlemike/article/details/80403967</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
