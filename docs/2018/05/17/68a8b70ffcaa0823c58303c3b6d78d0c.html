<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链共识算法(3)PoS权益证明算法 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链共识算法(3)PoS权益证明算法" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="# PoS权益证明算法原理及其在点点币、黑币中的实现 PoS，即Proof of Stake，译为权益证明。 无论PoW或PoS，均可以理解为“谁有资格写区块链”的问题。 PoW通过算力证明自己有资格写区块链，而PoS则是通过拥有的币龄来证明自己有资格写区块链。 ### PoW的优势和弊端 PoW，优势为可靠，使用广泛，是经历了充分的实践检验的公有链共识算法。 但其缺点也较为明显： * 1、消耗了太多额外算力，即大量能源。 * 2、资本大量投资矿机，导致算力中心化，有51%攻击的安全隐患。 ### PoS的提出和点点币 第一个基于PoS的虚拟币是点点币。 鉴于PoW的缺陷，2012年Sunny King提出了PoS，并基于PoW和PoS的混合机制发布了点点币PPCoin。 前期采用PoW挖矿开采和分配货币，以保证公平。后期采用PoS机制，保障网络安全，即拥有51%货币难度更大，从而防止51%攻击。 PoS核心概念为币龄，即持有货币的时间。例如有10个币、持有90天，即拥有900币天的币龄。 另外使用币，即意味着币龄的销毁。 在PoS中有一种特殊的交易称为利息币，即持有人可以消耗币龄获得利息，同时获得为网络产生区块、以及PoS造币的优先权。 ### 点点币的PoS实现原理 点点币的PoS证明计算公式为： proofhash &lt; 币龄x目标值 展开如下： hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime) &lt; bnTarget x bnCoinDayWeight * 其中proofhash，对应一组数据的哈希值，即hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime)。 * 币龄即bnCoinDayWeight，即币天，即持有的币数乘以持有币的天数，此处天数最大值为90天。 * 目标值，即bnTarget，用于衡量PoS挖矿难度。目标值与难度成反比，目标值越大、难度越小；反之亦然。 由公式可见，持有的币天越大，挖到区块的机会越大。 peercoin-0.6.1ppc中PoS证明计算代码如下： ```c++ bool CheckStakeKernelHash( unsigned int nBits, const CBlockHeader&amp; blockFrom, unsigned int nTxPrevOffset, const CTransaction&amp; txPrev, const COutPoint&amp; prevout, unsigned int nTimeTx, uint256&amp; hashProofOfStake, bool fPrintProofOfStake) { if (nTimeTx &lt; txPrev.nTime) // Transaction timestamp violation return error(&quot;CheckStakeKernelHash() : nTime violation&quot;); unsigned int nTimeBlockFrom = blockFrom.GetBlockTime(); if (nTimeBlockFrom + nStakeMinAge &gt; nTimeTx) // Min age requirement return error(&quot;CheckStakeKernelHash() : min age violation&quot;); &nbsp;&nbsp;&nbsp;&nbsp;//目标值使用nBits CBigNum bnTargetPerCoinDay; bnTargetPerCoinDay.SetCompact(nBits); int64 nValueIn = txPrev.vout[prevout.n].nValue; // v0.3 protocol kernel hash weight starts from 0 at the 30-day min age // this change increases active coins participating the hash and helps // to secure the network when proof-of-stake difficulty is low int64 nTimeWeight = min((int64)nTimeTx - txPrev.nTime, (int64)STAKE_MAX_AGE) - (IsProtocolV03(nTimeTx)? nStakeMinAge : 0); &nbsp;&nbsp;&nbsp;&nbsp;//计算币龄，STAKE_MAX_AGE为90天 CBigNum bnCoinDayWeight = CBigNum(nValueIn) * nTimeWeight / COIN / (24 * 60 * 60); // Calculate hash CDataStream ss(SER_GETHASH, 0); &nbsp;&nbsp;&nbsp;&nbsp;//权重修正因子 uint64 nStakeModifier = 0; int nStakeModifierHeight = 0; int64 nStakeModifierTime = 0; if (IsProtocolV03(nTimeTx)) // v0.3 protocol { if (!GetKernelStakeModifier(blockFrom.GetHash(), nTimeTx, nStakeModifier, nStakeModifierHeight, nStakeModifierTime, fPrintProofOfStake)) return false; ss &lt;&lt; nStakeModifier; } else // v0.2 protocol { ss &lt;&lt; nBits; } &nbsp;&nbsp;&nbsp;&nbsp;//计算proofhash &nbsp;&nbsp;&nbsp;&nbsp;//即计算hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime) ss &lt;&lt; nTimeBlockFrom &lt;&lt; nTxPrevOffset &lt;&lt; txPrev.nTime &lt;&lt; prevout.n &lt;&lt; nTimeTx; hashProofOfStake = Hash(ss.begin(), ss.end()); if (fPrintProofOfStake) { if (IsProtocolV03(nTimeTx)) printf(&quot;CheckStakeKernelHash() : using modifier 0x%016&quot; PRI64x&quot; at height=%d timestamp=%s for block from height=%d timestamp=%s\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime).c_str(), mapBlockIndex[blockFrom.GetHash()]-&gt;nHeight, DateTimeStrFormat(blockFrom.GetBlockTime()).c_str()); printf(&quot;CheckStakeKernelHash() : check protocol=%s modifier=0x%016&quot; PRI64x&quot; nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n&quot;, IsProtocolV05(nTimeTx)? &quot;0.5&quot; : (IsProtocolV03(nTimeTx)? &quot;0.3&quot; : &quot;0.2&quot;), IsProtocolV03(nTimeTx)? nStakeModifier : (uint64) nBits, nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString().c_str()); } // Now check if proof-of-stake hash meets target protocol &nbsp;&nbsp;&nbsp;&nbsp;//判断是否满足proofhash &lt; 币龄x目标值 if (CBigNum(hashProofOfStake) &gt; bnCoinDayWeight * bnTargetPerCoinDay) return false; if (fDebug &amp;&amp; !fPrintProofOfStake) { if (IsProtocolV03(nTimeTx)) printf(&quot;CheckStakeKernelHash() : using modifier 0x%016&quot; PRI64x&quot; at height=%d timestamp=%s for block from height=%d timestamp=%s\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime).c_str(), mapBlockIndex[blockFrom.GetHash()]-&gt;nHeight, DateTimeStrFormat(blockFrom.GetBlockTime()).c_str()); printf(&quot;CheckStakeKernelHash() : pass protocol=%s modifier=0x%016&quot; PRI64x&quot; nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n&quot;, IsProtocolV03(nTimeTx)? &quot;0.3&quot; : &quot;0.2&quot;, IsProtocolV03(nTimeTx)? nStakeModifier : (uint64) nBits, nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString().c_str()); } return true; } //代码位置src/kernel.cpp ``` ### 点点币的PoS挖矿难度 点点币使用目标值来衡量挖矿难度，目标值与难度成反比，目标值越大、难度越小；反之亦然。 当前区块的目标值与前一个区块目标值、前两个区块的时间间隔有关。 计算公式如下： 当前区块目标值 = 前一个区块目标值 x (1007x10x60 + 2x前两个区块时间间隔) / (1009x10x60) 由公式可见，两个区块目标间隔时间即为10分钟。 如果前两个区块时间间隔大于10分钟，目标值会提高，即当前区块难度会降低。 反之，如果前两个区块时间间隔小于10分钟，目标值会降低，即当前区块难度会提高。 peercoin-0.6.1ppc中目标值计算代码如下： ```c++ unsigned int static GetNextTargetRequired(const CBlockIndex* pindexLast, bool fProofOfStake) { if (pindexLast == NULL) return bnProofOfWorkLimit.GetCompact(); // genesis block const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake); if (pindexPrev-&gt;pprev == NULL) return bnInitialHashTarget.GetCompact(); // first block const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev-&gt;pprev, fProofOfStake); if (pindexPrevPrev-&gt;pprev == NULL) return bnInitialHashTarget.GetCompact(); // second block int64 nActualSpacing = pindexPrev-&gt;GetBlockTime() - pindexPrevPrev-&gt;GetBlockTime(); // ppcoin: target change every block // ppcoin: retarget with exponential moving toward target spacing CBigNum bnNew; bnNew.SetCompact(pindexPrev-&gt;nBits); &nbsp;&nbsp;&nbsp;&nbsp;//STAKE_TARGET_SPACING为10分钟，即10 * 60 &nbsp;&nbsp;&nbsp;&nbsp;//两个区块目标间隔时间即为10分钟 int64 nTargetSpacing = fProofOfStake? STAKE_TARGET_SPACING : min(nTargetSpacingWorkMax, (int64) STAKE_TARGET_SPACING * (1 + pindexLast-&gt;nHeight - pindexPrev-&gt;nHeight)); &nbsp;&nbsp;&nbsp;&nbsp;//nTargetTimespan为1周，即7 * 24 * 60 * 60 &nbsp;&nbsp;&nbsp;&nbsp;//nInterval为1008，即区块间隔为10分钟时，1周产生1008个区块 int64 nInterval = nTargetTimespan / nTargetSpacing; &nbsp;&nbsp;&nbsp;&nbsp;//计算当前区块目标值 bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing); bnNew /= ((nInterval + 1) * nTargetSpacing); if (bnNew &gt; bnProofOfWorkLimit) bnNew = bnProofOfWorkLimit; return bnNew.GetCompact(); } //代码位置src/kernel.cpp ``` ### PoS 2.0的提出和黑币 为了进一步巩固PoS的安全，2014年rat4（Pavel Vasin）提出了PoS 2.0，并发布了黑币。 黑币前5000个块，为纯PoW阶段；第5001个块到第10000个块为PoW与PoS并存阶段，从第10001个块及以后为纯PoS阶段。 黑币首创快速挖矿+低股息发行模式，发行阶段采用POW方式，通过算法改进在短时间内无法制造出专用的GPU和AISC矿机，解决分配不公平的问题。 PoS2.0相比PoS的改进： * 1、将币龄从等式中拿掉。新系统采用如下公式计算权益证明： 　　proofhash &lt; 币数x目标值 点点币中，部分节点平时保持离线，只在积累了可观的币龄以后才连线获取利息，然后再次离线。 PoS 2.0中拿掉币龄，使得积攒币龄的方法不再有效，所有节点必须更多的保持在线，以进行权益累积。 越多的节点在线进行权益累积，系统遭遇51%攻击的可能性就越低。 * 2、为了防范预先计算攻击，权益修正因子每次均改变。 * 3、改变时间戳规则，以及哈希算法改用SHA256。 ### 黑币的PoS实现原理 黑币的PoS证明计算公式为： proofhash &lt; 币数x目标值 展开如下： hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime) &lt; bnTarget * nWeight 其中proofhash，对应一组数据的哈希值，即hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime)。 币数即nWeight，目标值即bnTarget。 blackcoin-1.2.4中PoS证明计算代码如下： ```c++ static bool CheckStakeKernelHashV2(CBlockIndex* pindexPrev, unsigned int nBits, unsigned int nTimeBlockFrom, const CTransaction&amp; txPrev, const COutPoint&amp; prevout, unsigned int nTimeTx, uint256&amp; hashProofOfStake, uint256&amp; targetProofOfStake, bool fPrintProofOfStake) { if (nTimeTx &lt; txPrev.nTime) // Transaction timestamp violation return error(&quot;CheckStakeKernelHash() : nTime violation&quot;); //目标值使用nBits CBigNum bnTarget; bnTarget.SetCompact(nBits); //计算币数x目标值 int64_t nValueIn = txPrev.vout[prevout.n].nValue; CBigNum bnWeight = CBigNum(nValueIn); bnTarget *= bnWeight; targetProofOfStake = bnTarget.getuint256(); &nbsp;&nbsp;&nbsp;&nbsp; //权重修正因子 uint64_t nStakeModifier = pindexPrev-&gt;nStakeModifier; uint256 bnStakeModifierV2 = pindexPrev-&gt;bnStakeModifierV2; int nStakeModifierHeight = pindexPrev-&gt;nHeight; int64_t nStakeModifierTime = pindexPrev-&gt;nTime; //计算哈希值 &nbsp;&nbsp;&nbsp;&nbsp; //即计算hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime) CDataStream ss(SER_GETHASH, 0); if (IsProtocolV3(nTimeTx)) ss &lt;&lt; bnStakeModifierV2; else ss &lt;&lt; nStakeModifier &lt;&lt; nTimeBlockFrom; ss &lt;&lt; txPrev.nTime &lt;&lt; prevout.hash &lt;&lt; prevout.n &lt;&lt; nTimeTx; hashProofOfStake = Hash(ss.begin(), ss.end()); if (fPrintProofOfStake) { LogPrintf(&quot;CheckStakeKernelHash() : using modifier 0x%016x at height=%d timestamp=%s for block from timestamp=%s\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime), DateTimeStrFormat(nTimeBlockFrom)); LogPrintf(&quot;CheckStakeKernelHash() : check modifier=0x%016x nTimeBlockFrom=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n&quot;, nStakeModifier, nTimeBlockFrom, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString()); } // Now check if proof-of-stake hash meets target protocol &nbsp;&nbsp;&nbsp;&nbsp; //判断是否满足proofhash &lt; 币数x目标值 if (CBigNum(hashProofOfStake) &gt; bnTarget) return false; if (fDebug &amp;&amp; !fPrintProofOfStake) { LogPrintf(&quot;CheckStakeKernelHash() : using modifier 0x%016x at height=%d timestamp=%s for block from timestamp=%s\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime), DateTimeStrFormat(nTimeBlockFrom)); LogPrintf(&quot;CheckStakeKernelHash() : pass modifier=0x%016x nTimeBlockFrom=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n&quot;, nStakeModifier, nTimeBlockFrom, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString()); } return true; } ``` ### 附录 * [ 点点币github]( https://github.com/peercoin) * [ 黑币github]( https://github.com/CoinBlack/blackcoin) * [ 点点币白皮书（中文版）]( https://github.com/fengchunjian/ConsensusAlgorithm/blob/master/pos/%E7%82%B9%E7%82%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89.pdf) * [ 黑币PoS协议2.0版白皮书]( https://github.com/fengchunjian/ConsensusAlgorithm/blob/master/pos/%E9%BB%91%E5%B8%81PoS%E5%8D%8F%E8%AE%AE2.0%E7%89%88%E7%99%BD%E7%9A%AE%E4%B9%A6.pdf) ### 后记 PoS有种种优点，但也有所缺陷。 即因为PoS并不消耗更多的算力，因此如果出现分叉，理性节点会在所有链上同时PoS挖矿。 以至于每次分叉都会形成新的山寨币，即PoS无法很好的应对分叉。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多" />
<meta property="og:description" content="# PoS权益证明算法原理及其在点点币、黑币中的实现 PoS，即Proof of Stake，译为权益证明。 无论PoW或PoS，均可以理解为“谁有资格写区块链”的问题。 PoW通过算力证明自己有资格写区块链，而PoS则是通过拥有的币龄来证明自己有资格写区块链。 ### PoW的优势和弊端 PoW，优势为可靠，使用广泛，是经历了充分的实践检验的公有链共识算法。 但其缺点也较为明显： * 1、消耗了太多额外算力，即大量能源。 * 2、资本大量投资矿机，导致算力中心化，有51%攻击的安全隐患。 ### PoS的提出和点点币 第一个基于PoS的虚拟币是点点币。 鉴于PoW的缺陷，2012年Sunny King提出了PoS，并基于PoW和PoS的混合机制发布了点点币PPCoin。 前期采用PoW挖矿开采和分配货币，以保证公平。后期采用PoS机制，保障网络安全，即拥有51%货币难度更大，从而防止51%攻击。 PoS核心概念为币龄，即持有货币的时间。例如有10个币、持有90天，即拥有900币天的币龄。 另外使用币，即意味着币龄的销毁。 在PoS中有一种特殊的交易称为利息币，即持有人可以消耗币龄获得利息，同时获得为网络产生区块、以及PoS造币的优先权。 ### 点点币的PoS实现原理 点点币的PoS证明计算公式为： proofhash &lt; 币龄x目标值 展开如下： hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime) &lt; bnTarget x bnCoinDayWeight * 其中proofhash，对应一组数据的哈希值，即hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime)。 * 币龄即bnCoinDayWeight，即币天，即持有的币数乘以持有币的天数，此处天数最大值为90天。 * 目标值，即bnTarget，用于衡量PoS挖矿难度。目标值与难度成反比，目标值越大、难度越小；反之亦然。 由公式可见，持有的币天越大，挖到区块的机会越大。 peercoin-0.6.1ppc中PoS证明计算代码如下： ```c++ bool CheckStakeKernelHash( unsigned int nBits, const CBlockHeader&amp; blockFrom, unsigned int nTxPrevOffset, const CTransaction&amp; txPrev, const COutPoint&amp; prevout, unsigned int nTimeTx, uint256&amp; hashProofOfStake, bool fPrintProofOfStake) { if (nTimeTx &lt; txPrev.nTime) // Transaction timestamp violation return error(&quot;CheckStakeKernelHash() : nTime violation&quot;); unsigned int nTimeBlockFrom = blockFrom.GetBlockTime(); if (nTimeBlockFrom + nStakeMinAge &gt; nTimeTx) // Min age requirement return error(&quot;CheckStakeKernelHash() : min age violation&quot;); &nbsp;&nbsp;&nbsp;&nbsp;//目标值使用nBits CBigNum bnTargetPerCoinDay; bnTargetPerCoinDay.SetCompact(nBits); int64 nValueIn = txPrev.vout[prevout.n].nValue; // v0.3 protocol kernel hash weight starts from 0 at the 30-day min age // this change increases active coins participating the hash and helps // to secure the network when proof-of-stake difficulty is low int64 nTimeWeight = min((int64)nTimeTx - txPrev.nTime, (int64)STAKE_MAX_AGE) - (IsProtocolV03(nTimeTx)? nStakeMinAge : 0); &nbsp;&nbsp;&nbsp;&nbsp;//计算币龄，STAKE_MAX_AGE为90天 CBigNum bnCoinDayWeight = CBigNum(nValueIn) * nTimeWeight / COIN / (24 * 60 * 60); // Calculate hash CDataStream ss(SER_GETHASH, 0); &nbsp;&nbsp;&nbsp;&nbsp;//权重修正因子 uint64 nStakeModifier = 0; int nStakeModifierHeight = 0; int64 nStakeModifierTime = 0; if (IsProtocolV03(nTimeTx)) // v0.3 protocol { if (!GetKernelStakeModifier(blockFrom.GetHash(), nTimeTx, nStakeModifier, nStakeModifierHeight, nStakeModifierTime, fPrintProofOfStake)) return false; ss &lt;&lt; nStakeModifier; } else // v0.2 protocol { ss &lt;&lt; nBits; } &nbsp;&nbsp;&nbsp;&nbsp;//计算proofhash &nbsp;&nbsp;&nbsp;&nbsp;//即计算hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime) ss &lt;&lt; nTimeBlockFrom &lt;&lt; nTxPrevOffset &lt;&lt; txPrev.nTime &lt;&lt; prevout.n &lt;&lt; nTimeTx; hashProofOfStake = Hash(ss.begin(), ss.end()); if (fPrintProofOfStake) { if (IsProtocolV03(nTimeTx)) printf(&quot;CheckStakeKernelHash() : using modifier 0x%016&quot; PRI64x&quot; at height=%d timestamp=%s for block from height=%d timestamp=%s\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime).c_str(), mapBlockIndex[blockFrom.GetHash()]-&gt;nHeight, DateTimeStrFormat(blockFrom.GetBlockTime()).c_str()); printf(&quot;CheckStakeKernelHash() : check protocol=%s modifier=0x%016&quot; PRI64x&quot; nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n&quot;, IsProtocolV05(nTimeTx)? &quot;0.5&quot; : (IsProtocolV03(nTimeTx)? &quot;0.3&quot; : &quot;0.2&quot;), IsProtocolV03(nTimeTx)? nStakeModifier : (uint64) nBits, nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString().c_str()); } // Now check if proof-of-stake hash meets target protocol &nbsp;&nbsp;&nbsp;&nbsp;//判断是否满足proofhash &lt; 币龄x目标值 if (CBigNum(hashProofOfStake) &gt; bnCoinDayWeight * bnTargetPerCoinDay) return false; if (fDebug &amp;&amp; !fPrintProofOfStake) { if (IsProtocolV03(nTimeTx)) printf(&quot;CheckStakeKernelHash() : using modifier 0x%016&quot; PRI64x&quot; at height=%d timestamp=%s for block from height=%d timestamp=%s\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime).c_str(), mapBlockIndex[blockFrom.GetHash()]-&gt;nHeight, DateTimeStrFormat(blockFrom.GetBlockTime()).c_str()); printf(&quot;CheckStakeKernelHash() : pass protocol=%s modifier=0x%016&quot; PRI64x&quot; nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n&quot;, IsProtocolV03(nTimeTx)? &quot;0.3&quot; : &quot;0.2&quot;, IsProtocolV03(nTimeTx)? nStakeModifier : (uint64) nBits, nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString().c_str()); } return true; } //代码位置src/kernel.cpp ``` ### 点点币的PoS挖矿难度 点点币使用目标值来衡量挖矿难度，目标值与难度成反比，目标值越大、难度越小；反之亦然。 当前区块的目标值与前一个区块目标值、前两个区块的时间间隔有关。 计算公式如下： 当前区块目标值 = 前一个区块目标值 x (1007x10x60 + 2x前两个区块时间间隔) / (1009x10x60) 由公式可见，两个区块目标间隔时间即为10分钟。 如果前两个区块时间间隔大于10分钟，目标值会提高，即当前区块难度会降低。 反之，如果前两个区块时间间隔小于10分钟，目标值会降低，即当前区块难度会提高。 peercoin-0.6.1ppc中目标值计算代码如下： ```c++ unsigned int static GetNextTargetRequired(const CBlockIndex* pindexLast, bool fProofOfStake) { if (pindexLast == NULL) return bnProofOfWorkLimit.GetCompact(); // genesis block const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake); if (pindexPrev-&gt;pprev == NULL) return bnInitialHashTarget.GetCompact(); // first block const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev-&gt;pprev, fProofOfStake); if (pindexPrevPrev-&gt;pprev == NULL) return bnInitialHashTarget.GetCompact(); // second block int64 nActualSpacing = pindexPrev-&gt;GetBlockTime() - pindexPrevPrev-&gt;GetBlockTime(); // ppcoin: target change every block // ppcoin: retarget with exponential moving toward target spacing CBigNum bnNew; bnNew.SetCompact(pindexPrev-&gt;nBits); &nbsp;&nbsp;&nbsp;&nbsp;//STAKE_TARGET_SPACING为10分钟，即10 * 60 &nbsp;&nbsp;&nbsp;&nbsp;//两个区块目标间隔时间即为10分钟 int64 nTargetSpacing = fProofOfStake? STAKE_TARGET_SPACING : min(nTargetSpacingWorkMax, (int64) STAKE_TARGET_SPACING * (1 + pindexLast-&gt;nHeight - pindexPrev-&gt;nHeight)); &nbsp;&nbsp;&nbsp;&nbsp;//nTargetTimespan为1周，即7 * 24 * 60 * 60 &nbsp;&nbsp;&nbsp;&nbsp;//nInterval为1008，即区块间隔为10分钟时，1周产生1008个区块 int64 nInterval = nTargetTimespan / nTargetSpacing; &nbsp;&nbsp;&nbsp;&nbsp;//计算当前区块目标值 bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing); bnNew /= ((nInterval + 1) * nTargetSpacing); if (bnNew &gt; bnProofOfWorkLimit) bnNew = bnProofOfWorkLimit; return bnNew.GetCompact(); } //代码位置src/kernel.cpp ``` ### PoS 2.0的提出和黑币 为了进一步巩固PoS的安全，2014年rat4（Pavel Vasin）提出了PoS 2.0，并发布了黑币。 黑币前5000个块，为纯PoW阶段；第5001个块到第10000个块为PoW与PoS并存阶段，从第10001个块及以后为纯PoS阶段。 黑币首创快速挖矿+低股息发行模式，发行阶段采用POW方式，通过算法改进在短时间内无法制造出专用的GPU和AISC矿机，解决分配不公平的问题。 PoS2.0相比PoS的改进： * 1、将币龄从等式中拿掉。新系统采用如下公式计算权益证明： 　　proofhash &lt; 币数x目标值 点点币中，部分节点平时保持离线，只在积累了可观的币龄以后才连线获取利息，然后再次离线。 PoS 2.0中拿掉币龄，使得积攒币龄的方法不再有效，所有节点必须更多的保持在线，以进行权益累积。 越多的节点在线进行权益累积，系统遭遇51%攻击的可能性就越低。 * 2、为了防范预先计算攻击，权益修正因子每次均改变。 * 3、改变时间戳规则，以及哈希算法改用SHA256。 ### 黑币的PoS实现原理 黑币的PoS证明计算公式为： proofhash &lt; 币数x目标值 展开如下： hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime) &lt; bnTarget * nWeight 其中proofhash，对应一组数据的哈希值，即hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime)。 币数即nWeight，目标值即bnTarget。 blackcoin-1.2.4中PoS证明计算代码如下： ```c++ static bool CheckStakeKernelHashV2(CBlockIndex* pindexPrev, unsigned int nBits, unsigned int nTimeBlockFrom, const CTransaction&amp; txPrev, const COutPoint&amp; prevout, unsigned int nTimeTx, uint256&amp; hashProofOfStake, uint256&amp; targetProofOfStake, bool fPrintProofOfStake) { if (nTimeTx &lt; txPrev.nTime) // Transaction timestamp violation return error(&quot;CheckStakeKernelHash() : nTime violation&quot;); //目标值使用nBits CBigNum bnTarget; bnTarget.SetCompact(nBits); //计算币数x目标值 int64_t nValueIn = txPrev.vout[prevout.n].nValue; CBigNum bnWeight = CBigNum(nValueIn); bnTarget *= bnWeight; targetProofOfStake = bnTarget.getuint256(); &nbsp;&nbsp;&nbsp;&nbsp; //权重修正因子 uint64_t nStakeModifier = pindexPrev-&gt;nStakeModifier; uint256 bnStakeModifierV2 = pindexPrev-&gt;bnStakeModifierV2; int nStakeModifierHeight = pindexPrev-&gt;nHeight; int64_t nStakeModifierTime = pindexPrev-&gt;nTime; //计算哈希值 &nbsp;&nbsp;&nbsp;&nbsp; //即计算hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime) CDataStream ss(SER_GETHASH, 0); if (IsProtocolV3(nTimeTx)) ss &lt;&lt; bnStakeModifierV2; else ss &lt;&lt; nStakeModifier &lt;&lt; nTimeBlockFrom; ss &lt;&lt; txPrev.nTime &lt;&lt; prevout.hash &lt;&lt; prevout.n &lt;&lt; nTimeTx; hashProofOfStake = Hash(ss.begin(), ss.end()); if (fPrintProofOfStake) { LogPrintf(&quot;CheckStakeKernelHash() : using modifier 0x%016x at height=%d timestamp=%s for block from timestamp=%s\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime), DateTimeStrFormat(nTimeBlockFrom)); LogPrintf(&quot;CheckStakeKernelHash() : check modifier=0x%016x nTimeBlockFrom=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n&quot;, nStakeModifier, nTimeBlockFrom, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString()); } // Now check if proof-of-stake hash meets target protocol &nbsp;&nbsp;&nbsp;&nbsp; //判断是否满足proofhash &lt; 币数x目标值 if (CBigNum(hashProofOfStake) &gt; bnTarget) return false; if (fDebug &amp;&amp; !fPrintProofOfStake) { LogPrintf(&quot;CheckStakeKernelHash() : using modifier 0x%016x at height=%d timestamp=%s for block from timestamp=%s\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime), DateTimeStrFormat(nTimeBlockFrom)); LogPrintf(&quot;CheckStakeKernelHash() : pass modifier=0x%016x nTimeBlockFrom=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n&quot;, nStakeModifier, nTimeBlockFrom, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString()); } return true; } ``` ### 附录 * [ 点点币github]( https://github.com/peercoin) * [ 黑币github]( https://github.com/CoinBlack/blackcoin) * [ 点点币白皮书（中文版）]( https://github.com/fengchunjian/ConsensusAlgorithm/blob/master/pos/%E7%82%B9%E7%82%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89.pdf) * [ 黑币PoS协议2.0版白皮书]( https://github.com/fengchunjian/ConsensusAlgorithm/blob/master/pos/%E9%BB%91%E5%B8%81PoS%E5%8D%8F%E8%AE%AE2.0%E7%89%88%E7%99%BD%E7%9A%AE%E4%B9%A6.pdf) ### 后记 PoS有种种优点，但也有所缺陷。 即因为PoS并不消耗更多的算力，因此如果出现分叉，理性节点会在所有链上同时PoS挖矿。 以至于每次分叉都会形成新的山寨币，即PoS无法很好的应对分叉。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-17T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"# PoS权益证明算法原理及其在点点币、黑币中的实现 PoS，即Proof of Stake，译为权益证明。 无论PoW或PoS，均可以理解为“谁有资格写区块链”的问题。 PoW通过算力证明自己有资格写区块链，而PoS则是通过拥有的币龄来证明自己有资格写区块链。 ### PoW的优势和弊端 PoW，优势为可靠，使用广泛，是经历了充分的实践检验的公有链共识算法。 但其缺点也较为明显： * 1、消耗了太多额外算力，即大量能源。 * 2、资本大量投资矿机，导致算力中心化，有51%攻击的安全隐患。 ### PoS的提出和点点币 第一个基于PoS的虚拟币是点点币。 鉴于PoW的缺陷，2012年Sunny King提出了PoS，并基于PoW和PoS的混合机制发布了点点币PPCoin。 前期采用PoW挖矿开采和分配货币，以保证公平。后期采用PoS机制，保障网络安全，即拥有51%货币难度更大，从而防止51%攻击。 PoS核心概念为币龄，即持有货币的时间。例如有10个币、持有90天，即拥有900币天的币龄。 另外使用币，即意味着币龄的销毁。 在PoS中有一种特殊的交易称为利息币，即持有人可以消耗币龄获得利息，同时获得为网络产生区块、以及PoS造币的优先权。 ### 点点币的PoS实现原理 点点币的PoS证明计算公式为： proofhash &lt; 币龄x目标值 展开如下： hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime) &lt; bnTarget x bnCoinDayWeight * 其中proofhash，对应一组数据的哈希值，即hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime)。 * 币龄即bnCoinDayWeight，即币天，即持有的币数乘以持有币的天数，此处天数最大值为90天。 * 目标值，即bnTarget，用于衡量PoS挖矿难度。目标值与难度成反比，目标值越大、难度越小；反之亦然。 由公式可见，持有的币天越大，挖到区块的机会越大。 peercoin-0.6.1ppc中PoS证明计算代码如下： ```c++ bool CheckStakeKernelHash( unsigned int nBits, const CBlockHeader&amp; blockFrom, unsigned int nTxPrevOffset, const CTransaction&amp; txPrev, const COutPoint&amp; prevout, unsigned int nTimeTx, uint256&amp; hashProofOfStake, bool fPrintProofOfStake) { if (nTimeTx &lt; txPrev.nTime) // Transaction timestamp violation return error(&quot;CheckStakeKernelHash() : nTime violation&quot;); unsigned int nTimeBlockFrom = blockFrom.GetBlockTime(); if (nTimeBlockFrom + nStakeMinAge &gt; nTimeTx) // Min age requirement return error(&quot;CheckStakeKernelHash() : min age violation&quot;); &nbsp;&nbsp;&nbsp;&nbsp;//目标值使用nBits CBigNum bnTargetPerCoinDay; bnTargetPerCoinDay.SetCompact(nBits); int64 nValueIn = txPrev.vout[prevout.n].nValue; // v0.3 protocol kernel hash weight starts from 0 at the 30-day min age // this change increases active coins participating the hash and helps // to secure the network when proof-of-stake difficulty is low int64 nTimeWeight = min((int64)nTimeTx - txPrev.nTime, (int64)STAKE_MAX_AGE) - (IsProtocolV03(nTimeTx)? nStakeMinAge : 0); &nbsp;&nbsp;&nbsp;&nbsp;//计算币龄，STAKE_MAX_AGE为90天 CBigNum bnCoinDayWeight = CBigNum(nValueIn) * nTimeWeight / COIN / (24 * 60 * 60); // Calculate hash CDataStream ss(SER_GETHASH, 0); &nbsp;&nbsp;&nbsp;&nbsp;//权重修正因子 uint64 nStakeModifier = 0; int nStakeModifierHeight = 0; int64 nStakeModifierTime = 0; if (IsProtocolV03(nTimeTx)) // v0.3 protocol { if (!GetKernelStakeModifier(blockFrom.GetHash(), nTimeTx, nStakeModifier, nStakeModifierHeight, nStakeModifierTime, fPrintProofOfStake)) return false; ss &lt;&lt; nStakeModifier; } else // v0.2 protocol { ss &lt;&lt; nBits; } &nbsp;&nbsp;&nbsp;&nbsp;//计算proofhash &nbsp;&nbsp;&nbsp;&nbsp;//即计算hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime) ss &lt;&lt; nTimeBlockFrom &lt;&lt; nTxPrevOffset &lt;&lt; txPrev.nTime &lt;&lt; prevout.n &lt;&lt; nTimeTx; hashProofOfStake = Hash(ss.begin(), ss.end()); if (fPrintProofOfStake) { if (IsProtocolV03(nTimeTx)) printf(&quot;CheckStakeKernelHash() : using modifier 0x%016&quot; PRI64x&quot; at height=%d timestamp=%s for block from height=%d timestamp=%s\\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime).c_str(), mapBlockIndex[blockFrom.GetHash()]-&gt;nHeight, DateTimeStrFormat(blockFrom.GetBlockTime()).c_str()); printf(&quot;CheckStakeKernelHash() : check protocol=%s modifier=0x%016&quot; PRI64x&quot; nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n&quot;, IsProtocolV05(nTimeTx)? &quot;0.5&quot; : (IsProtocolV03(nTimeTx)? &quot;0.3&quot; : &quot;0.2&quot;), IsProtocolV03(nTimeTx)? nStakeModifier : (uint64) nBits, nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString().c_str()); } // Now check if proof-of-stake hash meets target protocol &nbsp;&nbsp;&nbsp;&nbsp;//判断是否满足proofhash &lt; 币龄x目标值 if (CBigNum(hashProofOfStake) &gt; bnCoinDayWeight * bnTargetPerCoinDay) return false; if (fDebug &amp;&amp; !fPrintProofOfStake) { if (IsProtocolV03(nTimeTx)) printf(&quot;CheckStakeKernelHash() : using modifier 0x%016&quot; PRI64x&quot; at height=%d timestamp=%s for block from height=%d timestamp=%s\\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime).c_str(), mapBlockIndex[blockFrom.GetHash()]-&gt;nHeight, DateTimeStrFormat(blockFrom.GetBlockTime()).c_str()); printf(&quot;CheckStakeKernelHash() : pass protocol=%s modifier=0x%016&quot; PRI64x&quot; nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n&quot;, IsProtocolV03(nTimeTx)? &quot;0.3&quot; : &quot;0.2&quot;, IsProtocolV03(nTimeTx)? nStakeModifier : (uint64) nBits, nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString().c_str()); } return true; } //代码位置src/kernel.cpp ``` ### 点点币的PoS挖矿难度 点点币使用目标值来衡量挖矿难度，目标值与难度成反比，目标值越大、难度越小；反之亦然。 当前区块的目标值与前一个区块目标值、前两个区块的时间间隔有关。 计算公式如下： 当前区块目标值 = 前一个区块目标值 x (1007x10x60 + 2x前两个区块时间间隔) / (1009x10x60) 由公式可见，两个区块目标间隔时间即为10分钟。 如果前两个区块时间间隔大于10分钟，目标值会提高，即当前区块难度会降低。 反之，如果前两个区块时间间隔小于10分钟，目标值会降低，即当前区块难度会提高。 peercoin-0.6.1ppc中目标值计算代码如下： ```c++ unsigned int static GetNextTargetRequired(const CBlockIndex* pindexLast, bool fProofOfStake) { if (pindexLast == NULL) return bnProofOfWorkLimit.GetCompact(); // genesis block const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake); if (pindexPrev-&gt;pprev == NULL) return bnInitialHashTarget.GetCompact(); // first block const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev-&gt;pprev, fProofOfStake); if (pindexPrevPrev-&gt;pprev == NULL) return bnInitialHashTarget.GetCompact(); // second block int64 nActualSpacing = pindexPrev-&gt;GetBlockTime() - pindexPrevPrev-&gt;GetBlockTime(); // ppcoin: target change every block // ppcoin: retarget with exponential moving toward target spacing CBigNum bnNew; bnNew.SetCompact(pindexPrev-&gt;nBits); &nbsp;&nbsp;&nbsp;&nbsp;//STAKE_TARGET_SPACING为10分钟，即10 * 60 &nbsp;&nbsp;&nbsp;&nbsp;//两个区块目标间隔时间即为10分钟 int64 nTargetSpacing = fProofOfStake? STAKE_TARGET_SPACING : min(nTargetSpacingWorkMax, (int64) STAKE_TARGET_SPACING * (1 + pindexLast-&gt;nHeight - pindexPrev-&gt;nHeight)); &nbsp;&nbsp;&nbsp;&nbsp;//nTargetTimespan为1周，即7 * 24 * 60 * 60 &nbsp;&nbsp;&nbsp;&nbsp;//nInterval为1008，即区块间隔为10分钟时，1周产生1008个区块 int64 nInterval = nTargetTimespan / nTargetSpacing; &nbsp;&nbsp;&nbsp;&nbsp;//计算当前区块目标值 bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing); bnNew /= ((nInterval + 1) * nTargetSpacing); if (bnNew &gt; bnProofOfWorkLimit) bnNew = bnProofOfWorkLimit; return bnNew.GetCompact(); } //代码位置src/kernel.cpp ``` ### PoS 2.0的提出和黑币 为了进一步巩固PoS的安全，2014年rat4（Pavel Vasin）提出了PoS 2.0，并发布了黑币。 黑币前5000个块，为纯PoW阶段；第5001个块到第10000个块为PoW与PoS并存阶段，从第10001个块及以后为纯PoS阶段。 黑币首创快速挖矿+低股息发行模式，发行阶段采用POW方式，通过算法改进在短时间内无法制造出专用的GPU和AISC矿机，解决分配不公平的问题。 PoS2.0相比PoS的改进： * 1、将币龄从等式中拿掉。新系统采用如下公式计算权益证明： 　　proofhash &lt; 币数x目标值 点点币中，部分节点平时保持离线，只在积累了可观的币龄以后才连线获取利息，然后再次离线。 PoS 2.0中拿掉币龄，使得积攒币龄的方法不再有效，所有节点必须更多的保持在线，以进行权益累积。 越多的节点在线进行权益累积，系统遭遇51%攻击的可能性就越低。 * 2、为了防范预先计算攻击，权益修正因子每次均改变。 * 3、改变时间戳规则，以及哈希算法改用SHA256。 ### 黑币的PoS实现原理 黑币的PoS证明计算公式为： proofhash &lt; 币数x目标值 展开如下： hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime) &lt; bnTarget * nWeight 其中proofhash，对应一组数据的哈希值，即hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime)。 币数即nWeight，目标值即bnTarget。 blackcoin-1.2.4中PoS证明计算代码如下： ```c++ static bool CheckStakeKernelHashV2(CBlockIndex* pindexPrev, unsigned int nBits, unsigned int nTimeBlockFrom, const CTransaction&amp; txPrev, const COutPoint&amp; prevout, unsigned int nTimeTx, uint256&amp; hashProofOfStake, uint256&amp; targetProofOfStake, bool fPrintProofOfStake) { if (nTimeTx &lt; txPrev.nTime) // Transaction timestamp violation return error(&quot;CheckStakeKernelHash() : nTime violation&quot;); //目标值使用nBits CBigNum bnTarget; bnTarget.SetCompact(nBits); //计算币数x目标值 int64_t nValueIn = txPrev.vout[prevout.n].nValue; CBigNum bnWeight = CBigNum(nValueIn); bnTarget *= bnWeight; targetProofOfStake = bnTarget.getuint256(); &nbsp;&nbsp;&nbsp;&nbsp; //权重修正因子 uint64_t nStakeModifier = pindexPrev-&gt;nStakeModifier; uint256 bnStakeModifierV2 = pindexPrev-&gt;bnStakeModifierV2; int nStakeModifierHeight = pindexPrev-&gt;nHeight; int64_t nStakeModifierTime = pindexPrev-&gt;nTime; //计算哈希值 &nbsp;&nbsp;&nbsp;&nbsp; //即计算hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime) CDataStream ss(SER_GETHASH, 0); if (IsProtocolV3(nTimeTx)) ss &lt;&lt; bnStakeModifierV2; else ss &lt;&lt; nStakeModifier &lt;&lt; nTimeBlockFrom; ss &lt;&lt; txPrev.nTime &lt;&lt; prevout.hash &lt;&lt; prevout.n &lt;&lt; nTimeTx; hashProofOfStake = Hash(ss.begin(), ss.end()); if (fPrintProofOfStake) { LogPrintf(&quot;CheckStakeKernelHash() : using modifier 0x%016x at height=%d timestamp=%s for block from timestamp=%s\\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime), DateTimeStrFormat(nTimeBlockFrom)); LogPrintf(&quot;CheckStakeKernelHash() : check modifier=0x%016x nTimeBlockFrom=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n&quot;, nStakeModifier, nTimeBlockFrom, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString()); } // Now check if proof-of-stake hash meets target protocol &nbsp;&nbsp;&nbsp;&nbsp; //判断是否满足proofhash &lt; 币数x目标值 if (CBigNum(hashProofOfStake) &gt; bnTarget) return false; if (fDebug &amp;&amp; !fPrintProofOfStake) { LogPrintf(&quot;CheckStakeKernelHash() : using modifier 0x%016x at height=%d timestamp=%s for block from timestamp=%s\\n&quot;, nStakeModifier, nStakeModifierHeight, DateTimeStrFormat(nStakeModifierTime), DateTimeStrFormat(nTimeBlockFrom)); LogPrintf(&quot;CheckStakeKernelHash() : pass modifier=0x%016x nTimeBlockFrom=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n&quot;, nStakeModifier, nTimeBlockFrom, txPrev.nTime, prevout.n, nTimeTx, hashProofOfStake.ToString()); } return true; } ``` ### 附录 * [ 点点币github]( https://github.com/peercoin) * [ 黑币github]( https://github.com/CoinBlack/blackcoin) * [ 点点币白皮书（中文版）]( https://github.com/fengchunjian/ConsensusAlgorithm/blob/master/pos/%E7%82%B9%E7%82%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89.pdf) * [ 黑币PoS协议2.0版白皮书]( https://github.com/fengchunjian/ConsensusAlgorithm/blob/master/pos/%E9%BB%91%E5%B8%81PoS%E5%8D%8F%E8%AE%AE2.0%E7%89%88%E7%99%BD%E7%9A%AE%E4%B9%A6.pdf) ### 后记 PoS有种种优点，但也有所缺陷。 即因为PoS并不消耗更多的算力，因此如果出现分叉，理性节点会在所有链上同时PoS挖矿。 以至于每次分叉都会形成新的山寨币，即PoS无法很好的应对分叉。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多","@type":"BlogPosting","url":"/2018/05/17/68a8b70ffcaa0823c58303c3b6d78d0c.html","headline":"区块链共识算法(3)PoS权益证明算法","dateModified":"2018-05-17T00:00:00+08:00","datePublished":"2018-05-17T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/05/17/68a8b70ffcaa0823c58303c3b6d78d0c.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链共识算法(3)PoS权益证明算法</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas, 'Courier New', monospace;font-size:14px;line-height:19px;">
   <div>
    <span style="color:#569cd6;"><strong># PoS权益证明算法原理及其在点点币、黑币中的实现</strong></span>
   </div>
   <br>
   <div>
    PoS，即Proof of Stake，译为权益证明。
   </div>
   <div>
    无论PoW或PoS，均可以理解为“谁有资格写区块链”的问题。
   </div>
   <div>
    PoW通过算力证明自己有资格写区块链，而PoS则是通过拥有的币龄来证明自己有资格写区块链。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### PoW的优势和弊端</strong></span>
   </div>
   <br>
   <div>
    PoW，优势为可靠，使用广泛，是经历了充分的实践检验的公有链共识算法。
   </div>
   <div>
    但其缺点也较为明显：
   </div>
   <div>
    <span style="color:#6796e6;">*</span> 1、消耗了太多额外算力，即大量能源。
   </div>
   <div>
    <span style="color:#6796e6;">*</span> 2、资本大量投资矿机，导致算力中心化，有51%攻击的安全隐患。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### PoS的提出和点点币</strong></span>
   </div>
   <br>
   <div>
    第一个基于PoS的虚拟币是点点币。
   </div>
   <div>
    鉴于PoW的缺陷，2012年Sunny King提出了PoS，并基于PoW和PoS的混合机制发布了点点币PPCoin。
   </div>
   <div>
    前期采用PoW挖矿开采和分配货币，以保证公平。后期采用PoS机制，保障网络安全，即拥有51%货币难度更大，从而防止51%攻击。
   </div>
   <br>
   <div>
    PoS核心概念为币龄，即持有货币的时间。例如有10个币、持有90天，即拥有900币天的币龄。
   </div>
   <div>
    另外使用币，即意味着币龄的销毁。
   </div>
   <div>
    在PoS中有一种特殊的交易称为利息币，即持有人可以消耗币龄获得利息，同时获得为网络产生区块、以及PoS造币的优先权。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 点点币的PoS实现原理</strong></span>
   </div>
   <br>
   <div>
    点点币的PoS证明计算公式为：
   </div>
   <br>
   <div>
    proofhash &lt; 币龄x目标值
   </div>
   <br>
   <div>
    展开如下：
   </div>
   <br>
   <div>
    hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime) &lt; bnTarget x bnCoinDayWeight
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">*</span> 其中proofhash，对应一组数据的哈希值，即hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime)。
   </div>
   <div>
    <span style="color:#6796e6;">*</span> 币龄即bnCoinDayWeight，即币天，即持有的币数乘以持有币的天数，此处天数最大值为90天。
   </div>
   <div>
    <span style="color:#6796e6;">*</span> 目标值，即bnTarget，用于衡量PoS挖矿难度。目标值与难度成反比，目标值越大、难度越小；反之亦然。
   </div>
   <br>
   <div>
    由公式可见，持有的币天越大，挖到区块的机会越大。
   </div>
   <br>
   <div>
    peercoin-0.6.1ppc中PoS证明计算代码如下：
   </div>
   <br>
   <div>
    ```c++
   </div>
   <div>
    <span style="color:#569cd6;">bool</span> 
    <span style="color:#dcdcaa;">CheckStakeKernelHash</span>(
    <span style="color:#569cd6;">unsigned</span> 
    <span style="color:#569cd6;">int</span> nBits, const CBlockHeader&amp; blockFrom, 
    <span style="color:#569cd6;">unsigned</span> 
    <span style="color:#569cd6;">int</span> nTxPrevOffset, const CTransaction&amp; txPrev, const COutPoint&amp; prevout, 
    <span style="color:#569cd6;">unsigned</span> 
    <span style="color:#569cd6;">int</span> nTimeTx, uint256&amp; hashProofOfStake, 
    <span style="color:#569cd6;">bool</span> fPrintProofOfStake)
   </div>
   <div>
    {
   </div>
   <div>
     if (nTimeTx &lt; txPrev.nTime) // Transaction timestamp violation
   </div>
   <div>
     return error("CheckStakeKernelHash() : nTime violation");
   </div>
   <br>
   <div>
     unsigned int nTimeBlockFrom = blockFrom.GetBlockTime();
   </div>
   <div>
     if (nTimeBlockFrom + nStakeMinAge &gt; nTimeTx) // Min age requirement
   </div>
   <div>
     return error("CheckStakeKernelHash() : min age violation");
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//目标值使用nBits
   </div>
   <div>
     CBigNum bnTargetPerCoinDay;
   </div>
   <div>
     bnTargetPerCoinDay.SetCompact(nBits);
   </div>
   <div>
     int64 nValueIn = txPrev.vout[prevout.n].nValue;
   </div>
   <div>
     // v0.3 protocol kernel hash weight starts from 0 at the 30-day min age
   </div>
   <div>
     // this change increases active coins participating the hash and helps
   </div>
   <div>
     // to secure the network when proof-of-stake difficulty is low
   </div>
   <div>
     int64 nTimeWeight = min((int64)nTimeTx - txPrev.nTime, (int64)STAKE_MAX_AGE) - (IsProtocolV03(nTimeTx)? nStakeMinAge : 0);
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//计算币龄，STAKE_MAX_AGE为90天
   </div>
   <div>
     CBigNum bnCoinDayWeight = CBigNum(nValueIn) * nTimeWeight / COIN / (24 * 60 * 60);
   </div>
   <div>
     // Calculate hash
   </div>
   <div>
     CDataStream ss(SER_GETHASH, 0);
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//权重修正因子
   </div>
   <div>
     uint64 nStakeModifier = 0;
   </div>
   <div>
     int nStakeModifierHeight = 0;
   </div>
   <div>
     int64 nStakeModifierTime = 0;
   </div>
   <div>
     if (IsProtocolV03(nTimeTx)) // v0.3 protocol
   </div>
   <div>
     {
   </div>
   <div>
     if (!GetKernelStakeModifier(blockFrom.GetHash(), nTimeTx, nStakeModifier, nStakeModifierHeight, nStakeModifierTime, fPrintProofOfStake))
   </div>
   <div>
     return false;
   </div>
   <div>
     ss &lt;&lt; nStakeModifier;
   </div>
   <div>
     }
   </div>
   <div>
     else // v0.2 protocol
   </div>
   <div>
     {
   </div>
   <div>
     ss &lt;&lt; nBits;
   </div>
   <div>
     }
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//计算proofhash
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//即计算hash(nStakeModifier + txPrev.block.nTime + txPrev.offset + txPrev.nTime + txPrev.vout.n + nTime)
   </div>
   <div>
     ss &lt;&lt; nTimeBlockFrom &lt;&lt; nTxPrevOffset &lt;&lt; txPrev.nTime &lt;&lt; prevout.n &lt;&lt; nTimeTx;
   </div>
   <div>
     hashProofOfStake = Hash(ss.begin(), ss.end());
   </div>
   <div>
     if (fPrintProofOfStake)
   </div>
   <div>
     {
   </div>
   <div>
     if (IsProtocolV03(nTimeTx))
   </div>
   <div>
     printf("CheckStakeKernelHash() : using modifier 0x%016" PRI64x" at height=%d timestamp=%s for block from height=%d timestamp=%s\n",
   </div>
   <div>
     nStakeModifier, nStakeModifierHeight,
   </div>
   <div>
     DateTimeStrFormat(nStakeModifierTime).c_str(),
   </div>
   <div>
     mapBlockIndex[blockFrom.GetHash()]-&gt;nHeight,
   </div>
   <div>
     DateTimeStrFormat(blockFrom.GetBlockTime()).c_str());
   </div>
   <div>
     printf("CheckStakeKernelHash() : check protocol=%s modifier=0x%016" PRI64x" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n",
   </div>
   <div>
     IsProtocolV05(nTimeTx)? "0.5" : (IsProtocolV03(nTimeTx)? "0.3" : "0.2"),
   </div>
   <div>
     IsProtocolV03(nTimeTx)? nStakeModifier : (uint64) nBits,
   </div>
   <div>
     nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx,
   </div>
   <div>
     hashProofOfStake.ToString().c_str());
   </div>
   <div>
     }
   </div>
   <br>
   <div>
     // Now check if proof-of-stake hash meets target protocol
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//判断是否满足proofhash &lt; 币龄x目标值
   </div>
   <div>
     if (CBigNum(hashProofOfStake) &gt; bnCoinDayWeight * bnTargetPerCoinDay)
   </div>
   <div>
     return false;
   </div>
   <div>
     if (fDebug &amp;&amp; !fPrintProofOfStake)
   </div>
   <div>
     {
   </div>
   <div>
     if (IsProtocolV03(nTimeTx))
   </div>
   <div>
     printf("CheckStakeKernelHash() : using modifier 0x%016" PRI64x" at height=%d timestamp=%s for block from height=%d timestamp=%s\n",
   </div>
   <div>
     nStakeModifier, nStakeModifierHeight, 
   </div>
   <div>
     DateTimeStrFormat(nStakeModifierTime).c_str(),
   </div>
   <div>
     mapBlockIndex[blockFrom.GetHash()]-&gt;nHeight,
   </div>
   <div>
     DateTimeStrFormat(blockFrom.GetBlockTime()).c_str());
   </div>
   <div>
     printf("CheckStakeKernelHash() : pass protocol=%s modifier=0x%016" PRI64x" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n",
   </div>
   <div>
     IsProtocolV03(nTimeTx)? "0.3" : "0.2",
   </div>
   <div>
     IsProtocolV03(nTimeTx)? nStakeModifier : (uint64) nBits,
   </div>
   <div>
     nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx,
   </div>
   <div>
     hashProofOfStake.ToString().c_str());
   </div>
   <div>
     }
   </div>
   <div>
     return true;
   </div>
   <div>
    }
   </div>
   <div>
    <span style="color:#608b4e;">//代码位置src/kernel.cpp</span>
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 点点币的PoS挖矿难度</strong></span>
   </div>
   <br>
   <div>
    点点币使用目标值来衡量挖矿难度，目标值与难度成反比，目标值越大、难度越小；反之亦然。
   </div>
   <div>
    当前区块的目标值与前一个区块目标值、前两个区块的时间间隔有关。
   </div>
   <br>
   <div>
    计算公式如下：
   </div>
   <br>
   <div>
    当前区块目标值 = 前一个区块目标值 x (1007x10x60 + 2x前两个区块时间间隔) / (1009x10x60)
   </div>
   <br>
   <div>
    由公式可见，两个区块目标间隔时间即为10分钟。
   </div>
   <div>
    如果前两个区块时间间隔大于10分钟，目标值会提高，即当前区块难度会降低。
   </div>
   <div>
    反之，如果前两个区块时间间隔小于10分钟，目标值会降低，即当前区块难度会提高。
   </div>
   <br>
   <div>
    peercoin-0.6.1ppc中目标值计算代码如下：
   </div>
   <br>
   <div>
    ```c++
   </div>
   <div>
    <span style="color:#569cd6;">unsigned</span> 
    <span style="color:#569cd6;">int</span> 
    <span style="color:#569cd6;">static</span> 
    <span style="color:#dcdcaa;">GetNextTargetRequired</span>(const CBlockIndex* pindexLast, bool fProofOfStake)
   </div>
   <div>
    {
   </div>
   <div>
     if (pindexLast == NULL)
   </div>
   <div>
     return bnProofOfWorkLimit.GetCompact(); // genesis block
   </div>
   <br>
   <div>
     const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake);
   </div>
   <div>
     if (pindexPrev-&gt;pprev == NULL)
   </div>
   <div>
     return bnInitialHashTarget.GetCompact(); // first block
   </div>
   <div>
     const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev-&gt;pprev, fProofOfStake);
   </div>
   <div>
     if (pindexPrevPrev-&gt;pprev == NULL)
   </div>
   <div>
     return bnInitialHashTarget.GetCompact(); // second block
   </div>
   <br>
   <div>
     int64 nActualSpacing = pindexPrev-&gt;GetBlockTime() - pindexPrevPrev-&gt;GetBlockTime();
   </div>
   <br>
   <div> 
    <span style="color:#608b4e;">// ppcoin: target change every block</span>
   </div>
   <div> 
    <span style="color:#608b4e;">// ppcoin: retarget with exponential moving toward target spacing</span>
   </div>
   <div>
     CBigNum bnNew;
   </div>
   <div>
     bnNew.SetCompact(pindexPrev-&gt;nBits);
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//STAKE_TARGET_SPACING为10分钟，即10 * 60
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//两个区块目标间隔时间即为10分钟
   </div>
   <div>
     int64 nTargetSpacing = fProofOfStake? STAKE_TARGET_SPACING : min(nTargetSpacingWorkMax, (int64) STAKE_TARGET_SPACING * (1 + pindexLast-&gt;nHeight - pindexPrev-&gt;nHeight));
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//nTargetTimespan为1周，即7 * 24 * 60 * 60
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//nInterval为1008，即区块间隔为10分钟时，1周产生1008个区块
   </div>
   <div>
     int64 nInterval = nTargetTimespan / nTargetSpacing;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//计算当前区块目标值
   </div>
   <div>
     bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing);
   </div>
   <div>
     bnNew /= ((nInterval + 1) * nTargetSpacing);
   </div>
   <br>
   <div>
     if (bnNew &gt; bnProofOfWorkLimit)
   </div>
   <div>
     bnNew = bnProofOfWorkLimit;
   </div>
   <br>
   <div>
     return bnNew.GetCompact();
   </div>
   <div>
    }
   </div>
   <div>
    <span style="color:#608b4e;">//代码位置src/kernel.cpp</span>
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### PoS 2.0的提出和黑币</strong></span>
   </div>
   <br>
   <div>
    为了进一步巩固PoS的安全，2014年rat4（Pavel Vasin）提出了PoS 2.0，并发布了黑币。
   </div>
   <div>
    黑币前5000个块，为纯PoW阶段；第5001个块到第10000个块为PoW与PoS并存阶段，从第10001个块及以后为纯PoS阶段。
   </div>
   <div>
    黑币首创快速挖矿+低股息发行模式，发行阶段采用POW方式，通过算法改进在短时间内无法制造出专用的GPU和AISC矿机，解决分配不公平的问题。
   </div>
   <br>
   <div>
    PoS2.0相比PoS的改进：
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">*</span> 1、将币龄从等式中拿掉。新系统采用如下公式计算权益证明：
   </div>
   <br>
   <div>
    　　proofhash &lt; 币数x目标值
   </div>
   <br>
   <div>
    点点币中，部分节点平时保持离线，只在积累了可观的币龄以后才连线获取利息，然后再次离线。
   </div>
   <div>
    PoS 2.0中拿掉币龄，使得积攒币龄的方法不再有效，所有节点必须更多的保持在线，以进行权益累积。
   </div>
   <div>
    越多的节点在线进行权益累积，系统遭遇51%攻击的可能性就越低。
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">*</span> 2、为了防范预先计算攻击，权益修正因子每次均改变。
   </div>
   <div>
    <span style="color:#6796e6;">*</span> 3、改变时间戳规则，以及哈希算法改用SHA256。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 黑币的PoS实现原理</strong></span>
   </div>
   <br>
   <div>
    黑币的PoS证明计算公式为：
   </div>
   <br>
   <div>
    proofhash &lt; 币数x目标值
   </div>
   <br>
   <div>
    展开如下：
   </div>
   <br>
   <div>
    hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime) &lt; bnTarget * nWeight
   </div>
   <br>
   <div>
    其中proofhash，对应一组数据的哈希值，即hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime)。
   </div>
   <div>
    币数即nWeight，目标值即bnTarget。
   </div>
   <br>
   <div>
    blackcoin-1.2.4中PoS证明计算代码如下：
   </div>
   <br>
   <div>
    ```c++
   </div>
   <div>
    <span style="color:#569cd6;">static</span> 
    <span style="color:#569cd6;">bool</span> 
    <span style="color:#dcdcaa;">CheckStakeKernelHashV2</span>(CBlockIndex* pindexPrev, unsigned int nBits, unsigned int nTimeBlockFrom, const CTransaction&amp; txPrev, const COutPoint&amp; prevout, unsigned int nTimeTx, uint256&amp; hashProofOfStake, uint256&amp; targetProofOfStake, bool fPrintProofOfStake)
   </div>
   <div>
    {
   </div>
   <div>
     if (nTimeTx &lt; txPrev.nTime) // Transaction timestamp violation
   </div>
   <div>
     return error("CheckStakeKernelHash() : nTime violation");
   </div>
   <br>
   <div> 
    <span style="color:#608b4e;">//目标值使用nBits</span>
   </div>
   <div>
     CBigNum bnTarget;
   </div>
   <div>
     bnTarget.SetCompact(nBits);
   </div>
   <br>
   <div> 
    <span style="color:#608b4e;">//计算币数x目标值</span>
   </div>
   <div>
     int64_t nValueIn = txPrev.vout[prevout.n].nValue;
   </div>
   <div>
     CBigNum bnWeight = CBigNum(nValueIn);
   </div>
   <div>
     bnTarget *= bnWeight;
   </div>
   <br>
   <div>
     targetProofOfStake = bnTarget.getuint256();
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//权重修正因子</span>
   </div>
   <div>
     uint64_t nStakeModifier = pindexPrev-&gt;nStakeModifier;
   </div>
   <div>
     uint256 bnStakeModifierV2 = pindexPrev-&gt;bnStakeModifierV2;
   </div>
   <div>
     int nStakeModifierHeight = pindexPrev-&gt;nHeight;
   </div>
   <div>
     int64_t nStakeModifierTime = pindexPrev-&gt;nTime;
   </div>
   <br>
   <div> 
    <span style="color:#608b4e;">//计算哈希值</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//即计算hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime)</span>
   </div>
   <div>
     CDataStream ss(SER_GETHASH, 0);
   </div>
   <div>
     if (IsProtocolV3(nTimeTx))
   </div>
   <div>
     ss &lt;&lt; bnStakeModifierV2;
   </div>
   <div>
     else
   </div>
   <div>
     ss &lt;&lt; nStakeModifier &lt;&lt; nTimeBlockFrom;
   </div>
   <div>
     ss &lt;&lt; txPrev.nTime &lt;&lt; prevout.hash &lt;&lt; prevout.n &lt;&lt; nTimeTx;
   </div>
   <div>
     hashProofOfStake = Hash(ss.begin(), ss.end());
   </div>
   <br>
   <div>
     if (fPrintProofOfStake)
   </div>
   <div>
     {
   </div>
   <div>
     LogPrintf("CheckStakeKernelHash() : using modifier 0x%016x at height=%d timestamp=%s for block from timestamp=%s\n",
   </div>
   <div>
     nStakeModifier, nStakeModifierHeight,
   </div>
   <div>
     DateTimeStrFormat(nStakeModifierTime),
   </div>
   <div>
     DateTimeStrFormat(nTimeBlockFrom));
   </div>
   <div>
     LogPrintf("CheckStakeKernelHash() : check modifier=0x%016x nTimeBlockFrom=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n",
   </div>
   <div>
     nStakeModifier,
   </div>
   <div>
     nTimeBlockFrom, txPrev.nTime, prevout.n, nTimeTx,
   </div>
   <div>
     hashProofOfStake.ToString());
   </div>
   <div>
     }
   </div>
   <br>
   <div> 
    <span style="color:#608b4e;">// Now check if proof-of-stake hash meets target protocol</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//判断是否满足proofhash &lt; 币数x目标值</span>
   </div>
   <div>
     if (CBigNum(hashProofOfStake) &gt; bnTarget)
   </div>
   <div>
     return false;
   </div>
   <br>
   <div>
     if (fDebug &amp;&amp; !fPrintProofOfStake)
   </div>
   <div>
     {
   </div>
   <div>
     LogPrintf("CheckStakeKernelHash() : using modifier 0x%016x at height=%d timestamp=%s for block from timestamp=%s\n",
   </div>
   <div>
     nStakeModifier, nStakeModifierHeight,
   </div>
   <div>
     DateTimeStrFormat(nStakeModifierTime),
   </div>
   <div>
     DateTimeStrFormat(nTimeBlockFrom));
   </div>
   <div>
     LogPrintf("CheckStakeKernelHash() : pass modifier=0x%016x nTimeBlockFrom=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\n",
   </div>
   <div>
     nStakeModifier,
   </div>
   <div>
     nTimeBlockFrom, txPrev.nTime, prevout.n, nTimeTx,
   </div>
   <div>
     hashProofOfStake.ToString());
   </div>
   <div>
     }
   </div>
   <br>
   <div>
     return true;
   </div>
   <div>
    }
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 附录</strong></span>
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">*</span> [
    <span style="color:#ce9178;">点点币github</span>](
    <span>https://github.com/peercoin</span>)
   </div>
   <div>
    <span style="color:#6796e6;">*</span> [
    <span style="color:#ce9178;">黑币github</span>](
    <span>https://github.com/CoinBlack/blackcoin</span>)
   </div>
   <div>
    <span style="color:#6796e6;">*</span> [
    <span style="color:#ce9178;">点点币白皮书（中文版）</span>](
    <span>https://github.com/fengchunjian/ConsensusAlgorithm/blob/master/pos/%E7%82%B9%E7%82%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89.pdf</span>)
   </div>
   <div>
    <span style="color:#6796e6;">*</span> [
    <span style="color:#ce9178;">黑币PoS协议2.0版白皮书</span>](
    <span>https://github.com/fengchunjian/ConsensusAlgorithm/blob/master/pos/%E9%BB%91%E5%B8%81PoS%E5%8D%8F%E8%AE%AE2.0%E7%89%88%E7%99%BD%E7%9A%AE%E4%B9%A6.pdf</span>)
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 后记</strong></span>
   </div>
   <br>
   <div>
    PoS有种种优点，但也有所缺陷。
   </div>
   <div>
    即因为PoS并不消耗更多的算力，因此如果出现分叉，理性节点会在所有链上同时PoS挖矿。
   </div>
   <div>
    以至于每次分叉都会形成新的山寨币，即PoS无法很好的应对分叉。
   </div>
  </div>
  <p></p>
  <p><br></p>
  <p><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180425001235188?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180425001144107?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);">网址：http://www.qukuailianxueyuan.io/<br></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180426145827720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018042614570887?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);">欲领取造币技术与全套虚拟机资料</p>
  <p style="background-color:rgb(255,255,255);"><span style="color:rgb(25,25,25);">区块链技术交流QQ群：</span><span style="color:rgb(255,0,0);">756146052&nbsp;&nbsp;</span><span style="color:rgb(25,25,25);">备注：CSDN</span></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);">尹成学院微信：备注：CSDN</p>
  <p style="color:rgb(25,25,25);text-align:center;background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180425000635656?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yincheng0571/article/details/80349159,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yincheng0571/article/details/80349159,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
