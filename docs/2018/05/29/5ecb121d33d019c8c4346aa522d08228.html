<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>EOS合约开发第十七章-合约通信编程 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="EOS合约开发第十七章-合约通信编程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="合约通信编程 一、EOS通知概述 我们首先看一看eosio.token合约中issue的通知。跳过基本的合约和账户配置，我们直接进入eosio.token合约，首先创建一个token： [kingnet@pdev1 nodeos1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token create &#39;{&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;100000000000.0000 EOS&quot;,&quot;can_freeze&quot;:0,&quot;can_recall&quot;:0,&quot;can_whitelist&quot;:0}&#39; -p eosio.token executed transaction: 756ecf4050184dd06c7f27d77cca3864e41fa3c319b23c326180d7cc386b62d9 120 bytes 6597 us # eosio.token &lt;= eosio.token::create {&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;100000000000.0000 EOS&quot;,&quot;can_freeze&quot;:0,&quot;can_recall&quot;:0,&quot;can_whitel... warning: transaction executed locally, but may not be confirmed by the network yet 然后eosio向配置好的账户helloworld发行token： [kingnet@pdev1 dice]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token issue &#39;{&quot;to&quot;:&quot;helloworld&quot;, &quot;quantity&quot;:&quot;100.0000 EOS&quot;, &quot;memo&quot;:&quot;m&quot;}&#39; -p eosio executed transaction: 732e883ae259644de6c4442a0b4007fdbc0d1b95157c5b000a3f7c9cbb1eecf7 120 bytes 1871 us # eosio.token &lt;= eosio.token::issue {&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; issueeosio balance: 100.0000 EOS # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; transfer from eosio to helloworld 100.0000 EOS # eosio &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} # helloworld &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} warning: transaction executed locally, but may not be confirmed by the network yet 从以上issue合约执行的日志中可以看出账户之间存在多次的通知，可以用以下图来描述整个消息流： eosio.token合约首先收到issue action的消息，在eosio.token合约执行时发起了一个新的transfer action消息给eosio.token合约，即发给自己，如下是issue action代码片段： void token::issue( account_name to, asset quantity, string memo ) { print( &quot;issue&quot; ); auto sym = quantity.symbol; eosio_assert( sym.is_valid(), &quot;invalid symbol name&quot; ); auto sym_name = sym.name(); stats statstable( _self, sym_name ); auto existing = statstable.find( sym_name ); eosio_assert( existing != statstable.end(), &quot;token with symbol does not exist, create token before issue&quot; ); const auto&amp; st = *existing; require_auth( st.issuer ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must issue positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); eosio_assert( quantity.amount &lt;= st.max_supply.amount - st.supply.amount, &quot;quantity exceeds available supply&quot;); statstable.modify( st, 0, [&amp;]( auto&amp; s ) { s.supply += quantity; }); add_balance( st.issuer, quantity, st, st.issuer ); if( to != st.issuer ) { SEND_INLINE_ACTION( *this, transfer, {st.issuer,N(active)}, {st.issuer, to, quantity, memo} ); } } 我可以看到在第27行，发送了一个action，采用的是inline方式（这是eos两种通信方式的一种，还有一种是Deferred&nbsp;），发送到自己即eosio.token的transfer action上。 以下是eosio.token的transfer action代码片段： void token::transfer( account_name from, account_name to, asset quantity, string /*memo*/ ) { print( &quot;transfer from &quot;, eosio::name{from}, &quot; to &quot;, eosio::name{to}, &quot; &quot;, quantity, &quot;\n&quot; ); eosio_assert( from != to, &quot;cannot transfer to self&quot; ); require_auth( from ); eosio_assert( is_account( to ), &quot;to account does not exist&quot;); auto sym = quantity.symbol.name(); stats statstable( _self, sym ); const auto&amp; st = statstable.get( sym ); require_recipient( from ); require_recipient( to ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must transfer positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); sub_balance( from, quantity, st ); add_balance( to, quantity, st, from ); } 从第14、15行可以看到其给from和to（即eosio和helloworld）各发送一个通知消息。 那么该通知信息会被eosio和helloworld两个账户收到吗？如果账户能收到通知消息，通知消息发送给账户时的参数又是什么呢？那么账户怎么处理通知消息呢？通过以下编程来深入了解EOS的通知消息。 二、EOS通知编程 我们创建三个合约，模拟两个游戏玩家在对战平台玩游戏的场景，游戏玩家1执行合约action后，游戏平台将收到玩家1请求，平台合约将执行玩家1的请求，同时将结果分别通知给游戏玩家1和游戏玩家2以通知其更新数据，游戏玩家完成更新后再通知平台合约已完成更新。在每个合约入口我们都首先将合约参数写入数据库中以跟踪整个通知流程。 游戏平台合约： /** * * The apply() methods must have C calling convention so that the blockchain can lookup and * * call these methods. * */ #include &lt;eosiolib/eosio.hpp&gt; extern &quot;C&quot; { struct gameinfo { uint64_t id; account_name player1; uint64_t x1; uint64_t y1; account_name player2; uint64_t x2; uint64_t y2; uint64_t info; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( gameinfo, (id)(player)(x)(y) ) }; typedef eosio::multi_index&lt; N(gameinfo), gameinfo&gt; gameinfo_index; struct notifyinfo { uint64_t id; account_name receiver; account_name code; account_name action; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) ) }; typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index; struct dummy_action { account_name player1; account_name player2; uint64_t info; }; /// The apply method implements the dispatch of events to this contract void apply( uint64_t receiver, uint64_t code, uint64_t action ) { // auto _self = receiver; { notifyinfo_index notifyinfos(_self, _self); auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = notifyinfos.available_primary_key(); info.receiver = receiver; info.code = code; info.action = action; }); } // if(receiver == code &amp;&amp; action == N(creategame)) { dummy_action dummy = eosio::unpack_action_data&lt;dummy_action&gt;(); gameinfo_index gameinfos(_self, _self); auto new_gameinfos_itr = gameinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = gameinfos.available_primary_key(); info.player1 = dummy.player1; info.x1 = 0; info.y1 = 0; info.player2 = dummy.player2; info.x2 = 0; info.y2 = 0; info.info = dummy.info; }); // require_recipient(dummy.player1); require_recipient(dummy.player2); } else if(action == N(creategame)) { // do something.... // } else if(receiver == code &amp;&amp; action == N(reset)) { gameinfo_index gameinfos(_self, _self); auto cur_gameinfos_itr = gameinfos.begin(); while(cur_gameinfos_itr != gameinfos.end()) { cur_gameinfos_itr = gameinfos.erase(cur_gameinfos_itr); } notifyinfo_index notifyinfos(_self, _self); auto cur_notifyinfos_itr = notifyinfos.begin(); while(cur_notifyinfos_itr != notifyinfos.end()) { cur_notifyinfos_itr = notifyinfos.erase(cur_notifyinfos_itr); } } } } // extern &quot;C&quot; 用户合约代码： /** * * The apply() methods must have C calling convention so that the blockchain can lookup and * * call these methods. * */ #include &lt;eosiolib/eosio.hpp&gt; extern &quot;C&quot; { struct gameinfo { uint64_t id; account_name player1; uint64_t x1; uint64_t y1; account_name player2; uint64_t x2; uint64_t y2; uint64_t info; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( gameinfo, (id)(player)(x)(y) ) }; typedef eosio::multi_index&lt; N(gameinfo), gameinfo&gt; gameinfo_index; struct notifyinfo { uint64_t id; account_name receiver; account_name code; account_name action; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) ) }; typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index; struct dummy_action { account_name player1; account_name player2; uint64_t info; }; /// The apply method implements the dispatch of events to this contract void apply( uint64_t receiver, uint64_t code, uint64_t action ) { auto _self = receiver; { notifyinfo_index notifyinfos(_self, _self); auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = notifyinfos.available_primary_key(); info.receiver = receiver; info.code = code; info.action = action; }); } // if(action == N(creategame)) { dummy_action dummy = eosio::unpack_action_data&lt;dummy_action&gt;(); gameinfo_index gameinfos(_self, _self); auto new_gameinfos_itr = gameinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = gameinfos.available_primary_key(); info.player1 = dummy.player1; info.x1 = 0; info.y1 = 0; info.player2 = dummy.player2; info.x2 = 0; info.y2 = 0; info.info = dummy.info; }); // require_recipient(code); } } } // extern &quot;C&quot; 我们将创建三个账户，分别运行游戏平台合约和两个游戏玩家合约： [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.s EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: c7dc538ecf56ba612eae50eb266848e1ae6a9907cbbab62ae8ade48018c38644 200 bytes 451 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;game.s&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcfnVPJq... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.c.1 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: f44bdfa622c06fb170e5b564bca0fd52f69d4cfc068bad9546a820ad822d6ece 200 bytes 403 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;game.c.1&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcfnVP... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.c.2 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: c52b61f22f6df8b46ac7a8623e3114404cfc2dceec81363abfee094f7e450c28 200 bytes 476 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;game.c.2&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcfnVP... warning: transaction executed locally, but may not be confirmed by the network yet 在游戏平台账户上部署游戏平台合约： [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.s /home/kingnet/tangy/eos/mycontracts/test_notify_s/ Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_s/test_notify_s.wasm... Using already assembled WASM... Publishing contract... executed transaction: 240396da31c7d4d193befc07bfe4db4956a250e0760a0156adeae8d3979a7017 3848 bytes 1273 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;game.s&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001560f6000006000017e60027e7e006... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;game.s&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;creategame&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;p... warning: transaction executed locally, but may not be confirmed by the network yet 分别在两个游戏玩家账户张部署游戏客户端合约： [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.c.1 /home/kingnet/tangy/eos/mycontracts/test_notify_g1 Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_g1/test_notify_g1.wasm... Using already assembled WASM... Publishing contract... executed transaction: 1c1b448f52cd4bca5c251cacf56c93ffaa49abfb2a03d7e065b18068f522cb9b 3368 bytes 1201 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;game.c.1&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001560f6000006000017e60027e7e0... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;game.c.1&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;gameinfo&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;i... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.c.2 /home/kingnet/tangy/eos/mycontracts/test_notify_g1 Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_g1/test_notify_g1.wasm... Using already assembled WASM... Publishing contract... executed transaction: d3456d22a8ea450edbf1ee014833dbd00aecc6fd22883fbe500460681bae653b 3368 bytes 1000 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;game.c.2&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001560f6000006000017e60027e7e0... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;game.c.2&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;gameinfo&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;i... warning: transaction executed locally, but may not be confirmed by the network yet 我们接下来执行一次游戏创建操作： [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action game.s creategame &#39;{&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}&#39; -p game.s executed transaction: 5048ffd4082325ca9f72ad9ac2c6fd7f3a6befbf87766343b064b57b6fac2fd5 120 bytes 4871 us # game.s &lt;= game.s::creategame {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1} # game.c.1 &lt;= game.s::creategame {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1} # game.c.2 &lt;= game.s::creategame {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1} warning: transaction executed locally, but may not be confirmed by the network yet 从以上执行的结果可以看到，creategame这个action首先发给了game.s，这是我们发起的，这个action消息又转发给了game.c.1和game.c.2，这是我们在creategame这个action中发送的通知消息。 我们可以继续看看每个合约账户上收到的action通知消息： [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.s # seq when contract::action =&gt; receiver trx id... args ================================================================================================================ # 0 2018-05-17T09:56:55.500 eosio::setcode =&gt; eosio 240396da... {&quot;account&quot;:&quot;game.s&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736... # 1 2018-05-17T09:56:55.500 eosio::setabi =&gt; eosio 240396da... {&quot;account&quot;:&quot;game.s&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;cr... # 2 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.s 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... # 3 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.1 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... # 4 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.2 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.c.1 # seq when contract::action =&gt; receiver trx id... args ================================================================================================================ # 0 2018-05-17T09:59:50.500 eosio::setcode =&gt; eosio 1c1b448f... {&quot;account&quot;:&quot;game.c.1&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;00617... # 1 2018-05-17T09:59:50.500 eosio::setabi =&gt; eosio 1c1b448f... {&quot;account&quot;:&quot;game.c.1&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;... # 2 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.1 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.c.2 # seq when contract::action =&gt; receiver trx id... args ================================================================================================================ # 0 2018-05-17T10:00:05.000 eosio::setcode =&gt; eosio d3456d22... {&quot;account&quot;:&quot;game.c.2&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;00617... # 1 2018-05-17T10:00:05.000 eosio::setabi =&gt; eosio d3456d22... {&quot;account&quot;:&quot;game.c.2&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;... # 2 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.2 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... 我们在入口跟踪了通知消息并写入了数据库，如果查看数据库可以得出一致的消息，同时我们在收到通知后也正确解析了请求的参数，查看数据库可以得到数据库中三个表的内容完全一致。 我们现在可以回答上面关于eos通知消息的问题了： 1. 向一个合约发送的通知会被这个合约接收并在应用层处理吗？ 一个合约向另一个合约发出的通知消息会被另一个合约收到，不管有没有ABI定义接口，都会在应用层收到。 2. 参数是什么呢？ 一个合约向另一个合约发送的通知消息就是本合约收到的消息，包括code、action和参数 3. 账户如何处理该通知消息呢？ 和处理正常的消息一样，根据code、action和参数进行逻辑处理 三、拒绝接受转账交易及DoS 我们目前已经清楚了eos合约通知机制，同时也知道了给一个账户转账交易会给该账户消息通知，其实我们还有一个疑问，如果账户合约处理通知消息失败了，那么这个交易状态会回滚么？ 我们现在开发一个合约，合约处理交易的transfer事件通知，在通知处理程序中，我们抛出一个异常，使得该通知处理失败。同时我们照样在入口记录所有收到的action。 我们会将该合约部署在账户test.notify上。我们转账给test.notify，那么eosio.token合约的transfer action会被执行，在eosio.token合约执行转账时，给向目标账户test.notify发送事件通知，但事件通知处理失败了，到底这个转账交易会回滚么？ 拒绝接收转账合约： /** * * The apply() methods must have C calling convention so that the blockchain can lookup and * * call these methods. * */ #include &lt;eosiolib/eosio.hpp&gt; extern &quot;C&quot; { struct notifyinfo { uint64_t id; account_name receiver; account_name code; account_name action; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) ) }; typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index; /// The apply method implements the dispatch of events to this contract void apply( uint64_t receiver, uint64_t code, uint64_t action ) { auto _self = receiver; notifyinfo_index notifyinfos(_self, _self); auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = notifyinfos.available_primary_key(); info.receiver = receiver; info.code = code; info.action = action; }); if(action == N(transfer)) { eosio_assert(&quot;reject transfer!&quot;); } if(receiver == code &amp;&amp; action == N(reset)) { auto cur_notify_itr = notifyinfos.begin(); while(cur_notify_itr != notifyinfos.end()) { cur_notify_itr = notifyinfos.erase(cur_notify_itr); } } } } // extern &quot;C&quot; 我们执行转账操作并检查结果： [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio test.notify EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: 4576dec103dab2abfbfff775f8208c8fff46996cc9d3717d576574544f381d72 200 bytes 476 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;test.notify&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcf... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract test.notify /home/kingnet/tangy/eos/mycontracts/test_notify Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify/test_notify.wasm... Using already assembled WASM... Publishing contract... executed transaction: 7bd410a214ed2700eea182bebcdf94304ee49911e8f0c53dcfa58068150067d4 5048 bytes 1200 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;test.notify&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001520e6000006000017e60027e... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;test.notify&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;hi&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;user... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token issue &#39;{&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;, &quot;memo&quot;:&quot;m&quot;}&#39; -p eosio executed transaction: 995b01cd4206ee19894400f09d2d0bbbba1b5d9e74010438447387e4be1f226e 120 bytes 10667 us # eosio.token &lt;= eosio.token::issue {&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; issueeosio balance: 1001.0000 EOS # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; transfer from eosio to test.notify 1.0000 EOS # eosio &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} # test.notify &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get currency balance eosio.token test.notify 1001.0000 EOS [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token transfer &#39;{&quot;from&quot;:&quot;alice&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;}&#39; -p alice 1566956ms thread-0 main.cpp:2316 main ] Failed with error: Assert Exception (10) condition: assertion failed: reject transfer! [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get currency balance eosio.token test.notify 1001.0000 EOS 我们可以看到转账失败了，这个失败是由转账的接收方处理转账通知事件时给出错误应答引起的，这样就可以让一个账户拒绝接收转账。 这个例子演示了时事件通知处理失败会导致整个交易回滚，如果一个transaction中包含了许多的action，但只要某一个账户处理action的通知事件失败将引起整个交易回滚，这样某一个账户可以进行DoS（拒绝服务攻击）。 下一章介绍EOS合约中通信编程。 阅读更多" />
<meta property="og:description" content="合约通信编程 一、EOS通知概述 我们首先看一看eosio.token合约中issue的通知。跳过基本的合约和账户配置，我们直接进入eosio.token合约，首先创建一个token： [kingnet@pdev1 nodeos1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token create &#39;{&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;100000000000.0000 EOS&quot;,&quot;can_freeze&quot;:0,&quot;can_recall&quot;:0,&quot;can_whitelist&quot;:0}&#39; -p eosio.token executed transaction: 756ecf4050184dd06c7f27d77cca3864e41fa3c319b23c326180d7cc386b62d9 120 bytes 6597 us # eosio.token &lt;= eosio.token::create {&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;100000000000.0000 EOS&quot;,&quot;can_freeze&quot;:0,&quot;can_recall&quot;:0,&quot;can_whitel... warning: transaction executed locally, but may not be confirmed by the network yet 然后eosio向配置好的账户helloworld发行token： [kingnet@pdev1 dice]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token issue &#39;{&quot;to&quot;:&quot;helloworld&quot;, &quot;quantity&quot;:&quot;100.0000 EOS&quot;, &quot;memo&quot;:&quot;m&quot;}&#39; -p eosio executed transaction: 732e883ae259644de6c4442a0b4007fdbc0d1b95157c5b000a3f7c9cbb1eecf7 120 bytes 1871 us # eosio.token &lt;= eosio.token::issue {&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; issueeosio balance: 100.0000 EOS # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; transfer from eosio to helloworld 100.0000 EOS # eosio &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} # helloworld &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} warning: transaction executed locally, but may not be confirmed by the network yet 从以上issue合约执行的日志中可以看出账户之间存在多次的通知，可以用以下图来描述整个消息流： eosio.token合约首先收到issue action的消息，在eosio.token合约执行时发起了一个新的transfer action消息给eosio.token合约，即发给自己，如下是issue action代码片段： void token::issue( account_name to, asset quantity, string memo ) { print( &quot;issue&quot; ); auto sym = quantity.symbol; eosio_assert( sym.is_valid(), &quot;invalid symbol name&quot; ); auto sym_name = sym.name(); stats statstable( _self, sym_name ); auto existing = statstable.find( sym_name ); eosio_assert( existing != statstable.end(), &quot;token with symbol does not exist, create token before issue&quot; ); const auto&amp; st = *existing; require_auth( st.issuer ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must issue positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); eosio_assert( quantity.amount &lt;= st.max_supply.amount - st.supply.amount, &quot;quantity exceeds available supply&quot;); statstable.modify( st, 0, [&amp;]( auto&amp; s ) { s.supply += quantity; }); add_balance( st.issuer, quantity, st, st.issuer ); if( to != st.issuer ) { SEND_INLINE_ACTION( *this, transfer, {st.issuer,N(active)}, {st.issuer, to, quantity, memo} ); } } 我可以看到在第27行，发送了一个action，采用的是inline方式（这是eos两种通信方式的一种，还有一种是Deferred&nbsp;），发送到自己即eosio.token的transfer action上。 以下是eosio.token的transfer action代码片段： void token::transfer( account_name from, account_name to, asset quantity, string /*memo*/ ) { print( &quot;transfer from &quot;, eosio::name{from}, &quot; to &quot;, eosio::name{to}, &quot; &quot;, quantity, &quot;\n&quot; ); eosio_assert( from != to, &quot;cannot transfer to self&quot; ); require_auth( from ); eosio_assert( is_account( to ), &quot;to account does not exist&quot;); auto sym = quantity.symbol.name(); stats statstable( _self, sym ); const auto&amp; st = statstable.get( sym ); require_recipient( from ); require_recipient( to ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must transfer positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); sub_balance( from, quantity, st ); add_balance( to, quantity, st, from ); } 从第14、15行可以看到其给from和to（即eosio和helloworld）各发送一个通知消息。 那么该通知信息会被eosio和helloworld两个账户收到吗？如果账户能收到通知消息，通知消息发送给账户时的参数又是什么呢？那么账户怎么处理通知消息呢？通过以下编程来深入了解EOS的通知消息。 二、EOS通知编程 我们创建三个合约，模拟两个游戏玩家在对战平台玩游戏的场景，游戏玩家1执行合约action后，游戏平台将收到玩家1请求，平台合约将执行玩家1的请求，同时将结果分别通知给游戏玩家1和游戏玩家2以通知其更新数据，游戏玩家完成更新后再通知平台合约已完成更新。在每个合约入口我们都首先将合约参数写入数据库中以跟踪整个通知流程。 游戏平台合约： /** * * The apply() methods must have C calling convention so that the blockchain can lookup and * * call these methods. * */ #include &lt;eosiolib/eosio.hpp&gt; extern &quot;C&quot; { struct gameinfo { uint64_t id; account_name player1; uint64_t x1; uint64_t y1; account_name player2; uint64_t x2; uint64_t y2; uint64_t info; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( gameinfo, (id)(player)(x)(y) ) }; typedef eosio::multi_index&lt; N(gameinfo), gameinfo&gt; gameinfo_index; struct notifyinfo { uint64_t id; account_name receiver; account_name code; account_name action; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) ) }; typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index; struct dummy_action { account_name player1; account_name player2; uint64_t info; }; /// The apply method implements the dispatch of events to this contract void apply( uint64_t receiver, uint64_t code, uint64_t action ) { // auto _self = receiver; { notifyinfo_index notifyinfos(_self, _self); auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = notifyinfos.available_primary_key(); info.receiver = receiver; info.code = code; info.action = action; }); } // if(receiver == code &amp;&amp; action == N(creategame)) { dummy_action dummy = eosio::unpack_action_data&lt;dummy_action&gt;(); gameinfo_index gameinfos(_self, _self); auto new_gameinfos_itr = gameinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = gameinfos.available_primary_key(); info.player1 = dummy.player1; info.x1 = 0; info.y1 = 0; info.player2 = dummy.player2; info.x2 = 0; info.y2 = 0; info.info = dummy.info; }); // require_recipient(dummy.player1); require_recipient(dummy.player2); } else if(action == N(creategame)) { // do something.... // } else if(receiver == code &amp;&amp; action == N(reset)) { gameinfo_index gameinfos(_self, _self); auto cur_gameinfos_itr = gameinfos.begin(); while(cur_gameinfos_itr != gameinfos.end()) { cur_gameinfos_itr = gameinfos.erase(cur_gameinfos_itr); } notifyinfo_index notifyinfos(_self, _self); auto cur_notifyinfos_itr = notifyinfos.begin(); while(cur_notifyinfos_itr != notifyinfos.end()) { cur_notifyinfos_itr = notifyinfos.erase(cur_notifyinfos_itr); } } } } // extern &quot;C&quot; 用户合约代码： /** * * The apply() methods must have C calling convention so that the blockchain can lookup and * * call these methods. * */ #include &lt;eosiolib/eosio.hpp&gt; extern &quot;C&quot; { struct gameinfo { uint64_t id; account_name player1; uint64_t x1; uint64_t y1; account_name player2; uint64_t x2; uint64_t y2; uint64_t info; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( gameinfo, (id)(player)(x)(y) ) }; typedef eosio::multi_index&lt; N(gameinfo), gameinfo&gt; gameinfo_index; struct notifyinfo { uint64_t id; account_name receiver; account_name code; account_name action; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) ) }; typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index; struct dummy_action { account_name player1; account_name player2; uint64_t info; }; /// The apply method implements the dispatch of events to this contract void apply( uint64_t receiver, uint64_t code, uint64_t action ) { auto _self = receiver; { notifyinfo_index notifyinfos(_self, _self); auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = notifyinfos.available_primary_key(); info.receiver = receiver; info.code = code; info.action = action; }); } // if(action == N(creategame)) { dummy_action dummy = eosio::unpack_action_data&lt;dummy_action&gt;(); gameinfo_index gameinfos(_self, _self); auto new_gameinfos_itr = gameinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = gameinfos.available_primary_key(); info.player1 = dummy.player1; info.x1 = 0; info.y1 = 0; info.player2 = dummy.player2; info.x2 = 0; info.y2 = 0; info.info = dummy.info; }); // require_recipient(code); } } } // extern &quot;C&quot; 我们将创建三个账户，分别运行游戏平台合约和两个游戏玩家合约： [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.s EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: c7dc538ecf56ba612eae50eb266848e1ae6a9907cbbab62ae8ade48018c38644 200 bytes 451 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;game.s&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcfnVPJq... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.c.1 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: f44bdfa622c06fb170e5b564bca0fd52f69d4cfc068bad9546a820ad822d6ece 200 bytes 403 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;game.c.1&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcfnVP... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.c.2 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: c52b61f22f6df8b46ac7a8623e3114404cfc2dceec81363abfee094f7e450c28 200 bytes 476 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;game.c.2&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcfnVP... warning: transaction executed locally, but may not be confirmed by the network yet 在游戏平台账户上部署游戏平台合约： [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.s /home/kingnet/tangy/eos/mycontracts/test_notify_s/ Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_s/test_notify_s.wasm... Using already assembled WASM... Publishing contract... executed transaction: 240396da31c7d4d193befc07bfe4db4956a250e0760a0156adeae8d3979a7017 3848 bytes 1273 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;game.s&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001560f6000006000017e60027e7e006... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;game.s&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;creategame&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;p... warning: transaction executed locally, but may not be confirmed by the network yet 分别在两个游戏玩家账户张部署游戏客户端合约： [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.c.1 /home/kingnet/tangy/eos/mycontracts/test_notify_g1 Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_g1/test_notify_g1.wasm... Using already assembled WASM... Publishing contract... executed transaction: 1c1b448f52cd4bca5c251cacf56c93ffaa49abfb2a03d7e065b18068f522cb9b 3368 bytes 1201 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;game.c.1&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001560f6000006000017e60027e7e0... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;game.c.1&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;gameinfo&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;i... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.c.2 /home/kingnet/tangy/eos/mycontracts/test_notify_g1 Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_g1/test_notify_g1.wasm... Using already assembled WASM... Publishing contract... executed transaction: d3456d22a8ea450edbf1ee014833dbd00aecc6fd22883fbe500460681bae653b 3368 bytes 1000 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;game.c.2&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001560f6000006000017e60027e7e0... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;game.c.2&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;gameinfo&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;i... warning: transaction executed locally, but may not be confirmed by the network yet 我们接下来执行一次游戏创建操作： [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action game.s creategame &#39;{&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}&#39; -p game.s executed transaction: 5048ffd4082325ca9f72ad9ac2c6fd7f3a6befbf87766343b064b57b6fac2fd5 120 bytes 4871 us # game.s &lt;= game.s::creategame {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1} # game.c.1 &lt;= game.s::creategame {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1} # game.c.2 &lt;= game.s::creategame {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1} warning: transaction executed locally, but may not be confirmed by the network yet 从以上执行的结果可以看到，creategame这个action首先发给了game.s，这是我们发起的，这个action消息又转发给了game.c.1和game.c.2，这是我们在creategame这个action中发送的通知消息。 我们可以继续看看每个合约账户上收到的action通知消息： [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.s # seq when contract::action =&gt; receiver trx id... args ================================================================================================================ # 0 2018-05-17T09:56:55.500 eosio::setcode =&gt; eosio 240396da... {&quot;account&quot;:&quot;game.s&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736... # 1 2018-05-17T09:56:55.500 eosio::setabi =&gt; eosio 240396da... {&quot;account&quot;:&quot;game.s&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;cr... # 2 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.s 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... # 3 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.1 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... # 4 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.2 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.c.1 # seq when contract::action =&gt; receiver trx id... args ================================================================================================================ # 0 2018-05-17T09:59:50.500 eosio::setcode =&gt; eosio 1c1b448f... {&quot;account&quot;:&quot;game.c.1&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;00617... # 1 2018-05-17T09:59:50.500 eosio::setabi =&gt; eosio 1c1b448f... {&quot;account&quot;:&quot;game.c.1&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;... # 2 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.1 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.c.2 # seq when contract::action =&gt; receiver trx id... args ================================================================================================================ # 0 2018-05-17T10:00:05.000 eosio::setcode =&gt; eosio d3456d22... {&quot;account&quot;:&quot;game.c.2&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;00617... # 1 2018-05-17T10:00:05.000 eosio::setabi =&gt; eosio d3456d22... {&quot;account&quot;:&quot;game.c.2&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;... # 2 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.2 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... 我们在入口跟踪了通知消息并写入了数据库，如果查看数据库可以得出一致的消息，同时我们在收到通知后也正确解析了请求的参数，查看数据库可以得到数据库中三个表的内容完全一致。 我们现在可以回答上面关于eos通知消息的问题了： 1. 向一个合约发送的通知会被这个合约接收并在应用层处理吗？ 一个合约向另一个合约发出的通知消息会被另一个合约收到，不管有没有ABI定义接口，都会在应用层收到。 2. 参数是什么呢？ 一个合约向另一个合约发送的通知消息就是本合约收到的消息，包括code、action和参数 3. 账户如何处理该通知消息呢？ 和处理正常的消息一样，根据code、action和参数进行逻辑处理 三、拒绝接受转账交易及DoS 我们目前已经清楚了eos合约通知机制，同时也知道了给一个账户转账交易会给该账户消息通知，其实我们还有一个疑问，如果账户合约处理通知消息失败了，那么这个交易状态会回滚么？ 我们现在开发一个合约，合约处理交易的transfer事件通知，在通知处理程序中，我们抛出一个异常，使得该通知处理失败。同时我们照样在入口记录所有收到的action。 我们会将该合约部署在账户test.notify上。我们转账给test.notify，那么eosio.token合约的transfer action会被执行，在eosio.token合约执行转账时，给向目标账户test.notify发送事件通知，但事件通知处理失败了，到底这个转账交易会回滚么？ 拒绝接收转账合约： /** * * The apply() methods must have C calling convention so that the blockchain can lookup and * * call these methods. * */ #include &lt;eosiolib/eosio.hpp&gt; extern &quot;C&quot; { struct notifyinfo { uint64_t id; account_name receiver; account_name code; account_name action; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) ) }; typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index; /// The apply method implements the dispatch of events to this contract void apply( uint64_t receiver, uint64_t code, uint64_t action ) { auto _self = receiver; notifyinfo_index notifyinfos(_self, _self); auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = notifyinfos.available_primary_key(); info.receiver = receiver; info.code = code; info.action = action; }); if(action == N(transfer)) { eosio_assert(&quot;reject transfer!&quot;); } if(receiver == code &amp;&amp; action == N(reset)) { auto cur_notify_itr = notifyinfos.begin(); while(cur_notify_itr != notifyinfos.end()) { cur_notify_itr = notifyinfos.erase(cur_notify_itr); } } } } // extern &quot;C&quot; 我们执行转账操作并检查结果： [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio test.notify EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: 4576dec103dab2abfbfff775f8208c8fff46996cc9d3717d576574544f381d72 200 bytes 476 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;test.notify&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcf... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract test.notify /home/kingnet/tangy/eos/mycontracts/test_notify Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify/test_notify.wasm... Using already assembled WASM... Publishing contract... executed transaction: 7bd410a214ed2700eea182bebcdf94304ee49911e8f0c53dcfa58068150067d4 5048 bytes 1200 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;test.notify&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001520e6000006000017e60027e... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;test.notify&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;hi&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;user... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token issue &#39;{&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;, &quot;memo&quot;:&quot;m&quot;}&#39; -p eosio executed transaction: 995b01cd4206ee19894400f09d2d0bbbba1b5d9e74010438447387e4be1f226e 120 bytes 10667 us # eosio.token &lt;= eosio.token::issue {&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; issueeosio balance: 1001.0000 EOS # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; transfer from eosio to test.notify 1.0000 EOS # eosio &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} # test.notify &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get currency balance eosio.token test.notify 1001.0000 EOS [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token transfer &#39;{&quot;from&quot;:&quot;alice&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;}&#39; -p alice 1566956ms thread-0 main.cpp:2316 main ] Failed with error: Assert Exception (10) condition: assertion failed: reject transfer! [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get currency balance eosio.token test.notify 1001.0000 EOS 我们可以看到转账失败了，这个失败是由转账的接收方处理转账通知事件时给出错误应答引起的，这样就可以让一个账户拒绝接收转账。 这个例子演示了时事件通知处理失败会导致整个交易回滚，如果一个transaction中包含了许多的action，但只要某一个账户处理action的通知事件失败将引起整个交易回滚，这样某一个账户可以进行DoS（拒绝服务攻击）。 下一章介绍EOS合约中通信编程。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"合约通信编程 一、EOS通知概述 我们首先看一看eosio.token合约中issue的通知。跳过基本的合约和账户配置，我们直接进入eosio.token合约，首先创建一个token： [kingnet@pdev1 nodeos1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token create &#39;{&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;100000000000.0000 EOS&quot;,&quot;can_freeze&quot;:0,&quot;can_recall&quot;:0,&quot;can_whitelist&quot;:0}&#39; -p eosio.token executed transaction: 756ecf4050184dd06c7f27d77cca3864e41fa3c319b23c326180d7cc386b62d9 120 bytes 6597 us # eosio.token &lt;= eosio.token::create {&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;100000000000.0000 EOS&quot;,&quot;can_freeze&quot;:0,&quot;can_recall&quot;:0,&quot;can_whitel... warning: transaction executed locally, but may not be confirmed by the network yet 然后eosio向配置好的账户helloworld发行token： [kingnet@pdev1 dice]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token issue &#39;{&quot;to&quot;:&quot;helloworld&quot;, &quot;quantity&quot;:&quot;100.0000 EOS&quot;, &quot;memo&quot;:&quot;m&quot;}&#39; -p eosio executed transaction: 732e883ae259644de6c4442a0b4007fdbc0d1b95157c5b000a3f7c9cbb1eecf7 120 bytes 1871 us # eosio.token &lt;= eosio.token::issue {&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; issueeosio balance: 100.0000 EOS # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; transfer from eosio to helloworld 100.0000 EOS # eosio &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} # helloworld &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;helloworld&quot;,&quot;quantity&quot;:&quot;100.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} warning: transaction executed locally, but may not be confirmed by the network yet 从以上issue合约执行的日志中可以看出账户之间存在多次的通知，可以用以下图来描述整个消息流： eosio.token合约首先收到issue action的消息，在eosio.token合约执行时发起了一个新的transfer action消息给eosio.token合约，即发给自己，如下是issue action代码片段： void token::issue( account_name to, asset quantity, string memo ) { print( &quot;issue&quot; ); auto sym = quantity.symbol; eosio_assert( sym.is_valid(), &quot;invalid symbol name&quot; ); auto sym_name = sym.name(); stats statstable( _self, sym_name ); auto existing = statstable.find( sym_name ); eosio_assert( existing != statstable.end(), &quot;token with symbol does not exist, create token before issue&quot; ); const auto&amp; st = *existing; require_auth( st.issuer ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must issue positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); eosio_assert( quantity.amount &lt;= st.max_supply.amount - st.supply.amount, &quot;quantity exceeds available supply&quot;); statstable.modify( st, 0, [&amp;]( auto&amp; s ) { s.supply += quantity; }); add_balance( st.issuer, quantity, st, st.issuer ); if( to != st.issuer ) { SEND_INLINE_ACTION( *this, transfer, {st.issuer,N(active)}, {st.issuer, to, quantity, memo} ); } } 我可以看到在第27行，发送了一个action，采用的是inline方式（这是eos两种通信方式的一种，还有一种是Deferred&nbsp;），发送到自己即eosio.token的transfer action上。 以下是eosio.token的transfer action代码片段： void token::transfer( account_name from, account_name to, asset quantity, string /*memo*/ ) { print( &quot;transfer from &quot;, eosio::name{from}, &quot; to &quot;, eosio::name{to}, &quot; &quot;, quantity, &quot;\\n&quot; ); eosio_assert( from != to, &quot;cannot transfer to self&quot; ); require_auth( from ); eosio_assert( is_account( to ), &quot;to account does not exist&quot;); auto sym = quantity.symbol.name(); stats statstable( _self, sym ); const auto&amp; st = statstable.get( sym ); require_recipient( from ); require_recipient( to ); eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must transfer positive quantity&quot; ); eosio_assert( quantity.symbol == st.supply.symbol, &quot;symbol precision mismatch&quot; ); sub_balance( from, quantity, st ); add_balance( to, quantity, st, from ); } 从第14、15行可以看到其给from和to（即eosio和helloworld）各发送一个通知消息。 那么该通知信息会被eosio和helloworld两个账户收到吗？如果账户能收到通知消息，通知消息发送给账户时的参数又是什么呢？那么账户怎么处理通知消息呢？通过以下编程来深入了解EOS的通知消息。 二、EOS通知编程 我们创建三个合约，模拟两个游戏玩家在对战平台玩游戏的场景，游戏玩家1执行合约action后，游戏平台将收到玩家1请求，平台合约将执行玩家1的请求，同时将结果分别通知给游戏玩家1和游戏玩家2以通知其更新数据，游戏玩家完成更新后再通知平台合约已完成更新。在每个合约入口我们都首先将合约参数写入数据库中以跟踪整个通知流程。 游戏平台合约： /** * * The apply() methods must have C calling convention so that the blockchain can lookup and * * call these methods. * */ #include &lt;eosiolib/eosio.hpp&gt; extern &quot;C&quot; { struct gameinfo { uint64_t id; account_name player1; uint64_t x1; uint64_t y1; account_name player2; uint64_t x2; uint64_t y2; uint64_t info; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( gameinfo, (id)(player)(x)(y) ) }; typedef eosio::multi_index&lt; N(gameinfo), gameinfo&gt; gameinfo_index; struct notifyinfo { uint64_t id; account_name receiver; account_name code; account_name action; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) ) }; typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index; struct dummy_action { account_name player1; account_name player2; uint64_t info; }; /// The apply method implements the dispatch of events to this contract void apply( uint64_t receiver, uint64_t code, uint64_t action ) { // auto _self = receiver; { notifyinfo_index notifyinfos(_self, _self); auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = notifyinfos.available_primary_key(); info.receiver = receiver; info.code = code; info.action = action; }); } // if(receiver == code &amp;&amp; action == N(creategame)) { dummy_action dummy = eosio::unpack_action_data&lt;dummy_action&gt;(); gameinfo_index gameinfos(_self, _self); auto new_gameinfos_itr = gameinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = gameinfos.available_primary_key(); info.player1 = dummy.player1; info.x1 = 0; info.y1 = 0; info.player2 = dummy.player2; info.x2 = 0; info.y2 = 0; info.info = dummy.info; }); // require_recipient(dummy.player1); require_recipient(dummy.player2); } else if(action == N(creategame)) { // do something.... // } else if(receiver == code &amp;&amp; action == N(reset)) { gameinfo_index gameinfos(_self, _self); auto cur_gameinfos_itr = gameinfos.begin(); while(cur_gameinfos_itr != gameinfos.end()) { cur_gameinfos_itr = gameinfos.erase(cur_gameinfos_itr); } notifyinfo_index notifyinfos(_self, _self); auto cur_notifyinfos_itr = notifyinfos.begin(); while(cur_notifyinfos_itr != notifyinfos.end()) { cur_notifyinfos_itr = notifyinfos.erase(cur_notifyinfos_itr); } } } } // extern &quot;C&quot; 用户合约代码： /** * * The apply() methods must have C calling convention so that the blockchain can lookup and * * call these methods. * */ #include &lt;eosiolib/eosio.hpp&gt; extern &quot;C&quot; { struct gameinfo { uint64_t id; account_name player1; uint64_t x1; uint64_t y1; account_name player2; uint64_t x2; uint64_t y2; uint64_t info; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( gameinfo, (id)(player)(x)(y) ) }; typedef eosio::multi_index&lt; N(gameinfo), gameinfo&gt; gameinfo_index; struct notifyinfo { uint64_t id; account_name receiver; account_name code; account_name action; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) ) }; typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index; struct dummy_action { account_name player1; account_name player2; uint64_t info; }; /// The apply method implements the dispatch of events to this contract void apply( uint64_t receiver, uint64_t code, uint64_t action ) { auto _self = receiver; { notifyinfo_index notifyinfos(_self, _self); auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = notifyinfos.available_primary_key(); info.receiver = receiver; info.code = code; info.action = action; }); } // if(action == N(creategame)) { dummy_action dummy = eosio::unpack_action_data&lt;dummy_action&gt;(); gameinfo_index gameinfos(_self, _self); auto new_gameinfos_itr = gameinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = gameinfos.available_primary_key(); info.player1 = dummy.player1; info.x1 = 0; info.y1 = 0; info.player2 = dummy.player2; info.x2 = 0; info.y2 = 0; info.info = dummy.info; }); // require_recipient(code); } } } // extern &quot;C&quot; 我们将创建三个账户，分别运行游戏平台合约和两个游戏玩家合约： [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.s EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: c7dc538ecf56ba612eae50eb266848e1ae6a9907cbbab62ae8ade48018c38644 200 bytes 451 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;game.s&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcfnVPJq... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.c.1 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: f44bdfa622c06fb170e5b564bca0fd52f69d4cfc068bad9546a820ad822d6ece 200 bytes 403 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;game.c.1&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcfnVP... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.c.2 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: c52b61f22f6df8b46ac7a8623e3114404cfc2dceec81363abfee094f7e450c28 200 bytes 476 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;game.c.2&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcfnVP... warning: transaction executed locally, but may not be confirmed by the network yet 在游戏平台账户上部署游戏平台合约： [kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.s /home/kingnet/tangy/eos/mycontracts/test_notify_s/ Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_s/test_notify_s.wasm... Using already assembled WASM... Publishing contract... executed transaction: 240396da31c7d4d193befc07bfe4db4956a250e0760a0156adeae8d3979a7017 3848 bytes 1273 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;game.s&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001560f6000006000017e60027e7e006... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;game.s&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;creategame&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;p... warning: transaction executed locally, but may not be confirmed by the network yet 分别在两个游戏玩家账户张部署游戏客户端合约： [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.c.1 /home/kingnet/tangy/eos/mycontracts/test_notify_g1 Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_g1/test_notify_g1.wasm... Using already assembled WASM... Publishing contract... executed transaction: 1c1b448f52cd4bca5c251cacf56c93ffaa49abfb2a03d7e065b18068f522cb9b 3368 bytes 1201 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;game.c.1&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001560f6000006000017e60027e7e0... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;game.c.1&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;gameinfo&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;i... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.c.2 /home/kingnet/tangy/eos/mycontracts/test_notify_g1 Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_g1/test_notify_g1.wasm... Using already assembled WASM... Publishing contract... executed transaction: d3456d22a8ea450edbf1ee014833dbd00aecc6fd22883fbe500460681bae653b 3368 bytes 1000 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;game.c.2&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001560f6000006000017e60027e7e0... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;game.c.2&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;gameinfo&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;i... warning: transaction executed locally, but may not be confirmed by the network yet 我们接下来执行一次游戏创建操作： [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action game.s creategame &#39;{&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}&#39; -p game.s executed transaction: 5048ffd4082325ca9f72ad9ac2c6fd7f3a6befbf87766343b064b57b6fac2fd5 120 bytes 4871 us # game.s &lt;= game.s::creategame {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1} # game.c.1 &lt;= game.s::creategame {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1} # game.c.2 &lt;= game.s::creategame {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1} warning: transaction executed locally, but may not be confirmed by the network yet 从以上执行的结果可以看到，creategame这个action首先发给了game.s，这是我们发起的，这个action消息又转发给了game.c.1和game.c.2，这是我们在creategame这个action中发送的通知消息。 我们可以继续看看每个合约账户上收到的action通知消息： [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.s # seq when contract::action =&gt; receiver trx id... args ================================================================================================================ # 0 2018-05-17T09:56:55.500 eosio::setcode =&gt; eosio 240396da... {&quot;account&quot;:&quot;game.s&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736... # 1 2018-05-17T09:56:55.500 eosio::setabi =&gt; eosio 240396da... {&quot;account&quot;:&quot;game.s&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;cr... # 2 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.s 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... # 3 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.1 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... # 4 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.2 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.c.1 # seq when contract::action =&gt; receiver trx id... args ================================================================================================================ # 0 2018-05-17T09:59:50.500 eosio::setcode =&gt; eosio 1c1b448f... {&quot;account&quot;:&quot;game.c.1&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;00617... # 1 2018-05-17T09:59:50.500 eosio::setabi =&gt; eosio 1c1b448f... {&quot;account&quot;:&quot;game.c.1&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;... # 2 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.1 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... [kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.c.2 # seq when contract::action =&gt; receiver trx id... args ================================================================================================================ # 0 2018-05-17T10:00:05.000 eosio::setcode =&gt; eosio d3456d22... {&quot;account&quot;:&quot;game.c.2&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;00617... # 1 2018-05-17T10:00:05.000 eosio::setabi =&gt; eosio d3456d22... {&quot;account&quot;:&quot;game.c.2&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;... # 2 2018-05-17T10:03:41.000 game.s::creategame =&gt; game.c.2 5048ffd4... {&quot;player1&quot;:&quot;game.c.1&quot;,&quot;player2&quot;:&quot;game.c.2&quot;,&quot;info&quot;:1}... 我们在入口跟踪了通知消息并写入了数据库，如果查看数据库可以得出一致的消息，同时我们在收到通知后也正确解析了请求的参数，查看数据库可以得到数据库中三个表的内容完全一致。 我们现在可以回答上面关于eos通知消息的问题了： 1. 向一个合约发送的通知会被这个合约接收并在应用层处理吗？ 一个合约向另一个合约发出的通知消息会被另一个合约收到，不管有没有ABI定义接口，都会在应用层收到。 2. 参数是什么呢？ 一个合约向另一个合约发送的通知消息就是本合约收到的消息，包括code、action和参数 3. 账户如何处理该通知消息呢？ 和处理正常的消息一样，根据code、action和参数进行逻辑处理 三、拒绝接受转账交易及DoS 我们目前已经清楚了eos合约通知机制，同时也知道了给一个账户转账交易会给该账户消息通知，其实我们还有一个疑问，如果账户合约处理通知消息失败了，那么这个交易状态会回滚么？ 我们现在开发一个合约，合约处理交易的transfer事件通知，在通知处理程序中，我们抛出一个异常，使得该通知处理失败。同时我们照样在入口记录所有收到的action。 我们会将该合约部署在账户test.notify上。我们转账给test.notify，那么eosio.token合约的transfer action会被执行，在eosio.token合约执行转账时，给向目标账户test.notify发送事件通知，但事件通知处理失败了，到底这个转账交易会回滚么？ 拒绝接收转账合约： /** * * The apply() methods must have C calling convention so that the blockchain can lookup and * * call these methods. * */ #include &lt;eosiolib/eosio.hpp&gt; extern &quot;C&quot; { struct notifyinfo { uint64_t id; account_name receiver; account_name code; account_name action; uint64_t primary_key()const { return id; } //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) ) }; typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index; /// The apply method implements the dispatch of events to this contract void apply( uint64_t receiver, uint64_t code, uint64_t action ) { auto _self = receiver; notifyinfo_index notifyinfos(_self, _self); auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){ info.id = notifyinfos.available_primary_key(); info.receiver = receiver; info.code = code; info.action = action; }); if(action == N(transfer)) { eosio_assert(&quot;reject transfer!&quot;); } if(receiver == code &amp;&amp; action == N(reset)) { auto cur_notify_itr = notifyinfos.begin(); while(cur_notify_itr != notifyinfos.end()) { cur_notify_itr = notifyinfos.erase(cur_notify_itr); } } } } // extern &quot;C&quot; 我们执行转账操作并检查结果： [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio test.notify EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV executed transaction: 4576dec103dab2abfbfff775f8208c8fff46996cc9d3717d576574544f381d72 200 bytes 476 us # eosio &lt;= eosio::newaccount {&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;test.notify&quot;,&quot;owner&quot;:{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcf... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract test.notify /home/kingnet/tangy/eos/mycontracts/test_notify Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify/test_notify.wasm... Using already assembled WASM... Publishing contract... executed transaction: 7bd410a214ed2700eea182bebcdf94304ee49911e8f0c53dcfa58068150067d4 5048 bytes 1200 us # eosio &lt;= eosio::setcode {&quot;account&quot;:&quot;test.notify&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001520e6000006000017e60027e... # eosio &lt;= eosio::setabi {&quot;account&quot;:&quot;test.notify&quot;,&quot;abi&quot;:{&quot;types&quot;:[],&quot;structs&quot;:[{&quot;name&quot;:&quot;hi&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;user... warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token issue &#39;{&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;, &quot;memo&quot;:&quot;m&quot;}&#39; -p eosio executed transaction: 995b01cd4206ee19894400f09d2d0bbbba1b5d9e74010438447387e4be1f226e 120 bytes 10667 us # eosio.token &lt;= eosio.token::issue {&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; issueeosio balance: 1001.0000 EOS # eosio.token &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} &gt;&gt; transfer from eosio to test.notify 1.0000 EOS # eosio &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} # test.notify &lt;= eosio.token::transfer {&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1001.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;} warning: transaction executed locally, but may not be confirmed by the network yet [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get currency balance eosio.token test.notify 1001.0000 EOS [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token transfer &#39;{&quot;from&quot;:&quot;alice&quot;,&quot;to&quot;:&quot;test.notify&quot;,&quot;quantity&quot;:&quot;1.0000 EOS&quot;,&quot;memo&quot;:&quot;m&quot;}&#39; -p alice 1566956ms thread-0 main.cpp:2316 main ] Failed with error: Assert Exception (10) condition: assertion failed: reject transfer! [kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get currency balance eosio.token test.notify 1001.0000 EOS 我们可以看到转账失败了，这个失败是由转账的接收方处理转账通知事件时给出错误应答引起的，这样就可以让一个账户拒绝接收转账。 这个例子演示了时事件通知处理失败会导致整个交易回滚，如果一个transaction中包含了许多的action，但只要某一个账户处理action的通知事件失败将引起整个交易回滚，这样某一个账户可以进行DoS（拒绝服务攻击）。 下一章介绍EOS合约中通信编程。 阅读更多","@type":"BlogPosting","url":"/2018/05/29/5ecb121d33d019c8c4346aa522d08228.html","headline":"EOS合约开发第十七章-合约通信编程","dateModified":"2018-05-29T00:00:00+08:00","datePublished":"2018-05-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/05/29/5ecb121d33d019c8c4346aa522d08228.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>EOS合约开发第十七章-合约通信编程</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h1 style="text-align:center;">合约通信编程</h1>
  <h3>一、EOS通知概述</h3>
  <p>我们首先看一看eosio.token合约中issue的通知。跳过基本的合约和账户配置，我们直接进入eosio.token合约，首先创建一个token：</p>
  <pre><code class="language-plain">[kingnet@pdev1 nodeos1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token create '{"issuer":"eosio","maximum_supply":"100000000000.0000 EOS","can_freeze":0,"can_recall":0,"can_whitelist":0}' -p eosio.token
executed transaction: 756ecf4050184dd06c7f27d77cca3864e41fa3c319b23c326180d7cc386b62d9  120 bytes  6597 us
#   eosio.token &lt;= eosio.token::create          {"issuer":"eosio","maximum_supply":"100000000000.0000 EOS","can_freeze":0,"can_recall":0,"can_whitel...
warning: transaction executed locally, but may not be confirmed by the network yet</code></pre>
  <p>然后eosio向配置好的账户helloworld发行token：</p>
  <pre><code class="language-plain">[kingnet@pdev1 dice]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token issue '{"to":"helloworld", "quantity":"100.0000 EOS", "memo":"m"}' -p eosio
executed transaction: 732e883ae259644de6c4442a0b4007fdbc0d1b95157c5b000a3f7c9cbb1eecf7  120 bytes  1871 us
#   eosio.token &lt;= eosio.token::issue           {"to":"helloworld","quantity":"100.0000 EOS","memo":"m"}
&gt;&gt; issueeosio balance: 100.0000 EOS
#   eosio.token &lt;= eosio.token::transfer        {"from":"eosio","to":"helloworld","quantity":"100.0000 EOS","memo":"m"}
&gt;&gt; transfer from eosio to helloworld 100.0000 EOS
#         eosio &lt;= eosio.token::transfer        {"from":"eosio","to":"helloworld","quantity":"100.0000 EOS","memo":"m"}
#    helloworld &lt;= eosio.token::transfer        {"from":"eosio","to":"helloworld","quantity":"100.0000 EOS","memo":"m"}
warning: transaction executed locally, but may not be confirmed by the network yet</code></pre>
  <p>从以上issue合约执行的日志中可以看出账户之间存在多次的通知，可以用以下图来描述整个消息流：</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180515192847209" alt=""><br></p>
  <p>eosio.token合约首先收到issue action的消息，在eosio.token合约执行时发起了一个新的transfer action消息给eosio.token合约，即发给自己，如下是issue action代码片段：</p>
  <pre><code class="language-cpp">void token::issue( account_name to, asset quantity, string memo )
{
    print( "issue" );
    auto sym = quantity.symbol;
    eosio_assert( sym.is_valid(), "invalid symbol name" );

    auto sym_name = sym.name();
    stats statstable( _self, sym_name );
    auto existing = statstable.find( sym_name );
    eosio_assert( existing != statstable.end(), "token with symbol does not exist, create token before issue" );
    const auto&amp; st = *existing;

    require_auth( st.issuer );
    eosio_assert( quantity.is_valid(), "invalid quantity" );
    eosio_assert( quantity.amount &gt; 0, "must issue positive quantity" );

    eosio_assert( quantity.symbol == st.supply.symbol, "symbol precision mismatch" );
    eosio_assert( quantity.amount &lt;= st.max_supply.amount - st.supply.amount, "quantity exceeds available supply");

    statstable.modify( st, 0, [&amp;]( auto&amp; s ) {
       s.supply += quantity;
    });

    add_balance( st.issuer, quantity, st, st.issuer );

    if( to != st.issuer ) {
       SEND_INLINE_ACTION( *this, transfer, {st.issuer,N(active)}, {st.issuer, to, quantity, memo} );
    }
}</code></pre>
  <p>我可以看到在第27行，发送了一个action，采用的是inline方式（这是eos两种通信方式的一种，还有一种是Deferred&nbsp;），发送到自己即eosio.token的transfer action上。</p>
  <p>以下是eosio.token的transfer action代码片段：</p>
  <pre><code class="language-cpp">void token::transfer( account_name from,
                      account_name to,
                      asset        quantity,
                      string       /*memo*/ )
{
    print( "transfer from ", eosio::name{from}, " to ", eosio::name{to}, " ", quantity, "\n" );
    eosio_assert( from != to, "cannot transfer to self" );
    require_auth( from );
    eosio_assert( is_account( to ), "to account does not exist");
    auto sym = quantity.symbol.name();
    stats statstable( _self, sym );
    const auto&amp; st = statstable.get( sym );

    require_recipient( from );
    require_recipient( to );

    eosio_assert( quantity.is_valid(), "invalid quantity" );
    eosio_assert( quantity.amount &gt; 0, "must transfer positive quantity" );
    eosio_assert( quantity.symbol == st.supply.symbol, "symbol precision mismatch" );


    sub_balance( from, quantity, st );
    add_balance( to, quantity, st, from );
}</code></pre>
  <p>从第14、15行可以看到其给from和to（即eosio和helloworld）各发送一个通知消息。</p>
  <p>那么该通知信息会被eosio和helloworld两个账户收到吗？如果账户能收到通知消息，通知消息发送给账户时的参数又是什么呢？那么账户怎么处理通知消息呢？通过以下编程来深入了解EOS的通知消息。</p>
  <h3>二、EOS通知编程</h3>
  <p>我们创建三个合约，模拟两个游戏玩家在对战平台玩游戏的场景，游戏玩家1执行合约action后，游戏平台将收到玩家1请求，平台合约将执行玩家1的请求，同时将结果分别通知给游戏玩家1和游戏玩家2以通知其更新数据，游戏玩家完成更新后再通知平台合约已完成更新。在每个合约入口我们都首先将合约参数写入数据库中以跟踪整个通知流程。</p>
  <p>游戏平台合约：</p>
  <pre><code class="language-cpp">/**
 * *  The apply() methods must have C calling convention so that the blockchain can lookup and
 * *  call these methods.
 * */
#include &lt;eosiolib/eosio.hpp&gt;

extern "C" {

	struct gameinfo {
	   uint64_t id;
	   account_name player1;
	   uint64_t x1;
	   uint64_t y1;
	   account_name player2;
	   uint64_t x2;
	   uint64_t y2;
	   uint64_t info;

	   uint64_t primary_key()const { return id; }

	   //EOSLIB_SERIALIZE( gameinfo, (id)(player)(x)(y) )
	};

	typedef eosio::multi_index&lt; N(gameinfo), gameinfo&gt; gameinfo_index;

	struct notifyinfo {
	   uint64_t id;
	   account_name receiver;
	   account_name code;
	   account_name action;

	   uint64_t primary_key()const { return id; }

	   //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) )
	};

	typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index;

	struct dummy_action {
		account_name player1;
		account_name player2;
		uint64_t info;
	};

   /// The apply method implements the dispatch of events to this contract
   void apply( uint64_t receiver, uint64_t code, uint64_t action ) {
	 //
	 auto _self = receiver;
	 {
		 notifyinfo_index notifyinfos(_self, _self);
		 auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){
			info.id           = notifyinfos.available_primary_key();
			info.receiver     = receiver;
			info.code         = code;
			info.action       = action;
		 });
	 }
	 //
	 if(receiver == code &amp;&amp; action == N(creategame)) {
		 dummy_action dummy = eosio::unpack_action_data&lt;dummy_action&gt;();
		 gameinfo_index gameinfos(_self, _self);
		 auto new_gameinfos_itr = gameinfos.emplace(_self, [&amp;](auto&amp; info){
			info.id         = gameinfos.available_primary_key();
			info.player1    = dummy.player1;
			info.x1         = 0;
			info.y1         = 0;
			info.player2    = dummy.player2;
			info.x2         = 0;
			info.y2         = 0;
			info.info       = dummy.info;
		 });

		 //
		 require_recipient(dummy.player1);
		 require_recipient(dummy.player2);
	 } else if(action == N(creategame)) {
		 // do something....
		 //
	 } else if(receiver == code &amp;&amp; action == N(reset)) {
		 gameinfo_index gameinfos(_self, _self);
		 auto cur_gameinfos_itr = gameinfos.begin();
		 while(cur_gameinfos_itr != gameinfos.end()) {
			 cur_gameinfos_itr = gameinfos.erase(cur_gameinfos_itr);
		 }

		 notifyinfo_index notifyinfos(_self, _self);
		 auto cur_notifyinfos_itr = notifyinfos.begin();
		 while(cur_notifyinfos_itr != notifyinfos.end()) {
			 cur_notifyinfos_itr = notifyinfos.erase(cur_notifyinfos_itr);
		 }
	 }
   }
} // extern "C"</code></pre>
  <p>用户合约代码：</p>
  <pre><code class="language-cpp">/**
 * *  The apply() methods must have C calling convention so that the blockchain can lookup and
 * *  call these methods.
 * */
#include &lt;eosiolib/eosio.hpp&gt;

extern "C" {

	struct gameinfo {
	   uint64_t id;
	   account_name player1;
	   uint64_t x1;
	   uint64_t y1;
	   account_name player2;
	   uint64_t x2;
	   uint64_t y2;
	   uint64_t info;

	   uint64_t primary_key()const { return id; }

	   //EOSLIB_SERIALIZE( gameinfo, (id)(player)(x)(y) )
	};

	typedef eosio::multi_index&lt; N(gameinfo), gameinfo&gt; gameinfo_index;

	struct notifyinfo {
	   uint64_t id;
	   account_name receiver;
	   account_name code;
	   account_name action;

	   uint64_t primary_key()const { return id; }

	   //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) )
	};

	typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index;

	struct dummy_action {
		account_name player1;
		account_name player2;
		uint64_t info;
	};

   /// The apply method implements the dispatch of events to this contract
   void apply( uint64_t receiver, uint64_t code, uint64_t action ) {
	 auto _self = receiver;
	 {
		 notifyinfo_index notifyinfos(_self, _self);
		 auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){
			info.id           = notifyinfos.available_primary_key();
			info.receiver     = receiver;
			info.code         = code;
			info.action       = action;
		 });
	 }
	 //
	 if(action == N(creategame)) {
		 dummy_action dummy = eosio::unpack_action_data&lt;dummy_action&gt;();
		 gameinfo_index gameinfos(_self, _self);
		 auto new_gameinfos_itr = gameinfos.emplace(_self, [&amp;](auto&amp; info){
			info.id         = gameinfos.available_primary_key();
			info.player1    = dummy.player1;
			info.x1         = 0;
			info.y1         = 0;
			info.player2    = dummy.player2;
			info.x2         = 0;
			info.y2         = 0;
			info.info       = dummy.info;
		 });

		 //
		 require_recipient(code);
	 }
   }
} // extern "C"</code></pre>
  <p>我们将创建三个账户，分别运行游戏平台合约和两个游戏玩家合约：</p>
  <pre><code class="language-cpp">[kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.s EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV
executed transaction: c7dc538ecf56ba612eae50eb266848e1ae6a9907cbbab62ae8ade48018c38644  200 bytes  451 us
#         eosio &lt;= eosio::newaccount            {"creator":"eosio","name":"game.s","owner":{"threshold":1,"keys":[{"key":"EOS6MRyAjQq8ud7hVNYcfnVPJq...
warning: transaction executed locally, but may not be confirmed by the network yet
[kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.c.1 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV
executed transaction: f44bdfa622c06fb170e5b564bca0fd52f69d4cfc068bad9546a820ad822d6ece  200 bytes  403 us
#         eosio &lt;= eosio::newaccount            {"creator":"eosio","name":"game.c.1","owner":{"threshold":1,"keys":[{"key":"EOS6MRyAjQq8ud7hVNYcfnVP...
warning: transaction executed locally, but may not be confirmed by the network yet
[kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio game.c.2 EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV
executed transaction: c52b61f22f6df8b46ac7a8623e3114404cfc2dceec81363abfee094f7e450c28  200 bytes  476 us
#         eosio &lt;= eosio::newaccount            {"creator":"eosio","name":"game.c.2","owner":{"threshold":1,"keys":[{"key":"EOS6MRyAjQq8ud7hVNYcfnVP...
warning: transaction executed locally, but may not be confirmed by the network yet</code></pre>
  <p>在游戏平台账户上部署游戏平台合约：</p>
  <pre><code class="language-plain">[kingnet@pdev1 test_notify_s]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.s /home/kingnet/tangy/eos/mycontracts/test_notify_s/
Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_s/test_notify_s.wasm...
Using already assembled WASM...
Publishing contract...
executed transaction: 240396da31c7d4d193befc07bfe4db4956a250e0760a0156adeae8d3979a7017  3848 bytes  1273 us
#         eosio &lt;= eosio::setcode               {"account":"game.s","vmtype":0,"vmversion":0,"code":"0061736d0100000001560f6000006000017e60027e7e006...
#         eosio &lt;= eosio::setabi                {"account":"game.s","abi":{"types":[],"structs":[{"name":"creategame","base":"","fields":[{"name":"p...
warning: transaction executed locally, but may not be confirmed by the network yet</code></pre>
  <p>分别在两个游戏玩家账户张部署游戏客户端合约：</p>
  <pre><code class="language-plain">[kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.c.1 /home/kingnet/tangy/eos/mycontracts/test_notify_g1
Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_g1/test_notify_g1.wasm...
Using already assembled WASM...
Publishing contract...
executed transaction: 1c1b448f52cd4bca5c251cacf56c93ffaa49abfb2a03d7e065b18068f522cb9b  3368 bytes  1201 us
#         eosio &lt;= eosio::setcode               {"account":"game.c.1","vmtype":0,"vmversion":0,"code":"0061736d0100000001560f6000006000017e60027e7e0...
#         eosio &lt;= eosio::setabi                {"account":"game.c.1","abi":{"types":[],"structs":[{"name":"gameinfo","base":"","fields":[{"name":"i...
warning: transaction executed locally, but may not be confirmed by the network yet
[kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract game.c.2 /home/kingnet/tangy/eos/mycontracts/test_notify_g1
Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify_g1/test_notify_g1.wasm...
Using already assembled WASM...
Publishing contract...
executed transaction: d3456d22a8ea450edbf1ee014833dbd00aecc6fd22883fbe500460681bae653b  3368 bytes  1000 us
#         eosio &lt;= eosio::setcode               {"account":"game.c.2","vmtype":0,"vmversion":0,"code":"0061736d0100000001560f6000006000017e60027e7e0...
#         eosio &lt;= eosio::setabi                {"account":"game.c.2","abi":{"types":[],"structs":[{"name":"gameinfo","base":"","fields":[{"name":"i...
warning: transaction executed locally, but may not be confirmed by the network yet</code></pre>
  <p>我们接下来执行一次游戏创建操作：</p>
  <pre><code class="language-plain">[kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action game.s creategame '{"player1":"game.c.1","player2":"game.c.2","info":1}' -p game.s
executed transaction: 5048ffd4082325ca9f72ad9ac2c6fd7f3a6befbf87766343b064b57b6fac2fd5  120 bytes  4871 us
#        game.s &lt;= game.s::creategame           {"player1":"game.c.1","player2":"game.c.2","info":1}
#      game.c.1 &lt;= game.s::creategame           {"player1":"game.c.1","player2":"game.c.2","info":1}
#      game.c.2 &lt;= game.s::creategame           {"player1":"game.c.1","player2":"game.c.2","info":1}
warning: transaction executed locally, but may not be confirmed by the network yet</code></pre>
  <p>从以上执行的结果可以看到，creategame这个action首先发给了game.s，这是我们发起的，这个action消息又转发给了game.c.1和game.c.2，这是我们在creategame这个action中发送的通知消息。</p>
  <p>我们可以继续看看每个合约账户上收到的action通知消息：</p>
  <pre><code class="language-plain">[kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.s
#  seq  when                              contract::action =&gt; receiver      trx id...   args
================================================================================================================
#    0   2018-05-17T09:56:55.500            eosio::setcode =&gt; eosio         240396da... {"account":"game.s","vmtype":0,"vmversion":0,"code":"0061736...
#    1   2018-05-17T09:56:55.500             eosio::setabi =&gt; eosio         240396da... {"account":"game.s","abi":{"types":[],"structs":[{"name":"cr...
#    2   2018-05-17T10:03:41.000        game.s::creategame =&gt; game.s        5048ffd4... {"player1":"game.c.1","player2":"game.c.2","info":1}...
#    3   2018-05-17T10:03:41.000        game.s::creategame =&gt; game.c.1      5048ffd4... {"player1":"game.c.1","player2":"game.c.2","info":1}...
#    4   2018-05-17T10:03:41.000        game.s::creategame =&gt; game.c.2      5048ffd4... {"player1":"game.c.1","player2":"game.c.2","info":1}...
[kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.c.1
#  seq  when                              contract::action =&gt; receiver      trx id...   args
================================================================================================================
#    0   2018-05-17T09:59:50.500            eosio::setcode =&gt; eosio         1c1b448f... {"account":"game.c.1","vmtype":0,"vmversion":0,"code":"00617...
#    1   2018-05-17T09:59:50.500             eosio::setabi =&gt; eosio         1c1b448f... {"account":"game.c.1","abi":{"types":[],"structs":[{"name":"...
#    2   2018-05-17T10:03:41.000        game.s::creategame =&gt; game.c.1      5048ffd4... {"player1":"game.c.1","player2":"game.c.2","info":1}...
[kingnet@pdev1 test_notify_g1]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get actions game.c.2
#  seq  when                              contract::action =&gt; receiver      trx id...   args
================================================================================================================
#    0   2018-05-17T10:00:05.000            eosio::setcode =&gt; eosio         d3456d22... {"account":"game.c.2","vmtype":0,"vmversion":0,"code":"00617...
#    1   2018-05-17T10:00:05.000             eosio::setabi =&gt; eosio         d3456d22... {"account":"game.c.2","abi":{"types":[],"structs":[{"name":"...
#    2   2018-05-17T10:03:41.000        game.s::creategame =&gt; game.c.2      5048ffd4... {"player1":"game.c.1","player2":"game.c.2","info":1}...</code></pre>
  <p>我们在入口跟踪了通知消息并写入了数据库，如果查看数据库可以得出一致的消息，同时我们在收到通知后也正确解析了请求的参数，查看数据库可以得到数据库中三个表的内容完全一致。</p>
  <p>我们现在可以回答上面关于eos通知消息的问题了：</p>
  <p>1. 向一个合约发送的通知会被这个合约接收并在应用层处理吗？</p>
  <p>一个合约向另一个合约发出的通知消息会被另一个合约收到，不管有没有ABI定义接口，都会在应用层收到。</p>
  <p>2. 参数是什么呢？</p>
  <p>一个合约向另一个合约发送的通知消息就是本合约收到的消息，包括code、action和参数</p>
  <p>3. 账户如何处理该通知消息呢？</p>
  <p>和处理正常的消息一样，根据code、action和参数进行逻辑处理</p>
  <h3>三、拒绝接受转账交易及DoS</h3>
  <p>我们目前已经清楚了eos合约通知机制，同时也知道了给一个账户转账交易会给该账户消息通知，其实我们还有一个疑问，如果账户合约处理通知消息失败了，那么这个交易状态会回滚么？</p>
  <p>我们现在开发一个合约，合约处理交易的transfer事件通知，在通知处理程序中，我们抛出一个异常，使得该通知处理失败。同时我们照样在入口记录所有收到的action。</p>
  <p>我们会将该合约部署在账户test.notify上。我们转账给test.notify，那么eosio.token合约的transfer action会被执行，在eosio.token合约执行转账时，给向目标账户test.notify发送事件通知，但事件通知处理失败了，到底这个转账交易会回滚么？</p>
  <p>拒绝接收转账合约：</p>
  <pre><code class="language-cpp">/**
 * *  The apply() methods must have C calling convention so that the blockchain can lookup and
 * *  call these methods.
 * */
#include &lt;eosiolib/eosio.hpp&gt;

extern "C" {

	struct notifyinfo {
	   uint64_t id;
	   account_name receiver;
	   account_name code;
	   account_name action;

	   uint64_t primary_key()const { return id; }

	   //EOSLIB_SERIALIZE( notifyinfo, (id)(receiver)(code)(action) )
	};

	typedef eosio::multi_index&lt; N(notifyinfo), notifyinfo&gt; notifyinfo_index;

   /// The apply method implements the dispatch of events to this contract
   void apply( uint64_t receiver, uint64_t code, uint64_t action ) {
	 auto _self = receiver;
	 notifyinfo_index notifyinfos(_self, _self);
	 auto new_notifyinfo_itr = notifyinfos.emplace(_self, [&amp;](auto&amp; info){
		info.id           = notifyinfos.available_primary_key();
		info.receiver     = receiver;
		info.code         = code;
		info.action       = action;
	 });

	 if(action == N(transfer)) {
		 eosio_assert("reject transfer!");
	 }

	 if(receiver == code &amp;&amp; action == N(reset)) {
		 auto cur_notify_itr = notifyinfos.begin();
		 while(cur_notify_itr != notifyinfos.end()) {
			 cur_notify_itr = notifyinfos.erase(cur_notify_itr);
		 }
	 }
   }
} // extern "C"</code></pre>
  <p>我们执行转账操作并检查结果：</p>
  <pre><code class="language-plain">[kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 create account eosio test.notify EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV
executed transaction: 4576dec103dab2abfbfff775f8208c8fff46996cc9d3717d576574544f381d72  200 bytes  476 us
#         eosio &lt;= eosio::newaccount            {"creator":"eosio","name":"test.notify","owner":{"threshold":1,"keys":[{"key":"EOS6MRyAjQq8ud7hVNYcf...
warning: transaction executed locally, but may not be confirmed by the network yet
[kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 set contract test.notify /home/kingnet/tangy/eos/mycontracts/test_notify
Reading WAST/WASM from /home/kingnet/tangy/eos/mycontracts/test_notify/test_notify.wasm...
Using already assembled WASM...
Publishing contract...
executed transaction: 7bd410a214ed2700eea182bebcdf94304ee49911e8f0c53dcfa58068150067d4  5048 bytes  1200 us
#         eosio &lt;= eosio::setcode               {"account":"test.notify","vmtype":0,"vmversion":0,"code":"0061736d0100000001520e6000006000017e60027e...
#         eosio &lt;= eosio::setabi                {"account":"test.notify","abi":{"types":[],"structs":[{"name":"hi","base":"","fields":[{"name":"user...
warning: transaction executed locally, but may not be confirmed by the network yet
[kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token issue '{"to":"test.notify","quantity":"1001.0000 EOS", "memo":"m"}' -p eosio
executed transaction: 995b01cd4206ee19894400f09d2d0bbbba1b5d9e74010438447387e4be1f226e  120 bytes  10667 us
#   eosio.token &lt;= eosio.token::issue           {"to":"test.notify","quantity":"1001.0000 EOS","memo":"m"}
&gt;&gt; issueeosio balance: 1001.0000 EOS
#   eosio.token &lt;= eosio.token::transfer        {"from":"eosio","to":"test.notify","quantity":"1001.0000 EOS","memo":"m"}
&gt;&gt; transfer from eosio to test.notify 1.0000 EOS
#         eosio &lt;= eosio.token::transfer        {"from":"eosio","to":"test.notify","quantity":"1001.0000 EOS","memo":"m"}
#   test.notify &lt;= eosio.token::transfer        {"from":"eosio","to":"test.notify","quantity":"1001.0000 EOS","memo":"m"}
warning: transaction executed locally, but may not be confirmed by the network yet
[kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get currency balance eosio.token test.notify
1001.0000 EOS
[kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 push action eosio.token transfer '{"from":"alice","to":"test.notify","quantity":"1.0000 EOS","memo":"m"}' -p alice
1566956ms thread-0   main.cpp:2316                 main                 ] Failed with error: Assert Exception (10)
condition: assertion failed: reject transfer!
[kingnet@pdev1 test_notify]$ cleos --wallet-url http://localhost:9800 --url http://localhost:9800 get currency balance eosio.token test.notify
1001.0000 EOS</code></pre>
  <p>我们可以看到转账失败了，这个失败是由转账的接收方处理转账通知事件时给出错误应答引起的，这样就可以让一个账户拒绝接收转账。</p>
  <p>这个例子演示了时事件通知处理失败会导致整个交易回滚，如果一个transaction中包含了许多的action，但只要某一个账户处理action的通知事件失败将引起整个交易回滚，这样某一个账户可以进行DoS（拒绝服务攻击）。</p>
  <p>下一章介绍EOS合约中通信编程。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bedrock_stable/article/details/80327817,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/bedrock_stable/article/details/80327817,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
