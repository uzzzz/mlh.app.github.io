<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链背后的信息安全(5) 对称加密算法的分组模式及其Go语言实现 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链背后的信息安全(5) 对称加密算法的分组模式及其Go语言实现" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="# 对称加密算法的分组模式及其Go语言实现 之前介绍的DES、3DES、AES加密算法，只能加密固定长度的明文。如果需要加密任意长度的明文，需要对明文分组加密。 DES、3DES、AES等又称分组密码，而分组有很多模式，如：ECB模式、CBC模式、CFB模式、OFB模式、CTR模式，如下将逐一介绍。 ## ECB模式 ECB模式，全称Electronic Codebook模式，译为电子密码本模式，即用相同的密码分别对明文分组独立加密。 ECB模式是最简单的模式，因为相同的明文分组会加密为相同的密文分组，因此存在一定风险。 如下为ECB模式示意图： 另外当最后一个明文分组的内容，小于分组长度时，需要用特定的数据进行填充。 ## CBC模式 CBC模式，全称Cipher Block Chaining模式，译为密文分组链接模式，即加密算法的输入是上一个密文分组和下一个明文分组的异或。 因为是将上一个密文分组和下一个明文分组的内容混合加密，因此可以避免ECB模式的缺陷。 当加密第一个明文分组时，由于不存在上一个密文分组，因此需要准备与分组等长的初始化向量IV，来代替上一个密文分组。 如下为CBC模式示意图： go标准库中CBC模式代码如下： ```go type cbc struct { &nbsp;&nbsp;&nbsp;&nbsp;//b为加密算法，如DES、AES &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密算法支持的明文分组长度 &nbsp;&nbsp;&nbsp;&nbsp;blockSize int &nbsp;&nbsp;&nbsp;&nbsp;//初始化向量IV &nbsp;&nbsp;&nbsp;&nbsp;iv []byte &nbsp;&nbsp;&nbsp;&nbsp;//临时变量 &nbsp;&nbsp;&nbsp;&nbsp;tmp []byte } type cbcEncrypter cbc //指定加密算法和IV func NewCBCEncrypter(b Block, iv []byte) BlockMode { &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != b.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;cipher.NewCBCEncrypter: IV length must equal block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if cbc, ok := b.(cbcEncAble); ok { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cbc.NewCBCEncrypter(iv) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return (*cbcEncrypter)(newCBC(b, iv)) } //加密 func (x *cbcEncrypter) CryptBlocks(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;if len(src)%x.blockSize != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;crypto/cipher: input not full blocks&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(dst) &lt; len(src) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;crypto/cipher: output smaller than input&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;iv := x.iv &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//上一个密文分组和下一个明文分组的异或 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//当加密第一个明文分组时，使用初始化向量IV &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xorBytes(dst[:x.blockSize], src[:x.blockSize], iv) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//执行加密算法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(dst[:x.blockSize], dst[:x.blockSize]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv = dst[:x.blockSize] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[x.blockSize:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[x.blockSize:] &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;copy(x.iv, iv) } //代码位置src/crypto/cipher/cbc.go ``` ## CFB模式 CFB模式，全称Cipher FeedBack模式，译为密文反馈模式，即上一个密文分组作为加密算法的输入，输出与明文异或作为下一个分组的密文。 在CFB模式中，明文分组和密文分组之间只有一次异或。 如下为CFB模式示意图： CFB模式与一次性密码本相似，都是通过将明文与随机比特序列进行异或运算来生成密文。 但由于CFB模式中密码算法的输出是通过计算得到的，并非真正的随机数，因此不具备一次性密码本那样理论上不可破译的性质。 CFB模式可以看做使用分组方式实现流密码的方式。 go标准库中CFB模式代码如下： ```go type cfb struct { &nbsp;&nbsp;&nbsp;&nbsp;//加密算法 &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;next []byte &nbsp;&nbsp;&nbsp;&nbsp;//加密的输出 &nbsp;&nbsp;&nbsp;&nbsp;out []byte &nbsp;&nbsp;&nbsp;&nbsp;outUsed int &nbsp;&nbsp;&nbsp;&nbsp;decrypt bool } //加密或解密 //decrypt为true表示解密 func (x *cfb) XORKeyStream(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.outUsed == len(x.out) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.out, x.next) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.decrypt { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy(x.next[x.outUsed:], src) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//加密输出与明文异或作为下一个分组的密文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !x.decrypt { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//上一个密文分组作为加密算法的输入 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy(x.next[x.outUsed:], dst) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n &nbsp;&nbsp;&nbsp;&nbsp;} } //加密器 func NewCFBEncrypter(block Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;return newCFB(block, iv, false) } //解密器 func NewCFBDecrypter(block Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;return newCFB(block, iv, true) } func newCFB(block Block, iv []byte, decrypt bool) Stream { &nbsp;&nbsp;&nbsp;&nbsp;//分组长度 &nbsp;&nbsp;&nbsp;&nbsp;blockSize := block.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != blockSize { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//初始化向量要求与分组长度等长 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;cipher.newCFB: IV length must equal block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x := &amp;cfb{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: block, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: make([]byte, blockSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next: make([]byte, blockSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: blockSize, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decrypt: decrypt, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;copy(x.next, iv) &nbsp;&nbsp;&nbsp;&nbsp;return x } //代码位置src/crypto/cipher/cfb.go ``` ## OFB模式 OFB模式，全称Output Feedback模式，译为输出反馈模式。 OFB模式与CFB模式类似，只是加密算法的输入是上一次加密的输出。 在OFB模式中，异或所需的密钥流，可以事先通过密码算法生成，即生成密钥流的操作可以与异或运算并行。 OFB模式加密和处理解密逻辑相同，明文与密钥流异或生成密文，密文与密钥流异或生成明文。 如下为OFB模式示意图： go标准库中OFB模式代码如下： ```go type ofb struct { &nbsp;&nbsp;&nbsp;&nbsp;//加密算法 &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;cipher []byte &nbsp;&nbsp;&nbsp;&nbsp;out []byte &nbsp;&nbsp;&nbsp;&nbsp;outUsed int } func NewOFB(b Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;//分组长度 &nbsp;&nbsp;&nbsp;&nbsp;blockSize := b.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != blockSize { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//const streamBufferSize = 512 &nbsp;&nbsp;&nbsp;&nbsp;bufSize := streamBufferSize &nbsp;&nbsp;&nbsp;&nbsp;if bufSize &lt; blockSize { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufSize = blockSize &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x := &amp;ofb{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: b, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cipher: make([]byte, blockSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: make([]byte, 0, bufSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: 0, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;copy(x.cipher, iv) &nbsp;&nbsp;&nbsp;&nbsp;return x } //生成密钥流 func (x *ofb) refill() { &nbsp;&nbsp;&nbsp;&nbsp;bs := x.b.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;remain := len(x.out) - x.outUsed &nbsp;&nbsp;&nbsp;&nbsp;if remain &gt; x.outUsed { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;copy(x.out, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:cap(x.out)] &nbsp;&nbsp;&nbsp;&nbsp;for remain &lt; len(x.out)-bs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.cipher, x.cipher) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy(x.out[remain:], x.cipher) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remain += bs &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:remain] &nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = 0 } func (x *ofb) XORKeyStream(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.outUsed &gt;= len(x.out)-x.b.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//生成密钥流 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.refill() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//与密钥流异或运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n &nbsp;&nbsp;&nbsp;&nbsp;} } //代码位置src/crypto/cipher/ofb.go ``` ## CTR模式 CTR模式，全称Counter模式，译为计数器模式。 CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。 也即最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行异或运算得到的。 如下为CTR模式示意图： go标准库中CTR模式代码如下： ```go type ctr struct { &nbsp;&nbsp;&nbsp;&nbsp;//加密算法 &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;ctr []byte &nbsp;&nbsp;&nbsp;&nbsp;out []byte &nbsp;&nbsp;&nbsp;&nbsp;outUsed int } const streamBufferSize = 512 type ctrAble interface { &nbsp;&nbsp;&nbsp;&nbsp;NewCTR(iv []byte) Stream } func NewCTR(block Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;if ctr, ok := block.(ctrAble); ok { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ctr.NewCTR(iv) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != block.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;cipher.NewCTR: IV length must equal block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;bufSize := streamBufferSize &nbsp;&nbsp;&nbsp;&nbsp;if bufSize &lt; block.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufSize = block.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return &amp;ctr{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: block, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctr: dup(iv), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: make([]byte, 0, bufSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: 0, &nbsp;&nbsp;&nbsp;&nbsp;} } //生成密钥流 func (x *ctr) refill() { &nbsp;&nbsp;&nbsp;&nbsp;remain := len(x.out) - x.outUsed &nbsp;&nbsp;&nbsp;&nbsp;copy(x.out, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:cap(x.out)] &nbsp;&nbsp;&nbsp;&nbsp;bs := x.b.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;for remain &lt;= len(x.out)-bs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.out[remain:], x.ctr) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remain += bs &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//计数器递增 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := len(x.ctr) - 1; i &gt;= 0; i-- { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.ctr[i]++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.ctr[i] != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:remain] &nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = 0 } func (x *ctr) XORKeyStream(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.outUsed &gt;= len(x.out)-x.b.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//生成密钥流 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.refill() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//与密钥流异或运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n &nbsp;&nbsp;&nbsp;&nbsp;} } ``` ## Fabric中CBC模式的AES加密实现 代码如下： ```go //AES加密、CBC模式、PKCS7填充算法 func AESCBCPKCS7Encrypt(key, src []byte) ([]byte, error) { &nbsp;&nbsp;&nbsp;&nbsp;//PKCS7填充算法 &nbsp;&nbsp;&nbsp;&nbsp;tmp := pkcs7Padding(src) &nbsp;&nbsp;&nbsp;&nbsp;//AES加密、CBC模式 &nbsp;&nbsp;&nbsp;&nbsp;return aesCBCEncrypt(key, tmp) } //PKCS7填充算法 //PKCS7即填充字符串由一个字节序列组成，每个字节填充该字节序列的长度 func pkcs7Padding(src []byte) []byte { &nbsp;&nbsp;&nbsp;&nbsp;padding := aes.BlockSize - len(src)%aes.BlockSize &nbsp;&nbsp;&nbsp;&nbsp;padtext := bytes.Repeat([]byte{byte(padding)}, padding) &nbsp;&nbsp;&nbsp;&nbsp;return append(src, padtext...) } //AES加密、CBC模式 func aesCBCEncrypt(key, s []byte) ([]byte, error) { &nbsp;&nbsp;&nbsp;&nbsp;if len(s)%aes.BlockSize != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, errors.New(&quot;Invalid plaintext. It must be a multiple of the block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;block, err := aes.NewCipher(key) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;ciphertext := make([]byte, aes.BlockSize+len(s)) &nbsp;&nbsp;&nbsp;&nbsp;//初始向量IV &nbsp;&nbsp;&nbsp;&nbsp;iv := ciphertext[:aes.BlockSize] &nbsp;&nbsp;&nbsp;&nbsp;if _, err := io.ReadFull(rand.Reader, iv); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;mode := cipher.NewCBCEncrypter(block, iv) &nbsp;&nbsp;&nbsp;&nbsp;mode.CryptBlocks(ciphertext[aes.BlockSize:], s) &nbsp;&nbsp;&nbsp;&nbsp;return ciphertext, nil } //代码位置github.com/hyperledger/fabric/bccsp/sw/aes.go ``` ## 后记 ECB模式因其高风险，不应再使用。 CBC模式、CFB模式、OFB模式、CTR模式，均可使用。 其中Fabric中使用了CBC模式。 待续。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多" />
<meta property="og:description" content="# 对称加密算法的分组模式及其Go语言实现 之前介绍的DES、3DES、AES加密算法，只能加密固定长度的明文。如果需要加密任意长度的明文，需要对明文分组加密。 DES、3DES、AES等又称分组密码，而分组有很多模式，如：ECB模式、CBC模式、CFB模式、OFB模式、CTR模式，如下将逐一介绍。 ## ECB模式 ECB模式，全称Electronic Codebook模式，译为电子密码本模式，即用相同的密码分别对明文分组独立加密。 ECB模式是最简单的模式，因为相同的明文分组会加密为相同的密文分组，因此存在一定风险。 如下为ECB模式示意图： 另外当最后一个明文分组的内容，小于分组长度时，需要用特定的数据进行填充。 ## CBC模式 CBC模式，全称Cipher Block Chaining模式，译为密文分组链接模式，即加密算法的输入是上一个密文分组和下一个明文分组的异或。 因为是将上一个密文分组和下一个明文分组的内容混合加密，因此可以避免ECB模式的缺陷。 当加密第一个明文分组时，由于不存在上一个密文分组，因此需要准备与分组等长的初始化向量IV，来代替上一个密文分组。 如下为CBC模式示意图： go标准库中CBC模式代码如下： ```go type cbc struct { &nbsp;&nbsp;&nbsp;&nbsp;//b为加密算法，如DES、AES &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密算法支持的明文分组长度 &nbsp;&nbsp;&nbsp;&nbsp;blockSize int &nbsp;&nbsp;&nbsp;&nbsp;//初始化向量IV &nbsp;&nbsp;&nbsp;&nbsp;iv []byte &nbsp;&nbsp;&nbsp;&nbsp;//临时变量 &nbsp;&nbsp;&nbsp;&nbsp;tmp []byte } type cbcEncrypter cbc //指定加密算法和IV func NewCBCEncrypter(b Block, iv []byte) BlockMode { &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != b.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;cipher.NewCBCEncrypter: IV length must equal block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if cbc, ok := b.(cbcEncAble); ok { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cbc.NewCBCEncrypter(iv) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return (*cbcEncrypter)(newCBC(b, iv)) } //加密 func (x *cbcEncrypter) CryptBlocks(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;if len(src)%x.blockSize != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;crypto/cipher: input not full blocks&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(dst) &lt; len(src) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;crypto/cipher: output smaller than input&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;iv := x.iv &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//上一个密文分组和下一个明文分组的异或 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//当加密第一个明文分组时，使用初始化向量IV &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xorBytes(dst[:x.blockSize], src[:x.blockSize], iv) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//执行加密算法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(dst[:x.blockSize], dst[:x.blockSize]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv = dst[:x.blockSize] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[x.blockSize:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[x.blockSize:] &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;copy(x.iv, iv) } //代码位置src/crypto/cipher/cbc.go ``` ## CFB模式 CFB模式，全称Cipher FeedBack模式，译为密文反馈模式，即上一个密文分组作为加密算法的输入，输出与明文异或作为下一个分组的密文。 在CFB模式中，明文分组和密文分组之间只有一次异或。 如下为CFB模式示意图： CFB模式与一次性密码本相似，都是通过将明文与随机比特序列进行异或运算来生成密文。 但由于CFB模式中密码算法的输出是通过计算得到的，并非真正的随机数，因此不具备一次性密码本那样理论上不可破译的性质。 CFB模式可以看做使用分组方式实现流密码的方式。 go标准库中CFB模式代码如下： ```go type cfb struct { &nbsp;&nbsp;&nbsp;&nbsp;//加密算法 &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;next []byte &nbsp;&nbsp;&nbsp;&nbsp;//加密的输出 &nbsp;&nbsp;&nbsp;&nbsp;out []byte &nbsp;&nbsp;&nbsp;&nbsp;outUsed int &nbsp;&nbsp;&nbsp;&nbsp;decrypt bool } //加密或解密 //decrypt为true表示解密 func (x *cfb) XORKeyStream(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.outUsed == len(x.out) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.out, x.next) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.decrypt { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy(x.next[x.outUsed:], src) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//加密输出与明文异或作为下一个分组的密文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !x.decrypt { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//上一个密文分组作为加密算法的输入 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy(x.next[x.outUsed:], dst) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n &nbsp;&nbsp;&nbsp;&nbsp;} } //加密器 func NewCFBEncrypter(block Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;return newCFB(block, iv, false) } //解密器 func NewCFBDecrypter(block Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;return newCFB(block, iv, true) } func newCFB(block Block, iv []byte, decrypt bool) Stream { &nbsp;&nbsp;&nbsp;&nbsp;//分组长度 &nbsp;&nbsp;&nbsp;&nbsp;blockSize := block.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != blockSize { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//初始化向量要求与分组长度等长 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;cipher.newCFB: IV length must equal block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x := &amp;cfb{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: block, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: make([]byte, blockSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next: make([]byte, blockSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: blockSize, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decrypt: decrypt, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;copy(x.next, iv) &nbsp;&nbsp;&nbsp;&nbsp;return x } //代码位置src/crypto/cipher/cfb.go ``` ## OFB模式 OFB模式，全称Output Feedback模式，译为输出反馈模式。 OFB模式与CFB模式类似，只是加密算法的输入是上一次加密的输出。 在OFB模式中，异或所需的密钥流，可以事先通过密码算法生成，即生成密钥流的操作可以与异或运算并行。 OFB模式加密和处理解密逻辑相同，明文与密钥流异或生成密文，密文与密钥流异或生成明文。 如下为OFB模式示意图： go标准库中OFB模式代码如下： ```go type ofb struct { &nbsp;&nbsp;&nbsp;&nbsp;//加密算法 &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;cipher []byte &nbsp;&nbsp;&nbsp;&nbsp;out []byte &nbsp;&nbsp;&nbsp;&nbsp;outUsed int } func NewOFB(b Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;//分组长度 &nbsp;&nbsp;&nbsp;&nbsp;blockSize := b.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != blockSize { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//const streamBufferSize = 512 &nbsp;&nbsp;&nbsp;&nbsp;bufSize := streamBufferSize &nbsp;&nbsp;&nbsp;&nbsp;if bufSize &lt; blockSize { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufSize = blockSize &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x := &amp;ofb{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: b, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cipher: make([]byte, blockSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: make([]byte, 0, bufSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: 0, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;copy(x.cipher, iv) &nbsp;&nbsp;&nbsp;&nbsp;return x } //生成密钥流 func (x *ofb) refill() { &nbsp;&nbsp;&nbsp;&nbsp;bs := x.b.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;remain := len(x.out) - x.outUsed &nbsp;&nbsp;&nbsp;&nbsp;if remain &gt; x.outUsed { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;copy(x.out, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:cap(x.out)] &nbsp;&nbsp;&nbsp;&nbsp;for remain &lt; len(x.out)-bs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.cipher, x.cipher) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy(x.out[remain:], x.cipher) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remain += bs &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:remain] &nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = 0 } func (x *ofb) XORKeyStream(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.outUsed &gt;= len(x.out)-x.b.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//生成密钥流 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.refill() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//与密钥流异或运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n &nbsp;&nbsp;&nbsp;&nbsp;} } //代码位置src/crypto/cipher/ofb.go ``` ## CTR模式 CTR模式，全称Counter模式，译为计数器模式。 CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。 也即最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行异或运算得到的。 如下为CTR模式示意图： go标准库中CTR模式代码如下： ```go type ctr struct { &nbsp;&nbsp;&nbsp;&nbsp;//加密算法 &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;ctr []byte &nbsp;&nbsp;&nbsp;&nbsp;out []byte &nbsp;&nbsp;&nbsp;&nbsp;outUsed int } const streamBufferSize = 512 type ctrAble interface { &nbsp;&nbsp;&nbsp;&nbsp;NewCTR(iv []byte) Stream } func NewCTR(block Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;if ctr, ok := block.(ctrAble); ok { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ctr.NewCTR(iv) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != block.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;cipher.NewCTR: IV length must equal block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;bufSize := streamBufferSize &nbsp;&nbsp;&nbsp;&nbsp;if bufSize &lt; block.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufSize = block.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return &amp;ctr{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: block, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctr: dup(iv), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: make([]byte, 0, bufSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: 0, &nbsp;&nbsp;&nbsp;&nbsp;} } //生成密钥流 func (x *ctr) refill() { &nbsp;&nbsp;&nbsp;&nbsp;remain := len(x.out) - x.outUsed &nbsp;&nbsp;&nbsp;&nbsp;copy(x.out, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:cap(x.out)] &nbsp;&nbsp;&nbsp;&nbsp;bs := x.b.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;for remain &lt;= len(x.out)-bs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.out[remain:], x.ctr) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remain += bs &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//计数器递增 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := len(x.ctr) - 1; i &gt;= 0; i-- { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.ctr[i]++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.ctr[i] != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:remain] &nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = 0 } func (x *ctr) XORKeyStream(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.outUsed &gt;= len(x.out)-x.b.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//生成密钥流 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.refill() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//与密钥流异或运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n &nbsp;&nbsp;&nbsp;&nbsp;} } ``` ## Fabric中CBC模式的AES加密实现 代码如下： ```go //AES加密、CBC模式、PKCS7填充算法 func AESCBCPKCS7Encrypt(key, src []byte) ([]byte, error) { &nbsp;&nbsp;&nbsp;&nbsp;//PKCS7填充算法 &nbsp;&nbsp;&nbsp;&nbsp;tmp := pkcs7Padding(src) &nbsp;&nbsp;&nbsp;&nbsp;//AES加密、CBC模式 &nbsp;&nbsp;&nbsp;&nbsp;return aesCBCEncrypt(key, tmp) } //PKCS7填充算法 //PKCS7即填充字符串由一个字节序列组成，每个字节填充该字节序列的长度 func pkcs7Padding(src []byte) []byte { &nbsp;&nbsp;&nbsp;&nbsp;padding := aes.BlockSize - len(src)%aes.BlockSize &nbsp;&nbsp;&nbsp;&nbsp;padtext := bytes.Repeat([]byte{byte(padding)}, padding) &nbsp;&nbsp;&nbsp;&nbsp;return append(src, padtext...) } //AES加密、CBC模式 func aesCBCEncrypt(key, s []byte) ([]byte, error) { &nbsp;&nbsp;&nbsp;&nbsp;if len(s)%aes.BlockSize != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, errors.New(&quot;Invalid plaintext. It must be a multiple of the block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;block, err := aes.NewCipher(key) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;ciphertext := make([]byte, aes.BlockSize+len(s)) &nbsp;&nbsp;&nbsp;&nbsp;//初始向量IV &nbsp;&nbsp;&nbsp;&nbsp;iv := ciphertext[:aes.BlockSize] &nbsp;&nbsp;&nbsp;&nbsp;if _, err := io.ReadFull(rand.Reader, iv); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;mode := cipher.NewCBCEncrypter(block, iv) &nbsp;&nbsp;&nbsp;&nbsp;mode.CryptBlocks(ciphertext[aes.BlockSize:], s) &nbsp;&nbsp;&nbsp;&nbsp;return ciphertext, nil } //代码位置github.com/hyperledger/fabric/bccsp/sw/aes.go ``` ## 后记 ECB模式因其高风险，不应再使用。 CBC模式、CFB模式、OFB模式、CTR模式，均可使用。 其中Fabric中使用了CBC模式。 待续。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/05/21/94492960e003209f94df2285a280f963.html" />
<meta property="og:url" content="https://mlh.app/2018/05/21/94492960e003209f94df2285a280f963.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"# 对称加密算法的分组模式及其Go语言实现 之前介绍的DES、3DES、AES加密算法，只能加密固定长度的明文。如果需要加密任意长度的明文，需要对明文分组加密。 DES、3DES、AES等又称分组密码，而分组有很多模式，如：ECB模式、CBC模式、CFB模式、OFB模式、CTR模式，如下将逐一介绍。 ## ECB模式 ECB模式，全称Electronic Codebook模式，译为电子密码本模式，即用相同的密码分别对明文分组独立加密。 ECB模式是最简单的模式，因为相同的明文分组会加密为相同的密文分组，因此存在一定风险。 如下为ECB模式示意图： 另外当最后一个明文分组的内容，小于分组长度时，需要用特定的数据进行填充。 ## CBC模式 CBC模式，全称Cipher Block Chaining模式，译为密文分组链接模式，即加密算法的输入是上一个密文分组和下一个明文分组的异或。 因为是将上一个密文分组和下一个明文分组的内容混合加密，因此可以避免ECB模式的缺陷。 当加密第一个明文分组时，由于不存在上一个密文分组，因此需要准备与分组等长的初始化向量IV，来代替上一个密文分组。 如下为CBC模式示意图： go标准库中CBC模式代码如下： ```go type cbc struct { &nbsp;&nbsp;&nbsp;&nbsp;//b为加密算法，如DES、AES &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密算法支持的明文分组长度 &nbsp;&nbsp;&nbsp;&nbsp;blockSize int &nbsp;&nbsp;&nbsp;&nbsp;//初始化向量IV &nbsp;&nbsp;&nbsp;&nbsp;iv []byte &nbsp;&nbsp;&nbsp;&nbsp;//临时变量 &nbsp;&nbsp;&nbsp;&nbsp;tmp []byte } type cbcEncrypter cbc //指定加密算法和IV func NewCBCEncrypter(b Block, iv []byte) BlockMode { &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != b.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;cipher.NewCBCEncrypter: IV length must equal block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if cbc, ok := b.(cbcEncAble); ok { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cbc.NewCBCEncrypter(iv) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return (*cbcEncrypter)(newCBC(b, iv)) } //加密 func (x *cbcEncrypter) CryptBlocks(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;if len(src)%x.blockSize != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;crypto/cipher: input not full blocks&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(dst) &lt; len(src) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;crypto/cipher: output smaller than input&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;iv := x.iv &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//上一个密文分组和下一个明文分组的异或 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//当加密第一个明文分组时，使用初始化向量IV &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xorBytes(dst[:x.blockSize], src[:x.blockSize], iv) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//执行加密算法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(dst[:x.blockSize], dst[:x.blockSize]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv = dst[:x.blockSize] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[x.blockSize:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[x.blockSize:] &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;copy(x.iv, iv) } //代码位置src/crypto/cipher/cbc.go ``` ## CFB模式 CFB模式，全称Cipher FeedBack模式，译为密文反馈模式，即上一个密文分组作为加密算法的输入，输出与明文异或作为下一个分组的密文。 在CFB模式中，明文分组和密文分组之间只有一次异或。 如下为CFB模式示意图： CFB模式与一次性密码本相似，都是通过将明文与随机比特序列进行异或运算来生成密文。 但由于CFB模式中密码算法的输出是通过计算得到的，并非真正的随机数，因此不具备一次性密码本那样理论上不可破译的性质。 CFB模式可以看做使用分组方式实现流密码的方式。 go标准库中CFB模式代码如下： ```go type cfb struct { &nbsp;&nbsp;&nbsp;&nbsp;//加密算法 &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;next []byte &nbsp;&nbsp;&nbsp;&nbsp;//加密的输出 &nbsp;&nbsp;&nbsp;&nbsp;out []byte &nbsp;&nbsp;&nbsp;&nbsp;outUsed int &nbsp;&nbsp;&nbsp;&nbsp;decrypt bool } //加密或解密 //decrypt为true表示解密 func (x *cfb) XORKeyStream(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.outUsed == len(x.out) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.out, x.next) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.decrypt { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy(x.next[x.outUsed:], src) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//加密输出与明文异或作为下一个分组的密文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !x.decrypt { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//上一个密文分组作为加密算法的输入 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy(x.next[x.outUsed:], dst) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n &nbsp;&nbsp;&nbsp;&nbsp;} } //加密器 func NewCFBEncrypter(block Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;return newCFB(block, iv, false) } //解密器 func NewCFBDecrypter(block Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;return newCFB(block, iv, true) } func newCFB(block Block, iv []byte, decrypt bool) Stream { &nbsp;&nbsp;&nbsp;&nbsp;//分组长度 &nbsp;&nbsp;&nbsp;&nbsp;blockSize := block.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != blockSize { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//初始化向量要求与分组长度等长 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;cipher.newCFB: IV length must equal block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x := &amp;cfb{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: block, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: make([]byte, blockSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next: make([]byte, blockSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: blockSize, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decrypt: decrypt, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;copy(x.next, iv) &nbsp;&nbsp;&nbsp;&nbsp;return x } //代码位置src/crypto/cipher/cfb.go ``` ## OFB模式 OFB模式，全称Output Feedback模式，译为输出反馈模式。 OFB模式与CFB模式类似，只是加密算法的输入是上一次加密的输出。 在OFB模式中，异或所需的密钥流，可以事先通过密码算法生成，即生成密钥流的操作可以与异或运算并行。 OFB模式加密和处理解密逻辑相同，明文与密钥流异或生成密文，密文与密钥流异或生成明文。 如下为OFB模式示意图： go标准库中OFB模式代码如下： ```go type ofb struct { &nbsp;&nbsp;&nbsp;&nbsp;//加密算法 &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;cipher []byte &nbsp;&nbsp;&nbsp;&nbsp;out []byte &nbsp;&nbsp;&nbsp;&nbsp;outUsed int } func NewOFB(b Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;//分组长度 &nbsp;&nbsp;&nbsp;&nbsp;blockSize := b.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != blockSize { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//const streamBufferSize = 512 &nbsp;&nbsp;&nbsp;&nbsp;bufSize := streamBufferSize &nbsp;&nbsp;&nbsp;&nbsp;if bufSize &lt; blockSize { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufSize = blockSize &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x := &amp;ofb{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: b, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cipher: make([]byte, blockSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: make([]byte, 0, bufSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: 0, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;copy(x.cipher, iv) &nbsp;&nbsp;&nbsp;&nbsp;return x } //生成密钥流 func (x *ofb) refill() { &nbsp;&nbsp;&nbsp;&nbsp;bs := x.b.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;remain := len(x.out) - x.outUsed &nbsp;&nbsp;&nbsp;&nbsp;if remain &gt; x.outUsed { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;copy(x.out, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:cap(x.out)] &nbsp;&nbsp;&nbsp;&nbsp;for remain &lt; len(x.out)-bs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.cipher, x.cipher) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy(x.out[remain:], x.cipher) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remain += bs &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:remain] &nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = 0 } func (x *ofb) XORKeyStream(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.outUsed &gt;= len(x.out)-x.b.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//生成密钥流 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.refill() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//与密钥流异或运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n &nbsp;&nbsp;&nbsp;&nbsp;} } //代码位置src/crypto/cipher/ofb.go ``` ## CTR模式 CTR模式，全称Counter模式，译为计数器模式。 CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。 也即最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行异或运算得到的。 如下为CTR模式示意图： go标准库中CTR模式代码如下： ```go type ctr struct { &nbsp;&nbsp;&nbsp;&nbsp;//加密算法 &nbsp;&nbsp;&nbsp;&nbsp;b Block &nbsp;&nbsp;&nbsp;&nbsp;//加密的输入 &nbsp;&nbsp;&nbsp;&nbsp;ctr []byte &nbsp;&nbsp;&nbsp;&nbsp;out []byte &nbsp;&nbsp;&nbsp;&nbsp;outUsed int } const streamBufferSize = 512 type ctrAble interface { &nbsp;&nbsp;&nbsp;&nbsp;NewCTR(iv []byte) Stream } func NewCTR(block Block, iv []byte) Stream { &nbsp;&nbsp;&nbsp;&nbsp;if ctr, ok := block.(ctrAble); ok { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ctr.NewCTR(iv) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(iv) != block.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;cipher.NewCTR: IV length must equal block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;bufSize := streamBufferSize &nbsp;&nbsp;&nbsp;&nbsp;if bufSize &lt; block.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufSize = block.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return &amp;ctr{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: block, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctr: dup(iv), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: make([]byte, 0, bufSize), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: 0, &nbsp;&nbsp;&nbsp;&nbsp;} } //生成密钥流 func (x *ctr) refill() { &nbsp;&nbsp;&nbsp;&nbsp;remain := len(x.out) - x.outUsed &nbsp;&nbsp;&nbsp;&nbsp;copy(x.out, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:cap(x.out)] &nbsp;&nbsp;&nbsp;&nbsp;bs := x.b.BlockSize() &nbsp;&nbsp;&nbsp;&nbsp;for remain &lt;= len(x.out)-bs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.out[remain:], x.ctr) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remain += bs &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//计数器递增 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := len(x.ctr) - 1; i &gt;= 0; i-- { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.ctr[i]++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.ctr[i] != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:remain] &nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = 0 } func (x *ctr) XORKeyStream(dst, src []byte) { &nbsp;&nbsp;&nbsp;&nbsp;for len(src) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x.outUsed &gt;= len(x.out)-x.b.BlockSize() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//生成密钥流 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.refill() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//与密钥流异或运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n &nbsp;&nbsp;&nbsp;&nbsp;} } ``` ## Fabric中CBC模式的AES加密实现 代码如下： ```go //AES加密、CBC模式、PKCS7填充算法 func AESCBCPKCS7Encrypt(key, src []byte) ([]byte, error) { &nbsp;&nbsp;&nbsp;&nbsp;//PKCS7填充算法 &nbsp;&nbsp;&nbsp;&nbsp;tmp := pkcs7Padding(src) &nbsp;&nbsp;&nbsp;&nbsp;//AES加密、CBC模式 &nbsp;&nbsp;&nbsp;&nbsp;return aesCBCEncrypt(key, tmp) } //PKCS7填充算法 //PKCS7即填充字符串由一个字节序列组成，每个字节填充该字节序列的长度 func pkcs7Padding(src []byte) []byte { &nbsp;&nbsp;&nbsp;&nbsp;padding := aes.BlockSize - len(src)%aes.BlockSize &nbsp;&nbsp;&nbsp;&nbsp;padtext := bytes.Repeat([]byte{byte(padding)}, padding) &nbsp;&nbsp;&nbsp;&nbsp;return append(src, padtext...) } //AES加密、CBC模式 func aesCBCEncrypt(key, s []byte) ([]byte, error) { &nbsp;&nbsp;&nbsp;&nbsp;if len(s)%aes.BlockSize != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, errors.New(&quot;Invalid plaintext. It must be a multiple of the block size&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;block, err := aes.NewCipher(key) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;ciphertext := make([]byte, aes.BlockSize+len(s)) &nbsp;&nbsp;&nbsp;&nbsp;//初始向量IV &nbsp;&nbsp;&nbsp;&nbsp;iv := ciphertext[:aes.BlockSize] &nbsp;&nbsp;&nbsp;&nbsp;if _, err := io.ReadFull(rand.Reader, iv); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;mode := cipher.NewCBCEncrypter(block, iv) &nbsp;&nbsp;&nbsp;&nbsp;mode.CryptBlocks(ciphertext[aes.BlockSize:], s) &nbsp;&nbsp;&nbsp;&nbsp;return ciphertext, nil } //代码位置github.com/hyperledger/fabric/bccsp/sw/aes.go ``` ## 后记 ECB模式因其高风险，不应再使用。 CBC模式、CFB模式、OFB模式、CTR模式，均可使用。 其中Fabric中使用了CBC模式。 待续。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/05/21/94492960e003209f94df2285a280f963.html","headline":"区块链背后的信息安全(5) 对称加密算法的分组模式及其Go语言实现","dateModified":"2018-05-21T00:00:00+08:00","datePublished":"2018-05-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/05/21/94492960e003209f94df2285a280f963.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链背后的信息安全(5) 对称加密算法的分组模式及其Go语言实现</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="font-weight:700;"><span style="color:#000000;"># 对称加密算法的分组模式及其Go语言实现</span></span></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">之前介绍的DES、3DES、AES加密算法，只能加密固定长度的明文。如果需要加密任意长度的明文，需要对明文分组加密。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">DES、3DES、AES等又称分组密码，而分组有很多模式，如：ECB模式、CBC模式、CFB模式、OFB模式、CTR模式，如下将逐一介绍。</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="font-weight:700;"><span style="color:#000000;">## ECB模式</span></span></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">ECB模式，全称Electronic Codebook模式，译为电子密码本模式，即用相同的密码分别对明文分组独立加密。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">ECB模式是最简单的模式，因为相同的明文分组会加密为相同的密文分组，因此存在一定风险。</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">如下为ECB模式示意图：</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><img src="https://img-blog.csdn.net/20180517122154544" alt=""><br></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">另外当最后一个明文分组的内容，小于分组长度时，需要用特定的数据进行填充。</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="font-weight:700;"><span style="color:#000000;">## CBC模式</span></span></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">CBC模式，全称Cipher Block Chaining模式，译为密文分组链接模式，即加密算法的输入是上一个密文分组和下一个明文分组的异或。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">因为是将上一个密文分组和下一个明文分组的内容混合加密，因此可以避免ECB模式的缺陷。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">当加密第一个明文分组时，由于不存在上一个密文分组，因此需要准备与分组等长的初始化向量IV，来代替上一个密文分组。</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">如下为CBC模式示意图：</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><img src="https://img-blog.csdn.net/20180517122144248" alt=""><br></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">go标准库中CBC模式代码如下：</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">```go</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>type</span> <span>cbc</span> <span>struct</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//b为加密算法，如DES、AES</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;b Block</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//加密算法支持的明文分组长度</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;blockSize <span>int</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//初始化向量IV</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;iv []<span>byte</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//临时变量</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;tmp []<span>byte</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>type</span> <span>cbcEncrypter</span> cbc</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//指定加密算法和IV</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> NewCBCEncrypter(b Block, iv []<span>byte</span>) BlockMode {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> <span>len</span>(iv) != b.BlockSize() {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>panic</span>(<span>"cipher.NewCBCEncrypter: IV length must equal block size"</span>)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> cbc, ok := b.(cbcEncAble); ok {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> cbc.NewCBCEncrypter(iv)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> (*cbcEncrypter)(newCBC(b, iv))</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//加密</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> (x *cbcEncrypter) CryptBlocks(dst, src []<span>byte</span>) {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> <span>len</span>(src)%x.blockSize != <span>0</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>panic</span>(<span>"crypto/cipher: input not full blocks"</span>)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> <span>len</span>(dst) &lt; <span>len</span>(src) {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>panic</span>(<span>"crypto/cipher: output smaller than input"</span>)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;iv := x.iv</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>for</span> <span>len</span>(src) &gt; <span>0</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//上一个密文分组和下一个明文分组的异或</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//当加密第一个明文分组时，使用初始化向量IV</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xorBytes(dst[:x.blockSize], src[:x.blockSize], iv)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//执行加密算法</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(dst[:x.blockSize], dst[:x.blockSize])</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv = dst[:x.blockSize]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[x.blockSize:]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[x.blockSize:]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>copy</span>(x.iv, iv)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//代码位置src/crypto/cipher/cbc.go</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">```</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="font-weight:700;"><span style="color:#000000;">## CFB模式</span></span></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">CFB模式，全称Cipher FeedBack模式，译为密文反馈模式，即上一个密文分组作为加密算法的输入，输出与明文异或作为下一个分组的密文。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">在CFB模式中，明文分组和密文分组之间只有一次异或。</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">如下为CFB模式示意图：</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><img src="https://img-blog.csdn.net/20180517122135790" alt=""><br></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">CFB模式与一次性密码本相似，都是通过将明文与随机比特序列进行异或运算来生成密文。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">但由于CFB模式中密码算法的输出是通过计算得到的，并非真正的随机数，因此不具备一次性密码本那样理论上不可破译的性质。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">CFB模式可以看做使用分组方式实现流密码的方式。</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">go标准库中CFB模式代码如下：</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">```go</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>type</span> <span>cfb</span> <span>struct</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//加密算法</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;b Block</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//加密的输入</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;next []<span>byte</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//加密的输出</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;out []<span>byte</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;outUsed <span>int</span></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;decrypt <span>bool</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//加密或解密</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//decrypt为true表示解密</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> (x *cfb) XORKeyStream(dst, src []<span>byte</span>) {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>for</span> <span>len</span>(src) &gt; <span>0</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> x.outUsed == <span>len</span>(x.out) {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.out, x.next)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = <span>0</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> x.decrypt {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>copy</span>(x.next[x.outUsed:], src)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//加密输出与明文异或作为下一个分组的密文</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:])</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> !x.decrypt {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//上一个密文分组作为加密算法的输入</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>copy</span>(x.next[x.outUsed:], dst)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//加密器</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> NewCFBEncrypter(block Block, iv []<span>byte</span>) Stream {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> newCFB(block, iv, <span>false</span>)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//解密器</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> NewCFBDecrypter(block Block, iv []<span>byte</span>) Stream {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> newCFB(block, iv, <span>true</span>)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> newCFB(block Block, iv []<span>byte</span>, decrypt <span>bool</span>) Stream {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//分组长度</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;blockSize := block.BlockSize()</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> <span>len</span>(iv) != blockSize {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//初始化向量要求与分组长度等长</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>panic</span>(<span>"cipher.newCFB: IV length must equal block size"</span>)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;x := &amp;cfb{</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: block,</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: <span>make</span>([]<span>byte</span>, blockSize),</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next: <span>make</span>([]<span>byte</span>, blockSize),</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: blockSize,</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decrypt: decrypt,</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//加密的输入</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>copy</span>(x.next, iv)</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> x</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//代码位置src/crypto/cipher/cfb.go</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">```</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="font-weight:700;"><span style="color:#000000;">## OFB模式</span></span></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">OFB模式，全称Output Feedback模式，译为输出反馈模式。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">OFB模式与CFB模式类似，只是加密算法的输入是上一次加密的输出。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">在OFB模式中，异或所需的密钥流，可以事先通过密码算法生成，即生成密钥流的操作可以与异或运算并行。</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">OFB模式加密和处理解密逻辑相同，明文与密钥流异或生成密文，密文与密钥流异或生成明文。</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">如下为OFB模式示意图：</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><img src="https://img-blog.csdn.net/2018051712212690" alt=""><br></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">go标准库中OFB模式代码如下：</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">```go</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>type</span> <span>ofb</span> <span>struct</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//加密算法</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;b Block</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//加密的输入</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;cipher []<span>byte</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;out []<span>byte</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;outUsed <span>int</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> NewOFB(b Block, iv []<span>byte</span>) Stream {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//分组长度</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;blockSize := b.BlockSize()</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> <span>len</span>(iv) != blockSize {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> <span>nil</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//const streamBufferSize = 512</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;bufSize := streamBufferSize</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> bufSize &lt; blockSize {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufSize = blockSize</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;x := &amp;ofb{</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: b,</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cipher: <span>make</span>([]<span>byte</span>, blockSize),</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: <span>make</span>([]<span>byte</span>, <span>0</span>, bufSize),</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: <span>0</span>,</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//加密的输入</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>copy</span>(x.cipher, iv)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> x</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//生成密钥流</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> (x *ofb) refill() {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;bs := x.b.BlockSize()</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;remain := <span>len</span>(x.out) - x.outUsed</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> remain &gt; x.outUsed {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>copy</span>(x.out, x.out[x.outUsed:])</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:<span>cap</span>(x.out)]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>for</span> remain &lt; <span>len</span>(x.out)-bs {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.cipher, x.cipher)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>copy</span>(x.out[remain:], x.cipher)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remain += bs</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:remain]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = <span>0</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> (x *ofb) XORKeyStream(dst, src []<span>byte</span>) {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>for</span> <span>len</span>(src) &gt; <span>0</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> x.outUsed &gt;= <span>len</span>(x.out)-x.b.BlockSize() {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//生成密钥流</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.refill()</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//与密钥流异或运算</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:])</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//代码位置src/crypto/cipher/ofb.go</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">```</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="font-weight:700;"><span style="color:#000000;">## CTR模式</span></span></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">CTR模式，全称Counter模式，译为计数器模式。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">也即最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行异或运算得到的。</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">如下为CTR模式示意图：</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><img src="https://img-blog.csdn.net/20180517122209761" alt=""><br></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">go标准库中CTR模式代码如下：</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">```go</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>type</span> <span>ctr</span> <span>struct</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//加密算法</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;b Block</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//加密的输入</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;ctr []<span>byte</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;out []<span>byte</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;outUsed <span>int</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>const</span> streamBufferSize = <span>512</span></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>type</span> <span>ctrAble</span> <span>interface</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;NewCTR(iv []<span>byte</span>) Stream</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> NewCTR(block Block, iv []<span>byte</span>) Stream {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> ctr, ok := block.(ctrAble); ok {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> ctr.NewCTR(iv)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> <span>len</span>(iv) != block.BlockSize() {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>panic</span>(<span>"cipher.NewCTR: IV length must equal block size"</span>)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;bufSize := streamBufferSize</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> bufSize &lt; block.BlockSize() {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufSize = block.BlockSize()</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> &amp;ctr{</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: block,</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctr: dup(iv),</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out: <span>make</span>([]<span>byte</span>, <span>0</span>, bufSize),</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outUsed: <span>0</span>,</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//生成密钥流</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> (x *ctr) refill() {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;remain := <span>len</span>(x.out) - x.outUsed</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>copy</span>(x.out, x.out[x.outUsed:])</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:<span>cap</span>(x.out)]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;bs := x.b.BlockSize()</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>for</span> remain &lt;= <span>len</span>(x.out)-bs {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.b.Encrypt(x.out[remain:], x.ctr)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remain += bs</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//计数器递增</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>for</span> i := <span>len</span>(x.ctr) - <span>1</span>; i &gt;= <span>0</span>; i-- {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.ctr[i]++</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> x.ctr[i] != <span>0</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>break</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;x.out = x.out[:remain]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed = <span>0</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> (x *ctr) XORKeyStream(dst, src []<span>byte</span>) {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>for</span> <span>len</span>(src) &gt; <span>0</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> x.outUsed &gt;= <span>len</span>(x.out)-x.b.BlockSize() {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//生成密钥流</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.refill()</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//与密钥流异或运算</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n := xorBytes(dst, src, x.out[x.outUsed:])</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst = dst[n:]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src = src[n:]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.outUsed += n</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">```</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="font-weight:700;"><span style="color:#000000;">## Fabric中CBC模式的AES加密实现</span></span></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">代码如下：</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">```go</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//AES加密、CBC模式、PKCS7填充算法</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> AESCBCPKCS7Encrypt(key, src []<span>byte</span>) ([]<span>byte</span>, <span>error</span>) {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//PKCS7填充算法</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;tmp := pkcs7Padding(src)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//AES加密、CBC模式</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> aesCBCEncrypt(key, tmp)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//PKCS7填充算法</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//PKCS7即填充字符串由一个字节序列组成，每个字节填充该字节序列的长度</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> pkcs7Padding(src []<span>byte</span>) []<span>byte</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;padding := aes.BlockSize - <span>len</span>(src)%aes.BlockSize</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;padtext := bytes.Repeat([]<span>byte</span>{byte(padding)}, padding)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> <span>append</span>(src, padtext...)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//AES加密、CBC模式</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><span>func</span> aesCBCEncrypt(key, s []<span>byte</span>) ([]<span>byte</span>, <span>error</span>) {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> <span>len</span>(s)%aes.BlockSize != <span>0</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> <span>nil</span>, errors.New(<span>"Invalid plaintext. It must be a multiple of the block size"</span>)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;block, err := aes.NewCipher(key)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> err != <span>nil</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> <span>nil</span>, err</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;ciphertext := <span>make</span>([]<span>byte</span>, aes.BlockSize+<span>len</span>(s))</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>//初始向量IV</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;iv := ciphertext[:aes.BlockSize]</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>if</span> _, err := io.ReadFull(rand.Reader, iv); err != <span>nil</span> {</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> <span>nil</span>, err</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;}</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;mode := cipher.NewCBCEncrypter(block, iv)</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;mode.CryptBlocks(ciphertext[aes.BlockSize:], s)</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;<span>return</span> ciphertext, <span>nil</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">}</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="color:#000000;">//代码位置github.com/hyperledger/fabric/bccsp/sw/aes.go</span></span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">```</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span><span style="font-weight:700;"><span style="color:#000000;">## 后记</span></span></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">ECB模式因其高风险，不应再使用。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">CBC模式、CFB模式、OFB模式、CTR模式，均可使用。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">其中Fabric中使用了CBC模式。</span>
  </div>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;">待续。</span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <h2 style="font-family:Consolas, 'Courier New', monospace;"><span style="color:#000000;"><img src="https://img-blog.csdn.net/20180430224554793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><br></span></h2>
  <p style="font-family:Consolas, 'Courier New', monospace;"><span style="color:#000000;"><img src="https://img-blog.csdn.net/20180425001235188?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><img src="https://img-blog.csdn.net/20180425001144107?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p>
  <p style="font-family:Consolas, 'Courier New', monospace;"><span style="color:#000000;">网址：http://www.qukuailianxueyuan.io/<br></span></p>
  <p style="font-family:Consolas, 'Courier New', monospace;"><span style="color:#000000;"><img src="https://img-blog.csdn.net/20180426145827720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p>
  <p style="font-family:Consolas, 'Courier New', monospace;"><span style="color:#000000;"><img src="https://img-blog.csdn.net/2018042614570887?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p>
  <p style="font-family:Consolas, 'Courier New', monospace;"><span style="color:#000000;">欲领取造币技术与全套虚拟机资料</span></p>
  <p style="font-family:Consolas, 'Courier New', monospace;"><span style="color:#000000;"><span>区块链技术交流QQ群：</span><span style="background-color:rgb(255,255,255);">756146052&nbsp;&nbsp;</span><span>备注：CSDN</span></span></p>
  <p style="font-family:Consolas, 'Courier New', monospace;"><span style="color:#000000;">尹成学院微信：备注：CSDN</span></p>
  <p style="text-align:center;font-family:Consolas, 'Courier New', monospace;"><span style="color:#000000;"><img src="https://img-blog.csdn.net/20180425000635656?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></span></p>
  <div style="font-family:Consolas, 'Courier New', monospace;font-size:14px;">
   <span style="color:#000000;"><br></span>
  </div>
  <span style="color:#000000;"><br style="font-family:Consolas, 'Courier New', monospace;font-size:14px;"></span>
  <br style="color:rgb(212,212,212);font-family:Consolas, 'Courier New', monospace;font-size:14px;"> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/itcastcpp/article/details/80391345,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/itcastcpp/article/details/80391345,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
