<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>gossip算法个人实现思路 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="gossip算法个人实现思路" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法背景 由于卡夫卡集群的特性，在系统运行一段时间后（默认配置是7天），会自动清除掉过期的记录，因此每个周期之后加入的节点都会丢失一部分数据。于是，我们需要一个机制能不依赖卡夫卡集群来实现数据的一致性，这就是我接下来要讲的Gossip算法。 2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法简介 Gossip算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此Gossip有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。 在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。 Gossip是一种去中心化、容错而又最终一致性的绝妙算法，其收敛性不但得到证明还具有指数级的收敛速度。使用Gossip的系统可以很容易的把Server扩展到更多的节点，满足弹性扩展轻而易举。 3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法目的 当卡夫卡集群无法保证数据一致性时，通过此算法，保证系统最终数据一致。同时，还可支持节点间各种类型的消息传播。 4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法实现 算法主要实现了三个功能1.在线节点不断广播”Alive”消息来指示它们的可用性；2.在数据和其他节点不一致时，同步其他节点数据；3.在有新数据进入网络时，节点间通过不断的对随机相邻节点广播，最终达到数据一致性。 a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点启动时，向卡夫卡集群发送连接消息，类型为KafkaMessage_Connect &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到此连接消息后，加入alivePeerNode[]切片，保存此节点地址和收到消息时的时间戳并记录区块高度 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向此节点发送响应连接信息，类型为ConnRspMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此节点收到ConnRspMsg指令消息后，加入alivePeerNode[]，保存发送节点的地址和收到消息时的时间戳并记录区块高度 b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;心跳机制 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点启动时启动timer计时器，每隔5秒发送心跳消息，类型为AliveMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到AliveMsg指令消息后，加入alivePeerNode[]切片，保存A节点地址和收到消息时的时间戳并记录区块高度后转发此消息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新起goroutine，遍历alivePeerNode []切片，对比时间戳，超过25秒的节点剔除出切片 c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信息交换机制 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A节点每隔4秒广播自己的区块高度，类型GossipMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B节点收到A节点GossipMsg指令消息后，对比区块高度，若h(B)&gt;h (A)，则返回ProcessMsg：Push和自己的区块数据区间AckBlock[h(A)+1, h (B)] ；若h(B)&lt;h(A)，则返回ProcessMsg：Pull和自己需要区块长度区间[h(B)+1, h (A)]，类型GossipAckMsg；若h(B)=h (A)，则返回ProcessMsg：Equals &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A节点收到B节点GossipAckMsg指令消息后，检查ProcessMsg类型，如果是push，则读取区块数据区间，逐一加入账本；如果是Pull，则将指定区块长度区间的数据放入Ack2Block[]，如果是Equals，不做处理。处理完成后，检查本地账本高度h’(A)是否等于h(A)，若不等于，说明在此通信过程中，A又有新加入的区块，把新加入的区块加入AckBlock[]，返回给B，类型GossipAck2Msg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B节点收到A节点类型为GossipAck2Msg的消息，检查Ack2Block[]是否有数据，若有，则同步至本地账本 d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据分发机制 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Leader节点(节点启动时，根据配置指定)在收到kafka客户端发送来的并切分成区块并记录账本后，广播此区块消息，类型为KafkaMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到消息后，对比区块高度，若正好比本地高1，则放入账本，否则不做处理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理完成后转发此消息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：若每个节点都是Leader节点，其实这个机制就没必要，考虑后续可能会增加其他类型（不止是区块）的信息，因而实现此机制 特别说明： 节点间的通讯方式：gRPC 节点广播的过滤条件：1.存在于alivePeerNode[]中，即是活跃节点 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.是本链的节点（加入多链后实现） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.节点签名满足要求（加入权限控制后实现） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 消息转发的条件：1.转发总次数不超过progatateTotalIter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.存活时间不超过progatateMaxSurvival 5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法配置 orgLeader：true&nbsp; # 是否指定本节点为组织代表节点 endpoint： # gossipID，默认为地址 progatateIterations:1 #消息转发次数 propagatePeerNum: 3 #推送消息给指定节点的个数 progatateTotalIters:15 #消息转发最大次数 progatateMaxSurvival:30s #消息存活最长时间 pullInterval:4s #拉取消息的时间间隔 aliveTimeInterval:5s #定期发送Alive心跳时间的时间间隔 aliveExpirationTimeOut:25s #Alive心跳时间的超时时间 6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法可能存在的问题及解决方案 a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若广播时，与其他节点建立不了连接怎么办，需要重连吗？ 暂时不做重连 b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与其他节点连接(重连)失败，需要重新选取节点发送吗？ 暂时不重新选取，等下一轮发送周期 c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 简化版实现： 取消心跳机制，只在新节点初次连接时维护aliveNode，随机选择3个节点做数据同步，只做pull请求，接受节点返回的区块处理存入账本。 阅读更多" />
<meta property="og:description" content="1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法背景 由于卡夫卡集群的特性，在系统运行一段时间后（默认配置是7天），会自动清除掉过期的记录，因此每个周期之后加入的节点都会丢失一部分数据。于是，我们需要一个机制能不依赖卡夫卡集群来实现数据的一致性，这就是我接下来要讲的Gossip算法。 2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法简介 Gossip算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此Gossip有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。 在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。 Gossip是一种去中心化、容错而又最终一致性的绝妙算法，其收敛性不但得到证明还具有指数级的收敛速度。使用Gossip的系统可以很容易的把Server扩展到更多的节点，满足弹性扩展轻而易举。 3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法目的 当卡夫卡集群无法保证数据一致性时，通过此算法，保证系统最终数据一致。同时，还可支持节点间各种类型的消息传播。 4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法实现 算法主要实现了三个功能1.在线节点不断广播”Alive”消息来指示它们的可用性；2.在数据和其他节点不一致时，同步其他节点数据；3.在有新数据进入网络时，节点间通过不断的对随机相邻节点广播，最终达到数据一致性。 a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点启动时，向卡夫卡集群发送连接消息，类型为KafkaMessage_Connect &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到此连接消息后，加入alivePeerNode[]切片，保存此节点地址和收到消息时的时间戳并记录区块高度 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向此节点发送响应连接信息，类型为ConnRspMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此节点收到ConnRspMsg指令消息后，加入alivePeerNode[]，保存发送节点的地址和收到消息时的时间戳并记录区块高度 b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;心跳机制 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点启动时启动timer计时器，每隔5秒发送心跳消息，类型为AliveMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到AliveMsg指令消息后，加入alivePeerNode[]切片，保存A节点地址和收到消息时的时间戳并记录区块高度后转发此消息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新起goroutine，遍历alivePeerNode []切片，对比时间戳，超过25秒的节点剔除出切片 c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信息交换机制 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A节点每隔4秒广播自己的区块高度，类型GossipMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B节点收到A节点GossipMsg指令消息后，对比区块高度，若h(B)&gt;h (A)，则返回ProcessMsg：Push和自己的区块数据区间AckBlock[h(A)+1, h (B)] ；若h(B)&lt;h(A)，则返回ProcessMsg：Pull和自己需要区块长度区间[h(B)+1, h (A)]，类型GossipAckMsg；若h(B)=h (A)，则返回ProcessMsg：Equals &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A节点收到B节点GossipAckMsg指令消息后，检查ProcessMsg类型，如果是push，则读取区块数据区间，逐一加入账本；如果是Pull，则将指定区块长度区间的数据放入Ack2Block[]，如果是Equals，不做处理。处理完成后，检查本地账本高度h’(A)是否等于h(A)，若不等于，说明在此通信过程中，A又有新加入的区块，把新加入的区块加入AckBlock[]，返回给B，类型GossipAck2Msg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B节点收到A节点类型为GossipAck2Msg的消息，检查Ack2Block[]是否有数据，若有，则同步至本地账本 d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据分发机制 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Leader节点(节点启动时，根据配置指定)在收到kafka客户端发送来的并切分成区块并记录账本后，广播此区块消息，类型为KafkaMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到消息后，对比区块高度，若正好比本地高1，则放入账本，否则不做处理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理完成后转发此消息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：若每个节点都是Leader节点，其实这个机制就没必要，考虑后续可能会增加其他类型（不止是区块）的信息，因而实现此机制 特别说明： 节点间的通讯方式：gRPC 节点广播的过滤条件：1.存在于alivePeerNode[]中，即是活跃节点 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.是本链的节点（加入多链后实现） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.节点签名满足要求（加入权限控制后实现） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 消息转发的条件：1.转发总次数不超过progatateTotalIter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.存活时间不超过progatateMaxSurvival 5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法配置 orgLeader：true&nbsp; # 是否指定本节点为组织代表节点 endpoint： # gossipID，默认为地址 progatateIterations:1 #消息转发次数 propagatePeerNum: 3 #推送消息给指定节点的个数 progatateTotalIters:15 #消息转发最大次数 progatateMaxSurvival:30s #消息存活最长时间 pullInterval:4s #拉取消息的时间间隔 aliveTimeInterval:5s #定期发送Alive心跳时间的时间间隔 aliveExpirationTimeOut:25s #Alive心跳时间的超时时间 6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法可能存在的问题及解决方案 a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若广播时，与其他节点建立不了连接怎么办，需要重连吗？ 暂时不做重连 b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与其他节点连接(重连)失败，需要重新选取节点发送吗？ 暂时不重新选取，等下一轮发送周期 c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 简化版实现： 取消心跳机制，只在新节点初次连接时维护aliveNode，随机选择3个节点做数据同步，只做pull请求，接受节点返回的区块处理存入账本。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/05/21/8f590d141ebd84a67aacaeb1629c3aa9.html" />
<meta property="og:url" content="https://mlh.app/2018/05/21/8f590d141ebd84a67aacaeb1629c3aa9.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法背景 由于卡夫卡集群的特性，在系统运行一段时间后（默认配置是7天），会自动清除掉过期的记录，因此每个周期之后加入的节点都会丢失一部分数据。于是，我们需要一个机制能不依赖卡夫卡集群来实现数据的一致性，这就是我接下来要讲的Gossip算法。 2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法简介 Gossip算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此Gossip有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。 在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。 Gossip是一种去中心化、容错而又最终一致性的绝妙算法，其收敛性不但得到证明还具有指数级的收敛速度。使用Gossip的系统可以很容易的把Server扩展到更多的节点，满足弹性扩展轻而易举。 3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法目的 当卡夫卡集群无法保证数据一致性时，通过此算法，保证系统最终数据一致。同时，还可支持节点间各种类型的消息传播。 4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法实现 算法主要实现了三个功能1.在线节点不断广播”Alive”消息来指示它们的可用性；2.在数据和其他节点不一致时，同步其他节点数据；3.在有新数据进入网络时，节点间通过不断的对随机相邻节点广播，最终达到数据一致性。 a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点启动时，向卡夫卡集群发送连接消息，类型为KafkaMessage_Connect &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到此连接消息后，加入alivePeerNode[]切片，保存此节点地址和收到消息时的时间戳并记录区块高度 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向此节点发送响应连接信息，类型为ConnRspMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此节点收到ConnRspMsg指令消息后，加入alivePeerNode[]，保存发送节点的地址和收到消息时的时间戳并记录区块高度 b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;心跳机制 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点启动时启动timer计时器，每隔5秒发送心跳消息，类型为AliveMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到AliveMsg指令消息后，加入alivePeerNode[]切片，保存A节点地址和收到消息时的时间戳并记录区块高度后转发此消息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新起goroutine，遍历alivePeerNode []切片，对比时间戳，超过25秒的节点剔除出切片 c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信息交换机制 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A节点每隔4秒广播自己的区块高度，类型GossipMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B节点收到A节点GossipMsg指令消息后，对比区块高度，若h(B)&gt;h (A)，则返回ProcessMsg：Push和自己的区块数据区间AckBlock[h(A)+1, h (B)] ；若h(B)&lt;h(A)，则返回ProcessMsg：Pull和自己需要区块长度区间[h(B)+1, h (A)]，类型GossipAckMsg；若h(B)=h (A)，则返回ProcessMsg：Equals &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A节点收到B节点GossipAckMsg指令消息后，检查ProcessMsg类型，如果是push，则读取区块数据区间，逐一加入账本；如果是Pull，则将指定区块长度区间的数据放入Ack2Block[]，如果是Equals，不做处理。处理完成后，检查本地账本高度h’(A)是否等于h(A)，若不等于，说明在此通信过程中，A又有新加入的区块，把新加入的区块加入AckBlock[]，返回给B，类型GossipAck2Msg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B节点收到A节点类型为GossipAck2Msg的消息，检查Ack2Block[]是否有数据，若有，则同步至本地账本 d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据分发机制 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Leader节点(节点启动时，根据配置指定)在收到kafka客户端发送来的并切分成区块并记录账本后，广播此区块消息，类型为KafkaMsg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到消息后，对比区块高度，若正好比本地高1，则放入账本，否则不做处理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理完成后转发此消息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：若每个节点都是Leader节点，其实这个机制就没必要，考虑后续可能会增加其他类型（不止是区块）的信息，因而实现此机制 特别说明： 节点间的通讯方式：gRPC 节点广播的过滤条件：1.存在于alivePeerNode[]中，即是活跃节点 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.是本链的节点（加入多链后实现） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.节点签名满足要求（加入权限控制后实现） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 消息转发的条件：1.转发总次数不超过progatateTotalIter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.存活时间不超过progatateMaxSurvival 5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法配置 orgLeader：true&nbsp; # 是否指定本节点为组织代表节点 endpoint： # gossipID，默认为地址 progatateIterations:1 #消息转发次数 propagatePeerNum: 3 #推送消息给指定节点的个数 progatateTotalIters:15 #消息转发最大次数 progatateMaxSurvival:30s #消息存活最长时间 pullInterval:4s #拉取消息的时间间隔 aliveTimeInterval:5s #定期发送Alive心跳时间的时间间隔 aliveExpirationTimeOut:25s #Alive心跳时间的超时时间 6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法可能存在的问题及解决方案 a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若广播时，与其他节点建立不了连接怎么办，需要重连吗？ 暂时不做重连 b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与其他节点连接(重连)失败，需要重新选取节点发送吗？ 暂时不重新选取，等下一轮发送周期 c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 简化版实现： 取消心跳机制，只在新节点初次连接时维护aliveNode，随机选择3个节点做数据同步，只做pull请求，接受节点返回的区块处理存入账本。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/05/21/8f590d141ebd84a67aacaeb1629c3aa9.html","headline":"gossip算法个人实现思路","dateModified":"2018-05-21T00:00:00+08:00","datePublished":"2018-05-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/05/21/8f590d141ebd84a67aacaeb1629c3aa9.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>gossip算法个人实现思路</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><span style="color:#000000;"><strong><span style="font-family:Calibri;">1.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法背景</strong></span></p>
  <p><span style="color:#000000;">由于卡夫卡集群的特性，在系统运行一段时间后（默认配置是<span style="font-family:Calibri;">7</span>天），会自动清除掉过期的记录，因此每个周期之后加入的节点都会丢失一部分数据。于是，我们需要一个机制能不依赖卡夫卡集群来实现数据的一致性，这就是我接下来要讲的<span style="font-family:Calibri;">Gossip</span>算法。</span></p>
  <p><span style="color:#000000;"><strong><span style="font-family:Calibri;">2.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法简介</strong></span></p>
  <p><span style="font-family:Calibri;color:#000000;">Gossip</span>算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此<span style="font-family:Calibri;">Gossip</span>有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。</p>
  <p><span style="color:#000000;">在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。</span></p>
  <p><span style="font-family:Calibri;color:#000000;">Gossip</span>是一种去中心化、容错而又最终一致性的绝妙算法，其收敛性不但得到证明还具有指数级的收敛速度。使用<span style="font-family:Calibri;">Gossip</span>的系统可以很容易的把<span style="font-family:Calibri;">Server</span>扩展到更多的节点，满足弹性扩展轻而易举。</p>
  <p><span style="color:#000000;"><strong><span style="font-family:Calibri;">3.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法目的</strong></span></p>
  <p><span style="color:#000000;">当卡夫卡集群无法保证数据一致性时，通过此算法，保证系统最终数据一致。同时，还可支持节点间各种类型的消息传播。</span></p>
  <p><span style="color:#000000;"><strong><span style="font-family:Calibri;">4.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法实现</strong></span></p>
  <p><span style="color:#000000;">算法主要实现了三个功能<span style="font-family:Calibri;">1.</span>在线节点不断广播<span style="font-family:Calibri;">”Alive”</span>消息来指示它们的可用性；<span style="font-family:Calibri;">2.</span>在数据和其他节点不一致时，同步其他节点数据；<span style="font-family:Calibri;">3.</span>在有新数据进入网络时，节点间通过不断的对随机相邻节点广播，最终达到数据一致性。</span><strong></strong></p>
  <p><span style="font-family:Calibri;color:#000000;">a)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化</p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">i.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点启动时，向卡夫卡集群发送连接消息，类型为<span style="font-family:Calibri;">KafkaMessage_Connect</span></span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">ii.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到此连接消息后，加入<span style="font-family:Calibri;">alivePeerNode[]</span>切片，保存此节点地址和收到消息时的时间戳并记录区块高度</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">iii.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向此节点发送响应连接信息，类型为<span style="font-family:Calibri;">ConnRspMsg</span></span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">iv.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此节点收到<span style="font-family:Calibri;">ConnRspMsg</span>指令消息后，加入<span style="font-family:Calibri;">alivePeerNode[]</span>，保存发送节点的地址和收到消息时的时间戳并记录区块高度</span></p>
  <p><span style="font-family:Calibri;color:#000000;">b)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;心跳机制</p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">i.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点启动时启动<span style="font-family:Calibri;">timer</span>计时器，每隔<span style="font-family:Calibri;">5</span>秒发送心跳消息，类型为<span style="font-family:Calibri;">AliveMsg </span></span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">ii.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到<span style="font-family:Calibri;">AliveMsg</span>指令消息后，加入<span style="font-family:Calibri;">alivePeerNode[]</span>切片，保存<span style="font-family:Calibri;">A</span>节点地址和收到消息时的时间戳并记录区块高度后转发此消息</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">iii.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新起<span style="font-family:Calibri;">goroutine</span>，遍历<span style="font-family:Calibri;">alivePeerNode []</span>切片，对比时间戳，超过<span style="font-family:Calibri;">25</span>秒的节点剔除出切片</span></p>
  <p><span style="font-family:Calibri;color:#000000;">c)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信息交换机制</p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">i.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">A</span>节点每隔<span style="font-family:Calibri;">4</span>秒广播自己的区块高度，类型<span style="font-family:Calibri;">GossipMsg</span></span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">ii.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">B</span>节点收到<span style="font-family:Calibri;">A</span>节点<span style="font-family:Calibri;">GossipMsg</span>指令消息后，对比区块高度，若<span style="font-family:Calibri;">h(B)&gt;h (A)</span>，则返回<span style="font-family:Calibri;">ProcessMsg</span>：<span style="font-family:Calibri;">Push</span>和自己的区块数据区间<span style="font-family:Calibri;">AckBlock[h(A)+1, h (B)]</span></span><span style="font-family:Calibri;color:#000000;"> </span><span style="color:#000000;">；若<span style="font-family:Calibri;">h(B)&lt;h(A)</span>，则返回<span style="font-family:Calibri;">ProcessMsg</span>：<span style="font-family:Calibri;">Pull</span>和自己需要区块长度区间<span style="font-family:Calibri;">[h(B)+1, h (A)]</span>，类型<span style="font-family:Calibri;">GossipAckMsg</span>；若<span style="font-family:Calibri;">h(B)=h (A)</span>，则返回<span style="font-family:Calibri;">ProcessMsg</span>：<span style="font-family:Calibri;">Equals</span></span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">iii.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">A</span>节点收到<span style="font-family:Calibri;">B</span>节点<span style="font-family:Calibri;">GossipAckMsg</span>指令消息后，检查<span style="font-family:Calibri;">ProcessMsg</span>类型，如果是<span style="font-family:Calibri;">push</span>，则读取区块数据区间，逐一加入账本；如果是<span style="font-family:Calibri;">Pull</span>，则将指定区块长度区间的数据放入<span style="font-family:Calibri;">Ack2Block[]</span></span><span style="color:#000000;">，如果是<span style="font-family:Calibri;">Equals</span>，不做处理。处理完成后，检查本地账本高度<span style="font-family:Calibri;">h’(A)</span>是否等于<span style="font-family:Calibri;">h(A)</span>，若不等于，说明在此通信过程中，<span style="font-family:Calibri;">A</span>又有新加入的区块，把新加入的区块加入<span style="font-family:Calibri;">AckBlock[]</span>，返回给<span style="font-family:Calibri;">B</span>，类型<span style="font-family:Calibri;">GossipAck2Msg</span></span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">iv.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">B</span>节点收到<span style="font-family:Calibri;">A</span>节点类型为<span style="font-family:Calibri;">GossipAck2Msg</span>的消息，检查<span style="font-family:Calibri;">Ack2Block[]</span>是否有数据，若有，则同步至本地账本</span></p>
  <p><span style="font-family:Calibri;color:#000000;">d)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据分发机制</p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">i.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">Leader</span>节点<span style="font-family:Calibri;">(</span>节点启动时，根据配置指定<span style="font-family:Calibri;">)</span>在收到<span style="font-family:Calibri;">kafka</span>客户端发送来的并切分成区块并记录账本后，广播此区块消息，类型为<span style="font-family:Calibri;">KafkaMsg</span></span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">ii.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他节点收到消息后，对比区块高度，若正好比本地高<span style="font-family:Calibri;">1</span>，则放入账本，否则不做处理</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">iii.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理完成后转发此消息</span></p>
  <p><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">iv.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">PS</span>：若每个节点都是<span style="font-family:Calibri;">Leader</span>节点，其实这个机制就没必要，考虑后续可能会增加其他类型（不止是区块）的信息，因而实现此机制</span></p>
  <p><span><span style="color:#FF0000;">特别说明：</span></span></p>
  <p><span style="color:#000000;">节点间的通讯方式：<span style="font-family:Calibri;">gRPC</span></span></p>
  <p><span style="color:#000000;">节点广播的过滤条件：<span style="font-family:Calibri;">1.</span>存在于<span style="font-family:Calibri;">alivePeerNode[]</span>中，即是活跃节点</span></p>
  <p><span style="font-family:Calibri;color:#000000;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.</span>是本链的节点（加入多链后实现）</p>
  <p><span style="font-family:Calibri;color:#000000;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.</span>节点签名满足要求（加入权限控制后实现）</p>
  <p><span style="font-family:Calibri;color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>消息转发的条件：<span style="font-family:Calibri;">1.</span>转发总次数不超过<span style="font-family:Calibri;">progatateTotalIter</span></p>
  <p><span style="font-family:Calibri;color:#000000;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.</span>存活时间不超过<span style="font-family:Calibri;">progatateMaxSurvival</span></p>
  <p><span style="color:#000000;"><strong><span style="font-family:Calibri;">5.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法配置</strong></span></p>
  <p><span style="font-family:Calibri;color:#000000;">orgLeader</span>：<span style="font-family:Calibri;">true&nbsp; # </span>是否指定本节点为组织代表节点</p>
  <p><span style="font-family:Calibri;color:#000000;">endpoint</span>：<span style="font-family:Calibri;"> # gossipID</span>，默认为地址</p>
  <p><span style="font-family:Calibri;color:#000000;">progatateIterations:1 #</span>消息转发次数</p>
  <p><span style="font-family:Calibri;color:#000000;">propagatePeerNum: 3 #</span>推送消息给指定节点的个数</p>
  <p><span style="font-family:Calibri;color:#000000;">progatateTotalIters:15 #</span>消息转发最大次数</p>
  <p><span style="font-family:Calibri;color:#000000;">progatateMaxSurvival:30s #</span>消息存活最长时间</p>
  <p><span style="font-family:Calibri;color:#000000;">pullInterval:4s #</span>拉取消息的时间间隔</p>
  <p><span style="font-family:Calibri;color:#000000;">aliveTimeInterval:5s #</span>定期发送<span style="font-family:Calibri;">Alive</span>心跳时间的时间间隔</p>
  <p><span style="font-family:Calibri;color:#000000;">aliveExpirationTimeOut:25s #Alive</span>心跳时间的超时时间</p>
  <p><span style="color:#000000;"><strong><span style="font-family:Calibri;">6.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 算法可能存在的问题及解决方案</strong></span></p>
  <p><span style="font-family:Calibri;color:#000000;">a)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若广播时，与其他节点建立不了连接怎么办，需要重连吗？</p>
  <p><span style="color:#000000;">暂时不做重连</span></p>
  <p><span style="font-family:Calibri;color:#000000;">b)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与其他节点连接<span style="font-family:Calibri;">(</span>重连<span style="font-family:Calibri;">)</span>失败，需要重新选取节点发送吗？</p>
  <p><span style="color:#000000;">暂时不重新选取，等下一轮发送周期</span></p>
  <p><span style="font-family:Calibri;color:#000000;">c)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:Calibri;">&nbsp;</span></p>
  <p><span style="font-family:Calibri;color:#000000;">&nbsp;</span></p>
  <p><strong><span style="color:#000000;">简化版实现：</span></strong></p>
  <p><span style="color:#000000;">取消心跳机制，只在新节点初次连接时维护<span style="font-family:Calibri;">aliveNode</span>，随机选择<span style="font-family:Calibri;">3</span>个节点做数据同步，只做<span style="font-family:Calibri;">pull</span>请求，接受节点返回的区块处理存入账本。</span></p>
  <div>
   <hr size="1" align="left">
   <div>
    <div>
     <p><br></p>
    </div>
   </div>
  </div>
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u012107512/article/details/80395081,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u012107512/article/details/80395081,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
