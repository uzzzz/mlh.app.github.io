<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链共识算法(2)PoW挖矿算法原理及其在比特币、以太坊中的实现 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链共识算法(2)PoW挖矿算法原理及其在比特币、以太坊中的实现" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="# PoW挖矿算法原理及其在比特币、以太坊中的实现 PoW，全称Proof of Work，即工作量证明，又称挖矿。 大部分公有链或虚拟货币，如比特币、以太坊，均基于PoW算法，来实现其共识机制。 即根据挖矿贡献的有效工作，来决定货币的分配。 ### 比特币区块 比特币区块由区块头和该区块所包含的交易列表组成。 区块头大小为80字节，其构成包括： * 4字节：版本号 * 32字节：上一个区块的哈希值 * 32字节：交易列表的Merkle根哈希值 * 4字节：当前时间戳 * 4字节：当前难度值 * 4字节：随机数Nonce值 此80字节长度的区块头，即为比特币Pow算法的输入字符串。 交易列表附加在区块头之后，其中第一笔交易为矿工获得奖励和手续费的特殊交易。 bitcoin-0.15.1源码中区块头和区块定义： ```c++ class CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;//版本号 int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;//上一个区块的哈希值 uint256 hashPrevBlock; &nbsp;&nbsp;&nbsp;&nbsp;//交易列表的Merkle根哈希值 uint256 hashMerkleRoot; &nbsp;&nbsp;&nbsp;&nbsp;//当前时间戳 uint32_t nTime; &nbsp;&nbsp;&nbsp;&nbsp;//当前挖矿难度，nBits越小难度越大 uint32_t nBits; &nbsp;&nbsp;&nbsp;&nbsp;//随机数Nonce值 uint32_t nNonce; &nbsp;&nbsp;&nbsp;&nbsp;//其它代码略 }; class CBlock : public CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;//交易列表 std::vector&lt;CTransactionRef&gt; vtx; &nbsp;&nbsp;&nbsp;&nbsp;//其它代码略 }; //代码位置src/primitives/block.h ``` ### 比特币Pow算法原理 Pow的过程，即为不断调整Nonce值，对区块头做双重SHA256哈希运算，使得结果满足给定数量前导0的哈希值的过程。 其中前导0的个数，取决于挖矿难度，前导0的个数越多，挖矿难度越大。 具体如下： * 1、生成铸币交易，并与其它所有准备打包进区块的交易组成交易列表，生成Merkle根哈希值。 * 2、将Merkle根哈希值，与区块头其它字段组成区块头，80字节长度的区块头作为Pow算法的输入。 * 3、不断变更区块头中的随机数Nonce，对变更后的区块头做双重SHA256哈希运算，与当前难度的目标值做比对， 如果小于目标难度，即Pow完成。 Pow完成的区块向全网广播，其他节点将验证其是否符合规则，如果验证有效，其他节点将接收此区块，并附加在已有区块链之后。 之后将进入下一轮挖矿。 bitcoin-0.15.1源码中Pow算法实现： ```c++ UniValue generateBlocks(std::shared_ptr&lt;CReserveScript&gt; coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript) { static const int nInnerLoopCount = 0x10000; int nHeightEnd = 0; int nHeight = 0; { // Don&#39;t keep cs_main locked LOCK(cs_main); nHeight = chainActive.Height(); nHeightEnd = nHeight+nGenerate; } unsigned int nExtraNonce = 0; UniValue blockHashes(UniValue::VARR); while (nHeight &lt; nHeightEnd) { std::unique_ptr&lt;CBlockTemplate&gt; pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript-&gt;reserveScript)); if (!pblocktemplate.get()) throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;Couldn&#39;t create new block&quot;); CBlock *pblock = &amp;pblocktemplate-&gt;block; { LOCK(cs_main); IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce); } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//不断变更区块头中的随机数Nonce &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//对变更后的区块头做双重SHA256哈希运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//与当前难度的目标值做比对，如果小于目标难度，即Pow完成 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//uint64_t nMaxTries = 1000000;即重试100万次 while (nMaxTries &gt; 0 &amp;&amp; pblock-&gt;nNonce &lt; nInnerLoopCount &amp;&amp; !CheckProofOfWork(pblock-&gt;GetHash(), pblock-&gt;nBits, Params().GetConsensus())) { ++pblock-&gt;nNonce; --nMaxTries; } if (nMaxTries == 0) { break; } if (pblock-&gt;nNonce == nInnerLoopCount) { continue; } std::shared_ptr&lt;const CBlock&gt; shared_pblock = std::make_shared&lt;const CBlock&gt;(*pblock); if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr)) throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;ProcessNewBlock, block not accepted&quot;); ++nHeight; blockHashes.push_back(pblock-&gt;GetHash().GetHex()); //mark script as important because it was used at least for one coinbase output if the script came from the wallet if (keepScript) { coinbaseScript-&gt;KeepScript(); } } return blockHashes; } //代码位置src/rpc/mining.cpp ``` 另附bitcoin-0.15.1源码中生成铸币交易和创建新块： ```c++ std::unique_ptr&lt;CBlockTemplate&gt; BlockAssembler::CreateNewBlock(const CScript&amp; scriptPubKeyIn, bool fMineWitnessTx) { int64_t nTimeStart = GetTimeMicros(); resetBlock(); pblocktemplate.reset(new CBlockTemplate()); if(!pblocktemplate.get()) return nullptr; pblock = &amp;pblocktemplate-&gt;block; // pointer for convenience pblock-&gt;vtx.emplace_back(); pblocktemplate-&gt;vTxFees.push_back(-1); // updated at end pblocktemplate-&gt;vTxSigOpsCost.push_back(-1); // updated at end LOCK2(cs_main, mempool.cs); CBlockIndex* pindexPrev = chainActive.Tip(); nHeight = pindexPrev-&gt;nHeight + 1; &nbsp;&nbsp;&nbsp;&nbsp; //版本号 pblock-&gt;nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus()); if (chainparams.MineBlocksOnDemand()) pblock-&gt;nVersion = gArgs.GetArg(&quot;-blockversion&quot;, pblock-&gt;nVersion); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//当前时间戳 pblock-&gt;nTime = GetAdjustedTime(); const int64_t nMedianTimePast = pindexPrev-&gt;GetMedianTimePast(); nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS &amp; LOCKTIME_MEDIAN_TIME_PAST) ? nMedianTimePast : pblock-&gt;GetBlockTime(); fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus()) &amp;&amp; fMineWitnessTx; int nPackagesSelected = 0; int nDescendantsUpdated = 0; addPackageTxs(nPackagesSelected, nDescendantsUpdated); int64_t nTime1 = GetTimeMicros(); nLastBlockTx = nBlockTx; nLastBlockWeight = nBlockWeight; //创建铸币交易 CMutableTransaction coinbaseTx; coinbaseTx.vin.resize(1); coinbaseTx.vin[0].prevout.SetNull(); coinbaseTx.vout.resize(1); &nbsp;&nbsp;&nbsp;&nbsp;//挖矿奖励和手续费 coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn; coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus()); coinbaseTx.vin[0].scriptSig = CScript() &lt;&lt; nHeight &lt;&lt; OP_0; &nbsp;&nbsp;&nbsp;&nbsp;//第一笔交易即为矿工获得奖励和手续费的特殊交易 pblock-&gt;vtx[0] = MakeTransactionRef(std::move(coinbaseTx)); pblocktemplate-&gt;vchCoinbaseCommitment = GenerateCoinbaseCommitment(*pblock, pindexPrev, chainparams.GetConsensus()); pblocktemplate-&gt;vTxFees[0] = -nFees; LogPrintf(&quot;CreateNewBlock(): block weight: %u txs: %u fees: %ld sigops %d\n&quot;, GetBlockWeight(*pblock), nBlockTx, nFees, nBlockSigOpsCost); //上一个区块的哈希值 pblock-&gt;hashPrevBlock = pindexPrev-&gt;GetBlockHash(); UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev); &nbsp;&nbsp;&nbsp;&nbsp;//当前挖矿难度 pblock-&gt;nBits = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus()); &nbsp;&nbsp;&nbsp;&nbsp;//随机数Nonce值 pblock-&gt;nNonce = 0; pblocktemplate-&gt;vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock-&gt;vtx[0]); CValidationState state; if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) { throw std::runtime_error(strprintf(&quot;%s: TestBlockValidity failed: %s&quot;, __func__, FormatStateMessage(state))); } int64_t nTime2 = GetTimeMicros(); LogPrint(BCLog::BENCH, &quot;CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\n&quot;, 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart)); return std::move(pblocktemplate); } //代码位置src/miner.cpp ``` ### 比特币挖矿难度计算 每创建2016个块后将计算新的难度，此后的2016个块使用新的难度。计算步骤如下： * 1、找到前2016个块的第一个块，计算生成这2016个块花费的时间。 即最后一个块的时间与第一个块的时间差。时间差不小于3.5天，不大于56天。 * 2、计算前2016个块的难度总和，即单个块的难度*总时间。 * 3、计算新的难度，即2016个块的难度总和/14天的秒数，得到每秒的难度值。 * 4、要求新的难度，难度不低于参数定义的最小难度。 bitcoin-0.15.1源码中计算挖矿难度代码如下： ```c++ //nFirstBlockTime即前2016个块的第一个块的时间戳 unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params) { if (params.fPowNoRetargeting) return pindexLast-&gt;nBits; //计算生成这2016个块花费的时间 int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime; &nbsp;&nbsp;&nbsp;&nbsp;//不小于3.5天 if (nActualTimespan &lt; params.nPowTargetTimespan/4) nActualTimespan = params.nPowTargetTimespan/4; &nbsp;&nbsp;&nbsp;&nbsp;//不大于56天 if (nActualTimespan &gt; params.nPowTargetTimespan*4) nActualTimespan = params.nPowTargetTimespan*4; // Retarget const arith_uint256 bnPowLimit = UintToArith256(params.powLimit); arith_uint256 bnNew; bnNew.SetCompact(pindexLast-&gt;nBits); &nbsp;&nbsp;&nbsp;&nbsp;//计算前2016个块的难度总和 &nbsp;&nbsp;&nbsp;&nbsp;//即单个块的难度*总时间 bnNew *= nActualTimespan; &nbsp;&nbsp;&nbsp;&nbsp;//计算新的难度 &nbsp;&nbsp;&nbsp;&nbsp;//即2016个块的难度总和/14天的秒数 bnNew /= params.nPowTargetTimespan; &nbsp;&nbsp;&nbsp;&nbsp; //bnNew越小，难度越大 &nbsp;&nbsp;&nbsp;&nbsp; //bnNew越大，难度越小 &nbsp;&nbsp;&nbsp;&nbsp; //要求新的难度，难度不低于参数定义的最小难度 if (bnNew &gt; bnPowLimit) bnNew = bnPowLimit; return bnNew.GetCompact(); } //代码位置src/pow.cpp ``` ### 以太坊区块 以太坊区块由Header和Body两部分组成。 其中Header部分成员如下： * ParentHash，父区块哈希 * UncleHash，叔区块哈希，具体为Body中Uncles数组的RLP哈希值。RLP哈希，即某类型对象RLP编码后做SHA3哈希运算。 * Coinbase，矿工地址。 * Root，StateDB中state Trie根节点RLP哈希值。 * TxHash，Block中tx Trie根节点RLP哈希值。 * ReceiptHash，Block中Receipt Trie根节点的RLP哈希值。 * Difficulty，区块难度，即当前挖矿难度。 * Number，区块序号，即父区块Number+1。 * GasLimit，区块内所有Gas消耗的理论上限，创建时指定，由父区块GasUsed和GasLimit计算得出。 * GasUsed，区块内所有Transaction执行时消耗的Gas总和。 * Time，当前时间戳。 * Nonce，随机数Nonce值。 有关叔区块： 叔区块，即孤立的块。以太坊成块速度较快，导致产生孤块。 以太坊会给发现孤块的矿工以回报，激励矿工在新块中引用孤块，引用孤块使主链更重。 在以太坊中，主链是指最重的链。 有关state Trie、tx Trie和Receipt Trie： * state Trie，所有账户对象可以逐个插入一个Merkle-PatricaTrie(MPT)结构中，形成state Trie。 * tx Trie：Block中Transactions中所有tx对象，逐个插入MPT结构中，形成tx Trie。 * Receipt Trie：Block中所有Transaction执行后生成Receipt数组，所有Receipt逐个插入MPT结构中，形成Receipt Trie。 Body成员如下： * Transactions，交易列表。 * Uncles，引用的叔区块列表。 go-ethereum-1.7.3源码中区块头和区块定义： ```go type Header struct { &nbsp;&nbsp;&nbsp;&nbsp; //父区块哈希 &nbsp;&nbsp;&nbsp;&nbsp;ParentHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //叔区块哈希 &nbsp;&nbsp;&nbsp;&nbsp;UncleHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //矿工地址 &nbsp;&nbsp;&nbsp;&nbsp;Coinbase common.Address &nbsp;&nbsp;&nbsp;&nbsp; //StateDB中state Trie根节点RLP哈希值 &nbsp;&nbsp;&nbsp;&nbsp;Root common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //Block中tx Trie根节点RLP哈希值 &nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //Block中Receipt Trie根节点的RLP哈希值 &nbsp;&nbsp;&nbsp;&nbsp;ReceiptHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom &nbsp;&nbsp;&nbsp;&nbsp; //区块难度 &nbsp;&nbsp;&nbsp;&nbsp;Difficulty *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //区块序号 &nbsp;&nbsp;&nbsp;&nbsp;Number *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //区块内所有Gas消耗的理论上限 &nbsp;&nbsp;&nbsp;&nbsp;GasLimit *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //区块内所有Transaction执行时消耗的Gas总和 &nbsp;&nbsp;&nbsp;&nbsp;GasUsed *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //当前时间戳 &nbsp;&nbsp;&nbsp;&nbsp;Time *big.Int &nbsp;&nbsp;&nbsp;&nbsp;Extra [] byte &nbsp;&nbsp;&nbsp;&nbsp;MixDigest common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //随机数Nonce值 &nbsp;&nbsp;&nbsp;&nbsp;Nonce BlockNonce } type Body struct { &nbsp;&nbsp;&nbsp;&nbsp; //交易列表 &nbsp;&nbsp;&nbsp;&nbsp;Transactions []*Transaction &nbsp;&nbsp;&nbsp;&nbsp; //引用的叔区块列表 &nbsp;&nbsp;&nbsp;&nbsp;Uncles []*Header } //代码位置core/types/block.go ``` ### 以太坊Pow算法原理 以太坊Pow算法可以表示为如下公式： RAND(h, n) &lt;= M / d 其中RAND()表示一个概念函数，代表一系列的复杂运算。 其中h和n为输入，即区块Header的哈希、以及Header中的Nonce。 M表示一个极大的数，此处使用2^256-1。 d，为区块难度，即Header中的Difficulty。 因此在h和n确定的情况下，d越大，挖矿难度越大，即为Difficulty本义。 即不断变更Nonce，使RAND(h, n)满足RAND(h, n) &lt;= M / d，即完成Pow。 go-ethereum-1.7.3源码中Pow算法实现： ```go func (ethash *Ethash) mine(block *types.Block, id int, seed uint64, abort chan struct{}, found chan *types.Block) { &nbsp;&nbsp;&nbsp;&nbsp; // Extract some data from the header &nbsp;&nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header = block.Header() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash = header.HashNoNonce().Bytes() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //target，即M / d，即(2^256-1)/Difficulty &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target = new(big.Int).Div(maxUint256, header.Difficulty) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number = header.Number.Uint64() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataset = ethash.dataset(number) &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp; // Start generating random nonces until we abort or find a good one &nbsp;&nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts = int64( 0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonce = seed &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp;logger := log.New( &quot;miner&quot;, id) &nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Started ethash search for new nonces&quot;, &quot;seed&quot;, seed) &nbsp;&nbsp;&nbsp;&nbsp; for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Mining terminated, update stats and abort &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Ethash nonce search aborted&quot;, &quot;attempts&quot;, nonce-seed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We don&#39;t have to update hash rate on every nonce, so update after after 2^X nonces &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attempts % ( 1 &lt;&lt; 15)) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts = 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //hashimotoFull即RAND(h, n)所代表的一系列的复杂运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;digest, result := hashimotoFull(dataset, hash, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //result满足RAND(h, n) &lt;= M / d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Correct nonce found, create a new header with it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header = types.CopyHeader(header) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.Nonce = types.EncodeNonce(nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.MixDigest = common.BytesToHash(digest) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Seal and return a block (if still needed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case found &lt;- block.WithSeal(header): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Ethash nonce found and reported&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Ethash nonce found but discarded&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //不断变更Nonce &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonce++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } //代码位置consensus/ethash/sealer.go ``` ### 以太坊挖矿难度计算 以太坊每次挖矿均需计算当前区块难度。 按版本不同有三种计算难度的规则，分别为：calcDifficultyByzantium（Byzantium版）、calcDifficultyHomestead（Homestead版）、calcDifficultyFrontier（Frontier版）。 此处以calcDifficultyHomestead为例。 计算难度时输入有： * parent_timestamp：父区块时间戳 * parent_diff：父区块难度 * block_timestamp：当前区块时间戳 * block_number：当前区块的序号 当前区块难度计算公式，即： ``` block_diff = parent_diff + (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99) + 2^((block_number // 100000) - 2) ``` 其中//为整数除法运算符，a//b，即先计算a/b，然后取不大于a/b的最大整数。 调整难度的目的，即为使挖矿时间保持在10-19s期间内，如果低于10s增大挖矿难度，如果大于19s将减小难度。 另外，计算出的当前区块难度不应低于以太坊创世区块难度，即131072。 go-ethereum-1.7.3源码中计算挖矿难度代码如下： ```go func calcDifficultyHomestead(time uint64, parent *types.Header) *big.Int { &nbsp;&nbsp;&nbsp;&nbsp; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.mediawiki &nbsp;&nbsp;&nbsp;&nbsp; // algorithm: &nbsp;&nbsp;&nbsp;&nbsp; // diff = (parent_diff + &nbsp;&nbsp;&nbsp;&nbsp; // (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99)) &nbsp;&nbsp;&nbsp;&nbsp; // ) + 2^(periodCount - 2) &nbsp;&nbsp;&nbsp;&nbsp;bigTime := new(big.Int).SetUint64(time) &nbsp;&nbsp;&nbsp;&nbsp;bigParentTime := new(big.Int).Set(parent.Time) &nbsp;&nbsp;&nbsp;&nbsp; // holds intermediate values to make the algo easier to read &amp; audit &nbsp;&nbsp;&nbsp;&nbsp;x := new(big.Int) &nbsp;&nbsp;&nbsp;&nbsp;y := new(big.Int) &nbsp;&nbsp;&nbsp;&nbsp; // 1 - (block_timestamp - parent_timestamp) // 10 &nbsp;&nbsp;&nbsp;&nbsp;x.Sub(bigTime, bigParentTime) &nbsp;&nbsp;&nbsp;&nbsp;x.Div(x, big10) &nbsp;&nbsp;&nbsp;&nbsp;x.Sub(big1, x) &nbsp;&nbsp;&nbsp;&nbsp; // max(1 - (block_timestamp - parent_timestamp) // 10, -99) &nbsp;&nbsp;&nbsp;&nbsp; if x.Cmp(bigMinus99) &lt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Set(bigMinus99) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // (parent_diff + parent_diff // 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99)) &nbsp;&nbsp;&nbsp;&nbsp;y.Div(parent.Difficulty, params.DifficultyBoundDivisor) &nbsp;&nbsp;&nbsp;&nbsp;x.Mul(y, x) &nbsp;&nbsp;&nbsp;&nbsp;x.Add(parent.Difficulty, x) &nbsp;&nbsp;&nbsp;&nbsp; // minimum difficulty can ever be (before exponential factor) &nbsp;&nbsp;&nbsp;&nbsp; if x.Cmp(params.MinimumDifficulty) &lt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Set(params.MinimumDifficulty) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // for the exponential factor &nbsp;&nbsp;&nbsp;&nbsp;periodCount := new(big.Int).Add(parent.Number, big1) &nbsp;&nbsp;&nbsp;&nbsp;periodCount.Div(periodCount, expDiffPeriod) &nbsp;&nbsp;&nbsp;&nbsp; // the exponential factor, commonly referred to as &quot;the bomb&quot; &nbsp;&nbsp;&nbsp;&nbsp; // diff = diff + 2^(periodCount - 2) &nbsp;&nbsp;&nbsp;&nbsp; if periodCount.Cmp(big1) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.Sub(periodCount, big2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.Exp(big2, y, nil) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Add(x, y) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; return x } //代码位置consensus/ethash/consensus.go ``` ### 后记 Pow算法概念简单，即工作端提交难以计算但易于验证的计算结果，其他节点通过验证这个结果来确信工作端完成了相当的工作量。 但其缺陷也很明显：1、随着节点将CPU挖矿升级为GPU、甚至矿机挖矿，节点数和算力已渐渐失衡； 2、比特币等网络每秒需完成数百万亿次哈希计算，资源大量浪费。 为此，业内提出了Pow的替代者如PoS权益证明算法，即要求用户拥有一定数量的货币，才有权参与确定下一个合法区块。 另外，相对拥有51%算力，购买超过半数以上的货币难度更大，也使得恶意攻击更加困难。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多" />
<meta property="og:description" content="# PoW挖矿算法原理及其在比特币、以太坊中的实现 PoW，全称Proof of Work，即工作量证明，又称挖矿。 大部分公有链或虚拟货币，如比特币、以太坊，均基于PoW算法，来实现其共识机制。 即根据挖矿贡献的有效工作，来决定货币的分配。 ### 比特币区块 比特币区块由区块头和该区块所包含的交易列表组成。 区块头大小为80字节，其构成包括： * 4字节：版本号 * 32字节：上一个区块的哈希值 * 32字节：交易列表的Merkle根哈希值 * 4字节：当前时间戳 * 4字节：当前难度值 * 4字节：随机数Nonce值 此80字节长度的区块头，即为比特币Pow算法的输入字符串。 交易列表附加在区块头之后，其中第一笔交易为矿工获得奖励和手续费的特殊交易。 bitcoin-0.15.1源码中区块头和区块定义： ```c++ class CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;//版本号 int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;//上一个区块的哈希值 uint256 hashPrevBlock; &nbsp;&nbsp;&nbsp;&nbsp;//交易列表的Merkle根哈希值 uint256 hashMerkleRoot; &nbsp;&nbsp;&nbsp;&nbsp;//当前时间戳 uint32_t nTime; &nbsp;&nbsp;&nbsp;&nbsp;//当前挖矿难度，nBits越小难度越大 uint32_t nBits; &nbsp;&nbsp;&nbsp;&nbsp;//随机数Nonce值 uint32_t nNonce; &nbsp;&nbsp;&nbsp;&nbsp;//其它代码略 }; class CBlock : public CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;//交易列表 std::vector&lt;CTransactionRef&gt; vtx; &nbsp;&nbsp;&nbsp;&nbsp;//其它代码略 }; //代码位置src/primitives/block.h ``` ### 比特币Pow算法原理 Pow的过程，即为不断调整Nonce值，对区块头做双重SHA256哈希运算，使得结果满足给定数量前导0的哈希值的过程。 其中前导0的个数，取决于挖矿难度，前导0的个数越多，挖矿难度越大。 具体如下： * 1、生成铸币交易，并与其它所有准备打包进区块的交易组成交易列表，生成Merkle根哈希值。 * 2、将Merkle根哈希值，与区块头其它字段组成区块头，80字节长度的区块头作为Pow算法的输入。 * 3、不断变更区块头中的随机数Nonce，对变更后的区块头做双重SHA256哈希运算，与当前难度的目标值做比对， 如果小于目标难度，即Pow完成。 Pow完成的区块向全网广播，其他节点将验证其是否符合规则，如果验证有效，其他节点将接收此区块，并附加在已有区块链之后。 之后将进入下一轮挖矿。 bitcoin-0.15.1源码中Pow算法实现： ```c++ UniValue generateBlocks(std::shared_ptr&lt;CReserveScript&gt; coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript) { static const int nInnerLoopCount = 0x10000; int nHeightEnd = 0; int nHeight = 0; { // Don&#39;t keep cs_main locked LOCK(cs_main); nHeight = chainActive.Height(); nHeightEnd = nHeight+nGenerate; } unsigned int nExtraNonce = 0; UniValue blockHashes(UniValue::VARR); while (nHeight &lt; nHeightEnd) { std::unique_ptr&lt;CBlockTemplate&gt; pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript-&gt;reserveScript)); if (!pblocktemplate.get()) throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;Couldn&#39;t create new block&quot;); CBlock *pblock = &amp;pblocktemplate-&gt;block; { LOCK(cs_main); IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce); } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//不断变更区块头中的随机数Nonce &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//对变更后的区块头做双重SHA256哈希运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//与当前难度的目标值做比对，如果小于目标难度，即Pow完成 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//uint64_t nMaxTries = 1000000;即重试100万次 while (nMaxTries &gt; 0 &amp;&amp; pblock-&gt;nNonce &lt; nInnerLoopCount &amp;&amp; !CheckProofOfWork(pblock-&gt;GetHash(), pblock-&gt;nBits, Params().GetConsensus())) { ++pblock-&gt;nNonce; --nMaxTries; } if (nMaxTries == 0) { break; } if (pblock-&gt;nNonce == nInnerLoopCount) { continue; } std::shared_ptr&lt;const CBlock&gt; shared_pblock = std::make_shared&lt;const CBlock&gt;(*pblock); if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr)) throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;ProcessNewBlock, block not accepted&quot;); ++nHeight; blockHashes.push_back(pblock-&gt;GetHash().GetHex()); //mark script as important because it was used at least for one coinbase output if the script came from the wallet if (keepScript) { coinbaseScript-&gt;KeepScript(); } } return blockHashes; } //代码位置src/rpc/mining.cpp ``` 另附bitcoin-0.15.1源码中生成铸币交易和创建新块： ```c++ std::unique_ptr&lt;CBlockTemplate&gt; BlockAssembler::CreateNewBlock(const CScript&amp; scriptPubKeyIn, bool fMineWitnessTx) { int64_t nTimeStart = GetTimeMicros(); resetBlock(); pblocktemplate.reset(new CBlockTemplate()); if(!pblocktemplate.get()) return nullptr; pblock = &amp;pblocktemplate-&gt;block; // pointer for convenience pblock-&gt;vtx.emplace_back(); pblocktemplate-&gt;vTxFees.push_back(-1); // updated at end pblocktemplate-&gt;vTxSigOpsCost.push_back(-1); // updated at end LOCK2(cs_main, mempool.cs); CBlockIndex* pindexPrev = chainActive.Tip(); nHeight = pindexPrev-&gt;nHeight + 1; &nbsp;&nbsp;&nbsp;&nbsp; //版本号 pblock-&gt;nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus()); if (chainparams.MineBlocksOnDemand()) pblock-&gt;nVersion = gArgs.GetArg(&quot;-blockversion&quot;, pblock-&gt;nVersion); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//当前时间戳 pblock-&gt;nTime = GetAdjustedTime(); const int64_t nMedianTimePast = pindexPrev-&gt;GetMedianTimePast(); nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS &amp; LOCKTIME_MEDIAN_TIME_PAST) ? nMedianTimePast : pblock-&gt;GetBlockTime(); fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus()) &amp;&amp; fMineWitnessTx; int nPackagesSelected = 0; int nDescendantsUpdated = 0; addPackageTxs(nPackagesSelected, nDescendantsUpdated); int64_t nTime1 = GetTimeMicros(); nLastBlockTx = nBlockTx; nLastBlockWeight = nBlockWeight; //创建铸币交易 CMutableTransaction coinbaseTx; coinbaseTx.vin.resize(1); coinbaseTx.vin[0].prevout.SetNull(); coinbaseTx.vout.resize(1); &nbsp;&nbsp;&nbsp;&nbsp;//挖矿奖励和手续费 coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn; coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus()); coinbaseTx.vin[0].scriptSig = CScript() &lt;&lt; nHeight &lt;&lt; OP_0; &nbsp;&nbsp;&nbsp;&nbsp;//第一笔交易即为矿工获得奖励和手续费的特殊交易 pblock-&gt;vtx[0] = MakeTransactionRef(std::move(coinbaseTx)); pblocktemplate-&gt;vchCoinbaseCommitment = GenerateCoinbaseCommitment(*pblock, pindexPrev, chainparams.GetConsensus()); pblocktemplate-&gt;vTxFees[0] = -nFees; LogPrintf(&quot;CreateNewBlock(): block weight: %u txs: %u fees: %ld sigops %d\n&quot;, GetBlockWeight(*pblock), nBlockTx, nFees, nBlockSigOpsCost); //上一个区块的哈希值 pblock-&gt;hashPrevBlock = pindexPrev-&gt;GetBlockHash(); UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev); &nbsp;&nbsp;&nbsp;&nbsp;//当前挖矿难度 pblock-&gt;nBits = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus()); &nbsp;&nbsp;&nbsp;&nbsp;//随机数Nonce值 pblock-&gt;nNonce = 0; pblocktemplate-&gt;vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock-&gt;vtx[0]); CValidationState state; if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) { throw std::runtime_error(strprintf(&quot;%s: TestBlockValidity failed: %s&quot;, __func__, FormatStateMessage(state))); } int64_t nTime2 = GetTimeMicros(); LogPrint(BCLog::BENCH, &quot;CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\n&quot;, 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart)); return std::move(pblocktemplate); } //代码位置src/miner.cpp ``` ### 比特币挖矿难度计算 每创建2016个块后将计算新的难度，此后的2016个块使用新的难度。计算步骤如下： * 1、找到前2016个块的第一个块，计算生成这2016个块花费的时间。 即最后一个块的时间与第一个块的时间差。时间差不小于3.5天，不大于56天。 * 2、计算前2016个块的难度总和，即单个块的难度*总时间。 * 3、计算新的难度，即2016个块的难度总和/14天的秒数，得到每秒的难度值。 * 4、要求新的难度，难度不低于参数定义的最小难度。 bitcoin-0.15.1源码中计算挖矿难度代码如下： ```c++ //nFirstBlockTime即前2016个块的第一个块的时间戳 unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params) { if (params.fPowNoRetargeting) return pindexLast-&gt;nBits; //计算生成这2016个块花费的时间 int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime; &nbsp;&nbsp;&nbsp;&nbsp;//不小于3.5天 if (nActualTimespan &lt; params.nPowTargetTimespan/4) nActualTimespan = params.nPowTargetTimespan/4; &nbsp;&nbsp;&nbsp;&nbsp;//不大于56天 if (nActualTimespan &gt; params.nPowTargetTimespan*4) nActualTimespan = params.nPowTargetTimespan*4; // Retarget const arith_uint256 bnPowLimit = UintToArith256(params.powLimit); arith_uint256 bnNew; bnNew.SetCompact(pindexLast-&gt;nBits); &nbsp;&nbsp;&nbsp;&nbsp;//计算前2016个块的难度总和 &nbsp;&nbsp;&nbsp;&nbsp;//即单个块的难度*总时间 bnNew *= nActualTimespan; &nbsp;&nbsp;&nbsp;&nbsp;//计算新的难度 &nbsp;&nbsp;&nbsp;&nbsp;//即2016个块的难度总和/14天的秒数 bnNew /= params.nPowTargetTimespan; &nbsp;&nbsp;&nbsp;&nbsp; //bnNew越小，难度越大 &nbsp;&nbsp;&nbsp;&nbsp; //bnNew越大，难度越小 &nbsp;&nbsp;&nbsp;&nbsp; //要求新的难度，难度不低于参数定义的最小难度 if (bnNew &gt; bnPowLimit) bnNew = bnPowLimit; return bnNew.GetCompact(); } //代码位置src/pow.cpp ``` ### 以太坊区块 以太坊区块由Header和Body两部分组成。 其中Header部分成员如下： * ParentHash，父区块哈希 * UncleHash，叔区块哈希，具体为Body中Uncles数组的RLP哈希值。RLP哈希，即某类型对象RLP编码后做SHA3哈希运算。 * Coinbase，矿工地址。 * Root，StateDB中state Trie根节点RLP哈希值。 * TxHash，Block中tx Trie根节点RLP哈希值。 * ReceiptHash，Block中Receipt Trie根节点的RLP哈希值。 * Difficulty，区块难度，即当前挖矿难度。 * Number，区块序号，即父区块Number+1。 * GasLimit，区块内所有Gas消耗的理论上限，创建时指定，由父区块GasUsed和GasLimit计算得出。 * GasUsed，区块内所有Transaction执行时消耗的Gas总和。 * Time，当前时间戳。 * Nonce，随机数Nonce值。 有关叔区块： 叔区块，即孤立的块。以太坊成块速度较快，导致产生孤块。 以太坊会给发现孤块的矿工以回报，激励矿工在新块中引用孤块，引用孤块使主链更重。 在以太坊中，主链是指最重的链。 有关state Trie、tx Trie和Receipt Trie： * state Trie，所有账户对象可以逐个插入一个Merkle-PatricaTrie(MPT)结构中，形成state Trie。 * tx Trie：Block中Transactions中所有tx对象，逐个插入MPT结构中，形成tx Trie。 * Receipt Trie：Block中所有Transaction执行后生成Receipt数组，所有Receipt逐个插入MPT结构中，形成Receipt Trie。 Body成员如下： * Transactions，交易列表。 * Uncles，引用的叔区块列表。 go-ethereum-1.7.3源码中区块头和区块定义： ```go type Header struct { &nbsp;&nbsp;&nbsp;&nbsp; //父区块哈希 &nbsp;&nbsp;&nbsp;&nbsp;ParentHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //叔区块哈希 &nbsp;&nbsp;&nbsp;&nbsp;UncleHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //矿工地址 &nbsp;&nbsp;&nbsp;&nbsp;Coinbase common.Address &nbsp;&nbsp;&nbsp;&nbsp; //StateDB中state Trie根节点RLP哈希值 &nbsp;&nbsp;&nbsp;&nbsp;Root common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //Block中tx Trie根节点RLP哈希值 &nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //Block中Receipt Trie根节点的RLP哈希值 &nbsp;&nbsp;&nbsp;&nbsp;ReceiptHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom &nbsp;&nbsp;&nbsp;&nbsp; //区块难度 &nbsp;&nbsp;&nbsp;&nbsp;Difficulty *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //区块序号 &nbsp;&nbsp;&nbsp;&nbsp;Number *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //区块内所有Gas消耗的理论上限 &nbsp;&nbsp;&nbsp;&nbsp;GasLimit *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //区块内所有Transaction执行时消耗的Gas总和 &nbsp;&nbsp;&nbsp;&nbsp;GasUsed *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //当前时间戳 &nbsp;&nbsp;&nbsp;&nbsp;Time *big.Int &nbsp;&nbsp;&nbsp;&nbsp;Extra [] byte &nbsp;&nbsp;&nbsp;&nbsp;MixDigest common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //随机数Nonce值 &nbsp;&nbsp;&nbsp;&nbsp;Nonce BlockNonce } type Body struct { &nbsp;&nbsp;&nbsp;&nbsp; //交易列表 &nbsp;&nbsp;&nbsp;&nbsp;Transactions []*Transaction &nbsp;&nbsp;&nbsp;&nbsp; //引用的叔区块列表 &nbsp;&nbsp;&nbsp;&nbsp;Uncles []*Header } //代码位置core/types/block.go ``` ### 以太坊Pow算法原理 以太坊Pow算法可以表示为如下公式： RAND(h, n) &lt;= M / d 其中RAND()表示一个概念函数，代表一系列的复杂运算。 其中h和n为输入，即区块Header的哈希、以及Header中的Nonce。 M表示一个极大的数，此处使用2^256-1。 d，为区块难度，即Header中的Difficulty。 因此在h和n确定的情况下，d越大，挖矿难度越大，即为Difficulty本义。 即不断变更Nonce，使RAND(h, n)满足RAND(h, n) &lt;= M / d，即完成Pow。 go-ethereum-1.7.3源码中Pow算法实现： ```go func (ethash *Ethash) mine(block *types.Block, id int, seed uint64, abort chan struct{}, found chan *types.Block) { &nbsp;&nbsp;&nbsp;&nbsp; // Extract some data from the header &nbsp;&nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header = block.Header() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash = header.HashNoNonce().Bytes() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //target，即M / d，即(2^256-1)/Difficulty &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target = new(big.Int).Div(maxUint256, header.Difficulty) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number = header.Number.Uint64() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataset = ethash.dataset(number) &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp; // Start generating random nonces until we abort or find a good one &nbsp;&nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts = int64( 0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonce = seed &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp;logger := log.New( &quot;miner&quot;, id) &nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Started ethash search for new nonces&quot;, &quot;seed&quot;, seed) &nbsp;&nbsp;&nbsp;&nbsp; for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Mining terminated, update stats and abort &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Ethash nonce search aborted&quot;, &quot;attempts&quot;, nonce-seed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We don&#39;t have to update hash rate on every nonce, so update after after 2^X nonces &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attempts % ( 1 &lt;&lt; 15)) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts = 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //hashimotoFull即RAND(h, n)所代表的一系列的复杂运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;digest, result := hashimotoFull(dataset, hash, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //result满足RAND(h, n) &lt;= M / d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Correct nonce found, create a new header with it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header = types.CopyHeader(header) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.Nonce = types.EncodeNonce(nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.MixDigest = common.BytesToHash(digest) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Seal and return a block (if still needed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case found &lt;- block.WithSeal(header): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Ethash nonce found and reported&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Ethash nonce found but discarded&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //不断变更Nonce &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonce++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } //代码位置consensus/ethash/sealer.go ``` ### 以太坊挖矿难度计算 以太坊每次挖矿均需计算当前区块难度。 按版本不同有三种计算难度的规则，分别为：calcDifficultyByzantium（Byzantium版）、calcDifficultyHomestead（Homestead版）、calcDifficultyFrontier（Frontier版）。 此处以calcDifficultyHomestead为例。 计算难度时输入有： * parent_timestamp：父区块时间戳 * parent_diff：父区块难度 * block_timestamp：当前区块时间戳 * block_number：当前区块的序号 当前区块难度计算公式，即： ``` block_diff = parent_diff + (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99) + 2^((block_number // 100000) - 2) ``` 其中//为整数除法运算符，a//b，即先计算a/b，然后取不大于a/b的最大整数。 调整难度的目的，即为使挖矿时间保持在10-19s期间内，如果低于10s增大挖矿难度，如果大于19s将减小难度。 另外，计算出的当前区块难度不应低于以太坊创世区块难度，即131072。 go-ethereum-1.7.3源码中计算挖矿难度代码如下： ```go func calcDifficultyHomestead(time uint64, parent *types.Header) *big.Int { &nbsp;&nbsp;&nbsp;&nbsp; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.mediawiki &nbsp;&nbsp;&nbsp;&nbsp; // algorithm: &nbsp;&nbsp;&nbsp;&nbsp; // diff = (parent_diff + &nbsp;&nbsp;&nbsp;&nbsp; // (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99)) &nbsp;&nbsp;&nbsp;&nbsp; // ) + 2^(periodCount - 2) &nbsp;&nbsp;&nbsp;&nbsp;bigTime := new(big.Int).SetUint64(time) &nbsp;&nbsp;&nbsp;&nbsp;bigParentTime := new(big.Int).Set(parent.Time) &nbsp;&nbsp;&nbsp;&nbsp; // holds intermediate values to make the algo easier to read &amp; audit &nbsp;&nbsp;&nbsp;&nbsp;x := new(big.Int) &nbsp;&nbsp;&nbsp;&nbsp;y := new(big.Int) &nbsp;&nbsp;&nbsp;&nbsp; // 1 - (block_timestamp - parent_timestamp) // 10 &nbsp;&nbsp;&nbsp;&nbsp;x.Sub(bigTime, bigParentTime) &nbsp;&nbsp;&nbsp;&nbsp;x.Div(x, big10) &nbsp;&nbsp;&nbsp;&nbsp;x.Sub(big1, x) &nbsp;&nbsp;&nbsp;&nbsp; // max(1 - (block_timestamp - parent_timestamp) // 10, -99) &nbsp;&nbsp;&nbsp;&nbsp; if x.Cmp(bigMinus99) &lt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Set(bigMinus99) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // (parent_diff + parent_diff // 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99)) &nbsp;&nbsp;&nbsp;&nbsp;y.Div(parent.Difficulty, params.DifficultyBoundDivisor) &nbsp;&nbsp;&nbsp;&nbsp;x.Mul(y, x) &nbsp;&nbsp;&nbsp;&nbsp;x.Add(parent.Difficulty, x) &nbsp;&nbsp;&nbsp;&nbsp; // minimum difficulty can ever be (before exponential factor) &nbsp;&nbsp;&nbsp;&nbsp; if x.Cmp(params.MinimumDifficulty) &lt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Set(params.MinimumDifficulty) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // for the exponential factor &nbsp;&nbsp;&nbsp;&nbsp;periodCount := new(big.Int).Add(parent.Number, big1) &nbsp;&nbsp;&nbsp;&nbsp;periodCount.Div(periodCount, expDiffPeriod) &nbsp;&nbsp;&nbsp;&nbsp; // the exponential factor, commonly referred to as &quot;the bomb&quot; &nbsp;&nbsp;&nbsp;&nbsp; // diff = diff + 2^(periodCount - 2) &nbsp;&nbsp;&nbsp;&nbsp; if periodCount.Cmp(big1) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.Sub(periodCount, big2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.Exp(big2, y, nil) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Add(x, y) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; return x } //代码位置consensus/ethash/consensus.go ``` ### 后记 Pow算法概念简单，即工作端提交难以计算但易于验证的计算结果，其他节点通过验证这个结果来确信工作端完成了相当的工作量。 但其缺陷也很明显：1、随着节点将CPU挖矿升级为GPU、甚至矿机挖矿，节点数和算力已渐渐失衡； 2、比特币等网络每秒需完成数百万亿次哈希计算，资源大量浪费。 为此，业内提出了Pow的替代者如PoS权益证明算法，即要求用户拥有一定数量的货币，才有权参与确定下一个合法区块。 另外，相对拥有51%算力，购买超过半数以上的货币难度更大，也使得恶意攻击更加困难。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/05/21/f6d5d5f9340a8a111c4204d8ad33976f.html" />
<meta property="og:url" content="https://mlh.app/2018/05/21/f6d5d5f9340a8a111c4204d8ad33976f.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"# PoW挖矿算法原理及其在比特币、以太坊中的实现 PoW，全称Proof of Work，即工作量证明，又称挖矿。 大部分公有链或虚拟货币，如比特币、以太坊，均基于PoW算法，来实现其共识机制。 即根据挖矿贡献的有效工作，来决定货币的分配。 ### 比特币区块 比特币区块由区块头和该区块所包含的交易列表组成。 区块头大小为80字节，其构成包括： * 4字节：版本号 * 32字节：上一个区块的哈希值 * 32字节：交易列表的Merkle根哈希值 * 4字节：当前时间戳 * 4字节：当前难度值 * 4字节：随机数Nonce值 此80字节长度的区块头，即为比特币Pow算法的输入字符串。 交易列表附加在区块头之后，其中第一笔交易为矿工获得奖励和手续费的特殊交易。 bitcoin-0.15.1源码中区块头和区块定义： ```c++ class CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;//版本号 int32_t nVersion; &nbsp;&nbsp;&nbsp;&nbsp;//上一个区块的哈希值 uint256 hashPrevBlock; &nbsp;&nbsp;&nbsp;&nbsp;//交易列表的Merkle根哈希值 uint256 hashMerkleRoot; &nbsp;&nbsp;&nbsp;&nbsp;//当前时间戳 uint32_t nTime; &nbsp;&nbsp;&nbsp;&nbsp;//当前挖矿难度，nBits越小难度越大 uint32_t nBits; &nbsp;&nbsp;&nbsp;&nbsp;//随机数Nonce值 uint32_t nNonce; &nbsp;&nbsp;&nbsp;&nbsp;//其它代码略 }; class CBlock : public CBlockHeader { public: &nbsp;&nbsp;&nbsp;&nbsp;//交易列表 std::vector&lt;CTransactionRef&gt; vtx; &nbsp;&nbsp;&nbsp;&nbsp;//其它代码略 }; //代码位置src/primitives/block.h ``` ### 比特币Pow算法原理 Pow的过程，即为不断调整Nonce值，对区块头做双重SHA256哈希运算，使得结果满足给定数量前导0的哈希值的过程。 其中前导0的个数，取决于挖矿难度，前导0的个数越多，挖矿难度越大。 具体如下： * 1、生成铸币交易，并与其它所有准备打包进区块的交易组成交易列表，生成Merkle根哈希值。 * 2、将Merkle根哈希值，与区块头其它字段组成区块头，80字节长度的区块头作为Pow算法的输入。 * 3、不断变更区块头中的随机数Nonce，对变更后的区块头做双重SHA256哈希运算，与当前难度的目标值做比对， 如果小于目标难度，即Pow完成。 Pow完成的区块向全网广播，其他节点将验证其是否符合规则，如果验证有效，其他节点将接收此区块，并附加在已有区块链之后。 之后将进入下一轮挖矿。 bitcoin-0.15.1源码中Pow算法实现： ```c++ UniValue generateBlocks(std::shared_ptr&lt;CReserveScript&gt; coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript) { static const int nInnerLoopCount = 0x10000; int nHeightEnd = 0; int nHeight = 0; { // Don&#39;t keep cs_main locked LOCK(cs_main); nHeight = chainActive.Height(); nHeightEnd = nHeight+nGenerate; } unsigned int nExtraNonce = 0; UniValue blockHashes(UniValue::VARR); while (nHeight &lt; nHeightEnd) { std::unique_ptr&lt;CBlockTemplate&gt; pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript-&gt;reserveScript)); if (!pblocktemplate.get()) throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;Couldn&#39;t create new block&quot;); CBlock *pblock = &amp;pblocktemplate-&gt;block; { LOCK(cs_main); IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce); } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//不断变更区块头中的随机数Nonce &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//对变更后的区块头做双重SHA256哈希运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//与当前难度的目标值做比对，如果小于目标难度，即Pow完成 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//uint64_t nMaxTries = 1000000;即重试100万次 while (nMaxTries &gt; 0 &amp;&amp; pblock-&gt;nNonce &lt; nInnerLoopCount &amp;&amp; !CheckProofOfWork(pblock-&gt;GetHash(), pblock-&gt;nBits, Params().GetConsensus())) { ++pblock-&gt;nNonce; --nMaxTries; } if (nMaxTries == 0) { break; } if (pblock-&gt;nNonce == nInnerLoopCount) { continue; } std::shared_ptr&lt;const CBlock&gt; shared_pblock = std::make_shared&lt;const CBlock&gt;(*pblock); if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr)) throw JSONRPCError(RPC_INTERNAL_ERROR, &quot;ProcessNewBlock, block not accepted&quot;); ++nHeight; blockHashes.push_back(pblock-&gt;GetHash().GetHex()); //mark script as important because it was used at least for one coinbase output if the script came from the wallet if (keepScript) { coinbaseScript-&gt;KeepScript(); } } return blockHashes; } //代码位置src/rpc/mining.cpp ``` 另附bitcoin-0.15.1源码中生成铸币交易和创建新块： ```c++ std::unique_ptr&lt;CBlockTemplate&gt; BlockAssembler::CreateNewBlock(const CScript&amp; scriptPubKeyIn, bool fMineWitnessTx) { int64_t nTimeStart = GetTimeMicros(); resetBlock(); pblocktemplate.reset(new CBlockTemplate()); if(!pblocktemplate.get()) return nullptr; pblock = &amp;pblocktemplate-&gt;block; // pointer for convenience pblock-&gt;vtx.emplace_back(); pblocktemplate-&gt;vTxFees.push_back(-1); // updated at end pblocktemplate-&gt;vTxSigOpsCost.push_back(-1); // updated at end LOCK2(cs_main, mempool.cs); CBlockIndex* pindexPrev = chainActive.Tip(); nHeight = pindexPrev-&gt;nHeight + 1; &nbsp;&nbsp;&nbsp;&nbsp; //版本号 pblock-&gt;nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus()); if (chainparams.MineBlocksOnDemand()) pblock-&gt;nVersion = gArgs.GetArg(&quot;-blockversion&quot;, pblock-&gt;nVersion); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//当前时间戳 pblock-&gt;nTime = GetAdjustedTime(); const int64_t nMedianTimePast = pindexPrev-&gt;GetMedianTimePast(); nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS &amp; LOCKTIME_MEDIAN_TIME_PAST) ? nMedianTimePast : pblock-&gt;GetBlockTime(); fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus()) &amp;&amp; fMineWitnessTx; int nPackagesSelected = 0; int nDescendantsUpdated = 0; addPackageTxs(nPackagesSelected, nDescendantsUpdated); int64_t nTime1 = GetTimeMicros(); nLastBlockTx = nBlockTx; nLastBlockWeight = nBlockWeight; //创建铸币交易 CMutableTransaction coinbaseTx; coinbaseTx.vin.resize(1); coinbaseTx.vin[0].prevout.SetNull(); coinbaseTx.vout.resize(1); &nbsp;&nbsp;&nbsp;&nbsp;//挖矿奖励和手续费 coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn; coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus()); coinbaseTx.vin[0].scriptSig = CScript() &lt;&lt; nHeight &lt;&lt; OP_0; &nbsp;&nbsp;&nbsp;&nbsp;//第一笔交易即为矿工获得奖励和手续费的特殊交易 pblock-&gt;vtx[0] = MakeTransactionRef(std::move(coinbaseTx)); pblocktemplate-&gt;vchCoinbaseCommitment = GenerateCoinbaseCommitment(*pblock, pindexPrev, chainparams.GetConsensus()); pblocktemplate-&gt;vTxFees[0] = -nFees; LogPrintf(&quot;CreateNewBlock(): block weight: %u txs: %u fees: %ld sigops %d\\n&quot;, GetBlockWeight(*pblock), nBlockTx, nFees, nBlockSigOpsCost); //上一个区块的哈希值 pblock-&gt;hashPrevBlock = pindexPrev-&gt;GetBlockHash(); UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev); &nbsp;&nbsp;&nbsp;&nbsp;//当前挖矿难度 pblock-&gt;nBits = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus()); &nbsp;&nbsp;&nbsp;&nbsp;//随机数Nonce值 pblock-&gt;nNonce = 0; pblocktemplate-&gt;vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock-&gt;vtx[0]); CValidationState state; if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) { throw std::runtime_error(strprintf(&quot;%s: TestBlockValidity failed: %s&quot;, __func__, FormatStateMessage(state))); } int64_t nTime2 = GetTimeMicros(); LogPrint(BCLog::BENCH, &quot;CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\\n&quot;, 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart)); return std::move(pblocktemplate); } //代码位置src/miner.cpp ``` ### 比特币挖矿难度计算 每创建2016个块后将计算新的难度，此后的2016个块使用新的难度。计算步骤如下： * 1、找到前2016个块的第一个块，计算生成这2016个块花费的时间。 即最后一个块的时间与第一个块的时间差。时间差不小于3.5天，不大于56天。 * 2、计算前2016个块的难度总和，即单个块的难度*总时间。 * 3、计算新的难度，即2016个块的难度总和/14天的秒数，得到每秒的难度值。 * 4、要求新的难度，难度不低于参数定义的最小难度。 bitcoin-0.15.1源码中计算挖矿难度代码如下： ```c++ //nFirstBlockTime即前2016个块的第一个块的时间戳 unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params) { if (params.fPowNoRetargeting) return pindexLast-&gt;nBits; //计算生成这2016个块花费的时间 int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime; &nbsp;&nbsp;&nbsp;&nbsp;//不小于3.5天 if (nActualTimespan &lt; params.nPowTargetTimespan/4) nActualTimespan = params.nPowTargetTimespan/4; &nbsp;&nbsp;&nbsp;&nbsp;//不大于56天 if (nActualTimespan &gt; params.nPowTargetTimespan*4) nActualTimespan = params.nPowTargetTimespan*4; // Retarget const arith_uint256 bnPowLimit = UintToArith256(params.powLimit); arith_uint256 bnNew; bnNew.SetCompact(pindexLast-&gt;nBits); &nbsp;&nbsp;&nbsp;&nbsp;//计算前2016个块的难度总和 &nbsp;&nbsp;&nbsp;&nbsp;//即单个块的难度*总时间 bnNew *= nActualTimespan; &nbsp;&nbsp;&nbsp;&nbsp;//计算新的难度 &nbsp;&nbsp;&nbsp;&nbsp;//即2016个块的难度总和/14天的秒数 bnNew /= params.nPowTargetTimespan; &nbsp;&nbsp;&nbsp;&nbsp; //bnNew越小，难度越大 &nbsp;&nbsp;&nbsp;&nbsp; //bnNew越大，难度越小 &nbsp;&nbsp;&nbsp;&nbsp; //要求新的难度，难度不低于参数定义的最小难度 if (bnNew &gt; bnPowLimit) bnNew = bnPowLimit; return bnNew.GetCompact(); } //代码位置src/pow.cpp ``` ### 以太坊区块 以太坊区块由Header和Body两部分组成。 其中Header部分成员如下： * ParentHash，父区块哈希 * UncleHash，叔区块哈希，具体为Body中Uncles数组的RLP哈希值。RLP哈希，即某类型对象RLP编码后做SHA3哈希运算。 * Coinbase，矿工地址。 * Root，StateDB中state Trie根节点RLP哈希值。 * TxHash，Block中tx Trie根节点RLP哈希值。 * ReceiptHash，Block中Receipt Trie根节点的RLP哈希值。 * Difficulty，区块难度，即当前挖矿难度。 * Number，区块序号，即父区块Number+1。 * GasLimit，区块内所有Gas消耗的理论上限，创建时指定，由父区块GasUsed和GasLimit计算得出。 * GasUsed，区块内所有Transaction执行时消耗的Gas总和。 * Time，当前时间戳。 * Nonce，随机数Nonce值。 有关叔区块： 叔区块，即孤立的块。以太坊成块速度较快，导致产生孤块。 以太坊会给发现孤块的矿工以回报，激励矿工在新块中引用孤块，引用孤块使主链更重。 在以太坊中，主链是指最重的链。 有关state Trie、tx Trie和Receipt Trie： * state Trie，所有账户对象可以逐个插入一个Merkle-PatricaTrie(MPT)结构中，形成state Trie。 * tx Trie：Block中Transactions中所有tx对象，逐个插入MPT结构中，形成tx Trie。 * Receipt Trie：Block中所有Transaction执行后生成Receipt数组，所有Receipt逐个插入MPT结构中，形成Receipt Trie。 Body成员如下： * Transactions，交易列表。 * Uncles，引用的叔区块列表。 go-ethereum-1.7.3源码中区块头和区块定义： ```go type Header struct { &nbsp;&nbsp;&nbsp;&nbsp; //父区块哈希 &nbsp;&nbsp;&nbsp;&nbsp;ParentHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //叔区块哈希 &nbsp;&nbsp;&nbsp;&nbsp;UncleHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //矿工地址 &nbsp;&nbsp;&nbsp;&nbsp;Coinbase common.Address &nbsp;&nbsp;&nbsp;&nbsp; //StateDB中state Trie根节点RLP哈希值 &nbsp;&nbsp;&nbsp;&nbsp;Root common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //Block中tx Trie根节点RLP哈希值 &nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //Block中Receipt Trie根节点的RLP哈希值 &nbsp;&nbsp;&nbsp;&nbsp;ReceiptHash common.Hash &nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom &nbsp;&nbsp;&nbsp;&nbsp; //区块难度 &nbsp;&nbsp;&nbsp;&nbsp;Difficulty *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //区块序号 &nbsp;&nbsp;&nbsp;&nbsp;Number *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //区块内所有Gas消耗的理论上限 &nbsp;&nbsp;&nbsp;&nbsp;GasLimit *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //区块内所有Transaction执行时消耗的Gas总和 &nbsp;&nbsp;&nbsp;&nbsp;GasUsed *big.Int &nbsp;&nbsp;&nbsp;&nbsp; //当前时间戳 &nbsp;&nbsp;&nbsp;&nbsp;Time *big.Int &nbsp;&nbsp;&nbsp;&nbsp;Extra [] byte &nbsp;&nbsp;&nbsp;&nbsp;MixDigest common.Hash &nbsp;&nbsp;&nbsp;&nbsp; //随机数Nonce值 &nbsp;&nbsp;&nbsp;&nbsp;Nonce BlockNonce } type Body struct { &nbsp;&nbsp;&nbsp;&nbsp; //交易列表 &nbsp;&nbsp;&nbsp;&nbsp;Transactions []*Transaction &nbsp;&nbsp;&nbsp;&nbsp; //引用的叔区块列表 &nbsp;&nbsp;&nbsp;&nbsp;Uncles []*Header } //代码位置core/types/block.go ``` ### 以太坊Pow算法原理 以太坊Pow算法可以表示为如下公式： RAND(h, n) &lt;= M / d 其中RAND()表示一个概念函数，代表一系列的复杂运算。 其中h和n为输入，即区块Header的哈希、以及Header中的Nonce。 M表示一个极大的数，此处使用2^256-1。 d，为区块难度，即Header中的Difficulty。 因此在h和n确定的情况下，d越大，挖矿难度越大，即为Difficulty本义。 即不断变更Nonce，使RAND(h, n)满足RAND(h, n) &lt;= M / d，即完成Pow。 go-ethereum-1.7.3源码中Pow算法实现： ```go func (ethash *Ethash) mine(block *types.Block, id int, seed uint64, abort chan struct{}, found chan *types.Block) { &nbsp;&nbsp;&nbsp;&nbsp; // Extract some data from the header &nbsp;&nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header = block.Header() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash = header.HashNoNonce().Bytes() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //target，即M / d，即(2^256-1)/Difficulty &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target = new(big.Int).Div(maxUint256, header.Difficulty) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number = header.Number.Uint64() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataset = ethash.dataset(number) &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp; // Start generating random nonces until we abort or find a good one &nbsp;&nbsp;&nbsp;&nbsp; var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts = int64( 0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonce = seed &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp;logger := log.New( &quot;miner&quot;, id) &nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Started ethash search for new nonces&quot;, &quot;seed&quot;, seed) &nbsp;&nbsp;&nbsp;&nbsp; for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Mining terminated, update stats and abort &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Ethash nonce search aborted&quot;, &quot;attempts&quot;, nonce-seed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We don&#39;t have to update hash rate on every nonce, so update after after 2^X nonces &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attempts % ( 1 &lt;&lt; 15)) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ethash.hashrate.Mark(attempts) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts = 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //hashimotoFull即RAND(h, n)所代表的一系列的复杂运算 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;digest, result := hashimotoFull(dataset, hash, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //result满足RAND(h, n) &lt;= M / d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Correct nonce found, create a new header with it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header = types.CopyHeader(header) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.Nonce = types.EncodeNonce(nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.MixDigest = common.BytesToHash(digest) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Seal and return a block (if still needed) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case found &lt;- block.WithSeal(header): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Ethash nonce found and reported&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case &lt;-abort: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace( &quot;Ethash nonce found but discarded&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //不断变更Nonce &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonce++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } //代码位置consensus/ethash/sealer.go ``` ### 以太坊挖矿难度计算 以太坊每次挖矿均需计算当前区块难度。 按版本不同有三种计算难度的规则，分别为：calcDifficultyByzantium（Byzantium版）、calcDifficultyHomestead（Homestead版）、calcDifficultyFrontier（Frontier版）。 此处以calcDifficultyHomestead为例。 计算难度时输入有： * parent_timestamp：父区块时间戳 * parent_diff：父区块难度 * block_timestamp：当前区块时间戳 * block_number：当前区块的序号 当前区块难度计算公式，即： ``` block_diff = parent_diff + (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99) + 2^((block_number // 100000) - 2) ``` 其中//为整数除法运算符，a//b，即先计算a/b，然后取不大于a/b的最大整数。 调整难度的目的，即为使挖矿时间保持在10-19s期间内，如果低于10s增大挖矿难度，如果大于19s将减小难度。 另外，计算出的当前区块难度不应低于以太坊创世区块难度，即131072。 go-ethereum-1.7.3源码中计算挖矿难度代码如下： ```go func calcDifficultyHomestead(time uint64, parent *types.Header) *big.Int { &nbsp;&nbsp;&nbsp;&nbsp; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.mediawiki &nbsp;&nbsp;&nbsp;&nbsp; // algorithm: &nbsp;&nbsp;&nbsp;&nbsp; // diff = (parent_diff + &nbsp;&nbsp;&nbsp;&nbsp; // (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99)) &nbsp;&nbsp;&nbsp;&nbsp; // ) + 2^(periodCount - 2) &nbsp;&nbsp;&nbsp;&nbsp;bigTime := new(big.Int).SetUint64(time) &nbsp;&nbsp;&nbsp;&nbsp;bigParentTime := new(big.Int).Set(parent.Time) &nbsp;&nbsp;&nbsp;&nbsp; // holds intermediate values to make the algo easier to read &amp; audit &nbsp;&nbsp;&nbsp;&nbsp;x := new(big.Int) &nbsp;&nbsp;&nbsp;&nbsp;y := new(big.Int) &nbsp;&nbsp;&nbsp;&nbsp; // 1 - (block_timestamp - parent_timestamp) // 10 &nbsp;&nbsp;&nbsp;&nbsp;x.Sub(bigTime, bigParentTime) &nbsp;&nbsp;&nbsp;&nbsp;x.Div(x, big10) &nbsp;&nbsp;&nbsp;&nbsp;x.Sub(big1, x) &nbsp;&nbsp;&nbsp;&nbsp; // max(1 - (block_timestamp - parent_timestamp) // 10, -99) &nbsp;&nbsp;&nbsp;&nbsp; if x.Cmp(bigMinus99) &lt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Set(bigMinus99) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // (parent_diff + parent_diff // 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99)) &nbsp;&nbsp;&nbsp;&nbsp;y.Div(parent.Difficulty, params.DifficultyBoundDivisor) &nbsp;&nbsp;&nbsp;&nbsp;x.Mul(y, x) &nbsp;&nbsp;&nbsp;&nbsp;x.Add(parent.Difficulty, x) &nbsp;&nbsp;&nbsp;&nbsp; // minimum difficulty can ever be (before exponential factor) &nbsp;&nbsp;&nbsp;&nbsp; if x.Cmp(params.MinimumDifficulty) &lt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Set(params.MinimumDifficulty) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // for the exponential factor &nbsp;&nbsp;&nbsp;&nbsp;periodCount := new(big.Int).Add(parent.Number, big1) &nbsp;&nbsp;&nbsp;&nbsp;periodCount.Div(periodCount, expDiffPeriod) &nbsp;&nbsp;&nbsp;&nbsp; // the exponential factor, commonly referred to as &quot;the bomb&quot; &nbsp;&nbsp;&nbsp;&nbsp; // diff = diff + 2^(periodCount - 2) &nbsp;&nbsp;&nbsp;&nbsp; if periodCount.Cmp(big1) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.Sub(periodCount, big2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.Exp(big2, y, nil) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Add(x, y) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; return x } //代码位置consensus/ethash/consensus.go ``` ### 后记 Pow算法概念简单，即工作端提交难以计算但易于验证的计算结果，其他节点通过验证这个结果来确信工作端完成了相当的工作量。 但其缺陷也很明显：1、随着节点将CPU挖矿升级为GPU、甚至矿机挖矿，节点数和算力已渐渐失衡； 2、比特币等网络每秒需完成数百万亿次哈希计算，资源大量浪费。 为此，业内提出了Pow的替代者如PoS权益证明算法，即要求用户拥有一定数量的货币，才有权参与确定下一个合法区块。 另外，相对拥有51%算力，购买超过半数以上的货币难度更大，也使得恶意攻击更加困难。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/05/21/f6d5d5f9340a8a111c4204d8ad33976f.html","headline":"区块链共识算法(2)PoW挖矿算法原理及其在比特币、以太坊中的实现","dateModified":"2018-05-21T00:00:00+08:00","datePublished":"2018-05-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/05/21/f6d5d5f9340a8a111c4204d8ad33976f.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链共识算法(2)PoW挖矿算法原理及其在比特币、以太坊中的实现</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div style="font-size:14px;color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas, 'Courier New', monospace;line-height:19px;">
   <div>
    <span style="color:rgb(86,156,214);"><span style="font-weight:700;"># PoW挖矿算法原理及其在比特币、以太坊中的实现</span></span>
   </div>
   <br>
   <div>
    PoW，全称Proof of Work，即工作量证明，又称挖矿。
   </div>
   <div>
    大部分公有链或虚拟货币，如比特币、以太坊，均基于PoW算法，来实现其共识机制。
   </div>
   <div>
    即根据挖矿贡献的有效工作，来决定货币的分配。
   </div>
   <br>
   <div>
    <span style="color:rgb(86,156,214);"><span style="font-weight:700;">### 比特币区块</span></span>
   </div>
   <br>
   <div>
    比特币区块由区块头和该区块所包含的交易列表组成。
   </div>
   <div>
    区块头大小为80字节，其构成包括：
   </div>
   <br>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 4字节：版本号
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 32字节：上一个区块的哈希值
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 32字节：交易列表的Merkle根哈希值
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 4字节：当前时间戳
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 4字节：当前难度值
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 4字节：随机数Nonce值
   </div>
   <br>
   <div>
    此80字节长度的区块头，即为比特币Pow算法的输入字符串。
   </div>
   <div>
    交易列表附加在区块头之后，其中第一笔交易为矿工获得奖励和手续费的特殊交易。
   </div>
   <br>
   <div>
    bitcoin-0.15.1源码中区块头和区块定义：
   </div>
   <br>
   <div>
    ```c++
   </div>
   <div>
    <span style="color:rgb(86,156,214);">class</span> 
    <span style="color:rgb(78,201,176);">CBlockHeader</span>
   </div>
   <div>
    {
   </div>
   <div>
    public:
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//版本号
   </div>
   <div>
     int32_t nVersion;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//上一个区块的哈希值
   </div>
   <div>
     uint256 hashPrevBlock;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//交易列表的Merkle根哈希值
   </div>
   <div>
     uint256 hashMerkleRoot;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//当前时间戳
   </div>
   <div>
     uint32_t nTime;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//当前挖矿难度，nBits越小难度越大
   </div>
   <div>
     uint32_t nBits;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//随机数Nonce值
   </div>
   <div>
     uint32_t nNonce;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//其它代码略
   </div>
   <div>
    };
   </div>
   <br>
   <div>
    <span style="color:rgb(86,156,214);">class</span> 
    <span style="color:rgb(78,201,176);">CBlock</span> : 
    <span style="color:rgb(86,156,214);">public</span> 
    <span style="color:rgb(78,201,176);">CBlockHeader</span>
   </div>
   <div>
    {
   </div>
   <div>
    public:
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//交易列表
   </div>
   <div>
     std::vector&lt;CTransactionRef&gt; vtx;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//其它代码略
   </div>
   <div>
    };
   </div>
   <div>
    <span style="color:rgb(96,139,78);">//代码位置src/primitives/block.h</span>
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:rgb(86,156,214);"><span style="font-weight:700;">### 比特币Pow算法原理</span></span>
   </div>
   <br>
   <div>
    Pow的过程，即为不断调整Nonce值，对区块头做双重SHA256哈希运算，使得结果满足给定数量前导0的哈希值的过程。
   </div>
   <div>
    其中前导0的个数，取决于挖矿难度，前导0的个数越多，挖矿难度越大。
   </div>
   <br>
   <div>
    具体如下：
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 1、生成铸币交易，并与其它所有准备打包进区块的交易组成交易列表，生成Merkle根哈希值。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 2、将Merkle根哈希值，与区块头其它字段组成区块头，80字节长度的区块头作为Pow算法的输入。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 3、不断变更区块头中的随机数Nonce，对变更后的区块头做双重SHA256哈希运算，与当前难度的目标值做比对，
   </div>
   <div>
    如果小于目标难度，即Pow完成。
   </div>
   <br>
   <div>
    Pow完成的区块向全网广播，其他节点将验证其是否符合规则，如果验证有效，其他节点将接收此区块，并附加在已有区块链之后。
   </div>
   <div>
    之后将进入下一轮挖矿。
   </div>
   <br>
   <div>
    bitcoin-0.15.1源码中Pow算法实现：
   </div>
   <br>
   <div>
    ```c++
   </div>
   <div>
    UniValue 
    <span style="color:rgb(220,220,170);">generateBlocks</span>(std::shared_ptr&lt;CReserveScript&gt; coinbaseScript, int nGenerate, 
   </div>
   <div>
    uint64_t nMaxTries, bool keepScript)
   </div>
   <div>
    {
   </div>
   <div>
     static const int nInnerLoopCount = 0x10000;
   </div>
   <div>
     int nHeightEnd = 0;
   </div>
   <div>
     int nHeight = 0;
   </div>
   <br>
   <div>
     { // Don't keep cs_main locked
   </div>
   <div>
     LOCK(cs_main);
   </div>
   <div>
     nHeight = chainActive.Height();
   </div>
   <div>
     nHeightEnd = nHeight+nGenerate;
   </div>
   <div>
     }
   </div>
   <div>
     unsigned int nExtraNonce = 0;
   </div>
   <div>
     UniValue blockHashes(UniValue::VARR);
   </div>
   <div>
     while (nHeight &lt; nHeightEnd)
   </div>
   <div>
     {
   </div>
   <div>
     std::unique_ptr&lt;CBlockTemplate&gt; pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript-&gt;reserveScript));
   </div>
   <div>
     if (!pblocktemplate.get())
   </div>
   <div>
     throw JSONRPCError(RPC_INTERNAL_ERROR, "Couldn't create new block");
   </div>
   <div>
     CBlock *pblock = &amp;pblocktemplate-&gt;block;
   </div>
   <div>
     {
   </div>
   <div>
     LOCK(cs_main);
   </div>
   <div>
     IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);
   </div>
   <div>
     }
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//不断变更区块头中的随机数Nonce
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//对变更后的区块头做双重SHA256哈希运算
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//与当前难度的目标值做比对，如果小于目标难度，即Pow完成
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//uint64_t nMaxTries = 1000000;即重试100万次
   </div>
   <div>
     while (nMaxTries &gt; 0 &amp;&amp; pblock-&gt;nNonce &lt; nInnerLoopCount &amp;&amp; !CheckProofOfWork(pblock-&gt;GetHash(), pblock-&gt;nBits, Params().GetConsensus())) {
   </div>
   <div>
     ++pblock-&gt;nNonce;
   </div>
   <div>
     --nMaxTries;
   </div>
   <div>
     }
   </div>
   <div>
     if (nMaxTries == 0) {
   </div>
   <div>
     break;
   </div>
   <div>
     }
   </div>
   <div>
     if (pblock-&gt;nNonce == nInnerLoopCount) {
   </div>
   <div>
     continue;
   </div>
   <div>
     }
   </div>
   <div>
     std::shared_ptr&lt;const CBlock&gt; shared_pblock = std::make_shared&lt;const CBlock&gt;(*pblock);
   </div>
   <div>
     if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))
   </div>
   <div>
     throw JSONRPCError(RPC_INTERNAL_ERROR, "ProcessNewBlock, block not accepted");
   </div>
   <div>
     ++nHeight;
   </div>
   <div>
     blockHashes.push_back(pblock-&gt;GetHash().GetHex());
   </div>
   <br>
   <div> 
    <span style="color:rgb(96,139,78);">//mark script as important because it was used at least for one coinbase output if the script came from the wallet</span>
   </div>
   <div>
     if (keepScript)
   </div>
   <div>
     {
   </div>
   <div>
     coinbaseScript-&gt;KeepScript();
   </div>
   <div>
     }
   </div>
   <div>
     }
   </div>
   <div>
     return blockHashes;
   </div>
   <div>
    }
   </div>
   <div>
    <span style="color:rgb(96,139,78);">//代码位置src/rpc/mining.cpp</span>
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    另附bitcoin-0.15.1源码中生成铸币交易和创建新块：
   </div>
   <br>
   <div>
    ```c++
   </div>
   <div>
    std::unique_ptr&lt;CBlockTemplate&gt; 
    <span style="color:rgb(220,220,170);">BlockAssembler::CreateNewBlock</span>(const CScript&amp; scriptPubKeyIn, bool fMineWitnessTx)
   </div>
   <div>
    {
   </div>
   <div>
     int64_t nTimeStart = GetTimeMicros();
   </div>
   <br>
   <div>
     resetBlock();
   </div>
   <br>
   <div>
     pblocktemplate.reset(new CBlockTemplate());
   </div>
   <br>
   <div>
     if(!pblocktemplate.get())
   </div>
   <div>
     return nullptr;
   </div>
   <div>
     pblock = &amp;pblocktemplate-&gt;block; // pointer for convenience
   </div>
   <br>
   <div>
     pblock-&gt;vtx.emplace_back();
   </div>
   <div>
     pblocktemplate-&gt;vTxFees.push_back(-1); // updated at end
   </div>
   <div>
     pblocktemplate-&gt;vTxSigOpsCost.push_back(-1); // updated at end
   </div>
   <br>
   <div>
     LOCK2(cs_main, mempool.cs);
   </div>
   <div>
     CBlockIndex* pindexPrev = chainActive.Tip();
   </div>
   <div>
     nHeight = pindexPrev-&gt;nHeight + 1;
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//版本号</span>
   </div>
   <div>
     pblock-&gt;nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());
   </div>
   <div>
     if (chainparams.MineBlocksOnDemand())
   </div>
   <div>
     pblock-&gt;nVersion = gArgs.GetArg("-blockversion", pblock-&gt;nVersion);
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//当前时间戳
   </div>
   <div>
     pblock-&gt;nTime = GetAdjustedTime();
   </div>
   <div>
     const int64_t nMedianTimePast = pindexPrev-&gt;GetMedianTimePast();
   </div>
   <br>
   <div>
     nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS &amp; LOCKTIME_MEDIAN_TIME_PAST)
   </div>
   <div>
     ? nMedianTimePast
   </div>
   <div>
     : pblock-&gt;GetBlockTime();
   </div>
   <div>
     fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus()) &amp;&amp; fMineWitnessTx;
   </div>
   <br>
   <div>
     int nPackagesSelected = 0;
   </div>
   <div>
     int nDescendantsUpdated = 0;
   </div>
   <div>
     addPackageTxs(nPackagesSelected, nDescendantsUpdated);
   </div>
   <br>
   <div>
     int64_t nTime1 = GetTimeMicros();
   </div>
   <br>
   <div>
     nLastBlockTx = nBlockTx;
   </div>
   <div>
     nLastBlockWeight = nBlockWeight;
   </div>
   <br>
   <div> 
    <span style="color:rgb(96,139,78);">//创建铸币交易</span>
   </div>
   <div>
     CMutableTransaction coinbaseTx;
   </div>
   <div>
     coinbaseTx.vin.resize(1);
   </div>
   <div>
     coinbaseTx.vin[0].prevout.SetNull();
   </div>
   <div>
     coinbaseTx.vout.resize(1);
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//挖矿奖励和手续费
   </div>
   <div>
     coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;
   </div>
   <div>
     coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());
   </div>
   <div>
     coinbaseTx.vin[0].scriptSig = CScript() &lt;&lt; nHeight &lt;&lt; OP_0;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//第一笔交易即为矿工获得奖励和手续费的特殊交易
   </div>
   <div>
     pblock-&gt;vtx[0] = MakeTransactionRef(std::move(coinbaseTx));
   </div>
   <div>
     pblocktemplate-&gt;vchCoinbaseCommitment = GenerateCoinbaseCommitment(*pblock, pindexPrev, chainparams.GetConsensus());
   </div>
   <div>
     pblocktemplate-&gt;vTxFees[0] = -nFees;
   </div>
   <br>
   <div>
     LogPrintf("CreateNewBlock(): block weight: %u txs: %u fees: %ld sigops %d\n", GetBlockWeight(*pblock), nBlockTx, nFees, nBlockSigOpsCost);
   </div>
   <br>
   <div> 
    <span style="color:rgb(96,139,78);">//上一个区块的哈希值</span>
   </div>
   <div>
     pblock-&gt;hashPrevBlock = pindexPrev-&gt;GetBlockHash();
   </div>
   <div>
     UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//当前挖矿难度
   </div>
   <div>
     pblock-&gt;nBits = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus());
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//随机数Nonce值
   </div>
   <div>
     pblock-&gt;nNonce = 0;
   </div>
   <div>
     pblocktemplate-&gt;vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock-&gt;vtx[0]);
   </div>
   <br>
   <div>
     CValidationState state;
   </div>
   <div>
     if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {
   </div>
   <div>
     throw std::runtime_error(strprintf("%s: TestBlockValidity failed: %s", __func__, FormatStateMessage(state)));
   </div>
   <div>
     }
   </div>
   <div>
     int64_t nTime2 = GetTimeMicros();
   </div>
   <br>
   <div>
     LogPrint(BCLog::BENCH, "CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\n", 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart));
   </div>
   <br>
   <div>
     return std::move(pblocktemplate);
   </div>
   <div>
    }
   </div>
   <div>
    <span style="color:rgb(96,139,78);">//代码位置src/miner.cpp</span>
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:rgb(86,156,214);"><span style="font-weight:700;">### 比特币挖矿难度计算</span></span>
   </div>
   <br>
   <div>
    每创建2016个块后将计算新的难度，此后的2016个块使用新的难度。计算步骤如下：
   </div>
   <br>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 1、找到前2016个块的第一个块，计算生成这2016个块花费的时间。
   </div>
   <div>
    即最后一个块的时间与第一个块的时间差。时间差不小于3.5天，不大于56天。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 2、计算前2016个块的难度总和，即单个块的难度*总时间。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 3、计算新的难度，即2016个块的难度总和/14天的秒数，得到每秒的难度值。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> 4、要求新的难度，难度不低于参数定义的最小难度。
   </div>
   <br>
   <div>
    bitcoin-0.15.1源码中计算挖矿难度代码如下：
   </div>
   <br>
   <div>
    ```c++
   </div>
   <div>
    <span style="color:rgb(96,139,78);">//nFirstBlockTime即前2016个块的第一个块的时间戳</span>
   </div>
   <div>
    <span style="color:rgb(86,156,214);">unsigned</span> 
    <span style="color:rgb(86,156,214);">int</span> 
    <span style="color:rgb(220,220,170);">CalculateNextWorkRequired</span>(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params)
   </div>
   <div>
    {
   </div>
   <div>
     if (params.fPowNoRetargeting)
   </div>
   <div>
     return pindexLast-&gt;nBits;
   </div>
   <br>
   <div> 
    <span style="color:rgb(96,139,78);">//计算生成这2016个块花费的时间</span>
   </div>
   <div>
     int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//不小于3.5天
   </div>
   <div>
     if (nActualTimespan &lt; params.nPowTargetTimespan/4)
   </div>
   <div>
     nActualTimespan = params.nPowTargetTimespan/4;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//不大于56天
   </div>
   <div>
     if (nActualTimespan &gt; params.nPowTargetTimespan*4)
   </div>
   <div>
     nActualTimespan = params.nPowTargetTimespan*4;
   </div>
   <br>
   <div> 
    <span style="color:rgb(96,139,78);">// Retarget</span>
   </div>
   <div>
     const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);
   </div>
   <div>
     arith_uint256 bnNew;
   </div>
   <div>
     bnNew.SetCompact(pindexLast-&gt;nBits);
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//计算前2016个块的难度总和
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//即单个块的难度*总时间
   </div>
   <div>
     bnNew *= nActualTimespan;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//计算新的难度
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//即2016个块的难度总和/14天的秒数
   </div>
   <div>
     bnNew /= params.nPowTargetTimespan;
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//bnNew越小，难度越大</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//bnNew越大，难度越小</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//要求新的难度，难度不低于参数定义的最小难度</span>
   </div>
   <div>
     if (bnNew &gt; bnPowLimit)
   </div>
   <div>
     bnNew = bnPowLimit;
   </div>
   <br>
   <div>
     return bnNew.GetCompact();
   </div>
   <div>
    }
   </div>
   <div>
    <span style="color:rgb(96,139,78);">//代码位置src/pow.cpp</span>
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:rgb(86,156,214);"><span style="font-weight:700;">### 以太坊区块</span></span>
   </div>
   <br>
   <div>
    以太坊区块由Header和Body两部分组成。
   </div>
   <br>
   <div>
    其中Header部分成员如下：
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> ParentHash，父区块哈希
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> UncleHash，叔区块哈希，具体为Body中Uncles数组的RLP哈希值。RLP哈希，即某类型对象RLP编码后做SHA3哈希运算。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> Coinbase，矿工地址。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> Root，StateDB中state Trie根节点RLP哈希值。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> TxHash，Block中tx Trie根节点RLP哈希值。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> ReceiptHash，Block中Receipt Trie根节点的RLP哈希值。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> Difficulty，区块难度，即当前挖矿难度。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> Number，区块序号，即父区块Number+1。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> GasLimit，区块内所有Gas消耗的理论上限，创建时指定，由父区块GasUsed和GasLimit计算得出。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> GasUsed，区块内所有Transaction执行时消耗的Gas总和。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> Time，当前时间戳。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> Nonce，随机数Nonce值。
   </div>
   <br>
   <div>
    有关叔区块：
   </div>
   <div>
    叔区块，即孤立的块。以太坊成块速度较快，导致产生孤块。
   </div>
   <div>
    以太坊会给发现孤块的矿工以回报，激励矿工在新块中引用孤块，引用孤块使主链更重。
   </div>
   <div>
    在以太坊中，主链是指最重的链。
   </div>
   <br>
   <div>
    有关state Trie、tx Trie和Receipt Trie：
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> state Trie，所有账户对象可以逐个插入一个Merkle-PatricaTrie(MPT)结构中，形成state Trie。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> tx Trie：Block中Transactions中所有tx对象，逐个插入MPT结构中，形成tx Trie。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> Receipt Trie：Block中所有Transaction执行后生成Receipt数组，所有Receipt逐个插入MPT结构中，形成Receipt Trie。
   </div>
   <br>
   <div>
    Body成员如下：
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> Transactions，交易列表。
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> Uncles，引用的叔区块列表。
   </div>
   <br>
   <div>
    go-ethereum-1.7.3源码中区块头和区块定义：
   </div>
   <br>
   <div>
    ```go
   </div>
   <div>
    <span style="color:rgb(86,156,214);">type</span> 
    <span style="color:rgb(78,201,176);">Header</span> 
    <span style="color:rgb(86,156,214);">struct</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//父区块哈希</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;ParentHash common.Hash
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//叔区块哈希</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;UncleHash common.Hash
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//矿工地址</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Coinbase common.Address
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//StateDB中state Trie根节点RLP哈希值</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Root common.Hash
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//Block中tx Trie根节点RLP哈希值</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;TxHash common.Hash
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//Block中Receipt Trie根节点的RLP哈希值</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;ReceiptHash common.Hash
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Bloom Bloom
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//区块难度</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Difficulty *big.Int
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//区块序号</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Number *big.Int
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//区块内所有Gas消耗的理论上限</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;GasLimit *big.Int
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//区块内所有Transaction执行时消耗的Gas总和</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;GasUsed *big.Int
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//当前时间戳</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Time *big.Int
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Extra []
    <span style="color:rgb(78,201,176);">byte</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;MixDigest common.Hash
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//随机数Nonce值</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Nonce BlockNonce
   </div>
   <div>
    }
   </div>
   <br>
   <div>
    <span style="color:rgb(86,156,214);">type</span> 
    <span style="color:rgb(78,201,176);">Body</span> 
    <span style="color:rgb(86,156,214);">struct</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//交易列表</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Transactions []*Transaction
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//引用的叔区块列表</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Uncles []*Header
   </div>
   <div>
    }
   </div>
   <div>
    <span style="color:rgb(96,139,78);">//代码位置core/types/block.go</span>
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:rgb(86,156,214);"><span style="font-weight:700;">### 以太坊Pow算法原理</span></span>
   </div>
   <br>
   <div>
    以太坊Pow算法可以表示为如下公式：
   </div>
   <br>
   <div>
    RAND(h, n) &lt;= M / d
   </div>
   <br>
   <div>
    其中RAND()表示一个概念函数，代表一系列的复杂运算。
   </div>
   <div>
    其中h和n为输入，即区块Header的哈希、以及Header中的Nonce。
   </div>
   <div>
    M表示一个极大的数，此处使用2^256-1。
   </div>
   <div>
    d，为区块难度，即Header中的Difficulty。
   </div>
   <br>
   <div>
    因此在h和n确定的情况下，d越大，挖矿难度越大，即为Difficulty本义。
   </div>
   <div>
    即不断变更Nonce，使RAND(h, n)满足RAND(h, n) &lt;= M / d，即完成Pow。
   </div>
   <br>
   <div>
    go-ethereum-1.7.3源码中Pow算法实现：
   </div>
   <br>
   <div>
    ```go
   </div>
   <div>
    <span style="color:rgb(86,156,214);">func</span> (ethash *Ethash) mine(block *types.Block, id 
    <span style="color:rgb(78,201,176);">int</span>, seed 
    <span style="color:rgb(78,201,176);">uint64</span>, abort 
    <span style="color:rgb(86,156,214);">chan</span> 
    <span style="color:rgb(86,156,214);">struct</span>{}, found 
    <span style="color:rgb(86,156,214);">chan</span> *types.Block) {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// Extract some data from the header</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(86,156,214);">var</span> (
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header = block.Header()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash = header.HashNoNonce().Bytes()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//target，即M / d，即(2^256-1)/Difficulty</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target = 
    <span style="color:rgb(220,220,170);">new</span>(big.Int).Div(maxUint256, header.Difficulty)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number = header.Number.Uint64()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataset = ethash.dataset(number)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// Start generating random nonces until we abort or find a good one</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(86,156,214);">var</span> (
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts = int64(
    <span style="color:rgb(181,206,168);">0</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonce = seed
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;logger := log.New(
    <span style="color:rgb(206,145,120);">"miner"</span>, id)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;logger.Trace(
    <span style="color:rgb(206,145,120);">"Started ethash search for new nonces"</span>, 
    <span style="color:rgb(206,145,120);">"seed"</span>, seed)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">for</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">select</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">case</span> &lt;-abort:
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// Mining terminated, update stats and abort</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace(
    <span style="color:rgb(206,145,120);">"Ethash nonce search aborted"</span>, 
    <span style="color:rgb(206,145,120);">"attempts"</span>, nonce-seed)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ethash.hashrate.Mark(attempts)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">return</span>
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">default</span>:
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// We don't have to update hash rate on every nonce, so update after after 2^X nonces</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts++
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">if</span> (attempts % (
    <span style="color:rgb(181,206,168);">1</span> &lt;&lt; 
    <span style="color:rgb(181,206,168);">15</span>)) == 
    <span style="color:rgb(181,206,168);">0</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ethash.hashrate.Mark(attempts)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attempts = 
    <span style="color:rgb(181,206,168);">0</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//hashimotoFull即RAND(h, n)所代表的一系列的复杂运算</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;digest, result := hashimotoFull(dataset, hash, nonce)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//result满足RAND(h, n) &lt;= M / d</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">if</span> 
    <span style="color:rgb(220,220,170);">new</span>(big.Int).SetBytes(result).Cmp(target) &lt;= 
    <span style="color:rgb(181,206,168);">0</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// Correct nonce found, create a new header with it</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header = types.CopyHeader(header)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.Nonce = types.EncodeNonce(nonce)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header.MixDigest = common.BytesToHash(digest)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// Seal and return a block (if still needed)</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">select</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">case</span> found &lt;- block.WithSeal(header):
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace(
    <span style="color:rgb(206,145,120);">"Ethash nonce found and reported"</span>, 
    <span style="color:rgb(206,145,120);">"attempts"</span>, nonce-seed, 
    <span style="color:rgb(206,145,120);">"nonce"</span>, nonce)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">case</span> &lt;-abort:
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Trace(
    <span style="color:rgb(206,145,120);">"Ethash nonce found but discarded"</span>, 
    <span style="color:rgb(206,145,120);">"attempts"</span>, nonce-seed, 
    <span style="color:rgb(206,145,120);">"nonce"</span>, nonce)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">return</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">//不断变更Nonce</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonce++
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    }
   </div>
   <div>
    <span style="color:rgb(96,139,78);">//代码位置consensus/ethash/sealer.go</span>
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:rgb(86,156,214);"><span style="font-weight:700;">### 以太坊挖矿难度计算</span></span>
   </div>
   <br>
   <div>
    以太坊每次挖矿均需计算当前区块难度。
   </div>
   <div>
    按版本不同有三种计算难度的规则，分别为：calcDifficultyByzantium（Byzantium版）、calcDifficultyHomestead（Homestead版）、calcDifficultyFrontier（Frontier版）。
   </div>
   <div>
    此处以calcDifficultyHomestead为例。
   </div>
   <br>
   <div>
    计算难度时输入有：
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> parent_timestamp：父区块时间戳
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> parent_diff：父区块难度
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> block_timestamp：当前区块时间戳
   </div>
   <div>
    <span style="color:rgb(103,150,230);">*</span> block_number：当前区块的序号
   </div>
   <br>
   <div>
    当前区块难度计算公式，即：
   </div>
   <br>
   <div>
    ```
   </div>
   <div>
    block_diff = parent_diff
   </div>
   <div>
    + (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99)
   </div>
   <div>
    + 2^((block_number // 100000) - 2)
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    其中//为整数除法运算符，a//b，即先计算a/b，然后取不大于a/b的最大整数。
   </div>
   <br>
   <div>
    调整难度的目的，即为使挖矿时间保持在10-19s期间内，如果低于10s增大挖矿难度，如果大于19s将减小难度。
   </div>
   <div>
    另外，计算出的当前区块难度不应低于以太坊创世区块难度，即131072。
   </div>
   <br>
   <div>
    go-ethereum-1.7.3源码中计算挖矿难度代码如下：
   </div>
   <br>
   <div>
    ```go
   </div>
   <div>
    <span style="color:rgb(86,156,214);">func</span> calcDifficultyHomestead(time 
    <span style="color:rgb(78,201,176);">uint64</span>, parent *types.Header) *big.Int {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.mediawiki</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// algorithm:</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// diff = (parent_diff +</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// (parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// ) + 2^(periodCount - 2)</span>
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;bigTime := 
    <span style="color:rgb(220,220,170);">new</span>(big.Int).SetUint64(time)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;bigParentTime := 
    <span style="color:rgb(220,220,170);">new</span>(big.Int).Set(parent.Time)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// holds intermediate values to make the algo easier to read &amp; audit</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;x := 
    <span style="color:rgb(220,220,170);">new</span>(big.Int)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;y := 
    <span style="color:rgb(220,220,170);">new</span>(big.Int)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// 1 - (block_timestamp - parent_timestamp) // 10</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;x.Sub(bigTime, bigParentTime)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;x.Div(x, big10)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;x.Sub(big1, x)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// max(1 - (block_timestamp - parent_timestamp) // 10, -99)</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">if</span> x.Cmp(bigMinus99) &lt; 
    <span style="color:rgb(181,206,168);">0</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Set(bigMinus99)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// (parent_diff + parent_diff // 2048 * max(1 - (block_timestamp - parent_timestamp) // 10, -99))</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;y.Div(parent.Difficulty, params.DifficultyBoundDivisor)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;x.Mul(y, x)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;x.Add(parent.Difficulty, x)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// minimum difficulty can ever be (before exponential factor)</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">if</span> x.Cmp(params.MinimumDifficulty) &lt; 
    <span style="color:rgb(181,206,168);">0</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Set(params.MinimumDifficulty)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// for the exponential factor</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;periodCount := 
    <span style="color:rgb(220,220,170);">new</span>(big.Int).Add(parent.Number, big1)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;periodCount.Div(periodCount, expDiffPeriod)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// the exponential factor, commonly referred to as "the bomb"</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(96,139,78);">// diff = diff + 2^(periodCount - 2)</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">if</span> periodCount.Cmp(big1) &gt; 
    <span style="color:rgb(181,206,168);">0</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.Sub(periodCount, big2)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y.Exp(big2, y, 
    <span style="color:rgb(86,156,214);">nil</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Add(x, y)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:rgb(197,134,192);">return</span> x
   </div>
   <div>
    }
   </div>
   <div>
    <span style="color:rgb(96,139,78);">//代码位置consensus/ethash/consensus.go</span>
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:rgb(86,156,214);"><span style="font-weight:700;">### 后记</span></span>
   </div>
   <br>
   <div>
    Pow算法概念简单，即工作端提交难以计算但易于验证的计算结果，其他节点通过验证这个结果来确信工作端完成了相当的工作量。
   </div>
   <div>
    但其缺陷也很明显：1、随着节点将CPU挖矿升级为GPU、甚至矿机挖矿，节点数和算力已渐渐失衡；
   </div>
   <div>
    2、比特币等网络每秒需完成数百万亿次哈希计算，资源大量浪费。
   </div>
   <div>
    为此，业内提出了Pow的替代者如PoS权益证明算法，即要求用户拥有一定数量的货币，才有权参与确定下一个合法区块。
   </div>
   <div>
    另外，相对拥有51%算力，购买超过半数以上的货币难度更大，也使得恶意攻击更加困难。
   </div>
  </div>
  <p style="background-color:rgb(255,255,255);"></p>
  <p style="background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180517123132574?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDU3MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="background-color:rgb(255,255,255);"><br style="color:rgb(51,51,51);font-size:14px;"><br style="color:rgb(51,51,51);font-size:14px;"></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180425001235188?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180425001144107?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);">网址：http://www.qukuailianxueyuan.io/<br></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180426145827720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018042614570887?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);">欲领取造币技术与全套虚拟机资料</p>
  <p style="background-color:rgb(255,255,255);"><span style="color:rgb(25,25,25);">区块链技术交流QQ群：</span><span style="color:rgb(255,0,0);">756146052&nbsp;&nbsp;</span><span style="color:rgb(25,25,25);">备注：CSDN</span></p>
  <p style="color:rgb(25,25,25);background-color:rgb(255,255,255);">尹成学院微信：备注：CSDN</p>
  <p style="color:rgb(25,25,25);text-align:center;background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180425000635656?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/itcastcpp/article/details/80391364,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/itcastcpp/article/details/80391364,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
