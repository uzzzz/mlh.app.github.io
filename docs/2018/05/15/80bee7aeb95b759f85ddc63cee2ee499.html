<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>用Java搭建一条区块链 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="用Java搭建一条区块链" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/qq_33764491/article/details/80330542 前言 为了更好的理解区块链的底层实现原理，决定自己动手模拟实现一条区块链。 思路分析 通过之前的学习，从文本知识的角度，我们知道，创世区块、记账原理、挖矿原理、工作量证明、共识机制等等区块链的相关知识。 创建一条区块链，首先默认构造创世区块。在此基础上，我们可以发布交易，并进行挖矿，计算出工作量证明，将交易记录到区块中，每成功的挖一次矿，块高就+1。当然在此过程中，可能会出现“造假”的问题。也就是说，每一个新注册的节点，都可以有自己的链。这些链长短不一，为了保证账本的一致性，需要通过一种一致性共识算法来找到最长的链，作为样本，同步数据，保证每个节点上的账本信息都是一致的。 数据结构 区块链 如图所示，索引为1的区块即为创始区块。可想而知，可以用List&lt;区块&gt;来表示区块链。其中，区块链的高度即为链上区块的块数，上图区块高度为4。 区块 单个区块的数据结构有索引、交易列表、时间戳、工作量证明、上一个区块的hash组成。 交易列表 整个区块链就是一个超级大的分布式账本，当发生交易时，矿工们通过计算工作量证明的方法来进行挖矿(本文中挖到矿将得到1个币的奖励)，将发生的交易记录到账本之中。 Web API 我们将通过Postman来模拟请求。请求API如下： /nodes/register 注册网络节点 /nodes/resolve 一致性共识算法 /transactions/new 新建交易 /mine 挖矿 /chain 输出整条链的数据 项目目录结构 Gradle Web 项目 dependencies { compile(&#39;javax:javaee-api:7.0&#39;) compile(&#39;org.json:json:20160810&#39;) testCompile(&#39;junit:junit:4.12&#39;) } 实现代码 注释写的很详细，如果遇到不懂的地方，欢迎大家一同讨论。 BlockChain类 ，所有的核心代码都在其中。 // 存储区块链 private List&lt;Map&lt;String, Object&gt;&gt; chain; // 该实例变量用于当前的交易信息列表 private List&lt;Map&lt;String, Object&gt;&gt; currentTransactions; // 网络中所有节点的集合 private Set&lt;String&gt; nodes; private static BlockChain blockChain = null; private BlockChain() { // 初始化区块链以及当前的交易信息列表 chain = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); currentTransactions = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); // 初始化存储网络中其他节点的集合 nodes = new HashSet&lt;String&gt;(); // 创建创世区块 newBlock(100, &quot;0&quot;); } /** * 在区块链上新建一个区块 * @param proof 新区块的工作量证明 * @param previous_hash 上一个区块的hash值 * @return 返回新建的区块 */ public Map&lt;String, Object&gt; newBlock(long proof, String previous_hash) { Map&lt;String, Object&gt; block = new HashMap&lt;String, Object&gt;(); block.put(&quot;index&quot;, getChain().size() + 1); block.put(&quot;timestamp&quot;, System.currentTimeMillis()); block.put(&quot;transactions&quot;, getCurrentTransactions()); block.put(&quot;proof&quot;, proof); // 如果没有传递上一个区块的hash就计算出区块链中最后一个区块的hash block.put(&quot;previous_hash&quot;, previous_hash != null ? previous_hash : hash(getChain().get(getChain().size() - 1))); // 重置当前的交易信息列表 setCurrentTransactions(new ArrayList&lt;Map&lt;String, Object&gt;&gt;()); getChain().add(block); return block; } // 创建单例对象 public static BlockChain getInstance() { if (blockChain == null) { synchronized (BlockChain.class) { if (blockChain == null) { blockChain = new BlockChain(); } } } return blockChain; } /** * @return 得到区块链中的最后一个区块 */ public Map&lt;String, Object&gt; lastBlock() { return getChain().get(getChain().size() - 1); } /** * 生成新交易信息，信息将加入到下一个待挖的区块中 * @param sender 发送方的地址 * @param recipient 接收方的地址 * @param amount 交易数量 * @return 返回该交易事务的块的索引 */ public int newTransactions(String sender, String recipient, long amount) { Map&lt;String, Object&gt; transaction = new HashMap&lt;String, Object&gt;(); transaction.put(&quot;sender&quot;, sender); transaction.put(&quot;recipient&quot;, recipient); transaction.put(&quot;amount&quot;, amount); getCurrentTransactions().add(transaction); return (Integer) lastBlock().get(&quot;index&quot;) + 1; } /** * 生成区块的 SHA-256格式的 hash值 * @param block 区块 * @return 返回该区块的hash */ public static Object hash(Map&lt;String, Object&gt; block) { return new Encrypt().Hash(new JSONObject(block).toString()); } /** * 注册节点 * @param address 节点地址 * @throws MalformedURLException */ public void registerNode(String address) throws MalformedURLException { URL url = new URL(address); String node = url.getHost() + &quot;:&quot; + (url.getPort() == -1 ? url.getDefaultPort() : url.getPort()); nodes.add(node); } /** * 验证是否为有效链,遍历每个区块验证hash和proof，来确定一个给定的区块链是否有效 * @param chain * @return */ public boolean vaildChain(List&lt;Map&lt;String,Object&gt;&gt; chain) { Map&lt;String,Object&gt; lastBlock = chain.get(0); int currentBlockIndex = 1; while (currentBlockIndex &lt; lastBlock.size()) { Map&lt;String,Object&gt; currentBlock = chain.get(currentBlockIndex); //检查区块的hash是否正确 if (!currentBlock.get(&quot;previous_hash&quot;).equals(hash(lastBlock))) { return false; } lastBlock = currentBlock; currentBlockIndex ++; } return true; } /** * 使用网络中最长的链. 遍历所有的邻居节点，并用上一个方法检查链的有效性， * 如果发现有效更长链，就替换掉自己的链 * @return 如果链被取代返回true, 否则返回false * @throws IOException */ public boolean resolveConflicts() throws IOException { //获得当前网络上所有的邻居节点 Set&lt;String&gt; neighbours = this.nodes; List&lt;Map&lt;String, Object&gt;&gt; newChain = null; // 寻找最长的区块链0 long maxLength = this.chain.size(); // 获取并验证网络中的所有节点的区块链 for (String node : neighbours) { URL url = new URL(&quot;http://&quot; + node + &quot;/chain&quot;); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.connect(); if (connection.getResponseCode() == 200) { BufferedReader bufferedReader = new BufferedReader( new InputStreamReader(connection.getInputStream(), &quot;utf-8&quot;)); StringBuffer responseData = new StringBuffer(); String response = null; while ((response = bufferedReader.readLine()) != null) { responseData.append(response); } bufferedReader.close(); JSONObject jsonData = new JSONObject(responseData.toString()); long length = jsonData.getLong(&quot;blockLength&quot;); List&lt;Map&lt;String, Object&gt;&gt; chain = (List) jsonData.getJSONArray(&quot;chain&quot;).toList(); // 检查长度是否长，链是否有效 if (length &gt; maxLength &amp;&amp; vaildChain(chain)) { maxLength = length; newChain = chain; } } } // 如果发现一个新的有效链比我们的长，就替换当前的链 if (newChain != null) { this.chain = newChain; return true; } return false; } Proof 类 ，计算工作量证明 /** * 计算当前区块的工作量证明 * @param last_proof 上一个区块的工作量证明 * @return */ public long ProofOfWork(long last_proof){ long proof = 0; while (!(vaildProof(last_proof,proof))) { proof ++; } return proof; } /** * 验证证明，是否拼接后的Hash值以4个0开头 * @param last_proof 上一个区块工作量证明 * @param proof 当前区块的工作量证明 * @return */ public boolean vaildProof(long last_proof, long proof) { String guess = last_proof + &quot;&quot; + proof; String guess_hash = new Encrypt().Hash(guess); boolean flag = guess_hash.startsWith(&quot;0000&quot;); return flag; } Encrypt 类 ，Hash计算工具类 public class Encrypt { /** * 传入字符串，返回 SHA-256 加密字符串 * @param strText * @return */ public String Hash(final String strText) { // 返回值 String strResult = null; // 是否是有效字符串 if (strText != null &amp;&amp; strText.length() &gt; 0) { try { // 创建加密对象，传入要加密类型 MessageDigest messageDigest = MessageDigest.getInstance(&quot;SHA-256&quot;); // 传入要加密的字符串 messageDigest.update(strText.getBytes()); // 执行哈希计算，得到 byte 数组 byte byteBuffer[] = messageDigest.digest(); // 將 byte 数组转换 string 类型 StringBuffer strHexString = new StringBuffer(); // 遍历 byte 数组 for (int i = 0; i &lt; byteBuffer.length; i++) { // 转换成16进制并存储在字符串中 String hex = Integer.toHexString(0xff &amp; byteBuffer[i]); if (hex.length() == 1) { strHexString.append(&#39;0&#39;); } strHexString.append(hex); } // 得到返回結果 strResult = strHexString.toString(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } } return strResult; } } FullChain 类，输出整条链的信息。 /** * @Author: cfx * @Description: 该Servlet用于输出整个区块链的数据(Json) * @Date: Created in 2018/5/9 17:24 */ @WebServlet(&quot;/chain&quot;) public class FullChain extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BlockChain blockChain = BlockChain.getInstance(); Map&lt;String,Object&gt; response = new HashMap&lt;String, Object&gt;(); response.put(&quot;chain&quot;,blockChain.getChain()); response.put(&quot;blockLength&quot;,blockChain.getChain().size()); JSONObject jsonObject = new JSONObject(response); resp.setContentType(&quot;application/json&quot;); PrintWriter printWriter = resp.getWriter(); printWriter.println(jsonObject); printWriter.close(); } } InitialID 类 ，初始化时执行，随机的uuid作为矿工的账户地址。 /** * @Author: cfx * @Description: 初始化时，使用UUID来作为节点ID * @Date: Created in 2018/5/9 17:17 */ @WebListener public class InitialID implements ServletContextListener { public void contextInitialized(ServletContextEvent sce) { ServletContext servletContext = sce.getServletContext(); String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); servletContext.setAttribute(&quot;uuid&quot;, uuid); System.out.println(&quot;uuid is : &quot;+servletContext.getAttribute(&quot;uuid&quot;)); } public void contextDestroyed(ServletContextEvent sce) { } } Register 类 ，节点注册类，记录网络上所有的节点，用户共识算法，保证所有的节点上的账本都是一致的。 /** * @Author: cfx * @Description: 注册网络节点 * @Date: Created in 2018/5/10 11:26 */ @WebServlet(&quot;/nodes/register&quot;) public class Register extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(&quot;utf-8&quot;); // 读取客户端传递过来的数据并转换成JSON格式 BufferedReader reader = req.getReader(); String input = null; StringBuffer requestBody = new StringBuffer(); while ((input = reader.readLine()) != null) { requestBody.append(input); } JSONObject jsonValue = new JSONObject(requestBody.toString()); BlockChain blockChain = BlockChain.getInstance(); blockChain.registerNode(jsonValue.getString(&quot;nodes&quot;)); PrintWriter printWriter = resp.getWriter(); printWriter.println(new JSONObject().append(&quot;message&quot;,&quot;The Nodes is : &quot; + blockChain.getNodes())); printWriter.close(); } } NewTransaction 类，新建交易类。 /** * @Author: cfx * @Description: 该Servlet用于接收并处理新的交易信息 * @Date: Created in 2018/5/9 17:22 */ @WebServlet(&quot;/transactions/new&quot;) public class NewTransaction extends HttpServlet { protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(&quot;utf-8&quot;); // 读取客户端传递过来的数据并转换成JSON格式 BufferedReader reader = req.getReader(); String input = null; StringBuffer requestBody = new StringBuffer(); while ((input = reader.readLine()) != null) { requestBody.append(input); } JSONObject jsonValues = new JSONObject(requestBody.toString()); // 检查所需要的字段是否位于POST的data中 String[] required = { &quot;sender&quot;, &quot;recipient&quot;, &quot;amount&quot; }; for (String string : required) { if (!jsonValues.has(string)) { // 如果没有需要的字段就返回错误信息 resp.sendError(400, &quot;Missing values&quot;); } } // 新建交易信息 BlockChain blockChain = BlockChain.getInstance(); int index = blockChain.newTransactions(jsonValues.getString(&quot;sender&quot;), jsonValues.getString(&quot;recipient&quot;), jsonValues.getLong(&quot;amount&quot;)); // 返回json格式的数据给客户端 resp.setContentType(&quot;application/json&quot;); PrintWriter printWriter = resp.getWriter(); printWriter.println(new JSONObject().append(&quot;message&quot;, &quot;Transaction will be added to Block &quot; + index)); printWriter.close(); } } Mine , 挖矿类。 /** * @Author: cfx * @Description: 该Servlet用于运行工作算法的证明来获得下一个证明，也就是所谓的挖矿 * @Date: Created in 2018/5/9 17:21 */ @WebServlet(&quot;/mine&quot;) public class Mine extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BlockChain blockChain = BlockChain.getInstance(); //计算出工作量证明 Map&lt;String,Object&gt; lastBlock = blockChain.lastBlock(); Long last_proof = Long.parseLong(lastBlock.get(&quot;proof&quot;) + &quot;&quot;); Long proof = new Proof().ProofOfWork(last_proof); //奖励计算出工作量证明的矿工1个币的奖励，发送者为&quot;0&quot;表明这是新挖出的矿。 String uuid = (String) this.getServletContext().getAttribute(&quot;uuid&quot;); blockChain.newTransactions(&quot;0&quot;,uuid,1); //构建新的区块 Map&lt;String,Object&gt; newBlock = blockChain.newBlock(proof,null); Map&lt;String, Object&gt; response = new HashMap&lt;String, Object&gt;(); response.put(&quot;message&quot;, &quot;New Block Forged&quot;); response.put(&quot;index&quot;, newBlock.get(&quot;index&quot;)); response.put(&quot;transactions&quot;, newBlock.get(&quot;transactions&quot;)); response.put(&quot;proof&quot;, newBlock.get(&quot;proof&quot;)); response.put(&quot;previous_hash&quot;, newBlock.get(&quot;previous_hash&quot;)); // 返回新区块的数据给客户端 resp.setContentType(&quot;application/json&quot;); PrintWriter printWriter = resp.getWriter(); printWriter.println(new JSONObject(response)); printWriter.close(); } } Consensus 类 ，通过判断不同节点上链的长度，来找出最长链，这就是一致性共识算法。 /** * @Author: cfx * @Description: 一致性共识算法，解决共识冲突，保证所有的节点都在同一条链上(最长链) * @Date: Created in 2018/5/10 11:38 */ @WebServlet(&quot;/nodes/resolve&quot;) public class Consensus extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BlockChain blockChain = BlockChain.getInstance(); boolean flag = blockChain.resolveConflicts(); System.out.println(&quot;是否解决一致性共识冲突：&quot; + flag); } } 运行结果 以下是本人之前的测试记录： 首次请求/chain: 初始化Blockchain { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;proof&quot;: 100, &quot;transactions&quot;: [], &quot;timestamp&quot;: 1526284543591, &quot;previous_hash&quot;: &quot;0&quot; } ], &quot;chainLenth&quot;: 1 } 请求/nodes/register，进行网络节点的注册。 request: { &quot;nodes&quot;: &quot;http://lcoalhost:8080&quot; } response: {&quot;message&quot;:[&quot;All Nodes are:[lcoalhost:8080]&quot;]} 请求/mine,进行挖矿。 { &quot;index&quot;: 2, &quot;proof&quot;: 35293, &quot;message&quot;: &quot;New Block Forged&quot;, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;previous_hash&quot;: &quot;c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66&quot; } 请求/chain,查看链上所有区块的数据 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;proof&quot;: 100, &quot;transactions&quot;: [], &quot;timestamp&quot;: 1526284543591, &quot;previous_hash&quot;: &quot;0&quot; }, { &quot;index&quot;: 2, &quot;proof&quot;: 35293, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;timestamp&quot;: 1526284661678, &quot;previous_hash&quot;: &quot;c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66&quot; } ], &quot;chainLenth&quot;: 2 } 请求/transactions/new,新建交易。 request: { &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 6 } response: { &quot;message&quot;: [ &quot;Transaction will be added to Block 3&quot; ] } 请求/mine，计算出工作量证明。将上面的交易记录到账本之中。 { &quot;index&quot;: 3, &quot;proof&quot;: 35089, &quot;message&quot;: &quot;New Block Forged&quot;, &quot;transactions&quot;: [ { &quot;amount&quot;: 6, &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot; }, { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;previous_hash&quot;: &quot;a12748a35d57a4a371cefc4a8c294236d69c762d28b889abb2ae34a31d2b7597&quot; } 请求/chain,查看链上所有区块的数据 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;proof&quot;: 100, &quot;transactions&quot;: [], &quot;timestamp&quot;: 1526284543591, &quot;previous_hash&quot;: &quot;0&quot; }, { &quot;index&quot;: 2, &quot;proof&quot;: 35293, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;timestamp&quot;: 1526284661678, &quot;previous_hash&quot;: &quot;c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66&quot; }, { &quot;index&quot;: 3, &quot;proof&quot;: 35089, &quot;transactions&quot;: [ { &quot;amount&quot;: 6, &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot; }, { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;timestamp&quot;: 1526284774452, &quot;previous_hash&quot;: &quot;a12748a35d57a4a371cefc4a8c294236d69c762d28b889abb2ae34a31d2b7597&quot; } ], &quot;chainLenth&quot;: 3 } 存在的问题 有一个问题没有解决，就是我们启动多实例来模拟不同的网络节点时，并不能解决节点加入同一个Set的问题，也就是说根本无法通过节点本身来获得其他网络节点，进而判断最长链。所以/nodes/resolve请求暂时时无用的。期间也有想方法解决，比如通过所谓的“第三方”–数据库，当一个节点注册时，保存到数据库中；当第二个节点加入时，也加入到数据库中…当需要请求解决一致性算法时，去数据库中读取节点信息遍历即可。但是，自己没有去实现。这是我的想法，毕竟是两个不相干的实例。如果有朋友有其他的解决方案，请一定要告诉我！谢谢。 总结 通过简单的Demo实现区块链，当然其中简化了大量的实现细节，所以说其实并没有多少实际参考价值。但是意义在于，能帮助我们更容易的理解区块链，为之后的学习打下夯实的基础。 项目源码 Java从零开始创建区块链Demo 参考文章 https://learnblockchain.cn/2017/11/04/bitcoin-pow/ http://blog.51cto.com/zero01/2086195等。 阅读更多 登录后自动展开" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/qq_33764491/article/details/80330542 前言 为了更好的理解区块链的底层实现原理，决定自己动手模拟实现一条区块链。 思路分析 通过之前的学习，从文本知识的角度，我们知道，创世区块、记账原理、挖矿原理、工作量证明、共识机制等等区块链的相关知识。 创建一条区块链，首先默认构造创世区块。在此基础上，我们可以发布交易，并进行挖矿，计算出工作量证明，将交易记录到区块中，每成功的挖一次矿，块高就+1。当然在此过程中，可能会出现“造假”的问题。也就是说，每一个新注册的节点，都可以有自己的链。这些链长短不一，为了保证账本的一致性，需要通过一种一致性共识算法来找到最长的链，作为样本，同步数据，保证每个节点上的账本信息都是一致的。 数据结构 区块链 如图所示，索引为1的区块即为创始区块。可想而知，可以用List&lt;区块&gt;来表示区块链。其中，区块链的高度即为链上区块的块数，上图区块高度为4。 区块 单个区块的数据结构有索引、交易列表、时间戳、工作量证明、上一个区块的hash组成。 交易列表 整个区块链就是一个超级大的分布式账本，当发生交易时，矿工们通过计算工作量证明的方法来进行挖矿(本文中挖到矿将得到1个币的奖励)，将发生的交易记录到账本之中。 Web API 我们将通过Postman来模拟请求。请求API如下： /nodes/register 注册网络节点 /nodes/resolve 一致性共识算法 /transactions/new 新建交易 /mine 挖矿 /chain 输出整条链的数据 项目目录结构 Gradle Web 项目 dependencies { compile(&#39;javax:javaee-api:7.0&#39;) compile(&#39;org.json:json:20160810&#39;) testCompile(&#39;junit:junit:4.12&#39;) } 实现代码 注释写的很详细，如果遇到不懂的地方，欢迎大家一同讨论。 BlockChain类 ，所有的核心代码都在其中。 // 存储区块链 private List&lt;Map&lt;String, Object&gt;&gt; chain; // 该实例变量用于当前的交易信息列表 private List&lt;Map&lt;String, Object&gt;&gt; currentTransactions; // 网络中所有节点的集合 private Set&lt;String&gt; nodes; private static BlockChain blockChain = null; private BlockChain() { // 初始化区块链以及当前的交易信息列表 chain = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); currentTransactions = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); // 初始化存储网络中其他节点的集合 nodes = new HashSet&lt;String&gt;(); // 创建创世区块 newBlock(100, &quot;0&quot;); } /** * 在区块链上新建一个区块 * @param proof 新区块的工作量证明 * @param previous_hash 上一个区块的hash值 * @return 返回新建的区块 */ public Map&lt;String, Object&gt; newBlock(long proof, String previous_hash) { Map&lt;String, Object&gt; block = new HashMap&lt;String, Object&gt;(); block.put(&quot;index&quot;, getChain().size() + 1); block.put(&quot;timestamp&quot;, System.currentTimeMillis()); block.put(&quot;transactions&quot;, getCurrentTransactions()); block.put(&quot;proof&quot;, proof); // 如果没有传递上一个区块的hash就计算出区块链中最后一个区块的hash block.put(&quot;previous_hash&quot;, previous_hash != null ? previous_hash : hash(getChain().get(getChain().size() - 1))); // 重置当前的交易信息列表 setCurrentTransactions(new ArrayList&lt;Map&lt;String, Object&gt;&gt;()); getChain().add(block); return block; } // 创建单例对象 public static BlockChain getInstance() { if (blockChain == null) { synchronized (BlockChain.class) { if (blockChain == null) { blockChain = new BlockChain(); } } } return blockChain; } /** * @return 得到区块链中的最后一个区块 */ public Map&lt;String, Object&gt; lastBlock() { return getChain().get(getChain().size() - 1); } /** * 生成新交易信息，信息将加入到下一个待挖的区块中 * @param sender 发送方的地址 * @param recipient 接收方的地址 * @param amount 交易数量 * @return 返回该交易事务的块的索引 */ public int newTransactions(String sender, String recipient, long amount) { Map&lt;String, Object&gt; transaction = new HashMap&lt;String, Object&gt;(); transaction.put(&quot;sender&quot;, sender); transaction.put(&quot;recipient&quot;, recipient); transaction.put(&quot;amount&quot;, amount); getCurrentTransactions().add(transaction); return (Integer) lastBlock().get(&quot;index&quot;) + 1; } /** * 生成区块的 SHA-256格式的 hash值 * @param block 区块 * @return 返回该区块的hash */ public static Object hash(Map&lt;String, Object&gt; block) { return new Encrypt().Hash(new JSONObject(block).toString()); } /** * 注册节点 * @param address 节点地址 * @throws MalformedURLException */ public void registerNode(String address) throws MalformedURLException { URL url = new URL(address); String node = url.getHost() + &quot;:&quot; + (url.getPort() == -1 ? url.getDefaultPort() : url.getPort()); nodes.add(node); } /** * 验证是否为有效链,遍历每个区块验证hash和proof，来确定一个给定的区块链是否有效 * @param chain * @return */ public boolean vaildChain(List&lt;Map&lt;String,Object&gt;&gt; chain) { Map&lt;String,Object&gt; lastBlock = chain.get(0); int currentBlockIndex = 1; while (currentBlockIndex &lt; lastBlock.size()) { Map&lt;String,Object&gt; currentBlock = chain.get(currentBlockIndex); //检查区块的hash是否正确 if (!currentBlock.get(&quot;previous_hash&quot;).equals(hash(lastBlock))) { return false; } lastBlock = currentBlock; currentBlockIndex ++; } return true; } /** * 使用网络中最长的链. 遍历所有的邻居节点，并用上一个方法检查链的有效性， * 如果发现有效更长链，就替换掉自己的链 * @return 如果链被取代返回true, 否则返回false * @throws IOException */ public boolean resolveConflicts() throws IOException { //获得当前网络上所有的邻居节点 Set&lt;String&gt; neighbours = this.nodes; List&lt;Map&lt;String, Object&gt;&gt; newChain = null; // 寻找最长的区块链0 long maxLength = this.chain.size(); // 获取并验证网络中的所有节点的区块链 for (String node : neighbours) { URL url = new URL(&quot;http://&quot; + node + &quot;/chain&quot;); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.connect(); if (connection.getResponseCode() == 200) { BufferedReader bufferedReader = new BufferedReader( new InputStreamReader(connection.getInputStream(), &quot;utf-8&quot;)); StringBuffer responseData = new StringBuffer(); String response = null; while ((response = bufferedReader.readLine()) != null) { responseData.append(response); } bufferedReader.close(); JSONObject jsonData = new JSONObject(responseData.toString()); long length = jsonData.getLong(&quot;blockLength&quot;); List&lt;Map&lt;String, Object&gt;&gt; chain = (List) jsonData.getJSONArray(&quot;chain&quot;).toList(); // 检查长度是否长，链是否有效 if (length &gt; maxLength &amp;&amp; vaildChain(chain)) { maxLength = length; newChain = chain; } } } // 如果发现一个新的有效链比我们的长，就替换当前的链 if (newChain != null) { this.chain = newChain; return true; } return false; } Proof 类 ，计算工作量证明 /** * 计算当前区块的工作量证明 * @param last_proof 上一个区块的工作量证明 * @return */ public long ProofOfWork(long last_proof){ long proof = 0; while (!(vaildProof(last_proof,proof))) { proof ++; } return proof; } /** * 验证证明，是否拼接后的Hash值以4个0开头 * @param last_proof 上一个区块工作量证明 * @param proof 当前区块的工作量证明 * @return */ public boolean vaildProof(long last_proof, long proof) { String guess = last_proof + &quot;&quot; + proof; String guess_hash = new Encrypt().Hash(guess); boolean flag = guess_hash.startsWith(&quot;0000&quot;); return flag; } Encrypt 类 ，Hash计算工具类 public class Encrypt { /** * 传入字符串，返回 SHA-256 加密字符串 * @param strText * @return */ public String Hash(final String strText) { // 返回值 String strResult = null; // 是否是有效字符串 if (strText != null &amp;&amp; strText.length() &gt; 0) { try { // 创建加密对象，传入要加密类型 MessageDigest messageDigest = MessageDigest.getInstance(&quot;SHA-256&quot;); // 传入要加密的字符串 messageDigest.update(strText.getBytes()); // 执行哈希计算，得到 byte 数组 byte byteBuffer[] = messageDigest.digest(); // 將 byte 数组转换 string 类型 StringBuffer strHexString = new StringBuffer(); // 遍历 byte 数组 for (int i = 0; i &lt; byteBuffer.length; i++) { // 转换成16进制并存储在字符串中 String hex = Integer.toHexString(0xff &amp; byteBuffer[i]); if (hex.length() == 1) { strHexString.append(&#39;0&#39;); } strHexString.append(hex); } // 得到返回結果 strResult = strHexString.toString(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } } return strResult; } } FullChain 类，输出整条链的信息。 /** * @Author: cfx * @Description: 该Servlet用于输出整个区块链的数据(Json) * @Date: Created in 2018/5/9 17:24 */ @WebServlet(&quot;/chain&quot;) public class FullChain extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BlockChain blockChain = BlockChain.getInstance(); Map&lt;String,Object&gt; response = new HashMap&lt;String, Object&gt;(); response.put(&quot;chain&quot;,blockChain.getChain()); response.put(&quot;blockLength&quot;,blockChain.getChain().size()); JSONObject jsonObject = new JSONObject(response); resp.setContentType(&quot;application/json&quot;); PrintWriter printWriter = resp.getWriter(); printWriter.println(jsonObject); printWriter.close(); } } InitialID 类 ，初始化时执行，随机的uuid作为矿工的账户地址。 /** * @Author: cfx * @Description: 初始化时，使用UUID来作为节点ID * @Date: Created in 2018/5/9 17:17 */ @WebListener public class InitialID implements ServletContextListener { public void contextInitialized(ServletContextEvent sce) { ServletContext servletContext = sce.getServletContext(); String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); servletContext.setAttribute(&quot;uuid&quot;, uuid); System.out.println(&quot;uuid is : &quot;+servletContext.getAttribute(&quot;uuid&quot;)); } public void contextDestroyed(ServletContextEvent sce) { } } Register 类 ，节点注册类，记录网络上所有的节点，用户共识算法，保证所有的节点上的账本都是一致的。 /** * @Author: cfx * @Description: 注册网络节点 * @Date: Created in 2018/5/10 11:26 */ @WebServlet(&quot;/nodes/register&quot;) public class Register extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(&quot;utf-8&quot;); // 读取客户端传递过来的数据并转换成JSON格式 BufferedReader reader = req.getReader(); String input = null; StringBuffer requestBody = new StringBuffer(); while ((input = reader.readLine()) != null) { requestBody.append(input); } JSONObject jsonValue = new JSONObject(requestBody.toString()); BlockChain blockChain = BlockChain.getInstance(); blockChain.registerNode(jsonValue.getString(&quot;nodes&quot;)); PrintWriter printWriter = resp.getWriter(); printWriter.println(new JSONObject().append(&quot;message&quot;,&quot;The Nodes is : &quot; + blockChain.getNodes())); printWriter.close(); } } NewTransaction 类，新建交易类。 /** * @Author: cfx * @Description: 该Servlet用于接收并处理新的交易信息 * @Date: Created in 2018/5/9 17:22 */ @WebServlet(&quot;/transactions/new&quot;) public class NewTransaction extends HttpServlet { protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(&quot;utf-8&quot;); // 读取客户端传递过来的数据并转换成JSON格式 BufferedReader reader = req.getReader(); String input = null; StringBuffer requestBody = new StringBuffer(); while ((input = reader.readLine()) != null) { requestBody.append(input); } JSONObject jsonValues = new JSONObject(requestBody.toString()); // 检查所需要的字段是否位于POST的data中 String[] required = { &quot;sender&quot;, &quot;recipient&quot;, &quot;amount&quot; }; for (String string : required) { if (!jsonValues.has(string)) { // 如果没有需要的字段就返回错误信息 resp.sendError(400, &quot;Missing values&quot;); } } // 新建交易信息 BlockChain blockChain = BlockChain.getInstance(); int index = blockChain.newTransactions(jsonValues.getString(&quot;sender&quot;), jsonValues.getString(&quot;recipient&quot;), jsonValues.getLong(&quot;amount&quot;)); // 返回json格式的数据给客户端 resp.setContentType(&quot;application/json&quot;); PrintWriter printWriter = resp.getWriter(); printWriter.println(new JSONObject().append(&quot;message&quot;, &quot;Transaction will be added to Block &quot; + index)); printWriter.close(); } } Mine , 挖矿类。 /** * @Author: cfx * @Description: 该Servlet用于运行工作算法的证明来获得下一个证明，也就是所谓的挖矿 * @Date: Created in 2018/5/9 17:21 */ @WebServlet(&quot;/mine&quot;) public class Mine extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BlockChain blockChain = BlockChain.getInstance(); //计算出工作量证明 Map&lt;String,Object&gt; lastBlock = blockChain.lastBlock(); Long last_proof = Long.parseLong(lastBlock.get(&quot;proof&quot;) + &quot;&quot;); Long proof = new Proof().ProofOfWork(last_proof); //奖励计算出工作量证明的矿工1个币的奖励，发送者为&quot;0&quot;表明这是新挖出的矿。 String uuid = (String) this.getServletContext().getAttribute(&quot;uuid&quot;); blockChain.newTransactions(&quot;0&quot;,uuid,1); //构建新的区块 Map&lt;String,Object&gt; newBlock = blockChain.newBlock(proof,null); Map&lt;String, Object&gt; response = new HashMap&lt;String, Object&gt;(); response.put(&quot;message&quot;, &quot;New Block Forged&quot;); response.put(&quot;index&quot;, newBlock.get(&quot;index&quot;)); response.put(&quot;transactions&quot;, newBlock.get(&quot;transactions&quot;)); response.put(&quot;proof&quot;, newBlock.get(&quot;proof&quot;)); response.put(&quot;previous_hash&quot;, newBlock.get(&quot;previous_hash&quot;)); // 返回新区块的数据给客户端 resp.setContentType(&quot;application/json&quot;); PrintWriter printWriter = resp.getWriter(); printWriter.println(new JSONObject(response)); printWriter.close(); } } Consensus 类 ，通过判断不同节点上链的长度，来找出最长链，这就是一致性共识算法。 /** * @Author: cfx * @Description: 一致性共识算法，解决共识冲突，保证所有的节点都在同一条链上(最长链) * @Date: Created in 2018/5/10 11:38 */ @WebServlet(&quot;/nodes/resolve&quot;) public class Consensus extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BlockChain blockChain = BlockChain.getInstance(); boolean flag = blockChain.resolveConflicts(); System.out.println(&quot;是否解决一致性共识冲突：&quot; + flag); } } 运行结果 以下是本人之前的测试记录： 首次请求/chain: 初始化Blockchain { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;proof&quot;: 100, &quot;transactions&quot;: [], &quot;timestamp&quot;: 1526284543591, &quot;previous_hash&quot;: &quot;0&quot; } ], &quot;chainLenth&quot;: 1 } 请求/nodes/register，进行网络节点的注册。 request: { &quot;nodes&quot;: &quot;http://lcoalhost:8080&quot; } response: {&quot;message&quot;:[&quot;All Nodes are:[lcoalhost:8080]&quot;]} 请求/mine,进行挖矿。 { &quot;index&quot;: 2, &quot;proof&quot;: 35293, &quot;message&quot;: &quot;New Block Forged&quot;, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;previous_hash&quot;: &quot;c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66&quot; } 请求/chain,查看链上所有区块的数据 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;proof&quot;: 100, &quot;transactions&quot;: [], &quot;timestamp&quot;: 1526284543591, &quot;previous_hash&quot;: &quot;0&quot; }, { &quot;index&quot;: 2, &quot;proof&quot;: 35293, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;timestamp&quot;: 1526284661678, &quot;previous_hash&quot;: &quot;c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66&quot; } ], &quot;chainLenth&quot;: 2 } 请求/transactions/new,新建交易。 request: { &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 6 } response: { &quot;message&quot;: [ &quot;Transaction will be added to Block 3&quot; ] } 请求/mine，计算出工作量证明。将上面的交易记录到账本之中。 { &quot;index&quot;: 3, &quot;proof&quot;: 35089, &quot;message&quot;: &quot;New Block Forged&quot;, &quot;transactions&quot;: [ { &quot;amount&quot;: 6, &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot; }, { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;previous_hash&quot;: &quot;a12748a35d57a4a371cefc4a8c294236d69c762d28b889abb2ae34a31d2b7597&quot; } 请求/chain,查看链上所有区块的数据 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;proof&quot;: 100, &quot;transactions&quot;: [], &quot;timestamp&quot;: 1526284543591, &quot;previous_hash&quot;: &quot;0&quot; }, { &quot;index&quot;: 2, &quot;proof&quot;: 35293, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;timestamp&quot;: 1526284661678, &quot;previous_hash&quot;: &quot;c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66&quot; }, { &quot;index&quot;: 3, &quot;proof&quot;: 35089, &quot;transactions&quot;: [ { &quot;amount&quot;: 6, &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot; }, { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;timestamp&quot;: 1526284774452, &quot;previous_hash&quot;: &quot;a12748a35d57a4a371cefc4a8c294236d69c762d28b889abb2ae34a31d2b7597&quot; } ], &quot;chainLenth&quot;: 3 } 存在的问题 有一个问题没有解决，就是我们启动多实例来模拟不同的网络节点时，并不能解决节点加入同一个Set的问题，也就是说根本无法通过节点本身来获得其他网络节点，进而判断最长链。所以/nodes/resolve请求暂时时无用的。期间也有想方法解决，比如通过所谓的“第三方”–数据库，当一个节点注册时，保存到数据库中；当第二个节点加入时，也加入到数据库中…当需要请求解决一致性算法时，去数据库中读取节点信息遍历即可。但是，自己没有去实现。这是我的想法，毕竟是两个不相干的实例。如果有朋友有其他的解决方案，请一定要告诉我！谢谢。 总结 通过简单的Demo实现区块链，当然其中简化了大量的实现细节，所以说其实并没有多少实际参考价值。但是意义在于，能帮助我们更容易的理解区块链，为之后的学习打下夯实的基础。 项目源码 Java从零开始创建区块链Demo 参考文章 https://learnblockchain.cn/2017/11/04/bitcoin-pow/ http://blog.51cto.com/zero01/2086195等。 阅读更多 登录后自动展开" />
<link rel="canonical" href="https://mlh.app/2018/05/15/80bee7aeb95b759f85ddc63cee2ee499.html" />
<meta property="og:url" content="https://mlh.app/2018/05/15/80bee7aeb95b759f85ddc63cee2ee499.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-15T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/qq_33764491/article/details/80330542 前言 为了更好的理解区块链的底层实现原理，决定自己动手模拟实现一条区块链。 思路分析 通过之前的学习，从文本知识的角度，我们知道，创世区块、记账原理、挖矿原理、工作量证明、共识机制等等区块链的相关知识。 创建一条区块链，首先默认构造创世区块。在此基础上，我们可以发布交易，并进行挖矿，计算出工作量证明，将交易记录到区块中，每成功的挖一次矿，块高就+1。当然在此过程中，可能会出现“造假”的问题。也就是说，每一个新注册的节点，都可以有自己的链。这些链长短不一，为了保证账本的一致性，需要通过一种一致性共识算法来找到最长的链，作为样本，同步数据，保证每个节点上的账本信息都是一致的。 数据结构 区块链 如图所示，索引为1的区块即为创始区块。可想而知，可以用List&lt;区块&gt;来表示区块链。其中，区块链的高度即为链上区块的块数，上图区块高度为4。 区块 单个区块的数据结构有索引、交易列表、时间戳、工作量证明、上一个区块的hash组成。 交易列表 整个区块链就是一个超级大的分布式账本，当发生交易时，矿工们通过计算工作量证明的方法来进行挖矿(本文中挖到矿将得到1个币的奖励)，将发生的交易记录到账本之中。 Web API 我们将通过Postman来模拟请求。请求API如下： /nodes/register 注册网络节点 /nodes/resolve 一致性共识算法 /transactions/new 新建交易 /mine 挖矿 /chain 输出整条链的数据 项目目录结构 Gradle Web 项目 dependencies { compile(&#39;javax:javaee-api:7.0&#39;) compile(&#39;org.json:json:20160810&#39;) testCompile(&#39;junit:junit:4.12&#39;) } 实现代码 注释写的很详细，如果遇到不懂的地方，欢迎大家一同讨论。 BlockChain类 ，所有的核心代码都在其中。 // 存储区块链 private List&lt;Map&lt;String, Object&gt;&gt; chain; // 该实例变量用于当前的交易信息列表 private List&lt;Map&lt;String, Object&gt;&gt; currentTransactions; // 网络中所有节点的集合 private Set&lt;String&gt; nodes; private static BlockChain blockChain = null; private BlockChain() { // 初始化区块链以及当前的交易信息列表 chain = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); currentTransactions = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); // 初始化存储网络中其他节点的集合 nodes = new HashSet&lt;String&gt;(); // 创建创世区块 newBlock(100, &quot;0&quot;); } /** * 在区块链上新建一个区块 * @param proof 新区块的工作量证明 * @param previous_hash 上一个区块的hash值 * @return 返回新建的区块 */ public Map&lt;String, Object&gt; newBlock(long proof, String previous_hash) { Map&lt;String, Object&gt; block = new HashMap&lt;String, Object&gt;(); block.put(&quot;index&quot;, getChain().size() + 1); block.put(&quot;timestamp&quot;, System.currentTimeMillis()); block.put(&quot;transactions&quot;, getCurrentTransactions()); block.put(&quot;proof&quot;, proof); // 如果没有传递上一个区块的hash就计算出区块链中最后一个区块的hash block.put(&quot;previous_hash&quot;, previous_hash != null ? previous_hash : hash(getChain().get(getChain().size() - 1))); // 重置当前的交易信息列表 setCurrentTransactions(new ArrayList&lt;Map&lt;String, Object&gt;&gt;()); getChain().add(block); return block; } // 创建单例对象 public static BlockChain getInstance() { if (blockChain == null) { synchronized (BlockChain.class) { if (blockChain == null) { blockChain = new BlockChain(); } } } return blockChain; } /** * @return 得到区块链中的最后一个区块 */ public Map&lt;String, Object&gt; lastBlock() { return getChain().get(getChain().size() - 1); } /** * 生成新交易信息，信息将加入到下一个待挖的区块中 * @param sender 发送方的地址 * @param recipient 接收方的地址 * @param amount 交易数量 * @return 返回该交易事务的块的索引 */ public int newTransactions(String sender, String recipient, long amount) { Map&lt;String, Object&gt; transaction = new HashMap&lt;String, Object&gt;(); transaction.put(&quot;sender&quot;, sender); transaction.put(&quot;recipient&quot;, recipient); transaction.put(&quot;amount&quot;, amount); getCurrentTransactions().add(transaction); return (Integer) lastBlock().get(&quot;index&quot;) + 1; } /** * 生成区块的 SHA-256格式的 hash值 * @param block 区块 * @return 返回该区块的hash */ public static Object hash(Map&lt;String, Object&gt; block) { return new Encrypt().Hash(new JSONObject(block).toString()); } /** * 注册节点 * @param address 节点地址 * @throws MalformedURLException */ public void registerNode(String address) throws MalformedURLException { URL url = new URL(address); String node = url.getHost() + &quot;:&quot; + (url.getPort() == -1 ? url.getDefaultPort() : url.getPort()); nodes.add(node); } /** * 验证是否为有效链,遍历每个区块验证hash和proof，来确定一个给定的区块链是否有效 * @param chain * @return */ public boolean vaildChain(List&lt;Map&lt;String,Object&gt;&gt; chain) { Map&lt;String,Object&gt; lastBlock = chain.get(0); int currentBlockIndex = 1; while (currentBlockIndex &lt; lastBlock.size()) { Map&lt;String,Object&gt; currentBlock = chain.get(currentBlockIndex); //检查区块的hash是否正确 if (!currentBlock.get(&quot;previous_hash&quot;).equals(hash(lastBlock))) { return false; } lastBlock = currentBlock; currentBlockIndex ++; } return true; } /** * 使用网络中最长的链. 遍历所有的邻居节点，并用上一个方法检查链的有效性， * 如果发现有效更长链，就替换掉自己的链 * @return 如果链被取代返回true, 否则返回false * @throws IOException */ public boolean resolveConflicts() throws IOException { //获得当前网络上所有的邻居节点 Set&lt;String&gt; neighbours = this.nodes; List&lt;Map&lt;String, Object&gt;&gt; newChain = null; // 寻找最长的区块链0 long maxLength = this.chain.size(); // 获取并验证网络中的所有节点的区块链 for (String node : neighbours) { URL url = new URL(&quot;http://&quot; + node + &quot;/chain&quot;); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.connect(); if (connection.getResponseCode() == 200) { BufferedReader bufferedReader = new BufferedReader( new InputStreamReader(connection.getInputStream(), &quot;utf-8&quot;)); StringBuffer responseData = new StringBuffer(); String response = null; while ((response = bufferedReader.readLine()) != null) { responseData.append(response); } bufferedReader.close(); JSONObject jsonData = new JSONObject(responseData.toString()); long length = jsonData.getLong(&quot;blockLength&quot;); List&lt;Map&lt;String, Object&gt;&gt; chain = (List) jsonData.getJSONArray(&quot;chain&quot;).toList(); // 检查长度是否长，链是否有效 if (length &gt; maxLength &amp;&amp; vaildChain(chain)) { maxLength = length; newChain = chain; } } } // 如果发现一个新的有效链比我们的长，就替换当前的链 if (newChain != null) { this.chain = newChain; return true; } return false; } Proof 类 ，计算工作量证明 /** * 计算当前区块的工作量证明 * @param last_proof 上一个区块的工作量证明 * @return */ public long ProofOfWork(long last_proof){ long proof = 0; while (!(vaildProof(last_proof,proof))) { proof ++; } return proof; } /** * 验证证明，是否拼接后的Hash值以4个0开头 * @param last_proof 上一个区块工作量证明 * @param proof 当前区块的工作量证明 * @return */ public boolean vaildProof(long last_proof, long proof) { String guess = last_proof + &quot;&quot; + proof; String guess_hash = new Encrypt().Hash(guess); boolean flag = guess_hash.startsWith(&quot;0000&quot;); return flag; } Encrypt 类 ，Hash计算工具类 public class Encrypt { /** * 传入字符串，返回 SHA-256 加密字符串 * @param strText * @return */ public String Hash(final String strText) { // 返回值 String strResult = null; // 是否是有效字符串 if (strText != null &amp;&amp; strText.length() &gt; 0) { try { // 创建加密对象，传入要加密类型 MessageDigest messageDigest = MessageDigest.getInstance(&quot;SHA-256&quot;); // 传入要加密的字符串 messageDigest.update(strText.getBytes()); // 执行哈希计算，得到 byte 数组 byte byteBuffer[] = messageDigest.digest(); // 將 byte 数组转换 string 类型 StringBuffer strHexString = new StringBuffer(); // 遍历 byte 数组 for (int i = 0; i &lt; byteBuffer.length; i++) { // 转换成16进制并存储在字符串中 String hex = Integer.toHexString(0xff &amp; byteBuffer[i]); if (hex.length() == 1) { strHexString.append(&#39;0&#39;); } strHexString.append(hex); } // 得到返回結果 strResult = strHexString.toString(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } } return strResult; } } FullChain 类，输出整条链的信息。 /** * @Author: cfx * @Description: 该Servlet用于输出整个区块链的数据(Json) * @Date: Created in 2018/5/9 17:24 */ @WebServlet(&quot;/chain&quot;) public class FullChain extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BlockChain blockChain = BlockChain.getInstance(); Map&lt;String,Object&gt; response = new HashMap&lt;String, Object&gt;(); response.put(&quot;chain&quot;,blockChain.getChain()); response.put(&quot;blockLength&quot;,blockChain.getChain().size()); JSONObject jsonObject = new JSONObject(response); resp.setContentType(&quot;application/json&quot;); PrintWriter printWriter = resp.getWriter(); printWriter.println(jsonObject); printWriter.close(); } } InitialID 类 ，初始化时执行，随机的uuid作为矿工的账户地址。 /** * @Author: cfx * @Description: 初始化时，使用UUID来作为节点ID * @Date: Created in 2018/5/9 17:17 */ @WebListener public class InitialID implements ServletContextListener { public void contextInitialized(ServletContextEvent sce) { ServletContext servletContext = sce.getServletContext(); String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); servletContext.setAttribute(&quot;uuid&quot;, uuid); System.out.println(&quot;uuid is : &quot;+servletContext.getAttribute(&quot;uuid&quot;)); } public void contextDestroyed(ServletContextEvent sce) { } } Register 类 ，节点注册类，记录网络上所有的节点，用户共识算法，保证所有的节点上的账本都是一致的。 /** * @Author: cfx * @Description: 注册网络节点 * @Date: Created in 2018/5/10 11:26 */ @WebServlet(&quot;/nodes/register&quot;) public class Register extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(&quot;utf-8&quot;); // 读取客户端传递过来的数据并转换成JSON格式 BufferedReader reader = req.getReader(); String input = null; StringBuffer requestBody = new StringBuffer(); while ((input = reader.readLine()) != null) { requestBody.append(input); } JSONObject jsonValue = new JSONObject(requestBody.toString()); BlockChain blockChain = BlockChain.getInstance(); blockChain.registerNode(jsonValue.getString(&quot;nodes&quot;)); PrintWriter printWriter = resp.getWriter(); printWriter.println(new JSONObject().append(&quot;message&quot;,&quot;The Nodes is : &quot; + blockChain.getNodes())); printWriter.close(); } } NewTransaction 类，新建交易类。 /** * @Author: cfx * @Description: 该Servlet用于接收并处理新的交易信息 * @Date: Created in 2018/5/9 17:22 */ @WebServlet(&quot;/transactions/new&quot;) public class NewTransaction extends HttpServlet { protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(&quot;utf-8&quot;); // 读取客户端传递过来的数据并转换成JSON格式 BufferedReader reader = req.getReader(); String input = null; StringBuffer requestBody = new StringBuffer(); while ((input = reader.readLine()) != null) { requestBody.append(input); } JSONObject jsonValues = new JSONObject(requestBody.toString()); // 检查所需要的字段是否位于POST的data中 String[] required = { &quot;sender&quot;, &quot;recipient&quot;, &quot;amount&quot; }; for (String string : required) { if (!jsonValues.has(string)) { // 如果没有需要的字段就返回错误信息 resp.sendError(400, &quot;Missing values&quot;); } } // 新建交易信息 BlockChain blockChain = BlockChain.getInstance(); int index = blockChain.newTransactions(jsonValues.getString(&quot;sender&quot;), jsonValues.getString(&quot;recipient&quot;), jsonValues.getLong(&quot;amount&quot;)); // 返回json格式的数据给客户端 resp.setContentType(&quot;application/json&quot;); PrintWriter printWriter = resp.getWriter(); printWriter.println(new JSONObject().append(&quot;message&quot;, &quot;Transaction will be added to Block &quot; + index)); printWriter.close(); } } Mine , 挖矿类。 /** * @Author: cfx * @Description: 该Servlet用于运行工作算法的证明来获得下一个证明，也就是所谓的挖矿 * @Date: Created in 2018/5/9 17:21 */ @WebServlet(&quot;/mine&quot;) public class Mine extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BlockChain blockChain = BlockChain.getInstance(); //计算出工作量证明 Map&lt;String,Object&gt; lastBlock = blockChain.lastBlock(); Long last_proof = Long.parseLong(lastBlock.get(&quot;proof&quot;) + &quot;&quot;); Long proof = new Proof().ProofOfWork(last_proof); //奖励计算出工作量证明的矿工1个币的奖励，发送者为&quot;0&quot;表明这是新挖出的矿。 String uuid = (String) this.getServletContext().getAttribute(&quot;uuid&quot;); blockChain.newTransactions(&quot;0&quot;,uuid,1); //构建新的区块 Map&lt;String,Object&gt; newBlock = blockChain.newBlock(proof,null); Map&lt;String, Object&gt; response = new HashMap&lt;String, Object&gt;(); response.put(&quot;message&quot;, &quot;New Block Forged&quot;); response.put(&quot;index&quot;, newBlock.get(&quot;index&quot;)); response.put(&quot;transactions&quot;, newBlock.get(&quot;transactions&quot;)); response.put(&quot;proof&quot;, newBlock.get(&quot;proof&quot;)); response.put(&quot;previous_hash&quot;, newBlock.get(&quot;previous_hash&quot;)); // 返回新区块的数据给客户端 resp.setContentType(&quot;application/json&quot;); PrintWriter printWriter = resp.getWriter(); printWriter.println(new JSONObject(response)); printWriter.close(); } } Consensus 类 ，通过判断不同节点上链的长度，来找出最长链，这就是一致性共识算法。 /** * @Author: cfx * @Description: 一致性共识算法，解决共识冲突，保证所有的节点都在同一条链上(最长链) * @Date: Created in 2018/5/10 11:38 */ @WebServlet(&quot;/nodes/resolve&quot;) public class Consensus extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BlockChain blockChain = BlockChain.getInstance(); boolean flag = blockChain.resolveConflicts(); System.out.println(&quot;是否解决一致性共识冲突：&quot; + flag); } } 运行结果 以下是本人之前的测试记录： 首次请求/chain: 初始化Blockchain { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;proof&quot;: 100, &quot;transactions&quot;: [], &quot;timestamp&quot;: 1526284543591, &quot;previous_hash&quot;: &quot;0&quot; } ], &quot;chainLenth&quot;: 1 } 请求/nodes/register，进行网络节点的注册。 request: { &quot;nodes&quot;: &quot;http://lcoalhost:8080&quot; } response: {&quot;message&quot;:[&quot;All Nodes are:[lcoalhost:8080]&quot;]} 请求/mine,进行挖矿。 { &quot;index&quot;: 2, &quot;proof&quot;: 35293, &quot;message&quot;: &quot;New Block Forged&quot;, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;previous_hash&quot;: &quot;c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66&quot; } 请求/chain,查看链上所有区块的数据 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;proof&quot;: 100, &quot;transactions&quot;: [], &quot;timestamp&quot;: 1526284543591, &quot;previous_hash&quot;: &quot;0&quot; }, { &quot;index&quot;: 2, &quot;proof&quot;: 35293, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;timestamp&quot;: 1526284661678, &quot;previous_hash&quot;: &quot;c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66&quot; } ], &quot;chainLenth&quot;: 2 } 请求/transactions/new,新建交易。 request: { &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 6 } response: { &quot;message&quot;: [ &quot;Transaction will be added to Block 3&quot; ] } 请求/mine，计算出工作量证明。将上面的交易记录到账本之中。 { &quot;index&quot;: 3, &quot;proof&quot;: 35089, &quot;message&quot;: &quot;New Block Forged&quot;, &quot;transactions&quot;: [ { &quot;amount&quot;: 6, &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot; }, { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;previous_hash&quot;: &quot;a12748a35d57a4a371cefc4a8c294236d69c762d28b889abb2ae34a31d2b7597&quot; } 请求/chain,查看链上所有区块的数据 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;proof&quot;: 100, &quot;transactions&quot;: [], &quot;timestamp&quot;: 1526284543591, &quot;previous_hash&quot;: &quot;0&quot; }, { &quot;index&quot;: 2, &quot;proof&quot;: 35293, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;timestamp&quot;: 1526284661678, &quot;previous_hash&quot;: &quot;c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66&quot; }, { &quot;index&quot;: 3, &quot;proof&quot;: 35089, &quot;transactions&quot;: [ { &quot;amount&quot;: 6, &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot; }, { &quot;amount&quot;: 1, &quot;sender&quot;: &quot;0&quot;, &quot;recipient&quot;: &quot;e91467fe51bd43b8ad7892b3bc09bd4e&quot; } ], &quot;timestamp&quot;: 1526284774452, &quot;previous_hash&quot;: &quot;a12748a35d57a4a371cefc4a8c294236d69c762d28b889abb2ae34a31d2b7597&quot; } ], &quot;chainLenth&quot;: 3 } 存在的问题 有一个问题没有解决，就是我们启动多实例来模拟不同的网络节点时，并不能解决节点加入同一个Set的问题，也就是说根本无法通过节点本身来获得其他网络节点，进而判断最长链。所以/nodes/resolve请求暂时时无用的。期间也有想方法解决，比如通过所谓的“第三方”–数据库，当一个节点注册时，保存到数据库中；当第二个节点加入时，也加入到数据库中…当需要请求解决一致性算法时，去数据库中读取节点信息遍历即可。但是，自己没有去实现。这是我的想法，毕竟是两个不相干的实例。如果有朋友有其他的解决方案，请一定要告诉我！谢谢。 总结 通过简单的Demo实现区块链，当然其中简化了大量的实现细节，所以说其实并没有多少实际参考价值。但是意义在于，能帮助我们更容易的理解区块链，为之后的学习打下夯实的基础。 项目源码 Java从零开始创建区块链Demo 参考文章 https://learnblockchain.cn/2017/11/04/bitcoin-pow/ http://blog.51cto.com/zero01/2086195等。 阅读更多 登录后自动展开","@type":"BlogPosting","url":"https://mlh.app/2018/05/15/80bee7aeb95b759f85ddc63cee2ee499.html","headline":"用Java搭建一条区块链","dateModified":"2018-05-15T00:00:00+08:00","datePublished":"2018-05-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/05/15/80bee7aeb95b759f85ddc63cee2ee499.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>用Java搭建一条区块链</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/qq_33764491/article/details/80330542 
 </div> 
 <div class="markdown_views prism-tomorrow-night"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h3 id="前言">前言</h3> 
  <blockquote> 
   <p>为了更好的理解区块链的底层实现原理，决定自己动手模拟实现一条区块链。</p> 
  </blockquote> 
  <h3 id="思路分析">思路分析</h3> 
  <blockquote> 
   <p>通过之前的学习，从文本知识的角度，我们知道，创世区块、记账原理、挖矿原理、工作量证明、共识机制等等区块链的相关知识。</p> 
  </blockquote> 
  <p>创建一条区块链，首先默认构造创世区块。在此基础上，我们可以发布交易，并进行挖矿，计算出工作量证明，将交易记录到区块中，每成功的挖一次矿，块高就+1。当然在此过程中，可能会出现“造假”的问题。也就是说，每一个新注册的节点，都可以有自己的链。这些链长短不一，为了保证账本的一致性，需要通过一种一致性共识算法来找到最长的链，作为样本，同步数据，保证每个节点上的账本信息都是一致的。</p> 
  <h3 id="数据结构">数据结构</h3> 
  <ul> 
   <li>区块链 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180515175053696?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzY0NDkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 如图所示，索引为1的区块即为创始区块。可想而知，可以用List&lt;区块&gt;来表示区块链。其中，区块链的高度即为链上区块的块数，上图区块高度为4。</li> 
   <li>区块 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180515175318739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzY0NDkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 单个区块的数据结构有索引、交易列表、时间戳、工作量证明、上一个区块的hash组成。</li> 
   <li>交易列表 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180515175602347?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzY0NDkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 整个区块链就是一个超级大的分布式账本，当发生交易时，矿工们通过计算工作量证明的方法来进行挖矿(本文中挖到矿将得到1个币的奖励)，将发生的交易记录到账本之中。</li> 
  </ul> 
  <h3 id="web-api">Web API</h3> 
  <p>我们将通过Postman来模拟请求。请求API如下： <br> <code> <br> /nodes/register 注册网络节点 <br> /nodes/resolve 一致性共识算法 <br> /transactions/new 新建交易 <br> /mine 挖矿 <br> /chain 输出整条链的数据 <br> </code></p> 
  <h3 id="项目目录结构">项目目录结构</h3> 
  <p>Gradle Web 项目 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180515181518879?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzY0NDkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <pre class="prettyprint"><code class="language-xml hljs ">dependencies {
    compile('javax:javaee-api:7.0')
    compile('org.json:json:20160810')

    testCompile('junit:junit:4.12')
}
</code></pre> 
  <h3 id="实现代码">实现代码</h3> 
  <blockquote> 
   <p>注释写的很详细，如果遇到不懂的地方，欢迎大家一同讨论。</p> 
  </blockquote> 
  <ul> 
   <li>BlockChain类 ，所有的核心代码都在其中。</li> 
  </ul> 
  <pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-comment">// 存储区块链</span>
    <span class="hljs-keyword">private</span> List&lt;Map&lt;String, Object&gt;&gt; chain;
    <span class="hljs-comment">// 该实例变量用于当前的交易信息列表</span>
    <span class="hljs-keyword">private</span> List&lt;Map&lt;String, Object&gt;&gt; currentTransactions;
    <span class="hljs-comment">// 网络中所有节点的集合</span>
    <span class="hljs-keyword">private</span> Set&lt;String&gt; nodes;


    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BlockChain blockChain = <span class="hljs-keyword">null</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-title">BlockChain</span>() {
        <span class="hljs-comment">// 初始化区块链以及当前的交易信息列表</span>
        chain = <span class="hljs-keyword">new</span> ArrayList&lt;Map&lt;String, Object&gt;&gt;();
        currentTransactions = <span class="hljs-keyword">new</span> ArrayList&lt;Map&lt;String, Object&gt;&gt;();
        <span class="hljs-comment">// 初始化存储网络中其他节点的集合</span>
        nodes = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();

        <span class="hljs-comment">// 创建创世区块</span>
        newBlock(<span class="hljs-number">100</span>, <span class="hljs-string">"0"</span>);
    }

    <span class="hljs-javadoc">/** * 在区块链上新建一个区块 *<span class="hljs-javadoctag"> @param</span> proof 新区块的工作量证明 *<span class="hljs-javadoctag"> @param</span> previous_hash 上一个区块的hash值 *<span class="hljs-javadoctag"> @return</span> 返回新建的区块 */</span>
    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">newBlock</span>(<span class="hljs-keyword">long</span> proof, String previous_hash) {

        Map&lt;String, Object&gt; block = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();
        block.put(<span class="hljs-string">"index"</span>, getChain().size() + <span class="hljs-number">1</span>);
        block.put(<span class="hljs-string">"timestamp"</span>, System.currentTimeMillis());
        block.put(<span class="hljs-string">"transactions"</span>, getCurrentTransactions());
        block.put(<span class="hljs-string">"proof"</span>, proof);
        <span class="hljs-comment">// 如果没有传递上一个区块的hash就计算出区块链中最后一个区块的hash</span>
        block.put(<span class="hljs-string">"previous_hash"</span>, previous_hash != <span class="hljs-keyword">null</span> ? previous_hash : hash(getChain().get(getChain().size() - <span class="hljs-number">1</span>)));

        <span class="hljs-comment">// 重置当前的交易信息列表</span>
        setCurrentTransactions(<span class="hljs-keyword">new</span> ArrayList&lt;Map&lt;String, Object&gt;&gt;());

        getChain().add(block);

        <span class="hljs-keyword">return</span> block;
    }

    <span class="hljs-comment">// 创建单例对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BlockChain <span class="hljs-title">getInstance</span>() {
        <span class="hljs-keyword">if</span> (blockChain == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">synchronized</span> (BlockChain.class) {
                <span class="hljs-keyword">if</span> (blockChain == <span class="hljs-keyword">null</span>) {
                    blockChain = <span class="hljs-keyword">new</span> BlockChain();
                }
            }
        }
        <span class="hljs-keyword">return</span> blockChain;
    }

    <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @return</span> 得到区块链中的最后一个区块 */</span>
    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">lastBlock</span>() {
        <span class="hljs-keyword">return</span> getChain().get(getChain().size() - <span class="hljs-number">1</span>);
    }

    <span class="hljs-javadoc">/** * 生成新交易信息，信息将加入到下一个待挖的区块中 *<span class="hljs-javadoctag"> @param</span> sender 发送方的地址 *<span class="hljs-javadoctag"> @param</span> recipient 接收方的地址 *<span class="hljs-javadoctag"> @param</span> amount 交易数量 *<span class="hljs-javadoctag"> @return</span> 返回该交易事务的块的索引 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newTransactions</span>(String sender, String recipient, <span class="hljs-keyword">long</span> amount) {

        Map&lt;String, Object&gt; transaction = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();
        transaction.put(<span class="hljs-string">"sender"</span>, sender);
        transaction.put(<span class="hljs-string">"recipient"</span>, recipient);
        transaction.put(<span class="hljs-string">"amount"</span>, amount);

        getCurrentTransactions().add(transaction);

        <span class="hljs-keyword">return</span> (Integer) lastBlock().get(<span class="hljs-string">"index"</span>) + <span class="hljs-number">1</span>;
    }

    <span class="hljs-javadoc">/** * 生成区块的 SHA-256格式的 hash值 *<span class="hljs-javadoctag"> @param</span> block 区块 *<span class="hljs-javadoctag"> @return</span> 返回该区块的hash */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">hash</span>(Map&lt;String, Object&gt; block) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Encrypt().Hash(<span class="hljs-keyword">new</span> JSONObject(block).toString());
    }

    <span class="hljs-javadoc">/** * 注册节点 *<span class="hljs-javadoctag"> @param</span> address 节点地址 *<span class="hljs-javadoctag"> @throws</span> MalformedURLException */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerNode</span>(String address) <span class="hljs-keyword">throws</span> MalformedURLException {
        URL url = <span class="hljs-keyword">new</span> URL(address);
        String node = url.getHost() + <span class="hljs-string">":"</span> + (url.getPort() == -<span class="hljs-number">1</span> ? url.getDefaultPort() : url.getPort());
        nodes.add(node);
    }

    <span class="hljs-javadoc">/** * 验证是否为有效链,遍历每个区块验证hash和proof，来确定一个给定的区块链是否有效 *<span class="hljs-javadoctag"> @param</span> chain *<span class="hljs-javadoctag"> @return</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">vaildChain</span>(List&lt;Map&lt;String,Object&gt;&gt; chain) {
        Map&lt;String,Object&gt; lastBlock = chain.get(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">int</span> currentBlockIndex = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (currentBlockIndex &lt; lastBlock.size()) {
            Map&lt;String,Object&gt; currentBlock = chain.get(currentBlockIndex);
            <span class="hljs-comment">//检查区块的hash是否正确</span>
            <span class="hljs-keyword">if</span> (!currentBlock.get(<span class="hljs-string">"previous_hash"</span>).equals(hash(lastBlock))) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
            lastBlock = currentBlock;
            currentBlockIndex ++;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-javadoc">/** * 使用网络中最长的链. 遍历所有的邻居节点，并用上一个方法检查链的有效性， * 如果发现有效更长链，就替换掉自己的链 *<span class="hljs-javadoctag"> @return</span> 如果链被取代返回true, 否则返回false *<span class="hljs-javadoctag"> @throws</span> IOException */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">resolveConflicts</span>() <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-comment">//获得当前网络上所有的邻居节点</span>
        Set&lt;String&gt; neighbours = <span class="hljs-keyword">this</span>.nodes;

        List&lt;Map&lt;String, Object&gt;&gt; newChain = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// 寻找最长的区块链0</span>
        <span class="hljs-keyword">long</span> maxLength = <span class="hljs-keyword">this</span>.chain.size();

        <span class="hljs-comment">// 获取并验证网络中的所有节点的区块链</span>
        <span class="hljs-keyword">for</span> (String node : neighbours) {

            URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">"http://"</span> + node + <span class="hljs-string">"/chain"</span>);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.connect();

            <span class="hljs-keyword">if</span> (connection.getResponseCode() == <span class="hljs-number">200</span>) {
                BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(
                        <span class="hljs-keyword">new</span> InputStreamReader(connection.getInputStream(), <span class="hljs-string">"utf-8"</span>));
                StringBuffer responseData = <span class="hljs-keyword">new</span> StringBuffer();
                String response = <span class="hljs-keyword">null</span>;
                <span class="hljs-keyword">while</span> ((response = bufferedReader.readLine()) != <span class="hljs-keyword">null</span>) {
                    responseData.append(response);
                }
                bufferedReader.close();

                JSONObject jsonData = <span class="hljs-keyword">new</span> JSONObject(responseData.toString());
                <span class="hljs-keyword">long</span> length = jsonData.getLong(<span class="hljs-string">"blockLength"</span>);
                List&lt;Map&lt;String, Object&gt;&gt; chain = (List) jsonData.getJSONArray(<span class="hljs-string">"chain"</span>).toList();

                <span class="hljs-comment">// 检查长度是否长，链是否有效</span>
                <span class="hljs-keyword">if</span> (length &gt; maxLength &amp;&amp; vaildChain(chain)) {
                    maxLength = length;
                    newChain = chain;
                }
            }

        }
        <span class="hljs-comment">// 如果发现一个新的有效链比我们的长，就替换当前的链</span>
        <span class="hljs-keyword">if</span> (newChain != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">this</span>.chain = newChain;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }</code></pre> 
  <ul> 
   <li>Proof 类 ，计算工作量证明</li> 
  </ul> 
  <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-javadoc">/** * 计算当前区块的工作量证明 *<span class="hljs-javadoctag"> @param</span> last_proof 上一个区块的工作量证明 *<span class="hljs-javadoctag"> @return</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">ProofOfWork</span>(<span class="hljs-keyword">long</span> last_proof){
        <span class="hljs-keyword">long</span> proof = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (!(vaildProof(last_proof,proof))) {
            proof ++;
        }
        <span class="hljs-keyword">return</span> proof;
    }

    <span class="hljs-javadoc">/** * 验证证明，是否拼接后的Hash值以4个0开头 *<span class="hljs-javadoctag"> @param</span> last_proof 上一个区块工作量证明 *<span class="hljs-javadoctag"> @param</span> proof 当前区块的工作量证明 *<span class="hljs-javadoctag"> @return</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">vaildProof</span>(<span class="hljs-keyword">long</span> last_proof, <span class="hljs-keyword">long</span> proof) {
        String guess = last_proof + <span class="hljs-string">""</span> + proof;
        String guess_hash = <span class="hljs-keyword">new</span> Encrypt().Hash(guess);
        <span class="hljs-keyword">boolean</span> flag = guess_hash.startsWith(<span class="hljs-string">"0000"</span>);
        <span class="hljs-keyword">return</span>  flag;
    }</code></pre> 
  <ul> 
   <li>Encrypt 类 ，Hash计算工具类</li> 
  </ul> 
  <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Encrypt</span> {</span>
     <span class="hljs-javadoc">/** * 传入字符串，返回 SHA-256 加密字符串 *<span class="hljs-javadoctag"> @param</span> strText *<span class="hljs-javadoctag"> @return</span> */</span>
     <span class="hljs-keyword">public</span> String <span class="hljs-title">Hash</span>(<span class="hljs-keyword">final</span> String strText) {
         <span class="hljs-comment">// 返回值</span>
         String strResult = <span class="hljs-keyword">null</span>;
         <span class="hljs-comment">// 是否是有效字符串</span>
         <span class="hljs-keyword">if</span> (strText != <span class="hljs-keyword">null</span> &amp;&amp; strText.length() &gt; <span class="hljs-number">0</span>) {
             <span class="hljs-keyword">try</span> {
                 <span class="hljs-comment">// 创建加密对象，传入要加密类型</span>
                 MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string">"SHA-256"</span>);
                 <span class="hljs-comment">// 传入要加密的字符串</span>
                 messageDigest.update(strText.getBytes());
                 <span class="hljs-comment">// 执行哈希计算，得到 byte 数组</span>
                 <span class="hljs-keyword">byte</span> byteBuffer[] = messageDigest.digest();
                 <span class="hljs-comment">// 將 byte 数组转换 string 类型</span>
                 StringBuffer strHexString = <span class="hljs-keyword">new</span> StringBuffer();
                 <span class="hljs-comment">// 遍历 byte 数组</span>
                 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; byteBuffer.length; i++) {
                     <span class="hljs-comment">// 转换成16进制并存储在字符串中</span>
                     String hex = Integer.toHexString(<span class="hljs-number">0xff</span> &amp; byteBuffer[i]);
                     <span class="hljs-keyword">if</span> (hex.length() == <span class="hljs-number">1</span>) {
                         strHexString.append(<span class="hljs-string">'0'</span>);
                     }
                     strHexString.append(hex);
                 }
                 <span class="hljs-comment">// 得到返回結果</span>
                 strResult = strHexString.toString();
             } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) {
                 e.printStackTrace();
             }
         }
         <span class="hljs-keyword">return</span> strResult;
     }
 }</code></pre> 
  <ul> 
   <li>FullChain 类，输出整条链的信息。</li> 
  </ul> 
  <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @Author</span>: cfx *<span class="hljs-javadoctag"> @Description</span>: 该Servlet用于输出整个区块链的数据(Json) *<span class="hljs-javadoctag"> @Date</span>: Created in 2018/5/9 17:24 */</span>
<span class="hljs-annotation">@WebServlet</span>(<span class="hljs-string">"/chain"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FullChain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span>{</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span>(HttpServletRequest req, HttpServletResponse resp) <span class="hljs-keyword">throws</span> ServletException, IOException {
        BlockChain blockChain = BlockChain.getInstance();
        Map&lt;String,Object&gt; response = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();
        response.put(<span class="hljs-string">"chain"</span>,blockChain.getChain());
        response.put(<span class="hljs-string">"blockLength"</span>,blockChain.getChain().size());

        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject(response);
        resp.setContentType(<span class="hljs-string">"application/json"</span>);
        PrintWriter printWriter = resp.getWriter();
        printWriter.println(jsonObject);
        printWriter.close();
    }
}</code></pre> 
  <ul> 
   <li>InitialID 类 ，初始化时执行，随机的uuid作为矿工的账户地址。</li> 
  </ul> 
  <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @Author</span>: cfx *<span class="hljs-javadoctag"> @Description</span>: 初始化时，使用UUID来作为节点ID *<span class="hljs-javadoctag"> @Date</span>: Created in 2018/5/9 17:17 */</span>
<span class="hljs-annotation">@WebListener</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitialID</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> {</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span>(ServletContextEvent sce) {
        ServletContext servletContext = sce.getServletContext();
        String uuid = UUID.randomUUID().toString().replace(<span class="hljs-string">"-"</span>, <span class="hljs-string">""</span>);
        servletContext.setAttribute(<span class="hljs-string">"uuid"</span>, uuid);
        System.out.println(<span class="hljs-string">"uuid is : "</span>+servletContext.getAttribute(<span class="hljs-string">"uuid"</span>));
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span>(ServletContextEvent sce) {
    }
}</code></pre> 
  <ul> 
   <li>Register 类 ，节点注册类，记录网络上所有的节点，用户共识算法，保证所有的节点上的账本都是一致的。</li> 
  </ul> 
  <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @Author</span>: cfx *<span class="hljs-javadoctag"> @Description</span>: 注册网络节点 *<span class="hljs-javadoctag"> @Date</span>: Created in 2018/5/10 11:26 */</span>
<span class="hljs-annotation">@WebServlet</span>(<span class="hljs-string">"/nodes/register"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Register</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> {</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span>(HttpServletRequest req, HttpServletResponse resp) <span class="hljs-keyword">throws</span> ServletException, IOException {
        req.setCharacterEncoding(<span class="hljs-string">"utf-8"</span>);
        <span class="hljs-comment">// 读取客户端传递过来的数据并转换成JSON格式</span>
        BufferedReader reader = req.getReader();
        String input = <span class="hljs-keyword">null</span>;
        StringBuffer requestBody = <span class="hljs-keyword">new</span> StringBuffer();
        <span class="hljs-keyword">while</span> ((input = reader.readLine()) != <span class="hljs-keyword">null</span>) {
            requestBody.append(input);
        }
        JSONObject jsonValue = <span class="hljs-keyword">new</span> JSONObject(requestBody.toString());
        BlockChain blockChain = BlockChain.getInstance();
        blockChain.registerNode(jsonValue.getString(<span class="hljs-string">"nodes"</span>));

        PrintWriter printWriter = resp.getWriter();
        printWriter.println(<span class="hljs-keyword">new</span> JSONObject().append(<span class="hljs-string">"message"</span>,<span class="hljs-string">"The Nodes is : "</span> + blockChain.getNodes()));
        printWriter.close();

    }
}</code></pre> 
  <ul> 
   <li>NewTransaction 类，新建交易类。</li> 
  </ul> 
  <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @Author</span>: cfx *<span class="hljs-javadoctag"> @Description</span>: 该Servlet用于接收并处理新的交易信息 *<span class="hljs-javadoctag"> @Date</span>: Created in 2018/5/9 17:22 */</span>
<span class="hljs-annotation">@WebServlet</span>(<span class="hljs-string">"/transactions/new"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewTransaction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> {</span>

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span>(HttpServletRequest req, HttpServletResponse resp) <span class="hljs-keyword">throws</span> ServletException, IOException {

        req.setCharacterEncoding(<span class="hljs-string">"utf-8"</span>);
        <span class="hljs-comment">// 读取客户端传递过来的数据并转换成JSON格式</span>
        BufferedReader reader = req.getReader();
        String input = <span class="hljs-keyword">null</span>;
        StringBuffer requestBody = <span class="hljs-keyword">new</span> StringBuffer();
        <span class="hljs-keyword">while</span> ((input = reader.readLine()) != <span class="hljs-keyword">null</span>) {
            requestBody.append(input);
        }
        JSONObject jsonValues = <span class="hljs-keyword">new</span> JSONObject(requestBody.toString());

        <span class="hljs-comment">// 检查所需要的字段是否位于POST的data中</span>
        String[] required = { <span class="hljs-string">"sender"</span>, <span class="hljs-string">"recipient"</span>, <span class="hljs-string">"amount"</span> };
        <span class="hljs-keyword">for</span> (String string : required) {
            <span class="hljs-keyword">if</span> (!jsonValues.has(string)) {
                <span class="hljs-comment">// 如果没有需要的字段就返回错误信息</span>
                resp.sendError(<span class="hljs-number">400</span>, <span class="hljs-string">"Missing values"</span>);
            }
        }

        <span class="hljs-comment">// 新建交易信息</span>
        BlockChain blockChain = BlockChain.getInstance();
        <span class="hljs-keyword">int</span> index = blockChain.newTransactions(jsonValues.getString(<span class="hljs-string">"sender"</span>), jsonValues.getString(<span class="hljs-string">"recipient"</span>),
                jsonValues.getLong(<span class="hljs-string">"amount"</span>));

        <span class="hljs-comment">// 返回json格式的数据给客户端</span>
        resp.setContentType(<span class="hljs-string">"application/json"</span>);
        PrintWriter printWriter = resp.getWriter();
        printWriter.println(<span class="hljs-keyword">new</span> JSONObject().append(<span class="hljs-string">"message"</span>, <span class="hljs-string">"Transaction will be added to Block "</span> + index));
        printWriter.close();
    }
}</code></pre> 
  <ul> 
   <li>Mine , 挖矿类。</li> 
  </ul> 
  <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @Author</span>: cfx *<span class="hljs-javadoctag"> @Description</span>: 该Servlet用于运行工作算法的证明来获得下一个证明，也就是所谓的挖矿 *<span class="hljs-javadoctag"> @Date</span>: Created in 2018/5/9 17:21 */</span>
<span class="hljs-annotation">@WebServlet</span>(<span class="hljs-string">"/mine"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span>{</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span>(HttpServletRequest req, HttpServletResponse resp) <span class="hljs-keyword">throws</span> ServletException, IOException {
        BlockChain blockChain = BlockChain.getInstance();

        <span class="hljs-comment">//计算出工作量证明</span>
        Map&lt;String,Object&gt; lastBlock = blockChain.lastBlock();
        Long last_proof = Long.parseLong(lastBlock.get(<span class="hljs-string">"proof"</span>) + <span class="hljs-string">""</span>);
        Long proof = <span class="hljs-keyword">new</span> Proof().ProofOfWork(last_proof);

        <span class="hljs-comment">//奖励计算出工作量证明的矿工1个币的奖励，发送者为"0"表明这是新挖出的矿。</span>
        String uuid = (String) <span class="hljs-keyword">this</span>.getServletContext().getAttribute(<span class="hljs-string">"uuid"</span>);
        blockChain.newTransactions(<span class="hljs-string">"0"</span>,uuid,<span class="hljs-number">1</span>);

        <span class="hljs-comment">//构建新的区块</span>
        Map&lt;String,Object&gt; newBlock = blockChain.newBlock(proof,<span class="hljs-keyword">null</span>);
        Map&lt;String, Object&gt; response = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();
        response.put(<span class="hljs-string">"message"</span>, <span class="hljs-string">"New Block Forged"</span>);
        response.put(<span class="hljs-string">"index"</span>, newBlock.get(<span class="hljs-string">"index"</span>));
        response.put(<span class="hljs-string">"transactions"</span>, newBlock.get(<span class="hljs-string">"transactions"</span>));
        response.put(<span class="hljs-string">"proof"</span>, newBlock.get(<span class="hljs-string">"proof"</span>));
        response.put(<span class="hljs-string">"previous_hash"</span>, newBlock.get(<span class="hljs-string">"previous_hash"</span>));

        <span class="hljs-comment">// 返回新区块的数据给客户端</span>
        resp.setContentType(<span class="hljs-string">"application/json"</span>);
        PrintWriter printWriter = resp.getWriter();
        printWriter.println(<span class="hljs-keyword">new</span> JSONObject(response));
        printWriter.close();
    }
}
</code></pre> 
  <ul> 
   <li>Consensus 类 ，通过判断不同节点上链的长度，来找出最长链，这就是一致性共识算法。</li> 
  </ul> 
  <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @Author</span>: cfx *<span class="hljs-javadoctag"> @Description</span>: 一致性共识算法，解决共识冲突，保证所有的节点都在同一条链上(最长链) *<span class="hljs-javadoctag"> @Date</span>: Created in 2018/5/10 11:38 */</span>
<span class="hljs-annotation">@WebServlet</span>(<span class="hljs-string">"/nodes/resolve"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consensus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> {</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span>(HttpServletRequest req, HttpServletResponse resp) <span class="hljs-keyword">throws</span> ServletException, IOException {
        BlockChain blockChain = BlockChain.getInstance();
        <span class="hljs-keyword">boolean</span> flag = blockChain.resolveConflicts();
        System.out.println(<span class="hljs-string">"是否解决一致性共识冲突："</span> + flag);
    }
}
</code></pre> 
  <h3 id="运行结果">运行结果</h3> 
  <p>以下是本人之前的测试记录：</p> 
  <pre class="prettyprint"><code class=" hljs vbscript">首次请求/chain:
    初始化Blockchain
    {
        <span class="hljs-string">"chain"</span>: [
            {
                <span class="hljs-string">"index"</span>: <span class="hljs-number">1</span>,
                <span class="hljs-string">"proof"</span>: <span class="hljs-number">100</span>,
                <span class="hljs-string">"transactions"</span>: [],
                <span class="hljs-string">"timestamp"</span>: <span class="hljs-number">1526284543591</span>,
                <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"0"</span>
            }
        ],
        <span class="hljs-string">"chainLenth"</span>: <span class="hljs-number">1</span>
    }

请求/nodes/register，进行网络节点的注册。
<span class="hljs-built_in">request</span>:
    {
      <span class="hljs-string">"nodes"</span>: <span class="hljs-string">"http://lcoalhost:8080"</span>
    }
<span class="hljs-built_in">response</span>:
    {<span class="hljs-string">"message"</span>:[<span class="hljs-string">"All Nodes are:[lcoalhost:8080]"</span>]}

请求/mine,进行挖矿。
{
    <span class="hljs-string">"index"</span>: <span class="hljs-number">2</span>,
    <span class="hljs-string">"proof"</span>: <span class="hljs-number">35293</span>,
    <span class="hljs-string">"message"</span>: <span class="hljs-string">"New Block Forged"</span>,
    <span class="hljs-string">"transactions"</span>: [
        {
            <span class="hljs-string">"amount"</span>: <span class="hljs-number">1</span>,
            <span class="hljs-string">"sender"</span>: <span class="hljs-string">"0"</span>,
            <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"e91467fe51bd43b8ad7892b3bc09bd4e"</span>
        }
    ],
    <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66"</span>
}
请求/chain,查看链上所有区块的数据
{
    <span class="hljs-string">"chain"</span>: [
        {
            <span class="hljs-string">"index"</span>: <span class="hljs-number">1</span>,
            <span class="hljs-string">"proof"</span>: <span class="hljs-number">100</span>,
            <span class="hljs-string">"transactions"</span>: [],
            <span class="hljs-string">"timestamp"</span>: <span class="hljs-number">1526284543591</span>,
            <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"0"</span>
        },
        {
            <span class="hljs-string">"index"</span>: <span class="hljs-number">2</span>,
            <span class="hljs-string">"proof"</span>: <span class="hljs-number">35293</span>,
            <span class="hljs-string">"transactions"</span>: [
                {
                    <span class="hljs-string">"amount"</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-string">"sender"</span>: <span class="hljs-string">"0"</span>,
                    <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"e91467fe51bd43b8ad7892b3bc09bd4e"</span>
                }
            ],
            <span class="hljs-string">"timestamp"</span>: <span class="hljs-number">1526284661678</span>,
            <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66"</span>
        }
    ],
    <span class="hljs-string">"chainLenth"</span>: <span class="hljs-number">2</span>
}

请求/transactions/<span class="hljs-keyword">new</span>,新建交易。
<span class="hljs-built_in">request</span>: 
    {
     <span class="hljs-string">"sender"</span>: <span class="hljs-string">"d4ee26eee15148ee92c6cd394edd974e"</span>,
     <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"someone-other-address"</span>,
     <span class="hljs-string">"amount"</span>: <span class="hljs-number">6</span>
    }
<span class="hljs-built_in">response</span>:
    {
        <span class="hljs-string">"message"</span>: [
            <span class="hljs-string">"Transaction will be added to Block 3"</span>
        ]
    }
请求/mine，计算出工作量证明。将上面的交易记录到账本之中。
{
    <span class="hljs-string">"index"</span>: <span class="hljs-number">3</span>,
    <span class="hljs-string">"proof"</span>: <span class="hljs-number">35089</span>,
    <span class="hljs-string">"message"</span>: <span class="hljs-string">"New Block Forged"</span>,
    <span class="hljs-string">"transactions"</span>: [
        {
            <span class="hljs-string">"amount"</span>: <span class="hljs-number">6</span>,
            <span class="hljs-string">"sender"</span>: <span class="hljs-string">"d4ee26eee15148ee92c6cd394edd974e"</span>,
            <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"someone-other-address"</span>
        },
        {
            <span class="hljs-string">"amount"</span>: <span class="hljs-number">1</span>,
            <span class="hljs-string">"sender"</span>: <span class="hljs-string">"0"</span>,
            <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"e91467fe51bd43b8ad7892b3bc09bd4e"</span>
        }
    ],
    <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"a12748a35d57a4a371cefc4a8c294236d69c762d28b889abb2ae34a31d2b7597"</span>
}

请求/chain,查看链上所有区块的数据
{
    <span class="hljs-string">"chain"</span>: [
        {
            <span class="hljs-string">"index"</span>: <span class="hljs-number">1</span>,
            <span class="hljs-string">"proof"</span>: <span class="hljs-number">100</span>,
            <span class="hljs-string">"transactions"</span>: [],
            <span class="hljs-string">"timestamp"</span>: <span class="hljs-number">1526284543591</span>,
            <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"0"</span>
        },
        {
            <span class="hljs-string">"index"</span>: <span class="hljs-number">2</span>,
            <span class="hljs-string">"proof"</span>: <span class="hljs-number">35293</span>,
            <span class="hljs-string">"transactions"</span>: [
                {
                    <span class="hljs-string">"amount"</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-string">"sender"</span>: <span class="hljs-string">"0"</span>,
                    <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"e91467fe51bd43b8ad7892b3bc09bd4e"</span>
                }
            ],
            <span class="hljs-string">"timestamp"</span>: <span class="hljs-number">1526284661678</span>,
            <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"c4b2bb2f6e042680aed249309791cac96da6c1f65b811c306088723ae3c73f66"</span>
        },
        {
            <span class="hljs-string">"index"</span>: <span class="hljs-number">3</span>,
            <span class="hljs-string">"proof"</span>: <span class="hljs-number">35089</span>,
            <span class="hljs-string">"transactions"</span>: [
                {
                    <span class="hljs-string">"amount"</span>: <span class="hljs-number">6</span>,
                    <span class="hljs-string">"sender"</span>: <span class="hljs-string">"d4ee26eee15148ee92c6cd394edd974e"</span>,
                    <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"someone-other-address"</span>
                },
                {
                    <span class="hljs-string">"amount"</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-string">"sender"</span>: <span class="hljs-string">"0"</span>,
                    <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"e91467fe51bd43b8ad7892b3bc09bd4e"</span>
                }
            ],
            <span class="hljs-string">"timestamp"</span>: <span class="hljs-number">1526284774452</span>,
            <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"a12748a35d57a4a371cefc4a8c294236d69c762d28b889abb2ae34a31d2b7597"</span>
        }
    ],
    <span class="hljs-string">"chainLenth"</span>: <span class="hljs-number">3</span>
}</code></pre> 
  <h3 id="存在的问题">存在的问题</h3> 
  <p>有一个问题没有解决，就是我们启动多实例来模拟不同的网络节点时，并不能解决节点加入同一个Set的问题，也就是说根本无法通过节点本身来获得其他网络节点，进而判断最长链。所以/nodes/resolve请求暂时时无用的。期间也有想方法解决，比如通过所谓的“第三方”–数据库，当一个节点注册时，保存到数据库中；当第二个节点加入时，也加入到数据库中…当需要请求解决一致性算法时，去数据库中读取节点信息遍历即可。但是，自己没有去实现。这是我的想法，毕竟是两个不相干的实例。如果有朋友有其他的解决方案，请一定要告诉我！谢谢。</p> 
  <h3 id="总结">总结</h3> 
  <p>通过简单的Demo实现区块链，当然其中简化了大量的实现细节，所以说其实并没有多少实际参考价值。但是意义在于，能帮助我们更容易的理解区块链，为之后的学习打下夯实的基础。</p> 
  <h3 id="项目源码">项目源码</h3> 
  <p><a href="https://github.com/mokeychan/blockchainforjava" rel="nofollow">Java从零开始创建区块链Demo</a></p> 
  <h3 id="参考文章">参考文章</h3> 
  <p><a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/" rel="nofollow">https://learnblockchain.cn/2017/11/04/bitcoin-pow/</a> <br> <a href="http://blog.51cto.com/zero01/2086195" rel="nofollow">http://blog.51cto.com/zero01/2086195</a>等。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-8cccb36679.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_33764491/article/details/80330542,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_33764491/article/details/80330542,&quot;}">阅读更多</a> 
 <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_33764491/article/details/80330542,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_557&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_33764491/article/details/80330542,&quot;}">登录后自动展开</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
