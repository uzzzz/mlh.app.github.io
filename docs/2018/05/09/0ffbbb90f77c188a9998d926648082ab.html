<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>超级账本HyperLedger的Fabric“全手动”、“多节点”部署教程，带视频演示 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="超级账本HyperLedger的Fabric“全手动”、“多节点”部署教程，带视频演示" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="原文地址：超级账本HyperLedger的Fabric项目的手动部署教程 说明 &nbsp; 虽然通过Building Your First Network中的docker-compose文件可以直接启动一个all-in-one的fabric。 但这种方式隐藏了太多的细节，只能让人有个模糊的认识，对生产环境中部署方式、多服务器部署，依然不清不楚， 对各组件的配置文件也完全不了解。 通过反复阅读Fabric的文档，以及Building Your First Network中的脚本，经历了诸多磨难之后，总算弄清楚了Fabric的组件间关系与配置项。 看文档感觉吃力或者一通操作后不知所以然的同学，可以使用网易云课堂视频教程：HyperLedger Fabric手动部署教程的视频讲解 说明 规划 编译或下载fabric文件 准备证书 cryptogen的方式 使用fabric-ca生成证书 orderer.example.com peer0.org1.example.com peer1.org1.example.com peer0.org2.example.com 开始部署 启动前准备 启动 用户 Admin@org1.example.com User1@org1.example.com Admin@org2.example.com 创建channel与peer的设置 准备channel文件 创建channel 将peer加入channel 安装合约（chaincode） 合约初始化 合约调用 更新合约 参考 规划 创建一个名为fabric-deploy的目录，用来存放部署过程使用到的文件。 mkdir ~/fabric-deploy 这里将用三台机器部署一个fabric网络，该网络中有两个组织: org1.example.com org2.example.com 一个order: orderer.example.com org1.example.com有两个peer: peer0.org1.example.com peer1.org1.example.com org2.example.com有一个peer: peer0.org2.example.com 三台机器的IP，以及部署的组件如下： 192.168.88.10 部署: orderer、peer0@org1 192.168.88.11 部署: peer1@org1 192.168.88.12 部署： peer0@org2 相应域名的IP分别为： 192.168.88.10 orderer.example.com 192.168.88.10 peer0.org1.example.com 192.168.88.11 peer1.org1.example.com 192.168.88.12 peer0.org2.example.com 将这四条记录添加到每台机器的/etc/hosts文件中。 每台机器上还需要安装docker: yum install -y docker systemctl start docker 另外fabric的peer会调用docker，需要在所有peer上安装docker，并提前下载镜像： docker pull hyperledger/fabric-javaenv:x86_64-1.1.0 docker pull hyperledger/fabric-ccenv:x86_64-1.1.0 docker pull hyperledger/fabric-baseos:x86_64-0.4.6 下载的镜像需要与下面步骤中创建的core.yaml中的镜像配对： ... chaincode: peerAddress: id: path: name: builder: $(DOCKER_NS)/fabric-ccenv:$(ARCH)-$(PROJECT_VERSION) golang: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) car: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) java: Dockerfile: | from $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION) ... 创建合约的时候会用到这些镜像，镜像下载可能比较慢，根据自己的情况配置加速器。另外每个peer上都需要下载。 我在”区块链实践分享”中提供的fabric-deploy中下载包中提供了这三个镜像，可以直接使用： cd fabric-deploy/docker-images ./load.sh 编译或下载fabric文件 编译方法见：hyperledger fabric编译 执行下面的命令可以下载编译好的fabric以及依赖的镜像： curl -sSL https://goo.gl/6wtTN5 | bash 或者直接到这里下载：&nbsp;hyperledger fabric download 这里使用的linux-amd64，fabric-1.1.0: wget https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/linux-amd64-1.1.0/hyperledger-fabric-linux-amd64-1.1.0.tar.gz wget https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/linux-amd64-1.1.0/hyperledger-fabric-linux-amd64-1.1.0.tar.gz.md5 下载完成后校验一下： $ md5sum hyperledger-fabric-linux-amd64-1.1.0.tar.gz 6be979ccd903752aefba9da4fc9e1d44 hyperledger-fabric-linux-amd64-1.1.0.tar.gz $ cat hyperledger-fabric-linux-amd64-1.1.0.tar.gz.md5 6be979ccd903752aefba9da4fc9e1d44 解压后得到两个bin和config两个目录: tar -xvf hyperledger-fabric-linux-amd64-1.1.0.tar.gz bin目录中是fabric的组件，config是配置文件模版。 $ ls bin/ configtxgen configtxlator cryptogen get-byfn.sh get-docker-images.sh orderer peer $ ls config/ configtx.yaml core.yaml orderer.yaml 保留备用。 准备证书 证书的准备方式有两种，一种用cryptogen命令生成，一种是通过fabric-ca服务生成。 cryptogen的方式 创建一个配置文件crypto-config.yaml，这里配置了两个组织，org1的Count是2，表示两个peer： OrdererOrgs: - Name: Orderer Domain: example.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.example.com Template: Count: 2 Users: Count: 1 - Name: Org2 Domain: org2.example.com Template: Count: 1 Users: Count: 1 然后执行crypto，生成证书： ./bin/cryptogen generate --config=crypto-config.yaml --output ./certs certs目录下生成了两个目录： $ ls ./certs/ ordererOrganizations peerOrganizations certs目录的内容比较多，并且目录很深，需要提前说明一下。搞清楚了这里面文件的含义，就懂了一半。 以certs/ordererOrganizations/example.com/orderers/orderer.example.com/目录中内容为例。 这里目录中的内容是用于orderer.example.com的，里面有两个子目录tls和msp： $ tree certs/ordererOrganizations/example.com/orderers/orderer.example.com/ certs/ordererOrganizations/example.com/orderers/orderer.example.com/ |-- msp | |-- admincerts | | -- Admin@example.com-cert.pem | |-- cacerts | | -- ca.example.com-cert.pem | |-- keystore | | -- 16da15d400d4ca4b53d369b6d6e50a084d4354998c3b4d7a0934635d3907f90f_sk | |-- signcerts | | -- orderer.example.com-cert.pem | -- tlscacerts | -- tlsca.example.com-cert.pem -- tls |-- ca.crt |-- server.crt -- server.key tls目录中的内容很好理解，它是order对外服务时使用的私钥(server.key)和证书(server.crt)，ca.crt是签注这个证书的CA，需要提供给发起请求的一端。 msp中有五个目录，对区块链进行操作时需要使用这些文件。 msp/admincerts中存放的是用户证书，使用该证书的用户对orderer.example.com具有管理权限。 msp/cacerts是签署msp/signcerts中用户证书的ca，可以用来校验用户的证书： $ cd ./certs/ordererOrganizations/example.com/orderers/orderer.example.com/msp/ $ openssl verify -CAfile ./cacerts/ca.example.com-cert.pem admincerts/Admin\@example.com-cert.pem admincerts/Admin@example.com-cert.pem: OK msp/keystore是orderer.example.com操作区块，进行签署时使用的的私钥。 msp/signcerts是orderer.example.com提供其它组件用来核实它的签署的公钥。 msp/tlscacerts文件与tls/ca.crt相同。 这里需要特别提到的是msp/admincerts，在使用fabric时，你可能会发现有些操作需要admin权限，例如在某个peer上安装合约。 那么管理员是如何认定的？就是看当前用户的证书是不是在msp/admincerts目录中。 这个目录中的内容目前是(版本1.1.x)启动时加载的，因此如果在里面添加或删除文件后，需要重启使用到它的组件。 在ordererOrganizations/example.com/还有其它几个目录： ca msp orderers tlsca users orderers中存放就签名分析的每个orderer组件的证书文件。 users中存放的用户的证书文件，与orderer.example.com中内容基本相同，不过tls目录中文件名变成了client.X： $ tree ordererOrganizations/example.com/users ordererOrganizations/example.com/users -- Admin@example.com |-- msp | |-- admincerts | | -- Admin@example.com-cert.pem | |-- cacerts | | -- ca.example.com-cert.pem | |-- keystore | | -- 1ac3b40c9ddda7e7a0f724b18faa0ce6fdf3f9e9ff5eac59e1e3f9739499ac2d_sk | |-- signcerts | | -- Admin@example.com-cert.pem | -- tlscacerts | -- tlsca.example.com-cert.pem -- tls |-- ca.crt |-- client.crt -- client.key certs/peerOrganizations中的内容与certs/ordererOrganizations中也基本相同，只不过它里面存放的是peer要使用的证书文件。 certs目录中的文件留着备用。 使用fabric-ca生成证书 fabric-ca的部署和详细用法见：hyperledger的fabricCA的使用 只用fabric-ca生成证书的过程相对繁琐很多，需要为每个组件、每个用户生成，这里不做示例。 orderer.example.com 建一个目录存放orderer.example.com需要文件： mkdir orderer.example.com 先将bin/orderer以及证书复制到orderer.example.com目录中。 cp bin/orderer orderer.example.com/ cp -rf certs/ordererOrganizations/example.com/orderers/orderer.example.com/* orderer.example.com/ 然后准备orderer的配置文件orderer.yaml: General: LedgerType: file ListenAddress: 0.0.0.0 ListenPort: 7050 TLS: Enabled: true PrivateKey: ./tls/server.key Certificate: ./tls/server.crt RootCAs: - ./tls/ca.crt # ClientAuthEnabled: false # ClientRootCAs: LogLevel: debug LogFormat: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; # GenesisMethod: provisional GenesisMethod: file GenesisProfile: SampleInsecureSolo GenesisFile: ./genesisblock LocalMSPDir: ./msp LocalMSPID: OrdererMSP Profile: Enabled: false Address: 0.0.0.0:6060 BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: FileLedger: Location: /opt/app/fabric/orderer/data Prefix: hyperledger-fabric-ordererledger RAMLedger: HistorySize: 1000 Kafka: Retry: ShortInterval: 5s ShortTotal: 10m LongInterval: 5m LongTotal: 12h NetworkTimeouts: DialTimeout: 10s ReadTimeout: 10s WriteTimeout: 10s Metadata: RetryBackoff: 250ms RetryMax: 3 Producer: RetryBackoff: 100ms RetryMax: 3 Consumer: RetryBackoff: 2s Verbose: false TLS: Enabled: false PrivateKey: #File: path/to/PrivateKey Certificate: #File: path/to/Certificate RootCAs: #File: path/to/RootCAs Version: 注意，orderer将被部署在目标机器的/opt/apt/fabric/orderer目录中，如果要部署在其它目录中，需要修改配置文件中路径。 这里需要用到一个data目录，存放orderer的数据: mkdir orderer.example.com/data peer0.org1.example.com 建一个目录存放peer0.org1.example.com需要文件： mkdir peer0.org1.example.com 先将bin/peer以及证书复制到peer0.org1.example.com目录中。 cp bin/peer peer0.org1.example.com/ cp -rf certs/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/* peer0.org1.example.com/ 准备peer0.org1.example.com的配置文件core.yaml： logging: peer: debug cauthdsl: warning gossip: warning ledger: info msp: warning policies: warning grpc: error format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; peer: id: peer0.org1.example.com networkId: dev listenAddress: 0.0.0.0:7051 address: 0.0.0.0:7051 addressAutoDetect: false gomaxprocs: -1 gossip: bootstrap: 127.0.0.1:7051 bootstrap: peer0.org1.example.com:7051 useLeaderElection: true orgLeader: false endpoint: maxBlockCountToStore: 100 maxPropagationBurstLatency: 10ms maxPropagationBurstSize: 10 propagateIterations: 1 propagatePeerNum: 3 pullInterval: 4s pullPeerNum: 3 requestStateInfoInterval: 4s publishStateInfoInterval: 4s stateInfoRetentionInterval: publishCertPeriod: 10s skipBlockVerification: false dialTimeout: 3s connTimeout: 2s recvBuffSize: 20 sendBuffSize: 200 digestWaitTime: 1s requestWaitTime: 1s responseWaitTime: 2s aliveTimeInterval: 5s aliveExpirationTimeout: 25s reconnectInterval: 25s externalEndpoint: peer0.org1.example.com:7051 election: startupGracePeriod: 15s membershipSampleInterval: 1s leaderAliveThreshold: 10s leaderElectionDuration: 5s events: address: 0.0.0.0:7053 buffersize: 100 timeout: 10ms tls: enabled: true cert: file: ./tls/server.crt key: file: ./tls/server.key rootcert: file: ./tls/ca.crt serverhostoverride: fileSystemPath: /opt/app/fabric/peer/data BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: mspConfigPath: msp localMspId: Org1MSP profile: enabled: true listenAddress: 0.0.0.0:6060 vm: endpoint: unix:///var/run/docker.sock docker: tls: enabled: false ca: file: docker/ca.crt cert: file: docker/tls.crt key: file: docker/tls.key attachStdout: false hostConfig: NetworkMode: host Dns: # - 192.168.0.1 LogConfig: Type: json-file Config: max-size: &quot;50m&quot; max-file: &quot;5&quot; Memory: 2147483648 chaincode: peerAddress: id: path: name: builder: $(DOCKER_NS)/fabric-ccenv:$(ARCH)-$(PROJECT_VERSION) golang: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) car: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) java: Dockerfile: | from $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION) startuptimeout: 300s executetimeout: 30s mode: net keepalive: 0 system: cscc: enable lscc: enable escc: enable vscc: enable qscc: enable logging: level: info shim: warning format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; ledger: blockchain: state: stateDatabase: goleveldb couchDBConfig: couchDBAddress: 127.0.0.1:5984 username: password: maxRetries: 3 maxRetriesOnStartup: 10 requestTimeout: 35s queryLimit: 10000 history: enableHistoryDatabase: true 注意，peer将被部署在目标机器的/opt/apt/fabric/peer目录中，如果要部署在其它目录中，需要修改配置文件中路径。 这里需要用到一个data目录，存放peer的数据: mkdir peer0.org1.example.com/data peer1.org1.example.com 过程与peer0.org1.example.com类似，注意将配置文件中的名称修改为peer1，并且不要拷错证书。 这里直接复制peer0.org1.exampl.com目录，然后替换其中的文件。 cp -rf peer0.org1.example.com/ peer1.org1.example.com/ rm -rf peer1.org1.example.com/msp/ rm -rf peer1.org1.example.com/tls/ cp -rf certs/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/* peer1.org1.example.com/ 最后修改peer1.org1.example.com/core.yml，将其中的peer0.org1.exampl.com修改为peer1.org1.example.com，这里直接用sed命令替换: sed -i &quot;s/peer0.org1.example.com/peer1\.org1\.example.com/g&quot; peer1.org1.example.com/core.yaml peer0.org2.example.com 过程与peer0.org1.example.com类似，注意将配置文件中的名称修改为org2，并且不要拷错证书。 这里直接复制peer0.org1.exampl.com目录，然后替换其中的文件。 cp -rf peer0.org1.example.com/ peer0.org2.example.com/ rm -rf peer0.org2.example.com/msp/ rm -rf peer0.org2.example.com/tls/ cp -rf certs/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/* peer0.org2.example.com/ 最后修改peer0.org2.example.com/core.yml，将其中的peer0.org1.exampl.com修改为peer0.org2.example.com，这里直接用sed命令替换: sed -i &quot;s/peer0.org1.example.com/peer0\.org2\.example.com/g&quot; peer0.org2.example.com/core.yaml 将配置文件中Org1MSP替换成Org2MSP: sed -i &quot;s/Org1MSP/Org2MSP/g&quot; peer0.org2.example.com/core.yaml 开始部署 部署之前，先确保已经在每台机器的/etc/hosts文件中添加下列的记录： 192.168.88.10 orderer.example.com 192.168.88.10 peer0.org1.example.com 192.168.88.11 peer1.org1.example.com 192.168.88.12 peer0.org2.example.com 注意根据你自己的环境情况修改。 在192.168.88.10上创建目录: mkdir -p /opt/app/fabric/{orderer,peer} 将orderer.example.com和peer0.org1.exmaple.com中的内容复制到192.168.88.10: scp -r orderer.example.com/* root@192.168.88.10:/opt/app/fabric/orderer/ scp -r peer0.org1.example.com/* root@192.168.88.10:/opt/app/fabric/peer/ 在192.168.88.11上创建目录: mkdir -p /opt/app/fabric/peer 将peer1.org1.exmaple.com中的内容复制到192.168.88.11: scp -r peer1.org1.example.com/* root@192.168.88.11:/opt/app/fabric/peer/ 在192.168.88.12上创建目录: mkdir -p /opt/app/fabric/peer 将peer0.org2.exmaple.com中的内容复制到192.168.88.12: scp -r peer0.org2.example.com/* root@192.168.88.12:/opt/app/fabric/peer/ 启动前准备 order、peer都部署到位，但是对我这里示意的场景，需要的文件并不齐备。 查看orderer.yaml文件，你会看到有这样几行： GenesisMethod: file GenesisFile: ./genesisblock GenesisProfile: SampleInsecureSolo 前两行配置了创世块的获取方式。第一个区块的获取方式有多种，这里采用最简单的一种做法，用configtxgen生成。 没有在前面的步骤中一次生成所有需要的文件是因为，如果你修改了配置、使用了其它的方式，可能不需要这里的操作。 回到存放了所有文件的fabric-deploy目录中，创建一个名为configtx.yaml的文件： Profiles: TwoOrgsOrdererGenesis: Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Consortiums: SampleConsortium: Organizations: - *Org1 - *Org2 TwoOrgsChannel: Consortium: SampleConsortium Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 - *Org2 Organizations: - &amp;OrdererOrg Name: OrdererOrg ID: OrdererMSP MSPDir: ./certs/ordererOrganizations/example.com/msp - &amp;Org1 Name: Org1MSP ID: Org1MSP MSPDir: ./certs/peerOrganizations/org1.example.com/msp AnchorPeers: - Host: peer0.org1.example.com Port: 7051 - &amp;Org2 Name: Org2MSP ID: Org2MSP MSPDir: ./certs/peerOrganizations/org2.example.com/msp AnchorPeers: - Host: peer0.org2.example.com Port: 7051 Orderer: &amp;OrdererDefaults OrdererType: solo Addresses: - orderer.example.com:7050 BatchTimeout: 2s BatchSize: MaxMessageCount: 10 AbsoluteMaxBytes: 99 MB PreferredMaxBytes: 512 KB Kafka: Brokers: - 127.0.0.1:9092 Organizations: Application: &amp;ApplicationDefaults Organizations: 这个配置文件的内容比较多，这里就不做解释了，可以到视频解说中听讲解。 直接用./bin/configtxgen生成创世块文件。 ./bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./genesisblock 将./genesisblock文件复制到192.168.88.10的/opt/app/fabric/orderer/目录中: scp genesisblock root@192.168.88.10:/opt/app/fabric/orderer/ 启动 分别到每台机器到orderer、peer目录中启动： ./orderer &amp; ./peer node start &amp; 为了方便查看输出的日志，可以写一个脚本： $ cat start.sh ./orderer 2&gt;&amp;1 |tee log peer的脚本如下： $ cat start.sh ./peer node start 2&gt;&amp;1 |tee log 然后将脚本放到后台运行： $ ./start.sh &amp; 如果程序启动失败，那么核实之前的步骤。或者到右侧的“区块链实践分享”知识星球中咨询。 用户 要使用得先有用户。在前面用cryptogen准备证书的时候，它默认创建了用户。 还记得certs目录下的几个users目录吗？那里面就是用户证书。 users目录一共有三个，分别是联盟的用户，和每个组织的用户： ./certs/ordererOrganizations/example.com/users ./certs/peerOrganizations/org1.example.com/users ./certs/peerOrganizations/org2.example.com/users 其中每个组织有两个用户，Admin和User1： $ ls ./certs/peerOrganizations/org1.example.com/users Admin@org1.example.com User1@org1.example.com Admin和User1唯一的区别是，Admin的用户证书被添加到了对一个peer的msp/admincerts目录中。（还记得这个目录的作用吗？） Admin@org1.example.com 使用hyperledger fabric可以通过SDK，也可以使用peer命令。 这里直接演示peer命令的用法。 在fabric-deploy中创建目录Admin@org1.example.com，在其中存放该用户的所有资料。 mkdir Admin@org1.example.com 将用户证书复制到其中： cp -rf certs/peerOrganizations/org1.example.com/users/Admin\@org1.example.com/* Admin\@org1.example.com/ 还需要将core.yaml复制到用户目录下： cp peer0.org1.example.com/core.yaml Admin\@org1.example.com/ 为了方便使用，在Admin@org1.example.com中创建一个peer.sh脚本： #!/bin/bash PATH=`pwd`/../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=cli export CORE_LOGGING_LEVEL=INFO peer $* 然后直接通过这个脚本访问peer0.org1.example.com: $ ./peer.sh node status status:STARTED 2018-04-29 14:32:03.517 CST [main] main -&gt; INFO 001 Exiting..... 可以看到peer0.org1.example.com:7051的状态是启动的。 为了后面的演示，下面使用复制替换的方式，准备另外两个用户的目录。 User1@org1.example.com User1与Admin1使用相同的peer，因此只需要替换用户证书即可： cp -rf Admin\@org1.example.com/ User1\@org1.example.com/ rm -rf User1\@org1.example.com/msp rm -rf User1\@org1.example.com/tls cp -rf certs/peerOrganizations/org1.example.com/users/User1\@org1.example.com/* User1\@org1.example.com/ 执行peer.sh检验： $ ./peer.sh node status status:STARTED 2018-04-29 14:37:48.251 CST [main] main -&gt; INFO 001 Exiting..... Admin@org2.example.com 对于Admin@org2.example.com，core.yaml也需要替换： cp -rf Admin\@org1.example.com/ Admin\@org2.example.com/ rm -rf Admin\@org2.example.com/msp/ rm -rf Admin\@org2.example.com/tls/ cp -rf certs/peerOrganizations/org2.example.com/users/Admin\@org2.example.com/* Admin\@org2.example.com/ cp peer0.org2.example.com/core.yaml Admin\@org2.example.com/ 还需要将peer.sh中peer地址修改为org2的peer地址： export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP 修改为： export CORE_PEER_ADDRESS=peer0.org2.example.com:7051 export CORE_PEER_LOCALMSPID=Org2MSP 验证： $ ./peer.sh node status status:STARTED 2018-04-29 14:44:22.395 CST [main] main -&gt; INFO 001 Exiting..... 创建channel与peer的设置 准备channel文件 这里用命令行演示channel的创建与peer的设置。(也可以通过SDK，SDK将单独讨论） 需要再次回到fabric-deploy目录中，用configtxgen生成channel文件： ./bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx mychannel.tx -channelID mychannel channel名字为mychannel，生成的mychannel.tx备用。 还需要为每个组织的peer生成一个anchor文件，每个组织只需要一个： ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP 生成的Org1MSPanchors.tx和Org2MSPanchors.tx备用。 下一步操作中需要访问orderer.example.com，需要将验证orderer.example.com的证书复制到用户目录中： cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem Admin\@org1.example.com/ cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem User1\@org1.example.com/ cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem Admin\@org2.example.com/ 创建channel 在Admin@org1.exampl.com目录中执行下面的命令，： ./peer.sh channel create -o orderer.example.com:7050 -c mychannel -f ../mychannel.tx --tls true --cafile tlsca.example.com-cert.pem 执行完成后，会生成一个mychannel.block文件： $ ls core.yaml msp mychannel.block peer.sh tls tlsca.example.com-cert.pem 将mychannel.block复制一份到Admin\@org2.example.com/中备用： cp Admin\@org1.example.com/mychannel.block Admin\@org2.example.com/ 将peer加入channel 分别在Admin\@org1.example.com/和Admin\@org2.example.com/执行下面的命令： ./peer.sh channel join -b mychannel.block 因为org1有两个peer，因此需要将peer.sh中peer修改为peer1.org1.example.com后，再添加一次： ./peer.sh channel join -b mychannel.block 可以用channel list查看peer所在channel $ ./peer.sh channel list 2018-04-29 16:37:47.016 CST [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized Channels peers has joined: mychannel 2018-04-29 16:37:47.018 CST [main] main -&gt; INFO 002 Exiting..... 最后需要每个组织指定一个anchor peer，anchor peer是组织用来与外部通信的peer: cd Admin\@org1.example.com/ ./peer.sh channel update -o orderer.example.com:7050 -c mychannel -f ../Org1MSPanchors.tx --tls true --cafile ./tlsca.example.com-cert.pem cd Admin\@org2.example.com/ ./peer.sh channel update -o orderer.example.com:7050 -c mychannel -f ../Org2MSPanchors.tx --tls true --cafile ./tlsca.example.com-cert.pem 安装合约（chaincode） 在hyperledger fabric中，合约被称为chaincode。 需要安装一个go语言的开发环境，安装方法这里就不介绍了。 这里将go的开发环境安装在fabric-deploy所在的机器上。 直接用go get获取一份合约代码： go get github.com/lijiaocn/fabric-chaincode-example/demo 到Admin@org1.example.com/目录下，以Admin@org1.example.com的身份打包合约: cd Admin\@org1.example.com/ 执行下面命令进行合约打包与签署： ./peer.sh chaincode package demo-pack.out -n demo -v 0.0.1 -s -S -p github.com/lijiaocn/fabric-chaincode-example/demo ./peer.sh chaincode signpackage demo-pack.out signed-demo-pack.out 然后安装合约： ./peer.sh chaincode install ./signed-demo-pack.out 安装之后，可以用chaincode list查看peer上已经安装的合约。 $ ./peer.sh chaincode list --installed Get installed chaincodes on peer: Name: demo, Version: 0.0.1, Path: github.com/lijiaocn/fabric-chaincode-example/demo, Id: 3d733bd28accf77b06b2bec065d8ce7315bd7c5441c51beea4650982f79eab46 2018-04-29 18:57:54.327 CST [main] main -&gt; INFO 001 Exiting.... chaincode只能用Admin安装，并且需要在每个peer上都安装一次。 因此需要将peer0.org1.example.com切换为peer1.org1.example.com后，再次安装一次： ./peer.sh chaincode install ./signed-demo-pack.out (不需要重新打包签署) 将signed-demo-pack.out复制到Admin@org2.exmaple.com中安装一次 cp Admin\@org1.example.com/signed-demo-pack.out Admin\@org2.example.com/ cd Admin\@org2.example.com/ ./peer.sh chaincode install ./signed-demo-pack.out 合约初始化 合约安装之后，需要进行一次初始化，只能由创建合约的用户进行初始化: cd Admin\@org1.example.com/ ./peer.sh chaincode instantiate -o orderer.example.com:7050 --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -v 0.0.1 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 第一进行合约初始化的时候的会比较慢，因为需要需要创建、启动容器。 合约调用 可以在任意一个peer上调用合约，例如以admin@org2.example.com的进行写操作： cd Admin\@org2.example.com/ ./peer.sh chaincode invoke -o orderer.example.com:7050 --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key1&quot;,&quot;key1 value is abc&quot;]}&#39; 如果是第一次在一个peer访问一个合约，这个peer需要先启动容器，响应会比较慢。进行写操作（invoke命令）时，需要指定orderer（-o orderer.example.com:7050）。 进行查询操作时，不需要指定orderer，例如： cd User1\@org1.example.com/ ./peer.sh chaincode query -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key1&quot;]}&#39; 更新合约 将更改后的合约重新打包，使用一个新的版本号： cd Admin\@org1.example.com/ 执行下面命令进行合约打包与签署： ./peer.sh chaincode package demo-pack-2.out -n demo -v 0.0.2 -s -S -p github.com/lijiaocn/fabric-chaincode-example/demo ./peer.sh chaincode signpackage demo-pack-2.out signed-demo-pack-2.out 然后安装合约： ./peer.sh chaincode install ./signed-demo-pack-2.out 更新的合约不需要初始化，需要进行更新操作： ./peer.sh chaincode upgrade -o orderer.example.com:7050 --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -v 0.0.2 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 新的合约也需要在每个peer上单独安装。 因此需要将peer0.org1.example.com切换为peer1.org1.example.com后，再次安装一次： ./peer.sh chaincode install ./signed-demo-pack-2.out (不需要重新打包签署) 将signed-demo-pack.out复制到Admin@org2.exmaple.com中安装一次 cp Admin\@org1.example.com/signed-demo-pack-2.out Admin\@org2.example.com/ cd Admin\@org2.example.com/ ./peer.sh chaincode install ./signed-demo-pack-2.out 视频纪录发布在：&nbsp;网易云课堂视频教程：HyperLedger Fabric全手动部署 可以到星球里找我要优惠券或者提问： 参考 Building Your First Network hyperledger fabric编译 hyperledger fabric download hyperledger的fabricCA的使用 hyperledger项目fabric的nodejsSDK的使用 网易云课堂视频教程：HyperLedger Fabric全手动部署 阅读更多" />
<meta property="og:description" content="原文地址：超级账本HyperLedger的Fabric项目的手动部署教程 说明 &nbsp; 虽然通过Building Your First Network中的docker-compose文件可以直接启动一个all-in-one的fabric。 但这种方式隐藏了太多的细节，只能让人有个模糊的认识，对生产环境中部署方式、多服务器部署，依然不清不楚， 对各组件的配置文件也完全不了解。 通过反复阅读Fabric的文档，以及Building Your First Network中的脚本，经历了诸多磨难之后，总算弄清楚了Fabric的组件间关系与配置项。 看文档感觉吃力或者一通操作后不知所以然的同学，可以使用网易云课堂视频教程：HyperLedger Fabric手动部署教程的视频讲解 说明 规划 编译或下载fabric文件 准备证书 cryptogen的方式 使用fabric-ca生成证书 orderer.example.com peer0.org1.example.com peer1.org1.example.com peer0.org2.example.com 开始部署 启动前准备 启动 用户 Admin@org1.example.com User1@org1.example.com Admin@org2.example.com 创建channel与peer的设置 准备channel文件 创建channel 将peer加入channel 安装合约（chaincode） 合约初始化 合约调用 更新合约 参考 规划 创建一个名为fabric-deploy的目录，用来存放部署过程使用到的文件。 mkdir ~/fabric-deploy 这里将用三台机器部署一个fabric网络，该网络中有两个组织: org1.example.com org2.example.com 一个order: orderer.example.com org1.example.com有两个peer: peer0.org1.example.com peer1.org1.example.com org2.example.com有一个peer: peer0.org2.example.com 三台机器的IP，以及部署的组件如下： 192.168.88.10 部署: orderer、peer0@org1 192.168.88.11 部署: peer1@org1 192.168.88.12 部署： peer0@org2 相应域名的IP分别为： 192.168.88.10 orderer.example.com 192.168.88.10 peer0.org1.example.com 192.168.88.11 peer1.org1.example.com 192.168.88.12 peer0.org2.example.com 将这四条记录添加到每台机器的/etc/hosts文件中。 每台机器上还需要安装docker: yum install -y docker systemctl start docker 另外fabric的peer会调用docker，需要在所有peer上安装docker，并提前下载镜像： docker pull hyperledger/fabric-javaenv:x86_64-1.1.0 docker pull hyperledger/fabric-ccenv:x86_64-1.1.0 docker pull hyperledger/fabric-baseos:x86_64-0.4.6 下载的镜像需要与下面步骤中创建的core.yaml中的镜像配对： ... chaincode: peerAddress: id: path: name: builder: $(DOCKER_NS)/fabric-ccenv:$(ARCH)-$(PROJECT_VERSION) golang: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) car: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) java: Dockerfile: | from $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION) ... 创建合约的时候会用到这些镜像，镜像下载可能比较慢，根据自己的情况配置加速器。另外每个peer上都需要下载。 我在”区块链实践分享”中提供的fabric-deploy中下载包中提供了这三个镜像，可以直接使用： cd fabric-deploy/docker-images ./load.sh 编译或下载fabric文件 编译方法见：hyperledger fabric编译 执行下面的命令可以下载编译好的fabric以及依赖的镜像： curl -sSL https://goo.gl/6wtTN5 | bash 或者直接到这里下载：&nbsp;hyperledger fabric download 这里使用的linux-amd64，fabric-1.1.0: wget https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/linux-amd64-1.1.0/hyperledger-fabric-linux-amd64-1.1.0.tar.gz wget https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/linux-amd64-1.1.0/hyperledger-fabric-linux-amd64-1.1.0.tar.gz.md5 下载完成后校验一下： $ md5sum hyperledger-fabric-linux-amd64-1.1.0.tar.gz 6be979ccd903752aefba9da4fc9e1d44 hyperledger-fabric-linux-amd64-1.1.0.tar.gz $ cat hyperledger-fabric-linux-amd64-1.1.0.tar.gz.md5 6be979ccd903752aefba9da4fc9e1d44 解压后得到两个bin和config两个目录: tar -xvf hyperledger-fabric-linux-amd64-1.1.0.tar.gz bin目录中是fabric的组件，config是配置文件模版。 $ ls bin/ configtxgen configtxlator cryptogen get-byfn.sh get-docker-images.sh orderer peer $ ls config/ configtx.yaml core.yaml orderer.yaml 保留备用。 准备证书 证书的准备方式有两种，一种用cryptogen命令生成，一种是通过fabric-ca服务生成。 cryptogen的方式 创建一个配置文件crypto-config.yaml，这里配置了两个组织，org1的Count是2，表示两个peer： OrdererOrgs: - Name: Orderer Domain: example.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.example.com Template: Count: 2 Users: Count: 1 - Name: Org2 Domain: org2.example.com Template: Count: 1 Users: Count: 1 然后执行crypto，生成证书： ./bin/cryptogen generate --config=crypto-config.yaml --output ./certs certs目录下生成了两个目录： $ ls ./certs/ ordererOrganizations peerOrganizations certs目录的内容比较多，并且目录很深，需要提前说明一下。搞清楚了这里面文件的含义，就懂了一半。 以certs/ordererOrganizations/example.com/orderers/orderer.example.com/目录中内容为例。 这里目录中的内容是用于orderer.example.com的，里面有两个子目录tls和msp： $ tree certs/ordererOrganizations/example.com/orderers/orderer.example.com/ certs/ordererOrganizations/example.com/orderers/orderer.example.com/ |-- msp | |-- admincerts | | -- Admin@example.com-cert.pem | |-- cacerts | | -- ca.example.com-cert.pem | |-- keystore | | -- 16da15d400d4ca4b53d369b6d6e50a084d4354998c3b4d7a0934635d3907f90f_sk | |-- signcerts | | -- orderer.example.com-cert.pem | -- tlscacerts | -- tlsca.example.com-cert.pem -- tls |-- ca.crt |-- server.crt -- server.key tls目录中的内容很好理解，它是order对外服务时使用的私钥(server.key)和证书(server.crt)，ca.crt是签注这个证书的CA，需要提供给发起请求的一端。 msp中有五个目录，对区块链进行操作时需要使用这些文件。 msp/admincerts中存放的是用户证书，使用该证书的用户对orderer.example.com具有管理权限。 msp/cacerts是签署msp/signcerts中用户证书的ca，可以用来校验用户的证书： $ cd ./certs/ordererOrganizations/example.com/orderers/orderer.example.com/msp/ $ openssl verify -CAfile ./cacerts/ca.example.com-cert.pem admincerts/Admin\@example.com-cert.pem admincerts/Admin@example.com-cert.pem: OK msp/keystore是orderer.example.com操作区块，进行签署时使用的的私钥。 msp/signcerts是orderer.example.com提供其它组件用来核实它的签署的公钥。 msp/tlscacerts文件与tls/ca.crt相同。 这里需要特别提到的是msp/admincerts，在使用fabric时，你可能会发现有些操作需要admin权限，例如在某个peer上安装合约。 那么管理员是如何认定的？就是看当前用户的证书是不是在msp/admincerts目录中。 这个目录中的内容目前是(版本1.1.x)启动时加载的，因此如果在里面添加或删除文件后，需要重启使用到它的组件。 在ordererOrganizations/example.com/还有其它几个目录： ca msp orderers tlsca users orderers中存放就签名分析的每个orderer组件的证书文件。 users中存放的用户的证书文件，与orderer.example.com中内容基本相同，不过tls目录中文件名变成了client.X： $ tree ordererOrganizations/example.com/users ordererOrganizations/example.com/users -- Admin@example.com |-- msp | |-- admincerts | | -- Admin@example.com-cert.pem | |-- cacerts | | -- ca.example.com-cert.pem | |-- keystore | | -- 1ac3b40c9ddda7e7a0f724b18faa0ce6fdf3f9e9ff5eac59e1e3f9739499ac2d_sk | |-- signcerts | | -- Admin@example.com-cert.pem | -- tlscacerts | -- tlsca.example.com-cert.pem -- tls |-- ca.crt |-- client.crt -- client.key certs/peerOrganizations中的内容与certs/ordererOrganizations中也基本相同，只不过它里面存放的是peer要使用的证书文件。 certs目录中的文件留着备用。 使用fabric-ca生成证书 fabric-ca的部署和详细用法见：hyperledger的fabricCA的使用 只用fabric-ca生成证书的过程相对繁琐很多，需要为每个组件、每个用户生成，这里不做示例。 orderer.example.com 建一个目录存放orderer.example.com需要文件： mkdir orderer.example.com 先将bin/orderer以及证书复制到orderer.example.com目录中。 cp bin/orderer orderer.example.com/ cp -rf certs/ordererOrganizations/example.com/orderers/orderer.example.com/* orderer.example.com/ 然后准备orderer的配置文件orderer.yaml: General: LedgerType: file ListenAddress: 0.0.0.0 ListenPort: 7050 TLS: Enabled: true PrivateKey: ./tls/server.key Certificate: ./tls/server.crt RootCAs: - ./tls/ca.crt # ClientAuthEnabled: false # ClientRootCAs: LogLevel: debug LogFormat: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; # GenesisMethod: provisional GenesisMethod: file GenesisProfile: SampleInsecureSolo GenesisFile: ./genesisblock LocalMSPDir: ./msp LocalMSPID: OrdererMSP Profile: Enabled: false Address: 0.0.0.0:6060 BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: FileLedger: Location: /opt/app/fabric/orderer/data Prefix: hyperledger-fabric-ordererledger RAMLedger: HistorySize: 1000 Kafka: Retry: ShortInterval: 5s ShortTotal: 10m LongInterval: 5m LongTotal: 12h NetworkTimeouts: DialTimeout: 10s ReadTimeout: 10s WriteTimeout: 10s Metadata: RetryBackoff: 250ms RetryMax: 3 Producer: RetryBackoff: 100ms RetryMax: 3 Consumer: RetryBackoff: 2s Verbose: false TLS: Enabled: false PrivateKey: #File: path/to/PrivateKey Certificate: #File: path/to/Certificate RootCAs: #File: path/to/RootCAs Version: 注意，orderer将被部署在目标机器的/opt/apt/fabric/orderer目录中，如果要部署在其它目录中，需要修改配置文件中路径。 这里需要用到一个data目录，存放orderer的数据: mkdir orderer.example.com/data peer0.org1.example.com 建一个目录存放peer0.org1.example.com需要文件： mkdir peer0.org1.example.com 先将bin/peer以及证书复制到peer0.org1.example.com目录中。 cp bin/peer peer0.org1.example.com/ cp -rf certs/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/* peer0.org1.example.com/ 准备peer0.org1.example.com的配置文件core.yaml： logging: peer: debug cauthdsl: warning gossip: warning ledger: info msp: warning policies: warning grpc: error format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; peer: id: peer0.org1.example.com networkId: dev listenAddress: 0.0.0.0:7051 address: 0.0.0.0:7051 addressAutoDetect: false gomaxprocs: -1 gossip: bootstrap: 127.0.0.1:7051 bootstrap: peer0.org1.example.com:7051 useLeaderElection: true orgLeader: false endpoint: maxBlockCountToStore: 100 maxPropagationBurstLatency: 10ms maxPropagationBurstSize: 10 propagateIterations: 1 propagatePeerNum: 3 pullInterval: 4s pullPeerNum: 3 requestStateInfoInterval: 4s publishStateInfoInterval: 4s stateInfoRetentionInterval: publishCertPeriod: 10s skipBlockVerification: false dialTimeout: 3s connTimeout: 2s recvBuffSize: 20 sendBuffSize: 200 digestWaitTime: 1s requestWaitTime: 1s responseWaitTime: 2s aliveTimeInterval: 5s aliveExpirationTimeout: 25s reconnectInterval: 25s externalEndpoint: peer0.org1.example.com:7051 election: startupGracePeriod: 15s membershipSampleInterval: 1s leaderAliveThreshold: 10s leaderElectionDuration: 5s events: address: 0.0.0.0:7053 buffersize: 100 timeout: 10ms tls: enabled: true cert: file: ./tls/server.crt key: file: ./tls/server.key rootcert: file: ./tls/ca.crt serverhostoverride: fileSystemPath: /opt/app/fabric/peer/data BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: mspConfigPath: msp localMspId: Org1MSP profile: enabled: true listenAddress: 0.0.0.0:6060 vm: endpoint: unix:///var/run/docker.sock docker: tls: enabled: false ca: file: docker/ca.crt cert: file: docker/tls.crt key: file: docker/tls.key attachStdout: false hostConfig: NetworkMode: host Dns: # - 192.168.0.1 LogConfig: Type: json-file Config: max-size: &quot;50m&quot; max-file: &quot;5&quot; Memory: 2147483648 chaincode: peerAddress: id: path: name: builder: $(DOCKER_NS)/fabric-ccenv:$(ARCH)-$(PROJECT_VERSION) golang: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) car: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) java: Dockerfile: | from $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION) startuptimeout: 300s executetimeout: 30s mode: net keepalive: 0 system: cscc: enable lscc: enable escc: enable vscc: enable qscc: enable logging: level: info shim: warning format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; ledger: blockchain: state: stateDatabase: goleveldb couchDBConfig: couchDBAddress: 127.0.0.1:5984 username: password: maxRetries: 3 maxRetriesOnStartup: 10 requestTimeout: 35s queryLimit: 10000 history: enableHistoryDatabase: true 注意，peer将被部署在目标机器的/opt/apt/fabric/peer目录中，如果要部署在其它目录中，需要修改配置文件中路径。 这里需要用到一个data目录，存放peer的数据: mkdir peer0.org1.example.com/data peer1.org1.example.com 过程与peer0.org1.example.com类似，注意将配置文件中的名称修改为peer1，并且不要拷错证书。 这里直接复制peer0.org1.exampl.com目录，然后替换其中的文件。 cp -rf peer0.org1.example.com/ peer1.org1.example.com/ rm -rf peer1.org1.example.com/msp/ rm -rf peer1.org1.example.com/tls/ cp -rf certs/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/* peer1.org1.example.com/ 最后修改peer1.org1.example.com/core.yml，将其中的peer0.org1.exampl.com修改为peer1.org1.example.com，这里直接用sed命令替换: sed -i &quot;s/peer0.org1.example.com/peer1\.org1\.example.com/g&quot; peer1.org1.example.com/core.yaml peer0.org2.example.com 过程与peer0.org1.example.com类似，注意将配置文件中的名称修改为org2，并且不要拷错证书。 这里直接复制peer0.org1.exampl.com目录，然后替换其中的文件。 cp -rf peer0.org1.example.com/ peer0.org2.example.com/ rm -rf peer0.org2.example.com/msp/ rm -rf peer0.org2.example.com/tls/ cp -rf certs/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/* peer0.org2.example.com/ 最后修改peer0.org2.example.com/core.yml，将其中的peer0.org1.exampl.com修改为peer0.org2.example.com，这里直接用sed命令替换: sed -i &quot;s/peer0.org1.example.com/peer0\.org2\.example.com/g&quot; peer0.org2.example.com/core.yaml 将配置文件中Org1MSP替换成Org2MSP: sed -i &quot;s/Org1MSP/Org2MSP/g&quot; peer0.org2.example.com/core.yaml 开始部署 部署之前，先确保已经在每台机器的/etc/hosts文件中添加下列的记录： 192.168.88.10 orderer.example.com 192.168.88.10 peer0.org1.example.com 192.168.88.11 peer1.org1.example.com 192.168.88.12 peer0.org2.example.com 注意根据你自己的环境情况修改。 在192.168.88.10上创建目录: mkdir -p /opt/app/fabric/{orderer,peer} 将orderer.example.com和peer0.org1.exmaple.com中的内容复制到192.168.88.10: scp -r orderer.example.com/* root@192.168.88.10:/opt/app/fabric/orderer/ scp -r peer0.org1.example.com/* root@192.168.88.10:/opt/app/fabric/peer/ 在192.168.88.11上创建目录: mkdir -p /opt/app/fabric/peer 将peer1.org1.exmaple.com中的内容复制到192.168.88.11: scp -r peer1.org1.example.com/* root@192.168.88.11:/opt/app/fabric/peer/ 在192.168.88.12上创建目录: mkdir -p /opt/app/fabric/peer 将peer0.org2.exmaple.com中的内容复制到192.168.88.12: scp -r peer0.org2.example.com/* root@192.168.88.12:/opt/app/fabric/peer/ 启动前准备 order、peer都部署到位，但是对我这里示意的场景，需要的文件并不齐备。 查看orderer.yaml文件，你会看到有这样几行： GenesisMethod: file GenesisFile: ./genesisblock GenesisProfile: SampleInsecureSolo 前两行配置了创世块的获取方式。第一个区块的获取方式有多种，这里采用最简单的一种做法，用configtxgen生成。 没有在前面的步骤中一次生成所有需要的文件是因为，如果你修改了配置、使用了其它的方式，可能不需要这里的操作。 回到存放了所有文件的fabric-deploy目录中，创建一个名为configtx.yaml的文件： Profiles: TwoOrgsOrdererGenesis: Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Consortiums: SampleConsortium: Organizations: - *Org1 - *Org2 TwoOrgsChannel: Consortium: SampleConsortium Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 - *Org2 Organizations: - &amp;OrdererOrg Name: OrdererOrg ID: OrdererMSP MSPDir: ./certs/ordererOrganizations/example.com/msp - &amp;Org1 Name: Org1MSP ID: Org1MSP MSPDir: ./certs/peerOrganizations/org1.example.com/msp AnchorPeers: - Host: peer0.org1.example.com Port: 7051 - &amp;Org2 Name: Org2MSP ID: Org2MSP MSPDir: ./certs/peerOrganizations/org2.example.com/msp AnchorPeers: - Host: peer0.org2.example.com Port: 7051 Orderer: &amp;OrdererDefaults OrdererType: solo Addresses: - orderer.example.com:7050 BatchTimeout: 2s BatchSize: MaxMessageCount: 10 AbsoluteMaxBytes: 99 MB PreferredMaxBytes: 512 KB Kafka: Brokers: - 127.0.0.1:9092 Organizations: Application: &amp;ApplicationDefaults Organizations: 这个配置文件的内容比较多，这里就不做解释了，可以到视频解说中听讲解。 直接用./bin/configtxgen生成创世块文件。 ./bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./genesisblock 将./genesisblock文件复制到192.168.88.10的/opt/app/fabric/orderer/目录中: scp genesisblock root@192.168.88.10:/opt/app/fabric/orderer/ 启动 分别到每台机器到orderer、peer目录中启动： ./orderer &amp; ./peer node start &amp; 为了方便查看输出的日志，可以写一个脚本： $ cat start.sh ./orderer 2&gt;&amp;1 |tee log peer的脚本如下： $ cat start.sh ./peer node start 2&gt;&amp;1 |tee log 然后将脚本放到后台运行： $ ./start.sh &amp; 如果程序启动失败，那么核实之前的步骤。或者到右侧的“区块链实践分享”知识星球中咨询。 用户 要使用得先有用户。在前面用cryptogen准备证书的时候，它默认创建了用户。 还记得certs目录下的几个users目录吗？那里面就是用户证书。 users目录一共有三个，分别是联盟的用户，和每个组织的用户： ./certs/ordererOrganizations/example.com/users ./certs/peerOrganizations/org1.example.com/users ./certs/peerOrganizations/org2.example.com/users 其中每个组织有两个用户，Admin和User1： $ ls ./certs/peerOrganizations/org1.example.com/users Admin@org1.example.com User1@org1.example.com Admin和User1唯一的区别是，Admin的用户证书被添加到了对一个peer的msp/admincerts目录中。（还记得这个目录的作用吗？） Admin@org1.example.com 使用hyperledger fabric可以通过SDK，也可以使用peer命令。 这里直接演示peer命令的用法。 在fabric-deploy中创建目录Admin@org1.example.com，在其中存放该用户的所有资料。 mkdir Admin@org1.example.com 将用户证书复制到其中： cp -rf certs/peerOrganizations/org1.example.com/users/Admin\@org1.example.com/* Admin\@org1.example.com/ 还需要将core.yaml复制到用户目录下： cp peer0.org1.example.com/core.yaml Admin\@org1.example.com/ 为了方便使用，在Admin@org1.example.com中创建一个peer.sh脚本： #!/bin/bash PATH=`pwd`/../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=cli export CORE_LOGGING_LEVEL=INFO peer $* 然后直接通过这个脚本访问peer0.org1.example.com: $ ./peer.sh node status status:STARTED 2018-04-29 14:32:03.517 CST [main] main -&gt; INFO 001 Exiting..... 可以看到peer0.org1.example.com:7051的状态是启动的。 为了后面的演示，下面使用复制替换的方式，准备另外两个用户的目录。 User1@org1.example.com User1与Admin1使用相同的peer，因此只需要替换用户证书即可： cp -rf Admin\@org1.example.com/ User1\@org1.example.com/ rm -rf User1\@org1.example.com/msp rm -rf User1\@org1.example.com/tls cp -rf certs/peerOrganizations/org1.example.com/users/User1\@org1.example.com/* User1\@org1.example.com/ 执行peer.sh检验： $ ./peer.sh node status status:STARTED 2018-04-29 14:37:48.251 CST [main] main -&gt; INFO 001 Exiting..... Admin@org2.example.com 对于Admin@org2.example.com，core.yaml也需要替换： cp -rf Admin\@org1.example.com/ Admin\@org2.example.com/ rm -rf Admin\@org2.example.com/msp/ rm -rf Admin\@org2.example.com/tls/ cp -rf certs/peerOrganizations/org2.example.com/users/Admin\@org2.example.com/* Admin\@org2.example.com/ cp peer0.org2.example.com/core.yaml Admin\@org2.example.com/ 还需要将peer.sh中peer地址修改为org2的peer地址： export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP 修改为： export CORE_PEER_ADDRESS=peer0.org2.example.com:7051 export CORE_PEER_LOCALMSPID=Org2MSP 验证： $ ./peer.sh node status status:STARTED 2018-04-29 14:44:22.395 CST [main] main -&gt; INFO 001 Exiting..... 创建channel与peer的设置 准备channel文件 这里用命令行演示channel的创建与peer的设置。(也可以通过SDK，SDK将单独讨论） 需要再次回到fabric-deploy目录中，用configtxgen生成channel文件： ./bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx mychannel.tx -channelID mychannel channel名字为mychannel，生成的mychannel.tx备用。 还需要为每个组织的peer生成一个anchor文件，每个组织只需要一个： ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP 生成的Org1MSPanchors.tx和Org2MSPanchors.tx备用。 下一步操作中需要访问orderer.example.com，需要将验证orderer.example.com的证书复制到用户目录中： cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem Admin\@org1.example.com/ cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem User1\@org1.example.com/ cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem Admin\@org2.example.com/ 创建channel 在Admin@org1.exampl.com目录中执行下面的命令，： ./peer.sh channel create -o orderer.example.com:7050 -c mychannel -f ../mychannel.tx --tls true --cafile tlsca.example.com-cert.pem 执行完成后，会生成一个mychannel.block文件： $ ls core.yaml msp mychannel.block peer.sh tls tlsca.example.com-cert.pem 将mychannel.block复制一份到Admin\@org2.example.com/中备用： cp Admin\@org1.example.com/mychannel.block Admin\@org2.example.com/ 将peer加入channel 分别在Admin\@org1.example.com/和Admin\@org2.example.com/执行下面的命令： ./peer.sh channel join -b mychannel.block 因为org1有两个peer，因此需要将peer.sh中peer修改为peer1.org1.example.com后，再添加一次： ./peer.sh channel join -b mychannel.block 可以用channel list查看peer所在channel $ ./peer.sh channel list 2018-04-29 16:37:47.016 CST [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized Channels peers has joined: mychannel 2018-04-29 16:37:47.018 CST [main] main -&gt; INFO 002 Exiting..... 最后需要每个组织指定一个anchor peer，anchor peer是组织用来与外部通信的peer: cd Admin\@org1.example.com/ ./peer.sh channel update -o orderer.example.com:7050 -c mychannel -f ../Org1MSPanchors.tx --tls true --cafile ./tlsca.example.com-cert.pem cd Admin\@org2.example.com/ ./peer.sh channel update -o orderer.example.com:7050 -c mychannel -f ../Org2MSPanchors.tx --tls true --cafile ./tlsca.example.com-cert.pem 安装合约（chaincode） 在hyperledger fabric中，合约被称为chaincode。 需要安装一个go语言的开发环境，安装方法这里就不介绍了。 这里将go的开发环境安装在fabric-deploy所在的机器上。 直接用go get获取一份合约代码： go get github.com/lijiaocn/fabric-chaincode-example/demo 到Admin@org1.example.com/目录下，以Admin@org1.example.com的身份打包合约: cd Admin\@org1.example.com/ 执行下面命令进行合约打包与签署： ./peer.sh chaincode package demo-pack.out -n demo -v 0.0.1 -s -S -p github.com/lijiaocn/fabric-chaincode-example/demo ./peer.sh chaincode signpackage demo-pack.out signed-demo-pack.out 然后安装合约： ./peer.sh chaincode install ./signed-demo-pack.out 安装之后，可以用chaincode list查看peer上已经安装的合约。 $ ./peer.sh chaincode list --installed Get installed chaincodes on peer: Name: demo, Version: 0.0.1, Path: github.com/lijiaocn/fabric-chaincode-example/demo, Id: 3d733bd28accf77b06b2bec065d8ce7315bd7c5441c51beea4650982f79eab46 2018-04-29 18:57:54.327 CST [main] main -&gt; INFO 001 Exiting.... chaincode只能用Admin安装，并且需要在每个peer上都安装一次。 因此需要将peer0.org1.example.com切换为peer1.org1.example.com后，再次安装一次： ./peer.sh chaincode install ./signed-demo-pack.out (不需要重新打包签署) 将signed-demo-pack.out复制到Admin@org2.exmaple.com中安装一次 cp Admin\@org1.example.com/signed-demo-pack.out Admin\@org2.example.com/ cd Admin\@org2.example.com/ ./peer.sh chaincode install ./signed-demo-pack.out 合约初始化 合约安装之后，需要进行一次初始化，只能由创建合约的用户进行初始化: cd Admin\@org1.example.com/ ./peer.sh chaincode instantiate -o orderer.example.com:7050 --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -v 0.0.1 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 第一进行合约初始化的时候的会比较慢，因为需要需要创建、启动容器。 合约调用 可以在任意一个peer上调用合约，例如以admin@org2.example.com的进行写操作： cd Admin\@org2.example.com/ ./peer.sh chaincode invoke -o orderer.example.com:7050 --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key1&quot;,&quot;key1 value is abc&quot;]}&#39; 如果是第一次在一个peer访问一个合约，这个peer需要先启动容器，响应会比较慢。进行写操作（invoke命令）时，需要指定orderer（-o orderer.example.com:7050）。 进行查询操作时，不需要指定orderer，例如： cd User1\@org1.example.com/ ./peer.sh chaincode query -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key1&quot;]}&#39; 更新合约 将更改后的合约重新打包，使用一个新的版本号： cd Admin\@org1.example.com/ 执行下面命令进行合约打包与签署： ./peer.sh chaincode package demo-pack-2.out -n demo -v 0.0.2 -s -S -p github.com/lijiaocn/fabric-chaincode-example/demo ./peer.sh chaincode signpackage demo-pack-2.out signed-demo-pack-2.out 然后安装合约： ./peer.sh chaincode install ./signed-demo-pack-2.out 更新的合约不需要初始化，需要进行更新操作： ./peer.sh chaincode upgrade -o orderer.example.com:7050 --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -v 0.0.2 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 新的合约也需要在每个peer上单独安装。 因此需要将peer0.org1.example.com切换为peer1.org1.example.com后，再次安装一次： ./peer.sh chaincode install ./signed-demo-pack-2.out (不需要重新打包签署) 将signed-demo-pack.out复制到Admin@org2.exmaple.com中安装一次 cp Admin\@org1.example.com/signed-demo-pack-2.out Admin\@org2.example.com/ cd Admin\@org2.example.com/ ./peer.sh chaincode install ./signed-demo-pack-2.out 视频纪录发布在：&nbsp;网易云课堂视频教程：HyperLedger Fabric全手动部署 可以到星球里找我要优惠券或者提问： 参考 Building Your First Network hyperledger fabric编译 hyperledger fabric download hyperledger的fabricCA的使用 hyperledger项目fabric的nodejsSDK的使用 网易云课堂视频教程：HyperLedger Fabric全手动部署 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/05/09/0ffbbb90f77c188a9998d926648082ab.html" />
<meta property="og:url" content="https://mlh.app/2018/05/09/0ffbbb90f77c188a9998d926648082ab.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"原文地址：超级账本HyperLedger的Fabric项目的手动部署教程 说明 &nbsp; 虽然通过Building Your First Network中的docker-compose文件可以直接启动一个all-in-one的fabric。 但这种方式隐藏了太多的细节，只能让人有个模糊的认识，对生产环境中部署方式、多服务器部署，依然不清不楚， 对各组件的配置文件也完全不了解。 通过反复阅读Fabric的文档，以及Building Your First Network中的脚本，经历了诸多磨难之后，总算弄清楚了Fabric的组件间关系与配置项。 看文档感觉吃力或者一通操作后不知所以然的同学，可以使用网易云课堂视频教程：HyperLedger Fabric手动部署教程的视频讲解 说明 规划 编译或下载fabric文件 准备证书 cryptogen的方式 使用fabric-ca生成证书 orderer.example.com peer0.org1.example.com peer1.org1.example.com peer0.org2.example.com 开始部署 启动前准备 启动 用户 Admin@org1.example.com User1@org1.example.com Admin@org2.example.com 创建channel与peer的设置 准备channel文件 创建channel 将peer加入channel 安装合约（chaincode） 合约初始化 合约调用 更新合约 参考 规划 创建一个名为fabric-deploy的目录，用来存放部署过程使用到的文件。 mkdir ~/fabric-deploy 这里将用三台机器部署一个fabric网络，该网络中有两个组织: org1.example.com org2.example.com 一个order: orderer.example.com org1.example.com有两个peer: peer0.org1.example.com peer1.org1.example.com org2.example.com有一个peer: peer0.org2.example.com 三台机器的IP，以及部署的组件如下： 192.168.88.10 部署: orderer、peer0@org1 192.168.88.11 部署: peer1@org1 192.168.88.12 部署： peer0@org2 相应域名的IP分别为： 192.168.88.10 orderer.example.com 192.168.88.10 peer0.org1.example.com 192.168.88.11 peer1.org1.example.com 192.168.88.12 peer0.org2.example.com 将这四条记录添加到每台机器的/etc/hosts文件中。 每台机器上还需要安装docker: yum install -y docker systemctl start docker 另外fabric的peer会调用docker，需要在所有peer上安装docker，并提前下载镜像： docker pull hyperledger/fabric-javaenv:x86_64-1.1.0 docker pull hyperledger/fabric-ccenv:x86_64-1.1.0 docker pull hyperledger/fabric-baseos:x86_64-0.4.6 下载的镜像需要与下面步骤中创建的core.yaml中的镜像配对： ... chaincode: peerAddress: id: path: name: builder: $(DOCKER_NS)/fabric-ccenv:$(ARCH)-$(PROJECT_VERSION) golang: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) car: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) java: Dockerfile: | from $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION) ... 创建合约的时候会用到这些镜像，镜像下载可能比较慢，根据自己的情况配置加速器。另外每个peer上都需要下载。 我在”区块链实践分享”中提供的fabric-deploy中下载包中提供了这三个镜像，可以直接使用： cd fabric-deploy/docker-images ./load.sh 编译或下载fabric文件 编译方法见：hyperledger fabric编译 执行下面的命令可以下载编译好的fabric以及依赖的镜像： curl -sSL https://goo.gl/6wtTN5 | bash 或者直接到这里下载：&nbsp;hyperledger fabric download 这里使用的linux-amd64，fabric-1.1.0: wget https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/linux-amd64-1.1.0/hyperledger-fabric-linux-amd64-1.1.0.tar.gz wget https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/linux-amd64-1.1.0/hyperledger-fabric-linux-amd64-1.1.0.tar.gz.md5 下载完成后校验一下： $ md5sum hyperledger-fabric-linux-amd64-1.1.0.tar.gz 6be979ccd903752aefba9da4fc9e1d44 hyperledger-fabric-linux-amd64-1.1.0.tar.gz $ cat hyperledger-fabric-linux-amd64-1.1.0.tar.gz.md5 6be979ccd903752aefba9da4fc9e1d44 解压后得到两个bin和config两个目录: tar -xvf hyperledger-fabric-linux-amd64-1.1.0.tar.gz bin目录中是fabric的组件，config是配置文件模版。 $ ls bin/ configtxgen configtxlator cryptogen get-byfn.sh get-docker-images.sh orderer peer $ ls config/ configtx.yaml core.yaml orderer.yaml 保留备用。 准备证书 证书的准备方式有两种，一种用cryptogen命令生成，一种是通过fabric-ca服务生成。 cryptogen的方式 创建一个配置文件crypto-config.yaml，这里配置了两个组织，org1的Count是2，表示两个peer： OrdererOrgs: - Name: Orderer Domain: example.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.example.com Template: Count: 2 Users: Count: 1 - Name: Org2 Domain: org2.example.com Template: Count: 1 Users: Count: 1 然后执行crypto，生成证书： ./bin/cryptogen generate --config=crypto-config.yaml --output ./certs certs目录下生成了两个目录： $ ls ./certs/ ordererOrganizations peerOrganizations certs目录的内容比较多，并且目录很深，需要提前说明一下。搞清楚了这里面文件的含义，就懂了一半。 以certs/ordererOrganizations/example.com/orderers/orderer.example.com/目录中内容为例。 这里目录中的内容是用于orderer.example.com的，里面有两个子目录tls和msp： $ tree certs/ordererOrganizations/example.com/orderers/orderer.example.com/ certs/ordererOrganizations/example.com/orderers/orderer.example.com/ |-- msp | |-- admincerts | | -- Admin@example.com-cert.pem | |-- cacerts | | -- ca.example.com-cert.pem | |-- keystore | | -- 16da15d400d4ca4b53d369b6d6e50a084d4354998c3b4d7a0934635d3907f90f_sk | |-- signcerts | | -- orderer.example.com-cert.pem | -- tlscacerts | -- tlsca.example.com-cert.pem -- tls |-- ca.crt |-- server.crt -- server.key tls目录中的内容很好理解，它是order对外服务时使用的私钥(server.key)和证书(server.crt)，ca.crt是签注这个证书的CA，需要提供给发起请求的一端。 msp中有五个目录，对区块链进行操作时需要使用这些文件。 msp/admincerts中存放的是用户证书，使用该证书的用户对orderer.example.com具有管理权限。 msp/cacerts是签署msp/signcerts中用户证书的ca，可以用来校验用户的证书： $ cd ./certs/ordererOrganizations/example.com/orderers/orderer.example.com/msp/ $ openssl verify -CAfile ./cacerts/ca.example.com-cert.pem admincerts/Admin\\@example.com-cert.pem admincerts/Admin@example.com-cert.pem: OK msp/keystore是orderer.example.com操作区块，进行签署时使用的的私钥。 msp/signcerts是orderer.example.com提供其它组件用来核实它的签署的公钥。 msp/tlscacerts文件与tls/ca.crt相同。 这里需要特别提到的是msp/admincerts，在使用fabric时，你可能会发现有些操作需要admin权限，例如在某个peer上安装合约。 那么管理员是如何认定的？就是看当前用户的证书是不是在msp/admincerts目录中。 这个目录中的内容目前是(版本1.1.x)启动时加载的，因此如果在里面添加或删除文件后，需要重启使用到它的组件。 在ordererOrganizations/example.com/还有其它几个目录： ca msp orderers tlsca users orderers中存放就签名分析的每个orderer组件的证书文件。 users中存放的用户的证书文件，与orderer.example.com中内容基本相同，不过tls目录中文件名变成了client.X： $ tree ordererOrganizations/example.com/users ordererOrganizations/example.com/users -- Admin@example.com |-- msp | |-- admincerts | | -- Admin@example.com-cert.pem | |-- cacerts | | -- ca.example.com-cert.pem | |-- keystore | | -- 1ac3b40c9ddda7e7a0f724b18faa0ce6fdf3f9e9ff5eac59e1e3f9739499ac2d_sk | |-- signcerts | | -- Admin@example.com-cert.pem | -- tlscacerts | -- tlsca.example.com-cert.pem -- tls |-- ca.crt |-- client.crt -- client.key certs/peerOrganizations中的内容与certs/ordererOrganizations中也基本相同，只不过它里面存放的是peer要使用的证书文件。 certs目录中的文件留着备用。 使用fabric-ca生成证书 fabric-ca的部署和详细用法见：hyperledger的fabricCA的使用 只用fabric-ca生成证书的过程相对繁琐很多，需要为每个组件、每个用户生成，这里不做示例。 orderer.example.com 建一个目录存放orderer.example.com需要文件： mkdir orderer.example.com 先将bin/orderer以及证书复制到orderer.example.com目录中。 cp bin/orderer orderer.example.com/ cp -rf certs/ordererOrganizations/example.com/orderers/orderer.example.com/* orderer.example.com/ 然后准备orderer的配置文件orderer.yaml: General: LedgerType: file ListenAddress: 0.0.0.0 ListenPort: 7050 TLS: Enabled: true PrivateKey: ./tls/server.key Certificate: ./tls/server.crt RootCAs: - ./tls/ca.crt # ClientAuthEnabled: false # ClientRootCAs: LogLevel: debug LogFormat: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; # GenesisMethod: provisional GenesisMethod: file GenesisProfile: SampleInsecureSolo GenesisFile: ./genesisblock LocalMSPDir: ./msp LocalMSPID: OrdererMSP Profile: Enabled: false Address: 0.0.0.0:6060 BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: FileLedger: Location: /opt/app/fabric/orderer/data Prefix: hyperledger-fabric-ordererledger RAMLedger: HistorySize: 1000 Kafka: Retry: ShortInterval: 5s ShortTotal: 10m LongInterval: 5m LongTotal: 12h NetworkTimeouts: DialTimeout: 10s ReadTimeout: 10s WriteTimeout: 10s Metadata: RetryBackoff: 250ms RetryMax: 3 Producer: RetryBackoff: 100ms RetryMax: 3 Consumer: RetryBackoff: 2s Verbose: false TLS: Enabled: false PrivateKey: #File: path/to/PrivateKey Certificate: #File: path/to/Certificate RootCAs: #File: path/to/RootCAs Version: 注意，orderer将被部署在目标机器的/opt/apt/fabric/orderer目录中，如果要部署在其它目录中，需要修改配置文件中路径。 这里需要用到一个data目录，存放orderer的数据: mkdir orderer.example.com/data peer0.org1.example.com 建一个目录存放peer0.org1.example.com需要文件： mkdir peer0.org1.example.com 先将bin/peer以及证书复制到peer0.org1.example.com目录中。 cp bin/peer peer0.org1.example.com/ cp -rf certs/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/* peer0.org1.example.com/ 准备peer0.org1.example.com的配置文件core.yaml： logging: peer: debug cauthdsl: warning gossip: warning ledger: info msp: warning policies: warning grpc: error format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; peer: id: peer0.org1.example.com networkId: dev listenAddress: 0.0.0.0:7051 address: 0.0.0.0:7051 addressAutoDetect: false gomaxprocs: -1 gossip: bootstrap: 127.0.0.1:7051 bootstrap: peer0.org1.example.com:7051 useLeaderElection: true orgLeader: false endpoint: maxBlockCountToStore: 100 maxPropagationBurstLatency: 10ms maxPropagationBurstSize: 10 propagateIterations: 1 propagatePeerNum: 3 pullInterval: 4s pullPeerNum: 3 requestStateInfoInterval: 4s publishStateInfoInterval: 4s stateInfoRetentionInterval: publishCertPeriod: 10s skipBlockVerification: false dialTimeout: 3s connTimeout: 2s recvBuffSize: 20 sendBuffSize: 200 digestWaitTime: 1s requestWaitTime: 1s responseWaitTime: 2s aliveTimeInterval: 5s aliveExpirationTimeout: 25s reconnectInterval: 25s externalEndpoint: peer0.org1.example.com:7051 election: startupGracePeriod: 15s membershipSampleInterval: 1s leaderAliveThreshold: 10s leaderElectionDuration: 5s events: address: 0.0.0.0:7053 buffersize: 100 timeout: 10ms tls: enabled: true cert: file: ./tls/server.crt key: file: ./tls/server.key rootcert: file: ./tls/ca.crt serverhostoverride: fileSystemPath: /opt/app/fabric/peer/data BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: mspConfigPath: msp localMspId: Org1MSP profile: enabled: true listenAddress: 0.0.0.0:6060 vm: endpoint: unix:///var/run/docker.sock docker: tls: enabled: false ca: file: docker/ca.crt cert: file: docker/tls.crt key: file: docker/tls.key attachStdout: false hostConfig: NetworkMode: host Dns: # - 192.168.0.1 LogConfig: Type: json-file Config: max-size: &quot;50m&quot; max-file: &quot;5&quot; Memory: 2147483648 chaincode: peerAddress: id: path: name: builder: $(DOCKER_NS)/fabric-ccenv:$(ARCH)-$(PROJECT_VERSION) golang: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) car: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) java: Dockerfile: | from $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION) startuptimeout: 300s executetimeout: 30s mode: net keepalive: 0 system: cscc: enable lscc: enable escc: enable vscc: enable qscc: enable logging: level: info shim: warning format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; ledger: blockchain: state: stateDatabase: goleveldb couchDBConfig: couchDBAddress: 127.0.0.1:5984 username: password: maxRetries: 3 maxRetriesOnStartup: 10 requestTimeout: 35s queryLimit: 10000 history: enableHistoryDatabase: true 注意，peer将被部署在目标机器的/opt/apt/fabric/peer目录中，如果要部署在其它目录中，需要修改配置文件中路径。 这里需要用到一个data目录，存放peer的数据: mkdir peer0.org1.example.com/data peer1.org1.example.com 过程与peer0.org1.example.com类似，注意将配置文件中的名称修改为peer1，并且不要拷错证书。 这里直接复制peer0.org1.exampl.com目录，然后替换其中的文件。 cp -rf peer0.org1.example.com/ peer1.org1.example.com/ rm -rf peer1.org1.example.com/msp/ rm -rf peer1.org1.example.com/tls/ cp -rf certs/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/* peer1.org1.example.com/ 最后修改peer1.org1.example.com/core.yml，将其中的peer0.org1.exampl.com修改为peer1.org1.example.com，这里直接用sed命令替换: sed -i &quot;s/peer0.org1.example.com/peer1\\.org1\\.example.com/g&quot; peer1.org1.example.com/core.yaml peer0.org2.example.com 过程与peer0.org1.example.com类似，注意将配置文件中的名称修改为org2，并且不要拷错证书。 这里直接复制peer0.org1.exampl.com目录，然后替换其中的文件。 cp -rf peer0.org1.example.com/ peer0.org2.example.com/ rm -rf peer0.org2.example.com/msp/ rm -rf peer0.org2.example.com/tls/ cp -rf certs/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/* peer0.org2.example.com/ 最后修改peer0.org2.example.com/core.yml，将其中的peer0.org1.exampl.com修改为peer0.org2.example.com，这里直接用sed命令替换: sed -i &quot;s/peer0.org1.example.com/peer0\\.org2\\.example.com/g&quot; peer0.org2.example.com/core.yaml 将配置文件中Org1MSP替换成Org2MSP: sed -i &quot;s/Org1MSP/Org2MSP/g&quot; peer0.org2.example.com/core.yaml 开始部署 部署之前，先确保已经在每台机器的/etc/hosts文件中添加下列的记录： 192.168.88.10 orderer.example.com 192.168.88.10 peer0.org1.example.com 192.168.88.11 peer1.org1.example.com 192.168.88.12 peer0.org2.example.com 注意根据你自己的环境情况修改。 在192.168.88.10上创建目录: mkdir -p /opt/app/fabric/{orderer,peer} 将orderer.example.com和peer0.org1.exmaple.com中的内容复制到192.168.88.10: scp -r orderer.example.com/* root@192.168.88.10:/opt/app/fabric/orderer/ scp -r peer0.org1.example.com/* root@192.168.88.10:/opt/app/fabric/peer/ 在192.168.88.11上创建目录: mkdir -p /opt/app/fabric/peer 将peer1.org1.exmaple.com中的内容复制到192.168.88.11: scp -r peer1.org1.example.com/* root@192.168.88.11:/opt/app/fabric/peer/ 在192.168.88.12上创建目录: mkdir -p /opt/app/fabric/peer 将peer0.org2.exmaple.com中的内容复制到192.168.88.12: scp -r peer0.org2.example.com/* root@192.168.88.12:/opt/app/fabric/peer/ 启动前准备 order、peer都部署到位，但是对我这里示意的场景，需要的文件并不齐备。 查看orderer.yaml文件，你会看到有这样几行： GenesisMethod: file GenesisFile: ./genesisblock GenesisProfile: SampleInsecureSolo 前两行配置了创世块的获取方式。第一个区块的获取方式有多种，这里采用最简单的一种做法，用configtxgen生成。 没有在前面的步骤中一次生成所有需要的文件是因为，如果你修改了配置、使用了其它的方式，可能不需要这里的操作。 回到存放了所有文件的fabric-deploy目录中，创建一个名为configtx.yaml的文件： Profiles: TwoOrgsOrdererGenesis: Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Consortiums: SampleConsortium: Organizations: - *Org1 - *Org2 TwoOrgsChannel: Consortium: SampleConsortium Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 - *Org2 Organizations: - &amp;OrdererOrg Name: OrdererOrg ID: OrdererMSP MSPDir: ./certs/ordererOrganizations/example.com/msp - &amp;Org1 Name: Org1MSP ID: Org1MSP MSPDir: ./certs/peerOrganizations/org1.example.com/msp AnchorPeers: - Host: peer0.org1.example.com Port: 7051 - &amp;Org2 Name: Org2MSP ID: Org2MSP MSPDir: ./certs/peerOrganizations/org2.example.com/msp AnchorPeers: - Host: peer0.org2.example.com Port: 7051 Orderer: &amp;OrdererDefaults OrdererType: solo Addresses: - orderer.example.com:7050 BatchTimeout: 2s BatchSize: MaxMessageCount: 10 AbsoluteMaxBytes: 99 MB PreferredMaxBytes: 512 KB Kafka: Brokers: - 127.0.0.1:9092 Organizations: Application: &amp;ApplicationDefaults Organizations: 这个配置文件的内容比较多，这里就不做解释了，可以到视频解说中听讲解。 直接用./bin/configtxgen生成创世块文件。 ./bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./genesisblock 将./genesisblock文件复制到192.168.88.10的/opt/app/fabric/orderer/目录中: scp genesisblock root@192.168.88.10:/opt/app/fabric/orderer/ 启动 分别到每台机器到orderer、peer目录中启动： ./orderer &amp; ./peer node start &amp; 为了方便查看输出的日志，可以写一个脚本： $ cat start.sh ./orderer 2&gt;&amp;1 |tee log peer的脚本如下： $ cat start.sh ./peer node start 2&gt;&amp;1 |tee log 然后将脚本放到后台运行： $ ./start.sh &amp; 如果程序启动失败，那么核实之前的步骤。或者到右侧的“区块链实践分享”知识星球中咨询。 用户 要使用得先有用户。在前面用cryptogen准备证书的时候，它默认创建了用户。 还记得certs目录下的几个users目录吗？那里面就是用户证书。 users目录一共有三个，分别是联盟的用户，和每个组织的用户： ./certs/ordererOrganizations/example.com/users ./certs/peerOrganizations/org1.example.com/users ./certs/peerOrganizations/org2.example.com/users 其中每个组织有两个用户，Admin和User1： $ ls ./certs/peerOrganizations/org1.example.com/users Admin@org1.example.com User1@org1.example.com Admin和User1唯一的区别是，Admin的用户证书被添加到了对一个peer的msp/admincerts目录中。（还记得这个目录的作用吗？） Admin@org1.example.com 使用hyperledger fabric可以通过SDK，也可以使用peer命令。 这里直接演示peer命令的用法。 在fabric-deploy中创建目录Admin@org1.example.com，在其中存放该用户的所有资料。 mkdir Admin@org1.example.com 将用户证书复制到其中： cp -rf certs/peerOrganizations/org1.example.com/users/Admin\\@org1.example.com/* Admin\\@org1.example.com/ 还需要将core.yaml复制到用户目录下： cp peer0.org1.example.com/core.yaml Admin\\@org1.example.com/ 为了方便使用，在Admin@org1.example.com中创建一个peer.sh脚本： #!/bin/bash PATH=`pwd`/../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=cli export CORE_LOGGING_LEVEL=INFO peer $* 然后直接通过这个脚本访问peer0.org1.example.com: $ ./peer.sh node status status:STARTED 2018-04-29 14:32:03.517 CST [main] main -&gt; INFO 001 Exiting..... 可以看到peer0.org1.example.com:7051的状态是启动的。 为了后面的演示，下面使用复制替换的方式，准备另外两个用户的目录。 User1@org1.example.com User1与Admin1使用相同的peer，因此只需要替换用户证书即可： cp -rf Admin\\@org1.example.com/ User1\\@org1.example.com/ rm -rf User1\\@org1.example.com/msp rm -rf User1\\@org1.example.com/tls cp -rf certs/peerOrganizations/org1.example.com/users/User1\\@org1.example.com/* User1\\@org1.example.com/ 执行peer.sh检验： $ ./peer.sh node status status:STARTED 2018-04-29 14:37:48.251 CST [main] main -&gt; INFO 001 Exiting..... Admin@org2.example.com 对于Admin@org2.example.com，core.yaml也需要替换： cp -rf Admin\\@org1.example.com/ Admin\\@org2.example.com/ rm -rf Admin\\@org2.example.com/msp/ rm -rf Admin\\@org2.example.com/tls/ cp -rf certs/peerOrganizations/org2.example.com/users/Admin\\@org2.example.com/* Admin\\@org2.example.com/ cp peer0.org2.example.com/core.yaml Admin\\@org2.example.com/ 还需要将peer.sh中peer地址修改为org2的peer地址： export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP 修改为： export CORE_PEER_ADDRESS=peer0.org2.example.com:7051 export CORE_PEER_LOCALMSPID=Org2MSP 验证： $ ./peer.sh node status status:STARTED 2018-04-29 14:44:22.395 CST [main] main -&gt; INFO 001 Exiting..... 创建channel与peer的设置 准备channel文件 这里用命令行演示channel的创建与peer的设置。(也可以通过SDK，SDK将单独讨论） 需要再次回到fabric-deploy目录中，用configtxgen生成channel文件： ./bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx mychannel.tx -channelID mychannel channel名字为mychannel，生成的mychannel.tx备用。 还需要为每个组织的peer生成一个anchor文件，每个组织只需要一个： ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP 生成的Org1MSPanchors.tx和Org2MSPanchors.tx备用。 下一步操作中需要访问orderer.example.com，需要将验证orderer.example.com的证书复制到用户目录中： cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem Admin\\@org1.example.com/ cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem User1\\@org1.example.com/ cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem Admin\\@org2.example.com/ 创建channel 在Admin@org1.exampl.com目录中执行下面的命令，： ./peer.sh channel create -o orderer.example.com:7050 -c mychannel -f ../mychannel.tx --tls true --cafile tlsca.example.com-cert.pem 执行完成后，会生成一个mychannel.block文件： $ ls core.yaml msp mychannel.block peer.sh tls tlsca.example.com-cert.pem 将mychannel.block复制一份到Admin\\@org2.example.com/中备用： cp Admin\\@org1.example.com/mychannel.block Admin\\@org2.example.com/ 将peer加入channel 分别在Admin\\@org1.example.com/和Admin\\@org2.example.com/执行下面的命令： ./peer.sh channel join -b mychannel.block 因为org1有两个peer，因此需要将peer.sh中peer修改为peer1.org1.example.com后，再添加一次： ./peer.sh channel join -b mychannel.block 可以用channel list查看peer所在channel $ ./peer.sh channel list 2018-04-29 16:37:47.016 CST [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized Channels peers has joined: mychannel 2018-04-29 16:37:47.018 CST [main] main -&gt; INFO 002 Exiting..... 最后需要每个组织指定一个anchor peer，anchor peer是组织用来与外部通信的peer: cd Admin\\@org1.example.com/ ./peer.sh channel update -o orderer.example.com:7050 -c mychannel -f ../Org1MSPanchors.tx --tls true --cafile ./tlsca.example.com-cert.pem cd Admin\\@org2.example.com/ ./peer.sh channel update -o orderer.example.com:7050 -c mychannel -f ../Org2MSPanchors.tx --tls true --cafile ./tlsca.example.com-cert.pem 安装合约（chaincode） 在hyperledger fabric中，合约被称为chaincode。 需要安装一个go语言的开发环境，安装方法这里就不介绍了。 这里将go的开发环境安装在fabric-deploy所在的机器上。 直接用go get获取一份合约代码： go get github.com/lijiaocn/fabric-chaincode-example/demo 到Admin@org1.example.com/目录下，以Admin@org1.example.com的身份打包合约: cd Admin\\@org1.example.com/ 执行下面命令进行合约打包与签署： ./peer.sh chaincode package demo-pack.out -n demo -v 0.0.1 -s -S -p github.com/lijiaocn/fabric-chaincode-example/demo ./peer.sh chaincode signpackage demo-pack.out signed-demo-pack.out 然后安装合约： ./peer.sh chaincode install ./signed-demo-pack.out 安装之后，可以用chaincode list查看peer上已经安装的合约。 $ ./peer.sh chaincode list --installed Get installed chaincodes on peer: Name: demo, Version: 0.0.1, Path: github.com/lijiaocn/fabric-chaincode-example/demo, Id: 3d733bd28accf77b06b2bec065d8ce7315bd7c5441c51beea4650982f79eab46 2018-04-29 18:57:54.327 CST [main] main -&gt; INFO 001 Exiting.... chaincode只能用Admin安装，并且需要在每个peer上都安装一次。 因此需要将peer0.org1.example.com切换为peer1.org1.example.com后，再次安装一次： ./peer.sh chaincode install ./signed-demo-pack.out (不需要重新打包签署) 将signed-demo-pack.out复制到Admin@org2.exmaple.com中安装一次 cp Admin\\@org1.example.com/signed-demo-pack.out Admin\\@org2.example.com/ cd Admin\\@org2.example.com/ ./peer.sh chaincode install ./signed-demo-pack.out 合约初始化 合约安装之后，需要进行一次初始化，只能由创建合约的用户进行初始化: cd Admin\\@org1.example.com/ ./peer.sh chaincode instantiate -o orderer.example.com:7050 --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -v 0.0.1 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 第一进行合约初始化的时候的会比较慢，因为需要需要创建、启动容器。 合约调用 可以在任意一个peer上调用合约，例如以admin@org2.example.com的进行写操作： cd Admin\\@org2.example.com/ ./peer.sh chaincode invoke -o orderer.example.com:7050 --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key1&quot;,&quot;key1 value is abc&quot;]}&#39; 如果是第一次在一个peer访问一个合约，这个peer需要先启动容器，响应会比较慢。进行写操作（invoke命令）时，需要指定orderer（-o orderer.example.com:7050）。 进行查询操作时，不需要指定orderer，例如： cd User1\\@org1.example.com/ ./peer.sh chaincode query -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key1&quot;]}&#39; 更新合约 将更改后的合约重新打包，使用一个新的版本号： cd Admin\\@org1.example.com/ 执行下面命令进行合约打包与签署： ./peer.sh chaincode package demo-pack-2.out -n demo -v 0.0.2 -s -S -p github.com/lijiaocn/fabric-chaincode-example/demo ./peer.sh chaincode signpackage demo-pack-2.out signed-demo-pack-2.out 然后安装合约： ./peer.sh chaincode install ./signed-demo-pack-2.out 更新的合约不需要初始化，需要进行更新操作： ./peer.sh chaincode upgrade -o orderer.example.com:7050 --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -v 0.0.2 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 新的合约也需要在每个peer上单独安装。 因此需要将peer0.org1.example.com切换为peer1.org1.example.com后，再次安装一次： ./peer.sh chaincode install ./signed-demo-pack-2.out (不需要重新打包签署) 将signed-demo-pack.out复制到Admin@org2.exmaple.com中安装一次 cp Admin\\@org1.example.com/signed-demo-pack-2.out Admin\\@org2.example.com/ cd Admin\\@org2.example.com/ ./peer.sh chaincode install ./signed-demo-pack-2.out 视频纪录发布在：&nbsp;网易云课堂视频教程：HyperLedger Fabric全手动部署 可以到星球里找我要优惠券或者提问： 参考 Building Your First Network hyperledger fabric编译 hyperledger fabric download hyperledger的fabricCA的使用 hyperledger项目fabric的nodejsSDK的使用 网易云课堂视频教程：HyperLedger Fabric全手动部署 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/05/09/0ffbbb90f77c188a9998d926648082ab.html","headline":"超级账本HyperLedger的Fabric“全手动”、“多节点”部署教程，带视频演示","dateModified":"2018-05-09T00:00:00+08:00","datePublished":"2018-05-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/05/09/0ffbbb90f77c188a9998d926648082ab.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>超级账本HyperLedger的Fabric“全手动”、“多节点”部署教程，带视频演示</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><strong>原文地址：<a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html" rel="nofollow">超级账本HyperLedger的Fabric项目的手动部署教程</a></strong></p> 
  <h2>说明</h2> 
  <p style="text-indent:0px;">&nbsp;</p> 
  <p style="text-indent:0px;">虽然通过<a href="http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html" rel="nofollow">Building Your First Network</a>中的docker-compose文件可以直接启动一个all-in-one的fabric。 但这种方式隐藏了太多的细节，只能让人有个模糊的认识，对生产环境中部署方式、多服务器部署，依然不清不楚， 对各组件的配置文件也完全不了解。</p> 
  <p style="text-indent:0px;">通过反复阅读Fabric的文档，以及<a href="http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html" rel="nofollow">Building Your First Network</a>中的脚本，经历了诸多磨难之后，总算弄清楚了Fabric的组件间关系与配置项。</p> 
  <p style="text-indent:0px;">看文档感觉吃力或者一通操作后不知所以然的同学，可以使用网易云课堂视频教程：<a href="http://study.163.com/course/introduction.htm?courseId=1005326005&amp;share=2&amp;shareId=400000000376006" rel="nofollow">HyperLedger Fabric手动部署教程的视频讲解</a></p> 
  <ul>
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E8%AF%B4%E6%98%8E" rel="nofollow">说明</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E8%A7%84%E5%88%92" rel="nofollow">规划</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E7%BC%96%E8%AF%91%E6%88%96%E4%B8%8B%E8%BD%BDfabric%E6%96%87%E4%BB%B6" rel="nofollow">编译或下载fabric文件</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%87%86%E5%A4%87%E8%AF%81%E4%B9%A6" rel="nofollow">准备证书</a> 
    <ul>
     <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#cryptogen%E7%9A%84%E6%96%B9%E5%BC%8F" rel="nofollow">cryptogen的方式</a></li> 
     <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E4%BD%BF%E7%94%A8fabric-ca%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6" rel="nofollow">使用fabric-ca生成证书</a></li> 
    </ul></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#ordererexamplecom" rel="nofollow">orderer.example.com</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#peer0org1examplecom" rel="nofollow">peer0.org1.example.com</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#peer1org1examplecom" rel="nofollow">peer1.org1.example.com</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#peer0org2examplecom" rel="nofollow">peer0.org2.example.com</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%BC%80%E5%A7%8B%E9%83%A8%E7%BD%B2" rel="nofollow">开始部署</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%90%AF%E5%8A%A8%E5%89%8D%E5%87%86%E5%A4%87" rel="nofollow">启动前准备</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%90%AF%E5%8A%A8" rel="nofollow">启动</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E7%94%A8%E6%88%B7" rel="nofollow">用户</a> 
    <ul>
     <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#adminorg1examplecom" rel="nofollow">Admin@org1.example.com</a></li> 
     <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#user1org1examplecom" rel="nofollow">User1@org1.example.com</a></li> 
     <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#adminorg2examplecom" rel="nofollow">Admin@org2.example.com</a></li> 
    </ul></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%88%9B%E5%BB%BAchannel%E4%B8%8Epeer%E7%9A%84%E8%AE%BE%E7%BD%AE" rel="nofollow">创建channel与peer的设置</a> 
    <ul>
     <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%87%86%E5%A4%87channel%E6%96%87%E4%BB%B6" rel="nofollow">准备channel文件</a></li> 
     <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%88%9B%E5%BB%BAchannel" rel="nofollow">创建channel</a></li> 
     <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%B0%86peer%E5%8A%A0%E5%85%A5channel" rel="nofollow">将peer加入channel</a></li> 
    </ul></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%AE%89%E8%A3%85%E5%90%88%E7%BA%A6chaincode" rel="nofollow">安装合约（chaincode）</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%90%88%E7%BA%A6%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">合约初始化</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8" rel="nofollow">合约调用</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E6%9B%B4%E6%96%B0%E5%90%88%E7%BA%A6" rel="nofollow">更新合约</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html#%E5%8F%82%E8%80%83" rel="nofollow">参考</a></li> 
  </ul>
  <h2>规划</h2> 
  <p style="text-indent:0px;">创建一个名为fabric-deploy的目录，用来存放部署过程使用到的文件。</p> 
  <pre class="highlight">
<code>mkdir ~/fabric-deploy
</code></pre> 
  <p style="text-indent:0px;">这里将用三台机器部署一个fabric网络，该网络中有两个组织:</p> 
  <pre class="highlight">
<code>org1.example.com
org2.example.com
</code></pre> 
  <p style="text-indent:0px;">一个order:</p> 
  <pre class="highlight">
<code>orderer.example.com
</code></pre> 
  <p style="text-indent:0px;">org1.example.com有两个peer:</p> 
  <pre class="highlight">
<code>peer0.org1.example.com
peer1.org1.example.com
</code></pre> 
  <p style="text-indent:0px;">org2.example.com有一个peer:</p> 
  <pre class="highlight">
<code>peer0.org2.example.com
</code></pre> 
  <p style="text-indent:0px;">三台机器的IP，以及部署的组件如下：</p> 
  <pre class="highlight">
<code>192.168.88.10  部署:  orderer、peer0@org1
192.168.88.11  部署:  peer1@org1
192.168.88.12  部署： peer0@org2
</code></pre> 
  <p style="text-indent:0px;">相应域名的IP分别为：</p> 
  <pre class="highlight">
<code>192.168.88.10 orderer.example.com
192.168.88.10 peer0.org1.example.com
192.168.88.11 peer1.org1.example.com
192.168.88.12 peer0.org2.example.com
</code></pre> 
  <p style="text-indent:0px;">将这四条记录添加到每台机器的/etc/hosts文件中。</p> 
  <p style="text-indent:0px;">每台机器上还需要安装docker:</p> 
  <pre class="highlight">
<code>yum install -y docker 
systemctl start docker
</code></pre> 
  <p style="text-indent:0px;">另外fabric的peer会调用docker，需要在所有peer上安装docker，并提前下载镜像：</p> 
  <pre class="highlight">
<code>docker pull hyperledger/fabric-javaenv:x86_64-1.1.0
docker pull hyperledger/fabric-ccenv:x86_64-1.1.0
docker pull hyperledger/fabric-baseos:x86_64-0.4.6
</code></pre> 
  <p style="text-indent:0px;">下载的镜像需要与下面步骤中创建的core.yaml中的镜像配对：</p> 
  <pre class="highlight">
<code>...
chaincode:
    peerAddress:
    id:
        path:
        name:
    builder: $(DOCKER_NS)/fabric-ccenv:$(ARCH)-$(PROJECT_VERSION)
    golang:
        runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION)
    car:
        runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION)
    java:
        Dockerfile:  |
            from $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION)
...
</code></pre> 
  <p style="text-indent:0px;">创建合约的时候会用到这些镜像，镜像下载可能比较慢，根据自己的情况配置加速器。另外每个peer上都需要下载。</p> 
  <p style="text-indent:0px;">我在”区块链实践分享”中提供的fabric-deploy中下载包中提供了这三个镜像，可以直接使用：</p> 
  <pre class="highlight">
<code>cd fabric-deploy/docker-images
./load.sh
</code></pre> 
  <h2>编译或下载fabric文件</h2> 
  <p style="text-indent:0px;">编译方法见：<a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/02/23/hyperledger-fabric-usage.html#fabric%E7%BC%96%E8%AF%91" rel="nofollow">hyperledger fabric编译</a></p> 
  <p style="text-indent:0px;">执行下面的命令可以下载编译好的fabric以及依赖的镜像：</p> 
  <pre class="highlight">
<code>curl -sSL https://goo.gl/6wtTN5 | bash 
</code></pre> 
  <p style="text-indent:0px;">或者直接到这里下载：&nbsp;<a href="https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/" rel="nofollow">hyperledger fabric download</a></p> 
  <p style="text-indent:0px;">这里使用的linux-amd64，fabric-1.1.0:</p> 
  <pre class="highlight">
<code>wget https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/linux-amd64-1.1.0/hyperledger-fabric-linux-amd64-1.1.0.tar.gz
wget https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/linux-amd64-1.1.0/hyperledger-fabric-linux-amd64-1.1.0.tar.gz.md5
</code></pre> 
  <p style="text-indent:0px;">下载完成后校验一下：</p> 
  <pre class="highlight">
<code>$ md5sum hyperledger-fabric-linux-amd64-1.1.0.tar.gz
6be979ccd903752aefba9da4fc9e1d44  hyperledger-fabric-linux-amd64-1.1.0.tar.gz
$ cat hyperledger-fabric-linux-amd64-1.1.0.tar.gz.md5
6be979ccd903752aefba9da4fc9e1d44
</code></pre> 
  <p style="text-indent:0px;">解压后得到两个bin和config两个目录:</p> 
  <pre class="highlight">
<code>tar -xvf hyperledger-fabric-linux-amd64-1.1.0.tar.gz
</code></pre> 
  <p style="text-indent:0px;">bin目录中是fabric的组件，config是配置文件模版。</p> 
  <pre class="highlight">
<code>$ ls bin/
configtxgen   configtxlator   cryptogen   get-byfn.sh   get-docker-images.sh orderer   peer

$ ls config/
configtx.yaml  core.yaml  orderer.yaml
</code></pre> 
  <p style="text-indent:0px;">保留备用。</p> 
  <h2>准备证书</h2> 
  <p style="text-indent:0px;">证书的准备方式有两种，一种用<code>cryptogen</code>命令生成，一种是通过<code>fabric-ca服务</code>生成。</p> 
  <h3>cryptogen的方式</h3> 
  <p style="text-indent:0px;">创建一个配置文件<code>crypto-config.yaml</code>，这里配置了两个组织，org1的Count是2，表示两个peer：</p> 
  <pre class="highlight">
<code>OrdererOrgs:
  - Name: Orderer
    Domain: example.com
    Specs:
      - Hostname: orderer
PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    Template:
      Count: 2
    Users:
      Count: 1
  - Name: Org2
    Domain: org2.example.com
    Template:
      Count: 1
    Users:
      Count: 1
</code></pre> 
  <p style="text-indent:0px;">然后执行crypto，生成证书：</p> 
  <pre class="highlight">
<code>./bin/cryptogen generate --config=crypto-config.yaml --output ./certs
</code></pre> 
  <p style="text-indent:0px;">certs目录下生成了两个目录：</p> 
  <pre class="highlight">
<code>$ ls ./certs/
ordererOrganizations  peerOrganizations
</code></pre> 
  <p style="text-indent:0px;">certs目录的内容比较多，并且目录很深，需要提前说明一下。搞清楚了这里面文件的含义，就懂了一半。</p> 
  <p style="text-indent:0px;">以<code>certs/ordererOrganizations/example.com/orderers/orderer.example.com/</code>目录中内容为例。</p> 
  <p style="text-indent:0px;">这里目录中的内容是用于orderer.example.com的，里面有两个子目录<code>tls</code>和<code>msp</code>：</p> 
  <pre class="highlight">
<code>$ tree certs/ordererOrganizations/example.com/orderers/orderer.example.com/
certs/ordererOrganizations/example.com/orderers/orderer.example.com/
|-- msp
|   |-- admincerts
|   |   -- Admin@example.com-cert.pem
|   |-- cacerts
|   |   -- ca.example.com-cert.pem
|   |-- keystore
|   |   -- 16da15d400d4ca4b53d369b6d6e50a084d4354998c3b4d7a0934635d3907f90f_sk
|   |-- signcerts
|   |   -- orderer.example.com-cert.pem
|   -- tlscacerts
|       -- tlsca.example.com-cert.pem
-- tls
    |-- ca.crt
    |-- server.crt
    -- server.key
</code></pre> 
  <p style="text-indent:0px;">tls目录中的内容很好理解，它是order对外服务时使用的私钥(server.key)和证书(server.crt)，ca.crt是签注这个证书的CA，需要提供给发起请求的一端。</p> 
  <p style="text-indent:0px;">msp中有五个目录，对区块链进行操作时需要使用这些文件。</p> 
  <p style="text-indent:0px;"><code>msp/admincerts</code>中存放的是用户证书，使用该证书的用户对orderer.example.com具有管理权限。</p> 
  <p style="text-indent:0px;"><code>msp/cacerts</code>是签署<code>msp/signcerts</code>中用户证书的ca，可以用来校验用户的证书：</p> 
  <pre class="highlight">
<code>$ cd ./certs/ordererOrganizations/example.com/orderers/orderer.example.com/msp/
$ openssl verify -CAfile ./cacerts/ca.example.com-cert.pem  admincerts/Admin\@example.com-cert.pem
admincerts/Admin@example.com-cert.pem: OK
</code></pre> 
  <p style="text-indent:0px;"><code>msp/keystore</code>是orderer.example.com操作区块，进行签署时使用的的私钥。</p> 
  <p style="text-indent:0px;"><code>msp/signcerts</code>是orderer.example.com提供其它组件用来核实它的签署的公钥。</p> 
  <p style="text-indent:0px;"><code>msp/tlscacerts</code>文件与<code>tls/ca.crt</code>相同。</p> 
  <p style="text-indent:0px;">这里需要特别提到的是<code>msp/admincerts</code>，在使用fabric时，你可能会发现有些操作需要admin权限，例如在某个peer上安装合约。</p> 
  <p style="text-indent:0px;">那么管理员是如何认定的？就是看当前用户的证书是不是在<code>msp/admincerts</code>目录中。</p> 
  <p style="text-indent:0px;">这个目录中的内容目前是(版本1.1.x)启动时加载的，因此如果在里面添加或删除文件后，需要重启使用到它的组件。</p> 
  <p style="text-indent:0px;">在<code>ordererOrganizations/example.com/</code>还有其它几个目录：</p> 
  <pre class="highlight">
<code>ca  msp  orderers  tlsca  users
</code></pre> 
  <p style="text-indent:0px;">orderers中存放就签名分析的每个orderer组件的证书文件。</p> 
  <p style="text-indent:0px;">users中存放的用户的证书文件，与<code>orderer.example.com</code>中内容基本相同，不过tls目录中文件名变成了<code>client.X</code>：</p> 
  <pre class="highlight">
<code>$ tree ordererOrganizations/example.com/users
ordererOrganizations/example.com/users
-- Admin@example.com
    |-- msp
    |   |-- admincerts
    |   |   -- Admin@example.com-cert.pem
    |   |-- cacerts
    |   |   -- ca.example.com-cert.pem
    |   |-- keystore
    |   |   -- 1ac3b40c9ddda7e7a0f724b18faa0ce6fdf3f9e9ff5eac59e1e3f9739499ac2d_sk
    |   |-- signcerts
    |   |   -- Admin@example.com-cert.pem
    |   -- tlscacerts
    |       -- tlsca.example.com-cert.pem
    -- tls
        |-- ca.crt
        |-- client.crt
        -- client.key
</code></pre> 
  <p style="text-indent:0px;"><code>certs/peerOrganizations</code>中的内容与<code>certs/ordererOrganizations</code>中也基本相同，只不过它里面存放的是peer要使用的证书文件。</p> 
  <p style="text-indent:0px;">certs目录中的文件留着备用。</p> 
  <h3>使用fabric-ca生成证书</h3> 
  <p style="text-indent:0px;">fabric-ca的部署和详细用法见：<a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/27/hyperledger-fabric-ca-usage.html" rel="nofollow">hyperledger的fabricCA的使用</a></p> 
  <p style="text-indent:0px;">只用fabric-ca生成证书的过程相对繁琐很多，需要为每个组件、每个用户生成，这里不做示例。</p> 
  <h2>orderer.example.com</h2> 
  <p style="text-indent:0px;">建一个目录存放orderer.example.com需要文件：</p> 
  <pre class="highlight">
<code>mkdir orderer.example.com
</code></pre> 
  <p style="text-indent:0px;">先将bin/orderer以及证书复制到orderer.example.com目录中。</p> 
  <pre class="highlight">
<code>cp bin/orderer orderer.example.com/
cp -rf certs/ordererOrganizations/example.com/orderers/orderer.example.com/* orderer.example.com/
</code></pre> 
  <p style="text-indent:0px;">然后准备orderer的配置文件<code>orderer.yaml</code>:</p> 
  <pre class="highlight">
<code>General:
    LedgerType: file
    ListenAddress: 0.0.0.0
    ListenPort: 7050
    TLS:
        Enabled: true
        PrivateKey: ./tls/server.key
        Certificate: ./tls/server.crt
        RootCAs:
          - ./tls/ca.crt
#        ClientAuthEnabled: false
#        ClientRootCAs:
    LogLevel: debug
    LogFormat: '%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}'
#    GenesisMethod: provisional
    GenesisMethod: file
    GenesisProfile: SampleInsecureSolo
    GenesisFile: ./genesisblock
    LocalMSPDir: ./msp
    LocalMSPID: OrdererMSP
    Profile:
        Enabled: false
        Address: 0.0.0.0:6060
    BCCSP:
        Default: SW
        SW:
            Hash: SHA2
            Security: 256
            FileKeyStore:
                KeyStore:
FileLedger:
    Location:  /opt/app/fabric/orderer/data
    Prefix: hyperledger-fabric-ordererledger
RAMLedger:
    HistorySize: 1000
Kafka:
    Retry:
        ShortInterval: 5s
        ShortTotal: 10m
        LongInterval: 5m
        LongTotal: 12h
        NetworkTimeouts:
            DialTimeout: 10s
            ReadTimeout: 10s
            WriteTimeout: 10s
        Metadata:
            RetryBackoff: 250ms
            RetryMax: 3
        Producer:
            RetryBackoff: 100ms
            RetryMax: 3
        Consumer:
            RetryBackoff: 2s
    Verbose: false
    TLS:
      Enabled: false
      PrivateKey:
        #File: path/to/PrivateKey
      Certificate:
        #File: path/to/Certificate
      RootCAs:
        #File: path/to/RootCAs
    Version:
</code></pre> 
  <p style="text-indent:0px;">注意，orderer将被部署在目标机器的<code>/opt/apt/fabric/orderer</code>目录中，如果要部署在其它目录中，需要修改配置文件中路径。</p> 
  <p style="text-indent:0px;">这里需要用到一个data目录，存放orderer的数据:</p> 
  <pre class="highlight">
<code>mkdir orderer.example.com/data
</code></pre> 
  <h2>peer0.org1.example.com</h2> 
  <p style="text-indent:0px;">建一个目录存放peer0.org1.example.com需要文件：</p> 
  <pre class="highlight">
<code>mkdir peer0.org1.example.com
</code></pre> 
  <p style="text-indent:0px;">先将bin/peer以及证书复制到peer0.org1.example.com目录中。</p> 
  <pre class="highlight">
<code>cp bin/peer peer0.org1.example.com/
cp -rf certs/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/* peer0.org1.example.com/
</code></pre> 
  <p style="text-indent:0px;">准备peer0.org1.example.com的配置文件core.yaml：</p> 
  <pre class="highlight">
<code>logging:
    peer:       debug
    cauthdsl:   warning
    gossip:     warning
    ledger:     info
    msp:        warning
    policies:   warning
    grpc:       error
    format: '%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}'
peer:
    id: peer0.org1.example.com
    networkId: dev
    listenAddress: 0.0.0.0:7051
    address: 0.0.0.0:7051
    addressAutoDetect: false
    gomaxprocs: -1
    gossip:
        bootstrap: 127.0.0.1:7051
        bootstrap: peer0.org1.example.com:7051
        useLeaderElection: true
        orgLeader: false
        endpoint:
        maxBlockCountToStore: 100
        maxPropagationBurstLatency: 10ms
        maxPropagationBurstSize: 10
        propagateIterations: 1
        propagatePeerNum: 3
        pullInterval: 4s
        pullPeerNum: 3
        requestStateInfoInterval: 4s
        publishStateInfoInterval: 4s
        stateInfoRetentionInterval:
        publishCertPeriod: 10s
        skipBlockVerification: false
        dialTimeout: 3s
        connTimeout: 2s
        recvBuffSize: 20
        sendBuffSize: 200
        digestWaitTime: 1s
        requestWaitTime: 1s
        responseWaitTime: 2s
        aliveTimeInterval: 5s
        aliveExpirationTimeout: 25s
        reconnectInterval: 25s
        externalEndpoint: peer0.org1.example.com:7051
        election:
            startupGracePeriod: 15s
            membershipSampleInterval: 1s
            leaderAliveThreshold: 10s
            leaderElectionDuration: 5s
    events:
        address: 0.0.0.0:7053
        buffersize: 100
        timeout: 10ms
    tls:
        enabled: true
        cert:
            file: ./tls/server.crt
        key:
            file: ./tls/server.key
        rootcert:
            file: ./tls/ca.crt
        serverhostoverride:
    fileSystemPath: /opt/app/fabric/peer/data
    BCCSP:
        Default: SW
        SW:
            Hash: SHA2
            Security: 256
            FileKeyStore:
                KeyStore:
    mspConfigPath: msp
    localMspId: Org1MSP
    profile:
        enabled:    true
        listenAddress: 0.0.0.0:6060
vm:
    endpoint: unix:///var/run/docker.sock
    docker:
        tls:
            enabled: false
            ca:
                file: docker/ca.crt
            cert:
                file: docker/tls.crt
            key:
                file: docker/tls.key
        attachStdout: false
        hostConfig:
            NetworkMode: host
            Dns:
               # - 192.168.0.1
            LogConfig:
                Type: json-file
                Config:
                    max-size: "50m"
                    max-file: "5"
            Memory: 2147483648
chaincode:
    peerAddress:
    id:
        path:
        name:
    builder: $(DOCKER_NS)/fabric-ccenv:$(ARCH)-$(PROJECT_VERSION)
    golang:
        runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION)
    car:
        runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION)
    java:
        Dockerfile:  |
            from $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION)
    startuptimeout: 300s
    executetimeout: 30s
    mode: net
    keepalive: 0
    system:
        cscc: enable
        lscc: enable
        escc: enable
        vscc: enable
        qscc: enable
    logging:
      level:  info
      shim:   warning
      format: '%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}'
ledger:
  blockchain:
  state:
    stateDatabase: goleveldb
    couchDBConfig:
       couchDBAddress: 127.0.0.1:5984
       username:
       password:
       maxRetries: 3
       maxRetriesOnStartup: 10
       requestTimeout: 35s
       queryLimit: 10000
  history:
    enableHistoryDatabase: true
</code></pre> 
  <p style="text-indent:0px;">注意，peer将被部署在目标机器的<code>/opt/apt/fabric/peer</code>目录中，如果要部署在其它目录中，需要修改配置文件中路径。</p> 
  <p style="text-indent:0px;">这里需要用到一个data目录，存放peer的数据:</p> 
  <pre class="highlight">
<code>mkdir peer0.org1.example.com/data
</code></pre> 
  <h2>peer1.org1.example.com</h2> 
  <p style="text-indent:0px;">过程与peer0.org1.example.com类似，注意将配置文件中的名称修改为peer1，并且不要拷错证书。</p> 
  <p style="text-indent:0px;">这里直接复制peer0.org1.exampl.com目录，然后替换其中的文件。</p> 
  <pre class="highlight">
<code>cp -rf peer0.org1.example.com/ peer1.org1.example.com/
rm -rf peer1.org1.example.com/msp/
rm -rf peer1.org1.example.com/tls/
cp -rf certs/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/* peer1.org1.example.com/
</code></pre> 
  <p style="text-indent:0px;">最后修改peer1.org1.example.com/core.yml，将其中的<code>peer0.org1.exampl.com</code>修改为<code>peer1.org1.example.com</code>，这里直接用sed命令替换:</p> 
  <pre class="highlight">
<code>sed -i "s/peer0.org1.example.com/peer1\.org1\.example.com/g" peer1.org1.example.com/core.yaml
</code></pre> 
  <h2>peer0.org2.example.com</h2> 
  <p style="text-indent:0px;">过程与peer0.org1.example.com类似，注意将配置文件中的名称修改为org2，并且不要拷错证书。</p> 
  <p style="text-indent:0px;">这里直接复制peer0.org1.exampl.com目录，然后替换其中的文件。</p> 
  <pre class="highlight">
<code>cp -rf peer0.org1.example.com/ peer0.org2.example.com/
rm -rf peer0.org2.example.com/msp/
rm -rf peer0.org2.example.com/tls/
cp -rf certs/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/*  peer0.org2.example.com/
</code></pre> 
  <p style="text-indent:0px;">最后修改peer0.org2.example.com/core.yml，将其中的<code>peer0.org1.exampl.com</code>修改为<code>peer0.org2.example.com</code>，这里直接用sed命令替换:</p> 
  <pre class="highlight">
<code>sed -i "s/peer0.org1.example.com/peer0\.org2\.example.com/g" peer0.org2.example.com/core.yaml
</code></pre> 
  <p style="text-indent:0px;">将配置文件中Org1MSP替换成Org2MSP:</p> 
  <pre class="highlight">
<code>sed -i "s/Org1MSP/Org2MSP/g" peer0.org2.example.com/core.yaml
</code></pre> 
  <h2>开始部署</h2> 
  <p style="text-indent:0px;">部署之前，先确保已经在每台机器的/etc/hosts文件中添加下列的记录：</p> 
  <pre class="highlight">
<code>192.168.88.10 orderer.example.com
192.168.88.10 peer0.org1.example.com
192.168.88.11 peer1.org1.example.com
192.168.88.12 peer0.org2.example.com
</code></pre> 
  <p style="text-indent:0px;">注意根据你自己的环境情况修改。</p> 
  <p style="text-indent:0px;">在192.168.88.10上创建目录:</p> 
  <pre class="highlight">
<code>mkdir -p /opt/app/fabric/{orderer,peer}
</code></pre> 
  <p style="text-indent:0px;">将orderer.example.com和peer0.org1.exmaple.com中的内容复制到192.168.88.10:</p> 
  <pre class="highlight">
<code>scp -r orderer.example.com/* root@192.168.88.10:/opt/app/fabric/orderer/
scp -r peer0.org1.example.com/* root@192.168.88.10:/opt/app/fabric/peer/
</code></pre> 
  <p style="text-indent:0px;">在192.168.88.11上创建目录:</p> 
  <pre class="highlight">
<code>mkdir -p /opt/app/fabric/peer
</code></pre> 
  <p style="text-indent:0px;">将peer1.org1.exmaple.com中的内容复制到192.168.88.11:</p> 
  <pre class="highlight">
<code>scp -r peer1.org1.example.com/* root@192.168.88.11:/opt/app/fabric/peer/
</code></pre> 
  <p style="text-indent:0px;">在192.168.88.12上创建目录:</p> 
  <pre class="highlight">
<code>mkdir -p /opt/app/fabric/peer
</code></pre> 
  <p style="text-indent:0px;">将peer0.org2.exmaple.com中的内容复制到192.168.88.12:</p> 
  <pre class="highlight">
<code>scp -r peer0.org2.example.com/* root@192.168.88.12:/opt/app/fabric/peer/
</code></pre> 
  <h2>启动前准备</h2> 
  <p style="text-indent:0px;">order、peer都部署到位，但是对我这里示意的场景，需要的文件并不齐备。</p> 
  <p style="text-indent:0px;">查看orderer.yaml文件，你会看到有这样几行：</p> 
  <pre class="highlight">
<code>GenesisMethod: file
GenesisFile: ./genesisblock
GenesisProfile: SampleInsecureSolo
</code></pre> 
  <p style="text-indent:0px;">前两行配置了创世块的获取方式。第一个区块的获取方式有多种，这里采用最简单的一种做法，用configtxgen生成。</p> 
  <blockquote> 
   <p>没有在前面的步骤中一次生成所有需要的文件是因为，如果你修改了配置、使用了其它的方式，可能不需要这里的操作。</p> 
  </blockquote> 
  <p style="text-indent:0px;">回到存放了所有文件的fabric-deploy目录中，创建一个名为<code>configtx.yaml</code>的文件：</p> 
  <pre class="highlight">
<code>Profiles:
    TwoOrgsOrdererGenesis:
        Orderer:
            &lt;&lt;: *OrdererDefaults
            Organizations:
                - *OrdererOrg
        Consortiums:
            SampleConsortium:
                Organizations:
                    - *Org1
                    - *Org2
    TwoOrgsChannel:
        Consortium: SampleConsortium
        Application:
            &lt;&lt;: *ApplicationDefaults
            Organizations:
                - *Org1
                - *Org2
Organizations:
    - &amp;OrdererOrg
        Name: OrdererOrg
        ID: OrdererMSP
        MSPDir: ./certs/ordererOrganizations/example.com/msp
    - &amp;Org1
        Name: Org1MSP
        ID: Org1MSP
        MSPDir: ./certs/peerOrganizations/org1.example.com/msp
        AnchorPeers:
            - Host: peer0.org1.example.com
              Port: 7051
    - &amp;Org2
        Name: Org2MSP
        ID: Org2MSP
        MSPDir: ./certs/peerOrganizations/org2.example.com/msp
        AnchorPeers:
            - Host: peer0.org2.example.com
              Port: 7051
Orderer: &amp;OrdererDefaults
    OrdererType: solo
    Addresses:
        - orderer.example.com:7050
    BatchTimeout: 2s
    BatchSize:
        MaxMessageCount: 10
        AbsoluteMaxBytes: 99 MB
        PreferredMaxBytes: 512 KB
    Kafka:
        Brokers:
            - 127.0.0.1:9092
    Organizations:
Application: &amp;ApplicationDefaults
    Organizations:
</code></pre> 
  <p style="text-indent:0px;">这个配置文件的内容比较多，这里就不做解释了，可以到视频解说中听讲解。</p> 
  <p style="text-indent:0px;">直接用<code>./bin/configtxgen</code>生成创世块文件。</p> 
  <pre class="highlight">
<code>./bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./genesisblock
</code></pre> 
  <p style="text-indent:0px;">将./genesisblock文件复制到192.168.88.10的/opt/app/fabric/orderer/目录中:</p> 
  <pre class="highlight">
<code>scp genesisblock root@192.168.88.10:/opt/app/fabric/orderer/
</code></pre> 
  <h2>启动</h2> 
  <p style="text-indent:0px;">分别到每台机器到orderer、peer目录中启动：</p> 
  <pre class="highlight">
<code>./orderer  &amp;
./peer node start  &amp;
</code></pre> 
  <p style="text-indent:0px;">为了方便查看输出的日志，可以写一个脚本：</p> 
  <pre class="highlight">
<code>$ cat start.sh
./orderer 2&gt;&amp;1 |tee log
</code></pre> 
  <p style="text-indent:0px;">peer的脚本如下：</p> 
  <pre class="highlight">
<code>$ cat start.sh
./peer node start 2&gt;&amp;1 |tee log
</code></pre> 
  <p style="text-indent:0px;">然后将脚本放到后台运行：</p> 
  <pre class="highlight">
<code>$ ./start.sh &amp;
</code></pre> 
  <p style="text-indent:0px;">如果程序启动失败，那么核实之前的步骤。或者到右侧的“区块链实践分享”知识星球中咨询。</p> 
  <h2>用户</h2> 
  <p style="text-indent:0px;">要使用得先有用户。在前面用<code>cryptogen</code>准备证书的时候，它默认创建了用户。</p> 
  <p style="text-indent:0px;">还记得certs目录下的几个<code>users</code>目录吗？那里面就是用户证书。</p> 
  <p style="text-indent:0px;">users目录一共有三个，分别是联盟的用户，和每个组织的用户：</p> 
  <pre class="highlight">
<code>./certs/ordererOrganizations/example.com/users
./certs/peerOrganizations/org1.example.com/users
./certs/peerOrganizations/org2.example.com/users
</code></pre> 
  <p style="text-indent:0px;">其中每个组织有两个用户，Admin和User1：</p> 
  <pre class="highlight">
<code>$ ls ./certs/peerOrganizations/org1.example.com/users
Admin@org1.example.com  User1@org1.example.com
</code></pre> 
  <p style="text-indent:0px;">Admin和User1唯一的区别是，Admin的用户证书被添加到了对一个peer的<code>msp/admincerts</code>目录中。（还记得这个目录的作用吗？）</p> 
  <h3>Admin@org1.example.com</h3> 
  <p style="text-indent:0px;">使用hyperledger fabric可以通过<a href="http://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2018/04/25/hyperledger-fabric-sdk-nodejs.html" rel="nofollow">SDK</a>，也可以使用peer命令。</p> 
  <p style="text-indent:0px;">这里直接演示peer命令的用法。</p> 
  <p style="text-indent:0px;">在fabric-deploy中创建目录<code>Admin@org1.example.com</code>，在其中存放该用户的所有资料。</p> 
  <pre class="highlight">
<code>mkdir Admin@org1.example.com
</code></pre> 
  <p style="text-indent:0px;">将用户证书复制到其中：</p> 
  <pre class="highlight">
<code>cp -rf certs/peerOrganizations/org1.example.com/users/Admin\@org1.example.com/* Admin\@org1.example.com/
</code></pre> 
  <p style="text-indent:0px;">还需要将core.yaml复制到用户目录下：</p> 
  <pre class="highlight">
<code>cp peer0.org1.example.com/core.yaml  Admin\@org1.example.com/
</code></pre> 
  <p style="text-indent:0px;">为了方便使用，在Admin@org1.example.com中创建一个peer.sh脚本：</p> 
  <pre class="highlight">
<code>#!/bin/bash
PATH=`pwd`/../bin:$PATH

export FABRIC_CFG_PATH=`pwd`

export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_TLS_CERT_FILE=./tls/client.crt
export CORE_PEER_TLS_KEY_FILE=./tls/client.key

export CORE_PEER_MSPCONFIGPATH=./msp
export CORE_PEER_ADDRESS=peer0.org1.example.com:7051
export CORE_PEER_LOCALMSPID=Org1MSP
export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt
export CORE_PEER_ID=cli
export CORE_LOGGING_LEVEL=INFO

peer $*
</code></pre> 
  <p style="text-indent:0px;">然后直接通过这个脚本访问peer0.org1.example.com:</p> 
  <pre class="highlight">
<code>$ ./peer.sh node status
status:STARTED
2018-04-29 14:32:03.517 CST [main] main -&gt; INFO 001 Exiting.....
</code></pre> 
  <p style="text-indent:0px;">可以看到<code>peer0.org1.example.com:7051</code>的状态是启动的。</p> 
  <p style="text-indent:0px;">为了后面的演示，下面使用复制替换的方式，准备另外两个用户的目录。</p> 
  <h3>User1@org1.example.com</h3> 
  <p style="text-indent:0px;">User1与Admin1使用相同的peer，因此只需要替换用户证书即可：</p> 
  <pre class="highlight">
<code>cp -rf  Admin\@org1.example.com/ User1\@org1.example.com/
rm -rf  User1\@org1.example.com/msp
rm -rf  User1\@org1.example.com/tls
cp -rf  certs/peerOrganizations/org1.example.com/users/User1\@org1.example.com/* User1\@org1.example.com/
</code></pre> 
  <p style="text-indent:0px;">执行peer.sh检验：</p> 
  <pre class="highlight">
<code>$ ./peer.sh node status
status:STARTED
2018-04-29 14:37:48.251 CST [main] main -&gt; INFO 001 Exiting.....
</code></pre> 
  <h3>Admin@org2.example.com</h3> 
  <p style="text-indent:0px;">对于Admin@org2.example.com，core.yaml也需要替换：</p> 
  <pre class="highlight">
<code>cp -rf  Admin\@org1.example.com/ Admin\@org2.example.com/
rm -rf  Admin\@org2.example.com/msp/
rm -rf  Admin\@org2.example.com/tls/
cp -rf certs/peerOrganizations/org2.example.com/users/Admin\@org2.example.com/* Admin\@org2.example.com/
cp peer0.org2.example.com/core.yaml Admin\@org2.example.com/
</code></pre> 
  <p style="text-indent:0px;">还需要将<code>peer.sh</code>中peer地址修改为org2的peer地址：</p> 
  <pre class="highlight">
<code>export CORE_PEER_ADDRESS=peer0.org1.example.com:7051
export CORE_PEER_LOCALMSPID=Org1MSP

修改为：

export CORE_PEER_ADDRESS=peer0.org2.example.com:7051
export CORE_PEER_LOCALMSPID=Org2MSP
</code></pre> 
  <p style="text-indent:0px;">验证：</p> 
  <pre class="highlight">
<code>$ ./peer.sh node status
status:STARTED
2018-04-29 14:44:22.395 CST [main] main -&gt; INFO 001 Exiting.....
</code></pre> 
  <h2>创建channel与peer的设置</h2> 
  <h3>准备channel文件</h3> 
  <p style="text-indent:0px;">这里用命令行演示channel的创建与peer的设置。(也可以通过SDK，SDK将单独讨论）</p> 
  <p style="text-indent:0px;">需要再次回到fabric-deploy目录中，用configtxgen生成channel文件：</p> 
  <pre class="highlight">
<code>./bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx mychannel.tx -channelID mychannel
</code></pre> 
  <p style="text-indent:0px;">channel名字为mychannel，生成的mychannel.tx备用。</p> 
  <p style="text-indent:0px;">还需要为每个组织的peer生成一个anchor文件，每个组织只需要一个：</p> 
  <pre class="highlight">
<code>./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP
./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP
</code></pre> 
  <p style="text-indent:0px;">生成的Org1MSPanchors.tx和Org2MSPanchors.tx备用。</p> 
  <p style="text-indent:0px;">下一步操作中需要访问orderer.example.com，需要将验证orderer.example.com的证书复制到用户目录中：</p> 
  <pre class="highlight">
<code>cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem  Admin\@org1.example.com/
cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem  User1\@org1.example.com/
cp certs/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem  Admin\@org2.example.com/
</code></pre> 
  <h3>创建channel</h3> 
  <p style="text-indent:0px;">在Admin@org1.exampl.com目录中执行下面的命令，：</p> 
  <pre class="highlight">
<code>./peer.sh channel create -o orderer.example.com:7050 -c mychannel -f ../mychannel.tx --tls true --cafile tlsca.example.com-cert.pem
</code></pre> 
  <p style="text-indent:0px;">执行完成后，会生成一个<code>mychannel.block</code>文件：</p> 
  <pre class="highlight">
<code>$ ls
core.yaml  msp  mychannel.block  peer.sh  tls  tlsca.example.com-cert.pem
</code></pre> 
  <p style="text-indent:0px;">将mychannel.block复制一份到<code>Admin\@org2.example.com/</code>中备用：</p> 
  <pre class="highlight">
<code>cp Admin\@org1.example.com/mychannel.block Admin\@org2.example.com/
</code></pre> 
  <h3>将peer加入channel</h3> 
  <p style="text-indent:0px;"><strong>分别</strong>在<code>Admin\@org1.example.com/</code>和<code>Admin\@org2.example.com/</code>执行下面的命令：</p> 
  <pre class="highlight">
<code>./peer.sh channel join -b mychannel.block
</code></pre> 
  <p style="text-indent:0px;">因为org1有两个peer，因此需要将peer.sh中peer修改为<code>peer1.org1.example.com</code>后，再添加一次：</p> 
  <pre class="highlight">
<code>./peer.sh channel join -b mychannel.block
</code></pre> 
  <p style="text-indent:0px;">可以用channel list查看peer所在channel</p> 
  <pre class="highlight">
<code>$ ./peer.sh channel list
2018-04-29 16:37:47.016 CST [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized
Channels peers has joined:
mychannel
2018-04-29 16:37:47.018 CST [main] main -&gt; INFO 002 Exiting.....
</code></pre> 
  <p style="text-indent:0px;">最后需要每个组织指定一个anchor peer，anchor peer是组织用来与外部通信的peer:</p> 
  <pre class="highlight">
<code>cd Admin\@org1.example.com/
./peer.sh channel update -o orderer.example.com:7050 -c mychannel -f ../Org1MSPanchors.tx --tls true --cafile ./tlsca.example.com-cert.pem

cd Admin\@org2.example.com/
./peer.sh channel update -o orderer.example.com:7050 -c mychannel -f ../Org2MSPanchors.tx --tls true --cafile ./tlsca.example.com-cert.pem
</code></pre> 
  <h2>安装合约（chaincode）</h2> 
  <p style="text-indent:0px;">在hyperledger fabric中，合约被称为chaincode。</p> 
  <p style="text-indent:0px;">需要安装一个go语言的开发环境，安装方法这里就不介绍了。</p> 
  <p style="text-indent:0px;">这里将go的开发环境安装在fabric-deploy所在的机器上。</p> 
  <p style="text-indent:0px;">直接用<code>go get</code>获取一份合约代码：</p> 
  <pre class="highlight">
<code>go get github.com/lijiaocn/fabric-chaincode-example/demo
</code></pre> 
  <p style="text-indent:0px;">到<code>Admin@org1.example.com/</code>目录下，以Admin@org1.example.com的身份打包合约:</p> 
  <pre class="highlight">
<code>cd Admin\@org1.example.com/
</code></pre> 
  <p style="text-indent:0px;">执行下面命令进行合约打包与签署：</p> 
  <pre class="highlight">
<code>./peer.sh chaincode package demo-pack.out -n demo -v 0.0.1 -s -S -p github.com/lijiaocn/fabric-chaincode-example/demo
./peer.sh chaincode signpackage demo-pack.out signed-demo-pack.out
</code></pre> 
  <p style="text-indent:0px;">然后安装合约：</p> 
  <pre class="highlight">
<code>./peer.sh chaincode install ./signed-demo-pack.out
</code></pre> 
  <p style="text-indent:0px;">安装之后，可以用chaincode list查看peer上已经安装的合约。</p> 
  <pre class="highlight">
<code>$ ./peer.sh chaincode list   --installed
Get installed chaincodes on peer:
Name: demo, Version: 0.0.1, Path: github.com/lijiaocn/fabric-chaincode-example/demo, Id: 3d733bd28accf77b06b2bec065d8ce7315bd7c5441c51beea4650982f79eab46
2018-04-29 18:57:54.327 CST [main] main -&gt; INFO 001 Exiting....
</code></pre> 
  <p style="text-indent:0px;">chaincode只能用Admin安装，并且需要在每个peer上都安装一次。</p> 
  <p style="text-indent:0px;">因此需要将peer0.org1.example.com切换为peer1.org1.example.com后，再次安装一次：</p> 
  <pre class="highlight">
<code>./peer.sh chaincode install ./signed-demo-pack.out  (不需要重新打包签署)
</code></pre> 
  <p style="text-indent:0px;">将signed-demo-pack.out复制到<code>Admin@org2.exmaple.com</code>中安装一次</p> 
  <pre class="highlight">
<code>cp Admin\@org1.example.com/signed-demo-pack.out  Admin\@org2.example.com/
cd Admin\@org2.example.com/
./peer.sh chaincode install ./signed-demo-pack.out
</code></pre> 
  <h2>合约初始化</h2> 
  <p style="text-indent:0px;">合约安装之后，需要进行一次初始化，只能由创建合约的用户进行初始化:</p> 
  <pre class="highlight">
<code>cd Admin\@org1.example.com/
./peer.sh chaincode instantiate -o orderer.example.com:7050 --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -v 0.0.1 -c '{"Args":["init"]}' -P "OR('Org1MSP.member','Org2MSP.member')"
</code></pre> 
  <p style="text-indent:0px;">第一进行合约初始化的时候的会比较慢，因为需要需要创建、启动容器。</p> 
  <h2>合约调用</h2> 
  <p style="text-indent:0px;">可以在任意一个peer上调用合约，例如以admin@org2.example.com的进行写操作：</p> 
  <pre class="highlight">
<code>cd Admin\@org2.example.com/
./peer.sh chaincode invoke -o orderer.example.com:7050  --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -c '{"Args":["write","key1","key1 value is abc"]}'
</code></pre> 
  <p style="text-indent:0px;">如果是第一次在一个peer访问一个合约，这个peer需要先启动容器，响应会比较慢。进行写操作（invoke命令）时，需要指定orderer（-o orderer.example.com:7050）。</p> 
  <p style="text-indent:0px;">进行查询操作时，不需要指定orderer，例如：</p> 
  <pre class="highlight">
<code>cd User1\@org1.example.com/
./peer.sh chaincode query -C mychannel -n demo -c '{"Args":["query","key1"]}'
</code></pre> 
  <h2>更新合约</h2> 
  <p style="text-indent:0px;">将更改后的合约重新打包，使用一个新的版本号：</p> 
  <pre class="highlight">
<code>cd Admin\@org1.example.com/
</code></pre> 
  <p style="text-indent:0px;">执行下面命令进行合约打包与签署：</p> 
  <pre class="highlight">
<code>./peer.sh chaincode package demo-pack-2.out -n demo -v 0.0.2 -s -S -p github.com/lijiaocn/fabric-chaincode-example/demo
./peer.sh chaincode signpackage demo-pack-2.out signed-demo-pack-2.out
</code></pre> 
  <p style="text-indent:0px;">然后安装合约：</p> 
  <pre class="highlight">
<code>./peer.sh chaincode install ./signed-demo-pack-2.out
</code></pre> 
  <p style="text-indent:0px;">更新的合约不需要初始化，需要进行更新操作：</p> 
  <pre class="highlight">
<code>./peer.sh chaincode upgrade -o orderer.example.com:7050 --tls true --cafile ./tlsca.example.com-cert.pem -C mychannel -n demo -v 0.0.2 -c '{"Args":["init"]}' -P "OR('Org1MSP.member','Org2MSP.member')"
</code></pre> 
  <p style="text-indent:0px;">新的合约也需要在每个peer上单独安装。</p> 
  <p style="text-indent:0px;">因此需要将peer0.org1.example.com切换为peer1.org1.example.com后，再次安装一次：</p> 
  <pre class="highlight">
<code>./peer.sh chaincode install ./signed-demo-pack-2.out  (不需要重新打包签署)
</code></pre> 
  <p style="text-indent:0px;">将signed-demo-pack.out复制到<code>Admin@org2.exmaple.com</code>中安装一次</p> 
  <pre class="highlight">
<code>cp Admin\@org1.example.com/signed-demo-pack-2.out  Admin\@org2.example.com/
cd Admin\@org2.example.com/
./peer.sh chaincode install ./signed-demo-pack-2.out
</code></pre> 
  <p style="text-indent:0px;">视频纪录发布在：&nbsp;<a href="http://study.163.com/course/introduction.htm?courseId=1005326005&amp;share=2&amp;shareId=400000000376006" rel="nofollow">网易云课堂视频教程：HyperLedger Fabric全手动部署</a></p> 
  <p style="text-indent:0px;">可以到星球里找我要优惠券或者提问：</p> 
  <p style="text-indent:0px;"><img alt="区块链实践分享" class="has" src="http://www.lijiaocn.com/img/xiaomiquan-blockchain.jpg"></p> 
  <h2>参考</h2> 
  <ol>
   <li><a href="http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html" rel="nofollow">Building Your First Network</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/02/23/hyperledger-fabric-usage.html#fabric%E7%BC%96%E8%AF%91" rel="nofollow">hyperledger fabric编译</a></li> 
   <li><a href="https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/" rel="nofollow">hyperledger fabric download</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/27/hyperledger-fabric-ca-usage.html" rel="nofollow">hyperledger的fabricCA的使用</a></li> 
   <li><a href="http://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2018/04/25/hyperledger-fabric-sdk-nodejs.html" rel="nofollow">hyperledger项目fabric的nodejsSDK的使用</a></li> 
   <li><a href="http://study.163.com/course/introduction.htm?courseId=1005326005&amp;share=2&amp;shareId=400000000376006" rel="nofollow">网易云课堂视频教程：HyperLedger Fabric全手动部署</a></li> 
  </ol> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lijiaocn/article/details/80261501,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lijiaocn/article/details/80261501,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
