<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链技术实现只需180行go代码！ | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链技术实现只需180行go代码！" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="通过本文，你将可以使用Go创建自己的区块链、理解哈希函数是如何保持区块链的完整性、掌握如何创造并添加新的块、实现多个节点通过竞争生成块、通过浏览器来查看整个链、了解所有其他关于区块链的基础知识。 如果你希望马上开始学习以太坊DApp开发，可以访问汇智网提供的出色的在线互动教程： 以太坊DApp实战开发入门 去中心化电商DApp实战开发 但是，文章中将不会涉及工作量证明算法（PoW）以及权益证明算法（PoS）这类的共识算法，同时为了让你更清楚得查看区块链以及块的添加，我们将网络交互的过程简化了，关于 P2P 网络比如“全网广播”这个过程等内容将在后续文章中补上。 开发环境 我们假设你已经具备一点 Go 语言的开发经验。在安装和配置 Go 开发环境后之后，我们还要获取以下一些依赖： ~$ go get github.com/davecgh/go-spew/spew spew可以帮助我们在终端中中直接查看 struct 和 slice 这两种数据结构。 ~$ go get github.com/gorilla/mux Gorilla 的 mux 包非常流行， 我们用它来写 web handler。 ~$ go get github.com/joho/godotenv godotenv可以帮助我们读取项目根目录中的.env 配置文件，这样就不用将 http端口之类的配置硬编码进代码中了。比如像这样： ADDR=8080 接下来，我们创建一个 main.go 文件。之后的大部分工作都围绕这个文件，开始写代码吧！ 导入依赖包 我们将所有的依赖包以声明的方式导入进去： package main import ( &quot;crypto/sha256&quot; &quot;encoding/hex&quot; &quot;encoding/json&quot; &quot;io&quot; &quot;log&quot; &quot;net/http&quot; &quot;os&quot; &quot;time&quot; &quot;github.com/davecgh/go-spew/spew&quot; &quot;github.com/gorilla/mux&quot; &quot;github.com/joho/godotenv&quot; ) 数据模型 接着我们来定义一个结构体，它代表组成区块链的每一个块的数据模型： type Block struct { Index int Timestamp string BPM int Hash string PrevHash string } Index 是这个块在整个链中的位置 Timestamp 显而易见就是块生成时的时间戳 Hash 是这个块通过 SHA256 算法生成的散列值 PrevHash 代表前一个块的 SHA256 散列值 BPM 每分钟心跳数，也就是心率 接着，我们再定义一个结构表示整个链，最简单的表示形式就是一个 Block 的 slice： var Blockchain []Block 我们使用散列算法（SHA256）来确定和维护链中块和块正确的顺序，确保每一个块的 PrevHash 值等于前一个块中的 Hash 值，这样就以正确的块顺序构建出链： 散列和生成新块 我们为什么需要散列？主要是两个原因： 在节省空间的前提下去唯一标识数据。散列是用整个块的数据计算得出，在我们的例子中，将整个块的数据通过 SHA256 计算成一个定长不可伪造的字符串。 维持链的完整性。通过存储前一个块的散列值，我们就能够确保每个块在链中的正确顺序。任何对数据的篡改都将改变散列值，同时也就破坏了链。以我们从事的医疗健康领域为例，比如有一个恶意的第三方为了调整“人寿险”的价格，而修改了一个或若干个块中的代表不健康的 BPM 值，那么整个链都变得不可信了。 我们接着写一个函数，用来计算给定的数据的 SHA256 散列值： func calculateHash(block Block) string { record := string(block.Index) + block.Timestamp + string(block.BPM) + block.PrevHash h := sha256.New() h.Write([]byte(record)) hashed := h.Sum(nil) return hex.EncodeToString(hashed) } 这个 calculateHash 函数接受一个块，通过块中的 Index，Timestamp，BPM，以及 PrevHash 值来计算出 SHA256 散列值。接下来我们就能编写一个生成块的函数： func generateBlock(oldBlock Block, BPM int) (Block, error) { var newBlock Block t := time.Now() newBlock.Index = oldBlock.Index + 1 newBlock.Timestamp = t.String() newBlock.BPM = BPM newBlock.PrevHash = oldBlock.Hash newBlock.Hash = calculateHash(newBlock) return newBlock, nil } 其中，Index 是从给定的前一块的 Index 递增得出，时间戳是直接通过 time.Now() 函数来获得的，Hash 值通过前面的 calculateHash 函数计算得出，PrevHash 则是给定的前一个块的 Hash 值。 校验块 搞定了块的生成，接下来我们需要有函数帮我们判断一个块是否有被篡改。检查 Index 来看这个块是否正确得递增，检查 PrevHash 与前一个块的 Hash 是否一致，再来通过 calculateHash 检查当前块的 Hash 值是否正确。通过这几步我们就能写出一个校验函数： func isBlockValid(newBlock, oldBlock Block) bool { if oldBlock.Index+1 != newBlock.Index { return false } if oldBlock.Hash != newBlock.PrevHash { return false } if calculateHash(newBlock) != newBlock.Hash { return false } return true } 除了校验块以外，我们还会遇到一个问题：两个节点都生成块并添加到各自的链上，那我们应该以谁为准？这里的细节我们留到下一篇文章， 这里先让我们记住一个原则：始终选择最长的链： 通常来说，更长的链表示它的数据（状态）是更新的，所以我们需要一个函数能帮我们将本地的过期的链切换成最新的链： func replaceChain(newBlocks []Block) { if len(newBlocks) &gt; len(Blockchain) { Blockchain = newBlocks } } 到这一步，我们基本就把所有重要的函数完成了。接下来，我们需要一个方便直观的方式来查看我们的链，包括数据及状态。通过浏览器查看 web 页面可能是最合适的方式！ Web 服务 我猜你一定对传统的 web 服务及开发非常熟悉，所以这部分你肯定一看就会。 借助 Gorilla/mux 包，我们先写一个函数来初始化我们的 web 服务： func run() error { mux := makeMuxRouter() httpAddr := os.Getenv(&quot;ADDR&quot;) log.Println(&quot;Listening on &quot;, os.Getenv(&quot;ADDR&quot;)) s := &amp;http.Server{ Addr: &quot;:&quot; + httpAddr, Handler: mux, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 &lt;&lt; 20, } if err := s.ListenAndServe(); err != nil { return err } return nil } 其中的端口号是通过前面提到的 .env 来获得，再添加一些基本的配置参数，这个 web 服务就已经可以 listen and serve 了！ 接下来我们再来定义不同 endpoint 以及对应的 handler。例如，对“/”的 GET 请求我们可以查看整个链，“/”的 POST 请求可以创建块。 func makeMuxRouter() http.Handler { muxRouter := mux.NewRouter() muxRouter.HandleFunc(&quot;/&quot;, handleGetBlockchain).Methods(&quot;GET&quot;) muxRouter.HandleFunc(&quot;/&quot;, handleWriteBlock).Methods(&quot;POST&quot;) return muxRouter } GET 请求的 handler： func handleGetBlockchain(w http.ResponseWriter, r *http.Request) { bytes, err := json.MarshalIndent(Blockchain, &quot;&quot;, &quot; &quot;) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } io.WriteString(w, string(bytes)) } 为了简化，我们直接以 JSON 格式返回整个链，你可以在浏览器中访问 localhost:8080 或者 127.0.0.1:8080 来查看（这里的8080就是你在 .env 中定义的端口号 ADDR）。 POST 请求的 handler 稍微有些复杂，我们先来定义一下 POST 请求的 payload： type Message struct { BPM int } 再看看 handler 的实现： func handleWriteBlock(w http.ResponseWriter, r *http.Request) { var m Message decoder := json.NewDecoder(r.Body) if err := decoder.Decode(&amp;m); err != nil { respondWithJSON(w, r, http.StatusBadRequest, r.Body) return } defer r.Body.Close() newBlock, err := generateBlock(Blockchain[len(Blockchain)-1], m.BPM) if err != nil { respondWithJSON(w, r, http.StatusInternalServerError, m) return } if isBlockValid(newBlock, Blockchain[len(Blockchain)-1]) { newBlockchain := append(Blockchain, newBlock) replaceChain(newBlockchain) spew.Dump(Blockchain) } respondWithJSON(w, r, http.StatusCreated, newBlock) } 我们的 POST 请求体中可以使用上面定义的 payload，比如： {&quot;BPM&quot;:75} 还记得前面我们写的 generateBlock 这个函数吗？它接受一个“前一个块”参数，和一个 BPM 值。POST handler 接受请求后就能获得请求体中的 BPM 值，接着借助生成块的函数以及校验块的函数就能生成一个新的块了！ 除此之外，你也可以： 使用spew.Dump 这个函数可以以非常美观和方便阅读的方式将 struct、slice 等数据打印在控制台里，方便我们调试。 测试 POST 请求时，可以使用 POSTMAN 这个 chrome 插件，相比 curl它更直观和方便。 POST 请求处理完之后，无论创建块成功与否，我们需要返回客户端一个响应： func respondWithJSON(w http.ResponseWriter, r *http.Request, code int, payload interface{}) { response, err := json.MarshalIndent(payload, &quot;&quot;, &quot; &quot;) if err != nil { w.WriteHeader(http.StatusInternalServerError) w.Write([]byte(&quot;HTTP 500: Internal Server Error&quot;)) return } w.WriteHeader(code) w.Write(response) } 快要大功告成了。 接下来，我们把这些关于区块链的函数，web 服务的函数“组装”起来： func main() { err := godotenv.Load() if err != nil { log.Fatal(err) } go func() { t := time.Now() genesisBlock := Block{0, t.String(), 0, &quot;&quot;, &quot;&quot;} spew.Dump(genesisBlock) Blockchain = append(Blockchain, genesisBlock) }() log.Fatal(run()) } 这里的 genesisBlock （创世块）是 main 函数中最重要的部分，通过它来初始化区块链，毕竟第一个块的 PrevHash 是空的。 哦耶！完成了 可以从这里获得完整的代码：Github repo 让我们来启动它： ~$ go run main.go 在终端中，我们可以看到 web 服务器启动的日志信息，并且打印出了创世块的信息： 接着我们打开浏览器，访问 localhost:8080 这个地址，我们可以看到页面中展示了当前整个区块链的信息（当然，目前只有一个创世块）： 接着，我们再通过 POSTMAN 来发送一些 POST 请求： 刷新刚才的页面，现在的链中多了一些块，正是我们刚才生成的，同时你们可以看到，块的顺序和散列值都正确。 总结 刚刚我们完成了一个自己的区块链，虽然很简单（陋），但它具备块生成、散列计算、块校验等基本能力。接下来你就可以继续深入的学习 区块链的其他重要知识，比如工作量证明、权益证明这样的共识算法，或者是智能合约、Dapp、侧链等等。 目前这个实现中不包括任何 P2P 网络的内容，我们会在下一篇文章中补充这部分内容，当然，我们鼓励你在这个基础上自己实践一遍！ 原文：180行go代码让你彻底理解区块链是什么 阅读更多" />
<meta property="og:description" content="通过本文，你将可以使用Go创建自己的区块链、理解哈希函数是如何保持区块链的完整性、掌握如何创造并添加新的块、实现多个节点通过竞争生成块、通过浏览器来查看整个链、了解所有其他关于区块链的基础知识。 如果你希望马上开始学习以太坊DApp开发，可以访问汇智网提供的出色的在线互动教程： 以太坊DApp实战开发入门 去中心化电商DApp实战开发 但是，文章中将不会涉及工作量证明算法（PoW）以及权益证明算法（PoS）这类的共识算法，同时为了让你更清楚得查看区块链以及块的添加，我们将网络交互的过程简化了，关于 P2P 网络比如“全网广播”这个过程等内容将在后续文章中补上。 开发环境 我们假设你已经具备一点 Go 语言的开发经验。在安装和配置 Go 开发环境后之后，我们还要获取以下一些依赖： ~$ go get github.com/davecgh/go-spew/spew spew可以帮助我们在终端中中直接查看 struct 和 slice 这两种数据结构。 ~$ go get github.com/gorilla/mux Gorilla 的 mux 包非常流行， 我们用它来写 web handler。 ~$ go get github.com/joho/godotenv godotenv可以帮助我们读取项目根目录中的.env 配置文件，这样就不用将 http端口之类的配置硬编码进代码中了。比如像这样： ADDR=8080 接下来，我们创建一个 main.go 文件。之后的大部分工作都围绕这个文件，开始写代码吧！ 导入依赖包 我们将所有的依赖包以声明的方式导入进去： package main import ( &quot;crypto/sha256&quot; &quot;encoding/hex&quot; &quot;encoding/json&quot; &quot;io&quot; &quot;log&quot; &quot;net/http&quot; &quot;os&quot; &quot;time&quot; &quot;github.com/davecgh/go-spew/spew&quot; &quot;github.com/gorilla/mux&quot; &quot;github.com/joho/godotenv&quot; ) 数据模型 接着我们来定义一个结构体，它代表组成区块链的每一个块的数据模型： type Block struct { Index int Timestamp string BPM int Hash string PrevHash string } Index 是这个块在整个链中的位置 Timestamp 显而易见就是块生成时的时间戳 Hash 是这个块通过 SHA256 算法生成的散列值 PrevHash 代表前一个块的 SHA256 散列值 BPM 每分钟心跳数，也就是心率 接着，我们再定义一个结构表示整个链，最简单的表示形式就是一个 Block 的 slice： var Blockchain []Block 我们使用散列算法（SHA256）来确定和维护链中块和块正确的顺序，确保每一个块的 PrevHash 值等于前一个块中的 Hash 值，这样就以正确的块顺序构建出链： 散列和生成新块 我们为什么需要散列？主要是两个原因： 在节省空间的前提下去唯一标识数据。散列是用整个块的数据计算得出，在我们的例子中，将整个块的数据通过 SHA256 计算成一个定长不可伪造的字符串。 维持链的完整性。通过存储前一个块的散列值，我们就能够确保每个块在链中的正确顺序。任何对数据的篡改都将改变散列值，同时也就破坏了链。以我们从事的医疗健康领域为例，比如有一个恶意的第三方为了调整“人寿险”的价格，而修改了一个或若干个块中的代表不健康的 BPM 值，那么整个链都变得不可信了。 我们接着写一个函数，用来计算给定的数据的 SHA256 散列值： func calculateHash(block Block) string { record := string(block.Index) + block.Timestamp + string(block.BPM) + block.PrevHash h := sha256.New() h.Write([]byte(record)) hashed := h.Sum(nil) return hex.EncodeToString(hashed) } 这个 calculateHash 函数接受一个块，通过块中的 Index，Timestamp，BPM，以及 PrevHash 值来计算出 SHA256 散列值。接下来我们就能编写一个生成块的函数： func generateBlock(oldBlock Block, BPM int) (Block, error) { var newBlock Block t := time.Now() newBlock.Index = oldBlock.Index + 1 newBlock.Timestamp = t.String() newBlock.BPM = BPM newBlock.PrevHash = oldBlock.Hash newBlock.Hash = calculateHash(newBlock) return newBlock, nil } 其中，Index 是从给定的前一块的 Index 递增得出，时间戳是直接通过 time.Now() 函数来获得的，Hash 值通过前面的 calculateHash 函数计算得出，PrevHash 则是给定的前一个块的 Hash 值。 校验块 搞定了块的生成，接下来我们需要有函数帮我们判断一个块是否有被篡改。检查 Index 来看这个块是否正确得递增，检查 PrevHash 与前一个块的 Hash 是否一致，再来通过 calculateHash 检查当前块的 Hash 值是否正确。通过这几步我们就能写出一个校验函数： func isBlockValid(newBlock, oldBlock Block) bool { if oldBlock.Index+1 != newBlock.Index { return false } if oldBlock.Hash != newBlock.PrevHash { return false } if calculateHash(newBlock) != newBlock.Hash { return false } return true } 除了校验块以外，我们还会遇到一个问题：两个节点都生成块并添加到各自的链上，那我们应该以谁为准？这里的细节我们留到下一篇文章， 这里先让我们记住一个原则：始终选择最长的链： 通常来说，更长的链表示它的数据（状态）是更新的，所以我们需要一个函数能帮我们将本地的过期的链切换成最新的链： func replaceChain(newBlocks []Block) { if len(newBlocks) &gt; len(Blockchain) { Blockchain = newBlocks } } 到这一步，我们基本就把所有重要的函数完成了。接下来，我们需要一个方便直观的方式来查看我们的链，包括数据及状态。通过浏览器查看 web 页面可能是最合适的方式！ Web 服务 我猜你一定对传统的 web 服务及开发非常熟悉，所以这部分你肯定一看就会。 借助 Gorilla/mux 包，我们先写一个函数来初始化我们的 web 服务： func run() error { mux := makeMuxRouter() httpAddr := os.Getenv(&quot;ADDR&quot;) log.Println(&quot;Listening on &quot;, os.Getenv(&quot;ADDR&quot;)) s := &amp;http.Server{ Addr: &quot;:&quot; + httpAddr, Handler: mux, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 &lt;&lt; 20, } if err := s.ListenAndServe(); err != nil { return err } return nil } 其中的端口号是通过前面提到的 .env 来获得，再添加一些基本的配置参数，这个 web 服务就已经可以 listen and serve 了！ 接下来我们再来定义不同 endpoint 以及对应的 handler。例如，对“/”的 GET 请求我们可以查看整个链，“/”的 POST 请求可以创建块。 func makeMuxRouter() http.Handler { muxRouter := mux.NewRouter() muxRouter.HandleFunc(&quot;/&quot;, handleGetBlockchain).Methods(&quot;GET&quot;) muxRouter.HandleFunc(&quot;/&quot;, handleWriteBlock).Methods(&quot;POST&quot;) return muxRouter } GET 请求的 handler： func handleGetBlockchain(w http.ResponseWriter, r *http.Request) { bytes, err := json.MarshalIndent(Blockchain, &quot;&quot;, &quot; &quot;) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } io.WriteString(w, string(bytes)) } 为了简化，我们直接以 JSON 格式返回整个链，你可以在浏览器中访问 localhost:8080 或者 127.0.0.1:8080 来查看（这里的8080就是你在 .env 中定义的端口号 ADDR）。 POST 请求的 handler 稍微有些复杂，我们先来定义一下 POST 请求的 payload： type Message struct { BPM int } 再看看 handler 的实现： func handleWriteBlock(w http.ResponseWriter, r *http.Request) { var m Message decoder := json.NewDecoder(r.Body) if err := decoder.Decode(&amp;m); err != nil { respondWithJSON(w, r, http.StatusBadRequest, r.Body) return } defer r.Body.Close() newBlock, err := generateBlock(Blockchain[len(Blockchain)-1], m.BPM) if err != nil { respondWithJSON(w, r, http.StatusInternalServerError, m) return } if isBlockValid(newBlock, Blockchain[len(Blockchain)-1]) { newBlockchain := append(Blockchain, newBlock) replaceChain(newBlockchain) spew.Dump(Blockchain) } respondWithJSON(w, r, http.StatusCreated, newBlock) } 我们的 POST 请求体中可以使用上面定义的 payload，比如： {&quot;BPM&quot;:75} 还记得前面我们写的 generateBlock 这个函数吗？它接受一个“前一个块”参数，和一个 BPM 值。POST handler 接受请求后就能获得请求体中的 BPM 值，接着借助生成块的函数以及校验块的函数就能生成一个新的块了！ 除此之外，你也可以： 使用spew.Dump 这个函数可以以非常美观和方便阅读的方式将 struct、slice 等数据打印在控制台里，方便我们调试。 测试 POST 请求时，可以使用 POSTMAN 这个 chrome 插件，相比 curl它更直观和方便。 POST 请求处理完之后，无论创建块成功与否，我们需要返回客户端一个响应： func respondWithJSON(w http.ResponseWriter, r *http.Request, code int, payload interface{}) { response, err := json.MarshalIndent(payload, &quot;&quot;, &quot; &quot;) if err != nil { w.WriteHeader(http.StatusInternalServerError) w.Write([]byte(&quot;HTTP 500: Internal Server Error&quot;)) return } w.WriteHeader(code) w.Write(response) } 快要大功告成了。 接下来，我们把这些关于区块链的函数，web 服务的函数“组装”起来： func main() { err := godotenv.Load() if err != nil { log.Fatal(err) } go func() { t := time.Now() genesisBlock := Block{0, t.String(), 0, &quot;&quot;, &quot;&quot;} spew.Dump(genesisBlock) Blockchain = append(Blockchain, genesisBlock) }() log.Fatal(run()) } 这里的 genesisBlock （创世块）是 main 函数中最重要的部分，通过它来初始化区块链，毕竟第一个块的 PrevHash 是空的。 哦耶！完成了 可以从这里获得完整的代码：Github repo 让我们来启动它： ~$ go run main.go 在终端中，我们可以看到 web 服务器启动的日志信息，并且打印出了创世块的信息： 接着我们打开浏览器，访问 localhost:8080 这个地址，我们可以看到页面中展示了当前整个区块链的信息（当然，目前只有一个创世块）： 接着，我们再通过 POSTMAN 来发送一些 POST 请求： 刷新刚才的页面，现在的链中多了一些块，正是我们刚才生成的，同时你们可以看到，块的顺序和散列值都正确。 总结 刚刚我们完成了一个自己的区块链，虽然很简单（陋），但它具备块生成、散列计算、块校验等基本能力。接下来你就可以继续深入的学习 区块链的其他重要知识，比如工作量证明、权益证明这样的共识算法，或者是智能合约、Dapp、侧链等等。 目前这个实现中不包括任何 P2P 网络的内容，我们会在下一篇文章中补充这部分内容，当然，我们鼓励你在这个基础上自己实践一遍！ 原文：180行go代码让你彻底理解区块链是什么 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/05/05/e6ec9baeca5c56cef78178a91c997b4f.html" />
<meta property="og:url" content="https://mlh.app/2018/05/05/e6ec9baeca5c56cef78178a91c997b4f.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-05T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"通过本文，你将可以使用Go创建自己的区块链、理解哈希函数是如何保持区块链的完整性、掌握如何创造并添加新的块、实现多个节点通过竞争生成块、通过浏览器来查看整个链、了解所有其他关于区块链的基础知识。 如果你希望马上开始学习以太坊DApp开发，可以访问汇智网提供的出色的在线互动教程： 以太坊DApp实战开发入门 去中心化电商DApp实战开发 但是，文章中将不会涉及工作量证明算法（PoW）以及权益证明算法（PoS）这类的共识算法，同时为了让你更清楚得查看区块链以及块的添加，我们将网络交互的过程简化了，关于 P2P 网络比如“全网广播”这个过程等内容将在后续文章中补上。 开发环境 我们假设你已经具备一点 Go 语言的开发经验。在安装和配置 Go 开发环境后之后，我们还要获取以下一些依赖： ~$ go get github.com/davecgh/go-spew/spew spew可以帮助我们在终端中中直接查看 struct 和 slice 这两种数据结构。 ~$ go get github.com/gorilla/mux Gorilla 的 mux 包非常流行， 我们用它来写 web handler。 ~$ go get github.com/joho/godotenv godotenv可以帮助我们读取项目根目录中的.env 配置文件，这样就不用将 http端口之类的配置硬编码进代码中了。比如像这样： ADDR=8080 接下来，我们创建一个 main.go 文件。之后的大部分工作都围绕这个文件，开始写代码吧！ 导入依赖包 我们将所有的依赖包以声明的方式导入进去： package main import ( &quot;crypto/sha256&quot; &quot;encoding/hex&quot; &quot;encoding/json&quot; &quot;io&quot; &quot;log&quot; &quot;net/http&quot; &quot;os&quot; &quot;time&quot; &quot;github.com/davecgh/go-spew/spew&quot; &quot;github.com/gorilla/mux&quot; &quot;github.com/joho/godotenv&quot; ) 数据模型 接着我们来定义一个结构体，它代表组成区块链的每一个块的数据模型： type Block struct { Index int Timestamp string BPM int Hash string PrevHash string } Index 是这个块在整个链中的位置 Timestamp 显而易见就是块生成时的时间戳 Hash 是这个块通过 SHA256 算法生成的散列值 PrevHash 代表前一个块的 SHA256 散列值 BPM 每分钟心跳数，也就是心率 接着，我们再定义一个结构表示整个链，最简单的表示形式就是一个 Block 的 slice： var Blockchain []Block 我们使用散列算法（SHA256）来确定和维护链中块和块正确的顺序，确保每一个块的 PrevHash 值等于前一个块中的 Hash 值，这样就以正确的块顺序构建出链： 散列和生成新块 我们为什么需要散列？主要是两个原因： 在节省空间的前提下去唯一标识数据。散列是用整个块的数据计算得出，在我们的例子中，将整个块的数据通过 SHA256 计算成一个定长不可伪造的字符串。 维持链的完整性。通过存储前一个块的散列值，我们就能够确保每个块在链中的正确顺序。任何对数据的篡改都将改变散列值，同时也就破坏了链。以我们从事的医疗健康领域为例，比如有一个恶意的第三方为了调整“人寿险”的价格，而修改了一个或若干个块中的代表不健康的 BPM 值，那么整个链都变得不可信了。 我们接着写一个函数，用来计算给定的数据的 SHA256 散列值： func calculateHash(block Block) string { record := string(block.Index) + block.Timestamp + string(block.BPM) + block.PrevHash h := sha256.New() h.Write([]byte(record)) hashed := h.Sum(nil) return hex.EncodeToString(hashed) } 这个 calculateHash 函数接受一个块，通过块中的 Index，Timestamp，BPM，以及 PrevHash 值来计算出 SHA256 散列值。接下来我们就能编写一个生成块的函数： func generateBlock(oldBlock Block, BPM int) (Block, error) { var newBlock Block t := time.Now() newBlock.Index = oldBlock.Index + 1 newBlock.Timestamp = t.String() newBlock.BPM = BPM newBlock.PrevHash = oldBlock.Hash newBlock.Hash = calculateHash(newBlock) return newBlock, nil } 其中，Index 是从给定的前一块的 Index 递增得出，时间戳是直接通过 time.Now() 函数来获得的，Hash 值通过前面的 calculateHash 函数计算得出，PrevHash 则是给定的前一个块的 Hash 值。 校验块 搞定了块的生成，接下来我们需要有函数帮我们判断一个块是否有被篡改。检查 Index 来看这个块是否正确得递增，检查 PrevHash 与前一个块的 Hash 是否一致，再来通过 calculateHash 检查当前块的 Hash 值是否正确。通过这几步我们就能写出一个校验函数： func isBlockValid(newBlock, oldBlock Block) bool { if oldBlock.Index+1 != newBlock.Index { return false } if oldBlock.Hash != newBlock.PrevHash { return false } if calculateHash(newBlock) != newBlock.Hash { return false } return true } 除了校验块以外，我们还会遇到一个问题：两个节点都生成块并添加到各自的链上，那我们应该以谁为准？这里的细节我们留到下一篇文章， 这里先让我们记住一个原则：始终选择最长的链： 通常来说，更长的链表示它的数据（状态）是更新的，所以我们需要一个函数能帮我们将本地的过期的链切换成最新的链： func replaceChain(newBlocks []Block) { if len(newBlocks) &gt; len(Blockchain) { Blockchain = newBlocks } } 到这一步，我们基本就把所有重要的函数完成了。接下来，我们需要一个方便直观的方式来查看我们的链，包括数据及状态。通过浏览器查看 web 页面可能是最合适的方式！ Web 服务 我猜你一定对传统的 web 服务及开发非常熟悉，所以这部分你肯定一看就会。 借助 Gorilla/mux 包，我们先写一个函数来初始化我们的 web 服务： func run() error { mux := makeMuxRouter() httpAddr := os.Getenv(&quot;ADDR&quot;) log.Println(&quot;Listening on &quot;, os.Getenv(&quot;ADDR&quot;)) s := &amp;http.Server{ Addr: &quot;:&quot; + httpAddr, Handler: mux, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 &lt;&lt; 20, } if err := s.ListenAndServe(); err != nil { return err } return nil } 其中的端口号是通过前面提到的 .env 来获得，再添加一些基本的配置参数，这个 web 服务就已经可以 listen and serve 了！ 接下来我们再来定义不同 endpoint 以及对应的 handler。例如，对“/”的 GET 请求我们可以查看整个链，“/”的 POST 请求可以创建块。 func makeMuxRouter() http.Handler { muxRouter := mux.NewRouter() muxRouter.HandleFunc(&quot;/&quot;, handleGetBlockchain).Methods(&quot;GET&quot;) muxRouter.HandleFunc(&quot;/&quot;, handleWriteBlock).Methods(&quot;POST&quot;) return muxRouter } GET 请求的 handler： func handleGetBlockchain(w http.ResponseWriter, r *http.Request) { bytes, err := json.MarshalIndent(Blockchain, &quot;&quot;, &quot; &quot;) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } io.WriteString(w, string(bytes)) } 为了简化，我们直接以 JSON 格式返回整个链，你可以在浏览器中访问 localhost:8080 或者 127.0.0.1:8080 来查看（这里的8080就是你在 .env 中定义的端口号 ADDR）。 POST 请求的 handler 稍微有些复杂，我们先来定义一下 POST 请求的 payload： type Message struct { BPM int } 再看看 handler 的实现： func handleWriteBlock(w http.ResponseWriter, r *http.Request) { var m Message decoder := json.NewDecoder(r.Body) if err := decoder.Decode(&amp;m); err != nil { respondWithJSON(w, r, http.StatusBadRequest, r.Body) return } defer r.Body.Close() newBlock, err := generateBlock(Blockchain[len(Blockchain)-1], m.BPM) if err != nil { respondWithJSON(w, r, http.StatusInternalServerError, m) return } if isBlockValid(newBlock, Blockchain[len(Blockchain)-1]) { newBlockchain := append(Blockchain, newBlock) replaceChain(newBlockchain) spew.Dump(Blockchain) } respondWithJSON(w, r, http.StatusCreated, newBlock) } 我们的 POST 请求体中可以使用上面定义的 payload，比如： {&quot;BPM&quot;:75} 还记得前面我们写的 generateBlock 这个函数吗？它接受一个“前一个块”参数，和一个 BPM 值。POST handler 接受请求后就能获得请求体中的 BPM 值，接着借助生成块的函数以及校验块的函数就能生成一个新的块了！ 除此之外，你也可以： 使用spew.Dump 这个函数可以以非常美观和方便阅读的方式将 struct、slice 等数据打印在控制台里，方便我们调试。 测试 POST 请求时，可以使用 POSTMAN 这个 chrome 插件，相比 curl它更直观和方便。 POST 请求处理完之后，无论创建块成功与否，我们需要返回客户端一个响应： func respondWithJSON(w http.ResponseWriter, r *http.Request, code int, payload interface{}) { response, err := json.MarshalIndent(payload, &quot;&quot;, &quot; &quot;) if err != nil { w.WriteHeader(http.StatusInternalServerError) w.Write([]byte(&quot;HTTP 500: Internal Server Error&quot;)) return } w.WriteHeader(code) w.Write(response) } 快要大功告成了。 接下来，我们把这些关于区块链的函数，web 服务的函数“组装”起来： func main() { err := godotenv.Load() if err != nil { log.Fatal(err) } go func() { t := time.Now() genesisBlock := Block{0, t.String(), 0, &quot;&quot;, &quot;&quot;} spew.Dump(genesisBlock) Blockchain = append(Blockchain, genesisBlock) }() log.Fatal(run()) } 这里的 genesisBlock （创世块）是 main 函数中最重要的部分，通过它来初始化区块链，毕竟第一个块的 PrevHash 是空的。 哦耶！完成了 可以从这里获得完整的代码：Github repo 让我们来启动它： ~$ go run main.go 在终端中，我们可以看到 web 服务器启动的日志信息，并且打印出了创世块的信息： 接着我们打开浏览器，访问 localhost:8080 这个地址，我们可以看到页面中展示了当前整个区块链的信息（当然，目前只有一个创世块）： 接着，我们再通过 POSTMAN 来发送一些 POST 请求： 刷新刚才的页面，现在的链中多了一些块，正是我们刚才生成的，同时你们可以看到，块的顺序和散列值都正确。 总结 刚刚我们完成了一个自己的区块链，虽然很简单（陋），但它具备块生成、散列计算、块校验等基本能力。接下来你就可以继续深入的学习 区块链的其他重要知识，比如工作量证明、权益证明这样的共识算法，或者是智能合约、Dapp、侧链等等。 目前这个实现中不包括任何 P2P 网络的内容，我们会在下一篇文章中补充这部分内容，当然，我们鼓励你在这个基础上自己实践一遍！ 原文：180行go代码让你彻底理解区块链是什么 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/05/05/e6ec9baeca5c56cef78178a91c997b4f.html","headline":"区块链技术实现只需180行go代码！","dateModified":"2018-05-05T00:00:00+08:00","datePublished":"2018-05-05T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/05/05/e6ec9baeca5c56cef78178a91c997b4f.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链技术实现只需180行go代码！</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>通过本文，你将可以使用Go创建自己的区块链、理解哈希函数是如何保持区块链的完整性、掌握如何创造并添加新的块、实现多个节点通过竞争生成块、通过浏览器来查看整个链、了解所有其他关于区块链的基础知识。</p> 
  <blockquote> 
   <p>如果你希望马上开始学习以太坊DApp开发，可以访问汇智网提供的出色的在线互动教程：</p> 
   <ul> 
    <li><a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=csdnvat7878" rel="nofollow">以太坊DApp实战开发入门</a></li> 
    <li><a href="http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6?affid=csdnvat7878" rel="nofollow">去中心化电商DApp实战开发</a></li> 
   </ul> 
  </blockquote> 
  <p>但是，文章中将不会涉及工作量证明算法（PoW）以及权益证明算法（PoS）这类的共识算法，同时为了让你更清楚得查看区块链以及块的添加，我们将网络交互的过程简化了，关于 P2P 网络比如“全网广播”这个过程等内容将在后续文章中补上。</p> 
  <h2 id="开发环境">开发环境</h2> 
  <p>我们假设你已经具备一点 Go 语言的开发经验。在安装和配置 Go 开发环境后之后，我们还要获取以下一些依赖：</p> 
  <pre class="prettyprint"><code class=" hljs go">~$ <span class="hljs-keyword">go</span> get github.com/davecgh/<span class="hljs-keyword">go</span>-spew/spew</code></pre> 
  <p><code>spew</code>可以帮助我们在终端中中直接查看 struct 和 slice 这两种数据结构。</p> 
  <pre class="prettyprint"><code class=" hljs cs">~$ go <span class="hljs-keyword">get</span> github.com/gorilla/mux</code></pre> 
  <p>Gorilla 的 <code>mux</code> 包非常流行， 我们用它来写 web handler。</p> 
  <pre class="prettyprint"><code class=" hljs cs">~$ go <span class="hljs-keyword">get</span> github.com/joho/godotenv</code></pre> 
  <p><code>godotenv</code>可以帮助我们读取项目根目录中的<code>.env</code> 配置文件，这样就不用将 http端口之类的配置硬编码进代码中了。比如像这样：</p> 
  <pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">ADDR</span>=<span class="hljs-string">8080</span></code></pre> 
  <p>接下来，我们创建一个 <code>main.go</code> 文件。之后的大部分工作都围绕这个文件，开始写代码吧！</p> 
  <h2 id="导入依赖包">导入依赖包</h2> 
  <p>我们将所有的依赖包以声明的方式导入进去：</p> 
  <pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"crypto/sha256"</span>
    <span class="hljs-string">"encoding/hex"</span>
    <span class="hljs-string">"encoding/json"</span>
    <span class="hljs-string">"io"</span>
    <span class="hljs-string">"log"</span>
    <span class="hljs-string">"net/http"</span>
    <span class="hljs-string">"os"</span>
    <span class="hljs-string">"time"</span>

    <span class="hljs-string">"github.com/davecgh/go-spew/spew"</span>
    <span class="hljs-string">"github.com/gorilla/mux"</span>
    <span class="hljs-string">"github.com/joho/godotenv"</span>
)</code></pre> 
  <h2 id="数据模型">数据模型</h2> 
  <p>接着我们来定义一个结构体，它代表组成区块链的每一个块的数据模型：</p> 
  <pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Block</span> struct <span class="hljs-container">{ <span class="hljs-type">Index</span> <span class="hljs-title">int</span> <span class="hljs-type">Timestamp</span> <span class="hljs-title">string</span> <span class="hljs-type">BPM</span> <span class="hljs-title">int</span> <span class="hljs-type">Hash</span> <span class="hljs-title">string</span> <span class="hljs-type">PrevHash</span> <span class="hljs-title">string</span> }</span></span></code></pre> 
  <ul> 
   <li>Index 是这个块在整个链中的位置</li> 
   <li>Timestamp 显而易见就是块生成时的时间戳</li> 
   <li>Hash 是这个块通过 SHA256 算法生成的散列值</li> 
   <li>PrevHash 代表前一个块的 SHA256 散列值</li> 
   <li>BPM 每分钟心跳数，也就是心率</li> 
  </ul> 
  <p>接着，我们再定义一个结构表示整个链，最简单的表示形式就是一个 Block 的 slice：</p> 
  <pre class="prettyprint"><code class=" hljs oxygene"><span class="hljs-keyword">var</span> Blockchain []<span class="hljs-keyword">Block</span></code></pre> 
  <p>我们使用散列算法（SHA256）来确定和维护链中块和块正确的顺序，确保每一个块的 PrevHash 值等于前一个块中的 Hash 值，这样就以正确的块顺序构建出链：</p> 
  <p><img src="https://static.oschina.net/uploads/img/201805/05223049_4GV2.png" alt="输入图片说明" title="在这里输入图片标题"></p> 
  <h2 id="散列和生成新块">散列和生成新块</h2> 
  <p>我们为什么需要散列？主要是两个原因：</p> 
  <ul> 
   <li>在节省空间的前提下去唯一标识数据。散列是用整个块的数据计算得出，在我们的例子中，将整个块的数据通过 SHA256 计算成一个定长不可伪造的字符串。</li> 
   <li>维持链的完整性。通过存储前一个块的散列值，我们就能够确保每个块在链中的正确顺序。任何对数据的篡改都将改变散列值，同时也就破坏了链。以我们从事的医疗健康领域为例，比如有一个恶意的第三方为了调整“人寿险”的价格，而修改了一个或若干个块中的代表不健康的 BPM 值，那么整个链都变得不可信了。</li> 
  </ul> 
  <p>我们接着写一个函数，用来计算给定的数据的 SHA256 散列值：</p> 
  <pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">func</span> <span class="hljs-tag">calculateHash</span>(<span class="hljs-tag">block</span> <span class="hljs-tag">Block</span>) <span class="hljs-tag">string</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">record </span>:<span class="hljs-value">= <span class="hljs-function">string(block.Index)</span> + block.Timestamp + <span class="hljs-function">string(block.BPM)</span> + block.PrevHash h := sha256.<span class="hljs-function">New()</span> h.<span class="hljs-function">Write([]<span class="hljs-function">byte(record)</span>)</span> hashed := h.<span class="hljs-function">Sum(nil)</span> return hex.<span class="hljs-function">EncodeToString(hashed)</span> </span></span></span>}</code></pre> 
  <p>这个 calculateHash 函数接受一个块，通过块中的 Index，Timestamp，BPM，以及 PrevHash 值来计算出 SHA256 散列值。接下来我们就能编写一个生成块的函数：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">func generateBlock(oldBlock Block, BPM int) (Block, error) {
    var newBlock Block

    t := time<span class="hljs-preprocessor">.Now</span>()
    newBlock<span class="hljs-preprocessor">.Index</span> = oldBlock<span class="hljs-preprocessor">.Index</span> + <span class="hljs-number">1</span>
    newBlock<span class="hljs-preprocessor">.Timestamp</span> = t<span class="hljs-preprocessor">.String</span>()
    newBlock<span class="hljs-preprocessor">.BPM</span> = BPM
    newBlock<span class="hljs-preprocessor">.PrevHash</span> = oldBlock<span class="hljs-preprocessor">.Hash</span>
    newBlock<span class="hljs-preprocessor">.Hash</span> = calculateHash(newBlock)

    return newBlock, nil
}</code></pre> 
  <p>其中，Index 是从给定的前一块的 Index 递增得出，时间戳是直接通过 time.Now() 函数来获得的，Hash 值通过前面的 calculateHash 函数计算得出，PrevHash 则是给定的前一个块的 Hash 值。</p> 
  <h2 id="校验块">校验块</h2> 
  <p>搞定了块的生成，接下来我们需要有函数帮我们判断一个块是否有被篡改。检查 Index 来看这个块是否正确得递增，检查 PrevHash 与前一个块的 Hash 是否一致，再来通过 calculateHash 检查当前块的 Hash 值是否正确。通过这几步我们就能写出一个校验函数：</p> 
  <pre class="prettyprint"><code class=" hljs go"><span class="hljs-keyword">func</span> isBlockValid(newBlock, oldBlock Block) <span class="hljs-typename">bool</span> {
    <span class="hljs-keyword">if</span> oldBlock.Index<span class="hljs-number">+1</span> != newBlock.Index {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">false</span>
    }
    <span class="hljs-keyword">if</span> oldBlock.Hash != newBlock.PrevHash {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">false</span>
    }
    <span class="hljs-keyword">if</span> calculateHash(newBlock) != newBlock.Hash {
        <span class="hljs-keyword">return</span> <span class="hljs-constant">false</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-constant">true</span>
}</code></pre> 
  <p>除了校验块以外，我们还会遇到一个问题：两个节点都生成块并添加到各自的链上，那我们应该以谁为准？这里的细节我们留到下一篇文章， <br> 这里先让我们记住一个原则：始终选择最长的链：</p> 
  <p><img src="https://static.oschina.net/uploads/img/201805/05223109_jqP4.png" alt="输入图片说明" title="在这里输入图片标题"></p> 
  <p>通常来说，更长的链表示它的数据（状态）是更新的，所以我们需要一个函数能帮我们将本地的过期的链切换成最新的链：</p> 
  <pre class="prettyprint"><code class=" hljs go"><span class="hljs-keyword">func</span> replaceChain(newBlocks []Block) {
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(newBlocks) &gt; <span class="hljs-built_in">len</span>(Blockchain) {
        Blockchain = newBlocks
    }
}</code></pre> 
  <p>到这一步，我们基本就把所有重要的函数完成了。接下来，我们需要一个方便直观的方式来查看我们的链，包括数据及状态。通过浏览器查看 web 页面可能是最合适的方式！</p> 
  <h2 id="web-服务">Web 服务</h2> 
  <p>我猜你一定对传统的 web 服务及开发非常熟悉，所以这部分你肯定一看就会。</p> 
  <p>借助 Gorilla/mux 包，我们先写一个函数来初始化我们的 web 服务：</p> 
  <pre class="prettyprint"><code class=" hljs vbscript">func run() <span class="hljs-keyword">error</span> {
    mux := makeMuxRouter()
    httpAddr := os.Getenv(<span class="hljs-string">"ADDR"</span>)
    <span class="hljs-built_in">log</span>.Println(<span class="hljs-string">"Listening on "</span>, os.Getenv(<span class="hljs-string">"ADDR"</span>))
    s := &amp;http.<span class="hljs-built_in">Server</span>{
        Addr:           <span class="hljs-string">":"</span> + httpAddr,
        Handler:        mux,
        ReadTimeout:    <span class="hljs-number">10</span> * <span class="hljs-built_in">time</span>.<span class="hljs-built_in">Second</span>,
        WriteTimeout:   <span class="hljs-number">10</span> * <span class="hljs-built_in">time</span>.<span class="hljs-built_in">Second</span>,
        MaxHeaderBytes: <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>,
    }

    <span class="hljs-keyword">if</span> <span class="hljs-built_in">err</span> := s.ListenAndServe(); <span class="hljs-built_in">err</span> != nil {
        return <span class="hljs-built_in">err</span>
    }

    return nil
}</code></pre> 
  <p>其中的端口号是通过前面提到的 .env 来获得，再添加一些基本的配置参数，这个 web 服务就已经可以 listen and serve 了！</p> 
  <p>接下来我们再来定义不同 endpoint 以及对应的 handler。例如，对“/”的 GET 请求我们可以查看整个链，“/”的 POST 请求可以创建块。</p> 
  <pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">func</span> <span class="hljs-tag">makeMuxRouter</span>() <span class="hljs-tag">http</span><span class="hljs-class">.Handler</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">muxRouter </span>:<span class="hljs-value">= mux.<span class="hljs-function">NewRouter()</span> muxRouter.<span class="hljs-function">HandleFunc(<span class="hljs-string">"/"</span>, handleGetBlockchain)</span>.<span class="hljs-function">Methods(<span class="hljs-string">"GET"</span>)</span> muxRouter.<span class="hljs-function">HandleFunc(<span class="hljs-string">"/"</span>, handleWriteBlock)</span>.<span class="hljs-function">Methods(<span class="hljs-string">"POST"</span>)</span> return muxRouter </span></span></span>}</code></pre> 
  <p>GET 请求的 handler：</p> 
  <pre class="prettyprint"><code class=" hljs livecodeserver">func handleGetBlockchain(w <span class="hljs-keyword">http</span>.ResponseWriter, r *<span class="hljs-keyword">http</span>.Request) {
    <span class="hljs-keyword">bytes</span>, err := json.MarshalIndent(Blockchain, <span class="hljs-string">""</span>, <span class="hljs-string">" "</span>)
    <span class="hljs-keyword">if</span> err != nil {
        <span class="hljs-keyword">http</span>.Error(w, err.Error(), <span class="hljs-keyword">http</span>.StatusInternalServerError)
        <span class="hljs-constant">return</span>
    }
    io.WriteString(w, <span class="hljs-keyword">string</span>(<span class="hljs-keyword">bytes</span>))
}</code></pre> 
  <p>为了简化，我们直接以 JSON 格式返回整个链，你可以在浏览器中访问 localhost:8080 或者 127.0.0.1:8080 来查看（这里的8080就是你在 .env 中定义的端口号 ADDR）。</p> 
  <p>POST 请求的 handler 稍微有些复杂，我们先来定义一下 POST 请求的 payload：</p> 
  <pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Message</span> struct <span class="hljs-container">{ <span class="hljs-type">BPM</span> <span class="hljs-title">int</span> }</span></span></code></pre> 
  <p>再看看 handler 的实现：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">func handleWriteBlock(w http<span class="hljs-preprocessor">.ResponseWriter</span>, r *http<span class="hljs-preprocessor">.Request</span>) {
    var m Message

    decoder := json<span class="hljs-preprocessor">.NewDecoder</span>(r<span class="hljs-preprocessor">.Body</span>)
    if err := decoder<span class="hljs-preprocessor">.Decode</span>(&amp;m)<span class="hljs-comment">; err != nil {</span>
        respondWithJSON(w, r, http<span class="hljs-preprocessor">.StatusBadRequest</span>, r<span class="hljs-preprocessor">.Body</span>)
        return
    }
    defer r<span class="hljs-preprocessor">.Body</span><span class="hljs-preprocessor">.Close</span>()

    newBlock, err := generateBlock(Blockchain[len(Blockchain)-<span class="hljs-number">1</span>], m<span class="hljs-preprocessor">.BPM</span>)
    if err != nil {
        respondWithJSON(w, r, http<span class="hljs-preprocessor">.StatusInternalServerError</span>, m)
        return
    }
    if isBlockValid(newBlock, Blockchain[len(Blockchain)-<span class="hljs-number">1</span>]) {
        newBlockchain := append(Blockchain, newBlock)
        replaceChain(newBlockchain)
        spew<span class="hljs-preprocessor">.Dump</span>(Blockchain)
    }

    respondWithJSON(w, r, http<span class="hljs-preprocessor">.StatusCreated</span>, newBlock)

}</code></pre> 
  <p>我们的 POST 请求体中可以使用上面定义的 payload，比如：</p> 
  <pre class="prettyprint"><code class=" hljs json">{"<span class="hljs-attribute">BPM</span>":<span class="hljs-value"><span class="hljs-number">75</span></span>}</code></pre> 
  <p>还记得前面我们写的 generateBlock 这个函数吗？它接受一个“前一个块”参数，和一个 BPM 值。POST handler 接受请求后就能获得请求体中的 BPM 值，接着借助生成块的函数以及校验块的函数就能生成一个新的块了！</p> 
  <p>除此之外，你也可以：</p> 
  <ul> 
   <li>使用spew.Dump 这个函数可以以非常美观和方便阅读的方式将 struct、slice 等数据打印在控制台里，方便我们调试。</li> 
   <li>测试 POST 请求时，可以使用 POSTMAN 这个 chrome 插件，相比 curl它更直观和方便。</li> 
  </ul> 
  <p>POST 请求处理完之后，无论创建块成功与否，我们需要返回客户端一个响应：</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">func respondWithJSON(w http<span class="hljs-preprocessor">.ResponseWriter</span>, r *http<span class="hljs-preprocessor">.Request</span>, code int, payload interface{}) {
    response, err := json<span class="hljs-preprocessor">.MarshalIndent</span>(payload, <span class="hljs-string">""</span>, <span class="hljs-string">" "</span>)
    if err != nil {
        w<span class="hljs-preprocessor">.WriteHeader</span>(http<span class="hljs-preprocessor">.StatusInternalServerError</span>)
        w<span class="hljs-preprocessor">.Write</span>([]byte(<span class="hljs-string">"HTTP 500: Internal Server Error"</span>))
        return
    }
    w<span class="hljs-preprocessor">.WriteHeader</span>(code)
    w<span class="hljs-preprocessor">.Write</span>(response)
}</code></pre> 
  <p>快要大功告成了。</p> 
  <p>接下来，我们把这些关于区块链的函数，web 服务的函数“组装”起来：</p> 
  <pre class="prettyprint"><code class=" hljs vbscript">func main() {
    <span class="hljs-built_in">err</span> := godotenv.Load()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">err</span> != nil {
        <span class="hljs-built_in">log</span>.Fatal(<span class="hljs-built_in">err</span>)
    }

    go func() {
        t := <span class="hljs-built_in">time</span>.<span class="hljs-built_in">Now</span>()
        genesisBlock := Block{<span class="hljs-number">0</span>, t.<span class="hljs-built_in">String</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>}
        spew.Dump(genesisBlock)
        Blockchain = append(Blockchain, genesisBlock)
    }()
    <span class="hljs-built_in">log</span>.Fatal(run())
}</code></pre> 
  <p>这里的 genesisBlock （创世块）是 main 函数中最重要的部分，通过它来初始化区块链，毕竟第一个块的 PrevHash 是空的。</p> 
  <h2 id="哦耶完成了">哦耶！完成了</h2> 
  <p>可以从这里获得完整的代码：<a href="https://github.com/mycoralhealth/blockchain-tutorial/blob/master/main.go" rel="nofollow">Github repo</a></p> 
  <p>让我们来启动它：</p> 
  <pre class="prettyprint"><code class=" hljs go">~$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span></code></pre> 
  <p>在终端中，我们可以看到 web 服务器启动的日志信息，并且打印出了创世块的信息：</p> 
  <p><img src="https://static.oschina.net/uploads/img/201805/05223126_AHQ4.png" alt="输入图片说明" title="在这里输入图片标题"></p> 
  <p>接着我们打开浏览器，访问 localhost:8080 这个地址，我们可以看到页面中展示了当前整个区块链的信息（当然，目前只有一个创世块）：</p> 
  <p><img src="https://static.oschina.net/uploads/img/201805/05223136_hu97.png" alt="输入图片说明" title="在这里输入图片标题"></p> 
  <p>接着，我们再通过 POSTMAN 来发送一些 POST 请求：</p> 
  <p><img src="https://static.oschina.net/uploads/img/201805/05223149_wc0Z.png" alt="输入图片说明" title="在这里输入图片标题"> <br> 刷新刚才的页面，现在的链中多了一些块，正是我们刚才生成的，同时你们可以看到，块的顺序和散列值都正确。</p> 
  <p><img src="https://static.oschina.net/uploads/img/201805/05223159_EIcb.png" alt="输入图片说明" title="在这里输入图片标题"></p> 
  <h2 id="总结">总结</h2> 
  <p>刚刚我们完成了一个自己的区块链，虽然很简单（陋），但它具备块生成、散列计算、块校验等基本能力。接下来你就可以继续深入的学习 <br> 区块链的其他重要知识，比如工作量证明、权益证明这样的共识算法，或者是智能合约、Dapp、侧链等等。</p> 
  <p>目前这个实现中不包括任何 P2P 网络的内容，我们会在下一篇文章中补充这部分内容，当然，我们鼓励你在这个基础上自己实践一遍！</p> 
  <p>原文：<a href="http://blog.hubwiz.com/2018/02/03/blockchain-diy-go/" rel="nofollow">180行go代码让你彻底理解区块链是什么</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/shebao3333/article/details/80210386,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/shebao3333/article/details/80210386,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
