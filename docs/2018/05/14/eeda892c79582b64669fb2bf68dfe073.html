<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊源码分析(53）以太坊测试网络Clique_PoA介绍 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊源码分析(53）以太坊测试网络Clique_PoA介绍" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="https://github.com/ethereum/EIPs/issues/225 Clique的模式下，用户是无法获取以太币的，因为无法挖矿，所以如果需要以太币， 需要通过特殊的途径来获取。 可以通过这个网站获取ether https://faucet.rinkeby.io/ 需要有google+账号，facebook或者twitter账号才能获取， 详细的获取办法参考上面的网站。 Clique 是以太坊的一个Power of authority 的实现， 现在主要在Rinkeby 测试网络使用。 ## 背景 以太坊的第一个官方测试网是Morden。它从2015年7月到2016年11月，由于Geth和Parity之间累积的垃圾和一些testnet的共识问题，最终决定停止重新启动testnet。 Ropsten就这样诞生了，清理掉了所有的垃圾，从一个干净的石板开始。这一运行状况一直持续到2017年2月底，当时恶意行为者决定滥用Pow，并逐步将GasLimit从正常的470万提高到90亿，此时发送巨大的交易损害整个网络。甚至在此之前，攻击者尝试了多次非常长的区块链重组，导致不同客户端之间的网络分裂，甚至是不同的版本。 这些攻击的根本原因在于PoW网络的安全性与它背后的计算能力一样安全。从零开始重新启动一个新的测试网络并不能解决任何问题，因为攻击者可以反复安装相同的攻击。Parity 团队决定采取一个紧急的解决办法，回滚大量的区块，制定一个不允许GasLimit超过一定门槛的软交叉。 虽然这个解决方案可能在短期内工作： 这并不高雅：以太坊应该有动态的限制 这不是可移植的：其他客户需要自己实现新的fork逻辑 它与同步模式不兼容：fast sync和轻客户端都运气不佳 这只是延长了攻击的时间：垃圾依然可以在无尽的情况下稳步推进 Parity的解决方案虽然不完美，但仍然可行。我想提出一个更长期的替代解决方案，涉及更多，但应该足够简单，以便能够在合理的时间内推出。 ## 标准化的PoA 如上所述，在没有价值的网络中，Pow不能安全地工作。 以太坊有以Casper为基础的长期PoS目标，但是这是一个繁琐的研究，所以我们不能很快依靠这个来解决今天的问题。 然而，一种解决方案很容易实施，而且足够有效地正确地修复测试网络，即权威证明方案（proof-of-authority scheme）。 注意，Parity确实有PoA的实现，虽然看起来比需要的更复杂，没有太多的协议文档，但是很难看到它可以和其他客户一起玩。 我欢迎他们基于他们的经验来给我的这个提案更多的反馈。 这里描述的PoA协议的主要设计目标是实现和嵌入任何现有的以太坊客户端应该是非常简单的，同时允许使用现有的同步技术（快速，轻松，扭曲），而不需要客户端开发者添加 定制逻辑到关键软件。 ## PoA101 对于那些没有意识到PoA如何运作的人来说，这是一个非常简单的协议，而不是矿工们为了解决一个困难的问题而竞相争夺，授权签署者可以随时自行决定是否创建新的块。 挑战围绕着如何控制挖矿频率，如何在不同的签名者之间分配负载（和机会）以及如何动态调整签名者列表。 下一节定义一个处理所有这些场景的建议协议。 ## Rinkeby proof-of-authority 总体来说，有两种同步区块链的方法： - 传统的方法是把所有的事务一个接一个地进行起始块和紧缩。这种方式尝试过而且已经被证明在以太坊这种复杂的网络中非常耗费计算资源。 另一种是只下载区块链头并验证它们的有效性，此后可以从网络上下载一个任意的最近的状态并检查最近的header。 - PoA方案基于这样的想法，即块可能只能由可信签署人完成。 因此，客户端看到的每个块（或header）都可以与可信任的签名者列表进行匹配。 这里面临的挑战是如何维护一个可以及时更改的授权签名者列表？ 明显的答案（将其存储在以太坊合同中）也是错误的答案：在快速同步期间是无法访问状态的。 **维护授权签名者列表的协议必须完全包含在块头中。** 下一个显而易见的想法是改变块标题的结构，这样就可以放弃PoW的概念，并引入新的字段来迎合投票机制。 这也是错误的答案：在多个实现中更改这样一个核心数据结构将是一个开发，维护和安全的噩梦。 **维护授权签名者列表的协议必须完全适合当前的数据模型。** 所以，根据以上所述，我们不能使用EVM进行投票，而是不得不求助于区块头。 而且我们不能改变区块头字段，而不得不求助于当前可用的字段。 没有太多的选择。 ### 把区块头的一些其他字段用来实现投票和签名 当前仅用作有趣元数据的最明显的字段是块头中的32字节的ExtraData部分。 矿工们通常把他们的客户端和版本放在那里，但是有些人用另外的“信息”填充它们。 该协议将扩展此字段以增加65字节用来存放矿工的KEC签名。 这将允许任何获得一个区块的人员根据授权签名者的名单对其进行验证。 同时它也使得区块头中的矿工地址的字段作废。 请注意，更改区块头的长度是非侵入性操作，因为所有代码（例如RLP编码，哈希）都不可知，所以客户端不需要定制逻辑。 以上就足以验证一个链，但我们如何更新一个动态的签名者列表。 答案是，我们可以重新使用新近过时的矿工字段beneficiary和PoA废弃的nonce字段来创建投票协议： - 在常规块中，这两个字段都将被设置为零。 - 如果签名者希望对授权签名人列表进行更改，则会： &nbsp;&nbsp;&nbsp;&nbsp; - 将矿工字段 **beneficiary**设置为希望投票的签署者 &nbsp;&nbsp;&nbsp;&nbsp; - 将 **nonce**设置为0或0xff ... f来投票赞成添加或踢出 任何同步链的客户端都可以在数据块处理过程中“统计”选票，并通过普通投票保持授权签名者的动态变化列表。 初始的一组签名者通过创世区块的参数提供（以避免在起始状态中部署“最初选民名单”合同的复杂性）。 为了避免有一个无限的窗口来统计票数，并且允许定期清除陈旧的提议，我们可以重新使用ethash的概念 epoch，每个epoch 转换都会刷新所有未决的投票。 此外，这些epoch 转换还可以作为包含头部额外数据内的当前授权签名者列表的无状态检查点。 这允许客户端仅基于检查点散列进行同步，而不必重播在链上进行的所有投票。 它同样允许用包含了初始签名者的创世区块来完全定义区块链 ### 攻击媒介：恶意签名者 可能发生恶意用户被添加到签名者列表中，或者签名者密钥/机器受到威胁。 在这种情况下，协议需要能够抵御重组和垃圾邮件。 所提出的解决方案是，给定N个授权签名者的列表，任何签名者可能只在每个K中填充1个块。这确保损害是有限的，其余的矿工可以投出恶意用户。 ## 攻击媒介：审查签名者 另一个有趣的攻击媒介是如果一个签名者（或者一组签名者）试图检查出从授权列表中删除它们的块。 为了解决这个问题，我们限制了签名者允许的最小频率为N / 2。 这确保了恶意签名者需要控制至少51％的签名帐户，在这种情况下，游戏就是无论如何也无法进行下去了。 ## 攻击媒介：垃圾邮件签名者 最后的小型攻击媒介就是恶意签署者在每一个块内注入新的投票建议。 由于节点需要统计所有投票来创建授权签名者的实际列表，所以他们需要通过时间跟踪所有投票。 没有限制投票窗口，这可能会慢慢增长，但却是无限的。 解决方法是放置一个W块的移动窗口，之后投票被认为是陈旧的。 一个理智的窗户可能是1-2个时代。 我们将这称为一个时代。 ## 攻击媒介：并发块 如果授权签名者的数量是N，并且我们允许每个签名者在K中填充1个块，那么在任何时间N-K个矿工都被允许为Mint。 为了避免这些争夺块，每个签名者将添加一个小的随机“抵消”，以释放一个新的块。 这确保了小叉子是罕见的，但偶尔还会发生（如在主网上）。 如果一个签名者被滥用权威而引起混乱，那么这个签名就可以被投票出去。 ## 注意 ### 这是否表明建议我们使用一个被审查testnet？ 该提议表明，考虑到某些行为者的恶意性质，并且鉴于“垄断资金”网络中PoW计划的弱点，最好是建立一个网络，使其具有一定的垃圾过滤功能，开发人员可以依靠它来测试其程序。 为什么规范PoA？ 不同的客户在不同的情况下会更好。 Go可能在服务器端环境中很棒，但CPP可能更适合在RPI Zero上运行。 手动投票是不是很麻烦？ 这是一个实现细节，但是签名者可以利用基于合同的投票策略，利用EVM的全部功能，只将结果推送到平均节点的头部进行验证。 ## 澄清和反馈 - 这个建议并不排除客户端运行基于PoW的测试网络，无论是Ropsten还是基于它的新的测试网络。理想的情况是客户提供一种连接PoW以及基于PoA的测试网络的方法（＃225（评论））。 - 协议参数尽管可以在客户端实施者的破坏中进行配置，但Rinkeby网络应该尽可能地靠近主网络。这包括动态GasLimit，15秒左右的可变区块时间，GasPrice等（＃225（评论））。 - 该方案要求至少有K个签名者随时上网，因为这是确保“最小化”多样性所需的最少人数。这意味着如果超过K，则网络停止。这应该通过确保签名者是高运行时间的机器来解决，并且在发生太多故障之前及时地将失败的机器投票出去（＃225（评论））。 - 该提案并没有解决“合法的”垃圾邮件问题，就像在攻击者有效地使用testnet以创建垃圾一样，但是如果没有PoW挖掘，攻击者可能无法获得无限的ether来攻击。一种可能性是以有限的方式（例如每天10次）（＃225（评论）），以GitHub（或其他任何方式）帐户为基础提供一个获取ether的途径。 - 有人建议为当时包含授权签名者列表的每个epoch创建checkpoint block。这将允许稍后的轻客户说“从这里同步”，而不需要从起源开始。这可以在签名之前作为前缀添加到extradata字段（＃225（comment））。 ## Clique PoA 一致性协议 (Clique proof-of-authority consensus protocol ) 我们定义下面的常量： - EPOCH_LENGTH：检查点并重置未决投票的块数。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议30000，以便和主网络的ethhash epoch类似 - BLOCK_PERIOD：两个连续块的时间戳之间的最小差异。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议15，以便和主网络的ethhash epoch类似 - EXTRA_VANITY：固定数量的ExtraData前缀字节为签名者vanity保留。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议的32个字节以便和当前的ExtraData的长度相同。 - EXTRA_SEAL：为签名者印章保留的固定数量的额外数据后缀字节。 &nbsp;&nbsp;&nbsp;&nbsp; - 保存签名的65个字节，基于标准secp256k1曲线。 - NONCE_AUTH：魔术随机数字0xffffffffffffffff投票添加一个新的签名者。 - NONCE_DROP：魔术随机数字0x0000000000000000对移除签名者进行投票。 - UNCLE_HASH：始终Keccak256（RLP（[]））作为Uncles在PoW之外没有任何意义。 - DIFF_NOTURN：如果当前没有轮到你签名，那么你签名的区块的难度就是这个难度。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议1，因为它只需要是一个任意的基线常数。 - DIFF_INTURN：如果当前轮到你签名，那么你签名的难度。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议2， 这样就比没有轮到的签名者难度要高。 我们还定义了以下每块的常量： - BLOCK_NUMBER：链中的块高度，创世区块的高度是0。 - SIGNER_COUNT：在区块链中中特定实例上有效的授权签名者的数量。 - SIGNER_INDEX：当前授权签名者的排序列表中的索引。 - SIGNER_LIMIT：每隔这么多块，签名者只能签署一块。 &nbsp;&nbsp;&nbsp;&nbsp; - 必须有floor(SIGNER_COUNT / 2）+1 这么多签名者同意才能达成某项决议。 我们重新调整区块头字段的用途，如下所示： - beneficiary：建议修改授权签名人名单的地址。 &nbsp;&nbsp;&nbsp;&nbsp; - 应该正常填写零，只有投票时修改。 &nbsp;&nbsp;&nbsp;&nbsp; - 尽管如此，仍然允许任意值（甚至是无意义的值，例如投出非签名者），以避免增加围绕投票机制的额外复杂性。 &nbsp;&nbsp;&nbsp;&nbsp; - 必须在检查点（即epoch转换）块填充零。 - nonce：Signer关于受益人字段中定义的账户的建议。 &nbsp;&nbsp;&nbsp;&nbsp; - NONCE_DROP 提议取消授权受益人作为现有签名者。 &nbsp;&nbsp;&nbsp;&nbsp; - NONCE_AUTH 提出授权受益人作为新的签名者。 &nbsp;&nbsp;&nbsp;&nbsp; - 必须在检查点块填充零。 &nbsp;&nbsp;&nbsp;&nbsp; - 除了上述两者（现在）之外，不得采用任何其他值。 - extraData： vanity, checkpointing and signer signatures的组合字段。 &nbsp;&nbsp;&nbsp;&nbsp; - 第一个EXTRA_VANITY字节（固定长度）可以包含任意签名者vanity data。 &nbsp;&nbsp;&nbsp;&nbsp; - 最后一个EXTRA_SEAL字节（固定长度）是密封标题的签名者签名。 &nbsp;&nbsp;&nbsp;&nbsp; - 检查点块必须包含一个签名者列表（N * 20字节），否则省略。 &nbsp;&nbsp;&nbsp;&nbsp; - 检查点块附加数据部分中的签署者列表必须按升序排序。 - mixHash：为了分叉保留。类似于Dao的额外数据 &nbsp;&nbsp;&nbsp;&nbsp; - 在正常操作期间必须填入零。 - ommersHash：必须是UNCLE_HASH，因为在PoW之外，Uncles叔没有任何意义。 - timestamp：必须至少为父区块的时间戳 + BLOCK_PERIOD。 - difficulty：包含块的独立得分 来推导链的质量。 &nbsp;&nbsp;&nbsp;&nbsp; - 如果BLOCK_NUMBER％SIGNER_COUNT！= SIGNER_INDEX，则必须为DIFF_NOTURN &nbsp;&nbsp;&nbsp;&nbsp; - 如果BLOCK_NUMBER％SIGNER_COUNT == SIGNER_INDEX，则必须为DIFF_INTURN ### Authorizing a block 为了给网络授权一个块，签名者需要签署包含除签名本身以外的所有内容。 这意味着哈希包含区块头的每个字段（包括nonce和mixDigest），还有除了65字节签名后缀外的extraData。 这些字段按照其在黄皮书中定义的顺序进行hash。 该散列使用标准的secp256k1曲线进行签名，得到的65字节签名（R，S，V，其中V为0或1）作为尾随的65字节后缀嵌入到extraData中。 为了确保恶意签名者（签名密钥丢失）不能在网络上受到破坏，每位签名者都可以在SIGNER_LIMIT连续块中签最多一个。 顺序不是固定的，不过（DIFF_INTURN）的签名者签出的区块难度要比（DIFF_NOTURN）高 #### 授权策略 只要签名者符合上述规范，他们可以授权和分配他们认为合适的块， 下面的建议策略会减少网络流量和分叉，所以这是一个建议的功能： - 如果签署者被允许签署一个区块（在授权清单上并且最近没有签署）。 &nbsp;&nbsp;&nbsp;&nbsp; - 计算下一个块的最佳签名时间（父+ BLOCK_PERIOD）。 &nbsp;&nbsp;&nbsp;&nbsp; - 如果轮到了，等待准确的时间到达，立即签字和播放。 &nbsp;&nbsp;&nbsp;&nbsp; - 如果没有轮到，则延迟 rand（SIGNER_COUNT * 500ms）这么久的时间签名。 这个小小的策略将确保当前轮到的签名者（谁的块更重）对签名和传播与外转签名者有稍微的优势。 此外，该方案允许随着签名者数目的增加而具有一定规模。 ### 投票签署者 每个epoch转换（包括创世区块）作为一个无状态的检查点，有能力的客户端应该能够同步而不需要任何以前的状态。 这意味着新epoch header不得包含投票，所有未落实的投票都将被丢弃，并从头开始计数。 对于所有非epoch 转换块： - 签名者可以使用自己签署的区块投一票，以提出对授权列表的更改。 - 对每一个提案只保留最新的一个投票。 - 随着链条的进展，投票也会生效（允许同时提交提案）。 - 达成多数人意见的提案SIGNER_LIMIT立即生效。 - 对于客户端实现的简单性，无效的提议不会受到惩罚。 **生效的提案意味着放弃对该提案的所有未决投票（无论是赞成还是反对），并从一个清晰的名单开始。** ### 级联投票 签名者取消授权期间可能会出现复杂的案例。如果先前授权的签署者被撤销，则批准提案所需的签名者数量可能会减少一个。这可能会导致一个或多个未决的提案达成共识，执行这些提案可能会进一步影响新的提案。 当多个相冲突的提议同时通过时（例如，添加新的签名者vs删除现有的提案者），处理这种情况并不明显，评估顺序可能会彻底改变最终授权列表的结果。由于签名者可能会在他们自己的每一个区块中反转他们自己的投票，所以哪一个提案将是“第一”并不那么明显。 为了避免级联执行所带来的缺陷，解决的办法是明确禁止级联效应。换句话说：只有当前标题/投票的受益人可以被添加到授权列表或从授权列表中删除。如果这导致其他建议达成共识，那么当他们各自的受益者再次“触发”时，这些建议将被执行（因为大多数人的共识仍然在这一点上）。 ### 投票策略 由于区块链可以有很小的reorgs，所以“cast-and-forget”的天真投票机制可能不是最优的，因为包含singleton投票的区块可能不会在最终的链中结束。 一个简单但工作的策略是允许用户在签名者上配置“提案”（例如“add 0x ...”，“drop 0x ...”）。 签署的代码，然后可以选择一个随机的建议，每块它签署和注入。 这确保了多个并发提案以及reorgs最终在链上被注意到。 这个列表可能在一定数量的块/epoch后过期，但重要的是要认识到“看”一个提案通过并不意味着它不会被重新组合，所以当提案通过时不应该立即放弃。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多" />
<meta property="og:description" content="https://github.com/ethereum/EIPs/issues/225 Clique的模式下，用户是无法获取以太币的，因为无法挖矿，所以如果需要以太币， 需要通过特殊的途径来获取。 可以通过这个网站获取ether https://faucet.rinkeby.io/ 需要有google+账号，facebook或者twitter账号才能获取， 详细的获取办法参考上面的网站。 Clique 是以太坊的一个Power of authority 的实现， 现在主要在Rinkeby 测试网络使用。 ## 背景 以太坊的第一个官方测试网是Morden。它从2015年7月到2016年11月，由于Geth和Parity之间累积的垃圾和一些testnet的共识问题，最终决定停止重新启动testnet。 Ropsten就这样诞生了，清理掉了所有的垃圾，从一个干净的石板开始。这一运行状况一直持续到2017年2月底，当时恶意行为者决定滥用Pow，并逐步将GasLimit从正常的470万提高到90亿，此时发送巨大的交易损害整个网络。甚至在此之前，攻击者尝试了多次非常长的区块链重组，导致不同客户端之间的网络分裂，甚至是不同的版本。 这些攻击的根本原因在于PoW网络的安全性与它背后的计算能力一样安全。从零开始重新启动一个新的测试网络并不能解决任何问题，因为攻击者可以反复安装相同的攻击。Parity 团队决定采取一个紧急的解决办法，回滚大量的区块，制定一个不允许GasLimit超过一定门槛的软交叉。 虽然这个解决方案可能在短期内工作： 这并不高雅：以太坊应该有动态的限制 这不是可移植的：其他客户需要自己实现新的fork逻辑 它与同步模式不兼容：fast sync和轻客户端都运气不佳 这只是延长了攻击的时间：垃圾依然可以在无尽的情况下稳步推进 Parity的解决方案虽然不完美，但仍然可行。我想提出一个更长期的替代解决方案，涉及更多，但应该足够简单，以便能够在合理的时间内推出。 ## 标准化的PoA 如上所述，在没有价值的网络中，Pow不能安全地工作。 以太坊有以Casper为基础的长期PoS目标，但是这是一个繁琐的研究，所以我们不能很快依靠这个来解决今天的问题。 然而，一种解决方案很容易实施，而且足够有效地正确地修复测试网络，即权威证明方案（proof-of-authority scheme）。 注意，Parity确实有PoA的实现，虽然看起来比需要的更复杂，没有太多的协议文档，但是很难看到它可以和其他客户一起玩。 我欢迎他们基于他们的经验来给我的这个提案更多的反馈。 这里描述的PoA协议的主要设计目标是实现和嵌入任何现有的以太坊客户端应该是非常简单的，同时允许使用现有的同步技术（快速，轻松，扭曲），而不需要客户端开发者添加 定制逻辑到关键软件。 ## PoA101 对于那些没有意识到PoA如何运作的人来说，这是一个非常简单的协议，而不是矿工们为了解决一个困难的问题而竞相争夺，授权签署者可以随时自行决定是否创建新的块。 挑战围绕着如何控制挖矿频率，如何在不同的签名者之间分配负载（和机会）以及如何动态调整签名者列表。 下一节定义一个处理所有这些场景的建议协议。 ## Rinkeby proof-of-authority 总体来说，有两种同步区块链的方法： - 传统的方法是把所有的事务一个接一个地进行起始块和紧缩。这种方式尝试过而且已经被证明在以太坊这种复杂的网络中非常耗费计算资源。 另一种是只下载区块链头并验证它们的有效性，此后可以从网络上下载一个任意的最近的状态并检查最近的header。 - PoA方案基于这样的想法，即块可能只能由可信签署人完成。 因此，客户端看到的每个块（或header）都可以与可信任的签名者列表进行匹配。 这里面临的挑战是如何维护一个可以及时更改的授权签名者列表？ 明显的答案（将其存储在以太坊合同中）也是错误的答案：在快速同步期间是无法访问状态的。 **维护授权签名者列表的协议必须完全包含在块头中。** 下一个显而易见的想法是改变块标题的结构，这样就可以放弃PoW的概念，并引入新的字段来迎合投票机制。 这也是错误的答案：在多个实现中更改这样一个核心数据结构将是一个开发，维护和安全的噩梦。 **维护授权签名者列表的协议必须完全适合当前的数据模型。** 所以，根据以上所述，我们不能使用EVM进行投票，而是不得不求助于区块头。 而且我们不能改变区块头字段，而不得不求助于当前可用的字段。 没有太多的选择。 ### 把区块头的一些其他字段用来实现投票和签名 当前仅用作有趣元数据的最明显的字段是块头中的32字节的ExtraData部分。 矿工们通常把他们的客户端和版本放在那里，但是有些人用另外的“信息”填充它们。 该协议将扩展此字段以增加65字节用来存放矿工的KEC签名。 这将允许任何获得一个区块的人员根据授权签名者的名单对其进行验证。 同时它也使得区块头中的矿工地址的字段作废。 请注意，更改区块头的长度是非侵入性操作，因为所有代码（例如RLP编码，哈希）都不可知，所以客户端不需要定制逻辑。 以上就足以验证一个链，但我们如何更新一个动态的签名者列表。 答案是，我们可以重新使用新近过时的矿工字段beneficiary和PoA废弃的nonce字段来创建投票协议： - 在常规块中，这两个字段都将被设置为零。 - 如果签名者希望对授权签名人列表进行更改，则会： &nbsp;&nbsp;&nbsp;&nbsp; - 将矿工字段 **beneficiary**设置为希望投票的签署者 &nbsp;&nbsp;&nbsp;&nbsp; - 将 **nonce**设置为0或0xff ... f来投票赞成添加或踢出 任何同步链的客户端都可以在数据块处理过程中“统计”选票，并通过普通投票保持授权签名者的动态变化列表。 初始的一组签名者通过创世区块的参数提供（以避免在起始状态中部署“最初选民名单”合同的复杂性）。 为了避免有一个无限的窗口来统计票数，并且允许定期清除陈旧的提议，我们可以重新使用ethash的概念 epoch，每个epoch 转换都会刷新所有未决的投票。 此外，这些epoch 转换还可以作为包含头部额外数据内的当前授权签名者列表的无状态检查点。 这允许客户端仅基于检查点散列进行同步，而不必重播在链上进行的所有投票。 它同样允许用包含了初始签名者的创世区块来完全定义区块链 ### 攻击媒介：恶意签名者 可能发生恶意用户被添加到签名者列表中，或者签名者密钥/机器受到威胁。 在这种情况下，协议需要能够抵御重组和垃圾邮件。 所提出的解决方案是，给定N个授权签名者的列表，任何签名者可能只在每个K中填充1个块。这确保损害是有限的，其余的矿工可以投出恶意用户。 ## 攻击媒介：审查签名者 另一个有趣的攻击媒介是如果一个签名者（或者一组签名者）试图检查出从授权列表中删除它们的块。 为了解决这个问题，我们限制了签名者允许的最小频率为N / 2。 这确保了恶意签名者需要控制至少51％的签名帐户，在这种情况下，游戏就是无论如何也无法进行下去了。 ## 攻击媒介：垃圾邮件签名者 最后的小型攻击媒介就是恶意签署者在每一个块内注入新的投票建议。 由于节点需要统计所有投票来创建授权签名者的实际列表，所以他们需要通过时间跟踪所有投票。 没有限制投票窗口，这可能会慢慢增长，但却是无限的。 解决方法是放置一个W块的移动窗口，之后投票被认为是陈旧的。 一个理智的窗户可能是1-2个时代。 我们将这称为一个时代。 ## 攻击媒介：并发块 如果授权签名者的数量是N，并且我们允许每个签名者在K中填充1个块，那么在任何时间N-K个矿工都被允许为Mint。 为了避免这些争夺块，每个签名者将添加一个小的随机“抵消”，以释放一个新的块。 这确保了小叉子是罕见的，但偶尔还会发生（如在主网上）。 如果一个签名者被滥用权威而引起混乱，那么这个签名就可以被投票出去。 ## 注意 ### 这是否表明建议我们使用一个被审查testnet？ 该提议表明，考虑到某些行为者的恶意性质，并且鉴于“垄断资金”网络中PoW计划的弱点，最好是建立一个网络，使其具有一定的垃圾过滤功能，开发人员可以依靠它来测试其程序。 为什么规范PoA？ 不同的客户在不同的情况下会更好。 Go可能在服务器端环境中很棒，但CPP可能更适合在RPI Zero上运行。 手动投票是不是很麻烦？ 这是一个实现细节，但是签名者可以利用基于合同的投票策略，利用EVM的全部功能，只将结果推送到平均节点的头部进行验证。 ## 澄清和反馈 - 这个建议并不排除客户端运行基于PoW的测试网络，无论是Ropsten还是基于它的新的测试网络。理想的情况是客户提供一种连接PoW以及基于PoA的测试网络的方法（＃225（评论））。 - 协议参数尽管可以在客户端实施者的破坏中进行配置，但Rinkeby网络应该尽可能地靠近主网络。这包括动态GasLimit，15秒左右的可变区块时间，GasPrice等（＃225（评论））。 - 该方案要求至少有K个签名者随时上网，因为这是确保“最小化”多样性所需的最少人数。这意味着如果超过K，则网络停止。这应该通过确保签名者是高运行时间的机器来解决，并且在发生太多故障之前及时地将失败的机器投票出去（＃225（评论））。 - 该提案并没有解决“合法的”垃圾邮件问题，就像在攻击者有效地使用testnet以创建垃圾一样，但是如果没有PoW挖掘，攻击者可能无法获得无限的ether来攻击。一种可能性是以有限的方式（例如每天10次）（＃225（评论）），以GitHub（或其他任何方式）帐户为基础提供一个获取ether的途径。 - 有人建议为当时包含授权签名者列表的每个epoch创建checkpoint block。这将允许稍后的轻客户说“从这里同步”，而不需要从起源开始。这可以在签名之前作为前缀添加到extradata字段（＃225（comment））。 ## Clique PoA 一致性协议 (Clique proof-of-authority consensus protocol ) 我们定义下面的常量： - EPOCH_LENGTH：检查点并重置未决投票的块数。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议30000，以便和主网络的ethhash epoch类似 - BLOCK_PERIOD：两个连续块的时间戳之间的最小差异。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议15，以便和主网络的ethhash epoch类似 - EXTRA_VANITY：固定数量的ExtraData前缀字节为签名者vanity保留。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议的32个字节以便和当前的ExtraData的长度相同。 - EXTRA_SEAL：为签名者印章保留的固定数量的额外数据后缀字节。 &nbsp;&nbsp;&nbsp;&nbsp; - 保存签名的65个字节，基于标准secp256k1曲线。 - NONCE_AUTH：魔术随机数字0xffffffffffffffff投票添加一个新的签名者。 - NONCE_DROP：魔术随机数字0x0000000000000000对移除签名者进行投票。 - UNCLE_HASH：始终Keccak256（RLP（[]））作为Uncles在PoW之外没有任何意义。 - DIFF_NOTURN：如果当前没有轮到你签名，那么你签名的区块的难度就是这个难度。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议1，因为它只需要是一个任意的基线常数。 - DIFF_INTURN：如果当前轮到你签名，那么你签名的难度。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议2， 这样就比没有轮到的签名者难度要高。 我们还定义了以下每块的常量： - BLOCK_NUMBER：链中的块高度，创世区块的高度是0。 - SIGNER_COUNT：在区块链中中特定实例上有效的授权签名者的数量。 - SIGNER_INDEX：当前授权签名者的排序列表中的索引。 - SIGNER_LIMIT：每隔这么多块，签名者只能签署一块。 &nbsp;&nbsp;&nbsp;&nbsp; - 必须有floor(SIGNER_COUNT / 2）+1 这么多签名者同意才能达成某项决议。 我们重新调整区块头字段的用途，如下所示： - beneficiary：建议修改授权签名人名单的地址。 &nbsp;&nbsp;&nbsp;&nbsp; - 应该正常填写零，只有投票时修改。 &nbsp;&nbsp;&nbsp;&nbsp; - 尽管如此，仍然允许任意值（甚至是无意义的值，例如投出非签名者），以避免增加围绕投票机制的额外复杂性。 &nbsp;&nbsp;&nbsp;&nbsp; - 必须在检查点（即epoch转换）块填充零。 - nonce：Signer关于受益人字段中定义的账户的建议。 &nbsp;&nbsp;&nbsp;&nbsp; - NONCE_DROP 提议取消授权受益人作为现有签名者。 &nbsp;&nbsp;&nbsp;&nbsp; - NONCE_AUTH 提出授权受益人作为新的签名者。 &nbsp;&nbsp;&nbsp;&nbsp; - 必须在检查点块填充零。 &nbsp;&nbsp;&nbsp;&nbsp; - 除了上述两者（现在）之外，不得采用任何其他值。 - extraData： vanity, checkpointing and signer signatures的组合字段。 &nbsp;&nbsp;&nbsp;&nbsp; - 第一个EXTRA_VANITY字节（固定长度）可以包含任意签名者vanity data。 &nbsp;&nbsp;&nbsp;&nbsp; - 最后一个EXTRA_SEAL字节（固定长度）是密封标题的签名者签名。 &nbsp;&nbsp;&nbsp;&nbsp; - 检查点块必须包含一个签名者列表（N * 20字节），否则省略。 &nbsp;&nbsp;&nbsp;&nbsp; - 检查点块附加数据部分中的签署者列表必须按升序排序。 - mixHash：为了分叉保留。类似于Dao的额外数据 &nbsp;&nbsp;&nbsp;&nbsp; - 在正常操作期间必须填入零。 - ommersHash：必须是UNCLE_HASH，因为在PoW之外，Uncles叔没有任何意义。 - timestamp：必须至少为父区块的时间戳 + BLOCK_PERIOD。 - difficulty：包含块的独立得分 来推导链的质量。 &nbsp;&nbsp;&nbsp;&nbsp; - 如果BLOCK_NUMBER％SIGNER_COUNT！= SIGNER_INDEX，则必须为DIFF_NOTURN &nbsp;&nbsp;&nbsp;&nbsp; - 如果BLOCK_NUMBER％SIGNER_COUNT == SIGNER_INDEX，则必须为DIFF_INTURN ### Authorizing a block 为了给网络授权一个块，签名者需要签署包含除签名本身以外的所有内容。 这意味着哈希包含区块头的每个字段（包括nonce和mixDigest），还有除了65字节签名后缀外的extraData。 这些字段按照其在黄皮书中定义的顺序进行hash。 该散列使用标准的secp256k1曲线进行签名，得到的65字节签名（R，S，V，其中V为0或1）作为尾随的65字节后缀嵌入到extraData中。 为了确保恶意签名者（签名密钥丢失）不能在网络上受到破坏，每位签名者都可以在SIGNER_LIMIT连续块中签最多一个。 顺序不是固定的，不过（DIFF_INTURN）的签名者签出的区块难度要比（DIFF_NOTURN）高 #### 授权策略 只要签名者符合上述规范，他们可以授权和分配他们认为合适的块， 下面的建议策略会减少网络流量和分叉，所以这是一个建议的功能： - 如果签署者被允许签署一个区块（在授权清单上并且最近没有签署）。 &nbsp;&nbsp;&nbsp;&nbsp; - 计算下一个块的最佳签名时间（父+ BLOCK_PERIOD）。 &nbsp;&nbsp;&nbsp;&nbsp; - 如果轮到了，等待准确的时间到达，立即签字和播放。 &nbsp;&nbsp;&nbsp;&nbsp; - 如果没有轮到，则延迟 rand（SIGNER_COUNT * 500ms）这么久的时间签名。 这个小小的策略将确保当前轮到的签名者（谁的块更重）对签名和传播与外转签名者有稍微的优势。 此外，该方案允许随着签名者数目的增加而具有一定规模。 ### 投票签署者 每个epoch转换（包括创世区块）作为一个无状态的检查点，有能力的客户端应该能够同步而不需要任何以前的状态。 这意味着新epoch header不得包含投票，所有未落实的投票都将被丢弃，并从头开始计数。 对于所有非epoch 转换块： - 签名者可以使用自己签署的区块投一票，以提出对授权列表的更改。 - 对每一个提案只保留最新的一个投票。 - 随着链条的进展，投票也会生效（允许同时提交提案）。 - 达成多数人意见的提案SIGNER_LIMIT立即生效。 - 对于客户端实现的简单性，无效的提议不会受到惩罚。 **生效的提案意味着放弃对该提案的所有未决投票（无论是赞成还是反对），并从一个清晰的名单开始。** ### 级联投票 签名者取消授权期间可能会出现复杂的案例。如果先前授权的签署者被撤销，则批准提案所需的签名者数量可能会减少一个。这可能会导致一个或多个未决的提案达成共识，执行这些提案可能会进一步影响新的提案。 当多个相冲突的提议同时通过时（例如，添加新的签名者vs删除现有的提案者），处理这种情况并不明显，评估顺序可能会彻底改变最终授权列表的结果。由于签名者可能会在他们自己的每一个区块中反转他们自己的投票，所以哪一个提案将是“第一”并不那么明显。 为了避免级联执行所带来的缺陷，解决的办法是明确禁止级联效应。换句话说：只有当前标题/投票的受益人可以被添加到授权列表或从授权列表中删除。如果这导致其他建议达成共识，那么当他们各自的受益者再次“触发”时，这些建议将被执行（因为大多数人的共识仍然在这一点上）。 ### 投票策略 由于区块链可以有很小的reorgs，所以“cast-and-forget”的天真投票机制可能不是最优的，因为包含singleton投票的区块可能不会在最终的链中结束。 一个简单但工作的策略是允许用户在签名者上配置“提案”（例如“add 0x ...”，“drop 0x ...”）。 签署的代码，然后可以选择一个随机的建议，每块它签署和注入。 这确保了多个并发提案以及reorgs最终在链上被注意到。 这个列表可能在一定数量的块/epoch后过期，但重要的是要认识到“看”一个提案通过并不意味着它不会被重新组合，所以当提案通过时不应该立即放弃。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/05/14/eeda892c79582b64669fb2bf68dfe073.html" />
<meta property="og:url" content="https://mlh.app/2018/05/14/eeda892c79582b64669fb2bf68dfe073.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-14T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"https://github.com/ethereum/EIPs/issues/225 Clique的模式下，用户是无法获取以太币的，因为无法挖矿，所以如果需要以太币， 需要通过特殊的途径来获取。 可以通过这个网站获取ether https://faucet.rinkeby.io/ 需要有google+账号，facebook或者twitter账号才能获取， 详细的获取办法参考上面的网站。 Clique 是以太坊的一个Power of authority 的实现， 现在主要在Rinkeby 测试网络使用。 ## 背景 以太坊的第一个官方测试网是Morden。它从2015年7月到2016年11月，由于Geth和Parity之间累积的垃圾和一些testnet的共识问题，最终决定停止重新启动testnet。 Ropsten就这样诞生了，清理掉了所有的垃圾，从一个干净的石板开始。这一运行状况一直持续到2017年2月底，当时恶意行为者决定滥用Pow，并逐步将GasLimit从正常的470万提高到90亿，此时发送巨大的交易损害整个网络。甚至在此之前，攻击者尝试了多次非常长的区块链重组，导致不同客户端之间的网络分裂，甚至是不同的版本。 这些攻击的根本原因在于PoW网络的安全性与它背后的计算能力一样安全。从零开始重新启动一个新的测试网络并不能解决任何问题，因为攻击者可以反复安装相同的攻击。Parity 团队决定采取一个紧急的解决办法，回滚大量的区块，制定一个不允许GasLimit超过一定门槛的软交叉。 虽然这个解决方案可能在短期内工作： 这并不高雅：以太坊应该有动态的限制 这不是可移植的：其他客户需要自己实现新的fork逻辑 它与同步模式不兼容：fast sync和轻客户端都运气不佳 这只是延长了攻击的时间：垃圾依然可以在无尽的情况下稳步推进 Parity的解决方案虽然不完美，但仍然可行。我想提出一个更长期的替代解决方案，涉及更多，但应该足够简单，以便能够在合理的时间内推出。 ## 标准化的PoA 如上所述，在没有价值的网络中，Pow不能安全地工作。 以太坊有以Casper为基础的长期PoS目标，但是这是一个繁琐的研究，所以我们不能很快依靠这个来解决今天的问题。 然而，一种解决方案很容易实施，而且足够有效地正确地修复测试网络，即权威证明方案（proof-of-authority scheme）。 注意，Parity确实有PoA的实现，虽然看起来比需要的更复杂，没有太多的协议文档，但是很难看到它可以和其他客户一起玩。 我欢迎他们基于他们的经验来给我的这个提案更多的反馈。 这里描述的PoA协议的主要设计目标是实现和嵌入任何现有的以太坊客户端应该是非常简单的，同时允许使用现有的同步技术（快速，轻松，扭曲），而不需要客户端开发者添加 定制逻辑到关键软件。 ## PoA101 对于那些没有意识到PoA如何运作的人来说，这是一个非常简单的协议，而不是矿工们为了解决一个困难的问题而竞相争夺，授权签署者可以随时自行决定是否创建新的块。 挑战围绕着如何控制挖矿频率，如何在不同的签名者之间分配负载（和机会）以及如何动态调整签名者列表。 下一节定义一个处理所有这些场景的建议协议。 ## Rinkeby proof-of-authority 总体来说，有两种同步区块链的方法： - 传统的方法是把所有的事务一个接一个地进行起始块和紧缩。这种方式尝试过而且已经被证明在以太坊这种复杂的网络中非常耗费计算资源。 另一种是只下载区块链头并验证它们的有效性，此后可以从网络上下载一个任意的最近的状态并检查最近的header。 - PoA方案基于这样的想法，即块可能只能由可信签署人完成。 因此，客户端看到的每个块（或header）都可以与可信任的签名者列表进行匹配。 这里面临的挑战是如何维护一个可以及时更改的授权签名者列表？ 明显的答案（将其存储在以太坊合同中）也是错误的答案：在快速同步期间是无法访问状态的。 **维护授权签名者列表的协议必须完全包含在块头中。** 下一个显而易见的想法是改变块标题的结构，这样就可以放弃PoW的概念，并引入新的字段来迎合投票机制。 这也是错误的答案：在多个实现中更改这样一个核心数据结构将是一个开发，维护和安全的噩梦。 **维护授权签名者列表的协议必须完全适合当前的数据模型。** 所以，根据以上所述，我们不能使用EVM进行投票，而是不得不求助于区块头。 而且我们不能改变区块头字段，而不得不求助于当前可用的字段。 没有太多的选择。 ### 把区块头的一些其他字段用来实现投票和签名 当前仅用作有趣元数据的最明显的字段是块头中的32字节的ExtraData部分。 矿工们通常把他们的客户端和版本放在那里，但是有些人用另外的“信息”填充它们。 该协议将扩展此字段以增加65字节用来存放矿工的KEC签名。 这将允许任何获得一个区块的人员根据授权签名者的名单对其进行验证。 同时它也使得区块头中的矿工地址的字段作废。 请注意，更改区块头的长度是非侵入性操作，因为所有代码（例如RLP编码，哈希）都不可知，所以客户端不需要定制逻辑。 以上就足以验证一个链，但我们如何更新一个动态的签名者列表。 答案是，我们可以重新使用新近过时的矿工字段beneficiary和PoA废弃的nonce字段来创建投票协议： - 在常规块中，这两个字段都将被设置为零。 - 如果签名者希望对授权签名人列表进行更改，则会： &nbsp;&nbsp;&nbsp;&nbsp; - 将矿工字段 **beneficiary**设置为希望投票的签署者 &nbsp;&nbsp;&nbsp;&nbsp; - 将 **nonce**设置为0或0xff ... f来投票赞成添加或踢出 任何同步链的客户端都可以在数据块处理过程中“统计”选票，并通过普通投票保持授权签名者的动态变化列表。 初始的一组签名者通过创世区块的参数提供（以避免在起始状态中部署“最初选民名单”合同的复杂性）。 为了避免有一个无限的窗口来统计票数，并且允许定期清除陈旧的提议，我们可以重新使用ethash的概念 epoch，每个epoch 转换都会刷新所有未决的投票。 此外，这些epoch 转换还可以作为包含头部额外数据内的当前授权签名者列表的无状态检查点。 这允许客户端仅基于检查点散列进行同步，而不必重播在链上进行的所有投票。 它同样允许用包含了初始签名者的创世区块来完全定义区块链 ### 攻击媒介：恶意签名者 可能发生恶意用户被添加到签名者列表中，或者签名者密钥/机器受到威胁。 在这种情况下，协议需要能够抵御重组和垃圾邮件。 所提出的解决方案是，给定N个授权签名者的列表，任何签名者可能只在每个K中填充1个块。这确保损害是有限的，其余的矿工可以投出恶意用户。 ## 攻击媒介：审查签名者 另一个有趣的攻击媒介是如果一个签名者（或者一组签名者）试图检查出从授权列表中删除它们的块。 为了解决这个问题，我们限制了签名者允许的最小频率为N / 2。 这确保了恶意签名者需要控制至少51％的签名帐户，在这种情况下，游戏就是无论如何也无法进行下去了。 ## 攻击媒介：垃圾邮件签名者 最后的小型攻击媒介就是恶意签署者在每一个块内注入新的投票建议。 由于节点需要统计所有投票来创建授权签名者的实际列表，所以他们需要通过时间跟踪所有投票。 没有限制投票窗口，这可能会慢慢增长，但却是无限的。 解决方法是放置一个W块的移动窗口，之后投票被认为是陈旧的。 一个理智的窗户可能是1-2个时代。 我们将这称为一个时代。 ## 攻击媒介：并发块 如果授权签名者的数量是N，并且我们允许每个签名者在K中填充1个块，那么在任何时间N-K个矿工都被允许为Mint。 为了避免这些争夺块，每个签名者将添加一个小的随机“抵消”，以释放一个新的块。 这确保了小叉子是罕见的，但偶尔还会发生（如在主网上）。 如果一个签名者被滥用权威而引起混乱，那么这个签名就可以被投票出去。 ## 注意 ### 这是否表明建议我们使用一个被审查testnet？ 该提议表明，考虑到某些行为者的恶意性质，并且鉴于“垄断资金”网络中PoW计划的弱点，最好是建立一个网络，使其具有一定的垃圾过滤功能，开发人员可以依靠它来测试其程序。 为什么规范PoA？ 不同的客户在不同的情况下会更好。 Go可能在服务器端环境中很棒，但CPP可能更适合在RPI Zero上运行。 手动投票是不是很麻烦？ 这是一个实现细节，但是签名者可以利用基于合同的投票策略，利用EVM的全部功能，只将结果推送到平均节点的头部进行验证。 ## 澄清和反馈 - 这个建议并不排除客户端运行基于PoW的测试网络，无论是Ropsten还是基于它的新的测试网络。理想的情况是客户提供一种连接PoW以及基于PoA的测试网络的方法（＃225（评论））。 - 协议参数尽管可以在客户端实施者的破坏中进行配置，但Rinkeby网络应该尽可能地靠近主网络。这包括动态GasLimit，15秒左右的可变区块时间，GasPrice等（＃225（评论））。 - 该方案要求至少有K个签名者随时上网，因为这是确保“最小化”多样性所需的最少人数。这意味着如果超过K，则网络停止。这应该通过确保签名者是高运行时间的机器来解决，并且在发生太多故障之前及时地将失败的机器投票出去（＃225（评论））。 - 该提案并没有解决“合法的”垃圾邮件问题，就像在攻击者有效地使用testnet以创建垃圾一样，但是如果没有PoW挖掘，攻击者可能无法获得无限的ether来攻击。一种可能性是以有限的方式（例如每天10次）（＃225（评论）），以GitHub（或其他任何方式）帐户为基础提供一个获取ether的途径。 - 有人建议为当时包含授权签名者列表的每个epoch创建checkpoint block。这将允许稍后的轻客户说“从这里同步”，而不需要从起源开始。这可以在签名之前作为前缀添加到extradata字段（＃225（comment））。 ## Clique PoA 一致性协议 (Clique proof-of-authority consensus protocol ) 我们定义下面的常量： - EPOCH_LENGTH：检查点并重置未决投票的块数。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议30000，以便和主网络的ethhash epoch类似 - BLOCK_PERIOD：两个连续块的时间戳之间的最小差异。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议15，以便和主网络的ethhash epoch类似 - EXTRA_VANITY：固定数量的ExtraData前缀字节为签名者vanity保留。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议的32个字节以便和当前的ExtraData的长度相同。 - EXTRA_SEAL：为签名者印章保留的固定数量的额外数据后缀字节。 &nbsp;&nbsp;&nbsp;&nbsp; - 保存签名的65个字节，基于标准secp256k1曲线。 - NONCE_AUTH：魔术随机数字0xffffffffffffffff投票添加一个新的签名者。 - NONCE_DROP：魔术随机数字0x0000000000000000对移除签名者进行投票。 - UNCLE_HASH：始终Keccak256（RLP（[]））作为Uncles在PoW之外没有任何意义。 - DIFF_NOTURN：如果当前没有轮到你签名，那么你签名的区块的难度就是这个难度。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议1，因为它只需要是一个任意的基线常数。 - DIFF_INTURN：如果当前轮到你签名，那么你签名的难度。 &nbsp;&nbsp;&nbsp;&nbsp; - 建议2， 这样就比没有轮到的签名者难度要高。 我们还定义了以下每块的常量： - BLOCK_NUMBER：链中的块高度，创世区块的高度是0。 - SIGNER_COUNT：在区块链中中特定实例上有效的授权签名者的数量。 - SIGNER_INDEX：当前授权签名者的排序列表中的索引。 - SIGNER_LIMIT：每隔这么多块，签名者只能签署一块。 &nbsp;&nbsp;&nbsp;&nbsp; - 必须有floor(SIGNER_COUNT / 2）+1 这么多签名者同意才能达成某项决议。 我们重新调整区块头字段的用途，如下所示： - beneficiary：建议修改授权签名人名单的地址。 &nbsp;&nbsp;&nbsp;&nbsp; - 应该正常填写零，只有投票时修改。 &nbsp;&nbsp;&nbsp;&nbsp; - 尽管如此，仍然允许任意值（甚至是无意义的值，例如投出非签名者），以避免增加围绕投票机制的额外复杂性。 &nbsp;&nbsp;&nbsp;&nbsp; - 必须在检查点（即epoch转换）块填充零。 - nonce：Signer关于受益人字段中定义的账户的建议。 &nbsp;&nbsp;&nbsp;&nbsp; - NONCE_DROP 提议取消授权受益人作为现有签名者。 &nbsp;&nbsp;&nbsp;&nbsp; - NONCE_AUTH 提出授权受益人作为新的签名者。 &nbsp;&nbsp;&nbsp;&nbsp; - 必须在检查点块填充零。 &nbsp;&nbsp;&nbsp;&nbsp; - 除了上述两者（现在）之外，不得采用任何其他值。 - extraData： vanity, checkpointing and signer signatures的组合字段。 &nbsp;&nbsp;&nbsp;&nbsp; - 第一个EXTRA_VANITY字节（固定长度）可以包含任意签名者vanity data。 &nbsp;&nbsp;&nbsp;&nbsp; - 最后一个EXTRA_SEAL字节（固定长度）是密封标题的签名者签名。 &nbsp;&nbsp;&nbsp;&nbsp; - 检查点块必须包含一个签名者列表（N * 20字节），否则省略。 &nbsp;&nbsp;&nbsp;&nbsp; - 检查点块附加数据部分中的签署者列表必须按升序排序。 - mixHash：为了分叉保留。类似于Dao的额外数据 &nbsp;&nbsp;&nbsp;&nbsp; - 在正常操作期间必须填入零。 - ommersHash：必须是UNCLE_HASH，因为在PoW之外，Uncles叔没有任何意义。 - timestamp：必须至少为父区块的时间戳 + BLOCK_PERIOD。 - difficulty：包含块的独立得分 来推导链的质量。 &nbsp;&nbsp;&nbsp;&nbsp; - 如果BLOCK_NUMBER％SIGNER_COUNT！= SIGNER_INDEX，则必须为DIFF_NOTURN &nbsp;&nbsp;&nbsp;&nbsp; - 如果BLOCK_NUMBER％SIGNER_COUNT == SIGNER_INDEX，则必须为DIFF_INTURN ### Authorizing a block 为了给网络授权一个块，签名者需要签署包含除签名本身以外的所有内容。 这意味着哈希包含区块头的每个字段（包括nonce和mixDigest），还有除了65字节签名后缀外的extraData。 这些字段按照其在黄皮书中定义的顺序进行hash。 该散列使用标准的secp256k1曲线进行签名，得到的65字节签名（R，S，V，其中V为0或1）作为尾随的65字节后缀嵌入到extraData中。 为了确保恶意签名者（签名密钥丢失）不能在网络上受到破坏，每位签名者都可以在SIGNER_LIMIT连续块中签最多一个。 顺序不是固定的，不过（DIFF_INTURN）的签名者签出的区块难度要比（DIFF_NOTURN）高 #### 授权策略 只要签名者符合上述规范，他们可以授权和分配他们认为合适的块， 下面的建议策略会减少网络流量和分叉，所以这是一个建议的功能： - 如果签署者被允许签署一个区块（在授权清单上并且最近没有签署）。 &nbsp;&nbsp;&nbsp;&nbsp; - 计算下一个块的最佳签名时间（父+ BLOCK_PERIOD）。 &nbsp;&nbsp;&nbsp;&nbsp; - 如果轮到了，等待准确的时间到达，立即签字和播放。 &nbsp;&nbsp;&nbsp;&nbsp; - 如果没有轮到，则延迟 rand（SIGNER_COUNT * 500ms）这么久的时间签名。 这个小小的策略将确保当前轮到的签名者（谁的块更重）对签名和传播与外转签名者有稍微的优势。 此外，该方案允许随着签名者数目的增加而具有一定规模。 ### 投票签署者 每个epoch转换（包括创世区块）作为一个无状态的检查点，有能力的客户端应该能够同步而不需要任何以前的状态。 这意味着新epoch header不得包含投票，所有未落实的投票都将被丢弃，并从头开始计数。 对于所有非epoch 转换块： - 签名者可以使用自己签署的区块投一票，以提出对授权列表的更改。 - 对每一个提案只保留最新的一个投票。 - 随着链条的进展，投票也会生效（允许同时提交提案）。 - 达成多数人意见的提案SIGNER_LIMIT立即生效。 - 对于客户端实现的简单性，无效的提议不会受到惩罚。 **生效的提案意味着放弃对该提案的所有未决投票（无论是赞成还是反对），并从一个清晰的名单开始。** ### 级联投票 签名者取消授权期间可能会出现复杂的案例。如果先前授权的签署者被撤销，则批准提案所需的签名者数量可能会减少一个。这可能会导致一个或多个未决的提案达成共识，执行这些提案可能会进一步影响新的提案。 当多个相冲突的提议同时通过时（例如，添加新的签名者vs删除现有的提案者），处理这种情况并不明显，评估顺序可能会彻底改变最终授权列表的结果。由于签名者可能会在他们自己的每一个区块中反转他们自己的投票，所以哪一个提案将是“第一”并不那么明显。 为了避免级联执行所带来的缺陷，解决的办法是明确禁止级联效应。换句话说：只有当前标题/投票的受益人可以被添加到授权列表或从授权列表中删除。如果这导致其他建议达成共识，那么当他们各自的受益者再次“触发”时，这些建议将被执行（因为大多数人的共识仍然在这一点上）。 ### 投票策略 由于区块链可以有很小的reorgs，所以“cast-and-forget”的天真投票机制可能不是最优的，因为包含singleton投票的区块可能不会在最终的链中结束。 一个简单但工作的策略是允许用户在签名者上配置“提案”（例如“add 0x ...”，“drop 0x ...”）。 签署的代码，然后可以选择一个随机的建议，每块它签署和注入。 这确保了多个并发提案以及reorgs最终在链上被注意到。 这个列表可能在一定数量的块/epoch后过期，但重要的是要认识到“看”一个提案通过并不意味着它不会被重新组合，所以当提案通过时不应该立即放弃。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/05/14/eeda892c79582b64669fb2bf68dfe073.html","headline":"以太坊源码分析(53）以太坊测试网络Clique_PoA介绍","dateModified":"2018-05-14T00:00:00+08:00","datePublished":"2018-05-14T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/05/14/eeda892c79582b64669fb2bf68dfe073.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊源码分析(53）以太坊测试网络Clique_PoA介绍</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas, 'Courier New', monospace;font-size:14px;line-height:19px;">
   <div>
    https://github.com/ethereum/EIPs/issues/225
   </div>
   <br>
   <div>
    Clique的模式下，用户是无法获取以太币的，因为无法挖矿，所以如果需要以太币， 需要通过特殊的途径来获取。
   </div>
   <br>
   <div>
    可以通过这个网站获取ether
   </div>
   <br>
   <div>
    https://faucet.rinkeby.io/
   </div>
   <br>
   <div>
    需要有google+账号，facebook或者twitter账号才能获取， 详细的获取办法参考上面的网站。
   </div>
   <br>
   <br>
   <br>
   <div>
    Clique 是以太坊的一个Power of authority 的实现， 现在主要在Rinkeby 测试网络使用。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 背景</strong></span>
   </div>
   <br>
   <div>
    以太坊的第一个官方测试网是Morden。它从2015年7月到2016年11月，由于Geth和Parity之间累积的垃圾和一些testnet的共识问题，最终决定停止重新启动testnet。
   </div>
   <br>
   <div>
    Ropsten就这样诞生了，清理掉了所有的垃圾，从一个干净的石板开始。这一运行状况一直持续到2017年2月底，当时恶意行为者决定滥用Pow，并逐步将GasLimit从正常的470万提高到90亿，此时发送巨大的交易损害整个网络。甚至在此之前，攻击者尝试了多次非常长的区块链重组，导致不同客户端之间的网络分裂，甚至是不同的版本。
   </div>
   <br>
   <div>
    这些攻击的根本原因在于PoW网络的安全性与它背后的计算能力一样安全。从零开始重新启动一个新的测试网络并不能解决任何问题，因为攻击者可以反复安装相同的攻击。Parity 团队决定采取一个紧急的解决办法，回滚大量的区块，制定一个不允许GasLimit超过一定门槛的软交叉。
   </div>
   <br>
   <div>
    虽然这个解决方案可能在短期内工作：
   </div>
   <br>
   <div>
    这并不高雅：以太坊应该有动态的限制
   </div>
   <div>
    这不是可移植的：其他客户需要自己实现新的fork逻辑
   </div>
   <div>
    它与同步模式不兼容：fast sync和轻客户端都运气不佳
   </div>
   <div>
    这只是延长了攻击的时间：垃圾依然可以在无尽的情况下稳步推进
   </div>
   <div>
    Parity的解决方案虽然不完美，但仍然可行。我想提出一个更长期的替代解决方案，涉及更多，但应该足够简单，以便能够在合理的时间内推出。
   </div>
   <br>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 标准化的PoA</strong></span>
   </div>
   <br>
   <div>
    如上所述，在没有价值的网络中，Pow不能安全地工作。 以太坊有以Casper为基础的长期PoS目标，但是这是一个繁琐的研究，所以我们不能很快依靠这个来解决今天的问题。 然而，一种解决方案很容易实施，而且足够有效地正确地修复测试网络，即权威证明方案（proof-of-authority scheme）。
   </div>
   <br>
   <div>
    注意，Parity确实有PoA的实现，虽然看起来比需要的更复杂，没有太多的协议文档，但是很难看到它可以和其他客户一起玩。 我欢迎他们基于他们的经验来给我的这个提案更多的反馈。
   </div>
   <br>
   <div>
    这里描述的PoA协议的主要设计目标是实现和嵌入任何现有的以太坊客户端应该是非常简单的，同时允许使用现有的同步技术（快速，轻松，扭曲），而不需要客户端开发者添加 定制逻辑到关键软件。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## PoA101</strong></span>
   </div>
   <br>
   <div>
    对于那些没有意识到PoA如何运作的人来说，这是一个非常简单的协议，而不是矿工们为了解决一个困难的问题而竞相争夺，授权签署者可以随时自行决定是否创建新的块。
   </div>
   <br>
   <div>
    挑战围绕着如何控制挖矿频率，如何在不同的签名者之间分配负载（和机会）以及如何动态调整签名者列表。 下一节定义一个处理所有这些场景的建议协议。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## Rinkeby proof-of-authority</strong></span>
   </div>
   <br>
   <div>
    总体来说，有两种同步区块链的方法：
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> 传统的方法是把所有的事务一个接一个地进行起始块和紧缩。这种方式尝试过而且已经被证明在以太坊这种复杂的网络中非常耗费计算资源。
   </div>
   <div>
    另一种是只下载区块链头并验证它们的有效性，此后可以从网络上下载一个任意的最近的状态并检查最近的header。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> PoA方案基于这样的想法，即块可能只能由可信签署人完成。 因此，客户端看到的每个块（或header）都可以与可信任的签名者列表进行匹配。 这里面临的挑战是如何维护一个可以及时更改的授权签名者列表？ 明显的答案（将其存储在以太坊合同中）也是错误的答案：在快速同步期间是无法访问状态的。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>**维护授权签名者列表的协议必须完全包含在块头中。**</strong></span>
   </div>
   <br>
   <div>
    下一个显而易见的想法是改变块标题的结构，这样就可以放弃PoW的概念，并引入新的字段来迎合投票机制。 这也是错误的答案：在多个实现中更改这样一个核心数据结构将是一个开发，维护和安全的噩梦。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>**维护授权签名者列表的协议必须完全适合当前的数据模型。**</strong></span>
   </div>
   <br>
   <div>
    所以，根据以上所述，我们不能使用EVM进行投票，而是不得不求助于区块头。 而且我们不能改变区块头字段，而不得不求助于当前可用的字段。 没有太多的选择。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 把区块头的一些其他字段用来实现投票和签名</strong></span>
   </div>
   <br>
   <div>
    当前仅用作有趣元数据的最明显的字段是块头中的32字节的ExtraData部分。 矿工们通常把他们的客户端和版本放在那里，但是有些人用另外的“信息”填充它们。 该协议将扩展此字段以增加65字节用来存放矿工的KEC签名。 这将允许任何获得一个区块的人员根据授权签名者的名单对其进行验证。 同时它也使得区块头中的矿工地址的字段作废。
   </div>
   <br>
   <div>
    请注意，更改区块头的长度是非侵入性操作，因为所有代码（例如RLP编码，哈希）都不可知，所以客户端不需要定制逻辑。
   </div>
   <br>
   <div>
    以上就足以验证一个链，但我们如何更新一个动态的签名者列表。 答案是，我们可以重新使用新近过时的矿工字段beneficiary和PoA废弃的nonce字段来创建投票协议：
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> 在常规块中，这两个字段都将被设置为零。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> 如果签名者希望对授权签名人列表进行更改，则会：
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 将矿工字段
    <span style="color:#569cd6;"><strong>**beneficiary**</strong></span>设置为希望投票的签署者
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 将
    <span style="color:#569cd6;"><strong>**nonce**</strong></span>设置为0或0xff ... f来投票赞成添加或踢出
   </div>
   <br>
   <div>
    任何同步链的客户端都可以在数据块处理过程中“统计”选票，并通过普通投票保持授权签名者的动态变化列表。 初始的一组签名者通过创世区块的参数提供（以避免在起始状态中部署“最初选民名单”合同的复杂性）。
   </div>
   <br>
   <div>
    为了避免有一个无限的窗口来统计票数，并且允许定期清除陈旧的提议，我们可以重新使用ethash的概念 epoch，每个epoch 转换都会刷新所有未决的投票。 此外，这些epoch 转换还可以作为包含头部额外数据内的当前授权签名者列表的无状态检查点。 这允许客户端仅基于检查点散列进行同步，而不必重播在链上进行的所有投票。 它同样允许用包含了初始签名者的创世区块来完全定义区块链
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 攻击媒介：恶意签名者</strong></span>
   </div>
   <br>
   <div>
    可能发生恶意用户被添加到签名者列表中，或者签名者密钥/机器受到威胁。 在这种情况下，协议需要能够抵御重组和垃圾邮件。 所提出的解决方案是，给定N个授权签名者的列表，任何签名者可能只在每个K中填充1个块。这确保损害是有限的，其余的矿工可以投出恶意用户。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 攻击媒介：审查签名者</strong></span>
   </div>
   <br>
   <div>
    另一个有趣的攻击媒介是如果一个签名者（或者一组签名者）试图检查出从授权列表中删除它们的块。 为了解决这个问题，我们限制了签名者允许的最小频率为N / 2。 这确保了恶意签名者需要控制至少51％的签名帐户，在这种情况下，游戏就是无论如何也无法进行下去了。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 攻击媒介：垃圾邮件签名者</strong></span>
   </div>
   <br>
   <div>
    最后的小型攻击媒介就是恶意签署者在每一个块内注入新的投票建议。 由于节点需要统计所有投票来创建授权签名者的实际列表，所以他们需要通过时间跟踪所有投票。 没有限制投票窗口，这可能会慢慢增长，但却是无限的。 解决方法是放置一个W块的移动窗口，之后投票被认为是陈旧的。 一个理智的窗户可能是1-2个时代。 我们将这称为一个时代。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 攻击媒介：并发块</strong></span>
   </div>
   <br>
   <div>
    如果授权签名者的数量是N，并且我们允许每个签名者在K中填充1个块，那么在任何时间N-K个矿工都被允许为Mint。 为了避免这些争夺块，每个签名者将添加一个小的随机“抵消”，以释放一个新的块。 这确保了小叉子是罕见的，但偶尔还会发生（如在主网上）。 如果一个签名者被滥用权威而引起混乱，那么这个签名就可以被投票出去。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 注意</strong></span>
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 这是否表明建议我们使用一个被审查testnet？</strong></span>
   </div>
   <br>
   <div>
    该提议表明，考虑到某些行为者的恶意性质，并且鉴于“垄断资金”网络中PoW计划的弱点，最好是建立一个网络，使其具有一定的垃圾过滤功能，开发人员可以依靠它来测试其程序。
   </div>
   <br>
   <div>
    为什么规范PoA？
   </div>
   <br>
   <div>
    不同的客户在不同的情况下会更好。 Go可能在服务器端环境中很棒，但CPP可能更适合在RPI Zero上运行。
   </div>
   <br>
   <div>
    手动投票是不是很麻烦？
   </div>
   <br>
   <div>
    这是一个实现细节，但是签名者可以利用基于合同的投票策略，利用EVM的全部功能，只将结果推送到平均节点的头部进行验证。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 澄清和反馈</strong></span>
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> 这个建议并不排除客户端运行基于PoW的测试网络，无论是Ropsten还是基于它的新的测试网络。理想的情况是客户提供一种连接PoW以及基于PoA的测试网络的方法（＃225（评论））。
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> 协议参数尽管可以在客户端实施者的破坏中进行配置，但Rinkeby网络应该尽可能地靠近主网络。这包括动态GasLimit，15秒左右的可变区块时间，GasPrice等（＃225（评论））。
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> 该方案要求至少有K个签名者随时上网，因为这是确保“最小化”多样性所需的最少人数。这意味着如果超过K，则网络停止。这应该通过确保签名者是高运行时间的机器来解决，并且在发生太多故障之前及时地将失败的机器投票出去（＃225（评论））。
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> 该提案并没有解决“合法的”垃圾邮件问题，就像在攻击者有效地使用testnet以创建垃圾一样，但是如果没有PoW挖掘，攻击者可能无法获得无限的ether来攻击。一种可能性是以有限的方式（例如每天10次）（＃225（评论）），以GitHub（或其他任何方式）帐户为基础提供一个获取ether的途径。
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> 有人建议为当时包含授权签名者列表的每个epoch创建checkpoint block。这将允许稍后的轻客户说“从这里同步”，而不需要从起源开始。这可以在签名之前作为前缀添加到extradata字段（＃225（comment））。
   </div>
   <br>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## Clique PoA 一致性协议 (Clique proof-of-authority consensus protocol )</strong></span>
   </div>
   <div>
    我们定义下面的常量：
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> EPOCH_LENGTH：检查点并重置未决投票的块数。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 建议30000，以便和主网络的ethhash epoch类似
   </div>
   <div>
    <span style="color:#6796e6;">-</span> BLOCK_PERIOD：两个连续块的时间戳之间的最小差异。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 建议15，以便和主网络的ethhash epoch类似
   </div>
   <div>
    <span style="color:#6796e6;">-</span> EXTRA_VANITY：固定数量的ExtraData前缀字节为签名者vanity保留。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 建议的32个字节以便和当前的ExtraData的长度相同。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> EXTRA_SEAL：为签名者印章保留的固定数量的额外数据后缀字节。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 保存签名的65个字节，基于标准secp256k1曲线。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> NONCE_AUTH：魔术随机数字0xffffffffffffffff投票添加一个新的签名者。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> NONCE_DROP：魔术随机数字0x0000000000000000对移除签名者进行投票。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> UNCLE_HASH：始终Keccak256（RLP（[]））作为Uncles在PoW之外没有任何意义。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> DIFF_NOTURN：如果当前没有轮到你签名，那么你签名的区块的难度就是这个难度。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 建议1，因为它只需要是一个任意的基线常数。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> DIFF_INTURN：如果当前轮到你签名，那么你签名的难度。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 建议2， 这样就比没有轮到的签名者难度要高。
   </div>
   <br>
   <div>
    我们还定义了以下每块的常量：
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> BLOCK_NUMBER：链中的块高度，创世区块的高度是0。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> SIGNER_COUNT：在区块链中中特定实例上有效的授权签名者的数量。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> SIGNER_INDEX：当前授权签名者的排序列表中的索引。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> SIGNER_LIMIT：每隔这么多块，签名者只能签署一块。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 必须有floor(SIGNER_COUNT / 2）+1 这么多签名者同意才能达成某项决议。
   </div>
   <br>
   <div>
    我们重新调整区块头字段的用途，如下所示：
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> beneficiary：建议修改授权签名人名单的地址。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 应该正常填写零，只有投票时修改。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 尽管如此，仍然允许任意值（甚至是无意义的值，例如投出非签名者），以避免增加围绕投票机制的额外复杂性。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 必须在检查点（即epoch转换）块填充零。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> nonce：Signer关于受益人字段中定义的账户的建议。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> NONCE_DROP 提议取消授权受益人作为现有签名者。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> NONCE_AUTH 提出授权受益人作为新的签名者。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 必须在检查点块填充零。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 除了上述两者（现在）之外，不得采用任何其他值。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> extraData： vanity, checkpointing and signer signatures的组合字段。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 第一个EXTRA_VANITY字节（固定长度）可以包含任意签名者vanity data。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 最后一个EXTRA_SEAL字节（固定长度）是密封标题的签名者签名。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 检查点块必须包含一个签名者列表（N * 20字节），否则省略。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 检查点块附加数据部分中的签署者列表必须按升序排序。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> mixHash：为了分叉保留。类似于Dao的额外数据
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 在正常操作期间必须填入零。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> ommersHash：必须是UNCLE_HASH，因为在PoW之外，Uncles叔没有任何意义。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> timestamp：必须至少为父区块的时间戳 + BLOCK_PERIOD。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> difficulty：包含块的独立得分 来推导链的质量。 
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 如果BLOCK_NUMBER％SIGNER_COUNT！= SIGNER_INDEX，则必须为DIFF_NOTURN
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 如果BLOCK_NUMBER％SIGNER_COUNT == SIGNER_INDEX，则必须为DIFF_INTURN
   </div>
   <br>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### Authorizing a block</strong></span>
   </div>
   <div>
    为了给网络授权一个块，签名者需要签署包含除签名本身以外的所有内容。 这意味着哈希包含区块头的每个字段（包括nonce和mixDigest），还有除了65字节签名后缀外的extraData。 这些字段按照其在黄皮书中定义的顺序进行hash。
   </div>
   <br>
   <div>
    该散列使用标准的secp256k1曲线进行签名，得到的65字节签名（R，S，V，其中V为0或1）作为尾随的65字节后缀嵌入到extraData中。
   </div>
   <br>
   <div>
    为了确保恶意签名者（签名密钥丢失）不能在网络上受到破坏，每位签名者都可以在SIGNER_LIMIT连续块中签最多一个。 顺序不是固定的，不过（DIFF_INTURN）的签名者签出的区块难度要比（DIFF_NOTURN）高
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>#### 授权策略</strong></span>
   </div>
   <br>
   <div>
    只要签名者符合上述规范，他们可以授权和分配他们认为合适的块， 下面的建议策略会减少网络流量和分叉，所以这是一个建议的功能：
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> 如果签署者被允许签署一个区块（在授权清单上并且最近没有签署）。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 计算下一个块的最佳签名时间（父+ BLOCK_PERIOD）。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 如果轮到了，等待准确的时间到达，立即签字和播放。
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#6796e6;">-</span> 如果没有轮到，则延迟 rand（SIGNER_COUNT * 500ms）这么久的时间签名。
   </div>
   <div>
    这个小小的策略将确保当前轮到的签名者（谁的块更重）对签名和传播与外转签名者有稍微的优势。 此外，该方案允许随着签名者数目的增加而具有一定规模。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 投票签署者</strong></span>
   </div>
   <br>
   <div>
    每个epoch转换（包括创世区块）作为一个无状态的检查点，有能力的客户端应该能够同步而不需要任何以前的状态。 这意味着新epoch header不得包含投票，所有未落实的投票都将被丢弃，并从头开始计数。
   </div>
   <br>
   <div>
    对于所有非epoch 转换块：
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> 签名者可以使用自己签署的区块投一票，以提出对授权列表的更改。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> 对每一个提案只保留最新的一个投票。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> 随着链条的进展，投票也会生效（允许同时提交提案）。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> 达成多数人意见的提案SIGNER_LIMIT立即生效。
   </div>
   <div>
    <span style="color:#6796e6;">-</span> 对于客户端实现的简单性，无效的提议不会受到惩罚。
   </div>
   <br>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>**生效的提案意味着放弃对该提案的所有未决投票（无论是赞成还是反对），并从一个清晰的名单开始。**</strong></span>
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 级联投票</strong></span>
   </div>
   <br>
   <div>
    签名者取消授权期间可能会出现复杂的案例。如果先前授权的签署者被撤销，则批准提案所需的签名者数量可能会减少一个。这可能会导致一个或多个未决的提案达成共识，执行这些提案可能会进一步影响新的提案。
   </div>
   <br>
   <div>
    当多个相冲突的提议同时通过时（例如，添加新的签名者vs删除现有的提案者），处理这种情况并不明显，评估顺序可能会彻底改变最终授权列表的结果。由于签名者可能会在他们自己的每一个区块中反转他们自己的投票，所以哪一个提案将是“第一”并不那么明显。
   </div>
   <br>
   <div>
    为了避免级联执行所带来的缺陷，解决的办法是明确禁止级联效应。换句话说：只有当前标题/投票的受益人可以被添加到授权列表或从授权列表中删除。如果这导致其他建议达成共识，那么当他们各自的受益者再次“触发”时，这些建议将被执行（因为大多数人的共识仍然在这一点上）。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 投票策略</strong></span>
   </div>
   <br>
   <div>
    由于区块链可以有很小的reorgs，所以“cast-and-forget”的天真投票机制可能不是最优的，因为包含singleton投票的区块可能不会在最终的链中结束。
   </div>
   <br>
   <div>
    一个简单但工作的策略是允许用户在签名者上配置“提案”（例如“add 0x ...”，“drop 0x ...”）。 签署的代码，然后可以选择一个随机的建议，每块它签署和注入。 这确保了多个并发提案以及reorgs最终在链上被注意到。
   </div>
   <br>
   <p>这个列表可能在一定数量的块/epoch后过期，但重要的是要认识到“看”一个提案通过并不意味着它不会被重新组合，所以当提案通过时不应该立即放弃。</p>
   <p></p>
   <h2 style="font-family:Consolas, 'Courier New', monospace;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180430224554793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><br></h2>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180425001235188?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180425001144107?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;">网址：http://www.qukuailianxueyuan.io/<br></p>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180426145827720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018042614570887?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;">欲领取造币技术与全套虚拟机资料</p>
   <p style="font-family:Consolas, 'Courier New', monospace;"><span style="color:rgb(25,25,25);">区块链技术交流QQ群：</span><span style="color:rgb(255,0,0);background-color:rgb(255,255,255);">756146052&nbsp;&nbsp;</span><span style="color:rgb(25,25,25);">备注：CSDN</span></p>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;">尹成学院微信：备注：CSDN</p>
   <p style="color:rgb(25,25,25);text-align:center;font-family:Consolas, 'Courier New', monospace;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180425000635656?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
   <div>
    <br>
   </div>
   <br>
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/itcastcpp/article/details/80305769,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/itcastcpp/article/details/80305769,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
