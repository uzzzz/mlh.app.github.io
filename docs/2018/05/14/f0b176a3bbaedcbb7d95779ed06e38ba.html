<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊源码分析(41）hashimoto源码分析 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊源码分析(41）hashimoto源码分析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hashimoto :I/O bound proof of work Abstract: Using a cryptographic hash function not as a proofofwork by itself, but rather as a generator of pointers to a shared data set, allows for an I/O bound proof of work. This method of proof of work is difficult to optimize via ASIC design, and difficult to outsource to nodes without the full data set. The name is based on the three operations which comprise the algorithm: hash, shift, and modulo. 摘要：使用密码散列函数本身并不作为工作的证明， 而是作为指向共享数据集的指针生成器，允许I / O绑定 工作证明。 这种工作证明方法很难通过ASIC设计来优化，并且在没有完整数据集的情况下很难外包给节点。 这个名字是基于构成算法的三个操作：散列，移位和 模。 The need for proofs which are difficult to outsource and optimize 工作量证明难以外包和优化的需求 A common challenge in cryptocurrency development is maintaining decentralization ofthe network. The use ofproofofwork to achieve decentralized consensus has been most notably demonstrated by Bitcoin, which uses partial collisions with zero ofsha256, similar to hashcash. As Bitcoin’s popularity has grown, dedicated hardware (currently application specific integrated circuits, or ASICs) has been produced to rapidly iterate the hash­based proofofwork function. Newer projects similar to Bitcoin often use different algorithms for proofofwork, and often with the goal ofASIC resistance. For algorithms such as Bitcoin’s, the improvement factor ofASICs means that commodity computer hardware can no longer be effectively used, potentially limiting adoption. 加密货币发展的一项挑战就是如何维持去中心化的网络结构。 正如比特币采用sha256哈希谜题的工作量证明方式来达到去中心化的一致性。 随着比特币的流行，专用硬件(目前的专用集成电路，或者是ASICs)已经被用来快速的执行基于hash方式的工作量证明函数。类似比特币的新项目通常使用不同的工作量证明算法，而且通常都有抵抗ASICs的目标。对于诸如比特币之类的算法，ASIC的对于性能的提升意味着普通的商业计算机硬件不再有效使用，可能会被限制采用。 Proofofwork can also be “outsourced”, or performed by a dedicated machine (a “miner”) without knowledge ofwhat is being verified. This is often the case in Bitcoin’s “mining pools”. It is also beneficial for a proofofwork algorithm to be difficult to outsource, in order to promote decentralization and encourage all nodes participating in the proofofwork process to also verify transactions. With these goals in mind, we present Hashimoto, an I/O bound proofofwork algorithm we believe to be resistant to both ASIC design and outsourcing. 工作量证明同样能够被外包出去，或者使用专用的机器(矿机)来执行工作量证明，而这些机器对于验证的内容并不清楚。比特币的“矿池”通常就是这种情况。如果工作量证明算法很难外包，以促进去中心化 并鼓励参与证明过程的所有节点也验证交易。为了达到这个目标，我们设计了hashimoti, 一个基于I/O 带宽的工作量证明算法，我们认为这个算法可以抵抗ASICs，同时也难以外包。 Initial attempts at &quot;ASIC resistance&quot; involved changing Bitcoin&#39;s sha256 algorithm for a different, more memory intensive algorithm, Percival&#39;s &quot;scrypt&quot; password based key derivation function1. Many implementations set the scrypt arguments to low memory requirements, defeating much ofthe purpose of the key derivation algorithm. While changing to a new algorithm, coupled with the relative obscurity of the various scrypt­based cryptocurrencies allowed for a delay, scrypt optimized ASICs are now available. Similar attempts at variations or multiple heterogeneous hash functions can at best only delay ASIC implementations. “ASIC抗性”的初始尝试包括改变比特币的sha256算法，用不同的，更多的内存密集型算法，Percival&#39;s &quot;scrypt&quot; password based key derivation function。许多实现都将脚本参数设置为低内存要求，这大大破坏了密钥派生算法的目的。在改用新算法的同时，再加上各种以scrypt为基础的加密货币的相对朦胧可能导致延迟，而且scrypt优化的ASIC现在已经上市。类似的变化尝试或多个异构散列函数最多只能延迟ASIC实现。 Leveraging shared data sets to create I/O bound proofs 利用共享数据集创建I / O限制证明 &nbsp;&nbsp;&nbsp;&nbsp;&quot;A supercomputer is a device for turning compute-bound problems into I/O-bound problems.&quot; &nbsp;&nbsp;&nbsp;&nbsp;-Ken Batcher &nbsp;&nbsp;&nbsp;&nbsp;“超级计算机是将计算受限问题转化为I / O约束问题的一种设备。” &nbsp;&nbsp;&nbsp;&nbsp;Ken Batcher Instead, an algorithm will have little room to be sped up by new hardware if it acts in a way that commodity computer systems are already optimized for. 相反，如果一种算法以商品计算机系统已经优化的方式运行，那么算法将没有多少空间可以被新硬件加速。 Since I/O bounds are what decades ofcomputing research has gone towards solving, it&#39;s unlikely that the relatively small motivation ofmining a few coins would be able to advance the state ofthe art in cache hierarchies. In the case that advances are made, they will be likely to impact the entire industry of computer hardware. 由于I / O界限是几十年来计算研究已经解决的问题，挖掘一些加密货币的相对较小的动机将不可能提高缓存层次结构的艺术水平。 在取得进展的情况下，可能会影响整个计算机硬件产业。 Fortuitously, all nodes participating in current implementations ofcryptocurrency have a large set of mutually agreed upon data; indeed this “blockchain” is the foundation ofthe currency. Using this large data set can both limit the advantage ofspecialized hardware, and require working nodes to have the entire data set. 幸运的是，参与当前加密货币实施的所有节点都有大量相互同意的数据;实际上，“区块链”是货币的基础。 使用这个大数据集既可以限制专用硬件的优点，又可以让工作节点拥有整个数据集。 Hashimoto is based offBitcoin’s proofofwork2. In Bitcoin’s case, as in Hashimoto, a successful proofsatisfies the following inequality: Hashimoto是基于比特币的工作量证明。 在比特币的情况下，和Hashimoto一样，一个成功的证明满足以下不等式： &nbsp;&nbsp;&nbsp;&nbsp;hash_output &lt; target For bitcoin, the hash_output is determined by 在比特币中， hash_output是由下面决定的。 &nbsp;&nbsp;&nbsp;&nbsp;hash_output = sha256(prev_hash, merkle_root, nonce) where prev_hash is the previous block’s hash and cannot be changed. The merkle_root is based on the transactions included in the block, and will be different for each individual node. The nonce is rapidly incremented as hash_outputs are calculated and do not satisfy the inequality. Thus the bottleneck of the proofis the sha256 function, and increasing the speed ofsha256 or parallelizing it is something ASICs can do very effectively. prev_hash是前一个区块的hash值，而且不能更改。merkle_root是基于区块中的交易生成的，并且对于每个单独的节点将是不同的。我们通过修改nonce的值来让上面的不等式成立。这样整个工作量证明的瓶颈在于sha256方法，而且通过ASIC可以极大增加sha256的计算速度，或者并行的运行它。 Hashimoto uses this hash output as a starting point, which is used to generated inputs for a second hash function. We call the original hash hash_output_A, and the final result of the prooffinal_output. Hashimoto使用这个hash_output作为一个起点，用来生成第二个hash函数的输入。我们称原始的hash为hash_output_A, 最终的结果为 prooffinal_output. Hash_output_A can be used to select many transactions from the shared blockchain, which are then used as inputs to the second hash. Instead of organizing transactions into blocks, for this purpose it is simpler to organize all transactions sequentially. For example, the 47th transaction of the 815th block might be termed transaction 141,918. We will use 64 transactions, though higher and lower numbers could work, with different access properties. We define the following functions: hash_output_a可用于从共享区块链中选择多个事务，然后将其用作第二个散列的输入。 而不是组织交易成块，为此目的是顺序组织所有交易更简单。 例如，第815个区块的第47个交易可能被称为交易141,918。 我们将使用64个交易，尽管更高和更低的数字可以工作，具有不同的访问属性。 我们定义以下功能： - nonce 64­bits. A new nonce is created for each attempt. - get_txid(T) return the txid (a hash ofa transaction) of transaction number T from block B. - block_height the current height ofthe block chain, which increases at each new block - nonce 64­bits. 每次尝试会生成一个新的nonce值. - get_txid(T) 从block B中通过交易序号来获取交易id - block_height 当前的区块高度 Hashimoto chooses transactions by doing the following: Hashimoto 通过下面的算法来挑选交易： &nbsp;&nbsp;&nbsp;&nbsp;hash_output_A = sha256(prev_hash, merkle_root, nonce) &nbsp;&nbsp;&nbsp;&nbsp;for i = 0 to 63 do &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shifted_A = hash_output_A &gt;&gt; i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transaction = shifted_A mod total_transactions &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txid[i] = get_txid(transaction) &lt;&lt; i &nbsp;&nbsp;&nbsp;&nbsp;end for &nbsp;&nbsp;&nbsp;&nbsp;txid_mix = txid[0] ⊕ txid[1] … ⊕ txid[63] &nbsp;&nbsp;&nbsp;&nbsp;final_output = txid_mix ⊕ (nonce &lt;&lt; 192) The target is then compared with final_output, and smaller values are accepted as proofs. 如果 final_output 比 target小，那么就会被接受。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多" />
<meta property="og:description" content="Hashimoto :I/O bound proof of work Abstract: Using a cryptographic hash function not as a proofofwork by itself, but rather as a generator of pointers to a shared data set, allows for an I/O bound proof of work. This method of proof of work is difficult to optimize via ASIC design, and difficult to outsource to nodes without the full data set. The name is based on the three operations which comprise the algorithm: hash, shift, and modulo. 摘要：使用密码散列函数本身并不作为工作的证明， 而是作为指向共享数据集的指针生成器，允许I / O绑定 工作证明。 这种工作证明方法很难通过ASIC设计来优化，并且在没有完整数据集的情况下很难外包给节点。 这个名字是基于构成算法的三个操作：散列，移位和 模。 The need for proofs which are difficult to outsource and optimize 工作量证明难以外包和优化的需求 A common challenge in cryptocurrency development is maintaining decentralization ofthe network. The use ofproofofwork to achieve decentralized consensus has been most notably demonstrated by Bitcoin, which uses partial collisions with zero ofsha256, similar to hashcash. As Bitcoin’s popularity has grown, dedicated hardware (currently application specific integrated circuits, or ASICs) has been produced to rapidly iterate the hash­based proofofwork function. Newer projects similar to Bitcoin often use different algorithms for proofofwork, and often with the goal ofASIC resistance. For algorithms such as Bitcoin’s, the improvement factor ofASICs means that commodity computer hardware can no longer be effectively used, potentially limiting adoption. 加密货币发展的一项挑战就是如何维持去中心化的网络结构。 正如比特币采用sha256哈希谜题的工作量证明方式来达到去中心化的一致性。 随着比特币的流行，专用硬件(目前的专用集成电路，或者是ASICs)已经被用来快速的执行基于hash方式的工作量证明函数。类似比特币的新项目通常使用不同的工作量证明算法，而且通常都有抵抗ASICs的目标。对于诸如比特币之类的算法，ASIC的对于性能的提升意味着普通的商业计算机硬件不再有效使用，可能会被限制采用。 Proofofwork can also be “outsourced”, or performed by a dedicated machine (a “miner”) without knowledge ofwhat is being verified. This is often the case in Bitcoin’s “mining pools”. It is also beneficial for a proofofwork algorithm to be difficult to outsource, in order to promote decentralization and encourage all nodes participating in the proofofwork process to also verify transactions. With these goals in mind, we present Hashimoto, an I/O bound proofofwork algorithm we believe to be resistant to both ASIC design and outsourcing. 工作量证明同样能够被外包出去，或者使用专用的机器(矿机)来执行工作量证明，而这些机器对于验证的内容并不清楚。比特币的“矿池”通常就是这种情况。如果工作量证明算法很难外包，以促进去中心化 并鼓励参与证明过程的所有节点也验证交易。为了达到这个目标，我们设计了hashimoti, 一个基于I/O 带宽的工作量证明算法，我们认为这个算法可以抵抗ASICs，同时也难以外包。 Initial attempts at &quot;ASIC resistance&quot; involved changing Bitcoin&#39;s sha256 algorithm for a different, more memory intensive algorithm, Percival&#39;s &quot;scrypt&quot; password based key derivation function1. Many implementations set the scrypt arguments to low memory requirements, defeating much ofthe purpose of the key derivation algorithm. While changing to a new algorithm, coupled with the relative obscurity of the various scrypt­based cryptocurrencies allowed for a delay, scrypt optimized ASICs are now available. Similar attempts at variations or multiple heterogeneous hash functions can at best only delay ASIC implementations. “ASIC抗性”的初始尝试包括改变比特币的sha256算法，用不同的，更多的内存密集型算法，Percival&#39;s &quot;scrypt&quot; password based key derivation function。许多实现都将脚本参数设置为低内存要求，这大大破坏了密钥派生算法的目的。在改用新算法的同时，再加上各种以scrypt为基础的加密货币的相对朦胧可能导致延迟，而且scrypt优化的ASIC现在已经上市。类似的变化尝试或多个异构散列函数最多只能延迟ASIC实现。 Leveraging shared data sets to create I/O bound proofs 利用共享数据集创建I / O限制证明 &nbsp;&nbsp;&nbsp;&nbsp;&quot;A supercomputer is a device for turning compute-bound problems into I/O-bound problems.&quot; &nbsp;&nbsp;&nbsp;&nbsp;-Ken Batcher &nbsp;&nbsp;&nbsp;&nbsp;“超级计算机是将计算受限问题转化为I / O约束问题的一种设备。” &nbsp;&nbsp;&nbsp;&nbsp;Ken Batcher Instead, an algorithm will have little room to be sped up by new hardware if it acts in a way that commodity computer systems are already optimized for. 相反，如果一种算法以商品计算机系统已经优化的方式运行，那么算法将没有多少空间可以被新硬件加速。 Since I/O bounds are what decades ofcomputing research has gone towards solving, it&#39;s unlikely that the relatively small motivation ofmining a few coins would be able to advance the state ofthe art in cache hierarchies. In the case that advances are made, they will be likely to impact the entire industry of computer hardware. 由于I / O界限是几十年来计算研究已经解决的问题，挖掘一些加密货币的相对较小的动机将不可能提高缓存层次结构的艺术水平。 在取得进展的情况下，可能会影响整个计算机硬件产业。 Fortuitously, all nodes participating in current implementations ofcryptocurrency have a large set of mutually agreed upon data; indeed this “blockchain” is the foundation ofthe currency. Using this large data set can both limit the advantage ofspecialized hardware, and require working nodes to have the entire data set. 幸运的是，参与当前加密货币实施的所有节点都有大量相互同意的数据;实际上，“区块链”是货币的基础。 使用这个大数据集既可以限制专用硬件的优点，又可以让工作节点拥有整个数据集。 Hashimoto is based offBitcoin’s proofofwork2. In Bitcoin’s case, as in Hashimoto, a successful proofsatisfies the following inequality: Hashimoto是基于比特币的工作量证明。 在比特币的情况下，和Hashimoto一样，一个成功的证明满足以下不等式： &nbsp;&nbsp;&nbsp;&nbsp;hash_output &lt; target For bitcoin, the hash_output is determined by 在比特币中， hash_output是由下面决定的。 &nbsp;&nbsp;&nbsp;&nbsp;hash_output = sha256(prev_hash, merkle_root, nonce) where prev_hash is the previous block’s hash and cannot be changed. The merkle_root is based on the transactions included in the block, and will be different for each individual node. The nonce is rapidly incremented as hash_outputs are calculated and do not satisfy the inequality. Thus the bottleneck of the proofis the sha256 function, and increasing the speed ofsha256 or parallelizing it is something ASICs can do very effectively. prev_hash是前一个区块的hash值，而且不能更改。merkle_root是基于区块中的交易生成的，并且对于每个单独的节点将是不同的。我们通过修改nonce的值来让上面的不等式成立。这样整个工作量证明的瓶颈在于sha256方法，而且通过ASIC可以极大增加sha256的计算速度，或者并行的运行它。 Hashimoto uses this hash output as a starting point, which is used to generated inputs for a second hash function. We call the original hash hash_output_A, and the final result of the prooffinal_output. Hashimoto使用这个hash_output作为一个起点，用来生成第二个hash函数的输入。我们称原始的hash为hash_output_A, 最终的结果为 prooffinal_output. Hash_output_A can be used to select many transactions from the shared blockchain, which are then used as inputs to the second hash. Instead of organizing transactions into blocks, for this purpose it is simpler to organize all transactions sequentially. For example, the 47th transaction of the 815th block might be termed transaction 141,918. We will use 64 transactions, though higher and lower numbers could work, with different access properties. We define the following functions: hash_output_a可用于从共享区块链中选择多个事务，然后将其用作第二个散列的输入。 而不是组织交易成块，为此目的是顺序组织所有交易更简单。 例如，第815个区块的第47个交易可能被称为交易141,918。 我们将使用64个交易，尽管更高和更低的数字可以工作，具有不同的访问属性。 我们定义以下功能： - nonce 64­bits. A new nonce is created for each attempt. - get_txid(T) return the txid (a hash ofa transaction) of transaction number T from block B. - block_height the current height ofthe block chain, which increases at each new block - nonce 64­bits. 每次尝试会生成一个新的nonce值. - get_txid(T) 从block B中通过交易序号来获取交易id - block_height 当前的区块高度 Hashimoto chooses transactions by doing the following: Hashimoto 通过下面的算法来挑选交易： &nbsp;&nbsp;&nbsp;&nbsp;hash_output_A = sha256(prev_hash, merkle_root, nonce) &nbsp;&nbsp;&nbsp;&nbsp;for i = 0 to 63 do &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shifted_A = hash_output_A &gt;&gt; i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transaction = shifted_A mod total_transactions &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txid[i] = get_txid(transaction) &lt;&lt; i &nbsp;&nbsp;&nbsp;&nbsp;end for &nbsp;&nbsp;&nbsp;&nbsp;txid_mix = txid[0] ⊕ txid[1] … ⊕ txid[63] &nbsp;&nbsp;&nbsp;&nbsp;final_output = txid_mix ⊕ (nonce &lt;&lt; 192) The target is then compared with final_output, and smaller values are accepted as proofs. 如果 final_output 比 target小，那么就会被接受。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-14T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Hashimoto :I/O bound proof of work Abstract: Using a cryptographic hash function not as a proofofwork by itself, but rather as a generator of pointers to a shared data set, allows for an I/O bound proof of work. This method of proof of work is difficult to optimize via ASIC design, and difficult to outsource to nodes without the full data set. The name is based on the three operations which comprise the algorithm: hash, shift, and modulo. 摘要：使用密码散列函数本身并不作为工作的证明， 而是作为指向共享数据集的指针生成器，允许I / O绑定 工作证明。 这种工作证明方法很难通过ASIC设计来优化，并且在没有完整数据集的情况下很难外包给节点。 这个名字是基于构成算法的三个操作：散列，移位和 模。 The need for proofs which are difficult to outsource and optimize 工作量证明难以外包和优化的需求 A common challenge in cryptocurrency development is maintaining decentralization ofthe network. The use ofproofofwork to achieve decentralized consensus has been most notably demonstrated by Bitcoin, which uses partial collisions with zero ofsha256, similar to hashcash. As Bitcoin’s popularity has grown, dedicated hardware (currently application specific integrated circuits, or ASICs) has been produced to rapidly iterate the hash­based proofofwork function. Newer projects similar to Bitcoin often use different algorithms for proofofwork, and often with the goal ofASIC resistance. For algorithms such as Bitcoin’s, the improvement factor ofASICs means that commodity computer hardware can no longer be effectively used, potentially limiting adoption. 加密货币发展的一项挑战就是如何维持去中心化的网络结构。 正如比特币采用sha256哈希谜题的工作量证明方式来达到去中心化的一致性。 随着比特币的流行，专用硬件(目前的专用集成电路，或者是ASICs)已经被用来快速的执行基于hash方式的工作量证明函数。类似比特币的新项目通常使用不同的工作量证明算法，而且通常都有抵抗ASICs的目标。对于诸如比特币之类的算法，ASIC的对于性能的提升意味着普通的商业计算机硬件不再有效使用，可能会被限制采用。 Proofofwork can also be “outsourced”, or performed by a dedicated machine (a “miner”) without knowledge ofwhat is being verified. This is often the case in Bitcoin’s “mining pools”. It is also beneficial for a proofofwork algorithm to be difficult to outsource, in order to promote decentralization and encourage all nodes participating in the proofofwork process to also verify transactions. With these goals in mind, we present Hashimoto, an I/O bound proofofwork algorithm we believe to be resistant to both ASIC design and outsourcing. 工作量证明同样能够被外包出去，或者使用专用的机器(矿机)来执行工作量证明，而这些机器对于验证的内容并不清楚。比特币的“矿池”通常就是这种情况。如果工作量证明算法很难外包，以促进去中心化 并鼓励参与证明过程的所有节点也验证交易。为了达到这个目标，我们设计了hashimoti, 一个基于I/O 带宽的工作量证明算法，我们认为这个算法可以抵抗ASICs，同时也难以外包。 Initial attempts at &quot;ASIC resistance&quot; involved changing Bitcoin&#39;s sha256 algorithm for a different, more memory intensive algorithm, Percival&#39;s &quot;scrypt&quot; password based key derivation function1. Many implementations set the scrypt arguments to low memory requirements, defeating much ofthe purpose of the key derivation algorithm. While changing to a new algorithm, coupled with the relative obscurity of the various scrypt­based cryptocurrencies allowed for a delay, scrypt optimized ASICs are now available. Similar attempts at variations or multiple heterogeneous hash functions can at best only delay ASIC implementations. “ASIC抗性”的初始尝试包括改变比特币的sha256算法，用不同的，更多的内存密集型算法，Percival&#39;s &quot;scrypt&quot; password based key derivation function。许多实现都将脚本参数设置为低内存要求，这大大破坏了密钥派生算法的目的。在改用新算法的同时，再加上各种以scrypt为基础的加密货币的相对朦胧可能导致延迟，而且scrypt优化的ASIC现在已经上市。类似的变化尝试或多个异构散列函数最多只能延迟ASIC实现。 Leveraging shared data sets to create I/O bound proofs 利用共享数据集创建I / O限制证明 &nbsp;&nbsp;&nbsp;&nbsp;&quot;A supercomputer is a device for turning compute-bound problems into I/O-bound problems.&quot; &nbsp;&nbsp;&nbsp;&nbsp;-Ken Batcher &nbsp;&nbsp;&nbsp;&nbsp;“超级计算机是将计算受限问题转化为I / O约束问题的一种设备。” &nbsp;&nbsp;&nbsp;&nbsp;Ken Batcher Instead, an algorithm will have little room to be sped up by new hardware if it acts in a way that commodity computer systems are already optimized for. 相反，如果一种算法以商品计算机系统已经优化的方式运行，那么算法将没有多少空间可以被新硬件加速。 Since I/O bounds are what decades ofcomputing research has gone towards solving, it&#39;s unlikely that the relatively small motivation ofmining a few coins would be able to advance the state ofthe art in cache hierarchies. In the case that advances are made, they will be likely to impact the entire industry of computer hardware. 由于I / O界限是几十年来计算研究已经解决的问题，挖掘一些加密货币的相对较小的动机将不可能提高缓存层次结构的艺术水平。 在取得进展的情况下，可能会影响整个计算机硬件产业。 Fortuitously, all nodes participating in current implementations ofcryptocurrency have a large set of mutually agreed upon data; indeed this “blockchain” is the foundation ofthe currency. Using this large data set can both limit the advantage ofspecialized hardware, and require working nodes to have the entire data set. 幸运的是，参与当前加密货币实施的所有节点都有大量相互同意的数据;实际上，“区块链”是货币的基础。 使用这个大数据集既可以限制专用硬件的优点，又可以让工作节点拥有整个数据集。 Hashimoto is based offBitcoin’s proofofwork2. In Bitcoin’s case, as in Hashimoto, a successful proofsatisfies the following inequality: Hashimoto是基于比特币的工作量证明。 在比特币的情况下，和Hashimoto一样，一个成功的证明满足以下不等式： &nbsp;&nbsp;&nbsp;&nbsp;hash_output &lt; target For bitcoin, the hash_output is determined by 在比特币中， hash_output是由下面决定的。 &nbsp;&nbsp;&nbsp;&nbsp;hash_output = sha256(prev_hash, merkle_root, nonce) where prev_hash is the previous block’s hash and cannot be changed. The merkle_root is based on the transactions included in the block, and will be different for each individual node. The nonce is rapidly incremented as hash_outputs are calculated and do not satisfy the inequality. Thus the bottleneck of the proofis the sha256 function, and increasing the speed ofsha256 or parallelizing it is something ASICs can do very effectively. prev_hash是前一个区块的hash值，而且不能更改。merkle_root是基于区块中的交易生成的，并且对于每个单独的节点将是不同的。我们通过修改nonce的值来让上面的不等式成立。这样整个工作量证明的瓶颈在于sha256方法，而且通过ASIC可以极大增加sha256的计算速度，或者并行的运行它。 Hashimoto uses this hash output as a starting point, which is used to generated inputs for a second hash function. We call the original hash hash_output_A, and the final result of the prooffinal_output. Hashimoto使用这个hash_output作为一个起点，用来生成第二个hash函数的输入。我们称原始的hash为hash_output_A, 最终的结果为 prooffinal_output. Hash_output_A can be used to select many transactions from the shared blockchain, which are then used as inputs to the second hash. Instead of organizing transactions into blocks, for this purpose it is simpler to organize all transactions sequentially. For example, the 47th transaction of the 815th block might be termed transaction 141,918. We will use 64 transactions, though higher and lower numbers could work, with different access properties. We define the following functions: hash_output_a可用于从共享区块链中选择多个事务，然后将其用作第二个散列的输入。 而不是组织交易成块，为此目的是顺序组织所有交易更简单。 例如，第815个区块的第47个交易可能被称为交易141,918。 我们将使用64个交易，尽管更高和更低的数字可以工作，具有不同的访问属性。 我们定义以下功能： - nonce 64­bits. A new nonce is created for each attempt. - get_txid(T) return the txid (a hash ofa transaction) of transaction number T from block B. - block_height the current height ofthe block chain, which increases at each new block - nonce 64­bits. 每次尝试会生成一个新的nonce值. - get_txid(T) 从block B中通过交易序号来获取交易id - block_height 当前的区块高度 Hashimoto chooses transactions by doing the following: Hashimoto 通过下面的算法来挑选交易： &nbsp;&nbsp;&nbsp;&nbsp;hash_output_A = sha256(prev_hash, merkle_root, nonce) &nbsp;&nbsp;&nbsp;&nbsp;for i = 0 to 63 do &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shifted_A = hash_output_A &gt;&gt; i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transaction = shifted_A mod total_transactions &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txid[i] = get_txid(transaction) &lt;&lt; i &nbsp;&nbsp;&nbsp;&nbsp;end for &nbsp;&nbsp;&nbsp;&nbsp;txid_mix = txid[0] ⊕ txid[1] … ⊕ txid[63] &nbsp;&nbsp;&nbsp;&nbsp;final_output = txid_mix ⊕ (nonce &lt;&lt; 192) The target is then compared with final_output, and smaller values are accepted as proofs. 如果 final_output 比 target小，那么就会被接受。 网址：http://www.qukuailianxueyuan.io/ 欲领取造币技术与全套虚拟机资料 区块链技术交流QQ群：756146052&nbsp;&nbsp;备注：CSDN 尹成学院微信：备注：CSDN 阅读更多","@type":"BlogPosting","url":"/2018/05/14/f0b176a3bbaedcbb7d95779ed06e38ba.html","headline":"以太坊源码分析(41）hashimoto源码分析","dateModified":"2018-05-14T00:00:00+08:00","datePublished":"2018-05-14T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/05/14/f0b176a3bbaedcbb7d95779ed06e38ba.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊源码分析(41）hashimoto源码分析</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas, 'Courier New', monospace;font-size:14px;line-height:19px;">
   <div>
    Hashimoto :I/O bound proof of work
   </div>
   <br>
   <br>
   <div>
    Abstract: Using a cryptographic hash function not as a proofofwork by itself, but
   </div>
   <div>
    rather as a generator of pointers to a shared data set, allows for an I/O bound
   </div>
   <div>
    proof of work. This method of proof of work is difficult to optimize via ASIC
   </div>
   <div>
    design, and difficult to outsource to nodes without the full data set. The name is
   </div>
   <div>
    based on the three operations which comprise the algorithm: hash, shift, and
   </div>
   <div>
    modulo.
   </div>
   <br>
   <div>
    摘要：使用密码散列函数本身并不作为工作的证明，
   </div>
   <div>
    而是作为指向共享数据集的指针生成器，允许I / O绑定
   </div>
   <div>
    工作证明。 这种工作证明方法很难通过ASIC设计来优化，并且在没有完整数据集的情况下很难外包给节点。 这个名字是基于构成算法的三个操作：散列，移位和
   </div>
   <div>
    模。
   </div>
   <br>
   <br>
   <div>
    The need for proofs which are difficult to outsource and optimize
   </div>
   <br>
   <div>
    工作量证明难以外包和优化的需求
   </div>
   <br>
   <div>
    A common challenge in cryptocurrency development is maintaining decentralization ofthe
   </div>
   <div>
    network. The use ofproofofwork to achieve decentralized consensus has been most notably
   </div>
   <div>
    demonstrated by Bitcoin, which uses partial collisions with zero ofsha256, similar to hashcash. As
   </div>
   <div>
    Bitcoin’s popularity has grown, dedicated hardware (currently application specific integrated circuits, or
   </div>
   <div>
    ASICs) has been produced to rapidly iterate the hash­based proofofwork function. Newer projects
   </div>
   <div>
    similar to Bitcoin often use different algorithms for proofofwork, and often with the goal ofASIC
   </div>
   <div>
    resistance. For algorithms such as Bitcoin’s, the improvement factor ofASICs means that commodity
   </div>
   <div>
    computer hardware can no longer be effectively used, potentially limiting adoption.
   </div>
   <br>
   <div>
    加密货币发展的一项挑战就是如何维持去中心化的网络结构。 正如比特币采用sha256哈希谜题的工作量证明方式来达到去中心化的一致性。 随着比特币的流行，专用硬件(目前的专用集成电路，或者是ASICs)已经被用来快速的执行基于hash方式的工作量证明函数。类似比特币的新项目通常使用不同的工作量证明算法，而且通常都有抵抗ASICs的目标。对于诸如比特币之类的算法，ASIC的对于性能的提升意味着普通的商业计算机硬件不再有效使用，可能会被限制采用。
   </div>
   <br>
   <div>
    Proofofwork can also be “outsourced”, or performed by a dedicated machine (a “miner”)
   </div>
   <div>
    without knowledge ofwhat is being verified. This is often the case in Bitcoin’s “mining pools”. It is also
   </div>
   <div>
    beneficial for a proofofwork algorithm to be difficult to outsource, in order to promote decentralization
   </div>
   <div>
    and encourage all nodes participating in the proofofwork process to also verify transactions. With these
   </div>
   <div>
    goals in mind, we present Hashimoto, an I/O bound proofofwork algorithm we believe to be resistant to
   </div>
   <div>
    both ASIC design and outsourcing.
   </div>
   <br>
   <div>
    工作量证明同样能够被外包出去，或者使用专用的机器(矿机)来执行工作量证明，而这些机器对于验证的内容并不清楚。比特币的“矿池”通常就是这种情况。如果工作量证明算法很难外包，以促进去中心化
   </div>
   <div>
    并鼓励参与证明过程的所有节点也验证交易。为了达到这个目标，我们设计了hashimoti, 一个基于I/O 带宽的工作量证明算法，我们认为这个算法可以抵抗ASICs，同时也难以外包。
   </div>
   <br>
   <div>
    Initial attempts at "ASIC resistance" involved changing Bitcoin's sha256 algorithm for a different,
   </div>
   <div>
    more memory intensive algorithm, Percival's "scrypt" password based key derivation function1. Many
   </div>
   <div>
    implementations set the scrypt arguments to low memory requirements, defeating much ofthe purpose of
   </div>
   <div>
    the key derivation algorithm. While changing to a new algorithm, coupled with the relative obscurity of the
   </div>
   <div>
    various scrypt­based cryptocurrencies allowed for a delay, scrypt optimized ASICs are now available.
   </div>
   <div>
    Similar attempts at variations or multiple heterogeneous hash functions can at best only delay ASIC
   </div>
   <div>
    implementations.
   </div>
   <br>
   <div>
    “ASIC抗性”的初始尝试包括改变比特币的sha256算法，用不同的，更多的内存密集型算法，Percival's "scrypt" password based key derivation function。许多实现都将脚本参数设置为低内存要求，这大大破坏了密钥派生算法的目的。在改用新算法的同时，再加上各种以scrypt为基础的加密货币的相对朦胧可能导致延迟，而且scrypt优化的ASIC现在已经上市。类似的变化尝试或多个异构散列函数最多只能延迟ASIC实现。
   </div>
   <br>
   <div>
    Leveraging shared data sets to create I/O bound proofs
   </div>
   <br>
   <div>
    利用共享数据集创建I / O限制证明
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;"A supercomputer is a device for turning compute-bound problems into I/O-bound problems."
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;-Ken Batcher
   </div>
   <br>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;“超级计算机是将计算受限问题转化为I / O约束问题的一种设备。”
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Ken Batcher
   </div>
   <br>
   <div>
    Instead, an algorithm will have little room to be sped up by new hardware if it acts in a way that commodity computer systems are already optimized for.
   </div>
   <br>
   <div>
    相反，如果一种算法以商品计算机系统已经优化的方式运行，那么算法将没有多少空间可以被新硬件加速。
   </div>
   <br>
   <div>
    Since I/O bounds are what decades ofcomputing research has gone towards solving, it's unlikely that the relatively small motivation ofmining a few coins would be able to advance the state ofthe art in cache hierarchies. In the case that advances are made, they will be likely to impact the entire industry of computer hardware.
   </div>
   <br>
   <div>
    由于I / O界限是几十年来计算研究已经解决的问题，挖掘一些加密货币的相对较小的动机将不可能提高缓存层次结构的艺术水平。 在取得进展的情况下，可能会影响整个计算机硬件产业。
   </div>
   <br>
   <div>
    Fortuitously, all nodes participating in current implementations ofcryptocurrency have a large set of mutually agreed upon data; indeed this “blockchain” is the foundation ofthe currency. Using this large data set can both limit the advantage ofspecialized hardware, and require working nodes to have the entire data set.
   </div>
   <br>
   <div>
    幸运的是，参与当前加密货币实施的所有节点都有大量相互同意的数据;实际上，“区块链”是货币的基础。 使用这个大数据集既可以限制专用硬件的优点，又可以让工作节点拥有整个数据集。
   </div>
   <br>
   <div>
    Hashimoto is based offBitcoin’s proofofwork2. In Bitcoin’s case, as in Hashimoto, a successful
   </div>
   <div>
    proofsatisfies the following inequality:
   </div>
   <br>
   <div>
    Hashimoto是基于比特币的工作量证明。 在比特币的情况下，和Hashimoto一样，一个成功的证明满足以下不等式：
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;hash_output &lt; target
   </div>
   <br>
   <div>
    For bitcoin, the hash_output is determined by
   </div>
   <br>
   <div>
    在比特币中， hash_output是由下面决定的。
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;hash_output = sha256(prev_hash, merkle_root, nonce)
   </div>
   <br>
   <div>
    where prev_hash is the previous block’s hash and cannot be changed. The merkle_root is based on the transactions included in the block, and will be different for each individual node. The nonce is rapidly incremented as hash_outputs are calculated and do not satisfy the inequality. Thus the bottleneck of the proofis the sha256 function, and increasing the speed ofsha256 or parallelizing it is something ASICs can do very effectively.
   </div>
   <br>
   <div>
    prev_hash是前一个区块的hash值，而且不能更改。merkle_root是基于区块中的交易生成的，并且对于每个单独的节点将是不同的。我们通过修改nonce的值来让上面的不等式成立。这样整个工作量证明的瓶颈在于sha256方法，而且通过ASIC可以极大增加sha256的计算速度，或者并行的运行它。
   </div>
   <br>
   <div>
    Hashimoto uses this hash output as a starting point, which is used to generated inputs for a second hash function. We call the original hash hash_output_A, and the final result of the prooffinal_output.
   </div>
   <br>
   <div>
    Hashimoto使用这个hash_output作为一个起点，用来生成第二个hash函数的输入。我们称原始的hash为hash_output_A, 最终的结果为 prooffinal_output.
   </div>
   <br>
   <div>
    Hash_output_A can be used to select many transactions from the shared blockchain, which are then used as inputs to the second hash. Instead of organizing transactions into blocks, for this purpose it is simpler to organize all transactions sequentially. For example, the 47th transaction of the 815th block might be termed transaction 141,918. We will use 64 transactions, though higher and lower numbers could work, with different access properties. We define the following functions:
   </div>
   <br>
   <div>
    hash_output_a可用于从共享区块链中选择多个事务，然后将其用作第二个散列的输入。 而不是组织交易成块，为此目的是顺序组织所有交易更简单。 例如，第815个区块的第47个交易可能被称为交易141,918。 我们将使用64个交易，尽管更高和更低的数字可以工作，具有不同的访问属性。 我们定义以下功能：
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> nonce 64­bits. A new nonce is created for each attempt.
   </div>
   <div>
    <span style="color:#6796e6;">-</span> get_txid(T) return the txid (a hash ofa transaction) of transaction number T from block B.
   </div>
   <div>
    <span style="color:#6796e6;">-</span> block_height the current height ofthe block chain, which increases at each new block
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">-</span> nonce 64­bits. 每次尝试会生成一个新的nonce值.
   </div>
   <div>
    <span style="color:#6796e6;">-</span> get_txid(T) 从block B中通过交易序号来获取交易id
   </div>
   <div>
    <span style="color:#6796e6;">-</span> block_height 当前的区块高度
   </div>
   <br>
   <div>
    Hashimoto chooses transactions by doing the following:
   </div>
   <br>
   <div>
    Hashimoto 通过下面的算法来挑选交易：
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;hash_output_A = sha256(prev_hash, merkle_root, nonce)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;for i = 0 to 63 do
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shifted_A = hash_output_A &gt;&gt; i
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transaction = shifted_A mod total_transactions
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txid[i] = get_txid(transaction) &lt;&lt; i
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;end for
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;txid_mix = txid[0] ⊕ txid[1] … ⊕ txid[63]
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;final_output = txid_mix ⊕ (nonce &lt;&lt; 192)
   </div>
   <br>
   <div>
    The target is then compared with final_output, and smaller values are accepted as proofs.
   </div>
   <br>
   <p>如果 final_output 比 target小，那么就会被接受。</p>
   <p></p>
   <h2 style="font-family:Consolas, 'Courier New', monospace;"><img src="https://img-blog.csdn.net/20180430224554793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><br></h2>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;"><img src="https://img-blog.csdn.net/20180425001235188?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><img src="https://img-blog.csdn.net/20180425001144107?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;">网址：http://www.qukuailianxueyuan.io/<br></p>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;"><img src="https://img-blog.csdn.net/20180426145827720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;"><img src="https://img-blog.csdn.net/2018042614570887?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;">欲领取造币技术与全套虚拟机资料</p>
   <p style="font-family:Consolas, 'Courier New', monospace;"><span style="color:rgb(25,25,25);">区块链技术交流QQ群：</span><span style="color:rgb(255,0,0);background-color:rgb(255,255,255);">756146052&nbsp;&nbsp;</span><span style="color:rgb(25,25,25);">备注：CSDN</span></p>
   <p style="color:rgb(25,25,25);font-family:Consolas, 'Courier New', monospace;">尹成学院微信：备注：CSDN</p>
   <p style="color:rgb(25,25,25);text-align:center;font-family:Consolas, 'Courier New', monospace;"><img src="https://img-blog.csdn.net/20180425000635656?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbmNoZW5nMDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
   <div>
    <br>
   </div>
   <br>
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/itcastcpp/article/details/80305509,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/itcastcpp/article/details/80305509,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
