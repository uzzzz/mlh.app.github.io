<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>干货：手把手教你发行属于自己的区块链Token | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="干货：手把手教你发行属于自己的区块链Token" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="预先准备 以太坊钱包 一定数量的eth余额 MetaMask Token的参数 在发行之前首先要考虑Token的参数，譬如这篇教程准备发行如下Token Token的名称：Dylan Token Token的标识：DT 发行量：19940512 Token的小数位：18 编写合约 想要基于以太坊拥有自己的Token，需要通过智能合约的形式去发行，编写如下基于ERC20的solidity代码： pragma solidity ^0.4.18; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b &lt;= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c &gt;= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address =&gt; uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[_from]); require(_value &lt;= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue &gt; oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Token is StandardToken { string public name = &quot;Dylan Token&quot;; string public symbol = &quot;DT&quot;; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 19940512; function Token() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; } } 需要修改Token的名字name、标识symbol、发行量INITIAL_SUPPLY和小数位decimals的，直接在合约Token中修改相应的变量即可。 编译部署合约 打开Remix-Solidity IDE，一种在线的Solidity IDE。 将上述的三个合约代码导入至Remix中，点击start to compile进行编译。 编译完成后切换到Run，下拉框选择Token，点击Deploy进行部署 之后会弹出确认transaction的面板，拖到最下面点击confirm MetaMask会弹出，确认交易，点击submit 稍等片刻，交易被确认，会出现下图红框所示的合约地址，复制到剪贴板 教程中Dylan Token合约地址为：0x89731a2ddcef82a268d8925327c4080229914f05 再进入MetaMask，点击Tokens——AddToken，粘贴复制的合约地址，点击Add 就可以在自己的钱包中看到刚刚发行的Token了 认证合约代码 注意：此步骤需科学上网，不然提交之前的验证码显示出不来。 在以太坊区块浏览器中找到自己的合约地址，点击Contract code——Verify and Publish，如下图所示 在Contract name:的输入框输入部署的合约名称Token, Compiler 选择在remix的sttings 中Solidity version 显示的版本号。Optimization 选择 No。 然后在Enter the Solidity Contract Code below 下面的输入框中原样填入Remix中的代码 完成后点击提交，如果通过验证，跳转之后会显示如下图红框内所示的successfully的字样 至此Token发行教程完结。 阅读更多" />
<meta property="og:description" content="预先准备 以太坊钱包 一定数量的eth余额 MetaMask Token的参数 在发行之前首先要考虑Token的参数，譬如这篇教程准备发行如下Token Token的名称：Dylan Token Token的标识：DT 发行量：19940512 Token的小数位：18 编写合约 想要基于以太坊拥有自己的Token，需要通过智能合约的形式去发行，编写如下基于ERC20的solidity代码： pragma solidity ^0.4.18; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b &lt;= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c &gt;= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address =&gt; uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[_from]); require(_value &lt;= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue &gt; oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Token is StandardToken { string public name = &quot;Dylan Token&quot;; string public symbol = &quot;DT&quot;; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 19940512; function Token() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; } } 需要修改Token的名字name、标识symbol、发行量INITIAL_SUPPLY和小数位decimals的，直接在合约Token中修改相应的变量即可。 编译部署合约 打开Remix-Solidity IDE，一种在线的Solidity IDE。 将上述的三个合约代码导入至Remix中，点击start to compile进行编译。 编译完成后切换到Run，下拉框选择Token，点击Deploy进行部署 之后会弹出确认transaction的面板，拖到最下面点击confirm MetaMask会弹出，确认交易，点击submit 稍等片刻，交易被确认，会出现下图红框所示的合约地址，复制到剪贴板 教程中Dylan Token合约地址为：0x89731a2ddcef82a268d8925327c4080229914f05 再进入MetaMask，点击Tokens——AddToken，粘贴复制的合约地址，点击Add 就可以在自己的钱包中看到刚刚发行的Token了 认证合约代码 注意：此步骤需科学上网，不然提交之前的验证码显示出不来。 在以太坊区块浏览器中找到自己的合约地址，点击Contract code——Verify and Publish，如下图所示 在Contract name:的输入框输入部署的合约名称Token, Compiler 选择在remix的sttings 中Solidity version 显示的版本号。Optimization 选择 No。 然后在Enter the Solidity Contract Code below 下面的输入框中原样填入Remix中的代码 完成后点击提交，如果通过验证，跳转之后会显示如下图红框内所示的successfully的字样 至此Token发行教程完结。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/05/14/77fcfe1017c805c41b466057ca293015.html" />
<meta property="og:url" content="https://mlh.app/2018/05/14/77fcfe1017c805c41b466057ca293015.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-14T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"预先准备 以太坊钱包 一定数量的eth余额 MetaMask Token的参数 在发行之前首先要考虑Token的参数，譬如这篇教程准备发行如下Token Token的名称：Dylan Token Token的标识：DT 发行量：19940512 Token的小数位：18 编写合约 想要基于以太坊拥有自己的Token，需要通过智能合约的形式去发行，编写如下基于ERC20的solidity代码： pragma solidity ^0.4.18; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b &lt;= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c &gt;= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address =&gt; uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value &lt;= balances[_from]); require(_value &lt;= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue &gt; oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Token is StandardToken { string public name = &quot;Dylan Token&quot;; string public symbol = &quot;DT&quot;; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 19940512; function Token() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; } } 需要修改Token的名字name、标识symbol、发行量INITIAL_SUPPLY和小数位decimals的，直接在合约Token中修改相应的变量即可。 编译部署合约 打开Remix-Solidity IDE，一种在线的Solidity IDE。 将上述的三个合约代码导入至Remix中，点击start to compile进行编译。 编译完成后切换到Run，下拉框选择Token，点击Deploy进行部署 之后会弹出确认transaction的面板，拖到最下面点击confirm MetaMask会弹出，确认交易，点击submit 稍等片刻，交易被确认，会出现下图红框所示的合约地址，复制到剪贴板 教程中Dylan Token合约地址为：0x89731a2ddcef82a268d8925327c4080229914f05 再进入MetaMask，点击Tokens——AddToken，粘贴复制的合约地址，点击Add 就可以在自己的钱包中看到刚刚发行的Token了 认证合约代码 注意：此步骤需科学上网，不然提交之前的验证码显示出不来。 在以太坊区块浏览器中找到自己的合约地址，点击Contract code——Verify and Publish，如下图所示 在Contract name:的输入框输入部署的合约名称Token, Compiler 选择在remix的sttings 中Solidity version 显示的版本号。Optimization 选择 No。 然后在Enter the Solidity Contract Code below 下面的输入框中原样填入Remix中的代码 完成后点击提交，如果通过验证，跳转之后会显示如下图红框内所示的successfully的字样 至此Token发行教程完结。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/05/14/77fcfe1017c805c41b466057ca293015.html","headline":"干货：手把手教你发行属于自己的区块链Token","dateModified":"2018-05-14T00:00:00+08:00","datePublished":"2018-05-14T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/05/14/77fcfe1017c805c41b466057ca293015.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>干货：手把手教你发行属于自己的区块链Token</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="预先准备">预先准备</h1> 
  <ul> 
   <li><a href="https://www.myetherwallet.com/" rel="nofollow" target="_blank">以太坊钱包</a></li> 
   <li>一定数量的eth余额</li> 
   <li><a href="https://metamask.io/" rel="nofollow" target="_blank">MetaMask</a></li> 
  </ul> 
  <h1 id="token的参数">Token的参数</h1> 
  <p>在发行之前首先要考虑Token的参数，譬如这篇教程准备发行如下Token</p> 
  <ul> 
   <li>Token的名称：<strong>Dylan Token</strong></li> 
   <li>Token的标识：<strong>DT</strong></li> 
   <li>发行量：<strong>19940512</strong></li> 
   <li>Token的小数位：<strong>18</strong></li> 
  </ul> 
  <h1 id="编写合约">编写合约</h1> 
  <p>想要基于以太坊拥有自己的<strong>Token</strong>，需要通过智能合约的形式去发行，编写如下基于<strong>ERC20</strong>的<strong>solidity</strong>代码：</p> 
  <pre class="prettyprint"><code class=" hljs java">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.18</span>;

library SafeMath {

  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> Multiplies two numbers, throws on overflow. */</span>
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    uint256 c = a * b;
    <span class="hljs-keyword">assert</span>(c / a == b);
    <span class="hljs-keyword">return</span> c;
  }

  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> Integer division of two numbers, truncating the quotient. */</span>
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    <span class="hljs-comment">// assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span>
    uint256 c = a / b;
    <span class="hljs-comment">// assert(a == b * c + a % b); // There is no case in which this doesn't hold</span>
    <span class="hljs-keyword">return</span> c;
  }

  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */</span>
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    <span class="hljs-keyword">assert</span>(b &lt;= a);
    <span class="hljs-keyword">return</span> a - b;
  }

  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> Adds two numbers, throws on overflow. */</span>
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    <span class="hljs-keyword">assert</span>(c &gt;= a);
    <span class="hljs-keyword">return</span> c;
  }
}

contract ERC20Basic {
  function totalSupply() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (uint256);
  function balanceOf(address who) <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (uint256);
  function transfer(address to, uint256 value) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

contract BasicToken is ERC20Basic {
  using SafeMath <span class="hljs-keyword">for</span> uint256;

  mapping(address =&gt; uint256) balances;

  uint256 totalSupply_;

  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> total number of tokens in existence */</span>
  function totalSupply() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (uint256) {
    <span class="hljs-keyword">return</span> totalSupply_;
  }

  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> transfer token for a specified address *<span class="hljs-javadoctag"> @param</span> _to The address to transfer to. *<span class="hljs-javadoctag"> @param</span> _value The amount to be transferred. */</span>
  function transfer(address _to, uint256 _value) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (bool) {
    require(_to != address(<span class="hljs-number">0</span>));
    require(_value &lt;= balances[msg.sender]);

    <span class="hljs-comment">// SafeMath.sub will throw if there is not enough balance.</span>
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  }

  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> Gets the balance of the specified address. *<span class="hljs-javadoctag"> @param</span> _owner The address to query the the balance of. *<span class="hljs-javadoctag"> @return</span> An uint256 representing the amount owned by the passed address. */</span>
  function balanceOf(address _owner) <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (uint256 balance) {
    <span class="hljs-keyword">return</span> balances[_owner];
  }

}

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (uint256);
  function transferFrom(address from, address to, uint256 value) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (bool);
  function approve(address spender, uint256 value) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract StandardToken is ERC20, BasicToken {

  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;


  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> Transfer tokens from one address to another *<span class="hljs-javadoctag"> @param</span> _from address The address which you want to send tokens from *<span class="hljs-javadoctag"> @param</span> _to address The address which you want to transfer to *<span class="hljs-javadoctag"> @param</span> _value uint256 the amount of tokens to be transferred */</span>
  function transferFrom(address _from, address _to, uint256 _value) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (bool) {
    require(_to != address(<span class="hljs-number">0</span>));
    require(_value &lt;= balances[_from]);
    require(_value &lt;= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  }

  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 *<span class="hljs-javadoctag"> @param</span> _spender The address which will spend the funds. *<span class="hljs-javadoctag"> @param</span> _value The amount of tokens to be spent. */</span>
  function approve(address _spender, uint256 _value) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  }

  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> Function to check the amount of tokens that an owner allowed to a spender. *<span class="hljs-javadoctag"> @param</span> _owner address The address which owns the funds. *<span class="hljs-javadoctag"> @param</span> _spender address The address which will spend the funds. *<span class="hljs-javadoctag"> @return</span> A uint256 specifying the amount of tokens still available for the spender. */</span>
  function allowance(address _owner, address _spender) <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (uint256) {
    <span class="hljs-keyword">return</span> allowed[_owner][_spender];
  }

  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol *<span class="hljs-javadoctag"> @param</span> _spender The address which will spend the funds. *<span class="hljs-javadoctag"> @param</span> _addedValue The amount of tokens to increase the allowance by. */</span>
  function increaseApproval(address _spender, uint _addedValue) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  }

  <span class="hljs-javadoc">/** *<span class="hljs-javadoctag"> @dev</span> Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol *<span class="hljs-javadoctag"> @param</span> _spender The address which will spend the funds. *<span class="hljs-javadoctag"> @param</span> _subtractedValue The amount of tokens to decrease the allowance by. */</span>
  function decreaseApproval(address _spender, uint _subtractedValue) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    <span class="hljs-keyword">if</span> (_subtractedValue &gt; oldValue) {
      allowed[msg.sender][_spender] = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  }

}

contract Token is StandardToken {

    string <span class="hljs-keyword">public</span> name    = <span class="hljs-string">"Dylan Token"</span>;
    string <span class="hljs-keyword">public</span> symbol  = <span class="hljs-string">"DT"</span>;
    uint8 <span class="hljs-keyword">public</span> decimals = <span class="hljs-number">18</span>;

    uint256 <span class="hljs-keyword">public</span> constant INITIAL_SUPPLY = <span class="hljs-number">19940512</span>;

    function Token() <span class="hljs-keyword">public</span> {
        totalSupply_ = INITIAL_SUPPLY * (<span class="hljs-number">10</span> ** uint256(decimals));
        balances[msg.sender] = totalSupply_;
    }
}</code></pre> 
  <p>需要修改<strong>Token</strong>的名字<code>name</code>、标识<code>symbol</code>、发行量<code>INITIAL_SUPPLY</code>和小数位<code>decimals</code>的，直接在<strong>合约</strong><code>Token</code>中修改相应的变量即可。</p> 
  <h1 id="编译部署合约">编译部署合约</h1> 
  <p>打开<a href="https://remix.ethereum.org/" rel="nofollow" target="_blank">Remix-Solidity IDE</a>，一种在线的Solidity IDE。 <br> 将上述的三个合约代码导入至Remix中，点击<strong>start to compile</strong>进行编译。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514190650474?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 编译完成后切换到Run，<strong>下拉框选择Token</strong>，点击<strong>Deploy</strong>进行部署 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514190729238?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 之后会弹出确认<strong>transaction</strong>的面板，拖到最下面点击<strong>confirm</strong> <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211028263?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> <strong>MetaMask</strong>会弹出，确认交易，点击<strong>submit</strong> <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211044443?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 稍等片刻，交易被确认，会出现下图红框所示的合约地址，<strong>复制到剪贴板</strong> <br> 教程中<strong>Dylan Token</strong>合约地址为：0x89731a2ddcef82a268d8925327c4080229914f05 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211359137?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 再进入<strong>MetaMask</strong>，点击<strong>Tokens</strong>——<strong>AddToken</strong>，粘贴复制的合约地址，点击<strong>Add</strong> <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211520559?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 就可以在自己的钱包中看到刚刚发行的<strong>Token</strong>了</p> 
  <h1 id="认证合约代码">认证合约代码</h1> 
  <p><strong>注意：此步骤需科学上网，不然提交之前的验证码显示出不来。</strong> <br> 在<a href="https://etherscan.io/" rel="nofollow" target="_blank">以太坊区块浏览器</a>中找到自己的合约地址，点击<strong>Contract code</strong>——<strong>Verify and Publish</strong>，如下图所示 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211601605?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 在<strong>Contract name</strong>:的输入框输入部署的合约名称<strong>Token</strong>, <strong>Compiler</strong> 选择在remix的sttings 中<strong>Solidity version</strong> 显示的版本号。<strong>Optimization</strong> 选择 <strong>No</strong>。 然后在<strong>Enter the Solidity Contract Code below</strong> 下面的输入框中原样填入<strong>Remix</strong>中的代码 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018051421173369?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 完成后点击提交，如果通过验证，跳转之后会显示如下图红框内所示的<strong>successfully</strong>的字样 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180514211914410?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI5NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 至此Token发行教程完结。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_33829547/article/details/80291294,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_33829547/article/details/80291294,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
