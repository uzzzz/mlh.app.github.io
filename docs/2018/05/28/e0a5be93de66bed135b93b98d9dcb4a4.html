<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊交易源码分析 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊交易源码分析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/TurkeyCock/article/details/80485391 这篇开始分析以太坊交易相关代码。基本流程参见下图： 可以看到，完整流程分为以下几个步骤： &nbsp; 发起交易：指定目标地址和交易金额，以及需要的gas/gaslimit 交易签名：使用账户私钥对交易进行签名 提交交易：把交易加入到交易缓冲池txpool中（会先对交易签名进行验证） 广播交易：通知EVM执行，同时把交易信息广播给其他结点 &nbsp; 下面依次分析这几个部分的源码。 1. 发起交易 用户通过JSON RPC发起eth_sendTransaction请求，最终会调用PublicTransactionPoolAPI 的实现，代码位于internal/ethapi/api.go： func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) { &nbsp;&nbsp;&nbsp;&nbsp;// Look up the wallet containing the requested signer &nbsp;&nbsp;&nbsp;&nbsp;account := accounts.Account{Address: args.From} &nbsp;&nbsp;&nbsp;&nbsp;wallet, err := s.b.AccountManager().Find(account) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if args.Nonce == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Hold the addresse&#39;s mutex around signing to prevent concurrent assignment of &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the same nonce to multiple accounts. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.nonceLock.LockAddr(args.From) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer s.nonceLock.UnlockAddr(args.From) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Set some sanity defaults and terminate on failure &nbsp;&nbsp;&nbsp;&nbsp;if err := args.setDefaults(ctx, s.b); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Assemble the transaction and sign with the wallet &nbsp;&nbsp;&nbsp;&nbsp;tx := args.toTransaction() &nbsp;&nbsp;&nbsp;&nbsp;var chainID *big.Int &nbsp;&nbsp;&nbsp;&nbsp;if config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chainID = config.ChainId &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;signed, err := wallet.SignTx(account, tx, chainID) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return submitTransaction(ctx, s.b, signed) } &nbsp; 首先根据from地址查找到对应的wallet，检查一下参数值，然后做了以下3件事： &nbsp; 通过SendTxArgs.toTransaction()创建交易 通过Wallet.SignTx()对交易进行签名 通过submitTransaction()提交交易 这里先分析创建交易部分。先看一下SendTxArgs类型的定义（internal/ethapi/api.go）： type SendTxArgs struct { &nbsp;&nbsp;&nbsp;&nbsp;From common.Address `json:&quot;from&quot;` &nbsp;&nbsp;&nbsp;&nbsp;To *common.Address `json:&quot;to&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Gas *hexutil.Uint64 `json:&quot;gas&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasPrice *hexutil.Big `json:&quot;gasPrice&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Value *hexutil.Big `json:&quot;value&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Nonce *hexutil.Uint64 `json:&quot;nonce&quot;` &nbsp;&nbsp;&nbsp;&nbsp;// We accept &quot;data&quot; and &quot;input&quot; for backwards-compatibility reasons. &quot;input&quot; is the &nbsp;&nbsp;&nbsp;&nbsp;// newer name and should be preferred by clients. &nbsp;&nbsp;&nbsp;&nbsp;Data *hexutil.Bytes `json:&quot;data&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Input *hexutil.Bytes `json:&quot;input&quot;` } 可以看到是和JSON字段相应的，包括了地址、gas、金额这些交易信息，nonce是一个随账户交易次数自增的数字，一般会自动填充。交易还可以携带一些额外数据，存放在data或者input字段中，推荐用input，data是为了向后兼容。 接着看一下它的toTransaction()函数： func (args *SendTxArgs) toTransaction() *types.Transaction { &nbsp;&nbsp;&nbsp;&nbsp;var input []byte &nbsp;&nbsp;&nbsp;&nbsp;if args.Data != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = *args.Data &nbsp;&nbsp;&nbsp;&nbsp;} else if args.Input != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = *args.Input &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if args.To == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return types.NewContractCreation(uint64(*args.Nonce), (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return types.NewTransaction(uint64(*args.Nonce), *args.To, (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input) } 可以看到，如果目标地址为空的话，表示这是一个创建智能合约的交易，调用NewContractCreation()。否则说明这是一个普通交易，调用NewTransaction()。不管调用哪个，最终都会生成一个Transaction实例，我们看一下Transaction类型的定义，代码位于core/types/transaction.go： type Transaction struct { &nbsp;&nbsp;&nbsp;&nbsp;data txdata &nbsp;&nbsp;&nbsp;&nbsp;// caches &nbsp;&nbsp;&nbsp;&nbsp;hash atomic.Value &nbsp;&nbsp;&nbsp;&nbsp;size atomic.Value &nbsp;&nbsp;&nbsp;&nbsp;from atomic.Value } 主要就是包含了一个txdata类型的字段，其他3个都是缓存。看一下txdata类型的定义： type txdata struct { &nbsp;&nbsp;&nbsp;&nbsp;AccountNonce uint64 `json:&quot;nonce&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Price *big.Int `json:&quot;gasPrice&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasLimit uint64 `json:&quot;gas&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Recipient *common.Address `json:&quot;to&quot; rlp:&quot;nil&quot;` // nil means contract creation &nbsp;&nbsp;&nbsp;&nbsp;Amount *big.Int `json:&quot;value&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Payload []byte `json:&quot;input&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;// Signature values &nbsp;&nbsp;&nbsp;&nbsp;V *big.Int `json:&quot;v&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;R *big.Int `json:&quot;r&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;S *big.Int `json:&quot;s&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;// This is only used when marshaling to JSON. &nbsp;&nbsp;&nbsp;&nbsp;Hash *common.Hash `json:&quot;hash&quot; rlp:&quot;-&quot;` } 可以看到，除了刚刚那些参数值，还有3个签名字段和1个hash字段。需要注意的是，from地址并不包含在该结构中。 2. 交易签名 创建完Transaction实例以后，会调用Wallet.SignTx()进行签名。具体流程参见下图： 可以看到，是先通过Keccak-256算法计算交易数据的hash值，然后结合账户的私钥，通过ECDSA（Elliptic Curve Digital Signature Algorithm），也就是椭圆曲线数字签名算法生成签名数据。 这里有个疑问，为什么txdata里只有接收方的地址（Recipient），没有发送方的地址呢？那我们如何知道这笔交易的发起人时谁呢？实际上发送方的地址是可以根据交易数据以及签名推算出来的，参见下图： 至于为什么不把发送方地址放到txdata中，是为了故意隐藏发送方信息，还是为了减小数据量，就不得而知了。 下面开始分析代码。上一篇文章分析过，Wallet是一个接口，具体实现在keyStoreWallet中，代码位于accounts/keystore/keystore_wallet.go中： func (w *keystoreWallet) SignTx(account accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;// Make sure the requested account is contained within &nbsp;&nbsp;&nbsp;&nbsp;if account.Address != w.account.Address { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, accounts.ErrUnknownAccount &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if account.URL != (accounts.URL{}) &amp;&amp; account.URL != w.account.URL { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, accounts.ErrUnknownAccount &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Account seems valid, request the keystore to sign &nbsp;&nbsp;&nbsp;&nbsp;return w.keystore.SignTx(account, tx, chainID) } 继续跟踪KeyStore的SignTx()函数，代码位于accounts/keystore/keystore.go中： func (ks *KeyStore) SignTx(a accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;// Look up the key to sign with and abort if it cannot be found &nbsp;&nbsp;&nbsp;&nbsp;ks.mu.RLock() &nbsp;&nbsp;&nbsp;&nbsp;defer ks.mu.RUnlock() &nbsp;&nbsp;&nbsp;&nbsp;unlockedKey, found := ks.unlocked[a.Address] &nbsp;&nbsp;&nbsp;&nbsp;if !found { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, ErrLocked &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Depending on the presence of the chain ID, sign with EIP155 or homestead &nbsp;&nbsp;&nbsp;&nbsp;if chainID != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return types.SignTx(tx, types.NewEIP155Signer(chainID), unlockedKey.PrivateKey) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return types.SignTx(tx, types.HomesteadSigner{}, unlockedKey.PrivateKey) } 这里会首先判断账户是否已经解锁，如果已经解锁的话就可以获取它的私钥。 然后创建签名器，如果要符合EIP155规范的话，需要把chainID传进去，也就是我们的“--networkid”命令行参数。 最后调用一个全局函数SignTx()完成签名，代码位于core/types/transaction_signing.go： func SignTx(tx *Transaction, s Signer, prv *ecdsa.PrivateKey) (*Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;h := s.Hash(tx) &nbsp;&nbsp;&nbsp;&nbsp;sig, err := crypto.Sign(h[:], prv) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return tx.WithSignature(s, sig) } 主要分为3个步骤： &nbsp; 生成交易的hash值 根据hash值和私钥生成签名 把签名数据填充到Transaction实例中 2.1 生成交易的hash值 以EIP155Signer为例，代码如下： func (s EIP155Signer) Hash(tx *Transaction) common.Hash { &nbsp;&nbsp;&nbsp;&nbsp;return rlpHash([]interface{}{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.AccountNonce, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Price, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.GasLimit, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Recipient, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Amount, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Payload, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.chainId, uint(0), uint(0), &nbsp;&nbsp;&nbsp;&nbsp;}) } func rlpHash(x interface{}) (h common.Hash) { &nbsp;&nbsp;&nbsp;&nbsp;hw := sha3.NewKeccak256() &nbsp;&nbsp;&nbsp;&nbsp;rlp.Encode(hw, x) &nbsp;&nbsp;&nbsp;&nbsp;hw.Sum(h[:0]) &nbsp;&nbsp;&nbsp;&nbsp;return h } 可以看到，先用SHA3-256生成hash值，然后再进行RLP编码。RLP是一种数据序列化方法，后面有时间再写文章分析。 2.2 根据hash值和私钥生成签名 crypto.Sign()函数代码位于crypto/signature_cgo.go： // Sign calculates an ECDSA signature. // The produced signature is in the [R || S || V] format where V is 0 or 1. func Sign(hash []byte, prv *ecdsa.PrivateKey) (sig []byte, err error) { &nbsp;&nbsp;&nbsp;&nbsp;if len(hash) != 32 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, fmt.Errorf(&quot;hash is required to be exactly 32 bytes (%d)&quot;, len(hash)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;seckey := math.PaddedBigBytes(prv.D, prv.Params().BitSize/8) &nbsp;&nbsp;&nbsp;&nbsp;defer zeroBytes(seckey) &nbsp;&nbsp;&nbsp;&nbsp;return secp256k1.Sign(hash, seckey) } 这里是通过ECDSA算法生成签名数据，水平有限就不继续分析了。最终会返回的签名是一个字节数组，按R / S / V的顺序排列。 2.3 填充签名数据 最后一步就是把签名数据的这3个值填充到Transaction结构中了，看一下WithSignature()函数，代码位于core/types/transaction.go： func (tx *Transaction) WithSignature(signer Signer, sig []byte) (*Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;r, s, v, err := signer.SignatureValues(tx, sig) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;cpy := &amp;Transaction{data: tx.data} &nbsp;&nbsp;&nbsp;&nbsp;cpy.data.R, cpy.data.S, cpy.data.V = r, s, v &nbsp;&nbsp;&nbsp;&nbsp;return cpy, nil } 生成的签名数据是字节数组类型，需要通过signer.SignatureValues()函数转换成3个big.Int类型的数据，然后填充到Transaction结构的R / S / V字段上。可以瞄一眼这个转换函数： func (fs FrontierSigner) SignatureValues(tx *Transaction, sig []byte) (r, s, v *big.Int, err error) { &nbsp;&nbsp;&nbsp;&nbsp;if len(sig) != 65 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Sprintf(&quot;wrong size for signature: got %d, want 65&quot;, len(sig))) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;r = new(big.Int).SetBytes(sig[:32]) &nbsp;&nbsp;&nbsp;&nbsp;s = new(big.Int).SetBytes(sig[32:64]) &nbsp;&nbsp;&nbsp;&nbsp;v = new(big.Int).SetBytes([]byte{sig[64] + 27}) &nbsp;&nbsp;&nbsp;&nbsp;return r, s, v, nil } 第0～31字节是R，第32～63字节是S，第64位加上27就可以得到V。 &nbsp; 3. 提交交易 签名完成以后，就需要调用submitTransaction()函数提交到交易缓冲池txpool中。 在分析代码之前，先看下TxPool中的几个重要字段： &nbsp;&nbsp;&nbsp;&nbsp;pending map[common.Address]*txList // All currently processable transactions &nbsp;&nbsp;&nbsp;&nbsp;queue map[common.Address]*txList // Queued but non-processable transactions &nbsp;&nbsp;&nbsp;&nbsp;all map[common.Hash]*types.Transaction // All transactions to allow lookups &nbsp;&nbsp;&nbsp;&nbsp;priced *txPricedList // All transactions sorted by price pending字段中包含了当前所有可被处理的交易列表，而queue字段中包含了所有不可被处理、也就是新加入进来的交易。它们是按账号地址来组织的，每个地址对应一个txList，具体内部结构参见下图： &nbsp; 可以看到txList内部包含一个txSortedMap结构，实现按nonce排序，其内部维护了两张表： &nbsp; 一张是包含了所有Transaction的map，key是Transaction的nonce值。之前提到过，这个nonce是随着账户的交易次数自增的一个数字，所以越新的交易，nonce值越高。 还有一张表是一个数组，包含了所有nonce值，其内部是进行过堆排序的（小顶堆），nonce值按照从大到小排列。每次调用heap.Pop()时会取出最小的nonce值，也就是最老的交易。 all字段中包含了所有的交易列表，以交易的hash作为key。 priced字段则是把all中的交易列表按照gas price从大到小排列，如果gas price一样，则按照交易的nonce值从小到大排列。最终的目标是每次取出gas price最大、nonce最小的交易。 我们提交交易的目标是：先把交易放入queue中记录在案，然后再从queue中选一部分放入pending中进行处理。如果发现txpool满了，则依据priced中的排序，剔除低油价的交易。 另外，如果是本地（local）提交的交易，默认情况下会尽可能地保证被放入txpool中，除非显式关闭该配置。 接着我们看一下txpool的默认配置： var DefaultTxPoolConfig = TxPoolConfig{ Journal: &quot;transactions.rlp&quot;, Rejournal: time.Hour, PriceLimit: 1, PriceBump: 10, AccountSlots: 16, GlobalSlots: 4096, AccountQueue: 64, GlobalQueue: 1024, Lifetime: 3 * time.Hour, } &nbsp; &nbsp; GlobalSlots：pending列表的最大长度，默认4096笔 AccountSlots：pending中每个账户存储的交易数的阈值，超过这个数量可能会被认为是垃圾交易或者是攻击者，多余交易可能被丢弃 GlobalQueue：queue列表的最大长度，默认1024笔 AccountQueue：queue中每个账户允许存储的最大交易数，超过会被丢弃，默认64笔 PriceLimit：允许进入txpool的最低gas price，默认1 Gwei PriceBump：如果出现两个nonce相同的交易，gas price的差值超过该阈值则用新交易替换老交易 好，现在我们回到internal/ethapi/api.go，分析submitTransaction()函数： func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) { &nbsp;&nbsp;&nbsp;&nbsp;if err := b.SendTx(ctx, tx); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if tx.To() == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signer := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, err := types.Sender(signer, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr := crypto.CreateAddress(from, tx.Nonce()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Info(&quot;Submitted contract creation&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;contract&quot;, addr.Hex()) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Info(&quot;Submitted transaction&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;recipient&quot;, tx.To()) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return tx.Hash(), nil } 这里有一个Backend参数，是在eth Service初始化时创建的，具体实现在EthApiBackend中，代码位于eth/api_backend.go。可以看到，这里先调用了SendTx()函数提交交易，然后如果发现目标地址为空，表明这是一个创建智能合约的交易，会创建合约地址。下面分别进行分析。 3.1 提交交易到txpool func (b *EthApiBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return b.eth.txPool.AddLocal(signedTx) } 继续跟踪TxPool的AddLocal()函数： func (pool *TxPool) AddLocal(tx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return pool.addTx(tx, !pool.config.NoLocals) } func (pool *TxPool) addTx(tx *types.Transaction, local bool) error { &nbsp;&nbsp;&nbsp;&nbsp;pool.mu.Lock() &nbsp;&nbsp;&nbsp;&nbsp;defer pool.mu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;// Try to inject the transaction and update any state &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.add(tx, local) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// If we added a new transaction, run promotion checks and return &nbsp;&nbsp;&nbsp;&nbsp;if !replace { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.promoteExecutables([]common.Address{from}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return nil } 这里有两个主要函数：add()和promoteExecuteables()。 add()会判断是否应该把当前交易加入到queue列表中，promoteExecuteables()则会从queue中选取一些交易放入pending列表中等待执行。下面分别讨论这两个函数。 3.1.1 TxPool.add() 这个函数比较长，我们分成一段一段的来分析： &nbsp;&nbsp;&nbsp;&nbsp;// If the transaction is already known, discard it &nbsp;&nbsp;&nbsp;&nbsp;hash := tx.Hash() &nbsp;&nbsp;&nbsp;&nbsp;if pool.all[hash] != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding already known transaction&quot;, &quot;hash&quot;, hash) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, fmt.Errorf(&quot;known transaction: %x&quot;, hash) &nbsp;&nbsp;&nbsp;&nbsp;} 这一段是先计算交易的hash值，然后判断是不是已经在txpool 中，在的话就直接退出。 &nbsp;&nbsp;&nbsp;&nbsp;if err := pool.validateTx(tx, local); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding invalid transaction&quot;, &quot;hash&quot;, hash, &quot;err&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalidTxCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err &nbsp;&nbsp;&nbsp;&nbsp;} 这一段是验证交易的有效性，主要进行以下几个方面的检查： &nbsp; 数据量必须&lt;32KB 交易金额必须非负（&gt;=0） 交易的gas limit必须低于block的gas limit 签名数据必须有效，能够解析出发送者地址 交易的gas price必须高于pool设定的最低gas price（除非是本地交易） 交易的nonce值必须高于当前链上该账户的nonce值（低于则说明这笔交易已经被打包过了） 当前账户余额必须大于“交易金额 + gasprice * gaslimit” 交易的gas limit必须大于对应数据量所需的最低gas水平 &nbsp;&nbsp;&nbsp;&nbsp;// If the transaction pool is full, discard underpriced transactions &nbsp;&nbsp;&nbsp;&nbsp;if uint64(len(pool.all)) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the new transaction is underpriced, don&#39;t accept it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding underpriced transaction&quot;, &quot;hash&quot;, hash, &quot;price&quot;, tx.GasPrice()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underpricedTxCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, ErrUnderpriced &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// New transaction is better than our worse ones, make room for it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drop := pool.priced.Discard(len(pool.all)-int(pool.config.GlobalSlots+pool.config.GlobalQueue-1), pool.locals) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range drop { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding freshly underpriced transaction&quot;, &quot;hash&quot;, tx.Hash(), &quot;price&quot;, tx.GasPrice()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underpricedTxCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.removeTx(tx.Hash(), false) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; 这一段是在当前txpool已满的情况下，剔除掉低油价的交易。还记得之前有个priced字段存储了按gas price以及nonce排序的交易列表吗？这里会先把当前交易的gas price和当前池中的最低价进行比较： &nbsp; 如果低于最低价，直接丢弃该交易返回 如果高于最低价，则从txpool中剔除一些低价的交易 &nbsp;&nbsp;&nbsp;&nbsp;// If the transaction is replacing an already pending one, do directly &nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated &nbsp;&nbsp;&nbsp;&nbsp;if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Nonce already pending, check if required price bump is met &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inserted, old := list.Add(tx, pool.config.PriceBump) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !inserted { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pendingDiscardCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, ErrReplaceUnderpriced &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// New transaction is better, replace old one &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if old != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete(pool.all, old.Hash()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pendingReplaceCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all[tx.Hash()] = tx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Put(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.journalTx(from, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Pooled new executable transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We&#39;ve directly injected a replacement transaction, notify subsystems &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(TxPreEvent{tx}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return old != nil, nil &nbsp;&nbsp;&nbsp;&nbsp;} 这一段是为了处理两个交易nonce相同的问题。如果用户发起了一笔交易，在还没有被执行之前又用同样的nonce发起了另一笔交易，则只会保留gas price高的那一笔。这个list.Overlaps()函数就是用来判断pending列表中是否包含相同nonce的交易的。 &nbsp;&nbsp;&nbsp;&nbsp;// New transaction isn&#39;t replacing a pending one, push into queue &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.enqueueTx(hash, tx) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err &nbsp;&nbsp;&nbsp;&nbsp;} 如果之前的那些检查都没有问题，就真正调用enqueueTx()函数把交易加入到queue列表中了。 &nbsp;&nbsp;&nbsp;&nbsp;// Mark local addresses and journal local transactions &nbsp;&nbsp;&nbsp;&nbsp;if local { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.locals.add(from) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;pool.journalTx(from, tx) 最后，如果发现这个账户是本地的，就把它加到一个白名单里，默认会保证本地交易优先被加到txpool中。 至此，TxPool.add()函数就分析完了。 3.1.2 TxPool.promoteExecuteables() 这个函数比上面那个还长。。。主要目的是把交易从queue列表“提拔”到pending列表，代码逻辑比较清楚，具体可以参见下面这张图： 根据不同的目的可以分为3块，分别以粉色、紫色、绿色标识。 &nbsp; 粉色部分主要是为了把queue中的交易“提拔”到pending中。当然在这之前需要先要进行一番检查： &nbsp; 丢弃nonce &lt; 账户当前nonce的交易，也就是已经被打包过的交易 丢弃转账金额 + gas消耗 &gt; 账户余额的交易，也就是会out-of-gas的交易 丢弃gas limit &gt; block gas limit的交易，这部分交易可能会导致区块生成失败 紫色部分主要是为了清理pending列表，使其满足GlobalSlots和AccountSlots的限制条件： &nbsp; 如果有些账户的交易数超过了AccountSlots，则先按交易数最少的账户进行均衡。举例来说，如果有10个账户交易数超过了AccountSlots（默认16），其中交易数最少的账户包含20笔交易，那么先把其他9个账户的交易数量削减到20。 如果经过上面的步骤，pending的长度还是超过了GlobalSlots，那就严格按照AccountSlots进行均衡，也就是把上面的10个账户的交易数进一步削减到16。 绿色部分主要是为了清理queue列表，使其满足GlobalQueue和AccountQueue的限制条件： &nbsp; 如果每个账户的交易数超过了AccountQueue，丢弃多余交易 如果queue的长度超过了GlobalQueue，则把账户按最后一次心跳时间排序，然后依次去除账户中的交易，直到满足限制条件位置。 这里提到一个最后一次心跳时间，其实就是账户最近一次交易的时间，用来作为账户活跃度的判断 具体代码非常长，就不贴了，可以按照上面的图自行对照。 3.2 创建智能合约地址 再贴一下之前创建智能合约地址的代码： addr := crypto.CreateAddress(from, tx.Nonce()) 参数是发送方地址和交易的nonce值，然后调用CreateAddress()方法，代码位于crypto/crypto.go： func CreateAddress(b common.Address, nonce uint64) common.Address { &nbsp;&nbsp;&nbsp;&nbsp;data, _ := rlp.EncodeToBytes([]interface{}{b, nonce}) &nbsp;&nbsp;&nbsp;&nbsp;return common.BytesToAddress(Keccak256(data)[12:]) } 可以看到，就是先对刚刚两个参数进行RLP编码，然后计算hash值，取后20位作为合约地址。 至此，提交交易部分的代码就分析完了。 4. 广播交易 交易提交到txpool中后，还需要广播出去，一方面通知EVM执行该交易，另一方面要把交易信息广播给其他结点。具体调用在3.1.2节中提到的promoteTx()函数中，代码位于crypto/tx_pool.go： func (pool *TxPool) promoteTx(addr common.Address, hash common.Hash, tx *types.Transaction) { …… &nbsp;&nbsp;&nbsp;&nbsp;// Set the potentially new pending nonce and notify any subsystems of the new tx &nbsp;&nbsp;&nbsp;&nbsp;pool.beats[addr] = time.Now() &nbsp;&nbsp;&nbsp;&nbsp;pool.pendingState.SetNonce(addr, tx.Nonce()+1) &nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(TxPreEvent{tx}) } 可以看到，先更新了最后一次心跳时间，然后更新账户的nonce值，最后一行就是发送一个TxPreEvent事件，外部可以通过SubscribeTxPreEvent()函数订阅该事件： func (pool *TxPool) SubscribeTxPreEvent(ch chan&lt;- TxPreEvent) event.Subscription { &nbsp;&nbsp;&nbsp;&nbsp;return pool.scope.Track(pool.txFeed.Subscribe(ch)) } 我们只要搜索一下这个函数，就可以知道哪些组件订阅了该事件了。 4.1 执行交易 第一个订阅的地方位于miner/worker.go： func newWorker(config *params.ChainConfig, engine consensus.Engine, coinbase common.Address, eth Backend, mux *event.TypeMux) *worker { …… &nbsp;&nbsp;&nbsp;&nbsp;// Subscribe TxPreEvent for tx pool &nbsp;&nbsp;&nbsp;&nbsp;worker.txSub = eth.TxPool().SubscribeTxPreEvent(worker.txCh) …… go worker.update() …… } 开启了一个goroutine来接收TxPreEvent，看一下update()函数： func (self *worker) update() { …… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Handle TxPreEvent &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ev := &lt;-self.txCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Apply transaction to the pending state if we&#39;re not mining &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if atomic.LoadInt32(&amp;self.mining) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.currentMu.Lock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc, _ := types.Sender(self.current.signer, ev.Tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txs := map[common.Address]types.Transactions{acc: {ev.Tx}} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txset := types.NewTransactionsByPriceAndNonce(self.current.signer, txs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.current.commitTransactions(self.mux, txset, self.chain, self.coinbase) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.updateSnapshot() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.currentMu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If we&#39;re mining, but nothing is being processed, wake on new transactions &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.config.Clique != nil &amp;&amp; self.config.Clique.Period == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.commitNewWork() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} …… } 可以看到，如果结点不挖矿的话，这里会立即调用commitTransactions()提交给EVM执行，获得本地回执。 如果结点挖矿的话，miner会调用commitNewWork()，内部也会调用commitTransactions()执行交易。 4.2 广播给其他结点 另一个订阅的地方位于eth/handler.go： func (pm *ProtocolManager) Start(maxPeers int) { …… &nbsp;&nbsp;&nbsp;pm.txSub = pm.txpool.SubscribeTxPreEvent(pm.txCh) &nbsp;&nbsp;&nbsp;&nbsp;go pm.txBroadcastLoop() …… } 同样也是启动了一个goroutine来接收TxPreEvent事件，看一下txBroadcastLoop()函数： func (pm *ProtocolManager) txBroadcastLoop() { &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case event := &lt;-pm.txCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pm.BroadcastTx(event.Tx.Hash(), event.Tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Err() channel will be closed when unsubscribing. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-pm.txSub.Err(): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } 继续跟踪BroadcastTx()函数： func (pm *ProtocolManager) BroadcastTx(hash common.Hash, tx *types.Transaction) { &nbsp;&nbsp;&nbsp;&nbsp;// Broadcast transaction to a batch of peers not knowing about it &nbsp;&nbsp;&nbsp;&nbsp;peers := pm.peers.PeersWithoutTx(hash) &nbsp;&nbsp;&nbsp;&nbsp;//FIXME include this again: peers = peers[:int(math.Sqrt(float64(len(peers))))] &nbsp;&nbsp;&nbsp;&nbsp;for _, peer := range peers { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peer.SendTransactions(types.Transactions{tx}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Broadcast transaction&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(peers)) } 可以看到，这里会通过P2P向所有没有该交易的结点发送该交易。 更多文章欢迎关注“鑫鑫点灯”专栏：https://blog.csdn.net/turkeycock/article/category/7669858 或关注飞久微信公众号： 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/TurkeyCock/article/details/80485391 这篇开始分析以太坊交易相关代码。基本流程参见下图： 可以看到，完整流程分为以下几个步骤： &nbsp; 发起交易：指定目标地址和交易金额，以及需要的gas/gaslimit 交易签名：使用账户私钥对交易进行签名 提交交易：把交易加入到交易缓冲池txpool中（会先对交易签名进行验证） 广播交易：通知EVM执行，同时把交易信息广播给其他结点 &nbsp; 下面依次分析这几个部分的源码。 1. 发起交易 用户通过JSON RPC发起eth_sendTransaction请求，最终会调用PublicTransactionPoolAPI 的实现，代码位于internal/ethapi/api.go： func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) { &nbsp;&nbsp;&nbsp;&nbsp;// Look up the wallet containing the requested signer &nbsp;&nbsp;&nbsp;&nbsp;account := accounts.Account{Address: args.From} &nbsp;&nbsp;&nbsp;&nbsp;wallet, err := s.b.AccountManager().Find(account) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if args.Nonce == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Hold the addresse&#39;s mutex around signing to prevent concurrent assignment of &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the same nonce to multiple accounts. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.nonceLock.LockAddr(args.From) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer s.nonceLock.UnlockAddr(args.From) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Set some sanity defaults and terminate on failure &nbsp;&nbsp;&nbsp;&nbsp;if err := args.setDefaults(ctx, s.b); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Assemble the transaction and sign with the wallet &nbsp;&nbsp;&nbsp;&nbsp;tx := args.toTransaction() &nbsp;&nbsp;&nbsp;&nbsp;var chainID *big.Int &nbsp;&nbsp;&nbsp;&nbsp;if config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chainID = config.ChainId &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;signed, err := wallet.SignTx(account, tx, chainID) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return submitTransaction(ctx, s.b, signed) } &nbsp; 首先根据from地址查找到对应的wallet，检查一下参数值，然后做了以下3件事： &nbsp; 通过SendTxArgs.toTransaction()创建交易 通过Wallet.SignTx()对交易进行签名 通过submitTransaction()提交交易 这里先分析创建交易部分。先看一下SendTxArgs类型的定义（internal/ethapi/api.go）： type SendTxArgs struct { &nbsp;&nbsp;&nbsp;&nbsp;From common.Address `json:&quot;from&quot;` &nbsp;&nbsp;&nbsp;&nbsp;To *common.Address `json:&quot;to&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Gas *hexutil.Uint64 `json:&quot;gas&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasPrice *hexutil.Big `json:&quot;gasPrice&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Value *hexutil.Big `json:&quot;value&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Nonce *hexutil.Uint64 `json:&quot;nonce&quot;` &nbsp;&nbsp;&nbsp;&nbsp;// We accept &quot;data&quot; and &quot;input&quot; for backwards-compatibility reasons. &quot;input&quot; is the &nbsp;&nbsp;&nbsp;&nbsp;// newer name and should be preferred by clients. &nbsp;&nbsp;&nbsp;&nbsp;Data *hexutil.Bytes `json:&quot;data&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Input *hexutil.Bytes `json:&quot;input&quot;` } 可以看到是和JSON字段相应的，包括了地址、gas、金额这些交易信息，nonce是一个随账户交易次数自增的数字，一般会自动填充。交易还可以携带一些额外数据，存放在data或者input字段中，推荐用input，data是为了向后兼容。 接着看一下它的toTransaction()函数： func (args *SendTxArgs) toTransaction() *types.Transaction { &nbsp;&nbsp;&nbsp;&nbsp;var input []byte &nbsp;&nbsp;&nbsp;&nbsp;if args.Data != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = *args.Data &nbsp;&nbsp;&nbsp;&nbsp;} else if args.Input != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = *args.Input &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if args.To == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return types.NewContractCreation(uint64(*args.Nonce), (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return types.NewTransaction(uint64(*args.Nonce), *args.To, (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input) } 可以看到，如果目标地址为空的话，表示这是一个创建智能合约的交易，调用NewContractCreation()。否则说明这是一个普通交易，调用NewTransaction()。不管调用哪个，最终都会生成一个Transaction实例，我们看一下Transaction类型的定义，代码位于core/types/transaction.go： type Transaction struct { &nbsp;&nbsp;&nbsp;&nbsp;data txdata &nbsp;&nbsp;&nbsp;&nbsp;// caches &nbsp;&nbsp;&nbsp;&nbsp;hash atomic.Value &nbsp;&nbsp;&nbsp;&nbsp;size atomic.Value &nbsp;&nbsp;&nbsp;&nbsp;from atomic.Value } 主要就是包含了一个txdata类型的字段，其他3个都是缓存。看一下txdata类型的定义： type txdata struct { &nbsp;&nbsp;&nbsp;&nbsp;AccountNonce uint64 `json:&quot;nonce&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Price *big.Int `json:&quot;gasPrice&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasLimit uint64 `json:&quot;gas&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Recipient *common.Address `json:&quot;to&quot; rlp:&quot;nil&quot;` // nil means contract creation &nbsp;&nbsp;&nbsp;&nbsp;Amount *big.Int `json:&quot;value&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Payload []byte `json:&quot;input&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;// Signature values &nbsp;&nbsp;&nbsp;&nbsp;V *big.Int `json:&quot;v&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;R *big.Int `json:&quot;r&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;S *big.Int `json:&quot;s&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;// This is only used when marshaling to JSON. &nbsp;&nbsp;&nbsp;&nbsp;Hash *common.Hash `json:&quot;hash&quot; rlp:&quot;-&quot;` } 可以看到，除了刚刚那些参数值，还有3个签名字段和1个hash字段。需要注意的是，from地址并不包含在该结构中。 2. 交易签名 创建完Transaction实例以后，会调用Wallet.SignTx()进行签名。具体流程参见下图： 可以看到，是先通过Keccak-256算法计算交易数据的hash值，然后结合账户的私钥，通过ECDSA（Elliptic Curve Digital Signature Algorithm），也就是椭圆曲线数字签名算法生成签名数据。 这里有个疑问，为什么txdata里只有接收方的地址（Recipient），没有发送方的地址呢？那我们如何知道这笔交易的发起人时谁呢？实际上发送方的地址是可以根据交易数据以及签名推算出来的，参见下图： 至于为什么不把发送方地址放到txdata中，是为了故意隐藏发送方信息，还是为了减小数据量，就不得而知了。 下面开始分析代码。上一篇文章分析过，Wallet是一个接口，具体实现在keyStoreWallet中，代码位于accounts/keystore/keystore_wallet.go中： func (w *keystoreWallet) SignTx(account accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;// Make sure the requested account is contained within &nbsp;&nbsp;&nbsp;&nbsp;if account.Address != w.account.Address { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, accounts.ErrUnknownAccount &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if account.URL != (accounts.URL{}) &amp;&amp; account.URL != w.account.URL { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, accounts.ErrUnknownAccount &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Account seems valid, request the keystore to sign &nbsp;&nbsp;&nbsp;&nbsp;return w.keystore.SignTx(account, tx, chainID) } 继续跟踪KeyStore的SignTx()函数，代码位于accounts/keystore/keystore.go中： func (ks *KeyStore) SignTx(a accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;// Look up the key to sign with and abort if it cannot be found &nbsp;&nbsp;&nbsp;&nbsp;ks.mu.RLock() &nbsp;&nbsp;&nbsp;&nbsp;defer ks.mu.RUnlock() &nbsp;&nbsp;&nbsp;&nbsp;unlockedKey, found := ks.unlocked[a.Address] &nbsp;&nbsp;&nbsp;&nbsp;if !found { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, ErrLocked &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Depending on the presence of the chain ID, sign with EIP155 or homestead &nbsp;&nbsp;&nbsp;&nbsp;if chainID != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return types.SignTx(tx, types.NewEIP155Signer(chainID), unlockedKey.PrivateKey) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return types.SignTx(tx, types.HomesteadSigner{}, unlockedKey.PrivateKey) } 这里会首先判断账户是否已经解锁，如果已经解锁的话就可以获取它的私钥。 然后创建签名器，如果要符合EIP155规范的话，需要把chainID传进去，也就是我们的“--networkid”命令行参数。 最后调用一个全局函数SignTx()完成签名，代码位于core/types/transaction_signing.go： func SignTx(tx *Transaction, s Signer, prv *ecdsa.PrivateKey) (*Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;h := s.Hash(tx) &nbsp;&nbsp;&nbsp;&nbsp;sig, err := crypto.Sign(h[:], prv) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return tx.WithSignature(s, sig) } 主要分为3个步骤： &nbsp; 生成交易的hash值 根据hash值和私钥生成签名 把签名数据填充到Transaction实例中 2.1 生成交易的hash值 以EIP155Signer为例，代码如下： func (s EIP155Signer) Hash(tx *Transaction) common.Hash { &nbsp;&nbsp;&nbsp;&nbsp;return rlpHash([]interface{}{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.AccountNonce, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Price, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.GasLimit, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Recipient, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Amount, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Payload, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.chainId, uint(0), uint(0), &nbsp;&nbsp;&nbsp;&nbsp;}) } func rlpHash(x interface{}) (h common.Hash) { &nbsp;&nbsp;&nbsp;&nbsp;hw := sha3.NewKeccak256() &nbsp;&nbsp;&nbsp;&nbsp;rlp.Encode(hw, x) &nbsp;&nbsp;&nbsp;&nbsp;hw.Sum(h[:0]) &nbsp;&nbsp;&nbsp;&nbsp;return h } 可以看到，先用SHA3-256生成hash值，然后再进行RLP编码。RLP是一种数据序列化方法，后面有时间再写文章分析。 2.2 根据hash值和私钥生成签名 crypto.Sign()函数代码位于crypto/signature_cgo.go： // Sign calculates an ECDSA signature. // The produced signature is in the [R || S || V] format where V is 0 or 1. func Sign(hash []byte, prv *ecdsa.PrivateKey) (sig []byte, err error) { &nbsp;&nbsp;&nbsp;&nbsp;if len(hash) != 32 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, fmt.Errorf(&quot;hash is required to be exactly 32 bytes (%d)&quot;, len(hash)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;seckey := math.PaddedBigBytes(prv.D, prv.Params().BitSize/8) &nbsp;&nbsp;&nbsp;&nbsp;defer zeroBytes(seckey) &nbsp;&nbsp;&nbsp;&nbsp;return secp256k1.Sign(hash, seckey) } 这里是通过ECDSA算法生成签名数据，水平有限就不继续分析了。最终会返回的签名是一个字节数组，按R / S / V的顺序排列。 2.3 填充签名数据 最后一步就是把签名数据的这3个值填充到Transaction结构中了，看一下WithSignature()函数，代码位于core/types/transaction.go： func (tx *Transaction) WithSignature(signer Signer, sig []byte) (*Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;r, s, v, err := signer.SignatureValues(tx, sig) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;cpy := &amp;Transaction{data: tx.data} &nbsp;&nbsp;&nbsp;&nbsp;cpy.data.R, cpy.data.S, cpy.data.V = r, s, v &nbsp;&nbsp;&nbsp;&nbsp;return cpy, nil } 生成的签名数据是字节数组类型，需要通过signer.SignatureValues()函数转换成3个big.Int类型的数据，然后填充到Transaction结构的R / S / V字段上。可以瞄一眼这个转换函数： func (fs FrontierSigner) SignatureValues(tx *Transaction, sig []byte) (r, s, v *big.Int, err error) { &nbsp;&nbsp;&nbsp;&nbsp;if len(sig) != 65 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Sprintf(&quot;wrong size for signature: got %d, want 65&quot;, len(sig))) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;r = new(big.Int).SetBytes(sig[:32]) &nbsp;&nbsp;&nbsp;&nbsp;s = new(big.Int).SetBytes(sig[32:64]) &nbsp;&nbsp;&nbsp;&nbsp;v = new(big.Int).SetBytes([]byte{sig[64] + 27}) &nbsp;&nbsp;&nbsp;&nbsp;return r, s, v, nil } 第0～31字节是R，第32～63字节是S，第64位加上27就可以得到V。 &nbsp; 3. 提交交易 签名完成以后，就需要调用submitTransaction()函数提交到交易缓冲池txpool中。 在分析代码之前，先看下TxPool中的几个重要字段： &nbsp;&nbsp;&nbsp;&nbsp;pending map[common.Address]*txList // All currently processable transactions &nbsp;&nbsp;&nbsp;&nbsp;queue map[common.Address]*txList // Queued but non-processable transactions &nbsp;&nbsp;&nbsp;&nbsp;all map[common.Hash]*types.Transaction // All transactions to allow lookups &nbsp;&nbsp;&nbsp;&nbsp;priced *txPricedList // All transactions sorted by price pending字段中包含了当前所有可被处理的交易列表，而queue字段中包含了所有不可被处理、也就是新加入进来的交易。它们是按账号地址来组织的，每个地址对应一个txList，具体内部结构参见下图： &nbsp; 可以看到txList内部包含一个txSortedMap结构，实现按nonce排序，其内部维护了两张表： &nbsp; 一张是包含了所有Transaction的map，key是Transaction的nonce值。之前提到过，这个nonce是随着账户的交易次数自增的一个数字，所以越新的交易，nonce值越高。 还有一张表是一个数组，包含了所有nonce值，其内部是进行过堆排序的（小顶堆），nonce值按照从大到小排列。每次调用heap.Pop()时会取出最小的nonce值，也就是最老的交易。 all字段中包含了所有的交易列表，以交易的hash作为key。 priced字段则是把all中的交易列表按照gas price从大到小排列，如果gas price一样，则按照交易的nonce值从小到大排列。最终的目标是每次取出gas price最大、nonce最小的交易。 我们提交交易的目标是：先把交易放入queue中记录在案，然后再从queue中选一部分放入pending中进行处理。如果发现txpool满了，则依据priced中的排序，剔除低油价的交易。 另外，如果是本地（local）提交的交易，默认情况下会尽可能地保证被放入txpool中，除非显式关闭该配置。 接着我们看一下txpool的默认配置： var DefaultTxPoolConfig = TxPoolConfig{ Journal: &quot;transactions.rlp&quot;, Rejournal: time.Hour, PriceLimit: 1, PriceBump: 10, AccountSlots: 16, GlobalSlots: 4096, AccountQueue: 64, GlobalQueue: 1024, Lifetime: 3 * time.Hour, } &nbsp; &nbsp; GlobalSlots：pending列表的最大长度，默认4096笔 AccountSlots：pending中每个账户存储的交易数的阈值，超过这个数量可能会被认为是垃圾交易或者是攻击者，多余交易可能被丢弃 GlobalQueue：queue列表的最大长度，默认1024笔 AccountQueue：queue中每个账户允许存储的最大交易数，超过会被丢弃，默认64笔 PriceLimit：允许进入txpool的最低gas price，默认1 Gwei PriceBump：如果出现两个nonce相同的交易，gas price的差值超过该阈值则用新交易替换老交易 好，现在我们回到internal/ethapi/api.go，分析submitTransaction()函数： func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) { &nbsp;&nbsp;&nbsp;&nbsp;if err := b.SendTx(ctx, tx); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if tx.To() == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signer := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, err := types.Sender(signer, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr := crypto.CreateAddress(from, tx.Nonce()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Info(&quot;Submitted contract creation&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;contract&quot;, addr.Hex()) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Info(&quot;Submitted transaction&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;recipient&quot;, tx.To()) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return tx.Hash(), nil } 这里有一个Backend参数，是在eth Service初始化时创建的，具体实现在EthApiBackend中，代码位于eth/api_backend.go。可以看到，这里先调用了SendTx()函数提交交易，然后如果发现目标地址为空，表明这是一个创建智能合约的交易，会创建合约地址。下面分别进行分析。 3.1 提交交易到txpool func (b *EthApiBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return b.eth.txPool.AddLocal(signedTx) } 继续跟踪TxPool的AddLocal()函数： func (pool *TxPool) AddLocal(tx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return pool.addTx(tx, !pool.config.NoLocals) } func (pool *TxPool) addTx(tx *types.Transaction, local bool) error { &nbsp;&nbsp;&nbsp;&nbsp;pool.mu.Lock() &nbsp;&nbsp;&nbsp;&nbsp;defer pool.mu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;// Try to inject the transaction and update any state &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.add(tx, local) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// If we added a new transaction, run promotion checks and return &nbsp;&nbsp;&nbsp;&nbsp;if !replace { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.promoteExecutables([]common.Address{from}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return nil } 这里有两个主要函数：add()和promoteExecuteables()。 add()会判断是否应该把当前交易加入到queue列表中，promoteExecuteables()则会从queue中选取一些交易放入pending列表中等待执行。下面分别讨论这两个函数。 3.1.1 TxPool.add() 这个函数比较长，我们分成一段一段的来分析： &nbsp;&nbsp;&nbsp;&nbsp;// If the transaction is already known, discard it &nbsp;&nbsp;&nbsp;&nbsp;hash := tx.Hash() &nbsp;&nbsp;&nbsp;&nbsp;if pool.all[hash] != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding already known transaction&quot;, &quot;hash&quot;, hash) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, fmt.Errorf(&quot;known transaction: %x&quot;, hash) &nbsp;&nbsp;&nbsp;&nbsp;} 这一段是先计算交易的hash值，然后判断是不是已经在txpool 中，在的话就直接退出。 &nbsp;&nbsp;&nbsp;&nbsp;if err := pool.validateTx(tx, local); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding invalid transaction&quot;, &quot;hash&quot;, hash, &quot;err&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalidTxCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err &nbsp;&nbsp;&nbsp;&nbsp;} 这一段是验证交易的有效性，主要进行以下几个方面的检查： &nbsp; 数据量必须&lt;32KB 交易金额必须非负（&gt;=0） 交易的gas limit必须低于block的gas limit 签名数据必须有效，能够解析出发送者地址 交易的gas price必须高于pool设定的最低gas price（除非是本地交易） 交易的nonce值必须高于当前链上该账户的nonce值（低于则说明这笔交易已经被打包过了） 当前账户余额必须大于“交易金额 + gasprice * gaslimit” 交易的gas limit必须大于对应数据量所需的最低gas水平 &nbsp;&nbsp;&nbsp;&nbsp;// If the transaction pool is full, discard underpriced transactions &nbsp;&nbsp;&nbsp;&nbsp;if uint64(len(pool.all)) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the new transaction is underpriced, don&#39;t accept it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding underpriced transaction&quot;, &quot;hash&quot;, hash, &quot;price&quot;, tx.GasPrice()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underpricedTxCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, ErrUnderpriced &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// New transaction is better than our worse ones, make room for it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drop := pool.priced.Discard(len(pool.all)-int(pool.config.GlobalSlots+pool.config.GlobalQueue-1), pool.locals) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range drop { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding freshly underpriced transaction&quot;, &quot;hash&quot;, tx.Hash(), &quot;price&quot;, tx.GasPrice()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underpricedTxCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.removeTx(tx.Hash(), false) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; 这一段是在当前txpool已满的情况下，剔除掉低油价的交易。还记得之前有个priced字段存储了按gas price以及nonce排序的交易列表吗？这里会先把当前交易的gas price和当前池中的最低价进行比较： &nbsp; 如果低于最低价，直接丢弃该交易返回 如果高于最低价，则从txpool中剔除一些低价的交易 &nbsp;&nbsp;&nbsp;&nbsp;// If the transaction is replacing an already pending one, do directly &nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated &nbsp;&nbsp;&nbsp;&nbsp;if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Nonce already pending, check if required price bump is met &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inserted, old := list.Add(tx, pool.config.PriceBump) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !inserted { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pendingDiscardCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, ErrReplaceUnderpriced &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// New transaction is better, replace old one &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if old != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete(pool.all, old.Hash()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pendingReplaceCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all[tx.Hash()] = tx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Put(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.journalTx(from, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Pooled new executable transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We&#39;ve directly injected a replacement transaction, notify subsystems &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(TxPreEvent{tx}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return old != nil, nil &nbsp;&nbsp;&nbsp;&nbsp;} 这一段是为了处理两个交易nonce相同的问题。如果用户发起了一笔交易，在还没有被执行之前又用同样的nonce发起了另一笔交易，则只会保留gas price高的那一笔。这个list.Overlaps()函数就是用来判断pending列表中是否包含相同nonce的交易的。 &nbsp;&nbsp;&nbsp;&nbsp;// New transaction isn&#39;t replacing a pending one, push into queue &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.enqueueTx(hash, tx) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err &nbsp;&nbsp;&nbsp;&nbsp;} 如果之前的那些检查都没有问题，就真正调用enqueueTx()函数把交易加入到queue列表中了。 &nbsp;&nbsp;&nbsp;&nbsp;// Mark local addresses and journal local transactions &nbsp;&nbsp;&nbsp;&nbsp;if local { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.locals.add(from) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;pool.journalTx(from, tx) 最后，如果发现这个账户是本地的，就把它加到一个白名单里，默认会保证本地交易优先被加到txpool中。 至此，TxPool.add()函数就分析完了。 3.1.2 TxPool.promoteExecuteables() 这个函数比上面那个还长。。。主要目的是把交易从queue列表“提拔”到pending列表，代码逻辑比较清楚，具体可以参见下面这张图： 根据不同的目的可以分为3块，分别以粉色、紫色、绿色标识。 &nbsp; 粉色部分主要是为了把queue中的交易“提拔”到pending中。当然在这之前需要先要进行一番检查： &nbsp; 丢弃nonce &lt; 账户当前nonce的交易，也就是已经被打包过的交易 丢弃转账金额 + gas消耗 &gt; 账户余额的交易，也就是会out-of-gas的交易 丢弃gas limit &gt; block gas limit的交易，这部分交易可能会导致区块生成失败 紫色部分主要是为了清理pending列表，使其满足GlobalSlots和AccountSlots的限制条件： &nbsp; 如果有些账户的交易数超过了AccountSlots，则先按交易数最少的账户进行均衡。举例来说，如果有10个账户交易数超过了AccountSlots（默认16），其中交易数最少的账户包含20笔交易，那么先把其他9个账户的交易数量削减到20。 如果经过上面的步骤，pending的长度还是超过了GlobalSlots，那就严格按照AccountSlots进行均衡，也就是把上面的10个账户的交易数进一步削减到16。 绿色部分主要是为了清理queue列表，使其满足GlobalQueue和AccountQueue的限制条件： &nbsp; 如果每个账户的交易数超过了AccountQueue，丢弃多余交易 如果queue的长度超过了GlobalQueue，则把账户按最后一次心跳时间排序，然后依次去除账户中的交易，直到满足限制条件位置。 这里提到一个最后一次心跳时间，其实就是账户最近一次交易的时间，用来作为账户活跃度的判断 具体代码非常长，就不贴了，可以按照上面的图自行对照。 3.2 创建智能合约地址 再贴一下之前创建智能合约地址的代码： addr := crypto.CreateAddress(from, tx.Nonce()) 参数是发送方地址和交易的nonce值，然后调用CreateAddress()方法，代码位于crypto/crypto.go： func CreateAddress(b common.Address, nonce uint64) common.Address { &nbsp;&nbsp;&nbsp;&nbsp;data, _ := rlp.EncodeToBytes([]interface{}{b, nonce}) &nbsp;&nbsp;&nbsp;&nbsp;return common.BytesToAddress(Keccak256(data)[12:]) } 可以看到，就是先对刚刚两个参数进行RLP编码，然后计算hash值，取后20位作为合约地址。 至此，提交交易部分的代码就分析完了。 4. 广播交易 交易提交到txpool中后，还需要广播出去，一方面通知EVM执行该交易，另一方面要把交易信息广播给其他结点。具体调用在3.1.2节中提到的promoteTx()函数中，代码位于crypto/tx_pool.go： func (pool *TxPool) promoteTx(addr common.Address, hash common.Hash, tx *types.Transaction) { …… &nbsp;&nbsp;&nbsp;&nbsp;// Set the potentially new pending nonce and notify any subsystems of the new tx &nbsp;&nbsp;&nbsp;&nbsp;pool.beats[addr] = time.Now() &nbsp;&nbsp;&nbsp;&nbsp;pool.pendingState.SetNonce(addr, tx.Nonce()+1) &nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(TxPreEvent{tx}) } 可以看到，先更新了最后一次心跳时间，然后更新账户的nonce值，最后一行就是发送一个TxPreEvent事件，外部可以通过SubscribeTxPreEvent()函数订阅该事件： func (pool *TxPool) SubscribeTxPreEvent(ch chan&lt;- TxPreEvent) event.Subscription { &nbsp;&nbsp;&nbsp;&nbsp;return pool.scope.Track(pool.txFeed.Subscribe(ch)) } 我们只要搜索一下这个函数，就可以知道哪些组件订阅了该事件了。 4.1 执行交易 第一个订阅的地方位于miner/worker.go： func newWorker(config *params.ChainConfig, engine consensus.Engine, coinbase common.Address, eth Backend, mux *event.TypeMux) *worker { …… &nbsp;&nbsp;&nbsp;&nbsp;// Subscribe TxPreEvent for tx pool &nbsp;&nbsp;&nbsp;&nbsp;worker.txSub = eth.TxPool().SubscribeTxPreEvent(worker.txCh) …… go worker.update() …… } 开启了一个goroutine来接收TxPreEvent，看一下update()函数： func (self *worker) update() { …… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Handle TxPreEvent &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ev := &lt;-self.txCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Apply transaction to the pending state if we&#39;re not mining &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if atomic.LoadInt32(&amp;self.mining) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.currentMu.Lock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc, _ := types.Sender(self.current.signer, ev.Tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txs := map[common.Address]types.Transactions{acc: {ev.Tx}} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txset := types.NewTransactionsByPriceAndNonce(self.current.signer, txs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.current.commitTransactions(self.mux, txset, self.chain, self.coinbase) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.updateSnapshot() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.currentMu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If we&#39;re mining, but nothing is being processed, wake on new transactions &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.config.Clique != nil &amp;&amp; self.config.Clique.Period == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.commitNewWork() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} …… } 可以看到，如果结点不挖矿的话，这里会立即调用commitTransactions()提交给EVM执行，获得本地回执。 如果结点挖矿的话，miner会调用commitNewWork()，内部也会调用commitTransactions()执行交易。 4.2 广播给其他结点 另一个订阅的地方位于eth/handler.go： func (pm *ProtocolManager) Start(maxPeers int) { …… &nbsp;&nbsp;&nbsp;pm.txSub = pm.txpool.SubscribeTxPreEvent(pm.txCh) &nbsp;&nbsp;&nbsp;&nbsp;go pm.txBroadcastLoop() …… } 同样也是启动了一个goroutine来接收TxPreEvent事件，看一下txBroadcastLoop()函数： func (pm *ProtocolManager) txBroadcastLoop() { &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case event := &lt;-pm.txCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pm.BroadcastTx(event.Tx.Hash(), event.Tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Err() channel will be closed when unsubscribing. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-pm.txSub.Err(): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } 继续跟踪BroadcastTx()函数： func (pm *ProtocolManager) BroadcastTx(hash common.Hash, tx *types.Transaction) { &nbsp;&nbsp;&nbsp;&nbsp;// Broadcast transaction to a batch of peers not knowing about it &nbsp;&nbsp;&nbsp;&nbsp;peers := pm.peers.PeersWithoutTx(hash) &nbsp;&nbsp;&nbsp;&nbsp;//FIXME include this again: peers = peers[:int(math.Sqrt(float64(len(peers))))] &nbsp;&nbsp;&nbsp;&nbsp;for _, peer := range peers { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peer.SendTransactions(types.Transactions{tx}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Broadcast transaction&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(peers)) } 可以看到，这里会通过P2P向所有没有该交易的结点发送该交易。 更多文章欢迎关注“鑫鑫点灯”专栏：https://blog.csdn.net/turkeycock/article/category/7669858 或关注飞久微信公众号： 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/05/28/e0a5be93de66bed135b93b98d9dcb4a4.html" />
<meta property="og:url" content="https://mlh.app/2018/05/28/e0a5be93de66bed135b93b98d9dcb4a4.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/TurkeyCock/article/details/80485391 这篇开始分析以太坊交易相关代码。基本流程参见下图： 可以看到，完整流程分为以下几个步骤： &nbsp; 发起交易：指定目标地址和交易金额，以及需要的gas/gaslimit 交易签名：使用账户私钥对交易进行签名 提交交易：把交易加入到交易缓冲池txpool中（会先对交易签名进行验证） 广播交易：通知EVM执行，同时把交易信息广播给其他结点 &nbsp; 下面依次分析这几个部分的源码。 1. 发起交易 用户通过JSON RPC发起eth_sendTransaction请求，最终会调用PublicTransactionPoolAPI 的实现，代码位于internal/ethapi/api.go： func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) { &nbsp;&nbsp;&nbsp;&nbsp;// Look up the wallet containing the requested signer &nbsp;&nbsp;&nbsp;&nbsp;account := accounts.Account{Address: args.From} &nbsp;&nbsp;&nbsp;&nbsp;wallet, err := s.b.AccountManager().Find(account) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if args.Nonce == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Hold the addresse&#39;s mutex around signing to prevent concurrent assignment of &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the same nonce to multiple accounts. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.nonceLock.LockAddr(args.From) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer s.nonceLock.UnlockAddr(args.From) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Set some sanity defaults and terminate on failure &nbsp;&nbsp;&nbsp;&nbsp;if err := args.setDefaults(ctx, s.b); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Assemble the transaction and sign with the wallet &nbsp;&nbsp;&nbsp;&nbsp;tx := args.toTransaction() &nbsp;&nbsp;&nbsp;&nbsp;var chainID *big.Int &nbsp;&nbsp;&nbsp;&nbsp;if config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chainID = config.ChainId &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;signed, err := wallet.SignTx(account, tx, chainID) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return submitTransaction(ctx, s.b, signed) } &nbsp; 首先根据from地址查找到对应的wallet，检查一下参数值，然后做了以下3件事： &nbsp; 通过SendTxArgs.toTransaction()创建交易 通过Wallet.SignTx()对交易进行签名 通过submitTransaction()提交交易 这里先分析创建交易部分。先看一下SendTxArgs类型的定义（internal/ethapi/api.go）： type SendTxArgs struct { &nbsp;&nbsp;&nbsp;&nbsp;From common.Address `json:&quot;from&quot;` &nbsp;&nbsp;&nbsp;&nbsp;To *common.Address `json:&quot;to&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Gas *hexutil.Uint64 `json:&quot;gas&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasPrice *hexutil.Big `json:&quot;gasPrice&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Value *hexutil.Big `json:&quot;value&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Nonce *hexutil.Uint64 `json:&quot;nonce&quot;` &nbsp;&nbsp;&nbsp;&nbsp;// We accept &quot;data&quot; and &quot;input&quot; for backwards-compatibility reasons. &quot;input&quot; is the &nbsp;&nbsp;&nbsp;&nbsp;// newer name and should be preferred by clients. &nbsp;&nbsp;&nbsp;&nbsp;Data *hexutil.Bytes `json:&quot;data&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Input *hexutil.Bytes `json:&quot;input&quot;` } 可以看到是和JSON字段相应的，包括了地址、gas、金额这些交易信息，nonce是一个随账户交易次数自增的数字，一般会自动填充。交易还可以携带一些额外数据，存放在data或者input字段中，推荐用input，data是为了向后兼容。 接着看一下它的toTransaction()函数： func (args *SendTxArgs) toTransaction() *types.Transaction { &nbsp;&nbsp;&nbsp;&nbsp;var input []byte &nbsp;&nbsp;&nbsp;&nbsp;if args.Data != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = *args.Data &nbsp;&nbsp;&nbsp;&nbsp;} else if args.Input != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = *args.Input &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if args.To == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return types.NewContractCreation(uint64(*args.Nonce), (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return types.NewTransaction(uint64(*args.Nonce), *args.To, (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input) } 可以看到，如果目标地址为空的话，表示这是一个创建智能合约的交易，调用NewContractCreation()。否则说明这是一个普通交易，调用NewTransaction()。不管调用哪个，最终都会生成一个Transaction实例，我们看一下Transaction类型的定义，代码位于core/types/transaction.go： type Transaction struct { &nbsp;&nbsp;&nbsp;&nbsp;data txdata &nbsp;&nbsp;&nbsp;&nbsp;// caches &nbsp;&nbsp;&nbsp;&nbsp;hash atomic.Value &nbsp;&nbsp;&nbsp;&nbsp;size atomic.Value &nbsp;&nbsp;&nbsp;&nbsp;from atomic.Value } 主要就是包含了一个txdata类型的字段，其他3个都是缓存。看一下txdata类型的定义： type txdata struct { &nbsp;&nbsp;&nbsp;&nbsp;AccountNonce uint64 `json:&quot;nonce&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Price *big.Int `json:&quot;gasPrice&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;GasLimit uint64 `json:&quot;gas&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Recipient *common.Address `json:&quot;to&quot; rlp:&quot;nil&quot;` // nil means contract creation &nbsp;&nbsp;&nbsp;&nbsp;Amount *big.Int `json:&quot;value&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;Payload []byte `json:&quot;input&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;// Signature values &nbsp;&nbsp;&nbsp;&nbsp;V *big.Int `json:&quot;v&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;R *big.Int `json:&quot;r&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;S *big.Int `json:&quot;s&quot; gencodec:&quot;required&quot;` &nbsp;&nbsp;&nbsp;&nbsp;// This is only used when marshaling to JSON. &nbsp;&nbsp;&nbsp;&nbsp;Hash *common.Hash `json:&quot;hash&quot; rlp:&quot;-&quot;` } 可以看到，除了刚刚那些参数值，还有3个签名字段和1个hash字段。需要注意的是，from地址并不包含在该结构中。 2. 交易签名 创建完Transaction实例以后，会调用Wallet.SignTx()进行签名。具体流程参见下图： 可以看到，是先通过Keccak-256算法计算交易数据的hash值，然后结合账户的私钥，通过ECDSA（Elliptic Curve Digital Signature Algorithm），也就是椭圆曲线数字签名算法生成签名数据。 这里有个疑问，为什么txdata里只有接收方的地址（Recipient），没有发送方的地址呢？那我们如何知道这笔交易的发起人时谁呢？实际上发送方的地址是可以根据交易数据以及签名推算出来的，参见下图： 至于为什么不把发送方地址放到txdata中，是为了故意隐藏发送方信息，还是为了减小数据量，就不得而知了。 下面开始分析代码。上一篇文章分析过，Wallet是一个接口，具体实现在keyStoreWallet中，代码位于accounts/keystore/keystore_wallet.go中： func (w *keystoreWallet) SignTx(account accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;// Make sure the requested account is contained within &nbsp;&nbsp;&nbsp;&nbsp;if account.Address != w.account.Address { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, accounts.ErrUnknownAccount &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if account.URL != (accounts.URL{}) &amp;&amp; account.URL != w.account.URL { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, accounts.ErrUnknownAccount &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Account seems valid, request the keystore to sign &nbsp;&nbsp;&nbsp;&nbsp;return w.keystore.SignTx(account, tx, chainID) } 继续跟踪KeyStore的SignTx()函数，代码位于accounts/keystore/keystore.go中： func (ks *KeyStore) SignTx(a accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;// Look up the key to sign with and abort if it cannot be found &nbsp;&nbsp;&nbsp;&nbsp;ks.mu.RLock() &nbsp;&nbsp;&nbsp;&nbsp;defer ks.mu.RUnlock() &nbsp;&nbsp;&nbsp;&nbsp;unlockedKey, found := ks.unlocked[a.Address] &nbsp;&nbsp;&nbsp;&nbsp;if !found { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, ErrLocked &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Depending on the presence of the chain ID, sign with EIP155 or homestead &nbsp;&nbsp;&nbsp;&nbsp;if chainID != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return types.SignTx(tx, types.NewEIP155Signer(chainID), unlockedKey.PrivateKey) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return types.SignTx(tx, types.HomesteadSigner{}, unlockedKey.PrivateKey) } 这里会首先判断账户是否已经解锁，如果已经解锁的话就可以获取它的私钥。 然后创建签名器，如果要符合EIP155规范的话，需要把chainID传进去，也就是我们的“--networkid”命令行参数。 最后调用一个全局函数SignTx()完成签名，代码位于core/types/transaction_signing.go： func SignTx(tx *Transaction, s Signer, prv *ecdsa.PrivateKey) (*Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;h := s.Hash(tx) &nbsp;&nbsp;&nbsp;&nbsp;sig, err := crypto.Sign(h[:], prv) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return tx.WithSignature(s, sig) } 主要分为3个步骤： &nbsp; 生成交易的hash值 根据hash值和私钥生成签名 把签名数据填充到Transaction实例中 2.1 生成交易的hash值 以EIP155Signer为例，代码如下： func (s EIP155Signer) Hash(tx *Transaction) common.Hash { &nbsp;&nbsp;&nbsp;&nbsp;return rlpHash([]interface{}{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.AccountNonce, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Price, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.GasLimit, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Recipient, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Amount, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Payload, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.chainId, uint(0), uint(0), &nbsp;&nbsp;&nbsp;&nbsp;}) } func rlpHash(x interface{}) (h common.Hash) { &nbsp;&nbsp;&nbsp;&nbsp;hw := sha3.NewKeccak256() &nbsp;&nbsp;&nbsp;&nbsp;rlp.Encode(hw, x) &nbsp;&nbsp;&nbsp;&nbsp;hw.Sum(h[:0]) &nbsp;&nbsp;&nbsp;&nbsp;return h } 可以看到，先用SHA3-256生成hash值，然后再进行RLP编码。RLP是一种数据序列化方法，后面有时间再写文章分析。 2.2 根据hash值和私钥生成签名 crypto.Sign()函数代码位于crypto/signature_cgo.go： // Sign calculates an ECDSA signature. // The produced signature is in the [R || S || V] format where V is 0 or 1. func Sign(hash []byte, prv *ecdsa.PrivateKey) (sig []byte, err error) { &nbsp;&nbsp;&nbsp;&nbsp;if len(hash) != 32 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, fmt.Errorf(&quot;hash is required to be exactly 32 bytes (%d)&quot;, len(hash)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;seckey := math.PaddedBigBytes(prv.D, prv.Params().BitSize/8) &nbsp;&nbsp;&nbsp;&nbsp;defer zeroBytes(seckey) &nbsp;&nbsp;&nbsp;&nbsp;return secp256k1.Sign(hash, seckey) } 这里是通过ECDSA算法生成签名数据，水平有限就不继续分析了。最终会返回的签名是一个字节数组，按R / S / V的顺序排列。 2.3 填充签名数据 最后一步就是把签名数据的这3个值填充到Transaction结构中了，看一下WithSignature()函数，代码位于core/types/transaction.go： func (tx *Transaction) WithSignature(signer Signer, sig []byte) (*Transaction, error) { &nbsp;&nbsp;&nbsp;&nbsp;r, s, v, err := signer.SignatureValues(tx, sig) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;cpy := &amp;Transaction{data: tx.data} &nbsp;&nbsp;&nbsp;&nbsp;cpy.data.R, cpy.data.S, cpy.data.V = r, s, v &nbsp;&nbsp;&nbsp;&nbsp;return cpy, nil } 生成的签名数据是字节数组类型，需要通过signer.SignatureValues()函数转换成3个big.Int类型的数据，然后填充到Transaction结构的R / S / V字段上。可以瞄一眼这个转换函数： func (fs FrontierSigner) SignatureValues(tx *Transaction, sig []byte) (r, s, v *big.Int, err error) { &nbsp;&nbsp;&nbsp;&nbsp;if len(sig) != 65 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Sprintf(&quot;wrong size for signature: got %d, want 65&quot;, len(sig))) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;r = new(big.Int).SetBytes(sig[:32]) &nbsp;&nbsp;&nbsp;&nbsp;s = new(big.Int).SetBytes(sig[32:64]) &nbsp;&nbsp;&nbsp;&nbsp;v = new(big.Int).SetBytes([]byte{sig[64] + 27}) &nbsp;&nbsp;&nbsp;&nbsp;return r, s, v, nil } 第0～31字节是R，第32～63字节是S，第64位加上27就可以得到V。 &nbsp; 3. 提交交易 签名完成以后，就需要调用submitTransaction()函数提交到交易缓冲池txpool中。 在分析代码之前，先看下TxPool中的几个重要字段： &nbsp;&nbsp;&nbsp;&nbsp;pending map[common.Address]*txList // All currently processable transactions &nbsp;&nbsp;&nbsp;&nbsp;queue map[common.Address]*txList // Queued but non-processable transactions &nbsp;&nbsp;&nbsp;&nbsp;all map[common.Hash]*types.Transaction // All transactions to allow lookups &nbsp;&nbsp;&nbsp;&nbsp;priced *txPricedList // All transactions sorted by price pending字段中包含了当前所有可被处理的交易列表，而queue字段中包含了所有不可被处理、也就是新加入进来的交易。它们是按账号地址来组织的，每个地址对应一个txList，具体内部结构参见下图： &nbsp; 可以看到txList内部包含一个txSortedMap结构，实现按nonce排序，其内部维护了两张表： &nbsp; 一张是包含了所有Transaction的map，key是Transaction的nonce值。之前提到过，这个nonce是随着账户的交易次数自增的一个数字，所以越新的交易，nonce值越高。 还有一张表是一个数组，包含了所有nonce值，其内部是进行过堆排序的（小顶堆），nonce值按照从大到小排列。每次调用heap.Pop()时会取出最小的nonce值，也就是最老的交易。 all字段中包含了所有的交易列表，以交易的hash作为key。 priced字段则是把all中的交易列表按照gas price从大到小排列，如果gas price一样，则按照交易的nonce值从小到大排列。最终的目标是每次取出gas price最大、nonce最小的交易。 我们提交交易的目标是：先把交易放入queue中记录在案，然后再从queue中选一部分放入pending中进行处理。如果发现txpool满了，则依据priced中的排序，剔除低油价的交易。 另外，如果是本地（local）提交的交易，默认情况下会尽可能地保证被放入txpool中，除非显式关闭该配置。 接着我们看一下txpool的默认配置： var DefaultTxPoolConfig = TxPoolConfig{ Journal: &quot;transactions.rlp&quot;, Rejournal: time.Hour, PriceLimit: 1, PriceBump: 10, AccountSlots: 16, GlobalSlots: 4096, AccountQueue: 64, GlobalQueue: 1024, Lifetime: 3 * time.Hour, } &nbsp; &nbsp; GlobalSlots：pending列表的最大长度，默认4096笔 AccountSlots：pending中每个账户存储的交易数的阈值，超过这个数量可能会被认为是垃圾交易或者是攻击者，多余交易可能被丢弃 GlobalQueue：queue列表的最大长度，默认1024笔 AccountQueue：queue中每个账户允许存储的最大交易数，超过会被丢弃，默认64笔 PriceLimit：允许进入txpool的最低gas price，默认1 Gwei PriceBump：如果出现两个nonce相同的交易，gas price的差值超过该阈值则用新交易替换老交易 好，现在我们回到internal/ethapi/api.go，分析submitTransaction()函数： func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) { &nbsp;&nbsp;&nbsp;&nbsp;if err := b.SendTx(ctx, tx); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if tx.To() == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signer := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, err := types.Sender(signer, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr := crypto.CreateAddress(from, tx.Nonce()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Info(&quot;Submitted contract creation&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;contract&quot;, addr.Hex()) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Info(&quot;Submitted transaction&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;recipient&quot;, tx.To()) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return tx.Hash(), nil } 这里有一个Backend参数，是在eth Service初始化时创建的，具体实现在EthApiBackend中，代码位于eth/api_backend.go。可以看到，这里先调用了SendTx()函数提交交易，然后如果发现目标地址为空，表明这是一个创建智能合约的交易，会创建合约地址。下面分别进行分析。 3.1 提交交易到txpool func (b *EthApiBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return b.eth.txPool.AddLocal(signedTx) } 继续跟踪TxPool的AddLocal()函数： func (pool *TxPool) AddLocal(tx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return pool.addTx(tx, !pool.config.NoLocals) } func (pool *TxPool) addTx(tx *types.Transaction, local bool) error { &nbsp;&nbsp;&nbsp;&nbsp;pool.mu.Lock() &nbsp;&nbsp;&nbsp;&nbsp;defer pool.mu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;// Try to inject the transaction and update any state &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.add(tx, local) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// If we added a new transaction, run promotion checks and return &nbsp;&nbsp;&nbsp;&nbsp;if !replace { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.promoteExecutables([]common.Address{from}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return nil } 这里有两个主要函数：add()和promoteExecuteables()。 add()会判断是否应该把当前交易加入到queue列表中，promoteExecuteables()则会从queue中选取一些交易放入pending列表中等待执行。下面分别讨论这两个函数。 3.1.1 TxPool.add() 这个函数比较长，我们分成一段一段的来分析： &nbsp;&nbsp;&nbsp;&nbsp;// If the transaction is already known, discard it &nbsp;&nbsp;&nbsp;&nbsp;hash := tx.Hash() &nbsp;&nbsp;&nbsp;&nbsp;if pool.all[hash] != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding already known transaction&quot;, &quot;hash&quot;, hash) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, fmt.Errorf(&quot;known transaction: %x&quot;, hash) &nbsp;&nbsp;&nbsp;&nbsp;} 这一段是先计算交易的hash值，然后判断是不是已经在txpool 中，在的话就直接退出。 &nbsp;&nbsp;&nbsp;&nbsp;if err := pool.validateTx(tx, local); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding invalid transaction&quot;, &quot;hash&quot;, hash, &quot;err&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalidTxCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err &nbsp;&nbsp;&nbsp;&nbsp;} 这一段是验证交易的有效性，主要进行以下几个方面的检查： &nbsp; 数据量必须&lt;32KB 交易金额必须非负（&gt;=0） 交易的gas limit必须低于block的gas limit 签名数据必须有效，能够解析出发送者地址 交易的gas price必须高于pool设定的最低gas price（除非是本地交易） 交易的nonce值必须高于当前链上该账户的nonce值（低于则说明这笔交易已经被打包过了） 当前账户余额必须大于“交易金额 + gasprice * gaslimit” 交易的gas limit必须大于对应数据量所需的最低gas水平 &nbsp;&nbsp;&nbsp;&nbsp;// If the transaction pool is full, discard underpriced transactions &nbsp;&nbsp;&nbsp;&nbsp;if uint64(len(pool.all)) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the new transaction is underpriced, don&#39;t accept it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding underpriced transaction&quot;, &quot;hash&quot;, hash, &quot;price&quot;, tx.GasPrice()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underpricedTxCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, ErrUnderpriced &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// New transaction is better than our worse ones, make room for it &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drop := pool.priced.Discard(len(pool.all)-int(pool.config.GlobalSlots+pool.config.GlobalQueue-1), pool.locals) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range drop { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Discarding freshly underpriced transaction&quot;, &quot;hash&quot;, tx.Hash(), &quot;price&quot;, tx.GasPrice()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underpricedTxCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.removeTx(tx.Hash(), false) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; 这一段是在当前txpool已满的情况下，剔除掉低油价的交易。还记得之前有个priced字段存储了按gas price以及nonce排序的交易列表吗？这里会先把当前交易的gas price和当前池中的最低价进行比较： &nbsp; 如果低于最低价，直接丢弃该交易返回 如果高于最低价，则从txpool中剔除一些低价的交易 &nbsp;&nbsp;&nbsp;&nbsp;// If the transaction is replacing an already pending one, do directly &nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated &nbsp;&nbsp;&nbsp;&nbsp;if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Nonce already pending, check if required price bump is met &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inserted, old := list.Add(tx, pool.config.PriceBump) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !inserted { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pendingDiscardCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, ErrReplaceUnderpriced &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// New transaction is better, replace old one &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if old != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete(pool.all, old.Hash()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pendingReplaceCounter.Inc(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all[tx.Hash()] = tx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Put(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.journalTx(from, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Pooled new executable transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We&#39;ve directly injected a replacement transaction, notify subsystems &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(TxPreEvent{tx}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return old != nil, nil &nbsp;&nbsp;&nbsp;&nbsp;} 这一段是为了处理两个交易nonce相同的问题。如果用户发起了一笔交易，在还没有被执行之前又用同样的nonce发起了另一笔交易，则只会保留gas price高的那一笔。这个list.Overlaps()函数就是用来判断pending列表中是否包含相同nonce的交易的。 &nbsp;&nbsp;&nbsp;&nbsp;// New transaction isn&#39;t replacing a pending one, push into queue &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.enqueueTx(hash, tx) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err &nbsp;&nbsp;&nbsp;&nbsp;} 如果之前的那些检查都没有问题，就真正调用enqueueTx()函数把交易加入到queue列表中了。 &nbsp;&nbsp;&nbsp;&nbsp;// Mark local addresses and journal local transactions &nbsp;&nbsp;&nbsp;&nbsp;if local { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.locals.add(from) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;pool.journalTx(from, tx) 最后，如果发现这个账户是本地的，就把它加到一个白名单里，默认会保证本地交易优先被加到txpool中。 至此，TxPool.add()函数就分析完了。 3.1.2 TxPool.promoteExecuteables() 这个函数比上面那个还长。。。主要目的是把交易从queue列表“提拔”到pending列表，代码逻辑比较清楚，具体可以参见下面这张图： 根据不同的目的可以分为3块，分别以粉色、紫色、绿色标识。 &nbsp; 粉色部分主要是为了把queue中的交易“提拔”到pending中。当然在这之前需要先要进行一番检查： &nbsp; 丢弃nonce &lt; 账户当前nonce的交易，也就是已经被打包过的交易 丢弃转账金额 + gas消耗 &gt; 账户余额的交易，也就是会out-of-gas的交易 丢弃gas limit &gt; block gas limit的交易，这部分交易可能会导致区块生成失败 紫色部分主要是为了清理pending列表，使其满足GlobalSlots和AccountSlots的限制条件： &nbsp; 如果有些账户的交易数超过了AccountSlots，则先按交易数最少的账户进行均衡。举例来说，如果有10个账户交易数超过了AccountSlots（默认16），其中交易数最少的账户包含20笔交易，那么先把其他9个账户的交易数量削减到20。 如果经过上面的步骤，pending的长度还是超过了GlobalSlots，那就严格按照AccountSlots进行均衡，也就是把上面的10个账户的交易数进一步削减到16。 绿色部分主要是为了清理queue列表，使其满足GlobalQueue和AccountQueue的限制条件： &nbsp; 如果每个账户的交易数超过了AccountQueue，丢弃多余交易 如果queue的长度超过了GlobalQueue，则把账户按最后一次心跳时间排序，然后依次去除账户中的交易，直到满足限制条件位置。 这里提到一个最后一次心跳时间，其实就是账户最近一次交易的时间，用来作为账户活跃度的判断 具体代码非常长，就不贴了，可以按照上面的图自行对照。 3.2 创建智能合约地址 再贴一下之前创建智能合约地址的代码： addr := crypto.CreateAddress(from, tx.Nonce()) 参数是发送方地址和交易的nonce值，然后调用CreateAddress()方法，代码位于crypto/crypto.go： func CreateAddress(b common.Address, nonce uint64) common.Address { &nbsp;&nbsp;&nbsp;&nbsp;data, _ := rlp.EncodeToBytes([]interface{}{b, nonce}) &nbsp;&nbsp;&nbsp;&nbsp;return common.BytesToAddress(Keccak256(data)[12:]) } 可以看到，就是先对刚刚两个参数进行RLP编码，然后计算hash值，取后20位作为合约地址。 至此，提交交易部分的代码就分析完了。 4. 广播交易 交易提交到txpool中后，还需要广播出去，一方面通知EVM执行该交易，另一方面要把交易信息广播给其他结点。具体调用在3.1.2节中提到的promoteTx()函数中，代码位于crypto/tx_pool.go： func (pool *TxPool) promoteTx(addr common.Address, hash common.Hash, tx *types.Transaction) { …… &nbsp;&nbsp;&nbsp;&nbsp;// Set the potentially new pending nonce and notify any subsystems of the new tx &nbsp;&nbsp;&nbsp;&nbsp;pool.beats[addr] = time.Now() &nbsp;&nbsp;&nbsp;&nbsp;pool.pendingState.SetNonce(addr, tx.Nonce()+1) &nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(TxPreEvent{tx}) } 可以看到，先更新了最后一次心跳时间，然后更新账户的nonce值，最后一行就是发送一个TxPreEvent事件，外部可以通过SubscribeTxPreEvent()函数订阅该事件： func (pool *TxPool) SubscribeTxPreEvent(ch chan&lt;- TxPreEvent) event.Subscription { &nbsp;&nbsp;&nbsp;&nbsp;return pool.scope.Track(pool.txFeed.Subscribe(ch)) } 我们只要搜索一下这个函数，就可以知道哪些组件订阅了该事件了。 4.1 执行交易 第一个订阅的地方位于miner/worker.go： func newWorker(config *params.ChainConfig, engine consensus.Engine, coinbase common.Address, eth Backend, mux *event.TypeMux) *worker { …… &nbsp;&nbsp;&nbsp;&nbsp;// Subscribe TxPreEvent for tx pool &nbsp;&nbsp;&nbsp;&nbsp;worker.txSub = eth.TxPool().SubscribeTxPreEvent(worker.txCh) …… go worker.update() …… } 开启了一个goroutine来接收TxPreEvent，看一下update()函数： func (self *worker) update() { …… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Handle TxPreEvent &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ev := &lt;-self.txCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Apply transaction to the pending state if we&#39;re not mining &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if atomic.LoadInt32(&amp;self.mining) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.currentMu.Lock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc, _ := types.Sender(self.current.signer, ev.Tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txs := map[common.Address]types.Transactions{acc: {ev.Tx}} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txset := types.NewTransactionsByPriceAndNonce(self.current.signer, txs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.current.commitTransactions(self.mux, txset, self.chain, self.coinbase) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.updateSnapshot() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.currentMu.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If we&#39;re mining, but nothing is being processed, wake on new transactions &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.config.Clique != nil &amp;&amp; self.config.Clique.Period == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.commitNewWork() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} …… } 可以看到，如果结点不挖矿的话，这里会立即调用commitTransactions()提交给EVM执行，获得本地回执。 如果结点挖矿的话，miner会调用commitNewWork()，内部也会调用commitTransactions()执行交易。 4.2 广播给其他结点 另一个订阅的地方位于eth/handler.go： func (pm *ProtocolManager) Start(maxPeers int) { …… &nbsp;&nbsp;&nbsp;pm.txSub = pm.txpool.SubscribeTxPreEvent(pm.txCh) &nbsp;&nbsp;&nbsp;&nbsp;go pm.txBroadcastLoop() …… } 同样也是启动了一个goroutine来接收TxPreEvent事件，看一下txBroadcastLoop()函数： func (pm *ProtocolManager) txBroadcastLoop() { &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case event := &lt;-pm.txCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pm.BroadcastTx(event.Tx.Hash(), event.Tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Err() channel will be closed when unsubscribing. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-pm.txSub.Err(): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } 继续跟踪BroadcastTx()函数： func (pm *ProtocolManager) BroadcastTx(hash common.Hash, tx *types.Transaction) { &nbsp;&nbsp;&nbsp;&nbsp;// Broadcast transaction to a batch of peers not knowing about it &nbsp;&nbsp;&nbsp;&nbsp;peers := pm.peers.PeersWithoutTx(hash) &nbsp;&nbsp;&nbsp;&nbsp;//FIXME include this again: peers = peers[:int(math.Sqrt(float64(len(peers))))] &nbsp;&nbsp;&nbsp;&nbsp;for _, peer := range peers { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peer.SendTransactions(types.Transactions{tx}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;log.Trace(&quot;Broadcast transaction&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(peers)) } 可以看到，这里会通过P2P向所有没有该交易的结点发送该交易。 更多文章欢迎关注“鑫鑫点灯”专栏：https://blog.csdn.net/turkeycock/article/category/7669858 或关注飞久微信公众号： 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/05/28/e0a5be93de66bed135b93b98d9dcb4a4.html","headline":"以太坊交易源码分析","dateModified":"2018-05-28T00:00:00+08:00","datePublished":"2018-05-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/05/28/e0a5be93de66bed135b93b98d9dcb4a4.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊交易源码分析</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/TurkeyCock/article/details/80485391 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-7f5a1a725b.css"> 
 <div class="htmledit_views"> 
  <p>这篇开始分析以太坊交易相关代码。基本流程参见下图：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180528174051167"></p> 
  <p>可以看到，完整流程分为以下几个步骤：</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>发起交易：指定目标地址和交易金额，以及需要的gas/gaslimit</li> 
   <li>交易签名：使用账户私钥对交易进行签名</li> 
   <li>提交交易：把交易加入到交易缓冲池txpool中（会先对交易签名进行验证）</li> 
   <li>广播交易：通知EVM执行，同时把交易信息广播给其他结点</li> 
  </ul>
  <p>&nbsp;</p> 
  <p>下面依次分析这几个部分的源码。</p> 
  <h1>1. 发起交易</h1> 
  <p>用户通过JSON RPC发起eth_sendTransaction请求，最终会调用PublicTransactionPoolAPI</p> 
  <p>的实现，代码位于internal/ethapi/api.go：</p> 
  <pre class="has">
<code class="language-plain">func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) {

&nbsp;&nbsp;&nbsp;&nbsp;// Look up the wallet containing the requested signer
&nbsp;&nbsp;&nbsp;&nbsp;account := accounts.Account{Address: args.From}

&nbsp;&nbsp;&nbsp;&nbsp;wallet, err := s.b.AccountManager().Find(account)
&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;if args.Nonce == nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Hold the addresse's mutex around signing to prevent concurrent assignment of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the same nonce to multiple accounts.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.nonceLock.LockAddr(args.From)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer s.nonceLock.UnlockAddr(args.From)
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Set some sanity defaults and terminate on failure
&nbsp;&nbsp;&nbsp;&nbsp;if err := args.setDefaults(ctx, s.b); err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Assemble the transaction and sign with the wallet
&nbsp;&nbsp;&nbsp;&nbsp;tx := args.toTransaction()

&nbsp;&nbsp;&nbsp;&nbsp;var chainID *big.Int
&nbsp;&nbsp;&nbsp;&nbsp;if config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chainID = config.ChainId
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;signed, err := wallet.SignTx(account, tx, chainID)
&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return submitTransaction(ctx, s.b, signed)
}</code></pre> 
  <p>&nbsp;</p> 
  <p>首先根据from地址查找到对应的wallet，检查一下参数值，然后做了以下3件事：</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>通过SendTxArgs.toTransaction()创建交易</li> 
   <li>通过Wallet.SignTx()对交易进行签名</li> 
   <li>通过submitTransaction()提交交易</li> 
  </ul>
  <p>这里先分析创建交易部分。先看一下SendTxArgs类型的定义（internal/ethapi/api.go）：</p> 
  <pre class="has">
<code class="language-plain">type SendTxArgs struct {
&nbsp;&nbsp;&nbsp;&nbsp;From     common.Address  `json:"from"`
&nbsp;&nbsp;&nbsp;&nbsp;To       *common.Address `json:"to"`
&nbsp;&nbsp;&nbsp;&nbsp;Gas      *hexutil.Uint64 `json:"gas"`
&nbsp;&nbsp;&nbsp;&nbsp;GasPrice *hexutil.Big    `json:"gasPrice"`
&nbsp;&nbsp;&nbsp;&nbsp;Value    *hexutil.Big    `json:"value"`
&nbsp;&nbsp;&nbsp;&nbsp;Nonce    *hexutil.Uint64 `json:"nonce"`
&nbsp;&nbsp;&nbsp;&nbsp;// We accept "data" and "input" for backwards-compatibility reasons. "input" is the
&nbsp;&nbsp;&nbsp;&nbsp;// newer name and should be preferred by clients.
&nbsp;&nbsp;&nbsp;&nbsp;Data  *hexutil.Bytes `json:"data"`
&nbsp;&nbsp;&nbsp;&nbsp;Input *hexutil.Bytes `json:"input"`
}</code></pre> 
  <p>可以看到是和JSON字段相应的，包括了地址、gas、金额这些交易信息，nonce是一个随账户交易次数自增的数字，一般会自动填充。交易还可以携带一些额外数据，存放在data或者input字段中，推荐用input，data是为了向后兼容。</p> 
  <p>接着看一下它的toTransaction()函数：</p> 
  <pre class="has">
<code class="language-plain">func (args *SendTxArgs) toTransaction() *types.Transaction {
&nbsp;&nbsp;&nbsp;&nbsp;var input []byte
&nbsp;&nbsp;&nbsp;&nbsp;if args.Data != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = *args.Data
&nbsp;&nbsp;&nbsp;&nbsp;} else if args.Input != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = *args.Input
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if args.To == nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return types.NewContractCreation(uint64(*args.Nonce), (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return types.NewTransaction(uint64(*args.Nonce), *args.To, (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input)
}</code></pre> 
  <p>可以看到，如果目标地址为空的话，表示这是一个创建智能合约的交易，调用NewContractCreation()。否则说明这是一个普通交易，调用NewTransaction()。不管调用哪个，最终都会生成一个Transaction实例，我们看一下Transaction类型的定义，代码位于core/types/transaction.go：</p> 
  <pre class="has">
<code class="language-plain">type Transaction struct {
&nbsp;&nbsp;&nbsp;&nbsp;data txdata
&nbsp;&nbsp;&nbsp;&nbsp;// caches
&nbsp;&nbsp;&nbsp;&nbsp;hash atomic.Value
&nbsp;&nbsp;&nbsp;&nbsp;size atomic.Value
&nbsp;&nbsp;&nbsp;&nbsp;from atomic.Value
}</code></pre> 
  <p>主要就是包含了一个txdata类型的字段，其他3个都是缓存。看一下txdata类型的定义：</p> 
  <pre class="has">
<code class="language-plain">type txdata struct {
&nbsp;&nbsp;&nbsp;&nbsp;AccountNonce uint64          `json:"nonce"    gencodec:"required"`
&nbsp;&nbsp;&nbsp;&nbsp;Price        *big.Int        `json:"gasPrice" gencodec:"required"`
&nbsp;&nbsp;&nbsp;&nbsp;GasLimit     uint64          `json:"gas"      gencodec:"required"`
&nbsp;&nbsp;&nbsp;&nbsp;Recipient    *common.Address `json:"to"       rlp:"nil"` // nil means contract creation
&nbsp;&nbsp;&nbsp;&nbsp;Amount       *big.Int        `json:"value"    gencodec:"required"`
&nbsp;&nbsp;&nbsp;&nbsp;Payload      []byte          `json:"input"    gencodec:"required"`

&nbsp;&nbsp;&nbsp;&nbsp;// Signature values
&nbsp;&nbsp;&nbsp;&nbsp;V *big.Int `json:"v" gencodec:"required"`
&nbsp;&nbsp;&nbsp;&nbsp;R *big.Int `json:"r" gencodec:"required"`
&nbsp;&nbsp;&nbsp;&nbsp;S *big.Int `json:"s" gencodec:"required"`

&nbsp;&nbsp;&nbsp;&nbsp;// This is only used when marshaling to JSON.
&nbsp;&nbsp;&nbsp;&nbsp;Hash *common.Hash `json:"hash" rlp:"-"`
}</code></pre> 
  <p>可以看到，除了刚刚那些参数值，还有3个签名字段和1个hash字段。需要注意的是，from地址并不包含在该结构中。</p> 
  <h1>2. 交易签名</h1> 
  <p>创建完Transaction实例以后，会调用Wallet.SignTx()进行签名。具体流程参见下图：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018052817510579"></p> 
  <p>可以看到，是先通过Keccak-256算法计算交易数据的hash值，然后结合账户的私钥，通过ECDSA（Elliptic Curve Digital Signature Algorithm），也就是椭圆曲线数字签名算法生成签名数据。</p> 
  <p>这里有个疑问，为什么txdata里只有接收方的地址（Recipient），没有发送方的地址呢？那我们如何知道这笔交易的发起人时谁呢？实际上发送方的地址是可以根据交易数据以及签名推算出来的，参见下图：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180528175134792"></p> 
  <p>至于为什么不把发送方地址放到txdata中，是为了故意隐藏发送方信息，还是为了减小数据量，就不得而知了。</p> 
  <p>下面开始分析代码。上一篇文章分析过，Wallet是一个接口，具体实现在keyStoreWallet中，代码位于accounts/keystore/keystore_wallet.go中：</p> 
  <pre class="has">
<code class="language-plain">func (w *keystoreWallet) SignTx(account accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) {
&nbsp;&nbsp;&nbsp;&nbsp;// Make sure the requested account is contained within
&nbsp;&nbsp;&nbsp;&nbsp;if account.Address != w.account.Address {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, accounts.ErrUnknownAccount
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if account.URL != (accounts.URL{}) &amp;&amp; account.URL != w.account.URL {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, accounts.ErrUnknownAccount
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Account seems valid, request the keystore to sign
&nbsp;&nbsp;&nbsp;&nbsp;return w.keystore.SignTx(account, tx, chainID)
}</code></pre> 
  <p>继续跟踪KeyStore的SignTx()函数，代码位于accounts/keystore/keystore.go中：</p> 
  <pre class="has">
<code class="language-plain">func (ks *KeyStore) SignTx(a accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) {
&nbsp;&nbsp;&nbsp;&nbsp;// Look up the key to sign with and abort if it cannot be found
&nbsp;&nbsp;&nbsp;&nbsp;ks.mu.RLock()
&nbsp;&nbsp;&nbsp;&nbsp;defer ks.mu.RUnlock()

&nbsp;&nbsp;&nbsp;&nbsp;unlockedKey, found := ks.unlocked[a.Address]
&nbsp;&nbsp;&nbsp;&nbsp;if !found {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, ErrLocked
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// Depending on the presence of the chain ID, sign with EIP155 or homestead
&nbsp;&nbsp;&nbsp;&nbsp;if chainID != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return types.SignTx(tx, types.NewEIP155Signer(chainID), unlockedKey.PrivateKey)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return types.SignTx(tx, types.HomesteadSigner{}, unlockedKey.PrivateKey)
}</code></pre> 
  <p>这里会首先判断账户是否已经解锁，如果已经解锁的话就可以获取它的私钥。</p> 
  <p>然后创建签名器，如果要符合EIP155规范的话，需要把chainID传进去，也就是我们的“--networkid”命令行参数。</p> 
  <p>最后调用一个全局函数SignTx()完成签名，代码位于core/types/transaction_signing.go：</p> 
  <pre class="has">
<code class="language-plain">func SignTx(tx *Transaction, s Signer, prv *ecdsa.PrivateKey) (*Transaction, error) {
&nbsp;&nbsp;&nbsp;&nbsp;h := s.Hash(tx)
&nbsp;&nbsp;&nbsp;&nbsp;sig, err := crypto.Sign(h[:], prv)
&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return tx.WithSignature(s, sig)
}</code></pre> 
  <p>主要分为3个步骤：</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>生成交易的hash值</li> 
   <li>根据hash值和私钥生成签名</li> 
   <li>把签名数据填充到Transaction实例中</li> 
  </ul>
  <h2>2.1 生成交易的hash值</h2> 
  <p>以EIP155Signer为例，代码如下：</p> 
  <pre class="has">
<code class="language-plain">func (s EIP155Signer) Hash(tx *Transaction) common.Hash {
&nbsp;&nbsp;&nbsp;&nbsp;return rlpHash([]interface{}{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.AccountNonce,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Price,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.GasLimit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Recipient,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Amount,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.data.Payload,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.chainId, uint(0), uint(0),
&nbsp;&nbsp;&nbsp;&nbsp;})
}

func rlpHash(x interface{}) (h common.Hash) {
&nbsp;&nbsp;&nbsp;&nbsp;hw := sha3.NewKeccak256()
&nbsp;&nbsp;&nbsp;&nbsp;rlp.Encode(hw, x)
&nbsp;&nbsp;&nbsp;&nbsp;hw.Sum(h[:0])
&nbsp;&nbsp;&nbsp;&nbsp;return h
}</code></pre> 
  <p>可以看到，先用SHA3-256生成hash值，然后再进行RLP编码。RLP是一种数据序列化方法，后面有时间再写文章分析。</p> 
  <h2>2.2 根据hash值和私钥生成签名</h2> 
  <p>crypto.Sign()函数代码位于crypto/signature_cgo.go：</p> 
  <pre class="has">
<code class="language-plain">// Sign calculates an ECDSA signature.
// The produced signature is in the [R || S || V] format where V is 0 or 1.

func Sign(hash []byte, prv *ecdsa.PrivateKey) (sig []byte, err error) {
&nbsp;&nbsp;&nbsp;&nbsp;if len(hash) != 32 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, fmt.Errorf("hash is required to be exactly 32 bytes (%d)", len(hash))
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;seckey := math.PaddedBigBytes(prv.D, prv.Params().BitSize/8)
&nbsp;&nbsp;&nbsp;&nbsp;defer zeroBytes(seckey)
&nbsp;&nbsp;&nbsp;&nbsp;return secp256k1.Sign(hash, seckey)
}</code></pre> 
  <p>这里是通过ECDSA算法生成签名数据，水平有限就不继续分析了。最终会返回的签名是一个字节数组，按R / S / V的顺序排列。</p> 
  <h2>2.3 填充签名数据</h2> 
  <p>最后一步就是把签名数据的这3个值填充到Transaction结构中了，看一下WithSignature()函数，代码位于core/types/transaction.go：</p> 
  <pre class="has">
<code class="language-plain">func (tx *Transaction) WithSignature(signer Signer, sig []byte) (*Transaction, error) {
&nbsp;&nbsp;&nbsp;&nbsp;r, s, v, err := signer.SignatureValues(tx, sig)
&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, err
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;cpy := &amp;Transaction{data: tx.data}
&nbsp;&nbsp;&nbsp;&nbsp;cpy.data.R, cpy.data.S, cpy.data.V = r, s, v
&nbsp;&nbsp;&nbsp;&nbsp;return cpy, nil
}</code></pre> 
  <p>生成的签名数据是字节数组类型，需要通过signer.SignatureValues()函数转换成3个big.Int类型的数据，然后填充到Transaction结构的R / S / V字段上。可以瞄一眼这个转换函数：</p> 
  <pre class="has">
<code class="language-plain">func (fs FrontierSigner) SignatureValues(tx *Transaction, sig []byte) (r, s, v *big.Int, err error) {
&nbsp;&nbsp;&nbsp;&nbsp;if len(sig) != 65 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Sprintf("wrong size for signature: got %d, want 65", len(sig)))
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;r = new(big.Int).SetBytes(sig[:32])
&nbsp;&nbsp;&nbsp;&nbsp;s = new(big.Int).SetBytes(sig[32:64])
&nbsp;&nbsp;&nbsp;&nbsp;v = new(big.Int).SetBytes([]byte{sig[64] + 27})
&nbsp;&nbsp;&nbsp;&nbsp;return r, s, v, nil
}</code></pre> 
  <p>第0～31字节是R，第32～63字节是S，第64位加上27就可以得到V。</p> 
  <p>&nbsp;</p> 
  <h1>3. 提交交易</h1> 
  <p>签名完成以后，就需要调用submitTransaction()函数提交到交易缓冲池txpool中。</p> 
  <p>在分析代码之前，先看下TxPool中的几个重要字段：</p> 
  <pre class="has">
<code class="language-plain">&nbsp;&nbsp;&nbsp;&nbsp;pending map[common.Address]*txList         // All currently processable transactions
&nbsp;&nbsp;&nbsp;&nbsp;queue   map[common.Address]*txList         // Queued but non-processable transactions
&nbsp;&nbsp;&nbsp;&nbsp;all     map[common.Hash]*types.Transaction // All transactions to allow lookups
&nbsp;&nbsp;&nbsp;&nbsp;priced  *txPricedList                      // All transactions sorted by price</code></pre> 
  <p>pending字段中包含了当前所有可被处理的交易列表，而queue字段中包含了所有不可被处理、也就是新加入进来的交易。它们是按账号地址来组织的，每个地址对应一个txList，具体内部结构参见下图：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180528175625558"></p> 
  <p>&nbsp;</p> 
  <p>可以看到txList内部包含一个txSortedMap结构，实现按nonce排序，其内部维护了两张表：</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>一张是包含了所有Transaction的map，key是Transaction的nonce值。之前提到过，这个nonce是随着账户的交易次数自增的一个数字，所以越新的交易，nonce值越高。</li> 
   <li>还有一张表是一个数组，包含了所有nonce值，其内部是进行过堆排序的（小顶堆），nonce值按照从大到小排列。每次调用heap.Pop()时会取出最小的nonce值，也就是最老的交易。</li> 
  </ul>
  <p>all字段中包含了所有的交易列表，以交易的hash作为key。</p> 
  <p>priced字段则是把all中的交易列表按照gas price从大到小排列，如果gas price一样，则按照交易的nonce值从小到大排列。最终的目标是每次取出gas price最大、nonce最小的交易。</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180528175849187"></p> 
  <p>我们提交交易的目标是：<strong>先把交易放入queue中记录在案，然后再从queue中选一部分放入pending中进行处理。如果发现txpool满了，则依据priced中的排序，剔除低油价的交易</strong>。</p> 
  <p>另外，如果是本地（local）提交的交易，默认情况下会尽可能地保证被放入txpool中，除非显式关闭该配置。</p> 
  <p>接着我们看一下txpool的默认配置：</p> 
  <pre class="has">
<code class="language-plain">var DefaultTxPoolConfig = TxPoolConfig{
        Journal:   "transactions.rlp",
        Rejournal: time.Hour,

        PriceLimit: 1,
        PriceBump:  10,

        AccountSlots: 16,
        GlobalSlots:  4096,
        AccountQueue: 64,
        GlobalQueue:  1024,

        Lifetime: 3 * time.Hour,
}</code></pre> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>GlobalSlots：pending列表的最大长度，默认4096笔</li> 
   <li>AccountSlots：pending中每个账户存储的交易数的阈值，超过这个数量可能会被认为是垃圾交易或者是攻击者，多余交易可能被丢弃</li> 
   <li>GlobalQueue：queue列表的最大长度，默认1024笔</li> 
   <li>AccountQueue：queue中每个账户允许存储的最大交易数，超过会被丢弃，默认64笔</li> 
   <li>PriceLimit：允许进入txpool的最低gas price，默认1 Gwei</li> 
   <li>PriceBump：如果出现两个nonce相同的交易，gas price的差值超过该阈值则用新交易替换老交易</li> 
  </ul>
  <p>好，现在我们回到internal/ethapi/api.go，分析submitTransaction()函数：</p> 
  <pre class="has">
<code class="language-plain">func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) {
&nbsp;&nbsp;&nbsp;&nbsp;if err := b.SendTx(ctx, tx); err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if tx.To() == nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signer := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, err := types.Sender(signer, tx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr := crypto.CreateAddress(from, tx.Nonce())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Info("Submitted contract creation", "fullhash", tx.Hash().Hex(), "contract", addr.Hex())
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Info("Submitted transaction", "fullhash", tx.Hash().Hex(), "recipient", tx.To())
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return tx.Hash(), nil
}</code></pre> 
  <p>这里有一个Backend参数，是在eth Service初始化时创建的，具体实现在EthApiBackend中，代码位于eth/api_backend.go。可以看到，这里先调用了SendTx()函数提交交易，然后如果发现目标地址为空，表明这是一个创建智能合约的交易，会创建合约地址。下面分别进行分析。</p> 
  <h2>3.1 提交交易到txpool</h2> 
  <pre class="has">
<code class="language-plain">func (b *EthApiBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error {
&nbsp;&nbsp;&nbsp;&nbsp;return b.eth.txPool.AddLocal(signedTx)
}</code></pre> 
  <p>继续跟踪TxPool的AddLocal()函数：</p> 
  <pre class="has">
<code class="language-plain">func (pool *TxPool) AddLocal(tx *types.Transaction) error {
&nbsp;&nbsp;&nbsp;&nbsp;return pool.addTx(tx, !pool.config.NoLocals)
}

func (pool *TxPool) addTx(tx *types.Transaction, local bool) error {
&nbsp;&nbsp;&nbsp;&nbsp;pool.mu.Lock()
&nbsp;&nbsp;&nbsp;&nbsp;defer pool.mu.Unlock()

&nbsp;&nbsp;&nbsp;&nbsp;// Try to inject the transaction and update any state
&nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.add(tx, local)
&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// If we added a new transaction, run promotion checks and return
&nbsp;&nbsp;&nbsp;&nbsp;if !replace {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.promoteExecutables([]common.Address{from})
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return nil
}</code></pre> 
  <p>这里有两个主要函数：add()和promoteExecuteables()。</p> 
  <p>add()会判断是否应该把当前交易加入到queue列表中，promoteExecuteables()则会从queue中选取一些交易放入pending列表中等待执行。下面分别讨论这两个函数。</p> 
  <h3>3.1.1 TxPool.add()</h3> 
  <p>这个函数比较长，我们分成一段一段的来分析：</p> 
  <pre class="has">
<code class="language-plain">&nbsp;&nbsp;&nbsp;&nbsp;// If the transaction is already known, discard it
&nbsp;&nbsp;&nbsp;&nbsp;hash := tx.Hash()
&nbsp;&nbsp;&nbsp;&nbsp;if pool.all[hash] != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace("Discarding already known transaction", "hash", hash)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, fmt.Errorf("known transaction: %x", hash)
&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre> 
  <p>这一段是先计算交易的hash值，然后判断是不是已经在txpool 中，在的话就直接退出。</p> 
  <pre class="has">
<code class="language-plain">&nbsp;&nbsp;&nbsp;&nbsp;if err := pool.validateTx(tx, local); err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace("Discarding invalid transaction", "hash", hash, "err", err)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalidTxCounter.Inc(1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err
&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre> 
  <p>这一段是验证交易的有效性，主要进行以下几个方面的检查：</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>数据量必须&lt;32KB</li> 
   <li>交易金额必须非负（&gt;=0）</li> 
   <li>交易的gas limit必须低于block的gas limit</li> 
   <li>签名数据必须有效，能够解析出发送者地址</li> 
   <li>交易的gas price必须高于pool设定的最低gas price（除非是本地交易）</li> 
   <li>交易的nonce值必须高于当前链上该账户的nonce值（低于则说明这笔交易已经被打包过了）</li> 
   <li>当前账户余额必须大于“交易金额 + gasprice * gaslimit”</li> 
   <li>交易的gas limit必须大于对应数据量所需的最低gas水平</li> 
  </ul>
  <pre class="has">
<code class="language-plain">&nbsp;&nbsp;&nbsp;&nbsp;// If the transaction pool is full, discard underpriced transactions
&nbsp;&nbsp;&nbsp;&nbsp;if uint64(len(pool.all)) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the new transaction is underpriced, don't accept it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace("Discarding underpriced transaction", "hash", hash, "price", tx.GasPrice())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underpricedTxCounter.Inc(1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, ErrUnderpriced
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// New transaction is better than our worse ones, make room for it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drop := pool.priced.Discard(len(pool.all)-int(pool.config.GlobalSlots+pool.config.GlobalQueue-1), pool.locals)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range drop {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace("Discarding freshly underpriced transaction", "hash", tx.Hash(), "price", tx.GasPrice())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underpricedTxCounter.Inc(1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.removeTx(tx.Hash(), false)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre> 
  <p>&nbsp;</p> 
  <p>这一段是在当前txpool已满的情况下，剔除掉低油价的交易。还记得之前有个priced字段存储了按gas price以及nonce排序的交易列表吗？这里会先把当前交易的gas price和当前池中的最低价进行比较：</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>如果低于最低价，直接丢弃该交易返回</li> 
   <li>如果高于最低价，则从txpool中剔除一些低价的交易</li> 
  </ul>
  <pre class="has">
<code class="language-plain">&nbsp;&nbsp;&nbsp;&nbsp;// If the transaction is replacing an already pending one, do directly
&nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated
&nbsp;&nbsp;&nbsp;&nbsp;if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Nonce already pending, check if required price bump is met
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inserted, old := list.Add(tx, pool.config.PriceBump)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !inserted {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pendingDiscardCounter.Inc(1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, ErrReplaceUnderpriced
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// New transaction is better, replace old one
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if old != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete(pool.all, old.Hash())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pendingReplaceCounter.Inc(1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all[tx.Hash()] = tx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Put(tx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.journalTx(from, tx)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Trace("Pooled new executable transaction", "hash", hash, "from", from, "to", tx.To())

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We've directly injected a replacement transaction, notify subsystems
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(TxPreEvent{tx})

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return old != nil, nil
&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre> 
  <p>这一段是为了处理两个交易nonce相同的问题。如果用户发起了一笔交易，在还没有被执行之前又用同样的nonce发起了另一笔交易，则只会保留gas price高的那一笔。这个list.Overlaps()函数就是用来判断pending列表中是否包含相同nonce的交易的。</p> 
  <pre class="has">
<code class="language-plain">&nbsp;&nbsp;&nbsp;&nbsp;// New transaction isn't replacing a pending one, push into queue
&nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.enqueueTx(hash, tx)
&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err
&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre> 
  <p>如果之前的那些检查都没有问题，就真正调用enqueueTx()函数把交易加入到queue列表中了。</p> 
  <pre class="has">
<code class="language-plain">&nbsp;&nbsp;&nbsp;&nbsp;// Mark local addresses and journal local transactions
&nbsp;&nbsp;&nbsp;&nbsp;if local {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.locals.add(from)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;pool.journalTx(from, tx)</code></pre> 
  <p>最后，如果发现这个账户是本地的，就把它加到一个白名单里，默认会保证本地交易优先被加到txpool中。</p> 
  <p>至此，TxPool.add()函数就分析完了。</p> 
  <h3>3.1.2 TxPool.promoteExecuteables()</h3> 
  <p>这个函数比上面那个还长。。。主要目的是把交易从queue列表“提拔”到pending列表，代码逻辑比较清楚，具体可以参见下面这张图：</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180528180550943"></p> 
  <p>根据不同的目的可以分为3块，分别以粉色、紫色、绿色标识。</p> 
  <p>&nbsp;</p> 
  <p>粉色部分主要是为了把queue中的交易“提拔”到pending中。当然在这之前需要先要进行一番检查：</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>丢弃nonce &lt; 账户当前nonce的交易，也就是已经被打包过的交易</li> 
   <li>丢弃转账金额 + gas消耗 &gt; 账户余额的交易，也就是会out-of-gas的交易</li> 
   <li>丢弃gas limit &gt; block gas limit的交易，这部分交易可能会导致区块生成失败</li> 
  </ul>
  <p>紫色部分主要是为了清理pending列表，使其满足GlobalSlots和AccountSlots的限制条件：</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>如果有些账户的交易数超过了AccountSlots，则先按交易数最少的账户进行均衡。举例来说，如果有10个账户交易数超过了AccountSlots（默认16），其中交易数最少的账户包含20笔交易，那么先把其他9个账户的交易数量削减到20。</li> 
   <li>如果经过上面的步骤，pending的长度还是超过了GlobalSlots，那就严格按照AccountSlots进行均衡，也就是把上面的10个账户的交易数进一步削减到16。</li> 
  </ul>
  <p>绿色部分主要是为了清理queue列表，使其满足GlobalQueue和AccountQueue的限制条件：</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>如果每个账户的交易数超过了AccountQueue，丢弃多余交易</li> 
   <li>如果queue的长度超过了GlobalQueue，则把账户按最后一次心跳时间排序，然后依次去除账户中的交易，直到满足限制条件位置。</li> 
  </ul>
  <p>这里提到一个最后一次心跳时间，其实就是账户最近一次交易的时间，用来作为账户活跃度的判断</p> 
  <p>具体代码非常长，就不贴了，可以按照上面的图自行对照。</p> 
  <h2>3.2 创建智能合约地址</h2> 
  <p>再贴一下之前创建智能合约地址的代码：</p> 
  <pre class="has">
<code class="language-plain">addr := crypto.CreateAddress(from, tx.Nonce())
</code></pre> 
  <p>参数是发送方地址和交易的nonce值，然后调用CreateAddress()方法，代码位于crypto/crypto.go：</p> 
  <pre class="has">
<code class="language-plain">func CreateAddress(b common.Address, nonce uint64) common.Address {
&nbsp;&nbsp;&nbsp;&nbsp;data, _ := rlp.EncodeToBytes([]interface{}{b, nonce})
&nbsp;&nbsp;&nbsp;&nbsp;return common.BytesToAddress(Keccak256(data)[12:])
}</code></pre> 
  <p>可以看到，就是先对刚刚两个参数进行RLP编码，然后计算hash值，取后20位作为合约地址。</p> 
  <p>至此，提交交易部分的代码就分析完了。</p> 
  <h1>4. 广播交易</h1> 
  <p>交易提交到txpool中后，还需要广播出去，一方面通知EVM执行该交易，另一方面要把交易信息广播给其他结点。具体调用在3.1.2节中提到的promoteTx()函数中，代码位于crypto/tx_pool.go：</p> 
  <pre class="has">
<code class="language-plain">func (pool *TxPool) promoteTx(addr common.Address, hash common.Hash, tx *types.Transaction) {
    ……
&nbsp;&nbsp;&nbsp;&nbsp;// Set the potentially new pending nonce and notify any subsystems of the new tx
&nbsp;&nbsp;&nbsp;&nbsp;pool.beats[addr] = time.Now()
&nbsp;&nbsp;&nbsp;&nbsp;pool.pendingState.SetNonce(addr, tx.Nonce()+1)

&nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(TxPreEvent{tx})
}</code></pre> 
  <p>可以看到，先更新了最后一次心跳时间，然后更新账户的nonce值，最后一行就是发送一个TxPreEvent事件，外部可以通过SubscribeTxPreEvent()函数订阅该事件：</p> 
  <pre class="has">
<code class="language-plain">func (pool *TxPool) SubscribeTxPreEvent(ch chan&lt;- TxPreEvent) event.Subscription {
&nbsp;&nbsp;&nbsp;&nbsp;return pool.scope.Track(pool.txFeed.Subscribe(ch))
}</code></pre> 
  <p>我们只要搜索一下这个函数，就可以知道哪些组件订阅了该事件了。</p> 
  <h2>4.1 执行交易</h2> 
  <p>第一个订阅的地方位于miner/worker.go：</p> 
  <pre class="has">
<code class="language-plain">func newWorker(config *params.ChainConfig, engine consensus.Engine, coinbase common.Address, eth Backend, mux *event.TypeMux) *worker {
    ……

&nbsp;&nbsp;&nbsp;&nbsp;// Subscribe TxPreEvent for tx pool
&nbsp;&nbsp;&nbsp;&nbsp;worker.txSub = eth.TxPool().SubscribeTxPreEvent(worker.txCh)

    ……

    go worker.update()

    ……
}</code></pre> 
  <p>开启了一个goroutine来接收TxPreEvent，看一下update()函数：</p> 
  <pre class="has">
<code class="language-plain">func (self *worker) update() {
    ……

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Handle TxPreEvent
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ev := &lt;-self.txCh:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Apply transaction to the pending state if we're not mining
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if atomic.LoadInt32(&amp;self.mining) == 0 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.currentMu.Lock()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc, _ := types.Sender(self.current.signer, ev.Tx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txs := map[common.Address]types.Transactions{acc: {ev.Tx}}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txset := types.NewTransactionsByPriceAndNonce(self.current.signer, txs)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.current.commitTransactions(self.mux, txset, self.chain, self.coinbase)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.updateSnapshot()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.currentMu.Unlock()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If we're mining, but nothing is being processed, wake on new transactions
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.config.Clique != nil &amp;&amp; self.config.Clique.Period == 0 {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.commitNewWork()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
    ……
}</code></pre> 
  <p>可以看到，如果结点不挖矿的话，这里会立即调用commitTransactions()提交给EVM执行，获得本地回执。</p> 
  <p>如果结点挖矿的话，miner会调用commitNewWork()，内部也会调用commitTransactions()执行交易。</p> 
  <h2>4.2 广播给其他结点</h2> 
  <p>另一个订阅的地方位于eth/handler.go：</p> 
  <pre class="has">
<code class="language-plain">func (pm *ProtocolManager) Start(maxPeers int) {
    ……

 &nbsp;&nbsp;&nbsp;pm.txSub = pm.txpool.SubscribeTxPreEvent(pm.txCh)
&nbsp;&nbsp;&nbsp;&nbsp;go pm.txBroadcastLoop()

    ……
}
</code></pre> 
  <p>同样也是启动了一个goroutine来接收TxPreEvent事件，看一下txBroadcastLoop()函数：</p> 
  <pre class="has">
<code class="language-plain">func (pm *ProtocolManager) txBroadcastLoop() {
&nbsp;&nbsp;&nbsp;&nbsp;for {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case event := &lt;-pm.txCh:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pm.BroadcastTx(event.Tx.Hash(), event.Tx)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Err() channel will be closed when unsubscribing.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-pm.txSub.Err():
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</code></pre> 
  <p>继续跟踪BroadcastTx()函数：</p> 
  <pre class="has">
<code class="language-plain">func (pm *ProtocolManager) BroadcastTx(hash common.Hash, tx *types.Transaction) {
&nbsp;&nbsp;&nbsp;&nbsp;// Broadcast transaction to a batch of peers not knowing about it
&nbsp;&nbsp;&nbsp;&nbsp;peers := pm.peers.PeersWithoutTx(hash)
&nbsp;&nbsp;&nbsp;&nbsp;//FIXME include this again: peers = peers[:int(math.Sqrt(float64(len(peers))))]
&nbsp;&nbsp;&nbsp;&nbsp;for _, peer := range peers {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peer.SendTransactions(types.Transactions{tx})
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;log.Trace("Broadcast transaction", "hash", hash, "recipients", len(peers))
}</code></pre> 
  <p>可以看到，这里会通过P2P向所有没有该交易的结点发送该交易。</p> 
  <p><span style="color:#ff6666;">更多文章欢迎关注“鑫鑫点灯”专栏：<a href="https://blog.csdn.net/turkeycock/article/category/7669858" rel="nofollow">https://blog.csdn.net/turkeycock/article/category/7669858</a></span></p> 
  <p><span style="color:#86ca5e;">或关注飞久微信公众号：</span></p> 
  <p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181030102930969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R1cmtleUNvY2s=,size_16,color_FFFFFF,t_70"></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/TurkeyCock/article/details/80485391,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/TurkeyCock/article/details/80485391,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
