<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链指南 第2章　区块链基础 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链指南 第2章　区块链基础" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="目录： 2.1 区块链技术 区块链本质上是一个对等网络（peer-to-peer）的分布式账本数据库。区块链本身其实是一串链接的数据区块，其链接指针是采用密码学哈希算法对区块头进行处理所产生的区块头哈希值。每一个数据块中记录了一组采用哈希算法组成的树状交易状态信息，这样保证了每个区块内的交易数据不可篡改，区块链里链接的区块也不可篡改。 2.1.1　基本概念 完整的区块链系统包含的技术：存储数据的数据区块及其之上的数字签名、时间戳等技术，有作为支撑的P2P网络和维护系统的共识算法，有挖矿和工作量证明机制，有匿名交易机制和比特币钱包，还有链龄，UTXO、Merkle树、双花等相关技术概念。 1.数据区块 比特币的交易记录会保存在数据区块之中， 比特币系统中大约每10分 钟会产生一个区块， 每个数据区块一般包含区块头（Header） 和区块体 （Body） 两部分，如下图： 区块头封装了当前的版本号（Version）、前一区块地址（Prev-block）、时间戳（Timestamp）、随机数（Nonce）、当前区块的目标哈希值（Bits）、Merkle树的根值（Merkle-root）等信息。 区块体中则主要包含交易计数和交易详情。交易详情就是比特币系统中的记账本，每一笔交易都会被永久地记入数据区块中，而且任何人都可以查询。区块体中的Merkle树将会对每一笔交易进行数字签名，如此可以确保每一笔交易都不可伪造且没有重复交易。所有的交易将通过Merkle树的Hash过程产生一个唯一Merkle根值记入区块头。 2.挖矿与分叉问题 区块在挖矿过程中产生。所谓挖矿，实际上是穷举随机数算法，把上个区块的哈希值加上10分钟内的全部交易单打包，再加上一个随机数，算出一个256位的字符串哈希值，输入的随机数Nonce使哈希值满足一定条件就获得这个区块的交易记账权。 新产生的区块需要快速广播出去，以便其他节点进行对其验证，以防造假。每个区块存着上一个区块的哈希值，可以溯源到源头，只有经过验证后才最终获得区块的交易记账权。 3.时间戳和不可篡改性 时间戳是指从格林威治时间1970年01月01日00时00分00秒（北京时间 1970年01月01日08时00分00秒）起到现在的总秒数，通常是一个字符序列，唯一地标识某时刻的时间。在比特币系统中，获得记账权的节点在链接区块时需要在区块头中加盖时间戳，用于记录当前区块数据的写入时 间。 4.分布式数据库 比特币系统中的区块就像一个记账本一样，记录了所有比特币的交易 信息，每一个比特币用户的比特币收支情况都被永久地嵌入了数据区块中 以供别人查询。这些数据区块中的交易数据存放在每一个比特币用户的客 户端节点中，所有的这些节点则组成了比特币及其坚韧的分布式数据库系 统。任何一个节点的数据被破坏都不会影响整个数据库的正常运转，因为 其他的健康节点中都保存了完整的数据库。 5.UTXO交易模式 UTXO（Unspent Transaction Outputs）是未花费的交易输出，它是比特币交易过程中的基本单位。 具体见我的博文： http://blog.csdn.net/wu2374633583/article/details/79175211 6.哈希函数 哈希函数有着很多适合存储区块链数据的优点： 1）哈希函数处理过的数据是单向性的，通过处理过的输出值几乎不可能计算出原始的输入值； 2）哈希函数处理不同长度的数据所耗费的时间是一致的，输出值也是定长的； 3）哈希函数的输入值即使只相差一个字节，输出值的结果也会迥然不同。比特币系统中最常采用的哈希函数是双SHA256哈希函数，通俗来说就是将不同长度的原始数据用两次SHA256哈希函数进行处理，再输出长度为256的二进制数字来进行统一的识别和存储。 7.Merkle树 Merkle树是数据结构中的一种树，可以是二叉树，也可以是多叉树，它具有树结构的所有特点。 比特币区块链系统中的采用的是Merkle二叉树，它的作用主要是快速归纳和校验区块数据的完整性，它会将区块链中的数据分组进行哈希运算，向上不断递归运算产生新的哈希节点，最终只剩下一个Merkle根存入区块头中，每个哈希节点总是包含两个相邻的数据块或其哈希值。 使用Merkle树优点： 首先是极大地提高了区块链的运行效率和可扩展性，使得区块头只需包含根哈希值而不必封装所有底层数据。 其次是Merkle树可支持“简化支付验证协议”（SPV），即在不运行完整区块链网络节点的情况下，也能够对交易数据进行检验。 8.双重支付 双重支付问题又称为“双花”问题，即利用货币的数字特性用“同一笔钱”完成两次或者多次支付。 区块链技术则在去中心化的系统中不借助任何第三方机构而只通过分布式节点之间的相互验证和共识机制，有效地解决了双重支付问题，在信息传输的同时完成了价值转移。 区块链技术通过区块链接形成的时间戳技术加上验证比特币是否满足UTXO（未花费交易）和数字签名，有效避免了双重支付的问题。 9.P2P网络 P2P网络（peer-to-peer network，对等网络）是一种在对等者（peer）之间分配任务和⼯作负载的分布式应⽤架构，是对等计算模型在应用层形成的一种组网或网络形式。因此，从字面上，P2P可以理解为对等计算或对等网络。 区块链系统是建立在IP通信协议和分布式网络的基础上的，它不依靠传统的电路交换，而是建立于网络通信之上，完全通过互联网去交换信息。网络中所有的节点具有同等的地位，不存在任何特殊化的中心节点和层级结构，每个节点均会承担网络路由、验证数据区块等功能。网络的节点根据存储数据量的不同可以分为全节点和轻量级节点。 10.加密算法 除了哈希算法以外，比特币中还存在一种为交易加密的非对称加密算法（椭圆曲线加密算法）。非对称加密算法指的就是存在一对数学相关的密钥，使用其中一个密钥（公钥）进行加密的数据信息，只有使用另一个密钥（私钥）才能对该信息进行解密。 具体见我博文： http://blog.csdn.net/wu2374633583/article/details/79174547 非对称加密需要两个（一对）密钥：公开密钥（publickey）和私有密钥（privatekey），用公钥对数据进行加密后，只有对应的私钥才能解密；反之如果私钥用于加密，则只有对应的公钥才能解密。通信双方无须交换密钥就可以建立保密通信。 简单再说一下这几个问题： 1）Base58编码 可读性编码算法，类似古典密码学里的置换算法，理论上并不是密码学理论的核心内容。可读性编码算法不是为了保护数据的安全性，而是为了可读性。以二进制进行传输的信息是不具备可读性的，数字与字母组成的字符串才更容易被识别。可读性编码不改变信息内容，只改变信息内容的表现形式（部分编码算法还加入了容错校验功能，以保证传输过程中数据的准确性和完整性）。 Base64是常见的可读性编码算法，所谓Base64，即是说在编码过程中使用了64种字符：大写A到Z、小写a到z、数字0到9、“+”和“/”。 Base58是Bitcoin中使用的一种编码方式，主要用于产生Bitcoin的钱包地址。相比Base64，Base58不使用数字”0”，字母大写”O”，字母大写”I”，和字母小写”i”，以及”+”和”/”符号。 设计Base58主要的目的是： （1）避免混淆。在某些字体下，数字0和字母大写O，以及字母大写I和字母小写l会非常相似。 （2）不使用”+”和”/”的原因是，非字母或数字的字符串难以作为账号的一部分被接受。 （3）没有标点符号，通常不会被从中间分行。 （4）使大部分的软件支持双击选择整个字符串。 （5）比特币中使用Base58算法来对公钥的Hash160及私钥进行编码，以生成以1或3开头的比特币地址及WIF（Wallet import Format)格式的私钥。 2）私钥与公钥 比特币私钥其实是使用SHA-256生成的32字节（256位）的随机数，有效私钥的范围则取决于比特币使用的secp256k1 椭圆曲线数字签名标准。大小介于0x1 到0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140之间的数几乎都是合法的私钥。 在私钥的前面加上版本号，后面添加压缩标志和附加校验码，（所谓附加校验码，就是对私钥经过2次SHA-256运算，取两次哈希结果的前四字节），然后再对其进行Base58编码，就可以得到我们常见的WIF（Wallet import Format)格式的私钥。 私钥经过椭圆曲线乘法运算，可以得到公钥。公钥是椭圆曲线上的点，并具有x和y坐标。公钥有两种形式：压缩的与非压缩的。早期比特币均使用非压缩公钥，现在大部分客户端默认使用压缩公钥。 由于数学原理，从私钥推算公钥是可行的，从公钥逆推私钥是不可能的。 也就是说比特币的私钥是： 32字节随机数（使用SHA-256）+版本号+压缩标志+校验码（双哈希过的随机数的前四位字节） 3）地址的生成 首先将公钥进行SHA256和RIPEMD160双哈希运算，并生成20字节长度的摘要结果（即Hash160结果），这个将作为比特币地址的主体（body）信息，再在前面加上版本前缀0x00，在后面添加4个字节的地址校验码。地址校验码通过对摘要结果进行两次SHA256运算，取哈希值的前4位产生。最后通过Base58处理把连在一起的版本前缀、主体信息和校验码转换成可以容易让人识别的比特币字符地址。 地址组成： （公钥（双哈希）+版本号前缀+地址校验码）（base58） 11.数字签名 数字签名就是在信息后面加上另一段内容，作为发送者的证明并且证明信息没有被篡改。一般是发送者将信息用哈希算法处理得出一个哈希值，然后用私钥对该哈希值进行加密，得出一个签名。然后发送者再将信息和签名一起发送给接收者。接收者使用发送者的公钥对签名进行解密，还原出哈希值，再通过哈希算法来验证信息的哈希值和解密签名还原出来的哈希值是否一致，从而可以鉴定信息是否来自发送者或验证信息是否被篡改。 注意和比特币加密信息的区别，见我的博文： http://blog.csdn.net/wu2374633583/article/details/79174547 12.比特币的隐私模型 在比特币的隐私模型中，所有的交易不需要第三方的操控，也不需要提供任何身份信息，只需要提供比特币的地址就可以跟任何人完成一次准匿名的交易。 2.1.2　框架与特点 1.框架简介 我们将区块链的基础架构分为三层来进行讲解： 首先，在网络层之上，区块链是建立在IP通信协议和对等网络的基础上的一个分布式系统，和传统带中心的分布式系统不一样，它不依靠中心化的服务器节点来转发消息，而是每一个节点都参与消息的转发。因此P2P网络比传统网络具有更高的安全性，任何一个节点被攻击都不会影响整个网络，所有的节点都保存着整个系统的状态信息。 其次，在数据层面上，区块链就是一个只可追加、不可更改的分布式数据库系统，是一个分布式账本。如果是公开的区块链，也就是公有链，那么这个账本可以被任何人在任何地方进行查询，完全公开透明。在区块链网络中，节点通过使用共识算法来维持网络中账本数据库的一致性。同时采用密码学的签名和哈希算法来确保这个数据库不可篡改，不能作伪，并且可追溯。 再次，在应用层面，我们可以用区块链代替传统的登记、清算系统。 在应用方面，区块链平台能够提供编程环境让用户编写智能合约。通过智能合约，可以把业务规则转化成在区块链平台自动执行的合约，该合约的执行不依赖可信任的第三方，也不受人为的干预。 2.架构特点 区块链具有去中心化、可靠数据库、开源可编程、集体维护、安全可信、交易准匿名性等特点。如果一个系统不具有以上特征，将不能被视为基于区块链技术的应用。 （1）去中心化 区块链数据的存储、传输、验证等过程均基于分布式的系统结构，作为区块链一种部署模式，公共链网络中所有参与的节点都可以具有同等的权利和义务。 （2）可靠数据库 区块链系统的数据库采用分布式存储，任何参与节点都可以拥有一份完整的数据库拷贝。 区块链数据的存储还带有时间戳，从而为数据添加了时间维度，具有极高的可追溯性。 （3）开源可编程 区块链系统通常是开源的，代码高度透明公共链的数据和程序对所有人公开，任何人都可以通过接口查询系统中的数据。并且区块链平台还提供灵活的脚本代码系统，支持用户创建高级的智能合约、货币和去中心化应用。 （4）集体维护 系统中的数据块由整个系统中所有具有记账功能的节点来共同维护，任一节点的损坏或失去都不会影响整个系统的运作。 （5）安全可信 区块链技术采用非对称密码学原理对交易进行签名，使得交易不能被伪造；同时利用哈希算法保证交易数据不能被轻易篡改，最后借助分布式系统各节点的工作量证明等共识算法形成强大的算力来抵御破坏者的攻击，保证区块链中的区块以及区块内的交易数据不可篡改和不可伪造，因此具有极高的安全性。 （6）准匿名性 区块链系统采用与用户公钥挂钩的地址来做用户标识，不需要传统的基于PKI的第三方认证中心（Certificate Authority，CA）颁发数字证书来确认身份。通过在全网节点运行共识算法，建立网络中诚实节点对全网状态的共识，间接地建立了节点间的信任。 区块链技术的核心优势是去中心化，能够通过运用哈希算法、数字签名、时间戳、分布式共识和经济激励等手段，在节点无需互相信任的分布式系统中建立信任，实现点对点交易和协作，从而为中心化机构普遍存在的低成本、低效率和数据存储不安全等问题提供了解决方案。 2.1.3　区块链运作的核心技术 1.区块链的链接 区块链即由一个个区块组成的链。每个区块分为区块头和区块体（含交易数据）两个部分。区块头包括用来实现区块链接的前一区块的哈希（PrevHash）值（又称散列值）和用于计算挖矿难度的随机数。 2.共识机制 可以将区块链理解为一个基于互联网的去中心化记账系统。区块链技术的核心是在没有中心控制的情况下，在互相没有信任基础的个体之间就交易的合法性等达成共识的共识机制。 区块链的共识机制目前主要有4类：PoW、PoS、DPoS、分布式一致性算法。 （1）PoW PoW（工作量证明），也就是像比特币的挖矿机制，矿工通过把网络尚未记录的现有交易打包到一个区块，然后不断遍历尝试来寻找一个随机数，使得新区块加上随机数的哈希值满足一定的难度条件，找到满足条件的随机数，就相当于确定了区块链最新的一个区块，也相当于获得了区块链的本轮记账权。矿工把满足挖矿难度条件的区块在网络中广播出去，全网其他节点在验证该区块满足挖矿难度条件，同时区块其的交易数据符合协议规范后，将各自把该区块链接到自己版本的区块链上，从而在全网形成对当前网络状态的共识。 优点： 完全去中心化，节点自由进出，避免了建立和维护中心化信用机构的成本。 缺点： 目前比特币挖矿造成大量的资源浪费；另外挖矿的激励机制也 造成矿池算力的高度集中，背离了当初去中心化设计的初衷。更大的问题是PoW机制的共识达成的周期较长，每秒只能最多做7笔交易，不适合商业应用。 （2）PoS PoS权益证明，要求节点提供拥有一定数量的代币证明来获取竞争区块链记账权的一种分布式共识机制。如果单纯依靠代币余额来决定记账者必然使得富有者胜出，导致记账权的中心化，降低共识的公正性，因此不同的PoS机制在权益证明的基础上，采用不同方式来增加记账权的随机性来避免中心化。 优点： 在一定程度上缩短了共识达成的时间，降低了PoW机制的资源浪费。 缺点： 破坏者对网络攻击的成本低，网络的安全性有待验证。另外拥 有代币数量大的节点获得记账权的几率更大，会使得网络的共识受少数富裕账户支配，从而失去公正性。 （3）DPoS DPoS（股份授权证明）机制，类似于董事会投票。比特股（bitshares）采用的PoS机制是持股者投票选出一定数量的见证人，每个见证人按序有两秒的权限时间成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一个时间片对应的见证人。持股人可以随时通过投票更换这些见证人。 优点： 大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。 ·缺点： 选举固定数量的见证人作为记账候选人有可能不适合于完全去中心化的场景。另外在网络节点数少的场景，选举的见证人的代表性也不强。 （4）分布式一致性算法 分布式一致性算法是基于传统的分布式一致性技术。其中有分为解决拜占庭将军问题的拜占庭容错算法，如PBFT。另外解决非拜占庭问题的分布式一致性算法（Pasox、Raft）。该类算法目前是联盟链和私有链链场景中常用的共识机制。 优点：实现秒级的快速共识机制，保证一致性。 缺点：去中心化程度不如公有链上的共识机制；更适合多方参与的多中心商业模式。 3.解锁脚本 脚本是区块链上实现自动验证、自动执行合约的重要技术。每一笔交易的每一项输出严格意义上并不是指向一个地址，而是指向一个脚本。脚本类似一套规则，它约束着接收方怎样才能花掉这个输出上锁定的资产。 交易的合法性验证也依赖于脚本。目前它依赖于两类脚本：锁定脚本与解锁脚本。 锁定脚本是在输出交易上加上的条件，通过一段脚本语言来实现，位于交易的输出。解锁脚本与锁定脚本相对应，只有满足锁定脚本要求的条件，才能花掉这个脚本上对应的资产，位于交易的输入。通过脚本语言可以表达很多灵活的条件。解释脚本是通过类似我们编程领域里的“虚拟机”，它分布式运行在区块链网络上的每一个节点。 比特币的脚本分为两种：一种是普通的P2PKH，，即支付给公钥的哈希地址，接收方只需要使用地址对应的私钥对该输出进行签名，即可花掉该输出。另一种是P2SH，即支付脚本的哈希。 比如在比特币中，P2PKH的脚本规则如下： Pubkey script: OP_DUP OP_HASH160 &lt;PubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG Signature script: &lt;sig&gt; &lt;pubkey&gt; P2SH的脚本规则如下： Pubkey script: OP_HASH160 &lt;Hash160(redeemScript)&gt; OP_EQUAL Signature script: &lt;sig&gt; [sig] [sig...] &lt;redeemScript&gt; 在上述的两种脚本规则里，Pubkey script代表锁定脚本，Signature script代表解锁脚本。OP_开头的单词是相关的脚本命令，也是“虚拟机”所能解析的指令。 注意的是，比特币的脚本机制比较简单，而以太坊的脚本机制是支持脚本的一套图灵完备语言。脚本机制让区块链技术作为一项底层协议成为可能。 4.交易规则 区块链的交易就是构成区块的基本单位，也是区块链负责记录的实际有效内容。一个区块链交易可以是一次转账，也可以是智能合约的部署等其他事务。 对于比特币而言，交易意味着一次支付转账，规则如下： 1）交易的输入和输出不能为空。 2）对交易的每个输入，如果其对应的UTXO输出能在当前交易池中找到，则拒绝该交易。因为当前交易池是未被记录在区块链中的交易，而交易的每个输入，应该来自确认的UTXO。如果在当前交易池中找到，那就是双花交易。 3）交易中的每个输入，其对应的输出必须是UTXO。 4）每个输入的解锁脚本（unlocking script）必须和相应输出的锁定脚本（locking script）共同验证交易的合规性。 注意： 对于以太坊来说，交易还可能是智能合约的部署。交易规则就确定了符合一定语法规则的合约才能被部署在区块链上。 5.交易优先级 区块链交易的优先级由区块链协议规则决定。对于比特币而言，交易被区块包含的优先次序由交易广播到网络上的时间和交易额的大小决定。 对于以太坊而言，交易的优先级还与交易的发布者愿意支付的交易费用有关。 6.Merkle证明 比特币区块链使用了Merkle证明，为的是将交易存储在每一个区块中。使得交易不能被篡改，同时也容易验证交易是否包含在一个特定区块中，Merkle树的一个重要使用场景就是快速支付验证，轻量级节点（light client）不用下载每一笔交易以及每一个区块，可以仅下载链的区块头，每个区块中仅包含5项内容（上一区块头的哈希值，时间戳，挖矿难度值，工作量证明随机数，包含该区块交易的Merkle树的根哈希），数据块大小为80字节。如果一个轻客户端希望确定一笔交易的状态，它可以简单地要求一个Merkle证明，显示出一个在Merkle树特定的交易，其根是在主链（main chain，非分叉链）上的区块头。 局限性：虽然可以证明包含的交易，但无法证明任何当前的状态（例如：数字资产的持有，名称注册，融合约的状态等）。 以太坊的改进：以太坊的每一个区块头中并非只包含一棵Merkle树，而是包含了3棵Merkle树（见图2-12），分别对应了3种对象：交易，收据（基本上，它是展示每一笔交易影响的数据条），状态。 这三棵树允许轻客户端轻松地进行并核实以下类型的查询答案： 1）这笔交易被包含在特定的区块中了吗？ 2）告诉我这个地址在过去30天中，发出X类型事件的所有实例（例如，一个众筹合约完成了它的目标）。 3）目前我的账户余额是多少？ 4）这个账户是否存在？ 5）假装在这个合约中运行这笔交易，它的输出会是什么？ 第1种和第5种是由交易树（transaction tree）来处理的；第3和第4种则是由状态树（state tree）负责处理，第2种则由收据树（receipt tree）处理。 7.RLP RLP（递归长度前缀编码）是Ethereum中对象序列化的一个主要编码方式，其目的是对任意嵌套的二进制数据的序列进行编码。 这种编码格式将任意长度和维度的字符串构成的数组串连接成字符串。 例如： [’dog‘，’cat‘]被串接（以字节数组格式）为[130，67，100，111，103，67，99，97，116]； 解释：基本的思想是 把数据类型和长度编码成一个单独的字节放在实际数据的前面（例如‘dog’的字节数组编码为[100，111，103]，于是串接后就成了[67，100，111，103]）。注意RLP编码正如其名字表示的一样，是递归的； 2.1.4　区块链交易流程 区块链上的交易指的是转账，如果每一笔转账都需要构造一笔交易数据会比较笨拙，为了使得价值易于组合与分割，比特币的交易被设计为可以纳入多个输入和输出，即一笔交易可以转账给多个人，也就是所谓的UTXO。 区块链交易的整个生命周期：从生成到在网络中传播，再到通过工作量证明、整个网络节点验证，最终记录到区块链。整个区块链交易流程如下： （1）交易的生成。所有者A利⽤他的私钥对前一次交易和下一位所有者B签署一个数字签名，并将这个签名附加在这枚货币的末尾，制作成交易单。 （2）交易的传播。A将交易单广播至全网，每个节点都将收到的交易信息纳入一个区块中。 （3）工作量证明。每个节点通过相当于解一道数学题的工作量证明机制，从而获得创建新区块的权力，并争取得到数字货币的奖励。 （4）整个网络节点验证。当一个节点找到解时，它就向全网广播该区块记录的所有盖时间戳交易，并由全网其他节点核对。 （5）记录到区块链。全网其他节点核对该区块记账的正确性，没有错误后他们将在该合法区块之后竞争下一个区块，这样就形成了一个合法记账的区块链。 2.2 以太坊 2.2.1　什么是以太坊 以太坊的目的是对脚本、竞争币和链上元协议（on-chain meta-protocol）等概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、图灵完备的、易于开发和协同的应用。 以太坊的新颖在于其神奇的计算机网络，它促成了一种新型的软件应用，真正的去中心化应用。将信任逻辑嵌入小程序中，运行在区块链上。而与比特币相比，以太坊建立了一种新的密码学技术基础框架，在其上开发应用更加容易，并对轻客户端友好，同时允许应用共享一个可行的经济环境和可靠的区块链安全。 以太坊是个平台和编程语言，包括数字货币以太币（Ether），以及用来构建和发布分布式应用的以太脚本（EtherScript）。 从最底层角度来看，以太坊是一个多层的、基于密码学的开源技术协议。它的不同功能模块通过设计进行了全面的整合，作为一个整体，它是一个创建和部署去中心化应用的综合平台。 同时，以太坊也是区块链与智能合约的完美结合，是智能合约的完整解决方案，被设计成了一个通用的去中心化平台，拥有一套完整的、可以扩展其功能的工具，在P2P网络、加密、HttpClient等技术的支持下实现了一个类似于比特币的区块链。它通过工作量证明机制实现共识，由矿工挖矿，通过对新的网络协议的制定实现对区块链的同步等操作。不同于比特币的是，在以太坊上可以任意编写智能合约，通过智能合约实现强大的功能，实现去中心化应用的开发。在以太坊上部署的智能合约运行在以太坊特有的虚拟机上，通过以太坊虚拟机和RPC接口与底层区块链进行交互。 2.2.2　以太坊技术 1.以太坊核心概念 （1）以太坊虚拟机 以太坊虚拟机（EVM）是以太坊中智能合约的运行环境。实际上它是由许多互相连接的计算机组成的。任何人都可以上传程序，并让这些程序自动执行，同时保证现在和所有以前的每个程序的状态总是公共可见的。 （2）账户 以太坊中有两类账户，它们共用同一个地址空间。外部账户，该类账户被公钥-私钥对控制。合约账户，该类账户被存储在账户中的代码控制。外部账户的地址是由公钥决定的，合约账户的地址是在创建合约时由合约创建者的地址和该地址发出过的交易数量计算得到。两类账户的唯一区别是：外部账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。 以太坊的账户包含4个部分：①随机数，用于确定每笔交易只能被处理一次的计数器；②账户目前的以太币余额；③账户的合约代码（如果有的话）；④账户的存储（默认为空）。 （3）消息 以太坊的消息在某种程度上类似于比特币的交易，但是两者之间存在3点重要的不同。 1）以太坊的消息可以由外部实体或者合约创建，然后比特币的交易只能从外部创建。 2）以太坊消息可以选择包含数据。 3）如果以太坊消息的接收者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。 （4）交易 以太坊中“交易”是指存储从外部账户发出的消息的签名数据包。交易包含消息的接收者、用于确认发送者的签名、以太币账户余额、要发送的数据和被称为STARTGAS和GASPRICE的两个数值。为了防止代码出现指数型爆炸和无限循环，每笔交易需要对执行代码所引发的计算步骤做出限制。STARTGAS就是通过需要支付的燃料来对计算步骤进行限制，GASPRICE是每一计算步骤需要支付矿工的燃料的价格。 （5）Gas 以太坊上的每笔交易都会被收取一定数量的燃料Gas，设置Gas的目的是限制交易执行所需的工作量，同时为交易的执行支付费用。 （6）存储、主存和栈 每个账户都有一块永久的内存区域，被称为存储，其形式为key-value，key和value的长度均为256位。在合约里，不能遍历账户的存储。相对于主存和栈，存储的读操作开销较大，修改存储甚至更多。一个合约只能对它自己的存储进行读写。 第二个内存区被称为主存。合约执行每次消息调用时都有一块新的被清除过的主存。 EVM不是基于寄存器的，而是基于栈的虚拟机。因此所有的计算都在一个称为栈的区域内执行。栈最大有1024个元素，每个元素有256位。对栈的访问只限于其顶端，允许复制最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的一个或几个元素，并把结果压在栈顶。 （7）指令集 EVM的指令集被刻意保持在最小规模，以尽可能避免可能导致共识问题的错误。所有的指令都是针对256位这个基本的数据单位进行的操作，具备常用的算术、位、逻辑和比较操作，也可以进行条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。 （8）消息调用 合约可以通过消息调用的方式来调用其他合约，或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源，一个目标，数据负载，以太币，Gas和返回数据。事实上每个交易都可以被认为是一个顶层消息调用，这个消息调用会依次产生更多的消息调用。 一个合约可以决定剩余Gas的分配。如果在内部消息调用时发生了out-of-gas异常或者其他异常，合约将会得到通知，一个错误码被压入栈中。这种情况只是内部消息调用的Gas耗尽。 被调用的合约（发起调用的合约也一样）会拥有崭新的主存，并能够访问调用的负载。调用负载被存储在一个单独的被称为calldata的区域。调用执行结束后，返回数据将被存放在调用方预先分配好的一块内存中。调用层数被限制为1024。因此对于更加复杂的操作，我们应该使用循环而不是递归。 （9）代码调用和库 以太坊中存在一种特殊类型的消息调用，被称为callcode。它跟消息调用几乎完全一样，只是加载来自目标地址的代码将在发起调用的合约上下文中运行。这意味着一个合约可以在运行时从另外一个地址动态加载代码。 2.以太坊的状态转换 以太坊的状态转换是指在一个交易（TX）发生时，以太坊从一个正确状态（S）转变到下一个正确状态（S’）的转换过程。 以太坊的状态转换函数为APPLY（S，TX）-&gt;S’，可以定义如下： 1）检查交易的格式是否正确，签名是否有效，以及随机数是否与发送者账户的随机数匹配。如否，返回错误。 2）计算交易费用fee=STARTGAS*GASPRICE，并从签名中确定发送者的地址。从发送者的账户中减去交易费用和增加发送者的随机数。如果账户余额不足，返回错误。 3）设定初值Gas=STARTGAS，并根据交易中的字节数减去一定量的燃料值。 4）从发送者的账户转移价值到接收者账户。如果接收账户还不存在，创建此账户。如果接收账户是一个合约，运行合约的代码，直到代码运用结束或者燃料用完。 5）如果因为发送者账户没有足够的费用或者代码执行耗尽燃料导致价值转移失败，恢复原来的状态，但是还需要支付交易费用，交易费用加至矿工账户。 6）若代码执行成功，将所有剩余的燃料归还给发送者，消耗掉的燃料作为交易费用发送给矿工。 假设合约存储器开始时是空的，一个值为10以太、燃料为2000、燃料价格为0.001以太并且两个数据字段值为[2，‘CHARLIE’]的交易发送后，状态转换函数的处理过程如下： 1）检查交易是否有效，格式是否正确。 2）检查交易发送者是否至少有2000×0.001=2个以太币。如果有，从发送者账户中减去2个以太币。 3）初始设定Gas=2000，假设交易长为170字节，每字节的费用是5，减去850，所以还剩1150。 4）从发送者账户减去10个以太币，为合约账户增加10个以太币。 5）运行代码。在这个合约中，运行代码很简单：它检查合约存储器索引为2处是否已使用，注意到它未被使用，然后将其值置为CHARLIE。假设这消耗了187单位的燃料，于是剩余的燃料为1150-187=963。 6）向发送者的账户增加963×0.001=0.963个以太币，返回最终状态。 3.以太坊客户端 目前有4种语言编写的以太坊的客户端。它们分别是Go语言实现的客户端Geth，用C++实现的客户端Eth，用Python语言实现的客户端Pyethapp和⽤Java实现的客户端EthereumJ。其中，Go语言版是以太坊官方一直维护并推荐使用的客户端。 以太坊包括一个专用的客户端浏览器（Mist），使得用户可以运用各种各样的去中心化应用（DApp），发布智能合约。Mist由特殊的安全层、密钥管理、去中心化账户管理和与区块链相关的组件几部分组成。 2.2.3　以太坊智能合约 1.智能合约 以太坊是内置有图灵完备编程语言的区块链，通过建立抽象的基础层，使得任何人都能够创建合约和去中心化应用，并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。 智能合约就像能在以太坊的平台上创建的包含价值而且只有满足某些条件才能打开的加密箱子，并且因为图灵完备性、价值意识（value-awareness）、区块链意识（blockchain-awareness）和记录多状态所增加的功能而比比特币脚本所能提供的智能合约强大得多。 2.开发语言 以太坊具有4种专门语言：Serpent（受Python启发）、Solidity（受JavaScript启发）、Mutan（受Go启发）和LLL（受Lisp启发），都是为向合约编程言从底层开始设计的语言。Solidity是以太坊的首选语言。 以太坊区块链另外特征是图灵完备，这保证了以太坊可以解决所有的计算问题。此外，因为以太坊的语言是为区块链专门设计的，它有账户的概念，使得它在交易的可视化和查询账户状态方面提供了实时性。 3.代码执行 以太坊合约的代码是使用低级的基于堆栈的字节码的语言写成的，被称为“以太坊虚拟机代码”或者“EVM代码”。代码由一系列字节构成，每一个字节代表一种操作。操作可以访问3种存储数据的空间： 1）堆栈，一种后进先出的数据存储，入栈、出栈的基本单位为32字节。 2）内存，可无限扩展的字节队列。 3）合约的长期存储，一个密钥/数值的存储，其中密钥和数值都是32字节大小。与计算结束即重置的堆栈和内存不同，存储内容将长期保持。 代码可以像访问区块头数据一样访问数值、发送和接收到的消息中的数据，代码还可以返回数据的字节队列作为输出。。EVM代码的正式执行模型非常简单。当以太坊虚拟机运行时，它的完整的计算状态可以由元组（block_state，transaction，message，code，memory，stack，pc，gas）来定义，这⾥block_state是包含所有账户余额和存储的全局状态。每轮执行时，通过调出代码的第pc（程序计数器）个字节，每个指令如何影响元组都有定义。 例如，ADD将两个元素出栈并将它们的和入栈，将Gas减1并将 pc加1；stack将顶部的两个元素出栈，并将第2个元素插入由第1个元素定义的合约存储位置，同样减少最多200的Gas值，并将pc加1。 2.2.4　以太坊的去中心化应用 1.什么是DApp 一个DApp是由智能合约和客户端代码构成的。智能合约就像加密的包含价值的箱子。只有当特定条件被满足时它才被打开，它封装了一些逻辑、规则、处理步骤或者双方间的协议。 从架构角度而言，DApp非常类似于传统的Web应用。主要区别是：在传统Web应用中，客户端有JavaScript代码，由用户在自己的浏览器中执行；服务器端的代码由主机运行。但是在一个DApp中，它的智能逻辑运行在区块链上，客户端代码运行在特殊浏览器Mist里面。 2.应用举例 Augur（www.augur.net），一个正在开发去中心化预测系统。用户可以在这个应用上对各种事件打赌并下注，例如希拉里会不会赢得2016年美国的大选。 Maker（www.makerdao.com），一个正在开发中的金融类去中心化自治组织（DAO）。它维护一系列用于金融服务的合约软件（即智能合约），其中的一个软件是贷券信贷系统。 WeiFund，一个正在开发中的去中心化众筹平台。这个众筹平台的好处是资金不需要第三方托管，而是由程序托管，因此能够确保资金100%安全。 Boardroom，一个正在开发中的DAO管理平台。去中心化自治组织与传统公司一样，也可以有股份的概念，通常就是DAO的代币，这些代币又可以有投票权。 Ujo Music，一个音乐版权管理平台，测试版。Ujo Music作为音乐版权管理平台，可以直接在歌曲的创作者与消费者之间建立直接的联系，从而省去了中间商的费用提成。 贷券简称Dai或者Dai Bond，是一种可转让的、彼此等价可互换的“加密债券”，它流通于信贷系统中，使用者无需事先认证，同时又是低风险的。贷券的发行人（借款人）将在以太坊区块链上的以太等数字加密资产作为抵押品来发行贷券，再将这些贷券在市场上卖给贷券持有以换回流动性好的资产。 2.3　基于区块链的电子货币 2.3.1　元币平台 元币（metacoin）单词前缀“meta-”意为“在其中”。所以元币是衍生于现有加密货币体系之上，更专注于业务系统的代币种类。 2.3.2　代币 1.通过货币参数修改而建立的代币 2.基于共识机制的创新而建立的代币 比特币的共识机制是建立在用SHA256算法加密的作业证据基础之上的。 3.通过双目标挖矿机制创新而建立的代币 比特币的工作量证明算法仅仅具有一个目的，那就是确保比特链的安全。尽管相对于传统支付系统的安全，这点挖矿开销并不高，但是被指是一种浪费。双目标工作量证明算法在产生工作量证明来满足安全的同时，解决一个具体的问题。但这样做也带来一定的风险。在向货币安全添加额外功能的同时，也影响了其供求曲线。 4.注重隐私性的代币 比特币常常被误认为具有隐私性。事实上，通过大数据分析，关联身份和比特币地址相对容易，从而通过连接彼此的地址，解析一个人的比特币消费习惯。所以，一些代币专注于强隐私性，试图直接解决此问题。 2.3.3　货币的未来 加密货币的未来整体来说比比特币更加繁荣。它们在比特币的基础上引进了全新的去中心化的组织形式和共识机制，并由此衍生出了数以百计的不可思议的创新。这将影响与经济相关的众多部门，如：财政、经济、货币、中央银行、企业管理等。 2.4 本章小结 本章主要介绍了区块链技术的基础知识。首先，介绍了区块链技术，包括区块链技术的基本概念、框架与特点，核心技术及交易流程。在这个基础之上，我们详细介绍了区块链技术最成功的应用——用特币，包括概念、原理、及隐私模型。之后，我们介绍了区块链的另外一个重要应用——以太坊。以太坊是区块链技术发展的一个重要的方向，是区块链技术未来的一部分。我们介绍了以太坊技术、以太坊智能合约、以太坊去中心化应用、以太坊发展的现状及未来。最后，我们分析了现有的流行的电子货币各自的优缺点。 阅读更多" />
<meta property="og:description" content="目录： 2.1 区块链技术 区块链本质上是一个对等网络（peer-to-peer）的分布式账本数据库。区块链本身其实是一串链接的数据区块，其链接指针是采用密码学哈希算法对区块头进行处理所产生的区块头哈希值。每一个数据块中记录了一组采用哈希算法组成的树状交易状态信息，这样保证了每个区块内的交易数据不可篡改，区块链里链接的区块也不可篡改。 2.1.1　基本概念 完整的区块链系统包含的技术：存储数据的数据区块及其之上的数字签名、时间戳等技术，有作为支撑的P2P网络和维护系统的共识算法，有挖矿和工作量证明机制，有匿名交易机制和比特币钱包，还有链龄，UTXO、Merkle树、双花等相关技术概念。 1.数据区块 比特币的交易记录会保存在数据区块之中， 比特币系统中大约每10分 钟会产生一个区块， 每个数据区块一般包含区块头（Header） 和区块体 （Body） 两部分，如下图： 区块头封装了当前的版本号（Version）、前一区块地址（Prev-block）、时间戳（Timestamp）、随机数（Nonce）、当前区块的目标哈希值（Bits）、Merkle树的根值（Merkle-root）等信息。 区块体中则主要包含交易计数和交易详情。交易详情就是比特币系统中的记账本，每一笔交易都会被永久地记入数据区块中，而且任何人都可以查询。区块体中的Merkle树将会对每一笔交易进行数字签名，如此可以确保每一笔交易都不可伪造且没有重复交易。所有的交易将通过Merkle树的Hash过程产生一个唯一Merkle根值记入区块头。 2.挖矿与分叉问题 区块在挖矿过程中产生。所谓挖矿，实际上是穷举随机数算法，把上个区块的哈希值加上10分钟内的全部交易单打包，再加上一个随机数，算出一个256位的字符串哈希值，输入的随机数Nonce使哈希值满足一定条件就获得这个区块的交易记账权。 新产生的区块需要快速广播出去，以便其他节点进行对其验证，以防造假。每个区块存着上一个区块的哈希值，可以溯源到源头，只有经过验证后才最终获得区块的交易记账权。 3.时间戳和不可篡改性 时间戳是指从格林威治时间1970年01月01日00时00分00秒（北京时间 1970年01月01日08时00分00秒）起到现在的总秒数，通常是一个字符序列，唯一地标识某时刻的时间。在比特币系统中，获得记账权的节点在链接区块时需要在区块头中加盖时间戳，用于记录当前区块数据的写入时 间。 4.分布式数据库 比特币系统中的区块就像一个记账本一样，记录了所有比特币的交易 信息，每一个比特币用户的比特币收支情况都被永久地嵌入了数据区块中 以供别人查询。这些数据区块中的交易数据存放在每一个比特币用户的客 户端节点中，所有的这些节点则组成了比特币及其坚韧的分布式数据库系 统。任何一个节点的数据被破坏都不会影响整个数据库的正常运转，因为 其他的健康节点中都保存了完整的数据库。 5.UTXO交易模式 UTXO（Unspent Transaction Outputs）是未花费的交易输出，它是比特币交易过程中的基本单位。 具体见我的博文： http://blog.csdn.net/wu2374633583/article/details/79175211 6.哈希函数 哈希函数有着很多适合存储区块链数据的优点： 1）哈希函数处理过的数据是单向性的，通过处理过的输出值几乎不可能计算出原始的输入值； 2）哈希函数处理不同长度的数据所耗费的时间是一致的，输出值也是定长的； 3）哈希函数的输入值即使只相差一个字节，输出值的结果也会迥然不同。比特币系统中最常采用的哈希函数是双SHA256哈希函数，通俗来说就是将不同长度的原始数据用两次SHA256哈希函数进行处理，再输出长度为256的二进制数字来进行统一的识别和存储。 7.Merkle树 Merkle树是数据结构中的一种树，可以是二叉树，也可以是多叉树，它具有树结构的所有特点。 比特币区块链系统中的采用的是Merkle二叉树，它的作用主要是快速归纳和校验区块数据的完整性，它会将区块链中的数据分组进行哈希运算，向上不断递归运算产生新的哈希节点，最终只剩下一个Merkle根存入区块头中，每个哈希节点总是包含两个相邻的数据块或其哈希值。 使用Merkle树优点： 首先是极大地提高了区块链的运行效率和可扩展性，使得区块头只需包含根哈希值而不必封装所有底层数据。 其次是Merkle树可支持“简化支付验证协议”（SPV），即在不运行完整区块链网络节点的情况下，也能够对交易数据进行检验。 8.双重支付 双重支付问题又称为“双花”问题，即利用货币的数字特性用“同一笔钱”完成两次或者多次支付。 区块链技术则在去中心化的系统中不借助任何第三方机构而只通过分布式节点之间的相互验证和共识机制，有效地解决了双重支付问题，在信息传输的同时完成了价值转移。 区块链技术通过区块链接形成的时间戳技术加上验证比特币是否满足UTXO（未花费交易）和数字签名，有效避免了双重支付的问题。 9.P2P网络 P2P网络（peer-to-peer network，对等网络）是一种在对等者（peer）之间分配任务和⼯作负载的分布式应⽤架构，是对等计算模型在应用层形成的一种组网或网络形式。因此，从字面上，P2P可以理解为对等计算或对等网络。 区块链系统是建立在IP通信协议和分布式网络的基础上的，它不依靠传统的电路交换，而是建立于网络通信之上，完全通过互联网去交换信息。网络中所有的节点具有同等的地位，不存在任何特殊化的中心节点和层级结构，每个节点均会承担网络路由、验证数据区块等功能。网络的节点根据存储数据量的不同可以分为全节点和轻量级节点。 10.加密算法 除了哈希算法以外，比特币中还存在一种为交易加密的非对称加密算法（椭圆曲线加密算法）。非对称加密算法指的就是存在一对数学相关的密钥，使用其中一个密钥（公钥）进行加密的数据信息，只有使用另一个密钥（私钥）才能对该信息进行解密。 具体见我博文： http://blog.csdn.net/wu2374633583/article/details/79174547 非对称加密需要两个（一对）密钥：公开密钥（publickey）和私有密钥（privatekey），用公钥对数据进行加密后，只有对应的私钥才能解密；反之如果私钥用于加密，则只有对应的公钥才能解密。通信双方无须交换密钥就可以建立保密通信。 简单再说一下这几个问题： 1）Base58编码 可读性编码算法，类似古典密码学里的置换算法，理论上并不是密码学理论的核心内容。可读性编码算法不是为了保护数据的安全性，而是为了可读性。以二进制进行传输的信息是不具备可读性的，数字与字母组成的字符串才更容易被识别。可读性编码不改变信息内容，只改变信息内容的表现形式（部分编码算法还加入了容错校验功能，以保证传输过程中数据的准确性和完整性）。 Base64是常见的可读性编码算法，所谓Base64，即是说在编码过程中使用了64种字符：大写A到Z、小写a到z、数字0到9、“+”和“/”。 Base58是Bitcoin中使用的一种编码方式，主要用于产生Bitcoin的钱包地址。相比Base64，Base58不使用数字”0”，字母大写”O”，字母大写”I”，和字母小写”i”，以及”+”和”/”符号。 设计Base58主要的目的是： （1）避免混淆。在某些字体下，数字0和字母大写O，以及字母大写I和字母小写l会非常相似。 （2）不使用”+”和”/”的原因是，非字母或数字的字符串难以作为账号的一部分被接受。 （3）没有标点符号，通常不会被从中间分行。 （4）使大部分的软件支持双击选择整个字符串。 （5）比特币中使用Base58算法来对公钥的Hash160及私钥进行编码，以生成以1或3开头的比特币地址及WIF（Wallet import Format)格式的私钥。 2）私钥与公钥 比特币私钥其实是使用SHA-256生成的32字节（256位）的随机数，有效私钥的范围则取决于比特币使用的secp256k1 椭圆曲线数字签名标准。大小介于0x1 到0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140之间的数几乎都是合法的私钥。 在私钥的前面加上版本号，后面添加压缩标志和附加校验码，（所谓附加校验码，就是对私钥经过2次SHA-256运算，取两次哈希结果的前四字节），然后再对其进行Base58编码，就可以得到我们常见的WIF（Wallet import Format)格式的私钥。 私钥经过椭圆曲线乘法运算，可以得到公钥。公钥是椭圆曲线上的点，并具有x和y坐标。公钥有两种形式：压缩的与非压缩的。早期比特币均使用非压缩公钥，现在大部分客户端默认使用压缩公钥。 由于数学原理，从私钥推算公钥是可行的，从公钥逆推私钥是不可能的。 也就是说比特币的私钥是： 32字节随机数（使用SHA-256）+版本号+压缩标志+校验码（双哈希过的随机数的前四位字节） 3）地址的生成 首先将公钥进行SHA256和RIPEMD160双哈希运算，并生成20字节长度的摘要结果（即Hash160结果），这个将作为比特币地址的主体（body）信息，再在前面加上版本前缀0x00，在后面添加4个字节的地址校验码。地址校验码通过对摘要结果进行两次SHA256运算，取哈希值的前4位产生。最后通过Base58处理把连在一起的版本前缀、主体信息和校验码转换成可以容易让人识别的比特币字符地址。 地址组成： （公钥（双哈希）+版本号前缀+地址校验码）（base58） 11.数字签名 数字签名就是在信息后面加上另一段内容，作为发送者的证明并且证明信息没有被篡改。一般是发送者将信息用哈希算法处理得出一个哈希值，然后用私钥对该哈希值进行加密，得出一个签名。然后发送者再将信息和签名一起发送给接收者。接收者使用发送者的公钥对签名进行解密，还原出哈希值，再通过哈希算法来验证信息的哈希值和解密签名还原出来的哈希值是否一致，从而可以鉴定信息是否来自发送者或验证信息是否被篡改。 注意和比特币加密信息的区别，见我的博文： http://blog.csdn.net/wu2374633583/article/details/79174547 12.比特币的隐私模型 在比特币的隐私模型中，所有的交易不需要第三方的操控，也不需要提供任何身份信息，只需要提供比特币的地址就可以跟任何人完成一次准匿名的交易。 2.1.2　框架与特点 1.框架简介 我们将区块链的基础架构分为三层来进行讲解： 首先，在网络层之上，区块链是建立在IP通信协议和对等网络的基础上的一个分布式系统，和传统带中心的分布式系统不一样，它不依靠中心化的服务器节点来转发消息，而是每一个节点都参与消息的转发。因此P2P网络比传统网络具有更高的安全性，任何一个节点被攻击都不会影响整个网络，所有的节点都保存着整个系统的状态信息。 其次，在数据层面上，区块链就是一个只可追加、不可更改的分布式数据库系统，是一个分布式账本。如果是公开的区块链，也就是公有链，那么这个账本可以被任何人在任何地方进行查询，完全公开透明。在区块链网络中，节点通过使用共识算法来维持网络中账本数据库的一致性。同时采用密码学的签名和哈希算法来确保这个数据库不可篡改，不能作伪，并且可追溯。 再次，在应用层面，我们可以用区块链代替传统的登记、清算系统。 在应用方面，区块链平台能够提供编程环境让用户编写智能合约。通过智能合约，可以把业务规则转化成在区块链平台自动执行的合约，该合约的执行不依赖可信任的第三方，也不受人为的干预。 2.架构特点 区块链具有去中心化、可靠数据库、开源可编程、集体维护、安全可信、交易准匿名性等特点。如果一个系统不具有以上特征，将不能被视为基于区块链技术的应用。 （1）去中心化 区块链数据的存储、传输、验证等过程均基于分布式的系统结构，作为区块链一种部署模式，公共链网络中所有参与的节点都可以具有同等的权利和义务。 （2）可靠数据库 区块链系统的数据库采用分布式存储，任何参与节点都可以拥有一份完整的数据库拷贝。 区块链数据的存储还带有时间戳，从而为数据添加了时间维度，具有极高的可追溯性。 （3）开源可编程 区块链系统通常是开源的，代码高度透明公共链的数据和程序对所有人公开，任何人都可以通过接口查询系统中的数据。并且区块链平台还提供灵活的脚本代码系统，支持用户创建高级的智能合约、货币和去中心化应用。 （4）集体维护 系统中的数据块由整个系统中所有具有记账功能的节点来共同维护，任一节点的损坏或失去都不会影响整个系统的运作。 （5）安全可信 区块链技术采用非对称密码学原理对交易进行签名，使得交易不能被伪造；同时利用哈希算法保证交易数据不能被轻易篡改，最后借助分布式系统各节点的工作量证明等共识算法形成强大的算力来抵御破坏者的攻击，保证区块链中的区块以及区块内的交易数据不可篡改和不可伪造，因此具有极高的安全性。 （6）准匿名性 区块链系统采用与用户公钥挂钩的地址来做用户标识，不需要传统的基于PKI的第三方认证中心（Certificate Authority，CA）颁发数字证书来确认身份。通过在全网节点运行共识算法，建立网络中诚实节点对全网状态的共识，间接地建立了节点间的信任。 区块链技术的核心优势是去中心化，能够通过运用哈希算法、数字签名、时间戳、分布式共识和经济激励等手段，在节点无需互相信任的分布式系统中建立信任，实现点对点交易和协作，从而为中心化机构普遍存在的低成本、低效率和数据存储不安全等问题提供了解决方案。 2.1.3　区块链运作的核心技术 1.区块链的链接 区块链即由一个个区块组成的链。每个区块分为区块头和区块体（含交易数据）两个部分。区块头包括用来实现区块链接的前一区块的哈希（PrevHash）值（又称散列值）和用于计算挖矿难度的随机数。 2.共识机制 可以将区块链理解为一个基于互联网的去中心化记账系统。区块链技术的核心是在没有中心控制的情况下，在互相没有信任基础的个体之间就交易的合法性等达成共识的共识机制。 区块链的共识机制目前主要有4类：PoW、PoS、DPoS、分布式一致性算法。 （1）PoW PoW（工作量证明），也就是像比特币的挖矿机制，矿工通过把网络尚未记录的现有交易打包到一个区块，然后不断遍历尝试来寻找一个随机数，使得新区块加上随机数的哈希值满足一定的难度条件，找到满足条件的随机数，就相当于确定了区块链最新的一个区块，也相当于获得了区块链的本轮记账权。矿工把满足挖矿难度条件的区块在网络中广播出去，全网其他节点在验证该区块满足挖矿难度条件，同时区块其的交易数据符合协议规范后，将各自把该区块链接到自己版本的区块链上，从而在全网形成对当前网络状态的共识。 优点： 完全去中心化，节点自由进出，避免了建立和维护中心化信用机构的成本。 缺点： 目前比特币挖矿造成大量的资源浪费；另外挖矿的激励机制也 造成矿池算力的高度集中，背离了当初去中心化设计的初衷。更大的问题是PoW机制的共识达成的周期较长，每秒只能最多做7笔交易，不适合商业应用。 （2）PoS PoS权益证明，要求节点提供拥有一定数量的代币证明来获取竞争区块链记账权的一种分布式共识机制。如果单纯依靠代币余额来决定记账者必然使得富有者胜出，导致记账权的中心化，降低共识的公正性，因此不同的PoS机制在权益证明的基础上，采用不同方式来增加记账权的随机性来避免中心化。 优点： 在一定程度上缩短了共识达成的时间，降低了PoW机制的资源浪费。 缺点： 破坏者对网络攻击的成本低，网络的安全性有待验证。另外拥 有代币数量大的节点获得记账权的几率更大，会使得网络的共识受少数富裕账户支配，从而失去公正性。 （3）DPoS DPoS（股份授权证明）机制，类似于董事会投票。比特股（bitshares）采用的PoS机制是持股者投票选出一定数量的见证人，每个见证人按序有两秒的权限时间成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一个时间片对应的见证人。持股人可以随时通过投票更换这些见证人。 优点： 大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。 ·缺点： 选举固定数量的见证人作为记账候选人有可能不适合于完全去中心化的场景。另外在网络节点数少的场景，选举的见证人的代表性也不强。 （4）分布式一致性算法 分布式一致性算法是基于传统的分布式一致性技术。其中有分为解决拜占庭将军问题的拜占庭容错算法，如PBFT。另外解决非拜占庭问题的分布式一致性算法（Pasox、Raft）。该类算法目前是联盟链和私有链链场景中常用的共识机制。 优点：实现秒级的快速共识机制，保证一致性。 缺点：去中心化程度不如公有链上的共识机制；更适合多方参与的多中心商业模式。 3.解锁脚本 脚本是区块链上实现自动验证、自动执行合约的重要技术。每一笔交易的每一项输出严格意义上并不是指向一个地址，而是指向一个脚本。脚本类似一套规则，它约束着接收方怎样才能花掉这个输出上锁定的资产。 交易的合法性验证也依赖于脚本。目前它依赖于两类脚本：锁定脚本与解锁脚本。 锁定脚本是在输出交易上加上的条件，通过一段脚本语言来实现，位于交易的输出。解锁脚本与锁定脚本相对应，只有满足锁定脚本要求的条件，才能花掉这个脚本上对应的资产，位于交易的输入。通过脚本语言可以表达很多灵活的条件。解释脚本是通过类似我们编程领域里的“虚拟机”，它分布式运行在区块链网络上的每一个节点。 比特币的脚本分为两种：一种是普通的P2PKH，，即支付给公钥的哈希地址，接收方只需要使用地址对应的私钥对该输出进行签名，即可花掉该输出。另一种是P2SH，即支付脚本的哈希。 比如在比特币中，P2PKH的脚本规则如下： Pubkey script: OP_DUP OP_HASH160 &lt;PubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG Signature script: &lt;sig&gt; &lt;pubkey&gt; P2SH的脚本规则如下： Pubkey script: OP_HASH160 &lt;Hash160(redeemScript)&gt; OP_EQUAL Signature script: &lt;sig&gt; [sig] [sig...] &lt;redeemScript&gt; 在上述的两种脚本规则里，Pubkey script代表锁定脚本，Signature script代表解锁脚本。OP_开头的单词是相关的脚本命令，也是“虚拟机”所能解析的指令。 注意的是，比特币的脚本机制比较简单，而以太坊的脚本机制是支持脚本的一套图灵完备语言。脚本机制让区块链技术作为一项底层协议成为可能。 4.交易规则 区块链的交易就是构成区块的基本单位，也是区块链负责记录的实际有效内容。一个区块链交易可以是一次转账，也可以是智能合约的部署等其他事务。 对于比特币而言，交易意味着一次支付转账，规则如下： 1）交易的输入和输出不能为空。 2）对交易的每个输入，如果其对应的UTXO输出能在当前交易池中找到，则拒绝该交易。因为当前交易池是未被记录在区块链中的交易，而交易的每个输入，应该来自确认的UTXO。如果在当前交易池中找到，那就是双花交易。 3）交易中的每个输入，其对应的输出必须是UTXO。 4）每个输入的解锁脚本（unlocking script）必须和相应输出的锁定脚本（locking script）共同验证交易的合规性。 注意： 对于以太坊来说，交易还可能是智能合约的部署。交易规则就确定了符合一定语法规则的合约才能被部署在区块链上。 5.交易优先级 区块链交易的优先级由区块链协议规则决定。对于比特币而言，交易被区块包含的优先次序由交易广播到网络上的时间和交易额的大小决定。 对于以太坊而言，交易的优先级还与交易的发布者愿意支付的交易费用有关。 6.Merkle证明 比特币区块链使用了Merkle证明，为的是将交易存储在每一个区块中。使得交易不能被篡改，同时也容易验证交易是否包含在一个特定区块中，Merkle树的一个重要使用场景就是快速支付验证，轻量级节点（light client）不用下载每一笔交易以及每一个区块，可以仅下载链的区块头，每个区块中仅包含5项内容（上一区块头的哈希值，时间戳，挖矿难度值，工作量证明随机数，包含该区块交易的Merkle树的根哈希），数据块大小为80字节。如果一个轻客户端希望确定一笔交易的状态，它可以简单地要求一个Merkle证明，显示出一个在Merkle树特定的交易，其根是在主链（main chain，非分叉链）上的区块头。 局限性：虽然可以证明包含的交易，但无法证明任何当前的状态（例如：数字资产的持有，名称注册，融合约的状态等）。 以太坊的改进：以太坊的每一个区块头中并非只包含一棵Merkle树，而是包含了3棵Merkle树（见图2-12），分别对应了3种对象：交易，收据（基本上，它是展示每一笔交易影响的数据条），状态。 这三棵树允许轻客户端轻松地进行并核实以下类型的查询答案： 1）这笔交易被包含在特定的区块中了吗？ 2）告诉我这个地址在过去30天中，发出X类型事件的所有实例（例如，一个众筹合约完成了它的目标）。 3）目前我的账户余额是多少？ 4）这个账户是否存在？ 5）假装在这个合约中运行这笔交易，它的输出会是什么？ 第1种和第5种是由交易树（transaction tree）来处理的；第3和第4种则是由状态树（state tree）负责处理，第2种则由收据树（receipt tree）处理。 7.RLP RLP（递归长度前缀编码）是Ethereum中对象序列化的一个主要编码方式，其目的是对任意嵌套的二进制数据的序列进行编码。 这种编码格式将任意长度和维度的字符串构成的数组串连接成字符串。 例如： [’dog‘，’cat‘]被串接（以字节数组格式）为[130，67，100，111，103，67，99，97，116]； 解释：基本的思想是 把数据类型和长度编码成一个单独的字节放在实际数据的前面（例如‘dog’的字节数组编码为[100，111，103]，于是串接后就成了[67，100，111，103]）。注意RLP编码正如其名字表示的一样，是递归的； 2.1.4　区块链交易流程 区块链上的交易指的是转账，如果每一笔转账都需要构造一笔交易数据会比较笨拙，为了使得价值易于组合与分割，比特币的交易被设计为可以纳入多个输入和输出，即一笔交易可以转账给多个人，也就是所谓的UTXO。 区块链交易的整个生命周期：从生成到在网络中传播，再到通过工作量证明、整个网络节点验证，最终记录到区块链。整个区块链交易流程如下： （1）交易的生成。所有者A利⽤他的私钥对前一次交易和下一位所有者B签署一个数字签名，并将这个签名附加在这枚货币的末尾，制作成交易单。 （2）交易的传播。A将交易单广播至全网，每个节点都将收到的交易信息纳入一个区块中。 （3）工作量证明。每个节点通过相当于解一道数学题的工作量证明机制，从而获得创建新区块的权力，并争取得到数字货币的奖励。 （4）整个网络节点验证。当一个节点找到解时，它就向全网广播该区块记录的所有盖时间戳交易，并由全网其他节点核对。 （5）记录到区块链。全网其他节点核对该区块记账的正确性，没有错误后他们将在该合法区块之后竞争下一个区块，这样就形成了一个合法记账的区块链。 2.2 以太坊 2.2.1　什么是以太坊 以太坊的目的是对脚本、竞争币和链上元协议（on-chain meta-protocol）等概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、图灵完备的、易于开发和协同的应用。 以太坊的新颖在于其神奇的计算机网络，它促成了一种新型的软件应用，真正的去中心化应用。将信任逻辑嵌入小程序中，运行在区块链上。而与比特币相比，以太坊建立了一种新的密码学技术基础框架，在其上开发应用更加容易，并对轻客户端友好，同时允许应用共享一个可行的经济环境和可靠的区块链安全。 以太坊是个平台和编程语言，包括数字货币以太币（Ether），以及用来构建和发布分布式应用的以太脚本（EtherScript）。 从最底层角度来看，以太坊是一个多层的、基于密码学的开源技术协议。它的不同功能模块通过设计进行了全面的整合，作为一个整体，它是一个创建和部署去中心化应用的综合平台。 同时，以太坊也是区块链与智能合约的完美结合，是智能合约的完整解决方案，被设计成了一个通用的去中心化平台，拥有一套完整的、可以扩展其功能的工具，在P2P网络、加密、HttpClient等技术的支持下实现了一个类似于比特币的区块链。它通过工作量证明机制实现共识，由矿工挖矿，通过对新的网络协议的制定实现对区块链的同步等操作。不同于比特币的是，在以太坊上可以任意编写智能合约，通过智能合约实现强大的功能，实现去中心化应用的开发。在以太坊上部署的智能合约运行在以太坊特有的虚拟机上，通过以太坊虚拟机和RPC接口与底层区块链进行交互。 2.2.2　以太坊技术 1.以太坊核心概念 （1）以太坊虚拟机 以太坊虚拟机（EVM）是以太坊中智能合约的运行环境。实际上它是由许多互相连接的计算机组成的。任何人都可以上传程序，并让这些程序自动执行，同时保证现在和所有以前的每个程序的状态总是公共可见的。 （2）账户 以太坊中有两类账户，它们共用同一个地址空间。外部账户，该类账户被公钥-私钥对控制。合约账户，该类账户被存储在账户中的代码控制。外部账户的地址是由公钥决定的，合约账户的地址是在创建合约时由合约创建者的地址和该地址发出过的交易数量计算得到。两类账户的唯一区别是：外部账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。 以太坊的账户包含4个部分：①随机数，用于确定每笔交易只能被处理一次的计数器；②账户目前的以太币余额；③账户的合约代码（如果有的话）；④账户的存储（默认为空）。 （3）消息 以太坊的消息在某种程度上类似于比特币的交易，但是两者之间存在3点重要的不同。 1）以太坊的消息可以由外部实体或者合约创建，然后比特币的交易只能从外部创建。 2）以太坊消息可以选择包含数据。 3）如果以太坊消息的接收者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。 （4）交易 以太坊中“交易”是指存储从外部账户发出的消息的签名数据包。交易包含消息的接收者、用于确认发送者的签名、以太币账户余额、要发送的数据和被称为STARTGAS和GASPRICE的两个数值。为了防止代码出现指数型爆炸和无限循环，每笔交易需要对执行代码所引发的计算步骤做出限制。STARTGAS就是通过需要支付的燃料来对计算步骤进行限制，GASPRICE是每一计算步骤需要支付矿工的燃料的价格。 （5）Gas 以太坊上的每笔交易都会被收取一定数量的燃料Gas，设置Gas的目的是限制交易执行所需的工作量，同时为交易的执行支付费用。 （6）存储、主存和栈 每个账户都有一块永久的内存区域，被称为存储，其形式为key-value，key和value的长度均为256位。在合约里，不能遍历账户的存储。相对于主存和栈，存储的读操作开销较大，修改存储甚至更多。一个合约只能对它自己的存储进行读写。 第二个内存区被称为主存。合约执行每次消息调用时都有一块新的被清除过的主存。 EVM不是基于寄存器的，而是基于栈的虚拟机。因此所有的计算都在一个称为栈的区域内执行。栈最大有1024个元素，每个元素有256位。对栈的访问只限于其顶端，允许复制最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的一个或几个元素，并把结果压在栈顶。 （7）指令集 EVM的指令集被刻意保持在最小规模，以尽可能避免可能导致共识问题的错误。所有的指令都是针对256位这个基本的数据单位进行的操作，具备常用的算术、位、逻辑和比较操作，也可以进行条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。 （8）消息调用 合约可以通过消息调用的方式来调用其他合约，或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源，一个目标，数据负载，以太币，Gas和返回数据。事实上每个交易都可以被认为是一个顶层消息调用，这个消息调用会依次产生更多的消息调用。 一个合约可以决定剩余Gas的分配。如果在内部消息调用时发生了out-of-gas异常或者其他异常，合约将会得到通知，一个错误码被压入栈中。这种情况只是内部消息调用的Gas耗尽。 被调用的合约（发起调用的合约也一样）会拥有崭新的主存，并能够访问调用的负载。调用负载被存储在一个单独的被称为calldata的区域。调用执行结束后，返回数据将被存放在调用方预先分配好的一块内存中。调用层数被限制为1024。因此对于更加复杂的操作，我们应该使用循环而不是递归。 （9）代码调用和库 以太坊中存在一种特殊类型的消息调用，被称为callcode。它跟消息调用几乎完全一样，只是加载来自目标地址的代码将在发起调用的合约上下文中运行。这意味着一个合约可以在运行时从另外一个地址动态加载代码。 2.以太坊的状态转换 以太坊的状态转换是指在一个交易（TX）发生时，以太坊从一个正确状态（S）转变到下一个正确状态（S’）的转换过程。 以太坊的状态转换函数为APPLY（S，TX）-&gt;S’，可以定义如下： 1）检查交易的格式是否正确，签名是否有效，以及随机数是否与发送者账户的随机数匹配。如否，返回错误。 2）计算交易费用fee=STARTGAS*GASPRICE，并从签名中确定发送者的地址。从发送者的账户中减去交易费用和增加发送者的随机数。如果账户余额不足，返回错误。 3）设定初值Gas=STARTGAS，并根据交易中的字节数减去一定量的燃料值。 4）从发送者的账户转移价值到接收者账户。如果接收账户还不存在，创建此账户。如果接收账户是一个合约，运行合约的代码，直到代码运用结束或者燃料用完。 5）如果因为发送者账户没有足够的费用或者代码执行耗尽燃料导致价值转移失败，恢复原来的状态，但是还需要支付交易费用，交易费用加至矿工账户。 6）若代码执行成功，将所有剩余的燃料归还给发送者，消耗掉的燃料作为交易费用发送给矿工。 假设合约存储器开始时是空的，一个值为10以太、燃料为2000、燃料价格为0.001以太并且两个数据字段值为[2，‘CHARLIE’]的交易发送后，状态转换函数的处理过程如下： 1）检查交易是否有效，格式是否正确。 2）检查交易发送者是否至少有2000×0.001=2个以太币。如果有，从发送者账户中减去2个以太币。 3）初始设定Gas=2000，假设交易长为170字节，每字节的费用是5，减去850，所以还剩1150。 4）从发送者账户减去10个以太币，为合约账户增加10个以太币。 5）运行代码。在这个合约中，运行代码很简单：它检查合约存储器索引为2处是否已使用，注意到它未被使用，然后将其值置为CHARLIE。假设这消耗了187单位的燃料，于是剩余的燃料为1150-187=963。 6）向发送者的账户增加963×0.001=0.963个以太币，返回最终状态。 3.以太坊客户端 目前有4种语言编写的以太坊的客户端。它们分别是Go语言实现的客户端Geth，用C++实现的客户端Eth，用Python语言实现的客户端Pyethapp和⽤Java实现的客户端EthereumJ。其中，Go语言版是以太坊官方一直维护并推荐使用的客户端。 以太坊包括一个专用的客户端浏览器（Mist），使得用户可以运用各种各样的去中心化应用（DApp），发布智能合约。Mist由特殊的安全层、密钥管理、去中心化账户管理和与区块链相关的组件几部分组成。 2.2.3　以太坊智能合约 1.智能合约 以太坊是内置有图灵完备编程语言的区块链，通过建立抽象的基础层，使得任何人都能够创建合约和去中心化应用，并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。 智能合约就像能在以太坊的平台上创建的包含价值而且只有满足某些条件才能打开的加密箱子，并且因为图灵完备性、价值意识（value-awareness）、区块链意识（blockchain-awareness）和记录多状态所增加的功能而比比特币脚本所能提供的智能合约强大得多。 2.开发语言 以太坊具有4种专门语言：Serpent（受Python启发）、Solidity（受JavaScript启发）、Mutan（受Go启发）和LLL（受Lisp启发），都是为向合约编程言从底层开始设计的语言。Solidity是以太坊的首选语言。 以太坊区块链另外特征是图灵完备，这保证了以太坊可以解决所有的计算问题。此外，因为以太坊的语言是为区块链专门设计的，它有账户的概念，使得它在交易的可视化和查询账户状态方面提供了实时性。 3.代码执行 以太坊合约的代码是使用低级的基于堆栈的字节码的语言写成的，被称为“以太坊虚拟机代码”或者“EVM代码”。代码由一系列字节构成，每一个字节代表一种操作。操作可以访问3种存储数据的空间： 1）堆栈，一种后进先出的数据存储，入栈、出栈的基本单位为32字节。 2）内存，可无限扩展的字节队列。 3）合约的长期存储，一个密钥/数值的存储，其中密钥和数值都是32字节大小。与计算结束即重置的堆栈和内存不同，存储内容将长期保持。 代码可以像访问区块头数据一样访问数值、发送和接收到的消息中的数据，代码还可以返回数据的字节队列作为输出。。EVM代码的正式执行模型非常简单。当以太坊虚拟机运行时，它的完整的计算状态可以由元组（block_state，transaction，message，code，memory，stack，pc，gas）来定义，这⾥block_state是包含所有账户余额和存储的全局状态。每轮执行时，通过调出代码的第pc（程序计数器）个字节，每个指令如何影响元组都有定义。 例如，ADD将两个元素出栈并将它们的和入栈，将Gas减1并将 pc加1；stack将顶部的两个元素出栈，并将第2个元素插入由第1个元素定义的合约存储位置，同样减少最多200的Gas值，并将pc加1。 2.2.4　以太坊的去中心化应用 1.什么是DApp 一个DApp是由智能合约和客户端代码构成的。智能合约就像加密的包含价值的箱子。只有当特定条件被满足时它才被打开，它封装了一些逻辑、规则、处理步骤或者双方间的协议。 从架构角度而言，DApp非常类似于传统的Web应用。主要区别是：在传统Web应用中，客户端有JavaScript代码，由用户在自己的浏览器中执行；服务器端的代码由主机运行。但是在一个DApp中，它的智能逻辑运行在区块链上，客户端代码运行在特殊浏览器Mist里面。 2.应用举例 Augur（www.augur.net），一个正在开发去中心化预测系统。用户可以在这个应用上对各种事件打赌并下注，例如希拉里会不会赢得2016年美国的大选。 Maker（www.makerdao.com），一个正在开发中的金融类去中心化自治组织（DAO）。它维护一系列用于金融服务的合约软件（即智能合约），其中的一个软件是贷券信贷系统。 WeiFund，一个正在开发中的去中心化众筹平台。这个众筹平台的好处是资金不需要第三方托管，而是由程序托管，因此能够确保资金100%安全。 Boardroom，一个正在开发中的DAO管理平台。去中心化自治组织与传统公司一样，也可以有股份的概念，通常就是DAO的代币，这些代币又可以有投票权。 Ujo Music，一个音乐版权管理平台，测试版。Ujo Music作为音乐版权管理平台，可以直接在歌曲的创作者与消费者之间建立直接的联系，从而省去了中间商的费用提成。 贷券简称Dai或者Dai Bond，是一种可转让的、彼此等价可互换的“加密债券”，它流通于信贷系统中，使用者无需事先认证，同时又是低风险的。贷券的发行人（借款人）将在以太坊区块链上的以太等数字加密资产作为抵押品来发行贷券，再将这些贷券在市场上卖给贷券持有以换回流动性好的资产。 2.3　基于区块链的电子货币 2.3.1　元币平台 元币（metacoin）单词前缀“meta-”意为“在其中”。所以元币是衍生于现有加密货币体系之上，更专注于业务系统的代币种类。 2.3.2　代币 1.通过货币参数修改而建立的代币 2.基于共识机制的创新而建立的代币 比特币的共识机制是建立在用SHA256算法加密的作业证据基础之上的。 3.通过双目标挖矿机制创新而建立的代币 比特币的工作量证明算法仅仅具有一个目的，那就是确保比特链的安全。尽管相对于传统支付系统的安全，这点挖矿开销并不高，但是被指是一种浪费。双目标工作量证明算法在产生工作量证明来满足安全的同时，解决一个具体的问题。但这样做也带来一定的风险。在向货币安全添加额外功能的同时，也影响了其供求曲线。 4.注重隐私性的代币 比特币常常被误认为具有隐私性。事实上，通过大数据分析，关联身份和比特币地址相对容易，从而通过连接彼此的地址，解析一个人的比特币消费习惯。所以，一些代币专注于强隐私性，试图直接解决此问题。 2.3.3　货币的未来 加密货币的未来整体来说比比特币更加繁荣。它们在比特币的基础上引进了全新的去中心化的组织形式和共识机制，并由此衍生出了数以百计的不可思议的创新。这将影响与经济相关的众多部门，如：财政、经济、货币、中央银行、企业管理等。 2.4 本章小结 本章主要介绍了区块链技术的基础知识。首先，介绍了区块链技术，包括区块链技术的基本概念、框架与特点，核心技术及交易流程。在这个基础之上，我们详细介绍了区块链技术最成功的应用——用特币，包括概念、原理、及隐私模型。之后，我们介绍了区块链的另外一个重要应用——以太坊。以太坊是区块链技术发展的一个重要的方向，是区块链技术未来的一部分。我们介绍了以太坊技术、以太坊智能合约、以太坊去中心化应用、以太坊发展的现状及未来。最后，我们分析了现有的流行的电子货币各自的优缺点。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/02/02/85baa12f83882111712551ba4c4372aa.html" />
<meta property="og:url" content="https://mlh.app/2018/02/02/85baa12f83882111712551ba4c4372aa.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-02T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"目录： 2.1 区块链技术 区块链本质上是一个对等网络（peer-to-peer）的分布式账本数据库。区块链本身其实是一串链接的数据区块，其链接指针是采用密码学哈希算法对区块头进行处理所产生的区块头哈希值。每一个数据块中记录了一组采用哈希算法组成的树状交易状态信息，这样保证了每个区块内的交易数据不可篡改，区块链里链接的区块也不可篡改。 2.1.1　基本概念 完整的区块链系统包含的技术：存储数据的数据区块及其之上的数字签名、时间戳等技术，有作为支撑的P2P网络和维护系统的共识算法，有挖矿和工作量证明机制，有匿名交易机制和比特币钱包，还有链龄，UTXO、Merkle树、双花等相关技术概念。 1.数据区块 比特币的交易记录会保存在数据区块之中， 比特币系统中大约每10分 钟会产生一个区块， 每个数据区块一般包含区块头（Header） 和区块体 （Body） 两部分，如下图： 区块头封装了当前的版本号（Version）、前一区块地址（Prev-block）、时间戳（Timestamp）、随机数（Nonce）、当前区块的目标哈希值（Bits）、Merkle树的根值（Merkle-root）等信息。 区块体中则主要包含交易计数和交易详情。交易详情就是比特币系统中的记账本，每一笔交易都会被永久地记入数据区块中，而且任何人都可以查询。区块体中的Merkle树将会对每一笔交易进行数字签名，如此可以确保每一笔交易都不可伪造且没有重复交易。所有的交易将通过Merkle树的Hash过程产生一个唯一Merkle根值记入区块头。 2.挖矿与分叉问题 区块在挖矿过程中产生。所谓挖矿，实际上是穷举随机数算法，把上个区块的哈希值加上10分钟内的全部交易单打包，再加上一个随机数，算出一个256位的字符串哈希值，输入的随机数Nonce使哈希值满足一定条件就获得这个区块的交易记账权。 新产生的区块需要快速广播出去，以便其他节点进行对其验证，以防造假。每个区块存着上一个区块的哈希值，可以溯源到源头，只有经过验证后才最终获得区块的交易记账权。 3.时间戳和不可篡改性 时间戳是指从格林威治时间1970年01月01日00时00分00秒（北京时间 1970年01月01日08时00分00秒）起到现在的总秒数，通常是一个字符序列，唯一地标识某时刻的时间。在比特币系统中，获得记账权的节点在链接区块时需要在区块头中加盖时间戳，用于记录当前区块数据的写入时 间。 4.分布式数据库 比特币系统中的区块就像一个记账本一样，记录了所有比特币的交易 信息，每一个比特币用户的比特币收支情况都被永久地嵌入了数据区块中 以供别人查询。这些数据区块中的交易数据存放在每一个比特币用户的客 户端节点中，所有的这些节点则组成了比特币及其坚韧的分布式数据库系 统。任何一个节点的数据被破坏都不会影响整个数据库的正常运转，因为 其他的健康节点中都保存了完整的数据库。 5.UTXO交易模式 UTXO（Unspent Transaction Outputs）是未花费的交易输出，它是比特币交易过程中的基本单位。 具体见我的博文： http://blog.csdn.net/wu2374633583/article/details/79175211 6.哈希函数 哈希函数有着很多适合存储区块链数据的优点： 1）哈希函数处理过的数据是单向性的，通过处理过的输出值几乎不可能计算出原始的输入值； 2）哈希函数处理不同长度的数据所耗费的时间是一致的，输出值也是定长的； 3）哈希函数的输入值即使只相差一个字节，输出值的结果也会迥然不同。比特币系统中最常采用的哈希函数是双SHA256哈希函数，通俗来说就是将不同长度的原始数据用两次SHA256哈希函数进行处理，再输出长度为256的二进制数字来进行统一的识别和存储。 7.Merkle树 Merkle树是数据结构中的一种树，可以是二叉树，也可以是多叉树，它具有树结构的所有特点。 比特币区块链系统中的采用的是Merkle二叉树，它的作用主要是快速归纳和校验区块数据的完整性，它会将区块链中的数据分组进行哈希运算，向上不断递归运算产生新的哈希节点，最终只剩下一个Merkle根存入区块头中，每个哈希节点总是包含两个相邻的数据块或其哈希值。 使用Merkle树优点： 首先是极大地提高了区块链的运行效率和可扩展性，使得区块头只需包含根哈希值而不必封装所有底层数据。 其次是Merkle树可支持“简化支付验证协议”（SPV），即在不运行完整区块链网络节点的情况下，也能够对交易数据进行检验。 8.双重支付 双重支付问题又称为“双花”问题，即利用货币的数字特性用“同一笔钱”完成两次或者多次支付。 区块链技术则在去中心化的系统中不借助任何第三方机构而只通过分布式节点之间的相互验证和共识机制，有效地解决了双重支付问题，在信息传输的同时完成了价值转移。 区块链技术通过区块链接形成的时间戳技术加上验证比特币是否满足UTXO（未花费交易）和数字签名，有效避免了双重支付的问题。 9.P2P网络 P2P网络（peer-to-peer network，对等网络）是一种在对等者（peer）之间分配任务和⼯作负载的分布式应⽤架构，是对等计算模型在应用层形成的一种组网或网络形式。因此，从字面上，P2P可以理解为对等计算或对等网络。 区块链系统是建立在IP通信协议和分布式网络的基础上的，它不依靠传统的电路交换，而是建立于网络通信之上，完全通过互联网去交换信息。网络中所有的节点具有同等的地位，不存在任何特殊化的中心节点和层级结构，每个节点均会承担网络路由、验证数据区块等功能。网络的节点根据存储数据量的不同可以分为全节点和轻量级节点。 10.加密算法 除了哈希算法以外，比特币中还存在一种为交易加密的非对称加密算法（椭圆曲线加密算法）。非对称加密算法指的就是存在一对数学相关的密钥，使用其中一个密钥（公钥）进行加密的数据信息，只有使用另一个密钥（私钥）才能对该信息进行解密。 具体见我博文： http://blog.csdn.net/wu2374633583/article/details/79174547 非对称加密需要两个（一对）密钥：公开密钥（publickey）和私有密钥（privatekey），用公钥对数据进行加密后，只有对应的私钥才能解密；反之如果私钥用于加密，则只有对应的公钥才能解密。通信双方无须交换密钥就可以建立保密通信。 简单再说一下这几个问题： 1）Base58编码 可读性编码算法，类似古典密码学里的置换算法，理论上并不是密码学理论的核心内容。可读性编码算法不是为了保护数据的安全性，而是为了可读性。以二进制进行传输的信息是不具备可读性的，数字与字母组成的字符串才更容易被识别。可读性编码不改变信息内容，只改变信息内容的表现形式（部分编码算法还加入了容错校验功能，以保证传输过程中数据的准确性和完整性）。 Base64是常见的可读性编码算法，所谓Base64，即是说在编码过程中使用了64种字符：大写A到Z、小写a到z、数字0到9、“+”和“/”。 Base58是Bitcoin中使用的一种编码方式，主要用于产生Bitcoin的钱包地址。相比Base64，Base58不使用数字”0”，字母大写”O”，字母大写”I”，和字母小写”i”，以及”+”和”/”符号。 设计Base58主要的目的是： （1）避免混淆。在某些字体下，数字0和字母大写O，以及字母大写I和字母小写l会非常相似。 （2）不使用”+”和”/”的原因是，非字母或数字的字符串难以作为账号的一部分被接受。 （3）没有标点符号，通常不会被从中间分行。 （4）使大部分的软件支持双击选择整个字符串。 （5）比特币中使用Base58算法来对公钥的Hash160及私钥进行编码，以生成以1或3开头的比特币地址及WIF（Wallet import Format)格式的私钥。 2）私钥与公钥 比特币私钥其实是使用SHA-256生成的32字节（256位）的随机数，有效私钥的范围则取决于比特币使用的secp256k1 椭圆曲线数字签名标准。大小介于0x1 到0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140之间的数几乎都是合法的私钥。 在私钥的前面加上版本号，后面添加压缩标志和附加校验码，（所谓附加校验码，就是对私钥经过2次SHA-256运算，取两次哈希结果的前四字节），然后再对其进行Base58编码，就可以得到我们常见的WIF（Wallet import Format)格式的私钥。 私钥经过椭圆曲线乘法运算，可以得到公钥。公钥是椭圆曲线上的点，并具有x和y坐标。公钥有两种形式：压缩的与非压缩的。早期比特币均使用非压缩公钥，现在大部分客户端默认使用压缩公钥。 由于数学原理，从私钥推算公钥是可行的，从公钥逆推私钥是不可能的。 也就是说比特币的私钥是： 32字节随机数（使用SHA-256）+版本号+压缩标志+校验码（双哈希过的随机数的前四位字节） 3）地址的生成 首先将公钥进行SHA256和RIPEMD160双哈希运算，并生成20字节长度的摘要结果（即Hash160结果），这个将作为比特币地址的主体（body）信息，再在前面加上版本前缀0x00，在后面添加4个字节的地址校验码。地址校验码通过对摘要结果进行两次SHA256运算，取哈希值的前4位产生。最后通过Base58处理把连在一起的版本前缀、主体信息和校验码转换成可以容易让人识别的比特币字符地址。 地址组成： （公钥（双哈希）+版本号前缀+地址校验码）（base58） 11.数字签名 数字签名就是在信息后面加上另一段内容，作为发送者的证明并且证明信息没有被篡改。一般是发送者将信息用哈希算法处理得出一个哈希值，然后用私钥对该哈希值进行加密，得出一个签名。然后发送者再将信息和签名一起发送给接收者。接收者使用发送者的公钥对签名进行解密，还原出哈希值，再通过哈希算法来验证信息的哈希值和解密签名还原出来的哈希值是否一致，从而可以鉴定信息是否来自发送者或验证信息是否被篡改。 注意和比特币加密信息的区别，见我的博文： http://blog.csdn.net/wu2374633583/article/details/79174547 12.比特币的隐私模型 在比特币的隐私模型中，所有的交易不需要第三方的操控，也不需要提供任何身份信息，只需要提供比特币的地址就可以跟任何人完成一次准匿名的交易。 2.1.2　框架与特点 1.框架简介 我们将区块链的基础架构分为三层来进行讲解： 首先，在网络层之上，区块链是建立在IP通信协议和对等网络的基础上的一个分布式系统，和传统带中心的分布式系统不一样，它不依靠中心化的服务器节点来转发消息，而是每一个节点都参与消息的转发。因此P2P网络比传统网络具有更高的安全性，任何一个节点被攻击都不会影响整个网络，所有的节点都保存着整个系统的状态信息。 其次，在数据层面上，区块链就是一个只可追加、不可更改的分布式数据库系统，是一个分布式账本。如果是公开的区块链，也就是公有链，那么这个账本可以被任何人在任何地方进行查询，完全公开透明。在区块链网络中，节点通过使用共识算法来维持网络中账本数据库的一致性。同时采用密码学的签名和哈希算法来确保这个数据库不可篡改，不能作伪，并且可追溯。 再次，在应用层面，我们可以用区块链代替传统的登记、清算系统。 在应用方面，区块链平台能够提供编程环境让用户编写智能合约。通过智能合约，可以把业务规则转化成在区块链平台自动执行的合约，该合约的执行不依赖可信任的第三方，也不受人为的干预。 2.架构特点 区块链具有去中心化、可靠数据库、开源可编程、集体维护、安全可信、交易准匿名性等特点。如果一个系统不具有以上特征，将不能被视为基于区块链技术的应用。 （1）去中心化 区块链数据的存储、传输、验证等过程均基于分布式的系统结构，作为区块链一种部署模式，公共链网络中所有参与的节点都可以具有同等的权利和义务。 （2）可靠数据库 区块链系统的数据库采用分布式存储，任何参与节点都可以拥有一份完整的数据库拷贝。 区块链数据的存储还带有时间戳，从而为数据添加了时间维度，具有极高的可追溯性。 （3）开源可编程 区块链系统通常是开源的，代码高度透明公共链的数据和程序对所有人公开，任何人都可以通过接口查询系统中的数据。并且区块链平台还提供灵活的脚本代码系统，支持用户创建高级的智能合约、货币和去中心化应用。 （4）集体维护 系统中的数据块由整个系统中所有具有记账功能的节点来共同维护，任一节点的损坏或失去都不会影响整个系统的运作。 （5）安全可信 区块链技术采用非对称密码学原理对交易进行签名，使得交易不能被伪造；同时利用哈希算法保证交易数据不能被轻易篡改，最后借助分布式系统各节点的工作量证明等共识算法形成强大的算力来抵御破坏者的攻击，保证区块链中的区块以及区块内的交易数据不可篡改和不可伪造，因此具有极高的安全性。 （6）准匿名性 区块链系统采用与用户公钥挂钩的地址来做用户标识，不需要传统的基于PKI的第三方认证中心（Certificate Authority，CA）颁发数字证书来确认身份。通过在全网节点运行共识算法，建立网络中诚实节点对全网状态的共识，间接地建立了节点间的信任。 区块链技术的核心优势是去中心化，能够通过运用哈希算法、数字签名、时间戳、分布式共识和经济激励等手段，在节点无需互相信任的分布式系统中建立信任，实现点对点交易和协作，从而为中心化机构普遍存在的低成本、低效率和数据存储不安全等问题提供了解决方案。 2.1.3　区块链运作的核心技术 1.区块链的链接 区块链即由一个个区块组成的链。每个区块分为区块头和区块体（含交易数据）两个部分。区块头包括用来实现区块链接的前一区块的哈希（PrevHash）值（又称散列值）和用于计算挖矿难度的随机数。 2.共识机制 可以将区块链理解为一个基于互联网的去中心化记账系统。区块链技术的核心是在没有中心控制的情况下，在互相没有信任基础的个体之间就交易的合法性等达成共识的共识机制。 区块链的共识机制目前主要有4类：PoW、PoS、DPoS、分布式一致性算法。 （1）PoW PoW（工作量证明），也就是像比特币的挖矿机制，矿工通过把网络尚未记录的现有交易打包到一个区块，然后不断遍历尝试来寻找一个随机数，使得新区块加上随机数的哈希值满足一定的难度条件，找到满足条件的随机数，就相当于确定了区块链最新的一个区块，也相当于获得了区块链的本轮记账权。矿工把满足挖矿难度条件的区块在网络中广播出去，全网其他节点在验证该区块满足挖矿难度条件，同时区块其的交易数据符合协议规范后，将各自把该区块链接到自己版本的区块链上，从而在全网形成对当前网络状态的共识。 优点： 完全去中心化，节点自由进出，避免了建立和维护中心化信用机构的成本。 缺点： 目前比特币挖矿造成大量的资源浪费；另外挖矿的激励机制也 造成矿池算力的高度集中，背离了当初去中心化设计的初衷。更大的问题是PoW机制的共识达成的周期较长，每秒只能最多做7笔交易，不适合商业应用。 （2）PoS PoS权益证明，要求节点提供拥有一定数量的代币证明来获取竞争区块链记账权的一种分布式共识机制。如果单纯依靠代币余额来决定记账者必然使得富有者胜出，导致记账权的中心化，降低共识的公正性，因此不同的PoS机制在权益证明的基础上，采用不同方式来增加记账权的随机性来避免中心化。 优点： 在一定程度上缩短了共识达成的时间，降低了PoW机制的资源浪费。 缺点： 破坏者对网络攻击的成本低，网络的安全性有待验证。另外拥 有代币数量大的节点获得记账权的几率更大，会使得网络的共识受少数富裕账户支配，从而失去公正性。 （3）DPoS DPoS（股份授权证明）机制，类似于董事会投票。比特股（bitshares）采用的PoS机制是持股者投票选出一定数量的见证人，每个见证人按序有两秒的权限时间成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一个时间片对应的见证人。持股人可以随时通过投票更换这些见证人。 优点： 大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。 ·缺点： 选举固定数量的见证人作为记账候选人有可能不适合于完全去中心化的场景。另外在网络节点数少的场景，选举的见证人的代表性也不强。 （4）分布式一致性算法 分布式一致性算法是基于传统的分布式一致性技术。其中有分为解决拜占庭将军问题的拜占庭容错算法，如PBFT。另外解决非拜占庭问题的分布式一致性算法（Pasox、Raft）。该类算法目前是联盟链和私有链链场景中常用的共识机制。 优点：实现秒级的快速共识机制，保证一致性。 缺点：去中心化程度不如公有链上的共识机制；更适合多方参与的多中心商业模式。 3.解锁脚本 脚本是区块链上实现自动验证、自动执行合约的重要技术。每一笔交易的每一项输出严格意义上并不是指向一个地址，而是指向一个脚本。脚本类似一套规则，它约束着接收方怎样才能花掉这个输出上锁定的资产。 交易的合法性验证也依赖于脚本。目前它依赖于两类脚本：锁定脚本与解锁脚本。 锁定脚本是在输出交易上加上的条件，通过一段脚本语言来实现，位于交易的输出。解锁脚本与锁定脚本相对应，只有满足锁定脚本要求的条件，才能花掉这个脚本上对应的资产，位于交易的输入。通过脚本语言可以表达很多灵活的条件。解释脚本是通过类似我们编程领域里的“虚拟机”，它分布式运行在区块链网络上的每一个节点。 比特币的脚本分为两种：一种是普通的P2PKH，，即支付给公钥的哈希地址，接收方只需要使用地址对应的私钥对该输出进行签名，即可花掉该输出。另一种是P2SH，即支付脚本的哈希。 比如在比特币中，P2PKH的脚本规则如下： Pubkey script: OP_DUP OP_HASH160 &lt;PubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG Signature script: &lt;sig&gt; &lt;pubkey&gt; P2SH的脚本规则如下： Pubkey script: OP_HASH160 &lt;Hash160(redeemScript)&gt; OP_EQUAL Signature script: &lt;sig&gt; [sig] [sig...] &lt;redeemScript&gt; 在上述的两种脚本规则里，Pubkey script代表锁定脚本，Signature script代表解锁脚本。OP_开头的单词是相关的脚本命令，也是“虚拟机”所能解析的指令。 注意的是，比特币的脚本机制比较简单，而以太坊的脚本机制是支持脚本的一套图灵完备语言。脚本机制让区块链技术作为一项底层协议成为可能。 4.交易规则 区块链的交易就是构成区块的基本单位，也是区块链负责记录的实际有效内容。一个区块链交易可以是一次转账，也可以是智能合约的部署等其他事务。 对于比特币而言，交易意味着一次支付转账，规则如下： 1）交易的输入和输出不能为空。 2）对交易的每个输入，如果其对应的UTXO输出能在当前交易池中找到，则拒绝该交易。因为当前交易池是未被记录在区块链中的交易，而交易的每个输入，应该来自确认的UTXO。如果在当前交易池中找到，那就是双花交易。 3）交易中的每个输入，其对应的输出必须是UTXO。 4）每个输入的解锁脚本（unlocking script）必须和相应输出的锁定脚本（locking script）共同验证交易的合规性。 注意： 对于以太坊来说，交易还可能是智能合约的部署。交易规则就确定了符合一定语法规则的合约才能被部署在区块链上。 5.交易优先级 区块链交易的优先级由区块链协议规则决定。对于比特币而言，交易被区块包含的优先次序由交易广播到网络上的时间和交易额的大小决定。 对于以太坊而言，交易的优先级还与交易的发布者愿意支付的交易费用有关。 6.Merkle证明 比特币区块链使用了Merkle证明，为的是将交易存储在每一个区块中。使得交易不能被篡改，同时也容易验证交易是否包含在一个特定区块中，Merkle树的一个重要使用场景就是快速支付验证，轻量级节点（light client）不用下载每一笔交易以及每一个区块，可以仅下载链的区块头，每个区块中仅包含5项内容（上一区块头的哈希值，时间戳，挖矿难度值，工作量证明随机数，包含该区块交易的Merkle树的根哈希），数据块大小为80字节。如果一个轻客户端希望确定一笔交易的状态，它可以简单地要求一个Merkle证明，显示出一个在Merkle树特定的交易，其根是在主链（main chain，非分叉链）上的区块头。 局限性：虽然可以证明包含的交易，但无法证明任何当前的状态（例如：数字资产的持有，名称注册，融合约的状态等）。 以太坊的改进：以太坊的每一个区块头中并非只包含一棵Merkle树，而是包含了3棵Merkle树（见图2-12），分别对应了3种对象：交易，收据（基本上，它是展示每一笔交易影响的数据条），状态。 这三棵树允许轻客户端轻松地进行并核实以下类型的查询答案： 1）这笔交易被包含在特定的区块中了吗？ 2）告诉我这个地址在过去30天中，发出X类型事件的所有实例（例如，一个众筹合约完成了它的目标）。 3）目前我的账户余额是多少？ 4）这个账户是否存在？ 5）假装在这个合约中运行这笔交易，它的输出会是什么？ 第1种和第5种是由交易树（transaction tree）来处理的；第3和第4种则是由状态树（state tree）负责处理，第2种则由收据树（receipt tree）处理。 7.RLP RLP（递归长度前缀编码）是Ethereum中对象序列化的一个主要编码方式，其目的是对任意嵌套的二进制数据的序列进行编码。 这种编码格式将任意长度和维度的字符串构成的数组串连接成字符串。 例如： [’dog‘，’cat‘]被串接（以字节数组格式）为[130，67，100，111，103，67，99，97，116]； 解释：基本的思想是 把数据类型和长度编码成一个单独的字节放在实际数据的前面（例如‘dog’的字节数组编码为[100，111，103]，于是串接后就成了[67，100，111，103]）。注意RLP编码正如其名字表示的一样，是递归的； 2.1.4　区块链交易流程 区块链上的交易指的是转账，如果每一笔转账都需要构造一笔交易数据会比较笨拙，为了使得价值易于组合与分割，比特币的交易被设计为可以纳入多个输入和输出，即一笔交易可以转账给多个人，也就是所谓的UTXO。 区块链交易的整个生命周期：从生成到在网络中传播，再到通过工作量证明、整个网络节点验证，最终记录到区块链。整个区块链交易流程如下： （1）交易的生成。所有者A利⽤他的私钥对前一次交易和下一位所有者B签署一个数字签名，并将这个签名附加在这枚货币的末尾，制作成交易单。 （2）交易的传播。A将交易单广播至全网，每个节点都将收到的交易信息纳入一个区块中。 （3）工作量证明。每个节点通过相当于解一道数学题的工作量证明机制，从而获得创建新区块的权力，并争取得到数字货币的奖励。 （4）整个网络节点验证。当一个节点找到解时，它就向全网广播该区块记录的所有盖时间戳交易，并由全网其他节点核对。 （5）记录到区块链。全网其他节点核对该区块记账的正确性，没有错误后他们将在该合法区块之后竞争下一个区块，这样就形成了一个合法记账的区块链。 2.2 以太坊 2.2.1　什么是以太坊 以太坊的目的是对脚本、竞争币和链上元协议（on-chain meta-protocol）等概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、图灵完备的、易于开发和协同的应用。 以太坊的新颖在于其神奇的计算机网络，它促成了一种新型的软件应用，真正的去中心化应用。将信任逻辑嵌入小程序中，运行在区块链上。而与比特币相比，以太坊建立了一种新的密码学技术基础框架，在其上开发应用更加容易，并对轻客户端友好，同时允许应用共享一个可行的经济环境和可靠的区块链安全。 以太坊是个平台和编程语言，包括数字货币以太币（Ether），以及用来构建和发布分布式应用的以太脚本（EtherScript）。 从最底层角度来看，以太坊是一个多层的、基于密码学的开源技术协议。它的不同功能模块通过设计进行了全面的整合，作为一个整体，它是一个创建和部署去中心化应用的综合平台。 同时，以太坊也是区块链与智能合约的完美结合，是智能合约的完整解决方案，被设计成了一个通用的去中心化平台，拥有一套完整的、可以扩展其功能的工具，在P2P网络、加密、HttpClient等技术的支持下实现了一个类似于比特币的区块链。它通过工作量证明机制实现共识，由矿工挖矿，通过对新的网络协议的制定实现对区块链的同步等操作。不同于比特币的是，在以太坊上可以任意编写智能合约，通过智能合约实现强大的功能，实现去中心化应用的开发。在以太坊上部署的智能合约运行在以太坊特有的虚拟机上，通过以太坊虚拟机和RPC接口与底层区块链进行交互。 2.2.2　以太坊技术 1.以太坊核心概念 （1）以太坊虚拟机 以太坊虚拟机（EVM）是以太坊中智能合约的运行环境。实际上它是由许多互相连接的计算机组成的。任何人都可以上传程序，并让这些程序自动执行，同时保证现在和所有以前的每个程序的状态总是公共可见的。 （2）账户 以太坊中有两类账户，它们共用同一个地址空间。外部账户，该类账户被公钥-私钥对控制。合约账户，该类账户被存储在账户中的代码控制。外部账户的地址是由公钥决定的，合约账户的地址是在创建合约时由合约创建者的地址和该地址发出过的交易数量计算得到。两类账户的唯一区别是：外部账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。 以太坊的账户包含4个部分：①随机数，用于确定每笔交易只能被处理一次的计数器；②账户目前的以太币余额；③账户的合约代码（如果有的话）；④账户的存储（默认为空）。 （3）消息 以太坊的消息在某种程度上类似于比特币的交易，但是两者之间存在3点重要的不同。 1）以太坊的消息可以由外部实体或者合约创建，然后比特币的交易只能从外部创建。 2）以太坊消息可以选择包含数据。 3）如果以太坊消息的接收者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。 （4）交易 以太坊中“交易”是指存储从外部账户发出的消息的签名数据包。交易包含消息的接收者、用于确认发送者的签名、以太币账户余额、要发送的数据和被称为STARTGAS和GASPRICE的两个数值。为了防止代码出现指数型爆炸和无限循环，每笔交易需要对执行代码所引发的计算步骤做出限制。STARTGAS就是通过需要支付的燃料来对计算步骤进行限制，GASPRICE是每一计算步骤需要支付矿工的燃料的价格。 （5）Gas 以太坊上的每笔交易都会被收取一定数量的燃料Gas，设置Gas的目的是限制交易执行所需的工作量，同时为交易的执行支付费用。 （6）存储、主存和栈 每个账户都有一块永久的内存区域，被称为存储，其形式为key-value，key和value的长度均为256位。在合约里，不能遍历账户的存储。相对于主存和栈，存储的读操作开销较大，修改存储甚至更多。一个合约只能对它自己的存储进行读写。 第二个内存区被称为主存。合约执行每次消息调用时都有一块新的被清除过的主存。 EVM不是基于寄存器的，而是基于栈的虚拟机。因此所有的计算都在一个称为栈的区域内执行。栈最大有1024个元素，每个元素有256位。对栈的访问只限于其顶端，允许复制最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的一个或几个元素，并把结果压在栈顶。 （7）指令集 EVM的指令集被刻意保持在最小规模，以尽可能避免可能导致共识问题的错误。所有的指令都是针对256位这个基本的数据单位进行的操作，具备常用的算术、位、逻辑和比较操作，也可以进行条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。 （8）消息调用 合约可以通过消息调用的方式来调用其他合约，或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源，一个目标，数据负载，以太币，Gas和返回数据。事实上每个交易都可以被认为是一个顶层消息调用，这个消息调用会依次产生更多的消息调用。 一个合约可以决定剩余Gas的分配。如果在内部消息调用时发生了out-of-gas异常或者其他异常，合约将会得到通知，一个错误码被压入栈中。这种情况只是内部消息调用的Gas耗尽。 被调用的合约（发起调用的合约也一样）会拥有崭新的主存，并能够访问调用的负载。调用负载被存储在一个单独的被称为calldata的区域。调用执行结束后，返回数据将被存放在调用方预先分配好的一块内存中。调用层数被限制为1024。因此对于更加复杂的操作，我们应该使用循环而不是递归。 （9）代码调用和库 以太坊中存在一种特殊类型的消息调用，被称为callcode。它跟消息调用几乎完全一样，只是加载来自目标地址的代码将在发起调用的合约上下文中运行。这意味着一个合约可以在运行时从另外一个地址动态加载代码。 2.以太坊的状态转换 以太坊的状态转换是指在一个交易（TX）发生时，以太坊从一个正确状态（S）转变到下一个正确状态（S’）的转换过程。 以太坊的状态转换函数为APPLY（S，TX）-&gt;S’，可以定义如下： 1）检查交易的格式是否正确，签名是否有效，以及随机数是否与发送者账户的随机数匹配。如否，返回错误。 2）计算交易费用fee=STARTGAS*GASPRICE，并从签名中确定发送者的地址。从发送者的账户中减去交易费用和增加发送者的随机数。如果账户余额不足，返回错误。 3）设定初值Gas=STARTGAS，并根据交易中的字节数减去一定量的燃料值。 4）从发送者的账户转移价值到接收者账户。如果接收账户还不存在，创建此账户。如果接收账户是一个合约，运行合约的代码，直到代码运用结束或者燃料用完。 5）如果因为发送者账户没有足够的费用或者代码执行耗尽燃料导致价值转移失败，恢复原来的状态，但是还需要支付交易费用，交易费用加至矿工账户。 6）若代码执行成功，将所有剩余的燃料归还给发送者，消耗掉的燃料作为交易费用发送给矿工。 假设合约存储器开始时是空的，一个值为10以太、燃料为2000、燃料价格为0.001以太并且两个数据字段值为[2，‘CHARLIE’]的交易发送后，状态转换函数的处理过程如下： 1）检查交易是否有效，格式是否正确。 2）检查交易发送者是否至少有2000×0.001=2个以太币。如果有，从发送者账户中减去2个以太币。 3）初始设定Gas=2000，假设交易长为170字节，每字节的费用是5，减去850，所以还剩1150。 4）从发送者账户减去10个以太币，为合约账户增加10个以太币。 5）运行代码。在这个合约中，运行代码很简单：它检查合约存储器索引为2处是否已使用，注意到它未被使用，然后将其值置为CHARLIE。假设这消耗了187单位的燃料，于是剩余的燃料为1150-187=963。 6）向发送者的账户增加963×0.001=0.963个以太币，返回最终状态。 3.以太坊客户端 目前有4种语言编写的以太坊的客户端。它们分别是Go语言实现的客户端Geth，用C++实现的客户端Eth，用Python语言实现的客户端Pyethapp和⽤Java实现的客户端EthereumJ。其中，Go语言版是以太坊官方一直维护并推荐使用的客户端。 以太坊包括一个专用的客户端浏览器（Mist），使得用户可以运用各种各样的去中心化应用（DApp），发布智能合约。Mist由特殊的安全层、密钥管理、去中心化账户管理和与区块链相关的组件几部分组成。 2.2.3　以太坊智能合约 1.智能合约 以太坊是内置有图灵完备编程语言的区块链，通过建立抽象的基础层，使得任何人都能够创建合约和去中心化应用，并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。 智能合约就像能在以太坊的平台上创建的包含价值而且只有满足某些条件才能打开的加密箱子，并且因为图灵完备性、价值意识（value-awareness）、区块链意识（blockchain-awareness）和记录多状态所增加的功能而比比特币脚本所能提供的智能合约强大得多。 2.开发语言 以太坊具有4种专门语言：Serpent（受Python启发）、Solidity（受JavaScript启发）、Mutan（受Go启发）和LLL（受Lisp启发），都是为向合约编程言从底层开始设计的语言。Solidity是以太坊的首选语言。 以太坊区块链另外特征是图灵完备，这保证了以太坊可以解决所有的计算问题。此外，因为以太坊的语言是为区块链专门设计的，它有账户的概念，使得它在交易的可视化和查询账户状态方面提供了实时性。 3.代码执行 以太坊合约的代码是使用低级的基于堆栈的字节码的语言写成的，被称为“以太坊虚拟机代码”或者“EVM代码”。代码由一系列字节构成，每一个字节代表一种操作。操作可以访问3种存储数据的空间： 1）堆栈，一种后进先出的数据存储，入栈、出栈的基本单位为32字节。 2）内存，可无限扩展的字节队列。 3）合约的长期存储，一个密钥/数值的存储，其中密钥和数值都是32字节大小。与计算结束即重置的堆栈和内存不同，存储内容将长期保持。 代码可以像访问区块头数据一样访问数值、发送和接收到的消息中的数据，代码还可以返回数据的字节队列作为输出。。EVM代码的正式执行模型非常简单。当以太坊虚拟机运行时，它的完整的计算状态可以由元组（block_state，transaction，message，code，memory，stack，pc，gas）来定义，这⾥block_state是包含所有账户余额和存储的全局状态。每轮执行时，通过调出代码的第pc（程序计数器）个字节，每个指令如何影响元组都有定义。 例如，ADD将两个元素出栈并将它们的和入栈，将Gas减1并将 pc加1；stack将顶部的两个元素出栈，并将第2个元素插入由第1个元素定义的合约存储位置，同样减少最多200的Gas值，并将pc加1。 2.2.4　以太坊的去中心化应用 1.什么是DApp 一个DApp是由智能合约和客户端代码构成的。智能合约就像加密的包含价值的箱子。只有当特定条件被满足时它才被打开，它封装了一些逻辑、规则、处理步骤或者双方间的协议。 从架构角度而言，DApp非常类似于传统的Web应用。主要区别是：在传统Web应用中，客户端有JavaScript代码，由用户在自己的浏览器中执行；服务器端的代码由主机运行。但是在一个DApp中，它的智能逻辑运行在区块链上，客户端代码运行在特殊浏览器Mist里面。 2.应用举例 Augur（www.augur.net），一个正在开发去中心化预测系统。用户可以在这个应用上对各种事件打赌并下注，例如希拉里会不会赢得2016年美国的大选。 Maker（www.makerdao.com），一个正在开发中的金融类去中心化自治组织（DAO）。它维护一系列用于金融服务的合约软件（即智能合约），其中的一个软件是贷券信贷系统。 WeiFund，一个正在开发中的去中心化众筹平台。这个众筹平台的好处是资金不需要第三方托管，而是由程序托管，因此能够确保资金100%安全。 Boardroom，一个正在开发中的DAO管理平台。去中心化自治组织与传统公司一样，也可以有股份的概念，通常就是DAO的代币，这些代币又可以有投票权。 Ujo Music，一个音乐版权管理平台，测试版。Ujo Music作为音乐版权管理平台，可以直接在歌曲的创作者与消费者之间建立直接的联系，从而省去了中间商的费用提成。 贷券简称Dai或者Dai Bond，是一种可转让的、彼此等价可互换的“加密债券”，它流通于信贷系统中，使用者无需事先认证，同时又是低风险的。贷券的发行人（借款人）将在以太坊区块链上的以太等数字加密资产作为抵押品来发行贷券，再将这些贷券在市场上卖给贷券持有以换回流动性好的资产。 2.3　基于区块链的电子货币 2.3.1　元币平台 元币（metacoin）单词前缀“meta-”意为“在其中”。所以元币是衍生于现有加密货币体系之上，更专注于业务系统的代币种类。 2.3.2　代币 1.通过货币参数修改而建立的代币 2.基于共识机制的创新而建立的代币 比特币的共识机制是建立在用SHA256算法加密的作业证据基础之上的。 3.通过双目标挖矿机制创新而建立的代币 比特币的工作量证明算法仅仅具有一个目的，那就是确保比特链的安全。尽管相对于传统支付系统的安全，这点挖矿开销并不高，但是被指是一种浪费。双目标工作量证明算法在产生工作量证明来满足安全的同时，解决一个具体的问题。但这样做也带来一定的风险。在向货币安全添加额外功能的同时，也影响了其供求曲线。 4.注重隐私性的代币 比特币常常被误认为具有隐私性。事实上，通过大数据分析，关联身份和比特币地址相对容易，从而通过连接彼此的地址，解析一个人的比特币消费习惯。所以，一些代币专注于强隐私性，试图直接解决此问题。 2.3.3　货币的未来 加密货币的未来整体来说比比特币更加繁荣。它们在比特币的基础上引进了全新的去中心化的组织形式和共识机制，并由此衍生出了数以百计的不可思议的创新。这将影响与经济相关的众多部门，如：财政、经济、货币、中央银行、企业管理等。 2.4 本章小结 本章主要介绍了区块链技术的基础知识。首先，介绍了区块链技术，包括区块链技术的基本概念、框架与特点，核心技术及交易流程。在这个基础之上，我们详细介绍了区块链技术最成功的应用——用特币，包括概念、原理、及隐私模型。之后，我们介绍了区块链的另外一个重要应用——以太坊。以太坊是区块链技术发展的一个重要的方向，是区块链技术未来的一部分。我们介绍了以太坊技术、以太坊智能合约、以太坊去中心化应用、以太坊发展的现状及未来。最后，我们分析了现有的流行的电子货币各自的优缺点。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/02/02/85baa12f83882111712551ba4c4372aa.html","headline":"区块链指南 第2章　区块链基础","dateModified":"2018-02-02T00:00:00+08:00","datePublished":"2018-02-02T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/02/02/85baa12f83882111712551ba4c4372aa.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链指南 第2章　区块链基础</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>目录：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180125163704267?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3UyMzc0NjMzNTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <hr> 
  <h2 id="21-区块链技术">2.1 区块链技术</h2> 
  <p>区块链本质上是一个<strong>对等网络</strong>（peer-to-peer）的<strong>分布式账本数据库</strong>。区块链本身其实是一串链接的数据区块，其链接指针是采用密码学<strong>哈希算法</strong>对区块头进行处理所产生的区块头哈希值。每一个数据块中记录了一组采用哈希算法组成的树状交易状态信息，这样保证了每个区块内的交易数据不可篡改，区块链里链接的区块也不可篡改。</p> 
  <hr> 
  <h3 id="211-基本概念">2.1.1　基本概念</h3> 
  <p>完整的区块链系统包含的技术：存储数据的数据区块及其之上的<strong>数字签名</strong>、<strong>时间戳</strong>等技术，有作为支撑的<strong>P2P网络</strong>和维护系统的<strong>共识算法</strong>，有<strong>挖矿</strong>和<strong>工作量证明机制</strong>，有<strong>匿名交易机制</strong>和<strong>比特币钱包</strong>，还有<strong>链龄</strong>，<strong>UTXO</strong>、<strong>Merkle树</strong>、<strong>双花</strong>等相关技术概念。</p> 
  <h4 id="1数据区块">1.数据区块</h4> 
  <p>比特币的交易记录会保存在数据区块之中， 比特币系统中大约每10分 <br> 钟会产生一个区块， 每个数据区块一般包含区块头（Header） 和区块体 <br> （Body） 两部分，如下图：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180125170011614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3UyMzc0NjMzNTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p><strong>区块头封装了当前的版本号（Version）、前一区块地址（Prev-block）、时间戳（Timestamp）、随机数（Nonce）、当前区块的目标哈希值（Bits）、Merkle树的根值（Merkle-root）等信息。</strong></p> 
  <p><strong>区块体中则主要包含交易计数和交易详情。交易详情就是比特币系统中的记账本，每一笔交易都会被永久地记入数据区块中，而且任何人都可以查询。区块体中的Merkle树将会对每一笔交易进行数字签名，如此可以确保每一笔交易都不可伪造且没有重复交易。所有的交易将通过Merkle树的Hash过程产生一个唯一Merkle根值记入区块头。</strong></p> 
  <h4 id="2挖矿与分叉问题">2.挖矿与分叉问题</h4> 
  <p>区块在挖矿过程中产生。<strong>所谓挖矿，实际上是穷举随机数算法</strong>，把上个区块的哈希值加上10分钟内的全部交易单打包，再加上一个随机数，算出一个256位的字符串哈希值，输入的随机数Nonce使哈希值满足一定条件就获得这个区块的交易记账权。</p> 
  <p>新产生的区块需要快速广播出去，以便其他节点进行对其验证，以防造假。每个区块存着上一个区块的哈希值，可以溯源到源头，只有经过验证后才最终获得区块的交易记账权。</p> 
  <h4 id="3时间戳和不可篡改性">3.时间戳和不可篡改性</h4> 
  <p>时间戳是指从格林威治时间1970年01月01日00时00分00秒（北京时间 <br> 1970年01月01日08时00分00秒）起到现在的总秒数，通常是一个字符序列，唯一地标识某时刻的时间。在比特币系统中，获得记账权的节点在链接区块时需要在区块头中加盖时间戳，用于记录当前区块数据的写入时 <br> 间。</p> 
  <h4 id="4分布式数据库">4.分布式数据库</h4> 
  <p>比特币系统中的区块就像一个记账本一样，记录了所有比特币的交易 <br> 信息，每一个比特币用户的比特币收支情况都被永久地嵌入了数据区块中 <br> 以供别人查询。这些数据区块中的交易数据存放在每一个比特币用户的客 <br> 户端节点中，所有的这些节点则组成了比特币及其坚韧的分布式数据库系 <br> 统。任何一个节点的数据被破坏都不会影响整个数据库的正常运转，因为 <br> 其他的健康节点中都保存了完整的数据库。</p> 
  <h4 id="5utxo交易模式">5.UTXO交易模式</h4> 
  <p>UTXO（Unspent Transaction Outputs）是未花费的交易输出，它是比特币交易过程中的基本单位。 <br> 具体见我的博文： <br> <a href="http://blog.csdn.net/wu2374633583/article/details/79175211" rel="nofollow">http://blog.csdn.net/wu2374633583/article/details/79175211</a></p> 
  <h4 id="6哈希函数">6.哈希函数</h4> 
  <p>哈希函数有着很多适合存储区块链数据的优点： <br> 1）哈希函数处理过的数据是单向性的，通过处理过的输出值几乎不可能计算出原始的输入值； <br> 2）哈希函数处理不同长度的数据所耗费的时间是一致的，输出值也是定长的； <br> 3）哈希函数的输入值即使只相差一个字节，输出值的结果也会迥然不同。比特币系统中最常采用的哈希函数是<strong>双SHA256哈希函数</strong>，通俗来说就是将不同长度的原始数据用两次SHA256哈希函数进行处理，再输出长度为256的二进制数字来进行统一的识别和存储。</p> 
  <h4 id="7merkle树">7.Merkle树</h4> 
  <p>Merkle树是数据结构中的一种树，可以是二叉树，也可以是多叉树，它具有树结构的所有特点。</p> 
  <p>比特币区块链系统中的采用的是Merkle二叉树，它的作用主要是快速归纳和校验区块数据的完整性，它会将区块链中的数据分组进行哈希运算，向上不断递归运算产生新的哈希节点，最终只剩下一个Merkle根存入区块头中，每个哈希节点总是包含两个相邻的数据块或其哈希值。</p> 
  <p>使用Merkle树优点： <br> 首先是极大地提高了区块链的运行效率和可扩展性，使得区块头只需包含根哈希值而不必封装所有底层数据。 <br> 其次是Merkle树可支持“简化支付验证协议”（SPV），即在不运行完整区块链网络节点的情况下，也能够对交易数据进行检验。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180129170825948?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3UyMzc0NjMzNTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <h4 id="8双重支付">8.双重支付</h4> 
  <p>双重支付问题又称为“双花”问题，即利用货币的数字特性用“同一笔钱”完成两次或者多次支付。</p> 
  <p>区块链技术则在去中心化的系统中不借助任何第三方机构而只通过分布式节点之间的相互验证和共识机制，有效地解决了双重支付问题，在信息传输的同时完成了价值转移。</p> 
  <p>区块链技术通过区块链接形成的时间戳技术加上验证比特币是否满足UTXO（未花费交易）和数字签名，有效避免了双重支付的问题。</p> 
  <h4 id="9p2p网络">9.P2P网络</h4> 
  <p>P2P网络（peer-to-peer network，对等网络）是一种在对等者（peer）之间分配任务和⼯作负载的分布式应⽤架构，是对等计算模型在应用层形成的一种组网或网络形式。因此，从字面上，P2P可以理解为对等计算或对等网络。</p> 
  <p>区块链系统是建立在IP通信协议和分布式网络的基础上的，它不依靠传统的电路交换，而是建立于网络通信之上，完全通过互联网去交换信息。网络中所有的节点具有同等的地位，不存在任何特殊化的中心节点和层级结构，每个节点均会承担网络路由、验证数据区块等功能。网络的节点根据存储数据量的不同可以分为全节点和轻量级节点。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180129171509755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3UyMzc0NjMzNTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <h4 id="10加密算法">10.加密算法</h4> 
  <p>除了哈希算法以外，比特币中还存在一种为交易加密的非对称加密算法（椭圆曲线加密算法）。非对称加密算法指的就是存在一对数学相关的密钥，使用其中一个密钥（公钥）进行加密的数据信息，只有使用另一个密钥（私钥）才能对该信息进行解密。 <br> 具体见我博文： <br> <a href="http://blog.csdn.net/wu2374633583/article/details/79174547" rel="nofollow">http://blog.csdn.net/wu2374633583/article/details/79174547</a></p> 
  <p>非对称加密需要两个（一对）密钥：公开密钥（publickey）和私有密钥（privatekey），用公钥对数据进行加密后，只有对应的私钥才能解密；反之如果私钥用于加密，则只有对应的公钥才能解密。通信双方无须交换密钥就可以建立保密通信。</p> 
  <p>简单再说一下这几个问题： <br> 1）<strong>Base58编码</strong> <br> 可读性编码算法，类似古典密码学里的置换算法，理论上并不是密码学理论的核心内容。可读性编码算法不是为了保护数据的安全性，而是为了可读性。以二进制进行传输的信息是不具备可读性的，数字与字母组成的字符串才更容易被识别。可读性编码不改变信息内容，只改变信息内容的表现形式（部分编码算法还加入了容错校验功能，以保证传输过程中数据的准确性和完整性）。 <br> Base64是常见的可读性编码算法，<strong>所谓Base64，即是说在编码过程中使用了64种字符：大写A到Z、小写a到z、数字0到9、“+”和“/”</strong>。</p> 
  <p>Base58是Bitcoin中使用的一种编码方式，主要用于产生Bitcoin的钱包地址。相比Base64，<strong>Base58不使用数字”0”，字母大写”O”，字母大写”I”，和字母小写”i”，以及”+”和”/”符号</strong>。</p> 
  <p>设计Base58主要的目的是： <br> （1）避免混淆。在某些字体下，数字0和字母大写O，以及字母大写I和字母小写l会非常相似。 <br> （2）不使用”+”和”/”的原因是，非字母或数字的字符串难以作为账号的一部分被接受。 <br> （3）没有标点符号，通常不会被从中间分行。 <br> （4）使大部分的软件支持双击选择整个字符串。 <br> （5）比特币中使用Base58算法来对公钥的Hash160及私钥进行编码，以生成以1或3开头的比特币地址及WIF（Wallet import Format)格式的私钥。</p> 
  <p>2）<strong>私钥与公钥</strong> <br> <strong>比特币私钥其实是使用SHA-256生成的32字节（256位）的随机数</strong>，有效私钥的范围则取决于比特币使用的secp256k1 椭圆曲线数字签名标准。大小介于0x1 到0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140之间的数几乎都是合法的私钥。 <br> 在私钥的前面加上版本号，后面添加压缩标志和附加校验码，（所谓附加校验码，就是对私钥经过2次SHA-256运算，取两次哈希结果的前四字节），然后再对其进行Base58编码，就可以得到我们常见的WIF（Wallet import Format)格式的私钥。 <br> 私钥经过椭圆曲线乘法运算，可以得到公钥。公钥是椭圆曲线上的点，并具有x和y坐标。公钥有两种形式：压缩的与非压缩的。早期比特币均使用非压缩公钥，现在大部分客户端默认使用压缩公钥。 <br> 由于数学原理，从私钥推算公钥是可行的，从公钥逆推私钥是不可能的。</p> 
  <p>也就是说比特币的私钥是： <br> 32字节随机数（使用SHA-256）+版本号+压缩标志+校验码（双哈希过的随机数的前四位字节）</p> 
  <p>3）<strong>地址的生成</strong> <br> 首先将公钥进行SHA256和RIPEMD160双哈希运算，并生成20字节长度的摘要结果（即Hash160结果），这个将作为比特币地址的主体（body）信息，再在前面加上版本前缀0x00，在后面添加4个字节的地址校验码。地址校验码通过对摘要结果进行两次SHA256运算，取哈希值的前4位产生。最后通过Base58处理把连在一起的版本前缀、主体信息和校验码转换成可以容易让人识别的比特币字符地址。 <br> 地址组成： <br> （公钥（双哈希）+版本号前缀+地址校验码）（base58）</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180129174109691?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3UyMzc0NjMzNTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <h4 id="11数字签名">11.数字签名</h4> 
  <p>数字签名就是在信息后面加上另一段内容，作为发送者的证明并且证明信息没有被篡改。一般是发送者将信息用哈希算法处理得出一个哈希值，然后用私钥对该哈希值进行加密，得出一个签名。然后发送者再将信息和签名一起发送给接收者。接收者使用发送者的公钥对签名进行解密，还原出哈希值，再通过哈希算法来验证信息的哈希值和解密签名还原出来的哈希值是否一致，从而可以鉴定信息是否来自发送者或验证信息是否被篡改。</p> 
  <p>注意和比特币加密信息的区别，见我的博文： <br> <a href="http://blog.csdn.net/wu2374633583/article/details/79174547" rel="nofollow">http://blog.csdn.net/wu2374633583/article/details/79174547</a></p> 
  <h4 id="12比特币的隐私模型">12.比特币的隐私模型</h4> 
  <p>在比特币的隐私模型中，所有的交易不需要第三方的操控，也不需要提供任何身份信息，只需要提供比特币的地址就可以跟任何人完成一次准匿名的交易。</p> 
  <hr> 
  <h3 id="212-框架与特点">2.1.2　框架与特点</h3> 
  <h4 id="1框架简介">1.框架简介</h4> 
  <p>我们将区块链的基础架构分为三层来进行讲解：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180129175844912?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3UyMzc0NjMzNTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>首先，在<strong>网络层</strong>之上，区块链是建立在IP通信协议和对等网络的基础上的一个分布式系统，和传统带中心的分布式系统不一样，它不依靠中心化的服务器节点来转发消息，而是每一个节点都参与消息的转发。因此P2P网络比传统网络具有更高的安全性，任何一个节点被攻击都不会影响整个网络，所有的节点都保存着整个系统的状态信息。</p> 
  <p>其次，在<strong>数据层面</strong>上，区块链就是一个只可追加、不可更改的分布式数据库系统，是一个分布式账本。如果是公开的区块链，也就是公有链，那么这个账本可以被任何人在任何地方进行查询，完全公开透明。在区块链网络中，节点通过使用共识算法来维持网络中账本数据库的一致性。同时采用密码学的签名和哈希算法来确保这个数据库不可篡改，不能作伪，并且可追溯。</p> 
  <p>再次，在<strong>应用层面</strong>，我们可以用区块链代替传统的登记、清算系统。</p> 
  <p>在应用方面，区块链平台能够提供编程环境让用户编写智能合约。通过智能合约，可以把业务规则转化成在区块链平台自动执行的合约，该合约的执行不依赖可信任的第三方，也不受人为的干预。</p> 
  <h4 id="2架构特点">2.架构特点</h4> 
  <p>区块链具有去中心化、可靠数据库、开源可编程、集体维护、安全可信、交易准匿名性等特点。如果一个系统不具有以上特征，将不能被视为基于区块链技术的应用。 <br> （1）去中心化 <br> 区块链数据的存储、传输、验证等过程均基于分布式的系统结构，作为区块链一种部署模式，公共链网络中所有参与的节点都可以具有同等的权利和义务。 <br> （2）可靠数据库 <br> 区块链系统的数据库采用分布式存储，任何参与节点都可以拥有一份完整的数据库拷贝。 <br> 区块链数据的存储还带有时间戳，从而为数据添加了时间维度，具有极高的可追溯性。 <br> （3）开源可编程 <br> 区块链系统通常是开源的，代码高度透明公共链的数据和程序对所有人公开，任何人都可以通过接口查询系统中的数据。并且区块链平台还提供灵活的脚本代码系统，支持用户创建高级的智能合约、货币和去中心化应用。 <br> （4）集体维护 <br> 系统中的数据块由整个系统中所有具有记账功能的节点来共同维护，任一节点的损坏或失去都不会影响整个系统的运作。 <br> （5）安全可信 <br> 区块链技术采用非对称密码学原理对交易进行签名，使得交易不能被伪造；同时利用哈希算法保证交易数据不能被轻易篡改，最后借助分布式系统各节点的工作量证明等共识算法形成强大的算力来抵御破坏者的攻击，保证区块链中的区块以及区块内的交易数据不可篡改和不可伪造，因此具有极高的安全性。 <br> （6）准匿名性 <br> 区块链系统采用与用户公钥挂钩的地址来做用户标识，不需要传统的基于PKI的第三方认证中心（Certificate Authority，CA）颁发数字证书来确认身份。通过在全网节点运行共识算法，建立网络中诚实节点对全网状态的共识，间接地建立了节点间的信任。</p> 
  <p><strong>区块链技术的核心优势是去中心化，能够通过运用哈希算法、数字签名、时间戳、分布式共识和经济激励等手段，在节点无需互相信任的分布式系统中建立信任，实现点对点交易和协作，从而为中心化机构普遍存在的低成本、低效率和数据存储不安全等问题提供了解决方案。</strong></p> 
  <hr> 
  <h3 id="213-区块链运作的核心技术">2.1.3　区块链运作的核心技术</h3> 
  <h4 id="1区块链的链接">1.区块链的链接</h4> 
  <p>区块链即由一个个区块组成的链。每个区块分为区块头和区块体（含交易数据）两个部分。区块头包括用来实现区块链接的前一区块的哈希（PrevHash）值（又称散列值）和用于计算挖矿难度的随机数。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180129183600436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3UyMzc0NjMzNTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <h4 id="2共识机制">2.共识机制</h4> 
  <p>可以将区块链理解为一个基于互联网的去中心化记账系统。区块链技术的核心是在没有中心控制的情况下，在互相没有信任基础的个体之间就交易的合法性等达成共识的共识机制。 <br> 区块链的共识机制目前主要有4类：PoW、PoS、DPoS、分布式一致性算法。 <br> （1）PoW <br> PoW（工作量证明），也就是像比特币的挖矿机制，矿工通过把网络尚未记录的现有交易打包到一个区块，然后不断遍历尝试来寻找一个随机数，使得新区块加上随机数的哈希值满足一定的难度条件，<strong>找到满足条件的随机数，就相当于确定了区块链最新的一个区块，也相当于获得了区块链的本轮记账权</strong>。矿工把满足挖矿难度条件的区块在网络中广播出去，全网其他节点在验证该区块满足挖矿难度条件，同时区块其的交易数据符合协议规范后，将各自把该区块链接到自己版本的区块链上，从而在全网形成对当前网络状态的共识。 <br> 优点： <br> 完全去中心化，节点自由进出，避免了建立和维护中心化信用机构的成本。 <br> 缺点： <br> 目前比特币挖矿造成大量的资源浪费；另外挖矿的激励机制也 <br> 造成矿池算力的高度集中，背离了当初去中心化设计的初衷。<strong>更大的问题是PoW机制的共识达成的周期较长，每秒只能最多做7笔交易，不适合商业应用</strong>。 <br> （2）PoS <br> PoS权益证明，要求节点提供拥有一定数量的代币证明来获取竞争区块链记账权的一种分布式共识机制。如果单纯依靠代币余额来决定记账者必然使得富有者胜出，导致记账权的中心化，降低共识的公正性，因此不同的PoS机制在权益证明的基础上，采用不同方式来增加记账权的随机性来避免中心化。 <br> 优点： <br> 在一定程度上缩短了共识达成的时间，降低了PoW机制的资源浪费。 <br> 缺点： <br> 破坏者对网络攻击的成本低，网络的安全性有待验证。另外拥 <br> 有代币数量大的节点获得记账权的几率更大，会使得网络的共识受少数富裕账户支配，从而失去公正性。 <br> （3）DPoS <br> DPoS（股份授权证明）机制，类似于董事会投票。比特股（bitshares）采用的PoS机制是持股者投票选出一定数量的见证人，每个见证人按序有两秒的权限时间成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一个时间片对应的见证人。持股人可以随时通过投票更换这些见证人。 <br> 优点： <br> 大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。 <br> ·缺点： <br> 选举固定数量的见证人作为记账候选人有可能不适合于完全去中心化的场景。另外在网络节点数少的场景，选举的见证人的代表性也不强。 <br> （4）分布式一致性算法 <br> 分布式一致性算法是基于传统的分布式一致性技术。其中有分为解决拜占庭将军问题的拜占庭容错算法，如PBFT。另外解决非拜占庭问题的分布式一致性算法（Pasox、Raft）。<strong>该类算法目前是联盟链和私有链链场景中常用的共识机制。</strong></p> 
  <p>优点：实现秒级的快速共识机制，保证一致性。 <br> 缺点：去中心化程度不如公有链上的共识机制；更适合多方参与的多中心商业模式。</p> 
  <h4 id="3解锁脚本">3.解锁脚本</h4> 
  <p><strong>脚本是区块链上实现自动验证、自动执行合约的重要技术</strong>。每一笔交易的每一项输出严格意义上并不是指向一个地址，而是指向一个脚本。脚本类似一套规则，它约束着接收方怎样才能花掉这个输出上锁定的资产。</p> 
  <p>交易的合法性验证也依赖于脚本。目前它依赖于两类脚本：锁定脚本与解锁脚本。</p> 
  <p>锁定脚本是在输出交易上加上的条件，通过一段脚本语言来实现，位于交易的输出。解锁脚本与锁定脚本相对应，只有满足锁定脚本要求的条件，才能花掉这个脚本上对应的资产，位于交易的输入。通过脚本语言可以表达很多灵活的条件。解释脚本是通过类似我们编程领域里的“虚拟机”，它分布式运行在区块链网络上的每一个节点。</p> 
  <p>比特币的脚本分为两种：一种是普通的P2PKH，，即支付给公钥的哈希地址，接收方只需要使用地址对应的私钥对该输出进行签名，即可花掉该输出。另一种是P2SH，即支付脚本的哈希。 <br> 比如在比特币中，P2PKH的脚本规则如下：</p> 
  <pre class="prettyprint"><code class=" hljs xml">Pubkey script: OP_DUP OP_HASH160 <span class="hljs-tag">&lt;<span class="hljs-title">PubKeyHash</span>&gt;</span> OP_EQUALVERIFY OP_CHECKSIG
Signature script: <span class="hljs-tag">&lt;<span class="hljs-title">sig</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-title">pubkey</span>&gt;</span></code></pre> 
  <p>P2SH的脚本规则如下：</p> 
  <pre class="prettyprint"><code class=" hljs xml">Pubkey script: OP_HASH160 <span class="hljs-tag">&lt;<span class="hljs-title">Hash160(redeemScript)</span>&gt;</span> OP_EQUAL
Signature script: <span class="hljs-tag">&lt;<span class="hljs-title">sig</span>&gt;</span> [sig] [sig...] <span class="hljs-tag">&lt;<span class="hljs-title">redeemScript</span>&gt;</span></code></pre> 
  <p>在上述的两种脚本规则里，Pubkey script代表锁定脚本，Signature script代表解锁脚本。OP_开头的单词是相关的脚本命令，也是“虚拟机”所能解析的指令。</p> 
  <p>注意的是，比特币的脚本机制比较简单，而以太坊的脚本机制是支持脚本的一套图灵完备语言。脚本机制让区块链技术作为一项底层协议成为可能。</p> 
  <h4 id="4交易规则">4.交易规则</h4> 
  <p>区块链的交易就是构成区块的基本单位，也是区块链负责记录的实际有效内容。一个区块链交易可以是一次转账，也可以是智能合约的部署等其他事务。 <br> 对于比特币而言，交易意味着一次支付转账，规则如下： <br> 1）<strong>交易的输入和输出不能为空</strong>。 <br> 2）<strong>对交易的每个输入，如果其对应的UTXO输出能在当前交易池中找到，则拒绝该交易</strong>。因为当前交易池是未被记录在区块链中的交易，而交易的每个输入，应该来自确认的UTXO。如果在当前交易池中找到，那就是双花交易。 <br> 3）<strong>交易中的每个输入，其对应的输出必须是UTXO。</strong> <br> 4）<strong>每个输入的解锁脚本（unlocking script）必须和相应输出的锁定脚本（locking script）共同验证交易的合规性</strong>。</p> 
  <p>注意： <br> <strong>对于以太坊来说，交易还可能是智能合约的部署</strong>。交易规则就确定了符合一定语法规则的合约才能被部署在区块链上。</p> 
  <h4 id="5交易优先级">5.交易优先级</h4> 
  <p>区块链交易的优先级由区块链协议规则决定。对于比特币而言，交易被区块包含的优先次序由交易广播到网络上的时间和交易额的大小决定。 <br> 对于以太坊而言，交易的优先级还与交易的发布者愿意支付的交易费用有关。</p> 
  <h4 id="6merkle证明">6.Merkle证明</h4> 
  <p>比特币区块链使用了Merkle证明，为的是将交易存储在每一个区块中。使得交易不能被篡改，同时也容易验证交易是否包含在一个特定区块中，<strong>Merkle树的一个重要使用场景就是快速支付验证</strong>，轻量级节点（light client）不用下载每一笔交易以及每一个区块，可以仅下载链的区块头，每个区块中仅包含5项内容（上一区块头的哈希值，时间戳，挖矿难度值，工作量证明随机数，包含该区块交易的Merkle树的根哈希），数据块大小为80字节。如果一个轻客户端希望确定一笔交易的状态，它可以简单地要求一个Merkle证明，显示出一个在Merkle树特定的交易，其根是在主链（main chain，非分叉链）上的区块头。</p> 
  <p>局限性：虽然可以证明包含的交易，但无法证明任何当前的状态（例如：数字资产的持有，名称注册，融合约的状态等）。 <br> 以太坊的改进：以太坊的每一个区块头中并非只包含一棵Merkle树，而是包含了3棵Merkle树（见图2-12），<strong>分别对应了3种对象：交易，收据（基本上，它是展示每一笔交易影响的数据条），状态。</strong></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180130121342304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3UyMzc0NjMzNTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>这三棵树允许轻客户端轻松地进行并核实以下类型的查询答案： <br> 1）这笔交易被包含在特定的区块中了吗？ <br> 2）告诉我这个地址在过去30天中，发出X类型事件的所有实例（例如，一个众筹合约完成了它的目标）。 <br> 3）目前我的账户余额是多少？ <br> 4）这个账户是否存在？ <br> 5）假装在这个合约中运行这笔交易，它的输出会是什么？</p> 
  <p>第1种和第5种是由交易树（transaction tree）来处理的；第3和第4种则是由状态树（state tree）负责处理，第2种则由收据树（receipt tree）处理。</p> 
  <h4 id="7rlp">7.RLP</h4> 
  <p><strong>RLP（递归长度前缀编码）是Ethereum中对象序列化的一个主要编码方式，其目的是对任意嵌套的二进制数据的序列进行编码。</strong> <br> 这种编码格式将任意长度和维度的字符串构成的数组串连接成字符串。 <br> 例如： <br> [’dog‘，’cat‘]被串接（以字节数组格式）为[130，67，100，111，103，67，99，97，116]； <br> 解释：基本的思想是 <br> 把数据类型和长度编码成一个单独的字节放在实际数据的前面（例如‘dog’的字节数组编码为[100，111，103]，于是串接后就成了[67，100，111，103]）。注意RLP编码正如其名字表示的一样，是递归的；</p> 
  <hr> 
  <h3 id="214-区块链交易流程">2.1.4　区块链交易流程</h3> 
  <p>区块链上的交易指的是转账，如果每一笔转账都需要构造一笔交易数据会比较笨拙，为了使得价值易于组合与分割，比特币的交易被设计为可以纳入多个输入和输出，即一笔交易可以转账给多个人，也就是所谓的UTXO。 <br> 区块链交易的整个生命周期：从生成到在网络中传播，再到通过工作量证明、整个网络节点验证，最终记录到区块链。整个区块链交易流程如下：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180130142345639?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3UyMzc0NjMzNTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>（1）<strong>交易的生成</strong>。所有者A利⽤他的私钥对前一次交易和下一位所有者B签署一个数字签名，并将这个签名附加在这枚货币的末尾，制作成交易单。 <br> （2）<strong>交易的传播</strong>。A将交易单广播至全网，每个节点都将收到的交易信息纳入一个区块中。 <br> （3）<strong>工作量证明</strong>。每个节点通过相当于解一道数学题的工作量证明机制，从而获得创建新区块的权力，并争取得到数字货币的奖励。 <br> （4）<strong>整个网络节点验证</strong>。当一个节点找到解时，它就向全网广播该区块记录的所有盖时间戳交易，并由全网其他节点核对。 <br> （5）<strong>记录到区块链</strong>。全网其他节点核对该区块记账的正确性，没有错误后他们将在该合法区块之后竞争下一个区块，这样就形成了一个合法记账的区块链。</p> 
  <hr> 
  <h2 id="22-以太坊">2.2 以太坊</h2> 
  <h3 id="221-什么是以太坊">2.2.1　什么是以太坊</h3> 
  <p>以太坊的目的是对脚本、竞争币和链上元协议（on-chain meta-protocol）等概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、图灵完备的、易于开发和协同的应用。</p> 
  <p>以太坊的新颖在于其神奇的计算机网络，它促成了一种新型的软件应用，真正的去中心化应用。将信任逻辑嵌入小程序中，运行在区块链上。而与比特币相比，以太坊建立了一种新的密码学技术基础框架，在其上开发应用更加容易，并对轻客户端友好，同时允许应用共享一个可行的经济环境和可靠的区块链安全。</p> 
  <p><strong>以太坊是个平台和编程语言，包括数字货币以太币（Ether），以及用来构建和发布分布式应用的以太脚本（EtherScript）。</strong></p> 
  <p><strong>从最底层角度来看，以太坊是一个多层的、基于密码学的开源技术协议。它的不同功能模块通过设计进行了全面的整合，作为一个整体，它是一个创建和部署去中心化应用的综合平台。</strong></p> 
  <p><strong>同时，以太坊也是区块链与智能合约的完美结合，是智能合约的完整解决方案，被设计成了一个通用的去中心化平台，拥有一套完整的、可以扩展其功能的工具，在P2P网络、加密、HttpClient等技术的支持下实现了一个类似于比特币的区块链。它通过工作量证明机制实现共识，由矿工挖矿，通过对新的网络协议的制定实现对区块链的同步等操作。不同于比特币的是，在以太坊上可以任意编写智能合约，通过智能合约实现强大的功能，实现去中心化应用的开发。在以太坊上部署的智能合约运行在以太坊特有的虚拟机上，通过以太坊虚拟机和RPC接口与底层区块链进行交互。</strong></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180201162607940?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3UyMzc0NjMzNTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <hr> 
  <h3 id="222-以太坊技术">2.2.2　以太坊技术</h3> 
  <h4 id="1以太坊核心概念">1.以太坊核心概念</h4> 
  <p>（1）以太坊虚拟机 <br> 以太坊虚拟机（EVM）是以太坊中智能合约的运行环境。实际上它是由许多互相连接的计算机组成的。任何人都可以上传程序，并让这些程序自动执行，同时保证现在和所有以前的每个程序的状态总是公共可见的。</p> 
  <p>（2）账户 <br> 以太坊中有两类账户，它们共用同一个地址空间。外部账户，该类账户被公钥-私钥对控制。合约账户，该类账户被存储在账户中的代码控制。外部账户的地址是由公钥决定的，合约账户的地址是在创建合约时由合约创建者的地址和该地址发出过的交易数量计算得到。两类账户的唯一区别是：外部账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。</p> 
  <p>以太坊的账户包含4个部分：①随机数，用于确定每笔交易只能被处理一次的计数器；②账户目前的以太币余额；③账户的合约代码（如果有的话）；④账户的存储（默认为空）。</p> 
  <p>（3）消息 <br> 以太坊的消息在某种程度上类似于比特币的交易，但是两者之间存在3点重要的不同。 <br> 1）<strong>以太坊的消息可以由外部实体或者合约创建，然后比特币的交易只能从外部创建。</strong> <br> 2）<strong>以太坊消息可以选择包含数据。</strong> <br> 3）<strong>如果以太坊消息的接收者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。</strong></p> 
  <p>（4）交易 <br> <strong>以太坊中“交易”是指存储从外部账户发出的消息的签名数据包。</strong>交易包含消息的接收者、用于确认发送者的签名、以太币账户余额、要发送的数据和被称为STARTGAS和GASPRICE的两个数值。为了防止代码出现指数型爆炸和无限循环，每笔交易需要对执行代码所引发的计算步骤做出限制。STARTGAS就是通过需要支付的燃料来对计算步骤进行限制，GASPRICE是每一计算步骤需要支付矿工的燃料的价格。</p> 
  <p>（5）Gas <br> 以太坊上的每笔交易都会被收取一定数量的燃料Gas，设置Gas的目的是限制交易执行所需的工作量，同时为交易的执行支付费用。</p> 
  <p>（6）存储、主存和栈 <br> 每个账户都有一块永久的内存区域，被称为存储，其形式为key-value，key和value的长度均为256位。在合约里，不能遍历账户的存储。相对于主存和栈，存储的读操作开销较大，修改存储甚至更多。一个合约只能对它自己的存储进行读写。</p> 
  <p>第二个内存区被称为主存。合约执行每次消息调用时都有一块新的被清除过的主存。</p> 
  <p>EVM不是基于寄存器的，而是基于栈的虚拟机。因此所有的计算都在一个称为栈的区域内执行。栈最大有1024个元素，每个元素有256位。对栈的访问只限于其顶端，允许复制最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的一个或几个元素，并把结果压在栈顶。 </p> 
  <p>（7）指令集 <br> EVM的指令集被刻意保持在最小规模，以尽可能避免可能导致共识问题的错误。所有的指令都是针对256位这个基本的数据单位进行的操作，具备常用的算术、位、逻辑和比较操作，也可以进行条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。</p> 
  <p>（8）消息调用 <br> 合约可以通过消息调用的方式来调用其他合约，或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源，一个目标，数据负载，以太币，Gas和返回数据。事实上每个交易都可以被认为是一个顶层消息调用，这个消息调用会依次产生更多的消息调用。</p> 
  <p>一个合约可以决定剩余Gas的分配。如果在内部消息调用时发生了out-of-gas异常或者其他异常，合约将会得到通知，一个错误码被压入栈中。这种情况只是内部消息调用的Gas耗尽。</p> 
  <p>被调用的合约（发起调用的合约也一样）会拥有崭新的主存，并能够访问调用的负载。调用负载被存储在一个单独的被称为calldata的区域。调用执行结束后，返回数据将被存放在调用方预先分配好的一块内存中。调用层数被限制为1024。因此对于更加复杂的操作，我们应该使用循环而不是递归。</p> 
  <p>（9）代码调用和库 <br> 以太坊中存在一种特殊类型的消息调用，被称为callcode。它跟消息调用几乎完全一样，只是加载来自目标地址的代码将在发起调用的合约上下文中运行。这意味着一个合约可以在运行时从另外一个地址动态加载代码。</p> 
  <h4 id="2以太坊的状态转换">2.以太坊的状态转换</h4> 
  <p>以太坊的状态转换是指在一个交易（TX）发生时，以太坊从一个正确状态（S）转变到下一个正确状态（S’）的转换过程。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180202111642757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3UyMzc0NjMzNTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>以太坊的状态转换函数为APPLY（S，TX）-&gt;S’，可以定义如下： <br> 1）检查交易的格式是否正确，签名是否有效，以及随机数是否与发送者账户的随机数匹配。如否，返回错误。 <br> 2）计算交易费用fee=STARTGAS*GASPRICE，并从签名中确定发送者的地址。从发送者的账户中减去交易费用和增加发送者的随机数。如果账户余额不足，返回错误。 <br> 3）设定初值Gas=STARTGAS，并根据交易中的字节数减去一定量的燃料值。 <br> 4）从发送者的账户转移价值到接收者账户。如果接收账户还不存在，创建此账户。如果接收账户是一个合约，运行合约的代码，直到代码运用结束或者燃料用完。 <br> 5）如果因为发送者账户没有足够的费用或者代码执行耗尽燃料导致价值转移失败，恢复原来的状态，但是还需要支付交易费用，交易费用加至矿工账户。 <br> 6）若代码执行成功，将所有剩余的燃料归还给发送者，消耗掉的燃料作为交易费用发送给矿工。 <br> 假设合约存储器开始时是空的，一个值为10以太、燃料为2000、燃料价格为0.001以太并且两个数据字段值为[2，‘CHARLIE’]的交易发送后，状态转换函数的处理过程如下： <br> 1）检查交易是否有效，格式是否正确。 <br> 2）检查交易发送者是否至少有2000×0.001=2个以太币。如果有，从发送者账户中减去2个以太币。 <br> 3）初始设定Gas=2000，假设交易长为170字节，每字节的费用是5，减去850，所以还剩1150。 <br> 4）从发送者账户减去10个以太币，为合约账户增加10个以太币。 <br> 5）运行代码。在这个合约中，运行代码很简单：它检查合约存储器索引为2处是否已使用，注意到它未被使用，然后将其值置为CHARLIE。假设这消耗了187单位的燃料，于是剩余的燃料为1150-187=963。 <br> 6）向发送者的账户增加963×0.001=0.963个以太币，返回最终状态。</p> 
  <h4 id="3以太坊客户端">3.以太坊客户端</h4> 
  <p>目前有4种语言编写的以太坊的客户端。它们分别是Go语言实现的客户端Geth，用C++实现的客户端Eth，用Python语言实现的客户端Pyethapp和⽤Java实现的客户端EthereumJ。其中，Go语言版是以太坊官方一直维护并推荐使用的客户端。 </p> 
  <p>以太坊包括一个专用的客户端浏览器（Mist），使得用户可以运用各种各样的去中心化应用（DApp），发布智能合约。Mist由特殊的安全层、密钥管理、去中心化账户管理和与区块链相关的组件几部分组成。</p> 
  <hr> 
  <h3 id="223-以太坊智能合约">2.2.3　以太坊智能合约</h3> 
  <h4 id="1智能合约">1.智能合约</h4> 
  <p>以太坊是内置有图灵完备编程语言的区块链，通过建立抽象的基础层，使得任何人都能够创建合约和去中心化应用，并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。</p> 
  <p>智能合约就像能在以太坊的平台上创建的包含价值而且只有满足某些条件才能打开的加密箱子，并且因为图灵完备性、价值意识（value-awareness）、区块链意识（blockchain-awareness）和记录多状态所增加的功能而比比特币脚本所能提供的智能合约强大得多。</p> 
  <h4 id="2开发语言">2.开发语言</h4> 
  <p>以太坊具有4种专门语言：Serpent（受Python启发）、Solidity（受JavaScript启发）、Mutan（受Go启发）和LLL（受Lisp启发），都是为向合约编程言从底层开始设计的语言。Solidity是以太坊的首选语言。 <br> 以太坊区块链另外特征是图灵完备，这保证了以太坊可以解决所有的计算问题。此外，因为以太坊的语言是为区块链专门设计的，它有账户的概念，使得它在交易的可视化和查询账户状态方面提供了实时性。</p> 
  <h4 id="3代码执行">3.代码执行</h4> 
  <p>以太坊合约的代码是使用低级的基于堆栈的字节码的语言写成的，被称为“以太坊虚拟机代码”或者“EVM代码”。代码由一系列字节构成，每一个字节代表一种操作。操作可以访问3种存储数据的空间： <br> 1）堆栈，一种后进先出的数据存储，入栈、出栈的基本单位为32字节。 <br> 2）内存，可无限扩展的字节队列。 <br> 3）合约的长期存储，一个密钥/数值的存储，其中密钥和数值都是32字节大小。与计算结束即重置的堆栈和内存不同，存储内容将长期保持。</p> 
  <p>代码可以像访问区块头数据一样访问数值、发送和接收到的消息中的数据，代码还可以返回数据的字节队列作为输出。。EVM代码的正式执行模型非常简单。当以太坊虚拟机运行时，它的完整的计算状态可以由元组（block_state，transaction，message，code，memory，stack，pc，gas）来定义，这⾥block_state是包含所有账户余额和存储的全局状态。每轮执行时，通过调出代码的第pc（程序计数器）个字节，每个指令如何影响元组都有定义。</p> 
  <p>例如，ADD将两个元素出栈并将它们的和入栈，将Gas减1并将 <br> pc加1；stack将顶部的两个元素出栈，并将第2个元素插入由第1个元素定义的合约存储位置，同样减少最多200的Gas值，并将pc加1。</p> 
  <hr> 
  <h3 id="224-以太坊的去中心化应用">2.2.4　以太坊的去中心化应用</h3> 
  <h4 id="1什么是dapp">1.什么是DApp</h4> 
  <p>一个DApp是由智能合约和客户端代码构成的。智能合约就像加密的包含价值的箱子。只有当特定条件被满足时它才被打开，<strong>它封装了一些逻辑、规则、处理步骤或者双方间的协议。</strong></p> 
  <p>从架构角度而言，DApp非常类似于传统的Web应用。主要区别是：在传统Web应用中，客户端有JavaScript代码，由用户在自己的浏览器中执行；服务器端的代码由主机运行。<strong>但是在一个DApp中，它的智能逻辑运行在区块链上，客户端代码运行在特殊浏览器Mist里面。</strong></p> 
  <h4 id="2应用举例">2.应用举例</h4> 
  <p>Augur（www.augur.net），一个正在开发去中心化预测系统。用户可以在这个应用上对各种事件打赌并下注，例如希拉里会不会赢得2016年美国的大选。</p> 
  <p>Maker（www.makerdao.com），一个正在开发中的金融类去中心化自治组织（DAO）。它维护一系列用于金融服务的合约软件（即智能合约），其中的一个软件是贷券信贷系统。</p> 
  <p>WeiFund，一个正在开发中的去中心化众筹平台。这个众筹平台的好处是资金不需要第三方托管，而是由程序托管，因此能够确保资金100%安全。</p> 
  <p>Boardroom，一个正在开发中的DAO管理平台。去中心化自治组织与传统公司一样，也可以有股份的概念，通常就是DAO的代币，这些代币又可以有投票权。</p> 
  <p>Ujo Music，一个音乐版权管理平台，测试版。Ujo Music作为音乐版权管理平台，可以直接在歌曲的创作者与消费者之间建立直接的联系，从而省去了中间商的费用提成。</p> 
  <p>贷券简称Dai或者Dai Bond，是一种可转让的、彼此等价可互换的“加密债券”，它流通于信贷系统中，使用者无需事先认证，同时又是低风险的。贷券的发行人（借款人）将在以太坊区块链上的以太等数字加密资产作为抵押品来发行贷券，再将这些贷券在市场上卖给贷券持有以换回流动性好的资产。</p> 
  <hr> 
  <h2 id="23-基于区块链的电子货币">2.3　基于区块链的电子货币</h2> 
  <h3 id="231-元币平台">2.3.1　元币平台</h3> 
  <p>元币（metacoin）单词前缀“meta-”意为“在其中”。所以元币是衍生于现有加密货币体系之上，更专注于业务系统的代币种类。</p> 
  <h3 id="232-代币">2.3.2　代币</h3> 
  <h4 id="1通过货币参数修改而建立的代币">1.通过货币参数修改而建立的代币</h4> 
  <h4 id="2基于共识机制的创新而建立的代币">2.基于共识机制的创新而建立的代币</h4> 
  <p>比特币的共识机制是建立在用SHA256算法加密的作业证据基础之上的。</p> 
  <h4 id="3通过双目标挖矿机制创新而建立的代币">3.通过双目标挖矿机制创新而建立的代币</h4> 
  <p>比特币的工作量证明算法仅仅具有一个目的，那就是确保比特链的安全。尽管相对于传统支付系统的安全，这点挖矿开销并不高，但是被指是一种浪费。双目标工作量证明算法在产生工作量证明来满足安全的同时，解决一个具体的问题。但这样做也带来一定的风险。在向货币安全添加额外功能的同时，也影响了其供求曲线。</p> 
  <h4 id="4注重隐私性的代币">4.注重隐私性的代币</h4> 
  <p>比特币常常被误认为具有隐私性。事实上，通过大数据分析，关联身份和比特币地址相对容易，从而通过连接彼此的地址，解析一个人的比特币消费习惯。所以，一些代币专注于强隐私性，试图直接解决此问题。</p> 
  <hr> 
  <h3 id="233-货币的未来">2.3.3　货币的未来</h3> 
  <p>加密货币的未来整体来说比比特币更加繁荣。它们在比特币的基础上引进了全新的去中心化的组织形式和共识机制，并由此衍生出了数以百计的不可思议的创新。这将影响与经济相关的众多部门，如：财政、经济、货币、中央银行、企业管理等。</p> 
  <hr> 
  <h2 id="24-本章小结">2.4 本章小结</h2> 
  <p>本章主要介绍了区块链技术的基础知识。首先，介绍了区块链技术，包括区块链技术的基本概念、框架与特点，核心技术及交易流程。在这个基础之上，我们详细介绍了区块链技术最成功的应用——用特币，包括概念、原理、及隐私模型。之后，我们介绍了区块链的另外一个重要应用——以太坊。以太坊是区块链技术发展的一个重要的方向，是区块链技术未来的一部分。我们介绍了以太坊技术、以太坊智能合约、以太坊去中心化应用、以太坊发展的现状及未来。最后，我们分析了现有的流行的电子货币各自的优缺点。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wu2374633583/article/details/79165543,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wu2374633583/article/details/79165543,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
