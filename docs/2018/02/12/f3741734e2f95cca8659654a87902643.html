<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>揭秘你所看不见的技术原理 - 附近的人 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="揭秘你所看不见的技术原理 - 附近的人" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="摘要 相信很多朋友都用到过微信附近的人功能，这个神奇的功能让陌生人能成为朋友、聊友、饭友，甚至能帮助一些朋友解决自身的一些生理需求。点开附近的人，就能显示附近的人甚至是附近的异性，真是一级棒。 但是大家在使用这个功能时有没有想过技术方面的实现原理呢？系统是如何在我们点开附近的人时，帮我们选出附近的人，同时还能计算出距离。接下来我们就来揭秘附近的人这个技术魔法。 定位原理 说到定位其实是离不开定位系统，例如GPS与北斗系统等。这些系统能提供给我们位置信息，也就是我们所处的经纬度。理想状态下，我们拿到经纬度后就能依据每一个用户的经纬度来计算附近的人了。那事实是不是这样呢？ 当然不是，如果是这样我这篇文章也就没必要写了，技术点门槛也太低了。那为何不能这么做？其实原因很简单，像微信这种用户动不动就过亿的app，如果每一次定位都依据用户原始的经纬度来计算，运算量实在是太大了。首先要计算与亿级用户的距离，然后依据距离排序。要是没有计算机，我们每分钟能计算3个人，每小时能计算180人，每天计算4320人，每年计算1,576,900，这辈子也算不完了，就算计算机能帮助我们提高10万倍的计算速度，这么多人也要算半个小时。 但是有没有发现，我们打开附件的人可能两秒钟就把附件的用户筛选出来了。这么快的速度肯定不是计算所有的经纬度。其实是有一套计算原理的。 1. 对着地图画格子 对于定位系统来说，我们的地球是被一个一个格子构成的，而每一个格子包含着一定的区域。我们拿北京城区为例，在画格子之前是： 将地图放入定位系统后，城区就不再是这个样子了，而是被分割成若干个格子，每一个格子都有格子的“名字”： 至于如何定义每一块的名称，后续章节-geohash算法会具体提及，这里不再复述。 2. 找到你所在的格子 定义了格子的名称，当然就有他的用处了，不然这不是白白定义了吗。其实在打开微信附近的人时，系统也会把设备的位置信息给记录，这时候系统依据设备的位置信息，通过geohash算法，计算出所在块名称。比如我们在天安门广场时，系统的计算名称可能是“EFACMDH”，名称有多少个字母主要看系统要求的定位精度最高为多少。我们发现设备位置名称的前5个字母是“EFACM”，正好是在地图中正中间的格子中，也就是包含了天安门的格子。但是设备位置名称后面还包含了“DH”，这说明当前格子包含的位置还不够详细，还不能说明设备所在更为精确的位置。因此我们还需要将格子更为细分，将“EFACM”格子放大，为下图： 这个范围内的所有格子前5个字符都是“EFACM”，但是都出现了第六个字符，而且第六个字符不同，其实就是因为这些位置范围都在“EFACM”中，只是对“EFACM”放大细分的结果。 而设备的位置信息为“EFACMDH”，也就是当前的位置范围任然不够精确，还需要继续细分，因此我们找出前六个字符为“EFACMD”的格子，再细分，如下图： 依据设备的位置编码，我们找出了设备所处的位置在红色框内，这时候我们把设备的位置信息记录在“EFACMDH”框内： 这样就将地图画成了格子，并且将设备的位置也记录在的相应的格子中。 3. 小结 整个定位，其实就是不断地进行着地图区域细化过程，我们依据系统设计的最高经度，计算出设备经纬度所在的区块名称，并将设备与经纬度记录在区块中，如下图： 接下来就是通过区块名称，将附件的人揪出来了。 揪出附近的人 上面这些区块与名称，作为用户的我们是看不到也不关心的，我们关心的是附近的人是如何选出来并展现在设备中。 1. 揪出第一批人 什么叫做第一批人，其实就像是微信中第一批大约展示20个人，这20人是离我们最近的20人，为了选出这20位好汉，系统进行了如下步骤： 找出所有在设备（浅蓝色点）所在的区块“EFACMDH”中的全部设备（蓝黑色的点）； 依据浅蓝色点与所有蓝黑色点的经纬度，计算出亮点之间的距离（这个网上有教程，很容易算），并对两点距离进行排序； 读取蓝黑色所有点的用户信息（头像、名称、微信号等等）； 按距离有小到大发送给设备并显示在附近的人中。 通过这些步骤，系统既获得了附近人的位置，又获得了用户信息、与当前设备距离等信息。所以说不只是显示距离，甚至附近的人在哪里都可以查询到，只是可能涉及到了用户隐私，不提供这项功能而已。 2. 还想看其他人 当“EFACMDH”区块记录的用户小于20名，或者用户还想查看更多的附近的人时，就需要扩大查询范围了。其实扩大查询范围无非就是减少一位名称，从查询“EFACMDH”变成查询“EFACMD”。流程如下： 将名称英文字母减少一位，由“EFACMDH”变成“EFACMD”； 查询区块名称类似于“EFACMD”的所有区块，例如“EFACMDHA”至“EFACMDY”区块，共同组成“EFACMDH”区块； 找出“EFACMD”的所有位置信息，并依据“1. 揪出第一批人”的方法获得排序后的用户信息 将用户信息回传给设备，并显示。 扩大查询范围其实要比查询当前区块的消耗是要大一些的。因为需要将若干个小区块组合成一个大区块；同时还要进行区块名类似性匹配，比精确匹配的消耗是要高上不少的。这就是为何查询附近的人时，都是先显示少数最近的一些人。 3. 小结 知道了附近的人查询原理，是不是觉得原来实现这么简单。其实中间还设计一些hash匹配、数据存储等，只是这些过于技术，与业务联系不紧密，这里也就没必要过深入地研究了。有兴趣的同学可以查阅redis数据库的geohash模块。 geohash算法 本章节与附近人业务关系不大了，而且内容偏技术性，若不是技术方面的同学可以跳过了。 1. geohash简单原理 上面已经把如何查找附近的人技术原理梳理了一遍，但是留下了一个问题是每一个区块都有一个名字，这个名字是如何来的？接下来将揭晓这个谜团。 为了方便提取位置信息，人为地把地球划分了经度与纬度，依据经纬度，又可以画一些经纬度参考线。犹如地球仪中，人为地划分了若干条经度线与纬度线，依据这些参考线我们可以知道某一些位置在参考线以东或者以西、以南或者以北，从而估算出大概的经度纬度。 geohash算法就是依据这个原理，算法思路就是对参考线进行不断细分，判断当前位置是在参考线以东（右）或者参考线以西（左），以东用1来标记，以西用0来标记，最后组成一个01串，再依据01串按照一定的编码格式转换成容易辨认的英文字符+数字的组合。 2. geohash计算过程 依据上述原理，接下来详细介绍一下geohash的计算过程，这里拿经纬度（116.389550， 39.928167）进行算法说明。 a. 纬度计算 中学学过的地理知识知道，地球分为南纬与北纬，分别都是0~90°，但是在计算机中，用文字定义南纬与北纬较为麻烦，所以计算机中用区间定义[-90,0)与[0,90]分为南北纬，同时叫做左右区间。区分了左右区间，接下来就是整个计算过程： 判断当前纬度39.928167是在左区间还是右区间，发现是在右区间[0,90]中，在右区间标识为1； 接着将区间[0,90]进行左右区间二分，二分后为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，标记为0； 不断重复上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167； 依据最大精度，定义一个最大重复次数，这里我们定义为15，这样就能得出一个01字串； 重复数 纬度范围 左区间 右区间 39.928167 1 [-90.0, 90.0] [-90.0, 0.0) [0.0, 90.0] 1 2 [0, 90.0] [0.0, 45.0) [45.0, 90] 0 3 [0.0, 45.0) [0.0, 22.5) [22.5, 45.0) 1 4 [22.5, 45.0] [22.5, 33.75) [33.75, 45.0] 1 5 [33.75, 45.0] [33.75, 39.375) [39.375, 45.0] 1 6 [39.375, 45.0] [39.375, 42.1875) [42.1875, 45.0] 0 7 [39.375, 42.1875) [39.375, 40.7812) [40.7812, 42.1875) 0 8 [39.375, 40.7812) [39.375, 40.0781) [40.0781, 40.7812) 0 9 [39.375, 40.0781) [39.375, 39.7265) [39.7265, 40.0781) 1 10 [39.7265, 40.0781) [39.7265, 39.9023) [39.9023, 40.0781) 1 11 [39.9023, 40.0781) [39.9023, 39.9902) [39.9902, 40.0781) 0 12 [39.9023, 39.9902) [39.9023, 39.9462) [39.9462, 39.9902) 0 13 [39.9023, 39.9462) [39.9023, 39.9243) [39.9243, 39.9462) 1 14 [39.9243, 39.9462) [39.9243, 39.9353) [39.9353, 39.9462) 0 15 [39.9243, 39.9353) [39.9243, 39.9298) [39.9298, 39.9353) 0 纬度最终得到的01字串为：1 0 1 1 1 0 0 0 1 1 0 0 1 0 0 b. 全局计算 经度计算与纬度计算类似，也是依据区间划分，左右判断来进行，这里就不在复述了，给出最终计算结果为：1 1 0 1 0 0 1 0 1 1 0 0 0 1 0，接下来就是如何通过经度与纬度的01字串，编码成相应的字母+数字的组合。 将经度与纬度的01字串进行合并，合并方法为：基数为放纬度，偶数位放经度，如下表： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 1 0 1 1 1 0 0 0 1 1 0 0 1 0 0 1 1 0 1 0 0 1 0 1 1 0 0 0 1 0 1 1 0 1 1 0 1 1 1 0 0 0 0 1 0 0 1 1 1 1 0 0 0 0 1 0 0 1 0 0 最终字串为：11011, 01110, 00010, 01111, 00001, 00100 将字串转换成十进制，得到：27, 14, 2, 15, 1, 4 对应base32编码表，如下： 数字 字符 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 b 11 c 12 d 13 e 14 f 15 g 16 h 17 j 18 k 19 m 20 n 21 p 22 q 23 r 24 s 25 t 26 u 27 v 28 w 29 x 30 y 31 z 最终得出（116.389550， 39.928167）所在区块为：VF2G14(可能有计算错误，不要在意这些细节) 这就是我们如何通过位置点，计算出位置所在区块的原理了。 3. 计算精度问题 通过上面的计算可以看到，循环计算15次才获得6位geohash字串，那6位geohash的精度是多少呢？如下表： geohash长度 纬度位数 经度位数 纬度误差 经度误差 距离误差（km） 1 2 3 ± 23 ± 23 ± 2500 2 5 5 ± 2.8 ± 56 ± 630 3 7 8 ± 0.7 ± 0.7 ± 78 4 10 10 ± 0.087 ± 0.18 ± 20 5 12 13 ± 0.022 ± 0.022 ± 2.4 6 15 15 ± 0.0027 ± 0.0055 ± 0.61 7 17 18 ± 0.00068 ± 0.00068 ± 0.076 8 20 20 ± 0.000086 ± 0.000172 ± 0.01911 9 22 23 ± 0.000021 ± 0.000021 ± 0.00478 10 25 25 ± 0.00000268 ± 0.00000536 ± 0.0005971 11 27 28 ± 0.00000067 ± 0.00000067 ± 0.0001492 12 30 30 ± 0,00000008 ± 0.00000017 ± 0.0000186 可以看出geohash的长度达到6个字符的误差是610m，长度达到8以上时精度已经达到了10m级。 但是当前民用领域定位系统的定位误差都在10m以上，如果在城区由于高楼、大树等影响定位系统型号，所以误差可以达到50m（不要看到导航软件那么准就认为没有误差，其实那是经过了强大的数据修正）。所以通过geohash定位附近的人时，8位已经是极限了，定位系统的精度导致再高的精度已经没有了意义。 总结 以上已经把附近的人找寻原理、定位算法原理都梳理了一遍，是不是觉得自己可以出门去寻找那个附近的人了。 当前移动设备非常发达，每一个智能手机中几乎都会安装GPS或者北斗芯片，而且GPS与北斗系统一直在不断升级，定位的精度也越来越高。这样附近的人算法精度也就越来越高。同时设备提供的API也非常容易使用，也为基于位置的服务变得（LBS）非常发达。相信通过原理的讲解能让大家更为了解隐藏在底层的东西。 阅读更多" />
<meta property="og:description" content="摘要 相信很多朋友都用到过微信附近的人功能，这个神奇的功能让陌生人能成为朋友、聊友、饭友，甚至能帮助一些朋友解决自身的一些生理需求。点开附近的人，就能显示附近的人甚至是附近的异性，真是一级棒。 但是大家在使用这个功能时有没有想过技术方面的实现原理呢？系统是如何在我们点开附近的人时，帮我们选出附近的人，同时还能计算出距离。接下来我们就来揭秘附近的人这个技术魔法。 定位原理 说到定位其实是离不开定位系统，例如GPS与北斗系统等。这些系统能提供给我们位置信息，也就是我们所处的经纬度。理想状态下，我们拿到经纬度后就能依据每一个用户的经纬度来计算附近的人了。那事实是不是这样呢？ 当然不是，如果是这样我这篇文章也就没必要写了，技术点门槛也太低了。那为何不能这么做？其实原因很简单，像微信这种用户动不动就过亿的app，如果每一次定位都依据用户原始的经纬度来计算，运算量实在是太大了。首先要计算与亿级用户的距离，然后依据距离排序。要是没有计算机，我们每分钟能计算3个人，每小时能计算180人，每天计算4320人，每年计算1,576,900，这辈子也算不完了，就算计算机能帮助我们提高10万倍的计算速度，这么多人也要算半个小时。 但是有没有发现，我们打开附件的人可能两秒钟就把附件的用户筛选出来了。这么快的速度肯定不是计算所有的经纬度。其实是有一套计算原理的。 1. 对着地图画格子 对于定位系统来说，我们的地球是被一个一个格子构成的，而每一个格子包含着一定的区域。我们拿北京城区为例，在画格子之前是： 将地图放入定位系统后，城区就不再是这个样子了，而是被分割成若干个格子，每一个格子都有格子的“名字”： 至于如何定义每一块的名称，后续章节-geohash算法会具体提及，这里不再复述。 2. 找到你所在的格子 定义了格子的名称，当然就有他的用处了，不然这不是白白定义了吗。其实在打开微信附近的人时，系统也会把设备的位置信息给记录，这时候系统依据设备的位置信息，通过geohash算法，计算出所在块名称。比如我们在天安门广场时，系统的计算名称可能是“EFACMDH”，名称有多少个字母主要看系统要求的定位精度最高为多少。我们发现设备位置名称的前5个字母是“EFACM”，正好是在地图中正中间的格子中，也就是包含了天安门的格子。但是设备位置名称后面还包含了“DH”，这说明当前格子包含的位置还不够详细，还不能说明设备所在更为精确的位置。因此我们还需要将格子更为细分，将“EFACM”格子放大，为下图： 这个范围内的所有格子前5个字符都是“EFACM”，但是都出现了第六个字符，而且第六个字符不同，其实就是因为这些位置范围都在“EFACM”中，只是对“EFACM”放大细分的结果。 而设备的位置信息为“EFACMDH”，也就是当前的位置范围任然不够精确，还需要继续细分，因此我们找出前六个字符为“EFACMD”的格子，再细分，如下图： 依据设备的位置编码，我们找出了设备所处的位置在红色框内，这时候我们把设备的位置信息记录在“EFACMDH”框内： 这样就将地图画成了格子，并且将设备的位置也记录在的相应的格子中。 3. 小结 整个定位，其实就是不断地进行着地图区域细化过程，我们依据系统设计的最高经度，计算出设备经纬度所在的区块名称，并将设备与经纬度记录在区块中，如下图： 接下来就是通过区块名称，将附件的人揪出来了。 揪出附近的人 上面这些区块与名称，作为用户的我们是看不到也不关心的，我们关心的是附近的人是如何选出来并展现在设备中。 1. 揪出第一批人 什么叫做第一批人，其实就像是微信中第一批大约展示20个人，这20人是离我们最近的20人，为了选出这20位好汉，系统进行了如下步骤： 找出所有在设备（浅蓝色点）所在的区块“EFACMDH”中的全部设备（蓝黑色的点）； 依据浅蓝色点与所有蓝黑色点的经纬度，计算出亮点之间的距离（这个网上有教程，很容易算），并对两点距离进行排序； 读取蓝黑色所有点的用户信息（头像、名称、微信号等等）； 按距离有小到大发送给设备并显示在附近的人中。 通过这些步骤，系统既获得了附近人的位置，又获得了用户信息、与当前设备距离等信息。所以说不只是显示距离，甚至附近的人在哪里都可以查询到，只是可能涉及到了用户隐私，不提供这项功能而已。 2. 还想看其他人 当“EFACMDH”区块记录的用户小于20名，或者用户还想查看更多的附近的人时，就需要扩大查询范围了。其实扩大查询范围无非就是减少一位名称，从查询“EFACMDH”变成查询“EFACMD”。流程如下： 将名称英文字母减少一位，由“EFACMDH”变成“EFACMD”； 查询区块名称类似于“EFACMD”的所有区块，例如“EFACMDHA”至“EFACMDY”区块，共同组成“EFACMDH”区块； 找出“EFACMD”的所有位置信息，并依据“1. 揪出第一批人”的方法获得排序后的用户信息 将用户信息回传给设备，并显示。 扩大查询范围其实要比查询当前区块的消耗是要大一些的。因为需要将若干个小区块组合成一个大区块；同时还要进行区块名类似性匹配，比精确匹配的消耗是要高上不少的。这就是为何查询附近的人时，都是先显示少数最近的一些人。 3. 小结 知道了附近的人查询原理，是不是觉得原来实现这么简单。其实中间还设计一些hash匹配、数据存储等，只是这些过于技术，与业务联系不紧密，这里也就没必要过深入地研究了。有兴趣的同学可以查阅redis数据库的geohash模块。 geohash算法 本章节与附近人业务关系不大了，而且内容偏技术性，若不是技术方面的同学可以跳过了。 1. geohash简单原理 上面已经把如何查找附近的人技术原理梳理了一遍，但是留下了一个问题是每一个区块都有一个名字，这个名字是如何来的？接下来将揭晓这个谜团。 为了方便提取位置信息，人为地把地球划分了经度与纬度，依据经纬度，又可以画一些经纬度参考线。犹如地球仪中，人为地划分了若干条经度线与纬度线，依据这些参考线我们可以知道某一些位置在参考线以东或者以西、以南或者以北，从而估算出大概的经度纬度。 geohash算法就是依据这个原理，算法思路就是对参考线进行不断细分，判断当前位置是在参考线以东（右）或者参考线以西（左），以东用1来标记，以西用0来标记，最后组成一个01串，再依据01串按照一定的编码格式转换成容易辨认的英文字符+数字的组合。 2. geohash计算过程 依据上述原理，接下来详细介绍一下geohash的计算过程，这里拿经纬度（116.389550， 39.928167）进行算法说明。 a. 纬度计算 中学学过的地理知识知道，地球分为南纬与北纬，分别都是0~90°，但是在计算机中，用文字定义南纬与北纬较为麻烦，所以计算机中用区间定义[-90,0)与[0,90]分为南北纬，同时叫做左右区间。区分了左右区间，接下来就是整个计算过程： 判断当前纬度39.928167是在左区间还是右区间，发现是在右区间[0,90]中，在右区间标识为1； 接着将区间[0,90]进行左右区间二分，二分后为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，标记为0； 不断重复上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167； 依据最大精度，定义一个最大重复次数，这里我们定义为15，这样就能得出一个01字串； 重复数 纬度范围 左区间 右区间 39.928167 1 [-90.0, 90.0] [-90.0, 0.0) [0.0, 90.0] 1 2 [0, 90.0] [0.0, 45.0) [45.0, 90] 0 3 [0.0, 45.0) [0.0, 22.5) [22.5, 45.0) 1 4 [22.5, 45.0] [22.5, 33.75) [33.75, 45.0] 1 5 [33.75, 45.0] [33.75, 39.375) [39.375, 45.0] 1 6 [39.375, 45.0] [39.375, 42.1875) [42.1875, 45.0] 0 7 [39.375, 42.1875) [39.375, 40.7812) [40.7812, 42.1875) 0 8 [39.375, 40.7812) [39.375, 40.0781) [40.0781, 40.7812) 0 9 [39.375, 40.0781) [39.375, 39.7265) [39.7265, 40.0781) 1 10 [39.7265, 40.0781) [39.7265, 39.9023) [39.9023, 40.0781) 1 11 [39.9023, 40.0781) [39.9023, 39.9902) [39.9902, 40.0781) 0 12 [39.9023, 39.9902) [39.9023, 39.9462) [39.9462, 39.9902) 0 13 [39.9023, 39.9462) [39.9023, 39.9243) [39.9243, 39.9462) 1 14 [39.9243, 39.9462) [39.9243, 39.9353) [39.9353, 39.9462) 0 15 [39.9243, 39.9353) [39.9243, 39.9298) [39.9298, 39.9353) 0 纬度最终得到的01字串为：1 0 1 1 1 0 0 0 1 1 0 0 1 0 0 b. 全局计算 经度计算与纬度计算类似，也是依据区间划分，左右判断来进行，这里就不在复述了，给出最终计算结果为：1 1 0 1 0 0 1 0 1 1 0 0 0 1 0，接下来就是如何通过经度与纬度的01字串，编码成相应的字母+数字的组合。 将经度与纬度的01字串进行合并，合并方法为：基数为放纬度，偶数位放经度，如下表： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 1 0 1 1 1 0 0 0 1 1 0 0 1 0 0 1 1 0 1 0 0 1 0 1 1 0 0 0 1 0 1 1 0 1 1 0 1 1 1 0 0 0 0 1 0 0 1 1 1 1 0 0 0 0 1 0 0 1 0 0 最终字串为：11011, 01110, 00010, 01111, 00001, 00100 将字串转换成十进制，得到：27, 14, 2, 15, 1, 4 对应base32编码表，如下： 数字 字符 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 b 11 c 12 d 13 e 14 f 15 g 16 h 17 j 18 k 19 m 20 n 21 p 22 q 23 r 24 s 25 t 26 u 27 v 28 w 29 x 30 y 31 z 最终得出（116.389550， 39.928167）所在区块为：VF2G14(可能有计算错误，不要在意这些细节) 这就是我们如何通过位置点，计算出位置所在区块的原理了。 3. 计算精度问题 通过上面的计算可以看到，循环计算15次才获得6位geohash字串，那6位geohash的精度是多少呢？如下表： geohash长度 纬度位数 经度位数 纬度误差 经度误差 距离误差（km） 1 2 3 ± 23 ± 23 ± 2500 2 5 5 ± 2.8 ± 56 ± 630 3 7 8 ± 0.7 ± 0.7 ± 78 4 10 10 ± 0.087 ± 0.18 ± 20 5 12 13 ± 0.022 ± 0.022 ± 2.4 6 15 15 ± 0.0027 ± 0.0055 ± 0.61 7 17 18 ± 0.00068 ± 0.00068 ± 0.076 8 20 20 ± 0.000086 ± 0.000172 ± 0.01911 9 22 23 ± 0.000021 ± 0.000021 ± 0.00478 10 25 25 ± 0.00000268 ± 0.00000536 ± 0.0005971 11 27 28 ± 0.00000067 ± 0.00000067 ± 0.0001492 12 30 30 ± 0,00000008 ± 0.00000017 ± 0.0000186 可以看出geohash的长度达到6个字符的误差是610m，长度达到8以上时精度已经达到了10m级。 但是当前民用领域定位系统的定位误差都在10m以上，如果在城区由于高楼、大树等影响定位系统型号，所以误差可以达到50m（不要看到导航软件那么准就认为没有误差，其实那是经过了强大的数据修正）。所以通过geohash定位附近的人时，8位已经是极限了，定位系统的精度导致再高的精度已经没有了意义。 总结 以上已经把附近的人找寻原理、定位算法原理都梳理了一遍，是不是觉得自己可以出门去寻找那个附近的人了。 当前移动设备非常发达，每一个智能手机中几乎都会安装GPS或者北斗芯片，而且GPS与北斗系统一直在不断升级，定位的精度也越来越高。这样附近的人算法精度也就越来越高。同时设备提供的API也非常容易使用，也为基于位置的服务变得（LBS）非常发达。相信通过原理的讲解能让大家更为了解隐藏在底层的东西。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/02/12/f3741734e2f95cca8659654a87902643.html" />
<meta property="og:url" content="https://mlh.app/2018/02/12/f3741734e2f95cca8659654a87902643.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-12T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"摘要 相信很多朋友都用到过微信附近的人功能，这个神奇的功能让陌生人能成为朋友、聊友、饭友，甚至能帮助一些朋友解决自身的一些生理需求。点开附近的人，就能显示附近的人甚至是附近的异性，真是一级棒。 但是大家在使用这个功能时有没有想过技术方面的实现原理呢？系统是如何在我们点开附近的人时，帮我们选出附近的人，同时还能计算出距离。接下来我们就来揭秘附近的人这个技术魔法。 定位原理 说到定位其实是离不开定位系统，例如GPS与北斗系统等。这些系统能提供给我们位置信息，也就是我们所处的经纬度。理想状态下，我们拿到经纬度后就能依据每一个用户的经纬度来计算附近的人了。那事实是不是这样呢？ 当然不是，如果是这样我这篇文章也就没必要写了，技术点门槛也太低了。那为何不能这么做？其实原因很简单，像微信这种用户动不动就过亿的app，如果每一次定位都依据用户原始的经纬度来计算，运算量实在是太大了。首先要计算与亿级用户的距离，然后依据距离排序。要是没有计算机，我们每分钟能计算3个人，每小时能计算180人，每天计算4320人，每年计算1,576,900，这辈子也算不完了，就算计算机能帮助我们提高10万倍的计算速度，这么多人也要算半个小时。 但是有没有发现，我们打开附件的人可能两秒钟就把附件的用户筛选出来了。这么快的速度肯定不是计算所有的经纬度。其实是有一套计算原理的。 1. 对着地图画格子 对于定位系统来说，我们的地球是被一个一个格子构成的，而每一个格子包含着一定的区域。我们拿北京城区为例，在画格子之前是： 将地图放入定位系统后，城区就不再是这个样子了，而是被分割成若干个格子，每一个格子都有格子的“名字”： 至于如何定义每一块的名称，后续章节-geohash算法会具体提及，这里不再复述。 2. 找到你所在的格子 定义了格子的名称，当然就有他的用处了，不然这不是白白定义了吗。其实在打开微信附近的人时，系统也会把设备的位置信息给记录，这时候系统依据设备的位置信息，通过geohash算法，计算出所在块名称。比如我们在天安门广场时，系统的计算名称可能是“EFACMDH”，名称有多少个字母主要看系统要求的定位精度最高为多少。我们发现设备位置名称的前5个字母是“EFACM”，正好是在地图中正中间的格子中，也就是包含了天安门的格子。但是设备位置名称后面还包含了“DH”，这说明当前格子包含的位置还不够详细，还不能说明设备所在更为精确的位置。因此我们还需要将格子更为细分，将“EFACM”格子放大，为下图： 这个范围内的所有格子前5个字符都是“EFACM”，但是都出现了第六个字符，而且第六个字符不同，其实就是因为这些位置范围都在“EFACM”中，只是对“EFACM”放大细分的结果。 而设备的位置信息为“EFACMDH”，也就是当前的位置范围任然不够精确，还需要继续细分，因此我们找出前六个字符为“EFACMD”的格子，再细分，如下图： 依据设备的位置编码，我们找出了设备所处的位置在红色框内，这时候我们把设备的位置信息记录在“EFACMDH”框内： 这样就将地图画成了格子，并且将设备的位置也记录在的相应的格子中。 3. 小结 整个定位，其实就是不断地进行着地图区域细化过程，我们依据系统设计的最高经度，计算出设备经纬度所在的区块名称，并将设备与经纬度记录在区块中，如下图： 接下来就是通过区块名称，将附件的人揪出来了。 揪出附近的人 上面这些区块与名称，作为用户的我们是看不到也不关心的，我们关心的是附近的人是如何选出来并展现在设备中。 1. 揪出第一批人 什么叫做第一批人，其实就像是微信中第一批大约展示20个人，这20人是离我们最近的20人，为了选出这20位好汉，系统进行了如下步骤： 找出所有在设备（浅蓝色点）所在的区块“EFACMDH”中的全部设备（蓝黑色的点）； 依据浅蓝色点与所有蓝黑色点的经纬度，计算出亮点之间的距离（这个网上有教程，很容易算），并对两点距离进行排序； 读取蓝黑色所有点的用户信息（头像、名称、微信号等等）； 按距离有小到大发送给设备并显示在附近的人中。 通过这些步骤，系统既获得了附近人的位置，又获得了用户信息、与当前设备距离等信息。所以说不只是显示距离，甚至附近的人在哪里都可以查询到，只是可能涉及到了用户隐私，不提供这项功能而已。 2. 还想看其他人 当“EFACMDH”区块记录的用户小于20名，或者用户还想查看更多的附近的人时，就需要扩大查询范围了。其实扩大查询范围无非就是减少一位名称，从查询“EFACMDH”变成查询“EFACMD”。流程如下： 将名称英文字母减少一位，由“EFACMDH”变成“EFACMD”； 查询区块名称类似于“EFACMD”的所有区块，例如“EFACMDHA”至“EFACMDY”区块，共同组成“EFACMDH”区块； 找出“EFACMD”的所有位置信息，并依据“1. 揪出第一批人”的方法获得排序后的用户信息 将用户信息回传给设备，并显示。 扩大查询范围其实要比查询当前区块的消耗是要大一些的。因为需要将若干个小区块组合成一个大区块；同时还要进行区块名类似性匹配，比精确匹配的消耗是要高上不少的。这就是为何查询附近的人时，都是先显示少数最近的一些人。 3. 小结 知道了附近的人查询原理，是不是觉得原来实现这么简单。其实中间还设计一些hash匹配、数据存储等，只是这些过于技术，与业务联系不紧密，这里也就没必要过深入地研究了。有兴趣的同学可以查阅redis数据库的geohash模块。 geohash算法 本章节与附近人业务关系不大了，而且内容偏技术性，若不是技术方面的同学可以跳过了。 1. geohash简单原理 上面已经把如何查找附近的人技术原理梳理了一遍，但是留下了一个问题是每一个区块都有一个名字，这个名字是如何来的？接下来将揭晓这个谜团。 为了方便提取位置信息，人为地把地球划分了经度与纬度，依据经纬度，又可以画一些经纬度参考线。犹如地球仪中，人为地划分了若干条经度线与纬度线，依据这些参考线我们可以知道某一些位置在参考线以东或者以西、以南或者以北，从而估算出大概的经度纬度。 geohash算法就是依据这个原理，算法思路就是对参考线进行不断细分，判断当前位置是在参考线以东（右）或者参考线以西（左），以东用1来标记，以西用0来标记，最后组成一个01串，再依据01串按照一定的编码格式转换成容易辨认的英文字符+数字的组合。 2. geohash计算过程 依据上述原理，接下来详细介绍一下geohash的计算过程，这里拿经纬度（116.389550， 39.928167）进行算法说明。 a. 纬度计算 中学学过的地理知识知道，地球分为南纬与北纬，分别都是0~90°，但是在计算机中，用文字定义南纬与北纬较为麻烦，所以计算机中用区间定义[-90,0)与[0,90]分为南北纬，同时叫做左右区间。区分了左右区间，接下来就是整个计算过程： 判断当前纬度39.928167是在左区间还是右区间，发现是在右区间[0,90]中，在右区间标识为1； 接着将区间[0,90]进行左右区间二分，二分后为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，标记为0； 不断重复上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167； 依据最大精度，定义一个最大重复次数，这里我们定义为15，这样就能得出一个01字串； 重复数 纬度范围 左区间 右区间 39.928167 1 [-90.0, 90.0] [-90.0, 0.0) [0.0, 90.0] 1 2 [0, 90.0] [0.0, 45.0) [45.0, 90] 0 3 [0.0, 45.0) [0.0, 22.5) [22.5, 45.0) 1 4 [22.5, 45.0] [22.5, 33.75) [33.75, 45.0] 1 5 [33.75, 45.0] [33.75, 39.375) [39.375, 45.0] 1 6 [39.375, 45.0] [39.375, 42.1875) [42.1875, 45.0] 0 7 [39.375, 42.1875) [39.375, 40.7812) [40.7812, 42.1875) 0 8 [39.375, 40.7812) [39.375, 40.0781) [40.0781, 40.7812) 0 9 [39.375, 40.0781) [39.375, 39.7265) [39.7265, 40.0781) 1 10 [39.7265, 40.0781) [39.7265, 39.9023) [39.9023, 40.0781) 1 11 [39.9023, 40.0781) [39.9023, 39.9902) [39.9902, 40.0781) 0 12 [39.9023, 39.9902) [39.9023, 39.9462) [39.9462, 39.9902) 0 13 [39.9023, 39.9462) [39.9023, 39.9243) [39.9243, 39.9462) 1 14 [39.9243, 39.9462) [39.9243, 39.9353) [39.9353, 39.9462) 0 15 [39.9243, 39.9353) [39.9243, 39.9298) [39.9298, 39.9353) 0 纬度最终得到的01字串为：1 0 1 1 1 0 0 0 1 1 0 0 1 0 0 b. 全局计算 经度计算与纬度计算类似，也是依据区间划分，左右判断来进行，这里就不在复述了，给出最终计算结果为：1 1 0 1 0 0 1 0 1 1 0 0 0 1 0，接下来就是如何通过经度与纬度的01字串，编码成相应的字母+数字的组合。 将经度与纬度的01字串进行合并，合并方法为：基数为放纬度，偶数位放经度，如下表： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 1 0 1 1 1 0 0 0 1 1 0 0 1 0 0 1 1 0 1 0 0 1 0 1 1 0 0 0 1 0 1 1 0 1 1 0 1 1 1 0 0 0 0 1 0 0 1 1 1 1 0 0 0 0 1 0 0 1 0 0 最终字串为：11011, 01110, 00010, 01111, 00001, 00100 将字串转换成十进制，得到：27, 14, 2, 15, 1, 4 对应base32编码表，如下： 数字 字符 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 b 11 c 12 d 13 e 14 f 15 g 16 h 17 j 18 k 19 m 20 n 21 p 22 q 23 r 24 s 25 t 26 u 27 v 28 w 29 x 30 y 31 z 最终得出（116.389550， 39.928167）所在区块为：VF2G14(可能有计算错误，不要在意这些细节) 这就是我们如何通过位置点，计算出位置所在区块的原理了。 3. 计算精度问题 通过上面的计算可以看到，循环计算15次才获得6位geohash字串，那6位geohash的精度是多少呢？如下表： geohash长度 纬度位数 经度位数 纬度误差 经度误差 距离误差（km） 1 2 3 ± 23 ± 23 ± 2500 2 5 5 ± 2.8 ± 56 ± 630 3 7 8 ± 0.7 ± 0.7 ± 78 4 10 10 ± 0.087 ± 0.18 ± 20 5 12 13 ± 0.022 ± 0.022 ± 2.4 6 15 15 ± 0.0027 ± 0.0055 ± 0.61 7 17 18 ± 0.00068 ± 0.00068 ± 0.076 8 20 20 ± 0.000086 ± 0.000172 ± 0.01911 9 22 23 ± 0.000021 ± 0.000021 ± 0.00478 10 25 25 ± 0.00000268 ± 0.00000536 ± 0.0005971 11 27 28 ± 0.00000067 ± 0.00000067 ± 0.0001492 12 30 30 ± 0,00000008 ± 0.00000017 ± 0.0000186 可以看出geohash的长度达到6个字符的误差是610m，长度达到8以上时精度已经达到了10m级。 但是当前民用领域定位系统的定位误差都在10m以上，如果在城区由于高楼、大树等影响定位系统型号，所以误差可以达到50m（不要看到导航软件那么准就认为没有误差，其实那是经过了强大的数据修正）。所以通过geohash定位附近的人时，8位已经是极限了，定位系统的精度导致再高的精度已经没有了意义。 总结 以上已经把附近的人找寻原理、定位算法原理都梳理了一遍，是不是觉得自己可以出门去寻找那个附近的人了。 当前移动设备非常发达，每一个智能手机中几乎都会安装GPS或者北斗芯片，而且GPS与北斗系统一直在不断升级，定位的精度也越来越高。这样附近的人算法精度也就越来越高。同时设备提供的API也非常容易使用，也为基于位置的服务变得（LBS）非常发达。相信通过原理的讲解能让大家更为了解隐藏在底层的东西。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/02/12/f3741734e2f95cca8659654a87902643.html","headline":"揭秘你所看不见的技术原理 - 附近的人","dateModified":"2018-02-12T00:00:00+08:00","datePublished":"2018-02-12T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/02/12/f3741734e2f95cca8659654a87902643.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>揭秘你所看不见的技术原理 - 附近的人</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="摘要">摘要</h1> 
  <hr> 
  <p>相信很多朋友都用到过微信附近的人功能，这个神奇的功能让陌生人能成为朋友、聊友、饭友，甚至能帮助一些朋友解决自身的一些生理需求。点开附近的人，就能显示附近的人甚至是附近的异性，真是一级棒。 <br> 但是大家在使用这个功能时有没有想过技术方面的实现原理呢？系统是如何在我们点开附近的人时，帮我们选出附近的人，同时还能计算出距离。接下来我们就来揭秘附近的人这个技术魔法。</p> 
  <h1 id="定位原理">定位原理</h1> 
  <hr> 
  <p>说到定位其实是离不开定位系统，例如GPS与北斗系统等。这些系统能提供给我们位置信息，也就是我们所处的经纬度。理想状态下，我们拿到经纬度后就能依据每一个用户的经纬度来计算附近的人了。那事实是不是这样呢？ <br> 当然不是，如果是这样我这篇文章也就没必要写了，技术点门槛也太低了。那为何不能这么做？其实原因很简单，像微信这种用户动不动就过亿的app，如果每一次定位都依据用户原始的经纬度来计算，运算量实在是太大了。首先要计算与亿级用户的距离，然后依据距离排序。要是没有计算机，我们每分钟能计算3个人，每小时能计算180人，每天计算4320人，每年计算1,576,900，这辈子也算不完了，就算计算机能帮助我们提高10万倍的计算速度，这么多人也要算半个小时。 <br> 但是有没有发现，我们打开附件的人可能两秒钟就把附件的用户筛选出来了。这么快的速度肯定不是计算所有的经纬度。其实是有一套计算原理的。</p> 
  <h2 id="1-对着地图画格子">1. 对着地图画格子</h2> 
  <p>对于定位系统来说，我们的地球是被一个一个格子构成的，而每一个格子包含着一定的区域。我们拿北京城区为例，在画格子之前是： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180211110817389?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3MjEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 将地图放入定位系统后，城区就不再是这个样子了，而是被分割成若干个格子，每一个格子都有格子的“名字”： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018021111144325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3MjEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 至于如何定义每一块的名称，后续章节-geohash算法会具体提及，这里不再复述。</p> 
  <h2 id="2-找到你所在的格子">2. 找到你所在的格子</h2> 
  <p>定义了格子的名称，当然就有他的用处了，不然这不是白白定义了吗。其实在打开微信附近的人时，系统也会把设备的位置信息给记录，这时候系统依据设备的位置信息，通过geohash算法，计算出所在块名称。比如我们在天安门广场时，系统的计算名称可能是“EFACMDH”，名称有多少个字母主要看系统要求的定位精度最高为多少。我们发现设备位置名称的前5个字母是“EFACM”，正好是在地图中正中间的格子中，也就是包含了天安门的格子。但是设备位置名称后面还包含了“DH”，这说明当前格子包含的位置还不够详细，还不能说明设备所在更为精确的位置。因此我们还需要将格子更为细分，将“EFACM”格子放大，为下图： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180211113435888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3MjEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 这个范围内的所有格子前5个字符都是“EFACM”，但是都出现了第六个字符，而且第六个字符不同，其实就是因为这些位置范围都在“EFACM”中，只是对“EFACM”放大细分的结果。 <br> 而设备的位置信息为“EFACMDH”，也就是当前的位置范围任然不够精确，还需要继续细分，因此我们找出前六个字符为“EFACMD”的格子，再细分，如下图： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180211134928533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3MjEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 依据设备的位置编码，我们找出了设备所处的位置在红色框内，这时候我们把设备的位置信息记录在“EFACMDH”框内： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180211134940421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3MjEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 这样就将地图画成了格子，并且将设备的位置也记录在的相应的格子中。</p> 
  <h2 id="3-小结">3. 小结</h2> 
  <p>整个定位，其实就是不断地进行着地图区域细化过程，我们依据系统设计的最高经度，计算出设备经纬度所在的区块名称，并将设备与经纬度记录在区块中，如下图： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018021114235085?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3MjEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 接下来就是通过区块名称，将附件的人揪出来了。</p> 
  <h1 id="揪出附近的人">揪出附近的人</h1> 
  <hr> 
  <p>上面这些区块与名称，作为用户的我们是看不到也不关心的，我们关心的是附近的人是如何选出来并展现在设备中。</p> 
  <h2 id="1-揪出第一批人">1. 揪出第一批人</h2> 
  <p>什么叫做第一批人，其实就像是微信中第一批大约展示20个人，这20人是离我们最近的20人，为了选出这20位好汉，系统进行了如下步骤： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180211144234227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3MjEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <ul> 
   <li>找出所有在设备（浅蓝色点）所在的区块“EFACMDH”中的全部设备（蓝黑色的点）；</li> 
   <li>依据浅蓝色点与所有蓝黑色点的经纬度，计算出亮点之间的距离（这个网上有教程，很容易算），并对两点距离进行排序；</li> 
   <li>读取蓝黑色所有点的用户信息（头像、名称、微信号等等）；</li> 
   <li>按距离有小到大发送给设备并显示在附近的人中。</li> 
  </ul> 
  <p>通过这些步骤，系统既获得了附近人的位置，又获得了用户信息、与当前设备距离等信息。所以说不只是显示距离，甚至附近的人在哪里都可以查询到，只是可能涉及到了用户隐私，不提供这项功能而已。</p> 
  <h2 id="2-还想看其他人">2. 还想看其他人</h2> 
  <p>当“EFACMDH”区块记录的用户小于20名，或者用户还想查看更多的附近的人时，就需要扩大查询范围了。其实扩大查询范围无非就是减少一位名称，从查询“EFACMDH”变成查询“EFACMD”。流程如下： <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018021115011533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3MjEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <ul> 
   <li>将名称英文字母减少一位，由“EFACMDH”变成“EFACMD”；</li> 
   <li>查询区块名称类似于“EFACMD”的所有区块，例如“EFACMDHA”至“EFACMDY”区块，共同组成“EFACMDH”区块；</li> 
   <li>找出“EFACMD”的所有位置信息，并依据“1. 揪出第一批人”的方法获得排序后的用户信息</li> 
   <li>将用户信息回传给设备，并显示。</li> 
  </ul> 
  <p>扩大查询范围其实要比查询当前区块的消耗是要大一些的。因为需要将若干个小区块组合成一个大区块；同时还要进行区块名类似性匹配，比精确匹配的消耗是要高上不少的。这就是为何查询附近的人时，都是先显示少数最近的一些人。</p> 
  <h2 id="3-小结-1">3. 小结</h2> 
  <p>知道了附近的人查询原理，是不是觉得原来实现这么简单。其实中间还设计一些hash匹配、数据存储等，只是这些过于技术，与业务联系不紧密，这里也就没必要过深入地研究了。有兴趣的同学可以查阅redis数据库的geohash模块。</p> 
  <h1 id="geohash算法">geohash算法</h1> 
  <hr> 
  <p>本章节与附近人业务关系不大了，而且内容偏技术性，若不是技术方面的同学可以跳过了。</p> 
  <h2 id="1-geohash简单原理">1. geohash简单原理</h2> 
  <p>上面已经把如何查找附近的人技术原理梳理了一遍，但是留下了一个问题是每一个区块都有一个名字，这个名字是如何来的？接下来将揭晓这个谜团。 <br> 为了方便提取位置信息，人为地把地球划分了经度与纬度，依据经纬度，又可以画一些经纬度参考线。犹如地球仪中，人为地划分了若干条经度线与纬度线，依据这些参考线我们可以知道某一些位置在参考线以东或者以西、以南或者以北，从而估算出大概的经度纬度。 <br> geohash算法就是依据这个原理，算法思路就是对参考线进行不断细分，判断当前位置是在参考线以东（右）或者参考线以西（左），以东用1来标记，以西用0来标记，最后组成一个01串，再依据01串按照一定的编码格式转换成容易辨认的英文字符+数字的组合。</p> 
  <h2 id="2-geohash计算过程">2. geohash计算过程</h2> 
  <p>依据上述原理，接下来详细介绍一下geohash的计算过程，这里拿经纬度（116.389550， 39.928167）进行算法说明。</p> 
  <h3 id="a-纬度计算">a. 纬度计算</h3> 
  <p>中学学过的地理知识知道，地球分为南纬与北纬，分别都是0~90°，但是在计算机中，用文字定义南纬与北纬较为麻烦，所以计算机中用区间定义[-90,0)与[0,90]分为南北纬，同时叫做左右区间。区分了左右区间，接下来就是整个计算过程：</p> 
  <ul> 
   <li>判断当前纬度39.928167是在左区间还是右区间，发现是在右区间[0,90]中，在右区间标识为1；</li> 
   <li>接着将区间[0,90]进行左右区间二分，二分后为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，标记为0；</li> 
   <li>不断重复上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167；</li> 
   <li>依据最大精度，定义一个最大重复次数，这里我们定义为15，这样就能得出一个01字串；</li> 
  </ul> 
  <table> 
   <thead> 
    <tr> 
     <th>重复数</th> 
     <th align="center">纬度范围</th> 
     <th align="right">左区间</th> 
     <th>右区间</th> 
     <th>39.928167</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>1</td> 
     <td align="center">[-90.0, 90.0]</td> 
     <td align="right">[-90.0, 0.0)</td> 
     <td>[0.0, 90.0]</td> 
     <td>1</td> 
    </tr> 
    <tr> 
     <td>2</td> 
     <td align="center">[0, 90.0]</td> 
     <td align="right">[0.0, 45.0)</td> 
     <td>[45.0, 90]</td> 
     <td>0</td> 
    </tr> 
    <tr> 
     <td>3</td> 
     <td align="center">[0.0, 45.0)</td> 
     <td align="right">[0.0, 22.5)</td> 
     <td>[22.5, 45.0)</td> 
     <td>1</td> 
    </tr> 
    <tr> 
     <td>4</td> 
     <td align="center">[22.5, 45.0]</td> 
     <td align="right">[22.5, 33.75)</td> 
     <td>[33.75, 45.0]</td> 
     <td>1</td> 
    </tr> 
    <tr> 
     <td>5</td> 
     <td align="center">[33.75, 45.0]</td> 
     <td align="right">[33.75, 39.375)</td> 
     <td>[39.375, 45.0]</td> 
     <td>1</td> 
    </tr> 
    <tr> 
     <td>6</td> 
     <td align="center">[39.375, 45.0]</td> 
     <td align="right">[39.375, 42.1875)</td> 
     <td>[42.1875, 45.0]</td> 
     <td>0</td> 
    </tr> 
    <tr> 
     <td>7</td> 
     <td align="center">[39.375, 42.1875)</td> 
     <td align="right">[39.375, 40.7812)</td> 
     <td>[40.7812, 42.1875)</td> 
     <td>0</td> 
    </tr> 
    <tr> 
     <td>8</td> 
     <td align="center">[39.375, 40.7812)</td> 
     <td align="right">[39.375, 40.0781)</td> 
     <td>[40.0781, 40.7812)</td> 
     <td>0</td> 
    </tr> 
    <tr> 
     <td>9</td> 
     <td align="center">[39.375, 40.0781)</td> 
     <td align="right">[39.375, 39.7265)</td> 
     <td>[39.7265, 40.0781)</td> 
     <td>1</td> 
    </tr> 
    <tr> 
     <td>10</td> 
     <td align="center">[39.7265, 40.0781)</td> 
     <td align="right">[39.7265, 39.9023)</td> 
     <td>[39.9023, 40.0781)</td> 
     <td>1</td> 
    </tr> 
    <tr> 
     <td>11</td> 
     <td align="center">[39.9023, 40.0781)</td> 
     <td align="right">[39.9023, 39.9902)</td> 
     <td>[39.9902, 40.0781)</td> 
     <td>0</td> 
    </tr> 
    <tr> 
     <td>12</td> 
     <td align="center">[39.9023, 39.9902)</td> 
     <td align="right">[39.9023, 39.9462)</td> 
     <td>[39.9462, 39.9902)</td> 
     <td>0</td> 
    </tr> 
    <tr> 
     <td>13</td> 
     <td align="center">[39.9023, 39.9462)</td> 
     <td align="right">[39.9023, 39.9243)</td> 
     <td>[39.9243, 39.9462)</td> 
     <td>1</td> 
    </tr> 
    <tr> 
     <td>14</td> 
     <td align="center">[39.9243, 39.9462)</td> 
     <td align="right">[39.9243, 39.9353)</td> 
     <td>[39.9353, 39.9462)</td> 
     <td>0</td> 
    </tr> 
    <tr> 
     <td>15</td> 
     <td align="center">[39.9243, 39.9353)</td> 
     <td align="right">[39.9243, 39.9298)</td> 
     <td>[39.9298, 39.9353)</td> 
     <td>0</td> 
    </tr> 
   </tbody>
  </table> 
  <ul> 
   <li>纬度最终得到的01字串为：1 0 1 1 1 0 0 0 1 1 0 0 1 0 0</li> 
  </ul> 
  <h3 id="b-全局计算">b. 全局计算</h3> 
  <p>经度计算与纬度计算类似，也是依据区间划分，左右判断来进行，这里就不在复述了，给出最终计算结果为：1 1 0 1 0 0 1 0 1 1 0 0 0 1 0，接下来就是如何通过经度与纬度的01字串，编码成相应的字母+数字的组合。</p> 
  <ul> 
   <li>将经度与纬度的01字串进行合并，合并方法为：<strong>基数为放纬度，偶数位放经度</strong>，如下表：</li> 
  </ul> 
  <table> 
   <thead> 
    <tr> 
     <th>1</th> 
     <th align="center">2</th> 
     <th align="right">3</th> 
     <th>4</th> 
     <th>5</th> 
     <th>6</th> 
     <th>7</th> 
     <th>8</th> 
     <th>9</th> 
     <th>10</th> 
     <th>11</th> 
     <th>12</th> 
     <th>13</th> 
     <th>14</th> 
     <th>15</th> 
     <th>16</th> 
     <th>17</th> 
     <th>18</th> 
     <th>19</th> 
     <th>20</th> 
     <th>21</th> 
     <th>22</th> 
     <th>23</th> 
     <th>24</th> 
     <th>25</th> 
     <th>26</th> 
     <th>27</th> 
     <th>28</th> 
     <th>29</th> 
     <th>30</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>1</td> 
     <td align="center"></td> 
     <td align="right">0</td> 
     <td></td> 
     <td>1</td> 
     <td></td> 
     <td>1</td> 
     <td></td> 
     <td>1</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>1</td> 
     <td></td> 
     <td>1</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>1</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
    </tr> 
    <tr> 
     <td></td> 
     <td align="center">1</td> 
     <td align="right"></td> 
     <td>1</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>1</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>1</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>1</td> 
     <td></td> 
     <td>1</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>0</td> 
     <td></td> 
     <td>1</td> 
     <td></td> 
     <td>0</td> 
    </tr> 
    <tr> 
     <td>1</td> 
     <td align="center">1</td> 
     <td align="right">0</td> 
     <td>1</td> 
     <td>1</td> 
     <td>0</td> 
     <td>1</td> 
     <td>1</td> 
     <td>1</td> 
     <td>0</td> 
     <td>0</td> 
     <td>0</td> 
     <td>0</td> 
     <td>1</td> 
     <td>0</td> 
     <td>0</td> 
     <td>1</td> 
     <td>1</td> 
     <td>1</td> 
     <td>1</td> 
     <td>0</td> 
     <td>0</td> 
     <td>0</td> 
     <td>0</td> 
     <td>1</td> 
     <td>0</td> 
     <td>0</td> 
     <td>1</td> 
     <td>0</td> 
     <td>0</td> 
    </tr> 
   </tbody>
  </table> 
  <ul> 
   <li>最终字串为：11011, 01110, 00010, 01111, 00001, 00100 </li> 
   <li>将字串转换成十进制，得到：27, 14, 2, 15, 1, 4</li> 
   <li>对应base32编码表，如下：</li> 
  </ul> 
  <table> 
   <thead> 
    <tr> 
     <th>数字</th> 
     <th align="center">字符</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>0</td> 
     <td align="center">0</td> 
    </tr> 
    <tr> 
     <td>1</td> 
     <td align="center">1</td> 
    </tr> 
    <tr> 
     <td>2</td> 
     <td align="center">2</td> 
    </tr> 
    <tr> 
     <td>3</td> 
     <td align="center">3</td> 
    </tr> 
    <tr> 
     <td>4</td> 
     <td align="center">4</td> 
    </tr> 
    <tr> 
     <td>5</td> 
     <td align="center">5</td> 
    </tr> 
    <tr> 
     <td>6</td> 
     <td align="center">6</td> 
    </tr> 
    <tr> 
     <td>7</td> 
     <td align="center">7</td> 
    </tr> 
    <tr> 
     <td>8</td> 
     <td align="center">8</td> 
    </tr> 
    <tr> 
     <td>9</td> 
     <td align="center">9</td> 
    </tr> 
    <tr> 
     <td>10</td> 
     <td align="center">b</td> 
    </tr> 
    <tr> 
     <td>11</td> 
     <td align="center">c</td> 
    </tr> 
    <tr> 
     <td>12</td> 
     <td align="center">d</td> 
    </tr> 
    <tr> 
     <td>13</td> 
     <td align="center">e</td> 
    </tr> 
    <tr> 
     <td>14</td> 
     <td align="center">f</td> 
    </tr> 
    <tr> 
     <td>15</td> 
     <td align="center">g</td> 
    </tr> 
    <tr> 
     <td>16</td> 
     <td align="center">h</td> 
    </tr> 
    <tr> 
     <td>17</td> 
     <td align="center">j</td> 
    </tr> 
    <tr> 
     <td>18</td> 
     <td align="center">k</td> 
    </tr> 
    <tr> 
     <td>19</td> 
     <td align="center">m</td> 
    </tr> 
    <tr> 
     <td>20</td> 
     <td align="center">n</td> 
    </tr> 
    <tr> 
     <td>21</td> 
     <td align="center">p</td> 
    </tr> 
    <tr> 
     <td>22</td> 
     <td align="center">q</td> 
    </tr> 
    <tr> 
     <td>23</td> 
     <td align="center">r</td> 
    </tr> 
    <tr> 
     <td>24</td> 
     <td align="center">s</td> 
    </tr> 
    <tr> 
     <td>25</td> 
     <td align="center">t</td> 
    </tr> 
    <tr> 
     <td>26</td> 
     <td align="center">u</td> 
    </tr> 
    <tr> 
     <td>27</td> 
     <td align="center">v</td> 
    </tr> 
    <tr> 
     <td>28</td> 
     <td align="center">w</td> 
    </tr> 
    <tr> 
     <td>29</td> 
     <td align="center">x</td> 
    </tr> 
    <tr> 
     <td>30</td> 
     <td align="center">y</td> 
    </tr> 
    <tr> 
     <td>31</td> 
     <td align="center">z</td> 
    </tr> 
   </tbody>
  </table> 
  <ul> 
   <li>最终得出（116.389550， 39.928167）所在区块为：VF2G14(可能有计算错误，不要在意这些细节)</li> 
  </ul> 
  <p>这就是我们如何通过位置点，计算出位置所在区块的原理了。</p> 
  <h1 id="3-计算精度问题">3. 计算精度问题</h1> 
  <p>通过上面的计算可以看到，循环计算15次才获得6位geohash字串，那6位geohash的精度是多少呢？如下表：</p> 
  <table> 
   <thead> 
    <tr> 
     <th>geohash长度</th> 
     <th align="center">纬度位数</th> 
     <th align="right">经度位数</th> 
     <th>纬度误差</th> 
     <th>经度误差</th> 
     <th>距离误差（km）</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td>1</td> 
     <td align="center">2</td> 
     <td align="right">3</td> 
     <td>± 23</td> 
     <td>± 23</td> 
     <td>± 2500</td> 
    </tr> 
    <tr> 
     <td>2</td> 
     <td align="center">5</td> 
     <td align="right">5</td> 
     <td>± 2.8</td> 
     <td>± 56</td> 
     <td>± 630</td> 
    </tr> 
    <tr> 
     <td>3</td> 
     <td align="center">7</td> 
     <td align="right">8</td> 
     <td>± 0.7</td> 
     <td>± 0.7</td> 
     <td>± 78</td> 
    </tr> 
    <tr> 
     <td>4</td> 
     <td align="center">10</td> 
     <td align="right">10</td> 
     <td>± 0.087</td> 
     <td>± 0.18</td> 
     <td>± 20</td> 
    </tr> 
    <tr> 
     <td>5</td> 
     <td align="center">12</td> 
     <td align="right">13</td> 
     <td>± 0.022</td> 
     <td>± 0.022</td> 
     <td>± 2.4</td> 
    </tr> 
    <tr> 
     <td>6</td> 
     <td align="center">15</td> 
     <td align="right">15</td> 
     <td>± 0.0027</td> 
     <td>± 0.0055</td> 
     <td>± 0.61</td> 
    </tr> 
    <tr> 
     <td>7</td> 
     <td align="center">17</td> 
     <td align="right">18</td> 
     <td>± 0.00068</td> 
     <td>± 0.00068</td> 
     <td>± 0.076</td> 
    </tr> 
    <tr> 
     <td>8</td> 
     <td align="center">20</td> 
     <td align="right">20</td> 
     <td>± 0.000086</td> 
     <td>± 0.000172</td> 
     <td>± 0.01911</td> 
    </tr> 
    <tr> 
     <td>9</td> 
     <td align="center">22</td> 
     <td align="right">23</td> 
     <td>± 0.000021</td> 
     <td>± 0.000021</td> 
     <td>± 0.00478</td> 
    </tr> 
    <tr> 
     <td>10</td> 
     <td align="center">25</td> 
     <td align="right">25</td> 
     <td>± 0.00000268</td> 
     <td>± 0.00000536</td> 
     <td>± 0.0005971</td> 
    </tr> 
    <tr> 
     <td>11</td> 
     <td align="center">27</td> 
     <td align="right">28</td> 
     <td>± 0.00000067</td> 
     <td>± 0.00000067</td> 
     <td>± 0.0001492</td> 
    </tr> 
    <tr> 
     <td>12</td> 
     <td align="center">30</td> 
     <td align="right">30</td> 
     <td>± 0,00000008</td> 
     <td>± 0.00000017</td> 
     <td>± 0.0000186</td> 
    </tr> 
   </tbody>
  </table> 
  <p>可以看出geohash的长度达到6个字符的误差是610m，长度达到8以上时精度已经达到了10m级。 <br> 但是当前民用领域定位系统的定位误差都在10m以上，如果在城区由于高楼、大树等影响定位系统型号，所以误差可以达到50m（不要看到导航软件那么准就认为没有误差，其实那是经过了强大的数据修正）。所以通过geohash定位附近的人时，8位已经是极限了，定位系统的精度导致再高的精度已经没有了意义。</p> 
  <h1 id="总结">总结</h1> 
  <hr> 
  <p>以上已经把附近的人找寻原理、定位算法原理都梳理了一遍，是不是觉得自己可以出门去寻找那个附近的人了。 <br> 当前移动设备非常发达，每一个智能手机中几乎都会安装GPS或者北斗芯片，而且GPS与北斗系统一直在不断升级，定位的精度也越来越高。这样附近的人算法精度也就越来越高。同时设备提供的API也非常容易使用，也为基于位置的服务变得（LBS）非常发达。相信通过原理的讲解能让大家更为了解隐藏在底层的东西。</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wzw212/article/details/79308798,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wzw212/article/details/79308798,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
