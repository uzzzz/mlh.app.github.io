<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>听说懂以太坊开发的程序员都被抢疯了！分享一篇价值10万的文章，来自10年经验的大咖对以太坊数据存储的思考与解读 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="听说懂以太坊开发的程序员都被抢疯了！分享一篇价值10万的文章，来自10年经验的大咖对以太坊数据存储的思考与解读" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文从存储结构的角度，解读以太坊的智能合约和账户数据模型的编码实现方案。借助这些实现方案的解读，可以对以太坊的数据模型、存储结构、编码方式、共识原理等知识有更加深入的了解，对基于以太坊的开发实施和问题定位有一定借鉴作用。&nbsp;﻿ &nbsp; 打开拉勾网，输入区块链工程师一职，月薪平均在30K左右。 但无论什么公司，无论什么岗位，无一例外有这么一句“熟悉以太坊区块链技术原理、机制的优先”。如今，会以太坊开发技术的程序员，俨然成为各大公司争抢的宝贝，而如果技术出众，更是被高薪团团围住。 而你呢，看了那么多以太坊相关资料，能实操能实战，凝结了资深大咖思考与经验精华的又有多少？看完了还是一头雾水，一脸困惑。 本篇文章就是为你的困惑而准备的。作者邓福喜主要从事区块链底层技术平台的设计与研发工作，有10多年的开发经验，他的经验与思考，是一份价值10万的知识大餐，以下，希望对你有所帮助。 以太坊作为公开区块链技术平台，因为其良好的扩展性和灵活度，有很强的业务适用场景，这主要归功于其图灵完备的虚拟机与其上运行的智能合约。以太坊通过特定的编码方式实现对智能合约与账户数据的编码存储，同时又能在其数据基础上实现对区块与交易执行结果的完备共识证明。以下分几个部分来详细阐述。 &nbsp; 以太坊RLP编码 RLP（Recursive Length Prefix）编码是以太坊中数据序列化的一个主要编码方式，可以将任意的嵌套二进制数据进行序列化。以太坊中针对RLP的编码规则定义如下： &nbsp; 1. 如果是一个单字节并且其值在[0x00,0x7f]范围内，RLP编码就是自身。 &nbsp; 2. 否则，如果一个数据串的字节长度是0-55字节，那么它的RLP编码是在数据串开头增加一个字节，这个字节的值是0x80加上数据串的字节长度。因此增加的该字节的取值范围为[0x80, 0xb7]。 &nbsp; 3. 如果一个数据串的字节长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xb7加上数据串字节长度的二进制编码的字节长度，然后依次跟着数据串字节长度部分和内容部分。比如：一个长度为1024字节的数据串，其字节长度用16进制表示为0x0400，长度为2个字节，因此RLP编码头字节的值为0xb9（0xb7 + 0x02），然后跟着两字节为0x0400，后面再加上数据串的具体内容。因此增加的首字节的取值范围为[0xb8, 0xbf]，因此其能编码的最大数据长度为2^56。 &nbsp; 4. 如果是一个嵌套的列表数据，则需要先将列表中的数据按照单元素的编码规则进行RLP编码后串联得到列表数据的payload。如果一个列表数据的payload的字节长度为0-55，那么列表的RLP编码在其payload前加上一个字节，这个字节的值是0xc0加上payload的字节长度。因此首字节的取值范围为[0xc0, 0xf7]。 &nbsp; 5. 如果一个列表数据的payload的长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xf7加上列表payload字节长度的二进制编码的字节长度，然后依次跟着payload字节长度部分和payload部分。因此首字节的取值范围为[0xf8, 0xff]，因此一个列表中存储的所有元素的字节长度不能超过2^56。 &nbsp; 如下是一些RLP编码的参考样例。 &nbsp; 表1 &nbsp;RLP编码样例 &nbsp; 以太坊MPT MPT（Merkle Patricia Tree）是以太坊用来将Key-Value进行紧凑编码的一种数据组织形式。基于该数据组织形式，MPT上任何存储数据的细微变化都会导致MPT的根节点发生变更，因此可以校验数据的一致性。 &nbsp; 在MPT中，存在如下三类节点。 &nbsp; 1. 叶子节点：用于数据存储的节点。其Key值是一个对应插入数据的特殊16进制编码（需要剔除掉从根节点到当前叶子节点的前缀部分内容），Value值对应插入数据的RLP编码。 &nbsp; 2. 扩展节点：扩展节点用来处理具有共同前缀的数据，通过扩展节点可以扩展出一个多分叉的分支节点。其Key值存储的是共同的前缀部分的16进制，Value值存储的是扩展出的分支节点的hash值（sha3（RLP（分支节点数据List）））。 &nbsp; 3. 分支节点：由于MPT存储的Key是16进制的编码数据，那么在不具备共同前缀时就通过分支节点进行分叉。分支节点的key是一个16个数据的数组，数组的下标对应16进制的0-F，用来扩展不同的数据。 &nbsp; 数组中存储的的是分叉节点的hash值，同时数组的下标也对应一个数据的一个16进制位（4bit）。分支节点的Value一般为空，如果有数据的Key值在其上的扩展节点终止，那么数据Key对应的Value值则存储在分支节点的Value属性上。 &nbsp; 扩展节点和叶子节点的Key值前面存在一个4bit或者8bit nibble，用来标示节点类型和后续的数据长度的奇偶性（原始数据Key值16进制后长度为偶数，但是经过扩展节点和分支节点的前缀剔除后剩下的长度可能是奇数，也可能为偶数）。 表2 Nibble取值含义 &nbsp; 如下是一个样例数据的MPT形象化表示： &nbsp; ﻿ 图1 &nbsp;MPT样例结构 &nbsp; 该图中蓝色标注的为分支节点；橙色标注的为扩展节点；绿色标注的为叶子节点。 &nbsp; 上述样例结构中存储的是如下的Key-Value原始数据： &nbsp; 表 3 原始样例数据 &nbsp; 在MPT树上节点存储的数据是原始数据的如下映射： &nbsp; Key = sha3(原始数据key) &nbsp; Value = RLP(原始数据Value) &nbsp; 因此在上述样例MPT中，存储的节点数据为如下表格所示： &nbsp; ﻿ 表4 &nbsp;MPT节点数据 &nbsp; 上述数据的插入过程如下： &nbsp; a. 插入[“00000000000000000000000000000022”, 22] &nbsp; 1. 将key值进行sha3求hash值得到0x8B2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30，将value计算RLP得到0x16 &nbsp; 2. 由于当前没有任何节点，则直接生成一个新的叶子节点，将该节点作为根节点。由于MPT key值长度为偶数，所以在MPT key值前增加16进制nibble值20，得到的树如下： &nbsp; &nbsp; 图2 &nbsp;One Node &nbsp; b. 插入[“00000000000000000000000000000023”, 23] &nbsp; 1. 将key值进行sha3求hash值得到0x5976CAE7AF706E65E5272E8C98FB867F1801F3408562AA73D259A27CAC334D78，将value计算RLP得到0x17。 &nbsp; 2. 当前树只有一个叶子节点，并且两个key的hash值没有公共前缀（一个以8开头，一个以5开头），因此增加一个分支节点用以扩展不同前缀的节点，并且构造两个新的叶子节点挂在分支节点下面。 &nbsp; 3. 将上述value为22的key值hash取16进制的首位得到8，那么将key值去掉1位得到0xB2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30，去掉1位后由于长度为奇数，那么增加16进制的nibble值3，得到新的叶子节点[0x3B2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30, 0x16] 。 &nbsp; 4. 将上述新得到的叶子节点作为RLP List进行编码，并计算hash值得到 0xDDCB61885A1C577BE083824D6761932FDCF0A496072A5932B021CD801F65076D，将得到的hash值填入父分支节点的第8位（原有hash值首字符为8）。 &nbsp; 5. 同理计算value为23的节点，得到新的叶子节点[0x3976CAE7AF706E65E5272E8C98FB867F1801F3408562AA73D259A27CAC334D78, 0x17]，并计算RLP编码的hash值0xB5BB9644C549233F9B3D462844E565AE9A5EF2D0687DB8739B3FEA5B1260FACF并填入父分支节点的第5位（原有hash值首字符为5）。 &nbsp; 6. 得到新的树结构如下： ﻿ ﻿ 图3 &nbsp;Two Nodes &nbsp; c. 插入[“00000000000000000000000000000024”, 24] &nbsp; 1. 按照相同的计算规则插入value为24的节点，由于没有共同的前缀，所以在分支节点第12位下增加一个新的叶子节点。 &nbsp; 2. 得到新的树结构如下：&nbsp; ﻿ ﻿ &nbsp; 图4 &nbsp;Three Nodes &nbsp; d. 插入[“00000000000000000000000000000025”, 25] &nbsp; 1. 按照相同的计算规则插入value为25的节点，由于没有共同的前缀，所以在分支节点第13位下增加一个新的叶子节点。 &nbsp; 2. 得到新的树结构如下： &nbsp; ﻿ ﻿ &nbsp; 图5 &nbsp;Four Nodes &nbsp; e. 插入[“00000000000000000000000000000026”, 26] &nbsp; 1. 将key值进行sha3求hash值得到0xC4D13FBA6CFB72A7455EB8EDF262434C55D24DC9674D58B4AE05A89EE83F9321，将value计算RLP得到0x1A。 &nbsp; 2. 根据hash值得首字符“C”查找根节点的插入点为分支节点的第12位，由于在第12位存在了相同的节点（value值为24），由于去掉首字符“C”后还存在共同的前缀“4”，则需要增加一个扩展节点用来存储共同前缀“4”，并且在扩展节点下增加一个分支节点用来扩展后续的不同部分。 &nbsp; 3. 将上述value为24的key值hash去掉共同的前缀“C4”并增加nibble后得到节点[0x3F06F103C7FB2579CFA08AF8536B03DE8DA3C677F9F2A6FB397CBD1A775273, 0x18]，求其节点RLP的hash值填入新增加分支节点的第11位（去掉共同前缀“C4”后的首字符为B）。 &nbsp; 4. 按照相同的计算规则构造value值为26的叶子节点[0x313FBA6CFB72A7455EB8EDF262434C55D24DC9674D58B4AE05A89EE83F9321, 0x1A]，求其节点RLP的hash值填入新增加分支节点的第13位（去掉共同前缀“C4”后的首字符为D）。 &nbsp; 5. 调整完上述两个叶子节点后，得到新的分支节点，并计算新的分支节点的RLP Hash值0xD7C0D0160345D3EF2F758D15598965BE1A2C71682995890C5341171EF72A54B2作为value值填入父扩展节点的value部分。 &nbsp; 6. 新增加的扩展节点保留共同的前缀“4”（剔除其父分支节点的共同部分“C”），并增加16进制nibble值1，得到其MPT key值为0x14。 &nbsp; 7. 计算新的扩展节点的RLP hash值0x7DADADF4464529492D2C475DA62C1F64FAAE150A7355E921E805CF82B5E90A69填入其父分支节点的第12位。 &nbsp; 8. 得到新的树结构如下： &nbsp; ﻿ ﻿ 图6 &nbsp;Five Nodes &nbsp; 上述过程是通过新增节点构建一个MPT的过程，存储数据的更新和删除逻辑就不在此累述，读者可以举一反三进行类推。需要注意的是任何数据的更新操作都需要先基于树的检索路径找到对应的节点进行更新，并且从该节点逐层向上调整检索路径上的所有节点直至根节点，中间有可能会涉及到节点类型的调整和节点的合并。 &nbsp; 以太坊合约存储规则 以太坊提供了一种图灵完备的虚拟机与智能合约编写规则。我们可以在智能合约中定义复杂的数据模型以及在该数据模型上执行的一系列函数操作。我们知道，以太坊是以Key-value的形式来存储数据的，那么智能合约的复杂数据结构是如何映射到这样的键值对上的呢？ &nbsp; 以太坊采用如下的编码规则来将数据结构定义和数据值映射成Key-Value： &nbsp; 1. 智能合约的任何结构都会被映射成[key, value]的形式，其中key和value均是无符号32字节的数据。 &nbsp; 2. 所有的存储成员按照成员定义位置从0开始索引编排，每次累加1，作为其对应的key值进行存储。Value为具体的成员属性值。 &nbsp; 3. 固定长度数据类型（例如：uint8、uint16、uint32、enum）Value按照32字节右对齐的原则。相邻的存储成员如果其长度不满足32字节，则会将Value进行压缩合并存储。例如如下的变量定义和数据取值： &nbsp; enum a = 1; &nbsp; uint8 b = 15; &nbsp; Key:0x00000000000000000000000000000000000 &nbsp; 00000000000000000000000000000 &nbsp; Valu0x00000000000000000000000000000000000 &nbsp; 000000000000000 &nbsp; 4. 可变长度数据类型（例如：string、bytes）按照左对齐的原则进行编码，如果其长度不大于31字节，则按照一条记录存储，该记录Value的最后一个字节存储其可变内容的实际长度，例如如下的变量定义和数据取值： &nbsp; string a = &quot;123&quot;; &nbsp; Key:0x0000000000000000000000000000000000 &nbsp; 000000000000000000000000000000 &nbsp; Value:0x31323300000000000000000000000000 &nbsp; 00000000000000000000000000000006 &nbsp; 5. 如果可变长度类型变量的数据内容长度超过31字节，则将会被拆分成多条记录进行存储。第一条记录的key值为其索引编号，Value值为其实际数据长度加1；然后将内容按照32字节拆分成多条记录，每条记录的key值为首条记录key值进行sha3后得到的hash值从0开始每次累加1得到，value值为拆分的内容部分。例如如下的变量定义和数据取值： &nbsp; string a = &quot;1234567890123456789012345678 &nbsp; 901234567890&quot;; &nbsp; Key1:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000000 &nbsp; Value1:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000000051 &nbsp; Key2:sha3(0x0000000000000000000000000000 &nbsp; 000000000000000000000000000000000000) &nbsp; Value2:0x3132333435363738393031323334353 &nbsp; 637383930313233343536373839303132 &nbsp; Key3:sha3(0x0000000000000000000000000000 &nbsp; 000000000000000000000000000000000000)+1 &nbsp; Value3:0x33343536373839300000000000000000 &nbsp; 00000000000000000000000000000000 &nbsp; 6. 针对结构体定义，可以看成将结构体扩展到结构变量定义位置的索引编号进行累加。例如如下的变量定义和数据取值： &nbsp; struct Data &nbsp; { &nbsp; string name; &nbsp; int age; &nbsp; } &nbsp; string a = &quot;1234567890&quot;; &nbsp; Data d; &nbsp; d.name = &quot;1234567890&quot;; &nbsp; d.age = 3224115; &nbsp; Key1:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000000 &nbsp; Value1:0x3132333435363738393031323334353 &nbsp; 637383930000000000000000000000014 &nbsp; Key2:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000001 &nbsp; Value2:0x313233343536373839303132333435 &nbsp; 3637383930000000000000000000000014 &nbsp; Key3:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000002 &nbsp; Value3:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000313233 &nbsp; 7. 针对数组定义，则需要扩展多条记录。第一条记录Key值为数组变量的索引，Value值为数组的元素个数。后续则根据数组的元素增加多条记录，每条记录的Key值在首条记录的Key值上做sha3得到hash值从0开始每次累加1，Value值为数组元素的对应值。例如如下的变量定义和数据取值： &nbsp; string[] cources; &nbsp; cources[0] = &quot;123&quot;; &nbsp; cources[1] = &quot;456&quot;; &nbsp; Key1:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000000000 &nbsp; Value1:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000000002 &nbsp; Key2:sha3(0x0000000000000000000000000000 &nbsp; 000000000000000000000000000000000000) &nbsp; Value2:0x3132330000000000000000000000000 &nbsp; 000000000000000000000000000000006 &nbsp; Key3:sha3(0x000000000000000000000000000 &nbsp; 0000000000000000000000000000000000000)+1 &nbsp; Value3:0x343536000000000000000000000000 &nbsp; 0000000000000000000000000000000006 &nbsp; 8. 针对Map数据定义，其key值则为map key值加上变量索引进行sha3取hash值。例如如下的变量定义和数据取值： &nbsp; string a; &nbsp; mapping(string =&gt; string) r; &nbsp; mapping(string =&gt; int) s; &nbsp; r[&quot;abc&quot;] = &quot;123&quot;; &nbsp; r[&quot;def&quot;] = &quot;123&quot;; &nbsp; s[&quot;abc&quot;] = 123; &nbsp; Key1:sha3(0x61626300000000000000000000000 &nbsp; 00000000000000000000000000000000000000001) &nbsp; Value1:0x313233000000000000000000000000000 &nbsp; 0000000000000000000000000000006 &nbsp; Key2:sha3(0x64656600000000000000000000000 &nbsp; 00000000000000000000000000000000000000001) &nbsp; Value2:0x3132330000000000000000000000000000 &nbsp; 000000000000000000000000000006 &nbsp; Key3:sha3(0x616263000000000000000000000000 &nbsp; 0000000000000000000000000000000000000002) &nbsp; Value3:0x00000000000000000000000000000000 &nbsp; 0000000000000000000000000000007b &nbsp; 以太坊账户结构 在以太坊中，账户信息以Key-Value的形式存储在区块链的数据库中，每个账户通过一个唯一的地址编码作为Key进行标示，Value存储该账户的相关属性、账户余额、合约代码标示、合约存储标示。其结构如下： ﻿ ﻿ 图7 &nbsp;账户结构 &nbsp; 1. Address：账户地址，与用户私钥唯一对应的一组20字节的数据串。 &nbsp; 2. Nonce：用户账户对应的的交易序列号，每次成功执行交易后累加1。 &nbsp; 3. Balance：用于账户对应的账户余额，以wei为单位（1 eth = 1018 wei）。 &nbsp; 4. StorageRoot：仅在合约账户上该属性有效，标示合约存储结构的MPT树根节点hash值。 &nbsp; 5. CodeHash：仅在合约账户上该属性有效，标示合约代码对应的Hash值。 &nbsp; 任何一个以太坊的账户都可以基于其地址在以太坊的数据库中按照MPT树的检索规则找到对应的一条账户存储记录。检索的Key值为账户地址的hash值，检索到的Value值是上述结构的一个RLP编码数据串，可以基于RLP的编码规则逆向解析出其对应的属性值。 &nbsp; 以太坊的数据库存储 以太坊用NoSQL数据库以Key-Value的形式存储所有的数据。针对账户数据结构，需要存储的数据主要包含智能合约的Storage和基本的账户信息。对应的存储规则如下： &nbsp; 1. 针对智能合约Storage，将数据按照编码规则映射成MPT，然后将MPT的所有节点的Key和Value构建一个RLP List编码作为数据库存储的Value值，将该Value值进行Sha3计算hash值作为数据库存储的Key值进行存储。 &nbsp; 2. 针对基本账户信息，将其对应智能合约Storage的MPT Root Hash保存于账户的StorageRoot属性，然后将系统中的所有Account构建一个MPT。按照和Storage的数据库存储方式将MPT的所有节点进行存储。 &nbsp; 上述构建的两个MPT树的结构如图8。 &nbsp; ﻿ 图8 &nbsp;Account &amp; Storage MPT 结论 以太坊的账户以Hash散列与RLP数据编码为基础，结合智能合约的数据对象映射和转换，将Key-Value的数据以MPT的方式进行组织，计算StorageRoot唯一证明并保存于账户模型。最终形成Storage和Account两种MPT，并将MPT的所有节点以Key-Value的形式存储于NoSQL数据库中。这样的编码存储方式可以快速的校验智能合约和账户数据是否发生了变更，进而只需要对比MPT根节点的差异就可以快速校验区块链上分布式节点数据的一致性。 &nbsp; 后记 在深刻理解了以太坊的存储模型和原理机制后，可以在某些方面扩展以太坊的能力实现更加丰富的功能集。例如： &nbsp; 1. 实现可视化的工具，完成对以太坊LevelDB数据库的数据解析和呈现。借助智能合约的存储定义，结合账户的StorageRoot遍历LevelDB数据库中的Key-Value键值对，根据编码规则实现数据逆向分析和展示，为DApp应用的开发调试提供更加方便快捷的数据操作。 &nbsp; 2. 智能合约的升级一直是一件令开发者颇为头疼的事情，如何保证在完成智能合约的缺陷升级后还能维系访问原有的留存数据就是一个切实的痛点。借助对智能合约的存储机制，可以考虑在以太坊中扩展功能，支持智能合约的升级，并将原有的智能合约StorageRoot迁移复制给升级后的智能合约账户。在满足特定的数据定义要求下，可以达到智能合约升级后的数据平滑迁移效果。 &nbsp; 3. 以太坊的数据存储方案并不是最完美的解决方案，因为MPT的特性，海量数据存储账户的更新操作会带来指数级的数据存取，这样会让以太坊的智能合约执行变得非常低效。是否存在可能的解决方案，将海量的数据存储脱离MPT的方式的，提升数据存取的效率，是值得思考的一个问题。 &nbsp; 上述的内容只是在以太坊数据存储模型上的简单思考和一些引子，起到抛砖引玉的效果。希望读者能有更新颖的想法和灵感。 &nbsp; 作者简介：邓福喜，矩阵元技术（深圳）有限公司的系统架构师。作者在分布式系统和互联网应用的架构设计与研发方面有10多年的从业经验，目前主要从事区块链底层技术平台的设计与研发工作，邮箱dengfuxi@juzix.io。 本文首发《程序员》 热门文章 区块链：诞生于草根的时尚 孟岩：我反对将Token翻译成“代币” “矿工”年入千万成历史，强监管下比特币还能走多远？ 深度解析区块链架构、跨链和演进 人才稀缺的区块链，程序员转型入门必看这四项技能 对话元道：通证经济需要“互链网”，“互链网”需要细腰 今天，这几位区块链大咖旗帜鲜明地亮出“通证派”，原来这才是他们期盼中的未来交易的模样... 与元道对话三：区块链经济正在进行“动力切换” 锐评：泡沫中的token和被冷落的联盟链 对话元道二：通证视角下的区块链创新路线 听听Vitalik对token设计的看法 了解更多区块链技术及应用内容，敬请关注： 阅读更多" />
<meta property="og:description" content="本文从存储结构的角度，解读以太坊的智能合约和账户数据模型的编码实现方案。借助这些实现方案的解读，可以对以太坊的数据模型、存储结构、编码方式、共识原理等知识有更加深入的了解，对基于以太坊的开发实施和问题定位有一定借鉴作用。&nbsp;﻿ &nbsp; 打开拉勾网，输入区块链工程师一职，月薪平均在30K左右。 但无论什么公司，无论什么岗位，无一例外有这么一句“熟悉以太坊区块链技术原理、机制的优先”。如今，会以太坊开发技术的程序员，俨然成为各大公司争抢的宝贝，而如果技术出众，更是被高薪团团围住。 而你呢，看了那么多以太坊相关资料，能实操能实战，凝结了资深大咖思考与经验精华的又有多少？看完了还是一头雾水，一脸困惑。 本篇文章就是为你的困惑而准备的。作者邓福喜主要从事区块链底层技术平台的设计与研发工作，有10多年的开发经验，他的经验与思考，是一份价值10万的知识大餐，以下，希望对你有所帮助。 以太坊作为公开区块链技术平台，因为其良好的扩展性和灵活度，有很强的业务适用场景，这主要归功于其图灵完备的虚拟机与其上运行的智能合约。以太坊通过特定的编码方式实现对智能合约与账户数据的编码存储，同时又能在其数据基础上实现对区块与交易执行结果的完备共识证明。以下分几个部分来详细阐述。 &nbsp; 以太坊RLP编码 RLP（Recursive Length Prefix）编码是以太坊中数据序列化的一个主要编码方式，可以将任意的嵌套二进制数据进行序列化。以太坊中针对RLP的编码规则定义如下： &nbsp; 1. 如果是一个单字节并且其值在[0x00,0x7f]范围内，RLP编码就是自身。 &nbsp; 2. 否则，如果一个数据串的字节长度是0-55字节，那么它的RLP编码是在数据串开头增加一个字节，这个字节的值是0x80加上数据串的字节长度。因此增加的该字节的取值范围为[0x80, 0xb7]。 &nbsp; 3. 如果一个数据串的字节长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xb7加上数据串字节长度的二进制编码的字节长度，然后依次跟着数据串字节长度部分和内容部分。比如：一个长度为1024字节的数据串，其字节长度用16进制表示为0x0400，长度为2个字节，因此RLP编码头字节的值为0xb9（0xb7 + 0x02），然后跟着两字节为0x0400，后面再加上数据串的具体内容。因此增加的首字节的取值范围为[0xb8, 0xbf]，因此其能编码的最大数据长度为2^56。 &nbsp; 4. 如果是一个嵌套的列表数据，则需要先将列表中的数据按照单元素的编码规则进行RLP编码后串联得到列表数据的payload。如果一个列表数据的payload的字节长度为0-55，那么列表的RLP编码在其payload前加上一个字节，这个字节的值是0xc0加上payload的字节长度。因此首字节的取值范围为[0xc0, 0xf7]。 &nbsp; 5. 如果一个列表数据的payload的长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xf7加上列表payload字节长度的二进制编码的字节长度，然后依次跟着payload字节长度部分和payload部分。因此首字节的取值范围为[0xf8, 0xff]，因此一个列表中存储的所有元素的字节长度不能超过2^56。 &nbsp; 如下是一些RLP编码的参考样例。 &nbsp; 表1 &nbsp;RLP编码样例 &nbsp; 以太坊MPT MPT（Merkle Patricia Tree）是以太坊用来将Key-Value进行紧凑编码的一种数据组织形式。基于该数据组织形式，MPT上任何存储数据的细微变化都会导致MPT的根节点发生变更，因此可以校验数据的一致性。 &nbsp; 在MPT中，存在如下三类节点。 &nbsp; 1. 叶子节点：用于数据存储的节点。其Key值是一个对应插入数据的特殊16进制编码（需要剔除掉从根节点到当前叶子节点的前缀部分内容），Value值对应插入数据的RLP编码。 &nbsp; 2. 扩展节点：扩展节点用来处理具有共同前缀的数据，通过扩展节点可以扩展出一个多分叉的分支节点。其Key值存储的是共同的前缀部分的16进制，Value值存储的是扩展出的分支节点的hash值（sha3（RLP（分支节点数据List）））。 &nbsp; 3. 分支节点：由于MPT存储的Key是16进制的编码数据，那么在不具备共同前缀时就通过分支节点进行分叉。分支节点的key是一个16个数据的数组，数组的下标对应16进制的0-F，用来扩展不同的数据。 &nbsp; 数组中存储的的是分叉节点的hash值，同时数组的下标也对应一个数据的一个16进制位（4bit）。分支节点的Value一般为空，如果有数据的Key值在其上的扩展节点终止，那么数据Key对应的Value值则存储在分支节点的Value属性上。 &nbsp; 扩展节点和叶子节点的Key值前面存在一个4bit或者8bit nibble，用来标示节点类型和后续的数据长度的奇偶性（原始数据Key值16进制后长度为偶数，但是经过扩展节点和分支节点的前缀剔除后剩下的长度可能是奇数，也可能为偶数）。 表2 Nibble取值含义 &nbsp; 如下是一个样例数据的MPT形象化表示： &nbsp; ﻿ 图1 &nbsp;MPT样例结构 &nbsp; 该图中蓝色标注的为分支节点；橙色标注的为扩展节点；绿色标注的为叶子节点。 &nbsp; 上述样例结构中存储的是如下的Key-Value原始数据： &nbsp; 表 3 原始样例数据 &nbsp; 在MPT树上节点存储的数据是原始数据的如下映射： &nbsp; Key = sha3(原始数据key) &nbsp; Value = RLP(原始数据Value) &nbsp; 因此在上述样例MPT中，存储的节点数据为如下表格所示： &nbsp; ﻿ 表4 &nbsp;MPT节点数据 &nbsp; 上述数据的插入过程如下： &nbsp; a. 插入[“00000000000000000000000000000022”, 22] &nbsp; 1. 将key值进行sha3求hash值得到0x8B2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30，将value计算RLP得到0x16 &nbsp; 2. 由于当前没有任何节点，则直接生成一个新的叶子节点，将该节点作为根节点。由于MPT key值长度为偶数，所以在MPT key值前增加16进制nibble值20，得到的树如下： &nbsp; &nbsp; 图2 &nbsp;One Node &nbsp; b. 插入[“00000000000000000000000000000023”, 23] &nbsp; 1. 将key值进行sha3求hash值得到0x5976CAE7AF706E65E5272E8C98FB867F1801F3408562AA73D259A27CAC334D78，将value计算RLP得到0x17。 &nbsp; 2. 当前树只有一个叶子节点，并且两个key的hash值没有公共前缀（一个以8开头，一个以5开头），因此增加一个分支节点用以扩展不同前缀的节点，并且构造两个新的叶子节点挂在分支节点下面。 &nbsp; 3. 将上述value为22的key值hash取16进制的首位得到8，那么将key值去掉1位得到0xB2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30，去掉1位后由于长度为奇数，那么增加16进制的nibble值3，得到新的叶子节点[0x3B2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30, 0x16] 。 &nbsp; 4. 将上述新得到的叶子节点作为RLP List进行编码，并计算hash值得到 0xDDCB61885A1C577BE083824D6761932FDCF0A496072A5932B021CD801F65076D，将得到的hash值填入父分支节点的第8位（原有hash值首字符为8）。 &nbsp; 5. 同理计算value为23的节点，得到新的叶子节点[0x3976CAE7AF706E65E5272E8C98FB867F1801F3408562AA73D259A27CAC334D78, 0x17]，并计算RLP编码的hash值0xB5BB9644C549233F9B3D462844E565AE9A5EF2D0687DB8739B3FEA5B1260FACF并填入父分支节点的第5位（原有hash值首字符为5）。 &nbsp; 6. 得到新的树结构如下： ﻿ ﻿ 图3 &nbsp;Two Nodes &nbsp; c. 插入[“00000000000000000000000000000024”, 24] &nbsp; 1. 按照相同的计算规则插入value为24的节点，由于没有共同的前缀，所以在分支节点第12位下增加一个新的叶子节点。 &nbsp; 2. 得到新的树结构如下：&nbsp; ﻿ ﻿ &nbsp; 图4 &nbsp;Three Nodes &nbsp; d. 插入[“00000000000000000000000000000025”, 25] &nbsp; 1. 按照相同的计算规则插入value为25的节点，由于没有共同的前缀，所以在分支节点第13位下增加一个新的叶子节点。 &nbsp; 2. 得到新的树结构如下： &nbsp; ﻿ ﻿ &nbsp; 图5 &nbsp;Four Nodes &nbsp; e. 插入[“00000000000000000000000000000026”, 26] &nbsp; 1. 将key值进行sha3求hash值得到0xC4D13FBA6CFB72A7455EB8EDF262434C55D24DC9674D58B4AE05A89EE83F9321，将value计算RLP得到0x1A。 &nbsp; 2. 根据hash值得首字符“C”查找根节点的插入点为分支节点的第12位，由于在第12位存在了相同的节点（value值为24），由于去掉首字符“C”后还存在共同的前缀“4”，则需要增加一个扩展节点用来存储共同前缀“4”，并且在扩展节点下增加一个分支节点用来扩展后续的不同部分。 &nbsp; 3. 将上述value为24的key值hash去掉共同的前缀“C4”并增加nibble后得到节点[0x3F06F103C7FB2579CFA08AF8536B03DE8DA3C677F9F2A6FB397CBD1A775273, 0x18]，求其节点RLP的hash值填入新增加分支节点的第11位（去掉共同前缀“C4”后的首字符为B）。 &nbsp; 4. 按照相同的计算规则构造value值为26的叶子节点[0x313FBA6CFB72A7455EB8EDF262434C55D24DC9674D58B4AE05A89EE83F9321, 0x1A]，求其节点RLP的hash值填入新增加分支节点的第13位（去掉共同前缀“C4”后的首字符为D）。 &nbsp; 5. 调整完上述两个叶子节点后，得到新的分支节点，并计算新的分支节点的RLP Hash值0xD7C0D0160345D3EF2F758D15598965BE1A2C71682995890C5341171EF72A54B2作为value值填入父扩展节点的value部分。 &nbsp; 6. 新增加的扩展节点保留共同的前缀“4”（剔除其父分支节点的共同部分“C”），并增加16进制nibble值1，得到其MPT key值为0x14。 &nbsp; 7. 计算新的扩展节点的RLP hash值0x7DADADF4464529492D2C475DA62C1F64FAAE150A7355E921E805CF82B5E90A69填入其父分支节点的第12位。 &nbsp; 8. 得到新的树结构如下： &nbsp; ﻿ ﻿ 图6 &nbsp;Five Nodes &nbsp; 上述过程是通过新增节点构建一个MPT的过程，存储数据的更新和删除逻辑就不在此累述，读者可以举一反三进行类推。需要注意的是任何数据的更新操作都需要先基于树的检索路径找到对应的节点进行更新，并且从该节点逐层向上调整检索路径上的所有节点直至根节点，中间有可能会涉及到节点类型的调整和节点的合并。 &nbsp; 以太坊合约存储规则 以太坊提供了一种图灵完备的虚拟机与智能合约编写规则。我们可以在智能合约中定义复杂的数据模型以及在该数据模型上执行的一系列函数操作。我们知道，以太坊是以Key-value的形式来存储数据的，那么智能合约的复杂数据结构是如何映射到这样的键值对上的呢？ &nbsp; 以太坊采用如下的编码规则来将数据结构定义和数据值映射成Key-Value： &nbsp; 1. 智能合约的任何结构都会被映射成[key, value]的形式，其中key和value均是无符号32字节的数据。 &nbsp; 2. 所有的存储成员按照成员定义位置从0开始索引编排，每次累加1，作为其对应的key值进行存储。Value为具体的成员属性值。 &nbsp; 3. 固定长度数据类型（例如：uint8、uint16、uint32、enum）Value按照32字节右对齐的原则。相邻的存储成员如果其长度不满足32字节，则会将Value进行压缩合并存储。例如如下的变量定义和数据取值： &nbsp; enum a = 1; &nbsp; uint8 b = 15; &nbsp; Key:0x00000000000000000000000000000000000 &nbsp; 00000000000000000000000000000 &nbsp; Valu0x00000000000000000000000000000000000 &nbsp; 000000000000000 &nbsp; 4. 可变长度数据类型（例如：string、bytes）按照左对齐的原则进行编码，如果其长度不大于31字节，则按照一条记录存储，该记录Value的最后一个字节存储其可变内容的实际长度，例如如下的变量定义和数据取值： &nbsp; string a = &quot;123&quot;; &nbsp; Key:0x0000000000000000000000000000000000 &nbsp; 000000000000000000000000000000 &nbsp; Value:0x31323300000000000000000000000000 &nbsp; 00000000000000000000000000000006 &nbsp; 5. 如果可变长度类型变量的数据内容长度超过31字节，则将会被拆分成多条记录进行存储。第一条记录的key值为其索引编号，Value值为其实际数据长度加1；然后将内容按照32字节拆分成多条记录，每条记录的key值为首条记录key值进行sha3后得到的hash值从0开始每次累加1得到，value值为拆分的内容部分。例如如下的变量定义和数据取值： &nbsp; string a = &quot;1234567890123456789012345678 &nbsp; 901234567890&quot;; &nbsp; Key1:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000000 &nbsp; Value1:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000000051 &nbsp; Key2:sha3(0x0000000000000000000000000000 &nbsp; 000000000000000000000000000000000000) &nbsp; Value2:0x3132333435363738393031323334353 &nbsp; 637383930313233343536373839303132 &nbsp; Key3:sha3(0x0000000000000000000000000000 &nbsp; 000000000000000000000000000000000000)+1 &nbsp; Value3:0x33343536373839300000000000000000 &nbsp; 00000000000000000000000000000000 &nbsp; 6. 针对结构体定义，可以看成将结构体扩展到结构变量定义位置的索引编号进行累加。例如如下的变量定义和数据取值： &nbsp; struct Data &nbsp; { &nbsp; string name; &nbsp; int age; &nbsp; } &nbsp; string a = &quot;1234567890&quot;; &nbsp; Data d; &nbsp; d.name = &quot;1234567890&quot;; &nbsp; d.age = 3224115; &nbsp; Key1:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000000 &nbsp; Value1:0x3132333435363738393031323334353 &nbsp; 637383930000000000000000000000014 &nbsp; Key2:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000001 &nbsp; Value2:0x313233343536373839303132333435 &nbsp; 3637383930000000000000000000000014 &nbsp; Key3:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000002 &nbsp; Value3:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000313233 &nbsp; 7. 针对数组定义，则需要扩展多条记录。第一条记录Key值为数组变量的索引，Value值为数组的元素个数。后续则根据数组的元素增加多条记录，每条记录的Key值在首条记录的Key值上做sha3得到hash值从0开始每次累加1，Value值为数组元素的对应值。例如如下的变量定义和数据取值： &nbsp; string[] cources; &nbsp; cources[0] = &quot;123&quot;; &nbsp; cources[1] = &quot;456&quot;; &nbsp; Key1:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000000000 &nbsp; Value1:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000000002 &nbsp; Key2:sha3(0x0000000000000000000000000000 &nbsp; 000000000000000000000000000000000000) &nbsp; Value2:0x3132330000000000000000000000000 &nbsp; 000000000000000000000000000000006 &nbsp; Key3:sha3(0x000000000000000000000000000 &nbsp; 0000000000000000000000000000000000000)+1 &nbsp; Value3:0x343536000000000000000000000000 &nbsp; 0000000000000000000000000000000006 &nbsp; 8. 针对Map数据定义，其key值则为map key值加上变量索引进行sha3取hash值。例如如下的变量定义和数据取值： &nbsp; string a; &nbsp; mapping(string =&gt; string) r; &nbsp; mapping(string =&gt; int) s; &nbsp; r[&quot;abc&quot;] = &quot;123&quot;; &nbsp; r[&quot;def&quot;] = &quot;123&quot;; &nbsp; s[&quot;abc&quot;] = 123; &nbsp; Key1:sha3(0x61626300000000000000000000000 &nbsp; 00000000000000000000000000000000000000001) &nbsp; Value1:0x313233000000000000000000000000000 &nbsp; 0000000000000000000000000000006 &nbsp; Key2:sha3(0x64656600000000000000000000000 &nbsp; 00000000000000000000000000000000000000001) &nbsp; Value2:0x3132330000000000000000000000000000 &nbsp; 000000000000000000000000000006 &nbsp; Key3:sha3(0x616263000000000000000000000000 &nbsp; 0000000000000000000000000000000000000002) &nbsp; Value3:0x00000000000000000000000000000000 &nbsp; 0000000000000000000000000000007b &nbsp; 以太坊账户结构 在以太坊中，账户信息以Key-Value的形式存储在区块链的数据库中，每个账户通过一个唯一的地址编码作为Key进行标示，Value存储该账户的相关属性、账户余额、合约代码标示、合约存储标示。其结构如下： ﻿ ﻿ 图7 &nbsp;账户结构 &nbsp; 1. Address：账户地址，与用户私钥唯一对应的一组20字节的数据串。 &nbsp; 2. Nonce：用户账户对应的的交易序列号，每次成功执行交易后累加1。 &nbsp; 3. Balance：用于账户对应的账户余额，以wei为单位（1 eth = 1018 wei）。 &nbsp; 4. StorageRoot：仅在合约账户上该属性有效，标示合约存储结构的MPT树根节点hash值。 &nbsp; 5. CodeHash：仅在合约账户上该属性有效，标示合约代码对应的Hash值。 &nbsp; 任何一个以太坊的账户都可以基于其地址在以太坊的数据库中按照MPT树的检索规则找到对应的一条账户存储记录。检索的Key值为账户地址的hash值，检索到的Value值是上述结构的一个RLP编码数据串，可以基于RLP的编码规则逆向解析出其对应的属性值。 &nbsp; 以太坊的数据库存储 以太坊用NoSQL数据库以Key-Value的形式存储所有的数据。针对账户数据结构，需要存储的数据主要包含智能合约的Storage和基本的账户信息。对应的存储规则如下： &nbsp; 1. 针对智能合约Storage，将数据按照编码规则映射成MPT，然后将MPT的所有节点的Key和Value构建一个RLP List编码作为数据库存储的Value值，将该Value值进行Sha3计算hash值作为数据库存储的Key值进行存储。 &nbsp; 2. 针对基本账户信息，将其对应智能合约Storage的MPT Root Hash保存于账户的StorageRoot属性，然后将系统中的所有Account构建一个MPT。按照和Storage的数据库存储方式将MPT的所有节点进行存储。 &nbsp; 上述构建的两个MPT树的结构如图8。 &nbsp; ﻿ 图8 &nbsp;Account &amp; Storage MPT 结论 以太坊的账户以Hash散列与RLP数据编码为基础，结合智能合约的数据对象映射和转换，将Key-Value的数据以MPT的方式进行组织，计算StorageRoot唯一证明并保存于账户模型。最终形成Storage和Account两种MPT，并将MPT的所有节点以Key-Value的形式存储于NoSQL数据库中。这样的编码存储方式可以快速的校验智能合约和账户数据是否发生了变更，进而只需要对比MPT根节点的差异就可以快速校验区块链上分布式节点数据的一致性。 &nbsp; 后记 在深刻理解了以太坊的存储模型和原理机制后，可以在某些方面扩展以太坊的能力实现更加丰富的功能集。例如： &nbsp; 1. 实现可视化的工具，完成对以太坊LevelDB数据库的数据解析和呈现。借助智能合约的存储定义，结合账户的StorageRoot遍历LevelDB数据库中的Key-Value键值对，根据编码规则实现数据逆向分析和展示，为DApp应用的开发调试提供更加方便快捷的数据操作。 &nbsp; 2. 智能合约的升级一直是一件令开发者颇为头疼的事情，如何保证在完成智能合约的缺陷升级后还能维系访问原有的留存数据就是一个切实的痛点。借助对智能合约的存储机制，可以考虑在以太坊中扩展功能，支持智能合约的升级，并将原有的智能合约StorageRoot迁移复制给升级后的智能合约账户。在满足特定的数据定义要求下，可以达到智能合约升级后的数据平滑迁移效果。 &nbsp; 3. 以太坊的数据存储方案并不是最完美的解决方案，因为MPT的特性，海量数据存储账户的更新操作会带来指数级的数据存取，这样会让以太坊的智能合约执行变得非常低效。是否存在可能的解决方案，将海量的数据存储脱离MPT的方式的，提升数据存取的效率，是值得思考的一个问题。 &nbsp; 上述的内容只是在以太坊数据存储模型上的简单思考和一些引子，起到抛砖引玉的效果。希望读者能有更新颖的想法和灵感。 &nbsp; 作者简介：邓福喜，矩阵元技术（深圳）有限公司的系统架构师。作者在分布式系统和互联网应用的架构设计与研发方面有10多年的从业经验，目前主要从事区块链底层技术平台的设计与研发工作，邮箱dengfuxi@juzix.io。 本文首发《程序员》 热门文章 区块链：诞生于草根的时尚 孟岩：我反对将Token翻译成“代币” “矿工”年入千万成历史，强监管下比特币还能走多远？ 深度解析区块链架构、跨链和演进 人才稀缺的区块链，程序员转型入门必看这四项技能 对话元道：通证经济需要“互链网”，“互链网”需要细腰 今天，这几位区块链大咖旗帜鲜明地亮出“通证派”，原来这才是他们期盼中的未来交易的模样... 与元道对话三：区块链经济正在进行“动力切换” 锐评：泡沫中的token和被冷落的联盟链 对话元道二：通证视角下的区块链创新路线 听听Vitalik对token设计的看法 了解更多区块链技术及应用内容，敬请关注： 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-10T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本文从存储结构的角度，解读以太坊的智能合约和账户数据模型的编码实现方案。借助这些实现方案的解读，可以对以太坊的数据模型、存储结构、编码方式、共识原理等知识有更加深入的了解，对基于以太坊的开发实施和问题定位有一定借鉴作用。&nbsp;﻿ &nbsp; 打开拉勾网，输入区块链工程师一职，月薪平均在30K左右。 但无论什么公司，无论什么岗位，无一例外有这么一句“熟悉以太坊区块链技术原理、机制的优先”。如今，会以太坊开发技术的程序员，俨然成为各大公司争抢的宝贝，而如果技术出众，更是被高薪团团围住。 而你呢，看了那么多以太坊相关资料，能实操能实战，凝结了资深大咖思考与经验精华的又有多少？看完了还是一头雾水，一脸困惑。 本篇文章就是为你的困惑而准备的。作者邓福喜主要从事区块链底层技术平台的设计与研发工作，有10多年的开发经验，他的经验与思考，是一份价值10万的知识大餐，以下，希望对你有所帮助。 以太坊作为公开区块链技术平台，因为其良好的扩展性和灵活度，有很强的业务适用场景，这主要归功于其图灵完备的虚拟机与其上运行的智能合约。以太坊通过特定的编码方式实现对智能合约与账户数据的编码存储，同时又能在其数据基础上实现对区块与交易执行结果的完备共识证明。以下分几个部分来详细阐述。 &nbsp; 以太坊RLP编码 RLP（Recursive Length Prefix）编码是以太坊中数据序列化的一个主要编码方式，可以将任意的嵌套二进制数据进行序列化。以太坊中针对RLP的编码规则定义如下： &nbsp; 1. 如果是一个单字节并且其值在[0x00,0x7f]范围内，RLP编码就是自身。 &nbsp; 2. 否则，如果一个数据串的字节长度是0-55字节，那么它的RLP编码是在数据串开头增加一个字节，这个字节的值是0x80加上数据串的字节长度。因此增加的该字节的取值范围为[0x80, 0xb7]。 &nbsp; 3. 如果一个数据串的字节长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xb7加上数据串字节长度的二进制编码的字节长度，然后依次跟着数据串字节长度部分和内容部分。比如：一个长度为1024字节的数据串，其字节长度用16进制表示为0x0400，长度为2个字节，因此RLP编码头字节的值为0xb9（0xb7 + 0x02），然后跟着两字节为0x0400，后面再加上数据串的具体内容。因此增加的首字节的取值范围为[0xb8, 0xbf]，因此其能编码的最大数据长度为2^56。 &nbsp; 4. 如果是一个嵌套的列表数据，则需要先将列表中的数据按照单元素的编码规则进行RLP编码后串联得到列表数据的payload。如果一个列表数据的payload的字节长度为0-55，那么列表的RLP编码在其payload前加上一个字节，这个字节的值是0xc0加上payload的字节长度。因此首字节的取值范围为[0xc0, 0xf7]。 &nbsp; 5. 如果一个列表数据的payload的长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xf7加上列表payload字节长度的二进制编码的字节长度，然后依次跟着payload字节长度部分和payload部分。因此首字节的取值范围为[0xf8, 0xff]，因此一个列表中存储的所有元素的字节长度不能超过2^56。 &nbsp; 如下是一些RLP编码的参考样例。 &nbsp; 表1 &nbsp;RLP编码样例 &nbsp; 以太坊MPT MPT（Merkle Patricia Tree）是以太坊用来将Key-Value进行紧凑编码的一种数据组织形式。基于该数据组织形式，MPT上任何存储数据的细微变化都会导致MPT的根节点发生变更，因此可以校验数据的一致性。 &nbsp; 在MPT中，存在如下三类节点。 &nbsp; 1. 叶子节点：用于数据存储的节点。其Key值是一个对应插入数据的特殊16进制编码（需要剔除掉从根节点到当前叶子节点的前缀部分内容），Value值对应插入数据的RLP编码。 &nbsp; 2. 扩展节点：扩展节点用来处理具有共同前缀的数据，通过扩展节点可以扩展出一个多分叉的分支节点。其Key值存储的是共同的前缀部分的16进制，Value值存储的是扩展出的分支节点的hash值（sha3（RLP（分支节点数据List）））。 &nbsp; 3. 分支节点：由于MPT存储的Key是16进制的编码数据，那么在不具备共同前缀时就通过分支节点进行分叉。分支节点的key是一个16个数据的数组，数组的下标对应16进制的0-F，用来扩展不同的数据。 &nbsp; 数组中存储的的是分叉节点的hash值，同时数组的下标也对应一个数据的一个16进制位（4bit）。分支节点的Value一般为空，如果有数据的Key值在其上的扩展节点终止，那么数据Key对应的Value值则存储在分支节点的Value属性上。 &nbsp; 扩展节点和叶子节点的Key值前面存在一个4bit或者8bit nibble，用来标示节点类型和后续的数据长度的奇偶性（原始数据Key值16进制后长度为偶数，但是经过扩展节点和分支节点的前缀剔除后剩下的长度可能是奇数，也可能为偶数）。 表2 Nibble取值含义 &nbsp; 如下是一个样例数据的MPT形象化表示： &nbsp; ﻿ 图1 &nbsp;MPT样例结构 &nbsp; 该图中蓝色标注的为分支节点；橙色标注的为扩展节点；绿色标注的为叶子节点。 &nbsp; 上述样例结构中存储的是如下的Key-Value原始数据： &nbsp; 表 3 原始样例数据 &nbsp; 在MPT树上节点存储的数据是原始数据的如下映射： &nbsp; Key = sha3(原始数据key) &nbsp; Value = RLP(原始数据Value) &nbsp; 因此在上述样例MPT中，存储的节点数据为如下表格所示： &nbsp; ﻿ 表4 &nbsp;MPT节点数据 &nbsp; 上述数据的插入过程如下： &nbsp; a. 插入[“00000000000000000000000000000022”, 22] &nbsp; 1. 将key值进行sha3求hash值得到0x8B2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30，将value计算RLP得到0x16 &nbsp; 2. 由于当前没有任何节点，则直接生成一个新的叶子节点，将该节点作为根节点。由于MPT key值长度为偶数，所以在MPT key值前增加16进制nibble值20，得到的树如下： &nbsp; &nbsp; 图2 &nbsp;One Node &nbsp; b. 插入[“00000000000000000000000000000023”, 23] &nbsp; 1. 将key值进行sha3求hash值得到0x5976CAE7AF706E65E5272E8C98FB867F1801F3408562AA73D259A27CAC334D78，将value计算RLP得到0x17。 &nbsp; 2. 当前树只有一个叶子节点，并且两个key的hash值没有公共前缀（一个以8开头，一个以5开头），因此增加一个分支节点用以扩展不同前缀的节点，并且构造两个新的叶子节点挂在分支节点下面。 &nbsp; 3. 将上述value为22的key值hash取16进制的首位得到8，那么将key值去掉1位得到0xB2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30，去掉1位后由于长度为奇数，那么增加16进制的nibble值3，得到新的叶子节点[0x3B2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30, 0x16] 。 &nbsp; 4. 将上述新得到的叶子节点作为RLP List进行编码，并计算hash值得到 0xDDCB61885A1C577BE083824D6761932FDCF0A496072A5932B021CD801F65076D，将得到的hash值填入父分支节点的第8位（原有hash值首字符为8）。 &nbsp; 5. 同理计算value为23的节点，得到新的叶子节点[0x3976CAE7AF706E65E5272E8C98FB867F1801F3408562AA73D259A27CAC334D78, 0x17]，并计算RLP编码的hash值0xB5BB9644C549233F9B3D462844E565AE9A5EF2D0687DB8739B3FEA5B1260FACF并填入父分支节点的第5位（原有hash值首字符为5）。 &nbsp; 6. 得到新的树结构如下： ﻿ ﻿ 图3 &nbsp;Two Nodes &nbsp; c. 插入[“00000000000000000000000000000024”, 24] &nbsp; 1. 按照相同的计算规则插入value为24的节点，由于没有共同的前缀，所以在分支节点第12位下增加一个新的叶子节点。 &nbsp; 2. 得到新的树结构如下：&nbsp; ﻿ ﻿ &nbsp; 图4 &nbsp;Three Nodes &nbsp; d. 插入[“00000000000000000000000000000025”, 25] &nbsp; 1. 按照相同的计算规则插入value为25的节点，由于没有共同的前缀，所以在分支节点第13位下增加一个新的叶子节点。 &nbsp; 2. 得到新的树结构如下： &nbsp; ﻿ ﻿ &nbsp; 图5 &nbsp;Four Nodes &nbsp; e. 插入[“00000000000000000000000000000026”, 26] &nbsp; 1. 将key值进行sha3求hash值得到0xC4D13FBA6CFB72A7455EB8EDF262434C55D24DC9674D58B4AE05A89EE83F9321，将value计算RLP得到0x1A。 &nbsp; 2. 根据hash值得首字符“C”查找根节点的插入点为分支节点的第12位，由于在第12位存在了相同的节点（value值为24），由于去掉首字符“C”后还存在共同的前缀“4”，则需要增加一个扩展节点用来存储共同前缀“4”，并且在扩展节点下增加一个分支节点用来扩展后续的不同部分。 &nbsp; 3. 将上述value为24的key值hash去掉共同的前缀“C4”并增加nibble后得到节点[0x3F06F103C7FB2579CFA08AF8536B03DE8DA3C677F9F2A6FB397CBD1A775273, 0x18]，求其节点RLP的hash值填入新增加分支节点的第11位（去掉共同前缀“C4”后的首字符为B）。 &nbsp; 4. 按照相同的计算规则构造value值为26的叶子节点[0x313FBA6CFB72A7455EB8EDF262434C55D24DC9674D58B4AE05A89EE83F9321, 0x1A]，求其节点RLP的hash值填入新增加分支节点的第13位（去掉共同前缀“C4”后的首字符为D）。 &nbsp; 5. 调整完上述两个叶子节点后，得到新的分支节点，并计算新的分支节点的RLP Hash值0xD7C0D0160345D3EF2F758D15598965BE1A2C71682995890C5341171EF72A54B2作为value值填入父扩展节点的value部分。 &nbsp; 6. 新增加的扩展节点保留共同的前缀“4”（剔除其父分支节点的共同部分“C”），并增加16进制nibble值1，得到其MPT key值为0x14。 &nbsp; 7. 计算新的扩展节点的RLP hash值0x7DADADF4464529492D2C475DA62C1F64FAAE150A7355E921E805CF82B5E90A69填入其父分支节点的第12位。 &nbsp; 8. 得到新的树结构如下： &nbsp; ﻿ ﻿ 图6 &nbsp;Five Nodes &nbsp; 上述过程是通过新增节点构建一个MPT的过程，存储数据的更新和删除逻辑就不在此累述，读者可以举一反三进行类推。需要注意的是任何数据的更新操作都需要先基于树的检索路径找到对应的节点进行更新，并且从该节点逐层向上调整检索路径上的所有节点直至根节点，中间有可能会涉及到节点类型的调整和节点的合并。 &nbsp; 以太坊合约存储规则 以太坊提供了一种图灵完备的虚拟机与智能合约编写规则。我们可以在智能合约中定义复杂的数据模型以及在该数据模型上执行的一系列函数操作。我们知道，以太坊是以Key-value的形式来存储数据的，那么智能合约的复杂数据结构是如何映射到这样的键值对上的呢？ &nbsp; 以太坊采用如下的编码规则来将数据结构定义和数据值映射成Key-Value： &nbsp; 1. 智能合约的任何结构都会被映射成[key, value]的形式，其中key和value均是无符号32字节的数据。 &nbsp; 2. 所有的存储成员按照成员定义位置从0开始索引编排，每次累加1，作为其对应的key值进行存储。Value为具体的成员属性值。 &nbsp; 3. 固定长度数据类型（例如：uint8、uint16、uint32、enum）Value按照32字节右对齐的原则。相邻的存储成员如果其长度不满足32字节，则会将Value进行压缩合并存储。例如如下的变量定义和数据取值： &nbsp; enum a = 1; &nbsp; uint8 b = 15; &nbsp; Key:0x00000000000000000000000000000000000 &nbsp; 00000000000000000000000000000 &nbsp; Valu0x00000000000000000000000000000000000 &nbsp; 000000000000000 &nbsp; 4. 可变长度数据类型（例如：string、bytes）按照左对齐的原则进行编码，如果其长度不大于31字节，则按照一条记录存储，该记录Value的最后一个字节存储其可变内容的实际长度，例如如下的变量定义和数据取值： &nbsp; string a = &quot;123&quot;; &nbsp; Key:0x0000000000000000000000000000000000 &nbsp; 000000000000000000000000000000 &nbsp; Value:0x31323300000000000000000000000000 &nbsp; 00000000000000000000000000000006 &nbsp; 5. 如果可变长度类型变量的数据内容长度超过31字节，则将会被拆分成多条记录进行存储。第一条记录的key值为其索引编号，Value值为其实际数据长度加1；然后将内容按照32字节拆分成多条记录，每条记录的key值为首条记录key值进行sha3后得到的hash值从0开始每次累加1得到，value值为拆分的内容部分。例如如下的变量定义和数据取值： &nbsp; string a = &quot;1234567890123456789012345678 &nbsp; 901234567890&quot;; &nbsp; Key1:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000000 &nbsp; Value1:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000000051 &nbsp; Key2:sha3(0x0000000000000000000000000000 &nbsp; 000000000000000000000000000000000000) &nbsp; Value2:0x3132333435363738393031323334353 &nbsp; 637383930313233343536373839303132 &nbsp; Key3:sha3(0x0000000000000000000000000000 &nbsp; 000000000000000000000000000000000000)+1 &nbsp; Value3:0x33343536373839300000000000000000 &nbsp; 00000000000000000000000000000000 &nbsp; 6. 针对结构体定义，可以看成将结构体扩展到结构变量定义位置的索引编号进行累加。例如如下的变量定义和数据取值： &nbsp; struct Data &nbsp; { &nbsp; string name; &nbsp; int age; &nbsp; } &nbsp; string a = &quot;1234567890&quot;; &nbsp; Data d; &nbsp; d.name = &quot;1234567890&quot;; &nbsp; d.age = 3224115; &nbsp; Key1:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000000 &nbsp; Value1:0x3132333435363738393031323334353 &nbsp; 637383930000000000000000000000014 &nbsp; Key2:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000001 &nbsp; Value2:0x313233343536373839303132333435 &nbsp; 3637383930000000000000000000000014 &nbsp; Key3:0x000000000000000000000000000000000 &nbsp; 0000000000000000000000000000002 &nbsp; Value3:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000313233 &nbsp; 7. 针对数组定义，则需要扩展多条记录。第一条记录Key值为数组变量的索引，Value值为数组的元素个数。后续则根据数组的元素增加多条记录，每条记录的Key值在首条记录的Key值上做sha3得到hash值从0开始每次累加1，Value值为数组元素的对应值。例如如下的变量定义和数据取值： &nbsp; string[] cources; &nbsp; cources[0] = &quot;123&quot;; &nbsp; cources[1] = &quot;456&quot;; &nbsp; Key1:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000000000 &nbsp; Value1:0x0000000000000000000000000000000 &nbsp; 000000000000000000000000000000002 &nbsp; Key2:sha3(0x0000000000000000000000000000 &nbsp; 000000000000000000000000000000000000) &nbsp; Value2:0x3132330000000000000000000000000 &nbsp; 000000000000000000000000000000006 &nbsp; Key3:sha3(0x000000000000000000000000000 &nbsp; 0000000000000000000000000000000000000)+1 &nbsp; Value3:0x343536000000000000000000000000 &nbsp; 0000000000000000000000000000000006 &nbsp; 8. 针对Map数据定义，其key值则为map key值加上变量索引进行sha3取hash值。例如如下的变量定义和数据取值： &nbsp; string a; &nbsp; mapping(string =&gt; string) r; &nbsp; mapping(string =&gt; int) s; &nbsp; r[&quot;abc&quot;] = &quot;123&quot;; &nbsp; r[&quot;def&quot;] = &quot;123&quot;; &nbsp; s[&quot;abc&quot;] = 123; &nbsp; Key1:sha3(0x61626300000000000000000000000 &nbsp; 00000000000000000000000000000000000000001) &nbsp; Value1:0x313233000000000000000000000000000 &nbsp; 0000000000000000000000000000006 &nbsp; Key2:sha3(0x64656600000000000000000000000 &nbsp; 00000000000000000000000000000000000000001) &nbsp; Value2:0x3132330000000000000000000000000000 &nbsp; 000000000000000000000000000006 &nbsp; Key3:sha3(0x616263000000000000000000000000 &nbsp; 0000000000000000000000000000000000000002) &nbsp; Value3:0x00000000000000000000000000000000 &nbsp; 0000000000000000000000000000007b &nbsp; 以太坊账户结构 在以太坊中，账户信息以Key-Value的形式存储在区块链的数据库中，每个账户通过一个唯一的地址编码作为Key进行标示，Value存储该账户的相关属性、账户余额、合约代码标示、合约存储标示。其结构如下： ﻿ ﻿ 图7 &nbsp;账户结构 &nbsp; 1. Address：账户地址，与用户私钥唯一对应的一组20字节的数据串。 &nbsp; 2. Nonce：用户账户对应的的交易序列号，每次成功执行交易后累加1。 &nbsp; 3. Balance：用于账户对应的账户余额，以wei为单位（1 eth = 1018 wei）。 &nbsp; 4. StorageRoot：仅在合约账户上该属性有效，标示合约存储结构的MPT树根节点hash值。 &nbsp; 5. CodeHash：仅在合约账户上该属性有效，标示合约代码对应的Hash值。 &nbsp; 任何一个以太坊的账户都可以基于其地址在以太坊的数据库中按照MPT树的检索规则找到对应的一条账户存储记录。检索的Key值为账户地址的hash值，检索到的Value值是上述结构的一个RLP编码数据串，可以基于RLP的编码规则逆向解析出其对应的属性值。 &nbsp; 以太坊的数据库存储 以太坊用NoSQL数据库以Key-Value的形式存储所有的数据。针对账户数据结构，需要存储的数据主要包含智能合约的Storage和基本的账户信息。对应的存储规则如下： &nbsp; 1. 针对智能合约Storage，将数据按照编码规则映射成MPT，然后将MPT的所有节点的Key和Value构建一个RLP List编码作为数据库存储的Value值，将该Value值进行Sha3计算hash值作为数据库存储的Key值进行存储。 &nbsp; 2. 针对基本账户信息，将其对应智能合约Storage的MPT Root Hash保存于账户的StorageRoot属性，然后将系统中的所有Account构建一个MPT。按照和Storage的数据库存储方式将MPT的所有节点进行存储。 &nbsp; 上述构建的两个MPT树的结构如图8。 &nbsp; ﻿ 图8 &nbsp;Account &amp; Storage MPT 结论 以太坊的账户以Hash散列与RLP数据编码为基础，结合智能合约的数据对象映射和转换，将Key-Value的数据以MPT的方式进行组织，计算StorageRoot唯一证明并保存于账户模型。最终形成Storage和Account两种MPT，并将MPT的所有节点以Key-Value的形式存储于NoSQL数据库中。这样的编码存储方式可以快速的校验智能合约和账户数据是否发生了变更，进而只需要对比MPT根节点的差异就可以快速校验区块链上分布式节点数据的一致性。 &nbsp; 后记 在深刻理解了以太坊的存储模型和原理机制后，可以在某些方面扩展以太坊的能力实现更加丰富的功能集。例如： &nbsp; 1. 实现可视化的工具，完成对以太坊LevelDB数据库的数据解析和呈现。借助智能合约的存储定义，结合账户的StorageRoot遍历LevelDB数据库中的Key-Value键值对，根据编码规则实现数据逆向分析和展示，为DApp应用的开发调试提供更加方便快捷的数据操作。 &nbsp; 2. 智能合约的升级一直是一件令开发者颇为头疼的事情，如何保证在完成智能合约的缺陷升级后还能维系访问原有的留存数据就是一个切实的痛点。借助对智能合约的存储机制，可以考虑在以太坊中扩展功能，支持智能合约的升级，并将原有的智能合约StorageRoot迁移复制给升级后的智能合约账户。在满足特定的数据定义要求下，可以达到智能合约升级后的数据平滑迁移效果。 &nbsp; 3. 以太坊的数据存储方案并不是最完美的解决方案，因为MPT的特性，海量数据存储账户的更新操作会带来指数级的数据存取，这样会让以太坊的智能合约执行变得非常低效。是否存在可能的解决方案，将海量的数据存储脱离MPT的方式的，提升数据存取的效率，是值得思考的一个问题。 &nbsp; 上述的内容只是在以太坊数据存储模型上的简单思考和一些引子，起到抛砖引玉的效果。希望读者能有更新颖的想法和灵感。 &nbsp; 作者简介：邓福喜，矩阵元技术（深圳）有限公司的系统架构师。作者在分布式系统和互联网应用的架构设计与研发方面有10多年的从业经验，目前主要从事区块链底层技术平台的设计与研发工作，邮箱dengfuxi@juzix.io。 本文首发《程序员》 热门文章 区块链：诞生于草根的时尚 孟岩：我反对将Token翻译成“代币” “矿工”年入千万成历史，强监管下比特币还能走多远？ 深度解析区块链架构、跨链和演进 人才稀缺的区块链，程序员转型入门必看这四项技能 对话元道：通证经济需要“互链网”，“互链网”需要细腰 今天，这几位区块链大咖旗帜鲜明地亮出“通证派”，原来这才是他们期盼中的未来交易的模样... 与元道对话三：区块链经济正在进行“动力切换” 锐评：泡沫中的token和被冷落的联盟链 对话元道二：通证视角下的区块链创新路线 听听Vitalik对token设计的看法 了解更多区块链技术及应用内容，敬请关注： 阅读更多","@type":"BlogPosting","url":"/2018/02/10/67bd262194b1a782dff944549783375e.html","headline":"听说懂以太坊开发的程序员都被抢疯了！分享一篇价值10万的文章，来自10年经验的大咖对以太坊数据存储的思考与解读","dateModified":"2018-02-10T00:00:00+08:00","datePublished":"2018-02-10T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/02/10/67bd262194b1a782dff944549783375e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>听说懂以太坊开发的程序员都被抢疯了！分享一篇价值10万的文章，来自10年经验的大咖对以太坊数据存储的思考与解读</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div class="rich_media_content" id="js_content"> 
   <blockquote>
    <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(0,122,170);">本文从存储结构的角度，解读以太坊的智能合约和账户数据模型的编码实现方案。借助这些实现方案的解读，可以对以太坊的数据模型、存储结构、编码方式、共识原理等知识有更加深入的了解，对基于以太坊的开发实施和问题定位有一定借鉴作用。&nbsp;</span></strong><strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(0,122,170);">﻿</span></strong></p>
   </blockquote>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;"></span></p>
   <p><img style="visibility:visible !important;" src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmqN2eNpBkV2LAARiapJ9pHCWOYiaz2G1vSXpqkR6nnArXLLTWzTor5bCQ/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1" alt="640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1"></p>
   <p style="margin-left:8px;line-height:1.75em;"><br><span style="letter-spacing:.5px;font-size:15px;"></span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="color:rgb(136,136,136);"><strong><span style="letter-spacing:.5px;font-size:20px;">打</span></strong><span style="font-size:15px;letter-spacing:.5px;">开拉勾网，输入区块链工程师一职，月薪平均在30K左右。</span></span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;color:rgb(136,136,136);"><br></span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;color:rgb(136,136,136);">但无论什么公司，无论什么岗位，无一例外有这么一句“熟悉以太坊区块链技术原理、机制的优先”。如今，会以太坊开发技术的程序员，俨然成为各大公司争抢的宝贝，而如果技术出众，更是被高薪团团围住。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;color:rgb(136,136,136);"><br></span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;color:rgb(136,136,136);">而你呢，看了那么多以太坊相关资料，能实操能实战，凝结了资深大咖思考与经验精华的又有多少？看完了还是一头雾水，一脸困惑。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;color:rgb(136,136,136);"><br></span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;color:rgb(136,136,136);">本篇文章就是为你的困惑而准备的。作者邓福喜主要从事区块链底层技术平台的设计与研发工作，有10多年的开发经验，他的经验与思考，是一份价值10万的知识大餐，以下，希望对你有所帮助。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><br></p>
   <p style="margin-left:8px;line-height:1.75em;"><br></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:20px;"><strong><span style="letter-spacing:.5px;color:rgb(0,122,170);">以</span></strong></span><span style="letter-spacing:.5px;font-size:15px;">太坊作为公开区块链技术平台，因为其良好的扩展性和灵活度，有很强的业务适用场景，这主要归功于其图灵完备的虚拟机与其上运行的智能合约。以太坊通过特定的编码方式实现对智能合约与账户数据的编码存储，同时又能在其数据基础上实现对区块与交易执行结果的完备共识证明。以下分几个部分来详细阐述。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="line-height:22px;font-size:18px;"><strong><span style="letter-spacing:.5px;font-size:18px;">以太坊RLP编码</span></strong></p>
   <p style="margin-left:8px;line-height:1.75em;"><br></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;">RLP（Recursive Length Prefix）编码是以太坊中数据序列化的一个主要编码方式，可以将任意的嵌套二进制数据进行序列化。</span></strong><span style="letter-spacing:.5px;font-size:15px;">以太坊中针对RLP的编码规则定义如下：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;">1. 如果是一个单字节并且其值在[0x00,0x7f]范围内，RLP编码就是自身。</span></strong></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;">2. 否则，如果一个数据串的字节长度是0-55字节，那么它的RLP编码是在数据串开头增加一个字节，这个字节的值是0x80加上数据串的字节长度。因此增加的该字节的取值范围为[0x80, 0xb7]。</span></strong></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;">3. 如果一个数据串的字节长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xb7加上数据串字节长度的二进制编码的字节长度，然后依次跟着数据串字节长度部分和内容部分。</span></strong><span style="letter-spacing:.5px;font-size:15px;">比如：一个长度为1024字节的数据串，其字节长度用16进制表示为0x0400，长度为2个字节，因此RLP编码头字节的值为0xb9（0xb7 + 0x02），然后跟着两字节为0x0400，后面再加上数据串的具体内容。因此增加的首字节的取值范围为[0xb8, 0xbf]，因此其能编码的最大数据长度为2^56。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;">4. 如果是一个嵌套的列表数据，则需要先将列表中的数据按照单元素的编码规则进行RLP编码后串联得到列表数据的payload。</span></strong><span style="letter-spacing:.5px;font-size:15px;">如果一个列表数据的payload的字节长度为0-55，那么列表的RLP编码在其payload前加上一个字节，这个字节的值是0xc0加上payload的字节长度。因此首字节的取值范围为[0xc0, 0xf7]。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;">5. 如果一个列表数据的payload的长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xf7加上列表payload字节长度的二进制编码的字节长度，然后依次跟着payload字节长度部分和payload部分。</span></strong><span style="letter-spacing:.5px;font-size:15px;">因此首字节的取值范围为[0xf8, 0xff]，因此一个列表中存储的所有元素的字节长度不能超过2^56。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">如下是一些RLP编码的参考样例。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmWEsqS9Yhoa5YwMYPHt7ibcXPNoCVdEOBvicuDOI4AXPxIa0KJhZPxAWQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">表1 &nbsp;RLP编码样例</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="line-height:22px;font-size:18px;"><strong><span style="letter-spacing:.5px;font-size:18px;">以太坊MPT</span></strong></p>
   <p><br></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">MPT（Merkle Patricia Tree）是以太坊用来将Key-Value进行紧凑编码的一种数据组织形式。基于该数据组织形式，MPT上任何存储数据的细微变化都会导致MPT的根节点发生变更，因此可以校验数据的一致性。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;">在MPT中，存在如下三类节点。</span></strong></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></strong></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(0,122,170);">1. 叶子节点</span></strong><span style="letter-spacing:.5px;font-size:15px;">：用于数据存储的节点。其Key值是一个对应插入数据的特殊16进制编码（需要剔除掉从根节点到当前叶子节点的前缀部分内容），Value值对应插入数据的RLP编码。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(0,122,170);">2. 扩展节点：</span></strong><span style="letter-spacing:.5px;font-size:15px;">扩展节点用来处理具有共同前缀的数据，通过扩展节点可以扩展出一个多分叉的分支节点。其Key值存储的是共同的前缀部分的16进制，Value值存储的是扩展出的分支节点的hash值（sha3（RLP（分支节点数据List）））。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(0,122,170);">3. 分支节点：</span></strong><span style="letter-spacing:.5px;font-size:15px;">由于MPT存储的Key是16进制的编码数据，那么在不具备共同前缀时就通过分支节点进行分叉。分支节点的key是一个16个数据的数组，数组的下标对应16进制的0-F，用来扩展不同的数据。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">数组中存储的的是分叉节点的hash值，同时数组的下标也对应一个数据的一个16进制位（4bit）。分支节点的Value一般为空，如果有数据的Key值在其上的扩展节点终止，那么数据Key对应的Value值则存储在分支节点的Value属性上。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">扩展节点和叶子节点的Key值前面存在一个4bit或者8bit nibble，用来标示节点类型和后续的数据长度的奇偶性（原始数据Key值16进制后长度为偶数，但是经过扩展节点和分支节点的前缀剔除后剩下的长度可能是奇数，也可能为偶数）。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><br></p>
   <p><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmPx5ykgqde2H6X5bbJljlgH3vo9sBHIb7D2WddET0WTb4Gkdsibvfic2Q/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">表2 Nibble取值含义</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">如下是一个样例数据的MPT形象化表示：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span></p>
   <p><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmZLJnJecyHJTmcqKsf097HAKvZVGoUrGBa4neMOkAg3fmf0D9cyDtjQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">图1 &nbsp;MPT样例结构</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">该图中蓝色标注的为分支节点；橙色标注的为扩展节点；绿色标注的为叶子节点。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">上述样例结构中存储的是如下的Key-Value原始数据：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="text-align:center;"><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmgS7Py9ct33l4trnqRtENrw9oXQShOSZic2c1zPXk1aH9y1TwHR30JpQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">表 3 原始样例数据</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">在MPT树上节点存储的数据是原始数据的如下映射：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key = sha3(原始数据key)</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value = RLP(原始数据Value)</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">因此在上述样例MPT中，存储的节点数据为如下表格所示：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmIPhfgsvt1xz36Cukw8TfcKpX7B7u87LjwgxZ9RXB4l28WUElluc4ZA/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">表4 &nbsp;MPT节点数据</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">上述数据的插入过程如下：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">a. 插入[“00000000000000000000000000000022”, 22]</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">1. 将key值进行sha3求hash值得到0x8B2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30，将value计算RLP得到0x16</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">2. 由于当前没有任何节点，则直接生成一个新的叶子节点，将该节点作为根节点。由于MPT key值长度为偶数，所以在MPT key值前增加16进制nibble值20，得到的树如下：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmuhAfalYxcaibvaS1vaf4XVzEuAIDXCeoLcehibTBHApBaHRofkHHWRPQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">图2 &nbsp;One Node</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">b. 插入[“00000000000000000000000000000023”, 23]</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">1. 将key值进行sha3求hash值得到0x5976CAE7AF706E65E5272E8C98FB867F1801F3408562AA73D259A27CAC334D78，将value计算RLP得到0x17。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">2. 当前树只有一个叶子节点，并且两个key的hash值没有公共前缀（一个以8开头，一个以5开头），因此增加一个分支节点用以扩展不同前缀的节点，并且构造两个新的叶子节点挂在分支节点下面。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">3. 将上述value为22的key值hash取16进制的首位得到8，那么将key值去掉1位得到0xB2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30，去掉1位后由于长度为奇数，那么增加16进制的nibble值3，得到新的叶子节点[0x3B2BDF72270B4653BD1D26471922392BAAC8AD73F2BF1BCE939D78C6D2044C30, 0x16] 。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">4. 将上述新得到的叶子节点作为RLP List进行编码，并计算hash值得到 0xDDCB61885A1C577BE083824D6761932FDCF0A496072A5932B021CD801F65076D，将得到的hash值填入父分支节点的第8位（原有hash值首字符为8）。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">5. 同理计算value为23的节点，得到新的叶子节点[0x3976CAE7AF706E65E5272E8C98FB867F1801F3408562AA73D259A27CAC334D78, 0x17]，并计算RLP编码的hash值0xB5BB9644C549233F9B3D462844E565AE9A5EF2D0687DB8739B3FEA5B1260FACF并填入父分支节点的第5位（原有hash值首字符为5）。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">6. 得到新的树结构如下：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span></p>
   <p><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmFnQziadBOXk8LoKHk4Vbjaar7mVibnia4Kye65bWbNH9Oc6d7ibBHDp8ibA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">图3 &nbsp;Two Nodes</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">c. 插入[“00000000000000000000000000000024”, 24]</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">1. 按照相同的计算规则插入value为24的节点，由于没有共同的前缀，所以在分支节点第12位下增加一个新的叶子节点。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">2. 得到新的树结构如下：</span><span style="font-size:15px;letter-spacing:.5px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span></p>
   <p><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmNypNB5FN6tufctFiad1TKS6ZggJpw9Zmv4pxsYACSGQKZXNAUMicBexw/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span><br></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">图4 &nbsp;Three Nodes</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">d. 插入[“00000000000000000000000000000025”, 25]</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">1. 按照相同的计算规则插入value为25的节点，由于没有共同的前缀，所以在分支节点第13位下增加一个新的叶子节点。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">2. 得到新的树结构如下：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span></p>
   <p><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmpSe6dBJQSZAG12ic03ddia4jAKIAWmpia7hjgsBL9vPRgaJfbcW6c3woA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span><br></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">图5 &nbsp;Four Nodes</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">e. 插入[“00000000000000000000000000000026”, 26]</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">1. 将key值进行sha3求hash值得到0xC4D13FBA6CFB72A7455EB8EDF262434C55D24DC9674D58B4AE05A89EE83F9321，将value计算RLP得到0x1A。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">2. 根据hash值得首字符“C”查找根节点的插入点为分支节点的第12位，由于在第12位存在了相同的节点（value值为24），由于去掉首字符“C”后还存在共同的前缀“4”，则需要增加一个扩展节点用来存储共同前缀“4”，并且在扩展节点下增加一个分支节点用来扩展后续的不同部分。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">3. 将上述value为24的key值hash去掉共同的前缀“C4”并增加nibble后得到节点[0x3F06F103C7FB2579CFA08AF8536B03DE8DA3C677F9F2A6FB397CBD1A775273, 0x18]，求其节点RLP的hash值填入新增加分支节点的第11位（去掉共同前缀“C4”后的首字符为B）。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">4. 按照相同的计算规则构造value值为26的叶子节点[0x313FBA6CFB72A7455EB8EDF262434C55D24DC9674D58B4AE05A89EE83F9321, 0x1A]，求其节点RLP的hash值填入新增加分支节点的第13位（去掉共同前缀“C4”后的首字符为D）。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">5. 调整完上述两个叶子节点后，得到新的分支节点，并计算新的分支节点的RLP Hash值0xD7C0D0160345D3EF2F758D15598965BE1A2C71682995890C5341171EF72A54B2作为value值填入父扩展节点的value部分。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">6. 新增加的扩展节点保留共同的前缀“4”（剔除其父分支节点的共同部分“C”），并增加16进制nibble值1，得到其MPT key值为0x14。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">7. 计算新的扩展节点的RLP hash值0x7DADADF4464529492D2C475DA62C1F64FAAE150A7355E921E805CF82B5E90A69填入其父分支节点的第12位。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">8. 得到新的树结构如下：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span></p>
   <p><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmJabDEu0982vp2V3hS6Q3tAIW9cBe2QiasnDQVr0bJTFFguEsDLC3LuA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">图6 &nbsp;Five Nodes</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">上述过程是通过新增节点构建一个MPT的过程，存储数据的更新和删除逻辑就不在此累述，读者可以举一反三进行类推。<strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(0,122,170);">需要注意的是任何数据的更新操作都需要先基于树的检索路径找到对应的节点进行更新，并且从该节点逐层向上调整检索路径上的所有节点直至根节点，中间有可能会涉及到节点类型的调整和节点的合并。</span></strong></span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="line-height:22px;font-size:18px;"><strong><span style="letter-spacing:.5px;font-size:18px;">以太坊合约存储规则</span></strong></p>
   <p class="shifubrush"><br></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;"></span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">以太坊提供了一种图灵完备的虚拟机与智能合约编写规则。我们可以在智能合约中定义复杂的数据模型以及在该数据模型上执行的一系列函数操作。我们知道，以太坊是以Key-value的形式来存储数据的，那么智能合约的复杂数据结构是如何映射到这样的键值对上的呢？</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">以太坊采用如下的编码规则来将数据结构定义和数据值映射成Key-Value：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">1. 智能合约的任何结构都会被映射成[key, value]的形式，其中key和value均是无符号32字节的数据。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">2. 所有的存储成员按照成员定义位置从0开始索引编排，每次累加1，作为其对应的key值进行存储。Value为具体的成员属性值。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">3. 固定长度数据类型（例如：uint8、uint16、uint32、enum）Value按照32字节右对齐的原则。相邻的存储成员如果其长度不满足32字节，则会将Value进行压缩合并存储。例如如下的变量定义和数据取值：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">enum a = 1; </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">uint8 b = 15; </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key:0x00000000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">00000000000000000000000000000 </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Valu0x00000000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">4. 可变长度数据类型（例如：string、bytes）按照左对齐的原则进行编码，如果其长度不大于31字节，则按照一条记录存储，该记录Value的最后一个字节存储其可变内容的实际长度，例如如下的变量定义和数据取值：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">string a = "123"; </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key:0x0000000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">000000000000000000000000000000 </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value:0x31323300000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">00000000000000000000000000000006</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">5. 如果可变长度类型变量的数据内容长度超过31字节，则将会被拆分成多条记录进行存储。第一条记录的key值为其索引编号，Value值为其实际数据长度加1；然后将内容按照32字节拆分成多条记录，每条记录的key值为首条记录key值进行sha3后得到的hash值从0开始每次累加1得到，value值为拆分的内容部分。例如如下的变量定义和数据取值：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">string a = "1234567890123456789012345678</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">901234567890"; </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key1:0x000000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">0000000000000000000000000000000 </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value1:0x0000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">000000000000000000000000000000051</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key2:sha3(0x0000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">000000000000000000000000000000000000) </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value2:0x3132333435363738393031323334353</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">637383930313233343536373839303132</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key3:sha3(0x0000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">000000000000000000000000000000000000)+1 </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value3:0x33343536373839300000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">00000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">6. 针对结构体定义，可以看成将结构体扩展到结构变量定义位置的索引编号进行累加。例如如下的变量定义和数据取值：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">struct Data</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">{</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">string name;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">int age;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">}</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">string a = "1234567890";</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Data d;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">d.name = "1234567890";</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">d.age = 3224115;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key1:0x000000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">0000000000000000000000000000000 </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value1:0x3132333435363738393031323334353</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">637383930000000000000000000000014</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key2:0x000000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">0000000000000000000000000000001</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value2:0x313233343536373839303132333435</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">3637383930000000000000000000000014</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key3:0x000000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">0000000000000000000000000000002 </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value3:0x0000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">000000000000000000000000000313233</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">7. 针对数组定义，则需要扩展多条记录。第一条记录Key值为数组变量的索引，Value值为数组的元素个数。后续则根据数组的元素增加多条记录，每条记录的Key值在首条记录的Key值上做sha3得到hash值从0开始每次累加1，Value值为数组元素的对应值。例如如下的变量定义和数据取值：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">string[] cources;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">cources[0] = "123";</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">cources[1] = "456";</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key1:0x0000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">000000000000000000000000000000000 </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value1:0x0000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">000000000000000000000000000000002</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key2:sha3(0x0000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">000000000000000000000000000000000000) </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value2:0x3132330000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">000000000000000000000000000000006</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key3:sha3(0x000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">0000000000000000000000000000000000000)+1</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value3:0x343536000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">0000000000000000000000000000000006</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">8. 针对Map数据定义，其key值则为map key值加上变量索引进行sha3取hash值。例如如下的变量定义和数据取值：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">string a;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">mapping(string =&gt; string) r; </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">mapping(string =&gt; int) s;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">r["abc"] = "123";</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">r["def"] = "123";</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">s["abc"] = 123;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key1:sha3(0x61626300000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">00000000000000000000000000000000000000001)</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value1:0x313233000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">0000000000000000000000000000006</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key2:sha3(0x64656600000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">00000000000000000000000000000000000000001) </span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value2:0x3132330000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">000000000000000000000000000006</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Key3:sha3(0x616263000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">0000000000000000000000000000000000000002)</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">Value3:0x00000000000000000000000000000000</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">0000000000000000000000000000007b</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="line-height:22px;font-size:18px;"><strong><span style="letter-spacing:.5px;font-size:18px;">以太坊账户结构</span></strong></p>
   <p style="margin-left:8px;line-height:1.75em;"><br></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">在以太坊中，账户信息以Key-Value的形式存储在区块链的数据库中，每个账户通过一个唯一的地址编码作为Key进行标示，Value存储该账户的相关属性、账户余额、合约代码标示、合约存储标示。其结构如下：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span></p>
   <p><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmULgBicmgwkPFjF4ib0z0ErfFMksicNZmM8e8vosCUNhYYSUr9DfzWJg0A/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">图7 &nbsp;账户结构</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">1. Address：账户地址，与用户私钥唯一对应的一组20字节的数据串。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">2. Nonce：用户账户对应的的交易序列号，每次成功执行交易后累加1。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">3. Balance：用于账户对应的账户余额，以wei为单位（1 eth = 1018 wei）。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">4. StorageRoot：仅在合约账户上该属性有效，标示合约存储结构的MPT树根节点hash值。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">5. CodeHash：仅在合约账户上该属性有效，标示合约代码对应的Hash值。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">任何一个以太坊的账户都可以基于其地址在以太坊的数据库中按照MPT树的检索规则找到对应的一条账户存储记录。检索的Key值为账户地址的hash值，检索到的Value值是上述结构的一个RLP编码数据串，可以基于RLP的编码规则逆向解析出其对应的属性值。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="line-height:22px;font-size:18px;"><strong><span style="letter-spacing:.5px;font-size:18px;">以太坊的数据库存储</span></strong></p>
   <p style="margin-left:8px;line-height:1.75em;"><br></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">以太坊用NoSQL数据库以Key-Value的形式存储所有的数据。针对账户数据结构，需要存储的数据主要包含智能合约的Storage和基本的账户信息。对应的存储规则如下：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">1. 针对智能合约Storage，将数据按照编码规则映射成MPT，然后将MPT的所有节点的Key和Value构建一个RLP List编码作为数据库存储的Value值，将该Value值进行Sha3计算hash值作为数据库存储的Key值进行存储。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">2. 针对基本账户信息，将其对应智能合约Storage的MPT Root Hash保存于账户的StorageRoot属性，然后将系统中的所有Account构建一个MPT。按照和Storage的数据库存储方式将MPT的所有节点进行存储。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">上述构建的两个MPT树的结构如图8。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/trm5VMeFp9lvibg2jwDAAeiaKoCerVJlgmQlEicpknPzBzEiaYaK6As2bY3GHHGxwIY9bGXzHDXAANSnzlEgxNibLPQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">﻿</span></p>
   <p style="margin-left:8px;line-height:1.75em;text-align:center;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">图8 &nbsp;Account &amp; Storage MPT</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;"></span></p>
   <p style="text-align:center;border:none;margin-left:8px;line-height:1.75em;"><br></p>
   <p style="line-height:22px;font-size:18px;"><strong><span style="letter-spacing:.5px;font-size:18px;">结论</span></strong></p>
   <p style="text-align:center;"><br></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;">以太坊的账户以Hash散列与RLP数据编码为基础，结合智能合约的数据对象映射和转换，将Key-Value的数据以MPT的方式进行组织，计算StorageRoot唯一证明并保存于账户模型。最终形成Storage和Account两种MPT，并将MPT的所有节点以Key-Value的形式存储于NoSQL数据库中。这样的编码存储方式可以快速的校验智能合约和账户数据是否发生了变更，进而只需要对比MPT根节点的差异就可以快速校验区块链上分布式节点数据的一致性。</span></strong></p>
   <p style="margin-left:8px;line-height:1.75em;"><strong><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></strong></p>
   <p style="line-height:22px;font-size:18px;"><strong><span style="letter-spacing:.5px;font-size:18px;">后记</span></strong></p>
   <p><br></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;"></span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">在深刻理解了以太坊的存储模型和原理机制后，可以在某些方面扩展以太坊的能力实现更加丰富的功能集。例如：</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">1<strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(0,122,170);">. 实现可视化的工具，完成对以太坊LevelDB数据库的数据解析和呈现。</span></strong>借助智能合约的存储定义，结合账户的StorageRoot遍历LevelDB数据库中的Key-Value键值对，根据编码规则实现数据逆向分析和展示，为DApp应用的开发调试提供更加方便快捷的数据操作。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">2. <strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(0,122,170);">智能合约的升级一直是一件令开发者颇为头疼的事情，如何保证在完成智能合约的缺陷升级后还能维系访问原有的留存数据就是一个切实的痛点。</span></strong>借助对智能合约的存储机制，可以考虑在以太坊中扩展功能，支持智能合约的升级，并将原有的智能合约StorageRoot迁移复制给升级后的智能合约账户。在满足特定的数据定义要求下，可以达到智能合约升级后的数据平滑迁移效果。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">3. <strong><span style="letter-spacing:.5px;font-size:15px;color:rgb(0,122,170);">以太坊的数据存储方案并不是最完美的解决方案，因为MPT的特性，海量数据存储账户的更新操作会带来指数级的数据存取，这样会让以太坊的智能合约执行变得非常低效。</span></strong>是否存在可能的解决方案，将海量的数据存储脱离MPT的方式的，提升数据存取的效率，是值得思考的一个问题。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">上述的内容只是在以太坊数据存储模型上的简单思考和一些引子，起到抛砖引玉的效果。希望读者能有更新颖的想法和灵感。</span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;">&nbsp;</span></p>
   <blockquote>
    <p style="margin-left:8px;line-height:1.75em;"><span style="letter-spacing:.5px;font-size:15px;color:rgb(136,136,136);">作者简介：邓福喜，矩阵元技术（深圳）有限公司的系统架构师。作者在分布式系统和互联网应用的架构设计与研发方面有10多年的从业经验，目前主要从事区块链底层技术平台的设计与研发工作，邮箱dengfuxi@juzix.io。</span></p>
    <p style="margin-left:8px;line-height:1.75em;"><span style="color:#888888;"><span style="font-size:15px;letter-spacing:.5px;">本文首发《程序员》</span></span></p>
   </blockquote>
   <p><br></p>
   <p><br></p>
   <p><br></p>
   <p><br></p>
   <p style="min-height:1em;line-height:22px;font-size:18px;"><span style="letter-spacing:.5px;">热门文章</span></p>
   <p><br></p>
   <p><br></p>
   <ul class="list-paddingleft-2" style="list-style-type:disc;">
    <li><p style="font-size:16px;min-height:1em;color:rgb(62,62,62);background-color:rgb(255,255,255);"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247484197&amp;idx=1&amp;sn=04f9fd8aa3c24cbbcaa9f6eee0ea882b&amp;chksm=fc7c5dd8cb0bd4ceeb6b00ee3268aa0224d2927f40bbc8bb1d1925930f9d7902de9d497cfbc4&amp;scene=21#wechat_redirect" rel="nofollow">区块链：诞生于草根的时尚</a><br></p></li>
    <li><p style="font-size:16px;min-height:1em;color:rgb(62,62,62);background-color:rgb(255,255,255);"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247484186&amp;idx=1&amp;sn=88e4a22ab40641afa5101c324c510ff7&amp;chksm=fc7c5de7cb0bd4f1675093e7a385d57e00e056fe6b084f94063a3dad208d93aa0aea05440a57&amp;scene=21#wechat_redirect" rel="nofollow">孟岩：我反对将Token翻译成“代币”</a><br></p></li>
    <li><p style="font-size:16px;min-height:1em;color:rgb(62,62,62);background-color:rgb(255,255,255);"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247484178&amp;idx=1&amp;sn=cc2bafd68942474c255e346e9edc3191&amp;chksm=fc7c5defcb0bd4f9f3ceba3837f1cebd847ae7d7b73d97484260cd888d1e3d70a7f19aec9851&amp;scene=21#wechat_redirect" rel="nofollow">“矿工”年入千万成历史，强监管下比特币还能走多远？</a><br></p></li>
    <li><p style="font-size:16px;min-height:1em;color:rgb(62,62,62);background-color:rgb(255,255,255);"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247484171&amp;idx=1&amp;sn=fb31a86654396c0f04663a7710c631fd&amp;chksm=fc7c5df6cb0bd4e015cb441e9dc7eda2417e2dcb6fc5b73d7673427def48cba4a257d417da54&amp;scene=21#wechat_redirect" rel="nofollow">深度解析区块链架构、跨链和演进</a><br></p></li>
    <li><p style="min-height:1em;line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247484159&amp;idx=1&amp;sn=3f7241490a9cd0694538b6ff81043d70&amp;chksm=fc7c5c02cb0bd514c892da106319f11d786bb87679c80c86615df5f2cdeea253edb04c376f2f&amp;scene=21#wechat_redirect" rel="nofollow" style="text-align:justify;">人才稀缺的区块链，程序员转型入门必看这四项技能</a><br></p></li>
    <li><p style="min-height:1em;text-align:justify;line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247484074&amp;idx=1&amp;sn=3a88bc647c6f7d65afbd1b5e44ca9824&amp;chksm=fc7c5c57cb0bd5414580b744495b05d15dceaa646a6dedc1753d14140ad9ac5ebb00e8f943a1&amp;scene=21#wechat_redirect" rel="nofollow">对话元道：通证经济需要“互链网”，“互链网”需要细腰</a></p></li>
    <li><p style="min-height:1em;text-align:justify;line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247484070&amp;idx=1&amp;sn=7efbec2eaa16598e805592942e378c19&amp;chksm=fc7c5c5bcb0bd54da3501517617a4d62e891e2ecf691ebe40f6fa3b557766cef49084122dea3&amp;scene=21#wechat_redirect" rel="nofollow">今天，这几位区块链大咖旗帜鲜明地亮出“通证派”，原来这才是他们期盼中的未来交易的模样...</a></p></li>
    <li><p style="min-height:1em;text-align:justify;line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247484051&amp;idx=1&amp;sn=0d7d8e2a4cae402002a2016983adb312&amp;chksm=fc7c5c6ecb0bd57819cc432d1c1d3b259c9962e17616b4778da62b6e077384177b582cbbf395&amp;scene=21#wechat_redirect" rel="nofollow">与元道对话三：区块链经济正在进行“动力切换”</a><br></p></li>
    <li><p style="min-height:1em;text-align:justify;line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247484035&amp;idx=1&amp;sn=e590bd609e0890bceebdbc975cac339a&amp;chksm=fc7c5c7ecb0bd56803349d427b63fd5100d9d9d12bf0dcbd5ec39ce3fe7664531e843dad37d1&amp;scene=21#wechat_redirect" rel="nofollow">锐评：泡沫中的token和被冷落的联盟链</a><br></p></li>
    <li><p style="min-height:1em;text-align:justify;line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247483992&amp;idx=1&amp;sn=c59d84da9ddc997dcd04b3c68da009fb&amp;chksm=fc7c5ca5cb0bd5b3cfc946587444fe2bb371a563e3a6b94620619d0e6d9ed419fc754ecbb7df&amp;scene=21#wechat_redirect" rel="nofollow">对话元道二：通证视角下的区块链创新路线</a><br></p></li>
    <li><p style="min-height:1em;text-align:justify;line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247483974&amp;idx=1&amp;sn=53411524d4573a99173c1d19586a41ac&amp;chksm=fc7c5cbbcb0bd5ad2141c0c13c013ec5bfc7640483d7eb3535f849783ff9c1fdbfb1fe2529c6&amp;scene=21#wechat_redirect" rel="nofollow">听听Vitalik对token设计的看法</a></p></li>
   </ul>
   <p style="margin-left:8px;font-size:16px;min-height:1em;color:rgb(62,62,62);background-color:rgb(255,255,255);line-height:1.75em;"><br></p>
   <p style="margin-left:8px;font-size:16px;min-height:1em;color:rgb(62,62,62);background-color:rgb(255,255,255);line-height:1.75em;"><img class="__bg_gif" style="margin-left:auto;display:block;visibility:visible !important;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/trm5VMeFp9kuuGYcoeg06IYM4TSEE1eCF4aiadptTMnNFDia5JfEBLuUslraYtDcYbKr2b4takjM2MfqeZYcVqkQ/640?wx_fmt=gif" alt="640?wx_fmt=gif"></p>
   <p style="margin-left:8px;font-size:16px;min-height:1em;color:rgb(62,62,62);background-color:rgb(255,255,255);line-height:1.75em;"><br></p>
   <p style="margin-left:8px;font-size:16px;min-height:1em;color:rgb(62,62,62);background-color:rgb(255,255,255);line-height:1.75em;"><span style="letter-spacing:.5px;"><strong><span style="font-size:14px;color:rgb(0,122,170);">了解更多区块链技术及应用内容，敬请关注：</span></strong></span></p>
   <p style="font-size:16px;min-height:1em;color:rgb(62,62,62);background-color:rgb(255,255,255);"><br></p>
   <p style="margin-left:8px;font-size:16px;min-height:1em;color:rgb(62,62,62);background-color:rgb(255,255,255);text-align:center;line-height:1.75em;"><img class="img_loading" style="visibility:visible !important;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/trm5VMeFp9mxakm4VPrgL8icicHWiaqWk0wccvxK7y28BUZtwpHtZLlEjAuvnwzRp3to3EBRSdA9ozn4frxxibwdQQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p><br></p> 
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Blockchain_lemon/article/details/79308137,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Blockchain_lemon/article/details/79308137,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
