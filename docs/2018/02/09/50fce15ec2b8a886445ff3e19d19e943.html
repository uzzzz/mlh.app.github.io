<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>干货 手把手教你快速撸一个区块链 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="干货 手把手教你快速撸一个区块链" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本篇文章由万云团队编译原文链接：http://mp.weixin.qq.com/s/5-O...如需转载请联系万云官方微信：万云Wancloud 2018年的门刚打开，区块链的火就烧成了火焰山。徐小平放言要拥抱区块链，朋友圈刷屏不止，连上班地铁上都能听到区块链，一夜起，区块链成了茶前饭后的谈资。于是乎，那个经常听到的问题又开始抓耳挠腮：区块链到底是什么鬼？关注的订阅号不停推送“一篇文章让你搞懂区块链”，“三分钟Get区块链”等不尽相同的内容，声音从四面八方聚焦到你耳边。 万云也在思考能为想了解区块链的老铁们做点什么，鉴于已有如此多区块链概念普及文，此次我们不聊枯燥的概念，而是回归区块链“技术”，一步步认真教你获得一个属于自己区块链。放心，只要你稍微懂一点技术，你就可以实现并拥有它。 || 以下翻译自Daniel van Flymen的《Learn Blockchains by Building One》，有所删改。|| 原文地址：https://hackernoon.com/learn-... 前言 概念了解：在开始前你需要知道，区块链是一种按时间将数据区块以顺序相连的方式组合在一起的链式数据结构，并通过密码学来保证其不可篡改和不可伪造的分布式账本。这些区块可以包含交易、文件以及任何你想要的数据，重要的是它们通过哈希链接在一起。目标读者：可以轻松地阅读和编写一些基本的Python，并且对HTTP有一些了解。所需工具：Python 3.6+、Flask、Requests：pip install Flask==0.12.2 requests==2.18.4&nbsp;除此之外还需安装HTTP工具，如Postman、cURL。源代码地址：https://github.com/dvf/blockc... 第一步：建立区块链①实现一个Blockchain类打开一个你常用的文本编辑器或者IDE，新建一个blockchain.py的python文件，并创建一个Blockchain类，在构造函数中创建两个空的队列，一个用于存储区块链，另一个用于存储交易。下面是Blockchain类的模板代码： class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass 我们所创建的Blockchain类将用来管理链，它会存储交易，并且提供一些方法来帮助添加新的区块到链。下面是详细的实现方法。 每个区块所包含5个基本属性：index，timestamp (in Unix time)，交易列表，工作量证明和前一个区块的哈希值。我们来看一个例子： block = { &#39;index&#39;: 1, &#39;timestamp&#39;: 1506057125.900785, &#39;transactions&#39;: [ { &#39;sender&#39;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;, &#39;recipient&#39;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;, &#39;amount&#39;: 5, } ], &#39;proof&#39;: 324984774000, &#39;previous_hash&#39;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot; } 到这里，我们对于链的概念应该比较清楚了，每个新的区块都会包含上一个区块的哈希值，从而让区块链具有不可篡改的特性。如果攻击者攻击了链中比较靠前的区块，则所有后面的区块将包含不正确的哈希值。如果不能理解，慢慢消化——这是理解区块链技术的核心思想。 ②将交易添加到区块 接下来我们实现一个将交易添加到区块的方法，继续看代码： class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 在new_transaction（）方法中向列表中添加一笔交易之后，它返回值是本次交易的index，该index会被添加到下一个待挖掘区块，后面在用户提交交易时也会用到。 ③建一个新的区块 当Blockchain被实例化后，我们需要创建一个创世区块，同时为我们的创世区块添加一个工作量证明，这是挖矿的结果，我们稍后会详细讨论挖矿。 除了创建创世区块的代码，我们还需要补充new_block（），new_transaction（）和hash（）的方法： import hashlib import json from time import time class Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; Create a new Block in the Blockchain :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; Creates a SHA-256 hash of a Block :param block: &lt;dict&gt; Block :return: &lt;str&gt; &quot;&quot;&quot; # We must make sure that the Dictionary is Ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 到此，我们的区块链已经基本上实现了雏形。这时候，你肯定想知道新区块是怎么被挖出来的，也就是我们通常所说的“挖矿”。 ④什么是工作量证明？ 想了解什么是“挖矿”，就必须理解工作量证明（POW）是什么。区块链上每一个新的区块都来自于工作量证明（POW），POW的目标是计算出一串解决问题的数字，这个结果众所周知是很难计算的，但却十分容易验证，因为网络上的任何人都能够验证这个结果，这是“工作量证明”背后的核心思想。 我们来看一个非常简单的例子帮助理解： 假设整数X乘以另一个整数y的哈希值必须以0结尾，hash(x * y) = ac23dc...0. 设x = 5.求y。我们用Python来实现： from hashlib import sha256 x = 5 y = 0 # We don&#39;t know what y should be yet... while sha256(f&#39;{x*y}&#39;.encode()).hexdigest()[-1] != &quot;0&quot;: y += 1 print(f&#39;The solution is y = {y}&#39;) 得到的答案是当y = 21，哈希值的结尾为0：hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，工作证明算法被称为Hashcash，这和我们上面所举的例子差不多，结果难于发现却易于校验。Hashcash是矿工为了创建一个新区块而争相计算的问题，计算难度通常取决于字符串中搜索的字符数，通常也会花费一定的时间才能计算得到，最终计算出来的矿工们会通过交易获得一定数量的比特币作为奖励。 ⑤实现一个基本的工作量证明 首先我们为Blockchain类实现一个类似的算法： 规则：找到一个数字p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。 import hashlib import json from time import time from uuid import uuid4 class Blockchain(object): ... def proof_of_work(self, last_proof): &quot;&quot;&quot; Simple Proof of Work Algorithm: - Find a number p&#39; such that hash(pp&#39;) contains leading 4 zeroes, where p is the previous p&#39; - p is the previous proof, and p&#39; is the new proof :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. &quot;&quot;&quot; guess = f&#39;{last_proof}{proof}&#39;.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; 通过修改前导零的数量，可以调整算法的难度，但是4个零完全足够了。你会发现，每当增加一个前导零，找到一个对应的解决方案与所需的时间之间会产生巨大的差异。 进行到这里，我们的Blockchain类已经基本完成，接下来我们实现HTTP服务进行交互。 第二步：区块链API我们将使用Python Flask框架，Flask是一个轻量级的Web应用框架，这使我们可以通过web服务来调用Blockchian类。 ①创建三个API： •/ transactions / new为区块创建一个新的交易 •/mine告诉我们的服务器开采新的区块。 •/chain返回整个区块链。 ②使用Flask 我们的“服务器”将基于Flask框架来实现区块链网络中的一个节点。 我们来添加一些模板代码： import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask class Blockchain(object): ... # Instantiate our Node app = Flask(__name__) # Generate a globally unique address for this node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # Instantiate the Blockchain blockchain = Blockchain() @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): return &quot;We&#39;ll mine a new Block&quot; @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): return &quot;We&#39;ll add a new transaction&quot; @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 以下是对上面添加的内容的进行简要说明： Line15：实例化Flask web服务节点。 Line18：为我们的服务节点创建一个随机的名称。 Line21：实例化Blockchain类。 Line24-26：创建一个路由为/mine的GET请求的，调用后端Blockchain的new block方法。 Line28-30：创建一个路由为/transactions/new的POST请求，将数据发送给后端Blockchina的new transaction方法。 Line32-38：创建一个路由为/chain的GET请求，将返回整个链。 Line40-41：在端口5000上运行服务器。 ③实现交易 下面是用户发起交易时发送到服务器的请求： { &quot;sender&quot;: &quot;my address&quot;, &quot;recipient&quot;: &quot;someone else&#39;s address&quot;, &quot;amount&quot;: 5 } 由于我们已经有了将交易添加到区块的方法，接下去就十分容易了。 下面我们来实现添加交易的函数： import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): values = request.get_json() # Check that the required fields are in the POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: f&#39;Transaction will be added to Block {index}&#39;} return jsonify(response), 201 ④实现挖矿 我们的挖矿方法是魔法发生的地方。它十分容易，只做三件事情：计算工作量证明；通过新增一笔交易奖励矿工一定数量的比特币；创建新的区块并将其添加到链中来。 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # We must receive a reward for finding the proof. # The sender is &quot;0&quot; to signify that this node has mined a new coin. blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain previous_hash = blockchain.hash(last_block) block = blockchain.new_block(proof, previous_hash) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 需要注意的是，开采块的交易接收者是我们自己服务器节点的地址，我们在这里所做的大部分工作只是与Blockchain类进行交互，基于以上我们区块链已经完成了，接下来开始交互演示。 第三步：交互演示您可以使用cURL或Postman与API进行交互。 启动服务器： $ python blockchain.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 尝试通过向http：// localhost：5000 / mine发出GET请求来挖掘区块： 创建一个新的交易，向http://localhost:5000/transactions/new发出一个POST请求： 也可以使用cURL发送请求： $ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{ &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 5 }&#39; &quot;http://localhost:5000/transactions/new&quot; 以上仅为交互演示的示例，你可以在你自己所完成的区块链上进行更多尝试。 第四步：共识机制我们有一个基本的区块链可以进行交易和挖矿，但其实区块链更重要的意义在于它们是分布式的。那么我们需要确保所有的节点都运行在同一条链上，这就是回归到了共识问题，如果要满足在网络上有多个节点并且不断增加，我们必须要实现共识算法。 ①注册新的节点 在实现共识算法之前，需要找到一种方式让网络上的节点知道其相邻的节点，每个节点都需要存储网络上其他节点的记录。因此，我们需要新增几个方法来帮助实现： 1./nodes/register接受URL形式的新节点列表。 / nodes / resolve来执行我们的共识算法，它可以解决任何冲突，确保节点具有正确的链。 　下面我们将修改Blockchain的构造函数以提供注册节点的方法： ... from urllib.parse import urlparse ... class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) 注意，我们使用set()集合来保存节点列表，这是确保新节点的添加是幂等的简便方法，这意味着无论我们添加特定节点多少次，它都只会出现一次。 ②实现共识算法 如前所述，当一个节点与另一个节点有不同时会发生冲突，为了解决这个问题，我们遵循取最长链原则，通过使用此算法，让网络中的节点间达成共识。 ... import requests class Blockchain(object) ... def valid_chain(self, chain): &quot;&quot;&quot; Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f&#39;{last_block}&#39;) print(f&#39;{block}&#39;) print(&quot;\n-----------\n&quot;) # Check that the hash of the block is correct if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def resolve_conflicts(self): &quot;&quot;&quot; This is our Consensus Algorithm, it resolves conflicts by replacing our chain with the longest one in the network. :return: &lt;bool&gt; True if our chain was replaced, False if not &quot;&quot;&quot; neighbours = self.nodes new_chain = None # We&#39;re only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f&#39;http://{node}/chain&#39;) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False valid_chain（）负责检查一个链是否有效，具体方法是循环读取每个区块并验证哈希和证明。 resolve_conflicts（）负责循环读取所有相邻节点，获取它们的链并使用上面的方法验证它们的有效性。如果找到了一个更长的有效链，则取代我们当前的链。 我们将两个方法注册到我们的API中，一个用于添加相邻节点，另一个用于解决冲突： @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 最后，如果你愿意的话可以开启另一台机器，并在你的网络上运转不同的节点。或者使用同一台机器上的不同端口启动进程。我在我的机器的不同端口创建另外一个节点，并将其注册到当前区块链网络中。 因此，我有两个节点：http：// localhost：5000和http：// localhost：5001。 为了确保链更长，我在节点2上挖掘了一些新的区块。 之后，我在节点1上调用GET / nodes / resolve，此处的链已经被共识算法计算后的得到的新链所替代。 现在，你可以邀请一些朋友来一起测试你的区块链了。 本文教程到此结束，那么，属于你自己的区块链撸好了吗？别忘了分享给身边同为程序员的朋友，一起来撸区块链！ 本篇文章由万云团队编译，如需转载请联系万云官方微信：万云Wancloud 阅读更多" />
<meta property="og:description" content="本篇文章由万云团队编译原文链接：http://mp.weixin.qq.com/s/5-O...如需转载请联系万云官方微信：万云Wancloud 2018年的门刚打开，区块链的火就烧成了火焰山。徐小平放言要拥抱区块链，朋友圈刷屏不止，连上班地铁上都能听到区块链，一夜起，区块链成了茶前饭后的谈资。于是乎，那个经常听到的问题又开始抓耳挠腮：区块链到底是什么鬼？关注的订阅号不停推送“一篇文章让你搞懂区块链”，“三分钟Get区块链”等不尽相同的内容，声音从四面八方聚焦到你耳边。 万云也在思考能为想了解区块链的老铁们做点什么，鉴于已有如此多区块链概念普及文，此次我们不聊枯燥的概念，而是回归区块链“技术”，一步步认真教你获得一个属于自己区块链。放心，只要你稍微懂一点技术，你就可以实现并拥有它。 || 以下翻译自Daniel van Flymen的《Learn Blockchains by Building One》，有所删改。|| 原文地址：https://hackernoon.com/learn-... 前言 概念了解：在开始前你需要知道，区块链是一种按时间将数据区块以顺序相连的方式组合在一起的链式数据结构，并通过密码学来保证其不可篡改和不可伪造的分布式账本。这些区块可以包含交易、文件以及任何你想要的数据，重要的是它们通过哈希链接在一起。目标读者：可以轻松地阅读和编写一些基本的Python，并且对HTTP有一些了解。所需工具：Python 3.6+、Flask、Requests：pip install Flask==0.12.2 requests==2.18.4&nbsp;除此之外还需安装HTTP工具，如Postman、cURL。源代码地址：https://github.com/dvf/blockc... 第一步：建立区块链①实现一个Blockchain类打开一个你常用的文本编辑器或者IDE，新建一个blockchain.py的python文件，并创建一个Blockchain类，在构造函数中创建两个空的队列，一个用于存储区块链，另一个用于存储交易。下面是Blockchain类的模板代码： class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass 我们所创建的Blockchain类将用来管理链，它会存储交易，并且提供一些方法来帮助添加新的区块到链。下面是详细的实现方法。 每个区块所包含5个基本属性：index，timestamp (in Unix time)，交易列表，工作量证明和前一个区块的哈希值。我们来看一个例子： block = { &#39;index&#39;: 1, &#39;timestamp&#39;: 1506057125.900785, &#39;transactions&#39;: [ { &#39;sender&#39;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;, &#39;recipient&#39;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;, &#39;amount&#39;: 5, } ], &#39;proof&#39;: 324984774000, &#39;previous_hash&#39;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot; } 到这里，我们对于链的概念应该比较清楚了，每个新的区块都会包含上一个区块的哈希值，从而让区块链具有不可篡改的特性。如果攻击者攻击了链中比较靠前的区块，则所有后面的区块将包含不正确的哈希值。如果不能理解，慢慢消化——这是理解区块链技术的核心思想。 ②将交易添加到区块 接下来我们实现一个将交易添加到区块的方法，继续看代码： class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 在new_transaction（）方法中向列表中添加一笔交易之后，它返回值是本次交易的index，该index会被添加到下一个待挖掘区块，后面在用户提交交易时也会用到。 ③建一个新的区块 当Blockchain被实例化后，我们需要创建一个创世区块，同时为我们的创世区块添加一个工作量证明，这是挖矿的结果，我们稍后会详细讨论挖矿。 除了创建创世区块的代码，我们还需要补充new_block（），new_transaction（）和hash（）的方法： import hashlib import json from time import time class Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; Create a new Block in the Blockchain :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; Creates a SHA-256 hash of a Block :param block: &lt;dict&gt; Block :return: &lt;str&gt; &quot;&quot;&quot; # We must make sure that the Dictionary is Ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 到此，我们的区块链已经基本上实现了雏形。这时候，你肯定想知道新区块是怎么被挖出来的，也就是我们通常所说的“挖矿”。 ④什么是工作量证明？ 想了解什么是“挖矿”，就必须理解工作量证明（POW）是什么。区块链上每一个新的区块都来自于工作量证明（POW），POW的目标是计算出一串解决问题的数字，这个结果众所周知是很难计算的，但却十分容易验证，因为网络上的任何人都能够验证这个结果，这是“工作量证明”背后的核心思想。 我们来看一个非常简单的例子帮助理解： 假设整数X乘以另一个整数y的哈希值必须以0结尾，hash(x * y) = ac23dc...0. 设x = 5.求y。我们用Python来实现： from hashlib import sha256 x = 5 y = 0 # We don&#39;t know what y should be yet... while sha256(f&#39;{x*y}&#39;.encode()).hexdigest()[-1] != &quot;0&quot;: y += 1 print(f&#39;The solution is y = {y}&#39;) 得到的答案是当y = 21，哈希值的结尾为0：hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，工作证明算法被称为Hashcash，这和我们上面所举的例子差不多，结果难于发现却易于校验。Hashcash是矿工为了创建一个新区块而争相计算的问题，计算难度通常取决于字符串中搜索的字符数，通常也会花费一定的时间才能计算得到，最终计算出来的矿工们会通过交易获得一定数量的比特币作为奖励。 ⑤实现一个基本的工作量证明 首先我们为Blockchain类实现一个类似的算法： 规则：找到一个数字p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。 import hashlib import json from time import time from uuid import uuid4 class Blockchain(object): ... def proof_of_work(self, last_proof): &quot;&quot;&quot; Simple Proof of Work Algorithm: - Find a number p&#39; such that hash(pp&#39;) contains leading 4 zeroes, where p is the previous p&#39; - p is the previous proof, and p&#39; is the new proof :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. &quot;&quot;&quot; guess = f&#39;{last_proof}{proof}&#39;.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; 通过修改前导零的数量，可以调整算法的难度，但是4个零完全足够了。你会发现，每当增加一个前导零，找到一个对应的解决方案与所需的时间之间会产生巨大的差异。 进行到这里，我们的Blockchain类已经基本完成，接下来我们实现HTTP服务进行交互。 第二步：区块链API我们将使用Python Flask框架，Flask是一个轻量级的Web应用框架，这使我们可以通过web服务来调用Blockchian类。 ①创建三个API： •/ transactions / new为区块创建一个新的交易 •/mine告诉我们的服务器开采新的区块。 •/chain返回整个区块链。 ②使用Flask 我们的“服务器”将基于Flask框架来实现区块链网络中的一个节点。 我们来添加一些模板代码： import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask class Blockchain(object): ... # Instantiate our Node app = Flask(__name__) # Generate a globally unique address for this node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # Instantiate the Blockchain blockchain = Blockchain() @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): return &quot;We&#39;ll mine a new Block&quot; @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): return &quot;We&#39;ll add a new transaction&quot; @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 以下是对上面添加的内容的进行简要说明： Line15：实例化Flask web服务节点。 Line18：为我们的服务节点创建一个随机的名称。 Line21：实例化Blockchain类。 Line24-26：创建一个路由为/mine的GET请求的，调用后端Blockchain的new block方法。 Line28-30：创建一个路由为/transactions/new的POST请求，将数据发送给后端Blockchina的new transaction方法。 Line32-38：创建一个路由为/chain的GET请求，将返回整个链。 Line40-41：在端口5000上运行服务器。 ③实现交易 下面是用户发起交易时发送到服务器的请求： { &quot;sender&quot;: &quot;my address&quot;, &quot;recipient&quot;: &quot;someone else&#39;s address&quot;, &quot;amount&quot;: 5 } 由于我们已经有了将交易添加到区块的方法，接下去就十分容易了。 下面我们来实现添加交易的函数： import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): values = request.get_json() # Check that the required fields are in the POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: f&#39;Transaction will be added to Block {index}&#39;} return jsonify(response), 201 ④实现挖矿 我们的挖矿方法是魔法发生的地方。它十分容易，只做三件事情：计算工作量证明；通过新增一笔交易奖励矿工一定数量的比特币；创建新的区块并将其添加到链中来。 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # We must receive a reward for finding the proof. # The sender is &quot;0&quot; to signify that this node has mined a new coin. blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain previous_hash = blockchain.hash(last_block) block = blockchain.new_block(proof, previous_hash) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 需要注意的是，开采块的交易接收者是我们自己服务器节点的地址，我们在这里所做的大部分工作只是与Blockchain类进行交互，基于以上我们区块链已经完成了，接下来开始交互演示。 第三步：交互演示您可以使用cURL或Postman与API进行交互。 启动服务器： $ python blockchain.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 尝试通过向http：// localhost：5000 / mine发出GET请求来挖掘区块： 创建一个新的交易，向http://localhost:5000/transactions/new发出一个POST请求： 也可以使用cURL发送请求： $ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{ &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 5 }&#39; &quot;http://localhost:5000/transactions/new&quot; 以上仅为交互演示的示例，你可以在你自己所完成的区块链上进行更多尝试。 第四步：共识机制我们有一个基本的区块链可以进行交易和挖矿，但其实区块链更重要的意义在于它们是分布式的。那么我们需要确保所有的节点都运行在同一条链上，这就是回归到了共识问题，如果要满足在网络上有多个节点并且不断增加，我们必须要实现共识算法。 ①注册新的节点 在实现共识算法之前，需要找到一种方式让网络上的节点知道其相邻的节点，每个节点都需要存储网络上其他节点的记录。因此，我们需要新增几个方法来帮助实现： 1./nodes/register接受URL形式的新节点列表。 / nodes / resolve来执行我们的共识算法，它可以解决任何冲突，确保节点具有正确的链。 　下面我们将修改Blockchain的构造函数以提供注册节点的方法： ... from urllib.parse import urlparse ... class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) 注意，我们使用set()集合来保存节点列表，这是确保新节点的添加是幂等的简便方法，这意味着无论我们添加特定节点多少次，它都只会出现一次。 ②实现共识算法 如前所述，当一个节点与另一个节点有不同时会发生冲突，为了解决这个问题，我们遵循取最长链原则，通过使用此算法，让网络中的节点间达成共识。 ... import requests class Blockchain(object) ... def valid_chain(self, chain): &quot;&quot;&quot; Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f&#39;{last_block}&#39;) print(f&#39;{block}&#39;) print(&quot;\n-----------\n&quot;) # Check that the hash of the block is correct if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def resolve_conflicts(self): &quot;&quot;&quot; This is our Consensus Algorithm, it resolves conflicts by replacing our chain with the longest one in the network. :return: &lt;bool&gt; True if our chain was replaced, False if not &quot;&quot;&quot; neighbours = self.nodes new_chain = None # We&#39;re only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f&#39;http://{node}/chain&#39;) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False valid_chain（）负责检查一个链是否有效，具体方法是循环读取每个区块并验证哈希和证明。 resolve_conflicts（）负责循环读取所有相邻节点，获取它们的链并使用上面的方法验证它们的有效性。如果找到了一个更长的有效链，则取代我们当前的链。 我们将两个方法注册到我们的API中，一个用于添加相邻节点，另一个用于解决冲突： @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 最后，如果你愿意的话可以开启另一台机器，并在你的网络上运转不同的节点。或者使用同一台机器上的不同端口启动进程。我在我的机器的不同端口创建另外一个节点，并将其注册到当前区块链网络中。 因此，我有两个节点：http：// localhost：5000和http：// localhost：5001。 为了确保链更长，我在节点2上挖掘了一些新的区块。 之后，我在节点1上调用GET / nodes / resolve，此处的链已经被共识算法计算后的得到的新链所替代。 现在，你可以邀请一些朋友来一起测试你的区块链了。 本文教程到此结束，那么，属于你自己的区块链撸好了吗？别忘了分享给身边同为程序员的朋友，一起来撸区块链！ 本篇文章由万云团队编译，如需转载请联系万云官方微信：万云Wancloud 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/02/09/50fce15ec2b8a886445ff3e19d19e943.html" />
<meta property="og:url" content="https://mlh.app/2018/02/09/50fce15ec2b8a886445ff3e19d19e943.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本篇文章由万云团队编译原文链接：http://mp.weixin.qq.com/s/5-O...如需转载请联系万云官方微信：万云Wancloud 2018年的门刚打开，区块链的火就烧成了火焰山。徐小平放言要拥抱区块链，朋友圈刷屏不止，连上班地铁上都能听到区块链，一夜起，区块链成了茶前饭后的谈资。于是乎，那个经常听到的问题又开始抓耳挠腮：区块链到底是什么鬼？关注的订阅号不停推送“一篇文章让你搞懂区块链”，“三分钟Get区块链”等不尽相同的内容，声音从四面八方聚焦到你耳边。 万云也在思考能为想了解区块链的老铁们做点什么，鉴于已有如此多区块链概念普及文，此次我们不聊枯燥的概念，而是回归区块链“技术”，一步步认真教你获得一个属于自己区块链。放心，只要你稍微懂一点技术，你就可以实现并拥有它。 || 以下翻译自Daniel van Flymen的《Learn Blockchains by Building One》，有所删改。|| 原文地址：https://hackernoon.com/learn-... 前言 概念了解：在开始前你需要知道，区块链是一种按时间将数据区块以顺序相连的方式组合在一起的链式数据结构，并通过密码学来保证其不可篡改和不可伪造的分布式账本。这些区块可以包含交易、文件以及任何你想要的数据，重要的是它们通过哈希链接在一起。目标读者：可以轻松地阅读和编写一些基本的Python，并且对HTTP有一些了解。所需工具：Python 3.6+、Flask、Requests：pip install Flask==0.12.2 requests==2.18.4&nbsp;除此之外还需安装HTTP工具，如Postman、cURL。源代码地址：https://github.com/dvf/blockc... 第一步：建立区块链①实现一个Blockchain类打开一个你常用的文本编辑器或者IDE，新建一个blockchain.py的python文件，并创建一个Blockchain类，在构造函数中创建两个空的队列，一个用于存储区块链，另一个用于存储交易。下面是Blockchain类的模板代码： class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass 我们所创建的Blockchain类将用来管理链，它会存储交易，并且提供一些方法来帮助添加新的区块到链。下面是详细的实现方法。 每个区块所包含5个基本属性：index，timestamp (in Unix time)，交易列表，工作量证明和前一个区块的哈希值。我们来看一个例子： block = { &#39;index&#39;: 1, &#39;timestamp&#39;: 1506057125.900785, &#39;transactions&#39;: [ { &#39;sender&#39;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;, &#39;recipient&#39;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;, &#39;amount&#39;: 5, } ], &#39;proof&#39;: 324984774000, &#39;previous_hash&#39;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot; } 到这里，我们对于链的概念应该比较清楚了，每个新的区块都会包含上一个区块的哈希值，从而让区块链具有不可篡改的特性。如果攻击者攻击了链中比较靠前的区块，则所有后面的区块将包含不正确的哈希值。如果不能理解，慢慢消化——这是理解区块链技术的核心思想。 ②将交易添加到区块 接下来我们实现一个将交易添加到区块的方法，继续看代码： class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 在new_transaction（）方法中向列表中添加一笔交易之后，它返回值是本次交易的index，该index会被添加到下一个待挖掘区块，后面在用户提交交易时也会用到。 ③建一个新的区块 当Blockchain被实例化后，我们需要创建一个创世区块，同时为我们的创世区块添加一个工作量证明，这是挖矿的结果，我们稍后会详细讨论挖矿。 除了创建创世区块的代码，我们还需要补充new_block（），new_transaction（）和hash（）的方法： import hashlib import json from time import time class Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; Create a new Block in the Blockchain :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; Creates a SHA-256 hash of a Block :param block: &lt;dict&gt; Block :return: &lt;str&gt; &quot;&quot;&quot; # We must make sure that the Dictionary is Ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 到此，我们的区块链已经基本上实现了雏形。这时候，你肯定想知道新区块是怎么被挖出来的，也就是我们通常所说的“挖矿”。 ④什么是工作量证明？ 想了解什么是“挖矿”，就必须理解工作量证明（POW）是什么。区块链上每一个新的区块都来自于工作量证明（POW），POW的目标是计算出一串解决问题的数字，这个结果众所周知是很难计算的，但却十分容易验证，因为网络上的任何人都能够验证这个结果，这是“工作量证明”背后的核心思想。 我们来看一个非常简单的例子帮助理解： 假设整数X乘以另一个整数y的哈希值必须以0结尾，hash(x * y) = ac23dc...0. 设x = 5.求y。我们用Python来实现： from hashlib import sha256 x = 5 y = 0 # We don&#39;t know what y should be yet... while sha256(f&#39;{x*y}&#39;.encode()).hexdigest()[-1] != &quot;0&quot;: y += 1 print(f&#39;The solution is y = {y}&#39;) 得到的答案是当y = 21，哈希值的结尾为0：hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，工作证明算法被称为Hashcash，这和我们上面所举的例子差不多，结果难于发现却易于校验。Hashcash是矿工为了创建一个新区块而争相计算的问题，计算难度通常取决于字符串中搜索的字符数，通常也会花费一定的时间才能计算得到，最终计算出来的矿工们会通过交易获得一定数量的比特币作为奖励。 ⑤实现一个基本的工作量证明 首先我们为Blockchain类实现一个类似的算法： 规则：找到一个数字p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。 import hashlib import json from time import time from uuid import uuid4 class Blockchain(object): ... def proof_of_work(self, last_proof): &quot;&quot;&quot; Simple Proof of Work Algorithm: - Find a number p&#39; such that hash(pp&#39;) contains leading 4 zeroes, where p is the previous p&#39; - p is the previous proof, and p&#39; is the new proof :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. &quot;&quot;&quot; guess = f&#39;{last_proof}{proof}&#39;.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; 通过修改前导零的数量，可以调整算法的难度，但是4个零完全足够了。你会发现，每当增加一个前导零，找到一个对应的解决方案与所需的时间之间会产生巨大的差异。 进行到这里，我们的Blockchain类已经基本完成，接下来我们实现HTTP服务进行交互。 第二步：区块链API我们将使用Python Flask框架，Flask是一个轻量级的Web应用框架，这使我们可以通过web服务来调用Blockchian类。 ①创建三个API： •/ transactions / new为区块创建一个新的交易 •/mine告诉我们的服务器开采新的区块。 •/chain返回整个区块链。 ②使用Flask 我们的“服务器”将基于Flask框架来实现区块链网络中的一个节点。 我们来添加一些模板代码： import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask class Blockchain(object): ... # Instantiate our Node app = Flask(__name__) # Generate a globally unique address for this node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # Instantiate the Blockchain blockchain = Blockchain() @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): return &quot;We&#39;ll mine a new Block&quot; @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): return &quot;We&#39;ll add a new transaction&quot; @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 以下是对上面添加的内容的进行简要说明： Line15：实例化Flask web服务节点。 Line18：为我们的服务节点创建一个随机的名称。 Line21：实例化Blockchain类。 Line24-26：创建一个路由为/mine的GET请求的，调用后端Blockchain的new block方法。 Line28-30：创建一个路由为/transactions/new的POST请求，将数据发送给后端Blockchina的new transaction方法。 Line32-38：创建一个路由为/chain的GET请求，将返回整个链。 Line40-41：在端口5000上运行服务器。 ③实现交易 下面是用户发起交易时发送到服务器的请求： { &quot;sender&quot;: &quot;my address&quot;, &quot;recipient&quot;: &quot;someone else&#39;s address&quot;, &quot;amount&quot;: 5 } 由于我们已经有了将交易添加到区块的方法，接下去就十分容易了。 下面我们来实现添加交易的函数： import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): values = request.get_json() # Check that the required fields are in the POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: f&#39;Transaction will be added to Block {index}&#39;} return jsonify(response), 201 ④实现挖矿 我们的挖矿方法是魔法发生的地方。它十分容易，只做三件事情：计算工作量证明；通过新增一笔交易奖励矿工一定数量的比特币；创建新的区块并将其添加到链中来。 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # We must receive a reward for finding the proof. # The sender is &quot;0&quot; to signify that this node has mined a new coin. blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain previous_hash = blockchain.hash(last_block) block = blockchain.new_block(proof, previous_hash) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 需要注意的是，开采块的交易接收者是我们自己服务器节点的地址，我们在这里所做的大部分工作只是与Blockchain类进行交互，基于以上我们区块链已经完成了，接下来开始交互演示。 第三步：交互演示您可以使用cURL或Postman与API进行交互。 启动服务器： $ python blockchain.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 尝试通过向http：// localhost：5000 / mine发出GET请求来挖掘区块： 创建一个新的交易，向http://localhost:5000/transactions/new发出一个POST请求： 也可以使用cURL发送请求： $ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{ &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 5 }&#39; &quot;http://localhost:5000/transactions/new&quot; 以上仅为交互演示的示例，你可以在你自己所完成的区块链上进行更多尝试。 第四步：共识机制我们有一个基本的区块链可以进行交易和挖矿，但其实区块链更重要的意义在于它们是分布式的。那么我们需要确保所有的节点都运行在同一条链上，这就是回归到了共识问题，如果要满足在网络上有多个节点并且不断增加，我们必须要实现共识算法。 ①注册新的节点 在实现共识算法之前，需要找到一种方式让网络上的节点知道其相邻的节点，每个节点都需要存储网络上其他节点的记录。因此，我们需要新增几个方法来帮助实现： 1./nodes/register接受URL形式的新节点列表。 / nodes / resolve来执行我们的共识算法，它可以解决任何冲突，确保节点具有正确的链。 　下面我们将修改Blockchain的构造函数以提供注册节点的方法： ... from urllib.parse import urlparse ... class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) 注意，我们使用set()集合来保存节点列表，这是确保新节点的添加是幂等的简便方法，这意味着无论我们添加特定节点多少次，它都只会出现一次。 ②实现共识算法 如前所述，当一个节点与另一个节点有不同时会发生冲突，为了解决这个问题，我们遵循取最长链原则，通过使用此算法，让网络中的节点间达成共识。 ... import requests class Blockchain(object) ... def valid_chain(self, chain): &quot;&quot;&quot; Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f&#39;{last_block}&#39;) print(f&#39;{block}&#39;) print(&quot;\\n-----------\\n&quot;) # Check that the hash of the block is correct if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def resolve_conflicts(self): &quot;&quot;&quot; This is our Consensus Algorithm, it resolves conflicts by replacing our chain with the longest one in the network. :return: &lt;bool&gt; True if our chain was replaced, False if not &quot;&quot;&quot; neighbours = self.nodes new_chain = None # We&#39;re only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f&#39;http://{node}/chain&#39;) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False valid_chain（）负责检查一个链是否有效，具体方法是循环读取每个区块并验证哈希和证明。 resolve_conflicts（）负责循环读取所有相邻节点，获取它们的链并使用上面的方法验证它们的有效性。如果找到了一个更长的有效链，则取代我们当前的链。 我们将两个方法注册到我们的API中，一个用于添加相邻节点，另一个用于解决冲突： @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 最后，如果你愿意的话可以开启另一台机器，并在你的网络上运转不同的节点。或者使用同一台机器上的不同端口启动进程。我在我的机器的不同端口创建另外一个节点，并将其注册到当前区块链网络中。 因此，我有两个节点：http：// localhost：5000和http：// localhost：5001。 为了确保链更长，我在节点2上挖掘了一些新的区块。 之后，我在节点1上调用GET / nodes / resolve，此处的链已经被共识算法计算后的得到的新链所替代。 现在，你可以邀请一些朋友来一起测试你的区块链了。 本文教程到此结束，那么，属于你自己的区块链撸好了吗？别忘了分享给身边同为程序员的朋友，一起来撸区块链！ 本篇文章由万云团队编译，如需转载请联系万云官方微信：万云Wancloud 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/02/09/50fce15ec2b8a886445ff3e19d19e943.html","headline":"干货 手把手教你快速撸一个区块链","dateModified":"2018-02-09T00:00:00+08:00","datePublished":"2018-02-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/02/09/50fce15ec2b8a886445ff3e19d19e943.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>干货 | 手把手教你快速撸一个区块链</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">本篇文章由万云团队编译</span><br style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">原文链接：</span><a href="http://mp.weixin.qq.com/s/5-O4PTnZWUsadrRDvVLS1A" rel="nofollow" style="background:rgb(255,255,255);color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.25);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;">http://mp.weixin.qq.com/s/5-O...</a><br style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">如需转载请联系万云官方微信：万云Wancloud</span><br></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">2018年的门刚打开，区块链的火就烧成了火焰山。徐小平放言要拥抱区块链，朋友圈刷屏不止，连上班地铁上都能听到区块链，一夜起，区块链成了茶前饭后的谈资。于是乎，那个经常听到的问题又开始抓耳挠腮：区块链到底是什么鬼？关注的订阅号不停推送“一篇文章让你搞懂区块链”，“三分钟Get区块链”等不尽相同的内容，声音从四面八方聚焦到你耳边。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">万云也在思考能为想了解区块链的老铁们做点什么，鉴于已有如此多区块链概念普及文，此次我们不聊枯燥的概念，而是回归区块链“技术”，一步步认真教你获得一个属于自己区块链。放心，只要你稍微懂一点技术，你就可以实现并拥有它。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">|| 以下翻译自Daniel van Flymen的《Learn Blockchains by Building One》，有所删改。<br>|| 原文地址：<a href="https://hackernoon.com/learn-blockchains-by-building-one-117428612f46" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.25);">https://hackernoon.com/learn-...</a></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>前言</strong></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">概念了解：在开始前你需要知道，区块链是一种按时间将数据区块以顺序相连的方式组合在一起的链式数据结构，并通过密码学来保证其不可篡改和不可伪造的分布式账本。这些区块可以包含交易、文件以及任何你想要的数据，重要的是它们通过哈希链接在一起。<br>目标读者：可以轻松地阅读和编写一些基本的Python，并且对HTTP有一些了解。<br>所需工具：Python 3.6+、Flask、Requests：<br>pip install Flask==0.12.2 requests==2.18.4&nbsp;<br>除此之外还需安装HTTP工具，如Postman、cURL。<br>源代码地址：<a href="https://github.com/dvf/blockchain" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.25);">https://github.com/dvf/blockc...</a></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>第一步：建立区块链<br>①实现一个Blockchain类</strong><br>打开一个你常用的文本编辑器或者IDE，新建一个blockchain.py的python文件，并创建一个Blockchain类，在构造函数中创建两个空的队列，一个用于存储区块链，另一个用于存储交易。下面是Blockchain类的模板代码：</p>
  <pre><code class="language-ruby"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Blockchain</span>(<span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">object</span>):</span> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">__init__</span><span class="hljs-params">(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>)</span></span>: <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>.chain = [] <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>.current_transactions = [] <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">new_block</span><span class="hljs-params">(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>)</span></span>: <span class="hljs-comment" style="color:rgb(153,153,136);"># Creates a new Block and adds it to the chain</span> pass <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">new_transaction</span><span class="hljs-params">(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>)</span></span>: <span class="hljs-comment" style="color:rgb(153,153,136);"># Adds a new transaction to the list of transactions</span> pass @staticmethod <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">hash</span><span class="hljs-params">(block)</span></span>: <span class="hljs-comment" style="color:rgb(153,153,136);"># Hashes a Block</span> pass @property <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">last_block</span><span class="hljs-params">(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>)</span></span>: <span class="hljs-comment" style="color:rgb(153,153,136);"># Returns the last Block in the chain</span> pass </code></code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">我们所创建的Blockchain类将用来管理链，它会存储交易，并且提供一些方法来帮助添加新的区块到链。下面是详细的实现方法。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">每个区块所包含5个基本属性：index，timestamp (in Unix time)，交易列表，工作量证明和前一个区块的哈希值。我们来看一个例子：</p>
  <pre class="hljs xquery" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);background:rgb(246,246,246) url(&quot;../img/blueprint.png&quot;) 0% 0%;border:none;"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">block = {
    <span class="hljs-string" style="color:rgb(221,17,68);">'index'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">1</span>,
    <span class="hljs-string" style="color:rgb(221,17,68);">'timestamp'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">1506057125.900785</span>,
    <span class="hljs-string" style="color:rgb(221,17,68);">'transactions'</span>: [
        {
            <span class="hljs-string" style="color:rgb(221,17,68);">'sender'</span>: <span class="hljs-string" style="color:rgb(221,17,68);">"8527147fe1f5426f9dd545de4b27ee00"</span>,
            <span class="hljs-string" style="color:rgb(221,17,68);">'recipient'</span>: <span class="hljs-string" style="color:rgb(221,17,68);">"a77f5cdfa2934df3954a5c7c7da5df1f"</span>,
            <span class="hljs-string" style="color:rgb(221,17,68);">'amount'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">5</span>,
        }
    ],
    <span class="hljs-string" style="color:rgb(221,17,68);">'proof'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">324984774000</span>,
    <span class="hljs-string" style="color:rgb(221,17,68);">'previous_hash'</span>: <span class="hljs-string" style="color:rgb(221,17,68);">"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"</span>
}
</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">到这里，我们对于链的概念应该比较清楚了，每个新的区块都会包含上一个区块的哈希值，从而让区块链具有不可篡改的特性。如果攻击者攻击了链中比较靠前的区块，则所有后面的区块将包含不正确的哈希值。如果不能理解，慢慢消化——这是理解区块链技术的核心思想。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>②将交易添加到区块</strong></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">接下来我们实现一个将交易添加到区块的方法，继续看代码：</p>
  <pre class="hljs vim" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);background:rgb(246,246,246) url(&quot;../img/blueprint.png&quot;) 0% 0%;border:none;"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">
class Blockchain(object):
    ...
    
    def new_transaction(self, sender, recipient, amount):
        <span class="hljs-string" style="color:rgb(221,17,68);">""</span><span class="hljs-comment" style="color:rgb(153,153,136);">"</span>
        Creates <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">a</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> transaction <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">to</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">go</span> into the <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">next</span> mined Block
        :param sender: <span class="hljs-symbol" style="color:rgb(153,0,115);">&lt;str&gt;</span> Address of the Sender
        :param recipien<span class="hljs-variable" style="color:rgb(0,128,128);">t:</span> <span class="hljs-symbol" style="color:rgb(153,0,115);">&lt;str&gt;</span> Address of the Recipient
        :param amoun<span class="hljs-variable" style="color:rgb(0,128,128);">t:</span> <span class="hljs-symbol" style="color:rgb(153,0,115);">&lt;int&gt;</span> Amount
        :<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span>: <span class="hljs-symbol" style="color:rgb(153,0,115);">&lt;int&gt;</span> The <span class="hljs-built_in" style="color:rgb(0,134,179);">index</span> of the Block that will hold this transaction
        <span class="hljs-string" style="color:rgb(221,17,68);">""</span><span class="hljs-comment" style="color:rgb(153,153,136);">"</span>

        self.current_transactions.<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">append</span>({
            <span class="hljs-string" style="color:rgb(221,17,68);">'sender'</span>: sender,
            <span class="hljs-string" style="color:rgb(221,17,68);">'recipient'</span>: recipient,
            <span class="hljs-string" style="color:rgb(221,17,68);">'amount'</span>: amount,
        })

        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> self.last_block[<span class="hljs-string" style="color:rgb(221,17,68);">'index'</span>] + <span class="hljs-number" style="color:rgb(0,128,128);">1</span>
</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">在new_transaction（）方法中向列表中添加一笔交易之后，它返回值是本次交易的index，该index会被添加到下一个待挖掘区块，后面在用户提交交易时也会用到。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>③建一个新的区块</strong></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">当Blockchain被实例化后，我们需要创建一个创世区块，同时为我们的创世区块添加一个工作量证明，这是挖矿的结果，我们稍后会详细讨论挖矿。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">除了创建创世区块的代码，我们还需要补充new_block（），new_transaction（）和hash（）的方法：</p>
  <pre><code class="language-python"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> hashlib <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> json <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> time <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> time <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Blockchain</span><span class="hljs-params">(object)</span>:</span> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">__init__</span><span class="hljs-params">(self)</span>:</span> self.current_transactions = [] self.chain = [] <span class="hljs-comment" style="color:rgb(153,153,136);"># Create the genesis block</span> self.new_block(previous_hash=<span class="hljs-number" style="color:rgb(0,128,128);">1</span>, proof=<span class="hljs-number" style="color:rgb(0,128,128);">100</span>) <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">new_block</span><span class="hljs-params">(self, proof, previous_hash=None)</span>:</span> <span class="hljs-string" style="color:rgb(221,17,68);">""" Create a new Block in the Blockchain :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block """</span> block = { <span class="hljs-string" style="color:rgb(221,17,68);">'index'</span>: len(self.chain) + <span class="hljs-number" style="color:rgb(0,128,128);">1</span>, <span class="hljs-string" style="color:rgb(221,17,68);">'timestamp'</span>: time(), <span class="hljs-string" style="color:rgb(221,17,68);">'transactions'</span>: self.current_transactions, <span class="hljs-string" style="color:rgb(221,17,68);">'proof'</span>: proof, <span class="hljs-string" style="color:rgb(221,17,68);">'previous_hash'</span>: previous_hash <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">or</span> self.hash(self.chain[<span class="hljs-number" style="color:rgb(0,128,128);">-1</span>]), } <span class="hljs-comment" style="color:rgb(153,153,136);"># Reset the current list of transactions</span> self.current_transactions = [] self.chain.append(block) <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> block <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">new_transaction</span><span class="hljs-params">(self, sender, recipient, amount)</span>:</span> <span class="hljs-string" style="color:rgb(221,17,68);">""" Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction """</span> self.current_transactions.append({ <span class="hljs-string" style="color:rgb(221,17,68);">'sender'</span>: sender, <span class="hljs-string" style="color:rgb(221,17,68);">'recipient'</span>: recipient, <span class="hljs-string" style="color:rgb(221,17,68);">'amount'</span>: amount, }) <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> self.last_block[<span class="hljs-string" style="color:rgb(221,17,68);">'index'</span>] + <span class="hljs-number" style="color:rgb(0,128,128);">1</span> <span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;"> @property</span> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">last_block</span><span class="hljs-params">(self)</span>:</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> self.chain[<span class="hljs-number" style="color:rgb(0,128,128);">-1</span>] <span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;"> @staticmethod</span> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">hash</span><span class="hljs-params">(block)</span>:</span> <span class="hljs-string" style="color:rgb(221,17,68);">""" Creates a SHA-256 hash of a Block :param block: &lt;dict&gt; Block :return: &lt;str&gt; """</span> <span class="hljs-comment" style="color:rgb(153,153,136);"># We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes</span> block_string = json.dumps(block, sort_keys=<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">True</span>).encode() <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> hashlib.sha256(block_string).hexdigest() </code></code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">到此，我们的区块链已经基本上实现了雏形。这时候，你肯定想知道新区块是怎么被挖出来的，也就是我们通常所说的“挖矿”。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>④什么是工作量证明？</strong></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">想了解什么是“挖矿”，就必须理解工作量证明（POW）是什么。区块链上每一个新的区块都来自于工作量证明（POW），POW的目标是计算出一串解决问题的数字，这个结果众所周知是很难计算的，但却十分容易验证，因为网络上的任何人都能够验证这个结果，这是“工作量证明”背后的核心思想。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">我们来看一个非常简单的例子帮助理解：</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">假设整数X乘以另一个整数y的哈希值必须以0结尾，hash(x * y) = ac23dc...0. 设x = 5.求y。我们用Python来实现：</p>
  <pre><code class="language-python"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> hashlib <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> sha256 x = <span class="hljs-number" style="color:rgb(0,128,128);">5</span> y = <span class="hljs-number" style="color:rgb(0,128,128);">0</span> <span class="hljs-comment" style="color:rgb(153,153,136);"># We don't know what y should be yet...</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">while</span> sha256(<span class="hljs-string" style="color:rgb(221,17,68);">f'<span class="hljs-subst" style="color:rgb(51,51,51);">{x*y}</span>'</span>.encode()).hexdigest()[<span class="hljs-number" style="color:rgb(0,128,128);">-1</span>] != <span class="hljs-string" style="color:rgb(221,17,68);">"0"</span>: y += <span class="hljs-number" style="color:rgb(0,128,128);">1</span> print(<span class="hljs-string" style="color:rgb(221,17,68);">f'The solution is y = <span class="hljs-subst" style="color:rgb(51,51,51);">{y}</span>'</span>) </code></code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">得到的答案是当y = 21，哈希值的结尾为0：<br>hash(5 * 21) = 1253e9373e...5e3600155e860</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">在比特币中，工作证明算法被称为Hashcash，这和我们上面所举的例子差不多，结果难于发现却易于校验。Hashcash是矿工为了创建一个新区块而争相计算的问题，计算难度通常取决于字符串中搜索的字符数，通常也会花费一定的时间才能计算得到，最终计算出来的矿工们会通过交易获得一定数量的比特币作为奖励。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>⑤实现一个基本的工作量证明</strong></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">首先我们为Blockchain类实现一个类似的算法：</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">规则：找到一个数字p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。</p>
  <pre><code class="language-python"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> hashlib <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> json <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> time <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> time <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> uuid <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> uuid4 <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Blockchain</span><span class="hljs-params">(object)</span>:</span> ... <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">proof_of_work</span><span class="hljs-params">(self, last_proof)</span>:</span> <span class="hljs-string" style="color:rgb(221,17,68);">""" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') contains leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof :param last_proof: &lt;int&gt; :return: &lt;int&gt; """</span> proof = <span class="hljs-number" style="color:rgb(0,128,128);">0</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">while</span> self.valid_proof(last_proof, proof) <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">is</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">False</span>: proof += <span class="hljs-number" style="color:rgb(0,128,128);">1</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> proof <span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;"> @staticmethod</span> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">valid_proof</span><span class="hljs-params">(last_proof, proof)</span>:</span> <span class="hljs-string" style="color:rgb(221,17,68);">""" Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. """</span> guess = <span class="hljs-string" style="color:rgb(221,17,68);">f'<span class="hljs-subst" style="color:rgb(51,51,51);">{last_proof}</span><span class="hljs-subst" style="color:rgb(51,51,51);">{proof}</span>'</span>.encode() guess_hash = hashlib.sha256(guess).hexdigest() <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> guess_hash[:<span class="hljs-number" style="color:rgb(0,128,128);">4</span>] == <span class="hljs-string" style="color:rgb(221,17,68);">"0000"</span> </code></code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">通过修改前导零的数量，可以调整算法的难度，但是4个零完全足够了。你会发现，每当增加一个前导零，找到一个对应的解决方案与所需的时间之间会产生巨大的差异。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">进行到这里，我们的Blockchain类已经基本完成，接下来我们实现HTTP服务进行交互。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>第二步：区块链API</strong><br>我们将使用Python Flask框架，Flask是一个轻量级的Web应用框架，这使我们可以通过web服务来调用Blockchian类。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>①创建三个API：</strong></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">•/ transactions / new为区块创建一个新的交易</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">•/mine告诉我们的服务器开采新的区块。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">•/chain返回整个区块链。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>②使用Flask</strong></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">我们的“服务器”将基于Flask框架来实现区块链网络中的一个节点。 我们来添加一些模板代码：</p>
  <pre><code class="language-python"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> hashlib <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> json <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> textwrap <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> dedent <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> time <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> time <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> uuid <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> uuid4 <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> flask <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> Flask <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Blockchain</span><span class="hljs-params">(object)</span>:</span> ... <span class="hljs-comment" style="color:rgb(153,153,136);"># Instantiate our Node</span> app = Flask(__name__) <span class="hljs-comment" style="color:rgb(153,153,136);"># Generate a globally unique address for this node</span> node_identifier = str(uuid4()).replace(<span class="hljs-string" style="color:rgb(221,17,68);">'-'</span>, <span class="hljs-string" style="color:rgb(221,17,68);">''</span>) <span class="hljs-comment" style="color:rgb(153,153,136);"># Instantiate the Blockchain</span> blockchain = Blockchain() <span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@app.route('/mine', methods=['GET'])</span> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">mine</span><span class="hljs-params">()</span>:</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> <span class="hljs-string" style="color:rgb(221,17,68);">"We'll mine a new Block"</span> <span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@app.route('/transactions/new', methods=['POST'])</span> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">new_transaction</span><span class="hljs-params">()</span>:</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> <span class="hljs-string" style="color:rgb(221,17,68);">"We'll add a new transaction"</span> <span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@app.route('/chain', methods=['GET'])</span> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">full_chain</span><span class="hljs-params">()</span>:</span> response = { <span class="hljs-string" style="color:rgb(221,17,68);">'chain'</span>: blockchain.chain, <span class="hljs-string" style="color:rgb(221,17,68);">'length'</span>: len(blockchain.chain), } <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> jsonify(response), <span class="hljs-number" style="color:rgb(0,128,128);">200</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> __name__ == <span class="hljs-string" style="color:rgb(221,17,68);">'__main__'</span>: app.run(host=<span class="hljs-string" style="color:rgb(221,17,68);">'0.0.0.0'</span>, port=<span class="hljs-number" style="color:rgb(0,128,128);">5000</span>) </code></code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">以下是对上面添加的内容的进行简要说明：</p>
  <pre class="hljs armasm" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);background:rgb(246,246,246) url(&quot;../img/blueprint.png&quot;) 0% 0%;border:none;"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"> Line15：实例化Flask web服务节点。

 Line18：为我们的服务节点创建一个随机的名称。

 Line21：实例化<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">Blockchain类。 </span>
 Line24-<span class="hljs-number" style="color:rgb(0,128,128);">26</span>：创建一个路由为/mine的<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">GET</span>请求的，调用后端<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">Blockchain的new </span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">block方法。 </span>
 Line28-<span class="hljs-number" style="color:rgb(0,128,128);">30</span>：创建一个路由为/transactions/new的POST请求，将数据发送给后端<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">Blockchina的new </span>transaction方法。

 Line32-<span class="hljs-number" style="color:rgb(0,128,128);">38</span>：创建一个路由为/chain的<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">GET</span>请求，将返回整个链。

 Line40-<span class="hljs-number" style="color:rgb(0,128,128);">41</span>：在端口<span class="hljs-number" style="color:rgb(0,128,128);">5000</span>上运行服务器。
 
</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>③实现交易</strong></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">下面是用户发起交易时发送到服务器的请求：</p>
  <pre class="hljs json" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);background:rgb(246,246,246) url(&quot;../img/blueprint.png&quot;) 0% 0%;border:none;"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">{
 <span class="hljs-attr">"sender"</span>: <span class="hljs-string" style="color:rgb(221,17,68);">"my address"</span>,
 <span class="hljs-attr">"recipient"</span>: <span class="hljs-string" style="color:rgb(221,17,68);">"someone else's address"</span>,
 <span class="hljs-attr">"amount"</span>: <span class="hljs-number" style="color:rgb(0,128,128);">5</span>
}
</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">由于我们已经有了将交易添加到区块的方法，接下去就十分容易了。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">下面我们来实现添加交易的函数：</p>
  <pre><code class="language-python"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> hashlib <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> json <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> textwrap <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> dedent <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> time <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> time <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> uuid <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> uuid4 <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> flask <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> Flask, jsonify, request ... <span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@app.route('/transactions/new', methods=['POST'])</span> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">new_transaction</span><span class="hljs-params">()</span>:</span> values = request.get_json() <span class="hljs-comment" style="color:rgb(153,153,136);"># Check that the required fields are in the POST'ed data</span> required = [<span class="hljs-string" style="color:rgb(221,17,68);">'sender'</span>, <span class="hljs-string" style="color:rgb(221,17,68);">'recipient'</span>, <span class="hljs-string" style="color:rgb(221,17,68);">'amount'</span>] <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">not</span> all(k <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">in</span> values <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> k <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">in</span> required): <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> <span class="hljs-string" style="color:rgb(221,17,68);">'Missing values'</span>, <span class="hljs-number" style="color:rgb(0,128,128);">400</span> <span class="hljs-comment" style="color:rgb(153,153,136);"># Create a new Transaction</span> index = blockchain.new_transaction(values[<span class="hljs-string" style="color:rgb(221,17,68);">'sender'</span>], values[<span class="hljs-string" style="color:rgb(221,17,68);">'recipient'</span>], values[<span class="hljs-string" style="color:rgb(221,17,68);">'amount'</span>]) response = {<span class="hljs-string" style="color:rgb(221,17,68);">'message'</span>: <span class="hljs-string" style="color:rgb(221,17,68);">f'Transaction will be added to Block <span class="hljs-subst" style="color:rgb(51,51,51);">{index}</span>'</span>} <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> jsonify(response), <span class="hljs-number" style="color:rgb(0,128,128);">201</span> </code></code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>④实现挖矿</strong></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">我们的挖矿方法是魔法发生的地方。它十分容易，只做三件事情：计算工作量证明；通过新增一笔交易奖励矿工一定数量的比特币；创建新的区块并将其添加到链中来。</p>
  <pre><code class="language-python"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> hashlib <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> json <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> time <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> time <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> uuid <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> uuid4 <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> flask <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> Flask, jsonify, request ... <span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@app.route('/mine', methods=['GET'])</span> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">mine</span><span class="hljs-params">()</span>:</span> <span class="hljs-comment" style="color:rgb(153,153,136);"># We run the proof of work algorithm to get the next proof...</span> last_block = blockchain.last_block last_proof = last_block[<span class="hljs-string" style="color:rgb(221,17,68);">'proof'</span>] proof = blockchain.proof_of_work(last_proof) <span class="hljs-comment" style="color:rgb(153,153,136);"># We must receive a reward for finding the proof.</span> <span class="hljs-comment" style="color:rgb(153,153,136);"># The sender is "0" to signify that this node has mined a new coin.</span> blockchain.new_transaction( sender=<span class="hljs-string" style="color:rgb(221,17,68);">"0"</span>, recipient=node_identifier, amount=<span class="hljs-number" style="color:rgb(0,128,128);">1</span>, ) <span class="hljs-comment" style="color:rgb(153,153,136);"># Forge the new Block by adding it to the chain</span> previous_hash = blockchain.hash(last_block) block = blockchain.new_block(proof, previous_hash) response = { <span class="hljs-string" style="color:rgb(221,17,68);">'message'</span>: <span class="hljs-string" style="color:rgb(221,17,68);">"New Block Forged"</span>, <span class="hljs-string" style="color:rgb(221,17,68);">'index'</span>: block[<span class="hljs-string" style="color:rgb(221,17,68);">'index'</span>], <span class="hljs-string" style="color:rgb(221,17,68);">'transactions'</span>: block[<span class="hljs-string" style="color:rgb(221,17,68);">'transactions'</span>], <span class="hljs-string" style="color:rgb(221,17,68);">'proof'</span>: block[<span class="hljs-string" style="color:rgb(221,17,68);">'proof'</span>], <span class="hljs-string" style="color:rgb(221,17,68);">'previous_hash'</span>: block[<span class="hljs-string" style="color:rgb(221,17,68);">'previous_hash'</span>], } <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> jsonify(response), <span class="hljs-number" style="color:rgb(0,128,128);">200</span> </code></code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">需要注意的是，开采块的交易接收者是我们自己服务器节点的地址，我们在这里所做的大部分工作只是与Blockchain类进行交互，基于以上我们区块链已经完成了，接下来开始交互演示。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">第三步：交互演示<br>您可以使用cURL或Postman与API进行交互。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">启动服务器：</p>
  <pre class="hljs vim" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);background:rgb(246,246,246) url(&quot;../img/blueprint.png&quot;) 0% 0%;border:none;"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">$ <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">python</span> blockchain.<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">py</span>
* Running <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">on</span> http://<span class="hljs-number" style="color:rgb(0,128,128);">127.0</span>.<span class="hljs-number" style="color:rgb(0,128,128);">0.1</span>:<span class="hljs-number" style="color:rgb(0,128,128);">5000</span>/ (Press CTRL+C <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">to</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">quit</span>)
</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">尝试通过向http：// localhost：5000 / mine发出GET请求来挖掘区块：</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180209141644147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1hfV2FuQ2xvdWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">创建一个新的交易，向<a href="http://localhost/" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.25);">http://localhost</a>:5000/transactions/new发出一个POST请求：</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180209141634896?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1hfV2FuQ2xvdWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">也可以使用cURL发送请求：</p>
  <pre class="hljs scilab" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);background:rgb(246,246,246) url(&quot;../img/blueprint.png&quot;) 0% 0%;border:none;"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">$ curl -X POST -H <span class="hljs-string" style="color:rgb(221,17,68);">"Content-Type: application/json"</span> -d <span class="hljs-string" style="color:rgb(221,17,68);">'{ "</span>sender<span class="hljs-string" style="color:rgb(221,17,68);">": "</span>d4ee26eee15148ee92c6cd394edd974e<span class="hljs-string" style="color:rgb(221,17,68);">", "</span>recipient<span class="hljs-string" style="color:rgb(221,17,68);">": "</span>someone-other-address<span class="hljs-string" style="color:rgb(221,17,68);">", "</span>amount<span class="hljs-string" style="color:rgb(221,17,68);">": 5 }'</span> <span class="hljs-string" style="color:rgb(221,17,68);">"http://localhost:5000/transactions/new"</span>
</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">以上仅为交互演示的示例，你可以在你自己所完成的区块链上进行更多尝试。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">第四步：共识机制<br>我们有一个基本的区块链可以进行交易和挖矿，但其实区块链更重要的意义在于它们是分布式的。那么我们需要确保所有的节点都运行在同一条链上，这就是回归到了共识问题，如果要满足在网络上有多个节点并且不断增加，我们必须要实现共识算法。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">①注册新的节点</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">在实现共识算法之前，需要找到一种方式让网络上的节点知道其相邻的节点，每个节点都需要存储网络上其他节点的记录。因此，我们需要新增几个方法来帮助实现：</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">1./nodes/register接受URL形式的新节点列表。</p>
  <ol style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li>/ nodes / resolve来执行我们的共识算法，它可以解决任何冲突，确保节点具有正确的链。</li>
  </ol>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">　下面我们将修改Blockchain的构造函数以提供注册节点的方法：</p>
  <pre><code class="language-python"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">... <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">from</span> urllib.parse <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">import</span> urlparse ... <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Blockchain</span><span class="hljs-params">(object)</span>:</span> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">__init__</span><span class="hljs-params">(self)</span>:</span> ... self.nodes = set() ... <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">register_node</span><span class="hljs-params">(self, address)</span>:</span> <span class="hljs-string" style="color:rgb(221,17,68);">""" Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. 'http://192.168.0.5:5000' :return: None """</span> parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) </code></code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">注意，我们使用set()集合来保存节点列表，这是确保新节点的添加是幂等的简便方法，这意味着无论我们添加特定节点多少次，它都只会出现一次。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">②实现共识算法</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">如前所述，当一个节点与另一个节点有不同时会发生冲突，为了解决这个问题，我们遵循取最长链原则，通过使用此算法，让网络中的节点间达成共识。</p>
  <pre><code class="language-ruby"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">... import requests <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Blockchain</span>(<span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">object</span>)</span> ... <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">valid_chain</span><span class="hljs-params">(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>, chain)</span></span>: <span class="hljs-string" style="color:rgb(221,17,68);">""</span><span class="hljs-string" style="color:rgb(221,17,68);">" Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not "</span><span class="hljs-string" style="color:rgb(221,17,68);">""</span> last_block = chain[<span class="hljs-number" style="color:rgb(0,128,128);">0</span>] current_index = <span class="hljs-number" style="color:rgb(0,128,128);">1</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">while</span> current_index &lt; len(chain): block = chain[current_index] print(f<span class="hljs-string" style="color:rgb(221,17,68);">'{last_block}'</span>) print(f<span class="hljs-string" style="color:rgb(221,17,68);">'{block}'</span>) print(<span class="hljs-string" style="color:rgb(221,17,68);">"\n-----------\n"</span>) <span class="hljs-comment" style="color:rgb(153,153,136);"># Check that the hash of the block is correct</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> block[<span class="hljs-string" style="color:rgb(221,17,68);">'previous_hash'</span>] != <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>.hash(last_block): <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> False <span class="hljs-comment" style="color:rgb(153,153,136);"># Check that the Proof of Work is correct</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">not</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>.valid_proof(last_block[<span class="hljs-string" style="color:rgb(221,17,68);">'proof'</span>], block[<span class="hljs-string" style="color:rgb(221,17,68);">'proof'</span>]): <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> False last_block = block current_index += <span class="hljs-number" style="color:rgb(0,128,128);">1</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> True <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">resolve_conflicts</span><span class="hljs-params">(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>)</span></span>: <span class="hljs-string" style="color:rgb(221,17,68);">""</span><span class="hljs-string" style="color:rgb(221,17,68);">" This is our Consensus Algorithm, it resolves conflicts by replacing our chain with the longest one in the network. :return: &lt;bool&gt; True if our chain was replaced, False if not "</span><span class="hljs-string" style="color:rgb(221,17,68);">""</span> neighbours = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>.nodes new_chain = None <span class="hljs-comment" style="color:rgb(153,153,136);"># We're only looking for chains longer than ours</span> max_length = len(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>.chain) <span class="hljs-comment" style="color:rgb(153,153,136);"># Grab and verify the chains from all the nodes in our network</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> node <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">in</span> <span class="hljs-symbol" style="color:rgb(153,0,115);">neighbours:</span> response = requests.get(f<span class="hljs-string" style="color:rgb(221,17,68);">'http://{node}/chain'</span>) <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> response.status_code == <span class="hljs-number" style="color:rgb(0,128,128);">200</span>: length = response.json()[<span class="hljs-string" style="color:rgb(221,17,68);">'length'</span>] chain = response.json()[<span class="hljs-string" style="color:rgb(221,17,68);">'chain'</span>] <span class="hljs-comment" style="color:rgb(153,153,136);"># Check if the length is longer and the chain is valid</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> length &gt; max_length <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">and</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>.valid_chain(chain): max_length = length new_chain = chain <span class="hljs-comment" style="color:rgb(153,153,136);"># Replace our chain if we discovered a new, valid chain longer than ours</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> <span class="hljs-symbol" style="color:rgb(153,0,115);">new_chain:</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">self</span>.chain = new_chain <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> True <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> False </code></code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">valid_chain（）负责检查一个链是否有效，具体方法是循环读取每个区块并验证哈希和证明。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">resolve_conflicts（）负责循环读取所有相邻节点，获取它们的链并使用上面的方法验证它们的有效性。如果找到了一个更长的有效链，则取代我们当前的链。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">我们将两个方法注册到我们的API中，一个用于添加相邻节点，另一个用于解决冲突：</p>
  <pre><code class="language-ruby"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">@app.route(<span class="hljs-string" style="color:rgb(221,17,68);">'/nodes/register'</span>, methods=[<span class="hljs-string" style="color:rgb(221,17,68);">'POST'</span>]) <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">register_nodes</span><span class="hljs-params">()</span></span>: values = request.get_json() nodes = values.get(<span class="hljs-string" style="color:rgb(221,17,68);">'nodes'</span>) <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> nodes is <span class="hljs-symbol" style="color:rgb(153,0,115);">None:</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> <span class="hljs-string" style="color:rgb(221,17,68);">"Error: Please supply a valid list of nodes"</span>, <span class="hljs-number" style="color:rgb(0,128,128);">400</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> node <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">in</span> <span class="hljs-symbol" style="color:rgb(153,0,115);">nodes:</span> blockchain.register_node(node) response = { <span class="hljs-string" style="color:rgb(221,17,68);">'message'</span>: <span class="hljs-string" style="color:rgb(221,17,68);">'New nodes have been added'</span>, <span class="hljs-string" style="color:rgb(221,17,68);">'total_nodes'</span>: list(blockchain.nodes), } <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> jsonify(response), <span class="hljs-number" style="color:rgb(0,128,128);">201</span> @app.route(<span class="hljs-string" style="color:rgb(221,17,68);">'/nodes/resolve'</span>, methods=[<span class="hljs-string" style="color:rgb(221,17,68);">'GET'</span>]) <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">def</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">consensus</span><span class="hljs-params">()</span></span>: replaced = blockchain.resolve_conflicts() <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> <span class="hljs-symbol" style="color:rgb(153,0,115);">replaced:</span> response = { <span class="hljs-string" style="color:rgb(221,17,68);">'message'</span>: <span class="hljs-string" style="color:rgb(221,17,68);">'Our chain was replaced'</span>, <span class="hljs-string" style="color:rgb(221,17,68);">'new_chain'</span>: blockchain.chain } <span class="hljs-symbol" style="color:rgb(153,0,115);">else:</span> response = { <span class="hljs-string" style="color:rgb(221,17,68);">'message'</span>: <span class="hljs-string" style="color:rgb(221,17,68);">'Our chain is authoritative'</span>, <span class="hljs-string" style="color:rgb(221,17,68);">'chain'</span>: blockchain.chain } <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> jsonify(response), <span class="hljs-number" style="color:rgb(0,128,128);">200</span> </code></code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">最后，如果你愿意的话可以开启另一台机器，并在你的网络上运转不同的节点。或者使用同一台机器上的不同端口启动进程。我在我的机器的不同端口创建另外一个节点，并将其注册到当前区块链网络中。 因此，我有两个节点：http：// localhost：5000和http：// localhost：5001。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/201802091417042?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1hfV2FuQ2xvdWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">为了确保链更长，我在节点2上挖掘了一些新的区块。 之后，我在节点1上调用GET / nodes / resolve，此处的链已经被共识算法计算后的得到的新链所替代。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180209141713164?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1hfV2FuQ2xvdWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">现在，你可以邀请一些朋友来一起测试你的区块链了。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">本文教程到此结束，那么，属于你自己的区块链撸好了吗？别忘了分享给身边同为程序员的朋友，一起来撸区块链！</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">本篇文章由万云团队编译，如需转载请联系万云官方微信：万云Wancloud</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/WX_WanCloud/article/details/79297123,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/WX_WanCloud/article/details/79297123,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
