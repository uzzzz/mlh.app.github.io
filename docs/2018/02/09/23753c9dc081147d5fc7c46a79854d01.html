<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>hyperledger v1.0.5 区块链运维入门 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="hyperledger v1.0.5 区块链运维入门" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="hyperledger v1.0.5 区块链运维入门 本文作者最近在找工作，有意向致电 13113668890 Mr.&nbsp;Neo Chen&nbsp;(陈景峯),&nbsp;netkiller, BG7NYT 中国广东省深圳市龙华新区民治街道溪山美地518131+86&nbsp;13113668890&lt;netkiller@msn.com&gt; 版权声明 转载请与作者联系，转载时请务必标明文章原始出处和作者信息及本声明。 http://www.netkiller.cn http://netkiller.github.io http://netkiller.sourceforge.net 微信订阅号 netkiller-ebook (微信扫描二维码） QQ：13721218 请注明“读者” QQ群：128659835 请注明“读者” 2018-02-08 摘要 你网上搜索hyperledger大部分文章是讲解开发环境的安装与配置，没有一篇关于怎样运维区块链的文章。当你配置好开发环境，写好合约，怎样落地呢？却很少文章提及。 要将区块链落地，我们必须依赖运维技术，这是IT基础设施，区块链应用将建立在这个基础设施之上，否则区块链就是浮云，悬在空中无法落地。 目录 1. 背景 2. 部署拓扑 2.1. 依赖关系 2.2. 准备物理机 3. 生成证书和创世区块 3.1. 创建配置文件 3.1.1. crypto-config.yaml 3.1.2. configtx.yaml 3.2. 启动 fabric-tools 容器 3.2.1. 启动 Docker 容器 3.2.2. 生成证书 3.2.3. 生成创世区块 3.2.4. 生成通道配置文件 3.2.5. generate anchor peer transaction 3.2.6. 清理 Docker 容器 4. CouchDB 节点 4.1. 安装 CouchDB 4.2. 启动 CouchDB 4.3. 备份与恢复 CouchDB&nbsp; 5. CA 节点安装 5.1. docker-compose-ca.yml 5.2. 启动 CA 节点 6. Orderer 节点安装 6.1. docker-compose-orderer.yml 6.2. 启动 Orderer 节点 7. Peer 节点安装 7.1. docker-compose-peer.yml 7.2. 启动 Peer 节点 7.3. 创建 Channel 8. Tools 节点安装 8.1.&nbsp; 9. 验收与测试 10. 总结 1.&nbsp;背景 由于区块链是区中心化，与传统运维不同，所以之前你积累的经验，不一定适用于区块链。要想运维好区块链项目，就必须理解去中心化这个概念。 首先谈谈传统运维，总结为三个字“中心化”，当然有人反对并抛出“分布式”感念，传统运维的分布式仍然建立在中心化的基础之上。 我们来看看传统应用模式，决多数应用都可以概括为： 用户&nbsp;-&gt;&nbsp;WEB&nbsp;-&gt;&nbsp;Application&nbsp;-&gt;&nbsp;Cache&nbsp;-&gt;&nbsp;Database&nbsp; 可以在这个体系下面做灵活变化，例如加入所有引擎、分布式文件系统，大数据等等应用，但都离不开这个模式。 区块链完全不同，如果举一个最接近的例子，我想可能与多数据中心远程异地灾备比较接近。 2.&nbsp;部署拓扑 什么是区块链呢？ 区块链实际上就是数据库，一个只能插入和查询的数据库，数据不能被修改和删除，并且这个数据库没有DBA管理员角色。这么一说你应该明白了把，实际上运维区块链就是在维护一个分布式数据库。 网上的绝大多数安装例子中，均采用 docker 部署方案，但无一例外的是，全部安装在一个物理机上。如果是生产环境，我们必须分开不是，首先要做的工作是化整为零，拆解应用，搞明白每个容器的功能和作用。然后我们将应用拆分，独立部署到物理节点上去。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;golang&nbsp;|&nbsp;nodejs&nbsp;|&nbsp;python&nbsp;|&nbsp;java&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fabric-ca&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+------------------------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V+-------------------+&nbsp;&nbsp;&nbsp;+-------------------+| Peer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;Peer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+&nbsp;&nbsp;&nbsp;+-------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V+-----------+&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+------------+|&nbsp;Orderer&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;Orderer&nbsp;&nbsp;&nbsp;&nbsp;|+-----------+&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Couchdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+ 接下来我们要做的工作是将上面拓扑图种的技术点分分击破。 由于 Hyperledger Fabric 是建立在 Docker 基础之上的。所以不建议你去除 Docker 转而使用传统的本地编译安装方式。我们仍然保持使用 Docker 在每个物理节点上，省去软件的编译和安装环节。 2.1.&nbsp;依赖关系 需要注意的是于其他传统系统一样，Hyperledger Fabric 的启动也是有顺序的，这是因为他们之间存在着依赖关系。 2.2.&nbsp;准备物理机 物理机 ca 节点，域名：ca.example.com，端口：7054 orderer 节点，域名 orderer.example.com，端口：7050 peer 节点，域名：peer.example.com，端口：7051、7053 couchdb 节点，域名 couchdb.example.com，端口：5984 tools 节点，域名：tools.example.com 3.&nbsp;生成证书和创世区块 这里我们需要几个命令（configtxgen configtxlator cryptogen），官方的安装方式： curl -sSL https://goo.gl/byy2Qj | bash -s 1.0.5 无论如何我都安装不成功，可能是（https://goo.gl/byy2Qj）被天朝给墙了。不过我发现 fabric-tools 里面有这个工具。 提示 经过翻墙发现 https://goo.gl/byy2Qj 地址是 301 到下面地址： https://raw.githubusercontent.com/hyperledger/fabric/v1.0.5/scripts/bootstrap.sh [root@localhost ~]# mkdir netkiller [root@localhost ~]# cd netkiller/ [root@localhost netkiller]# mkdir -p {chaincode,crypto-config,config,artifacts} 3.1.&nbsp;创建配置文件 3.1.1.&nbsp;crypto-config.yaml 创建证书 OrdererOrgs: - Name: Orderer Domain: example.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.example.com Template: Count: 1 Users: Count: 1 3.1.2.&nbsp;configtx.yaml --- Profiles: OneOrgOrdererGenesis: Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Consortiums: SampleConsortium: Organizations: - *Org1 OneOrgChannel: Consortium: SampleConsortium Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 Organizations: - &amp;OrdererOrg Name: OrdererOrg ID: OrdererMSP MSPDir: crypto-config/ordererOrganizations/example.com/msp - &amp;Org1 Name: Org1MSP ID: Org1MSP MSPDir: crypto-config/peerOrganizations/org1.example.com/msp AnchorPeers: - Host: peer0.org1.example.com Port: 7051 Orderer: &amp;OrdererDefaults OrdererType: solo Addresses: - orderer.example.com:7050 BatchTimeout: 2s BatchSize: MaxMessageCount: 10 AbsoluteMaxBytes: 99 MB PreferredMaxBytes: 512 KB Kafka: Brokers: - 127.0.0.1:9092 Organizations: Application: &amp;ApplicationDefaults Organizations: 3.2.&nbsp;启动 fabric-tools 容器 创建文件 docker-compose-tools.yml version: &#39;2&#39; networks: basic: services: tools: container_name: tools image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp - CORE_CHAINCODE_KEEPALIVE=10 # working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer working_dir: /root/netkiller command: /bin/bash volumes: - /var/run/:/host/var/run/ - ~/netkiller:/root/netkiller - ./chaincode/:/opt/gopath/src/github.com/ - ./crypto:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ networks: - basic 3.2.1.&nbsp;启动 Docker 容器 启动 Docker 容器 [root@localhost netkiller]# docker-compose -f docker-compose-tools.yml up -d Creating tools 进入容器 [root@localhost netkiller]# docker-compose -f docker-compose-tools.yml exec tools bash root@88e9040d2d2a:/opt/gopath/src/github.com/hyperledger/fabric/peer# 3.2.2.&nbsp;生成证书 命令 cryptogen generate --config=./crypto-config.yaml 演示 root@8f467a88de99:~/netkiller# cryptogen generate --config=./crypto-config.yaml org1.example.com root@8f467a88de99:~/netkiller# ls -1 crypto-config ordererOrganizations peerOrganizations 3.2.3.&nbsp;生成创世区块 root@8f467a88de99:~/netkiller# export FABRIC_CFG_PATH=$PWD root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgOrdererGenesis -outputBlock ./config/genesis.block 2018-02-08 08:35:30.121 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration 2018-02-08 08:35:30.236 UTC [common/configtx/tool] doOutputBlock -&gt; INFO 002 Generating genesis block 2018-02-08 08:35:30.238 UTC [common/configtx/tool] doOutputBlock -&gt; INFO 003 Writing genesis block 3.2.4.&nbsp;生成通道配置文件 命令 CHANNEL_NAME=mychannel configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME 操作演示 root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME 2018-02-08 08:41:08.010 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration 2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx 2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -&gt; INFO 003 Writing new channel tx 3.2.5.&nbsp; generate anchor peer transaction 命令 CHANNEL_NAME=mychannel configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP 操作演示 root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP 2018-02-08 08:46:19.162 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration 2018-02-08 08:46:19.176 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update 2018-02-08 08:46:19.177 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update 3.2.6.&nbsp;清理 Docker 容器 至此所需的证书与创世区块都已生产完毕，fabric-tools 容易完成了它的使命，你可以继续保留或者清理干净。 [root@localhost netkiller]# docker-compose -f docker-compose-tools.yml down Stopping tools ... done Removing tools ... done Removing network netkiller_basic 清理 tools 容器 docker rm -f $(docker ps -qa) 4.&nbsp;CouchDB 节点 整个 Hyperledger Fabric 技术栈中只有这个 CouchDB 是个外来户，看到 CouchDB 我就非常兴奋，这是一个NoSQL数据库(它与MongoDB十分类似)，所以CouchDB 100%可以独立运行，且最容易分离。 CouchDB 在这里有两个方案可以选择。 采用 Docker 运行 CouchDB的方案。 采用传统方式物理机上本地安装 CouchDB 理论两种方案对实际结果没有什么区别，只需提供IP地址，用户名与密码供其他节点访问即可。但实际我们看到 Hyperledger Fabric 使用的镜像是 hyperledger/fabric-couchdb 不清楚是否有修改过 CouchDB 数据库。 如果你对 Docker 比较熟悉就采用 Docker 方案。如果不熟悉就采用本地安装方式。总之选择一种你能Hold住（掌控）的方案，一旦出现故障，你能第一时间排查并处理。 4.1.&nbsp;安装 CouchDB 下面是 Docker 方案 [root@localhost netkiller]# vim docker-compose-couchdb.yml version: &#39;3&#39; networks: basic: services: couchdb: container_name: couchdb image: hyperledger/fabric-couchdb # Populate the COUCHDB_USER and COUCHDB_PASSWORD to set an admin user and password # for CouchDB. This will prevent CouchDB from operating in an &quot;Admin Party&quot; mode. environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=passw0rd ports: - 172.16.0.17:5984:5984 networks: - basic 4.2.&nbsp;启动 CouchDB 启动 Docker 容器 docker-compose -f docker-compose-couchdb.yml up -d 访问CouchDB管理界面，http://172.16.0.17:5984/_utils/ 请使用上面设置的密码进入。若想进入到容器内部可以使用下面命令： docker-compose -f docker-compose-couchdb.yml exec couchdb bash 至此 CouchDB 节点部署完毕。 4.3.&nbsp;备份与恢复 CouchDB&nbsp; 既然是运维区块链，对于运维工作我们最关心的就是如何备份数据，在出现故障的时候恢复数据。 npm install --save couchdb-backup-restore var cbr = require(&#39;couchdb-backup-restore&#39;); var config = {credentials: &#39;http://localhost:5984&#39;}; function done(err) { if (err) { return console.error(err); } console.log(&#39;all done!&#39;); } // backup cbr.backup(config, done).pipe(fs.createWriteStream(&#39;./db-backup.tar.gz&#39;)) // restore fs.createReadStream(&#39;./db-backup.tar.gz&#39;).pipe(cbr.restore(config, done)); 5.&nbsp;CA 节点安装 CA 节点需要我们之前生成 crypto-config&nbsp; 5.1.&nbsp;docker-compose-ca.yml version: &#39;3&#39; networks: basic: services: ca.example.com: image: hyperledger/fabric-ca environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca.example.com - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.example.com-cert.pem - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/4239aa0dcd76daeeb8ba0cda701851d14504d31aad1b2ddddbac6a57365e497c_sk ports: - &quot;XXX.XXX.XXX.XXX:7054:7054&quot; command: sh -c &#39;fabric-ca-server start -b admin:adminpw -d&#39; volumes: - ./crypto-config/peerOrganizations/org1.example.com/ca/:/etc/hyperledger/fabric-ca-server-config container_name: ca.example.com networks: - basic 5.2.&nbsp;启动 CA 节点 docker-compose -f docker-compose-ca.yaml up -d 6.&nbsp;Orderer 节点安装 6.1.&nbsp;docker-compose-orderer.yml version: &#39;3&#39; networks: basic: services: orderer.example.com: container_name: orderer.example.com image: hyperledger/fabric-orderer environment: - ORDERER_GENERAL_LOGLEVEL=debug - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 - ORDERER_GENERAL_GENESISMETHOD=file - ORDERER_GENERAL_GENESISFILE=/etc/hyperledger/configtx/genesis.block - ORDERER_GENERAL_LOCALMSPID=OrdererMSP - ORDERER_GENERAL_LOCALMSPDIR=/etc/hyperledger/msp/orderer/msp working_dir: /opt/gopath/src/github.com/hyperledger/fabric/orderer command: orderer ports: - 7050:7050 volumes: - ./config/:/etc/hyperledger/configtx - ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/:/etc/hyperledger/msp/orderer - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/:/etc/hyperledger/msp/peerOrg1 networks: - basic 6.2.&nbsp;启动 Orderer 节点 docker-compose -f docker-compose-orderer.yaml up -d 7.&nbsp;Peer 节点安装 7.1.&nbsp;docker-compose-peer.yml version: &#39;3&#39; networks: basic: services: peer0.org1.example.com: container_name: peer0.org1.example.com image: hyperledger/fabric-peer environment: - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_PEER_ID=peer0.org1.example.com - CORE_LOGGING_PEER=debug - CORE_CHAINCODE_LOGGING_LEVEL=DEBUG - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/peer/ - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 # # the following setting starts chaincode containers on the same # # bridge network as the peers # # https://docs.docker.com/compose/networking/ - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=${COMPOSE_PROJECT_NAME}_basic - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=172.16.0.17:5984 # The CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME and CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD # provide the credentials for ledger to connect to CouchDB. The username and password must # match the username and password set for the associated CouchDB. - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=passw0rd working_dir: /opt/gopath/src/github.com/hyperledger/fabric command: peer node start # command: peer node start --peer-chaincodedev=true ports: - 7051:7051 - 7053:7053 volumes: - /var/run/:/host/var/run/ - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/msp/peer - ./crypto-config/peerOrganizations/org1.example.com/users:/etc/hyperledger/msp/users - ./config:/etc/hyperledger/configtx #depends_on: # - orderer.example.com # - couchdb networks: - basic Peer 需要连接到 CouchDB 注意配置项 CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=172.16.0.17:5984&nbsp; 同时连接CouchDB的用户与密码要正确 7.2.&nbsp;启动 Peer 节点 [root@localhost netkiller]# docker-compose -f docker-compose-peer.yaml up -d 7.3.&nbsp;创建 Channel 进入 Peer 容器 docker-compose -f docker-compose-peer.yaml exec peer0.org1.example.com bash 添加 Orderer 节点并创建 Channel CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx 加入到 mychannel CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp peer channel join -b mychannel.block 查看通道 st t@f39764f58ff7:/opt/gopath/src/github.com/hyperledger/fabric# peer channel list 2018-02-09 08:12:46.454 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP 2018-02-09 08:12:46.454 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity 2018-02-09 08:12:46.456 UTC [channelCmd] InitCmdFactory -&gt; INFO 003 Endorser and orderer connections initialized 2018-02-09 08:12:46.457 UTC [msp/identity] Sign -&gt; DEBU 004 Sign: plaintext: 0A8A070A5C08031A0C08FEAFF5D30510...631A0D0A0B4765744368616E6E656C73 2018-02-09 08:12:46.458 UTC [msp/identity] Sign -&gt; DEBU 005 Sign: digest: E27446498819AA4FE8EE835ADEF16195489975377A3C18D89C36D37AA24E5CA2 2018-02-09 08:12:46.469 UTC [channelCmd] list -&gt; INFO 006 Channels peers has joined to: 2018-02-09 08:12:46.469 UTC [channelCmd] list -&gt; INFO 007 mychannel 2018-02-09 08:12:46.469 UTC [main] main -&gt; INFO 008 Exiting..... 8.&nbsp;Tools 节点安装 Tools 在生成创世区块的时候我们就曾经使用，你可以沿用之前的 tools 简单，或者创建一个 cli 节点，这个节点主要是用于管理区块链集群，例如合约部署，调试等等。 8.1.&nbsp; version: &#39;3&#39; networks: basic: services: cli: container_name: cli image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp - CORE_CHAINCODE_KEEPALIVE=10 working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer command: /bin/bash volumes: - /var/run/:/host/var/run/ - ./chaincode/:/opt/gopath/src/github.com/ - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ networks: - basic #depends_on: # - orderer.example.com # - peer0.org1.example.com # - couchdb 9.&nbsp;验收与测试 10.&nbsp;总结 阅读更多" />
<meta property="og:description" content="hyperledger v1.0.5 区块链运维入门 本文作者最近在找工作，有意向致电 13113668890 Mr.&nbsp;Neo Chen&nbsp;(陈景峯),&nbsp;netkiller, BG7NYT 中国广东省深圳市龙华新区民治街道溪山美地518131+86&nbsp;13113668890&lt;netkiller@msn.com&gt; 版权声明 转载请与作者联系，转载时请务必标明文章原始出处和作者信息及本声明。 http://www.netkiller.cn http://netkiller.github.io http://netkiller.sourceforge.net 微信订阅号 netkiller-ebook (微信扫描二维码） QQ：13721218 请注明“读者” QQ群：128659835 请注明“读者” 2018-02-08 摘要 你网上搜索hyperledger大部分文章是讲解开发环境的安装与配置，没有一篇关于怎样运维区块链的文章。当你配置好开发环境，写好合约，怎样落地呢？却很少文章提及。 要将区块链落地，我们必须依赖运维技术，这是IT基础设施，区块链应用将建立在这个基础设施之上，否则区块链就是浮云，悬在空中无法落地。 目录 1. 背景 2. 部署拓扑 2.1. 依赖关系 2.2. 准备物理机 3. 生成证书和创世区块 3.1. 创建配置文件 3.1.1. crypto-config.yaml 3.1.2. configtx.yaml 3.2. 启动 fabric-tools 容器 3.2.1. 启动 Docker 容器 3.2.2. 生成证书 3.2.3. 生成创世区块 3.2.4. 生成通道配置文件 3.2.5. generate anchor peer transaction 3.2.6. 清理 Docker 容器 4. CouchDB 节点 4.1. 安装 CouchDB 4.2. 启动 CouchDB 4.3. 备份与恢复 CouchDB&nbsp; 5. CA 节点安装 5.1. docker-compose-ca.yml 5.2. 启动 CA 节点 6. Orderer 节点安装 6.1. docker-compose-orderer.yml 6.2. 启动 Orderer 节点 7. Peer 节点安装 7.1. docker-compose-peer.yml 7.2. 启动 Peer 节点 7.3. 创建 Channel 8. Tools 节点安装 8.1.&nbsp; 9. 验收与测试 10. 总结 1.&nbsp;背景 由于区块链是区中心化，与传统运维不同，所以之前你积累的经验，不一定适用于区块链。要想运维好区块链项目，就必须理解去中心化这个概念。 首先谈谈传统运维，总结为三个字“中心化”，当然有人反对并抛出“分布式”感念，传统运维的分布式仍然建立在中心化的基础之上。 我们来看看传统应用模式，决多数应用都可以概括为： 用户&nbsp;-&gt;&nbsp;WEB&nbsp;-&gt;&nbsp;Application&nbsp;-&gt;&nbsp;Cache&nbsp;-&gt;&nbsp;Database&nbsp; 可以在这个体系下面做灵活变化，例如加入所有引擎、分布式文件系统，大数据等等应用，但都离不开这个模式。 区块链完全不同，如果举一个最接近的例子，我想可能与多数据中心远程异地灾备比较接近。 2.&nbsp;部署拓扑 什么是区块链呢？ 区块链实际上就是数据库，一个只能插入和查询的数据库，数据不能被修改和删除，并且这个数据库没有DBA管理员角色。这么一说你应该明白了把，实际上运维区块链就是在维护一个分布式数据库。 网上的绝大多数安装例子中，均采用 docker 部署方案，但无一例外的是，全部安装在一个物理机上。如果是生产环境，我们必须分开不是，首先要做的工作是化整为零，拆解应用，搞明白每个容器的功能和作用。然后我们将应用拆分，独立部署到物理节点上去。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;golang&nbsp;|&nbsp;nodejs&nbsp;|&nbsp;python&nbsp;|&nbsp;java&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fabric-ca&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+------------------------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V+-------------------+&nbsp;&nbsp;&nbsp;+-------------------+| Peer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;Peer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+&nbsp;&nbsp;&nbsp;+-------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V+-----------+&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+------------+|&nbsp;Orderer&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;Orderer&nbsp;&nbsp;&nbsp;&nbsp;|+-----------+&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Couchdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+ 接下来我们要做的工作是将上面拓扑图种的技术点分分击破。 由于 Hyperledger Fabric 是建立在 Docker 基础之上的。所以不建议你去除 Docker 转而使用传统的本地编译安装方式。我们仍然保持使用 Docker 在每个物理节点上，省去软件的编译和安装环节。 2.1.&nbsp;依赖关系 需要注意的是于其他传统系统一样，Hyperledger Fabric 的启动也是有顺序的，这是因为他们之间存在着依赖关系。 2.2.&nbsp;准备物理机 物理机 ca 节点，域名：ca.example.com，端口：7054 orderer 节点，域名 orderer.example.com，端口：7050 peer 节点，域名：peer.example.com，端口：7051、7053 couchdb 节点，域名 couchdb.example.com，端口：5984 tools 节点，域名：tools.example.com 3.&nbsp;生成证书和创世区块 这里我们需要几个命令（configtxgen configtxlator cryptogen），官方的安装方式： curl -sSL https://goo.gl/byy2Qj | bash -s 1.0.5 无论如何我都安装不成功，可能是（https://goo.gl/byy2Qj）被天朝给墙了。不过我发现 fabric-tools 里面有这个工具。 提示 经过翻墙发现 https://goo.gl/byy2Qj 地址是 301 到下面地址： https://raw.githubusercontent.com/hyperledger/fabric/v1.0.5/scripts/bootstrap.sh [root@localhost ~]# mkdir netkiller [root@localhost ~]# cd netkiller/ [root@localhost netkiller]# mkdir -p {chaincode,crypto-config,config,artifacts} 3.1.&nbsp;创建配置文件 3.1.1.&nbsp;crypto-config.yaml 创建证书 OrdererOrgs: - Name: Orderer Domain: example.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.example.com Template: Count: 1 Users: Count: 1 3.1.2.&nbsp;configtx.yaml --- Profiles: OneOrgOrdererGenesis: Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Consortiums: SampleConsortium: Organizations: - *Org1 OneOrgChannel: Consortium: SampleConsortium Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 Organizations: - &amp;OrdererOrg Name: OrdererOrg ID: OrdererMSP MSPDir: crypto-config/ordererOrganizations/example.com/msp - &amp;Org1 Name: Org1MSP ID: Org1MSP MSPDir: crypto-config/peerOrganizations/org1.example.com/msp AnchorPeers: - Host: peer0.org1.example.com Port: 7051 Orderer: &amp;OrdererDefaults OrdererType: solo Addresses: - orderer.example.com:7050 BatchTimeout: 2s BatchSize: MaxMessageCount: 10 AbsoluteMaxBytes: 99 MB PreferredMaxBytes: 512 KB Kafka: Brokers: - 127.0.0.1:9092 Organizations: Application: &amp;ApplicationDefaults Organizations: 3.2.&nbsp;启动 fabric-tools 容器 创建文件 docker-compose-tools.yml version: &#39;2&#39; networks: basic: services: tools: container_name: tools image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp - CORE_CHAINCODE_KEEPALIVE=10 # working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer working_dir: /root/netkiller command: /bin/bash volumes: - /var/run/:/host/var/run/ - ~/netkiller:/root/netkiller - ./chaincode/:/opt/gopath/src/github.com/ - ./crypto:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ networks: - basic 3.2.1.&nbsp;启动 Docker 容器 启动 Docker 容器 [root@localhost netkiller]# docker-compose -f docker-compose-tools.yml up -d Creating tools 进入容器 [root@localhost netkiller]# docker-compose -f docker-compose-tools.yml exec tools bash root@88e9040d2d2a:/opt/gopath/src/github.com/hyperledger/fabric/peer# 3.2.2.&nbsp;生成证书 命令 cryptogen generate --config=./crypto-config.yaml 演示 root@8f467a88de99:~/netkiller# cryptogen generate --config=./crypto-config.yaml org1.example.com root@8f467a88de99:~/netkiller# ls -1 crypto-config ordererOrganizations peerOrganizations 3.2.3.&nbsp;生成创世区块 root@8f467a88de99:~/netkiller# export FABRIC_CFG_PATH=$PWD root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgOrdererGenesis -outputBlock ./config/genesis.block 2018-02-08 08:35:30.121 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration 2018-02-08 08:35:30.236 UTC [common/configtx/tool] doOutputBlock -&gt; INFO 002 Generating genesis block 2018-02-08 08:35:30.238 UTC [common/configtx/tool] doOutputBlock -&gt; INFO 003 Writing genesis block 3.2.4.&nbsp;生成通道配置文件 命令 CHANNEL_NAME=mychannel configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME 操作演示 root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME 2018-02-08 08:41:08.010 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration 2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx 2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -&gt; INFO 003 Writing new channel tx 3.2.5.&nbsp; generate anchor peer transaction 命令 CHANNEL_NAME=mychannel configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP 操作演示 root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP 2018-02-08 08:46:19.162 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration 2018-02-08 08:46:19.176 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update 2018-02-08 08:46:19.177 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update 3.2.6.&nbsp;清理 Docker 容器 至此所需的证书与创世区块都已生产完毕，fabric-tools 容易完成了它的使命，你可以继续保留或者清理干净。 [root@localhost netkiller]# docker-compose -f docker-compose-tools.yml down Stopping tools ... done Removing tools ... done Removing network netkiller_basic 清理 tools 容器 docker rm -f $(docker ps -qa) 4.&nbsp;CouchDB 节点 整个 Hyperledger Fabric 技术栈中只有这个 CouchDB 是个外来户，看到 CouchDB 我就非常兴奋，这是一个NoSQL数据库(它与MongoDB十分类似)，所以CouchDB 100%可以独立运行，且最容易分离。 CouchDB 在这里有两个方案可以选择。 采用 Docker 运行 CouchDB的方案。 采用传统方式物理机上本地安装 CouchDB 理论两种方案对实际结果没有什么区别，只需提供IP地址，用户名与密码供其他节点访问即可。但实际我们看到 Hyperledger Fabric 使用的镜像是 hyperledger/fabric-couchdb 不清楚是否有修改过 CouchDB 数据库。 如果你对 Docker 比较熟悉就采用 Docker 方案。如果不熟悉就采用本地安装方式。总之选择一种你能Hold住（掌控）的方案，一旦出现故障，你能第一时间排查并处理。 4.1.&nbsp;安装 CouchDB 下面是 Docker 方案 [root@localhost netkiller]# vim docker-compose-couchdb.yml version: &#39;3&#39; networks: basic: services: couchdb: container_name: couchdb image: hyperledger/fabric-couchdb # Populate the COUCHDB_USER and COUCHDB_PASSWORD to set an admin user and password # for CouchDB. This will prevent CouchDB from operating in an &quot;Admin Party&quot; mode. environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=passw0rd ports: - 172.16.0.17:5984:5984 networks: - basic 4.2.&nbsp;启动 CouchDB 启动 Docker 容器 docker-compose -f docker-compose-couchdb.yml up -d 访问CouchDB管理界面，http://172.16.0.17:5984/_utils/ 请使用上面设置的密码进入。若想进入到容器内部可以使用下面命令： docker-compose -f docker-compose-couchdb.yml exec couchdb bash 至此 CouchDB 节点部署完毕。 4.3.&nbsp;备份与恢复 CouchDB&nbsp; 既然是运维区块链，对于运维工作我们最关心的就是如何备份数据，在出现故障的时候恢复数据。 npm install --save couchdb-backup-restore var cbr = require(&#39;couchdb-backup-restore&#39;); var config = {credentials: &#39;http://localhost:5984&#39;}; function done(err) { if (err) { return console.error(err); } console.log(&#39;all done!&#39;); } // backup cbr.backup(config, done).pipe(fs.createWriteStream(&#39;./db-backup.tar.gz&#39;)) // restore fs.createReadStream(&#39;./db-backup.tar.gz&#39;).pipe(cbr.restore(config, done)); 5.&nbsp;CA 节点安装 CA 节点需要我们之前生成 crypto-config&nbsp; 5.1.&nbsp;docker-compose-ca.yml version: &#39;3&#39; networks: basic: services: ca.example.com: image: hyperledger/fabric-ca environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca.example.com - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.example.com-cert.pem - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/4239aa0dcd76daeeb8ba0cda701851d14504d31aad1b2ddddbac6a57365e497c_sk ports: - &quot;XXX.XXX.XXX.XXX:7054:7054&quot; command: sh -c &#39;fabric-ca-server start -b admin:adminpw -d&#39; volumes: - ./crypto-config/peerOrganizations/org1.example.com/ca/:/etc/hyperledger/fabric-ca-server-config container_name: ca.example.com networks: - basic 5.2.&nbsp;启动 CA 节点 docker-compose -f docker-compose-ca.yaml up -d 6.&nbsp;Orderer 节点安装 6.1.&nbsp;docker-compose-orderer.yml version: &#39;3&#39; networks: basic: services: orderer.example.com: container_name: orderer.example.com image: hyperledger/fabric-orderer environment: - ORDERER_GENERAL_LOGLEVEL=debug - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 - ORDERER_GENERAL_GENESISMETHOD=file - ORDERER_GENERAL_GENESISFILE=/etc/hyperledger/configtx/genesis.block - ORDERER_GENERAL_LOCALMSPID=OrdererMSP - ORDERER_GENERAL_LOCALMSPDIR=/etc/hyperledger/msp/orderer/msp working_dir: /opt/gopath/src/github.com/hyperledger/fabric/orderer command: orderer ports: - 7050:7050 volumes: - ./config/:/etc/hyperledger/configtx - ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/:/etc/hyperledger/msp/orderer - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/:/etc/hyperledger/msp/peerOrg1 networks: - basic 6.2.&nbsp;启动 Orderer 节点 docker-compose -f docker-compose-orderer.yaml up -d 7.&nbsp;Peer 节点安装 7.1.&nbsp;docker-compose-peer.yml version: &#39;3&#39; networks: basic: services: peer0.org1.example.com: container_name: peer0.org1.example.com image: hyperledger/fabric-peer environment: - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_PEER_ID=peer0.org1.example.com - CORE_LOGGING_PEER=debug - CORE_CHAINCODE_LOGGING_LEVEL=DEBUG - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/peer/ - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 # # the following setting starts chaincode containers on the same # # bridge network as the peers # # https://docs.docker.com/compose/networking/ - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=${COMPOSE_PROJECT_NAME}_basic - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=172.16.0.17:5984 # The CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME and CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD # provide the credentials for ledger to connect to CouchDB. The username and password must # match the username and password set for the associated CouchDB. - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=passw0rd working_dir: /opt/gopath/src/github.com/hyperledger/fabric command: peer node start # command: peer node start --peer-chaincodedev=true ports: - 7051:7051 - 7053:7053 volumes: - /var/run/:/host/var/run/ - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/msp/peer - ./crypto-config/peerOrganizations/org1.example.com/users:/etc/hyperledger/msp/users - ./config:/etc/hyperledger/configtx #depends_on: # - orderer.example.com # - couchdb networks: - basic Peer 需要连接到 CouchDB 注意配置项 CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=172.16.0.17:5984&nbsp; 同时连接CouchDB的用户与密码要正确 7.2.&nbsp;启动 Peer 节点 [root@localhost netkiller]# docker-compose -f docker-compose-peer.yaml up -d 7.3.&nbsp;创建 Channel 进入 Peer 容器 docker-compose -f docker-compose-peer.yaml exec peer0.org1.example.com bash 添加 Orderer 节点并创建 Channel CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx 加入到 mychannel CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp peer channel join -b mychannel.block 查看通道 st t@f39764f58ff7:/opt/gopath/src/github.com/hyperledger/fabric# peer channel list 2018-02-09 08:12:46.454 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP 2018-02-09 08:12:46.454 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity 2018-02-09 08:12:46.456 UTC [channelCmd] InitCmdFactory -&gt; INFO 003 Endorser and orderer connections initialized 2018-02-09 08:12:46.457 UTC [msp/identity] Sign -&gt; DEBU 004 Sign: plaintext: 0A8A070A5C08031A0C08FEAFF5D30510...631A0D0A0B4765744368616E6E656C73 2018-02-09 08:12:46.458 UTC [msp/identity] Sign -&gt; DEBU 005 Sign: digest: E27446498819AA4FE8EE835ADEF16195489975377A3C18D89C36D37AA24E5CA2 2018-02-09 08:12:46.469 UTC [channelCmd] list -&gt; INFO 006 Channels peers has joined to: 2018-02-09 08:12:46.469 UTC [channelCmd] list -&gt; INFO 007 mychannel 2018-02-09 08:12:46.469 UTC [main] main -&gt; INFO 008 Exiting..... 8.&nbsp;Tools 节点安装 Tools 在生成创世区块的时候我们就曾经使用，你可以沿用之前的 tools 简单，或者创建一个 cli 节点，这个节点主要是用于管理区块链集群，例如合约部署，调试等等。 8.1.&nbsp; version: &#39;3&#39; networks: basic: services: cli: container_name: cli image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp - CORE_CHAINCODE_KEEPALIVE=10 working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer command: /bin/bash volumes: - /var/run/:/host/var/run/ - ./chaincode/:/opt/gopath/src/github.com/ - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ networks: - basic #depends_on: # - orderer.example.com # - peer0.org1.example.com # - couchdb 9.&nbsp;验收与测试 10.&nbsp;总结 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/02/09/23753c9dc081147d5fc7c46a79854d01.html" />
<meta property="og:url" content="https://mlh.app/2018/02/09/23753c9dc081147d5fc7c46a79854d01.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"hyperledger v1.0.5 区块链运维入门 本文作者最近在找工作，有意向致电 13113668890 Mr.&nbsp;Neo Chen&nbsp;(陈景峯),&nbsp;netkiller, BG7NYT 中国广东省深圳市龙华新区民治街道溪山美地518131+86&nbsp;13113668890&lt;netkiller@msn.com&gt; 版权声明 转载请与作者联系，转载时请务必标明文章原始出处和作者信息及本声明。 http://www.netkiller.cn http://netkiller.github.io http://netkiller.sourceforge.net 微信订阅号 netkiller-ebook (微信扫描二维码） QQ：13721218 请注明“读者” QQ群：128659835 请注明“读者” 2018-02-08 摘要 你网上搜索hyperledger大部分文章是讲解开发环境的安装与配置，没有一篇关于怎样运维区块链的文章。当你配置好开发环境，写好合约，怎样落地呢？却很少文章提及。 要将区块链落地，我们必须依赖运维技术，这是IT基础设施，区块链应用将建立在这个基础设施之上，否则区块链就是浮云，悬在空中无法落地。 目录 1. 背景 2. 部署拓扑 2.1. 依赖关系 2.2. 准备物理机 3. 生成证书和创世区块 3.1. 创建配置文件 3.1.1. crypto-config.yaml 3.1.2. configtx.yaml 3.2. 启动 fabric-tools 容器 3.2.1. 启动 Docker 容器 3.2.2. 生成证书 3.2.3. 生成创世区块 3.2.4. 生成通道配置文件 3.2.5. generate anchor peer transaction 3.2.6. 清理 Docker 容器 4. CouchDB 节点 4.1. 安装 CouchDB 4.2. 启动 CouchDB 4.3. 备份与恢复 CouchDB&nbsp; 5. CA 节点安装 5.1. docker-compose-ca.yml 5.2. 启动 CA 节点 6. Orderer 节点安装 6.1. docker-compose-orderer.yml 6.2. 启动 Orderer 节点 7. Peer 节点安装 7.1. docker-compose-peer.yml 7.2. 启动 Peer 节点 7.3. 创建 Channel 8. Tools 节点安装 8.1.&nbsp; 9. 验收与测试 10. 总结 1.&nbsp;背景 由于区块链是区中心化，与传统运维不同，所以之前你积累的经验，不一定适用于区块链。要想运维好区块链项目，就必须理解去中心化这个概念。 首先谈谈传统运维，总结为三个字“中心化”，当然有人反对并抛出“分布式”感念，传统运维的分布式仍然建立在中心化的基础之上。 我们来看看传统应用模式，决多数应用都可以概括为： 用户&nbsp;-&gt;&nbsp;WEB&nbsp;-&gt;&nbsp;Application&nbsp;-&gt;&nbsp;Cache&nbsp;-&gt;&nbsp;Database&nbsp; 可以在这个体系下面做灵活变化，例如加入所有引擎、分布式文件系统，大数据等等应用，但都离不开这个模式。 区块链完全不同，如果举一个最接近的例子，我想可能与多数据中心远程异地灾备比较接近。 2.&nbsp;部署拓扑 什么是区块链呢？ 区块链实际上就是数据库，一个只能插入和查询的数据库，数据不能被修改和删除，并且这个数据库没有DBA管理员角色。这么一说你应该明白了把，实际上运维区块链就是在维护一个分布式数据库。 网上的绝大多数安装例子中，均采用 docker 部署方案，但无一例外的是，全部安装在一个物理机上。如果是生产环境，我们必须分开不是，首先要做的工作是化整为零，拆解应用，搞明白每个容器的功能和作用。然后我们将应用拆分，独立部署到物理节点上去。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;golang&nbsp;|&nbsp;nodejs&nbsp;|&nbsp;python&nbsp;|&nbsp;java&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+------------------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fabric-ca&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+------------------------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V+-------------------+&nbsp;&nbsp;&nbsp;+-------------------+| Peer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;Peer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+&nbsp;&nbsp;&nbsp;+-------------------+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V+-----------+&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+------------+|&nbsp;Orderer&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;Orderer&nbsp;&nbsp;&nbsp;&nbsp;|+-----------+&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Couchdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+ 接下来我们要做的工作是将上面拓扑图种的技术点分分击破。 由于 Hyperledger Fabric 是建立在 Docker 基础之上的。所以不建议你去除 Docker 转而使用传统的本地编译安装方式。我们仍然保持使用 Docker 在每个物理节点上，省去软件的编译和安装环节。 2.1.&nbsp;依赖关系 需要注意的是于其他传统系统一样，Hyperledger Fabric 的启动也是有顺序的，这是因为他们之间存在着依赖关系。 2.2.&nbsp;准备物理机 物理机 ca 节点，域名：ca.example.com，端口：7054 orderer 节点，域名 orderer.example.com，端口：7050 peer 节点，域名：peer.example.com，端口：7051、7053 couchdb 节点，域名 couchdb.example.com，端口：5984 tools 节点，域名：tools.example.com 3.&nbsp;生成证书和创世区块 这里我们需要几个命令（configtxgen configtxlator cryptogen），官方的安装方式： curl -sSL https://goo.gl/byy2Qj | bash -s 1.0.5 无论如何我都安装不成功，可能是（https://goo.gl/byy2Qj）被天朝给墙了。不过我发现 fabric-tools 里面有这个工具。 提示 经过翻墙发现 https://goo.gl/byy2Qj 地址是 301 到下面地址： https://raw.githubusercontent.com/hyperledger/fabric/v1.0.5/scripts/bootstrap.sh [root@localhost ~]# mkdir netkiller [root@localhost ~]# cd netkiller/ [root@localhost netkiller]# mkdir -p {chaincode,crypto-config,config,artifacts} 3.1.&nbsp;创建配置文件 3.1.1.&nbsp;crypto-config.yaml 创建证书 OrdererOrgs: - Name: Orderer Domain: example.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.example.com Template: Count: 1 Users: Count: 1 3.1.2.&nbsp;configtx.yaml --- Profiles: OneOrgOrdererGenesis: Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Consortiums: SampleConsortium: Organizations: - *Org1 OneOrgChannel: Consortium: SampleConsortium Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 Organizations: - &amp;OrdererOrg Name: OrdererOrg ID: OrdererMSP MSPDir: crypto-config/ordererOrganizations/example.com/msp - &amp;Org1 Name: Org1MSP ID: Org1MSP MSPDir: crypto-config/peerOrganizations/org1.example.com/msp AnchorPeers: - Host: peer0.org1.example.com Port: 7051 Orderer: &amp;OrdererDefaults OrdererType: solo Addresses: - orderer.example.com:7050 BatchTimeout: 2s BatchSize: MaxMessageCount: 10 AbsoluteMaxBytes: 99 MB PreferredMaxBytes: 512 KB Kafka: Brokers: - 127.0.0.1:9092 Organizations: Application: &amp;ApplicationDefaults Organizations: 3.2.&nbsp;启动 fabric-tools 容器 创建文件 docker-compose-tools.yml version: &#39;2&#39; networks: basic: services: tools: container_name: tools image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp - CORE_CHAINCODE_KEEPALIVE=10 # working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer working_dir: /root/netkiller command: /bin/bash volumes: - /var/run/:/host/var/run/ - ~/netkiller:/root/netkiller - ./chaincode/:/opt/gopath/src/github.com/ - ./crypto:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ networks: - basic 3.2.1.&nbsp;启动 Docker 容器 启动 Docker 容器 [root@localhost netkiller]# docker-compose -f docker-compose-tools.yml up -d Creating tools 进入容器 [root@localhost netkiller]# docker-compose -f docker-compose-tools.yml exec tools bash root@88e9040d2d2a:/opt/gopath/src/github.com/hyperledger/fabric/peer# 3.2.2.&nbsp;生成证书 命令 cryptogen generate --config=./crypto-config.yaml 演示 root@8f467a88de99:~/netkiller# cryptogen generate --config=./crypto-config.yaml org1.example.com root@8f467a88de99:~/netkiller# ls -1 crypto-config ordererOrganizations peerOrganizations 3.2.3.&nbsp;生成创世区块 root@8f467a88de99:~/netkiller# export FABRIC_CFG_PATH=$PWD root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgOrdererGenesis -outputBlock ./config/genesis.block 2018-02-08 08:35:30.121 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration 2018-02-08 08:35:30.236 UTC [common/configtx/tool] doOutputBlock -&gt; INFO 002 Generating genesis block 2018-02-08 08:35:30.238 UTC [common/configtx/tool] doOutputBlock -&gt; INFO 003 Writing genesis block 3.2.4.&nbsp;生成通道配置文件 命令 CHANNEL_NAME=mychannel configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME 操作演示 root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME 2018-02-08 08:41:08.010 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration 2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx 2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -&gt; INFO 003 Writing new channel tx 3.2.5.&nbsp; generate anchor peer transaction 命令 CHANNEL_NAME=mychannel configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP 操作演示 root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP 2018-02-08 08:46:19.162 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration 2018-02-08 08:46:19.176 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update 2018-02-08 08:46:19.177 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update 3.2.6.&nbsp;清理 Docker 容器 至此所需的证书与创世区块都已生产完毕，fabric-tools 容易完成了它的使命，你可以继续保留或者清理干净。 [root@localhost netkiller]# docker-compose -f docker-compose-tools.yml down Stopping tools ... done Removing tools ... done Removing network netkiller_basic 清理 tools 容器 docker rm -f $(docker ps -qa) 4.&nbsp;CouchDB 节点 整个 Hyperledger Fabric 技术栈中只有这个 CouchDB 是个外来户，看到 CouchDB 我就非常兴奋，这是一个NoSQL数据库(它与MongoDB十分类似)，所以CouchDB 100%可以独立运行，且最容易分离。 CouchDB 在这里有两个方案可以选择。 采用 Docker 运行 CouchDB的方案。 采用传统方式物理机上本地安装 CouchDB 理论两种方案对实际结果没有什么区别，只需提供IP地址，用户名与密码供其他节点访问即可。但实际我们看到 Hyperledger Fabric 使用的镜像是 hyperledger/fabric-couchdb 不清楚是否有修改过 CouchDB 数据库。 如果你对 Docker 比较熟悉就采用 Docker 方案。如果不熟悉就采用本地安装方式。总之选择一种你能Hold住（掌控）的方案，一旦出现故障，你能第一时间排查并处理。 4.1.&nbsp;安装 CouchDB 下面是 Docker 方案 [root@localhost netkiller]# vim docker-compose-couchdb.yml version: &#39;3&#39; networks: basic: services: couchdb: container_name: couchdb image: hyperledger/fabric-couchdb # Populate the COUCHDB_USER and COUCHDB_PASSWORD to set an admin user and password # for CouchDB. This will prevent CouchDB from operating in an &quot;Admin Party&quot; mode. environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=passw0rd ports: - 172.16.0.17:5984:5984 networks: - basic 4.2.&nbsp;启动 CouchDB 启动 Docker 容器 docker-compose -f docker-compose-couchdb.yml up -d 访问CouchDB管理界面，http://172.16.0.17:5984/_utils/ 请使用上面设置的密码进入。若想进入到容器内部可以使用下面命令： docker-compose -f docker-compose-couchdb.yml exec couchdb bash 至此 CouchDB 节点部署完毕。 4.3.&nbsp;备份与恢复 CouchDB&nbsp; 既然是运维区块链，对于运维工作我们最关心的就是如何备份数据，在出现故障的时候恢复数据。 npm install --save couchdb-backup-restore var cbr = require(&#39;couchdb-backup-restore&#39;); var config = {credentials: &#39;http://localhost:5984&#39;}; function done(err) { if (err) { return console.error(err); } console.log(&#39;all done!&#39;); } // backup cbr.backup(config, done).pipe(fs.createWriteStream(&#39;./db-backup.tar.gz&#39;)) // restore fs.createReadStream(&#39;./db-backup.tar.gz&#39;).pipe(cbr.restore(config, done)); 5.&nbsp;CA 节点安装 CA 节点需要我们之前生成 crypto-config&nbsp; 5.1.&nbsp;docker-compose-ca.yml version: &#39;3&#39; networks: basic: services: ca.example.com: image: hyperledger/fabric-ca environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca.example.com - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.example.com-cert.pem - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/4239aa0dcd76daeeb8ba0cda701851d14504d31aad1b2ddddbac6a57365e497c_sk ports: - &quot;XXX.XXX.XXX.XXX:7054:7054&quot; command: sh -c &#39;fabric-ca-server start -b admin:adminpw -d&#39; volumes: - ./crypto-config/peerOrganizations/org1.example.com/ca/:/etc/hyperledger/fabric-ca-server-config container_name: ca.example.com networks: - basic 5.2.&nbsp;启动 CA 节点 docker-compose -f docker-compose-ca.yaml up -d 6.&nbsp;Orderer 节点安装 6.1.&nbsp;docker-compose-orderer.yml version: &#39;3&#39; networks: basic: services: orderer.example.com: container_name: orderer.example.com image: hyperledger/fabric-orderer environment: - ORDERER_GENERAL_LOGLEVEL=debug - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 - ORDERER_GENERAL_GENESISMETHOD=file - ORDERER_GENERAL_GENESISFILE=/etc/hyperledger/configtx/genesis.block - ORDERER_GENERAL_LOCALMSPID=OrdererMSP - ORDERER_GENERAL_LOCALMSPDIR=/etc/hyperledger/msp/orderer/msp working_dir: /opt/gopath/src/github.com/hyperledger/fabric/orderer command: orderer ports: - 7050:7050 volumes: - ./config/:/etc/hyperledger/configtx - ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/:/etc/hyperledger/msp/orderer - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/:/etc/hyperledger/msp/peerOrg1 networks: - basic 6.2.&nbsp;启动 Orderer 节点 docker-compose -f docker-compose-orderer.yaml up -d 7.&nbsp;Peer 节点安装 7.1.&nbsp;docker-compose-peer.yml version: &#39;3&#39; networks: basic: services: peer0.org1.example.com: container_name: peer0.org1.example.com image: hyperledger/fabric-peer environment: - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_PEER_ID=peer0.org1.example.com - CORE_LOGGING_PEER=debug - CORE_CHAINCODE_LOGGING_LEVEL=DEBUG - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/peer/ - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 # # the following setting starts chaincode containers on the same # # bridge network as the peers # # https://docs.docker.com/compose/networking/ - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=${COMPOSE_PROJECT_NAME}_basic - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=172.16.0.17:5984 # The CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME and CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD # provide the credentials for ledger to connect to CouchDB. The username and password must # match the username and password set for the associated CouchDB. - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=passw0rd working_dir: /opt/gopath/src/github.com/hyperledger/fabric command: peer node start # command: peer node start --peer-chaincodedev=true ports: - 7051:7051 - 7053:7053 volumes: - /var/run/:/host/var/run/ - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/msp/peer - ./crypto-config/peerOrganizations/org1.example.com/users:/etc/hyperledger/msp/users - ./config:/etc/hyperledger/configtx #depends_on: # - orderer.example.com # - couchdb networks: - basic Peer 需要连接到 CouchDB 注意配置项 CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=172.16.0.17:5984&nbsp; 同时连接CouchDB的用户与密码要正确 7.2.&nbsp;启动 Peer 节点 [root@localhost netkiller]# docker-compose -f docker-compose-peer.yaml up -d 7.3.&nbsp;创建 Channel 进入 Peer 容器 docker-compose -f docker-compose-peer.yaml exec peer0.org1.example.com bash 添加 Orderer 节点并创建 Channel CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx 加入到 mychannel CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp peer channel join -b mychannel.block 查看通道 st t@f39764f58ff7:/opt/gopath/src/github.com/hyperledger/fabric# peer channel list 2018-02-09 08:12:46.454 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP 2018-02-09 08:12:46.454 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity 2018-02-09 08:12:46.456 UTC [channelCmd] InitCmdFactory -&gt; INFO 003 Endorser and orderer connections initialized 2018-02-09 08:12:46.457 UTC [msp/identity] Sign -&gt; DEBU 004 Sign: plaintext: 0A8A070A5C08031A0C08FEAFF5D30510...631A0D0A0B4765744368616E6E656C73 2018-02-09 08:12:46.458 UTC [msp/identity] Sign -&gt; DEBU 005 Sign: digest: E27446498819AA4FE8EE835ADEF16195489975377A3C18D89C36D37AA24E5CA2 2018-02-09 08:12:46.469 UTC [channelCmd] list -&gt; INFO 006 Channels peers has joined to: 2018-02-09 08:12:46.469 UTC [channelCmd] list -&gt; INFO 007 mychannel 2018-02-09 08:12:46.469 UTC [main] main -&gt; INFO 008 Exiting..... 8.&nbsp;Tools 节点安装 Tools 在生成创世区块的时候我们就曾经使用，你可以沿用之前的 tools 简单，或者创建一个 cli 节点，这个节点主要是用于管理区块链集群，例如合约部署，调试等等。 8.1.&nbsp; version: &#39;3&#39; networks: basic: services: cli: container_name: cli image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp - CORE_CHAINCODE_KEEPALIVE=10 working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer command: /bin/bash volumes: - /var/run/:/host/var/run/ - ./chaincode/:/opt/gopath/src/github.com/ - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ networks: - basic #depends_on: # - orderer.example.com # - peer0.org1.example.com # - couchdb 9.&nbsp;验收与测试 10.&nbsp;总结 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/02/09/23753c9dc081147d5fc7c46a79854d01.html","headline":"hyperledger v1.0.5 区块链运维入门","dateModified":"2018-02-09T00:00:00+08:00","datePublished":"2018-02-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/02/09/23753c9dc081147d5fc7c46a79854d01.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>hyperledger v1.0.5 区块链运维入门</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div class="titlepage">
   <div>
    <div>
     <h2 class="title">hyperledger v1.0.5 区块链运维入门</h2>
    </div>
    <div>
     <h3 class="subtitle">本文作者最近在找工作，有意向致电 13113668890</h3>
    </div>
    <div>
     <div class="author">
      <h3 class="author"><span class="honorific">Mr</span>.&nbsp;<span class="firstname">Neo Chen</span>&nbsp;<span class="surname">(陈景峯)</span>,&nbsp;<span class="lineage">netkiller, BG7NYT</span></h3>
      <div class="affiliation">
       <div class="address">
        <p><br><span class="country">中国</span><span class="state">广东省</span><span class="city">深圳市</span><span class="street">龙华新区民治街道溪山美地</span><br><span class="postcode">518131</span><br><span class="phone">+86&nbsp;13113668890</span><br><br><code class="email">&lt;<a class="email" href="mailto:netkiller@msn.com" rel="nofollow">netkiller@msn.com</a>&gt;</code><br></p>
       </div>
      </div>
     </div>
    </div>
    <div>
     <div class="legalnotice">
      <p class="legalnotice-title"><strong>版权声明</strong></p>
      <p>转载请与作者联系，转载时请务必标明文章原始出处和作者信息及本声明。</p>
      <table class="simplelist" style="border:0px;">
       <tbody>
        <tr>
         <td><a class="ulink" href="http://creativecommons.org/licenses/by/3.0/" rel="nofollow"></a>
          <table style="border:0px;width:180px;">
           <tbody>
            <tr>
             <td><img src="http://www.netkiller.cn/images/by-nc-sa.png" alt=""></td>
            </tr>
           </tbody>
          </table></td>
         <td>
          <table class="simplelist" style="border:0px;">
           <tbody>
            <tr>
             <td><a class="ulink" href="http://www.netkiller.cn/" rel="nofollow">http://www.netkiller.cn</a></td>
            </tr>
            <tr>
             <td><a class="ulink" href="http://netkiller.github.io/" rel="nofollow">http://netkiller.github.io</a></td>
            </tr>
            <tr>
             <td><a class="ulink" href="http://netkiller.sourceforge.net/" rel="nofollow">http://netkiller.sourceforge.net</a></td>
            </tr>
           </tbody>
          </table></td>
         <td><a class="ulink" href="http://www.netkiller.cn/images/weixin.jpg" rel="nofollow"></a>
          <table style="border:0px;width:80px;">
           <tbody>
            <tr>
             <td><img src="http://www.netkiller.cn/images/weixin.jpg" alt=""></td>
            </tr>
           </tbody>
          </table></td>
         <td>
          <table class="simplelist" style="border:0px;">
           <tbody>
            <tr>
             <td>微信订阅号 netkiller-ebook (微信扫描二维码）</td>
            </tr>
            <tr>
             <td>QQ：13721218 请注明“读者”</td>
            </tr>
            <tr>
             <td>QQ群：128659835 请注明“读者”</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table>
      <p></p>
     </div>
    </div>
    <div>
     <p class="pubdate">2018-02-08</p>
    </div>
    <div>
     <div class="abstract">
      <div class="abstract-title">
       摘要
      </div>
      <p>你网上搜索hyperledger大部分文章是讲解开发环境的安装与配置，没有一篇关于怎样运维区块链的文章。当你配置好开发环境，写好合约，怎样落地呢？却很少文章提及。</p>
      <p>要将区块链落地，我们必须依赖运维技术，这是IT基础设施，区块链应用将建立在这个基础设施之上，否则区块链就是浮云，悬在空中无法落地。</p>
     </div>
    </div>
   </div>
   <hr>
  </div>
  <div class="toc">
   <div class="toc-title">
    目录
   </div>
   <ul class="toc">
    <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#background" rel="nofollow">1. 背景</a></span></li>
    <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#overview" rel="nofollow">2. 部署拓扑</a></span>
     <ul>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#depends" rel="nofollow">2.1. 依赖关系</a></span></li>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#hosts" rel="nofollow">2.2. 准备物理机</a></span></li>
     </ul></li>
    <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#genesis" rel="nofollow">3. 生成证书和创世区块</a></span>
     <ul>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#genesis.block" rel="nofollow">3.1. 创建配置文件</a></span>
       <ul>
        <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#crypto-config.yaml" rel="nofollow">3.1.1. crypto-config.yaml</a></span></li>
        <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#" rel="nofollow">3.1.2. configtx.yaml</a></span></li>
       </ul></li>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#genesis.fabric-tools" rel="nofollow">3.2. 启动 fabric-tools 容器</a></span>
       <ul>
        <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#" rel="nofollow">3.2.1. 启动 Docker 容器</a></span></li>
        <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#" rel="nofollow">3.2.2. 生成证书</a></span></li>
        <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#" rel="nofollow">3.2.3. 生成创世区块</a></span></li>
        <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#" rel="nofollow">3.2.4. 生成通道配置文件</a></span></li>
        <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#" rel="nofollow">3.2.5. generate anchor peer transaction</a></span></li>
        <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#" rel="nofollow">3.2.6. 清理 Docker 容器</a></span></li>
       </ul></li>
     </ul></li>
    <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#couchdb" rel="nofollow">4. CouchDB 节点</a></span>
     <ul>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#couchdb.docker-compose" rel="nofollow">4.1. 安装 CouchDB</a></span></li>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#couchdb.up" rel="nofollow">4.2. 启动 CouchDB</a></span></li>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#couchdb.backup" rel="nofollow">4.3. 备份与恢复 CouchDB&nbsp;</a></span></li>
     </ul></li>
    <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#ca" rel="nofollow">5. CA 节点安装</a></span>
     <ul>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#docker-compose-ca.yaml" rel="nofollow">5.1. docker-compose-ca.yml</a></span></li>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#ca.up" rel="nofollow">5.2. 启动 CA 节点</a></span></li>
     </ul></li>
    <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#orderer" rel="nofollow">6. Orderer 节点安装</a></span>
     <ul>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#" rel="nofollow">6.1. docker-compose-orderer.yml</a></span></li>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#" rel="nofollow">6.2. 启动 Orderer 节点</a></span></li>
     </ul></li>
    <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#peer" rel="nofollow">7. Peer 节点安装</a></span>
     <ul>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#" rel="nofollow">7.1. docker-compose-peer.yml</a></span></li>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#peer.up" rel="nofollow">7.2. 启动 Peer 节点</a></span></li>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#peel.channel" rel="nofollow">7.3. 创建 Channel</a></span></li>
     </ul></li>
    <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#tools" rel="nofollow">8. Tools 节点安装</a></span>
     <ul>
      <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#" rel="nofollow">8.1.&nbsp;</a></span></li>
     </ul></li>
    <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#test" rel="nofollow">9. 验收与测试</a></span></li>
    <li><span class="section"><a href="http://www.netkiller.cn/journal/hyperledger.cluster.html#summary" rel="nofollow">10. 总结</a></span></li>
   </ul>
  </div>
  <div class="titlepage">
   <h2 class="title" style="clear:both;">1.&nbsp;背景</h2>
  </div>
  <p>由于区块链是区中心化，与传统运维不同，所以之前你积累的经验，不一定适用于区块链。要想运维好区块链项目，就必须理解去中心化这个概念。</p>
  <p>首先谈谈传统运维，总结为三个字“中心化”，当然有人反对并抛出“分布式”感念，传统运维的分布式仍然建立在中心化的基础之上。</p>
  <p>我们来看看传统应用模式，决多数应用都可以概括为：</p>
  <div class="literallayout">
   <p><br><br>用户&nbsp;-&gt;&nbsp;WEB&nbsp;-&gt;&nbsp;Application&nbsp;-&gt;&nbsp;Cache&nbsp;-&gt;&nbsp;Database&nbsp;<br><br></p>
  </div>
  <p>可以在这个体系下面做灵活变化，例如加入所有引擎、分布式文件系统，大数据等等应用，但都离不开这个模式。</p>
  <p>区块链完全不同，如果举一个最接近的例子，我想可能与多数据中心远程异地灾备比较接近。</p>
  <div class="titlepage">
   <h2 class="title" style="clear:both;">2.&nbsp;部署拓扑</h2>
  </div>
  <p>什么是区块链呢？ 区块链实际上就是数据库，一个只能插入和查询的数据库，数据不能被修改和删除，并且这个数据库没有DBA管理员角色。这么一说你应该明白了把，实际上运维区块链就是在维护一个分布式数据库。</p>
  <p>网上的绝大多数安装例子中，均采用 docker 部署方案，但无一例外的是，全部安装在一个物理机上。如果是生产环境，我们必须分开不是，首先要做的工作是化整为零，拆解应用，搞明白每个容器的功能和作用。然后我们将应用拆分，独立部署到物理节点上去。</p>
  <div class="literallayout">
   <p><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;golang&nbsp;|&nbsp;nodejs&nbsp;|&nbsp;python&nbsp;|&nbsp;java&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---------------------------------+ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+------------------------------+ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fabric-ca&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+------------------------------+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V<br>+-------------------+&nbsp;&nbsp;&nbsp;+-------------------+<br>| Peer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;Peer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>+-------------------+&nbsp;&nbsp;&nbsp;+-------------------+ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V<br>+-----------+&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+------------+<br>|&nbsp;Orderer&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;Orderer&nbsp;&nbsp;&nbsp;&nbsp;|<br>+-----------+&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+------------+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Couchdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-------------------+ <br><br></p>
  </div>
  <p>接下来我们要做的工作是将上面拓扑图种的技术点分分击破。</p>
  <p>由于 Hyperledger Fabric 是建立在 Docker 基础之上的。所以不建议你去除 Docker 转而使用传统的本地编译安装方式。我们仍然保持使用 Docker 在每个物理节点上，省去软件的编译和安装环节。</p>
  <div class="titlepage">
   <h3 class="title">2.1.&nbsp;依赖关系</h3>
  </div>
  <p>需要注意的是于其他传统系统一样，Hyperledger Fabric 的启动也是有顺序的，这是因为他们之间存在着依赖关系。</p>
  <div class="titlepage">
   <h3 class="title">2.2.&nbsp;准备物理机</h3>
  </div>
  <div class="itemizedlist">
   <div class="itemizedlist-title">
    物理机
   </div>
   <ul class="itemizedlist">
    <li class="listitem"><p>ca 节点，域名：ca.example.com，端口：7054</p></li>
    <li class="listitem"><p>orderer 节点，域名 orderer.example.com，端口：7050</p></li>
    <li class="listitem"><p>peer 节点，域名：peer.example.com，端口：7051、7053</p></li>
    <li class="listitem"><p>couchdb 节点，域名 couchdb.example.com，端口：5984</p></li>
    <li class="listitem"><p>tools 节点，域名：tools.example.com</p></li>
   </ul>
  </div>
  <div class="titlepage">
   <h2 class="title" style="clear:both;">3.&nbsp;生成证书和创世区块</h2>
  </div>
  <p>这里我们需要几个命令（configtxgen configtxlator cryptogen），官方的安装方式：</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">		
curl -sSL https://goo.gl/byy2Qj | bash -s 1.0.5
		
		</pre>
  <p>无论如何我都安装不成功，可能是（https://goo.gl/byy2Qj）被天朝给墙了。不过我发现 fabric-tools 里面有这个工具。</p>
  <div class="tip">
   <h3 class="title">提示</h3>
   <p>经过翻墙发现 https://goo.gl/byy2Qj 地址是 301 到下面地址：</p>
   <p><a class="ulink" href="https://raw.githubusercontent.com/hyperledger/fabric/v1.0.5/scripts/bootstrap.sh" rel="nofollow">https://raw.githubusercontent.com/hyperledger/fabric/v1.0.5/scripts/bootstrap.sh</a></p>
  </div>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">		
[root@localhost ~]# mkdir netkiller
[root@localhost ~]# cd netkiller/
[root@localhost netkiller]# mkdir -p {chaincode,crypto-config,config,artifacts}	
		
		</pre>
  <div class="titlepage">
   <h3 class="title">3.1.&nbsp;创建配置文件</h3>
  </div>
  <div class="titlepage">
   <h4 class="title">3.1.1.&nbsp;crypto-config.yaml</h4>
  </div>
  <p>创建证书</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
OrdererOrgs:
  - Name: Orderer
    Domain: example.com
    Specs:
      - Hostname: orderer
PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    Template:
      Count: 1
    Users:
      Count: 1			
				
				</pre>
  <div class="titlepage">
   <h4 class="title">3.1.2.&nbsp;configtx.yaml</h4>
  </div>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
---
Profiles:

    OneOrgOrdererGenesis:
        Orderer:
            &lt;&lt;: *OrdererDefaults
            Organizations:
                - *OrdererOrg
        Consortiums:
            SampleConsortium:
                Organizations:
                    - *Org1
    OneOrgChannel:
        Consortium: SampleConsortium
        Application:
            &lt;&lt;: *ApplicationDefaults
            Organizations:
                - *Org1

Organizations:

    - &amp;OrdererOrg
        Name: OrdererOrg

        ID: OrdererMSP

        MSPDir: crypto-config/ordererOrganizations/example.com/msp

    - &amp;Org1
        Name: Org1MSP

        ID: Org1MSP

        MSPDir: crypto-config/peerOrganizations/org1.example.com/msp

        AnchorPeers:
            - Host: peer0.org1.example.com
              Port: 7051

Orderer: &amp;OrdererDefaults

    OrdererType: solo

    Addresses:
        - orderer.example.com:7050

    BatchTimeout: 2s

    BatchSize:

        MaxMessageCount: 10

        AbsoluteMaxBytes: 99 MB

        PreferredMaxBytes: 512 KB

    Kafka:
        Brokers:
            - 127.0.0.1:9092

    Organizations:

Application: &amp;ApplicationDefaults

    Organizations:
				
				</pre>
  <div class="titlepage">
   <h3 class="title">3.2.&nbsp;启动 fabric-tools 容器</h3>
  </div>
  <p>创建文件 docker-compose-tools.yml</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
version: '2'

networks:
  basic:

services:
  tools:
    container_name: tools 
    image: hyperledger/fabric-tools
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_ID=cli
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
      - CORE_CHAINCODE_KEEPALIVE=10
    # working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    working_dir: /root/netkiller
    command: /bin/bash
    volumes:
        - /var/run/:/host/var/run/
        - ~/netkiller:/root/netkiller
        - ./chaincode/:/opt/gopath/src/github.com/
        - ./crypto:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
    networks:
        - basic
			
			</pre>
  <div class="titlepage">
   <h4 class="title">3.2.1.&nbsp;启动 Docker 容器</h4>
  </div>
  <p>启动 Docker 容器</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
[root@localhost netkiller]# docker-compose -f docker-compose-tools.yml up -d
Creating tools
				
				</pre>
  <p>进入容器</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
[root@localhost netkiller]# docker-compose -f docker-compose-tools.yml exec tools bash
root@88e9040d2d2a:/opt/gopath/src/github.com/hyperledger/fabric/peer#				
				
				</pre>
  <div class="titlepage">
   <h4 class="title">3.2.2.&nbsp;生成证书</h4>
  </div>
  <p>命令</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
cryptogen generate --config=./crypto-config.yaml
				
				</pre>
  <p>演示</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
root@8f467a88de99:~/netkiller# cryptogen generate --config=./crypto-config.yaml
org1.example.com

root@8f467a88de99:~/netkiller# ls -1 crypto-config
ordererOrganizations
peerOrganizations
				
				</pre>
  <div class="titlepage">
   <h4 class="title">3.2.3.&nbsp;生成创世区块</h4>
  </div>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
root@8f467a88de99:~/netkiller# export FABRIC_CFG_PATH=$PWD				
root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgOrdererGenesis -outputBlock ./config/genesis.block
2018-02-08 08:35:30.121 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration
2018-02-08 08:35:30.236 UTC [common/configtx/tool] doOutputBlock -&gt; INFO 002 Generating genesis block
2018-02-08 08:35:30.238 UTC [common/configtx/tool] doOutputBlock -&gt; INFO 003 Writing genesis block			
				
				</pre>
  <div class="titlepage">
   <h4 class="title">3.2.4.&nbsp;生成通道配置文件</h4>
  </div>
  <p>命令</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
CHANNEL_NAME=mychannel
configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME				
				
				</pre>
  <p>操作演示</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel
root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME 
2018-02-08 08:41:08.010 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration
2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx
2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -&gt; INFO 003 Writing new channel tx				
				
				</pre>
  <div class="titlepage">
   <h4 class="title">3.2.5.&nbsp; generate anchor peer transaction</h4>
  </div>
  <p>命令</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
CHANNEL_NAME=mychannel
configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP				
				
				</pre>
  <p>操作演示</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel
root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP
2018-02-08 08:46:19.162 UTC [common/configtx/tool] main -&gt; INFO 001 Loading configuration
2018-02-08 08:46:19.176 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update
2018-02-08 08:46:19.177 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update
				
				</pre>
  <div class="titlepage">
   <h4 class="title">3.2.6.&nbsp;清理 Docker 容器</h4>
  </div>
  <p>至此所需的证书与创世区块都已生产完毕，fabric-tools 容易完成了它的使命，你可以继续保留或者清理干净。</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
[root@localhost netkiller]# docker-compose -f docker-compose-tools.yml down
Stopping tools ... done
Removing tools ... done
Removing network netkiller_basic
				
				</pre>
  <p>清理 tools 容器</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">				
docker rm -f $(docker ps -qa)
				
				</pre>
  <div class="titlepage">
   <h2 class="title" style="clear:both;">4.&nbsp;CouchDB 节点</h2>
  </div>
  <p>整个 Hyperledger Fabric 技术栈中只有这个 CouchDB 是个外来户，看到 CouchDB 我就非常兴奋，这是一个NoSQL数据库(它与MongoDB十分类似)，所以CouchDB 100%可以独立运行，且最容易分离。</p>
  <p>CouchDB 在这里有两个方案可以选择。</p>
  <div class="itemizedlist">
   <div class="itemizedlist-title">
    <ul class="itemizedlist">
     <li class="listitem"><p>采用 Docker 运行 CouchDB的方案。</p></li>
     <li class="listitem"><p>采用传统方式物理机上本地安装 CouchDB</p></li>
    </ul>
   </div>
   <p>理论两种方案对实际结果没有什么区别，只需提供IP地址，用户名与密码供其他节点访问即可。但实际我们看到 Hyperledger Fabric 使用的镜像是 hyperledger/fabric-couchdb 不清楚是否有修改过 CouchDB 数据库。</p>
   <p>如果你对 Docker 比较熟悉就采用 Docker 方案。如果不熟悉就采用本地安装方式。总之选择一种你能Hold住（掌控）的方案，一旦出现故障，你能第一时间排查并处理。</p>
   <div class="titlepage">
    <h3 class="title">4.1.&nbsp;安装 CouchDB</h3>
   </div>
   <p>下面是 Docker 方案</p>
   <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
[root@localhost netkiller]# vim docker-compose-couchdb.yml
		
version: '3'

networks:
  basic:

services:
  couchdb:
    container_name: couchdb
    image: hyperledger/fabric-couchdb
    # Populate the COUCHDB_USER and COUCHDB_PASSWORD to set an admin user and password
    # for CouchDB.  This will prevent CouchDB from operating in an "Admin Party" mode.
    environment:
      - COUCHDB_USER=admin
      - COUCHDB_PASSWORD=passw0rd
    ports:
      - 172.16.0.17:5984:5984
    networks:
      - basic
			
			</pre>
   <div class="titlepage">
    <h3 class="title">4.2.&nbsp;启动 CouchDB</h3>
   </div>
   <p>启动 Docker 容器</p>
   <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
docker-compose -f docker-compose-couchdb.yml up -d		
			
			</pre>
   <p>访问CouchDB管理界面，http://172.16.0.17:5984/_utils/ 请使用上面设置的密码进入。若想进入到容器内部可以使用下面命令：</p>
   <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
docker-compose -f docker-compose-couchdb.yml exec couchdb bash	
			
			</pre>
   <p>至此 CouchDB 节点部署完毕。</p>
   <div class="titlepage">
    <h3 class="title">4.3.&nbsp;备份与恢复 CouchDB&nbsp;</h3>
   </div>
   <p>既然是运维区块链，对于运维工作我们最关心的就是如何备份数据，在出现故障的时候恢复数据。</p>
   <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
npm install --save couchdb-backup-restore			
			
			</pre>
   <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
var cbr = require('couchdb-backup-restore');
 
var config = {credentials: 'http://localhost:5984'};
 
function done(err) {
  if (err) {
    return console.error(err);
  }
  console.log('all done!');
}
 
// backup 
cbr.backup(config, done).pipe(fs.createWriteStream('./db-backup.tar.gz'))

// restore 
fs.createReadStream('./db-backup.tar.gz').pipe(cbr.restore(config, done));
			
			</pre>
  </div>
  <div class="titlepage">
   <h2 class="title" style="clear:both;">5.&nbsp;CA 节点安装</h2>
  </div>
  <p>CA 节点需要我们之前生成 crypto-config&nbsp;</p>
  <div class="titlepage">
   <h3 class="title">5.1.&nbsp;docker-compose-ca.yml</h3>
  </div>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
version: '3'

networks:
  basic:

services:
  ca.example.com:
    image: hyperledger/fabric-ca
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.example.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.example.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/4239aa0dcd76daeeb8ba0cda701851d14504d31aad1b2ddddbac6a57365e497c_sk
    ports:
      - "XXX.XXX.XXX.XXX:7054:7054"
    command: sh -c 'fabric-ca-server start -b admin:adminpw -d'
    volumes:
      - ./crypto-config/peerOrganizations/org1.example.com/ca/:/etc/hyperledger/fabric-ca-server-config
    container_name: ca.example.com
    networks:
      - basic			
			
			</pre>
  <div class="titlepage">
   <h3 class="title">5.2.&nbsp;启动 CA 节点</h3>
  </div>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
docker-compose -f docker-compose-ca.yaml up -d			
			
			</pre>
  <div class="titlepage">
   <h2 class="title" style="clear:both;">6.&nbsp;Orderer 节点安装</h2>
  </div>
  <p></p>
  <div class="titlepage">
   <h3 class="title">6.1.&nbsp;docker-compose-orderer.yml</h3>
  </div>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
version: '3'

networks:
  basic:

services:
  orderer.example.com:
    container_name: orderer.example.com
    image: hyperledger/fabric-orderer
    environment:
      - ORDERER_GENERAL_LOGLEVEL=debug
      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
      - ORDERER_GENERAL_GENESISMETHOD=file
      - ORDERER_GENERAL_GENESISFILE=/etc/hyperledger/configtx/genesis.block
      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
      - ORDERER_GENERAL_LOCALMSPDIR=/etc/hyperledger/msp/orderer/msp
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/orderer
    command: orderer
    ports:
      - 7050:7050
    volumes:
        - ./config/:/etc/hyperledger/configtx
        - ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/:/etc/hyperledger/msp/orderer
        - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/:/etc/hyperledger/msp/peerOrg1
    networks:
      - basic			
			
			</pre>
  <div class="titlepage">
   <h3 class="title">6.2.&nbsp;启动 Orderer 节点</h3>
  </div>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
docker-compose -f docker-compose-orderer.yaml up -d			
			
			</pre>
  <div class="titlepage">
   <h2 class="title" style="clear:both;">7.&nbsp;Peer 节点安装</h2>
  </div>
  <p></p>
  <div class="titlepage">
   <h3 class="title">7.1.&nbsp;docker-compose-peer.yml</h3>
  </div>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
version: '3'

networks:
  basic:

services:

  peer0.org1.example.com:
    container_name: peer0.org1.example.com
    image: hyperledger/fabric-peer
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer0.org1.example.com
      - CORE_LOGGING_PEER=debug
      - CORE_CHAINCODE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/peer/
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      # # the following setting starts chaincode containers on the same
      # # bridge network as the peers
      # # https://docs.docker.com/compose/networking/
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=${COMPOSE_PROJECT_NAME}_basic
      - CORE_LEDGER_STATE_STATEDATABASE=CouchDB
      - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=172.16.0.17:5984
      # The CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME and CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD
      # provide the credentials for ledger to connect to CouchDB.  The username and password must
      # match the username and password set for the associated CouchDB.
      - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin
      - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=passw0rd
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric
    command: peer node start
    # command: peer node start --peer-chaincodedev=true
    ports:
      - 7051:7051
      - 7053:7053
    volumes:
        - /var/run/:/host/var/run/
        - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/msp/peer
        - ./crypto-config/peerOrganizations/org1.example.com/users:/etc/hyperledger/msp/users
        - ./config:/etc/hyperledger/configtx
    #depends_on:
    #  - orderer.example.com
    #  - couchdb
    networks:
      - basic
			
			</pre>
  <p>Peer 需要连接到 CouchDB 注意配置项 CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=172.16.0.17:5984&nbsp;</p>
  <p>同时连接CouchDB的用户与密码要正确</p>
  <div class="titlepage">
   <h3 class="title">7.2.&nbsp;启动 Peer 节点</h3>
  </div>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
[root@localhost netkiller]# docker-compose -f docker-compose-peer.yaml up -d
			
			</pre>
  <div class="titlepage">
   <h3 class="title">7.3.&nbsp;创建 Channel</h3>
  </div>
  <p>进入 Peer 容器</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
docker-compose -f docker-compose-peer.yaml exec peer0.org1.example.com bash
			
			</pre>
  <p>添加 Orderer 节点并创建 Channel</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
CORE_PEER_LOCALMSPID=Org1MSP
CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp
peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx			
			
			</pre>
  <p>加入到 mychannel</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
CORE_PEER_LOCALMSPID=Org1MSP
CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp
peer channel join -b mychannel.block
			
			</pre>
  <p>查看通道</p>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
st t@f39764f58ff7:/opt/gopath/src/github.com/hyperledger/fabric# peer channel list
2018-02-09 08:12:46.454 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP
2018-02-09 08:12:46.454 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity
2018-02-09 08:12:46.456 UTC [channelCmd] InitCmdFactory -&gt; INFO 003 Endorser and orderer connections initialized
2018-02-09 08:12:46.457 UTC [msp/identity] Sign -&gt; DEBU 004 Sign: plaintext: 0A8A070A5C08031A0C08FEAFF5D30510...631A0D0A0B4765744368616E6E656C73 
2018-02-09 08:12:46.458 UTC [msp/identity] Sign -&gt; DEBU 005 Sign: digest: E27446498819AA4FE8EE835ADEF16195489975377A3C18D89C36D37AA24E5CA2 
2018-02-09 08:12:46.469 UTC [channelCmd] list -&gt; INFO 006 Channels peers has joined to: 
2018-02-09 08:12:46.469 UTC [channelCmd] list -&gt; INFO 007 mychannel 
2018-02-09 08:12:46.469 UTC [main] main -&gt; INFO 008 Exiting.....			
			
			</pre>
  <div class="titlepage">
   <h2 class="title" style="clear:both;">8.&nbsp;Tools 节点安装</h2>
  </div>
  <p>Tools 在生成创世区块的时候我们就曾经使用，你可以沿用之前的 tools 简单，或者创建一个 cli 节点，这个节点主要是用于管理区块链集群，例如合约部署，调试等等。</p>
  <div class="titlepage">
   <h3 class="title">8.1.&nbsp;</h3>
  </div>
  <pre class="screen" style="background-color:rgb(238,238,238);border:1px solid #000000;">			
version: '3'

networks:
  basic:

services:
			
  cli:
    container_name: cli
    image: hyperledger/fabric-tools
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_ID=cli
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
      - CORE_CHAINCODE_KEEPALIVE=10
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    command: /bin/bash
    volumes:
        - /var/run/:/host/var/run/
        - ./chaincode/:/opt/gopath/src/github.com/
        - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
    networks:
        - basic
    #depends_on:
    #  - orderer.example.com
    #  - peer0.org1.example.com
    #  - couchdb	
			
			</pre>
  <div class="titlepage">
   <h2 class="title" style="clear:both;">9.&nbsp;验收与测试</h2>
  </div>
  <div class="titlepage">
   <h2 class="title" style="clear:both;">10.&nbsp;总结</h2>
   <div>
    <br>
   </div>
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u010604770/article/details/79300637,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u010604770/article/details/79300637,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
