<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>《Fabric交易流程》Transaction Flow 非直译文 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="《Fabric交易流程》Transaction Flow 非直译文" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="原文链接：https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html 【这篇文章不用直译。】 Transaction Flow 交易流程 This document outlines the transactional mechanics that take place during a standard asset exchange. The scenario includes two clients, A and B, who are buying and selling radishes. They each have a peer on the network through which they send their transactions and interact with the ledger. 这个篇文章描述了在“标准资产交易”过程中节点之间的内部交易机制。以A和B两个人交易萝卜为例，他们两个人都各自在网络中拥有Peer节点，用于在区块链账本中记账。 Assumptions 假设 This flow assumes that a channel is set up and running. The application user has registered and enrolled with the organization’s certificate authority (CA) and received back necessary cryptographic material, which is used to authenticate to the network. 假设Channel已经设置好配置，并正在运行着。所有用户的Peer节点应用程序已经注册了并且取得了用于权限验证的CA证书，以及相应的加密资料（就是一堆配置文件，确实了访问不了网络）。 The chaincode (containing a set of key value pairs representing the initial state of the radish market) is installed on the peers and instantiated on the channel. The chaincode contains logic defining a set of transaction instructions and the agreed upon price for a radish. An endorsement policy has also been set for this chaincode, stating that both&nbsp;peerA&nbsp;and&nbsp;peerB&nbsp;must endorse any transaction. chaincode 链码会被安装到Peer节点上，并且在Channel上实例化（Channel实例建立在Orders形成的网络里的），链码包含了“交易指令”和“商品价格”。链码也“背书担保规则”，A和B的Peer节点会对满足“背书担保规则”的交易，进行担保。 Client A initiates a transaction&nbsp; 客户A发起一笔交易 What’s happening? - Client A is sending a request to purchase radishes. The request targets&nbsp;peerA&nbsp;and&nbsp;peerB, who are respectively representative of Client A and Client B. The endorsement policy states that both peers must endorse any transaction, therefore the request goes to&nbsp;peerA&nbsp;and&nbsp;peerB. 客户A用App发起一笔购买萝卜的订单，这个订单请求会被发送给节点A和节点B。 倘若“背书担保规则”设定为对所有交易均可担保，那么这个请求将被Peer节点接受。 Next, the transaction proposal is constructed. An application leveraging a supported SDK (Node, Java, Python) utilizes one of the available API’s which generates a transaction proposal. The proposal is a request to invoke a chaincode function so that data can be read and/or written to the ledger (i.e. write new key value pairs for the assets). The SDK serves as a shim to package the transaction proposal into the properly architected format (protocol buffer over gRPC) and takes the user’s cryptographic credentials to produce a unique signature for this transaction proposal. 下一步是构建 “交易提案”。 这个发起交易的App会借助 Fabric 客户端 SDK中的其中 API接口 生成一个 “交易提案”。这个提案的内容是 请求调用ChainCode链码去读取或者写入账本。 （一个shim是一个库,它将一个新的API引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现）Fabric客户端的SDK（以Shim库的形式）序列化“交易提案”为一个 结构化的文本格式并利用客户端用户的加密凭证为该“交易提案”生成一个签名。 Endorsing peers verify signature &amp; execute the transaction&nbsp; &nbsp; &nbsp; &nbsp;Peer为担保的交易验证签名&amp;执行交易 The endorsing peers verify (1) that the transaction proposal is well formed, (2) it has not been submitted already in the past (replay-attack protection), (3) the signature is valid (using MSP), and (4) that the submitter (Client A, in the example) is properly authorized to perform the proposed operation on that channel (namely, each endorsing peer ensures that the submitter satisfies the channel’s&nbsp;Writers&nbsp;policy). The endorsing peers take the transaction proposal inputs as arguments to the invoked chaincode’s function. The chaincode is then executed against the current state database to produce transaction results including a response value, read set, and write set. No updates are made to the ledger at this point. The set of these values, along with the endorsing peer’s signature is passed back as a “proposal response” to the SDK which parses the payload for the application to consume. 担保的Peer节点需要验证的条款有： （1）交易提案格式是否正确&nbsp; （2）是否被提交过（防止重放攻击） （3）签名是否有效（签名是否为CA颁发的） （4）提交的客户端APP（客户A）是否被授权在该Channel执行 “发起交易”的操作指令。 担保的Peer节点会在调用ChainCode链码函数时将该“交易提案”作为参数传入。 链码会根据当前账本数据库的数据去处理交易结果，交易结果包含了：返回码、读取的数据集合、写入的数据集合（这个写入操作暂时不会对数据库执行）。 这个时候还不会将对账本进行更新。然后这些被ChainCode处理后的“交易结果”会带上Peer的签名一起返回给客户端的SDK程序，客户端的SDK程序会解析这些数据，提供给App做下一步处理。 {The MSP is a peer component that allows them to verify transaction requests arriving from clients and to sign transaction results(endorsements). The Writing policy is defined at channel creation time, and determines which user is entitled to submit a transaction to that channel.} { MSP（由CA 针对每个Peer节点进行颁发） 是一个Peer的组件，有了它才可以被允许对来自客户端的交易进行验证，以及对ChainCode处理后的交易结果进行签名。The Writing policy“写入规则” 在通道创建的时候被定义，他声明了哪些客户端用户有权利发起“交易提案”给哪些“Channel通道”。} Proposal responses are inspected The application verifies the endorsing peer signatures and compares the proposal responses to determine if the proposal responses are the same. If the chaincode only queried the ledger, the application would inspect the query response and would typically not submit the transaction to Ordering Service. If the client application intends to submit the transaction to Ordering Service to update the ledger, the application determines if the specified endorsement policy has been fulfilled before submitting (i.e. did peerA and peerB both endorse). The architecture is such that even if an application chooses not to inspect responses or otherwise forwards an unendorsed transaction, the endorsement policy will still be enforced by peers and upheld at the commit validation phase. 这个应用程序会去验证担保的Peer节点的签名是否正确，并比较&nbsp;proposal responses“提案响应” 是否一样。如果Chaincode 只是查询账本，那么客户端的APP只会检查proposal responses“提案响应”的正确性，而不再提交 “交易”给&nbsp;Ordering Service。 如果客户端的APP尝试提交“交易”给Ordering Service 更新账单，在提交之前需要确保所有Peer的担保签名都收集齐全（如，本例中需要收集Peer A节点和Peer B节点的 proposal responses 中 签名）。同时在这个体系结构中规定了，如果客户端App选择不检查proposal responses“提案响应”的正确性，或者转发一个未被担保的交易，这个“担保规则”依然会使这个交易在“提交验证阶段” 被交由 Peer节点强制性坚决地执行 “担保程序”。 Client assembles endorsements into a transaction&nbsp; 客户将担保背书组装成交易 The application “broadcasts” the transaction proposal and response within a “transaction message” to the Ordering Service. The transaction will contain the read/write sets, the endorsing peers signatures and the Channel ID. The Ordering Service does not need to inspect the entire content of a transaction in order to perform its operation, it simply receives transactions from all channels in the network, orders them chronologically by channel, and creates blocks of transactions per channel. 应用程序广播 “交易信息”给Ordering Service，里面包含了transaction proposal&nbsp;“交易提案”和&nbsp;proposal responses“提案响应” 。 这个“交易信息”包括了 “账本的读写操作数据集合”（其实就是一堆指令集），以及担保节点Peer的签名信息，和Channel ID。Ordering Service不需要为了执行操作时而去再检查“交易信息”的内容，他只是简单的从Channel网络中接受信息就可以了。 每条通道的交易记录都会按照时间排序，并且按照不同Channel通道 将“交易记录”打包成区块。 Transaction is validated and committed&nbsp;交易被验证并提交 The blocks of transactions are “delivered” to all peers on the channel. The transactions within the block are validated to ensure endorsement policy is fulfilled and to ensure that there have been no changes to ledger state for read set variables since the read set was generated by the transaction execution. Transactions in the block are tagged as being valid or invalid. 所有打包好交易的区块会被传递给所有区块相对应的通道内的Peer节点。这些区块的交易会被验证,以确保交易已经获得了所有Peer节点的担保背书，并且交易记录中读集合的数据和上一次读取账本时一样未被篡改过。被验证通过的记录会被标记为&nbsp;valid 已验证，未通过的验证的交易记录会被标记为&nbsp;invalid 未验证。 Ledger updated 账本更新 Each peer appends the block to the channel’s chain, and for each valid transaction the write sets are committed to current state database. An event is emitted, to notify the client application that the transaction (invocation) has been immutably appended to the chain, as well as notification of whether the transaction was validated or invalidated. 每个Peer节点都会把区块追加到对应Channel通道的链上，对于每一个被标记为通过验证的交易的“写数据集合”会被提交给数据库。同时，会触发一个事件，去通知客户端App他提交的交易已经被写入区块链（并不可再修改），如果交易无效也会同样的通知客户端App。 Note: See the&nbsp;swimlane&nbsp;diagram to better understand the server side flow and the protobuffers. 阅读更多" />
<meta property="og:description" content="原文链接：https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html 【这篇文章不用直译。】 Transaction Flow 交易流程 This document outlines the transactional mechanics that take place during a standard asset exchange. The scenario includes two clients, A and B, who are buying and selling radishes. They each have a peer on the network through which they send their transactions and interact with the ledger. 这个篇文章描述了在“标准资产交易”过程中节点之间的内部交易机制。以A和B两个人交易萝卜为例，他们两个人都各自在网络中拥有Peer节点，用于在区块链账本中记账。 Assumptions 假设 This flow assumes that a channel is set up and running. The application user has registered and enrolled with the organization’s certificate authority (CA) and received back necessary cryptographic material, which is used to authenticate to the network. 假设Channel已经设置好配置，并正在运行着。所有用户的Peer节点应用程序已经注册了并且取得了用于权限验证的CA证书，以及相应的加密资料（就是一堆配置文件，确实了访问不了网络）。 The chaincode (containing a set of key value pairs representing the initial state of the radish market) is installed on the peers and instantiated on the channel. The chaincode contains logic defining a set of transaction instructions and the agreed upon price for a radish. An endorsement policy has also been set for this chaincode, stating that both&nbsp;peerA&nbsp;and&nbsp;peerB&nbsp;must endorse any transaction. chaincode 链码会被安装到Peer节点上，并且在Channel上实例化（Channel实例建立在Orders形成的网络里的），链码包含了“交易指令”和“商品价格”。链码也“背书担保规则”，A和B的Peer节点会对满足“背书担保规则”的交易，进行担保。 Client A initiates a transaction&nbsp; 客户A发起一笔交易 What’s happening? - Client A is sending a request to purchase radishes. The request targets&nbsp;peerA&nbsp;and&nbsp;peerB, who are respectively representative of Client A and Client B. The endorsement policy states that both peers must endorse any transaction, therefore the request goes to&nbsp;peerA&nbsp;and&nbsp;peerB. 客户A用App发起一笔购买萝卜的订单，这个订单请求会被发送给节点A和节点B。 倘若“背书担保规则”设定为对所有交易均可担保，那么这个请求将被Peer节点接受。 Next, the transaction proposal is constructed. An application leveraging a supported SDK (Node, Java, Python) utilizes one of the available API’s which generates a transaction proposal. The proposal is a request to invoke a chaincode function so that data can be read and/or written to the ledger (i.e. write new key value pairs for the assets). The SDK serves as a shim to package the transaction proposal into the properly architected format (protocol buffer over gRPC) and takes the user’s cryptographic credentials to produce a unique signature for this transaction proposal. 下一步是构建 “交易提案”。 这个发起交易的App会借助 Fabric 客户端 SDK中的其中 API接口 生成一个 “交易提案”。这个提案的内容是 请求调用ChainCode链码去读取或者写入账本。 （一个shim是一个库,它将一个新的API引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现）Fabric客户端的SDK（以Shim库的形式）序列化“交易提案”为一个 结构化的文本格式并利用客户端用户的加密凭证为该“交易提案”生成一个签名。 Endorsing peers verify signature &amp; execute the transaction&nbsp; &nbsp; &nbsp; &nbsp;Peer为担保的交易验证签名&amp;执行交易 The endorsing peers verify (1) that the transaction proposal is well formed, (2) it has not been submitted already in the past (replay-attack protection), (3) the signature is valid (using MSP), and (4) that the submitter (Client A, in the example) is properly authorized to perform the proposed operation on that channel (namely, each endorsing peer ensures that the submitter satisfies the channel’s&nbsp;Writers&nbsp;policy). The endorsing peers take the transaction proposal inputs as arguments to the invoked chaincode’s function. The chaincode is then executed against the current state database to produce transaction results including a response value, read set, and write set. No updates are made to the ledger at this point. The set of these values, along with the endorsing peer’s signature is passed back as a “proposal response” to the SDK which parses the payload for the application to consume. 担保的Peer节点需要验证的条款有： （1）交易提案格式是否正确&nbsp; （2）是否被提交过（防止重放攻击） （3）签名是否有效（签名是否为CA颁发的） （4）提交的客户端APP（客户A）是否被授权在该Channel执行 “发起交易”的操作指令。 担保的Peer节点会在调用ChainCode链码函数时将该“交易提案”作为参数传入。 链码会根据当前账本数据库的数据去处理交易结果，交易结果包含了：返回码、读取的数据集合、写入的数据集合（这个写入操作暂时不会对数据库执行）。 这个时候还不会将对账本进行更新。然后这些被ChainCode处理后的“交易结果”会带上Peer的签名一起返回给客户端的SDK程序，客户端的SDK程序会解析这些数据，提供给App做下一步处理。 {The MSP is a peer component that allows them to verify transaction requests arriving from clients and to sign transaction results(endorsements). The Writing policy is defined at channel creation time, and determines which user is entitled to submit a transaction to that channel.} { MSP（由CA 针对每个Peer节点进行颁发） 是一个Peer的组件，有了它才可以被允许对来自客户端的交易进行验证，以及对ChainCode处理后的交易结果进行签名。The Writing policy“写入规则” 在通道创建的时候被定义，他声明了哪些客户端用户有权利发起“交易提案”给哪些“Channel通道”。} Proposal responses are inspected The application verifies the endorsing peer signatures and compares the proposal responses to determine if the proposal responses are the same. If the chaincode only queried the ledger, the application would inspect the query response and would typically not submit the transaction to Ordering Service. If the client application intends to submit the transaction to Ordering Service to update the ledger, the application determines if the specified endorsement policy has been fulfilled before submitting (i.e. did peerA and peerB both endorse). The architecture is such that even if an application chooses not to inspect responses or otherwise forwards an unendorsed transaction, the endorsement policy will still be enforced by peers and upheld at the commit validation phase. 这个应用程序会去验证担保的Peer节点的签名是否正确，并比较&nbsp;proposal responses“提案响应” 是否一样。如果Chaincode 只是查询账本，那么客户端的APP只会检查proposal responses“提案响应”的正确性，而不再提交 “交易”给&nbsp;Ordering Service。 如果客户端的APP尝试提交“交易”给Ordering Service 更新账单，在提交之前需要确保所有Peer的担保签名都收集齐全（如，本例中需要收集Peer A节点和Peer B节点的 proposal responses 中 签名）。同时在这个体系结构中规定了，如果客户端App选择不检查proposal responses“提案响应”的正确性，或者转发一个未被担保的交易，这个“担保规则”依然会使这个交易在“提交验证阶段” 被交由 Peer节点强制性坚决地执行 “担保程序”。 Client assembles endorsements into a transaction&nbsp; 客户将担保背书组装成交易 The application “broadcasts” the transaction proposal and response within a “transaction message” to the Ordering Service. The transaction will contain the read/write sets, the endorsing peers signatures and the Channel ID. The Ordering Service does not need to inspect the entire content of a transaction in order to perform its operation, it simply receives transactions from all channels in the network, orders them chronologically by channel, and creates blocks of transactions per channel. 应用程序广播 “交易信息”给Ordering Service，里面包含了transaction proposal&nbsp;“交易提案”和&nbsp;proposal responses“提案响应” 。 这个“交易信息”包括了 “账本的读写操作数据集合”（其实就是一堆指令集），以及担保节点Peer的签名信息，和Channel ID。Ordering Service不需要为了执行操作时而去再检查“交易信息”的内容，他只是简单的从Channel网络中接受信息就可以了。 每条通道的交易记录都会按照时间排序，并且按照不同Channel通道 将“交易记录”打包成区块。 Transaction is validated and committed&nbsp;交易被验证并提交 The blocks of transactions are “delivered” to all peers on the channel. The transactions within the block are validated to ensure endorsement policy is fulfilled and to ensure that there have been no changes to ledger state for read set variables since the read set was generated by the transaction execution. Transactions in the block are tagged as being valid or invalid. 所有打包好交易的区块会被传递给所有区块相对应的通道内的Peer节点。这些区块的交易会被验证,以确保交易已经获得了所有Peer节点的担保背书，并且交易记录中读集合的数据和上一次读取账本时一样未被篡改过。被验证通过的记录会被标记为&nbsp;valid 已验证，未通过的验证的交易记录会被标记为&nbsp;invalid 未验证。 Ledger updated 账本更新 Each peer appends the block to the channel’s chain, and for each valid transaction the write sets are committed to current state database. An event is emitted, to notify the client application that the transaction (invocation) has been immutably appended to the chain, as well as notification of whether the transaction was validated or invalidated. 每个Peer节点都会把区块追加到对应Channel通道的链上，对于每一个被标记为通过验证的交易的“写数据集合”会被提交给数据库。同时，会触发一个事件，去通知客户端App他提交的交易已经被写入区块链（并不可再修改），如果交易无效也会同样的通知客户端App。 Note: See the&nbsp;swimlane&nbsp;diagram to better understand the server side flow and the protobuffers. 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"原文链接：https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html 【这篇文章不用直译。】 Transaction Flow 交易流程 This document outlines the transactional mechanics that take place during a standard asset exchange. The scenario includes two clients, A and B, who are buying and selling radishes. They each have a peer on the network through which they send their transactions and interact with the ledger. 这个篇文章描述了在“标准资产交易”过程中节点之间的内部交易机制。以A和B两个人交易萝卜为例，他们两个人都各自在网络中拥有Peer节点，用于在区块链账本中记账。 Assumptions 假设 This flow assumes that a channel is set up and running. The application user has registered and enrolled with the organization’s certificate authority (CA) and received back necessary cryptographic material, which is used to authenticate to the network. 假设Channel已经设置好配置，并正在运行着。所有用户的Peer节点应用程序已经注册了并且取得了用于权限验证的CA证书，以及相应的加密资料（就是一堆配置文件，确实了访问不了网络）。 The chaincode (containing a set of key value pairs representing the initial state of the radish market) is installed on the peers and instantiated on the channel. The chaincode contains logic defining a set of transaction instructions and the agreed upon price for a radish. An endorsement policy has also been set for this chaincode, stating that both&nbsp;peerA&nbsp;and&nbsp;peerB&nbsp;must endorse any transaction. chaincode 链码会被安装到Peer节点上，并且在Channel上实例化（Channel实例建立在Orders形成的网络里的），链码包含了“交易指令”和“商品价格”。链码也“背书担保规则”，A和B的Peer节点会对满足“背书担保规则”的交易，进行担保。 Client A initiates a transaction&nbsp; 客户A发起一笔交易 What’s happening? - Client A is sending a request to purchase radishes. The request targets&nbsp;peerA&nbsp;and&nbsp;peerB, who are respectively representative of Client A and Client B. The endorsement policy states that both peers must endorse any transaction, therefore the request goes to&nbsp;peerA&nbsp;and&nbsp;peerB. 客户A用App发起一笔购买萝卜的订单，这个订单请求会被发送给节点A和节点B。 倘若“背书担保规则”设定为对所有交易均可担保，那么这个请求将被Peer节点接受。 Next, the transaction proposal is constructed. An application leveraging a supported SDK (Node, Java, Python) utilizes one of the available API’s which generates a transaction proposal. The proposal is a request to invoke a chaincode function so that data can be read and/or written to the ledger (i.e. write new key value pairs for the assets). The SDK serves as a shim to package the transaction proposal into the properly architected format (protocol buffer over gRPC) and takes the user’s cryptographic credentials to produce a unique signature for this transaction proposal. 下一步是构建 “交易提案”。 这个发起交易的App会借助 Fabric 客户端 SDK中的其中 API接口 生成一个 “交易提案”。这个提案的内容是 请求调用ChainCode链码去读取或者写入账本。 （一个shim是一个库,它将一个新的API引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现）Fabric客户端的SDK（以Shim库的形式）序列化“交易提案”为一个 结构化的文本格式并利用客户端用户的加密凭证为该“交易提案”生成一个签名。 Endorsing peers verify signature &amp; execute the transaction&nbsp; &nbsp; &nbsp; &nbsp;Peer为担保的交易验证签名&amp;执行交易 The endorsing peers verify (1) that the transaction proposal is well formed, (2) it has not been submitted already in the past (replay-attack protection), (3) the signature is valid (using MSP), and (4) that the submitter (Client A, in the example) is properly authorized to perform the proposed operation on that channel (namely, each endorsing peer ensures that the submitter satisfies the channel’s&nbsp;Writers&nbsp;policy). The endorsing peers take the transaction proposal inputs as arguments to the invoked chaincode’s function. The chaincode is then executed against the current state database to produce transaction results including a response value, read set, and write set. No updates are made to the ledger at this point. The set of these values, along with the endorsing peer’s signature is passed back as a “proposal response” to the SDK which parses the payload for the application to consume. 担保的Peer节点需要验证的条款有： （1）交易提案格式是否正确&nbsp; （2）是否被提交过（防止重放攻击） （3）签名是否有效（签名是否为CA颁发的） （4）提交的客户端APP（客户A）是否被授权在该Channel执行 “发起交易”的操作指令。 担保的Peer节点会在调用ChainCode链码函数时将该“交易提案”作为参数传入。 链码会根据当前账本数据库的数据去处理交易结果，交易结果包含了：返回码、读取的数据集合、写入的数据集合（这个写入操作暂时不会对数据库执行）。 这个时候还不会将对账本进行更新。然后这些被ChainCode处理后的“交易结果”会带上Peer的签名一起返回给客户端的SDK程序，客户端的SDK程序会解析这些数据，提供给App做下一步处理。 {The MSP is a peer component that allows them to verify transaction requests arriving from clients and to sign transaction results(endorsements). The Writing policy is defined at channel creation time, and determines which user is entitled to submit a transaction to that channel.} { MSP（由CA 针对每个Peer节点进行颁发） 是一个Peer的组件，有了它才可以被允许对来自客户端的交易进行验证，以及对ChainCode处理后的交易结果进行签名。The Writing policy“写入规则” 在通道创建的时候被定义，他声明了哪些客户端用户有权利发起“交易提案”给哪些“Channel通道”。} Proposal responses are inspected The application verifies the endorsing peer signatures and compares the proposal responses to determine if the proposal responses are the same. If the chaincode only queried the ledger, the application would inspect the query response and would typically not submit the transaction to Ordering Service. If the client application intends to submit the transaction to Ordering Service to update the ledger, the application determines if the specified endorsement policy has been fulfilled before submitting (i.e. did peerA and peerB both endorse). The architecture is such that even if an application chooses not to inspect responses or otherwise forwards an unendorsed transaction, the endorsement policy will still be enforced by peers and upheld at the commit validation phase. 这个应用程序会去验证担保的Peer节点的签名是否正确，并比较&nbsp;proposal responses“提案响应” 是否一样。如果Chaincode 只是查询账本，那么客户端的APP只会检查proposal responses“提案响应”的正确性，而不再提交 “交易”给&nbsp;Ordering Service。 如果客户端的APP尝试提交“交易”给Ordering Service 更新账单，在提交之前需要确保所有Peer的担保签名都收集齐全（如，本例中需要收集Peer A节点和Peer B节点的 proposal responses 中 签名）。同时在这个体系结构中规定了，如果客户端App选择不检查proposal responses“提案响应”的正确性，或者转发一个未被担保的交易，这个“担保规则”依然会使这个交易在“提交验证阶段” 被交由 Peer节点强制性坚决地执行 “担保程序”。 Client assembles endorsements into a transaction&nbsp; 客户将担保背书组装成交易 The application “broadcasts” the transaction proposal and response within a “transaction message” to the Ordering Service. The transaction will contain the read/write sets, the endorsing peers signatures and the Channel ID. The Ordering Service does not need to inspect the entire content of a transaction in order to perform its operation, it simply receives transactions from all channels in the network, orders them chronologically by channel, and creates blocks of transactions per channel. 应用程序广播 “交易信息”给Ordering Service，里面包含了transaction proposal&nbsp;“交易提案”和&nbsp;proposal responses“提案响应” 。 这个“交易信息”包括了 “账本的读写操作数据集合”（其实就是一堆指令集），以及担保节点Peer的签名信息，和Channel ID。Ordering Service不需要为了执行操作时而去再检查“交易信息”的内容，他只是简单的从Channel网络中接受信息就可以了。 每条通道的交易记录都会按照时间排序，并且按照不同Channel通道 将“交易记录”打包成区块。 Transaction is validated and committed&nbsp;交易被验证并提交 The blocks of transactions are “delivered” to all peers on the channel. The transactions within the block are validated to ensure endorsement policy is fulfilled and to ensure that there have been no changes to ledger state for read set variables since the read set was generated by the transaction execution. Transactions in the block are tagged as being valid or invalid. 所有打包好交易的区块会被传递给所有区块相对应的通道内的Peer节点。这些区块的交易会被验证,以确保交易已经获得了所有Peer节点的担保背书，并且交易记录中读集合的数据和上一次读取账本时一样未被篡改过。被验证通过的记录会被标记为&nbsp;valid 已验证，未通过的验证的交易记录会被标记为&nbsp;invalid 未验证。 Ledger updated 账本更新 Each peer appends the block to the channel’s chain, and for each valid transaction the write sets are committed to current state database. An event is emitted, to notify the client application that the transaction (invocation) has been immutably appended to the chain, as well as notification of whether the transaction was validated or invalidated. 每个Peer节点都会把区块追加到对应Channel通道的链上，对于每一个被标记为通过验证的交易的“写数据集合”会被提交给数据库。同时，会触发一个事件，去通知客户端App他提交的交易已经被写入区块链（并不可再修改），如果交易无效也会同样的通知客户端App。 Note: See the&nbsp;swimlane&nbsp;diagram to better understand the server side flow and the protobuffers. 阅读更多","@type":"BlogPosting","url":"/2018/02/01/43aba931b570cd751a798f0086bd900c.html","headline":"《Fabric交易流程》Transaction Flow 非直译文","dateModified":"2018-02-01T00:00:00+08:00","datePublished":"2018-02-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/02/01/43aba931b570cd751a798f0086bd900c.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>《Fabric交易流程》Transaction Flow 非直译文</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>原文链接：https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html</p> 
  <p>【<span style="color:rgb(79,79,79);text-align:justify;">这篇文章不用直译。</span>】</p> 
  <p><br></p> 
  <p><br></p> 
  <p></p> 
  <h1 style="font-family:'Roboto Slab', 'ff-tisa-web-pro', Georgia, Arial, sans-serif;font-size:28px;color:rgb(1,1,1);letter-spacing:.3px;background-color:rgb(252,252,252);"> Transaction Flow 交易流程</h1> 
  <div>
   <br>
  </div> 
  <div>
   <br>
  </div> 
  <p></p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> This document outlines the transactional mechanics that take place during a standard asset exchange. The scenario includes two clients, A and B, who are buying and selling radishes. They each have a peer on the network through which they send their transactions and interact with the ledger.</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> 这个篇文章描述了在“<span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);">标准资产交易</span>”过程中节点之间的内部交易机制。以A和B两个人交易萝卜为例，他们两个人都各自在网络中拥有Peer节点，用于在区块链账本中记账。</p> 
  <img alt="_images/step0.png" src="https://hyperledger-fabric.readthedocs.io/en/latest/_images/step0.png" style="border:0px;vertical-align:middle;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);">
  <span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"></span> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> <strong>Assumptions 假设</strong></p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> This flow assumes that a channel is set up and running. The application user has registered and enrolled with the organization’s certificate authority (CA) and received back necessary cryptographic material, which is used to authenticate to the network.</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> 假设Channel已经设置好配置，并正在运行着。所有用户的Peer节点应用程序已经注册了并且取得了用于权限验证的CA证书，以及相应的加密资料（就是一堆配置文件，确实了访问不了网络）。</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> The chaincode (containing a set of key value pairs representing the initial state of the radish market) is installed on the peers and instantiated on the channel. The chaincode contains logic defining a set of transaction instructions and the agreed upon price for a radish. An endorsement policy has also been set for this chaincode, stating that both&nbsp;<code class="docutils literal" style="font-family:Consolas, 'Andale Mono WT', 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Liberation Mono', 'Nimbus Mono L', Monaco, 'Courier New', Courier, monospace;font-size:12px;background:rgb(255,255,255);border:1px solid rgb(225,228,229);color:rgb(231,76,60);"><span class="pre">peerA</span></code>&nbsp;and&nbsp;<code class="docutils literal" style="font-family:Consolas, 'Andale Mono WT', 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Liberation Mono', 'Nimbus Mono L', Monaco, 'Courier New', Courier, monospace;font-size:12px;background:rgb(255,255,255);border:1px solid rgb(225,228,229);color:rgb(231,76,60);"><span class="pre">peerB</span></code>&nbsp;must endorse any transaction.</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> <span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);">chaincode 链码会被安装到Peer节点上，并且在Channel上实例化（Channel实例建立在Orders形成的网络里的），链码包含了“交易指令”和“商品价格”。链码也“背书担保规则”，A和B的Peer节点会对满足“背书担保规则”的交易，进行担保。</span></p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> <br></p> 
  <img alt="_images/step1.png" src="https://hyperledger-fabric.readthedocs.io/en/latest/_images/step1.png" style="border:0px;vertical-align:middle;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);">
  <span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"></span> 
  <ol class="arabic simple" style="margin-left:0px;line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;font-size:16px;letter-spacing:.3px;background-color:rgb(252,252,252);">
   <li style="list-style:decimal;margin-left:24px;"><strong>Client A initiates a transaction&nbsp; 客户A发起一笔交易</strong></li>
  </ol>
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> What’s happening? - Client A is sending a request to purchase radishes. The request targets&nbsp;<code class="docutils literal" style="font-family:Consolas, 'Andale Mono WT', 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Liberation Mono', 'Nimbus Mono L', Monaco, 'Courier New', Courier, monospace;font-size:12px;background:rgb(255,255,255);border:1px solid rgb(225,228,229);color:rgb(231,76,60);"><span class="pre">peerA</span></code>&nbsp;and&nbsp;<code class="docutils literal" style="font-family:Consolas, 'Andale Mono WT', 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Liberation Mono', 'Nimbus Mono L', Monaco, 'Courier New', Courier, monospace;font-size:12px;background:rgb(255,255,255);border:1px solid rgb(225,228,229);color:rgb(231,76,60);"><span class="pre">peerB</span></code>, who are respectively representative of Client A and Client B. The endorsement policy states that both peers must endorse any transaction, therefore the request goes to&nbsp;<code class="docutils literal" style="font-family:Consolas, 'Andale Mono WT', 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Liberation Mono', 'Nimbus Mono L', Monaco, 'Courier New', Courier, monospace;font-size:12px;background:rgb(255,255,255);border:1px solid rgb(225,228,229);color:rgb(231,76,60);"><span class="pre">peerA</span></code>&nbsp;and&nbsp;<code class="docutils literal" style="font-family:Consolas, 'Andale Mono WT', 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Liberation Mono', 'Nimbus Mono L', Monaco, 'Courier New', Courier, monospace;font-size:12px;background:rgb(255,255,255);border:1px solid rgb(225,228,229);color:rgb(231,76,60);"><span class="pre">peerB</span></code>.</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> 客户A用App发起一笔购买萝卜的订单，这个订单请求会被发送给节点A和节点B。 倘若“背书担保规则”设定为对所有交易均可担保，那么这个请求将被Peer节点接受。</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> Next, the transaction proposal is constructed. An application leveraging a supported SDK (Node, Java, Python) utilizes one of the available API’s which generates a transaction proposal. The proposal is a request to invoke a chaincode function so that data can be read and/or written to the ledger (i.e. write new key value pairs for the assets). The SDK serves as a shim to package the transaction proposal into the properly architected format (protocol buffer over gRPC) and takes the user’s cryptographic credentials to produce a unique signature for this transaction proposal.</p> 
  <p style="line-height:24px;font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;"> <span style="color:#010101;background-color:rgb(252,252,252);">下一步是构建 “交易提案”。 这个发起交易的App会借助 Fabric 客户端 SDK中的其中 API接口 生成一个 “交易提案”。这个提案的内容是 请求调用ChainCode链码去读取或者写入账本。 （</span><span style="font-family:'PingFang SC', 'Lantinghei SC', 'Microsoft YaHei', arial, '宋体', sans-serif, tahoma;letter-spacing:.3px;"><span style="color:#333333;background-color:rgb(255,255,255);">一个shim是一个库,它将一个新的API引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现）Fabric客户端的SDK（以Shim库的形式）序列化“交易提案”为一个 结构化的文本格式并</span><span style="font-family:'PingFang SC', 'Lantinghei SC', 'Microsoft YaHei', arial, '宋体', sans-serif, tahoma;letter-spacing:.3px;"><span style="color:#333333;background-color:rgb(255,255,255);">利</span><strong><span style="color:#000000;background-color:rgb(51,204,255);">用客户端用户的加密凭证</span></strong></span><strong><span style="color:#000000;background-color:rgb(51,204,255);">为该“交易提案”生成一个签名。</span></strong></span></p> 
  <img alt="_images/step2.png" src="https://hyperledger-fabric.readthedocs.io/en/latest/_images/step2.png" style="border:0px;vertical-align:middle;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);">
  <span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"></span> 
  <ol class="arabic simple" start="2" style="margin-left:0px;line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;font-size:16px;letter-spacing:.3px;background-color:rgb(252,252,252);">
   <li style="list-style:decimal;margin-left:24px;"><strong>Endorsing peers verify signature &amp; execute the transaction&nbsp; &nbsp; &nbsp; &nbsp;Peer为担保的交易验证签名&amp;执行交易</strong></li>
  </ol>
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> The endorsing peers verify (1) that the transaction proposal is well formed, (2) it has not been submitted already in the past (replay-attack protection), (3) the signature is valid (using MSP), and (4) that the submitter (Client A, in the example) is properly authorized to perform the proposed operation on that channel (namely, each endorsing peer ensures that the submitter satisfies the channel’s&nbsp;<em>Writers</em>&nbsp;policy). The endorsing peers take the transaction proposal inputs as arguments to the invoked chaincode’s function. The chaincode is then executed against the current state database to produce transaction results including a response value, read set, and write set. No updates are made to the ledger at this point. The set of these values, along with the endorsing peer’s signature is passed back as a “proposal response” to the SDK which parses the payload for the application to consume.</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> 担保的Peer节点需要验证的条款有：</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> （1）交易提案格式是否正确&nbsp;</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> （2）是否被提交过（防止重放攻击）</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> （3）签名是否有效（签名是否为CA颁发的）</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> （4）提交的客户端APP（客户A）是否被授权在该Channel执行 “发起交易”的操作指令。</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;"> <span style="background-color:rgb(252,252,252);">担保的Peer节点会在调用</span><span style="background-color:rgb(252,252,252);color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;">ChainCode链码函数时</span><span style="background-color:rgb(252,252,252);">将该“交易提案”作为参数传入。 </span><span style="background-color:rgb(51,204,255);"><strong>链码会根据当前账本数据库的数据去处理交易结果，交易结果包含了：返回码、读取的数据集合、写入的数据集合（这个写入操作暂时不会对数据库执行）。 这个时候还不会将对账本进行更新。</strong></span><span style="background-color:rgb(252,252,252);">然后这些被ChainCode处理后的“</span><span style="background-color:rgb(252,252,252);color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;">交易结果</span><span style="background-color:rgb(252,252,252);">”会带上Peer的签名一起返回给客户端的SDK程序，客户端的SDK程序会解析这些数据，提供给App做下一步处理。</span></p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> <em>{The MSP is a peer component that allows them to verify transaction requests arriving from clients and to sign transaction results(endorsements). The Writing policy is defined at channel creation time, and determines which user is entitled to submit a transaction to that channel.}</em></p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> <span style="font-style:italic;"><span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"><em>{ MSP（由CA 针对每个Peer节点进行颁发） 是一个Peer的组件，有了它才可以被允许对来自客户端的交易进行验证，以及对ChainCode处理后的交易结果进行签名。<span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"><em>The Writing policy“<span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"><em>写入规则</em></span>” 在通道创建的时候被定义，他声明了哪些客户端用户有权利发起“交易提案”给哪些“Channel通道”。}</em></span></em></span><br></span></p> 
  <img alt="_images/step3.png" src="https://hyperledger-fabric.readthedocs.io/en/latest/_images/step3.png" style="border:0px;vertical-align:middle;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);">
  <span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"></span> 
  <ol class="arabic simple" start="3" style="margin-left:0px;line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;font-size:16px;letter-spacing:.3px;background-color:rgb(252,252,252);">
   <li style="list-style:decimal;margin-left:24px;"><strong>Proposal responses are inspected</strong></li>
  </ol>
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> The application verifies the endorsing peer signatures and compares the proposal responses to determine if the proposal responses are the same. If the chaincode only queried the ledger, the application would inspect the query response and would typically not submit the transaction to Ordering Service. If the client application intends to submit the transaction to Ordering Service to update the ledger, the application determines if the specified endorsement policy has been fulfilled before submitting (i.e. did peerA and peerB both endorse). The architecture is such that even if an application chooses not to inspect responses or otherwise forwards an unendorsed transaction, the endorsement policy will still be enforced by peers and upheld at the commit validation phase.</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;"> <span style="background-color:rgb(252,252,252);">这个应用程序会去验证担保的Peer节点的签名是否正确，并比较&nbsp;</span><span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;"><span style="background-color:rgb(252,252,252);">proposal responses“提案响应” 是否一样。</span><strong style="background-color:rgb(51,204,255);">如果Chaincode 只是查询账本，那么客户端的APP只会检查</strong><span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;"><strong style="background-color:rgb(51,204,255);">proposal responses“提案响应”的正确性，而不再提交 “交易”给&nbsp;</strong><span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;"><strong style="background-color:rgb(51,204,255);">Ordering Service。</strong><span style="background-color:rgb(252,252,252);"> 如果客户端的APP尝试提交“交易”给Ordering Service 更新账单，在提交之前需要确保所有Peer的担保签名都收集齐全（如，本例中需要收集Peer A节点和Peer B节点的 </span><span style="background-color:rgb(252,252,252);color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;">proposal responses 中 签名</span><span style="background-color:rgb(252,252,252);">）。同时在这个体系结构中规定了，</span><strong style="background-color:rgb(51,204,255);">如果客户端App选择不检查<span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;">proposal responses“提案响应”的正确性，或者转发一个未被担保的交易，这个“担保规则”依然会使这个交易在“<span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;">提交验证阶段</span>” 被交由 Peer节点强制性坚决地执行 “担保程序”。</span></strong></span></span></span></p> 
  <img alt="_images/step4.png" src="https://hyperledger-fabric.readthedocs.io/en/latest/_images/step4.png" style="border:0px;vertical-align:middle;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);">
  <span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"></span> 
  <ol class="arabic simple" start="4" style="margin-left:0px;line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;font-size:16px;letter-spacing:.3px;background-color:rgb(252,252,252);">
   <li style="list-style:decimal;margin-left:24px;"><strong>Client assembles endorsements into a transaction&nbsp; 客户将担保背书组装成交易</strong></li>
  </ol>
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> The application “broadcasts” the transaction proposal and response within a “transaction message” to the Ordering Service. The transaction will contain the read/write sets, the endorsing peers signatures and the Channel ID. The Ordering Service does not need to inspect the entire content of a transaction in order to perform its operation, it simply receives transactions from all channels in the network, orders them chronologically by channel, and creates blocks of transactions per channel.</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;"> <span style="background-color:rgb(252,252,252);">应用程序广播 “交易信息”给</span><span style="background-color:rgb(252,252,252);color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;">Ordering Service</span><span style="background-color:rgb(252,252,252);">，里面包含了</span><span style="background-color:rgb(252,252,252);color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;">transaction proposal&nbsp;</span><span style="background-color:rgb(252,252,252);">“交易提案”和&nbsp;</span><span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;"><span style="background-color:rgb(252,252,252);">proposal responses“提案响应” 。 这个“交易信息”包括了 “账本的读写操作数据集合”（其实就是一堆指令集），以及担保节点Peer的签名信息，和Channel ID。</span><strong style="background-color:rgb(51,204,255);">Ordering Service不需要为了执行操作时而去再检查“交易信息”的内容</strong><span style="background-color:rgb(252,252,252);">，他只是简单的从Channel网络中接受信息就可以了。 每条通道的</span><strong style="background-color:rgb(51,204,255);">交易记录都会按照时间排序</strong><span style="background-color:rgb(252,252,252);">，并且按照不同Channel通道 将“交易记录”打包成区块。</span></span></p> 
  <img alt="_images/step5.png" src="https://hyperledger-fabric.readthedocs.io/en/latest/_images/step5.png" style="border:0px;vertical-align:middle;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);">
  <span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"></span> 
  <ol class="arabic simple" start="5" style="margin-left:0px;line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;font-size:16px;letter-spacing:.3px;background-color:rgb(252,252,252);">
   <li style="list-style:decimal;margin-left:24px;"><strong>Transaction is validated and committed&nbsp;交易被验证并提交</strong></li>
  </ol>
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> The blocks of transactions are “delivered” to all peers on the channel. The transactions within the block are validated to ensure endorsement policy is fulfilled and to ensure that there have been no changes to ledger state for read set variables since the read set was generated by the transaction execution. Transactions in the block are tagged as being valid or invalid.</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;"> <span style="background-color:rgb(252,252,252);">所有打包好交易的区块会被传递给所有区块相对应的通道内的Peer节点。这些区块的交易会被验证,以确保交易已经获得了所有Peer节点的担保背书，</span><span style="background-color:rgb(51,204,255);"><strong>并且交易记录中读集合的数据和上一次读取账本时一样未被篡改过</strong>。<strong>被验证通过的记录会被标记为&nbsp;<span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;">valid 已验证，未通过的验证的交易记录会被标记为&nbsp;<span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;">invalid 未验证。</span></span></strong></span></p> 
  <img alt="_images/step6.png" src="https://hyperledger-fabric.readthedocs.io/en/latest/_images/step6.png" style="border:0px;vertical-align:middle;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);">
  <span style="color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"></span> 
  <ol class="arabic simple" start="6" style="margin-left:0px;line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;font-size:16px;letter-spacing:.3px;background-color:rgb(252,252,252);">
   <li style="list-style:decimal;margin-left:24px;"><strong>Ledger updated 账本更新</strong></li>
  </ol>
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> Each peer appends the block to the channel’s chain, and for each valid transaction the write sets are committed to current state database. An event is emitted, to notify the client application that the transaction (invocation) has been immutably appended to the chain, as well as notification of whether the transaction was validated or invalidated.</p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;"> <span style="background-color:rgb(252,252,252);">每个Peer节点都会把区块追加到对应</span><span style="background-color:rgb(252,252,252);color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;text-align:justify;">Channel</span><span style="background-color:rgb(252,252,252);">通道的链上，对于每一个被标记为通过验证的交易的“写数据集合”会被提交给数据库。</span><strong style="background-color:rgb(51,204,255);">同时，会触发一个事件，去通知客户端App他提交的交易已经被写入区块链（并不可再修改），如果交易无效也会同样的通知客户端App。</strong></p> 
  <p style="line-height:24px;color:rgb(1,1,1);font-family:Lato, 'proxima-nova', 'Helvetica Neue', Arial, sans-serif;letter-spacing:.3px;background-color:rgb(252,252,252);"> <strong>Note</strong>: See the&nbsp;<span class="xref std std-ref">swimlane</span>&nbsp;diagram to better understand the server side flow and the protobuffers.</p> 
  <br>
  <p><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u010833547/article/details/79225080,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u010833547/article/details/79225080,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
