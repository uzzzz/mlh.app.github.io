<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链的原理与golang实现例子 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链的原理与golang实现例子" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明： https://blog.csdn.net/liwan2018/article/details/79377490 什么是区块链 区块链有多火，就不用我介绍了，你能通过搜索引擎跳转到这里，就证明你是区块链的fan了。既然进来了，就不会让你白来，no bb, 直接上干货！ （开场白，也不全是废话）区块链是 21 世纪最具革命性的技术之一，它仍然处于不断成长的阶段，而且还有很多潜力尚未显现出来。 本质上，区块链只是一个分布式数据库而已。 不过，使它独一无二的是，区块链是一个公开的数据库，而不是一个私人数据库，也就是说，每个使用它的人都有一个完整或部分的副本。 只有经过其他数据库管理员的同意，才能向数据库中添加新的记录。 此外，也正是由于区块链，才使得加密货币和智能合约成为现实。 综而述之，用一个形象的比如：区块链就是一个去中心化、分布式”记账本”。 区块链原理 1.区块 让我们从 “区块链” 中的 “区块” 谈起。在区块链中，存储有效信息的是区块。 比如，比特币区块存储的有效信息，就是比特币交易，交易信息也是所有加密货币的本质。除此以外，区块还包含了一些技术信息，比如版本，当前时间戳和前一个区块的哈希。 这里，我们并不会实现一个像比特币技术规范所描述的区块链，而是实现一个简化版的区块链，它仅包含了一些关键信息。看起来就像是这样： type Block struct { Timestamp int64 Data []byte PrevBlockHash []byte Hash []byte } - Timestamp 是当前时间戳，也就是区块创建的时间。 - Data 是区块存储的实际有效的信息。 - PrevBlockHash 存储的是前一个块的哈希。 - Hash 是当前块的哈希。 在比特币技术规范中，Timestamp, PrevBlockHash, Hash 是区块头（block header），区块头是一个单独的数据结构。而交易，也就是这里的 Data, 是另一个单独的数据结构。为了简便起见，我把这两个混合在了一起。 那么，我们要如何计算哈希呢？如何计算哈希，是区块链一个非常重要的部分。正是由于这个特性，才使得区块链是安全的。计算一个哈希，是在计算上非常困难的一个操作。即使在高速电脑上，也要花费不少时间 (这就是为什么人们会购买 GPU 来挖比特币) 。这是一个有意为之的架构设计，它故意使得加入新的区块十分困难，因此可以保证区块一旦被加入以后，就很难再进行修改。 目前，我们仅取了 Block 结构的一些字段（Timestamp, Data 和 PrevBlockHash），并将它们相互连接起来，然后在连接后的结果上计算一个 SHA-256 的哈希. 让我们在 SetHash 方法中完成这个任务： func (b *Block) SetHash() { timestamp := []byte(strconv.FormatInt(b.Timestamp, 10)) headers := bytes.Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{}) hash := sha256.Sum256(headers) b.Hash = hash[:] } 接下来，按照 Golang 的惯例，我们会实现一个用于简化创建一个区块的函数： func NewBlock(data string, prevBlockHash []byte) *Block { block := &amp;Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}} block.SetHash() return block } 这就是区块部分的全部内容了！ 2.链 下面让我们来实现一个区块链。本质上，区块链仅仅是一个有着特定结构的数据库，是一个有序，后向连接的列表。 这也就是说，区块按照插入的顺序进行存储，每个块都被连接到前一个块。这样的结构，能够让我们快速地获取链上的最新块，并且高效地通过哈希来检索一个块。 在 Golang 中，可以通过一个 array 和 map 来实现这个结构：array 存储有序的哈希（Golang 中 array 是有序的），map 存储 hask -&gt; block 对(Golang 中, map 是无序的)。 但是在基本的原型阶段，我们只用到了 array，因为现在还不需要通过哈希来获取块。 type Blockchain struct { blocks []*Block } 这就是我们的第一个区块链！我从来没有想过它会是这么容易。 现在，让我们能够给它添加一个块： func (bc *Blockchain) AddBlock(data string) { prevBlock := bc.blocks[len(bc.blocks)-1] newBlock := NewBlock(data, prevBlock.Hash) bc.blocks = append(bc.blocks, newBlock) } 完成！不过，真的就这样了吗？ 为了加入一个新的块，我们必须要有一个已有的块，但是，现在我们的链是空的，一个块都没有！所以，在任何一个区块链中，都必须至少有一个块。这样的块，也就是链中的第一个块，通常叫做创世块（genesis block）. 让我们实现一个方法来创建一个创世块： func NewGenesisBlock() *Block { return NewBlock(&quot;Genesis Block&quot;, []byte{}) } 现在，我们可以实现一个函数来创建有创世块的区块链： func NewBlockchain() *Blockchain { return &amp;Blockchain{[]*Block{NewGenesisBlock()}} } 来检查一个我们的区块链是否如期工作： func main() { bc := NewBlockchain() bc.AddBlock(&quot;Send 1 BTC to Ivan&quot;) bc.AddBlock(&quot;Send 2 more BTC to Ivan&quot;) for _, block := range bc.blocks { fmt.Printf(&quot;Prev. hash: %x\n&quot;, block.PrevBlockHash) fmt.Printf(&quot;Data: %s\n&quot;, block.Data) fmt.Printf(&quot;Hash: %x\n&quot;, block.Hash) fmt.Println() } } 一个完整的代码 package main import ( &quot;crypto/sha256&quot; &quot;encoding/json&quot; &quot;flag&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; &quot;net/http&quot; &quot;sort&quot; &quot;strings&quot; &quot;time&quot; &quot;websocket&quot; //&quot;golang.org/x/net/websocket&quot; ) const ( queryLatest = iota queryAll responseBlockchain ) var genesisBlock = &amp;Block{ Index: 0, PreviousHash: &quot;0&quot;, Timestamp: 1465154705, Data: &quot;my genesis block!!&quot;, Hash: &quot;816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7&quot;, } var ( sockets []*websocket.Conn blockchain = []*Block{genesisBlock} httpAddr = flag.String(&quot;api&quot;, &quot;:3001&quot;, &quot;api server address.&quot;) p2pAddr = flag.String(&quot;p2p&quot;, &quot;:6001&quot;, &quot;p2p server address.&quot;) initialPeers = flag.String(&quot;peers&quot;, &quot;ws://localhost:6001&quot;, &quot;initial peers&quot;) ) type Block struct { Index int64 `json:&quot;index&quot;` PreviousHash string `json:&quot;previousHash&quot;` Timestamp int64 `json:&quot;timestamp&quot;` Data string `json:&quot;data&quot;` Hash string `json:&quot;hash&quot;` } func (b *Block) String() string { return fmt.Sprintf(&quot;index: %d,previousHash:%s,timestamp:%d,data:%s,hash:%s&quot;, b.Index, b.PreviousHash, b.Timestamp, b.Data, b.Hash) } type ByIndex []*Block func (b ByIndex) Len() int { return len(b) } func (b ByIndex) Swap(i, j int) { b[i], b[j] = b[j], b[i] } func (b ByIndex) Less(i, j int) bool { return b[i].Index &lt; b[j].Index } type ResponseBlockchain struct { Type int `json:&quot;type&quot;` Data string `json:&quot;data&quot;` } func errFatal(msg string, err error) { if err != nil { log.Fatalln(msg, err) } } func connectToPeers(peersAddr []string) { for _, peer := range peersAddr { if peer == &quot;&quot; { continue } ws, err := websocket.Dial(peer, &quot;&quot;, peer) if err != nil { log.Println(&quot;dial to peer&quot;, err) continue } initConnection(ws) } } func initConnection(ws *websocket.Conn) { go wsHandleP2P(ws) log.Println(&quot;query latest block.&quot;) ws.Write(queryLatestMsg()) } func handleBlocks(w http.ResponseWriter, r *http.Request) { bs, _ := json.Marshal(blockchain) w.Write(bs) } func handleMineBlock(w http.ResponseWriter, r *http.Request) { var v struct { Data string `json:&quot;data&quot;` } decoder := json.NewDecoder(r.Body) defer r.Body.Close() err := decoder.Decode(&amp;v) if err != nil { w.WriteHeader(http.StatusGone) log.Println(&quot;[API] invalid block data : &quot;, err.Error()) w.Write([]byte(&quot;invalid block data. &quot; + err.Error() + &quot;\n&quot;)) return } block := generateNextBlock(v.Data) addBlock(block) broadcast(responseLatestMsg()) } func handlePeers(w http.ResponseWriter, r *http.Request) { var slice []string for _, socket := range sockets { if socket.IsClientConn() { slice = append(slice, strings.Replace(socket.LocalAddr().String(), &quot;ws://&quot;, &quot;&quot;, 1)) } else { slice = append(slice, socket.Request().RemoteAddr) } } bs, _ := json.Marshal(slice) w.Write(bs) } func handleAddPeer(w http.ResponseWriter, r *http.Request) { var v struct { Peer string `json:&quot;peer&quot;` } decoder := json.NewDecoder(r.Body) defer r.Body.Close() err := decoder.Decode(&amp;v) if err != nil { w.WriteHeader(http.StatusGone) log.Println(&quot;[API] invalid peer data : &quot;, err.Error()) w.Write([]byte(&quot;invalid peer data. &quot; + err.Error())) return } connectToPeers([]string{v.Peer}) } func wsHandleP2P(ws *websocket.Conn) { var ( v = &amp;ResponseBlockchain{} peer = ws.LocalAddr().String() ) sockets = append(sockets, ws) for { var msg []byte err := websocket.Message.Receive(ws, &amp;msg) if err == io.EOF { log.Printf(&quot;p2p Peer[%s] shutdown, remove it form peers pool.\n&quot;, peer) break } if err != nil { log.Println(&quot;Can&#39;t receive p2p msg from &quot;, peer, err.Error()) break } log.Printf(&quot;Received[from %s]: %s.\n&quot;, peer, msg) err = json.Unmarshal(msg, v) errFatal(&quot;invalid p2p msg&quot;, err) switch v.Type { case queryLatest: v.Type = responseBlockchain bs := responseLatestMsg() log.Printf(&quot;responseLatestMsg: %s\n&quot;, bs) ws.Write(bs) case queryAll: d, _ := json.Marshal(blockchain) v.Type = responseBlockchain v.Data = string(d) bs, _ := json.Marshal(v) log.Printf(&quot;responseChainMsg: %s\n&quot;, bs) ws.Write(bs) case responseBlockchain: handleBlockchainResponse([]byte(v.Data)) } } } func getLatestBlock() (block *Block) { return blockchain[len(blockchain)-1] } func responseLatestMsg() (bs []byte) { var v = &amp;ResponseBlockchain{Type: responseBlockchain} d, _ := json.Marshal(blockchain[len(blockchain)-1:]) v.Data = string(d) bs, _ = json.Marshal(v) return } func queryLatestMsg() []byte { return []byte(fmt.Sprintf(&quot;{\&quot;type\&quot;: %d}&quot;, queryLatest)) } func queryAllMsg() []byte { return []byte(fmt.Sprintf(&quot;{\&quot;type\&quot;: %d}&quot;, queryAll)) } func calculateHashForBlock(b *Block) string { return fmt.Sprintf(&quot;%x&quot;, sha256.Sum256([]byte(fmt.Sprintf(&quot;%d%s%d%s&quot;, b.Index, b.PreviousHash, b.Timestamp, b.Data)))) } func generateNextBlock(data string) (nb *Block) { var previousBlock = getLatestBlock() nb = &amp;Block{ Data: data, PreviousHash: previousBlock.Hash, Index: previousBlock.Index + 1, Timestamp: time.Now().Unix(), } nb.Hash = calculateHashForBlock(nb) return } func addBlock(b *Block) { if isValidNewBlock(b, getLatestBlock()) { blockchain = append(blockchain, b) } } func isValidNewBlock(nb, pb *Block) (ok bool) { if nb.Hash == calculateHashForBlock(nb) &amp;&amp; pb.Index+1 == nb.Index &amp;&amp; pb.Hash == nb.PreviousHash { ok = true } return } func isValidChain(bc []*Block) bool { if bc[0].String() != genesisBlock.String() { log.Println(&quot;No same GenesisBlock.&quot;, bc[0].String()) return false } var temp = []*Block{bc[0]} for i := 1; i &lt; len(bc); i++ { if isValidNewBlock(bc[i], temp[i-1]) { temp = append(temp, bc[i]) } else { return false } } return true } func replaceChain(bc []*Block) { if isValidChain(bc) &amp;&amp; len(bc) &gt; len(blockchain) { log.Println(&quot;Received blockchain is valid. Replacing current blockchain with received blockchain.&quot;) blockchain = bc broadcast(responseLatestMsg()) } else { log.Println(&quot;Received blockchain invalid.&quot;) } } func broadcast(msg []byte) { for n, socket := range sockets { _, err := socket.Write(msg) if err != nil { log.Printf(&quot;peer [%s] disconnected.&quot;, socket.RemoteAddr().String()) sockets = append(sockets[0:n], sockets[n+1:]...) } } } func handleBlockchainResponse(msg []byte) { var receivedBlocks = []*Block{} err := json.Unmarshal(msg, &amp;receivedBlocks) errFatal(&quot;invalid blockchain&quot;, err) sort.Sort(ByIndex(receivedBlocks)) latestBlockReceived := receivedBlocks[len(receivedBlocks)-1] latestBlockHeld := getLatestBlock() if latestBlockReceived.Index &gt; latestBlockHeld.Index { log.Printf(&quot;blockchain possibly behind. We got: %d Peer got: %d&quot;, latestBlockHeld.Index, latestBlockReceived.Index) if latestBlockHeld.Hash == latestBlockReceived.PreviousHash { log.Println(&quot;We can append the received block to our chain.&quot;) blockchain = append(blockchain, latestBlockReceived) } else if len(receivedBlocks) == 1 { log.Println(&quot;We have to query the chain from our peer.&quot;) broadcast(queryAllMsg()) } else { log.Println(&quot;Received blockchain is longer than current blockchain.&quot;) replaceChain(receivedBlocks) } } else { log.Println(&quot;received blockchain is not longer than current blockchain. Do nothing.&quot;) } } func main() { flag.Parse() connectToPeers(strings.Split(*initialPeers, &quot;,&quot;)) http.HandleFunc(&quot;/blocks&quot;, handleBlocks) http.HandleFunc(&quot;/mine_block&quot;, handleMineBlock) http.HandleFunc(&quot;/peers&quot;, handlePeers) http.HandleFunc(&quot;/add_peer&quot;, handleAddPeer) go func() { log.Println(&quot;Listen HTTP on&quot;, *httpAddr) errFatal(&quot;start api server&quot;, http.ListenAndServe(*httpAddr, nil)) }() http.Handle(&quot;/&quot;, websocket.Handler(wsHandleP2P)) log.Println(&quot;Listen P2P on &quot;, *p2pAddr) errFatal(&quot;start p2p server&quot;, http.ListenAndServe(*p2pAddr, nil)) } 链接： https://github.com/kofj/naivechain/blob/master/main.go 什么是区块链 区块链原理 1.区块 2.链 一个完整的代码 多少人忙得连写博客的时间都没有哟！ 阅读更多" />
<meta property="og:description" content="版权声明： https://blog.csdn.net/liwan2018/article/details/79377490 什么是区块链 区块链有多火，就不用我介绍了，你能通过搜索引擎跳转到这里，就证明你是区块链的fan了。既然进来了，就不会让你白来，no bb, 直接上干货！ （开场白，也不全是废话）区块链是 21 世纪最具革命性的技术之一，它仍然处于不断成长的阶段，而且还有很多潜力尚未显现出来。 本质上，区块链只是一个分布式数据库而已。 不过，使它独一无二的是，区块链是一个公开的数据库，而不是一个私人数据库，也就是说，每个使用它的人都有一个完整或部分的副本。 只有经过其他数据库管理员的同意，才能向数据库中添加新的记录。 此外，也正是由于区块链，才使得加密货币和智能合约成为现实。 综而述之，用一个形象的比如：区块链就是一个去中心化、分布式”记账本”。 区块链原理 1.区块 让我们从 “区块链” 中的 “区块” 谈起。在区块链中，存储有效信息的是区块。 比如，比特币区块存储的有效信息，就是比特币交易，交易信息也是所有加密货币的本质。除此以外，区块还包含了一些技术信息，比如版本，当前时间戳和前一个区块的哈希。 这里，我们并不会实现一个像比特币技术规范所描述的区块链，而是实现一个简化版的区块链，它仅包含了一些关键信息。看起来就像是这样： type Block struct { Timestamp int64 Data []byte PrevBlockHash []byte Hash []byte } - Timestamp 是当前时间戳，也就是区块创建的时间。 - Data 是区块存储的实际有效的信息。 - PrevBlockHash 存储的是前一个块的哈希。 - Hash 是当前块的哈希。 在比特币技术规范中，Timestamp, PrevBlockHash, Hash 是区块头（block header），区块头是一个单独的数据结构。而交易，也就是这里的 Data, 是另一个单独的数据结构。为了简便起见，我把这两个混合在了一起。 那么，我们要如何计算哈希呢？如何计算哈希，是区块链一个非常重要的部分。正是由于这个特性，才使得区块链是安全的。计算一个哈希，是在计算上非常困难的一个操作。即使在高速电脑上，也要花费不少时间 (这就是为什么人们会购买 GPU 来挖比特币) 。这是一个有意为之的架构设计，它故意使得加入新的区块十分困难，因此可以保证区块一旦被加入以后，就很难再进行修改。 目前，我们仅取了 Block 结构的一些字段（Timestamp, Data 和 PrevBlockHash），并将它们相互连接起来，然后在连接后的结果上计算一个 SHA-256 的哈希. 让我们在 SetHash 方法中完成这个任务： func (b *Block) SetHash() { timestamp := []byte(strconv.FormatInt(b.Timestamp, 10)) headers := bytes.Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{}) hash := sha256.Sum256(headers) b.Hash = hash[:] } 接下来，按照 Golang 的惯例，我们会实现一个用于简化创建一个区块的函数： func NewBlock(data string, prevBlockHash []byte) *Block { block := &amp;Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}} block.SetHash() return block } 这就是区块部分的全部内容了！ 2.链 下面让我们来实现一个区块链。本质上，区块链仅仅是一个有着特定结构的数据库，是一个有序，后向连接的列表。 这也就是说，区块按照插入的顺序进行存储，每个块都被连接到前一个块。这样的结构，能够让我们快速地获取链上的最新块，并且高效地通过哈希来检索一个块。 在 Golang 中，可以通过一个 array 和 map 来实现这个结构：array 存储有序的哈希（Golang 中 array 是有序的），map 存储 hask -&gt; block 对(Golang 中, map 是无序的)。 但是在基本的原型阶段，我们只用到了 array，因为现在还不需要通过哈希来获取块。 type Blockchain struct { blocks []*Block } 这就是我们的第一个区块链！我从来没有想过它会是这么容易。 现在，让我们能够给它添加一个块： func (bc *Blockchain) AddBlock(data string) { prevBlock := bc.blocks[len(bc.blocks)-1] newBlock := NewBlock(data, prevBlock.Hash) bc.blocks = append(bc.blocks, newBlock) } 完成！不过，真的就这样了吗？ 为了加入一个新的块，我们必须要有一个已有的块，但是，现在我们的链是空的，一个块都没有！所以，在任何一个区块链中，都必须至少有一个块。这样的块，也就是链中的第一个块，通常叫做创世块（genesis block）. 让我们实现一个方法来创建一个创世块： func NewGenesisBlock() *Block { return NewBlock(&quot;Genesis Block&quot;, []byte{}) } 现在，我们可以实现一个函数来创建有创世块的区块链： func NewBlockchain() *Blockchain { return &amp;Blockchain{[]*Block{NewGenesisBlock()}} } 来检查一个我们的区块链是否如期工作： func main() { bc := NewBlockchain() bc.AddBlock(&quot;Send 1 BTC to Ivan&quot;) bc.AddBlock(&quot;Send 2 more BTC to Ivan&quot;) for _, block := range bc.blocks { fmt.Printf(&quot;Prev. hash: %x\n&quot;, block.PrevBlockHash) fmt.Printf(&quot;Data: %s\n&quot;, block.Data) fmt.Printf(&quot;Hash: %x\n&quot;, block.Hash) fmt.Println() } } 一个完整的代码 package main import ( &quot;crypto/sha256&quot; &quot;encoding/json&quot; &quot;flag&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; &quot;net/http&quot; &quot;sort&quot; &quot;strings&quot; &quot;time&quot; &quot;websocket&quot; //&quot;golang.org/x/net/websocket&quot; ) const ( queryLatest = iota queryAll responseBlockchain ) var genesisBlock = &amp;Block{ Index: 0, PreviousHash: &quot;0&quot;, Timestamp: 1465154705, Data: &quot;my genesis block!!&quot;, Hash: &quot;816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7&quot;, } var ( sockets []*websocket.Conn blockchain = []*Block{genesisBlock} httpAddr = flag.String(&quot;api&quot;, &quot;:3001&quot;, &quot;api server address.&quot;) p2pAddr = flag.String(&quot;p2p&quot;, &quot;:6001&quot;, &quot;p2p server address.&quot;) initialPeers = flag.String(&quot;peers&quot;, &quot;ws://localhost:6001&quot;, &quot;initial peers&quot;) ) type Block struct { Index int64 `json:&quot;index&quot;` PreviousHash string `json:&quot;previousHash&quot;` Timestamp int64 `json:&quot;timestamp&quot;` Data string `json:&quot;data&quot;` Hash string `json:&quot;hash&quot;` } func (b *Block) String() string { return fmt.Sprintf(&quot;index: %d,previousHash:%s,timestamp:%d,data:%s,hash:%s&quot;, b.Index, b.PreviousHash, b.Timestamp, b.Data, b.Hash) } type ByIndex []*Block func (b ByIndex) Len() int { return len(b) } func (b ByIndex) Swap(i, j int) { b[i], b[j] = b[j], b[i] } func (b ByIndex) Less(i, j int) bool { return b[i].Index &lt; b[j].Index } type ResponseBlockchain struct { Type int `json:&quot;type&quot;` Data string `json:&quot;data&quot;` } func errFatal(msg string, err error) { if err != nil { log.Fatalln(msg, err) } } func connectToPeers(peersAddr []string) { for _, peer := range peersAddr { if peer == &quot;&quot; { continue } ws, err := websocket.Dial(peer, &quot;&quot;, peer) if err != nil { log.Println(&quot;dial to peer&quot;, err) continue } initConnection(ws) } } func initConnection(ws *websocket.Conn) { go wsHandleP2P(ws) log.Println(&quot;query latest block.&quot;) ws.Write(queryLatestMsg()) } func handleBlocks(w http.ResponseWriter, r *http.Request) { bs, _ := json.Marshal(blockchain) w.Write(bs) } func handleMineBlock(w http.ResponseWriter, r *http.Request) { var v struct { Data string `json:&quot;data&quot;` } decoder := json.NewDecoder(r.Body) defer r.Body.Close() err := decoder.Decode(&amp;v) if err != nil { w.WriteHeader(http.StatusGone) log.Println(&quot;[API] invalid block data : &quot;, err.Error()) w.Write([]byte(&quot;invalid block data. &quot; + err.Error() + &quot;\n&quot;)) return } block := generateNextBlock(v.Data) addBlock(block) broadcast(responseLatestMsg()) } func handlePeers(w http.ResponseWriter, r *http.Request) { var slice []string for _, socket := range sockets { if socket.IsClientConn() { slice = append(slice, strings.Replace(socket.LocalAddr().String(), &quot;ws://&quot;, &quot;&quot;, 1)) } else { slice = append(slice, socket.Request().RemoteAddr) } } bs, _ := json.Marshal(slice) w.Write(bs) } func handleAddPeer(w http.ResponseWriter, r *http.Request) { var v struct { Peer string `json:&quot;peer&quot;` } decoder := json.NewDecoder(r.Body) defer r.Body.Close() err := decoder.Decode(&amp;v) if err != nil { w.WriteHeader(http.StatusGone) log.Println(&quot;[API] invalid peer data : &quot;, err.Error()) w.Write([]byte(&quot;invalid peer data. &quot; + err.Error())) return } connectToPeers([]string{v.Peer}) } func wsHandleP2P(ws *websocket.Conn) { var ( v = &amp;ResponseBlockchain{} peer = ws.LocalAddr().String() ) sockets = append(sockets, ws) for { var msg []byte err := websocket.Message.Receive(ws, &amp;msg) if err == io.EOF { log.Printf(&quot;p2p Peer[%s] shutdown, remove it form peers pool.\n&quot;, peer) break } if err != nil { log.Println(&quot;Can&#39;t receive p2p msg from &quot;, peer, err.Error()) break } log.Printf(&quot;Received[from %s]: %s.\n&quot;, peer, msg) err = json.Unmarshal(msg, v) errFatal(&quot;invalid p2p msg&quot;, err) switch v.Type { case queryLatest: v.Type = responseBlockchain bs := responseLatestMsg() log.Printf(&quot;responseLatestMsg: %s\n&quot;, bs) ws.Write(bs) case queryAll: d, _ := json.Marshal(blockchain) v.Type = responseBlockchain v.Data = string(d) bs, _ := json.Marshal(v) log.Printf(&quot;responseChainMsg: %s\n&quot;, bs) ws.Write(bs) case responseBlockchain: handleBlockchainResponse([]byte(v.Data)) } } } func getLatestBlock() (block *Block) { return blockchain[len(blockchain)-1] } func responseLatestMsg() (bs []byte) { var v = &amp;ResponseBlockchain{Type: responseBlockchain} d, _ := json.Marshal(blockchain[len(blockchain)-1:]) v.Data = string(d) bs, _ = json.Marshal(v) return } func queryLatestMsg() []byte { return []byte(fmt.Sprintf(&quot;{\&quot;type\&quot;: %d}&quot;, queryLatest)) } func queryAllMsg() []byte { return []byte(fmt.Sprintf(&quot;{\&quot;type\&quot;: %d}&quot;, queryAll)) } func calculateHashForBlock(b *Block) string { return fmt.Sprintf(&quot;%x&quot;, sha256.Sum256([]byte(fmt.Sprintf(&quot;%d%s%d%s&quot;, b.Index, b.PreviousHash, b.Timestamp, b.Data)))) } func generateNextBlock(data string) (nb *Block) { var previousBlock = getLatestBlock() nb = &amp;Block{ Data: data, PreviousHash: previousBlock.Hash, Index: previousBlock.Index + 1, Timestamp: time.Now().Unix(), } nb.Hash = calculateHashForBlock(nb) return } func addBlock(b *Block) { if isValidNewBlock(b, getLatestBlock()) { blockchain = append(blockchain, b) } } func isValidNewBlock(nb, pb *Block) (ok bool) { if nb.Hash == calculateHashForBlock(nb) &amp;&amp; pb.Index+1 == nb.Index &amp;&amp; pb.Hash == nb.PreviousHash { ok = true } return } func isValidChain(bc []*Block) bool { if bc[0].String() != genesisBlock.String() { log.Println(&quot;No same GenesisBlock.&quot;, bc[0].String()) return false } var temp = []*Block{bc[0]} for i := 1; i &lt; len(bc); i++ { if isValidNewBlock(bc[i], temp[i-1]) { temp = append(temp, bc[i]) } else { return false } } return true } func replaceChain(bc []*Block) { if isValidChain(bc) &amp;&amp; len(bc) &gt; len(blockchain) { log.Println(&quot;Received blockchain is valid. Replacing current blockchain with received blockchain.&quot;) blockchain = bc broadcast(responseLatestMsg()) } else { log.Println(&quot;Received blockchain invalid.&quot;) } } func broadcast(msg []byte) { for n, socket := range sockets { _, err := socket.Write(msg) if err != nil { log.Printf(&quot;peer [%s] disconnected.&quot;, socket.RemoteAddr().String()) sockets = append(sockets[0:n], sockets[n+1:]...) } } } func handleBlockchainResponse(msg []byte) { var receivedBlocks = []*Block{} err := json.Unmarshal(msg, &amp;receivedBlocks) errFatal(&quot;invalid blockchain&quot;, err) sort.Sort(ByIndex(receivedBlocks)) latestBlockReceived := receivedBlocks[len(receivedBlocks)-1] latestBlockHeld := getLatestBlock() if latestBlockReceived.Index &gt; latestBlockHeld.Index { log.Printf(&quot;blockchain possibly behind. We got: %d Peer got: %d&quot;, latestBlockHeld.Index, latestBlockReceived.Index) if latestBlockHeld.Hash == latestBlockReceived.PreviousHash { log.Println(&quot;We can append the received block to our chain.&quot;) blockchain = append(blockchain, latestBlockReceived) } else if len(receivedBlocks) == 1 { log.Println(&quot;We have to query the chain from our peer.&quot;) broadcast(queryAllMsg()) } else { log.Println(&quot;Received blockchain is longer than current blockchain.&quot;) replaceChain(receivedBlocks) } } else { log.Println(&quot;received blockchain is not longer than current blockchain. Do nothing.&quot;) } } func main() { flag.Parse() connectToPeers(strings.Split(*initialPeers, &quot;,&quot;)) http.HandleFunc(&quot;/blocks&quot;, handleBlocks) http.HandleFunc(&quot;/mine_block&quot;, handleMineBlock) http.HandleFunc(&quot;/peers&quot;, handlePeers) http.HandleFunc(&quot;/add_peer&quot;, handleAddPeer) go func() { log.Println(&quot;Listen HTTP on&quot;, *httpAddr) errFatal(&quot;start api server&quot;, http.ListenAndServe(*httpAddr, nil)) }() http.Handle(&quot;/&quot;, websocket.Handler(wsHandleP2P)) log.Println(&quot;Listen P2P on &quot;, *p2pAddr) errFatal(&quot;start p2p server&quot;, http.ListenAndServe(*p2pAddr, nil)) } 链接： https://github.com/kofj/naivechain/blob/master/main.go 什么是区块链 区块链原理 1.区块 2.链 一个完整的代码 多少人忙得连写博客的时间都没有哟！ 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/02/26/173212002fd43613ba516243c85e5457.html" />
<meta property="og:url" content="https://mlh.app/2018/02/26/173212002fd43613ba516243c85e5457.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-26T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明： https://blog.csdn.net/liwan2018/article/details/79377490 什么是区块链 区块链有多火，就不用我介绍了，你能通过搜索引擎跳转到这里，就证明你是区块链的fan了。既然进来了，就不会让你白来，no bb, 直接上干货！ （开场白，也不全是废话）区块链是 21 世纪最具革命性的技术之一，它仍然处于不断成长的阶段，而且还有很多潜力尚未显现出来。 本质上，区块链只是一个分布式数据库而已。 不过，使它独一无二的是，区块链是一个公开的数据库，而不是一个私人数据库，也就是说，每个使用它的人都有一个完整或部分的副本。 只有经过其他数据库管理员的同意，才能向数据库中添加新的记录。 此外，也正是由于区块链，才使得加密货币和智能合约成为现实。 综而述之，用一个形象的比如：区块链就是一个去中心化、分布式”记账本”。 区块链原理 1.区块 让我们从 “区块链” 中的 “区块” 谈起。在区块链中，存储有效信息的是区块。 比如，比特币区块存储的有效信息，就是比特币交易，交易信息也是所有加密货币的本质。除此以外，区块还包含了一些技术信息，比如版本，当前时间戳和前一个区块的哈希。 这里，我们并不会实现一个像比特币技术规范所描述的区块链，而是实现一个简化版的区块链，它仅包含了一些关键信息。看起来就像是这样： type Block struct { Timestamp int64 Data []byte PrevBlockHash []byte Hash []byte } - Timestamp 是当前时间戳，也就是区块创建的时间。 - Data 是区块存储的实际有效的信息。 - PrevBlockHash 存储的是前一个块的哈希。 - Hash 是当前块的哈希。 在比特币技术规范中，Timestamp, PrevBlockHash, Hash 是区块头（block header），区块头是一个单独的数据结构。而交易，也就是这里的 Data, 是另一个单独的数据结构。为了简便起见，我把这两个混合在了一起。 那么，我们要如何计算哈希呢？如何计算哈希，是区块链一个非常重要的部分。正是由于这个特性，才使得区块链是安全的。计算一个哈希，是在计算上非常困难的一个操作。即使在高速电脑上，也要花费不少时间 (这就是为什么人们会购买 GPU 来挖比特币) 。这是一个有意为之的架构设计，它故意使得加入新的区块十分困难，因此可以保证区块一旦被加入以后，就很难再进行修改。 目前，我们仅取了 Block 结构的一些字段（Timestamp, Data 和 PrevBlockHash），并将它们相互连接起来，然后在连接后的结果上计算一个 SHA-256 的哈希. 让我们在 SetHash 方法中完成这个任务： func (b *Block) SetHash() { timestamp := []byte(strconv.FormatInt(b.Timestamp, 10)) headers := bytes.Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{}) hash := sha256.Sum256(headers) b.Hash = hash[:] } 接下来，按照 Golang 的惯例，我们会实现一个用于简化创建一个区块的函数： func NewBlock(data string, prevBlockHash []byte) *Block { block := &amp;Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}} block.SetHash() return block } 这就是区块部分的全部内容了！ 2.链 下面让我们来实现一个区块链。本质上，区块链仅仅是一个有着特定结构的数据库，是一个有序，后向连接的列表。 这也就是说，区块按照插入的顺序进行存储，每个块都被连接到前一个块。这样的结构，能够让我们快速地获取链上的最新块，并且高效地通过哈希来检索一个块。 在 Golang 中，可以通过一个 array 和 map 来实现这个结构：array 存储有序的哈希（Golang 中 array 是有序的），map 存储 hask -&gt; block 对(Golang 中, map 是无序的)。 但是在基本的原型阶段，我们只用到了 array，因为现在还不需要通过哈希来获取块。 type Blockchain struct { blocks []*Block } 这就是我们的第一个区块链！我从来没有想过它会是这么容易。 现在，让我们能够给它添加一个块： func (bc *Blockchain) AddBlock(data string) { prevBlock := bc.blocks[len(bc.blocks)-1] newBlock := NewBlock(data, prevBlock.Hash) bc.blocks = append(bc.blocks, newBlock) } 完成！不过，真的就这样了吗？ 为了加入一个新的块，我们必须要有一个已有的块，但是，现在我们的链是空的，一个块都没有！所以，在任何一个区块链中，都必须至少有一个块。这样的块，也就是链中的第一个块，通常叫做创世块（genesis block）. 让我们实现一个方法来创建一个创世块： func NewGenesisBlock() *Block { return NewBlock(&quot;Genesis Block&quot;, []byte{}) } 现在，我们可以实现一个函数来创建有创世块的区块链： func NewBlockchain() *Blockchain { return &amp;Blockchain{[]*Block{NewGenesisBlock()}} } 来检查一个我们的区块链是否如期工作： func main() { bc := NewBlockchain() bc.AddBlock(&quot;Send 1 BTC to Ivan&quot;) bc.AddBlock(&quot;Send 2 more BTC to Ivan&quot;) for _, block := range bc.blocks { fmt.Printf(&quot;Prev. hash: %x\\n&quot;, block.PrevBlockHash) fmt.Printf(&quot;Data: %s\\n&quot;, block.Data) fmt.Printf(&quot;Hash: %x\\n&quot;, block.Hash) fmt.Println() } } 一个完整的代码 package main import ( &quot;crypto/sha256&quot; &quot;encoding/json&quot; &quot;flag&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; &quot;net/http&quot; &quot;sort&quot; &quot;strings&quot; &quot;time&quot; &quot;websocket&quot; //&quot;golang.org/x/net/websocket&quot; ) const ( queryLatest = iota queryAll responseBlockchain ) var genesisBlock = &amp;Block{ Index: 0, PreviousHash: &quot;0&quot;, Timestamp: 1465154705, Data: &quot;my genesis block!!&quot;, Hash: &quot;816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7&quot;, } var ( sockets []*websocket.Conn blockchain = []*Block{genesisBlock} httpAddr = flag.String(&quot;api&quot;, &quot;:3001&quot;, &quot;api server address.&quot;) p2pAddr = flag.String(&quot;p2p&quot;, &quot;:6001&quot;, &quot;p2p server address.&quot;) initialPeers = flag.String(&quot;peers&quot;, &quot;ws://localhost:6001&quot;, &quot;initial peers&quot;) ) type Block struct { Index int64 `json:&quot;index&quot;` PreviousHash string `json:&quot;previousHash&quot;` Timestamp int64 `json:&quot;timestamp&quot;` Data string `json:&quot;data&quot;` Hash string `json:&quot;hash&quot;` } func (b *Block) String() string { return fmt.Sprintf(&quot;index: %d,previousHash:%s,timestamp:%d,data:%s,hash:%s&quot;, b.Index, b.PreviousHash, b.Timestamp, b.Data, b.Hash) } type ByIndex []*Block func (b ByIndex) Len() int { return len(b) } func (b ByIndex) Swap(i, j int) { b[i], b[j] = b[j], b[i] } func (b ByIndex) Less(i, j int) bool { return b[i].Index &lt; b[j].Index } type ResponseBlockchain struct { Type int `json:&quot;type&quot;` Data string `json:&quot;data&quot;` } func errFatal(msg string, err error) { if err != nil { log.Fatalln(msg, err) } } func connectToPeers(peersAddr []string) { for _, peer := range peersAddr { if peer == &quot;&quot; { continue } ws, err := websocket.Dial(peer, &quot;&quot;, peer) if err != nil { log.Println(&quot;dial to peer&quot;, err) continue } initConnection(ws) } } func initConnection(ws *websocket.Conn) { go wsHandleP2P(ws) log.Println(&quot;query latest block.&quot;) ws.Write(queryLatestMsg()) } func handleBlocks(w http.ResponseWriter, r *http.Request) { bs, _ := json.Marshal(blockchain) w.Write(bs) } func handleMineBlock(w http.ResponseWriter, r *http.Request) { var v struct { Data string `json:&quot;data&quot;` } decoder := json.NewDecoder(r.Body) defer r.Body.Close() err := decoder.Decode(&amp;v) if err != nil { w.WriteHeader(http.StatusGone) log.Println(&quot;[API] invalid block data : &quot;, err.Error()) w.Write([]byte(&quot;invalid block data. &quot; + err.Error() + &quot;\\n&quot;)) return } block := generateNextBlock(v.Data) addBlock(block) broadcast(responseLatestMsg()) } func handlePeers(w http.ResponseWriter, r *http.Request) { var slice []string for _, socket := range sockets { if socket.IsClientConn() { slice = append(slice, strings.Replace(socket.LocalAddr().String(), &quot;ws://&quot;, &quot;&quot;, 1)) } else { slice = append(slice, socket.Request().RemoteAddr) } } bs, _ := json.Marshal(slice) w.Write(bs) } func handleAddPeer(w http.ResponseWriter, r *http.Request) { var v struct { Peer string `json:&quot;peer&quot;` } decoder := json.NewDecoder(r.Body) defer r.Body.Close() err := decoder.Decode(&amp;v) if err != nil { w.WriteHeader(http.StatusGone) log.Println(&quot;[API] invalid peer data : &quot;, err.Error()) w.Write([]byte(&quot;invalid peer data. &quot; + err.Error())) return } connectToPeers([]string{v.Peer}) } func wsHandleP2P(ws *websocket.Conn) { var ( v = &amp;ResponseBlockchain{} peer = ws.LocalAddr().String() ) sockets = append(sockets, ws) for { var msg []byte err := websocket.Message.Receive(ws, &amp;msg) if err == io.EOF { log.Printf(&quot;p2p Peer[%s] shutdown, remove it form peers pool.\\n&quot;, peer) break } if err != nil { log.Println(&quot;Can&#39;t receive p2p msg from &quot;, peer, err.Error()) break } log.Printf(&quot;Received[from %s]: %s.\\n&quot;, peer, msg) err = json.Unmarshal(msg, v) errFatal(&quot;invalid p2p msg&quot;, err) switch v.Type { case queryLatest: v.Type = responseBlockchain bs := responseLatestMsg() log.Printf(&quot;responseLatestMsg: %s\\n&quot;, bs) ws.Write(bs) case queryAll: d, _ := json.Marshal(blockchain) v.Type = responseBlockchain v.Data = string(d) bs, _ := json.Marshal(v) log.Printf(&quot;responseChainMsg: %s\\n&quot;, bs) ws.Write(bs) case responseBlockchain: handleBlockchainResponse([]byte(v.Data)) } } } func getLatestBlock() (block *Block) { return blockchain[len(blockchain)-1] } func responseLatestMsg() (bs []byte) { var v = &amp;ResponseBlockchain{Type: responseBlockchain} d, _ := json.Marshal(blockchain[len(blockchain)-1:]) v.Data = string(d) bs, _ = json.Marshal(v) return } func queryLatestMsg() []byte { return []byte(fmt.Sprintf(&quot;{\\&quot;type\\&quot;: %d}&quot;, queryLatest)) } func queryAllMsg() []byte { return []byte(fmt.Sprintf(&quot;{\\&quot;type\\&quot;: %d}&quot;, queryAll)) } func calculateHashForBlock(b *Block) string { return fmt.Sprintf(&quot;%x&quot;, sha256.Sum256([]byte(fmt.Sprintf(&quot;%d%s%d%s&quot;, b.Index, b.PreviousHash, b.Timestamp, b.Data)))) } func generateNextBlock(data string) (nb *Block) { var previousBlock = getLatestBlock() nb = &amp;Block{ Data: data, PreviousHash: previousBlock.Hash, Index: previousBlock.Index + 1, Timestamp: time.Now().Unix(), } nb.Hash = calculateHashForBlock(nb) return } func addBlock(b *Block) { if isValidNewBlock(b, getLatestBlock()) { blockchain = append(blockchain, b) } } func isValidNewBlock(nb, pb *Block) (ok bool) { if nb.Hash == calculateHashForBlock(nb) &amp;&amp; pb.Index+1 == nb.Index &amp;&amp; pb.Hash == nb.PreviousHash { ok = true } return } func isValidChain(bc []*Block) bool { if bc[0].String() != genesisBlock.String() { log.Println(&quot;No same GenesisBlock.&quot;, bc[0].String()) return false } var temp = []*Block{bc[0]} for i := 1; i &lt; len(bc); i++ { if isValidNewBlock(bc[i], temp[i-1]) { temp = append(temp, bc[i]) } else { return false } } return true } func replaceChain(bc []*Block) { if isValidChain(bc) &amp;&amp; len(bc) &gt; len(blockchain) { log.Println(&quot;Received blockchain is valid. Replacing current blockchain with received blockchain.&quot;) blockchain = bc broadcast(responseLatestMsg()) } else { log.Println(&quot;Received blockchain invalid.&quot;) } } func broadcast(msg []byte) { for n, socket := range sockets { _, err := socket.Write(msg) if err != nil { log.Printf(&quot;peer [%s] disconnected.&quot;, socket.RemoteAddr().String()) sockets = append(sockets[0:n], sockets[n+1:]...) } } } func handleBlockchainResponse(msg []byte) { var receivedBlocks = []*Block{} err := json.Unmarshal(msg, &amp;receivedBlocks) errFatal(&quot;invalid blockchain&quot;, err) sort.Sort(ByIndex(receivedBlocks)) latestBlockReceived := receivedBlocks[len(receivedBlocks)-1] latestBlockHeld := getLatestBlock() if latestBlockReceived.Index &gt; latestBlockHeld.Index { log.Printf(&quot;blockchain possibly behind. We got: %d Peer got: %d&quot;, latestBlockHeld.Index, latestBlockReceived.Index) if latestBlockHeld.Hash == latestBlockReceived.PreviousHash { log.Println(&quot;We can append the received block to our chain.&quot;) blockchain = append(blockchain, latestBlockReceived) } else if len(receivedBlocks) == 1 { log.Println(&quot;We have to query the chain from our peer.&quot;) broadcast(queryAllMsg()) } else { log.Println(&quot;Received blockchain is longer than current blockchain.&quot;) replaceChain(receivedBlocks) } } else { log.Println(&quot;received blockchain is not longer than current blockchain. Do nothing.&quot;) } } func main() { flag.Parse() connectToPeers(strings.Split(*initialPeers, &quot;,&quot;)) http.HandleFunc(&quot;/blocks&quot;, handleBlocks) http.HandleFunc(&quot;/mine_block&quot;, handleMineBlock) http.HandleFunc(&quot;/peers&quot;, handlePeers) http.HandleFunc(&quot;/add_peer&quot;, handleAddPeer) go func() { log.Println(&quot;Listen HTTP on&quot;, *httpAddr) errFatal(&quot;start api server&quot;, http.ListenAndServe(*httpAddr, nil)) }() http.Handle(&quot;/&quot;, websocket.Handler(wsHandleP2P)) log.Println(&quot;Listen P2P on &quot;, *p2pAddr) errFatal(&quot;start p2p server&quot;, http.ListenAndServe(*p2pAddr, nil)) } 链接： https://github.com/kofj/naivechain/blob/master/main.go 什么是区块链 区块链原理 1.区块 2.链 一个完整的代码 多少人忙得连写博客的时间都没有哟！ 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/02/26/173212002fd43613ba516243c85e5457.html","headline":"区块链的原理与golang实现例子","dateModified":"2018-02-26T00:00:00+08:00","datePublished":"2018-02-26T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/02/26/173212002fd43613ba516243c85e5457.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链的原理与golang实现例子</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明： https://blog.csdn.net/liwan2018/article/details/79377490 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1 id="什么是区块链">什么是区块链</h1> 
  <p>区块链有多火，就不用我介绍了，你能通过搜索引擎跳转到这里，就证明你是区块链的fan了。既然进来了，就不会让你白来，no bb, 直接上干货！</p> 
  <p>（开场白，也不全是废话）区块链是 21 世纪最具革命性的技术之一，它仍然处于不断成长的阶段，而且还有很多潜力尚未显现出来。 <em>本质上，区块链只是一个分布式数据库而已。</em> 不过，使它独一无二的是，区块链是一个公开的数据库，而不是一个私人数据库，也就是说，每个使用它的人都有一个完整或部分的副本。 只有经过其他数据库管理员的同意，才能向数据库中添加新的记录。 此外，也正是由于区块链，才使得加密货币和智能合约成为现实。 </p> 
  <p>综而述之，用一个形象的比如：<em>区块链就是一个去中心化、分布式”记账本”。</em></p> 
  <h1 id="区块链原理">区块链原理</h1> 
  <h2 id="1区块">1.区块</h2> 
  <p>让我们从 “区块链” 中的 “区块” 谈起。在区块链中，存储有效信息的是区块。 <br> 比如，比特币区块存储的有效信息，就是比特币交易，交易信息也是所有加密货币的本质。除此以外，区块还包含了一些技术信息，比如版本，当前时间戳和前一个区块的哈希。</p> 
  <p>这里，我们并不会实现一个像比特币技术规范所描述的区块链，而是实现一个简化版的区块链，它仅包含了一些关键信息。看起来就像是这样：</p> 
  <pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Block</span> struct <span class="hljs-container">{ <span class="hljs-type">Timestamp</span> <span class="hljs-title">int64</span> <span class="hljs-type">Data</span> []<span class="hljs-title">byte</span> <span class="hljs-type">PrevBlockHash</span> []<span class="hljs-title">byte</span> <span class="hljs-type">Hash</span> []<span class="hljs-title">byte</span> }</span></span></code></pre> 
  <pre class="prettyprint"><code class=" hljs haml">      -<span class="ruby"> <span class="hljs-constant">Timestamp</span> 是当前时间戳，也就是区块创建的时间。 </span>
      -<span class="ruby"> <span class="hljs-constant">Data</span> 是区块存储的实际有效的信息。 </span>
      -<span class="ruby"> <span class="hljs-constant">PrevBlockHash</span> 存储的是前一个块的哈希。 </span>
      -<span class="ruby"> <span class="hljs-constant">Hash</span> 是当前块的哈希。</span></code></pre> 
  <p>在比特币技术规范中，Timestamp, PrevBlockHash, Hash 是区块头（block header），区块头是一个单独的数据结构。而交易，也就是这里的 Data, 是另一个单独的数据结构。为了简便起见，我把这两个混合在了一起。</p> 
  <p>那么，我们要如何计算哈希呢？如何计算哈希，是区块链一个非常重要的部分。正是由于这个特性，才使得区块链是安全的。计算一个哈希，是在计算上非常困难的一个操作。即使在高速电脑上，也要花费不少时间 (这就是为什么人们会购买 GPU 来挖比特币) 。这是一个有意为之的架构设计，它故意使得加入新的区块十分困难，因此可以保证区块一旦被加入以后，就很难再进行修改。</p> 
  <p>目前，我们仅取了 Block 结构的一些字段（Timestamp, Data 和 PrevBlockHash），并将它们相互连接起来，然后在连接后的结果上计算一个 SHA-256 的哈希. 让我们在 SetHash 方法中完成这个任务：</p> 
  <pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">func</span> (<span class="hljs-tag">b</span> *<span class="hljs-tag">Block</span>) <span class="hljs-tag">SetHash</span>() <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">timestamp </span>:<span class="hljs-value">= []<span class="hljs-function">byte(strconv.<span class="hljs-function">FormatInt(b.Timestamp, <span class="hljs-number">10</span>)</span>)</span> headers := bytes.<span class="hljs-function">Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{})</span> hash := sha256.<span class="hljs-function">Sum256(headers)</span> b.Hash = hash[:] </span></span></span>}</code></pre> 
  <p>接下来，按照 Golang 的惯例，我们会实现一个用于简化创建一个区块的函数：</p> 
  <pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">func</span> <span class="hljs-tag">NewBlock</span>(<span class="hljs-tag">data</span> <span class="hljs-tag">string</span>, <span class="hljs-tag">prevBlockHash</span> <span class="hljs-attr_selector">[]</span><span class="hljs-tag">byte</span>) *<span class="hljs-tag">Block</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">block </span>:<span class="hljs-value">= &amp;Block{time.<span class="hljs-function">Now()</span>.<span class="hljs-function">Unix()</span>, []<span class="hljs-function">byte(data)</span>, prevBlockHash, []byte{</span></span></span>}}
    <span class="hljs-tag">block</span><span class="hljs-class">.SetHash</span>()
    <span class="hljs-tag">return</span> <span class="hljs-tag">block</span>
}</code></pre> 
  <p>这就是区块部分的全部内容了！</p> 
  <h2 id="2链">2.链</h2> 
  <p>下面让我们来实现一个区块链。本质上，区块链仅仅是一个有着特定结构的数据库，是一个有序，后向连接的列表。 <br> 这也就是说，区块按照插入的顺序进行存储，每个块都被连接到前一个块。这样的结构，能够让我们快速地获取链上的最新块，并且高效地通过哈希来检索一个块。 <br> 在 Golang 中，可以通过一个 array 和 map 来实现这个结构：array 存储有序的哈希（Golang 中 array 是有序的），map 存储 hask -&gt; block 对(Golang 中, map 是无序的)。 但是在基本的原型阶段，我们只用到了 array，因为现在还不需要通过哈希来获取块。</p> 
  <pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Blockchain</span> struct <span class="hljs-container">{ <span class="hljs-title">blocks</span> []*<span class="hljs-type">Block</span> }</span></span></code></pre> 
  <p>这就是我们的第一个区块链！我从来没有想过它会是这么容易。</p> 
  <p>现在，让我们能够给它添加一个块：</p> 
  <pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">func</span> (<span class="hljs-tag">bc</span> *<span class="hljs-tag">Blockchain</span>) <span class="hljs-tag">AddBlock</span>(<span class="hljs-tag">data</span> <span class="hljs-tag">string</span>) <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">prevBlock </span>:<span class="hljs-value">= bc.blocks[<span class="hljs-function">len(bc.blocks)</span>-<span class="hljs-number">1</span>] newBlock := <span class="hljs-function">NewBlock(data, prevBlock.Hash)</span> bc.blocks = <span class="hljs-function">append(bc.blocks, newBlock)</span> </span></span></span>}</code></pre> 
  <p>完成！不过，真的就这样了吗？</p> 
  <p>为了加入一个新的块，我们必须要有一个已有的块，但是，现在我们的链是空的，一个块都没有！所以，在任何一个区块链中，都必须至少有一个块。这样的块，也就是链中的第一个块，通常叫做创世块（genesis block）. 让我们实现一个方法来创建一个创世块：</p> 
  <pre class="prettyprint"><code class=" hljs scss">func <span class="hljs-function">NewGenesisBlock()</span> *<span class="hljs-value">Block</span> {
    return <span class="hljs-function">NewBlock(<span class="hljs-string">"Genesis Block"</span>, []byte{})</span>
}</code></pre> 
  <p>现在，我们可以实现一个函数来创建有创世块的区块链：</p> 
  <pre class="prettyprint"><code class=" hljs scss">func <span class="hljs-function">NewBlockchain()</span> *Blockchain {
    return &amp;Blockchain{<span class="hljs-attr_selector">[]</span>*<span class="hljs-value">Block</span>{<span class="hljs-function">NewGenesisBlock()</span>}}
}</code></pre> 
  <p>来检查一个我们的区块链是否如期工作：</p> 
  <pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">func</span> <span class="hljs-tag">main</span>() <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">bc </span>:<span class="hljs-value">= <span class="hljs-function">NewBlockchain()</span> bc.<span class="hljs-function">AddBlock(<span class="hljs-string">"Send 1 BTC to Ivan"</span>)</span> bc.<span class="hljs-function">AddBlock(<span class="hljs-string">"Send 2 more BTC to Ivan"</span>)</span> for _, block := range bc.blocks { fmt.<span class="hljs-function">Printf(<span class="hljs-string">"Prev. hash: %x\n"</span>, block.PrevBlockHash)</span> fmt.<span class="hljs-function">Printf(<span class="hljs-string">"Data: %s\n"</span>, block.Data)</span> fmt.<span class="hljs-function">Printf(<span class="hljs-string">"Hash: %x\n"</span>, block.Hash)</span> fmt.<span class="hljs-function">Println()</span> </span></span></span>}
}</code></pre> 
  <h1 id="一个完整的代码">一个完整的代码</h1> 
  <pre class="prettyprint"><code class="language-golang hljs "><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"crypto/sha256"</span>
    <span class="hljs-string">"encoding/json"</span>
    <span class="hljs-string">"flag"</span>
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"io"</span>
    <span class="hljs-string">"log"</span>
    <span class="hljs-string">"net/http"</span>
    <span class="hljs-string">"sort"</span>
    <span class="hljs-string">"strings"</span>
    <span class="hljs-string">"time"</span>
    <span class="hljs-string">"websocket"</span>
    <span class="hljs-comment">//"golang.org/x/net/websocket"</span>
)

<span class="hljs-keyword">const</span> (
    queryLatest = <span class="hljs-constant">iota</span>
    queryAll
    responseBlockchain
)

<span class="hljs-keyword">var</span> genesisBlock = &amp;Block{
    Index:       <span class="hljs-number"> 0</span>,
    PreviousHash: <span class="hljs-string">"0"</span>,
    Timestamp:   <span class="hljs-number"> 1465154705</span>,
    Data:         <span class="hljs-string">"my genesis block!!"</span>,
    Hash:         <span class="hljs-string">"816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7"</span>,
}

<span class="hljs-keyword">var</span> (
    sockets      []*websocket.Conn
    blockchain   = []*Block{genesisBlock}
    httpAddr     = flag.String(<span class="hljs-string">"api"</span>, <span class="hljs-string">":3001"</span>, <span class="hljs-string">"api server address."</span>)
    p2pAddr      = flag.String(<span class="hljs-string">"p2p"</span>, <span class="hljs-string">":6001"</span>, <span class="hljs-string">"p2p server address."</span>)
    initialPeers = flag.String(<span class="hljs-string">"peers"</span>, <span class="hljs-string">"ws://localhost:6001"</span>, <span class="hljs-string">"initial peers"</span>)
)

<span class="hljs-keyword">type</span> Block <span class="hljs-keyword">struct</span> {
    Index        <span class="hljs-typename">int64</span>  <span class="hljs-string">`json:"index"`</span>
    PreviousHash <span class="hljs-typename">string</span> <span class="hljs-string">`json:"previousHash"`</span>
    Timestamp    <span class="hljs-typename">int64</span>  <span class="hljs-string">`json:"timestamp"`</span>
    Data         <span class="hljs-typename">string</span> <span class="hljs-string">`json:"data"`</span>
    Hash         <span class="hljs-typename">string</span> <span class="hljs-string">`json:"hash"`</span>
}

<span class="hljs-keyword">func</span> (b *Block) String() <span class="hljs-typename">string</span> {
    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"index: %d,previousHash:%s,timestamp:%d,data:%s,hash:%s"</span>, b.Index, b.PreviousHash, b.Timestamp, b.Data, b.Hash)
}

<span class="hljs-keyword">type</span> ByIndex []*Block

<span class="hljs-keyword">func</span> (b ByIndex) Len() <span class="hljs-typename">int</span>           { <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(b) }
<span class="hljs-keyword">func</span> (b ByIndex) Swap(i, j <span class="hljs-typename">int</span>)      { b[i], b[j] = b[j], b[i] }
<span class="hljs-keyword">func</span> (b ByIndex) Less(i, j <span class="hljs-typename">int</span>) <span class="hljs-typename">bool</span> { <span class="hljs-keyword">return</span> b[i].Index &lt; b[j].Index }

<span class="hljs-keyword">type</span> ResponseBlockchain <span class="hljs-keyword">struct</span> {
    Type <span class="hljs-typename">int</span>    <span class="hljs-string">`json:"type"`</span>
    Data <span class="hljs-typename">string</span> <span class="hljs-string">`json:"data"`</span>
}

<span class="hljs-keyword">func</span> errFatal(msg <span class="hljs-typename">string</span>, err error) {
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        log.Fatalln(msg, err)
    }
}

<span class="hljs-keyword">func</span> connectToPeers(peersAddr []<span class="hljs-typename">string</span>) {
    <span class="hljs-keyword">for</span> _, peer := <span class="hljs-keyword">range</span> peersAddr {
        <span class="hljs-keyword">if</span> peer == <span class="hljs-string">""</span> {
            <span class="hljs-keyword">continue</span>
        }
        ws, err := websocket.Dial(peer, <span class="hljs-string">""</span>, peer)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Println(<span class="hljs-string">"dial to peer"</span>, err)
            <span class="hljs-keyword">continue</span>
        }
        initConnection(ws)
    }
}
<span class="hljs-keyword">func</span> initConnection(ws *websocket.Conn) {
    <span class="hljs-keyword">go</span> wsHandleP2P(ws)

    log.Println(<span class="hljs-string">"query latest block."</span>)
    ws.Write(queryLatestMsg())
}

<span class="hljs-keyword">func</span> handleBlocks(w http.ResponseWriter, r *http.Request) {
    bs, _ := json.Marshal(blockchain)
    w.Write(bs)
}
<span class="hljs-keyword">func</span> handleMineBlock(w http.ResponseWriter, r *http.Request) {
    <span class="hljs-keyword">var</span> v <span class="hljs-keyword">struct</span> {
        Data <span class="hljs-typename">string</span> <span class="hljs-string">`json:"data"`</span>
    }
    decoder := json.NewDecoder(r.Body)
    <span class="hljs-keyword">defer</span> r.Body.Close()
    err := decoder.Decode(&amp;v)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        w.WriteHeader(http.StatusGone)
        log.Println(<span class="hljs-string">"[API] invalid block data : "</span>, err.Error())
        w.Write([]<span class="hljs-typename">byte</span>(<span class="hljs-string">"invalid block data. "</span> + err.Error() + <span class="hljs-string">"\n"</span>))
        <span class="hljs-keyword">return</span>
    }
    block := generateNextBlock(v.Data)
    addBlock(block)
    broadcast(responseLatestMsg())
}

<span class="hljs-keyword">func</span> handlePeers(w http.ResponseWriter, r *http.Request) {
    <span class="hljs-keyword">var</span> slice []<span class="hljs-typename">string</span>
    <span class="hljs-keyword">for</span> _, socket := <span class="hljs-keyword">range</span> sockets {
        <span class="hljs-keyword">if</span> socket.IsClientConn() {
            slice = <span class="hljs-built_in">append</span>(slice, strings.Replace(socket.LocalAddr().String(), <span class="hljs-string">"ws://"</span>, <span class="hljs-string">""</span>,<span class="hljs-number"> 1</span>))
        } <span class="hljs-keyword">else</span> {
            slice = <span class="hljs-built_in">append</span>(slice, socket.Request().RemoteAddr)
        }
    }
    bs, _ := json.Marshal(slice)
    w.Write(bs)
}

<span class="hljs-keyword">func</span> handleAddPeer(w http.ResponseWriter, r *http.Request) {
    <span class="hljs-keyword">var</span> v <span class="hljs-keyword">struct</span> {
        Peer <span class="hljs-typename">string</span> <span class="hljs-string">`json:"peer"`</span>
    }
    decoder := json.NewDecoder(r.Body)
    <span class="hljs-keyword">defer</span> r.Body.Close()
    err := decoder.Decode(&amp;v)
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        w.WriteHeader(http.StatusGone)
        log.Println(<span class="hljs-string">"[API] invalid peer data : "</span>, err.Error())
        w.Write([]<span class="hljs-typename">byte</span>(<span class="hljs-string">"invalid peer data. "</span> + err.Error()))
        <span class="hljs-keyword">return</span>
    }
    connectToPeers([]<span class="hljs-typename">string</span>{v.Peer})
}

<span class="hljs-keyword">func</span> wsHandleP2P(ws *websocket.Conn) {
    <span class="hljs-keyword">var</span> (
        v    = &amp;ResponseBlockchain{}
        peer = ws.LocalAddr().String()
    )
    sockets = <span class="hljs-built_in">append</span>(sockets, ws)

    <span class="hljs-keyword">for</span> {
        <span class="hljs-keyword">var</span> msg []<span class="hljs-typename">byte</span>
        err := websocket.Message.Receive(ws, &amp;msg)
        <span class="hljs-keyword">if</span> err == io.EOF {
            log.Printf(<span class="hljs-string">"p2p Peer[%s] shutdown, remove it form peers pool.\n"</span>, peer)
            <span class="hljs-keyword">break</span>
        }
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Println(<span class="hljs-string">"Can't receive p2p msg from "</span>, peer, err.Error())
            <span class="hljs-keyword">break</span>
        }

        log.Printf(<span class="hljs-string">"Received[from %s]: %s.\n"</span>, peer, msg)
        err = json.Unmarshal(msg, v)
        errFatal(<span class="hljs-string">"invalid p2p msg"</span>, err)

        <span class="hljs-keyword">switch</span> v.Type {
        <span class="hljs-keyword">case</span> queryLatest:
            v.Type = responseBlockchain

            bs := responseLatestMsg()
            log.Printf(<span class="hljs-string">"responseLatestMsg: %s\n"</span>, bs)
            ws.Write(bs)

        <span class="hljs-keyword">case</span> queryAll:
            d, _ := json.Marshal(blockchain)
            v.Type = responseBlockchain
            v.Data = <span class="hljs-typename">string</span>(d)
            bs, _ := json.Marshal(v)
            log.Printf(<span class="hljs-string">"responseChainMsg: %s\n"</span>, bs)
            ws.Write(bs)

        <span class="hljs-keyword">case</span> responseBlockchain:
            handleBlockchainResponse([]<span class="hljs-typename">byte</span>(v.Data))
        }

    }
}

<span class="hljs-keyword">func</span> getLatestBlock() (block *Block) { <span class="hljs-keyword">return</span> blockchain[<span class="hljs-built_in">len</span>(blockchain<span class="hljs-number">)-1</span>] }
<span class="hljs-keyword">func</span> responseLatestMsg() (bs []<span class="hljs-typename">byte</span>) {
    <span class="hljs-keyword">var</span> v = &amp;ResponseBlockchain{Type: responseBlockchain}
    d, _ := json.Marshal(blockchain[<span class="hljs-built_in">len</span>(blockchain<span class="hljs-number">)-1</span>:])
    v.Data = <span class="hljs-typename">string</span>(d)
    bs, _ = json.Marshal(v)
    <span class="hljs-keyword">return</span>
}

<span class="hljs-keyword">func</span> queryLatestMsg() []<span class="hljs-typename">byte</span> { <span class="hljs-keyword">return</span> []<span class="hljs-typename">byte</span>(fmt.Sprintf(<span class="hljs-string">"{\"type\": %d}"</span>, queryLatest)) }

<span class="hljs-keyword">func</span> queryAllMsg() []<span class="hljs-typename">byte</span>    { <span class="hljs-keyword">return</span> []<span class="hljs-typename">byte</span>(fmt.Sprintf(<span class="hljs-string">"{\"type\": %d}"</span>, queryAll)) }

<span class="hljs-keyword">func</span> calculateHashForBlock(b *Block) <span class="hljs-typename">string</span> {
    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%x"</span>, sha256.Sum256([]<span class="hljs-typename">byte</span>(fmt.Sprintf(<span class="hljs-string">"%d%s%d%s"</span>, b.Index, b.PreviousHash, b.Timestamp, b.Data))))
}

<span class="hljs-keyword">func</span> generateNextBlock(data <span class="hljs-typename">string</span>) (nb *Block) {
    <span class="hljs-keyword">var</span> previousBlock = getLatestBlock()
    nb = &amp;Block{
        Data:         data,
        PreviousHash: previousBlock.Hash,
        Index:        previousBlock.Index +<span class="hljs-number"> 1</span>,
        Timestamp:    time.Now().Unix(),
    }
    nb.Hash = calculateHashForBlock(nb)
    <span class="hljs-keyword">return</span>
}

<span class="hljs-keyword">func</span> addBlock(b *Block) {
    <span class="hljs-keyword">if</span> isValidNewBlock(b, getLatestBlock()) {
        blockchain = <span class="hljs-built_in">append</span>(blockchain, b)
    }
}

<span class="hljs-keyword">func</span> isValidNewBlock(nb, pb *Block) (ok <span class="hljs-typename">bool</span>) {
    <span class="hljs-keyword">if</span> nb.Hash == calculateHashForBlock(nb) &amp;&amp;
        pb.Index<span class="hljs-number">+1</span> == nb.Index &amp;&amp;
        pb.Hash == nb.PreviousHash {
        ok = <span class="hljs-constant">true</span>
    }
    <span class="hljs-keyword">return</span>
}

<span class="hljs-keyword">func</span> isValidChain(bc []*Block) <span class="hljs-typename">bool</span> {
    <span class="hljs-keyword">if</span> bc<span class="hljs-number">[0</span>].String() != genesisBlock.String() {
        log.Println(<span class="hljs-string">"No same GenesisBlock."</span>, bc<span class="hljs-number">[0</span>].String())
        <span class="hljs-keyword">return</span> <span class="hljs-constant">false</span>
    }
    <span class="hljs-keyword">var</span> temp = []*Block{bc<span class="hljs-number">[0</span>]}
    <span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 1</span>; i &lt; <span class="hljs-built_in">len</span>(bc); i++ {
        <span class="hljs-keyword">if</span> isValidNewBlock(bc[i], temp[i<span class="hljs-number">-1</span>]) {
            temp = <span class="hljs-built_in">append</span>(temp, bc[i])
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-constant">false</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-constant">true</span>
}

<span class="hljs-keyword">func</span> replaceChain(bc []*Block) {
    <span class="hljs-keyword">if</span> isValidChain(bc) &amp;&amp; <span class="hljs-built_in">len</span>(bc) &gt; <span class="hljs-built_in">len</span>(blockchain) {
        log.Println(<span class="hljs-string">"Received blockchain is valid. Replacing current blockchain with received blockchain."</span>)
        blockchain = bc
        broadcast(responseLatestMsg())
    } <span class="hljs-keyword">else</span> {
        log.Println(<span class="hljs-string">"Received blockchain invalid."</span>)
    }
}
<span class="hljs-keyword">func</span> broadcast(msg []<span class="hljs-typename">byte</span>) {
    <span class="hljs-keyword">for</span> n, socket := <span class="hljs-keyword">range</span> sockets {
        _, err := socket.Write(msg)
        <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
            log.Printf(<span class="hljs-string">"peer [%s] disconnected."</span>, socket.RemoteAddr().String())
            sockets = <span class="hljs-built_in">append</span>(sockets<span class="hljs-number">[0</span>:n], sockets[n<span class="hljs-number">+1</span>:]...)
        }
    }
}

<span class="hljs-keyword">func</span> handleBlockchainResponse(msg []<span class="hljs-typename">byte</span>) {
    <span class="hljs-keyword">var</span> receivedBlocks = []*Block{}

    err := json.Unmarshal(msg, &amp;receivedBlocks)
    errFatal(<span class="hljs-string">"invalid blockchain"</span>, err)

    sort.Sort(ByIndex(receivedBlocks))

    latestBlockReceived := receivedBlocks[<span class="hljs-built_in">len</span>(receivedBlocks<span class="hljs-number">)-1</span>]
    latestBlockHeld := getLatestBlock()
    <span class="hljs-keyword">if</span> latestBlockReceived.Index &gt; latestBlockHeld.Index {
        log.Printf(<span class="hljs-string">"blockchain possibly behind. We got: %d Peer got: %d"</span>, latestBlockHeld.Index, latestBlockReceived.Index)
        <span class="hljs-keyword">if</span> latestBlockHeld.Hash == latestBlockReceived.PreviousHash {
            log.Println(<span class="hljs-string">"We can append the received block to our chain."</span>)
            blockchain = <span class="hljs-built_in">append</span>(blockchain, latestBlockReceived)
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(receivedBlocks) ==<span class="hljs-number"> 1</span> {
            log.Println(<span class="hljs-string">"We have to query the chain from our peer."</span>)
            broadcast(queryAllMsg())
        } <span class="hljs-keyword">else</span> {
            log.Println(<span class="hljs-string">"Received blockchain is longer than current blockchain."</span>)
            replaceChain(receivedBlocks)
        }
    } <span class="hljs-keyword">else</span> {
        log.Println(<span class="hljs-string">"received blockchain is not longer than current blockchain. Do nothing."</span>)
    }
}

<span class="hljs-keyword">func</span> main() {
    flag.Parse()
    connectToPeers(strings.Split(*initialPeers, <span class="hljs-string">","</span>))

    http.HandleFunc(<span class="hljs-string">"/blocks"</span>, handleBlocks)
    http.HandleFunc(<span class="hljs-string">"/mine_block"</span>, handleMineBlock)
    http.HandleFunc(<span class="hljs-string">"/peers"</span>, handlePeers)
    http.HandleFunc(<span class="hljs-string">"/add_peer"</span>, handleAddPeer)
    <span class="hljs-keyword">go</span> <span class="hljs-keyword">func</span>() {
        log.Println(<span class="hljs-string">"Listen HTTP on"</span>, *httpAddr)
        errFatal(<span class="hljs-string">"start api server"</span>, http.ListenAndServe(*httpAddr, <span class="hljs-constant">nil</span>))
    }()

    http.Handle(<span class="hljs-string">"/"</span>, websocket.Handler(wsHandleP2P))
    log.Println(<span class="hljs-string">"Listen P2P on "</span>, *p2pAddr)
    errFatal(<span class="hljs-string">"start p2p server"</span>, http.ListenAndServe(*p2pAddr, <span class="hljs-constant">nil</span>))
}</code></pre> 
  <p>链接：<a href="https://github.com/kofj/naivechain/blob/master/main.go" rel="nofollow" target="_blank"> </a><a href="https://github.com/kofj/naivechain/blob/master/main.go" rel="nofollow">https://github.com/kofj/naivechain/blob/master/main.go</a></p> 
  <p></p>
  <div class="toc"> 
   <ul> 
    <li><a href="#什么是区块链" rel="nofollow">什么是区块链</a></li> 
    <li><a href="#区块链原理" rel="nofollow">区块链原理</a>
     <ul> 
      <li><a href="#1区块" rel="nofollow">1.区块</a></li> 
      <li><a href="#2链" rel="nofollow">2.链</a></li> 
     </ul> </li> 
    <li><a href="#一个完整的代码" rel="nofollow">一个完整的代码</a></li> 
   </ul> 
  </div> 
  <p></p> 
  <hr> 
  <p><em>多少人忙得连写博客的时间都没有哟！</em></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-778f64ae39.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/liwan2018/article/details/79377490,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/liwan2018/article/details/79377490,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
