<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>一夜身价暴涨千倍，如何发布你自己的 ICO？ | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="一夜身价暴涨千倍，如何发布你自己的 ICO？" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文来自作者&nbsp;余博伦&nbsp;在&nbsp;GitChat&nbsp;上分享 「韭菜种植与收割：发布你自己的 ICO」，「阅读原文」查看交流实录。 「文末高能」 编辑 | 哈比 你可曾想梭哈全部存款，参与 ICO，一夜身价暴涨千倍，获得财富自由，从此走上人生巅峰？ ICO 是借用 IPO 生造出来的一种概念，同样具有非常相似的募资机制，但 IPO 有着严格的上市流程、政策监管，如下图所示。 即便如此，参与 IPO 仍然有着相当大的风险，且为股市带来了相当大的不稳定因素。而与 ICO 比起来简直就是小巫见大巫了。 一家公司想要进行 IPO 起码要达到能够上市的标准，而想发布 ICO 你只要有一个好听的 idea 就足够了。并且严重缺乏监管，虽然各国政府都在不断发出声明，但截至本分享写作前，也没有正式出台比较明朗的有关规定。 这也导致无数的空气项目披着虚拟货币和区块链的高科技壳，到处招摇撞骗割韭菜，有过之无不及的还搞什么 AI+ 区块链，IOT+ 区块链，技术名词堆积越多的项目，死得往往越快。 甚至一些有头有脸的大公司，也忍不住打打擦边球，收割一波，炒作炒作，股价就能翻几个涨停。 可就像马老爷子说的： 如果有 10% 的利润，它就保证到处被使用；有 20% 的利润，它就活跃起来；有 50% 的利润，它就铤而走险；为了 100% 的利润，它就敢践踏一切人间法律；有 300% 的利润，它就敢犯任何罪行，甚至绞首的危险。 即便如此，仍然有很多人跃跃欲试不信邪。这一场 Chat 就手把手教你为 ICO 做好所有技术面上的准备。在和大家一起点亮新技能的同时，也揭一揭所谓 ICO 的老底。 内容概要 目前市场上 99% 的项目 ICO 都是基于以太坊（Ethereum）智能合约（Smart Contracts）技术发布的 token（ERC20 Token）。 本次分享也是基于这一套技术栈，介绍内容包括以下几个方面。 本地开发环境构建 以太坊智能合约开发 本地开发环境发布 线上测试网络发布 主网络发布 ERC20 Token 合约开发 ICO Crowdsale 合约开发 补充说明与权限控制 合约的发布及调试 Dapp 开发 web3.js 的使用 Metamask 简介 truffle-contract 的使用 ICO 前端应用开发 Dapp 部署 IPNS Nginx 反向代理 IPFS 简介 发布应用 域名解析 使用到的技术栈包括： Truffle：http://truffleframework.com [Ganache：http://truffleframework.com/ganache Metamask：https://metamask.io Solidity：http://solidity.readthedocs.io/en/develop openzeppelin：https://openzeppelin.org Infura：https://infura.io web3.js：https://web3js.readthedocs.io/en/1.0/index.html truffle-contract：https://github.com/trufflesuite/truffle-contract ipfs：https://ipfs.io 对读者的基本要求有： 了解编程 会 JavaScript 本地开发环境构建 以太坊官方提供的 Mist&nbsp;(https://github.com/ethereum/mist/releases)&nbsp;和 Ethereum-Wallet&nbsp;(https://github.com/ethereum/mist/releases)。 其中 Mist 是一个可以用来访问 Dapp 的浏览器，Ethereum-Wallet 是 Mist 的一个独立发布版本，也算是浏览器，但只能用来访问以太坊钱包这个应用。 在网络同步过程中或多或少都会遇到问题，而且目前网络拥堵，完整节点过大，同步完成相当困难。但事实上我们进行以太坊开发时并不需要同步完整的节点，也可以选择使用相应的模拟开发环境。 Truffle&nbsp;(http://truffleframework.com)&nbsp;框架为你提供本地进行智能合约开发的所有依赖支持，使你可以在本地进行智能合约及 Dapp 的开发、编译、发布。安装非常简单，只需要： npm install -g truffle Ganache&nbsp;(http://truffleframework.com/ganache)&nbsp;也是 Truffle 框架中提供的一个应用，可以在你的本地开启模拟一个以太坊节点，让你能够将开发好的智能合约发布至本地测试节点中运行调试。 安装也非常简单，官网下载即可，双击打开运行。 不过这里有一个隐藏的坑，如果你使用的是 Windows 系统的话，Ganache 提供的是后缀名为&nbsp;.appx&nbsp;的 Windows 应用商店版安装包。你需要打开 Windows 设置 -&gt; 系统 -&gt; 针对开发人员 -&gt; 选择 “旁加载应用” 这个选项。 确认之后就可以双击&nbsp;Ganache.appx&nbsp;进行安装了，假如系统仍然无法识别这一后缀名，你可以手动打开&nbsp;powershell&nbsp;输入如下命令进行安装。 Add-AppxPackage .\Ganache.appx 至此本地开发智能合约及 Dapp 的环境就算安装完成了，Truffle 官方提供了许多示例教程以及应用脚手架（truffle box），其中就包括教你开发以太坊宠物商&nbsp;(http://truffleframework.com/tutorials/pet-shop)&nbsp;的教程等内容。 在此不再赘述，感兴趣的同学自己动手可以试试。 以太坊智能合约开发 首先使用 Truffle 初始化我们的项目，命令如下。 mkdir my-icocd my-ico npm init -y truffle init 脚本运行完成之后 Truffle 会自动为我们的项目创建一系列文件夹和文件，如下图所示。 这里有一个隐藏的坑，如果你使用 Windows 命令行的话，需要删掉&nbsp;truffle.js&nbsp;文件，否则在项目目录执行 truffle 相关命令时，CMD 会混淆&nbsp;truffle&nbsp;与&nbsp;truffle.js&nbsp;文件。 因此，你应该将配置写在&nbsp;truffle-config.js&nbsp;文件当中。 ERC20 Token 合约开发 现在我们的项目目录大概是这个样子： contracts/ Migrations.sol migrations/ 1_initial_migration.js test/ package.json truffle-config.js 或 truffle.js 我们在编写智能合约时，需要在&nbsp;contracts&nbsp;目录下新建相应的智能合约文件。 在以太坊开发智能合约的编程语言叫做 Solidity&nbsp;(https://goo.gl/hCHh3w)。它是一种在语法上非常类似 JavaScript 的语言，其后缀名为&nbsp;.sol&nbsp;。 例如在这里我们可以创建一个名为&nbsp;GitCoin.sol&nbsp;的文件，命令如下。 // *nix touch GitCoin.sol // win copy NUL &gt; GitCoin.sol ERC20（Ethereum Request for Comments NO.20）(https://goo.gl/aX4x5F)&nbsp;是官方发行的 token 标准。 如果你希望你发布的 token 能够在以太坊网络上流通、上市交易所、支持以太坊钱包，在开发 token 的合约时就必须遵从这一规范。 ERC20 规定了合约中的一系列变量、方法、事件，你可以参考官网教程 Create your own CRYPTO-CURRENCY with Ethereum&nbsp;(https://www.ethereum.org/token)&nbsp;当中的示例代码： pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }contract TokenERC20 { &nbsp; &nbsp;// Public variables of the token &nbsp; &nbsp;string public name; &nbsp; &nbsp;string public symbol; &nbsp; &nbsp;uint8 public decimals = 18; &nbsp; &nbsp;// 18 decimals is the strongly suggested default, avoid changing it &nbsp; &nbsp;uint256 public totalSupply; &nbsp; &nbsp;// This creates an array with all balances &nbsp; &nbsp;mapping (address =&gt; uint256) public balanceOf; &nbsp; &nbsp;mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; &nbsp; &nbsp;// This generates a public event on the blockchain that will notify clients &nbsp; &nbsp;event Transfer(address indexed from, address indexed to, uint256 value); &nbsp; &nbsp;// This notifies clients about the amount burnt &nbsp; &nbsp;event Burn(address indexed from, uint256 value); &nbsp; &nbsp;/** &nbsp; &nbsp; * Constrctor function &nbsp; &nbsp; * &nbsp; &nbsp; * Initializes contract with initial supply tokens to the creator of the contract &nbsp; &nbsp; */ &nbsp; &nbsp;function TokenERC20( &nbsp; &nbsp; &nbsp; &nbsp;uint256 initialSupply, &nbsp; &nbsp; &nbsp; &nbsp;string tokenName, &nbsp; &nbsp; &nbsp; &nbsp;string tokenSymbol &nbsp; &nbsp;) public { &nbsp; &nbsp; &nbsp; &nbsp;totalSupply = initialSupply * 10 ** uint256(decimals); &nbsp;// Update total supply with the decimal amount &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = totalSupply; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Give the creator all initial tokens &nbsp; &nbsp; &nbsp; &nbsp;name = tokenName; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Set the name for display purposes &nbsp; &nbsp; &nbsp; &nbsp;symbol = tokenSymbol; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Set the symbol for display purposes &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Internal transfer, only can be called by this contract &nbsp; &nbsp; */ &nbsp; &nbsp;function _transfer(address _from, address _to, uint _value) internal { &nbsp; &nbsp; &nbsp; &nbsp;// Prevent transfer to 0x0 address. Use burn() instead &nbsp; &nbsp; &nbsp; &nbsp;require(_to != 0x0); &nbsp; &nbsp; &nbsp; &nbsp;// Check if the sender has enough &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp;// Check for overflows &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[_to] + _value &gt; balanceOf[_to]); &nbsp; &nbsp; &nbsp; &nbsp;// Save this for an assertion in the future &nbsp; &nbsp; &nbsp; &nbsp;uint previousBalances = balanceOf[_from] + balanceOf[_to]; &nbsp; &nbsp; &nbsp; &nbsp;// Subtract from the sender &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp;// Add the same to the recipient &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_to] += _value; &nbsp; &nbsp; &nbsp; &nbsp;Transfer(_from, _to, _value); &nbsp; &nbsp; &nbsp; &nbsp;// Asserts are used to use static analysis to find bugs in your code. They should never fail &nbsp; &nbsp; &nbsp; &nbsp;assert(balanceOf[_from] + balanceOf[_to] == previousBalances); &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Transfer tokens &nbsp; &nbsp; * &nbsp; &nbsp; * Send `_value` tokens to `_to` from your account &nbsp; &nbsp; * &nbsp; &nbsp; * @param _to The address of the recipient &nbsp; &nbsp; * @param _value the amount to send &nbsp; &nbsp; */ &nbsp; &nbsp;function transfer(address _to, uint256 _value) public { &nbsp; &nbsp; &nbsp; &nbsp;_transfer(msg.sender, _to, _value); &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Transfer tokens from other address &nbsp; &nbsp; * &nbsp; &nbsp; * Send `_value` tokens to `_to` on behalf of `_from` &nbsp; &nbsp; * &nbsp; &nbsp; * @param _from The address of the sender &nbsp; &nbsp; * @param _to The address of the recipient &nbsp; &nbsp; * @param _value the amount to send &nbsp; &nbsp; */ &nbsp; &nbsp;function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;require(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp; // Check allowance &nbsp; &nbsp; &nbsp; &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp;_transfer(_from, _to, _value); &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Set allowance for other address &nbsp; &nbsp; * &nbsp; &nbsp; * Allows `_spender` to spend no more than `_value` tokens on your behalf &nbsp; &nbsp; * &nbsp; &nbsp; * @param _spender The address authorized to spend &nbsp; &nbsp; * @param _value the max amount they can spend &nbsp; &nbsp; */ &nbsp; &nbsp;function approve(address _spender, uint256 _value) public &nbsp; &nbsp; &nbsp; &nbsp;returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;allowance[msg.sender][_spender] = _value; &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Set allowance for other address and notify &nbsp; &nbsp; * &nbsp; &nbsp; * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it &nbsp; &nbsp; * &nbsp; &nbsp; * @param _spender The address authorized to spend &nbsp; &nbsp; * @param _value the max amount they can spend &nbsp; &nbsp; * @param _extraData some extra information to send to the approved contract &nbsp; &nbsp; */ &nbsp; &nbsp;function approveAndCall(address _spender, uint256 _value, bytes _extraData) &nbsp; &nbsp; &nbsp; &nbsp;public &nbsp; &nbsp; &nbsp; &nbsp;returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;tokenRecipient spender = tokenRecipient(_spender); &nbsp; &nbsp; &nbsp; &nbsp;if (approve(_spender, _value)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spender.receiveApproval(msg.sender, _value, this, _extraData); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Destroy tokens &nbsp; &nbsp; * &nbsp; &nbsp; * Remove `_value` tokens from the system irreversibly &nbsp; &nbsp; * &nbsp; &nbsp; * @param _value the amount of money to burn &nbsp; &nbsp; */ &nbsp; &nbsp;function burn(uint256 _value) public returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[msg.sender] &gt;= _value); &nbsp; // Check if the sender has enough &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Subtract from the sender &nbsp; &nbsp; &nbsp; &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Updates totalSupply &nbsp; &nbsp; &nbsp; &nbsp;Burn(msg.sender, _value); &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Destroy tokens from other account &nbsp; &nbsp; * &nbsp; &nbsp; * Remove `_value` tokens from the system irreversibly on behalf of `_from`. &nbsp; &nbsp; * &nbsp; &nbsp; * @param _from the address of the sender &nbsp; &nbsp; * @param _value the amount of money to burn &nbsp; &nbsp; */ &nbsp; &nbsp;function burnFrom(address _from, uint256 _value) public returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Check if the targeted balance is enough &nbsp; &nbsp; &nbsp; &nbsp;require(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp;// Check allowance &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the targeted balance &nbsp; &nbsp; &nbsp; &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the sender&#39;s allowance &nbsp; &nbsp; &nbsp; &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Update totalSupply &nbsp; &nbsp; &nbsp; &nbsp;Burn(_from, _value); &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} } 我只是想割韭菜而已，用得着写几百行代码吗？ 当然不必，这时我们就需要使用到智能合约开发框架 OpenZeppelin&nbsp;(https://openzeppelin.org)，安装命令如下。 npm install zeppelin-solidity --save GitCoin.sol 引入 OpenZeppelin，代码如下。 // 声明 solidity 编译版本pragma solidity ^0.4.18;// 引入框架为我们提供的编写好的 ERC20 Token 的代码import &quot;zeppelin-solidity/contracts/token/StandardToken.sol&quot;;// 通过 is 关键字继承 StandardTokencontract GitToken is StandardToken { &nbsp;string public name = &quot;GitToken&quot;; // Token 名称 &nbsp;string public symbol = &quot;EGT&quot;; // Token 标识 例如：ETH/EOS &nbsp;uint public decimals = 18; // 计量单位，和 ETH 保持一样就设置为 18 &nbsp;uint public INITIAL_SUPPLY = 10000 * (10 ** decimals); // 初始供应量 &nbsp;// 与 contract 同名的函数为本 contract 的构造方法，类似于 JavaScript 当中的 constructor &nbsp;function GitToken() { &nbsp; &nbsp;totalSupply = INITIAL_SUPPLY; // 设置初始供应量 &nbsp; &nbsp;balances[msg.sender] = INITIAL_SUPPLY; // 将所有初始 token 都存入 contract 创建者的余额 &nbsp;} } 好了，至此一个可以用来交易的符合 ERC20 标准的 token 就编写完毕了。 就这么简单？就这么简单！当然智能合约的功能不止如此，token 中可以玩转设计的地方也不止这些。 不过我们要稍微放在后面一些来讨论，接下来还是赶快着手 ICO 合约开发，为我们的项目募集资金吧。 ICO Crowdsale 合约开发 同样，以太坊官网文档在教程 CROWDSALE Raising funds from friends without a third party&nbsp;(https://www.ethereum.org/crowdsale)&nbsp;中也为我们提供了用来 crowdsale 做 ICO 募资的示例代码： pragma solidity ^0.4.18;/** * interface 的概念和其他编程语言当中类似，在这里相当于我们可以通过传参引用之前发布的 token 合约 * 我们只需要使用其中的转账 transfer 方法，所以就只声明 transfer **/interface token { &nbsp; &nbsp;function transfer(address receiver, uint amount); }contract Crowdsale { &nbsp; &nbsp;// 这里是发布合约时需要传入的参数 &nbsp; &nbsp;address public beneficiary; // ICO 募资成功后的收款方 &nbsp; &nbsp;uint public fundingGoal; // 骗多少钱 &nbsp; &nbsp;uint public amountRaised; // 割到多少韭菜 &nbsp; &nbsp;uint public deadline; // 割到啥时候 &nbsp; &nbsp;/** &nbsp; &nbsp;* 卖多贵，即你的 token 与以太坊的汇率，你可以自己设定 &nbsp; &nbsp;* 注意到，ICO 当中 token 的价格是由合约发布方自行设定而不是市场决定的 &nbsp; &nbsp;* 也就是说你项目值多少钱你可以自己编 &nbsp; &nbsp;**/ &nbsp; &nbsp;uint public price; &nbsp; &nbsp;token public tokenReward; // 你要卖的 token &nbsp; &nbsp;mapping(address =&gt; uint256) public balanceOf; &nbsp; &nbsp;bool fundingGoalReached = false; // 是否达标 &nbsp; &nbsp;bool crowdsaleClosed = false; // 售卖是否结束 &nbsp; &nbsp;/** &nbsp; &nbsp;* 事件可以用来记录信息，每次调用事件方法时都能将相关信息存入区块链中 &nbsp; &nbsp;* 可以用作凭证，也可以在你的 Dapp 中查询使用这些数据 &nbsp; &nbsp;**/ &nbsp; &nbsp;event GoalReached(address recipient, uint totalAmountRaised); &nbsp; &nbsp;event FundTransfer(address backer, uint amount, bool isContribution); &nbsp; &nbsp;/** &nbsp; &nbsp; * Constrctor function &nbsp; &nbsp; * &nbsp; &nbsp; * Setup the owner &nbsp; &nbsp; */ &nbsp; &nbsp;function Crowdsale( &nbsp; &nbsp; &nbsp; &nbsp;address ifSuccessfulSendTo, &nbsp; &nbsp; &nbsp; &nbsp;uint fundingGoalInEthers, &nbsp; &nbsp; &nbsp; &nbsp;uint durationInMinutes, &nbsp; &nbsp; &nbsp; &nbsp;uint etherCostOfEachToken, &nbsp; &nbsp; &nbsp; &nbsp;address addressOfTokenUsedAsReward &nbsp; &nbsp;) { &nbsp; &nbsp; &nbsp; &nbsp;beneficiary = ifSuccessfulSendTo; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoal = fundingGoalInEthers * 1 ether; &nbsp; &nbsp; &nbsp; &nbsp;deadline = now + durationInMinutes * 1 minutes; &nbsp; &nbsp; &nbsp; &nbsp;price = etherCostOfEachToken * 1 ether; &nbsp; &nbsp; &nbsp; &nbsp;tokenReward = token(addressOfTokenUsedAsReward); // 传入已发布的 token 合约的地址来创建实例 &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Fallback function &nbsp; &nbsp; * &nbsp; &nbsp; * payable 用来指明向合约付款时调用的方法 &nbsp; &nbsp; */ &nbsp; &nbsp;function () payable { &nbsp; &nbsp; &nbsp; &nbsp;require(!crowdsaleClosed); &nbsp; &nbsp; &nbsp; &nbsp;uint amount = msg.value; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] += amount; &nbsp; &nbsp; &nbsp; &nbsp;amountRaised += amount; &nbsp; &nbsp; &nbsp; &nbsp;tokenReward.transfer(msg.sender, amount / price); &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(msg.sender, amount, true); &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp;* modifier 可以理解为其他语言中的装饰器或中间件 &nbsp; &nbsp;* 当通过其中定义的一些逻辑判断通过之后才会继续执行该方法 &nbsp; &nbsp;* _ 表示继续执行之后的代码 &nbsp; &nbsp;**/ &nbsp; &nbsp;modifier afterDeadline() { if (now &gt;= deadline) _; } &nbsp; &nbsp;/** &nbsp; &nbsp; * Check if goal was reached &nbsp; &nbsp; * &nbsp; &nbsp; * Checks if the goal or time limit has been reached and ends the campaign &nbsp; &nbsp; */ &nbsp; &nbsp;function checkGoalReached() afterDeadline { &nbsp; &nbsp; &nbsp; &nbsp;if (amountRaised &gt;= fundingGoal){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoalReached = true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GoalReached(beneficiary, amountRaised); &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;crowdsaleClosed = true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Withdraw the funds &nbsp; &nbsp; * &nbsp; &nbsp; * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached, &nbsp; &nbsp; * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw &nbsp; &nbsp; * the amount they contributed. &nbsp; &nbsp; */ &nbsp; &nbsp;function safeWithdrawal() afterDeadline { &nbsp; &nbsp; &nbsp; &nbsp;if (!fundingGoalReached) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint amount = balanceOf[msg.sender]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (amount &gt; 0) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (msg.sender.send(amount)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(msg.sender, amount, false); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = amount; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;if (fundingGoalReached &amp;&amp; beneficiary == msg.sender) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (beneficiary.send(amountRaised)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(beneficiary, amountRaised, false); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//If we fail to send the funds to beneficiary, unlock funders balance &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoalReached = false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;} } 至此我们的 ICO 合约也开发完毕了，基本上一行代码都没有写，只是改了几个参数，一个键盘上只有三个按键的程序员都能够完成这类智能合约的开发，没有比这更友好的编程体验了。 虽然 solidity 是一种非图灵完备的编程语言，但我们仍然能够用它编写许多逻辑。 上述的 ICO 示例代码写得算比较客气的一种，在最后的提款方法中，如果筹资达标，ICO 发布方则可以取走所有筹款，而如果未达标，参与者则能够取回自己的投资，由合约来持有所有款项。 但事实上，我们仍然可以随意修改其中的逻辑，看下面代码。 function () payable { &nbsp;require(!crowdsaleClosed); &nbsp;uint amount = msg.value; &nbsp;balanceOf[msg.sender] += amount; &nbsp;amountRaised += amount; &nbsp;tokenReward.transfer(msg.sender, amount / price); &nbsp;// 每次有人付款直接取走筹资 &nbsp;beneficiary.send(amountRaised); &nbsp;amountRaised = 0; &nbsp;FundTransfer(msg.sender, amount, true); }// 删除剩余代码 补充说明与权限控制 既然咱是铁了心来割韭菜的，如此简单的代码怎么能够满足咱的贪欲呢？一定要学比特币固定供给量吗？ 我是来卖 token 的呀，万一有一天卖完了怎么办，万一有人手里筹码比我自己都多了控盘怎么办，万一发的数量太多卖的不好怎么办？ 事实上解决这些问题的逻辑全部都可以写在智能合约里。 Ownable token 在我们的潜在观念里，区块链自有不可变属性。 这种不可变属性在一些狂热信徒的演绎当中变成了平权属性，甚至带有了共产主义色彩，仿佛拥抱区块链技术就能够为未来的人类文明带来希望，把人民从集权的手中解救出来。 然而事实上这种不可变性同样是两面的，它能够带来的也包括所有权的不可变性。 ERC20 标准只规定了我们的合约中应该包含哪些方法，而没有限制合约中不能出现哪些方法，因此在之前的基础上，我们还可以继续编写一些特殊的方法，赋予合约发布者一些管理员特权。 请看下面代码： contract Ownable { &nbsp; &nbsp;address public owner; &nbsp; &nbsp;function Ownable() public { &nbsp; &nbsp; &nbsp; &nbsp;owner = msg.sender; &nbsp; &nbsp;} &nbsp; &nbsp;// 通过 onlyOwner 我们可以限定一些方法只有所有者才能够调用 &nbsp; &nbsp;modifier onlyOwner { &nbsp; &nbsp; &nbsp; &nbsp;require(msg.sender == owner); &nbsp; &nbsp; &nbsp; &nbsp;_; &nbsp; &nbsp;} &nbsp; &nbsp;function transferOwnership(address newOwner) onlyOwner public { &nbsp; &nbsp; &nbsp; &nbsp;owner = newOwner; &nbsp; &nbsp;} }// 合约可以同时有多个继承contract GitToken is StandardToken, Ownable { &nbsp;... MintableToken 接下来我们来解决 token 不够卖的问题，万一我的 initial offer 卖断货了怎么办，万一我卖完一次还想卖怎么办？ 这时我们就需要把 token 编写成为 MintableToken，在我们想增发的时候就能增发，代码如下： // 用 onlyOwner 限定只有 token 的所有者才能够进行增发操作function mint(address _to, uint256 _amount) onlyOwner public returns (bool) { &nbsp;totalSupply_ = totalSupply_.add(_amount); &nbsp;balances[_to] = balances[_to].add(_amount); &nbsp;Mint(_to, _amount); &nbsp;Transfer(address(0), _to, _amount); &nbsp;return true; } BurnableToken 万一我们的 token 不小心发了太多，卖的时间久了贬值怎么办？ 当然是销毁了，可参照下面代码： /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */function burn(uint256 _value) public returns (bool success) { &nbsp;require(balanceOf[msg.sender] &gt;= _value); &nbsp; // Check if the sender has enough &nbsp;balanceOf[msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Subtract from the sender &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Updates totalSupply &nbsp;Burn(msg.sender, _value); &nbsp;return true; } 万一有人手里的筹码太多，或者 token 被竞争对手买走了怎么办？没关系，我们还可以指定销毁某一账户中的 token，请看下面代码： /** &nbsp;* Destroy tokens from other account &nbsp;* &nbsp;* Remove `_value` tokens from the system irreversibly on behalf of `_from`. &nbsp;* &nbsp;* @param _from the address of the sender &nbsp;* @param _value the amount of money to burn &nbsp;*/function burnFrom(address _from, uint256 _value) public returns (bool success) { &nbsp;require(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Check if the targeted balance is enough &nbsp;require(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp;// Check allowance &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the targeted balance &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the sender&#39;s allowance &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Update totalSupply &nbsp;Burn(_from, _value); &nbsp;return true; } 只要上述的方法全部都出现在合约里，我们发布的 token 就能够具备上述所有属性。 这样一来，不够的时候我们可以发钱，发多了可以销毁，我们成功创建了属于自己的一所中央银行，甚至看某人不爽还能够指定销毁其账户存款，这哪里是平权，简直是超级集权。 而事实上，在已发布的 ERC20 token 当中，例如排名第一的 EOS 的合约&nbsp;(https://goo.gl/L2AmQP)&nbsp;里也是存在类似方法的，如下所示。 function mint(uint128 wad) auth stoppable note { &nbsp;_balances[msg.sender] = add(_balances[msg.sender], wad); &nbsp;_supply = add(_supply, wad); }function burn(uint128 wad) auth stoppable note { &nbsp;_balances[msg.sender] = sub(_balances[msg.sender], wad); &nbsp;_supply = sub(_supply, wad); } 当然在其官方网站和白皮书中是标明了会发布多少 token，创始团队持有多少，投资人分配多少，公开发布多少，如何销毁等内容的。 但白皮书又不具备法律效力，token 的所有权也不在你手里，万一人家哪天想要跑路或者中途变卦岂是咱能拦得住的。 换个角度讲，假如你现在手里有一家可以印钱的公司，印多少就有多少，你印还是不印？ 通过这一部分内容的介绍，我只是想要证明，智能合约本身并不具备可无条件信任的特性，充其量就是一段没法改一直跑的程序而已。 你也可以在逻辑中加入管理员权限，token 的发布方并不比央行可信多少，只要所有者愿意可以随时进行修改。以太坊官方宣传的所谓 “trustless” 这一概念根本不成立。 没有第三方担保，没有法律法规的维护，仅凭智能合约本身你的投资得不到任何保证。智能合约的不可变性反而给割韭菜的一方提供了巨大的便利。 从前你看不惯某家公司还能够黑掉它的系统，获取管理员权限，如今所有程序都跑在区块链上，黑无可黑，集权永远都在合约发布者的手里。 讲到这里，希望你能理解这次分享的良苦用心，不要轻信任何 ICO 项目。 合约的发布及调试 本地开发环境发布 合约开发完成之后，我们需要编译并发布合约至区块链网络中，只需要进行以下两步操作。 首先在&nbsp;migrations&nbsp;文件夹下新建&nbsp;2-deploy-contract.js&nbsp;文件，配置部署脚本如下。 // 引入我们编写的合约const GitCoin = artifacts.require(&quot;./GitCoin.sol&quot;)const GitCoinCrowdsale = artifacts.require(&quot;./GitCoinCrowdsale.sol&quot;)module.exports = function(deployer, network, accounts) { &nbsp;// 设定参数，此处的参数即使传入合约构造方法的参数，与你自己编写的合约保持一致 &nbsp;const ifSuccessfulSendTo = accounts[0] // 当前以太坊网络中的默认账户 &nbsp;const fundingGoalInEthers = 1000 &nbsp;const durationInMinutes = 36000000 &nbsp;const etherCostOfEachToken = 0.01 &nbsp;// 这里的 Promise 可以保证我们在发布完 token 合约之后再发布 ICO 合约，并将已发布 token 的地址作为参数传入 &nbsp;deployer.deploy(GitCoin).then(function() { &nbsp; &nbsp;return deployer.deploy(GitCoinCrowdsale, ifSuccessfulSendTo, fundingGoalInEthers, durationInMinutes, etherCostOfEachToken, GitCoin.address); &nbsp;}); }; 接着在&nbsp;truffle-config.js&nbsp;或&nbsp;truffle.js&nbsp;中设置发布网络，脚本如下。 module.exports = { &nbsp;networks: { &nbsp; &nbsp;development: { &nbsp; &nbsp; &nbsp;host: &quot;127.0.0.1&quot;, &nbsp; &nbsp; &nbsp;port: 7545, // 与你本地的 ganache 设置保持一致 &nbsp; &nbsp; &nbsp;network_id: &quot;*&quot; // Match any network id &nbsp; &nbsp;} &nbsp;} }; 现在只需要开启 Ganache： 然后在命令行中输入： truffle compile truffle migrate 你的合约就会顺利发布至测试网络中了。然后你可以输入： truffle console 这样就能够进入本地的命令行调试了： # 所有的合约方法都是 Promise 对象truffle(development)&gt; GitCoinCrowdsale.deployed().then(inst=&gt;{crowd=inst}) truffle(development)&gt; GitCoin.deployed().then(inst=&gt;{git=inst}) truffle(development)&gt; crowd.sendTransaction({from:web3.eth.accounts[0],value:web3.toWei(1, &quot;ether&quot;)}) truffle(development)&gt; git.mint(web3.eth.accounts[0],web3.toWei(100, &quot;ether&quot;)) 线上测试网络发布 以太坊网络分为测试网和主网，在正式发布主网之前，我们可以先发送到测试网络进行调试。 发布至以太坊网络也无需同步完整节点，我们可以使用 Infura 为我们提供的公共接口。 填写表单提交后，Infura 会为你提供专用的接口地址，然后我们只需要将网络地址填入到配置文件中，如下所示。 var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;); // 在这里我们需要通过 js 调用以太坊钱包，通过 npm install truffle-hdwallet-provider 安装这个库var infura_apikey = &quot;ubQWERwasd&quot;; // infura 为你提供的 apikey 请与你申请到的 key 保持一致，此处仅为示例var mnemonic = &quot;apple banana carray dog egg fault great&quot;; // 你以太坊钱包的 mnemonic ，可以从 Metamask 当中导出，mnemonic 可以获取你钱包的所有访问权限，请妥善保存，在开发中切勿提交到 gitmodule.exports = { &nbsp;networks: { &nbsp; &nbsp;development: { &nbsp; &nbsp; &nbsp;host: &quot;127.0.0.1&quot;, &nbsp; &nbsp; &nbsp;port: 7545, &nbsp; &nbsp; &nbsp;network_id: &quot;*&quot; &nbsp; &nbsp;}, &nbsp; &nbsp;ropsten: { &nbsp; &nbsp; &nbsp;provider: function() { &nbsp; &nbsp; &nbsp; &nbsp;return new HDWalletProvider(mnemonic, &quot;https://ropsten.infura.io/&quot;+infura_apikey) &nbsp; &nbsp; &nbsp;}, &nbsp; &nbsp; &nbsp;network_id: 3, &nbsp; &nbsp; &nbsp;gas: 3012388, &nbsp; &nbsp; &nbsp;gasPrice: 30000000000 &nbsp; &nbsp;}, &nbsp; &nbsp;main: { &nbsp; &nbsp; &nbsp;provider: function() { &nbsp; &nbsp; &nbsp; &nbsp;return new HDWalletProvider(mnemonic, &quot;https://mainnet.infura.io/&quot;+infura_apikey) &nbsp; &nbsp; &nbsp;}, &nbsp; &nbsp; &nbsp;network_id: 3, &nbsp; &nbsp; &nbsp;gas: 3012388, &nbsp; &nbsp; &nbsp;gasPrice: 1000000000 &nbsp; &nbsp;} &nbsp;} }; 在以太坊网络中发布合约需要使用 ETH 支付矿工的 gas 费用，你可以在 Ethereum Ropsten Faucet&nbsp;(http://faucet.ropsten.be:3001)&nbsp;免费获取到用于 Ropsten 测试网络的 ETH。 由于网络环境的变化，不同的拥堵状况可能造成燃料费用和消耗的不同。 如果发布不成功，可以调整&nbsp;gas/gasPrice&nbsp;的数值，你可以通过&nbsp;web3.getBlock(&#39;latest&#39;).gasLimit&nbsp;这一数值判断当前网络的消耗。 在命令行输入如下命令： truffle migrate --network ropsten 通过&nbsp;--network&nbsp;设置发布的目标网络。 主网络发布 同理，在发布至主网络时，只需要执行如下命令。 truffle migrate --network main 但由于当前的以太坊网络的现实状况，如果设置燃料费太低，可能要等待数天后合约才会被网络确认，注意到我们编写的发布脚本是需要合约地址回调的。 介于这种状况，我们可以将 token 合约和 crowdsale 合约分开发布，只需要再新建&nbsp;3-deploy-crowdsale.js&nbsp;文件，脚本如下。 const LeekCoinCrowdsale = artifacts.require(&quot;./GitCoinCrowdsale.sol&quot;)module.exports = function(deployer, network, accounts) { &nbsp;const ifSuccessfulSendTo = accounts[0] &nbsp;const fundingGoalInEthers = 1000 &nbsp;const durationInMinutes = 36000 &nbsp;const etherCostOfEachToken = 0.01 &nbsp;const tokenAddress = &#39;0x123456789ABCDFGHSDWDVC&#39; // 先单独发布 token 合约，上线成功后将其合约地址填在此处 &nbsp;deployer.deploy(GitCoinCrowdsale, ifSuccessfulSendTo, fundingGoalInEthers, durationInMinutes, etherCostOfEachToken, tokenAddress); }; 在发布至主网络时，可以分开两次进行，确保你设置的账户里有真实的 ETH 余额，注意设置好合理的 gas 数值，根据确认时间的长短，可能需要 0.08~1 ETH 不等。 上线合约验证 无论是发布至以太坊的测试网络还是主网络，在发布完成之后都需要在 Etherscan&nbsp;(https://etherscan.io)&nbsp;进行线上验证。 在 Etherscan 上打开你刚刚发布的合约地址，你可以看到如下内容： 点击&nbsp;Verify And Publish&nbsp;链接就可以进入验证页面： 在填写表单时有以下注意事项。 Compiler 选择最新版本； Optimization 选择 No。 虽然 solidity 支持 import 语法，但 Etherscan 对使用 import 进行开发的合约支持很鸡肋，目前它要求你需要把库文件也当作合约发布至网络才能够在表单中填写进行验证。 当然我们也可以选择手动把 import 库文件的内容手动复制粘贴到代码框里，注意要保留全部内容，包括 pragma 声明一行。 当然你也可以选择使用官方的 Remix&nbsp;(https://remix.ethereum.org/)&nbsp;预先 concrete 你的合约文件，也可以安装 solidity compiler&nbsp;(https://goo.gl/aKsXxH)&nbsp;在本地编译好再发布。 ICO 和 token 的合约如此简单，根本不需要这些玩意儿，所以此处不再赘述，感兴趣的同学可以自行研究。 Dapp 开发 智能合约相当于我们的后端逻辑，以太坊的 EVM 就是我们的云服务器，Infura 为我们提供 API 接口，接下来我们就只需要给韭菜开发一个可以花钱消费的前端界面了。 ICO 项目的网站把握以下几个原则就好。 文字不要太多，页面要大片留白，简洁明了有现代感； 配色一定要深，加上动态几何图形，设计要有未来感； 开发团队全配齐，不是常春藤，没有硅谷背景的不要，一定要国际化； 各种站台大佬，海量媒体报道，一线互联网公司合作全放上去。 言归正传，我们还是专注于技术。 web3.js 的使用 web3.js&nbsp;(https://github.com/ethereum/web3.js)&nbsp;为我们提供了一系列访问以太坊网络的 JavaScript 编程接口，完整的说明文档可以在 web3.js Doc&nbsp;(https://goo.gl/zp2yEQ)&nbsp;中参阅。 我们一般通过如下脚本来初始化 web3 对象。 // 判断当前浏览器中有未注入 web3 对象if (typeof web3 !== &#39;undefined&#39;) { &nbsp;App.web3Provider = web3.currentProvider; &nbsp;web3 = new Web3(web3.currentProvider); } else { &nbsp;// 注意设置到你自己的 infura 地址 &nbsp;App.web3Provider = new Web3.providers.HttpProvider(&#39;https://ropsten.infura.io/ubQWERawsd&#39;); &nbsp;web3 = new Web3(App.web3Provider); } Metamask 简介 Metamask&nbsp;(https://metamask.io)&nbsp;是一个浏览器插件，通过 Metamask 我们可以在浏览器中使用以太坊钱包，在访问 Dapp 应用时，也可以为其注入 web3 对象。 具体配合应用开发的文档可以在 MetaMask Compatibility Guide&nbsp;(https://goo.gl/7wKPtp)&nbsp;查阅，一般我们通过如下脚本来监测 Metamask 状态获取以太坊账户。 var account = web3.eth.accounts[0];var accountInterval = setInterval(function() { &nbsp;if (web3.eth.accounts[0] !== account) { &nbsp; &nbsp;account = web3.eth.accounts[0]; &nbsp; &nbsp;updateInterface(); &nbsp;} }, 100); truffle-contract 的使用 web3.js 默认为我们提供的接口还是太底层，许多调用需要 hard code 设置参数，以太坊网络使用的 BigNumber 也需要我们手动转换。 我们可以选择使用 truffle-contract&nbsp;(https://github.com/trufflesuite/truffle-contract)&nbsp;来调用更高一层的封装对象，并且在之前使用 truffle 开发构建的智能合约文件也能派上用场。 我们可以在&nbsp;build/contracts/&nbsp;下找到编译好的&nbsp;GitCoin.json&nbsp;和&nbsp;GitCoinCrowdsale.json&nbsp;文件，之后可以在我们的应用中通过如下脚本获取合约对象。 &lt;script type=&quot;text/javascript&quot; src=&quot;./dist/truffle-contract.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var GitCoin; $.getJSON(&#39;contracts/GitCoin.json&#39;, function(data) { &nbsp;// 获取编译好的合约文件 &nbsp;var GitCoinArtifact = data; &nbsp;// 通过 truffle-contract 获取合约对象 &nbsp;GitCoin = TruffleContract(GitCoinArtifact); &nbsp;// 将合约绑定至当前 web3 对象 &nbsp;GitCoin.setProvider(App.web3Provider); });&lt;/script&gt; 之后我们就可以像在&nbsp;truffle console&nbsp;当中一样，对合约对象进行各种操作啦。 ICO 前端应用开发 我们的 ICO 应用只需要解决一个核心需求，那就是买币；只需要两个核心功能，一个是选择买多少，另一个就是付款，所以我们的界面自然是相当简单，如下图所示。 然后再稍微美化一下，如下面两张图所示。 一场成功的 ICO，自然需要精雕细琢，完整的代码示例可以在 Leek Ecological Chain&nbsp;(http://lec.yubolun.com/)&nbsp;找到，同时此网站也是上述教程的一个完整示例，你可以切换到 Ropsten 网络在本网站上购买 LEC&nbsp;(https://goo.gl/4uNskB)&nbsp;韭菜币。 Dapp 部署 既然我们开发的是 Dapp 去中心化应用，怎么能够部署在中心化的服务器上呢？这不是自掉身价吗？Dapp 自然有其部署的解决方案。 IPFS 简介 IPFS 提供去中心化的点对点的 Web 服务。 说简单点，你可以把它理解成为一个 p2p 的网盘，你网站的静态文件可以发布到 IPFS 上面托管，而且只要 IPFS 的节点不挂，你的网站就永远都不会挂，而不像部署到单独服务器上。 同时 IPFS 上的一个文件也就对应着一个 hash 地址，普通用户可以通过公共的 http gateway 访问到你的页面，不像云服务器还要备案，正好也方便你割完韭菜跑路。 使用也非常简单，只需要在 Install Go IPFS&nbsp;(https://ipfs.io/docs/install)&nbsp;下载安装。 发布应用 只需要一行命令，把你 Dapp 的所有静态文件上传至 IPFS，命令如下。 ipfs add -r your-ico/# 返回 hash 地址，此处仅为示例added QWERabcd1234qwerABCD your-ico/ 然后你就能够通过 https://goo.gl/5SyBwN 访问你的网站。当然这样的域名十分不友好，为 IPFS 站点设置解析需要一些不常用的操作。 域名解析 IPNS 你的站点必然包含多个文件，每个文件对应着独立的 hash 地址，而且你也不能保证你的网站只需要发布一次。 因此在网站发布后，我们需要使用 ipns 来获取到对应的唯一地址，之后的 DNS 解析也会对应到这一地址，同样只需要一行命令，如下所示。 # 站点发布后的 hash 地址，此处仅为示例ipfs name publish QWERabcd1234qwerABCD# 返回 ipns 地址Published to ABCDqwer1234abcdQWER 之后你就能够通过 https://goo.gl/8YMLBi 访问你的站点了。在设置域名解析时，我们需要添加一条&nbsp;TXT&nbsp;类型的解析记录，解析值为： dnslink=/ipns/ABCDqwer1234abcdQWER 这样我们就能够通过 https://goo.gl/VjSm1K 访问你的 Dapp，这样是不是友好多了？ Nginx 反向代理 当然你也可能希望使用自己的独立域名，这时我们只需要使用 Nginx 设置反向代理即可。 server { &nbsp;listen 80; &nbsp;server_name yourico.com; &nbsp;location / { &nbsp; &nbsp;proxy_pass https://ipfs.io/ipns/yourico.com/; &nbsp;} } 写在后面 以太坊官网，第一篇教程教你发 token，第二篇就教你卖 token，居心何在我也不好评判。 除了 ICO 还有 IMO/IFO ，IMO 你只用卖个路由器，IFO 只需要 fork 一份 Bitcoin 的代码，稍微调调参数，就不需要什么教程了。 程序员总是妄图通过技术手段解决社会问题，然而人性是不变的。以太坊希望建立一个 trustless 的网络，可惜被无数人滥用，巧立空气项目，搞空壳公司，逃避监管搞非法集资。 区块链和虚拟货币期望用点对点分布式的网络，脱离第三方，让世界上任何角落的两个人都能够低成本地进行交易，结果大量投机者涌入，导致网络堵塞，如今我们连一笔交易的矿工费都支付不起。 当然我信奉技术本身是无罪，就好像这篇教你割韭菜的文章一样，你是选择擦亮双眼，看清 ICO 的本质，从此势不两立；还是选择投机倒把，滥用以太坊技术，坠身同流合污？ 您可以在访问 https://github.com/discountry/gitcoin 查看完整的智能合约示例。 您可以访问 https://github.com/discountry/lec 查看完整的 Dapp 示例。 Read at your own risk. 近期热文 《它的暴利，已经完全超过了某些犯罪收入》 《Java 语法糖详解》 《程序员跳槽时，如何高效地准备面试？》 《机器学习数据预处理方法与技巧系统讲解》 《中小型企业基于大数据技术的项目实践》 《GitChat 被恶意攻击引发的技术性思考：拒绝服务攻击》 「阅读原文」看交流实录，你想知道的都在这里 阅读更多" />
<meta property="og:description" content="本文来自作者&nbsp;余博伦&nbsp;在&nbsp;GitChat&nbsp;上分享 「韭菜种植与收割：发布你自己的 ICO」，「阅读原文」查看交流实录。 「文末高能」 编辑 | 哈比 你可曾想梭哈全部存款，参与 ICO，一夜身价暴涨千倍，获得财富自由，从此走上人生巅峰？ ICO 是借用 IPO 生造出来的一种概念，同样具有非常相似的募资机制，但 IPO 有着严格的上市流程、政策监管，如下图所示。 即便如此，参与 IPO 仍然有着相当大的风险，且为股市带来了相当大的不稳定因素。而与 ICO 比起来简直就是小巫见大巫了。 一家公司想要进行 IPO 起码要达到能够上市的标准，而想发布 ICO 你只要有一个好听的 idea 就足够了。并且严重缺乏监管，虽然各国政府都在不断发出声明，但截至本分享写作前，也没有正式出台比较明朗的有关规定。 这也导致无数的空气项目披着虚拟货币和区块链的高科技壳，到处招摇撞骗割韭菜，有过之无不及的还搞什么 AI+ 区块链，IOT+ 区块链，技术名词堆积越多的项目，死得往往越快。 甚至一些有头有脸的大公司，也忍不住打打擦边球，收割一波，炒作炒作，股价就能翻几个涨停。 可就像马老爷子说的： 如果有 10% 的利润，它就保证到处被使用；有 20% 的利润，它就活跃起来；有 50% 的利润，它就铤而走险；为了 100% 的利润，它就敢践踏一切人间法律；有 300% 的利润，它就敢犯任何罪行，甚至绞首的危险。 即便如此，仍然有很多人跃跃欲试不信邪。这一场 Chat 就手把手教你为 ICO 做好所有技术面上的准备。在和大家一起点亮新技能的同时，也揭一揭所谓 ICO 的老底。 内容概要 目前市场上 99% 的项目 ICO 都是基于以太坊（Ethereum）智能合约（Smart Contracts）技术发布的 token（ERC20 Token）。 本次分享也是基于这一套技术栈，介绍内容包括以下几个方面。 本地开发环境构建 以太坊智能合约开发 本地开发环境发布 线上测试网络发布 主网络发布 ERC20 Token 合约开发 ICO Crowdsale 合约开发 补充说明与权限控制 合约的发布及调试 Dapp 开发 web3.js 的使用 Metamask 简介 truffle-contract 的使用 ICO 前端应用开发 Dapp 部署 IPNS Nginx 反向代理 IPFS 简介 发布应用 域名解析 使用到的技术栈包括： Truffle：http://truffleframework.com [Ganache：http://truffleframework.com/ganache Metamask：https://metamask.io Solidity：http://solidity.readthedocs.io/en/develop openzeppelin：https://openzeppelin.org Infura：https://infura.io web3.js：https://web3js.readthedocs.io/en/1.0/index.html truffle-contract：https://github.com/trufflesuite/truffle-contract ipfs：https://ipfs.io 对读者的基本要求有： 了解编程 会 JavaScript 本地开发环境构建 以太坊官方提供的 Mist&nbsp;(https://github.com/ethereum/mist/releases)&nbsp;和 Ethereum-Wallet&nbsp;(https://github.com/ethereum/mist/releases)。 其中 Mist 是一个可以用来访问 Dapp 的浏览器，Ethereum-Wallet 是 Mist 的一个独立发布版本，也算是浏览器，但只能用来访问以太坊钱包这个应用。 在网络同步过程中或多或少都会遇到问题，而且目前网络拥堵，完整节点过大，同步完成相当困难。但事实上我们进行以太坊开发时并不需要同步完整的节点，也可以选择使用相应的模拟开发环境。 Truffle&nbsp;(http://truffleframework.com)&nbsp;框架为你提供本地进行智能合约开发的所有依赖支持，使你可以在本地进行智能合约及 Dapp 的开发、编译、发布。安装非常简单，只需要： npm install -g truffle Ganache&nbsp;(http://truffleframework.com/ganache)&nbsp;也是 Truffle 框架中提供的一个应用，可以在你的本地开启模拟一个以太坊节点，让你能够将开发好的智能合约发布至本地测试节点中运行调试。 安装也非常简单，官网下载即可，双击打开运行。 不过这里有一个隐藏的坑，如果你使用的是 Windows 系统的话，Ganache 提供的是后缀名为&nbsp;.appx&nbsp;的 Windows 应用商店版安装包。你需要打开 Windows 设置 -&gt; 系统 -&gt; 针对开发人员 -&gt; 选择 “旁加载应用” 这个选项。 确认之后就可以双击&nbsp;Ganache.appx&nbsp;进行安装了，假如系统仍然无法识别这一后缀名，你可以手动打开&nbsp;powershell&nbsp;输入如下命令进行安装。 Add-AppxPackage .\Ganache.appx 至此本地开发智能合约及 Dapp 的环境就算安装完成了，Truffle 官方提供了许多示例教程以及应用脚手架（truffle box），其中就包括教你开发以太坊宠物商&nbsp;(http://truffleframework.com/tutorials/pet-shop)&nbsp;的教程等内容。 在此不再赘述，感兴趣的同学自己动手可以试试。 以太坊智能合约开发 首先使用 Truffle 初始化我们的项目，命令如下。 mkdir my-icocd my-ico npm init -y truffle init 脚本运行完成之后 Truffle 会自动为我们的项目创建一系列文件夹和文件，如下图所示。 这里有一个隐藏的坑，如果你使用 Windows 命令行的话，需要删掉&nbsp;truffle.js&nbsp;文件，否则在项目目录执行 truffle 相关命令时，CMD 会混淆&nbsp;truffle&nbsp;与&nbsp;truffle.js&nbsp;文件。 因此，你应该将配置写在&nbsp;truffle-config.js&nbsp;文件当中。 ERC20 Token 合约开发 现在我们的项目目录大概是这个样子： contracts/ Migrations.sol migrations/ 1_initial_migration.js test/ package.json truffle-config.js 或 truffle.js 我们在编写智能合约时，需要在&nbsp;contracts&nbsp;目录下新建相应的智能合约文件。 在以太坊开发智能合约的编程语言叫做 Solidity&nbsp;(https://goo.gl/hCHh3w)。它是一种在语法上非常类似 JavaScript 的语言，其后缀名为&nbsp;.sol&nbsp;。 例如在这里我们可以创建一个名为&nbsp;GitCoin.sol&nbsp;的文件，命令如下。 // *nix touch GitCoin.sol // win copy NUL &gt; GitCoin.sol ERC20（Ethereum Request for Comments NO.20）(https://goo.gl/aX4x5F)&nbsp;是官方发行的 token 标准。 如果你希望你发布的 token 能够在以太坊网络上流通、上市交易所、支持以太坊钱包，在开发 token 的合约时就必须遵从这一规范。 ERC20 规定了合约中的一系列变量、方法、事件，你可以参考官网教程 Create your own CRYPTO-CURRENCY with Ethereum&nbsp;(https://www.ethereum.org/token)&nbsp;当中的示例代码： pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }contract TokenERC20 { &nbsp; &nbsp;// Public variables of the token &nbsp; &nbsp;string public name; &nbsp; &nbsp;string public symbol; &nbsp; &nbsp;uint8 public decimals = 18; &nbsp; &nbsp;// 18 decimals is the strongly suggested default, avoid changing it &nbsp; &nbsp;uint256 public totalSupply; &nbsp; &nbsp;// This creates an array with all balances &nbsp; &nbsp;mapping (address =&gt; uint256) public balanceOf; &nbsp; &nbsp;mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; &nbsp; &nbsp;// This generates a public event on the blockchain that will notify clients &nbsp; &nbsp;event Transfer(address indexed from, address indexed to, uint256 value); &nbsp; &nbsp;// This notifies clients about the amount burnt &nbsp; &nbsp;event Burn(address indexed from, uint256 value); &nbsp; &nbsp;/** &nbsp; &nbsp; * Constrctor function &nbsp; &nbsp; * &nbsp; &nbsp; * Initializes contract with initial supply tokens to the creator of the contract &nbsp; &nbsp; */ &nbsp; &nbsp;function TokenERC20( &nbsp; &nbsp; &nbsp; &nbsp;uint256 initialSupply, &nbsp; &nbsp; &nbsp; &nbsp;string tokenName, &nbsp; &nbsp; &nbsp; &nbsp;string tokenSymbol &nbsp; &nbsp;) public { &nbsp; &nbsp; &nbsp; &nbsp;totalSupply = initialSupply * 10 ** uint256(decimals); &nbsp;// Update total supply with the decimal amount &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = totalSupply; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Give the creator all initial tokens &nbsp; &nbsp; &nbsp; &nbsp;name = tokenName; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Set the name for display purposes &nbsp; &nbsp; &nbsp; &nbsp;symbol = tokenSymbol; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Set the symbol for display purposes &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Internal transfer, only can be called by this contract &nbsp; &nbsp; */ &nbsp; &nbsp;function _transfer(address _from, address _to, uint _value) internal { &nbsp; &nbsp; &nbsp; &nbsp;// Prevent transfer to 0x0 address. Use burn() instead &nbsp; &nbsp; &nbsp; &nbsp;require(_to != 0x0); &nbsp; &nbsp; &nbsp; &nbsp;// Check if the sender has enough &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp;// Check for overflows &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[_to] + _value &gt; balanceOf[_to]); &nbsp; &nbsp; &nbsp; &nbsp;// Save this for an assertion in the future &nbsp; &nbsp; &nbsp; &nbsp;uint previousBalances = balanceOf[_from] + balanceOf[_to]; &nbsp; &nbsp; &nbsp; &nbsp;// Subtract from the sender &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp;// Add the same to the recipient &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_to] += _value; &nbsp; &nbsp; &nbsp; &nbsp;Transfer(_from, _to, _value); &nbsp; &nbsp; &nbsp; &nbsp;// Asserts are used to use static analysis to find bugs in your code. They should never fail &nbsp; &nbsp; &nbsp; &nbsp;assert(balanceOf[_from] + balanceOf[_to] == previousBalances); &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Transfer tokens &nbsp; &nbsp; * &nbsp; &nbsp; * Send `_value` tokens to `_to` from your account &nbsp; &nbsp; * &nbsp; &nbsp; * @param _to The address of the recipient &nbsp; &nbsp; * @param _value the amount to send &nbsp; &nbsp; */ &nbsp; &nbsp;function transfer(address _to, uint256 _value) public { &nbsp; &nbsp; &nbsp; &nbsp;_transfer(msg.sender, _to, _value); &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Transfer tokens from other address &nbsp; &nbsp; * &nbsp; &nbsp; * Send `_value` tokens to `_to` on behalf of `_from` &nbsp; &nbsp; * &nbsp; &nbsp; * @param _from The address of the sender &nbsp; &nbsp; * @param _to The address of the recipient &nbsp; &nbsp; * @param _value the amount to send &nbsp; &nbsp; */ &nbsp; &nbsp;function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;require(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp; // Check allowance &nbsp; &nbsp; &nbsp; &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp;_transfer(_from, _to, _value); &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Set allowance for other address &nbsp; &nbsp; * &nbsp; &nbsp; * Allows `_spender` to spend no more than `_value` tokens on your behalf &nbsp; &nbsp; * &nbsp; &nbsp; * @param _spender The address authorized to spend &nbsp; &nbsp; * @param _value the max amount they can spend &nbsp; &nbsp; */ &nbsp; &nbsp;function approve(address _spender, uint256 _value) public &nbsp; &nbsp; &nbsp; &nbsp;returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;allowance[msg.sender][_spender] = _value; &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Set allowance for other address and notify &nbsp; &nbsp; * &nbsp; &nbsp; * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it &nbsp; &nbsp; * &nbsp; &nbsp; * @param _spender The address authorized to spend &nbsp; &nbsp; * @param _value the max amount they can spend &nbsp; &nbsp; * @param _extraData some extra information to send to the approved contract &nbsp; &nbsp; */ &nbsp; &nbsp;function approveAndCall(address _spender, uint256 _value, bytes _extraData) &nbsp; &nbsp; &nbsp; &nbsp;public &nbsp; &nbsp; &nbsp; &nbsp;returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;tokenRecipient spender = tokenRecipient(_spender); &nbsp; &nbsp; &nbsp; &nbsp;if (approve(_spender, _value)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spender.receiveApproval(msg.sender, _value, this, _extraData); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Destroy tokens &nbsp; &nbsp; * &nbsp; &nbsp; * Remove `_value` tokens from the system irreversibly &nbsp; &nbsp; * &nbsp; &nbsp; * @param _value the amount of money to burn &nbsp; &nbsp; */ &nbsp; &nbsp;function burn(uint256 _value) public returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[msg.sender] &gt;= _value); &nbsp; // Check if the sender has enough &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Subtract from the sender &nbsp; &nbsp; &nbsp; &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Updates totalSupply &nbsp; &nbsp; &nbsp; &nbsp;Burn(msg.sender, _value); &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Destroy tokens from other account &nbsp; &nbsp; * &nbsp; &nbsp; * Remove `_value` tokens from the system irreversibly on behalf of `_from`. &nbsp; &nbsp; * &nbsp; &nbsp; * @param _from the address of the sender &nbsp; &nbsp; * @param _value the amount of money to burn &nbsp; &nbsp; */ &nbsp; &nbsp;function burnFrom(address _from, uint256 _value) public returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Check if the targeted balance is enough &nbsp; &nbsp; &nbsp; &nbsp;require(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp;// Check allowance &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the targeted balance &nbsp; &nbsp; &nbsp; &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the sender&#39;s allowance &nbsp; &nbsp; &nbsp; &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Update totalSupply &nbsp; &nbsp; &nbsp; &nbsp;Burn(_from, _value); &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} } 我只是想割韭菜而已，用得着写几百行代码吗？ 当然不必，这时我们就需要使用到智能合约开发框架 OpenZeppelin&nbsp;(https://openzeppelin.org)，安装命令如下。 npm install zeppelin-solidity --save GitCoin.sol 引入 OpenZeppelin，代码如下。 // 声明 solidity 编译版本pragma solidity ^0.4.18;// 引入框架为我们提供的编写好的 ERC20 Token 的代码import &quot;zeppelin-solidity/contracts/token/StandardToken.sol&quot;;// 通过 is 关键字继承 StandardTokencontract GitToken is StandardToken { &nbsp;string public name = &quot;GitToken&quot;; // Token 名称 &nbsp;string public symbol = &quot;EGT&quot;; // Token 标识 例如：ETH/EOS &nbsp;uint public decimals = 18; // 计量单位，和 ETH 保持一样就设置为 18 &nbsp;uint public INITIAL_SUPPLY = 10000 * (10 ** decimals); // 初始供应量 &nbsp;// 与 contract 同名的函数为本 contract 的构造方法，类似于 JavaScript 当中的 constructor &nbsp;function GitToken() { &nbsp; &nbsp;totalSupply = INITIAL_SUPPLY; // 设置初始供应量 &nbsp; &nbsp;balances[msg.sender] = INITIAL_SUPPLY; // 将所有初始 token 都存入 contract 创建者的余额 &nbsp;} } 好了，至此一个可以用来交易的符合 ERC20 标准的 token 就编写完毕了。 就这么简单？就这么简单！当然智能合约的功能不止如此，token 中可以玩转设计的地方也不止这些。 不过我们要稍微放在后面一些来讨论，接下来还是赶快着手 ICO 合约开发，为我们的项目募集资金吧。 ICO Crowdsale 合约开发 同样，以太坊官网文档在教程 CROWDSALE Raising funds from friends without a third party&nbsp;(https://www.ethereum.org/crowdsale)&nbsp;中也为我们提供了用来 crowdsale 做 ICO 募资的示例代码： pragma solidity ^0.4.18;/** * interface 的概念和其他编程语言当中类似，在这里相当于我们可以通过传参引用之前发布的 token 合约 * 我们只需要使用其中的转账 transfer 方法，所以就只声明 transfer **/interface token { &nbsp; &nbsp;function transfer(address receiver, uint amount); }contract Crowdsale { &nbsp; &nbsp;// 这里是发布合约时需要传入的参数 &nbsp; &nbsp;address public beneficiary; // ICO 募资成功后的收款方 &nbsp; &nbsp;uint public fundingGoal; // 骗多少钱 &nbsp; &nbsp;uint public amountRaised; // 割到多少韭菜 &nbsp; &nbsp;uint public deadline; // 割到啥时候 &nbsp; &nbsp;/** &nbsp; &nbsp;* 卖多贵，即你的 token 与以太坊的汇率，你可以自己设定 &nbsp; &nbsp;* 注意到，ICO 当中 token 的价格是由合约发布方自行设定而不是市场决定的 &nbsp; &nbsp;* 也就是说你项目值多少钱你可以自己编 &nbsp; &nbsp;**/ &nbsp; &nbsp;uint public price; &nbsp; &nbsp;token public tokenReward; // 你要卖的 token &nbsp; &nbsp;mapping(address =&gt; uint256) public balanceOf; &nbsp; &nbsp;bool fundingGoalReached = false; // 是否达标 &nbsp; &nbsp;bool crowdsaleClosed = false; // 售卖是否结束 &nbsp; &nbsp;/** &nbsp; &nbsp;* 事件可以用来记录信息，每次调用事件方法时都能将相关信息存入区块链中 &nbsp; &nbsp;* 可以用作凭证，也可以在你的 Dapp 中查询使用这些数据 &nbsp; &nbsp;**/ &nbsp; &nbsp;event GoalReached(address recipient, uint totalAmountRaised); &nbsp; &nbsp;event FundTransfer(address backer, uint amount, bool isContribution); &nbsp; &nbsp;/** &nbsp; &nbsp; * Constrctor function &nbsp; &nbsp; * &nbsp; &nbsp; * Setup the owner &nbsp; &nbsp; */ &nbsp; &nbsp;function Crowdsale( &nbsp; &nbsp; &nbsp; &nbsp;address ifSuccessfulSendTo, &nbsp; &nbsp; &nbsp; &nbsp;uint fundingGoalInEthers, &nbsp; &nbsp; &nbsp; &nbsp;uint durationInMinutes, &nbsp; &nbsp; &nbsp; &nbsp;uint etherCostOfEachToken, &nbsp; &nbsp; &nbsp; &nbsp;address addressOfTokenUsedAsReward &nbsp; &nbsp;) { &nbsp; &nbsp; &nbsp; &nbsp;beneficiary = ifSuccessfulSendTo; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoal = fundingGoalInEthers * 1 ether; &nbsp; &nbsp; &nbsp; &nbsp;deadline = now + durationInMinutes * 1 minutes; &nbsp; &nbsp; &nbsp; &nbsp;price = etherCostOfEachToken * 1 ether; &nbsp; &nbsp; &nbsp; &nbsp;tokenReward = token(addressOfTokenUsedAsReward); // 传入已发布的 token 合约的地址来创建实例 &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Fallback function &nbsp; &nbsp; * &nbsp; &nbsp; * payable 用来指明向合约付款时调用的方法 &nbsp; &nbsp; */ &nbsp; &nbsp;function () payable { &nbsp; &nbsp; &nbsp; &nbsp;require(!crowdsaleClosed); &nbsp; &nbsp; &nbsp; &nbsp;uint amount = msg.value; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] += amount; &nbsp; &nbsp; &nbsp; &nbsp;amountRaised += amount; &nbsp; &nbsp; &nbsp; &nbsp;tokenReward.transfer(msg.sender, amount / price); &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(msg.sender, amount, true); &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp;* modifier 可以理解为其他语言中的装饰器或中间件 &nbsp; &nbsp;* 当通过其中定义的一些逻辑判断通过之后才会继续执行该方法 &nbsp; &nbsp;* _ 表示继续执行之后的代码 &nbsp; &nbsp;**/ &nbsp; &nbsp;modifier afterDeadline() { if (now &gt;= deadline) _; } &nbsp; &nbsp;/** &nbsp; &nbsp; * Check if goal was reached &nbsp; &nbsp; * &nbsp; &nbsp; * Checks if the goal or time limit has been reached and ends the campaign &nbsp; &nbsp; */ &nbsp; &nbsp;function checkGoalReached() afterDeadline { &nbsp; &nbsp; &nbsp; &nbsp;if (amountRaised &gt;= fundingGoal){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoalReached = true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GoalReached(beneficiary, amountRaised); &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;crowdsaleClosed = true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Withdraw the funds &nbsp; &nbsp; * &nbsp; &nbsp; * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached, &nbsp; &nbsp; * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw &nbsp; &nbsp; * the amount they contributed. &nbsp; &nbsp; */ &nbsp; &nbsp;function safeWithdrawal() afterDeadline { &nbsp; &nbsp; &nbsp; &nbsp;if (!fundingGoalReached) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint amount = balanceOf[msg.sender]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (amount &gt; 0) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (msg.sender.send(amount)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(msg.sender, amount, false); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = amount; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;if (fundingGoalReached &amp;&amp; beneficiary == msg.sender) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (beneficiary.send(amountRaised)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(beneficiary, amountRaised, false); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//If we fail to send the funds to beneficiary, unlock funders balance &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoalReached = false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;} } 至此我们的 ICO 合约也开发完毕了，基本上一行代码都没有写，只是改了几个参数，一个键盘上只有三个按键的程序员都能够完成这类智能合约的开发，没有比这更友好的编程体验了。 虽然 solidity 是一种非图灵完备的编程语言，但我们仍然能够用它编写许多逻辑。 上述的 ICO 示例代码写得算比较客气的一种，在最后的提款方法中，如果筹资达标，ICO 发布方则可以取走所有筹款，而如果未达标，参与者则能够取回自己的投资，由合约来持有所有款项。 但事实上，我们仍然可以随意修改其中的逻辑，看下面代码。 function () payable { &nbsp;require(!crowdsaleClosed); &nbsp;uint amount = msg.value; &nbsp;balanceOf[msg.sender] += amount; &nbsp;amountRaised += amount; &nbsp;tokenReward.transfer(msg.sender, amount / price); &nbsp;// 每次有人付款直接取走筹资 &nbsp;beneficiary.send(amountRaised); &nbsp;amountRaised = 0; &nbsp;FundTransfer(msg.sender, amount, true); }// 删除剩余代码 补充说明与权限控制 既然咱是铁了心来割韭菜的，如此简单的代码怎么能够满足咱的贪欲呢？一定要学比特币固定供给量吗？ 我是来卖 token 的呀，万一有一天卖完了怎么办，万一有人手里筹码比我自己都多了控盘怎么办，万一发的数量太多卖的不好怎么办？ 事实上解决这些问题的逻辑全部都可以写在智能合约里。 Ownable token 在我们的潜在观念里，区块链自有不可变属性。 这种不可变属性在一些狂热信徒的演绎当中变成了平权属性，甚至带有了共产主义色彩，仿佛拥抱区块链技术就能够为未来的人类文明带来希望，把人民从集权的手中解救出来。 然而事实上这种不可变性同样是两面的，它能够带来的也包括所有权的不可变性。 ERC20 标准只规定了我们的合约中应该包含哪些方法，而没有限制合约中不能出现哪些方法，因此在之前的基础上，我们还可以继续编写一些特殊的方法，赋予合约发布者一些管理员特权。 请看下面代码： contract Ownable { &nbsp; &nbsp;address public owner; &nbsp; &nbsp;function Ownable() public { &nbsp; &nbsp; &nbsp; &nbsp;owner = msg.sender; &nbsp; &nbsp;} &nbsp; &nbsp;// 通过 onlyOwner 我们可以限定一些方法只有所有者才能够调用 &nbsp; &nbsp;modifier onlyOwner { &nbsp; &nbsp; &nbsp; &nbsp;require(msg.sender == owner); &nbsp; &nbsp; &nbsp; &nbsp;_; &nbsp; &nbsp;} &nbsp; &nbsp;function transferOwnership(address newOwner) onlyOwner public { &nbsp; &nbsp; &nbsp; &nbsp;owner = newOwner; &nbsp; &nbsp;} }// 合约可以同时有多个继承contract GitToken is StandardToken, Ownable { &nbsp;... MintableToken 接下来我们来解决 token 不够卖的问题，万一我的 initial offer 卖断货了怎么办，万一我卖完一次还想卖怎么办？ 这时我们就需要把 token 编写成为 MintableToken，在我们想增发的时候就能增发，代码如下： // 用 onlyOwner 限定只有 token 的所有者才能够进行增发操作function mint(address _to, uint256 _amount) onlyOwner public returns (bool) { &nbsp;totalSupply_ = totalSupply_.add(_amount); &nbsp;balances[_to] = balances[_to].add(_amount); &nbsp;Mint(_to, _amount); &nbsp;Transfer(address(0), _to, _amount); &nbsp;return true; } BurnableToken 万一我们的 token 不小心发了太多，卖的时间久了贬值怎么办？ 当然是销毁了，可参照下面代码： /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */function burn(uint256 _value) public returns (bool success) { &nbsp;require(balanceOf[msg.sender] &gt;= _value); &nbsp; // Check if the sender has enough &nbsp;balanceOf[msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Subtract from the sender &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Updates totalSupply &nbsp;Burn(msg.sender, _value); &nbsp;return true; } 万一有人手里的筹码太多，或者 token 被竞争对手买走了怎么办？没关系，我们还可以指定销毁某一账户中的 token，请看下面代码： /** &nbsp;* Destroy tokens from other account &nbsp;* &nbsp;* Remove `_value` tokens from the system irreversibly on behalf of `_from`. &nbsp;* &nbsp;* @param _from the address of the sender &nbsp;* @param _value the amount of money to burn &nbsp;*/function burnFrom(address _from, uint256 _value) public returns (bool success) { &nbsp;require(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Check if the targeted balance is enough &nbsp;require(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp;// Check allowance &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the targeted balance &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the sender&#39;s allowance &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Update totalSupply &nbsp;Burn(_from, _value); &nbsp;return true; } 只要上述的方法全部都出现在合约里，我们发布的 token 就能够具备上述所有属性。 这样一来，不够的时候我们可以发钱，发多了可以销毁，我们成功创建了属于自己的一所中央银行，甚至看某人不爽还能够指定销毁其账户存款，这哪里是平权，简直是超级集权。 而事实上，在已发布的 ERC20 token 当中，例如排名第一的 EOS 的合约&nbsp;(https://goo.gl/L2AmQP)&nbsp;里也是存在类似方法的，如下所示。 function mint(uint128 wad) auth stoppable note { &nbsp;_balances[msg.sender] = add(_balances[msg.sender], wad); &nbsp;_supply = add(_supply, wad); }function burn(uint128 wad) auth stoppable note { &nbsp;_balances[msg.sender] = sub(_balances[msg.sender], wad); &nbsp;_supply = sub(_supply, wad); } 当然在其官方网站和白皮书中是标明了会发布多少 token，创始团队持有多少，投资人分配多少，公开发布多少，如何销毁等内容的。 但白皮书又不具备法律效力，token 的所有权也不在你手里，万一人家哪天想要跑路或者中途变卦岂是咱能拦得住的。 换个角度讲，假如你现在手里有一家可以印钱的公司，印多少就有多少，你印还是不印？ 通过这一部分内容的介绍，我只是想要证明，智能合约本身并不具备可无条件信任的特性，充其量就是一段没法改一直跑的程序而已。 你也可以在逻辑中加入管理员权限，token 的发布方并不比央行可信多少，只要所有者愿意可以随时进行修改。以太坊官方宣传的所谓 “trustless” 这一概念根本不成立。 没有第三方担保，没有法律法规的维护，仅凭智能合约本身你的投资得不到任何保证。智能合约的不可变性反而给割韭菜的一方提供了巨大的便利。 从前你看不惯某家公司还能够黑掉它的系统，获取管理员权限，如今所有程序都跑在区块链上，黑无可黑，集权永远都在合约发布者的手里。 讲到这里，希望你能理解这次分享的良苦用心，不要轻信任何 ICO 项目。 合约的发布及调试 本地开发环境发布 合约开发完成之后，我们需要编译并发布合约至区块链网络中，只需要进行以下两步操作。 首先在&nbsp;migrations&nbsp;文件夹下新建&nbsp;2-deploy-contract.js&nbsp;文件，配置部署脚本如下。 // 引入我们编写的合约const GitCoin = artifacts.require(&quot;./GitCoin.sol&quot;)const GitCoinCrowdsale = artifacts.require(&quot;./GitCoinCrowdsale.sol&quot;)module.exports = function(deployer, network, accounts) { &nbsp;// 设定参数，此处的参数即使传入合约构造方法的参数，与你自己编写的合约保持一致 &nbsp;const ifSuccessfulSendTo = accounts[0] // 当前以太坊网络中的默认账户 &nbsp;const fundingGoalInEthers = 1000 &nbsp;const durationInMinutes = 36000000 &nbsp;const etherCostOfEachToken = 0.01 &nbsp;// 这里的 Promise 可以保证我们在发布完 token 合约之后再发布 ICO 合约，并将已发布 token 的地址作为参数传入 &nbsp;deployer.deploy(GitCoin).then(function() { &nbsp; &nbsp;return deployer.deploy(GitCoinCrowdsale, ifSuccessfulSendTo, fundingGoalInEthers, durationInMinutes, etherCostOfEachToken, GitCoin.address); &nbsp;}); }; 接着在&nbsp;truffle-config.js&nbsp;或&nbsp;truffle.js&nbsp;中设置发布网络，脚本如下。 module.exports = { &nbsp;networks: { &nbsp; &nbsp;development: { &nbsp; &nbsp; &nbsp;host: &quot;127.0.0.1&quot;, &nbsp; &nbsp; &nbsp;port: 7545, // 与你本地的 ganache 设置保持一致 &nbsp; &nbsp; &nbsp;network_id: &quot;*&quot; // Match any network id &nbsp; &nbsp;} &nbsp;} }; 现在只需要开启 Ganache： 然后在命令行中输入： truffle compile truffle migrate 你的合约就会顺利发布至测试网络中了。然后你可以输入： truffle console 这样就能够进入本地的命令行调试了： # 所有的合约方法都是 Promise 对象truffle(development)&gt; GitCoinCrowdsale.deployed().then(inst=&gt;{crowd=inst}) truffle(development)&gt; GitCoin.deployed().then(inst=&gt;{git=inst}) truffle(development)&gt; crowd.sendTransaction({from:web3.eth.accounts[0],value:web3.toWei(1, &quot;ether&quot;)}) truffle(development)&gt; git.mint(web3.eth.accounts[0],web3.toWei(100, &quot;ether&quot;)) 线上测试网络发布 以太坊网络分为测试网和主网，在正式发布主网之前，我们可以先发送到测试网络进行调试。 发布至以太坊网络也无需同步完整节点，我们可以使用 Infura 为我们提供的公共接口。 填写表单提交后，Infura 会为你提供专用的接口地址，然后我们只需要将网络地址填入到配置文件中，如下所示。 var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;); // 在这里我们需要通过 js 调用以太坊钱包，通过 npm install truffle-hdwallet-provider 安装这个库var infura_apikey = &quot;ubQWERwasd&quot;; // infura 为你提供的 apikey 请与你申请到的 key 保持一致，此处仅为示例var mnemonic = &quot;apple banana carray dog egg fault great&quot;; // 你以太坊钱包的 mnemonic ，可以从 Metamask 当中导出，mnemonic 可以获取你钱包的所有访问权限，请妥善保存，在开发中切勿提交到 gitmodule.exports = { &nbsp;networks: { &nbsp; &nbsp;development: { &nbsp; &nbsp; &nbsp;host: &quot;127.0.0.1&quot;, &nbsp; &nbsp; &nbsp;port: 7545, &nbsp; &nbsp; &nbsp;network_id: &quot;*&quot; &nbsp; &nbsp;}, &nbsp; &nbsp;ropsten: { &nbsp; &nbsp; &nbsp;provider: function() { &nbsp; &nbsp; &nbsp; &nbsp;return new HDWalletProvider(mnemonic, &quot;https://ropsten.infura.io/&quot;+infura_apikey) &nbsp; &nbsp; &nbsp;}, &nbsp; &nbsp; &nbsp;network_id: 3, &nbsp; &nbsp; &nbsp;gas: 3012388, &nbsp; &nbsp; &nbsp;gasPrice: 30000000000 &nbsp; &nbsp;}, &nbsp; &nbsp;main: { &nbsp; &nbsp; &nbsp;provider: function() { &nbsp; &nbsp; &nbsp; &nbsp;return new HDWalletProvider(mnemonic, &quot;https://mainnet.infura.io/&quot;+infura_apikey) &nbsp; &nbsp; &nbsp;}, &nbsp; &nbsp; &nbsp;network_id: 3, &nbsp; &nbsp; &nbsp;gas: 3012388, &nbsp; &nbsp; &nbsp;gasPrice: 1000000000 &nbsp; &nbsp;} &nbsp;} }; 在以太坊网络中发布合约需要使用 ETH 支付矿工的 gas 费用，你可以在 Ethereum Ropsten Faucet&nbsp;(http://faucet.ropsten.be:3001)&nbsp;免费获取到用于 Ropsten 测试网络的 ETH。 由于网络环境的变化，不同的拥堵状况可能造成燃料费用和消耗的不同。 如果发布不成功，可以调整&nbsp;gas/gasPrice&nbsp;的数值，你可以通过&nbsp;web3.getBlock(&#39;latest&#39;).gasLimit&nbsp;这一数值判断当前网络的消耗。 在命令行输入如下命令： truffle migrate --network ropsten 通过&nbsp;--network&nbsp;设置发布的目标网络。 主网络发布 同理，在发布至主网络时，只需要执行如下命令。 truffle migrate --network main 但由于当前的以太坊网络的现实状况，如果设置燃料费太低，可能要等待数天后合约才会被网络确认，注意到我们编写的发布脚本是需要合约地址回调的。 介于这种状况，我们可以将 token 合约和 crowdsale 合约分开发布，只需要再新建&nbsp;3-deploy-crowdsale.js&nbsp;文件，脚本如下。 const LeekCoinCrowdsale = artifacts.require(&quot;./GitCoinCrowdsale.sol&quot;)module.exports = function(deployer, network, accounts) { &nbsp;const ifSuccessfulSendTo = accounts[0] &nbsp;const fundingGoalInEthers = 1000 &nbsp;const durationInMinutes = 36000 &nbsp;const etherCostOfEachToken = 0.01 &nbsp;const tokenAddress = &#39;0x123456789ABCDFGHSDWDVC&#39; // 先单独发布 token 合约，上线成功后将其合约地址填在此处 &nbsp;deployer.deploy(GitCoinCrowdsale, ifSuccessfulSendTo, fundingGoalInEthers, durationInMinutes, etherCostOfEachToken, tokenAddress); }; 在发布至主网络时，可以分开两次进行，确保你设置的账户里有真实的 ETH 余额，注意设置好合理的 gas 数值，根据确认时间的长短，可能需要 0.08~1 ETH 不等。 上线合约验证 无论是发布至以太坊的测试网络还是主网络，在发布完成之后都需要在 Etherscan&nbsp;(https://etherscan.io)&nbsp;进行线上验证。 在 Etherscan 上打开你刚刚发布的合约地址，你可以看到如下内容： 点击&nbsp;Verify And Publish&nbsp;链接就可以进入验证页面： 在填写表单时有以下注意事项。 Compiler 选择最新版本； Optimization 选择 No。 虽然 solidity 支持 import 语法，但 Etherscan 对使用 import 进行开发的合约支持很鸡肋，目前它要求你需要把库文件也当作合约发布至网络才能够在表单中填写进行验证。 当然我们也可以选择手动把 import 库文件的内容手动复制粘贴到代码框里，注意要保留全部内容，包括 pragma 声明一行。 当然你也可以选择使用官方的 Remix&nbsp;(https://remix.ethereum.org/)&nbsp;预先 concrete 你的合约文件，也可以安装 solidity compiler&nbsp;(https://goo.gl/aKsXxH)&nbsp;在本地编译好再发布。 ICO 和 token 的合约如此简单，根本不需要这些玩意儿，所以此处不再赘述，感兴趣的同学可以自行研究。 Dapp 开发 智能合约相当于我们的后端逻辑，以太坊的 EVM 就是我们的云服务器，Infura 为我们提供 API 接口，接下来我们就只需要给韭菜开发一个可以花钱消费的前端界面了。 ICO 项目的网站把握以下几个原则就好。 文字不要太多，页面要大片留白，简洁明了有现代感； 配色一定要深，加上动态几何图形，设计要有未来感； 开发团队全配齐，不是常春藤，没有硅谷背景的不要，一定要国际化； 各种站台大佬，海量媒体报道，一线互联网公司合作全放上去。 言归正传，我们还是专注于技术。 web3.js 的使用 web3.js&nbsp;(https://github.com/ethereum/web3.js)&nbsp;为我们提供了一系列访问以太坊网络的 JavaScript 编程接口，完整的说明文档可以在 web3.js Doc&nbsp;(https://goo.gl/zp2yEQ)&nbsp;中参阅。 我们一般通过如下脚本来初始化 web3 对象。 // 判断当前浏览器中有未注入 web3 对象if (typeof web3 !== &#39;undefined&#39;) { &nbsp;App.web3Provider = web3.currentProvider; &nbsp;web3 = new Web3(web3.currentProvider); } else { &nbsp;// 注意设置到你自己的 infura 地址 &nbsp;App.web3Provider = new Web3.providers.HttpProvider(&#39;https://ropsten.infura.io/ubQWERawsd&#39;); &nbsp;web3 = new Web3(App.web3Provider); } Metamask 简介 Metamask&nbsp;(https://metamask.io)&nbsp;是一个浏览器插件，通过 Metamask 我们可以在浏览器中使用以太坊钱包，在访问 Dapp 应用时，也可以为其注入 web3 对象。 具体配合应用开发的文档可以在 MetaMask Compatibility Guide&nbsp;(https://goo.gl/7wKPtp)&nbsp;查阅，一般我们通过如下脚本来监测 Metamask 状态获取以太坊账户。 var account = web3.eth.accounts[0];var accountInterval = setInterval(function() { &nbsp;if (web3.eth.accounts[0] !== account) { &nbsp; &nbsp;account = web3.eth.accounts[0]; &nbsp; &nbsp;updateInterface(); &nbsp;} }, 100); truffle-contract 的使用 web3.js 默认为我们提供的接口还是太底层，许多调用需要 hard code 设置参数，以太坊网络使用的 BigNumber 也需要我们手动转换。 我们可以选择使用 truffle-contract&nbsp;(https://github.com/trufflesuite/truffle-contract)&nbsp;来调用更高一层的封装对象，并且在之前使用 truffle 开发构建的智能合约文件也能派上用场。 我们可以在&nbsp;build/contracts/&nbsp;下找到编译好的&nbsp;GitCoin.json&nbsp;和&nbsp;GitCoinCrowdsale.json&nbsp;文件，之后可以在我们的应用中通过如下脚本获取合约对象。 &lt;script type=&quot;text/javascript&quot; src=&quot;./dist/truffle-contract.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var GitCoin; $.getJSON(&#39;contracts/GitCoin.json&#39;, function(data) { &nbsp;// 获取编译好的合约文件 &nbsp;var GitCoinArtifact = data; &nbsp;// 通过 truffle-contract 获取合约对象 &nbsp;GitCoin = TruffleContract(GitCoinArtifact); &nbsp;// 将合约绑定至当前 web3 对象 &nbsp;GitCoin.setProvider(App.web3Provider); });&lt;/script&gt; 之后我们就可以像在&nbsp;truffle console&nbsp;当中一样，对合约对象进行各种操作啦。 ICO 前端应用开发 我们的 ICO 应用只需要解决一个核心需求，那就是买币；只需要两个核心功能，一个是选择买多少，另一个就是付款，所以我们的界面自然是相当简单，如下图所示。 然后再稍微美化一下，如下面两张图所示。 一场成功的 ICO，自然需要精雕细琢，完整的代码示例可以在 Leek Ecological Chain&nbsp;(http://lec.yubolun.com/)&nbsp;找到，同时此网站也是上述教程的一个完整示例，你可以切换到 Ropsten 网络在本网站上购买 LEC&nbsp;(https://goo.gl/4uNskB)&nbsp;韭菜币。 Dapp 部署 既然我们开发的是 Dapp 去中心化应用，怎么能够部署在中心化的服务器上呢？这不是自掉身价吗？Dapp 自然有其部署的解决方案。 IPFS 简介 IPFS 提供去中心化的点对点的 Web 服务。 说简单点，你可以把它理解成为一个 p2p 的网盘，你网站的静态文件可以发布到 IPFS 上面托管，而且只要 IPFS 的节点不挂，你的网站就永远都不会挂，而不像部署到单独服务器上。 同时 IPFS 上的一个文件也就对应着一个 hash 地址，普通用户可以通过公共的 http gateway 访问到你的页面，不像云服务器还要备案，正好也方便你割完韭菜跑路。 使用也非常简单，只需要在 Install Go IPFS&nbsp;(https://ipfs.io/docs/install)&nbsp;下载安装。 发布应用 只需要一行命令，把你 Dapp 的所有静态文件上传至 IPFS，命令如下。 ipfs add -r your-ico/# 返回 hash 地址，此处仅为示例added QWERabcd1234qwerABCD your-ico/ 然后你就能够通过 https://goo.gl/5SyBwN 访问你的网站。当然这样的域名十分不友好，为 IPFS 站点设置解析需要一些不常用的操作。 域名解析 IPNS 你的站点必然包含多个文件，每个文件对应着独立的 hash 地址，而且你也不能保证你的网站只需要发布一次。 因此在网站发布后，我们需要使用 ipns 来获取到对应的唯一地址，之后的 DNS 解析也会对应到这一地址，同样只需要一行命令，如下所示。 # 站点发布后的 hash 地址，此处仅为示例ipfs name publish QWERabcd1234qwerABCD# 返回 ipns 地址Published to ABCDqwer1234abcdQWER 之后你就能够通过 https://goo.gl/8YMLBi 访问你的站点了。在设置域名解析时，我们需要添加一条&nbsp;TXT&nbsp;类型的解析记录，解析值为： dnslink=/ipns/ABCDqwer1234abcdQWER 这样我们就能够通过 https://goo.gl/VjSm1K 访问你的 Dapp，这样是不是友好多了？ Nginx 反向代理 当然你也可能希望使用自己的独立域名，这时我们只需要使用 Nginx 设置反向代理即可。 server { &nbsp;listen 80; &nbsp;server_name yourico.com; &nbsp;location / { &nbsp; &nbsp;proxy_pass https://ipfs.io/ipns/yourico.com/; &nbsp;} } 写在后面 以太坊官网，第一篇教程教你发 token，第二篇就教你卖 token，居心何在我也不好评判。 除了 ICO 还有 IMO/IFO ，IMO 你只用卖个路由器，IFO 只需要 fork 一份 Bitcoin 的代码，稍微调调参数，就不需要什么教程了。 程序员总是妄图通过技术手段解决社会问题，然而人性是不变的。以太坊希望建立一个 trustless 的网络，可惜被无数人滥用，巧立空气项目，搞空壳公司，逃避监管搞非法集资。 区块链和虚拟货币期望用点对点分布式的网络，脱离第三方，让世界上任何角落的两个人都能够低成本地进行交易，结果大量投机者涌入，导致网络堵塞，如今我们连一笔交易的矿工费都支付不起。 当然我信奉技术本身是无罪，就好像这篇教你割韭菜的文章一样，你是选择擦亮双眼，看清 ICO 的本质，从此势不两立；还是选择投机倒把，滥用以太坊技术，坠身同流合污？ 您可以在访问 https://github.com/discountry/gitcoin 查看完整的智能合约示例。 您可以访问 https://github.com/discountry/lec 查看完整的 Dapp 示例。 Read at your own risk. 近期热文 《它的暴利，已经完全超过了某些犯罪收入》 《Java 语法糖详解》 《程序员跳槽时，如何高效地准备面试？》 《机器学习数据预处理方法与技巧系统讲解》 《中小型企业基于大数据技术的项目实践》 《GitChat 被恶意攻击引发的技术性思考：拒绝服务攻击》 「阅读原文」看交流实录，你想知道的都在这里 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本文来自作者&nbsp;余博伦&nbsp;在&nbsp;GitChat&nbsp;上分享 「韭菜种植与收割：发布你自己的 ICO」，「阅读原文」查看交流实录。 「文末高能」 编辑 | 哈比 你可曾想梭哈全部存款，参与 ICO，一夜身价暴涨千倍，获得财富自由，从此走上人生巅峰？ ICO 是借用 IPO 生造出来的一种概念，同样具有非常相似的募资机制，但 IPO 有着严格的上市流程、政策监管，如下图所示。 即便如此，参与 IPO 仍然有着相当大的风险，且为股市带来了相当大的不稳定因素。而与 ICO 比起来简直就是小巫见大巫了。 一家公司想要进行 IPO 起码要达到能够上市的标准，而想发布 ICO 你只要有一个好听的 idea 就足够了。并且严重缺乏监管，虽然各国政府都在不断发出声明，但截至本分享写作前，也没有正式出台比较明朗的有关规定。 这也导致无数的空气项目披着虚拟货币和区块链的高科技壳，到处招摇撞骗割韭菜，有过之无不及的还搞什么 AI+ 区块链，IOT+ 区块链，技术名词堆积越多的项目，死得往往越快。 甚至一些有头有脸的大公司，也忍不住打打擦边球，收割一波，炒作炒作，股价就能翻几个涨停。 可就像马老爷子说的： 如果有 10% 的利润，它就保证到处被使用；有 20% 的利润，它就活跃起来；有 50% 的利润，它就铤而走险；为了 100% 的利润，它就敢践踏一切人间法律；有 300% 的利润，它就敢犯任何罪行，甚至绞首的危险。 即便如此，仍然有很多人跃跃欲试不信邪。这一场 Chat 就手把手教你为 ICO 做好所有技术面上的准备。在和大家一起点亮新技能的同时，也揭一揭所谓 ICO 的老底。 内容概要 目前市场上 99% 的项目 ICO 都是基于以太坊（Ethereum）智能合约（Smart Contracts）技术发布的 token（ERC20 Token）。 本次分享也是基于这一套技术栈，介绍内容包括以下几个方面。 本地开发环境构建 以太坊智能合约开发 本地开发环境发布 线上测试网络发布 主网络发布 ERC20 Token 合约开发 ICO Crowdsale 合约开发 补充说明与权限控制 合约的发布及调试 Dapp 开发 web3.js 的使用 Metamask 简介 truffle-contract 的使用 ICO 前端应用开发 Dapp 部署 IPNS Nginx 反向代理 IPFS 简介 发布应用 域名解析 使用到的技术栈包括： Truffle：http://truffleframework.com [Ganache：http://truffleframework.com/ganache Metamask：https://metamask.io Solidity：http://solidity.readthedocs.io/en/develop openzeppelin：https://openzeppelin.org Infura：https://infura.io web3.js：https://web3js.readthedocs.io/en/1.0/index.html truffle-contract：https://github.com/trufflesuite/truffle-contract ipfs：https://ipfs.io 对读者的基本要求有： 了解编程 会 JavaScript 本地开发环境构建 以太坊官方提供的 Mist&nbsp;(https://github.com/ethereum/mist/releases)&nbsp;和 Ethereum-Wallet&nbsp;(https://github.com/ethereum/mist/releases)。 其中 Mist 是一个可以用来访问 Dapp 的浏览器，Ethereum-Wallet 是 Mist 的一个独立发布版本，也算是浏览器，但只能用来访问以太坊钱包这个应用。 在网络同步过程中或多或少都会遇到问题，而且目前网络拥堵，完整节点过大，同步完成相当困难。但事实上我们进行以太坊开发时并不需要同步完整的节点，也可以选择使用相应的模拟开发环境。 Truffle&nbsp;(http://truffleframework.com)&nbsp;框架为你提供本地进行智能合约开发的所有依赖支持，使你可以在本地进行智能合约及 Dapp 的开发、编译、发布。安装非常简单，只需要： npm install -g truffle Ganache&nbsp;(http://truffleframework.com/ganache)&nbsp;也是 Truffle 框架中提供的一个应用，可以在你的本地开启模拟一个以太坊节点，让你能够将开发好的智能合约发布至本地测试节点中运行调试。 安装也非常简单，官网下载即可，双击打开运行。 不过这里有一个隐藏的坑，如果你使用的是 Windows 系统的话，Ganache 提供的是后缀名为&nbsp;.appx&nbsp;的 Windows 应用商店版安装包。你需要打开 Windows 设置 -&gt; 系统 -&gt; 针对开发人员 -&gt; 选择 “旁加载应用” 这个选项。 确认之后就可以双击&nbsp;Ganache.appx&nbsp;进行安装了，假如系统仍然无法识别这一后缀名，你可以手动打开&nbsp;powershell&nbsp;输入如下命令进行安装。 Add-AppxPackage .\\Ganache.appx 至此本地开发智能合约及 Dapp 的环境就算安装完成了，Truffle 官方提供了许多示例教程以及应用脚手架（truffle box），其中就包括教你开发以太坊宠物商&nbsp;(http://truffleframework.com/tutorials/pet-shop)&nbsp;的教程等内容。 在此不再赘述，感兴趣的同学自己动手可以试试。 以太坊智能合约开发 首先使用 Truffle 初始化我们的项目，命令如下。 mkdir my-icocd my-ico npm init -y truffle init 脚本运行完成之后 Truffle 会自动为我们的项目创建一系列文件夹和文件，如下图所示。 这里有一个隐藏的坑，如果你使用 Windows 命令行的话，需要删掉&nbsp;truffle.js&nbsp;文件，否则在项目目录执行 truffle 相关命令时，CMD 会混淆&nbsp;truffle&nbsp;与&nbsp;truffle.js&nbsp;文件。 因此，你应该将配置写在&nbsp;truffle-config.js&nbsp;文件当中。 ERC20 Token 合约开发 现在我们的项目目录大概是这个样子： contracts/ Migrations.sol migrations/ 1_initial_migration.js test/ package.json truffle-config.js 或 truffle.js 我们在编写智能合约时，需要在&nbsp;contracts&nbsp;目录下新建相应的智能合约文件。 在以太坊开发智能合约的编程语言叫做 Solidity&nbsp;(https://goo.gl/hCHh3w)。它是一种在语法上非常类似 JavaScript 的语言，其后缀名为&nbsp;.sol&nbsp;。 例如在这里我们可以创建一个名为&nbsp;GitCoin.sol&nbsp;的文件，命令如下。 // *nix touch GitCoin.sol // win copy NUL &gt; GitCoin.sol ERC20（Ethereum Request for Comments NO.20）(https://goo.gl/aX4x5F)&nbsp;是官方发行的 token 标准。 如果你希望你发布的 token 能够在以太坊网络上流通、上市交易所、支持以太坊钱包，在开发 token 的合约时就必须遵从这一规范。 ERC20 规定了合约中的一系列变量、方法、事件，你可以参考官网教程 Create your own CRYPTO-CURRENCY with Ethereum&nbsp;(https://www.ethereum.org/token)&nbsp;当中的示例代码： pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }contract TokenERC20 { &nbsp; &nbsp;// Public variables of the token &nbsp; &nbsp;string public name; &nbsp; &nbsp;string public symbol; &nbsp; &nbsp;uint8 public decimals = 18; &nbsp; &nbsp;// 18 decimals is the strongly suggested default, avoid changing it &nbsp; &nbsp;uint256 public totalSupply; &nbsp; &nbsp;// This creates an array with all balances &nbsp; &nbsp;mapping (address =&gt; uint256) public balanceOf; &nbsp; &nbsp;mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; &nbsp; &nbsp;// This generates a public event on the blockchain that will notify clients &nbsp; &nbsp;event Transfer(address indexed from, address indexed to, uint256 value); &nbsp; &nbsp;// This notifies clients about the amount burnt &nbsp; &nbsp;event Burn(address indexed from, uint256 value); &nbsp; &nbsp;/** &nbsp; &nbsp; * Constrctor function &nbsp; &nbsp; * &nbsp; &nbsp; * Initializes contract with initial supply tokens to the creator of the contract &nbsp; &nbsp; */ &nbsp; &nbsp;function TokenERC20( &nbsp; &nbsp; &nbsp; &nbsp;uint256 initialSupply, &nbsp; &nbsp; &nbsp; &nbsp;string tokenName, &nbsp; &nbsp; &nbsp; &nbsp;string tokenSymbol &nbsp; &nbsp;) public { &nbsp; &nbsp; &nbsp; &nbsp;totalSupply = initialSupply * 10 ** uint256(decimals); &nbsp;// Update total supply with the decimal amount &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = totalSupply; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Give the creator all initial tokens &nbsp; &nbsp; &nbsp; &nbsp;name = tokenName; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Set the name for display purposes &nbsp; &nbsp; &nbsp; &nbsp;symbol = tokenSymbol; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Set the symbol for display purposes &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Internal transfer, only can be called by this contract &nbsp; &nbsp; */ &nbsp; &nbsp;function _transfer(address _from, address _to, uint _value) internal { &nbsp; &nbsp; &nbsp; &nbsp;// Prevent transfer to 0x0 address. Use burn() instead &nbsp; &nbsp; &nbsp; &nbsp;require(_to != 0x0); &nbsp; &nbsp; &nbsp; &nbsp;// Check if the sender has enough &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp;// Check for overflows &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[_to] + _value &gt; balanceOf[_to]); &nbsp; &nbsp; &nbsp; &nbsp;// Save this for an assertion in the future &nbsp; &nbsp; &nbsp; &nbsp;uint previousBalances = balanceOf[_from] + balanceOf[_to]; &nbsp; &nbsp; &nbsp; &nbsp;// Subtract from the sender &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp;// Add the same to the recipient &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_to] += _value; &nbsp; &nbsp; &nbsp; &nbsp;Transfer(_from, _to, _value); &nbsp; &nbsp; &nbsp; &nbsp;// Asserts are used to use static analysis to find bugs in your code. They should never fail &nbsp; &nbsp; &nbsp; &nbsp;assert(balanceOf[_from] + balanceOf[_to] == previousBalances); &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Transfer tokens &nbsp; &nbsp; * &nbsp; &nbsp; * Send `_value` tokens to `_to` from your account &nbsp; &nbsp; * &nbsp; &nbsp; * @param _to The address of the recipient &nbsp; &nbsp; * @param _value the amount to send &nbsp; &nbsp; */ &nbsp; &nbsp;function transfer(address _to, uint256 _value) public { &nbsp; &nbsp; &nbsp; &nbsp;_transfer(msg.sender, _to, _value); &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Transfer tokens from other address &nbsp; &nbsp; * &nbsp; &nbsp; * Send `_value` tokens to `_to` on behalf of `_from` &nbsp; &nbsp; * &nbsp; &nbsp; * @param _from The address of the sender &nbsp; &nbsp; * @param _to The address of the recipient &nbsp; &nbsp; * @param _value the amount to send &nbsp; &nbsp; */ &nbsp; &nbsp;function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;require(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp; // Check allowance &nbsp; &nbsp; &nbsp; &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp;_transfer(_from, _to, _value); &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Set allowance for other address &nbsp; &nbsp; * &nbsp; &nbsp; * Allows `_spender` to spend no more than `_value` tokens on your behalf &nbsp; &nbsp; * &nbsp; &nbsp; * @param _spender The address authorized to spend &nbsp; &nbsp; * @param _value the max amount they can spend &nbsp; &nbsp; */ &nbsp; &nbsp;function approve(address _spender, uint256 _value) public &nbsp; &nbsp; &nbsp; &nbsp;returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;allowance[msg.sender][_spender] = _value; &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Set allowance for other address and notify &nbsp; &nbsp; * &nbsp; &nbsp; * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it &nbsp; &nbsp; * &nbsp; &nbsp; * @param _spender The address authorized to spend &nbsp; &nbsp; * @param _value the max amount they can spend &nbsp; &nbsp; * @param _extraData some extra information to send to the approved contract &nbsp; &nbsp; */ &nbsp; &nbsp;function approveAndCall(address _spender, uint256 _value, bytes _extraData) &nbsp; &nbsp; &nbsp; &nbsp;public &nbsp; &nbsp; &nbsp; &nbsp;returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;tokenRecipient spender = tokenRecipient(_spender); &nbsp; &nbsp; &nbsp; &nbsp;if (approve(_spender, _value)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spender.receiveApproval(msg.sender, _value, this, _extraData); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Destroy tokens &nbsp; &nbsp; * &nbsp; &nbsp; * Remove `_value` tokens from the system irreversibly &nbsp; &nbsp; * &nbsp; &nbsp; * @param _value the amount of money to burn &nbsp; &nbsp; */ &nbsp; &nbsp;function burn(uint256 _value) public returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[msg.sender] &gt;= _value); &nbsp; // Check if the sender has enough &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Subtract from the sender &nbsp; &nbsp; &nbsp; &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Updates totalSupply &nbsp; &nbsp; &nbsp; &nbsp;Burn(msg.sender, _value); &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Destroy tokens from other account &nbsp; &nbsp; * &nbsp; &nbsp; * Remove `_value` tokens from the system irreversibly on behalf of `_from`. &nbsp; &nbsp; * &nbsp; &nbsp; * @param _from the address of the sender &nbsp; &nbsp; * @param _value the amount of money to burn &nbsp; &nbsp; */ &nbsp; &nbsp;function burnFrom(address _from, uint256 _value) public returns (bool success) { &nbsp; &nbsp; &nbsp; &nbsp;require(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Check if the targeted balance is enough &nbsp; &nbsp; &nbsp; &nbsp;require(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp;// Check allowance &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the targeted balance &nbsp; &nbsp; &nbsp; &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the sender&#39;s allowance &nbsp; &nbsp; &nbsp; &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Update totalSupply &nbsp; &nbsp; &nbsp; &nbsp;Burn(_from, _value); &nbsp; &nbsp; &nbsp; &nbsp;return true; &nbsp; &nbsp;} } 我只是想割韭菜而已，用得着写几百行代码吗？ 当然不必，这时我们就需要使用到智能合约开发框架 OpenZeppelin&nbsp;(https://openzeppelin.org)，安装命令如下。 npm install zeppelin-solidity --save GitCoin.sol 引入 OpenZeppelin，代码如下。 // 声明 solidity 编译版本pragma solidity ^0.4.18;// 引入框架为我们提供的编写好的 ERC20 Token 的代码import &quot;zeppelin-solidity/contracts/token/StandardToken.sol&quot;;// 通过 is 关键字继承 StandardTokencontract GitToken is StandardToken { &nbsp;string public name = &quot;GitToken&quot;; // Token 名称 &nbsp;string public symbol = &quot;EGT&quot;; // Token 标识 例如：ETH/EOS &nbsp;uint public decimals = 18; // 计量单位，和 ETH 保持一样就设置为 18 &nbsp;uint public INITIAL_SUPPLY = 10000 * (10 ** decimals); // 初始供应量 &nbsp;// 与 contract 同名的函数为本 contract 的构造方法，类似于 JavaScript 当中的 constructor &nbsp;function GitToken() { &nbsp; &nbsp;totalSupply = INITIAL_SUPPLY; // 设置初始供应量 &nbsp; &nbsp;balances[msg.sender] = INITIAL_SUPPLY; // 将所有初始 token 都存入 contract 创建者的余额 &nbsp;} } 好了，至此一个可以用来交易的符合 ERC20 标准的 token 就编写完毕了。 就这么简单？就这么简单！当然智能合约的功能不止如此，token 中可以玩转设计的地方也不止这些。 不过我们要稍微放在后面一些来讨论，接下来还是赶快着手 ICO 合约开发，为我们的项目募集资金吧。 ICO Crowdsale 合约开发 同样，以太坊官网文档在教程 CROWDSALE Raising funds from friends without a third party&nbsp;(https://www.ethereum.org/crowdsale)&nbsp;中也为我们提供了用来 crowdsale 做 ICO 募资的示例代码： pragma solidity ^0.4.18;/** * interface 的概念和其他编程语言当中类似，在这里相当于我们可以通过传参引用之前发布的 token 合约 * 我们只需要使用其中的转账 transfer 方法，所以就只声明 transfer **/interface token { &nbsp; &nbsp;function transfer(address receiver, uint amount); }contract Crowdsale { &nbsp; &nbsp;// 这里是发布合约时需要传入的参数 &nbsp; &nbsp;address public beneficiary; // ICO 募资成功后的收款方 &nbsp; &nbsp;uint public fundingGoal; // 骗多少钱 &nbsp; &nbsp;uint public amountRaised; // 割到多少韭菜 &nbsp; &nbsp;uint public deadline; // 割到啥时候 &nbsp; &nbsp;/** &nbsp; &nbsp;* 卖多贵，即你的 token 与以太坊的汇率，你可以自己设定 &nbsp; &nbsp;* 注意到，ICO 当中 token 的价格是由合约发布方自行设定而不是市场决定的 &nbsp; &nbsp;* 也就是说你项目值多少钱你可以自己编 &nbsp; &nbsp;**/ &nbsp; &nbsp;uint public price; &nbsp; &nbsp;token public tokenReward; // 你要卖的 token &nbsp; &nbsp;mapping(address =&gt; uint256) public balanceOf; &nbsp; &nbsp;bool fundingGoalReached = false; // 是否达标 &nbsp; &nbsp;bool crowdsaleClosed = false; // 售卖是否结束 &nbsp; &nbsp;/** &nbsp; &nbsp;* 事件可以用来记录信息，每次调用事件方法时都能将相关信息存入区块链中 &nbsp; &nbsp;* 可以用作凭证，也可以在你的 Dapp 中查询使用这些数据 &nbsp; &nbsp;**/ &nbsp; &nbsp;event GoalReached(address recipient, uint totalAmountRaised); &nbsp; &nbsp;event FundTransfer(address backer, uint amount, bool isContribution); &nbsp; &nbsp;/** &nbsp; &nbsp; * Constrctor function &nbsp; &nbsp; * &nbsp; &nbsp; * Setup the owner &nbsp; &nbsp; */ &nbsp; &nbsp;function Crowdsale( &nbsp; &nbsp; &nbsp; &nbsp;address ifSuccessfulSendTo, &nbsp; &nbsp; &nbsp; &nbsp;uint fundingGoalInEthers, &nbsp; &nbsp; &nbsp; &nbsp;uint durationInMinutes, &nbsp; &nbsp; &nbsp; &nbsp;uint etherCostOfEachToken, &nbsp; &nbsp; &nbsp; &nbsp;address addressOfTokenUsedAsReward &nbsp; &nbsp;) { &nbsp; &nbsp; &nbsp; &nbsp;beneficiary = ifSuccessfulSendTo; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoal = fundingGoalInEthers * 1 ether; &nbsp; &nbsp; &nbsp; &nbsp;deadline = now + durationInMinutes * 1 minutes; &nbsp; &nbsp; &nbsp; &nbsp;price = etherCostOfEachToken * 1 ether; &nbsp; &nbsp; &nbsp; &nbsp;tokenReward = token(addressOfTokenUsedAsReward); // 传入已发布的 token 合约的地址来创建实例 &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Fallback function &nbsp; &nbsp; * &nbsp; &nbsp; * payable 用来指明向合约付款时调用的方法 &nbsp; &nbsp; */ &nbsp; &nbsp;function () payable { &nbsp; &nbsp; &nbsp; &nbsp;require(!crowdsaleClosed); &nbsp; &nbsp; &nbsp; &nbsp;uint amount = msg.value; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] += amount; &nbsp; &nbsp; &nbsp; &nbsp;amountRaised += amount; &nbsp; &nbsp; &nbsp; &nbsp;tokenReward.transfer(msg.sender, amount / price); &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(msg.sender, amount, true); &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp;* modifier 可以理解为其他语言中的装饰器或中间件 &nbsp; &nbsp;* 当通过其中定义的一些逻辑判断通过之后才会继续执行该方法 &nbsp; &nbsp;* _ 表示继续执行之后的代码 &nbsp; &nbsp;**/ &nbsp; &nbsp;modifier afterDeadline() { if (now &gt;= deadline) _; } &nbsp; &nbsp;/** &nbsp; &nbsp; * Check if goal was reached &nbsp; &nbsp; * &nbsp; &nbsp; * Checks if the goal or time limit has been reached and ends the campaign &nbsp; &nbsp; */ &nbsp; &nbsp;function checkGoalReached() afterDeadline { &nbsp; &nbsp; &nbsp; &nbsp;if (amountRaised &gt;= fundingGoal){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoalReached = true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GoalReached(beneficiary, amountRaised); &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;crowdsaleClosed = true; &nbsp; &nbsp;} &nbsp; &nbsp;/** &nbsp; &nbsp; * Withdraw the funds &nbsp; &nbsp; * &nbsp; &nbsp; * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached, &nbsp; &nbsp; * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw &nbsp; &nbsp; * the amount they contributed. &nbsp; &nbsp; */ &nbsp; &nbsp;function safeWithdrawal() afterDeadline { &nbsp; &nbsp; &nbsp; &nbsp;if (!fundingGoalReached) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint amount = balanceOf[msg.sender]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (amount &gt; 0) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (msg.sender.send(amount)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(msg.sender, amount, false); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = amount; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;if (fundingGoalReached &amp;&amp; beneficiary == msg.sender) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (beneficiary.send(amountRaised)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(beneficiary, amountRaised, false); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//If we fail to send the funds to beneficiary, unlock funders balance &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoalReached = false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;} } 至此我们的 ICO 合约也开发完毕了，基本上一行代码都没有写，只是改了几个参数，一个键盘上只有三个按键的程序员都能够完成这类智能合约的开发，没有比这更友好的编程体验了。 虽然 solidity 是一种非图灵完备的编程语言，但我们仍然能够用它编写许多逻辑。 上述的 ICO 示例代码写得算比较客气的一种，在最后的提款方法中，如果筹资达标，ICO 发布方则可以取走所有筹款，而如果未达标，参与者则能够取回自己的投资，由合约来持有所有款项。 但事实上，我们仍然可以随意修改其中的逻辑，看下面代码。 function () payable { &nbsp;require(!crowdsaleClosed); &nbsp;uint amount = msg.value; &nbsp;balanceOf[msg.sender] += amount; &nbsp;amountRaised += amount; &nbsp;tokenReward.transfer(msg.sender, amount / price); &nbsp;// 每次有人付款直接取走筹资 &nbsp;beneficiary.send(amountRaised); &nbsp;amountRaised = 0; &nbsp;FundTransfer(msg.sender, amount, true); }// 删除剩余代码 补充说明与权限控制 既然咱是铁了心来割韭菜的，如此简单的代码怎么能够满足咱的贪欲呢？一定要学比特币固定供给量吗？ 我是来卖 token 的呀，万一有一天卖完了怎么办，万一有人手里筹码比我自己都多了控盘怎么办，万一发的数量太多卖的不好怎么办？ 事实上解决这些问题的逻辑全部都可以写在智能合约里。 Ownable token 在我们的潜在观念里，区块链自有不可变属性。 这种不可变属性在一些狂热信徒的演绎当中变成了平权属性，甚至带有了共产主义色彩，仿佛拥抱区块链技术就能够为未来的人类文明带来希望，把人民从集权的手中解救出来。 然而事实上这种不可变性同样是两面的，它能够带来的也包括所有权的不可变性。 ERC20 标准只规定了我们的合约中应该包含哪些方法，而没有限制合约中不能出现哪些方法，因此在之前的基础上，我们还可以继续编写一些特殊的方法，赋予合约发布者一些管理员特权。 请看下面代码： contract Ownable { &nbsp; &nbsp;address public owner; &nbsp; &nbsp;function Ownable() public { &nbsp; &nbsp; &nbsp; &nbsp;owner = msg.sender; &nbsp; &nbsp;} &nbsp; &nbsp;// 通过 onlyOwner 我们可以限定一些方法只有所有者才能够调用 &nbsp; &nbsp;modifier onlyOwner { &nbsp; &nbsp; &nbsp; &nbsp;require(msg.sender == owner); &nbsp; &nbsp; &nbsp; &nbsp;_; &nbsp; &nbsp;} &nbsp; &nbsp;function transferOwnership(address newOwner) onlyOwner public { &nbsp; &nbsp; &nbsp; &nbsp;owner = newOwner; &nbsp; &nbsp;} }// 合约可以同时有多个继承contract GitToken is StandardToken, Ownable { &nbsp;... MintableToken 接下来我们来解决 token 不够卖的问题，万一我的 initial offer 卖断货了怎么办，万一我卖完一次还想卖怎么办？ 这时我们就需要把 token 编写成为 MintableToken，在我们想增发的时候就能增发，代码如下： // 用 onlyOwner 限定只有 token 的所有者才能够进行增发操作function mint(address _to, uint256 _amount) onlyOwner public returns (bool) { &nbsp;totalSupply_ = totalSupply_.add(_amount); &nbsp;balances[_to] = balances[_to].add(_amount); &nbsp;Mint(_to, _amount); &nbsp;Transfer(address(0), _to, _amount); &nbsp;return true; } BurnableToken 万一我们的 token 不小心发了太多，卖的时间久了贬值怎么办？ 当然是销毁了，可参照下面代码： /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */function burn(uint256 _value) public returns (bool success) { &nbsp;require(balanceOf[msg.sender] &gt;= _value); &nbsp; // Check if the sender has enough &nbsp;balanceOf[msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Subtract from the sender &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Updates totalSupply &nbsp;Burn(msg.sender, _value); &nbsp;return true; } 万一有人手里的筹码太多，或者 token 被竞争对手买走了怎么办？没关系，我们还可以指定销毁某一账户中的 token，请看下面代码： /** &nbsp;* Destroy tokens from other account &nbsp;* &nbsp;* Remove `_value` tokens from the system irreversibly on behalf of `_from`. &nbsp;* &nbsp;* @param _from the address of the sender &nbsp;* @param _value the amount of money to burn &nbsp;*/function burnFrom(address _from, uint256 _value) public returns (bool success) { &nbsp;require(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Check if the targeted balance is enough &nbsp;require(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp;// Check allowance &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the targeted balance &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subtract from the sender&#39;s allowance &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Update totalSupply &nbsp;Burn(_from, _value); &nbsp;return true; } 只要上述的方法全部都出现在合约里，我们发布的 token 就能够具备上述所有属性。 这样一来，不够的时候我们可以发钱，发多了可以销毁，我们成功创建了属于自己的一所中央银行，甚至看某人不爽还能够指定销毁其账户存款，这哪里是平权，简直是超级集权。 而事实上，在已发布的 ERC20 token 当中，例如排名第一的 EOS 的合约&nbsp;(https://goo.gl/L2AmQP)&nbsp;里也是存在类似方法的，如下所示。 function mint(uint128 wad) auth stoppable note { &nbsp;_balances[msg.sender] = add(_balances[msg.sender], wad); &nbsp;_supply = add(_supply, wad); }function burn(uint128 wad) auth stoppable note { &nbsp;_balances[msg.sender] = sub(_balances[msg.sender], wad); &nbsp;_supply = sub(_supply, wad); } 当然在其官方网站和白皮书中是标明了会发布多少 token，创始团队持有多少，投资人分配多少，公开发布多少，如何销毁等内容的。 但白皮书又不具备法律效力，token 的所有权也不在你手里，万一人家哪天想要跑路或者中途变卦岂是咱能拦得住的。 换个角度讲，假如你现在手里有一家可以印钱的公司，印多少就有多少，你印还是不印？ 通过这一部分内容的介绍，我只是想要证明，智能合约本身并不具备可无条件信任的特性，充其量就是一段没法改一直跑的程序而已。 你也可以在逻辑中加入管理员权限，token 的发布方并不比央行可信多少，只要所有者愿意可以随时进行修改。以太坊官方宣传的所谓 “trustless” 这一概念根本不成立。 没有第三方担保，没有法律法规的维护，仅凭智能合约本身你的投资得不到任何保证。智能合约的不可变性反而给割韭菜的一方提供了巨大的便利。 从前你看不惯某家公司还能够黑掉它的系统，获取管理员权限，如今所有程序都跑在区块链上，黑无可黑，集权永远都在合约发布者的手里。 讲到这里，希望你能理解这次分享的良苦用心，不要轻信任何 ICO 项目。 合约的发布及调试 本地开发环境发布 合约开发完成之后，我们需要编译并发布合约至区块链网络中，只需要进行以下两步操作。 首先在&nbsp;migrations&nbsp;文件夹下新建&nbsp;2-deploy-contract.js&nbsp;文件，配置部署脚本如下。 // 引入我们编写的合约const GitCoin = artifacts.require(&quot;./GitCoin.sol&quot;)const GitCoinCrowdsale = artifacts.require(&quot;./GitCoinCrowdsale.sol&quot;)module.exports = function(deployer, network, accounts) { &nbsp;// 设定参数，此处的参数即使传入合约构造方法的参数，与你自己编写的合约保持一致 &nbsp;const ifSuccessfulSendTo = accounts[0] // 当前以太坊网络中的默认账户 &nbsp;const fundingGoalInEthers = 1000 &nbsp;const durationInMinutes = 36000000 &nbsp;const etherCostOfEachToken = 0.01 &nbsp;// 这里的 Promise 可以保证我们在发布完 token 合约之后再发布 ICO 合约，并将已发布 token 的地址作为参数传入 &nbsp;deployer.deploy(GitCoin).then(function() { &nbsp; &nbsp;return deployer.deploy(GitCoinCrowdsale, ifSuccessfulSendTo, fundingGoalInEthers, durationInMinutes, etherCostOfEachToken, GitCoin.address); &nbsp;}); }; 接着在&nbsp;truffle-config.js&nbsp;或&nbsp;truffle.js&nbsp;中设置发布网络，脚本如下。 module.exports = { &nbsp;networks: { &nbsp; &nbsp;development: { &nbsp; &nbsp; &nbsp;host: &quot;127.0.0.1&quot;, &nbsp; &nbsp; &nbsp;port: 7545, // 与你本地的 ganache 设置保持一致 &nbsp; &nbsp; &nbsp;network_id: &quot;*&quot; // Match any network id &nbsp; &nbsp;} &nbsp;} }; 现在只需要开启 Ganache： 然后在命令行中输入： truffle compile truffle migrate 你的合约就会顺利发布至测试网络中了。然后你可以输入： truffle console 这样就能够进入本地的命令行调试了： # 所有的合约方法都是 Promise 对象truffle(development)&gt; GitCoinCrowdsale.deployed().then(inst=&gt;{crowd=inst}) truffle(development)&gt; GitCoin.deployed().then(inst=&gt;{git=inst}) truffle(development)&gt; crowd.sendTransaction({from:web3.eth.accounts[0],value:web3.toWei(1, &quot;ether&quot;)}) truffle(development)&gt; git.mint(web3.eth.accounts[0],web3.toWei(100, &quot;ether&quot;)) 线上测试网络发布 以太坊网络分为测试网和主网，在正式发布主网之前，我们可以先发送到测试网络进行调试。 发布至以太坊网络也无需同步完整节点，我们可以使用 Infura 为我们提供的公共接口。 填写表单提交后，Infura 会为你提供专用的接口地址，然后我们只需要将网络地址填入到配置文件中，如下所示。 var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;); // 在这里我们需要通过 js 调用以太坊钱包，通过 npm install truffle-hdwallet-provider 安装这个库var infura_apikey = &quot;ubQWERwasd&quot;; // infura 为你提供的 apikey 请与你申请到的 key 保持一致，此处仅为示例var mnemonic = &quot;apple banana carray dog egg fault great&quot;; // 你以太坊钱包的 mnemonic ，可以从 Metamask 当中导出，mnemonic 可以获取你钱包的所有访问权限，请妥善保存，在开发中切勿提交到 gitmodule.exports = { &nbsp;networks: { &nbsp; &nbsp;development: { &nbsp; &nbsp; &nbsp;host: &quot;127.0.0.1&quot;, &nbsp; &nbsp; &nbsp;port: 7545, &nbsp; &nbsp; &nbsp;network_id: &quot;*&quot; &nbsp; &nbsp;}, &nbsp; &nbsp;ropsten: { &nbsp; &nbsp; &nbsp;provider: function() { &nbsp; &nbsp; &nbsp; &nbsp;return new HDWalletProvider(mnemonic, &quot;https://ropsten.infura.io/&quot;+infura_apikey) &nbsp; &nbsp; &nbsp;}, &nbsp; &nbsp; &nbsp;network_id: 3, &nbsp; &nbsp; &nbsp;gas: 3012388, &nbsp; &nbsp; &nbsp;gasPrice: 30000000000 &nbsp; &nbsp;}, &nbsp; &nbsp;main: { &nbsp; &nbsp; &nbsp;provider: function() { &nbsp; &nbsp; &nbsp; &nbsp;return new HDWalletProvider(mnemonic, &quot;https://mainnet.infura.io/&quot;+infura_apikey) &nbsp; &nbsp; &nbsp;}, &nbsp; &nbsp; &nbsp;network_id: 3, &nbsp; &nbsp; &nbsp;gas: 3012388, &nbsp; &nbsp; &nbsp;gasPrice: 1000000000 &nbsp; &nbsp;} &nbsp;} }; 在以太坊网络中发布合约需要使用 ETH 支付矿工的 gas 费用，你可以在 Ethereum Ropsten Faucet&nbsp;(http://faucet.ropsten.be:3001)&nbsp;免费获取到用于 Ropsten 测试网络的 ETH。 由于网络环境的变化，不同的拥堵状况可能造成燃料费用和消耗的不同。 如果发布不成功，可以调整&nbsp;gas/gasPrice&nbsp;的数值，你可以通过&nbsp;web3.getBlock(&#39;latest&#39;).gasLimit&nbsp;这一数值判断当前网络的消耗。 在命令行输入如下命令： truffle migrate --network ropsten 通过&nbsp;--network&nbsp;设置发布的目标网络。 主网络发布 同理，在发布至主网络时，只需要执行如下命令。 truffle migrate --network main 但由于当前的以太坊网络的现实状况，如果设置燃料费太低，可能要等待数天后合约才会被网络确认，注意到我们编写的发布脚本是需要合约地址回调的。 介于这种状况，我们可以将 token 合约和 crowdsale 合约分开发布，只需要再新建&nbsp;3-deploy-crowdsale.js&nbsp;文件，脚本如下。 const LeekCoinCrowdsale = artifacts.require(&quot;./GitCoinCrowdsale.sol&quot;)module.exports = function(deployer, network, accounts) { &nbsp;const ifSuccessfulSendTo = accounts[0] &nbsp;const fundingGoalInEthers = 1000 &nbsp;const durationInMinutes = 36000 &nbsp;const etherCostOfEachToken = 0.01 &nbsp;const tokenAddress = &#39;0x123456789ABCDFGHSDWDVC&#39; // 先单独发布 token 合约，上线成功后将其合约地址填在此处 &nbsp;deployer.deploy(GitCoinCrowdsale, ifSuccessfulSendTo, fundingGoalInEthers, durationInMinutes, etherCostOfEachToken, tokenAddress); }; 在发布至主网络时，可以分开两次进行，确保你设置的账户里有真实的 ETH 余额，注意设置好合理的 gas 数值，根据确认时间的长短，可能需要 0.08~1 ETH 不等。 上线合约验证 无论是发布至以太坊的测试网络还是主网络，在发布完成之后都需要在 Etherscan&nbsp;(https://etherscan.io)&nbsp;进行线上验证。 在 Etherscan 上打开你刚刚发布的合约地址，你可以看到如下内容： 点击&nbsp;Verify And Publish&nbsp;链接就可以进入验证页面： 在填写表单时有以下注意事项。 Compiler 选择最新版本； Optimization 选择 No。 虽然 solidity 支持 import 语法，但 Etherscan 对使用 import 进行开发的合约支持很鸡肋，目前它要求你需要把库文件也当作合约发布至网络才能够在表单中填写进行验证。 当然我们也可以选择手动把 import 库文件的内容手动复制粘贴到代码框里，注意要保留全部内容，包括 pragma 声明一行。 当然你也可以选择使用官方的 Remix&nbsp;(https://remix.ethereum.org/)&nbsp;预先 concrete 你的合约文件，也可以安装 solidity compiler&nbsp;(https://goo.gl/aKsXxH)&nbsp;在本地编译好再发布。 ICO 和 token 的合约如此简单，根本不需要这些玩意儿，所以此处不再赘述，感兴趣的同学可以自行研究。 Dapp 开发 智能合约相当于我们的后端逻辑，以太坊的 EVM 就是我们的云服务器，Infura 为我们提供 API 接口，接下来我们就只需要给韭菜开发一个可以花钱消费的前端界面了。 ICO 项目的网站把握以下几个原则就好。 文字不要太多，页面要大片留白，简洁明了有现代感； 配色一定要深，加上动态几何图形，设计要有未来感； 开发团队全配齐，不是常春藤，没有硅谷背景的不要，一定要国际化； 各种站台大佬，海量媒体报道，一线互联网公司合作全放上去。 言归正传，我们还是专注于技术。 web3.js 的使用 web3.js&nbsp;(https://github.com/ethereum/web3.js)&nbsp;为我们提供了一系列访问以太坊网络的 JavaScript 编程接口，完整的说明文档可以在 web3.js Doc&nbsp;(https://goo.gl/zp2yEQ)&nbsp;中参阅。 我们一般通过如下脚本来初始化 web3 对象。 // 判断当前浏览器中有未注入 web3 对象if (typeof web3 !== &#39;undefined&#39;) { &nbsp;App.web3Provider = web3.currentProvider; &nbsp;web3 = new Web3(web3.currentProvider); } else { &nbsp;// 注意设置到你自己的 infura 地址 &nbsp;App.web3Provider = new Web3.providers.HttpProvider(&#39;https://ropsten.infura.io/ubQWERawsd&#39;); &nbsp;web3 = new Web3(App.web3Provider); } Metamask 简介 Metamask&nbsp;(https://metamask.io)&nbsp;是一个浏览器插件，通过 Metamask 我们可以在浏览器中使用以太坊钱包，在访问 Dapp 应用时，也可以为其注入 web3 对象。 具体配合应用开发的文档可以在 MetaMask Compatibility Guide&nbsp;(https://goo.gl/7wKPtp)&nbsp;查阅，一般我们通过如下脚本来监测 Metamask 状态获取以太坊账户。 var account = web3.eth.accounts[0];var accountInterval = setInterval(function() { &nbsp;if (web3.eth.accounts[0] !== account) { &nbsp; &nbsp;account = web3.eth.accounts[0]; &nbsp; &nbsp;updateInterface(); &nbsp;} }, 100); truffle-contract 的使用 web3.js 默认为我们提供的接口还是太底层，许多调用需要 hard code 设置参数，以太坊网络使用的 BigNumber 也需要我们手动转换。 我们可以选择使用 truffle-contract&nbsp;(https://github.com/trufflesuite/truffle-contract)&nbsp;来调用更高一层的封装对象，并且在之前使用 truffle 开发构建的智能合约文件也能派上用场。 我们可以在&nbsp;build/contracts/&nbsp;下找到编译好的&nbsp;GitCoin.json&nbsp;和&nbsp;GitCoinCrowdsale.json&nbsp;文件，之后可以在我们的应用中通过如下脚本获取合约对象。 &lt;script type=&quot;text/javascript&quot; src=&quot;./dist/truffle-contract.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var GitCoin; $.getJSON(&#39;contracts/GitCoin.json&#39;, function(data) { &nbsp;// 获取编译好的合约文件 &nbsp;var GitCoinArtifact = data; &nbsp;// 通过 truffle-contract 获取合约对象 &nbsp;GitCoin = TruffleContract(GitCoinArtifact); &nbsp;// 将合约绑定至当前 web3 对象 &nbsp;GitCoin.setProvider(App.web3Provider); });&lt;/script&gt; 之后我们就可以像在&nbsp;truffle console&nbsp;当中一样，对合约对象进行各种操作啦。 ICO 前端应用开发 我们的 ICO 应用只需要解决一个核心需求，那就是买币；只需要两个核心功能，一个是选择买多少，另一个就是付款，所以我们的界面自然是相当简单，如下图所示。 然后再稍微美化一下，如下面两张图所示。 一场成功的 ICO，自然需要精雕细琢，完整的代码示例可以在 Leek Ecological Chain&nbsp;(http://lec.yubolun.com/)&nbsp;找到，同时此网站也是上述教程的一个完整示例，你可以切换到 Ropsten 网络在本网站上购买 LEC&nbsp;(https://goo.gl/4uNskB)&nbsp;韭菜币。 Dapp 部署 既然我们开发的是 Dapp 去中心化应用，怎么能够部署在中心化的服务器上呢？这不是自掉身价吗？Dapp 自然有其部署的解决方案。 IPFS 简介 IPFS 提供去中心化的点对点的 Web 服务。 说简单点，你可以把它理解成为一个 p2p 的网盘，你网站的静态文件可以发布到 IPFS 上面托管，而且只要 IPFS 的节点不挂，你的网站就永远都不会挂，而不像部署到单独服务器上。 同时 IPFS 上的一个文件也就对应着一个 hash 地址，普通用户可以通过公共的 http gateway 访问到你的页面，不像云服务器还要备案，正好也方便你割完韭菜跑路。 使用也非常简单，只需要在 Install Go IPFS&nbsp;(https://ipfs.io/docs/install)&nbsp;下载安装。 发布应用 只需要一行命令，把你 Dapp 的所有静态文件上传至 IPFS，命令如下。 ipfs add -r your-ico/# 返回 hash 地址，此处仅为示例added QWERabcd1234qwerABCD your-ico/ 然后你就能够通过 https://goo.gl/5SyBwN 访问你的网站。当然这样的域名十分不友好，为 IPFS 站点设置解析需要一些不常用的操作。 域名解析 IPNS 你的站点必然包含多个文件，每个文件对应着独立的 hash 地址，而且你也不能保证你的网站只需要发布一次。 因此在网站发布后，我们需要使用 ipns 来获取到对应的唯一地址，之后的 DNS 解析也会对应到这一地址，同样只需要一行命令，如下所示。 # 站点发布后的 hash 地址，此处仅为示例ipfs name publish QWERabcd1234qwerABCD# 返回 ipns 地址Published to ABCDqwer1234abcdQWER 之后你就能够通过 https://goo.gl/8YMLBi 访问你的站点了。在设置域名解析时，我们需要添加一条&nbsp;TXT&nbsp;类型的解析记录，解析值为： dnslink=/ipns/ABCDqwer1234abcdQWER 这样我们就能够通过 https://goo.gl/VjSm1K 访问你的 Dapp，这样是不是友好多了？ Nginx 反向代理 当然你也可能希望使用自己的独立域名，这时我们只需要使用 Nginx 设置反向代理即可。 server { &nbsp;listen 80; &nbsp;server_name yourico.com; &nbsp;location / { &nbsp; &nbsp;proxy_pass https://ipfs.io/ipns/yourico.com/; &nbsp;} } 写在后面 以太坊官网，第一篇教程教你发 token，第二篇就教你卖 token，居心何在我也不好评判。 除了 ICO 还有 IMO/IFO ，IMO 你只用卖个路由器，IFO 只需要 fork 一份 Bitcoin 的代码，稍微调调参数，就不需要什么教程了。 程序员总是妄图通过技术手段解决社会问题，然而人性是不变的。以太坊希望建立一个 trustless 的网络，可惜被无数人滥用，巧立空气项目，搞空壳公司，逃避监管搞非法集资。 区块链和虚拟货币期望用点对点分布式的网络，脱离第三方，让世界上任何角落的两个人都能够低成本地进行交易，结果大量投机者涌入，导致网络堵塞，如今我们连一笔交易的矿工费都支付不起。 当然我信奉技术本身是无罪，就好像这篇教你割韭菜的文章一样，你是选择擦亮双眼，看清 ICO 的本质，从此势不两立；还是选择投机倒把，滥用以太坊技术，坠身同流合污？ 您可以在访问 https://github.com/discountry/gitcoin 查看完整的智能合约示例。 您可以访问 https://github.com/discountry/lec 查看完整的 Dapp 示例。 Read at your own risk. 近期热文 《它的暴利，已经完全超过了某些犯罪收入》 《Java 语法糖详解》 《程序员跳槽时，如何高效地准备面试？》 《机器学习数据预处理方法与技巧系统讲解》 《中小型企业基于大数据技术的项目实践》 《GitChat 被恶意攻击引发的技术性思考：拒绝服务攻击》 「阅读原文」看交流实录，你想知道的都在这里 阅读更多","@type":"BlogPosting","url":"/2018/02/13/924cb7f660caab962ebbecf6d1bf03ac.html","headline":"一夜身价暴涨千倍，如何发布你自己的 ICO？","dateModified":"2018-02-13T00:00:00+08:00","datePublished":"2018-02-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/02/13/924cb7f660caab962ebbecf6d1bf03ac.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>一夜身价暴涨千倍，如何发布你自己的 ICO？</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div class="rich_media_content"> 
   <p style="line-height:1.75em;margin-left:8px;"><img class="__bg_gif img_loadederror" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/0vU1ia3htaaNkJ6m9xkicNHd7rK9UzHjm9gI3jwia6gHYKpYUUyjsTjDp9xfMO9PzMuQ45fTwA8FicB0DmFyQAG5mg/640?wx_fmt=gif" style="width:640px;" alt=""><br></p>
   <p style="line-height:1.75em;margin-left:8px;"><span style="font-size:13px;"><span style="color:rgb(178,178,178);">本文来自作者</span>&nbsp;<span style="color:rgb(85,85,85);">余博伦</span>&nbsp;<span style="color:rgb(178,178,178);">在<strong>&nbsp;GitChat&nbsp;</strong>上分享 「韭菜种植与收割：发布你自己的 ICO」，</span>「<span style="color:rgb(171,25,66);">阅读原文</span>」<span style="color:rgb(178,178,178);">查看交流实录。</span></span></p>
   <p style="text-align:right;line-height:1.75em;margin-left:8px;"><span style="font-size:13px;">「<span style="color:rgb(171,25,66);">文末高能</span>」</span></p>
   <p style="line-height:1.75em;margin-left:8px;"><span style="color:rgb(178,178,178);font-size:13px;">编辑 | 哈比</span></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">你可曾想梭哈全部存款，参与 ICO，一夜身价暴涨千倍，获得财富自由，从此走上人生巅峰？</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">ICO 是借用 IPO 生造出来的一种概念，同样具有非常相似的募资机制，但 IPO 有着严格的上市流程、政策监管，如下图所示。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loadederror" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc3CZHAzXqRI1aj5yWxshnY56cLLY81TOYPyhaXCwysu3QcS58zdHgicHw/640?wx_fmt=jpeg" style="width:654px;" alt=""></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">即便如此，参与 IPO 仍然有着相当大的风险，且为股市带来了相当大的不稳定因素。而与 ICO 比起来简直就是小巫见大巫了。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">一家公司想要进行 IPO 起码要达到能够上市的标准，而想发布 ICO 你只要有一个好听的 idea 就足够了。并且严重缺乏监管，虽然各国政府都在不断发出声明，但截至本分享写作前，也没有正式出台比较明朗的有关规定。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">这也导致无数的空气项目披着虚拟货币和区块链的高科技壳，到处招摇撞骗割韭菜，有过之无不及的还搞什么 AI+ 区块链，IOT+ 区块链，技术名词堆积越多的项目，死得往往越快。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">甚至一些有头有脸的大公司，也忍不住打打擦边球，收割一波，炒作炒作，股价就能翻几个涨停。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">可就像马老爷子说的：</p>
   <blockquote style="border-left-width:4px;border-left-color:rgb(221,221,221);font-size:15px;color:rgb(119,119,119);">
    <p style="color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:rgb(136,136,136);">如果有 10% 的利润，它就保证到处被使用；有 20% 的利润，它就活跃起来；有 50% 的利润，它就铤而走险；为了 100% 的利润，它就敢践踏一切人间法律；有 300% 的利润，它就敢犯任何罪行，甚至绞首的危险。</span></p>
   </blockquote>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">即便如此，仍然有很多人跃跃欲试不信邪。这一场 Chat 就手把手教你为 ICO 做好所有技术面上的准备。在和大家一起点亮新技能的同时，也揭一揭所谓 ICO 的老底。</p>
   <h3 style="font-weight:bold;font-size:18px;color:rgb(240,150,28);line-height:1.75em;">内容概要</h3>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">目前市场上 99% 的项目 ICO 都是基于以太坊<span style="color:rgb(136,136,136);">（Ethereum）</span>智能合约<span style="color:rgb(136,136,136);">（Smart Contracts）</span>技术发布的 token<span style="color:rgb(136,136,136);">（ERC20 Token）</span>。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">本次分享也是基于这一套技术栈，介绍内容包括以下几个方面。</p>
   <ul class="list-paddingleft-2" style="margin-left:8px;">
    <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">本地开发环境构建</span></p></li>
    <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">以太坊智能合约开发</span></p>
     <ul class="list-paddingleft-2" style="list-style-type:square;">
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">本地开发环境发布</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">线上测试网络发布</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">主网络发布</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">ERC20 Token 合约开发</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">ICO Crowdsale 合约开发</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">补充说明与权限控制</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">合约的发布及调试</span></p></li>
     </ul></li>
    <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">Dapp 开发</span></p>
     <ul class="list-paddingleft-2" style="list-style-type:square;">
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">web3.js 的使用</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">Metamask 简介</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">truffle-contract 的使用</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">ICO 前端应用开发</span></p></li>
     </ul></li>
    <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">Dapp 部署</span></p>
     <ul class="list-paddingleft-2" style="list-style-type:square;">
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">IPNS</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">Nginx 反向代理</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">IPFS 简介</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">发布应用</span></p></li>
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">域名解析</span></p></li>
     </ul></li>
   </ul>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">使用到的技术栈包括：</p>
   <ul class="list-paddingleft-2" style="margin-left:8px;">
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">Truffle：http://truffleframework.com</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">[Ganache：http://truffleframework.com/ganache</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">Metamask：https://metamask.io</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">Solidity：http://solidity.readthedocs.io/en/develop</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">openzeppelin：https://openzeppelin.org</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">Infura：https://infura.io</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">web3.js：https://web3js.readthedocs.io/en/1.0/index.html</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">truffle-contract：https://github.com/trufflesuite/truffle-contract</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">ipfs：https://ipfs.io</span></p></li>
   </ul>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">对读者的基本要求有：</p>
   <ul class="list-paddingleft-2" style="margin-left:8px;">
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">了解编程</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">会 JavaScript</span></p></li>
   </ul>
   <h3 style="font-weight:bold;font-size:18px;color:rgb(240,150,28);line-height:1.75em;">本地开发环境构建</h3>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">以太坊官方提供的 Mist&nbsp;<span style="color:rgb(136,136,136);">(https://github.com/ethereum/mist/releases)&nbsp;</span>和 Ethereum-Wallet<span style="color:rgb(136,136,136);">&nbsp;(https://github.com/ethereum/mist/releases)</span>。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">其中 Mist 是一个可以用来访问 Dapp 的浏览器，Ethereum-Wallet 是 Mist 的一个独立发布版本，也算是浏览器，但只能用来访问以太坊钱包这个应用。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">在网络同步过程中或多或少都会遇到问题，而且目前网络拥堵，完整节点过大，同步完成相当困难。但事实上我们进行以太坊开发时并不需要同步完整的节点，也可以选择使用相应的模拟开发环境。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">Truffle&nbsp;<span style="color:rgb(136,136,136);">(http://truffleframework.com)&nbsp;</span>框架为你提供本地进行智能合约开发的所有依赖支持，使你可以在本地进行智能合约及 Dapp 的开发、编译、发布。安装非常简单，只需要：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">npm install -g truffle</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">Ganache<span style="color:rgb(136,136,136);">&nbsp;(http://truffleframework.com/ganache)&nbsp;</span>也是 Truffle 框架中提供的一个应用，可以在你的本地开启模拟一个以太坊节点，让你能够将开发好的智能合约发布至本地测试节点中运行调试。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">安装也非常简单，官网下载即可，双击打开运行。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">不过这里有一个隐藏的坑，如果你使用的是 Windows 系统的话，Ganache 提供的是后缀名为&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">.appx</code>&nbsp;的 Windows 应用商店版安装包。你需要打开 Windows 设置 -&gt; 系统 -&gt; 针对开发人员 -&gt; 选择 “旁加载应用” 这个选项。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc3y7Hhbpibgc71cux8UIcePjswvE5vWlqsSNbGz55Ay8ibBsNStBEicFnRw/640?wx_fmt=png" style="width:654px;" alt=""></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">确认之后就可以双击&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">Ganache.appx</code>&nbsp;进行安装了，假如系统仍然无法识别这一后缀名，你可以手动打开&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">powershell</code>&nbsp;输入如下命令进行安装。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">Add-AppxPackage .\Ganache.appx</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc33NVsl6NQO3icl0Ribf05cicY5237Sicico5NiaIX2t6953mrwoBib5331JhHw/640?wx_fmt=png" style="width:654px;" alt=""></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">至此本地开发智能合约及 Dapp 的环境就算安装完成了，Truffle 官方提供了许多示例教程以及应用脚手架<span style="color:rgb(136,136,136);">（truffle box）</span>，其中就包括教你开发以太坊宠物商&nbsp;<span style="color:rgb(136,136,136);">(http://truffleframework.com/tutorials/pet-shop)&nbsp;</span>的教程等内容。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">在此不再赘述，感兴趣的同学自己动手可以试试。</p>
   <h3 style="font-weight:bold;font-size:18px;color:rgb(240,150,28);line-height:1.75em;">以太坊智能合约开发</h3>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">首先使用 Truffle 初始化我们的项目，命令如下。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">mkdir my-ico<span class="hljs-built_in" style="color:rgb(0,134,179);">cd</span> my-ico npm init -y truffle init</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">脚本运行完成之后 Truffle 会自动为我们的项目创建一系列文件夹和文件，如下图所示。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">这里有一个隐藏的坑，如果你使用 Windows 命令行的话，需要删掉&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">truffle.js</code>&nbsp;文件，否则在项目目录执行 truffle 相关命令时，CMD 会混淆&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">truffle</code>&nbsp;与&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">truffle.js</code>&nbsp;文件。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">因此，你应该将配置写在&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">truffle-config.js</code>&nbsp;文件当中。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc3nYh955x7PLlJI9IAMPNDAhY3tk67JmA1yHPsPeCia8j6Dpa0hJ0xlzQ/640?wx_fmt=png" style="width:274px;" alt=""></p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">ERC20 Token 合约开发</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">现在我们的项目目录大概是这个样子：</p>
   <ul class="list-paddingleft-2" style="margin-left:8px;">
    <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">contracts/</span></p>
     <ul class="list-paddingleft-2" style="list-style-type:square;">
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">Migrations.sol</span></p></li>
     </ul></li>
    <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">migrations/</span></p>
     <ul class="list-paddingleft-2" style="list-style-type:square;">
      <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">1_initial_migration.js</span></p></li>
     </ul></li>
    <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">test/</span></p></li>
    <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">package.json</span></p></li>
    <li><p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(85,85,85);">truffle-config.js 或 truffle.js</span></p></li>
   </ul>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">我们在编写智能合约时，需要在&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">contracts</code>&nbsp;目录下新建相应的智能合约文件。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">在以太坊开发智能合约的编程语言叫做 Solidity&nbsp;<span style="color:rgb(136,136,136);">(<span style="font-family:Roboto, Helvetica, Arial, sans-serif;">https://goo.gl/hCHh3w</span>)。</span>它是一种在语法上非常类似 JavaScript 的语言，其后缀名为&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">.sol</code>&nbsp;。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">例如在这里我们可以创建一个名为&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">GitCoin.sol</code>&nbsp;的文件，命令如下。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">// *nix touch GitCoin.sol // win copy NUL &gt; GitCoin.sol</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">ERC20<span style="color:rgb(136,136,136);">（Ethereum Request for Comments NO.20）(<span style="font-family:Roboto, Helvetica, Arial, sans-serif;">https://goo.gl/aX4x5F</span>)&nbsp;</span>是官方发行的 token 标准。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">如果你希望你发布的 token 能够在以太坊网络上流通、上市交易所、支持以太坊钱包，在开发 token 的合约时就必须遵从这一规范。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">ERC20 规定了合约中的一系列变量、方法、事件，你可以参考官网教程 Create your own CRYPTO-CURRENCY with Ethereum&nbsp;<span style="color:rgb(136,136,136);">(https://www.ethereum.org/token)</span>&nbsp;当中的示例代码：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">pragma solidity ^<span class="hljs-number" style="color:rgb(0,128,128);">0.4.16</span>; interface tokenRecipient { <span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">receiveApproval</span><span class="hljs-params">(address _from, uint256 _value, address _token, bytes _extraData)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span>; }<span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">contract</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">TokenERC20</span> </span>{ &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Public variables of the token</span> &nbsp; &nbsp;string public name; &nbsp; &nbsp;string public symbol; &nbsp; &nbsp;uint8 public decimals = <span class="hljs-number" style="color:rgb(0,128,128);">18</span>; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 18 decimals is the strongly suggested default, avoid changing it</span> &nbsp; &nbsp;uint256 public totalSupply; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// This creates an array with all balances</span> &nbsp; &nbsp;mapping (address =&gt; uint256) public balanceOf; &nbsp; &nbsp;mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// This generates a public event on the blockchain that will notify clients</span> &nbsp; &nbsp;event Transfer(address indexed from, address indexed to, uint256 value); &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// This notifies clients about the amount burnt</span> &nbsp; &nbsp;event Burn(address indexed from, uint256 value); &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Constrctor function &nbsp; &nbsp; * &nbsp; &nbsp; * Initializes contract with initial supply tokens to the creator of the contract &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">TokenERC20</span><span class="hljs-params">( &nbsp; &nbsp; &nbsp; &nbsp;uint256 initialSupply, &nbsp; &nbsp; &nbsp; &nbsp;string tokenName, &nbsp; &nbsp; &nbsp; &nbsp;string tokenSymbol &nbsp; &nbsp;)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;totalSupply = initialSupply * <span class="hljs-number" style="color:rgb(0,128,128);">10</span> ** uint256(decimals); &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Update total supply with the decimal amount</span> &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = totalSupply; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Give the creator all initial tokens</span> &nbsp; &nbsp; &nbsp; &nbsp;name = tokenName; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Set the name for display purposes</span> &nbsp; &nbsp; &nbsp; &nbsp;symbol = tokenSymbol; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Set the symbol for display purposes</span> &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Internal transfer, only can be called by this contract &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">_transfer</span><span class="hljs-params">(address _from, address _to, uint _value)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">internal</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Prevent transfer to 0x0 address. Use burn() instead</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(_to != <span class="hljs-number" style="color:rgb(0,128,128);">0x0</span>); &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Check if the sender has enough</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Check for overflows</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(balanceOf[_to] + _value &gt; balanceOf[_to]); &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Save this for an assertion in the future</span> &nbsp; &nbsp; &nbsp; &nbsp;uint previousBalances = balanceOf[_from] + balanceOf[_to]; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Subtract from the sender</span> &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Add the same to the recipient</span> &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_to] += _value; &nbsp; &nbsp; &nbsp; &nbsp;Transfer(_from, _to, _value); &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Asserts are used to use static analysis to find bugs in your code. They should never fail</span> &nbsp; &nbsp; &nbsp; &nbsp;assert(balanceOf[_from] + balanceOf[_to] == previousBalances); &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Transfer tokens &nbsp; &nbsp; * &nbsp; &nbsp; * Send `_value` tokens to `_to` from your account &nbsp; &nbsp; * &nbsp; &nbsp; * @param _to The address of the recipient &nbsp; &nbsp; * @param _value the amount to send &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">transfer</span><span class="hljs-params">(address _to, uint256 _value)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;_transfer(msg.sender, _to, _value); &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Transfer tokens from other address &nbsp; &nbsp; * &nbsp; &nbsp; * Send `_value` tokens to `_to` on behalf of `_from` &nbsp; &nbsp; * &nbsp; &nbsp; * @param _from The address of the sender &nbsp; &nbsp; * @param _to The address of the recipient &nbsp; &nbsp; * @param _value the amount to send &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">transferFrom</span><span class="hljs-params">(address _from, address _to, uint256 _value)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">returns</span> <span class="hljs-params">(bool success)</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Check allowance</span> &nbsp; &nbsp; &nbsp; &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp;_transfer(_from, _to, _value); &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">return</span> <span class="hljs-literal">true</span>; &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Set allowance for other address &nbsp; &nbsp; * &nbsp; &nbsp; * Allows `_spender` to spend no more than `_value` tokens on your behalf &nbsp; &nbsp; * &nbsp; &nbsp; * @param _spender The address authorized to spend &nbsp; &nbsp; * @param _value the max amount they can spend &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">approve</span><span class="hljs-params">(address _spender, uint256 _value)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">returns</span> <span class="hljs-params">(bool success)</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;allowance[msg.sender][_spender] = _value; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">return</span> <span class="hljs-literal">true</span>; &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Set allowance for other address and notify &nbsp; &nbsp; * &nbsp; &nbsp; * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it &nbsp; &nbsp; * &nbsp; &nbsp; * @param _spender The address authorized to spend &nbsp; &nbsp; * @param _value the max amount they can spend &nbsp; &nbsp; * @param _extraData some extra information to send to the approved contract &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">approveAndCall</span><span class="hljs-params">(address _spender, uint256 _value, bytes _extraData)</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">returns</span> <span class="hljs-params">(bool success)</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;tokenRecipient spender = tokenRecipient(_spender); &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">if</span> (approve(_spender, _value)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spender.receiveApproval(msg.sender, _value, <span class="hljs-keyword" style="font-weight:bold;">this</span>, _extraData); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">return</span> <span class="hljs-literal">true</span>; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Destroy tokens &nbsp; &nbsp; * &nbsp; &nbsp; * Remove `_value` tokens from the system irreversibly &nbsp; &nbsp; * &nbsp; &nbsp; * @param _value the amount of money to burn &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">burn</span><span class="hljs-params">(uint256 _value)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">returns</span> <span class="hljs-params">(bool success)</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(balanceOf[msg.sender] &gt;= _value); &nbsp; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Check if the sender has enough</span> &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Subtract from the sender</span> &nbsp; &nbsp; &nbsp; &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Updates totalSupply</span> &nbsp; &nbsp; &nbsp; &nbsp;Burn(msg.sender, _value); &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">return</span> <span class="hljs-literal">true</span>; &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Destroy tokens from other account &nbsp; &nbsp; * &nbsp; &nbsp; * Remove `_value` tokens from the system irreversibly on behalf of `_from`. &nbsp; &nbsp; * &nbsp; &nbsp; * @param _from the address of the sender &nbsp; &nbsp; * @param _value the amount of money to burn &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">burnFrom</span><span class="hljs-params">(address _from, uint256 _value)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">returns</span> <span class="hljs-params">(bool success)</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Check if the targeted balance is enough</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Check allowance</span> &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Subtract from the targeted balance</span> &nbsp; &nbsp; &nbsp; &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Subtract from the sender's allowance</span> &nbsp; &nbsp; &nbsp; &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Update totalSupply</span> &nbsp; &nbsp; &nbsp; &nbsp;Burn(_from, _value); &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">return</span> <span class="hljs-literal">true</span>; &nbsp; &nbsp;} }</p>
   <blockquote style="border-left-width:4px;border-left-color:rgb(221,221,221);font-size:15px;color:rgb(119,119,119);">
    <p style="color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:rgb(136,136,136);">我只是想割韭菜而已，用得着写几百行代码吗？</span></p>
   </blockquote>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">当然不必，这时我们就需要使用到智能合约开发框架 OpenZeppelin&nbsp;<span style="color:rgb(136,136,136);">(https://openzeppelin.org)</span>，安装命令如下。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">npm install zeppelin-solidity --save</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:#000000;">GitCoin.sol</span></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">引入 OpenZeppelin，代码如下。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 声明 solidity 编译版本</span>pragma solidity ^<span class="hljs-number" style="color:rgb(0,128,128);">0.4.18</span>;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 引入框架为我们提供的编写好的 ERC20 Token 的代码</span>import <span class="hljs-string" style="color:rgb(221,17,68);">"zeppelin-solidity/contracts/token/StandardToken.sol"</span>;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 通过 is 关键字继承 StandardToken</span>contract GitToken is StandardToken { &nbsp;string public name = <span class="hljs-string" style="color:rgb(221,17,68);">"GitToken"</span>; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Token 名称</span> &nbsp;string public symbol = <span class="hljs-string" style="color:rgb(221,17,68);">"EGT"</span>; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Token 标识 例如：ETH/EOS</span> &nbsp;uint public decimals = <span class="hljs-number" style="color:rgb(0,128,128);">18</span>; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 计量单位，和 ETH 保持一样就设置为 18</span> &nbsp;uint public INITIAL_SUPPLY = <span class="hljs-number" style="color:rgb(0,128,128);">10000</span> * (<span class="hljs-number" style="color:rgb(0,128,128);">10</span> ** decimals); <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 初始供应量</span> &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 与 contract 同名的函数为本 contract 的构造方法，类似于 JavaScript 当中的 constructor</span> &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">GitToken</span><span class="hljs-params">()</span> </span>{ &nbsp; &nbsp;totalSupply = INITIAL_SUPPLY; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 设置初始供应量</span> &nbsp; &nbsp;balances[msg.sender] = INITIAL_SUPPLY; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 将所有初始 token 都存入 contract 创建者的余额</span> &nbsp;} }</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">好了，至此一个可以用来交易的符合 ERC20 标准的 token 就编写完毕了。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">就这么简单？就这么简单！当然智能合约的功能不止如此，token 中可以玩转设计的地方也不止这些。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">不过我们要稍微放在后面一些来讨论，接下来还是赶快着手 ICO 合约开发，为我们的项目募集资金吧。</p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">ICO Crowdsale 合约开发</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">同样，以太坊官网文档在教程 CROWDSALE Raising funds from friends without a third party<span style="color:rgb(136,136,136);">&nbsp;(https://www.ethereum.org/crowdsale)</span>&nbsp;中也为我们提供了用来 crowdsale 做 ICO 募资的示例代码：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">pragma solidity ^<span class="hljs-number" style="color:rgb(0,128,128);">0.4.18</span>;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** * interface 的概念和其他编程语言当中类似，在这里相当于我们可以通过传参引用之前发布的 token 合约 * 我们只需要使用其中的转账 transfer 方法，所以就只声明 transfer **/</span>interface token { &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">transfer</span><span class="hljs-params">(address receiver, uint amount)</span>; }<span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">contract</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">Crowdsale</span> </span>{ &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 这里是发布合约时需要传入的参数</span> &nbsp; &nbsp;address public beneficiary; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// ICO 募资成功后的收款方</span> &nbsp; &nbsp;uint public fundingGoal; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 骗多少钱</span> &nbsp; &nbsp;uint public amountRaised; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 割到多少韭菜</span> &nbsp; &nbsp;uint public deadline; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 割到啥时候</span> &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp;* 卖多贵，即你的 token 与以太坊的汇率，你可以自己设定 &nbsp; &nbsp;* 注意到，ICO 当中 token 的价格是由合约发布方自行设定而不是市场决定的 &nbsp; &nbsp;* 也就是说你项目值多少钱你可以自己编 &nbsp; &nbsp;**/</span> &nbsp; &nbsp;uint public price; &nbsp; &nbsp;token public tokenReward; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 你要卖的 token</span> &nbsp; &nbsp;mapping(address =&gt; uint256) public balanceOf; &nbsp; &nbsp;bool fundingGoalReached = <span class="hljs-literal">false</span>; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 是否达标</span> &nbsp; &nbsp;bool crowdsaleClosed = <span class="hljs-literal">false</span>; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 售卖是否结束</span> &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp;* 事件可以用来记录信息，每次调用事件方法时都能将相关信息存入区块链中 &nbsp; &nbsp;* 可以用作凭证，也可以在你的 Dapp 中查询使用这些数据 &nbsp; &nbsp;**/</span> &nbsp; &nbsp;event GoalReached(address recipient, uint totalAmountRaised); &nbsp; &nbsp;event FundTransfer(address backer, uint amount, bool isContribution); &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Constrctor function &nbsp; &nbsp; * &nbsp; &nbsp; * Setup the owner &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">Crowdsale</span><span class="hljs-params">( &nbsp; &nbsp; &nbsp; &nbsp;address ifSuccessfulSendTo, &nbsp; &nbsp; &nbsp; &nbsp;uint fundingGoalInEthers, &nbsp; &nbsp; &nbsp; &nbsp;uint durationInMinutes, &nbsp; &nbsp; &nbsp; &nbsp;uint etherCostOfEachToken, &nbsp; &nbsp; &nbsp; &nbsp;address addressOfTokenUsedAsReward &nbsp; &nbsp;)</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;beneficiary = ifSuccessfulSendTo; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoal = fundingGoalInEthers * <span class="hljs-number" style="color:rgb(0,128,128);">1</span> ether; &nbsp; &nbsp; &nbsp; &nbsp;deadline = now + durationInMinutes * <span class="hljs-number" style="color:rgb(0,128,128);">1</span> minutes; &nbsp; &nbsp; &nbsp; &nbsp;price = etherCostOfEachToken * <span class="hljs-number" style="color:rgb(0,128,128);">1</span> ether; &nbsp; &nbsp; &nbsp; &nbsp;tokenReward = token(addressOfTokenUsedAsReward); <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 传入已发布的 token 合约的地址来创建实例</span> &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Fallback function &nbsp; &nbsp; * &nbsp; &nbsp; * payable 用来指明向合约付款时调用的方法 &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-params">()</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">payable</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(!crowdsaleClosed); &nbsp; &nbsp; &nbsp; &nbsp;uint amount = msg.value; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] += amount; &nbsp; &nbsp; &nbsp; &nbsp;amountRaised += amount; &nbsp; &nbsp; &nbsp; &nbsp;tokenReward.transfer(msg.sender, amount / price); &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(msg.sender, amount, <span class="hljs-literal">true</span>); &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp;* modifier 可以理解为其他语言中的装饰器或中间件 &nbsp; &nbsp;* 当通过其中定义的一些逻辑判断通过之后才会继续执行该方法 &nbsp; &nbsp;* _ 表示继续执行之后的代码 &nbsp; &nbsp;**/</span> &nbsp; &nbsp;modifier afterDeadline() { <span class="hljs-keyword" style="font-weight:bold;">if</span> (now &gt;= deadline) _; } &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Check if goal was reached &nbsp; &nbsp; * &nbsp; &nbsp; * Checks if the goal or time limit has been reached and ends the campaign &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">checkGoalReached</span><span class="hljs-params">()</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">afterDeadline</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">if</span> (amountRaised &gt;= fundingGoal){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoalReached = <span class="hljs-literal">true</span>; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GoalReached(beneficiary, amountRaised); &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;crowdsaleClosed = <span class="hljs-literal">true</span>; &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp; &nbsp; * Withdraw the funds &nbsp; &nbsp; * &nbsp; &nbsp; * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached, &nbsp; &nbsp; * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw &nbsp; &nbsp; * the amount they contributed. &nbsp; &nbsp; */</span> &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">safeWithdrawal</span><span class="hljs-params">()</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">afterDeadline</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">if</span> (!fundingGoalReached) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uint amount = balanceOf[msg.sender]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = <span class="hljs-number" style="color:rgb(0,128,128);">0</span>; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">if</span> (amount &gt; <span class="hljs-number" style="color:rgb(0,128,128);">0</span>) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">if</span> (msg.sender.send(amount)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(msg.sender, amount, <span class="hljs-literal">false</span>); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} <span class="hljs-keyword" style="font-weight:bold;">else</span> { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;balanceOf[msg.sender] = amount; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">if</span> (fundingGoalReached &amp;&amp; beneficiary == msg.sender) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">if</span> (beneficiary.send(amountRaised)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FundTransfer(beneficiary, amountRaised, <span class="hljs-literal">false</span>); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} <span class="hljs-keyword" style="font-weight:bold;">else</span> { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">//If we fail to send the funds to beneficiary, unlock funders balance</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fundingGoalReached = <span class="hljs-literal">false</span>; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;} }</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">至此我们的 ICO 合约也开发完毕了，基本上一行代码都没有写，只是改了几个参数，一个键盘上只有三个按键的程序员都能够完成这类智能合约的开发，没有比这更友好的编程体验了。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">虽然 solidity 是一种非图灵完备的编程语言，但我们仍然能够用它编写许多逻辑。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">上述的 ICO 示例代码写得算比较客气的一种，在最后的提款方法中，如果筹资达标，ICO 发布方则可以取走所有筹款，而如果未达标，参与者则能够取回自己的投资，由合约来持有所有款项。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">但事实上，我们仍然可以随意修改其中的逻辑，看下面代码。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-params">()</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">payable</span> </span>{ &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(!crowdsaleClosed); &nbsp;uint amount = msg.value; &nbsp;balanceOf[msg.sender] += amount; &nbsp;amountRaised += amount; &nbsp;tokenReward.transfer(msg.sender, amount / price); &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 每次有人付款直接取走筹资</span> &nbsp;beneficiary.send(amountRaised); &nbsp;amountRaised = <span class="hljs-number" style="color:rgb(0,128,128);">0</span>; &nbsp;FundTransfer(msg.sender, amount, <span class="hljs-literal">true</span>); }<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 删除剩余代码</span></p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">补充说明与权限控制</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">既然咱是铁了心来割韭菜的，如此简单的代码怎么能够满足咱的贪欲呢？一定要学比特币固定供给量吗？</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">我是来卖 token 的呀，万一有一天卖完了怎么办，万一有人手里筹码比我自己都多了控盘怎么办，万一发的数量太多卖的不好怎么办？</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">事实上解决这些问题的逻辑全部都可以写在智能合约里。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:#000000;">Ownable token</span></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">在我们的潜在观念里，区块链自有不可变属性。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">这种不可变属性在一些狂热信徒的演绎当中变成了平权属性，甚至带有了共产主义色彩，仿佛拥抱区块链技术就能够为未来的人类文明带来希望，把人民从集权的手中解救出来。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">然而事实上这种不可变性同样是两面的，它能够带来的也包括所有权的不可变性。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">ERC20 标准只规定了我们的合约中应该包含哪些方法，而没有限制合约中不能出现哪些方法，因此在之前的基础上，我们还可以继续编写一些特殊的方法，赋予合约发布者一些管理员特权。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">请看下面代码：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">contract Ownable { &nbsp; &nbsp;address public owner; &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">Ownable</span><span class="hljs-params">()</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;owner = msg.sender; &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 通过 onlyOwner 我们可以限定一些方法只有所有者才能够调用</span> &nbsp; &nbsp;modifier onlyOwner { &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(msg.sender == owner); &nbsp; &nbsp; &nbsp; &nbsp;_; &nbsp; &nbsp;} &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">transferOwnership</span><span class="hljs-params">(address newOwner)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">onlyOwner</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;owner = newOwner; &nbsp; &nbsp;} }<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 合约可以同时有多个继承</span>contract GitToken is StandardToken, Ownable { &nbsp;...</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:#000000;">MintableToken</span></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">接下来我们来解决 token 不够卖的问题，万一我的 initial offer 卖断货了怎么办，万一我卖完一次还想卖怎么办？</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">这时我们就需要把 token 编写成为 MintableToken，在我们想增发的时候就能增发，代码如下：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 用 onlyOwner 限定只有 token 的所有者才能够进行增发操作</span><span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">mint</span><span class="hljs-params">(address _to, uint256 _amount)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">onlyOwner</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">returns</span> <span class="hljs-params">(bool)</span> </span>{ &nbsp;totalSupply_ = totalSupply_.add(_amount); &nbsp;balances[_to] = balances[_to].add(_amount); &nbsp;Mint(_to, _amount); &nbsp;Transfer(address(<span class="hljs-number" style="color:rgb(0,128,128);">0</span>), _to, _amount); &nbsp;<span class="hljs-keyword" style="font-weight:bold;">return</span> <span class="hljs-literal">true</span>; }</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:#000000;">BurnableToken</span></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">万一我们的 token 不小心发了太多，卖的时间久了贬值怎么办？</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">当然是销毁了，可参照下面代码：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */</span><span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">burn</span><span class="hljs-params">(uint256 _value)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">returns</span> <span class="hljs-params">(bool success)</span> </span>{ &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(balanceOf[msg.sender] &gt;= _value); &nbsp; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Check if the sender has enough</span> &nbsp;balanceOf[msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Subtract from the sender</span> &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Updates totalSupply</span> &nbsp;Burn(msg.sender, _value); &nbsp;<span class="hljs-keyword" style="font-weight:bold;">return</span> <span class="hljs-literal">true</span>; }</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">万一有人手里的筹码太多，或者 token 被竞争对手买走了怎么办？没关系，我们还可以指定销毁某一账户中的 token，请看下面代码：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">/** &nbsp;* Destroy tokens from other account &nbsp;* &nbsp;* Remove `_value` tokens from the system irreversibly on behalf of `_from`. &nbsp;* &nbsp;* @param _from the address of the sender &nbsp;* @param _value the amount of money to burn &nbsp;*/</span><span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">burnFrom</span><span class="hljs-params">(address _from, uint256 _value)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">public</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">returns</span> <span class="hljs-params">(bool success)</span> </span>{ &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(balanceOf[_from] &gt;= _value); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Check if the targeted balance is enough</span> &nbsp;<span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(_value &lt;= allowance[_from][msg.sender]); &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Check allowance</span> &nbsp;balanceOf[_from] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Subtract from the targeted balance</span> &nbsp;allowance[_from][msg.sender] -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Subtract from the sender's allowance</span> &nbsp;totalSupply -= _value; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Update totalSupply</span> &nbsp;Burn(_from, _value); &nbsp;<span class="hljs-keyword" style="font-weight:bold;">return</span> <span class="hljs-literal">true</span>; }</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">只要上述的方法全部都出现在合约里，我们发布的 token 就能够具备上述所有属性。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">这样一来，不够的时候我们可以发钱，发多了可以销毁，我们成功创建了属于自己的一所中央银行，甚至看某人不爽还能够指定销毁其账户存款，这哪里是平权，简直是超级集权。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">而事实上，在已发布的 ERC20 token 当中，例如排名第一的 EOS 的合约&nbsp;<span style="color:rgb(136,136,136);">(https://goo.gl/L2AmQP)&nbsp;</span>里也是存在类似方法的，如下所示。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">mint</span><span class="hljs-params">(uint128 wad)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">auth</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">stoppable</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">note</span> </span>{ &nbsp;_balances[msg.sender] = add(_balances[msg.sender], wad); &nbsp;_supply = add(_supply, wad); }<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">burn</span><span class="hljs-params">(uint128 wad)</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">auth</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">stoppable</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">note</span> </span>{ &nbsp;_balances[msg.sender] = sub(_balances[msg.sender], wad); &nbsp;_supply = sub(_supply, wad); }</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">当然在其官方网站和白皮书中是标明了会发布多少 token，创始团队持有多少，投资人分配多少，公开发布多少，如何销毁等内容的。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">但白皮书又不具备法律效力，token 的所有权也不在你手里，万一人家哪天想要跑路或者中途变卦岂是咱能拦得住的。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">换个角度讲，假如你现在手里有一家可以印钱的公司，印多少就有多少，你印还是不印？</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">通过这一部分内容的介绍，我只是想要证明，智能合约本身并不具备可无条件信任的特性，充其量就是一段没法改一直跑的程序而已。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">你也可以在逻辑中加入管理员权限，token 的发布方并不比央行可信多少，只要所有者愿意可以随时进行修改。以太坊官方宣传的所谓 “trustless” 这一概念根本不成立。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc32rOO49iaIMAjoTJRGfBSg3hOKXWzOrOSMoUib2d9spriblfS2b5wTYUHg/640?wx_fmt=png" style="width:654px;" alt=""></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">没有第三方担保，没有法律法规的维护，仅凭智能合约本身你的投资得不到任何保证。智能合约的不可变性反而给割韭菜的一方提供了巨大的便利。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">从前你看不惯某家公司还能够黑掉它的系统，获取管理员权限，如今所有程序都跑在区块链上，黑无可黑，集权永远都在合约发布者的手里。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">讲到这里，希望你能理解这次分享的良苦用心，不要轻信任何 ICO 项目。</p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">合约的发布及调试</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:#000000;">本地开发环境发布</span></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">合约开发完成之后，我们需要编译并发布合约至区块链网络中，只需要进行以下两步操作。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">首先在&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">migrations</code>&nbsp;文件夹下新建&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">2-deploy-contract.js</code>&nbsp;文件，配置部署脚本如下。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 引入我们编写的合约</span><span class="hljs-keyword" style="font-weight:bold;">const</span> GitCoin = artifacts.require(<span class="hljs-string" style="color:rgb(221,17,68);">"./GitCoin.sol"</span>)<span class="hljs-keyword" style="font-weight:bold;">const</span> GitCoinCrowdsale = artifacts.require(<span class="hljs-string" style="color:rgb(221,17,68);">"./GitCoinCrowdsale.sol"</span>)<span class="hljs-built_in" style="color:rgb(0,134,179);">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span><span class="hljs-params">(deployer, network, accounts)</span> </span>{ &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 设定参数，此处的参数即使传入合约构造方法的参数，与你自己编写的合约保持一致</span> &nbsp;<span class="hljs-keyword" style="font-weight:bold;">const</span> ifSuccessfulSendTo = accounts[<span class="hljs-number" style="color:rgb(0,128,128);">0</span>] <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 当前以太坊网络中的默认账户</span> &nbsp;<span class="hljs-keyword" style="font-weight:bold;">const</span> fundingGoalInEthers = <span class="hljs-number" style="color:rgb(0,128,128);">1000</span> &nbsp;<span class="hljs-keyword" style="font-weight:bold;">const</span> durationInMinutes = <span class="hljs-number" style="color:rgb(0,128,128);">36000000</span> &nbsp;<span class="hljs-keyword" style="font-weight:bold;">const</span> etherCostOfEachToken = <span class="hljs-number" style="color:rgb(0,128,128);">0.01</span> &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 这里的 Promise 可以保证我们在发布完 token 合约之后再发布 ICO 合约，并将已发布 token 的地址作为参数传入</span> &nbsp;deployer.deploy(GitCoin).then(<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span><span class="hljs-params">()</span> </span>{ &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">return</span> deployer.deploy(GitCoinCrowdsale, ifSuccessfulSendTo, fundingGoalInEthers, durationInMinutes, etherCostOfEachToken, GitCoin.address); &nbsp;}); };</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">接着在&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">truffle-config.js</code>&nbsp;或&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">truffle.js</code>&nbsp;中设置发布网络，脚本如下。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-built_in" style="color:rgb(0,134,179);">module</span>.exports = { &nbsp;networks: { &nbsp; &nbsp;development: { &nbsp; &nbsp; &nbsp;host: <span class="hljs-string" style="color:rgb(221,17,68);">"127.0.0.1"</span>, &nbsp; &nbsp; &nbsp;port: <span class="hljs-number" style="color:rgb(0,128,128);">7545</span>, <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 与你本地的 ganache 设置保持一致</span> &nbsp; &nbsp; &nbsp;network_id: <span class="hljs-string" style="color:rgb(221,17,68);">"*"</span> <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// Match any network id</span> &nbsp; &nbsp;} &nbsp;} };</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">现在只需要开启 Ganache：</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loading" style="width:558px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc32OQnCMCzlCj1nqZ7TTgDCG7q0ibOfBaPIxGTNoiapI0zXHwHwTb6avYQ/640?wx_fmt=jpeg" alt=""></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">然后在命令行中输入：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">truffle compile truffle migrate</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">你的合约就会顺利发布至测试网络中了。然后你可以输入：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">truffle console</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">这样就能够进入本地的命令行调试了：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;"># 所有的合约方法都是 Promise 对象</span>truffle(development)&gt; GitCoinCrowdsale.deployed().then(inst=&gt;{crowd=inst}) truffle(development)&gt; GitCoin.deployed().then(inst=&gt;{git=inst}) truffle(development)&gt; crowd.sendTransaction({from:web3.eth.accounts[<span class="hljs-number" style="color:rgb(0,128,128);">0</span>],value:web3.toWei(<span class="hljs-number" style="color:rgb(0,128,128);">1</span>, <span class="hljs-string" style="color:rgb(221,17,68);">"ether"</span>)}) truffle(development)&gt; git.mint(web3.eth.accounts[<span class="hljs-number" style="color:rgb(0,128,128);">0</span>],web3.toWei(<span class="hljs-number" style="color:rgb(0,128,128);">100</span>, <span class="hljs-string" style="color:rgb(221,17,68);">"ether"</span>))</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:#000000;">线上测试网络发布</span></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">以太坊网络分为测试网和主网，在正式发布主网之前，我们可以先发送到测试网络进行调试。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">发布至以太坊网络也无需同步完整节点，我们可以使用 Infura 为我们提供的公共接口。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc3cciafOibQ9TVrIgPQjrZBCANfQ3jxb3nnp3Oqkg1Do79UxR4kv9GLhgw/640?wx_fmt=png" style="width:654px;" alt=""></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">填写表单提交后，Infura 会为你提供专用的接口地址，然后我们只需要将网络地址填入到配置文件中，如下所示。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-keyword" style="font-weight:bold;">var</span> HDWalletProvider = <span class="hljs-built_in" style="color:rgb(0,134,179);">require</span>(<span class="hljs-string" style="color:rgb(221,17,68);">"truffle-hdwallet-provider"</span>); <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 在这里我们需要通过 js 调用以太坊钱包，通过 npm install truffle-hdwallet-provider 安装这个库</span><span class="hljs-keyword" style="font-weight:bold;">var</span> infura_apikey = <span class="hljs-string" style="color:rgb(221,17,68);">"ubQWERwasd"</span>; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// infura 为你提供的 apikey 请与你申请到的 key 保持一致，此处仅为示例</span><span class="hljs-keyword" style="font-weight:bold;">var</span> mnemonic = <span class="hljs-string" style="color:rgb(221,17,68);">"apple banana carray dog egg fault great"</span>; <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 你以太坊钱包的 mnemonic ，可以从 Metamask 当中导出，mnemonic 可以获取你钱包的所有访问权限，请妥善保存，在开发中切勿提交到 git</span><span class="hljs-built_in" style="color:rgb(0,134,179);">module</span>.exports = { &nbsp;networks: { &nbsp; &nbsp;development: { &nbsp; &nbsp; &nbsp;host: <span class="hljs-string" style="color:rgb(221,17,68);">"127.0.0.1"</span>, &nbsp; &nbsp; &nbsp;port: <span class="hljs-number" style="color:rgb(0,128,128);">7545</span>, &nbsp; &nbsp; &nbsp;network_id: <span class="hljs-string" style="color:rgb(221,17,68);">"*"</span> &nbsp; &nbsp;}, &nbsp; &nbsp;ropsten: { &nbsp; &nbsp; &nbsp;provider: <span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span><span class="hljs-params">()</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">return</span> <span class="hljs-keyword" style="font-weight:bold;">new</span> HDWalletProvider(mnemonic, <span class="hljs-string" style="color:rgb(221,17,68);">"https://ropsten.infura.io/"</span>+infura_apikey) &nbsp; &nbsp; &nbsp;}, &nbsp; &nbsp; &nbsp;network_id: <span class="hljs-number" style="color:rgb(0,128,128);">3</span>, &nbsp; &nbsp; &nbsp;gas: <span class="hljs-number" style="color:rgb(0,128,128);">3012388</span>, &nbsp; &nbsp; &nbsp;gasPrice: <span class="hljs-number" style="color:rgb(0,128,128);">30000000000</span> &nbsp; &nbsp;}, &nbsp; &nbsp;main: { &nbsp; &nbsp; &nbsp;provider: <span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span><span class="hljs-params">()</span> </span>{ &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword" style="font-weight:bold;">return</span> <span class="hljs-keyword" style="font-weight:bold;">new</span> HDWalletProvider(mnemonic, <span class="hljs-string" style="color:rgb(221,17,68);">"https://mainnet.infura.io/"</span>+infura_apikey) &nbsp; &nbsp; &nbsp;}, &nbsp; &nbsp; &nbsp;network_id: <span class="hljs-number" style="color:rgb(0,128,128);">3</span>, &nbsp; &nbsp; &nbsp;gas: <span class="hljs-number" style="color:rgb(0,128,128);">3012388</span>, &nbsp; &nbsp; &nbsp;gasPrice: <span class="hljs-number" style="color:rgb(0,128,128);">1000000000</span> &nbsp; &nbsp;} &nbsp;} };</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">在以太坊网络中发布合约需要使用 ETH 支付矿工的 gas 费用，你可以在 Ethereum Ropsten Faucet<span style="color:rgb(136,136,136);">&nbsp;(http://faucet.ropsten.be:3001)&nbsp;</span>免费获取到用于 Ropsten 测试网络的 ETH。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc3xolOJx7oDwhpQXbBibzxufs2UwgL48eR0spqQmVictmZVn0CVSLZBubQ/640?wx_fmt=png" style="width:654px;" alt=""></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">由于网络环境的变化，不同的拥堵状况可能造成燃料费用和消耗的不同。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">如果发布不成功，可以调整&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">gas/gasPrice</code>&nbsp;的数值，你可以通过&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">web3.getBlock('latest').gasLimit</code>&nbsp;这一数值判断当前网络的消耗。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">在命令行输入如下命令：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">truffle migrate --network ropsten</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">通过&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">--network</code>&nbsp;设置发布的目标网络。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:#000000;">主网络发布</span></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">同理，在发布至主网络时，只需要执行如下命令。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">truffle migrate --network main</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">但由于当前的以太坊网络的现实状况，如果设置燃料费太低，可能要等待数天后合约才会被网络确认，注意到我们编写的发布脚本是需要合约地址回调的。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">介于这种状况，我们可以将 token 合约和 crowdsale 合约分开发布，只需要再新建&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">3-deploy-crowdsale.js</code>&nbsp;文件，脚本如下。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-keyword" style="font-weight:bold;">const</span> LeekCoinCrowdsale = artifacts.require(<span class="hljs-string" style="color:rgb(221,17,68);">"./GitCoinCrowdsale.sol"</span>)<span class="hljs-built_in" style="color:rgb(0,134,179);">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span><span class="hljs-params">(deployer, network, accounts)</span> </span>{ &nbsp;<span class="hljs-keyword" style="font-weight:bold;">const</span> ifSuccessfulSendTo = accounts[<span class="hljs-number" style="color:rgb(0,128,128);">0</span>] &nbsp;<span class="hljs-keyword" style="font-weight:bold;">const</span> fundingGoalInEthers = <span class="hljs-number" style="color:rgb(0,128,128);">1000</span> &nbsp;<span class="hljs-keyword" style="font-weight:bold;">const</span> durationInMinutes = <span class="hljs-number" style="color:rgb(0,128,128);">36000</span> &nbsp;<span class="hljs-keyword" style="font-weight:bold;">const</span> etherCostOfEachToken = <span class="hljs-number" style="color:rgb(0,128,128);">0.01</span> &nbsp;<span class="hljs-keyword" style="font-weight:bold;">const</span> tokenAddress = <span class="hljs-string" style="color:rgb(221,17,68);">'0x123456789ABCDFGHSDWDVC'</span> <span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 先单独发布 token 合约，上线成功后将其合约地址填在此处</span> &nbsp;deployer.deploy(GitCoinCrowdsale, ifSuccessfulSendTo, fundingGoalInEthers, durationInMinutes, etherCostOfEachToken, tokenAddress); };</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">在发布至主网络时，可以分开两次进行，确保你设置的账户里有真实的 ETH 余额，注意设置好合理的 gas 数值，根据确认时间的长短，可能需要 0.08~1 ETH 不等。</p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">上线合约验证</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">无论是发布至以太坊的测试网络还是主网络，在发布完成之后都需要在 Etherscan&nbsp;<span style="color:rgb(136,136,136);">(https://etherscan.io)&nbsp;</span>进行线上验证。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">在 Etherscan 上打开你刚刚发布的合约地址，你可以看到如下内容：</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loading" style="width:556px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc39U9jlbpL83FEMpibLlnNv9RqLmadR02IkUutNibJ6uxhwpTREPzHicOzA/640?wx_fmt=jpeg" alt=""></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">点击&nbsp;<span style="color:#000000;">Verify And Publish</span>&nbsp;链接就可以进入验证页面：</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc3bzzibvNKJZqmVFNTCiaj74fAwXffIryiazR6djoy2fJSM4yMcOSkD1g2A/640?wx_fmt=png" style="width:654px;" alt=""></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">在填写表单时有以下注意事项。</p>
   <ol class="list-paddingleft-2" style="margin-left:8px;">
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">Compiler 选择最新版本；</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">Optimization 选择 No。</span></p></li>
   </ol>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">虽然 solidity 支持 import 语法，但 Etherscan 对使用 import 进行开发的合约支持很鸡肋，目前它要求你需要把库文件也当作合约发布至网络才能够在表单中填写进行验证。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">当然我们也可以选择手动把 import 库文件的内容手动复制粘贴到代码框里，注意要保留全部内容，包括 pragma 声明一行。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">当然你也可以选择使用官方的 Remix&nbsp;<span style="color:rgb(136,136,136);">(https://remix.ethereum.org/)&nbsp;</span>预先 concrete 你的合约文件，也可以安装 solidity compiler<span style="color:rgb(136,136,136);">&nbsp;(https://goo.gl/aKsXxH)&nbsp;</span>在本地编译好再发布。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">ICO 和 token 的合约如此简单，根本不需要这些玩意儿，所以此处不再赘述，感兴趣的同学可以自行研究。</p>
   <h3 style="font-weight:bold;font-size:18px;color:rgb(240,150,28);line-height:1.75em;">Dapp 开发</h3>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">智能合约相当于我们的后端逻辑，以太坊的 EVM 就是我们的云服务器，Infura 为我们提供 API 接口，接下来我们就只需要给韭菜开发一个可以花钱消费的前端界面了。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">ICO 项目的网站把握以下几个原则就好。</p>
   <ol class="list-paddingleft-2" style="margin-left:8px;">
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">文字不要太多，页面要大片留白，简洁明了有现代感；</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">配色一定要深，加上动态几何图形，设计要有未来感；</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">开发团队全配齐，不是常春藤，没有硅谷背景的不要，一定要国际化；</span></p></li>
    <li><p style="line-height:1.75em;"><span style="color:rgb(85,85,85);font-size:15px;">各种站台大佬，海量媒体报道，一线互联网公司合作全放上去。</span></p></li>
   </ol>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">言归正传，我们还是专注于技术。</p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">web3.js 的使用</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">web3.js&nbsp;<span style="color:rgb(136,136,136);">(https://github.com/ethereum/web3.js)&nbsp;</span>为我们提供了一系列访问以太坊网络的 JavaScript 编程接口，完整的说明文档可以在 web3.js Doc&nbsp;<span style="color:rgb(136,136,136);">(https://goo.gl/zp2yEQ)</span>&nbsp;中参阅。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">我们一般通过如下脚本来初始化 web3 对象。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 判断当前浏览器中有未注入 web3 对象</span><span class="hljs-keyword" style="font-weight:bold;">if</span> (<span class="hljs-keyword" style="font-weight:bold;">typeof</span> web3 !== <span class="hljs-string" style="color:rgb(221,17,68);">'undefined'</span>) { &nbsp;App.web3Provider = web3.currentProvider; &nbsp;web3 = <span class="hljs-keyword" style="font-weight:bold;">new</span> Web3(web3.currentProvider); } <span class="hljs-keyword" style="font-weight:bold;">else</span> { &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 注意设置到你自己的 infura 地址</span> &nbsp;App.web3Provider = <span class="hljs-keyword" style="font-weight:bold;">new</span> Web3.providers.HttpProvider(<span class="hljs-string" style="color:rgb(221,17,68);">'https://ropsten.infura.io/ubQWERawsd'</span>); &nbsp;web3 = <span class="hljs-keyword" style="font-weight:bold;">new</span> Web3(App.web3Provider); }</p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">Metamask 简介</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">Metamask&nbsp;<span style="color:rgb(136,136,136);">(https://metamask.io)&nbsp;</span>是一个浏览器插件，通过 Metamask 我们可以在浏览器中使用以太坊钱包，在访问 Dapp 应用时，也可以为其注入 web3 对象。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">具体配合应用开发的文档可以在 MetaMask Compatibility Guide&nbsp;<span style="color:rgb(136,136,136);">(https://goo.gl/7wKPtp)</span>&nbsp;查阅，一般我们通过如下脚本来监测 Metamask 状态获取以太坊账户。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-keyword" style="font-weight:bold;">var</span> account = web3.eth.accounts[<span class="hljs-number" style="color:rgb(0,128,128);">0</span>];<span class="hljs-keyword" style="font-weight:bold;">var</span> accountInterval = setInterval(<span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span><span class="hljs-params">()</span> </span>{ &nbsp;<span class="hljs-keyword" style="font-weight:bold;">if</span> (web3.eth.accounts[<span class="hljs-number" style="color:rgb(0,128,128);">0</span>] !== account) { &nbsp; &nbsp;account = web3.eth.accounts[<span class="hljs-number" style="color:rgb(0,128,128);">0</span>]; &nbsp; &nbsp;updateInterface(); &nbsp;} }, <span class="hljs-number" style="color:rgb(0,128,128);">100</span>);</p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">truffle-contract 的使用</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">web3.js 默认为我们提供的接口还是太底层，许多调用需要 hard code 设置参数，以太坊网络使用的 BigNumber 也需要我们手动转换。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">我们可以选择使用 truffle-contract<span style="color:rgb(136,136,136);">&nbsp;(https://github.com/trufflesuite/truffle-contract)</span>&nbsp;来调用更高一层的封装对象，并且在之前使用 truffle 开发构建的智能合约文件也能派上用场。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">我们可以在&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">build/contracts/</code>&nbsp;下找到编译好的&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">GitCoin.json</code>&nbsp;和&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">GitCoinCrowdsale.json</code>&nbsp;文件，之后可以在我们的应用中通过如下脚本获取合约对象。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-tag" style="color:rgb(0,0,128);">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute" style="color:rgb(0,128,128);">type</span>=<span class="hljs-value" style="color:rgb(221,17,68);">"text/javascript"</span> <span class="hljs-attribute" style="color:rgb(0,128,128);">src</span>=<span class="hljs-value" style="color:rgb(221,17,68);">"./dist/truffle-contract.min.js"</span>&gt;</span><span class="javascript"><span class="hljs-tag" style="color:rgb(0,0,128);">&lt;/<span class="hljs-title">script</span>&gt;&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword" style="font-weight:bold;">var</span> GitCoin; $.getJSON(<span class="hljs-string" style="color:rgb(221,17,68);">'contracts/GitCoin.json'</span>, <span class="hljs-function"><span class="hljs-keyword" style="font-weight:bold;">function</span><span class="hljs-params">(data)</span> </span>{ &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 获取编译好的合约文件</span> &nbsp;<span class="hljs-keyword" style="font-weight:bold;">var</span> GitCoinArtifact = data; &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 通过 truffle-contract 获取合约对象</span> &nbsp;GitCoin = TruffleContract(GitCoinArtifact); &nbsp;<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;">// 将合约绑定至当前 web3 对象</span> &nbsp;GitCoin.setProvider(App.web3Provider); });</span><span class="hljs-tag" style="color:rgb(0,0,128);">&lt;/<span class="hljs-title">script</span>&gt;</span></span></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">之后我们就可以像在&nbsp;<code style="margin-left:.15em;font-family:Consolas, Inconsolata, Courier, monospace;border-width:1px;border-style:solid;border-color:rgb(234,234,234);background-color:rgb(248,248,248);">truffle console</code>&nbsp;当中一样，对合约对象进行各种操作啦。</p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">ICO 前端应用开发</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">我们的 ICO 应用只需要解决一个核心需求，那就是买币；只需要两个核心功能，一个是选择买多少，另一个就是付款，所以我们的界面自然是相当简单，如下图所示。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc3f0hj9VokCqZBbImR0YkprhNDOZqKDyB12edThtiaL8BDcYNcEMO9fhQ/640?wx_fmt=png" style="width:237px;" alt=""></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">然后再稍微美化一下，如下面两张图所示。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc3j1GR3jvIUWY2TicicSD4DRETvzIJIk2PPG1Q2XBfbMYvBDSq4VibEfhAg/640?wx_fmt=png" style="width:654px;" alt=""><img class="img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/0vU1ia3htaaNic0qibwlzIZSP8LeEbUEUc3WvQSNUmFFSKjQIVHOhiavkqpuJ3a7VU0SicelVvYZ3CtkGib97NjbIsOQ/640?wx_fmt=png" style="width:654px;" alt=""></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">一场成功的 ICO，自然需要精雕细琢，完整的代码示例可以在 Leek Ecological Chain<span style="color:rgb(136,136,136);">&nbsp;(http://lec.yubolun.com/)</span>&nbsp;找到，同时此网站也是上述教程的一个完整示例，你可以切换到 Ropsten 网络在本网站上购买 LEC<span style="color:rgb(136,136,136);">&nbsp;(https://goo.gl/4uNskB)&nbsp;</span>韭菜币。</p>
   <h3 style="font-weight:bold;font-size:18px;color:rgb(240,150,28);line-height:1.75em;">Dapp 部署</h3>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">既然我们开发的是 Dapp 去中心化应用，怎么能够部署在中心化的服务器上呢？这不是自掉身价吗？Dapp 自然有其部署的解决方案。</p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">IPFS 简介</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">IPFS 提供去中心化的点对点的 Web 服务。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">说简单点，你可以把它理解成为一个 p2p 的网盘，你网站的静态文件可以发布到 IPFS 上面托管，而且只要 IPFS 的节点不挂，你的网站就永远都不会挂，而不像部署到单独服务器上。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">同时 IPFS 上的一个文件也就对应着一个 hash 地址，普通用户可以通过公共的 http gateway 访问到你的页面，不像云服务器还要备案，正好也方便你割完韭菜跑路。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">使用也非常简单，只需要在 Install Go IPFS&nbsp;<span style="color:rgb(136,136,136);">(https://ipfs.io/docs/install)&nbsp;</span>下载安装。</p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">发布应用</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">只需要一行命令，把你 Dapp 的所有静态文件上传至 IPFS，命令如下。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">ipfs add -r your-ico/<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;"># 返回 hash 地址，此处仅为示例</span>added QWERabcd1234qwerABCD your-ico/</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">然后你就能够通过 https://goo.gl/5SyBwN 访问你的网站。当然这样的域名十分不友好，为 IPFS 站点设置解析需要一些不常用的操作。</p>
   <h4 style="font-weight:bold;color:rgb(240,150,28);line-height:1.75em;">域名解析</h4>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:#000000;">IPNS</span></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">你的站点必然包含多个文件，每个文件对应着独立的 hash 地址，而且你也不能保证你的网站只需要发布一次。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">因此在网站发布后，我们需要使用 ipns 来获取到对应的唯一地址，之后的 DNS 解析也会对应到这一地址，同样只需要一行命令，如下所示。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;"><span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;"># 站点发布后的 hash 地址，此处仅为示例</span>ipfs name publish QWERabcd1234qwerABCD<span class="hljs-comment" style="color:rgb(153,153,136);font-style:italic;"># 返回 ipns 地址</span>Published to ABCDqwer1234abcdQWER</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">之后你就能够通过 https://goo.gl/8YMLBi 访问你的站点了。在设置域名解析时，我们需要添加一条&nbsp;<span style="color:#000000;">TXT</span>&nbsp;类型的解析记录，解析值为：</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">dnslink=/ipns/ABCDqwer1234abcdQWER</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">这样我们就能够通过 https://goo.gl/VjSm1K 访问你的 Dapp，这样是不是友好多了？</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:#000000;">Nginx 反向代理</span></p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">当然你也可能希望使用自己的独立域名，这时我们只需要使用 Nginx 设置反向代理即可。</p>
   <pre style="font-family:Consolas, Inconsolata, Courier, monospace;line-height:1.2em;font-size:15px;color:rgb(85,85,85);"></pre>
   <p style="border-width:1px;border-style:solid;border-color:rgb(204,204,204);color:rgb(51,51,51);line-height:1.75em;margin-left:8px;">server { &nbsp;listen 80; &nbsp;server_name yourico.com; &nbsp;location / { &nbsp; &nbsp;proxy_pass https://ipfs.io/ipns/yourico.com/; &nbsp;} }</p>
   <h3 style="font-weight:bold;font-size:18px;color:rgb(240,150,28);line-height:1.75em;">写在后面</h3>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">以太坊官网，第一篇教程教你发 token，第二篇就教你卖 token，居心何在我也不好评判。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">除了 ICO 还有 IMO/IFO ，IMO 你只用卖个路由器，IFO 只需要 fork 一份 Bitcoin 的代码，稍微调调参数，就不需要什么教程了。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">程序员总是妄图通过技术手段解决社会问题，然而人性是不变的。以太坊希望建立一个 trustless 的网络，可惜被无数人滥用，巧立空气项目，搞空壳公司，逃避监管搞非法集资。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">区块链和虚拟货币期望用点对点分布式的网络，脱离第三方，让世界上任何角落的两个人都能够低成本地进行交易，结果大量投机者涌入，导致网络堵塞，如今我们连一笔交易的矿工费都支付不起。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">当然我信奉技术本身是无罪，就好像这篇教你割韭菜的文章一样，你是选择擦亮双眼，看清 ICO 的本质，从此势不两立；还是选择投机倒把，滥用以太坊技术，坠身同流合污？</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">您可以在访问 https://github.com/discountry/gitcoin 查看完整的智能合约示例。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;">您可以访问 https://github.com/discountry/lec 查看完整的 Dapp 示例。</p>
   <p style="font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;"><span style="color:#000000;">Read at your own risk.</span></p>
   <p style="margin-left:8px;"><span style="color:#000000;"></span></p>
   <p style="margin-left:8px;line-height:1.75em;letter-spacing:.5px;"><span style="color:rgb(240,150,28);font-size:18px;">近期热文</span></p>
   <p style="margin-left:8px;min-height:1em;background-color:rgb(255,255,255);line-height:1.75em;letter-spacing:1px;"><span style="color:#888888;"><span style="font-size:15px;"><strong>《<a href="http://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247485292&amp;idx=1&amp;sn=6eac421bbb02d3c3c5531ae1df0f7efd&amp;chksm=e82be67ddf5c6f6bcbb6f32c91408e8f06f62599f47ca8faa0f8115cce6379debf8faa616bbb&amp;scene=21#wechat_redirect" rel="nofollow">它的暴利，已经完全超过了某些犯罪收入</a>》</strong></span></span></p>
   <p style="margin-left:8px;min-height:1em;background-color:rgb(255,255,255);line-height:1.75em;letter-spacing:1px;"><span style="color:rgb(136,136,136);font-size:15px;"><strong>《<a href="http://mp.weixin.qq.com/s?__biz=MzIwNjEwNTQ4Mw==&amp;mid=2651580791&amp;idx=1&amp;sn=8f2a16563d3e85d475968d407b586e46&amp;chksm=8cd9f793bbae7e858a123d48c3a3f82e7f7845273a8b92b0f26d97ac9c0daf9db2c330f2411b&amp;scene=21#wechat_redirect" rel="nofollow">Java 语法糖详解</a>》</strong></span></p>
   <p style="margin-left:8px;min-height:1em;background-color:rgb(255,255,255);line-height:1.75em;letter-spacing:1px;"><span style="color:rgb(136,136,136);font-size:15px;"><strong>《<a href="http://mp.weixin.qq.com/s?__biz=MzIwNjEwNTQ4Mw==&amp;mid=2651580766&amp;idx=1&amp;sn=afbef493895a76e8bb18d7f2a16b4c53&amp;chksm=8cd9f7babbae7eac2a1d02277e0a46516443fc42c7aa89c435dcc0ae3d487c6599025b2ab465&amp;scene=21#wechat_redirect" rel="nofollow">程序员跳槽时，如何高效地准备面试？</a>》</strong></span></p>
   <p style="margin-left:8px;min-height:1em;background-color:rgb(255,255,255);line-height:1.75em;letter-spacing:1px;"><span style="color:rgb(136,136,136);font-size:15px;"><strong>《<a href="http://mp.weixin.qq.com/s?__biz=MzIwNjEwNTQ4Mw==&amp;mid=2651580699&amp;idx=1&amp;sn=23dcad4f09753b762e1064c3f91a9412&amp;chksm=8cd9f7ffbbae7ee9498af602f59f0faeb3e0c96576dbc048d6b77367eea59cb7993987539022&amp;scene=21#wechat_redirect" rel="nofollow">机器学习数据预处理方法与技巧系统讲解</a>》</strong></span></p>
   <p style="margin-left:8px;min-height:1em;background-color:rgb(255,255,255);line-height:1.75em;letter-spacing:1px;"><span style="color:rgb(136,136,136);font-size:15px;"><strong>《<a href="http://mp.weixin.qq.com/s?__biz=MzIwNjEwNTQ4Mw==&amp;mid=2651580695&amp;idx=1&amp;sn=0f188fc2dc7a9b02df04be9278b9a7c8&amp;chksm=8cd9f7f3bbae7ee5f162d4912f7aa32a5d08af463de69185afad33121e685697050abe273900&amp;scene=21#wechat_redirect" rel="nofollow">中小型企业基于大数据技术的项目实践</a>》</strong></span></p>
   <p style="margin-left:8px;min-height:1em;background-color:rgb(255,255,255);line-height:1.75em;letter-spacing:1px;"><span style="color:rgb(136,136,136);font-size:15px;"><strong>《<a href="http://mp.weixin.qq.com/s?__biz=MzIwNjEwNTQ4Mw==&amp;mid=2651580690&amp;idx=1&amp;sn=ae9e67f38be634cf859ff59cdc8536dd&amp;chksm=8cd9f7f6bbae7ee00d4e3ec2985fab1763823a183fe1ca6781e7ba1c21bb145df35f8ebbe04c&amp;scene=21#wechat_redirect" rel="nofollow">GitChat 被恶意攻击引发的技术性思考：拒绝服务攻击</a>》</strong></span></p>
   <p style="margin-left:8px;line-height:1.75em;"><span style="font-size:13px;"><span style="color:rgb(62,62,62);"><span style="letter-spacing:1px;color:rgb(171,25,66);">「阅读原文」</span></span></span><span style="font-size:13px;color:rgb(178,178,178);">看交流实录，你想知道的都在这里</span></p> 
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/GitChat/article/details/79319834,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/GitChat/article/details/79319834,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
