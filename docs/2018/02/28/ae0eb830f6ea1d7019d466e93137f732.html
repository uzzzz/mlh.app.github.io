<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>深入理解区块链h5房卡斗牛源码搭建 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="深入理解区块链h5房卡斗牛源码搭建" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&nbsp; 一提到比特币、区块链，h5房卡斗牛源码搭建 官网:h5.super-mans.com 企娥:2012035031 vx和tel:17061863513 h5房卡斗牛源码搭建能让我们最先想到的就是去中心化，分布式数据库/账本，但是什么是去中心化，或者什么是区块链，却未必都能说得清。很多人对于区块链的认识就止步于此。网上查一查什么是区块链，各种专业词汇扑面而来，什么点对点网络，什么工作量证明机制(PoW)，什么数字签名、共识算法，把人看得云里雾里，也未必真能搞得懂。实际上，区块链就是这样的一种技术，它并非是从零开始，而是基于已有的这些技术，经过巧妙的结合生成的。如果要搞懂区块链，就要搞明白这些东西是怎么结合在一起的。所以这篇文章主要在宏观的基础上，在技术层面做更进一步的深入。 &nbsp; &nbsp; 如何理解区块链 &nbsp; &nbsp; &nbsp;&nbsp;首先，引入区块链的理念：将一个基于节点的去中心化共识协议与工作量证明(PoW)机制结合在一起。节点通过PoW机制获得参与到系统的权利，每隔一段时间将交易打包到区块中，从而创建出不断增长的区块链。 &nbsp; &nbsp; &nbsp;&nbsp;这里主要有两个概念：去中心化和工作量证明机制。 &nbsp; &nbsp; &nbsp;&nbsp;如何去中心化：区块链系统中的每一个区块，负责记录交易信息，每个用户的收支情况都被永久的存储在区块中供他人查询。每个节点都会保存一份完整的交易数据，所有这些节点组成了区块链的分布式数据库系统，任何一个节点的数据出现问题，都不会影响整个系统的运转。 &nbsp; &nbsp; &nbsp;&nbsp;工作量证明机制：工作量证明(Proof Of Work，简称PoW)，简单理解就是一份证明，用来确认你在系统中做过一定量的工作。相较于低效的监测工作的整个过程，通过对工作结果进行认证来证明完成了相应的工作量，则是一种非常高效的方式。例如我们通过完成工作中的各项任务来证明我们为公司创造了价值，从而得到公司的认可。而这种&quot;工作证明&quot;一般都会花费一定的时间才能得到。 &nbsp; &nbsp; 工作量证明机制(PoW) &nbsp; &nbsp; &nbsp;&nbsp;工作量证明机制，是一种应对拒绝服务攻击(DoS)和其他服务滥用的经济对策。它要求发起者进行一定量的运算作为代价，也就意味着需要消耗计算机一定的时间。例如现在网站登录时都需要输入的验证码(滑块或者拼图)，都采用的是这种CAPTCHA模式。 &nbsp; &nbsp; &nbsp;&nbsp;类似于CAPTCHA，哈希现金(HashCash)的原理是在邮件的消息头中增加一个包含收件人地址、发送时间和salt随机数的hashcash stamp的散列值，但是满足前20位都是0的散列值才是合法的。这就需要发送者在正式发送前需要通过调整salt的值进行多次计算，在满足该条件后才能成功发送。但是我们不希望发送者在算出这个stamp后继续复用，所以HashCash规定了过期的stamp是非法的(即发送时间&nbsp;&gt; stamp时间)。 &nbsp; &nbsp; &nbsp;&nbsp;区块链也是采用了类似hashcash的工作量证明方法，对区块头中的数据做双重SHA256运算(&nbsp;即SHA256(SHA256(HEADER)) )，与当前网络的目标值做对比，如果小于目标值，则完成工作量证明。 &nbsp; &nbsp; &nbsp;&nbsp;这里对PoW做了较多的解释，是为了便于理解PoW是如何应用在区块链上的。挖矿也是通过PoW进行的。在比特币系统中，节点完成工作量证明后，就代表获得这个区块的交易记账权。系统会通过PoW机制让矿工们竞争记账权，谁在单位时间内执行的运算更多(拥有更高的算力)，谁就有更高的概率获得区块的记账权。获得记账权的矿工将把该区块广播到网络中，全网其他节点在验证区块满足特定的条件后，其区块会被链接在主链上，从而在全网范围内形成对当前网络状态的一次共识，该矿工也会得到系统奖励的一定数量的代币。所有的区块通过这种形式链接在一起，形成了区块链的主链，从创世区块到当前生成的最新区块，所有历史交易数据都是公开透明的。 &nbsp; &nbsp; &nbsp;&nbsp;上面提到了区块是用于记录交易信息的，区块头中的数据参与了PoW的过程。那么接下来有必要进一步分析区块的内容了。 &nbsp; &nbsp; 区块的组成 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;每个区块由区块头和区块体两部分组成。区块头中主要包含前一个区块的Hash地址(Prevhash)、时间戳(Timestamp)、随机数(Nonce)、当前区块的目标Hash值(CurrentTarget)。Merkle树的根值(Merkle Root)等信息；区块体中则包含了具体的交易数量(TX NUM)和自上一个区块生成以来发生的所有交易的列表。这个交易列表就是记账本，每一笔交易都会被永久地记入区块中，任何人都可以查询。而且交易都会伴随数字签名，确保交易不可篡改及真实有效性，所有交易都将通过Merkle树的Hash运算产生一个唯一的Merkle根值记录到区块头中(Merkle树是一种数据结构，后面将做介绍)。 &nbsp; &nbsp; 状态转移与UTXO交易模式 &nbsp; &nbsp; &nbsp;&nbsp;从技术的角度出发，比特币记账本可以看做是一个状态转移的系统。持有人对现存的所有比特币的持有情况，可以理解为系统当前的一种状态。例如：小明有100个比特币，表示在当前的状态下，小明持有100个比特币。当小明想进行交易时，比如给小王转20个比特币，就需要以当前的状态(拥有100个比特币)和发起的交易(给小王转20个比特币)，通过状态转移，生成新的状态(小明有80个比特币，小王有20个比特币)。这个状态转移可以看做是一个函数： APPLY(STATE, TRANSACTION) =&gt; NEW_STATE 表示小明给小王转账的交易： APPLY({XiaoMing: 100, XiaoWang: 0}, &quot;send 20 from XiaoMing to XiaoWang&quot;) =&gt; {XiaoMing: 80, XiaoWang: 20 } &nbsp; &nbsp; &nbsp;&nbsp;可以发现，交易的过程就是一个从输入到输出的过程，一个资金流转的过程，并且创世区块和后来挖矿产生的奖励区块不适用于这个公式(创世区块是整个链上的第一个区块；挖矿的奖励区块是凭空产生的，是发行代币的方式)。除此之外，其他的交易都必须要依据现有的输入来产生新的输出。而现有的输入是从何而来的，必然是从这个持有人在上一笔交易中的输出得到的。稍微有点绕，按照上面的例子，假如小王要给小李再转5个比特币，这笔交易的输入(5个币)必须是上一笔交易(小明给小王转账)中未被使用的输出(20个币)。这个未被使用的交易输出也叫做UTXO(Unspent TX Output)，是比特币交易的基本单位。也可以简单理解为空闲的、未被占用的金额，就像已经花出去的钱(你上一笔交易的UTXO)是不可能再花一遍的(已成为别人的UTXO)。一笔交易可以包括一个或多个输入和一个或多个输出，每个输入包含一个对现有UTXO的引用和与持有者私钥创建的密码学签名；每个输出包含一个新的加入到状态中的UTXO。 &nbsp; 对于交易中的每个输入和状态，有如下的定义： 1.如果引用的UTXO不在当前的状态中，则会返回错误；如果签名与引用的UTXO的持有者签名不一致，也会返回错误。 2.如果所有输入的UTXO总额与所有输出的UTXO总额不等，会返回错误。 3.返回的新状态NEW_STATE中，移除了所有输入的UTXO，增加了所有输出的UTXO。 &nbsp; &nbsp; Merkle树 &nbsp; &nbsp; &nbsp;&nbsp;Merkle树是数据结构中的一种树结构，可以是二叉树，也可以是多叉树，具有树的所有特点。由于Merkle树中会进行Hash运算，所以也被称为Hash树。在了解Merkle树之前，先来看看Hash算法及HashList。 &nbsp; &nbsp; &nbsp;&nbsp;Hash算法是一种可以将任意长度的数据转换成固定长度字符串的算法。是一种安全散列算法。最显著的特点是几乎不可逆、无冲突。Hash算法最常见的应用就是对数据完整性的校验。例如我们在下载一些文件时，资源提供方会给出一个MD5或者SHA的值，这个值实际上就是资源在经过Hash运算后的值，用户下载数据后，可以对数据进行Hash，然后跟这个值比对，如果相同，就说明数据在传输过程中无损坏或篡改。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;缺点：当下载较大的文件时，如果出现Hash值不匹配的情况，那么就要重新下载整个文件。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这种通过对整个文件进行Hash运算来判断数据是否损坏的方法，效率很低下。如果将文件分割成一个个小的数据块，分别对其做Hash，就得到了HashList。在点对点网络中传输数据时，会从多个节点同时下载数据。假设某些节点网络不稳定或者数据不可信，那么为了验证数据的准确性，就会采用HashList，如果某些数据块损坏了，只需要重新下载这些小的数据块即可，无需重新下载整个文件。 &nbsp; &nbsp; &nbsp;&nbsp;通常在下载数据前，会先从可信数据源那里获取一个Root Hash值。Root Hash是将HashList中每个数据块的Hash值拼接到一起，再做一次Hash运算所得到的值。这个值用来校验HashList是否正确。得到Root Hash后，会再下载该数据的HashList。判断HashList正确后，才开始文件数据的下载。最后将下载的数据块做Hash后与HashList做比对，如果出现不一致，则说明数据被损坏，需要重新下载该数据块。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;然后回过头来再看Merkle树，它的底层与HashList一样，都是将数据分成小数据块，然后分别计算其Hash值。但是再往上一层就不同了，它不是把所有的Hash值合并到一起做Hash，而是将两个相邻的Hash值拼接在一起进行Hash运算，产生一个新的Hash。例如Block1的Hash值201w与Block2的Hash值0mzc合并Hash后产生新的3ali Hash值。而如果两两匹配后出现孤立的Hash值，则直接将其做Hash，例如Block5。最终产生一个Root Hash值，通常称为Merkle Root。 同样，在下载前，会先从可信数据源中获取正确的Merkle Root，然后再从其他节点下载Merkle树，通过Merkle Root来辨别Merkle树的真伪。如果发现不匹配，则从其他节点继续下载该Merkle树，直到获得一个与可信Merkle Root相匹配的Merkle树。 &nbsp; &nbsp; &nbsp; 由于Merkle树是逐级分支的，所以它可以从任意一个分支开始下载并验证。考虑Root-&gt;d063-&gt;09yk-&gt;a8b5-&gt;Block3这个分支，如果对这个分支的Hash值验证通过后，就可以下载Block3的数据了。而在HashList中需要先得到整个Hash值列表后才能使用Root Hash验证。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在区块链系统中，最下层的叶节点中存放的是交易数据，每个中间层的节点都是它的两个子节点的Hash，根节点也是它的两个子节点的Hash，代表Merkle树的顶部。如果有攻击者恶意篡改交易数据，或者篡改Merkle树的某一部分，必然导致上层节点的Hash值变动，最终导致验证不通过。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 了解了Merkle树的结构后，如果我们要查找某一笔交易，那么顺序是怎样的呢？首先，可以根据区块头中的时间戳确认交易存在的具体区块。而Merkle Root也是放在区块头中的，如果我们从Merkle Root开始向下查找，假设底层有n笔交易数据，那么找到所需的步骤为log2(n)，其实就是算法中的二分查找。简化支付验证(Simplified Payment Verification)就是利用这种方案，实现了轻量级的钱包客户端，只需下载区块头及相关交易的分支，即可对交易进行确认。但是它也存在一些缺点： 1.容易遭到全节点的拒绝服务，所以要保证较多的与全节点的连接，而且要保证这些节点是可信的； 2.spv客户端向全节点请求的交易必须与它的密钥一致，这样全节点会看到该客户端的相应用户的公钥，造成隐私泄露。 &nbsp; &nbsp; &nbsp; P2P网络 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;P2P网络即对等网络，是一种去中心化的分布式应用架构。这种网络结构与目前传统的CS(Client/Server)、BS(Browse Server)结构的本质区别是，网络中不存在中心节点/服务器。在P2P架构中，每个节点的地位都是对等的，都具有相同的功能，无主从之分。节点通过将硬件资源以服务的形式共享到网络中，这些共享的资源可以被其他节点直接访问。一个节点既可充当服务器的角色，又是服务请求方，故节点越多，网络中可提供的资源就越多。而CS、BS这些模式都是以中心应用服务器为核心的，由用户向中心服务器发起请求，中心服务器处理请求后再将结果返回给用户。用户之间的通信也需要通过中心服务器转发来完成。所以P2P网络中的核心思想也是去中心化。除了这个特点，P2P网络还具有扩展性强、健壮性、高性价比、负载均衡、隐私保护等特点。我们日常使用的BT下载就是采用P2P让客户端之间进行数据传输。BT下载是通过BitTorrent协议(一种中心索引式的P2P文件分分析通信协议)，让你在下载其他用户资源的同时，也为其他用户提供上传。所以下载的人越多，可连接到的节点就越多，下载速度就越快。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在BT架构中，我们发现还是存在一个&quot;中心服务器&quot;，该服务器的作用并非提供下载服务，而是对发布的torrent文件进行统一管理。torrent文件本质上是一个索引文件，包含了Tracker信息(发布资源的服务器的位置)和文件信息(文件名、大小、Hash值等)，这些信息根据BitTorrent协议内的B编码规则进行编码。torrent文件中的Hash信息是对每一块要下载的文件内容的加密结果。使用文本工具打开.torrent文件，就可以看个大概(乱码是SHA1校验码)： &nbsp; &nbsp; 结语 &nbsp; &nbsp; &nbsp; 通过以上的内容可以发现，组成区块链的这些技术实际上早已有着广泛的应用，只是我们之前并未那么密切的关注过，而区块链只是将这些技术巧妙的结合到了一起。理解了这些技术的原理后，我们就可以揭开区块链神秘的面纱，去进一步窥探其中的奥秘。 阅读更多" />
<meta property="og:description" content="&nbsp; 一提到比特币、区块链，h5房卡斗牛源码搭建 官网:h5.super-mans.com 企娥:2012035031 vx和tel:17061863513 h5房卡斗牛源码搭建能让我们最先想到的就是去中心化，分布式数据库/账本，但是什么是去中心化，或者什么是区块链，却未必都能说得清。很多人对于区块链的认识就止步于此。网上查一查什么是区块链，各种专业词汇扑面而来，什么点对点网络，什么工作量证明机制(PoW)，什么数字签名、共识算法，把人看得云里雾里，也未必真能搞得懂。实际上，区块链就是这样的一种技术，它并非是从零开始，而是基于已有的这些技术，经过巧妙的结合生成的。如果要搞懂区块链，就要搞明白这些东西是怎么结合在一起的。所以这篇文章主要在宏观的基础上，在技术层面做更进一步的深入。 &nbsp; &nbsp; 如何理解区块链 &nbsp; &nbsp; &nbsp;&nbsp;首先，引入区块链的理念：将一个基于节点的去中心化共识协议与工作量证明(PoW)机制结合在一起。节点通过PoW机制获得参与到系统的权利，每隔一段时间将交易打包到区块中，从而创建出不断增长的区块链。 &nbsp; &nbsp; &nbsp;&nbsp;这里主要有两个概念：去中心化和工作量证明机制。 &nbsp; &nbsp; &nbsp;&nbsp;如何去中心化：区块链系统中的每一个区块，负责记录交易信息，每个用户的收支情况都被永久的存储在区块中供他人查询。每个节点都会保存一份完整的交易数据，所有这些节点组成了区块链的分布式数据库系统，任何一个节点的数据出现问题，都不会影响整个系统的运转。 &nbsp; &nbsp; &nbsp;&nbsp;工作量证明机制：工作量证明(Proof Of Work，简称PoW)，简单理解就是一份证明，用来确认你在系统中做过一定量的工作。相较于低效的监测工作的整个过程，通过对工作结果进行认证来证明完成了相应的工作量，则是一种非常高效的方式。例如我们通过完成工作中的各项任务来证明我们为公司创造了价值，从而得到公司的认可。而这种&quot;工作证明&quot;一般都会花费一定的时间才能得到。 &nbsp; &nbsp; 工作量证明机制(PoW) &nbsp; &nbsp; &nbsp;&nbsp;工作量证明机制，是一种应对拒绝服务攻击(DoS)和其他服务滥用的经济对策。它要求发起者进行一定量的运算作为代价，也就意味着需要消耗计算机一定的时间。例如现在网站登录时都需要输入的验证码(滑块或者拼图)，都采用的是这种CAPTCHA模式。 &nbsp; &nbsp; &nbsp;&nbsp;类似于CAPTCHA，哈希现金(HashCash)的原理是在邮件的消息头中增加一个包含收件人地址、发送时间和salt随机数的hashcash stamp的散列值，但是满足前20位都是0的散列值才是合法的。这就需要发送者在正式发送前需要通过调整salt的值进行多次计算，在满足该条件后才能成功发送。但是我们不希望发送者在算出这个stamp后继续复用，所以HashCash规定了过期的stamp是非法的(即发送时间&nbsp;&gt; stamp时间)。 &nbsp; &nbsp; &nbsp;&nbsp;区块链也是采用了类似hashcash的工作量证明方法，对区块头中的数据做双重SHA256运算(&nbsp;即SHA256(SHA256(HEADER)) )，与当前网络的目标值做对比，如果小于目标值，则完成工作量证明。 &nbsp; &nbsp; &nbsp;&nbsp;这里对PoW做了较多的解释，是为了便于理解PoW是如何应用在区块链上的。挖矿也是通过PoW进行的。在比特币系统中，节点完成工作量证明后，就代表获得这个区块的交易记账权。系统会通过PoW机制让矿工们竞争记账权，谁在单位时间内执行的运算更多(拥有更高的算力)，谁就有更高的概率获得区块的记账权。获得记账权的矿工将把该区块广播到网络中，全网其他节点在验证区块满足特定的条件后，其区块会被链接在主链上，从而在全网范围内形成对当前网络状态的一次共识，该矿工也会得到系统奖励的一定数量的代币。所有的区块通过这种形式链接在一起，形成了区块链的主链，从创世区块到当前生成的最新区块，所有历史交易数据都是公开透明的。 &nbsp; &nbsp; &nbsp;&nbsp;上面提到了区块是用于记录交易信息的，区块头中的数据参与了PoW的过程。那么接下来有必要进一步分析区块的内容了。 &nbsp; &nbsp; 区块的组成 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;每个区块由区块头和区块体两部分组成。区块头中主要包含前一个区块的Hash地址(Prevhash)、时间戳(Timestamp)、随机数(Nonce)、当前区块的目标Hash值(CurrentTarget)。Merkle树的根值(Merkle Root)等信息；区块体中则包含了具体的交易数量(TX NUM)和自上一个区块生成以来发生的所有交易的列表。这个交易列表就是记账本，每一笔交易都会被永久地记入区块中，任何人都可以查询。而且交易都会伴随数字签名，确保交易不可篡改及真实有效性，所有交易都将通过Merkle树的Hash运算产生一个唯一的Merkle根值记录到区块头中(Merkle树是一种数据结构，后面将做介绍)。 &nbsp; &nbsp; 状态转移与UTXO交易模式 &nbsp; &nbsp; &nbsp;&nbsp;从技术的角度出发，比特币记账本可以看做是一个状态转移的系统。持有人对现存的所有比特币的持有情况，可以理解为系统当前的一种状态。例如：小明有100个比特币，表示在当前的状态下，小明持有100个比特币。当小明想进行交易时，比如给小王转20个比特币，就需要以当前的状态(拥有100个比特币)和发起的交易(给小王转20个比特币)，通过状态转移，生成新的状态(小明有80个比特币，小王有20个比特币)。这个状态转移可以看做是一个函数： APPLY(STATE, TRANSACTION) =&gt; NEW_STATE 表示小明给小王转账的交易： APPLY({XiaoMing: 100, XiaoWang: 0}, &quot;send 20 from XiaoMing to XiaoWang&quot;) =&gt; {XiaoMing: 80, XiaoWang: 20 } &nbsp; &nbsp; &nbsp;&nbsp;可以发现，交易的过程就是一个从输入到输出的过程，一个资金流转的过程，并且创世区块和后来挖矿产生的奖励区块不适用于这个公式(创世区块是整个链上的第一个区块；挖矿的奖励区块是凭空产生的，是发行代币的方式)。除此之外，其他的交易都必须要依据现有的输入来产生新的输出。而现有的输入是从何而来的，必然是从这个持有人在上一笔交易中的输出得到的。稍微有点绕，按照上面的例子，假如小王要给小李再转5个比特币，这笔交易的输入(5个币)必须是上一笔交易(小明给小王转账)中未被使用的输出(20个币)。这个未被使用的交易输出也叫做UTXO(Unspent TX Output)，是比特币交易的基本单位。也可以简单理解为空闲的、未被占用的金额，就像已经花出去的钱(你上一笔交易的UTXO)是不可能再花一遍的(已成为别人的UTXO)。一笔交易可以包括一个或多个输入和一个或多个输出，每个输入包含一个对现有UTXO的引用和与持有者私钥创建的密码学签名；每个输出包含一个新的加入到状态中的UTXO。 &nbsp; 对于交易中的每个输入和状态，有如下的定义： 1.如果引用的UTXO不在当前的状态中，则会返回错误；如果签名与引用的UTXO的持有者签名不一致，也会返回错误。 2.如果所有输入的UTXO总额与所有输出的UTXO总额不等，会返回错误。 3.返回的新状态NEW_STATE中，移除了所有输入的UTXO，增加了所有输出的UTXO。 &nbsp; &nbsp; Merkle树 &nbsp; &nbsp; &nbsp;&nbsp;Merkle树是数据结构中的一种树结构，可以是二叉树，也可以是多叉树，具有树的所有特点。由于Merkle树中会进行Hash运算，所以也被称为Hash树。在了解Merkle树之前，先来看看Hash算法及HashList。 &nbsp; &nbsp; &nbsp;&nbsp;Hash算法是一种可以将任意长度的数据转换成固定长度字符串的算法。是一种安全散列算法。最显著的特点是几乎不可逆、无冲突。Hash算法最常见的应用就是对数据完整性的校验。例如我们在下载一些文件时，资源提供方会给出一个MD5或者SHA的值，这个值实际上就是资源在经过Hash运算后的值，用户下载数据后，可以对数据进行Hash，然后跟这个值比对，如果相同，就说明数据在传输过程中无损坏或篡改。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;缺点：当下载较大的文件时，如果出现Hash值不匹配的情况，那么就要重新下载整个文件。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这种通过对整个文件进行Hash运算来判断数据是否损坏的方法，效率很低下。如果将文件分割成一个个小的数据块，分别对其做Hash，就得到了HashList。在点对点网络中传输数据时，会从多个节点同时下载数据。假设某些节点网络不稳定或者数据不可信，那么为了验证数据的准确性，就会采用HashList，如果某些数据块损坏了，只需要重新下载这些小的数据块即可，无需重新下载整个文件。 &nbsp; &nbsp; &nbsp;&nbsp;通常在下载数据前，会先从可信数据源那里获取一个Root Hash值。Root Hash是将HashList中每个数据块的Hash值拼接到一起，再做一次Hash运算所得到的值。这个值用来校验HashList是否正确。得到Root Hash后，会再下载该数据的HashList。判断HashList正确后，才开始文件数据的下载。最后将下载的数据块做Hash后与HashList做比对，如果出现不一致，则说明数据被损坏，需要重新下载该数据块。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;然后回过头来再看Merkle树，它的底层与HashList一样，都是将数据分成小数据块，然后分别计算其Hash值。但是再往上一层就不同了，它不是把所有的Hash值合并到一起做Hash，而是将两个相邻的Hash值拼接在一起进行Hash运算，产生一个新的Hash。例如Block1的Hash值201w与Block2的Hash值0mzc合并Hash后产生新的3ali Hash值。而如果两两匹配后出现孤立的Hash值，则直接将其做Hash，例如Block5。最终产生一个Root Hash值，通常称为Merkle Root。 同样，在下载前，会先从可信数据源中获取正确的Merkle Root，然后再从其他节点下载Merkle树，通过Merkle Root来辨别Merkle树的真伪。如果发现不匹配，则从其他节点继续下载该Merkle树，直到获得一个与可信Merkle Root相匹配的Merkle树。 &nbsp; &nbsp; &nbsp; 由于Merkle树是逐级分支的，所以它可以从任意一个分支开始下载并验证。考虑Root-&gt;d063-&gt;09yk-&gt;a8b5-&gt;Block3这个分支，如果对这个分支的Hash值验证通过后，就可以下载Block3的数据了。而在HashList中需要先得到整个Hash值列表后才能使用Root Hash验证。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在区块链系统中，最下层的叶节点中存放的是交易数据，每个中间层的节点都是它的两个子节点的Hash，根节点也是它的两个子节点的Hash，代表Merkle树的顶部。如果有攻击者恶意篡改交易数据，或者篡改Merkle树的某一部分，必然导致上层节点的Hash值变动，最终导致验证不通过。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 了解了Merkle树的结构后，如果我们要查找某一笔交易，那么顺序是怎样的呢？首先，可以根据区块头中的时间戳确认交易存在的具体区块。而Merkle Root也是放在区块头中的，如果我们从Merkle Root开始向下查找，假设底层有n笔交易数据，那么找到所需的步骤为log2(n)，其实就是算法中的二分查找。简化支付验证(Simplified Payment Verification)就是利用这种方案，实现了轻量级的钱包客户端，只需下载区块头及相关交易的分支，即可对交易进行确认。但是它也存在一些缺点： 1.容易遭到全节点的拒绝服务，所以要保证较多的与全节点的连接，而且要保证这些节点是可信的； 2.spv客户端向全节点请求的交易必须与它的密钥一致，这样全节点会看到该客户端的相应用户的公钥，造成隐私泄露。 &nbsp; &nbsp; &nbsp; P2P网络 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;P2P网络即对等网络，是一种去中心化的分布式应用架构。这种网络结构与目前传统的CS(Client/Server)、BS(Browse Server)结构的本质区别是，网络中不存在中心节点/服务器。在P2P架构中，每个节点的地位都是对等的，都具有相同的功能，无主从之分。节点通过将硬件资源以服务的形式共享到网络中，这些共享的资源可以被其他节点直接访问。一个节点既可充当服务器的角色，又是服务请求方，故节点越多，网络中可提供的资源就越多。而CS、BS这些模式都是以中心应用服务器为核心的，由用户向中心服务器发起请求，中心服务器处理请求后再将结果返回给用户。用户之间的通信也需要通过中心服务器转发来完成。所以P2P网络中的核心思想也是去中心化。除了这个特点，P2P网络还具有扩展性强、健壮性、高性价比、负载均衡、隐私保护等特点。我们日常使用的BT下载就是采用P2P让客户端之间进行数据传输。BT下载是通过BitTorrent协议(一种中心索引式的P2P文件分分析通信协议)，让你在下载其他用户资源的同时，也为其他用户提供上传。所以下载的人越多，可连接到的节点就越多，下载速度就越快。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在BT架构中，我们发现还是存在一个&quot;中心服务器&quot;，该服务器的作用并非提供下载服务，而是对发布的torrent文件进行统一管理。torrent文件本质上是一个索引文件，包含了Tracker信息(发布资源的服务器的位置)和文件信息(文件名、大小、Hash值等)，这些信息根据BitTorrent协议内的B编码规则进行编码。torrent文件中的Hash信息是对每一块要下载的文件内容的加密结果。使用文本工具打开.torrent文件，就可以看个大概(乱码是SHA1校验码)： &nbsp; &nbsp; 结语 &nbsp; &nbsp; &nbsp; 通过以上的内容可以发现，组成区块链的这些技术实际上早已有着广泛的应用，只是我们之前并未那么密切的关注过，而区块链只是将这些技术巧妙的结合到了一起。理解了这些技术的原理后，我们就可以揭开区块链神秘的面纱，去进一步窥探其中的奥秘。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/02/28/ae0eb830f6ea1d7019d466e93137f732.html" />
<meta property="og:url" content="https://mlh.app/2018/02/28/ae0eb830f6ea1d7019d466e93137f732.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"&nbsp; 一提到比特币、区块链，h5房卡斗牛源码搭建 官网:h5.super-mans.com 企娥:2012035031 vx和tel:17061863513 h5房卡斗牛源码搭建能让我们最先想到的就是去中心化，分布式数据库/账本，但是什么是去中心化，或者什么是区块链，却未必都能说得清。很多人对于区块链的认识就止步于此。网上查一查什么是区块链，各种专业词汇扑面而来，什么点对点网络，什么工作量证明机制(PoW)，什么数字签名、共识算法，把人看得云里雾里，也未必真能搞得懂。实际上，区块链就是这样的一种技术，它并非是从零开始，而是基于已有的这些技术，经过巧妙的结合生成的。如果要搞懂区块链，就要搞明白这些东西是怎么结合在一起的。所以这篇文章主要在宏观的基础上，在技术层面做更进一步的深入。 &nbsp; &nbsp; 如何理解区块链 &nbsp; &nbsp; &nbsp;&nbsp;首先，引入区块链的理念：将一个基于节点的去中心化共识协议与工作量证明(PoW)机制结合在一起。节点通过PoW机制获得参与到系统的权利，每隔一段时间将交易打包到区块中，从而创建出不断增长的区块链。 &nbsp; &nbsp; &nbsp;&nbsp;这里主要有两个概念：去中心化和工作量证明机制。 &nbsp; &nbsp; &nbsp;&nbsp;如何去中心化：区块链系统中的每一个区块，负责记录交易信息，每个用户的收支情况都被永久的存储在区块中供他人查询。每个节点都会保存一份完整的交易数据，所有这些节点组成了区块链的分布式数据库系统，任何一个节点的数据出现问题，都不会影响整个系统的运转。 &nbsp; &nbsp; &nbsp;&nbsp;工作量证明机制：工作量证明(Proof Of Work，简称PoW)，简单理解就是一份证明，用来确认你在系统中做过一定量的工作。相较于低效的监测工作的整个过程，通过对工作结果进行认证来证明完成了相应的工作量，则是一种非常高效的方式。例如我们通过完成工作中的各项任务来证明我们为公司创造了价值，从而得到公司的认可。而这种&quot;工作证明&quot;一般都会花费一定的时间才能得到。 &nbsp; &nbsp; 工作量证明机制(PoW) &nbsp; &nbsp; &nbsp;&nbsp;工作量证明机制，是一种应对拒绝服务攻击(DoS)和其他服务滥用的经济对策。它要求发起者进行一定量的运算作为代价，也就意味着需要消耗计算机一定的时间。例如现在网站登录时都需要输入的验证码(滑块或者拼图)，都采用的是这种CAPTCHA模式。 &nbsp; &nbsp; &nbsp;&nbsp;类似于CAPTCHA，哈希现金(HashCash)的原理是在邮件的消息头中增加一个包含收件人地址、发送时间和salt随机数的hashcash stamp的散列值，但是满足前20位都是0的散列值才是合法的。这就需要发送者在正式发送前需要通过调整salt的值进行多次计算，在满足该条件后才能成功发送。但是我们不希望发送者在算出这个stamp后继续复用，所以HashCash规定了过期的stamp是非法的(即发送时间&nbsp;&gt; stamp时间)。 &nbsp; &nbsp; &nbsp;&nbsp;区块链也是采用了类似hashcash的工作量证明方法，对区块头中的数据做双重SHA256运算(&nbsp;即SHA256(SHA256(HEADER)) )，与当前网络的目标值做对比，如果小于目标值，则完成工作量证明。 &nbsp; &nbsp; &nbsp;&nbsp;这里对PoW做了较多的解释，是为了便于理解PoW是如何应用在区块链上的。挖矿也是通过PoW进行的。在比特币系统中，节点完成工作量证明后，就代表获得这个区块的交易记账权。系统会通过PoW机制让矿工们竞争记账权，谁在单位时间内执行的运算更多(拥有更高的算力)，谁就有更高的概率获得区块的记账权。获得记账权的矿工将把该区块广播到网络中，全网其他节点在验证区块满足特定的条件后，其区块会被链接在主链上，从而在全网范围内形成对当前网络状态的一次共识，该矿工也会得到系统奖励的一定数量的代币。所有的区块通过这种形式链接在一起，形成了区块链的主链，从创世区块到当前生成的最新区块，所有历史交易数据都是公开透明的。 &nbsp; &nbsp; &nbsp;&nbsp;上面提到了区块是用于记录交易信息的，区块头中的数据参与了PoW的过程。那么接下来有必要进一步分析区块的内容了。 &nbsp; &nbsp; 区块的组成 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;每个区块由区块头和区块体两部分组成。区块头中主要包含前一个区块的Hash地址(Prevhash)、时间戳(Timestamp)、随机数(Nonce)、当前区块的目标Hash值(CurrentTarget)。Merkle树的根值(Merkle Root)等信息；区块体中则包含了具体的交易数量(TX NUM)和自上一个区块生成以来发生的所有交易的列表。这个交易列表就是记账本，每一笔交易都会被永久地记入区块中，任何人都可以查询。而且交易都会伴随数字签名，确保交易不可篡改及真实有效性，所有交易都将通过Merkle树的Hash运算产生一个唯一的Merkle根值记录到区块头中(Merkle树是一种数据结构，后面将做介绍)。 &nbsp; &nbsp; 状态转移与UTXO交易模式 &nbsp; &nbsp; &nbsp;&nbsp;从技术的角度出发，比特币记账本可以看做是一个状态转移的系统。持有人对现存的所有比特币的持有情况，可以理解为系统当前的一种状态。例如：小明有100个比特币，表示在当前的状态下，小明持有100个比特币。当小明想进行交易时，比如给小王转20个比特币，就需要以当前的状态(拥有100个比特币)和发起的交易(给小王转20个比特币)，通过状态转移，生成新的状态(小明有80个比特币，小王有20个比特币)。这个状态转移可以看做是一个函数： APPLY(STATE, TRANSACTION) =&gt; NEW_STATE 表示小明给小王转账的交易： APPLY({XiaoMing: 100, XiaoWang: 0}, &quot;send 20 from XiaoMing to XiaoWang&quot;) =&gt; {XiaoMing: 80, XiaoWang: 20 } &nbsp; &nbsp; &nbsp;&nbsp;可以发现，交易的过程就是一个从输入到输出的过程，一个资金流转的过程，并且创世区块和后来挖矿产生的奖励区块不适用于这个公式(创世区块是整个链上的第一个区块；挖矿的奖励区块是凭空产生的，是发行代币的方式)。除此之外，其他的交易都必须要依据现有的输入来产生新的输出。而现有的输入是从何而来的，必然是从这个持有人在上一笔交易中的输出得到的。稍微有点绕，按照上面的例子，假如小王要给小李再转5个比特币，这笔交易的输入(5个币)必须是上一笔交易(小明给小王转账)中未被使用的输出(20个币)。这个未被使用的交易输出也叫做UTXO(Unspent TX Output)，是比特币交易的基本单位。也可以简单理解为空闲的、未被占用的金额，就像已经花出去的钱(你上一笔交易的UTXO)是不可能再花一遍的(已成为别人的UTXO)。一笔交易可以包括一个或多个输入和一个或多个输出，每个输入包含一个对现有UTXO的引用和与持有者私钥创建的密码学签名；每个输出包含一个新的加入到状态中的UTXO。 &nbsp; 对于交易中的每个输入和状态，有如下的定义： 1.如果引用的UTXO不在当前的状态中，则会返回错误；如果签名与引用的UTXO的持有者签名不一致，也会返回错误。 2.如果所有输入的UTXO总额与所有输出的UTXO总额不等，会返回错误。 3.返回的新状态NEW_STATE中，移除了所有输入的UTXO，增加了所有输出的UTXO。 &nbsp; &nbsp; Merkle树 &nbsp; &nbsp; &nbsp;&nbsp;Merkle树是数据结构中的一种树结构，可以是二叉树，也可以是多叉树，具有树的所有特点。由于Merkle树中会进行Hash运算，所以也被称为Hash树。在了解Merkle树之前，先来看看Hash算法及HashList。 &nbsp; &nbsp; &nbsp;&nbsp;Hash算法是一种可以将任意长度的数据转换成固定长度字符串的算法。是一种安全散列算法。最显著的特点是几乎不可逆、无冲突。Hash算法最常见的应用就是对数据完整性的校验。例如我们在下载一些文件时，资源提供方会给出一个MD5或者SHA的值，这个值实际上就是资源在经过Hash运算后的值，用户下载数据后，可以对数据进行Hash，然后跟这个值比对，如果相同，就说明数据在传输过程中无损坏或篡改。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;缺点：当下载较大的文件时，如果出现Hash值不匹配的情况，那么就要重新下载整个文件。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这种通过对整个文件进行Hash运算来判断数据是否损坏的方法，效率很低下。如果将文件分割成一个个小的数据块，分别对其做Hash，就得到了HashList。在点对点网络中传输数据时，会从多个节点同时下载数据。假设某些节点网络不稳定或者数据不可信，那么为了验证数据的准确性，就会采用HashList，如果某些数据块损坏了，只需要重新下载这些小的数据块即可，无需重新下载整个文件。 &nbsp; &nbsp; &nbsp;&nbsp;通常在下载数据前，会先从可信数据源那里获取一个Root Hash值。Root Hash是将HashList中每个数据块的Hash值拼接到一起，再做一次Hash运算所得到的值。这个值用来校验HashList是否正确。得到Root Hash后，会再下载该数据的HashList。判断HashList正确后，才开始文件数据的下载。最后将下载的数据块做Hash后与HashList做比对，如果出现不一致，则说明数据被损坏，需要重新下载该数据块。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;然后回过头来再看Merkle树，它的底层与HashList一样，都是将数据分成小数据块，然后分别计算其Hash值。但是再往上一层就不同了，它不是把所有的Hash值合并到一起做Hash，而是将两个相邻的Hash值拼接在一起进行Hash运算，产生一个新的Hash。例如Block1的Hash值201w与Block2的Hash值0mzc合并Hash后产生新的3ali Hash值。而如果两两匹配后出现孤立的Hash值，则直接将其做Hash，例如Block5。最终产生一个Root Hash值，通常称为Merkle Root。 同样，在下载前，会先从可信数据源中获取正确的Merkle Root，然后再从其他节点下载Merkle树，通过Merkle Root来辨别Merkle树的真伪。如果发现不匹配，则从其他节点继续下载该Merkle树，直到获得一个与可信Merkle Root相匹配的Merkle树。 &nbsp; &nbsp; &nbsp; 由于Merkle树是逐级分支的，所以它可以从任意一个分支开始下载并验证。考虑Root-&gt;d063-&gt;09yk-&gt;a8b5-&gt;Block3这个分支，如果对这个分支的Hash值验证通过后，就可以下载Block3的数据了。而在HashList中需要先得到整个Hash值列表后才能使用Root Hash验证。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在区块链系统中，最下层的叶节点中存放的是交易数据，每个中间层的节点都是它的两个子节点的Hash，根节点也是它的两个子节点的Hash，代表Merkle树的顶部。如果有攻击者恶意篡改交易数据，或者篡改Merkle树的某一部分，必然导致上层节点的Hash值变动，最终导致验证不通过。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 了解了Merkle树的结构后，如果我们要查找某一笔交易，那么顺序是怎样的呢？首先，可以根据区块头中的时间戳确认交易存在的具体区块。而Merkle Root也是放在区块头中的，如果我们从Merkle Root开始向下查找，假设底层有n笔交易数据，那么找到所需的步骤为log2(n)，其实就是算法中的二分查找。简化支付验证(Simplified Payment Verification)就是利用这种方案，实现了轻量级的钱包客户端，只需下载区块头及相关交易的分支，即可对交易进行确认。但是它也存在一些缺点： 1.容易遭到全节点的拒绝服务，所以要保证较多的与全节点的连接，而且要保证这些节点是可信的； 2.spv客户端向全节点请求的交易必须与它的密钥一致，这样全节点会看到该客户端的相应用户的公钥，造成隐私泄露。 &nbsp; &nbsp; &nbsp; P2P网络 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;P2P网络即对等网络，是一种去中心化的分布式应用架构。这种网络结构与目前传统的CS(Client/Server)、BS(Browse Server)结构的本质区别是，网络中不存在中心节点/服务器。在P2P架构中，每个节点的地位都是对等的，都具有相同的功能，无主从之分。节点通过将硬件资源以服务的形式共享到网络中，这些共享的资源可以被其他节点直接访问。一个节点既可充当服务器的角色，又是服务请求方，故节点越多，网络中可提供的资源就越多。而CS、BS这些模式都是以中心应用服务器为核心的，由用户向中心服务器发起请求，中心服务器处理请求后再将结果返回给用户。用户之间的通信也需要通过中心服务器转发来完成。所以P2P网络中的核心思想也是去中心化。除了这个特点，P2P网络还具有扩展性强、健壮性、高性价比、负载均衡、隐私保护等特点。我们日常使用的BT下载就是采用P2P让客户端之间进行数据传输。BT下载是通过BitTorrent协议(一种中心索引式的P2P文件分分析通信协议)，让你在下载其他用户资源的同时，也为其他用户提供上传。所以下载的人越多，可连接到的节点就越多，下载速度就越快。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在BT架构中，我们发现还是存在一个&quot;中心服务器&quot;，该服务器的作用并非提供下载服务，而是对发布的torrent文件进行统一管理。torrent文件本质上是一个索引文件，包含了Tracker信息(发布资源的服务器的位置)和文件信息(文件名、大小、Hash值等)，这些信息根据BitTorrent协议内的B编码规则进行编码。torrent文件中的Hash信息是对每一块要下载的文件内容的加密结果。使用文本工具打开.torrent文件，就可以看个大概(乱码是SHA1校验码)： &nbsp; &nbsp; 结语 &nbsp; &nbsp; &nbsp; 通过以上的内容可以发现，组成区块链的这些技术实际上早已有着广泛的应用，只是我们之前并未那么密切的关注过，而区块链只是将这些技术巧妙的结合到了一起。理解了这些技术的原理后，我们就可以揭开区块链神秘的面纱，去进一步窥探其中的奥秘。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/02/28/ae0eb830f6ea1d7019d466e93137f732.html","headline":"深入理解区块链h5房卡斗牛源码搭建","dateModified":"2018-02-28T00:00:00+08:00","datePublished":"2018-02-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/02/28/ae0eb830f6ea1d7019d466e93137f732.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>深入理解区块链h5房卡斗牛源码搭建</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; 一提到比特币、区块链，h5房卡斗牛源码搭建 官网:h5.super-mans.com 企娥:2012035031 vx和tel:17061863513 h5房卡斗牛源码搭建能让我们最先想到的就是去中心化，分布式数据库</span><span style="line-height:1.5;color:rgb(1,1,1);">/</span><span style="line-height:1.5;color:rgb(1,1,1);">账本，但是什么是去中心化，或者什么是区块链，却未必都能说得清。很多人对于区块链的认识就止步于此。网上查一查什么是区块链，各种专业词汇扑面而来，什么点对点网络，什么工作量证明机制</span><span style="line-height:1.5;color:rgb(1,1,1);">(PoW)</span><span style="line-height:1.5;color:rgb(1,1,1);">，什么数字签名、共识算法，把人看得云里雾里，也未必真能搞得懂。实际上，区块链就是这样的一种技术，它并非是从零开始，而是基于已有的这些技术，经过巧妙的结合生成的。如果要搞懂区块链，就要搞明白这些东西是怎么结合在一起的。所以这篇文章主要在宏观的基础上，在技术层面做更进一步的深入。</span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span><span style="line-height:1.5;color:rgb(54,95,145);">如何理解区块链</span></span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <div align="left">
    <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;首先，引入区块链的理念：将一个基于节点的去中心化共识协议与工作量证明</span><span style="line-height:1.5;color:rgb(1,1,1);">(PoW)</span><span style="line-height:1.5;color:rgb(1,1,1);">机制结合在一起。节点通过</span><span style="line-height:1.5;color:rgb(1,1,1);">PoW</span><span style="line-height:1.5;color:rgb(1,1,1);">机制获得参与到系统的权利，每隔一段时间将交易打包到区块中，从而创建出不断增长的区块链。</span></span>
   </div>
   <div align="left">
    <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Microsoft YaHei';">&nbsp; &nbsp; &nbsp;&nbsp;这里主要有两个概念：去中心化和工作量证明机制。</span>
   </div>
   <div align="left">
    <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Microsoft YaHei';">&nbsp; &nbsp; &nbsp;&nbsp;如何去中心化：区块链系统中的每一个区块，负责记录交易信息，每个用户的收支情况都被永久的存储在区块中供他人查询。每个节点都会保存一份完整的交易数据，所有这些节点组成了区块链的分布式数据库系统，任何一个节点的数据出现问题，都不会影响整个系统的运转。</span>
   </div>
   <div>
    <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;工作量证明机制：工作量证明</span><span style="line-height:1.5;color:rgb(1,1,1);">(Proof Of Work</span><span style="line-height:1.5;color:rgb(1,1,1);">，简称</span><span style="line-height:1.5;color:rgb(1,1,1);">PoW)</span><span style="line-height:1.5;color:rgb(1,1,1);">，简单理解就是一份证明，用来确认你在系统中做过一定量的工作。相较于低效的监测工作的整个过程，通过对工作结果进行认证来证明完成了相应的工作量，则是一种非常高效的方式。例如我们通过完成工作中的各项任务来证明我们为公司创造了价值，从而得到公司的认可。而这种</span><span style="line-height:1.5;color:rgb(1,1,1);">"</span><span style="line-height:1.5;color:rgb(1,1,1);">工作证明</span><span style="line-height:1.5;color:rgb(1,1,1);">"</span><span style="line-height:1.5;color:rgb(1,1,1);">一般都会花费一定的时间才能得到。</span></span>
   </div>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span><span style="line-height:1.5;color:rgb(54,95,145);">工作量证明机制</span><span style="line-height:1.5;color:rgb(54,95,145);">(PoW)</span></span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;工作量证明机制，是一种应对拒绝服务攻击</span><span style="line-height:1.5;color:rgb(1,1,1);">(DoS)</span><span style="line-height:1.5;color:rgb(1,1,1);">和其他服务滥用的经济对策。它要求发起者进行一定量的运算作为代价，也就意味着需要消耗计算机一定的时间。例如现在网站登录时都需要输入的验证码</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">滑块或者拼图</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">，都采用的是这种</span><span style="line-height:1.5;color:rgb(1,1,1);">CAPTCHA</span><span style="line-height:1.5;color:rgb(1,1,1);">模式。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;类似于</span><span style="line-height:1.5;color:rgb(1,1,1);">CAPTCHA</span><span style="line-height:1.5;color:rgb(1,1,1);">，哈希现金</span><span style="line-height:1.5;color:rgb(1,1,1);">(HashCash)</span><span style="line-height:1.5;color:rgb(1,1,1);">的原理是在邮件的消息头中增加一个包含收件人地址、发送时间和</span><span style="line-height:1.5;color:rgb(1,1,1);">salt</span><span style="line-height:1.5;color:rgb(1,1,1);">随机数的</span><span style="line-height:1.5;color:rgb(1,1,1);">hashcash stamp</span><span style="line-height:1.5;color:rgb(1,1,1);">的散列值，但是满足前</span><span style="line-height:1.5;color:rgb(1,1,1);">20</span><span style="line-height:1.5;color:rgb(1,1,1);">位都是</span><span style="line-height:1.5;color:rgb(1,1,1);">0</span><span style="line-height:1.5;color:rgb(1,1,1);">的散列值才是合法的。这就需要发送者在正式发送前需要通过调整</span><span style="line-height:1.5;color:rgb(1,1,1);">salt</span><span style="line-height:1.5;color:rgb(1,1,1);">的值进行多次计算，在满足该条件后才能成功发送。但是我们不希望发送者在算出这个</span><span style="line-height:1.5;color:rgb(1,1,1);">stamp</span><span style="line-height:1.5;color:rgb(1,1,1);">后继续复用，所以</span><span style="line-height:1.5;color:rgb(1,1,1);">HashCash</span><span style="line-height:1.5;color:rgb(1,1,1);">规定了过期的</span><span style="line-height:1.5;color:rgb(1,1,1);">stamp</span><span style="line-height:1.5;color:rgb(1,1,1);">是非法的</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">即发送时间</span>&nbsp;<span style="line-height:1.5;color:rgb(1,1,1);">&gt; stamp</span><span style="line-height:1.5;color:rgb(1,1,1);">时间</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;区块链也是采用了类似</span><span style="line-height:1.5;color:rgb(1,1,1);">hashcash</span><span style="line-height:1.5;color:rgb(1,1,1);">的工作量证明方法，对区块头中的数据做双重</span><span style="line-height:1.5;color:rgb(1,1,1);">SHA256</span><span style="line-height:1.5;color:rgb(1,1,1);">运算</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span>&nbsp;<span style="line-height:1.5;color:rgb(1,1,1);">即</span><span style="line-height:1.5;color:rgb(1,1,1);">SHA256(SHA256(HEADER)) )</span><span style="line-height:1.5;color:rgb(1,1,1);">，与当前网络的目标值做对比，如果小于目标值，则完成工作量证明。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;这里对</span><span style="line-height:1.5;color:rgb(1,1,1);">PoW</span><span style="line-height:1.5;color:rgb(1,1,1);">做了较多的解释，是为了便于理解</span><span style="line-height:1.5;color:rgb(1,1,1);">PoW</span><span style="line-height:1.5;color:rgb(1,1,1);">是如何应用在区块链上的。挖矿也是通过</span><span style="line-height:1.5;color:rgb(1,1,1);">PoW</span><span style="line-height:1.5;color:rgb(1,1,1);">进行的。在比特币系统中，节点完成工作量证明后，就代表获得这个区块的交易记账权。系统会通过</span><span style="line-height:1.5;color:rgb(1,1,1);">PoW</span><span style="line-height:1.5;color:rgb(1,1,1);">机制让矿工们竞争记账权，谁在单位时间内执行的运算更多</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">拥有更高的算力</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">，谁就有更高的概率获得区块的记账权。获得记账权的矿工将把该区块广播到网络中，全网其他节点在验证区块满足特定的条件后，其区块会被链接在主链上，从而在全网范围内形成对当前网络状态的一次共识，该矿工也会得到系统奖励的一定数量的代币。所有的区块通过这种形式链接在一起，形成了区块链的主链，从创世区块到当前生成的最新区块，所有历史交易数据都是公开透明的。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;上面提到了区块是用于记录交易信息的，区块头中的数据参与了</span><span style="line-height:1.5;color:rgb(1,1,1);">PoW</span><span style="line-height:1.5;color:rgb(1,1,1);">的过程。那么接下来有必要进一步分析区块的内容了。</span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span><span style="line-height:1.5;color:rgb(54,95,145);">区块的组成</span></span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Microsoft YaHei';"><img src="https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132352296-510409923.png" alt="" style="border:0px;"></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;每个区块由区块头和区块体两部分组成。区块头中主要包含前一个区块的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">地址</span><span style="line-height:1.5;color:rgb(1,1,1);">(Prevhash)</span><span style="line-height:1.5;color:rgb(1,1,1);">、时间戳</span><span style="line-height:1.5;color:rgb(1,1,1);">(Timestamp)</span><span style="line-height:1.5;color:rgb(1,1,1);">、随机数</span><span style="line-height:1.5;color:rgb(1,1,1);">(Nonce)</span><span style="line-height:1.5;color:rgb(1,1,1);">、当前区块的目标</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值</span><span style="line-height:1.5;color:rgb(1,1,1);">(CurrentTarget)</span><span style="line-height:1.5;color:rgb(1,1,1);">。</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树的根值</span><span style="line-height:1.5;color:rgb(1,1,1);">(Merkle Root)</span><span style="line-height:1.5;color:rgb(1,1,1);">等信息；区块体中则包含了具体的交易数量</span><span style="line-height:1.5;color:rgb(1,1,1);">(TX NUM)</span><span style="line-height:1.5;color:rgb(1,1,1);">和自上一个区块生成以来发生的所有交易的列表。这个交易列表就是记账本，每一笔交易都会被永久地记入区块中，任何人都可以查询。而且交易都会伴随数字签名，确保交易不可篡改及真实有效性，所有交易都将通过</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">运算产生一个唯一的</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">根值记录到区块头中</span><span style="line-height:1.5;color:rgb(1,1,1);">(Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树是一种数据结构，后面将做介绍</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">。</span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span><span style="line-height:1.5;color:rgb(54,95,145);">状态转移与UTXO交易模式</span></span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;从技术的角度出发，比特币记账本可以看做是一个状态转移的系统。持有人对现存的所有比特币的持有情况，可以理解为系统当前的一种状态。例如：小明有</span><span style="line-height:1.5;color:rgb(1,1,1);">100</span><span style="line-height:1.5;color:rgb(1,1,1);">个比特币，表示在当前的状态下，小明持有</span><span style="line-height:1.5;color:rgb(1,1,1);">100</span><span style="line-height:1.5;color:rgb(1,1,1);">个比特币。当小明想进行交易时，比如给小王转</span><span style="line-height:1.5;color:rgb(1,1,1);">20</span><span style="line-height:1.5;color:rgb(1,1,1);">个比特币，就需要以当前的状态</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">拥有</span><span style="line-height:1.5;color:rgb(1,1,1);">100</span><span style="line-height:1.5;color:rgb(1,1,1);">个比特币</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">和发起的交易</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">给小王转</span><span style="line-height:1.5;color:rgb(1,1,1);">20</span><span style="line-height:1.5;color:rgb(1,1,1);">个比特币</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">，通过状态转移，生成新的状态</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">小明有</span><span style="line-height:1.5;color:rgb(1,1,1);">80</span><span style="line-height:1.5;color:rgb(1,1,1);">个比特币，小王有</span><span style="line-height:1.5;color:rgb(1,1,1);">20</span><span style="line-height:1.5;color:rgb(1,1,1);">个比特币</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">。这个状态转移可以看做是一个函数：</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Microsoft YaHei';">APPLY(STATE, TRANSACTION) =&gt; NEW_STATE</span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Microsoft YaHei';">表示小明给小王转账的交易：</span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Microsoft YaHei';">APPLY({XiaoMing: 100, XiaoWang: 0}, "send 20 from XiaoMing to XiaoWang") =&gt; {XiaoMing: 80, XiaoWang: 20 }</span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;可以发现，交易的过程就是一个从输入到输出的过程，一个资金流转的过程，并且创世区块和后来挖矿产生的奖励区块不适用于这个公式</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">创世区块是整个链上的第一个区块；挖矿的奖励区块是凭空产生的，是发行代币的方式</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">。除此之外，其他的交易都必须要依据现有的输入来产生新的输出。而现有的输入是从何而来的，必然是从这个持有人在上一笔交易中的输出得到的。稍微有点绕，按照上面的例子，假如小王要给小李再转</span><span style="line-height:1.5;color:rgb(1,1,1);">5</span><span style="line-height:1.5;color:rgb(1,1,1);">个比特币，这笔交易的输入</span><span style="line-height:1.5;color:rgb(1,1,1);">(5</span><span style="line-height:1.5;color:rgb(1,1,1);">个币</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">必须是上一笔交易</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">小明给小王转账</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">中未被使用的输出</span><span style="line-height:1.5;color:rgb(1,1,1);">(20</span><span style="line-height:1.5;color:rgb(1,1,1);">个币</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">。这个未被使用的交易输出也叫做</span><span style="line-height:1.5;color:rgb(1,1,1);">UTXO(Unspent TX Output)</span><span style="line-height:1.5;color:rgb(1,1,1);">，是比特币交易的基本单位。也可以简单理解为空闲的、未被占用的金额，就像已经花出去的钱</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">你上一笔交易的</span><span style="line-height:1.5;color:rgb(1,1,1);">UTXO)</span><span style="line-height:1.5;color:rgb(1,1,1);">是不可能再花一遍的</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">已成为别人的</span><span style="line-height:1.5;color:rgb(1,1,1);">UTXO)</span><span style="line-height:1.5;color:rgb(1,1,1);">。一笔交易可以包括一个或多个输入和一个或多个输出，每个输入包含一个对现有</span><span style="line-height:1.5;color:rgb(1,1,1);">UTXO</span><span style="line-height:1.5;color:rgb(1,1,1);">的引用和与持有者私钥创建的密码学签名；每个输出包含一个新的加入到状态中的</span><span style="line-height:1.5;color:rgb(1,1,1);">UTXO</span><span style="line-height:1.5;color:rgb(1,1,1);">。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Microsoft YaHei';"><img src="https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132415506-1545251215.png" alt="" style="border:0px;"></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Microsoft YaHei';">对于交易中的每个输入和状态，有如下的定义：</span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">1.</span><span style="line-height:1.5;color:rgb(1,1,1);">如果引用的</span><span style="line-height:1.5;color:rgb(1,1,1);">UTXO</span><span style="line-height:1.5;color:rgb(1,1,1);">不在当前的状态中，则会返回错误；如果签名与引用的</span><span style="line-height:1.5;color:rgb(1,1,1);">UTXO</span><span style="line-height:1.5;color:rgb(1,1,1);">的持有者签名不一致，也会返回错误。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">2.</span><span style="line-height:1.5;color:rgb(1,1,1);">如果所有输入的</span><span style="line-height:1.5;color:rgb(1,1,1);">UTXO</span><span style="line-height:1.5;color:rgb(1,1,1);">总额与所有输出的</span><span style="line-height:1.5;color:rgb(1,1,1);">UTXO</span><span style="line-height:1.5;color:rgb(1,1,1);">总额不等，会返回错误。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">3.</span><span style="line-height:1.5;color:rgb(1,1,1);">返回的新状态</span><span style="line-height:1.5;color:rgb(1,1,1);">NEW_STATE</span><span style="line-height:1.5;color:rgb(1,1,1);">中，移除了所有输入的</span><span style="line-height:1.5;color:rgb(1,1,1);">UTXO</span><span style="line-height:1.5;color:rgb(1,1,1);">，增加了所有输出的</span><span style="line-height:1.5;color:rgb(1,1,1);">UTXO</span><span style="line-height:1.5;color:rgb(1,1,1);">。</span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span><span style="line-height:1.5;color:rgb(54,95,145);">Merkle树</span></span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树是数据结构中的一种树结构，可以是二叉树，也可以是多叉树，具有树的所有特点。由于</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树中会进行</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">运算，所以也被称为</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">树。在了解</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树之前，先来看看</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">算法及</span><span style="line-height:1.5;color:rgb(1,1,1);">HashList</span><span style="line-height:1.5;color:rgb(1,1,1);">。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">算法是一种可以将任意长度的数据转换成固定长度字符串的算法。是一种安全散列算法。最显著的特点是几乎不可逆、无冲突。</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">算法最常见的应用就是对数据完整性的校验。例如我们在下载一些文件时，资源提供方会给出一个</span><span style="line-height:1.5;color:rgb(1,1,1);">MD5</span><span style="line-height:1.5;color:rgb(1,1,1);">或者</span><span style="line-height:1.5;color:rgb(1,1,1);">SHA</span><span style="line-height:1.5;color:rgb(1,1,1);">的值，这个值实际上就是资源在经过</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">运算后的值，用户下载数据后，可以对数据进行</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">，然后跟这个值比对，如果相同，就说明数据在传输过程中无损坏或篡改。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Microsoft YaHei';"><img src="https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132437666-538176808.png" alt="" style="border:0px;"></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;缺点：当下载较大的文件时，如果出现</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值不匹配的情况，那么就要重新下载整个文件。</span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;这种通过对整个文件进行</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">运算来判断数据是否损坏的方法，效率很低下。如果将文件分割成一个个小的数据块，分别对其做</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">，就得到了</span><span style="line-height:1.5;color:rgb(1,1,1);">HashList</span><span style="line-height:1.5;color:rgb(1,1,1);">。在点对点网络中传输数据时，会从多个节点同时下载数据。假设某些节点网络不稳定或者数据不可信，那么为了验证数据的准确性，就会采用</span><span style="line-height:1.5;color:rgb(1,1,1);">HashList</span><span style="line-height:1.5;color:rgb(1,1,1);">，如果某些数据块损坏了，只需要重新下载这些小的数据块即可，无需重新下载整个文件。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;通常在下载数据前，会先从可信数据源那里获取一个</span><span style="line-height:1.5;color:rgb(1,1,1);">Root Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值。</span><span style="line-height:1.5;color:rgb(1,1,1);">Root Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">是将</span><span style="line-height:1.5;color:rgb(1,1,1);">HashList</span><span style="line-height:1.5;color:rgb(1,1,1);">中每个数据块的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值拼接到一起，再做一次</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">运算所得到的值。这个值用来校验</span><span style="line-height:1.5;color:rgb(1,1,1);">HashList</span><span style="line-height:1.5;color:rgb(1,1,1);">是否正确。得到</span><span style="line-height:1.5;color:rgb(1,1,1);">Root Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">后，会再下载该数据的</span><span style="line-height:1.5;color:rgb(1,1,1);">HashList</span><span style="line-height:1.5;color:rgb(1,1,1);">。判断</span><span style="line-height:1.5;color:rgb(1,1,1);">HashList</span><span style="line-height:1.5;color:rgb(1,1,1);">正确后，才开始文件数据的下载。最后将下载的数据块做</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">后与</span><span style="line-height:1.5;color:rgb(1,1,1);">HashList</span><span style="line-height:1.5;color:rgb(1,1,1);">做比对，如果出现不一致，则说明数据被损坏，需要重新下载该数据块。</span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;<img src="https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132529132-1346532573.png" alt="" style="border:0px;"></span>
   <p style="line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span></p>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;然后回过头来再看</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树，它的底层与</span><span style="line-height:1.5;color:rgb(1,1,1);">HashList</span><span style="line-height:1.5;color:rgb(1,1,1);">一样，都是将数据分成小数据块，然后分别计算其</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值。但是再往上一层就不同了，它不是把所有的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值合并到一起做</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">，而是将两个相邻的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值拼接在一起进行</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">运算，产生一个新的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">。例如</span><span style="line-height:1.5;color:rgb(1,1,1);">Block1的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值</span><span style="line-height:1.5;color:rgb(1,1,1);">201w</span><span style="line-height:1.5;color:rgb(1,1,1);">与</span><span style="line-height:1.5;color:rgb(1,1,1);">Block2</span><span style="line-height:1.5;color:rgb(1,1,1);">的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值</span><span style="line-height:1.5;color:rgb(1,1,1);">0mzc</span><span style="line-height:1.5;color:rgb(1,1,1);">合并</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">后产生新的</span><span style="line-height:1.5;color:rgb(1,1,1);">3ali Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值。而如果两两匹配后出现孤立的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值，则直接将其做</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">，例如</span><span style="line-height:1.5;color:rgb(1,1,1);">Block5</span><span style="line-height:1.5;color:rgb(1,1,1);">。最终产生一个</span><span style="line-height:1.5;color:rgb(1,1,1);">Root Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值，通常称为</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle Root</span><span style="line-height:1.5;color:rgb(1,1,1);">。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">同样，在下载前，会先从可信数据源中获取正确的</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle Root</span><span style="line-height:1.5;color:rgb(1,1,1);">，然后再从其他节点下载</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树，通过</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle Root</span><span style="line-height:1.5;color:rgb(1,1,1);">来辨别</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树的真伪。如果发现不匹配，则从其他节点继续下载该</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树，直到获得一个与可信</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle Root</span><span style="line-height:1.5;color:rgb(1,1,1);">相匹配的</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp; 由于</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树是逐级分支的，所以它可以从任意一个分支开始下载并验证。考虑</span><span style="line-height:1.5;color:rgb(1,1,1);">Root-&gt;d063-&gt;09yk-&gt;a8b5-&gt;Block3</span><span style="line-height:1.5;color:rgb(1,1,1);">这个分支，如果对这个分支的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值验证通过后，就可以下载</span><span style="line-height:1.5;color:rgb(1,1,1);">Block3</span><span style="line-height:1.5;color:rgb(1,1,1);">的数据了。而在</span><span style="line-height:1.5;color:rgb(1,1,1);">HashList</span><span style="line-height:1.5;color:rgb(1,1,1);">中需要先得到整个</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值列表后才能使用</span><span style="line-height:1.5;color:rgb(1,1,1);">Root Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">验证。</span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;<img src="https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132604976-1429493735.png" alt="" style="border:0px;"></span>
   <p style="line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span></p>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp; 在区块链系统中，最下层的叶节点中存放的是交易数据，每个中间层的节点都是它的两个子节点的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">，根节点也是它的两个子节点的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">，代表</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树的顶部。如果有攻击者恶意篡改交易数据，或者篡改</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树的某一部分，必然导致上层节点的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值变动，最终导致验证不通过。</span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;<img src="https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227174209799-144174834.png" alt="" style="border:0px;"></span>
   <p style="line-height:1.5;color:rgb(0,0,0);font-size:13px;">&nbsp;</p>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp; 了解了</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle</span><span style="line-height:1.5;color:rgb(1,1,1);">树的结构后，如果我们要查找某一笔交易，那么顺序是怎样的呢？首先，可以根据区块头中的时间戳确认交易存在的具体区块。而</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle Root</span><span style="line-height:1.5;color:rgb(1,1,1);">也是放在区块头中的，如果我们从</span><span style="line-height:1.5;color:rgb(1,1,1);">Merkle Root</span><span style="line-height:1.5;color:rgb(1,1,1);">开始向下查找，假设底层有</span><span style="line-height:1.5;color:rgb(1,1,1);">n</span><span style="line-height:1.5;color:rgb(1,1,1);">笔交易数据，那么找到所需的步骤为</span><span style="line-height:1.5;color:rgb(1,1,1);">log2(n)</span><span style="line-height:1.5;color:rgb(1,1,1);">，其实就是算法中的二分查找。简化支付验证</span><span style="line-height:1.5;color:rgb(1,1,1);">(Simplified Payment Verification)</span><span style="line-height:1.5;color:rgb(1,1,1);">就是利用这种方案，实现了轻量级的钱包客户端，只需下载区块头及相关交易的分支，即可对交易进行确认。但是它也存在一些缺点：</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">1.</span><span style="line-height:1.5;color:rgb(1,1,1);">容易遭到全节点的拒绝服务，所以要保证较多的与全节点的连接，而且要保证这些节点是可信的；</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">2.spv</span><span style="line-height:1.5;color:rgb(1,1,1);">客户端向全节点请求的交易必须与它的密钥一致，这样全节点会看到该客户端的相应用户的公钥，造成隐私泄露。</span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span><span style="line-height:1.5;color:rgb(54,95,145);">P2P网络</span></span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;color:rgb(54,95,145);font-family:'Microsoft YaHei';"><img src="https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132626142-2132219804.png" alt="" style="border:0px;"></span>
   <p style="line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span></p>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;P2P</span><span style="line-height:1.5;color:rgb(1,1,1);">网络即对等网络，是一种去中心化的分布式应用架构。这种网络结构与目前传统的</span><span style="line-height:1.5;color:rgb(1,1,1);">CS(Client/Server)</span><span style="line-height:1.5;color:rgb(1,1,1);">、</span><span style="line-height:1.5;color:rgb(1,1,1);">BS(Browse Server)</span><span style="line-height:1.5;color:rgb(1,1,1);">结构的本质区别是，网络中不存在中心节点</span><span style="line-height:1.5;color:rgb(1,1,1);">/</span><span style="line-height:1.5;color:rgb(1,1,1);">服务器。在</span><span style="line-height:1.5;color:rgb(1,1,1);">P2P</span><span style="line-height:1.5;color:rgb(1,1,1);">架构中，每个节点的地位都是对等的，都具有相同的功能，无主从之分。节点通过将硬件资源以服务的形式共享到网络中，这些共享的资源可以被其他节点直接访问。一个节点既可充当服务器的角色，又是服务请求方，故节点越多，网络中可提供的资源就越多。而</span><span style="line-height:1.5;color:rgb(1,1,1);">CS</span><span style="line-height:1.5;color:rgb(1,1,1);">、</span><span style="line-height:1.5;color:rgb(1,1,1);">BS</span><span style="line-height:1.5;color:rgb(1,1,1);">这些模式都是以中心应用服务器为核心的，由用户向中心服务器发起请求，中心服务器处理请求后再将结果返回给用户。用户之间的通信也需要通过中心服务器转发来完成。所以</span><span style="line-height:1.5;color:rgb(1,1,1);">P2P</span><span style="line-height:1.5;color:rgb(1,1,1);">网络中的核心思想也是去中心化。除了这个特点，</span><span style="line-height:1.5;color:rgb(1,1,1);">P2P</span><span style="line-height:1.5;color:rgb(1,1,1);">网络还具有扩展性强、健壮性、高性价比、负载均衡、隐私保护等特点。我们日常使用的</span><span style="line-height:1.5;color:rgb(1,1,1);">BT</span><span style="line-height:1.5;color:rgb(1,1,1);">下载就是采用</span><span style="line-height:1.5;color:rgb(1,1,1);">P2P</span><span style="line-height:1.5;color:rgb(1,1,1);">让客户端之间进行数据传输。</span><span style="line-height:1.5;color:rgb(1,1,1);">BT</span><span style="line-height:1.5;color:rgb(1,1,1);">下载是通过</span><span style="line-height:1.5;color:rgb(1,1,1);">BitTorrent</span><span style="line-height:1.5;color:rgb(1,1,1);">协议</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">一种中心索引式的</span><span style="line-height:1.5;color:rgb(1,1,1);">P2P</span><span style="line-height:1.5;color:rgb(1,1,1);">文件分分析通信协议</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">，让你在下载其他用户资源的同时，也为其他用户提供上传。所以下载的人越多，可连接到的节点就越多，下载速度就越快。</span></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Microsoft YaHei';"><img src="https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132634624-918408562.png" alt="" style="border:0px;"></span>
   <p style="line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span></p>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"></span>
  </div>
  <div align="left" style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span style="line-height:1.5;color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;&nbsp;在</span><span style="line-height:1.5;color:rgb(1,1,1);">BT</span><span style="line-height:1.5;color:rgb(1,1,1);">架构中，我们发现还是存在一个</span><span style="line-height:1.5;color:rgb(1,1,1);">"</span><span style="line-height:1.5;color:rgb(1,1,1);">中心服务器</span><span style="line-height:1.5;color:rgb(1,1,1);">"</span><span style="line-height:1.5;color:rgb(1,1,1);">，该服务器的作用并非提供下载服务，而是对发布的</span><span style="line-height:1.5;color:rgb(1,1,1);">torrent</span><span style="line-height:1.5;color:rgb(1,1,1);">文件进行统一管理。</span><span style="line-height:1.5;color:rgb(1,1,1);">torrent</span><span style="line-height:1.5;color:rgb(1,1,1);">文件本质上是一个索引文件，包含了</span><span style="line-height:1.5;color:rgb(1,1,1);">Tracker</span><span style="line-height:1.5;color:rgb(1,1,1);">信息</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">发布资源的服务器的位置</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">和文件信息</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">文件名、大小、</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">值等</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">，这些信息根据</span><span style="line-height:1.5;color:rgb(1,1,1);">BitTorrent</span><span style="line-height:1.5;color:rgb(1,1,1);">协议内的</span><span style="line-height:1.5;color:rgb(1,1,1);">B</span><span style="line-height:1.5;color:rgb(1,1,1);">编码规则进行编码。</span><span style="line-height:1.5;color:rgb(1,1,1);">torrent</span><span style="line-height:1.5;color:rgb(1,1,1);">文件中的</span><span style="line-height:1.5;color:rgb(1,1,1);">Hash</span><span style="line-height:1.5;color:rgb(1,1,1);">信息是对每一块要下载的文件内容的加密结果。使用文本工具打开</span><span style="line-height:1.5;color:rgb(1,1,1);">.torrent</span><span style="line-height:1.5;color:rgb(1,1,1);">文件，就可以看个大概</span><span style="line-height:1.5;color:rgb(1,1,1);">(</span><span style="line-height:1.5;color:rgb(1,1,1);">乱码是</span><span style="line-height:1.5;color:rgb(1,1,1);">SHA1</span><span style="line-height:1.5;color:rgb(1,1,1);">校验码</span><span style="line-height:1.5;color:rgb(1,1,1);">)</span><span style="line-height:1.5;color:rgb(1,1,1);">：</span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;<img src="https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132642194-1855834450.png" alt="" style="border:0px;"></span>
   <p style="line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="line-height:1.5;font-family:'Microsoft YaHei';">&nbsp;</span></p>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;font-family:'Microsoft YaHei';"><span><span style="line-height:1.5;color:rgb(54,95,145);">结语</span></span></span>
  </div>
  <div style="color:rgb(0,0,0);font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:13px;text-align:left;background-color:rgb(255,255,255);">
   <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Microsoft YaHei';">&nbsp; &nbsp; &nbsp; 通过以上的内容可以发现，组成区块链的这些技术实际上早已有着广泛的应用，只是我们之前并未那么密切的关注过，而区块链只是将这些技术巧妙的结合到了一起。理解了这些技术的原理后，我们就可以揭开区块链神秘的面纱，去进一步窥探其中的奥秘。</span>
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/oschina_41771497/article/details/79402419,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/oschina_41771497/article/details/79402419,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
