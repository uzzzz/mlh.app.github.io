<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>通过写一个python区块链原型程序学习区块链 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="通过写一个python区块链原型程序学习区块链" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="通过写一个区块链原型程序学习区块链 &nbsp; 网上看到一篇翻译文章： https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/ &nbsp; 学习一门技术最好的方法就是自己做一个，水平有限，手敲了一遍这个代码，边敲边学，在这个过程中对区块链有了更加全面的认识，同时也学习了一些python知识。 &nbsp; 区块链基本概念 区块链是一个分布式账本，每个参与挖矿的节点共同保存全部交易信息，没有中心化认证机构，全网半数以上节点存活就可以保证交易信息正确有效。 下面通过这个原型演示程序介绍一些区块链的基本概念 &nbsp; 1.&nbsp;&nbsp;&nbsp;区块（block）： 相对完整的区块包含区块头和区块体，区块头保存区块的元数据，区块体的内容是交易信息记录，区块头中包含交易信息的Merkle树哈希，这个原型程序没有区块体，直接将区块的元数据和交易信息一起保存在区块里。 &nbsp; ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;索引：区块序号 ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间戳：区块生成的时间 ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工作量证明：生成这个区块耗费的工作量的证明 ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一个区块的哈希：为了保证整个链条的合法性不被篡改，每个区块保存前一个区块的哈希值 本程序区块： block = {&nbsp;&nbsp;&nbsp; &#39;index&#39;: len(self.chain) + 1,&nbsp;&nbsp;&nbsp; &#39;timestamp&#39;: time(),&nbsp;&nbsp;&nbsp; &#39;transactions&#39;: self.current_transactions,&nbsp;&nbsp;&nbsp; &#39;proof&#39;: proof,&nbsp;&nbsp;&nbsp; &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]),} &nbsp;2.&nbsp;&nbsp;&nbsp;区块链（blockchain）： 矿工通过挖矿把一段时间内的交易信息固化在区块内，每个区块通过在本区块存储上一个区块的哈希值形成联结关系，就像一条贪吃蛇，不断生成区块形成链条，就是区块链了。 ew_block(self, proof, previous_hash=None): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 生成一个新块，添加进链 &nbsp;&nbsp;&nbsp; :param proof: &lt;int&gt; 工作量算法给出的工作量证明 &nbsp;&nbsp;&nbsp; :param previous_hash: (optional) &lt;str&gt; 前一个块的哈希值 &nbsp;&nbsp;&nbsp; :return: &lt;dict&gt; 新块 &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; block = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;index&#39;: len(self.chain) + 1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;timestamp&#39;: time(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;transactions&#39;: self.current_transactions, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;proof&#39;: proof, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; #&nbsp; 重置交易列表 &nbsp;&nbsp;&nbsp; self.current_transactions = [] &nbsp;&nbsp;&nbsp; self.chain.append(block) &nbsp;&nbsp;&nbsp; return block 3.&nbsp;&nbsp;&nbsp;交易信息（transaction）： 区块链应用的目的是维护一个账本，也就是交易记录，比如谁什么时间给了谁多少钱。 def new_transaction(self, sender, recipient, amount): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 生成新交易信息，信息将加入到下一个待挖的区块中 &nbsp;&nbsp;&nbsp; :param sender: &lt;str&gt; 发送者地址 &nbsp;&nbsp;&nbsp; :param recipient: &lt;str&gt; 接收者地址 &nbsp;&nbsp;&nbsp; :param amount: &lt;int&gt; 交易额 &nbsp;&nbsp;&nbsp; :return: &lt;int&gt;记录这笔交易的块的索引 &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; self.current_transactions.append({ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;sender&#39;: sender, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;recipient&#39;: recipient, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;amount&#39;: amount, &nbsp;&nbsp;&nbsp; }) &nbsp;&nbsp;&nbsp; return self.last_block[&#39;index&#39;] + 1 &nbsp;4.&nbsp;&nbsp;&nbsp;挖矿（mine）： 交易随时随刻在发生，交易发生后交易信息广播给在区块链程序里注册的每一个矿工，矿工通过挖矿工作生成区块，矿工挖矿的目的就是封存交易信息，只有新的区块挖出来以后交易信息才最终得到确认。挖矿需要消耗一定的时间，比特币的规定时间是10分钟，挖矿成功的时候，把从上一个区块生成开始到挖出这个区块的时间点之间（10分钟）的交易信息封存在这个新挖出的区块里，连进区块链，并把交易记录清零。因为挖矿需要耗费时间和设备以及电力资源，挖出区块的矿工会得到奖励，矿工提供了工作量证明就能得到奖励。 def mine(): &nbsp;&nbsp;&nbsp; #&nbsp; 计算工作量证明 &nbsp;&nbsp;&nbsp; last_block = blockchain.last_block &nbsp;&nbsp;&nbsp; last_proof = last_block[&#39;proof&#39;] &nbsp;&nbsp;&nbsp; proof = blockchain.proof_of_work(last_proof) &nbsp;&nbsp;&nbsp; #&nbsp; 给工作量证明的节点提供奖励 &nbsp;&nbsp;&nbsp; #&nbsp; 发送者为0表示是新挖出的币 &nbsp;&nbsp;&nbsp; blockchain.new_transaction( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sender=0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recipient=node_identifier, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amount=1, &nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; #&nbsp; 将新block加入chain &nbsp;&nbsp;&nbsp; block = blockchain.new_block(proof) &nbsp;5.&nbsp;&nbsp;&nbsp;工作量证明（POW）： proof of work，挖矿的工足量证明是通过计算一个字符串哈希值，使这个哈希值满足一定的条件。这个字符串由前一个区块的工作量证明和一个随机数组成，由于哈希算法是单向加密，因此只能通过不断地试不同的随机数来使组合字符串的哈希值满足条件，通过对这个条件的苛刻程度进行调整可以控制挖矿的效率，即多长时间挖出一个区块。比特币使用sha256哈希算法计算工作量，本程序的POW条件为哈希值前4位为0。 @staticmethod def proof_of_work(last_proof): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 工作量证明： &nbsp;&nbsp;&nbsp;&nbsp; - 查找一个p&#39;使得hash(pp&#39;)以4个0开头 &nbsp;&nbsp;&nbsp;&nbsp; - p是上一个块的proof，p’是当前的proof &nbsp;&nbsp;&nbsp; :param last_proof: &lt;int&gt; &nbsp;&nbsp;&nbsp; :return: &lt;int&gt; &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; proof = 0 &nbsp;&nbsp;&nbsp; while hashlib.sha256(f&#39;{last_proof}{proof}&#39;.encode()).hexdigest()[:4] != &#39;0000&#39;: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;proof += 1 &nbsp;&nbsp;&nbsp; return proof &nbsp;6.&nbsp;&nbsp;&nbsp;分叉冲突（conflict） 每个矿工在自己的链尾添加新区块，为了解决分布式系统的一致性问题，要解决分叉冲突。本程序每个矿工维护自己的链，解决冲突的方法是手工轮训每个矿工维护的链，找到最长链，如果比自己的链长，就把自己的链替换为这个最长链。 def resolve_conflicts(self): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 共识算法解决冲突 &nbsp;&nbsp;&nbsp; 使用网络中最长的链 &nbsp;&nbsp;&nbsp; :return: &lt;bool&gt; True如果链被取代，否则为False &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; neighbours = self.nodes &nbsp;&nbsp;&nbsp; new_chain = None &nbsp;&nbsp;&nbsp; max_length = len(self.chain) &nbsp;&nbsp;&nbsp; #&nbsp; 抓取并验证网络中所有节点的链 &nbsp;&nbsp;&nbsp; for node in neighbours: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = requests.get(f&#39;http://{node}/chain&#39;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(node) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if response.status_code == 200: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length = response.json()[&#39;length&#39;] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chain = response.json()[&#39;chain&#39;] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(length) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(chain) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(self.valid_chain(chain)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; 检查链的长度是否更长，链是否合法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if length &gt; max_length and self.valid_chain(chain): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_length = length &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_chain = chain &nbsp;&nbsp;&nbsp; #&nbsp; 如果发现了新的合法的更长的链就用它替换我的链 &nbsp;&nbsp;&nbsp; if new_chain: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.chain = new_chain &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True &nbsp;&nbsp;&nbsp; return False &nbsp; 区块链运行机制 本程序使用python flask框架实现web接口，作为一个原型演示程序实现了如下功能： 1.&nbsp;&nbsp;&nbsp;当有新的矿工节点加入工作网络，它把其他节点注册进自己的节点列表并把自己注册到其他全部矿工节点 2.&nbsp;&nbsp;&nbsp;各节点可以随时添加交易信息，不过本程序未实现交易信息的广播 3.&nbsp;&nbsp;&nbsp;矿工挖矿生成新区块添加进自己的链 4.&nbsp;&nbsp;&nbsp;轮训查找最长链替换自己的链 &nbsp; 功能演示 在80节点注册81和82节点 在81节点添加交易信息 在81节点挖矿 在80节点解决冲突，链条被替换为81节点的链条 在82节点注册80和81节点 在82节点解决冲突，链条被替换为最长链 &nbsp; 本程序可以扩充的简单功能 广播交易信息 挖矿前解决分叉冲突 加长POW计算时间 &nbsp; 程序代码及运行方法 代码放在github，建议使用docker运行 https://github.com/YngwieWang/blockchain 阅读更多" />
<meta property="og:description" content="通过写一个区块链原型程序学习区块链 &nbsp; 网上看到一篇翻译文章： https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/ &nbsp; 学习一门技术最好的方法就是自己做一个，水平有限，手敲了一遍这个代码，边敲边学，在这个过程中对区块链有了更加全面的认识，同时也学习了一些python知识。 &nbsp; 区块链基本概念 区块链是一个分布式账本，每个参与挖矿的节点共同保存全部交易信息，没有中心化认证机构，全网半数以上节点存活就可以保证交易信息正确有效。 下面通过这个原型演示程序介绍一些区块链的基本概念 &nbsp; 1.&nbsp;&nbsp;&nbsp;区块（block）： 相对完整的区块包含区块头和区块体，区块头保存区块的元数据，区块体的内容是交易信息记录，区块头中包含交易信息的Merkle树哈希，这个原型程序没有区块体，直接将区块的元数据和交易信息一起保存在区块里。 &nbsp; ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;索引：区块序号 ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间戳：区块生成的时间 ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工作量证明：生成这个区块耗费的工作量的证明 ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一个区块的哈希：为了保证整个链条的合法性不被篡改，每个区块保存前一个区块的哈希值 本程序区块： block = {&nbsp;&nbsp;&nbsp; &#39;index&#39;: len(self.chain) + 1,&nbsp;&nbsp;&nbsp; &#39;timestamp&#39;: time(),&nbsp;&nbsp;&nbsp; &#39;transactions&#39;: self.current_transactions,&nbsp;&nbsp;&nbsp; &#39;proof&#39;: proof,&nbsp;&nbsp;&nbsp; &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]),} &nbsp;2.&nbsp;&nbsp;&nbsp;区块链（blockchain）： 矿工通过挖矿把一段时间内的交易信息固化在区块内，每个区块通过在本区块存储上一个区块的哈希值形成联结关系，就像一条贪吃蛇，不断生成区块形成链条，就是区块链了。 ew_block(self, proof, previous_hash=None): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 生成一个新块，添加进链 &nbsp;&nbsp;&nbsp; :param proof: &lt;int&gt; 工作量算法给出的工作量证明 &nbsp;&nbsp;&nbsp; :param previous_hash: (optional) &lt;str&gt; 前一个块的哈希值 &nbsp;&nbsp;&nbsp; :return: &lt;dict&gt; 新块 &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; block = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;index&#39;: len(self.chain) + 1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;timestamp&#39;: time(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;transactions&#39;: self.current_transactions, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;proof&#39;: proof, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; #&nbsp; 重置交易列表 &nbsp;&nbsp;&nbsp; self.current_transactions = [] &nbsp;&nbsp;&nbsp; self.chain.append(block) &nbsp;&nbsp;&nbsp; return block 3.&nbsp;&nbsp;&nbsp;交易信息（transaction）： 区块链应用的目的是维护一个账本，也就是交易记录，比如谁什么时间给了谁多少钱。 def new_transaction(self, sender, recipient, amount): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 生成新交易信息，信息将加入到下一个待挖的区块中 &nbsp;&nbsp;&nbsp; :param sender: &lt;str&gt; 发送者地址 &nbsp;&nbsp;&nbsp; :param recipient: &lt;str&gt; 接收者地址 &nbsp;&nbsp;&nbsp; :param amount: &lt;int&gt; 交易额 &nbsp;&nbsp;&nbsp; :return: &lt;int&gt;记录这笔交易的块的索引 &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; self.current_transactions.append({ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;sender&#39;: sender, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;recipient&#39;: recipient, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;amount&#39;: amount, &nbsp;&nbsp;&nbsp; }) &nbsp;&nbsp;&nbsp; return self.last_block[&#39;index&#39;] + 1 &nbsp;4.&nbsp;&nbsp;&nbsp;挖矿（mine）： 交易随时随刻在发生，交易发生后交易信息广播给在区块链程序里注册的每一个矿工，矿工通过挖矿工作生成区块，矿工挖矿的目的就是封存交易信息，只有新的区块挖出来以后交易信息才最终得到确认。挖矿需要消耗一定的时间，比特币的规定时间是10分钟，挖矿成功的时候，把从上一个区块生成开始到挖出这个区块的时间点之间（10分钟）的交易信息封存在这个新挖出的区块里，连进区块链，并把交易记录清零。因为挖矿需要耗费时间和设备以及电力资源，挖出区块的矿工会得到奖励，矿工提供了工作量证明就能得到奖励。 def mine(): &nbsp;&nbsp;&nbsp; #&nbsp; 计算工作量证明 &nbsp;&nbsp;&nbsp; last_block = blockchain.last_block &nbsp;&nbsp;&nbsp; last_proof = last_block[&#39;proof&#39;] &nbsp;&nbsp;&nbsp; proof = blockchain.proof_of_work(last_proof) &nbsp;&nbsp;&nbsp; #&nbsp; 给工作量证明的节点提供奖励 &nbsp;&nbsp;&nbsp; #&nbsp; 发送者为0表示是新挖出的币 &nbsp;&nbsp;&nbsp; blockchain.new_transaction( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sender=0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recipient=node_identifier, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amount=1, &nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; #&nbsp; 将新block加入chain &nbsp;&nbsp;&nbsp; block = blockchain.new_block(proof) &nbsp;5.&nbsp;&nbsp;&nbsp;工作量证明（POW）： proof of work，挖矿的工足量证明是通过计算一个字符串哈希值，使这个哈希值满足一定的条件。这个字符串由前一个区块的工作量证明和一个随机数组成，由于哈希算法是单向加密，因此只能通过不断地试不同的随机数来使组合字符串的哈希值满足条件，通过对这个条件的苛刻程度进行调整可以控制挖矿的效率，即多长时间挖出一个区块。比特币使用sha256哈希算法计算工作量，本程序的POW条件为哈希值前4位为0。 @staticmethod def proof_of_work(last_proof): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 工作量证明： &nbsp;&nbsp;&nbsp;&nbsp; - 查找一个p&#39;使得hash(pp&#39;)以4个0开头 &nbsp;&nbsp;&nbsp;&nbsp; - p是上一个块的proof，p’是当前的proof &nbsp;&nbsp;&nbsp; :param last_proof: &lt;int&gt; &nbsp;&nbsp;&nbsp; :return: &lt;int&gt; &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; proof = 0 &nbsp;&nbsp;&nbsp; while hashlib.sha256(f&#39;{last_proof}{proof}&#39;.encode()).hexdigest()[:4] != &#39;0000&#39;: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;proof += 1 &nbsp;&nbsp;&nbsp; return proof &nbsp;6.&nbsp;&nbsp;&nbsp;分叉冲突（conflict） 每个矿工在自己的链尾添加新区块，为了解决分布式系统的一致性问题，要解决分叉冲突。本程序每个矿工维护自己的链，解决冲突的方法是手工轮训每个矿工维护的链，找到最长链，如果比自己的链长，就把自己的链替换为这个最长链。 def resolve_conflicts(self): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 共识算法解决冲突 &nbsp;&nbsp;&nbsp; 使用网络中最长的链 &nbsp;&nbsp;&nbsp; :return: &lt;bool&gt; True如果链被取代，否则为False &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; neighbours = self.nodes &nbsp;&nbsp;&nbsp; new_chain = None &nbsp;&nbsp;&nbsp; max_length = len(self.chain) &nbsp;&nbsp;&nbsp; #&nbsp; 抓取并验证网络中所有节点的链 &nbsp;&nbsp;&nbsp; for node in neighbours: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = requests.get(f&#39;http://{node}/chain&#39;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(node) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if response.status_code == 200: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length = response.json()[&#39;length&#39;] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chain = response.json()[&#39;chain&#39;] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(length) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(chain) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(self.valid_chain(chain)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; 检查链的长度是否更长，链是否合法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if length &gt; max_length and self.valid_chain(chain): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_length = length &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_chain = chain &nbsp;&nbsp;&nbsp; #&nbsp; 如果发现了新的合法的更长的链就用它替换我的链 &nbsp;&nbsp;&nbsp; if new_chain: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.chain = new_chain &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True &nbsp;&nbsp;&nbsp; return False &nbsp; 区块链运行机制 本程序使用python flask框架实现web接口，作为一个原型演示程序实现了如下功能： 1.&nbsp;&nbsp;&nbsp;当有新的矿工节点加入工作网络，它把其他节点注册进自己的节点列表并把自己注册到其他全部矿工节点 2.&nbsp;&nbsp;&nbsp;各节点可以随时添加交易信息，不过本程序未实现交易信息的广播 3.&nbsp;&nbsp;&nbsp;矿工挖矿生成新区块添加进自己的链 4.&nbsp;&nbsp;&nbsp;轮训查找最长链替换自己的链 &nbsp; 功能演示 在80节点注册81和82节点 在81节点添加交易信息 在81节点挖矿 在80节点解决冲突，链条被替换为81节点的链条 在82节点注册80和81节点 在82节点解决冲突，链条被替换为最长链 &nbsp; 本程序可以扩充的简单功能 广播交易信息 挖矿前解决分叉冲突 加长POW计算时间 &nbsp; 程序代码及运行方法 代码放在github，建议使用docker运行 https://github.com/YngwieWang/blockchain 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/02/15/fd1f28ba08a12a9876962dae4630f7e3.html" />
<meta property="og:url" content="https://mlh.app/2018/02/15/fd1f28ba08a12a9876962dae4630f7e3.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-15T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"通过写一个区块链原型程序学习区块链 &nbsp; 网上看到一篇翻译文章： https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/ &nbsp; 学习一门技术最好的方法就是自己做一个，水平有限，手敲了一遍这个代码，边敲边学，在这个过程中对区块链有了更加全面的认识，同时也学习了一些python知识。 &nbsp; 区块链基本概念 区块链是一个分布式账本，每个参与挖矿的节点共同保存全部交易信息，没有中心化认证机构，全网半数以上节点存活就可以保证交易信息正确有效。 下面通过这个原型演示程序介绍一些区块链的基本概念 &nbsp; 1.&nbsp;&nbsp;&nbsp;区块（block）： 相对完整的区块包含区块头和区块体，区块头保存区块的元数据，区块体的内容是交易信息记录，区块头中包含交易信息的Merkle树哈希，这个原型程序没有区块体，直接将区块的元数据和交易信息一起保存在区块里。 &nbsp; ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;索引：区块序号 ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间戳：区块生成的时间 ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工作量证明：生成这个区块耗费的工作量的证明 ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一个区块的哈希：为了保证整个链条的合法性不被篡改，每个区块保存前一个区块的哈希值 本程序区块： block = {&nbsp;&nbsp;&nbsp; &#39;index&#39;: len(self.chain) + 1,&nbsp;&nbsp;&nbsp; &#39;timestamp&#39;: time(),&nbsp;&nbsp;&nbsp; &#39;transactions&#39;: self.current_transactions,&nbsp;&nbsp;&nbsp; &#39;proof&#39;: proof,&nbsp;&nbsp;&nbsp; &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]),} &nbsp;2.&nbsp;&nbsp;&nbsp;区块链（blockchain）： 矿工通过挖矿把一段时间内的交易信息固化在区块内，每个区块通过在本区块存储上一个区块的哈希值形成联结关系，就像一条贪吃蛇，不断生成区块形成链条，就是区块链了。 ew_block(self, proof, previous_hash=None): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 生成一个新块，添加进链 &nbsp;&nbsp;&nbsp; :param proof: &lt;int&gt; 工作量算法给出的工作量证明 &nbsp;&nbsp;&nbsp; :param previous_hash: (optional) &lt;str&gt; 前一个块的哈希值 &nbsp;&nbsp;&nbsp; :return: &lt;dict&gt; 新块 &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; block = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;index&#39;: len(self.chain) + 1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;timestamp&#39;: time(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;transactions&#39;: self.current_transactions, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;proof&#39;: proof, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; #&nbsp; 重置交易列表 &nbsp;&nbsp;&nbsp; self.current_transactions = [] &nbsp;&nbsp;&nbsp; self.chain.append(block) &nbsp;&nbsp;&nbsp; return block 3.&nbsp;&nbsp;&nbsp;交易信息（transaction）： 区块链应用的目的是维护一个账本，也就是交易记录，比如谁什么时间给了谁多少钱。 def new_transaction(self, sender, recipient, amount): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 生成新交易信息，信息将加入到下一个待挖的区块中 &nbsp;&nbsp;&nbsp; :param sender: &lt;str&gt; 发送者地址 &nbsp;&nbsp;&nbsp; :param recipient: &lt;str&gt; 接收者地址 &nbsp;&nbsp;&nbsp; :param amount: &lt;int&gt; 交易额 &nbsp;&nbsp;&nbsp; :return: &lt;int&gt;记录这笔交易的块的索引 &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; self.current_transactions.append({ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;sender&#39;: sender, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;recipient&#39;: recipient, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#39;amount&#39;: amount, &nbsp;&nbsp;&nbsp; }) &nbsp;&nbsp;&nbsp; return self.last_block[&#39;index&#39;] + 1 &nbsp;4.&nbsp;&nbsp;&nbsp;挖矿（mine）： 交易随时随刻在发生，交易发生后交易信息广播给在区块链程序里注册的每一个矿工，矿工通过挖矿工作生成区块，矿工挖矿的目的就是封存交易信息，只有新的区块挖出来以后交易信息才最终得到确认。挖矿需要消耗一定的时间，比特币的规定时间是10分钟，挖矿成功的时候，把从上一个区块生成开始到挖出这个区块的时间点之间（10分钟）的交易信息封存在这个新挖出的区块里，连进区块链，并把交易记录清零。因为挖矿需要耗费时间和设备以及电力资源，挖出区块的矿工会得到奖励，矿工提供了工作量证明就能得到奖励。 def mine(): &nbsp;&nbsp;&nbsp; #&nbsp; 计算工作量证明 &nbsp;&nbsp;&nbsp; last_block = blockchain.last_block &nbsp;&nbsp;&nbsp; last_proof = last_block[&#39;proof&#39;] &nbsp;&nbsp;&nbsp; proof = blockchain.proof_of_work(last_proof) &nbsp;&nbsp;&nbsp; #&nbsp; 给工作量证明的节点提供奖励 &nbsp;&nbsp;&nbsp; #&nbsp; 发送者为0表示是新挖出的币 &nbsp;&nbsp;&nbsp; blockchain.new_transaction( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sender=0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recipient=node_identifier, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amount=1, &nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; #&nbsp; 将新block加入chain &nbsp;&nbsp;&nbsp; block = blockchain.new_block(proof) &nbsp;5.&nbsp;&nbsp;&nbsp;工作量证明（POW）： proof of work，挖矿的工足量证明是通过计算一个字符串哈希值，使这个哈希值满足一定的条件。这个字符串由前一个区块的工作量证明和一个随机数组成，由于哈希算法是单向加密，因此只能通过不断地试不同的随机数来使组合字符串的哈希值满足条件，通过对这个条件的苛刻程度进行调整可以控制挖矿的效率，即多长时间挖出一个区块。比特币使用sha256哈希算法计算工作量，本程序的POW条件为哈希值前4位为0。 @staticmethod def proof_of_work(last_proof): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 工作量证明： &nbsp;&nbsp;&nbsp;&nbsp; - 查找一个p&#39;使得hash(pp&#39;)以4个0开头 &nbsp;&nbsp;&nbsp;&nbsp; - p是上一个块的proof，p’是当前的proof &nbsp;&nbsp;&nbsp; :param last_proof: &lt;int&gt; &nbsp;&nbsp;&nbsp; :return: &lt;int&gt; &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; proof = 0 &nbsp;&nbsp;&nbsp; while hashlib.sha256(f&#39;{last_proof}{proof}&#39;.encode()).hexdigest()[:4] != &#39;0000&#39;: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;proof += 1 &nbsp;&nbsp;&nbsp; return proof &nbsp;6.&nbsp;&nbsp;&nbsp;分叉冲突（conflict） 每个矿工在自己的链尾添加新区块，为了解决分布式系统的一致性问题，要解决分叉冲突。本程序每个矿工维护自己的链，解决冲突的方法是手工轮训每个矿工维护的链，找到最长链，如果比自己的链长，就把自己的链替换为这个最长链。 def resolve_conflicts(self): &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; 共识算法解决冲突 &nbsp;&nbsp;&nbsp; 使用网络中最长的链 &nbsp;&nbsp;&nbsp; :return: &lt;bool&gt; True如果链被取代，否则为False &nbsp;&nbsp;&nbsp; &quot;&quot;&quot; &nbsp;&nbsp;&nbsp; neighbours = self.nodes &nbsp;&nbsp;&nbsp; new_chain = None &nbsp;&nbsp;&nbsp; max_length = len(self.chain) &nbsp;&nbsp;&nbsp; #&nbsp; 抓取并验证网络中所有节点的链 &nbsp;&nbsp;&nbsp; for node in neighbours: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = requests.get(f&#39;http://{node}/chain&#39;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(node) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if response.status_code == 200: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length = response.json()[&#39;length&#39;] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chain = response.json()[&#39;chain&#39;] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(length) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(chain) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(self.valid_chain(chain)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; 检查链的长度是否更长，链是否合法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if length &gt; max_length and self.valid_chain(chain): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_length = length &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_chain = chain &nbsp;&nbsp;&nbsp; #&nbsp; 如果发现了新的合法的更长的链就用它替换我的链 &nbsp;&nbsp;&nbsp; if new_chain: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.chain = new_chain &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True &nbsp;&nbsp;&nbsp; return False &nbsp; 区块链运行机制 本程序使用python flask框架实现web接口，作为一个原型演示程序实现了如下功能： 1.&nbsp;&nbsp;&nbsp;当有新的矿工节点加入工作网络，它把其他节点注册进自己的节点列表并把自己注册到其他全部矿工节点 2.&nbsp;&nbsp;&nbsp;各节点可以随时添加交易信息，不过本程序未实现交易信息的广播 3.&nbsp;&nbsp;&nbsp;矿工挖矿生成新区块添加进自己的链 4.&nbsp;&nbsp;&nbsp;轮训查找最长链替换自己的链 &nbsp; 功能演示 在80节点注册81和82节点 在81节点添加交易信息 在81节点挖矿 在80节点解决冲突，链条被替换为81节点的链条 在82节点注册80和81节点 在82节点解决冲突，链条被替换为最长链 &nbsp; 本程序可以扩充的简单功能 广播交易信息 挖矿前解决分叉冲突 加长POW计算时间 &nbsp; 程序代码及运行方法 代码放在github，建议使用docker运行 https://github.com/YngwieWang/blockchain 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/02/15/fd1f28ba08a12a9876962dae4630f7e3.html","headline":"通过写一个python区块链原型程序学习区块链","dateModified":"2018-02-15T00:00:00+08:00","datePublished":"2018-02-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/02/15/fd1f28ba08a12a9876962dae4630f7e3.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>通过写一个python区块链原型程序学习区块链</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><strong>通过写一个区块链原型程序学习区块链</strong></p>
  <p>&nbsp;</p>
  <p>网上看到一篇翻译文章：</p>
  <p><a href="https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/" rel="nofollow"><span style="color:#003884;">https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/</span></a></p>
  <p>&nbsp;</p>
  <p>学习一门技术最好的方法就是自己做一个，水平有限，手敲了一遍这个代码，边敲边学，在这个过程中对区块链有了更加全面的认识，同时也学习了一些python知识。</p>
  <p>&nbsp;</p>
  <p><strong>区块链基本概念</strong></p>
  <p><span style="color:#FF0000;">区块链是一个分布式账本，每个参与挖矿的节点共同保存全部交易信息，没有中心化认证机构，全网半数以上节点存活就可以保证交易信息正确有效。</span></p>
  <p>下面通过这个原型演示程序介绍一些区块链的基本概念</p>
  <p>&nbsp;</p>
  <p>1.&nbsp;&nbsp;&nbsp;区块（block）：</p>
  <p>相对完整的区块包含区块头和区块体，区块头保存区块的元数据，区块体的内容是交易信息记录，区块头中包含交易信息的Merkle树哈希，这个原型程序没有区块体，直接将区块的元数据和交易信息一起保存在区块里。</p>
  <p style="text-align:left;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180215231604534" alt="">&nbsp;</p>
  <p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;索引：区块序号</p>
  <p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间戳：区块生成的时间</p>
  <p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工作量证明：生成这个区块耗费的工作量的证明</p>
  <p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一个区块的哈希：为了保证整个链条的合法性不被篡改，每个区块保存前一个区块的哈希值</p>
  <p>本程序区块：</p>
  <p style="background:#141414;"><span style="color:#F8F8F8;">block </span><span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">{<br>&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'index'</span><span style="color:#CDA869;">: </span><span style="color:#DAD085;">len</span><span style="color:#F8F8F8;">(</span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.chain) </span><span style="color:#CDA869;">+ </span><span style="color:#CF6A4C;">1</span><span style="color:#F8F8F8;">,<br>&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'timestamp'</span><span style="color:#CDA869;">: </span><span style="color:#9B703F;">time</span><span style="color:#F8F8F8;">(),<br>&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'transactions'</span><span style="color:#CDA869;">: </span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.current_transactions,<br>&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'proof'</span><span style="color:#CDA869;">: </span><span style="color:#7587A6;">proof</span><span style="color:#F8F8F8;">,<br>&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'previous_hash'</span><span style="color:#CDA869;">: </span><span style="color:#7587A6;">previous_hash </span><span style="color:#F9EE98;">or </span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.</span><span style="color:#9B703F;">hash</span><span style="color:#F8F8F8;">(</span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.chain[</span><span style="color:#CDA869;">-</span><span style="color:#CF6A4C;">1</span><span style="color:#F8F8F8;">]),<br>}</span></p>
  <p>&nbsp;2.&nbsp;&nbsp;&nbsp;区块链（blockchain）：</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180215231616848" alt=""><strong></strong></p>
  <p><span style="color:#FF0000;">矿工通过挖矿把一段时间内的交易信息固化在区块内，每个区块通过在本区块存储上一个区块的哈希值形成联结关系，就像一条<strong>贪吃蛇</strong>，不断生成区块形成链条，就是区块链了。</span></p>
  <pre style="background:#141414;"><span style="color:#9B703F;">ew_block</span><span style="color:#F8F8F8;">(</span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">, </span><span style="color:#7587A6;">proof</span><span style="color:#F8F8F8;">, </span><span style="color:#7587A6;">previous_hash</span><span style="color:#CDA869;">=</span><span style="color:#F9EE98;">None</span><span style="color:#F8F8F8;">)</span><span style="color:#CDA869;">:
&nbsp;&nbsp;&nbsp; </span><em><span style="color:#5F5A60;">""" &nbsp;&nbsp;&nbsp; </span>生成一个新块，添加进链
&nbsp;&nbsp;&nbsp; :param proof: &lt;int&gt; 工作量算法给出的工作量证明
&nbsp;&nbsp;&nbsp; :param previous_hash: (optional) &lt;str&gt; 前一个块的哈希值
&nbsp;&nbsp;&nbsp; :return: &lt;dict&gt; 新块
&nbsp;&nbsp;&nbsp; """

&nbsp;&nbsp;&nbsp; </em><span style="color:#F8F8F8;">block </span><span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'index'</span><span style="color:#CDA869;">: </span><span style="color:#DAD085;">len</span><span style="color:#F8F8F8;">(</span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.chain) </span><span style="color:#CDA869;">+ </span><span style="color:#CF6A4C;">1</span><span style="color:#F8F8F8;">,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'timestamp'</span><span style="color:#CDA869;">: </span><span style="color:#9B703F;">time</span><span style="color:#F8F8F8;">(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'transactions'</span><span style="color:#CDA869;">: </span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.current_transactions,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'proof'</span><span style="color:#CDA869;">: </span><span style="color:#7587A6;">proof</span><span style="color:#F8F8F8;">,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'previous_hash'</span><span style="color:#CDA869;">: </span><span style="color:#7587A6;">previous_hash </span><span style="color:#F9EE98;">or </span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.</span><span style="color:#9B703F;">hash</span><span style="color:#F8F8F8;">(</span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.chain[</span><span style="color:#CDA869;">-</span><span style="color:#CF6A4C;">1</span><span style="color:#F8F8F8;">]),
&nbsp;&nbsp;&nbsp; </span>}

&nbsp;&nbsp;&nbsp; <em><span style="color:#5F5A60;">#&nbsp; </span>重置交易列表
&nbsp;&nbsp;&nbsp; </em><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.current_transactions </span><span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">[]

&nbsp;&nbsp;&nbsp; </span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.chain.</span><span style="color:#9B703F;">append</span><span style="color:#F8F8F8;">(block)
&nbsp;&nbsp;&nbsp; </span><span style="color:#F9EE98;">return </span><span style="color:#F8F8F8;">block</span></pre>
  <p>3.&nbsp;&nbsp;&nbsp;交易信息（transaction）：</p>
  <p>区块链应用的目的是维护一个账本，也就是交易记录，比如谁什么时间给了谁多少钱。</p>
  <pre style="background:#141414;"><span style="color:#F9EE98;">def </span><span style="color:#9B703F;">new_transaction</span><span style="color:#F8F8F8;">(</span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">, </span><span style="color:#7587A6;">sender</span><span style="color:#F8F8F8;">, </span><span style="color:#7587A6;">recipient</span><span style="color:#F8F8F8;">, </span><span style="color:#7587A6;">amount</span><span style="color:#F8F8F8;">)</span><span style="color:#CDA869;">:
&nbsp;&nbsp;&nbsp; </span><em><span style="color:#5F5A60;">""" &nbsp;&nbsp;&nbsp; </span>生成新交易信息，信息将加入到下一个待挖的区块中
&nbsp;&nbsp;&nbsp; :param sender: &lt;str&gt; 发送者地址
&nbsp;&nbsp;&nbsp; :param recipient: &lt;str&gt; 接收者地址
&nbsp;&nbsp;&nbsp; :param amount: &lt;int&gt; 交易额
&nbsp;&nbsp;&nbsp; :return: &lt;int&gt;记录这笔交易的块的索引
&nbsp;&nbsp;&nbsp; """

&nbsp;&nbsp;&nbsp; </em><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.current_transactions.</span><span style="color:#9B703F;">append</span><span style="color:#F8F8F8;">({
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'sender'</span><span style="color:#CDA869;">: </span><span style="color:#7587A6;">sender</span><span style="color:#F8F8F8;">,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'recipient'</span><span style="color:#CDA869;">: </span><span style="color:#7587A6;">recipient</span><span style="color:#F8F8F8;">,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#8F9D6A;">'amount'</span><span style="color:#CDA869;">: </span><span style="color:#7587A6;">amount</span><span style="color:#F8F8F8;">,
&nbsp;&nbsp;&nbsp; </span>})

&nbsp;&nbsp;&nbsp; <span style="color:#F9EE98;">return </span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.last_block[</span><span style="color:#8F9D6A;">'index'</span><span style="color:#F8F8F8;">] </span><span style="color:#CDA869;">+ </span><span style="color:#CF6A4C;">1</span></pre>
  <p><span style="color:#FF0000;">&nbsp;</span>4.&nbsp;&nbsp;&nbsp;挖矿（mine）：</p>
  <p>交易随时随刻在发生，交易发生后交易信息广播给在区块链程序里注册的每一个矿工，矿工通过挖矿工作生成区块，矿工挖矿的目的就是封存交易信息，只有新的区块挖出来以后交易信息才最终得到确认。挖矿需要消耗一定的时间，比特币的规定时间是10分钟，挖矿成功的时候，把从上一个区块生成开始到挖出这个区块的时间点之间（10分钟）的交易信息封存在这个新挖出的区块里，连进区块链，并把交易记录清零。因为挖矿需要耗费时间和设备以及电力资源，挖出区块的矿工会得到奖励，矿工提供了工作量证明就能得到奖励。</p>
  <pre style="background:#141414;"><span style="color:#F9EE98;">def </span><span style="color:#9B703F;">mine</span><span style="color:#F8F8F8;">()</span><span style="color:#CDA869;">:
&nbsp;&nbsp;&nbsp; </span><em><span style="color:#5F5A60;">#&nbsp; </span>计算工作量证明
&nbsp;&nbsp;&nbsp; </em><span style="color:#F8F8F8;">last_block </span><span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">blockchain.last_block
&nbsp;&nbsp;&nbsp; </span>last_proof <span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">last_block[</span><span style="color:#8F9D6A;">'proof'</span><span style="color:#F8F8F8;">]
&nbsp;&nbsp;&nbsp; </span>proof <span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">blockchain.</span><span style="color:#9B703F;">proof_of_work</span><span style="color:#F8F8F8;">(last_proof)

&nbsp;&nbsp;&nbsp; </span><em><span style="color:#5F5A60;">#&nbsp; </span>给工作量证明的节点提供奖励
&nbsp;&nbsp;&nbsp; #&nbsp; 发送者为0表示是新挖出的币
&nbsp;&nbsp;&nbsp; </em><span style="color:#F8F8F8;">blockchain.</span><span style="color:#9B703F;">new_transaction</span><span style="color:#F8F8F8;">(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#AA4926;">sender</span><span style="color:#CDA869;">=</span><span style="color:#CF6A4C;">0</span><span style="color:#F8F8F8;">,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#AA4926;">recipient</span><span style="color:#CDA869;">=</span><span style="color:#F8F8F8;">node_identifier,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#AA4926;">amount</span><span style="color:#CDA869;">=</span><span style="color:#CF6A4C;">1</span><span style="color:#F8F8F8;">,
&nbsp;&nbsp;&nbsp; </span>)

&nbsp;&nbsp;&nbsp; <em><span style="color:#5F5A60;">#&nbsp; </span>将新block加入chain
&nbsp;&nbsp;&nbsp; </em><span style="color:#F8F8F8;">block </span><span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">blockchain.</span><span style="color:#9B703F;">new_block</span><span style="color:#F8F8F8;">(proof)</span></pre>
  <p>&nbsp;5.&nbsp;&nbsp;&nbsp;工作量证明（POW）：</p>
  <p>proof of work，挖矿的工足量证明是通过计算一个字符串哈希值，使这个哈希值满足一定的条件。这个字符串由前一个区块的工作量证明和一个随机数组成，由于哈希算法是单向加密，因此只能通过不断地试不同的随机数来使组合字符串的哈希值满足条件，通过对这个条件的苛刻程度进行调整可以控制挖矿的效率，即多长时间挖出一个区块。比特币使用sha256哈希算法计算工作量，本程序的POW条件为哈希值前4位为0。</p>
  <pre style="background:#141414;"><span style="color:#9B703F;">@staticmethod
</span><span style="color:#F9EE98;">def </span><span style="color:#9B703F;">proof_of_work</span><span style="color:#F8F8F8;">(</span><span style="color:#7587A6;">last_proof</span><span style="color:#F8F8F8;">)</span><span style="color:#CDA869;">:
&nbsp;&nbsp;&nbsp; </span><em><span style="color:#5F5A60;">""" &nbsp;&nbsp;&nbsp; </span>工作量证明：
&nbsp;&nbsp;&nbsp;&nbsp; - 查找一个p'使得hash(pp')以4个0开头
&nbsp;&nbsp;&nbsp;&nbsp; - p是上一个块的proof，p’是当前的proof
&nbsp;&nbsp;&nbsp; :param last_proof: &lt;int&gt;
&nbsp;&nbsp;&nbsp; :return: &lt;int&gt;
&nbsp;&nbsp;&nbsp; """
&nbsp;&nbsp;&nbsp; </em><span style="color:#F8F8F8;">proof </span><span style="color:#CDA869;">= </span><span style="color:#CF6A4C;">0
&nbsp;&nbsp;&nbsp; </span><span style="color:#F9EE98;">while </span><span style="color:#F8F8F8;">hashlib.</span><span style="color:#9B703F;">sha256</span><span style="color:#F8F8F8;">(</span><span style="color:#8F9D6A;">f'{last_proof}{proof}'</span><span style="color:#F8F8F8;">.</span><span style="color:#9B703F;">encode</span><span style="color:#F8F8F8;">()).</span><span style="color:#9B703F;">hexdigest</span><span style="color:#F8F8F8;">()[</span><span style="color:#CDA869;">:</span><span style="color:#CF6A4C;">4</span><span style="color:#F8F8F8;">] </span><span style="color:#CDA869;">!= </span><span style="color:#8F9D6A;">'0000'</span><span style="color:#CDA869;">:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&nbsp;&nbsp;<span style="color:#F8F8F8;">proof </span><span style="color:#CDA869;">+= </span><span style="color:#CF6A4C;">1
&nbsp;&nbsp;&nbsp; </span><span style="color:#F9EE98;">return </span><span style="color:#F8F8F8;">proof</span></pre>
  <p>&nbsp;6.&nbsp;&nbsp;&nbsp;分叉冲突（conflict）</p>
  <p>每个矿工在自己的链尾添加新区块，为了解决分布式系统的一致性问题，要解决分叉冲突。本程序每个矿工维护自己的链，解决冲突的方法是手工轮训每个矿工维护的链，找到最长链，如果比自己的链长，就把自己的链替换为这个最长链。</p>
  <pre style="background:#141414;"><span style="color:#F9EE98;">def </span><span style="color:#9B703F;">resolve_conflicts</span><span style="color:#F8F8F8;">(</span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">)</span><span style="color:#CDA869;">:
&nbsp;&nbsp;&nbsp; </span><em><span style="color:#5F5A60;">""" &nbsp;&nbsp;&nbsp; </span>共识算法解决冲突
&nbsp;&nbsp;&nbsp; 使用网络中最长的链
&nbsp;&nbsp;&nbsp; :return: &lt;bool&gt; True如果链被取代，否则为False
&nbsp;&nbsp;&nbsp; """
&nbsp;&nbsp;&nbsp; </em><span style="color:#F8F8F8;">neighbours </span><span style="color:#CDA869;">= </span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.nodes
&nbsp;&nbsp;&nbsp; </span>new_chain <span style="color:#CDA869;">= </span><span style="color:#F9EE98;">None
&nbsp;&nbsp;&nbsp; </span><span style="color:#F8F8F8;">max_length </span><span style="color:#CDA869;">= </span><span style="color:#DAD085;">len</span><span style="color:#F8F8F8;">(</span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.chain)

&nbsp;&nbsp;&nbsp; </span><em><span style="color:#5F5A60;">#&nbsp; </span>抓取并验证网络中所有节点的链
&nbsp;&nbsp;&nbsp; </em><span style="color:#F9EE98;">for </span><span style="color:#F8F8F8;">node </span><span style="color:#F9EE98;">in </span><span style="color:#F8F8F8;">neighbours</span><span style="color:#CDA869;">:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#F8F8F8;">response </span><span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">requests.</span><span style="color:#9B703F;">get</span><span style="color:#F8F8F8;">(</span><span style="color:#8F9D6A;">f'http://{node}/chain'</span><span style="color:#F8F8F8;">)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#DAD085;">print</span><span style="color:#F8F8F8;">(node)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#F9EE98;">if </span><span style="color:#F8F8F8;">response.status_code </span><span style="color:#CDA869;">== </span><span style="color:#CF6A4C;">200</span><span style="color:#CDA869;">:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#F8F8F8;">length </span><span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">response.</span><span style="color:#9B703F;">json</span><span style="color:#F8F8F8;">()[</span><span style="color:#8F9D6A;">'length'</span><span style="color:#F8F8F8;">]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>chain <span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">response.</span><span style="color:#9B703F;">json</span><span style="color:#F8F8F8;">()[</span><span style="color:#8F9D6A;">'chain'</span><span style="color:#F8F8F8;">]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#DAD085;">print</span><span style="color:#F8F8F8;">(length)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#DAD085;">print</span><span style="color:#F8F8F8;">(chain)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#DAD085;">print</span><span style="color:#F8F8F8;">(</span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.</span><span style="color:#9B703F;">valid_chain</span><span style="color:#F8F8F8;">(chain))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><em><span style="color:#5F5A60;">#&nbsp; </span>检查链的长度是否更长，链是否合法
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em><span style="color:#F9EE98;">if </span><span style="color:#F8F8F8;">length </span><span style="color:#CDA869;">&gt; </span><span style="color:#F8F8F8;">max_length </span><span style="color:#F9EE98;">and </span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.</span><span style="color:#9B703F;">valid_chain</span><span style="color:#F8F8F8;">(chain)</span><span style="color:#CDA869;">:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#F8F8F8;">max_length </span><span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">length
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>new_chain <span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">chain

&nbsp;&nbsp;&nbsp; </span><em><span style="color:#5F5A60;">#&nbsp; </span>如果发现了新的合法的更长的链就用它替换我的链
&nbsp;&nbsp;&nbsp; </em><span style="color:#F9EE98;">if </span><span style="color:#F8F8F8;">new_chain</span><span style="color:#CDA869;">:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#94558D;">self</span><span style="color:#F8F8F8;">.chain </span><span style="color:#CDA869;">= </span><span style="color:#F8F8F8;">new_chain
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#F9EE98;">return True

&nbsp;&nbsp;&nbsp; </span>return False</pre>
  <p><strong>&nbsp;</strong></p>
  <p><span style="font-weight:bold;">区块链运行机制</span></p>
  <p>本程序使用python flask框架实现web接口，作为一个原型演示程序实现了如下功能：</p>
  <p>1.&nbsp;&nbsp;&nbsp;当有新的矿工节点加入工作网络，它把其他节点注册进自己的节点列表并把自己注册到其他全部矿工节点</p>
  <p>2.&nbsp;&nbsp;&nbsp;各节点可以随时添加交易信息，不过本程序未实现交易信息的广播</p>
  <p>3.&nbsp;&nbsp;&nbsp;矿工挖矿生成新区块添加进自己的链</p>
  <p>4.&nbsp;&nbsp;&nbsp;轮训查找最长链替换自己的链</p>
  <p><strong>&nbsp;</strong></p>
  <p><strong>功能演示</strong></p>
  <p>在80节点注册81和82节点</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180215231707282" alt=""></p>
  <p>在81节点添加交易信息</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180215231716420" alt=""></p>
  <p>在81节点挖矿</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180215231722416" alt=""></p>
  <p>在80节点解决冲突，链条被替换为81节点的链条</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180215231727982" alt=""></p>
  <p>在82节点注册80和81节点</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180215231740211" alt=""></p>
  <p>在82节点解决冲突，链条被替换为最长链</p>
  <p><strong>&nbsp;<img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180215232014246" alt=""></strong></p>
  <p><strong>本程序可以扩充的简单功能</strong></p>
  <ol start="1" type="1">
   <li style="color:#000000;">广播交易信息</li> 
   <li style="color:#000000;">挖矿前解决分叉冲突</li> 
   <li style="color:#000000;">加长POW计算时间</li>
  </ol>
  <p>&nbsp;</p>
  <p><strong>程序代码及运行方法</strong></p>
  <p>代码放在github，建议使用docker运行</p>
  <p><a href="https://github.com/YngwieWang/blockchain" rel="nofollow">https://github.com/YngwieWang/blockchain</a></p>
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_35753140/article/details/79329414,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_35753140/article/details/79329414,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
