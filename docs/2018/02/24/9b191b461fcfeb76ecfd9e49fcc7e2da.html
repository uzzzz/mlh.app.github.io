<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>用Java创建你第一个区块链-part1-sunny_ice的专栏(区块链、产品经理) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="用Java创建你第一个区块链-part1-sunny_ice的专栏(区块链、产品经理)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比特币是区块链中最重要的一个应用，在比特币大涨之后又出现了很多币种，比如莱特币、以太币等等，更在2014年以太坊的出现，市面上出现了各种各样的币种以及ICO，在此先简单介绍一下以太坊（Ethereum）并不是一个机构，而是一款能够在区块链上实现智能合约、开源的底层系统，从数据资料中显示，以太坊从诞生到2017年5月，全球已有了200多个以太坊应用的诞生。以太坊是一个平台和一种编程语言，使开发人员能够建立和发布下一代分布式应用，包括创建各种加密货币、智能合约、还有基于区块链的“去中心化自治组织”，但是以太坊是基于go、python以及自制的一些语言，对于广泛使用java语言的开发人员以及底层框架就是Java的系统而言，很难进行扩展和实际应用，所以我会一步一步的用Java语言帮助你创建属于你的第一个区块链应用。 &nbsp; &nbsp; &nbsp; 写本系列教程的一个最终目的就是，帮助你实现区块链技术，并希望你可以应用区块链技术到特有的业务逻辑中去，因为除了已知的比特币、以太坊，区块链在非金融行业、产业链以及传统金融行业中都可以广泛的应用起来。所以在这个教程中将会实现： &nbsp; &nbsp; &nbsp;&nbsp;1、创建你第一个非常基本的区块链 &nbsp; &nbsp; &nbsp; 2、实现一个简单的工作量证明系统即挖矿 &nbsp; &nbsp; &nbsp; 3、在此基础上实现各种可能性 &nbsp; &nbsp; &nbsp; 在此我必须要首先说明，这里创建的区块链并不是功能完全的完全适合应用与生产的区块链，相反只是为了帮助你更好的理解区块链的概念。事实上现在的区块链技术也没有非常的成熟，还属于探索研究的阶段，换个想法，这也代表了我们有很大的机遇不断的去发展区块链技术，并利用区块链技术来颠覆我们现有的商业世界。 &nbsp; &nbsp; &nbsp; 第一步、创建区块链 &nbsp; &nbsp; &nbsp; 区块链就是一串或者是一系列区块的集合，类似于链表的概念，每个区块都指向于后面一个区块，然后顺序的连接在一起。那么每个区块中的内容是什么呢？在区块链中的每一个区块都存放了很多很有价值的信息，主要包括三个部分：自己的数字签名，上一个区块的数字签名，还有一切需要加密的数据（这些数据在比特币中就相当于是交易的信息，它是加密货币的本质）。每个数字签名不但证明了自己是特有的一个区块，而且指向了前一个区块的来源，让所有的区块在链条中可以串起来，而数据就是一些特定的信息，你可以按照业务逻辑来保存业务数据。 &nbsp; &nbsp; 这里的hash指的就是数字签名 。 &nbsp; &nbsp; 所以每一个区块不仅包含前一个区块的hash值，同时包含自身的一个hash值，自身的hash值是通过之前的hash值和数据date通过hash计算出来的。如果前一个区块的数据一旦被篡改了，那么前一个区块的hash值也会同样发生变化（因为数据也被计算在内），这样也就导致了所有后续的区块中的hash值。所以计算和比对hash值会让我们检查到当前的区块链是否是有效的，也就避免了数据被恶意篡改的可能性，因为篡改数据就会改变hash值并破坏整个区块链。 &nbsp; &nbsp; 就像上图中看到了一个每一个区块包含一个自身的hash（数字签名），而变量PreviousHash是由前一个区块的hash值和data数据进行hash计算获得而来的。 &nbsp; &nbsp; &nbsp;我定义的区块链格式如下，只包含了最重要的一些信息，你可以在此基础上进行扩展。 public class Block { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String hash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String previousHash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String data; //数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private long timeStamp; //时间戳 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//区块构造函数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Block(String data,String previousHash ) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this .data = data; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this .previousHash = previousHash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this .timeStamp = new Date() .getTime(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 第二步、创建数字签名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 熟悉加密算法的朋友们，Java方式可以实现的加密方式有很多，例如BASE、MD、RSA、SHA等等，我在这里选用了SHA256这种加密方式，SHA（Secure Hash Algorithm）安全散列算法，这种算法的特点是数据的少量更改会在Hash值中产生不可预知的大量更改，hash值用作表示大量数据的固定大小的唯一值，而SHA256算法的hash值大小为256位。之所以选用SHA256是因为它的大小正合适，一方面产生重复hash值的可能性很小，另一方面在区块链实际应用过程中，有可能会产生大量的区块，而使得信息量很大，那么256位的大小就比较恰当了。 &nbsp; &nbsp; &nbsp; 下面我创建了一个StringUtil方法来方便调用SHA256算法。 public class StringUtil { //应用sha256算法让一个输入转变成256位的hash值 public static String applySha256(String input){ try { MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;); byte[] hash = digest.digest(input.getBytes(&quot;UTF-8&quot;)); StringBuffer hexString = new StringBuffer(); for (int i = 0; i &lt; hash.length; i++) { String hex = Integer.toHexString(0xff &amp; hash[i]); if(hex.length() == 1) hexString.append(&#39;0&#39;); hexString.append(hex); } return hexString.toString(); } catch(Exception e) { throw new RuntimeException(e); } } } &nbsp; &nbsp; &nbsp; 或许你完全不理解上述代码的含义，但是你只要理解所有的输入调用此方法后均会生成一个独一无二的hash值（数字签名），而这个hash值在区块链中是非常重要的。 &nbsp; &nbsp; &nbsp; &nbsp;接下来让我们在Block类中应用 方法&nbsp;applySha256 方法，其主要的目的就是计算hash值，我们计算的hash值应该包括区块中所有我们不希望被恶意篡改的数据，在我们上面所列的Block类中就一定包括previousHash，data和timeStamp， &nbsp;&nbsp; public String calculateHash() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String calculatedhash = StringUtil.applySha256( previousHash + Long.toString(timeStamp) + data ); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return calculatedhash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; &nbsp;然后把这个方法加入到Block的构造函数中去。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Block(String data,String previousHash ) { this.data = data; this.previousHash = previousHash; this.timeStamp = new Date().getTime(); this.hash = calculateHash(); //确保hash值的来源 } &nbsp; &nbsp; &nbsp; &nbsp;第三步、是时候进行一下测试了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;在主方法中让我们创建一些区块，并把其hash值打印出来，来看看是否一切都在我们的掌控中。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;就在我的“10分钟理解区块链究竟是什么”中提到的，区块链中的第一个区块我们称之为创世纪区块，因为它是头区块，所以previousHash值我们设定为0。 public class NoobChain { public static void main(String[] args) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //创世纪区块 Block genesisBlock = new Block(&quot;Hi im the first block&quot;, &quot;0&quot;); System.out.println(&quot;Hash for block 1 : &quot; + genesisBlock.hash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //第二个区块，链接在创世纪区块之后 Block secondBlock = new Block(&quot;Yo im the second block&quot;,genesisBlock.hash); System.out.println(&quot;Hash for block 2 : &quot; + secondBlock.hash); &nbsp;//第三个区块，链接在第二个区块之后 Block thirdBlock = new Block(&quot;Hey im the third block&quot;,secondBlock.hash); System.out.println(&quot;Hash for block 3 : &quot; + thirdBlock.hash); } } &nbsp; &nbsp; &nbsp; &nbsp;输出结果类似于下面 &nbsp; &nbsp; &nbsp; 每一个区块都必须要有自己的数据签名即hash值，这个hash值依赖于自身的信息（data）和上一个区块的数字签名（previousHash），但这个还不是区块链，下面让我们存储区块到数组中，这里我会引入gson包，目的是可以用json方式查看整个一条区块链结构。 import java.util.ArrayList; import com.google.gson.GsonBuilder; public class NoobChain { public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;(); public static void main(String[] args) { //增加区块到数组中去 blockchain.add(new Block(&quot;Hi im the first block&quot;, &quot;0&quot;)); blockchain.add(new Block(&quot;Yo im the second block&quot;,blockchain.get(blockchain.size()-1).hash)); blockchain.add(new Block(&quot;Hey im the third block&quot;,blockchain.get(blockchain.size()-1).hash)); String blockchainJson = new GsonBuilder().setPrettyPrinting().create().toJson(blockchain); System.out.println(blockchainJson); } } &nbsp; &nbsp; &nbsp; &nbsp; 这样的输出结构就更类似于我们所期待的区块链的样子。 &nbsp; &nbsp; &nbsp; &nbsp; 第四步、检查区块链的完整性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 在主方法中增加一个isChainValid()方法，目的是循环区块链中的所有区块并且比较hash值，这个方法用来检查hash值是否是于计算出来的hash值相等，同时previousHash值是否和前一个区块的hash值相等。或许你会产生如下的疑问，我们就在一个主函数中创建区块链中的区块，所以不存在被修改的可能性，但是你要注意的是，区块链中的一个核心概念就是去中心化，每一个区块可能是在网络中的某一个节点中产生的，所以很有可能某个节点把自己节点中的数据修改了，那么根据上述的理论数据改变会导致整个区块链的破裂，也就是区块链就无效了。 public static Boolean isChainValid() { Block currentBlock; Block previousBlock; //循环遍历区块链来检查hash值 for(int i=1; i &lt; blockchain.size(); i++) { currentBlock = blockchain.get(i); previousBlock = blockchain.get(i-1); //比对hash值和计算的hash值 if(!currentBlock.hash.equals(currentBlock.calculateHash()) ){ System.out.println(&quot;Current Hashes not equal&quot;); return false; } //比对前一个区块的hash值和previousHash值 if(!previousBlock.hash.equals(currentBlock.previousHash) ) { System.out.println(&quot;Previous Hashes not equal&quot;); return false; } } return true; } &nbsp; &nbsp; &nbsp; 任何区块链中区块的一丝一毫改变都会导致这个函数返回false，也就证明了区块链无效了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在比特币网络中所有的网络节点都分享了它们各自的区块链，然而最长的有效区块链是被全网所统一承认的，如果有人恶意来篡改之前的数据，然后创建一条更长的区块链并全网发布呈现在网络中，我们该怎么办呢？这就涉及到了区块链中另外一个重要的概念工作量证明，这里就不得不提及一下hashcash，这个概念最早来自于Adam Back的一篇论文，主要应用于邮件过滤和比特币中防止双重支付。 &nbsp; &nbsp; &nbsp; hashcash其本质就是一个数学难题，希望你可以做大量的工作，也就是付出cpu的计算能力得到正确的结果才能够获取某些资源（比如往你的邮箱中发送垃圾邮件），邮件过滤正是基于这样的原理，我们设定一个规则，所有想给我发送电子邮件的人，我都要求他满足一个计算结果才会接受，要满足这个计算结果必须付出cpu的计算代价。即使一次计算只需要几秒钟，对于垃圾邮件的系统来说都是致命的，因为这些系统每天要发送数以万计的垃圾邮件，多出的cpu时间对它们来说代价是非常大的。 &nbsp; &nbsp; &nbsp; 我们在这里实现了hashcash的理论，也就是为了创建一个新的区块必须花费大量的时间和计算能力，所以攻击者想要篡改数据那么他必须比其他节点拥有更多的计算能力。 &nbsp; &nbsp; &nbsp; 第五步、挖矿 &nbsp; &nbsp; &nbsp; 这里我们要求挖矿者做工作量证明，具体的方式是在区块中尝试不同的参数值直到它的hash值是从一系列的0开始的。下面我们在Block类中增加了一个随机数nonce，在计算hash值中也把nonce计算在内。 import java.util.Date; public class Block { public String hash; public String previousHash; private String data; //数据 private long timeStamp; //时间戳 private int nonce;//增加一个随机数 //构造函数 public Block(String data,String previousHash ) { this.data = data; this.previousHash = previousHash; this.timeStamp = new Date().getTime(); this.hash = calculateHash(); } //计算hash值（把新增的随机数也计算在内） public String calculateHash() { String calculatedhash = StringUtil.applySha256( previousHash + Long.toString(timeStamp) + Integer.toString(nonce) + data ); return calculatedhash; } public void mineBlock(int difficulty) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//创建一个string值由难度的位数来决定 String target = new String(new char[difficulty]).replace(&#39;\0&#39;, &#39;0&#39;); while(!hash.substring( 0, difficulty).equals(target)) { nonce ++; hash = calculateHash(); } System.out.println(&quot;Block Mined!!! : &quot; + hash); } } mineBlock()方法中引入了一个int值称为difficulty难度，低的难度比如1和2，普通的电脑基本都可以马上计算出来，我的建议是在4-6之间进行测试，普通电脑大概会花费3秒时间，在莱特币中难度大概围绕在442592左右，而在比特币中每一次挖矿都要求大概在10分钟左右，当然根据所有网络中的计算能力，难度也会不断的进行修改。 我们在主方法中增加difficulty这个静态变量。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public static int difficulty =5； &nbsp; &nbsp; &nbsp;&nbsp;这样我们必须修改主方法中让创建每个新区块时必须触发mineBlock()方法，而isChainValid()方法用来检查每个区块的hash值是否正确，整个区块链是否是有效的。 import java.util.ArrayList; import com.google.gson.GsonBuilder; public class NoobChain { public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;(); public static int difficulty = 5; public static void main(String[] args) { //把区块增加到数组中去 blockchain.add(new Block(&quot;Hi im the first block&quot;, &quot;0&quot;)); System.out.println(&quot;Trying to Mine block 1... &quot;); blockchain.get(0).mineBlock(difficulty); blockchain.add(new Block(&quot;Yo im the second block&quot;,blockchain.get(blockchain.size()-1).hash)); System.out.println(&quot;Trying to Mine block 2... &quot;); blockchain.get(1).mineBlock(difficulty); blockchain.add(new Block(&quot;Hey im the third block&quot;,blockchain.get(blockchain.size()-1).hash)); System.out.println(&quot;Trying to Mine block 3... &quot;); blockchain.get(2).mineBlock(difficulty); System.out.println(&quot;\nBlockchain is Valid: &quot; + isChainValid()); String blockchainJson = new GsonBuilder().setPrettyPrinting().create().toJson(blockchain); System.out.println(&quot;\nThe block chain: &quot;); System.out.println(blockchainJson); } public static Boolean isChainValid() { Block currentBlock; Block previousBlock; String hashTarget = new String(new char[difficulty]).replace(&#39;\0&#39;, &#39;0&#39;); for(int i=1; i &lt; blockchain.size(); i++) { currentBlock = blockchain.get(i); previousBlock = blockchain.get(i-1); if(!currentBlock.hash.equals(currentBlock.calculateHash()) ){ System.out.println(&quot;Current Hashes not equal&quot;); return false; } if(!previousBlock.hash.equals(currentBlock.previousHash) ) { System.out.println(&quot;Previous Hashes not equal&quot;); return false; } //增加hash值是否已经计算过 if(!currentBlock.hash.substring( 0, difficulty).equals(hashTarget)) { System.out.println(&quot;This block hasn&#39;t been mined&quot;); return false; } } return true; } } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;运行此主函数可以得到以下的输出结果。 &nbsp; &nbsp; &nbsp; &nbsp;经过测试增加一个新的区块即挖矿必须花费一定时间，大概是3秒左右，你可以提高difficulty难度来看，它是如何影响数据难题所花费的时间的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 如果有人在你的区块链系统中恶意篡改数据： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1、他们的区块链是无效的。 &nbsp; &nbsp; &nbsp; &nbsp; 2、他们无法创建更长的区块链 &nbsp; &nbsp; &nbsp; &nbsp; 3、网络中诚实的区块链会在长链中更有时间的优势 &nbsp; &nbsp; &nbsp; &nbsp; 因为篡改的区块链将无法赶上长链和有效链，除非他们比你网络中所有的节点拥有更大的计算速度，可能是未来的量子计算机或者是其他什么。 &nbsp; &nbsp; &nbsp; &nbsp; 由此你的第一个区块链已经创建成功了 总结一下：你的第一个区块链实现的功能包括 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、有很多区块组成用来存储数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、有数字签名让你的区块链链接在一起 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、需要挖矿的工作量证明新的区块 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、可以用来检查数据是否是有效的同时是未经篡改的 &nbsp; &nbsp; &nbsp; &nbsp; 你可以从下面地址下载工程&nbsp;NoobChain-Tutorial-Part-1-master &nbsp; &nbsp; &nbsp; &nbsp; 在下一个部分，我会讲述交易、数字签名以及钱包等概念，请持续关注。 阅读更多" />
<meta property="og:description" content="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比特币是区块链中最重要的一个应用，在比特币大涨之后又出现了很多币种，比如莱特币、以太币等等，更在2014年以太坊的出现，市面上出现了各种各样的币种以及ICO，在此先简单介绍一下以太坊（Ethereum）并不是一个机构，而是一款能够在区块链上实现智能合约、开源的底层系统，从数据资料中显示，以太坊从诞生到2017年5月，全球已有了200多个以太坊应用的诞生。以太坊是一个平台和一种编程语言，使开发人员能够建立和发布下一代分布式应用，包括创建各种加密货币、智能合约、还有基于区块链的“去中心化自治组织”，但是以太坊是基于go、python以及自制的一些语言，对于广泛使用java语言的开发人员以及底层框架就是Java的系统而言，很难进行扩展和实际应用，所以我会一步一步的用Java语言帮助你创建属于你的第一个区块链应用。 &nbsp; &nbsp; &nbsp; 写本系列教程的一个最终目的就是，帮助你实现区块链技术，并希望你可以应用区块链技术到特有的业务逻辑中去，因为除了已知的比特币、以太坊，区块链在非金融行业、产业链以及传统金融行业中都可以广泛的应用起来。所以在这个教程中将会实现： &nbsp; &nbsp; &nbsp;&nbsp;1、创建你第一个非常基本的区块链 &nbsp; &nbsp; &nbsp; 2、实现一个简单的工作量证明系统即挖矿 &nbsp; &nbsp; &nbsp; 3、在此基础上实现各种可能性 &nbsp; &nbsp; &nbsp; 在此我必须要首先说明，这里创建的区块链并不是功能完全的完全适合应用与生产的区块链，相反只是为了帮助你更好的理解区块链的概念。事实上现在的区块链技术也没有非常的成熟，还属于探索研究的阶段，换个想法，这也代表了我们有很大的机遇不断的去发展区块链技术，并利用区块链技术来颠覆我们现有的商业世界。 &nbsp; &nbsp; &nbsp; 第一步、创建区块链 &nbsp; &nbsp; &nbsp; 区块链就是一串或者是一系列区块的集合，类似于链表的概念，每个区块都指向于后面一个区块，然后顺序的连接在一起。那么每个区块中的内容是什么呢？在区块链中的每一个区块都存放了很多很有价值的信息，主要包括三个部分：自己的数字签名，上一个区块的数字签名，还有一切需要加密的数据（这些数据在比特币中就相当于是交易的信息，它是加密货币的本质）。每个数字签名不但证明了自己是特有的一个区块，而且指向了前一个区块的来源，让所有的区块在链条中可以串起来，而数据就是一些特定的信息，你可以按照业务逻辑来保存业务数据。 &nbsp; &nbsp; 这里的hash指的就是数字签名 。 &nbsp; &nbsp; 所以每一个区块不仅包含前一个区块的hash值，同时包含自身的一个hash值，自身的hash值是通过之前的hash值和数据date通过hash计算出来的。如果前一个区块的数据一旦被篡改了，那么前一个区块的hash值也会同样发生变化（因为数据也被计算在内），这样也就导致了所有后续的区块中的hash值。所以计算和比对hash值会让我们检查到当前的区块链是否是有效的，也就避免了数据被恶意篡改的可能性，因为篡改数据就会改变hash值并破坏整个区块链。 &nbsp; &nbsp; 就像上图中看到了一个每一个区块包含一个自身的hash（数字签名），而变量PreviousHash是由前一个区块的hash值和data数据进行hash计算获得而来的。 &nbsp; &nbsp; &nbsp;我定义的区块链格式如下，只包含了最重要的一些信息，你可以在此基础上进行扩展。 public class Block { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String hash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String previousHash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String data; //数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private long timeStamp; //时间戳 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//区块构造函数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Block(String data,String previousHash ) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this .data = data; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this .previousHash = previousHash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this .timeStamp = new Date() .getTime(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 第二步、创建数字签名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 熟悉加密算法的朋友们，Java方式可以实现的加密方式有很多，例如BASE、MD、RSA、SHA等等，我在这里选用了SHA256这种加密方式，SHA（Secure Hash Algorithm）安全散列算法，这种算法的特点是数据的少量更改会在Hash值中产生不可预知的大量更改，hash值用作表示大量数据的固定大小的唯一值，而SHA256算法的hash值大小为256位。之所以选用SHA256是因为它的大小正合适，一方面产生重复hash值的可能性很小，另一方面在区块链实际应用过程中，有可能会产生大量的区块，而使得信息量很大，那么256位的大小就比较恰当了。 &nbsp; &nbsp; &nbsp; 下面我创建了一个StringUtil方法来方便调用SHA256算法。 public class StringUtil { //应用sha256算法让一个输入转变成256位的hash值 public static String applySha256(String input){ try { MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;); byte[] hash = digest.digest(input.getBytes(&quot;UTF-8&quot;)); StringBuffer hexString = new StringBuffer(); for (int i = 0; i &lt; hash.length; i++) { String hex = Integer.toHexString(0xff &amp; hash[i]); if(hex.length() == 1) hexString.append(&#39;0&#39;); hexString.append(hex); } return hexString.toString(); } catch(Exception e) { throw new RuntimeException(e); } } } &nbsp; &nbsp; &nbsp; 或许你完全不理解上述代码的含义，但是你只要理解所有的输入调用此方法后均会生成一个独一无二的hash值（数字签名），而这个hash值在区块链中是非常重要的。 &nbsp; &nbsp; &nbsp; &nbsp;接下来让我们在Block类中应用 方法&nbsp;applySha256 方法，其主要的目的就是计算hash值，我们计算的hash值应该包括区块中所有我们不希望被恶意篡改的数据，在我们上面所列的Block类中就一定包括previousHash，data和timeStamp， &nbsp;&nbsp; public String calculateHash() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String calculatedhash = StringUtil.applySha256( previousHash + Long.toString(timeStamp) + data ); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return calculatedhash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; &nbsp;然后把这个方法加入到Block的构造函数中去。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Block(String data,String previousHash ) { this.data = data; this.previousHash = previousHash; this.timeStamp = new Date().getTime(); this.hash = calculateHash(); //确保hash值的来源 } &nbsp; &nbsp; &nbsp; &nbsp;第三步、是时候进行一下测试了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;在主方法中让我们创建一些区块，并把其hash值打印出来，来看看是否一切都在我们的掌控中。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;就在我的“10分钟理解区块链究竟是什么”中提到的，区块链中的第一个区块我们称之为创世纪区块，因为它是头区块，所以previousHash值我们设定为0。 public class NoobChain { public static void main(String[] args) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //创世纪区块 Block genesisBlock = new Block(&quot;Hi im the first block&quot;, &quot;0&quot;); System.out.println(&quot;Hash for block 1 : &quot; + genesisBlock.hash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //第二个区块，链接在创世纪区块之后 Block secondBlock = new Block(&quot;Yo im the second block&quot;,genesisBlock.hash); System.out.println(&quot;Hash for block 2 : &quot; + secondBlock.hash); &nbsp;//第三个区块，链接在第二个区块之后 Block thirdBlock = new Block(&quot;Hey im the third block&quot;,secondBlock.hash); System.out.println(&quot;Hash for block 3 : &quot; + thirdBlock.hash); } } &nbsp; &nbsp; &nbsp; &nbsp;输出结果类似于下面 &nbsp; &nbsp; &nbsp; 每一个区块都必须要有自己的数据签名即hash值，这个hash值依赖于自身的信息（data）和上一个区块的数字签名（previousHash），但这个还不是区块链，下面让我们存储区块到数组中，这里我会引入gson包，目的是可以用json方式查看整个一条区块链结构。 import java.util.ArrayList; import com.google.gson.GsonBuilder; public class NoobChain { public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;(); public static void main(String[] args) { //增加区块到数组中去 blockchain.add(new Block(&quot;Hi im the first block&quot;, &quot;0&quot;)); blockchain.add(new Block(&quot;Yo im the second block&quot;,blockchain.get(blockchain.size()-1).hash)); blockchain.add(new Block(&quot;Hey im the third block&quot;,blockchain.get(blockchain.size()-1).hash)); String blockchainJson = new GsonBuilder().setPrettyPrinting().create().toJson(blockchain); System.out.println(blockchainJson); } } &nbsp; &nbsp; &nbsp; &nbsp; 这样的输出结构就更类似于我们所期待的区块链的样子。 &nbsp; &nbsp; &nbsp; &nbsp; 第四步、检查区块链的完整性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 在主方法中增加一个isChainValid()方法，目的是循环区块链中的所有区块并且比较hash值，这个方法用来检查hash值是否是于计算出来的hash值相等，同时previousHash值是否和前一个区块的hash值相等。或许你会产生如下的疑问，我们就在一个主函数中创建区块链中的区块，所以不存在被修改的可能性，但是你要注意的是，区块链中的一个核心概念就是去中心化，每一个区块可能是在网络中的某一个节点中产生的，所以很有可能某个节点把自己节点中的数据修改了，那么根据上述的理论数据改变会导致整个区块链的破裂，也就是区块链就无效了。 public static Boolean isChainValid() { Block currentBlock; Block previousBlock; //循环遍历区块链来检查hash值 for(int i=1; i &lt; blockchain.size(); i++) { currentBlock = blockchain.get(i); previousBlock = blockchain.get(i-1); //比对hash值和计算的hash值 if(!currentBlock.hash.equals(currentBlock.calculateHash()) ){ System.out.println(&quot;Current Hashes not equal&quot;); return false; } //比对前一个区块的hash值和previousHash值 if(!previousBlock.hash.equals(currentBlock.previousHash) ) { System.out.println(&quot;Previous Hashes not equal&quot;); return false; } } return true; } &nbsp; &nbsp; &nbsp; 任何区块链中区块的一丝一毫改变都会导致这个函数返回false，也就证明了区块链无效了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在比特币网络中所有的网络节点都分享了它们各自的区块链，然而最长的有效区块链是被全网所统一承认的，如果有人恶意来篡改之前的数据，然后创建一条更长的区块链并全网发布呈现在网络中，我们该怎么办呢？这就涉及到了区块链中另外一个重要的概念工作量证明，这里就不得不提及一下hashcash，这个概念最早来自于Adam Back的一篇论文，主要应用于邮件过滤和比特币中防止双重支付。 &nbsp; &nbsp; &nbsp; hashcash其本质就是一个数学难题，希望你可以做大量的工作，也就是付出cpu的计算能力得到正确的结果才能够获取某些资源（比如往你的邮箱中发送垃圾邮件），邮件过滤正是基于这样的原理，我们设定一个规则，所有想给我发送电子邮件的人，我都要求他满足一个计算结果才会接受，要满足这个计算结果必须付出cpu的计算代价。即使一次计算只需要几秒钟，对于垃圾邮件的系统来说都是致命的，因为这些系统每天要发送数以万计的垃圾邮件，多出的cpu时间对它们来说代价是非常大的。 &nbsp; &nbsp; &nbsp; 我们在这里实现了hashcash的理论，也就是为了创建一个新的区块必须花费大量的时间和计算能力，所以攻击者想要篡改数据那么他必须比其他节点拥有更多的计算能力。 &nbsp; &nbsp; &nbsp; 第五步、挖矿 &nbsp; &nbsp; &nbsp; 这里我们要求挖矿者做工作量证明，具体的方式是在区块中尝试不同的参数值直到它的hash值是从一系列的0开始的。下面我们在Block类中增加了一个随机数nonce，在计算hash值中也把nonce计算在内。 import java.util.Date; public class Block { public String hash; public String previousHash; private String data; //数据 private long timeStamp; //时间戳 private int nonce;//增加一个随机数 //构造函数 public Block(String data,String previousHash ) { this.data = data; this.previousHash = previousHash; this.timeStamp = new Date().getTime(); this.hash = calculateHash(); } //计算hash值（把新增的随机数也计算在内） public String calculateHash() { String calculatedhash = StringUtil.applySha256( previousHash + Long.toString(timeStamp) + Integer.toString(nonce) + data ); return calculatedhash; } public void mineBlock(int difficulty) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//创建一个string值由难度的位数来决定 String target = new String(new char[difficulty]).replace(&#39;\0&#39;, &#39;0&#39;); while(!hash.substring( 0, difficulty).equals(target)) { nonce ++; hash = calculateHash(); } System.out.println(&quot;Block Mined!!! : &quot; + hash); } } mineBlock()方法中引入了一个int值称为difficulty难度，低的难度比如1和2，普通的电脑基本都可以马上计算出来，我的建议是在4-6之间进行测试，普通电脑大概会花费3秒时间，在莱特币中难度大概围绕在442592左右，而在比特币中每一次挖矿都要求大概在10分钟左右，当然根据所有网络中的计算能力，难度也会不断的进行修改。 我们在主方法中增加difficulty这个静态变量。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public static int difficulty =5； &nbsp; &nbsp; &nbsp;&nbsp;这样我们必须修改主方法中让创建每个新区块时必须触发mineBlock()方法，而isChainValid()方法用来检查每个区块的hash值是否正确，整个区块链是否是有效的。 import java.util.ArrayList; import com.google.gson.GsonBuilder; public class NoobChain { public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;(); public static int difficulty = 5; public static void main(String[] args) { //把区块增加到数组中去 blockchain.add(new Block(&quot;Hi im the first block&quot;, &quot;0&quot;)); System.out.println(&quot;Trying to Mine block 1... &quot;); blockchain.get(0).mineBlock(difficulty); blockchain.add(new Block(&quot;Yo im the second block&quot;,blockchain.get(blockchain.size()-1).hash)); System.out.println(&quot;Trying to Mine block 2... &quot;); blockchain.get(1).mineBlock(difficulty); blockchain.add(new Block(&quot;Hey im the third block&quot;,blockchain.get(blockchain.size()-1).hash)); System.out.println(&quot;Trying to Mine block 3... &quot;); blockchain.get(2).mineBlock(difficulty); System.out.println(&quot;\nBlockchain is Valid: &quot; + isChainValid()); String blockchainJson = new GsonBuilder().setPrettyPrinting().create().toJson(blockchain); System.out.println(&quot;\nThe block chain: &quot;); System.out.println(blockchainJson); } public static Boolean isChainValid() { Block currentBlock; Block previousBlock; String hashTarget = new String(new char[difficulty]).replace(&#39;\0&#39;, &#39;0&#39;); for(int i=1; i &lt; blockchain.size(); i++) { currentBlock = blockchain.get(i); previousBlock = blockchain.get(i-1); if(!currentBlock.hash.equals(currentBlock.calculateHash()) ){ System.out.println(&quot;Current Hashes not equal&quot;); return false; } if(!previousBlock.hash.equals(currentBlock.previousHash) ) { System.out.println(&quot;Previous Hashes not equal&quot;); return false; } //增加hash值是否已经计算过 if(!currentBlock.hash.substring( 0, difficulty).equals(hashTarget)) { System.out.println(&quot;This block hasn&#39;t been mined&quot;); return false; } } return true; } } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;运行此主函数可以得到以下的输出结果。 &nbsp; &nbsp; &nbsp; &nbsp;经过测试增加一个新的区块即挖矿必须花费一定时间，大概是3秒左右，你可以提高difficulty难度来看，它是如何影响数据难题所花费的时间的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 如果有人在你的区块链系统中恶意篡改数据： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1、他们的区块链是无效的。 &nbsp; &nbsp; &nbsp; &nbsp; 2、他们无法创建更长的区块链 &nbsp; &nbsp; &nbsp; &nbsp; 3、网络中诚实的区块链会在长链中更有时间的优势 &nbsp; &nbsp; &nbsp; &nbsp; 因为篡改的区块链将无法赶上长链和有效链，除非他们比你网络中所有的节点拥有更大的计算速度，可能是未来的量子计算机或者是其他什么。 &nbsp; &nbsp; &nbsp; &nbsp; 由此你的第一个区块链已经创建成功了 总结一下：你的第一个区块链实现的功能包括 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、有很多区块组成用来存储数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、有数字签名让你的区块链链接在一起 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、需要挖矿的工作量证明新的区块 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、可以用来检查数据是否是有效的同时是未经篡改的 &nbsp; &nbsp; &nbsp; &nbsp; 你可以从下面地址下载工程&nbsp;NoobChain-Tutorial-Part-1-master &nbsp; &nbsp; &nbsp; &nbsp; 在下一个部分，我会讲述交易、数字签名以及钱包等概念，请持续关注。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比特币是区块链中最重要的一个应用，在比特币大涨之后又出现了很多币种，比如莱特币、以太币等等，更在2014年以太坊的出现，市面上出现了各种各样的币种以及ICO，在此先简单介绍一下以太坊（Ethereum）并不是一个机构，而是一款能够在区块链上实现智能合约、开源的底层系统，从数据资料中显示，以太坊从诞生到2017年5月，全球已有了200多个以太坊应用的诞生。以太坊是一个平台和一种编程语言，使开发人员能够建立和发布下一代分布式应用，包括创建各种加密货币、智能合约、还有基于区块链的“去中心化自治组织”，但是以太坊是基于go、python以及自制的一些语言，对于广泛使用java语言的开发人员以及底层框架就是Java的系统而言，很难进行扩展和实际应用，所以我会一步一步的用Java语言帮助你创建属于你的第一个区块链应用。 &nbsp; &nbsp; &nbsp; 写本系列教程的一个最终目的就是，帮助你实现区块链技术，并希望你可以应用区块链技术到特有的业务逻辑中去，因为除了已知的比特币、以太坊，区块链在非金融行业、产业链以及传统金融行业中都可以广泛的应用起来。所以在这个教程中将会实现： &nbsp; &nbsp; &nbsp;&nbsp;1、创建你第一个非常基本的区块链 &nbsp; &nbsp; &nbsp; 2、实现一个简单的工作量证明系统即挖矿 &nbsp; &nbsp; &nbsp; 3、在此基础上实现各种可能性 &nbsp; &nbsp; &nbsp; 在此我必须要首先说明，这里创建的区块链并不是功能完全的完全适合应用与生产的区块链，相反只是为了帮助你更好的理解区块链的概念。事实上现在的区块链技术也没有非常的成熟，还属于探索研究的阶段，换个想法，这也代表了我们有很大的机遇不断的去发展区块链技术，并利用区块链技术来颠覆我们现有的商业世界。 &nbsp; &nbsp; &nbsp; 第一步、创建区块链 &nbsp; &nbsp; &nbsp; 区块链就是一串或者是一系列区块的集合，类似于链表的概念，每个区块都指向于后面一个区块，然后顺序的连接在一起。那么每个区块中的内容是什么呢？在区块链中的每一个区块都存放了很多很有价值的信息，主要包括三个部分：自己的数字签名，上一个区块的数字签名，还有一切需要加密的数据（这些数据在比特币中就相当于是交易的信息，它是加密货币的本质）。每个数字签名不但证明了自己是特有的一个区块，而且指向了前一个区块的来源，让所有的区块在链条中可以串起来，而数据就是一些特定的信息，你可以按照业务逻辑来保存业务数据。 &nbsp; &nbsp; 这里的hash指的就是数字签名 。 &nbsp; &nbsp; 所以每一个区块不仅包含前一个区块的hash值，同时包含自身的一个hash值，自身的hash值是通过之前的hash值和数据date通过hash计算出来的。如果前一个区块的数据一旦被篡改了，那么前一个区块的hash值也会同样发生变化（因为数据也被计算在内），这样也就导致了所有后续的区块中的hash值。所以计算和比对hash值会让我们检查到当前的区块链是否是有效的，也就避免了数据被恶意篡改的可能性，因为篡改数据就会改变hash值并破坏整个区块链。 &nbsp; &nbsp; 就像上图中看到了一个每一个区块包含一个自身的hash（数字签名），而变量PreviousHash是由前一个区块的hash值和data数据进行hash计算获得而来的。 &nbsp; &nbsp; &nbsp;我定义的区块链格式如下，只包含了最重要的一些信息，你可以在此基础上进行扩展。 public class Block { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String hash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String previousHash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String data; //数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private long timeStamp; //时间戳 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//区块构造函数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Block(String data,String previousHash ) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this .data = data; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this .previousHash = previousHash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this .timeStamp = new Date() .getTime(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 第二步、创建数字签名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 熟悉加密算法的朋友们，Java方式可以实现的加密方式有很多，例如BASE、MD、RSA、SHA等等，我在这里选用了SHA256这种加密方式，SHA（Secure Hash Algorithm）安全散列算法，这种算法的特点是数据的少量更改会在Hash值中产生不可预知的大量更改，hash值用作表示大量数据的固定大小的唯一值，而SHA256算法的hash值大小为256位。之所以选用SHA256是因为它的大小正合适，一方面产生重复hash值的可能性很小，另一方面在区块链实际应用过程中，有可能会产生大量的区块，而使得信息量很大，那么256位的大小就比较恰当了。 &nbsp; &nbsp; &nbsp; 下面我创建了一个StringUtil方法来方便调用SHA256算法。 public class StringUtil { //应用sha256算法让一个输入转变成256位的hash值 public static String applySha256(String input){ try { MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;); byte[] hash = digest.digest(input.getBytes(&quot;UTF-8&quot;)); StringBuffer hexString = new StringBuffer(); for (int i = 0; i &lt; hash.length; i++) { String hex = Integer.toHexString(0xff &amp; hash[i]); if(hex.length() == 1) hexString.append(&#39;0&#39;); hexString.append(hex); } return hexString.toString(); } catch(Exception e) { throw new RuntimeException(e); } } } &nbsp; &nbsp; &nbsp; 或许你完全不理解上述代码的含义，但是你只要理解所有的输入调用此方法后均会生成一个独一无二的hash值（数字签名），而这个hash值在区块链中是非常重要的。 &nbsp; &nbsp; &nbsp; &nbsp;接下来让我们在Block类中应用 方法&nbsp;applySha256 方法，其主要的目的就是计算hash值，我们计算的hash值应该包括区块中所有我们不希望被恶意篡改的数据，在我们上面所列的Block类中就一定包括previousHash，data和timeStamp， &nbsp;&nbsp; public String calculateHash() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String calculatedhash = StringUtil.applySha256( previousHash + Long.toString(timeStamp) + data ); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return calculatedhash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; &nbsp;然后把这个方法加入到Block的构造函数中去。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Block(String data,String previousHash ) { this.data = data; this.previousHash = previousHash; this.timeStamp = new Date().getTime(); this.hash = calculateHash(); //确保hash值的来源 } &nbsp; &nbsp; &nbsp; &nbsp;第三步、是时候进行一下测试了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;在主方法中让我们创建一些区块，并把其hash值打印出来，来看看是否一切都在我们的掌控中。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;就在我的“10分钟理解区块链究竟是什么”中提到的，区块链中的第一个区块我们称之为创世纪区块，因为它是头区块，所以previousHash值我们设定为0。 public class NoobChain { public static void main(String[] args) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //创世纪区块 Block genesisBlock = new Block(&quot;Hi im the first block&quot;, &quot;0&quot;); System.out.println(&quot;Hash for block 1 : &quot; + genesisBlock.hash); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //第二个区块，链接在创世纪区块之后 Block secondBlock = new Block(&quot;Yo im the second block&quot;,genesisBlock.hash); System.out.println(&quot;Hash for block 2 : &quot; + secondBlock.hash); &nbsp;//第三个区块，链接在第二个区块之后 Block thirdBlock = new Block(&quot;Hey im the third block&quot;,secondBlock.hash); System.out.println(&quot;Hash for block 3 : &quot; + thirdBlock.hash); } } &nbsp; &nbsp; &nbsp; &nbsp;输出结果类似于下面 &nbsp; &nbsp; &nbsp; 每一个区块都必须要有自己的数据签名即hash值，这个hash值依赖于自身的信息（data）和上一个区块的数字签名（previousHash），但这个还不是区块链，下面让我们存储区块到数组中，这里我会引入gson包，目的是可以用json方式查看整个一条区块链结构。 import java.util.ArrayList; import com.google.gson.GsonBuilder; public class NoobChain { public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;(); public static void main(String[] args) { //增加区块到数组中去 blockchain.add(new Block(&quot;Hi im the first block&quot;, &quot;0&quot;)); blockchain.add(new Block(&quot;Yo im the second block&quot;,blockchain.get(blockchain.size()-1).hash)); blockchain.add(new Block(&quot;Hey im the third block&quot;,blockchain.get(blockchain.size()-1).hash)); String blockchainJson = new GsonBuilder().setPrettyPrinting().create().toJson(blockchain); System.out.println(blockchainJson); } } &nbsp; &nbsp; &nbsp; &nbsp; 这样的输出结构就更类似于我们所期待的区块链的样子。 &nbsp; &nbsp; &nbsp; &nbsp; 第四步、检查区块链的完整性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 在主方法中增加一个isChainValid()方法，目的是循环区块链中的所有区块并且比较hash值，这个方法用来检查hash值是否是于计算出来的hash值相等，同时previousHash值是否和前一个区块的hash值相等。或许你会产生如下的疑问，我们就在一个主函数中创建区块链中的区块，所以不存在被修改的可能性，但是你要注意的是，区块链中的一个核心概念就是去中心化，每一个区块可能是在网络中的某一个节点中产生的，所以很有可能某个节点把自己节点中的数据修改了，那么根据上述的理论数据改变会导致整个区块链的破裂，也就是区块链就无效了。 public static Boolean isChainValid() { Block currentBlock; Block previousBlock; //循环遍历区块链来检查hash值 for(int i=1; i &lt; blockchain.size(); i++) { currentBlock = blockchain.get(i); previousBlock = blockchain.get(i-1); //比对hash值和计算的hash值 if(!currentBlock.hash.equals(currentBlock.calculateHash()) ){ System.out.println(&quot;Current Hashes not equal&quot;); return false; } //比对前一个区块的hash值和previousHash值 if(!previousBlock.hash.equals(currentBlock.previousHash) ) { System.out.println(&quot;Previous Hashes not equal&quot;); return false; } } return true; } &nbsp; &nbsp; &nbsp; 任何区块链中区块的一丝一毫改变都会导致这个函数返回false，也就证明了区块链无效了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在比特币网络中所有的网络节点都分享了它们各自的区块链，然而最长的有效区块链是被全网所统一承认的，如果有人恶意来篡改之前的数据，然后创建一条更长的区块链并全网发布呈现在网络中，我们该怎么办呢？这就涉及到了区块链中另外一个重要的概念工作量证明，这里就不得不提及一下hashcash，这个概念最早来自于Adam Back的一篇论文，主要应用于邮件过滤和比特币中防止双重支付。 &nbsp; &nbsp; &nbsp; hashcash其本质就是一个数学难题，希望你可以做大量的工作，也就是付出cpu的计算能力得到正确的结果才能够获取某些资源（比如往你的邮箱中发送垃圾邮件），邮件过滤正是基于这样的原理，我们设定一个规则，所有想给我发送电子邮件的人，我都要求他满足一个计算结果才会接受，要满足这个计算结果必须付出cpu的计算代价。即使一次计算只需要几秒钟，对于垃圾邮件的系统来说都是致命的，因为这些系统每天要发送数以万计的垃圾邮件，多出的cpu时间对它们来说代价是非常大的。 &nbsp; &nbsp; &nbsp; 我们在这里实现了hashcash的理论，也就是为了创建一个新的区块必须花费大量的时间和计算能力，所以攻击者想要篡改数据那么他必须比其他节点拥有更多的计算能力。 &nbsp; &nbsp; &nbsp; 第五步、挖矿 &nbsp; &nbsp; &nbsp; 这里我们要求挖矿者做工作量证明，具体的方式是在区块中尝试不同的参数值直到它的hash值是从一系列的0开始的。下面我们在Block类中增加了一个随机数nonce，在计算hash值中也把nonce计算在内。 import java.util.Date; public class Block { public String hash; public String previousHash; private String data; //数据 private long timeStamp; //时间戳 private int nonce;//增加一个随机数 //构造函数 public Block(String data,String previousHash ) { this.data = data; this.previousHash = previousHash; this.timeStamp = new Date().getTime(); this.hash = calculateHash(); } //计算hash值（把新增的随机数也计算在内） public String calculateHash() { String calculatedhash = StringUtil.applySha256( previousHash + Long.toString(timeStamp) + Integer.toString(nonce) + data ); return calculatedhash; } public void mineBlock(int difficulty) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//创建一个string值由难度的位数来决定 String target = new String(new char[difficulty]).replace(&#39;\\0&#39;, &#39;0&#39;); while(!hash.substring( 0, difficulty).equals(target)) { nonce ++; hash = calculateHash(); } System.out.println(&quot;Block Mined!!! : &quot; + hash); } } mineBlock()方法中引入了一个int值称为difficulty难度，低的难度比如1和2，普通的电脑基本都可以马上计算出来，我的建议是在4-6之间进行测试，普通电脑大概会花费3秒时间，在莱特币中难度大概围绕在442592左右，而在比特币中每一次挖矿都要求大概在10分钟左右，当然根据所有网络中的计算能力，难度也会不断的进行修改。 我们在主方法中增加difficulty这个静态变量。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public static int difficulty =5； &nbsp; &nbsp; &nbsp;&nbsp;这样我们必须修改主方法中让创建每个新区块时必须触发mineBlock()方法，而isChainValid()方法用来检查每个区块的hash值是否正确，整个区块链是否是有效的。 import java.util.ArrayList; import com.google.gson.GsonBuilder; public class NoobChain { public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;(); public static int difficulty = 5; public static void main(String[] args) { //把区块增加到数组中去 blockchain.add(new Block(&quot;Hi im the first block&quot;, &quot;0&quot;)); System.out.println(&quot;Trying to Mine block 1... &quot;); blockchain.get(0).mineBlock(difficulty); blockchain.add(new Block(&quot;Yo im the second block&quot;,blockchain.get(blockchain.size()-1).hash)); System.out.println(&quot;Trying to Mine block 2... &quot;); blockchain.get(1).mineBlock(difficulty); blockchain.add(new Block(&quot;Hey im the third block&quot;,blockchain.get(blockchain.size()-1).hash)); System.out.println(&quot;Trying to Mine block 3... &quot;); blockchain.get(2).mineBlock(difficulty); System.out.println(&quot;\\nBlockchain is Valid: &quot; + isChainValid()); String blockchainJson = new GsonBuilder().setPrettyPrinting().create().toJson(blockchain); System.out.println(&quot;\\nThe block chain: &quot;); System.out.println(blockchainJson); } public static Boolean isChainValid() { Block currentBlock; Block previousBlock; String hashTarget = new String(new char[difficulty]).replace(&#39;\\0&#39;, &#39;0&#39;); for(int i=1; i &lt; blockchain.size(); i++) { currentBlock = blockchain.get(i); previousBlock = blockchain.get(i-1); if(!currentBlock.hash.equals(currentBlock.calculateHash()) ){ System.out.println(&quot;Current Hashes not equal&quot;); return false; } if(!previousBlock.hash.equals(currentBlock.previousHash) ) { System.out.println(&quot;Previous Hashes not equal&quot;); return false; } //增加hash值是否已经计算过 if(!currentBlock.hash.substring( 0, difficulty).equals(hashTarget)) { System.out.println(&quot;This block hasn&#39;t been mined&quot;); return false; } } return true; } } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;运行此主函数可以得到以下的输出结果。 &nbsp; &nbsp; &nbsp; &nbsp;经过测试增加一个新的区块即挖矿必须花费一定时间，大概是3秒左右，你可以提高difficulty难度来看，它是如何影响数据难题所花费的时间的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 如果有人在你的区块链系统中恶意篡改数据： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1、他们的区块链是无效的。 &nbsp; &nbsp; &nbsp; &nbsp; 2、他们无法创建更长的区块链 &nbsp; &nbsp; &nbsp; &nbsp; 3、网络中诚实的区块链会在长链中更有时间的优势 &nbsp; &nbsp; &nbsp; &nbsp; 因为篡改的区块链将无法赶上长链和有效链，除非他们比你网络中所有的节点拥有更大的计算速度，可能是未来的量子计算机或者是其他什么。 &nbsp; &nbsp; &nbsp; &nbsp; 由此你的第一个区块链已经创建成功了 总结一下：你的第一个区块链实现的功能包括 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、有很多区块组成用来存储数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、有数字签名让你的区块链链接在一起 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、需要挖矿的工作量证明新的区块 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、可以用来检查数据是否是有效的同时是未经篡改的 &nbsp; &nbsp; &nbsp; &nbsp; 你可以从下面地址下载工程&nbsp;NoobChain-Tutorial-Part-1-master &nbsp; &nbsp; &nbsp; &nbsp; 在下一个部分，我会讲述交易、数字签名以及钱包等概念，请持续关注。 阅读更多","@type":"BlogPosting","url":"/2018/02/24/9b191b461fcfeb76ecfd9e49fcc7e2da.html","headline":"用Java创建你第一个区块链-part1-sunny_ice的专栏(区块链、产品经理)","dateModified":"2018-02-24T00:00:00+08:00","datePublished":"2018-02-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/02/24/9b191b461fcfeb76ecfd9e49fcc7e2da.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>用Java创建你第一个区块链-part1-sunny_ice的专栏(区块链、产品经理)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-7f5a1a725b.css"> 
 <div class="htmledit_views"> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比特币是区块链中最重要的一个应用，在比特币大涨之后又出现了很多币种，比如莱特币、以太币等等，更在2014年以太坊的出现，市面上出现了各种各样的币种以及ICO，在此先简单介绍一下以太坊（Ethereum）并不是一个机构，而是一款能够在区块链上实现智能合约、开源的底层系统，从数据资料中显示，以太坊从诞生到2017年5月，全球已有了200多个以太坊应用的诞生。以太坊是一个平台和一种编程语言，使开发人员能够建立和发布下一代分布式应用，包括创建各种加密货币、智能合约、还有基于区块链的“去中心化自治组织”，但是以太坊是基于go、python以及自制的一些语言，对于广泛使用java语言的开发人员以及底层框架就是Java的系统而言，很难进行扩展和实际应用，所以我会一步一步的用Java语言帮助你创建属于你的第一个区块链应用。</p>
  <p>&nbsp; &nbsp; &nbsp; 写本系列教程的一个最终目的就是，帮助你实现区块链技术，并希望你可以应用区块链技术到特有的业务逻辑中去，因为除了已知的比特币、以太坊，区块链在非金融行业、产业链以及传统金融行业中都可以广泛的应用起来。所以在这个教程中将会实现：<br></p>
  <p>&nbsp; &nbsp; &nbsp;&nbsp;1、创建你第一个非常基本的区块链</p>
  <p>&nbsp; &nbsp; &nbsp; 2、实现一个简单的工作量证明系统即挖矿</p>
  <p>&nbsp; &nbsp; &nbsp; 3、在此基础上实现各种可能性</p>
  <p>&nbsp; &nbsp; &nbsp; 在此我必须要首先说明，这里创建的区块链并不是功能完全的完全适合应用与生产的区块链，相反只是为了帮助你更好的理解区块链的概念。事实上现在的区块链技术也没有非常的成熟，还属于探索研究的阶段，换个想法，这也代表了我们有很大的机遇不断的去发展区块链技术，并利用区块链技术来颠覆我们现有的商业世界。</p>
  <p>&nbsp; &nbsp; &nbsp; 第一步、创建区块链<br></p>
  <p>&nbsp; &nbsp; &nbsp; 区块链就是一串或者是一系列区块的集合，类似于链表的概念，每个区块都指向于后面一个区块，然后顺序的连接在一起。那么每个区块中的内容是什么呢？在区块链中的每一个区块都存放了很多很有价值的信息，主要包括三个部分：自己的数字签名，上一个区块的数字签名，还有一切需要加密的数据（这些数据在比特币中就相当于是交易的信息，它是加密货币的本质）。每个数字签名不但证明了自己是特有的一个区块，而且指向了前一个区块的来源，让所有的区块在链条中可以串起来，而数据就是一些特定的信息，你可以按照业务逻辑来保存业务数据。</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180224104228630" alt=""></p>
  <p>&nbsp; &nbsp; 这里的hash指的就是数字签名 。</p>
  <p>&nbsp; &nbsp; 所以每一个区块不仅包含前一个区块的hash值，同时包含自身的一个hash值，自身的hash值是通过之前的hash值和数据date通过hash计算出来的。如果前一个区块的数据一旦被篡改了，那么前一个区块的hash值也会同样发生变化（因为数据也被计算在内），这样也就导致了所有后续的区块中的hash值。所以计算和比对hash值会让我们检查到当前的区块链是否是有效的，也就避免了数据被恶意篡改的可能性，因为篡改数据就会改变hash值并破坏整个区块链。</p>
  <p>&nbsp; &nbsp; 就像上图中看到了一个每一个区块包含一个自身的hash（数字签名），而变量PreviousHash是由前一个区块的hash值和data数据进行hash计算获得而来的。<br></p>
  <p>&nbsp; &nbsp; &nbsp;我定义的区块链格式如下，只包含了最重要的一些信息，你可以在此基础上进行扩展。</p>
  <p></p>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   <span style="color:rgb(215,58,73);"> public</span> 
   <span style="color:rgb(215,58,73);">class</span> 
   <span style="color:rgb(111,66,193);">Block</span> {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   <span style="color:rgb(215,58,73);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public</span> String hash;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   <span style="color:rgb(215,58,73);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public</span> String previousHash;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   <span style="color:rgb(215,58,73);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private</span> String data; 
   <span style="color:rgb(106,115,125);">//数据</span>
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   <span style="color:rgb(215,58,73);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private</span> 
   <span style="color:rgb(215,58,73);">long</span> timeStamp; 
   <span style="color:rgb(106,115,125);">//时间戳</span>
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   <span style="color:rgb(106,115,125);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//区块构造函数</span>
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   <span style="color:rgb(215,58,73);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public</span> 
   <span style="color:rgb(111,66,193);">Block</span>(String 
   <span style="color:rgb(227,98,9);">data</span>,String 
   <span style="color:rgb(227,98,9);">previousHash</span> ) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   <span style="color:rgb(0,92,197);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this</span>
   <span style="color:rgb(215,58,73);">.</span>data 
   <span style="color:rgb(215,58,73);">=</span> data;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   <span style="color:rgb(0,92,197);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this</span>
   <span style="color:rgb(215,58,73);">.</span>previousHash 
   <span style="color:rgb(215,58,73);">=</span> previousHash;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   <span style="color:rgb(0,92,197);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this</span>
   <span style="color:rgb(215,58,73);">.</span>timeStamp 
   <span style="color:rgb(215,58,73);">=</span> 
   <span style="color:rgb(215,58,73);">new</span> Date()
   <span style="color:rgb(215,58,73);">.</span>getTime();
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
   }
  </div>
  <br>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 第二步、创建数字签名<br></p>
  <p></p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 熟悉加密算法的朋友们，Java方式可以实现的加密方式有很多，例如BASE、MD、RSA、SHA等等，我在这里选用了SHA256这种加密方式，SHA（<span style="color:rgb(74,74,74);font-family:'Microsoft Yahei', 'Hiragino Sans GB', Helvetica, 'Helvetica Neue', '微软雅黑', Tahoma, Arial, sans-serif;background-color:rgb(255,255,255);">Secure Hash Algorithm</span>）安全散列算法，这种算法的特点是数据的少量更改会在Hash值中产生不可预知的大量更改，hash值用作表示大量数据的固定大小的唯一值，而SHA256算法的hash值大小为256位。之所以选用SHA256是因为它的大小正合适，一方面产生重复hash值的可能性很小，另一方面在区块链实际应用过程中，有可能会产生大量的区块，而使得信息量很大，那么256位的大小就比较恰当了。</p>
  <p>&nbsp; &nbsp; &nbsp; 下面我创建了一个StringUtil方法来方便调用SHA256算法。</p>
  <p></p>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   <span style="color:rgb(255,0,0);"> public class</span> StringUtil {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    //应用sha256算法让一个输入转变成256位的hash值
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;"> 
   <span style="color:rgb(255,0,0);">public static</span> String applySha256(String input){ 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    try {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    MessageDigest digest = MessageDigest.getInstance("SHA-256"); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    byte[] hash = digest.digest(input.getBytes("UTF-8")); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    StringBuffer hexString = new StringBuffer(); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    for (int i = 0; i &lt; hash.length; i++) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    String hex = Integer.toHexString(0xff &amp; hash[i]);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    if(hex.length() == 1) hexString.append('0');
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    hexString.append(hex);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    return hexString.toString();
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    catch(Exception e) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    throw new RuntimeException(e);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    } 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.75;">
    }
  </div>
  <br>
  <p>&nbsp; &nbsp; &nbsp; 或许你完全不理解上述代码的含义，但是你只要理解所有的输入调用此方法后均会生成一个独一无二的hash值（数字签名），而这个hash值在区块链中是非常重要的。</p>
  <p>&nbsp; &nbsp; &nbsp; &nbsp;接下来让我们在Block类中应用 方法&nbsp;<span style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">applySha256 </span>方法，其主要的目的就是计算hash值，我们计算的hash值应该包括区块中所有我们不希望被恶意篡改的数据，在我们上面所列的Block类中就一定包括previousHash，data和timeStamp，</p>
  <p></p>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   &nbsp;&nbsp; public String calculateHash() {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String calculatedhash = StringUtil.applySha256( 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    previousHash +
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    Long.toString(timeStamp) +
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    data 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    );
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return calculatedhash;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  </div>
  <p>&nbsp; &nbsp; &nbsp;然后把这个方法加入到Block的构造函数中去。</p>
  <p></p>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Block(String data,String previousHash ) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    this.data = data;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    this.previousHash = previousHash;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    this.timeStamp = new Date().getTime();
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    this.hash = calculateHash(); //确保hash值的来源
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <p>&nbsp; &nbsp; &nbsp; &nbsp;第三步、是时候进行一下测试了</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;在主方法中让我们创建一些区块，并把其hash值打印出来，来看看是否一切都在我们的掌控中。<br></p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;就在我的“10分钟理解区块链究竟是什么”中提到的，区块链中的第一个区块我们称之为创世纪区块，因为它是头区块，所以previousHash值我们设定为0。<br></p>
  <p></p>
  <div style="text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   <span style="font-family:Arial, Verdana, sans-serif;font-size:14px;">public class NoobChain </span>
   <span style="font-family:Arial, Verdana, sans-serif;"><span style="font-size:14px;"> {</span></span>
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   <br>
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public static void main(String[] args) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <p style="font-size:14px;line-height:22px;text-align:left;font-family:Arial, Verdana, sans-serif;background-color:rgb(255,255,255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //创世纪区块<br></p>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    Block genesisBlock = new Block("Hi im the first block", "0");
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("Hash for block 1 : " + genesisBlock.hash);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <p style="font-size:14px;line-height:22px;text-align:left;font-family:Arial, Verdana, sans-serif;background-color:rgb(255,255,255);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //第二个区块，链接在创世纪区块之后</p>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    Block secondBlock = new Block("Yo im the second block",genesisBlock.hash);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("Hash for block 2 : " + secondBlock.hash);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    &nbsp;//第三个区块，链接在第二个区块之后
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    Block thirdBlock = new Block("Hey im the third block",secondBlock.hash);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("Hash for block 3 : " + thirdBlock.hash);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   }
  </div>
  <br>
  <p>&nbsp; &nbsp; &nbsp; &nbsp;输出结果类似于下面</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180224143147687" alt=""><br></p>
  <p>&nbsp; &nbsp; &nbsp; 每一个区块都必须要有自己的数据签名即hash值，这个hash值依赖于自身的信息（data）和上一个区块的数字签名（previousHash），但这个还不是区块链，下面让我们存储区块到数组中，这里我会引入gson包，目的是可以用json方式查看整个一条区块链结构。<br></p>
  <p></p>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   import java.util.ArrayList;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   import com.google.gson.GsonBuilder;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   <br>
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   public class 
   <span style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">NoobChain</span> {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;(); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   <br>
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public static void main(String[] args) { 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    //增加区块到数组中去
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    blockchain.add(new Block("Hi im the first block", "0")); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    blockchain.add(new Block("Yo im the second block",blockchain.get(blockchain.size()-1).hash)); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    blockchain.add(new Block("Hey im the third block",blockchain.get(blockchain.size()-1).hash));
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    String blockchainJson = new GsonBuilder().setPrettyPrinting().create().toJson(blockchain); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println(blockchainJson);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   }
  </div>
  <br>
  <p style="text-align:left;"><span style="font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp;</span> 这样的输出结构就更类似于我们所期待的区块链的样子。</p>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 第四步、检查区块链的完整性。</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 在主方法中增加一个isChainValid()方法，目的是循环区块链中的所有区块并且比较hash值，这个方法用来检查hash值是否是于计算出来的hash值相等，同时previousHash值是否和前一个区块的hash值相等。或许你会产生如下的疑问，我们就在一个主函数中创建区块链中的区块，所以不存在被修改的可能性，但是你要注意的是，区块链中的一个核心概念就是去中心化，每一个区块可能是在网络中的某一个节点中产生的，所以很有可能某个节点把自己节点中的数据修改了，那么根据上述的理论数据改变会导致整个区块链的破裂，也就是区块链就无效了。<br></p>
  <p></p>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   public static Boolean isChainValid() {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    Block currentBlock; 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    Block previousBlock;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    //循环遍历区块链来检查hash值
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    for(int i=1; i &lt; blockchain.size(); i++) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    currentBlock = blockchain.get(i);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    previousBlock = blockchain.get(i-1);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    //比对hash值和计算的hash值
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    if(!currentBlock.hash.equals(currentBlock.calculateHash()) ){
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("Current Hashes not equal"); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    return false;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    //比对前一个区块的hash值和previousHash值
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    if(!previousBlock.hash.equals(currentBlock.previousHash) ) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("Previous Hashes not equal");
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    return false;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    return true;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   }
  </div>
  <p>&nbsp; &nbsp; &nbsp; 任何区块链中区块的一丝一毫改变都会导致这个函数返回false，也就证明了区块链无效了。</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在比特币网络中所有的网络节点都分享了它们各自的区块链，然而最长的有效区块链是被全网所统一承认的，如果有人恶意来篡改之前的数据，然后创建一条更长的区块链并全网发布呈现在网络中，我们该怎么办呢？这就涉及到了区块链中另外一个重要的概念工作量证明，这里就不得不提及一下hashcash，这个概念最早来自于Adam Back的一篇论文，主要应用于邮件过滤和比特币中防止双重支付。<br></p>
  <p>&nbsp; &nbsp; &nbsp; hashcash其本质就是一个数学难题，希望你可以做大量的工作，也就是付出cpu的计算能力得到正确的结果才能够获取某些资源（比如往你的邮箱中发送垃圾邮件），邮件过滤正是基于这样的原理，我们设定一个规则，所有想给我发送电子邮件的人，我都要求他满足一个计算结果才会接受，要满足这个计算结果必须付出cpu的计算代价。即使一次计算只需要几秒钟，对于垃圾邮件的系统来说都是致命的，因为这些系统每天要发送数以万计的垃圾邮件，多出的cpu时间对它们来说代价是非常大的。</p>
  <p>&nbsp; &nbsp; &nbsp; 我们在这里实现了hashcash的理论，也就是为了创建一个新的区块必须花费大量的时间和计算能力，所以攻击者想要篡改数据那么他必须比其他节点拥有更多的计算能力。<br></p>
  <p>&nbsp; &nbsp; &nbsp; 第五步、挖矿</p>
  <p>&nbsp; &nbsp; &nbsp; 这里我们要求挖矿者做工作量证明，具体的方式是在区块中尝试不同的参数值直到它的hash值是从一系列的0开始的。下面我们在Block类中增加了一个随机数nonce，在计算hash值中也把nonce计算在内。</p>
  <p><span style="text-align:left;font-size:14px;"></span></p>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   import java.util.Date;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   <br>
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   public class Block {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public String hash;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public String previousHash; 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    private String data; //数据
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    private long timeStamp; //时间戳
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    private int nonce;//增加一个随机数
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    //构造函数
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public Block(String data,String previousHash ) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    this.data = data;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    this.previousHash = previousHash;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    this.timeStamp = new Date().getTime();
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    this.hash = calculateHash(); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    //计算hash值（把新增的随机数也计算在内）
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public String calculateHash() {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    String calculatedhash = StringUtil.applySha256( 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    previousHash +
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    Long.toString(timeStamp) +
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    Integer.toString(nonce) + 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    data 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    );
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    return calculatedhash;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public void mineBlock(int difficulty) {
  </div>
  <p style="font-size:14px;line-height:22px;text-align:left;font-family:Arial, Verdana, sans-serif;background-color:rgb(255,255,255);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>//创建一个string值由难度的位数来决定</span></p>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    String target = new String(new char[difficulty]).replace('\0', '0'); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    while(!hash.substring( 0, difficulty).equals(target)) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    nonce ++;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    hash = calculateHash();
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("Block Mined!!! : " + hash);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   }
  </div>
  <br>
  <p><span style="text-align:left;"></span><span style="text-align:left;font-size:14px;"> </span><span style="text-align:left;"><span style="font-size:14px;">mineBlock()方法中引入了一个int值称为difficulty难度，低的难度比如1和2，普通的电脑基本都可以马上计算出来，我的建议是在4-6之间进行测试，普通电脑大概会花费3秒时间，在莱特币中难度大概围绕在442592左右，而在比特币中每一次挖矿都要求大概在10分钟左右，当然根据所有网络中的计算能力，难度也会不断的进行修改。</span></span></p>
  <div style="line-height:1.58;text-align:left;">
   <span style="font-size:14px;"> 我们在主方法中增加difficulty这个静态变量。</span>
  </div>
  <p><span style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public static int difficulty =5；</span></p>
  <p style="text-align:left;"><span style="font-size:14px;">&nbsp; &nbsp; &nbsp;&nbsp;</span>这样我们必须修改主方法中让创建每个新区块时必须触发mineBlock()方法，而isChainValid()方法用来检查每个区块的hash值是否正确，整个区块链是否是有效的。</p>
  <p></p>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   import java.util.ArrayList;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   import com.google.gson.GsonBuilder;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   <br>
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   public class 
   <span style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">NoobChain</span> {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;();
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public static int difficulty = 5;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   <br>
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public static void main(String[] args) { 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    //把区块增加到数组中去
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    blockchain.add(new Block("Hi im the first block", "0"));
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("Trying to Mine block 1... ");
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    blockchain.get(0).mineBlock(difficulty);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    blockchain.add(new Block("Yo im the second block",blockchain.get(blockchain.size()-1).hash));
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("Trying to Mine block 2... ");
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    blockchain.get(1).mineBlock(difficulty);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    blockchain.add(new Block("Hey im the third block",blockchain.get(blockchain.size()-1).hash));
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("Trying to Mine block 3... ");
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    blockchain.get(2).mineBlock(difficulty); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("\nBlockchain is Valid: " + isChainValid());
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    String blockchainJson = new GsonBuilder().setPrettyPrinting().create().toJson(blockchain);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("\nThe block chain: ");
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println(blockchainJson);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;"> 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    public static Boolean isChainValid() {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    Block currentBlock; 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    Block previousBlock;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    String hashTarget = new String(new char[difficulty]).replace('\0', '0');
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    for(int i=1; i &lt; blockchain.size(); i++) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    currentBlock = blockchain.get(i);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    previousBlock = blockchain.get(i-1);
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    if(!currentBlock.hash.equals(currentBlock.calculateHash()) ){
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("Current Hashes not equal"); 
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    return false;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    if(!previousBlock.hash.equals(currentBlock.previousHash) ) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("Previous Hashes not equal");
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    return false;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    //增加hash值是否已经计算过
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    if(!currentBlock.hash.substring( 0, difficulty).equals(hashTarget)) {
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    System.out.println("This block hasn't been mined");
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    return false;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    return true;
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
    }
  </div>
  <div style="font-family:Arial, Verdana, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);line-height:1.58;">
   }
  </div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;运行此主函数可以得到以下的输出结果。
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180224154416254" alt=""><br></p>
  <p>&nbsp; &nbsp; &nbsp; &nbsp;经过测试增加一个新的区块即挖矿必须花费一定时间，大概是3秒左右，你可以提高difficulty难度来看，它是如何影响数据难题所花费的时间的。</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 如果有人在你的区块链系统中恶意篡改数据：<br></p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1、他们的区块链是无效的。<br></p>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 2、他们无法创建更长的区块链</p>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 3、网络中诚实的区块链会在长链中更有时间的优势</p>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 因为篡改的区块链将无法赶上长链和有效链，除非他们比你网络中所有的节点拥有更大的计算速度，可能是未来的量子计算机或者是其他什么。</p>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 由此你的第一个区块链已经创建成功了</p>
  <p>总结一下：你的第一个区块链实现的功能包括</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、有很多区块组成用来存储数据</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、有数字签名让你的区块链链接在一起</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、需要挖矿的工作量证明新的区块</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、可以用来检查数据是否是有效的同时是未经篡改的</p>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 你可以从下面地址下载工程&nbsp;<a href="https://gitee.com/sunny_ice/NoobChain-Tutorial-Part-1-master" rel="nofollow">NoobChain-Tutorial-Part-1-master</a></p>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 在下一个部分，我会讲述交易、数字签名以及钱包等概念，请持续关注。</p>
  <p><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u010093971/article/details/79358730,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u010093971/article/details/79358730,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
