<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Win10下开发部署Dapp(4)：solidity快速入门 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Win10下开发部署Dapp(4)：solidity快速入门" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="基础篇 Solidity是一门静态类型的脚本语言，我们可以对照C++的语法进行快速记忆。 1.基本保留字与基本类型 contract：类似于class，定义一个合约，具有构造函数，仅在创建合约时被调用。 function：定义一个函数。 event：定义一个事件，外部Dapp可以监控这些事件，以获知合约内的变化。 var：声明变量，类似于C++11的auto，可以在初始化时进行自动类型推导，之后不能更改类型。 bool: 布尔类型，有true跟false两种值。 uint8、uint16、。。。uint256：无符号整型，uint是uint256的别名。 nint8、int16、。。。int256：有符号整形，int是int256的别名。 ufixedMxN：无符号定点小数，M表示整个类型占用的bit数，N表示小数位数。ufixed64x7：7位小数，剩下的是整数部分 fixedMxN：定点小数。 address：地址类型，表示账户地址或者合约地址。20Byte。 addr.balance：返回uint256类型的值，表示addr账户的余额（Wei）。 addr.send(uint256 N)：转给addr地址N Wei数量的以太币，失败是返回false。 addr.transfer(uint256 N)：包装了send方法，失败时直接抛出异常，会导致整个交易回退。 addr.call、addr.callcode、addr.delegatecall：调用addr合约的指定的方法，区别稍后详述。 2.基本操作符 逻辑操作符：！(逻辑非)、&amp;&amp;(逻辑与)、||(逻辑或)。跟C++完全一致，并且&amp;&amp;与||同样存在短路求值。 比较操作符：&lt;、&lt;=、&gt;、&gt;=、==、!=，跟C++完全一致。 算术操作符：+(正号)、-（负号）、 +、-、*、/、%(取余)、&lt;&lt;(左移)、&gt;&gt;(右移)、**(幂)。除了幂，其余的都跟C++一致。 位操作符：&amp;(与)、|(或)、~(非)、^(异或)。 3.数组、字符串、结构体、枚举类型、mapping 数组 定长数组：编译期长度就固定下来的数组是定长数组，这样定义一个定常数组：T[k]（例如 uint8[ 5 ] arr）。bytes1、bytes2, bytes3, …, bytes32，这些也是定长数组。bytes1可以简写成byte。定长数组是值类型（value-type）,可以进行比较操作、位操作、索引操作。 动态数组：编译期长度不固定，类似于C++中的vector，这样定义一个动态数组：T[] (例如 int256[] arr)。 string是特殊的动态数组。普通的定长数组、动态数组都可以进行取长度操作：arr.length，以及下标索引操作，但是string暂时不支持这两种操作。bytes也是动态数组，相当于byte[]，但是比byte[]要更、廉价一些，应该尽量使用bytes。另外，动态数组、bytes还可以调用push方法，在数组末尾添加数据，返回最新的长度。 字符串 string本质上是经过UTF8编码的byte数组。当前版本的solidity对string的实现十分不完整，无法支持串联、比较、下标索引等操作，甚至连取长度都不支持。当前的string仅可以用来做mapping的key。 结构体 跟C++很像，这样定义一个结构体： struct MyStruct{ bool flag; string name; } MyStruct a; 结构体、数组里未被初始化的元素，都是0。 枚举 mapping solidity里使用频率比较高的类型。mapping (address =&gt; uint256) balanceOf; 定义了一个map，使用地址做索引，值位uint256. 4.全局可用的单位、函数、对象 以太币单位 1 Ether = 1000 Finny 1 Finny = 1000 Szabo 1 Szabo = 1000 Gwei 1 Gwei = 1000 Mwei 1 Mwei = 1000 Kwei 1 Kwei = 1000 wei 1 Ether = 10^18 wei 时间单位 1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks == 7 days 1 years == 365 days block对象 block.blockhash(uint blockNumber) returns (bytes32)：返回指定高度的块的hash值，仅限最近256块。 block.coinbase (address)：当前块的矿工 block.difficulty (uint)：当前块的难度 block.gaslimit (uint)：当前块的gaslimit block.number (uint)：当前块高度 block.timestamp (uint): 当前块时间戳 msg对象 msg.data (bytes)：当前调用完整的原始数据 msg.gas (uint): 剩余的gas，0.4.21版本之后弃用，替换为gasleft。 msg.sender (address): 当前调用的发起者。 msg.sig (bytes4):调用数据的头四字节 msg.value (uint):当前消息携带的以太币，单位wei。 tx对象 tx.gasprice (uint):当前交易的gas price tx.origin (address): 当前交易的发起者。 数学函数、hash函数 addmod(uint x, uint y, uint k) returns (uint): mulmod(uint x, uint y, uint k) returns (uint): keccak256(…) returns (bytes32): sha256(…) returns (bytes32): sha3(…) returns (bytes32): ripemd160(…) returns (bytes20): ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address): 异常处理函数 assert(bool condition): require(bool condition): revert(): 其他 gasleft() returns (uint256) now (uint): this suicide 5.contract（合约） contract类似于class，他有： 构造函数。跟contract名称相同的function即为构造函数，在合约创建时被调用，可以有参数，无返回值。 自杀函数。selfdestruct（address）销毁合约，并把合约账户里的ether转移到指定的地址，花费比调用transfer小。suicide是selfdestruct的别名。 this。在合约内，this可以转化成address。在合约内部调用自己的external函数也需要用到this。 成员变量。 成员函数。 继承、被继承。一个合约可以继承其他合约。 6.可见性：external、public、internal、private 合约内的成员变量、成员函数需要使用可见性来修饰，不修饰默认为public（跟C++刚好相反）。 external：只能用来修饰成员函数，这样的函数只能被外部合约调用，合约内部想要调用该函数，需要使用this.func(); public：修饰变量，则编译器会自动生成一个同名的getter。修饰函数，则外部可以调用该函数。 internal：类似于protect，可被合约内部以及子类合约访问。 private：私有的，仅合约内部可以访问，子类不可访问。 7.函数及其修饰词 函数可以有多个返回值： 直接通过一个稍微复杂点的例子来看下solidity的函数是啥样子的。 uint16 uCount; //合约内的成员变量 function add(uint8 a, uint8 b) public pure returns(uint8){ return a + b; //先忽略溢出。 } function GetCount() public view returns(uint16){ return uCount; } function setCount(uint16 count) public { uCount = count; } modifier validAddress(address addr){ assert(addr != address(0)); _; } modifier validAmount(uint256 amount){ reqire(amount &gt; 0); _; } function myTransferFunc(address to, uint256 amount) public validAddress(to) validAmount(amount){ //无需再检查参数的合法性，如果不合法，会在modifier中抛出异常，进不到函数体中。 //........ //........ } function deposit(uint256 amount) public payable returns(bool, string){ //........ return (true, &quot;successfull&quot;); } function () public payable{ //....... }   从上往下依次看，add方法很简单，实现了两个数相加，但是pure是啥意思？GetCount方法的view又是啥意思？SetCount为啥没有这两个东西？pure：不改变合约状态，也不读取合约状态的函数，开发者应当主动使用pure修饰；读取合约状态但是不修改合约状态的函数，使用view修饰；SetCount改变了合约状态，不能被这两个中的任何一个修饰。（老版本的solidity没有view与pure，只有一个constant，凡是不改变状态的函数需要被constant修饰，后来细化成两部分view + pure）。   接下来的modifier，业界普遍翻译成函数修改器，我觉得应该叫 函数卫词，它就像是一个卫语句，在函数运行之前过滤参数的合法性。不合法直接抛出异常，退出函数体，整个交易都不会被执行。   再往下，一个新关键词：payable。被这个修饰的函数，才能够被转账，否则只能是普通调用。   最后，一个没有名字的函数，叫回退函数（fallback function）。当且仅当一个合约的回退函数被实现了且被payable修饰了，才能向这个合约地址直接转账。 8.事件   事件是另一个新东西，可以让外部dapp监控合约内的变化。这里先简单介绍下事件的定义以及触发，事件的监听后面补上。 event OnTrasnsfer(address from, address to, uint value); function myTransferFunc(address to, uint256 amount) public validAddress(to) validAmount(amount){ //转账 。。。 //新版本的solidity触发事件需要使用emit关键字，之前的版本不用，但是看起来像是个函数调用。 emit OnTrasnsfer(address(this), to, amount); } 扩展篇 1.继承、多态、super solidity支持继承，并且支持多重继承。 下面的代码展示了基本的继承的作用：代码重用。 contract ERC20Token{ string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); //基类里可以不给实现，只做函数声明。也可给一个实现，子类根据情况，选择直接使用用或者重新写一个实现覆盖父类的 function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value)public returns (bool success); } contract TokenA is ERC20Token { function MyToken(string _name, string _symbol, uint256 _decimals) public{ name = _name; symbol = _symbol; decimals = _decimals; } //如果父类只声明了该方法，此处为实现。若父类实现了，此处会覆盖父类的实现。 function transfer(address _to, uint256 _value) public returns (bool success){ } } contract TokenB is ERC20Token { ..... ..... } 假如ERC20Token里的方法只给了声明，那ERC20Token就是一个抽象合约，该合约不能被部署只能做父类。 接下来就是由继承+重写(override)而引出的多态： contract Base{ function Func() public pure returns(uint256){ return 11112222; } } contract Drived is Base{ function Func() public pure returns(uint256){ return 33334444; } } contract TestContract{ function TestContract() public{ } function TestPolymorphism(address subClassAddr) public pure returns(uint256, uint256){ Drived objDrived = Drived(subClassAddr); Base objBase = Base(subClassAddr); return (objDrived.Func(), objBase.Func()); } } 我们先部署Base、Drive两个合约，分别得到合约地址baseAddr、drivedAddr，再部署TestContract合约，分别把两个地址做参数调用TestPolymorphism方法，结果如下： 使用baseAddr做参数，输出为： 11112222 11112222 *使用drivedAddr做参数，输出为： 33334444 33334444 有多重继承，及不可避免地会引起棱形继承，看下面代码： contract Ancestor{ function Func(uint256 val)public pure returns(uint256){ return val; } } contract BaseA is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return Ancestor.Func(val * 2); } } contract BaseB is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return Ancestor.Func(val * 4); } } contract Final is BaseA, BaseB { } 我们部署了Final合约之后，该合约对外只有一个可以调用的方法：Func，使用一个数字N做参数，输出会是多少呢?答案是4N。如果把继承的顺序改为 contract Final is BaseB, BaseA ,则输出的结果便是2N。solidity在处理多继承的时候，有一个结构叫继承图(inheritance graph)，对于第一种情况，继承图是这样的：Final-BaseB-BaseA-Ancestor。所以调用Final.Func实际上调用的是BaseB里的Func。 接下来看看神奇的super contract BaseA is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return super.Func(val * 2); } } contract BaseB is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return super.Func(val * 4); } } contract Final is BaseA, BaseB { } 部署了Final之后调用Func方法，传入N，结果是8N。为啥？super不是简单的调用所在的合约的父合约，而是调用继承图中的下一个合约里的方法：继承图为Final-BaseB-BaseA-Ancestor，BaseB中的super.Func实际上调用的是BaseA.Func，所以最终的N被放大了4*2=8倍。 2. throw、require、assert、revert require与assert都是用来进行条件过滤的，当里面的条件表达式为false时，抛出异常回退整个交易。二者本质的区别在于： require（opcode为0xfd）会直接异常，已用掉的gas送给旷工，未使用的gas返回给交易发起者。 assert（opcode为0xfe）也是抛出异常，同时消耗掉交易发起者提供的 所有 gas。 使用者可根据以上特点酌情使用两者。比如，在需要过滤恶意调用的地方使用assert，能够增加hacker的攻击成本。 throw和revert两个同样使用的是0xfd操作码，跟require是一样的。但是在0.4.10版本之前，throw用的是0xfe。所以不推荐使用throw而推荐用revert代之，因为throw会在不同版本的编译器上体现不同的行为。 3. 合约间的访问：call、callcode、delegatecall 4. storage、memory、new、delete 5. import、library、using for 阅读更多" />
<meta property="og:description" content="基础篇 Solidity是一门静态类型的脚本语言，我们可以对照C++的语法进行快速记忆。 1.基本保留字与基本类型 contract：类似于class，定义一个合约，具有构造函数，仅在创建合约时被调用。 function：定义一个函数。 event：定义一个事件，外部Dapp可以监控这些事件，以获知合约内的变化。 var：声明变量，类似于C++11的auto，可以在初始化时进行自动类型推导，之后不能更改类型。 bool: 布尔类型，有true跟false两种值。 uint8、uint16、。。。uint256：无符号整型，uint是uint256的别名。 nint8、int16、。。。int256：有符号整形，int是int256的别名。 ufixedMxN：无符号定点小数，M表示整个类型占用的bit数，N表示小数位数。ufixed64x7：7位小数，剩下的是整数部分 fixedMxN：定点小数。 address：地址类型，表示账户地址或者合约地址。20Byte。 addr.balance：返回uint256类型的值，表示addr账户的余额（Wei）。 addr.send(uint256 N)：转给addr地址N Wei数量的以太币，失败是返回false。 addr.transfer(uint256 N)：包装了send方法，失败时直接抛出异常，会导致整个交易回退。 addr.call、addr.callcode、addr.delegatecall：调用addr合约的指定的方法，区别稍后详述。 2.基本操作符 逻辑操作符：！(逻辑非)、&amp;&amp;(逻辑与)、||(逻辑或)。跟C++完全一致，并且&amp;&amp;与||同样存在短路求值。 比较操作符：&lt;、&lt;=、&gt;、&gt;=、==、!=，跟C++完全一致。 算术操作符：+(正号)、-（负号）、 +、-、*、/、%(取余)、&lt;&lt;(左移)、&gt;&gt;(右移)、**(幂)。除了幂，其余的都跟C++一致。 位操作符：&amp;(与)、|(或)、~(非)、^(异或)。 3.数组、字符串、结构体、枚举类型、mapping 数组 定长数组：编译期长度就固定下来的数组是定长数组，这样定义一个定常数组：T[k]（例如 uint8[ 5 ] arr）。bytes1、bytes2, bytes3, …, bytes32，这些也是定长数组。bytes1可以简写成byte。定长数组是值类型（value-type）,可以进行比较操作、位操作、索引操作。 动态数组：编译期长度不固定，类似于C++中的vector，这样定义一个动态数组：T[] (例如 int256[] arr)。 string是特殊的动态数组。普通的定长数组、动态数组都可以进行取长度操作：arr.length，以及下标索引操作，但是string暂时不支持这两种操作。bytes也是动态数组，相当于byte[]，但是比byte[]要更、廉价一些，应该尽量使用bytes。另外，动态数组、bytes还可以调用push方法，在数组末尾添加数据，返回最新的长度。 字符串 string本质上是经过UTF8编码的byte数组。当前版本的solidity对string的实现十分不完整，无法支持串联、比较、下标索引等操作，甚至连取长度都不支持。当前的string仅可以用来做mapping的key。 结构体 跟C++很像，这样定义一个结构体： struct MyStruct{ bool flag; string name; } MyStruct a; 结构体、数组里未被初始化的元素，都是0。 枚举 mapping solidity里使用频率比较高的类型。mapping (address =&gt; uint256) balanceOf; 定义了一个map，使用地址做索引，值位uint256. 4.全局可用的单位、函数、对象 以太币单位 1 Ether = 1000 Finny 1 Finny = 1000 Szabo 1 Szabo = 1000 Gwei 1 Gwei = 1000 Mwei 1 Mwei = 1000 Kwei 1 Kwei = 1000 wei 1 Ether = 10^18 wei 时间单位 1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks == 7 days 1 years == 365 days block对象 block.blockhash(uint blockNumber) returns (bytes32)：返回指定高度的块的hash值，仅限最近256块。 block.coinbase (address)：当前块的矿工 block.difficulty (uint)：当前块的难度 block.gaslimit (uint)：当前块的gaslimit block.number (uint)：当前块高度 block.timestamp (uint): 当前块时间戳 msg对象 msg.data (bytes)：当前调用完整的原始数据 msg.gas (uint): 剩余的gas，0.4.21版本之后弃用，替换为gasleft。 msg.sender (address): 当前调用的发起者。 msg.sig (bytes4):调用数据的头四字节 msg.value (uint):当前消息携带的以太币，单位wei。 tx对象 tx.gasprice (uint):当前交易的gas price tx.origin (address): 当前交易的发起者。 数学函数、hash函数 addmod(uint x, uint y, uint k) returns (uint): mulmod(uint x, uint y, uint k) returns (uint): keccak256(…) returns (bytes32): sha256(…) returns (bytes32): sha3(…) returns (bytes32): ripemd160(…) returns (bytes20): ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address): 异常处理函数 assert(bool condition): require(bool condition): revert(): 其他 gasleft() returns (uint256) now (uint): this suicide 5.contract（合约） contract类似于class，他有： 构造函数。跟contract名称相同的function即为构造函数，在合约创建时被调用，可以有参数，无返回值。 自杀函数。selfdestruct（address）销毁合约，并把合约账户里的ether转移到指定的地址，花费比调用transfer小。suicide是selfdestruct的别名。 this。在合约内，this可以转化成address。在合约内部调用自己的external函数也需要用到this。 成员变量。 成员函数。 继承、被继承。一个合约可以继承其他合约。 6.可见性：external、public、internal、private 合约内的成员变量、成员函数需要使用可见性来修饰，不修饰默认为public（跟C++刚好相反）。 external：只能用来修饰成员函数，这样的函数只能被外部合约调用，合约内部想要调用该函数，需要使用this.func(); public：修饰变量，则编译器会自动生成一个同名的getter。修饰函数，则外部可以调用该函数。 internal：类似于protect，可被合约内部以及子类合约访问。 private：私有的，仅合约内部可以访问，子类不可访问。 7.函数及其修饰词 函数可以有多个返回值： 直接通过一个稍微复杂点的例子来看下solidity的函数是啥样子的。 uint16 uCount; //合约内的成员变量 function add(uint8 a, uint8 b) public pure returns(uint8){ return a + b; //先忽略溢出。 } function GetCount() public view returns(uint16){ return uCount; } function setCount(uint16 count) public { uCount = count; } modifier validAddress(address addr){ assert(addr != address(0)); _; } modifier validAmount(uint256 amount){ reqire(amount &gt; 0); _; } function myTransferFunc(address to, uint256 amount) public validAddress(to) validAmount(amount){ //无需再检查参数的合法性，如果不合法，会在modifier中抛出异常，进不到函数体中。 //........ //........ } function deposit(uint256 amount) public payable returns(bool, string){ //........ return (true, &quot;successfull&quot;); } function () public payable{ //....... }   从上往下依次看，add方法很简单，实现了两个数相加，但是pure是啥意思？GetCount方法的view又是啥意思？SetCount为啥没有这两个东西？pure：不改变合约状态，也不读取合约状态的函数，开发者应当主动使用pure修饰；读取合约状态但是不修改合约状态的函数，使用view修饰；SetCount改变了合约状态，不能被这两个中的任何一个修饰。（老版本的solidity没有view与pure，只有一个constant，凡是不改变状态的函数需要被constant修饰，后来细化成两部分view + pure）。   接下来的modifier，业界普遍翻译成函数修改器，我觉得应该叫 函数卫词，它就像是一个卫语句，在函数运行之前过滤参数的合法性。不合法直接抛出异常，退出函数体，整个交易都不会被执行。   再往下，一个新关键词：payable。被这个修饰的函数，才能够被转账，否则只能是普通调用。   最后，一个没有名字的函数，叫回退函数（fallback function）。当且仅当一个合约的回退函数被实现了且被payable修饰了，才能向这个合约地址直接转账。 8.事件   事件是另一个新东西，可以让外部dapp监控合约内的变化。这里先简单介绍下事件的定义以及触发，事件的监听后面补上。 event OnTrasnsfer(address from, address to, uint value); function myTransferFunc(address to, uint256 amount) public validAddress(to) validAmount(amount){ //转账 。。。 //新版本的solidity触发事件需要使用emit关键字，之前的版本不用，但是看起来像是个函数调用。 emit OnTrasnsfer(address(this), to, amount); } 扩展篇 1.继承、多态、super solidity支持继承，并且支持多重继承。 下面的代码展示了基本的继承的作用：代码重用。 contract ERC20Token{ string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); //基类里可以不给实现，只做函数声明。也可给一个实现，子类根据情况，选择直接使用用或者重新写一个实现覆盖父类的 function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value)public returns (bool success); } contract TokenA is ERC20Token { function MyToken(string _name, string _symbol, uint256 _decimals) public{ name = _name; symbol = _symbol; decimals = _decimals; } //如果父类只声明了该方法，此处为实现。若父类实现了，此处会覆盖父类的实现。 function transfer(address _to, uint256 _value) public returns (bool success){ } } contract TokenB is ERC20Token { ..... ..... } 假如ERC20Token里的方法只给了声明，那ERC20Token就是一个抽象合约，该合约不能被部署只能做父类。 接下来就是由继承+重写(override)而引出的多态： contract Base{ function Func() public pure returns(uint256){ return 11112222; } } contract Drived is Base{ function Func() public pure returns(uint256){ return 33334444; } } contract TestContract{ function TestContract() public{ } function TestPolymorphism(address subClassAddr) public pure returns(uint256, uint256){ Drived objDrived = Drived(subClassAddr); Base objBase = Base(subClassAddr); return (objDrived.Func(), objBase.Func()); } } 我们先部署Base、Drive两个合约，分别得到合约地址baseAddr、drivedAddr，再部署TestContract合约，分别把两个地址做参数调用TestPolymorphism方法，结果如下： 使用baseAddr做参数，输出为： 11112222 11112222 *使用drivedAddr做参数，输出为： 33334444 33334444 有多重继承，及不可避免地会引起棱形继承，看下面代码： contract Ancestor{ function Func(uint256 val)public pure returns(uint256){ return val; } } contract BaseA is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return Ancestor.Func(val * 2); } } contract BaseB is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return Ancestor.Func(val * 4); } } contract Final is BaseA, BaseB { } 我们部署了Final合约之后，该合约对外只有一个可以调用的方法：Func，使用一个数字N做参数，输出会是多少呢?答案是4N。如果把继承的顺序改为 contract Final is BaseB, BaseA ,则输出的结果便是2N。solidity在处理多继承的时候，有一个结构叫继承图(inheritance graph)，对于第一种情况，继承图是这样的：Final-BaseB-BaseA-Ancestor。所以调用Final.Func实际上调用的是BaseB里的Func。 接下来看看神奇的super contract BaseA is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return super.Func(val * 2); } } contract BaseB is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return super.Func(val * 4); } } contract Final is BaseA, BaseB { } 部署了Final之后调用Func方法，传入N，结果是8N。为啥？super不是简单的调用所在的合约的父合约，而是调用继承图中的下一个合约里的方法：继承图为Final-BaseB-BaseA-Ancestor，BaseB中的super.Func实际上调用的是BaseA.Func，所以最终的N被放大了4*2=8倍。 2. throw、require、assert、revert require与assert都是用来进行条件过滤的，当里面的条件表达式为false时，抛出异常回退整个交易。二者本质的区别在于： require（opcode为0xfd）会直接异常，已用掉的gas送给旷工，未使用的gas返回给交易发起者。 assert（opcode为0xfe）也是抛出异常，同时消耗掉交易发起者提供的 所有 gas。 使用者可根据以上特点酌情使用两者。比如，在需要过滤恶意调用的地方使用assert，能够增加hacker的攻击成本。 throw和revert两个同样使用的是0xfd操作码，跟require是一样的。但是在0.4.10版本之前，throw用的是0xfe。所以不推荐使用throw而推荐用revert代之，因为throw会在不同版本的编译器上体现不同的行为。 3. 合约间的访问：call、callcode、delegatecall 4. storage、memory、new、delete 5. import、library、using for 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/17/19b3374d571287324a88413dcbfa6881.html" />
<meta property="og:url" content="https://mlh.app/2018/03/17/19b3374d571287324a88413dcbfa6881.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-17T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"基础篇 Solidity是一门静态类型的脚本语言，我们可以对照C++的语法进行快速记忆。 1.基本保留字与基本类型 contract：类似于class，定义一个合约，具有构造函数，仅在创建合约时被调用。 function：定义一个函数。 event：定义一个事件，外部Dapp可以监控这些事件，以获知合约内的变化。 var：声明变量，类似于C++11的auto，可以在初始化时进行自动类型推导，之后不能更改类型。 bool: 布尔类型，有true跟false两种值。 uint8、uint16、。。。uint256：无符号整型，uint是uint256的别名。 nint8、int16、。。。int256：有符号整形，int是int256的别名。 ufixedMxN：无符号定点小数，M表示整个类型占用的bit数，N表示小数位数。ufixed64x7：7位小数，剩下的是整数部分 fixedMxN：定点小数。 address：地址类型，表示账户地址或者合约地址。20Byte。 addr.balance：返回uint256类型的值，表示addr账户的余额（Wei）。 addr.send(uint256 N)：转给addr地址N Wei数量的以太币，失败是返回false。 addr.transfer(uint256 N)：包装了send方法，失败时直接抛出异常，会导致整个交易回退。 addr.call、addr.callcode、addr.delegatecall：调用addr合约的指定的方法，区别稍后详述。 2.基本操作符 逻辑操作符：！(逻辑非)、&amp;&amp;(逻辑与)、||(逻辑或)。跟C++完全一致，并且&amp;&amp;与||同样存在短路求值。 比较操作符：&lt;、&lt;=、&gt;、&gt;=、==、!=，跟C++完全一致。 算术操作符：+(正号)、-（负号）、 +、-、*、/、%(取余)、&lt;&lt;(左移)、&gt;&gt;(右移)、**(幂)。除了幂，其余的都跟C++一致。 位操作符：&amp;(与)、|(或)、~(非)、^(异或)。 3.数组、字符串、结构体、枚举类型、mapping 数组 定长数组：编译期长度就固定下来的数组是定长数组，这样定义一个定常数组：T[k]（例如 uint8[ 5 ] arr）。bytes1、bytes2, bytes3, …, bytes32，这些也是定长数组。bytes1可以简写成byte。定长数组是值类型（value-type）,可以进行比较操作、位操作、索引操作。 动态数组：编译期长度不固定，类似于C++中的vector，这样定义一个动态数组：T[] (例如 int256[] arr)。 string是特殊的动态数组。普通的定长数组、动态数组都可以进行取长度操作：arr.length，以及下标索引操作，但是string暂时不支持这两种操作。bytes也是动态数组，相当于byte[]，但是比byte[]要更、廉价一些，应该尽量使用bytes。另外，动态数组、bytes还可以调用push方法，在数组末尾添加数据，返回最新的长度。 字符串 string本质上是经过UTF8编码的byte数组。当前版本的solidity对string的实现十分不完整，无法支持串联、比较、下标索引等操作，甚至连取长度都不支持。当前的string仅可以用来做mapping的key。 结构体 跟C++很像，这样定义一个结构体： struct MyStruct{ bool flag; string name; } MyStruct a; 结构体、数组里未被初始化的元素，都是0。 枚举 mapping solidity里使用频率比较高的类型。mapping (address =&gt; uint256) balanceOf; 定义了一个map，使用地址做索引，值位uint256. 4.全局可用的单位、函数、对象 以太币单位 1 Ether = 1000 Finny 1 Finny = 1000 Szabo 1 Szabo = 1000 Gwei 1 Gwei = 1000 Mwei 1 Mwei = 1000 Kwei 1 Kwei = 1000 wei 1 Ether = 10^18 wei 时间单位 1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks == 7 days 1 years == 365 days block对象 block.blockhash(uint blockNumber) returns (bytes32)：返回指定高度的块的hash值，仅限最近256块。 block.coinbase (address)：当前块的矿工 block.difficulty (uint)：当前块的难度 block.gaslimit (uint)：当前块的gaslimit block.number (uint)：当前块高度 block.timestamp (uint): 当前块时间戳 msg对象 msg.data (bytes)：当前调用完整的原始数据 msg.gas (uint): 剩余的gas，0.4.21版本之后弃用，替换为gasleft。 msg.sender (address): 当前调用的发起者。 msg.sig (bytes4):调用数据的头四字节 msg.value (uint):当前消息携带的以太币，单位wei。 tx对象 tx.gasprice (uint):当前交易的gas price tx.origin (address): 当前交易的发起者。 数学函数、hash函数 addmod(uint x, uint y, uint k) returns (uint): mulmod(uint x, uint y, uint k) returns (uint): keccak256(…) returns (bytes32): sha256(…) returns (bytes32): sha3(…) returns (bytes32): ripemd160(…) returns (bytes20): ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address): 异常处理函数 assert(bool condition): require(bool condition): revert(): 其他 gasleft() returns (uint256) now (uint): this suicide 5.contract（合约） contract类似于class，他有： 构造函数。跟contract名称相同的function即为构造函数，在合约创建时被调用，可以有参数，无返回值。 自杀函数。selfdestruct（address）销毁合约，并把合约账户里的ether转移到指定的地址，花费比调用transfer小。suicide是selfdestruct的别名。 this。在合约内，this可以转化成address。在合约内部调用自己的external函数也需要用到this。 成员变量。 成员函数。 继承、被继承。一个合约可以继承其他合约。 6.可见性：external、public、internal、private 合约内的成员变量、成员函数需要使用可见性来修饰，不修饰默认为public（跟C++刚好相反）。 external：只能用来修饰成员函数，这样的函数只能被外部合约调用，合约内部想要调用该函数，需要使用this.func(); public：修饰变量，则编译器会自动生成一个同名的getter。修饰函数，则外部可以调用该函数。 internal：类似于protect，可被合约内部以及子类合约访问。 private：私有的，仅合约内部可以访问，子类不可访问。 7.函数及其修饰词 函数可以有多个返回值： 直接通过一个稍微复杂点的例子来看下solidity的函数是啥样子的。 uint16 uCount; //合约内的成员变量 function add(uint8 a, uint8 b) public pure returns(uint8){ return a + b; //先忽略溢出。 } function GetCount() public view returns(uint16){ return uCount; } function setCount(uint16 count) public { uCount = count; } modifier validAddress(address addr){ assert(addr != address(0)); _; } modifier validAmount(uint256 amount){ reqire(amount &gt; 0); _; } function myTransferFunc(address to, uint256 amount) public validAddress(to) validAmount(amount){ //无需再检查参数的合法性，如果不合法，会在modifier中抛出异常，进不到函数体中。 //........ //........ } function deposit(uint256 amount) public payable returns(bool, string){ //........ return (true, &quot;successfull&quot;); } function () public payable{ //....... }   从上往下依次看，add方法很简单，实现了两个数相加，但是pure是啥意思？GetCount方法的view又是啥意思？SetCount为啥没有这两个东西？pure：不改变合约状态，也不读取合约状态的函数，开发者应当主动使用pure修饰；读取合约状态但是不修改合约状态的函数，使用view修饰；SetCount改变了合约状态，不能被这两个中的任何一个修饰。（老版本的solidity没有view与pure，只有一个constant，凡是不改变状态的函数需要被constant修饰，后来细化成两部分view + pure）。   接下来的modifier，业界普遍翻译成函数修改器，我觉得应该叫 函数卫词，它就像是一个卫语句，在函数运行之前过滤参数的合法性。不合法直接抛出异常，退出函数体，整个交易都不会被执行。   再往下，一个新关键词：payable。被这个修饰的函数，才能够被转账，否则只能是普通调用。   最后，一个没有名字的函数，叫回退函数（fallback function）。当且仅当一个合约的回退函数被实现了且被payable修饰了，才能向这个合约地址直接转账。 8.事件   事件是另一个新东西，可以让外部dapp监控合约内的变化。这里先简单介绍下事件的定义以及触发，事件的监听后面补上。 event OnTrasnsfer(address from, address to, uint value); function myTransferFunc(address to, uint256 amount) public validAddress(to) validAmount(amount){ //转账 。。。 //新版本的solidity触发事件需要使用emit关键字，之前的版本不用，但是看起来像是个函数调用。 emit OnTrasnsfer(address(this), to, amount); } 扩展篇 1.继承、多态、super solidity支持继承，并且支持多重继承。 下面的代码展示了基本的继承的作用：代码重用。 contract ERC20Token{ string public name; string public symbol; uint256 public decimals; uint256 public totalSupply; mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); //基类里可以不给实现，只做函数声明。也可给一个实现，子类根据情况，选择直接使用用或者重新写一个实现覆盖父类的 function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value)public returns (bool success); } contract TokenA is ERC20Token { function MyToken(string _name, string _symbol, uint256 _decimals) public{ name = _name; symbol = _symbol; decimals = _decimals; } //如果父类只声明了该方法，此处为实现。若父类实现了，此处会覆盖父类的实现。 function transfer(address _to, uint256 _value) public returns (bool success){ } } contract TokenB is ERC20Token { ..... ..... } 假如ERC20Token里的方法只给了声明，那ERC20Token就是一个抽象合约，该合约不能被部署只能做父类。 接下来就是由继承+重写(override)而引出的多态： contract Base{ function Func() public pure returns(uint256){ return 11112222; } } contract Drived is Base{ function Func() public pure returns(uint256){ return 33334444; } } contract TestContract{ function TestContract() public{ } function TestPolymorphism(address subClassAddr) public pure returns(uint256, uint256){ Drived objDrived = Drived(subClassAddr); Base objBase = Base(subClassAddr); return (objDrived.Func(), objBase.Func()); } } 我们先部署Base、Drive两个合约，分别得到合约地址baseAddr、drivedAddr，再部署TestContract合约，分别把两个地址做参数调用TestPolymorphism方法，结果如下： 使用baseAddr做参数，输出为： 11112222 11112222 *使用drivedAddr做参数，输出为： 33334444 33334444 有多重继承，及不可避免地会引起棱形继承，看下面代码： contract Ancestor{ function Func(uint256 val)public pure returns(uint256){ return val; } } contract BaseA is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return Ancestor.Func(val * 2); } } contract BaseB is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return Ancestor.Func(val * 4); } } contract Final is BaseA, BaseB { } 我们部署了Final合约之后，该合约对外只有一个可以调用的方法：Func，使用一个数字N做参数，输出会是多少呢?答案是4N。如果把继承的顺序改为 contract Final is BaseB, BaseA ,则输出的结果便是2N。solidity在处理多继承的时候，有一个结构叫继承图(inheritance graph)，对于第一种情况，继承图是这样的：Final-BaseB-BaseA-Ancestor。所以调用Final.Func实际上调用的是BaseB里的Func。 接下来看看神奇的super contract BaseA is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return super.Func(val * 2); } } contract BaseB is Ancestor{ function Func(uint256 val)public pure returns(uint256){ return super.Func(val * 4); } } contract Final is BaseA, BaseB { } 部署了Final之后调用Func方法，传入N，结果是8N。为啥？super不是简单的调用所在的合约的父合约，而是调用继承图中的下一个合约里的方法：继承图为Final-BaseB-BaseA-Ancestor，BaseB中的super.Func实际上调用的是BaseA.Func，所以最终的N被放大了4*2=8倍。 2. throw、require、assert、revert require与assert都是用来进行条件过滤的，当里面的条件表达式为false时，抛出异常回退整个交易。二者本质的区别在于： require（opcode为0xfd）会直接异常，已用掉的gas送给旷工，未使用的gas返回给交易发起者。 assert（opcode为0xfe）也是抛出异常，同时消耗掉交易发起者提供的 所有 gas。 使用者可根据以上特点酌情使用两者。比如，在需要过滤恶意调用的地方使用assert，能够增加hacker的攻击成本。 throw和revert两个同样使用的是0xfd操作码，跟require是一样的。但是在0.4.10版本之前，throw用的是0xfe。所以不推荐使用throw而推荐用revert代之，因为throw会在不同版本的编译器上体现不同的行为。 3. 合约间的访问：call、callcode、delegatecall 4. storage、memory、new、delete 5. import、library、using for 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/17/19b3374d571287324a88413dcbfa6881.html","headline":"Win10下开发部署Dapp(4)：solidity快速入门","dateModified":"2018-03-17T00:00:00+08:00","datePublished":"2018-03-17T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/17/19b3374d571287324a88413dcbfa6881.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Win10下开发部署Dapp(4)：solidity快速入门</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p></p>
  <h2 id="基础篇">
   <center>
    基础篇
   </center></h2>
  <p></p> 
  <p>Solidity是一门静态类型的脚本语言，我们可以对照C++的语法进行快速记忆。</p> 
  <h3 id="1基本保留字与基本类型">1.基本保留字与基本类型</h3> 
  <blockquote> 
   <ul> 
    <li>contract：类似于class，定义一个合约，具有构造函数，仅在创建合约时被调用。</li> 
    <li>function：定义一个函数。</li> 
    <li>event：定义一个事件，外部Dapp可以监控这些事件，以获知合约内的变化。</li> 
    <li>var：声明变量，类似于C++11的auto，可以在初始化时进行自动类型推导，之后不能更改类型。</li> 
    <li>bool: 布尔类型，有true跟false两种值。</li> 
    <li>uint8、uint16、。。。uint256：无符号整型，uint是uint256的别名。</li> 
    <li>nint8、int16、。。。int256：有符号整形，int是int256的别名。</li> 
    <li>ufixedMxN：无符号定点小数，M表示整个类型占用的bit数，N表示小数位数。ufixed64x7：7位小数，剩下的是整数部分</li> 
    <li>fixedMxN：定点小数。</li> 
    <li>address：地址类型，表示账户地址或者合约地址。20Byte。 <br> addr.balance：返回uint256类型的值，表示addr账户的余额（Wei）。 <br> addr.send(uint256 N)：转给addr地址N Wei数量的以太币，失败是返回false。 <br> addr.transfer(uint256 N)：包装了send方法，失败时直接抛出异常，会导致整个交易回退。 <br> addr.call、addr.callcode、addr.delegatecall：调用addr合约的指定的方法，区别稍后详述。</li> 
   </ul> 
  </blockquote> 
  <h3 id="2基本操作符">2.基本操作符</h3> 
  <blockquote> 
   <ul> 
    <li>逻辑操作符：！(逻辑非)、&amp;&amp;(逻辑与)、||(逻辑或)。跟C++完全一致，并且&amp;&amp;与||同样存在短路求值。</li> 
    <li>比较操作符：&lt;、&lt;=、&gt;、&gt;=、==、!=，跟C++完全一致。</li> 
    <li>算术操作符：+(正号)、-（负号）、 +、-、*、/、%(取余)、&lt;&lt;(左移)、&gt;&gt;(右移)、**(幂)。除了幂，其余的都跟C++一致。</li> 
    <li>位操作符：&amp;(与)、|(或)、~(非)、^(异或)。</li> 
   </ul> 
  </blockquote> 
  <h3 id="3数组字符串结构体枚举类型mapping">3.数组、字符串、结构体、枚举类型、mapping</h3> 
  <blockquote> 
   <ul> 
    <li><p>数组</p> 
     <blockquote> 
      <ul>
       <li>定长数组：编译期长度就固定下来的数组是定长数组，这样定义一个定常数组：T[k]（例如 uint8[ 5 ] arr）。bytes1、bytes2, bytes3, …, bytes32，这些也是定长数组。bytes1可以简写成byte。定长数组是值类型（value-type）,可以进行比较操作、位操作、索引操作。</li> 
       <li>动态数组：编译期长度不固定，类似于C++中的vector，这样定义一个动态数组：T[] (例如 int256[] arr)。 <br> string是特殊的动态数组。普通的定长数组、动态数组都可以进行取长度操作：arr.length，以及下标索引操作，但是string暂时不支持这两种操作。bytes也是动态数组，相当于byte[]，但是比byte[]要更、廉价一些，应该尽量使用bytes。另外，动态数组、bytes还可以调用push方法，在数组末尾添加数据，返回最新的长度。</li>
      </ul> 
     </blockquote></li> 
    <li><p>字符串 <br> string本质上是经过UTF8编码的byte数组。当前版本的solidity对string的实现十分不完整，无法支持串联、比较、下标索引等操作，甚至连取长度都不支持。当前的string仅可以用来做mapping的key。</p></li> 
    <li><p>结构体 <br> 跟C++很像，这样定义一个结构体：</p> <pre class="prettyprint"><code class="language-javascript hljs ">struct MyStruct{
    bool flag;
    string name;
}
MyStruct a;</code></pre> <pre><code>结构体、数组里未被初始化的元素，都是0。
</code></pre></li> 
    <li><p>枚举</p></li> 
    <li><p>mapping <br> solidity里使用频率比较高的类型。mapping (address =&gt; uint256) balanceOf; 定义了一个map，使用地址做索引，值位uint256.</p></li> 
   </ul> 
  </blockquote> 
  <h3 id="4全局可用的单位函数对象">4.全局可用的单位、函数、对象</h3> 
  <blockquote> 
   <ul> 
    <li>以太币单位 <br> 1 Ether = 1000 Finny <br> 1 Finny = 1000 Szabo <br> 1 Szabo = 1000 Gwei <br> 1 Gwei = 1000 Mwei <br> 1 Mwei = 1000 Kwei <br> 1 Kwei = 1000 wei <br> 1 Ether = 10^18 wei</li> 
    <li>时间单位 <br> 1 == 1 seconds <br> 1 minutes == 60 seconds <br> 1 hours == 60 minutes <br> 1 days == 24 hours <br> 1 weeks == 7 days <br> 1 years == 365 days</li> 
    <li>block对象 <br> block.blockhash(uint blockNumber) returns (bytes32)：返回指定高度的块的hash值，仅限最近256块。 <br> block.coinbase (address)：当前块的矿工 <br> block.difficulty (uint)：当前块的难度 <br> block.gaslimit (uint)：当前块的gaslimit <br> block.number (uint)：当前块高度 <br> block.timestamp (uint): 当前块时间戳</li> 
    <li>msg对象 <br> msg.data (bytes)：当前调用完整的原始数据 <br> msg.gas (uint): 剩余的gas，0.4.21版本之后弃用，替换为gasleft。 <br> msg.sender (address): 当前调用的发起者。 <br> msg.sig (bytes4):调用数据的头四字节 <br> msg.value (uint):当前消息携带的以太币，单位wei。</li> 
    <li>tx对象 <br> tx.gasprice (uint):当前交易的gas price <br> tx.origin (address): 当前交易的发起者。</li> 
    <li>数学函数、hash函数 <br> addmod(uint x, uint y, uint k) returns (uint): <br> mulmod(uint x, uint y, uint k) returns (uint): <br> keccak256(…) returns (bytes32): <br> sha256(…) returns (bytes32): <br> sha3(…) returns (bytes32): <br> ripemd160(…) returns (bytes20): <br> ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):</li> 
    <li>异常处理函数 <br> assert(bool condition): <br> require(bool condition): <br> revert():</li> 
    <li>其他 <br> gasleft() returns (uint256) <br> now (uint): <br> this <br> suicide</li> 
   </ul> 
  </blockquote> 
  <h3 id="5contract合约">5.contract（合约）</h3> 
  <p>contract类似于class，他有：</p> 
  <blockquote> 
   <ul> 
    <li>构造函数。跟contract名称相同的function即为构造函数，在合约创建时被调用，可以有参数，无返回值。</li> 
    <li>自杀函数。selfdestruct（address）销毁合约，并把合约账户里的ether转移到指定的地址，花费比调用transfer小。suicide是selfdestruct的别名。</li> 
    <li>this。在合约内，this可以转化成address。在合约内部调用自己的external函数也需要用到this。</li> 
    <li>成员变量。</li> 
    <li>成员函数。</li> 
    <li>继承、被继承。一个合约可以继承其他合约。</li> 
   </ul> 
  </blockquote> 
  <h3 id="6可见性externalpublicinternalprivate">6.可见性：external、public、internal、private</h3> 
  <p>合约内的成员变量、成员函数需要使用可见性来修饰，不修饰默认为public（跟C++刚好相反）。</p> 
  <blockquote> 
   <ul> 
    <li>external：只能用来修饰成员函数，这样的函数只能被外部合约调用，合约内部想要调用该函数，需要使用this.func();</li> 
    <li>public：修饰变量，则编译器会自动生成一个同名的getter。修饰函数，则外部可以调用该函数。</li> 
    <li>internal：类似于protect，可被合约内部以及子类合约访问。</li> 
    <li>private：私有的，仅合约内部可以访问，子类不可访问。</li> 
   </ul> 
  </blockquote> 
  <h3 id="7函数及其修饰词">7.函数及其修饰词</h3> 
  <p>函数可以有多个返回值： <br> 直接通过一个稍微复杂点的例子来看下solidity的函数是啥样子的。</p> 
  <pre class="prettyprint"><code class="language-javascript hljs ">uint16 uCount; <span class="hljs-comment">//合约内的成员变量</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(uint8 a, uint8 b)</span> <span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint8)</span>{</span>
    <span class="hljs-keyword">return</span> a + b; <span class="hljs-comment">//先忽略溢出。</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetCount</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint16)</span>{</span>
    <span class="hljs-keyword">return</span> uCount;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setCount</span><span class="hljs-params">(uint16 count)</span> <span class="hljs-title">public</span> {</span>
    uCount = count;
}

modifier validAddress(address addr){
    assert(addr != address(<span class="hljs-number">0</span>));
    _;
}
modifier validAmount(uint256 amount){
    reqire(amount &gt; <span class="hljs-number">0</span>);
    _;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myTransferFunc</span><span class="hljs-params">(address to, uint256 amount)</span> <span class="hljs-title">public</span> <span class="hljs-title">validAddress</span><span class="hljs-params">(to)</span> <span class="hljs-title">validAmount</span><span class="hljs-params">(amount)</span>{</span>
    <span class="hljs-comment">//无需再检查参数的合法性，如果不合法，会在modifier中抛出异常，进不到函数体中。</span>
    <span class="hljs-comment">//........</span>
    <span class="hljs-comment">//........</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deposit</span><span class="hljs-params">(uint256 amount)</span> <span class="hljs-title">public</span> <span class="hljs-title">payable</span> <span class="hljs-title">returns</span><span class="hljs-params">(bool, string)</span>{</span> 
    <span class="hljs-comment">//........</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>, <span class="hljs-string">"successfull"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">payable</span>{</span>
    <span class="hljs-comment">//.......</span>
}</code></pre> 
  <p>  从上往下依次看，add方法很简单，实现了两个数相加，但是pure是啥意思？GetCount方法的view又是啥意思？SetCount为啥没有这两个东西？pure：不改变合约状态，也不读取合约状态的函数，开发者应当主动使用pure修饰；读取合约状态但是不修改合约状态的函数，使用view修饰；SetCount改变了合约状态，不能被这两个中的任何一个修饰。（老版本的solidity没有view与pure，只有一个constant，凡是不改变状态的函数需要被constant修饰，后来细化成两部分view + pure）。 <br>   接下来的modifier，业界普遍翻译成函数修改器，我觉得应该叫 <strong>函数卫词</strong>，它就像是一个卫语句，在函数运行之前过滤参数的合法性。不合法直接抛出异常，退出函数体，整个交易都不会被执行。 <br>   再往下，一个新关键词：payable。被这个修饰的函数，才能够被转账，否则只能是普通调用。 <br>   最后，一个没有名字的函数，叫回退函数（fallback function）。当且仅当一个合约的回退函数被实现了且被payable修饰了，才能向这个<strong>合约地址</strong>直接转账。</p> 
  <h3 id="8事件">8.事件</h3> 
  <p>  事件是另一个新东西，可以让外部dapp监控合约内的变化。这里先简单介绍下事件的定义以及触发，事件的监听后面补上。</p> 
  <pre class="prettyprint"><code class="language-javascript hljs ">event OnTrasnsfer(address from, address to, uint value);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myTransferFunc</span><span class="hljs-params">(address to, uint256 amount)</span> <span class="hljs-title">public</span> <span class="hljs-title">validAddress</span><span class="hljs-params">(to)</span> <span class="hljs-title">validAmount</span><span class="hljs-params">(amount)</span>{</span>
    <span class="hljs-comment">//转账</span>
    。。。
    <span class="hljs-comment">//新版本的solidity触发事件需要使用emit关键字，之前的版本不用，但是看起来像是个函数调用。</span>
    emit OnTrasnsfer(address(<span class="hljs-keyword">this</span>), to, amount);
}</code></pre> 
  <p></p>
  <h2 id="扩展篇">
   <center>
    扩展篇
   </center></h2>
  <p></p> 
  <h3 id="1继承多态super">1.继承、多态、super</h3> 
  <p>solidity支持继承，并且支持多重继承。</p> 
  <p>下面的代码展示了基本的继承的作用：代码重用。</p> 
  <pre class="prettyprint"><code class="language-javascript hljs ">contract ERC20Token{
    string public name;
    string public symbol;
    uint256 public decimals;
    uint256 public totalSupply;
    mapping (address =&gt; uint256) public balanceOf;
    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    <span class="hljs-comment">//基类里可以不给实现，只做函数声明。也可给一个实现，子类根据情况，选择直接使用用或者重新写一个实现覆盖父类的</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address _to, uint256 _value)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span>; <span class="hljs-title">function</span> <span class="hljs-title">transferFrom</span><span class="hljs-params">(address _from, address _to, uint256 _value)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span>; <span class="hljs-title">function</span> <span class="hljs-title">approve</span><span class="hljs-params">(address _spender, uint256 _value)</span><span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span>; } <span class="hljs-title">contract</span> <span class="hljs-title">TokenA</span> <span class="hljs-title">is</span> <span class="hljs-title">ERC20Token</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyToken</span><span class="hljs-params">(string _name, string _symbol, uint256 _decimals)</span> <span class="hljs-title">public</span>{</span>
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }
    <span class="hljs-comment">//如果父类只声明了该方法，此处为实现。若父类实现了，此处会覆盖父类的实现。</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address _to, uint256 _value)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool success)</span>{</span>

    }
}

contract TokenB is ERC20Token {
        .....
        .....
}</code></pre> 
  <p>假如ERC20Token里的方法只给了声明，那ERC20Token就是一个抽象合约，该合约不能被部署只能做父类。 <br> 接下来就是由继承+重写(override)而引出的多态：</p> 
  <pre class="prettyprint"><code class="language-javascript hljs ">contract Base{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint256)</span>{</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">11112222</span>;
    }
}

contract Drived is Base{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint256)</span>{</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">33334444</span>;
    }
}

contract TestContract{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TestContract</span><span class="hljs-params">()</span> <span class="hljs-title">public</span>{</span>

    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TestPolymorphism</span><span class="hljs-params">(address subClassAddr)</span> <span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint256, uint256)</span>{</span>
        Drived objDrived = Drived(subClassAddr);
        Base objBase     = Base(subClassAddr);

        <span class="hljs-keyword">return</span> (objDrived.Func(), objBase.Func());
    }
}</code></pre> 
  <p>我们先部署Base、Drive两个合约，分别得到合约地址baseAddr、drivedAddr，再部署TestContract合约，分别把两个地址做参数调用TestPolymorphism方法，结果如下：</p> 
  <blockquote> 
   <ul> 
    <li>使用baseAddr做参数，输出为： <br> 11112222 <br> 11112222 <br> *使用drivedAddr做参数，输出为： <br> 33334444 <br> 33334444 <br> 有多重继承，及不可避免地会引起棱形继承，看下面代码：</li> 
   </ul> 
  </blockquote> 
  <pre class="prettyprint"><code class="language-javascript hljs ">
contract Ancestor{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Func</span><span class="hljs-params">(uint256 val)</span><span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint256)</span>{</span>
        <span class="hljs-keyword">return</span> val;
    }
}
contract BaseA is Ancestor{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Func</span><span class="hljs-params">(uint256 val)</span><span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint256)</span>{</span>
        <span class="hljs-keyword">return</span> Ancestor.Func(val * <span class="hljs-number">2</span>);
    }
}
contract BaseB is Ancestor{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Func</span><span class="hljs-params">(uint256 val)</span><span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint256)</span>{</span>
        <span class="hljs-keyword">return</span> Ancestor.Func(val * <span class="hljs-number">4</span>);
    }
}
contract Final is BaseA, BaseB {

}</code></pre> 
  <p>我们部署了Final合约之后，该合约对外只有一个可以调用的方法：Func，使用一个数字N做参数，输出会是多少呢?答案是4N。如果把继承的顺序改为 <strong>contract Final is BaseB, BaseA </strong> ,则输出的结果便是2N。solidity在处理多继承的时候，有一个结构叫<strong>继承图</strong>(inheritance graph)，对于第一种情况，继承图是这样的：Final-BaseB-BaseA-Ancestor。所以调用Final.Func实际上调用的是BaseB里的Func。 <br> 接下来看看神奇的<strong>super</strong></p> 
  <pre class="prettyprint"><code class="language-javascript hljs ">contract BaseA is Ancestor{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Func</span><span class="hljs-params">(uint256 val)</span><span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint256)</span>{</span>
        <span class="hljs-keyword">return</span> super.Func(val * <span class="hljs-number">2</span>);
    }
}
contract BaseB is Ancestor{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Func</span><span class="hljs-params">(uint256 val)</span><span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint256)</span>{</span>
        <span class="hljs-keyword">return</span> super.Func(val * <span class="hljs-number">4</span>);
    }
}
contract Final is BaseA, BaseB {

}</code></pre> 
  <p>部署了Final之后调用Func方法，传入N，结果是8N。为啥？super不是简单的调用所在的合约的父合约，而是调用继承图中的下一个合约里的方法：继承图为Final-BaseB-BaseA-Ancestor，BaseB中的super.Func实际上调用的是BaseA.Func，所以最终的N被放大了4*2=8倍。</p> 
  <h3 id="2-throwrequireassertrevert">2. throw、require、assert、revert</h3> 
  <p>require与assert都是用来进行条件过滤的，当里面的条件表达式为false时，抛出异常回退整个交易。二者本质的区别在于：</p> 
  <blockquote> 
   <ul> 
    <li>require（opcode为0xfd）会直接异常，已用掉的gas送给旷工，未使用的gas返回给交易发起者。</li> 
    <li>assert（opcode为0xfe）也是抛出异常，同时消耗掉交易发起者提供的 <strong>所有</strong> gas。</li> 
   </ul> 
  </blockquote> 
  <p>使用者可根据以上特点酌情使用两者。比如，在需要过滤恶意调用的地方使用assert，能够增加hacker的攻击成本。 <br> throw和revert两个同样使用的是0xfd操作码，跟require是一样的。但是在0.4.10版本之前，throw用的是0xfe。所以不推荐使用throw而推荐用revert代之，因为throw会在不同版本的编译器上体现不同的行为。</p> 
  <h3 id="3-合约间的访问callcallcodedelegatecall">3. 合约间的访问：call、callcode、delegatecall</h3> 
  <h3 id="4-storagememorynewdelete">4. storage、memory、new、delete</h3> 
  <h3 id="5-importlibraryusing-for">5. import、library、using for</h3> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/JohnnyMartin/article/details/79565875,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/JohnnyMartin/article/details/79565875,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
