<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>一天一步解读迷恋猫CryptoKitties源码（二） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="一天一步解读迷恋猫CryptoKitties源码（二）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="书接上文 CryptoKitties中包含的contract： contract Ownable contract ERC721 contract GeneScienceInterface contract KittyAccessControl contract KittyBase is KittyAccessControl contract ERC721Metadata contract KittyOwnership is KittyBase, ERC721 contract KittyBreeding is KittyOwnership contract ClockAuctionBase contract Pausable is Ownable contract ClockAuction is Pausable, ClockAuctionBase contract SaleClockAuction is ClockAuction contract KittyAuction is KittyBreeding contract KittyMinting is KittyAuction contract KittyCore is KittyMinting 在上篇文章中，我们解析了Ownable和KittyAccessControl两个合约的代码。自感进度缓慢，今天利用一天的时间，尽可能多的来码字。各位看官瞧来： 0x03 KittyBase 这个合约中主要决定了我们猫猫的属性值，决定了每个猫猫都唯一的基因值，出生日期，父母的id，以及目前猫猫的代数等信息。这些属性值保存在struct Kitty里。 我们一点一点来分析这个合约的代码，先看其中220-280行的代码，去掉原有的注释，加上我们的注释后，代码如下： contract KittyBase is KittyAccessControl { // 监听出生的事件： // 当一个猫猫出生时，这个事件将会记录这个猫猫的拥有者owner，猫猫的编号kittyId // 父母的编号matronId和sireId，还有这个猫的基因genes event Birth(address owner, uint256 kittyId, uint256 matronId, uint256 sireId, uint256 genes); // 监听猫猫转移所有权的事件： // 从from拥有者，转移到to的新拥有者 // 转移猫猫的编号tokenId event Transfer(address from, address to, uint256 tokenId); // 猫猫的基础数据 struct Kitty { uint256 genes; // 猫猫的基因 uint64 birthTime; // 猫猫出生的日期 uint64 cooldownEndBlock;// 猫猫可以再次进行繁殖的最小区块。用于已经怀孕的猫猫 uint32 matronId; // 猫妈妈的ID uint32 sireId; // 猫爸爸的ID uint32 siringWithId; // 怀孕繁殖期，当前交配的猫猫ID。 uint16 cooldownIndex; // 繁殖冷却时间 uint16 generation; // 猫猫的代数 } ... } genes 对于一个猫猫最重要的就是他的基因，一个猫猫的基因由父母的基因决定生成。生成的算法在合约GeneScienceInterface中的mixGenes方法，基因决定了猫猫的各项属性，但是具体决定的方法并没有开源，所以我们不得而知。 birthTime 猫猫的出生日期不言而喻，在_createKitty时使用uint64(now)确定为当前时间。 cooldownEndBlock 一个刚出生猫猫的cooldownEndBlock值为0。当一个猫猫要进行生产时，需要下先调用KittyBreeding合约中_isReadyToBreed方法，这个方法会判断这个的cooldownEndBlock是否小于等于当前的区块编号。cooldownEndBlock是判断一个猫是否能够生产的其中一个判断条件，也是一个必要条件。一个怀孕的猫猫必须等待一段时间才可以进行生产，而等待时间的标准不是一个具体的时间戳，而是一个区块的编号，只有当前区块的编号值大于等于cooldownEndBlock的值的时候，这个准猫妈妈才可以进行生产。 matronId sireId 对于初代猫猫的父母编号都是0。 siringWithId 如果一个猫没有怀孕，那么这个值将会是0。如果一个猫怀孕了，那么这个值就不是0。所以通过siringWithId可以判断一个猫是否已经欢迎。而当猫宝宝出生时，可以通过这个编号id来获取猫爸爸的基因，获取到的基因和母亲的组合生成小猫的基因。 cooldownIndex 为了避免一个用户频繁的使用同一个猫进行繁殖，为每一个猫都加入了一个繁殖的冷却期。在这个冷却过程中，猫猫不可以和其他猫猫进行交往配对。初代猫的冷却期最短为0，随着猫猫的代数增加，冷却期的初始值等于_generation / 2。同时随着猫猫的生育次数的增加，这个冷却期的时间也会不断递增。 generation 初代猫的代数值为0，之后生育的猫猫的代数等于max((母亲的代数， 父亲的代数)+1) 上面我们分析了这个合约中猫猫的属性结构体，再接着看后面的代码280-435行： contract KittyBase is KittyAccessControl { ... // cooldownIndex对应的冷却时间 // 随着猫猫的代数和生育次数的增加，猫猫进行交配的冷却时间也会逐渐增加。 // 最大冷却时间不会超过7天。 uint32[14] public cooldowns = [ uint32(1 minutes), uint32(2 minutes), uint32(5 minutes), uint32(10 minutes), uint32(30 minutes), uint32(1 hours), uint32(2 hours), uint32(4 hours), uint32(8 hours), uint32(16 hours), uint32(1 days), uint32(2 days), uint32(4 days), uint32(7 days) ]; // 生成一个区块的时间 uint256 public secondsPerBlock = 15; // 这里保存所有区块中的猫猫的id Kitty[] kitties; // 猫猫的id到猫猫地址的映射 mapping (uint256 =&gt; address) public kittyIndexToOwner; // 拥有者到拥有者猫猫个数的映射 mapping (address =&gt; uint256) ownershipTokenCount; // 准备出售的猫猫id到拥有者地址的映射 mapping (uint256 =&gt; address) public kittyIndexToApproved; // 准备交配的猫猫id到拥有者地址的映射 mapping (uint256 =&gt; address) public sireAllowedToAddress; // 拍卖合约的地址 SaleClockAuction public saleAuction; // 交配的合约地址 SiringClockAuction public siringAuction; // 从_from拥有者，将id为_tokenId的猫猫转移到_to的新拥有者 // _from为0时，表明初代猫生成 function _transfer(address _from, address _to, uint256 _tokenId) internal { // 增加新拥有者猫猫的数量 ownershipTokenCount[_to]++; // 变更猫猫的新主人为_to kittyIndexToOwner[_tokenId] = _to; // 判断_from地址是否为空 if (_from != address(0)) { // 如果不为空，_from原拥有者的猫猫数量减一 ownershipTokenCount[_from]--; // 删除这个猫猫的出售信息 delete sireAllowedToAddress[_tokenId]; // 删除这个猫猫的交配信息 delete kittyIndexToApproved[_tokenId]; } // 事件记录 Transfer(_from, _to, _tokenId); } // 生成一个新的猫猫 // _matronId、_sireId父母id // _generation 代数 // _genes 基因 // _owner 猫猫拥有者 // 返回新猫猫id function _createKitty( uint256 _matronId, uint256 _sireId, uint256 _generation, uint256 _genes, address _owner ) internal returns (uint) { // 新的猫猫必须包含父母id和代数信息 require(_matronId == uint256(uint32(_matronId))); require(_sireId == uint256(uint32(_sireId))); require(_generation == uint256(uint16(_generation))); // 更换_generation代数信息确定猫猫初始冷却交配时间，最大值为13(13对应7天) uint16 cooldownIndex = uint16(_generation / 2); if (cooldownIndex &gt; 13) { cooldownIndex = 13; } // 生成一个猫猫的基本属性 Kitty memory _kitty = Kitty({ genes: _genes, birthTime: uint64(now), cooldownEndBlock: 0, matronId: uint32(_matronId), sireId: uint32(_sireId), siringWithId: 0, cooldownIndex: cooldownIndex, generation: uint16(_generation) }); // 将新的猫咪放入kitties中 // 猫咪的id等于kitties数组中的顺序编号 uint256 newKittenId = kitties.push(_kitty) - 1; require(newKittenId == uint256(uint32(newKittenId))); // 事件记录 Birth( _owner, newKittenId, uint256(_kitty.matronId), uint256(_kitty.sireId), _kitty.genes ); // 给_owner分配新猫猫newKittenId _transfer(0, _owner, newKittenId); return newKittenId; } // CEO COO CFO 可以修改区块生成时间 function setSecondsPerBlock(uint256 secs) external onlyCLevel { require(secs &lt; cooldowns[0]); secondsPerBlock = secs; } } 0x04 ERC721 在继续向下看之前，我们先来了解一下ERC721的合约。 先抛出代码中的注释： Interface for contracts conforming to ERC-721: Non-Fungible Tokens 符合ERC-721的合约的接口：非同质代币 首先来解释什么叫非同质代币：先来解释什么是同质代币，比如大家熟知的比特币和以太币都是同质代币。每一个不同的比特币和以太币都拥有相同的价值。每一个token的价值平等，你只需要注意自己的token数量是否变化，很少有人注意你钱包里的token都是什么样的地址，转账和消费时是用token1还是用token2，因为他们的价值都是一样的,可以换来同等的等价物。这就是同质代币。 而非同质代币和同质代币相反，每一个token都有不同的基因，不同的基因决定不同的长相，最关键的是不同的基因和长相决定了每一个token拥有不同的价值。假如你有一个非常稀有的猫猫，你一定希望他和普通的猫猫有所区别，他们在拍卖中不会售出相同的价格。所以每一个猫都有自己的价值，这就和比特币和以太币有着本质的区别，所以在同质代币前加了一个非。 所以说迷恋猫就是一个标准的ERC721标准的智能合约。而每个ERC721标准合约需要实现ERC721及ERC165接口，所以源码中的代码如下： contract ERC721 { // Required methods // 返回所有非同质代币的数量 function totalSupply() public view returns (uint256 total); // 返回_owner的非同质代币的数量 function balanceOf(address _owner) public view returns (uint256 balance); // 返回_tokenId非同质代币的拥有者的地址 function ownerOf(uint256 _tokenId) external view returns (address owner); // 将_tokenId非同质代币授权给地址_to的拥有者 // approve()方法的目的是可以授权第三人来代替自己执行交易 function approve(address _to, uint256 _tokenId) external; // 将_tokenId非同质代币转移给地址为_to的拥有者 function transfer(address _to, uint256 _tokenId) external; // 从_from拥有者转移_tokenId非同质代币给_to新的拥有者 // 内部调用transfer方法进行转移 function transferFrom(address _from, address _to, uint256 _tokenId) external; // Events // 两个事件来分别记录转移和授权 event Transfer(address from, address to, uint256 tokenId); event Approval(address owner, address approved, uint256 tokenId); // Optional // 可选实现的接口： // 返回合约的名字 // function name() public view returns (string name); // 返回合约代币的符号 // function symbol() public view returns (string symbol); // 返回_owner所有的非同质代币的id // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds); // 返回非同质代币的元数据 // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl); // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165) // ERC721标准要求必须同时符合ERC165标准 // 方法用来验证这个合约是否实现了特定的接口。 function supportsInterface(bytes4 _interfaceID) external view returns (bool); } 笔者在这里不再展开描述ERC-165协议的具体内容了，感兴趣的童鞋可以通过以下链接学习： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md 0x05 ERC721Metadata 借着我们刚刚了解了ERC721，我们接着看源码中的ERC721Metadata合约。 这个合约中的唯一一个方法getMetadata是用于提供合约的元数据(这里返回的是一个bytes和一个uint)。 输入和返回值分别代表什么含义呢，我们来看源码中441-460行的内容： contract ERC721Metadata { /// 根据_tokenId，返回特定的字符数组和总长度 function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) { // 如果_tokenId为1或2或3，返回不同的字符数组及总长度 if (_tokenId == 1) { buffer[0] = &quot;Hello World! :D&quot;; count = 15; } else if (_tokenId == 2) { buffer[0] = &quot;I would definitely choose a medi&quot;; buffer[1] = &quot;um length string.&quot;; count = 49; } else if (_tokenId == 3) { buffer[0] = &quot;Lorem ipsum dolor sit amet, mi e&quot;; buffer[1] = &quot;st accumsan dapibus augue lorem,&quot;; buffer[2] = &quot; tristique vestibulum id, libero&quot;; buffer[3] = &quot; suscipit varius sapien aliquam.&quot;; count = 128; } } } 0x06 KittyOwnership 这个合约继承自KittyBase和ERC721实现了ERC721接口中定义的方法。定义了整个合约的名称和单位 // KittyOwnership继承自KittyBase和ERC721 contract KittyOwnership is KittyBase, ERC721 { /// @notice Name and symbol of the non fungible token, as defined in ERC721. // 整个智能合约的名字为CryptoKitties string public constant name = &quot;CryptoKitties&quot;; // 猫猫代币的单位为CK string public constant symbol = &quot;CK&quot;; // The contract that will return kitty metadata // 合约的元数据 ERC721Metadata public erc721Metadata; // ERC165接口的加密byte = 0x01ffc9a7 bytes4 constant InterfaceSignature_ERC165 = bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;)); // ERC721接口的加密byte = 0x9a20483d bytes4 constant InterfaceSignature_ERC721 = bytes4(keccak256(&#39;name()&#39;)) ^ bytes4(keccak256(&#39;symbol()&#39;)) ^ bytes4(keccak256(&#39;totalSupply()&#39;)) ^ bytes4(keccak256(&#39;balanceOf(address)&#39;)) ^ bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^ bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^ bytes4(keccak256(&#39;transfer(address,uint256)&#39;)) ^ bytes4(keccak256(&#39;transferFrom(address,address,uint256)&#39;)) ^ bytes4(keccak256(&#39;tokensOfOwner(address)&#39;)) ^ bytes4(keccak256(&#39;tokenMetadata(uint256,string)&#39;)); // 验证是否实现了ERC721和ERC165 // function supportsInterface(bytes4 _interfaceID) external view returns (bool) { return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721)); } /// @dev Set the address of the sibling contract that tracks metadata. /// CEO only. function setMetadataAddress(address _contractAddress) public onlyCEO { erc721Metadata = ERC721Metadata(_contractAddress); } // 判断_tokenId的猫猫是否归_claimant地址用户所有 function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) { return kittyIndexToOwner[_tokenId] == _claimant; } // 判断_tokenId的猫猫是否可以被_claimant的地址用户进行转让 function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) { return kittyIndexToApproved[_tokenId] == _claimant; } // 允许_tokenId的猫猫可以被_approved的地址用户执行transferFrom()方法 function _approve(uint256 _tokenId, address _approved) internal { kittyIndexToApproved[_tokenId] = _approved; } // 返回_ownerd拥有的猫猫token个数 function balanceOf(address _owner) public view returns (uint256 count) { return ownershipTokenCount[_owner]; } // 将_tokenId的猫猫转移给_to地址拥有者 // 当系统没有处于暂停状态时 function transfer( address _to, uint256 _tokenId ) external whenNotPaused { // 检查一下_to的地址是否合法 require(_to != address(0)); // 不允许将猫猫转移给本合约地址 require(_to != address(this)); // 不予许将猫猫转移给拍卖合约地址 require(_to != address(saleAuction)); // 不允许将猫猫转移给交配合约地址 require(_to != address(siringAuction)); // 你只能发送_tokenId为你你自己拥有的猫猫 require(_owns(msg.sender, _tokenId)); // 事件记录 _transfer(msg.sender, _to, _tokenId); } // 授权其他人将_tokenId为自己拥有的猫猫调用transferFrom()转移给地址为_to的拥有者 // 当系统处于非暂停状态 function approve( address _to, uint256 _tokenId ) external whenNotPaused { // 只有猫猫的拥有者可以授权其他人 require(_owns(msg.sender, _tokenId)); // 修改_approve()方法修改kittyIndexToApproved[_tokenId] _approve(_tokenId, _to); // 事件记录 Approval(msg.sender, _to, _tokenId); } // 将_from用户的猫猫_tokenId转移给_to用户 // 当系统处于非暂停状态 function transferFrom( address _from, address _to, uint256 _tokenId ) external whenNotPaused { // 检查一下_to的地址是否合法 require(_to != address(0)); // 不允许将猫猫转移给本合约地址 require(_to != address(this)); // 检查msg.sender是否获得了授权转移_tokenId的毛毛啊 require(_approvedFor(msg.sender, _tokenId)); // 检查_from是否拥有_tokenId猫猫 require(_owns(_from, _tokenId)); // 调用_transfer()进行转移 _transfer(_from, _to, _tokenId); } // 返回目前所有的猫猫个数 function totalSupply() public view returns (uint) { return kitties.length - 1; } // 返回_tokenId猫猫的拥有者的地址 function ownerOf(uint256 _tokenId) external view returns (address owner) { owner = kittyIndexToOwner[_tokenId]; require(owner != address(0)); } // 返回_owner拥有的所有猫猫的id数组 function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) { // 获得_owner拥有的猫猫数量 uint256 tokenCount = balanceOf(_owner); // 判断数量是否为0 if (tokenCount == 0) { // 如果该_owner没有猫猫，返回空数组 return new uint256[](0); } else { // 如果该_owner有 // 声明并初始化一个返回值result，长度为tokenCount uint256[] memory result = new uint256[](tokenCount); // 当前所有的猫猫数量 uint256 totalCats = totalSupply(); // 循环的初始值 uint256 resultIndex = 0; // 所有的猫都有ID从1增加到totalCats uint256 catId; // 从1开始循环遍历所有的totalCats for (catId = 1; catId &lt;= totalCats; catId++) { // 判断当前catId的拥有者是否为_owner if (kittyIndexToOwner[catId] == _owner) { // 如果是，将catId放入result数组resultIndex位置 result[resultIndex] = catId; // resultIndex加1 resultIndex++; } } // 返回result return result; } } // 拷贝方法 function _memcpy(uint _dest, uint _src, uint _len) private view { // Copy word-length chunks while possible for(; _len &gt;= 32; _len -= 32) { assembly { mstore(_dest, mload(_src)) } _dest += 32; _src += 32; } // Copy remaining bytes uint256 mask = 256 ** (32 - _len) - 1; assembly { let srcpart := and(mload(_src), not(mask)) let destpart := and(mload(_dest), mask) mstore(_dest, or(destpart, srcpart)) } } // 将_rawBytes中长度为_stringLength转成string并返回 function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) { var outputString = new string(_stringLength); uint256 outputPtr; uint256 bytesPtr; assembly { outputPtr := add(outputString, 32) bytesPtr := _rawBytes } _memcpy(outputPtr, bytesPtr, _stringLength); return outputString; } // 返回指向该元数据的元数据包的URI function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) { require(erc721Metadata != address(0)); bytes32[4] memory buffer; uint256 count; (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport); return _toString(buffer, count); } } 阅读更多" />
<meta property="og:description" content="书接上文 CryptoKitties中包含的contract： contract Ownable contract ERC721 contract GeneScienceInterface contract KittyAccessControl contract KittyBase is KittyAccessControl contract ERC721Metadata contract KittyOwnership is KittyBase, ERC721 contract KittyBreeding is KittyOwnership contract ClockAuctionBase contract Pausable is Ownable contract ClockAuction is Pausable, ClockAuctionBase contract SaleClockAuction is ClockAuction contract KittyAuction is KittyBreeding contract KittyMinting is KittyAuction contract KittyCore is KittyMinting 在上篇文章中，我们解析了Ownable和KittyAccessControl两个合约的代码。自感进度缓慢，今天利用一天的时间，尽可能多的来码字。各位看官瞧来： 0x03 KittyBase 这个合约中主要决定了我们猫猫的属性值，决定了每个猫猫都唯一的基因值，出生日期，父母的id，以及目前猫猫的代数等信息。这些属性值保存在struct Kitty里。 我们一点一点来分析这个合约的代码，先看其中220-280行的代码，去掉原有的注释，加上我们的注释后，代码如下： contract KittyBase is KittyAccessControl { // 监听出生的事件： // 当一个猫猫出生时，这个事件将会记录这个猫猫的拥有者owner，猫猫的编号kittyId // 父母的编号matronId和sireId，还有这个猫的基因genes event Birth(address owner, uint256 kittyId, uint256 matronId, uint256 sireId, uint256 genes); // 监听猫猫转移所有权的事件： // 从from拥有者，转移到to的新拥有者 // 转移猫猫的编号tokenId event Transfer(address from, address to, uint256 tokenId); // 猫猫的基础数据 struct Kitty { uint256 genes; // 猫猫的基因 uint64 birthTime; // 猫猫出生的日期 uint64 cooldownEndBlock;// 猫猫可以再次进行繁殖的最小区块。用于已经怀孕的猫猫 uint32 matronId; // 猫妈妈的ID uint32 sireId; // 猫爸爸的ID uint32 siringWithId; // 怀孕繁殖期，当前交配的猫猫ID。 uint16 cooldownIndex; // 繁殖冷却时间 uint16 generation; // 猫猫的代数 } ... } genes 对于一个猫猫最重要的就是他的基因，一个猫猫的基因由父母的基因决定生成。生成的算法在合约GeneScienceInterface中的mixGenes方法，基因决定了猫猫的各项属性，但是具体决定的方法并没有开源，所以我们不得而知。 birthTime 猫猫的出生日期不言而喻，在_createKitty时使用uint64(now)确定为当前时间。 cooldownEndBlock 一个刚出生猫猫的cooldownEndBlock值为0。当一个猫猫要进行生产时，需要下先调用KittyBreeding合约中_isReadyToBreed方法，这个方法会判断这个的cooldownEndBlock是否小于等于当前的区块编号。cooldownEndBlock是判断一个猫是否能够生产的其中一个判断条件，也是一个必要条件。一个怀孕的猫猫必须等待一段时间才可以进行生产，而等待时间的标准不是一个具体的时间戳，而是一个区块的编号，只有当前区块的编号值大于等于cooldownEndBlock的值的时候，这个准猫妈妈才可以进行生产。 matronId sireId 对于初代猫猫的父母编号都是0。 siringWithId 如果一个猫没有怀孕，那么这个值将会是0。如果一个猫怀孕了，那么这个值就不是0。所以通过siringWithId可以判断一个猫是否已经欢迎。而当猫宝宝出生时，可以通过这个编号id来获取猫爸爸的基因，获取到的基因和母亲的组合生成小猫的基因。 cooldownIndex 为了避免一个用户频繁的使用同一个猫进行繁殖，为每一个猫都加入了一个繁殖的冷却期。在这个冷却过程中，猫猫不可以和其他猫猫进行交往配对。初代猫的冷却期最短为0，随着猫猫的代数增加，冷却期的初始值等于_generation / 2。同时随着猫猫的生育次数的增加，这个冷却期的时间也会不断递增。 generation 初代猫的代数值为0，之后生育的猫猫的代数等于max((母亲的代数， 父亲的代数)+1) 上面我们分析了这个合约中猫猫的属性结构体，再接着看后面的代码280-435行： contract KittyBase is KittyAccessControl { ... // cooldownIndex对应的冷却时间 // 随着猫猫的代数和生育次数的增加，猫猫进行交配的冷却时间也会逐渐增加。 // 最大冷却时间不会超过7天。 uint32[14] public cooldowns = [ uint32(1 minutes), uint32(2 minutes), uint32(5 minutes), uint32(10 minutes), uint32(30 minutes), uint32(1 hours), uint32(2 hours), uint32(4 hours), uint32(8 hours), uint32(16 hours), uint32(1 days), uint32(2 days), uint32(4 days), uint32(7 days) ]; // 生成一个区块的时间 uint256 public secondsPerBlock = 15; // 这里保存所有区块中的猫猫的id Kitty[] kitties; // 猫猫的id到猫猫地址的映射 mapping (uint256 =&gt; address) public kittyIndexToOwner; // 拥有者到拥有者猫猫个数的映射 mapping (address =&gt; uint256) ownershipTokenCount; // 准备出售的猫猫id到拥有者地址的映射 mapping (uint256 =&gt; address) public kittyIndexToApproved; // 准备交配的猫猫id到拥有者地址的映射 mapping (uint256 =&gt; address) public sireAllowedToAddress; // 拍卖合约的地址 SaleClockAuction public saleAuction; // 交配的合约地址 SiringClockAuction public siringAuction; // 从_from拥有者，将id为_tokenId的猫猫转移到_to的新拥有者 // _from为0时，表明初代猫生成 function _transfer(address _from, address _to, uint256 _tokenId) internal { // 增加新拥有者猫猫的数量 ownershipTokenCount[_to]++; // 变更猫猫的新主人为_to kittyIndexToOwner[_tokenId] = _to; // 判断_from地址是否为空 if (_from != address(0)) { // 如果不为空，_from原拥有者的猫猫数量减一 ownershipTokenCount[_from]--; // 删除这个猫猫的出售信息 delete sireAllowedToAddress[_tokenId]; // 删除这个猫猫的交配信息 delete kittyIndexToApproved[_tokenId]; } // 事件记录 Transfer(_from, _to, _tokenId); } // 生成一个新的猫猫 // _matronId、_sireId父母id // _generation 代数 // _genes 基因 // _owner 猫猫拥有者 // 返回新猫猫id function _createKitty( uint256 _matronId, uint256 _sireId, uint256 _generation, uint256 _genes, address _owner ) internal returns (uint) { // 新的猫猫必须包含父母id和代数信息 require(_matronId == uint256(uint32(_matronId))); require(_sireId == uint256(uint32(_sireId))); require(_generation == uint256(uint16(_generation))); // 更换_generation代数信息确定猫猫初始冷却交配时间，最大值为13(13对应7天) uint16 cooldownIndex = uint16(_generation / 2); if (cooldownIndex &gt; 13) { cooldownIndex = 13; } // 生成一个猫猫的基本属性 Kitty memory _kitty = Kitty({ genes: _genes, birthTime: uint64(now), cooldownEndBlock: 0, matronId: uint32(_matronId), sireId: uint32(_sireId), siringWithId: 0, cooldownIndex: cooldownIndex, generation: uint16(_generation) }); // 将新的猫咪放入kitties中 // 猫咪的id等于kitties数组中的顺序编号 uint256 newKittenId = kitties.push(_kitty) - 1; require(newKittenId == uint256(uint32(newKittenId))); // 事件记录 Birth( _owner, newKittenId, uint256(_kitty.matronId), uint256(_kitty.sireId), _kitty.genes ); // 给_owner分配新猫猫newKittenId _transfer(0, _owner, newKittenId); return newKittenId; } // CEO COO CFO 可以修改区块生成时间 function setSecondsPerBlock(uint256 secs) external onlyCLevel { require(secs &lt; cooldowns[0]); secondsPerBlock = secs; } } 0x04 ERC721 在继续向下看之前，我们先来了解一下ERC721的合约。 先抛出代码中的注释： Interface for contracts conforming to ERC-721: Non-Fungible Tokens 符合ERC-721的合约的接口：非同质代币 首先来解释什么叫非同质代币：先来解释什么是同质代币，比如大家熟知的比特币和以太币都是同质代币。每一个不同的比特币和以太币都拥有相同的价值。每一个token的价值平等，你只需要注意自己的token数量是否变化，很少有人注意你钱包里的token都是什么样的地址，转账和消费时是用token1还是用token2，因为他们的价值都是一样的,可以换来同等的等价物。这就是同质代币。 而非同质代币和同质代币相反，每一个token都有不同的基因，不同的基因决定不同的长相，最关键的是不同的基因和长相决定了每一个token拥有不同的价值。假如你有一个非常稀有的猫猫，你一定希望他和普通的猫猫有所区别，他们在拍卖中不会售出相同的价格。所以每一个猫都有自己的价值，这就和比特币和以太币有着本质的区别，所以在同质代币前加了一个非。 所以说迷恋猫就是一个标准的ERC721标准的智能合约。而每个ERC721标准合约需要实现ERC721及ERC165接口，所以源码中的代码如下： contract ERC721 { // Required methods // 返回所有非同质代币的数量 function totalSupply() public view returns (uint256 total); // 返回_owner的非同质代币的数量 function balanceOf(address _owner) public view returns (uint256 balance); // 返回_tokenId非同质代币的拥有者的地址 function ownerOf(uint256 _tokenId) external view returns (address owner); // 将_tokenId非同质代币授权给地址_to的拥有者 // approve()方法的目的是可以授权第三人来代替自己执行交易 function approve(address _to, uint256 _tokenId) external; // 将_tokenId非同质代币转移给地址为_to的拥有者 function transfer(address _to, uint256 _tokenId) external; // 从_from拥有者转移_tokenId非同质代币给_to新的拥有者 // 内部调用transfer方法进行转移 function transferFrom(address _from, address _to, uint256 _tokenId) external; // Events // 两个事件来分别记录转移和授权 event Transfer(address from, address to, uint256 tokenId); event Approval(address owner, address approved, uint256 tokenId); // Optional // 可选实现的接口： // 返回合约的名字 // function name() public view returns (string name); // 返回合约代币的符号 // function symbol() public view returns (string symbol); // 返回_owner所有的非同质代币的id // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds); // 返回非同质代币的元数据 // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl); // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165) // ERC721标准要求必须同时符合ERC165标准 // 方法用来验证这个合约是否实现了特定的接口。 function supportsInterface(bytes4 _interfaceID) external view returns (bool); } 笔者在这里不再展开描述ERC-165协议的具体内容了，感兴趣的童鞋可以通过以下链接学习： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md 0x05 ERC721Metadata 借着我们刚刚了解了ERC721，我们接着看源码中的ERC721Metadata合约。 这个合约中的唯一一个方法getMetadata是用于提供合约的元数据(这里返回的是一个bytes和一个uint)。 输入和返回值分别代表什么含义呢，我们来看源码中441-460行的内容： contract ERC721Metadata { /// 根据_tokenId，返回特定的字符数组和总长度 function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) { // 如果_tokenId为1或2或3，返回不同的字符数组及总长度 if (_tokenId == 1) { buffer[0] = &quot;Hello World! :D&quot;; count = 15; } else if (_tokenId == 2) { buffer[0] = &quot;I would definitely choose a medi&quot;; buffer[1] = &quot;um length string.&quot;; count = 49; } else if (_tokenId == 3) { buffer[0] = &quot;Lorem ipsum dolor sit amet, mi e&quot;; buffer[1] = &quot;st accumsan dapibus augue lorem,&quot;; buffer[2] = &quot; tristique vestibulum id, libero&quot;; buffer[3] = &quot; suscipit varius sapien aliquam.&quot;; count = 128; } } } 0x06 KittyOwnership 这个合约继承自KittyBase和ERC721实现了ERC721接口中定义的方法。定义了整个合约的名称和单位 // KittyOwnership继承自KittyBase和ERC721 contract KittyOwnership is KittyBase, ERC721 { /// @notice Name and symbol of the non fungible token, as defined in ERC721. // 整个智能合约的名字为CryptoKitties string public constant name = &quot;CryptoKitties&quot;; // 猫猫代币的单位为CK string public constant symbol = &quot;CK&quot;; // The contract that will return kitty metadata // 合约的元数据 ERC721Metadata public erc721Metadata; // ERC165接口的加密byte = 0x01ffc9a7 bytes4 constant InterfaceSignature_ERC165 = bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;)); // ERC721接口的加密byte = 0x9a20483d bytes4 constant InterfaceSignature_ERC721 = bytes4(keccak256(&#39;name()&#39;)) ^ bytes4(keccak256(&#39;symbol()&#39;)) ^ bytes4(keccak256(&#39;totalSupply()&#39;)) ^ bytes4(keccak256(&#39;balanceOf(address)&#39;)) ^ bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^ bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^ bytes4(keccak256(&#39;transfer(address,uint256)&#39;)) ^ bytes4(keccak256(&#39;transferFrom(address,address,uint256)&#39;)) ^ bytes4(keccak256(&#39;tokensOfOwner(address)&#39;)) ^ bytes4(keccak256(&#39;tokenMetadata(uint256,string)&#39;)); // 验证是否实现了ERC721和ERC165 // function supportsInterface(bytes4 _interfaceID) external view returns (bool) { return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721)); } /// @dev Set the address of the sibling contract that tracks metadata. /// CEO only. function setMetadataAddress(address _contractAddress) public onlyCEO { erc721Metadata = ERC721Metadata(_contractAddress); } // 判断_tokenId的猫猫是否归_claimant地址用户所有 function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) { return kittyIndexToOwner[_tokenId] == _claimant; } // 判断_tokenId的猫猫是否可以被_claimant的地址用户进行转让 function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) { return kittyIndexToApproved[_tokenId] == _claimant; } // 允许_tokenId的猫猫可以被_approved的地址用户执行transferFrom()方法 function _approve(uint256 _tokenId, address _approved) internal { kittyIndexToApproved[_tokenId] = _approved; } // 返回_ownerd拥有的猫猫token个数 function balanceOf(address _owner) public view returns (uint256 count) { return ownershipTokenCount[_owner]; } // 将_tokenId的猫猫转移给_to地址拥有者 // 当系统没有处于暂停状态时 function transfer( address _to, uint256 _tokenId ) external whenNotPaused { // 检查一下_to的地址是否合法 require(_to != address(0)); // 不允许将猫猫转移给本合约地址 require(_to != address(this)); // 不予许将猫猫转移给拍卖合约地址 require(_to != address(saleAuction)); // 不允许将猫猫转移给交配合约地址 require(_to != address(siringAuction)); // 你只能发送_tokenId为你你自己拥有的猫猫 require(_owns(msg.sender, _tokenId)); // 事件记录 _transfer(msg.sender, _to, _tokenId); } // 授权其他人将_tokenId为自己拥有的猫猫调用transferFrom()转移给地址为_to的拥有者 // 当系统处于非暂停状态 function approve( address _to, uint256 _tokenId ) external whenNotPaused { // 只有猫猫的拥有者可以授权其他人 require(_owns(msg.sender, _tokenId)); // 修改_approve()方法修改kittyIndexToApproved[_tokenId] _approve(_tokenId, _to); // 事件记录 Approval(msg.sender, _to, _tokenId); } // 将_from用户的猫猫_tokenId转移给_to用户 // 当系统处于非暂停状态 function transferFrom( address _from, address _to, uint256 _tokenId ) external whenNotPaused { // 检查一下_to的地址是否合法 require(_to != address(0)); // 不允许将猫猫转移给本合约地址 require(_to != address(this)); // 检查msg.sender是否获得了授权转移_tokenId的毛毛啊 require(_approvedFor(msg.sender, _tokenId)); // 检查_from是否拥有_tokenId猫猫 require(_owns(_from, _tokenId)); // 调用_transfer()进行转移 _transfer(_from, _to, _tokenId); } // 返回目前所有的猫猫个数 function totalSupply() public view returns (uint) { return kitties.length - 1; } // 返回_tokenId猫猫的拥有者的地址 function ownerOf(uint256 _tokenId) external view returns (address owner) { owner = kittyIndexToOwner[_tokenId]; require(owner != address(0)); } // 返回_owner拥有的所有猫猫的id数组 function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) { // 获得_owner拥有的猫猫数量 uint256 tokenCount = balanceOf(_owner); // 判断数量是否为0 if (tokenCount == 0) { // 如果该_owner没有猫猫，返回空数组 return new uint256[](0); } else { // 如果该_owner有 // 声明并初始化一个返回值result，长度为tokenCount uint256[] memory result = new uint256[](tokenCount); // 当前所有的猫猫数量 uint256 totalCats = totalSupply(); // 循环的初始值 uint256 resultIndex = 0; // 所有的猫都有ID从1增加到totalCats uint256 catId; // 从1开始循环遍历所有的totalCats for (catId = 1; catId &lt;= totalCats; catId++) { // 判断当前catId的拥有者是否为_owner if (kittyIndexToOwner[catId] == _owner) { // 如果是，将catId放入result数组resultIndex位置 result[resultIndex] = catId; // resultIndex加1 resultIndex++; } } // 返回result return result; } } // 拷贝方法 function _memcpy(uint _dest, uint _src, uint _len) private view { // Copy word-length chunks while possible for(; _len &gt;= 32; _len -= 32) { assembly { mstore(_dest, mload(_src)) } _dest += 32; _src += 32; } // Copy remaining bytes uint256 mask = 256 ** (32 - _len) - 1; assembly { let srcpart := and(mload(_src), not(mask)) let destpart := and(mload(_dest), mask) mstore(_dest, or(destpart, srcpart)) } } // 将_rawBytes中长度为_stringLength转成string并返回 function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) { var outputString = new string(_stringLength); uint256 outputPtr; uint256 bytesPtr; assembly { outputPtr := add(outputString, 32) bytesPtr := _rawBytes } _memcpy(outputPtr, bytesPtr, _stringLength); return outputString; } // 返回指向该元数据的元数据包的URI function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) { require(erc721Metadata != address(0)); bytes32[4] memory buffer; uint256 count; (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport); return _toString(buffer, count); } } 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"书接上文 CryptoKitties中包含的contract： contract Ownable contract ERC721 contract GeneScienceInterface contract KittyAccessControl contract KittyBase is KittyAccessControl contract ERC721Metadata contract KittyOwnership is KittyBase, ERC721 contract KittyBreeding is KittyOwnership contract ClockAuctionBase contract Pausable is Ownable contract ClockAuction is Pausable, ClockAuctionBase contract SaleClockAuction is ClockAuction contract KittyAuction is KittyBreeding contract KittyMinting is KittyAuction contract KittyCore is KittyMinting 在上篇文章中，我们解析了Ownable和KittyAccessControl两个合约的代码。自感进度缓慢，今天利用一天的时间，尽可能多的来码字。各位看官瞧来： 0x03 KittyBase 这个合约中主要决定了我们猫猫的属性值，决定了每个猫猫都唯一的基因值，出生日期，父母的id，以及目前猫猫的代数等信息。这些属性值保存在struct Kitty里。 我们一点一点来分析这个合约的代码，先看其中220-280行的代码，去掉原有的注释，加上我们的注释后，代码如下： contract KittyBase is KittyAccessControl { // 监听出生的事件： // 当一个猫猫出生时，这个事件将会记录这个猫猫的拥有者owner，猫猫的编号kittyId // 父母的编号matronId和sireId，还有这个猫的基因genes event Birth(address owner, uint256 kittyId, uint256 matronId, uint256 sireId, uint256 genes); // 监听猫猫转移所有权的事件： // 从from拥有者，转移到to的新拥有者 // 转移猫猫的编号tokenId event Transfer(address from, address to, uint256 tokenId); // 猫猫的基础数据 struct Kitty { uint256 genes; // 猫猫的基因 uint64 birthTime; // 猫猫出生的日期 uint64 cooldownEndBlock;// 猫猫可以再次进行繁殖的最小区块。用于已经怀孕的猫猫 uint32 matronId; // 猫妈妈的ID uint32 sireId; // 猫爸爸的ID uint32 siringWithId; // 怀孕繁殖期，当前交配的猫猫ID。 uint16 cooldownIndex; // 繁殖冷却时间 uint16 generation; // 猫猫的代数 } ... } genes 对于一个猫猫最重要的就是他的基因，一个猫猫的基因由父母的基因决定生成。生成的算法在合约GeneScienceInterface中的mixGenes方法，基因决定了猫猫的各项属性，但是具体决定的方法并没有开源，所以我们不得而知。 birthTime 猫猫的出生日期不言而喻，在_createKitty时使用uint64(now)确定为当前时间。 cooldownEndBlock 一个刚出生猫猫的cooldownEndBlock值为0。当一个猫猫要进行生产时，需要下先调用KittyBreeding合约中_isReadyToBreed方法，这个方法会判断这个的cooldownEndBlock是否小于等于当前的区块编号。cooldownEndBlock是判断一个猫是否能够生产的其中一个判断条件，也是一个必要条件。一个怀孕的猫猫必须等待一段时间才可以进行生产，而等待时间的标准不是一个具体的时间戳，而是一个区块的编号，只有当前区块的编号值大于等于cooldownEndBlock的值的时候，这个准猫妈妈才可以进行生产。 matronId sireId 对于初代猫猫的父母编号都是0。 siringWithId 如果一个猫没有怀孕，那么这个值将会是0。如果一个猫怀孕了，那么这个值就不是0。所以通过siringWithId可以判断一个猫是否已经欢迎。而当猫宝宝出生时，可以通过这个编号id来获取猫爸爸的基因，获取到的基因和母亲的组合生成小猫的基因。 cooldownIndex 为了避免一个用户频繁的使用同一个猫进行繁殖，为每一个猫都加入了一个繁殖的冷却期。在这个冷却过程中，猫猫不可以和其他猫猫进行交往配对。初代猫的冷却期最短为0，随着猫猫的代数增加，冷却期的初始值等于_generation / 2。同时随着猫猫的生育次数的增加，这个冷却期的时间也会不断递增。 generation 初代猫的代数值为0，之后生育的猫猫的代数等于max((母亲的代数， 父亲的代数)+1) 上面我们分析了这个合约中猫猫的属性结构体，再接着看后面的代码280-435行： contract KittyBase is KittyAccessControl { ... // cooldownIndex对应的冷却时间 // 随着猫猫的代数和生育次数的增加，猫猫进行交配的冷却时间也会逐渐增加。 // 最大冷却时间不会超过7天。 uint32[14] public cooldowns = [ uint32(1 minutes), uint32(2 minutes), uint32(5 minutes), uint32(10 minutes), uint32(30 minutes), uint32(1 hours), uint32(2 hours), uint32(4 hours), uint32(8 hours), uint32(16 hours), uint32(1 days), uint32(2 days), uint32(4 days), uint32(7 days) ]; // 生成一个区块的时间 uint256 public secondsPerBlock = 15; // 这里保存所有区块中的猫猫的id Kitty[] kitties; // 猫猫的id到猫猫地址的映射 mapping (uint256 =&gt; address) public kittyIndexToOwner; // 拥有者到拥有者猫猫个数的映射 mapping (address =&gt; uint256) ownershipTokenCount; // 准备出售的猫猫id到拥有者地址的映射 mapping (uint256 =&gt; address) public kittyIndexToApproved; // 准备交配的猫猫id到拥有者地址的映射 mapping (uint256 =&gt; address) public sireAllowedToAddress; // 拍卖合约的地址 SaleClockAuction public saleAuction; // 交配的合约地址 SiringClockAuction public siringAuction; // 从_from拥有者，将id为_tokenId的猫猫转移到_to的新拥有者 // _from为0时，表明初代猫生成 function _transfer(address _from, address _to, uint256 _tokenId) internal { // 增加新拥有者猫猫的数量 ownershipTokenCount[_to]++; // 变更猫猫的新主人为_to kittyIndexToOwner[_tokenId] = _to; // 判断_from地址是否为空 if (_from != address(0)) { // 如果不为空，_from原拥有者的猫猫数量减一 ownershipTokenCount[_from]--; // 删除这个猫猫的出售信息 delete sireAllowedToAddress[_tokenId]; // 删除这个猫猫的交配信息 delete kittyIndexToApproved[_tokenId]; } // 事件记录 Transfer(_from, _to, _tokenId); } // 生成一个新的猫猫 // _matronId、_sireId父母id // _generation 代数 // _genes 基因 // _owner 猫猫拥有者 // 返回新猫猫id function _createKitty( uint256 _matronId, uint256 _sireId, uint256 _generation, uint256 _genes, address _owner ) internal returns (uint) { // 新的猫猫必须包含父母id和代数信息 require(_matronId == uint256(uint32(_matronId))); require(_sireId == uint256(uint32(_sireId))); require(_generation == uint256(uint16(_generation))); // 更换_generation代数信息确定猫猫初始冷却交配时间，最大值为13(13对应7天) uint16 cooldownIndex = uint16(_generation / 2); if (cooldownIndex &gt; 13) { cooldownIndex = 13; } // 生成一个猫猫的基本属性 Kitty memory _kitty = Kitty({ genes: _genes, birthTime: uint64(now), cooldownEndBlock: 0, matronId: uint32(_matronId), sireId: uint32(_sireId), siringWithId: 0, cooldownIndex: cooldownIndex, generation: uint16(_generation) }); // 将新的猫咪放入kitties中 // 猫咪的id等于kitties数组中的顺序编号 uint256 newKittenId = kitties.push(_kitty) - 1; require(newKittenId == uint256(uint32(newKittenId))); // 事件记录 Birth( _owner, newKittenId, uint256(_kitty.matronId), uint256(_kitty.sireId), _kitty.genes ); // 给_owner分配新猫猫newKittenId _transfer(0, _owner, newKittenId); return newKittenId; } // CEO COO CFO 可以修改区块生成时间 function setSecondsPerBlock(uint256 secs) external onlyCLevel { require(secs &lt; cooldowns[0]); secondsPerBlock = secs; } } 0x04 ERC721 在继续向下看之前，我们先来了解一下ERC721的合约。 先抛出代码中的注释： Interface for contracts conforming to ERC-721: Non-Fungible Tokens 符合ERC-721的合约的接口：非同质代币 首先来解释什么叫非同质代币：先来解释什么是同质代币，比如大家熟知的比特币和以太币都是同质代币。每一个不同的比特币和以太币都拥有相同的价值。每一个token的价值平等，你只需要注意自己的token数量是否变化，很少有人注意你钱包里的token都是什么样的地址，转账和消费时是用token1还是用token2，因为他们的价值都是一样的,可以换来同等的等价物。这就是同质代币。 而非同质代币和同质代币相反，每一个token都有不同的基因，不同的基因决定不同的长相，最关键的是不同的基因和长相决定了每一个token拥有不同的价值。假如你有一个非常稀有的猫猫，你一定希望他和普通的猫猫有所区别，他们在拍卖中不会售出相同的价格。所以每一个猫都有自己的价值，这就和比特币和以太币有着本质的区别，所以在同质代币前加了一个非。 所以说迷恋猫就是一个标准的ERC721标准的智能合约。而每个ERC721标准合约需要实现ERC721及ERC165接口，所以源码中的代码如下： contract ERC721 { // Required methods // 返回所有非同质代币的数量 function totalSupply() public view returns (uint256 total); // 返回_owner的非同质代币的数量 function balanceOf(address _owner) public view returns (uint256 balance); // 返回_tokenId非同质代币的拥有者的地址 function ownerOf(uint256 _tokenId) external view returns (address owner); // 将_tokenId非同质代币授权给地址_to的拥有者 // approve()方法的目的是可以授权第三人来代替自己执行交易 function approve(address _to, uint256 _tokenId) external; // 将_tokenId非同质代币转移给地址为_to的拥有者 function transfer(address _to, uint256 _tokenId) external; // 从_from拥有者转移_tokenId非同质代币给_to新的拥有者 // 内部调用transfer方法进行转移 function transferFrom(address _from, address _to, uint256 _tokenId) external; // Events // 两个事件来分别记录转移和授权 event Transfer(address from, address to, uint256 tokenId); event Approval(address owner, address approved, uint256 tokenId); // Optional // 可选实现的接口： // 返回合约的名字 // function name() public view returns (string name); // 返回合约代币的符号 // function symbol() public view returns (string symbol); // 返回_owner所有的非同质代币的id // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds); // 返回非同质代币的元数据 // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl); // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165) // ERC721标准要求必须同时符合ERC165标准 // 方法用来验证这个合约是否实现了特定的接口。 function supportsInterface(bytes4 _interfaceID) external view returns (bool); } 笔者在这里不再展开描述ERC-165协议的具体内容了，感兴趣的童鞋可以通过以下链接学习： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md 0x05 ERC721Metadata 借着我们刚刚了解了ERC721，我们接着看源码中的ERC721Metadata合约。 这个合约中的唯一一个方法getMetadata是用于提供合约的元数据(这里返回的是一个bytes和一个uint)。 输入和返回值分别代表什么含义呢，我们来看源码中441-460行的内容： contract ERC721Metadata { /// 根据_tokenId，返回特定的字符数组和总长度 function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) { // 如果_tokenId为1或2或3，返回不同的字符数组及总长度 if (_tokenId == 1) { buffer[0] = &quot;Hello World! :D&quot;; count = 15; } else if (_tokenId == 2) { buffer[0] = &quot;I would definitely choose a medi&quot;; buffer[1] = &quot;um length string.&quot;; count = 49; } else if (_tokenId == 3) { buffer[0] = &quot;Lorem ipsum dolor sit amet, mi e&quot;; buffer[1] = &quot;st accumsan dapibus augue lorem,&quot;; buffer[2] = &quot; tristique vestibulum id, libero&quot;; buffer[3] = &quot; suscipit varius sapien aliquam.&quot;; count = 128; } } } 0x06 KittyOwnership 这个合约继承自KittyBase和ERC721实现了ERC721接口中定义的方法。定义了整个合约的名称和单位 // KittyOwnership继承自KittyBase和ERC721 contract KittyOwnership is KittyBase, ERC721 { /// @notice Name and symbol of the non fungible token, as defined in ERC721. // 整个智能合约的名字为CryptoKitties string public constant name = &quot;CryptoKitties&quot;; // 猫猫代币的单位为CK string public constant symbol = &quot;CK&quot;; // The contract that will return kitty metadata // 合约的元数据 ERC721Metadata public erc721Metadata; // ERC165接口的加密byte = 0x01ffc9a7 bytes4 constant InterfaceSignature_ERC165 = bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;)); // ERC721接口的加密byte = 0x9a20483d bytes4 constant InterfaceSignature_ERC721 = bytes4(keccak256(&#39;name()&#39;)) ^ bytes4(keccak256(&#39;symbol()&#39;)) ^ bytes4(keccak256(&#39;totalSupply()&#39;)) ^ bytes4(keccak256(&#39;balanceOf(address)&#39;)) ^ bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^ bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^ bytes4(keccak256(&#39;transfer(address,uint256)&#39;)) ^ bytes4(keccak256(&#39;transferFrom(address,address,uint256)&#39;)) ^ bytes4(keccak256(&#39;tokensOfOwner(address)&#39;)) ^ bytes4(keccak256(&#39;tokenMetadata(uint256,string)&#39;)); // 验证是否实现了ERC721和ERC165 // function supportsInterface(bytes4 _interfaceID) external view returns (bool) { return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721)); } /// @dev Set the address of the sibling contract that tracks metadata. /// CEO only. function setMetadataAddress(address _contractAddress) public onlyCEO { erc721Metadata = ERC721Metadata(_contractAddress); } // 判断_tokenId的猫猫是否归_claimant地址用户所有 function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) { return kittyIndexToOwner[_tokenId] == _claimant; } // 判断_tokenId的猫猫是否可以被_claimant的地址用户进行转让 function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) { return kittyIndexToApproved[_tokenId] == _claimant; } // 允许_tokenId的猫猫可以被_approved的地址用户执行transferFrom()方法 function _approve(uint256 _tokenId, address _approved) internal { kittyIndexToApproved[_tokenId] = _approved; } // 返回_ownerd拥有的猫猫token个数 function balanceOf(address _owner) public view returns (uint256 count) { return ownershipTokenCount[_owner]; } // 将_tokenId的猫猫转移给_to地址拥有者 // 当系统没有处于暂停状态时 function transfer( address _to, uint256 _tokenId ) external whenNotPaused { // 检查一下_to的地址是否合法 require(_to != address(0)); // 不允许将猫猫转移给本合约地址 require(_to != address(this)); // 不予许将猫猫转移给拍卖合约地址 require(_to != address(saleAuction)); // 不允许将猫猫转移给交配合约地址 require(_to != address(siringAuction)); // 你只能发送_tokenId为你你自己拥有的猫猫 require(_owns(msg.sender, _tokenId)); // 事件记录 _transfer(msg.sender, _to, _tokenId); } // 授权其他人将_tokenId为自己拥有的猫猫调用transferFrom()转移给地址为_to的拥有者 // 当系统处于非暂停状态 function approve( address _to, uint256 _tokenId ) external whenNotPaused { // 只有猫猫的拥有者可以授权其他人 require(_owns(msg.sender, _tokenId)); // 修改_approve()方法修改kittyIndexToApproved[_tokenId] _approve(_tokenId, _to); // 事件记录 Approval(msg.sender, _to, _tokenId); } // 将_from用户的猫猫_tokenId转移给_to用户 // 当系统处于非暂停状态 function transferFrom( address _from, address _to, uint256 _tokenId ) external whenNotPaused { // 检查一下_to的地址是否合法 require(_to != address(0)); // 不允许将猫猫转移给本合约地址 require(_to != address(this)); // 检查msg.sender是否获得了授权转移_tokenId的毛毛啊 require(_approvedFor(msg.sender, _tokenId)); // 检查_from是否拥有_tokenId猫猫 require(_owns(_from, _tokenId)); // 调用_transfer()进行转移 _transfer(_from, _to, _tokenId); } // 返回目前所有的猫猫个数 function totalSupply() public view returns (uint) { return kitties.length - 1; } // 返回_tokenId猫猫的拥有者的地址 function ownerOf(uint256 _tokenId) external view returns (address owner) { owner = kittyIndexToOwner[_tokenId]; require(owner != address(0)); } // 返回_owner拥有的所有猫猫的id数组 function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) { // 获得_owner拥有的猫猫数量 uint256 tokenCount = balanceOf(_owner); // 判断数量是否为0 if (tokenCount == 0) { // 如果该_owner没有猫猫，返回空数组 return new uint256[](0); } else { // 如果该_owner有 // 声明并初始化一个返回值result，长度为tokenCount uint256[] memory result = new uint256[](tokenCount); // 当前所有的猫猫数量 uint256 totalCats = totalSupply(); // 循环的初始值 uint256 resultIndex = 0; // 所有的猫都有ID从1增加到totalCats uint256 catId; // 从1开始循环遍历所有的totalCats for (catId = 1; catId &lt;= totalCats; catId++) { // 判断当前catId的拥有者是否为_owner if (kittyIndexToOwner[catId] == _owner) { // 如果是，将catId放入result数组resultIndex位置 result[resultIndex] = catId; // resultIndex加1 resultIndex++; } } // 返回result return result; } } // 拷贝方法 function _memcpy(uint _dest, uint _src, uint _len) private view { // Copy word-length chunks while possible for(; _len &gt;= 32; _len -= 32) { assembly { mstore(_dest, mload(_src)) } _dest += 32; _src += 32; } // Copy remaining bytes uint256 mask = 256 ** (32 - _len) - 1; assembly { let srcpart := and(mload(_src), not(mask)) let destpart := and(mload(_dest), mask) mstore(_dest, or(destpart, srcpart)) } } // 将_rawBytes中长度为_stringLength转成string并返回 function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) { var outputString = new string(_stringLength); uint256 outputPtr; uint256 bytesPtr; assembly { outputPtr := add(outputString, 32) bytesPtr := _rawBytes } _memcpy(outputPtr, bytesPtr, _stringLength); return outputString; } // 返回指向该元数据的元数据包的URI function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) { require(erc721Metadata != address(0)); bytes32[4] memory buffer; uint256 count; (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport); return _toString(buffer, count); } } 阅读更多","@type":"BlogPosting","url":"/2018/03/28/9089365078eec56442d1ea4ab06765db.html","headline":"一天一步解读迷恋猫CryptoKitties源码（二）","dateModified":"2018-03-28T00:00:00+08:00","datePublished":"2018-03-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/03/28/9089365078eec56442d1ea4ab06765db.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>一天一步解读迷恋猫CryptoKitties源码（二）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="书接上文">书接上文</h1> 
  <p>CryptoKitties中包含的contract：</p> 
  <pre class="prettyprint"><code class=" hljs cs">contract Ownable
contract ERC721
contract GeneScienceInterface
contract KittyAccessControl
contract KittyBase <span class="hljs-keyword">is</span> KittyAccessControl
contract ERC721Metadata
contract KittyOwnership <span class="hljs-keyword">is</span> KittyBase, ERC721
contract KittyBreeding <span class="hljs-keyword">is</span> KittyOwnership
contract ClockAuctionBase
contract Pausable <span class="hljs-keyword">is</span> Ownable
contract ClockAuction <span class="hljs-keyword">is</span> Pausable, ClockAuctionBase
contract SaleClockAuction <span class="hljs-keyword">is</span> ClockAuction
contract KittyAuction <span class="hljs-keyword">is</span> KittyBreeding
contract KittyMinting <span class="hljs-keyword">is</span> KittyAuction
contract KittyCore <span class="hljs-keyword">is</span> KittyMinting</code></pre> 
  <p>在上篇文章中，我们解析了<code>Ownable</code>和<code>KittyAccessControl</code>两个合约的代码。自感进度缓慢，今天利用一天的时间，尽可能多的来码字。各位看官瞧来：</p> 
  <h1 id="0x03-kittybase">0x03 KittyBase</h1> 
  <p>这个合约中主要决定了我们猫猫的属性值，决定了每个猫猫都唯一的基因值，出生日期，父母的id，以及目前猫猫的代数等信息。这些属性值保存在<code>struct Kitty</code>里。 <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018032809591072?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2MDk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br> 我们一点一点来分析这个合约的代码，先看其中220-280行的代码，去掉原有的注释，加上我们的注释后，代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs vala">contract KittyBase is KittyAccessControl {
    <span class="hljs-comment">// 监听出生的事件：</span>
    <span class="hljs-comment">// 当一个猫猫出生时，这个事件将会记录这个猫猫的拥有者owner，猫猫的编号kittyId</span>
    <span class="hljs-comment">// 父母的编号matronId和sireId，还有这个猫的基因genes</span>
    event Birth(address owner, uint256 kittyId, uint256 matronId, uint256 sireId, uint256 genes);

    <span class="hljs-comment">// 监听猫猫转移所有权的事件：</span>
    <span class="hljs-comment">// 从from拥有者，转移到to的新拥有者</span>
    <span class="hljs-comment">// 转移猫猫的编号tokenId</span>
    event Transfer(address from, address to, uint256 tokenId);

    <span class="hljs-comment">// 猫猫的基础数据</span>
    <span class="hljs-keyword">struct</span> Kitty {
        uint256 genes;          <span class="hljs-comment">// 猫猫的基因</span>
        <span class="hljs-keyword">uint64</span> birthTime;       <span class="hljs-comment">// 猫猫出生的日期</span>
        <span class="hljs-keyword">uint64</span> cooldownEndBlock;<span class="hljs-comment">// 猫猫可以再次进行繁殖的最小区块。用于已经怀孕的猫猫</span>
        <span class="hljs-keyword">uint32</span> matronId;        <span class="hljs-comment">// 猫妈妈的ID</span>
        <span class="hljs-keyword">uint32</span> sireId;          <span class="hljs-comment">// 猫爸爸的ID</span>
        <span class="hljs-keyword">uint32</span> siringWithId;    <span class="hljs-comment">// 怀孕繁殖期，当前交配的猫猫ID。</span>
        <span class="hljs-keyword">uint16</span> cooldownIndex;   <span class="hljs-comment">// 繁殖冷却时间</span>
        <span class="hljs-keyword">uint16</span> generation;      <span class="hljs-comment">// 猫猫的代数</span>
    }
    ...
}</code></pre> 
  <ul> 
   <li><code>genes</code> <br> 对于一个猫猫最重要的就是他的基因，一个猫猫的基因由父母的基因决定生成。生成的算法在合约<code>GeneScienceInterface</code>中的<code>mixGenes</code>方法，基因决定了猫猫的各项属性，但是具体决定的方法并没有开源，所以我们不得而知。</li> 
   <li><code>birthTime</code> <br> 猫猫的出生日期不言而喻，在<code>_createKitty</code>时使用<code>uint64(now)</code>确定为当前时间。</li> 
   <li><code>cooldownEndBlock</code> <br> 一个刚出生猫猫的<code>cooldownEndBlock</code>值为0。当一个猫猫要进行生产时，需要下先调用<code>KittyBreeding</code>合约中<code>_isReadyToBreed</code>方法，这个方法会判断这个的<code>cooldownEndBlock</code>是否小于等于当前的区块编号。<code>cooldownEndBlock</code>是判断一个猫是否能够生产的其中一个判断条件，也是一个必要条件。一个怀孕的猫猫必须等待一段时间才可以进行生产，而等待时间的标准不是一个具体的时间戳，而是一个区块的编号，只有当前区块的编号值大于等于<code>cooldownEndBlock</code>的值的时候，这个准猫妈妈才可以进行生产。</li> 
   <li><code>matronId</code> </li> 
   <li><code>sireId</code> <br> 对于初代猫猫的父母编号都是0。</li> 
   <li><code>siringWithId</code> <br> 如果一个猫没有怀孕，那么这个值将会是0。如果一个猫怀孕了，那么这个值就不是0。所以通过<code>siringWithId</code>可以判断一个猫是否已经欢迎。而当猫宝宝出生时，可以通过这个编号id来获取猫爸爸的基因，获取到的基因和母亲的组合生成小猫的基因。</li> 
   <li><code>cooldownIndex</code> <br> 为了避免一个用户频繁的使用同一个猫进行繁殖，为每一个猫都加入了一个繁殖的冷却期。在这个冷却过程中，猫猫不可以和其他猫猫进行交往配对。初代猫的冷却期最短为0，随着猫猫的代数增加，冷却期的初始值等于<code>_generation</code> / 2。同时随着猫猫的生育次数的增加，这个冷却期的时间也会不断递增。</li> 
   <li><code>generation</code> <br> 初代猫的代数值为0，之后生育的猫猫的代数等于max((母亲的代数， 父亲的代数)+1)</li> 
  </ul> 
  <p>上面我们分析了这个合约中猫猫的属性结构体，再接着看后面的代码280-435行：</p> 
  <pre class="prettyprint"><code class=" hljs vala">contract KittyBase is KittyAccessControl {

    ...

    <span class="hljs-comment">// cooldownIndex对应的冷却时间</span>
    <span class="hljs-comment">// 随着猫猫的代数和生育次数的增加，猫猫进行交配的冷却时间也会逐渐增加。</span>
    <span class="hljs-comment">// 最大冷却时间不会超过7天。</span>
    <span class="hljs-keyword">uint32</span>[<span class="hljs-number">14</span>] <span class="hljs-keyword">public</span> cooldowns = [
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">1</span> minutes),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">2</span> minutes),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">5</span> minutes),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">10</span> minutes),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">30</span> minutes),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">1</span> hours),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">2</span> hours),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">4</span> hours),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">8</span> hours),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">16</span> hours),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">1</span> days),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">2</span> days),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">4</span> days),
        <span class="hljs-keyword">uint32</span>(<span class="hljs-number">7</span> days)
    ];

    <span class="hljs-comment">// 生成一个区块的时间</span>
    uint256 <span class="hljs-keyword">public</span> secondsPerBlock = <span class="hljs-number">15</span>;

    <span class="hljs-comment">// 这里保存所有区块中的猫猫的id</span>
    Kitty[] kitties;

    <span class="hljs-comment">// 猫猫的id到猫猫地址的映射</span>
    mapping (uint256 =&gt; address) <span class="hljs-keyword">public</span> kittyIndexToOwner;

    <span class="hljs-comment">// 拥有者到拥有者猫猫个数的映射</span>
    mapping (address =&gt; uint256) ownershipTokenCount;

    <span class="hljs-comment">// 准备出售的猫猫id到拥有者地址的映射</span>
    mapping (uint256 =&gt; address) <span class="hljs-keyword">public</span> kittyIndexToApproved;

    <span class="hljs-comment">// 准备交配的猫猫id到拥有者地址的映射</span>
    mapping (uint256 =&gt; address) <span class="hljs-keyword">public</span> sireAllowedToAddress;

    <span class="hljs-comment">// 拍卖合约的地址</span>
    SaleClockAuction <span class="hljs-keyword">public</span> saleAuction;

    <span class="hljs-comment">// 交配的合约地址</span>
    SiringClockAuction <span class="hljs-keyword">public</span> siringAuction;

    <span class="hljs-comment">// 从_from拥有者，将id为_tokenId的猫猫转移到_to的新拥有者</span>
    <span class="hljs-comment">// _from为0时，表明初代猫生成</span>
    function _transfer(address _from, address _to, uint256 _tokenId) <span class="hljs-keyword">internal</span> {
        <span class="hljs-comment">// 增加新拥有者猫猫的数量</span>
        ownershipTokenCount[_to]++;
        <span class="hljs-comment">// 变更猫猫的新主人为_to</span>
        kittyIndexToOwner[_tokenId] = _to;
        <span class="hljs-comment">// 判断_from地址是否为空</span>
        if (_from != address(<span class="hljs-number">0</span>)) {    
            <span class="hljs-comment">// 如果不为空，_from原拥有者的猫猫数量减一</span>
            ownershipTokenCount[_from]--;
            <span class="hljs-comment">// 删除这个猫猫的出售信息</span>
            delete sireAllowedToAddress[_tokenId];
            <span class="hljs-comment">// 删除这个猫猫的交配信息</span>
            delete kittyIndexToApproved[_tokenId];
        }
        <span class="hljs-comment">// 事件记录</span>
        Transfer(_from, _to, _tokenId);
    }

    <span class="hljs-comment">// 生成一个新的猫猫</span>
    <span class="hljs-comment">// _matronId、_sireId父母id</span>
    <span class="hljs-comment">// _generation 代数</span>
    <span class="hljs-comment">// _genes 基因</span>
    <span class="hljs-comment">// _owner 猫猫拥有者</span>
    <span class="hljs-comment">// 返回新猫猫id</span>
    function _createKitty(
        uint256 _matronId,
        uint256 _sireId,
        uint256 _generation,
        uint256 _genes,
        address _owner
    )
        <span class="hljs-keyword">internal</span>
        returns (<span class="hljs-keyword">uint</span>) 
    {
        <span class="hljs-comment">// 新的猫猫必须包含父母id和代数信息</span>
        require(_matronId == uint256(<span class="hljs-keyword">uint32</span>(_matronId)));
        require(_sireId == uint256(<span class="hljs-keyword">uint32</span>(_sireId)));
        require(_generation == uint256(<span class="hljs-keyword">uint16</span>(_generation)));

        <span class="hljs-comment">// 更换_generation代数信息确定猫猫初始冷却交配时间，最大值为13(13对应7天)</span>
        <span class="hljs-keyword">uint16</span> cooldownIndex = <span class="hljs-keyword">uint16</span>(_generation / <span class="hljs-number">2</span>);
        if (cooldownIndex &gt; <span class="hljs-number">13</span>) {
            cooldownIndex = <span class="hljs-number">13</span>;
        }

        <span class="hljs-comment">// 生成一个猫猫的基本属性</span>
        Kitty memory _kitty = Kitty({
            genes: _genes,
            birthTime: <span class="hljs-keyword">uint64</span>(now),
            cooldownEndBlock: <span class="hljs-number">0</span>,
            matronId: <span class="hljs-keyword">uint32</span>(_matronId),
            sireId: <span class="hljs-keyword">uint32</span>(_sireId),
            siringWithId: <span class="hljs-number">0</span>,
            cooldownIndex: cooldownIndex,
            generation: <span class="hljs-keyword">uint16</span>(_generation)
        });
        <span class="hljs-comment">// 将新的猫咪放入kitties中</span>
        <span class="hljs-comment">// 猫咪的id等于kitties数组中的顺序编号</span>
        uint256 newKittenId = kitties.push(_kitty) - <span class="hljs-number">1</span>;

        require(newKittenId == uint256(<span class="hljs-keyword">uint32</span>(newKittenId)));

        <span class="hljs-comment">// 事件记录</span>
        Birth(
            _owner,
            newKittenId,
            uint256(_kitty.matronId),
            uint256(_kitty.sireId),
            _kitty.genes
        );

        <span class="hljs-comment">// 给_owner分配新猫猫newKittenId</span>
        _transfer(<span class="hljs-number">0</span>, _owner, newKittenId);

        <span class="hljs-keyword">return</span> newKittenId;
    }

    <span class="hljs-comment">// CEO COO CFO 可以修改区块生成时间</span>
    function setSecondsPerBlock(uint256 secs) external onlyCLevel {
        require(secs &lt; cooldowns[<span class="hljs-number">0</span>]);
        secondsPerBlock = secs;
    }
}</code></pre> 
  <h1 id="0x04-erc721">0x04 ERC721</h1> 
  <p>在继续向下看之前，我们先来了解一下ERC721的合约。 <br> 先抛出代码中的注释：</p> 
  <blockquote> 
   <p>Interface for contracts conforming to ERC-721: Non-Fungible Tokens</p> 
   <p><strong>符合ERC-721的合约的接口：非同质代币</strong></p> 
  </blockquote> 
  <p>首先来解释什么叫非同质代币：先来解释什么是同质代币，比如大家熟知的比特币和以太币都是同质代币。每一个不同的比特币和以太币都拥有相同的价值。每一个token的价值平等，你只需要注意自己的token数量是否变化，很少有人注意你钱包里的token都是什么样的地址，转账和消费时是用token1还是用token2，因为他们的价值都是一样的,可以换来同等的等价物。这就是同质代币。 <br> 而非同质代币和同质代币相反，每一个token都有不同的基因，不同的基因决定不同的长相，最关键的是不同的基因和长相决定了每一个token拥有不同的价值。假如你有一个非常稀有的猫猫，你一定希望他和普通的猫猫有所区别，他们在拍卖中不会售出相同的价格。所以每一个猫都有自己的价值，这就和比特币和以太币有着本质的区别，所以在同质代币前加了一个非。 <br> 所以说迷恋猫就是一个标准的ERC721标准的智能合约。而每个ERC721标准合约需要实现ERC721及ERC165接口，所以源码中的代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs php">contract ERC721 {
    <span class="hljs-comment">// Required methods</span>
    <span class="hljs-comment">// 返回所有非同质代币的数量</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">totalSupply</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256 total)</span>;</span>
    <span class="hljs-comment">// 返回_owner的非同质代币的数量</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">balanceOf</span><span class="hljs-params">(address _owner)</span> <span class="hljs-title">public</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256 balance)</span>;</span>
    <span class="hljs-comment">// 返回_tokenId非同质代币的拥有者的地址</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownerOf</span><span class="hljs-params">(uint256 _tokenId)</span> <span class="hljs-title">external</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(address owner)</span>;</span>
    <span class="hljs-comment">// 将_tokenId非同质代币授权给地址_to的拥有者</span>
    <span class="hljs-comment">// approve()方法的目的是可以授权第三人来代替自己执行交易</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">approve</span><span class="hljs-params">(address _to, uint256 _tokenId)</span> <span class="hljs-title">external</span>;</span>
    <span class="hljs-comment">// 将_tokenId非同质代币转移给地址为_to的拥有者</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">(address _to, uint256 _tokenId)</span> <span class="hljs-title">external</span>;</span>
    <span class="hljs-comment">// 从_from拥有者转移_tokenId非同质代币给_to新的拥有者</span>
    <span class="hljs-comment">// 内部调用transfer方法进行转移</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transferFrom</span><span class="hljs-params">(address _from, address _to, uint256 _tokenId)</span> <span class="hljs-title">external</span>;</span>

    <span class="hljs-comment">// Events</span>
    <span class="hljs-comment">// 两个事件来分别记录转移和授权</span>
    event Transfer(address from, address to, uint256 tokenId);
    event Approval(address owner, address approved, uint256 tokenId);

    <span class="hljs-comment">// Optional</span>
    <span class="hljs-comment">// 可选实现的接口：</span>
    <span class="hljs-comment">// 返回合约的名字</span>
    <span class="hljs-comment">// function name() public view returns (string name);</span>
    <span class="hljs-comment">// 返回合约代币的符号</span>
    <span class="hljs-comment">// function symbol() public view returns (string symbol);</span>
    <span class="hljs-comment">// 返回_owner所有的非同质代币的id</span>
    <span class="hljs-comment">// function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);</span>
    <span class="hljs-comment">// 返回非同质代币的元数据</span>
    <span class="hljs-comment">// function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);</span>

    <span class="hljs-comment">// ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)</span>
    <span class="hljs-comment">// ERC721标准要求必须同时符合ERC165标准</span>
    <span class="hljs-comment">// 方法用来验证这个合约是否实现了特定的接口。</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">supportsInterface</span><span class="hljs-params">(bytes4 _interfaceID)</span> <span class="hljs-title">external</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span>;</span>
}</code></pre> 
  <p>笔者在这里不再展开描述ERC-165协议的具体内容了，感兴趣的童鞋可以通过以下链接学习： <br> <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md" rel="nofollow">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md</a></p> 
  <h1 id="0x05-erc721metadata">0x05 ERC721Metadata</h1> 
  <p>借着我们刚刚了解了<code>ERC721</code>，我们接着看源码中的<code>ERC721Metadata</code>合约。 <br> 这个合约中的唯一一个方法<code>getMetadata</code>是用于提供合约的元数据(这里返回的是一个<code>bytes</code>和一个<code>uint</code>)。 <br> 输入和返回值分别代表什么含义呢，我们来看源码中441-460行的内容：</p> 
  <pre class="prettyprint"><code class=" hljs cs">contract ERC721Metadata {
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 根据_tokenId，返回特定的字符数组和总长度</span>
    function getMetadata(uint256 _tokenId, <span class="hljs-keyword">string</span>) <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (bytes32[4] buffer, uint256 count) {
        <span class="hljs-comment">// 如果_tokenId为1或2或3，返回不同的字符数组及总长度</span>
        <span class="hljs-keyword">if</span> (_tokenId == <span class="hljs-number">1</span>) {
            buffer[<span class="hljs-number">0</span>] = <span class="hljs-string">"Hello World! :D"</span>;
            count = <span class="hljs-number">15</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_tokenId == <span class="hljs-number">2</span>) {
            buffer[<span class="hljs-number">0</span>] = <span class="hljs-string">"I would definitely choose a medi"</span>;
            buffer[<span class="hljs-number">1</span>] = <span class="hljs-string">"um length string."</span>;
            count = <span class="hljs-number">49</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_tokenId == <span class="hljs-number">3</span>) {
            buffer[<span class="hljs-number">0</span>] = <span class="hljs-string">"Lorem ipsum dolor sit amet, mi e"</span>;
            buffer[<span class="hljs-number">1</span>] = <span class="hljs-string">"st accumsan dapibus augue lorem,"</span>;
            buffer[<span class="hljs-number">2</span>] = <span class="hljs-string">" tristique vestibulum id, libero"</span>;
            buffer[<span class="hljs-number">3</span>] = <span class="hljs-string">" suscipit varius sapien aliquam."</span>;
            count = <span class="hljs-number">128</span>;
        }
    }
}</code></pre> 
  <h1 id="0x06-kittyownership">0x06 KittyOwnership</h1> 
  <p>这个合约继承自<code>KittyBase</code>和<code>ERC721</code>实现了ERC721接口中定义的方法。定义了整个合约的名称和单位</p> 
  <pre class="prettyprint"><code class=" hljs php"><span class="hljs-comment">// KittyOwnership继承自KittyBase和ERC721</span>
contract KittyOwnership is KittyBase, ERC721 {

    <span class="hljs-comment">/// @notice Name and symbol of the non fungible token, as defined in ERC721.</span>
    <span class="hljs-comment">// 整个智能合约的名字为CryptoKitties</span>
    string <span class="hljs-keyword">public</span> constant name = <span class="hljs-string">"CryptoKitties"</span>;
    <span class="hljs-comment">// 猫猫代币的单位为CK</span>
    string <span class="hljs-keyword">public</span> constant symbol = <span class="hljs-string">"CK"</span>;

    <span class="hljs-comment">// The contract that will return kitty metadata</span>
    <span class="hljs-comment">// 合约的元数据</span>
    ERC721Metadata <span class="hljs-keyword">public</span> erc721Metadata;

    <span class="hljs-comment">// ERC165接口的加密byte = 0x01ffc9a7</span>
    bytes4 constant InterfaceSignature_ERC165 =
        bytes4(keccak256(<span class="hljs-string">'supportsInterface(bytes4)'</span>));

    <span class="hljs-comment">// ERC721接口的加密byte = 0x9a20483d</span>
    bytes4 constant InterfaceSignature_ERC721 =
        bytes4(keccak256(<span class="hljs-string">'name()'</span>)) ^
        bytes4(keccak256(<span class="hljs-string">'symbol()'</span>)) ^
        bytes4(keccak256(<span class="hljs-string">'totalSupply()'</span>)) ^
        bytes4(keccak256(<span class="hljs-string">'balanceOf(address)'</span>)) ^
        bytes4(keccak256(<span class="hljs-string">'ownerOf(uint256)'</span>)) ^
        bytes4(keccak256(<span class="hljs-string">'approve(address,uint256)'</span>)) ^
        bytes4(keccak256(<span class="hljs-string">'transfer(address,uint256)'</span>)) ^
        bytes4(keccak256(<span class="hljs-string">'transferFrom(address,address,uint256)'</span>)) ^
        bytes4(keccak256(<span class="hljs-string">'tokensOfOwner(address)'</span>)) ^
        bytes4(keccak256(<span class="hljs-string">'tokenMetadata(uint256,string)'</span>));

    <span class="hljs-comment">// 验证是否实现了ERC721和ERC165</span>
    <span class="hljs-comment">// </span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">supportsInterface</span><span class="hljs-params">(bytes4 _interfaceID)</span> <span class="hljs-title">external</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span> {</span>
        <span class="hljs-keyword">return</span> ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));
    }

    <span class="hljs-comment">/// @dev Set the address of the sibling contract that tracks metadata.</span>
    <span class="hljs-comment">/// CEO only.</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMetadataAddress</span><span class="hljs-params">(address _contractAddress)</span> <span class="hljs-title">public</span> <span class="hljs-title">onlyCEO</span> {</span>
        erc721Metadata = ERC721Metadata(_contractAddress);
    }

    <span class="hljs-comment">// 判断_tokenId的猫猫是否归_claimant地址用户所有</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_owns</span><span class="hljs-params">(address _claimant, uint256 _tokenId)</span> <span class="hljs-title">internal</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span> {</span>
        <span class="hljs-keyword">return</span> kittyIndexToOwner[_tokenId] == _claimant;
    }

    <span class="hljs-comment">// 判断_tokenId的猫猫是否可以被_claimant的地址用户进行转让</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_approvedFor</span><span class="hljs-params">(address _claimant, uint256 _tokenId)</span> <span class="hljs-title">internal</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bool)</span> {</span>
        <span class="hljs-keyword">return</span> kittyIndexToApproved[_tokenId] == _claimant;
    }

    <span class="hljs-comment">// 允许_tokenId的猫猫可以被_approved的地址用户执行transferFrom()方法</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_approve</span><span class="hljs-params">(uint256 _tokenId, address _approved)</span> <span class="hljs-title">internal</span> {</span>
        kittyIndexToApproved[_tokenId] = _approved;
    }

    <span class="hljs-comment">// 返回_ownerd拥有的猫猫token个数</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">balanceOf</span><span class="hljs-params">(address _owner)</span> <span class="hljs-title">public</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256 count)</span> {</span>
        <span class="hljs-keyword">return</span> ownershipTokenCount[_owner];
    }

    <span class="hljs-comment">// 将_tokenId的猫猫转移给_to地址拥有者</span>
    <span class="hljs-comment">// 当系统没有处于暂停状态时</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span><span class="hljs-params">( address _to, uint256 _tokenId )</span> <span class="hljs-title">external</span> <span class="hljs-title">whenNotPaused</span> {</span>
        <span class="hljs-comment">// 检查一下_to的地址是否合法</span>
        <span class="hljs-keyword">require</span>(_to != address(<span class="hljs-number">0</span>));
        <span class="hljs-comment">// 不允许将猫猫转移给本合约地址</span>
        <span class="hljs-keyword">require</span>(_to != address(this));
        <span class="hljs-comment">// 不予许将猫猫转移给拍卖合约地址</span>
        <span class="hljs-keyword">require</span>(_to != address(saleAuction));
        <span class="hljs-comment">// 不允许将猫猫转移给交配合约地址</span>
        <span class="hljs-keyword">require</span>(_to != address(siringAuction));

        <span class="hljs-comment">// 你只能发送_tokenId为你你自己拥有的猫猫</span>
        <span class="hljs-keyword">require</span>(_owns(msg.sender, _tokenId));

        <span class="hljs-comment">// 事件记录</span>
        _transfer(msg.sender, _to, _tokenId);
    }

    <span class="hljs-comment">// 授权其他人将_tokenId为自己拥有的猫猫调用transferFrom()转移给地址为_to的拥有者</span>
    <span class="hljs-comment">// 当系统处于非暂停状态</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">approve</span><span class="hljs-params">( address _to, uint256 _tokenId )</span> <span class="hljs-title">external</span> <span class="hljs-title">whenNotPaused</span> {</span>
        <span class="hljs-comment">// 只有猫猫的拥有者可以授权其他人</span>
        <span class="hljs-keyword">require</span>(_owns(msg.sender, _tokenId));

        <span class="hljs-comment">// 修改_approve()方法修改kittyIndexToApproved[_tokenId]</span>
        _approve(_tokenId, _to);

        <span class="hljs-comment">// 事件记录</span>
        Approval(msg.sender, _to, _tokenId);
    }

    <span class="hljs-comment">// 将_from用户的猫猫_tokenId转移给_to用户</span>
    <span class="hljs-comment">// 当系统处于非暂停状态</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transferFrom</span><span class="hljs-params">( address _from, address _to, uint256 _tokenId )</span> <span class="hljs-title">external</span> <span class="hljs-title">whenNotPaused</span> {</span>
        <span class="hljs-comment">// 检查一下_to的地址是否合法</span>
        <span class="hljs-keyword">require</span>(_to != address(<span class="hljs-number">0</span>));
        <span class="hljs-comment">// 不允许将猫猫转移给本合约地址</span>
        <span class="hljs-keyword">require</span>(_to != address(this));
        <span class="hljs-comment">// 检查msg.sender是否获得了授权转移_tokenId的毛毛啊</span>
        <span class="hljs-keyword">require</span>(_approvedFor(msg.sender, _tokenId));
        <span class="hljs-comment">// 检查_from是否拥有_tokenId猫猫</span>
        <span class="hljs-keyword">require</span>(_owns(_from, _tokenId));

        <span class="hljs-comment">// 调用_transfer()进行转移</span>
        _transfer(_from, _to, _tokenId);
    }

    <span class="hljs-comment">// 返回目前所有的猫猫个数</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">totalSupply</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span> {</span>
        <span class="hljs-keyword">return</span> kitties.length - <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// 返回_tokenId猫猫的拥有者的地址</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownerOf</span><span class="hljs-params">(uint256 _tokenId)</span> <span class="hljs-title">external</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(address owner)</span> {</span>
        owner = kittyIndexToOwner[_tokenId];

        <span class="hljs-keyword">require</span>(owner != address(<span class="hljs-number">0</span>));
    }

    <span class="hljs-comment">// 返回_owner拥有的所有猫猫的id数组</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tokensOfOwner</span><span class="hljs-params">(address _owner)</span> <span class="hljs-title">external</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span><span class="hljs-params">(uint256[] ownerTokens)</span> {</span>
        <span class="hljs-comment">// 获得_owner拥有的猫猫数量</span>
        uint256 tokenCount = balanceOf(_owner);

        <span class="hljs-comment">// 判断数量是否为0</span>
        <span class="hljs-keyword">if</span> (tokenCount == <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 如果该_owner没有猫猫，返回空数组</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uint256[](<span class="hljs-number">0</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 如果该_owner有</span>
            <span class="hljs-comment">// 声明并初始化一个返回值result，长度为tokenCount</span>
            uint256[] memory result = <span class="hljs-keyword">new</span> uint256[](tokenCount);
            <span class="hljs-comment">// 当前所有的猫猫数量</span>
            uint256 totalCats = totalSupply();
            <span class="hljs-comment">// 循环的初始值</span>
            uint256 resultIndex = <span class="hljs-number">0</span>;

            <span class="hljs-comment">// 所有的猫都有ID从1增加到totalCats</span>
            uint256 catId;

            <span class="hljs-comment">// 从1开始循环遍历所有的totalCats</span>
            <span class="hljs-keyword">for</span> (catId = <span class="hljs-number">1</span>; catId &lt;= totalCats; catId++) {
                <span class="hljs-comment">// 判断当前catId的拥有者是否为_owner</span>
                <span class="hljs-keyword">if</span> (kittyIndexToOwner[catId] == _owner) {
                    <span class="hljs-comment">// 如果是，将catId放入result数组resultIndex位置</span>
                    result[resultIndex] = catId;
                    <span class="hljs-comment">// resultIndex加1</span>
                    resultIndex++;
                }
            }

            <span class="hljs-comment">// 返回result</span>
            <span class="hljs-keyword">return</span> result;
        }
    }

    <span class="hljs-comment">// 拷贝方法</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_memcpy</span><span class="hljs-params">(uint _dest, uint _src, uint _len)</span> <span class="hljs-title">private</span> <span class="hljs-title">view</span> {</span>
        <span class="hljs-comment">// Copy word-length chunks while possible</span>
        <span class="hljs-keyword">for</span>(; _len &gt;= <span class="hljs-number">32</span>; _len -= <span class="hljs-number">32</span>) {
            assembly {
                mstore(_dest, mload(_src))
            }
            _dest += <span class="hljs-number">32</span>;
            _src += <span class="hljs-number">32</span>;
        }

        <span class="hljs-comment">// Copy remaining bytes</span>
        uint256 mask = <span class="hljs-number">256</span> ** (<span class="hljs-number">32</span> - _len) - <span class="hljs-number">1</span>;
        assembly {
            let srcpart := <span class="hljs-keyword">and</span>(mload(_src), not(mask))
            let destpart := <span class="hljs-keyword">and</span>(mload(_dest), mask)
            mstore(_dest, <span class="hljs-keyword">or</span>(destpart, srcpart))
        }
    }

    <span class="hljs-comment">// 将_rawBytes中长度为_stringLength转成string并返回</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_toString</span><span class="hljs-params">(bytes32[<span class="hljs-number">4</span>] _rawBytes, uint256 _stringLength)</span> <span class="hljs-title">private</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(string)</span> {</span>
        <span class="hljs-keyword">var</span> outputString = <span class="hljs-keyword">new</span> string(_stringLength);
        uint256 outputPtr;
        uint256 bytesPtr;

        assembly {
            outputPtr := add(outputString, <span class="hljs-number">32</span>)
            bytesPtr := _rawBytes
        }

        _memcpy(outputPtr, bytesPtr, _stringLength);

        <span class="hljs-keyword">return</span> outputString;
    }

    <span class="hljs-comment">// 返回指向该元数据的元数据包的URI</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tokenMetadata</span><span class="hljs-params">(uint256 _tokenId, string _preferredTransport)</span> <span class="hljs-title">external</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(string infoUrl)</span> {</span>
        <span class="hljs-keyword">require</span>(erc721Metadata != address(<span class="hljs-number">0</span>));
        bytes32[<span class="hljs-number">4</span>] memory buffer;
        uint256 count;
        (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);

        <span class="hljs-keyword">return</span> _toString(buffer, count);
    }
}</code></pre> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u011609555/article/details/79726280,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u011609555/article/details/79726280,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
