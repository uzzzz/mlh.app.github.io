<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链 之 部署和调用以太坊智能合约 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链 之 部署和调用以太坊智能合约" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/RoyalApex/article/details/79430999 区块链 之 部署和调用以太坊智能合约 作者：邹祁峰 邮箱：Qifeng.zou.job@hotmail.com 博客：http://blog.csdn.net/qifengzou 日期：2018.03.04 01:18 转载请注明来自”祁峰”的CSDN博客 1 引言 智能合约就像我们业务的后台逻辑, 其运行在以太坊平台上. 以太坊就像操作系统, 其天然的提供了区块链的特性. 绝大多数开发人员只需关注使用Solidity编写智能合约实现业务逻辑, 而无需去修改以太坊的特性. 因此, 此文中将重点讲述如何在以太坊上部署和调用智能合约. 为方便大家理解智能合约和以太坊之间的关系,可以用一下几个概念做类比. 序号 通用概念 以太坊 01 操作系统 以太坊 02 C/C++/Java/Go Solidity 03 类+函数 智能合约 2 智能合约 为了让大家对智能合约的编写/部署/调用有一个全面的了解.以下将以一个实例串联整个过程. 2.1 编写智能合约 智能合约的编写,编译以及部署可以通过网页版Remix,也可通过本地truffle框架进行操作.以下以truffle框架下进行操作.[注:truffle的使用请自查资料] 新建Adoption.sol文件: # mkdir pet-adopt // 新建项目目录 # truffle init // 初始化truffle框架, 将会自动生成如下目录结构 # tree // 查看目录结构 . ├── contracts // 智能合约存放目录 │ └── Migrations.sol ├── migrations // 智能合约部署脚本 │ └── 1_initial_migration.js ├── test └── truffle-config.js 进入智能合约存放目录contracts,并创建智能合约Adoption.sol文件,输入如下内容: pragma solidity ^0.4.17; contract Adoption { address[16] public adopters; // 保存领养者的地址 // 领养宠物 function adopt(uint petId) public returns (uint) { require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); // 确保id在数组长度内 adopters[petId] = msg.sender; // 保存调用这地址 return petId; } // 返回领养者 function getAdopters() public view returns (address[16]) { return adopters; } } 2.2 编译智能合约 完成智能合约的编辑后,则需编译智能合约.在项目根目录输入如下指令: # truffle compile // 编译智能合约 Compiling ./contracts/Adoption.sol… Compiling ./contracts/Migrations.sol… Writing artifacts to ./build/contracts # tree // 查看目录结构 . ├── build │ └── contracts │ ├── Adoption.json // 编译结果 │ └── Migrations.json ├── contracts │ ├── Adoption.sol │ └── Migrations.sol ├── migrations │ └── 1_initial_migration.js ├── test └── truffle-config.js 完成编译后, 编译结果将会输出到./build/contracts/Adoption.json文件中. 2.3 部署智能合约 完成智能合约的编译后,便可进行智能合约的部署了.部署智能合约Adoption.sol的大体步骤如下: 1.启动以太坊私链 既然要将智能合约部署到以太坊网络,在部署之前需要搭建好以太坊网络.搭建以太坊私链的过程可参考博文: &lt;&lt;区块链 之 搭建以太坊私有链&gt;&gt; 以太坊私有链--rpcport为8545. 2.指定以太坊平台 首先需要指明将智能合约部署到哪个以太坊网络,只需指明该以太坊网络的某一个节点便可. 在根目录下的truffle-config.js添加如下配置信息: module.exports = { // See &lt;http://truffleframework.com/docs/advanced/configuration&gt; // for more about customizing your Truffle configuration! networks: { development: { host: &quot;127.0.0.1&quot;, port: 8545, network_id: &quot;*&quot; // Match any network id } } }; 3.添加部署脚本 需要在migrations中添加部署脚本:2_deploy_adoption.js. 其格式如下: var Adoption = artifacts.require(&quot;Adoption&quot;); module.exports = function(deployer) { deployer.deploy(Adoption); }; 4.执行部署操作 完成以上的配置后,可通过执行以下命令部署智能合约到指定的以太坊私有链中: # truffle migrate 如过执行以上命令后出现以下信息时, 表示智能合约部署失败: Using network ‘development’. Running migration: 1_initial_migration.js Deploying Migrations… … undefined Error encountered, bailing. Network state unknown. Review successful transactions manually. Error: authentication needed: password or unlock at Object.InvalidResponse (/usr/local/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/errors.js:38:1) … 信息中存在Error: authentication needed: password or unlock的提示,则需要在以太坊私链中执行如下操作: # geth --datadir ./data/00 --networkid 15 --port 61910 --rpc --rpcport 8545 --rpcapi &#39;db,net,eth,web3&#39; --rpccorsdomain &#39;*&#39; console &gt; personal.unlock(eth.accounts[0], &#39;123456&#39;) // 解锁 true &gt; miner.start() // 开始挖矿. 完成以上操作后, 便可再次向以太坊私有链部署智能合约. # truffle migrate / /部署智能合约 Using network ‘development’. Running migration: 1_initial_migration.js Deploying Migrations… … 0x0d55306dc39c028eed2867c819bd9c73d8bfbfeaac071613ef43f4456cdf72cf Migrations: 0xe23b05e83fbbc5e57d8fe5e1bf0bd460b03f1541 Saving successful migration to network… … 0x1e646661887966b0cfeda56ce317995a9e9189126828a8b56f6627e5a20207f1 Saving artifacts… Running migration: 2_deploy_adopt.js Deploying Adoption… … 0xed2ea576bc349d6688f66758a19cb7d889da459df615a7440ed33ec8d816e486 Adoption: 0xff8f47f643827fc324ac9575b8b4981d042ce5e7 Saving successful migration to network… … 0x99db86745721494b955e9d4f3099d91d180435a792f75f2dc085c143337e7aa2 Saving artifacts… 以上日志提示智能合约已经部署成功, 同时以上日志Adoption: 0xff8f47f643827fc324ac9575b8b4981d042ce5e7中也指明了智能合约Adoption地址为:0xff8f47f643827fc324ac9575b8b4981d042ce5e7, 该地址将会在智能合约的调用中被使用. 2.4 调用智能合约 为了保证后续智能合约的调用能够正常执行, 以太坊私有链中至少有一个节点正在挖矿. 要调用刚才部署的智能合约, 需要找到被部署智能合约的abi信息和地址. 1.智能合约abi信息 智能合约的abi信息在编译后的文件中, 如:Adoption.sol被编译后, 其abi信息存储在Adoption.json文件中. # tree . ├── build │ └── contracts │ ├── Adoption.json // 智能合约abi信息存储在该文件中 │ └── Migrations.json ├── contracts │ ├── Adoption.sol // 智能合约 │ └── Migrations.sol ├── migrations │ ├── 1_initial_migration.js │ └── 2_deploy_adopt.js ├── test └── truffle-config.js 智能合约abi信息为一个数组, 如下所示: &quot;abi&quot;: [ { &quot;constant&quot;: true, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: false, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;petId&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopt&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;getAdopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address[16]&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; } ] 拷贝abi数组, 并将以上json转换成一行子串, 再切换到以太坊的geth命令中, 输入如下指令: &gt; var abi = [ { &quot;constant&quot;: true, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: false, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;petId&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopt&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;getAdopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address[16]&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; } ] 2.智能合约地址信息 在2.3节中提到智能合约的地址为:0xff8f47f643827fc324ac9575b8b4981d042ce5e7, 可将该地址存储到geth的变量中. &gt; var addr = &quot;0xff8f47f643827fc324ac9575b8b4981d042ce5e7&quot; // 注意:必须使用双引号 有了智能合约的abi和地址信息后, 可通过以下语句创建新建智能合约对象. &gt; var adoption = eth.contract(abi).at(addr) // 创建合约对象 可在geth命令行中输入adoption变量名, 将会打印该变量的数据信息. 如下所示: abi: [{ constant: true, inputs: [{...}], name: &quot;adopters&quot;, outputs: [{...}], payable: false, stateMutability: &quot;view&quot;, type: &quot;function&quot; }, { constant: false, inputs: [{...}], name: &quot;adopt&quot;, outputs: [{...}], payable: false, stateMutability: &quot;nonpayable&quot;, type: &quot;function&quot; }, { constant: true, inputs: [], name: &quot;getAdopters&quot;, outputs: [{...}], payable: false, stateMutability: &quot;view&quot;, type: &quot;function&quot; }], address: &quot;0xff8f47f643827fc324ac9575b8b4981d042ce5e7&quot;, transactionHash: null, adopt: function(), adopters: function(), allEvents: function(), getAdopters: function() } 在最末尾可以看到我们在Adoption.sol中编辑的函数名, 说明已获取到智能合约对象. 3.调用智能合约 完成以上操作后, 则可以通过adoption对象调用智能合约对象了. 如果调用的智能合约函数未改变合约中的数据, 则不会消耗以太坊gas. 以Adoption中的getAdopters()为例, 获取16只宠物被哪些账号收养. &gt;adoption.getAdopters.call() [“0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”] 以上地址均为0x0000000000000000000000000000000000000000, 表示暂无人收养. 如果调用的智能合约函数需要合约中的数据, 则需要消耗以太坊gas. 以Adoption中的adopt()为例, 收养第2只宠物. &gt;adoption.adopt.sendTransaction(2, {from: eth.accounts[0]}) “0x0d1a6079e878b82870eafbbd66c311c9acad893c7389bd43c9b003a5a5416ef0” 由于需要修改合约中的数据, 调用adopt()时需要使用sendTransaction()发起交易, 并附加发起者的账号. 以上操作只是发起了交易, 但交易并不一定会被处理. 交易被处理还必须要有节点处于挖矿模式. &gt; miner.start() 过了一段时间后, 再次查看宠物是否被收养成功. &gt; adoption.getAdopters() [“0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0xa0cf841d14ba336ffd6c1f617eb4663223790cc3”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”] 可以发现索引为2的数组内容的值为0xa0cf841d14ba336ffd6c1f617eb4663223790cc3, 说明宠物已经收养成功.即: 发起的交易已经被执行. 至此, 智能合约的编辑/编译/部署以及最后的调用过程已经讲解完成. 对于智能合约的调用, 还可通过其他方式调用. 如:在js中如何调用智能合约, 在此未能讲述. 后续章节将会陆续补充. 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/RoyalApex/article/details/79430999 区块链 之 部署和调用以太坊智能合约 作者：邹祁峰 邮箱：Qifeng.zou.job@hotmail.com 博客：http://blog.csdn.net/qifengzou 日期：2018.03.04 01:18 转载请注明来自”祁峰”的CSDN博客 1 引言 智能合约就像我们业务的后台逻辑, 其运行在以太坊平台上. 以太坊就像操作系统, 其天然的提供了区块链的特性. 绝大多数开发人员只需关注使用Solidity编写智能合约实现业务逻辑, 而无需去修改以太坊的特性. 因此, 此文中将重点讲述如何在以太坊上部署和调用智能合约. 为方便大家理解智能合约和以太坊之间的关系,可以用一下几个概念做类比. 序号 通用概念 以太坊 01 操作系统 以太坊 02 C/C++/Java/Go Solidity 03 类+函数 智能合约 2 智能合约 为了让大家对智能合约的编写/部署/调用有一个全面的了解.以下将以一个实例串联整个过程. 2.1 编写智能合约 智能合约的编写,编译以及部署可以通过网页版Remix,也可通过本地truffle框架进行操作.以下以truffle框架下进行操作.[注:truffle的使用请自查资料] 新建Adoption.sol文件: # mkdir pet-adopt // 新建项目目录 # truffle init // 初始化truffle框架, 将会自动生成如下目录结构 # tree // 查看目录结构 . ├── contracts // 智能合约存放目录 │ └── Migrations.sol ├── migrations // 智能合约部署脚本 │ └── 1_initial_migration.js ├── test └── truffle-config.js 进入智能合约存放目录contracts,并创建智能合约Adoption.sol文件,输入如下内容: pragma solidity ^0.4.17; contract Adoption { address[16] public adopters; // 保存领养者的地址 // 领养宠物 function adopt(uint petId) public returns (uint) { require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); // 确保id在数组长度内 adopters[petId] = msg.sender; // 保存调用这地址 return petId; } // 返回领养者 function getAdopters() public view returns (address[16]) { return adopters; } } 2.2 编译智能合约 完成智能合约的编辑后,则需编译智能合约.在项目根目录输入如下指令: # truffle compile // 编译智能合约 Compiling ./contracts/Adoption.sol… Compiling ./contracts/Migrations.sol… Writing artifacts to ./build/contracts # tree // 查看目录结构 . ├── build │ └── contracts │ ├── Adoption.json // 编译结果 │ └── Migrations.json ├── contracts │ ├── Adoption.sol │ └── Migrations.sol ├── migrations │ └── 1_initial_migration.js ├── test └── truffle-config.js 完成编译后, 编译结果将会输出到./build/contracts/Adoption.json文件中. 2.3 部署智能合约 完成智能合约的编译后,便可进行智能合约的部署了.部署智能合约Adoption.sol的大体步骤如下: 1.启动以太坊私链 既然要将智能合约部署到以太坊网络,在部署之前需要搭建好以太坊网络.搭建以太坊私链的过程可参考博文: &lt;&lt;区块链 之 搭建以太坊私有链&gt;&gt; 以太坊私有链--rpcport为8545. 2.指定以太坊平台 首先需要指明将智能合约部署到哪个以太坊网络,只需指明该以太坊网络的某一个节点便可. 在根目录下的truffle-config.js添加如下配置信息: module.exports = { // See &lt;http://truffleframework.com/docs/advanced/configuration&gt; // for more about customizing your Truffle configuration! networks: { development: { host: &quot;127.0.0.1&quot;, port: 8545, network_id: &quot;*&quot; // Match any network id } } }; 3.添加部署脚本 需要在migrations中添加部署脚本:2_deploy_adoption.js. 其格式如下: var Adoption = artifacts.require(&quot;Adoption&quot;); module.exports = function(deployer) { deployer.deploy(Adoption); }; 4.执行部署操作 完成以上的配置后,可通过执行以下命令部署智能合约到指定的以太坊私有链中: # truffle migrate 如过执行以上命令后出现以下信息时, 表示智能合约部署失败: Using network ‘development’. Running migration: 1_initial_migration.js Deploying Migrations… … undefined Error encountered, bailing. Network state unknown. Review successful transactions manually. Error: authentication needed: password or unlock at Object.InvalidResponse (/usr/local/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/errors.js:38:1) … 信息中存在Error: authentication needed: password or unlock的提示,则需要在以太坊私链中执行如下操作: # geth --datadir ./data/00 --networkid 15 --port 61910 --rpc --rpcport 8545 --rpcapi &#39;db,net,eth,web3&#39; --rpccorsdomain &#39;*&#39; console &gt; personal.unlock(eth.accounts[0], &#39;123456&#39;) // 解锁 true &gt; miner.start() // 开始挖矿. 完成以上操作后, 便可再次向以太坊私有链部署智能合约. # truffle migrate / /部署智能合约 Using network ‘development’. Running migration: 1_initial_migration.js Deploying Migrations… … 0x0d55306dc39c028eed2867c819bd9c73d8bfbfeaac071613ef43f4456cdf72cf Migrations: 0xe23b05e83fbbc5e57d8fe5e1bf0bd460b03f1541 Saving successful migration to network… … 0x1e646661887966b0cfeda56ce317995a9e9189126828a8b56f6627e5a20207f1 Saving artifacts… Running migration: 2_deploy_adopt.js Deploying Adoption… … 0xed2ea576bc349d6688f66758a19cb7d889da459df615a7440ed33ec8d816e486 Adoption: 0xff8f47f643827fc324ac9575b8b4981d042ce5e7 Saving successful migration to network… … 0x99db86745721494b955e9d4f3099d91d180435a792f75f2dc085c143337e7aa2 Saving artifacts… 以上日志提示智能合约已经部署成功, 同时以上日志Adoption: 0xff8f47f643827fc324ac9575b8b4981d042ce5e7中也指明了智能合约Adoption地址为:0xff8f47f643827fc324ac9575b8b4981d042ce5e7, 该地址将会在智能合约的调用中被使用. 2.4 调用智能合约 为了保证后续智能合约的调用能够正常执行, 以太坊私有链中至少有一个节点正在挖矿. 要调用刚才部署的智能合约, 需要找到被部署智能合约的abi信息和地址. 1.智能合约abi信息 智能合约的abi信息在编译后的文件中, 如:Adoption.sol被编译后, 其abi信息存储在Adoption.json文件中. # tree . ├── build │ └── contracts │ ├── Adoption.json // 智能合约abi信息存储在该文件中 │ └── Migrations.json ├── contracts │ ├── Adoption.sol // 智能合约 │ └── Migrations.sol ├── migrations │ ├── 1_initial_migration.js │ └── 2_deploy_adopt.js ├── test └── truffle-config.js 智能合约abi信息为一个数组, 如下所示: &quot;abi&quot;: [ { &quot;constant&quot;: true, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: false, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;petId&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopt&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;getAdopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address[16]&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; } ] 拷贝abi数组, 并将以上json转换成一行子串, 再切换到以太坊的geth命令中, 输入如下指令: &gt; var abi = [ { &quot;constant&quot;: true, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: false, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;petId&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopt&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;getAdopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address[16]&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; } ] 2.智能合约地址信息 在2.3节中提到智能合约的地址为:0xff8f47f643827fc324ac9575b8b4981d042ce5e7, 可将该地址存储到geth的变量中. &gt; var addr = &quot;0xff8f47f643827fc324ac9575b8b4981d042ce5e7&quot; // 注意:必须使用双引号 有了智能合约的abi和地址信息后, 可通过以下语句创建新建智能合约对象. &gt; var adoption = eth.contract(abi).at(addr) // 创建合约对象 可在geth命令行中输入adoption变量名, 将会打印该变量的数据信息. 如下所示: abi: [{ constant: true, inputs: [{...}], name: &quot;adopters&quot;, outputs: [{...}], payable: false, stateMutability: &quot;view&quot;, type: &quot;function&quot; }, { constant: false, inputs: [{...}], name: &quot;adopt&quot;, outputs: [{...}], payable: false, stateMutability: &quot;nonpayable&quot;, type: &quot;function&quot; }, { constant: true, inputs: [], name: &quot;getAdopters&quot;, outputs: [{...}], payable: false, stateMutability: &quot;view&quot;, type: &quot;function&quot; }], address: &quot;0xff8f47f643827fc324ac9575b8b4981d042ce5e7&quot;, transactionHash: null, adopt: function(), adopters: function(), allEvents: function(), getAdopters: function() } 在最末尾可以看到我们在Adoption.sol中编辑的函数名, 说明已获取到智能合约对象. 3.调用智能合约 完成以上操作后, 则可以通过adoption对象调用智能合约对象了. 如果调用的智能合约函数未改变合约中的数据, 则不会消耗以太坊gas. 以Adoption中的getAdopters()为例, 获取16只宠物被哪些账号收养. &gt;adoption.getAdopters.call() [“0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”] 以上地址均为0x0000000000000000000000000000000000000000, 表示暂无人收养. 如果调用的智能合约函数需要合约中的数据, 则需要消耗以太坊gas. 以Adoption中的adopt()为例, 收养第2只宠物. &gt;adoption.adopt.sendTransaction(2, {from: eth.accounts[0]}) “0x0d1a6079e878b82870eafbbd66c311c9acad893c7389bd43c9b003a5a5416ef0” 由于需要修改合约中的数据, 调用adopt()时需要使用sendTransaction()发起交易, 并附加发起者的账号. 以上操作只是发起了交易, 但交易并不一定会被处理. 交易被处理还必须要有节点处于挖矿模式. &gt; miner.start() 过了一段时间后, 再次查看宠物是否被收养成功. &gt; adoption.getAdopters() [“0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0xa0cf841d14ba336ffd6c1f617eb4663223790cc3”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”] 可以发现索引为2的数组内容的值为0xa0cf841d14ba336ffd6c1f617eb4663223790cc3, 说明宠物已经收养成功.即: 发起的交易已经被执行. 至此, 智能合约的编辑/编译/部署以及最后的调用过程已经讲解完成. 对于智能合约的调用, 还可通过其他方式调用. 如:在js中如何调用智能合约, 在此未能讲述. 后续章节将会陆续补充. 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/04/19c90318b4e5bd6c6395cc18248bac26.html" />
<meta property="og:url" content="https://mlh.app/2018/03/04/19c90318b4e5bd6c6395cc18248bac26.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-04T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/RoyalApex/article/details/79430999 区块链 之 部署和调用以太坊智能合约 作者：邹祁峰 邮箱：Qifeng.zou.job@hotmail.com 博客：http://blog.csdn.net/qifengzou 日期：2018.03.04 01:18 转载请注明来自”祁峰”的CSDN博客 1 引言 智能合约就像我们业务的后台逻辑, 其运行在以太坊平台上. 以太坊就像操作系统, 其天然的提供了区块链的特性. 绝大多数开发人员只需关注使用Solidity编写智能合约实现业务逻辑, 而无需去修改以太坊的特性. 因此, 此文中将重点讲述如何在以太坊上部署和调用智能合约. 为方便大家理解智能合约和以太坊之间的关系,可以用一下几个概念做类比. 序号 通用概念 以太坊 01 操作系统 以太坊 02 C/C++/Java/Go Solidity 03 类+函数 智能合约 2 智能合约 为了让大家对智能合约的编写/部署/调用有一个全面的了解.以下将以一个实例串联整个过程. 2.1 编写智能合约 智能合约的编写,编译以及部署可以通过网页版Remix,也可通过本地truffle框架进行操作.以下以truffle框架下进行操作.[注:truffle的使用请自查资料] 新建Adoption.sol文件: # mkdir pet-adopt // 新建项目目录 # truffle init // 初始化truffle框架, 将会自动生成如下目录结构 # tree // 查看目录结构 . ├── contracts // 智能合约存放目录 │ └── Migrations.sol ├── migrations // 智能合约部署脚本 │ └── 1_initial_migration.js ├── test └── truffle-config.js 进入智能合约存放目录contracts,并创建智能合约Adoption.sol文件,输入如下内容: pragma solidity ^0.4.17; contract Adoption { address[16] public adopters; // 保存领养者的地址 // 领养宠物 function adopt(uint petId) public returns (uint) { require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); // 确保id在数组长度内 adopters[petId] = msg.sender; // 保存调用这地址 return petId; } // 返回领养者 function getAdopters() public view returns (address[16]) { return adopters; } } 2.2 编译智能合约 完成智能合约的编辑后,则需编译智能合约.在项目根目录输入如下指令: # truffle compile // 编译智能合约 Compiling ./contracts/Adoption.sol… Compiling ./contracts/Migrations.sol… Writing artifacts to ./build/contracts # tree // 查看目录结构 . ├── build │ └── contracts │ ├── Adoption.json // 编译结果 │ └── Migrations.json ├── contracts │ ├── Adoption.sol │ └── Migrations.sol ├── migrations │ └── 1_initial_migration.js ├── test └── truffle-config.js 完成编译后, 编译结果将会输出到./build/contracts/Adoption.json文件中. 2.3 部署智能合约 完成智能合约的编译后,便可进行智能合约的部署了.部署智能合约Adoption.sol的大体步骤如下: 1.启动以太坊私链 既然要将智能合约部署到以太坊网络,在部署之前需要搭建好以太坊网络.搭建以太坊私链的过程可参考博文: &lt;&lt;区块链 之 搭建以太坊私有链&gt;&gt; 以太坊私有链--rpcport为8545. 2.指定以太坊平台 首先需要指明将智能合约部署到哪个以太坊网络,只需指明该以太坊网络的某一个节点便可. 在根目录下的truffle-config.js添加如下配置信息: module.exports = { // See &lt;http://truffleframework.com/docs/advanced/configuration&gt; // for more about customizing your Truffle configuration! networks: { development: { host: &quot;127.0.0.1&quot;, port: 8545, network_id: &quot;*&quot; // Match any network id } } }; 3.添加部署脚本 需要在migrations中添加部署脚本:2_deploy_adoption.js. 其格式如下: var Adoption = artifacts.require(&quot;Adoption&quot;); module.exports = function(deployer) { deployer.deploy(Adoption); }; 4.执行部署操作 完成以上的配置后,可通过执行以下命令部署智能合约到指定的以太坊私有链中: # truffle migrate 如过执行以上命令后出现以下信息时, 表示智能合约部署失败: Using network ‘development’. Running migration: 1_initial_migration.js Deploying Migrations… … undefined Error encountered, bailing. Network state unknown. Review successful transactions manually. Error: authentication needed: password or unlock at Object.InvalidResponse (/usr/local/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/errors.js:38:1) … 信息中存在Error: authentication needed: password or unlock的提示,则需要在以太坊私链中执行如下操作: # geth --datadir ./data/00 --networkid 15 --port 61910 --rpc --rpcport 8545 --rpcapi &#39;db,net,eth,web3&#39; --rpccorsdomain &#39;*&#39; console &gt; personal.unlock(eth.accounts[0], &#39;123456&#39;) // 解锁 true &gt; miner.start() // 开始挖矿. 完成以上操作后, 便可再次向以太坊私有链部署智能合约. # truffle migrate / /部署智能合约 Using network ‘development’. Running migration: 1_initial_migration.js Deploying Migrations… … 0x0d55306dc39c028eed2867c819bd9c73d8bfbfeaac071613ef43f4456cdf72cf Migrations: 0xe23b05e83fbbc5e57d8fe5e1bf0bd460b03f1541 Saving successful migration to network… … 0x1e646661887966b0cfeda56ce317995a9e9189126828a8b56f6627e5a20207f1 Saving artifacts… Running migration: 2_deploy_adopt.js Deploying Adoption… … 0xed2ea576bc349d6688f66758a19cb7d889da459df615a7440ed33ec8d816e486 Adoption: 0xff8f47f643827fc324ac9575b8b4981d042ce5e7 Saving successful migration to network… … 0x99db86745721494b955e9d4f3099d91d180435a792f75f2dc085c143337e7aa2 Saving artifacts… 以上日志提示智能合约已经部署成功, 同时以上日志Adoption: 0xff8f47f643827fc324ac9575b8b4981d042ce5e7中也指明了智能合约Adoption地址为:0xff8f47f643827fc324ac9575b8b4981d042ce5e7, 该地址将会在智能合约的调用中被使用. 2.4 调用智能合约 为了保证后续智能合约的调用能够正常执行, 以太坊私有链中至少有一个节点正在挖矿. 要调用刚才部署的智能合约, 需要找到被部署智能合约的abi信息和地址. 1.智能合约abi信息 智能合约的abi信息在编译后的文件中, 如:Adoption.sol被编译后, 其abi信息存储在Adoption.json文件中. # tree . ├── build │ └── contracts │ ├── Adoption.json // 智能合约abi信息存储在该文件中 │ └── Migrations.json ├── contracts │ ├── Adoption.sol // 智能合约 │ └── Migrations.sol ├── migrations │ ├── 1_initial_migration.js │ └── 2_deploy_adopt.js ├── test └── truffle-config.js 智能合约abi信息为一个数组, 如下所示: &quot;abi&quot;: [ { &quot;constant&quot;: true, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: false, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;petId&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopt&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;getAdopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address[16]&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; } ] 拷贝abi数组, 并将以上json转换成一行子串, 再切换到以太坊的geth命令中, 输入如下指令: &gt; var abi = [ { &quot;constant&quot;: true, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: false, &quot;inputs&quot;: [ { &quot;name&quot;: &quot;petId&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;adopt&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; }, { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;getAdopters&quot;, &quot;outputs&quot;: [ { &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;address[16]&quot; } ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; } ] 2.智能合约地址信息 在2.3节中提到智能合约的地址为:0xff8f47f643827fc324ac9575b8b4981d042ce5e7, 可将该地址存储到geth的变量中. &gt; var addr = &quot;0xff8f47f643827fc324ac9575b8b4981d042ce5e7&quot; // 注意:必须使用双引号 有了智能合约的abi和地址信息后, 可通过以下语句创建新建智能合约对象. &gt; var adoption = eth.contract(abi).at(addr) // 创建合约对象 可在geth命令行中输入adoption变量名, 将会打印该变量的数据信息. 如下所示: abi: [{ constant: true, inputs: [{...}], name: &quot;adopters&quot;, outputs: [{...}], payable: false, stateMutability: &quot;view&quot;, type: &quot;function&quot; }, { constant: false, inputs: [{...}], name: &quot;adopt&quot;, outputs: [{...}], payable: false, stateMutability: &quot;nonpayable&quot;, type: &quot;function&quot; }, { constant: true, inputs: [], name: &quot;getAdopters&quot;, outputs: [{...}], payable: false, stateMutability: &quot;view&quot;, type: &quot;function&quot; }], address: &quot;0xff8f47f643827fc324ac9575b8b4981d042ce5e7&quot;, transactionHash: null, adopt: function(), adopters: function(), allEvents: function(), getAdopters: function() } 在最末尾可以看到我们在Adoption.sol中编辑的函数名, 说明已获取到智能合约对象. 3.调用智能合约 完成以上操作后, 则可以通过adoption对象调用智能合约对象了. 如果调用的智能合约函数未改变合约中的数据, 则不会消耗以太坊gas. 以Adoption中的getAdopters()为例, 获取16只宠物被哪些账号收养. &gt;adoption.getAdopters.call() [“0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”] 以上地址均为0x0000000000000000000000000000000000000000, 表示暂无人收养. 如果调用的智能合约函数需要合约中的数据, 则需要消耗以太坊gas. 以Adoption中的adopt()为例, 收养第2只宠物. &gt;adoption.adopt.sendTransaction(2, {from: eth.accounts[0]}) “0x0d1a6079e878b82870eafbbd66c311c9acad893c7389bd43c9b003a5a5416ef0” 由于需要修改合约中的数据, 调用adopt()时需要使用sendTransaction()发起交易, 并附加发起者的账号. 以上操作只是发起了交易, 但交易并不一定会被处理. 交易被处理还必须要有节点处于挖矿模式. &gt; miner.start() 过了一段时间后, 再次查看宠物是否被收养成功. &gt; adoption.getAdopters() [“0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0xa0cf841d14ba336ffd6c1f617eb4663223790cc3”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”, “0x0000000000000000000000000000000000000000”] 可以发现索引为2的数组内容的值为0xa0cf841d14ba336ffd6c1f617eb4663223790cc3, 说明宠物已经收养成功.即: 发起的交易已经被执行. 至此, 智能合约的编辑/编译/部署以及最后的调用过程已经讲解完成. 对于智能合约的调用, 还可通过其他方式调用. 如:在js中如何调用智能合约, 在此未能讲述. 后续章节将会陆续补充. 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/04/19c90318b4e5bd6c6395cc18248bac26.html","headline":"区块链 之 部署和调用以太坊智能合约","dateModified":"2018-03-04T00:00:00+08:00","datePublished":"2018-03-04T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/04/19c90318b4e5bd6c6395cc18248bac26.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链 之 部署和调用以太坊智能合约</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/RoyalApex/article/details/79430999 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1 id="区块链-之-部署和调用以太坊智能合约">区块链 之 部署和调用以太坊智能合约</h1> 
  <blockquote> 
   <p>作者：邹祁峰 <br> 邮箱：Qifeng.zou.job@hotmail.com <br> 博客：<a href="http://blog.csdn.net/qifengzou" rel="nofollow">http://blog.csdn.net/qifengzou</a> <br> 日期：2018.03.04 01:18 <br> 转载请注明来自”祁峰”的CSDN博客</p> 
  </blockquote> 
  <h2 id="1-引言">1 引言</h2> 
  <p>智能合约就像我们业务的后台逻辑, 其运行在以太坊平台上. 以太坊就像操作系统, 其天然的提供了区块链的特性. 绝大多数开发人员只需关注使用Solidity编写智能合约实现业务逻辑, 而无需去修改以太坊的特性. 因此, 此文中将重点讲述如何在以太坊上部署和调用智能合约. <br> 为方便大家理解智能合约和以太坊之间的关系,可以用一下几个概念做类比.</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">序号</th> 
     <th align="left">通用概念</th> 
     <th align="left">以太坊</th> 
    </tr> 
   </thead> 
   <tbody>
    <tr> 
     <td align="center">01</td> 
     <td align="left">操作系统</td> 
     <td align="left">以太坊</td> 
    </tr> 
    <tr> 
     <td align="center">02</td> 
     <td align="left">C/C++/Java/Go</td> 
     <td align="left">Solidity</td> 
    </tr> 
    <tr> 
     <td align="center">03</td> 
     <td align="left">类+函数</td> 
     <td align="left">智能合约</td> 
    </tr> 
   </tbody>
  </table> 
  <h2 id="2-智能合约">2 智能合约</h2> 
  <p>为了让大家对智能合约的编写/部署/调用有一个全面的了解.以下将以一个实例串联整个过程.</p> 
  <h3 id="21-编写智能合约">2.1 编写智能合约</h3> 
  <p>智能合约的编写,编译以及部署可以通过网页版Remix,也可通过本地truffle框架进行操作.以下以truffle框架下进行操作.<code>[注:truffle的使用请自查资料]</code> <br> 新建<code>Adoption.sol</code>文件:</p> 
  <blockquote> 
   <p><code># mkdir pet-adopt</code> // 新建项目目录 <br> <code># truffle init</code> // 初始化truffle框架, 将会自动生成如下目录结构 <br> <code># tree</code> // 查看目录结构 <br> . <br> ├── contracts // 智能合约存放目录 <br> │ └── Migrations.sol <br> ├── migrations // 智能合约部署脚本 <br> │ └── 1_initial_migration.js <br> ├── test <br> └── truffle-config.js</p> 
  </blockquote> 
  <p>进入智能合约存放目录contracts,并创建智能合约<code>Adoption.sol</code>文件,输入如下内容:</p> 
  <pre class="prettyprint"><code class="language-solidity hljs cs">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.17</span>;

contract Adoption {
    address[<span class="hljs-number">16</span>] <span class="hljs-keyword">public</span> adopters;  <span class="hljs-comment">// 保存领养者的地址</span>

    <span class="hljs-comment">// 领养宠物</span>
    function adopt(<span class="hljs-keyword">uint</span> petId) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (<span class="hljs-keyword">uint</span>) {
        require(petId &gt;= <span class="hljs-number">0</span> &amp;&amp; petId &lt;= <span class="hljs-number">15</span>);  <span class="hljs-comment">// 确保id在数组长度内</span>

        adopters[petId] = msg.sender;        <span class="hljs-comment">// 保存调用这地址</span>
        <span class="hljs-keyword">return</span> petId;
    }

    <span class="hljs-comment">// 返回领养者</span>
    function getAdopters() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (address[16]) {
        <span class="hljs-keyword">return</span> adopters;
    }
}</code></pre> 
  <h3 id="22-编译智能合约">2.2 编译智能合约</h3> 
  <p>完成智能合约的编辑后,则需编译智能合约.在项目根目录输入如下指令:</p> 
  <blockquote> 
   <p><code># truffle compile</code> // 编译智能合约 <br> Compiling ./contracts/Adoption.sol… <br> Compiling ./contracts/Migrations.sol… <br> Writing artifacts to ./build/contracts <br> <code># tree</code> // 查看目录结构 <br> . <br> ├── build <br> │ └── contracts <br> │ ├── Adoption.json // 编译结果 <br> │ └── Migrations.json <br> ├── contracts <br> │ ├── Adoption.sol <br> │ └── Migrations.sol <br> ├── migrations <br> │ └── 1_initial_migration.js <br> ├── test <br> └── truffle-config.js</p> 
  </blockquote> 
  <p>完成编译后, 编译结果将会输出到<code>./build/contracts/Adoption.json</code>文件中.</p> 
  <h3 id="23-部署智能合约">2.3 部署智能合约</h3> 
  <p>完成智能合约的编译后,便可进行智能合约的部署了.部署智能合约Adoption.sol的大体步骤如下: <br> <em>1.启动以太坊私链</em> <br> 既然要将智能合约部署到以太坊网络,在部署之前需要搭建好以太坊网络.搭建以太坊私链的过程可参考博文: &lt;&lt;<a href="http://blog.csdn.net/qifengzou/article/details/79422330" rel="nofollow">区块链 之 搭建以太坊私有链</a>&gt;&gt; <br> 以太坊私有链<code>--rpcport</code>为8545. <br> <em>2.指定以太坊平台</em> <br> 首先需要指明将智能合约部署到哪个以太坊网络,只需指明该以太坊网络的某一个节点便可. 在根目录下的<code>truffle-config.js</code>添加如下配置信息:</p> 
  <pre class="prettyprint"><code class="language-js hljs ">module.exports = {
  <span class="hljs-comment">// See &lt;http://truffleframework.com/docs/advanced/configuration&gt;</span>
  <span class="hljs-comment">// for more about customizing your Truffle configuration!</span>
  networks: {
    development: {
      host: <span class="hljs-string">"127.0.0.1"</span>,
      port: <span class="hljs-number">8545</span>,
      network_id: <span class="hljs-string">"*"</span> <span class="hljs-comment">// Match any network id</span>
    }
  }
};</code></pre> 
  <p><em>3.添加部署脚本</em> <br> 需要在migrations中添加部署脚本:<code>2_deploy_adoption.js</code>. 其格式如下:</p> 
  <pre class="prettyprint"><code class="language-js hljs "><span class="hljs-keyword">var</span> Adoption = artifacts.require(<span class="hljs-string">"Adoption"</span>);

module.exports = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(deployer)</span> {</span>
      deployer.deploy(Adoption);
};</code></pre> 
  <p><em>4.执行部署操作</em> <br> 完成以上的配置后,可通过执行以下命令部署智能合约到指定的以太坊私有链中:</p> 
  <blockquote> 
   <p><code># truffle migrate</code></p> 
  </blockquote> 
  <p>如过执行以上命令后出现以下信息时, 表示智能合约部署<strong>失败</strong>:</p> 
  <blockquote> 
   <p>Using network ‘development’.</p> 
   <p>Running migration: 1_initial_migration.js <br> Deploying Migrations… <br> … undefined <br> Error encountered, bailing. Network state unknown. Review successful transactions manually. <br> Error: authentication needed: password or unlock <br> at Object.InvalidResponse (/usr/local/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/errors.js:38:1) <br> …</p> 
  </blockquote> 
  <p>信息中存在<code>Error: authentication needed: password or unlock</code>的提示,则需要在以太坊私链中执行如下操作:</p> 
  <blockquote> 
   <p><code># geth --datadir ./data/00 --networkid 15 --port 61910 --rpc --rpcport 8545 --rpcapi 'db,net,eth,web3' --rpccorsdomain '*' console</code> <br> <code>&gt; personal.unlock(eth.accounts[0], '123456'</code>) // 解锁 <br> <code>true</code> <br> <code>&gt; miner.start()</code> // 开始挖矿.</p> 
  </blockquote> 
  <p>完成以上操作后, 便可再次向以太坊私有链部署智能合约.</p> 
  <blockquote> 
   <p><code># truffle migrate</code> / /部署智能合约 <br> Using network ‘development’.</p> 
   <p>Running migration: 1_initial_migration.js <br> Deploying Migrations… <br> … 0x0d55306dc39c028eed2867c819bd9c73d8bfbfeaac071613ef43f4456cdf72cf <br> Migrations: 0xe23b05e83fbbc5e57d8fe5e1bf0bd460b03f1541 <br> Saving successful migration to network… <br> … 0x1e646661887966b0cfeda56ce317995a9e9189126828a8b56f6627e5a20207f1 <br> Saving artifacts… <br> Running migration: 2_deploy_adopt.js <br> Deploying Adoption… <br> … 0xed2ea576bc349d6688f66758a19cb7d889da459df615a7440ed33ec8d816e486 <br> Adoption: 0xff8f47f643827fc324ac9575b8b4981d042ce5e7 <br> Saving successful migration to network… <br> … 0x99db86745721494b955e9d4f3099d91d180435a792f75f2dc085c143337e7aa2 <br> Saving artifacts…</p> 
  </blockquote> 
  <p>以上日志提示智能合约已经部署成功, 同时以上日志<code>Adoption: 0xff8f47f643827fc324ac9575b8b4981d042ce5e7</code>中也指明了智能合约Adoption地址为:<code>0xff8f47f643827fc324ac9575b8b4981d042ce5e7</code>, 该地址将会在智能合约的调用中被使用.</p> 
  <h3 id="24-调用智能合约">2.4 调用智能合约</h3> 
  <p>为了保证后续智能合约的调用能够正常执行, 以太坊私有链中至少有一个节点正在挖矿. <br> 要调用刚才部署的智能合约, 需要找到被部署智能合约的abi信息和地址. <br> <strong>1.智能合约abi信息</strong> <br> 智能合约的abi信息在编译后的文件中, 如:Adoption.sol被编译后, 其abi信息存储在Adoption.json文件中.</p> 
  <blockquote> 
   <p><code># tree</code> <br> . <br> ├── build <br> │ └── contracts <br> │ ├── Adoption.json // 智能合约abi信息存储在该文件中 <br> │ └── Migrations.json <br> ├── contracts <br> │ ├── Adoption.sol // 智能合约 <br> │ └── Migrations.sol <br> ├── migrations <br> │ ├── 1_initial_migration.js <br> │ └── 2_deploy_adopt.js <br> ├── test <br> └── truffle-config.js</p> 
  </blockquote> 
  <p>智能合约abi信息为一个数组, 如下所示:</p> 
  <pre class="prettyprint"><code class="language-json hljs "><span class="hljs-string">"abi"</span>: [
    {
      "<span class="hljs-attribute">constant</span>": <span class="hljs-value"><span class="hljs-literal">true</span></span>,
      "<span class="hljs-attribute">inputs</span>": <span class="hljs-value">[ { "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">""</span></span>, "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"uint256"</span> </span>} ]</span>,
      "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"adopters"</span></span>,
      "<span class="hljs-attribute">outputs</span>": <span class="hljs-value">[ { "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">""</span></span>, "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"address"</span> </span>} ]</span>,
      "<span class="hljs-attribute">payable</span>": <span class="hljs-value"><span class="hljs-literal">false</span></span>,
      "<span class="hljs-attribute">stateMutability</span>": <span class="hljs-value"><span class="hljs-string">"view"</span></span>,
      "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"function"</span> </span>},
    {
      "<span class="hljs-attribute">constant</span>": <span class="hljs-value"><span class="hljs-literal">false</span></span>,
      "<span class="hljs-attribute">inputs</span>": <span class="hljs-value">[ { "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"petId"</span></span>, "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"uint256"</span> </span>} ]</span>,
      "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"adopt"</span></span>,
      "<span class="hljs-attribute">outputs</span>": <span class="hljs-value">[ { "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">""</span></span>, "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"uint256"</span> </span>} ]</span>,
      "<span class="hljs-attribute">payable</span>": <span class="hljs-value"><span class="hljs-literal">false</span></span>,
      "<span class="hljs-attribute">stateMutability</span>": <span class="hljs-value"><span class="hljs-string">"nonpayable"</span></span>,
      "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"function"</span> </span>},
    {
      "<span class="hljs-attribute">constant</span>": <span class="hljs-value"><span class="hljs-literal">true</span></span>,
      "<span class="hljs-attribute">inputs</span>": <span class="hljs-value">[]</span>,
      "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"getAdopters"</span></span>,
      "<span class="hljs-attribute">outputs</span>": <span class="hljs-value">[ { "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">""</span></span>, "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"address[16]"</span> </span>} ]</span>,
      "<span class="hljs-attribute">payable</span>": <span class="hljs-value"><span class="hljs-literal">false</span></span>,
      "<span class="hljs-attribute">stateMutability</span>": <span class="hljs-value"><span class="hljs-string">"view"</span></span>,
      "<span class="hljs-attribute">type</span>": <span class="hljs-value"><span class="hljs-string">"function"</span> </span>}
  ]</code></pre> 
  <p>拷贝abi数组, 并将以上json转换成<strong>一行</strong>子串, 再切换到以太坊的geth命令中, 输入如下指令:</p> 
  <blockquote> 
   <p><code>&gt; var abi = [ { "constant": true, "inputs": [ { "name": "", "type": "uint256" } ], "name": "adopters", "outputs": [ { "name": "", "type": "address" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [ { "name": "petId", "type": "uint256" } ], "name": "adopt", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "getAdopters", "outputs": [ { "name": "", "type": "address[16]" } ], "payable": false, "stateMutability": "view", "type": "function" } ]</code></p> 
  </blockquote> 
  <p><strong>2.智能合约地址信息</strong> <br> 在2.3节中提到智能合约的地址为:<code>0xff8f47f643827fc324ac9575b8b4981d042ce5e7</code>, 可将该地址存储到geth的变量中.</p> 
  <blockquote> 
   <p><code>&gt; var addr = "0xff8f47f643827fc324ac9575b8b4981d042ce5e7"</code> // 注意:必须使用双引号</p> 
  </blockquote> 
  <p>有了智能合约的abi和地址信息后, 可通过以下语句创建新建智能合约对象.</p> 
  <blockquote> 
   <p><code>&gt; var adoption = eth.contract(abi).at(addr)</code> // 创建合约对象</p> 
  </blockquote> 
  <p>可在geth命令行中输入adoption变量名, 将会打印该变量的数据信息. 如下所示:</p> 
  <pre class="prettyprint"><code class="language-{ hljs r">  abi: [{
      constant: true,
      inputs: [{<span class="hljs-keyword">...</span>}],
      name: <span class="hljs-string">"adopters"</span>,
      outputs: [{<span class="hljs-keyword">...</span>}],
      payable: false,
      stateMutability: <span class="hljs-string">"view"</span>,
      type: <span class="hljs-string">"function"</span>
  }, {
      constant: false,
      inputs: [{<span class="hljs-keyword">...</span>}],
      name: <span class="hljs-string">"adopt"</span>,
      outputs: [{<span class="hljs-keyword">...</span>}],
      payable: false,
      stateMutability: <span class="hljs-string">"nonpayable"</span>,
      type: <span class="hljs-string">"function"</span>
  }, {
      constant: true,
      inputs: [],
      name: <span class="hljs-string">"getAdopters"</span>,
      outputs: [{<span class="hljs-keyword">...</span>}],
      payable: false,
      stateMutability: <span class="hljs-string">"view"</span>,
      type: <span class="hljs-string">"function"</span>
  }],
  address: <span class="hljs-string">"0xff8f47f643827fc324ac9575b8b4981d042ce5e7"</span>,
  transactionHash: null,
  adopt: <span class="hljs-keyword">function</span>(),
  adopters: <span class="hljs-keyword">function</span>(),
  allEvents: <span class="hljs-keyword">function</span>(),
  getAdopters: <span class="hljs-keyword">function</span>()
}</code></pre> 
  <p>在最末尾可以看到我们在Adoption.sol中编辑的函数名, 说明已获取到智能合约对象. <br> <strong>3.调用智能合约</strong> <br> 完成以上操作后, 则可以通过adoption对象调用智能合约对象了. <br> 如果调用的智能合约函数未改变合约中的数据, 则不会消耗以太坊gas. 以Adoption中的getAdopters()为例, 获取16只宠物被哪些账号收养.</p> 
  <blockquote> 
   <p><code>&gt;adoption.getAdopters.call()</code> <br> [“0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”]</p> 
  </blockquote> 
  <p>以上地址均为<code>0x0000000000000000000000000000000000000000</code>, 表示暂无人收养. <br> 如果调用的智能合约函数需要合约中的数据, 则需要消耗以太坊gas. 以Adoption中的adopt()为例, 收养第2只宠物.</p> 
  <blockquote> 
   <p><code>&gt;adoption.adopt.sendTransaction(2, {from: eth.accounts[0]})</code> <br> “0x0d1a6079e878b82870eafbbd66c311c9acad893c7389bd43c9b003a5a5416ef0”</p> 
  </blockquote> 
  <p>由于需要修改合约中的数据, 调用adopt()时需要使用sendTransaction()发起交易, 并附加发起者的账号. <br> 以上操作只是发起了交易, 但交易并不一定会被处理. 交易被处理还必须要有节点处于挖矿模式.</p> 
  <blockquote> 
   <p><code>&gt; miner.start()</code></p> 
  </blockquote> 
  <p>过了一段时间后, 再次查看宠物是否被收养成功.</p> 
  <blockquote> 
   <p><code>&gt; adoption.getAdopters()</code> <br> [“0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0xa0cf841d14ba336ffd6c1f617eb4663223790cc3”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”, <br> “0x0000000000000000000000000000000000000000”]</p> 
  </blockquote> 
  <p>可以发现索引为2的数组内容的值为<code>0xa0cf841d14ba336ffd6c1f617eb4663223790cc3</code>, 说明宠物已经收养成功.即: 发起的交易已经被执行.</p> 
  <p>至此, 智能合约的编辑/编译/部署以及最后的调用过程已经讲解完成. 对于智能合约的调用, 还可通过其他方式调用. 如:在js中如何调用智能合约, 在此未能讲述. 后续章节将会陆续补充.</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-778f64ae39.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qifengzou/article/details/79430999,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qifengzou/article/details/79430999,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
