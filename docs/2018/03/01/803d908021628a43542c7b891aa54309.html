<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Hyperledger Fabric开发（二）：创建网络 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Hyperledger Fabric开发（二）：创建网络" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="运行fabric-samples项目中的一个例子：first-network，创建第一个网络（Building Your First Network）。 该网络共有4个peer节点，划分为2个组织（organizations），以及1个单独的orderer节点，另外还需要一个容器来执行创建和加入channel、部署和执行chaincode等命令。 运行该例子需要下载的文件有：fabric-samples项目，特定的平台二进制文件，所需的镜像文件。 准备 项目下载 在已设置的GOPATH路径下从github克隆fabric-samples项目 mkdir -p ~/go/src/github.com/hyperledger cd ~/go/src/github.com/hyperledger git clone -b master https://github.com/hyperledger/fabric-samples.git cd fabric-samples 平台文件和镜像文件 一、脚本自动化下载 1.官方文档提供了极为简便的命令，运行即可完成下载 curl https://goo.gl/6wtTN5 | bash -s 1.1.0-alpha 版本可自由选择，这里选的是1.1.0-alpha 2.由于上面的curl命令使用的是google的短网址，在国内下载缓慢，文档提供了可替换的url，命令如下： curl -sSL https://github.com/hyperledger/fabric/blob/master/scripts/bootstrap.sh | bash -s 1.1.0-alpha 3.上面的下载本质上是利用fabric项目中的bootstrap.sh脚本，所以也可以直接运行https://github.com/hyperledger/fabric/blob/master/scripts/bootstrap.sh。最后将下载后的bin目录至于fabric-samples中并添加到系统环境变量。 二、手动分步下载 1.特定的二进制平台文件（Platform-specific Binaries） 先下载平台文件，打开bootstap.sh脚本文件查看源码，可以找到下载地址，选择合适的版本，当前最新是darwin-amd64-1.1.0-alpha/，然后选择hyperledger-fabric-darwin-amd64-1.1.0-alpha.tar.gz 解压后可获得bin目录，其中包含文件cryptogen, configtxgen, configtxlator和peer。将bin目录至于fabric-sample目录下并加入系统环境变量，打开配置文件vim ~/.bash_profile后添加 export PATH=$HOME/hyperledger/fabric-samples/bin:$PATH 2.镜像文件下载（images) 所需的镜像文件有peer, orderer, ca, ccenv, javaenv, kafka, zookeeper, couchdb和tools。通过docker pull命令从docker hub中逐一拉取镜像，例如： docker pull hyperledger/fabric-peer:x86_64-1.1.0-alpha 注意后面要带上标签，否则会下载失败，全部拉取完成后，为了保证网络的成功运行，需要给每个镜像打上latest标签。格式和示例如下： docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签) docker tag f00c5d490d19 docker.io/hyperledger/fabric-peer:latest 运行 1.生成配置信息 cd ~/hyperledger/fabric-samples ./byfn.sh -m generate 该命令利用平台文件中的crypotogen和configtxgen工具主要完成以下工作：生成网络成员所需的证书和密钥，生成创世排序区块（Orderer Genesis block），以及生成一系列配置channel所需的配置交易（configuration transactions），并且生成Org1和Org2的Anchor节点更新交易。成功执行后，生成crypto-config目录和channel-artifacts目录。 2.启动网络 ./byfn.sh -m up 该行命令利用docker-compose up命令运行所有镜像，主要完成的工作有：构建4个peer节点和1个orderer节点，创建channel并把4个peer节点加入其中，在各peer节点上安装chaincode并执行相关操作。 3.结束运行 ./byfn.sh -m down 该命令会终止所有正在运行的容器，删除生成的配置文件，并删除chaincode镜像。 分析 1.证书生成器 使用二进制平台文件中的cryptogen工具来为网络中的实体生成证书（certificates），这些证书是身份的象征，它们允许我们的实体在交流和交易的时候进行签名（sign）和身份验证（verify authentication）。 cryptogen工具读取包含网络拓扑信息的crypto-config.yaml配置文件来生成相关证书，并为组织和这些组织的成员生成一组证书和密钥。每个组织都分配了一个唯一的根证书（ca-cert），它将特定成员（peers and orderer）绑定到该组织。在这个典型的网络中，成员将使用证书授权（Certificate Authority）生成属于自己的证书，Hyperledger Fabric中的交易和通信由实体的私钥（keystore）签名，然后通过公钥（signcerts）进行验证。 2.配置交易生成器 configtxgen tool用来生成4个配置文件： orderer genesis block：排序服务（ordering service）的创世区块。 channel configuration transaction：通道配置交易，会在channel创建时广播给orderer。 two anchor peer transactions：指定通道上两个组织的锚节点（Anchor Peer）。 configtxgen tool读取配置文件configtx.yaml，该文件包含该简单网络的定义。 1.文件顶部的Profiles部分有两个头部，一个是TwoOrgsOrdererGenesis用于生成orderer genesis block，一个是TwoOrgsChannel，用于生成channel配置交易，这两个头部会在生成配置信息作为参数传递进去。 2.文件的Organizations部分显示该网络有3个成员，OrdererOrg，Org1，Org2。文件指定了一个联盟（SampleConsortium），由两个Peer Orgs组成。每个Org中指定了MSP的目录位置，其中两个Peer Org里还指定了AnchorPeers，该值定义了能够用于跨越组织通信（cross org gossip communication）的节点的位置。该部分将会在后续的配置中被引用。 3.文件的Orderer部份定义了一些将会用作排序相关操作参数的值，它们被编码（encode）入配置交易或者创世区块中。 配置文件中保存了网络每个成员（组织和节点）的MSP目录，因此可以将每个组织的根证书（cacerts）存储在orderer genesis block中，当网络实体与ordering service通信时，就能对实体的数字签名进行验证。过程是：通过创世排序区块中的CA证书得到CA公钥，然后用CA公钥对交易或通信中的证书进行验证，身份验证成功后得到实体节点的公钥，然后用该公钥来验证信息的完整性。 3.手动运行工具 生成证书 当前路径位于first-network目录下，bin文件在上一级目录fabric-samples中，运行以下命令后证书和秘钥（也就是MSP material）会被输出到crypto-config目录中。 ../bin/cryptogen generate --config=./crypto-config.yaml 生成创世区块 首先需要告诉configtxgen去哪找到需要的配置文件configtx.yaml，所以要在执行命令前先设置一个环境变量 export FABRIC_CFG_PATH=$PWD ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 创建channel配置交易（channel.tx） 执行命令前需要设置$CHANNEL_NAME环境变量。 export CHANNEL_NAME=mychannel ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 接下来，在我们正在构建的channel上定义两个anchor peer（for Org1 and Org2）。 ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 生成的order genesis block 和 channel transaction artifacts都将输出到channel-artifacts目录下。最终目录包含4个文件：genesis.block，channel.tx，Org1MSPanchors.tx和Org2MSPanchors.tx。 4.启动网络 注意： 在运行之前，需要修改docker-compose-cli.yaml文件，注释掉以下一行： command: /bin/bash -c &#39;./scripts/script.sh ${CHANNEL_NAME} ${DELAY}; sleep $TIMEOUT&#39; 该行代码会使cli容器运行的时候自动运行脚本script.sh，会进行创建channel，加入节点等等一系列操作，此时如果再进行手动执行，并把CHANNEL_NAME设置为mychannel，就会出现channel名称重复问题，从而报错 Error: got unexpected status: BAD_REQUEST。 运行docker-compose命令启动网络 docker-compose -f docker-compose-cli.yaml up -d 如果cli容器处于睡眠状态，可通过docker run cli重新运行。 创建channel并加入节点 CLI容器针对peer0.org1.example.com操作所需要的环境变量已经设置好了，但如果需要对其他peer或者orderer节点进行操作，则需要提供这些变量值。 首先进入CLI容器中： docker exec -it cli bash 接下来先定义CHANNEL_NAME变量，然后创建channel，将channel.tx作为创建channel请求的一部分发送给orderer，其中-c参数是channel name，-f参数是channel配置交易（channel.tx），--cafile参数指定了orderer的根证书路径，用于验证TLS握手。 export CHANNEL_NAME=mychannel peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 上述命令将生成一个&lt;channel-ID.block&gt;，在这里是mychannel.block，现在将节点peer0.org1.example.com加入channel。 peer channel join -b mychannel.block 当需要加入其它节点的时候，需要将环境变量传入，这里继续加入peer0.org2.example.com。 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel join -b mychannel.block 更新anchor peers 下面的命令将更新channel的定义从而定义anchor peers，本质上只是在channel的genesis block之上添加了一些配置信息。 定义Org1的anchor peer: peer0.org1.example.com peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 定义Org2的anchor peer：peer0.org2.example.com，同样的，需要加上环境变量 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 安装并实例化（instantiate）链码（chaincode） 这里使用的是已经存在的chaincode，应用通过chaincode与区块链进行交互，我们需要在每个peer节点上安装chaincode，源码会被存放在节点的文件系统中，然后在channel上实例化chaincode。 注意： 文档中chaincode在cli容器文件系统内的地址是 github.com/chaincode/chaincode_example02/go/ ，而我的实际路径为github.com/hyperledger/fabric/examples/chainco de/go/chaincode_example02。（更新于4.12，release-1.1版本的路径与文档中一致） 安装Golang语言编写的chaincode： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 实例化chaincode，这会在channel上初始化chaincode，并为目标节点运行一个chaincode容器。注意-P参数设置了endorsement的策略，这里是OR (&#39;Org0MSP.peer&#39;,&#39;Org1MSP.peer&#39;)，表示需要属于Org1**或者**Org2的1个peer进行1次背书（endorsement）。实例化命令如下： peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; 查询（Query） 首先查询a的值，以确保chaincode成功实例化并且状态数据库（state DB）被成功填充。 peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 查询结果为 Query Result: 100 调用（Invoke） 从a账户转移10个数额到b账户，这个命令将会把交易发送至orderer节点并创建新的block，同时更新stateDB。 peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 再次调用Query命令可得到结果Query Result: 90。 5.运行过程分析 以下是通过./byfn.sh -m up启动网络时，运行script.sh脚本所进行步骤： script.sh脚本在CLI容器内执行，该脚本执行了createChannel命令，提供了channel的名字，并且使用channel.tx作为配置文件，来创建一个channel。 createChannel的输出是一个genesis block，存储在peer的文件系统中。block中存储了channel的配置信息（由channel.tx指定）。 joinChannel命令将4个peer加入channel中，用上面创建的genesis block作为输入，创建了一条以该创世区块为开始的chain。 更新两个org的anchor peers，将Org1MSPanchors.tx和Org2MSPanchors.tx发送给ordering service以实现更新。 chaincode (chaincode_example02）被安装在peer0.org1和peer0.org2中。使chaincode在peer0.org2中实例化，将chaincode添加到channel中，运行容器dev-peer0.org2.example.com-mycc-1.0。 查询（query）peer0.org1节点中a的值，结果为100, 由于chaincode在该节点已经完成install，所以该查询操作会运行一个chaincode容器。接着在该节点中（invoke）从a的账户向b转移10金额。 在peer1.org2中下载chaincode。向该节点发送查询a的操作，同样又会运行第3个新的chaincode容器。得到查询的值为90。注意这里的每个fabric节点中，是没有数据库副本的（database replicas），即对数据库的写入是可以保证数据一致性。 阅读更多" />
<meta property="og:description" content="运行fabric-samples项目中的一个例子：first-network，创建第一个网络（Building Your First Network）。 该网络共有4个peer节点，划分为2个组织（organizations），以及1个单独的orderer节点，另外还需要一个容器来执行创建和加入channel、部署和执行chaincode等命令。 运行该例子需要下载的文件有：fabric-samples项目，特定的平台二进制文件，所需的镜像文件。 准备 项目下载 在已设置的GOPATH路径下从github克隆fabric-samples项目 mkdir -p ~/go/src/github.com/hyperledger cd ~/go/src/github.com/hyperledger git clone -b master https://github.com/hyperledger/fabric-samples.git cd fabric-samples 平台文件和镜像文件 一、脚本自动化下载 1.官方文档提供了极为简便的命令，运行即可完成下载 curl https://goo.gl/6wtTN5 | bash -s 1.1.0-alpha 版本可自由选择，这里选的是1.1.0-alpha 2.由于上面的curl命令使用的是google的短网址，在国内下载缓慢，文档提供了可替换的url，命令如下： curl -sSL https://github.com/hyperledger/fabric/blob/master/scripts/bootstrap.sh | bash -s 1.1.0-alpha 3.上面的下载本质上是利用fabric项目中的bootstrap.sh脚本，所以也可以直接运行https://github.com/hyperledger/fabric/blob/master/scripts/bootstrap.sh。最后将下载后的bin目录至于fabric-samples中并添加到系统环境变量。 二、手动分步下载 1.特定的二进制平台文件（Platform-specific Binaries） 先下载平台文件，打开bootstap.sh脚本文件查看源码，可以找到下载地址，选择合适的版本，当前最新是darwin-amd64-1.1.0-alpha/，然后选择hyperledger-fabric-darwin-amd64-1.1.0-alpha.tar.gz 解压后可获得bin目录，其中包含文件cryptogen, configtxgen, configtxlator和peer。将bin目录至于fabric-sample目录下并加入系统环境变量，打开配置文件vim ~/.bash_profile后添加 export PATH=$HOME/hyperledger/fabric-samples/bin:$PATH 2.镜像文件下载（images) 所需的镜像文件有peer, orderer, ca, ccenv, javaenv, kafka, zookeeper, couchdb和tools。通过docker pull命令从docker hub中逐一拉取镜像，例如： docker pull hyperledger/fabric-peer:x86_64-1.1.0-alpha 注意后面要带上标签，否则会下载失败，全部拉取完成后，为了保证网络的成功运行，需要给每个镜像打上latest标签。格式和示例如下： docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签) docker tag f00c5d490d19 docker.io/hyperledger/fabric-peer:latest 运行 1.生成配置信息 cd ~/hyperledger/fabric-samples ./byfn.sh -m generate 该命令利用平台文件中的crypotogen和configtxgen工具主要完成以下工作：生成网络成员所需的证书和密钥，生成创世排序区块（Orderer Genesis block），以及生成一系列配置channel所需的配置交易（configuration transactions），并且生成Org1和Org2的Anchor节点更新交易。成功执行后，生成crypto-config目录和channel-artifacts目录。 2.启动网络 ./byfn.sh -m up 该行命令利用docker-compose up命令运行所有镜像，主要完成的工作有：构建4个peer节点和1个orderer节点，创建channel并把4个peer节点加入其中，在各peer节点上安装chaincode并执行相关操作。 3.结束运行 ./byfn.sh -m down 该命令会终止所有正在运行的容器，删除生成的配置文件，并删除chaincode镜像。 分析 1.证书生成器 使用二进制平台文件中的cryptogen工具来为网络中的实体生成证书（certificates），这些证书是身份的象征，它们允许我们的实体在交流和交易的时候进行签名（sign）和身份验证（verify authentication）。 cryptogen工具读取包含网络拓扑信息的crypto-config.yaml配置文件来生成相关证书，并为组织和这些组织的成员生成一组证书和密钥。每个组织都分配了一个唯一的根证书（ca-cert），它将特定成员（peers and orderer）绑定到该组织。在这个典型的网络中，成员将使用证书授权（Certificate Authority）生成属于自己的证书，Hyperledger Fabric中的交易和通信由实体的私钥（keystore）签名，然后通过公钥（signcerts）进行验证。 2.配置交易生成器 configtxgen tool用来生成4个配置文件： orderer genesis block：排序服务（ordering service）的创世区块。 channel configuration transaction：通道配置交易，会在channel创建时广播给orderer。 two anchor peer transactions：指定通道上两个组织的锚节点（Anchor Peer）。 configtxgen tool读取配置文件configtx.yaml，该文件包含该简单网络的定义。 1.文件顶部的Profiles部分有两个头部，一个是TwoOrgsOrdererGenesis用于生成orderer genesis block，一个是TwoOrgsChannel，用于生成channel配置交易，这两个头部会在生成配置信息作为参数传递进去。 2.文件的Organizations部分显示该网络有3个成员，OrdererOrg，Org1，Org2。文件指定了一个联盟（SampleConsortium），由两个Peer Orgs组成。每个Org中指定了MSP的目录位置，其中两个Peer Org里还指定了AnchorPeers，该值定义了能够用于跨越组织通信（cross org gossip communication）的节点的位置。该部分将会在后续的配置中被引用。 3.文件的Orderer部份定义了一些将会用作排序相关操作参数的值，它们被编码（encode）入配置交易或者创世区块中。 配置文件中保存了网络每个成员（组织和节点）的MSP目录，因此可以将每个组织的根证书（cacerts）存储在orderer genesis block中，当网络实体与ordering service通信时，就能对实体的数字签名进行验证。过程是：通过创世排序区块中的CA证书得到CA公钥，然后用CA公钥对交易或通信中的证书进行验证，身份验证成功后得到实体节点的公钥，然后用该公钥来验证信息的完整性。 3.手动运行工具 生成证书 当前路径位于first-network目录下，bin文件在上一级目录fabric-samples中，运行以下命令后证书和秘钥（也就是MSP material）会被输出到crypto-config目录中。 ../bin/cryptogen generate --config=./crypto-config.yaml 生成创世区块 首先需要告诉configtxgen去哪找到需要的配置文件configtx.yaml，所以要在执行命令前先设置一个环境变量 export FABRIC_CFG_PATH=$PWD ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 创建channel配置交易（channel.tx） 执行命令前需要设置$CHANNEL_NAME环境变量。 export CHANNEL_NAME=mychannel ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 接下来，在我们正在构建的channel上定义两个anchor peer（for Org1 and Org2）。 ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 生成的order genesis block 和 channel transaction artifacts都将输出到channel-artifacts目录下。最终目录包含4个文件：genesis.block，channel.tx，Org1MSPanchors.tx和Org2MSPanchors.tx。 4.启动网络 注意： 在运行之前，需要修改docker-compose-cli.yaml文件，注释掉以下一行： command: /bin/bash -c &#39;./scripts/script.sh ${CHANNEL_NAME} ${DELAY}; sleep $TIMEOUT&#39; 该行代码会使cli容器运行的时候自动运行脚本script.sh，会进行创建channel，加入节点等等一系列操作，此时如果再进行手动执行，并把CHANNEL_NAME设置为mychannel，就会出现channel名称重复问题，从而报错 Error: got unexpected status: BAD_REQUEST。 运行docker-compose命令启动网络 docker-compose -f docker-compose-cli.yaml up -d 如果cli容器处于睡眠状态，可通过docker run cli重新运行。 创建channel并加入节点 CLI容器针对peer0.org1.example.com操作所需要的环境变量已经设置好了，但如果需要对其他peer或者orderer节点进行操作，则需要提供这些变量值。 首先进入CLI容器中： docker exec -it cli bash 接下来先定义CHANNEL_NAME变量，然后创建channel，将channel.tx作为创建channel请求的一部分发送给orderer，其中-c参数是channel name，-f参数是channel配置交易（channel.tx），--cafile参数指定了orderer的根证书路径，用于验证TLS握手。 export CHANNEL_NAME=mychannel peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 上述命令将生成一个&lt;channel-ID.block&gt;，在这里是mychannel.block，现在将节点peer0.org1.example.com加入channel。 peer channel join -b mychannel.block 当需要加入其它节点的时候，需要将环境变量传入，这里继续加入peer0.org2.example.com。 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel join -b mychannel.block 更新anchor peers 下面的命令将更新channel的定义从而定义anchor peers，本质上只是在channel的genesis block之上添加了一些配置信息。 定义Org1的anchor peer: peer0.org1.example.com peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 定义Org2的anchor peer：peer0.org2.example.com，同样的，需要加上环境变量 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 安装并实例化（instantiate）链码（chaincode） 这里使用的是已经存在的chaincode，应用通过chaincode与区块链进行交互，我们需要在每个peer节点上安装chaincode，源码会被存放在节点的文件系统中，然后在channel上实例化chaincode。 注意： 文档中chaincode在cli容器文件系统内的地址是 github.com/chaincode/chaincode_example02/go/ ，而我的实际路径为github.com/hyperledger/fabric/examples/chainco de/go/chaincode_example02。（更新于4.12，release-1.1版本的路径与文档中一致） 安装Golang语言编写的chaincode： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 实例化chaincode，这会在channel上初始化chaincode，并为目标节点运行一个chaincode容器。注意-P参数设置了endorsement的策略，这里是OR (&#39;Org0MSP.peer&#39;,&#39;Org1MSP.peer&#39;)，表示需要属于Org1**或者**Org2的1个peer进行1次背书（endorsement）。实例化命令如下： peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; 查询（Query） 首先查询a的值，以确保chaincode成功实例化并且状态数据库（state DB）被成功填充。 peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 查询结果为 Query Result: 100 调用（Invoke） 从a账户转移10个数额到b账户，这个命令将会把交易发送至orderer节点并创建新的block，同时更新stateDB。 peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 再次调用Query命令可得到结果Query Result: 90。 5.运行过程分析 以下是通过./byfn.sh -m up启动网络时，运行script.sh脚本所进行步骤： script.sh脚本在CLI容器内执行，该脚本执行了createChannel命令，提供了channel的名字，并且使用channel.tx作为配置文件，来创建一个channel。 createChannel的输出是一个genesis block，存储在peer的文件系统中。block中存储了channel的配置信息（由channel.tx指定）。 joinChannel命令将4个peer加入channel中，用上面创建的genesis block作为输入，创建了一条以该创世区块为开始的chain。 更新两个org的anchor peers，将Org1MSPanchors.tx和Org2MSPanchors.tx发送给ordering service以实现更新。 chaincode (chaincode_example02）被安装在peer0.org1和peer0.org2中。使chaincode在peer0.org2中实例化，将chaincode添加到channel中，运行容器dev-peer0.org2.example.com-mycc-1.0。 查询（query）peer0.org1节点中a的值，结果为100, 由于chaincode在该节点已经完成install，所以该查询操作会运行一个chaincode容器。接着在该节点中（invoke）从a的账户向b转移10金额。 在peer1.org2中下载chaincode。向该节点发送查询a的操作，同样又会运行第3个新的chaincode容器。得到查询的值为90。注意这里的每个fabric节点中，是没有数据库副本的（database replicas），即对数据库的写入是可以保证数据一致性。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"运行fabric-samples项目中的一个例子：first-network，创建第一个网络（Building Your First Network）。 该网络共有4个peer节点，划分为2个组织（organizations），以及1个单独的orderer节点，另外还需要一个容器来执行创建和加入channel、部署和执行chaincode等命令。 运行该例子需要下载的文件有：fabric-samples项目，特定的平台二进制文件，所需的镜像文件。 准备 项目下载 在已设置的GOPATH路径下从github克隆fabric-samples项目 mkdir -p ~/go/src/github.com/hyperledger cd ~/go/src/github.com/hyperledger git clone -b master https://github.com/hyperledger/fabric-samples.git cd fabric-samples 平台文件和镜像文件 一、脚本自动化下载 1.官方文档提供了极为简便的命令，运行即可完成下载 curl https://goo.gl/6wtTN5 | bash -s 1.1.0-alpha 版本可自由选择，这里选的是1.1.0-alpha 2.由于上面的curl命令使用的是google的短网址，在国内下载缓慢，文档提供了可替换的url，命令如下： curl -sSL https://github.com/hyperledger/fabric/blob/master/scripts/bootstrap.sh | bash -s 1.1.0-alpha 3.上面的下载本质上是利用fabric项目中的bootstrap.sh脚本，所以也可以直接运行https://github.com/hyperledger/fabric/blob/master/scripts/bootstrap.sh。最后将下载后的bin目录至于fabric-samples中并添加到系统环境变量。 二、手动分步下载 1.特定的二进制平台文件（Platform-specific Binaries） 先下载平台文件，打开bootstap.sh脚本文件查看源码，可以找到下载地址，选择合适的版本，当前最新是darwin-amd64-1.1.0-alpha/，然后选择hyperledger-fabric-darwin-amd64-1.1.0-alpha.tar.gz 解压后可获得bin目录，其中包含文件cryptogen, configtxgen, configtxlator和peer。将bin目录至于fabric-sample目录下并加入系统环境变量，打开配置文件vim ~/.bash_profile后添加 export PATH=$HOME/hyperledger/fabric-samples/bin:$PATH 2.镜像文件下载（images) 所需的镜像文件有peer, orderer, ca, ccenv, javaenv, kafka, zookeeper, couchdb和tools。通过docker pull命令从docker hub中逐一拉取镜像，例如： docker pull hyperledger/fabric-peer:x86_64-1.1.0-alpha 注意后面要带上标签，否则会下载失败，全部拉取完成后，为了保证网络的成功运行，需要给每个镜像打上latest标签。格式和示例如下： docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签) docker tag f00c5d490d19 docker.io/hyperledger/fabric-peer:latest 运行 1.生成配置信息 cd ~/hyperledger/fabric-samples ./byfn.sh -m generate 该命令利用平台文件中的crypotogen和configtxgen工具主要完成以下工作：生成网络成员所需的证书和密钥，生成创世排序区块（Orderer Genesis block），以及生成一系列配置channel所需的配置交易（configuration transactions），并且生成Org1和Org2的Anchor节点更新交易。成功执行后，生成crypto-config目录和channel-artifacts目录。 2.启动网络 ./byfn.sh -m up 该行命令利用docker-compose up命令运行所有镜像，主要完成的工作有：构建4个peer节点和1个orderer节点，创建channel并把4个peer节点加入其中，在各peer节点上安装chaincode并执行相关操作。 3.结束运行 ./byfn.sh -m down 该命令会终止所有正在运行的容器，删除生成的配置文件，并删除chaincode镜像。 分析 1.证书生成器 使用二进制平台文件中的cryptogen工具来为网络中的实体生成证书（certificates），这些证书是身份的象征，它们允许我们的实体在交流和交易的时候进行签名（sign）和身份验证（verify authentication）。 cryptogen工具读取包含网络拓扑信息的crypto-config.yaml配置文件来生成相关证书，并为组织和这些组织的成员生成一组证书和密钥。每个组织都分配了一个唯一的根证书（ca-cert），它将特定成员（peers and orderer）绑定到该组织。在这个典型的网络中，成员将使用证书授权（Certificate Authority）生成属于自己的证书，Hyperledger Fabric中的交易和通信由实体的私钥（keystore）签名，然后通过公钥（signcerts）进行验证。 2.配置交易生成器 configtxgen tool用来生成4个配置文件： orderer genesis block：排序服务（ordering service）的创世区块。 channel configuration transaction：通道配置交易，会在channel创建时广播给orderer。 two anchor peer transactions：指定通道上两个组织的锚节点（Anchor Peer）。 configtxgen tool读取配置文件configtx.yaml，该文件包含该简单网络的定义。 1.文件顶部的Profiles部分有两个头部，一个是TwoOrgsOrdererGenesis用于生成orderer genesis block，一个是TwoOrgsChannel，用于生成channel配置交易，这两个头部会在生成配置信息作为参数传递进去。 2.文件的Organizations部分显示该网络有3个成员，OrdererOrg，Org1，Org2。文件指定了一个联盟（SampleConsortium），由两个Peer Orgs组成。每个Org中指定了MSP的目录位置，其中两个Peer Org里还指定了AnchorPeers，该值定义了能够用于跨越组织通信（cross org gossip communication）的节点的位置。该部分将会在后续的配置中被引用。 3.文件的Orderer部份定义了一些将会用作排序相关操作参数的值，它们被编码（encode）入配置交易或者创世区块中。 配置文件中保存了网络每个成员（组织和节点）的MSP目录，因此可以将每个组织的根证书（cacerts）存储在orderer genesis block中，当网络实体与ordering service通信时，就能对实体的数字签名进行验证。过程是：通过创世排序区块中的CA证书得到CA公钥，然后用CA公钥对交易或通信中的证书进行验证，身份验证成功后得到实体节点的公钥，然后用该公钥来验证信息的完整性。 3.手动运行工具 生成证书 当前路径位于first-network目录下，bin文件在上一级目录fabric-samples中，运行以下命令后证书和秘钥（也就是MSP material）会被输出到crypto-config目录中。 ../bin/cryptogen generate --config=./crypto-config.yaml 生成创世区块 首先需要告诉configtxgen去哪找到需要的配置文件configtx.yaml，所以要在执行命令前先设置一个环境变量 export FABRIC_CFG_PATH=$PWD ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 创建channel配置交易（channel.tx） 执行命令前需要设置$CHANNEL_NAME环境变量。 export CHANNEL_NAME=mychannel ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 接下来，在我们正在构建的channel上定义两个anchor peer（for Org1 and Org2）。 ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 生成的order genesis block 和 channel transaction artifacts都将输出到channel-artifacts目录下。最终目录包含4个文件：genesis.block，channel.tx，Org1MSPanchors.tx和Org2MSPanchors.tx。 4.启动网络 注意： 在运行之前，需要修改docker-compose-cli.yaml文件，注释掉以下一行： command: /bin/bash -c &#39;./scripts/script.sh ${CHANNEL_NAME} ${DELAY}; sleep $TIMEOUT&#39; 该行代码会使cli容器运行的时候自动运行脚本script.sh，会进行创建channel，加入节点等等一系列操作，此时如果再进行手动执行，并把CHANNEL_NAME设置为mychannel，就会出现channel名称重复问题，从而报错 Error: got unexpected status: BAD_REQUEST。 运行docker-compose命令启动网络 docker-compose -f docker-compose-cli.yaml up -d 如果cli容器处于睡眠状态，可通过docker run cli重新运行。 创建channel并加入节点 CLI容器针对peer0.org1.example.com操作所需要的环境变量已经设置好了，但如果需要对其他peer或者orderer节点进行操作，则需要提供这些变量值。 首先进入CLI容器中： docker exec -it cli bash 接下来先定义CHANNEL_NAME变量，然后创建channel，将channel.tx作为创建channel请求的一部分发送给orderer，其中-c参数是channel name，-f参数是channel配置交易（channel.tx），--cafile参数指定了orderer的根证书路径，用于验证TLS握手。 export CHANNEL_NAME=mychannel peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 上述命令将生成一个&lt;channel-ID.block&gt;，在这里是mychannel.block，现在将节点peer0.org1.example.com加入channel。 peer channel join -b mychannel.block 当需要加入其它节点的时候，需要将环境变量传入，这里继续加入peer0.org2.example.com。 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel join -b mychannel.block 更新anchor peers 下面的命令将更新channel的定义从而定义anchor peers，本质上只是在channel的genesis block之上添加了一些配置信息。 定义Org1的anchor peer: peer0.org1.example.com peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 定义Org2的anchor peer：peer0.org2.example.com，同样的，需要加上环境变量 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 安装并实例化（instantiate）链码（chaincode） 这里使用的是已经存在的chaincode，应用通过chaincode与区块链进行交互，我们需要在每个peer节点上安装chaincode，源码会被存放在节点的文件系统中，然后在channel上实例化chaincode。 注意： 文档中chaincode在cli容器文件系统内的地址是 github.com/chaincode/chaincode_example02/go/ ，而我的实际路径为github.com/hyperledger/fabric/examples/chainco de/go/chaincode_example02。（更新于4.12，release-1.1版本的路径与文档中一致） 安装Golang语言编写的chaincode： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 实例化chaincode，这会在channel上初始化chaincode，并为目标节点运行一个chaincode容器。注意-P参数设置了endorsement的策略，这里是OR (&#39;Org0MSP.peer&#39;,&#39;Org1MSP.peer&#39;)，表示需要属于Org1**或者**Org2的1个peer进行1次背书（endorsement）。实例化命令如下： peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; 查询（Query） 首先查询a的值，以确保chaincode成功实例化并且状态数据库（state DB）被成功填充。 peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 查询结果为 Query Result: 100 调用（Invoke） 从a账户转移10个数额到b账户，这个命令将会把交易发送至orderer节点并创建新的block，同时更新stateDB。 peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 再次调用Query命令可得到结果Query Result: 90。 5.运行过程分析 以下是通过./byfn.sh -m up启动网络时，运行script.sh脚本所进行步骤： script.sh脚本在CLI容器内执行，该脚本执行了createChannel命令，提供了channel的名字，并且使用channel.tx作为配置文件，来创建一个channel。 createChannel的输出是一个genesis block，存储在peer的文件系统中。block中存储了channel的配置信息（由channel.tx指定）。 joinChannel命令将4个peer加入channel中，用上面创建的genesis block作为输入，创建了一条以该创世区块为开始的chain。 更新两个org的anchor peers，将Org1MSPanchors.tx和Org2MSPanchors.tx发送给ordering service以实现更新。 chaincode (chaincode_example02）被安装在peer0.org1和peer0.org2中。使chaincode在peer0.org2中实例化，将chaincode添加到channel中，运行容器dev-peer0.org2.example.com-mycc-1.0。 查询（query）peer0.org1节点中a的值，结果为100, 由于chaincode在该节点已经完成install，所以该查询操作会运行一个chaincode容器。接着在该节点中（invoke）从a的账户向b转移10金额。 在peer1.org2中下载chaincode。向该节点发送查询a的操作，同样又会运行第3个新的chaincode容器。得到查询的值为90。注意这里的每个fabric节点中，是没有数据库副本的（database replicas），即对数据库的写入是可以保证数据一致性。 阅读更多","@type":"BlogPosting","url":"/2018/03/01/803d908021628a43542c7b891aa54309.html","headline":"Hyperledger Fabric开发（二）：创建网络","dateModified":"2018-03-01T00:00:00+08:00","datePublished":"2018-03-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/03/01/803d908021628a43542c7b891aa54309.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Hyperledger Fabric开发（二）：创建网络</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <blockquote> 
   <p>运行<strong>fabric-samples</strong>项目中的一个例子：<strong>first-network</strong>，创建第一个网络（Building Your First Network）。 <br> 该网络共有4个peer节点，划分为2个组织（organizations），以及1个单独的orderer节点，另外还需要一个容器来执行创建和加入channel、部署和执行chaincode等命令。 <br> 运行该例子需要下载的文件有：<strong>fabric-samples项目</strong>，<strong>特定的平台二进制文件</strong>，<strong>所需的镜像文件</strong>。</p> 
  </blockquote> 
  <h3 id="准备"><strong>准备</strong></h3> 
  <h5 id="项目下载"><strong>项目下载</strong></h5> 
  <p>在已设置的<code>GOPATH</code>路径下从<code>github</code>克隆<code>fabric-samples</code>项目</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">mkdir -p ~/go/src/github<span class="hljs-preprocessor">.com</span>/hyperledger
cd ~/go/src/github<span class="hljs-preprocessor">.com</span>/hyperledger
git clone -b master https://github<span class="hljs-preprocessor">.com</span>/hyperledger/fabric-samples<span class="hljs-preprocessor">.git</span>
cd fabric-samples</code></pre> 
  <h5 id="平台文件和镜像文件"><strong>平台文件和镜像文件</strong></h5> 
  <p><strong>一、脚本自动化下载</strong></p> 
  <p>1.官方文档提供了极为简便的命令，运行即可完成下载</p> 
  <pre class="prettyprint"><code class=" hljs bash">curl https://goo.gl/<span class="hljs-number">6</span>wtTN5 | bash <span class="hljs-operator">-s</span> <span class="hljs-number">1.1</span>.<span class="hljs-number">0</span>-alpha</code></pre> 
  <p>版本可自由选择，这里选的是<code>1.1.0-alpha</code></p> 
  <p>2.由于上面的<code>curl</code>命令使用的是google的短网址，在国内下载缓慢，文档提供了可替换的<code>url</code>，命令如下：</p> 
  <pre class="prettyprint"><code class=" hljs ruby">curl -sSL <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/github.com/hyperledger</span><span class="hljs-regexp">/fabric/blob</span><span class="hljs-regexp">/master/scripts</span><span class="hljs-regexp">/bootstrap.sh | bash -s 1.1.0-alpha</span></code></pre> 
  <p>3.上面的下载本质上是利用<code>fabric</code>项目中的<code>bootstrap.sh</code>脚本，所以也可以直接运行<a href="https://github.com/hyperledger/fabric/blob/master/scripts/bootstrap.sh" rel="nofollow">https://github.com/hyperledger/fabric/blob/master/scripts/bootstrap.sh</a>。最后将下载后的<code>bin</code>目录至于<code>fabric-samples</code>中并添加到系统环境变量。</p> 
  <p><strong>二、手动分步下载</strong></p> 
  <p><strong>1.特定的二进制平台文件</strong>（Platform-specific Binaries） <br> 先下载平台文件，打开<code>bootstap.sh</code>脚本文件查看源码，可以找到<a href="https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric" rel="nofollow">下载地址</a>，选择合适的版本，当前最新是<code>darwin-amd64-1.1.0-alpha/</code>，然后选择<code>hyperledger-fabric-darwin-amd64-1.1.0-alpha.tar.gz</code> <br> 解压后可获得<code>bin</code>目录，其中包含文件<code>cryptogen</code>, <code>configtxgen</code>, <code>configtxlator</code>和<code>peer</code>。将<code>bin</code>目录至于<code>fabric-sample</code>目录下并加入系统环境变量，打开配置文件<code>vim ~/.bash_profile</code>后添加</p> 
  <pre class="prettyprint"><code class=" hljs bash"><span class="hljs-keyword">export</span> PATH=<span class="hljs-variable">$HOME</span>/hyperledger/fabric-samples/bin:<span class="hljs-variable">$PATH</span></code></pre> 
  <p><strong>2.镜像文件下载</strong>（images) <br> 所需的镜像文件有<strong>peer, orderer, ca, ccenv, javaenv, kafka, zookeeper, couchdb</strong>和<strong>tools</strong>。通过<code>docker pull</code>命令从<code>docker hub</code>中逐一拉取镜像，例如：</p> 
  <pre class="prettyprint"><code class=" hljs lasso">docker pull hyperledger/fabric<span class="hljs-attribute">-peer</span>:x86_64<span class="hljs-subst">-</span><span class="hljs-number">1.1</span><span class="hljs-number">.0</span><span class="hljs-attribute">-alpha</span></code></pre> 
  <p>注意后面要带上标签，否则会下载失败，全部拉取完成后，为了保证网络的成功运行，需要给每个镜像打上<code>latest</code>标签。格式和示例如下：</p> 
  <pre class="prettyprint"><code class=" hljs lasso">docker <span class="hljs-built_in">tag</span> IMAGEID(镜像id) REPOSITORY:<span class="hljs-built_in">TAG</span>（仓库：标签)
docker <span class="hljs-built_in">tag</span> f00c5d490d19 docker<span class="hljs-built_in">.</span>io/hyperledger/fabric<span class="hljs-attribute">-peer</span>:latest</code></pre> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180301134155376?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhheXVqaWU1MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <h3 id="运行">运行</h3> 
  <h5 id="1生成配置信息">1.生成配置信息</h5> 
  <pre class="prettyprint"><code class=" hljs lasso">cd ~/hyperledger/fabric<span class="hljs-attribute">-samples</span>
<span class="hljs-built_in">.</span>/byfn<span class="hljs-built_in">.</span>sh <span class="hljs-attribute">-m</span> generate</code></pre> 
  <p>该命令利用平台文件中的<code>crypotogen</code>和<code>configtxgen</code>工具主要完成以下工作：生成网络成员所需的证书和密钥，生成创世排序区块（Orderer Genesis block），以及生成一系列配置<code>channel</code>所需的配置交易（configuration transactions），并且生成Org1和Org2的<code>Anchor</code>节点更新交易。成功执行后，生成<code>crypto-config</code>目录和channel-artifacts目录。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180301164506440?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhheXVqaWU1MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <h5 id="2启动网络">2.启动网络</h5> 
  <pre class="prettyprint"><code class=" hljs avrasm">./byfn<span class="hljs-preprocessor">.sh</span> -m up</code></pre> 
  <p>该行命令利用<code>docker-compose up</code>命令运行所有镜像，主要完成的工作有：构建4个peer节点和1个<code>orderer</code>节点，创建<code>channel</code>并把4个peer节点加入其中，在各peer节点上安装<code>chaincode</code>并执行相关操作。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180301164532483?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhheXVqaWU1MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p> 
  <p>3.结束运行</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">./byfn<span class="hljs-preprocessor">.sh</span> -m down</code></pre> 
  <p>该命令会终止所有正在运行的容器，删除生成的配置文件，并删除chaincode镜像。</p> 
  <h3 id="分析">分析</h3> 
  <h5 id="1证书生成器">1.证书生成器</h5> 
  <ul> 
   <li><p>使用二进制平台文件中的<code>cryptogen</code>工具来为网络中的实体生成证书（certificates），这些证书是身份的象征，它们允许我们的实体在交流和交易的时候进行签名（sign）和身份验证（verify authentication）。</p></li> 
   <li><p><code>cryptogen</code>工具读取包含网络拓扑信息的<code>crypto-config.yaml</code>配置文件来生成相关证书，并为<strong>组织</strong>和这些<strong>组织的成员</strong>生成一组证书和密钥。每个组织都分配了一个唯一的根证书（ca-cert），它将特定成员（peers and orderer）绑定到该组织。在这个典型的网络中，成员将使用证书授权（Certificate Authority）生成属于自己的证书，Hyperledger Fabric中的交易和通信由实体的私钥（keystore）签名，然后通过公钥（signcerts）进行验证。</p></li> 
  </ul> 
  <h5 id="2配置交易生成器">2.配置交易生成器</h5> 
  <ul> 
   <li><p><code>configtxgen tool</code>用来生成4个配置文件： <br> <strong>orderer genesis block：</strong>排序服务（ordering service）的创世区块。 <br> <strong>channel configuration transaction：</strong>通道配置交易，会在channel创建时广播给orderer。 <br> <strong>two anchor peer transactions：</strong>指定通道上两个组织的锚节点（Anchor Peer）。</p></li> 
   <li><p><code>configtxgen tool</code>读取配置文件<code>configtx.yaml</code>，该文件包含该简单网络的定义。 <br> 1.文件顶部的<code>Profiles</code>部分有两个头部，一个是<code>TwoOrgsOrdererGenesis</code>用于生成orderer genesis block，一个是<code>TwoOrgsChannel</code>，用于生成channel配置交易，这两个头部会在生成配置信息作为参数传递进去。 <br> 2.文件的<code>Organizations</code>部分显示该网络有3个成员，OrdererOrg，Org1，Org2。文件指定了一个联盟（SampleConsortium），由两个Peer Orgs组成。每个Org中指定了MSP的目录位置，其中两个Peer Org里还指定了<code>AnchorPeers</code>，该值定义了能够用于跨越组织通信（cross org gossip communication）的节点的位置。该部分将会在后续的配置中被引用。 <br> 3.文件的<code>Orderer</code>部份定义了一些将会用作排序相关操作参数的值，它们被编码（encode）入配置交易或者创世区块中。</p></li> 
   <li><p>配置文件中保存了网络每个成员（组织和节点）的MSP目录，因此可以将每个组织的根证书（cacerts）存储在orderer genesis block中，当网络实体与ordering service通信时，就能对实体的数字签名进行验证。过程是：通过创世排序区块中的CA证书得到CA公钥，然后用CA公钥对交易或通信中的证书进行验证，身份验证成功后得到实体节点的公钥，然后用该公钥来验证信息的完整性。</p></li> 
  </ul> 
  <h5 id="3手动运行工具">3.手动运行工具</h5> 
  <ul> 
   <li><p><strong>生成证书</strong> <br> 当前路径位于<code>first-network</code>目录下，<code>bin</code>文件在上一级目录<code>fabric-samples</code>中，运行以下命令后证书和秘钥（也就是MSP material）会被输出到<code>crypto-config</code>目录中。</p> <pre class="prettyprint"><code class=" hljs vhdl">../bin/cryptogen <span class="hljs-keyword">generate</span> <span class="hljs-comment">--config=./crypto-config.yaml</span>
</code></pre></li> 
   <li><p><strong>生成创世区块</strong> <br> 首先需要告诉<code>configtxgen</code>去哪找到需要的配置文件<code>configtx.yaml</code>，所以要在执行命令前先设置一个环境变量</p> <pre class="prettyprint"><code class=" hljs lasso">export FABRIC_CFG_PATH<span class="hljs-subst">=</span><span class="hljs-variable">$PWD</span>
<span class="hljs-built_in">..</span>/bin/configtxgen <span class="hljs-attribute">-profile</span> TwoOrgsOrdererGenesis <span class="hljs-attribute">-outputBlock</span> <span class="hljs-built_in">.</span>/channel<span class="hljs-attribute">-artifacts</span>/genesis<span class="hljs-built_in">.</span>block
</code></pre></li> 
   <li><p><strong>创建channel配置交易（channel.tx）</strong> <br> 执行命令前需要设置<code>$CHANNEL_NAME</code>环境变量。</p> <pre class="prettyprint"><code class=" hljs lasso">export CHANNEL_NAME<span class="hljs-subst">=</span>mychannel
<span class="hljs-built_in">..</span>/bin/configtxgen <span class="hljs-attribute">-profile</span> TwoOrgsChannel <span class="hljs-attribute">-outputCreateChannelTx</span> <span class="hljs-built_in">.</span>/channel<span class="hljs-attribute">-artifacts</span>/channel<span class="hljs-built_in">.</span>tx <span class="hljs-attribute">-channelID</span> <span class="hljs-variable">$CHANNEL_NAME</span></code></pre> <p>接下来，在我们正在构建的channel上定义两个<code>anchor peer</code>（for Org1 and Org2）。</p> <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-built_in">..</span>/bin/configtxgen <span class="hljs-attribute">-profile</span> TwoOrgsChannel <span class="hljs-attribute">-outputAnchorPeersUpdate</span> <span class="hljs-built_in">.</span>/channel<span class="hljs-attribute">-artifacts</span>/Org1MSPanchors<span class="hljs-built_in">.</span>tx <span class="hljs-attribute">-channelID</span> <span class="hljs-variable">$CHANNEL_NAME</span> <span class="hljs-attribute">-asOrg</span> Org1MSP
<span class="hljs-built_in">..</span>/bin/configtxgen <span class="hljs-attribute">-profile</span> TwoOrgsChannel <span class="hljs-attribute">-outputAnchorPeersUpdate</span> <span class="hljs-built_in">.</span>/channel<span class="hljs-attribute">-artifacts</span>/Org2MSPanchors<span class="hljs-built_in">.</span>tx <span class="hljs-attribute">-channelID</span> <span class="hljs-variable">$CHANNEL_NAME</span> <span class="hljs-attribute">-asOrg</span> Org2MSP</code></pre> <p>生成的order genesis block 和 channel transaction artifacts都将输出到<code>channel-artifacts</code>目录下。最终目录包含4个文件：<strong>genesis.block，channel.tx，Org1MSPanchors.tx和Org2MSPanchors.tx</strong>。</p></li> 
  </ul> 
  <h5 id="4启动网络">4.启动网络</h5> 
  <ul> 
   <li><p><strong>注意：</strong> 在运行之前，需要修改<code>docker-compose-cli.yaml</code>文件，注释掉以下一行：</p> <pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-command"><span class="hljs-keyword">command</span>: /<span class="hljs-title">bin</span>/<span class="hljs-title">bash</span> -<span class="hljs-title">c</span> <span class="hljs-string">'./scripts/script.sh ${CHANNEL_NAME} ${DELAY}; sleep $TIMEOUT'</span></span></code></pre> <p>该行代码会使cli容器运行的时候自动运行脚本<code>script.sh</code>，会进行创建channel，加入节点等等一系列操作，此时如果再进行手动执行，并把<code>CHANNEL_NAME</code>设置为mychannel，就会出现channel名称重复问题，从而报错 <code>Error: got unexpected status: BAD_REQUEST</code>。</p> <p>运行<code>docker-compose</code>命令启动网络</p> <pre class="prettyprint"><code class=" hljs lasso">docker<span class="hljs-attribute">-compose</span> <span class="hljs-attribute">-f</span> docker<span class="hljs-attribute">-compose</span><span class="hljs-attribute">-cli</span><span class="hljs-built_in">.</span>yaml up <span class="hljs-attribute">-d</span></code></pre> <p>如果cli容器处于睡眠状态，可通过<code>docker run cli</code>重新运行。</p></li> 
   <li><p><strong>创建channel并加入节点</strong> <br> CLI容器针对<code>peer0.org1.example.com</code>操作所需要的环境变量已经设置好了，但如果需要对其他peer或者orderer节点进行操作，则需要提供这些变量值。 <br> 首先进入CLI容器中：</p> <pre class="prettyprint"><code class=" hljs bash">docker <span class="hljs-keyword">exec</span> -it cli bash</code></pre> <p>接下来先定义<code>CHANNEL_NAME</code>变量，然后创建channel，将<code>channel.tx</code>作为创建channel请求的一部分发送给orderer，其中<code>-c</code>参数是channel name，<code>-f</code>参数是channel配置交易（channel.tx），<code>--cafile</code>参数指定了orderer的根证书路径，用于验证TLS握手。</p> <pre class="prettyprint"><code class=" hljs avrasm">export CHANNEL_NAME=mychannel
peer channel create -o orderer<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>:<span class="hljs-number">7050</span> -c $CHANNEL_NAME -f ./channel-artifacts/channel<span class="hljs-preprocessor">.tx</span> --tls --cafile /opt/gopath/src/github<span class="hljs-preprocessor">.com</span>/hyperledger/fabric/peer/crypto/ordererOrganizations/example<span class="hljs-preprocessor">.com</span>/orderers/orderer<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>/msp/tlscacerts/tlsca<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>-cert<span class="hljs-preprocessor">.pem</span>
</code></pre> <p>上述命令将生成一个<code>&lt;channel-ID.block&gt;</code>，在这里是<code>mychannel.block</code>，现在将节点<code>peer0.org1.example.com</code>加入channel。</p> <pre class="prettyprint"><code class=" hljs oxygene">peer channel <span class="hljs-keyword">join</span> -b mychannel.<span class="hljs-keyword">block</span></code></pre> <p>当需要加入其它节点的时候，需要将环境变量传入，这里继续加入<code>peer0.org2.example.com</code>。</p> <pre class="prettyprint"><code class=" hljs avrasm">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github<span class="hljs-preprocessor">.com</span>/hyperledger/fabric/peer/crypto/peerOrganizations/org2<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>/users/Admin@org2<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>/msp CORE_PEER_ADDRESS=peer0<span class="hljs-preprocessor">.org</span>2<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>:<span class="hljs-number">7051</span> CORE_PEER_LOCALMSPID=<span class="hljs-string">"Org2MSP"</span> CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github<span class="hljs-preprocessor">.com</span>/hyperledger/fabric/peer/crypto/peerOrganizations/org2<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>/peers/peer0<span class="hljs-preprocessor">.org</span>2<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>/tls/ca<span class="hljs-preprocessor">.crt</span> peer channel join -b mychannel<span class="hljs-preprocessor">.block</span>
</code></pre></li> 
   <li><p><strong>更新anchor peers</strong> <br> 下面的命令将更新channel的定义从而定义anchor peers，本质上只是在channel的genesis block之上添加了一些配置信息。 <br> 定义Org1的anchor peer: <code>peer0.org1.example.com</code></p> <pre class="prettyprint"><code class=" hljs avrasm">peer channel update -o orderer<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>:<span class="hljs-number">7050</span> -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors<span class="hljs-preprocessor">.tx</span> --tls --cafile /opt/gopath/src/github<span class="hljs-preprocessor">.com</span>/hyperledger/fabric/peer/crypto/ordererOrganizations/example<span class="hljs-preprocessor">.com</span>/orderers/orderer<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>/msp/tlscacerts/tlsca<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>-cert<span class="hljs-preprocessor">.pem</span>
</code></pre> <p>定义Org2的anchor peer：<code>peer0.org2.example.com</code>，同样的，需要加上环境变量</p> <pre class="prettyprint"><code class=" hljs avrasm">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github<span class="hljs-preprocessor">.com</span>/hyperledger/fabric/peer/crypto/peerOrganizations/org2<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>/users/Admin@org2<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>/msp CORE_PEER_ADDRESS=peer0<span class="hljs-preprocessor">.org</span>2<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>:<span class="hljs-number">7051</span> CORE_PEER_LOCALMSPID=<span class="hljs-string">"Org2MSP"</span> CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github<span class="hljs-preprocessor">.com</span>/hyperledger/fabric/peer/crypto/peerOrganizations/org2<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>/peers/peer0<span class="hljs-preprocessor">.org</span>2<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>/tls/ca<span class="hljs-preprocessor">.crt</span> peer channel update -o orderer<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>:<span class="hljs-number">7050</span> -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors<span class="hljs-preprocessor">.tx</span> --tls --cafile /opt/gopath/src/github<span class="hljs-preprocessor">.com</span>/hyperledger/fabric/peer/crypto/ordererOrganizations/example<span class="hljs-preprocessor">.com</span>/orderers/orderer<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>/msp/tlscacerts/tlsca<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span>-cert<span class="hljs-preprocessor">.pem</span></code></pre></li> 
   <li><p><strong>安装并实例化（instantiate）链码（chaincode）</strong> <br> 这里使用的是已经存在的<strong>chaincode</strong>，应用通过chaincode与区块链进行交互，我们需要在每个peer节点上安装chaincode，源码会被存放在节点的文件系统中，然后在channel上实例化chaincode。 <br> <strong>注意：</strong> 文档中chaincode在cli容器文件系统内的地址是 <br> <code>github.com/chaincode/chaincode_example02/go/</code> <br> ，而我的实际路径为<code>github.com/hyperledger/fabric/examples/chainco <br> de/go/chaincode_example02</code>。（更新于4.12，release-1.1版本的路径与文档中一致） <br> 安装Golang语言编写的chaincode：</p> <pre class="prettyprint"><code class=" hljs lasso">peer chaincode install <span class="hljs-attribute">-n</span> mycc <span class="hljs-attribute">-v</span> <span class="hljs-number">1.0</span> <span class="hljs-attribute">-p</span> github<span class="hljs-built_in">.</span>com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</code></pre> <p>实例化chaincode，这会在channel上初始化chaincode，并为目标节点运行一个chaincode容器。注意<code>-P</code>参数设置了<strong>endorsement</strong>的策略，这里是<code>OR ('Org0MSP.peer','Org1MSP.peer')</code>，表示需要属于Org1**或者**Org2的1个peer进行1次背书（endorsement）。实例化命令如下：</p> <pre class="prettyprint"><code class=" hljs lasso">peer chaincode instantiate <span class="hljs-attribute">-o</span> orderer<span class="hljs-built_in">.</span>example<span class="hljs-built_in">.</span>com:<span class="hljs-number">7050</span> <span class="hljs-subst">--</span>tls <span class="hljs-subst">--</span>cafile /opt/gopath/src/github<span class="hljs-built_in">.</span>com/hyperledger/fabric/peer/crypto/ordererOrganizations/example<span class="hljs-built_in">.</span>com/orderers/orderer<span class="hljs-built_in">.</span>example<span class="hljs-built_in">.</span>com/msp/tlscacerts/tlsca<span class="hljs-built_in">.</span>example<span class="hljs-built_in">.</span>com<span class="hljs-attribute">-cert</span><span class="hljs-built_in">.</span>pem <span class="hljs-attribute">-C</span> <span class="hljs-variable">$CHANNEL_NAME</span> <span class="hljs-attribute">-n</span> mycc <span class="hljs-attribute">-v</span> <span class="hljs-number">1.0</span> <span class="hljs-attribute">-c</span> <span class="hljs-string">'{"Args":["init","a", "100", "b","200"]}'</span> <span class="hljs-attribute">-P</span> <span class="hljs-string">"OR ('Org1MSP.peer','Org2MSP.peer')"</span></code></pre></li> 
   <li><p><strong>查询（Query）</strong> <br> 首先查询a的值，以确保chaincode成功实例化并且状态数据库（state DB）被成功填充。</p> <pre class="prettyprint"><code class=" hljs lasso">peer chaincode query <span class="hljs-attribute">-C</span> <span class="hljs-variable">$CHANNEL_NAME</span> <span class="hljs-attribute">-n</span> mycc <span class="hljs-attribute">-c</span> <span class="hljs-string">'{"Args":["query","a"]}'</span></code></pre> <p>查询结果为 <code>Query Result: 100</code></p></li> 
   <li><p><strong>调用（Invoke）</strong> <br> 从a账户转移10个数额到b账户，这个命令将会把交易发送至orderer节点并创建新的block，同时更新stateDB。</p> <pre class="prettyprint"><code class=" hljs lasso">peer chaincode invoke <span class="hljs-attribute">-o</span> orderer<span class="hljs-built_in">.</span>example<span class="hljs-built_in">.</span>com:<span class="hljs-number">7050</span>  <span class="hljs-subst">--</span>tls <span class="hljs-subst">--</span>cafile /opt/gopath/src/github<span class="hljs-built_in">.</span>com/hyperledger/fabric/peer/crypto/ordererOrganizations/example<span class="hljs-built_in">.</span>com/orderers/orderer<span class="hljs-built_in">.</span>example<span class="hljs-built_in">.</span>com/msp/tlscacerts/tlsca<span class="hljs-built_in">.</span>example<span class="hljs-built_in">.</span>com<span class="hljs-attribute">-cert</span><span class="hljs-built_in">.</span>pem  <span class="hljs-attribute">-C</span> <span class="hljs-variable">$CHANNEL_NAME</span> <span class="hljs-attribute">-n</span> mycc <span class="hljs-attribute">-c</span> <span class="hljs-string">'{"Args":["invoke","a","b","10"]}'</span></code></pre> <p>再次调用Query命令可得到结果<code>Query Result: 90</code>。</p></li> 
  </ul> 
  <h5 id="5运行过程分析"><strong>5.运行过程分析</strong></h5> 
  <p>以下是通过<code>./byfn.sh -m up</code>启动网络时，运行<code>script.sh</code>脚本所进行步骤：</p> 
  <ul> 
   <li><code>script.sh</code>脚本在CLI容器内执行，该脚本执行了<code>createChannel</code>命令，提供了channel的名字，并且使用<code>channel.tx</code>作为配置文件，来创建一个channel。</li> 
   <li><code>createChannel</code>的输出是一个genesis block，存储在peer的文件系统中。block中存储了channel的配置信息（由<code>channel.tx</code>指定）。</li> 
   <li><code>joinChannel</code>命令将4个peer加入channel中，用上面创建的<code>genesis block</code>作为输入，创建了一条以该创世区块为开始的<strong>chain</strong>。</li> 
   <li>更新两个org的<code>anchor peers</code>，将<code>Org1MSPanchors.tx</code>和<code>Org2MSPanchors.tx</code>发送给<code>ordering service</code>以实现更新。</li> 
   <li><strong>chaincode</strong> (chaincode_example02）被安装在<code>peer0.org1</code>和<code>peer0.org2</code>中。使chaincode在<code>peer0.org2</code>中实例化，将chaincode添加到channel中，运行容器<code>dev-peer0.org2.example.com-mycc-1.0</code>。</li> 
   <li>查询（query）<code>peer0.org1</code>节点中a的值，结果为100, 由于chaincode在该节点已经完成install，所以该查询操作会运行一个chaincode容器。接着在该节点中（invoke）从a的账户向b转移10金额。</li> 
   <li>在<code>peer1.org2</code>中下载chaincode。向该节点发送查询a的操作，同样又会运行第3个新的chaincode容器。得到查询的值为90。注意这里的每个fabric节点中，是没有数据库副本的（database replicas），即对数据库的写入是可以保证数据一致性。</li> 
  </ul> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/zhayujie5200/article/details/79414776,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/zhayujie5200/article/details/79414776,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
