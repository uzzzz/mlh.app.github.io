<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>智能合约代币编译、部署、调用 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="智能合约代币编译、部署、调用" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="一、智能合约发行代币流程 1、智能合约代币协议ERC20 &nbsp; &nbsp; &nbsp; &nbsp; 代币（token）在以太坊中代表数字资产，并不是所有的代币都符合特定的规范。基于ERC20的代币更容易互换，也可以与各种钱包dapp兼容。标准化非常有利，也就意味着这些资产可以用于不同的平台和项目，否则只能用在特定的场合。 &nbsp; &nbsp; &nbsp; &nbsp; ERC20协议需要实现的接口标准如下： contract ERC20 { /* 代币总量 */ function totalSupply() constant returns (uint totalSupply); /* 账户代币查询 *／ function balanceOf(address _owner) constant returns (uint balance); /* 代币转账（从自己账户） */ function transfer(address _to, uint _value) returns (bool success); /* 代币转账（从委托账户） */ function transferFrom(address _from, address _to, uint _value) returns (bool success); /* 在自己账户设置_spender账户的委托金 */ function approve(address _spender, uint _value) returns (bool success); /* 返回_spender仍然被允许从_owner提取的金额。 */ function allowance(address _owner, address _spender) constant returns (uint remaining); /* 事件：转账事件通知 */ event Transfer(address indexed _from, address indexed _to, uint _value); /* 事件：委托设置事件通知 */ event Approval(address indexed _owner, address indexed _spender, uint _value); } &nbsp; &nbsp; &nbsp; &nbsp; 官方一个功能基本完整的代币合约： /* 一个相对比较完善的代币合约 */ pragma solidity ^0.4.16; /* 创建一个父类， 账户管理员 */ contract owned { address public owner; function owned() public { owner = msg.sender; } /* modifier是修改标志 */ modifier onlyOwner { require(msg.sender == owner); _; } /* 修改管理员账户， onlyOwner代表只能是用户管理员来修改 */ function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } /* receiveApproval服务合约指示代币合约将代币从发送者的账户转移到服务合约的账户（通过调用服务合约的 */ interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { // 代币（token）的公共变量 string public name; //代币名字 string public symbol; //代币符号 uint8 public decimals = 18; //代币小数点位数， 18是默认， 尽量不要更改 uint256 public totalSupply; //代币总量 // 记录各个账户的代币数目 mapping (address =&gt; uint256) public balanceOf; // A账户存在B账户资金 mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; // 转账通知事件 event Transfer(address indexed from, address indexed to, uint256 value); // 销毁金额通知事件 event Burn(address indexed from, uint256 value); /* 构造函数 */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); // 根据decimals计算代币的数量 balanceOf[msg.sender] = totalSupply; // 给生成者所有的代币数量 name = tokenName; // 设置代币的名字 symbol = tokenSymbol; // 设置代币的符号 } /* 私有的交易函数 */ function _transfer(address _from, address _to, uint _value) internal { // 防止转移到0x0， 用burn代替这个功能 require(_to != 0x0); // 检测发送者是否有足够的资金 require(balanceOf[_from] &gt;= _value); // 检查是否溢出（数据类型的溢出） require(balanceOf[_to] + _value &gt; balanceOf[_to]); // 将此保存为将来的断言， 函数最后会有一个检验 uint previousBalances = balanceOf[_from] + balanceOf[_to]; // 减少发送者资产 balanceOf[_from] -= _value; // 增加接收者的资产 balanceOf[_to] += _value; Transfer(_from, _to, _value); // 断言检测， 不应该为错 assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /* 传递tokens */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /* 从其他账户转移资产 */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /* 授权第三方从发送者账户转移代币，然后通过transferFrom()函数来执行第三方的转移操作 */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /* 为其他地址设置津贴， 并通知 发送者通知代币合约, 代币合约通知服务合约receiveApproval, 服务合约指示代币合约将代币从发送者的账户转移到服务合约的账户（通过调用服务合约的transferFrom) */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * 销毁代币 */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough balanceOf[msg.sender] -= _value; // Subtract from the sender totalSupply -= _value; // Updates totalSupply Burn(msg.sender, _value); return true; } /** * 从其他账户销毁代币 */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] &gt;= _value); // Check if the targeted balance is enough require(_value &lt;= allowance[_from][msg.sender]); // Check allowance balanceOf[_from] -= _value; // Subtract from the targeted balance allowance[_from][msg.sender] -= _value; // Subtract from the sender&#39;s allowance totalSupply -= _value; // Update totalSupply Burn(_from, _value); return true; } } /******************************************/ /* ADVANCED TOKEN STARTS HERE */ /******************************************/ contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; /* 冻结账户 */ mapping (address =&gt; bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /* 构造函数 */ function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} /* 转账， 比父类加入了账户冻结 */ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] &gt;= _value); // Check if the sender has enough require (balanceOf[_to] + _value &gt; balanceOf[_to]); // Check for overflows require(!frozenAccount[_from]); // Check if sender is frozen require(!frozenAccount[_to]); // Check if recipient is frozen balanceOf[_from] -= _value; // Subtract from the sender balanceOf[_to] += _value; // Add the same to the recipient Transfer(_from, _to, _value); } /// 向指定账户增发资金 function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); } /// 冻结 or 解冻账户 function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } /// @notice Buy tokens from contract by sending ether function buy() payable public { uint amount = msg.value / buyPrice; // calculates the amount _transfer(this, msg.sender, amount); // makes the transfers } function sell(uint256 amount) public { require(this.balance &gt;= amount * sellPrice); // checks if the contract has enough ether to buy _transfer(msg.sender, this, amount); // makes the transfers msg.sender.transfer(amount * sellPrice); // sends ether to the seller. It&#39;s important to do this last to avoid recursion attacks } } 2、代币合约编译、部署、调用 &nbsp; &nbsp; &nbsp; &nbsp; 代币合约部署方式很多，本地工具有truffle，官方有网页编译器remix，另外以太坊官方钱包也可以完成合约部署。本文主要介绍从官方remix编译器编译、部署到测试私链的方法。并将代币添加到，在以太坊官方钱包完成转账。 &nbsp; &nbsp; &nbsp; &nbsp; 官方remix编译器地址：http://remix.ethereum.org/ 合约编译，步骤图示如下所示： 将合约代码写入编译器代码编辑区。 在右侧compile工具栏执行&quot;Start to compile&quot; 编译完毕右侧会出现代码调试信息。 合约部署，步骤： 点击右侧工具栏run选项，出现如下界面。 选择要部署的网络，并选择要合约部署的外部账户。 填入构造函数参数后，点击create完成部署（部署网络需要有节点在挖矿、外部账户中有足量以太币且账户已解锁） remix编译器合约调用示例 部署后如下图所示，会显示合约内部定义的函数，可以自行调用尝试。 前面说到，按照ERC20协议部署的代币合约有很好的兼容性，可以将代币添加到官方钱包完成转账。 命令行启动官方钱包，将钱包连接到部署合约的私链网络，命令如下： ./Ethereum\ Wallet --rpc http://10.11.178.42:8545 在钱包上面工具栏选择CONTACTS，选择“WATCH TOKEN”， 将代币合约部署地址填到地址栏，点击ok完成添加，如下图。 在工具栏选择SEND，填入相关的代币信息，确保无误后点击send完成转账。 阅读更多" />
<meta property="og:description" content="一、智能合约发行代币流程 1、智能合约代币协议ERC20 &nbsp; &nbsp; &nbsp; &nbsp; 代币（token）在以太坊中代表数字资产，并不是所有的代币都符合特定的规范。基于ERC20的代币更容易互换，也可以与各种钱包dapp兼容。标准化非常有利，也就意味着这些资产可以用于不同的平台和项目，否则只能用在特定的场合。 &nbsp; &nbsp; &nbsp; &nbsp; ERC20协议需要实现的接口标准如下： contract ERC20 { /* 代币总量 */ function totalSupply() constant returns (uint totalSupply); /* 账户代币查询 *／ function balanceOf(address _owner) constant returns (uint balance); /* 代币转账（从自己账户） */ function transfer(address _to, uint _value) returns (bool success); /* 代币转账（从委托账户） */ function transferFrom(address _from, address _to, uint _value) returns (bool success); /* 在自己账户设置_spender账户的委托金 */ function approve(address _spender, uint _value) returns (bool success); /* 返回_spender仍然被允许从_owner提取的金额。 */ function allowance(address _owner, address _spender) constant returns (uint remaining); /* 事件：转账事件通知 */ event Transfer(address indexed _from, address indexed _to, uint _value); /* 事件：委托设置事件通知 */ event Approval(address indexed _owner, address indexed _spender, uint _value); } &nbsp; &nbsp; &nbsp; &nbsp; 官方一个功能基本完整的代币合约： /* 一个相对比较完善的代币合约 */ pragma solidity ^0.4.16; /* 创建一个父类， 账户管理员 */ contract owned { address public owner; function owned() public { owner = msg.sender; } /* modifier是修改标志 */ modifier onlyOwner { require(msg.sender == owner); _; } /* 修改管理员账户， onlyOwner代表只能是用户管理员来修改 */ function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } /* receiveApproval服务合约指示代币合约将代币从发送者的账户转移到服务合约的账户（通过调用服务合约的 */ interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { // 代币（token）的公共变量 string public name; //代币名字 string public symbol; //代币符号 uint8 public decimals = 18; //代币小数点位数， 18是默认， 尽量不要更改 uint256 public totalSupply; //代币总量 // 记录各个账户的代币数目 mapping (address =&gt; uint256) public balanceOf; // A账户存在B账户资金 mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; // 转账通知事件 event Transfer(address indexed from, address indexed to, uint256 value); // 销毁金额通知事件 event Burn(address indexed from, uint256 value); /* 构造函数 */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); // 根据decimals计算代币的数量 balanceOf[msg.sender] = totalSupply; // 给生成者所有的代币数量 name = tokenName; // 设置代币的名字 symbol = tokenSymbol; // 设置代币的符号 } /* 私有的交易函数 */ function _transfer(address _from, address _to, uint _value) internal { // 防止转移到0x0， 用burn代替这个功能 require(_to != 0x0); // 检测发送者是否有足够的资金 require(balanceOf[_from] &gt;= _value); // 检查是否溢出（数据类型的溢出） require(balanceOf[_to] + _value &gt; balanceOf[_to]); // 将此保存为将来的断言， 函数最后会有一个检验 uint previousBalances = balanceOf[_from] + balanceOf[_to]; // 减少发送者资产 balanceOf[_from] -= _value; // 增加接收者的资产 balanceOf[_to] += _value; Transfer(_from, _to, _value); // 断言检测， 不应该为错 assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /* 传递tokens */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /* 从其他账户转移资产 */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /* 授权第三方从发送者账户转移代币，然后通过transferFrom()函数来执行第三方的转移操作 */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /* 为其他地址设置津贴， 并通知 发送者通知代币合约, 代币合约通知服务合约receiveApproval, 服务合约指示代币合约将代币从发送者的账户转移到服务合约的账户（通过调用服务合约的transferFrom) */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * 销毁代币 */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough balanceOf[msg.sender] -= _value; // Subtract from the sender totalSupply -= _value; // Updates totalSupply Burn(msg.sender, _value); return true; } /** * 从其他账户销毁代币 */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] &gt;= _value); // Check if the targeted balance is enough require(_value &lt;= allowance[_from][msg.sender]); // Check allowance balanceOf[_from] -= _value; // Subtract from the targeted balance allowance[_from][msg.sender] -= _value; // Subtract from the sender&#39;s allowance totalSupply -= _value; // Update totalSupply Burn(_from, _value); return true; } } /******************************************/ /* ADVANCED TOKEN STARTS HERE */ /******************************************/ contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; /* 冻结账户 */ mapping (address =&gt; bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /* 构造函数 */ function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} /* 转账， 比父类加入了账户冻结 */ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] &gt;= _value); // Check if the sender has enough require (balanceOf[_to] + _value &gt; balanceOf[_to]); // Check for overflows require(!frozenAccount[_from]); // Check if sender is frozen require(!frozenAccount[_to]); // Check if recipient is frozen balanceOf[_from] -= _value; // Subtract from the sender balanceOf[_to] += _value; // Add the same to the recipient Transfer(_from, _to, _value); } /// 向指定账户增发资金 function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); } /// 冻结 or 解冻账户 function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } /// @notice Buy tokens from contract by sending ether function buy() payable public { uint amount = msg.value / buyPrice; // calculates the amount _transfer(this, msg.sender, amount); // makes the transfers } function sell(uint256 amount) public { require(this.balance &gt;= amount * sellPrice); // checks if the contract has enough ether to buy _transfer(msg.sender, this, amount); // makes the transfers msg.sender.transfer(amount * sellPrice); // sends ether to the seller. It&#39;s important to do this last to avoid recursion attacks } } 2、代币合约编译、部署、调用 &nbsp; &nbsp; &nbsp; &nbsp; 代币合约部署方式很多，本地工具有truffle，官方有网页编译器remix，另外以太坊官方钱包也可以完成合约部署。本文主要介绍从官方remix编译器编译、部署到测试私链的方法。并将代币添加到，在以太坊官方钱包完成转账。 &nbsp; &nbsp; &nbsp; &nbsp; 官方remix编译器地址：http://remix.ethereum.org/ 合约编译，步骤图示如下所示： 将合约代码写入编译器代码编辑区。 在右侧compile工具栏执行&quot;Start to compile&quot; 编译完毕右侧会出现代码调试信息。 合约部署，步骤： 点击右侧工具栏run选项，出现如下界面。 选择要部署的网络，并选择要合约部署的外部账户。 填入构造函数参数后，点击create完成部署（部署网络需要有节点在挖矿、外部账户中有足量以太币且账户已解锁） remix编译器合约调用示例 部署后如下图所示，会显示合约内部定义的函数，可以自行调用尝试。 前面说到，按照ERC20协议部署的代币合约有很好的兼容性，可以将代币添加到官方钱包完成转账。 命令行启动官方钱包，将钱包连接到部署合约的私链网络，命令如下： ./Ethereum\ Wallet --rpc http://10.11.178.42:8545 在钱包上面工具栏选择CONTACTS，选择“WATCH TOKEN”， 将代币合约部署地址填到地址栏，点击ok完成添加，如下图。 在工具栏选择SEND，填入相关的代币信息，确保无误后点击send完成转账。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/20/7ca9b0141a63a21b8db3ffda3346328d.html" />
<meta property="og:url" content="https://mlh.app/2018/03/20/7ca9b0141a63a21b8db3ffda3346328d.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"一、智能合约发行代币流程 1、智能合约代币协议ERC20 &nbsp; &nbsp; &nbsp; &nbsp; 代币（token）在以太坊中代表数字资产，并不是所有的代币都符合特定的规范。基于ERC20的代币更容易互换，也可以与各种钱包dapp兼容。标准化非常有利，也就意味着这些资产可以用于不同的平台和项目，否则只能用在特定的场合。 &nbsp; &nbsp; &nbsp; &nbsp; ERC20协议需要实现的接口标准如下： contract ERC20 { /* 代币总量 */ function totalSupply() constant returns (uint totalSupply); /* 账户代币查询 *／ function balanceOf(address _owner) constant returns (uint balance); /* 代币转账（从自己账户） */ function transfer(address _to, uint _value) returns (bool success); /* 代币转账（从委托账户） */ function transferFrom(address _from, address _to, uint _value) returns (bool success); /* 在自己账户设置_spender账户的委托金 */ function approve(address _spender, uint _value) returns (bool success); /* 返回_spender仍然被允许从_owner提取的金额。 */ function allowance(address _owner, address _spender) constant returns (uint remaining); /* 事件：转账事件通知 */ event Transfer(address indexed _from, address indexed _to, uint _value); /* 事件：委托设置事件通知 */ event Approval(address indexed _owner, address indexed _spender, uint _value); } &nbsp; &nbsp; &nbsp; &nbsp; 官方一个功能基本完整的代币合约： /* 一个相对比较完善的代币合约 */ pragma solidity ^0.4.16; /* 创建一个父类， 账户管理员 */ contract owned { address public owner; function owned() public { owner = msg.sender; } /* modifier是修改标志 */ modifier onlyOwner { require(msg.sender == owner); _; } /* 修改管理员账户， onlyOwner代表只能是用户管理员来修改 */ function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } /* receiveApproval服务合约指示代币合约将代币从发送者的账户转移到服务合约的账户（通过调用服务合约的 */ interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { // 代币（token）的公共变量 string public name; //代币名字 string public symbol; //代币符号 uint8 public decimals = 18; //代币小数点位数， 18是默认， 尽量不要更改 uint256 public totalSupply; //代币总量 // 记录各个账户的代币数目 mapping (address =&gt; uint256) public balanceOf; // A账户存在B账户资金 mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; // 转账通知事件 event Transfer(address indexed from, address indexed to, uint256 value); // 销毁金额通知事件 event Burn(address indexed from, uint256 value); /* 构造函数 */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); // 根据decimals计算代币的数量 balanceOf[msg.sender] = totalSupply; // 给生成者所有的代币数量 name = tokenName; // 设置代币的名字 symbol = tokenSymbol; // 设置代币的符号 } /* 私有的交易函数 */ function _transfer(address _from, address _to, uint _value) internal { // 防止转移到0x0， 用burn代替这个功能 require(_to != 0x0); // 检测发送者是否有足够的资金 require(balanceOf[_from] &gt;= _value); // 检查是否溢出（数据类型的溢出） require(balanceOf[_to] + _value &gt; balanceOf[_to]); // 将此保存为将来的断言， 函数最后会有一个检验 uint previousBalances = balanceOf[_from] + balanceOf[_to]; // 减少发送者资产 balanceOf[_from] -= _value; // 增加接收者的资产 balanceOf[_to] += _value; Transfer(_from, _to, _value); // 断言检测， 不应该为错 assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /* 传递tokens */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /* 从其他账户转移资产 */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /* 授权第三方从发送者账户转移代币，然后通过transferFrom()函数来执行第三方的转移操作 */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /* 为其他地址设置津贴， 并通知 发送者通知代币合约, 代币合约通知服务合约receiveApproval, 服务合约指示代币合约将代币从发送者的账户转移到服务合约的账户（通过调用服务合约的transferFrom) */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * 销毁代币 */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough balanceOf[msg.sender] -= _value; // Subtract from the sender totalSupply -= _value; // Updates totalSupply Burn(msg.sender, _value); return true; } /** * 从其他账户销毁代币 */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] &gt;= _value); // Check if the targeted balance is enough require(_value &lt;= allowance[_from][msg.sender]); // Check allowance balanceOf[_from] -= _value; // Subtract from the targeted balance allowance[_from][msg.sender] -= _value; // Subtract from the sender&#39;s allowance totalSupply -= _value; // Update totalSupply Burn(_from, _value); return true; } } /******************************************/ /* ADVANCED TOKEN STARTS HERE */ /******************************************/ contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; /* 冻结账户 */ mapping (address =&gt; bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /* 构造函数 */ function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} /* 转账， 比父类加入了账户冻结 */ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] &gt;= _value); // Check if the sender has enough require (balanceOf[_to] + _value &gt; balanceOf[_to]); // Check for overflows require(!frozenAccount[_from]); // Check if sender is frozen require(!frozenAccount[_to]); // Check if recipient is frozen balanceOf[_from] -= _value; // Subtract from the sender balanceOf[_to] += _value; // Add the same to the recipient Transfer(_from, _to, _value); } /// 向指定账户增发资金 function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); } /// 冻结 or 解冻账户 function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } /// @notice Buy tokens from contract by sending ether function buy() payable public { uint amount = msg.value / buyPrice; // calculates the amount _transfer(this, msg.sender, amount); // makes the transfers } function sell(uint256 amount) public { require(this.balance &gt;= amount * sellPrice); // checks if the contract has enough ether to buy _transfer(msg.sender, this, amount); // makes the transfers msg.sender.transfer(amount * sellPrice); // sends ether to the seller. It&#39;s important to do this last to avoid recursion attacks } } 2、代币合约编译、部署、调用 &nbsp; &nbsp; &nbsp; &nbsp; 代币合约部署方式很多，本地工具有truffle，官方有网页编译器remix，另外以太坊官方钱包也可以完成合约部署。本文主要介绍从官方remix编译器编译、部署到测试私链的方法。并将代币添加到，在以太坊官方钱包完成转账。 &nbsp; &nbsp; &nbsp; &nbsp; 官方remix编译器地址：http://remix.ethereum.org/ 合约编译，步骤图示如下所示： 将合约代码写入编译器代码编辑区。 在右侧compile工具栏执行&quot;Start to compile&quot; 编译完毕右侧会出现代码调试信息。 合约部署，步骤： 点击右侧工具栏run选项，出现如下界面。 选择要部署的网络，并选择要合约部署的外部账户。 填入构造函数参数后，点击create完成部署（部署网络需要有节点在挖矿、外部账户中有足量以太币且账户已解锁） remix编译器合约调用示例 部署后如下图所示，会显示合约内部定义的函数，可以自行调用尝试。 前面说到，按照ERC20协议部署的代币合约有很好的兼容性，可以将代币添加到官方钱包完成转账。 命令行启动官方钱包，将钱包连接到部署合约的私链网络，命令如下： ./Ethereum\\ Wallet --rpc http://10.11.178.42:8545 在钱包上面工具栏选择CONTACTS，选择“WATCH TOKEN”， 将代币合约部署地址填到地址栏，点击ok完成添加，如下图。 在工具栏选择SEND，填入相关的代币信息，确保无误后点击send完成转账。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/20/7ca9b0141a63a21b8db3ffda3346328d.html","headline":"智能合约代币编译、部署、调用","dateModified":"2018-03-20T00:00:00+08:00","datePublished":"2018-03-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/20/7ca9b0141a63a21b8db3ffda3346328d.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>智能合约代币编译、部署、调用</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h2 style="border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(204,204,204);color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;background-color:rgb(255,255,255);">一、智能合约发行代币流程</h2>
  <h3 style="font-size:18px;color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;background-color:rgb(255,255,255);">1、智能合约代币协议ERC20</h3>
  <p style="color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">&nbsp; &nbsp; &nbsp; &nbsp; 代币（token）在以太坊中代表数字资产，并不是所有的代币都符合特定的规范。基于ERC20的代币更容易互换，也可以与各种钱包dapp兼容。标准化非常有利，也就意味着这些资产可以用于不同的平台和项目，否则只能用在特定的场合。</p>
  <p style="color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">&nbsp; &nbsp; &nbsp; &nbsp; ERC20协议需要实现的接口标准如下：</p>
  <div style="color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <pre style="background-color:rgb(248,248,248);border:1px solid rgb(204,204,204);font-size:13px;line-height:19px;"><code class="language-none" style="border:none;background-color:transparent;">contract ERC20 {

    /* 代币总量 */
    function totalSupply() constant returns (uint totalSupply);

    /* 账户代币查询 *／
    function balanceOf(address _owner) constant returns (uint balance);

    /* 代币转账（从自己账户） */
    function transfer(address _to, uint _value) returns (bool success);

    /* 代币转账（从委托账户） */
    function transferFrom(address _from, address _to, uint _value) returns (bool success);

    /* 在自己账户设置_spender账户的委托金 */
    function approve(address _spender, uint _value) returns (bool success);

    /* 返回_spender仍然被允许从_owner提取的金额。 */
    function allowance(address _owner, address _spender) constant returns (uint remaining);

    /* 事件：转账事件通知 */
    event Transfer(address indexed _from, address indexed _to, uint _value);

    /* 事件：委托设置事件通知 */
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}</code></pre>
  </div>
  <p style="color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">&nbsp; &nbsp; &nbsp; &nbsp; 官方一个功能基本完整的代币合约：</p>
  <p style="color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);"></p>
  <div>
   <pre style="background-color:rgb(248,248,248);border:1px solid rgb(204,204,204);font-size:13px;line-height:19px;"><code class="language-none" style="border:none;background-color:transparent;">/* 一个相对比较完善的代币合约 */
pragma solidity ^0.4.16;
/* 创建一个父类， 账户管理员 */
contract owned {

    address public owner;

    function owned() public {
    owner = msg.sender;
    }

    /* modifier是修改标志 */
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    /* 修改管理员账户， onlyOwner代表只能是用户管理员来修改 */
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }   
}

/* receiveApproval服务合约指示代币合约将代币从发送者的账户转移到服务合约的账户（通过调用服务合约的 */
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract TokenERC20 {
    // 代币（token）的公共变量
    string public name;             //代币名字
    string public symbol;           //代币符号
    uint8 public decimals = 18;     //代币小数点位数， 18是默认， 尽量不要更改

    uint256 public totalSupply;     //代币总量

    // 记录各个账户的代币数目
    mapping (address =&gt; uint256) public balanceOf;

    // A账户存在B账户资金
    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;

    // 转账通知事件
    event Transfer(address indexed from, address indexed to, uint256 value);

    // 销毁金额通知事件
    event Burn(address indexed from, uint256 value);

    /* 构造函数 */
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // 根据decimals计算代币的数量
        balanceOf[msg.sender] = totalSupply;                    // 给生成者所有的代币数量
        name = tokenName;                                       // 设置代币的名字
        symbol = tokenSymbol;                                   // 设置代币的符号
    }

    /* 私有的交易函数 */
    function _transfer(address _from, address _to, uint _value) internal {
        // 防止转移到0x0， 用burn代替这个功能
        require(_to != 0x0);
        // 检测发送者是否有足够的资金
        require(balanceOf[_from] &gt;= _value);
        // 检查是否溢出（数据类型的溢出）
        require(balanceOf[_to] + _value &gt; balanceOf[_to]);
        // 将此保存为将来的断言， 函数最后会有一个检验
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // 减少发送者资产
        balanceOf[_from] -= _value;
        // 增加接收者的资产
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // 断言检测， 不应该为错
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /* 传递tokens */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /* 从其他账户转移资产 */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value &lt;= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /*  授权第三方从发送者账户转移代币，然后通过transferFrom()函数来执行第三方的转移操作 */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /*
    为其他地址设置津贴， 并通知
    发送者通知代币合约, 代币合约通知服务合约receiveApproval, 服务合约指示代币合约将代币从发送者的账户转移到服务合约的账户（通过调用服务合约的transferFrom)
    */

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
    * 销毁代币
    */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] &gt;= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
    * 从其他账户销毁代币
    */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] &gt;= _value);                // Check if the targeted balance is enough
        require(_value &lt;= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}

/******************************************/
/*       ADVANCED TOKEN STARTS HERE       */
/******************************************/

contract MyAdvancedToken is owned, TokenERC20 {

    uint256 public sellPrice;
    uint256 public buyPrice;

    /* 冻结账户 */
    mapping (address =&gt; bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* 构造函数 */
    function MyAdvancedToken(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}

    /* 转账， 比父类加入了账户冻结 */
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] &gt;= _value);               // Check if the sender has enough
        require (balanceOf[_to] + _value &gt; balanceOf[_to]); // Check for overflows
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        require(!frozenAccount[_to]);                       // Check if recipient is frozen
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        Transfer(_from, _to, _value);
    }

/// 向指定账户增发资金
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);

    }


    /// 冻结 or 解冻账户
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    /// @notice Buy tokens from contract by sending ether
    function buy() payable public {
        uint amount = msg.value / buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }

    function sell(uint256 amount) public {
        require(this.balance &gt;= amount * sellPrice);      // checks if the contract has enough ether to buy
        _transfer(msg.sender, this, amount);              // makes the transfers
        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }
}</code></pre>
  </div>
  <h3 style="font-size:18px;color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;background-color:rgb(255,255,255);"><br></h3>
  <h3 style="font-size:18px;color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;background-color:rgb(255,255,255);">2、代币合约编译、部署、调用</h3>
  <p style="color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">&nbsp; &nbsp; &nbsp; &nbsp; 代币合约部署方式很多，本地工具有truffle，官方有网页编译器remix，另外以太坊官方钱包也可以完成合约部署。本文主要介绍从官方remix编译器编译、部署到测试私链的方法。并将代币添加到，在以太坊官方钱包完成转账。</p>
  <p style="color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">&nbsp; &nbsp; &nbsp; &nbsp; 官方remix编译器地址：http://remix.ethereum.org/</p>
  <ul style="color:rgb(0,0,0);font-family:Helvetica, arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li style="margin-left:0px;"><p>合约编译，步骤图示如下所示：</p>
    <ul>
     <li style="margin-left:0px;">将合约代码写入编译器代码编辑区。</li>
     <li style="margin-left:0px;">在右侧compile工具栏执行"Start to compile"</li>
     <li style="margin-left:0px;">编译完毕右侧会出现代码调试信息。</li>
    </ul><p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180320142728466" alt=""><br></p></li>
   <li style="margin-left:0px;"><p>合约部署，步骤：</p>
    <ul>
     <li style="margin-left:0px;">点击右侧工具栏run选项，出现如下界面。</li>
     <li style="margin-left:0px;">选择要部署的网络，并选择要合约部署的外部账户。</li>
     <li style="margin-left:0px;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180320142807528" alt=""></li>
     <li style="margin-left:0px;">填入构造函数参数后，点击create完成部署（部署网络需要有节点在挖矿、外部账户中有足量以太币且账户已解锁）</li>
    </ul><p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018032014283871" alt=""><br></p></li>
   <li style="margin-left:0px;"><p>remix编译器合约调用示例</p>
    <ul>
     <li style="margin-left:0px;">部署后如下图所示，会显示合约内部定义的函数，可以自行调用尝试。</li>
    </ul></li>
   <li style="margin-left:0px;"><p>前面说到，按照ERC20协议部署的代币合约有很好的兼容性，可以将代币添加到官方钱包完成转账。</p>
    <ul>
     <li style="margin-left:0px;"><p>命令行启动官方钱包，将钱包连接到部署合约的私链网络，命令如下：</p>
      <div>
       <pre style="background-color:rgb(248,248,248);border:1px solid rgb(204,204,204);font-size:13px;line-height:19px;"><code class="language-none" style="border:none;background-color:transparent;">./Ethereum\ Wallet --rpc http://10.11.178.42:8545</code></pre>
      </div></li>
     <li style="margin-left:0px;"><p>在钱包上面工具栏选择CONTACTS，选择“WATCH TOKEN”， 将代币合约部署地址填到地址栏，点击ok完成添加，如下图。</p><p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180320142904134" alt=""><br></p></li>
     <li style="margin-left:0px;"><p>在工具栏选择SEND，填入相关的代币信息，确保无误后点击send完成转账。</p></li>
    </ul></li>
  </ul>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180320142920961" alt=""></p>
  <p></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jueying7573/article/details/79624944,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jueying7573/article/details/79624944,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
