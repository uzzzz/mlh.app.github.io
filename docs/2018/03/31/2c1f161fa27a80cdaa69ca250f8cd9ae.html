<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>基于以太坊发布属于自己的数字货币（代币）完整版 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="基于以太坊发布属于自己的数字货币（代币）完整版" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="基于以太坊发布属于自己的数字货币（代币）完整版 （参考资料来源于网络以及各种摸索，其中各种坑） &nbsp; 本文单纯从技术角度详细介绍如何基于以太坊ERC20创建代币的流程(此案例是部署的eth主网，非测试案例) &nbsp; 写在前面 &nbsp; 本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么。 代币Token 如果不那么追求精确的定义，代币就是数字货币，比特币、以太币就是一个代币。利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。 因此不管是出于商业，还是学习很多人想创建一个自己的代币，先贴一个图看看创建的代币是什么样子。 以我自己发布的BliBli币 Bcoin为例 访问地址 ： &nbsp;https://etherscan.io/token/0x73c8da697fe5e145f6269c4c852e59a7328f9371 &nbsp;今天我们就来详细讲一讲怎样创建一个这样的代币。 ERC20 Token ERC20和代币一同出现， ERC20是以太坊定义的一个代币标准。是一种发行代币合约必须要遵守的协议，该协议规定了几个参数——发行货币的名称，简称，发行量，要支持的函数等，只有支持了该协议才会被以太坊所认同。 erc20标准代码如下 // https://github.com/ethereum/EIPs/issues/20 contract ERC20 { function totalSupply() constant returns (uint totalSupply); function balanceOf(address _owner) constant returns (uint balance); function transfer(address _to, uint _value) returns (bool success); function transferFrom(address _from, address _to, uint _value) returns (bool success); function approve(address _spender, uint _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint remaining); event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } totalSupply:&nbsp; 代表的是代币发行总量&nbsp; &nbsp; totalSupply():该方法可以返回代币的总数量 name:&nbsp; 发行代币的名称&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dicimals:&nbsp; 发行代币以后，代币交易的最小单位 balanceOf(): 该方法返回的是输入钱包地址后，该钱包的代币余额 tansferFrom() :从一个地址向另一个地址发送余额 approve(): 允许_spender从你的账户转出_value余额 allowance(): 允许_spender从你的账户转出_value的余额，调用多次会覆盖可用量。某些DEX功能需要此功能 event Transfer(): &nbsp;token转移完成后出发 event Approval(): &nbsp;approve(address _spender, uint256 _value)调用后触发 编写代币合约： pragma solidity ^0.4.12; contract IMigrationContract { function migrate(address addr, uint256 nas) returns (bool success); } /* 灵感来自于NAS coin*/ contract SafeMath { function safeAdd(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x + y; assert((z &gt;= x) &amp;&amp; (z &gt;= y)); return z; } function safeSubtract(uint256 x, uint256 y) internal returns(uint256) { assert(x &gt;= y); uint256 z = x - y; return z; } function safeMult(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x * y; assert((x == 0)||(z/x == y)); return z; } } contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /* ERC 20 token */ contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address =&gt; uint256) balances; mapping (address =&gt; mapping (address =&gt; uint256)) allowed; } contract BliBliToken is StandardToken, SafeMath { // metadata string public constant name = &quot;BliBli&quot;; string public constant symbol = &quot;BCoin&quot;; uint256 public constant decimals = 18; string public version = &quot;1.0&quot;; // contracts address public ethFundDeposit; // ETH存放地址 address public newContractAddr; // token更新地址 // crowdsale parameters bool public isFunding; // 状态切换到true uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; // 正在售卖中的tokens数量 uint256 public tokenRaised = 0; // 总的售卖数量token uint256 public tokenMigrated = 0; // 总的已经交易的 token uint256 public tokenExchangeRate = 625; // 625 BILIBILI 兑换 1 ETH // events event AllocateToken(address indexed _to, uint256 _value); // 分配的私有交易token; event IssueToken(address indexed _to, uint256 _value); // 公开发行售卖的token; event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); // 转换 function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; } // constructor function BliBliToken( address _ethFundDeposit, uint256 _currentSupply) { ethFundDeposit = _ethFundDeposit; isFunding = false; //通过控制预CrowdS ale状态 fundingStartBlock = 0; fundingStopBlock = 0; currentSupply = formatDecimals(_currentSupply); totalSupply = formatDecimals(10000000); balances[msg.sender] = totalSupply; if(currentSupply &gt; totalSupply) throw; } modifier isOwner() { require(msg.sender == ethFundDeposit); _; } /// 设置token汇率 function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external { if (_tokenExchangeRate == 0) throw; if (_tokenExchangeRate == tokenExchangeRate) throw; tokenExchangeRate = _tokenExchangeRate; } /// @dev 超发token处理 function increaseSupply (uint256 _value) isOwner external { uint256 value = formatDecimals(_value); if (value + currentSupply &gt; totalSupply) throw; currentSupply = safeAdd(currentSupply, value); IncreaseSupply(value); } /// @dev 被盗token处理 function decreaseSupply (uint256 _value) isOwner external { uint256 value = formatDecimals(_value); if (value + tokenRaised &gt; currentSupply) throw; currentSupply = safeSubtract(currentSupply, value); DecreaseSupply(value); } /// 启动区块检测 异常的处理 function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external { if (isFunding) throw; if (_fundingStartBlock &gt;= _fundingStopBlock) throw; if (block.number &gt;= _fundingStartBlock) throw; fundingStartBlock = _fundingStartBlock; fundingStopBlock = _fundingStopBlock; isFunding = true; } /// 关闭区块异常处理 function stopFunding() isOwner external { if (!isFunding) throw; isFunding = false; } /// 开发了一个新的合同来接收token（或者更新token） function setMigrateContract(address _newContractAddr) isOwner external { if (_newContractAddr == newContractAddr) throw; newContractAddr = _newContractAddr; } /// 设置新的所有者地址 function changeOwner(address _newFundDeposit) isOwner() external { if (_newFundDeposit == address(0x0)) throw; ethFundDeposit = _newFundDeposit; } ///转移token到新的合约 function migrate() external { if(isFunding) throw; if(newContractAddr == address(0x0)) throw; uint256 tokens = balances[msg.sender]; if (tokens == 0) throw; balances[msg.sender] = 0; tokenMigrated = safeAdd(tokenMigrated, tokens); IMigrationContract newContract = IMigrationContract(newContractAddr); if (!newContract.migrate(msg.sender, tokens)) throw; Migrate(msg.sender, tokens); // log it } /// 转账ETH 到BILIBILI团队 function transferETH() isOwner external { if (this.balance == 0) throw; if (!ethFundDeposit.send(this.balance)) throw; } /// 将BILIBILI token分配到预处理地址。 function allocateToken (address _addr, uint256 _eth) isOwner external { if (_eth == 0) throw; if (_addr == address(0x0)) throw; uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate); if (tokens + tokenRaised &gt; currentSupply) throw; tokenRaised = safeAdd(tokenRaised, tokens); balances[_addr] += tokens; AllocateToken(_addr, tokens); // 记录token日志 } /// 购买token function () payable { if (!isFunding) throw; if (msg.value == 0) throw; if (block.number &lt; fundingStartBlock) throw; if (block.number &gt; fundingStopBlock) throw; uint256 tokens = safeMult(msg.value, tokenExchangeRate); if (tokens + tokenRaised &gt; currentSupply) throw; tokenRaised = safeAdd(tokenRaised, tokens); balances[msg.sender] += tokens; IssueToken(msg.sender, tokens); //记录日志 } } 以上的代币合约，是参考以太坊已经ICO过，并且产生价值的代币合约参考而来，完整比且功能强大，此合约创建的代币，具有“交易”，“转账”，“异常检测”，“更改代币持有人”，“设置汇率”，“被盗处理”，“超发代币”等功能。 （解释下：在以太坊的世界中，硬通货就是ETH-以太币，相当于现实世界中的黄金，我们发布的代币，就相当于各国发行的需要 与黄金挂钩兑换比率的货币，国家对货币拥有控制权，只要合约功能进行扩展，创造代币的人也会对代币拥有控制权。） （对于挖矿的误解：不少小哥哥小姐姐认为挖矿就是挖币，其实挖矿是挖区块，区块是干嘛的，是用来打包交易的，是存储数据的，代币是不用挖的，当你挖到了区块，代币是给你的奖励，在发行量一定的情况下，代币会越来越少，所以挖到区块的奖励会变少。那奖励少了为什么还要挖矿呢，因为你的任何一笔交易都需要记录，一个区块的大小也就几M，存储不了那么多交易信息，所以要持续挖区块来记录你的交易，同时交易的手续费，会奖励给挖出区块的人。） 部署合约： &nbsp; &nbsp;&nbsp; 部署合约有多种方式&nbsp; &nbsp; &nbsp; 1 geth 编译代码 ---部署合约 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 用ethereum wallet钱包部署合约 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 最简单直观的部署合约方式：&nbsp;&nbsp;MetaMask和Remix Solidity IDE&nbsp;部署合约 &nbsp; &nbsp;我们按照&nbsp;MetaMask和Remix Solidity IDE&nbsp;来进行部署合约。 &nbsp;1：&nbsp;创建钱包帐号。MetaMask是钱包的一种，在chrome浏览器中，安装MetaMask插件即可，安装完成后，右上角会出现一个“狐狸头”的标志，点击该标志，打开钱包，第一步，创建账户，（创建账户只需要输入面密码即可，名称创建后可以随便改，该账户就是一个hash值，如何给自己创建的账户冲以太币，可以上https://otcbtc.com/sign_up网站，按照操作买以太币，然后转账到自己创建的账户）创建成功后，记住密码还有产生的几个随机单词（一定要记录下来）。如下： &nbsp;&nbsp;&nbsp;2：打开&nbsp;Remix Solidity IDE&nbsp;访问地址：&nbsp;http://remix.ethereum.org/#optimize=false&amp;version=soljson-v0.4.21+commit.dfe3193c.js&nbsp; &nbsp;界面如下&nbsp; 3：&nbsp; 拷贝“编写代币合约”后边的代码到Remix Solidity IDE中按照如下编译 4： create 发布&nbsp; 如下 &nbsp; &nbsp; 5 create后，产生hash值，拷贝hash值，在钱包中添加token OK，如上所示，第一个属于你的真正意义上的去中心化数字货币就诞生了。正式网络和测试网络部署方法一样，不需要买eth就是了。 如果是测试网络，如何获得ETH？&nbsp; &nbsp;进入 https://gitter.im/kovan-testnet/faucet&nbsp; 下方直接发送你的账户地址（hash值）即可，一般五分钟到账，会得到五个测试网络用的ETH币。 6（如果部署的是eth主网，非测试网，执行该步骤，测试网络可以不理会） 发布了代币以后，如果以后进行ico，那么需要发布源码公开。步骤如下 &nbsp; &nbsp;①&nbsp; 拷贝部署成功的合约地址（hash），到&nbsp; https://etherscan.io/&nbsp; &nbsp;右上角搜索hash &nbsp; &nbsp;②&nbsp; 按照如下图进行verify AND publish &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;打开如下页面第一步 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;打开如下页面第二部 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 打开如下页面第三部 &nbsp; &nbsp; &nbsp; &nbsp; ok&nbsp; 现在的代币就比较完整了，差ico了 代币转账： &nbsp; &nbsp;1&nbsp; metamask钱包转账：&nbsp; 如下 &nbsp; &nbsp;输入地址和代币数量 2&nbsp; 网页钱包转账：&nbsp; 如下&nbsp;&nbsp;https://www.myetherwallet.com/#send-transaction &nbsp; &nbsp; 登录账户： &nbsp; 转账交易 &nbsp; &nbsp; &nbsp;qq群交流 &nbsp; &nbsp; &nbsp; 阅读更多" />
<meta property="og:description" content="基于以太坊发布属于自己的数字货币（代币）完整版 （参考资料来源于网络以及各种摸索，其中各种坑） &nbsp; 本文单纯从技术角度详细介绍如何基于以太坊ERC20创建代币的流程(此案例是部署的eth主网，非测试案例) &nbsp; 写在前面 &nbsp; 本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么。 代币Token 如果不那么追求精确的定义，代币就是数字货币，比特币、以太币就是一个代币。利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。 因此不管是出于商业，还是学习很多人想创建一个自己的代币，先贴一个图看看创建的代币是什么样子。 以我自己发布的BliBli币 Bcoin为例 访问地址 ： &nbsp;https://etherscan.io/token/0x73c8da697fe5e145f6269c4c852e59a7328f9371 &nbsp;今天我们就来详细讲一讲怎样创建一个这样的代币。 ERC20 Token ERC20和代币一同出现， ERC20是以太坊定义的一个代币标准。是一种发行代币合约必须要遵守的协议，该协议规定了几个参数——发行货币的名称，简称，发行量，要支持的函数等，只有支持了该协议才会被以太坊所认同。 erc20标准代码如下 // https://github.com/ethereum/EIPs/issues/20 contract ERC20 { function totalSupply() constant returns (uint totalSupply); function balanceOf(address _owner) constant returns (uint balance); function transfer(address _to, uint _value) returns (bool success); function transferFrom(address _from, address _to, uint _value) returns (bool success); function approve(address _spender, uint _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint remaining); event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } totalSupply:&nbsp; 代表的是代币发行总量&nbsp; &nbsp; totalSupply():该方法可以返回代币的总数量 name:&nbsp; 发行代币的名称&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dicimals:&nbsp; 发行代币以后，代币交易的最小单位 balanceOf(): 该方法返回的是输入钱包地址后，该钱包的代币余额 tansferFrom() :从一个地址向另一个地址发送余额 approve(): 允许_spender从你的账户转出_value余额 allowance(): 允许_spender从你的账户转出_value的余额，调用多次会覆盖可用量。某些DEX功能需要此功能 event Transfer(): &nbsp;token转移完成后出发 event Approval(): &nbsp;approve(address _spender, uint256 _value)调用后触发 编写代币合约： pragma solidity ^0.4.12; contract IMigrationContract { function migrate(address addr, uint256 nas) returns (bool success); } /* 灵感来自于NAS coin*/ contract SafeMath { function safeAdd(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x + y; assert((z &gt;= x) &amp;&amp; (z &gt;= y)); return z; } function safeSubtract(uint256 x, uint256 y) internal returns(uint256) { assert(x &gt;= y); uint256 z = x - y; return z; } function safeMult(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x * y; assert((x == 0)||(z/x == y)); return z; } } contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /* ERC 20 token */ contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address =&gt; uint256) balances; mapping (address =&gt; mapping (address =&gt; uint256)) allowed; } contract BliBliToken is StandardToken, SafeMath { // metadata string public constant name = &quot;BliBli&quot;; string public constant symbol = &quot;BCoin&quot;; uint256 public constant decimals = 18; string public version = &quot;1.0&quot;; // contracts address public ethFundDeposit; // ETH存放地址 address public newContractAddr; // token更新地址 // crowdsale parameters bool public isFunding; // 状态切换到true uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; // 正在售卖中的tokens数量 uint256 public tokenRaised = 0; // 总的售卖数量token uint256 public tokenMigrated = 0; // 总的已经交易的 token uint256 public tokenExchangeRate = 625; // 625 BILIBILI 兑换 1 ETH // events event AllocateToken(address indexed _to, uint256 _value); // 分配的私有交易token; event IssueToken(address indexed _to, uint256 _value); // 公开发行售卖的token; event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); // 转换 function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; } // constructor function BliBliToken( address _ethFundDeposit, uint256 _currentSupply) { ethFundDeposit = _ethFundDeposit; isFunding = false; //通过控制预CrowdS ale状态 fundingStartBlock = 0; fundingStopBlock = 0; currentSupply = formatDecimals(_currentSupply); totalSupply = formatDecimals(10000000); balances[msg.sender] = totalSupply; if(currentSupply &gt; totalSupply) throw; } modifier isOwner() { require(msg.sender == ethFundDeposit); _; } /// 设置token汇率 function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external { if (_tokenExchangeRate == 0) throw; if (_tokenExchangeRate == tokenExchangeRate) throw; tokenExchangeRate = _tokenExchangeRate; } /// @dev 超发token处理 function increaseSupply (uint256 _value) isOwner external { uint256 value = formatDecimals(_value); if (value + currentSupply &gt; totalSupply) throw; currentSupply = safeAdd(currentSupply, value); IncreaseSupply(value); } /// @dev 被盗token处理 function decreaseSupply (uint256 _value) isOwner external { uint256 value = formatDecimals(_value); if (value + tokenRaised &gt; currentSupply) throw; currentSupply = safeSubtract(currentSupply, value); DecreaseSupply(value); } /// 启动区块检测 异常的处理 function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external { if (isFunding) throw; if (_fundingStartBlock &gt;= _fundingStopBlock) throw; if (block.number &gt;= _fundingStartBlock) throw; fundingStartBlock = _fundingStartBlock; fundingStopBlock = _fundingStopBlock; isFunding = true; } /// 关闭区块异常处理 function stopFunding() isOwner external { if (!isFunding) throw; isFunding = false; } /// 开发了一个新的合同来接收token（或者更新token） function setMigrateContract(address _newContractAddr) isOwner external { if (_newContractAddr == newContractAddr) throw; newContractAddr = _newContractAddr; } /// 设置新的所有者地址 function changeOwner(address _newFundDeposit) isOwner() external { if (_newFundDeposit == address(0x0)) throw; ethFundDeposit = _newFundDeposit; } ///转移token到新的合约 function migrate() external { if(isFunding) throw; if(newContractAddr == address(0x0)) throw; uint256 tokens = balances[msg.sender]; if (tokens == 0) throw; balances[msg.sender] = 0; tokenMigrated = safeAdd(tokenMigrated, tokens); IMigrationContract newContract = IMigrationContract(newContractAddr); if (!newContract.migrate(msg.sender, tokens)) throw; Migrate(msg.sender, tokens); // log it } /// 转账ETH 到BILIBILI团队 function transferETH() isOwner external { if (this.balance == 0) throw; if (!ethFundDeposit.send(this.balance)) throw; } /// 将BILIBILI token分配到预处理地址。 function allocateToken (address _addr, uint256 _eth) isOwner external { if (_eth == 0) throw; if (_addr == address(0x0)) throw; uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate); if (tokens + tokenRaised &gt; currentSupply) throw; tokenRaised = safeAdd(tokenRaised, tokens); balances[_addr] += tokens; AllocateToken(_addr, tokens); // 记录token日志 } /// 购买token function () payable { if (!isFunding) throw; if (msg.value == 0) throw; if (block.number &lt; fundingStartBlock) throw; if (block.number &gt; fundingStopBlock) throw; uint256 tokens = safeMult(msg.value, tokenExchangeRate); if (tokens + tokenRaised &gt; currentSupply) throw; tokenRaised = safeAdd(tokenRaised, tokens); balances[msg.sender] += tokens; IssueToken(msg.sender, tokens); //记录日志 } } 以上的代币合约，是参考以太坊已经ICO过，并且产生价值的代币合约参考而来，完整比且功能强大，此合约创建的代币，具有“交易”，“转账”，“异常检测”，“更改代币持有人”，“设置汇率”，“被盗处理”，“超发代币”等功能。 （解释下：在以太坊的世界中，硬通货就是ETH-以太币，相当于现实世界中的黄金，我们发布的代币，就相当于各国发行的需要 与黄金挂钩兑换比率的货币，国家对货币拥有控制权，只要合约功能进行扩展，创造代币的人也会对代币拥有控制权。） （对于挖矿的误解：不少小哥哥小姐姐认为挖矿就是挖币，其实挖矿是挖区块，区块是干嘛的，是用来打包交易的，是存储数据的，代币是不用挖的，当你挖到了区块，代币是给你的奖励，在发行量一定的情况下，代币会越来越少，所以挖到区块的奖励会变少。那奖励少了为什么还要挖矿呢，因为你的任何一笔交易都需要记录，一个区块的大小也就几M，存储不了那么多交易信息，所以要持续挖区块来记录你的交易，同时交易的手续费，会奖励给挖出区块的人。） 部署合约： &nbsp; &nbsp;&nbsp; 部署合约有多种方式&nbsp; &nbsp; &nbsp; 1 geth 编译代码 ---部署合约 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 用ethereum wallet钱包部署合约 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 最简单直观的部署合约方式：&nbsp;&nbsp;MetaMask和Remix Solidity IDE&nbsp;部署合约 &nbsp; &nbsp;我们按照&nbsp;MetaMask和Remix Solidity IDE&nbsp;来进行部署合约。 &nbsp;1：&nbsp;创建钱包帐号。MetaMask是钱包的一种，在chrome浏览器中，安装MetaMask插件即可，安装完成后，右上角会出现一个“狐狸头”的标志，点击该标志，打开钱包，第一步，创建账户，（创建账户只需要输入面密码即可，名称创建后可以随便改，该账户就是一个hash值，如何给自己创建的账户冲以太币，可以上https://otcbtc.com/sign_up网站，按照操作买以太币，然后转账到自己创建的账户）创建成功后，记住密码还有产生的几个随机单词（一定要记录下来）。如下： &nbsp;&nbsp;&nbsp;2：打开&nbsp;Remix Solidity IDE&nbsp;访问地址：&nbsp;http://remix.ethereum.org/#optimize=false&amp;version=soljson-v0.4.21+commit.dfe3193c.js&nbsp; &nbsp;界面如下&nbsp; 3：&nbsp; 拷贝“编写代币合约”后边的代码到Remix Solidity IDE中按照如下编译 4： create 发布&nbsp; 如下 &nbsp; &nbsp; 5 create后，产生hash值，拷贝hash值，在钱包中添加token OK，如上所示，第一个属于你的真正意义上的去中心化数字货币就诞生了。正式网络和测试网络部署方法一样，不需要买eth就是了。 如果是测试网络，如何获得ETH？&nbsp; &nbsp;进入 https://gitter.im/kovan-testnet/faucet&nbsp; 下方直接发送你的账户地址（hash值）即可，一般五分钟到账，会得到五个测试网络用的ETH币。 6（如果部署的是eth主网，非测试网，执行该步骤，测试网络可以不理会） 发布了代币以后，如果以后进行ico，那么需要发布源码公开。步骤如下 &nbsp; &nbsp;①&nbsp; 拷贝部署成功的合约地址（hash），到&nbsp; https://etherscan.io/&nbsp; &nbsp;右上角搜索hash &nbsp; &nbsp;②&nbsp; 按照如下图进行verify AND publish &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;打开如下页面第一步 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;打开如下页面第二部 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 打开如下页面第三部 &nbsp; &nbsp; &nbsp; &nbsp; ok&nbsp; 现在的代币就比较完整了，差ico了 代币转账： &nbsp; &nbsp;1&nbsp; metamask钱包转账：&nbsp; 如下 &nbsp; &nbsp;输入地址和代币数量 2&nbsp; 网页钱包转账：&nbsp; 如下&nbsp;&nbsp;https://www.myetherwallet.com/#send-transaction &nbsp; &nbsp; 登录账户： &nbsp; 转账交易 &nbsp; &nbsp; &nbsp;qq群交流 &nbsp; &nbsp; &nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/31/2c1f161fa27a80cdaa69ca250f8cd9ae.html" />
<meta property="og:url" content="https://mlh.app/2018/03/31/2c1f161fa27a80cdaa69ca250f8cd9ae.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-31T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"基于以太坊发布属于自己的数字货币（代币）完整版 （参考资料来源于网络以及各种摸索，其中各种坑） &nbsp; 本文单纯从技术角度详细介绍如何基于以太坊ERC20创建代币的流程(此案例是部署的eth主网，非测试案例) &nbsp; 写在前面 &nbsp; 本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么。 代币Token 如果不那么追求精确的定义，代币就是数字货币，比特币、以太币就是一个代币。利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。 因此不管是出于商业，还是学习很多人想创建一个自己的代币，先贴一个图看看创建的代币是什么样子。 以我自己发布的BliBli币 Bcoin为例 访问地址 ： &nbsp;https://etherscan.io/token/0x73c8da697fe5e145f6269c4c852e59a7328f9371 &nbsp;今天我们就来详细讲一讲怎样创建一个这样的代币。 ERC20 Token ERC20和代币一同出现， ERC20是以太坊定义的一个代币标准。是一种发行代币合约必须要遵守的协议，该协议规定了几个参数——发行货币的名称，简称，发行量，要支持的函数等，只有支持了该协议才会被以太坊所认同。 erc20标准代码如下 // https://github.com/ethereum/EIPs/issues/20 contract ERC20 { function totalSupply() constant returns (uint totalSupply); function balanceOf(address _owner) constant returns (uint balance); function transfer(address _to, uint _value) returns (bool success); function transferFrom(address _from, address _to, uint _value) returns (bool success); function approve(address _spender, uint _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint remaining); event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } totalSupply:&nbsp; 代表的是代币发行总量&nbsp; &nbsp; totalSupply():该方法可以返回代币的总数量 name:&nbsp; 发行代币的名称&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dicimals:&nbsp; 发行代币以后，代币交易的最小单位 balanceOf(): 该方法返回的是输入钱包地址后，该钱包的代币余额 tansferFrom() :从一个地址向另一个地址发送余额 approve(): 允许_spender从你的账户转出_value余额 allowance(): 允许_spender从你的账户转出_value的余额，调用多次会覆盖可用量。某些DEX功能需要此功能 event Transfer(): &nbsp;token转移完成后出发 event Approval(): &nbsp;approve(address _spender, uint256 _value)调用后触发 编写代币合约： pragma solidity ^0.4.12; contract IMigrationContract { function migrate(address addr, uint256 nas) returns (bool success); } /* 灵感来自于NAS coin*/ contract SafeMath { function safeAdd(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x + y; assert((z &gt;= x) &amp;&amp; (z &gt;= y)); return z; } function safeSubtract(uint256 x, uint256 y) internal returns(uint256) { assert(x &gt;= y); uint256 z = x - y; return z; } function safeMult(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x * y; assert((x == 0)||(z/x == y)); return z; } } contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /* ERC 20 token */ contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address =&gt; uint256) balances; mapping (address =&gt; mapping (address =&gt; uint256)) allowed; } contract BliBliToken is StandardToken, SafeMath { // metadata string public constant name = &quot;BliBli&quot;; string public constant symbol = &quot;BCoin&quot;; uint256 public constant decimals = 18; string public version = &quot;1.0&quot;; // contracts address public ethFundDeposit; // ETH存放地址 address public newContractAddr; // token更新地址 // crowdsale parameters bool public isFunding; // 状态切换到true uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; // 正在售卖中的tokens数量 uint256 public tokenRaised = 0; // 总的售卖数量token uint256 public tokenMigrated = 0; // 总的已经交易的 token uint256 public tokenExchangeRate = 625; // 625 BILIBILI 兑换 1 ETH // events event AllocateToken(address indexed _to, uint256 _value); // 分配的私有交易token; event IssueToken(address indexed _to, uint256 _value); // 公开发行售卖的token; event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); // 转换 function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; } // constructor function BliBliToken( address _ethFundDeposit, uint256 _currentSupply) { ethFundDeposit = _ethFundDeposit; isFunding = false; //通过控制预CrowdS ale状态 fundingStartBlock = 0; fundingStopBlock = 0; currentSupply = formatDecimals(_currentSupply); totalSupply = formatDecimals(10000000); balances[msg.sender] = totalSupply; if(currentSupply &gt; totalSupply) throw; } modifier isOwner() { require(msg.sender == ethFundDeposit); _; } /// 设置token汇率 function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external { if (_tokenExchangeRate == 0) throw; if (_tokenExchangeRate == tokenExchangeRate) throw; tokenExchangeRate = _tokenExchangeRate; } /// @dev 超发token处理 function increaseSupply (uint256 _value) isOwner external { uint256 value = formatDecimals(_value); if (value + currentSupply &gt; totalSupply) throw; currentSupply = safeAdd(currentSupply, value); IncreaseSupply(value); } /// @dev 被盗token处理 function decreaseSupply (uint256 _value) isOwner external { uint256 value = formatDecimals(_value); if (value + tokenRaised &gt; currentSupply) throw; currentSupply = safeSubtract(currentSupply, value); DecreaseSupply(value); } /// 启动区块检测 异常的处理 function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external { if (isFunding) throw; if (_fundingStartBlock &gt;= _fundingStopBlock) throw; if (block.number &gt;= _fundingStartBlock) throw; fundingStartBlock = _fundingStartBlock; fundingStopBlock = _fundingStopBlock; isFunding = true; } /// 关闭区块异常处理 function stopFunding() isOwner external { if (!isFunding) throw; isFunding = false; } /// 开发了一个新的合同来接收token（或者更新token） function setMigrateContract(address _newContractAddr) isOwner external { if (_newContractAddr == newContractAddr) throw; newContractAddr = _newContractAddr; } /// 设置新的所有者地址 function changeOwner(address _newFundDeposit) isOwner() external { if (_newFundDeposit == address(0x0)) throw; ethFundDeposit = _newFundDeposit; } ///转移token到新的合约 function migrate() external { if(isFunding) throw; if(newContractAddr == address(0x0)) throw; uint256 tokens = balances[msg.sender]; if (tokens == 0) throw; balances[msg.sender] = 0; tokenMigrated = safeAdd(tokenMigrated, tokens); IMigrationContract newContract = IMigrationContract(newContractAddr); if (!newContract.migrate(msg.sender, tokens)) throw; Migrate(msg.sender, tokens); // log it } /// 转账ETH 到BILIBILI团队 function transferETH() isOwner external { if (this.balance == 0) throw; if (!ethFundDeposit.send(this.balance)) throw; } /// 将BILIBILI token分配到预处理地址。 function allocateToken (address _addr, uint256 _eth) isOwner external { if (_eth == 0) throw; if (_addr == address(0x0)) throw; uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate); if (tokens + tokenRaised &gt; currentSupply) throw; tokenRaised = safeAdd(tokenRaised, tokens); balances[_addr] += tokens; AllocateToken(_addr, tokens); // 记录token日志 } /// 购买token function () payable { if (!isFunding) throw; if (msg.value == 0) throw; if (block.number &lt; fundingStartBlock) throw; if (block.number &gt; fundingStopBlock) throw; uint256 tokens = safeMult(msg.value, tokenExchangeRate); if (tokens + tokenRaised &gt; currentSupply) throw; tokenRaised = safeAdd(tokenRaised, tokens); balances[msg.sender] += tokens; IssueToken(msg.sender, tokens); //记录日志 } } 以上的代币合约，是参考以太坊已经ICO过，并且产生价值的代币合约参考而来，完整比且功能强大，此合约创建的代币，具有“交易”，“转账”，“异常检测”，“更改代币持有人”，“设置汇率”，“被盗处理”，“超发代币”等功能。 （解释下：在以太坊的世界中，硬通货就是ETH-以太币，相当于现实世界中的黄金，我们发布的代币，就相当于各国发行的需要 与黄金挂钩兑换比率的货币，国家对货币拥有控制权，只要合约功能进行扩展，创造代币的人也会对代币拥有控制权。） （对于挖矿的误解：不少小哥哥小姐姐认为挖矿就是挖币，其实挖矿是挖区块，区块是干嘛的，是用来打包交易的，是存储数据的，代币是不用挖的，当你挖到了区块，代币是给你的奖励，在发行量一定的情况下，代币会越来越少，所以挖到区块的奖励会变少。那奖励少了为什么还要挖矿呢，因为你的任何一笔交易都需要记录，一个区块的大小也就几M，存储不了那么多交易信息，所以要持续挖区块来记录你的交易，同时交易的手续费，会奖励给挖出区块的人。） 部署合约： &nbsp; &nbsp;&nbsp; 部署合约有多种方式&nbsp; &nbsp; &nbsp; 1 geth 编译代码 ---部署合约 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 用ethereum wallet钱包部署合约 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 最简单直观的部署合约方式：&nbsp;&nbsp;MetaMask和Remix Solidity IDE&nbsp;部署合约 &nbsp; &nbsp;我们按照&nbsp;MetaMask和Remix Solidity IDE&nbsp;来进行部署合约。 &nbsp;1：&nbsp;创建钱包帐号。MetaMask是钱包的一种，在chrome浏览器中，安装MetaMask插件即可，安装完成后，右上角会出现一个“狐狸头”的标志，点击该标志，打开钱包，第一步，创建账户，（创建账户只需要输入面密码即可，名称创建后可以随便改，该账户就是一个hash值，如何给自己创建的账户冲以太币，可以上https://otcbtc.com/sign_up网站，按照操作买以太币，然后转账到自己创建的账户）创建成功后，记住密码还有产生的几个随机单词（一定要记录下来）。如下： &nbsp;&nbsp;&nbsp;2：打开&nbsp;Remix Solidity IDE&nbsp;访问地址：&nbsp;http://remix.ethereum.org/#optimize=false&amp;version=soljson-v0.4.21+commit.dfe3193c.js&nbsp; &nbsp;界面如下&nbsp; 3：&nbsp; 拷贝“编写代币合约”后边的代码到Remix Solidity IDE中按照如下编译 4： create 发布&nbsp; 如下 &nbsp; &nbsp; 5 create后，产生hash值，拷贝hash值，在钱包中添加token OK，如上所示，第一个属于你的真正意义上的去中心化数字货币就诞生了。正式网络和测试网络部署方法一样，不需要买eth就是了。 如果是测试网络，如何获得ETH？&nbsp; &nbsp;进入 https://gitter.im/kovan-testnet/faucet&nbsp; 下方直接发送你的账户地址（hash值）即可，一般五分钟到账，会得到五个测试网络用的ETH币。 6（如果部署的是eth主网，非测试网，执行该步骤，测试网络可以不理会） 发布了代币以后，如果以后进行ico，那么需要发布源码公开。步骤如下 &nbsp; &nbsp;①&nbsp; 拷贝部署成功的合约地址（hash），到&nbsp; https://etherscan.io/&nbsp; &nbsp;右上角搜索hash &nbsp; &nbsp;②&nbsp; 按照如下图进行verify AND publish &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;打开如下页面第一步 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;打开如下页面第二部 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 打开如下页面第三部 &nbsp; &nbsp; &nbsp; &nbsp; ok&nbsp; 现在的代币就比较完整了，差ico了 代币转账： &nbsp; &nbsp;1&nbsp; metamask钱包转账：&nbsp; 如下 &nbsp; &nbsp;输入地址和代币数量 2&nbsp; 网页钱包转账：&nbsp; 如下&nbsp;&nbsp;https://www.myetherwallet.com/#send-transaction &nbsp; &nbsp; 登录账户： &nbsp; 转账交易 &nbsp; &nbsp; &nbsp;qq群交流 &nbsp; &nbsp; &nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/31/2c1f161fa27a80cdaa69ca250f8cd9ae.html","headline":"基于以太坊发布属于自己的数字货币（代币）完整版","dateModified":"2018-03-31T00:00:00+08:00","datePublished":"2018-03-31T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/31/2c1f161fa27a80cdaa69ca250f8cd9ae.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>基于以太坊发布属于自己的数字货币（代币）完整版</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-7f5a1a725b.css"> 
 <div class="htmledit_views"> 
  <h4 style="text-align:center;"><strong>基于以太坊发布属于自己的数字货币（代币）完整版</strong></h4>
  <h4 style="text-align:center;"><strong>（<span style="color:rgb(255,0,0);">参考资料来源于网络以及各种摸索，其中各种坑</span>）</strong></h4>
  <p>&nbsp;</p>
  <p></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">本文</span></span><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">单纯</span></span><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">从技术角度详细介绍如何基于以太坊</span>ERC20创建代币的流程(</span><span style="background:rgb(255,255,255);"><span style="color:#ff0000;">此案例是部署的eth主网，非测试案例</span></span><span style="color:rgb(85,85,85);background:rgb(255,255,255);">)</span></strong></p>
  <span style="font-family:'宋体';"></span>
  <p>&nbsp;</p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">写在前面</span></span></strong></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp;</span></strong></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看</span></span></strong><a href="https://learnblockchain.cn/2017/11/20/whatiseth/" rel="nofollow"><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">以太坊是什么</span></span></strong></a>。</p>
  <h2 align="justify" style="background:rgb(255,255,255);"><strong><span style="color:rgb(85,85,85);"><span style="font-family:Lato;">代币</span>Token</span></strong></h2>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">如果不那么追求精确的定义，代币就是数字货币，比特币、以太币就是一个代币。</span></span><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><br></span><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。</span></span><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><br></span></strong></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">因此不管是出于商业，还是学习很多人想创建一个自己的代币，先贴一个图看看创建的代币是什么样子。</span></span></strong></p>
  <p><span style="color:rgb(85,85,85);font-family:Lato;"><strong>以我自己发布的</strong></span><span style="background-color:rgb(255,255,255);color:rgb(85,85,85);"><strong>BliBli币 Bcoin为例</strong></span></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">访问地址</span> <span style="font-family:Lato;">：</span> &nbsp;https://etherscan.io/token/0x73c8da697fe5e145f6269c4c852e59a7328f9371</span></strong></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><br></span></strong></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331181804640?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></strong></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"></span></strong></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><br></span></strong></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp;</span><span style="background-color:rgb(255,255,255);color:rgb(85,85,85);font-family:Lato;"><strong>今天我们就来详细讲一讲怎样创建一个这样的代币。</strong></span></p>
  <h3 align="justify" style="background:rgb(255,255,255);"><strong><span style="color:rgb(85,85,85);">ERC20 Token</span></strong></h3>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);">ERC20和代币一同出现， ERC20是以太坊定义的一个</span></strong><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md" rel="nofollow"><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">代币标准</span></span></strong></a><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">。</span></span><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:Lato;">是一种发行代币合约必须要遵守的协议，该协议规定了几个参数</span>——发行货币的名称，简称，发行量，要支持的函数等，只有支持了该协议才会被以太坊所认同。</span></strong></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);">erc20标准代码如下</span></strong></p>
  <pre><code class="language-html">// https://github.com/ethereum/EIPs/issues/20
  contract ERC20 {
      function totalSupply() constant returns (uint totalSupply);
      function balanceOf(address _owner) constant returns (uint balance);
      function transfer(address _to, uint _value) returns (bool success);
      function transferFrom(address _from, address _to, uint _value) returns (bool success);
      function approve(address _spender, uint _value) returns (bool success);
      function allowance(address _owner, address _spender) constant returns (uint remaining);
      event Transfer(address indexed _from, address indexed _to, uint _value);
      event Approval(address indexed _owner, address indexed _spender, uint _value);
    }</code></pre>
  <br>
  <p>totalSupply:&nbsp; 代表的是代币发行总量&nbsp; &nbsp; totalSupply():该方法可以返回代币的总数量</p>
  <p>name:&nbsp; 发行代币的名称&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dicimals:&nbsp; 发行代币以后，代币交易的最小单位</p>
  <p>balanceOf(): 该方法返回的是输入钱包地址后，该钱包的代币余额</p>
  <p>tansferFrom() :从一个地址向另一个地址发送余额</p>
  <p>approve(): 允许_spender从你的账户转出_value余额</p>
  <p></p>
  <p><span style="font-weight:bold;"><span></span></span></p>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);">allowance(): 允许_spender从你的账户转出_value的余额，调用多次会覆盖可用量。某些DEX功能需要此功能</p>
  <p></p>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);">event Transfer(): &nbsp;token转移完成后出发</p>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);"></p>
  <p>event Approval(): &nbsp;approve(address _spender, uint256 _value)调用后触发</p>
  <p><br></p>
  <p></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:'PingFang SC';">编写代币合约：</span></span></strong></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="font-family:'PingFang SC';"><br></span></span></strong></p>
  <pre><code class="language-html">pragma solidity ^0.4.12;

contract IMigrationContract {
    function migrate(address addr, uint256 nas) returns (bool success);
}

/* 灵感来自于NAS  coin*/
contract SafeMath {


    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x + y;
        assert((z &gt;= x) &amp;&amp; (z &gt;= y));
        return z;
    }

    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
        assert(x &gt;= y);
        uint256 z = x - y;
        return z;
    }

    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x * y;
        assert((x == 0)||(z/x == y));
        return z;
    }

}

contract Token {
    uint256 public totalSupply;
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
    function approve(address _spender, uint256 _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}


/*  ERC 20 token */
contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    mapping (address =&gt; uint256) balances;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;
}

contract BliBliToken is StandardToken, SafeMath {

    // metadata
    string  public constant name = "BliBli";
    string  public constant symbol = "BCoin";
    uint256 public constant decimals = 18;
    string  public version = "1.0";

    // contracts
    address public ethFundDeposit;          // ETH存放地址
    address public newContractAddr;         // token更新地址

    // crowdsale parameters
    bool    public isFunding;                // 状态切换到true
    uint256 public fundingStartBlock;
    uint256 public fundingStopBlock;

    uint256 public currentSupply;           // 正在售卖中的tokens数量
    uint256 public tokenRaised = 0;         // 总的售卖数量token
    uint256 public tokenMigrated = 0;     // 总的已经交易的 token
    uint256 public tokenExchangeRate = 625;             // 625 BILIBILI 兑换 1 ETH

    // events
    event AllocateToken(address indexed _to, uint256 _value);   // 分配的私有交易token;
    event IssueToken(address indexed _to, uint256 _value);      // 公开发行售卖的token;
    event IncreaseSupply(uint256 _value);
    event DecreaseSupply(uint256 _value);
    event Migrate(address indexed _to, uint256 _value);

    // 转换
    function formatDecimals(uint256 _value) internal returns (uint256 ) {
        return _value * 10 ** decimals;
    }

    // constructor
    function BliBliToken(
        address _ethFundDeposit,
        uint256 _currentSupply)
    {
        ethFundDeposit = _ethFundDeposit;

        isFunding = false;                           //通过控制预CrowdS ale状态
        fundingStartBlock = 0;
        fundingStopBlock = 0;

        currentSupply = formatDecimals(_currentSupply);
        totalSupply = formatDecimals(10000000);
        balances[msg.sender] = totalSupply;
        if(currentSupply &gt; totalSupply) throw;
    }

    modifier isOwner()  { require(msg.sender == ethFundDeposit); _; }

    ///  设置token汇率
    function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {
        if (_tokenExchangeRate == 0) throw;
        if (_tokenExchangeRate == tokenExchangeRate) throw;

        tokenExchangeRate = _tokenExchangeRate;
    }

    /// @dev 超发token处理
    function increaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + currentSupply &gt; totalSupply) throw;
        currentSupply = safeAdd(currentSupply, value);
        IncreaseSupply(value);
    }

    /// @dev 被盗token处理
    function decreaseSupply (uint256 _value) isOwner external {
        uint256 value = formatDecimals(_value);
        if (value + tokenRaised &gt; currentSupply) throw;

        currentSupply = safeSubtract(currentSupply, value);
        DecreaseSupply(value);
    }

    ///  启动区块检测 异常的处理
    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {
        if (isFunding) throw;
        if (_fundingStartBlock &gt;= _fundingStopBlock) throw;
        if (block.number &gt;= _fundingStartBlock) throw;

        fundingStartBlock = _fundingStartBlock;
        fundingStopBlock = _fundingStopBlock;
        isFunding = true;
    }

    ///  关闭区块异常处理
    function stopFunding() isOwner external {
        if (!isFunding) throw;
        isFunding = false;
    }

    /// 开发了一个新的合同来接收token（或者更新token）
    function setMigrateContract(address _newContractAddr) isOwner external {
        if (_newContractAddr == newContractAddr) throw;
        newContractAddr = _newContractAddr;
    }

    /// 设置新的所有者地址
    function changeOwner(address _newFundDeposit) isOwner() external {
        if (_newFundDeposit == address(0x0)) throw;
        ethFundDeposit = _newFundDeposit;
    }

    ///转移token到新的合约
    function migrate() external {
        if(isFunding) throw;
        if(newContractAddr == address(0x0)) throw;

        uint256 tokens = balances[msg.sender];
        if (tokens == 0) throw;

        balances[msg.sender] = 0;
        tokenMigrated = safeAdd(tokenMigrated, tokens);

        IMigrationContract newContract = IMigrationContract(newContractAddr);
        if (!newContract.migrate(msg.sender, tokens)) throw;

        Migrate(msg.sender, tokens);               // log it
    }

    /// 转账ETH 到BILIBILI团队
    function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }

    ///  将BILIBILI token分配到预处理地址。
    function allocateToken (address _addr, uint256 _eth) isOwner external {
        if (_eth == 0) throw;
        if (_addr == address(0x0)) throw;

        uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);
        if (tokens + tokenRaised &gt; currentSupply) throw;

        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[_addr] += tokens;

        AllocateToken(_addr, tokens);  // 记录token日志
    }

    /// 购买token
    function () payable {
        if (!isFunding) throw;
        if (msg.value == 0) throw;

        if (block.number &lt; fundingStartBlock) throw;
        if (block.number &gt; fundingStopBlock) throw;

        uint256 tokens = safeMult(msg.value, tokenExchangeRate);
        if (tokens + tokenRaised &gt; currentSupply) throw;

        tokenRaised = safeAdd(tokenRaised, tokens);
        balances[msg.sender] += tokens;

        IssueToken(msg.sender, tokens);  //记录日志
    }
}</code></pre>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);"><span style="background-color:rgb(255,255,255);">以上的代币合约，是参考以太坊已经ICO过，并且产生价值的代币合约参考而来，完整比且功能强大，此合约创建的代币，具有“交易”，“转账”，“异常检测”，“更改代币持有人”，“设置汇率”，“被盗处理”，“超发代币”等功能。</span></p>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);"><span style="background-color:rgb(255,255,255);">（解释下：在以太坊的世界中，硬通货就是ETH-以太币，相当于现实世界中的黄金，我们发布的代币，就相当于各国发行的需要 与黄金挂钩兑换比率的货币，国家对货币拥有控制权，只要合约功能进行扩展，创造代币的人也会对代币拥有控制权。）</span></p>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);"><span style="background-color:rgb(255,255,255);">（对于挖矿的误解：不少小哥哥小姐姐认为挖矿就是挖币，其实挖矿是挖区块，区块是干嘛的，是用来打包交易的，是存储数据的，代币是不用挖的，当你挖到了区块，代币是给你的奖励，在发行量一定的情况下，代币会越来越少，所以挖到区块的奖励会变少。那奖励少了为什么还要挖矿呢，因为你的任何一笔交易都需要记录，一个区块的大小也就几M，存储不了那么多交易信息，所以要持续挖区块来记录你的交易，同时交易的手续费，会奖励给挖出区块的人。）</span></p>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);"><span style="background-color:rgb(255,255,255);"><br></span></p>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);"><span style="background-color:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);">部署合约：</span></span></p>
  <p class="p" align="justify" style="text-indent:0pt;line-height:15.6pt;"><span style="font-family:'PingFang SC';letter-spacing:0pt;font-size:9.5pt;"><span style="color:#555555;background-color:rgb(255,255,255);">&nbsp; &nbsp;&nbsp;</span></span></p>
  <p align="justify" style="background:rgb(255,255,255);color:rgb(85,85,85);"><span style="font-family:'PingFang SC';">部署合约有多种方式</span>&nbsp; &nbsp; &nbsp; 1 geth 编译代码 ---部署合约</p>
  <p align="justify" style="background:rgb(255,255,255);color:rgb(85,85,85);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 用ethereum wallet钱包部署合约</p>
  <p align="justify" style="background:rgb(255,255,255);color:rgb(85,85,85);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 最简单直观的部署合约方式：&nbsp;&nbsp;<a href="https://metamask.io/" rel="nofollow"><span style="color:rgb(79,79,79);">MetaMask</span></a>和<a href="https://remix.ethereum.org/" rel="nofollow"><span style="color:rgb(79,79,79);">Remix Solidity IDE</span></a>&nbsp;部署合约</p>
  <p align="justify" style="background:rgb(255,255,255);color:rgb(85,85,85);">&nbsp; &nbsp;我们按照&nbsp;<a href="https://metamask.io/" rel="nofollow"><span style="color:rgb(79,79,79);">MetaMask</span></a>和<a href="https://remix.ethereum.org/" rel="nofollow"><span style="color:rgb(79,79,79);">Remix Solidity IDE</span></a>&nbsp;来进行部署合约。</p>
  <p><span style="background-color:rgb(255,255,255);">&nbsp;<span style="color:#ff0000;">1</span></span><span style="background-color:rgb(255,102,102);"><span style="font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:#ff0000;">：</span></span></span><span style="color:rgb(79,79,79);background-color:rgb(255,255,255);">&nbsp;</span><span style="background-color:rgb(255,255,255);"><span style="color:#ff0000;">创建钱包帐号</span></span><span style="color:rgb(79,79,79);background-color:rgb(255,255,255);">。</span><a href="https://metamask.io/" rel="nofollow" style="color:rgb(79,79,79);background-color:rgb(255,255,255);">MetaMask</a><span style="color:rgb(85,85,85);background-color:rgb(255,255,255);font-family:'PingFang SC';">是钱包的一种，在</span><span style="color:rgb(85,85,85);background-color:rgb(255,255,255);">chrome浏览器中，安装</span><a href="https://metamask.io/" rel="nofollow" style="color:rgb(85,85,85);background-color:rgb(255,255,255);"><span style="color:rgb(79,79,79);">MetaMask</span></a><span style="color:rgb(85,85,85);background-color:rgb(255,255,255);">插件即可，安装完成后，右上角会出现一个“狐狸头”的标志，点击该标志，打开钱包，第一步，创建账户，（创建账户只需要输入面密码即可，名称创建后可以随便改，该账户就是一个hash值，如何给自己创建的账户冲以太币，可以上https://otcbtc.com/sign_up网站，按照操作买以太币，然后转账到自己创建的账户）创建成功后，记住密码还有产生的几个随机单词（一定要记录下来）。如下：</span></p>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331190227923?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p style="background-color:rgb(255,255,255);"><span style="color:#555555;">&nbsp;</span><span style="color:#3366ff;">&nbsp;</span><span style="font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:#ff0000;">&nbsp;2：打开</span></span><span style="color:#3366ff;">&nbsp;</span><span style="font-family:'PingFang SC';"><a href="https://remix.ethereum.org/" rel="nofollow" style="font-family:'PingFang SC';"><span style="color:#ff0000;">Remix Solidity ID</span></a><a href="https://remix.ethereum.org/" rel="nofollow" style="color:rgb(51,102,255);font-family:'PingFang SC';">E</a><span style="color:#3366ff;">&nbsp;</span><span style="color:#555555;">访问地址：&nbsp;http://remix.ethereum.org/#optimize=false&amp;version=soljson-v0.4.21+commit.dfe3193c.js&nbsp; &nbsp;界面如下&nbsp;</span></span></p>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331190820888?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><span style="background-color:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);"><a href="https://remix.ethereum.org/" rel="nofollow" style="background-color:rgb(255,255,255);color:rgb(85,85,85);border-bottom:1px solid rgb(153,153,153);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;"></a></span></span></p>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);"><span style="background-color:rgb(255,255,255);"><br></span></p>
  <p style="background-color:rgb(255,255,255);color:rgb(85,85,85);"><span style="background-color:rgb(255,255,255);"><br></span></p>
  <p style="background-color:rgb(255,255,255);"><span style="font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:#ff0000;">3：&nbsp; 拷贝“编写代币合约”后边的代码到</span><a href="https://remix.ethereum.org/" rel="nofollow" style="font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:rgb(255,0,0);">Remix Solidity I</span><span style="color:#ff0000;">D</span></a><span style="color:#ff0000;"><a href="https://remix.ethereum.org/" rel="nofollow" style="font-family:'PingFang SC';background-color:rgb(255,255,255);">E</a>中按照如下编译</span></span><br></p>
  <p style="background-color:rgb(255,255,255);"><span style="font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:#ff0000;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331191549376?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></span></p>
  <p style="background-color:rgb(255,255,255);"><span style="font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:#ff0000;">4： create 发布&nbsp; 如下</span></span></p>
  <p style="background-color:rgb(255,255,255);"><span style="font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:#ff0000;">&nbsp;<img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331191910145?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></span></span></p>
  <p style="background-color:rgb(255,255,255);"><span style="font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:#ff0000;">&nbsp;</span></span></p>
  <p style="background-color:rgb(255,255,255);"><span style="font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:#ff0000;">5 create后，产生hash值，拷贝hash值，在钱包中添加token</span></span></p>
  <p style="background-color:rgb(255,255,255);"><span style="font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:#ff0000;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331202731955?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></span></p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331202823564?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331202848716?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p><span style="color:rgb(255,0,0);font-family:'PingFang SC';background-color:rgb(255,255,255);"><br></span></p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331203201830?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p><br></p>
  <p><span style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">OK，如上所示，第一个属于你的真正意义上的去中心化数字货币就诞生了。正式网络和测试网络部署方法一样，不需要买eth就是了。</span><br></p>
  <p><span style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">如果是测试网络，如何获得ETH？&nbsp; &nbsp;进入 https://gitter.im/kovan-testnet/faucet&nbsp; 下方直接发送你的账户地址（hash值）即可，一般五分钟到账，会得到五个测试网络用的ETH币。</span></p>
  <p><br></p>
  <p><br></p>
  <p><span style="color:rgb(255,0,0);font-family:'PingFang SC';background-color:rgb(255,255,255);">6（如果部署的是eth主网，非测试网，执行该步骤，测试网络可以不理会）</span><br></p>
  <p><span style="color:rgb(255,0,0);font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">发布了代币以后，如果以后进行ico，那么需要发布源码公开。步骤如下</span><br></span></p>
  <p><span style="color:rgb(255,0,0);font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">&nbsp; &nbsp;①&nbsp; 拷贝部署成功的合约地址（hash），到&nbsp; https://etherscan.io/&nbsp; &nbsp;右上角搜索hash</span></span></p>
  <p><span style="color:rgb(255,0,0);font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">&nbsp; &nbsp;②&nbsp; 按照如下图进行verify AND publish</span></span></p>
  <p><span style="color:rgb(255,0,0);font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;打开如下页面第一步</span></span></p>
  <p><span style="color:rgb(255,0,0);font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331204356737?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></span></p>
  <p><span style="color:rgb(255,0,0);font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><br></span></span></p>
  <p><span style="color:rgb(255,0,0);font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;打开如下页面第二部</span></span></p>
  <p><span style="color:rgb(255,0,0);font-family:'PingFang SC';background-color:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><br></span></span></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018033120480518?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></strong></p>
  <p><br></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp;</span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 打开如下页面第三部</span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331205343546?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp;</span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp;</span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><br></span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331205501928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp;</span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><br></span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp; ok&nbsp; 现在的代币就比较完整了，差ico了</span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);"><br></span></span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);"><br></span></span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);">代币转账：</span><br></span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);">&nbsp; &nbsp;1&nbsp; metamask钱包转账：&nbsp; 如下</span></span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331210215652?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></span></p>
  <p>&nbsp; &nbsp;输入地址和代币数量</p>
  <p><br></p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331210316702?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;" alt=""><br></p>
  <p><br></p>
  <p><br></p>
  <p><span style="background-color:rgb(255,255,255);">2</span><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);">&nbsp; <a href="https://www.myetherwallet.com/#send-transaction" rel="nofollow">网页钱包</a>转账：&nbsp; 如下&nbsp;&nbsp;https://www.myetherwallet.com/#send-transaction</span></p>
  <p><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);">&nbsp; &nbsp; 登录账户：</span></p>
  <p><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331210714266?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p>
  <p><br></p>
  <p>&nbsp; 转账交易</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331210945819?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);"><br></span></span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);"><span style="color:rgb(85,85,85);font-family:'PingFang SC';font-weight:700;background-color:rgb(255,255,255);"><br></span></span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp; &nbsp; &nbsp;qq群交流</span></p>
  <p><strong><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp;<img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180331212905532?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBVkFfSEhISA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></span></strong></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp;</span></p>
  <p><span style="color:rgb(85,85,85);background:rgb(255,255,255);">&nbsp;</span></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/JAVA_HHHH/article/details/79771752,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/JAVA_HHHH/article/details/79771752,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
