<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>基于Java语言构建区块链（四）—— 交易（UTXO） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="基于Java语言构建区块链（四）—— 交易（UTXO）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="引言 上一篇&nbsp;文章，我们实现了区块数据的持久化，本篇开始交易环节的实现。交易这一环节是整个比特币系统当中最为关键的一环，并且区块链唯一的目的就是通过安全的、可信的方式来存储交易信息，防止它们创建之后被人恶意篡改。今天我们开始实现交易这一环节，但由于这是一个很大的话题，所以我们分为两部分：第一部分我们将实现区块链交易的基本机制，到第二部分，我们再来研究它的细节。 &lt;!--more--&gt; 比特币交易 如果你开发过Web应用程序，为了实现支付系统，你可能会在数据库中创建一些数据库表：账户&nbsp;和&nbsp;交易记录。账户用于存储用户的个人信息以及账户余额等信息，交易记录用于存储资金从一个账户转移到另一个账户的记录。但是在比特币中，支付系统是以一种完全不一样的方式实现的，在这里： 没有账户 没有余额 没有地址 没有 Coins（币） 没有发送者和接受者 由于区块链是一个公开的数据库，我们不希望存储有关钱包所有者的敏感信息。Coins&nbsp;不会汇总到钱包中。交易不会将资金从一个地址转移到另一个地址。没有可保存帐户余额的字段或属性。只有交易信息。那比特币的交易信息里面到底存储的是什么呢？ 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ 交易组成 一笔比特币的交易由&nbsp;交易输入&nbsp;和&nbsp;交易输出&nbsp;组成，数据结构如下： /** * 交易 * * @author wangwei * @date 2017/03/04 */ @Data @AllArgsConstructor @NoArgsConstructor public class Transaction { /** * 交易的Hash */ private byte[] txId; /** * 交易输入 */ private TXInput[] inputs; /** * 交易输出 */ private TXOutput[] outputs; } 一笔交易的&nbsp;交易输入&nbsp;其实是指向上一笔交易的交易输出&nbsp;（这个后面详细说明）。我们钱包里面的 Coin（币）实际是存储在这些&nbsp;交易输出&nbsp;里面。下图表示了区块链交易系统里面各个交易相互引用的关系： 注意： 有些&nbsp;交易输出&nbsp;并不是由&nbsp;交易输入&nbsp;产生，而是凭空产生的（后面会详细介绍）。 但，交易输入&nbsp;必须指向某个&nbsp;交易输出，它不能凭空产生。 在一笔交易里面，交易输入&nbsp;可能会来自多笔交易所产生的&nbsp;交易输出。 在整篇文章中，我们将使用诸如“钱”，“硬币”，“花费”，“发送”，“账户”等词语。但比特币中没有这样的概念，在比特币交易中，交易信息是由&nbsp;锁定脚本&nbsp;锁定一个数值，并且只能被所有者的&nbsp;解锁脚本&nbsp;解锁。（解铃还须系铃人） 交易输出 让我们先从交易输出开始，他的数据结构如下： /** * 交易输出 * * @author wangwei * @date 2017/03/04 */ @Data @AllArgsConstructor @NoArgsConstructor public class TXOutput { /** * 数值 */ private int value; /** * 锁定脚本 */ private String scriptPubKey; } 实际上，它表示的是能够存储 &quot;coins（币）&quot;的交易输出（注意&nbsp;value&nbsp;字段）。并且这里所谓的&nbsp;value&nbsp;实际上是由存储在ScriptPubKey&nbsp;（锁定脚本）中的一个puzzle（难题） 所锁定。在内部，比特币使用称为脚本的脚本语言，用于定义输出锁定和解锁逻辑。这个语言很原始（这是故意的，以避免可能的黑客和滥用），但我们不会详细讨论它。 你可以在这里找到它的详细解释。here 在比特币中，value&nbsp;字段存储着&nbsp;satoshis&nbsp;的任意倍的数值，而不是BTC的数量。satoshis&nbsp;是比特币的百万分之一（0.00000001 BTC），因此这是比特币中最小的货币单位（如1美分）。 satoshis：聪 锁定脚本是一个放在一个输出值上的“障碍”，同时它明确了今后花费这笔输出的条件。由于锁定脚本往往含有一个公钥（即比特币地址），在历史上它曾被称作一个脚本公钥代码。在大多数比特币应用源代码中，脚本公钥代码便是我们所说的锁定脚本。 由于我们还没有实现钱包地址的逻辑，所以这里先暂且忽略锁定脚本相关的逻辑。ScriptPubKey&nbsp;将会存储任意的字符串（用户定义的钱包地址） 顺便说一句，拥有这样的脚本语言意味着比特币也可以用作智能合约平台。 关于&nbsp;交易输出&nbsp;的一个重要的事情是它们是不可分割的，这意味着你不能将它所存储的数值拆开来使用。当这个交易输出在新的交易中被交易输入所引用时，它将作为一个整体被花费掉。 如果其值大于所需值，那么剩余的部分则会作为零钱返回给付款方。 这与真实世界的情况类似，例如，您支付5美元的钞票用于购买1美元的东西，那么你将会得到4美元的零钱。 交易输入 /** * 交易输入 * * @author wangwei * @date 2017/03/04 */ @Data @AllArgsConstructor @NoArgsConstructor public class TXInput { /** * 交易Id的hash值 */ private byte[] txId; /** * 交易输出索引 */ private int txOutputIndex; /** * 解锁脚本 */ private String scriptSig; } 前面提到过，一个交易输入指向的是某一笔交易的交易输出： txId&nbsp;存储的是某笔交易的ID值 txOutputIndex&nbsp;存储的是交易中这个交易输出的索引位置（因为一笔交易可能包含多个交易输出） scriptSig&nbsp;主要是提供用于交易输出中&nbsp;ScriptPubKey&nbsp;所需的验证数据。 如果这个数据被验证正确，那么相应的交易输出将被解锁，并且其中的 value 能够生成新的交易输出； 如果不正确，那么相应的交易输出将不能被交易输入所引用； 通过锁定脚本与解锁脚本这种机制，保证了某个用户不能花费属于他人的Coins。 同样，由于我们尚未实现钱包地址功能，ScriptSig&nbsp;将会存储任意的用户所定义的钱包地址。我们将会在下一章节实现公钥和数字签名验证。 说了这么多，我们来总结一下。交易输出是&quot;Coins&quot;实际存储的地方。每一个交易输出都带有一个锁定脚本，它决定了解锁的逻辑。每一笔新的交易必须至少有一个交易输入与交易输出。一笔交易的交易输入指向前一笔交易的交易输出，并且提供用于锁定脚本解锁需要的数据（ScriptSig&nbsp;字段），然后利用交易输出中的&nbsp;value&nbsp;去创建新的交易输出。 注意，这段话的原文如下，但是里面有表述错误的地方，交易输出带有的是锁定脚本，而不是解锁脚本。 Let’s sum it up. Outputs are where “coins” are stored. Each output comes with an unlocking script, which determines the logic of unlocking the output. Every new transaction must have at least one input and output. An input references an output from a previous transaction and provides data (the&nbsp;ScriptSig&nbsp;field) that is used in the output’s unlocking script to unlock it and use its value to create new outputs. 那到底是先有交易输入还是先有交易输出呢？ 鸡与蛋的问题 在比特币中，鸡蛋先于鸡出现。交易输入源自于交易输出的逻辑是典型的&quot;先有鸡还是先有蛋&quot;的问题：交易输入产生交易输出，交易输出又会被交易输入所引用。在比特币中，交易输出先于交易输入出现。 当矿工开始开采区块时，区块中会被添加一个&nbsp;coinbase&nbsp;交易。coinbase 交易是一种特殊的交易，它不需要以前已经存在的交易输出。它会凭空创建出交易输出（i.e: Coins）。也即，鸡蛋的出现并不需要母鸡，这笔交易是作为矿工成功挖出新的区块后的一笔奖励。 正如你所知道的那样，在区块链的最前端，即第一个区块，有一个创世区块。他产生了区块链中有史以来的第一个交易输出，并且由于没有前一笔交易，也就没有相应的输出，因此不需要前一笔交易的交易输出。 让我们来创建 coinbase 交易： /** * 创建CoinBase交易 * * @param to 收账的钱包地址 * @param data 解锁脚本数据 * @return */ public Transaction newCoinbaseTX(String to, String data) { if (StringUtils.isBlank(data)) { data = String.format(&quot;Reward to &#39;%s&#39;&quot;, to); } // 创建交易输入 TXInput txInput = new TXInput(new byte[]{}, -1, data); // 创建交易输出 TXOutput txOutput = new TXOutput(SUBSIDY, to); // 创建交易 Transaction tx = new Transaction(null, new TXInput[]{txInput}, new TXOutput[]{txOutput}); // 设置交易ID tx.setTxId(); return tx; } coinbase交易只有一个交易输入。在我们的代码实现中，txId&nbsp;是空数组，txOutputIndex&nbsp;设置为了 -1。另外，coinbase交易不会在&nbsp;ScriptSig&nbsp;字段上存储解锁脚本，相反，存了一个任意的数据。 在比特币中，第一个 coinbase 交易报刊了如下的信息：&quot;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks&quot;.&nbsp; 点击查看 SUBSIDY&nbsp;是挖矿奖励数量。在比特币中，这个奖励数量没有存储在任何地方，而是依据现有区块的总数进行计算而得到：区块总数 除以 210000。开采创世区块得到的奖励为50BTC，每过 210000 个区块，奖励会减半。在我们的实现中，我们暂且将挖矿奖励设置为常数。（至少目前是这样） 在区块链中存储交易信息 从现在开始，每一个区块必须存储至少一个交易信息，并且尽可能地避免在没有交易数据的情况下进行挖矿。这意味着我们必须移除&nbsp;Block&nbsp;对象中的&nbsp;date&nbsp;字段，取而代之的是&nbsp;transactions： /** * 区块 * * @author wangwei * @date 2018/02/02 */ @Data @AllArgsConstructor @NoArgsConstructor public class Block { /** * 区块hash值 */ private String hash; /** * 前一个区块的hash值 */ private String previousHash; /** * 交易信息 */ private Transaction[] transactions; /** * 区块创建时间(单位:秒) */ private long timeStamp; } 相应地，newGenesisBlock&nbsp;与&nbsp;newBlock&nbsp;也都需要做改变： /** * &lt;p&gt; 创建创世区块 &lt;/p&gt; * * @param coinbase * @return */ public static Block newGenesisBlock(Transaction coinbase) { return Block.newBlock(&quot;&quot;, new Transaction[]{coinbase}); } /** * &lt;p&gt; 创建新区块 &lt;/p&gt; * * @param previousHash * @param transactions * @return */ public static Block newBlock(String previousHash, Transaction[] transactions) { Block block = new Block(&quot;&quot;, previousHash, transactions, Instant.now().getEpochSecond(), 0); ProofOfWork pow = ProofOfWork.newProofOfWork(block); PowResult powResult = pow.run(); block.setHash(powResult.getHash()); block.setNonce(powResult.getNonce()); return block; } 接下来，修改&nbsp;newBlockchain&nbsp;方法： /** * &lt;p&gt; 创建区块链 &lt;/p&gt; * * @param address 钱包地址 * @return */ public static Blockchain newBlockchain(String address) throws Exception { String lastBlockHash = RocksDBUtils.getInstance().getLastBlockHash(); if (StringUtils.isBlank(lastBlockHash)) { // 创建 coinBase 交易 Transaction coinbaseTX = Transaction.newCoinbaseTX(address, &quot;&quot;); Block genesisBlock = Block.newGenesisBlock(coinbaseTX); lastBlockHash = genesisBlock.getHash(); RocksDBUtils.getInstance().putBlock(genesisBlock); RocksDBUtils.getInstance().putLastBlockHash(lastBlockHash); } return new Blockchain(lastBlockHash); } 现在，代码有钱包地址的接口，将会收到开采创世区块的奖励。 工作量证明（Pow） Pow算法必须将存储在区块中的交易信息考虑在内，以保存交易信息存储的一致性和可靠性。因此，我们必须修改&nbsp;ProofOfWork.prepareData&nbsp;接口代码逻辑： /** * 准备数据 * &lt;p&gt; * 注意：在准备区块数据时，一定要从原始数据类型转化为byte[]，不能直接从字符串进行转换 * @param nonce * @return */ private String prepareData(long nonce) { byte[] prevBlockHashBytes = {}; if (StringUtils.isNoneBlank(this.getBlock().getPrevBlockHash())) { prevBlockHashBytes = new BigInteger(this.getBlock().getPrevBlockHash(), 16).toByteArray(); } return ByteUtils.merge( prevBlockHashBytes, this.getBlock().hashTransaction(), ByteUtils.toBytes(this.getBlock().getTimeStamp()), ByteUtils.toBytes(TARGET_BITS), ByteUtils.toBytes(nonce) ); } 其中&nbsp;hashTransaction&nbsp;代码如下： /** * 对区块中的交易信息进行Hash计算 * * @return */ public byte[] hashTransaction() { byte[][] txIdArrays = new byte[this.getTransactions().length][]; for (int i = 0; i &lt; this.getTransactions().length; i++) { txIdArrays[i] = this.getTransactions()[i].getTxId(); } return DigestUtils.sha256(ByteUtils.merge(txIds)); } 同样，我们使用哈希值来作为数据的唯一标识。我们希望区块中的所有交易数据都能通过一个哈希值来定义它的唯一标识。为了达到这个目的，我们计算了每一个交易的唯一哈希值，然后将他们串联起来，再对这个串联后的组合进行哈希值计算。 比特币使用更复杂的技术：它将所有包含在块中的交易表示为&nbsp; Merkle树&nbsp;，并在Proof-of-Work系统中使用该树的根散列。 这种方法只需要跟节点的散列值就可以快速检查块是否包含某笔交易，而无需下载所有交易。 UTXO（未花费交易输出） UTXO：unspend transaction output.（未被花费的交易输出） 在比特币的世界里既没有账户，也没有余额，只有分散到区块链里的UTXO. UTXO&nbsp;是理解比特币交易原理的关键所在，我们先来看一段场景： 场景：假设你过去分别向A、B、C这三个比特币用户购买了BTC，从A手中购买了3.5个BTC，从B手中购买了4.5个BTC，从C手中购买了2个BTC，现在你的比特币钱包里面恰好剩余10个BTC。 问题：这个10个BTC是真正的10个BTC吗？其实不是，这句话可能听起来有点怪。（什么！我钱包里面的BTC不是真正的BTC，你不要吓我……） 解释：前面提到过在比特币的交易系统当中，并不存在账户、余额这些概念，所以，你的钱包里面的10个BTC，并不是说钱包余额为10个BTC。而是说，这10个BTC其实是由你的比特币地址（钱包地址|公钥）锁定了的散落在各个区块和各个交易里面的UTXO的总和。 UTXO 是比特币交易的基本单位，每笔交易都会产生UTXO，一个UTXO可以是一“聪”的任意倍。给某人发送比特币实际上是创造新的UTXO，绑定到那个人的钱包地址，并且能被他用于新的支付。 一般的比特币交易由&nbsp;交易输入&nbsp;和&nbsp;交易输出&nbsp;两部分组成。A向你支付3.5个BTC这笔交易，实际上产生了一个新的UTXO，这个新的UTXO 等于 3.5个BTC（3.5亿聪），并且锁定到了你的比特币钱包地址上。 假如你要给你女（男）朋友转 1.5 BTC，那么你的钱包会从可用的UTXO中选取一个或多个可用的个体来拼凑出一个大于或等于一笔交易所需的比特币量。比如在这个假设场景里面，你的钱包会选取你和C的交易中的UTXO作为 交易输入，input = 2BTC，这里会生成两个新的交易输出，一个输出（UTXO = 1.5 BTC）会被绑定到你女（男）朋友的钱包地址上，另一个输出（UTXO = 0.5 BTC）会作为找零，重新绑定到你的钱包地址上。 有关比特币交易这部分更详细的内容，请查看： 《精通比特币（第二版）》第6章 —— 交易 我们需要找到所有未花费的交易输出（UTXO）。Unspent(未花费)&nbsp;意味着这些交易输出从未被交易输入所指向。这前面的图片中，UTXO如下： tx0, output 1; tx1, output 0; tx3, output 0; tx4, output 0. 当然，当我们检查余额时，我不需要区块链中所有的UTXO，我只需要能被我们解锁的UTXO（当前，我们还没有实现密钥对，而是替代为用户自定义的钱包地址）。首先，我们在交易输入与交易输出上定义锁定-解锁的方法： 交易输入： public class TXInput { ... /** * 判断解锁数据是否能够解锁交易输出 * * @param unlockingData * @return */ public boolean canUnlockOutputWith(String unlockingData) { return this.getScriptSig().endsWith(unlockingData); } } 交易输出： public class TXOutput { ... /** * 判断解锁数据是否能够解锁交易输出 * * @param unlockingData * @return */ public boolean canBeUnlockedWith(String unlockingData) { return this.getScriptPubKey().endsWith(unlockingData); } } 这里我们暂时用&nbsp;unlockingData&nbsp;来与脚本字段进行比较。我们会在后面的文章中来对这部分内容进行优化，我们将会基于私钥来实现用户的钱包地址。 下一步，查询所有与钱包地址绑定的包含UTXO的交易信息，有点复杂（本篇先这样实现，后面我们做一个与钱包地址映射的UTXO池来进行优化）： 从与钱包地址对应的交易输入中查询出所有已被花费了的交易输出 再来排除，寻找包含未被花费的交易输出的交易 public class Blockchain { ... /** * 查找钱包地址对应的所有未花费的交易 * * @param address 钱包地址 * @return */ private Transaction[] findUnspentTransactions(String address) throws Exception { Map&lt;String, int[]&gt; allSpentTXOs = this.getAllSpentTXOs(address); Transaction[] unspentTxs = {}; // 再次遍历所有区块中的交易输出 for (BlockchainIterator blockchainIterator = this.getBlockchainIterator(); blockchainIterator.hashNext(); ) { Block block = blockchainIterator.next(); for (Transaction transaction : block.getTransactions()) { String txId = Hex.encodeHexString(transaction.getTxId()); int[] spentOutIndexArray = allSpentTXOs.get(txId); for (int outIndex = 0; outIndex &lt; transaction.getOutputs().length; outIndex++) { if (spentOutIndexArray != null &amp;&amp; ArrayUtils.contains(spentOutIndexArray, outIndex)) { continue; } // 保存不存在 allSpentTXOs 中的交易 if (transaction.getOutputs()[outIndex].canBeUnlockedWith(address)) { unspentTxs = ArrayUtils.add(unspentTxs, transaction); } } } } return unspentTxs; } /** * 从交易输入中查询区块链中所有已被花费了的交易输出 * * @param address 钱包地址 * @return 交易ID以及对应的交易输出下标地址 * @throws Exception */ private Map&lt;String, int[]&gt; getAllSpentTXOs(String address) throws Exception { // 定义TxId ——&gt; spentOutIndex[]，存储交易ID与已被花费的交易输出数组索引值 Map&lt;String, int[]&gt; spentTXOs = new HashMap&lt;&gt;(); for (BlockchainIterator blockchainIterator = this.getBlockchainIterator(); blockchainIterator.hashNext(); ) { Block block = blockchainIterator.next(); for (Transaction transaction : block.getTransactions()) { // 如果是 coinbase 交易，直接跳过，因为它不存在引用前一个区块的交易输出 if (transaction.isCoinbase()) { continue; } for (TXInput txInput : transaction.getInputs()) { if (txInput.canUnlockOutputWith(address)) { String inTxId = Hex.encodeHexString(txInput.getTxId()); int[] spentOutIndexArray = spentTXOs.get(inTxId); if (spentOutIndexArray == null) { spentTXOs.put(inTxId, new int[]{txInput.getTxOutputIndex()}); } else { spentOutIndexArray = ArrayUtils.add(spentOutIndexArray, txInput.getTxOutputIndex()); spentTXOs.put(inTxId, spentOutIndexArray); } } } } } return spentTXOs; } ... } 得到了所有包含UTXO的交易数据，接下来，我们就可以得到所有UTXO集合了： public class Blockchain { ... /** * 查找钱包地址对应的所有UTXO * * @param address 钱包地址 * @return */ public TXOutput[] findUTXO(String address) throws Exception { Transaction[] unspentTxs = this.findUnspentTransactions(address); TXOutput[] utxos = {}; if (unspentTxs == null || unspentTxs.length == 0) { return utxos; } for (Transaction tx : unspentTxs) { for (TXOutput txOutput : tx.getOutputs()) { if (txOutput.canBeUnlockedWith(address)) { utxos = ArrayUtils.add(utxos, txOutput); } } } return utxos; } ... } 现在，我们可以实现获取钱包地址余额的接口了： public class CLI { ... /** * 查询钱包余额 * * @param address 钱包地址 */ private void getBalance(String address) throws Exception { Blockchain blockchain = Blockchain.createBlockchain(address); TXOutput[] txOutputs = blockchain.findUTXO(address); int balance = 0; if (txOutputs != null &amp;&amp; txOutputs.length &gt; 0) { for (TXOutput txOutput : txOutputs) { balance += txOutput.getValue(); } } System.out.printf(&quot;Balance of &#39;%s&#39;: %d\n&quot;, address, balance); } ... } 查询&nbsp;wangwei&nbsp;这个钱包地址的余额： $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei # 输出 Balance of &#39;wangwei&#39;: 10 转账 现在，我们想要给某人发送一些币。因此，我们需要创建一笔新的交易，然后放入区块中，再进行挖矿。到目前为止，我们只是实现了&nbsp;coinbase&nbsp;交易，现在我们需要实现常见的创建交易接口： public class Transaction { ... /** * 从 from 向 to 支付一定的 amount 的金额 * * @param from 支付钱包地址 * @param to 收款钱包地址 * @param amount 交易金额 * @param blockchain 区块链 * @return */ public static Transaction newUTXOTransaction(String from, String to, int amount, Blockchain blockchain) throws Exception { SpendableOutputResult result = blockchain.findSpendableOutputs(from, amount); int accumulated = result.getAccumulated(); Map&lt;String, int[]&gt; unspentOuts = result.getUnspentOuts(); if (accumulated &lt; amount) { throw new Exception(&quot;ERROR: Not enough funds&quot;); } Iterator&lt;Map.Entry&lt;String, int[]&gt;&gt; iterator = unspentOuts.entrySet().iterator(); TXInput[] txInputs = {}; while (iterator.hasNext()) { Map.Entry&lt;String, int[]&gt; entry = iterator.next(); String txIdStr = entry.getKey(); int[] outIdxs = entry.getValue(); byte[] txId = Hex.decodeHex(txIdStr); for (int outIndex : outIdxs) { txInputs = ArrayUtils.add(txInputs, new TXInput(txId, outIndex, from)); } } TXOutput[] txOutput = {}; txOutput = ArrayUtils.add(txOutput, new TXOutput(amount, to)); if (accumulated &gt; amount) { txOutput = ArrayUtils.add(txOutput, new TXOutput((accumulated - amount), from)); } Transaction newTx = new Transaction(null, txInputs, txOutput); newTx.setTxId(); return newTx; } ... } 在创建新的交易输出之前，我们需要事先找到所有的UTXO，并确保有足够的金额。这就是&nbsp;findSpendableOutputs&nbsp;要干的事情。之后，为每个找到的输出创建一个引用它的输入。接下来，我们创建两个交易输出： 一个&nbsp;output&nbsp;用于锁定到接收者的钱包地址上。这个是真正被转走的coins； 另一个&nbsp;output&nbsp;锁定到发送者的钱包地址上。这个就是 找零。只有当用于支付的UTXO总和大于要支付的金额时，才会创建这部分的 交易输出。记住：交易输出是不可分割的 findSpendableOutputs&nbsp;需要调用我们之前创建的&nbsp;findUnspentTransactions&nbsp;接口： public class Blockchain { ... /** * 寻找能够花费的交易 * * @param address 钱包地址 * @param amount 花费金额 */ public SpendableOutputResult findSpendableOutputs(String address, int amount) throws Exception { Transaction[] unspentTXs = this.findUnspentTransactions(address); int accumulated = 0; Map&lt;String, int[]&gt; unspentOuts = new HashMap&lt;&gt;(); for (Transaction tx : unspentTXs) { String txId = Hex.encodeHexString(tx.getTxId()); for (int outId = 0; outId &lt; tx.getOutputs().length; outId++) { TXOutput txOutput = tx.getOutputs()[outId]; if (txOutput.canBeUnlockedWith(address) &amp;&amp; accumulated &lt; amount) { accumulated += txOutput.getValue(); int[] outIds = unspentOuts.get(txId); if (outIds == null) { outIds = new int[]{outId}; } else { outIds = ArrayUtils.add(outIds, outId); } unspentOuts.put(txId, outIds); if (accumulated &gt;= amount) { break; } } } } return new SpendableOutputResult(accumulated, unspentOuts); } ... } 这个方法会遍历所有的UTXO并统计他们的总额。当计算的总额恰好大于或者等于需要转账的金额时，方法会停止遍历，然后返回用于支付的总额以及按交易ID分组的交易输出索引值数组。我们不想要花更多的钱。 现在，我们可以修改&nbsp;Block.mineBlock&nbsp;接口： public class Block { ... /** * 打包交易，进行挖矿 * * @param transactions */ public void mineBlock(Transaction[] transactions) throws Exception { String lastBlockHash = RocksDBUtils.getInstance().getLastBlockHash(); if (lastBlockHash == null) { throw new Exception(&quot;ERROR: Fail to get last block hash ! &quot;); } Block block = Block.newBlock(lastBlockHash, transactions); this.addBlock(block); } ... } 最后，我们来实现转账的接口： public class CLI { ... /** * 转账 * * @param from * @param to * @param amount */ private void send(String from, String to, int amount) throws Exception { Blockchain blockchain = Blockchain.createBlockchain(from); Transaction transaction = Transaction.newUTXOTransaction(from, to, amount, blockchain); blockchain.mineBlock(new Transaction[]{transaction}); RocksDBUtils.getInstance().closeDB(); System.out.println(&quot;Success!&quot;); } ... } 转账，意味着创建一笔新的交易并且通过挖矿的方式将其存入区块中。但是，比特币不会像我们这样做，它会把新的交易记录先存到内存池中，当一个矿工准备去开采一个区块时，它会把打包内存池中的所有交易信息，并且创建一个候选区块。只有当这个包含所有交易信息的候选区块被成功开采并且被添加到区块链上时，这些交易信息才算被确认。 让我们来测试一下： # 先确认 wangwei 的余额 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei Balance of &#39;wangwei&#39;: 10 # 转账 $ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Pedro -amount 6 Elapsed Time: 0.828 seconds correct hash Hex: 00000c5f50cf72db1f375a5d454f98bc49d07335db921cbef5fa9e58ad34d462 Success! # 查询 wangwei 的余额 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei Balance of &#39;wangwei&#39;: 4 # 查询 Pedro 的余额 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Pedro Balance of &#39;Pedro&#39;: 6 赞！现在让我们来创建更多的交易并且确保从多个交易输出进行转账是正常的： $ java -jar blockchain-java-jar-with-dependencies.jar send -from Pedro -to Helen -amount 2 Elapsed Time: 2.533 seconds correct hash Hex: 00000c81d541ad407a3767ad633d1147602df86fe14e1962ec145ab17b633e88 Success! $ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Helen -amount 2 Elapsed Time: 1.481 seconds correct hash Hex: 00000c3f8b82c2b970438f5f1f39d56bb8a9d66341efc92a02ffcbff91acd84b Success! 现在，Helen 这个钱包地址上有了两笔从 wangwei 和 Pedro 转账中产生的UTXO，让我们将它们再转账给另外一个人： $ java -jar blockchain-java-jar-with-dependencies.jar send -from Helen -to Rachel -amount 3 Elapsed Time: 17.136 seconds correct hash Hex: 000000b1226a947166c2b01a15d1cd3558ddf86fe99bad28a0501a2af60f6a02 Success! $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei Balance of &#39;wangwei&#39;: 2 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Pedro Balance of &#39;Pedro&#39;: 4 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Helen Balance of &#39;Helen&#39;: 1 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Rachel Balance of &#39;Rachel&#39;: 3 非常棒！让我们来测试一下失败的场景： $ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Ivan -amount 5 java.lang.Exception: ERROR: Not enough funds at one.wangwei.blockchain.transaction.Transaction.newUTXOTransaction(Transaction.java:104) at one.wangwei.blockchain.cli.CLI.send(CLI.java:138) at one.wangwei.blockchain.cli.CLI.parse(CLI.java:73) at one.wangwei.blockchain.cli.Main.main(Main.java:7) 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ 总结 本篇内容有点难度，但好歹我们现在有了交易信息了。尽管，缺少像比特币这一类加密货币的一些关键特性： 钱包地址。我们还没有基于私钥的真实地址。 奖励。挖矿绝对没有利润。 UTXO集。当我们计算钱包地址的余额时，我们需要遍历所有的区块中的所有交易信息，当有许许多多的区块时，这将花费不少的时间。此外，如果我们想验证以后的交易，可能需要很长时间。 UTXO集旨在解决这些问题并快速处理交易。 内存池。 这是交易在打包成区块之前存储的地方。 在我们当前的实现中，一个块只包含一笔交易，而且效率很低。 文章出处： https://wangwei.one/ &nbsp;转载 ！ 阅读更多" />
<meta property="og:description" content="引言 上一篇&nbsp;文章，我们实现了区块数据的持久化，本篇开始交易环节的实现。交易这一环节是整个比特币系统当中最为关键的一环，并且区块链唯一的目的就是通过安全的、可信的方式来存储交易信息，防止它们创建之后被人恶意篡改。今天我们开始实现交易这一环节，但由于这是一个很大的话题，所以我们分为两部分：第一部分我们将实现区块链交易的基本机制，到第二部分，我们再来研究它的细节。 &lt;!--more--&gt; 比特币交易 如果你开发过Web应用程序，为了实现支付系统，你可能会在数据库中创建一些数据库表：账户&nbsp;和&nbsp;交易记录。账户用于存储用户的个人信息以及账户余额等信息，交易记录用于存储资金从一个账户转移到另一个账户的记录。但是在比特币中，支付系统是以一种完全不一样的方式实现的，在这里： 没有账户 没有余额 没有地址 没有 Coins（币） 没有发送者和接受者 由于区块链是一个公开的数据库，我们不希望存储有关钱包所有者的敏感信息。Coins&nbsp;不会汇总到钱包中。交易不会将资金从一个地址转移到另一个地址。没有可保存帐户余额的字段或属性。只有交易信息。那比特币的交易信息里面到底存储的是什么呢？ 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ 交易组成 一笔比特币的交易由&nbsp;交易输入&nbsp;和&nbsp;交易输出&nbsp;组成，数据结构如下： /** * 交易 * * @author wangwei * @date 2017/03/04 */ @Data @AllArgsConstructor @NoArgsConstructor public class Transaction { /** * 交易的Hash */ private byte[] txId; /** * 交易输入 */ private TXInput[] inputs; /** * 交易输出 */ private TXOutput[] outputs; } 一笔交易的&nbsp;交易输入&nbsp;其实是指向上一笔交易的交易输出&nbsp;（这个后面详细说明）。我们钱包里面的 Coin（币）实际是存储在这些&nbsp;交易输出&nbsp;里面。下图表示了区块链交易系统里面各个交易相互引用的关系： 注意： 有些&nbsp;交易输出&nbsp;并不是由&nbsp;交易输入&nbsp;产生，而是凭空产生的（后面会详细介绍）。 但，交易输入&nbsp;必须指向某个&nbsp;交易输出，它不能凭空产生。 在一笔交易里面，交易输入&nbsp;可能会来自多笔交易所产生的&nbsp;交易输出。 在整篇文章中，我们将使用诸如“钱”，“硬币”，“花费”，“发送”，“账户”等词语。但比特币中没有这样的概念，在比特币交易中，交易信息是由&nbsp;锁定脚本&nbsp;锁定一个数值，并且只能被所有者的&nbsp;解锁脚本&nbsp;解锁。（解铃还须系铃人） 交易输出 让我们先从交易输出开始，他的数据结构如下： /** * 交易输出 * * @author wangwei * @date 2017/03/04 */ @Data @AllArgsConstructor @NoArgsConstructor public class TXOutput { /** * 数值 */ private int value; /** * 锁定脚本 */ private String scriptPubKey; } 实际上，它表示的是能够存储 &quot;coins（币）&quot;的交易输出（注意&nbsp;value&nbsp;字段）。并且这里所谓的&nbsp;value&nbsp;实际上是由存储在ScriptPubKey&nbsp;（锁定脚本）中的一个puzzle（难题） 所锁定。在内部，比特币使用称为脚本的脚本语言，用于定义输出锁定和解锁逻辑。这个语言很原始（这是故意的，以避免可能的黑客和滥用），但我们不会详细讨论它。 你可以在这里找到它的详细解释。here 在比特币中，value&nbsp;字段存储着&nbsp;satoshis&nbsp;的任意倍的数值，而不是BTC的数量。satoshis&nbsp;是比特币的百万分之一（0.00000001 BTC），因此这是比特币中最小的货币单位（如1美分）。 satoshis：聪 锁定脚本是一个放在一个输出值上的“障碍”，同时它明确了今后花费这笔输出的条件。由于锁定脚本往往含有一个公钥（即比特币地址），在历史上它曾被称作一个脚本公钥代码。在大多数比特币应用源代码中，脚本公钥代码便是我们所说的锁定脚本。 由于我们还没有实现钱包地址的逻辑，所以这里先暂且忽略锁定脚本相关的逻辑。ScriptPubKey&nbsp;将会存储任意的字符串（用户定义的钱包地址） 顺便说一句，拥有这样的脚本语言意味着比特币也可以用作智能合约平台。 关于&nbsp;交易输出&nbsp;的一个重要的事情是它们是不可分割的，这意味着你不能将它所存储的数值拆开来使用。当这个交易输出在新的交易中被交易输入所引用时，它将作为一个整体被花费掉。 如果其值大于所需值，那么剩余的部分则会作为零钱返回给付款方。 这与真实世界的情况类似，例如，您支付5美元的钞票用于购买1美元的东西，那么你将会得到4美元的零钱。 交易输入 /** * 交易输入 * * @author wangwei * @date 2017/03/04 */ @Data @AllArgsConstructor @NoArgsConstructor public class TXInput { /** * 交易Id的hash值 */ private byte[] txId; /** * 交易输出索引 */ private int txOutputIndex; /** * 解锁脚本 */ private String scriptSig; } 前面提到过，一个交易输入指向的是某一笔交易的交易输出： txId&nbsp;存储的是某笔交易的ID值 txOutputIndex&nbsp;存储的是交易中这个交易输出的索引位置（因为一笔交易可能包含多个交易输出） scriptSig&nbsp;主要是提供用于交易输出中&nbsp;ScriptPubKey&nbsp;所需的验证数据。 如果这个数据被验证正确，那么相应的交易输出将被解锁，并且其中的 value 能够生成新的交易输出； 如果不正确，那么相应的交易输出将不能被交易输入所引用； 通过锁定脚本与解锁脚本这种机制，保证了某个用户不能花费属于他人的Coins。 同样，由于我们尚未实现钱包地址功能，ScriptSig&nbsp;将会存储任意的用户所定义的钱包地址。我们将会在下一章节实现公钥和数字签名验证。 说了这么多，我们来总结一下。交易输出是&quot;Coins&quot;实际存储的地方。每一个交易输出都带有一个锁定脚本，它决定了解锁的逻辑。每一笔新的交易必须至少有一个交易输入与交易输出。一笔交易的交易输入指向前一笔交易的交易输出，并且提供用于锁定脚本解锁需要的数据（ScriptSig&nbsp;字段），然后利用交易输出中的&nbsp;value&nbsp;去创建新的交易输出。 注意，这段话的原文如下，但是里面有表述错误的地方，交易输出带有的是锁定脚本，而不是解锁脚本。 Let’s sum it up. Outputs are where “coins” are stored. Each output comes with an unlocking script, which determines the logic of unlocking the output. Every new transaction must have at least one input and output. An input references an output from a previous transaction and provides data (the&nbsp;ScriptSig&nbsp;field) that is used in the output’s unlocking script to unlock it and use its value to create new outputs. 那到底是先有交易输入还是先有交易输出呢？ 鸡与蛋的问题 在比特币中，鸡蛋先于鸡出现。交易输入源自于交易输出的逻辑是典型的&quot;先有鸡还是先有蛋&quot;的问题：交易输入产生交易输出，交易输出又会被交易输入所引用。在比特币中，交易输出先于交易输入出现。 当矿工开始开采区块时，区块中会被添加一个&nbsp;coinbase&nbsp;交易。coinbase 交易是一种特殊的交易，它不需要以前已经存在的交易输出。它会凭空创建出交易输出（i.e: Coins）。也即，鸡蛋的出现并不需要母鸡，这笔交易是作为矿工成功挖出新的区块后的一笔奖励。 正如你所知道的那样，在区块链的最前端，即第一个区块，有一个创世区块。他产生了区块链中有史以来的第一个交易输出，并且由于没有前一笔交易，也就没有相应的输出，因此不需要前一笔交易的交易输出。 让我们来创建 coinbase 交易： /** * 创建CoinBase交易 * * @param to 收账的钱包地址 * @param data 解锁脚本数据 * @return */ public Transaction newCoinbaseTX(String to, String data) { if (StringUtils.isBlank(data)) { data = String.format(&quot;Reward to &#39;%s&#39;&quot;, to); } // 创建交易输入 TXInput txInput = new TXInput(new byte[]{}, -1, data); // 创建交易输出 TXOutput txOutput = new TXOutput(SUBSIDY, to); // 创建交易 Transaction tx = new Transaction(null, new TXInput[]{txInput}, new TXOutput[]{txOutput}); // 设置交易ID tx.setTxId(); return tx; } coinbase交易只有一个交易输入。在我们的代码实现中，txId&nbsp;是空数组，txOutputIndex&nbsp;设置为了 -1。另外，coinbase交易不会在&nbsp;ScriptSig&nbsp;字段上存储解锁脚本，相反，存了一个任意的数据。 在比特币中，第一个 coinbase 交易报刊了如下的信息：&quot;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks&quot;.&nbsp; 点击查看 SUBSIDY&nbsp;是挖矿奖励数量。在比特币中，这个奖励数量没有存储在任何地方，而是依据现有区块的总数进行计算而得到：区块总数 除以 210000。开采创世区块得到的奖励为50BTC，每过 210000 个区块，奖励会减半。在我们的实现中，我们暂且将挖矿奖励设置为常数。（至少目前是这样） 在区块链中存储交易信息 从现在开始，每一个区块必须存储至少一个交易信息，并且尽可能地避免在没有交易数据的情况下进行挖矿。这意味着我们必须移除&nbsp;Block&nbsp;对象中的&nbsp;date&nbsp;字段，取而代之的是&nbsp;transactions： /** * 区块 * * @author wangwei * @date 2018/02/02 */ @Data @AllArgsConstructor @NoArgsConstructor public class Block { /** * 区块hash值 */ private String hash; /** * 前一个区块的hash值 */ private String previousHash; /** * 交易信息 */ private Transaction[] transactions; /** * 区块创建时间(单位:秒) */ private long timeStamp; } 相应地，newGenesisBlock&nbsp;与&nbsp;newBlock&nbsp;也都需要做改变： /** * &lt;p&gt; 创建创世区块 &lt;/p&gt; * * @param coinbase * @return */ public static Block newGenesisBlock(Transaction coinbase) { return Block.newBlock(&quot;&quot;, new Transaction[]{coinbase}); } /** * &lt;p&gt; 创建新区块 &lt;/p&gt; * * @param previousHash * @param transactions * @return */ public static Block newBlock(String previousHash, Transaction[] transactions) { Block block = new Block(&quot;&quot;, previousHash, transactions, Instant.now().getEpochSecond(), 0); ProofOfWork pow = ProofOfWork.newProofOfWork(block); PowResult powResult = pow.run(); block.setHash(powResult.getHash()); block.setNonce(powResult.getNonce()); return block; } 接下来，修改&nbsp;newBlockchain&nbsp;方法： /** * &lt;p&gt; 创建区块链 &lt;/p&gt; * * @param address 钱包地址 * @return */ public static Blockchain newBlockchain(String address) throws Exception { String lastBlockHash = RocksDBUtils.getInstance().getLastBlockHash(); if (StringUtils.isBlank(lastBlockHash)) { // 创建 coinBase 交易 Transaction coinbaseTX = Transaction.newCoinbaseTX(address, &quot;&quot;); Block genesisBlock = Block.newGenesisBlock(coinbaseTX); lastBlockHash = genesisBlock.getHash(); RocksDBUtils.getInstance().putBlock(genesisBlock); RocksDBUtils.getInstance().putLastBlockHash(lastBlockHash); } return new Blockchain(lastBlockHash); } 现在，代码有钱包地址的接口，将会收到开采创世区块的奖励。 工作量证明（Pow） Pow算法必须将存储在区块中的交易信息考虑在内，以保存交易信息存储的一致性和可靠性。因此，我们必须修改&nbsp;ProofOfWork.prepareData&nbsp;接口代码逻辑： /** * 准备数据 * &lt;p&gt; * 注意：在准备区块数据时，一定要从原始数据类型转化为byte[]，不能直接从字符串进行转换 * @param nonce * @return */ private String prepareData(long nonce) { byte[] prevBlockHashBytes = {}; if (StringUtils.isNoneBlank(this.getBlock().getPrevBlockHash())) { prevBlockHashBytes = new BigInteger(this.getBlock().getPrevBlockHash(), 16).toByteArray(); } return ByteUtils.merge( prevBlockHashBytes, this.getBlock().hashTransaction(), ByteUtils.toBytes(this.getBlock().getTimeStamp()), ByteUtils.toBytes(TARGET_BITS), ByteUtils.toBytes(nonce) ); } 其中&nbsp;hashTransaction&nbsp;代码如下： /** * 对区块中的交易信息进行Hash计算 * * @return */ public byte[] hashTransaction() { byte[][] txIdArrays = new byte[this.getTransactions().length][]; for (int i = 0; i &lt; this.getTransactions().length; i++) { txIdArrays[i] = this.getTransactions()[i].getTxId(); } return DigestUtils.sha256(ByteUtils.merge(txIds)); } 同样，我们使用哈希值来作为数据的唯一标识。我们希望区块中的所有交易数据都能通过一个哈希值来定义它的唯一标识。为了达到这个目的，我们计算了每一个交易的唯一哈希值，然后将他们串联起来，再对这个串联后的组合进行哈希值计算。 比特币使用更复杂的技术：它将所有包含在块中的交易表示为&nbsp; Merkle树&nbsp;，并在Proof-of-Work系统中使用该树的根散列。 这种方法只需要跟节点的散列值就可以快速检查块是否包含某笔交易，而无需下载所有交易。 UTXO（未花费交易输出） UTXO：unspend transaction output.（未被花费的交易输出） 在比特币的世界里既没有账户，也没有余额，只有分散到区块链里的UTXO. UTXO&nbsp;是理解比特币交易原理的关键所在，我们先来看一段场景： 场景：假设你过去分别向A、B、C这三个比特币用户购买了BTC，从A手中购买了3.5个BTC，从B手中购买了4.5个BTC，从C手中购买了2个BTC，现在你的比特币钱包里面恰好剩余10个BTC。 问题：这个10个BTC是真正的10个BTC吗？其实不是，这句话可能听起来有点怪。（什么！我钱包里面的BTC不是真正的BTC，你不要吓我……） 解释：前面提到过在比特币的交易系统当中，并不存在账户、余额这些概念，所以，你的钱包里面的10个BTC，并不是说钱包余额为10个BTC。而是说，这10个BTC其实是由你的比特币地址（钱包地址|公钥）锁定了的散落在各个区块和各个交易里面的UTXO的总和。 UTXO 是比特币交易的基本单位，每笔交易都会产生UTXO，一个UTXO可以是一“聪”的任意倍。给某人发送比特币实际上是创造新的UTXO，绑定到那个人的钱包地址，并且能被他用于新的支付。 一般的比特币交易由&nbsp;交易输入&nbsp;和&nbsp;交易输出&nbsp;两部分组成。A向你支付3.5个BTC这笔交易，实际上产生了一个新的UTXO，这个新的UTXO 等于 3.5个BTC（3.5亿聪），并且锁定到了你的比特币钱包地址上。 假如你要给你女（男）朋友转 1.5 BTC，那么你的钱包会从可用的UTXO中选取一个或多个可用的个体来拼凑出一个大于或等于一笔交易所需的比特币量。比如在这个假设场景里面，你的钱包会选取你和C的交易中的UTXO作为 交易输入，input = 2BTC，这里会生成两个新的交易输出，一个输出（UTXO = 1.5 BTC）会被绑定到你女（男）朋友的钱包地址上，另一个输出（UTXO = 0.5 BTC）会作为找零，重新绑定到你的钱包地址上。 有关比特币交易这部分更详细的内容，请查看： 《精通比特币（第二版）》第6章 —— 交易 我们需要找到所有未花费的交易输出（UTXO）。Unspent(未花费)&nbsp;意味着这些交易输出从未被交易输入所指向。这前面的图片中，UTXO如下： tx0, output 1; tx1, output 0; tx3, output 0; tx4, output 0. 当然，当我们检查余额时，我不需要区块链中所有的UTXO，我只需要能被我们解锁的UTXO（当前，我们还没有实现密钥对，而是替代为用户自定义的钱包地址）。首先，我们在交易输入与交易输出上定义锁定-解锁的方法： 交易输入： public class TXInput { ... /** * 判断解锁数据是否能够解锁交易输出 * * @param unlockingData * @return */ public boolean canUnlockOutputWith(String unlockingData) { return this.getScriptSig().endsWith(unlockingData); } } 交易输出： public class TXOutput { ... /** * 判断解锁数据是否能够解锁交易输出 * * @param unlockingData * @return */ public boolean canBeUnlockedWith(String unlockingData) { return this.getScriptPubKey().endsWith(unlockingData); } } 这里我们暂时用&nbsp;unlockingData&nbsp;来与脚本字段进行比较。我们会在后面的文章中来对这部分内容进行优化，我们将会基于私钥来实现用户的钱包地址。 下一步，查询所有与钱包地址绑定的包含UTXO的交易信息，有点复杂（本篇先这样实现，后面我们做一个与钱包地址映射的UTXO池来进行优化）： 从与钱包地址对应的交易输入中查询出所有已被花费了的交易输出 再来排除，寻找包含未被花费的交易输出的交易 public class Blockchain { ... /** * 查找钱包地址对应的所有未花费的交易 * * @param address 钱包地址 * @return */ private Transaction[] findUnspentTransactions(String address) throws Exception { Map&lt;String, int[]&gt; allSpentTXOs = this.getAllSpentTXOs(address); Transaction[] unspentTxs = {}; // 再次遍历所有区块中的交易输出 for (BlockchainIterator blockchainIterator = this.getBlockchainIterator(); blockchainIterator.hashNext(); ) { Block block = blockchainIterator.next(); for (Transaction transaction : block.getTransactions()) { String txId = Hex.encodeHexString(transaction.getTxId()); int[] spentOutIndexArray = allSpentTXOs.get(txId); for (int outIndex = 0; outIndex &lt; transaction.getOutputs().length; outIndex++) { if (spentOutIndexArray != null &amp;&amp; ArrayUtils.contains(spentOutIndexArray, outIndex)) { continue; } // 保存不存在 allSpentTXOs 中的交易 if (transaction.getOutputs()[outIndex].canBeUnlockedWith(address)) { unspentTxs = ArrayUtils.add(unspentTxs, transaction); } } } } return unspentTxs; } /** * 从交易输入中查询区块链中所有已被花费了的交易输出 * * @param address 钱包地址 * @return 交易ID以及对应的交易输出下标地址 * @throws Exception */ private Map&lt;String, int[]&gt; getAllSpentTXOs(String address) throws Exception { // 定义TxId ——&gt; spentOutIndex[]，存储交易ID与已被花费的交易输出数组索引值 Map&lt;String, int[]&gt; spentTXOs = new HashMap&lt;&gt;(); for (BlockchainIterator blockchainIterator = this.getBlockchainIterator(); blockchainIterator.hashNext(); ) { Block block = blockchainIterator.next(); for (Transaction transaction : block.getTransactions()) { // 如果是 coinbase 交易，直接跳过，因为它不存在引用前一个区块的交易输出 if (transaction.isCoinbase()) { continue; } for (TXInput txInput : transaction.getInputs()) { if (txInput.canUnlockOutputWith(address)) { String inTxId = Hex.encodeHexString(txInput.getTxId()); int[] spentOutIndexArray = spentTXOs.get(inTxId); if (spentOutIndexArray == null) { spentTXOs.put(inTxId, new int[]{txInput.getTxOutputIndex()}); } else { spentOutIndexArray = ArrayUtils.add(spentOutIndexArray, txInput.getTxOutputIndex()); spentTXOs.put(inTxId, spentOutIndexArray); } } } } } return spentTXOs; } ... } 得到了所有包含UTXO的交易数据，接下来，我们就可以得到所有UTXO集合了： public class Blockchain { ... /** * 查找钱包地址对应的所有UTXO * * @param address 钱包地址 * @return */ public TXOutput[] findUTXO(String address) throws Exception { Transaction[] unspentTxs = this.findUnspentTransactions(address); TXOutput[] utxos = {}; if (unspentTxs == null || unspentTxs.length == 0) { return utxos; } for (Transaction tx : unspentTxs) { for (TXOutput txOutput : tx.getOutputs()) { if (txOutput.canBeUnlockedWith(address)) { utxos = ArrayUtils.add(utxos, txOutput); } } } return utxos; } ... } 现在，我们可以实现获取钱包地址余额的接口了： public class CLI { ... /** * 查询钱包余额 * * @param address 钱包地址 */ private void getBalance(String address) throws Exception { Blockchain blockchain = Blockchain.createBlockchain(address); TXOutput[] txOutputs = blockchain.findUTXO(address); int balance = 0; if (txOutputs != null &amp;&amp; txOutputs.length &gt; 0) { for (TXOutput txOutput : txOutputs) { balance += txOutput.getValue(); } } System.out.printf(&quot;Balance of &#39;%s&#39;: %d\n&quot;, address, balance); } ... } 查询&nbsp;wangwei&nbsp;这个钱包地址的余额： $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei # 输出 Balance of &#39;wangwei&#39;: 10 转账 现在，我们想要给某人发送一些币。因此，我们需要创建一笔新的交易，然后放入区块中，再进行挖矿。到目前为止，我们只是实现了&nbsp;coinbase&nbsp;交易，现在我们需要实现常见的创建交易接口： public class Transaction { ... /** * 从 from 向 to 支付一定的 amount 的金额 * * @param from 支付钱包地址 * @param to 收款钱包地址 * @param amount 交易金额 * @param blockchain 区块链 * @return */ public static Transaction newUTXOTransaction(String from, String to, int amount, Blockchain blockchain) throws Exception { SpendableOutputResult result = blockchain.findSpendableOutputs(from, amount); int accumulated = result.getAccumulated(); Map&lt;String, int[]&gt; unspentOuts = result.getUnspentOuts(); if (accumulated &lt; amount) { throw new Exception(&quot;ERROR: Not enough funds&quot;); } Iterator&lt;Map.Entry&lt;String, int[]&gt;&gt; iterator = unspentOuts.entrySet().iterator(); TXInput[] txInputs = {}; while (iterator.hasNext()) { Map.Entry&lt;String, int[]&gt; entry = iterator.next(); String txIdStr = entry.getKey(); int[] outIdxs = entry.getValue(); byte[] txId = Hex.decodeHex(txIdStr); for (int outIndex : outIdxs) { txInputs = ArrayUtils.add(txInputs, new TXInput(txId, outIndex, from)); } } TXOutput[] txOutput = {}; txOutput = ArrayUtils.add(txOutput, new TXOutput(amount, to)); if (accumulated &gt; amount) { txOutput = ArrayUtils.add(txOutput, new TXOutput((accumulated - amount), from)); } Transaction newTx = new Transaction(null, txInputs, txOutput); newTx.setTxId(); return newTx; } ... } 在创建新的交易输出之前，我们需要事先找到所有的UTXO，并确保有足够的金额。这就是&nbsp;findSpendableOutputs&nbsp;要干的事情。之后，为每个找到的输出创建一个引用它的输入。接下来，我们创建两个交易输出： 一个&nbsp;output&nbsp;用于锁定到接收者的钱包地址上。这个是真正被转走的coins； 另一个&nbsp;output&nbsp;锁定到发送者的钱包地址上。这个就是 找零。只有当用于支付的UTXO总和大于要支付的金额时，才会创建这部分的 交易输出。记住：交易输出是不可分割的 findSpendableOutputs&nbsp;需要调用我们之前创建的&nbsp;findUnspentTransactions&nbsp;接口： public class Blockchain { ... /** * 寻找能够花费的交易 * * @param address 钱包地址 * @param amount 花费金额 */ public SpendableOutputResult findSpendableOutputs(String address, int amount) throws Exception { Transaction[] unspentTXs = this.findUnspentTransactions(address); int accumulated = 0; Map&lt;String, int[]&gt; unspentOuts = new HashMap&lt;&gt;(); for (Transaction tx : unspentTXs) { String txId = Hex.encodeHexString(tx.getTxId()); for (int outId = 0; outId &lt; tx.getOutputs().length; outId++) { TXOutput txOutput = tx.getOutputs()[outId]; if (txOutput.canBeUnlockedWith(address) &amp;&amp; accumulated &lt; amount) { accumulated += txOutput.getValue(); int[] outIds = unspentOuts.get(txId); if (outIds == null) { outIds = new int[]{outId}; } else { outIds = ArrayUtils.add(outIds, outId); } unspentOuts.put(txId, outIds); if (accumulated &gt;= amount) { break; } } } } return new SpendableOutputResult(accumulated, unspentOuts); } ... } 这个方法会遍历所有的UTXO并统计他们的总额。当计算的总额恰好大于或者等于需要转账的金额时，方法会停止遍历，然后返回用于支付的总额以及按交易ID分组的交易输出索引值数组。我们不想要花更多的钱。 现在，我们可以修改&nbsp;Block.mineBlock&nbsp;接口： public class Block { ... /** * 打包交易，进行挖矿 * * @param transactions */ public void mineBlock(Transaction[] transactions) throws Exception { String lastBlockHash = RocksDBUtils.getInstance().getLastBlockHash(); if (lastBlockHash == null) { throw new Exception(&quot;ERROR: Fail to get last block hash ! &quot;); } Block block = Block.newBlock(lastBlockHash, transactions); this.addBlock(block); } ... } 最后，我们来实现转账的接口： public class CLI { ... /** * 转账 * * @param from * @param to * @param amount */ private void send(String from, String to, int amount) throws Exception { Blockchain blockchain = Blockchain.createBlockchain(from); Transaction transaction = Transaction.newUTXOTransaction(from, to, amount, blockchain); blockchain.mineBlock(new Transaction[]{transaction}); RocksDBUtils.getInstance().closeDB(); System.out.println(&quot;Success!&quot;); } ... } 转账，意味着创建一笔新的交易并且通过挖矿的方式将其存入区块中。但是，比特币不会像我们这样做，它会把新的交易记录先存到内存池中，当一个矿工准备去开采一个区块时，它会把打包内存池中的所有交易信息，并且创建一个候选区块。只有当这个包含所有交易信息的候选区块被成功开采并且被添加到区块链上时，这些交易信息才算被确认。 让我们来测试一下： # 先确认 wangwei 的余额 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei Balance of &#39;wangwei&#39;: 10 # 转账 $ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Pedro -amount 6 Elapsed Time: 0.828 seconds correct hash Hex: 00000c5f50cf72db1f375a5d454f98bc49d07335db921cbef5fa9e58ad34d462 Success! # 查询 wangwei 的余额 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei Balance of &#39;wangwei&#39;: 4 # 查询 Pedro 的余额 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Pedro Balance of &#39;Pedro&#39;: 6 赞！现在让我们来创建更多的交易并且确保从多个交易输出进行转账是正常的： $ java -jar blockchain-java-jar-with-dependencies.jar send -from Pedro -to Helen -amount 2 Elapsed Time: 2.533 seconds correct hash Hex: 00000c81d541ad407a3767ad633d1147602df86fe14e1962ec145ab17b633e88 Success! $ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Helen -amount 2 Elapsed Time: 1.481 seconds correct hash Hex: 00000c3f8b82c2b970438f5f1f39d56bb8a9d66341efc92a02ffcbff91acd84b Success! 现在，Helen 这个钱包地址上有了两笔从 wangwei 和 Pedro 转账中产生的UTXO，让我们将它们再转账给另外一个人： $ java -jar blockchain-java-jar-with-dependencies.jar send -from Helen -to Rachel -amount 3 Elapsed Time: 17.136 seconds correct hash Hex: 000000b1226a947166c2b01a15d1cd3558ddf86fe99bad28a0501a2af60f6a02 Success! $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei Balance of &#39;wangwei&#39;: 2 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Pedro Balance of &#39;Pedro&#39;: 4 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Helen Balance of &#39;Helen&#39;: 1 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Rachel Balance of &#39;Rachel&#39;: 3 非常棒！让我们来测试一下失败的场景： $ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Ivan -amount 5 java.lang.Exception: ERROR: Not enough funds at one.wangwei.blockchain.transaction.Transaction.newUTXOTransaction(Transaction.java:104) at one.wangwei.blockchain.cli.CLI.send(CLI.java:138) at one.wangwei.blockchain.cli.CLI.parse(CLI.java:73) at one.wangwei.blockchain.cli.Main.main(Main.java:7) 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ 总结 本篇内容有点难度，但好歹我们现在有了交易信息了。尽管，缺少像比特币这一类加密货币的一些关键特性： 钱包地址。我们还没有基于私钥的真实地址。 奖励。挖矿绝对没有利润。 UTXO集。当我们计算钱包地址的余额时，我们需要遍历所有的区块中的所有交易信息，当有许许多多的区块时，这将花费不少的时间。此外，如果我们想验证以后的交易，可能需要很长时间。 UTXO集旨在解决这些问题并快速处理交易。 内存池。 这是交易在打包成区块之前存储的地方。 在我们当前的实现中，一个块只包含一笔交易，而且效率很低。 文章出处： https://wangwei.one/ &nbsp;转载 ！ 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/27/75b10041984621b48d48ec099b7b340e.html" />
<meta property="og:url" content="https://mlh.app/2018/03/27/75b10041984621b48d48ec099b7b340e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-27T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"引言 上一篇&nbsp;文章，我们实现了区块数据的持久化，本篇开始交易环节的实现。交易这一环节是整个比特币系统当中最为关键的一环，并且区块链唯一的目的就是通过安全的、可信的方式来存储交易信息，防止它们创建之后被人恶意篡改。今天我们开始实现交易这一环节，但由于这是一个很大的话题，所以我们分为两部分：第一部分我们将实现区块链交易的基本机制，到第二部分，我们再来研究它的细节。 &lt;!--more--&gt; 比特币交易 如果你开发过Web应用程序，为了实现支付系统，你可能会在数据库中创建一些数据库表：账户&nbsp;和&nbsp;交易记录。账户用于存储用户的个人信息以及账户余额等信息，交易记录用于存储资金从一个账户转移到另一个账户的记录。但是在比特币中，支付系统是以一种完全不一样的方式实现的，在这里： 没有账户 没有余额 没有地址 没有 Coins（币） 没有发送者和接受者 由于区块链是一个公开的数据库，我们不希望存储有关钱包所有者的敏感信息。Coins&nbsp;不会汇总到钱包中。交易不会将资金从一个地址转移到另一个地址。没有可保存帐户余额的字段或属性。只有交易信息。那比特币的交易信息里面到底存储的是什么呢？ 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ 交易组成 一笔比特币的交易由&nbsp;交易输入&nbsp;和&nbsp;交易输出&nbsp;组成，数据结构如下： /** * 交易 * * @author wangwei * @date 2017/03/04 */ @Data @AllArgsConstructor @NoArgsConstructor public class Transaction { /** * 交易的Hash */ private byte[] txId; /** * 交易输入 */ private TXInput[] inputs; /** * 交易输出 */ private TXOutput[] outputs; } 一笔交易的&nbsp;交易输入&nbsp;其实是指向上一笔交易的交易输出&nbsp;（这个后面详细说明）。我们钱包里面的 Coin（币）实际是存储在这些&nbsp;交易输出&nbsp;里面。下图表示了区块链交易系统里面各个交易相互引用的关系： 注意： 有些&nbsp;交易输出&nbsp;并不是由&nbsp;交易输入&nbsp;产生，而是凭空产生的（后面会详细介绍）。 但，交易输入&nbsp;必须指向某个&nbsp;交易输出，它不能凭空产生。 在一笔交易里面，交易输入&nbsp;可能会来自多笔交易所产生的&nbsp;交易输出。 在整篇文章中，我们将使用诸如“钱”，“硬币”，“花费”，“发送”，“账户”等词语。但比特币中没有这样的概念，在比特币交易中，交易信息是由&nbsp;锁定脚本&nbsp;锁定一个数值，并且只能被所有者的&nbsp;解锁脚本&nbsp;解锁。（解铃还须系铃人） 交易输出 让我们先从交易输出开始，他的数据结构如下： /** * 交易输出 * * @author wangwei * @date 2017/03/04 */ @Data @AllArgsConstructor @NoArgsConstructor public class TXOutput { /** * 数值 */ private int value; /** * 锁定脚本 */ private String scriptPubKey; } 实际上，它表示的是能够存储 &quot;coins（币）&quot;的交易输出（注意&nbsp;value&nbsp;字段）。并且这里所谓的&nbsp;value&nbsp;实际上是由存储在ScriptPubKey&nbsp;（锁定脚本）中的一个puzzle（难题） 所锁定。在内部，比特币使用称为脚本的脚本语言，用于定义输出锁定和解锁逻辑。这个语言很原始（这是故意的，以避免可能的黑客和滥用），但我们不会详细讨论它。 你可以在这里找到它的详细解释。here 在比特币中，value&nbsp;字段存储着&nbsp;satoshis&nbsp;的任意倍的数值，而不是BTC的数量。satoshis&nbsp;是比特币的百万分之一（0.00000001 BTC），因此这是比特币中最小的货币单位（如1美分）。 satoshis：聪 锁定脚本是一个放在一个输出值上的“障碍”，同时它明确了今后花费这笔输出的条件。由于锁定脚本往往含有一个公钥（即比特币地址），在历史上它曾被称作一个脚本公钥代码。在大多数比特币应用源代码中，脚本公钥代码便是我们所说的锁定脚本。 由于我们还没有实现钱包地址的逻辑，所以这里先暂且忽略锁定脚本相关的逻辑。ScriptPubKey&nbsp;将会存储任意的字符串（用户定义的钱包地址） 顺便说一句，拥有这样的脚本语言意味着比特币也可以用作智能合约平台。 关于&nbsp;交易输出&nbsp;的一个重要的事情是它们是不可分割的，这意味着你不能将它所存储的数值拆开来使用。当这个交易输出在新的交易中被交易输入所引用时，它将作为一个整体被花费掉。 如果其值大于所需值，那么剩余的部分则会作为零钱返回给付款方。 这与真实世界的情况类似，例如，您支付5美元的钞票用于购买1美元的东西，那么你将会得到4美元的零钱。 交易输入 /** * 交易输入 * * @author wangwei * @date 2017/03/04 */ @Data @AllArgsConstructor @NoArgsConstructor public class TXInput { /** * 交易Id的hash值 */ private byte[] txId; /** * 交易输出索引 */ private int txOutputIndex; /** * 解锁脚本 */ private String scriptSig; } 前面提到过，一个交易输入指向的是某一笔交易的交易输出： txId&nbsp;存储的是某笔交易的ID值 txOutputIndex&nbsp;存储的是交易中这个交易输出的索引位置（因为一笔交易可能包含多个交易输出） scriptSig&nbsp;主要是提供用于交易输出中&nbsp;ScriptPubKey&nbsp;所需的验证数据。 如果这个数据被验证正确，那么相应的交易输出将被解锁，并且其中的 value 能够生成新的交易输出； 如果不正确，那么相应的交易输出将不能被交易输入所引用； 通过锁定脚本与解锁脚本这种机制，保证了某个用户不能花费属于他人的Coins。 同样，由于我们尚未实现钱包地址功能，ScriptSig&nbsp;将会存储任意的用户所定义的钱包地址。我们将会在下一章节实现公钥和数字签名验证。 说了这么多，我们来总结一下。交易输出是&quot;Coins&quot;实际存储的地方。每一个交易输出都带有一个锁定脚本，它决定了解锁的逻辑。每一笔新的交易必须至少有一个交易输入与交易输出。一笔交易的交易输入指向前一笔交易的交易输出，并且提供用于锁定脚本解锁需要的数据（ScriptSig&nbsp;字段），然后利用交易输出中的&nbsp;value&nbsp;去创建新的交易输出。 注意，这段话的原文如下，但是里面有表述错误的地方，交易输出带有的是锁定脚本，而不是解锁脚本。 Let’s sum it up. Outputs are where “coins” are stored. Each output comes with an unlocking script, which determines the logic of unlocking the output. Every new transaction must have at least one input and output. An input references an output from a previous transaction and provides data (the&nbsp;ScriptSig&nbsp;field) that is used in the output’s unlocking script to unlock it and use its value to create new outputs. 那到底是先有交易输入还是先有交易输出呢？ 鸡与蛋的问题 在比特币中，鸡蛋先于鸡出现。交易输入源自于交易输出的逻辑是典型的&quot;先有鸡还是先有蛋&quot;的问题：交易输入产生交易输出，交易输出又会被交易输入所引用。在比特币中，交易输出先于交易输入出现。 当矿工开始开采区块时，区块中会被添加一个&nbsp;coinbase&nbsp;交易。coinbase 交易是一种特殊的交易，它不需要以前已经存在的交易输出。它会凭空创建出交易输出（i.e: Coins）。也即，鸡蛋的出现并不需要母鸡，这笔交易是作为矿工成功挖出新的区块后的一笔奖励。 正如你所知道的那样，在区块链的最前端，即第一个区块，有一个创世区块。他产生了区块链中有史以来的第一个交易输出，并且由于没有前一笔交易，也就没有相应的输出，因此不需要前一笔交易的交易输出。 让我们来创建 coinbase 交易： /** * 创建CoinBase交易 * * @param to 收账的钱包地址 * @param data 解锁脚本数据 * @return */ public Transaction newCoinbaseTX(String to, String data) { if (StringUtils.isBlank(data)) { data = String.format(&quot;Reward to &#39;%s&#39;&quot;, to); } // 创建交易输入 TXInput txInput = new TXInput(new byte[]{}, -1, data); // 创建交易输出 TXOutput txOutput = new TXOutput(SUBSIDY, to); // 创建交易 Transaction tx = new Transaction(null, new TXInput[]{txInput}, new TXOutput[]{txOutput}); // 设置交易ID tx.setTxId(); return tx; } coinbase交易只有一个交易输入。在我们的代码实现中，txId&nbsp;是空数组，txOutputIndex&nbsp;设置为了 -1。另外，coinbase交易不会在&nbsp;ScriptSig&nbsp;字段上存储解锁脚本，相反，存了一个任意的数据。 在比特币中，第一个 coinbase 交易报刊了如下的信息：&quot;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks&quot;.&nbsp; 点击查看 SUBSIDY&nbsp;是挖矿奖励数量。在比特币中，这个奖励数量没有存储在任何地方，而是依据现有区块的总数进行计算而得到：区块总数 除以 210000。开采创世区块得到的奖励为50BTC，每过 210000 个区块，奖励会减半。在我们的实现中，我们暂且将挖矿奖励设置为常数。（至少目前是这样） 在区块链中存储交易信息 从现在开始，每一个区块必须存储至少一个交易信息，并且尽可能地避免在没有交易数据的情况下进行挖矿。这意味着我们必须移除&nbsp;Block&nbsp;对象中的&nbsp;date&nbsp;字段，取而代之的是&nbsp;transactions： /** * 区块 * * @author wangwei * @date 2018/02/02 */ @Data @AllArgsConstructor @NoArgsConstructor public class Block { /** * 区块hash值 */ private String hash; /** * 前一个区块的hash值 */ private String previousHash; /** * 交易信息 */ private Transaction[] transactions; /** * 区块创建时间(单位:秒) */ private long timeStamp; } 相应地，newGenesisBlock&nbsp;与&nbsp;newBlock&nbsp;也都需要做改变： /** * &lt;p&gt; 创建创世区块 &lt;/p&gt; * * @param coinbase * @return */ public static Block newGenesisBlock(Transaction coinbase) { return Block.newBlock(&quot;&quot;, new Transaction[]{coinbase}); } /** * &lt;p&gt; 创建新区块 &lt;/p&gt; * * @param previousHash * @param transactions * @return */ public static Block newBlock(String previousHash, Transaction[] transactions) { Block block = new Block(&quot;&quot;, previousHash, transactions, Instant.now().getEpochSecond(), 0); ProofOfWork pow = ProofOfWork.newProofOfWork(block); PowResult powResult = pow.run(); block.setHash(powResult.getHash()); block.setNonce(powResult.getNonce()); return block; } 接下来，修改&nbsp;newBlockchain&nbsp;方法： /** * &lt;p&gt; 创建区块链 &lt;/p&gt; * * @param address 钱包地址 * @return */ public static Blockchain newBlockchain(String address) throws Exception { String lastBlockHash = RocksDBUtils.getInstance().getLastBlockHash(); if (StringUtils.isBlank(lastBlockHash)) { // 创建 coinBase 交易 Transaction coinbaseTX = Transaction.newCoinbaseTX(address, &quot;&quot;); Block genesisBlock = Block.newGenesisBlock(coinbaseTX); lastBlockHash = genesisBlock.getHash(); RocksDBUtils.getInstance().putBlock(genesisBlock); RocksDBUtils.getInstance().putLastBlockHash(lastBlockHash); } return new Blockchain(lastBlockHash); } 现在，代码有钱包地址的接口，将会收到开采创世区块的奖励。 工作量证明（Pow） Pow算法必须将存储在区块中的交易信息考虑在内，以保存交易信息存储的一致性和可靠性。因此，我们必须修改&nbsp;ProofOfWork.prepareData&nbsp;接口代码逻辑： /** * 准备数据 * &lt;p&gt; * 注意：在准备区块数据时，一定要从原始数据类型转化为byte[]，不能直接从字符串进行转换 * @param nonce * @return */ private String prepareData(long nonce) { byte[] prevBlockHashBytes = {}; if (StringUtils.isNoneBlank(this.getBlock().getPrevBlockHash())) { prevBlockHashBytes = new BigInteger(this.getBlock().getPrevBlockHash(), 16).toByteArray(); } return ByteUtils.merge( prevBlockHashBytes, this.getBlock().hashTransaction(), ByteUtils.toBytes(this.getBlock().getTimeStamp()), ByteUtils.toBytes(TARGET_BITS), ByteUtils.toBytes(nonce) ); } 其中&nbsp;hashTransaction&nbsp;代码如下： /** * 对区块中的交易信息进行Hash计算 * * @return */ public byte[] hashTransaction() { byte[][] txIdArrays = new byte[this.getTransactions().length][]; for (int i = 0; i &lt; this.getTransactions().length; i++) { txIdArrays[i] = this.getTransactions()[i].getTxId(); } return DigestUtils.sha256(ByteUtils.merge(txIds)); } 同样，我们使用哈希值来作为数据的唯一标识。我们希望区块中的所有交易数据都能通过一个哈希值来定义它的唯一标识。为了达到这个目的，我们计算了每一个交易的唯一哈希值，然后将他们串联起来，再对这个串联后的组合进行哈希值计算。 比特币使用更复杂的技术：它将所有包含在块中的交易表示为&nbsp; Merkle树&nbsp;，并在Proof-of-Work系统中使用该树的根散列。 这种方法只需要跟节点的散列值就可以快速检查块是否包含某笔交易，而无需下载所有交易。 UTXO（未花费交易输出） UTXO：unspend transaction output.（未被花费的交易输出） 在比特币的世界里既没有账户，也没有余额，只有分散到区块链里的UTXO. UTXO&nbsp;是理解比特币交易原理的关键所在，我们先来看一段场景： 场景：假设你过去分别向A、B、C这三个比特币用户购买了BTC，从A手中购买了3.5个BTC，从B手中购买了4.5个BTC，从C手中购买了2个BTC，现在你的比特币钱包里面恰好剩余10个BTC。 问题：这个10个BTC是真正的10个BTC吗？其实不是，这句话可能听起来有点怪。（什么！我钱包里面的BTC不是真正的BTC，你不要吓我……） 解释：前面提到过在比特币的交易系统当中，并不存在账户、余额这些概念，所以，你的钱包里面的10个BTC，并不是说钱包余额为10个BTC。而是说，这10个BTC其实是由你的比特币地址（钱包地址|公钥）锁定了的散落在各个区块和各个交易里面的UTXO的总和。 UTXO 是比特币交易的基本单位，每笔交易都会产生UTXO，一个UTXO可以是一“聪”的任意倍。给某人发送比特币实际上是创造新的UTXO，绑定到那个人的钱包地址，并且能被他用于新的支付。 一般的比特币交易由&nbsp;交易输入&nbsp;和&nbsp;交易输出&nbsp;两部分组成。A向你支付3.5个BTC这笔交易，实际上产生了一个新的UTXO，这个新的UTXO 等于 3.5个BTC（3.5亿聪），并且锁定到了你的比特币钱包地址上。 假如你要给你女（男）朋友转 1.5 BTC，那么你的钱包会从可用的UTXO中选取一个或多个可用的个体来拼凑出一个大于或等于一笔交易所需的比特币量。比如在这个假设场景里面，你的钱包会选取你和C的交易中的UTXO作为 交易输入，input = 2BTC，这里会生成两个新的交易输出，一个输出（UTXO = 1.5 BTC）会被绑定到你女（男）朋友的钱包地址上，另一个输出（UTXO = 0.5 BTC）会作为找零，重新绑定到你的钱包地址上。 有关比特币交易这部分更详细的内容，请查看： 《精通比特币（第二版）》第6章 —— 交易 我们需要找到所有未花费的交易输出（UTXO）。Unspent(未花费)&nbsp;意味着这些交易输出从未被交易输入所指向。这前面的图片中，UTXO如下： tx0, output 1; tx1, output 0; tx3, output 0; tx4, output 0. 当然，当我们检查余额时，我不需要区块链中所有的UTXO，我只需要能被我们解锁的UTXO（当前，我们还没有实现密钥对，而是替代为用户自定义的钱包地址）。首先，我们在交易输入与交易输出上定义锁定-解锁的方法： 交易输入： public class TXInput { ... /** * 判断解锁数据是否能够解锁交易输出 * * @param unlockingData * @return */ public boolean canUnlockOutputWith(String unlockingData) { return this.getScriptSig().endsWith(unlockingData); } } 交易输出： public class TXOutput { ... /** * 判断解锁数据是否能够解锁交易输出 * * @param unlockingData * @return */ public boolean canBeUnlockedWith(String unlockingData) { return this.getScriptPubKey().endsWith(unlockingData); } } 这里我们暂时用&nbsp;unlockingData&nbsp;来与脚本字段进行比较。我们会在后面的文章中来对这部分内容进行优化，我们将会基于私钥来实现用户的钱包地址。 下一步，查询所有与钱包地址绑定的包含UTXO的交易信息，有点复杂（本篇先这样实现，后面我们做一个与钱包地址映射的UTXO池来进行优化）： 从与钱包地址对应的交易输入中查询出所有已被花费了的交易输出 再来排除，寻找包含未被花费的交易输出的交易 public class Blockchain { ... /** * 查找钱包地址对应的所有未花费的交易 * * @param address 钱包地址 * @return */ private Transaction[] findUnspentTransactions(String address) throws Exception { Map&lt;String, int[]&gt; allSpentTXOs = this.getAllSpentTXOs(address); Transaction[] unspentTxs = {}; // 再次遍历所有区块中的交易输出 for (BlockchainIterator blockchainIterator = this.getBlockchainIterator(); blockchainIterator.hashNext(); ) { Block block = blockchainIterator.next(); for (Transaction transaction : block.getTransactions()) { String txId = Hex.encodeHexString(transaction.getTxId()); int[] spentOutIndexArray = allSpentTXOs.get(txId); for (int outIndex = 0; outIndex &lt; transaction.getOutputs().length; outIndex++) { if (spentOutIndexArray != null &amp;&amp; ArrayUtils.contains(spentOutIndexArray, outIndex)) { continue; } // 保存不存在 allSpentTXOs 中的交易 if (transaction.getOutputs()[outIndex].canBeUnlockedWith(address)) { unspentTxs = ArrayUtils.add(unspentTxs, transaction); } } } } return unspentTxs; } /** * 从交易输入中查询区块链中所有已被花费了的交易输出 * * @param address 钱包地址 * @return 交易ID以及对应的交易输出下标地址 * @throws Exception */ private Map&lt;String, int[]&gt; getAllSpentTXOs(String address) throws Exception { // 定义TxId ——&gt; spentOutIndex[]，存储交易ID与已被花费的交易输出数组索引值 Map&lt;String, int[]&gt; spentTXOs = new HashMap&lt;&gt;(); for (BlockchainIterator blockchainIterator = this.getBlockchainIterator(); blockchainIterator.hashNext(); ) { Block block = blockchainIterator.next(); for (Transaction transaction : block.getTransactions()) { // 如果是 coinbase 交易，直接跳过，因为它不存在引用前一个区块的交易输出 if (transaction.isCoinbase()) { continue; } for (TXInput txInput : transaction.getInputs()) { if (txInput.canUnlockOutputWith(address)) { String inTxId = Hex.encodeHexString(txInput.getTxId()); int[] spentOutIndexArray = spentTXOs.get(inTxId); if (spentOutIndexArray == null) { spentTXOs.put(inTxId, new int[]{txInput.getTxOutputIndex()}); } else { spentOutIndexArray = ArrayUtils.add(spentOutIndexArray, txInput.getTxOutputIndex()); spentTXOs.put(inTxId, spentOutIndexArray); } } } } } return spentTXOs; } ... } 得到了所有包含UTXO的交易数据，接下来，我们就可以得到所有UTXO集合了： public class Blockchain { ... /** * 查找钱包地址对应的所有UTXO * * @param address 钱包地址 * @return */ public TXOutput[] findUTXO(String address) throws Exception { Transaction[] unspentTxs = this.findUnspentTransactions(address); TXOutput[] utxos = {}; if (unspentTxs == null || unspentTxs.length == 0) { return utxos; } for (Transaction tx : unspentTxs) { for (TXOutput txOutput : tx.getOutputs()) { if (txOutput.canBeUnlockedWith(address)) { utxos = ArrayUtils.add(utxos, txOutput); } } } return utxos; } ... } 现在，我们可以实现获取钱包地址余额的接口了： public class CLI { ... /** * 查询钱包余额 * * @param address 钱包地址 */ private void getBalance(String address) throws Exception { Blockchain blockchain = Blockchain.createBlockchain(address); TXOutput[] txOutputs = blockchain.findUTXO(address); int balance = 0; if (txOutputs != null &amp;&amp; txOutputs.length &gt; 0) { for (TXOutput txOutput : txOutputs) { balance += txOutput.getValue(); } } System.out.printf(&quot;Balance of &#39;%s&#39;: %d\\n&quot;, address, balance); } ... } 查询&nbsp;wangwei&nbsp;这个钱包地址的余额： $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei # 输出 Balance of &#39;wangwei&#39;: 10 转账 现在，我们想要给某人发送一些币。因此，我们需要创建一笔新的交易，然后放入区块中，再进行挖矿。到目前为止，我们只是实现了&nbsp;coinbase&nbsp;交易，现在我们需要实现常见的创建交易接口： public class Transaction { ... /** * 从 from 向 to 支付一定的 amount 的金额 * * @param from 支付钱包地址 * @param to 收款钱包地址 * @param amount 交易金额 * @param blockchain 区块链 * @return */ public static Transaction newUTXOTransaction(String from, String to, int amount, Blockchain blockchain) throws Exception { SpendableOutputResult result = blockchain.findSpendableOutputs(from, amount); int accumulated = result.getAccumulated(); Map&lt;String, int[]&gt; unspentOuts = result.getUnspentOuts(); if (accumulated &lt; amount) { throw new Exception(&quot;ERROR: Not enough funds&quot;); } Iterator&lt;Map.Entry&lt;String, int[]&gt;&gt; iterator = unspentOuts.entrySet().iterator(); TXInput[] txInputs = {}; while (iterator.hasNext()) { Map.Entry&lt;String, int[]&gt; entry = iterator.next(); String txIdStr = entry.getKey(); int[] outIdxs = entry.getValue(); byte[] txId = Hex.decodeHex(txIdStr); for (int outIndex : outIdxs) { txInputs = ArrayUtils.add(txInputs, new TXInput(txId, outIndex, from)); } } TXOutput[] txOutput = {}; txOutput = ArrayUtils.add(txOutput, new TXOutput(amount, to)); if (accumulated &gt; amount) { txOutput = ArrayUtils.add(txOutput, new TXOutput((accumulated - amount), from)); } Transaction newTx = new Transaction(null, txInputs, txOutput); newTx.setTxId(); return newTx; } ... } 在创建新的交易输出之前，我们需要事先找到所有的UTXO，并确保有足够的金额。这就是&nbsp;findSpendableOutputs&nbsp;要干的事情。之后，为每个找到的输出创建一个引用它的输入。接下来，我们创建两个交易输出： 一个&nbsp;output&nbsp;用于锁定到接收者的钱包地址上。这个是真正被转走的coins； 另一个&nbsp;output&nbsp;锁定到发送者的钱包地址上。这个就是 找零。只有当用于支付的UTXO总和大于要支付的金额时，才会创建这部分的 交易输出。记住：交易输出是不可分割的 findSpendableOutputs&nbsp;需要调用我们之前创建的&nbsp;findUnspentTransactions&nbsp;接口： public class Blockchain { ... /** * 寻找能够花费的交易 * * @param address 钱包地址 * @param amount 花费金额 */ public SpendableOutputResult findSpendableOutputs(String address, int amount) throws Exception { Transaction[] unspentTXs = this.findUnspentTransactions(address); int accumulated = 0; Map&lt;String, int[]&gt; unspentOuts = new HashMap&lt;&gt;(); for (Transaction tx : unspentTXs) { String txId = Hex.encodeHexString(tx.getTxId()); for (int outId = 0; outId &lt; tx.getOutputs().length; outId++) { TXOutput txOutput = tx.getOutputs()[outId]; if (txOutput.canBeUnlockedWith(address) &amp;&amp; accumulated &lt; amount) { accumulated += txOutput.getValue(); int[] outIds = unspentOuts.get(txId); if (outIds == null) { outIds = new int[]{outId}; } else { outIds = ArrayUtils.add(outIds, outId); } unspentOuts.put(txId, outIds); if (accumulated &gt;= amount) { break; } } } } return new SpendableOutputResult(accumulated, unspentOuts); } ... } 这个方法会遍历所有的UTXO并统计他们的总额。当计算的总额恰好大于或者等于需要转账的金额时，方法会停止遍历，然后返回用于支付的总额以及按交易ID分组的交易输出索引值数组。我们不想要花更多的钱。 现在，我们可以修改&nbsp;Block.mineBlock&nbsp;接口： public class Block { ... /** * 打包交易，进行挖矿 * * @param transactions */ public void mineBlock(Transaction[] transactions) throws Exception { String lastBlockHash = RocksDBUtils.getInstance().getLastBlockHash(); if (lastBlockHash == null) { throw new Exception(&quot;ERROR: Fail to get last block hash ! &quot;); } Block block = Block.newBlock(lastBlockHash, transactions); this.addBlock(block); } ... } 最后，我们来实现转账的接口： public class CLI { ... /** * 转账 * * @param from * @param to * @param amount */ private void send(String from, String to, int amount) throws Exception { Blockchain blockchain = Blockchain.createBlockchain(from); Transaction transaction = Transaction.newUTXOTransaction(from, to, amount, blockchain); blockchain.mineBlock(new Transaction[]{transaction}); RocksDBUtils.getInstance().closeDB(); System.out.println(&quot;Success!&quot;); } ... } 转账，意味着创建一笔新的交易并且通过挖矿的方式将其存入区块中。但是，比特币不会像我们这样做，它会把新的交易记录先存到内存池中，当一个矿工准备去开采一个区块时，它会把打包内存池中的所有交易信息，并且创建一个候选区块。只有当这个包含所有交易信息的候选区块被成功开采并且被添加到区块链上时，这些交易信息才算被确认。 让我们来测试一下： # 先确认 wangwei 的余额 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei Balance of &#39;wangwei&#39;: 10 # 转账 $ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Pedro -amount 6 Elapsed Time: 0.828 seconds correct hash Hex: 00000c5f50cf72db1f375a5d454f98bc49d07335db921cbef5fa9e58ad34d462 Success! # 查询 wangwei 的余额 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei Balance of &#39;wangwei&#39;: 4 # 查询 Pedro 的余额 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Pedro Balance of &#39;Pedro&#39;: 6 赞！现在让我们来创建更多的交易并且确保从多个交易输出进行转账是正常的： $ java -jar blockchain-java-jar-with-dependencies.jar send -from Pedro -to Helen -amount 2 Elapsed Time: 2.533 seconds correct hash Hex: 00000c81d541ad407a3767ad633d1147602df86fe14e1962ec145ab17b633e88 Success! $ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Helen -amount 2 Elapsed Time: 1.481 seconds correct hash Hex: 00000c3f8b82c2b970438f5f1f39d56bb8a9d66341efc92a02ffcbff91acd84b Success! 现在，Helen 这个钱包地址上有了两笔从 wangwei 和 Pedro 转账中产生的UTXO，让我们将它们再转账给另外一个人： $ java -jar blockchain-java-jar-with-dependencies.jar send -from Helen -to Rachel -amount 3 Elapsed Time: 17.136 seconds correct hash Hex: 000000b1226a947166c2b01a15d1cd3558ddf86fe99bad28a0501a2af60f6a02 Success! $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei Balance of &#39;wangwei&#39;: 2 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Pedro Balance of &#39;Pedro&#39;: 4 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Helen Balance of &#39;Helen&#39;: 1 $ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Rachel Balance of &#39;Rachel&#39;: 3 非常棒！让我们来测试一下失败的场景： $ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Ivan -amount 5 java.lang.Exception: ERROR: Not enough funds at one.wangwei.blockchain.transaction.Transaction.newUTXOTransaction(Transaction.java:104) at one.wangwei.blockchain.cli.CLI.send(CLI.java:138) at one.wangwei.blockchain.cli.CLI.parse(CLI.java:73) at one.wangwei.blockchain.cli.Main.main(Main.java:7) 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ 总结 本篇内容有点难度，但好歹我们现在有了交易信息了。尽管，缺少像比特币这一类加密货币的一些关键特性： 钱包地址。我们还没有基于私钥的真实地址。 奖励。挖矿绝对没有利润。 UTXO集。当我们计算钱包地址的余额时，我们需要遍历所有的区块中的所有交易信息，当有许许多多的区块时，这将花费不少的时间。此外，如果我们想验证以后的交易，可能需要很长时间。 UTXO集旨在解决这些问题并快速处理交易。 内存池。 这是交易在打包成区块之前存储的地方。 在我们当前的实现中，一个块只包含一笔交易，而且效率很低。 文章出处： https://wangwei.one/ &nbsp;转载 ！ 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/27/75b10041984621b48d48ec099b7b340e.html","headline":"基于Java语言构建区块链（四）—— 交易（UTXO）","dateModified":"2018-03-27T00:00:00+08:00","datePublished":"2018-03-27T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/27/75b10041984621b48d48ec099b7b340e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>基于Java语言构建区块链（四）—— 交易（UTXO）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180327140654816" alt=""></p>
  <p></p>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">引言</h2>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><a href="https://wangwei.one/posts/35c768a3.html" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.247059);">上一篇</a>&nbsp;文章，我们实现了区块数据的持久化，本篇开始交易环节的实现。交易这一环节是整个比特币系统当中最为关键的一环，并且区块链唯一的目的就是通过安全的、可信的方式来存储交易信息，防止它们创建之后被人恶意篡改。今天我们开始实现交易这一环节，但由于这是一个很大的话题，所以我们分为两部分：第一部分我们将实现区块链交易的基本机制，到第二部分，我们再来研究它的细节。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">&lt;!--more--&gt;</p>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">比特币交易</h2>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">如果你开发过Web应用程序，为了实现支付系统，你可能会在数据库中创建一些数据库表：<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">账户</code>&nbsp;和&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易记录</code>。账户用于存储用户的个人信息以及账户余额等信息，交易记录用于存储资金从一个账户转移到另一个账户的记录。但是在比特币中，支付系统是以一种完全不一样的方式实现的，在这里：</p>
  <ul style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li style="margin-left:0px;">没有账户</li>
   <li style="margin-left:0px;">没有余额</li>
   <li style="margin-left:0px;">没有地址</li>
   <li style="margin-left:0px;">没有 Coins（币）</li>
   <li style="margin-left:0px;">没有发送者和接受者</li>
  </ul>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">由于区块链是一个公开的数据库，我们不希望存储有关钱包所有者的敏感信息。<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">Coins</code>&nbsp;不会汇总到钱包中。交易不会将资金从一个地址转移到另一个地址。没有可保存帐户余额的字段或属性。只有交易信息。那比特币的交易信息里面到底存储的是什么呢？</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"></p>
  <p style="background:rgb(255,255,255);"><span style="color:rgb(29,29,29);"><span style="font-family:'微软雅黑';">给大家推荐一个</span></span><a href="https://www.yidianzixun.com/channel/w/java" rel="nofollow"><span style="color:rgb(18,154,238);">java</span></a><span style="color:rgb(29,29,29);"><span style="font-family:'微软雅黑';">内部学习群：</span>725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！</span></p>
  <p style="background:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:1.5em;">交易组成</span></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">一笔比特币的交易由&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输入</code>&nbsp;和&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输出</code>&nbsp;组成，数据结构如下：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 交易 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@author</span> wangwei * <span class="hljs-doctag" style="color:rgb(221,17,68);">@date</span> 2017/03/04 */</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@Data</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@AllArgsConstructor</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@NoArgsConstructor</span>
<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Transaction</span> </span>{

    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 交易的Hash */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">byte</span>[] txId;
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 交易输入 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> TXInput[] inputs;
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 交易输出 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> TXOutput[] outputs;

    
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">一笔交易的&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输入</code>&nbsp;其实是指向上一笔交易的<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输出</code>&nbsp;（这个后面详细说明）。我们钱包里面的 Coin（币）实际是存储在这些&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输出</code>&nbsp;里面。下图表示了区块链交易系统里面各个交易相互引用的关系：</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180327140835413" alt=""><br></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">注意：</p>
  <ol style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li>有些&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输出</code>&nbsp;并不是由&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输入</code>&nbsp;产生，而是凭空产生的（后面会详细介绍）。</li>
   <li>但，<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输入</code>&nbsp;必须指向某个&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输出</code>，它不能凭空产生。</li>
   <li>在一笔交易里面，<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输入</code>&nbsp;可能会来自多笔交易所产生的&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输出</code>。</li>
  </ol>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">在整篇文章中，我们将使用诸如“钱”，“硬币”，“花费”，“发送”，“账户”等词语。但比特币中没有这样的概念，在比特币交易中，交易信息是由&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">锁定脚本</code>&nbsp;锁定一个数值，并且只能被所有者的&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">解锁脚本</code>&nbsp;解锁。（解铃还须系铃人）</p>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">交易输出</h2>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">让我们先从交易输出开始，他的数据结构如下：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 交易输出 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@author</span> wangwei * <span class="hljs-doctag" style="color:rgb(221,17,68);">@date</span> 2017/03/04 */</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@Data</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@AllArgsConstructor</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@NoArgsConstructor</span>
<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">TXOutput</span> </span>{

    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 数值 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> value;
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 锁定脚本 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> String scriptPubKey;
    
    
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">实际上，它表示的是能够存储 "coins（币）"的交易输出（注意&nbsp;<strong>value</strong>&nbsp;字段）。并且这里所谓的&nbsp;<strong>value</strong>&nbsp;实际上是由存储在<strong>ScriptPubKey</strong>&nbsp;（锁定脚本）中的一个puzzle（难题） 所锁定。在内部，比特币使用称为脚本的脚本语言，用于定义输出锁定和解锁逻辑。这个语言很原始（这是故意的，以避免可能的黑客和滥用），但我们不会详细讨论它。 你可以在这里找到它的详细解释。<a href="https://en.bitcoin.it/wiki/Script" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.247059);">here</a></p>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   <p>在比特币中，<em>value</em>&nbsp;字段存储着&nbsp;<em>satoshis</em>&nbsp;的任意倍的数值，而不是BTC的数量。<em>satoshis</em>&nbsp;是比特币的百万分之一（0.00000001 BTC），因此这是比特币中最小的货币单位（如1美分）。</p>
   <blockquote style="font-size:1em;border-left:2px solid rgb(0,154,97);color:rgb(85,85,85);">
    <em>satoshis</em>：聪
   </blockquote>
   <p>锁定脚本是一个放在一个输出值上的“障碍”，同时它明确了今后花费这笔输出的条件。由于锁定脚本往往含有一个公钥（即比特币地址），在历史上它曾被称作一个脚本公钥代码。在大多数比特币应用源代码中，脚本公钥代码便是我们所说的锁定脚本。</p>
  </blockquote>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">由于我们还没有实现钱包地址的逻辑，所以这里先暂且忽略锁定脚本相关的逻辑。<strong>ScriptPubKey</strong>&nbsp;将会存储任意的字符串（用户定义的钱包地址）</p>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   顺便说一句，拥有这样的脚本语言意味着比特币也可以用作智能合约平台。
  </blockquote>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">关于&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输出</code>&nbsp;的一个重要的事情是它们是<strong>不可分割的</strong>，这意味着你不能将它所存储的数值拆开来使用。当这个交易输出在新的交易中被交易输入所引用时，它将作为一个整体被花费掉。 如果其值大于所需值，那么剩余的部分则会作为零钱返回给付款方。 这与真实世界的情况类似，例如，您支付5美元的钞票用于购买1美元的东西，那么你将会得到4美元的零钱。</p>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">交易输入</h2>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 交易输入 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@author</span> wangwei * <span class="hljs-doctag" style="color:rgb(221,17,68);">@date</span> 2017/03/04 */</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@Data</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@AllArgsConstructor</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@NoArgsConstructor</span>
<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">TXInput</span> </span>{

    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 交易Id的hash值 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">byte</span>[] txId;
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 交易输出索引 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> txOutputIndex;
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 解锁脚本 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> String scriptSig;

    
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">前面提到过，一个交易输入指向的是某一笔交易的交易输出：</p>
  <ul style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li style="margin-left:0px;"><strong>txId</strong>&nbsp;存储的是某笔交易的ID值</li>
   <li style="margin-left:0px;"><strong>txOutputIndex</strong>&nbsp;存储的是交易中这个交易输出的索引位置（因为一笔交易可能包含多个交易输出）</li>
   <li style="margin-left:0px;"><p><strong>scriptSig</strong>&nbsp;主要是提供用于交易输出中&nbsp;<strong>ScriptPubKey</strong>&nbsp;所需的验证数据。</p>
    <ul style="margin-left:3em;">
     <li style="margin-left:0px;">如果这个数据被验证正确，那么相应的交易输出将被解锁，并且其中的 value 能够生成新的交易输出；</li>
     <li style="margin-left:0px;">如果不正确，那么相应的交易输出将不能被交易输入所引用；</li>
    </ul></li>
  </ul>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">通过锁定脚本与解锁脚本这种机制，保证了某个用户不能花费属于他人的Coins。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">同样，由于我们尚未实现钱包地址功能，<strong>ScriptSig</strong>&nbsp;将会存储任意的用户所定义的钱包地址。我们将会在下一章节实现公钥和数字签名验证。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">说了这么多，我们来总结一下。交易输出是"Coins"实际存储的地方。每一个交易输出都带有一个锁定脚本，它决定了解锁的逻辑。每一笔新的交易必须至少有一个交易输入与交易输出。一笔交易的交易输入指向前一笔交易的交易输出，并且提供用于锁定脚本解锁需要的数据（<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">ScriptSig</code>&nbsp;字段），然后利用交易输出中的&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">value</code>&nbsp;去创建新的交易输出。</p>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   注意，这段话的原文如下，但是里面有表述错误的地方，交易输出带有的是锁定脚本，而不是解锁脚本。
   <p>Let’s sum it up. Outputs are where “coins” are stored. Each output comes with an unlocking script, which determines the logic of unlocking the output. Every new transaction must have at least one input and output. An input references an output from a previous transaction and provides data (the&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">ScriptSig</code>&nbsp;field) that is used in the output’s unlocking script to unlock it and use its value to create new outputs.</p>
  </blockquote>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">那到底是先有交易输入还是先有交易输出呢？</p>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">鸡与蛋的问题</h2>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">在比特币中，鸡蛋先于鸡出现。交易输入源自于交易输出的逻辑是典型的"先有鸡还是先有蛋"的问题：交易输入产生交易输出，交易输出又会被交易输入所引用。在比特币中，<strong>交易输出先于交易输入出现</strong>。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">当矿工开始开采区块时，区块中会被添加一个&nbsp;<strong>coinbase</strong>&nbsp;交易。coinbase 交易是一种特殊的交易，它不需要以前已经存在的交易输出。它会凭空创建出交易输出（i.e: Coins）。也即，鸡蛋的出现并不需要母鸡，这笔交易是作为矿工成功挖出新的区块后的一笔奖励。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">正如你所知道的那样，在区块链的最前端，即第一个区块，有一个创世区块。他产生了区块链中有史以来的第一个交易输出，并且由于没有前一笔交易，也就没有相应的输出，因此不需要前一笔交易的交易输出。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">让我们来创建 coinbase 交易：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 创建CoinBase交易 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> to 收账的钱包地址 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> data 解锁脚本数据 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> Transaction <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">newCoinbaseTX</span><span class="hljs-params">(String to, String data)</span> </span>{
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (StringUtils.isBlank(data)) {
        data = String.format(<span class="hljs-string" style="color:rgb(221,17,68);">"Reward to '%s'"</span>, to);
    }
    <span class="hljs-comment" style="color:rgb(153,153,136);">// 创建交易输入</span>
    TXInput txInput = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> TXInput(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">byte</span>[]{}, -<span class="hljs-number" style="color:rgb(0,128,128);">1</span>, data);
    <span class="hljs-comment" style="color:rgb(153,153,136);">// 创建交易输出</span>
    TXOutput txOutput = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> TXOutput(SUBSIDY, to);
    <span class="hljs-comment" style="color:rgb(153,153,136);">// 创建交易</span>
    Transaction tx = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> Transaction(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">null</span>, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> TXInput[]{txInput}, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> TXOutput[]{txOutput});
    <span class="hljs-comment" style="color:rgb(153,153,136);">// 设置交易ID</span>
    tx.setTxId();
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> tx;
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">coinbase交易只有一个交易输入。在我们的代码实现中，<strong>txId</strong>&nbsp;是空数组，<strong>txOutputIndex</strong>&nbsp;设置为了 -1。另外，coinbase交易不会在&nbsp;<strong>ScriptSig</strong>&nbsp;字段上存储解锁脚本，相反，存了一个任意的数据。</p>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   在比特币中，第一个 coinbase 交易报刊了如下的信息："The Times 03/Jan/2009 Chancellor on brink of second bailout for banks".&nbsp;
   <a href="https://blockchain.info/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b?show_adv=true" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.247059);">点击查看</a>
  </blockquote>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>SUBSIDY</strong>&nbsp;是挖矿奖励数量。在比特币中，这个奖励数量没有存储在任何地方，而是依据现有区块的总数进行计算而得到：区块总数 除以 210000。开采创世区块得到的奖励为50BTC，每过 210000 个区块，奖励会减半。在我们的实现中，我们暂且将挖矿奖励设置为常数。（至少目前是这样）</p>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">在区块链中存储交易信息</h2>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">从现在开始，每一个区块必须存储至少一个交易信息，并且尽可能地避免在没有交易数据的情况下进行挖矿。这意味着我们必须移除&nbsp;<strong>Block</strong>&nbsp;对象中的&nbsp;<strong>date</strong>&nbsp;字段，取而代之的是&nbsp;<strong>transactions</strong>：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 区块 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@author</span> wangwei * <span class="hljs-doctag" style="color:rgb(221,17,68);">@date</span> 2018/02/02 */</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@Data</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@AllArgsConstructor</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@NoArgsConstructor</span>
<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Block</span> </span>{

    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 区块hash值 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> String hash;
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 前一个区块的hash值 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> String previousHash;
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 交易信息 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> Transaction[] transactions;
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 区块创建时间(单位:秒) */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">long</span> timeStamp;

}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">相应地，<strong>newGenesisBlock</strong>&nbsp;与&nbsp;<strong>newBlock</strong>&nbsp;也都需要做改变：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * &lt;p&gt; 创建创世区块 &lt;/p&gt; * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> coinbase * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">static</span> Block <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">newGenesisBlock</span><span class="hljs-params">(Transaction coinbase)</span> </span>{
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> Block.newBlock(<span class="hljs-string" style="color:rgb(221,17,68);">""</span>, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> Transaction[]{coinbase});
}

<span class="hljs-comment" style="color:rgb(153,153,136);">/** * &lt;p&gt; 创建新区块 &lt;/p&gt; * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> previousHash * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> transactions * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">static</span> Block <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">newBlock</span><span class="hljs-params">(String previousHash, Transaction[] transactions)</span> </span>{
     Block block = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> Block(<span class="hljs-string" style="color:rgb(221,17,68);">""</span>, previousHash, transactions, Instant.now().getEpochSecond(), <span class="hljs-number" style="color:rgb(0,128,128);">0</span>);
     ProofOfWork pow = ProofOfWork.newProofOfWork(block);
     PowResult powResult = pow.run();
     block.setHash(powResult.getHash());
     block.setNonce(powResult.getNonce());
     <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> block;
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">接下来，修改&nbsp;<strong>newBlockchain</strong>&nbsp;方法：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * &lt;p&gt; 创建区块链 &lt;/p&gt; * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> address 钱包地址 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">static</span> Blockchain <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">newBlockchain</span><span class="hljs-params">(String address)</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">throws</span> Exception </span>{
    String lastBlockHash = RocksDBUtils.getInstance().getLastBlockHash();
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (StringUtils.isBlank(lastBlockHash)) {
        <span class="hljs-comment" style="color:rgb(153,153,136);">// 创建 coinBase 交易</span>
        Transaction coinbaseTX = Transaction.newCoinbaseTX(address, <span class="hljs-string" style="color:rgb(221,17,68);">""</span>);
        Block genesisBlock = Block.newGenesisBlock(coinbaseTX);
        lastBlockHash = genesisBlock.getHash();
        RocksDBUtils.getInstance().putBlock(genesisBlock);
        RocksDBUtils.getInstance().putLastBlockHash(lastBlockHash);
     }
     <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> Blockchain(lastBlockHash);
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">现在，代码有钱包地址的接口，将会收到开采创世区块的奖励。</p>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">工作量证明（Pow）</h2>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">Pow算法必须将存储在区块中的交易信息考虑在内，以保存交易信息存储的一致性和可靠性。因此，我们必须修改&nbsp;<strong>ProofOfWork.prepareData</strong>&nbsp;接口代码逻辑：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 准备数据 * &lt;p&gt; * 注意：在准备区块数据时，一定要从原始数据类型转化为byte[]，不能直接从字符串进行转换 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> nonce * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> String <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">prepareData</span><span class="hljs-params">(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">long</span> nonce)</span> </span>{
   <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">byte</span>[] prevBlockHashBytes = {};
   <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (StringUtils.isNoneBlank(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlock().getPrevBlockHash())) {
       prevBlockHashBytes = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> BigInteger(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlock().getPrevBlockHash(), <span class="hljs-number" style="color:rgb(0,128,128);">16</span>).toByteArray();
   }

   <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> ByteUtils.merge(
           prevBlockHashBytes,
           <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlock().hashTransaction(),
           ByteUtils.toBytes(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlock().getTimeStamp()),
           ByteUtils.toBytes(TARGET_BITS),
           ByteUtils.toBytes(nonce)
    );
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">其中&nbsp;<strong>hashTransaction</strong>&nbsp;代码如下：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 对区块中的交易信息进行Hash计算 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">byte</span>[] hashTransaction() {
   <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">byte</span>[][] txIdArrays = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">byte</span>[<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getTransactions().length][];
   <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> i = <span class="hljs-number" style="color:rgb(0,128,128);">0</span>; i &lt; <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getTransactions().length; i++) {
       txIdArrays[i] = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getTransactions()[i].getTxId();
   }
   <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> DigestUtils.sha256(ByteUtils.merge(txIds));
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">同样，我们使用哈希值来作为数据的唯一标识。我们希望区块中的所有交易数据都能通过一个哈希值来定义它的唯一标识。为了达到这个目的，我们计算了每一个交易的唯一哈希值，然后将他们串联起来，再对这个串联后的组合进行哈希值计算。</p>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   比特币使用更复杂的技术：它将所有包含在块中的交易表示为&nbsp;
   <a href="https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.247059);">Merkle树</a>&nbsp;，并在Proof-of-Work系统中使用该树的根散列。 这种方法只需要跟节点的散列值就可以快速检查块是否包含某笔交易，而无需下载所有交易。
  </blockquote>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">UTXO（未花费交易输出）</h2>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   UTXO：unspend transaction output.（未被花费的交易输出）
   <p>在比特币的世界里既没有账户，也没有余额，只有分散到区块链里的UTXO.</p>
  </blockquote>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><em>UTXO</em>&nbsp;是理解比特币交易原理的关键所在，我们先来看一段场景：</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">场景：假设你过去分别向A、B、C这三个比特币用户购买了BTC，从A手中购买了3.5个BTC，从B手中购买了4.5个BTC，从C手中购买了2个BTC，现在你的比特币钱包里面恰好剩余10个BTC。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">问题：这个10个BTC是真正的10个BTC吗？其实不是，这句话可能听起来有点怪。（什么！我钱包里面的BTC不是真正的BTC，你不要吓我……）</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">解释：前面提到过在比特币的交易系统当中，并不存在账户、余额这些概念，所以，你的钱包里面的10个BTC，并不是说钱包余额为10个BTC。而是说，这10个BTC其实是由你的比特币地址（钱包地址|公钥）锁定了的散落在各个区块和各个交易里面的UTXO的总和。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">UTXO 是比特币交易的基本单位，每笔交易都会产生UTXO，一个UTXO可以是一“聪”的任意倍。给某人发送比特币实际上是创造新的UTXO，绑定到那个人的钱包地址，并且能被他用于新的支付。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">一般的比特币交易由&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输入</code>&nbsp;和&nbsp;<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">交易输出</code>&nbsp;两部分组成。A向你支付3.5个BTC这笔交易，实际上产生了一个新的UTXO，这个新的UTXO 等于 3.5个BTC（3.5亿聪），并且锁定到了你的比特币钱包地址上。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">假如你要给你女（男）朋友转 1.5 BTC，那么你的钱包会从可用的UTXO中选取一个或多个可用的个体来拼凑出一个大于或等于一笔交易所需的比特币量。比如在这个假设场景里面，你的钱包会选取你和C的交易中的UTXO作为 交易输入，input = 2BTC，这里会生成两个新的交易输出，一个输出（UTXO = 1.5 BTC）会被绑定到你女（男）朋友的钱包地址上，另一个输出（UTXO = 0.5 BTC）会作为找零，重新绑定到你的钱包地址上。</p>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   有关比特币交易这部分更详细的内容，请查看：
   <a href="https://github.com/bitcoinbook/bitcoinbook" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.247059);">《精通比特币（第二版）》第6章 —— 交易</a>
  </blockquote>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">我们需要找到所有未花费的交易输出（UTXO）。<em>Unspent(未花费)</em>&nbsp;意味着这些交易输出从未被交易输入所指向。这前面的图片中，UTXO如下：</p>
  <ol style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li>tx0, output 1;</li>
   <li>tx1, output 0;</li>
   <li>tx3, output 0;</li>
   <li>tx4, output 0.</li>
  </ol>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">当然，当我们检查余额时，我不需要区块链中所有的UTXO，我只需要能被我们解锁的UTXO（当前，我们还没有实现密钥对，而是替代为用户自定义的钱包地址）。首先，我们在交易输入与交易输出上定义锁定-解锁的方法：</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">交易输入：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">TXInput</span> </span>{
      
    ...
     
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 判断解锁数据是否能够解锁交易输出 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> unlockingData * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">boolean</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">canUnlockOutputWith</span><span class="hljs-params">(String unlockingData)</span> </span>{
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getScriptSig().endsWith(unlockingData);
    }
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">交易输出：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">TXOutput</span> </span>{
    
    ...
        
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 判断解锁数据是否能够解锁交易输出 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> unlockingData * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">boolean</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">canBeUnlockedWith</span><span class="hljs-params">(String unlockingData)</span> </span>{
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getScriptPubKey().endsWith(unlockingData);
    }
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">这里我们暂时用&nbsp;<strong>unlockingData</strong>&nbsp;来与脚本字段进行比较。我们会在后面的文章中来对这部分内容进行优化，我们将会基于私钥来实现用户的钱包地址。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">下一步，查询所有与钱包地址绑定的包含UTXO的交易信息，有点复杂（本篇先这样实现，后面我们做一个与钱包地址映射的UTXO池来进行优化）：</p>
  <ul style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li style="margin-left:0px;">从与钱包地址对应的交易输入中查询出所有已被花费了的交易输出</li>
   <li style="margin-left:0px;">再来排除，寻找包含未被花费的交易输出的交易</li>
  </ul>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Blockchain</span> </span>{

    ...

    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 查找钱包地址对应的所有未花费的交易 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> address 钱包地址 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> Transaction[] findUnspentTransactions(String address) <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">throws</span> Exception {
        Map&lt;String, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[]&gt; allSpentTXOs = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getAllSpentTXOs(address);
        Transaction[] unspentTxs = {};

        <span class="hljs-comment" style="color:rgb(153,153,136);">// 再次遍历所有区块中的交易输出</span>
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (BlockchainIterator blockchainIterator = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlockchainIterator(); blockchainIterator.hashNext(); ) {
            Block block = blockchainIterator.next();
            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (Transaction transaction : block.getTransactions()) {

                String txId = Hex.encodeHexString(transaction.getTxId());

                <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[] spentOutIndexArray = allSpentTXOs.get(txId);

                <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> outIndex = <span class="hljs-number" style="color:rgb(0,128,128);">0</span>; outIndex &lt; transaction.getOutputs().length; outIndex++) {
                    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (spentOutIndexArray != <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">null</span> &amp;&amp; ArrayUtils.contains(spentOutIndexArray, outIndex)) {
                        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">continue</span>;
                    }

                    <span class="hljs-comment" style="color:rgb(153,153,136);">// 保存不存在 allSpentTXOs 中的交易</span>
                    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (transaction.getOutputs()[outIndex].canBeUnlockedWith(address)) {
                        unspentTxs = ArrayUtils.add(unspentTxs, transaction);
                    }
                }
            }
        }
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> unspentTxs;
    }


    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 从交易输入中查询区块链中所有已被花费了的交易输出 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> address 钱包地址 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> 交易ID以及对应的交易输出下标地址 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@throws</span> Exception */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> Map&lt;String, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[]&gt; getAllSpentTXOs(String address) <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">throws</span> Exception {
        <span class="hljs-comment" style="color:rgb(153,153,136);">// 定义TxId ——&gt; spentOutIndex[]，存储交易ID与已被花费的交易输出数组索引值</span>
        Map&lt;String, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[]&gt; spentTXOs = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (BlockchainIterator blockchainIterator = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlockchainIterator(); blockchainIterator.hashNext(); ) {
            Block block = blockchainIterator.next();

            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (Transaction transaction : block.getTransactions()) {
                <span class="hljs-comment" style="color:rgb(153,153,136);">// 如果是 coinbase 交易，直接跳过，因为它不存在引用前一个区块的交易输出</span>
                <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (transaction.isCoinbase()) {
                    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">continue</span>;
                }
                <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (TXInput txInput : transaction.getInputs()) {
                    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (txInput.canUnlockOutputWith(address)) {
                        String inTxId = Hex.encodeHexString(txInput.getTxId());
                        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[] spentOutIndexArray = spentTXOs.get(inTxId);
                        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (spentOutIndexArray == <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">null</span>) {
                            spentTXOs.put(inTxId, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[]{txInput.getTxOutputIndex()});
                        } <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">else</span> {
                            spentOutIndexArray = ArrayUtils.add(spentOutIndexArray, txInput.getTxOutputIndex());
                            spentTXOs.put(inTxId, spentOutIndexArray);
                        }
                    }
                }
            }
        }
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> spentTXOs;
    }
    
    ...
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">得到了所有包含UTXO的交易数据，接下来，我们就可以得到所有UTXO集合了：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Blockchain</span> </span>{

   ...

   <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 查找钱包地址对应的所有UTXO * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> address 钱包地址 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> TXOutput[] findUTXO(String address) <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">throws</span> Exception {
        Transaction[] unspentTxs = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.findUnspentTransactions(address);
        TXOutput[] utxos = {};
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (unspentTxs == <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">null</span> || unspentTxs.length == <span class="hljs-number" style="color:rgb(0,128,128);">0</span>) {
            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> utxos;
        }
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (Transaction tx : unspentTxs) {
            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (TXOutput txOutput : tx.getOutputs()) {
                <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (txOutput.canBeUnlockedWith(address)) {
                    utxos = ArrayUtils.add(utxos, txOutput);
                }
            }
        }
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> utxos;
    }
    
    ...
    
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">现在，我们可以实现获取钱包地址余额的接口了：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">CLI</span> </span>{

    ...
        
   <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 查询钱包余额 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> address 钱包地址 */</span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">void</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">getBalance</span><span class="hljs-params">(String address)</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">throws</span> Exception </span>{
        Blockchain blockchain = Blockchain.createBlockchain(address);
        TXOutput[] txOutputs = blockchain.findUTXO(address);
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> balance = <span class="hljs-number" style="color:rgb(0,128,128);">0</span>;
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (txOutputs != <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">null</span> &amp;&amp; txOutputs.length &gt; <span class="hljs-number" style="color:rgb(0,128,128);">0</span>) {
            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (TXOutput txOutput : txOutputs) {
                balance += txOutput.getValue();
            }
        }
        System.out.printf(<span class="hljs-string" style="color:rgb(221,17,68);">"Balance of '%s': %d\n"</span>, address, balance);
    }
 
    ...
        
}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">查询&nbsp;<em>wangwei</em>&nbsp;这个钱包地址的余额：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="powershell" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">$ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei

<span class="hljs-comment" style="color:rgb(153,153,136);"># 输出</span>
Balance of <span class="hljs-string" style="color:rgb(221,17,68);">'wangwei'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">10</span></code></pre>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">转账</h2>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">现在，我们想要给某人发送一些币。因此，我们需要创建一笔新的交易，然后放入区块中，再进行挖矿。到目前为止，我们只是实现了&nbsp;<em>coinbase</em>&nbsp;交易，现在我们需要实现常见的创建交易接口：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Transaction</span> </span>{
 
   ...
   
   <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 从 from 向 to 支付一定的 amount 的金额 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> from 支付钱包地址 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> to 收款钱包地址 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> amount 交易金额 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> blockchain 区块链 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">static</span> Transaction <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">newUTXOTransaction</span><span class="hljs-params">(String from, String to, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> amount, Blockchain blockchain)</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">throws</span> Exception </span>{
        SpendableOutputResult result = blockchain.findSpendableOutputs(from, amount);
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> accumulated = result.getAccumulated();
        Map&lt;String, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[]&gt; unspentOuts = result.getUnspentOuts();

        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (accumulated &lt; amount) {
            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">throw</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> Exception(<span class="hljs-string" style="color:rgb(221,17,68);">"ERROR: Not enough funds"</span>);
        }
        Iterator&lt;Map.Entry&lt;String, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[]&gt;&gt; iterator = unspentOuts.entrySet().iterator();

        TXInput[] txInputs = {};
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">while</span> (iterator.hasNext()) {
            Map.Entry&lt;String, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[]&gt; entry = iterator.next();
            String txIdStr = entry.getKey();
            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[] outIdxs = entry.getValue();
            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">byte</span>[] txId = Hex.decodeHex(txIdStr);
            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> outIndex : outIdxs) {
                txInputs = ArrayUtils.add(txInputs, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> TXInput(txId, outIndex, from));
            }
        }

        TXOutput[] txOutput = {};
        txOutput = ArrayUtils.add(txOutput, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> TXOutput(amount, to));
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (accumulated &gt; amount) {
            txOutput = ArrayUtils.add(txOutput, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> TXOutput((accumulated - amount), from));
        }

        Transaction newTx = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> Transaction(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">null</span>, txInputs, txOutput);
        newTx.setTxId();
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> newTx;
    }
    
    ...
    
}    </code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">在创建新的交易输出之前，我们需要事先找到所有的UTXO，并确保有足够的金额。这就是&nbsp;<strong>findSpendableOutputs</strong>&nbsp;要干的事情。之后，为每个找到的输出创建一个引用它的输入。接下来，我们创建两个交易输出：</p>
  <ol style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li>一个&nbsp;<em>output</em>&nbsp;用于锁定到接收者的钱包地址上。这个是真正被转走的coins；</li>
   <li>另一个&nbsp;<em>output</em>&nbsp;锁定到发送者的钱包地址上。这个就是 找零。只有当用于支付的UTXO总和大于要支付的金额时，才会创建这部分的 交易输出。记住：交易输出是<strong>不可分割的</strong></li>
  </ol>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><strong>findSpendableOutputs</strong>&nbsp;需要调用我们之前创建的&nbsp;<strong>findUnspentTransactions</strong>&nbsp;接口：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Blockchain</span> </span>{

    ...
    
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 寻找能够花费的交易 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> address 钱包地址 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> amount 花费金额 */</span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> SpendableOutputResult <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">findSpendableOutputs</span><span class="hljs-params">(String address, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> amount)</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">throws</span> Exception </span>{
        Transaction[] unspentTXs = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.findUnspentTransactions(address);
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> accumulated = <span class="hljs-number" style="color:rgb(0,128,128);">0</span>;
        Map&lt;String, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[]&gt; unspentOuts = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (Transaction tx : unspentTXs) {

            String txId = Hex.encodeHexString(tx.getTxId());

            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> outId = <span class="hljs-number" style="color:rgb(0,128,128);">0</span>; outId &lt; tx.getOutputs().length; outId++) {

                TXOutput txOutput = tx.getOutputs()[outId];

                <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (txOutput.canBeUnlockedWith(address) &amp;&amp; accumulated &lt; amount) {
                    accumulated += txOutput.getValue();

                    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[] outIds = unspentOuts.get(txId);
                    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (outIds == <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">null</span>) {
                        outIds = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span>[]{outId};
                    } <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">else</span> {
                        outIds = ArrayUtils.add(outIds, outId);
                    }
                    unspentOuts.put(txId, outIds);
                    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (accumulated &gt;= amount) {
                        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">break</span>;
                    }
                }
            }
        }
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> SpendableOutputResult(accumulated, unspentOuts);
    }
    
    ...

}</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">这个方法会遍历所有的UTXO并统计他们的总额。当计算的总额恰好大于或者等于需要转账的金额时，方法会停止遍历，然后返回用于支付的总额以及按交易ID分组的交易输出索引值数组。我们不想要花更多的钱。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">现在，我们可以修改&nbsp;<strong>Block.mineBlock</strong>&nbsp;接口：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">Block</span> </span>{
   
   ...
   
   <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 打包交易，进行挖矿 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> transactions */</span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">void</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">mineBlock</span><span class="hljs-params">(Transaction[] transactions)</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">throws</span> Exception </span>{
        String lastBlockHash = RocksDBUtils.getInstance().getLastBlockHash();
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (lastBlockHash == <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">null</span>) {
            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">throw</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> Exception(<span class="hljs-string" style="color:rgb(221,17,68);">"ERROR: Fail to get last block hash ! "</span>);
        }
        Block block = Block.newBlock(lastBlockHash, transactions);
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.addBlock(block);
    }
    
    ...
    
}    </code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">最后，我们来实现转账的接口：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">CLI</span> </span>{
   
   ...
  
   <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 转账 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> from * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> to * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> amount */</span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">void</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">send</span><span class="hljs-params">(String from, String to, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> amount)</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">throws</span> Exception </span>{
        Blockchain blockchain = Blockchain.createBlockchain(from);
        Transaction transaction = Transaction.newUTXOTransaction(from, to, amount, blockchain);
        blockchain.mineBlock(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> Transaction[]{transaction});
        RocksDBUtils.getInstance().closeDB();
        System.out.println(<span class="hljs-string" style="color:rgb(221,17,68);">"Success!"</span>);
    }
    
    ...
    
}    </code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">转账，意味着创建一笔新的交易并且通过挖矿的方式将其存入区块中。但是，比特币不会像我们这样做，它会把新的交易记录先存到内存池中，当一个矿工准备去开采一个区块时，它会把打包内存池中的所有交易信息，并且创建一个候选区块。只有当这个包含所有交易信息的候选区块被成功开采并且被添加到区块链上时，这些交易信息才算被确认。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">让我们来测试一下：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="powershell" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);"># 先确认 wangwei 的余额</span>
$ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei
Balance of <span class="hljs-string" style="color:rgb(221,17,68);">'wangwei'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">10</span>

<span class="hljs-comment" style="color:rgb(153,153,136);"># 转账</span>
$ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Pedro -amount <span class="hljs-number" style="color:rgb(0,128,128);">6</span>
Elapsed Time: <span class="hljs-number" style="color:rgb(0,128,128);">0.828</span> seconds 
correct hash Hex: <span class="hljs-number" style="color:rgb(0,128,128);">00000</span>c5f50cf72db1f375a5d454f98bc49d07335db921cbef5fa9e58ad34d462 

Success!

<span class="hljs-comment" style="color:rgb(153,153,136);"># 查询 wangwei 的余额</span>
$ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei
Balance of <span class="hljs-string" style="color:rgb(221,17,68);">'wangwei'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">4</span>


<span class="hljs-comment" style="color:rgb(153,153,136);"># 查询 Pedro 的余额</span>
$ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Pedro
Balance of <span class="hljs-string" style="color:rgb(221,17,68);">'Pedro'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">6</span></code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">赞！现在让我们来创建更多的交易并且确保从多个交易输出进行转账是正常的：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="powershell" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">$ java -jar blockchain-java-jar-with-dependencies.jar send -from Pedro -to Helen -amount <span class="hljs-number" style="color:rgb(0,128,128);">2</span>
Elapsed Time: <span class="hljs-number" style="color:rgb(0,128,128);">2.533</span> seconds 
correct hash Hex: <span class="hljs-number" style="color:rgb(0,128,128);">00000</span>c81d541ad407a3767ad633d1147602df86fe14e1962ec145ab17b633e88 

Success!


$ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Helen -amount <span class="hljs-number" style="color:rgb(0,128,128);">2</span>
Elapsed Time: <span class="hljs-number" style="color:rgb(0,128,128);">1.481</span> seconds 
correct hash Hex: <span class="hljs-number" style="color:rgb(0,128,128);">00000</span>c3f8b82c2b970438f5f1f39d56bb8a9d66341efc92a02ffcbff91acd84b 

Success!</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">现在，Helen 这个钱包地址上有了两笔从 wangwei 和 Pedro 转账中产生的UTXO，让我们将它们再转账给另外一个人：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="powershell" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">$ java -jar blockchain-java-jar-with-dependencies.jar send -from Helen -to Rachel -amount <span class="hljs-number" style="color:rgb(0,128,128);">3</span>
Elapsed Time: <span class="hljs-number" style="color:rgb(0,128,128);">17.136</span> seconds 
correct hash Hex: <span class="hljs-number" style="color:rgb(0,128,128);">000000</span>b1226a947166c2b01a15d1cd3558ddf86fe99bad28a0501a2af60f6a02 

Success!

$ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address wangwei
Balance of <span class="hljs-string" style="color:rgb(221,17,68);">'wangwei'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">2</span>
$ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Pedro  
Balance of <span class="hljs-string" style="color:rgb(221,17,68);">'Pedro'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">4</span>
$ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Helen
Balance of <span class="hljs-string" style="color:rgb(221,17,68);">'Helen'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">1</span>
$ java -jar blockchain-java-jar-with-dependencies.jar getbalance -address Rachel
Balance of <span class="hljs-string" style="color:rgb(221,17,68);">'Rachel'</span>: <span class="hljs-number" style="color:rgb(0,128,128);">3</span>
</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">非常棒！让我们来测试一下失败的场景：</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="powershell" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">$ java -jar blockchain-java-jar-with-dependencies.jar send -from wangwei -to Ivan -amount <span class="hljs-number" style="color:rgb(0,128,128);">5</span> 
java.lang.Exception: ERROR: Not enough funds
        at one.wangwei.blockchain.transaction.Transaction.newUTXOTransaction(Transaction.java:<span class="hljs-number" style="color:rgb(0,128,128);">104</span>)
        at one.wangwei.blockchain.cli.CLI.send(CLI.java:<span class="hljs-number" style="color:rgb(0,128,128);">138</span>)
        at one.wangwei.blockchain.cli.CLI.parse(CLI.java:<span class="hljs-number" style="color:rgb(0,128,128);">73</span>)
        at one.wangwei.blockchain.cli.Main.main(Main.java:<span class="hljs-number" style="color:rgb(0,128,128);">7</span>)</code></pre>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);"></h2>
  <p style="background:rgb(255,255,255);"><span style="color:rgb(29,29,29);"><span style="font-family:'微软雅黑';">给大家推荐一个</span></span><a href="https://www.yidianzixun.com/channel/w/java" rel="nofollow"><span style="color:rgb(18,154,238);">java</span></a><span style="color:rgb(29,29,29);"><span style="font-family:'微软雅黑';">内部学习群：</span>725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！</span></p>
  <p style="background:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:1.75em;">总结</span></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">本篇内容有点难度，但好歹我们现在有了交易信息了。尽管，缺少像比特币这一类加密货币的一些关键特性：</p>
  <ol style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li>钱包地址。我们还没有基于私钥的真实地址。</li>
   <li>奖励。挖矿绝对没有利润。</li>
   <li>UTXO集。当我们计算钱包地址的余额时，我们需要遍历所有的区块中的所有交易信息，当有许许多多的区块时，这将花费不少的时间。此外，如果我们想验证以后的交易，可能需要很长时间。 UTXO集旨在解决这些问题并快速处理交易。</li>
   <li>内存池。 这是交易在打包成区块之前存储的地方。 在我们当前的实现中，一个块只包含一笔交易，而且效率很低。</li>
   <li><span style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">文章出处： https://wangwei.one/ &nbsp;转载 ！</span><br></li>
  </ol>
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/gupao123456/article/details/79712293,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/gupao123456/article/details/79712293,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
