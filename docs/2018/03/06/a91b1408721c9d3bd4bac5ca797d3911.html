<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码阅读笔记【共识篇】 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码阅读笔记【共识篇】" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="比特币源码阅读笔记【共识篇】 这篇文章总结下比特币挖矿和共识相关内容。 一、挖矿和共识 挖矿这个词可能让一部分人误解了比特币矿工。矿工的工作，主要是验证交易和打包区块，而得到的比特币奖励和手续费是一种激励手段和“副产品”。比特币的挖矿是比特币P2P网络节点各自独立发生的四个过程的相互作用的结果： 完整区块链节点，基于一串规则独立验证每笔交易； 矿工节点独立打包交易成为新的区块；通过工作量证明算法（Proof-of-work, 简写为PoW）证明你的计算工作量后产生新的区块； 每个节点独立验证新的区块，组装到链中； 每个节点基于PoW算法，独立选择工作量最大的链； 1.1 独立验证 前文提到过，比特币系统设计中没有账户余额，取而代之的是历史交易记录，比特币完整节点可以通过历史交易记录计算得到UTXO。当比特币钱包“收到”比特币时，实际发生的是钱包检测到UTXO池中存在该钱包私钥可以花费的UTXO。因此，用户的比特币“余额”实际是用户钱包可以花费的所有UTXO的和，而这个值需要从很多区块、很多交易记录中汇总得到。余额的概念存在于钱包，但不存在于区块链。 1.1.1 验证交易 首先回顾一下交易结构，一笔交易的输入包含以下信息： Transaction Hash 哈希指针，指向包含被花费UTXO的交易 Output Index 被花费的UTXO的索引 Unlocking-Script Size 解锁脚本的大小（字节数） Unlocking-Script 完成了UTXO加锁脚本条件的解锁脚本 Sequence Number 用于locktime，取值0xFFFFFFFF表示禁用 交易的输入需要有一个哈希指针，指向即将在交易中花费的UTXO。节点在向邻居节点转发交易前，会首先独立验证交易，只有符合一系列条件的交易才会在比特币网络向新的节点进行传播。矿工独立验证交易的内容，一部分内容是验证UTXO是否合法（防止双重支付），另一部分就是验证交易脚本是否有权限花费这些UTXO（验证签名）。验证交易输入的代码主要在以下几个函数中：AcceptToMemoryPool, Check Transaction, CheckInputs。 bool CheckInputs(const CTransaction&amp; tx, CValidationState &amp;state, const CCoinsViewCache &amp;inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData&amp; txdata, std::vector&lt;CScriptCheck&gt; *pvChecks) { if (!tx.IsCoinBase()) { if (pvChecks) pvChecks-&gt;reserve(tx.vin.size()); if (fScriptChecks) { // 此处省略部分代码 for (unsigned int i = 0; i &lt; tx.vin.size(); i++) { // 1. 验证UTXO，防止双重支付 const COutPoint &amp;prevout = tx.vin[i].prevout; const Coin&amp; coin = inputs.AccessCoin(prevout); assert(!coin.IsSpent()); // 2. 验证签名，确认所有权 CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &amp;txdata); if (pvChecks) { pvChecks-&gt;push_back(CScriptCheck()); check.swap(pvChecks-&gt;back()); } else if (!check()) { if (flags &amp; STANDARD_NOT_MANDATORY_VERIFY_FLAGS) { CScriptCheck check2(coin.out, tx, i, flags &amp; ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &amp;txdata); if (check2()) return state.Invalid(false, REJECT_NONSTANDARD, strprintf(&quot;non-mandatory-script-verify-flag (%s)&quot;, ScriptErrorString(check.GetScriptError()))); } return state.DoS(100,false, REJECT_INVALID, strprintf(&quot;mandatory-script-verify-flag-failed (%s)&quot;, ScriptErrorString(check.GetScriptError()))); } } if (cacheFullScriptStore &amp;&amp; !pvChecks) { scriptExecutionCache.insert(hashCacheEntry); } } } return true; } 矿工会将通过验证的交易放入内存（代码见AcceptToMemoryPool），在进行工作量证明计算并赢得记账权后，将上述交易打包到区块中。 static bool AcceptToMemoryPoolWorker(const CChainParams&amp; chainparams, CTxMemPool&amp; pool, CValidationState&amp; state, const CTransactionRef&amp; ptx, bool* pfMissingInputs, int64_t nAcceptTime, std::list&lt;CTransactionRef&gt;* plTxnReplaced, bool bypass_limits, const CAmount&amp; nAbsurdFee, std::vector&lt;COutPoint&gt;&amp; coins_to_uncache) { // 此处省略部分代码 GetMainSignals().TransactionAddedToMempool(ptx); return true; } 1.1.2 验证区块 1.2 独立打包区块 假设矿工的名字是Jing。在Alice付给Bob比特币购买咖啡时，Jing的节点组装了一条区块链，高度是277314。Jing的节点持续监听网络中的交易，也持续监听其他节点发现的新区块。突然Jing的节点在网络中发现了区块277315，这时候对应区块277315的算力竞赛宣告结束，同时开启了对应区块277316的算力竞赛。 在Jing的节点搜索区块277315的答案的时候，它同时收集了许多通过验证的交易，并把这些通过验证的交易放到了内存池中。一旦收到区块277315并且完成了验证，Jing的节点会比较内存池中的所有交易，删除区块277315中包含的交易。内存池中剩下的交易记录可以继续保留，等待下一次的交易打包。 Jing 的节点立刻创建一个空区块，称为候选区块277316。一旦候选区块在工作量证明算法中胜出，这个候选区块就成为了合法区块。回顾下区块的结构，比特币区块主要包含四个字段：prevHash, nonce, Merkle Root和timestamp。 构成区块的过程主要分成两个部分：1. 汇总交易，生成交易摘要Merkle Root哈希值 2. 加入随机数nonce，生成区块header，并验证区块header是否满足上个区块的设定的目标值； 1.2.1 Coinbase交易 每个区块的第一笔交易叫做Coinbase交易。Coinbase交易是一笔特殊交易，因为它包含了挖矿奖励。和普通交易不同，coinbase交易的输入不包含UTXO，而是输入一个coinbase值，用于凭空创造比特币。Coinbase交易有一个输出，向矿工的比特币地址支付比特币。 我们可以通过命令bitcoin-cli getrawtransaction查看coinbase。 $ bitcoin-cli getrawtransaction d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f 1 { &quot;hex&quot;: &quot;01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff6 f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000 &quot;, &quot;txid&quot;: &quot;d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f&quot;, &quot;version&quot;: 1, &quot;locktime&quot;: 0, &quot;vin&quot;: [{ &quot;coinbase&quot;: &quot;03443b0403858402062f503253482f&quot;, &quot;sequence&quot;: 4294967295 }], &quot;vout&quot;: [{ &quot;value&quot;: 25.09094928, &quot;n&quot;: 0, &quot;scriptPubKey&quot;: { &quot;asm&quot;: &quot;02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG&quot;, &quot;hex&quot;: &quot;2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac&quot;, &quot;reqSigs&quot;: 1, &quot;type&quot;: &quot;pubkey&quot;, &quot;addresses&quot;: [ &quot;1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N&quot; ] } }] } Coinbase交易不包含解锁脚本字段（即scriptSig），取代它的是coinbase数据字段，其大小限制为2至100个字节。除了最前面的几个字节，剩下的coinbase数据字段内容可以由矿工随意填写。例如，著名的比特币创世区块上，中本聪写下了如下文字：“The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”。现在，矿工一般在coinbase数据字段写入其所在矿池的名字。 挖矿成功后，矿工可以得到多少奖励呢？两部分，区块奖励+手续费。上面的例子中，矿工奖励总数25.09094928枚比特币，其中包含25个比特币的区块奖励和0.09094928个比特币的手续费。比特币区块链每生成210000个区块，约4年时间，区块奖励减半（参数nSubsidyHalvingInterval，见src/chainparam.cpp中）。到2140年，区块奖励将归零，矿工的激励将只剩交易手续费。 CAmount GetBlockSubsidy(int nHeight, const Consensus::Params&amp; consensusParams) { int halvings = nHeight / consensusParams.nSubsidyHalvingInterval; // Force block reward to zero when right shift is undefined. if (halvings &gt;= 64) return 0; CAmount nSubsidy = 50 * COIN; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. nSubsidy &gt;&gt;= halvings; return nSubsidy; } Coinbase交易生成后，剩下的工作就是将待确认的交易组织起来，生成一棵Merkle树作为交易摘要写进区块277316。交易打包到Merkle Tree过程详见本系列第一篇文章比特币源码阅读笔记【基础篇】。最终生成一个候选区块，格式如下所示。 $ bitcoin-cli getblockhash 277316 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 $ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 { &quot;hash&quot; : &quot;0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4&quot;, &quot;size&quot; : 218629, &quot;height&quot; : 277316, &quot;version&quot; : 2, &quot;merkleroot&quot; : &quot;c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e&quot;, &quot;tx&quot;:[ &quot;d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f&quot;, &quot;b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe&quot;, ... 后面交易省略 ... ], &quot;time&quot; : 1388185914, &quot;nonce&quot; : 924591752, &quot;bits&quot; : &quot;1903a30c&quot;, &quot;difficulty&quot; : 1180923195.25802612, &quot;chainwork&quot; : &quot;000000000000000000000000000000000000000000000934695e92aaf53afa1a&quot;, &quot;previousblockhash&quot; : &quot;0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569&quot; } 1.2.2 区块目标难度 比特币的区块链结构主要有两层哈希，第一层是在区块的链结构上，每个区块header都包含一个哈希指针，指向前一个区块；第二层是在每一个区块内，区块内部打包的所有交易用Merkle树组织起来，如下图所示 回顾下区块header的结构： version 软件/协议版本号 previous block hash 父区块的哈希值 merkle root 当前区块交易信息摘要值 timestamp 区块创建时间 target 当前区块的工作量证明算法目标值 nonce 工作量证明算法的计数器 version，软件版本号，由当前客户端版本决定；父区块哈希值prevHash，由该节点可以获取的最新区块决定；区块创建时间timestamp，即矿工节点的时间戳；这三个参数没有太多可以解释的内容。 后面三个参数：PoW目标值target，计数器nonce，交易摘要值merkle root是达成共识的关键。 什么是目标，什么又是目标难度呢？目标是比特币网络中所有矿工节点一起计算的那道题目，题目的格式为: 找到一个区块，它的header哈希值小于0000000000000000029AB9000000000000000000000000000000000000000000。这个题目就是下一个区块的挖矿目标，而这个数值0000000000000000029AB9000000000000000000000000000000000000000000就是所谓的目标难度。那么上面例子中的哈希计算有多难呢？网络中的一个节点如果想求出这个哈希值，平均需要进行1.8 * 10 ^ 21次哈希计算。这个难度是动态调整的，假如网络中矿工节点的计算能力都很强，那么难度将会提高。目标难度由下面的公式计算 目标 = 系数 * 2^(8 * (指数 – 3)) 根据这个公式，假如难度位取值是0x1903a30c, 我们可以得到目标值： 目标 = 0x03a30c * 2^(0x08 * (0x19 - 0x03))^ =&gt; 目标 = 0x03a30c * 2^(0x08 * 0x16)^ =&gt; 目标 = 0x03a30c * 2^0xB0^ 用十进制表示: =&gt; 目标 = 238,348 * 2^176^ =&gt; 目标 = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328 切换回十六进制表示: =&gt; 目标 = 0x0000000000000003A30C00000000000000000000000000000000000000000000 我们可以看到，哈希目标决定了求解PoW的时间。为什么要调整难度呢，谁在调整难度，又是如何调整难度呢？ 首先，比特币平均每10分钟生成一个区块，这是比特币的基础设定。比特币区块产生速率不仅需要短期保持恒定，而且需要维持多年。在这个过程中，计算机的算力将持续提升，加入挖矿的计算机也将持续变化，不管外部条件如何改变，比特币区块生成时间都将动态地调整到10分钟。在出块时间上保持稳定是一种聪明的设计，2100万个比特币，在2140年全部挖矿得出，这个社会学实验周期在100年以上，无论是成功还是失败，过程中的起起伏伏已经是极佳的社会学实验案例。 完全去中心化的网络中如何完成难度调整呢？我们可以在链参数定义的源代码chainparams.cpp中找到参数：nPowTargetTimespan=14*24*60*60，两周调整一次PoW难度。按每10分钟产生一个区块计算，两周产生(14*24*60*60)/(10*60)=2016个区块，也就是每产生2016个区块调整一次难度。 class CMainParams : public CChainParams { public: CMainParams() { strNetworkID = &quot;main&quot;; consensus.nSubsidyHalvingInterval = 210000; // 省略部分参数 consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks consensus.nPowTargetSpacing = 10 * 60; consensus.fPowAllowMinDifficultyBlocks = false; consensus.fPowNoRetargeting = false; consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016 consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing // 隔离见证 (BIP141, BIP143, and BIP147) consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1; consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1479168000; // November 15th, 2016. consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1510704000; // November 15th, 2017. // The best chain should have at least this much work. consensus.nMinimumChainWork = uint256S(&quot;0x000000000000000000000000000000000000000000723d3581fe1bd55373540a&quot;); } }; 调整难度的时候会评估最后产生的2016个区块的时间，与2016 * 10分钟做比较，实际时间除以预期时间的比例决定了下一次的目标难度。重新定义哈希值目标的公式为： 新目标 = 旧目标 * (产出过去2016个区块的时间 / 20160 分钟) 计算下次PoW工作量(目标难度)的代码，见src/pow.cpp中的CalculateNextWorkRequired函数： unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params) { if (params.fPowNoRetargeting) return pindexLast-&gt;nBits; // Limit adjustment step int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime; if (nActualTimespan &lt; params.nPowTargetTimespan/4) nActualTimespan = params.nPowTargetTimespan/4; if (nActualTimespan &gt; params.nPowTargetTimespan*4) nActualTimespan = params.nPowTargetTimespan*4; // Retarget const arith_uint256 bnPowLimit = UintToArith256(params.powLimit); arith_uint256 bnNew; bnNew.SetCompact(pindexLast-&gt;nBits); bnNew *= nActualTimespan; bnNew /= params.nPowTargetTimespan; if (bnNew &gt; bnPowLimit) bnNew = bnPowLimit; return bnNew.GetCompact(); } 1.2.3 PoW 工作量证明 我们可以用下面的Python代码表示工作量证明的计算过程，两层循环尝试merkle root和nonce, 生成一个区块；将区块和目标难度输入PoW算法进行验证，哈希值满足难度target要求则验证通过，见下面Python代码第37行。 #!/usr/bin/env python # example of proof-of-work algorithm import hashlib import time max_nonce = 2 ** 32 # 4 billion def proof_of_work(header, difficulty_bits): # calculate the difficulty target target = 2 ** (256-difficulty_bits) for nonce in xrange(max_nonce): hash_result = hashlib.sha256(str(header)+str(nonce)).hexdigest() # check if this is a valid result, below the target if long(hash_result, 16) &lt; target: print &quot;Success with nonce %d&quot; % nonce print &quot;Hash is %s&quot; % hash_result return (hash_result,nonce) print &quot;Failed after %d (max_nonce) tries&quot; % nonce return nonce if __name__ == &#39;__main__&#39;: nonce = 0 hash_result = &#39;&#39; # difficulty from 0 to 31 bits for difficulty_bits in xrange(32): difficulty = 2 ** difficulty_bits print &quot;Difficulty: %ld (%d bits)&quot; % (difficulty, difficulty_bits) print &quot;Starting search...&quot; # checkpoint the current time start_time = time.time() # make a new block which includes the hash from the previous block # we fake a block of transactions - just a string new_block = &#39;test block with transactions&#39; + hash_result # find a valid nonce for the new block (hash_result, nonce) = proof_of_work(new_block, difficulty_bits) # checkpoint how long it took to find a result end_time = time.time() elapsed_time = end_time - start_time print &quot;Elapsed Time: %.4f seconds&quot; % elapsed_time if elapsed_time &gt; 0: # estimate the hashes per second hash_power = float(long(nonce)/elapsed_time) print &quot;Hashing Power: %ld hashes per second&quot; % hash_power 每个矿工的谜题都是一样的吗？不，原因主要有几点： 网络状态决定了不同节点的账本状态不能做到全部一致；不同矿工节点的上一个区块不会完全相同；一方面是高度可能不一致，另一方面是节点可能选择相同高度的不同区块。 不同节点打包的UTXO列表，内容和顺序不相同。与区块高度相比，这项区别更为明显。 矿工之间的公钥签名不同，除非共享公钥（加入同一个矿池） 1.3 组装到链 下一步是矿工独立地将区块组装到区块链。每个矿工节点基于PoW算法，独立选择计算工作量最大的链，并将交易组装进链。 比特币分布式共识机制的最后一步就是将区块组装到链并选择最多工作量的链。一旦一个节点验证了一个新的区块，它将会尝试把这个区块组装到现有的链中。节点维护了三个区块集合： 链到主链中的区块 链到主链分支中的区块 没有已知父节点的区块，叫做孤块。 上述三种区块都必须通过交易验证和区块验证，而验证失败的区块会被抛弃，不会向网络中其他节点转发。主链指的是在一个时刻拥有最多累积工作量的链，大多数情况下主链就是拥有最多区块的链，除非此刻有两条长度相同的链，其中一条拥有更多的累积工作量。主链还会维护分支链用于未来引用，因为分支链有可能得到更多的后续区块从而成为新的主链。当矿工挖出新区块时，该节点通过选择扩展哪条链来投票。我们不用担心部分矿工故意选择工作量更少的链，因为多数矿工会选择工作量最多的链，而工作量较少的链会被彻底放弃。打个比方，超市收银台有多个结账窗口，只有排队人数最多的收银台可以结账。这时候为了结账，矿工只能选择最长的队伍排队，因为短队伍意味着不会得到结账机会。 1.4 孤块 如果收到了一个合法区块，但是没有在主链和分支链中发现该区块的父区块，那么这个区块就叫做孤块。因为孤块是合法的区块，只是没有找到父区块，所以孤块也会被节点保存下来，存储在孤块池中，直到找到它的父区块。一旦找到了父区块，孤块就离开孤块池，链到已经存在的链上。一般来说，两个区块在很短时间内产生，并且被其他节点接收的顺序刚好和产生顺序相反才会出现孤块，孤块是一种临时现象。 二、分叉 2.1 分叉 因为区块链是一个分布式的数据结构，所以不同的副本不会永远一致。区块可能在不同时间到达不同的节点，造成各个节点拥有不同的区块链视角。为了解决这个问题，每个节点选择承认并扩展一条最多工作量的链。只要所有节点都选择最多累积工作量的链，那么比特币网络将最终收敛到一致状态。节点之间区块链版本不一致的状态称作分叉，一般来说分叉只是一种临时状态，当出现更多区块的链时，网络节点会达成新的一致状态。下面我们解释一下网络分叉和合并的过程。 下图中蓝色的圈代表比特币矿工节点，黑色的线代表节点之间的网络连接关系，五角星代表最新的一个区块。假设初始状态时所有节点的最新区块都是这个五角星。 下一时刻，节点X和节点Y几乎同时挖矿得到了两个不同的区块，节点X挖出了米白色的正三角形，节点Y挖出了橙色的倒三角形，两个区块被X和Y各自追加在五角星后面，并开始向各自连接的矿工节点广播，见图中的红色箭头。收到节点X挖出三角形区块的节点将三角形区块追加到自己的区块链上，同样地，收到节点Y挖出倒三角形区块的节点将倒三角形区块追加到自己的区块链上，这时候，比特币网络产生了临时的分叉。 随着节点在网络中同步区块数据，每个节点都会收到两个合法的区块，两个区块都会存在于该节点维护的区块链上。 这时候，一个矿工节点挖出了新的区块–绿色方块，这个矿工选择将绿色区块连接在米白色三角形之后，并向网络中传播。随着绿色区块的传播，当绿色区块传播到节点Y的时候，节点Y将绿色区块追加在米白色的区块之后。这里比较有趣，虽然节点Y挖出了橙色的区块，但是当它收到绿色区块后依然需要把绿色区块追加在米白色区块上，而不能忽略绿色区块。这是游戏规则。 假如矿工有能力修改挖矿策略，形成了一批破坏者，只保留向自己挖出的区块追加的块，丢弃其他节点。这种情况会发生什么呢？短期来看，比特币网络节点行成了两派，各自维护自己的区块，如果两派区块链都继续沿着各自路线前进，并且都有其支持者，那么比特币将分裂成两种币。 回到游戏规则中来，节点Y需要追加绿色区块到节点X挖出的米白色三角形后面，随着网络节点同步区块的进行，“五角星-米白色三角形-绿色方块”这条链成为拥有最多累计工作量的区块链，成为主链。在比特币的世界里橙色的区块很悲剧，只能认赔，什么也得不到。这时候比特币网络再次成为统一状态。 顺便提一句，在以太坊的世界里，橙色的区块称为叔块，如果叔块得到确认还可以得到奖励，称为叔块奖励。造成这种现象的原因是，比特币的出块时间是固定的10分钟，而以太坊的出块时间是变化的，大体出块时间如下： 在第 4000000个区块，总的以太币数量大约是 93262556，时间大约是 2017-08-15 区块时间为 30.01秒。 在第 4500000个区块，总的以太币数量大约是 95912556，时间大约是 2018-11-03 区块时间为 136.71秒。 在第 5000000个区块，总的以太币数量大约是 98562556，时间大约是 2025-10-02 区块时间为 835.81秒。 现阶段以太坊的出块时间只有30秒，相比于10分钟很短。网络传输过程中，由于种种因素，会出现网络孤岛，叔块比例会远高于比特币的场景。为了弥补这些矿工的损失，以太坊设立了叔块奖励，详见幽灵协议（Greedy Heaviest-Observed Sub-Tree, 简写为GHOST)。 2.2 隔离见证 2017年初，比特币社区发生了一场大的变革，其中几个关键词就是：隔离见证，区块扩容，闪电网络。它们出现的原因都是为了解决比特币网络交易拥堵的问题，只是技术路线出现了分歧。矿工为首的一派的意见是扩容区块，而比特币Core团队坚持1MB区块大小，双方互不妥协，最终比特币分叉成了两种币，BTC和BCH。 隔离见证是指一种比特币架构修改方案，它会影响到比特币的扩展性、安全性、性能和经济激励等多个方面。隔离见证方案的原文可以查看以下几篇BIP: BIP-141 隔离见证的主要定义 BIP-143 交易签名验证–第0版 BIP-144 Peer Services—-新的网络消息和序列化格式 BIP-145 隔离见证的getblocktemplate更新 (适用于挖矿) 鉴于篇幅所限，本篇文章不再展开比特币扩容问题。感兴趣的读者敬请期待–比特币源码阅读笔记【扩容篇】。 三、参考资料 Mastering BitCoin 普林斯顿大学公开课 巴比特论坛 阅读更多" />
<meta property="og:description" content="比特币源码阅读笔记【共识篇】 这篇文章总结下比特币挖矿和共识相关内容。 一、挖矿和共识 挖矿这个词可能让一部分人误解了比特币矿工。矿工的工作，主要是验证交易和打包区块，而得到的比特币奖励和手续费是一种激励手段和“副产品”。比特币的挖矿是比特币P2P网络节点各自独立发生的四个过程的相互作用的结果： 完整区块链节点，基于一串规则独立验证每笔交易； 矿工节点独立打包交易成为新的区块；通过工作量证明算法（Proof-of-work, 简写为PoW）证明你的计算工作量后产生新的区块； 每个节点独立验证新的区块，组装到链中； 每个节点基于PoW算法，独立选择工作量最大的链； 1.1 独立验证 前文提到过，比特币系统设计中没有账户余额，取而代之的是历史交易记录，比特币完整节点可以通过历史交易记录计算得到UTXO。当比特币钱包“收到”比特币时，实际发生的是钱包检测到UTXO池中存在该钱包私钥可以花费的UTXO。因此，用户的比特币“余额”实际是用户钱包可以花费的所有UTXO的和，而这个值需要从很多区块、很多交易记录中汇总得到。余额的概念存在于钱包，但不存在于区块链。 1.1.1 验证交易 首先回顾一下交易结构，一笔交易的输入包含以下信息： Transaction Hash 哈希指针，指向包含被花费UTXO的交易 Output Index 被花费的UTXO的索引 Unlocking-Script Size 解锁脚本的大小（字节数） Unlocking-Script 完成了UTXO加锁脚本条件的解锁脚本 Sequence Number 用于locktime，取值0xFFFFFFFF表示禁用 交易的输入需要有一个哈希指针，指向即将在交易中花费的UTXO。节点在向邻居节点转发交易前，会首先独立验证交易，只有符合一系列条件的交易才会在比特币网络向新的节点进行传播。矿工独立验证交易的内容，一部分内容是验证UTXO是否合法（防止双重支付），另一部分就是验证交易脚本是否有权限花费这些UTXO（验证签名）。验证交易输入的代码主要在以下几个函数中：AcceptToMemoryPool, Check Transaction, CheckInputs。 bool CheckInputs(const CTransaction&amp; tx, CValidationState &amp;state, const CCoinsViewCache &amp;inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData&amp; txdata, std::vector&lt;CScriptCheck&gt; *pvChecks) { if (!tx.IsCoinBase()) { if (pvChecks) pvChecks-&gt;reserve(tx.vin.size()); if (fScriptChecks) { // 此处省略部分代码 for (unsigned int i = 0; i &lt; tx.vin.size(); i++) { // 1. 验证UTXO，防止双重支付 const COutPoint &amp;prevout = tx.vin[i].prevout; const Coin&amp; coin = inputs.AccessCoin(prevout); assert(!coin.IsSpent()); // 2. 验证签名，确认所有权 CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &amp;txdata); if (pvChecks) { pvChecks-&gt;push_back(CScriptCheck()); check.swap(pvChecks-&gt;back()); } else if (!check()) { if (flags &amp; STANDARD_NOT_MANDATORY_VERIFY_FLAGS) { CScriptCheck check2(coin.out, tx, i, flags &amp; ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &amp;txdata); if (check2()) return state.Invalid(false, REJECT_NONSTANDARD, strprintf(&quot;non-mandatory-script-verify-flag (%s)&quot;, ScriptErrorString(check.GetScriptError()))); } return state.DoS(100,false, REJECT_INVALID, strprintf(&quot;mandatory-script-verify-flag-failed (%s)&quot;, ScriptErrorString(check.GetScriptError()))); } } if (cacheFullScriptStore &amp;&amp; !pvChecks) { scriptExecutionCache.insert(hashCacheEntry); } } } return true; } 矿工会将通过验证的交易放入内存（代码见AcceptToMemoryPool），在进行工作量证明计算并赢得记账权后，将上述交易打包到区块中。 static bool AcceptToMemoryPoolWorker(const CChainParams&amp; chainparams, CTxMemPool&amp; pool, CValidationState&amp; state, const CTransactionRef&amp; ptx, bool* pfMissingInputs, int64_t nAcceptTime, std::list&lt;CTransactionRef&gt;* plTxnReplaced, bool bypass_limits, const CAmount&amp; nAbsurdFee, std::vector&lt;COutPoint&gt;&amp; coins_to_uncache) { // 此处省略部分代码 GetMainSignals().TransactionAddedToMempool(ptx); return true; } 1.1.2 验证区块 1.2 独立打包区块 假设矿工的名字是Jing。在Alice付给Bob比特币购买咖啡时，Jing的节点组装了一条区块链，高度是277314。Jing的节点持续监听网络中的交易，也持续监听其他节点发现的新区块。突然Jing的节点在网络中发现了区块277315，这时候对应区块277315的算力竞赛宣告结束，同时开启了对应区块277316的算力竞赛。 在Jing的节点搜索区块277315的答案的时候，它同时收集了许多通过验证的交易，并把这些通过验证的交易放到了内存池中。一旦收到区块277315并且完成了验证，Jing的节点会比较内存池中的所有交易，删除区块277315中包含的交易。内存池中剩下的交易记录可以继续保留，等待下一次的交易打包。 Jing 的节点立刻创建一个空区块，称为候选区块277316。一旦候选区块在工作量证明算法中胜出，这个候选区块就成为了合法区块。回顾下区块的结构，比特币区块主要包含四个字段：prevHash, nonce, Merkle Root和timestamp。 构成区块的过程主要分成两个部分：1. 汇总交易，生成交易摘要Merkle Root哈希值 2. 加入随机数nonce，生成区块header，并验证区块header是否满足上个区块的设定的目标值； 1.2.1 Coinbase交易 每个区块的第一笔交易叫做Coinbase交易。Coinbase交易是一笔特殊交易，因为它包含了挖矿奖励。和普通交易不同，coinbase交易的输入不包含UTXO，而是输入一个coinbase值，用于凭空创造比特币。Coinbase交易有一个输出，向矿工的比特币地址支付比特币。 我们可以通过命令bitcoin-cli getrawtransaction查看coinbase。 $ bitcoin-cli getrawtransaction d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f 1 { &quot;hex&quot;: &quot;01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff6 f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000 &quot;, &quot;txid&quot;: &quot;d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f&quot;, &quot;version&quot;: 1, &quot;locktime&quot;: 0, &quot;vin&quot;: [{ &quot;coinbase&quot;: &quot;03443b0403858402062f503253482f&quot;, &quot;sequence&quot;: 4294967295 }], &quot;vout&quot;: [{ &quot;value&quot;: 25.09094928, &quot;n&quot;: 0, &quot;scriptPubKey&quot;: { &quot;asm&quot;: &quot;02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG&quot;, &quot;hex&quot;: &quot;2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac&quot;, &quot;reqSigs&quot;: 1, &quot;type&quot;: &quot;pubkey&quot;, &quot;addresses&quot;: [ &quot;1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N&quot; ] } }] } Coinbase交易不包含解锁脚本字段（即scriptSig），取代它的是coinbase数据字段，其大小限制为2至100个字节。除了最前面的几个字节，剩下的coinbase数据字段内容可以由矿工随意填写。例如，著名的比特币创世区块上，中本聪写下了如下文字：“The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”。现在，矿工一般在coinbase数据字段写入其所在矿池的名字。 挖矿成功后，矿工可以得到多少奖励呢？两部分，区块奖励+手续费。上面的例子中，矿工奖励总数25.09094928枚比特币，其中包含25个比特币的区块奖励和0.09094928个比特币的手续费。比特币区块链每生成210000个区块，约4年时间，区块奖励减半（参数nSubsidyHalvingInterval，见src/chainparam.cpp中）。到2140年，区块奖励将归零，矿工的激励将只剩交易手续费。 CAmount GetBlockSubsidy(int nHeight, const Consensus::Params&amp; consensusParams) { int halvings = nHeight / consensusParams.nSubsidyHalvingInterval; // Force block reward to zero when right shift is undefined. if (halvings &gt;= 64) return 0; CAmount nSubsidy = 50 * COIN; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. nSubsidy &gt;&gt;= halvings; return nSubsidy; } Coinbase交易生成后，剩下的工作就是将待确认的交易组织起来，生成一棵Merkle树作为交易摘要写进区块277316。交易打包到Merkle Tree过程详见本系列第一篇文章比特币源码阅读笔记【基础篇】。最终生成一个候选区块，格式如下所示。 $ bitcoin-cli getblockhash 277316 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 $ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 { &quot;hash&quot; : &quot;0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4&quot;, &quot;size&quot; : 218629, &quot;height&quot; : 277316, &quot;version&quot; : 2, &quot;merkleroot&quot; : &quot;c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e&quot;, &quot;tx&quot;:[ &quot;d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f&quot;, &quot;b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe&quot;, ... 后面交易省略 ... ], &quot;time&quot; : 1388185914, &quot;nonce&quot; : 924591752, &quot;bits&quot; : &quot;1903a30c&quot;, &quot;difficulty&quot; : 1180923195.25802612, &quot;chainwork&quot; : &quot;000000000000000000000000000000000000000000000934695e92aaf53afa1a&quot;, &quot;previousblockhash&quot; : &quot;0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569&quot; } 1.2.2 区块目标难度 比特币的区块链结构主要有两层哈希，第一层是在区块的链结构上，每个区块header都包含一个哈希指针，指向前一个区块；第二层是在每一个区块内，区块内部打包的所有交易用Merkle树组织起来，如下图所示 回顾下区块header的结构： version 软件/协议版本号 previous block hash 父区块的哈希值 merkle root 当前区块交易信息摘要值 timestamp 区块创建时间 target 当前区块的工作量证明算法目标值 nonce 工作量证明算法的计数器 version，软件版本号，由当前客户端版本决定；父区块哈希值prevHash，由该节点可以获取的最新区块决定；区块创建时间timestamp，即矿工节点的时间戳；这三个参数没有太多可以解释的内容。 后面三个参数：PoW目标值target，计数器nonce，交易摘要值merkle root是达成共识的关键。 什么是目标，什么又是目标难度呢？目标是比特币网络中所有矿工节点一起计算的那道题目，题目的格式为: 找到一个区块，它的header哈希值小于0000000000000000029AB9000000000000000000000000000000000000000000。这个题目就是下一个区块的挖矿目标，而这个数值0000000000000000029AB9000000000000000000000000000000000000000000就是所谓的目标难度。那么上面例子中的哈希计算有多难呢？网络中的一个节点如果想求出这个哈希值，平均需要进行1.8 * 10 ^ 21次哈希计算。这个难度是动态调整的，假如网络中矿工节点的计算能力都很强，那么难度将会提高。目标难度由下面的公式计算 目标 = 系数 * 2^(8 * (指数 – 3)) 根据这个公式，假如难度位取值是0x1903a30c, 我们可以得到目标值： 目标 = 0x03a30c * 2^(0x08 * (0x19 - 0x03))^ =&gt; 目标 = 0x03a30c * 2^(0x08 * 0x16)^ =&gt; 目标 = 0x03a30c * 2^0xB0^ 用十进制表示: =&gt; 目标 = 238,348 * 2^176^ =&gt; 目标 = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328 切换回十六进制表示: =&gt; 目标 = 0x0000000000000003A30C00000000000000000000000000000000000000000000 我们可以看到，哈希目标决定了求解PoW的时间。为什么要调整难度呢，谁在调整难度，又是如何调整难度呢？ 首先，比特币平均每10分钟生成一个区块，这是比特币的基础设定。比特币区块产生速率不仅需要短期保持恒定，而且需要维持多年。在这个过程中，计算机的算力将持续提升，加入挖矿的计算机也将持续变化，不管外部条件如何改变，比特币区块生成时间都将动态地调整到10分钟。在出块时间上保持稳定是一种聪明的设计，2100万个比特币，在2140年全部挖矿得出，这个社会学实验周期在100年以上，无论是成功还是失败，过程中的起起伏伏已经是极佳的社会学实验案例。 完全去中心化的网络中如何完成难度调整呢？我们可以在链参数定义的源代码chainparams.cpp中找到参数：nPowTargetTimespan=14*24*60*60，两周调整一次PoW难度。按每10分钟产生一个区块计算，两周产生(14*24*60*60)/(10*60)=2016个区块，也就是每产生2016个区块调整一次难度。 class CMainParams : public CChainParams { public: CMainParams() { strNetworkID = &quot;main&quot;; consensus.nSubsidyHalvingInterval = 210000; // 省略部分参数 consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks consensus.nPowTargetSpacing = 10 * 60; consensus.fPowAllowMinDifficultyBlocks = false; consensus.fPowNoRetargeting = false; consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016 consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing // 隔离见证 (BIP141, BIP143, and BIP147) consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1; consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1479168000; // November 15th, 2016. consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1510704000; // November 15th, 2017. // The best chain should have at least this much work. consensus.nMinimumChainWork = uint256S(&quot;0x000000000000000000000000000000000000000000723d3581fe1bd55373540a&quot;); } }; 调整难度的时候会评估最后产生的2016个区块的时间，与2016 * 10分钟做比较，实际时间除以预期时间的比例决定了下一次的目标难度。重新定义哈希值目标的公式为： 新目标 = 旧目标 * (产出过去2016个区块的时间 / 20160 分钟) 计算下次PoW工作量(目标难度)的代码，见src/pow.cpp中的CalculateNextWorkRequired函数： unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params) { if (params.fPowNoRetargeting) return pindexLast-&gt;nBits; // Limit adjustment step int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime; if (nActualTimespan &lt; params.nPowTargetTimespan/4) nActualTimespan = params.nPowTargetTimespan/4; if (nActualTimespan &gt; params.nPowTargetTimespan*4) nActualTimespan = params.nPowTargetTimespan*4; // Retarget const arith_uint256 bnPowLimit = UintToArith256(params.powLimit); arith_uint256 bnNew; bnNew.SetCompact(pindexLast-&gt;nBits); bnNew *= nActualTimespan; bnNew /= params.nPowTargetTimespan; if (bnNew &gt; bnPowLimit) bnNew = bnPowLimit; return bnNew.GetCompact(); } 1.2.3 PoW 工作量证明 我们可以用下面的Python代码表示工作量证明的计算过程，两层循环尝试merkle root和nonce, 生成一个区块；将区块和目标难度输入PoW算法进行验证，哈希值满足难度target要求则验证通过，见下面Python代码第37行。 #!/usr/bin/env python # example of proof-of-work algorithm import hashlib import time max_nonce = 2 ** 32 # 4 billion def proof_of_work(header, difficulty_bits): # calculate the difficulty target target = 2 ** (256-difficulty_bits) for nonce in xrange(max_nonce): hash_result = hashlib.sha256(str(header)+str(nonce)).hexdigest() # check if this is a valid result, below the target if long(hash_result, 16) &lt; target: print &quot;Success with nonce %d&quot; % nonce print &quot;Hash is %s&quot; % hash_result return (hash_result,nonce) print &quot;Failed after %d (max_nonce) tries&quot; % nonce return nonce if __name__ == &#39;__main__&#39;: nonce = 0 hash_result = &#39;&#39; # difficulty from 0 to 31 bits for difficulty_bits in xrange(32): difficulty = 2 ** difficulty_bits print &quot;Difficulty: %ld (%d bits)&quot; % (difficulty, difficulty_bits) print &quot;Starting search...&quot; # checkpoint the current time start_time = time.time() # make a new block which includes the hash from the previous block # we fake a block of transactions - just a string new_block = &#39;test block with transactions&#39; + hash_result # find a valid nonce for the new block (hash_result, nonce) = proof_of_work(new_block, difficulty_bits) # checkpoint how long it took to find a result end_time = time.time() elapsed_time = end_time - start_time print &quot;Elapsed Time: %.4f seconds&quot; % elapsed_time if elapsed_time &gt; 0: # estimate the hashes per second hash_power = float(long(nonce)/elapsed_time) print &quot;Hashing Power: %ld hashes per second&quot; % hash_power 每个矿工的谜题都是一样的吗？不，原因主要有几点： 网络状态决定了不同节点的账本状态不能做到全部一致；不同矿工节点的上一个区块不会完全相同；一方面是高度可能不一致，另一方面是节点可能选择相同高度的不同区块。 不同节点打包的UTXO列表，内容和顺序不相同。与区块高度相比，这项区别更为明显。 矿工之间的公钥签名不同，除非共享公钥（加入同一个矿池） 1.3 组装到链 下一步是矿工独立地将区块组装到区块链。每个矿工节点基于PoW算法，独立选择计算工作量最大的链，并将交易组装进链。 比特币分布式共识机制的最后一步就是将区块组装到链并选择最多工作量的链。一旦一个节点验证了一个新的区块，它将会尝试把这个区块组装到现有的链中。节点维护了三个区块集合： 链到主链中的区块 链到主链分支中的区块 没有已知父节点的区块，叫做孤块。 上述三种区块都必须通过交易验证和区块验证，而验证失败的区块会被抛弃，不会向网络中其他节点转发。主链指的是在一个时刻拥有最多累积工作量的链，大多数情况下主链就是拥有最多区块的链，除非此刻有两条长度相同的链，其中一条拥有更多的累积工作量。主链还会维护分支链用于未来引用，因为分支链有可能得到更多的后续区块从而成为新的主链。当矿工挖出新区块时，该节点通过选择扩展哪条链来投票。我们不用担心部分矿工故意选择工作量更少的链，因为多数矿工会选择工作量最多的链，而工作量较少的链会被彻底放弃。打个比方，超市收银台有多个结账窗口，只有排队人数最多的收银台可以结账。这时候为了结账，矿工只能选择最长的队伍排队，因为短队伍意味着不会得到结账机会。 1.4 孤块 如果收到了一个合法区块，但是没有在主链和分支链中发现该区块的父区块，那么这个区块就叫做孤块。因为孤块是合法的区块，只是没有找到父区块，所以孤块也会被节点保存下来，存储在孤块池中，直到找到它的父区块。一旦找到了父区块，孤块就离开孤块池，链到已经存在的链上。一般来说，两个区块在很短时间内产生，并且被其他节点接收的顺序刚好和产生顺序相反才会出现孤块，孤块是一种临时现象。 二、分叉 2.1 分叉 因为区块链是一个分布式的数据结构，所以不同的副本不会永远一致。区块可能在不同时间到达不同的节点，造成各个节点拥有不同的区块链视角。为了解决这个问题，每个节点选择承认并扩展一条最多工作量的链。只要所有节点都选择最多累积工作量的链，那么比特币网络将最终收敛到一致状态。节点之间区块链版本不一致的状态称作分叉，一般来说分叉只是一种临时状态，当出现更多区块的链时，网络节点会达成新的一致状态。下面我们解释一下网络分叉和合并的过程。 下图中蓝色的圈代表比特币矿工节点，黑色的线代表节点之间的网络连接关系，五角星代表最新的一个区块。假设初始状态时所有节点的最新区块都是这个五角星。 下一时刻，节点X和节点Y几乎同时挖矿得到了两个不同的区块，节点X挖出了米白色的正三角形，节点Y挖出了橙色的倒三角形，两个区块被X和Y各自追加在五角星后面，并开始向各自连接的矿工节点广播，见图中的红色箭头。收到节点X挖出三角形区块的节点将三角形区块追加到自己的区块链上，同样地，收到节点Y挖出倒三角形区块的节点将倒三角形区块追加到自己的区块链上，这时候，比特币网络产生了临时的分叉。 随着节点在网络中同步区块数据，每个节点都会收到两个合法的区块，两个区块都会存在于该节点维护的区块链上。 这时候，一个矿工节点挖出了新的区块–绿色方块，这个矿工选择将绿色区块连接在米白色三角形之后，并向网络中传播。随着绿色区块的传播，当绿色区块传播到节点Y的时候，节点Y将绿色区块追加在米白色的区块之后。这里比较有趣，虽然节点Y挖出了橙色的区块，但是当它收到绿色区块后依然需要把绿色区块追加在米白色区块上，而不能忽略绿色区块。这是游戏规则。 假如矿工有能力修改挖矿策略，形成了一批破坏者，只保留向自己挖出的区块追加的块，丢弃其他节点。这种情况会发生什么呢？短期来看，比特币网络节点行成了两派，各自维护自己的区块，如果两派区块链都继续沿着各自路线前进，并且都有其支持者，那么比特币将分裂成两种币。 回到游戏规则中来，节点Y需要追加绿色区块到节点X挖出的米白色三角形后面，随着网络节点同步区块的进行，“五角星-米白色三角形-绿色方块”这条链成为拥有最多累计工作量的区块链，成为主链。在比特币的世界里橙色的区块很悲剧，只能认赔，什么也得不到。这时候比特币网络再次成为统一状态。 顺便提一句，在以太坊的世界里，橙色的区块称为叔块，如果叔块得到确认还可以得到奖励，称为叔块奖励。造成这种现象的原因是，比特币的出块时间是固定的10分钟，而以太坊的出块时间是变化的，大体出块时间如下： 在第 4000000个区块，总的以太币数量大约是 93262556，时间大约是 2017-08-15 区块时间为 30.01秒。 在第 4500000个区块，总的以太币数量大约是 95912556，时间大约是 2018-11-03 区块时间为 136.71秒。 在第 5000000个区块，总的以太币数量大约是 98562556，时间大约是 2025-10-02 区块时间为 835.81秒。 现阶段以太坊的出块时间只有30秒，相比于10分钟很短。网络传输过程中，由于种种因素，会出现网络孤岛，叔块比例会远高于比特币的场景。为了弥补这些矿工的损失，以太坊设立了叔块奖励，详见幽灵协议（Greedy Heaviest-Observed Sub-Tree, 简写为GHOST)。 2.2 隔离见证 2017年初，比特币社区发生了一场大的变革，其中几个关键词就是：隔离见证，区块扩容，闪电网络。它们出现的原因都是为了解决比特币网络交易拥堵的问题，只是技术路线出现了分歧。矿工为首的一派的意见是扩容区块，而比特币Core团队坚持1MB区块大小，双方互不妥协，最终比特币分叉成了两种币，BTC和BCH。 隔离见证是指一种比特币架构修改方案，它会影响到比特币的扩展性、安全性、性能和经济激励等多个方面。隔离见证方案的原文可以查看以下几篇BIP: BIP-141 隔离见证的主要定义 BIP-143 交易签名验证–第0版 BIP-144 Peer Services—-新的网络消息和序列化格式 BIP-145 隔离见证的getblocktemplate更新 (适用于挖矿) 鉴于篇幅所限，本篇文章不再展开比特币扩容问题。感兴趣的读者敬请期待–比特币源码阅读笔记【扩容篇】。 三、参考资料 Mastering BitCoin 普林斯顿大学公开课 巴比特论坛 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/06/a91b1408721c9d3bd4bac5ca797d3911.html" />
<meta property="og:url" content="https://mlh.app/2018/03/06/a91b1408721c9d3bd4bac5ca797d3911.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"比特币源码阅读笔记【共识篇】 这篇文章总结下比特币挖矿和共识相关内容。 一、挖矿和共识 挖矿这个词可能让一部分人误解了比特币矿工。矿工的工作，主要是验证交易和打包区块，而得到的比特币奖励和手续费是一种激励手段和“副产品”。比特币的挖矿是比特币P2P网络节点各自独立发生的四个过程的相互作用的结果： 完整区块链节点，基于一串规则独立验证每笔交易； 矿工节点独立打包交易成为新的区块；通过工作量证明算法（Proof-of-work, 简写为PoW）证明你的计算工作量后产生新的区块； 每个节点独立验证新的区块，组装到链中； 每个节点基于PoW算法，独立选择工作量最大的链； 1.1 独立验证 前文提到过，比特币系统设计中没有账户余额，取而代之的是历史交易记录，比特币完整节点可以通过历史交易记录计算得到UTXO。当比特币钱包“收到”比特币时，实际发生的是钱包检测到UTXO池中存在该钱包私钥可以花费的UTXO。因此，用户的比特币“余额”实际是用户钱包可以花费的所有UTXO的和，而这个值需要从很多区块、很多交易记录中汇总得到。余额的概念存在于钱包，但不存在于区块链。 1.1.1 验证交易 首先回顾一下交易结构，一笔交易的输入包含以下信息： Transaction Hash 哈希指针，指向包含被花费UTXO的交易 Output Index 被花费的UTXO的索引 Unlocking-Script Size 解锁脚本的大小（字节数） Unlocking-Script 完成了UTXO加锁脚本条件的解锁脚本 Sequence Number 用于locktime，取值0xFFFFFFFF表示禁用 交易的输入需要有一个哈希指针，指向即将在交易中花费的UTXO。节点在向邻居节点转发交易前，会首先独立验证交易，只有符合一系列条件的交易才会在比特币网络向新的节点进行传播。矿工独立验证交易的内容，一部分内容是验证UTXO是否合法（防止双重支付），另一部分就是验证交易脚本是否有权限花费这些UTXO（验证签名）。验证交易输入的代码主要在以下几个函数中：AcceptToMemoryPool, Check Transaction, CheckInputs。 bool CheckInputs(const CTransaction&amp; tx, CValidationState &amp;state, const CCoinsViewCache &amp;inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData&amp; txdata, std::vector&lt;CScriptCheck&gt; *pvChecks) { if (!tx.IsCoinBase()) { if (pvChecks) pvChecks-&gt;reserve(tx.vin.size()); if (fScriptChecks) { // 此处省略部分代码 for (unsigned int i = 0; i &lt; tx.vin.size(); i++) { // 1. 验证UTXO，防止双重支付 const COutPoint &amp;prevout = tx.vin[i].prevout; const Coin&amp; coin = inputs.AccessCoin(prevout); assert(!coin.IsSpent()); // 2. 验证签名，确认所有权 CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &amp;txdata); if (pvChecks) { pvChecks-&gt;push_back(CScriptCheck()); check.swap(pvChecks-&gt;back()); } else if (!check()) { if (flags &amp; STANDARD_NOT_MANDATORY_VERIFY_FLAGS) { CScriptCheck check2(coin.out, tx, i, flags &amp; ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &amp;txdata); if (check2()) return state.Invalid(false, REJECT_NONSTANDARD, strprintf(&quot;non-mandatory-script-verify-flag (%s)&quot;, ScriptErrorString(check.GetScriptError()))); } return state.DoS(100,false, REJECT_INVALID, strprintf(&quot;mandatory-script-verify-flag-failed (%s)&quot;, ScriptErrorString(check.GetScriptError()))); } } if (cacheFullScriptStore &amp;&amp; !pvChecks) { scriptExecutionCache.insert(hashCacheEntry); } } } return true; } 矿工会将通过验证的交易放入内存（代码见AcceptToMemoryPool），在进行工作量证明计算并赢得记账权后，将上述交易打包到区块中。 static bool AcceptToMemoryPoolWorker(const CChainParams&amp; chainparams, CTxMemPool&amp; pool, CValidationState&amp; state, const CTransactionRef&amp; ptx, bool* pfMissingInputs, int64_t nAcceptTime, std::list&lt;CTransactionRef&gt;* plTxnReplaced, bool bypass_limits, const CAmount&amp; nAbsurdFee, std::vector&lt;COutPoint&gt;&amp; coins_to_uncache) { // 此处省略部分代码 GetMainSignals().TransactionAddedToMempool(ptx); return true; } 1.1.2 验证区块 1.2 独立打包区块 假设矿工的名字是Jing。在Alice付给Bob比特币购买咖啡时，Jing的节点组装了一条区块链，高度是277314。Jing的节点持续监听网络中的交易，也持续监听其他节点发现的新区块。突然Jing的节点在网络中发现了区块277315，这时候对应区块277315的算力竞赛宣告结束，同时开启了对应区块277316的算力竞赛。 在Jing的节点搜索区块277315的答案的时候，它同时收集了许多通过验证的交易，并把这些通过验证的交易放到了内存池中。一旦收到区块277315并且完成了验证，Jing的节点会比较内存池中的所有交易，删除区块277315中包含的交易。内存池中剩下的交易记录可以继续保留，等待下一次的交易打包。 Jing 的节点立刻创建一个空区块，称为候选区块277316。一旦候选区块在工作量证明算法中胜出，这个候选区块就成为了合法区块。回顾下区块的结构，比特币区块主要包含四个字段：prevHash, nonce, Merkle Root和timestamp。 构成区块的过程主要分成两个部分：1. 汇总交易，生成交易摘要Merkle Root哈希值 2. 加入随机数nonce，生成区块header，并验证区块header是否满足上个区块的设定的目标值； 1.2.1 Coinbase交易 每个区块的第一笔交易叫做Coinbase交易。Coinbase交易是一笔特殊交易，因为它包含了挖矿奖励。和普通交易不同，coinbase交易的输入不包含UTXO，而是输入一个coinbase值，用于凭空创造比特币。Coinbase交易有一个输出，向矿工的比特币地址支付比特币。 我们可以通过命令bitcoin-cli getrawtransaction查看coinbase。 $ bitcoin-cli getrawtransaction d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f 1 { &quot;hex&quot;: &quot;01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff6 f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000 &quot;, &quot;txid&quot;: &quot;d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f&quot;, &quot;version&quot;: 1, &quot;locktime&quot;: 0, &quot;vin&quot;: [{ &quot;coinbase&quot;: &quot;03443b0403858402062f503253482f&quot;, &quot;sequence&quot;: 4294967295 }], &quot;vout&quot;: [{ &quot;value&quot;: 25.09094928, &quot;n&quot;: 0, &quot;scriptPubKey&quot;: { &quot;asm&quot;: &quot;02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG&quot;, &quot;hex&quot;: &quot;2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac&quot;, &quot;reqSigs&quot;: 1, &quot;type&quot;: &quot;pubkey&quot;, &quot;addresses&quot;: [ &quot;1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N&quot; ] } }] } Coinbase交易不包含解锁脚本字段（即scriptSig），取代它的是coinbase数据字段，其大小限制为2至100个字节。除了最前面的几个字节，剩下的coinbase数据字段内容可以由矿工随意填写。例如，著名的比特币创世区块上，中本聪写下了如下文字：“The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”。现在，矿工一般在coinbase数据字段写入其所在矿池的名字。 挖矿成功后，矿工可以得到多少奖励呢？两部分，区块奖励+手续费。上面的例子中，矿工奖励总数25.09094928枚比特币，其中包含25个比特币的区块奖励和0.09094928个比特币的手续费。比特币区块链每生成210000个区块，约4年时间，区块奖励减半（参数nSubsidyHalvingInterval，见src/chainparam.cpp中）。到2140年，区块奖励将归零，矿工的激励将只剩交易手续费。 CAmount GetBlockSubsidy(int nHeight, const Consensus::Params&amp; consensusParams) { int halvings = nHeight / consensusParams.nSubsidyHalvingInterval; // Force block reward to zero when right shift is undefined. if (halvings &gt;= 64) return 0; CAmount nSubsidy = 50 * COIN; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. nSubsidy &gt;&gt;= halvings; return nSubsidy; } Coinbase交易生成后，剩下的工作就是将待确认的交易组织起来，生成一棵Merkle树作为交易摘要写进区块277316。交易打包到Merkle Tree过程详见本系列第一篇文章比特币源码阅读笔记【基础篇】。最终生成一个候选区块，格式如下所示。 $ bitcoin-cli getblockhash 277316 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 $ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 { &quot;hash&quot; : &quot;0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4&quot;, &quot;size&quot; : 218629, &quot;height&quot; : 277316, &quot;version&quot; : 2, &quot;merkleroot&quot; : &quot;c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e&quot;, &quot;tx&quot;:[ &quot;d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f&quot;, &quot;b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe&quot;, ... 后面交易省略 ... ], &quot;time&quot; : 1388185914, &quot;nonce&quot; : 924591752, &quot;bits&quot; : &quot;1903a30c&quot;, &quot;difficulty&quot; : 1180923195.25802612, &quot;chainwork&quot; : &quot;000000000000000000000000000000000000000000000934695e92aaf53afa1a&quot;, &quot;previousblockhash&quot; : &quot;0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569&quot; } 1.2.2 区块目标难度 比特币的区块链结构主要有两层哈希，第一层是在区块的链结构上，每个区块header都包含一个哈希指针，指向前一个区块；第二层是在每一个区块内，区块内部打包的所有交易用Merkle树组织起来，如下图所示 回顾下区块header的结构： version 软件/协议版本号 previous block hash 父区块的哈希值 merkle root 当前区块交易信息摘要值 timestamp 区块创建时间 target 当前区块的工作量证明算法目标值 nonce 工作量证明算法的计数器 version，软件版本号，由当前客户端版本决定；父区块哈希值prevHash，由该节点可以获取的最新区块决定；区块创建时间timestamp，即矿工节点的时间戳；这三个参数没有太多可以解释的内容。 后面三个参数：PoW目标值target，计数器nonce，交易摘要值merkle root是达成共识的关键。 什么是目标，什么又是目标难度呢？目标是比特币网络中所有矿工节点一起计算的那道题目，题目的格式为: 找到一个区块，它的header哈希值小于0000000000000000029AB9000000000000000000000000000000000000000000。这个题目就是下一个区块的挖矿目标，而这个数值0000000000000000029AB9000000000000000000000000000000000000000000就是所谓的目标难度。那么上面例子中的哈希计算有多难呢？网络中的一个节点如果想求出这个哈希值，平均需要进行1.8 * 10 ^ 21次哈希计算。这个难度是动态调整的，假如网络中矿工节点的计算能力都很强，那么难度将会提高。目标难度由下面的公式计算 目标 = 系数 * 2^(8 * (指数 – 3)) 根据这个公式，假如难度位取值是0x1903a30c, 我们可以得到目标值： 目标 = 0x03a30c * 2^(0x08 * (0x19 - 0x03))^ =&gt; 目标 = 0x03a30c * 2^(0x08 * 0x16)^ =&gt; 目标 = 0x03a30c * 2^0xB0^ 用十进制表示: =&gt; 目标 = 238,348 * 2^176^ =&gt; 目标 = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328 切换回十六进制表示: =&gt; 目标 = 0x0000000000000003A30C00000000000000000000000000000000000000000000 我们可以看到，哈希目标决定了求解PoW的时间。为什么要调整难度呢，谁在调整难度，又是如何调整难度呢？ 首先，比特币平均每10分钟生成一个区块，这是比特币的基础设定。比特币区块产生速率不仅需要短期保持恒定，而且需要维持多年。在这个过程中，计算机的算力将持续提升，加入挖矿的计算机也将持续变化，不管外部条件如何改变，比特币区块生成时间都将动态地调整到10分钟。在出块时间上保持稳定是一种聪明的设计，2100万个比特币，在2140年全部挖矿得出，这个社会学实验周期在100年以上，无论是成功还是失败，过程中的起起伏伏已经是极佳的社会学实验案例。 完全去中心化的网络中如何完成难度调整呢？我们可以在链参数定义的源代码chainparams.cpp中找到参数：nPowTargetTimespan=14*24*60*60，两周调整一次PoW难度。按每10分钟产生一个区块计算，两周产生(14*24*60*60)/(10*60)=2016个区块，也就是每产生2016个区块调整一次难度。 class CMainParams : public CChainParams { public: CMainParams() { strNetworkID = &quot;main&quot;; consensus.nSubsidyHalvingInterval = 210000; // 省略部分参数 consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks consensus.nPowTargetSpacing = 10 * 60; consensus.fPowAllowMinDifficultyBlocks = false; consensus.fPowNoRetargeting = false; consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016 consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing // 隔离见证 (BIP141, BIP143, and BIP147) consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1; consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1479168000; // November 15th, 2016. consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1510704000; // November 15th, 2017. // The best chain should have at least this much work. consensus.nMinimumChainWork = uint256S(&quot;0x000000000000000000000000000000000000000000723d3581fe1bd55373540a&quot;); } }; 调整难度的时候会评估最后产生的2016个区块的时间，与2016 * 10分钟做比较，实际时间除以预期时间的比例决定了下一次的目标难度。重新定义哈希值目标的公式为： 新目标 = 旧目标 * (产出过去2016个区块的时间 / 20160 分钟) 计算下次PoW工作量(目标难度)的代码，见src/pow.cpp中的CalculateNextWorkRequired函数： unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params) { if (params.fPowNoRetargeting) return pindexLast-&gt;nBits; // Limit adjustment step int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime; if (nActualTimespan &lt; params.nPowTargetTimespan/4) nActualTimespan = params.nPowTargetTimespan/4; if (nActualTimespan &gt; params.nPowTargetTimespan*4) nActualTimespan = params.nPowTargetTimespan*4; // Retarget const arith_uint256 bnPowLimit = UintToArith256(params.powLimit); arith_uint256 bnNew; bnNew.SetCompact(pindexLast-&gt;nBits); bnNew *= nActualTimespan; bnNew /= params.nPowTargetTimespan; if (bnNew &gt; bnPowLimit) bnNew = bnPowLimit; return bnNew.GetCompact(); } 1.2.3 PoW 工作量证明 我们可以用下面的Python代码表示工作量证明的计算过程，两层循环尝试merkle root和nonce, 生成一个区块；将区块和目标难度输入PoW算法进行验证，哈希值满足难度target要求则验证通过，见下面Python代码第37行。 #!/usr/bin/env python # example of proof-of-work algorithm import hashlib import time max_nonce = 2 ** 32 # 4 billion def proof_of_work(header, difficulty_bits): # calculate the difficulty target target = 2 ** (256-difficulty_bits) for nonce in xrange(max_nonce): hash_result = hashlib.sha256(str(header)+str(nonce)).hexdigest() # check if this is a valid result, below the target if long(hash_result, 16) &lt; target: print &quot;Success with nonce %d&quot; % nonce print &quot;Hash is %s&quot; % hash_result return (hash_result,nonce) print &quot;Failed after %d (max_nonce) tries&quot; % nonce return nonce if __name__ == &#39;__main__&#39;: nonce = 0 hash_result = &#39;&#39; # difficulty from 0 to 31 bits for difficulty_bits in xrange(32): difficulty = 2 ** difficulty_bits print &quot;Difficulty: %ld (%d bits)&quot; % (difficulty, difficulty_bits) print &quot;Starting search...&quot; # checkpoint the current time start_time = time.time() # make a new block which includes the hash from the previous block # we fake a block of transactions - just a string new_block = &#39;test block with transactions&#39; + hash_result # find a valid nonce for the new block (hash_result, nonce) = proof_of_work(new_block, difficulty_bits) # checkpoint how long it took to find a result end_time = time.time() elapsed_time = end_time - start_time print &quot;Elapsed Time: %.4f seconds&quot; % elapsed_time if elapsed_time &gt; 0: # estimate the hashes per second hash_power = float(long(nonce)/elapsed_time) print &quot;Hashing Power: %ld hashes per second&quot; % hash_power 每个矿工的谜题都是一样的吗？不，原因主要有几点： 网络状态决定了不同节点的账本状态不能做到全部一致；不同矿工节点的上一个区块不会完全相同；一方面是高度可能不一致，另一方面是节点可能选择相同高度的不同区块。 不同节点打包的UTXO列表，内容和顺序不相同。与区块高度相比，这项区别更为明显。 矿工之间的公钥签名不同，除非共享公钥（加入同一个矿池） 1.3 组装到链 下一步是矿工独立地将区块组装到区块链。每个矿工节点基于PoW算法，独立选择计算工作量最大的链，并将交易组装进链。 比特币分布式共识机制的最后一步就是将区块组装到链并选择最多工作量的链。一旦一个节点验证了一个新的区块，它将会尝试把这个区块组装到现有的链中。节点维护了三个区块集合： 链到主链中的区块 链到主链分支中的区块 没有已知父节点的区块，叫做孤块。 上述三种区块都必须通过交易验证和区块验证，而验证失败的区块会被抛弃，不会向网络中其他节点转发。主链指的是在一个时刻拥有最多累积工作量的链，大多数情况下主链就是拥有最多区块的链，除非此刻有两条长度相同的链，其中一条拥有更多的累积工作量。主链还会维护分支链用于未来引用，因为分支链有可能得到更多的后续区块从而成为新的主链。当矿工挖出新区块时，该节点通过选择扩展哪条链来投票。我们不用担心部分矿工故意选择工作量更少的链，因为多数矿工会选择工作量最多的链，而工作量较少的链会被彻底放弃。打个比方，超市收银台有多个结账窗口，只有排队人数最多的收银台可以结账。这时候为了结账，矿工只能选择最长的队伍排队，因为短队伍意味着不会得到结账机会。 1.4 孤块 如果收到了一个合法区块，但是没有在主链和分支链中发现该区块的父区块，那么这个区块就叫做孤块。因为孤块是合法的区块，只是没有找到父区块，所以孤块也会被节点保存下来，存储在孤块池中，直到找到它的父区块。一旦找到了父区块，孤块就离开孤块池，链到已经存在的链上。一般来说，两个区块在很短时间内产生，并且被其他节点接收的顺序刚好和产生顺序相反才会出现孤块，孤块是一种临时现象。 二、分叉 2.1 分叉 因为区块链是一个分布式的数据结构，所以不同的副本不会永远一致。区块可能在不同时间到达不同的节点，造成各个节点拥有不同的区块链视角。为了解决这个问题，每个节点选择承认并扩展一条最多工作量的链。只要所有节点都选择最多累积工作量的链，那么比特币网络将最终收敛到一致状态。节点之间区块链版本不一致的状态称作分叉，一般来说分叉只是一种临时状态，当出现更多区块的链时，网络节点会达成新的一致状态。下面我们解释一下网络分叉和合并的过程。 下图中蓝色的圈代表比特币矿工节点，黑色的线代表节点之间的网络连接关系，五角星代表最新的一个区块。假设初始状态时所有节点的最新区块都是这个五角星。 下一时刻，节点X和节点Y几乎同时挖矿得到了两个不同的区块，节点X挖出了米白色的正三角形，节点Y挖出了橙色的倒三角形，两个区块被X和Y各自追加在五角星后面，并开始向各自连接的矿工节点广播，见图中的红色箭头。收到节点X挖出三角形区块的节点将三角形区块追加到自己的区块链上，同样地，收到节点Y挖出倒三角形区块的节点将倒三角形区块追加到自己的区块链上，这时候，比特币网络产生了临时的分叉。 随着节点在网络中同步区块数据，每个节点都会收到两个合法的区块，两个区块都会存在于该节点维护的区块链上。 这时候，一个矿工节点挖出了新的区块–绿色方块，这个矿工选择将绿色区块连接在米白色三角形之后，并向网络中传播。随着绿色区块的传播，当绿色区块传播到节点Y的时候，节点Y将绿色区块追加在米白色的区块之后。这里比较有趣，虽然节点Y挖出了橙色的区块，但是当它收到绿色区块后依然需要把绿色区块追加在米白色区块上，而不能忽略绿色区块。这是游戏规则。 假如矿工有能力修改挖矿策略，形成了一批破坏者，只保留向自己挖出的区块追加的块，丢弃其他节点。这种情况会发生什么呢？短期来看，比特币网络节点行成了两派，各自维护自己的区块，如果两派区块链都继续沿着各自路线前进，并且都有其支持者，那么比特币将分裂成两种币。 回到游戏规则中来，节点Y需要追加绿色区块到节点X挖出的米白色三角形后面，随着网络节点同步区块的进行，“五角星-米白色三角形-绿色方块”这条链成为拥有最多累计工作量的区块链，成为主链。在比特币的世界里橙色的区块很悲剧，只能认赔，什么也得不到。这时候比特币网络再次成为统一状态。 顺便提一句，在以太坊的世界里，橙色的区块称为叔块，如果叔块得到确认还可以得到奖励，称为叔块奖励。造成这种现象的原因是，比特币的出块时间是固定的10分钟，而以太坊的出块时间是变化的，大体出块时间如下： 在第 4000000个区块，总的以太币数量大约是 93262556，时间大约是 2017-08-15 区块时间为 30.01秒。 在第 4500000个区块，总的以太币数量大约是 95912556，时间大约是 2018-11-03 区块时间为 136.71秒。 在第 5000000个区块，总的以太币数量大约是 98562556，时间大约是 2025-10-02 区块时间为 835.81秒。 现阶段以太坊的出块时间只有30秒，相比于10分钟很短。网络传输过程中，由于种种因素，会出现网络孤岛，叔块比例会远高于比特币的场景。为了弥补这些矿工的损失，以太坊设立了叔块奖励，详见幽灵协议（Greedy Heaviest-Observed Sub-Tree, 简写为GHOST)。 2.2 隔离见证 2017年初，比特币社区发生了一场大的变革，其中几个关键词就是：隔离见证，区块扩容，闪电网络。它们出现的原因都是为了解决比特币网络交易拥堵的问题，只是技术路线出现了分歧。矿工为首的一派的意见是扩容区块，而比特币Core团队坚持1MB区块大小，双方互不妥协，最终比特币分叉成了两种币，BTC和BCH。 隔离见证是指一种比特币架构修改方案，它会影响到比特币的扩展性、安全性、性能和经济激励等多个方面。隔离见证方案的原文可以查看以下几篇BIP: BIP-141 隔离见证的主要定义 BIP-143 交易签名验证–第0版 BIP-144 Peer Services—-新的网络消息和序列化格式 BIP-145 隔离见证的getblocktemplate更新 (适用于挖矿) 鉴于篇幅所限，本篇文章不再展开比特币扩容问题。感兴趣的读者敬请期待–比特币源码阅读笔记【扩容篇】。 三、参考资料 Mastering BitCoin 普林斯顿大学公开课 巴比特论坛 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/06/a91b1408721c9d3bd4bac5ca797d3911.html","headline":"比特币源码阅读笔记【共识篇】","dateModified":"2018-03-06T00:00:00+08:00","datePublished":"2018-03-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/06/a91b1408721c9d3bd4bac5ca797d3911.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码阅读笔记【共识篇】</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="比特币源码阅读笔记共识篇">比特币源码阅读笔记【共识篇】</h1> 
  <p>这篇文章总结下比特币挖矿和共识相关内容。</p> 
  <h2 id="一挖矿和共识">一、挖矿和共识</h2> 
  <p><strong>挖矿</strong>这个词可能让一部分人误解了比特币矿工。矿工的工作，主要是验证交易和打包区块，而得到的比特币奖励和手续费是一种激励手段和“副产品”。比特币的挖矿是比特币P2P网络节点各自独立发生的四个过程的相互作用的结果：</p> 
  <ul> 
   <li>完整区块链节点，基于一串规则独立验证每笔交易；</li> 
   <li>矿工节点独立打包交易成为新的区块；通过工作量证明算法（Proof-of-work, 简写为PoW）证明你的计算工作量后产生新的区块；</li> 
   <li>每个节点独立验证新的区块，组装到链中；</li> 
   <li>每个节点基于PoW算法，独立选择工作量最大的链；</li> 
  </ul> 
  <h2 id="11-独立验证">1.1 独立验证</h2> 
  <p>前文提到过，比特币系统设计中没有账户余额，取而代之的是历史交易记录，比特币<strong>完整节点</strong>可以通过历史交易记录计算得到UTXO。当比特币钱包“收到”比特币时，实际发生的是钱包检测到UTXO池中存在该钱包私钥可以花费的UTXO。因此，用户的比特币“余额”实际是用户钱包可以花费的所有UTXO的和，而这个值需要从很多区块、很多交易记录中汇总得到。<strong>余额的概念存在于钱包，但不存在于区块链</strong>。</p> 
  <h3 id="111-验证交易">1.1.1 验证交易</h3> 
  <p>首先回顾一下交易结构，一笔交易的输入包含以下信息：</p> 
  <ul> 
   <li>Transaction Hash 哈希指针，指向包含被花费UTXO的交易</li> 
   <li>Output Index 被花费的UTXO的索引</li> 
   <li>Unlocking-Script Size 解锁脚本的大小（字节数）</li> 
   <li>Unlocking-Script 完成了UTXO加锁脚本条件的解锁脚本</li> 
   <li>Sequence Number 用于locktime，取值0xFFFFFFFF表示禁用</li> 
  </ul> 
  <p>交易的输入需要有一个哈希指针，指向即将在交易中花费的UTXO。节点在向邻居节点转发交易前，会首先独立验证交易，只有符合一系列条件的交易才会在比特币网络向新的节点进行传播。矿工独立验证交易的内容，一部分内容是验证UTXO是否合法（防止双重支付），另一部分就是验证交易脚本是否有权限花费这些UTXO（验证签名）。验证交易输入的代码主要在以下几个函数中：<code>AcceptToMemoryPool</code>, <code>Check Transaction</code>, <code>CheckInputs</code>。</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> CheckInputs(<span class="hljs-keyword">const</span> CTransaction&amp; tx, CValidationState &amp;state, <span class="hljs-keyword">const</span> CCoinsViewCache &amp;inputs, <span class="hljs-keyword">bool</span> fScriptChecks, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">bool</span> cacheSigStore, <span class="hljs-keyword">bool</span> cacheFullScriptStore, PrecomputedTransactionData&amp; txdata, <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CScriptCheck&gt;</span> *pvChecks)
{
    <span class="hljs-keyword">if</span> (!tx.IsCoinBase())
    {
        <span class="hljs-keyword">if</span> (pvChecks)
            pvChecks-&gt;reserve(tx.vin.size());

        <span class="hljs-keyword">if</span> (fScriptChecks) {
            <span class="hljs-comment">// 此处省略部分代码</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tx.vin.size(); i++) {
                <span class="hljs-comment">// 1. 验证UTXO，防止双重支付</span>
                <span class="hljs-keyword">const</span> COutPoint &amp;prevout = tx.vin[i].prevout;
                <span class="hljs-keyword">const</span> Coin&amp; coin = inputs.AccessCoin(prevout);
                assert(!coin.IsSpent());
                <span class="hljs-comment">// 2. 验证签名，确认所有权</span>
                CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &amp;txdata);
                <span class="hljs-keyword">if</span> (pvChecks) {
                    pvChecks-&gt;push_back(CScriptCheck());
                    check.swap(pvChecks-&gt;back());
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!check()) {
                    <span class="hljs-keyword">if</span> (flags &amp; STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {
                        CScriptCheck check2(coin.out, tx, i,
                                flags &amp; ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &amp;txdata);
                        <span class="hljs-keyword">if</span> (check2())
                            <span class="hljs-keyword">return</span> state.Invalid(<span class="hljs-keyword">false</span>, REJECT_NONSTANDARD, strprintf(<span class="hljs-string">"non-mandatory-script-verify-flag (%s)"</span>, ScriptErrorString(check.GetScriptError())));
                    }
                    <span class="hljs-keyword">return</span> state.DoS(<span class="hljs-number">100</span>,<span class="hljs-keyword">false</span>, REJECT_INVALID, strprintf(<span class="hljs-string">"mandatory-script-verify-flag-failed (%s)"</span>, ScriptErrorString(check.GetScriptError())));
                }
            }
            <span class="hljs-keyword">if</span> (cacheFullScriptStore &amp;&amp; !pvChecks) {
                scriptExecutionCache.insert(hashCacheEntry);
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <p>矿工会将通过验证的交易放入内存（代码见AcceptToMemoryPool），在进行工作量证明计算并赢得记账权后，将上述交易打包到区块中。</p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> AcceptToMemoryPoolWorker(<span class="hljs-keyword">const</span> CChainParams&amp; chainparams, CTxMemPool&amp; pool, CValidationState&amp; state, <span class="hljs-keyword">const</span> CTransactionRef&amp; ptx, <span class="hljs-keyword">bool</span>* pfMissingInputs, int64_t nAcceptTime, <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;CTransactionRef&gt;</span>* plTxnReplaced, <span class="hljs-keyword">bool</span> bypass_limits, <span class="hljs-keyword">const</span> CAmount&amp; nAbsurdFee, <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;COutPoint&gt;</span>&amp; coins_to_uncache)
{
    <span class="hljs-comment">// 此处省略部分代码</span>
    GetMainSignals().TransactionAddedToMempool(ptx);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</code></pre> 
  <h3 id="112-验证区块">1.1.2 验证区块</h3> 
  <h3 id="12-独立打包区块">1.2 独立打包区块</h3> 
  <p>假设矿工的名字是Jing。在Alice付给Bob比特币购买咖啡时，Jing的节点组装了一条区块链，高度是277314。Jing的节点持续监听网络中的交易，也持续监听其他节点发现的新区块。突然Jing的节点在网络中发现了区块277315，这时候对应区块277315的算力竞赛宣告结束，同时开启了对应区块277316的算力竞赛。</p> 
  <p>在Jing的节点搜索区块277315的答案的时候，它同时收集了许多通过验证的交易，并把这些通过验证的交易放到了内存池中。一旦收到区块277315并且完成了验证，Jing的节点会比较内存池中的所有交易，删除区块277315中包含的交易。内存池中剩下的交易记录可以继续保留，等待下一次的交易打包。</p> 
  <p>Jing 的节点立刻创建一个空区块，称为<strong>候选区块277316</strong>。一旦候选区块在工作量证明算法中胜出，这个候选区块就成为了<strong>合法区块</strong>。回顾下区块的结构，比特币区块主要包含四个字段：<code>prevHash</code>, <code>nonce</code>, <code>Merkle Root</code>和<code>timestamp</code>。</p> 
  <p>构成区块的过程主要分成两个部分：1. 汇总交易，生成交易摘要Merkle Root哈希值 2. 加入随机数nonce，生成区块header，并验证区块header是否满足上个区块的设定的目标值；</p> 
  <h4 id="121-coinbase交易">1.2.1 Coinbase交易</h4> 
  <p>每个区块的第一笔交易叫做<strong>Coinbase交易</strong>。Coinbase交易是一笔特殊交易，因为它包含了<strong>挖矿奖励</strong>。和普通交易不同，coinbase交易的输入不包含UTXO，而是输入一个coinbase值，用于凭空创造比特币。Coinbase交易有一个输出，向矿工的比特币地址支付比特币。</p> 
  <p>我们可以通过命令<code>bitcoin-cli getrawtransaction</code>查看coinbase。</p> 
  <pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>bitcoin-cli getrawtransaction
d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f <span class="hljs-number">1</span>
{
    <span class="hljs-string">"hex"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff6 f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000 "</span>,
    <span class="hljs-string">"txid"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f"</span>,
    <span class="hljs-string">"version"</span><span class="hljs-symbol">:</span> <span class="hljs-number">1</span>,
    <span class="hljs-string">"locktime"</span><span class="hljs-symbol">:</span> <span class="hljs-number">0</span>,
    <span class="hljs-string">"vin"</span><span class="hljs-symbol">:</span> [{
        <span class="hljs-string">"coinbase"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"03443b0403858402062f503253482f"</span>,
        <span class="hljs-string">"sequence"</span><span class="hljs-symbol">:</span> <span class="hljs-number">4294967295</span>
    }],
    <span class="hljs-string">"vout"</span><span class="hljs-symbol">:</span> [{
        <span class="hljs-string">"value"</span><span class="hljs-symbol">:</span> <span class="hljs-number">25.09094928</span>,
        <span class="hljs-string">"n"</span><span class="hljs-symbol">:</span> <span class="hljs-number">0</span>,
        <span class="hljs-string">"scriptPubKey"</span><span class="hljs-symbol">:</span> {
            <span class="hljs-string">"asm"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG"</span>,
            <span class="hljs-string">"hex"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac"</span>,
            <span class="hljs-string">"reqSigs"</span><span class="hljs-symbol">:</span> <span class="hljs-number">1</span>,
            <span class="hljs-string">"type"</span><span class="hljs-symbol">:</span> <span class="hljs-string">"pubkey"</span>,
            <span class="hljs-string">"addresses"</span><span class="hljs-symbol">:</span> [
                <span class="hljs-string">"1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N"</span>
            ]
        }
    }]
}</code></pre> 
  <p>Coinbase交易不包含解锁脚本字段（即scriptSig），取代它的是coinbase数据字段，其大小限制为2至100个字节。除了最前面的几个字节，剩下的coinbase数据字段内容可以由矿工随意填写。例如，著名的比特币创世区块上，中本聪写下了如下文字：“The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”。现在，矿工一般在coinbase数据字段写入其所在矿池的名字。</p> 
  <p>挖矿成功后，矿工可以得到多少奖励呢？两部分，区块奖励+手续费。上面的例子中，矿工奖励总数25.09094928枚比特币，其中包含25个比特币的区块奖励和0.09094928个比特币的手续费。比特币区块链每生成210000个区块，约4年时间，区块奖励减半（参数<code>nSubsidyHalvingInterval</code>，见<code>src/chainparam.cpp</code>中）。到2140年，区块奖励将归零，矿工的激励将只剩交易手续费。</p> 
  <pre class="prettyprint"><code class=" hljs coffeescript">CAmount GetBlockSubsidy(int nHeight, <span class="hljs-reserved">const</span> <span class="hljs-attribute">Consensus</span>::Params&amp; consensusParams) 
{
    int halvings = nHeight / consensusParams.nSubsidyHalvingInterval; 
    <span class="hljs-regexp">//</span> Force block reward to zero <span class="hljs-keyword">when</span> right shift <span class="hljs-keyword">is</span> <span class="hljs-literal">undefined</span>.
    <span class="hljs-keyword">if</span> (halvings &gt;= <span class="hljs-number">64</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    CAmount nSubsidy = <span class="hljs-number">50</span> * COIN;
    <span class="hljs-regexp">//</span> Subsidy <span class="hljs-keyword">is</span> cut <span class="hljs-keyword">in</span> half every <span class="hljs-number">210</span>,<span class="hljs-number">000</span> blocks which will occur approximately every <span class="hljs-number">4</span> years.
    nSubsidy &gt;&gt;= halvings;
    <span class="hljs-keyword">return</span> nSubsidy; 
}</code></pre> 
  <p>Coinbase交易生成后，剩下的工作就是将待确认的交易组织起来，生成一棵Merkle树作为交易摘要写进区块277316。交易打包到Merkle Tree过程详见本系列第一篇文章<a href="https://mp.weixin.qq.com/s/eBPzIAhODV4ZGEbmJ6HOGw" rel="nofollow">比特币源码阅读笔记【基础篇】</a>。最终生成一个候选区块，格式如下所示。</p> 
  <pre class="prettyprint"><code class=" hljs r">$ bitcoin-cli getblockhash <span class="hljs-number">277316</span>
0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4
$ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4
{
    <span class="hljs-string">"hash"</span> : <span class="hljs-string">"0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4"</span>, 
    <span class="hljs-string">"size"</span> : <span class="hljs-number">218629</span>,
    <span class="hljs-string">"height"</span> : <span class="hljs-number">277316</span>,
    <span class="hljs-string">"version"</span> : <span class="hljs-number">2</span>,
    <span class="hljs-string">"merkleroot"</span> : <span class="hljs-string">"c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e"</span>,
    <span class="hljs-string">"tx"</span>:[
        <span class="hljs-string">"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f"</span>,
        <span class="hljs-string">"b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe"</span>,
        <span class="hljs-keyword">...</span> 后面交易省略 <span class="hljs-keyword">...</span>
],
    <span class="hljs-string">"time"</span> : <span class="hljs-number">1388185914</span>,
    <span class="hljs-string">"nonce"</span> : <span class="hljs-number">924591752</span>,
    <span class="hljs-string">"bits"</span> : <span class="hljs-string">"1903a30c"</span>,
    <span class="hljs-string">"difficulty"</span> : <span class="hljs-number">1180923195.25802612</span>, 
    <span class="hljs-string">"chainwork"</span> : <span class="hljs-string">"000000000000000000000000000000000000000000000934695e92aaf53afa1a"</span>, 
    <span class="hljs-string">"previousblockhash"</span> : <span class="hljs-string">"0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569"</span>
}</code></pre> 
  <h4 id="122-区块目标难度">1.2.2 区块目标难度</h4> 
  <p>比特币的区块链结构主要有两层哈希，第一层是在区块的<strong>链结构</strong>上，每个区块header都包含一个哈希指针，指向前一个区块；第二层是在每一个<strong>区块内</strong>，区块内部打包的所有交易用Merkle树组织起来，如下图所示<img src="http://static.zybuluo.com/renqHIT/ebqahe7h7yntinwnnjy1001u/%E9%93%BE%E6%8E%A5.png" alt="链接.png-234.3kB" title=""></p> 
  <p>回顾下区块header的结构：</p> 
  <ul> 
   <li>version 软件/协议版本号</li> 
   <li>previous block hash 父区块的哈希值</li> 
   <li>merkle root 当前区块交易信息摘要值</li> 
   <li>timestamp 区块创建时间</li> 
   <li>target 当前区块的工作量证明算法目标值</li> 
   <li>nonce 工作量证明算法的计数器</li> 
  </ul> 
  <p><code>version</code>，软件版本号，由当前客户端版本决定；父区块哈希值<code>prevHash</code>，由该节点可以获取的最新区块决定；区块创建时间<code>timestamp</code>，即矿工节点的时间戳；这三个参数没有太多可以解释的内容。</p> 
  <p>后面三个参数：PoW目标值<code>target</code>，计数器<code>nonce</code>，交易摘要值<code>merkle root</code>是达成共识的关键。</p> 
  <p>什么是目标，什么又是目标难度呢？目标是比特币网络中所有矿工节点一起计算的那道题目，题目的格式为: 找到一个区块，它的header哈希值小于0000000000000000029AB9000000000000000000000000000000000000000000。这个题目就是下一个区块的挖矿目标，而这个数值0000000000000000029AB9000000000000000000000000000000000000000000就是所谓的<strong>目标难度</strong>。那么上面例子中的哈希计算有多难呢？网络中的一个节点如果想求出这个哈希值，平均需要进行1.8 * 10 ^ 21次哈希计算。这个难度是动态调整的，假如网络中矿工节点的计算能力都很强，那么难度将会提高。目标难度由下面的公式计算</p> 
  <pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute"> 目标 </span>=<span class="hljs-string"> 系数 * 2^(8 * (指数 – 3))</span></code></pre> 
  <p>根据这个公式，假如难度位取值是0x1903a30c, 我们可以得到目标值：</p> 
  <pre class="prettyprint"><code class=" hljs haml">    目标 = 0x03a30c * 2^(0x08 * (0x19 - 0x03))^
    =<span class="ruby">&gt; 目标 = <span class="hljs-number">0x03a30c</span> * <span class="hljs-number">2</span>^(<span class="hljs-number">0x08</span> * <span class="hljs-number">0x16</span>)^ </span>    =<span class="ruby">&gt; 目标 = <span class="hljs-number">0x03a30c</span> * <span class="hljs-number">2</span>^<span class="hljs-number">0xB0</span>^</span></code></pre> 
  <p>用十进制表示:</p> 
  <pre class="prettyprint"><code class=" hljs haml">    =<span class="ruby">&gt; 目标 = <span class="hljs-number">238</span>,<span class="hljs-number">348</span> * <span class="hljs-number">2</span>^<span class="hljs-number">176</span>^ </span>    =<span class="ruby">&gt; 目标 = </span>    22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328</code></pre> 
  <p>切换回十六进制表示:</p> 
  <pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute"> </span>=<span class="hljs-string">&gt; 目标 = 0x0000000000000003A30C00000000000000000000000000000000000000000000</span></code></pre> 
  <p>我们可以看到，哈希目标决定了求解PoW的时间。为什么要调整难度呢，谁在调整难度，又是如何调整难度呢？</p> 
  <p>首先，比特币<strong>平均每10分钟生成一个区块，这是比特币的基础设定</strong>。比特币区块产生速率不仅需要短期保持恒定，而且需要维持多年。在这个过程中，计算机的算力将持续提升，加入挖矿的计算机也将持续变化，不管外部条件如何改变，比特币区块生成时间都将动态地调整到10分钟。在出块时间上保持稳定是一种聪明的设计，2100万个比特币，在2140年全部挖矿得出，这个社会学实验周期在100年以上，无论是成功还是失败，过程中的起起伏伏已经是极佳的社会学实验案例。</p> 
  <p>完全去中心化的网络中如何完成难度调整呢？我们可以在链参数定义的源代码<code>chainparams.cpp</code>中找到参数：<code>nPowTargetTimespan=14*24*60*60</code>，两周调整一次PoW难度。按每10分钟产生一个区块计算，两周产生<code>(14*24*60*60)/(10*60)=2016</code>个区块，也就是每产生2016个区块调整一次难度。</p> 
  <pre class="prettyprint"><code class=" hljs avrasm">class CMainParams : public CChainParams {
<span class="hljs-label">public:</span>
    CMainParams() {
        strNetworkID = <span class="hljs-string">"main"</span><span class="hljs-comment">;</span>
        consensus<span class="hljs-preprocessor">.nSubsidyHalvingInterval</span> = <span class="hljs-number">210000</span><span class="hljs-comment">;</span>
        // 省略部分参数
        consensus<span class="hljs-preprocessor">.nPowTargetTimespan</span> = <span class="hljs-number">14</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span><span class="hljs-comment">; // two weeks</span>
        consensus<span class="hljs-preprocessor">.nPowTargetSpacing</span> = <span class="hljs-number">10</span> * <span class="hljs-number">60</span><span class="hljs-comment">;</span>
        consensus<span class="hljs-preprocessor">.fPowAllowMinDifficultyBlocks</span> = false<span class="hljs-comment">;</span>
        consensus<span class="hljs-preprocessor">.fPowNoRetargeting</span> = false<span class="hljs-comment">;</span>
        consensus<span class="hljs-preprocessor">.nRuleChangeActivationThreshold</span> = <span class="hljs-number">1916</span><span class="hljs-comment">; // 95% of 2016</span>
        consensus<span class="hljs-preprocessor">.nMinerConfirmationWindow</span> = <span class="hljs-number">2016</span><span class="hljs-comment">; // nPowTargetTimespan / nPowTargetSpacing</span>

        // 隔离见证 (BIP141, BIP143, <span class="hljs-keyword">and</span> BIP147)
        consensus<span class="hljs-preprocessor">.vDeployments</span>[Consensus::DEPLOYMENT_SEGWIT]<span class="hljs-preprocessor">.bit</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
        consensus<span class="hljs-preprocessor">.vDeployments</span>[Consensus::DEPLOYMENT_SEGWIT]<span class="hljs-preprocessor">.nStartTime</span> = <span class="hljs-number">1479168000</span><span class="hljs-comment">; // November 15th, 2016.</span>
        consensus<span class="hljs-preprocessor">.vDeployments</span>[Consensus::DEPLOYMENT_SEGWIT]<span class="hljs-preprocessor">.nTimeout</span> = <span class="hljs-number">1510704000</span><span class="hljs-comment">; // November 15th, 2017.</span>

        // The best chain should have at least this much work.
        consensus<span class="hljs-preprocessor">.nMinimumChainWork</span> = uint256S(<span class="hljs-string">"0x000000000000000000000000000000000000000000723d3581fe1bd55373540a"</span>)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span></code></pre> 
  <p>调整难度的时候会评估最后产生的2016个区块的时间，与2016 * 10分钟做比较，实际时间除以预期时间的比例决定了下一次的目标难度。重新定义哈希值目标的公式为：</p> 
  <pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">新目标 </span>=<span class="hljs-string"> 旧目标 * (产出过去2016个区块的时间 / 20160 分钟)</span></code></pre> 
  <p>计算下次PoW工作量(目标难度)的代码，见<code>src/pow.cpp</code>中的CalculateNextWorkRequired函数：</p> 
  <pre class="prettyprint"><code class=" hljs cs">unsigned <span class="hljs-keyword">int</span> CalculateNextWorkRequired(<span class="hljs-keyword">const</span> CBlockIndex* pindexLast, int64_t nFirstBlockTime, <span class="hljs-keyword">const</span> Consensus::Params&amp; <span class="hljs-keyword">params</span>)
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">params</span>.fPowNoRetargeting)
        <span class="hljs-keyword">return</span> pindexLast-&gt;nBits;

    <span class="hljs-comment">// Limit adjustment step</span>
    int64_t nActualTimespan = pindexLast-&gt;GetBlockTime() - nFirstBlockTime;
    <span class="hljs-keyword">if</span> (nActualTimespan &lt; <span class="hljs-keyword">params</span>.nPowTargetTimespan/<span class="hljs-number">4</span>)
        nActualTimespan = <span class="hljs-keyword">params</span>.nPowTargetTimespan/<span class="hljs-number">4</span>;
    <span class="hljs-keyword">if</span> (nActualTimespan &gt; <span class="hljs-keyword">params</span>.nPowTargetTimespan*<span class="hljs-number">4</span>)
        nActualTimespan = <span class="hljs-keyword">params</span>.nPowTargetTimespan*<span class="hljs-number">4</span>;

    <span class="hljs-comment">// Retarget</span>
    <span class="hljs-keyword">const</span> arith_uint256 bnPowLimit = UintToArith256(<span class="hljs-keyword">params</span>.powLimit);
    arith_uint256 bnNew;
    bnNew.SetCompact(pindexLast-&gt;nBits);
    bnNew *= nActualTimespan;
    bnNew /= <span class="hljs-keyword">params</span>.nPowTargetTimespan;

    <span class="hljs-keyword">if</span> (bnNew &gt; bnPowLimit)
        bnNew = bnPowLimit;

    <span class="hljs-keyword">return</span> bnNew.GetCompact();
}</code></pre> 
  <h4 id="123-pow-工作量证明">1.2.3 PoW 工作量证明</h4> 
  <p>我们可以用下面的Python代码表示工作量证明的计算过程，两层循环尝试<code>merkle root</code>和<code>nonce</code>, 生成一个区块；将区块和目标难度输入PoW算法进行验证，哈希值满足难度target要求则验证通过，见下面Python代码第37行。</p> 
  <pre class="prettyprint"><code class="language-Python hljs python"><span class="hljs-comment">#!/usr/bin/env python</span>
<span class="hljs-comment"># example of proof-of-work algorithm</span>
<span class="hljs-keyword">import</span> hashlib
<span class="hljs-keyword">import</span> time

max_nonce = <span class="hljs-number">2</span> ** <span class="hljs-number">32</span> <span class="hljs-comment"># 4 billion</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proof_of_work</span><span class="hljs-params">(header, difficulty_bits)</span>:</span>
    <span class="hljs-comment"># calculate the difficulty target</span>
    target = <span class="hljs-number">2</span> ** (<span class="hljs-number">256</span>-difficulty_bits) 

    <span class="hljs-keyword">for</span> nonce <span class="hljs-keyword">in</span> xrange(max_nonce):
        hash_result = hashlib.sha256(str(header)+str(nonce)).hexdigest()
        <span class="hljs-comment"># check if this is a valid result, below the target</span>
        <span class="hljs-keyword">if</span> long(hash_result, <span class="hljs-number">16</span>) &lt; target:
            <span class="hljs-keyword">print</span> <span class="hljs-string">"Success with nonce %d"</span> % nonce 
            <span class="hljs-keyword">print</span> <span class="hljs-string">"Hash is %s"</span> % hash_result 
            <span class="hljs-keyword">return</span> (hash_result,nonce)

    <span class="hljs-keyword">print</span> <span class="hljs-string">"Failed after %d (max_nonce) tries"</span> % nonce <span class="hljs-keyword">return</span> nonce


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>: 
    nonce = <span class="hljs-number">0</span>
    hash_result = <span class="hljs-string">''</span>
    <span class="hljs-comment"># difficulty from 0 to 31 bits</span>
    <span class="hljs-keyword">for</span> difficulty_bits <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">32</span>): 
        difficulty = <span class="hljs-number">2</span> ** difficulty_bits
        <span class="hljs-keyword">print</span> <span class="hljs-string">"Difficulty: %ld (%d bits)"</span> % (difficulty, difficulty_bits) 
        <span class="hljs-keyword">print</span> <span class="hljs-string">"Starting search..."</span>
        <span class="hljs-comment"># checkpoint the current time</span>
        start_time = time.time()
        <span class="hljs-comment"># make a new block which includes the hash from the previous block</span>
        <span class="hljs-comment"># we fake a block of transactions - just a string</span>
        new_block = <span class="hljs-string">'test block with transactions'</span> + hash_result 
        <span class="hljs-comment"># find a valid nonce for the new block</span>
        (hash_result, nonce) = proof_of_work(new_block, difficulty_bits) 
        <span class="hljs-comment"># checkpoint how long it took to find a result</span>
        end_time = time.time()
        elapsed_time = end_time - start_time
        <span class="hljs-keyword">print</span> <span class="hljs-string">"Elapsed Time: %.4f seconds"</span> % elapsed_time 
        <span class="hljs-keyword">if</span> elapsed_time &gt; <span class="hljs-number">0</span>:
            <span class="hljs-comment"># estimate the hashes per second</span>
            hash_power = float(long(nonce)/elapsed_time)
            <span class="hljs-keyword">print</span> <span class="hljs-string">"Hashing Power: %ld hashes per second"</span> % hash_power</code></pre> 
  <p>每个矿工的谜题都是一样的吗？不，原因主要有几点：</p> 
  <ol> 
   <li>网络状态决定了不同节点的账本状态不能做到全部一致；不同矿工节点的上一个区块不会完全相同；一方面是高度可能不一致，另一方面是节点可能选择相同高度的不同区块。</li> 
   <li>不同节点打包的UTXO列表，内容和顺序不相同。与区块高度相比，这项区别更为明显。</li> 
   <li>矿工之间的公钥签名不同，除非共享公钥（加入同一个矿池）</li> 
  </ol> 
  <h3 id="13-组装到链">1.3 组装到链</h3> 
  <p>下一步是矿工独立地将区块组装到区块链。每个矿工节点基于PoW算法，独立选择计算工作量最大的链，并将交易组装进链。</p> 
  <p>比特币分布式共识机制的最后一步就是<strong>将区块组装到链并选择最多工作量的链</strong>。一旦一个节点验证了一个新的区块，它将会尝试把这个区块组装到现有的链中。节点维护了三个区块集合：</p> 
  <ul> 
   <li>链到主链中的区块 </li> 
   <li>链到主链分支中的区块 </li> 
   <li>没有已知父节点的区块，叫做<strong>孤块</strong>。</li> 
  </ul> 
  <p>上述三种区块都必须通过交易验证和区块验证，而验证失败的区块会被抛弃，不会向网络中其他节点转发。<strong>主链</strong>指的是在一个时刻拥有最多累积工作量的链，大多数情况下主链就是拥有最多区块的链，除非此刻有两条长度相同的链，其中一条拥有更多的累积工作量。主链还会维护分支链用于未来引用，因为分支链有可能得到更多的后续区块从而成为新的主链。当矿工挖出新区块时，该节点通过选择扩展哪条链来投票。我们不用担心部分矿工故意选择工作量更少的链，因为多数矿工会选择工作量最多的链，而工作量较少的链会被彻底放弃。打个比方，超市收银台有多个结账窗口，只有排队人数最多的收银台可以结账。这时候为了结账，矿工只能选择最长的队伍排队，因为短队伍意味着不会得到结账机会。</p> 
  <h3 id="14-孤块">1.4 孤块</h3> 
  <p>如果收到了一个合法区块，但是没有在主链和分支链中发现该区块的父区块，那么这个区块就叫做<strong>孤块</strong>。因为孤块是合法的区块，只是没有找到父区块，所以孤块也会被节点保存下来，存储在<strong>孤块池</strong>中，直到找到它的父区块。一旦找到了父区块，孤块就离开孤块池，链到已经存在的链上。一般来说，两个区块在很短时间内产生，并且被其他节点接收的顺序刚好和产生顺序相反才会出现孤块，孤块是一种临时现象。</p> 
  <h2 id="二分叉">二、分叉</h2> 
  <h3 id="21-分叉">2.1 分叉</h3> 
  <p>因为区块链是一个分布式的数据结构，所以不同的副本不会永远一致。区块可能在不同时间到达不同的节点，造成各个节点拥有不同的区块链视角。为了解决这个问题，每个节点选择承认并扩展一条最多工作量的链。只要所有节点都选择最多累积工作量的链，那么比特币网络将最终收敛到一致状态。节点之间区块链版本不一致的状态称作<strong>分叉</strong>，一般来说分叉只是一种临时状态，当出现更多区块的链时，网络节点会达成新的一致状态。下面我们解释一下网络分叉和合并的过程。</p> 
  <p>下图中蓝色的圈代表比特币矿工节点，黑色的线代表节点之间的网络连接关系，五角星代表最新的一个区块。假设初始状态时所有节点的最新区块都是这个五角星。 <br> <img src="http://static.zybuluo.com/renqHIT/lsfkbjmr303c8rrdrl05zo5z/%E5%88%86%E5%8F%89-0.png" alt="分叉-0.png-222.9kB" title=""></p> 
  <p>下一时刻，节点X和节点Y几乎同时挖矿得到了两个不同的区块，节点X挖出了米白色的正三角形，节点Y挖出了橙色的倒三角形，两个区块被X和Y各自追加在五角星后面，并开始向各自连接的矿工节点广播，见图中的红色箭头。收到节点X挖出三角形区块的节点将三角形区块追加到自己的区块链上，同样地，收到节点Y挖出倒三角形区块的节点将倒三角形区块追加到自己的区块链上，这时候，比特币网络产生了临时的分叉。 <br> <img src="http://static.zybuluo.com/renqHIT/6fzle8ae32lsv2k5xzyk1vny/%E5%88%86%E5%8F%89-1.png" alt="分叉-1.png-189.7kB" title=""></p> 
  <p>随着节点在网络中同步区块数据，每个节点都会收到两个合法的区块，两个区块都会存在于该节点维护的区块链上。 <br> <img src="http://static.zybuluo.com/renqHIT/1iuehzwwdgkqaikznwzrl0rg/%E5%88%86%E5%8F%89-2.png" alt="分叉-2.png-222.8kB" title=""></p> 
  <p>这时候，一个矿工节点挖出了新的区块–绿色方块，这个矿工选择将绿色区块连接在米白色三角形之后，并向网络中传播。随着绿色区块的传播，当绿色区块传播到节点Y的时候，节点Y将绿色区块追加在米白色的区块之后。这里比较有趣，虽然节点Y挖出了橙色的区块，但是当它收到绿色区块后依然需要把绿色区块追加在米白色区块上，而不能忽略绿色区块。这是游戏规则。</p> 
  <p>假如矿工有能力修改挖矿策略，形成了一批破坏者，只保留向自己挖出的区块追加的块，丢弃其他节点。这种情况会发生什么呢？短期来看，比特币网络节点行成了两派，各自维护自己的区块，如果两派区块链都继续沿着各自路线前进，并且都有其支持者，那么比特币将分裂成两种币。 <br> <img src="http://static.zybuluo.com/renqHIT/ebq8bkedtzaocsmvn3ev65ww/fencha-3.png" alt="fencha-3.png-390.2kB" title=""></p> 
  <p>回到游戏规则中来，节点Y需要追加绿色区块到节点X挖出的米白色三角形后面，随着网络节点同步区块的进行，“五角星-米白色三角形-绿色方块”这条链成为拥有最多累计工作量的区块链，成为主链。在比特币的世界里橙色的区块很悲剧，只能认赔，什么也得不到。这时候比特币网络再次成为统一状态。</p> 
  <p><img src="http://static.zybuluo.com/renqHIT/iqimdp6tilaj87ymkyiv526z/%E5%88%86%E5%8F%89-4.png" alt="分叉-4.png-351.1kB" title=""></p> 
  <p>顺便提一句，在以太坊的世界里，橙色的区块称为<strong>叔块</strong>，如果叔块得到确认还可以得到奖励，称为<strong>叔块奖励</strong>。造成这种现象的原因是，比特币的出块时间是固定的10分钟，而以太坊的出块时间是变化的，大体出块时间如下：</p> 
  <pre class="prettyprint"><code class=" hljs ">在第 4000000个区块，总的以太币数量大约是 93262556，时间大约是 2017-08-15 区块时间为 30.01秒。
在第 4500000个区块，总的以太币数量大约是 95912556，时间大约是 2018-11-03 区块时间为 136.71秒。
在第 5000000个区块，总的以太币数量大约是 98562556，时间大约是 2025-10-02 区块时间为 835.81秒。</code></pre> 
  <p>现阶段以太坊的出块时间只有30秒，相比于10分钟很短。网络传输过程中，由于种种因素，会出现网络孤岛，叔块比例会远高于比特币的场景。为了弥补这些矿工的损失，以太坊设立了叔块奖励，详见<strong>幽灵协议</strong>（Greedy Heaviest-Observed Sub-Tree, 简写为GHOST)。</p> 
  <h3 id="22-隔离见证">2.2 隔离见证</h3> 
  <p>2017年初，比特币社区发生了一场大的变革，其中几个关键词就是：隔离见证，区块扩容，闪电网络。它们出现的原因都是为了解决比特币网络交易拥堵的问题，只是技术路线出现了分歧。矿工为首的一派的意见是扩容区块，而比特币Core团队坚持1MB区块大小，双方互不妥协，最终比特币分叉成了两种币，BTC和BCH。</p> 
  <p>隔离见证是指一种比特币架构修改方案，它会影响到比特币的扩展性、安全性、性能和经济激励等多个方面。隔离见证方案的原文可以查看以下几篇BIP:</p> 
  <ul> 
   <li>BIP-141 隔离见证的主要定义</li> 
   <li>BIP-143 交易签名验证–第0版</li> 
   <li>BIP-144 Peer Services—-新的网络消息和序列化格式</li> 
   <li>BIP-145 隔离见证的getblocktemplate更新 (适用于挖矿)</li> 
  </ul> 
  <p>鉴于篇幅所限，本篇文章不再展开比特币扩容问题。感兴趣的读者敬请期待–比特币源码阅读笔记【扩容篇】。</p> 
  <h2 id="三参考资料">三、参考资料</h2> 
  <ol> 
   <li>Mastering BitCoin</li> 
   <li>普林斯顿大学公开课</li> 
   <li>巴比特论坛</li> 
  </ol> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/renq_654321/article/details/79456170,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/renq_654321/article/details/79456170,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
