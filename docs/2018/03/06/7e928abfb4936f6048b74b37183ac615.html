<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链的简单理解以及python的简单实现 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链的简单理解以及python的简单实现" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/luokezhen/article/details/79436942 最近看了不少关于区块链的资讯, 里面大多数都是在鼓吹这个技术有多么长远的未来. 看得多了, 自然也就产生了想要一探究竟的想法. 但是那些文章里都是些自己造的或者强行翻译过来的各种名词, 并没有具体的例子, 虽然看了但是也不能产生更加清晰的认知. 所以, 在csdn上找了一些简单的区块链示例, 尝试着写了一下. 区块类 区块链, 从名字来理解, 就是区块构成的链条. 到此, 两个基本的类已经呼之欲出了. 一个是区块类, 还有区块的容器类 class BlockChain(object): pass class Block(object): pass 先来了解一下区块. 一个区块有七个基本的属性 : index: 就是该区块的序号, 你是第多少个区块, 也叫做链高度 hash: 就是这个区块的id previous hash: 就是上一个区块的id tempstamp: 时间戳 difficulty: 该区块的难度指数 nonce: 随机数, 用于产生下一个区块 data: 用来存储这个区块对应的信息 至此, 应该能写出这个类的基本代码了. 还要有一个获取该区块信息的方法, 以便于我们查看这个区块信息 # 区块类 class Block(object): # 一个区块有七个基本的属性, 分别是序号, id, 上一个区块id, 随机数, 难度系数, 时间戳, 还有一个区块体, 记录了交易信息 def __init__(self): self.index = None # 区块的id self.hash = None self.previous_hash = None self.nonce = None self.difficulty = None self.timestamp = None self.transaction_data = None # 以字典的形式记录这个区块的信息, 并返回 def get_block_info(self): block_info = { &#39;Index&#39;: self.index, &#39;Hash&#39;: self.hash, &#39;Previous_hash&#39;: self.previous_hash, &#39;Nonce&#39;: self.nonce, &#39;Difficulty&#39;: self.difficulty, &#39;Timestamp&#39;: self.timestamp, &#39;Transaction_data&#39;: self.transaction_data, } return block_info 矿工类 那么区块是如何生成的呢?答案就是由矿工挖出来的. 区块里一个关键的属性就是这个区块的id, 它是通过hashlib包里的sha256计算方法计算出来的. 但是计算为什么叫做挖矿呢? 因为我们可以给这个id一个限制条件, 那么矿工就需要不停地改变内容去计算结果, 直到满足这个条件为止, 条件设置的越苛刻, 尝试的次数就越多, 计算时间也越长. 这就是挖矿的过程. 所以, 可以尝试着写出矿工类. 有一个挖矿的方法mine, 并且记录耗时, 这里我们设置的规则为id最后一位为0 class Pitman(object): # 定义矿工的挖矿方法, 需要的参数为该区块的序号, 之前的id, 交易信息 def mine(self, index, previous_hash, transaction_data): # print(&#39;我要开始挖了&#39;) # 开始时间 begin_time = time.time() block = Block() block.index = index block.previous_hash = previous_hash block.transaction_data = transaction_data block.timestamp = time.time() # 根据之前的id和交易信息生成这个区块的id和随机数, 还有困难系数 block.difficulty, block.hash, block.nonce = self.gen_hash(previous_hash, transaction_data) # 结束时间 end_time = time.time() # 花费的时间 spend_time = end_time - begin_time # print(&#39;我挖完了&#39;) return block, spend_time 上面的代码中记录了耗时, 使用了我们的区块类, 并设置了对应的属性, 至于id值, 我们另写一个方法来获取 @staticmethod def gen_hash(previous_hash, transaction_data): # 随机数, 从1到99999随机取值 nonce = random.randrange(1, 99999) difficulty = 0 # 先生成一个字符串, 然后尝试, 不符合要求再修改 guess = str(previous_hash) + str(nonce) + transaction_data # 计算出id res = hashlib.sha256(guess.encode()).hexdigest() # 验证生成的id是否符合要求, 这里设定的要求是最后一位为0 while res[-1] != &#39;0&#39;: # 每尝试一次, 难度系数就+1 difficulty += 1 nonce += difficulty guess = previous_hash + str(nonce) + transaction_data res = hashlib.sha256(guess.encode()).hexdigest() # 得到符合要求的id后, 返回难度系数, id值和随机数 return difficulty, res, nonce 多线程 我们希望可以同时让多个矿工进行挖矿 # 自定义线程类 class MyThread(Thread): def __init__(self, target, args=()): super(MyThread, self).__init__() self.func = target self.arg = args # self.result = None def run(self): self.result = self.func(*self.arg) def get_result(self): try: return self.result except Exception as e: print(&#39;自定义线程获取结果时发生了错误:&#39;, e) return None 继承线程类并重写run方法 区块链类 每一个区块都是根据上一个区块的id产生的, 那么第一个区块没有上一个区块, 就需要我们来自己设置, 第一个区块被叫做创世区块 # 首先, 创建一个区块链类 class BlockChain(object): def __init__(self, hash_num): # 存储区块链对象, 区块的容器 self.chain_list = [] # 矿工的容器 self.pitman_list = [] # 然后再容器中填入6个矿工 for i in range(6): self.pitman_list.append(Pitman) # 存储每个阶段产生的区块 self.result_list = [] # 创建区块的方法, 如果当前生成的区块为第一个区块，则产生创世区块 self.gen_block(hash_num) 因为每个区块都是由上一个区块计算出来的, 所以我们需要一个获取上一个区块的方法, 也就是此时区块链中最后一个区块 # 获取最后一个区块 @property def get_last_block(self): if len(self.chain_list): return self.chain_list[-1] return None 还需要交易信息, 这里我们随机生成一个就好 # 随机生成一份交易信息, 交易信息就是json字符串 def get_trans(self): dict_data = { # random.sample可以从一个序列中随机获取指定数量的元素 &#39;sender&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;recipient&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), # 相当于random.choice(range(1, 10000)) &#39;amount&#39;: random.randrange(1, 10000), } return json.dumps(dict_data) 接下来就是生成新区块了, 这里需要区分它是否是创世区块, 因为生成规则不同 如果是创世区块 # 生成新区块的方法 def gen_block(self, initial_hash=None): # 根据传参判断是否是创世区块 # 如果是创世区块 if initial_hash: # 先用区块类定义一个区块 block = Block() # 然后对创建好的对象的实例属性进行设置 block.index = 0 block.nonce = random.randrange(0, 99999) block.previous_hash = &#39;0&#39; # 写到此, 我并不知道这个0是怎么来的, 以后是不是还要赋其他值? # 已经了解了, 0就是创世区块, 第一个, 所以是0 block.difficulty = 0 # 区块的交易信息 block.transaction_data = self.get_trans() # 哈希值 # guess = f&#39;{block.previousHash}{block.nonce}{block.transactionData}&#39;.encode() # 这个写法我没有看懂 # 看懂了, 是字符串格式化的另一种写法: f写法 guess = str(block.index) + str(block.nonce) + block.previous_hash block.hash = hashlib.sha256(guess.encode()).hexdigest() block.timestamp = time.time() self.chain_list.append(block) 否则 # 如果不是创世区块 else: # 先启动六个矿工开始挖矿 for pitman in self.pitman_list: # for i in range(len(self.pitman_list)): # todo: 参数先不写, 以后在写 # 参数为这个矿工类, 链此时的长度, 最后一个区块id, 交易信息 t = MyThread(target=pitman.mine, args=(pitman, len(self.chain_list), # 获取当前这个区块链的最后一个区块的id self.get_last_block.get_block_info()[&#39;Hash&#39;], # 获取交易信息 self.get_trans())) # t = MyThread(target=self.pitman_list[i].mine, ) t.start() t.join() # 存储挖出来的区块 self.result_list.append(t.get_result()) print(&quot;All blocks generated by pitmen:&quot;) # 挖完了之后就该打印挖到的区块了 # 上一个循环是同时启动六个矿工的线程开始运行, 等运行都完毕之后, 才开始继续主程序的运行, 是这样的吗? for result in self.result_list: print(result[0].get_block_info()) # 获取新的区块 # 先找到这个符合标准的区块 # 先取出来第一个挖出来的区块 first_block = self.result_list[0][0] # 再获取第一个区块计算耗费的时间, 转换成标准小数 min_time = Decimal(self.result_list[0][1]) # 去寻找那个用时最短的矿工挖出来的区块 for i in range(1, len(self.result_list)): if Decimal(self.result_list[i][1]) &lt; min_time: first_block = self.result_list[i][0] # 找到以后存储 self.chain_list.append(first_block) # 清空结果列表 self.result_list = [] 展示区块链信息方法 def show_chain(self): for block in self.chain_list: print(block.get_block_info()) 至此, 一个完整的简单区块链写完了, 跑一下 if __name__ == &#39;__main__&#39;: chain = BlockChain(1) for i in range(20): chain.gen_block() chain.show_chain() 完整代码: https://github.com/luokezhen/lkz/tree/master/%E5%8C%BA%E5%9D%97%E9%93%BE 参考资料: http://blog.csdn.net/bmwgaara/article/details/79059007 以上均为我个人的学习感悟, 欢迎批评指正 交流产生灵感 : QQ: 1396737599 微信: 18500094110 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/luokezhen/article/details/79436942 最近看了不少关于区块链的资讯, 里面大多数都是在鼓吹这个技术有多么长远的未来. 看得多了, 自然也就产生了想要一探究竟的想法. 但是那些文章里都是些自己造的或者强行翻译过来的各种名词, 并没有具体的例子, 虽然看了但是也不能产生更加清晰的认知. 所以, 在csdn上找了一些简单的区块链示例, 尝试着写了一下. 区块类 区块链, 从名字来理解, 就是区块构成的链条. 到此, 两个基本的类已经呼之欲出了. 一个是区块类, 还有区块的容器类 class BlockChain(object): pass class Block(object): pass 先来了解一下区块. 一个区块有七个基本的属性 : index: 就是该区块的序号, 你是第多少个区块, 也叫做链高度 hash: 就是这个区块的id previous hash: 就是上一个区块的id tempstamp: 时间戳 difficulty: 该区块的难度指数 nonce: 随机数, 用于产生下一个区块 data: 用来存储这个区块对应的信息 至此, 应该能写出这个类的基本代码了. 还要有一个获取该区块信息的方法, 以便于我们查看这个区块信息 # 区块类 class Block(object): # 一个区块有七个基本的属性, 分别是序号, id, 上一个区块id, 随机数, 难度系数, 时间戳, 还有一个区块体, 记录了交易信息 def __init__(self): self.index = None # 区块的id self.hash = None self.previous_hash = None self.nonce = None self.difficulty = None self.timestamp = None self.transaction_data = None # 以字典的形式记录这个区块的信息, 并返回 def get_block_info(self): block_info = { &#39;Index&#39;: self.index, &#39;Hash&#39;: self.hash, &#39;Previous_hash&#39;: self.previous_hash, &#39;Nonce&#39;: self.nonce, &#39;Difficulty&#39;: self.difficulty, &#39;Timestamp&#39;: self.timestamp, &#39;Transaction_data&#39;: self.transaction_data, } return block_info 矿工类 那么区块是如何生成的呢?答案就是由矿工挖出来的. 区块里一个关键的属性就是这个区块的id, 它是通过hashlib包里的sha256计算方法计算出来的. 但是计算为什么叫做挖矿呢? 因为我们可以给这个id一个限制条件, 那么矿工就需要不停地改变内容去计算结果, 直到满足这个条件为止, 条件设置的越苛刻, 尝试的次数就越多, 计算时间也越长. 这就是挖矿的过程. 所以, 可以尝试着写出矿工类. 有一个挖矿的方法mine, 并且记录耗时, 这里我们设置的规则为id最后一位为0 class Pitman(object): # 定义矿工的挖矿方法, 需要的参数为该区块的序号, 之前的id, 交易信息 def mine(self, index, previous_hash, transaction_data): # print(&#39;我要开始挖了&#39;) # 开始时间 begin_time = time.time() block = Block() block.index = index block.previous_hash = previous_hash block.transaction_data = transaction_data block.timestamp = time.time() # 根据之前的id和交易信息生成这个区块的id和随机数, 还有困难系数 block.difficulty, block.hash, block.nonce = self.gen_hash(previous_hash, transaction_data) # 结束时间 end_time = time.time() # 花费的时间 spend_time = end_time - begin_time # print(&#39;我挖完了&#39;) return block, spend_time 上面的代码中记录了耗时, 使用了我们的区块类, 并设置了对应的属性, 至于id值, 我们另写一个方法来获取 @staticmethod def gen_hash(previous_hash, transaction_data): # 随机数, 从1到99999随机取值 nonce = random.randrange(1, 99999) difficulty = 0 # 先生成一个字符串, 然后尝试, 不符合要求再修改 guess = str(previous_hash) + str(nonce) + transaction_data # 计算出id res = hashlib.sha256(guess.encode()).hexdigest() # 验证生成的id是否符合要求, 这里设定的要求是最后一位为0 while res[-1] != &#39;0&#39;: # 每尝试一次, 难度系数就+1 difficulty += 1 nonce += difficulty guess = previous_hash + str(nonce) + transaction_data res = hashlib.sha256(guess.encode()).hexdigest() # 得到符合要求的id后, 返回难度系数, id值和随机数 return difficulty, res, nonce 多线程 我们希望可以同时让多个矿工进行挖矿 # 自定义线程类 class MyThread(Thread): def __init__(self, target, args=()): super(MyThread, self).__init__() self.func = target self.arg = args # self.result = None def run(self): self.result = self.func(*self.arg) def get_result(self): try: return self.result except Exception as e: print(&#39;自定义线程获取结果时发生了错误:&#39;, e) return None 继承线程类并重写run方法 区块链类 每一个区块都是根据上一个区块的id产生的, 那么第一个区块没有上一个区块, 就需要我们来自己设置, 第一个区块被叫做创世区块 # 首先, 创建一个区块链类 class BlockChain(object): def __init__(self, hash_num): # 存储区块链对象, 区块的容器 self.chain_list = [] # 矿工的容器 self.pitman_list = [] # 然后再容器中填入6个矿工 for i in range(6): self.pitman_list.append(Pitman) # 存储每个阶段产生的区块 self.result_list = [] # 创建区块的方法, 如果当前生成的区块为第一个区块，则产生创世区块 self.gen_block(hash_num) 因为每个区块都是由上一个区块计算出来的, 所以我们需要一个获取上一个区块的方法, 也就是此时区块链中最后一个区块 # 获取最后一个区块 @property def get_last_block(self): if len(self.chain_list): return self.chain_list[-1] return None 还需要交易信息, 这里我们随机生成一个就好 # 随机生成一份交易信息, 交易信息就是json字符串 def get_trans(self): dict_data = { # random.sample可以从一个序列中随机获取指定数量的元素 &#39;sender&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;recipient&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), # 相当于random.choice(range(1, 10000)) &#39;amount&#39;: random.randrange(1, 10000), } return json.dumps(dict_data) 接下来就是生成新区块了, 这里需要区分它是否是创世区块, 因为生成规则不同 如果是创世区块 # 生成新区块的方法 def gen_block(self, initial_hash=None): # 根据传参判断是否是创世区块 # 如果是创世区块 if initial_hash: # 先用区块类定义一个区块 block = Block() # 然后对创建好的对象的实例属性进行设置 block.index = 0 block.nonce = random.randrange(0, 99999) block.previous_hash = &#39;0&#39; # 写到此, 我并不知道这个0是怎么来的, 以后是不是还要赋其他值? # 已经了解了, 0就是创世区块, 第一个, 所以是0 block.difficulty = 0 # 区块的交易信息 block.transaction_data = self.get_trans() # 哈希值 # guess = f&#39;{block.previousHash}{block.nonce}{block.transactionData}&#39;.encode() # 这个写法我没有看懂 # 看懂了, 是字符串格式化的另一种写法: f写法 guess = str(block.index) + str(block.nonce) + block.previous_hash block.hash = hashlib.sha256(guess.encode()).hexdigest() block.timestamp = time.time() self.chain_list.append(block) 否则 # 如果不是创世区块 else: # 先启动六个矿工开始挖矿 for pitman in self.pitman_list: # for i in range(len(self.pitman_list)): # todo: 参数先不写, 以后在写 # 参数为这个矿工类, 链此时的长度, 最后一个区块id, 交易信息 t = MyThread(target=pitman.mine, args=(pitman, len(self.chain_list), # 获取当前这个区块链的最后一个区块的id self.get_last_block.get_block_info()[&#39;Hash&#39;], # 获取交易信息 self.get_trans())) # t = MyThread(target=self.pitman_list[i].mine, ) t.start() t.join() # 存储挖出来的区块 self.result_list.append(t.get_result()) print(&quot;All blocks generated by pitmen:&quot;) # 挖完了之后就该打印挖到的区块了 # 上一个循环是同时启动六个矿工的线程开始运行, 等运行都完毕之后, 才开始继续主程序的运行, 是这样的吗? for result in self.result_list: print(result[0].get_block_info()) # 获取新的区块 # 先找到这个符合标准的区块 # 先取出来第一个挖出来的区块 first_block = self.result_list[0][0] # 再获取第一个区块计算耗费的时间, 转换成标准小数 min_time = Decimal(self.result_list[0][1]) # 去寻找那个用时最短的矿工挖出来的区块 for i in range(1, len(self.result_list)): if Decimal(self.result_list[i][1]) &lt; min_time: first_block = self.result_list[i][0] # 找到以后存储 self.chain_list.append(first_block) # 清空结果列表 self.result_list = [] 展示区块链信息方法 def show_chain(self): for block in self.chain_list: print(block.get_block_info()) 至此, 一个完整的简单区块链写完了, 跑一下 if __name__ == &#39;__main__&#39;: chain = BlockChain(1) for i in range(20): chain.gen_block() chain.show_chain() 完整代码: https://github.com/luokezhen/lkz/tree/master/%E5%8C%BA%E5%9D%97%E9%93%BE 参考资料: http://blog.csdn.net/bmwgaara/article/details/79059007 以上均为我个人的学习感悟, 欢迎批评指正 交流产生灵感 : QQ: 1396737599 微信: 18500094110 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/06/7e928abfb4936f6048b74b37183ac615.html" />
<meta property="og:url" content="https://mlh.app/2018/03/06/7e928abfb4936f6048b74b37183ac615.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/luokezhen/article/details/79436942 最近看了不少关于区块链的资讯, 里面大多数都是在鼓吹这个技术有多么长远的未来. 看得多了, 自然也就产生了想要一探究竟的想法. 但是那些文章里都是些自己造的或者强行翻译过来的各种名词, 并没有具体的例子, 虽然看了但是也不能产生更加清晰的认知. 所以, 在csdn上找了一些简单的区块链示例, 尝试着写了一下. 区块类 区块链, 从名字来理解, 就是区块构成的链条. 到此, 两个基本的类已经呼之欲出了. 一个是区块类, 还有区块的容器类 class BlockChain(object): pass class Block(object): pass 先来了解一下区块. 一个区块有七个基本的属性 : index: 就是该区块的序号, 你是第多少个区块, 也叫做链高度 hash: 就是这个区块的id previous hash: 就是上一个区块的id tempstamp: 时间戳 difficulty: 该区块的难度指数 nonce: 随机数, 用于产生下一个区块 data: 用来存储这个区块对应的信息 至此, 应该能写出这个类的基本代码了. 还要有一个获取该区块信息的方法, 以便于我们查看这个区块信息 # 区块类 class Block(object): # 一个区块有七个基本的属性, 分别是序号, id, 上一个区块id, 随机数, 难度系数, 时间戳, 还有一个区块体, 记录了交易信息 def __init__(self): self.index = None # 区块的id self.hash = None self.previous_hash = None self.nonce = None self.difficulty = None self.timestamp = None self.transaction_data = None # 以字典的形式记录这个区块的信息, 并返回 def get_block_info(self): block_info = { &#39;Index&#39;: self.index, &#39;Hash&#39;: self.hash, &#39;Previous_hash&#39;: self.previous_hash, &#39;Nonce&#39;: self.nonce, &#39;Difficulty&#39;: self.difficulty, &#39;Timestamp&#39;: self.timestamp, &#39;Transaction_data&#39;: self.transaction_data, } return block_info 矿工类 那么区块是如何生成的呢?答案就是由矿工挖出来的. 区块里一个关键的属性就是这个区块的id, 它是通过hashlib包里的sha256计算方法计算出来的. 但是计算为什么叫做挖矿呢? 因为我们可以给这个id一个限制条件, 那么矿工就需要不停地改变内容去计算结果, 直到满足这个条件为止, 条件设置的越苛刻, 尝试的次数就越多, 计算时间也越长. 这就是挖矿的过程. 所以, 可以尝试着写出矿工类. 有一个挖矿的方法mine, 并且记录耗时, 这里我们设置的规则为id最后一位为0 class Pitman(object): # 定义矿工的挖矿方法, 需要的参数为该区块的序号, 之前的id, 交易信息 def mine(self, index, previous_hash, transaction_data): # print(&#39;我要开始挖了&#39;) # 开始时间 begin_time = time.time() block = Block() block.index = index block.previous_hash = previous_hash block.transaction_data = transaction_data block.timestamp = time.time() # 根据之前的id和交易信息生成这个区块的id和随机数, 还有困难系数 block.difficulty, block.hash, block.nonce = self.gen_hash(previous_hash, transaction_data) # 结束时间 end_time = time.time() # 花费的时间 spend_time = end_time - begin_time # print(&#39;我挖完了&#39;) return block, spend_time 上面的代码中记录了耗时, 使用了我们的区块类, 并设置了对应的属性, 至于id值, 我们另写一个方法来获取 @staticmethod def gen_hash(previous_hash, transaction_data): # 随机数, 从1到99999随机取值 nonce = random.randrange(1, 99999) difficulty = 0 # 先生成一个字符串, 然后尝试, 不符合要求再修改 guess = str(previous_hash) + str(nonce) + transaction_data # 计算出id res = hashlib.sha256(guess.encode()).hexdigest() # 验证生成的id是否符合要求, 这里设定的要求是最后一位为0 while res[-1] != &#39;0&#39;: # 每尝试一次, 难度系数就+1 difficulty += 1 nonce += difficulty guess = previous_hash + str(nonce) + transaction_data res = hashlib.sha256(guess.encode()).hexdigest() # 得到符合要求的id后, 返回难度系数, id值和随机数 return difficulty, res, nonce 多线程 我们希望可以同时让多个矿工进行挖矿 # 自定义线程类 class MyThread(Thread): def __init__(self, target, args=()): super(MyThread, self).__init__() self.func = target self.arg = args # self.result = None def run(self): self.result = self.func(*self.arg) def get_result(self): try: return self.result except Exception as e: print(&#39;自定义线程获取结果时发生了错误:&#39;, e) return None 继承线程类并重写run方法 区块链类 每一个区块都是根据上一个区块的id产生的, 那么第一个区块没有上一个区块, 就需要我们来自己设置, 第一个区块被叫做创世区块 # 首先, 创建一个区块链类 class BlockChain(object): def __init__(self, hash_num): # 存储区块链对象, 区块的容器 self.chain_list = [] # 矿工的容器 self.pitman_list = [] # 然后再容器中填入6个矿工 for i in range(6): self.pitman_list.append(Pitman) # 存储每个阶段产生的区块 self.result_list = [] # 创建区块的方法, 如果当前生成的区块为第一个区块，则产生创世区块 self.gen_block(hash_num) 因为每个区块都是由上一个区块计算出来的, 所以我们需要一个获取上一个区块的方法, 也就是此时区块链中最后一个区块 # 获取最后一个区块 @property def get_last_block(self): if len(self.chain_list): return self.chain_list[-1] return None 还需要交易信息, 这里我们随机生成一个就好 # 随机生成一份交易信息, 交易信息就是json字符串 def get_trans(self): dict_data = { # random.sample可以从一个序列中随机获取指定数量的元素 &#39;sender&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), &#39;recipient&#39;: &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 8)), # 相当于random.choice(range(1, 10000)) &#39;amount&#39;: random.randrange(1, 10000), } return json.dumps(dict_data) 接下来就是生成新区块了, 这里需要区分它是否是创世区块, 因为生成规则不同 如果是创世区块 # 生成新区块的方法 def gen_block(self, initial_hash=None): # 根据传参判断是否是创世区块 # 如果是创世区块 if initial_hash: # 先用区块类定义一个区块 block = Block() # 然后对创建好的对象的实例属性进行设置 block.index = 0 block.nonce = random.randrange(0, 99999) block.previous_hash = &#39;0&#39; # 写到此, 我并不知道这个0是怎么来的, 以后是不是还要赋其他值? # 已经了解了, 0就是创世区块, 第一个, 所以是0 block.difficulty = 0 # 区块的交易信息 block.transaction_data = self.get_trans() # 哈希值 # guess = f&#39;{block.previousHash}{block.nonce}{block.transactionData}&#39;.encode() # 这个写法我没有看懂 # 看懂了, 是字符串格式化的另一种写法: f写法 guess = str(block.index) + str(block.nonce) + block.previous_hash block.hash = hashlib.sha256(guess.encode()).hexdigest() block.timestamp = time.time() self.chain_list.append(block) 否则 # 如果不是创世区块 else: # 先启动六个矿工开始挖矿 for pitman in self.pitman_list: # for i in range(len(self.pitman_list)): # todo: 参数先不写, 以后在写 # 参数为这个矿工类, 链此时的长度, 最后一个区块id, 交易信息 t = MyThread(target=pitman.mine, args=(pitman, len(self.chain_list), # 获取当前这个区块链的最后一个区块的id self.get_last_block.get_block_info()[&#39;Hash&#39;], # 获取交易信息 self.get_trans())) # t = MyThread(target=self.pitman_list[i].mine, ) t.start() t.join() # 存储挖出来的区块 self.result_list.append(t.get_result()) print(&quot;All blocks generated by pitmen:&quot;) # 挖完了之后就该打印挖到的区块了 # 上一个循环是同时启动六个矿工的线程开始运行, 等运行都完毕之后, 才开始继续主程序的运行, 是这样的吗? for result in self.result_list: print(result[0].get_block_info()) # 获取新的区块 # 先找到这个符合标准的区块 # 先取出来第一个挖出来的区块 first_block = self.result_list[0][0] # 再获取第一个区块计算耗费的时间, 转换成标准小数 min_time = Decimal(self.result_list[0][1]) # 去寻找那个用时最短的矿工挖出来的区块 for i in range(1, len(self.result_list)): if Decimal(self.result_list[i][1]) &lt; min_time: first_block = self.result_list[i][0] # 找到以后存储 self.chain_list.append(first_block) # 清空结果列表 self.result_list = [] 展示区块链信息方法 def show_chain(self): for block in self.chain_list: print(block.get_block_info()) 至此, 一个完整的简单区块链写完了, 跑一下 if __name__ == &#39;__main__&#39;: chain = BlockChain(1) for i in range(20): chain.gen_block() chain.show_chain() 完整代码: https://github.com/luokezhen/lkz/tree/master/%E5%8C%BA%E5%9D%97%E9%93%BE 参考资料: http://blog.csdn.net/bmwgaara/article/details/79059007 以上均为我个人的学习感悟, 欢迎批评指正 交流产生灵感 : QQ: 1396737599 微信: 18500094110 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/06/7e928abfb4936f6048b74b37183ac615.html","headline":"区块链的简单理解以及python的简单实现","dateModified":"2018-03-06T00:00:00+08:00","datePublished":"2018-03-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/06/7e928abfb4936f6048b74b37183ac615.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链的简单理解以及python的简单实现</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/luokezhen/article/details/79436942 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>最近看了不少关于区块链的资讯, 里面大多数都是在鼓吹这个技术有多么长远的未来. 看得多了, 自然也就产生了想要一探究竟的想法. 但是那些文章里都是些自己造的或者强行翻译过来的各种名词, 并没有具体的例子, 虽然看了但是也不能产生更加清晰的认知. 所以, 在csdn上找了一些简单的区块链示例, 尝试着写了一下.</p> 
  <hr> 
  <h1 id="区块类">区块类</h1> 
  <p>区块链, 从名字来理解, 就是区块构成的链条. 到此, 两个基本的类已经呼之欲出了. 一个是区块类, 还有区块的容器类</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockChain</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-keyword">pass</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Block</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-keyword">pass</span></code></pre> 
  <p>先来了解一下区块. 一个区块有七个基本的属性 :</p> 
  <ol> 
   <li>index: 就是该区块的序号, 你是第多少个区块, 也叫做链高度</li> 
   <li>hash: 就是这个区块的id</li> 
   <li>previous hash: 就是上一个区块的id</li> 
   <li>tempstamp: 时间戳</li> 
   <li>difficulty: 该区块的难度指数</li> 
   <li>nonce: 随机数, 用于产生下一个区块</li> 
   <li>data: 用来存储这个区块对应的信息</li> 
  </ol> 
  <p>至此, 应该能写出这个类的基本代码了. 还要有一个获取该区块信息的方法, 以便于我们查看这个区块信息</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 区块类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Block</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-comment"># 一个区块有七个基本的属性, 分别是序号, id, 上一个区块id, 随机数, 难度系数, 时间戳, 还有一个区块体, 记录了交易信息</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.index = <span class="hljs-keyword">None</span>
        <span class="hljs-comment"># 区块的id</span>
        self.hash = <span class="hljs-keyword">None</span>
        self.previous_hash = <span class="hljs-keyword">None</span>
        self.nonce = <span class="hljs-keyword">None</span>
        self.difficulty = <span class="hljs-keyword">None</span>
        self.timestamp = <span class="hljs-keyword">None</span>
        self.transaction_data = <span class="hljs-keyword">None</span>

    <span class="hljs-comment"># 以字典的形式记录这个区块的信息, 并返回</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_block_info</span><span class="hljs-params">(self)</span>:</span>
        block_info = {
            <span class="hljs-string">'Index'</span>: self.index,
            <span class="hljs-string">'Hash'</span>: self.hash,
            <span class="hljs-string">'Previous_hash'</span>: self.previous_hash,
            <span class="hljs-string">'Nonce'</span>: self.nonce,
            <span class="hljs-string">'Difficulty'</span>: self.difficulty,
            <span class="hljs-string">'Timestamp'</span>: self.timestamp,
            <span class="hljs-string">'Transaction_data'</span>: self.transaction_data,
        }
        <span class="hljs-keyword">return</span> block_info</code></pre> 
  <hr> 
  <h1 id="矿工类">矿工类</h1> 
  <p>那么区块是如何生成的呢?答案就是由矿工挖出来的. 区块里一个关键的属性就是这个区块的id, 它是通过hashlib包里的sha256计算方法计算出来的. 但是计算为什么叫做挖矿呢? 因为我们可以给这个id一个限制条件, 那么矿工就需要不停地改变内容去计算结果, 直到满足这个条件为止, 条件设置的越苛刻, 尝试的次数就越多, 计算时间也越长. 这就是挖矿的过程.</p> 
  <p>所以, 可以尝试着写出矿工类. 有一个挖矿的方法mine, 并且记录耗时, 这里我们设置的规则为id最后一位为0</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pitman</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-comment"># 定义矿工的挖矿方法, 需要的参数为该区块的序号, 之前的id, 交易信息</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mine</span><span class="hljs-params">(self, index, previous_hash, transaction_data)</span>:</span>
        <span class="hljs-comment"># print('我要开始挖了')</span>
        <span class="hljs-comment"># 开始时间</span>
        begin_time = time.time()

        block = Block()
        block.index = index
        block.previous_hash = previous_hash
        block.transaction_data = transaction_data
        block.timestamp = time.time()
        <span class="hljs-comment"># 根据之前的id和交易信息生成这个区块的id和随机数, 还有困难系数</span>
        block.difficulty, block.hash, block.nonce = self.gen_hash(previous_hash, transaction_data)

        <span class="hljs-comment"># 结束时间</span>
        end_time = time.time()
        <span class="hljs-comment"># 花费的时间</span>
        spend_time = end_time - begin_time
        <span class="hljs-comment"># print('我挖完了')</span>

        <span class="hljs-keyword">return</span> block, spend_time</code></pre> 
  <p>上面的代码中记录了耗时, 使用了我们的区块类, 并设置了对应的属性, 至于id值, 我们另写一个方法来获取</p> 
  <pre class="prettyprint"><code class="language-python hljs ">    <span class="hljs-decorator">@staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_hash</span><span class="hljs-params">(previous_hash, transaction_data)</span>:</span>
        <span class="hljs-comment"># 随机数, 从1到99999随机取值</span>
        nonce = random.randrange(<span class="hljs-number">1</span>, <span class="hljs-number">99999</span>)

        difficulty = <span class="hljs-number">0</span>
        <span class="hljs-comment"># 先生成一个字符串, 然后尝试, 不符合要求再修改</span>
        guess = str(previous_hash) + str(nonce) + transaction_data
        <span class="hljs-comment"># 计算出id</span>
        res = hashlib.sha256(guess.encode()).hexdigest()

        <span class="hljs-comment"># 验证生成的id是否符合要求, 这里设定的要求是最后一位为0</span>
        <span class="hljs-keyword">while</span> res[-<span class="hljs-number">1</span>] != <span class="hljs-string">'0'</span>:
            <span class="hljs-comment"># 每尝试一次, 难度系数就+1</span>
            difficulty += <span class="hljs-number">1</span>
            nonce += difficulty
            guess = previous_hash + str(nonce) + transaction_data
            res = hashlib.sha256(guess.encode()).hexdigest()
        <span class="hljs-comment"># 得到符合要求的id后, 返回难度系数, id值和随机数</span>
        <span class="hljs-keyword">return</span> difficulty, res, nonce</code></pre> 
  <hr> 
  <h1 id="多线程">多线程</h1> 
  <p>我们希望可以同时让多个矿工进行挖矿</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 自定义线程类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(Thread)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, target, args=<span class="hljs-params">()</span>)</span>:</span>
        super(MyThread, self).__init__()
        self.func = target
        self.arg = args
        <span class="hljs-comment"># self.result = None</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span>
        self.result = self.func(*self.arg)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_result</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">return</span> self.result
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            print(<span class="hljs-string">'自定义线程获取结果时发生了错误:'</span>, e)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span></code></pre> 
  <p>继承线程类并重写run方法</p> 
  <hr> 
  <h1 id="区块链类">区块链类</h1> 
  <p>每一个区块都是根据上一个区块的id产生的, 那么第一个区块没有上一个区块, 就需要我们来自己设置, 第一个区块被叫做创世区块</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 首先, 创建一个区块链类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockChain</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, hash_num)</span>:</span>
        <span class="hljs-comment"># 存储区块链对象, 区块的容器</span>
        self.chain_list = []

        <span class="hljs-comment"># 矿工的容器</span>
        self.pitman_list = []

        <span class="hljs-comment"># 然后再容器中填入6个矿工</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):
            self.pitman_list.append(Pitman)

        <span class="hljs-comment"># 存储每个阶段产生的区块</span>
        self.result_list = []

        <span class="hljs-comment"># 创建区块的方法, 如果当前生成的区块为第一个区块，则产生创世区块</span>
        self.gen_block(hash_num)</code></pre> 
  <p>因为每个区块都是由上一个区块计算出来的, 所以我们需要一个获取上一个区块的方法, 也就是此时区块链中最后一个区块</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 获取最后一个区块</span>
    <span class="hljs-decorator">@property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_last_block</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> len(self.chain_list):
            <span class="hljs-keyword">return</span> self.chain_list[-<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span></code></pre> 
  <p>还需要交易信息, 这里我们随机生成一个就好</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 随机生成一份交易信息, 交易信息就是json字符串</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_trans</span><span class="hljs-params">(self)</span>:</span>
        dict_data = {
            <span class="hljs-comment"># random.sample可以从一个序列中随机获取指定数量的元素</span>
            <span class="hljs-string">'sender'</span>: <span class="hljs-string">''</span>.join(random.sample(string.ascii_letters + string.digits, <span class="hljs-number">8</span>)),
            <span class="hljs-string">'recipient'</span>: <span class="hljs-string">''</span>.join(random.sample(string.ascii_letters + string.digits, <span class="hljs-number">8</span>)),
            <span class="hljs-comment"># 相当于random.choice(range(1, 10000))</span>
            <span class="hljs-string">'amount'</span>: random.randrange(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>),
    }
    <span class="hljs-keyword">return</span> json.dumps(dict_data)</code></pre> 
  <p>接下来就是生成新区块了, 这里需要区分它是否是创世区块, 因为生成规则不同 <br> 如果是创世区块</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 生成新区块的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_block</span><span class="hljs-params">(self, initial_hash=None)</span>:</span>
        <span class="hljs-comment"># 根据传参判断是否是创世区块</span>

        <span class="hljs-comment"># 如果是创世区块</span>
        <span class="hljs-keyword">if</span> initial_hash:
            <span class="hljs-comment"># 先用区块类定义一个区块</span>
            block = Block()
            <span class="hljs-comment"># 然后对创建好的对象的实例属性进行设置</span>
            block.index = <span class="hljs-number">0</span>
            block.nonce = random.randrange(<span class="hljs-number">0</span>, <span class="hljs-number">99999</span>)
            block.previous_hash = <span class="hljs-string">'0'</span>
            <span class="hljs-comment"># 写到此, 我并不知道这个0是怎么来的, 以后是不是还要赋其他值?</span>
            <span class="hljs-comment"># 已经了解了, 0就是创世区块, 第一个, 所以是0</span>

            block.difficulty = <span class="hljs-number">0</span>
            <span class="hljs-comment"># 区块的交易信息</span>
            block.transaction_data = self.get_trans()

            <span class="hljs-comment"># 哈希值</span>
            <span class="hljs-comment"># guess = f'{block.previousHash}{block.nonce}{block.transactionData}'.encode()</span>
            <span class="hljs-comment"># 这个写法我没有看懂</span>
            <span class="hljs-comment"># 看懂了, 是字符串格式化的另一种写法: f写法</span>
            guess = str(block.index) + str(block.nonce) + block.previous_hash
            block.hash = hashlib.sha256(guess.encode()).hexdigest()

            block.timestamp = time.time()

            self.chain_list.append(block)</code></pre> 
  <p>否则</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 如果不是创世区块</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># 先启动六个矿工开始挖矿</span>
            <span class="hljs-keyword">for</span> pitman <span class="hljs-keyword">in</span> self.pitman_list:
            <span class="hljs-comment"># for i in range(len(self.pitman_list)):</span>
                <span class="hljs-comment"># todo: 参数先不写, 以后在写</span>
                <span class="hljs-comment"># 参数为这个矿工类, 链此时的长度, 最后一个区块id, 交易信息</span>
                t = MyThread(target=pitman.mine, args=(pitman,
                                                       len(self.chain_list),
                                                       <span class="hljs-comment"># 获取当前这个区块链的最后一个区块的id</span>
                                                       self.get_last_block.get_block_info()[<span class="hljs-string">'Hash'</span>],
                                                       <span class="hljs-comment"># 获取交易信息</span>
                                                       self.get_trans()))

                <span class="hljs-comment"># t = MyThread(target=self.pitman_list[i].mine, )</span>
                t.start()
                t.join()

                <span class="hljs-comment"># 存储挖出来的区块</span>
                self.result_list.append(t.get_result())

            print(<span class="hljs-string">"All blocks generated by pitmen:"</span>)
            <span class="hljs-comment"># 挖完了之后就该打印挖到的区块了</span>
            <span class="hljs-comment"># 上一个循环是同时启动六个矿工的线程开始运行, 等运行都完毕之后, 才开始继续主程序的运行, 是这样的吗?</span>
            <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> self.result_list:
                print(result[<span class="hljs-number">0</span>].get_block_info())

            <span class="hljs-comment"># 获取新的区块</span>
            <span class="hljs-comment"># 先找到这个符合标准的区块</span>

            <span class="hljs-comment"># 先取出来第一个挖出来的区块</span>
            first_block = self.result_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
            <span class="hljs-comment"># 再获取第一个区块计算耗费的时间, 转换成标准小数</span>
            min_time = Decimal(self.result_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])

            <span class="hljs-comment"># 去寻找那个用时最短的矿工挖出来的区块</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(self.result_list)):
                <span class="hljs-keyword">if</span> Decimal(self.result_list[i][<span class="hljs-number">1</span>]) &lt; min_time:
                    first_block = self.result_list[i][<span class="hljs-number">0</span>]

            <span class="hljs-comment"># 找到以后存储</span>
            self.chain_list.append(first_block)
            <span class="hljs-comment"># 清空结果列表</span>
            self.result_list = []</code></pre> 
  <p>展示区块链信息方法</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_chain</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> self.chain_list:
            print(block.get_block_info())</code></pre> 
  <hr> 
  <p>至此, 一个完整的简单区块链写完了, 跑一下</p> 
  <pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    chain = BlockChain(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):
        chain.gen_block()
    chain.show_chain()</code></pre> 
  <hr> 
  <p>完整代码: <br> <a href="https://github.com/luokezhen/lkz/tree/master/%E5%8C%BA%E5%9D%97%E9%93%BE" rel="nofollow">https://github.com/luokezhen/lkz/tree/master/%E5%8C%BA%E5%9D%97%E9%93%BE</a> <br> 参考资料: <br> <a href="http://blog.csdn.net/bmwgaara/article/details/79059007" rel="nofollow">http://blog.csdn.net/bmwgaara/article/details/79059007</a></p> 
  <hr> 
  <p>以上均为我个人的学习感悟, 欢迎批评指正</p> 
  <h4 id="交流产生灵感"><strong>交流产生灵感 : </strong></h4> 
  <p>QQ: 1396737599 <br> 微信: 18500094110</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-778f64ae39.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/luokezhen/article/details/79436942,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/luokezhen/article/details/79436942,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
