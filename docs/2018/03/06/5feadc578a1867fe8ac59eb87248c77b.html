<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Linux下文件描述符剖析 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Linux下文件描述符剖析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Linux文件IO open、dup、fork内核原理分析 1、open一个文件 一个Linux进程启动后，会在内核空间创建一个PCB进程控制块，PCB是一个进程的私有财产。 这个PCB中有一个已打开文件描述符表，记录着所有该进程打开的文件描述符以及对应的file结构体地址。 默认情况下，启动一个Linux进程后，会打开三个文件，分别是标准输入、标准输出、标准错误分别使用了0、1 、2号文件描述符。 当该进程使用函数open打开一个新的文件时，一般会在内核空间申请一个file结构体，并且把3号文件描述符对应的file指针指向file结构体。 代码如下： testOpen.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;new fd = %d\n&quot;, fd); } 原理图如下： process table entry就是进程的文件描述符表，file table entry用来记录文件的读写打开模式，当前文件偏移量，以及v-node指针。 v-node table entry是虚拟文件系统对应的文件节点，i-node是磁盘文件系统对应的文件节点。通过这两个节点就能找到最终的磁盘文件。 每一个进程只有一个process table entry，一般情况下默认使用 fd 0、fd1、fd2，新打开的文件log.txt将使用 fd 3。 2、两个进程同时open一个文件 两个进程同时open一个文件，这个时候的原理图如下： 因为现在是两个进程，所以process table entry进程控制块也是两个，每个进程控制块中各自维护一个张文件描述符表，同时打开一个文件的时候，都各自申请了一个file table entry。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于打开的是同一一个文件，所以file table entry都指向了同一个v-node。 两个file table entry，怎么去证明呢？ test2open.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;new fd = %d\n&quot;, fd); &nbsp; &nbsp;printf(&quot;%ld\n&quot;, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3); &nbsp; &nbsp;sleep(5); &nbsp; &nbsp;printf(&quot;%ld\n&quot;, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd); } file table entry中都保存了一个文件读写偏移量，如果是两个file table entry，那么两个进程读写位置是独立的，不受影响的。 上面的代码运行结果是： #先启动进程0 $ ./a.out new fd = 3 0 3 ​ #在5秒时间内，启动进程1 $ ./a.out new fd = 3 0 3 两个进程都分配了fd 3 给新打开个文件，并且读写位置不受其他进程的影响 。如果受影响了话，进程1的读写位置要变成3和6. 3 一个进程open两次同一个文件 一个进程open两次同一个文件，其实跟两个进程open一次的原理相同，都是调用了两次open，反正只要记住，调用一次open函数，就会创建一个file table entry。 原理图如下： 由于只有一个进程，所以只有一个process table entry，open了两次，所以是两个file table entry 分别分配了fd 3与fd 4指向这两个结构体。 代码如下： #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd0 = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;int fd1 = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;new fd0 = %d\n&quot;, fd0); &nbsp; &nbsp;printf(&quot;new fd1 = %d\n&quot;, fd1); ​ &nbsp; &nbsp;write(fd0, &quot;123&quot;, 3); ​ &nbsp; &nbsp;printf(&quot;fd0 lseek %ld\n&quot;, lseek(fd0, 0, SEEK_CUR)); &nbsp; &nbsp;printf(&quot;fd1 lseek %ld\n&quot;, lseek(fd1, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd0); &nbsp; &nbsp;close(fd1); } 上面代码open了两次log.txt，创建了两个file结构体，验证方法还是通过判断读写位置是否是独立的。 运行结果： new fd0 = 3 new fd1 = 3 fd0 lseek 3 fd1 lseek 0 结果已经说明一切了，修改fd0的读写位置不会影响fd1的读写位置。 4、使用dup复制文件描述符 dup函数与open函数不同，open函数会创建一个file table，但是dup只是申请一个fd来指向一个已经存在的file table。原理图如下： &nbsp;&nbsp;&nbsp;&nbsp; 代码 testdup.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd, copyfd; &nbsp; &nbsp;fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;/*复制fd*/ &nbsp; &nbsp;copyfd = dup(fd); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3) &nbsp; &nbsp;/*打印出fd和copyfd的偏移量，经过上面的写操作，都变成3了*/ &nbsp; &nbsp;printf(&quot;fd lseek %ld\n&quot;, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;printf(&quot;copyfd lseek %ld\n&quot;, lseek(copyfd, 0, SEEK_CUR)); close(fd); &nbsp; &nbsp;close(copyfd); &nbsp; &nbsp;return 0; } 运行结果： $ ./a.out fd lseek 3 copyfd lseek 3 结果证明只要操作了fd 或copyfd这两个文件描述符中一个的读写位置，就会影响到另一个文件描述符的读写位置。说明这两个文件描述符指向的是同一个file table。 需要注意的是，一旦dup了一次，就会file table引用计数加一，如果想要释放file table的内存，必须要把open以及所有dup出来的文件描述符都关闭掉。 5、fork之后open 如果在调用fork之后调用一次open函数，由于fork之后会返回两次，一次父进程返回，一次子进程返回，那么这个时候其实是相当与两个进程分别调用了一次open函数打开同一个文件，与第二节中的原理相同。 代码如下：testforkopen.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int pid = fork(); &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;pid %d %ld\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3); &nbsp; &nbsp;sleep(5); &nbsp; &nbsp;printf(&quot;pid %d %ld\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd); } 运行结果： $ ./a.out pid 6112 lseek 0 &nbsp;#父进程 pid 0 lseek 0 &nbsp; &nbsp; #子进程 pid 6112 lseek 3 &nbsp;#父进程 pid 0 lseek 3 &nbsp;#子进程 可以看到父子进程的读写位置都是3，并不受影响。 6 fork之前open fork之前调用open函数，也就是只调用了一次，产生了一个fd以及file table，fork之后子进程的process table entry会从父亲进程中复制过来，文件描述表也复制过来了，那么子进程的fd指向的是同一个file table。 原理图如下： 代码如下：testopenfork.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;int pid = fork(); &nbsp; &nbsp;printf(&quot;pid %d %ld\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3); &nbsp; &nbsp;sleep(5); &nbsp; &nbsp;printf(&quot;pid %d %ld\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd); } 运行结果： $ ./a.out pid 6388 lseek 0 pid 0 lseek 3 pid 6388 lseek 6 pid 0 lseek 6 父子进程都各自写入3字节，如果是两个file table，那么最终都应该打印的是3，而不是6，请与第5节进行对比。 需要注意的是：如果想要释放这个file table，也必须父子进程都close一次fd才会释放，如果不close，进程退出的时候会自动close掉所有的文件描述符。 阅读更多" />
<meta property="og:description" content="Linux文件IO open、dup、fork内核原理分析 1、open一个文件 一个Linux进程启动后，会在内核空间创建一个PCB进程控制块，PCB是一个进程的私有财产。 这个PCB中有一个已打开文件描述符表，记录着所有该进程打开的文件描述符以及对应的file结构体地址。 默认情况下，启动一个Linux进程后，会打开三个文件，分别是标准输入、标准输出、标准错误分别使用了0、1 、2号文件描述符。 当该进程使用函数open打开一个新的文件时，一般会在内核空间申请一个file结构体，并且把3号文件描述符对应的file指针指向file结构体。 代码如下： testOpen.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;new fd = %d\n&quot;, fd); } 原理图如下： process table entry就是进程的文件描述符表，file table entry用来记录文件的读写打开模式，当前文件偏移量，以及v-node指针。 v-node table entry是虚拟文件系统对应的文件节点，i-node是磁盘文件系统对应的文件节点。通过这两个节点就能找到最终的磁盘文件。 每一个进程只有一个process table entry，一般情况下默认使用 fd 0、fd1、fd2，新打开的文件log.txt将使用 fd 3。 2、两个进程同时open一个文件 两个进程同时open一个文件，这个时候的原理图如下： 因为现在是两个进程，所以process table entry进程控制块也是两个，每个进程控制块中各自维护一个张文件描述符表，同时打开一个文件的时候，都各自申请了一个file table entry。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于打开的是同一一个文件，所以file table entry都指向了同一个v-node。 两个file table entry，怎么去证明呢？ test2open.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;new fd = %d\n&quot;, fd); &nbsp; &nbsp;printf(&quot;%ld\n&quot;, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3); &nbsp; &nbsp;sleep(5); &nbsp; &nbsp;printf(&quot;%ld\n&quot;, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd); } file table entry中都保存了一个文件读写偏移量，如果是两个file table entry，那么两个进程读写位置是独立的，不受影响的。 上面的代码运行结果是： #先启动进程0 $ ./a.out new fd = 3 0 3 ​ #在5秒时间内，启动进程1 $ ./a.out new fd = 3 0 3 两个进程都分配了fd 3 给新打开个文件，并且读写位置不受其他进程的影响 。如果受影响了话，进程1的读写位置要变成3和6. 3 一个进程open两次同一个文件 一个进程open两次同一个文件，其实跟两个进程open一次的原理相同，都是调用了两次open，反正只要记住，调用一次open函数，就会创建一个file table entry。 原理图如下： 由于只有一个进程，所以只有一个process table entry，open了两次，所以是两个file table entry 分别分配了fd 3与fd 4指向这两个结构体。 代码如下： #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd0 = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;int fd1 = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;new fd0 = %d\n&quot;, fd0); &nbsp; &nbsp;printf(&quot;new fd1 = %d\n&quot;, fd1); ​ &nbsp; &nbsp;write(fd0, &quot;123&quot;, 3); ​ &nbsp; &nbsp;printf(&quot;fd0 lseek %ld\n&quot;, lseek(fd0, 0, SEEK_CUR)); &nbsp; &nbsp;printf(&quot;fd1 lseek %ld\n&quot;, lseek(fd1, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd0); &nbsp; &nbsp;close(fd1); } 上面代码open了两次log.txt，创建了两个file结构体，验证方法还是通过判断读写位置是否是独立的。 运行结果： new fd0 = 3 new fd1 = 3 fd0 lseek 3 fd1 lseek 0 结果已经说明一切了，修改fd0的读写位置不会影响fd1的读写位置。 4、使用dup复制文件描述符 dup函数与open函数不同，open函数会创建一个file table，但是dup只是申请一个fd来指向一个已经存在的file table。原理图如下： &nbsp;&nbsp;&nbsp;&nbsp; 代码 testdup.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd, copyfd; &nbsp; &nbsp;fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;/*复制fd*/ &nbsp; &nbsp;copyfd = dup(fd); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3) &nbsp; &nbsp;/*打印出fd和copyfd的偏移量，经过上面的写操作，都变成3了*/ &nbsp; &nbsp;printf(&quot;fd lseek %ld\n&quot;, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;printf(&quot;copyfd lseek %ld\n&quot;, lseek(copyfd, 0, SEEK_CUR)); close(fd); &nbsp; &nbsp;close(copyfd); &nbsp; &nbsp;return 0; } 运行结果： $ ./a.out fd lseek 3 copyfd lseek 3 结果证明只要操作了fd 或copyfd这两个文件描述符中一个的读写位置，就会影响到另一个文件描述符的读写位置。说明这两个文件描述符指向的是同一个file table。 需要注意的是，一旦dup了一次，就会file table引用计数加一，如果想要释放file table的内存，必须要把open以及所有dup出来的文件描述符都关闭掉。 5、fork之后open 如果在调用fork之后调用一次open函数，由于fork之后会返回两次，一次父进程返回，一次子进程返回，那么这个时候其实是相当与两个进程分别调用了一次open函数打开同一个文件，与第二节中的原理相同。 代码如下：testforkopen.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int pid = fork(); &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;pid %d %ld\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3); &nbsp; &nbsp;sleep(5); &nbsp; &nbsp;printf(&quot;pid %d %ld\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd); } 运行结果： $ ./a.out pid 6112 lseek 0 &nbsp;#父进程 pid 0 lseek 0 &nbsp; &nbsp; #子进程 pid 6112 lseek 3 &nbsp;#父进程 pid 0 lseek 3 &nbsp;#子进程 可以看到父子进程的读写位置都是3，并不受影响。 6 fork之前open fork之前调用open函数，也就是只调用了一次，产生了一个fd以及file table，fork之后子进程的process table entry会从父亲进程中复制过来，文件描述表也复制过来了，那么子进程的fd指向的是同一个file table。 原理图如下： 代码如下：testopenfork.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;int pid = fork(); &nbsp; &nbsp;printf(&quot;pid %d %ld\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3); &nbsp; &nbsp;sleep(5); &nbsp; &nbsp;printf(&quot;pid %d %ld\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd); } 运行结果： $ ./a.out pid 6388 lseek 0 pid 0 lseek 3 pid 6388 lseek 6 pid 0 lseek 6 父子进程都各自写入3字节，如果是两个file table，那么最终都应该打印的是3，而不是6，请与第5节进行对比。 需要注意的是：如果想要释放这个file table，也必须父子进程都close一次fd才会释放，如果不close，进程退出的时候会自动close掉所有的文件描述符。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Linux文件IO open、dup、fork内核原理分析 1、open一个文件 一个Linux进程启动后，会在内核空间创建一个PCB进程控制块，PCB是一个进程的私有财产。 这个PCB中有一个已打开文件描述符表，记录着所有该进程打开的文件描述符以及对应的file结构体地址。 默认情况下，启动一个Linux进程后，会打开三个文件，分别是标准输入、标准输出、标准错误分别使用了0、1 、2号文件描述符。 当该进程使用函数open打开一个新的文件时，一般会在内核空间申请一个file结构体，并且把3号文件描述符对应的file指针指向file结构体。 代码如下： testOpen.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;new fd = %d\\n&quot;, fd); } 原理图如下： process table entry就是进程的文件描述符表，file table entry用来记录文件的读写打开模式，当前文件偏移量，以及v-node指针。 v-node table entry是虚拟文件系统对应的文件节点，i-node是磁盘文件系统对应的文件节点。通过这两个节点就能找到最终的磁盘文件。 每一个进程只有一个process table entry，一般情况下默认使用 fd 0、fd1、fd2，新打开的文件log.txt将使用 fd 3。 2、两个进程同时open一个文件 两个进程同时open一个文件，这个时候的原理图如下： 因为现在是两个进程，所以process table entry进程控制块也是两个，每个进程控制块中各自维护一个张文件描述符表，同时打开一个文件的时候，都各自申请了一个file table entry。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于打开的是同一一个文件，所以file table entry都指向了同一个v-node。 两个file table entry，怎么去证明呢？ test2open.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;new fd = %d\\n&quot;, fd); &nbsp; &nbsp;printf(&quot;%ld\\n&quot;, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3); &nbsp; &nbsp;sleep(5); &nbsp; &nbsp;printf(&quot;%ld\\n&quot;, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd); } file table entry中都保存了一个文件读写偏移量，如果是两个file table entry，那么两个进程读写位置是独立的，不受影响的。 上面的代码运行结果是： #先启动进程0 $ ./a.out new fd = 3 0 3 ​ #在5秒时间内，启动进程1 $ ./a.out new fd = 3 0 3 两个进程都分配了fd 3 给新打开个文件，并且读写位置不受其他进程的影响 。如果受影响了话，进程1的读写位置要变成3和6. 3 一个进程open两次同一个文件 一个进程open两次同一个文件，其实跟两个进程open一次的原理相同，都是调用了两次open，反正只要记住，调用一次open函数，就会创建一个file table entry。 原理图如下： 由于只有一个进程，所以只有一个process table entry，open了两次，所以是两个file table entry 分别分配了fd 3与fd 4指向这两个结构体。 代码如下： #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd0 = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;int fd1 = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;new fd0 = %d\\n&quot;, fd0); &nbsp; &nbsp;printf(&quot;new fd1 = %d\\n&quot;, fd1); ​ &nbsp; &nbsp;write(fd0, &quot;123&quot;, 3); ​ &nbsp; &nbsp;printf(&quot;fd0 lseek %ld\\n&quot;, lseek(fd0, 0, SEEK_CUR)); &nbsp; &nbsp;printf(&quot;fd1 lseek %ld\\n&quot;, lseek(fd1, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd0); &nbsp; &nbsp;close(fd1); } 上面代码open了两次log.txt，创建了两个file结构体，验证方法还是通过判断读写位置是否是独立的。 运行结果： new fd0 = 3 new fd1 = 3 fd0 lseek 3 fd1 lseek 0 结果已经说明一切了，修改fd0的读写位置不会影响fd1的读写位置。 4、使用dup复制文件描述符 dup函数与open函数不同，open函数会创建一个file table，但是dup只是申请一个fd来指向一个已经存在的file table。原理图如下： &nbsp;&nbsp;&nbsp;&nbsp; 代码 testdup.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd, copyfd; &nbsp; &nbsp;fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;/*复制fd*/ &nbsp; &nbsp;copyfd = dup(fd); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3) &nbsp; &nbsp;/*打印出fd和copyfd的偏移量，经过上面的写操作，都变成3了*/ &nbsp; &nbsp;printf(&quot;fd lseek %ld\\n&quot;, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;printf(&quot;copyfd lseek %ld\\n&quot;, lseek(copyfd, 0, SEEK_CUR)); close(fd); &nbsp; &nbsp;close(copyfd); &nbsp; &nbsp;return 0; } 运行结果： $ ./a.out fd lseek 3 copyfd lseek 3 结果证明只要操作了fd 或copyfd这两个文件描述符中一个的读写位置，就会影响到另一个文件描述符的读写位置。说明这两个文件描述符指向的是同一个file table。 需要注意的是，一旦dup了一次，就会file table引用计数加一，如果想要释放file table的内存，必须要把open以及所有dup出来的文件描述符都关闭掉。 5、fork之后open 如果在调用fork之后调用一次open函数，由于fork之后会返回两次，一次父进程返回，一次子进程返回，那么这个时候其实是相当与两个进程分别调用了一次open函数打开同一个文件，与第二节中的原理相同。 代码如下：testforkopen.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int pid = fork(); &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;printf(&quot;pid %d %ld\\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3); &nbsp; &nbsp;sleep(5); &nbsp; &nbsp;printf(&quot;pid %d %ld\\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd); } 运行结果： $ ./a.out pid 6112 lseek 0 &nbsp;#父进程 pid 0 lseek 0 &nbsp; &nbsp; #子进程 pid 6112 lseek 3 &nbsp;#父进程 pid 0 lseek 3 &nbsp;#子进程 可以看到父子进程的读写位置都是3，并不受影响。 6 fork之前open fork之前调用open函数，也就是只调用了一次，产生了一个fd以及file table，fork之后子进程的process table entry会从父亲进程中复制过来，文件描述表也复制过来了，那么子进程的fd指向的是同一个file table。 原理图如下： 代码如下：testopenfork.c #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { &nbsp; &nbsp;int fd = open(&quot;./log.txt&quot;, O_RDWR); &nbsp; &nbsp;int pid = fork(); &nbsp; &nbsp;printf(&quot;pid %d %ld\\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;write(fd, &quot;123&quot;, 3); &nbsp; &nbsp;sleep(5); &nbsp; &nbsp;printf(&quot;pid %d %ld\\n&quot;, pid, lseek(fd, 0, SEEK_CUR)); &nbsp; &nbsp;close(fd); } 运行结果： $ ./a.out pid 6388 lseek 0 pid 0 lseek 3 pid 6388 lseek 6 pid 0 lseek 6 父子进程都各自写入3字节，如果是两个file table，那么最终都应该打印的是3，而不是6，请与第5节进行对比。 需要注意的是：如果想要释放这个file table，也必须父子进程都close一次fd才会释放，如果不close，进程退出的时候会自动close掉所有的文件描述符。 阅读更多","@type":"BlogPosting","url":"/2018/03/06/5feadc578a1867fe8ac59eb87248c77b.html","headline":"Linux下文件描述符剖析","dateModified":"2018-03-06T00:00:00+08:00","datePublished":"2018-03-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/03/06/5feadc578a1867fe8ac59eb87248c77b.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Linux下文件描述符剖析</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h2 class="md-end-block md-heading md-focus" style="font-size:1.75em;line-height:1.225;border-bottom:1px solid rgb(238,238,238);color:rgb(57,172,171);text-align:center;width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"></h2>
  <h1 class="md-end-block md-heading md-focus" style="color:rgb(50,57,186);font-size:2.25em;line-height:1.2;border-bottom:1px solid rgb(238,238,238);text-align:center;width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-expand">Linux文件IO open、dup、fork内核原理分析</span></h1>
  <h2 class="md-end-block md-heading" style="color:rgb(57,172,171);font-size:1.75em;line-height:1.225;border-bottom:1px solid rgb(238,238,238);text-align:center;width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;">1、open一个文件</h2>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 一个Linux进程启动后，会在内核空间创建一个PCB进程控制块，PCB是一个进程的私有财产。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 这个PCB中有一个已打开文件描述符表，记录着所有该进程打开的文件描述符以及对应的file结构体地址。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 默认情况下，启动一个Linux进程后，会打开三个文件，分别是标准输入、标准输出、标准错误分别使用了0、1 、2号文件描述符。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 当该进程使用函数open打开一个新的文件时，一般会在内核空间申请一个file结构体，并且把3号文件描述符对应的file指针指向file结构体。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 代码如下：</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">testOpen.c</span></p>
  <pre class="md-fences md-end-block" style="background-color:rgb(232,232,232);font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;color:rgb(51,51,51);text-align:left;border:1px solid rgb(221,221,221);width:inherit;"><span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;unistd.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;fcntl.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;stdio.h&gt;</span></span>
<span><span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-def" style="color:rgb(0,0,255);">main</span>(<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">argc</span>, <span class="cm-variable-3" style="color:rgb(0,136,85);">char</span> <span class="cm-variable-3" style="color:rgb(0,136,85);">*</span><span class="cm-variable" style="color:rgb(0,0,0);">argv</span>[])</span>
<span>{</span>
<span> &nbsp; &nbsp;<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">fd</span> <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-variable" style="color:rgb(0,0,0);">open</span>(<span class="cm-string" style="color:rgb(170,17,17);">"./log.txt"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">O_RDWR</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"new fd = %d\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">fd</span>);</span>
<span>}</span></pre>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 原理图如下：</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"></span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180227141158110" alt=""><span class="md-line md-end-block"><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;text-align:center;"></span></span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> process table entry就是进程的文件描述符表，file table entry用来记录文件的读写打开模式，当前文件偏移量，以及v-node指针。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> v-node table entry是虚拟文件系统对应的文件节点，i-node是磁盘文件系统对应的文件节点。通过这两个节点就能找到最终的磁盘文件。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 每一个进程只有一个process table entry，一般情况下默认使用 fd 0、fd1、fd2，新打开的文件log.txt将使用</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">fd 3。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"></span></p>
  <h2 class="md-end-block md-heading" style="color:rgb(57,172,171);font-size:1.75em;line-height:1.225;border-bottom:1px solid rgb(238,238,238);text-align:center;width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;">2、两个进程同时open一个文件</h2>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 两个进程同时open一个文件，这个时候的原理图如下：</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180227141249683" alt=""><br></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 因为现在是两个进程，所以process table entry进程控制块也是两个，每个进程控制块中各自维护一个张文件描述符表，同时打开一个文件的时候，都各自申请了一个file table entry。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> </span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block md-focus">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于打开的是同一一个文件，所以file table entry都指向了同一个v-node。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 两个file table entry，怎么去证明呢？</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"></span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">test2open.c</span></p>
  <pre class="md-fences md-end-block" style="background-color:rgb(232,232,232);font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;color:rgb(51,51,51);text-align:left;border:1px solid rgb(221,221,221);width:inherit;"><span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;unistd.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;fcntl.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;stdio.h&gt;</span></span>
<span><span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-def" style="color:rgb(0,0,255);">main</span>(<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">argc</span>, <span class="cm-variable-3" style="color:rgb(0,136,85);">char</span> <span class="cm-variable-3" style="color:rgb(0,136,85);">*</span><span class="cm-variable" style="color:rgb(0,0,0);">argv</span>[])</span>
<span>{</span>
<span> &nbsp; &nbsp;<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">fd</span> <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-variable" style="color:rgb(0,0,0);">open</span>(<span class="cm-string" style="color:rgb(170,17,17);">"./log.txt"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">O_RDWR</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"new fd = %d\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">fd</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"%ld\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">lseek</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-number" style="color:rgb(17,102,68);">0</span>, <span class="cm-variable" style="color:rgb(0,0,0);">SEEK_CUR</span>));</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">write</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-string" style="color:rgb(170,17,17);">"123"</span>, <span class="cm-number" style="color:rgb(17,102,68);">3</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">sleep</span>(<span class="cm-number" style="color:rgb(17,102,68);">5</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"%ld\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">lseek</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-number" style="color:rgb(17,102,68);">0</span>, <span class="cm-variable" style="color:rgb(0,0,0);">SEEK_CUR</span>));</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">close</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>);</span>
<span>}</span></pre>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> file table entry中都保存了一个文件读写偏移量，如果是两个file table entry，那么两个进程读写位置是独立的，不受影响的。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 上面的代码运行结果是：</span></p>
  <pre class="md-fences md-end-block" style="background-color:rgb(232,232,232);font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;color:rgb(51,51,51);text-align:left;border:1px solid rgb(221,221,221);width:inherit;"><span><span class="cm-comment" style="color:rgb(170,85,0);">#先启动进程0</span></span>
<span><span class="cm-def" style="color:rgb(0,0,255);">$ </span>./a.out </span>
<span>new fd <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-number" style="color:rgb(17,102,68);">3</span></span>
<span><span class="cm-number" style="color:rgb(17,102,68);">0</span></span>
<span><span class="cm-number" style="color:rgb(17,102,68);">3</span></span>
<span>​</span>
<span><span class="cm-comment" style="color:rgb(170,85,0);">#在5秒时间内，启动进程1</span></span>
<span><span class="cm-def" style="color:rgb(0,0,255);">$ </span>./a.out </span>
<span>new fd <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-number" style="color:rgb(17,102,68);">3</span></span>
<span><span class="cm-number" style="color:rgb(17,102,68);">0</span></span>
<span><span class="cm-number" style="color:rgb(17,102,68);">3</span></span></pre>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 两个进程都分配了fd 3 给新打开个文件，并且读写位置不受其他进程的影响 。如果受影响了话，进程1的读写位置要变成3和6.</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"></span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"></span></p>
  <h2 class="md-end-block md-heading" style="color:rgb(57,172,171);font-size:1.75em;line-height:1.225;border-bottom:1px solid rgb(238,238,238);text-align:center;width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;">3 一个进程open两次同一个文件</h2>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 一个进程open两次同一个文件，其实跟两个进程open一次的原理相同，都是调用了两次open，反正只要记住，调用一次open函数，就会创建一个file table entry。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">原理图如下：</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180227141322155" alt=""><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;"></span></span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 由于只有一个进程，所以只有一个process table entry，open了两次，所以是两个file table entry 分别分配了fd 3与fd 4指向这两个结构体。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">代码如下：</span></p>
  <pre class="md-fences md-end-block" style="background-color:rgb(232,232,232);font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;color:rgb(51,51,51);text-align:left;border:1px solid rgb(221,221,221);width:inherit;"><span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;unistd.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;fcntl.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;stdio.h&gt;</span></span>
<span><span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-def" style="color:rgb(0,0,255);">main</span>(<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">argc</span>, <span class="cm-variable-3" style="color:rgb(0,136,85);">char</span> <span class="cm-variable-3" style="color:rgb(0,136,85);">*</span><span class="cm-variable" style="color:rgb(0,0,0);">argv</span>[])</span>
<span>{</span>
<span> &nbsp; &nbsp;<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">fd0</span> <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-variable" style="color:rgb(0,0,0);">open</span>(<span class="cm-string" style="color:rgb(170,17,17);">"./log.txt"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">O_RDWR</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">fd1</span> <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-variable" style="color:rgb(0,0,0);">open</span>(<span class="cm-string" style="color:rgb(170,17,17);">"./log.txt"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">O_RDWR</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"new fd0 = %d\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">fd0</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"new fd1 = %d\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">fd1</span>);</span>
<span>​</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">write</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd0</span>, <span class="cm-string" style="color:rgb(170,17,17);">"123"</span>, <span class="cm-number" style="color:rgb(17,102,68);">3</span>);</span>
<span>​</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"fd0 lseek %ld\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">lseek</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd0</span>, <span class="cm-number" style="color:rgb(17,102,68);">0</span>, <span class="cm-variable" style="color:rgb(0,0,0);">SEEK_CUR</span>));</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"fd1 lseek %ld\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">lseek</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd1</span>, <span class="cm-number" style="color:rgb(17,102,68);">0</span>, <span class="cm-variable" style="color:rgb(0,0,0);">SEEK_CUR</span>));</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">close</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd0</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">close</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd1</span>);</span>
<span>}</span></pre>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 上面代码open了两次log.txt，创建了两个file结构体，验证方法还是通过判断读写位置是否是独立的。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">运行结果：</span></p>
  <pre class="md-fences md-end-block" style="background-color:rgb(232,232,232);font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;color:rgb(51,51,51);text-align:left;border:1px solid rgb(221,221,221);width:inherit;"><span>new fd0 <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-number" style="color:rgb(17,102,68);">3</span></span>
<span>new fd1 <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-number" style="color:rgb(17,102,68);">3</span></span>
<span>fd0 lseek <span class="cm-number" style="color:rgb(17,102,68);">3</span></span>
<span>fd1 lseek <span class="cm-number" style="color:rgb(17,102,68);">0</span></span></pre>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 结果已经说明一切了，修改fd0的读写位置不会影响fd1的读写位置。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"></span></p>
  <h2 class="md-end-block md-heading" style="color:rgb(57,172,171);font-size:1.75em;line-height:1.225;border-bottom:1px solid rgb(238,238,238);text-align:center;width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;">4、使用dup复制文件描述符</h2>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> dup函数与open函数不同，open函数会创建一个file table，但是dup只是申请一个fd来指向一个已经存在的file table。原理图如下：</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180227141340549" alt=""><span class="md-line md-end-block"><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;text-align:center;"></span></span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">代码 testdup.c</span></p>
  <pre class="md-fences md-end-block" style="background-color:rgb(232,232,232);font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;color:rgb(51,51,51);text-align:left;border:1px solid rgb(221,221,221);width:inherit;"><span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;unistd.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;fcntl.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;stdio.h&gt;</span></span>
<span> </span>
<span><span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-def" style="color:rgb(0,0,255);">main</span>(<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">argc</span>, <span class="cm-variable-3" style="color:rgb(0,136,85);">char</span> <span class="cm-variable-3" style="color:rgb(0,136,85);">*</span><span class="cm-variable" style="color:rgb(0,0,0);">argv</span>[])</span>
<span>{</span>
<span> &nbsp; &nbsp;<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-variable" style="color:rgb(0,0,0);">copyfd</span>;</span>
<span> </span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">fd</span> <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-variable" style="color:rgb(0,0,0);">open</span>(<span class="cm-string" style="color:rgb(170,17,17);">"./log.txt"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">O_RDWR</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-comment" style="color:rgb(170,85,0);">/*复制fd*/</span></span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">copyfd</span> <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-variable" style="color:rgb(0,0,0);">dup</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>);</span>
<span> </span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">write</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-string" style="color:rgb(170,17,17);">"123"</span>, <span class="cm-number" style="color:rgb(17,102,68);">3</span>)</span>
<span> </span>
<span> &nbsp; &nbsp;<span class="cm-comment" style="color:rgb(170,85,0);">/*打印出fd和copyfd的偏移量，经过上面的写操作，都变成3了*/</span></span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"fd lseek %ld\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">lseek</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-number" style="color:rgb(17,102,68);">0</span>, <span class="cm-variable" style="color:rgb(0,0,0);">SEEK_CUR</span>));</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"copyfd lseek %ld\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">lseek</span>(<span class="cm-variable" style="color:rgb(0,0,0);">copyfd</span>, <span class="cm-number" style="color:rgb(17,102,68);">0</span>, <span class="cm-variable" style="color:rgb(0,0,0);">SEEK_CUR</span>));</span>
<span> </span>
<span> <span class="cm-tab"> </span><span class="cm-variable" style="color:rgb(0,0,0);">close</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">close</span>(<span class="cm-variable" style="color:rgb(0,0,0);">copyfd</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-keyword" style="color:rgb(119,0,136);">return</span> <span class="cm-number" style="color:rgb(17,102,68);">0</span>;</span>
<span>}</span></pre>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">运行结果：</span></p>
  <pre class="md-fences md-end-block" style="background-color:rgb(232,232,232);font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;color:rgb(51,51,51);text-align:left;border:1px solid rgb(221,221,221);width:inherit;"><span><span class="cm-def" style="color:rgb(0,0,255);">$ </span>./a.out </span>
<span>fd lseek <span class="cm-number" style="color:rgb(17,102,68);">3</span></span>
<span>copyfd lseek <span class="cm-number" style="color:rgb(17,102,68);">3</span></span></pre>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 结果证明只要操作了fd 或copyfd这两个文件描述符中一个的读写位置，就会影响到另一个文件描述符的读写位置。说明这两个文件描述符指向的是同一个file table。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 需要注意的是，一旦dup了一次，就会file table引用计数加一，如果想要释放file table的内存，必须要把open以及所有dup出来的文件描述符都关闭掉。</span></p>
  <h2 class="md-end-block md-heading" style="color:rgb(57,172,171);font-size:1.75em;line-height:1.225;border-bottom:1px solid rgb(238,238,238);text-align:center;width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;">5、fork之后open</h2>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 如果在调用fork之后调用一次open函数，由于fork之后会返回两次，一次父进程返回，一次子进程返回，那么这个时候其实是相当与两个进程分别调用了一次open函数打开同一个文件，与第二节中的原理相同。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180227141417120" alt=""><br></span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">代码如下：testforkopen.c</span></p>
  <pre class="md-fences md-end-block" style="background-color:rgb(232,232,232);font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;color:rgb(51,51,51);text-align:left;border:1px solid rgb(221,221,221);width:inherit;"><span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;unistd.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;fcntl.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;stdio.h&gt;</span></span>
<span><span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-def" style="color:rgb(0,0,255);">main</span>(<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">argc</span>, <span class="cm-variable-3" style="color:rgb(0,136,85);">char</span> <span class="cm-variable-3" style="color:rgb(0,136,85);">*</span><span class="cm-variable" style="color:rgb(0,0,0);">argv</span>[])</span>
<span>{</span>
<span> &nbsp; &nbsp;<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">pid</span> <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-variable" style="color:rgb(0,0,0);">fork</span>();</span>
<span> &nbsp; &nbsp;<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">fd</span> <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-variable" style="color:rgb(0,0,0);">open</span>(<span class="cm-string" style="color:rgb(170,17,17);">"./log.txt"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">O_RDWR</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"pid %d %ld\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">pid</span>, <span class="cm-variable" style="color:rgb(0,0,0);">lseek</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-number" style="color:rgb(17,102,68);">0</span>, <span class="cm-variable" style="color:rgb(0,0,0);">SEEK_CUR</span>));</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">write</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-string" style="color:rgb(170,17,17);">"123"</span>, <span class="cm-number" style="color:rgb(17,102,68);">3</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">sleep</span>(<span class="cm-number" style="color:rgb(17,102,68);">5</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"pid %d %ld\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">pid</span>, <span class="cm-variable" style="color:rgb(0,0,0);">lseek</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-number" style="color:rgb(17,102,68);">0</span>, <span class="cm-variable" style="color:rgb(0,0,0);">SEEK_CUR</span>));</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">close</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>);</span>
<span>}</span></pre>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"></span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">运行结果：</span></p>
  <pre class="md-fences md-end-block" style="background-color:rgb(232,232,232);font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;color:rgb(51,51,51);text-align:left;border:1px solid rgb(221,221,221);width:inherit;"><span><span class="cm-def" style="color:rgb(0,0,255);">$ </span>./a.out </span>
<span>pid <span class="cm-number" style="color:rgb(17,102,68);">6112</span> lseek <span class="cm-number" style="color:rgb(17,102,68);">0</span> &nbsp;<span class="cm-comment" style="color:rgb(170,85,0);">#父进程</span></span>
<span>pid <span class="cm-number" style="color:rgb(17,102,68);">0</span> lseek <span class="cm-number" style="color:rgb(17,102,68);">0</span> &nbsp; &nbsp; <span class="cm-comment" style="color:rgb(170,85,0);">#子进程</span></span>
<span>pid <span class="cm-number" style="color:rgb(17,102,68);">6112</span> lseek <span class="cm-number" style="color:rgb(17,102,68);">3</span> &nbsp;<span class="cm-comment" style="color:rgb(170,85,0);">#父进程</span></span>
<span>pid <span class="cm-number" style="color:rgb(17,102,68);">0</span> lseek <span class="cm-number" style="color:rgb(17,102,68);">3</span><span class="cm-tab"> </span> &nbsp;<span class="cm-comment" style="color:rgb(170,85,0);">#子进程</span></span></pre>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">可以看到父子进程的读写位置都是3，并不受影响。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"></span></p>
  <h2 class="md-end-block md-heading" style="color:rgb(57,172,171);font-size:1.75em;line-height:1.225;border-bottom:1px solid rgb(238,238,238);text-align:center;width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;">6 fork之前open</h2>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> fork之前调用open函数，也就是只调用了一次，产生了一个fd以及file table，fork之后子进程的process table entry会从父亲进程中复制过来，文件描述表也复制过来了，那么子进程的fd指向的是同一个file table。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">原理图如下：</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180227141429625" alt=""><span class="md-line md-end-block"><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;text-align:center;"></span></span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">代码如下：testopenfork.c</span></p>
  <pre class="md-fences md-end-block" style="background-color:rgb(232,232,232);font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;color:rgb(51,51,51);text-align:left;border:1px solid rgb(221,221,221);width:inherit;"><span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;unistd.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;fcntl.h&gt;</span></span>
<span><span class="cm-meta" style="color:rgb(85,85,85);">#include &lt;stdio.h&gt;</span></span>
<span><span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-def" style="color:rgb(0,0,255);">main</span>(<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">argc</span>, <span class="cm-variable-3" style="color:rgb(0,136,85);">char</span> <span class="cm-variable-3" style="color:rgb(0,136,85);">*</span><span class="cm-variable" style="color:rgb(0,0,0);">argv</span>[])</span>
<span>{</span>
<span> &nbsp; &nbsp;<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">fd</span> <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-variable" style="color:rgb(0,0,0);">open</span>(<span class="cm-string" style="color:rgb(170,17,17);">"./log.txt"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">O_RDWR</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable-3" style="color:rgb(0,136,85);">int</span> <span class="cm-variable" style="color:rgb(0,0,0);">pid</span> <span class="cm-operator" style="color:rgb(152,26,26);">=</span> <span class="cm-variable" style="color:rgb(0,0,0);">fork</span>();</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"pid %d %ld\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">pid</span>, <span class="cm-variable" style="color:rgb(0,0,0);">lseek</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-number" style="color:rgb(17,102,68);">0</span>, <span class="cm-variable" style="color:rgb(0,0,0);">SEEK_CUR</span>));</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">write</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-string" style="color:rgb(170,17,17);">"123"</span>, <span class="cm-number" style="color:rgb(17,102,68);">3</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">sleep</span>(<span class="cm-number" style="color:rgb(17,102,68);">5</span>);</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">printf</span>(<span class="cm-string" style="color:rgb(170,17,17);">"pid %d %ld\n"</span>, <span class="cm-variable" style="color:rgb(0,0,0);">pid</span>, <span class="cm-variable" style="color:rgb(0,0,0);">lseek</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>, <span class="cm-number" style="color:rgb(17,102,68);">0</span>, <span class="cm-variable" style="color:rgb(0,0,0);">SEEK_CUR</span>));</span>
<span> &nbsp; &nbsp;<span class="cm-variable" style="color:rgb(0,0,0);">close</span>(<span class="cm-variable" style="color:rgb(0,0,0);">fd</span>);</span>
<span>}</span></pre>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block">运行结果：</span></p>
  <pre class="md-fences md-end-block" style="background-color:rgb(232,232,232);font-family:Consolas, 'Liberation Mono', Courier, monospace;font-size:.9em;color:rgb(51,51,51);text-align:left;border:1px solid rgb(221,221,221);width:inherit;"><span><span class="cm-def" style="color:rgb(0,0,255);">$ </span>./a.out </span>
<span>pid <span class="cm-number" style="color:rgb(17,102,68);">6388</span> lseek <span class="cm-number" style="color:rgb(17,102,68);">0</span></span>
<span>pid <span class="cm-number" style="color:rgb(17,102,68);">0</span> lseek <span class="cm-number" style="color:rgb(17,102,68);">3</span></span>
<span>pid <span class="cm-number" style="color:rgb(17,102,68);">6388</span> lseek <span class="cm-number" style="color:rgb(17,102,68);">6</span></span>
<span>pid <span class="cm-number" style="color:rgb(17,102,68);">0</span> lseek <span class="cm-number" style="color:rgb(17,102,68);">6</span></span></pre>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 父子进程都各自写入3字节，如果是两个file table，那么最终都应该打印的是3，而不是6，请与第5节进行对比。</span></p>
  <p style="color:rgb(51,51,51);width:inherit;font-family:'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;"><span class="md-line md-end-block"> 需要注意的是：如果想要释放这个file table，也必须父子进程都close一次fd才会释放，如果不close，进程退出的时候会自动close掉所有的文件描述符。</span></p>
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq769651718/article/details/79459346,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq769651718/article/details/79459346,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
