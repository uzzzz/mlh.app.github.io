<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>比特币源码阅读笔记【基础篇】 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="比特币源码阅读笔记【基础篇】" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="比特币源码阅读笔记【基础篇】 出差坐火车ing，正好利用这段时间学习一波比特币源代码，比特币源码的主要语言是C++，测试代码语言主要是Python。 一、区块链数据结构和数字签名算法 1. 数据结构 Merkle树 区块链, 顾名思义是由一个个区块按一定规则组成的链。何谓区块，我们可以用命令行工具bitcoin-cli或者区块链浏览器(blockchain.info等网站)浏览区块详细信息, 例如： { &quot;size&quot;: 43560, &quot;version&quot;: 2, &quot;previousblockhash&quot;: &quot;00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249&quot;, &quot;merkleroot&quot;: &quot;5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d&quot;, &quot;time&quot;: 1388185038, &quot;difficulty&quot;: 1180923195.25802612, &quot;nonce&quot;: 4215469401, &quot;tx&quot;: [&quot;257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77&quot;, # [...many more transactions omitted...] &quot;05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634&quot; ] } 区块包含的信息分几个部分：1.元信息，如version,time,size等 2. 挖矿信息，如仅用一次的随机数nonce, 难度系数difficulty 3. 交易数据 4. 交易摘要，merkleroot和perviousblockhash。 比特币采用Merkle树进行交易摘要。 Merkle树的基础是哈希函数和非对称数字签名，比特币选择的哈希函数是两层SHA256。交易本身不存储在Merkle树中，Merkle树保存交易的哈希值。例如，一笔交易A的哈希值计算过程HA = SHA256(SHA256(A)) , 两笔交易A和B的哈希值计算过程为H(A,B) = SHA256(SHA256(HA+HB)))。交易数据两两计算，最终组成一个哈希二叉树，如下图所示 这两个字段，merkleroot表示整条链的交易摘要哈希值，perviousblockhash表示该区块在链中的位置； 下图是一个链的样例： 到此为止，我们已经知道，比特币区块链的基础数据结构是Merkle树。Merkle树是哈希指针形式的二叉树，每个节点包含其子节点的哈希值，一旦子节点的结构或内容发生变动，该节点的哈希值必然发生改变，从而，两个Merkle树最上层节点的哈希值相同，我们就认为两个Merkle树是完全一致的。 Merkle树计算核心函数，见consensus/merkle.cpp /* This implements a constant-space merkle root/path calculator, limited to 2^32 leaves. */ static void MerkleComputation(const std::vector&lt;uint256&gt;&amp; leaves, uint256* proot, bool* pmutated, uint32_t branchpos, std::vector&lt;uint256&gt;* pbranch) { if (pbranch) pbranch-&gt;clear(); if (leaves.size() == 0) { if (pmutated) *pmutated = false; if (proot) *proot = uint256(); return; } bool mutated = false; // count is the number of leaves processed so far. uint32_t count = 0; // inner is an array of eagerly computed subtree hashes, indexed by tree // level (0 being the leaves). // For example, when count is 25 (11001 in binary), inner[4] is the hash of // the first 16 leaves, inner[3] of the next 8 leaves, and inner[0] equal to // the last leaf. The other inner entries are undefined. uint256 inner[32]; // Which position in inner is a hash that depends on the matching leaf. int matchlevel = -1; // First process all leaves into &#39;inner&#39; values. while (count &lt; leaves.size()) { uint256 h = leaves[count]; bool matchh = count == branchpos; count++; int level; // For each of the lower bits in count that are 0, do 1 step. Each // corresponds to an inner value that existed before processing the // current leaf, and each needs a hash to combine it. for (level = 0; !(count &amp; (((uint32_t)1) &lt;&lt; level)); level++) { if (pbranch) { if (matchh) { pbranch-&gt;push_back(inner[level]); } else if (matchlevel == level) { pbranch-&gt;push_back(h); matchh = true; } } mutated |= (inner[level] == h); CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin()); } // Store the resulting hash at inner position level. inner[level] = h; if (matchh) { matchlevel = level; } } // Do a final &#39;sweep&#39; over the rightmost branch of the tree to process // odd levels, and reduce everything to a single top value. // Level is the level (counted from the bottom) up to which we&#39;ve sweeped. int level = 0; // As long as bit number level in count is zero, skip it. It means there // is nothing left at this level. while (!(count &amp; (((uint32_t)1) &lt;&lt; level))) { level++; } uint256 h = inner[level]; bool matchh = matchlevel == level; while (count != (((uint32_t)1) &lt;&lt; level)) { // If we reach this point, h is an inner value that is not the top. // We combine it with itself (Bitcoin&#39;s special rule for odd levels in // the tree) to produce a higher level one. if (pbranch &amp;&amp; matchh) { pbranch-&gt;push_back(h); } CHash256().Write(h.begin(), 32).Write(h.begin(), 32).Finalize(h.begin()); // Increment count to the value it would have if two entries at this // level had existed. count += (((uint32_t)1) &lt;&lt; level); level++; // And propagate the result upwards accordingly. while (!(count &amp; (((uint32_t)1) &lt;&lt; level))) { if (pbranch) { if (matchh) { pbranch-&gt;push_back(inner[level]); } else if (matchlevel == level) { pbranch-&gt;push_back(h); matchh = true; } } CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin()); level++; } } // Return result. if (pmutated) *pmutated = mutated; if (proot) *proot = h; } 2. 数字签名算法 椭圆曲线算法 2.1 椭圆曲线算法和公私钥 日常工作中，我们每天登录服务器，对公私钥系统已经非常熟悉了，公私钥并不是新鲜的技术。我们可以用ssh-keygen命令生成一对公钥和私钥；当拥有私钥时，可以用ssh-keygen -y -f生成配对的公钥，但拥有公钥无法生成配对的私钥。这背后的原理就是椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm, 简写为ECDSA)。比特币利用椭圆曲线生成密钥对，其中公钥作为交易接收方的地址，对外传播。 在平面直角坐标系中，一条椭圆曲线的形状如下图。比特币的源码中，椭圆曲线定义在src/secp256k1目录。比特币选择的椭圆曲线方程为y2 mod p = (x3 + 7) mod p，其中p是一个非常大的质数，p = 2256 - 232 - 29 - 28 - 27 - 26 - 24 - 1。 给定私钥k, 如何根据椭圆曲线生成公钥K呢？公式为K = k * G。其中，G 代表一种变换，从点k=(x,y)进行一次变换生成k1=(x1, y1)，先在点k出求正切线，正切线与椭圆曲线的交点… 下图用几何形式展示了变换G。 2.2 SHA-256 哈希函数在比特币中用途极为广泛，包括：比特币地址，交易脚本地址，挖矿工作量证明。在比特币系统中，利用公钥生成比特币地址的算法是SHA256和 RIPEMD160。 由公钥生成比特币地址的总体过程如下图所示 给定公钥K，先进行SHA256哈希，再对SHA256的结果进行RIPEMD160哈希，得到的值A就是比特币地址, 即A = RIPEMD160(SHA256(K))。A值进一步压缩, 我们就得到了比特币地址, 形如1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy。比特币选择的压缩算法是Base58Check。 SHA-256计算过程，如下图 我们来看一下比特币源码中SHA256哈希的实现 哈希函数类定义如下, 主体是状态s，由8个32位无符号整数组成。缓冲buf用于批量读入和计算数据。 /** A hasher class for SHA-256. */ class CSHA256 { private: uint32_t s[8]; unsigned char buf[64]; uint64_t bytes; public: static const size_t OUTPUT_SIZE = 32; CSHA256(); CSHA256&amp; Write(const unsigned char* data, size_t len); void Finalize(unsigned char hash[OUTPUT_SIZE]); CSHA256&amp; Reset(); }; SHA256的主体代码，数据data每64字节读入一次，写入buff，经过Transform处理，得到s值。 CSHA256&amp; CSHA256::Write(const unsigned char* data, size_t len) { const unsigned char* end = data + len; size_t bufsize = bytes % 64; if (bufsize &amp;&amp; bufsize + len &gt;= 64) { // Fill the buffer, and process it. memcpy(buf + bufsize, data, 64 - bufsize); bytes += 64 - bufsize; data += 64 - bufsize; Transform(s, buf, 1); bufsize = 0; } if (end - data &gt;= 64) { size_t blocks = (end - data) / 64; Transform(s, data, blocks); data += 64 * blocks; bytes += 64 * blocks; } if (end &gt; data) { // Fill the buffer with what remains. memcpy(buf + bufsize, data, end - data); bytes += end - data; } return *this; } 这里定义了一些基本运算，Ch, Maj, Sigma0, Sigma1, sigma0, sigma1，很直白，无需赘言。 uint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z) { return z ^ (x &amp; (y ^ z)); } uint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z) { return (x &amp; y) | (z &amp; (x | y)); } uint32_t inline Sigma0(uint32_t x) { return (x &gt;&gt; 2 | x &lt;&lt; 30) ^ (x &gt;&gt; 13 | x &lt;&lt; 19) ^ (x &gt;&gt; 22 | x &lt;&lt; 10); } uint32_t inline Sigma1(uint32_t x) { return (x &gt;&gt; 6 | x &lt;&lt; 26) ^ (x &gt;&gt; 11 | x &lt;&lt; 21) ^ (x &gt;&gt; 25 | x &lt;&lt; 7); } uint32_t inline sigma0(uint32_t x) { return (x &gt;&gt; 7 | x &lt;&lt; 25) ^ (x &gt;&gt; 18 | x &lt;&lt; 14) ^ (x &gt;&gt; 3); } uint32_t inline sigma1(uint32_t x) { return (x &gt;&gt; 17 | x &lt;&lt; 15) ^ (x &gt;&gt; 19 | x &lt;&lt; 13) ^ (x &gt;&gt; 10); } 初始化8个32位的无符号整数，作为初始状态。 /** Initialize SHA-256 state. */ void inline Initialize(uint32_t* s) { s[0] = 0x6a09e667ul; s[1] = 0xbb67ae85ul; s[2] = 0x3c6ef372ul; s[3] = 0xa54ff53aul; s[4] = 0x510e527ful; s[5] = 0x9b05688cul; s[6] = 0x1f83d9abul; s[7] = 0x5be0cd19ul; } /** One round of SHA-256. */ void inline Round(uint32_t a, uint32_t b, uint32_t c, uint32_t&amp; d, uint32_t e, uint32_t f, uint32_t g, uint32_t&amp; h, uint32_t k, uint32_t w) { uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w; uint32_t t2 = Sigma0(a) + Maj(a, b, c); d += t1; h = t1 + t2; } 每一轮SHA256计算过程如上所示，同样很直白，无需赘言。 下面的Transform函数比较有内容，函数输入一个64字节的chunk和状态s，每次从chunk读入4字节，根据当前状态s，做16次Round计算；完成后再做三轮16次Round；最后，8个无符号整数都加上上述64次Round的结果，更新状态s。经过上述计算，我们就得到了数据chunk的SHA256哈希值。 数据读写的代码，见/src/crypto/common.h /** Perform a number of SHA-256 transformations, processing 64-byte chunks. */ void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks) { while (blocks--) { uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7]; uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15; // 步骤一： Round(a, b, c, d, e, f, g, h, 0x428a2f98, w0 = ReadBE32(chunk + 0)); Round(h, a, b, c, d, e, f, g, 0x71374491, w1 = ReadBE32(chunk + 4)); // 中间省略... Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = ReadBE32(chunk + 56)); Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = ReadBE32(chunk + 60)); // 步骤二： Round(a, b, c, d, e, f, g, h, 0xe49b69c1, w0 += sigma1(w14) + w9 + sigma0(w1)); Round(h, a, b, c, d, e, f, g, 0xefbe4786, w1 += sigma1(w15) + w10 + sigma0(w2)); // 中间省略 Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) + w7 + sigma0(w15)); Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) + w8 + sigma0(w0)); // 步骤三： Round(a, b, c, d, e, f, g, h, 0x27b70a85, w0 += sigma1(w14) + w9 + sigma0(w1)); Round(h, a, b, c, d, e, f, g, 0x2e1b2138, w1 += sigma1(w15) + w10 + sigma0(w2)); // 中间省略 Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) + w7 + sigma0(w15)); Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) + w8 + sigma0(w0)); // 步骤四： Round(a, b, c, d, e, f, g, h, 0x19a4c116, w0 += sigma1(w14) + w9 + sigma0(w1)); Round(h, a, b, c, d, e, f, g, 0x1e376c08, w1 += sigma1(w15) + w10 + sigma0(w2)); // 中间省略 Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14 + sigma1(w12) + w7 + sigma0(w15)); Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15 + sigma1(w13) + w8 + sigma0(w0)); s[0] += a; s[1] += b; s[2] += c; s[3] += d; s[4] += e; s[5] += f; s[6] += g; s[7] += h; chunk += 64; } } 以上就是SHA256哈希算法的实现；下一步，我们分析交易结构。 二、交易 一般的交易系统设计：账户，余额。比特币的交易系统, 不记录余额，记录交易内容。例如，一般的交易系统，记录Alice的余额为10 RMB，Bob的余额为5RMB，当Alice发起交易，给Bob支付5RMB时，支付系统后台检查Alice的余额，验证通过后，对Alice的余额减5RMB，再对Bob的余额加5RMB。 而区块链处理的思路是，不记录Alice和Bob的账户余额，记录历史上发生过的所有交易记录，以未消费交易输出（UTXO）形式分布式地保存在区块链上，区块链网络节点共同验证UTXO是否合法。 构建比特币交易的基础是交易输出, 交易输出是比特币货币系统中不可拆分的块（chunk），记录在区块链上，被比特币网络认证；比特币网络节点记录所有可获得且可消费的交易输出，称作未消费交易输出(unspent transaction outputs), 简写成UTXO。 区块链上的一笔交易，代表着一组UTXO集合状态转换到另外一组UTXO集合状态。当产生新的“比特币”时，UTXO集合大小增加。UTXO是比特币交易的基础。“账户余额”的概念由比特币钱包应用创造，钱包应用扫描区块链，得到钱包拥有者的私钥可以消费的UTXO的总和，即“账户余额”。大多数钱包应用维护了一个数据库，用于存储该钱包私钥可以消费的UTXO集合。 2.1 交易格式 实际比特币的交易记录是二进制格式，转换成可读格式后，一笔交易的内容包含三个部分：元数据，输入，输出; 如下所示 { &quot;version&quot;: 1, &quot;locktime&quot;: 0, &quot;vin&quot;: [{ &quot;txid&quot;: &quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;, &quot;vout&quot;: 0, &quot;scriptSig&quot;: &quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;, &quot;sequence&quot;: 4294967295 }], &quot;vout&quot;: [{ &quot;value&quot;: 0.01500000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG &quot; }, { &quot;value&quot;: 0.08450000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot; }] } 值得注意的是，每个输入包含了一项scirptSig, 上例中是3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf, 每个输出的元素都包含了一项scriptPubKey, 上例中是ab68025513c3dbd2f7b92a94e0581f5d50f654e7, 这个值代表了交易脚本的哈希值。(稍后详细描述) 比特币交易结构，见primitives/transaction.h /** * Basic transaction serialization format: * - int32_t nVersion * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - uint32_t nLockTime * * Extended transaction serialization format: * - int32_t nVersion * - unsigned char dummy = 0x00 * - unsigned char flags (!= 0) * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - if (flags &amp; 1): * - CTxWitness wit; * - uint32_t nLockTime */ 可以看到，基本交易序列化格式的信息包括：版本号，输入列表，输出列表，锁定时间；此外，扩展的交易序列化格式还包括扩容方案隔离见证的一些信息。关于比特币扩容和隔离见证此处不展开讨论，准备单独写一篇笔记。对比特币扩容方案感兴趣的读者，建议阅读BIP-141, BIP-143和BIP-147。 交易输入定义，见src/primitives/transaction.h /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. */ class CTxIn { public: COutPoint prevout; CScript scriptSig; uint32_t nSequence; CScriptWitness scriptWitness; //! Only serialized through CTransaction /* Setting nSequence to this value for every input in a transaction * disables nLockTime. */ static const uint32_t SEQUENCE_FINAL = 0xffffffff; /* Below flags apply in the context of BIP 68*/ /* If this flag set, CTxIn::nSequence is NOT interpreted as a * relative lock-time. */ static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 &lt;&lt; 31); /* If CTxIn::nSequence encodes a relative lock-time and this flag * is set, the relative lock-time has units of 512 seconds, * otherwise it specifies blocks with a granularity of 1. */ static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 &lt;&lt; 22); /* If CTxIn::nSequence encodes a relative lock-time, this mask is * applied to extract that lock-time from the sequence field. */ static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff; /* In order to use the same number of bits to encode roughly the * same wall-clock duration, and because blocks are naturally * limited to occur every 600s on average, the minimum granularity * for time-based relative lock-time is fixed at 512 seconds. * Converting from CTxIn::nSequence to seconds is performed by * multiplying by 512 = 2^9, or equivalently shifting up by * 9 bits. */ static const int SEQUENCE_LOCKTIME_GRANULARITY = 9; CTxIn() { nSequence = SEQUENCE_FINAL; } explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(prevout); READWRITE(scriptSig); READWRITE(nSequence); } friend bool operator==(const CTxIn&amp; a, const CTxIn&amp; b) { return (a.prevout == b.prevout &amp;&amp; a.scriptSig == b.scriptSig &amp;&amp; a.nSequence == b.nSequence); } friend bool operator!=(const CTxIn&amp; a, const CTxIn&amp; b) { return !(a == b); } std::string ToString() const; }; 交易输出定义，见src/primitives/transaction.h /** An output of a transaction. It contains the public key that the next input * must be able to sign with to claim it. */ class CTxOut { public: CAmount nValue; CScript scriptPubKey; CTxOut() { SetNull(); } CTxOut(const CAmount&amp; nValueIn, CScript scriptPubKeyIn); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(nValue); READWRITE(scriptPubKey); } void SetNull() { nValue = -1; scriptPubKey.clear(); } bool IsNull() const { return (nValue == -1); } friend bool operator==(const CTxOut&amp; a, const CTxOut&amp; b) { return (a.nValue == b.nValue &amp;&amp; a.scriptPubKey == b.scriptPubKey); } friend bool operator!=(const CTxOut&amp; a, const CTxOut&amp; b) { return !(a == b); } std::string ToString() const; }; 2.2 交易脚本 比特币脚本语言是专为比特币而设计的简化版本的程序语言。比特币脚本语言有意设计成非图灵完备语言，计算表达能力受到了一定的限制。最主要的有三点：1.数据存储在栈中，不支持定义变量；2. 限制比特币脚本的可用内存和执行时间；3. 比特币脚本中不支持循环，避免死循环导致浪费比特币矿工计算资源。 比特币脚本指令集合，总共有256个操作，其中15个禁用，75个保留。主要的操作为：1. 算数操作，如加减法 2. 分支判断 if/then 3. 逻辑和数据处理 与或非，抛出异常和捕获异常，提前返回等 4. 加密算法，包括哈希函数，签名认证，多重签名认证等。 值得注意的是，比特币脚本语言具有强大的加密算法库，支持在一条操作中对多重签名进行验证，即OP_CHECKMULTISIG操作。多重签名意味着，指定n个公钥，指定一个阈值参数t，表示如果操作想要正常执行，至少匹配n个公钥中的的t个签名。 2.3 未消费交易输出, UTXO 终于到了“币”的环节, “币”在比特币的源码世界里，定义如下，见src/coins.h /** * A UTXO entry. * * Serialized format: * - VARINT((coinbase ? 1 : 0) | (height &lt;&lt; 1)) * - the non-spent CTxOut (via CTxOutCompressor) */ class Coin { public: //! unspent transaction output CTxOut out; //! whether containing transaction was a coinbase unsigned int fCoinBase : 1; //! at which height this containing transaction was included in the active block chain uint32_t nHeight : 31; //! construct a Coin from a CTxOut and height/coinbase information. Coin(CTxOut&amp;&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {} Coin(const CTxOut&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {} void Clear() { out.SetNull(); fCoinBase = false; nHeight = 0; } //! empty constructor Coin() : fCoinBase(false), nHeight(0) { } bool IsCoinBase() const { return fCoinBase; } template&lt;typename Stream&gt; void Serialize(Stream &amp;s) const { assert(!IsSpent()); uint32_t code = nHeight * 2 + fCoinBase; ::Serialize(s, VARINT(code)); ::Serialize(s, CTxOutCompressor(REF(out))); } template&lt;typename Stream&gt; void Unserialize(Stream &amp;s) { uint32_t code = 0; ::Unserialize(s, VARINT(code)); nHeight = code &gt;&gt; 1; fCoinBase = code &amp; 1; ::Unserialize(s, REF(CTxOutCompressor(out))); } bool IsSpent() const { return out.IsNull(); } size_t DynamicMemoryUsage() const { return memusage::DynamicUsage(out.scriptPubKey); } }; 参考资料 普林斯顿大学公开课 Coursera Mastering Bitcoin 阅读更多" />
<meta property="og:description" content="比特币源码阅读笔记【基础篇】 出差坐火车ing，正好利用这段时间学习一波比特币源代码，比特币源码的主要语言是C++，测试代码语言主要是Python。 一、区块链数据结构和数字签名算法 1. 数据结构 Merkle树 区块链, 顾名思义是由一个个区块按一定规则组成的链。何谓区块，我们可以用命令行工具bitcoin-cli或者区块链浏览器(blockchain.info等网站)浏览区块详细信息, 例如： { &quot;size&quot;: 43560, &quot;version&quot;: 2, &quot;previousblockhash&quot;: &quot;00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249&quot;, &quot;merkleroot&quot;: &quot;5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d&quot;, &quot;time&quot;: 1388185038, &quot;difficulty&quot;: 1180923195.25802612, &quot;nonce&quot;: 4215469401, &quot;tx&quot;: [&quot;257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77&quot;, # [...many more transactions omitted...] &quot;05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634&quot; ] } 区块包含的信息分几个部分：1.元信息，如version,time,size等 2. 挖矿信息，如仅用一次的随机数nonce, 难度系数difficulty 3. 交易数据 4. 交易摘要，merkleroot和perviousblockhash。 比特币采用Merkle树进行交易摘要。 Merkle树的基础是哈希函数和非对称数字签名，比特币选择的哈希函数是两层SHA256。交易本身不存储在Merkle树中，Merkle树保存交易的哈希值。例如，一笔交易A的哈希值计算过程HA = SHA256(SHA256(A)) , 两笔交易A和B的哈希值计算过程为H(A,B) = SHA256(SHA256(HA+HB)))。交易数据两两计算，最终组成一个哈希二叉树，如下图所示 这两个字段，merkleroot表示整条链的交易摘要哈希值，perviousblockhash表示该区块在链中的位置； 下图是一个链的样例： 到此为止，我们已经知道，比特币区块链的基础数据结构是Merkle树。Merkle树是哈希指针形式的二叉树，每个节点包含其子节点的哈希值，一旦子节点的结构或内容发生变动，该节点的哈希值必然发生改变，从而，两个Merkle树最上层节点的哈希值相同，我们就认为两个Merkle树是完全一致的。 Merkle树计算核心函数，见consensus/merkle.cpp /* This implements a constant-space merkle root/path calculator, limited to 2^32 leaves. */ static void MerkleComputation(const std::vector&lt;uint256&gt;&amp; leaves, uint256* proot, bool* pmutated, uint32_t branchpos, std::vector&lt;uint256&gt;* pbranch) { if (pbranch) pbranch-&gt;clear(); if (leaves.size() == 0) { if (pmutated) *pmutated = false; if (proot) *proot = uint256(); return; } bool mutated = false; // count is the number of leaves processed so far. uint32_t count = 0; // inner is an array of eagerly computed subtree hashes, indexed by tree // level (0 being the leaves). // For example, when count is 25 (11001 in binary), inner[4] is the hash of // the first 16 leaves, inner[3] of the next 8 leaves, and inner[0] equal to // the last leaf. The other inner entries are undefined. uint256 inner[32]; // Which position in inner is a hash that depends on the matching leaf. int matchlevel = -1; // First process all leaves into &#39;inner&#39; values. while (count &lt; leaves.size()) { uint256 h = leaves[count]; bool matchh = count == branchpos; count++; int level; // For each of the lower bits in count that are 0, do 1 step. Each // corresponds to an inner value that existed before processing the // current leaf, and each needs a hash to combine it. for (level = 0; !(count &amp; (((uint32_t)1) &lt;&lt; level)); level++) { if (pbranch) { if (matchh) { pbranch-&gt;push_back(inner[level]); } else if (matchlevel == level) { pbranch-&gt;push_back(h); matchh = true; } } mutated |= (inner[level] == h); CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin()); } // Store the resulting hash at inner position level. inner[level] = h; if (matchh) { matchlevel = level; } } // Do a final &#39;sweep&#39; over the rightmost branch of the tree to process // odd levels, and reduce everything to a single top value. // Level is the level (counted from the bottom) up to which we&#39;ve sweeped. int level = 0; // As long as bit number level in count is zero, skip it. It means there // is nothing left at this level. while (!(count &amp; (((uint32_t)1) &lt;&lt; level))) { level++; } uint256 h = inner[level]; bool matchh = matchlevel == level; while (count != (((uint32_t)1) &lt;&lt; level)) { // If we reach this point, h is an inner value that is not the top. // We combine it with itself (Bitcoin&#39;s special rule for odd levels in // the tree) to produce a higher level one. if (pbranch &amp;&amp; matchh) { pbranch-&gt;push_back(h); } CHash256().Write(h.begin(), 32).Write(h.begin(), 32).Finalize(h.begin()); // Increment count to the value it would have if two entries at this // level had existed. count += (((uint32_t)1) &lt;&lt; level); level++; // And propagate the result upwards accordingly. while (!(count &amp; (((uint32_t)1) &lt;&lt; level))) { if (pbranch) { if (matchh) { pbranch-&gt;push_back(inner[level]); } else if (matchlevel == level) { pbranch-&gt;push_back(h); matchh = true; } } CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin()); level++; } } // Return result. if (pmutated) *pmutated = mutated; if (proot) *proot = h; } 2. 数字签名算法 椭圆曲线算法 2.1 椭圆曲线算法和公私钥 日常工作中，我们每天登录服务器，对公私钥系统已经非常熟悉了，公私钥并不是新鲜的技术。我们可以用ssh-keygen命令生成一对公钥和私钥；当拥有私钥时，可以用ssh-keygen -y -f生成配对的公钥，但拥有公钥无法生成配对的私钥。这背后的原理就是椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm, 简写为ECDSA)。比特币利用椭圆曲线生成密钥对，其中公钥作为交易接收方的地址，对外传播。 在平面直角坐标系中，一条椭圆曲线的形状如下图。比特币的源码中，椭圆曲线定义在src/secp256k1目录。比特币选择的椭圆曲线方程为y2 mod p = (x3 + 7) mod p，其中p是一个非常大的质数，p = 2256 - 232 - 29 - 28 - 27 - 26 - 24 - 1。 给定私钥k, 如何根据椭圆曲线生成公钥K呢？公式为K = k * G。其中，G 代表一种变换，从点k=(x,y)进行一次变换生成k1=(x1, y1)，先在点k出求正切线，正切线与椭圆曲线的交点… 下图用几何形式展示了变换G。 2.2 SHA-256 哈希函数在比特币中用途极为广泛，包括：比特币地址，交易脚本地址，挖矿工作量证明。在比特币系统中，利用公钥生成比特币地址的算法是SHA256和 RIPEMD160。 由公钥生成比特币地址的总体过程如下图所示 给定公钥K，先进行SHA256哈希，再对SHA256的结果进行RIPEMD160哈希，得到的值A就是比特币地址, 即A = RIPEMD160(SHA256(K))。A值进一步压缩, 我们就得到了比特币地址, 形如1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy。比特币选择的压缩算法是Base58Check。 SHA-256计算过程，如下图 我们来看一下比特币源码中SHA256哈希的实现 哈希函数类定义如下, 主体是状态s，由8个32位无符号整数组成。缓冲buf用于批量读入和计算数据。 /** A hasher class for SHA-256. */ class CSHA256 { private: uint32_t s[8]; unsigned char buf[64]; uint64_t bytes; public: static const size_t OUTPUT_SIZE = 32; CSHA256(); CSHA256&amp; Write(const unsigned char* data, size_t len); void Finalize(unsigned char hash[OUTPUT_SIZE]); CSHA256&amp; Reset(); }; SHA256的主体代码，数据data每64字节读入一次，写入buff，经过Transform处理，得到s值。 CSHA256&amp; CSHA256::Write(const unsigned char* data, size_t len) { const unsigned char* end = data + len; size_t bufsize = bytes % 64; if (bufsize &amp;&amp; bufsize + len &gt;= 64) { // Fill the buffer, and process it. memcpy(buf + bufsize, data, 64 - bufsize); bytes += 64 - bufsize; data += 64 - bufsize; Transform(s, buf, 1); bufsize = 0; } if (end - data &gt;= 64) { size_t blocks = (end - data) / 64; Transform(s, data, blocks); data += 64 * blocks; bytes += 64 * blocks; } if (end &gt; data) { // Fill the buffer with what remains. memcpy(buf + bufsize, data, end - data); bytes += end - data; } return *this; } 这里定义了一些基本运算，Ch, Maj, Sigma0, Sigma1, sigma0, sigma1，很直白，无需赘言。 uint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z) { return z ^ (x &amp; (y ^ z)); } uint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z) { return (x &amp; y) | (z &amp; (x | y)); } uint32_t inline Sigma0(uint32_t x) { return (x &gt;&gt; 2 | x &lt;&lt; 30) ^ (x &gt;&gt; 13 | x &lt;&lt; 19) ^ (x &gt;&gt; 22 | x &lt;&lt; 10); } uint32_t inline Sigma1(uint32_t x) { return (x &gt;&gt; 6 | x &lt;&lt; 26) ^ (x &gt;&gt; 11 | x &lt;&lt; 21) ^ (x &gt;&gt; 25 | x &lt;&lt; 7); } uint32_t inline sigma0(uint32_t x) { return (x &gt;&gt; 7 | x &lt;&lt; 25) ^ (x &gt;&gt; 18 | x &lt;&lt; 14) ^ (x &gt;&gt; 3); } uint32_t inline sigma1(uint32_t x) { return (x &gt;&gt; 17 | x &lt;&lt; 15) ^ (x &gt;&gt; 19 | x &lt;&lt; 13) ^ (x &gt;&gt; 10); } 初始化8个32位的无符号整数，作为初始状态。 /** Initialize SHA-256 state. */ void inline Initialize(uint32_t* s) { s[0] = 0x6a09e667ul; s[1] = 0xbb67ae85ul; s[2] = 0x3c6ef372ul; s[3] = 0xa54ff53aul; s[4] = 0x510e527ful; s[5] = 0x9b05688cul; s[6] = 0x1f83d9abul; s[7] = 0x5be0cd19ul; } /** One round of SHA-256. */ void inline Round(uint32_t a, uint32_t b, uint32_t c, uint32_t&amp; d, uint32_t e, uint32_t f, uint32_t g, uint32_t&amp; h, uint32_t k, uint32_t w) { uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w; uint32_t t2 = Sigma0(a) + Maj(a, b, c); d += t1; h = t1 + t2; } 每一轮SHA256计算过程如上所示，同样很直白，无需赘言。 下面的Transform函数比较有内容，函数输入一个64字节的chunk和状态s，每次从chunk读入4字节，根据当前状态s，做16次Round计算；完成后再做三轮16次Round；最后，8个无符号整数都加上上述64次Round的结果，更新状态s。经过上述计算，我们就得到了数据chunk的SHA256哈希值。 数据读写的代码，见/src/crypto/common.h /** Perform a number of SHA-256 transformations, processing 64-byte chunks. */ void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks) { while (blocks--) { uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7]; uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15; // 步骤一： Round(a, b, c, d, e, f, g, h, 0x428a2f98, w0 = ReadBE32(chunk + 0)); Round(h, a, b, c, d, e, f, g, 0x71374491, w1 = ReadBE32(chunk + 4)); // 中间省略... Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = ReadBE32(chunk + 56)); Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = ReadBE32(chunk + 60)); // 步骤二： Round(a, b, c, d, e, f, g, h, 0xe49b69c1, w0 += sigma1(w14) + w9 + sigma0(w1)); Round(h, a, b, c, d, e, f, g, 0xefbe4786, w1 += sigma1(w15) + w10 + sigma0(w2)); // 中间省略 Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) + w7 + sigma0(w15)); Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) + w8 + sigma0(w0)); // 步骤三： Round(a, b, c, d, e, f, g, h, 0x27b70a85, w0 += sigma1(w14) + w9 + sigma0(w1)); Round(h, a, b, c, d, e, f, g, 0x2e1b2138, w1 += sigma1(w15) + w10 + sigma0(w2)); // 中间省略 Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) + w7 + sigma0(w15)); Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) + w8 + sigma0(w0)); // 步骤四： Round(a, b, c, d, e, f, g, h, 0x19a4c116, w0 += sigma1(w14) + w9 + sigma0(w1)); Round(h, a, b, c, d, e, f, g, 0x1e376c08, w1 += sigma1(w15) + w10 + sigma0(w2)); // 中间省略 Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14 + sigma1(w12) + w7 + sigma0(w15)); Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15 + sigma1(w13) + w8 + sigma0(w0)); s[0] += a; s[1] += b; s[2] += c; s[3] += d; s[4] += e; s[5] += f; s[6] += g; s[7] += h; chunk += 64; } } 以上就是SHA256哈希算法的实现；下一步，我们分析交易结构。 二、交易 一般的交易系统设计：账户，余额。比特币的交易系统, 不记录余额，记录交易内容。例如，一般的交易系统，记录Alice的余额为10 RMB，Bob的余额为5RMB，当Alice发起交易，给Bob支付5RMB时，支付系统后台检查Alice的余额，验证通过后，对Alice的余额减5RMB，再对Bob的余额加5RMB。 而区块链处理的思路是，不记录Alice和Bob的账户余额，记录历史上发生过的所有交易记录，以未消费交易输出（UTXO）形式分布式地保存在区块链上，区块链网络节点共同验证UTXO是否合法。 构建比特币交易的基础是交易输出, 交易输出是比特币货币系统中不可拆分的块（chunk），记录在区块链上，被比特币网络认证；比特币网络节点记录所有可获得且可消费的交易输出，称作未消费交易输出(unspent transaction outputs), 简写成UTXO。 区块链上的一笔交易，代表着一组UTXO集合状态转换到另外一组UTXO集合状态。当产生新的“比特币”时，UTXO集合大小增加。UTXO是比特币交易的基础。“账户余额”的概念由比特币钱包应用创造，钱包应用扫描区块链，得到钱包拥有者的私钥可以消费的UTXO的总和，即“账户余额”。大多数钱包应用维护了一个数据库，用于存储该钱包私钥可以消费的UTXO集合。 2.1 交易格式 实际比特币的交易记录是二进制格式，转换成可读格式后，一笔交易的内容包含三个部分：元数据，输入，输出; 如下所示 { &quot;version&quot;: 1, &quot;locktime&quot;: 0, &quot;vin&quot;: [{ &quot;txid&quot;: &quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;, &quot;vout&quot;: 0, &quot;scriptSig&quot;: &quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;, &quot;sequence&quot;: 4294967295 }], &quot;vout&quot;: [{ &quot;value&quot;: 0.01500000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG &quot; }, { &quot;value&quot;: 0.08450000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot; }] } 值得注意的是，每个输入包含了一项scirptSig, 上例中是3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf, 每个输出的元素都包含了一项scriptPubKey, 上例中是ab68025513c3dbd2f7b92a94e0581f5d50f654e7, 这个值代表了交易脚本的哈希值。(稍后详细描述) 比特币交易结构，见primitives/transaction.h /** * Basic transaction serialization format: * - int32_t nVersion * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - uint32_t nLockTime * * Extended transaction serialization format: * - int32_t nVersion * - unsigned char dummy = 0x00 * - unsigned char flags (!= 0) * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - if (flags &amp; 1): * - CTxWitness wit; * - uint32_t nLockTime */ 可以看到，基本交易序列化格式的信息包括：版本号，输入列表，输出列表，锁定时间；此外，扩展的交易序列化格式还包括扩容方案隔离见证的一些信息。关于比特币扩容和隔离见证此处不展开讨论，准备单独写一篇笔记。对比特币扩容方案感兴趣的读者，建议阅读BIP-141, BIP-143和BIP-147。 交易输入定义，见src/primitives/transaction.h /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. */ class CTxIn { public: COutPoint prevout; CScript scriptSig; uint32_t nSequence; CScriptWitness scriptWitness; //! Only serialized through CTransaction /* Setting nSequence to this value for every input in a transaction * disables nLockTime. */ static const uint32_t SEQUENCE_FINAL = 0xffffffff; /* Below flags apply in the context of BIP 68*/ /* If this flag set, CTxIn::nSequence is NOT interpreted as a * relative lock-time. */ static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 &lt;&lt; 31); /* If CTxIn::nSequence encodes a relative lock-time and this flag * is set, the relative lock-time has units of 512 seconds, * otherwise it specifies blocks with a granularity of 1. */ static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 &lt;&lt; 22); /* If CTxIn::nSequence encodes a relative lock-time, this mask is * applied to extract that lock-time from the sequence field. */ static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff; /* In order to use the same number of bits to encode roughly the * same wall-clock duration, and because blocks are naturally * limited to occur every 600s on average, the minimum granularity * for time-based relative lock-time is fixed at 512 seconds. * Converting from CTxIn::nSequence to seconds is performed by * multiplying by 512 = 2^9, or equivalently shifting up by * 9 bits. */ static const int SEQUENCE_LOCKTIME_GRANULARITY = 9; CTxIn() { nSequence = SEQUENCE_FINAL; } explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(prevout); READWRITE(scriptSig); READWRITE(nSequence); } friend bool operator==(const CTxIn&amp; a, const CTxIn&amp; b) { return (a.prevout == b.prevout &amp;&amp; a.scriptSig == b.scriptSig &amp;&amp; a.nSequence == b.nSequence); } friend bool operator!=(const CTxIn&amp; a, const CTxIn&amp; b) { return !(a == b); } std::string ToString() const; }; 交易输出定义，见src/primitives/transaction.h /** An output of a transaction. It contains the public key that the next input * must be able to sign with to claim it. */ class CTxOut { public: CAmount nValue; CScript scriptPubKey; CTxOut() { SetNull(); } CTxOut(const CAmount&amp; nValueIn, CScript scriptPubKeyIn); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(nValue); READWRITE(scriptPubKey); } void SetNull() { nValue = -1; scriptPubKey.clear(); } bool IsNull() const { return (nValue == -1); } friend bool operator==(const CTxOut&amp; a, const CTxOut&amp; b) { return (a.nValue == b.nValue &amp;&amp; a.scriptPubKey == b.scriptPubKey); } friend bool operator!=(const CTxOut&amp; a, const CTxOut&amp; b) { return !(a == b); } std::string ToString() const; }; 2.2 交易脚本 比特币脚本语言是专为比特币而设计的简化版本的程序语言。比特币脚本语言有意设计成非图灵完备语言，计算表达能力受到了一定的限制。最主要的有三点：1.数据存储在栈中，不支持定义变量；2. 限制比特币脚本的可用内存和执行时间；3. 比特币脚本中不支持循环，避免死循环导致浪费比特币矿工计算资源。 比特币脚本指令集合，总共有256个操作，其中15个禁用，75个保留。主要的操作为：1. 算数操作，如加减法 2. 分支判断 if/then 3. 逻辑和数据处理 与或非，抛出异常和捕获异常，提前返回等 4. 加密算法，包括哈希函数，签名认证，多重签名认证等。 值得注意的是，比特币脚本语言具有强大的加密算法库，支持在一条操作中对多重签名进行验证，即OP_CHECKMULTISIG操作。多重签名意味着，指定n个公钥，指定一个阈值参数t，表示如果操作想要正常执行，至少匹配n个公钥中的的t个签名。 2.3 未消费交易输出, UTXO 终于到了“币”的环节, “币”在比特币的源码世界里，定义如下，见src/coins.h /** * A UTXO entry. * * Serialized format: * - VARINT((coinbase ? 1 : 0) | (height &lt;&lt; 1)) * - the non-spent CTxOut (via CTxOutCompressor) */ class Coin { public: //! unspent transaction output CTxOut out; //! whether containing transaction was a coinbase unsigned int fCoinBase : 1; //! at which height this containing transaction was included in the active block chain uint32_t nHeight : 31; //! construct a Coin from a CTxOut and height/coinbase information. Coin(CTxOut&amp;&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {} Coin(const CTxOut&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {} void Clear() { out.SetNull(); fCoinBase = false; nHeight = 0; } //! empty constructor Coin() : fCoinBase(false), nHeight(0) { } bool IsCoinBase() const { return fCoinBase; } template&lt;typename Stream&gt; void Serialize(Stream &amp;s) const { assert(!IsSpent()); uint32_t code = nHeight * 2 + fCoinBase; ::Serialize(s, VARINT(code)); ::Serialize(s, CTxOutCompressor(REF(out))); } template&lt;typename Stream&gt; void Unserialize(Stream &amp;s) { uint32_t code = 0; ::Unserialize(s, VARINT(code)); nHeight = code &gt;&gt; 1; fCoinBase = code &amp; 1; ::Unserialize(s, REF(CTxOutCompressor(out))); } bool IsSpent() const { return out.IsNull(); } size_t DynamicMemoryUsage() const { return memusage::DynamicUsage(out.scriptPubKey); } }; 参考资料 普林斯顿大学公开课 Coursera Mastering Bitcoin 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"比特币源码阅读笔记【基础篇】 出差坐火车ing，正好利用这段时间学习一波比特币源代码，比特币源码的主要语言是C++，测试代码语言主要是Python。 一、区块链数据结构和数字签名算法 1. 数据结构 Merkle树 区块链, 顾名思义是由一个个区块按一定规则组成的链。何谓区块，我们可以用命令行工具bitcoin-cli或者区块链浏览器(blockchain.info等网站)浏览区块详细信息, 例如： { &quot;size&quot;: 43560, &quot;version&quot;: 2, &quot;previousblockhash&quot;: &quot;00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249&quot;, &quot;merkleroot&quot;: &quot;5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d&quot;, &quot;time&quot;: 1388185038, &quot;difficulty&quot;: 1180923195.25802612, &quot;nonce&quot;: 4215469401, &quot;tx&quot;: [&quot;257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77&quot;, # [...many more transactions omitted...] &quot;05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634&quot; ] } 区块包含的信息分几个部分：1.元信息，如version,time,size等 2. 挖矿信息，如仅用一次的随机数nonce, 难度系数difficulty 3. 交易数据 4. 交易摘要，merkleroot和perviousblockhash。 比特币采用Merkle树进行交易摘要。 Merkle树的基础是哈希函数和非对称数字签名，比特币选择的哈希函数是两层SHA256。交易本身不存储在Merkle树中，Merkle树保存交易的哈希值。例如，一笔交易A的哈希值计算过程HA = SHA256(SHA256(A)) , 两笔交易A和B的哈希值计算过程为H(A,B) = SHA256(SHA256(HA+HB)))。交易数据两两计算，最终组成一个哈希二叉树，如下图所示 这两个字段，merkleroot表示整条链的交易摘要哈希值，perviousblockhash表示该区块在链中的位置； 下图是一个链的样例： 到此为止，我们已经知道，比特币区块链的基础数据结构是Merkle树。Merkle树是哈希指针形式的二叉树，每个节点包含其子节点的哈希值，一旦子节点的结构或内容发生变动，该节点的哈希值必然发生改变，从而，两个Merkle树最上层节点的哈希值相同，我们就认为两个Merkle树是完全一致的。 Merkle树计算核心函数，见consensus/merkle.cpp /* This implements a constant-space merkle root/path calculator, limited to 2^32 leaves. */ static void MerkleComputation(const std::vector&lt;uint256&gt;&amp; leaves, uint256* proot, bool* pmutated, uint32_t branchpos, std::vector&lt;uint256&gt;* pbranch) { if (pbranch) pbranch-&gt;clear(); if (leaves.size() == 0) { if (pmutated) *pmutated = false; if (proot) *proot = uint256(); return; } bool mutated = false; // count is the number of leaves processed so far. uint32_t count = 0; // inner is an array of eagerly computed subtree hashes, indexed by tree // level (0 being the leaves). // For example, when count is 25 (11001 in binary), inner[4] is the hash of // the first 16 leaves, inner[3] of the next 8 leaves, and inner[0] equal to // the last leaf. The other inner entries are undefined. uint256 inner[32]; // Which position in inner is a hash that depends on the matching leaf. int matchlevel = -1; // First process all leaves into &#39;inner&#39; values. while (count &lt; leaves.size()) { uint256 h = leaves[count]; bool matchh = count == branchpos; count++; int level; // For each of the lower bits in count that are 0, do 1 step. Each // corresponds to an inner value that existed before processing the // current leaf, and each needs a hash to combine it. for (level = 0; !(count &amp; (((uint32_t)1) &lt;&lt; level)); level++) { if (pbranch) { if (matchh) { pbranch-&gt;push_back(inner[level]); } else if (matchlevel == level) { pbranch-&gt;push_back(h); matchh = true; } } mutated |= (inner[level] == h); CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin()); } // Store the resulting hash at inner position level. inner[level] = h; if (matchh) { matchlevel = level; } } // Do a final &#39;sweep&#39; over the rightmost branch of the tree to process // odd levels, and reduce everything to a single top value. // Level is the level (counted from the bottom) up to which we&#39;ve sweeped. int level = 0; // As long as bit number level in count is zero, skip it. It means there // is nothing left at this level. while (!(count &amp; (((uint32_t)1) &lt;&lt; level))) { level++; } uint256 h = inner[level]; bool matchh = matchlevel == level; while (count != (((uint32_t)1) &lt;&lt; level)) { // If we reach this point, h is an inner value that is not the top. // We combine it with itself (Bitcoin&#39;s special rule for odd levels in // the tree) to produce a higher level one. if (pbranch &amp;&amp; matchh) { pbranch-&gt;push_back(h); } CHash256().Write(h.begin(), 32).Write(h.begin(), 32).Finalize(h.begin()); // Increment count to the value it would have if two entries at this // level had existed. count += (((uint32_t)1) &lt;&lt; level); level++; // And propagate the result upwards accordingly. while (!(count &amp; (((uint32_t)1) &lt;&lt; level))) { if (pbranch) { if (matchh) { pbranch-&gt;push_back(inner[level]); } else if (matchlevel == level) { pbranch-&gt;push_back(h); matchh = true; } } CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin()); level++; } } // Return result. if (pmutated) *pmutated = mutated; if (proot) *proot = h; } 2. 数字签名算法 椭圆曲线算法 2.1 椭圆曲线算法和公私钥 日常工作中，我们每天登录服务器，对公私钥系统已经非常熟悉了，公私钥并不是新鲜的技术。我们可以用ssh-keygen命令生成一对公钥和私钥；当拥有私钥时，可以用ssh-keygen -y -f生成配对的公钥，但拥有公钥无法生成配对的私钥。这背后的原理就是椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm, 简写为ECDSA)。比特币利用椭圆曲线生成密钥对，其中公钥作为交易接收方的地址，对外传播。 在平面直角坐标系中，一条椭圆曲线的形状如下图。比特币的源码中，椭圆曲线定义在src/secp256k1目录。比特币选择的椭圆曲线方程为y2 mod p = (x3 + 7) mod p，其中p是一个非常大的质数，p = 2256 - 232 - 29 - 28 - 27 - 26 - 24 - 1。 给定私钥k, 如何根据椭圆曲线生成公钥K呢？公式为K = k * G。其中，G 代表一种变换，从点k=(x,y)进行一次变换生成k1=(x1, y1)，先在点k出求正切线，正切线与椭圆曲线的交点… 下图用几何形式展示了变换G。 2.2 SHA-256 哈希函数在比特币中用途极为广泛，包括：比特币地址，交易脚本地址，挖矿工作量证明。在比特币系统中，利用公钥生成比特币地址的算法是SHA256和 RIPEMD160。 由公钥生成比特币地址的总体过程如下图所示 给定公钥K，先进行SHA256哈希，再对SHA256的结果进行RIPEMD160哈希，得到的值A就是比特币地址, 即A = RIPEMD160(SHA256(K))。A值进一步压缩, 我们就得到了比特币地址, 形如1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy。比特币选择的压缩算法是Base58Check。 SHA-256计算过程，如下图 我们来看一下比特币源码中SHA256哈希的实现 哈希函数类定义如下, 主体是状态s，由8个32位无符号整数组成。缓冲buf用于批量读入和计算数据。 /** A hasher class for SHA-256. */ class CSHA256 { private: uint32_t s[8]; unsigned char buf[64]; uint64_t bytes; public: static const size_t OUTPUT_SIZE = 32; CSHA256(); CSHA256&amp; Write(const unsigned char* data, size_t len); void Finalize(unsigned char hash[OUTPUT_SIZE]); CSHA256&amp; Reset(); }; SHA256的主体代码，数据data每64字节读入一次，写入buff，经过Transform处理，得到s值。 CSHA256&amp; CSHA256::Write(const unsigned char* data, size_t len) { const unsigned char* end = data + len; size_t bufsize = bytes % 64; if (bufsize &amp;&amp; bufsize + len &gt;= 64) { // Fill the buffer, and process it. memcpy(buf + bufsize, data, 64 - bufsize); bytes += 64 - bufsize; data += 64 - bufsize; Transform(s, buf, 1); bufsize = 0; } if (end - data &gt;= 64) { size_t blocks = (end - data) / 64; Transform(s, data, blocks); data += 64 * blocks; bytes += 64 * blocks; } if (end &gt; data) { // Fill the buffer with what remains. memcpy(buf + bufsize, data, end - data); bytes += end - data; } return *this; } 这里定义了一些基本运算，Ch, Maj, Sigma0, Sigma1, sigma0, sigma1，很直白，无需赘言。 uint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z) { return z ^ (x &amp; (y ^ z)); } uint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z) { return (x &amp; y) | (z &amp; (x | y)); } uint32_t inline Sigma0(uint32_t x) { return (x &gt;&gt; 2 | x &lt;&lt; 30) ^ (x &gt;&gt; 13 | x &lt;&lt; 19) ^ (x &gt;&gt; 22 | x &lt;&lt; 10); } uint32_t inline Sigma1(uint32_t x) { return (x &gt;&gt; 6 | x &lt;&lt; 26) ^ (x &gt;&gt; 11 | x &lt;&lt; 21) ^ (x &gt;&gt; 25 | x &lt;&lt; 7); } uint32_t inline sigma0(uint32_t x) { return (x &gt;&gt; 7 | x &lt;&lt; 25) ^ (x &gt;&gt; 18 | x &lt;&lt; 14) ^ (x &gt;&gt; 3); } uint32_t inline sigma1(uint32_t x) { return (x &gt;&gt; 17 | x &lt;&lt; 15) ^ (x &gt;&gt; 19 | x &lt;&lt; 13) ^ (x &gt;&gt; 10); } 初始化8个32位的无符号整数，作为初始状态。 /** Initialize SHA-256 state. */ void inline Initialize(uint32_t* s) { s[0] = 0x6a09e667ul; s[1] = 0xbb67ae85ul; s[2] = 0x3c6ef372ul; s[3] = 0xa54ff53aul; s[4] = 0x510e527ful; s[5] = 0x9b05688cul; s[6] = 0x1f83d9abul; s[7] = 0x5be0cd19ul; } /** One round of SHA-256. */ void inline Round(uint32_t a, uint32_t b, uint32_t c, uint32_t&amp; d, uint32_t e, uint32_t f, uint32_t g, uint32_t&amp; h, uint32_t k, uint32_t w) { uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w; uint32_t t2 = Sigma0(a) + Maj(a, b, c); d += t1; h = t1 + t2; } 每一轮SHA256计算过程如上所示，同样很直白，无需赘言。 下面的Transform函数比较有内容，函数输入一个64字节的chunk和状态s，每次从chunk读入4字节，根据当前状态s，做16次Round计算；完成后再做三轮16次Round；最后，8个无符号整数都加上上述64次Round的结果，更新状态s。经过上述计算，我们就得到了数据chunk的SHA256哈希值。 数据读写的代码，见/src/crypto/common.h /** Perform a number of SHA-256 transformations, processing 64-byte chunks. */ void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks) { while (blocks--) { uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7]; uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15; // 步骤一： Round(a, b, c, d, e, f, g, h, 0x428a2f98, w0 = ReadBE32(chunk + 0)); Round(h, a, b, c, d, e, f, g, 0x71374491, w1 = ReadBE32(chunk + 4)); // 中间省略... Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = ReadBE32(chunk + 56)); Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = ReadBE32(chunk + 60)); // 步骤二： Round(a, b, c, d, e, f, g, h, 0xe49b69c1, w0 += sigma1(w14) + w9 + sigma0(w1)); Round(h, a, b, c, d, e, f, g, 0xefbe4786, w1 += sigma1(w15) + w10 + sigma0(w2)); // 中间省略 Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) + w7 + sigma0(w15)); Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) + w8 + sigma0(w0)); // 步骤三： Round(a, b, c, d, e, f, g, h, 0x27b70a85, w0 += sigma1(w14) + w9 + sigma0(w1)); Round(h, a, b, c, d, e, f, g, 0x2e1b2138, w1 += sigma1(w15) + w10 + sigma0(w2)); // 中间省略 Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) + w7 + sigma0(w15)); Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) + w8 + sigma0(w0)); // 步骤四： Round(a, b, c, d, e, f, g, h, 0x19a4c116, w0 += sigma1(w14) + w9 + sigma0(w1)); Round(h, a, b, c, d, e, f, g, 0x1e376c08, w1 += sigma1(w15) + w10 + sigma0(w2)); // 中间省略 Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14 + sigma1(w12) + w7 + sigma0(w15)); Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15 + sigma1(w13) + w8 + sigma0(w0)); s[0] += a; s[1] += b; s[2] += c; s[3] += d; s[4] += e; s[5] += f; s[6] += g; s[7] += h; chunk += 64; } } 以上就是SHA256哈希算法的实现；下一步，我们分析交易结构。 二、交易 一般的交易系统设计：账户，余额。比特币的交易系统, 不记录余额，记录交易内容。例如，一般的交易系统，记录Alice的余额为10 RMB，Bob的余额为5RMB，当Alice发起交易，给Bob支付5RMB时，支付系统后台检查Alice的余额，验证通过后，对Alice的余额减5RMB，再对Bob的余额加5RMB。 而区块链处理的思路是，不记录Alice和Bob的账户余额，记录历史上发生过的所有交易记录，以未消费交易输出（UTXO）形式分布式地保存在区块链上，区块链网络节点共同验证UTXO是否合法。 构建比特币交易的基础是交易输出, 交易输出是比特币货币系统中不可拆分的块（chunk），记录在区块链上，被比特币网络认证；比特币网络节点记录所有可获得且可消费的交易输出，称作未消费交易输出(unspent transaction outputs), 简写成UTXO。 区块链上的一笔交易，代表着一组UTXO集合状态转换到另外一组UTXO集合状态。当产生新的“比特币”时，UTXO集合大小增加。UTXO是比特币交易的基础。“账户余额”的概念由比特币钱包应用创造，钱包应用扫描区块链，得到钱包拥有者的私钥可以消费的UTXO的总和，即“账户余额”。大多数钱包应用维护了一个数据库，用于存储该钱包私钥可以消费的UTXO集合。 2.1 交易格式 实际比特币的交易记录是二进制格式，转换成可读格式后，一笔交易的内容包含三个部分：元数据，输入，输出; 如下所示 { &quot;version&quot;: 1, &quot;locktime&quot;: 0, &quot;vin&quot;: [{ &quot;txid&quot;: &quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;, &quot;vout&quot;: 0, &quot;scriptSig&quot;: &quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;, &quot;sequence&quot;: 4294967295 }], &quot;vout&quot;: [{ &quot;value&quot;: 0.01500000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG &quot; }, { &quot;value&quot;: 0.08450000, &quot;scriptPubKey&quot;: &quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot; }] } 值得注意的是，每个输入包含了一项scirptSig, 上例中是3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf, 每个输出的元素都包含了一项scriptPubKey, 上例中是ab68025513c3dbd2f7b92a94e0581f5d50f654e7, 这个值代表了交易脚本的哈希值。(稍后详细描述) 比特币交易结构，见primitives/transaction.h /** * Basic transaction serialization format: * - int32_t nVersion * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - uint32_t nLockTime * * Extended transaction serialization format: * - int32_t nVersion * - unsigned char dummy = 0x00 * - unsigned char flags (!= 0) * - std::vector&lt;CTxIn&gt; vin * - std::vector&lt;CTxOut&gt; vout * - if (flags &amp; 1): * - CTxWitness wit; * - uint32_t nLockTime */ 可以看到，基本交易序列化格式的信息包括：版本号，输入列表，输出列表，锁定时间；此外，扩展的交易序列化格式还包括扩容方案隔离见证的一些信息。关于比特币扩容和隔离见证此处不展开讨论，准备单独写一篇笔记。对比特币扩容方案感兴趣的读者，建议阅读BIP-141, BIP-143和BIP-147。 交易输入定义，见src/primitives/transaction.h /** An input of a transaction. It contains the location of the previous * transaction&#39;s output that it claims and a signature that matches the * output&#39;s public key. */ class CTxIn { public: COutPoint prevout; CScript scriptSig; uint32_t nSequence; CScriptWitness scriptWitness; //! Only serialized through CTransaction /* Setting nSequence to this value for every input in a transaction * disables nLockTime. */ static const uint32_t SEQUENCE_FINAL = 0xffffffff; /* Below flags apply in the context of BIP 68*/ /* If this flag set, CTxIn::nSequence is NOT interpreted as a * relative lock-time. */ static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 &lt;&lt; 31); /* If CTxIn::nSequence encodes a relative lock-time and this flag * is set, the relative lock-time has units of 512 seconds, * otherwise it specifies blocks with a granularity of 1. */ static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 &lt;&lt; 22); /* If CTxIn::nSequence encodes a relative lock-time, this mask is * applied to extract that lock-time from the sequence field. */ static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff; /* In order to use the same number of bits to encode roughly the * same wall-clock duration, and because blocks are naturally * limited to occur every 600s on average, the minimum granularity * for time-based relative lock-time is fixed at 512 seconds. * Converting from CTxIn::nSequence to seconds is performed by * multiplying by 512 = 2^9, or equivalently shifting up by * 9 bits. */ static const int SEQUENCE_LOCKTIME_GRANULARITY = 9; CTxIn() { nSequence = SEQUENCE_FINAL; } explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(prevout); READWRITE(scriptSig); READWRITE(nSequence); } friend bool operator==(const CTxIn&amp; a, const CTxIn&amp; b) { return (a.prevout == b.prevout &amp;&amp; a.scriptSig == b.scriptSig &amp;&amp; a.nSequence == b.nSequence); } friend bool operator!=(const CTxIn&amp; a, const CTxIn&amp; b) { return !(a == b); } std::string ToString() const; }; 交易输出定义，见src/primitives/transaction.h /** An output of a transaction. It contains the public key that the next input * must be able to sign with to claim it. */ class CTxOut { public: CAmount nValue; CScript scriptPubKey; CTxOut() { SetNull(); } CTxOut(const CAmount&amp; nValueIn, CScript scriptPubKeyIn); ADD_SERIALIZE_METHODS; template &lt;typename Stream, typename Operation&gt; inline void SerializationOp(Stream&amp; s, Operation ser_action) { READWRITE(nValue); READWRITE(scriptPubKey); } void SetNull() { nValue = -1; scriptPubKey.clear(); } bool IsNull() const { return (nValue == -1); } friend bool operator==(const CTxOut&amp; a, const CTxOut&amp; b) { return (a.nValue == b.nValue &amp;&amp; a.scriptPubKey == b.scriptPubKey); } friend bool operator!=(const CTxOut&amp; a, const CTxOut&amp; b) { return !(a == b); } std::string ToString() const; }; 2.2 交易脚本 比特币脚本语言是专为比特币而设计的简化版本的程序语言。比特币脚本语言有意设计成非图灵完备语言，计算表达能力受到了一定的限制。最主要的有三点：1.数据存储在栈中，不支持定义变量；2. 限制比特币脚本的可用内存和执行时间；3. 比特币脚本中不支持循环，避免死循环导致浪费比特币矿工计算资源。 比特币脚本指令集合，总共有256个操作，其中15个禁用，75个保留。主要的操作为：1. 算数操作，如加减法 2. 分支判断 if/then 3. 逻辑和数据处理 与或非，抛出异常和捕获异常，提前返回等 4. 加密算法，包括哈希函数，签名认证，多重签名认证等。 值得注意的是，比特币脚本语言具有强大的加密算法库，支持在一条操作中对多重签名进行验证，即OP_CHECKMULTISIG操作。多重签名意味着，指定n个公钥，指定一个阈值参数t，表示如果操作想要正常执行，至少匹配n个公钥中的的t个签名。 2.3 未消费交易输出, UTXO 终于到了“币”的环节, “币”在比特币的源码世界里，定义如下，见src/coins.h /** * A UTXO entry. * * Serialized format: * - VARINT((coinbase ? 1 : 0) | (height &lt;&lt; 1)) * - the non-spent CTxOut (via CTxOutCompressor) */ class Coin { public: //! unspent transaction output CTxOut out; //! whether containing transaction was a coinbase unsigned int fCoinBase : 1; //! at which height this containing transaction was included in the active block chain uint32_t nHeight : 31; //! construct a Coin from a CTxOut and height/coinbase information. Coin(CTxOut&amp;&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {} Coin(const CTxOut&amp; outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {} void Clear() { out.SetNull(); fCoinBase = false; nHeight = 0; } //! empty constructor Coin() : fCoinBase(false), nHeight(0) { } bool IsCoinBase() const { return fCoinBase; } template&lt;typename Stream&gt; void Serialize(Stream &amp;s) const { assert(!IsSpent()); uint32_t code = nHeight * 2 + fCoinBase; ::Serialize(s, VARINT(code)); ::Serialize(s, CTxOutCompressor(REF(out))); } template&lt;typename Stream&gt; void Unserialize(Stream &amp;s) { uint32_t code = 0; ::Unserialize(s, VARINT(code)); nHeight = code &gt;&gt; 1; fCoinBase = code &amp; 1; ::Unserialize(s, REF(CTxOutCompressor(out))); } bool IsSpent() const { return out.IsNull(); } size_t DynamicMemoryUsage() const { return memusage::DynamicUsage(out.scriptPubKey); } }; 参考资料 普林斯顿大学公开课 Coursera Mastering Bitcoin 阅读更多","@type":"BlogPosting","url":"/2018/03/06/1d324332a919569be54ac53bbf1697fb.html","headline":"比特币源码阅读笔记【基础篇】","dateModified":"2018-03-06T00:00:00+08:00","datePublished":"2018-03-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/03/06/1d324332a919569be54ac53bbf1697fb.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>比特币源码阅读笔记【基础篇】</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="比特币源码阅读笔记基础篇">比特币源码阅读笔记【基础篇】</h1> 
  <p>出差坐火车ing，正好利用这段时间学习一波比特币源代码，比特币源码的主要语言是C++，测试代码语言主要是Python。</p> 
  <h2 id="一区块链数据结构和数字签名算法">一、区块链数据结构和数字签名算法</h2> 
  <h3 id="1-数据结构-merkle树">1. 数据结构 Merkle树</h3> 
  <p>区块链, 顾名思义是由一个个<strong>区块</strong>按一定规则组成的<strong>链</strong>。何谓区块，我们可以用命令行工具bitcoin-cli或者区块链浏览器(blockchain.info等网站)浏览区块详细信息, 例如：</p> 
  <pre class="prettyprint"><code class=" hljs json">{
    "<span class="hljs-attribute">size</span>": <span class="hljs-value"><span class="hljs-number">43560</span></span>,
    "<span class="hljs-attribute">version</span>": <span class="hljs-value"><span class="hljs-number">2</span></span>,
    "<span class="hljs-attribute">previousblockhash</span>": <span class="hljs-value"><span class="hljs-string">"00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249"</span></span>,
    "<span class="hljs-attribute">merkleroot</span>": <span class="hljs-value"><span class="hljs-string">"5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d"</span></span>,
    "<span class="hljs-attribute">time</span>": <span class="hljs-value"><span class="hljs-number">1388185038</span></span>,
    "<span class="hljs-attribute">difficulty</span>": <span class="hljs-value"><span class="hljs-number">1180923195.25802612</span></span>,
    "<span class="hljs-attribute">nonce</span>": <span class="hljs-value"><span class="hljs-number">4215469401</span></span>,
    "<span class="hljs-attribute">tx</span>": <span class="hljs-value">[<span class="hljs-string">"257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77"</span>, # [...many more transactions omitted...] <span class="hljs-string">"05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634"</span> ] </span>}</code></pre> 
  <p>区块包含的信息分几个部分：1.元信息，如<code>version</code>,<code>time</code>,<code>size</code>等 2. 挖矿信息，如仅用一次的随机数<code>nonce</code>, 难度系数<code>difficulty</code> 3. 交易数据 4. 交易摘要，<code>merkleroot</code>和<code>perviousblockhash</code>。</p> 
  <p>比特币采用Merkle树进行<strong>交易摘要</strong>。 Merkle树的基础是哈希函数和非对称数字签名，比特币选择的哈希函数是两层SHA256。交易本身不存储在Merkle树中，Merkle树保存交易的哈希值。例如，一笔交易A的哈希值计算过程H<sub>A</sub> = SHA256(SHA256(A)) <br> , 两笔交易A和B的哈希值计算过程为H<sub>(A,B)</sub> = SHA256(SHA256(H<sub>A</sub>+H<sub>B</sub>)))。交易数据两两计算，最终组成一个哈希二叉树，如下图所示 <br> <img src="http://static.zybuluo.com/renqHIT/far07jrcaeswpvnb6m89u30l/WX20180224-010301@2x.png" alt="WX20180224-010301@2x.png-61.3kB" title=""></p> 
  <p>这两个字段，<code>merkleroot</code>表示整条链的交易摘要哈希值，<code>perviousblockhash</code>表示该区块在链中的位置； <br> 下图是一个<strong>链</strong>的样例： <br> <img src="http://static.zybuluo.com/renqHIT/ccfr1cl2ki0v8dbuh4vhaxzf/WX20180224-004307@2x.png" alt="WX20180224-004307@2x.png-337.5kB" title=""></p> 
  <p>到此为止，我们已经知道，比特币区块链的基础数据结构是Merkle树。Merkle树是哈希指针形式的二叉树，每个节点包含其子节点的哈希值，一旦子节点的结构或内容发生变动，该节点的哈希值必然发生改变，从而，两个Merkle树最上层节点的哈希值相同，我们就认为两个Merkle树是完全一致的。</p> 
  <p>Merkle树计算核心函数，见<code>consensus/merkle.cpp</code></p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">/* This implements a constant-space merkle root/path calculator, limited to 2^32 leaves. */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> MerkleComputation(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint256&gt;</span>&amp; leaves, uint256* proot, <span class="hljs-keyword">bool</span>* pmutated, uint32_t branchpos, <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uint256&gt;</span>* pbranch) {
    <span class="hljs-keyword">if</span> (pbranch) pbranch-&gt;clear();
    <span class="hljs-keyword">if</span> (leaves.size() == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (pmutated) *pmutated = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (proot) *proot = uint256();
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">bool</span> mutated = <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// count is the number of leaves processed so far.</span>
    uint32_t count = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// inner is an array of eagerly computed subtree hashes, indexed by tree</span>
    <span class="hljs-comment">// level (0 being the leaves).</span>
    <span class="hljs-comment">// For example, when count is 25 (11001 in binary), inner[4] is the hash of</span>
    <span class="hljs-comment">// the first 16 leaves, inner[3] of the next 8 leaves, and inner[0] equal to</span>
    <span class="hljs-comment">// the last leaf. The other inner entries are undefined.</span>
    uint256 inner[<span class="hljs-number">32</span>];
    <span class="hljs-comment">// Which position in inner is a hash that depends on the matching leaf.</span>
    <span class="hljs-keyword">int</span> matchlevel = -<span class="hljs-number">1</span>;
    <span class="hljs-comment">// First process all leaves into 'inner' values.</span>
    <span class="hljs-keyword">while</span> (count &lt; leaves.size()) {
        uint256 h = leaves[count];
        <span class="hljs-keyword">bool</span> matchh = count == branchpos;
        count++;
        <span class="hljs-keyword">int</span> level;
        <span class="hljs-comment">// For each of the lower bits in count that are 0, do 1 step. Each</span>
        <span class="hljs-comment">// corresponds to an inner value that existed before processing the</span>
        <span class="hljs-comment">// current leaf, and each needs a hash to combine it.</span>
        <span class="hljs-keyword">for</span> (level = <span class="hljs-number">0</span>; !(count &amp; (((uint32_t)<span class="hljs-number">1</span>) &lt;&lt; level)); level++) {
            <span class="hljs-keyword">if</span> (pbranch) {
                <span class="hljs-keyword">if</span> (matchh) {
                    pbranch-&gt;push_back(inner[level]);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matchlevel == level) {
                    pbranch-&gt;push_back(h);
                    matchh = <span class="hljs-keyword">true</span>;
                }
            }
            mutated |= (inner[level] == h);
            CHash256().Write(inner[level].begin(), <span class="hljs-number">32</span>).Write(h.begin(), <span class="hljs-number">32</span>).Finalize(h.begin());
        }
        <span class="hljs-comment">// Store the resulting hash at inner position level.</span>
        inner[level] = h;
        <span class="hljs-keyword">if</span> (matchh) {
            matchlevel = level;
        }
    }
    <span class="hljs-comment">// Do a final 'sweep' over the rightmost branch of the tree to process</span>
    <span class="hljs-comment">// odd levels, and reduce everything to a single top value.</span>
    <span class="hljs-comment">// Level is the level (counted from the bottom) up to which we've sweeped.</span>
    <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// As long as bit number level in count is zero, skip it. It means there</span>
    <span class="hljs-comment">// is nothing left at this level.</span>
    <span class="hljs-keyword">while</span> (!(count &amp; (((uint32_t)<span class="hljs-number">1</span>) &lt;&lt; level))) {
        level++;
    }
    uint256 h = inner[level];
    <span class="hljs-keyword">bool</span> matchh = matchlevel == level;
    <span class="hljs-keyword">while</span> (count != (((uint32_t)<span class="hljs-number">1</span>) &lt;&lt; level)) {
        <span class="hljs-comment">// If we reach this point, h is an inner value that is not the top.</span>
        <span class="hljs-comment">// We combine it with itself (Bitcoin's special rule for odd levels in</span>
        <span class="hljs-comment">// the tree) to produce a higher level one.</span>
        <span class="hljs-keyword">if</span> (pbranch &amp;&amp; matchh) {
            pbranch-&gt;push_back(h);
        }
        CHash256().Write(h.begin(), <span class="hljs-number">32</span>).Write(h.begin(), <span class="hljs-number">32</span>).Finalize(h.begin());
        <span class="hljs-comment">// Increment count to the value it would have if two entries at this</span>
        <span class="hljs-comment">// level had existed.</span>
        count += (((uint32_t)<span class="hljs-number">1</span>) &lt;&lt; level);
        level++;
        <span class="hljs-comment">// And propagate the result upwards accordingly.</span>
        <span class="hljs-keyword">while</span> (!(count &amp; (((uint32_t)<span class="hljs-number">1</span>) &lt;&lt; level))) {
            <span class="hljs-keyword">if</span> (pbranch) {
                <span class="hljs-keyword">if</span> (matchh) {
                    pbranch-&gt;push_back(inner[level]);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matchlevel == level) {
                    pbranch-&gt;push_back(h);
                    matchh = <span class="hljs-keyword">true</span>;
                }
            }
            CHash256().Write(inner[level].begin(), <span class="hljs-number">32</span>).Write(h.begin(), <span class="hljs-number">32</span>).Finalize(h.begin());
            level++;
        }
    }
    <span class="hljs-comment">// Return result.</span>
    <span class="hljs-keyword">if</span> (pmutated) *pmutated = mutated;
    <span class="hljs-keyword">if</span> (proot) *proot = h;
}</code></pre> 
  <h3 id="2-数字签名算法-椭圆曲线算法">2. 数字签名算法 椭圆曲线算法</h3> 
  <h4 id="21-椭圆曲线算法和公私钥">2.1 椭圆曲线算法和公私钥</h4> 
  <p>日常工作中，我们每天登录服务器，对公私钥系统已经非常熟悉了，公私钥并不是新鲜的技术。我们可以用<code>ssh-keygen</code>命令生成一对公钥和私钥；当拥有私钥时，可以用<code>ssh-keygen -y -f</code>生成配对的公钥，但拥有公钥无法生成配对的私钥。这背后的原理就是椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm, 简写为ECDSA)。比特币利用椭圆曲线生成密钥对，其中公钥作为交易接收方的地址，对外传播。</p> 
  <p>在平面直角坐标系中，一条椭圆曲线的形状如下图。比特币的源码中，椭圆曲线定义在<code>src/secp256k1</code>目录。比特币选择的椭圆曲线方程为y<sup>2</sup> mod p = (x<sup>3</sup> + 7) mod p，其中p是一个非常大的质数，p = 2<sup>256</sup> - 2<sup>32</sup> - 2<sup>9</sup> - 2<sup>8</sup> - 2<sup>7</sup> - 2<sup>6</sup> - 2<sup>4</sup> - 1。 <br> <img src="http://static.zybuluo.com/renqHIT/dk1cjitngxwaxfqgybqgb6vt/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="椭圆曲线示意图.png-69.5kB" title=""></p> 
  <p>给定私钥k, 如何根据椭圆曲线生成公钥K呢？公式为<code>K = k * G</code>。其中，G 代表一种变换，从点k=(x,y)进行一次变换生成k<sub>1</sub>=(x<sub>1</sub>, y<sub>1</sub>)，先在点k出求正切线，正切线与椭圆曲线的交点… <br> 下图用几何形式展示了变换G。 <br> <img src="http://static.zybuluo.com/renqHIT/aikcftpqmlsek5bjvqq5t5xr/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF2.png" alt="椭圆曲线2.png-129.2kB" title=""></p> 
  <h4 id="22-sha-256">2.2 SHA-256</h4> 
  <p>哈希函数在比特币中用途极为广泛，包括：比特币地址，交易脚本地址，挖矿工作量证明。在比特币系统中，利用公钥生成比特币地址的算法是SHA256和 RIPEMD160。 <br> 由公钥生成比特币地址的总体过程如下图所示 <br> <img src="http://static.zybuluo.com/renqHIT/aiypemwfigo9zizw50gjuwjz/%E5%85%AC%E9%92%A5-%E6%AF%94%E7%89%B9%E5%B8%81%E5%9C%B0%E5%9D%80.png" alt="公钥-比特币地址.png-158.2kB" title=""> <br> 给定公钥K，先进行SHA256哈希，再对SHA256的结果进行RIPEMD160哈希，得到的值A就是比特币地址, 即<code>A = RIPEMD160(SHA256(K))</code>。A值进一步压缩, 我们就得到了比特币地址, 形如<code>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</code>。比特币选择的压缩算法是<strong>Base58Check</strong>。</p> 
  <p>SHA-256计算过程，如下图 <br> <img src="http://static.zybuluo.com/renqHIT/8s2es0z29y9u8wlp5ths54nu/sha-256-in-depth.png" alt="sha-256-in-depth.png-512.5kB" title=""></p> 
  <p>我们来看一下比特币源码中SHA256哈希的实现 <br> 哈希函数类定义如下, 主体是状态s，由8个32位无符号整数组成。缓冲buf用于批量读入和计算数据。</p> 
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">/** A hasher class for SHA-256. */</span>
<span class="hljs-keyword">class</span> CSHA256
{
<span class="hljs-keyword">private</span>:
    uint32_t s[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">64</span>];
    uint64_t bytes;

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> size_t OUTPUT_SIZE = <span class="hljs-number">32</span>;

    CSHA256();
    CSHA256&amp; Write(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* data, size_t len);
    <span class="hljs-keyword">void</span> Finalize(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> hash[OUTPUT_SIZE]);
    CSHA256&amp; Reset();
};</code></pre> 
  <p>SHA256的主体代码，数据data每64字节读入一次，写入buff，经过Transform处理，得到s值。</p> 
  <pre class="prettyprint"><code class="language-cpp hljs ">CSHA256&amp; CSHA256::Write(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* data, size_t len)
{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* end = data + len;
    size_t bufsize = bytes % <span class="hljs-number">64</span>;
    <span class="hljs-keyword">if</span> (bufsize &amp;&amp; bufsize + len &gt;= <span class="hljs-number">64</span>) {
        <span class="hljs-comment">// Fill the buffer, and process it.</span>
        <span class="hljs-built_in">memcpy</span>(buf + bufsize, data, <span class="hljs-number">64</span> - bufsize);
        bytes += <span class="hljs-number">64</span> - bufsize;
        data += <span class="hljs-number">64</span> - bufsize;
        Transform(s, buf, <span class="hljs-number">1</span>);
        bufsize = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span> (end - data &gt;= <span class="hljs-number">64</span>) {
        size_t blocks = (end - data) / <span class="hljs-number">64</span>;
        Transform(s, data, blocks);
        data += <span class="hljs-number">64</span> * blocks;
        bytes += <span class="hljs-number">64</span> * blocks;
    }
    <span class="hljs-keyword">if</span> (end &gt; data) {
        <span class="hljs-comment">// Fill the buffer with what remains.</span>
        <span class="hljs-built_in">memcpy</span>(buf + bufsize, data, end - data);
        bytes += end - data;
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}</code></pre> 
  <p>这里定义了一些基本运算，Ch, Maj, Sigma0, Sigma1, sigma0, sigma1，很直白，无需赘言。</p> 
  <pre class="prettyprint"><code class="language-cpp hljs ">uint32_t <span class="hljs-keyword">inline</span> Ch(uint32_t x, uint32_t y, uint32_t z) { <span class="hljs-keyword">return</span> z ^ (x &amp; (y ^ z)); }
uint32_t <span class="hljs-keyword">inline</span> Maj(uint32_t x, uint32_t y, uint32_t z) { <span class="hljs-keyword">return</span> (x &amp; y) | (z &amp; (x | y)); }
uint32_t <span class="hljs-keyword">inline</span> Sigma0(uint32_t x) { <span class="hljs-keyword">return</span> (x &gt;&gt; <span class="hljs-number">2</span> | x &lt;&lt; <span class="hljs-number">30</span>) ^ (x &gt;&gt; <span class="hljs-number">13</span> | x &lt;&lt; <span class="hljs-number">19</span>) ^ (x &gt;&gt; <span class="hljs-number">22</span> | x &lt;&lt; <span class="hljs-number">10</span>); }
uint32_t <span class="hljs-keyword">inline</span> Sigma1(uint32_t x) { <span class="hljs-keyword">return</span> (x &gt;&gt; <span class="hljs-number">6</span> | x &lt;&lt; <span class="hljs-number">26</span>) ^ (x &gt;&gt; <span class="hljs-number">11</span> | x &lt;&lt; <span class="hljs-number">21</span>) ^ (x &gt;&gt; <span class="hljs-number">25</span> | x &lt;&lt; <span class="hljs-number">7</span>); }
uint32_t <span class="hljs-keyword">inline</span> sigma0(uint32_t x) { <span class="hljs-keyword">return</span> (x &gt;&gt; <span class="hljs-number">7</span> | x &lt;&lt; <span class="hljs-number">25</span>) ^ (x &gt;&gt; <span class="hljs-number">18</span> | x &lt;&lt; <span class="hljs-number">14</span>) ^ (x &gt;&gt; <span class="hljs-number">3</span>); }
uint32_t <span class="hljs-keyword">inline</span> sigma1(uint32_t x) { <span class="hljs-keyword">return</span> (x &gt;&gt; <span class="hljs-number">17</span> | x &lt;&lt; <span class="hljs-number">15</span>) ^ (x &gt;&gt; <span class="hljs-number">19</span> | x &lt;&lt; <span class="hljs-number">13</span>) ^ (x &gt;&gt; <span class="hljs-number">10</span>); }</code></pre> 
  <p>初始化8个32位的无符号整数，作为初始状态。</p> 
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">/** Initialize SHA-256 state. */</span>
<span class="hljs-keyword">void</span> <span class="hljs-keyword">inline</span> Initialize(uint32_t* s)
{
    s[<span class="hljs-number">0</span>] = <span class="hljs-number">0x6a09e667</span>ul;
    s[<span class="hljs-number">1</span>] = <span class="hljs-number">0xbb67ae85</span>ul;
    s[<span class="hljs-number">2</span>] = <span class="hljs-number">0x3c6ef372</span>ul;
    s[<span class="hljs-number">3</span>] = <span class="hljs-number">0xa54ff53a</span>ul;
    s[<span class="hljs-number">4</span>] = <span class="hljs-number">0x510e527f</span>ul;
    s[<span class="hljs-number">5</span>] = <span class="hljs-number">0x9b05688c</span>ul;
    s[<span class="hljs-number">6</span>] = <span class="hljs-number">0x1f83d9ab</span>ul;
    s[<span class="hljs-number">7</span>] = <span class="hljs-number">0x5be0cd19</span>ul;
}</code></pre> 
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">/** One round of SHA-256. */</span>
<span class="hljs-keyword">void</span> <span class="hljs-keyword">inline</span> Round(uint32_t a, uint32_t b, uint32_t c, uint32_t&amp; d, uint32_t e, uint32_t f, uint32_t g, uint32_t&amp; h, uint32_t k, uint32_t w)
{
    uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w;
    uint32_t t2 = Sigma0(a) + Maj(a, b, c);
    d += t1;
    h = t1 + t2;
}</code></pre> 
  <p>每一轮SHA256计算过程如上所示，同样很直白，无需赘言。</p> 
  <p>下面的Transform函数比较有内容，函数输入一个64字节的chunk和状态s，每次从chunk读入4字节，根据当前状态s，做16次Round计算；完成后再做三轮16次Round；最后，8个无符号整数都加上上述64次Round的结果，更新状态s。经过上述计算，我们就得到了数据chunk的SHA256哈希值。</p> 
  <p>数据读写的代码，见<code>/src/crypto/common.h</code></p> 
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">/** Perform a number of SHA-256 transformations, processing 64-byte chunks. */</span>
<span class="hljs-keyword">void</span> Transform(uint32_t* s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* chunk, size_t blocks)
{
    <span class="hljs-keyword">while</span> (blocks--) {
        uint32_t a = s[<span class="hljs-number">0</span>], b = s[<span class="hljs-number">1</span>], c = s[<span class="hljs-number">2</span>], d = s[<span class="hljs-number">3</span>], e = s[<span class="hljs-number">4</span>], f = s[<span class="hljs-number">5</span>], g = s[<span class="hljs-number">6</span>], h = s[<span class="hljs-number">7</span>];
        uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;
        <span class="hljs-comment">// 步骤一：</span>
        Round(a, b, c, d, e, f, g, h, <span class="hljs-number">0x428a2f98</span>, w0 = ReadBE32(chunk + <span class="hljs-number">0</span>));
        Round(h, a, b, c, d, e, f, g, <span class="hljs-number">0x71374491</span>, w1 = ReadBE32(chunk + <span class="hljs-number">4</span>));
        <span class="hljs-comment">// 中间省略...</span>
        Round(c, d, e, f, g, h, a, b, <span class="hljs-number">0x9bdc06a7</span>, w14 = ReadBE32(chunk + <span class="hljs-number">56</span>));
        Round(b, c, d, e, f, g, h, a, <span class="hljs-number">0xc19bf174</span>, w15 = ReadBE32(chunk + <span class="hljs-number">60</span>));
        <span class="hljs-comment">// 步骤二：</span>
        Round(a, b, c, d, e, f, g, h, <span class="hljs-number">0xe49b69c1</span>, w0 += sigma1(w14) + w9 + sigma0(w1));
        Round(h, a, b, c, d, e, f, g, <span class="hljs-number">0xefbe4786</span>, w1 += sigma1(w15) + w10 + sigma0(w2));
        <span class="hljs-comment">// 中间省略</span>
        Round(c, d, e, f, g, h, a, b, <span class="hljs-number">0x06ca6351</span>, w14 += sigma1(w12) + w7 + sigma0(w15));
        Round(b, c, d, e, f, g, h, a, <span class="hljs-number">0x14292967</span>, w15 += sigma1(w13) + w8 + sigma0(w0));
        <span class="hljs-comment">// 步骤三：</span>
        Round(a, b, c, d, e, f, g, h, <span class="hljs-number">0x27b70a85</span>, w0 += sigma1(w14) + w9 + sigma0(w1));
        Round(h, a, b, c, d, e, f, g, <span class="hljs-number">0x2e1b2138</span>, w1 += sigma1(w15) + w10 + sigma0(w2));
        <span class="hljs-comment">// 中间省略</span>
        Round(c, d, e, f, g, h, a, b, <span class="hljs-number">0xf40e3585</span>, w14 += sigma1(w12) + w7 + sigma0(w15));
        Round(b, c, d, e, f, g, h, a, <span class="hljs-number">0x106aa070</span>, w15 += sigma1(w13) + w8 + sigma0(w0));
        <span class="hljs-comment">// 步骤四：</span>
        Round(a, b, c, d, e, f, g, h, <span class="hljs-number">0x19a4c116</span>, w0 += sigma1(w14) + w9 + sigma0(w1));
        Round(h, a, b, c, d, e, f, g, <span class="hljs-number">0x1e376c08</span>, w1 += sigma1(w15) + w10 + sigma0(w2));
        <span class="hljs-comment">// 中间省略</span>
        Round(c, d, e, f, g, h, a, b, <span class="hljs-number">0xbef9a3f7</span>, w14 + sigma1(w12) + w7 + sigma0(w15));
        Round(b, c, d, e, f, g, h, a, <span class="hljs-number">0xc67178f2</span>, w15 + sigma1(w13) + w8 + sigma0(w0));

        s[<span class="hljs-number">0</span>] += a;
        s[<span class="hljs-number">1</span>] += b;
        s[<span class="hljs-number">2</span>] += c;
        s[<span class="hljs-number">3</span>] += d;
        s[<span class="hljs-number">4</span>] += e;
        s[<span class="hljs-number">5</span>] += f;
        s[<span class="hljs-number">6</span>] += g;
        s[<span class="hljs-number">7</span>] += h;
        chunk += <span class="hljs-number">64</span>;
    }
}
</code></pre> 
  <p>以上就是SHA256哈希算法的实现；下一步，我们分析交易结构。</p> 
  <h2 id="二交易">二、交易</h2> 
  <p>一般的交易系统设计：账户，余额。比特币的交易系统, 不记录余额，记录交易内容。例如，一般的交易系统，记录Alice的余额为10 RMB，Bob的余额为5RMB，当Alice发起交易，给Bob支付5RMB时，支付系统后台检查Alice的余额，验证通过后，对Alice的余额减5RMB，再对Bob的余额加5RMB。 <br> 而区块链处理的思路是，不记录Alice和Bob的账户余额，记录历史上发生过的所有交易记录，以未消费交易输出（UTXO）形式分布式地保存在区块链上，区块链网络节点共同验证UTXO是否合法。 <br> 构建比特币交易的基础是<strong>交易输出</strong>, 交易输出是比特币货币系统中不可拆分的块（chunk），记录在区块链上，被比特币网络认证；比特币网络节点记录所有可获得且可消费的交易输出，称作<strong>未消费交易输出</strong>(unspent transaction outputs), 简写成<strong>UTXO</strong>。 <br> 区块链上的一笔交易，代表着一组UTXO集合状态转换到另外一组UTXO集合状态。当产生新的“比特币”时，UTXO集合大小增加。UTXO是比特币交易的基础。“账户余额”的概念由比特币钱包应用创造，钱包应用扫描区块链，得到钱包拥有者的私钥可以消费的UTXO的总和，即“账户余额”。大多数钱包应用维护了一个数据库，用于存储该钱包私钥可以消费的UTXO集合。</p> 
  <h3 id="21-交易格式">2.1 交易格式</h3> 
  <p>实际比特币的交易记录是二进制格式，转换成可读格式后，一笔交易的内容包含三个部分：元数据，输入，输出; 如下所示</p> 
  <pre class="prettyprint"><code class=" hljs json">{
    "<span class="hljs-attribute">version</span>": <span class="hljs-value"><span class="hljs-number">1</span></span>,
    "<span class="hljs-attribute">locktime</span>": <span class="hljs-value"><span class="hljs-number">0</span></span>,
    "<span class="hljs-attribute">vin</span>": <span class="hljs-value">[{ "<span class="hljs-attribute">txid</span>": <span class="hljs-value"><span class="hljs-string">"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18"</span></span>, "<span class="hljs-attribute">vout</span>": <span class="hljs-value"><span class="hljs-number">0</span></span>, "<span class="hljs-attribute">scriptSig</span>": <span class="hljs-value"><span class="hljs-string">"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf"</span></span>, "<span class="hljs-attribute">sequence</span>": <span class="hljs-value"><span class="hljs-number">4294967295</span> </span>}]</span>,
    "<span class="hljs-attribute">vout</span>": <span class="hljs-value">[{ "<span class="hljs-attribute">value</span>": <span class="hljs-value"><span class="hljs-number">0.01500000</span></span>, "<span class="hljs-attribute">scriptPubKey</span>": <span class="hljs-value"><span class="hljs-string">"OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG "</span> </span>}, { "<span class="hljs-attribute">value</span>": <span class="hljs-value"><span class="hljs-number">0.08450000</span></span>, "<span class="hljs-attribute">scriptPubKey</span>": <span class="hljs-value"><span class="hljs-string">"OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG"</span> </span>}] </span>}</code></pre> 
  <p>值得注意的是，每个输入包含了一项scirptSig, 上例中是<code>3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf</code>, 每个输出的元素都包含了一项scriptPubKey, 上例中是<code>ab68025513c3dbd2f7b92a94e0581f5d50f654e7</code>, 这个值代表了交易脚本的哈希值。(稍后详细描述)</p> 
  <p>比特币交易结构，见<code>primitives/transaction.h</code></p> 
  <pre class="prettyprint"><code class=" hljs ruby">/**
 * <span class="hljs-constant">Basic</span> transaction serialization <span class="hljs-symbol">format:</span>
 * - int32_t nVersion
 * - <span class="hljs-symbol">std:</span><span class="hljs-symbol">:vector&lt;CTxIn&gt;</span> vin
 * - <span class="hljs-symbol">std:</span><span class="hljs-symbol">:vector&lt;CTxOut&gt;</span> vout
 * - uint32_t nLockTime
 *
 * <span class="hljs-constant">Extended</span> transaction serialization <span class="hljs-symbol">format:</span>
 * - int32_t nVersion
 * - unsigned char dummy = <span class="hljs-number">0x00</span>
 * - unsigned char flags (!= <span class="hljs-number">0</span>)
 * - <span class="hljs-symbol">std:</span><span class="hljs-symbol">:vector&lt;CTxIn&gt;</span> vin
 * - <span class="hljs-symbol">std:</span><span class="hljs-symbol">:vector&lt;CTxOut&gt;</span> vout
 * - <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-number">1</span>)<span class="hljs-symbol">:</span>
 *   - <span class="hljs-constant">CTxWitness</span> wit;
 * - uint32_t nLockTime
 *<span class="hljs-regexp">/</span></code></pre> 
  <p>可以看到，基本交易序列化格式的信息包括：版本号，输入列表，输出列表，锁定时间；此外，扩展的交易序列化格式还包括扩容方案<strong>隔离见证</strong>的一些信息。关于比特币扩容和隔离见证此处不展开讨论，准备单独写一篇笔记。对比特币扩容方案感兴趣的读者，建议阅读BIP-141, BIP-143和BIP-147。</p> 
  <p>交易输入定义，见<code>src/primitives/transaction.h</code></p> 
  <pre class="prettyprint"><code class=" hljs coffeescript">/** An input <span class="hljs-keyword">of</span> a transaction.  It contains the location <span class="hljs-keyword">of</span> the previous
 * transaction<span class="hljs-string">'s output that it claims and a signature that matches the * output'</span>s public key.
 */
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTxIn</span></span>
{
<span class="hljs-attribute">public</span>:
    COutPoint prevout;
    CScript scriptSig;
    uint32_t nSequence;
    CScriptWitness scriptWitness; <span class="hljs-regexp">//</span>! Only serialized through CTransaction

    /* Setting nSequence to <span class="hljs-keyword">this</span> value <span class="hljs-keyword">for</span> every input <span class="hljs-keyword">in</span> a transaction
     * disables nLockTime. */
    static <span class="hljs-reserved">const</span> uint32_t SEQUENCE_FINAL = <span class="hljs-number">0xffffffff</span>;

    <span class="hljs-regexp">/* Below flags apply in the context of BIP 68*/</span>
    /* If <span class="hljs-keyword">this</span> flag set, <span class="hljs-attribute">CTxIn</span>::nSequence <span class="hljs-keyword">is</span> NOT interpreted as a
     * relative lock-time. */
    static <span class="hljs-reserved">const</span> uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>);

    /* If <span class="hljs-attribute">CTxIn</span>::nSequence encodes a relative lock-time <span class="hljs-keyword">and</span> <span class="hljs-keyword">this</span> flag
     * <span class="hljs-keyword">is</span> set, the relative lock-time has units <span class="hljs-keyword">of</span> <span class="hljs-number">512</span> seconds,
     * otherwise it specifies blocks <span class="hljs-reserved">with</span> a granularity <span class="hljs-keyword">of</span> <span class="hljs-number">1.</span> */
    static <span class="hljs-reserved">const</span> uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">22</span>);

    /* If <span class="hljs-attribute">CTxIn</span>::nSequence encodes a relative lock-time, <span class="hljs-keyword">this</span> mask <span class="hljs-keyword">is</span>
     * applied to extract that lock-time from the sequence field. */
    static <span class="hljs-reserved">const</span> uint32_t SEQUENCE_LOCKTIME_MASK = <span class="hljs-number">0x0000ffff</span>;

    /* In order to use the same number <span class="hljs-keyword">of</span> bits to encode roughly the
     * same wall-clock duration, <span class="hljs-keyword">and</span> because blocks are naturally
     * limited to occur every <span class="hljs-number">600</span>s <span class="hljs-literal">on</span> average, the minimum granularity
     * <span class="hljs-keyword">for</span> time-based relative lock-time <span class="hljs-keyword">is</span> fixed at <span class="hljs-number">512</span> seconds.
     * Converting from <span class="hljs-attribute">CTxIn</span>::nSequence to seconds <span class="hljs-keyword">is</span> performed <span class="hljs-keyword">by</span>
     * multiplying <span class="hljs-keyword">by</span> <span class="hljs-number">512</span> = <span class="hljs-number">2</span>^<span class="hljs-number">9</span>, <span class="hljs-keyword">or</span> equivalently shifting up <span class="hljs-keyword">by</span>
     * <span class="hljs-number">9</span> bits. */
    static <span class="hljs-reserved">const</span> int SEQUENCE_LOCKTIME_GRANULARITY = <span class="hljs-number">9</span>;

    CTxIn()
    {
        nSequence = SEQUENCE_FINAL;
    }

    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);
    CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);

    ADD_SERIALIZE_METHODS;

    template &lt;typename Stream, typename Operation&gt;
    inline <span class="hljs-reserved">void</span> SerializationOp(Stream&amp; s, Operation ser_action) {
        READWRITE(prevout);
        READWRITE(scriptSig);
        READWRITE(nSequence);
    }

    friend bool operator==(<span class="hljs-reserved">const</span> CTxIn&amp; a, <span class="hljs-reserved">const</span> CTxIn&amp; b)
    {
        <span class="hljs-keyword">return</span> (a.prevout   == b.prevout &amp;&amp;
                a.scriptSig == b.scriptSig &amp;&amp;
                a.nSequence == b.nSequence);
    }

    friend bool operator!=(<span class="hljs-reserved">const</span> CTxIn&amp; a, <span class="hljs-reserved">const</span> CTxIn&amp; b)
    {
        <span class="hljs-keyword">return</span> !(a == b);
    }

    <span class="hljs-attribute">std</span>::string ToString() <span class="hljs-reserved">const</span>;
};</code></pre> 
  <p>交易输出定义，见<code>src/primitives/transaction.h</code></p> 
  <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">/** An output of a transaction. It contains the public key that the next input * must be able to sign with to claim it. */</span>
<span class="hljs-keyword">class</span> CTxOut
{
<span class="hljs-keyword">public</span>:
    CAmount nValue;
    CScript scriptPubKey;

    CTxOut()
    {
        SetNull();
    }

    CTxOut(<span class="hljs-keyword">const</span> CAmount&amp; nValueIn, CScript scriptPubKeyIn);

    ADD_SERIALIZE_METHODS;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Stream, <span class="hljs-keyword">typename</span> Operation&gt;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> SerializationOp(Stream&amp; s, Operation ser_action) {
        READWRITE(nValue);
        READWRITE(scriptPubKey);
    }

    <span class="hljs-keyword">void</span> SetNull()
    {
        nValue = -<span class="hljs-number">1</span>;
        scriptPubKey.clear();
    }

    <span class="hljs-keyword">bool</span> IsNull() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> (nValue == -<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> CTxOut&amp; a, <span class="hljs-keyword">const</span> CTxOut&amp; b)
    {
        <span class="hljs-keyword">return</span> (a.nValue       == b.nValue &amp;&amp;
                a.scriptPubKey == b.scriptPubKey);
    }

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> CTxOut&amp; a, <span class="hljs-keyword">const</span> CTxOut&amp; b)
    {
        <span class="hljs-keyword">return</span> !(a == b);
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ToString() <span class="hljs-keyword">const</span>;
};
</code></pre> 
  <h3 id="22-交易脚本">2.2 交易脚本</h3> 
  <p>比特币脚本语言是专为比特币而设计的简化版本的程序语言。比特币脚本语言有意设计成<strong>非图灵完备语言</strong>，计算表达能力受到了一定的限制。最主要的有三点：1.数据存储在栈中，不支持定义变量；2. 限制比特币脚本的可用内存和执行时间；3. 比特币脚本中不支持循环，避免死循环导致浪费比特币矿工计算资源。 <br> 比特币脚本指令集合，总共有256个操作，其中15个禁用，75个保留。主要的操作为：1. 算数操作，如加减法 2. 分支判断 if/then 3. 逻辑和数据处理 与或非，抛出异常和捕获异常，提前返回等 4. 加密算法，包括哈希函数，签名认证，多重签名认证等。 值得注意的是，比特币脚本语言具有强大的加密算法库，支持在一条操作中对多重签名进行验证，即OP_CHECKMULTISIG操作。多重签名意味着，指定n个公钥，指定一个阈值参数t，表示如果操作想要正常执行，至少匹配n个公钥中的的t个签名。</p> 
  <h3 id="23-未消费交易输出-utxo">2.3 未消费交易输出, UTXO</h3> 
  <p>终于到了“币”的环节, “币”在比特币的源码世界里，定义如下，见<code>src/coins.h</code></p> 
  <pre class="prettyprint"><code class=" hljs d"><span class="hljs-comment">/** * A UTXO entry. * * Serialized format: * - VARINT((coinbase ? 1 : 0) | (height &lt;&lt; 1)) * - the non-spent CTxOut (via CTxOutCompressor) */</span>
<span class="hljs-keyword">class</span> Coin
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//! unspent transaction output</span>
    CTxOut <span class="hljs-keyword">out</span>;

    <span class="hljs-comment">//! whether containing transaction was a coinbase</span>
    unsigned <span class="hljs-keyword">int</span> fCoinBase : <span class="hljs-number">1</span>;

    <span class="hljs-comment">//! at which height this containing transaction was included in the active block chain</span>
    uint32_t nHeight : <span class="hljs-number">31</span>;

    <span class="hljs-comment">//! construct a Coin from a CTxOut and height/coinbase information.</span>
    Coin(CTxOut&amp;&amp; outIn, <span class="hljs-keyword">int</span> nHeightIn, <span class="hljs-built_in">bool</span> fCoinBaseIn) : <span class="hljs-keyword">out</span>(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {}
    Coin(<span class="hljs-keyword">const</span> CTxOut&amp; outIn, <span class="hljs-keyword">int</span> nHeightIn, <span class="hljs-built_in">bool</span> fCoinBaseIn) : <span class="hljs-keyword">out</span>(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {}

    <span class="hljs-keyword">void</span> Clear() {
        <span class="hljs-keyword">out</span>.SetNull();
        fCoinBase = <span class="hljs-literal">false</span>;
        nHeight = <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">//! empty constructor</span>
    Coin() : fCoinBase(<span class="hljs-literal">false</span>), nHeight(<span class="hljs-number">0</span>) { }

    <span class="hljs-built_in">bool</span> IsCoinBase() <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> fCoinBase;
    }

    <span class="hljs-keyword">template</span>&lt;typename Stream&gt;
    <span class="hljs-keyword">void</span> Serialize(Stream &amp;s) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">assert</span>(!IsSpent());
        uint32_t code = nHeight * <span class="hljs-number">2</span> + fCoinBase;
        ::Serialize(s, VARINT(code));
        ::Serialize(s, CTxOutCompressor(REF(<span class="hljs-keyword">out</span>)));
    }

    <span class="hljs-keyword">template</span>&lt;typename Stream&gt;
    <span class="hljs-keyword">void</span> Unserialize(Stream &amp;s) {
        uint32_t code = <span class="hljs-number">0</span>;
        ::Unserialize(s, VARINT(code));
        nHeight = code &gt;&gt; <span class="hljs-number">1</span>;
        fCoinBase = code &amp; <span class="hljs-number">1</span>;
        ::Unserialize(s, REF(CTxOutCompressor(<span class="hljs-keyword">out</span>)));
    }

    <span class="hljs-built_in">bool</span> IsSpent() <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">out</span>.IsNull();
    }

    size_t DynamicMemoryUsage() <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> memusage::DynamicUsage(<span class="hljs-keyword">out</span>.scriptPubKey);
    }
};</code></pre> 
  <h2 id="参考资料">参考资料</h2> 
  <ul> 
   <li>普林斯顿大学公开课 Coursera</li> 
   <li>Mastering Bitcoin</li> 
  </ul> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/renq_654321/article/details/79456190,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/renq_654321/article/details/79456190,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
