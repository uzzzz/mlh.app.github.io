<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Node.js接入支付宝（蚂蚁金服）支付 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Node.js接入支付宝（蚂蚁金服）支付" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="最近项目（Android和Ios）中需要接入付费功能（支付宝和微信），下面就先来介绍下接入支付宝的流程。文章主要分为三大块： 第一块是如何在蚂蚁金服的开放平台创建一个应用并且配置开发选项。 第二块是node端接入支付功能生成前端支付需要的参数（私钥签名）。 第三块是node端对支付结果异步通知的验签（公钥验签）。 蚂蚁金服开放平台创建一个应用 一、登陆：进入开放平台登录账号后，进入开发者中心-网页&amp;移动应用栏目，点击创建应用中的支付接入 二、创建应用：使用场景选择“自用型应用”，并且给你的应用取一个响亮的名字（应用名称和应用图标会在授权、分享的场景中露出） 三、创建完成：这时候在我的应用里面可以看到我们刚刚创建的应用了，这时候点击“查看”按钮开始配置应用 四、添加功能：进入之后需要添加我们需要的功能选项（手机网站支付、app支付、授权等），很多功能是需要签约的，按照签约的提示填写即可。添加完毕后就可以开始开发配置了 五、开发配置：开发配置分为3步，第1步设置应用公钥，第2步设置应用公关，第3步设置授权回调地址，接下来详细介绍 第1步：生成应用公钥我们需要先下载一个软件（ https://docs.open.alipay.com/291/106097），通过这个软件我们可以生成公钥。因为我们用的开发语言是nodejs， 所以在生成公钥的时候注意选择的类型（密钥格式选择PKCS1(非JAVA适用)）。生成完之后，将生成的商户应用公钥填入开放平台中即可。 设置完应用公钥之后不要着急关闭我们生成签名的软件，我们需要将公钥和私钥（签名使用）保存到文件中，之后的代码中需要调用。 填写完成后，我们应该可以看到下面的界面。我们可以查看、修改之前的应用公钥， 并且此时注意，在“查看应用公钥”的旁边出现了另外一个按钮“查看支付宝公钥”，这个非常重要，很多新手把支付宝公钥和应用公钥搞混淆了，正常情况下我们代码中只需要用到两种密钥， 一个是应用私钥（用于生成app或网页端支付需要的签名参数）还有个是支付宝公钥（用于对支付宝异步通知结果进行验签的） ，到了之后的代码解析模块会详细讲解。 第2步：设置应用网关，这个地址也是很重要的，我们之后的支付结果支付宝都会通过异步的post请求这个到该地址上（用户付钱有没有成功就是依据他啦）。具体的请求参数参考：https://docs.open.alipay.com/204/105301/ 第3步：设置授权回调地址，第三方授权或用户信息授权后回调地址。授权链接中配置的redirect_uri的值必须与此值保持一致。当填入该地址时，系统会自动进行安全检测。授权回调地址很多同学可能用不上，详细的使用请参考： https://docs.open.alipay.com/316/106274 6.提交审核：填写完上述信息就可以提交审核了，经过我们几次开发，发现支付宝审核非常快，白天几十分钟就会审核完毕了，在这个过程中我们也不要等着了，可以开始coding咯。 Node.js实现支付参数的生成 下面就以app支付为例子进行分析： app端发起一个支付请求，需要一个参数（orderInfo），这个参数是从后台生成，如果我们后台（node）能够生成一个正确的参数，app端就可以成功的唤起支付宝，并且完成支付。 后台具体需要拼接哪些参数，请参考https://docs.open.alipay.com/204/105465/，文档中标记必填的参数我们也必须要填写。 看过请求参数的文档之后我们就可以正式开始组成app端需要的参数了，我们按照文档中的步骤进行构建参数，总共分为三步： 第一步：把所有必填的参数以及我们自己业务需要的参数组成key-value对象。 第二步：在第一步中有一个参数是最复杂，也是支付宝用来校验请求的合法性。就是sign（签名）这个参数，我们无法直接填写，需要通过应用的私钥去签名得到，我们第二步就是为了生成这个参数。 第三步：对我们参数中所有的value进行编码（encodeURIComponent），并且将参数转换成字符串返回给客户端即可； 第一步：生成基础参数 let params = new Map(); params.set(&#39;app_id&#39;, this.accountSettings.APP_ID); params.set(&#39;method&#39;, &#39;alipay.trade.app.pay&#39;); params.set(&#39;charset&#39;, &#39;utf-8&#39;); params.set(&#39;sign_type&#39;, &#39;RSA2&#39;); params.set(&#39;timestamp&#39;, moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;)); params.set(&#39;version&#39;, &#39;1.0&#39;); params.set(&#39;notify_url&#39;, this.accountSettings.APP_GATEWAY_URL); params.set(&#39;biz_content&#39;, this._buildBizContent(&#39;商品名称xxxx&#39;, &#39;商户订单号xxxxx&#39;, &#39;商品金额8.88&#39;)); _buildBizContent()这个方法是用来生成参数biz_content的，这个参数用来传递一些附加参数，具体参数请参考文档中的业务参数 /** * 生成业务请求参数的集合 * @param subject 商品的标题/交易标题/订单标题/订单关键字等。 * @param outTradeNo 商户网站唯一订单号 * @param totalAmount 订单总金额，单位为元，精确到小数点后两位，取值范围[0.01,100000000] * @returns {string} json字符串 * @private */ _buildBizContent(subject, outTradeNo, totalAmount) { let bizContent = { subject: subject, out_trade_no: outTradeNo, total_amount: totalAmount, product_code: &#39;QUICK_MSECURITY_PAY&#39;, }; return JSON.stringify(bizContent); } 第二步：生成签名 通过第一步，我们已经生成了基础参数存放在了params对象中，但是params中还缺少非常核心的一个参数就是“sign”下面我们就来说说如何生成sign，这次先看代码吧！（生成签名的官方文档在此） /** * 根据参数构建签名 * @param paramsMap Map对象 * @returns {number|PromiseLike&lt;ArrayBuffer&gt;} * @private */ _buildSign(paramsMap) { //1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数 let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join(&#39;&amp;&#39;); let privateKey = fs.readFileSync(this.accountSettings.APP_PRIVATE_KEY_PATH, &#39;utf8&#39;); let signType = paramsMap.get(&#39;sign_type&#39;); return this._signWithPrivateKey(signType, paramsString, privateKey); } /** * 通过私钥给字符串签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param content 需要加密的字符串 * @param privateKey 私钥 * @returns {number | PromiseLike&lt;ArrayBuffer&gt;} * @private */ _signWithPrivateKey(signType, content, privateKey) { let sign; if (signType.toUpperCase() === &#39;RSA2&#39;) { sign = crypto.createSign(&quot;RSA-SHA256&quot;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { sign = crypto.createSign(&quot;RSA-SHA1&quot;); } else { throw new Error(&#39;请传入正确的签名方式，signType：&#39; + signType); } sign.update(content); return sign.sign(privateKey, &#39;base64&#39;); } 当我们调用_buildSign()方法的时候，需要传入一个参数，就是我们第一步构建出来的params，函数返回的就是我们需要的sign参数，下面来看看它具体做了什么。 1.筛选字段：获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数。 //1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数 let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; v1); 2.根据key的ascii排序：按照第一个字符的键值ASCII码递增排序（字母升序排序），如果遇到相同字符则按照第二个字符的键值ASCII码递增排序，以此类推。 //2.按照字符的键值ASCII码递增排序 paramsList.sort(); 3.拼接字符串：将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来，此时生成的字符串为待签名字符串。 //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join(&#39;&amp;&#39;); 4.需要把上一步获取到的待签名字符串进行签名，签名分为两种，根据传递给支付宝的参数sign_type来判断（商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2），此时还需要把我们的应用私钥给取出来，用来签名。应用的私钥就是我们在一开始配置应用的时候，在生成应用公钥的时候与之对应的私钥。 需要注意的是我们将私钥存储在文件中的时候，需要在第一行和最后一行分别加上一行，否则会报错 5.接下来调用_signWithPrivateKey方法即可获取到我们的sign参数的内容了 第三步：对所有的参数的value进行编码，并获得最终字符串 params.set(&#39;sign&#39;, this._buildSign(params)); return [...params].map(([k, v]) =&gt; `${k}=${encodeURIComponent(v)}`).join(&#39;&amp;&#39;); 将我们上一步获取到的签名也设置到sign中，然后将所有的value进行encode，最终用“=“和“&amp;“拼接成字符串返回给前端，到这里我们就完成了所有的步骤:) Node.js实现服务器对支付结果异步通知的验签 对于App支付产生的交易，支付宝会根据原始支付API中传入的异步通知地址notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统。异步通知的详细参数列表请参考：https://docs.open.alipay.com/204/105301/。 接受异步通知这一步非常的重要，用户是否真正的支付成功绝大部分是依赖于这个请求，我们不可能根据客户端返回的支付结果来判断，也不可能每一笔账都去蚂蚁金服的后台去对账。所以一定要处理好支付宝给我们发的请求，一定要对收到参数进行验证签名，保证这个请求确实是支付宝给我们发送的，而不是某人捏造的请求，处理不好会造成很大的损失。 小提示：但我们收到请求并且处理完成后必须打印输出“success”（不包含引号）。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）。 下面是接受请求的路由的处理代码： handler.aliGateway = function (req, res, next) { let notifyTime = req.body.notify_time;//通知时间:通知的发送时间。格式为yyyy-MM-dd HH:mm:ss let notifyType = req.body.notify_type;//通知类型:通知的类型 let notifyId = req.body.notify_id;//通知校验ID:通知校验ID let appId = req.body.app_id;//支付宝分配给开发者的应用Id:支付宝分配给开发者的应用Id let charset = req.body.charset;//编码格式:编码格式，如utf-8、gbk、gb2312等 let version = req.body.version;//接口版本:调用的接口版本，固定为：1.0 let signType = req.body.sign_type;//签名类型:商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2 let sign = req.body.sign;//签名:请参考&lt;a href=&quot;#yanqian&quot; class=&quot;bi-link&quot;&gt;异步返回结果的验签&lt;/a&gt; let tradeNo = req.body.trade_no;//支付宝交易号:支付宝交易凭证号 let outTradeNo = req.body.out_trade_no;//商户订单号:原支付请求的商户订单号 let outBizNo = req.body.out_biz_no;//商户业务号:商户业务ID，主要是退款通知中返回退款申请的流水号 let buyerId = req.body.buyer_id;//买家支付宝用户号:买家支付宝账号对应的支付宝唯一用户号。以2088开头的纯16位数字 let buyerLogonId = req.body.buyer_logon_id;//买家支付宝账号:买家支付宝账号 let sellerId = req.body.seller_id;//卖家支付宝用户号:卖家支付宝用户号 let sellerEmail = req.body.seller_email;//卖家支付宝账号:卖家支付宝账号 let tradeStatus = req.body.trade_status;//交易状态:交易目前所处的状态，见&lt;a href=&quot;#jiaoyi&quot; class=&quot;bi-link&quot;&gt;交易状态说明&lt;/a&gt; let totalAmount = req.body.total_amount;//订单金额:本次交易支付的订单金额，单位为人民币（元） let receiptAmount = req.body.receipt_amount;//实收金额:商家在交易中实际收到的款项，单位为元 let invoiceAmount = req.body.invoice_amount;//开票金额:用户在交易中支付的可开发票的金额 let buyerPayAmount = req.body.buyer_pay_amount;//付款金额:用户在交易中支付的金额 let pointAmount = req.body.point_amount;//集分宝金额:使用集分宝支付的金额 let refundFee = req.body.refund_fee;//总退款金额:退款通知中，返回总退款金额，单位为元，支持两位小数 let subject = req.body.subject;//订单标题:商品的标题/交易标题/订单标题/订单关键字等，是请求时对应的参数，原样通知回来 let body = req.body.body;//商品描述:该订单的备注、描述、明细等。对应请求时的body参数，原样通知回来 let gmtCreate = req.body.gmt_create;//交易创建时间:该笔交易创建的时间。格式为yyyy-MM-dd HH:mm:ss let gmtPayment = req.body.gmt_payment;//交易付款时间:该笔交易的买家付款时间。格式为yyyy-MM-dd HH:mm:ss let gmtRefund = req.body.gmt_refund;//交易退款时间:该笔交易的退款时间。格式为yyyy-MM-dd HH:mm:ss.S let gmtClose = req.body.gmt_close;//交易结束时间:该笔交易结束时间。格式为yyyy-MM-dd HH:mm:ss let fundBillList = req.body.fund_bill_list;//支付金额信息:支付成功的各个渠道金额信息，详见&lt;a href=&quot;#zijin&quot; class=&quot;bi-link&quot;&gt;资金明细信息说明&lt;/a&gt; let passbackParams = req.body.passback_params;//回传参数:公共回传参数，如果请求时传递了该参数，则返回给商户时会在异步通知时将该参数原样返回。本参数必须进行UrlEncode之后才可以发送给支付宝 let voucherDetailList = req.body.voucher_detail_list;//优惠券信息:本交易支付时所使用的所有优惠券信息，详见&lt;a href=&quot;#youhui&quot; class=&quot;bi-link&quot;&gt;优惠券信息说明&lt;/a&gt; let payHelper = new AliPayHelper(DefineProto.AliAccountType.AAT_REMIND); let isSuccess = payHelper.verifySign(req.body); if (isSuccess) { if (tradeStatus === &#39;TRADE_FINISHED&#39;) {//交易状态TRADE_FINISHED的通知触发条件是商户签约的产品不支持退款功能的前提下，买家付款成功；或者，商户签约的产品支持退款功能的前提下，交易已经成功并且已经超过可退款期限。 } else if (tradeStatus === &#39;TRADE_SUCCESS&#39;) {//状态TRADE_SUCCESS的通知触发条件是商户签约的产品支持退款功能的前提下，买家付款成功 } else if (tradeStatus === &#39;WAIT_BUYER_PAY&#39;) { } else if (tradeStatus === &#39;TRADE_CLOSED&#39;) { } res.send(&#39;success&#39;); } else { res.send(&#39;fail&#39;); } }; 可以看到上面验签的核心代码就是payHelper.verifySign(req.body)，我们来具体看看支付是要求我们如何验签的，参考文档：https://docs.open.alipay.com/204/105301/ 很多操作都和签名的时候类似，唯一需要注意的是：验签的时候用的是支付宝的公钥而不是应用的公钥 需要注意的是我们将公钥存储在文件中的时候，需要在第一行和最后一行分别加上一行，否则会报错 贴上具体的验签代码： /** * 验证支付宝异步通知的合法性 * @param params 支付宝异步通知结果的参数 * @returns {*} */ verifySign(params) { try { let sign = params[&#39;sign&#39;];//签名 let signType = params[&#39;sign_type&#39;];//签名类型 let paramsMap = new Map(); for (let key in params) { paramsMap.set(key, params[key]); } let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; k1 !== &#39;sign_type&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${decodeURIComponent(v)}`).join(&#39;&amp;&#39;); let publicKey = fs.readFileSync(this.accountSettings.ALI_PUBLIC_KEY_PATH, &#39;utf8&#39;); return this._verifyWithPublicKey(signType, sign, paramsString, publicKey); } catch (e) { console.error(e); return false; } } /** * 验证签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param sign 返回参数的签名 * @param content 参数组成的待验签串 * @param publicKey 支付宝公钥 * @returns {*} 是否验证成功 * @private */ _verifyWithPublicKey(signType, sign, content, publicKey) { try { let verify; if (signType.toUpperCase() === &#39;RSA2&#39;) { verify = crypto.createVerify(&#39;RSA-SHA256&#39;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { verify = crypto.createVerify(&#39;RSA-SHA1&#39;); } else { throw new Error(&#39;未知signType：&#39; + signType); } verify.update(content); return verify.verify(publicKey, sign, &#39;base64&#39;) } catch (err) { console.error(err); return false; } } 到这里我们的三大块已经介绍完成啦，贴上完整的代码： const path = require(&#39;path&#39;); const fs = require(&#39;fs&#39;); const moment = require(&#39;moment&#39;); const crypto = require(&#39;crypto&#39;); let ALI_PAY_SETTINGS = { APP_ID: &#39;2016091100487933&#39;, APP_GATEWAY_URL: &#39;xxxxxxx&#39;,//用于接收支付宝异步通知 AUTH_REDIRECT_URL: &#39;xxxxxxx&#39;,//第三方授权或用户信息授权后回调地址。授权链接中配置的redirect_uri的值必须与此值保持一致。 APP_PRIVATE_KEY_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;app-private.pem&#39;),//应用私钥 APP_PUBLIC_KEY_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;app-public.pem&#39;),//应用公钥 ALI_PUBLIC_KEY_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;ali-public.pem&#39;),//阿里公钥 AES_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;aes.txt&#39;),//aes加密（暂未使用） }; class AliPayHelper { /** * 构造方法 * @param accountType 用于以后区分多支付账号 */ constructor(accountType) { this.accountType = accountType; this.accountSettings = ALI_PAY_SETTINGS; } /** * 构建app支付需要的参数 * @param subject 商品名称 * @param outTradeNo 自己公司的订单号 * @param totalAmount 金额 * @returns {string} */ buildParams(subject, outTradeNo, totalAmount) { let params = new Map(); params.set(&#39;app_id&#39;, this.accountSettings.APP_ID); params.set(&#39;method&#39;, &#39;alipay.trade.app.pay&#39;); params.set(&#39;charset&#39;, &#39;utf-8&#39;); params.set(&#39;sign_type&#39;, &#39;RSA2&#39;); params.set(&#39;timestamp&#39;, moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;)); params.set(&#39;version&#39;, &#39;1.0&#39;); params.set(&#39;notify_url&#39;, this.accountSettings.APP_GATEWAY_URL); params.set(&#39;biz_content&#39;, this._buildBizContent(subject, outTradeNo, totalAmount)); params.set(&#39;sign&#39;, this._buildSign(params)); return [...params].map(([k, v]) =&gt; `${k}=${encodeURIComponent(v)}`).join(&#39;&amp;&#39;); } /** * 根据参数构建签名 * @param paramsMap Map对象 * @returns {number|PromiseLike&lt;ArrayBuffer&gt;} * @private */ _buildSign(paramsMap) { //1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数 let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join(&#39;&amp;&#39;); let privateKey = fs.readFileSync(this.accountSettings.APP_PRIVATE_KEY_PATH, &#39;utf8&#39;); let signType = paramsMap.get(&#39;sign_type&#39;); return this._signWithPrivateKey(signType, paramsString, privateKey); } /** * 通过私钥给字符串签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param content 需要加密的字符串 * @param privateKey 私钥 * @returns {number | PromiseLike&lt;ArrayBuffer&gt;} * @private */ _signWithPrivateKey(signType, content, privateKey) { let sign; if (signType.toUpperCase() === &#39;RSA2&#39;) { sign = crypto.createSign(&quot;RSA-SHA256&quot;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { sign = crypto.createSign(&quot;RSA-SHA1&quot;); } else { throw new Error(&#39;请传入正确的签名方式，signType：&#39; + signType); } sign.update(content); return sign.sign(privateKey, &#39;base64&#39;); } /** * 生成业务请求参数的集合 * @param subject 商品的标题/交易标题/订单标题/订单关键字等。 * @param outTradeNo 商户网站唯一订单号 * @param totalAmount 订单总金额，单位为元，精确到小数点后两位，取值范围[0.01,100000000] * @returns {string} json字符串 * @private */ _buildBizContent(subject, outTradeNo, totalAmount) { let bizContent = { subject: subject, out_trade_no: outTradeNo, total_amount: totalAmount, product_code: &#39;QUICK_MSECURITY_PAY&#39;, }; return JSON.stringify(bizContent); } /** * 验证支付宝异步通知的合法性 * @param params 支付宝异步通知结果的参数 * @returns {*} */ verifySign(params) { try { let sign = params[&#39;sign&#39;];//签名 let signType = params[&#39;sign_type&#39;];//签名类型 let paramsMap = new Map(); for (let key in params) { paramsMap.set(key, params[key]); } let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; k1 !== &#39;sign_type&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${decodeURIComponent(v)}`).join(&#39;&amp;&#39;); let publicKey = fs.readFileSync(this.accountSettings.ALI_PUBLIC_KEY_PATH, &#39;utf8&#39;); return this._verifyWithPublicKey(signType, sign, paramsString, publicKey); } catch (e) { console.error(e); return false; } } /** * 验证签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param sign 返回参数的签名 * @param content 参数组成的待验签串 * @param publicKey 支付宝公钥 * @returns {*} 是否验证成功 * @private */ _verifyWithPublicKey(signType, sign, content, publicKey) { try { let verify; if (signType.toUpperCase() === &#39;RSA2&#39;) { verify = crypto.createVerify(&#39;RSA-SHA256&#39;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { verify = crypto.createVerify(&#39;RSA-SHA1&#39;); } else { throw new Error(&#39;未知signType：&#39; + signType); } verify.update(content); return verify.verify(publicKey, sign, &#39;base64&#39;) } catch (err) { console.error(err); return false; } } } module.exports = AliPayHelper;如果有写的不对的地方麻烦在评论中指出，如果有疑问也欢迎提问哦~ 阅读更多" />
<meta property="og:description" content="最近项目（Android和Ios）中需要接入付费功能（支付宝和微信），下面就先来介绍下接入支付宝的流程。文章主要分为三大块： 第一块是如何在蚂蚁金服的开放平台创建一个应用并且配置开发选项。 第二块是node端接入支付功能生成前端支付需要的参数（私钥签名）。 第三块是node端对支付结果异步通知的验签（公钥验签）。 蚂蚁金服开放平台创建一个应用 一、登陆：进入开放平台登录账号后，进入开发者中心-网页&amp;移动应用栏目，点击创建应用中的支付接入 二、创建应用：使用场景选择“自用型应用”，并且给你的应用取一个响亮的名字（应用名称和应用图标会在授权、分享的场景中露出） 三、创建完成：这时候在我的应用里面可以看到我们刚刚创建的应用了，这时候点击“查看”按钮开始配置应用 四、添加功能：进入之后需要添加我们需要的功能选项（手机网站支付、app支付、授权等），很多功能是需要签约的，按照签约的提示填写即可。添加完毕后就可以开始开发配置了 五、开发配置：开发配置分为3步，第1步设置应用公钥，第2步设置应用公关，第3步设置授权回调地址，接下来详细介绍 第1步：生成应用公钥我们需要先下载一个软件（ https://docs.open.alipay.com/291/106097），通过这个软件我们可以生成公钥。因为我们用的开发语言是nodejs， 所以在生成公钥的时候注意选择的类型（密钥格式选择PKCS1(非JAVA适用)）。生成完之后，将生成的商户应用公钥填入开放平台中即可。 设置完应用公钥之后不要着急关闭我们生成签名的软件，我们需要将公钥和私钥（签名使用）保存到文件中，之后的代码中需要调用。 填写完成后，我们应该可以看到下面的界面。我们可以查看、修改之前的应用公钥， 并且此时注意，在“查看应用公钥”的旁边出现了另外一个按钮“查看支付宝公钥”，这个非常重要，很多新手把支付宝公钥和应用公钥搞混淆了，正常情况下我们代码中只需要用到两种密钥， 一个是应用私钥（用于生成app或网页端支付需要的签名参数）还有个是支付宝公钥（用于对支付宝异步通知结果进行验签的） ，到了之后的代码解析模块会详细讲解。 第2步：设置应用网关，这个地址也是很重要的，我们之后的支付结果支付宝都会通过异步的post请求这个到该地址上（用户付钱有没有成功就是依据他啦）。具体的请求参数参考：https://docs.open.alipay.com/204/105301/ 第3步：设置授权回调地址，第三方授权或用户信息授权后回调地址。授权链接中配置的redirect_uri的值必须与此值保持一致。当填入该地址时，系统会自动进行安全检测。授权回调地址很多同学可能用不上，详细的使用请参考： https://docs.open.alipay.com/316/106274 6.提交审核：填写完上述信息就可以提交审核了，经过我们几次开发，发现支付宝审核非常快，白天几十分钟就会审核完毕了，在这个过程中我们也不要等着了，可以开始coding咯。 Node.js实现支付参数的生成 下面就以app支付为例子进行分析： app端发起一个支付请求，需要一个参数（orderInfo），这个参数是从后台生成，如果我们后台（node）能够生成一个正确的参数，app端就可以成功的唤起支付宝，并且完成支付。 后台具体需要拼接哪些参数，请参考https://docs.open.alipay.com/204/105465/，文档中标记必填的参数我们也必须要填写。 看过请求参数的文档之后我们就可以正式开始组成app端需要的参数了，我们按照文档中的步骤进行构建参数，总共分为三步： 第一步：把所有必填的参数以及我们自己业务需要的参数组成key-value对象。 第二步：在第一步中有一个参数是最复杂，也是支付宝用来校验请求的合法性。就是sign（签名）这个参数，我们无法直接填写，需要通过应用的私钥去签名得到，我们第二步就是为了生成这个参数。 第三步：对我们参数中所有的value进行编码（encodeURIComponent），并且将参数转换成字符串返回给客户端即可； 第一步：生成基础参数 let params = new Map(); params.set(&#39;app_id&#39;, this.accountSettings.APP_ID); params.set(&#39;method&#39;, &#39;alipay.trade.app.pay&#39;); params.set(&#39;charset&#39;, &#39;utf-8&#39;); params.set(&#39;sign_type&#39;, &#39;RSA2&#39;); params.set(&#39;timestamp&#39;, moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;)); params.set(&#39;version&#39;, &#39;1.0&#39;); params.set(&#39;notify_url&#39;, this.accountSettings.APP_GATEWAY_URL); params.set(&#39;biz_content&#39;, this._buildBizContent(&#39;商品名称xxxx&#39;, &#39;商户订单号xxxxx&#39;, &#39;商品金额8.88&#39;)); _buildBizContent()这个方法是用来生成参数biz_content的，这个参数用来传递一些附加参数，具体参数请参考文档中的业务参数 /** * 生成业务请求参数的集合 * @param subject 商品的标题/交易标题/订单标题/订单关键字等。 * @param outTradeNo 商户网站唯一订单号 * @param totalAmount 订单总金额，单位为元，精确到小数点后两位，取值范围[0.01,100000000] * @returns {string} json字符串 * @private */ _buildBizContent(subject, outTradeNo, totalAmount) { let bizContent = { subject: subject, out_trade_no: outTradeNo, total_amount: totalAmount, product_code: &#39;QUICK_MSECURITY_PAY&#39;, }; return JSON.stringify(bizContent); } 第二步：生成签名 通过第一步，我们已经生成了基础参数存放在了params对象中，但是params中还缺少非常核心的一个参数就是“sign”下面我们就来说说如何生成sign，这次先看代码吧！（生成签名的官方文档在此） /** * 根据参数构建签名 * @param paramsMap Map对象 * @returns {number|PromiseLike&lt;ArrayBuffer&gt;} * @private */ _buildSign(paramsMap) { //1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数 let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join(&#39;&amp;&#39;); let privateKey = fs.readFileSync(this.accountSettings.APP_PRIVATE_KEY_PATH, &#39;utf8&#39;); let signType = paramsMap.get(&#39;sign_type&#39;); return this._signWithPrivateKey(signType, paramsString, privateKey); } /** * 通过私钥给字符串签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param content 需要加密的字符串 * @param privateKey 私钥 * @returns {number | PromiseLike&lt;ArrayBuffer&gt;} * @private */ _signWithPrivateKey(signType, content, privateKey) { let sign; if (signType.toUpperCase() === &#39;RSA2&#39;) { sign = crypto.createSign(&quot;RSA-SHA256&quot;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { sign = crypto.createSign(&quot;RSA-SHA1&quot;); } else { throw new Error(&#39;请传入正确的签名方式，signType：&#39; + signType); } sign.update(content); return sign.sign(privateKey, &#39;base64&#39;); } 当我们调用_buildSign()方法的时候，需要传入一个参数，就是我们第一步构建出来的params，函数返回的就是我们需要的sign参数，下面来看看它具体做了什么。 1.筛选字段：获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数。 //1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数 let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; v1); 2.根据key的ascii排序：按照第一个字符的键值ASCII码递增排序（字母升序排序），如果遇到相同字符则按照第二个字符的键值ASCII码递增排序，以此类推。 //2.按照字符的键值ASCII码递增排序 paramsList.sort(); 3.拼接字符串：将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来，此时生成的字符串为待签名字符串。 //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join(&#39;&amp;&#39;); 4.需要把上一步获取到的待签名字符串进行签名，签名分为两种，根据传递给支付宝的参数sign_type来判断（商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2），此时还需要把我们的应用私钥给取出来，用来签名。应用的私钥就是我们在一开始配置应用的时候，在生成应用公钥的时候与之对应的私钥。 需要注意的是我们将私钥存储在文件中的时候，需要在第一行和最后一行分别加上一行，否则会报错 5.接下来调用_signWithPrivateKey方法即可获取到我们的sign参数的内容了 第三步：对所有的参数的value进行编码，并获得最终字符串 params.set(&#39;sign&#39;, this._buildSign(params)); return [...params].map(([k, v]) =&gt; `${k}=${encodeURIComponent(v)}`).join(&#39;&amp;&#39;); 将我们上一步获取到的签名也设置到sign中，然后将所有的value进行encode，最终用“=“和“&amp;“拼接成字符串返回给前端，到这里我们就完成了所有的步骤:) Node.js实现服务器对支付结果异步通知的验签 对于App支付产生的交易，支付宝会根据原始支付API中传入的异步通知地址notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统。异步通知的详细参数列表请参考：https://docs.open.alipay.com/204/105301/。 接受异步通知这一步非常的重要，用户是否真正的支付成功绝大部分是依赖于这个请求，我们不可能根据客户端返回的支付结果来判断，也不可能每一笔账都去蚂蚁金服的后台去对账。所以一定要处理好支付宝给我们发的请求，一定要对收到参数进行验证签名，保证这个请求确实是支付宝给我们发送的，而不是某人捏造的请求，处理不好会造成很大的损失。 小提示：但我们收到请求并且处理完成后必须打印输出“success”（不包含引号）。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）。 下面是接受请求的路由的处理代码： handler.aliGateway = function (req, res, next) { let notifyTime = req.body.notify_time;//通知时间:通知的发送时间。格式为yyyy-MM-dd HH:mm:ss let notifyType = req.body.notify_type;//通知类型:通知的类型 let notifyId = req.body.notify_id;//通知校验ID:通知校验ID let appId = req.body.app_id;//支付宝分配给开发者的应用Id:支付宝分配给开发者的应用Id let charset = req.body.charset;//编码格式:编码格式，如utf-8、gbk、gb2312等 let version = req.body.version;//接口版本:调用的接口版本，固定为：1.0 let signType = req.body.sign_type;//签名类型:商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2 let sign = req.body.sign;//签名:请参考&lt;a href=&quot;#yanqian&quot; class=&quot;bi-link&quot;&gt;异步返回结果的验签&lt;/a&gt; let tradeNo = req.body.trade_no;//支付宝交易号:支付宝交易凭证号 let outTradeNo = req.body.out_trade_no;//商户订单号:原支付请求的商户订单号 let outBizNo = req.body.out_biz_no;//商户业务号:商户业务ID，主要是退款通知中返回退款申请的流水号 let buyerId = req.body.buyer_id;//买家支付宝用户号:买家支付宝账号对应的支付宝唯一用户号。以2088开头的纯16位数字 let buyerLogonId = req.body.buyer_logon_id;//买家支付宝账号:买家支付宝账号 let sellerId = req.body.seller_id;//卖家支付宝用户号:卖家支付宝用户号 let sellerEmail = req.body.seller_email;//卖家支付宝账号:卖家支付宝账号 let tradeStatus = req.body.trade_status;//交易状态:交易目前所处的状态，见&lt;a href=&quot;#jiaoyi&quot; class=&quot;bi-link&quot;&gt;交易状态说明&lt;/a&gt; let totalAmount = req.body.total_amount;//订单金额:本次交易支付的订单金额，单位为人民币（元） let receiptAmount = req.body.receipt_amount;//实收金额:商家在交易中实际收到的款项，单位为元 let invoiceAmount = req.body.invoice_amount;//开票金额:用户在交易中支付的可开发票的金额 let buyerPayAmount = req.body.buyer_pay_amount;//付款金额:用户在交易中支付的金额 let pointAmount = req.body.point_amount;//集分宝金额:使用集分宝支付的金额 let refundFee = req.body.refund_fee;//总退款金额:退款通知中，返回总退款金额，单位为元，支持两位小数 let subject = req.body.subject;//订单标题:商品的标题/交易标题/订单标题/订单关键字等，是请求时对应的参数，原样通知回来 let body = req.body.body;//商品描述:该订单的备注、描述、明细等。对应请求时的body参数，原样通知回来 let gmtCreate = req.body.gmt_create;//交易创建时间:该笔交易创建的时间。格式为yyyy-MM-dd HH:mm:ss let gmtPayment = req.body.gmt_payment;//交易付款时间:该笔交易的买家付款时间。格式为yyyy-MM-dd HH:mm:ss let gmtRefund = req.body.gmt_refund;//交易退款时间:该笔交易的退款时间。格式为yyyy-MM-dd HH:mm:ss.S let gmtClose = req.body.gmt_close;//交易结束时间:该笔交易结束时间。格式为yyyy-MM-dd HH:mm:ss let fundBillList = req.body.fund_bill_list;//支付金额信息:支付成功的各个渠道金额信息，详见&lt;a href=&quot;#zijin&quot; class=&quot;bi-link&quot;&gt;资金明细信息说明&lt;/a&gt; let passbackParams = req.body.passback_params;//回传参数:公共回传参数，如果请求时传递了该参数，则返回给商户时会在异步通知时将该参数原样返回。本参数必须进行UrlEncode之后才可以发送给支付宝 let voucherDetailList = req.body.voucher_detail_list;//优惠券信息:本交易支付时所使用的所有优惠券信息，详见&lt;a href=&quot;#youhui&quot; class=&quot;bi-link&quot;&gt;优惠券信息说明&lt;/a&gt; let payHelper = new AliPayHelper(DefineProto.AliAccountType.AAT_REMIND); let isSuccess = payHelper.verifySign(req.body); if (isSuccess) { if (tradeStatus === &#39;TRADE_FINISHED&#39;) {//交易状态TRADE_FINISHED的通知触发条件是商户签约的产品不支持退款功能的前提下，买家付款成功；或者，商户签约的产品支持退款功能的前提下，交易已经成功并且已经超过可退款期限。 } else if (tradeStatus === &#39;TRADE_SUCCESS&#39;) {//状态TRADE_SUCCESS的通知触发条件是商户签约的产品支持退款功能的前提下，买家付款成功 } else if (tradeStatus === &#39;WAIT_BUYER_PAY&#39;) { } else if (tradeStatus === &#39;TRADE_CLOSED&#39;) { } res.send(&#39;success&#39;); } else { res.send(&#39;fail&#39;); } }; 可以看到上面验签的核心代码就是payHelper.verifySign(req.body)，我们来具体看看支付是要求我们如何验签的，参考文档：https://docs.open.alipay.com/204/105301/ 很多操作都和签名的时候类似，唯一需要注意的是：验签的时候用的是支付宝的公钥而不是应用的公钥 需要注意的是我们将公钥存储在文件中的时候，需要在第一行和最后一行分别加上一行，否则会报错 贴上具体的验签代码： /** * 验证支付宝异步通知的合法性 * @param params 支付宝异步通知结果的参数 * @returns {*} */ verifySign(params) { try { let sign = params[&#39;sign&#39;];//签名 let signType = params[&#39;sign_type&#39;];//签名类型 let paramsMap = new Map(); for (let key in params) { paramsMap.set(key, params[key]); } let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; k1 !== &#39;sign_type&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${decodeURIComponent(v)}`).join(&#39;&amp;&#39;); let publicKey = fs.readFileSync(this.accountSettings.ALI_PUBLIC_KEY_PATH, &#39;utf8&#39;); return this._verifyWithPublicKey(signType, sign, paramsString, publicKey); } catch (e) { console.error(e); return false; } } /** * 验证签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param sign 返回参数的签名 * @param content 参数组成的待验签串 * @param publicKey 支付宝公钥 * @returns {*} 是否验证成功 * @private */ _verifyWithPublicKey(signType, sign, content, publicKey) { try { let verify; if (signType.toUpperCase() === &#39;RSA2&#39;) { verify = crypto.createVerify(&#39;RSA-SHA256&#39;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { verify = crypto.createVerify(&#39;RSA-SHA1&#39;); } else { throw new Error(&#39;未知signType：&#39; + signType); } verify.update(content); return verify.verify(publicKey, sign, &#39;base64&#39;) } catch (err) { console.error(err); return false; } } 到这里我们的三大块已经介绍完成啦，贴上完整的代码： const path = require(&#39;path&#39;); const fs = require(&#39;fs&#39;); const moment = require(&#39;moment&#39;); const crypto = require(&#39;crypto&#39;); let ALI_PAY_SETTINGS = { APP_ID: &#39;2016091100487933&#39;, APP_GATEWAY_URL: &#39;xxxxxxx&#39;,//用于接收支付宝异步通知 AUTH_REDIRECT_URL: &#39;xxxxxxx&#39;,//第三方授权或用户信息授权后回调地址。授权链接中配置的redirect_uri的值必须与此值保持一致。 APP_PRIVATE_KEY_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;app-private.pem&#39;),//应用私钥 APP_PUBLIC_KEY_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;app-public.pem&#39;),//应用公钥 ALI_PUBLIC_KEY_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;ali-public.pem&#39;),//阿里公钥 AES_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;aes.txt&#39;),//aes加密（暂未使用） }; class AliPayHelper { /** * 构造方法 * @param accountType 用于以后区分多支付账号 */ constructor(accountType) { this.accountType = accountType; this.accountSettings = ALI_PAY_SETTINGS; } /** * 构建app支付需要的参数 * @param subject 商品名称 * @param outTradeNo 自己公司的订单号 * @param totalAmount 金额 * @returns {string} */ buildParams(subject, outTradeNo, totalAmount) { let params = new Map(); params.set(&#39;app_id&#39;, this.accountSettings.APP_ID); params.set(&#39;method&#39;, &#39;alipay.trade.app.pay&#39;); params.set(&#39;charset&#39;, &#39;utf-8&#39;); params.set(&#39;sign_type&#39;, &#39;RSA2&#39;); params.set(&#39;timestamp&#39;, moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;)); params.set(&#39;version&#39;, &#39;1.0&#39;); params.set(&#39;notify_url&#39;, this.accountSettings.APP_GATEWAY_URL); params.set(&#39;biz_content&#39;, this._buildBizContent(subject, outTradeNo, totalAmount)); params.set(&#39;sign&#39;, this._buildSign(params)); return [...params].map(([k, v]) =&gt; `${k}=${encodeURIComponent(v)}`).join(&#39;&amp;&#39;); } /** * 根据参数构建签名 * @param paramsMap Map对象 * @returns {number|PromiseLike&lt;ArrayBuffer&gt;} * @private */ _buildSign(paramsMap) { //1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数 let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join(&#39;&amp;&#39;); let privateKey = fs.readFileSync(this.accountSettings.APP_PRIVATE_KEY_PATH, &#39;utf8&#39;); let signType = paramsMap.get(&#39;sign_type&#39;); return this._signWithPrivateKey(signType, paramsString, privateKey); } /** * 通过私钥给字符串签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param content 需要加密的字符串 * @param privateKey 私钥 * @returns {number | PromiseLike&lt;ArrayBuffer&gt;} * @private */ _signWithPrivateKey(signType, content, privateKey) { let sign; if (signType.toUpperCase() === &#39;RSA2&#39;) { sign = crypto.createSign(&quot;RSA-SHA256&quot;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { sign = crypto.createSign(&quot;RSA-SHA1&quot;); } else { throw new Error(&#39;请传入正确的签名方式，signType：&#39; + signType); } sign.update(content); return sign.sign(privateKey, &#39;base64&#39;); } /** * 生成业务请求参数的集合 * @param subject 商品的标题/交易标题/订单标题/订单关键字等。 * @param outTradeNo 商户网站唯一订单号 * @param totalAmount 订单总金额，单位为元，精确到小数点后两位，取值范围[0.01,100000000] * @returns {string} json字符串 * @private */ _buildBizContent(subject, outTradeNo, totalAmount) { let bizContent = { subject: subject, out_trade_no: outTradeNo, total_amount: totalAmount, product_code: &#39;QUICK_MSECURITY_PAY&#39;, }; return JSON.stringify(bizContent); } /** * 验证支付宝异步通知的合法性 * @param params 支付宝异步通知结果的参数 * @returns {*} */ verifySign(params) { try { let sign = params[&#39;sign&#39;];//签名 let signType = params[&#39;sign_type&#39;];//签名类型 let paramsMap = new Map(); for (let key in params) { paramsMap.set(key, params[key]); } let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; k1 !== &#39;sign_type&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${decodeURIComponent(v)}`).join(&#39;&amp;&#39;); let publicKey = fs.readFileSync(this.accountSettings.ALI_PUBLIC_KEY_PATH, &#39;utf8&#39;); return this._verifyWithPublicKey(signType, sign, paramsString, publicKey); } catch (e) { console.error(e); return false; } } /** * 验证签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param sign 返回参数的签名 * @param content 参数组成的待验签串 * @param publicKey 支付宝公钥 * @returns {*} 是否验证成功 * @private */ _verifyWithPublicKey(signType, sign, content, publicKey) { try { let verify; if (signType.toUpperCase() === &#39;RSA2&#39;) { verify = crypto.createVerify(&#39;RSA-SHA256&#39;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { verify = crypto.createVerify(&#39;RSA-SHA1&#39;); } else { throw new Error(&#39;未知signType：&#39; + signType); } verify.update(content); return verify.verify(publicKey, sign, &#39;base64&#39;) } catch (err) { console.error(err); return false; } } } module.exports = AliPayHelper;如果有写的不对的地方麻烦在评论中指出，如果有疑问也欢迎提问哦~ 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-08T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"最近项目（Android和Ios）中需要接入付费功能（支付宝和微信），下面就先来介绍下接入支付宝的流程。文章主要分为三大块： 第一块是如何在蚂蚁金服的开放平台创建一个应用并且配置开发选项。 第二块是node端接入支付功能生成前端支付需要的参数（私钥签名）。 第三块是node端对支付结果异步通知的验签（公钥验签）。 蚂蚁金服开放平台创建一个应用 一、登陆：进入开放平台登录账号后，进入开发者中心-网页&amp;移动应用栏目，点击创建应用中的支付接入 二、创建应用：使用场景选择“自用型应用”，并且给你的应用取一个响亮的名字（应用名称和应用图标会在授权、分享的场景中露出） 三、创建完成：这时候在我的应用里面可以看到我们刚刚创建的应用了，这时候点击“查看”按钮开始配置应用 四、添加功能：进入之后需要添加我们需要的功能选项（手机网站支付、app支付、授权等），很多功能是需要签约的，按照签约的提示填写即可。添加完毕后就可以开始开发配置了 五、开发配置：开发配置分为3步，第1步设置应用公钥，第2步设置应用公关，第3步设置授权回调地址，接下来详细介绍 第1步：生成应用公钥我们需要先下载一个软件（ https://docs.open.alipay.com/291/106097），通过这个软件我们可以生成公钥。因为我们用的开发语言是nodejs， 所以在生成公钥的时候注意选择的类型（密钥格式选择PKCS1(非JAVA适用)）。生成完之后，将生成的商户应用公钥填入开放平台中即可。 设置完应用公钥之后不要着急关闭我们生成签名的软件，我们需要将公钥和私钥（签名使用）保存到文件中，之后的代码中需要调用。 填写完成后，我们应该可以看到下面的界面。我们可以查看、修改之前的应用公钥， 并且此时注意，在“查看应用公钥”的旁边出现了另外一个按钮“查看支付宝公钥”，这个非常重要，很多新手把支付宝公钥和应用公钥搞混淆了，正常情况下我们代码中只需要用到两种密钥， 一个是应用私钥（用于生成app或网页端支付需要的签名参数）还有个是支付宝公钥（用于对支付宝异步通知结果进行验签的） ，到了之后的代码解析模块会详细讲解。 第2步：设置应用网关，这个地址也是很重要的，我们之后的支付结果支付宝都会通过异步的post请求这个到该地址上（用户付钱有没有成功就是依据他啦）。具体的请求参数参考：https://docs.open.alipay.com/204/105301/ 第3步：设置授权回调地址，第三方授权或用户信息授权后回调地址。授权链接中配置的redirect_uri的值必须与此值保持一致。当填入该地址时，系统会自动进行安全检测。授权回调地址很多同学可能用不上，详细的使用请参考： https://docs.open.alipay.com/316/106274 6.提交审核：填写完上述信息就可以提交审核了，经过我们几次开发，发现支付宝审核非常快，白天几十分钟就会审核完毕了，在这个过程中我们也不要等着了，可以开始coding咯。 Node.js实现支付参数的生成 下面就以app支付为例子进行分析： app端发起一个支付请求，需要一个参数（orderInfo），这个参数是从后台生成，如果我们后台（node）能够生成一个正确的参数，app端就可以成功的唤起支付宝，并且完成支付。 后台具体需要拼接哪些参数，请参考https://docs.open.alipay.com/204/105465/，文档中标记必填的参数我们也必须要填写。 看过请求参数的文档之后我们就可以正式开始组成app端需要的参数了，我们按照文档中的步骤进行构建参数，总共分为三步： 第一步：把所有必填的参数以及我们自己业务需要的参数组成key-value对象。 第二步：在第一步中有一个参数是最复杂，也是支付宝用来校验请求的合法性。就是sign（签名）这个参数，我们无法直接填写，需要通过应用的私钥去签名得到，我们第二步就是为了生成这个参数。 第三步：对我们参数中所有的value进行编码（encodeURIComponent），并且将参数转换成字符串返回给客户端即可； 第一步：生成基础参数 let params = new Map(); params.set(&#39;app_id&#39;, this.accountSettings.APP_ID); params.set(&#39;method&#39;, &#39;alipay.trade.app.pay&#39;); params.set(&#39;charset&#39;, &#39;utf-8&#39;); params.set(&#39;sign_type&#39;, &#39;RSA2&#39;); params.set(&#39;timestamp&#39;, moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;)); params.set(&#39;version&#39;, &#39;1.0&#39;); params.set(&#39;notify_url&#39;, this.accountSettings.APP_GATEWAY_URL); params.set(&#39;biz_content&#39;, this._buildBizContent(&#39;商品名称xxxx&#39;, &#39;商户订单号xxxxx&#39;, &#39;商品金额8.88&#39;)); _buildBizContent()这个方法是用来生成参数biz_content的，这个参数用来传递一些附加参数，具体参数请参考文档中的业务参数 /** * 生成业务请求参数的集合 * @param subject 商品的标题/交易标题/订单标题/订单关键字等。 * @param outTradeNo 商户网站唯一订单号 * @param totalAmount 订单总金额，单位为元，精确到小数点后两位，取值范围[0.01,100000000] * @returns {string} json字符串 * @private */ _buildBizContent(subject, outTradeNo, totalAmount) { let bizContent = { subject: subject, out_trade_no: outTradeNo, total_amount: totalAmount, product_code: &#39;QUICK_MSECURITY_PAY&#39;, }; return JSON.stringify(bizContent); } 第二步：生成签名 通过第一步，我们已经生成了基础参数存放在了params对象中，但是params中还缺少非常核心的一个参数就是“sign”下面我们就来说说如何生成sign，这次先看代码吧！（生成签名的官方文档在此） /** * 根据参数构建签名 * @param paramsMap Map对象 * @returns {number|PromiseLike&lt;ArrayBuffer&gt;} * @private */ _buildSign(paramsMap) { //1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数 let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join(&#39;&amp;&#39;); let privateKey = fs.readFileSync(this.accountSettings.APP_PRIVATE_KEY_PATH, &#39;utf8&#39;); let signType = paramsMap.get(&#39;sign_type&#39;); return this._signWithPrivateKey(signType, paramsString, privateKey); } /** * 通过私钥给字符串签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param content 需要加密的字符串 * @param privateKey 私钥 * @returns {number | PromiseLike&lt;ArrayBuffer&gt;} * @private */ _signWithPrivateKey(signType, content, privateKey) { let sign; if (signType.toUpperCase() === &#39;RSA2&#39;) { sign = crypto.createSign(&quot;RSA-SHA256&quot;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { sign = crypto.createSign(&quot;RSA-SHA1&quot;); } else { throw new Error(&#39;请传入正确的签名方式，signType：&#39; + signType); } sign.update(content); return sign.sign(privateKey, &#39;base64&#39;); } 当我们调用_buildSign()方法的时候，需要传入一个参数，就是我们第一步构建出来的params，函数返回的就是我们需要的sign参数，下面来看看它具体做了什么。 1.筛选字段：获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数。 //1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数 let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; v1); 2.根据key的ascii排序：按照第一个字符的键值ASCII码递增排序（字母升序排序），如果遇到相同字符则按照第二个字符的键值ASCII码递增排序，以此类推。 //2.按照字符的键值ASCII码递增排序 paramsList.sort(); 3.拼接字符串：将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来，此时生成的字符串为待签名字符串。 //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join(&#39;&amp;&#39;); 4.需要把上一步获取到的待签名字符串进行签名，签名分为两种，根据传递给支付宝的参数sign_type来判断（商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2），此时还需要把我们的应用私钥给取出来，用来签名。应用的私钥就是我们在一开始配置应用的时候，在生成应用公钥的时候与之对应的私钥。 需要注意的是我们将私钥存储在文件中的时候，需要在第一行和最后一行分别加上一行，否则会报错 5.接下来调用_signWithPrivateKey方法即可获取到我们的sign参数的内容了 第三步：对所有的参数的value进行编码，并获得最终字符串 params.set(&#39;sign&#39;, this._buildSign(params)); return [...params].map(([k, v]) =&gt; `${k}=${encodeURIComponent(v)}`).join(&#39;&amp;&#39;); 将我们上一步获取到的签名也设置到sign中，然后将所有的value进行encode，最终用“=“和“&amp;“拼接成字符串返回给前端，到这里我们就完成了所有的步骤:) Node.js实现服务器对支付结果异步通知的验签 对于App支付产生的交易，支付宝会根据原始支付API中传入的异步通知地址notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统。异步通知的详细参数列表请参考：https://docs.open.alipay.com/204/105301/。 接受异步通知这一步非常的重要，用户是否真正的支付成功绝大部分是依赖于这个请求，我们不可能根据客户端返回的支付结果来判断，也不可能每一笔账都去蚂蚁金服的后台去对账。所以一定要处理好支付宝给我们发的请求，一定要对收到参数进行验证签名，保证这个请求确实是支付宝给我们发送的，而不是某人捏造的请求，处理不好会造成很大的损失。 小提示：但我们收到请求并且处理完成后必须打印输出“success”（不包含引号）。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）。 下面是接受请求的路由的处理代码： handler.aliGateway = function (req, res, next) { let notifyTime = req.body.notify_time;//通知时间:通知的发送时间。格式为yyyy-MM-dd HH:mm:ss let notifyType = req.body.notify_type;//通知类型:通知的类型 let notifyId = req.body.notify_id;//通知校验ID:通知校验ID let appId = req.body.app_id;//支付宝分配给开发者的应用Id:支付宝分配给开发者的应用Id let charset = req.body.charset;//编码格式:编码格式，如utf-8、gbk、gb2312等 let version = req.body.version;//接口版本:调用的接口版本，固定为：1.0 let signType = req.body.sign_type;//签名类型:商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2 let sign = req.body.sign;//签名:请参考&lt;a href=&quot;#yanqian&quot; class=&quot;bi-link&quot;&gt;异步返回结果的验签&lt;/a&gt; let tradeNo = req.body.trade_no;//支付宝交易号:支付宝交易凭证号 let outTradeNo = req.body.out_trade_no;//商户订单号:原支付请求的商户订单号 let outBizNo = req.body.out_biz_no;//商户业务号:商户业务ID，主要是退款通知中返回退款申请的流水号 let buyerId = req.body.buyer_id;//买家支付宝用户号:买家支付宝账号对应的支付宝唯一用户号。以2088开头的纯16位数字 let buyerLogonId = req.body.buyer_logon_id;//买家支付宝账号:买家支付宝账号 let sellerId = req.body.seller_id;//卖家支付宝用户号:卖家支付宝用户号 let sellerEmail = req.body.seller_email;//卖家支付宝账号:卖家支付宝账号 let tradeStatus = req.body.trade_status;//交易状态:交易目前所处的状态，见&lt;a href=&quot;#jiaoyi&quot; class=&quot;bi-link&quot;&gt;交易状态说明&lt;/a&gt; let totalAmount = req.body.total_amount;//订单金额:本次交易支付的订单金额，单位为人民币（元） let receiptAmount = req.body.receipt_amount;//实收金额:商家在交易中实际收到的款项，单位为元 let invoiceAmount = req.body.invoice_amount;//开票金额:用户在交易中支付的可开发票的金额 let buyerPayAmount = req.body.buyer_pay_amount;//付款金额:用户在交易中支付的金额 let pointAmount = req.body.point_amount;//集分宝金额:使用集分宝支付的金额 let refundFee = req.body.refund_fee;//总退款金额:退款通知中，返回总退款金额，单位为元，支持两位小数 let subject = req.body.subject;//订单标题:商品的标题/交易标题/订单标题/订单关键字等，是请求时对应的参数，原样通知回来 let body = req.body.body;//商品描述:该订单的备注、描述、明细等。对应请求时的body参数，原样通知回来 let gmtCreate = req.body.gmt_create;//交易创建时间:该笔交易创建的时间。格式为yyyy-MM-dd HH:mm:ss let gmtPayment = req.body.gmt_payment;//交易付款时间:该笔交易的买家付款时间。格式为yyyy-MM-dd HH:mm:ss let gmtRefund = req.body.gmt_refund;//交易退款时间:该笔交易的退款时间。格式为yyyy-MM-dd HH:mm:ss.S let gmtClose = req.body.gmt_close;//交易结束时间:该笔交易结束时间。格式为yyyy-MM-dd HH:mm:ss let fundBillList = req.body.fund_bill_list;//支付金额信息:支付成功的各个渠道金额信息，详见&lt;a href=&quot;#zijin&quot; class=&quot;bi-link&quot;&gt;资金明细信息说明&lt;/a&gt; let passbackParams = req.body.passback_params;//回传参数:公共回传参数，如果请求时传递了该参数，则返回给商户时会在异步通知时将该参数原样返回。本参数必须进行UrlEncode之后才可以发送给支付宝 let voucherDetailList = req.body.voucher_detail_list;//优惠券信息:本交易支付时所使用的所有优惠券信息，详见&lt;a href=&quot;#youhui&quot; class=&quot;bi-link&quot;&gt;优惠券信息说明&lt;/a&gt; let payHelper = new AliPayHelper(DefineProto.AliAccountType.AAT_REMIND); let isSuccess = payHelper.verifySign(req.body); if (isSuccess) { if (tradeStatus === &#39;TRADE_FINISHED&#39;) {//交易状态TRADE_FINISHED的通知触发条件是商户签约的产品不支持退款功能的前提下，买家付款成功；或者，商户签约的产品支持退款功能的前提下，交易已经成功并且已经超过可退款期限。 } else if (tradeStatus === &#39;TRADE_SUCCESS&#39;) {//状态TRADE_SUCCESS的通知触发条件是商户签约的产品支持退款功能的前提下，买家付款成功 } else if (tradeStatus === &#39;WAIT_BUYER_PAY&#39;) { } else if (tradeStatus === &#39;TRADE_CLOSED&#39;) { } res.send(&#39;success&#39;); } else { res.send(&#39;fail&#39;); } }; 可以看到上面验签的核心代码就是payHelper.verifySign(req.body)，我们来具体看看支付是要求我们如何验签的，参考文档：https://docs.open.alipay.com/204/105301/ 很多操作都和签名的时候类似，唯一需要注意的是：验签的时候用的是支付宝的公钥而不是应用的公钥 需要注意的是我们将公钥存储在文件中的时候，需要在第一行和最后一行分别加上一行，否则会报错 贴上具体的验签代码： /** * 验证支付宝异步通知的合法性 * @param params 支付宝异步通知结果的参数 * @returns {*} */ verifySign(params) { try { let sign = params[&#39;sign&#39;];//签名 let signType = params[&#39;sign_type&#39;];//签名类型 let paramsMap = new Map(); for (let key in params) { paramsMap.set(key, params[key]); } let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; k1 !== &#39;sign_type&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${decodeURIComponent(v)}`).join(&#39;&amp;&#39;); let publicKey = fs.readFileSync(this.accountSettings.ALI_PUBLIC_KEY_PATH, &#39;utf8&#39;); return this._verifyWithPublicKey(signType, sign, paramsString, publicKey); } catch (e) { console.error(e); return false; } } /** * 验证签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param sign 返回参数的签名 * @param content 参数组成的待验签串 * @param publicKey 支付宝公钥 * @returns {*} 是否验证成功 * @private */ _verifyWithPublicKey(signType, sign, content, publicKey) { try { let verify; if (signType.toUpperCase() === &#39;RSA2&#39;) { verify = crypto.createVerify(&#39;RSA-SHA256&#39;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { verify = crypto.createVerify(&#39;RSA-SHA1&#39;); } else { throw new Error(&#39;未知signType：&#39; + signType); } verify.update(content); return verify.verify(publicKey, sign, &#39;base64&#39;) } catch (err) { console.error(err); return false; } } 到这里我们的三大块已经介绍完成啦，贴上完整的代码： const path = require(&#39;path&#39;); const fs = require(&#39;fs&#39;); const moment = require(&#39;moment&#39;); const crypto = require(&#39;crypto&#39;); let ALI_PAY_SETTINGS = { APP_ID: &#39;2016091100487933&#39;, APP_GATEWAY_URL: &#39;xxxxxxx&#39;,//用于接收支付宝异步通知 AUTH_REDIRECT_URL: &#39;xxxxxxx&#39;,//第三方授权或用户信息授权后回调地址。授权链接中配置的redirect_uri的值必须与此值保持一致。 APP_PRIVATE_KEY_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;app-private.pem&#39;),//应用私钥 APP_PUBLIC_KEY_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;app-public.pem&#39;),//应用公钥 ALI_PUBLIC_KEY_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;ali-public.pem&#39;),//阿里公钥 AES_PATH: path.join(__dirname, &#39;pem&#39;, &#39;remind&#39;, &#39;sandbox&#39;, &#39;aes.txt&#39;),//aes加密（暂未使用） }; class AliPayHelper { /** * 构造方法 * @param accountType 用于以后区分多支付账号 */ constructor(accountType) { this.accountType = accountType; this.accountSettings = ALI_PAY_SETTINGS; } /** * 构建app支付需要的参数 * @param subject 商品名称 * @param outTradeNo 自己公司的订单号 * @param totalAmount 金额 * @returns {string} */ buildParams(subject, outTradeNo, totalAmount) { let params = new Map(); params.set(&#39;app_id&#39;, this.accountSettings.APP_ID); params.set(&#39;method&#39;, &#39;alipay.trade.app.pay&#39;); params.set(&#39;charset&#39;, &#39;utf-8&#39;); params.set(&#39;sign_type&#39;, &#39;RSA2&#39;); params.set(&#39;timestamp&#39;, moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;)); params.set(&#39;version&#39;, &#39;1.0&#39;); params.set(&#39;notify_url&#39;, this.accountSettings.APP_GATEWAY_URL); params.set(&#39;biz_content&#39;, this._buildBizContent(subject, outTradeNo, totalAmount)); params.set(&#39;sign&#39;, this._buildSign(params)); return [...params].map(([k, v]) =&gt; `${k}=${encodeURIComponent(v)}`).join(&#39;&amp;&#39;); } /** * 根据参数构建签名 * @param paramsMap Map对象 * @returns {number|PromiseLike&lt;ArrayBuffer&gt;} * @private */ _buildSign(paramsMap) { //1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数 let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join(&#39;&amp;&#39;); let privateKey = fs.readFileSync(this.accountSettings.APP_PRIVATE_KEY_PATH, &#39;utf8&#39;); let signType = paramsMap.get(&#39;sign_type&#39;); return this._signWithPrivateKey(signType, paramsString, privateKey); } /** * 通过私钥给字符串签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param content 需要加密的字符串 * @param privateKey 私钥 * @returns {number | PromiseLike&lt;ArrayBuffer&gt;} * @private */ _signWithPrivateKey(signType, content, privateKey) { let sign; if (signType.toUpperCase() === &#39;RSA2&#39;) { sign = crypto.createSign(&quot;RSA-SHA256&quot;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { sign = crypto.createSign(&quot;RSA-SHA1&quot;); } else { throw new Error(&#39;请传入正确的签名方式，signType：&#39; + signType); } sign.update(content); return sign.sign(privateKey, &#39;base64&#39;); } /** * 生成业务请求参数的集合 * @param subject 商品的标题/交易标题/订单标题/订单关键字等。 * @param outTradeNo 商户网站唯一订单号 * @param totalAmount 订单总金额，单位为元，精确到小数点后两位，取值范围[0.01,100000000] * @returns {string} json字符串 * @private */ _buildBizContent(subject, outTradeNo, totalAmount) { let bizContent = { subject: subject, out_trade_no: outTradeNo, total_amount: totalAmount, product_code: &#39;QUICK_MSECURITY_PAY&#39;, }; return JSON.stringify(bizContent); } /** * 验证支付宝异步通知的合法性 * @param params 支付宝异步通知结果的参数 * @returns {*} */ verifySign(params) { try { let sign = params[&#39;sign&#39;];//签名 let signType = params[&#39;sign_type&#39;];//签名类型 let paramsMap = new Map(); for (let key in params) { paramsMap.set(key, params[key]); } let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== &#39;sign&#39; &amp;&amp; k1 !== &#39;sign_type&#39; &amp;&amp; v1); //2.按照字符的键值ASCII码递增排序 paramsList.sort(); //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来 let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${decodeURIComponent(v)}`).join(&#39;&amp;&#39;); let publicKey = fs.readFileSync(this.accountSettings.ALI_PUBLIC_KEY_PATH, &#39;utf8&#39;); return this._verifyWithPublicKey(signType, sign, paramsString, publicKey); } catch (e) { console.error(e); return false; } } /** * 验证签名 * @param signType 返回参数的签名类型：RSA2或RSA * @param sign 返回参数的签名 * @param content 参数组成的待验签串 * @param publicKey 支付宝公钥 * @returns {*} 是否验证成功 * @private */ _verifyWithPublicKey(signType, sign, content, publicKey) { try { let verify; if (signType.toUpperCase() === &#39;RSA2&#39;) { verify = crypto.createVerify(&#39;RSA-SHA256&#39;); } else if (signType.toUpperCase() === &#39;RSA&#39;) { verify = crypto.createVerify(&#39;RSA-SHA1&#39;); } else { throw new Error(&#39;未知signType：&#39; + signType); } verify.update(content); return verify.verify(publicKey, sign, &#39;base64&#39;) } catch (err) { console.error(err); return false; } } } module.exports = AliPayHelper;如果有写的不对的地方麻烦在评论中指出，如果有疑问也欢迎提问哦~ 阅读更多","@type":"BlogPosting","url":"/2018/03/08/39d6dbd28b7adc1b61624c256ba8cdc3.html","headline":"Node.js接入支付宝（蚂蚁金服）支付","dateModified":"2018-03-08T00:00:00+08:00","datePublished":"2018-03-08T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/03/08/39d6dbd28b7adc1b61624c256ba8cdc3.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Node.js接入支付宝（蚂蚁金服）支付</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>最近项目（Android和Ios）中需要接入付费功能（支付宝和微信），下面就先来介绍下接入支付宝的流程。文章主要分为三大块：</p>
  <p>第一块是如何在蚂蚁金服的开放平台创建一个应用并且配置开发选项。</p>
  <p>第二块是node端接入支付功能生成前端支付需要的参数（私钥签名）。</p>
  <p>第三块是node端对支付结果异步通知的验签（公钥验签）。</p>
  <p><br></p>
  <h2><span style="color:#ff0000;">蚂蚁金服开放平台创建一个应用</span></h2>
  <h5 style="text-align:left;">一、登陆：进入<a href="https://open.alipay.com/platform/home.htm" rel="nofollow">开放平台</a>登录账号后，进入开发者中心-网页&amp;移动应用栏目，点击创建应用中的支付接入<img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307232119739?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></h5>
  <h5 style="text-align:left;"><br></h5>
  <h5 style="text-align:left;">二、创建应用：使用场景选择“自用型应用”，并且给你的应用取一个响亮的名字（应用名称和应用图标会在授权、分享的场景中露出）<span style="font-weight:normal;"></span></h5>
  <h5 style="text-align:left;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307232356621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></h5>
  <h5><br></h5>
  <h5><br></h5>
  <h5>三、创建完成：这时候在我的应用里面可以看到我们刚刚创建的应用了，这时候点击“查看”按钮开始配置应用</h5>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307232833641?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
  <h5 style="text-align:left;"><br></h5>
  <h5 style="text-align:left;"><br></h5>
  <h5 style="text-align:left;">四、添加功能：进入之后需要添加我们需要的功能选项（手机网站支付、app支付、授权等），很多功能是需要签约的，按照签约的提示填写即可。添加完毕后就可以开始开发配置了<img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307233203820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></h5>
  <h5><br></h5>
  <h5>五、开发配置：开发配置分为3步，第1步设置应用公钥，第2步设置应用公关，第3步设置授权回调地址，接下来详细介绍</h5>
  <div>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307234126344?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="">
   <br>
  </div>
  <div>
   <br>
  </div>
  <div>
   第1步：生成应用公钥我们需要先下载一个软件（
   <a href="https://docs.open.alipay.com/291/106097" rel="nofollow">https://docs.open.alipay.com/291/106097</a>），通过这个软件我们可以生成公钥。因为我们用的开发语言是nodejs，
   <strong>所以在生成公钥的时候注意选择的类型（密钥格式选择PKCS1(非JAVA适用)）</strong>。生成完之后，将生成的商户应用公钥填入开放平台中即可。
   <strong>设置完应用公钥之后不要着急关闭我们生成签名的软件，我们需要将公钥和私钥（签名使用）保存到文件中，之后的代码中需要调用。</strong>
  </div>
  <div>
   <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307234428530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="">
   <br>
  </div>
  <div>
   <br>
  </div>
  <div>
   填写完成后，我们应该可以看到下面的界面。我们可以查看、修改之前的应用公钥，
   <strong>并且此时注意，在“查看应用公钥”的旁边出现了另外一个按钮“查看支付宝公钥”，这个非常重要，很多新手把支付宝公钥和应用公钥搞混淆了，正常情况下我们代码中只需要用到两种密钥，</strong>
   <span style="color:#ff0000;"><strong>一个是应用私钥（用于生成app或网页端支付需要的签名参数）还有个是支付宝公钥（用于对支付宝异步通知结果进行验签的）</strong></span>
   <span style="color:#000000;">，到了之后的代码解析模块会详细讲解。</span>
  </div>
  <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307234833850?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="">
  <p><br></p>
  <p>第2步：设置应用网关，这个地址也是很重要的，我们之后的支付结果支付宝都会通过异步的post请求这个到该地址上（用户付钱有没有成功就是依据他啦）。具体的请求参数参考：<a href="https://docs.open.alipay.com/204/105301/" rel="nofollow">https://docs.open.alipay.com/204/105301/</a></p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307235547698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <div>
   <br>
  </div>
  <div>
   第3步：设置授权回调地址，第三方授权或用户信息授权后回调地址。授权链接中配置的redirect_uri的值必须与此值保持一致。当填入该地址时，系统会自动进行安全检测。授权回调地址很多同学可能用不上，详细的使用请参考：
   <a href="https://docs.open.alipay.com/316/106274" rel="nofollow">https://docs.open.alipay.com/316/106274</a>
   <br>
  </div>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307235939155?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
  <h5><br></h5>
  <h5><br></h5>
  <h5>6.提交审核：填写完上述信息就可以提交审核了，经过我们几次开发，发现支付宝审核非常快，白天几十分钟就会审核完毕了，在这个过程中我们也不要等着了，可以开始coding咯。</h5>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180308000310356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p><br></p>
  <p><br></p>
  <h2><span style="color:#ff0000;">Node.js实现支付参数的生成</span></h2>
  <p>下面就以app支付为例子进行分析：</p>
  <p>app端发起一个支付请求，需要一个参数（orderInfo），这个参数是从后台生成，如果我们后台（node）能够生成一个正确的参数，app端就可以成功的唤起支付宝，并且完成支付。</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180308173749420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p><br></p>
  <p>后台具体需要拼接哪些参数，请参考<a href="https://docs.open.alipay.com/204/105465/" rel="nofollow">https://docs.open.alipay.com/204/105465/</a>，文档中标记必填的参数我们也必须要填写。</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180308174225157?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p><br></p>
  <p>看过请求参数的文档之后我们就可以正式开始组成app端需要的参数了，我们按照文档中的步骤进行构建参数，总共分为三步：</p>
  <p>第一步：把所有必填的参数以及我们自己业务需要的参数组成key-value对象。</p>
  <p>第二步：在第一步中有一个参数是最复杂，也是支付宝用来校验请求的合法性。就是sign（签名）这个参数，我们无法直接填写，需要通过应用的私钥去签名得到，我们第二步就是为了生成这个参数。</p>
  <p>第三步：对我们参数中所有的value进行编码（encodeURIComponent），并且将参数转换成字符串返回给客户端即可；</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018030817455986?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p><br></p>
  <h4>第一步：生成基础参数</h4>
  <pre><code class="language-javascript">let params = new Map();
params.set('app_id', this.accountSettings.APP_ID);
params.set('method', 'alipay.trade.app.pay');
params.set('charset', 'utf-8');
params.set('sign_type', 'RSA2');
params.set('timestamp', moment().format('YYYY-MM-DD HH:mm:ss'));
params.set('version', '1.0');
params.set('notify_url', this.accountSettings.APP_GATEWAY_URL);
params.set('biz_content', this._buildBizContent('商品名称xxxx', '商户订单号xxxxx', '商品金额8.88'));</code></pre>
  <p>_buildBizContent()这个方法是用来生成参数biz_content的，这个参数用来传递一些附加参数，具体参数请参考<a href="https://docs.open.alipay.com/204/105465/" rel="nofollow">文档中的业务参数</a></p>
  <pre><code class="language-javascript">/**
 * 生成业务请求参数的集合
 * @param subject       商品的标题/交易标题/订单标题/订单关键字等。
 * @param outTradeNo    商户网站唯一订单号
 * @param totalAmount   订单总金额，单位为元，精确到小数点后两位，取值范围[0.01,100000000]
 * @returns {string}    json字符串
 * @private
 */
_buildBizContent(subject, outTradeNo, totalAmount) {
    let bizContent = {
        subject: subject,
        out_trade_no: outTradeNo,
        total_amount: totalAmount,
        product_code: 'QUICK_MSECURITY_PAY',
    };

    return JSON.stringify(bizContent);
}</code></pre>
  <p><br></p>
  <h4>第二步：生成签名</h4>
  <p>通过第一步，我们已经生成了基础参数存放在了params对象中，但是params中还缺少非常核心的一个参数就是“sign”下面我们就来说说如何生成sign，这次先看代码吧！（生成签名的<a href="https://docs.open.alipay.com/291/106118" rel="nofollow">官方文档</a>在此）</p>
  <pre><code class="language-javascript">/**
 * 根据参数构建签名
 * @param paramsMap    Map对象
 * @returns {number|PromiseLike&lt;ArrayBuffer&gt;}
 * @private
 */
_buildSign(paramsMap) {
    //1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数
    let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== 'sign' &amp;&amp; v1);
    //2.按照字符的键值ASCII码递增排序
    paramsList.sort();
    //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来
    let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join('&amp;');

    let privateKey = fs.readFileSync(this.accountSettings.APP_PRIVATE_KEY_PATH, 'utf8');
    let signType = paramsMap.get('sign_type');
    return this._signWithPrivateKey(signType, paramsString, privateKey);
}

/**
 * 通过私钥给字符串签名
 * @param signType      返回参数的签名类型：RSA2或RSA
 * @param content       需要加密的字符串
 * @param privateKey    私钥
 * @returns {number | PromiseLike&lt;ArrayBuffer&gt;}
 * @private
 */
_signWithPrivateKey(signType, content, privateKey) {
    let sign;
    if (signType.toUpperCase() === 'RSA2') {
        sign = crypto.createSign("RSA-SHA256");
    } else if (signType.toUpperCase() === 'RSA') {
        sign = crypto.createSign("RSA-SHA1");
    } else {
        throw new Error('请传入正确的签名方式，signType：' + signType);
    }
    sign.update(content);
    return sign.sign(privateKey, 'base64');
}</code></pre>
  <p>当我们调用_buildSign()方法的时候，需要传入一个参数，就是我们第一步构建出来的params，函数返回的就是我们需要的sign参数，下面来看看它具体做了什么。</p>
  <p></p>
  <p>1.筛选字段：获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数。</p>
  <pre><code class="language-javascript">//1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数
let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== 'sign' &amp;&amp; v1);</code></pre>
  <p>2.根据key的ascii排序：按照第一个字符的键值ASCII码递增排序（字母升序排序），如果遇到相同字符则按照第二个字符的键值ASCII码递增排序，以此类推。</p>
  <pre><code class="language-javascript">//2.按照字符的键值ASCII码递增排序
paramsList.sort();</code></pre>
  <p>3.拼接字符串：将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来，此时生成的字符串为待签名字符串。</p>
  <pre><code class="language-javascript">//3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来
let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join('&amp;');</code></pre>
  <p>4.需要把上一步获取到的待<strong>签名字符串</strong>进行签名，签名分为两种，根据传递给支付宝的参数<strong>sign_type</strong>来判断（商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2），此时还需要把我们的<strong>应用私钥</strong>给取出来，用来签名。应用的私钥就是我们在一开始配置应用的时候，在生成应用公钥的时候与之对应的私钥。</p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180308215957927?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p><strong>需要注意的是我们将私钥存储在文件中的时候，需要在第一行和最后一行分别加上一行，否则会报错</strong></p>
  <p><strong><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180308232151301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></strong></p>
  <p><br></p>
  <p>5.接下来调用_signWithPrivateKey方法即可获取到我们的sign参数的内容了</p>
  <p><br></p>
  <h4>第三步：对所有的参数的value进行编码，并获得最终字符串</h4>
  <pre><code class="language-javascript">params.set('sign', this._buildSign(params));
return [...params].map(([k, v]) =&gt; `${k}=${encodeURIComponent(v)}`).join('&amp;');</code></pre>
  <p>将我们上一步获取到的签名也设置到sign中，然后将所有的value进行encode，最终用“=“和“&amp;“拼接成字符串返回给前端，到这里我们就完成了所有的步骤:)</p>
  <p><br></p>
  <p><br></p>
  <p></p>
  <h2><span style="color:#ff0000;">Node.js实现服务器对支付结果异步通知的验签</span></h2>
  <p>对于App支付产生的交易，支付宝会根据原始支付API中传入的异步通知地址<strong><span style="color:#ff0000;">notify_url</span></strong>，通过POST请求的形式将支付结果作为参数通知到商户系统。异步通知的详细参数列表请参考：<a href="https://docs.open.alipay.com/204/105301/" rel="nofollow">https://docs.open.alipay.com/204/105301/</a>。</p>
  <p>接受异步通知这一步非常的重要，用户是否真正的支付成功绝大部分是依赖于这个请求，我们不可能根据客户端返回的支付结果来判断，也不可能每一笔账都去蚂蚁金服的后台去对账。所以<strong>一定要处理好支付宝给我们发的请求，一定要对收到参数进行验证签名，保证这个请求确实是支付宝给我们发送的，而不是某人捏造的请求，处理不好会造成很大的损失。</strong></p>
  <p>小提示：但我们收到请求并且处理完成后必须打印输出“success”（不包含引号）。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）。</p>
  <p>下面是接受请求的路由的处理代码：</p>
  <pre><code class="language-javascript">handler.aliGateway = function (req, res, next) {
    let notifyTime = req.body.notify_time;//通知时间:通知的发送时间。格式为yyyy-MM-dd HH:mm:ss
    let notifyType = req.body.notify_type;//通知类型:通知的类型
    let notifyId = req.body.notify_id;//通知校验ID:通知校验ID
    let appId = req.body.app_id;//支付宝分配给开发者的应用Id:支付宝分配给开发者的应用Id
    let charset = req.body.charset;//编码格式:编码格式，如utf-8、gbk、gb2312等
    let version = req.body.version;//接口版本:调用的接口版本，固定为：1.0
    let signType = req.body.sign_type;//签名类型:商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2
    let sign = req.body.sign;//签名:请参考&lt;a href="#yanqian" class="bi-link"&gt;异步返回结果的验签&lt;/a&gt;
    let tradeNo = req.body.trade_no;//支付宝交易号:支付宝交易凭证号
    let outTradeNo = req.body.out_trade_no;//商户订单号:原支付请求的商户订单号
    let outBizNo = req.body.out_biz_no;//商户业务号:商户业务ID，主要是退款通知中返回退款申请的流水号
    let buyerId = req.body.buyer_id;//买家支付宝用户号:买家支付宝账号对应的支付宝唯一用户号。以2088开头的纯16位数字
    let buyerLogonId = req.body.buyer_logon_id;//买家支付宝账号:买家支付宝账号
    let sellerId = req.body.seller_id;//卖家支付宝用户号:卖家支付宝用户号
    let sellerEmail = req.body.seller_email;//卖家支付宝账号:卖家支付宝账号
    let tradeStatus = req.body.trade_status;//交易状态:交易目前所处的状态，见&lt;a href="#jiaoyi" class="bi-link"&gt;交易状态说明&lt;/a&gt;
    let totalAmount = req.body.total_amount;//订单金额:本次交易支付的订单金额，单位为人民币（元）
    let receiptAmount = req.body.receipt_amount;//实收金额:商家在交易中实际收到的款项，单位为元
    let invoiceAmount = req.body.invoice_amount;//开票金额:用户在交易中支付的可开发票的金额
    let buyerPayAmount = req.body.buyer_pay_amount;//付款金额:用户在交易中支付的金额
    let pointAmount = req.body.point_amount;//集分宝金额:使用集分宝支付的金额
    let refundFee = req.body.refund_fee;//总退款金额:退款通知中，返回总退款金额，单位为元，支持两位小数
    let subject = req.body.subject;//订单标题:商品的标题/交易标题/订单标题/订单关键字等，是请求时对应的参数，原样通知回来
    let body = req.body.body;//商品描述:该订单的备注、描述、明细等。对应请求时的body参数，原样通知回来
    let gmtCreate = req.body.gmt_create;//交易创建时间:该笔交易创建的时间。格式为yyyy-MM-dd HH:mm:ss
    let gmtPayment = req.body.gmt_payment;//交易付款时间:该笔交易的买家付款时间。格式为yyyy-MM-dd HH:mm:ss
    let gmtRefund = req.body.gmt_refund;//交易退款时间:该笔交易的退款时间。格式为yyyy-MM-dd HH:mm:ss.S
    let gmtClose = req.body.gmt_close;//交易结束时间:该笔交易结束时间。格式为yyyy-MM-dd HH:mm:ss
    let fundBillList = req.body.fund_bill_list;//支付金额信息:支付成功的各个渠道金额信息，详见&lt;a href="#zijin" class="bi-link"&gt;资金明细信息说明&lt;/a&gt;
    let passbackParams = req.body.passback_params;//回传参数:公共回传参数，如果请求时传递了该参数，则返回给商户时会在异步通知时将该参数原样返回。本参数必须进行UrlEncode之后才可以发送给支付宝
    let voucherDetailList = req.body.voucher_detail_list;//优惠券信息:本交易支付时所使用的所有优惠券信息，详见&lt;a href="#youhui" class="bi-link"&gt;优惠券信息说明&lt;/a&gt;

    let payHelper = new AliPayHelper(DefineProto.AliAccountType.AAT_REMIND);
    let isSuccess = payHelper.verifySign(req.body);
    if (isSuccess) {
        if (tradeStatus === 'TRADE_FINISHED') {//交易状态TRADE_FINISHED的通知触发条件是商户签约的产品不支持退款功能的前提下，买家付款成功；或者，商户签约的产品支持退款功能的前提下，交易已经成功并且已经超过可退款期限。

        } else if (tradeStatus === 'TRADE_SUCCESS') {//状态TRADE_SUCCESS的通知触发条件是商户签约的产品支持退款功能的前提下，买家付款成功

        } else if (tradeStatus === 'WAIT_BUYER_PAY') {

        } else if (tradeStatus === 'TRADE_CLOSED') {

        }
        res.send('success');
    } else {
        res.send('fail');
    }
};</code></pre>
  <p>可以看到上面验签的核心代码就是<strong>payHelper.verifySign(req.body)</strong>，我们来具体看看支付是要求我们如何验签的，参考文档：<a href="https://docs.open.alipay.com/204/105301/" rel="nofollow">https://docs.open.alipay.com/204/105301/</a></p>
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180308222421147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p>
  <p>很多操作都和签名的时候类似，唯一需要注意的是：验签的时候<strong><span style="color:#ff0000;">用的是支付宝的公钥而不是应用的公钥</span></strong></p>
  <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180308222747273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="">
  <br>
  <p><strong>需要注意的是我们将公钥存储在文件中的时候，需要在第一行和最后一行分别加上一行，否则会报错</strong><br></p>
  <p><strong><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180308232245349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmp3ZWl5dWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></strong></p>
  <p>贴上具体的验签代码：</p>
  <pre><code class="language-javascript">/**
 * 验证支付宝异步通知的合法性
 * @param params  支付宝异步通知结果的参数
 * @returns {*}
 */
verifySign(params) {
    try {
        let sign = params['sign'];//签名
        let signType = params['sign_type'];//签名类型
        let paramsMap = new Map();
        for (let key in params) {
            paramsMap.set(key, params[key]);
        }
        let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== 'sign' &amp;&amp; k1 !== 'sign_type' &amp;&amp; v1);
        //2.按照字符的键值ASCII码递增排序
        paramsList.sort();
        //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来
        let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${decodeURIComponent(v)}`).join('&amp;');
        let publicKey = fs.readFileSync(this.accountSettings.ALI_PUBLIC_KEY_PATH, 'utf8');
        return this._verifyWithPublicKey(signType, sign, paramsString, publicKey);
    } catch (e) {
        console.error(e);
        return false;
    }
}

/**
 * 验证签名
 * @param signType      返回参数的签名类型：RSA2或RSA
 * @param sign          返回参数的签名
 * @param content       参数组成的待验签串
 * @param publicKey     支付宝公钥
 * @returns {*}         是否验证成功
 * @private
 */
_verifyWithPublicKey(signType, sign, content, publicKey) {
    try {
        let verify;
        if (signType.toUpperCase() === 'RSA2') {
            verify = crypto.createVerify('RSA-SHA256');
        } else if (signType.toUpperCase() === 'RSA') {
            verify = crypto.createVerify('RSA-SHA1');
        } else {
            throw new Error('未知signType：' + signType);
        }
        verify.update(content);
        return verify.verify(publicKey, sign, 'base64')
    } catch (err) {
        console.error(err);
        return false;
    }
}</code></pre>
  <p><br></p>
  <p><br></p>
  <h2>到这里我们的三大块已经介绍完成啦，贴上完整的代码：</h2>
  <pre><code class="language-javascript">const path = require('path');
const fs = require('fs');
const moment = require('moment');
const crypto = require('crypto');

let ALI_PAY_SETTINGS = {
    APP_ID: '2016091100487933',
    APP_GATEWAY_URL: 'xxxxxxx',//用于接收支付宝异步通知
    AUTH_REDIRECT_URL: 'xxxxxxx',//第三方授权或用户信息授权后回调地址。授权链接中配置的redirect_uri的值必须与此值保持一致。
    APP_PRIVATE_KEY_PATH: path.join(__dirname, 'pem', 'remind', 'sandbox', 'app-private.pem'),//应用私钥
    APP_PUBLIC_KEY_PATH: path.join(__dirname, 'pem', 'remind', 'sandbox', 'app-public.pem'),//应用公钥
    ALI_PUBLIC_KEY_PATH: path.join(__dirname, 'pem', 'remind', 'sandbox', 'ali-public.pem'),//阿里公钥
    AES_PATH: path.join(__dirname, 'pem', 'remind', 'sandbox', 'aes.txt'),//aes加密（暂未使用）
};


class AliPayHelper {

    /**
     * 构造方法
     * @param accountType   用于以后区分多支付账号
     */
    constructor(accountType) {
        this.accountType = accountType;
        this.accountSettings = ALI_PAY_SETTINGS;
    }

    /**
     * 构建app支付需要的参数
     * @param subject       商品名称
     * @param outTradeNo    自己公司的订单号
     * @param totalAmount   金额
     * @returns {string}
     */
    buildParams(subject, outTradeNo, totalAmount) {
        let params = new Map();
        params.set('app_id', this.accountSettings.APP_ID);
        params.set('method', 'alipay.trade.app.pay');
        params.set('charset', 'utf-8');
        params.set('sign_type', 'RSA2');
        params.set('timestamp', moment().format('YYYY-MM-DD HH:mm:ss'));
        params.set('version', '1.0');
        params.set('notify_url', this.accountSettings.APP_GATEWAY_URL);
        params.set('biz_content', this._buildBizContent(subject, outTradeNo, totalAmount));
        params.set('sign', this._buildSign(params));

        return [...params].map(([k, v]) =&gt; `${k}=${encodeURIComponent(v)}`).join('&amp;');
    }

    /**
     * 根据参数构建签名
     * @param paramsMap    Map对象
     * @returns {number|PromiseLike&lt;ArrayBuffer&gt;}
     * @private
     */
    _buildSign(paramsMap) {
        //1.获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign字段，剔除值为空的参数
        let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== 'sign' &amp;&amp; v1);
        //2.按照字符的键值ASCII码递增排序
        paramsList.sort();
        //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来
        let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${v}`).join('&amp;');

        let privateKey = fs.readFileSync(this.accountSettings.APP_PRIVATE_KEY_PATH, 'utf8');
        let signType = paramsMap.get('sign_type');
        return this._signWithPrivateKey(signType, paramsString, privateKey);
    }

    /**
     * 通过私钥给字符串签名
     * @param signType      返回参数的签名类型：RSA2或RSA
     * @param content       需要加密的字符串
     * @param privateKey    私钥
     * @returns {number | PromiseLike&lt;ArrayBuffer&gt;}
     * @private
     */
    _signWithPrivateKey(signType, content, privateKey) {
        let sign;
        if (signType.toUpperCase() === 'RSA2') {
            sign = crypto.createSign("RSA-SHA256");
        } else if (signType.toUpperCase() === 'RSA') {
            sign = crypto.createSign("RSA-SHA1");
        } else {
            throw new Error('请传入正确的签名方式，signType：' + signType);
        }
        sign.update(content);
        return sign.sign(privateKey, 'base64');
    }

    /**
     * 生成业务请求参数的集合
     * @param subject       商品的标题/交易标题/订单标题/订单关键字等。
     * @param outTradeNo    商户网站唯一订单号
     * @param totalAmount   订单总金额，单位为元，精确到小数点后两位，取值范围[0.01,100000000]
     * @returns {string}    json字符串
     * @private
     */
    _buildBizContent(subject, outTradeNo, totalAmount) {
        let bizContent = {
            subject: subject,
            out_trade_no: outTradeNo,
            total_amount: totalAmount,
            product_code: 'QUICK_MSECURITY_PAY',
        };

        return JSON.stringify(bizContent);
    }

    /**
     * 验证支付宝异步通知的合法性
     * @param params  支付宝异步通知结果的参数
     * @returns {*}
     */
    verifySign(params) {
        try {
            let sign = params['sign'];//签名
            let signType = params['sign_type'];//签名类型
            let paramsMap = new Map();
            for (let key in params) {
                paramsMap.set(key, params[key]);
            }
            let paramsList = [...paramsMap].filter(([k1, v1]) =&gt; k1 !== 'sign' &amp;&amp; k1 !== 'sign_type' &amp;&amp; v1);
            //2.按照字符的键值ASCII码递增排序
            paramsList.sort();
            //3.组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来
            let paramsString = paramsList.map(([k, v]) =&gt; `${k}=${decodeURIComponent(v)}`).join('&amp;');
            let publicKey = fs.readFileSync(this.accountSettings.ALI_PUBLIC_KEY_PATH, 'utf8');
            return this._verifyWithPublicKey(signType, sign, paramsString, publicKey);
        } catch (e) {
            console.error(e);
            return false;
        }
    }

    /**
     * 验证签名
     * @param signType      返回参数的签名类型：RSA2或RSA
     * @param sign          返回参数的签名
     * @param content       参数组成的待验签串
     * @param publicKey     支付宝公钥
     * @returns {*}         是否验证成功
     * @private
     */
    _verifyWithPublicKey(signType, sign, content, publicKey) {
        try {
            let verify;
            if (signType.toUpperCase() === 'RSA2') {
                verify = crypto.createVerify('RSA-SHA256');
            } else if (signType.toUpperCase() === 'RSA') {
                verify = crypto.createVerify('RSA-SHA1');
            } else {
                throw new Error('未知signType：' + signType);
            }
            verify.update(content);
            return verify.verify(publicKey, sign, 'base64')
        } catch (err) {
            console.error(err);
            return false;
        }
    }

}

module.exports = AliPayHelper;</code></pre>如果有写的不对的地方麻烦在评论中指出，如果有疑问也欢迎提问哦~
  <br>
  <p></p>
  <p><br></p>
  <p><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/njweiyukun/article/details/79478455,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/njweiyukun/article/details/79478455,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
