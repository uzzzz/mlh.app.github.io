<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>基于Java语言构建区块链（二）—— 工作量证明 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="基于Java语言构建区块链（二）—— 工作量证明" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="引言 在&nbsp;上一篇&nbsp;文章中，我们实现了区块链最基本的数据结构模型，添加区块以及和前一个区块连接在一起。但是，我们的实现方式非常简单，而真实的比特币区块链中，每一个区块的添加都是需要经过大量的计算才可以完成，这个过程就是我们熟知的挖矿。 工作量证明机制 区块链最关键的一个思想就是，必须进行大量且困难的计算工作才能将交易数据存放到区块链上。这种工作机制才能保证整个区块链数据的安全性和一致性。同时，完成这个计算工作的矿工会得到相应的Token奖励。 这套机制和我们的现实生活非常相似：我们必须努力工作来赚取报酬用以维持我们的生活。在区块链中，网络中的矿工们努力工作来维持区块链网络，为其添加区块，并且获得一定的Token奖励。作为他们工作的成果，一个区块以安全的方式被组合进了区块链中，这样就保证了整个区块链数据库的稳定性。还有一个必须要注意的是，某个矿工完成了计算工作的结果，还必须得到其他所有矿工的认同（证明是正确的），这样才算完成。 这一整套的计算和证明机制，就称为Proof-of-Work（工作量证明）。计算工作是非常非常困难的，因为它需要消耗大量的计算机算力资源，即使是性能非常高的计算机都不能非常快地计算出正确的结果。此外，随着时间的推移，这项计算工作的难度也会随之增加，目的是为了保证每小时6个新区块的出块率。在比特币中，这种工作的目标是找到满足某个特定要求的区块Hash（哈希值）。这个区块哈希值就是工作结果的一个证明。因此，计算工作的目的就是为了寻找到这个证明值。 最后要注意的是，计算出这个特定的Hash（哈希值）是非常困难的，但是别人来验证这个Hash值是否正确的时候，是非常简单的，一下子就能完成。 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ Hashing Hash：哈希 | 散列 我们来讨论一下Hashing（哈希），对这一块非常熟悉的朋友可以直接跳过这一段内容。 哈希是一种计算机算法，该算法能够计算出任意大小数据的哈希值，并且这个哈希值的长度是固定的，256bit。这个被计算出来的哈希值能够作为这个数据的唯一代表。哈希算法有几个关键的特性： 不可逆性。不能根据一个哈希值推导出原始数据。所以，哈希不是加密。 唯一性。每个数据有且仅有一个唯一的哈希值。 迥异性。原始数据一丁点的变化都将得到完全不一样的哈希值。 例如： SHA256(&quot;wangwei1&quot;) ——&gt; 1e898b7c9adaad86c20139a302ccd5277f81040cab68dc2aecfc684773532652 SHA256(&quot;wangwei2&quot;) ——&gt; c9cc7417c17318c8aab448cc8ace24c53b6dcf350f5c5fd8e91cbc3b011a179d 哈希算法被广泛用于验证文件的一致性上。比如软件提供商通常会在安装包上附加一个检验码（checksums），当我们下载完一个软件安装包后，可以用哈希函数计算一下这个软件安装包的哈希值，然后再和软件安装包的检验码做个对比，就可以知道下载的安装包是否完整、是否有数据丢失。 在区块链中，哈希值用于保证区块的一致性。每一个区块被用于进行哈希计算的数据，都包含前一个区块链的哈希值，因此任何人想要修改区块的数据几乎是不可能的，他必须要把整个区块链中从创世区块到最新的区块的所有哈希值全部重新计算一遍。 你可以脑补一下这个工作量有多大，按照目前计算机的算力来看，几乎不可能 Hashcash 比特币的工作量证明是使用的是Hashcash算法，一种最初被用于反垃圾邮件的算法，它可以被拆解为以下几步： 获取某种公开可知的数据data（在邮件案例中，指的是收件人邮件地址；比特币案例中，指的是区块头） 添加一个计数器counter，初始值设置为0； 计算 data 与 counter拼接字符串的哈希值； 检查上一步的哈希值是否满足某个条件，满足则停止计算，不满足则 counter 加1，然后重复第3步和第4步，直到满足这个特定的条件为止。 这是一种粗暴的算法：你改变计数器，计算一个新的哈希值，检查它，增加计数器，计算一个新的哈希值，循环往复，这就是为什么它需要花费大量计算机算力资源的原因所在。 让我们来近距离看一下这个特定的条件指的是什么。在原始的Hashcash算法中，这个特殊的要求指的是计算出来的哈希值的前20bit必须全是零， 在比特币种，这种要求哈希值前面有多少个零打头的要求是随着时间的推移而不断调整的，这是出于设计的目的，尽管在计算机的算力会不断的提升和越来越多的矿工加入这个网络中的情况下，都要保证每10min生产一个区块。 我们演示一下这个算法， # 计算字符串&#39;I like donuts&#39;的哈希值 SHA256(&quot;I like donuts&quot;) ——&gt; f80867f6efd4484c23b0e7184e53fe4af6ab49b97f5293fcd50d5b2bfa73a4d0 # 拼接一个计数器值(ca07ca)，再次进行Hash计算 SHA256(&quot;I like donutsca07ca&quot;) ——&gt; 0000002f7c1fe31cb82acdc082cfec47620b7e4ab94f2bf9e096c436fc8cee06 这里的ca07ca是计数器值的十六进制，他表示的十进制值为13240266 即，从0开始，总共计算了13240266次，才计算出 I like donuts这个数据的Hash值，满足前6位(3字节)全是零。 代码实现 思路： 1）每次区块被添加到区块链之前，先要进行挖矿（Pow） 2）挖矿过程中，产生的 Hash 值，如果小于难度目标值则添加进区块，否则继续挖矿，直到找到正确的Hash为止 3）最后，验证区块Hash是否有效 定义Pow类 /** * 工作量证明 * * @author wangwei * @date 2018/02/04 */ @Data public class ProofOfWork { /** * 难度目标位 */ public static final int TARGET_BITS = 20; /** * 区块 */ private Block block; /** * 难度目标值 */ private BigInteger target; private ProofOfWork(Block block, BigInteger target) { this.block = block; this.target = target; } /** * 创建新的工作量证明，设定难度目标值 * &lt;p&gt; * 对1进行移位运算，将1向左移动 (256 - TARGET_BITS) 位，得到我们的难度目标值 * * @param block * @return */ public static ProofOfWork newProofOfWork(Block block) { BigInteger targetValue = BigInteger.valueOf(1).shiftLeft((256 - TARGET_BITS)); return new ProofOfWork(block, targetValue); } } 设定一个难度目标位TARGET_BITS，表示最终挖矿挖出来Hash值，转化为二进制后，与256相比，长度少了多少bit，也即二进制前面有多少bit是零. TARGET_BITS&nbsp;越大，最终targetValue就越小，要求计算出来的Hash越来越小，也就是挖矿的难度越来越大。 我们这里的TARGET_BITS是固定的，但是在真实的比特币中，难度目标是随着时间的推推，会动态调整的。详见：《精通比特币 （第二版）》第10章 由于数值比较大，这里要使用BitInteger类型。 准备数据 /** * 准备数据 * &lt;p&gt; * 注意：在准备区块数据时，一定要从原始数据类型转化为byte[]，不能直接从字符串进行转换 * @param nonce * @return */ private String prepareData(long nonce) { byte[] prevBlockHashBytes = {}; if (StringUtils.isNoneBlank(this.getBlock().getPrevBlockHash())) { prevBlockHashBytes = new BigInteger(this.getBlock().getPrevBlockHash(), 16).toByteArray(); } return ByteUtils.merge( prevBlockHashBytes, this.getBlock().getData().getBytes(), ByteUtils.toBytes(this.getBlock().getTimeStamp()), ByteUtils.toBytes(TARGET_BITS), ByteUtils.toBytes(nonce) ); } 参与Hash运算的如下几个信息： 前一个区块（父区块）的Hash值； 区块中的交易数据； 区块生成的时间； 难度目标； 用于工作量证明算法的计数器 详见： 《精通比特币 （第二版）》第09章 Pow算法 /** * 运行工作量证明，开始挖矿，找到小于难度目标值的Hash * * @return */ public PowResult run() { long nonce = 0; String shaHex = &quot;&quot;; System.out.printf(&quot;Mining the block containing：%s \n&quot;, this.getBlock().getData()); long startTime = System.currentTimeMillis(); while (nonce &lt; Long.MAX_VALUE) { String data = this.prepareData(nonce); shaHex = DigestUtils.sha256Hex(data); if (new BigInteger(shaHex, 16).compareTo(this.target) == -1) { System.out.printf(&quot;Elapsed Time: %s seconds \n&quot;, (float) (System.currentTimeMillis() - startTime) / 1000); System.out.printf(&quot;correct hash Hex: %s \n\n&quot;, shaHex); break; } else { nonce++; } } return new PowResult(nonce, shaHex); } 循环体里面主要以下四步： 准备数据 进行sha256运算 转化为BigInter类型 与target进行比较 最后，返回正确的Hash值以及运算计数器nonce 验证区块Hash有效性 /** * 验证区块是否有效 * * @return */ public boolean validate() { String data = this.prepareData(this.getBlock().getNonce()); return new BigInteger(DigestUtils.sha256Hex(data), 16).compareTo(this.target) == -1; } 修改区块添加逻辑 /** * &lt;p&gt; 创建新区块 &lt;/p&gt; * * @param previousHash * @param data * @return */ public static Block newBlock(String previousHash, String data) { Block block = new Block(&quot;&quot;, previousHash, data, Instant.now().getEpochSecond(), 0); ProofOfWork pow = ProofOfWork.newProofOfWork(block); PowResult powResult = pow.run(); block.setHash(powResult.getHash()); block.setNonce(powResult.getNonce()); return block; } 创建区块 创建Pow算法对象 执行Pow算法 保存返回的Hash以及运算计数器 测试运行 /** * 测试 * * @author wangwei * @date 2018/02/05 */ public class BlockchainTest { public static void main(String[] args) { Blockchain blockchain = Blockchain.newBlockchain(); blockchain.addBlock(&quot;Send 1 BTC to Ivan&quot;); blockchain.addBlock(&quot;Send 2 more BTC to Ivan&quot;); for (Block block : blockchain.getBlockList()) { System.out.println(&quot;Prev.hash: &quot; + block.getPrevBlockHash()); System.out.println(&quot;Data: &quot; + block.getData()); System.out.println(&quot;Hash: &quot; + block.getHash()); System.out.println(&quot;Nonce: &quot; + block.getNonce()); ProofOfWork pow = ProofOfWork.newProofOfWork(block); System.out.println(&quot;Pow valid: &quot; + pow.validate() + &quot;\n&quot;); } } } /** * 设定TARGET_BITS = 20，得到如下结果： */ Mining the block containing：Genesis Block Elapsed Time: 2.118 seconds correct hash Hex: 00000828ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442 Mining the block containing：Send 1 BTC to Ivan Elapsed Time: 1.069 seconds correct hash Hex: 00000a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5 Mining the block containing：Send 2 more BTC to Ivan Elapsed Time: 4.258 seconds correct hash Hex: 00000777f93efe91d9aabcba14ab3d8ab8e0255b89818cdb9b93cfa844ad0c7f Prev.hash: Data: Genesis Block Hash: 00000828ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442 Nonce: 522163 Pow valid: true Prev.hash: 00000828ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442 Data: Send 1 BTC to Ivan Hash: 00000a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5 Nonce: 474758 Pow valid: true Prev.hash: 00000a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5 Data: Send 2 more BTC to Ivan Hash: 00000777f93efe91d9aabcba14ab3d8ab8e0255b89818cdb9b93cfa844ad0c7f Nonce: 1853839 Pow valid: true 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ 总结 我们正在一步一步接近真实的区块链架构，本篇我们实现了挖矿机制，但是我们还有很多关键性的功能没有实现：区块链数据库的持久性、钱包、地址、交易、共识机制，这些我们后面一步一步来实现 文章出处： https://wangwei.one/ &nbsp;转载 ！ 阅读更多" />
<meta property="og:description" content="引言 在&nbsp;上一篇&nbsp;文章中，我们实现了区块链最基本的数据结构模型，添加区块以及和前一个区块连接在一起。但是，我们的实现方式非常简单，而真实的比特币区块链中，每一个区块的添加都是需要经过大量的计算才可以完成，这个过程就是我们熟知的挖矿。 工作量证明机制 区块链最关键的一个思想就是，必须进行大量且困难的计算工作才能将交易数据存放到区块链上。这种工作机制才能保证整个区块链数据的安全性和一致性。同时，完成这个计算工作的矿工会得到相应的Token奖励。 这套机制和我们的现实生活非常相似：我们必须努力工作来赚取报酬用以维持我们的生活。在区块链中，网络中的矿工们努力工作来维持区块链网络，为其添加区块，并且获得一定的Token奖励。作为他们工作的成果，一个区块以安全的方式被组合进了区块链中，这样就保证了整个区块链数据库的稳定性。还有一个必须要注意的是，某个矿工完成了计算工作的结果，还必须得到其他所有矿工的认同（证明是正确的），这样才算完成。 这一整套的计算和证明机制，就称为Proof-of-Work（工作量证明）。计算工作是非常非常困难的，因为它需要消耗大量的计算机算力资源，即使是性能非常高的计算机都不能非常快地计算出正确的结果。此外，随着时间的推移，这项计算工作的难度也会随之增加，目的是为了保证每小时6个新区块的出块率。在比特币中，这种工作的目标是找到满足某个特定要求的区块Hash（哈希值）。这个区块哈希值就是工作结果的一个证明。因此，计算工作的目的就是为了寻找到这个证明值。 最后要注意的是，计算出这个特定的Hash（哈希值）是非常困难的，但是别人来验证这个Hash值是否正确的时候，是非常简单的，一下子就能完成。 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ Hashing Hash：哈希 | 散列 我们来讨论一下Hashing（哈希），对这一块非常熟悉的朋友可以直接跳过这一段内容。 哈希是一种计算机算法，该算法能够计算出任意大小数据的哈希值，并且这个哈希值的长度是固定的，256bit。这个被计算出来的哈希值能够作为这个数据的唯一代表。哈希算法有几个关键的特性： 不可逆性。不能根据一个哈希值推导出原始数据。所以，哈希不是加密。 唯一性。每个数据有且仅有一个唯一的哈希值。 迥异性。原始数据一丁点的变化都将得到完全不一样的哈希值。 例如： SHA256(&quot;wangwei1&quot;) ——&gt; 1e898b7c9adaad86c20139a302ccd5277f81040cab68dc2aecfc684773532652 SHA256(&quot;wangwei2&quot;) ——&gt; c9cc7417c17318c8aab448cc8ace24c53b6dcf350f5c5fd8e91cbc3b011a179d 哈希算法被广泛用于验证文件的一致性上。比如软件提供商通常会在安装包上附加一个检验码（checksums），当我们下载完一个软件安装包后，可以用哈希函数计算一下这个软件安装包的哈希值，然后再和软件安装包的检验码做个对比，就可以知道下载的安装包是否完整、是否有数据丢失。 在区块链中，哈希值用于保证区块的一致性。每一个区块被用于进行哈希计算的数据，都包含前一个区块链的哈希值，因此任何人想要修改区块的数据几乎是不可能的，他必须要把整个区块链中从创世区块到最新的区块的所有哈希值全部重新计算一遍。 你可以脑补一下这个工作量有多大，按照目前计算机的算力来看，几乎不可能 Hashcash 比特币的工作量证明是使用的是Hashcash算法，一种最初被用于反垃圾邮件的算法，它可以被拆解为以下几步： 获取某种公开可知的数据data（在邮件案例中，指的是收件人邮件地址；比特币案例中，指的是区块头） 添加一个计数器counter，初始值设置为0； 计算 data 与 counter拼接字符串的哈希值； 检查上一步的哈希值是否满足某个条件，满足则停止计算，不满足则 counter 加1，然后重复第3步和第4步，直到满足这个特定的条件为止。 这是一种粗暴的算法：你改变计数器，计算一个新的哈希值，检查它，增加计数器，计算一个新的哈希值，循环往复，这就是为什么它需要花费大量计算机算力资源的原因所在。 让我们来近距离看一下这个特定的条件指的是什么。在原始的Hashcash算法中，这个特殊的要求指的是计算出来的哈希值的前20bit必须全是零， 在比特币种，这种要求哈希值前面有多少个零打头的要求是随着时间的推移而不断调整的，这是出于设计的目的，尽管在计算机的算力会不断的提升和越来越多的矿工加入这个网络中的情况下，都要保证每10min生产一个区块。 我们演示一下这个算法， # 计算字符串&#39;I like donuts&#39;的哈希值 SHA256(&quot;I like donuts&quot;) ——&gt; f80867f6efd4484c23b0e7184e53fe4af6ab49b97f5293fcd50d5b2bfa73a4d0 # 拼接一个计数器值(ca07ca)，再次进行Hash计算 SHA256(&quot;I like donutsca07ca&quot;) ——&gt; 0000002f7c1fe31cb82acdc082cfec47620b7e4ab94f2bf9e096c436fc8cee06 这里的ca07ca是计数器值的十六进制，他表示的十进制值为13240266 即，从0开始，总共计算了13240266次，才计算出 I like donuts这个数据的Hash值，满足前6位(3字节)全是零。 代码实现 思路： 1）每次区块被添加到区块链之前，先要进行挖矿（Pow） 2）挖矿过程中，产生的 Hash 值，如果小于难度目标值则添加进区块，否则继续挖矿，直到找到正确的Hash为止 3）最后，验证区块Hash是否有效 定义Pow类 /** * 工作量证明 * * @author wangwei * @date 2018/02/04 */ @Data public class ProofOfWork { /** * 难度目标位 */ public static final int TARGET_BITS = 20; /** * 区块 */ private Block block; /** * 难度目标值 */ private BigInteger target; private ProofOfWork(Block block, BigInteger target) { this.block = block; this.target = target; } /** * 创建新的工作量证明，设定难度目标值 * &lt;p&gt; * 对1进行移位运算，将1向左移动 (256 - TARGET_BITS) 位，得到我们的难度目标值 * * @param block * @return */ public static ProofOfWork newProofOfWork(Block block) { BigInteger targetValue = BigInteger.valueOf(1).shiftLeft((256 - TARGET_BITS)); return new ProofOfWork(block, targetValue); } } 设定一个难度目标位TARGET_BITS，表示最终挖矿挖出来Hash值，转化为二进制后，与256相比，长度少了多少bit，也即二进制前面有多少bit是零. TARGET_BITS&nbsp;越大，最终targetValue就越小，要求计算出来的Hash越来越小，也就是挖矿的难度越来越大。 我们这里的TARGET_BITS是固定的，但是在真实的比特币中，难度目标是随着时间的推推，会动态调整的。详见：《精通比特币 （第二版）》第10章 由于数值比较大，这里要使用BitInteger类型。 准备数据 /** * 准备数据 * &lt;p&gt; * 注意：在准备区块数据时，一定要从原始数据类型转化为byte[]，不能直接从字符串进行转换 * @param nonce * @return */ private String prepareData(long nonce) { byte[] prevBlockHashBytes = {}; if (StringUtils.isNoneBlank(this.getBlock().getPrevBlockHash())) { prevBlockHashBytes = new BigInteger(this.getBlock().getPrevBlockHash(), 16).toByteArray(); } return ByteUtils.merge( prevBlockHashBytes, this.getBlock().getData().getBytes(), ByteUtils.toBytes(this.getBlock().getTimeStamp()), ByteUtils.toBytes(TARGET_BITS), ByteUtils.toBytes(nonce) ); } 参与Hash运算的如下几个信息： 前一个区块（父区块）的Hash值； 区块中的交易数据； 区块生成的时间； 难度目标； 用于工作量证明算法的计数器 详见： 《精通比特币 （第二版）》第09章 Pow算法 /** * 运行工作量证明，开始挖矿，找到小于难度目标值的Hash * * @return */ public PowResult run() { long nonce = 0; String shaHex = &quot;&quot;; System.out.printf(&quot;Mining the block containing：%s \n&quot;, this.getBlock().getData()); long startTime = System.currentTimeMillis(); while (nonce &lt; Long.MAX_VALUE) { String data = this.prepareData(nonce); shaHex = DigestUtils.sha256Hex(data); if (new BigInteger(shaHex, 16).compareTo(this.target) == -1) { System.out.printf(&quot;Elapsed Time: %s seconds \n&quot;, (float) (System.currentTimeMillis() - startTime) / 1000); System.out.printf(&quot;correct hash Hex: %s \n\n&quot;, shaHex); break; } else { nonce++; } } return new PowResult(nonce, shaHex); } 循环体里面主要以下四步： 准备数据 进行sha256运算 转化为BigInter类型 与target进行比较 最后，返回正确的Hash值以及运算计数器nonce 验证区块Hash有效性 /** * 验证区块是否有效 * * @return */ public boolean validate() { String data = this.prepareData(this.getBlock().getNonce()); return new BigInteger(DigestUtils.sha256Hex(data), 16).compareTo(this.target) == -1; } 修改区块添加逻辑 /** * &lt;p&gt; 创建新区块 &lt;/p&gt; * * @param previousHash * @param data * @return */ public static Block newBlock(String previousHash, String data) { Block block = new Block(&quot;&quot;, previousHash, data, Instant.now().getEpochSecond(), 0); ProofOfWork pow = ProofOfWork.newProofOfWork(block); PowResult powResult = pow.run(); block.setHash(powResult.getHash()); block.setNonce(powResult.getNonce()); return block; } 创建区块 创建Pow算法对象 执行Pow算法 保存返回的Hash以及运算计数器 测试运行 /** * 测试 * * @author wangwei * @date 2018/02/05 */ public class BlockchainTest { public static void main(String[] args) { Blockchain blockchain = Blockchain.newBlockchain(); blockchain.addBlock(&quot;Send 1 BTC to Ivan&quot;); blockchain.addBlock(&quot;Send 2 more BTC to Ivan&quot;); for (Block block : blockchain.getBlockList()) { System.out.println(&quot;Prev.hash: &quot; + block.getPrevBlockHash()); System.out.println(&quot;Data: &quot; + block.getData()); System.out.println(&quot;Hash: &quot; + block.getHash()); System.out.println(&quot;Nonce: &quot; + block.getNonce()); ProofOfWork pow = ProofOfWork.newProofOfWork(block); System.out.println(&quot;Pow valid: &quot; + pow.validate() + &quot;\n&quot;); } } } /** * 设定TARGET_BITS = 20，得到如下结果： */ Mining the block containing：Genesis Block Elapsed Time: 2.118 seconds correct hash Hex: 00000828ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442 Mining the block containing：Send 1 BTC to Ivan Elapsed Time: 1.069 seconds correct hash Hex: 00000a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5 Mining the block containing：Send 2 more BTC to Ivan Elapsed Time: 4.258 seconds correct hash Hex: 00000777f93efe91d9aabcba14ab3d8ab8e0255b89818cdb9b93cfa844ad0c7f Prev.hash: Data: Genesis Block Hash: 00000828ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442 Nonce: 522163 Pow valid: true Prev.hash: 00000828ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442 Data: Send 1 BTC to Ivan Hash: 00000a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5 Nonce: 474758 Pow valid: true Prev.hash: 00000a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5 Data: Send 2 more BTC to Ivan Hash: 00000777f93efe91d9aabcba14ab3d8ab8e0255b89818cdb9b93cfa844ad0c7f Nonce: 1853839 Pow valid: true 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ 总结 我们正在一步一步接近真实的区块链架构，本篇我们实现了挖矿机制，但是我们还有很多关键性的功能没有实现：区块链数据库的持久性、钱包、地址、交易、共识机制，这些我们后面一步一步来实现 文章出处： https://wangwei.one/ &nbsp;转载 ！ 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/25/936fa33078f2aa25768ed16093add150.html" />
<meta property="og:url" content="https://mlh.app/2018/03/25/936fa33078f2aa25768ed16093add150.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-25T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"引言 在&nbsp;上一篇&nbsp;文章中，我们实现了区块链最基本的数据结构模型，添加区块以及和前一个区块连接在一起。但是，我们的实现方式非常简单，而真实的比特币区块链中，每一个区块的添加都是需要经过大量的计算才可以完成，这个过程就是我们熟知的挖矿。 工作量证明机制 区块链最关键的一个思想就是，必须进行大量且困难的计算工作才能将交易数据存放到区块链上。这种工作机制才能保证整个区块链数据的安全性和一致性。同时，完成这个计算工作的矿工会得到相应的Token奖励。 这套机制和我们的现实生活非常相似：我们必须努力工作来赚取报酬用以维持我们的生活。在区块链中，网络中的矿工们努力工作来维持区块链网络，为其添加区块，并且获得一定的Token奖励。作为他们工作的成果，一个区块以安全的方式被组合进了区块链中，这样就保证了整个区块链数据库的稳定性。还有一个必须要注意的是，某个矿工完成了计算工作的结果，还必须得到其他所有矿工的认同（证明是正确的），这样才算完成。 这一整套的计算和证明机制，就称为Proof-of-Work（工作量证明）。计算工作是非常非常困难的，因为它需要消耗大量的计算机算力资源，即使是性能非常高的计算机都不能非常快地计算出正确的结果。此外，随着时间的推移，这项计算工作的难度也会随之增加，目的是为了保证每小时6个新区块的出块率。在比特币中，这种工作的目标是找到满足某个特定要求的区块Hash（哈希值）。这个区块哈希值就是工作结果的一个证明。因此，计算工作的目的就是为了寻找到这个证明值。 最后要注意的是，计算出这个特定的Hash（哈希值）是非常困难的，但是别人来验证这个Hash值是否正确的时候，是非常简单的，一下子就能完成。 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ Hashing Hash：哈希 | 散列 我们来讨论一下Hashing（哈希），对这一块非常熟悉的朋友可以直接跳过这一段内容。 哈希是一种计算机算法，该算法能够计算出任意大小数据的哈希值，并且这个哈希值的长度是固定的，256bit。这个被计算出来的哈希值能够作为这个数据的唯一代表。哈希算法有几个关键的特性： 不可逆性。不能根据一个哈希值推导出原始数据。所以，哈希不是加密。 唯一性。每个数据有且仅有一个唯一的哈希值。 迥异性。原始数据一丁点的变化都将得到完全不一样的哈希值。 例如： SHA256(&quot;wangwei1&quot;) ——&gt; 1e898b7c9adaad86c20139a302ccd5277f81040cab68dc2aecfc684773532652 SHA256(&quot;wangwei2&quot;) ——&gt; c9cc7417c17318c8aab448cc8ace24c53b6dcf350f5c5fd8e91cbc3b011a179d 哈希算法被广泛用于验证文件的一致性上。比如软件提供商通常会在安装包上附加一个检验码（checksums），当我们下载完一个软件安装包后，可以用哈希函数计算一下这个软件安装包的哈希值，然后再和软件安装包的检验码做个对比，就可以知道下载的安装包是否完整、是否有数据丢失。 在区块链中，哈希值用于保证区块的一致性。每一个区块被用于进行哈希计算的数据，都包含前一个区块链的哈希值，因此任何人想要修改区块的数据几乎是不可能的，他必须要把整个区块链中从创世区块到最新的区块的所有哈希值全部重新计算一遍。 你可以脑补一下这个工作量有多大，按照目前计算机的算力来看，几乎不可能 Hashcash 比特币的工作量证明是使用的是Hashcash算法，一种最初被用于反垃圾邮件的算法，它可以被拆解为以下几步： 获取某种公开可知的数据data（在邮件案例中，指的是收件人邮件地址；比特币案例中，指的是区块头） 添加一个计数器counter，初始值设置为0； 计算 data 与 counter拼接字符串的哈希值； 检查上一步的哈希值是否满足某个条件，满足则停止计算，不满足则 counter 加1，然后重复第3步和第4步，直到满足这个特定的条件为止。 这是一种粗暴的算法：你改变计数器，计算一个新的哈希值，检查它，增加计数器，计算一个新的哈希值，循环往复，这就是为什么它需要花费大量计算机算力资源的原因所在。 让我们来近距离看一下这个特定的条件指的是什么。在原始的Hashcash算法中，这个特殊的要求指的是计算出来的哈希值的前20bit必须全是零， 在比特币种，这种要求哈希值前面有多少个零打头的要求是随着时间的推移而不断调整的，这是出于设计的目的，尽管在计算机的算力会不断的提升和越来越多的矿工加入这个网络中的情况下，都要保证每10min生产一个区块。 我们演示一下这个算法， # 计算字符串&#39;I like donuts&#39;的哈希值 SHA256(&quot;I like donuts&quot;) ——&gt; f80867f6efd4484c23b0e7184e53fe4af6ab49b97f5293fcd50d5b2bfa73a4d0 # 拼接一个计数器值(ca07ca)，再次进行Hash计算 SHA256(&quot;I like donutsca07ca&quot;) ——&gt; 0000002f7c1fe31cb82acdc082cfec47620b7e4ab94f2bf9e096c436fc8cee06 这里的ca07ca是计数器值的十六进制，他表示的十进制值为13240266 即，从0开始，总共计算了13240266次，才计算出 I like donuts这个数据的Hash值，满足前6位(3字节)全是零。 代码实现 思路： 1）每次区块被添加到区块链之前，先要进行挖矿（Pow） 2）挖矿过程中，产生的 Hash 值，如果小于难度目标值则添加进区块，否则继续挖矿，直到找到正确的Hash为止 3）最后，验证区块Hash是否有效 定义Pow类 /** * 工作量证明 * * @author wangwei * @date 2018/02/04 */ @Data public class ProofOfWork { /** * 难度目标位 */ public static final int TARGET_BITS = 20; /** * 区块 */ private Block block; /** * 难度目标值 */ private BigInteger target; private ProofOfWork(Block block, BigInteger target) { this.block = block; this.target = target; } /** * 创建新的工作量证明，设定难度目标值 * &lt;p&gt; * 对1进行移位运算，将1向左移动 (256 - TARGET_BITS) 位，得到我们的难度目标值 * * @param block * @return */ public static ProofOfWork newProofOfWork(Block block) { BigInteger targetValue = BigInteger.valueOf(1).shiftLeft((256 - TARGET_BITS)); return new ProofOfWork(block, targetValue); } } 设定一个难度目标位TARGET_BITS，表示最终挖矿挖出来Hash值，转化为二进制后，与256相比，长度少了多少bit，也即二进制前面有多少bit是零. TARGET_BITS&nbsp;越大，最终targetValue就越小，要求计算出来的Hash越来越小，也就是挖矿的难度越来越大。 我们这里的TARGET_BITS是固定的，但是在真实的比特币中，难度目标是随着时间的推推，会动态调整的。详见：《精通比特币 （第二版）》第10章 由于数值比较大，这里要使用BitInteger类型。 准备数据 /** * 准备数据 * &lt;p&gt; * 注意：在准备区块数据时，一定要从原始数据类型转化为byte[]，不能直接从字符串进行转换 * @param nonce * @return */ private String prepareData(long nonce) { byte[] prevBlockHashBytes = {}; if (StringUtils.isNoneBlank(this.getBlock().getPrevBlockHash())) { prevBlockHashBytes = new BigInteger(this.getBlock().getPrevBlockHash(), 16).toByteArray(); } return ByteUtils.merge( prevBlockHashBytes, this.getBlock().getData().getBytes(), ByteUtils.toBytes(this.getBlock().getTimeStamp()), ByteUtils.toBytes(TARGET_BITS), ByteUtils.toBytes(nonce) ); } 参与Hash运算的如下几个信息： 前一个区块（父区块）的Hash值； 区块中的交易数据； 区块生成的时间； 难度目标； 用于工作量证明算法的计数器 详见： 《精通比特币 （第二版）》第09章 Pow算法 /** * 运行工作量证明，开始挖矿，找到小于难度目标值的Hash * * @return */ public PowResult run() { long nonce = 0; String shaHex = &quot;&quot;; System.out.printf(&quot;Mining the block containing：%s \\n&quot;, this.getBlock().getData()); long startTime = System.currentTimeMillis(); while (nonce &lt; Long.MAX_VALUE) { String data = this.prepareData(nonce); shaHex = DigestUtils.sha256Hex(data); if (new BigInteger(shaHex, 16).compareTo(this.target) == -1) { System.out.printf(&quot;Elapsed Time: %s seconds \\n&quot;, (float) (System.currentTimeMillis() - startTime) / 1000); System.out.printf(&quot;correct hash Hex: %s \\n\\n&quot;, shaHex); break; } else { nonce++; } } return new PowResult(nonce, shaHex); } 循环体里面主要以下四步： 准备数据 进行sha256运算 转化为BigInter类型 与target进行比较 最后，返回正确的Hash值以及运算计数器nonce 验证区块Hash有效性 /** * 验证区块是否有效 * * @return */ public boolean validate() { String data = this.prepareData(this.getBlock().getNonce()); return new BigInteger(DigestUtils.sha256Hex(data), 16).compareTo(this.target) == -1; } 修改区块添加逻辑 /** * &lt;p&gt; 创建新区块 &lt;/p&gt; * * @param previousHash * @param data * @return */ public static Block newBlock(String previousHash, String data) { Block block = new Block(&quot;&quot;, previousHash, data, Instant.now().getEpochSecond(), 0); ProofOfWork pow = ProofOfWork.newProofOfWork(block); PowResult powResult = pow.run(); block.setHash(powResult.getHash()); block.setNonce(powResult.getNonce()); return block; } 创建区块 创建Pow算法对象 执行Pow算法 保存返回的Hash以及运算计数器 测试运行 /** * 测试 * * @author wangwei * @date 2018/02/05 */ public class BlockchainTest { public static void main(String[] args) { Blockchain blockchain = Blockchain.newBlockchain(); blockchain.addBlock(&quot;Send 1 BTC to Ivan&quot;); blockchain.addBlock(&quot;Send 2 more BTC to Ivan&quot;); for (Block block : blockchain.getBlockList()) { System.out.println(&quot;Prev.hash: &quot; + block.getPrevBlockHash()); System.out.println(&quot;Data: &quot; + block.getData()); System.out.println(&quot;Hash: &quot; + block.getHash()); System.out.println(&quot;Nonce: &quot; + block.getNonce()); ProofOfWork pow = ProofOfWork.newProofOfWork(block); System.out.println(&quot;Pow valid: &quot; + pow.validate() + &quot;\\n&quot;); } } } /** * 设定TARGET_BITS = 20，得到如下结果： */ Mining the block containing：Genesis Block Elapsed Time: 2.118 seconds correct hash Hex: 00000828ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442 Mining the block containing：Send 1 BTC to Ivan Elapsed Time: 1.069 seconds correct hash Hex: 00000a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5 Mining the block containing：Send 2 more BTC to Ivan Elapsed Time: 4.258 seconds correct hash Hex: 00000777f93efe91d9aabcba14ab3d8ab8e0255b89818cdb9b93cfa844ad0c7f Prev.hash: Data: Genesis Block Hash: 00000828ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442 Nonce: 522163 Pow valid: true Prev.hash: 00000828ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442 Data: Send 1 BTC to Ivan Hash: 00000a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5 Nonce: 474758 Pow valid: true Prev.hash: 00000a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5 Data: Send 2 more BTC to Ivan Hash: 00000777f93efe91d9aabcba14ab3d8ab8e0255b89818cdb9b93cfa844ad0c7f Nonce: 1853839 Pow valid: true 给大家推荐一个java内部学习群：725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！ 总结 我们正在一步一步接近真实的区块链架构，本篇我们实现了挖矿机制，但是我们还有很多关键性的功能没有实现：区块链数据库的持久性、钱包、地址、交易、共识机制，这些我们后面一步一步来实现 文章出处： https://wangwei.one/ &nbsp;转载 ！ 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/25/936fa33078f2aa25768ed16093add150.html","headline":"基于Java语言构建区块链（二）—— 工作量证明","dateModified":"2018-03-25T00:00:00+08:00","datePublished":"2018-03-25T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/25/936fa33078f2aa25768ed16093add150.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>基于Java语言构建区块链（二）—— 工作量证明</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><span class="img-wrap"><span style="font-size:1.75em;"><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180325134740780" alt=""><br></span></span></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><span class="img-wrap"><span style="font-size:1.75em;">引言</span></span></p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">在&nbsp;<a href="https://wangwei.one/posts/df195d9.html" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.247059);">上一篇</a>&nbsp;文章中，我们实现了区块链最基本的数据结构模型，添加区块以及和前一个区块连接在一起。但是，我们的实现方式非常简单，而真实的比特币区块链中，每一个区块的添加都是需要经过大量的计算才可以完成，这个过程就是我们熟知的<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">挖矿</code>。</p>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">工作量证明机制</h2>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">区块链最关键的一个思想就是，必须进行大量且困难的计算工作才能将交易数据存放到区块链上。这种工作机制才能保证整个区块链数据的安全性和一致性。同时，完成这个计算工作的矿工会得到相应的Token奖励。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">这套机制和我们的现实生活非常相似：我们必须努力工作来赚取报酬用以维持我们的生活。在区块链中，网络中的矿工们努力工作来维持区块链网络，为其添加区块，并且获得一定的Token奖励。作为他们工作的成果，一个区块以安全的方式被组合进了区块链中，这样就保证了整个区块链数据库的稳定性。还有一个必须要注意的是，某个矿工完成了计算工作的结果，还必须得到其他所有矿工的认同（证明是正确的），这样才算完成。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">这一整套的计算和证明机制，就称为<strong>Proof-of-Work（工作量证明）</strong>。计算工作是非常非常困难的，因为它需要消耗大量的计算机算力资源，即使是性能非常高的计算机都不能非常快地计算出正确的结果。此外，随着时间的推移，这项计算工作的难度也会随之增加，目的是为了保证每小时6个新区块的出块率。在比特币中，这种工作的目标是找到满足某个特定要求的区块Hash（哈希值）。这个区块哈希值就是工作结果的一个证明。因此，计算工作的目的就是为了寻找到这个证明值。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">最后要注意的是，计算出这个特定的Hash（哈希值）是非常困难的，但是别人来验证这个Hash值是否正确的时候，是非常简单的，一下子就能完成。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;background-color:rgb(255,255,255);"></p>
  <p style="background:rgb(255,255,255);"><span style="font-size:14px;color:rgb(29,29,29);"><span style="font-family:'微软雅黑';">给大家推荐一个</span></span><a href="https://www.yidianzixun.com/channel/w/java" rel="nofollow" style="font-size:14px;"><span style="color:rgb(18,154,238);">java</span></a><span style="color:rgb(29,29,29);"><span style="font-size:14px;font-family:'微软雅黑';">内部学习群：</span><span style="font-size:14px;">725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！</span></span></p>
  <p style="background:rgb(255,255,255);"><span style="color:rgb(29,29,29);"><span style="font-size:18px;">H</span></span><span style="font-size:1.75em;color:rgb(51,51,51);">ashing</span></p>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   Hash：哈希 | 散列
  </blockquote>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">我们来讨论一下<strong>Hashing（哈希）</strong>，对这一块非常熟悉的朋友可以直接跳过这一段内容。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">哈希是一种计算机算法，该算法能够计算出任意大小数据的哈希值，并且这个哈希值的长度是固定的，256bit。这个被计算出来的哈希值能够作为这个数据的<strong>唯一</strong>代表。哈希算法有几个关键的特性：</p>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   <ul style="margin-left:3em;">
    <li style="margin-left:0px;"><strong>不可逆性</strong>。不能根据一个哈希值推导出原始数据。所以，哈希不是加密。</li>
    <li style="margin-left:0px;"><strong>唯一性</strong>。每个数据有且仅有一个唯一的哈希值。</li>
    <li style="margin-left:0px;"><strong>迥异性</strong>。原始数据一丁点的变化都将得到完全不一样的哈希值。</li>
   </ul>
  </blockquote>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">例如：</p>
  <pre class="hljs llvm" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;">SHA<span class="hljs-number" style="color:rgb(0,128,128);">256</span>(<span class="hljs-string" style="color:rgb(221,17,68);">"wangwei1"</span>) ——&gt; <span class="hljs-number" style="color:rgb(0,128,128);">1e898</span>b<span class="hljs-number" style="color:rgb(0,128,128);">7</span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">c</span><span class="hljs-number" style="color:rgb(0,128,128);">9</span>adaad<span class="hljs-number" style="color:rgb(0,128,128);">86</span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">c</span><span class="hljs-number" style="color:rgb(0,128,128);">20139</span>a<span class="hljs-number" style="color:rgb(0,128,128);">302</span>ccd<span class="hljs-number" style="color:rgb(0,128,128);">5277</span>f<span class="hljs-number" style="color:rgb(0,128,128);">81040</span>cab<span class="hljs-number" style="color:rgb(0,128,128);">68</span>dc<span class="hljs-number" style="color:rgb(0,128,128);">2</span>aecfc<span class="hljs-number" style="color:rgb(0,128,128);">684773532652</span>
SHA<span class="hljs-number" style="color:rgb(0,128,128);">256</span>(<span class="hljs-string" style="color:rgb(221,17,68);">"wangwei2"</span>) ——&gt; <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">c</span><span class="hljs-number" style="color:rgb(0,128,128);">9</span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">cc</span><span class="hljs-number" style="color:rgb(0,128,128);">7417</span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">c</span><span class="hljs-number" style="color:rgb(0,128,128);">17318</span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">c</span><span class="hljs-number" style="color:rgb(0,128,128);">8</span>aab<span class="hljs-number" style="color:rgb(0,128,128);">448</span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">cc</span><span class="hljs-number" style="color:rgb(0,128,128);">8</span>ace<span class="hljs-number" style="color:rgb(0,128,128);">24</span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">c</span><span class="hljs-number" style="color:rgb(0,128,128);">53</span>b<span class="hljs-number" style="color:rgb(0,128,128);">6</span>dcf<span class="hljs-number" style="color:rgb(0,128,128);">350</span>f<span class="hljs-number" style="color:rgb(0,128,128);">5</span><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">c</span><span class="hljs-number" style="color:rgb(0,128,128);">5</span>fd<span class="hljs-number" style="color:rgb(0,128,128);">8e91</span>cbc<span class="hljs-number" style="color:rgb(0,128,128);">3</span>b<span class="hljs-number" style="color:rgb(0,128,128);">011</span>a<span class="hljs-number" style="color:rgb(0,128,128);">179</span>d</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">哈希算法被广泛用于验证文件的一致性上。比如软件提供商通常会在安装包上附加一个检验码（checksums），当我们下载完一个软件安装包后，可以用哈希函数计算一下这个软件安装包的哈希值，然后再和软件安装包的检验码做个对比，就可以知道下载的安装包是否完整、是否有数据丢失。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">在区块链中，哈希值用于保证区块的一致性。每一个区块被用于进行哈希计算的数据，都包含前一个区块链的哈希值，因此任何人想要修改区块的数据几乎是不可能的，他必须要把整个区块链中从创世区块到最新的区块的所有哈希值全部重新计算一遍。</p>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   你可以脑补一下这个工作量有多大，按照目前计算机的算力来看，几乎不可能
  </blockquote>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">Hashcash</h2>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">比特币的工作量证明是使用的是<a href="https://en.wikipedia.org/wiki/Hashcash" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.247059);">Hashcash</a>算法，一种最初被用于反垃圾邮件的算法，它可以被拆解为以下几步：</p>
  <ol style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li>获取某种公开可知的数据data（在邮件案例中，指的是收件人邮件地址；比特币案例中，指的是区块头）</li>
   <li>添加一个计数器counter，初始值设置为0；</li>
   <li>计算 data 与 counter拼接字符串的哈希值；</li>
   <li>检查上一步的哈希值是否满足某个条件，满足则停止计算，不满足则 counter 加1，然后重复第3步和第4步，直到满足这个特定的条件为止。</li>
  </ol>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">这是一种粗暴的算法：你改变计数器，计算一个新的哈希值，检查它，增加计数器，计算一个新的哈希值，循环往复，这就是为什么它需要花费大量计算机算力资源的原因所在。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">让我们来近距离看一下这个特定的条件指的是什么。在原始的<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">Hashcash</code>算法中，这个特殊的要求指的是计算出来的哈希值的前20bit必须全是零，</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">在比特币种，这种要求哈希值前面有多少个零打头的要求是随着时间的推移而不断调整的，这是出于设计的目的，尽管在计算机的算力会不断的提升和越来越多的矿工加入这个网络中的情况下，都要保证每10min生产一个区块。</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">我们演示一下这个算法，</p>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="powershell" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);"># 计算字符串'I like donuts'的哈希值</span>
SHA256(<span class="hljs-string" style="color:rgb(221,17,68);">"I like donuts"</span>) 
——&gt; f80867f6efd4484c23b0e7184e53fe4af6ab49b97f5293fcd50d5b2bfa73a4d0

<span class="hljs-comment" style="color:rgb(153,153,136);"># 拼接一个计数器值(ca07ca)，再次进行Hash计算</span>
SHA256(<span class="hljs-string" style="color:rgb(221,17,68);">"I like donutsca07ca"</span>) 
——&gt; <span class="hljs-number" style="color:rgb(0,128,128);">0000002</span>f7c1fe31cb82acdc082cfec47620b7e4ab94f2bf9e096c436fc8cee06</code></pre>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">这里的<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">ca07ca</code>是计数器值的十六进制，他表示的十进制值为<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">13240266</code></p>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   即，从0开始，总共计算了13240266次，才计算出
   <code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">I like donuts</code>这个数据的Hash值，满足前6位(3字节)全是零。
  </blockquote>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">代码实现</h2>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   思路：
   <p>1）每次区块被添加到区块链之前，先要进行挖矿（Pow）</p>
   <p>2）挖矿过程中，产生的 Hash 值，如果小于难度目标值则添加进区块，否则继续挖矿，直到找到正确的Hash为止</p>
   <p>3）最后，验证区块Hash是否有效</p>
  </blockquote>
  <h4 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.25em;background-color:rgb(255,255,255);">定义Pow类</h4>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 工作量证明 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@author</span> wangwei * <span class="hljs-doctag" style="color:rgb(221,17,68);">@date</span> 2018/02/04 */</span>
<span class="hljs-meta" style="color:rgb(153,153,153);font-weight:bold;">@Data</span>
<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">ProofOfWork</span> </span>{

    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 难度目标位 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">static</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">final</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">int</span> TARGET_BITS = <span class="hljs-number" style="color:rgb(0,128,128);">20</span>;

    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 区块 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> Block block;
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 难度目标值 */</span>
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> BigInteger target;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">ProofOfWork</span><span class="hljs-params">(Block block, BigInteger target)</span> </span>{
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.block = block;
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.target = target;
    }
  
    <span class="hljs-comment" style="color:rgb(153,153,136);">/** * 创建新的工作量证明，设定难度目标值 * &lt;p&gt; * 对1进行移位运算，将1向左移动 (256 - TARGET_BITS) 位，得到我们的难度目标值 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> block * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">static</span> ProofOfWork <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">newProofOfWork</span><span class="hljs-params">(Block block)</span> </span>{
        BigInteger targetValue = BigInteger.valueOf(<span class="hljs-number" style="color:rgb(0,128,128);">1</span>).shiftLeft((<span class="hljs-number" style="color:rgb(0,128,128);">256</span> - TARGET_BITS));
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> ProofOfWork(block, targetValue);
    }
}</code></pre>
  <ul style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li style="margin-left:0px;"><p>设定一个难度目标位<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">TARGET_BITS</code>，表示最终挖矿挖出来Hash值，转化为二进制后，与256相比，长度少了多少bit，也即二进制前面有多少bit是零.</p>
    <blockquote style="font-size:1em;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);">
     <ul style="margin-left:3em;">
      <li style="margin-left:0px;"><code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">TARGET_BITS</code>&nbsp;越大，最终<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">targetValue</code>就越小，要求计算出来的Hash越来越小，也就是挖矿的难度越来越大。</li>
      <li style="margin-left:0px;">我们这里的<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">TARGET_BITS</code>是固定的，但是在真实的比特币中，难度目标是随着时间的推推，会动态调整的。详见：<a href="https://github.com/bitcoinbook/bitcoinbook" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.247059);">《精通比特币 （第二版）》第10章</a></li>
     </ul>
    </blockquote></li>
   <li style="margin-left:0px;">由于数值比较大，这里要使用<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">BitInteger</code>类型。</li>
  </ul>
  <h4 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.25em;background-color:rgb(255,255,255);">准备数据</h4>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 准备数据 * &lt;p&gt; * 注意：在准备区块数据时，一定要从原始数据类型转化为byte[]，不能直接从字符串进行转换 * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> nonce * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">private</span> String <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">prepareData</span><span class="hljs-params">(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">long</span> nonce)</span> </span>{
   <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">byte</span>[] prevBlockHashBytes = {};
   <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (StringUtils.isNoneBlank(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlock().getPrevBlockHash())) {
       prevBlockHashBytes = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> BigInteger(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlock().getPrevBlockHash(), <span class="hljs-number" style="color:rgb(0,128,128);">16</span>).toByteArray();
   }

   <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> ByteUtils.merge(
           prevBlockHashBytes,
           <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlock().getData().getBytes(),
           ByteUtils.toBytes(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlock().getTimeStamp()),
           ByteUtils.toBytes(TARGET_BITS),
           ByteUtils.toBytes(nonce)
    );
}</code></pre>
  <ul style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li style="margin-left:0px;"><p>参与Hash运算的如下几个信息：</p>
    <ul style="margin-left:3em;">
     <li style="margin-left:0px;">前一个区块（父区块）的Hash值；</li>
     <li style="margin-left:0px;">区块中的交易数据；</li>
     <li style="margin-left:0px;">区块生成的时间；</li>
     <li style="margin-left:0px;">难度目标；</li>
     <li style="margin-left:0px;">用于工作量证明算法的计数器</li>
    </ul></li>
  </ul>
  <blockquote style="font-size:14px;border-left:2px solid rgb(0,154,97);background:rgb(246,246,246);color:rgb(85,85,85);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;">
   详见：
   <a href="https://github.com/bitcoinbook/bitcoinbook" rel="nofollow" style="background:transparent;color:rgb(0,154,97);border-bottom:1px solid rgba(0,154,97,.247059);">《精通比特币 （第二版）》第09章</a>
  </blockquote>
  <h4 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.25em;background-color:rgb(255,255,255);">Pow算法</h4>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 运行工作量证明，开始挖矿，找到小于难度目标值的Hash * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> PowResult <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">long</span> nonce = <span class="hljs-number" style="color:rgb(0,128,128);">0</span>;
    String shaHex = <span class="hljs-string" style="color:rgb(221,17,68);">""</span>;
    System.out.printf(<span class="hljs-string" style="color:rgb(221,17,68);">"Mining the block containing：%s \n"</span>, <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlock().getData());

    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">long</span> startTime = System.currentTimeMillis();
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">while</span> (nonce &lt; Long.MAX_VALUE) {
        String data = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.prepareData(nonce);
        shaHex = DigestUtils.sha256Hex(data);
        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">if</span> (<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> BigInteger(shaHex, <span class="hljs-number" style="color:rgb(0,128,128);">16</span>).compareTo(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.target) == -<span class="hljs-number" style="color:rgb(0,128,128);">1</span>) {
            System.out.printf(<span class="hljs-string" style="color:rgb(221,17,68);">"Elapsed Time: %s seconds \n"</span>, (<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">float</span>) (System.currentTimeMillis() - startTime) / <span class="hljs-number" style="color:rgb(0,128,128);">1000</span>);
            System.out.printf(<span class="hljs-string" style="color:rgb(221,17,68);">"correct hash Hex: %s \n\n"</span>, shaHex);
            <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">break</span>;
         } <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">else</span> {
            nonce++;
         }
     }
     <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> PowResult(nonce, shaHex);
}</code></pre>
  <ul style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li style="margin-left:0px;"><p>循环体里面主要以下四步：</p>
    <ul style="margin-left:3em;">
     <li style="margin-left:0px;">准备数据</li>
     <li style="margin-left:0px;">进行sha256运算</li>
     <li style="margin-left:0px;">转化为BigInter类型</li>
     <li style="margin-left:0px;">与target进行比较</li>
    </ul></li>
   <li style="margin-left:0px;">最后，返回正确的Hash值以及运算计数器<code style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;">nonce</code></li>
  </ul>
  <h4 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.25em;background-color:rgb(255,255,255);">验证区块Hash有效性</h4>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 验证区块是否有效 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">boolean</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">validate</span><span class="hljs-params">()</span> </span>{
    String data = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.prepareData(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.getBlock().getNonce());
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> BigInteger(DigestUtils.sha256Hex(data), <span class="hljs-number" style="color:rgb(0,128,128);">16</span>).compareTo(<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">this</span>.target) == -<span class="hljs-number" style="color:rgb(0,128,128);">1</span>;
}</code></pre>
  <h4 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.25em;background-color:rgb(255,255,255);">修改区块添加逻辑</h4>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * &lt;p&gt; 创建新区块 &lt;/p&gt; * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> previousHash * <span class="hljs-doctag" style="color:rgb(221,17,68);">@param</span> data * <span class="hljs-doctag" style="color:rgb(221,17,68);">@return</span> */</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">static</span> Block <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">newBlock</span><span class="hljs-params">(String previousHash, String data)</span> </span>{
    Block block = <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">new</span> Block(<span class="hljs-string" style="color:rgb(221,17,68);">""</span>, previousHash, data, Instant.now().getEpochSecond(), <span class="hljs-number" style="color:rgb(0,128,128);">0</span>);
    ProofOfWork pow = ProofOfWork.newProofOfWork(block);
    PowResult powResult = pow.run();
    block.setHash(powResult.getHash());
    block.setNonce(powResult.getNonce());
    <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">return</span> block;
}</code></pre>
  <ul style="margin-left:3em;color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">
   <li style="margin-left:0px;">创建区块</li>
   <li style="margin-left:0px;">创建Pow算法对象</li>
   <li style="margin-left:0px;">执行Pow算法</li>
   <li style="margin-left:0px;">保存返回的Hash以及运算计数器</li>
  </ul>
  <h4 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.25em;background-color:rgb(255,255,255);">测试运行</h4>
  <pre style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:.93em;line-height:1.45;color:rgb(51,51,51);border:none;"><code class="java" style="font-family:'Source Code Pro', Consolas, Menlo, Monaco, 'Courier New', monospace;font-size:1em;color:inherit;background:none;"><span class="hljs-comment" style="color:rgb(153,153,136);">/** * 测试 * * <span class="hljs-doctag" style="color:rgb(221,17,68);">@author</span> wangwei * <span class="hljs-doctag" style="color:rgb(221,17,68);">@date</span> 2018/02/05 */</span>
<span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">class</span> <span class="hljs-title" style="color:rgb(68,85,136);font-weight:bold;">BlockchainTest</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">public</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">static</span> <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">void</span> <span class="hljs-title" style="color:rgb(153,0,0);font-weight:bold;">main</span><span class="hljs-params">(String[] args)</span> </span>{

        Blockchain blockchain = Blockchain.newBlockchain();

        blockchain.addBlock(<span class="hljs-string" style="color:rgb(221,17,68);">"Send 1 BTC to Ivan"</span>);
        blockchain.addBlock(<span class="hljs-string" style="color:rgb(221,17,68);">"Send 2 more BTC to Ivan"</span>);

        <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">for</span> (Block block : blockchain.getBlockList()) {
            System.out.println(<span class="hljs-string" style="color:rgb(221,17,68);">"Prev.hash: "</span> + block.getPrevBlockHash());
            System.out.println(<span class="hljs-string" style="color:rgb(221,17,68);">"Data: "</span> + block.getData());
            System.out.println(<span class="hljs-string" style="color:rgb(221,17,68);">"Hash: "</span> + block.getHash());
            System.out.println(<span class="hljs-string" style="color:rgb(221,17,68);">"Nonce: "</span> + block.getNonce());

            ProofOfWork pow = ProofOfWork.newProofOfWork(block);
            System.out.println(<span class="hljs-string" style="color:rgb(221,17,68);">"Pow valid: "</span> +  pow.validate() + <span class="hljs-string" style="color:rgb(221,17,68);">"\n"</span>);
        }
    }
}

<span class="hljs-comment" style="color:rgb(153,153,136);">/** * 设定TARGET_BITS = 20，得到如下结果： */</span>
Mining the block containing：Genesis Block 
Elapsed Time: <span class="hljs-number" style="color:rgb(0,128,128);">2.118</span> seconds 
correct hash Hex: <span class="hljs-number" style="color:rgb(0,128,128);">00000828</span>ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442 

Mining the block containing：Send <span class="hljs-number" style="color:rgb(0,128,128);">1</span> BTC to Ivan 
Elapsed Time: <span class="hljs-number" style="color:rgb(0,128,128);">1.069</span> seconds 
correct hash Hex: <span class="hljs-number" style="color:rgb(0,128,128);">00000</span>a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5 

Mining the block containing：Send <span class="hljs-number" style="color:rgb(0,128,128);">2</span> more BTC to Ivan 
Elapsed Time: <span class="hljs-number" style="color:rgb(0,128,128);">4.258</span> seconds 
correct hash Hex: <span class="hljs-number" style="color:rgb(0,128,128);">00000777f</span>93efe91d9aabcba14ab3d8ab8e0255b89818cdb9b93cfa844ad0c7f 

Prev.hash: 
Data: Genesis Block
Hash: <span class="hljs-number" style="color:rgb(0,128,128);">00000828</span>ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442
Nonce: <span class="hljs-number" style="color:rgb(0,128,128);">522163</span>
Pow valid: <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">true</span>

Prev.hash: <span class="hljs-number" style="color:rgb(0,128,128);">00000828</span>ee8289ef6381f297585ef8c952fde93fc2b673ff7cc655f699bb2442
Data: Send <span class="hljs-number" style="color:rgb(0,128,128);">1</span> BTC to Ivan
Hash: <span class="hljs-number" style="color:rgb(0,128,128);">00000</span>a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5
Nonce: <span class="hljs-number" style="color:rgb(0,128,128);">474758</span>
Pow valid: <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">true</span>

Prev.hash: <span class="hljs-number" style="color:rgb(0,128,128);">00000</span>a38c0d7f2ebbd20773e93770298aa8bc0cc6d85fca8756fe0646ae7fea5
Data: Send <span class="hljs-number" style="color:rgb(0,128,128);">2</span> more BTC to Ivan
Hash: <span class="hljs-number" style="color:rgb(0,128,128);">00000777f</span>93efe91d9aabcba14ab3d8ab8e0255b89818cdb9b93cfa844ad0c7f
Nonce: <span class="hljs-number" style="color:rgb(0,128,128);">1853839</span>
Pow valid: <span class="hljs-keyword" style="color:rgb(51,51,51);font-weight:bold;">true</span></code></pre>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);"></h2>
  <p style="background:rgb(255,255,255);"><span style="color:rgb(29,29,29);"><span style="font-family:'微软雅黑';">给大家推荐一个</span></span><a href="https://www.yidianzixun.com/channel/w/java" rel="nofollow"><span style="color:rgb(18,154,238);">java</span></a><span style="color:rgb(29,29,29);"><span style="font-family:'微软雅黑';">内部学习群：</span>725633148，进群找管理免费领取学习资料和视频。没有错就是免费领取！大佬小白都欢迎，大家一起学习共同进步！</span></p>
  <h2 style="font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-weight:500;line-height:1.2;color:rgb(51,51,51);font-size:1.75em;border-bottom:1px solid rgb(238,238,238);background-color:rgb(255,255,255);">总结</h2>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">我们正在一步一步接近真实的区块链架构，本篇我们实现了挖矿机制，但是我们还有很多关键性的功能没有实现：区块链数据库的持久性、钱包、地址、交易、共识机制，这些我们后面一步一步来实现</p>
  <p style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-family:'-apple-system', 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;font-size:14px;background-color:rgb(255,255,255);">文章出处： https://wangwei.one/ &nbsp;转载 ！</span><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/gupao123456/article/details/79686061,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/gupao123456/article/details/79686061,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
