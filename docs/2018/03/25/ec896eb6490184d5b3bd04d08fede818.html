<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>ECDSA 签名验证原理及C语言实现 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="ECDSA 签名验证原理及C语言实现" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u011280717/article/details/79689205 这两天总算把ECDSA搞明白了，本来想造个ECDSA轮子，但最近有点忙，而ECDSA轮子又不像HASH那样简单，所以就直接拿现成的轮子来记录一些ECDSA学习心得。 这里贴上github上一个比较适合学习的ECDSA代码，当然这个版本的代码没有openssl等商业级的代码专业，但是它足够简单，用来学习ECDSA原理非常合适。 easy-ecc 非对称加密算法签名/验证无非包括三步： 1. 密钥生成keygen 2. 签名sign 3. 验证verify 后文都以ECDSA384为例。 1 密钥生成 密钥生成其实主要涉及椭圆曲线ECC的一些原理，在这篇小记里，就不再赘述原理，网上讲原理的文章非常多。我当时也是看了以下这篇文章算是入门ECC原理。非常好的一篇文章，分享给各位朋友。 椭圆曲线密码学简介 椭圆曲线密码学的简单介绍 椭圆曲线定义 从上文中我们就可以知道椭圆的通式为 y^2 = x^3 + a*x + b mod p 以及一个无穷大的数0，当然最正宗的定义还有限定条件，该曲线是在有限域上的，并且a，b和q之间也存在关系。 ECDSA的密钥的计算方式 使用椭圆曲线E， 其中模数为p系数为a和b生成素数阶n的循环群的点G 选择一个随机整数d，且0 &lt; d &lt; q。 计算B=dG 其中d就是ECSDA的私钥，而点B(x，y)就是ECDSA的公钥。 P-384曲线 ECDSA384选用的P-384曲线。维基百科对P-384曲线描述如下： P-384 is the elliptic curve currently specified in NSA Suite B Cryptography for the ECDSA and ECDH algorithms. It is a 384 bit curve with characteristic approximately. In binary, this mod is given by 111…1100…0011…11. That is, 288 1s followed by 64 0s followed by 32 1s. The curve is given by the equation y^2 = x^3 - 3x + b where b is given by a certain 384 bit number. 简而言之，这条曲线形式就是y^2 = x^3 - 3x + b mod p，而b和q以及素数阶n在ECDSA中都是固定的。 所以ECDSA384中密钥生成的一些条件我们都找到了，从上述式子中可以看到系数a=-3， 其他的参数我们从代码中看。从代码中可以看到B，P和N都是一些固定值，这个是ECDSA384所规定的数，都是密码学专家制定的。因为这里讲的是ECDSA384，所以所有参与运算的数都是384 bits。但由于计算机现在最长的类型就是64bits，所以一个64 bits的数组来描述，相关的运算也因此稍麻烦一点。 ecc.h #define ECC_CURVE 48 #define Curve_P_48 {0x00000000FFFFFFFF, 0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF} #define Curve_B_48 {0x2A85C8EDD3EC2AEF, 0xC656398D8A2ED19D, 0x0314088F5013875A, 0x181D9C6EFE814112, 0x988E056BE3F82D19, 0xB3312FA7E23EE7E4} #define Curve_G_48 { \ {0x3A545E3872760AB7, 0x5502F25DBF55296C, 0x59F741E082542A38, 0x6E1D3B628BA79B98, 0x8EB1C71EF320AD74, 0xAA87CA22BE8B0537}, \ {0x7A431D7C90EA0E5F, 0x0A60B1CE1D7E819D, 0xE9DA3113B5F0B8C0, 0xF8F41DBD289A147C, 0x5D9E98BF9292DC29, 0x3617DE4A96262C6F}} #define Curve_N_48 {0xECEC196ACCC52973, 0x581A0DB248B0A77A, 0xC7634D81F4372DDF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF} static uint64_t curve_p[NUM_ECC_DIGITS] = CONCAT(Curve_P_, ECC_CURVE); static uint64_t curve_b[NUM_ECC_DIGITS] = CONCAT(Curve_B_, ECC_CURVE); static EccPoint curve_G = CONCAT(Curve_G_, ECC_CURVE); static uint64_t curve_n[NUM_ECC_DIGITS] = CONCAT(Curve_N_, ECC_CURVE); curve_b就是椭圆曲线的系数b curve_p就是椭圆曲线的模数p curve_G就是椭生成素数阶curve_n的循环群的点G 代码实现 然后就可以直接看代码中是如何生成密钥对，其API是 int ecc_make_key(uint8_t p_publicKey[ECC_BYTES+1], uint8_t p_privateKey[ECC_BYTES]) p_privateKey就是生成的私钥，而p_publicKey就是生成的公钥。有人问公钥不是点B的坐标吗，那点B不是需要x和y吗，x和y又分别是384位的，那为什么这里公钥是384 + 8位呢？这主要是这份代码的作者实现的小技巧，实际上通过坐标x就可以算出坐标y，所以这里只存了点B的x坐标即可，那多了8个位用作校验计算的准确性。当然可以直接把这个p_publicKey设置为p_publicKey[ECC_BYTES * 2]，也不做任务压缩，直接将x和y坐标存到公钥中，那使用的时候就不需要通过x坐标去算y坐标，这只是个人实现的喜好而已。 int ecc_make_key(uint8_t p_publicKey[ECC_BYTES+1], uint8_t p_privateKey[ECC_BYTES]) { uint64_t l_private[NUM_ECC_DIGITS]; EccPoint l_public; unsigned l_tries = 0; do { /*1.生成随机整数d，即私钥*/ if(!getRandomNumber(l_private) || (l_tries++ &gt;= MAX_TRIES)) { return 0; } /*1.1生成的随机数不能为0*/ if(vli_isZero(l_private)) { continue; } /*1.2 生成的随机数必须满足 0 &lt; d &lt; n*/ /* Make sure the private key is in the range [1, n-1]. For the supported curves, n is always large enough that we only need to subtract once at most. */ if(vli_cmp(curve_n, l_private) != 1) { vli_sub(l_private, l_private, curve_n); } /*2.根据p-384曲线计算公钥B=dG*/ EccPoint_mult(&amp;l_public, &amp;curve_G, l_private, NULL); } while(EccPoint_isZero(&amp;l_public)); /*将私钥和公钥分别转换为大端的字节数组并返回给上层*/ ecc_native2bytes(p_privateKey, l_private); /*可以看到公钥B的x坐标是存在在p_publicKey[1]开始的位置，p_publicKey[0]存放了一个y坐标校验值*/ ecc_native2bytes(p_publicKey + 1, l_public.x); p_publicKey[0] = 2 + (l_public.y[0] &amp; 0x01); return 1; } 上面代码就列出来，根据中文注释可以看到跟描述的生成步骤是一一对应的。其中一些大数的运算以及Ecc曲线的运算就不展开了，这里面都是编程体力活，原理很简单，但代码实现比较繁琐。 2 签名 与DSA一样，ECDSA签名由一对整数(r, s)组成，其中每个值的位长度都与q相同，这也有助于实现十分简洁的签名。使用公钥和私钥计算消息x的签名的方式如下 选择一个整数作为随机临时密钥Ke， 且0 &lt; Ke &lt; n。 计算R = Ke * A 设置r = Xr 计算s = (h(x) + d * r)/Ke mod q。 其中h(x)是待签名的数据的哈希值，ECDSA384的哈希算法是SHA384。在步骤3中，点R的x坐标赋给变量r。这样签名整数对(r,s)就计算出来了。 所以其实如果理解了椭圆曲线的原理之后，理解ECDSA还是很容易的，直接看代码，很直观得可以看到这个ECDSA签名流程。 签名的接口如下， p_privateKey是签名所用的私钥，p_hash是待签名数据的哈希值，p_signature存放计算出来的签名整数对(r,s)，p_signature[0:ECC_BYTES-1] 存放r，p_signature[ECC_BYTES， ECC_BYTES * 2 - 1]存放s。 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) 选择一个整数作为随机临时密钥Ke， 且0 &lt; Ke &lt; n。 从代码中可以看到， ecdsa_sign一开始就生成一个随机数k，并且必须满足0 &lt; k &lt; n。 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { uint64_t k[NUM_ECC_DIGITS]; uint64_t l_tmp[NUM_ECC_DIGITS]; uint64_t l_s[NUM_ECC_DIGITS]; EccPoint p; unsigned l_tries = 0; do { if(!getRandomNumber(k) || (l_tries++ &gt;= MAX_TRIES)) { return 0; } if(vli_isZero(k)) { continue; } if(vli_cmp(curve_n, k) != 1) { vli_sub(k, k, curve_n); } ...... } 计算R = Ke * A 同样计算出来的点R的x坐标也不能比q大。 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { ...... /* tmp = k * G */ EccPoint_mult(&amp;p, &amp;curve_G, k, NULL); /* r = x1 (mod n) */ if(vli_cmp(curve_n, p.x) != 1) { vli_sub(p.x, p.x, curve_n); } ...... } 设置r = Xr 将r以大端字节数组的形式存放到签名p_signature的前半部分 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { ...... ecc_native2bytes(p_signature, p.x); ...... } 计算s = (h(x) + d * r)/Ke mod q 原理很简单，但由于计算方法稍微复杂一点这个计算分成三步走 s = (r*d) mod n s = (h(x) + r*d) mod n s = (h(x) + r*d) / k mod n int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { ...... ecc_bytes2native(l_tmp, p_privateKey); vli_modMult(l_s, p.x, l_tmp, curve_n); /* s = (r*d) mod n */ ecc_bytes2native(l_tmp, p_hash); vli_modAdd(l_s, l_tmp, l_s, curve_n); /* s = (h(x) + r*d) mod n */ vli_modInv(k, k, curve_n); /* k = 1 / k */ vli_modMult(l_s, l_s, k, curve_n); /* s = (h(x) + r*d) / k mod n */ ecc_native2bytes(p_signature + ECC_BYTES, l_s); return 1; } 最终将算出来的s存放到签名p_signature 的后半部分。 3 签名验证 签名验证过程如下： - 计算辅助值W = 1 / s mod q - 计算辅助值u1 = w * h(x) mod q - 计算辅助值u2 = w * r mod q - 计算P = u1 * A + u2 * B - 验证verify(x, (r, s)), 如果P的x坐标 = r mod q，那么就是有效的签名，否则就是无效的签名。 关于验证的证明可以参考《深入浅出密码学-常用加密技术原理及应用》P268的证明。 验证的接口如下: - p_publicKey就是验证所要用到的公钥，即点B的坐标。 - p_hash是待验证数据的哈希值。 - p_signature 就是签名数据。 int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) 计算辅助值W = 1 / s mod q int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) { uint64_t u1[NUM_ECC_DIGITS], u2[NUM_ECC_DIGITS]; uint64_t z[NUM_ECC_DIGITS]; EccPoint l_public, l_sum; uint64_t rx[NUM_ECC_DIGITS]; uint64_t ry[NUM_ECC_DIGITS]; uint64_t tx[NUM_ECC_DIGITS]; uint64_t ty[NUM_ECC_DIGITS]; uint64_t tz[NUM_ECC_DIGITS]; uint64_t l_r[NUM_ECC_DIGITS], l_s[NUM_ECC_DIGITS]; /*先根据公钥B的x坐标计算坐标y，然后从签名中提取出r和s*/ ecc_point_decompress(&amp;l_public, p_publicKey); ecc_bytes2native(l_r, p_signature); ecc_bytes2native(l_s, p_signature + ECC_BYTES); ...... /* 1.计算w = s ^ -1 mod q */ vli_modInv(z, l_s, curve_n); /* Z = s^-1 */ ....... } 计算辅助值u1 = w * h(x) mod q 和 u2 = w * r mod q int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) { ...... ecc_bytes2native(u1, p_hash); vli_modMult(u1, u1, z, curve_n); /* u1 = w * h(x) mod q = h(x) / s mod q */ vli_modMult(u2, l_r, z, curve_n); /* u2 = w * r mod q= r / s mod q */ ...... } 计算P = u1 * A + u2 * B 这里面的计算代码上实现有点繁琐，主要是大数运算和椭圆曲线的运算，就不一一展开了，最终就是将计算出来的点P的x坐标和y坐标存放到rx和ry这两个变量中。 int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) { ...... /* Calculate l_sum = G + Q. */ vli_set(l_sum.x, l_public.x); vli_set(l_sum.y, l_public.y); vli_set(tx, curve_G.x); vli_set(ty, curve_G.y); vli_modSub(z, l_sum.x, tx, curve_p); /* Z = x2 - x1 */ XYcZ_add(tx, ty, l_sum.x, l_sum.y); vli_modInv(z, z, curve_p); /* Z = 1/Z */ apply_z(l_sum.x, l_sum.y, z); /* Use Shamir&#39;s trick to calculate u1*G + u2*Q */ EccPoint *l_points[4] = {NULL, &amp;curve_G, &amp;l_public, &amp;l_sum}; uint l_numBits = umax(vli_numBits(u1), vli_numBits(u2)); EccPoint *l_point = l_points[(!!vli_testBit(u1, l_numBits-1)) | ((!!vli_testBit(u2, l_numBits-1)) &lt;&lt; 1)]; vli_set(rx, l_point-&gt;x); vli_set(ry, l_point-&gt;y); vli_clear(z); z[0] = 1; int i; for(i = l_numBits - 2; i &gt;= 0; --i) { EccPoint_double_jacobian(rx, ry, z); int l_index = (!!vli_testBit(u1, i)) | ((!!vli_testBit(u2, i)) &lt;&lt; 1); EccPoint *l_point = l_points[l_index]; if(l_point) { vli_set(tx, l_point-&gt;x); vli_set(ty, l_point-&gt;y); apply_z(tx, ty, z); vli_modSub(tz, rx, tx, curve_p); /* Z = x2 - x1 */ XYcZ_add(tx, ty, rx, ry); vli_modMult_fast(z, z, tz); } } vli_modInv(z, z, curve_p); /* Z = 1/Z */ apply_z(rx, ry, z); ...... } 验证verify(x, (r, s)), 如果P的x坐标 = r mod q，那么就是有效的签名，否则就是无效的签名。 最终比较计算出来点P的x坐标是否与签名中的r相同来判断签名是否成功。 int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES ...... /* Accept only if v == r. */ return (vli_cmp(rx, l_r) == 0); } 应用 定义一个hash模拟一个数据的哈希值。首先创建密钥对，然后分别签名验证。 main.c 1 #include &quot;ecc.h&quot; 2 #include &lt;stdint.h&gt; 3 #include &lt;stdlib.h&gt; 4 #include &lt;stdio.h&gt; 5 6 int main() 7 { 8 uint8_t public_key[ECC_BYTES + 1]; 9 uint8_t private_key[ECC_BYTES]; 10 uint8_t hash[ECC_BYTES] = {0x2}; 11 uint8_t signature[ECC_BYTES * 2]; 12 uint32_t i = 0; 13 int ret = 0; 14 15 ret = ecc_make_key(public_key, private_key); 16 if (ret == 0) { 17 printf(&quot;ecc_make_key failure\n&quot;); 18 } 19 20 printf(&quot;##############public key###############\n&quot;); 21 for (i = 0;i &lt; ECC_BYTES + 1;i++) { 22 printf(&quot;%x &quot;, public_key[i]); 23 } 24 25 printf(&quot;\n\n&quot;); 26 printf(&quot;##############private key###############\n&quot;); 27 for (i = 0;i &lt; ECC_BYTES;i++) { 28 printf(&quot;%x &quot;, private_key[i]); 29 } 30 printf(&quot;\n\n&quot;); 31 32 ret = ecdsa_sign(private_key, hash, signature); 33 if (ret == 0) { 34 printf(&quot;ecdsa_sign failure\n&quot;); 35 } 36 37 ret = ecdsa_verify(public_key, hash, signature); 38 if (ret == 1) { 39 printf(&quot;verify passed\n&quot;); 40 } else { 41 printf(&quot;verify failed\n&quot;); 42 } 43 44 return 0; 45 } 运行结果 ############secret key############# 662eea0239ee28f 62693fced7eb10f1 3dd1e1815fe2e2b6 af68ec328b437369 737206cce4206de3 7650b5ce554851b6 ##############public key############### 2 8a 5c c7 24 28 ae 49 da c1 8 e7 a8 80 8a fd 5f ef a 79 ca d9 57 bf cc f9 92 98 85 5f 68 c4 5a 77 e2 2 d1 56 e4 4f 1d c5 94 1c bb 62 8e 2b a2 ##############private key############### 76 50 b5 ce 55 48 51 b6 73 72 6 cc e4 20 6d e3 af 68 ec 32 8b 43 73 69 3d d1 e1 81 5f e2 e2 b6 62 69 3f ce d7 eb 10 f1 6 62 ee a0 23 9e e2 8f l_read:48, l_left:48 verify passed 假如我们篡改了数据，那么验证就会失败，这里可以通过修改哈希值来模拟数据篡改，应该当数据一旦发生变化，其相应的哈希值就会发生变化。修改main函数如下，在验证签名之前篡改数据。 37 hash[0] = 0x3; 38 ret = ecdsa_verify(public_key, hash, signature); 39 if (ret == 1) { 40 printf(&quot;verify passed\n&quot;); 41 } else { 42 printf(&quot;verify failed\n&quot;); 43 } 44 45 return 0; 46 } 再运行一把就可以看到验证签名失败。 ############secret key############# 4f512226dd0a47e3 e7c9bc62fd8f37e6 f200140c350bb743 7fa11d17b04448fb aa4b146001ab1143 b132949e3715217c ##############public key############### 2 ea cb d1 46 84 60 89 2f cb c9 6 d8 da 9a 1d b4 21 7d 17 2 e4 b5 2b 6 58 d9 e8 75 e2 4b ae 30 84 7c 70 cf 41 7 fe 8c f4 d2 a8 37 50 e1 4 92 ##############private key############### b1 32 94 9e 37 15 21 7c aa 4b 14 60 1 ab 11 43 7f a1 1d 17 b0 44 48 fb f2 0 14 c 35 b b7 43 e7 c9 bc 62 fd 8f 37 e6 4f 51 22 26 dd a 47 e3 l_read:48, l_left:48 verify failed 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u011280717/article/details/79689205 这两天总算把ECDSA搞明白了，本来想造个ECDSA轮子，但最近有点忙，而ECDSA轮子又不像HASH那样简单，所以就直接拿现成的轮子来记录一些ECDSA学习心得。 这里贴上github上一个比较适合学习的ECDSA代码，当然这个版本的代码没有openssl等商业级的代码专业，但是它足够简单，用来学习ECDSA原理非常合适。 easy-ecc 非对称加密算法签名/验证无非包括三步： 1. 密钥生成keygen 2. 签名sign 3. 验证verify 后文都以ECDSA384为例。 1 密钥生成 密钥生成其实主要涉及椭圆曲线ECC的一些原理，在这篇小记里，就不再赘述原理，网上讲原理的文章非常多。我当时也是看了以下这篇文章算是入门ECC原理。非常好的一篇文章，分享给各位朋友。 椭圆曲线密码学简介 椭圆曲线密码学的简单介绍 椭圆曲线定义 从上文中我们就可以知道椭圆的通式为 y^2 = x^3 + a*x + b mod p 以及一个无穷大的数0，当然最正宗的定义还有限定条件，该曲线是在有限域上的，并且a，b和q之间也存在关系。 ECDSA的密钥的计算方式 使用椭圆曲线E， 其中模数为p系数为a和b生成素数阶n的循环群的点G 选择一个随机整数d，且0 &lt; d &lt; q。 计算B=dG 其中d就是ECSDA的私钥，而点B(x，y)就是ECDSA的公钥。 P-384曲线 ECDSA384选用的P-384曲线。维基百科对P-384曲线描述如下： P-384 is the elliptic curve currently specified in NSA Suite B Cryptography for the ECDSA and ECDH algorithms. It is a 384 bit curve with characteristic approximately. In binary, this mod is given by 111…1100…0011…11. That is, 288 1s followed by 64 0s followed by 32 1s. The curve is given by the equation y^2 = x^3 - 3x + b where b is given by a certain 384 bit number. 简而言之，这条曲线形式就是y^2 = x^3 - 3x + b mod p，而b和q以及素数阶n在ECDSA中都是固定的。 所以ECDSA384中密钥生成的一些条件我们都找到了，从上述式子中可以看到系数a=-3， 其他的参数我们从代码中看。从代码中可以看到B，P和N都是一些固定值，这个是ECDSA384所规定的数，都是密码学专家制定的。因为这里讲的是ECDSA384，所以所有参与运算的数都是384 bits。但由于计算机现在最长的类型就是64bits，所以一个64 bits的数组来描述，相关的运算也因此稍麻烦一点。 ecc.h #define ECC_CURVE 48 #define Curve_P_48 {0x00000000FFFFFFFF, 0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF} #define Curve_B_48 {0x2A85C8EDD3EC2AEF, 0xC656398D8A2ED19D, 0x0314088F5013875A, 0x181D9C6EFE814112, 0x988E056BE3F82D19, 0xB3312FA7E23EE7E4} #define Curve_G_48 { \ {0x3A545E3872760AB7, 0x5502F25DBF55296C, 0x59F741E082542A38, 0x6E1D3B628BA79B98, 0x8EB1C71EF320AD74, 0xAA87CA22BE8B0537}, \ {0x7A431D7C90EA0E5F, 0x0A60B1CE1D7E819D, 0xE9DA3113B5F0B8C0, 0xF8F41DBD289A147C, 0x5D9E98BF9292DC29, 0x3617DE4A96262C6F}} #define Curve_N_48 {0xECEC196ACCC52973, 0x581A0DB248B0A77A, 0xC7634D81F4372DDF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF} static uint64_t curve_p[NUM_ECC_DIGITS] = CONCAT(Curve_P_, ECC_CURVE); static uint64_t curve_b[NUM_ECC_DIGITS] = CONCAT(Curve_B_, ECC_CURVE); static EccPoint curve_G = CONCAT(Curve_G_, ECC_CURVE); static uint64_t curve_n[NUM_ECC_DIGITS] = CONCAT(Curve_N_, ECC_CURVE); curve_b就是椭圆曲线的系数b curve_p就是椭圆曲线的模数p curve_G就是椭生成素数阶curve_n的循环群的点G 代码实现 然后就可以直接看代码中是如何生成密钥对，其API是 int ecc_make_key(uint8_t p_publicKey[ECC_BYTES+1], uint8_t p_privateKey[ECC_BYTES]) p_privateKey就是生成的私钥，而p_publicKey就是生成的公钥。有人问公钥不是点B的坐标吗，那点B不是需要x和y吗，x和y又分别是384位的，那为什么这里公钥是384 + 8位呢？这主要是这份代码的作者实现的小技巧，实际上通过坐标x就可以算出坐标y，所以这里只存了点B的x坐标即可，那多了8个位用作校验计算的准确性。当然可以直接把这个p_publicKey设置为p_publicKey[ECC_BYTES * 2]，也不做任务压缩，直接将x和y坐标存到公钥中，那使用的时候就不需要通过x坐标去算y坐标，这只是个人实现的喜好而已。 int ecc_make_key(uint8_t p_publicKey[ECC_BYTES+1], uint8_t p_privateKey[ECC_BYTES]) { uint64_t l_private[NUM_ECC_DIGITS]; EccPoint l_public; unsigned l_tries = 0; do { /*1.生成随机整数d，即私钥*/ if(!getRandomNumber(l_private) || (l_tries++ &gt;= MAX_TRIES)) { return 0; } /*1.1生成的随机数不能为0*/ if(vli_isZero(l_private)) { continue; } /*1.2 生成的随机数必须满足 0 &lt; d &lt; n*/ /* Make sure the private key is in the range [1, n-1]. For the supported curves, n is always large enough that we only need to subtract once at most. */ if(vli_cmp(curve_n, l_private) != 1) { vli_sub(l_private, l_private, curve_n); } /*2.根据p-384曲线计算公钥B=dG*/ EccPoint_mult(&amp;l_public, &amp;curve_G, l_private, NULL); } while(EccPoint_isZero(&amp;l_public)); /*将私钥和公钥分别转换为大端的字节数组并返回给上层*/ ecc_native2bytes(p_privateKey, l_private); /*可以看到公钥B的x坐标是存在在p_publicKey[1]开始的位置，p_publicKey[0]存放了一个y坐标校验值*/ ecc_native2bytes(p_publicKey + 1, l_public.x); p_publicKey[0] = 2 + (l_public.y[0] &amp; 0x01); return 1; } 上面代码就列出来，根据中文注释可以看到跟描述的生成步骤是一一对应的。其中一些大数的运算以及Ecc曲线的运算就不展开了，这里面都是编程体力活，原理很简单，但代码实现比较繁琐。 2 签名 与DSA一样，ECDSA签名由一对整数(r, s)组成，其中每个值的位长度都与q相同，这也有助于实现十分简洁的签名。使用公钥和私钥计算消息x的签名的方式如下 选择一个整数作为随机临时密钥Ke， 且0 &lt; Ke &lt; n。 计算R = Ke * A 设置r = Xr 计算s = (h(x) + d * r)/Ke mod q。 其中h(x)是待签名的数据的哈希值，ECDSA384的哈希算法是SHA384。在步骤3中，点R的x坐标赋给变量r。这样签名整数对(r,s)就计算出来了。 所以其实如果理解了椭圆曲线的原理之后，理解ECDSA还是很容易的，直接看代码，很直观得可以看到这个ECDSA签名流程。 签名的接口如下， p_privateKey是签名所用的私钥，p_hash是待签名数据的哈希值，p_signature存放计算出来的签名整数对(r,s)，p_signature[0:ECC_BYTES-1] 存放r，p_signature[ECC_BYTES， ECC_BYTES * 2 - 1]存放s。 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) 选择一个整数作为随机临时密钥Ke， 且0 &lt; Ke &lt; n。 从代码中可以看到， ecdsa_sign一开始就生成一个随机数k，并且必须满足0 &lt; k &lt; n。 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { uint64_t k[NUM_ECC_DIGITS]; uint64_t l_tmp[NUM_ECC_DIGITS]; uint64_t l_s[NUM_ECC_DIGITS]; EccPoint p; unsigned l_tries = 0; do { if(!getRandomNumber(k) || (l_tries++ &gt;= MAX_TRIES)) { return 0; } if(vli_isZero(k)) { continue; } if(vli_cmp(curve_n, k) != 1) { vli_sub(k, k, curve_n); } ...... } 计算R = Ke * A 同样计算出来的点R的x坐标也不能比q大。 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { ...... /* tmp = k * G */ EccPoint_mult(&amp;p, &amp;curve_G, k, NULL); /* r = x1 (mod n) */ if(vli_cmp(curve_n, p.x) != 1) { vli_sub(p.x, p.x, curve_n); } ...... } 设置r = Xr 将r以大端字节数组的形式存放到签名p_signature的前半部分 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { ...... ecc_native2bytes(p_signature, p.x); ...... } 计算s = (h(x) + d * r)/Ke mod q 原理很简单，但由于计算方法稍微复杂一点这个计算分成三步走 s = (r*d) mod n s = (h(x) + r*d) mod n s = (h(x) + r*d) / k mod n int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { ...... ecc_bytes2native(l_tmp, p_privateKey); vli_modMult(l_s, p.x, l_tmp, curve_n); /* s = (r*d) mod n */ ecc_bytes2native(l_tmp, p_hash); vli_modAdd(l_s, l_tmp, l_s, curve_n); /* s = (h(x) + r*d) mod n */ vli_modInv(k, k, curve_n); /* k = 1 / k */ vli_modMult(l_s, l_s, k, curve_n); /* s = (h(x) + r*d) / k mod n */ ecc_native2bytes(p_signature + ECC_BYTES, l_s); return 1; } 最终将算出来的s存放到签名p_signature 的后半部分。 3 签名验证 签名验证过程如下： - 计算辅助值W = 1 / s mod q - 计算辅助值u1 = w * h(x) mod q - 计算辅助值u2 = w * r mod q - 计算P = u1 * A + u2 * B - 验证verify(x, (r, s)), 如果P的x坐标 = r mod q，那么就是有效的签名，否则就是无效的签名。 关于验证的证明可以参考《深入浅出密码学-常用加密技术原理及应用》P268的证明。 验证的接口如下: - p_publicKey就是验证所要用到的公钥，即点B的坐标。 - p_hash是待验证数据的哈希值。 - p_signature 就是签名数据。 int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) 计算辅助值W = 1 / s mod q int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) { uint64_t u1[NUM_ECC_DIGITS], u2[NUM_ECC_DIGITS]; uint64_t z[NUM_ECC_DIGITS]; EccPoint l_public, l_sum; uint64_t rx[NUM_ECC_DIGITS]; uint64_t ry[NUM_ECC_DIGITS]; uint64_t tx[NUM_ECC_DIGITS]; uint64_t ty[NUM_ECC_DIGITS]; uint64_t tz[NUM_ECC_DIGITS]; uint64_t l_r[NUM_ECC_DIGITS], l_s[NUM_ECC_DIGITS]; /*先根据公钥B的x坐标计算坐标y，然后从签名中提取出r和s*/ ecc_point_decompress(&amp;l_public, p_publicKey); ecc_bytes2native(l_r, p_signature); ecc_bytes2native(l_s, p_signature + ECC_BYTES); ...... /* 1.计算w = s ^ -1 mod q */ vli_modInv(z, l_s, curve_n); /* Z = s^-1 */ ....... } 计算辅助值u1 = w * h(x) mod q 和 u2 = w * r mod q int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) { ...... ecc_bytes2native(u1, p_hash); vli_modMult(u1, u1, z, curve_n); /* u1 = w * h(x) mod q = h(x) / s mod q */ vli_modMult(u2, l_r, z, curve_n); /* u2 = w * r mod q= r / s mod q */ ...... } 计算P = u1 * A + u2 * B 这里面的计算代码上实现有点繁琐，主要是大数运算和椭圆曲线的运算，就不一一展开了，最终就是将计算出来的点P的x坐标和y坐标存放到rx和ry这两个变量中。 int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) { ...... /* Calculate l_sum = G + Q. */ vli_set(l_sum.x, l_public.x); vli_set(l_sum.y, l_public.y); vli_set(tx, curve_G.x); vli_set(ty, curve_G.y); vli_modSub(z, l_sum.x, tx, curve_p); /* Z = x2 - x1 */ XYcZ_add(tx, ty, l_sum.x, l_sum.y); vli_modInv(z, z, curve_p); /* Z = 1/Z */ apply_z(l_sum.x, l_sum.y, z); /* Use Shamir&#39;s trick to calculate u1*G + u2*Q */ EccPoint *l_points[4] = {NULL, &amp;curve_G, &amp;l_public, &amp;l_sum}; uint l_numBits = umax(vli_numBits(u1), vli_numBits(u2)); EccPoint *l_point = l_points[(!!vli_testBit(u1, l_numBits-1)) | ((!!vli_testBit(u2, l_numBits-1)) &lt;&lt; 1)]; vli_set(rx, l_point-&gt;x); vli_set(ry, l_point-&gt;y); vli_clear(z); z[0] = 1; int i; for(i = l_numBits - 2; i &gt;= 0; --i) { EccPoint_double_jacobian(rx, ry, z); int l_index = (!!vli_testBit(u1, i)) | ((!!vli_testBit(u2, i)) &lt;&lt; 1); EccPoint *l_point = l_points[l_index]; if(l_point) { vli_set(tx, l_point-&gt;x); vli_set(ty, l_point-&gt;y); apply_z(tx, ty, z); vli_modSub(tz, rx, tx, curve_p); /* Z = x2 - x1 */ XYcZ_add(tx, ty, rx, ry); vli_modMult_fast(z, z, tz); } } vli_modInv(z, z, curve_p); /* Z = 1/Z */ apply_z(rx, ry, z); ...... } 验证verify(x, (r, s)), 如果P的x坐标 = r mod q，那么就是有效的签名，否则就是无效的签名。 最终比较计算出来点P的x坐标是否与签名中的r相同来判断签名是否成功。 int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES ...... /* Accept only if v == r. */ return (vli_cmp(rx, l_r) == 0); } 应用 定义一个hash模拟一个数据的哈希值。首先创建密钥对，然后分别签名验证。 main.c 1 #include &quot;ecc.h&quot; 2 #include &lt;stdint.h&gt; 3 #include &lt;stdlib.h&gt; 4 #include &lt;stdio.h&gt; 5 6 int main() 7 { 8 uint8_t public_key[ECC_BYTES + 1]; 9 uint8_t private_key[ECC_BYTES]; 10 uint8_t hash[ECC_BYTES] = {0x2}; 11 uint8_t signature[ECC_BYTES * 2]; 12 uint32_t i = 0; 13 int ret = 0; 14 15 ret = ecc_make_key(public_key, private_key); 16 if (ret == 0) { 17 printf(&quot;ecc_make_key failure\n&quot;); 18 } 19 20 printf(&quot;##############public key###############\n&quot;); 21 for (i = 0;i &lt; ECC_BYTES + 1;i++) { 22 printf(&quot;%x &quot;, public_key[i]); 23 } 24 25 printf(&quot;\n\n&quot;); 26 printf(&quot;##############private key###############\n&quot;); 27 for (i = 0;i &lt; ECC_BYTES;i++) { 28 printf(&quot;%x &quot;, private_key[i]); 29 } 30 printf(&quot;\n\n&quot;); 31 32 ret = ecdsa_sign(private_key, hash, signature); 33 if (ret == 0) { 34 printf(&quot;ecdsa_sign failure\n&quot;); 35 } 36 37 ret = ecdsa_verify(public_key, hash, signature); 38 if (ret == 1) { 39 printf(&quot;verify passed\n&quot;); 40 } else { 41 printf(&quot;verify failed\n&quot;); 42 } 43 44 return 0; 45 } 运行结果 ############secret key############# 662eea0239ee28f 62693fced7eb10f1 3dd1e1815fe2e2b6 af68ec328b437369 737206cce4206de3 7650b5ce554851b6 ##############public key############### 2 8a 5c c7 24 28 ae 49 da c1 8 e7 a8 80 8a fd 5f ef a 79 ca d9 57 bf cc f9 92 98 85 5f 68 c4 5a 77 e2 2 d1 56 e4 4f 1d c5 94 1c bb 62 8e 2b a2 ##############private key############### 76 50 b5 ce 55 48 51 b6 73 72 6 cc e4 20 6d e3 af 68 ec 32 8b 43 73 69 3d d1 e1 81 5f e2 e2 b6 62 69 3f ce d7 eb 10 f1 6 62 ee a0 23 9e e2 8f l_read:48, l_left:48 verify passed 假如我们篡改了数据，那么验证就会失败，这里可以通过修改哈希值来模拟数据篡改，应该当数据一旦发生变化，其相应的哈希值就会发生变化。修改main函数如下，在验证签名之前篡改数据。 37 hash[0] = 0x3; 38 ret = ecdsa_verify(public_key, hash, signature); 39 if (ret == 1) { 40 printf(&quot;verify passed\n&quot;); 41 } else { 42 printf(&quot;verify failed\n&quot;); 43 } 44 45 return 0; 46 } 再运行一把就可以看到验证签名失败。 ############secret key############# 4f512226dd0a47e3 e7c9bc62fd8f37e6 f200140c350bb743 7fa11d17b04448fb aa4b146001ab1143 b132949e3715217c ##############public key############### 2 ea cb d1 46 84 60 89 2f cb c9 6 d8 da 9a 1d b4 21 7d 17 2 e4 b5 2b 6 58 d9 e8 75 e2 4b ae 30 84 7c 70 cf 41 7 fe 8c f4 d2 a8 37 50 e1 4 92 ##############private key############### b1 32 94 9e 37 15 21 7c aa 4b 14 60 1 ab 11 43 7f a1 1d 17 b0 44 48 fb f2 0 14 c 35 b b7 43 e7 c9 bc 62 fd 8f 37 e6 4f 51 22 26 dd a 47 e3 l_read:48, l_left:48 verify failed 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/25/ec896eb6490184d5b3bd04d08fede818.html" />
<meta property="og:url" content="https://mlh.app/2018/03/25/ec896eb6490184d5b3bd04d08fede818.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-25T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u011280717/article/details/79689205 这两天总算把ECDSA搞明白了，本来想造个ECDSA轮子，但最近有点忙，而ECDSA轮子又不像HASH那样简单，所以就直接拿现成的轮子来记录一些ECDSA学习心得。 这里贴上github上一个比较适合学习的ECDSA代码，当然这个版本的代码没有openssl等商业级的代码专业，但是它足够简单，用来学习ECDSA原理非常合适。 easy-ecc 非对称加密算法签名/验证无非包括三步： 1. 密钥生成keygen 2. 签名sign 3. 验证verify 后文都以ECDSA384为例。 1 密钥生成 密钥生成其实主要涉及椭圆曲线ECC的一些原理，在这篇小记里，就不再赘述原理，网上讲原理的文章非常多。我当时也是看了以下这篇文章算是入门ECC原理。非常好的一篇文章，分享给各位朋友。 椭圆曲线密码学简介 椭圆曲线密码学的简单介绍 椭圆曲线定义 从上文中我们就可以知道椭圆的通式为 y^2 = x^3 + a*x + b mod p 以及一个无穷大的数0，当然最正宗的定义还有限定条件，该曲线是在有限域上的，并且a，b和q之间也存在关系。 ECDSA的密钥的计算方式 使用椭圆曲线E， 其中模数为p系数为a和b生成素数阶n的循环群的点G 选择一个随机整数d，且0 &lt; d &lt; q。 计算B=dG 其中d就是ECSDA的私钥，而点B(x，y)就是ECDSA的公钥。 P-384曲线 ECDSA384选用的P-384曲线。维基百科对P-384曲线描述如下： P-384 is the elliptic curve currently specified in NSA Suite B Cryptography for the ECDSA and ECDH algorithms. It is a 384 bit curve with characteristic approximately. In binary, this mod is given by 111…1100…0011…11. That is, 288 1s followed by 64 0s followed by 32 1s. The curve is given by the equation y^2 = x^3 - 3x + b where b is given by a certain 384 bit number. 简而言之，这条曲线形式就是y^2 = x^3 - 3x + b mod p，而b和q以及素数阶n在ECDSA中都是固定的。 所以ECDSA384中密钥生成的一些条件我们都找到了，从上述式子中可以看到系数a=-3， 其他的参数我们从代码中看。从代码中可以看到B，P和N都是一些固定值，这个是ECDSA384所规定的数，都是密码学专家制定的。因为这里讲的是ECDSA384，所以所有参与运算的数都是384 bits。但由于计算机现在最长的类型就是64bits，所以一个64 bits的数组来描述，相关的运算也因此稍麻烦一点。 ecc.h #define ECC_CURVE 48 #define Curve_P_48 {0x00000000FFFFFFFF, 0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF} #define Curve_B_48 {0x2A85C8EDD3EC2AEF, 0xC656398D8A2ED19D, 0x0314088F5013875A, 0x181D9C6EFE814112, 0x988E056BE3F82D19, 0xB3312FA7E23EE7E4} #define Curve_G_48 { \\ {0x3A545E3872760AB7, 0x5502F25DBF55296C, 0x59F741E082542A38, 0x6E1D3B628BA79B98, 0x8EB1C71EF320AD74, 0xAA87CA22BE8B0537}, \\ {0x7A431D7C90EA0E5F, 0x0A60B1CE1D7E819D, 0xE9DA3113B5F0B8C0, 0xF8F41DBD289A147C, 0x5D9E98BF9292DC29, 0x3617DE4A96262C6F}} #define Curve_N_48 {0xECEC196ACCC52973, 0x581A0DB248B0A77A, 0xC7634D81F4372DDF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF} static uint64_t curve_p[NUM_ECC_DIGITS] = CONCAT(Curve_P_, ECC_CURVE); static uint64_t curve_b[NUM_ECC_DIGITS] = CONCAT(Curve_B_, ECC_CURVE); static EccPoint curve_G = CONCAT(Curve_G_, ECC_CURVE); static uint64_t curve_n[NUM_ECC_DIGITS] = CONCAT(Curve_N_, ECC_CURVE); curve_b就是椭圆曲线的系数b curve_p就是椭圆曲线的模数p curve_G就是椭生成素数阶curve_n的循环群的点G 代码实现 然后就可以直接看代码中是如何生成密钥对，其API是 int ecc_make_key(uint8_t p_publicKey[ECC_BYTES+1], uint8_t p_privateKey[ECC_BYTES]) p_privateKey就是生成的私钥，而p_publicKey就是生成的公钥。有人问公钥不是点B的坐标吗，那点B不是需要x和y吗，x和y又分别是384位的，那为什么这里公钥是384 + 8位呢？这主要是这份代码的作者实现的小技巧，实际上通过坐标x就可以算出坐标y，所以这里只存了点B的x坐标即可，那多了8个位用作校验计算的准确性。当然可以直接把这个p_publicKey设置为p_publicKey[ECC_BYTES * 2]，也不做任务压缩，直接将x和y坐标存到公钥中，那使用的时候就不需要通过x坐标去算y坐标，这只是个人实现的喜好而已。 int ecc_make_key(uint8_t p_publicKey[ECC_BYTES+1], uint8_t p_privateKey[ECC_BYTES]) { uint64_t l_private[NUM_ECC_DIGITS]; EccPoint l_public; unsigned l_tries = 0; do { /*1.生成随机整数d，即私钥*/ if(!getRandomNumber(l_private) || (l_tries++ &gt;= MAX_TRIES)) { return 0; } /*1.1生成的随机数不能为0*/ if(vli_isZero(l_private)) { continue; } /*1.2 生成的随机数必须满足 0 &lt; d &lt; n*/ /* Make sure the private key is in the range [1, n-1]. For the supported curves, n is always large enough that we only need to subtract once at most. */ if(vli_cmp(curve_n, l_private) != 1) { vli_sub(l_private, l_private, curve_n); } /*2.根据p-384曲线计算公钥B=dG*/ EccPoint_mult(&amp;l_public, &amp;curve_G, l_private, NULL); } while(EccPoint_isZero(&amp;l_public)); /*将私钥和公钥分别转换为大端的字节数组并返回给上层*/ ecc_native2bytes(p_privateKey, l_private); /*可以看到公钥B的x坐标是存在在p_publicKey[1]开始的位置，p_publicKey[0]存放了一个y坐标校验值*/ ecc_native2bytes(p_publicKey + 1, l_public.x); p_publicKey[0] = 2 + (l_public.y[0] &amp; 0x01); return 1; } 上面代码就列出来，根据中文注释可以看到跟描述的生成步骤是一一对应的。其中一些大数的运算以及Ecc曲线的运算就不展开了，这里面都是编程体力活，原理很简单，但代码实现比较繁琐。 2 签名 与DSA一样，ECDSA签名由一对整数(r, s)组成，其中每个值的位长度都与q相同，这也有助于实现十分简洁的签名。使用公钥和私钥计算消息x的签名的方式如下 选择一个整数作为随机临时密钥Ke， 且0 &lt; Ke &lt; n。 计算R = Ke * A 设置r = Xr 计算s = (h(x) + d * r)/Ke mod q。 其中h(x)是待签名的数据的哈希值，ECDSA384的哈希算法是SHA384。在步骤3中，点R的x坐标赋给变量r。这样签名整数对(r,s)就计算出来了。 所以其实如果理解了椭圆曲线的原理之后，理解ECDSA还是很容易的，直接看代码，很直观得可以看到这个ECDSA签名流程。 签名的接口如下， p_privateKey是签名所用的私钥，p_hash是待签名数据的哈希值，p_signature存放计算出来的签名整数对(r,s)，p_signature[0:ECC_BYTES-1] 存放r，p_signature[ECC_BYTES， ECC_BYTES * 2 - 1]存放s。 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) 选择一个整数作为随机临时密钥Ke， 且0 &lt; Ke &lt; n。 从代码中可以看到， ecdsa_sign一开始就生成一个随机数k，并且必须满足0 &lt; k &lt; n。 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { uint64_t k[NUM_ECC_DIGITS]; uint64_t l_tmp[NUM_ECC_DIGITS]; uint64_t l_s[NUM_ECC_DIGITS]; EccPoint p; unsigned l_tries = 0; do { if(!getRandomNumber(k) || (l_tries++ &gt;= MAX_TRIES)) { return 0; } if(vli_isZero(k)) { continue; } if(vli_cmp(curve_n, k) != 1) { vli_sub(k, k, curve_n); } ...... } 计算R = Ke * A 同样计算出来的点R的x坐标也不能比q大。 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { ...... /* tmp = k * G */ EccPoint_mult(&amp;p, &amp;curve_G, k, NULL); /* r = x1 (mod n) */ if(vli_cmp(curve_n, p.x) != 1) { vli_sub(p.x, p.x, curve_n); } ...... } 设置r = Xr 将r以大端字节数组的形式存放到签名p_signature的前半部分 int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { ...... ecc_native2bytes(p_signature, p.x); ...... } 计算s = (h(x) + d * r)/Ke mod q 原理很简单，但由于计算方法稍微复杂一点这个计算分成三步走 s = (r*d) mod n s = (h(x) + r*d) mod n s = (h(x) + r*d) / k mod n int ecdsa_sign(const uint8_t p_privateKey[ECC_BYTES], const uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*2]) { ...... ecc_bytes2native(l_tmp, p_privateKey); vli_modMult(l_s, p.x, l_tmp, curve_n); /* s = (r*d) mod n */ ecc_bytes2native(l_tmp, p_hash); vli_modAdd(l_s, l_tmp, l_s, curve_n); /* s = (h(x) + r*d) mod n */ vli_modInv(k, k, curve_n); /* k = 1 / k */ vli_modMult(l_s, l_s, k, curve_n); /* s = (h(x) + r*d) / k mod n */ ecc_native2bytes(p_signature + ECC_BYTES, l_s); return 1; } 最终将算出来的s存放到签名p_signature 的后半部分。 3 签名验证 签名验证过程如下： - 计算辅助值W = 1 / s mod q - 计算辅助值u1 = w * h(x) mod q - 计算辅助值u2 = w * r mod q - 计算P = u1 * A + u2 * B - 验证verify(x, (r, s)), 如果P的x坐标 = r mod q，那么就是有效的签名，否则就是无效的签名。 关于验证的证明可以参考《深入浅出密码学-常用加密技术原理及应用》P268的证明。 验证的接口如下: - p_publicKey就是验证所要用到的公钥，即点B的坐标。 - p_hash是待验证数据的哈希值。 - p_signature 就是签名数据。 int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) 计算辅助值W = 1 / s mod q int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) { uint64_t u1[NUM_ECC_DIGITS], u2[NUM_ECC_DIGITS]; uint64_t z[NUM_ECC_DIGITS]; EccPoint l_public, l_sum; uint64_t rx[NUM_ECC_DIGITS]; uint64_t ry[NUM_ECC_DIGITS]; uint64_t tx[NUM_ECC_DIGITS]; uint64_t ty[NUM_ECC_DIGITS]; uint64_t tz[NUM_ECC_DIGITS]; uint64_t l_r[NUM_ECC_DIGITS], l_s[NUM_ECC_DIGITS]; /*先根据公钥B的x坐标计算坐标y，然后从签名中提取出r和s*/ ecc_point_decompress(&amp;l_public, p_publicKey); ecc_bytes2native(l_r, p_signature); ecc_bytes2native(l_s, p_signature + ECC_BYTES); ...... /* 1.计算w = s ^ -1 mod q */ vli_modInv(z, l_s, curve_n); /* Z = s^-1 */ ....... } 计算辅助值u1 = w * h(x) mod q 和 u2 = w * r mod q int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) { ...... ecc_bytes2native(u1, p_hash); vli_modMult(u1, u1, z, curve_n); /* u1 = w * h(x) mod q = h(x) / s mod q */ vli_modMult(u2, l_r, z, curve_n); /* u2 = w * r mod q= r / s mod q */ ...... } 计算P = u1 * A + u2 * B 这里面的计算代码上实现有点繁琐，主要是大数运算和椭圆曲线的运算，就不一一展开了，最终就是将计算出来的点P的x坐标和y坐标存放到rx和ry这两个变量中。 int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES*2]) { ...... /* Calculate l_sum = G + Q. */ vli_set(l_sum.x, l_public.x); vli_set(l_sum.y, l_public.y); vli_set(tx, curve_G.x); vli_set(ty, curve_G.y); vli_modSub(z, l_sum.x, tx, curve_p); /* Z = x2 - x1 */ XYcZ_add(tx, ty, l_sum.x, l_sum.y); vli_modInv(z, z, curve_p); /* Z = 1/Z */ apply_z(l_sum.x, l_sum.y, z); /* Use Shamir&#39;s trick to calculate u1*G + u2*Q */ EccPoint *l_points[4] = {NULL, &amp;curve_G, &amp;l_public, &amp;l_sum}; uint l_numBits = umax(vli_numBits(u1), vli_numBits(u2)); EccPoint *l_point = l_points[(!!vli_testBit(u1, l_numBits-1)) | ((!!vli_testBit(u2, l_numBits-1)) &lt;&lt; 1)]; vli_set(rx, l_point-&gt;x); vli_set(ry, l_point-&gt;y); vli_clear(z); z[0] = 1; int i; for(i = l_numBits - 2; i &gt;= 0; --i) { EccPoint_double_jacobian(rx, ry, z); int l_index = (!!vli_testBit(u1, i)) | ((!!vli_testBit(u2, i)) &lt;&lt; 1); EccPoint *l_point = l_points[l_index]; if(l_point) { vli_set(tx, l_point-&gt;x); vli_set(ty, l_point-&gt;y); apply_z(tx, ty, z); vli_modSub(tz, rx, tx, curve_p); /* Z = x2 - x1 */ XYcZ_add(tx, ty, rx, ry); vli_modMult_fast(z, z, tz); } } vli_modInv(z, z, curve_p); /* Z = 1/Z */ apply_z(rx, ry, z); ...... } 验证verify(x, (r, s)), 如果P的x坐标 = r mod q，那么就是有效的签名，否则就是无效的签名。 最终比较计算出来点P的x坐标是否与签名中的r相同来判断签名是否成功。 int ecdsa_verify(const uint8_t p_publicKey[ECC_BYTES+1], const uint8_t p_hash[ECC_BYTES], const uint8_t p_signature[ECC_BYTES ...... /* Accept only if v == r. */ return (vli_cmp(rx, l_r) == 0); } 应用 定义一个hash模拟一个数据的哈希值。首先创建密钥对，然后分别签名验证。 main.c 1 #include &quot;ecc.h&quot; 2 #include &lt;stdint.h&gt; 3 #include &lt;stdlib.h&gt; 4 #include &lt;stdio.h&gt; 5 6 int main() 7 { 8 uint8_t public_key[ECC_BYTES + 1]; 9 uint8_t private_key[ECC_BYTES]; 10 uint8_t hash[ECC_BYTES] = {0x2}; 11 uint8_t signature[ECC_BYTES * 2]; 12 uint32_t i = 0; 13 int ret = 0; 14 15 ret = ecc_make_key(public_key, private_key); 16 if (ret == 0) { 17 printf(&quot;ecc_make_key failure\\n&quot;); 18 } 19 20 printf(&quot;##############public key###############\\n&quot;); 21 for (i = 0;i &lt; ECC_BYTES + 1;i++) { 22 printf(&quot;%x &quot;, public_key[i]); 23 } 24 25 printf(&quot;\\n\\n&quot;); 26 printf(&quot;##############private key###############\\n&quot;); 27 for (i = 0;i &lt; ECC_BYTES;i++) { 28 printf(&quot;%x &quot;, private_key[i]); 29 } 30 printf(&quot;\\n\\n&quot;); 31 32 ret = ecdsa_sign(private_key, hash, signature); 33 if (ret == 0) { 34 printf(&quot;ecdsa_sign failure\\n&quot;); 35 } 36 37 ret = ecdsa_verify(public_key, hash, signature); 38 if (ret == 1) { 39 printf(&quot;verify passed\\n&quot;); 40 } else { 41 printf(&quot;verify failed\\n&quot;); 42 } 43 44 return 0; 45 } 运行结果 ############secret key############# 662eea0239ee28f 62693fced7eb10f1 3dd1e1815fe2e2b6 af68ec328b437369 737206cce4206de3 7650b5ce554851b6 ##############public key############### 2 8a 5c c7 24 28 ae 49 da c1 8 e7 a8 80 8a fd 5f ef a 79 ca d9 57 bf cc f9 92 98 85 5f 68 c4 5a 77 e2 2 d1 56 e4 4f 1d c5 94 1c bb 62 8e 2b a2 ##############private key############### 76 50 b5 ce 55 48 51 b6 73 72 6 cc e4 20 6d e3 af 68 ec 32 8b 43 73 69 3d d1 e1 81 5f e2 e2 b6 62 69 3f ce d7 eb 10 f1 6 62 ee a0 23 9e e2 8f l_read:48, l_left:48 verify passed 假如我们篡改了数据，那么验证就会失败，这里可以通过修改哈希值来模拟数据篡改，应该当数据一旦发生变化，其相应的哈希值就会发生变化。修改main函数如下，在验证签名之前篡改数据。 37 hash[0] = 0x3; 38 ret = ecdsa_verify(public_key, hash, signature); 39 if (ret == 1) { 40 printf(&quot;verify passed\\n&quot;); 41 } else { 42 printf(&quot;verify failed\\n&quot;); 43 } 44 45 return 0; 46 } 再运行一把就可以看到验证签名失败。 ############secret key############# 4f512226dd0a47e3 e7c9bc62fd8f37e6 f200140c350bb743 7fa11d17b04448fb aa4b146001ab1143 b132949e3715217c ##############public key############### 2 ea cb d1 46 84 60 89 2f cb c9 6 d8 da 9a 1d b4 21 7d 17 2 e4 b5 2b 6 58 d9 e8 75 e2 4b ae 30 84 7c 70 cf 41 7 fe 8c f4 d2 a8 37 50 e1 4 92 ##############private key############### b1 32 94 9e 37 15 21 7c aa 4b 14 60 1 ab 11 43 7f a1 1d 17 b0 44 48 fb f2 0 14 c 35 b b7 43 e7 c9 bc 62 fd 8f 37 e6 4f 51 22 26 dd a 47 e3 l_read:48, l_left:48 verify failed 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/25/ec896eb6490184d5b3bd04d08fede818.html","headline":"ECDSA 签名验证原理及C语言实现","dateModified":"2018-03-25T00:00:00+08:00","datePublished":"2018-03-25T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/25/ec896eb6490184d5b3bd04d08fede818.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>ECDSA 签名验证原理及C语言实现</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u011280717/article/details/79689205 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>这两天总算把ECDSA搞明白了，本来想造个ECDSA轮子，但最近有点忙，而ECDSA轮子又不像HASH那样简单，所以就直接拿现成的轮子来记录一些ECDSA学习心得。 <br> 这里贴上github上一个比较适合学习的ECDSA代码，当然这个版本的代码没有openssl等商业级的代码专业，但是它足够简单，用来学习ECDSA原理非常合适。 <br> <a href="https://github.com/esxgx/easy-ecc" rel="nofollow">easy-ecc</a></p> 
  <p>非对称加密算法签名/验证无非包括三步： <br> 1. 密钥生成keygen <br> 2. 签名sign <br> 3. 验证verify</p> 
  <p>后文都以ECDSA384为例。</p> 
  <h1 id="1-密钥生成">1 密钥生成</h1> 
  <p>密钥生成其实主要涉及椭圆曲线ECC的一些原理，在这篇小记里，就不再赘述原理，网上讲原理的文章非常多。我当时也是看了以下这篇文章算是入门ECC原理。非常好的一篇文章，分享给各位朋友。 <br> <a href="http://www.8btc.com/introduction" rel="nofollow">椭圆曲线密码学简介</a> <br> <a href="https://zhuanlan.zhihu.com/p/26029199" rel="nofollow">椭圆曲线密码学的简单介绍</a></p> 
  <h2 id="椭圆曲线定义">椭圆曲线定义</h2> 
  <p>从上文中我们就可以知道椭圆的通式为 <br> y^2 = x^3 + a*x + b mod p 以及一个无穷大的数0，当然最正宗的定义还有限定条件，该曲线是在有限域上的，并且a，b和q之间也存在关系。</p> 
  <h2 id="ecdsa的密钥的计算方式">ECDSA的密钥的计算方式</h2> 
  <ol> 
   <li>使用椭圆曲线E， 其中<br>模数为p<br>系数为a和b<br>生成素数阶n的循环群的点G</li> 
   <li>选择一个随机整数d，且0 &lt; d &lt; q。</li> 
   <li>计算B=dG <br> 其中d就是ECSDA的私钥，而点B(x，y)就是ECDSA的公钥。</li> 
  </ol> 
  <h4 id="p-384曲线">P-384曲线</h4> 
  <p>ECDSA384选用的P-384曲线。维基百科对P-384曲线描述如下：</p> 
  <p>P-384 is the elliptic curve currently specified in NSA Suite B Cryptography for the ECDSA and ECDH algorithms. It is a 384 bit curve with characteristic approximately. In binary, this mod is given by 111…1100…0011…11. That is, 288 1s followed by 64 0s followed by 32 1s. The curve is given by the equation <strong>y^2 = x^3 - 3x + b</strong> where <strong>b</strong> is given by a certain 384 bit number. <br> 简而言之，这条曲线形式就是<strong>y^2 = x^3 - 3x + b mod p</strong>，而b和q以及素数阶n在ECDSA中都是固定的。</p> 
  <p>所以ECDSA384中密钥生成的一些条件我们都找到了，从上述式子中可以看到系数<strong>a=-3</strong>， 其他的参数我们从代码中看。从代码中可以看到B，P和N都是一些固定值，这个是ECDSA384所规定的数，都是密码学专家制定的。因为这里讲的是ECDSA384，所以所有参与运算的数都是384 bits。但由于计算机现在最长的类型就是64bits，所以一个64 bits的数组来描述，相关的运算也因此稍麻烦一点。 </p> 
  <p><strong><em>ecc.h</em></strong></p> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">#define ECC_CURVE 48</span>

<span class="hljs-preprocessor">#define Curve_P_48 {0x00000000FFFFFFFF, 0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF}</span>

<span class="hljs-preprocessor">#define Curve_B_48 {0x2A85C8EDD3EC2AEF, 0xC656398D8A2ED19D, 0x0314088F5013875A, 0x181D9C6EFE814112, 0x988E056BE3F82D19, 0xB3312FA7E23EE7E4}</span>

<span class="hljs-preprocessor">#define Curve_G_48 { \</span>
    {<span class="hljs-number">0x3A545E3872760AB7</span>, <span class="hljs-number">0x5502F25DBF55296C</span>, <span class="hljs-number">0x59F741E082542A38</span>, <span class="hljs-number">0x6E1D3B628BA79B98</span>, <span class="hljs-number">0x8EB1C71EF320AD74</span>, <span class="hljs-number">0xAA87CA22BE8B0537</span>}, \
    {<span class="hljs-number">0x7A431D7C90EA0E5F</span>, <span class="hljs-number">0x0A60B1CE1D7E819D</span>, <span class="hljs-number">0xE9DA3113B5F0B8C0</span>, <span class="hljs-number">0xF8F41DBD289A147C</span>, <span class="hljs-number">0x5D9E98BF9292DC29</span>, <span class="hljs-number">0x3617DE4A96262C6F</span>}}

<span class="hljs-preprocessor">#define Curve_N_48 {0xECEC196ACCC52973, 0x581A0DB248B0A77A, 0xC7634D81F4372DDF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF}</span>

<span class="hljs-keyword">static</span> uint64_t curve_p[NUM_ECC_DIGITS] = CONCAT(Curve_P_, ECC_CURVE);
<span class="hljs-keyword">static</span> uint64_t curve_b[NUM_ECC_DIGITS] = CONCAT(Curve_B_, ECC_CURVE);
<span class="hljs-keyword">static</span> EccPoint curve_G = CONCAT(Curve_G_, ECC_CURVE);
<span class="hljs-keyword">static</span> uint64_t curve_n[NUM_ECC_DIGITS] = CONCAT(Curve_N_, ECC_CURVE);</code></pre> 
  <ul> 
   <li>curve_b就是椭圆曲线的系数b</li> 
   <li>curve_p就是椭圆曲线的模数p</li> 
   <li>curve_G就是椭生成素数阶curve_n的循环群的点G</li> 
  </ul> 
  <h4 id="代码实现">代码实现</h4> 
  <p>然后就可以直接看代码中是如何生成密钥对，其API是</p> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> ecc_make_key(uint8_t p_publicKey[ECC_BYTES+<span class="hljs-number">1</span>], uint8_t p_privateKey[ECC_BYTES])</code></pre> 
  <p>p_privateKey就是生成的私钥，而p_publicKey就是生成的公钥。有人问公钥不是点B的坐标吗，那点B不是需要x和y吗，x和y又分别是384位的，那为什么这里公钥是384 + 8位呢？这主要是这份代码的作者实现的小技巧，实际上通过坐标x就可以算出坐标y，所以这里只存了点B的x坐标即可，那多了8个位用作校验计算的准确性。当然可以直接把这个p_publicKey设置为p_publicKey[ECC_BYTES * 2]，也不做任务压缩，直接将x和y坐标存到公钥中，那使用的时候就不需要通过x坐标去算y坐标，这只是个人实现的喜好而已。</p> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> ecc_make_key(uint8_t p_publicKey[ECC_BYTES+<span class="hljs-number">1</span>], uint8_t p_privateKey[ECC_BYTES])
{
    uint64_t l_private[NUM_ECC_DIGITS];
    EccPoint l_public;
    <span class="hljs-keyword">unsigned</span> l_tries = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-comment">/*1.生成随机整数d，即私钥*/</span>
        <span class="hljs-keyword">if</span>(!getRandomNumber(l_private) || (l_tries++ &gt;= MAX_TRIES))
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-comment">/*1.1生成的随机数不能为0*/</span>
        <span class="hljs-keyword">if</span>(vli_isZero(l_private))
        {
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-comment">/*1.2 生成的随机数必须满足 0 &lt; d &lt; n*/</span>
        <span class="hljs-comment">/* Make sure the private key is in the range [1, n-1]. For the supported curves, n is always large enough that we only need to subtract once at most. */</span>
        <span class="hljs-keyword">if</span>(vli_cmp(curve_n, l_private) != <span class="hljs-number">1</span>)
        {
            vli_sub(l_private, l_private, curve_n);
        }
        <span class="hljs-comment">/*2.根据p-384曲线计算公钥B=dG*/</span>
        EccPoint_mult(&amp;l_public, &amp;curve_G, l_private, NULL);
    } <span class="hljs-keyword">while</span>(EccPoint_isZero(&amp;l_public));
    <span class="hljs-comment">/*将私钥和公钥分别转换为大端的字节数组并返回给上层*/</span>
    ecc_native2bytes(p_privateKey, l_private);
    <span class="hljs-comment">/*可以看到公钥B的x坐标是存在在p_publicKey[1]开始的位置，p_publicKey[0]存放了一个y坐标校验值*/</span>
    ecc_native2bytes(p_publicKey + <span class="hljs-number">1</span>, l_public.x);
    p_publicKey[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span> + (l_public.y[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x01</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
  <p>上面代码就列出来，根据中文注释可以看到跟描述的生成步骤是一一对应的。其中一些大数的运算以及Ecc曲线的运算就不展开了，这里面都是编程体力活，原理很简单，但代码实现比较繁琐。</p> 
  <h1 id="2-签名">2 签名</h1> 
  <p>与DSA一样，ECDSA签名由一对整数(r, s)组成，其中每个值的位长度都与q相同，这也有助于实现十分简洁的签名。使用公钥和私钥计算消息x的签名的方式如下</p> 
  <ul> 
   <li>选择一个整数作为随机临时密钥Ke， 且0 &lt; Ke &lt; n。</li> 
   <li>计算R = Ke * A</li> 
   <li>设置r = Xr</li> 
   <li>计算s = (h(x) + d * r)/Ke mod q。</li> 
  </ul> 
  <p>其中h(x)是待签名的数据的哈希值，ECDSA384的哈希算法是SHA384。在步骤3中，点R的x坐标赋给变量r。这样签名整数对(r,s)就计算出来了。 <br> 所以其实如果理解了椭圆曲线的原理之后，理解ECDSA还是很容易的，直接看代码，很直观得可以看到这个ECDSA签名流程。</p> 
  <p>签名的接口如下， <strong>p_privateKey</strong>是签名所用的私钥，<strong>p_hash</strong>是待签名数据的哈希值，<strong>p_signature</strong>存放计算出来的签名整数对(r,s)，<strong>p_signature[0:ECC_BYTES-1]</strong> 存放r，<strong>p_signature[ECC_BYTES， ECC_BYTES * 2 - 1]</strong>存放s。</p> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> ecdsa_sign(<span class="hljs-keyword">const</span> uint8_t p_privateKey[ECC_BYTES], <span class="hljs-keyword">const</span> uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*<span class="hljs-number">2</span>])</code></pre> 
  <h5 id="选择一个整数作为随机临时密钥ke-且0-ke-n">选择一个整数作为随机临时密钥Ke， 且0 &lt; Ke &lt; n。</h5> 
  <p>从代码中可以看到， ecdsa_sign一开始就生成一个随机数k，并且必须满足0 &lt; k &lt; n。</p> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> ecdsa_sign(<span class="hljs-keyword">const</span> uint8_t p_privateKey[ECC_BYTES], <span class="hljs-keyword">const</span> uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*<span class="hljs-number">2</span>])
{
    uint64_t k[NUM_ECC_DIGITS];
    uint64_t l_tmp[NUM_ECC_DIGITS];
    uint64_t l_s[NUM_ECC_DIGITS];
    EccPoint p;
    <span class="hljs-keyword">unsigned</span> l_tries = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-keyword">if</span>(!getRandomNumber(k) || (l_tries++ &gt;= MAX_TRIES))
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">if</span>(vli_isZero(k))
        {
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span>(vli_cmp(curve_n, k) != <span class="hljs-number">1</span>)
        {
            vli_sub(k, k, curve_n);
        }
     ......
 }</code></pre> 
  <h5 id="计算r-ke-a">计算R = Ke * A</h5> 
  <p>同样计算出来的点R的x坐标也不能比q大。</p> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> ecdsa_sign(<span class="hljs-keyword">const</span> uint8_t p_privateKey[ECC_BYTES], <span class="hljs-keyword">const</span> uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*<span class="hljs-number">2</span>])
{
        ......
     <span class="hljs-comment">/* tmp = k * G */</span>
        EccPoint_mult(&amp;p, &amp;curve_G, k, NULL);

        <span class="hljs-comment">/* r = x1 (mod n) */</span>
        <span class="hljs-keyword">if</span>(vli_cmp(curve_n, p.x) != <span class="hljs-number">1</span>)
        {
            vli_sub(p.x, p.x, curve_n);
        }
        ......
}</code></pre> 
  <h5 id="设置r-xr">设置r = Xr</h5> 
  <p>将r以大端字节数组的形式存放到签名p_signature的前半部分</p> 
  <pre class="prettyprint"><code class="language-C hljs cs"><span class="hljs-keyword">int</span> ecdsa_sign(<span class="hljs-keyword">const</span> uint8_t p_privateKey[ECC_BYTES], <span class="hljs-keyword">const</span> uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*<span class="hljs-number">2</span>])
{
        ......
        ecc_native2bytes(p_signature, p.x);
        ......
}</code></pre> 
  <h5 id="计算s-hx-d-rke-mod-q">计算s = (h(x) + d * r)/Ke mod q</h5> 
  <p>原理很简单，但由于计算方法稍微复杂一点这个计算分成三步走</p> 
  <ul> 
   <li>s = (r*d) mod n</li> 
   <li>s = (h(x) + r*d) mod n</li> 
   <li>s = (h(x) + r*d) / k mod n</li> 
  </ul> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> ecdsa_sign(<span class="hljs-keyword">const</span> uint8_t p_privateKey[ECC_BYTES], <span class="hljs-keyword">const</span> uint8_t p_hash[ECC_BYTES], uint8_t p_signature[ECC_BYTES*<span class="hljs-number">2</span>])
{
    ......
    ecc_bytes2native(l_tmp, p_privateKey);
    vli_modMult(l_s, p.x, l_tmp, curve_n); <span class="hljs-comment">/* s = (r*d) mod n */</span>
    ecc_bytes2native(l_tmp, p_hash);
    vli_modAdd(l_s, l_tmp, l_s, curve_n); <span class="hljs-comment">/* s = (h(x) + r*d) mod n */</span>
    vli_modInv(k, k, curve_n); <span class="hljs-comment">/* k = 1 / k */</span>
    vli_modMult(l_s, l_s, k, curve_n); <span class="hljs-comment">/* s = (h(x) + r*d) / k mod n */</span>
    ecc_native2bytes(p_signature + ECC_BYTES, l_s);

    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
  <p>最终将算出来的s存放到签名p_signature 的后半部分。</p> 
  <h1 id="3-签名验证">3 签名验证</h1> 
  <p>签名验证过程如下： <br> - 计算辅助值W = 1 / s mod q <br> - 计算辅助值u1 = w * h(x) mod q <br> - 计算辅助值u2 = w * r mod q <br> - 计算P = u1 * A + u2 * B <br> - 验证verify(x, (r, s)), 如果P的x坐标 = r mod q，那么就是有效的签名，否则就是无效的签名。</p> 
  <p>关于验证的证明可以参考《深入浅出密码学-常用加密技术原理及应用》P268的证明。</p> 
  <p>验证的接口如下: <br> - p_publicKey就是验证所要用到的公钥，即点B的坐标。 <br> - p_hash是待验证数据的哈希值。 <br> - p_signature 就是签名数据。</p> 
  <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">int</span> ecdsa_verify(<span class="hljs-keyword">const</span> uint8_t p_publicKey[ECC_BYTES+<span class="hljs-number">1</span>], <span class="hljs-keyword">const</span> uint8_t p_hash[ECC_BYTES], <span class="hljs-keyword">const</span> uint8_t p_signature[ECC_BYTES*<span class="hljs-number">2</span>])</code></pre> 
  <h5 id="计算辅助值w-1-s-mod-q">计算辅助值W = 1 / s mod q</h5> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> ecdsa_verify(<span class="hljs-keyword">const</span> uint8_t p_publicKey[ECC_BYTES+<span class="hljs-number">1</span>], <span class="hljs-keyword">const</span> uint8_t p_hash[ECC_BYTES], <span class="hljs-keyword">const</span> uint8_t p_signature[ECC_BYTES*<span class="hljs-number">2</span>])
{
    uint64_t u1[NUM_ECC_DIGITS], u2[NUM_ECC_DIGITS];
    uint64_t z[NUM_ECC_DIGITS];
    EccPoint l_public, l_sum;
    uint64_t rx[NUM_ECC_DIGITS];
    uint64_t ry[NUM_ECC_DIGITS];
    uint64_t tx[NUM_ECC_DIGITS];
    uint64_t ty[NUM_ECC_DIGITS];
    uint64_t tz[NUM_ECC_DIGITS];

    uint64_t l_r[NUM_ECC_DIGITS], l_s[NUM_ECC_DIGITS];
    <span class="hljs-comment">/*先根据公钥B的x坐标计算坐标y，然后从签名中提取出r和s*/</span>
    ecc_point_decompress(&amp;l_public, p_publicKey);
    ecc_bytes2native(l_r, p_signature);
    ecc_bytes2native(l_s, p_signature + ECC_BYTES);
    ......
    <span class="hljs-comment">/* 1.计算w = s ^ -1 mod q */</span>
    vli_modInv(z, l_s, curve_n); <span class="hljs-comment">/* Z = s^-1 */</span>
    .......
}</code></pre> 
  <h5 id="计算辅助值u1-w-hx-mod-q-和-u2-w-r-mod-q">计算辅助值u1 = w * h(x) mod q 和 u2 = w * r mod q</h5> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> ecdsa_verify(<span class="hljs-keyword">const</span> uint8_t p_publicKey[ECC_BYTES+<span class="hljs-number">1</span>], <span class="hljs-keyword">const</span> uint8_t p_hash[ECC_BYTES], <span class="hljs-keyword">const</span> uint8_t p_signature[ECC_BYTES*<span class="hljs-number">2</span>])
{
    ......
    ecc_bytes2native(u1, p_hash);
    vli_modMult(u1, u1, z, curve_n); <span class="hljs-comment">/* u1 = w * h(x) mod q = h(x) / s mod q */</span>
    vli_modMult(u2, l_r, z, curve_n); <span class="hljs-comment">/* u2 = w * r mod q= r / s mod q */</span>
    ......
}</code></pre> 
  <h5 id="计算p-u1-a-u2-b">计算P = u1 * A + u2 * B</h5> 
  <p>这里面的计算代码上实现有点繁琐，主要是大数运算和椭圆曲线的运算，就不一一展开了，最终就是将计算出来的点P的x坐标和y坐标存放到rx和ry这两个变量中。</p> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> ecdsa_verify(<span class="hljs-keyword">const</span> uint8_t p_publicKey[ECC_BYTES+<span class="hljs-number">1</span>], <span class="hljs-keyword">const</span> uint8_t p_hash[ECC_BYTES], <span class="hljs-keyword">const</span> uint8_t p_signature[ECC_BYTES*<span class="hljs-number">2</span>])
{
    ......
        <span class="hljs-comment">/* Calculate l_sum = G + Q. */</span>
    vli_set(l_sum.x, l_public.x);
    vli_set(l_sum.y, l_public.y);
    vli_set(tx, curve_G.x);
    vli_set(ty, curve_G.y);
    vli_modSub(z, l_sum.x, tx, curve_p); <span class="hljs-comment">/* Z = x2 - x1 */</span>
    XYcZ_add(tx, ty, l_sum.x, l_sum.y);
    vli_modInv(z, z, curve_p); <span class="hljs-comment">/* Z = 1/Z */</span>
    apply_z(l_sum.x, l_sum.y, z);

    <span class="hljs-comment">/* Use Shamir's trick to calculate u1*G + u2*Q */</span>
    EccPoint *l_points[<span class="hljs-number">4</span>] = {NULL, &amp;curve_G, &amp;l_public, &amp;l_sum};
    uint l_numBits = umax(vli_numBits(u1), vli_numBits(u2));

    EccPoint *l_point = l_points[(!!vli_testBit(u1, l_numBits-<span class="hljs-number">1</span>)) | ((!!vli_testBit(u2, l_numBits-<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">1</span>)];
    vli_set(rx, l_point-&gt;x);
    vli_set(ry, l_point-&gt;y);
    vli_clear(z);
    z[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span>(i = l_numBits - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i)
    {
        EccPoint_double_jacobian(rx, ry, z);

        <span class="hljs-keyword">int</span> l_index = (!!vli_testBit(u1, i)) | ((!!vli_testBit(u2, i)) &lt;&lt; <span class="hljs-number">1</span>);
        EccPoint *l_point = l_points[l_index];
        <span class="hljs-keyword">if</span>(l_point)
        {
            vli_set(tx, l_point-&gt;x);
            vli_set(ty, l_point-&gt;y);
            apply_z(tx, ty, z);
            vli_modSub(tz, rx, tx, curve_p); <span class="hljs-comment">/* Z = x2 - x1 */</span>
            XYcZ_add(tx, ty, rx, ry);
            vli_modMult_fast(z, z, tz);
        }
    }

    vli_modInv(z, z, curve_p); <span class="hljs-comment">/* Z = 1/Z */</span>
    apply_z(rx, ry, z);
    ......
}</code></pre> 
  <h5 id="验证verifyx-r-s-如果p的x坐标-r-mod-q那么就是有效的签名否则就是无效的签名">验证verify(x, (r, s)), 如果P的x坐标 = r mod q，那么就是有效的签名，否则就是无效的签名。</h5> 
  <p>最终比较计算出来点P的x坐标是否与签名中的r相同来判断签名是否成功。</p> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> ecdsa_verify(<span class="hljs-keyword">const</span> uint8_t p_publicKey[ECC_BYTES+<span class="hljs-number">1</span>], <span class="hljs-keyword">const</span> uint8_t p_hash[ECC_BYTES], <span class="hljs-keyword">const</span> uint8_t p_signature[ECC_BYTES
    ......
    <span class="hljs-comment">/* Accept only if v == r. */</span>
    <span class="hljs-keyword">return</span> (vli_cmp(rx, l_r) == <span class="hljs-number">0</span>);
}</code></pre> 
  <h1 id="应用">应用</h1> 
  <p>定义一个hash模拟一个数据的哈希值。首先创建密钥对，然后分别签名验证。 <br> <strong><em>main.c</em></strong></p> 
  <pre class="prettyprint"><code class=" hljs cpp">  <span class="hljs-number">1</span> <span class="hljs-preprocessor">#include "ecc.h"</span>
  <span class="hljs-number">2</span> <span class="hljs-preprocessor">#include &lt;stdint.h&gt;</span>
  <span class="hljs-number">3</span> <span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
  <span class="hljs-number">4</span> <span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
  <span class="hljs-number">5</span>
  <span class="hljs-number">6</span> <span class="hljs-keyword">int</span> main()
  <span class="hljs-number">7</span> {
  <span class="hljs-number">8</span>     uint8_t public_key[ECC_BYTES + <span class="hljs-number">1</span>];
  <span class="hljs-number">9</span>     uint8_t private_key[ECC_BYTES];
 <span class="hljs-number">10</span>     uint8_t hash[ECC_BYTES] = {<span class="hljs-number">0x2</span>};
 <span class="hljs-number">11</span>     uint8_t signature[ECC_BYTES * <span class="hljs-number">2</span>];
 <span class="hljs-number">12</span>     uint32_t i = <span class="hljs-number">0</span>;
 <span class="hljs-number">13</span>     <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
 <span class="hljs-number">14</span>
 <span class="hljs-number">15</span>     ret = ecc_make_key(public_key, private_key);
 <span class="hljs-number">16</span>     <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) {
 <span class="hljs-number">17</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ecc_make_key failure\n"</span>);
 <span class="hljs-number">18</span>     }
 <span class="hljs-number">19</span>
 <span class="hljs-number">20</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"##############public key###############\n"</span>);
 <span class="hljs-number">21</span>     <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; ECC_BYTES + <span class="hljs-number">1</span>;i++) {
 <span class="hljs-number">22</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%x "</span>, public_key[i]);
 <span class="hljs-number">23</span>     }
 <span class="hljs-number">24</span>
 <span class="hljs-number">25</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);
 <span class="hljs-number">26</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"##############private key###############\n"</span>);
 <span class="hljs-number">27</span>     <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; ECC_BYTES;i++) {
 <span class="hljs-number">28</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%x "</span>, private_key[i]);
 <span class="hljs-number">29</span>     }
 <span class="hljs-number">30</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n"</span>);
 <span class="hljs-number">31</span>
 <span class="hljs-number">32</span>     ret = ecdsa_sign(private_key, hash, signature);
 <span class="hljs-number">33</span>     <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) {
 <span class="hljs-number">34</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ecdsa_sign failure\n"</span>);
 <span class="hljs-number">35</span>     }
 <span class="hljs-number">36</span>
 <span class="hljs-number">37</span>     ret = ecdsa_verify(public_key, hash, signature);
 <span class="hljs-number">38</span>     <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">1</span>) {
 <span class="hljs-number">39</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"verify passed\n"</span>);
 <span class="hljs-number">40</span>     } <span class="hljs-keyword">else</span> {
 <span class="hljs-number">41</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"verify failed\n"</span>);
 <span class="hljs-number">42</span>     }
 <span class="hljs-number">43</span>
 <span class="hljs-number">44</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 <span class="hljs-number">45</span> }</code></pre> 
  <p>运行结果</p> 
  <pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">############secret key#############</span>
<span class="hljs-number">662</span>eea0239ee28f <span class="hljs-number">62693f</span>ced7eb10f1 <span class="hljs-number">3</span>dd1e1815fe2e2b6 af68ec328b437369 <span class="hljs-number">737206</span>cce4206de3 <span class="hljs-number">7650</span>b5ce554851b6

<span class="hljs-preprocessor">##############public key###############</span>
<span class="hljs-number">2</span> <span class="hljs-number">8</span>a <span class="hljs-number">5</span>c c7 <span class="hljs-number">24</span> <span class="hljs-number">28</span> ae <span class="hljs-number">49</span> da c1 <span class="hljs-number">8</span> e7 a8 <span class="hljs-number">80</span> <span class="hljs-number">8</span>a fd <span class="hljs-number">5f</span> ef a <span class="hljs-number">79</span> ca d9 <span class="hljs-number">57</span> bf cc f9 <span class="hljs-number">92</span> <span class="hljs-number">98</span> <span class="hljs-number">85</span> <span class="hljs-number">5f</span> <span class="hljs-number">68</span> c4 <span class="hljs-number">5</span>a <span class="hljs-number">77</span> e2 <span class="hljs-number">2</span> d1 <span class="hljs-number">56</span> e4 <span class="hljs-number">4f</span> <span class="hljs-number">1</span>d c5 <span class="hljs-number">94</span> <span class="hljs-number">1</span>c bb <span class="hljs-number">62</span> <span class="hljs-number">8</span>e <span class="hljs-number">2</span>b a2

<span class="hljs-preprocessor">##############private key###############</span>
<span class="hljs-number">76</span> <span class="hljs-number">50</span> b5 ce <span class="hljs-number">55</span> <span class="hljs-number">48</span> <span class="hljs-number">51</span> b6 <span class="hljs-number">73</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span> cc e4 <span class="hljs-number">20</span> <span class="hljs-number">6</span>d e3 af <span class="hljs-number">68</span> ec <span class="hljs-number">32</span> <span class="hljs-number">8</span>b <span class="hljs-number">43</span> <span class="hljs-number">73</span> <span class="hljs-number">69</span> <span class="hljs-number">3</span>d d1 e1 <span class="hljs-number">81</span> <span class="hljs-number">5f</span> e2 e2 b6 <span class="hljs-number">62</span> <span class="hljs-number">69</span> <span class="hljs-number">3f</span> ce d7 eb <span class="hljs-number">10</span> f1 <span class="hljs-number">6</span> <span class="hljs-number">62</span> ee a0 <span class="hljs-number">23</span> <span class="hljs-number">9</span>e e2 <span class="hljs-number">8f</span>

l_read:<span class="hljs-number">48</span>, l_left:<span class="hljs-number">48</span>
verify passed</code></pre> 
  <p>假如我们篡改了数据，那么验证就会失败，这里可以通过修改哈希值来模拟数据篡改，应该当数据一旦发生变化，其相应的哈希值就会发生变化。修改main函数如下，在验证签名之前篡改数据。</p> 
  <pre class="prettyprint"><code class="language-c hljs "> <span class="hljs-number">37</span>     hash[<span class="hljs-number">0</span>] = <span class="hljs-number">0x3</span>;
 <span class="hljs-number">38</span>     ret = ecdsa_verify(public_key, hash, signature);
 <span class="hljs-number">39</span>     <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">1</span>) {
 <span class="hljs-number">40</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"verify passed\n"</span>);
 <span class="hljs-number">41</span>     } <span class="hljs-keyword">else</span> {
 <span class="hljs-number">42</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"verify failed\n"</span>);
 <span class="hljs-number">43</span>     }
 <span class="hljs-number">44</span>
 <span class="hljs-number">45</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 <span class="hljs-number">46</span> }</code></pre> 
  <p>再运行一把就可以看到验证签名失败。</p> 
  <pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-comment">######</span><span class="hljs-comment">######</span>secret key<span class="hljs-comment">######</span><span class="hljs-comment">######</span><span class="hljs-comment">#</span>
<span class="hljs-number">4</span>f512226dd0a47e3 e7c9bc62fd8f37e6 f200140c350bb743 <span class="hljs-number">7</span>fa11d17b04448fb aa4b146001ab1143 b132949e3715217c

<span class="hljs-comment">######</span><span class="hljs-comment">######</span><span class="hljs-comment">##public key###############</span>
<span class="hljs-number">2</span> ea cb d1 <span class="hljs-number">46</span> <span class="hljs-number">84</span> <span class="hljs-number">60</span> <span class="hljs-number">89</span> <span class="hljs-number">2</span>f cb c9 <span class="hljs-number">6</span> d8 da <span class="hljs-number">9</span>a <span class="hljs-number">1</span>d b4 <span class="hljs-number">21</span> <span class="hljs-number">7</span>d <span class="hljs-number">17</span> <span class="hljs-number">2</span> e4 b5 <span class="hljs-number">2</span>b <span class="hljs-number">6</span> <span class="hljs-number">58</span> d9 e8 <span class="hljs-number">75</span> e2 <span class="hljs-number">4</span>b ae <span class="hljs-number">30</span> <span class="hljs-number">84</span> <span class="hljs-number">7</span>c <span class="hljs-number">70</span> cf <span class="hljs-number">41</span> <span class="hljs-number">7</span> fe <span class="hljs-number">8</span>c f4 d2 a8 <span class="hljs-number">37</span> <span class="hljs-number">50</span> e1 <span class="hljs-number">4</span> <span class="hljs-number">92</span>

<span class="hljs-comment">######</span><span class="hljs-comment">######</span><span class="hljs-comment">##private key###############</span>
b1 <span class="hljs-number">32</span> <span class="hljs-number">94</span> <span class="hljs-number">9</span>e <span class="hljs-number">37</span> <span class="hljs-number">15</span> <span class="hljs-number">21</span> <span class="hljs-number">7</span>c aa <span class="hljs-number">4</span>b <span class="hljs-number">14</span> <span class="hljs-number">60</span> <span class="hljs-number">1</span> ab <span class="hljs-number">11</span> <span class="hljs-number">43</span> <span class="hljs-number">7</span>f a1 <span class="hljs-number">1</span>d <span class="hljs-number">17</span> b0 <span class="hljs-number">44</span> <span class="hljs-number">48</span> fb f2 <span class="hljs-number">0</span> <span class="hljs-number">14</span> c <span class="hljs-number">35</span> b b7 <span class="hljs-number">43</span> e7 c9 bc <span class="hljs-number">62</span> fd <span class="hljs-number">8</span>f <span class="hljs-number">37</span> e6 <span class="hljs-number">4</span>f <span class="hljs-number">51</span> <span class="hljs-number">22</span> <span class="hljs-number">26</span> dd a <span class="hljs-number">47</span> e3

<span class="hljs-attribute">l_read</span>:<span class="hljs-number">48</span>, <span class="hljs-attribute">l_left</span>:<span class="hljs-number">48</span>
verify failed</code></pre> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-778f64ae39.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u011280717/article/details/79689205,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u011280717/article/details/79689205,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
