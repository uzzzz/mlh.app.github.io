<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链概念1：Hash 算法 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链概念1：Hash 算法" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="问题导读1.哈希算法在区块链的作用是什么？2.什么是哈希算法？3.哈希算法是否可逆？4.比特币采用的是什么哈希算法？作用在学习哈希算法前，我们需要知道哈希在区块链的作用哈希算法的作用如下：区块链通过哈希算法对一个交易区块中的交易信息进行加密，并把信息压缩成由一串数字和字母组成的散列字符串。区块链的哈希值能够唯一而精准地标识一个区块，区块链中任意节点通过简单的哈希计算都接获得这个区块的哈希值，计算出的哈希值没有变化也就意味着区块链中的信息没有被篡改。定义hash （哈希或散列）算法是信息技术领域非常基础也非常重要的技术。它能任意长度的二进制值（明文）映射为较短的固定长度的二进制值（hash 值），并且不同的明文很难映射为相同的 hash 值。例如计算一段话“hello blockchain world, this is yeasy@github”的 md5 hash 值为 89242549883a2ef85dc81b90fb606046。$ echo “hello blockchain world, this is yeasy@github”|md5&nbsp;89242549883a2ef85dc81b90fb606046&nbsp;这意味着我们只要对某文件进行 md5 hash 计算，得到结果为 89242549883a2ef85dc81b90fb606046，这就说明文件内容极大概率上就是 “hello blockchain world, this is yeasy@github”。可见，hash 的核心思想十分类似于基于内容的编址或命名。注：md5 是一个经典的 hash 算法，其和 SHA-1 算法都已被 证明 安全性不足应用于商业场景。一个优秀的 hash 算法，将能实现：正向快速：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。&nbsp;逆向困难：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。&nbsp;输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。&nbsp;冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。&nbsp;冲突避免有时候又被称为“抗碰撞性”。如果给定一个明文前提下，无法找到碰撞的另一个明文，称为“抗弱碰撞性”；如果无法找到任意两个明文，发生碰撞，则称算法具有“抗强碰撞性”。流行的算法目前流行的 hash 算法包括 MD5（已被证明不够安全）和 SHA-1，两者均以 MD4 为基础设计的。MD4（RFC 1320）是 MIT 的 Ronald L. Rivest 在 1990 年设计的，MD 是 Message Digest 的缩写。其输出为 128 位。MD4 并不足够安全。MD5（RFC 1321）是 Rivest 于1991年对 MD4 的改进版本。它对输入仍以 512 位分组，其输出是 128 位。MD5 比 MD4 复杂，并且计算速度要慢一点，但更安全一些。MD5 并不足够安全。SHA1 （Secure Hash Algorithm）是由 NIST NSA 设计，它的输出为长度 160 位的 hash 值，因此抗穷举性更好。SHA-1 设计时基于和 MD4 相同原理,并且模仿了该算法。为了提高安全性，NIST NSA 还设计出了 SHA-224、SHA-256、SHA-384，和 SHA-512 算法（统称为 SHA-2），跟 SHA-1 算法原理类似。性能一般的，hash 算法都是算力敏感型，意味着计算资源是瓶颈，主频越高的 CPU 进行 hash 的速度也越快。也有一些 hash 算法不是算力敏感的，例如 scrypt，需要大量的内存资源，节点不能通过简单的增加更多 CPU 来获得 hash 性能的提升。&nbsp;数字摘要顾名思义，数字摘要是对数字内容进行 hash 运算，获取唯一的摘要值来指代原始数字内容。数字摘要是解决确保内容没被篡改过的问题（利用 hash 函数的抗碰撞性特点）。数字摘要是 hash 算法最重要的一个用途。在网络上下载软件或文件时，往往同时会提供一个数字摘要值，用户下载下来原始文件可以自行进行计算，并同提供的摘要值进行比对，以确保内容没有被修改过。&nbsp;##########################对于哈希，我们可能认识还不够彻底，下面在补充一些内容解释1：把网址A，转换成数字1。网址B，转换成数字2。一个网址X，转换成数字N，根据数字N作为下标，就可以快速地查找出网址X的信息。这个转换的过程就是哈希算法。哈希算法并不是一种特定的算法，只要能完成这种转换的算法都是哈希算法。但是评定一个算法是否是好的哈希算法，要根据算法的离散度和冲突概率来评定。解释2：什么是哈希表和哈希算法？比如这里有一万首歌，给你一首新的歌X，要求你确认这首歌是否在那一万首歌之内。无疑，将一万首歌一个一个比对非常慢。但如果存在一种方式，能将一万首歌的每首数据浓缩到一个数字（称为哈希码）中，于是得到一万个数字，那么用同样的算法计算新的歌X的编码，看看歌X的编码是否在之前那一万个数字中，就能知道歌X是否在那一万首歌中。作为例子，如果要你组织那一万首歌，一个简单的哈希算法就是让歌曲所占硬盘的字节数作为哈希码。这样的话，你可以让一万首歌“按照大小排序”，然后遇到一首新的歌，只要看看新的歌的字节数是否和已有的一万首歌中的某一首的字节数相同，就知道新的歌是否在那一万首歌之内了。当然这个简单的哈希算法很容易出现两者同样大小的歌曲，这就是发送了碰撞。而好的哈希算法发生碰撞的几率非常小。解释3：这个HASH算法不是大学里数据结构课里那个HASH表的算法。这里的HASH算法是密码学的基础，比较常用的有MD5和SHA，最重要的两条性质，就是不可逆和无冲突。所谓不可逆，就是当你知道x的HASH值，无法求出x；所谓无冲突，就是当你知道x，无法求出一个y， 使x与y的HASH值相同。这两条性质在数学上都是不成立的。因为一个函数必然可逆，且由于HASH函数的值域有限，理论上会有无穷多个不同的原始值，它们的hash值都相同。MD5和SHA做到的，是求逆和求冲突在计算上不可能，也就是正向计算很容易，而反向计算即使穷尽人类所有的计算资源都做不到。我觉得密码学的几个算法（HASH、对称加密、公私钥）是计算机科学领域最伟大的发明之一，它授予了弱小的个人在强权面前信息的安全（而且是绝对的安全）。举个例子，只要你一直使用https与国外站点通讯，并注意对方的公钥没有被篡改，G**W可以断开你的连接，但它永远不可能知道你们的传输内容是什么。解释4： 解读区块链，区块链中HASH算法 区块链技术是一系列技术的结合，建立一种新的技术架构，hash算法是其中尤为重要的一块，这里简单对hash算法做一个说明。如果有理解不当的地方请及时指正。 讲hash算法之前先明确一个基础的计算机知识，计算机在底层机器码是采用二进制的模式，所谓二进制简单来说就是底层以0/1来标识，所有数据传输记录都以010101的模式来存储记录，两种状态也可认为就是一个日常生活中的开关，1标识开，0标识关。那么计算机中最小的数据单位也就是这里说的0或者1，这里我们称为bit（比特或者位），8个bit组成一个字节。当然计算机中也有八进制、十六进制的表示，这里暂时不展开讨论。只明确底层一个二进制的概念。 Hash算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法。 再引入一个hash表概念，计算机数据结构中，给定一个表M，关键字key，存在函数H(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为hash表。 简单理解hash算法就是这一种单向的加密，一个明文加密称为密文，不可逆推，只有加密过程，没有解密过程。说明了hash函数和hash表的概念，那么目前常用的hash算法有MD5（已被破解），SHA系列算法（比特币中使用sha-256算法）。SHA这里稍微提下（secure hash algorithm）这不是一个算法，这是一个hash函数集，现在有sha-224、sha-256、sha-384、sha-512等算法。在09年中本聪设计比特币的时候，当时sha-256被认为最安全的算法之一，故选择了sha-256，到目前为止还没有被破解。 解释到这里，可能会联想到，hash算法中key在计算后如果出现了同一位置，冲突的产生，这里简单说下几种冲突处理，如有兴趣可以查看hash算法论文。 1.拉链法：这种方法可以完全避免冲突，将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组t[0..m-1]。凡是散列地址为i的结点，均插入到以t为头指针的单链表中。t中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。 2.多哈希法：设计两种以上的hash函数，避免冲突，这个感觉比较不靠谱，但是从概率上来说多种hash函数还是降低了冲突的出现。 3.开放地址法：开放地址法有一个公式：Hi=(H(key)+di) MOD m i=1,2,...,k(k&lt;=m-1），其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,...m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,4,-4,9,-9,16,-16,...k*k,-k*k(k&lt;=m/2），称二次探测再散列。如果di取值可能为伪随机数列。称伪随机探测再散列。 &nbsp; &nbsp; Hash算法函数根据分类：加法hash、位运算hash、乘法hash、除法hash、查表hash等。 参考百度百科说的比较抽象，有兴趣可以深入了解下。 结合区块链，在区块链中很多地方都用到了hash函数： 1.区块链中节点的地址、公钥、私钥的计算。以地址为例：公钥经过一次SHA256计算，再进行一次RIPEMD160计算，得到一个公钥哈希（20字节\160比特），添加版本信息，再来两次SHA256运算、取前4比特字节，放到哈希公钥加版本信息后，再经过base58编码，最终得到地址。 2.merkle tree：是数据结构中的一种树结构，可以是二叉树，也可以是多叉树，他和数据结构中树的特点几乎一致，和普通树不同的是：merkle tree上的叶节点存放hash计算后的hash值，非叶节点是其对应的子节点串联的字符串的hash值。用于区块头和SPV认证中。 3.比特币中的挖矿，工作量证明（pow），计算的其实就是一个nonce，当这个随机数和其他散列过的数据合并时，产生一个比规定目标小（target）值。挖矿也可以理解一种快速不可逆的计算。SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET。 4.比特币中的bloom filter布隆过滤器，布隆过滤器基于hash函数的快速查找。解决了客户端检索的问题，原理是Bloom filter可以快速判断出某检索值一定不存在于某个指定的集合，从而可以过滤掉大量无关数据，减少客户端不必要的下载量。 简单介绍了HASH算法，和区块链中用到的HASH算法，区块链是多个技术的结合，结合各自特点出现的一种新的技术架构，HASH算法和加密技术为区块链的自证信任化及安全控制提供了基础，算法的碰撞和现在量子计算的发展，之前在区块链的安全性的文章中笔者有过说明，技术不断发展，肯定会有更适合的技术保障应用的实现。 参考：链接：https://www.zhihu.com/question/20820286/answer/88812256来源：知乎http://blog.sina.com.cn/s/blog_1799256a10102x3fh.html 阅读更多" />
<meta property="og:description" content="问题导读1.哈希算法在区块链的作用是什么？2.什么是哈希算法？3.哈希算法是否可逆？4.比特币采用的是什么哈希算法？作用在学习哈希算法前，我们需要知道哈希在区块链的作用哈希算法的作用如下：区块链通过哈希算法对一个交易区块中的交易信息进行加密，并把信息压缩成由一串数字和字母组成的散列字符串。区块链的哈希值能够唯一而精准地标识一个区块，区块链中任意节点通过简单的哈希计算都接获得这个区块的哈希值，计算出的哈希值没有变化也就意味着区块链中的信息没有被篡改。定义hash （哈希或散列）算法是信息技术领域非常基础也非常重要的技术。它能任意长度的二进制值（明文）映射为较短的固定长度的二进制值（hash 值），并且不同的明文很难映射为相同的 hash 值。例如计算一段话“hello blockchain world, this is yeasy@github”的 md5 hash 值为 89242549883a2ef85dc81b90fb606046。$ echo “hello blockchain world, this is yeasy@github”|md5&nbsp;89242549883a2ef85dc81b90fb606046&nbsp;这意味着我们只要对某文件进行 md5 hash 计算，得到结果为 89242549883a2ef85dc81b90fb606046，这就说明文件内容极大概率上就是 “hello blockchain world, this is yeasy@github”。可见，hash 的核心思想十分类似于基于内容的编址或命名。注：md5 是一个经典的 hash 算法，其和 SHA-1 算法都已被 证明 安全性不足应用于商业场景。一个优秀的 hash 算法，将能实现：正向快速：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。&nbsp;逆向困难：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。&nbsp;输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。&nbsp;冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。&nbsp;冲突避免有时候又被称为“抗碰撞性”。如果给定一个明文前提下，无法找到碰撞的另一个明文，称为“抗弱碰撞性”；如果无法找到任意两个明文，发生碰撞，则称算法具有“抗强碰撞性”。流行的算法目前流行的 hash 算法包括 MD5（已被证明不够安全）和 SHA-1，两者均以 MD4 为基础设计的。MD4（RFC 1320）是 MIT 的 Ronald L. Rivest 在 1990 年设计的，MD 是 Message Digest 的缩写。其输出为 128 位。MD4 并不足够安全。MD5（RFC 1321）是 Rivest 于1991年对 MD4 的改进版本。它对输入仍以 512 位分组，其输出是 128 位。MD5 比 MD4 复杂，并且计算速度要慢一点，但更安全一些。MD5 并不足够安全。SHA1 （Secure Hash Algorithm）是由 NIST NSA 设计，它的输出为长度 160 位的 hash 值，因此抗穷举性更好。SHA-1 设计时基于和 MD4 相同原理,并且模仿了该算法。为了提高安全性，NIST NSA 还设计出了 SHA-224、SHA-256、SHA-384，和 SHA-512 算法（统称为 SHA-2），跟 SHA-1 算法原理类似。性能一般的，hash 算法都是算力敏感型，意味着计算资源是瓶颈，主频越高的 CPU 进行 hash 的速度也越快。也有一些 hash 算法不是算力敏感的，例如 scrypt，需要大量的内存资源，节点不能通过简单的增加更多 CPU 来获得 hash 性能的提升。&nbsp;数字摘要顾名思义，数字摘要是对数字内容进行 hash 运算，获取唯一的摘要值来指代原始数字内容。数字摘要是解决确保内容没被篡改过的问题（利用 hash 函数的抗碰撞性特点）。数字摘要是 hash 算法最重要的一个用途。在网络上下载软件或文件时，往往同时会提供一个数字摘要值，用户下载下来原始文件可以自行进行计算，并同提供的摘要值进行比对，以确保内容没有被修改过。&nbsp;##########################对于哈希，我们可能认识还不够彻底，下面在补充一些内容解释1：把网址A，转换成数字1。网址B，转换成数字2。一个网址X，转换成数字N，根据数字N作为下标，就可以快速地查找出网址X的信息。这个转换的过程就是哈希算法。哈希算法并不是一种特定的算法，只要能完成这种转换的算法都是哈希算法。但是评定一个算法是否是好的哈希算法，要根据算法的离散度和冲突概率来评定。解释2：什么是哈希表和哈希算法？比如这里有一万首歌，给你一首新的歌X，要求你确认这首歌是否在那一万首歌之内。无疑，将一万首歌一个一个比对非常慢。但如果存在一种方式，能将一万首歌的每首数据浓缩到一个数字（称为哈希码）中，于是得到一万个数字，那么用同样的算法计算新的歌X的编码，看看歌X的编码是否在之前那一万个数字中，就能知道歌X是否在那一万首歌中。作为例子，如果要你组织那一万首歌，一个简单的哈希算法就是让歌曲所占硬盘的字节数作为哈希码。这样的话，你可以让一万首歌“按照大小排序”，然后遇到一首新的歌，只要看看新的歌的字节数是否和已有的一万首歌中的某一首的字节数相同，就知道新的歌是否在那一万首歌之内了。当然这个简单的哈希算法很容易出现两者同样大小的歌曲，这就是发送了碰撞。而好的哈希算法发生碰撞的几率非常小。解释3：这个HASH算法不是大学里数据结构课里那个HASH表的算法。这里的HASH算法是密码学的基础，比较常用的有MD5和SHA，最重要的两条性质，就是不可逆和无冲突。所谓不可逆，就是当你知道x的HASH值，无法求出x；所谓无冲突，就是当你知道x，无法求出一个y， 使x与y的HASH值相同。这两条性质在数学上都是不成立的。因为一个函数必然可逆，且由于HASH函数的值域有限，理论上会有无穷多个不同的原始值，它们的hash值都相同。MD5和SHA做到的，是求逆和求冲突在计算上不可能，也就是正向计算很容易，而反向计算即使穷尽人类所有的计算资源都做不到。我觉得密码学的几个算法（HASH、对称加密、公私钥）是计算机科学领域最伟大的发明之一，它授予了弱小的个人在强权面前信息的安全（而且是绝对的安全）。举个例子，只要你一直使用https与国外站点通讯，并注意对方的公钥没有被篡改，G**W可以断开你的连接，但它永远不可能知道你们的传输内容是什么。解释4： 解读区块链，区块链中HASH算法 区块链技术是一系列技术的结合，建立一种新的技术架构，hash算法是其中尤为重要的一块，这里简单对hash算法做一个说明。如果有理解不当的地方请及时指正。 讲hash算法之前先明确一个基础的计算机知识，计算机在底层机器码是采用二进制的模式，所谓二进制简单来说就是底层以0/1来标识，所有数据传输记录都以010101的模式来存储记录，两种状态也可认为就是一个日常生活中的开关，1标识开，0标识关。那么计算机中最小的数据单位也就是这里说的0或者1，这里我们称为bit（比特或者位），8个bit组成一个字节。当然计算机中也有八进制、十六进制的表示，这里暂时不展开讨论。只明确底层一个二进制的概念。 Hash算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法。 再引入一个hash表概念，计算机数据结构中，给定一个表M，关键字key，存在函数H(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为hash表。 简单理解hash算法就是这一种单向的加密，一个明文加密称为密文，不可逆推，只有加密过程，没有解密过程。说明了hash函数和hash表的概念，那么目前常用的hash算法有MD5（已被破解），SHA系列算法（比特币中使用sha-256算法）。SHA这里稍微提下（secure hash algorithm）这不是一个算法，这是一个hash函数集，现在有sha-224、sha-256、sha-384、sha-512等算法。在09年中本聪设计比特币的时候，当时sha-256被认为最安全的算法之一，故选择了sha-256，到目前为止还没有被破解。 解释到这里，可能会联想到，hash算法中key在计算后如果出现了同一位置，冲突的产生，这里简单说下几种冲突处理，如有兴趣可以查看hash算法论文。 1.拉链法：这种方法可以完全避免冲突，将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组t[0..m-1]。凡是散列地址为i的结点，均插入到以t为头指针的单链表中。t中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。 2.多哈希法：设计两种以上的hash函数，避免冲突，这个感觉比较不靠谱，但是从概率上来说多种hash函数还是降低了冲突的出现。 3.开放地址法：开放地址法有一个公式：Hi=(H(key)+di) MOD m i=1,2,...,k(k&lt;=m-1），其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,...m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,4,-4,9,-9,16,-16,...k*k,-k*k(k&lt;=m/2），称二次探测再散列。如果di取值可能为伪随机数列。称伪随机探测再散列。 &nbsp; &nbsp; Hash算法函数根据分类：加法hash、位运算hash、乘法hash、除法hash、查表hash等。 参考百度百科说的比较抽象，有兴趣可以深入了解下。 结合区块链，在区块链中很多地方都用到了hash函数： 1.区块链中节点的地址、公钥、私钥的计算。以地址为例：公钥经过一次SHA256计算，再进行一次RIPEMD160计算，得到一个公钥哈希（20字节\160比特），添加版本信息，再来两次SHA256运算、取前4比特字节，放到哈希公钥加版本信息后，再经过base58编码，最终得到地址。 2.merkle tree：是数据结构中的一种树结构，可以是二叉树，也可以是多叉树，他和数据结构中树的特点几乎一致，和普通树不同的是：merkle tree上的叶节点存放hash计算后的hash值，非叶节点是其对应的子节点串联的字符串的hash值。用于区块头和SPV认证中。 3.比特币中的挖矿，工作量证明（pow），计算的其实就是一个nonce，当这个随机数和其他散列过的数据合并时，产生一个比规定目标小（target）值。挖矿也可以理解一种快速不可逆的计算。SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET。 4.比特币中的bloom filter布隆过滤器，布隆过滤器基于hash函数的快速查找。解决了客户端检索的问题，原理是Bloom filter可以快速判断出某检索值一定不存在于某个指定的集合，从而可以过滤掉大量无关数据，减少客户端不必要的下载量。 简单介绍了HASH算法，和区块链中用到的HASH算法，区块链是多个技术的结合，结合各自特点出现的一种新的技术架构，HASH算法和加密技术为区块链的自证信任化及安全控制提供了基础，算法的碰撞和现在量子计算的发展，之前在区块链的安全性的文章中笔者有过说明，技术不断发展，肯定会有更适合的技术保障应用的实现。 参考：链接：https://www.zhihu.com/question/20820286/answer/88812256来源：知乎http://blog.sina.com.cn/s/blog_1799256a10102x3fh.html 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/16/20477178390645a3e22d076cd1af8b00.html" />
<meta property="og:url" content="https://mlh.app/2018/03/16/20477178390645a3e22d076cd1af8b00.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-16T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"问题导读1.哈希算法在区块链的作用是什么？2.什么是哈希算法？3.哈希算法是否可逆？4.比特币采用的是什么哈希算法？作用在学习哈希算法前，我们需要知道哈希在区块链的作用哈希算法的作用如下：区块链通过哈希算法对一个交易区块中的交易信息进行加密，并把信息压缩成由一串数字和字母组成的散列字符串。区块链的哈希值能够唯一而精准地标识一个区块，区块链中任意节点通过简单的哈希计算都接获得这个区块的哈希值，计算出的哈希值没有变化也就意味着区块链中的信息没有被篡改。定义hash （哈希或散列）算法是信息技术领域非常基础也非常重要的技术。它能任意长度的二进制值（明文）映射为较短的固定长度的二进制值（hash 值），并且不同的明文很难映射为相同的 hash 值。例如计算一段话“hello blockchain world, this is yeasy@github”的 md5 hash 值为 89242549883a2ef85dc81b90fb606046。$ echo “hello blockchain world, this is yeasy@github”|md5&nbsp;89242549883a2ef85dc81b90fb606046&nbsp;这意味着我们只要对某文件进行 md5 hash 计算，得到结果为 89242549883a2ef85dc81b90fb606046，这就说明文件内容极大概率上就是 “hello blockchain world, this is yeasy@github”。可见，hash 的核心思想十分类似于基于内容的编址或命名。注：md5 是一个经典的 hash 算法，其和 SHA-1 算法都已被 证明 安全性不足应用于商业场景。一个优秀的 hash 算法，将能实现：正向快速：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。&nbsp;逆向困难：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。&nbsp;输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。&nbsp;冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。&nbsp;冲突避免有时候又被称为“抗碰撞性”。如果给定一个明文前提下，无法找到碰撞的另一个明文，称为“抗弱碰撞性”；如果无法找到任意两个明文，发生碰撞，则称算法具有“抗强碰撞性”。流行的算法目前流行的 hash 算法包括 MD5（已被证明不够安全）和 SHA-1，两者均以 MD4 为基础设计的。MD4（RFC 1320）是 MIT 的 Ronald L. Rivest 在 1990 年设计的，MD 是 Message Digest 的缩写。其输出为 128 位。MD4 并不足够安全。MD5（RFC 1321）是 Rivest 于1991年对 MD4 的改进版本。它对输入仍以 512 位分组，其输出是 128 位。MD5 比 MD4 复杂，并且计算速度要慢一点，但更安全一些。MD5 并不足够安全。SHA1 （Secure Hash Algorithm）是由 NIST NSA 设计，它的输出为长度 160 位的 hash 值，因此抗穷举性更好。SHA-1 设计时基于和 MD4 相同原理,并且模仿了该算法。为了提高安全性，NIST NSA 还设计出了 SHA-224、SHA-256、SHA-384，和 SHA-512 算法（统称为 SHA-2），跟 SHA-1 算法原理类似。性能一般的，hash 算法都是算力敏感型，意味着计算资源是瓶颈，主频越高的 CPU 进行 hash 的速度也越快。也有一些 hash 算法不是算力敏感的，例如 scrypt，需要大量的内存资源，节点不能通过简单的增加更多 CPU 来获得 hash 性能的提升。&nbsp;数字摘要顾名思义，数字摘要是对数字内容进行 hash 运算，获取唯一的摘要值来指代原始数字内容。数字摘要是解决确保内容没被篡改过的问题（利用 hash 函数的抗碰撞性特点）。数字摘要是 hash 算法最重要的一个用途。在网络上下载软件或文件时，往往同时会提供一个数字摘要值，用户下载下来原始文件可以自行进行计算，并同提供的摘要值进行比对，以确保内容没有被修改过。&nbsp;##########################对于哈希，我们可能认识还不够彻底，下面在补充一些内容解释1：把网址A，转换成数字1。网址B，转换成数字2。一个网址X，转换成数字N，根据数字N作为下标，就可以快速地查找出网址X的信息。这个转换的过程就是哈希算法。哈希算法并不是一种特定的算法，只要能完成这种转换的算法都是哈希算法。但是评定一个算法是否是好的哈希算法，要根据算法的离散度和冲突概率来评定。解释2：什么是哈希表和哈希算法？比如这里有一万首歌，给你一首新的歌X，要求你确认这首歌是否在那一万首歌之内。无疑，将一万首歌一个一个比对非常慢。但如果存在一种方式，能将一万首歌的每首数据浓缩到一个数字（称为哈希码）中，于是得到一万个数字，那么用同样的算法计算新的歌X的编码，看看歌X的编码是否在之前那一万个数字中，就能知道歌X是否在那一万首歌中。作为例子，如果要你组织那一万首歌，一个简单的哈希算法就是让歌曲所占硬盘的字节数作为哈希码。这样的话，你可以让一万首歌“按照大小排序”，然后遇到一首新的歌，只要看看新的歌的字节数是否和已有的一万首歌中的某一首的字节数相同，就知道新的歌是否在那一万首歌之内了。当然这个简单的哈希算法很容易出现两者同样大小的歌曲，这就是发送了碰撞。而好的哈希算法发生碰撞的几率非常小。解释3：这个HASH算法不是大学里数据结构课里那个HASH表的算法。这里的HASH算法是密码学的基础，比较常用的有MD5和SHA，最重要的两条性质，就是不可逆和无冲突。所谓不可逆，就是当你知道x的HASH值，无法求出x；所谓无冲突，就是当你知道x，无法求出一个y， 使x与y的HASH值相同。这两条性质在数学上都是不成立的。因为一个函数必然可逆，且由于HASH函数的值域有限，理论上会有无穷多个不同的原始值，它们的hash值都相同。MD5和SHA做到的，是求逆和求冲突在计算上不可能，也就是正向计算很容易，而反向计算即使穷尽人类所有的计算资源都做不到。我觉得密码学的几个算法（HASH、对称加密、公私钥）是计算机科学领域最伟大的发明之一，它授予了弱小的个人在强权面前信息的安全（而且是绝对的安全）。举个例子，只要你一直使用https与国外站点通讯，并注意对方的公钥没有被篡改，G**W可以断开你的连接，但它永远不可能知道你们的传输内容是什么。解释4： 解读区块链，区块链中HASH算法 区块链技术是一系列技术的结合，建立一种新的技术架构，hash算法是其中尤为重要的一块，这里简单对hash算法做一个说明。如果有理解不当的地方请及时指正。 讲hash算法之前先明确一个基础的计算机知识，计算机在底层机器码是采用二进制的模式，所谓二进制简单来说就是底层以0/1来标识，所有数据传输记录都以010101的模式来存储记录，两种状态也可认为就是一个日常生活中的开关，1标识开，0标识关。那么计算机中最小的数据单位也就是这里说的0或者1，这里我们称为bit（比特或者位），8个bit组成一个字节。当然计算机中也有八进制、十六进制的表示，这里暂时不展开讨论。只明确底层一个二进制的概念。 Hash算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法。 再引入一个hash表概念，计算机数据结构中，给定一个表M，关键字key，存在函数H(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为hash表。 简单理解hash算法就是这一种单向的加密，一个明文加密称为密文，不可逆推，只有加密过程，没有解密过程。说明了hash函数和hash表的概念，那么目前常用的hash算法有MD5（已被破解），SHA系列算法（比特币中使用sha-256算法）。SHA这里稍微提下（secure hash algorithm）这不是一个算法，这是一个hash函数集，现在有sha-224、sha-256、sha-384、sha-512等算法。在09年中本聪设计比特币的时候，当时sha-256被认为最安全的算法之一，故选择了sha-256，到目前为止还没有被破解。 解释到这里，可能会联想到，hash算法中key在计算后如果出现了同一位置，冲突的产生，这里简单说下几种冲突处理，如有兴趣可以查看hash算法论文。 1.拉链法：这种方法可以完全避免冲突，将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组t[0..m-1]。凡是散列地址为i的结点，均插入到以t为头指针的单链表中。t中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。 2.多哈希法：设计两种以上的hash函数，避免冲突，这个感觉比较不靠谱，但是从概率上来说多种hash函数还是降低了冲突的出现。 3.开放地址法：开放地址法有一个公式：Hi=(H(key)+di) MOD m i=1,2,...,k(k&lt;=m-1），其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,...m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,4,-4,9,-9,16,-16,...k*k,-k*k(k&lt;=m/2），称二次探测再散列。如果di取值可能为伪随机数列。称伪随机探测再散列。 &nbsp; &nbsp; Hash算法函数根据分类：加法hash、位运算hash、乘法hash、除法hash、查表hash等。 参考百度百科说的比较抽象，有兴趣可以深入了解下。 结合区块链，在区块链中很多地方都用到了hash函数： 1.区块链中节点的地址、公钥、私钥的计算。以地址为例：公钥经过一次SHA256计算，再进行一次RIPEMD160计算，得到一个公钥哈希（20字节\\160比特），添加版本信息，再来两次SHA256运算、取前4比特字节，放到哈希公钥加版本信息后，再经过base58编码，最终得到地址。 2.merkle tree：是数据结构中的一种树结构，可以是二叉树，也可以是多叉树，他和数据结构中树的特点几乎一致，和普通树不同的是：merkle tree上的叶节点存放hash计算后的hash值，非叶节点是其对应的子节点串联的字符串的hash值。用于区块头和SPV认证中。 3.比特币中的挖矿，工作量证明（pow），计算的其实就是一个nonce，当这个随机数和其他散列过的数据合并时，产生一个比规定目标小（target）值。挖矿也可以理解一种快速不可逆的计算。SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET。 4.比特币中的bloom filter布隆过滤器，布隆过滤器基于hash函数的快速查找。解决了客户端检索的问题，原理是Bloom filter可以快速判断出某检索值一定不存在于某个指定的集合，从而可以过滤掉大量无关数据，减少客户端不必要的下载量。 简单介绍了HASH算法，和区块链中用到的HASH算法，区块链是多个技术的结合，结合各自特点出现的一种新的技术架构，HASH算法和加密技术为区块链的自证信任化及安全控制提供了基础，算法的碰撞和现在量子计算的发展，之前在区块链的安全性的文章中笔者有过说明，技术不断发展，肯定会有更适合的技术保障应用的实现。 参考：链接：https://www.zhihu.com/question/20820286/answer/88812256来源：知乎http://blog.sina.com.cn/s/blog_1799256a10102x3fh.html 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/16/20477178390645a3e22d076cd1af8b00.html","headline":"区块链概念1：Hash 算法","dateModified":"2018-03-16T00:00:00+08:00","datePublished":"2018-03-16T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/16/20477178390645a3e22d076cd1af8b00.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链概念1：Hash 算法</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div class="rich_media_content" id="js_content"> 
   <p><span style="font-weight:700;color:rgb(68,68,68);">问题导读</span><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);"><span style="color:#ff0000;">1.哈希算法在区块链的作用是什么？</span></span><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);"><span style="color:#ff0000;">2.什么是哈希算法？</span></span><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);"><span style="color:#ff0000;">3.哈希算法是否可逆？</span></span><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);"><span style="color:#ff0000;">4.比特币采用的是什么哈希算法？</span></span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);">作用</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">在学习哈希算法前，我们需要知道哈希在区块链的作用</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">哈希算法的作用如下：</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">区块链通过哈希算法对一个交易区块中的交易信息进行加密，并把信息压缩成由一串数字和字母组成的散列字符串。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">区块链的哈希值能够唯一而精准地标识一个区块，区块链中任意节点通过简单的哈希计算都接获得这个区块的哈希值，计算出的哈希值没有变化也就意味着区块链中的信息没有被篡改。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);">定义</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">hash （哈希或散列）算法是信息技术领域非常基础也非常重要的技术。它能任意长度的二进制值（明文）映射为较短的固定长度的二进制值（hash 值），并且不同的明文很难映射为相同的 hash 值。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">例如计算一段话“hello blockchain world, this is yeasy@github”的 md5 hash 值为 89242549883a2ef85dc81b90fb606046。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">$ echo “hello blockchain world, this is yeasy@github”|md5&nbsp;</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">89242549883a2ef85dc81b90fb606046&nbsp;</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">这意味着我们只要对某文件进行 md5 hash 计算，得到结果为 89242549883a2ef85dc81b90fb606046，这就说明文件内容极大概率上就是 “hello blockchain world, this is yeasy@github”。可见，hash 的核心思想十分类似于基于内容的编址或命名。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">注：md5 是一个经典的 hash 算法，其和 SHA-1 算法都已被 证明 安全性不足应用于商业场景。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:#ff00ff;">一个优秀的 hash 算法，将能实现：</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">正向快速：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。&nbsp;</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">逆向困难：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。&nbsp;</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。&nbsp;</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。&nbsp;</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">冲突避免有时候又被称为“抗碰撞性”。如果给定一个明文前提下，无法找到碰撞的另一个明文，称为“抗弱碰撞性”；如果无法找到任意两个明文，发生碰撞，则称算法具有“抗强碰撞性”。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);">流行的算法</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">目前流行的 hash 算法包括 MD5（已被证明不够安全）和 SHA-1，两者均以 MD4 为基础设计的。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">MD4（RFC 1320）是 MIT 的 Ronald L. Rivest 在 1990 年设计的，MD 是 Message Digest 的缩写。其输出为 128 位。MD4 并不足够安全。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">MD5（RFC 1321）是 Rivest 于1991年对 MD4 的改进版本。它对输入仍以 512 位分组，其输出是 128 位。MD5 比 MD4 复杂，并且计算速度要慢一点，但更安全一些。MD5 并不足够安全。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">SHA1 （Secure Hash Algorithm）是由 NIST NSA 设计，它的输出为长度 160 位的 hash 值，因此抗穷举性更好。SHA-1 设计时基于和 MD4 相同原理,并且模仿了该算法。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">为了提高安全性，NIST NSA 还设计出了 SHA-224、SHA-256、SHA-384，和 SHA-512 算法（统称为 SHA-2），跟 SHA-1 算法原理类似。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);">性能</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">一般的，hash 算法都是算力敏感型，意味着计算资源是瓶颈，主频越高的 CPU 进行 hash 的速度也越快。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">也有一些 hash 算法不是算力敏感的，例如 scrypt，需要大量的内存资源，节点不能通过简单的增加更多 CPU 来获得 hash 性能的提升。&nbsp;</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">数字摘要</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">顾名思义，数字摘要是对数字内容进行 hash 运算，获取唯一的摘要值来指代原始数字内容。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">数字摘要是解决确保内容没被篡改过的问题（利用 hash 函数的抗碰撞性特点）。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">数字摘要是 hash 算法最重要的一个用途。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">在网络上下载软件或文件时，往往同时会提供一个数字摘要值，用户下载下来原始文件可以自行进行计算，并同提供的摘要值进行比对，以确保内容没有被修改过。&nbsp;</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">##########################</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">对于哈希，我们可能认识还不够彻底，下面在补充一些内容</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);">解释1：</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">把网址A，转换成数字1。网址B，转换成数字2。一个网址X，转换成数字N，根据数字N作为下标，就可以快速地查找出网址X的信息。这个转换的过程就是哈希算法。哈希算法并不是一种特定的算法，只要能完成这种转换的算法都是哈希算法。但是评定一个算法是否是好的哈希算法，要根据算法的离散度和冲突概率来评定。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);">解释2：</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">什么是哈希表和哈希算法？比如这里有一万首歌，给你一首新的歌X，要求你确认这首歌是否在那一万首歌之内。无疑，将一万首歌一个一个比对非常慢。但如果存在一种方式，能将一万首歌的每首数据浓缩到一个数字（称为哈希码）中，于是得到一万个数字，那么用同样的算法计算新的歌X的编码，看看歌X的编码是否在之前那一万个数字中，就能知道歌X是否在那一万首歌中。作为例子，如果要你组织那一万首歌，一个简单的哈希算法就是让歌曲所占硬盘的字节数作为哈希码。这样的话，你可以让一万首歌“按照大小排序”，然后遇到一首新的歌，只要看看新的歌的字节数是否和已有的一万首歌中的某一首的字节数相同，就知道新的歌是否在那一万首歌之内了。当然这个简单的哈希算法很容易出现两者同样大小的歌曲，这就是发送了碰撞。而好的哈希算法发生碰撞的几率非常小。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);">解释3：</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">这个HASH算法不是大学里数据结构课里那个HASH表的算法。这里的HASH算法是密码学的基础，比较常用的有MD5和SHA，最重要的两条性质，就是不可逆和无冲突。所谓不可逆，就是当你知道x的HASH值，无法求出x；所谓无冲突，就是当你知道x，无法求出一个y， 使x与y的HASH值相同。这两条性质在数学上都是不成立的。因为一个函数必然可逆，且由于HASH函数的值域有限，理论上会有无穷多个不同的原始值，它们的hash值都相同。MD5和SHA做到的，是求逆和求冲突在计算上不可能，也就是正向计算很容易，而反向计算即使穷尽人类所有的计算资源都做不到。我觉得密码学的几个算法（HASH、对称加密、公私钥）是计算机科学领域最伟大的发明之一，它授予了弱小的个人在强权面前信息的安全（而且是绝对的安全）。举个例子，只要你一直使用https与国外站点通讯，并注意对方的公钥没有被篡改，G**W可以断开你的连接，但它永远不可能知道你们的传输内容是什么。</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="font-weight:700;color:rgb(68,68,68);">解释4：</span><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"></p>
   <p style="color:rgb(68,68,68);"><span style="color:#ff00ff;"><span style="font-weight:700;">解读区块链，区块链中HASH算法</span></span></p>
   <p style="color:rgb(68,68,68);">区块链技术是一系列技术的结合，建立一种新的技术架构，hash算法是其中尤为重要的一块，这里简单对hash算法做一个说明。如果有理解不当的地方请及时指正。</p>
   <p style="color:rgb(68,68,68);">讲hash算法之前先明确一个基础的计算机知识，计算机在底层机器码是采用二进制的模式，所谓二进制简单来说就是底层以0/1来标识，所有数据传输记录都以010101的模式来存储记录，两种状态也可认为就是一个日常生活中的开关，1标识开，0标识关。那么计算机中最小的数据单位也就是这里说的0或者1，这里我们称为bit（比特或者位），8个bit组成一个字节。当然计算机中也有八进制、十六进制的表示，这里暂时不展开讨论。只明确底层一个二进制的概念。</p>
   <p><br style="color:rgb(68,68,68);"></p>
   <p style="color:rgb(68,68,68);">Hash算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法。</p>
   <p style="color:rgb(68,68,68);">再引入一个hash表概念，计算机数据结构中，给定一个表M，关键字key，存在函数H(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为hash表。</p>
   <p><br style="color:rgb(68,68,68);"></p>
   <p style="color:rgb(68,68,68);">简单理解hash算法就是这一种单向的加密，一个明文加密称为密文，不可逆推，只有加密过程，没有解密过程。说明了hash函数和hash表的概念，那么目前常用的hash算法有MD5（已被破解），SHA系列算法（比特币中使用sha-256算法）。SHA这里稍微提下（secure hash algorithm）这不是一个算法，这是一个hash函数集，现在有sha-224、sha-256、sha-384、sha-512等算法。在09年中本聪设计比特币的时候，当时sha-256被认为最安全的算法之一，故选择了sha-256，到目前为止还没有被破解。</p>
   <p style="color:rgb(68,68,68);">解释到这里，可能会联想到，hash算法中key在计算后如果出现了同一位置，冲突的产生，这里简单说下几种冲突处理，如有兴趣可以查看hash算法论文。</p>
   <p style="color:rgb(68,68,68);">1.拉链法：这种方法可以完全避免冲突，将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组t[0..m-1]。凡是散列地址为i的结点，均插入到以t为头指针的单链表中。t中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。</p>
   <p><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"></p>
   <p style="color:rgb(68,68,68);">2.多哈希法：设计两种以上的hash函数，避免冲突，这个感觉比较不靠谱，但是从概率上来说多种hash函数还是降低了冲突的出现。</p>
   <p style="color:rgb(68,68,68);">3.开放地址法：开放地址法有一个公式：Hi=(H(key)+di) MOD m i=1,2,...,k(k&lt;=m-1），其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,...m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,4,-4,9,-9,16,-16,...k*k,-k*k(k&lt;=m/2），称二次探测再散列。如果di取值可能为伪随机数列。称伪随机探测再散列。</p>
   <p style="color:rgb(68,68,68);">&nbsp; &nbsp; Hash算法函数根据分类：加法hash、位运算hash、乘法hash、除法hash、查表hash等。</p>
   <p style="color:rgb(68,68,68);">参考百度百科说的比较抽象，有兴趣可以深入了解下。</p>
   <p style="color:rgb(68,68,68);">结合区块链，在区块链中很多地方都用到了hash函数：</p>
   <p style="color:rgb(68,68,68);">1.区块链中节点的地址、公钥、私钥的计算。以地址为例：公钥经过一次SHA256计算，再进行一次RIPEMD160计算，得到一个公钥哈希（20字节\160比特），添加版本信息，再来两次SHA256运算、取前4比特字节，放到哈希公钥加版本信息后，再经过base58编码，最终得到地址。</p>
   <p style="color:rgb(68,68,68);"><img class="zoom img_loading" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/RtvkY2NHvicrtuvpgzFtmtKGI83uZiaRQrBvtscib8qNZ8icXfibk642cQGZicebPdEfWgvApibFlnibogKibicMo93W1ozg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="color:rgb(68,68,68);"><br></p>
   <p><br style="color:rgb(68,68,68);"></p>
   <p style="color:rgb(68,68,68);">2.merkle tree：是数据结构中的一种树结构，可以是二叉树，也可以是多叉树，他和数据结构中树的特点几乎一致，和普通树不同的是：merkle tree上的叶节点存放hash计算后的hash值，非叶节点是其对应的子节点串联的字符串的hash值。用于区块头和SPV认证中。</p>
   <p><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"></p>
   <p style="color:rgb(68,68,68);">3.比特币中的挖矿，工作量证明（pow），计算的其实就是一个nonce，当这个随机数和其他散列过的数据合并时，产生一个比规定目标小（target）值。挖矿也可以理解一种快速不可逆的计算。SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET。</p>
   <p><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"></p>
   <p style="color:rgb(68,68,68);">4.比特币中的bloom filter布隆过滤器，布隆过滤器基于hash函数的快速查找。解决了客户端检索的问题，原理是Bloom filter可以快速判断出某检索值一定不存在于某个指定的集合，从而可以过滤掉大量无关数据，减少客户端不必要的下载量。</p>
   <p><br style="color:rgb(68,68,68);"></p>
   <p style="color:rgb(68,68,68);">简单介绍了HASH算法，和区块链中用到的HASH算法，区块链是多个技术的结合，结合各自特点出现的一种新的技术架构，HASH算法和加密技术为区块链的自证信任化及安全控制提供了基础，算法的碰撞和现在量子计算的发展，之前在区块链的安全性的文章中笔者有过说明，技术不断发展，肯定会有更适合的技术保障应用的实现。</p>
   <p><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">参考：</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">链接：https://www.zhihu.com/question/20820286/answer/88812256</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">来源：知乎</span><br style="color:rgb(68,68,68);"><span style="color:rgb(68,68,68);">http://blog.sina.com.cn/s/blog_1799256a10102x3fh.html</span></p>
   <p><br></p> 
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/c36qUCnS2zuqF6/article/details/79580022,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/c36qUCnS2zuqF6/article/details/79580022,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
