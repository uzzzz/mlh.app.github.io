<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Python创建一个简单的区块链 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Python创建一个简单的区块链" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="区块链（Blockchain）是一种分布式账本（listributed ledger），它是一种仅供增加（append-only），内容不可变（immutable）的有序（ordered）链式数据结构，该数据结构由网络中的一系列节点共同维护，并且这些节点之间互不信任。区块链是如今盛行的Bitcoin，Ethereum等数字货币背后的底层技术，本文通过Python从0开始创建一个简单的区块链模型，对于理解区块链基本原理很有帮助。 准备 所需条件： python3.6，pip，flask，requests，cURL flask和requests可通过如下命令下载： pip install falsk, requests 创建文件blockchain.py，所有代码均写在此文件中。 开始 代码主要分为两部分，首先是一个Blockchain类，其中包含区块链的属性和特性方法；然后是相应的路由处理方法，以flask服务器作为区块链网络中的一个节点来处理客户端请求对区块链完成相应操作，以及和网络中其它节点进行交互。 相关数据结构 block：区块，以dict表示，包含属性索引（index），时间戳（timestamp），交易集合（transactions），工作量证明（proof），上一个区块的hash值（previous_hash）。其中，previous_hash用于链接这些有序区块，并且保证其中内容不被更改。 tansaction：交易，dict形式，存放于区块中，包含属性：发出者（sender），接收者（recipient），数额（amount） Blockchain类的属性 chain：区块链中所有区块的list集合，每个元素都是一个block current_transactions: 当前即将加入区块的交易集合，list表示 nodes：当前节点的其他相邻节点的set集合 Blockchain类的方法 new_block()：生成新的区块，接收工作量证明proof作为参数，将block加入chain中，并且清空当前交易集合，返回生成的block。在__init__方法中会自动生成一个创世区块（genesis block），初始proof为100，previous_hash为’1’ new_transaction()：生成新的交易，接收三个参数：发出者，接受者，数额，并将交易加入到当前交易集合中，返回该交易将会加入的区块的索引 hash()：生成区块的hash值，接收一个block作为参数，首先利用json.dumps()将block对象转化为json格式，然后利用hashlib.sha256()计算其hash值 proof_of_work()：工作量证明算法（PoW），通过循环找一个数p，使得与前一个区块的proof拼接起来的字符串的hash值的前4位为’0000’，接收上一个区块的proof作为参数，返回找到的符合要求的proof register_node()：注册节点，接收一个URL作为参数，利用urllib.parse.urlparse()解析该地址，获取其中的内容ip:port，并加入到相邻节点集合nodes中 resolve_confict()： 共识算法（consensus）解决冲突，即使用网络中最长且有效的链。遍历其他节点的集合nodes（集合中保存了这些节点的ip和port），利用requests.get()通过路由/chain获取到这些节点的链chain。然后先进行长度判断，如果某节点的链长大于当前节点的链长；则对该链进行有效判断，即遍历该链，判断每个区块的previous_hash和proof值是否满足要求。如果该链更长且有效，则用该chain替换掉自身的链，解决冲突。 URL处理函数 用户提交的数据和服务器的响应数据均使用json格式，服务器利用Flask.request.get_json()获取表单中的json数据，利用Flask.jsonify()将response数据转化为json格式返回。 mine()：挖矿，对应路由为/mine ，请求方法为GET。主要完成任务有：计算工作量证明，通过新建交易给予矿工（自身节点）1个币的奖励，新增一个区块并加入链中。 new_transaction()：新增交易，对应路由为/transactions/new，请求方法为POST。通过request.get_json()获取用户提交的json格式表单，判断交易是否符合要求，调用类中添加交易的方法。 full_chain()：查看整条链，对应路由为/chain，请求方法为GET。 register_nodes()： 注册节点，对应路由为/node/register，方法为POST。接收提交的节点集合，调用register_node()加入这些节点，返回nodes集合 consensus()：共识，对应路由为/node/resolve，方法为GET。调用resolve_conflict()解决冲突，返回共识之后的链。 全部代码 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request from urllib.parse import urlparse import requests import sys class Blockchain(object): def __init__(self): # 当前即将加入区块的交易集合 self.current_transactions = [] self.chain = [] self.nodes = set() # create the genesis block self.new_block(proof=100, previous_hash=&#39;1&#39;) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; 生成新块 :param proof: &lt;int&gt; The proof given by the PoW algorithm :param previous_hash: （Optional) &lt;str&gt; hash of Previous block :return: &lt;dict&gt; new block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, # a list &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # 当前交易集合在加入区块后清空 self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; 生成新的交易信息，将加入下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): # Return the last block in the chain return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; 生成区块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; the hash value &quot;&quot;&quot; # we must make sure that the dict is ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() def proof_of_work(self, last_proof): &quot;&quot;&quot; 工作量证明： - 查找一个 p&#39; 使得 hash(pp&#39;)以4个0开头 - p是上一个块的证明， p&#39; 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; 验证证明：是否hash(last_proof, proof) :param proof: &lt;int&gt; previous proof :param last_proof: &lt;int&gt; current proof :return: &lt;bool&gt; True if correct, Flase if not. &quot;&quot;&quot; guess_hash = hashlib.sha256((str(last_proof) + str(proof)).encode()).hexdigest() return guess_hash[:4] == &#39;0000&#39; def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. EG. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; node = urlparse(address).netloc self.nodes.add(node) def valid_chain(self, chain): &quot;&quot;&quot; Determine if a blockchain is valid :param chain: &lt;list&gt; a blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; for i in range(1, len(chain)): block = chain[i] previous_block = chain[i-1] if self.hash(previous_block) != block[&#39;previous_hash&#39;]: return False if not self.valid_proof(previous_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False return True def resolve_conflict(self): &quot;&quot;&quot; 共识算法解决冲突，使用网络中最长且有效的链 :param chain: &lt;list&gt; other blockchain :return: &lt;bool&gt; True 链被取代，False 链未被取代 &quot;&quot;&quot; flag = False for node in self.nodes: r = requests.get(&#39;http://{}/chain&#39;.format(node)) if r.status_code == 200: chain = r.json()[&#39;chain&#39;] length = r.json()[&#39;length&#39;] if length &gt; len(self.chain) and self.valid_chain(chain): self.chain = chain flag = True return flag # Instantiate our Node app = Flask(__name__) # Generate a globally unique address for this Node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # Instantiate the Blockchain blockchain = Blockchain() @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the PoW algorithm to get the next proof... last_proof = blockchain.last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # 给工作量证明的节点提供奖励， # 发送者为 &#39;0&#39; 表面是新挖出的币 blockchain.new_transaction( sender=&#39;0&#39;, recipient=node_identifier, amount=1, ) block = blockchain.new_block(proof) response = { &#39;message&#39;: &#39;New Block Forged&#39;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): # json.loads(request.get_data()) values = request.get_json() # Check that the required fields are in POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: &#39;Transaction will be added to Block {}&#39;.format(index)} return jsonify(response), 201 @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 @app.route(&#39;/node/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes) } return jsonify(response), 201 @app.route(&#39;/node/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): is_replaced = blockchain.resolve_conflict() if is_replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: myport = 5000 if len(sys.argv) &gt; 1: myport = int(sys.argv[1]) app.run(host=&#39;0.0.0.0&#39;, port=myport) 测试 在一台机器开启多个终端分别运行源代码，通过监听多个不同的端口来模拟多节点网络。这里模拟包含两个节点的区块链网络。 python3 blockchain.py 5000 #在终端1运行 python3 blockchain.py 5001 #在终端2运行 挖矿：新建另一个终端3进行通过curl命令进行操作。对节点1进行一次挖矿操作，此时链中有两个区块。 curl http://127.0.0.1:5000/mine 发送交易：向节点1发送一个交易。 curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;sender&quot;: &quot;5000&quot;, &quot;recipient&quot;: &quot;5001&quot;, &quot;amount&quot;: 100}&#39; &quot;http://127.0.0.1:5000/transactions/new&quot; 查看区块链：先进行一次mine操作，使刚刚发送的交易进入第3个区块，然后查看整个区块链的数据信息，此时该链有3个区块，其中第3个区块包含两条交易。 curl http://127.0.0.1:5000/mine curl http://127.0.0.1:5000/chain 注册节点：向节点2（端口为5001，1个block）发送节点1的地址（端口为5000，3个block）。 curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;nodes&quot;: [&quot;http://127.0.0.1:5000&quot;]}&#39; &quot;http://127.0.0.1:5001/node/register&quot; 共识：使节点2完成与相邻节点的共识，用节点1的链（长度为3）替换节点2的链（长度为1）。 curl http://127.0.0.1:5001/node/resolve 参考文章：https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/ 阅读更多" />
<meta property="og:description" content="区块链（Blockchain）是一种分布式账本（listributed ledger），它是一种仅供增加（append-only），内容不可变（immutable）的有序（ordered）链式数据结构，该数据结构由网络中的一系列节点共同维护，并且这些节点之间互不信任。区块链是如今盛行的Bitcoin，Ethereum等数字货币背后的底层技术，本文通过Python从0开始创建一个简单的区块链模型，对于理解区块链基本原理很有帮助。 准备 所需条件： python3.6，pip，flask，requests，cURL flask和requests可通过如下命令下载： pip install falsk, requests 创建文件blockchain.py，所有代码均写在此文件中。 开始 代码主要分为两部分，首先是一个Blockchain类，其中包含区块链的属性和特性方法；然后是相应的路由处理方法，以flask服务器作为区块链网络中的一个节点来处理客户端请求对区块链完成相应操作，以及和网络中其它节点进行交互。 相关数据结构 block：区块，以dict表示，包含属性索引（index），时间戳（timestamp），交易集合（transactions），工作量证明（proof），上一个区块的hash值（previous_hash）。其中，previous_hash用于链接这些有序区块，并且保证其中内容不被更改。 tansaction：交易，dict形式，存放于区块中，包含属性：发出者（sender），接收者（recipient），数额（amount） Blockchain类的属性 chain：区块链中所有区块的list集合，每个元素都是一个block current_transactions: 当前即将加入区块的交易集合，list表示 nodes：当前节点的其他相邻节点的set集合 Blockchain类的方法 new_block()：生成新的区块，接收工作量证明proof作为参数，将block加入chain中，并且清空当前交易集合，返回生成的block。在__init__方法中会自动生成一个创世区块（genesis block），初始proof为100，previous_hash为’1’ new_transaction()：生成新的交易，接收三个参数：发出者，接受者，数额，并将交易加入到当前交易集合中，返回该交易将会加入的区块的索引 hash()：生成区块的hash值，接收一个block作为参数，首先利用json.dumps()将block对象转化为json格式，然后利用hashlib.sha256()计算其hash值 proof_of_work()：工作量证明算法（PoW），通过循环找一个数p，使得与前一个区块的proof拼接起来的字符串的hash值的前4位为’0000’，接收上一个区块的proof作为参数，返回找到的符合要求的proof register_node()：注册节点，接收一个URL作为参数，利用urllib.parse.urlparse()解析该地址，获取其中的内容ip:port，并加入到相邻节点集合nodes中 resolve_confict()： 共识算法（consensus）解决冲突，即使用网络中最长且有效的链。遍历其他节点的集合nodes（集合中保存了这些节点的ip和port），利用requests.get()通过路由/chain获取到这些节点的链chain。然后先进行长度判断，如果某节点的链长大于当前节点的链长；则对该链进行有效判断，即遍历该链，判断每个区块的previous_hash和proof值是否满足要求。如果该链更长且有效，则用该chain替换掉自身的链，解决冲突。 URL处理函数 用户提交的数据和服务器的响应数据均使用json格式，服务器利用Flask.request.get_json()获取表单中的json数据，利用Flask.jsonify()将response数据转化为json格式返回。 mine()：挖矿，对应路由为/mine ，请求方法为GET。主要完成任务有：计算工作量证明，通过新建交易给予矿工（自身节点）1个币的奖励，新增一个区块并加入链中。 new_transaction()：新增交易，对应路由为/transactions/new，请求方法为POST。通过request.get_json()获取用户提交的json格式表单，判断交易是否符合要求，调用类中添加交易的方法。 full_chain()：查看整条链，对应路由为/chain，请求方法为GET。 register_nodes()： 注册节点，对应路由为/node/register，方法为POST。接收提交的节点集合，调用register_node()加入这些节点，返回nodes集合 consensus()：共识，对应路由为/node/resolve，方法为GET。调用resolve_conflict()解决冲突，返回共识之后的链。 全部代码 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request from urllib.parse import urlparse import requests import sys class Blockchain(object): def __init__(self): # 当前即将加入区块的交易集合 self.current_transactions = [] self.chain = [] self.nodes = set() # create the genesis block self.new_block(proof=100, previous_hash=&#39;1&#39;) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; 生成新块 :param proof: &lt;int&gt; The proof given by the PoW algorithm :param previous_hash: （Optional) &lt;str&gt; hash of Previous block :return: &lt;dict&gt; new block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, # a list &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # 当前交易集合在加入区块后清空 self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; 生成新的交易信息，将加入下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): # Return the last block in the chain return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; 生成区块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; the hash value &quot;&quot;&quot; # we must make sure that the dict is ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() def proof_of_work(self, last_proof): &quot;&quot;&quot; 工作量证明： - 查找一个 p&#39; 使得 hash(pp&#39;)以4个0开头 - p是上一个块的证明， p&#39; 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; 验证证明：是否hash(last_proof, proof) :param proof: &lt;int&gt; previous proof :param last_proof: &lt;int&gt; current proof :return: &lt;bool&gt; True if correct, Flase if not. &quot;&quot;&quot; guess_hash = hashlib.sha256((str(last_proof) + str(proof)).encode()).hexdigest() return guess_hash[:4] == &#39;0000&#39; def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. EG. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; node = urlparse(address).netloc self.nodes.add(node) def valid_chain(self, chain): &quot;&quot;&quot; Determine if a blockchain is valid :param chain: &lt;list&gt; a blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; for i in range(1, len(chain)): block = chain[i] previous_block = chain[i-1] if self.hash(previous_block) != block[&#39;previous_hash&#39;]: return False if not self.valid_proof(previous_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False return True def resolve_conflict(self): &quot;&quot;&quot; 共识算法解决冲突，使用网络中最长且有效的链 :param chain: &lt;list&gt; other blockchain :return: &lt;bool&gt; True 链被取代，False 链未被取代 &quot;&quot;&quot; flag = False for node in self.nodes: r = requests.get(&#39;http://{}/chain&#39;.format(node)) if r.status_code == 200: chain = r.json()[&#39;chain&#39;] length = r.json()[&#39;length&#39;] if length &gt; len(self.chain) and self.valid_chain(chain): self.chain = chain flag = True return flag # Instantiate our Node app = Flask(__name__) # Generate a globally unique address for this Node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # Instantiate the Blockchain blockchain = Blockchain() @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the PoW algorithm to get the next proof... last_proof = blockchain.last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # 给工作量证明的节点提供奖励， # 发送者为 &#39;0&#39; 表面是新挖出的币 blockchain.new_transaction( sender=&#39;0&#39;, recipient=node_identifier, amount=1, ) block = blockchain.new_block(proof) response = { &#39;message&#39;: &#39;New Block Forged&#39;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): # json.loads(request.get_data()) values = request.get_json() # Check that the required fields are in POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: &#39;Transaction will be added to Block {}&#39;.format(index)} return jsonify(response), 201 @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 @app.route(&#39;/node/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes) } return jsonify(response), 201 @app.route(&#39;/node/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): is_replaced = blockchain.resolve_conflict() if is_replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: myport = 5000 if len(sys.argv) &gt; 1: myport = int(sys.argv[1]) app.run(host=&#39;0.0.0.0&#39;, port=myport) 测试 在一台机器开启多个终端分别运行源代码，通过监听多个不同的端口来模拟多节点网络。这里模拟包含两个节点的区块链网络。 python3 blockchain.py 5000 #在终端1运行 python3 blockchain.py 5001 #在终端2运行 挖矿：新建另一个终端3进行通过curl命令进行操作。对节点1进行一次挖矿操作，此时链中有两个区块。 curl http://127.0.0.1:5000/mine 发送交易：向节点1发送一个交易。 curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;sender&quot;: &quot;5000&quot;, &quot;recipient&quot;: &quot;5001&quot;, &quot;amount&quot;: 100}&#39; &quot;http://127.0.0.1:5000/transactions/new&quot; 查看区块链：先进行一次mine操作，使刚刚发送的交易进入第3个区块，然后查看整个区块链的数据信息，此时该链有3个区块，其中第3个区块包含两条交易。 curl http://127.0.0.1:5000/mine curl http://127.0.0.1:5000/chain 注册节点：向节点2（端口为5001，1个block）发送节点1的地址（端口为5000，3个block）。 curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;nodes&quot;: [&quot;http://127.0.0.1:5000&quot;]}&#39; &quot;http://127.0.0.1:5001/node/register&quot; 共识：使节点2完成与相邻节点的共识，用节点1的链（长度为3）替换节点2的链（长度为1）。 curl http://127.0.0.1:5001/node/resolve 参考文章：https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/ 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/07/f3d94b477f4a5b0e5f7d3d17d6671ea9.html" />
<meta property="og:url" content="https://mlh.app/2018/03/07/f3d94b477f4a5b0e5f7d3d17d6671ea9.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-07T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"区块链（Blockchain）是一种分布式账本（listributed ledger），它是一种仅供增加（append-only），内容不可变（immutable）的有序（ordered）链式数据结构，该数据结构由网络中的一系列节点共同维护，并且这些节点之间互不信任。区块链是如今盛行的Bitcoin，Ethereum等数字货币背后的底层技术，本文通过Python从0开始创建一个简单的区块链模型，对于理解区块链基本原理很有帮助。 准备 所需条件： python3.6，pip，flask，requests，cURL flask和requests可通过如下命令下载： pip install falsk, requests 创建文件blockchain.py，所有代码均写在此文件中。 开始 代码主要分为两部分，首先是一个Blockchain类，其中包含区块链的属性和特性方法；然后是相应的路由处理方法，以flask服务器作为区块链网络中的一个节点来处理客户端请求对区块链完成相应操作，以及和网络中其它节点进行交互。 相关数据结构 block：区块，以dict表示，包含属性索引（index），时间戳（timestamp），交易集合（transactions），工作量证明（proof），上一个区块的hash值（previous_hash）。其中，previous_hash用于链接这些有序区块，并且保证其中内容不被更改。 tansaction：交易，dict形式，存放于区块中，包含属性：发出者（sender），接收者（recipient），数额（amount） Blockchain类的属性 chain：区块链中所有区块的list集合，每个元素都是一个block current_transactions: 当前即将加入区块的交易集合，list表示 nodes：当前节点的其他相邻节点的set集合 Blockchain类的方法 new_block()：生成新的区块，接收工作量证明proof作为参数，将block加入chain中，并且清空当前交易集合，返回生成的block。在__init__方法中会自动生成一个创世区块（genesis block），初始proof为100，previous_hash为’1’ new_transaction()：生成新的交易，接收三个参数：发出者，接受者，数额，并将交易加入到当前交易集合中，返回该交易将会加入的区块的索引 hash()：生成区块的hash值，接收一个block作为参数，首先利用json.dumps()将block对象转化为json格式，然后利用hashlib.sha256()计算其hash值 proof_of_work()：工作量证明算法（PoW），通过循环找一个数p，使得与前一个区块的proof拼接起来的字符串的hash值的前4位为’0000’，接收上一个区块的proof作为参数，返回找到的符合要求的proof register_node()：注册节点，接收一个URL作为参数，利用urllib.parse.urlparse()解析该地址，获取其中的内容ip:port，并加入到相邻节点集合nodes中 resolve_confict()： 共识算法（consensus）解决冲突，即使用网络中最长且有效的链。遍历其他节点的集合nodes（集合中保存了这些节点的ip和port），利用requests.get()通过路由/chain获取到这些节点的链chain。然后先进行长度判断，如果某节点的链长大于当前节点的链长；则对该链进行有效判断，即遍历该链，判断每个区块的previous_hash和proof值是否满足要求。如果该链更长且有效，则用该chain替换掉自身的链，解决冲突。 URL处理函数 用户提交的数据和服务器的响应数据均使用json格式，服务器利用Flask.request.get_json()获取表单中的json数据，利用Flask.jsonify()将response数据转化为json格式返回。 mine()：挖矿，对应路由为/mine ，请求方法为GET。主要完成任务有：计算工作量证明，通过新建交易给予矿工（自身节点）1个币的奖励，新增一个区块并加入链中。 new_transaction()：新增交易，对应路由为/transactions/new，请求方法为POST。通过request.get_json()获取用户提交的json格式表单，判断交易是否符合要求，调用类中添加交易的方法。 full_chain()：查看整条链，对应路由为/chain，请求方法为GET。 register_nodes()： 注册节点，对应路由为/node/register，方法为POST。接收提交的节点集合，调用register_node()加入这些节点，返回nodes集合 consensus()：共识，对应路由为/node/resolve，方法为GET。调用resolve_conflict()解决冲突，返回共识之后的链。 全部代码 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request from urllib.parse import urlparse import requests import sys class Blockchain(object): def __init__(self): # 当前即将加入区块的交易集合 self.current_transactions = [] self.chain = [] self.nodes = set() # create the genesis block self.new_block(proof=100, previous_hash=&#39;1&#39;) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; 生成新块 :param proof: &lt;int&gt; The proof given by the PoW algorithm :param previous_hash: （Optional) &lt;str&gt; hash of Previous block :return: &lt;dict&gt; new block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, # a list &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # 当前交易集合在加入区块后清空 self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; 生成新的交易信息，将加入下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): # Return the last block in the chain return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; 生成区块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; the hash value &quot;&quot;&quot; # we must make sure that the dict is ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() def proof_of_work(self, last_proof): &quot;&quot;&quot; 工作量证明： - 查找一个 p&#39; 使得 hash(pp&#39;)以4个0开头 - p是上一个块的证明， p&#39; 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; 验证证明：是否hash(last_proof, proof) :param proof: &lt;int&gt; previous proof :param last_proof: &lt;int&gt; current proof :return: &lt;bool&gt; True if correct, Flase if not. &quot;&quot;&quot; guess_hash = hashlib.sha256((str(last_proof) + str(proof)).encode()).hexdigest() return guess_hash[:4] == &#39;0000&#39; def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. EG. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; node = urlparse(address).netloc self.nodes.add(node) def valid_chain(self, chain): &quot;&quot;&quot; Determine if a blockchain is valid :param chain: &lt;list&gt; a blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; for i in range(1, len(chain)): block = chain[i] previous_block = chain[i-1] if self.hash(previous_block) != block[&#39;previous_hash&#39;]: return False if not self.valid_proof(previous_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False return True def resolve_conflict(self): &quot;&quot;&quot; 共识算法解决冲突，使用网络中最长且有效的链 :param chain: &lt;list&gt; other blockchain :return: &lt;bool&gt; True 链被取代，False 链未被取代 &quot;&quot;&quot; flag = False for node in self.nodes: r = requests.get(&#39;http://{}/chain&#39;.format(node)) if r.status_code == 200: chain = r.json()[&#39;chain&#39;] length = r.json()[&#39;length&#39;] if length &gt; len(self.chain) and self.valid_chain(chain): self.chain = chain flag = True return flag # Instantiate our Node app = Flask(__name__) # Generate a globally unique address for this Node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # Instantiate the Blockchain blockchain = Blockchain() @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the PoW algorithm to get the next proof... last_proof = blockchain.last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # 给工作量证明的节点提供奖励， # 发送者为 &#39;0&#39; 表面是新挖出的币 blockchain.new_transaction( sender=&#39;0&#39;, recipient=node_identifier, amount=1, ) block = blockchain.new_block(proof) response = { &#39;message&#39;: &#39;New Block Forged&#39;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): # json.loads(request.get_data()) values = request.get_json() # Check that the required fields are in POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: &#39;Transaction will be added to Block {}&#39;.format(index)} return jsonify(response), 201 @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 @app.route(&#39;/node/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes) } return jsonify(response), 201 @app.route(&#39;/node/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): is_replaced = blockchain.resolve_conflict() if is_replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: myport = 5000 if len(sys.argv) &gt; 1: myport = int(sys.argv[1]) app.run(host=&#39;0.0.0.0&#39;, port=myport) 测试 在一台机器开启多个终端分别运行源代码，通过监听多个不同的端口来模拟多节点网络。这里模拟包含两个节点的区块链网络。 python3 blockchain.py 5000 #在终端1运行 python3 blockchain.py 5001 #在终端2运行 挖矿：新建另一个终端3进行通过curl命令进行操作。对节点1进行一次挖矿操作，此时链中有两个区块。 curl http://127.0.0.1:5000/mine 发送交易：向节点1发送一个交易。 curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;sender&quot;: &quot;5000&quot;, &quot;recipient&quot;: &quot;5001&quot;, &quot;amount&quot;: 100}&#39; &quot;http://127.0.0.1:5000/transactions/new&quot; 查看区块链：先进行一次mine操作，使刚刚发送的交易进入第3个区块，然后查看整个区块链的数据信息，此时该链有3个区块，其中第3个区块包含两条交易。 curl http://127.0.0.1:5000/mine curl http://127.0.0.1:5000/chain 注册节点：向节点2（端口为5001，1个block）发送节点1的地址（端口为5000，3个block）。 curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;nodes&quot;: [&quot;http://127.0.0.1:5000&quot;]}&#39; &quot;http://127.0.0.1:5001/node/register&quot; 共识：使节点2完成与相邻节点的共识，用节点1的链（长度为3）替换节点2的链（长度为1）。 curl http://127.0.0.1:5001/node/resolve 参考文章：https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/ 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/07/f3d94b477f4a5b0e5f7d3d17d6671ea9.html","headline":"Python创建一个简单的区块链","dateModified":"2018-03-07T00:00:00+08:00","datePublished":"2018-03-07T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/07/f3d94b477f4a5b0e5f7d3d17d6671ea9.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Python创建一个简单的区块链</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <blockquote> 
   <p><strong>区块链</strong>（Blockchain）是一种<strong>分布式账本</strong>（listributed ledger），它是一种<strong>仅供增加</strong>（append-only），<strong>内容不可变</strong>（immutable）的<strong>有序</strong>（ordered）链式数据结构，该数据结构由网络中的一系列节点共同维护，并且这些节点之间互不信任。区块链是如今盛行的<strong>Bitcoin</strong>，<strong>Ethereum</strong>等数字货币背后的底层技术，本文通过<strong>Python</strong>从0开始创建一个简单的区块链模型，对于理解区块链基本原理很有帮助。</p> 
  </blockquote> 
  <h4 id="准备"><strong>准备</strong></h4> 
  <p><strong>所需条件：</strong> python3.6，pip，flask，requests，cURL</p> 
  <p>flask和requests可通过如下命令下载：</p> 
  <pre class="prettyprint"><code class=" hljs cmake">pip <span class="hljs-keyword">install</span> falsk, requests</code></pre> 
  <p>创建文件<strong>blockchain.py</strong>，所有代码均写在此文件中。</p> 
  <h4 id="开始"><strong>开始</strong></h4> 
  <p>代码主要分为两部分，首先是一个<strong>Blockchain</strong>类，其中包含区块链的属性和特性方法；然后是相应的路由处理方法，以flask服务器作为区块链网络中的一个节点来处理客户端请求对区块链完成相应操作，以及和网络中其它节点进行交互。</p> 
  <h5 id="相关数据结构"><strong>相关数据结构</strong></h5> 
  <ul> 
   <li><p><strong>block</strong>：区块，以<strong>dict</strong>表示，包含属性<strong>索引</strong>（index），<strong>时间戳</strong>（timestamp），<strong>交易集合</strong>（transactions），<strong>工作量证明</strong>（proof），<strong>上一个区块的hash值</strong>（previous_hash）。其中，previous_hash用于链接这些有序区块，并且保证其中内容不被更改。</p></li> 
   <li><p><strong>tansaction</strong>：交易，<strong>dict</strong>形式，存放于区块中，包含属性：<strong>发出者</strong>（sender），<strong>接收者</strong>（recipient），<strong>数额</strong>（amount）</p></li> 
  </ul> 
  <h5 id="blockchain类的属性"><strong>Blockchain类的属性</strong></h5> 
  <ul> 
   <li><p><strong>chain</strong>：区块链中所有区块的<strong>list</strong>集合，每个元素都是一个<strong>block</strong></p></li> 
   <li><p><strong>current_transactions</strong>: 当前即将加入区块的交易集合，<strong>list</strong>表示</p></li> 
   <li><p><strong>nodes</strong>：当前节点的其他相邻节点的<strong>set</strong>集合</p></li> 
  </ul> 
  <h5 id="blockchain类的方法"><strong>Blockchain类的方法</strong></h5> 
  <ul> 
   <li><p><strong>new_block()</strong>：生成新的区块，接收工作量证明proof作为参数，将block加入chain中，并且清空当前交易集合，返回生成的block。在<code>__init__</code>方法中会自动生成一个创世区块（genesis block），初始proof为100，previous_hash为’1’</p></li> 
   <li><p><strong>new_transaction()</strong>：生成新的交易，接收三个参数：发出者，接受者，数额，并将交易加入到当前交易集合中，返回该交易将会加入的区块的索引</p></li> 
   <li><p><strong>hash()</strong>：生成区块的hash值，接收一个block作为参数，首先利用<code>json.dumps()</code>将block对象转化为json格式，然后利用<code>hashlib.sha256()</code>计算其hash值</p></li> 
   <li><p><strong>proof_of_work()</strong>：工作量证明算法（PoW），通过循环找一个数p，使得与前一个区块的proof拼接起来的字符串的hash值的前4位为’0000’，接收上一个区块的proof作为参数，返回找到的符合要求的proof</p></li> 
   <li><p><strong>register_node()</strong>：注册节点，接收一个URL作为参数，利用<code>urllib.parse.urlparse()</code>解析该地址，获取其中的内容<code>ip:port</code>，并加入到相邻节点集合nodes中</p></li> 
   <li><p><strong>resolve_confict()</strong>： 共识算法（consensus）解决冲突，即使用网络中<strong>最长且有效</strong>的链。遍历其他节点的集合<code>nodes</code>（集合中保存了这些节点的ip和port），利用<code>requests.get()</code>通过路由<code>/chain</code>获取到这些节点的链<code>chain</code>。然后先进行<strong>长度判断</strong>，如果某节点的链长大于当前节点的链长；则对该链进行<strong>有效判断</strong>，即遍历该链，判断每个区块的previous_hash和proof值是否满足要求。如果该链更长且有效，则用该chain替换掉自身的链，解决冲突。</p></li> 
  </ul> 
  <h5 id="url处理函数"><strong>URL处理函数</strong></h5> 
  <p>用户提交的数据和服务器的响应数据均使用<strong>json</strong>格式，服务器利用<code>Flask.request.get_json()</code>获取表单中的json数据，利用<code>Flask.jsonify()</code>将response数据转化为json格式返回。</p> 
  <ul> 
   <li><p><strong>mine()</strong>：挖矿，对应路由为<code>/mine</code> ，请求方法为<code>GET</code>。主要完成任务有：计算工作量证明，通过新建交易给予矿工（自身节点）1个币的奖励，新增一个区块并加入链中。</p></li> 
   <li><p><strong>new_transaction()</strong>：新增交易，对应路由为<code>/transactions/new</code>，请求方法为<code>POST</code>。通过<code>request.get_json()</code>获取用户提交的json格式表单，判断交易是否符合要求，调用类中添加交易的方法。</p></li> 
   <li><p><strong>full_chain()</strong>：查看整条链，对应路由为<code>/chain</code>，请求方法为<code>GET</code>。</p></li> 
   <li><p><strong>register_nodes()</strong>： 注册节点，对应路由为<code>/node/register</code>，方法为<code>POST</code>。接收提交的节点集合，调用<code>register_node()</code>加入这些节点，返回<strong>nodes</strong>集合</p></li> 
   <li><p><strong>consensus()</strong>：共识，对应路由为<code>/node/resolve</code>，方法为<code>GET</code>。调用<code>resolve_conflict()</code>解决冲突，返回共识之后的链。</p></li> 
  </ul> 
  <h5 id="全部代码"><strong>全部代码</strong></h5> 
  <pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> hashlib
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> uuid4
<span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify, request
<span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urlparse
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">import</span> sys


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blockchain</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># 当前即将加入区块的交易集合</span>
        self.current_transactions = []
        self.chain = []
        self.nodes = set()
        <span class="hljs-comment"># create the genesis block</span>
        self.new_block(proof=<span class="hljs-number">100</span>, previous_hash=<span class="hljs-string">'1'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_block</span><span class="hljs-params">(self, proof, previous_hash=None)</span>:</span>
        <span class="hljs-string">""" 生成新块 :param proof: &lt;int&gt; The proof given by the PoW algorithm :param previous_hash: （Optional) &lt;str&gt; hash of Previous block :return: &lt;dict&gt; new block """</span>
        block = {
            <span class="hljs-string">'index'</span>: len(self.chain) + <span class="hljs-number">1</span>,
            <span class="hljs-string">'timestamp'</span>: time(),
            <span class="hljs-string">'transactions'</span>: self.current_transactions,        <span class="hljs-comment"># a list</span>
            <span class="hljs-string">'proof'</span>: proof,
            <span class="hljs-string">'previous_hash'</span>: previous_hash <span class="hljs-keyword">or</span> self.hash(self.chain[-<span class="hljs-number">1</span>]),
        }
        <span class="hljs-comment"># 当前交易集合在加入区块后清空</span>
        self.current_transactions = []
        self.chain.append(block)
        <span class="hljs-keyword">return</span> block

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_transaction</span><span class="hljs-params">(self, sender, recipient, amount)</span>:</span>
        <span class="hljs-string">""" 生成新的交易信息，将加入下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction """</span>
        self.current_transactions.append({
            <span class="hljs-string">'sender'</span>: sender,
            <span class="hljs-string">'recipient'</span>: recipient,
            <span class="hljs-string">'amount'</span>: amount,
        })
        <span class="hljs-keyword">return</span> self.last_block[<span class="hljs-string">'index'</span>] + <span class="hljs-number">1</span>

    <span class="hljs-decorator">@property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">last_block</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Return the last block in the chain</span>
        <span class="hljs-keyword">return</span> self.chain[-<span class="hljs-number">1</span>]

    <span class="hljs-decorator">@staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hash</span><span class="hljs-params">(block)</span>:</span>
        <span class="hljs-string">""" 生成区块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; the hash value """</span>
        <span class="hljs-comment"># we must make sure that the dict is ordered, or we'll have inconsistent hashes</span>
        block_string = json.dumps(block, sort_keys=<span class="hljs-keyword">True</span>).encode()
        <span class="hljs-keyword">return</span> hashlib.sha256(block_string).hexdigest()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proof_of_work</span><span class="hljs-params">(self, last_proof)</span>:</span>
        <span class="hljs-string">""" 工作量证明： - 查找一个 p' 使得 hash(pp')以4个0开头 - p是上一个块的证明， p' 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; """</span>
        proof = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> self.valid_proof(last_proof, proof) <span class="hljs-keyword">is</span> <span class="hljs-keyword">False</span>:
            proof += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> proof

    <span class="hljs-decorator">@staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid_proof</span><span class="hljs-params">(last_proof, proof)</span>:</span>
        <span class="hljs-string">""" 验证证明：是否hash(last_proof, proof) :param proof: &lt;int&gt; previous proof :param last_proof: &lt;int&gt; current proof :return: &lt;bool&gt; True if correct, Flase if not. """</span>
        guess_hash = hashlib.sha256((str(last_proof) + str(proof)).encode()).hexdigest()
        <span class="hljs-keyword">return</span> guess_hash[:<span class="hljs-number">4</span>] == <span class="hljs-string">'0000'</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register_node</span><span class="hljs-params">(self, address)</span>:</span>
        <span class="hljs-string">""" Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. EG. 'http://192.168.0.5:5000' :return: None """</span>
        node = urlparse(address).netloc
        self.nodes.add(node)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid_chain</span><span class="hljs-params">(self, chain)</span>:</span>
        <span class="hljs-string">""" Determine if a blockchain is valid :param chain: &lt;list&gt; a blockchain :return: &lt;bool&gt; True if valid, False if not """</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(chain)):
            block = chain[i]
            previous_block = chain[i-<span class="hljs-number">1</span>]
            <span class="hljs-keyword">if</span> self.hash(previous_block) != block[<span class="hljs-string">'previous_hash'</span>]:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.valid_proof(previous_block[<span class="hljs-string">'proof'</span>], block[<span class="hljs-string">'proof'</span>]):
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resolve_conflict</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">""" 共识算法解决冲突，使用网络中最长且有效的链 :param chain: &lt;list&gt; other blockchain :return: &lt;bool&gt; True 链被取代，False 链未被取代 """</span>
        flag = <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> self.nodes:
            r = requests.get(<span class="hljs-string">'http://{}/chain'</span>.format(node))
            <span class="hljs-keyword">if</span> r.status_code == <span class="hljs-number">200</span>:
                chain = r.json()[<span class="hljs-string">'chain'</span>]
                length = r.json()[<span class="hljs-string">'length'</span>]
                <span class="hljs-keyword">if</span> length &gt; len(self.chain) <span class="hljs-keyword">and</span> self.valid_chain(chain):
                    self.chain = chain
                    flag = <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> flag


<span class="hljs-comment"># Instantiate our Node</span>
app = Flask(__name__)


<span class="hljs-comment"># Generate a globally unique address for this Node</span>
node_identifier = str(uuid4()).replace(<span class="hljs-string">'-'</span>, <span class="hljs-string">''</span>)
<span class="hljs-comment"># Instantiate the Blockchain</span>
blockchain = Blockchain()


<span class="hljs-decorator">@app.route('/mine', methods=['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mine</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># We run the PoW algorithm to get the next proof...</span>
    last_proof = blockchain.last_block[<span class="hljs-string">'proof'</span>]
    proof = blockchain.proof_of_work(last_proof)
    <span class="hljs-comment"># 给工作量证明的节点提供奖励，</span>
    <span class="hljs-comment"># 发送者为 '0' 表面是新挖出的币</span>
    blockchain.new_transaction(
        sender=<span class="hljs-string">'0'</span>,
        recipient=node_identifier,
        amount=<span class="hljs-number">1</span>,
    )
    block = blockchain.new_block(proof)
    response = {
        <span class="hljs-string">'message'</span>: <span class="hljs-string">'New Block Forged'</span>,
        <span class="hljs-string">'index'</span>: block[<span class="hljs-string">'index'</span>],
        <span class="hljs-string">'transactions'</span>: block[<span class="hljs-string">'transactions'</span>],
        <span class="hljs-string">'proof'</span>: block[<span class="hljs-string">'proof'</span>],
        <span class="hljs-string">'previous_hash'</span>: block[<span class="hljs-string">'previous_hash'</span>],
    }
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">200</span>


<span class="hljs-decorator">@app.route('/transactions/new', methods=['POST'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_transaction</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># json.loads(request.get_data())</span>
    values = request.get_json()
    <span class="hljs-comment"># Check that the required fields are in POST'ed data</span>
    required = [<span class="hljs-string">'sender'</span>, <span class="hljs-string">'recipient'</span>, <span class="hljs-string">'amount'</span>]
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> all(k <span class="hljs-keyword">in</span> values <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> required):
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Missing values'</span>, <span class="hljs-number">400</span>
    <span class="hljs-comment"># Create a new Transaction</span>

    index = blockchain.new_transaction(values[<span class="hljs-string">'sender'</span>], values[<span class="hljs-string">'recipient'</span>], values[<span class="hljs-string">'amount'</span>])
    response = {<span class="hljs-string">'message'</span>: <span class="hljs-string">'Transaction will be added to Block {}'</span>.format(index)}
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">201</span>


<span class="hljs-decorator">@app.route('/chain', methods=['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">full_chain</span><span class="hljs-params">()</span>:</span>
    response = {
        <span class="hljs-string">'chain'</span>: blockchain.chain,
        <span class="hljs-string">'length'</span>: len(blockchain.chain),
    }
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">200</span>


<span class="hljs-decorator">@app.route('/node/register', methods=['POST'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register_nodes</span><span class="hljs-params">()</span>:</span>
    values = request.get_json()
    nodes = values.get(<span class="hljs-string">'nodes'</span>)
    <span class="hljs-keyword">if</span> nodes <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Error: Please supply a valid list of nodes"</span>, <span class="hljs-number">400</span>
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes:
        blockchain.register_node(node)
    response = {
        <span class="hljs-string">'message'</span>: <span class="hljs-string">'New nodes have been added'</span>,
        <span class="hljs-string">'total_nodes'</span>: list(blockchain.nodes)
    }
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">201</span>


<span class="hljs-decorator">@app.route('/node/resolve', methods=['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consensus</span><span class="hljs-params">()</span>:</span>
    is_replaced = blockchain.resolve_conflict()
    <span class="hljs-keyword">if</span> is_replaced:
        response = {
            <span class="hljs-string">'message'</span>: <span class="hljs-string">'Our chain was replaced'</span>,
            <span class="hljs-string">'new_chain'</span>: blockchain.chain
        }
    <span class="hljs-keyword">else</span>:
        response = {
            <span class="hljs-string">'message'</span>: <span class="hljs-string">'Our chain is authoritative'</span>,
            <span class="hljs-string">'chain'</span>: blockchain.chain
        }
    <span class="hljs-keyword">return</span> jsonify(response), <span class="hljs-number">200</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    myport = <span class="hljs-number">5000</span>
    <span class="hljs-keyword">if</span> len(sys.argv) &gt; <span class="hljs-number">1</span>:
        myport = int(sys.argv[<span class="hljs-number">1</span>])
    app.run(host=<span class="hljs-string">'0.0.0.0'</span>, port=myport)
</code></pre> 
  <h4 id="测试"><strong>测试</strong></h4> 
  <ul> 
   <li><p>在一台机器开启多个终端分别运行源代码，通过监听多个不同的端口来模拟多节点网络。这里模拟包含两个节点的区块链网络。</p> <pre class="prettyprint"><code class=" hljs avrasm">python3 blockchain<span class="hljs-preprocessor">.py</span> <span class="hljs-number">5000</span>         <span class="hljs-preprocessor">#在终端1运行</span>
python3 blockchain<span class="hljs-preprocessor">.py</span> <span class="hljs-number">5001</span>         <span class="hljs-preprocessor">#在终端2运行</span></code></pre></li> 
   <li><p>挖矿：新建另一个终端3进行通过curl命令进行操作。对节点1进行一次挖矿操作，此时链中有两个区块。</p> <pre class="prettyprint"><code class=" hljs cs">curl http:<span class="hljs-comment">//127.0.0.1:5000/mine</span></code></pre> <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307155147051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhheXVqaWU1MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p></li> 
   <li><p>发送交易：向节点1发送一个交易。</p> <pre class="prettyprint"><code class=" hljs scilab">curl -X POST -H <span class="hljs-string">"Content-Type: application/json"</span> -d <span class="hljs-string">'{"</span>sender<span class="hljs-string">": "</span><span class="hljs-number">5000</span><span class="hljs-string">", "</span>recipient<span class="hljs-string">": "</span><span class="hljs-number">5001</span><span class="hljs-string">", "</span>amount<span class="hljs-string">": 100}'</span> <span class="hljs-string">"http://127.0.0.1:5000/transactions/new"</span></code></pre> <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307155022309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhheXVqaWU1MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p></li> 
   <li><p>查看区块链：先进行一次mine操作，使刚刚发送的交易进入第3个区块，然后查看整个区块链的数据信息，此时该链有3个区块，其中第3个区块包含两条交易。</p> <pre class="prettyprint"><code class=" hljs cs">curl http:<span class="hljs-comment">//127.0.0.1:5000/mine</span>
curl http:<span class="hljs-comment">//127.0.0.1:5000/chain</span></code></pre> <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307155945639?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhheXVqaWU1MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p></li> 
   <li><p>注册节点：向节点2（端口为5001，1个block）发送节点1的地址（端口为5000，3个block）。</p> <pre class="prettyprint"><code class=" hljs lasso">curl <span class="hljs-attribute">-X</span> POST <span class="hljs-attribute">-H</span> <span class="hljs-string">"Content-Type: application/json"</span> <span class="hljs-attribute">-d</span> <span class="hljs-string">'{"nodes": ["http://127.0.0.1:5000"]}'</span> <span class="hljs-string">"http://127.0.0.1:5001/node/register"</span></code></pre> <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307155102779?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhheXVqaWU1MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p></li> 
   <li><p>共识：使节点2完成与相邻节点的共识，用节点1的链（长度为3）替换节点2的链（长度为1）。</p> <pre class="prettyprint"><code class=" hljs cs">curl http:<span class="hljs-comment">//127.0.0.1:5001/node/resolve</span></code></pre> <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180307155318187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhheXVqaWU1MjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p></li> 
  </ul> 
  <p><strong>参考文章：</strong><a href="https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/" rel="nofollow">https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/zhayujie5200/article/details/79468117,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/zhayujie5200/article/details/79468117,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
