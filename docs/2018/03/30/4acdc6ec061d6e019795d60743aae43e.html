<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>美团新一代渠道包打包神器walle | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="美团新一代渠道包打包神器walle" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="官方介绍&nbsp;https://tech.meituan.com/android-apk-v2-signature-scheme.html 因为在Android 7.0（Nougat）推出了新的应用签名方案APK Signature Scheme v2，用之前快速生成渠道包的方式（美团Android自动化之旅—生成渠道包）打出来的包，没法签名。因此有了现在新的渠道包打包工具walle。 新的应用签名方案APK Signature Scheme v2 Android 7.0（Nougat）引入一项新的应用签名方案APK Signature Scheme v2，它是一个对全文件进行签名的方案，能提供更快的应用安装时间、对未授权APK文件的更改提供更多保护，在默认情况下，Android Gradle 2.2.0插件会使用APK Signature Scheme v2和传统签名方案来签署你的应用。 下面以&nbsp;新的应用签名方案&nbsp;来指APK Signature Scheme v2。 目前该方案不是强制性的，在&nbsp;build.gradle&nbsp;添加&nbsp;v2SigningEnabled false&nbsp;，就能使用传统签名方案来签署我们的应用（见下面的代码片段）。 android { ... defaultConfig { ... } signingConfigs { release { storeFile file(&quot;myreleasekey.keystore&quot;) storePassword &quot;password&quot; keyAlias &quot;MyReleaseKey&quot; keyPassword &quot;password&quot; v2SigningEnabled false } } } 但新的应用签名方案有着良好的向后兼容性，能完全兼容低于Android 7.0（Nougat）的版本。对比旧签名方案，它有更快的验证速度和更安全的保护，因此新的应用签名方案可能会被采纳成一个强制配置，笔者认为现在有必要对现有的渠道包生成方式进行检查、升级或改造来支持新的应用签名方案。 新的签名方案对已有的渠道生成方案有什么影响呢？下图是新的应用签名方案和旧的签名方案的一个对比： 新的签名方案会在ZIP文件格式的&nbsp;Central Directory&nbsp;区块所在文件位置的前面添加一个APK Signing Block区块，下面按照ZIP文件的格式来分析新应用签名方案签名后的APK包。 整个APK（ZIP文件格式）会被分为以下四个区块： Contents of ZIP entries（from offset 0 until the start of APK Signing Block） APK Signing Block ZIP Central Directory ZIP End of Central Directory 新应用签名方案的签名信息会被保存在区块2（APK Signing Block）中， 而区块1（Contents of ZIP entries）、区块3（ZIP Central Directory）、区块4（ZIP End of Central Directory）是受保护的，在签名后任何对区块1、3、4的修改都逃不过新的应用签名方案的检查。 之前的渠道包生成方案是通过在META-INF目录下添加空文件，用空文件的名称来作为渠道的唯一标识，之前在META-INF下添加文件是不需要重新签名应用的，这样会节省不少打包的时间，从而提高打渠道包的速度。但在新的应用签名方案下META-INF已经被列入了保护区了，向META-INF添加空文件的方案会对区块1、3、4都会有影响，新应用签名方案签署的应用经过我们旧的生成渠道包方案处理后，在安装时会报以下错误： Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates from base.apk: META-INF/CERT.SF indicates base.apk is signed using APK Signature Scheme v2, but no such signature was found. Signature stripped?] 目前另外一种比较流行的渠道包快速生成方案（往APK中添加ZIP Comment）也因为上述原因，无法在新的应用签名方案下进行正常工作。 如果新的应用签名方案后续改成强制要求，那我们现有的生成渠道包的方式就会无法工作，那我们难道要退回到解放前，通过传统的方式（例如：使用APKTool逆向工具、采用Flavor ＋ BuildType等比较耗时的方案来进行渠道包打包）来生成支持新应用签名方案的渠道包吗？ 如果只有少量渠道包的场景下，这种耗时时长还能够勉强接受。但是目前我们有将近900个渠道，如果采用传统方式打完所有的渠道包需要近3个小时，这是不能接受的。 那我们有没有其他更好的渠道包生成方式，既能支持新的应用签名方案，又能体验毫秒级的打包耗时呢？我们来分析一下新方案中的区块2——Block。 可扩展的APK Signature Scheme v2 Block 通过上面的描述，可以看出因为APK包的区块1、3、4都是受保护的，任何修改在签名后对它们的修改，都会在安装过程中被签名校验检测失败，而区块2（APK Signing Block）是不受签名校验规则保护的，那是否可以在这个不受签名保护的区块2（APK Signing Block）上做文章呢？我们先来看看对区块2格式的描述： 偏移 字节数 描述 @+0 8 这个Block的长度（本字段的长度不计算在内） @+8 n 一组ID-value @-24 8 这个Block的长度（和第一个字段一样值） @-16 16 魔数 “APK Sig Block 42” 区块2中APK Signing Block是由这几部分组成：2个用来标示这个区块长度的8字节 ＋ 这个区块的魔数（APK Sig Block 42）+ 这个区块所承载的数据（ID-value）。 我们重点来看一下这个ID-value，它由一个8字节的长度标示＋4字节的ID＋它的负载组成。V2的签名信息是以ID（0x7109871a）的ID-value来保存在这个区块中，不知大家有没有注意这是一组ID-value，也就是说它是可以有若干个这样的ID-value来组成，那我们是不是可以在这里做一些文章呢？ 为了验证我们的想法，先来看看新的应用签名方案是怎么验证签名信息的，见下图： 通过上图可以看出新的应用签名方案的验证过程： 寻找APK Signing Block，如果能够找到，则进行验证，验证成功则继续进行安装，如果失败了则终止安装 如果未找到APK Signing Block，则执行原来的签名验证机制，也是验证成功则继续进行安装，如果失败了则终止安装 那Android应用在安装时新的应用签名方案是怎么进行校验的呢？笔者通过翻阅Android相关部分的源码，发现下面代码段是用来处理上面所说的ID-value的： public static ByteBuffer findApkSignatureSchemeV2Block( ByteBuffer apkSigningBlock, Result result) throws SignatureNotFoundException { checkByteOrderLittleEndian(apkSigningBlock); // FORMAT: // OFFSET DATA TYPE DESCRIPTION // * @+0 bytes uint64: size in bytes (excluding this field) // * @+8 bytes pairs // * @-24 bytes uint64: size in bytes (same as the one above) // * @-16 bytes uint128: magic ByteBuffer pairs = sliceFromTo(apkSigningBlock, 8, apkSigningBlock.capacity() - 24); int entryCount = 0; while (pairs.hasRemaining()) { entryCount++; if (pairs.remaining() &lt; 8) { throw new SignatureNotFoundException( &quot;Insufficient data to read size of APK Signing Block entry #&quot; + entryCount); } long lenLong = pairs.getLong(); if ((lenLong &lt; 4) || (lenLong &gt; Integer.MAX_VALUE)) { throw new SignatureNotFoundException( &quot;APK Signing Block entry #&quot; + entryCount + &quot; size out of range: &quot; + lenLong); } int len = (int) lenLong; int nextEntryPos = pairs.position() + len; if (len &gt; pairs.remaining()) { throw new SignatureNotFoundException( &quot;APK Signing Block entry #&quot; + entryCount + &quot; size out of range: &quot; + len + &quot;, available: &quot; + pairs.remaining()); } int id = pairs.getInt(); if (id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID) { return getByteBuffer(pairs, len - 4); } result.addWarning(Issue.APK_SIG_BLOCK_UNKNOWN_ENTRY_ID, id); pairs.position(nextEntryPos); } throw new SignatureNotFoundException( &quot;No APK Signature Scheme v2 block in APK Signing Block&quot;); } 上述代码中关键的一个位置是&nbsp;if (id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID) {return getByteBuffer(pairs, len - 4);}，通过源代码可以看出Android是通过查找ID为&nbsp;APK_SIGNATURE_SCHEME_V2_BLOCK_ID = 0x7109871a&nbsp;的ID-value，来获取APK Signature Scheme v2 Block，对这个区块中其他的ID-value选择了忽略。 在APK Signature Scheme v2中没有看到对无法识别的ID，有相关处理的介绍。 当看到这里时，我们可不可以设想一下，提供一个自定义的ID-value并写入该区域，从而为快速生成渠道包服务呢？ 怎么向ID-value中添加信息呢？通过阅读ZIP的文件格式和APK Signing Block格式的描述，笔者通过编写下面的代码片段进行验证，发现通过在已经被新的应用签名方案签名后的APK中添加自定义的ID-value，是不需要再次经过签名就能安装的，下面是部分代码片段。 public void writeApkSigningBlock(DataOutput dataOutput) { long length = 24; for (int index = 0; index &lt; payloads.size(); ++index) { ApkSigningPayload payload = payloads.get(index); byte[] bytes = payload.getByteBuffer(); length += 12 + bytes.length; } ByteBuffer byteBuffer = ByteBuffer.allocate(Long.BYTES); byteBuffer.order(ByteOrder.LITTLE_ENDIAN); byteBuffer.putLong(length); dataOutput.write(byteBuffer.array()); for (int index = 0; index &lt; payloads.size(); ++index) { ApkSigningPayload payload = payloads.get(index); byte[] bytes = payload.getByteBuffer(); byteBuffer = ByteBuffer.allocate(Integer.BYTES); byteBuffer.order(ByteOrder.LITTLE_ENDIAN); byteBuffer.putInt(payload.getId()); dataOutput.write(byteBuffer.array()); dataOutput.write(bytes); } ... } 新一代渠道包生成工具 到这里为止一个新的渠道包生成方案逐步清晰了起来，下面是新一代渠道包生成工具的描述： 对新的应用签名方案生成的APK包中的ID-value进行扩展，提供自定义ID－value（渠道信息），并保存在APK中 而APK在安装过程中进行的签名校验，是忽略我们添加的这个ID-value的，这样就能正常安装了 在App运行阶段，可以通过ZIP的EOCD（End of central directory）、Central directory等结构中的信息（会涉及ZIP格式的相关知识，这里不做展开描述）找到我们自己添加的ID-value，从而实现获取渠道信息的功能 新一代渠道包生成工具完全是基于ZIP文件格式和APK Signing Block存储格式而构建，基于文件的二进制流进行处理，有着良好的处理速度和兼容性，能够满足不同的语言编写的要求，目前笔者采用的是Java＋Groovy开发， 该工具主要有四部分组成： 用于写入ID-value信息的Java类库 Gradle构建插件用来和Android的打包流程进行结合 用于读取ID-value信息的Java类库 用于供com.android.application使用的读取渠道信息的AAR 这样，每打一个渠道包只需复制一个APK，然后在APK中添加一个ID-value即可，这种打包方式速度非常快，对一个30M大小的APK包只需要100多毫秒（包含文件复制时间）就能生成一个渠道包，而在运行时获取渠道信息只需要大约几毫秒的时间。 这个项目我们取名为Walle（瓦力），已经开源，项目的Github地址是：&nbsp;https://github.com/Meituan-Dianping/walle&nbsp;（求Issue、PR、Star）。希望业内有类似需求的团队能够在APK Signature Scheme V2签名下愉快地生成渠道包，同时也期待大家一起对该项目进行完善和优化。 总结 以上就是我们对新的应用签名方案进行的分析，并根据它所带来的文件存储格式上的变化，找到了可以利用的ID-value，然后基于这个ID-value来构建我们新一代渠道包生成工具。 新一代渠道包生成工具能够满足新应用签名方案对安全性的要求，同时也能满足对渠道包打包时间的要求，至此大家生成渠道包的方式需要升级了！ 文章中引用的图片来源于：https://source.android.com/security/apksigning/v2.html 上面是关于工具实现的介绍，下面介绍工具的使用：https://github.com/Meituan-Dianping/walle Gradle插件使用方式 配置build.gradle 在位于项目的根目录 build.gradle 文件中添加Walle Gradle插件的依赖， 如下： buildscript { dependencies { classpath &#39;com.meituan.android.walle:plugin:1.1.6&#39; } } 并在当前App的 build.gradle 文件中apply这个插件，并添加上用于读取渠道号的AAR apply plugin: &#39;walle&#39; dependencies { compile &#39;com.meituan.android.walle:library:1.1.6&#39; } 配置插件 walle { // 指定渠道包的输出路径 apkOutputFolder = new File(&quot;${project.buildDir}/outputs/channels&quot;); // 定制渠道包的APK的文件名称 apkFileNameFormat = &#39;${appName}-${packageName}-${channel}-${buildType}-v${versionName}-${versionCode}-${buildTime}.apk&#39;; // 渠道配置文件 channelFile = new File(&quot;${project.getProjectDir()}/channel&quot;) } 配置项具体解释： apkOutputFolder：指定渠道包的输出路径， 默认值为new File(&quot;${project.buildDir}/outputs/apk&quot;) apkFileNameFormat：定制渠道包的APK的文件名称, 默认值为&#39;${appName}-${buildType}-${channel}.apk&#39; 可使用以下变量: projectName - 项目名字 appName - App模块名字 packageName - applicationId (App包名packageName) buildType - buildType (release/debug等) channel - channel名称 (对应渠道打包中的渠道名字) versionName - versionName (显示用的版本号) versionCode - versionCode (内部版本号) buildTime - buildTime (编译构建日期时间) fileSHA1 - fileSHA1 (最终APK文件的SHA1哈希值) flavorName - 编译构建 productFlavors 名 channelFile：包含渠道配置信息的文件路径。 具体内容格式详见：渠道配置文件示例，支持使用#号添加注释。 如何获取渠道信息 在需要渠道等信息时可以通过下面代码进行获取 String channel = WalleChannelReader.getChannel(this.getApplicationContext()); 如何生成渠道包 生成渠道包的方式是和assemble${variantName}Channels指令结合，渠道包的生成目录默认存放在 build/outputs/apk/，也可以通过walle闭包中的apkOutputFolder参数来指定输出目录 用法示例： 生成渠道包 ./gradlew clean assembleReleaseChannels 支持 productFlavors ./gradlew clean assembleMeituanReleaseChannels 临时生成某渠道包 我们推荐使用channelFile/configFile配置来生成渠道包，但有时也可能有临时生成渠道包需求，这时可以使用： 生成单个渠道包: ./gradlew clean assembleReleaseChannels -PchannelList=meituan 生成多个渠道包: ./gradlew clean assembleReleaseChannels -PchannelList=meituan,dianping 基于360加固后签名失效的解决方案： https://github.com/Jay-Goo/ProtectedApkResignerForWalle 其中的配置 阅读更多" />
<meta property="og:description" content="官方介绍&nbsp;https://tech.meituan.com/android-apk-v2-signature-scheme.html 因为在Android 7.0（Nougat）推出了新的应用签名方案APK Signature Scheme v2，用之前快速生成渠道包的方式（美团Android自动化之旅—生成渠道包）打出来的包，没法签名。因此有了现在新的渠道包打包工具walle。 新的应用签名方案APK Signature Scheme v2 Android 7.0（Nougat）引入一项新的应用签名方案APK Signature Scheme v2，它是一个对全文件进行签名的方案，能提供更快的应用安装时间、对未授权APK文件的更改提供更多保护，在默认情况下，Android Gradle 2.2.0插件会使用APK Signature Scheme v2和传统签名方案来签署你的应用。 下面以&nbsp;新的应用签名方案&nbsp;来指APK Signature Scheme v2。 目前该方案不是强制性的，在&nbsp;build.gradle&nbsp;添加&nbsp;v2SigningEnabled false&nbsp;，就能使用传统签名方案来签署我们的应用（见下面的代码片段）。 android { ... defaultConfig { ... } signingConfigs { release { storeFile file(&quot;myreleasekey.keystore&quot;) storePassword &quot;password&quot; keyAlias &quot;MyReleaseKey&quot; keyPassword &quot;password&quot; v2SigningEnabled false } } } 但新的应用签名方案有着良好的向后兼容性，能完全兼容低于Android 7.0（Nougat）的版本。对比旧签名方案，它有更快的验证速度和更安全的保护，因此新的应用签名方案可能会被采纳成一个强制配置，笔者认为现在有必要对现有的渠道包生成方式进行检查、升级或改造来支持新的应用签名方案。 新的签名方案对已有的渠道生成方案有什么影响呢？下图是新的应用签名方案和旧的签名方案的一个对比： 新的签名方案会在ZIP文件格式的&nbsp;Central Directory&nbsp;区块所在文件位置的前面添加一个APK Signing Block区块，下面按照ZIP文件的格式来分析新应用签名方案签名后的APK包。 整个APK（ZIP文件格式）会被分为以下四个区块： Contents of ZIP entries（from offset 0 until the start of APK Signing Block） APK Signing Block ZIP Central Directory ZIP End of Central Directory 新应用签名方案的签名信息会被保存在区块2（APK Signing Block）中， 而区块1（Contents of ZIP entries）、区块3（ZIP Central Directory）、区块4（ZIP End of Central Directory）是受保护的，在签名后任何对区块1、3、4的修改都逃不过新的应用签名方案的检查。 之前的渠道包生成方案是通过在META-INF目录下添加空文件，用空文件的名称来作为渠道的唯一标识，之前在META-INF下添加文件是不需要重新签名应用的，这样会节省不少打包的时间，从而提高打渠道包的速度。但在新的应用签名方案下META-INF已经被列入了保护区了，向META-INF添加空文件的方案会对区块1、3、4都会有影响，新应用签名方案签署的应用经过我们旧的生成渠道包方案处理后，在安装时会报以下错误： Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates from base.apk: META-INF/CERT.SF indicates base.apk is signed using APK Signature Scheme v2, but no such signature was found. Signature stripped?] 目前另外一种比较流行的渠道包快速生成方案（往APK中添加ZIP Comment）也因为上述原因，无法在新的应用签名方案下进行正常工作。 如果新的应用签名方案后续改成强制要求，那我们现有的生成渠道包的方式就会无法工作，那我们难道要退回到解放前，通过传统的方式（例如：使用APKTool逆向工具、采用Flavor ＋ BuildType等比较耗时的方案来进行渠道包打包）来生成支持新应用签名方案的渠道包吗？ 如果只有少量渠道包的场景下，这种耗时时长还能够勉强接受。但是目前我们有将近900个渠道，如果采用传统方式打完所有的渠道包需要近3个小时，这是不能接受的。 那我们有没有其他更好的渠道包生成方式，既能支持新的应用签名方案，又能体验毫秒级的打包耗时呢？我们来分析一下新方案中的区块2——Block。 可扩展的APK Signature Scheme v2 Block 通过上面的描述，可以看出因为APK包的区块1、3、4都是受保护的，任何修改在签名后对它们的修改，都会在安装过程中被签名校验检测失败，而区块2（APK Signing Block）是不受签名校验规则保护的，那是否可以在这个不受签名保护的区块2（APK Signing Block）上做文章呢？我们先来看看对区块2格式的描述： 偏移 字节数 描述 @+0 8 这个Block的长度（本字段的长度不计算在内） @+8 n 一组ID-value @-24 8 这个Block的长度（和第一个字段一样值） @-16 16 魔数 “APK Sig Block 42” 区块2中APK Signing Block是由这几部分组成：2个用来标示这个区块长度的8字节 ＋ 这个区块的魔数（APK Sig Block 42）+ 这个区块所承载的数据（ID-value）。 我们重点来看一下这个ID-value，它由一个8字节的长度标示＋4字节的ID＋它的负载组成。V2的签名信息是以ID（0x7109871a）的ID-value来保存在这个区块中，不知大家有没有注意这是一组ID-value，也就是说它是可以有若干个这样的ID-value来组成，那我们是不是可以在这里做一些文章呢？ 为了验证我们的想法，先来看看新的应用签名方案是怎么验证签名信息的，见下图： 通过上图可以看出新的应用签名方案的验证过程： 寻找APK Signing Block，如果能够找到，则进行验证，验证成功则继续进行安装，如果失败了则终止安装 如果未找到APK Signing Block，则执行原来的签名验证机制，也是验证成功则继续进行安装，如果失败了则终止安装 那Android应用在安装时新的应用签名方案是怎么进行校验的呢？笔者通过翻阅Android相关部分的源码，发现下面代码段是用来处理上面所说的ID-value的： public static ByteBuffer findApkSignatureSchemeV2Block( ByteBuffer apkSigningBlock, Result result) throws SignatureNotFoundException { checkByteOrderLittleEndian(apkSigningBlock); // FORMAT: // OFFSET DATA TYPE DESCRIPTION // * @+0 bytes uint64: size in bytes (excluding this field) // * @+8 bytes pairs // * @-24 bytes uint64: size in bytes (same as the one above) // * @-16 bytes uint128: magic ByteBuffer pairs = sliceFromTo(apkSigningBlock, 8, apkSigningBlock.capacity() - 24); int entryCount = 0; while (pairs.hasRemaining()) { entryCount++; if (pairs.remaining() &lt; 8) { throw new SignatureNotFoundException( &quot;Insufficient data to read size of APK Signing Block entry #&quot; + entryCount); } long lenLong = pairs.getLong(); if ((lenLong &lt; 4) || (lenLong &gt; Integer.MAX_VALUE)) { throw new SignatureNotFoundException( &quot;APK Signing Block entry #&quot; + entryCount + &quot; size out of range: &quot; + lenLong); } int len = (int) lenLong; int nextEntryPos = pairs.position() + len; if (len &gt; pairs.remaining()) { throw new SignatureNotFoundException( &quot;APK Signing Block entry #&quot; + entryCount + &quot; size out of range: &quot; + len + &quot;, available: &quot; + pairs.remaining()); } int id = pairs.getInt(); if (id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID) { return getByteBuffer(pairs, len - 4); } result.addWarning(Issue.APK_SIG_BLOCK_UNKNOWN_ENTRY_ID, id); pairs.position(nextEntryPos); } throw new SignatureNotFoundException( &quot;No APK Signature Scheme v2 block in APK Signing Block&quot;); } 上述代码中关键的一个位置是&nbsp;if (id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID) {return getByteBuffer(pairs, len - 4);}，通过源代码可以看出Android是通过查找ID为&nbsp;APK_SIGNATURE_SCHEME_V2_BLOCK_ID = 0x7109871a&nbsp;的ID-value，来获取APK Signature Scheme v2 Block，对这个区块中其他的ID-value选择了忽略。 在APK Signature Scheme v2中没有看到对无法识别的ID，有相关处理的介绍。 当看到这里时，我们可不可以设想一下，提供一个自定义的ID-value并写入该区域，从而为快速生成渠道包服务呢？ 怎么向ID-value中添加信息呢？通过阅读ZIP的文件格式和APK Signing Block格式的描述，笔者通过编写下面的代码片段进行验证，发现通过在已经被新的应用签名方案签名后的APK中添加自定义的ID-value，是不需要再次经过签名就能安装的，下面是部分代码片段。 public void writeApkSigningBlock(DataOutput dataOutput) { long length = 24; for (int index = 0; index &lt; payloads.size(); ++index) { ApkSigningPayload payload = payloads.get(index); byte[] bytes = payload.getByteBuffer(); length += 12 + bytes.length; } ByteBuffer byteBuffer = ByteBuffer.allocate(Long.BYTES); byteBuffer.order(ByteOrder.LITTLE_ENDIAN); byteBuffer.putLong(length); dataOutput.write(byteBuffer.array()); for (int index = 0; index &lt; payloads.size(); ++index) { ApkSigningPayload payload = payloads.get(index); byte[] bytes = payload.getByteBuffer(); byteBuffer = ByteBuffer.allocate(Integer.BYTES); byteBuffer.order(ByteOrder.LITTLE_ENDIAN); byteBuffer.putInt(payload.getId()); dataOutput.write(byteBuffer.array()); dataOutput.write(bytes); } ... } 新一代渠道包生成工具 到这里为止一个新的渠道包生成方案逐步清晰了起来，下面是新一代渠道包生成工具的描述： 对新的应用签名方案生成的APK包中的ID-value进行扩展，提供自定义ID－value（渠道信息），并保存在APK中 而APK在安装过程中进行的签名校验，是忽略我们添加的这个ID-value的，这样就能正常安装了 在App运行阶段，可以通过ZIP的EOCD（End of central directory）、Central directory等结构中的信息（会涉及ZIP格式的相关知识，这里不做展开描述）找到我们自己添加的ID-value，从而实现获取渠道信息的功能 新一代渠道包生成工具完全是基于ZIP文件格式和APK Signing Block存储格式而构建，基于文件的二进制流进行处理，有着良好的处理速度和兼容性，能够满足不同的语言编写的要求，目前笔者采用的是Java＋Groovy开发， 该工具主要有四部分组成： 用于写入ID-value信息的Java类库 Gradle构建插件用来和Android的打包流程进行结合 用于读取ID-value信息的Java类库 用于供com.android.application使用的读取渠道信息的AAR 这样，每打一个渠道包只需复制一个APK，然后在APK中添加一个ID-value即可，这种打包方式速度非常快，对一个30M大小的APK包只需要100多毫秒（包含文件复制时间）就能生成一个渠道包，而在运行时获取渠道信息只需要大约几毫秒的时间。 这个项目我们取名为Walle（瓦力），已经开源，项目的Github地址是：&nbsp;https://github.com/Meituan-Dianping/walle&nbsp;（求Issue、PR、Star）。希望业内有类似需求的团队能够在APK Signature Scheme V2签名下愉快地生成渠道包，同时也期待大家一起对该项目进行完善和优化。 总结 以上就是我们对新的应用签名方案进行的分析，并根据它所带来的文件存储格式上的变化，找到了可以利用的ID-value，然后基于这个ID-value来构建我们新一代渠道包生成工具。 新一代渠道包生成工具能够满足新应用签名方案对安全性的要求，同时也能满足对渠道包打包时间的要求，至此大家生成渠道包的方式需要升级了！ 文章中引用的图片来源于：https://source.android.com/security/apksigning/v2.html 上面是关于工具实现的介绍，下面介绍工具的使用：https://github.com/Meituan-Dianping/walle Gradle插件使用方式 配置build.gradle 在位于项目的根目录 build.gradle 文件中添加Walle Gradle插件的依赖， 如下： buildscript { dependencies { classpath &#39;com.meituan.android.walle:plugin:1.1.6&#39; } } 并在当前App的 build.gradle 文件中apply这个插件，并添加上用于读取渠道号的AAR apply plugin: &#39;walle&#39; dependencies { compile &#39;com.meituan.android.walle:library:1.1.6&#39; } 配置插件 walle { // 指定渠道包的输出路径 apkOutputFolder = new File(&quot;${project.buildDir}/outputs/channels&quot;); // 定制渠道包的APK的文件名称 apkFileNameFormat = &#39;${appName}-${packageName}-${channel}-${buildType}-v${versionName}-${versionCode}-${buildTime}.apk&#39;; // 渠道配置文件 channelFile = new File(&quot;${project.getProjectDir()}/channel&quot;) } 配置项具体解释： apkOutputFolder：指定渠道包的输出路径， 默认值为new File(&quot;${project.buildDir}/outputs/apk&quot;) apkFileNameFormat：定制渠道包的APK的文件名称, 默认值为&#39;${appName}-${buildType}-${channel}.apk&#39; 可使用以下变量: projectName - 项目名字 appName - App模块名字 packageName - applicationId (App包名packageName) buildType - buildType (release/debug等) channel - channel名称 (对应渠道打包中的渠道名字) versionName - versionName (显示用的版本号) versionCode - versionCode (内部版本号) buildTime - buildTime (编译构建日期时间) fileSHA1 - fileSHA1 (最终APK文件的SHA1哈希值) flavorName - 编译构建 productFlavors 名 channelFile：包含渠道配置信息的文件路径。 具体内容格式详见：渠道配置文件示例，支持使用#号添加注释。 如何获取渠道信息 在需要渠道等信息时可以通过下面代码进行获取 String channel = WalleChannelReader.getChannel(this.getApplicationContext()); 如何生成渠道包 生成渠道包的方式是和assemble${variantName}Channels指令结合，渠道包的生成目录默认存放在 build/outputs/apk/，也可以通过walle闭包中的apkOutputFolder参数来指定输出目录 用法示例： 生成渠道包 ./gradlew clean assembleReleaseChannels 支持 productFlavors ./gradlew clean assembleMeituanReleaseChannels 临时生成某渠道包 我们推荐使用channelFile/configFile配置来生成渠道包，但有时也可能有临时生成渠道包需求，这时可以使用： 生成单个渠道包: ./gradlew clean assembleReleaseChannels -PchannelList=meituan 生成多个渠道包: ./gradlew clean assembleReleaseChannels -PchannelList=meituan,dianping 基于360加固后签名失效的解决方案： https://github.com/Jay-Goo/ProtectedApkResignerForWalle 其中的配置 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/30/4acdc6ec061d6e019795d60743aae43e.html" />
<meta property="og:url" content="https://mlh.app/2018/03/30/4acdc6ec061d6e019795d60743aae43e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-30T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"官方介绍&nbsp;https://tech.meituan.com/android-apk-v2-signature-scheme.html 因为在Android 7.0（Nougat）推出了新的应用签名方案APK Signature Scheme v2，用之前快速生成渠道包的方式（美团Android自动化之旅—生成渠道包）打出来的包，没法签名。因此有了现在新的渠道包打包工具walle。 新的应用签名方案APK Signature Scheme v2 Android 7.0（Nougat）引入一项新的应用签名方案APK Signature Scheme v2，它是一个对全文件进行签名的方案，能提供更快的应用安装时间、对未授权APK文件的更改提供更多保护，在默认情况下，Android Gradle 2.2.0插件会使用APK Signature Scheme v2和传统签名方案来签署你的应用。 下面以&nbsp;新的应用签名方案&nbsp;来指APK Signature Scheme v2。 目前该方案不是强制性的，在&nbsp;build.gradle&nbsp;添加&nbsp;v2SigningEnabled false&nbsp;，就能使用传统签名方案来签署我们的应用（见下面的代码片段）。 android { ... defaultConfig { ... } signingConfigs { release { storeFile file(&quot;myreleasekey.keystore&quot;) storePassword &quot;password&quot; keyAlias &quot;MyReleaseKey&quot; keyPassword &quot;password&quot; v2SigningEnabled false } } } 但新的应用签名方案有着良好的向后兼容性，能完全兼容低于Android 7.0（Nougat）的版本。对比旧签名方案，它有更快的验证速度和更安全的保护，因此新的应用签名方案可能会被采纳成一个强制配置，笔者认为现在有必要对现有的渠道包生成方式进行检查、升级或改造来支持新的应用签名方案。 新的签名方案对已有的渠道生成方案有什么影响呢？下图是新的应用签名方案和旧的签名方案的一个对比： 新的签名方案会在ZIP文件格式的&nbsp;Central Directory&nbsp;区块所在文件位置的前面添加一个APK Signing Block区块，下面按照ZIP文件的格式来分析新应用签名方案签名后的APK包。 整个APK（ZIP文件格式）会被分为以下四个区块： Contents of ZIP entries（from offset 0 until the start of APK Signing Block） APK Signing Block ZIP Central Directory ZIP End of Central Directory 新应用签名方案的签名信息会被保存在区块2（APK Signing Block）中， 而区块1（Contents of ZIP entries）、区块3（ZIP Central Directory）、区块4（ZIP End of Central Directory）是受保护的，在签名后任何对区块1、3、4的修改都逃不过新的应用签名方案的检查。 之前的渠道包生成方案是通过在META-INF目录下添加空文件，用空文件的名称来作为渠道的唯一标识，之前在META-INF下添加文件是不需要重新签名应用的，这样会节省不少打包的时间，从而提高打渠道包的速度。但在新的应用签名方案下META-INF已经被列入了保护区了，向META-INF添加空文件的方案会对区块1、3、4都会有影响，新应用签名方案签署的应用经过我们旧的生成渠道包方案处理后，在安装时会报以下错误： Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates from base.apk: META-INF/CERT.SF indicates base.apk is signed using APK Signature Scheme v2, but no such signature was found. Signature stripped?] 目前另外一种比较流行的渠道包快速生成方案（往APK中添加ZIP Comment）也因为上述原因，无法在新的应用签名方案下进行正常工作。 如果新的应用签名方案后续改成强制要求，那我们现有的生成渠道包的方式就会无法工作，那我们难道要退回到解放前，通过传统的方式（例如：使用APKTool逆向工具、采用Flavor ＋ BuildType等比较耗时的方案来进行渠道包打包）来生成支持新应用签名方案的渠道包吗？ 如果只有少量渠道包的场景下，这种耗时时长还能够勉强接受。但是目前我们有将近900个渠道，如果采用传统方式打完所有的渠道包需要近3个小时，这是不能接受的。 那我们有没有其他更好的渠道包生成方式，既能支持新的应用签名方案，又能体验毫秒级的打包耗时呢？我们来分析一下新方案中的区块2——Block。 可扩展的APK Signature Scheme v2 Block 通过上面的描述，可以看出因为APK包的区块1、3、4都是受保护的，任何修改在签名后对它们的修改，都会在安装过程中被签名校验检测失败，而区块2（APK Signing Block）是不受签名校验规则保护的，那是否可以在这个不受签名保护的区块2（APK Signing Block）上做文章呢？我们先来看看对区块2格式的描述： 偏移 字节数 描述 @+0 8 这个Block的长度（本字段的长度不计算在内） @+8 n 一组ID-value @-24 8 这个Block的长度（和第一个字段一样值） @-16 16 魔数 “APK Sig Block 42” 区块2中APK Signing Block是由这几部分组成：2个用来标示这个区块长度的8字节 ＋ 这个区块的魔数（APK Sig Block 42）+ 这个区块所承载的数据（ID-value）。 我们重点来看一下这个ID-value，它由一个8字节的长度标示＋4字节的ID＋它的负载组成。V2的签名信息是以ID（0x7109871a）的ID-value来保存在这个区块中，不知大家有没有注意这是一组ID-value，也就是说它是可以有若干个这样的ID-value来组成，那我们是不是可以在这里做一些文章呢？ 为了验证我们的想法，先来看看新的应用签名方案是怎么验证签名信息的，见下图： 通过上图可以看出新的应用签名方案的验证过程： 寻找APK Signing Block，如果能够找到，则进行验证，验证成功则继续进行安装，如果失败了则终止安装 如果未找到APK Signing Block，则执行原来的签名验证机制，也是验证成功则继续进行安装，如果失败了则终止安装 那Android应用在安装时新的应用签名方案是怎么进行校验的呢？笔者通过翻阅Android相关部分的源码，发现下面代码段是用来处理上面所说的ID-value的： public static ByteBuffer findApkSignatureSchemeV2Block( ByteBuffer apkSigningBlock, Result result) throws SignatureNotFoundException { checkByteOrderLittleEndian(apkSigningBlock); // FORMAT: // OFFSET DATA TYPE DESCRIPTION // * @+0 bytes uint64: size in bytes (excluding this field) // * @+8 bytes pairs // * @-24 bytes uint64: size in bytes (same as the one above) // * @-16 bytes uint128: magic ByteBuffer pairs = sliceFromTo(apkSigningBlock, 8, apkSigningBlock.capacity() - 24); int entryCount = 0; while (pairs.hasRemaining()) { entryCount++; if (pairs.remaining() &lt; 8) { throw new SignatureNotFoundException( &quot;Insufficient data to read size of APK Signing Block entry #&quot; + entryCount); } long lenLong = pairs.getLong(); if ((lenLong &lt; 4) || (lenLong &gt; Integer.MAX_VALUE)) { throw new SignatureNotFoundException( &quot;APK Signing Block entry #&quot; + entryCount + &quot; size out of range: &quot; + lenLong); } int len = (int) lenLong; int nextEntryPos = pairs.position() + len; if (len &gt; pairs.remaining()) { throw new SignatureNotFoundException( &quot;APK Signing Block entry #&quot; + entryCount + &quot; size out of range: &quot; + len + &quot;, available: &quot; + pairs.remaining()); } int id = pairs.getInt(); if (id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID) { return getByteBuffer(pairs, len - 4); } result.addWarning(Issue.APK_SIG_BLOCK_UNKNOWN_ENTRY_ID, id); pairs.position(nextEntryPos); } throw new SignatureNotFoundException( &quot;No APK Signature Scheme v2 block in APK Signing Block&quot;); } 上述代码中关键的一个位置是&nbsp;if (id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID) {return getByteBuffer(pairs, len - 4);}，通过源代码可以看出Android是通过查找ID为&nbsp;APK_SIGNATURE_SCHEME_V2_BLOCK_ID = 0x7109871a&nbsp;的ID-value，来获取APK Signature Scheme v2 Block，对这个区块中其他的ID-value选择了忽略。 在APK Signature Scheme v2中没有看到对无法识别的ID，有相关处理的介绍。 当看到这里时，我们可不可以设想一下，提供一个自定义的ID-value并写入该区域，从而为快速生成渠道包服务呢？ 怎么向ID-value中添加信息呢？通过阅读ZIP的文件格式和APK Signing Block格式的描述，笔者通过编写下面的代码片段进行验证，发现通过在已经被新的应用签名方案签名后的APK中添加自定义的ID-value，是不需要再次经过签名就能安装的，下面是部分代码片段。 public void writeApkSigningBlock(DataOutput dataOutput) { long length = 24; for (int index = 0; index &lt; payloads.size(); ++index) { ApkSigningPayload payload = payloads.get(index); byte[] bytes = payload.getByteBuffer(); length += 12 + bytes.length; } ByteBuffer byteBuffer = ByteBuffer.allocate(Long.BYTES); byteBuffer.order(ByteOrder.LITTLE_ENDIAN); byteBuffer.putLong(length); dataOutput.write(byteBuffer.array()); for (int index = 0; index &lt; payloads.size(); ++index) { ApkSigningPayload payload = payloads.get(index); byte[] bytes = payload.getByteBuffer(); byteBuffer = ByteBuffer.allocate(Integer.BYTES); byteBuffer.order(ByteOrder.LITTLE_ENDIAN); byteBuffer.putInt(payload.getId()); dataOutput.write(byteBuffer.array()); dataOutput.write(bytes); } ... } 新一代渠道包生成工具 到这里为止一个新的渠道包生成方案逐步清晰了起来，下面是新一代渠道包生成工具的描述： 对新的应用签名方案生成的APK包中的ID-value进行扩展，提供自定义ID－value（渠道信息），并保存在APK中 而APK在安装过程中进行的签名校验，是忽略我们添加的这个ID-value的，这样就能正常安装了 在App运行阶段，可以通过ZIP的EOCD（End of central directory）、Central directory等结构中的信息（会涉及ZIP格式的相关知识，这里不做展开描述）找到我们自己添加的ID-value，从而实现获取渠道信息的功能 新一代渠道包生成工具完全是基于ZIP文件格式和APK Signing Block存储格式而构建，基于文件的二进制流进行处理，有着良好的处理速度和兼容性，能够满足不同的语言编写的要求，目前笔者采用的是Java＋Groovy开发， 该工具主要有四部分组成： 用于写入ID-value信息的Java类库 Gradle构建插件用来和Android的打包流程进行结合 用于读取ID-value信息的Java类库 用于供com.android.application使用的读取渠道信息的AAR 这样，每打一个渠道包只需复制一个APK，然后在APK中添加一个ID-value即可，这种打包方式速度非常快，对一个30M大小的APK包只需要100多毫秒（包含文件复制时间）就能生成一个渠道包，而在运行时获取渠道信息只需要大约几毫秒的时间。 这个项目我们取名为Walle（瓦力），已经开源，项目的Github地址是：&nbsp;https://github.com/Meituan-Dianping/walle&nbsp;（求Issue、PR、Star）。希望业内有类似需求的团队能够在APK Signature Scheme V2签名下愉快地生成渠道包，同时也期待大家一起对该项目进行完善和优化。 总结 以上就是我们对新的应用签名方案进行的分析，并根据它所带来的文件存储格式上的变化，找到了可以利用的ID-value，然后基于这个ID-value来构建我们新一代渠道包生成工具。 新一代渠道包生成工具能够满足新应用签名方案对安全性的要求，同时也能满足对渠道包打包时间的要求，至此大家生成渠道包的方式需要升级了！ 文章中引用的图片来源于：https://source.android.com/security/apksigning/v2.html 上面是关于工具实现的介绍，下面介绍工具的使用：https://github.com/Meituan-Dianping/walle Gradle插件使用方式 配置build.gradle 在位于项目的根目录 build.gradle 文件中添加Walle Gradle插件的依赖， 如下： buildscript { dependencies { classpath &#39;com.meituan.android.walle:plugin:1.1.6&#39; } } 并在当前App的 build.gradle 文件中apply这个插件，并添加上用于读取渠道号的AAR apply plugin: &#39;walle&#39; dependencies { compile &#39;com.meituan.android.walle:library:1.1.6&#39; } 配置插件 walle { // 指定渠道包的输出路径 apkOutputFolder = new File(&quot;${project.buildDir}/outputs/channels&quot;); // 定制渠道包的APK的文件名称 apkFileNameFormat = &#39;${appName}-${packageName}-${channel}-${buildType}-v${versionName}-${versionCode}-${buildTime}.apk&#39;; // 渠道配置文件 channelFile = new File(&quot;${project.getProjectDir()}/channel&quot;) } 配置项具体解释： apkOutputFolder：指定渠道包的输出路径， 默认值为new File(&quot;${project.buildDir}/outputs/apk&quot;) apkFileNameFormat：定制渠道包的APK的文件名称, 默认值为&#39;${appName}-${buildType}-${channel}.apk&#39; 可使用以下变量: projectName - 项目名字 appName - App模块名字 packageName - applicationId (App包名packageName) buildType - buildType (release/debug等) channel - channel名称 (对应渠道打包中的渠道名字) versionName - versionName (显示用的版本号) versionCode - versionCode (内部版本号) buildTime - buildTime (编译构建日期时间) fileSHA1 - fileSHA1 (最终APK文件的SHA1哈希值) flavorName - 编译构建 productFlavors 名 channelFile：包含渠道配置信息的文件路径。 具体内容格式详见：渠道配置文件示例，支持使用#号添加注释。 如何获取渠道信息 在需要渠道等信息时可以通过下面代码进行获取 String channel = WalleChannelReader.getChannel(this.getApplicationContext()); 如何生成渠道包 生成渠道包的方式是和assemble${variantName}Channels指令结合，渠道包的生成目录默认存放在 build/outputs/apk/，也可以通过walle闭包中的apkOutputFolder参数来指定输出目录 用法示例： 生成渠道包 ./gradlew clean assembleReleaseChannels 支持 productFlavors ./gradlew clean assembleMeituanReleaseChannels 临时生成某渠道包 我们推荐使用channelFile/configFile配置来生成渠道包，但有时也可能有临时生成渠道包需求，这时可以使用： 生成单个渠道包: ./gradlew clean assembleReleaseChannels -PchannelList=meituan 生成多个渠道包: ./gradlew clean assembleReleaseChannels -PchannelList=meituan,dianping 基于360加固后签名失效的解决方案： https://github.com/Jay-Goo/ProtectedApkResignerForWalle 其中的配置 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/30/4acdc6ec061d6e019795d60743aae43e.html","headline":"美团新一代渠道包打包神器walle","dateModified":"2018-03-30T00:00:00+08:00","datePublished":"2018-03-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/30/4acdc6ec061d6e019795d60743aae43e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>美团新一代渠道包打包神器walle</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">官方介绍&nbsp;<a href="https://tech.meituan.com/android-apk-v2-signature-scheme.html" rel="nofollow">https://tech.meituan.com/android-apk-v2-signature-scheme.html</a></p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">因为<span style="color:rgb(102,102,102);font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;font-size:13.92px;">在Android 7.0（Nougat）推出了新的应用签名方案APK Signature Scheme v2，用<span style="color:rgb(102,102,102);font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;font-size:13.92px;">之前快速生成渠道包的方式（</span><a href="http://tech.meituan.com/mt-apk-packaging.html" rel="nofollow" style="font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;font-size:13.92px;text-decoration:none;color:rgb(50,211,195);">美团Android自动化之旅—生成渠道包</a><span style="color:rgb(102,102,102);font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;font-size:13.92px;">）打出来的包，没法签名。因此<span style="color:rgb(102,102,102);font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;font-size:13.92px;">有了现在新的渠道包打包工具walle。</span></span></span></p>
  <h2 id="-apk-signature-scheme-v2" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.73em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">新的应用签名方案APK Signature Scheme v2</h2>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">Android 7.0（Nougat）引入一项新的应用签名方案<a href="https://source.android.com/security/apksigning/v2.html" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">APK Signature Scheme v2</a>，它是一个对全文件进行签名的方案，能提供更快的应用安装时间、对未授权APK文件的更改提供更多保护，在默认情况下，Android Gradle 2.2.0插件会使用APK Signature Scheme v2和传统签名方案来签署你的应用。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">下面以&nbsp;<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">新的应用签名方案</code>&nbsp;来指APK Signature Scheme v2。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">目前该方案不是强制性的，在&nbsp;<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">build.gradle</code>&nbsp;添加&nbsp;<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">v2SigningEnabled false</code>&nbsp;，就能使用传统签名方案来签署我们的应用（见下面的代码片段）。</p>
  <pre style="font-family:'Helvetica Regular';overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code class="groovy" style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">  android {
    ...
    defaultConfig { ... }
    signingConfigs {
      release {
        storeFile file(<span class="string">"myreleasekey.keystore"</span>)
        storePassword <span class="string">"password"</span>
        keyAlias <span class="string">"MyReleaseKey"</span>
        keyPassword <span class="string">"password"</span>
        v2SigningEnabled <span class="literal">false</span>
      }
    }
  }
</code></pre>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">但新的应用签名方案有着良好的向后兼容性，能完全兼容低于Android 7.0（Nougat）的版本。对比旧签名方案，它有更快的验证速度和更安全的保护，因此新的应用签名方案可能会被采纳成一个强制配置，笔者认为现在有必要对现有的渠道包生成方式进行检查、升级或改造来支持新的应用签名方案。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">新的签名方案对已有的渠道生成方案有什么影响呢？下图是新的应用签名方案和旧的签名方案的一个对比：</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;"><img src="https://tech.meituan.com/img/android-v2-signature/apk-before-after-signing.png" style="border:0px;color:#FFFFFF;vertical-align:middle;" alt=""></p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">新的签名方案会在ZIP文件格式的&nbsp;<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">Central Directory</code>&nbsp;区块所在文件位置的前面添加一个APK Signing Block区块，下面按照ZIP文件的格式来分析新应用签名方案签名后的APK包。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">整个APK（ZIP文件格式）会被分为以下四个区块：</p>
  <ol style="color:rgb(68,68,68);font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">
   <li style="color:rgb(102,102,102);">Contents of ZIP entries（from offset 0 until the start of APK Signing Block）</li>
   <li style="color:rgb(102,102,102);">APK Signing Block</li>
   <li style="color:rgb(102,102,102);">ZIP Central Directory</li>
   <li style="color:rgb(102,102,102);">ZIP End of Central Directory</li>
  </ol>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;"><img src="https://tech.meituan.com/img/android-v2-signature/apk-sections.png" style="border:0px;color:#FFFFFF;vertical-align:middle;" alt=""></p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">新应用签名方案的签名信息会被保存在区块2（APK Signing Block）中， 而区块1（<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">Contents of ZIP entries</code>）、区块3（<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">ZIP Central Directory</code>）、区块4（<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">ZIP End of Central Directory</code>）是受保护的，在签名后任何对区块1、3、4的修改都逃不过新的应用签名方案的检查。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">之前的渠道包生成方案是通过在META-INF目录下添加空文件，用空文件的名称来作为渠道的唯一标识，之前在META-INF下添加文件是不需要重新签名应用的，这样会节省不少打包的时间，从而提高打渠道包的速度。但在新的应用签名方案下META-INF已经被列入了保护区了，向META-INF添加空文件的方案会对区块1、3、4都会有影响，新应用签名方案签署的应用经过我们旧的生成渠道包方案处理后，在安装时会报以下错误：</p>
  <pre style="font-family:'Helvetica Regular';overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: 
Failed to collect certificates from base.apk: META-INF/CERT.SF indicates base.apk is signed using APK Signature Scheme v2, 
but no such signature was found. Signature stripped?]
</code></pre>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">目前另外一种比较流行的<a href="http://linghaolu.github.io/apk/2016/04/02/apk-comment.html" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">渠道包快速生成方案</a>（往APK中添加ZIP Comment）也因为上述原因，无法在新的应用签名方案下进行正常工作。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">如果新的应用签名方案后续改成强制要求，那我们现有的生成渠道包的方式就会无法工作，那我们难道要退回到解放前，通过传统的方式（例如：使用APKTool逆向工具、采用Flavor ＋ BuildType等比较耗时的方案来进行渠道包打包）来生成支持新应用签名方案的渠道包吗？</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">如果只有少量渠道包的场景下，这种耗时时长还能够勉强接受。但是目前我们有将近900个渠道，如果采用传统方式打完所有的渠道包需要近3个小时，这是不能接受的。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">那我们有没有其他更好的渠道包生成方式，既能支持新的应用签名方案，又能体验毫秒级的打包耗时呢？我们来分析一下新方案中的区块2——Block。</p>
  <h2 id="-apk-signature-scheme-v2-block" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.73em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">可扩展的APK Signature Scheme v2 Block</h2>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">通过上面的描述，可以看出因为APK包的区块1、3、4都是受保护的，任何修改在签名后对它们的修改，都会在安装过程中被签名校验检测失败，而区块2（APK Signing Block）是不受签名校验规则保护的，那是否可以在这个不受签名保护的区块2（APK Signing Block）上做文章呢？我们先来看看对区块2格式的描述：</p>
  <table style="border-collapse:collapse;border-spacing:0px;color:rgb(68,68,68);font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;font-size:12px;">
   <thead>
    <tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);">
     <th style="text-align:left;">偏移</th>
     <th style="text-align:center;">字节数</th>
     <th style="text-align:left;">描述</th>
    </tr>
   </thead>
   <tbody>
    <tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);">
     <td style="vertical-align:top;">@+0</td>
     <td style="vertical-align:top;text-align:center;">8</td>
     <td style="vertical-align:top;">这个Block的长度（本字段的长度不计算在内）</td>
    </tr>
    <tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);">
     <td style="vertical-align:top;">@+8</td>
     <td style="vertical-align:top;text-align:center;">n</td>
     <td style="vertical-align:top;">一组ID-value</td>
    </tr>
    <tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);">
     <td style="vertical-align:top;">@-24</td>
     <td style="vertical-align:top;text-align:center;">8</td>
     <td style="vertical-align:top;">这个Block的长度（和第一个字段一样值）</td>
    </tr>
    <tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);">
     <td style="vertical-align:top;">@-16</td>
     <td style="vertical-align:top;text-align:center;">16</td>
     <td style="vertical-align:top;">魔数 “APK Sig Block 42”</td>
    </tr>
   </tbody>
  </table>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">区块2中APK Signing Block是由这几部分组成：2个用来标示这个区块长度的8字节 ＋ 这个区块的魔数（<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">APK Sig Block 42</code>）+ 这个区块所承载的数据（ID-value）。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">我们重点来看一下这个ID-value，它由一个8字节的长度标示＋4字节的ID＋它的负载组成。V2的签名信息是以ID（<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">0x7109871a</code>）的ID-value来保存在这个区块中，不知大家有没有注意这是一组ID-value，也就是说它是可以有若干个这样的ID-value来组成，那我们是不是可以在这里做一些文章呢？</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">为了验证我们的想法，先来看看新的应用签名方案是怎么验证签名信息的，见下图：</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;"><img src="https://tech.meituan.com/img/android-v2-signature/apk-validation-process.png" style="border:0px;color:#FFFFFF;vertical-align:middle;" alt=""></p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">通过上图可以看出新的应用签名方案的验证过程：</p>
  <ol style="color:rgb(68,68,68);font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">
   <li style="color:rgb(102,102,102);">寻找APK Signing Block，如果能够找到，则进行验证，验证成功则继续进行安装，如果失败了则终止安装</li>
   <li style="color:rgb(102,102,102);">如果未找到APK Signing Block，则执行原来的签名验证机制，也是验证成功则继续进行安装，如果失败了则终止安装</li>
  </ol>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">那Android应用在安装时新的应用签名方案是怎么进行校验的呢？笔者通过翻阅Android相关部分的源码，发现下面代码段是用来处理上面所说的ID-value的：</p>
  <pre style="font-family:'Helvetica Regular';overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code class="java" style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">findApkSignatureSchemeV2Block</span><span class="params">( ByteBuffer apkSigningBlock, Result result)</span> <span class="keyword">throws</span> SignatureNotFoundException </span>{
        checkByteOrderLittleEndian(apkSigningBlock);
        <span class="comment">// FORMAT:</span>
        <span class="comment">// OFFSET DATA TYPE DESCRIPTION</span>
        <span class="comment">// * @+0 bytes uint64: size in bytes (excluding this field)</span>
        <span class="comment">// * @+8 bytes pairs</span>
        <span class="comment">// * @-24 bytes uint64: size in bytes (same as the one above)</span>
        <span class="comment">// * @-16 bytes uint128: magic</span>
        ByteBuffer pairs = sliceFromTo(apkSigningBlock, <span class="number">8</span>, apkSigningBlock.capacity() - <span class="number">24</span>);

        <span class="keyword">int</span> entryCount = <span class="number">0</span>;
        <span class="keyword">while</span> (pairs.hasRemaining()) {
            entryCount++;
            <span class="keyword">if</span> (pairs.remaining() &lt; <span class="number">8</span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> SignatureNotFoundException(
                        <span class="string">"Insufficient data to read size of APK Signing Block entry #"</span> + entryCount);
            }
            <span class="keyword">long</span> lenLong = pairs.getLong();
            <span class="keyword">if</span> ((lenLong &lt; <span class="number">4</span>) || (lenLong &gt; Integer.MAX_VALUE)) {
                <span class="keyword">throw</span> <span class="keyword">new</span> SignatureNotFoundException(
                        <span class="string">"APK Signing Block entry #"</span> + entryCount
                                + <span class="string">" size out of range: "</span> + lenLong);
            }
            <span class="keyword">int</span> len = (<span class="keyword">int</span>) lenLong;
            <span class="keyword">int</span> nextEntryPos = pairs.position() + len;
            <span class="keyword">if</span> (len &gt; pairs.remaining()) {
                <span class="keyword">throw</span> <span class="keyword">new</span> SignatureNotFoundException(
                        <span class="string">"APK Signing Block entry #"</span> + entryCount + <span class="string">" size out of range: "</span> + len
                                + <span class="string">", available: "</span> + pairs.remaining());
            }
            <span class="keyword">int</span> id = pairs.getInt();
            <span class="keyword">if</span> (id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID) {
                <span class="keyword">return</span> getByteBuffer(pairs, len - <span class="number">4</span>);
            }
            result.addWarning(Issue.APK_SIG_BLOCK_UNKNOWN_ENTRY_ID, id);
            pairs.position(nextEntryPos);
        }

        <span class="keyword">throw</span> <span class="keyword">new</span> SignatureNotFoundException(
                <span class="string">"No APK Signature Scheme v2 block in APK Signing Block"</span>);
    }
</code></pre>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">上述代码中关键的一个位置是&nbsp;<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">if (id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID) {return getByteBuffer(pairs, len - 4);}</code>，通过源代码可以看出Android是通过查找ID为&nbsp;<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">APK_SIGNATURE_SCHEME_V2_BLOCK_ID = 0x7109871a</code>&nbsp;的ID-value，来获取APK Signature Scheme v2 Block，对这个区块中其他的ID-value选择了忽略。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">在<a href="https://source.android.com/security/apksigning/v2.html" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">APK Signature Scheme v2</a>中没有看到对无法识别的ID，有相关处理的介绍。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">当看到这里时，我们可不可以设想一下，提供一个自定义的ID-value并写入该区域，从而为快速生成渠道包服务呢？</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">怎么向ID-value中添加信息呢？通过阅读ZIP的文件格式和APK Signing Block格式的描述，笔者通过编写下面的代码片段进行验证，发现通过在已经被新的应用签名方案签名后的APK中添加自定义的ID-value，是不需要再次经过签名就能安装的，下面是部分代码片段。</p>
  <pre style="font-family:'Helvetica Regular';overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code class="java" style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeApkSigningBlock</span><span class="params">(DataOutput dataOutput)</span> </span>{
        <span class="keyword">long</span> length = <span class="number">24</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; payloads.size(); ++index) {
            ApkSigningPayload payload = payloads.get(index);
            <span class="keyword">byte</span>[] bytes = payload.getByteBuffer();
            length += <span class="number">12</span> + bytes.length;
        }

        ByteBuffer byteBuffer = ByteBuffer.allocate(Long.BYTES);
        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
        byteBuffer.putLong(length);
        dataOutput.write(byteBuffer.array());

        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; payloads.size(); ++index) {
            ApkSigningPayload payload = payloads.get(index);
            <span class="keyword">byte</span>[] bytes = payload.getByteBuffer();

            byteBuffer = ByteBuffer.allocate(Integer.BYTES);
            byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
            byteBuffer.putInt(payload.getId());
            dataOutput.write(byteBuffer.array());

            dataOutput.write(bytes);
        }
        ...
    }
</code></pre>
  <h2 id="-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.73em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">新一代渠道包生成工具</h2>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">到这里为止一个新的渠道包生成方案逐步清晰了起来，下面是新一代渠道包生成工具的描述：</p>
  <ol style="color:rgb(68,68,68);font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">
   <li style="color:rgb(102,102,102);">对新的应用签名方案生成的APK包中的ID-value进行扩展，提供自定义ID－value（渠道信息），并保存在APK中</li>
   <li style="color:rgb(102,102,102);">而APK在安装过程中进行的签名校验，是忽略我们添加的这个ID-value的，这样就能正常安装了</li>
   <li style="color:rgb(102,102,102);">在App运行阶段，可以通过ZIP的<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">EOCD（End of central directory）</code>、<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">Central directory</code>等结构中的信息（会涉及ZIP格式的相关知识，这里不做展开描述）找到我们自己添加的ID-value，从而实现获取渠道信息的功能</li>
  </ol>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">新一代渠道包生成工具完全是基于ZIP文件格式和APK Signing Block存储格式而构建，基于文件的二进制流进行处理，有着良好的处理速度和兼容性，能够满足不同的语言编写的要求，目前笔者采用的是Java＋Groovy开发， 该工具主要有四部分组成：</p>
  <ol style="color:rgb(68,68,68);font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">
   <li style="color:rgb(102,102,102);">用于写入ID-value信息的Java类库</li>
   <li style="color:rgb(102,102,102);">Gradle构建插件用来和Android的打包流程进行结合</li>
   <li style="color:rgb(102,102,102);">用于读取ID-value信息的Java类库</li>
   <li style="color:rgb(102,102,102);">用于供<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">com.android.application</code>使用的读取渠道信息的AAR</li>
  </ol>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">这样，每打一个渠道包只需复制一个APK，然后在APK中添加一个ID-value即可，这种打包方式速度非常快，对一个30M大小的APK包只需要100多毫秒（包含文件复制时间）就能生成一个渠道包，而在运行时获取渠道信息只需要大约几毫秒的时间。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">这个项目我们取名为Walle（瓦力），已经开源，项目的Github地址是：&nbsp;<a href="https://github.com/Meituan-Dianping/walle" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">https://github.com/Meituan-Dianping/walle</a>&nbsp;（求Issue、PR、Star）。希望业内有类似需求的团队能够在APK Signature Scheme V2签名下愉快地生成渠道包，同时也期待大家一起对该项目进行完善和优化。</p>
  <h2 style="color:rgb(42,41,53);line-height:1.5em;font-size:1.73em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">总结</h2>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">以上就是我们对新的应用签名方案进行的分析，并根据它所带来的文件存储格式上的变化，找到了可以利用的ID-value，然后基于这个ID-value来构建我们新一代渠道包生成工具。</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">新一代渠道包生成工具能够满足新应用签名方案对安全性的要求，同时也能满足对渠道包打包时间的要求，至此大家生成渠道包的方式需要升级了！</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">文章中引用的图片来源于：<a href="https://source.android.com/security/apksigning/v2.html" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">https://source.android.com/security/apksigning/v2.html</a></p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;"><br></p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;"><br></p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">上面是关于工具实现的介绍，下面介绍工具的使用：<a href="https://github.com/Meituan-Dianping/walle" rel="nofollow">https://github.com/Meituan-Dianping/walle</a></p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;"><br></p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;"></p>
  <pre><code class="language-java">Gradle插件使用方式

配置build.gradle

在位于项目的根目录 build.gradle 文件中添加Walle Gradle插件的依赖， 如下：

buildscript {
    dependencies {
        classpath 'com.meituan.android.walle:plugin:1.1.6'
    }
}
并在当前App的 build.gradle 文件中apply这个插件，并添加上用于读取渠道号的AAR

apply plugin: 'walle'

dependencies {
    compile 'com.meituan.android.walle:library:1.1.6'
}
配置插件

walle {
    // 指定渠道包的输出路径
    apkOutputFolder = new File("${project.buildDir}/outputs/channels");
    // 定制渠道包的APK的文件名称
    apkFileNameFormat = '${appName}-${packageName}-${channel}-${buildType}-v${versionName}-${versionCode}-${buildTime}.apk';
    // 渠道配置文件
    channelFile = new File("${project.getProjectDir()}/channel")
}
配置项具体解释：

apkOutputFolder：指定渠道包的输出路径， 默认值为new File("${project.buildDir}/outputs/apk")

apkFileNameFormat：定制渠道包的APK的文件名称, 默认值为'${appName}-${buildType}-${channel}.apk'
可使用以下变量:

     projectName - 项目名字
     appName - App模块名字
     packageName - applicationId (App包名packageName)
     buildType - buildType (release/debug等)
     channel - channel名称 (对应渠道打包中的渠道名字)
     versionName - versionName (显示用的版本号)
     versionCode - versionCode (内部版本号)
     buildTime - buildTime (编译构建日期时间)
     fileSHA1 - fileSHA1 (最终APK文件的SHA1哈希值)
     flavorName - 编译构建 productFlavors 名
channelFile：包含渠道配置信息的文件路径。 具体内容格式详见：渠道配置文件示例，支持使用#号添加注释。

如何获取渠道信息

在需要渠道等信息时可以通过下面代码进行获取

String channel = WalleChannelReader.getChannel(this.getApplicationContext());
如何生成渠道包

生成渠道包的方式是和assemble${variantName}Channels指令结合，渠道包的生成目录默认存放在 build/outputs/apk/，也可以通过walle闭包中的apkOutputFolder参数来指定输出目录

用法示例：

生成渠道包 ./gradlew clean assembleReleaseChannels
支持 productFlavors ./gradlew clean assembleMeituanReleaseChannels</code></pre>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;"><br></p>
  <pre><code class="language-java">临时生成某渠道包

我们推荐使用channelFile/configFile配置来生成渠道包，但有时也可能有临时生成渠道包需求，这时可以使用：

生成单个渠道包: ./gradlew clean assembleReleaseChannels -PchannelList=meituan

生成多个渠道包: ./gradlew clean assembleReleaseChannels -PchannelList=meituan,dianping</code></pre>
  <br>
  <br>基于360加固后签名失效的解决方案：
  <a href="https://github.com/Jay-Goo/ProtectedApkResignerForWalle" rel="nofollow">https://github.com/Jay-Goo/ProtectedApkResignerForWalle</a>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">其中的配置</p>
  <p style="color:rgb(102,102,102);font-size:1.16em;font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;"><img src="" alt=""><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180330231434144" alt=""><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u011733020/article/details/79764516,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/u011733020/article/details/79764516,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
