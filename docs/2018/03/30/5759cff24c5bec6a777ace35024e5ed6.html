<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>(二) 区块链数据结构-区块 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="(二) 区块链数据结构-区块" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文版权归袋马学院所有，转载请注明出处 https://blog.csdn.net/maerdym/article/details/79753490 区块是区块链的核心单元。区块链由区块互相连接而成。 区块 区块由区块头和区块体两部分组成。其中区块的大小被限制在1M以内(为了防止资源浪费和DOS攻击)，区块头的大小被固定为80个字节。 但目前随机比特币的发展，交易数量持续增加，1M的大小能存储的交易数量有限，导致大量的交易积压。因此目前正在考虑扩容方案。 区块头 区块头中记录了版本号、上一个区块的Hash地址、merkle根、区块创建时间戳、区块的工作量难度目标以及用于计算目标的参数值。 字段 大小 描述 version 4字节 版本号，⽤于跟踪软件/协议的更新 prevBlockHash 32字节 上一个区块的Hash地址 merkleRoot 32字节 该区块中交易的merkl e树根的哈希值（稍后详细说明） time 4字节 该区块的创建时间戳 difficultyTarget 4字节 该区块链工作量证明难度目标(稍后讲解工作量证明) nonce 4字节 用于证明工作量的计算参数 区块体 区块体中记录了该区块存储的交易数量以及交易数据。 字段 大小 描述 numTransactionsBytes 1字节 交易数量占用的字节数 numTransactions 0-8个字节 区块内存储的交易数量 transactions 不确定 区块内存的多个交易数据 为了节约区块的存储空间，区块内的交易数量字段采用了压缩存储。在读取交易数量之前，会先读取numTransactionsBytes字段值。- 如果该值小于253，则用直接将该值作为交易数量- 如果该值等于253，则读取之后的两个字节作为交易数量- 如果该值等于254，则读取之后的4个字节作为交易数量- 否则，读取之后的8个字节作为交易数量 区块的核心代码 1. 区块中的核心常量定义 /** How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. */ //区块头的大小，当前为80个字节 public static final int HEADER_SIZE = 80; static final long ALLOWED_TIME_DRIFT = 2 * 60 * 60; // Same value as Bitcoin Core. /** * A constant shared by the entire network: how large in bytes a block is allowed to be. One day we may have to * upgrade everyone to change this, so Bitcoin can continue to grow. For now it exists as an anti-DoS measure to * avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever. */ //全网共享的常量，用于表示区块的最大字节数。随着比特币会持续的发展，日后升级网络时可能会变更该数字。 //目前该值作为解决拒接攻击的一种措施，避免有人创建巨量的区块，造成整个网络的资源浪费。 public static final int MAX_BLOCK_SIZE = 1 * 1000 * 1000; /** * A &quot;sigop&quot; is a signature verification operation. Because they&#39;re expensive we also impose a separate limit on * the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very * expensive/slow to verify. */ //sigop是签名校验操作，因此这个操作需要大量的资源，因此需要限制大小，防止资源浪费或降低网络性能 public static final int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50; /** A value for difficultyTarget (nBits) that allows half of all possible hash solutions. Used in unit testing. */ //工作量的难度目标 public static final long EASIEST_DIFFICULTY_TARGET = 0x207fFFFFL; 2. 区块中的核心变量定义 private long version; //区块链的版本号 private Sha256Hash prevBlockHash; //前一个区块的hash地址 private Sha256Hash merkleRoot; //交易标识的merkle根 private long time; //区块创建时间戳 private long difficultyTarget; // &quot;nBits&quot; //区块工作难度目标 private long nonce; //用于证明区块工作量的参数 // TODO: Get rid of all the direct accesses to this field. It&#39;s a long-since unnecessary holdover from the Dalvik days. /** If null, it means this object holds only the headers. */ //区块中存储的交易数据 @Nullable List&lt;Transaction&gt; transactions; /** Stores the hash of the block. If null, getHash() will recalculate it. */ //当前区块的hash地址 private Sha256Hash hash; 3. 解析区块二进制数据 //从原始字节数据中构造区块对象 @Override protected void parse() throws ProtocolException { // header cursor = offset; version = readUint32(); //读取4个字节的版本号 prevBlockHash = readHash(); //读取前一个区块的hash地址 merkleRoot = readHash(); //读取merkle交易树的根值 time = readUint32(); //读取区块的创建时间戳 difficultyTarget = readUint32(); //读取区块的难度目标 nonce = readUint32(); //读取区块用于计算难度的随机数 //通过区块头计算当前区块的hash地址 hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(payload, offset, cursor - offset)); headerBytesValid = serializer.isParseRetainMode(); //是否缓存区块的hash地址 // transactions //解析区块内的交易数据 parseTransactions(offset + HEADER_SIZE); //计算区块的字节数 length = cursor - offset; } 4. 解析区块内的交易数据 //解析区块内的交易数据 protected void parseTransactions(final int transactionsOffset) throws ProtocolException { cursor = transactionsOffset; //设置读取数据的起始偏移地址 optimalEncodingMessageSize = HEADER_SIZE; //初始化编码后的区块大小 if (payload.length == cursor) { // This message is just a header, it has no transactions. transactionBytesValid = false; return; } int numTransactions = (int) readVarInt(); //获取区块内的交易数据量 //累加编码后的区块大小，不同的整数经过编码后，占用的存储空间不一样，因此需要通过VarInt进行计算 optimalEncodingMessageSize += VarInt.sizeOf(numTransactions); transactions = new ArrayList&lt;&gt;(numTransactions); //逐一构造区块内的交易数据 for (int i = 0; i &lt; numTransactions; i++) { //构造区块内的交易数据 Transaction tx = new Transaction(params, payload, cursor, this, serializer, UNKNOWN_LENGTH); // Label the transaction as coming from the P2P network, so code that cares where we first saw it knows. tx.getConfidence().setSource(TransactionConfidence.Source.NETWORK); transactions.add(tx); cursor += tx.getMessageSize(); optimalEncodingMessageSize += tx.getOptimalEncodingMessageSize(); } transactionBytesValid = serializer.isParseRetainMode(); } 上一篇：(一) 区块链数据结构-区块链 下一篇：(三) 区块链数据结构 – 交易 阅读更多" />
<meta property="og:description" content="版权声明：本文版权归袋马学院所有，转载请注明出处 https://blog.csdn.net/maerdym/article/details/79753490 区块是区块链的核心单元。区块链由区块互相连接而成。 区块 区块由区块头和区块体两部分组成。其中区块的大小被限制在1M以内(为了防止资源浪费和DOS攻击)，区块头的大小被固定为80个字节。 但目前随机比特币的发展，交易数量持续增加，1M的大小能存储的交易数量有限，导致大量的交易积压。因此目前正在考虑扩容方案。 区块头 区块头中记录了版本号、上一个区块的Hash地址、merkle根、区块创建时间戳、区块的工作量难度目标以及用于计算目标的参数值。 字段 大小 描述 version 4字节 版本号，⽤于跟踪软件/协议的更新 prevBlockHash 32字节 上一个区块的Hash地址 merkleRoot 32字节 该区块中交易的merkl e树根的哈希值（稍后详细说明） time 4字节 该区块的创建时间戳 difficultyTarget 4字节 该区块链工作量证明难度目标(稍后讲解工作量证明) nonce 4字节 用于证明工作量的计算参数 区块体 区块体中记录了该区块存储的交易数量以及交易数据。 字段 大小 描述 numTransactionsBytes 1字节 交易数量占用的字节数 numTransactions 0-8个字节 区块内存储的交易数量 transactions 不确定 区块内存的多个交易数据 为了节约区块的存储空间，区块内的交易数量字段采用了压缩存储。在读取交易数量之前，会先读取numTransactionsBytes字段值。- 如果该值小于253，则用直接将该值作为交易数量- 如果该值等于253，则读取之后的两个字节作为交易数量- 如果该值等于254，则读取之后的4个字节作为交易数量- 否则，读取之后的8个字节作为交易数量 区块的核心代码 1. 区块中的核心常量定义 /** How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. */ //区块头的大小，当前为80个字节 public static final int HEADER_SIZE = 80; static final long ALLOWED_TIME_DRIFT = 2 * 60 * 60; // Same value as Bitcoin Core. /** * A constant shared by the entire network: how large in bytes a block is allowed to be. One day we may have to * upgrade everyone to change this, so Bitcoin can continue to grow. For now it exists as an anti-DoS measure to * avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever. */ //全网共享的常量，用于表示区块的最大字节数。随着比特币会持续的发展，日后升级网络时可能会变更该数字。 //目前该值作为解决拒接攻击的一种措施，避免有人创建巨量的区块，造成整个网络的资源浪费。 public static final int MAX_BLOCK_SIZE = 1 * 1000 * 1000; /** * A &quot;sigop&quot; is a signature verification operation. Because they&#39;re expensive we also impose a separate limit on * the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very * expensive/slow to verify. */ //sigop是签名校验操作，因此这个操作需要大量的资源，因此需要限制大小，防止资源浪费或降低网络性能 public static final int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50; /** A value for difficultyTarget (nBits) that allows half of all possible hash solutions. Used in unit testing. */ //工作量的难度目标 public static final long EASIEST_DIFFICULTY_TARGET = 0x207fFFFFL; 2. 区块中的核心变量定义 private long version; //区块链的版本号 private Sha256Hash prevBlockHash; //前一个区块的hash地址 private Sha256Hash merkleRoot; //交易标识的merkle根 private long time; //区块创建时间戳 private long difficultyTarget; // &quot;nBits&quot; //区块工作难度目标 private long nonce; //用于证明区块工作量的参数 // TODO: Get rid of all the direct accesses to this field. It&#39;s a long-since unnecessary holdover from the Dalvik days. /** If null, it means this object holds only the headers. */ //区块中存储的交易数据 @Nullable List&lt;Transaction&gt; transactions; /** Stores the hash of the block. If null, getHash() will recalculate it. */ //当前区块的hash地址 private Sha256Hash hash; 3. 解析区块二进制数据 //从原始字节数据中构造区块对象 @Override protected void parse() throws ProtocolException { // header cursor = offset; version = readUint32(); //读取4个字节的版本号 prevBlockHash = readHash(); //读取前一个区块的hash地址 merkleRoot = readHash(); //读取merkle交易树的根值 time = readUint32(); //读取区块的创建时间戳 difficultyTarget = readUint32(); //读取区块的难度目标 nonce = readUint32(); //读取区块用于计算难度的随机数 //通过区块头计算当前区块的hash地址 hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(payload, offset, cursor - offset)); headerBytesValid = serializer.isParseRetainMode(); //是否缓存区块的hash地址 // transactions //解析区块内的交易数据 parseTransactions(offset + HEADER_SIZE); //计算区块的字节数 length = cursor - offset; } 4. 解析区块内的交易数据 //解析区块内的交易数据 protected void parseTransactions(final int transactionsOffset) throws ProtocolException { cursor = transactionsOffset; //设置读取数据的起始偏移地址 optimalEncodingMessageSize = HEADER_SIZE; //初始化编码后的区块大小 if (payload.length == cursor) { // This message is just a header, it has no transactions. transactionBytesValid = false; return; } int numTransactions = (int) readVarInt(); //获取区块内的交易数据量 //累加编码后的区块大小，不同的整数经过编码后，占用的存储空间不一样，因此需要通过VarInt进行计算 optimalEncodingMessageSize += VarInt.sizeOf(numTransactions); transactions = new ArrayList&lt;&gt;(numTransactions); //逐一构造区块内的交易数据 for (int i = 0; i &lt; numTransactions; i++) { //构造区块内的交易数据 Transaction tx = new Transaction(params, payload, cursor, this, serializer, UNKNOWN_LENGTH); // Label the transaction as coming from the P2P network, so code that cares where we first saw it knows. tx.getConfidence().setSource(TransactionConfidence.Source.NETWORK); transactions.add(tx); cursor += tx.getMessageSize(); optimalEncodingMessageSize += tx.getOptimalEncodingMessageSize(); } transactionBytesValid = serializer.isParseRetainMode(); } 上一篇：(一) 区块链数据结构-区块链 下一篇：(三) 区块链数据结构 – 交易 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/03/30/5759cff24c5bec6a777ace35024e5ed6.html" />
<meta property="og:url" content="https://mlh.app/2018/03/30/5759cff24c5bec6a777ace35024e5ed6.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-30T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文版权归袋马学院所有，转载请注明出处 https://blog.csdn.net/maerdym/article/details/79753490 区块是区块链的核心单元。区块链由区块互相连接而成。 区块 区块由区块头和区块体两部分组成。其中区块的大小被限制在1M以内(为了防止资源浪费和DOS攻击)，区块头的大小被固定为80个字节。 但目前随机比特币的发展，交易数量持续增加，1M的大小能存储的交易数量有限，导致大量的交易积压。因此目前正在考虑扩容方案。 区块头 区块头中记录了版本号、上一个区块的Hash地址、merkle根、区块创建时间戳、区块的工作量难度目标以及用于计算目标的参数值。 字段 大小 描述 version 4字节 版本号，⽤于跟踪软件/协议的更新 prevBlockHash 32字节 上一个区块的Hash地址 merkleRoot 32字节 该区块中交易的merkl e树根的哈希值（稍后详细说明） time 4字节 该区块的创建时间戳 difficultyTarget 4字节 该区块链工作量证明难度目标(稍后讲解工作量证明) nonce 4字节 用于证明工作量的计算参数 区块体 区块体中记录了该区块存储的交易数量以及交易数据。 字段 大小 描述 numTransactionsBytes 1字节 交易数量占用的字节数 numTransactions 0-8个字节 区块内存储的交易数量 transactions 不确定 区块内存的多个交易数据 为了节约区块的存储空间，区块内的交易数量字段采用了压缩存储。在读取交易数量之前，会先读取numTransactionsBytes字段值。- 如果该值小于253，则用直接将该值作为交易数量- 如果该值等于253，则读取之后的两个字节作为交易数量- 如果该值等于254，则读取之后的4个字节作为交易数量- 否则，读取之后的8个字节作为交易数量 区块的核心代码 1. 区块中的核心常量定义 /** How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. */ //区块头的大小，当前为80个字节 public static final int HEADER_SIZE = 80; static final long ALLOWED_TIME_DRIFT = 2 * 60 * 60; // Same value as Bitcoin Core. /** * A constant shared by the entire network: how large in bytes a block is allowed to be. One day we may have to * upgrade everyone to change this, so Bitcoin can continue to grow. For now it exists as an anti-DoS measure to * avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever. */ //全网共享的常量，用于表示区块的最大字节数。随着比特币会持续的发展，日后升级网络时可能会变更该数字。 //目前该值作为解决拒接攻击的一种措施，避免有人创建巨量的区块，造成整个网络的资源浪费。 public static final int MAX_BLOCK_SIZE = 1 * 1000 * 1000; /** * A &quot;sigop&quot; is a signature verification operation. Because they&#39;re expensive we also impose a separate limit on * the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very * expensive/slow to verify. */ //sigop是签名校验操作，因此这个操作需要大量的资源，因此需要限制大小，防止资源浪费或降低网络性能 public static final int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50; /** A value for difficultyTarget (nBits) that allows half of all possible hash solutions. Used in unit testing. */ //工作量的难度目标 public static final long EASIEST_DIFFICULTY_TARGET = 0x207fFFFFL; 2. 区块中的核心变量定义 private long version; //区块链的版本号 private Sha256Hash prevBlockHash; //前一个区块的hash地址 private Sha256Hash merkleRoot; //交易标识的merkle根 private long time; //区块创建时间戳 private long difficultyTarget; // &quot;nBits&quot; //区块工作难度目标 private long nonce; //用于证明区块工作量的参数 // TODO: Get rid of all the direct accesses to this field. It&#39;s a long-since unnecessary holdover from the Dalvik days. /** If null, it means this object holds only the headers. */ //区块中存储的交易数据 @Nullable List&lt;Transaction&gt; transactions; /** Stores the hash of the block. If null, getHash() will recalculate it. */ //当前区块的hash地址 private Sha256Hash hash; 3. 解析区块二进制数据 //从原始字节数据中构造区块对象 @Override protected void parse() throws ProtocolException { // header cursor = offset; version = readUint32(); //读取4个字节的版本号 prevBlockHash = readHash(); //读取前一个区块的hash地址 merkleRoot = readHash(); //读取merkle交易树的根值 time = readUint32(); //读取区块的创建时间戳 difficultyTarget = readUint32(); //读取区块的难度目标 nonce = readUint32(); //读取区块用于计算难度的随机数 //通过区块头计算当前区块的hash地址 hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(payload, offset, cursor - offset)); headerBytesValid = serializer.isParseRetainMode(); //是否缓存区块的hash地址 // transactions //解析区块内的交易数据 parseTransactions(offset + HEADER_SIZE); //计算区块的字节数 length = cursor - offset; } 4. 解析区块内的交易数据 //解析区块内的交易数据 protected void parseTransactions(final int transactionsOffset) throws ProtocolException { cursor = transactionsOffset; //设置读取数据的起始偏移地址 optimalEncodingMessageSize = HEADER_SIZE; //初始化编码后的区块大小 if (payload.length == cursor) { // This message is just a header, it has no transactions. transactionBytesValid = false; return; } int numTransactions = (int) readVarInt(); //获取区块内的交易数据量 //累加编码后的区块大小，不同的整数经过编码后，占用的存储空间不一样，因此需要通过VarInt进行计算 optimalEncodingMessageSize += VarInt.sizeOf(numTransactions); transactions = new ArrayList&lt;&gt;(numTransactions); //逐一构造区块内的交易数据 for (int i = 0; i &lt; numTransactions; i++) { //构造区块内的交易数据 Transaction tx = new Transaction(params, payload, cursor, this, serializer, UNKNOWN_LENGTH); // Label the transaction as coming from the P2P network, so code that cares where we first saw it knows. tx.getConfidence().setSource(TransactionConfidence.Source.NETWORK); transactions.add(tx); cursor += tx.getMessageSize(); optimalEncodingMessageSize += tx.getOptimalEncodingMessageSize(); } transactionBytesValid = serializer.isParseRetainMode(); } 上一篇：(一) 区块链数据结构-区块链 下一篇：(三) 区块链数据结构 – 交易 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/03/30/5759cff24c5bec6a777ace35024e5ed6.html","headline":"(二) 区块链数据结构-区块","dateModified":"2018-03-30T00:00:00+08:00","datePublished":"2018-03-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/03/30/5759cff24c5bec6a777ace35024e5ed6.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>(二) 区块链数据结构-区块</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文版权归袋马学院所有，转载请注明出处 https://blog.csdn.net/maerdym/article/details/79753490 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;vertical-align:baseline;color:rgb(51,51,51);background-color:rgb(255,255,255);">区块是区块链的核心单元。区块链由区块互相连接而成。</p>
  <hr style="border-top:0px solid rgb(204,204,204);border-right:0px solid rgb(204,204,204);border-left:0px solid rgb(204,204,204);border-bottom-color:rgb(204,204,204);background-color:rgb(239,239,239);color:rgb(51,51,51);font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;">
  <h3 style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;font-size:24px;vertical-align:baseline;clear:both;line-height:1;color:rgb(51,51,51);background-color:rgb(255,255,255);">区块</h3>
  <p style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;vertical-align:baseline;color:rgb(51,51,51);background-color:rgb(255,255,255);">区块由区块头和区块体两部分组成。其中区块的大小被限制在1M以内(为了防止资源浪费和DOS攻击)，区块头的大小被固定为80个字节。</p>
  <p style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;vertical-align:baseline;color:rgb(51,51,51);background-color:rgb(255,255,255);"><img src="http://www.insideai.cn/wp-content/uploads/2018/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8C%BA%E5%9D%97%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.gif" alt="区块链数据结构-区块存储格式" title="区块链数据结构-区块存储格式"></p>
  <p style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;vertical-align:baseline;color:rgb(51,51,51);background-color:rgb(255,255,255);"><span style="border:0px;font-family:inherit;font-weight:inherit;vertical-align:baseline;">但目前随机比特币的发展，交易数量持续增加，1M的大小能存储的交易数量有限，导致大量的交易积压。因此目前正在考虑扩容方案。</span></p>
  <hr style="border-top:0px solid rgb(204,204,204);border-right:0px solid rgb(204,204,204);border-left:0px solid rgb(204,204,204);border-bottom-color:rgb(204,204,204);background-color:rgb(239,239,239);color:rgb(51,51,51);font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;">
  <h3 style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;font-size:24px;vertical-align:baseline;clear:both;line-height:1;color:rgb(51,51,51);background-color:rgb(255,255,255);">区块头</h3>
  <p style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;vertical-align:baseline;color:rgb(51,51,51);background-color:rgb(255,255,255);">区块头中记录了版本号、上一个区块的Hash地址、merkle根、区块创建时间戳、区块的工作量难度目标以及用于计算目标的参数值。</p>
  <table style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;font-size:16px;vertical-align:baseline;border-collapse:separate;border-spacing:0px;width:650px;color:rgb(51,51,51);background-color:rgb(255,255,255);">
   <thead style="border:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
    <tr style="border-top:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
     <th style="border-width:0px 0px 4px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">字段</th>
     <th style="border-width:0px 0px 4px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">大小</th>
     <th style="border-width:0px 0px 4px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">描述</th>
    </tr>
   </thead>
   <tbody style="font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
    <tr style="border-top:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">version</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">4字节</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">版本号，⽤于跟踪软件/协议的更新</td>
    </tr>
    <tr style="border-top:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">prevBlockHash</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">32字节</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">上一个区块的Hash地址</td>
    </tr>
    <tr style="border-top:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">merkleRoot</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">32字节</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">该区块中交易的merkl e树根的哈希值（稍后详细说明）</td>
    </tr>
    <tr style="border-top:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">time</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">4字节</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">该区块的创建时间戳</td>
    </tr>
    <tr style="border-top:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">difficultyTarget</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">4字节</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">该区块链工作量证明难度目标(稍后讲解工作量证明)</td>
    </tr>
    <tr style="border-top:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">nonce</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">4字节</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">用于证明工作量的计算参数</td>
    </tr>
   </tbody>
  </table>
  <hr style="border-top:0px solid rgb(204,204,204);border-right:0px solid rgb(204,204,204);border-left:0px solid rgb(204,204,204);border-bottom-color:rgb(204,204,204);background-color:rgb(239,239,239);color:rgb(51,51,51);font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;">
  <h3 style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;font-size:24px;vertical-align:baseline;clear:both;line-height:1;color:rgb(51,51,51);background-color:rgb(255,255,255);">区块体</h3>
  <p style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;vertical-align:baseline;color:rgb(51,51,51);background-color:rgb(255,255,255);">区块体中记录了该区块存储的交易数量以及交易数据。</p>
  <table style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;font-size:16px;vertical-align:baseline;border-collapse:separate;border-spacing:0px;width:650px;color:rgb(51,51,51);background-color:rgb(255,255,255);">
   <thead style="border:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
    <tr style="border-top:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
     <th style="border-width:0px 0px 4px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">字段</th>
     <th style="border-width:0px 0px 4px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">大小</th>
     <th style="border-width:0px 0px 4px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">描述</th>
    </tr>
   </thead>
   <tbody style="font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
    <tr style="border-top:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">numTransactionsBytes</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">1字节</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">交易数量占用的字节数</td>
    </tr>
    <tr style="border-top:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">numTransactions</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">0-8个字节</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">区块内存储的交易数量</td>
    </tr>
    <tr style="border-top:0px;font-family:inherit;font-style:inherit;font-weight:inherit;vertical-align:baseline;">
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">transactions</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">不确定</td>
     <td style="border-top:0px;border-right:0px;border-left:0px;border-bottom-color:rgb(239,239,239);font-family:inherit;font-size:16px;font-style:inherit;vertical-align:baseline;border-collapse:collapse;">区块内存的多个交易数据</td>
    </tr>
   </tbody>
  </table>
  <p style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;vertical-align:baseline;color:rgb(51,51,51);background-color:rgb(255,255,255);">为了节约区块的存储空间，区块内的交易数量字段采用了压缩存储。在读取交易数量之前，会先读取numTransactionsBytes字段值。<br>- 如果该值小于253，则用直接将该值作为交易数量<br>- 如果该值等于253，则读取之后的两个字节作为交易数量<br>- 如果该值等于254，则读取之后的4个字节作为交易数量<br>- 否则，读取之后的8个字节作为交易数量</p>
  <hr style="border-top:0px solid rgb(204,204,204);border-right:0px solid rgb(204,204,204);border-left:0px solid rgb(204,204,204);border-bottom-color:rgb(204,204,204);background-color:rgb(239,239,239);color:rgb(51,51,51);font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;">
  <h3 style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;font-size:24px;vertical-align:baseline;clear:both;line-height:1;color:rgb(51,51,51);background-color:rgb(255,255,255);">区块的核心代码</h3>
  <h4 style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;font-size:16px;vertical-align:baseline;clear:both;line-height:1;color:rgb(51,51,51);background-color:rgb(255,255,255);">1. 区块中的核心常量定义</h4>
  <pre class="line-numbers prism-highlight" style="border:0px;font-family:'Courier 10 Pitch', Courier, monospace;font-size:.8125em;vertical-align:baseline;background:rgba(0,0,0,.03);line-height:1.96923em;color:rgb(51,51,51);"><code class="language-java" style="border:0px;font-family:Monaco, Consolas, 'Andale Mono', 'DejaVu Sans Mono', monospace;font-size:.8125em;vertical-align:baseline;line-height:1.96923em;">    /** How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. */
    //区块头的大小，当前为80个字节
    public static final int HEADER_SIZE = 80;   

    static final long ALLOWED_TIME_DRIFT = 2 * 60 * 60; // Same value as Bitcoin Core.

    /**
     * A constant shared by the entire network: how large in bytes a block is allowed to be. One day we may have to
     * upgrade everyone to change this, so Bitcoin can continue to grow. For now it exists as an anti-DoS measure to
     * avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever.
     */
    //全网共享的常量，用于表示区块的最大字节数。随着比特币会持续的发展，日后升级网络时可能会变更该数字。
    //目前该值作为解决拒接攻击的一种措施，避免有人创建巨量的区块，造成整个网络的资源浪费。
    public static final int MAX_BLOCK_SIZE = 1 * 1000 * 1000;
    /**
     * A "sigop" is a signature verification operation. Because they're expensive we also impose a separate limit on
     * the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very
     * expensive/slow to verify.
     */
    //sigop是签名校验操作，因此这个操作需要大量的资源，因此需要限制大小，防止资源浪费或降低网络性能
    public static final int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50;

    /** A value for difficultyTarget (nBits) that allows half of all possible hash solutions. Used in unit testing. */
    //工作量的难度目标
    public static final long EASIEST_DIFFICULTY_TARGET = 0x207fFFFFL;
</code></pre>
  <h4 style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;font-size:16px;vertical-align:baseline;clear:both;line-height:1;color:rgb(51,51,51);background-color:rgb(255,255,255);">2. 区块中的核心变量定义</h4>
  <pre class="line-numbers prism-highlight" style="border:0px;font-family:'Courier 10 Pitch', Courier, monospace;font-size:.8125em;vertical-align:baseline;background:rgba(0,0,0,.03);line-height:1.96923em;color:rgb(51,51,51);"><code class="language-java" style="border:0px;font-family:Monaco, Consolas, 'Andale Mono', 'DejaVu Sans Mono', monospace;font-size:.8125em;vertical-align:baseline;line-height:1.96923em;">    private long version;               //区块链的版本号
    private Sha256Hash prevBlockHash;   //前一个区块的hash地址
    private Sha256Hash merkleRoot;      //交易标识的merkle根
    private long time;                  //区块创建时间戳
    private long difficultyTarget; // "nBits"   //区块工作难度目标
    private long nonce;                 //用于证明区块工作量的参数

    // TODO: Get rid of all the direct accesses to this field. It's a long-since unnecessary holdover from the Dalvik days.
    /** If null, it means this object holds only the headers. */
    //区块中存储的交易数据
    @Nullable List&lt;Transaction&gt; transactions;

    /** Stores the hash of the block. If null, getHash() will recalculate it. */
    //当前区块的hash地址
    private Sha256Hash hash;
</code></pre>
  <h4 style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;font-size:16px;vertical-align:baseline;clear:both;line-height:1;color:rgb(51,51,51);background-color:rgb(255,255,255);">3. 解析区块二进制数据</h4>
  <pre class="line-numbers prism-highlight" style="border:0px;font-family:'Courier 10 Pitch', Courier, monospace;font-size:.8125em;vertical-align:baseline;background:rgba(0,0,0,.03);line-height:1.96923em;color:rgb(51,51,51);"><code class="language-java" style="border:0px;font-family:Monaco, Consolas, 'Andale Mono', 'DejaVu Sans Mono', monospace;font-size:.8125em;vertical-align:baseline;line-height:1.96923em;">    //从原始字节数据中构造区块对象
    @Override
    protected void parse() throws ProtocolException {
        // header
        cursor = offset;            
        version = readUint32();     //读取4个字节的版本号
        prevBlockHash = readHash(); //读取前一个区块的hash地址
        merkleRoot = readHash();    //读取merkle交易树的根值
        time = readUint32();        //读取区块的创建时间戳
        difficultyTarget = readUint32();    //读取区块的难度目标
        nonce = readUint32();               //读取区块用于计算难度的随机数
        //通过区块头计算当前区块的hash地址
        hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(payload, offset, cursor - offset));
        headerBytesValid = serializer.isParseRetainMode();  //是否缓存区块的hash地址

        // transactions
        //解析区块内的交易数据
        parseTransactions(offset + HEADER_SIZE);

        //计算区块的字节数
        length = cursor - offset;
    }
</code></pre>
  <h4 style="border:0px;font-family:'Source Sans Pro', Helvetica, Arial, sans-serif;font-size:16px;vertical-align:baseline;clear:both;line-height:1;color:rgb(51,51,51);background-color:rgb(255,255,255);">4. 解析区块内的交易数据</h4>
  <pre class="line-numbers prism-highlight" style="border:0px;font-family:'Courier 10 Pitch', Courier, monospace;font-size:.8125em;vertical-align:baseline;background:rgba(0,0,0,.03);line-height:1.96923em;color:rgb(51,51,51);"><code class="language-java" style="border:0px;font-family:Monaco, Consolas, 'Andale Mono', 'DejaVu Sans Mono', monospace;font-size:.8125em;vertical-align:baseline;line-height:1.96923em;">    //解析区块内的交易数据
    protected void parseTransactions(final int transactionsOffset) throws ProtocolException {
        cursor = transactionsOffset;            //设置读取数据的起始偏移地址

        optimalEncodingMessageSize = HEADER_SIZE;   //初始化编码后的区块大小
        if (payload.length == cursor) {
            // This message is just a header, it has no transactions.
            transactionBytesValid = false;
            return;
        }

        int numTransactions = (int) readVarInt();   //获取区块内的交易数据量

        //累加编码后的区块大小，不同的整数经过编码后，占用的存储空间不一样，因此需要通过VarInt进行计算
        optimalEncodingMessageSize += VarInt.sizeOf(numTransactions);

        transactions = new ArrayList&lt;&gt;(numTransactions);

        //逐一构造区块内的交易数据
        for (int i = 0; i &lt; numTransactions; i++) {
            //构造区块内的交易数据
            Transaction tx = new Transaction(params, payload, cursor, this, serializer, UNKNOWN_LENGTH);
            // Label the transaction as coming from the P2P network, so code that cares where we first saw it knows.
            tx.getConfidence().setSource(TransactionConfidence.Source.NETWORK);
            transactions.add(tx);
            cursor += tx.getMessageSize();
            optimalEncodingMessageSize += tx.getOptimalEncodingMessageSize();
        }
        transactionBytesValid = serializer.isParseRetainMode();
    }</code></pre>
  <p>上一篇：<a href="http://www.insideai.cn/%E6%A0%B7%E6%9C%AC/" rel="nofollow">(一) 区块链数据结构-区块链</a></p>
  <p>下一篇：<a href="http://www.insideai.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%A4%E6%98%93/" rel="nofollow">(三) 区块链数据结构 – 交易</a></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/maerdym/article/details/79753490,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/maerdym/article/details/79753490,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
