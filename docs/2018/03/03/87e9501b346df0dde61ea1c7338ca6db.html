<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>干货 分分钟教你用Python创建一个区块链 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="干货 分分钟教你用Python创建一个区块链" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="源码：https://github.com/xilibi2003/blockchain 对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。 但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可以加深对区块链的理解。 准备工作 本文要求读者对Python有基本的理解，能读写基本的Python，并且需要对HTTP请求有基本的了解。 我们知道区块链是由区块的记录构成的不可变、有序的链结构，记录可以是交易、文件或任何你想要的数据，重要的是它们是通过哈希值（hashes）链接起来的。 环境准备 环境准备，确保已经安装Python3.6+, pip , Flask, requests安装方法： 1 pip install Flask==0.12.2 requests==2.18.4 同时还需要一个HTTP客户端，比如Postman，cURL或其它客户端。 参考源代码（原代码在我翻译的时候，无法运行，我fork了一份，修复了其中的错误，并添加了翻译，感谢star） 开始创建Blockchain 新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中，可以随时参考源代码 Blockchain类 首先创建一个Blockchain类，在构造函数中创建了两个列表，一个用于储存区块链，一个用于储存交易。 以下是Blockchain类的框架： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass Blockchain类用来管理链条，它能存储交易，加入新块等，下面我们来进一步完善这些方法。 块结构 每个区块包含属性：索引（index），Unix时间戳（timestamp），交易列表（transactions），工作量证明（稍后解释）以及前一个区块的Hash值。 以下是一个区块的结构： 1 2 3 4 5 6 7 8 9 10 11 12 13 block = { &#39;index&#39;: 1, &#39;timestamp&#39;: 1506057125.900785, &#39;transactions&#39;: [ { &#39;sender&#39;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;, &#39;recipient&#39;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;, &#39;amount&#39;: 5, } ], &#39;proof&#39;: 324984774000, &#39;previous_hash&#39;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot; } 到这里，区块链的概念就清楚了，每个新的区块都包含上一个区块的Hash，这是关键的一点，它保障了区块链不可变性。如果攻击者破坏了前面的某个区块，那么后面所有区块的Hash都会变得不正确。不理解的话，慢慢消化，可参考区块链记账原理 加入交易 接下来我们需要添加一个交易，来完善下new_transaction方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 方法向列表中添加一个交易记录，并返回该记录将被添加到的区块(下一个待挖掘的区块)的索引，等下在用户提交交易时会有用。 创建新块 当Blockchain实例化后，我们需要构造一个创世块（没有前区块的第一个区块），并且给它加上一个工作量证明。 每个区块都需要经过工作量证明，俗称挖矿，稍后会继续讲解。 为了构造创世块，我们还需要完善new_block(), new_transaction() 和hash() 方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import hashlib import json from time import time class Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; 生成新块 :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; 生成块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; &quot;&quot;&quot; # We must make sure that the Dictionary is Ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 通过上面的代码和注释可以对区块链有直观的了解，接下来我们看看区块是怎么挖出来的。 理解工作量证明 新的区块依赖工作量证明算法（PoW）来构造。PoW的目标是找出一个符合特定条件的数字，这个数字很难计算出来，但容易验证。这就是工作量证明的核心思想。 为了方便理解，举个例子： 假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc…0。设变量 x = 5，求 y 的值？ 用Python实现如下： 1 2 3 4 5 6 from hashlib import sha256 x = 5 y = 0 # y未知 while sha256(f&#39;{x*y}&#39;.encode()).hexdigest()[-1] != &quot;0&quot;: y += 1 print(f&#39;The solution is y = {y}&#39;) 结果是y=21. 因为： 1 hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，使用称为Hashcash的工作量证明算法，它和上面的问题很类似。矿工们为了争夺创建区块的权利而争相计算结果。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，会获得比特币奖励。当然，在网络上非常容易验证这个结果。 实现工作量证明 让我们来实现一个相似PoW算法，规则是：寻找一个数 p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import hashlib import json from time import time from uuid import uuid4 class Blockchain(object): ... def proof_of_work(self, last_proof): &quot;&quot;&quot; 简单的工作量证明: - 查找一个 p&#39; 使得 hash(pp&#39;) 以4个0开头 - p 是上一个块的证明, p&#39; 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; 验证证明: 是否hash(last_proof, proof)以4个0开头? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. &quot;&quot;&quot; guess = f&#39;{last_proof}{proof}&#39;.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; 衡量算法复杂度的办法是修改零开头的个数。使用4个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。 现在Blockchain类基本已经完成了，接下来使用HTTP requests来进行交互。 Blockchain作为API接口 我们将使用Python Flask框架，这是一个轻量Web应用框架，它方便将网络请求映射到 Python函数，现在我们来让Blockchain运行在基于Flask web上。 我们将创建三个接口： /transactions/new 创建一个交易并添加到区块 /mine 告诉服务器去挖掘新的区块 /chain 返回整个区块链 创建节点 我们的“Flask服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask class Blockchain(object): ... # Instantiate our Node app = Flask(__name__) # Generate a globally unique address for this node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # Instantiate the Blockchain blockchain = Blockchain() @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): return &quot;We&#39;ll mine a new Block&quot; @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): return &quot;We&#39;ll add a new transaction&quot; @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 简单的说明一下以上代码： 第15行: 创建一个节点。第18行: 为节点创建一个随机的名字。第21行: 实例Blockchain类。第24–26行: 创建/mine GET接口。第28–30行: 创建/transactions/new POST接口,可以给接口发送交易数据。第32–38行: 创建 /chain 接口, 返回整个区块链。第40–41行: 服务运行在端口5000上。 发送交易 发送到节点的交易数据结构如下： 1 2 3 4 5 { &quot;sender&quot;: &quot;my address&quot;, &quot;recipient&quot;: &quot;someone else&#39;s address&quot;, &quot;amount&quot;: 5 } 之前已经有添加交易的方法，基于接口来添加交易就很简单了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): values = request.get_json() # Check that the required fields are in the POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: f&#39;Transaction will be added to Block {index}&#39;} return jsonify(response), 201 挖矿 挖矿正是神奇所在，它很简单，做了一下三件事： 计算工作量证明PoW 通过新增一个交易授予矿工（自己）一个币 构造新区块并将其添加到链中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # 给工作量证明的节点提供奖励. # 发送者为 &quot;0&quot; 表明是新挖出的币 blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain block = blockchain.new_block(proof) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕Blockchain类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下 运行区块链 你可以使用cURL 或Postman 去和API进行交互 启动server: 1 2 $ python blockchain.py * Runing on http://127.0.0.1:5000/ (Press CTRL+C to quit) 让我们通过请求 http://localhost:5000/mine 来进行挖矿 通过post请求，添加一个新交易 如果不是使用Postman，则用一下的cURL语句也是一样的： 1 2 3 4 5 $ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{ &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 5 }&#39; &quot;http://localhost:5000/transactions/new&quot; 在挖了两次矿之后，就有3个块了，通过请求 http://localhost:5000/chain 可以得到所有的块信息。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;previous_hash&quot;: 1, &quot;proof&quot;: 100, &quot;timestamp&quot;: 1506280650.770839, &quot;transactions&quot;: [] }, { &quot;index&quot;: 2, &quot;previous_hash&quot;: &quot;c099bc...bfb7&quot;, &quot;proof&quot;: 35293, &quot;timestamp&quot;: 1506280664.717925, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;, &quot;sender&quot;: &quot;0&quot; } ] }, { &quot;index&quot;: 3, &quot;previous_hash&quot;: &quot;eff91a...10f2&quot;, &quot;proof&quot;: 35089, &quot;timestamp&quot;: 1506280666.1086972, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;, &quot;sender&quot;: &quot;0&quot; } ] } ], &quot;length&quot;: 3 } 一致性（共识） 我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法。 注册节点 在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口： /nodes/register 接收URL形式的新节点列表 /nodes/resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链 我们修改下Blockchain的init函数并提供一个注册节点方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... from urllib.parse import urlparse ... class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) 我们用 set 来储存节点，这是一种避免重复添加节点的简单方法。 实现共识算法 前面提到，冲突是指不同的节点拥有不同的链，为了解决这个问题，规定最长的、有效的链才是最终的链，换句话说，网络中有效最长链才是实际的链。 我们使用一下的算法，来达到网络中的共识 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 ... import requests class Blockchain(object) ... def valid_chain(self, chain): &quot;&quot;&quot; Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f&#39;{last_block}&#39;) print(f&#39;{block}&#39;) print(&quot;\n-----------\n&quot;) # Check that the hash of the block is correct if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def resolve_conflicts(self): &quot;&quot;&quot; 共识算法解决冲突 使用网络中最长的链. :return: &lt;bool&gt; True 如果链被取代, 否则为False &quot;&quot;&quot; neighbours = self.nodes new_chain = None # We&#39;re only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f&#39;http://{node}/chain&#39;) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False 第一个方法 valid_chain() 用来检查是否是有效链，遍历每个块验证hash和proof. 第2个方法 resolve_conflicts() 用来解决冲突，遍历所有的邻居节点，并用上一个方法检查链的有效性， 如果发现有效更长链，就替换掉自己的链 让我们添加两个路由，一个用来注册节点，一个用来解决冲突。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 你可以在不同的机器运行节点，或在一台机机开启不同的网络端口来模拟多节点的网络，这里在同一台机器开启不同的端口演示，在不同的终端运行一下命令，就启动了两个节点：http://localhost:5000 和 http://localhost:5001 1 2 pipenv run python blockchain.py pipenv run python blockchain.py -p 5001 然后在节点2上挖两个块，确保是更长的链，然后在节点1上访问接口/nodes/resolve ,这时节点1的链会通过共识算法被节点2的链取代。 好啦，你可以邀请朋友们一起来测试你的区块链 来源：https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/ 源码：https://github.com/xilibi2003/blockchain 作者：FlyAI 链接：https://juejin.im/post/5a98c60cf265da237a4c724b 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 阅读更多" />
<meta property="og:description" content="源码：https://github.com/xilibi2003/blockchain 对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。 但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可以加深对区块链的理解。 准备工作 本文要求读者对Python有基本的理解，能读写基本的Python，并且需要对HTTP请求有基本的了解。 我们知道区块链是由区块的记录构成的不可变、有序的链结构，记录可以是交易、文件或任何你想要的数据，重要的是它们是通过哈希值（hashes）链接起来的。 环境准备 环境准备，确保已经安装Python3.6+, pip , Flask, requests安装方法： 1 pip install Flask==0.12.2 requests==2.18.4 同时还需要一个HTTP客户端，比如Postman，cURL或其它客户端。 参考源代码（原代码在我翻译的时候，无法运行，我fork了一份，修复了其中的错误，并添加了翻译，感谢star） 开始创建Blockchain 新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中，可以随时参考源代码 Blockchain类 首先创建一个Blockchain类，在构造函数中创建了两个列表，一个用于储存区块链，一个用于储存交易。 以下是Blockchain类的框架： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass Blockchain类用来管理链条，它能存储交易，加入新块等，下面我们来进一步完善这些方法。 块结构 每个区块包含属性：索引（index），Unix时间戳（timestamp），交易列表（transactions），工作量证明（稍后解释）以及前一个区块的Hash值。 以下是一个区块的结构： 1 2 3 4 5 6 7 8 9 10 11 12 13 block = { &#39;index&#39;: 1, &#39;timestamp&#39;: 1506057125.900785, &#39;transactions&#39;: [ { &#39;sender&#39;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;, &#39;recipient&#39;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;, &#39;amount&#39;: 5, } ], &#39;proof&#39;: 324984774000, &#39;previous_hash&#39;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot; } 到这里，区块链的概念就清楚了，每个新的区块都包含上一个区块的Hash，这是关键的一点，它保障了区块链不可变性。如果攻击者破坏了前面的某个区块，那么后面所有区块的Hash都会变得不正确。不理解的话，慢慢消化，可参考区块链记账原理 加入交易 接下来我们需要添加一个交易，来完善下new_transaction方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 方法向列表中添加一个交易记录，并返回该记录将被添加到的区块(下一个待挖掘的区块)的索引，等下在用户提交交易时会有用。 创建新块 当Blockchain实例化后，我们需要构造一个创世块（没有前区块的第一个区块），并且给它加上一个工作量证明。 每个区块都需要经过工作量证明，俗称挖矿，稍后会继续讲解。 为了构造创世块，我们还需要完善new_block(), new_transaction() 和hash() 方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import hashlib import json from time import time class Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; 生成新块 :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; 生成块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; &quot;&quot;&quot; # We must make sure that the Dictionary is Ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 通过上面的代码和注释可以对区块链有直观的了解，接下来我们看看区块是怎么挖出来的。 理解工作量证明 新的区块依赖工作量证明算法（PoW）来构造。PoW的目标是找出一个符合特定条件的数字，这个数字很难计算出来，但容易验证。这就是工作量证明的核心思想。 为了方便理解，举个例子： 假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc…0。设变量 x = 5，求 y 的值？ 用Python实现如下： 1 2 3 4 5 6 from hashlib import sha256 x = 5 y = 0 # y未知 while sha256(f&#39;{x*y}&#39;.encode()).hexdigest()[-1] != &quot;0&quot;: y += 1 print(f&#39;The solution is y = {y}&#39;) 结果是y=21. 因为： 1 hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，使用称为Hashcash的工作量证明算法，它和上面的问题很类似。矿工们为了争夺创建区块的权利而争相计算结果。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，会获得比特币奖励。当然，在网络上非常容易验证这个结果。 实现工作量证明 让我们来实现一个相似PoW算法，规则是：寻找一个数 p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import hashlib import json from time import time from uuid import uuid4 class Blockchain(object): ... def proof_of_work(self, last_proof): &quot;&quot;&quot; 简单的工作量证明: - 查找一个 p&#39; 使得 hash(pp&#39;) 以4个0开头 - p 是上一个块的证明, p&#39; 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; 验证证明: 是否hash(last_proof, proof)以4个0开头? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. &quot;&quot;&quot; guess = f&#39;{last_proof}{proof}&#39;.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; 衡量算法复杂度的办法是修改零开头的个数。使用4个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。 现在Blockchain类基本已经完成了，接下来使用HTTP requests来进行交互。 Blockchain作为API接口 我们将使用Python Flask框架，这是一个轻量Web应用框架，它方便将网络请求映射到 Python函数，现在我们来让Blockchain运行在基于Flask web上。 我们将创建三个接口： /transactions/new 创建一个交易并添加到区块 /mine 告诉服务器去挖掘新的区块 /chain 返回整个区块链 创建节点 我们的“Flask服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask class Blockchain(object): ... # Instantiate our Node app = Flask(__name__) # Generate a globally unique address for this node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # Instantiate the Blockchain blockchain = Blockchain() @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): return &quot;We&#39;ll mine a new Block&quot; @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): return &quot;We&#39;ll add a new transaction&quot; @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 简单的说明一下以上代码： 第15行: 创建一个节点。第18行: 为节点创建一个随机的名字。第21行: 实例Blockchain类。第24–26行: 创建/mine GET接口。第28–30行: 创建/transactions/new POST接口,可以给接口发送交易数据。第32–38行: 创建 /chain 接口, 返回整个区块链。第40–41行: 服务运行在端口5000上。 发送交易 发送到节点的交易数据结构如下： 1 2 3 4 5 { &quot;sender&quot;: &quot;my address&quot;, &quot;recipient&quot;: &quot;someone else&#39;s address&quot;, &quot;amount&quot;: 5 } 之前已经有添加交易的方法，基于接口来添加交易就很简单了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): values = request.get_json() # Check that the required fields are in the POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: f&#39;Transaction will be added to Block {index}&#39;} return jsonify(response), 201 挖矿 挖矿正是神奇所在，它很简单，做了一下三件事： 计算工作量证明PoW 通过新增一个交易授予矿工（自己）一个币 构造新区块并将其添加到链中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # 给工作量证明的节点提供奖励. # 发送者为 &quot;0&quot; 表明是新挖出的币 blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain block = blockchain.new_block(proof) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕Blockchain类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下 运行区块链 你可以使用cURL 或Postman 去和API进行交互 启动server: 1 2 $ python blockchain.py * Runing on http://127.0.0.1:5000/ (Press CTRL+C to quit) 让我们通过请求 http://localhost:5000/mine 来进行挖矿 通过post请求，添加一个新交易 如果不是使用Postman，则用一下的cURL语句也是一样的： 1 2 3 4 5 $ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{ &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 5 }&#39; &quot;http://localhost:5000/transactions/new&quot; 在挖了两次矿之后，就有3个块了，通过请求 http://localhost:5000/chain 可以得到所有的块信息。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;previous_hash&quot;: 1, &quot;proof&quot;: 100, &quot;timestamp&quot;: 1506280650.770839, &quot;transactions&quot;: [] }, { &quot;index&quot;: 2, &quot;previous_hash&quot;: &quot;c099bc...bfb7&quot;, &quot;proof&quot;: 35293, &quot;timestamp&quot;: 1506280664.717925, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;, &quot;sender&quot;: &quot;0&quot; } ] }, { &quot;index&quot;: 3, &quot;previous_hash&quot;: &quot;eff91a...10f2&quot;, &quot;proof&quot;: 35089, &quot;timestamp&quot;: 1506280666.1086972, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;, &quot;sender&quot;: &quot;0&quot; } ] } ], &quot;length&quot;: 3 } 一致性（共识） 我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法。 注册节点 在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口： /nodes/register 接收URL形式的新节点列表 /nodes/resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链 我们修改下Blockchain的init函数并提供一个注册节点方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... from urllib.parse import urlparse ... class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) 我们用 set 来储存节点，这是一种避免重复添加节点的简单方法。 实现共识算法 前面提到，冲突是指不同的节点拥有不同的链，为了解决这个问题，规定最长的、有效的链才是最终的链，换句话说，网络中有效最长链才是实际的链。 我们使用一下的算法，来达到网络中的共识 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 ... import requests class Blockchain(object) ... def valid_chain(self, chain): &quot;&quot;&quot; Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f&#39;{last_block}&#39;) print(f&#39;{block}&#39;) print(&quot;\n-----------\n&quot;) # Check that the hash of the block is correct if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def resolve_conflicts(self): &quot;&quot;&quot; 共识算法解决冲突 使用网络中最长的链. :return: &lt;bool&gt; True 如果链被取代, 否则为False &quot;&quot;&quot; neighbours = self.nodes new_chain = None # We&#39;re only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f&#39;http://{node}/chain&#39;) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False 第一个方法 valid_chain() 用来检查是否是有效链，遍历每个块验证hash和proof. 第2个方法 resolve_conflicts() 用来解决冲突，遍历所有的邻居节点，并用上一个方法检查链的有效性， 如果发现有效更长链，就替换掉自己的链 让我们添加两个路由，一个用来注册节点，一个用来解决冲突。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 你可以在不同的机器运行节点，或在一台机机开启不同的网络端口来模拟多节点的网络，这里在同一台机器开启不同的端口演示，在不同的终端运行一下命令，就启动了两个节点：http://localhost:5000 和 http://localhost:5001 1 2 pipenv run python blockchain.py pipenv run python blockchain.py -p 5001 然后在节点2上挖两个块，确保是更长的链，然后在节点1上访问接口/nodes/resolve ,这时节点1的链会通过共识算法被节点2的链取代。 好啦，你可以邀请朋友们一起来测试你的区块链 来源：https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/ 源码：https://github.com/xilibi2003/blockchain 作者：FlyAI 链接：https://juejin.im/post/5a98c60cf265da237a4c724b 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-03T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"源码：https://github.com/xilibi2003/blockchain 对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。 但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可以加深对区块链的理解。 准备工作 本文要求读者对Python有基本的理解，能读写基本的Python，并且需要对HTTP请求有基本的了解。 我们知道区块链是由区块的记录构成的不可变、有序的链结构，记录可以是交易、文件或任何你想要的数据，重要的是它们是通过哈希值（hashes）链接起来的。 环境准备 环境准备，确保已经安装Python3.6+, pip , Flask, requests安装方法： 1 pip install Flask==0.12.2 requests==2.18.4 同时还需要一个HTTP客户端，比如Postman，cURL或其它客户端。 参考源代码（原代码在我翻译的时候，无法运行，我fork了一份，修复了其中的错误，并添加了翻译，感谢star） 开始创建Blockchain 新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中，可以随时参考源代码 Blockchain类 首先创建一个Blockchain类，在构造函数中创建了两个列表，一个用于储存区块链，一个用于储存交易。 以下是Blockchain类的框架： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass Blockchain类用来管理链条，它能存储交易，加入新块等，下面我们来进一步完善这些方法。 块结构 每个区块包含属性：索引（index），Unix时间戳（timestamp），交易列表（transactions），工作量证明（稍后解释）以及前一个区块的Hash值。 以下是一个区块的结构： 1 2 3 4 5 6 7 8 9 10 11 12 13 block = { &#39;index&#39;: 1, &#39;timestamp&#39;: 1506057125.900785, &#39;transactions&#39;: [ { &#39;sender&#39;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;, &#39;recipient&#39;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;, &#39;amount&#39;: 5, } ], &#39;proof&#39;: 324984774000, &#39;previous_hash&#39;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot; } 到这里，区块链的概念就清楚了，每个新的区块都包含上一个区块的Hash，这是关键的一点，它保障了区块链不可变性。如果攻击者破坏了前面的某个区块，那么后面所有区块的Hash都会变得不正确。不理解的话，慢慢消化，可参考区块链记账原理 加入交易 接下来我们需要添加一个交易，来完善下new_transaction方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 方法向列表中添加一个交易记录，并返回该记录将被添加到的区块(下一个待挖掘的区块)的索引，等下在用户提交交易时会有用。 创建新块 当Blockchain实例化后，我们需要构造一个创世块（没有前区块的第一个区块），并且给它加上一个工作量证明。 每个区块都需要经过工作量证明，俗称挖矿，稍后会继续讲解。 为了构造创世块，我们还需要完善new_block(), new_transaction() 和hash() 方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import hashlib import json from time import time class Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): &quot;&quot;&quot; 生成新块 :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block &quot;&quot;&quot; block = { &#39;index&#39;: len(self.chain) + 1, &#39;timestamp&#39;: time(), &#39;transactions&#39;: self.current_transactions, &#39;proof&#39;: proof, &#39;previous_hash&#39;: previous_hash or self.hash(self.chain[-1]), } # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): &quot;&quot;&quot; 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction &quot;&quot;&quot; self.current_transactions.append({ &#39;sender&#39;: sender, &#39;recipient&#39;: recipient, &#39;amount&#39;: amount, }) return self.last_block[&#39;index&#39;] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): &quot;&quot;&quot; 生成块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; &quot;&quot;&quot; # We must make sure that the Dictionary is Ordered, or we&#39;ll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 通过上面的代码和注释可以对区块链有直观的了解，接下来我们看看区块是怎么挖出来的。 理解工作量证明 新的区块依赖工作量证明算法（PoW）来构造。PoW的目标是找出一个符合特定条件的数字，这个数字很难计算出来，但容易验证。这就是工作量证明的核心思想。 为了方便理解，举个例子： 假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc…0。设变量 x = 5，求 y 的值？ 用Python实现如下： 1 2 3 4 5 6 from hashlib import sha256 x = 5 y = 0 # y未知 while sha256(f&#39;{x*y}&#39;.encode()).hexdigest()[-1] != &quot;0&quot;: y += 1 print(f&#39;The solution is y = {y}&#39;) 结果是y=21. 因为： 1 hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，使用称为Hashcash的工作量证明算法，它和上面的问题很类似。矿工们为了争夺创建区块的权利而争相计算结果。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，会获得比特币奖励。当然，在网络上非常容易验证这个结果。 实现工作量证明 让我们来实现一个相似PoW算法，规则是：寻找一个数 p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import hashlib import json from time import time from uuid import uuid4 class Blockchain(object): ... def proof_of_work(self, last_proof): &quot;&quot;&quot; 简单的工作量证明: - 查找一个 p&#39; 使得 hash(pp&#39;) 以4个0开头 - p 是上一个块的证明, p&#39; 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; &quot;&quot;&quot; proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): &quot;&quot;&quot; 验证证明: 是否hash(last_proof, proof)以4个0开头? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. &quot;&quot;&quot; guess = f&#39;{last_proof}{proof}&#39;.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == &quot;0000&quot; 衡量算法复杂度的办法是修改零开头的个数。使用4个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。 现在Blockchain类基本已经完成了，接下来使用HTTP requests来进行交互。 Blockchain作为API接口 我们将使用Python Flask框架，这是一个轻量Web应用框架，它方便将网络请求映射到 Python函数，现在我们来让Blockchain运行在基于Flask web上。 我们将创建三个接口： /transactions/new 创建一个交易并添加到区块 /mine 告诉服务器去挖掘新的区块 /chain 返回整个区块链 创建节点 我们的“Flask服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask class Blockchain(object): ... # Instantiate our Node app = Flask(__name__) # Generate a globally unique address for this node node_identifier = str(uuid4()).replace(&#39;-&#39;, &#39;&#39;) # Instantiate the Blockchain blockchain = Blockchain() @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): return &quot;We&#39;ll mine a new Block&quot; @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): return &quot;We&#39;ll add a new transaction&quot; @app.route(&#39;/chain&#39;, methods=[&#39;GET&#39;]) def full_chain(): response = { &#39;chain&#39;: blockchain.chain, &#39;length&#39;: len(blockchain.chain), } return jsonify(response), 200 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) 简单的说明一下以上代码： 第15行: 创建一个节点。第18行: 为节点创建一个随机的名字。第21行: 实例Blockchain类。第24–26行: 创建/mine GET接口。第28–30行: 创建/transactions/new POST接口,可以给接口发送交易数据。第32–38行: 创建 /chain 接口, 返回整个区块链。第40–41行: 服务运行在端口5000上。 发送交易 发送到节点的交易数据结构如下： 1 2 3 4 5 { &quot;sender&quot;: &quot;my address&quot;, &quot;recipient&quot;: &quot;someone else&#39;s address&quot;, &quot;amount&quot;: 5 } 之前已经有添加交易的方法，基于接口来添加交易就很简单了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import hashlib import json from textwrap import dedent from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/transactions/new&#39;, methods=[&#39;POST&#39;]) def new_transaction(): values = request.get_json() # Check that the required fields are in the POST&#39;ed data required = [&#39;sender&#39;, &#39;recipient&#39;, &#39;amount&#39;] if not all(k in values for k in required): return &#39;Missing values&#39;, 400 # Create a new Transaction index = blockchain.new_transaction(values[&#39;sender&#39;], values[&#39;recipient&#39;], values[&#39;amount&#39;]) response = {&#39;message&#39;: f&#39;Transaction will be added to Block {index}&#39;} return jsonify(response), 201 挖矿 挖矿正是神奇所在，它很简单，做了一下三件事： 计算工作量证明PoW 通过新增一个交易授予矿工（自己）一个币 构造新区块并将其添加到链中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import hashlib import json from time import time from uuid import uuid4 from flask import Flask, jsonify, request ... @app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;]) def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block[&#39;proof&#39;] proof = blockchain.proof_of_work(last_proof) # 给工作量证明的节点提供奖励. # 发送者为 &quot;0&quot; 表明是新挖出的币 blockchain.new_transaction( sender=&quot;0&quot;, recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain block = blockchain.new_block(proof) response = { &#39;message&#39;: &quot;New Block Forged&quot;, &#39;index&#39;: block[&#39;index&#39;], &#39;transactions&#39;: block[&#39;transactions&#39;], &#39;proof&#39;: block[&#39;proof&#39;], &#39;previous_hash&#39;: block[&#39;previous_hash&#39;], } return jsonify(response), 200 注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕Blockchain类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下 运行区块链 你可以使用cURL 或Postman 去和API进行交互 启动server: 1 2 $ python blockchain.py * Runing on http://127.0.0.1:5000/ (Press CTRL+C to quit) 让我们通过请求 http://localhost:5000/mine 来进行挖矿 通过post请求，添加一个新交易 如果不是使用Postman，则用一下的cURL语句也是一样的： 1 2 3 4 5 $ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{ &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 5 }&#39; &quot;http://localhost:5000/transactions/new&quot; 在挖了两次矿之后，就有3个块了，通过请求 http://localhost:5000/chain 可以得到所有的块信息。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 { &quot;chain&quot;: [ { &quot;index&quot;: 1, &quot;previous_hash&quot;: 1, &quot;proof&quot;: 100, &quot;timestamp&quot;: 1506280650.770839, &quot;transactions&quot;: [] }, { &quot;index&quot;: 2, &quot;previous_hash&quot;: &quot;c099bc...bfb7&quot;, &quot;proof&quot;: 35293, &quot;timestamp&quot;: 1506280664.717925, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;, &quot;sender&quot;: &quot;0&quot; } ] }, { &quot;index&quot;: 3, &quot;previous_hash&quot;: &quot;eff91a...10f2&quot;, &quot;proof&quot;: 35089, &quot;timestamp&quot;: 1506280666.1086972, &quot;transactions&quot;: [ { &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;, &quot;sender&quot;: &quot;0&quot; } ] } ], &quot;length&quot;: 3 } 一致性（共识） 我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法。 注册节点 在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口： /nodes/register 接收URL形式的新节点列表 /nodes/resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链 我们修改下Blockchain的init函数并提供一个注册节点方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... from urllib.parse import urlparse ... class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): &quot;&quot;&quot; Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. &#39;http://192.168.0.5:5000&#39; :return: None &quot;&quot;&quot; parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) 我们用 set 来储存节点，这是一种避免重复添加节点的简单方法。 实现共识算法 前面提到，冲突是指不同的节点拥有不同的链，为了解决这个问题，规定最长的、有效的链才是最终的链，换句话说，网络中有效最长链才是实际的链。 我们使用一下的算法，来达到网络中的共识 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 ... import requests class Blockchain(object) ... def valid_chain(self, chain): &quot;&quot;&quot; Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not &quot;&quot;&quot; last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f&#39;{last_block}&#39;) print(f&#39;{block}&#39;) print(&quot;\\n-----------\\n&quot;) # Check that the hash of the block is correct if block[&#39;previous_hash&#39;] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block[&#39;proof&#39;], block[&#39;proof&#39;]): return False last_block = block current_index += 1 return True def resolve_conflicts(self): &quot;&quot;&quot; 共识算法解决冲突 使用网络中最长的链. :return: &lt;bool&gt; True 如果链被取代, 否则为False &quot;&quot;&quot; neighbours = self.nodes new_chain = None # We&#39;re only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f&#39;http://{node}/chain&#39;) if response.status_code == 200: length = response.json()[&#39;length&#39;] chain = response.json()[&#39;chain&#39;] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False 第一个方法 valid_chain() 用来检查是否是有效链，遍历每个块验证hash和proof. 第2个方法 resolve_conflicts() 用来解决冲突，遍历所有的邻居节点，并用上一个方法检查链的有效性， 如果发现有效更长链，就替换掉自己的链 让我们添加两个路由，一个用来注册节点，一个用来解决冲突。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @app.route(&#39;/nodes/register&#39;, methods=[&#39;POST&#39;]) def register_nodes(): values = request.get_json() nodes = values.get(&#39;nodes&#39;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = { &#39;message&#39;: &#39;New nodes have been added&#39;, &#39;total_nodes&#39;: list(blockchain.nodes), } return jsonify(response), 201 @app.route(&#39;/nodes/resolve&#39;, methods=[&#39;GET&#39;]) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { &#39;message&#39;: &#39;Our chain was replaced&#39;, &#39;new_chain&#39;: blockchain.chain } else: response = { &#39;message&#39;: &#39;Our chain is authoritative&#39;, &#39;chain&#39;: blockchain.chain } return jsonify(response), 200 你可以在不同的机器运行节点，或在一台机机开启不同的网络端口来模拟多节点的网络，这里在同一台机器开启不同的端口演示，在不同的终端运行一下命令，就启动了两个节点：http://localhost:5000 和 http://localhost:5001 1 2 pipenv run python blockchain.py pipenv run python blockchain.py -p 5001 然后在节点2上挖两个块，确保是更长的链，然后在节点1上访问接口/nodes/resolve ,这时节点1的链会通过共识算法被节点2的链取代。 好啦，你可以邀请朋友们一起来测试你的区块链 来源：https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/ 源码：https://github.com/xilibi2003/blockchain 作者：FlyAI 链接：https://juejin.im/post/5a98c60cf265da237a4c724b 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 阅读更多","@type":"BlogPosting","url":"/2018/03/03/87e9501b346df0dde61ea1c7338ca6db.html","headline":"干货 分分钟教你用Python创建一个区块链","dateModified":"2018-03-03T00:00:00+08:00","datePublished":"2018-03-03T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/03/03/87e9501b346df0dde61ea1c7338ca6db.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>干货 | 分分钟教你用Python创建一个区块链</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h1 class="article-title" style="line-height:1.5;color:rgb(51,51,51);font-family:'-apple-system', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Arial, sans-serif;background-color:rgb(255,255,255);"></h1>
  <div>
   <div>
    <p><strong>源码：https://github.com/xilibi2003/blockchain</strong></p>
    <p>对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。</p>
    <p>但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可以加深对区块链的理解。</p>
    <h2>准备工作</h2>
    <p>本文要求读者对Python有基本的理解，能读写基本的Python，并且需要对HTTP请求有基本的了解。</p>
    <p>我们知道区块链是由区块的记录构成的不可变、有序的链结构，记录可以是交易、文件或任何你想要的数据，重要的是它们是通过哈希值（hashes）链接起来的。</p>
    <h3>环境准备</h3>
    <p>环境准备，确保已经安装Python3.6+, pip , Flask, requests<br>安装方法：<br></p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
</code></pre></td>
        <td><pre class="hljs bash"><code>pip install Flask==0.12.2 requests==2.18.4</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>同时还需要一个HTTP客户端，比如Postman，cURL或其它客户端。</p>
    <p>参考源代码（原代码在我翻译的时候，无法运行，我fork了一份，修复了其中的错误，并添加了翻译，感谢star）</p>
    <h2>开始创建Blockchain</h2>
    <p><br></p>
    <p>新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中，可以随时参考源代码</p>
    <h3>Blockchain类</h3>
    <p>首先创建一个Blockchain类，在构造函数中创建了两个列表，一个用于储存区块链，一个用于储存交易。</p>
    <p>以下是Blockchain类的框架：<br></p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</code></pre></td>
        <td><pre class="hljs bash"><code>class Blockchain(object):
    def __init__(self):
        self.chain = []
        self.current_transactions = []
        
    def new_block(self):
        <span class="hljs-comment"># Creates a new Block and adds it to the chain</span>
        pass
    
    def new_transaction(self):
        <span class="hljs-comment"># Adds a new transaction to the list of transactions</span>
        pass
    
    @staticmethod
    def <span class="hljs-built_in">hash</span>(block):
        <span class="hljs-comment"># Hashes a Block</span>
        pass

    @property
    def last_block(self):
        <span class="hljs-comment"># Returns the last Block in the chain</span>
        pass</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>Blockchain类用来管理链条，它能存储交易，加入新块等，下面我们来进一步完善这些方法。</p>
    <h3>块结构</h3>
    <p>每个区块包含属性：索引（index），Unix时间戳（timestamp），交易列表（transactions），工作量证明（稍后解释）以及前一个区块的Hash值。</p>
    <p>以下是一个区块的结构：<br></p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
</code></pre></td>
        <td><pre class="hljs bash"><code>block = {
    <span class="hljs-string">'index'</span>: 1,
    <span class="hljs-string">'timestamp'</span>: 1506057125.900785,
    <span class="hljs-string">'transactions'</span>: [
        {
            <span class="hljs-string">'sender'</span>: <span class="hljs-string">"8527147fe1f5426f9dd545de4b27ee00"</span>,
            <span class="hljs-string">'recipient'</span>: <span class="hljs-string">"a77f5cdfa2934df3954a5c7c7da5df1f"</span>,
            <span class="hljs-string">'amount'</span>: 5,
        }
    ],
    <span class="hljs-string">'proof'</span>: 324984774000,
    <span class="hljs-string">'previous_hash'</span>: <span class="hljs-string">"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"</span>
}</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>到这里，区块链的概念就清楚了，每个新的区块都包含上一个区块的Hash，这是关键的一点，它保障了区块链不可变性。如果攻击者破坏了前面的某个区块，那么后面所有区块的Hash都会变得不正确。不理解的话，慢慢消化，可参考区块链记账原理</p>
    <h3>加入交易</h3>
    <p>接下来我们需要添加一个交易，来完善下new_transaction方法<br></p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</code></pre></td>
        <td><pre class="hljs bash"><code>class Blockchain(object):
    ...
    
    def new_transaction(self, sender, recipient, amount):
        <span class="hljs-string">""</span><span class="hljs-string">" 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction "</span><span class="hljs-string">""</span>

        self.current_transactions.append({
            <span class="hljs-string">'sender'</span>: sender,
            <span class="hljs-string">'recipient'</span>: recipient,
            <span class="hljs-string">'amount'</span>: amount,
        })

        <span class="hljs-built_in">return</span> self.last_block[<span class="hljs-string">'index'</span>] + 1</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>方法向列表中添加一个交易记录，并返回该记录将被添加到的区块(下一个待挖掘的区块)的索引，等下在用户提交交易时会有用。</p>
    <h3>创建新块</h3>
    <p>当Blockchain实例化后，我们需要构造一个创世块（没有前区块的第一个区块），并且给它加上一个工作量证明。</p>
    <p>每个区块都需要经过工作量证明，俗称挖矿，稍后会继续讲解。</p>
    <p>为了构造创世块，我们还需要完善new_block(), new_transaction() 和hash() 方法：</p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</code></pre></td>
        <td><pre class="hljs bash"><code>import hashlib
import json
from time import time


class Blockchain(object):
    def __init__(self):
        self.current_transactions = []
        self.chain = []

        <span class="hljs-comment"># Create the genesis block</span>
        self.new_block(previous_hash=1, proof=100)

    def new_block(self, proof, previous_hash=None):
        <span class="hljs-string">""</span><span class="hljs-string">" 生成新块 :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block "</span><span class="hljs-string">""</span>

        block = {
            <span class="hljs-string">'index'</span>: len(self.chain) + 1,
            <span class="hljs-string">'timestamp'</span>: time(),
            <span class="hljs-string">'transactions'</span>: self.current_transactions,
            <span class="hljs-string">'proof'</span>: proof,
            <span class="hljs-string">'previous_hash'</span>: previous_hash or self.hash(self.chain[-1]),
        }

        <span class="hljs-comment"># Reset the current list of transactions</span>
        self.current_transactions = []

        self.chain.append(block)
        <span class="hljs-built_in">return</span> block

    def new_transaction(self, sender, recipient, amount):
        <span class="hljs-string">""</span><span class="hljs-string">" 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction "</span><span class="hljs-string">""</span>
        self.current_transactions.append({
            <span class="hljs-string">'sender'</span>: sender,
            <span class="hljs-string">'recipient'</span>: recipient,
            <span class="hljs-string">'amount'</span>: amount,
        })

        <span class="hljs-built_in">return</span> self.last_block[<span class="hljs-string">'index'</span>] + 1

    @property
    def last_block(self):
        <span class="hljs-built_in">return</span> self.chain[-1]

    @staticmethod
    def <span class="hljs-built_in">hash</span>(block):
        <span class="hljs-string">""</span><span class="hljs-string">" 生成块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; "</span><span class="hljs-string">""</span>

        <span class="hljs-comment"># We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes</span>
        block_string = json.dumps(block, sort_keys=True).encode()
        <span class="hljs-built_in">return</span> hashlib.sha256(block_string).hexdigest()
</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>通过上面的代码和注释可以对区块链有直观的了解，接下来我们看看区块是怎么挖出来的。</p>
    <h3>理解工作量证明</h3>
    <p>新的区块依赖工作量证明算法（PoW）来构造。PoW的目标是找出一个符合特定条件的数字，<strong>这个数字很难计算出来，但容易验证</strong>。这就是工作量证明的核心思想。</p>
    <p>为了方便理解，举个例子：</p>
    <p>假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc…0。设变量 x = 5，求 y 的值？</p>
    <p>用Python实现如下：</p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
</code></pre></td>
        <td><pre class="hljs bash"><code>from hashlib import sha256
x = 5
y = 0  <span class="hljs-comment"># y未知</span>
<span class="hljs-keyword">while</span> sha256(f<span class="hljs-string">'{x*y}'</span>.encode()).hexdigest()[-1] != <span class="hljs-string">"0"</span>:
    y += 1
<span class="hljs-built_in">print</span>(f<span class="hljs-string">'The solution is y = {y}'</span>)
</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>结果是y=21. 因为：<br></p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
</code></pre></td>
        <td><pre class="hljs bash"><code><span class="hljs-built_in">hash</span>(5 * 21) = 1253e9373e...5e3600155e860</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>在比特币中，使用称为Hashcash的工作量证明算法，它和上面的问题很类似。矿工们为了争夺创建区块的权利而争相计算结果。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，会获得比特币奖励。<br>当然，在网络上非常容易验证这个结果。</p>
    <h3>实现工作量证明</h3>
    <p>让我们来实现一个相似PoW算法，规则是：寻找一个数 p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。</p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</code></pre></td>
        <td><pre class="hljs bash"><code>import hashlib
import json

from time import time
from uuid import uuid4


class Blockchain(object):
    ...
        
    def proof_of_work(self, last_proof):
        <span class="hljs-string">""</span><span class="hljs-string">" 简单的工作量证明: - 查找一个 p' 使得 hash(pp') 以4个0开头 - p 是上一个块的证明, p' 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; "</span><span class="hljs-string">""</span>

        proof = 0
        <span class="hljs-keyword">while</span> self.valid_proof(last_proof, proof) is False:
            proof += 1

        <span class="hljs-built_in">return</span> proof

    @staticmethod
    def valid_proof(last_proof, proof):
        <span class="hljs-string">""</span><span class="hljs-string">" 验证证明: 是否hash(last_proof, proof)以4个0开头? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. "</span><span class="hljs-string">""</span>

        guess = f<span class="hljs-string">'{last_proof}{proof}'</span>.encode()
        guess_hash = hashlib.sha256(guess).hexdigest()
        <span class="hljs-built_in">return</span> guess_hash[:4] == <span class="hljs-string">"0000"</span>
</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>衡量算法复杂度的办法是修改零开头的个数。使用4个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。</p>
    <p>现在Blockchain类基本已经完成了，接下来使用HTTP requests来进行交互。</p>
    <h2>Blockchain作为API接口</h2>
    <p>我们将使用Python Flask框架，这是一个轻量Web应用框架，它方便将网络请求映射到 Python函数，现在我们来让Blockchain运行在基于Flask web上。</p>
    <p>我们将创建三个接口：</p>
    <ul>
     <li><p>/transactions/new 创建一个交易并添加到区块</p></li>
     <li><p>/mine 告诉服务器去挖掘新的区块</p></li>
     <li><p>/chain 返回整个区块链</p></li>
    </ul>
    <h3>创建节点</h3>
    <p>我们的“Flask服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码：</p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</code></pre></td>
        <td><pre class="hljs bash"><code>import hashlib
import json
from textwrap import dedent
from time import time
from uuid import uuid4

from flask import Flask


class Blockchain(object):
    ...


<span class="hljs-comment"># Instantiate our Node</span>
app = Flask(__name__)

<span class="hljs-comment"># Generate a globally unique address for this node</span>
node_identifier = str(uuid4()).replace(<span class="hljs-string">'-'</span>, <span class="hljs-string">''</span>)

<span class="hljs-comment"># Instantiate the Blockchain</span>
blockchain = Blockchain()


@app.route(<span class="hljs-string">'/mine'</span>, methods=[<span class="hljs-string">'GET'</span>])
def mine():
    <span class="hljs-built_in">return</span> <span class="hljs-string">"We'll mine a new Block"</span>
  
@app.route(<span class="hljs-string">'/transactions/new'</span>, methods=[<span class="hljs-string">'POST'</span>])
def new_transaction():
    <span class="hljs-built_in">return</span> <span class="hljs-string">"We'll add a new transaction"</span>

@app.route(<span class="hljs-string">'/chain'</span>, methods=[<span class="hljs-string">'GET'</span>])
def full_chain():
    response = {
        <span class="hljs-string">'chain'</span>: blockchain.chain,
        <span class="hljs-string">'length'</span>: len(blockchain.chain),
    }
    <span class="hljs-built_in">return</span> jsonify(response), 200

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    app.run(host=<span class="hljs-string">'0.0.0.0'</span>, port=5000)
</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>简单的说明一下以上代码：</p>
    <p>第15行: 创建一个节点。<br>第18行: 为节点创建一个随机的名字。<br>第21行: 实例Blockchain类。<br>第24–26行: 创建/mine GET接口。<br>第28–30行: 创建/transactions/new POST接口,可以给接口发送交易数据。<br>第32–38行: 创建 /chain 接口, 返回整个区块链。<br>第40–41行: 服务运行在端口5000上。</p>
    <h3>发送交易</h3>
    <p>发送到节点的交易数据结构如下：<br></p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
</code></pre></td>
        <td><pre class="hljs bash"><code>{
 <span class="hljs-string">"sender"</span>: <span class="hljs-string">"my address"</span>,
 <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"someone else's address"</span>,
 <span class="hljs-string">"amount"</span>: 5
}</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>之前已经有添加交易的方法，基于接口来添加交易就很简单了</p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</code></pre></td>
        <td><pre class="hljs bash"><code>import hashlib
import json
from textwrap import dedent
from time import time
from uuid import uuid4

from flask import Flask, jsonify, request

...

@app.route(<span class="hljs-string">'/transactions/new'</span>, methods=[<span class="hljs-string">'POST'</span>])
def new_transaction():
    values = request.get_json()

    <span class="hljs-comment"># Check that the required fields are in the POST'ed data</span>
    required = [<span class="hljs-string">'sender'</span>, <span class="hljs-string">'recipient'</span>, <span class="hljs-string">'amount'</span>]
    <span class="hljs-keyword">if</span> not all(k <span class="hljs-keyword">in</span> values <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> required):
        <span class="hljs-built_in">return</span> <span class="hljs-string">'Missing values'</span>, 400

    <span class="hljs-comment"># Create a new Transaction</span>
    index = blockchain.new_transaction(values[<span class="hljs-string">'sender'</span>], values[<span class="hljs-string">'recipient'</span>], values[<span class="hljs-string">'amount'</span>])

    response = {<span class="hljs-string">'message'</span>: f<span class="hljs-string">'Transaction will be added to Block {index}'</span>}
    <span class="hljs-built_in">return</span> jsonify(response), 201
</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <h3>挖矿</h3>
    <p>挖矿正是神奇所在，它很简单，做了一下三件事：</p>
    <ol>
     <li><p>计算工作量证明PoW</p></li>
     <li><p>通过新增一个交易授予矿工（自己）一个币</p></li>
     <li><p>构造新区块并将其添加到链中</p></li>
    </ol>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</code></pre></td>
        <td><pre class="hljs bash"><code>import hashlib
import json

from time import time
from uuid import uuid4

from flask import Flask, jsonify, request

...

@app.route(<span class="hljs-string">'/mine'</span>, methods=[<span class="hljs-string">'GET'</span>])
def mine():
    <span class="hljs-comment"># We run the proof of work algorithm to get the next proof...</span>
    last_block = blockchain.last_block
    last_proof = last_block[<span class="hljs-string">'proof'</span>]
    proof = blockchain.proof_of_work(last_proof)

    <span class="hljs-comment"># 给工作量证明的节点提供奖励.</span>
    <span class="hljs-comment"># 发送者为 "0" 表明是新挖出的币</span>
    blockchain.new_transaction(
        sender=<span class="hljs-string">"0"</span>,
        recipient=node_identifier,
        amount=1,
    )

    <span class="hljs-comment"># Forge the new Block by adding it to the chain</span>
    block = blockchain.new_block(proof)

    response = {
        <span class="hljs-string">'message'</span>: <span class="hljs-string">"New Block Forged"</span>,
        <span class="hljs-string">'index'</span>: block[<span class="hljs-string">'index'</span>],
        <span class="hljs-string">'transactions'</span>: block[<span class="hljs-string">'transactions'</span>],
        <span class="hljs-string">'proof'</span>: block[<span class="hljs-string">'proof'</span>],
        <span class="hljs-string">'previous_hash'</span>: block[<span class="hljs-string">'previous_hash'</span>],
    }
    <span class="hljs-built_in">return</span> jsonify(response), 200
</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕Blockchain类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下</p>
    <h2>运行区块链</h2>
    <p>你可以使用cURL 或Postman 去和API进行交互</p>
    <p>启动server:<br></p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
</code></pre></td>
        <td><pre class="hljs bash"><code>$ python blockchain.py
* Runing on http://127.0.0.1:5000/ (Press CTRL+C to quit)</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>让我们通过请求 http://localhost:5000/mine 来进行挖矿</p>
    <p></p>
    <p>通过post请求，添加一个新交易</p>
    <p></p>
    <p>如果不是使用Postman，则用一下的cURL语句也是一样的：<br></p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
</code></pre></td>
        <td><pre class="hljs bash"><code>$ curl -X POST -H <span class="hljs-string">"Content-Type: application/json"</span> <span class="hljs-_">-d</span> <span class="hljs-string">'{ "sender": "d4ee26eee15148ee92c6cd394edd974e", "recipient": "someone-other-address", "amount": 5 }'</span> <span class="hljs-string">"http://localhost:5000/transactions/new"</span></code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>在挖了两次矿之后，就有3个块了，通过请求 http://localhost:5000/chain 可以得到所有的块信息。</p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</code></pre></td>
        <td><pre class="hljs bash"><code>{
  <span class="hljs-string">"chain"</span>: [
    {
      <span class="hljs-string">"index"</span>: 1,
      <span class="hljs-string">"previous_hash"</span>: 1,
      <span class="hljs-string">"proof"</span>: 100,
      <span class="hljs-string">"timestamp"</span>: 1506280650.770839,
      <span class="hljs-string">"transactions"</span>: []
    },
    {
      <span class="hljs-string">"index"</span>: 2,
      <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"c099bc...bfb7"</span>,
      <span class="hljs-string">"proof"</span>: 35293,
      <span class="hljs-string">"timestamp"</span>: 1506280664.717925,
      <span class="hljs-string">"transactions"</span>: [
        {
          <span class="hljs-string">"amount"</span>: 1,
          <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"8bbcb347e0634905b0cac7955bae152b"</span>,
          <span class="hljs-string">"sender"</span>: <span class="hljs-string">"0"</span>
        }
      ]
    },
    {
      <span class="hljs-string">"index"</span>: 3,
      <span class="hljs-string">"previous_hash"</span>: <span class="hljs-string">"eff91a...10f2"</span>,
      <span class="hljs-string">"proof"</span>: 35089,
      <span class="hljs-string">"timestamp"</span>: 1506280666.1086972,
      <span class="hljs-string">"transactions"</span>: [
        {
          <span class="hljs-string">"amount"</span>: 1,
          <span class="hljs-string">"recipient"</span>: <span class="hljs-string">"8bbcb347e0634905b0cac7955bae152b"</span>,
          <span class="hljs-string">"sender"</span>: <span class="hljs-string">"0"</span>
        }
      ]
    }
  ],
  <span class="hljs-string">"length"</span>: 3
}
</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <h2>一致性（共识）</h2>
    <p>我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法。</p>
    <h3>注册节点</h3>
    <p>在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口：</p>
    <ol>
     <li><p>/nodes/register 接收URL形式的新节点列表</p></li>
     <li><p>/nodes/resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链<br><br></p></li>
    </ol>
    <p>我们修改下Blockchain的init函数并提供一个注册节点方法：<br></p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</code></pre></td>
        <td><pre class="hljs bash"><code>...
from urllib.parse import urlparse
...


class Blockchain(object):
    def __init__(self):
        ...
        self.nodes = <span class="hljs-built_in">set</span>()
        ...

    def register_node(self, address):
        <span class="hljs-string">""</span><span class="hljs-string">" Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. 'http://192.168.0.5:5000' :return: None "</span><span class="hljs-string">""</span>

        parsed_url = urlparse(address)
        self.nodes.add(parsed_url.netloc)</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>我们用 set 来储存节点，这是一种避免重复添加节点的简单方法。</p>
    <h3>实现共识算法</h3>
    <p>前面提到，冲突是指不同的节点拥有不同的链，为了解决这个问题，规定最长的、有效的链才是最终的链，换句话说，网络中有效最长链才是实际的链。</p>
    <p>我们使用一下的算法，来达到网络中的共识<br></p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</code></pre></td>
        <td><pre class="hljs bash"><code>...
import requests


class Blockchain(object)
    ...
    
    def valid_chain(self, chain):
        <span class="hljs-string">""</span><span class="hljs-string">" Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not "</span><span class="hljs-string">""</span>

        last_block = chain[0]
        current_index = 1

        <span class="hljs-keyword">while</span> current_index &lt; len(chain):
            block = chain[current_index]
            <span class="hljs-built_in">print</span>(f<span class="hljs-string">'{last_block}'</span>)
            <span class="hljs-built_in">print</span>(f<span class="hljs-string">'{block}'</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n-----------\n"</span>)
            <span class="hljs-comment"># Check that the hash of the block is correct</span>
            <span class="hljs-keyword">if</span> block[<span class="hljs-string">'previous_hash'</span>] != self.hash(last_block):
                <span class="hljs-built_in">return</span> False

            <span class="hljs-comment"># Check that the Proof of Work is correct</span>
            <span class="hljs-keyword">if</span> not self.valid_proof(last_block[<span class="hljs-string">'proof'</span>], block[<span class="hljs-string">'proof'</span>]):
                <span class="hljs-built_in">return</span> False

            last_block = block
            current_index += 1

        <span class="hljs-built_in">return</span> True

    def resolve_conflicts(self):
        <span class="hljs-string">""</span><span class="hljs-string">" 共识算法解决冲突 使用网络中最长的链. :return: &lt;bool&gt; True 如果链被取代, 否则为False "</span><span class="hljs-string">""</span>

        neighbours = self.nodes
        new_chain = None

        <span class="hljs-comment"># We're only looking for chains longer than ours</span>
        max_length = len(self.chain)

        <span class="hljs-comment"># Grab and verify the chains from all the nodes in our network</span>
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> neighbours:
            response = requests.get(f<span class="hljs-string">'http://{node}/chain'</span>)

            <span class="hljs-keyword">if</span> response.status_code == 200:
                length = response.json()[<span class="hljs-string">'length'</span>]
                chain = response.json()[<span class="hljs-string">'chain'</span>]

                <span class="hljs-comment"># Check if the length is longer and the chain is valid</span>
                <span class="hljs-keyword">if</span> length &gt; max_length and self.valid_chain(chain):
                    max_length = length
                    new_chain = chain

        <span class="hljs-comment"># Replace our chain if we discovered a new, valid chain longer than ours</span>
        <span class="hljs-keyword">if</span> new_chain:
            self.chain = new_chain
            <span class="hljs-built_in">return</span> True

        <span class="hljs-built_in">return</span> False</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>第一个方法 valid_chain() 用来检查是否是有效链，遍历每个块验证hash和proof.</p>
    <p>第2个方法 resolve_conflicts() 用来解决冲突，遍历所有的邻居节点，并用上一个方法检查链的有效性， <strong>如果发现有效更长链，就替换掉自己的链</strong></p>
    <p>让我们添加两个路由，一个用来注册节点，一个用来解决冲突。<br></p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</code></pre></td>
        <td><pre class="hljs bash"><code>@app.route(<span class="hljs-string">'/nodes/register'</span>, methods=[<span class="hljs-string">'POST'</span>])
def register_nodes():
    values = request.get_json()

    nodes = values.get(<span class="hljs-string">'nodes'</span>)
    <span class="hljs-keyword">if</span> nodes is None:
        <span class="hljs-built_in">return</span> <span class="hljs-string">"Error: Please supply a valid list of nodes"</span>, 400

    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes:
        blockchain.register_node(node)

    response = {
        <span class="hljs-string">'message'</span>: <span class="hljs-string">'New nodes have been added'</span>,
        <span class="hljs-string">'total_nodes'</span>: list(blockchain.nodes),
    }
    <span class="hljs-built_in">return</span> jsonify(response), 201


@app.route(<span class="hljs-string">'/nodes/resolve'</span>, methods=[<span class="hljs-string">'GET'</span>])
def consensus():
    replaced = blockchain.resolve_conflicts()

    <span class="hljs-keyword">if</span> replaced:
        response = {
            <span class="hljs-string">'message'</span>: <span class="hljs-string">'Our chain was replaced'</span>,
            <span class="hljs-string">'new_chain'</span>: blockchain.chain
        }
    <span class="hljs-keyword">else</span>:
        response = {
            <span class="hljs-string">'message'</span>: <span class="hljs-string">'Our chain is authoritative'</span>,
            <span class="hljs-string">'chain'</span>: blockchain.chain
        }

    <span class="hljs-built_in">return</span> jsonify(response), 200</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>你可以在不同的机器运行节点，或在一台机机开启不同的网络端口来模拟多节点的网络，这里在同一台机器开启不同的端口演示，在不同的终端运行一下命令，就启动了两个节点：http://localhost:5000 和 http://localhost:5001</p>
    <div>
     <table>
      <tbody>
       <tr>
        <td><pre class="hljs bash"><code>1
2
</code></pre></td>
        <td><pre class="hljs bash"><code>pipenv run python blockchain.py
pipenv run python blockchain.py -p 5001
</code></pre></td>
       </tr>
      </tbody>
     </table>
    </div>
    <p><img class="lazyload inited loaded" src="https://user-gold-cdn.xitu.io/2018/3/2/161e4c985f1e48ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
    <p>然后在节点2上挖两个块，确保是更长的链，然后在节点1上访问接口/nodes/resolve ,这时节点1的链会通过共识算法被节点2的链取代。</p>
    <p><img class="lazyload inited loaded" src="https://user-gold-cdn.xitu.io/2018/3/2/161e4c985f24257d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
    <p>好啦，你可以邀请朋友们一起来测试你的区块链</p>
    <p>来源：https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/</p>
    <p>源码：https://github.com/xilibi2003/blockchain</p>
   </div>
   <br>作者：FlyAI
   <br>链接：https://juejin.im/post/5a98c60cf265da237a4c724b
   <br>来源：掘金
   <br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  </div>
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_19861715/article/details/79428608,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_19861715/article/details/79428608,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
