<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>åˆé“¾ä¸»ç½‘Betaç‰ˆæ…¢é“¾æŒ–çŸ¿è§£æ | æœ‰ç»„ç»‡åœ¨ï¼</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="åˆé“¾ä¸»ç½‘Betaç‰ˆæ…¢é“¾æŒ–çŸ¿è§£æ" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="åˆé“¾ä¸»ç½‘Betaç‰ˆäºæ–°åŠ å¡æ—¶é—´2018å¹´09æœˆ28æ—¥08:00æ­£å¼ä¸Šçº¿ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œ07:56åˆ†PBFTå§”å‘˜ä¼šç¬¬ä¸€æ¬¡å…±è¯†å‡ºå—å’ŒTrueChain fPOWåˆ›ä¸–åŒºå—è¢«æŒ–å‡ºã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥è°ˆè°ˆæ…¢é“¾çš„å‡ºçŸ¿ã€‚ 1 å¯åŠ¨èŠ‚ç‚¹è‡ªåŠ¨æŒ–çŸ¿ æœ¬å¸–ä»¥dockeræŒ–çŸ¿ä¸ºä¾‹ï¼Œè¯¦ç»†æ“ä½œè§dockerç‰ˆæŒ–çŸ¿æ•™ç¨‹ ã€‚èŠ‚ç‚¹å¯åŠ¨åˆ†ä¸ºå‚ä¸å‚åŠ å§”å‘˜ä¼šç«é€‰æŒ–çŸ¿ã€‚ 1.1 å‚ä¸å§”å‘˜ä¼šç«é€‰èŠ‚ç‚¹æŒ–çŸ¿ 1ï¼‰æŒ–çŸ¿åªæŒ–æ°´æœ docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit --election console 2ï¼‰æŒ–çŸ¿æ°´æœå’ŒåŒºå— docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --election console 1.2 éå‚ä¸å§”å‘˜ä¼šç«é€‰èŠ‚ç‚¹æŒ–çŸ¿ 1ï¼‰æŒ–çŸ¿åªæŒ–æ°´æœ docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit console 2ï¼‰æŒ–çŸ¿æ°´æœå’ŒåŒºå— docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine console 1.3 å¯åŠ¨å‘½ä»¤è§£æ -p å°†å®¹å™¨ä¸­çš„ç«¯å£æ˜ å°„åˆ°å®¿ä¸»æœº â€“datadir æ•°æ®å­˜å‚¨çš„æ–‡ä»¶å¤¹ â€“minefruit æŒ‡å®šæŒ–çŸ¿åªæŒ–æ°´æœ â€“election æœ¬èŠ‚ç‚¹å‚ä¸å§”å‘˜ä¼šç«é€‰ 2 FPOWæœºåˆ¶æŒ–çŸ¿ 2.1 æŒ–çŸ¿æµç¨‹ åˆé“¾é‡‡ç”¨äº†æ°´æœé“¾ï¼ˆFruitChainï¼‰çš„è®¾è®¡æ¥ä¿è¯åœ¨æŒ–çŸ¿è¿‡ç¨‹ä¸­æ‰€æœ‰å‚ä¸è€…çš„å…¬å¹³æ€§ã€‚è¿™æ˜¯ä¸€ç§å…¨æ–°çš„è®¾è®¡æŒ–çŸ¿çš„è®¾è®¡ç†å¿µï¼Œç§°ä¹‹ä¸ºFPOWã€‚è¿™ç§è®¾è®¡æœ‰æ•ˆçš„è§£å†³äº†ç®—åŠ›å·®è·å¯¼è‡´çš„å°ç®—åŠ›çŸ¿å·¥æŒ–ä¸åˆ°çŸ¿çš„ä¸è¶³ï¼Œä¿è¯äº†æ‰€æœ‰çŸ¿å·¥çš„å…¬å¹³æ€§ï¼Œå› ä¸ºåœ¨æŒ–çŸ¿è¿‡ç¨‹ä¸­æŒ–åˆ°ç›¸å¯¹ç®€å•çš„æ°´æœï¼ˆfruitï¼‰ä¹Ÿæ˜¯æœ‰å¥–åŠ±çš„ã€‚æŒ–åˆ°çš„æ°´æœç§°ä¹‹ä¸ºæ°´æœé“¾ï¼ˆFruitChainï¼‰ã€‚å…¶å¤§è‡´çš„æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ 2.2 ä»£ç å®ç° ä¸Šå›¾æµç¨‹ä¸­çš„ä»£ç å®ç°æˆ‘ä»¬å¯ä»¥ä»æºç çš„truechain-engineering-code/miner/worker.goä¸­æ‰¾åˆ°ã€‚ block := result.Block //work := result.Work if block.IsFruit() { if block.FastNumber() == nil { // if it does&#39;t include a fast block signs, it&#39;s not a fruit continue } if block.FastNumber().Cmp(common.Big0) == 0 { continue } //log.Info(&quot;ğŸ’ â€”-------mined fruit&quot;,&quot; FB NUMBER&quot;,block.FastNumber()) // add fruit once if self.FastBlockNumber != nil{ if self.FastBlockNumber.Cmp(block.FastNumber()) !=0 { log.Info(&quot;ğŸ’ ----mined fruit 1&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) //log.Info(&quot;not same fruits&quot;) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } }else{ log.Info(&quot;ğŸ’ ----mined fruit 2&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } // make sure the fast number has been fruit self.FastBlockNumber.SetUint64(block.FastNumber().Uint64()) // only have fast block not fruits we need commit new work if self.current.fruits == nil{ self.atCommintNewWoker = false // post msg for commitnew work var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) self.chain.PostChainEvents(events) } } else { if block.Fruits() == nil{ self.atCommintNewWoker = false continue } fruits := block.Fruits() log.Info(&quot;+++++ mined block --- &quot;,&quot;block number&quot;,block.Number(), &quot;fruits&quot;, len(fruits), &quot;first&quot;, fruits[0].FastNumber(), &quot;end&quot;, fruits[len(fruits) - 1].FastNumber()) stat, err := self.chain.WriteCanonicalBlock(block) if err != nil { log.Error(&quot;Failed writing block to chain&quot;, &quot;err&quot;, err) continue } // Broadcast the block and announce chain insertion event self.mux.Post(chain.NewMinedBlockEvent{Block: block}) var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) if stat == chain.CanonStatTy { events = append(events, chain.ChainEvent{Block: block, Hash: block.Hash()}) events = append(events, chain.ChainHeadEvent{Block: block}) } self.chain.PostChainEvents(events) // Insert the block into the set of pending ones to wait for confirmations self.unconfirmed.Insert(block.NumberU64(), block.Hash()) self.atCommintNewWoker = false } block := result.Blockï¼šé¦–å…ˆè·å–åˆ°ç»“æœä¸­çš„blockï¼ˆå§‘ä¸”å…ˆå«ä»–blockï¼Œåº”ä¸ºä»–è¿˜æœ‰å¯èƒ½åªæ˜¯ä¸€ä¸ªæ°´æœè€Œä¸æ˜¯å—ï¼‰ã€‚ é€šè¿‡block.IsFruit()æ–¹æ³•åˆ¤æ–­æ­¤blockæ˜¯å¦æ˜¯æ°´æœï¼ˆfruitï¼‰ï¼Œå¦‚æœè¿”å›trueçš„è¯ï¼Œè¿›å…¥æ–¹æ³•ä½“ï¼Œæ‰§è¡Œæ°´æœçš„æ“ä½œï¼Œåä¹‹ï¼Œæ‰§è¡Œå—çš„æ“ä½œã€‚ block.IsFruit()è¿”å›trueã€‚é€šè¿‡self.etrue.SnailPool().AddRemoteFruits(newFruits)å°†è¯¥blockæ·»åŠ åˆ°æ°´æœæ± ï¼ˆsnailpoolï¼‰ä¸­ã€‚ block.IsFruit()è¿”å›false,å¹¶ä¸”è¯¥blockä¸­å«æœ‰fruitï¼Œé‚£ä¹ˆæäº¤å§”å‘˜ä¼šç¡®è®¤å°±å¯ä»¥æ‰§è¡Œä¸Šé“¾æ“ä½œäº†ï¼Œself.chain.WriteCanonicalBlock(block)ã€‚ 2.3 æ°´æœæ–°é²œåº¦ç¡®è®¤ åˆé“¾é€šè¿‡fPOWæœºåˆ¶å¯ä»¥å¾ˆæœ‰æ•ˆçš„é¿å…è‡ªç§æŒ–çŸ¿ï¼Œå…¶åŸç†å°±æ˜¯ç»™æ°´æœèµ‹äºˆæ–°é²œåº¦çš„æ¦‚å¿µã€‚å¦‚æœä¸€ä¸ªè‡ªç§çš„çŸ¿å·¥åœ¨æŒ–åˆ°å—ä¹‹åä¸æäº¤å§”å‘˜ä¼šç¡®è®¤ï¼Œè‡ªå·±æƒ³å†æŒ–åˆ°æ›´é•¿çš„é“¾ä¹‹åå†å¹¿æ’­çš„è¯ï¼Œé‚£ä¹ˆï¼Œå¯¹ä¸èµ·ï¼Œä¹‹å‰æŒ–åˆ°çš„æ°´æœå¾ˆå¯èƒ½å°±å·²ç»è¿‡æœŸäº†ï¼Œé‚£ä¹ˆä¹‹å‰æ²¡å¹¿æ’­çš„é“¾ä¹Ÿå°±ä½œåºŸäº†ã€‚æ‰€ä»¥çŸ¿å·¥ä¼šé¿å…æ°´æœè¿‡æœŸè€ŒåŠæ—¶æŠŠè‡ªå·±æŒ–åˆ°çš„å—æäº¤å§”å‘˜ä¼šç¡®è®¤å¹¶ä¸Šé“¾ï¼Œä»è€Œæœ‰æ•ˆçš„é¿å…è‡ªç§æŒ–çŸ¿ã€‚ä¸‹é¢æ˜¯æ°´æœæ–°é²œåº¦ç¡®è®¤çš„ä»£ç å®ç°ã€‚æˆªå–è‡ªtruechain-engineering-code/consensus/minerva/consensus.goã€‚ func (m *Minerva) VerifyFreshness(fruit, block *types.SnailHeader) error { var headerNumber *big.Int if block == nil { // when block is nil, is used to verify new fruits for next block headerNumber = new(big.Int).Add(m.sbc.CurrentHeader().Number, common.Big1) } else { headerNumber = block.Number } // check freshness pointer := m.sbc.GetHeaderByNumber(fruit.PointerNumber.Uint64()) if pointer == nil { return types.ErrSnailHeightNotYet } if pointer.Hash() != fruit.PointerHash { log.Debug(&quot;VerifyFreshness get pointer failed.&quot;, &quot;fruit&quot;, fruit.FastNumber, &quot;pointerNumber&quot;, fruit.PointerNumber, &quot;pointerHash&quot;, fruit.PointerHash, &quot;fruitNumber&quot;, fruit.Number, &quot;pointer&quot;, pointer.Hash()) return consensus.ErrUnknownPointer } freshNumber := new(big.Int).Sub(headerNumber, pointer.Number) if freshNumber.Cmp(params.FruitFreshness) &gt; 0 { log.Debug(&quot;VerifyFreshness failed.&quot;, &quot;fruit sb&quot;, fruit.Number, &quot;fruit fb&quot;, fruit.FastNumber, &quot;poiner&quot;, pointer.Number, &quot;current&quot;, headerNumber) return consensus.ErrFreshness } return nil } ä»ä¸Šé¢çš„ä»£ç å—ä¸­å¯çŸ¥ï¼Œæ°´æœçš„hashå’ŒæŒ‡é’ˆçš„hashå€¼ä¸ç›¸ç­‰ä»¥åŠæ°´æœæ–°é²œåº¦å€¼å¤§äºè®¾ç½®çš„æ–°é²œå€¼çš„æ—¶å€™ï¼Œå‡ä¼šè¿”å›VerifyFreshness failedï¼Œå³è¯¥æ°´æœå·²ç»è¿‡æœŸäº†ã€‚ 2.4 æŒ–çŸ¿å¥–åŠ±åˆ†é… æˆ‘ä»¬è¯´fPOWæœºåˆ¶å¯¹æ‰€æœ‰çš„çŸ¿å·¥éƒ½æ˜¯å…¬å¹³çš„ï¼Œä¸ä¼šå› ä¸ºæ™®é€šçŸ¿å·¥çš„ç®—åŠ›ä¸å¤Ÿè€ŒæŒ–ä¸åˆ°å—å¯¼è‡´å¾—ä¸åˆ°å¥–åŠ±ï¼Œå› ä¸ºå°±ç®—ä½ ç®—åŠ›ä¸å¤Ÿï¼ŒæŒ–åˆ°æ°´æœçš„æ¦‚ç‡è¿˜æ˜¯æ¯”è¾ƒé«˜çš„ã€‚é‚£ä¹ˆï¼Œè¿™ä¸ªå¥–åŠ±æ˜¯æ€ä¹ˆåˆ†é…çš„å‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹åˆ†é…çš„ä»£ç ã€‚ // AccumulateRewardsFast credits the coinbase of the given block with the mining // reward. The total reward consists of the static block reward and rewards for // included uncles. The coinbase of each uncle block is also rewarded. func accumulateRewardsFast(election consensus.CommitteeElection, state *state.StateDB, header *types.Header, sBlock *types.SnailBlock) error { committeeCoin, minerCoin, minerFruitCoin, e := getBlockReward(header.Number) if e != nil { return e } //miner&#39;s award state.AddBalance(sBlock.Coinbase(), minerCoin) LogPrint(&quot;miner&#39;s award&quot;, sBlock.Coinbase(), minerCoin) //miner fruit award blockFruits := sBlock.Body().Fruits blockFruitsLen := big.NewInt(int64(len(blockFruits))) if len(blockFruits) &gt; 0 { minerFruitCoinOne := new(big.Int).Div(minerFruitCoin, blockFruitsLen) for _, v := range sBlock.Body().Fruits { state.AddBalance(v.Coinbase(), minerFruitCoinOne) LogPrint(&quot;minerFruit&quot;, v.Coinbase(), minerFruitCoinOne) } } else { return consensus.ErrInvalidBlock } //committee&#39;s award committeeCoinFruit := new(big.Int).Div(committeeCoin, blockFruitsLen) //all fail committee coinBase failAddr := make(map[common.Address]bool) for _, fruit := range blockFruits { signs := fruit.Body().Signs committeeMembers, errs := election.VerifySigns(signs) if len(committeeMembers) != len(errs) { return consensus.ErrInvalidSignsLength } //Effective and not evil var fruitOkAddr []common.Address for i, cm := range committeeMembers { if errs[i] != nil { continue } cmPubAddr := crypto.PubkeyToAddress(*cm.Publickey) if signs[i].Result == types.VoteAgree { if _, ok := failAddr[cmPubAddr]; !ok { fruitOkAddr = append(fruitOkAddr, cm.Coinbase) } } else { failAddr[cmPubAddr] = false } } if len(fruitOkAddr) == 0 { log.Error(&quot;fruitOkAddr&quot;, &quot;Error&quot;, consensus.ErrInvalidSignsLength.Error()) return nil } // Equal by fruit committeeCoinFruitMember := new(big.Int).Div(committeeCoinFruit, big.NewInt(int64(len(fruitOkAddr)))) for _, v := range fruitOkAddr { state.AddBalance(v, committeeCoinFruitMember) LogPrint(&quot;committee&quot;, v, committeeCoinFruitMember) } } return nil } ä»ä¸Šé¢è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æŒ–çŸ¿å¥–åŠ±æ˜¯åˆ†é…ç»™ä¸‰æ–¹çš„ï¼Œåˆ†åˆ«æ˜¯ï¼š åŒºå—çŸ¿å·¥ æ°´æœçŸ¿å·¥ å§”å‘˜ä¼š ä¹Ÿè®¸æœ‰äººä¼šé—®å•¦ï¼Œå¦‚æœåŒºå—ä¸åŒ…å«æ°´æœï¼Œæ˜¯ä¸æ˜¯å°±åªè¦åˆ†ç»™åŒºå—çŸ¿å·¥å’Œå§”å‘˜ä¼šä¸¤æ–¹å°±å¯ä»¥å•¦ï¼Œç­”æ¡ˆæ˜¯å¦å®šçš„ï¼Œå¦‚æœè¿™ä¸ªåŒºå—ä¸åŒ…å«æ°´æœï¼ˆlen(sBlock.Body().Fruits)&lt;=0ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªå—æ˜¯ä¸åˆæ³•çš„ï¼ˆErrInvalidBlockï¼‰ã€‚ åˆ†é…æµç¨‹ä¸ºï¼š è®¡ç®—åŒºå—çš„å¥–åŠ±ï¼ŒgetBlockRewardï¼ˆï¼‰ è®¡ç®—åŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥ï¼Œå§”å‘˜ä¼šåˆ†åˆ«åº”å¾—çš„å¥–åŠ± ç»™åŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥ï¼Œç­¾åçš„å§”å‘˜ä¼šæˆå‘˜åˆ†å‘å¥–åŠ±ã€‚ 3 æ€»ç»“ åˆé“¾ä½¿ç”¨äº†fPOWæœºåˆ¶ï¼Œè¿™ç§è®¾è®¡æœ‰æ•ˆçš„è§£å†³äº†ç®—åŠ›å·®è·å¯¼è‡´çš„å°ç®—åŠ›çŸ¿å·¥æŒ–ä¸åˆ°çŸ¿çš„ä¸è¶³ï¼Œä¿è¯äº†æ‰€æœ‰çŸ¿å·¥çš„å…¬å¹³æ€§ã€‚è¿™ç§æœºåˆ¶çš„å‡ºçŸ¿æµç¨‹æ˜¯çŸ¿å·¥æŒ–åˆ°çŸ¿ååˆ¤æ–­æ˜¯å—è¿˜æ˜¯æ°´æœï¼ŒçŸ¿å·¥æŒ–åˆ°æ°´æœåï¼Œä¼šå°†æ°´æœæ”¾åˆ°ä¸€ä¸ªæ°´æœæ± ï¼ˆfruit poolï¼‰ä¸­ï¼Œå¾…åˆ°æŒ–åˆ°å—ï¼ˆblockï¼‰åï¼Œä¾¿ä»æ°´æœæ± ä¸­å–å‡ºæ°´æœæ”¾ç½®åœ¨åŒºå—ä¸­ï¼ŒåŒºå—è¿›å…¥å§”å‘˜ä¼šè¿›è¡Œç¡®è®¤ï¼Œè¾¾æˆå…±è¯†å°±ä¸Šé“¾ã€‚ä¸Šé“¾ååŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥åŠç­¾åçš„å§”å‘˜ä¼šæˆå‘˜éƒ½èƒ½åˆ†åˆ°è¯¥åŒºå—çš„å¥–åŠ±ã€‚ é˜…è¯»æ›´å¤š" />
<meta property="og:description" content="åˆé“¾ä¸»ç½‘Betaç‰ˆäºæ–°åŠ å¡æ—¶é—´2018å¹´09æœˆ28æ—¥08:00æ­£å¼ä¸Šçº¿ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œ07:56åˆ†PBFTå§”å‘˜ä¼šç¬¬ä¸€æ¬¡å…±è¯†å‡ºå—å’ŒTrueChain fPOWåˆ›ä¸–åŒºå—è¢«æŒ–å‡ºã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥è°ˆè°ˆæ…¢é“¾çš„å‡ºçŸ¿ã€‚ 1 å¯åŠ¨èŠ‚ç‚¹è‡ªåŠ¨æŒ–çŸ¿ æœ¬å¸–ä»¥dockeræŒ–çŸ¿ä¸ºä¾‹ï¼Œè¯¦ç»†æ“ä½œè§dockerç‰ˆæŒ–çŸ¿æ•™ç¨‹ ã€‚èŠ‚ç‚¹å¯åŠ¨åˆ†ä¸ºå‚ä¸å‚åŠ å§”å‘˜ä¼šç«é€‰æŒ–çŸ¿ã€‚ 1.1 å‚ä¸å§”å‘˜ä¼šç«é€‰èŠ‚ç‚¹æŒ–çŸ¿ 1ï¼‰æŒ–çŸ¿åªæŒ–æ°´æœ docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit --election console 2ï¼‰æŒ–çŸ¿æ°´æœå’ŒåŒºå— docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --election console 1.2 éå‚ä¸å§”å‘˜ä¼šç«é€‰èŠ‚ç‚¹æŒ–çŸ¿ 1ï¼‰æŒ–çŸ¿åªæŒ–æ°´æœ docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit console 2ï¼‰æŒ–çŸ¿æ°´æœå’ŒåŒºå— docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine console 1.3 å¯åŠ¨å‘½ä»¤è§£æ -p å°†å®¹å™¨ä¸­çš„ç«¯å£æ˜ å°„åˆ°å®¿ä¸»æœº â€“datadir æ•°æ®å­˜å‚¨çš„æ–‡ä»¶å¤¹ â€“minefruit æŒ‡å®šæŒ–çŸ¿åªæŒ–æ°´æœ â€“election æœ¬èŠ‚ç‚¹å‚ä¸å§”å‘˜ä¼šç«é€‰ 2 FPOWæœºåˆ¶æŒ–çŸ¿ 2.1 æŒ–çŸ¿æµç¨‹ åˆé“¾é‡‡ç”¨äº†æ°´æœé“¾ï¼ˆFruitChainï¼‰çš„è®¾è®¡æ¥ä¿è¯åœ¨æŒ–çŸ¿è¿‡ç¨‹ä¸­æ‰€æœ‰å‚ä¸è€…çš„å…¬å¹³æ€§ã€‚è¿™æ˜¯ä¸€ç§å…¨æ–°çš„è®¾è®¡æŒ–çŸ¿çš„è®¾è®¡ç†å¿µï¼Œç§°ä¹‹ä¸ºFPOWã€‚è¿™ç§è®¾è®¡æœ‰æ•ˆçš„è§£å†³äº†ç®—åŠ›å·®è·å¯¼è‡´çš„å°ç®—åŠ›çŸ¿å·¥æŒ–ä¸åˆ°çŸ¿çš„ä¸è¶³ï¼Œä¿è¯äº†æ‰€æœ‰çŸ¿å·¥çš„å…¬å¹³æ€§ï¼Œå› ä¸ºåœ¨æŒ–çŸ¿è¿‡ç¨‹ä¸­æŒ–åˆ°ç›¸å¯¹ç®€å•çš„æ°´æœï¼ˆfruitï¼‰ä¹Ÿæ˜¯æœ‰å¥–åŠ±çš„ã€‚æŒ–åˆ°çš„æ°´æœç§°ä¹‹ä¸ºæ°´æœé“¾ï¼ˆFruitChainï¼‰ã€‚å…¶å¤§è‡´çš„æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ 2.2 ä»£ç å®ç° ä¸Šå›¾æµç¨‹ä¸­çš„ä»£ç å®ç°æˆ‘ä»¬å¯ä»¥ä»æºç çš„truechain-engineering-code/miner/worker.goä¸­æ‰¾åˆ°ã€‚ block := result.Block //work := result.Work if block.IsFruit() { if block.FastNumber() == nil { // if it does&#39;t include a fast block signs, it&#39;s not a fruit continue } if block.FastNumber().Cmp(common.Big0) == 0 { continue } //log.Info(&quot;ğŸ’ â€”-------mined fruit&quot;,&quot; FB NUMBER&quot;,block.FastNumber()) // add fruit once if self.FastBlockNumber != nil{ if self.FastBlockNumber.Cmp(block.FastNumber()) !=0 { log.Info(&quot;ğŸ’ ----mined fruit 1&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) //log.Info(&quot;not same fruits&quot;) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } }else{ log.Info(&quot;ğŸ’ ----mined fruit 2&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } // make sure the fast number has been fruit self.FastBlockNumber.SetUint64(block.FastNumber().Uint64()) // only have fast block not fruits we need commit new work if self.current.fruits == nil{ self.atCommintNewWoker = false // post msg for commitnew work var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) self.chain.PostChainEvents(events) } } else { if block.Fruits() == nil{ self.atCommintNewWoker = false continue } fruits := block.Fruits() log.Info(&quot;+++++ mined block --- &quot;,&quot;block number&quot;,block.Number(), &quot;fruits&quot;, len(fruits), &quot;first&quot;, fruits[0].FastNumber(), &quot;end&quot;, fruits[len(fruits) - 1].FastNumber()) stat, err := self.chain.WriteCanonicalBlock(block) if err != nil { log.Error(&quot;Failed writing block to chain&quot;, &quot;err&quot;, err) continue } // Broadcast the block and announce chain insertion event self.mux.Post(chain.NewMinedBlockEvent{Block: block}) var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) if stat == chain.CanonStatTy { events = append(events, chain.ChainEvent{Block: block, Hash: block.Hash()}) events = append(events, chain.ChainHeadEvent{Block: block}) } self.chain.PostChainEvents(events) // Insert the block into the set of pending ones to wait for confirmations self.unconfirmed.Insert(block.NumberU64(), block.Hash()) self.atCommintNewWoker = false } block := result.Blockï¼šé¦–å…ˆè·å–åˆ°ç»“æœä¸­çš„blockï¼ˆå§‘ä¸”å…ˆå«ä»–blockï¼Œåº”ä¸ºä»–è¿˜æœ‰å¯èƒ½åªæ˜¯ä¸€ä¸ªæ°´æœè€Œä¸æ˜¯å—ï¼‰ã€‚ é€šè¿‡block.IsFruit()æ–¹æ³•åˆ¤æ–­æ­¤blockæ˜¯å¦æ˜¯æ°´æœï¼ˆfruitï¼‰ï¼Œå¦‚æœè¿”å›trueçš„è¯ï¼Œè¿›å…¥æ–¹æ³•ä½“ï¼Œæ‰§è¡Œæ°´æœçš„æ“ä½œï¼Œåä¹‹ï¼Œæ‰§è¡Œå—çš„æ“ä½œã€‚ block.IsFruit()è¿”å›trueã€‚é€šè¿‡self.etrue.SnailPool().AddRemoteFruits(newFruits)å°†è¯¥blockæ·»åŠ åˆ°æ°´æœæ± ï¼ˆsnailpoolï¼‰ä¸­ã€‚ block.IsFruit()è¿”å›false,å¹¶ä¸”è¯¥blockä¸­å«æœ‰fruitï¼Œé‚£ä¹ˆæäº¤å§”å‘˜ä¼šç¡®è®¤å°±å¯ä»¥æ‰§è¡Œä¸Šé“¾æ“ä½œäº†ï¼Œself.chain.WriteCanonicalBlock(block)ã€‚ 2.3 æ°´æœæ–°é²œåº¦ç¡®è®¤ åˆé“¾é€šè¿‡fPOWæœºåˆ¶å¯ä»¥å¾ˆæœ‰æ•ˆçš„é¿å…è‡ªç§æŒ–çŸ¿ï¼Œå…¶åŸç†å°±æ˜¯ç»™æ°´æœèµ‹äºˆæ–°é²œåº¦çš„æ¦‚å¿µã€‚å¦‚æœä¸€ä¸ªè‡ªç§çš„çŸ¿å·¥åœ¨æŒ–åˆ°å—ä¹‹åä¸æäº¤å§”å‘˜ä¼šç¡®è®¤ï¼Œè‡ªå·±æƒ³å†æŒ–åˆ°æ›´é•¿çš„é“¾ä¹‹åå†å¹¿æ’­çš„è¯ï¼Œé‚£ä¹ˆï¼Œå¯¹ä¸èµ·ï¼Œä¹‹å‰æŒ–åˆ°çš„æ°´æœå¾ˆå¯èƒ½å°±å·²ç»è¿‡æœŸäº†ï¼Œé‚£ä¹ˆä¹‹å‰æ²¡å¹¿æ’­çš„é“¾ä¹Ÿå°±ä½œåºŸäº†ã€‚æ‰€ä»¥çŸ¿å·¥ä¼šé¿å…æ°´æœè¿‡æœŸè€ŒåŠæ—¶æŠŠè‡ªå·±æŒ–åˆ°çš„å—æäº¤å§”å‘˜ä¼šç¡®è®¤å¹¶ä¸Šé“¾ï¼Œä»è€Œæœ‰æ•ˆçš„é¿å…è‡ªç§æŒ–çŸ¿ã€‚ä¸‹é¢æ˜¯æ°´æœæ–°é²œåº¦ç¡®è®¤çš„ä»£ç å®ç°ã€‚æˆªå–è‡ªtruechain-engineering-code/consensus/minerva/consensus.goã€‚ func (m *Minerva) VerifyFreshness(fruit, block *types.SnailHeader) error { var headerNumber *big.Int if block == nil { // when block is nil, is used to verify new fruits for next block headerNumber = new(big.Int).Add(m.sbc.CurrentHeader().Number, common.Big1) } else { headerNumber = block.Number } // check freshness pointer := m.sbc.GetHeaderByNumber(fruit.PointerNumber.Uint64()) if pointer == nil { return types.ErrSnailHeightNotYet } if pointer.Hash() != fruit.PointerHash { log.Debug(&quot;VerifyFreshness get pointer failed.&quot;, &quot;fruit&quot;, fruit.FastNumber, &quot;pointerNumber&quot;, fruit.PointerNumber, &quot;pointerHash&quot;, fruit.PointerHash, &quot;fruitNumber&quot;, fruit.Number, &quot;pointer&quot;, pointer.Hash()) return consensus.ErrUnknownPointer } freshNumber := new(big.Int).Sub(headerNumber, pointer.Number) if freshNumber.Cmp(params.FruitFreshness) &gt; 0 { log.Debug(&quot;VerifyFreshness failed.&quot;, &quot;fruit sb&quot;, fruit.Number, &quot;fruit fb&quot;, fruit.FastNumber, &quot;poiner&quot;, pointer.Number, &quot;current&quot;, headerNumber) return consensus.ErrFreshness } return nil } ä»ä¸Šé¢çš„ä»£ç å—ä¸­å¯çŸ¥ï¼Œæ°´æœçš„hashå’ŒæŒ‡é’ˆçš„hashå€¼ä¸ç›¸ç­‰ä»¥åŠæ°´æœæ–°é²œåº¦å€¼å¤§äºè®¾ç½®çš„æ–°é²œå€¼çš„æ—¶å€™ï¼Œå‡ä¼šè¿”å›VerifyFreshness failedï¼Œå³è¯¥æ°´æœå·²ç»è¿‡æœŸäº†ã€‚ 2.4 æŒ–çŸ¿å¥–åŠ±åˆ†é… æˆ‘ä»¬è¯´fPOWæœºåˆ¶å¯¹æ‰€æœ‰çš„çŸ¿å·¥éƒ½æ˜¯å…¬å¹³çš„ï¼Œä¸ä¼šå› ä¸ºæ™®é€šçŸ¿å·¥çš„ç®—åŠ›ä¸å¤Ÿè€ŒæŒ–ä¸åˆ°å—å¯¼è‡´å¾—ä¸åˆ°å¥–åŠ±ï¼Œå› ä¸ºå°±ç®—ä½ ç®—åŠ›ä¸å¤Ÿï¼ŒæŒ–åˆ°æ°´æœçš„æ¦‚ç‡è¿˜æ˜¯æ¯”è¾ƒé«˜çš„ã€‚é‚£ä¹ˆï¼Œè¿™ä¸ªå¥–åŠ±æ˜¯æ€ä¹ˆåˆ†é…çš„å‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹åˆ†é…çš„ä»£ç ã€‚ // AccumulateRewardsFast credits the coinbase of the given block with the mining // reward. The total reward consists of the static block reward and rewards for // included uncles. The coinbase of each uncle block is also rewarded. func accumulateRewardsFast(election consensus.CommitteeElection, state *state.StateDB, header *types.Header, sBlock *types.SnailBlock) error { committeeCoin, minerCoin, minerFruitCoin, e := getBlockReward(header.Number) if e != nil { return e } //miner&#39;s award state.AddBalance(sBlock.Coinbase(), minerCoin) LogPrint(&quot;miner&#39;s award&quot;, sBlock.Coinbase(), minerCoin) //miner fruit award blockFruits := sBlock.Body().Fruits blockFruitsLen := big.NewInt(int64(len(blockFruits))) if len(blockFruits) &gt; 0 { minerFruitCoinOne := new(big.Int).Div(minerFruitCoin, blockFruitsLen) for _, v := range sBlock.Body().Fruits { state.AddBalance(v.Coinbase(), minerFruitCoinOne) LogPrint(&quot;minerFruit&quot;, v.Coinbase(), minerFruitCoinOne) } } else { return consensus.ErrInvalidBlock } //committee&#39;s award committeeCoinFruit := new(big.Int).Div(committeeCoin, blockFruitsLen) //all fail committee coinBase failAddr := make(map[common.Address]bool) for _, fruit := range blockFruits { signs := fruit.Body().Signs committeeMembers, errs := election.VerifySigns(signs) if len(committeeMembers) != len(errs) { return consensus.ErrInvalidSignsLength } //Effective and not evil var fruitOkAddr []common.Address for i, cm := range committeeMembers { if errs[i] != nil { continue } cmPubAddr := crypto.PubkeyToAddress(*cm.Publickey) if signs[i].Result == types.VoteAgree { if _, ok := failAddr[cmPubAddr]; !ok { fruitOkAddr = append(fruitOkAddr, cm.Coinbase) } } else { failAddr[cmPubAddr] = false } } if len(fruitOkAddr) == 0 { log.Error(&quot;fruitOkAddr&quot;, &quot;Error&quot;, consensus.ErrInvalidSignsLength.Error()) return nil } // Equal by fruit committeeCoinFruitMember := new(big.Int).Div(committeeCoinFruit, big.NewInt(int64(len(fruitOkAddr)))) for _, v := range fruitOkAddr { state.AddBalance(v, committeeCoinFruitMember) LogPrint(&quot;committee&quot;, v, committeeCoinFruitMember) } } return nil } ä»ä¸Šé¢è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æŒ–çŸ¿å¥–åŠ±æ˜¯åˆ†é…ç»™ä¸‰æ–¹çš„ï¼Œåˆ†åˆ«æ˜¯ï¼š åŒºå—çŸ¿å·¥ æ°´æœçŸ¿å·¥ å§”å‘˜ä¼š ä¹Ÿè®¸æœ‰äººä¼šé—®å•¦ï¼Œå¦‚æœåŒºå—ä¸åŒ…å«æ°´æœï¼Œæ˜¯ä¸æ˜¯å°±åªè¦åˆ†ç»™åŒºå—çŸ¿å·¥å’Œå§”å‘˜ä¼šä¸¤æ–¹å°±å¯ä»¥å•¦ï¼Œç­”æ¡ˆæ˜¯å¦å®šçš„ï¼Œå¦‚æœè¿™ä¸ªåŒºå—ä¸åŒ…å«æ°´æœï¼ˆlen(sBlock.Body().Fruits)&lt;=0ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªå—æ˜¯ä¸åˆæ³•çš„ï¼ˆErrInvalidBlockï¼‰ã€‚ åˆ†é…æµç¨‹ä¸ºï¼š è®¡ç®—åŒºå—çš„å¥–åŠ±ï¼ŒgetBlockRewardï¼ˆï¼‰ è®¡ç®—åŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥ï¼Œå§”å‘˜ä¼šåˆ†åˆ«åº”å¾—çš„å¥–åŠ± ç»™åŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥ï¼Œç­¾åçš„å§”å‘˜ä¼šæˆå‘˜åˆ†å‘å¥–åŠ±ã€‚ 3 æ€»ç»“ åˆé“¾ä½¿ç”¨äº†fPOWæœºåˆ¶ï¼Œè¿™ç§è®¾è®¡æœ‰æ•ˆçš„è§£å†³äº†ç®—åŠ›å·®è·å¯¼è‡´çš„å°ç®—åŠ›çŸ¿å·¥æŒ–ä¸åˆ°çŸ¿çš„ä¸è¶³ï¼Œä¿è¯äº†æ‰€æœ‰çŸ¿å·¥çš„å…¬å¹³æ€§ã€‚è¿™ç§æœºåˆ¶çš„å‡ºçŸ¿æµç¨‹æ˜¯çŸ¿å·¥æŒ–åˆ°çŸ¿ååˆ¤æ–­æ˜¯å—è¿˜æ˜¯æ°´æœï¼ŒçŸ¿å·¥æŒ–åˆ°æ°´æœåï¼Œä¼šå°†æ°´æœæ”¾åˆ°ä¸€ä¸ªæ°´æœæ± ï¼ˆfruit poolï¼‰ä¸­ï¼Œå¾…åˆ°æŒ–åˆ°å—ï¼ˆblockï¼‰åï¼Œä¾¿ä»æ°´æœæ± ä¸­å–å‡ºæ°´æœæ”¾ç½®åœ¨åŒºå—ä¸­ï¼ŒåŒºå—è¿›å…¥å§”å‘˜ä¼šè¿›è¡Œç¡®è®¤ï¼Œè¾¾æˆå…±è¯†å°±ä¸Šé“¾ã€‚ä¸Šé“¾ååŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥åŠç­¾åçš„å§”å‘˜ä¼šæˆå‘˜éƒ½èƒ½åˆ†åˆ°è¯¥åŒºå—çš„å¥–åŠ±ã€‚ é˜…è¯»æ›´å¤š" />
<meta property="og:site_name" content="æœ‰ç»„ç»‡åœ¨ï¼" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-10-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"åˆé“¾ä¸»ç½‘Betaç‰ˆäºæ–°åŠ å¡æ—¶é—´2018å¹´09æœˆ28æ—¥08:00æ­£å¼ä¸Šçº¿ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œ07:56åˆ†PBFTå§”å‘˜ä¼šç¬¬ä¸€æ¬¡å…±è¯†å‡ºå—å’ŒTrueChain fPOWåˆ›ä¸–åŒºå—è¢«æŒ–å‡ºã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥è°ˆè°ˆæ…¢é“¾çš„å‡ºçŸ¿ã€‚ 1 å¯åŠ¨èŠ‚ç‚¹è‡ªåŠ¨æŒ–çŸ¿ æœ¬å¸–ä»¥dockeræŒ–çŸ¿ä¸ºä¾‹ï¼Œè¯¦ç»†æ“ä½œè§dockerç‰ˆæŒ–çŸ¿æ•™ç¨‹ ã€‚èŠ‚ç‚¹å¯åŠ¨åˆ†ä¸ºå‚ä¸å‚åŠ å§”å‘˜ä¼šç«é€‰æŒ–çŸ¿ã€‚ 1.1 å‚ä¸å§”å‘˜ä¼šç«é€‰èŠ‚ç‚¹æŒ–çŸ¿ 1ï¼‰æŒ–çŸ¿åªæŒ–æ°´æœ docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit --election console 2ï¼‰æŒ–çŸ¿æ°´æœå’ŒåŒºå— docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --election console 1.2 éå‚ä¸å§”å‘˜ä¼šç«é€‰èŠ‚ç‚¹æŒ–çŸ¿ 1ï¼‰æŒ–çŸ¿åªæŒ–æ°´æœ docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit console 2ï¼‰æŒ–çŸ¿æ°´æœå’ŒåŒºå— docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine console 1.3 å¯åŠ¨å‘½ä»¤è§£æ -p å°†å®¹å™¨ä¸­çš„ç«¯å£æ˜ å°„åˆ°å®¿ä¸»æœº â€“datadir æ•°æ®å­˜å‚¨çš„æ–‡ä»¶å¤¹ â€“minefruit æŒ‡å®šæŒ–çŸ¿åªæŒ–æ°´æœ â€“election æœ¬èŠ‚ç‚¹å‚ä¸å§”å‘˜ä¼šç«é€‰ 2 FPOWæœºåˆ¶æŒ–çŸ¿ 2.1 æŒ–çŸ¿æµç¨‹ åˆé“¾é‡‡ç”¨äº†æ°´æœé“¾ï¼ˆFruitChainï¼‰çš„è®¾è®¡æ¥ä¿è¯åœ¨æŒ–çŸ¿è¿‡ç¨‹ä¸­æ‰€æœ‰å‚ä¸è€…çš„å…¬å¹³æ€§ã€‚è¿™æ˜¯ä¸€ç§å…¨æ–°çš„è®¾è®¡æŒ–çŸ¿çš„è®¾è®¡ç†å¿µï¼Œç§°ä¹‹ä¸ºFPOWã€‚è¿™ç§è®¾è®¡æœ‰æ•ˆçš„è§£å†³äº†ç®—åŠ›å·®è·å¯¼è‡´çš„å°ç®—åŠ›çŸ¿å·¥æŒ–ä¸åˆ°çŸ¿çš„ä¸è¶³ï¼Œä¿è¯äº†æ‰€æœ‰çŸ¿å·¥çš„å…¬å¹³æ€§ï¼Œå› ä¸ºåœ¨æŒ–çŸ¿è¿‡ç¨‹ä¸­æŒ–åˆ°ç›¸å¯¹ç®€å•çš„æ°´æœï¼ˆfruitï¼‰ä¹Ÿæ˜¯æœ‰å¥–åŠ±çš„ã€‚æŒ–åˆ°çš„æ°´æœç§°ä¹‹ä¸ºæ°´æœé“¾ï¼ˆFruitChainï¼‰ã€‚å…¶å¤§è‡´çš„æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ 2.2 ä»£ç å®ç° ä¸Šå›¾æµç¨‹ä¸­çš„ä»£ç å®ç°æˆ‘ä»¬å¯ä»¥ä»æºç çš„truechain-engineering-code/miner/worker.goä¸­æ‰¾åˆ°ã€‚ block := result.Block //work := result.Work if block.IsFruit() { if block.FastNumber() == nil { // if it does&#39;t include a fast block signs, it&#39;s not a fruit continue } if block.FastNumber().Cmp(common.Big0) == 0 { continue } //log.Info(&quot;ğŸ’ â€”-------mined fruit&quot;,&quot; FB NUMBER&quot;,block.FastNumber()) // add fruit once if self.FastBlockNumber != nil{ if self.FastBlockNumber.Cmp(block.FastNumber()) !=0 { log.Info(&quot;ğŸ’ ----mined fruit 1&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) //log.Info(&quot;not same fruits&quot;) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } }else{ log.Info(&quot;ğŸ’ ----mined fruit 2&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } // make sure the fast number has been fruit self.FastBlockNumber.SetUint64(block.FastNumber().Uint64()) // only have fast block not fruits we need commit new work if self.current.fruits == nil{ self.atCommintNewWoker = false // post msg for commitnew work var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) self.chain.PostChainEvents(events) } } else { if block.Fruits() == nil{ self.atCommintNewWoker = false continue } fruits := block.Fruits() log.Info(&quot;+++++ mined block --- &quot;,&quot;block number&quot;,block.Number(), &quot;fruits&quot;, len(fruits), &quot;first&quot;, fruits[0].FastNumber(), &quot;end&quot;, fruits[len(fruits) - 1].FastNumber()) stat, err := self.chain.WriteCanonicalBlock(block) if err != nil { log.Error(&quot;Failed writing block to chain&quot;, &quot;err&quot;, err) continue } // Broadcast the block and announce chain insertion event self.mux.Post(chain.NewMinedBlockEvent{Block: block}) var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) if stat == chain.CanonStatTy { events = append(events, chain.ChainEvent{Block: block, Hash: block.Hash()}) events = append(events, chain.ChainHeadEvent{Block: block}) } self.chain.PostChainEvents(events) // Insert the block into the set of pending ones to wait for confirmations self.unconfirmed.Insert(block.NumberU64(), block.Hash()) self.atCommintNewWoker = false } block := result.Blockï¼šé¦–å…ˆè·å–åˆ°ç»“æœä¸­çš„blockï¼ˆå§‘ä¸”å…ˆå«ä»–blockï¼Œåº”ä¸ºä»–è¿˜æœ‰å¯èƒ½åªæ˜¯ä¸€ä¸ªæ°´æœè€Œä¸æ˜¯å—ï¼‰ã€‚ é€šè¿‡block.IsFruit()æ–¹æ³•åˆ¤æ–­æ­¤blockæ˜¯å¦æ˜¯æ°´æœï¼ˆfruitï¼‰ï¼Œå¦‚æœè¿”å›trueçš„è¯ï¼Œè¿›å…¥æ–¹æ³•ä½“ï¼Œæ‰§è¡Œæ°´æœçš„æ“ä½œï¼Œåä¹‹ï¼Œæ‰§è¡Œå—çš„æ“ä½œã€‚ block.IsFruit()è¿”å›trueã€‚é€šè¿‡self.etrue.SnailPool().AddRemoteFruits(newFruits)å°†è¯¥blockæ·»åŠ åˆ°æ°´æœæ± ï¼ˆsnailpoolï¼‰ä¸­ã€‚ block.IsFruit()è¿”å›false,å¹¶ä¸”è¯¥blockä¸­å«æœ‰fruitï¼Œé‚£ä¹ˆæäº¤å§”å‘˜ä¼šç¡®è®¤å°±å¯ä»¥æ‰§è¡Œä¸Šé“¾æ“ä½œäº†ï¼Œself.chain.WriteCanonicalBlock(block)ã€‚ 2.3 æ°´æœæ–°é²œåº¦ç¡®è®¤ åˆé“¾é€šè¿‡fPOWæœºåˆ¶å¯ä»¥å¾ˆæœ‰æ•ˆçš„é¿å…è‡ªç§æŒ–çŸ¿ï¼Œå…¶åŸç†å°±æ˜¯ç»™æ°´æœèµ‹äºˆæ–°é²œåº¦çš„æ¦‚å¿µã€‚å¦‚æœä¸€ä¸ªè‡ªç§çš„çŸ¿å·¥åœ¨æŒ–åˆ°å—ä¹‹åä¸æäº¤å§”å‘˜ä¼šç¡®è®¤ï¼Œè‡ªå·±æƒ³å†æŒ–åˆ°æ›´é•¿çš„é“¾ä¹‹åå†å¹¿æ’­çš„è¯ï¼Œé‚£ä¹ˆï¼Œå¯¹ä¸èµ·ï¼Œä¹‹å‰æŒ–åˆ°çš„æ°´æœå¾ˆå¯èƒ½å°±å·²ç»è¿‡æœŸäº†ï¼Œé‚£ä¹ˆä¹‹å‰æ²¡å¹¿æ’­çš„é“¾ä¹Ÿå°±ä½œåºŸäº†ã€‚æ‰€ä»¥çŸ¿å·¥ä¼šé¿å…æ°´æœè¿‡æœŸè€ŒåŠæ—¶æŠŠè‡ªå·±æŒ–åˆ°çš„å—æäº¤å§”å‘˜ä¼šç¡®è®¤å¹¶ä¸Šé“¾ï¼Œä»è€Œæœ‰æ•ˆçš„é¿å…è‡ªç§æŒ–çŸ¿ã€‚ä¸‹é¢æ˜¯æ°´æœæ–°é²œåº¦ç¡®è®¤çš„ä»£ç å®ç°ã€‚æˆªå–è‡ªtruechain-engineering-code/consensus/minerva/consensus.goã€‚ func (m *Minerva) VerifyFreshness(fruit, block *types.SnailHeader) error { var headerNumber *big.Int if block == nil { // when block is nil, is used to verify new fruits for next block headerNumber = new(big.Int).Add(m.sbc.CurrentHeader().Number, common.Big1) } else { headerNumber = block.Number } // check freshness pointer := m.sbc.GetHeaderByNumber(fruit.PointerNumber.Uint64()) if pointer == nil { return types.ErrSnailHeightNotYet } if pointer.Hash() != fruit.PointerHash { log.Debug(&quot;VerifyFreshness get pointer failed.&quot;, &quot;fruit&quot;, fruit.FastNumber, &quot;pointerNumber&quot;, fruit.PointerNumber, &quot;pointerHash&quot;, fruit.PointerHash, &quot;fruitNumber&quot;, fruit.Number, &quot;pointer&quot;, pointer.Hash()) return consensus.ErrUnknownPointer } freshNumber := new(big.Int).Sub(headerNumber, pointer.Number) if freshNumber.Cmp(params.FruitFreshness) &gt; 0 { log.Debug(&quot;VerifyFreshness failed.&quot;, &quot;fruit sb&quot;, fruit.Number, &quot;fruit fb&quot;, fruit.FastNumber, &quot;poiner&quot;, pointer.Number, &quot;current&quot;, headerNumber) return consensus.ErrFreshness } return nil } ä»ä¸Šé¢çš„ä»£ç å—ä¸­å¯çŸ¥ï¼Œæ°´æœçš„hashå’ŒæŒ‡é’ˆçš„hashå€¼ä¸ç›¸ç­‰ä»¥åŠæ°´æœæ–°é²œåº¦å€¼å¤§äºè®¾ç½®çš„æ–°é²œå€¼çš„æ—¶å€™ï¼Œå‡ä¼šè¿”å›VerifyFreshness failedï¼Œå³è¯¥æ°´æœå·²ç»è¿‡æœŸäº†ã€‚ 2.4 æŒ–çŸ¿å¥–åŠ±åˆ†é… æˆ‘ä»¬è¯´fPOWæœºåˆ¶å¯¹æ‰€æœ‰çš„çŸ¿å·¥éƒ½æ˜¯å…¬å¹³çš„ï¼Œä¸ä¼šå› ä¸ºæ™®é€šçŸ¿å·¥çš„ç®—åŠ›ä¸å¤Ÿè€ŒæŒ–ä¸åˆ°å—å¯¼è‡´å¾—ä¸åˆ°å¥–åŠ±ï¼Œå› ä¸ºå°±ç®—ä½ ç®—åŠ›ä¸å¤Ÿï¼ŒæŒ–åˆ°æ°´æœçš„æ¦‚ç‡è¿˜æ˜¯æ¯”è¾ƒé«˜çš„ã€‚é‚£ä¹ˆï¼Œè¿™ä¸ªå¥–åŠ±æ˜¯æ€ä¹ˆåˆ†é…çš„å‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹åˆ†é…çš„ä»£ç ã€‚ // AccumulateRewardsFast credits the coinbase of the given block with the mining // reward. The total reward consists of the static block reward and rewards for // included uncles. The coinbase of each uncle block is also rewarded. func accumulateRewardsFast(election consensus.CommitteeElection, state *state.StateDB, header *types.Header, sBlock *types.SnailBlock) error { committeeCoin, minerCoin, minerFruitCoin, e := getBlockReward(header.Number) if e != nil { return e } //miner&#39;s award state.AddBalance(sBlock.Coinbase(), minerCoin) LogPrint(&quot;miner&#39;s award&quot;, sBlock.Coinbase(), minerCoin) //miner fruit award blockFruits := sBlock.Body().Fruits blockFruitsLen := big.NewInt(int64(len(blockFruits))) if len(blockFruits) &gt; 0 { minerFruitCoinOne := new(big.Int).Div(minerFruitCoin, blockFruitsLen) for _, v := range sBlock.Body().Fruits { state.AddBalance(v.Coinbase(), minerFruitCoinOne) LogPrint(&quot;minerFruit&quot;, v.Coinbase(), minerFruitCoinOne) } } else { return consensus.ErrInvalidBlock } //committee&#39;s award committeeCoinFruit := new(big.Int).Div(committeeCoin, blockFruitsLen) //all fail committee coinBase failAddr := make(map[common.Address]bool) for _, fruit := range blockFruits { signs := fruit.Body().Signs committeeMembers, errs := election.VerifySigns(signs) if len(committeeMembers) != len(errs) { return consensus.ErrInvalidSignsLength } //Effective and not evil var fruitOkAddr []common.Address for i, cm := range committeeMembers { if errs[i] != nil { continue } cmPubAddr := crypto.PubkeyToAddress(*cm.Publickey) if signs[i].Result == types.VoteAgree { if _, ok := failAddr[cmPubAddr]; !ok { fruitOkAddr = append(fruitOkAddr, cm.Coinbase) } } else { failAddr[cmPubAddr] = false } } if len(fruitOkAddr) == 0 { log.Error(&quot;fruitOkAddr&quot;, &quot;Error&quot;, consensus.ErrInvalidSignsLength.Error()) return nil } // Equal by fruit committeeCoinFruitMember := new(big.Int).Div(committeeCoinFruit, big.NewInt(int64(len(fruitOkAddr)))) for _, v := range fruitOkAddr { state.AddBalance(v, committeeCoinFruitMember) LogPrint(&quot;committee&quot;, v, committeeCoinFruitMember) } } return nil } ä»ä¸Šé¢è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æŒ–çŸ¿å¥–åŠ±æ˜¯åˆ†é…ç»™ä¸‰æ–¹çš„ï¼Œåˆ†åˆ«æ˜¯ï¼š åŒºå—çŸ¿å·¥ æ°´æœçŸ¿å·¥ å§”å‘˜ä¼š ä¹Ÿè®¸æœ‰äººä¼šé—®å•¦ï¼Œå¦‚æœåŒºå—ä¸åŒ…å«æ°´æœï¼Œæ˜¯ä¸æ˜¯å°±åªè¦åˆ†ç»™åŒºå—çŸ¿å·¥å’Œå§”å‘˜ä¼šä¸¤æ–¹å°±å¯ä»¥å•¦ï¼Œç­”æ¡ˆæ˜¯å¦å®šçš„ï¼Œå¦‚æœè¿™ä¸ªåŒºå—ä¸åŒ…å«æ°´æœï¼ˆlen(sBlock.Body().Fruits)&lt;=0ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªå—æ˜¯ä¸åˆæ³•çš„ï¼ˆErrInvalidBlockï¼‰ã€‚ åˆ†é…æµç¨‹ä¸ºï¼š è®¡ç®—åŒºå—çš„å¥–åŠ±ï¼ŒgetBlockRewardï¼ˆï¼‰ è®¡ç®—åŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥ï¼Œå§”å‘˜ä¼šåˆ†åˆ«åº”å¾—çš„å¥–åŠ± ç»™åŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥ï¼Œç­¾åçš„å§”å‘˜ä¼šæˆå‘˜åˆ†å‘å¥–åŠ±ã€‚ 3 æ€»ç»“ åˆé“¾ä½¿ç”¨äº†fPOWæœºåˆ¶ï¼Œè¿™ç§è®¾è®¡æœ‰æ•ˆçš„è§£å†³äº†ç®—åŠ›å·®è·å¯¼è‡´çš„å°ç®—åŠ›çŸ¿å·¥æŒ–ä¸åˆ°çŸ¿çš„ä¸è¶³ï¼Œä¿è¯äº†æ‰€æœ‰çŸ¿å·¥çš„å…¬å¹³æ€§ã€‚è¿™ç§æœºåˆ¶çš„å‡ºçŸ¿æµç¨‹æ˜¯çŸ¿å·¥æŒ–åˆ°çŸ¿ååˆ¤æ–­æ˜¯å—è¿˜æ˜¯æ°´æœï¼ŒçŸ¿å·¥æŒ–åˆ°æ°´æœåï¼Œä¼šå°†æ°´æœæ”¾åˆ°ä¸€ä¸ªæ°´æœæ± ï¼ˆfruit poolï¼‰ä¸­ï¼Œå¾…åˆ°æŒ–åˆ°å—ï¼ˆblockï¼‰åï¼Œä¾¿ä»æ°´æœæ± ä¸­å–å‡ºæ°´æœæ”¾ç½®åœ¨åŒºå—ä¸­ï¼ŒåŒºå—è¿›å…¥å§”å‘˜ä¼šè¿›è¡Œç¡®è®¤ï¼Œè¾¾æˆå…±è¯†å°±ä¸Šé“¾ã€‚ä¸Šé“¾ååŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥åŠç­¾åçš„å§”å‘˜ä¼šæˆå‘˜éƒ½èƒ½åˆ†åˆ°è¯¥åŒºå—çš„å¥–åŠ±ã€‚ é˜…è¯»æ›´å¤š","@type":"BlogPosting","url":"/2018/10/20/f066d55d75eb37fb99060567bd1008fd.html","headline":"åˆé“¾ä¸»ç½‘Betaç‰ˆæ…¢é“¾æŒ–çŸ¿è§£æ","dateModified":"2018-10-20T00:00:00+08:00","datePublished":"2018-10-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/10/20/f066d55d75eb37fb99060567bd1008fd.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>åˆé“¾ä¸»ç½‘Betaç‰ˆæ…¢é“¾æŒ–çŸ¿è§£æ</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>æŸšå­ç¤¾åŒº</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart ç®­å¤´å›¾æ ‡ å‹¿åˆ  --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>åˆé“¾ä¸»ç½‘Betaç‰ˆäºæ–°åŠ å¡æ—¶é—´2018å¹´09æœˆ28æ—¥08:00æ­£å¼ä¸Šçº¿ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œ07:56åˆ†PBFTå§”å‘˜ä¼šç¬¬ä¸€æ¬¡å…±è¯†å‡ºå—å’ŒTrueChain fPOWåˆ›ä¸–åŒºå—è¢«æŒ–å‡ºã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥è°ˆè°ˆæ…¢é“¾çš„å‡ºçŸ¿ã€‚</p> 
  <h1><a id="1__2"></a>1 å¯åŠ¨èŠ‚ç‚¹è‡ªåŠ¨æŒ–çŸ¿</h1> 
  <p>æœ¬å¸–ä»¥dockeræŒ–çŸ¿ä¸ºä¾‹ï¼Œè¯¦ç»†æ“ä½œè§<a href="https://www.truechain.pro/download/ming/ming-version-docker-zh.pdf" rel="nofollow">dockerç‰ˆæŒ–çŸ¿æ•™ç¨‹</a> ã€‚èŠ‚ç‚¹å¯åŠ¨åˆ†ä¸ºå‚ä¸å‚åŠ å§”å‘˜ä¼šç«é€‰æŒ–çŸ¿ã€‚</p> 
  <h2><a id="11__5"></a>1.1 å‚ä¸å§”å‘˜ä¼šç«é€‰èŠ‚ç‚¹æŒ–çŸ¿</h2> 
  <p>1ï¼‰æŒ–çŸ¿åªæŒ–æ°´æœ</p> 
  <pre><code>docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine  --minefruit --election console
</code></pre> 
  <p>2ï¼‰æŒ–çŸ¿æ°´æœå’ŒåŒºå—</p> 
  <pre><code>docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --election console
</code></pre> 
  <h2><a id="12__21"></a>1.2 éå‚ä¸å§”å‘˜ä¼šç«é€‰èŠ‚ç‚¹æŒ–çŸ¿</h2> 
  <p>1ï¼‰æŒ–çŸ¿åªæŒ–æ°´æœ</p> 
  <pre><code>docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit console
</code></pre> 
  <p>2ï¼‰æŒ–çŸ¿æ°´æœå’ŒåŒºå—</p> 
  <pre><code>docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine console
</code></pre> 
  <h2><a id="13__35"></a>1.3 å¯åŠ¨å‘½ä»¤è§£æ</h2> 
  <ul> 
   <li>-p å°†å®¹å™¨ä¸­çš„ç«¯å£æ˜ å°„åˆ°å®¿ä¸»æœº</li> 
   <li>â€“datadir æ•°æ®å­˜å‚¨çš„æ–‡ä»¶å¤¹</li> 
   <li>â€“minefruit æŒ‡å®šæŒ–çŸ¿åªæŒ–æ°´æœ</li> 
   <li>â€“election æœ¬èŠ‚ç‚¹å‚ä¸å§”å‘˜ä¼šç«é€‰</li> 
  </ul> 
  <h1><a id="2_FPOW_40"></a>2 FPOWæœºåˆ¶æŒ–çŸ¿</h1> 
  <h2><a id="21__41"></a>2.1 æŒ–çŸ¿æµç¨‹</h2> 
  <p>åˆé“¾é‡‡ç”¨äº†æ°´æœé“¾ï¼ˆFruitChainï¼‰çš„è®¾è®¡æ¥ä¿è¯åœ¨æŒ–çŸ¿è¿‡ç¨‹ä¸­æ‰€æœ‰å‚ä¸è€…çš„å…¬å¹³æ€§ã€‚è¿™æ˜¯ä¸€ç§å…¨æ–°çš„è®¾è®¡æŒ–çŸ¿çš„è®¾è®¡ç†å¿µï¼Œç§°ä¹‹ä¸ºFPOWã€‚è¿™ç§è®¾è®¡æœ‰æ•ˆçš„è§£å†³äº†ç®—åŠ›å·®è·å¯¼è‡´çš„å°ç®—åŠ›çŸ¿å·¥æŒ–ä¸åˆ°çŸ¿çš„ä¸è¶³ï¼Œä¿è¯äº†æ‰€æœ‰çŸ¿å·¥çš„å…¬å¹³æ€§ï¼Œå› ä¸ºåœ¨æŒ–çŸ¿è¿‡ç¨‹ä¸­æŒ–åˆ°ç›¸å¯¹ç®€å•çš„æ°´æœï¼ˆfruitï¼‰ä¹Ÿæ˜¯æœ‰å¥–åŠ±çš„ã€‚æŒ–åˆ°çš„æ°´æœç§°ä¹‹ä¸ºæ°´æœé“¾ï¼ˆFruitChainï¼‰ã€‚å…¶å¤§è‡´çš„æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚<br> <img src="https://note.youdao.com/yws/api/personal/file/3B1FD5637EE2445994D03CA9F69722D0?method=download&amp;shareKey=9848b2c33035eb895d3db80224f251ab" alt="image"></p> 
  <h2><a id="22__44"></a>2.2 ä»£ç å®ç°</h2> 
  <p>ä¸Šå›¾æµç¨‹ä¸­çš„ä»£ç å®ç°æˆ‘ä»¬å¯ä»¥ä»æºç çš„truechain-engineering-code/miner/worker.goä¸­æ‰¾åˆ°ã€‚</p> 
  <pre><code>block := result.Block
//work := result.Work

if block.IsFruit() {
	if block.FastNumber() == nil {
		// if it does't include a fast block signs, it's not a fruit
		continue
	}
	if block.FastNumber().Cmp(common.Big0) == 0 {
		continue
	}

	//log.Info("ğŸ’ â€”-------mined fruit"," FB NUMBER",block.FastNumber())

	// add fruit once
	if self.FastBlockNumber != nil{
		if self.FastBlockNumber.Cmp(block.FastNumber()) !=0 {
			log.Info("ğŸ’  ----mined fruit 1","number",block.FastNumber(), "diff", block.FruitDifficulty(), "hash", block.Hash(), "signs", len(block.Signs()))
			//log.Info("not same fruits")
			var newFruits []*types.SnailBlock
			newFruits = append(newFruits, block)
			self.etrue.SnailPool().AddRemoteFruits(newFruits)
		}
	}else{
		log.Info("ğŸ’ ----mined fruit 2","number",block.FastNumber(), "diff", block.FruitDifficulty(), "hash", block.Hash(), "signs", len(block.Signs()))
		var newFruits []*types.SnailBlock
		newFruits = append(newFruits, block)
		self.etrue.SnailPool().AddRemoteFruits(newFruits)
	}

	// make sure the fast number has been fruit
	self.FastBlockNumber.SetUint64(block.FastNumber().Uint64())

	// only have fast block not fruits we need commit new work
	if self.current.fruits == nil{
		self.atCommintNewWoker = false
		// post msg for commitnew work
		var (
			events []interface{}
		)
		events = append(events, chain.NewMinedEvent{Block: block})
		self.chain.PostChainEvents(events)
	}
} else {
	if block.Fruits() == nil{
		self.atCommintNewWoker = false
		continue
	}

	fruits := block.Fruits()
	log.Info("+++++ mined block  ---  ","block number",block.Number(), "fruits", len(fruits), "first", fruits[0].FastNumber(), "end", fruits[len(fruits) - 1].FastNumber())

	stat, err := self.chain.WriteCanonicalBlock(block)
	if err != nil {
		log.Error("Failed writing block to chain", "err", err)
		continue
	}

	// Broadcast the block and announce chain insertion event
	self.mux.Post(chain.NewMinedBlockEvent{Block: block})
	var (
		events []interface{}
	)

	events = append(events, chain.NewMinedEvent{Block: block})

	if stat == chain.CanonStatTy {
		events = append(events, chain.ChainEvent{Block: block, Hash: block.Hash()})
		events = append(events, chain.ChainHeadEvent{Block: block})
	}
	self.chain.PostChainEvents(events)

	// Insert the block into the set of pending ones to wait for confirmations
	self.unconfirmed.Insert(block.NumberU64(), block.Hash())

	self.atCommintNewWoker = false
}
</code></pre> 
  <ol> 
   <li>block := result.Blockï¼šé¦–å…ˆè·å–åˆ°ç»“æœä¸­çš„blockï¼ˆå§‘ä¸”å…ˆå«ä»–blockï¼Œåº”ä¸ºä»–è¿˜æœ‰å¯èƒ½åªæ˜¯ä¸€ä¸ªæ°´æœè€Œä¸æ˜¯å—ï¼‰ã€‚</li> 
   <li>é€šè¿‡block.IsFruit()æ–¹æ³•åˆ¤æ–­æ­¤blockæ˜¯å¦æ˜¯æ°´æœï¼ˆfruitï¼‰ï¼Œå¦‚æœè¿”å›trueçš„è¯ï¼Œè¿›å…¥æ–¹æ³•ä½“ï¼Œæ‰§è¡Œæ°´æœçš„æ“ä½œï¼Œåä¹‹ï¼Œæ‰§è¡Œå—çš„æ“ä½œã€‚</li> 
   <li>block.IsFruit()è¿”å›trueã€‚é€šè¿‡self.etrue.SnailPool().AddRemoteFruits(newFruits)å°†è¯¥blockæ·»åŠ åˆ°æ°´æœæ± ï¼ˆsnailpoolï¼‰ä¸­ã€‚</li> 
   <li>block.IsFruit()è¿”å›false,å¹¶ä¸”è¯¥blockä¸­å«æœ‰fruitï¼Œé‚£ä¹ˆæäº¤å§”å‘˜ä¼šç¡®è®¤å°±å¯ä»¥æ‰§è¡Œä¸Šé“¾æ“ä½œäº†ï¼Œself.chain.WriteCanonicalBlock(block)ã€‚</li> 
  </ol> 
  <h2><a id="23__130"></a>2.3 æ°´æœæ–°é²œåº¦ç¡®è®¤</h2> 
  <p>åˆé“¾é€šè¿‡fPOWæœºåˆ¶å¯ä»¥å¾ˆæœ‰æ•ˆçš„é¿å…è‡ªç§æŒ–çŸ¿ï¼Œå…¶åŸç†å°±æ˜¯ç»™æ°´æœèµ‹äºˆæ–°é²œåº¦çš„æ¦‚å¿µã€‚å¦‚æœä¸€ä¸ªè‡ªç§çš„çŸ¿å·¥åœ¨æŒ–åˆ°å—ä¹‹åä¸æäº¤å§”å‘˜ä¼šç¡®è®¤ï¼Œè‡ªå·±æƒ³å†æŒ–åˆ°æ›´é•¿çš„é“¾ä¹‹åå†å¹¿æ’­çš„è¯ï¼Œé‚£ä¹ˆï¼Œå¯¹ä¸èµ·ï¼Œä¹‹å‰æŒ–åˆ°çš„æ°´æœå¾ˆå¯èƒ½å°±å·²ç»è¿‡æœŸäº†ï¼Œé‚£ä¹ˆä¹‹å‰æ²¡å¹¿æ’­çš„é“¾ä¹Ÿå°±ä½œåºŸäº†ã€‚æ‰€ä»¥çŸ¿å·¥ä¼šé¿å…æ°´æœè¿‡æœŸè€ŒåŠæ—¶æŠŠè‡ªå·±æŒ–åˆ°çš„å—æäº¤å§”å‘˜ä¼šç¡®è®¤å¹¶ä¸Šé“¾ï¼Œä»è€Œæœ‰æ•ˆçš„é¿å…è‡ªç§æŒ–çŸ¿ã€‚ä¸‹é¢æ˜¯æ°´æœæ–°é²œåº¦ç¡®è®¤çš„ä»£ç å®ç°ã€‚æˆªå–è‡ªtruechain-engineering-code/consensus/minerva/consensus.goã€‚</p> 
  <pre><code>func (m *Minerva) VerifyFreshness(fruit, block *types.SnailHeader) error {
	var headerNumber *big.Int
	if block == nil {
		// when block is nil, is used to verify new fruits for next block
		headerNumber = new(big.Int).Add(m.sbc.CurrentHeader().Number, common.Big1)
	} else {
		headerNumber = block.Number
	}
	// check freshness
	pointer := m.sbc.GetHeaderByNumber(fruit.PointerNumber.Uint64())
	if pointer == nil {
		return types.ErrSnailHeightNotYet
	}
	if pointer.Hash() != fruit.PointerHash {
		log.Debug("VerifyFreshness get pointer failed.", "fruit", fruit.FastNumber, "pointerNumber", fruit.PointerNumber, "pointerHash", fruit.PointerHash,
			"fruitNumber", fruit.Number, "pointer", pointer.Hash())
		return consensus.ErrUnknownPointer
	}
	freshNumber := new(big.Int).Sub(headerNumber, pointer.Number)
	if freshNumber.Cmp(params.FruitFreshness) &gt; 0 {
		log.Debug("VerifyFreshness failed.", "fruit sb", fruit.Number, "fruit fb", fruit.FastNumber, "poiner", pointer.Number, "current", headerNumber)
		return consensus.ErrFreshness
	}

	return nil
}
</code></pre> 
  <p>ä»ä¸Šé¢çš„ä»£ç å—ä¸­å¯çŸ¥ï¼Œæ°´æœçš„hashå’ŒæŒ‡é’ˆçš„hashå€¼ä¸ç›¸ç­‰ä»¥åŠæ°´æœæ–°é²œåº¦å€¼å¤§äºè®¾ç½®çš„æ–°é²œå€¼çš„æ—¶å€™ï¼Œå‡ä¼šè¿”å›VerifyFreshness failedï¼Œå³è¯¥æ°´æœå·²ç»è¿‡æœŸäº†ã€‚</p> 
  <h2><a id="24__162"></a>2.4 æŒ–çŸ¿å¥–åŠ±åˆ†é…</h2> 
  <p>æˆ‘ä»¬è¯´fPOWæœºåˆ¶å¯¹æ‰€æœ‰çš„çŸ¿å·¥éƒ½æ˜¯å…¬å¹³çš„ï¼Œä¸ä¼šå› ä¸ºæ™®é€šçŸ¿å·¥çš„ç®—åŠ›ä¸å¤Ÿè€ŒæŒ–ä¸åˆ°å—å¯¼è‡´å¾—ä¸åˆ°å¥–åŠ±ï¼Œå› ä¸ºå°±ç®—ä½ ç®—åŠ›ä¸å¤Ÿï¼ŒæŒ–åˆ°æ°´æœçš„æ¦‚ç‡è¿˜æ˜¯æ¯”è¾ƒé«˜çš„ã€‚é‚£ä¹ˆï¼Œè¿™ä¸ªå¥–åŠ±æ˜¯æ€ä¹ˆåˆ†é…çš„å‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹åˆ†é…çš„ä»£ç ã€‚</p> 
  <pre><code>// AccumulateRewardsFast credits the coinbase of the given block with the mining
// reward. The total reward consists of the static block reward and rewards for
// included uncles. The coinbase of each uncle block is also rewarded.
func accumulateRewardsFast(election consensus.CommitteeElection, state *state.StateDB, header *types.Header, sBlock *types.SnailBlock) error {
	committeeCoin, minerCoin, minerFruitCoin, e := getBlockReward(header.Number)

	if e != nil {
		return e
	}

	//miner's award
	state.AddBalance(sBlock.Coinbase(), minerCoin)
	LogPrint("miner's award", sBlock.Coinbase(), minerCoin)

	//miner fruit award
	blockFruits := sBlock.Body().Fruits
	blockFruitsLen := big.NewInt(int64(len(blockFruits)))
	if len(blockFruits) &gt; 0 {
		minerFruitCoinOne := new(big.Int).Div(minerFruitCoin, blockFruitsLen)
		for _, v := range sBlock.Body().Fruits {
			state.AddBalance(v.Coinbase(), minerFruitCoinOne)
			LogPrint("minerFruit", v.Coinbase(), minerFruitCoinOne)
		}
	} else {
		return consensus.ErrInvalidBlock
	}

	//committee's award
	committeeCoinFruit := new(big.Int).Div(committeeCoin, blockFruitsLen)

	//all fail committee coinBase
	failAddr := make(map[common.Address]bool)

	for _, fruit := range blockFruits {
		signs := fruit.Body().Signs

		committeeMembers, errs := election.VerifySigns(signs)

		if len(committeeMembers) != len(errs) {
			return consensus.ErrInvalidSignsLength
		}

		//Effective and not evil
		var fruitOkAddr []common.Address
		for i, cm := range committeeMembers {
			if errs[i] != nil {
				continue
			}
			cmPubAddr := crypto.PubkeyToAddress(*cm.Publickey)

			if signs[i].Result == types.VoteAgree {
				if _, ok := failAddr[cmPubAddr]; !ok {
					fruitOkAddr = append(fruitOkAddr, cm.Coinbase)
				}
			} else {
				failAddr[cmPubAddr] = false
			}
		}

		if len(fruitOkAddr) == 0 {
			log.Error("fruitOkAddr", "Error", consensus.ErrInvalidSignsLength.Error())
			return nil
		}

		// Equal by fruit
		committeeCoinFruitMember := new(big.Int).Div(committeeCoinFruit, big.NewInt(int64(len(fruitOkAddr))))
		for _, v := range fruitOkAddr {
			state.AddBalance(v, committeeCoinFruitMember)
			LogPrint("committee", v, committeeCoinFruitMember)
		}
	}

	return nil
}
</code></pre> 
  <p>ä»ä¸Šé¢è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æŒ–çŸ¿å¥–åŠ±æ˜¯åˆ†é…ç»™ä¸‰æ–¹çš„ï¼Œåˆ†åˆ«æ˜¯ï¼š</p> 
  <ul> 
   <li>åŒºå—çŸ¿å·¥</li> 
   <li>æ°´æœçŸ¿å·¥</li> 
   <li>å§”å‘˜ä¼š</li> 
  </ul> 
  <p>ä¹Ÿè®¸æœ‰äººä¼šé—®å•¦ï¼Œå¦‚æœåŒºå—ä¸åŒ…å«æ°´æœï¼Œæ˜¯ä¸æ˜¯å°±åªè¦åˆ†ç»™åŒºå—çŸ¿å·¥å’Œå§”å‘˜ä¼šä¸¤æ–¹å°±å¯ä»¥å•¦ï¼Œç­”æ¡ˆæ˜¯å¦å®šçš„ï¼Œå¦‚æœè¿™ä¸ªåŒºå—ä¸åŒ…å«æ°´æœï¼ˆlen(sBlock.Body().Fruits)&lt;=0ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªå—æ˜¯ä¸åˆæ³•çš„ï¼ˆErrInvalidBlockï¼‰ã€‚<br> åˆ†é…æµç¨‹ä¸ºï¼š</p> 
  <ol> 
   <li>è®¡ç®—åŒºå—çš„å¥–åŠ±ï¼ŒgetBlockRewardï¼ˆï¼‰</li> 
   <li>è®¡ç®—åŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥ï¼Œå§”å‘˜ä¼šåˆ†åˆ«åº”å¾—çš„å¥–åŠ±</li> 
   <li>ç»™åŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥ï¼Œç­¾åçš„å§”å‘˜ä¼šæˆå‘˜åˆ†å‘å¥–åŠ±ã€‚</li> 
  </ol> 
  <h1><a id="3__251"></a>3 æ€»ç»“</h1> 
  <p>åˆé“¾ä½¿ç”¨äº†fPOWæœºåˆ¶ï¼Œè¿™ç§è®¾è®¡æœ‰æ•ˆçš„è§£å†³äº†ç®—åŠ›å·®è·å¯¼è‡´çš„å°ç®—åŠ›çŸ¿å·¥æŒ–ä¸åˆ°çŸ¿çš„ä¸è¶³ï¼Œä¿è¯äº†æ‰€æœ‰çŸ¿å·¥çš„å…¬å¹³æ€§ã€‚è¿™ç§æœºåˆ¶çš„å‡ºçŸ¿æµç¨‹æ˜¯çŸ¿å·¥æŒ–åˆ°çŸ¿ååˆ¤æ–­æ˜¯å—è¿˜æ˜¯æ°´æœï¼ŒçŸ¿å·¥æŒ–åˆ°æ°´æœåï¼Œä¼šå°†æ°´æœæ”¾åˆ°ä¸€ä¸ªæ°´æœæ± ï¼ˆfruit poolï¼‰ä¸­ï¼Œå¾…åˆ°æŒ–åˆ°å—ï¼ˆblockï¼‰åï¼Œä¾¿ä»æ°´æœæ± ä¸­å–å‡ºæ°´æœæ”¾ç½®åœ¨åŒºå—ä¸­ï¼ŒåŒºå—è¿›å…¥å§”å‘˜ä¼šè¿›è¡Œç¡®è®¤ï¼Œè¾¾æˆå…±è¯†å°±ä¸Šé“¾ã€‚ä¸Šé“¾ååŒºå—çŸ¿å·¥ï¼Œæ°´æœçŸ¿å·¥åŠç­¾åçš„å§”å‘˜ä¼šæˆå‘˜éƒ½èƒ½åˆ†åˆ°è¯¥åŒºå—çš„å¥–åŠ±ã€‚</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sinat_27935057/article/details/83193018,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sinat_27935057/article/details/83193018,&quot;}">é˜…è¯»æ›´å¤š</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- è‡ªå®šä¹‰å¹¿å‘Š -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">æ›´å¤šç²¾å½©å†…å®¹</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">å›é¦–é¡µ</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
