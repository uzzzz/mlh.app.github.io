<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>初链主网Beta版慢链挖矿解析 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="初链主网Beta版慢链挖矿解析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="初链主网Beta版于新加坡时间2018年09月28日08:00正式上线，在此之前，07:56分PBFT委员会第一次共识出块和TrueChain fPOW创世区块被挖出。下面我们就来谈谈慢链的出矿。 1 启动节点自动挖矿 本帖以docker挖矿为例，详细操作见docker版挖矿教程 。节点启动分为参不参加委员会竞选挖矿。 1.1 参与委员会竞选节点挖矿 1）挖矿只挖水果 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit --election console 2）挖矿水果和区块 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --election console 1.2 非参与委员会竞选节点挖矿 1）挖矿只挖水果 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit console 2）挖矿水果和区块 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine console 1.3 启动命令解析 -p 将容器中的端口映射到宿主机 –datadir 数据存储的文件夹 –minefruit 指定挖矿只挖水果 –election 本节点参与委员会竞选 2 FPOW机制挖矿 2.1 挖矿流程 初链采用了水果链（FruitChain）的设计来保证在挖矿过程中所有参与者的公平性。这是一种全新的设计挖矿的设计理念，称之为FPOW。这种设计有效的解决了算力差距导致的小算力矿工挖不到矿的不足，保证了所有矿工的公平性，因为在挖矿过程中挖到相对简单的水果（fruit）也是有奖励的。挖到的水果称之为水果链（FruitChain）。其大致的流程如下图所示。 2.2 代码实现 上图流程中的代码实现我们可以从源码的truechain-engineering-code/miner/worker.go中找到。 block := result.Block //work := result.Work if block.IsFruit() { if block.FastNumber() == nil { // if it does&#39;t include a fast block signs, it&#39;s not a fruit continue } if block.FastNumber().Cmp(common.Big0) == 0 { continue } //log.Info(&quot;🍒 —-------mined fruit&quot;,&quot; FB NUMBER&quot;,block.FastNumber()) // add fruit once if self.FastBlockNumber != nil{ if self.FastBlockNumber.Cmp(block.FastNumber()) !=0 { log.Info(&quot;🍒 ----mined fruit 1&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) //log.Info(&quot;not same fruits&quot;) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } }else{ log.Info(&quot;🍒 ----mined fruit 2&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } // make sure the fast number has been fruit self.FastBlockNumber.SetUint64(block.FastNumber().Uint64()) // only have fast block not fruits we need commit new work if self.current.fruits == nil{ self.atCommintNewWoker = false // post msg for commitnew work var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) self.chain.PostChainEvents(events) } } else { if block.Fruits() == nil{ self.atCommintNewWoker = false continue } fruits := block.Fruits() log.Info(&quot;+++++ mined block --- &quot;,&quot;block number&quot;,block.Number(), &quot;fruits&quot;, len(fruits), &quot;first&quot;, fruits[0].FastNumber(), &quot;end&quot;, fruits[len(fruits) - 1].FastNumber()) stat, err := self.chain.WriteCanonicalBlock(block) if err != nil { log.Error(&quot;Failed writing block to chain&quot;, &quot;err&quot;, err) continue } // Broadcast the block and announce chain insertion event self.mux.Post(chain.NewMinedBlockEvent{Block: block}) var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) if stat == chain.CanonStatTy { events = append(events, chain.ChainEvent{Block: block, Hash: block.Hash()}) events = append(events, chain.ChainHeadEvent{Block: block}) } self.chain.PostChainEvents(events) // Insert the block into the set of pending ones to wait for confirmations self.unconfirmed.Insert(block.NumberU64(), block.Hash()) self.atCommintNewWoker = false } block := result.Block：首先获取到结果中的block（姑且先叫他block，应为他还有可能只是一个水果而不是块）。 通过block.IsFruit()方法判断此block是否是水果（fruit），如果返回true的话，进入方法体，执行水果的操作，反之，执行块的操作。 block.IsFruit()返回true。通过self.etrue.SnailPool().AddRemoteFruits(newFruits)将该block添加到水果池（snailpool）中。 block.IsFruit()返回false,并且该block中含有fruit，那么提交委员会确认就可以执行上链操作了，self.chain.WriteCanonicalBlock(block)。 2.3 水果新鲜度确认 初链通过fPOW机制可以很有效的避免自私挖矿，其原理就是给水果赋予新鲜度的概念。如果一个自私的矿工在挖到块之后不提交委员会确认，自己想再挖到更长的链之后再广播的话，那么，对不起，之前挖到的水果很可能就已经过期了，那么之前没广播的链也就作废了。所以矿工会避免水果过期而及时把自己挖到的块提交委员会确认并上链，从而有效的避免自私挖矿。下面是水果新鲜度确认的代码实现。截取自truechain-engineering-code/consensus/minerva/consensus.go。 func (m *Minerva) VerifyFreshness(fruit, block *types.SnailHeader) error { var headerNumber *big.Int if block == nil { // when block is nil, is used to verify new fruits for next block headerNumber = new(big.Int).Add(m.sbc.CurrentHeader().Number, common.Big1) } else { headerNumber = block.Number } // check freshness pointer := m.sbc.GetHeaderByNumber(fruit.PointerNumber.Uint64()) if pointer == nil { return types.ErrSnailHeightNotYet } if pointer.Hash() != fruit.PointerHash { log.Debug(&quot;VerifyFreshness get pointer failed.&quot;, &quot;fruit&quot;, fruit.FastNumber, &quot;pointerNumber&quot;, fruit.PointerNumber, &quot;pointerHash&quot;, fruit.PointerHash, &quot;fruitNumber&quot;, fruit.Number, &quot;pointer&quot;, pointer.Hash()) return consensus.ErrUnknownPointer } freshNumber := new(big.Int).Sub(headerNumber, pointer.Number) if freshNumber.Cmp(params.FruitFreshness) &gt; 0 { log.Debug(&quot;VerifyFreshness failed.&quot;, &quot;fruit sb&quot;, fruit.Number, &quot;fruit fb&quot;, fruit.FastNumber, &quot;poiner&quot;, pointer.Number, &quot;current&quot;, headerNumber) return consensus.ErrFreshness } return nil } 从上面的代码块中可知，水果的hash和指针的hash值不相等以及水果新鲜度值大于设置的新鲜值的时候，均会返回VerifyFreshness failed，即该水果已经过期了。 2.4 挖矿奖励分配 我们说fPOW机制对所有的矿工都是公平的，不会因为普通矿工的算力不够而挖不到块导致得不到奖励，因为就算你算力不够，挖到水果的概率还是比较高的。那么，这个奖励是怎么分配的呢？我们来看分配的代码。 // AccumulateRewardsFast credits the coinbase of the given block with the mining // reward. The total reward consists of the static block reward and rewards for // included uncles. The coinbase of each uncle block is also rewarded. func accumulateRewardsFast(election consensus.CommitteeElection, state *state.StateDB, header *types.Header, sBlock *types.SnailBlock) error { committeeCoin, minerCoin, minerFruitCoin, e := getBlockReward(header.Number) if e != nil { return e } //miner&#39;s award state.AddBalance(sBlock.Coinbase(), minerCoin) LogPrint(&quot;miner&#39;s award&quot;, sBlock.Coinbase(), minerCoin) //miner fruit award blockFruits := sBlock.Body().Fruits blockFruitsLen := big.NewInt(int64(len(blockFruits))) if len(blockFruits) &gt; 0 { minerFruitCoinOne := new(big.Int).Div(minerFruitCoin, blockFruitsLen) for _, v := range sBlock.Body().Fruits { state.AddBalance(v.Coinbase(), minerFruitCoinOne) LogPrint(&quot;minerFruit&quot;, v.Coinbase(), minerFruitCoinOne) } } else { return consensus.ErrInvalidBlock } //committee&#39;s award committeeCoinFruit := new(big.Int).Div(committeeCoin, blockFruitsLen) //all fail committee coinBase failAddr := make(map[common.Address]bool) for _, fruit := range blockFruits { signs := fruit.Body().Signs committeeMembers, errs := election.VerifySigns(signs) if len(committeeMembers) != len(errs) { return consensus.ErrInvalidSignsLength } //Effective and not evil var fruitOkAddr []common.Address for i, cm := range committeeMembers { if errs[i] != nil { continue } cmPubAddr := crypto.PubkeyToAddress(*cm.Publickey) if signs[i].Result == types.VoteAgree { if _, ok := failAddr[cmPubAddr]; !ok { fruitOkAddr = append(fruitOkAddr, cm.Coinbase) } } else { failAddr[cmPubAddr] = false } } if len(fruitOkAddr) == 0 { log.Error(&quot;fruitOkAddr&quot;, &quot;Error&quot;, consensus.ErrInvalidSignsLength.Error()) return nil } // Equal by fruit committeeCoinFruitMember := new(big.Int).Div(committeeCoinFruit, big.NewInt(int64(len(fruitOkAddr)))) for _, v := range fruitOkAddr { state.AddBalance(v, committeeCoinFruitMember) LogPrint(&quot;committee&quot;, v, committeeCoinFruitMember) } } return nil } 从上面这段代码中，我们可以发现挖矿奖励是分配给三方的，分别是： 区块矿工 水果矿工 委员会 也许有人会问啦，如果区块不包含水果，是不是就只要分给区块矿工和委员会两方就可以啦，答案是否定的，如果这个区块不包含水果（len(sBlock.Body().Fruits)&lt;=0），那么这个块是不合法的（ErrInvalidBlock）。 分配流程为： 计算区块的奖励，getBlockReward（） 计算区块矿工，水果矿工，委员会分别应得的奖励 给区块矿工，水果矿工，签名的委员会成员分发奖励。 3 总结 初链使用了fPOW机制，这种设计有效的解决了算力差距导致的小算力矿工挖不到矿的不足，保证了所有矿工的公平性。这种机制的出矿流程是矿工挖到矿后判断是块还是水果，矿工挖到水果后，会将水果放到一个水果池（fruit pool）中，待到挖到块（block）后，便从水果池中取出水果放置在区块中，区块进入委员会进行确认，达成共识就上链。上链后区块矿工，水果矿工及签名的委员会成员都能分到该区块的奖励。 阅读更多" />
<meta property="og:description" content="初链主网Beta版于新加坡时间2018年09月28日08:00正式上线，在此之前，07:56分PBFT委员会第一次共识出块和TrueChain fPOW创世区块被挖出。下面我们就来谈谈慢链的出矿。 1 启动节点自动挖矿 本帖以docker挖矿为例，详细操作见docker版挖矿教程 。节点启动分为参不参加委员会竞选挖矿。 1.1 参与委员会竞选节点挖矿 1）挖矿只挖水果 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit --election console 2）挖矿水果和区块 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --election console 1.2 非参与委员会竞选节点挖矿 1）挖矿只挖水果 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit console 2）挖矿水果和区块 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine console 1.3 启动命令解析 -p 将容器中的端口映射到宿主机 –datadir 数据存储的文件夹 –minefruit 指定挖矿只挖水果 –election 本节点参与委员会竞选 2 FPOW机制挖矿 2.1 挖矿流程 初链采用了水果链（FruitChain）的设计来保证在挖矿过程中所有参与者的公平性。这是一种全新的设计挖矿的设计理念，称之为FPOW。这种设计有效的解决了算力差距导致的小算力矿工挖不到矿的不足，保证了所有矿工的公平性，因为在挖矿过程中挖到相对简单的水果（fruit）也是有奖励的。挖到的水果称之为水果链（FruitChain）。其大致的流程如下图所示。 2.2 代码实现 上图流程中的代码实现我们可以从源码的truechain-engineering-code/miner/worker.go中找到。 block := result.Block //work := result.Work if block.IsFruit() { if block.FastNumber() == nil { // if it does&#39;t include a fast block signs, it&#39;s not a fruit continue } if block.FastNumber().Cmp(common.Big0) == 0 { continue } //log.Info(&quot;🍒 —-------mined fruit&quot;,&quot; FB NUMBER&quot;,block.FastNumber()) // add fruit once if self.FastBlockNumber != nil{ if self.FastBlockNumber.Cmp(block.FastNumber()) !=0 { log.Info(&quot;🍒 ----mined fruit 1&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) //log.Info(&quot;not same fruits&quot;) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } }else{ log.Info(&quot;🍒 ----mined fruit 2&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } // make sure the fast number has been fruit self.FastBlockNumber.SetUint64(block.FastNumber().Uint64()) // only have fast block not fruits we need commit new work if self.current.fruits == nil{ self.atCommintNewWoker = false // post msg for commitnew work var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) self.chain.PostChainEvents(events) } } else { if block.Fruits() == nil{ self.atCommintNewWoker = false continue } fruits := block.Fruits() log.Info(&quot;+++++ mined block --- &quot;,&quot;block number&quot;,block.Number(), &quot;fruits&quot;, len(fruits), &quot;first&quot;, fruits[0].FastNumber(), &quot;end&quot;, fruits[len(fruits) - 1].FastNumber()) stat, err := self.chain.WriteCanonicalBlock(block) if err != nil { log.Error(&quot;Failed writing block to chain&quot;, &quot;err&quot;, err) continue } // Broadcast the block and announce chain insertion event self.mux.Post(chain.NewMinedBlockEvent{Block: block}) var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) if stat == chain.CanonStatTy { events = append(events, chain.ChainEvent{Block: block, Hash: block.Hash()}) events = append(events, chain.ChainHeadEvent{Block: block}) } self.chain.PostChainEvents(events) // Insert the block into the set of pending ones to wait for confirmations self.unconfirmed.Insert(block.NumberU64(), block.Hash()) self.atCommintNewWoker = false } block := result.Block：首先获取到结果中的block（姑且先叫他block，应为他还有可能只是一个水果而不是块）。 通过block.IsFruit()方法判断此block是否是水果（fruit），如果返回true的话，进入方法体，执行水果的操作，反之，执行块的操作。 block.IsFruit()返回true。通过self.etrue.SnailPool().AddRemoteFruits(newFruits)将该block添加到水果池（snailpool）中。 block.IsFruit()返回false,并且该block中含有fruit，那么提交委员会确认就可以执行上链操作了，self.chain.WriteCanonicalBlock(block)。 2.3 水果新鲜度确认 初链通过fPOW机制可以很有效的避免自私挖矿，其原理就是给水果赋予新鲜度的概念。如果一个自私的矿工在挖到块之后不提交委员会确认，自己想再挖到更长的链之后再广播的话，那么，对不起，之前挖到的水果很可能就已经过期了，那么之前没广播的链也就作废了。所以矿工会避免水果过期而及时把自己挖到的块提交委员会确认并上链，从而有效的避免自私挖矿。下面是水果新鲜度确认的代码实现。截取自truechain-engineering-code/consensus/minerva/consensus.go。 func (m *Minerva) VerifyFreshness(fruit, block *types.SnailHeader) error { var headerNumber *big.Int if block == nil { // when block is nil, is used to verify new fruits for next block headerNumber = new(big.Int).Add(m.sbc.CurrentHeader().Number, common.Big1) } else { headerNumber = block.Number } // check freshness pointer := m.sbc.GetHeaderByNumber(fruit.PointerNumber.Uint64()) if pointer == nil { return types.ErrSnailHeightNotYet } if pointer.Hash() != fruit.PointerHash { log.Debug(&quot;VerifyFreshness get pointer failed.&quot;, &quot;fruit&quot;, fruit.FastNumber, &quot;pointerNumber&quot;, fruit.PointerNumber, &quot;pointerHash&quot;, fruit.PointerHash, &quot;fruitNumber&quot;, fruit.Number, &quot;pointer&quot;, pointer.Hash()) return consensus.ErrUnknownPointer } freshNumber := new(big.Int).Sub(headerNumber, pointer.Number) if freshNumber.Cmp(params.FruitFreshness) &gt; 0 { log.Debug(&quot;VerifyFreshness failed.&quot;, &quot;fruit sb&quot;, fruit.Number, &quot;fruit fb&quot;, fruit.FastNumber, &quot;poiner&quot;, pointer.Number, &quot;current&quot;, headerNumber) return consensus.ErrFreshness } return nil } 从上面的代码块中可知，水果的hash和指针的hash值不相等以及水果新鲜度值大于设置的新鲜值的时候，均会返回VerifyFreshness failed，即该水果已经过期了。 2.4 挖矿奖励分配 我们说fPOW机制对所有的矿工都是公平的，不会因为普通矿工的算力不够而挖不到块导致得不到奖励，因为就算你算力不够，挖到水果的概率还是比较高的。那么，这个奖励是怎么分配的呢？我们来看分配的代码。 // AccumulateRewardsFast credits the coinbase of the given block with the mining // reward. The total reward consists of the static block reward and rewards for // included uncles. The coinbase of each uncle block is also rewarded. func accumulateRewardsFast(election consensus.CommitteeElection, state *state.StateDB, header *types.Header, sBlock *types.SnailBlock) error { committeeCoin, minerCoin, minerFruitCoin, e := getBlockReward(header.Number) if e != nil { return e } //miner&#39;s award state.AddBalance(sBlock.Coinbase(), minerCoin) LogPrint(&quot;miner&#39;s award&quot;, sBlock.Coinbase(), minerCoin) //miner fruit award blockFruits := sBlock.Body().Fruits blockFruitsLen := big.NewInt(int64(len(blockFruits))) if len(blockFruits) &gt; 0 { minerFruitCoinOne := new(big.Int).Div(minerFruitCoin, blockFruitsLen) for _, v := range sBlock.Body().Fruits { state.AddBalance(v.Coinbase(), minerFruitCoinOne) LogPrint(&quot;minerFruit&quot;, v.Coinbase(), minerFruitCoinOne) } } else { return consensus.ErrInvalidBlock } //committee&#39;s award committeeCoinFruit := new(big.Int).Div(committeeCoin, blockFruitsLen) //all fail committee coinBase failAddr := make(map[common.Address]bool) for _, fruit := range blockFruits { signs := fruit.Body().Signs committeeMembers, errs := election.VerifySigns(signs) if len(committeeMembers) != len(errs) { return consensus.ErrInvalidSignsLength } //Effective and not evil var fruitOkAddr []common.Address for i, cm := range committeeMembers { if errs[i] != nil { continue } cmPubAddr := crypto.PubkeyToAddress(*cm.Publickey) if signs[i].Result == types.VoteAgree { if _, ok := failAddr[cmPubAddr]; !ok { fruitOkAddr = append(fruitOkAddr, cm.Coinbase) } } else { failAddr[cmPubAddr] = false } } if len(fruitOkAddr) == 0 { log.Error(&quot;fruitOkAddr&quot;, &quot;Error&quot;, consensus.ErrInvalidSignsLength.Error()) return nil } // Equal by fruit committeeCoinFruitMember := new(big.Int).Div(committeeCoinFruit, big.NewInt(int64(len(fruitOkAddr)))) for _, v := range fruitOkAddr { state.AddBalance(v, committeeCoinFruitMember) LogPrint(&quot;committee&quot;, v, committeeCoinFruitMember) } } return nil } 从上面这段代码中，我们可以发现挖矿奖励是分配给三方的，分别是： 区块矿工 水果矿工 委员会 也许有人会问啦，如果区块不包含水果，是不是就只要分给区块矿工和委员会两方就可以啦，答案是否定的，如果这个区块不包含水果（len(sBlock.Body().Fruits)&lt;=0），那么这个块是不合法的（ErrInvalidBlock）。 分配流程为： 计算区块的奖励，getBlockReward（） 计算区块矿工，水果矿工，委员会分别应得的奖励 给区块矿工，水果矿工，签名的委员会成员分发奖励。 3 总结 初链使用了fPOW机制，这种设计有效的解决了算力差距导致的小算力矿工挖不到矿的不足，保证了所有矿工的公平性。这种机制的出矿流程是矿工挖到矿后判断是块还是水果，矿工挖到水果后，会将水果放到一个水果池（fruit pool）中，待到挖到块（block）后，便从水果池中取出水果放置在区块中，区块进入委员会进行确认，达成共识就上链。上链后区块矿工，水果矿工及签名的委员会成员都能分到该区块的奖励。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/10/20/f066d55d75eb37fb99060567bd1008fd.html" />
<meta property="og:url" content="https://mlh.app/2018/10/20/f066d55d75eb37fb99060567bd1008fd.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-10-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"初链主网Beta版于新加坡时间2018年09月28日08:00正式上线，在此之前，07:56分PBFT委员会第一次共识出块和TrueChain fPOW创世区块被挖出。下面我们就来谈谈慢链的出矿。 1 启动节点自动挖矿 本帖以docker挖矿为例，详细操作见docker版挖矿教程 。节点启动分为参不参加委员会竞选挖矿。 1.1 参与委员会竞选节点挖矿 1）挖矿只挖水果 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit --election console 2）挖矿水果和区块 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --election console 1.2 非参与委员会竞选节点挖矿 1）挖矿只挖水果 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit console 2）挖矿水果和区块 docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine console 1.3 启动命令解析 -p 将容器中的端口映射到宿主机 –datadir 数据存储的文件夹 –minefruit 指定挖矿只挖水果 –election 本节点参与委员会竞选 2 FPOW机制挖矿 2.1 挖矿流程 初链采用了水果链（FruitChain）的设计来保证在挖矿过程中所有参与者的公平性。这是一种全新的设计挖矿的设计理念，称之为FPOW。这种设计有效的解决了算力差距导致的小算力矿工挖不到矿的不足，保证了所有矿工的公平性，因为在挖矿过程中挖到相对简单的水果（fruit）也是有奖励的。挖到的水果称之为水果链（FruitChain）。其大致的流程如下图所示。 2.2 代码实现 上图流程中的代码实现我们可以从源码的truechain-engineering-code/miner/worker.go中找到。 block := result.Block //work := result.Work if block.IsFruit() { if block.FastNumber() == nil { // if it does&#39;t include a fast block signs, it&#39;s not a fruit continue } if block.FastNumber().Cmp(common.Big0) == 0 { continue } //log.Info(&quot;🍒 —-------mined fruit&quot;,&quot; FB NUMBER&quot;,block.FastNumber()) // add fruit once if self.FastBlockNumber != nil{ if self.FastBlockNumber.Cmp(block.FastNumber()) !=0 { log.Info(&quot;🍒 ----mined fruit 1&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) //log.Info(&quot;not same fruits&quot;) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } }else{ log.Info(&quot;🍒 ----mined fruit 2&quot;,&quot;number&quot;,block.FastNumber(), &quot;diff&quot;, block.FruitDifficulty(), &quot;hash&quot;, block.Hash(), &quot;signs&quot;, len(block.Signs())) var newFruits []*types.SnailBlock newFruits = append(newFruits, block) self.etrue.SnailPool().AddRemoteFruits(newFruits) } // make sure the fast number has been fruit self.FastBlockNumber.SetUint64(block.FastNumber().Uint64()) // only have fast block not fruits we need commit new work if self.current.fruits == nil{ self.atCommintNewWoker = false // post msg for commitnew work var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) self.chain.PostChainEvents(events) } } else { if block.Fruits() == nil{ self.atCommintNewWoker = false continue } fruits := block.Fruits() log.Info(&quot;+++++ mined block --- &quot;,&quot;block number&quot;,block.Number(), &quot;fruits&quot;, len(fruits), &quot;first&quot;, fruits[0].FastNumber(), &quot;end&quot;, fruits[len(fruits) - 1].FastNumber()) stat, err := self.chain.WriteCanonicalBlock(block) if err != nil { log.Error(&quot;Failed writing block to chain&quot;, &quot;err&quot;, err) continue } // Broadcast the block and announce chain insertion event self.mux.Post(chain.NewMinedBlockEvent{Block: block}) var ( events []interface{} ) events = append(events, chain.NewMinedEvent{Block: block}) if stat == chain.CanonStatTy { events = append(events, chain.ChainEvent{Block: block, Hash: block.Hash()}) events = append(events, chain.ChainHeadEvent{Block: block}) } self.chain.PostChainEvents(events) // Insert the block into the set of pending ones to wait for confirmations self.unconfirmed.Insert(block.NumberU64(), block.Hash()) self.atCommintNewWoker = false } block := result.Block：首先获取到结果中的block（姑且先叫他block，应为他还有可能只是一个水果而不是块）。 通过block.IsFruit()方法判断此block是否是水果（fruit），如果返回true的话，进入方法体，执行水果的操作，反之，执行块的操作。 block.IsFruit()返回true。通过self.etrue.SnailPool().AddRemoteFruits(newFruits)将该block添加到水果池（snailpool）中。 block.IsFruit()返回false,并且该block中含有fruit，那么提交委员会确认就可以执行上链操作了，self.chain.WriteCanonicalBlock(block)。 2.3 水果新鲜度确认 初链通过fPOW机制可以很有效的避免自私挖矿，其原理就是给水果赋予新鲜度的概念。如果一个自私的矿工在挖到块之后不提交委员会确认，自己想再挖到更长的链之后再广播的话，那么，对不起，之前挖到的水果很可能就已经过期了，那么之前没广播的链也就作废了。所以矿工会避免水果过期而及时把自己挖到的块提交委员会确认并上链，从而有效的避免自私挖矿。下面是水果新鲜度确认的代码实现。截取自truechain-engineering-code/consensus/minerva/consensus.go。 func (m *Minerva) VerifyFreshness(fruit, block *types.SnailHeader) error { var headerNumber *big.Int if block == nil { // when block is nil, is used to verify new fruits for next block headerNumber = new(big.Int).Add(m.sbc.CurrentHeader().Number, common.Big1) } else { headerNumber = block.Number } // check freshness pointer := m.sbc.GetHeaderByNumber(fruit.PointerNumber.Uint64()) if pointer == nil { return types.ErrSnailHeightNotYet } if pointer.Hash() != fruit.PointerHash { log.Debug(&quot;VerifyFreshness get pointer failed.&quot;, &quot;fruit&quot;, fruit.FastNumber, &quot;pointerNumber&quot;, fruit.PointerNumber, &quot;pointerHash&quot;, fruit.PointerHash, &quot;fruitNumber&quot;, fruit.Number, &quot;pointer&quot;, pointer.Hash()) return consensus.ErrUnknownPointer } freshNumber := new(big.Int).Sub(headerNumber, pointer.Number) if freshNumber.Cmp(params.FruitFreshness) &gt; 0 { log.Debug(&quot;VerifyFreshness failed.&quot;, &quot;fruit sb&quot;, fruit.Number, &quot;fruit fb&quot;, fruit.FastNumber, &quot;poiner&quot;, pointer.Number, &quot;current&quot;, headerNumber) return consensus.ErrFreshness } return nil } 从上面的代码块中可知，水果的hash和指针的hash值不相等以及水果新鲜度值大于设置的新鲜值的时候，均会返回VerifyFreshness failed，即该水果已经过期了。 2.4 挖矿奖励分配 我们说fPOW机制对所有的矿工都是公平的，不会因为普通矿工的算力不够而挖不到块导致得不到奖励，因为就算你算力不够，挖到水果的概率还是比较高的。那么，这个奖励是怎么分配的呢？我们来看分配的代码。 // AccumulateRewardsFast credits the coinbase of the given block with the mining // reward. The total reward consists of the static block reward and rewards for // included uncles. The coinbase of each uncle block is also rewarded. func accumulateRewardsFast(election consensus.CommitteeElection, state *state.StateDB, header *types.Header, sBlock *types.SnailBlock) error { committeeCoin, minerCoin, minerFruitCoin, e := getBlockReward(header.Number) if e != nil { return e } //miner&#39;s award state.AddBalance(sBlock.Coinbase(), minerCoin) LogPrint(&quot;miner&#39;s award&quot;, sBlock.Coinbase(), minerCoin) //miner fruit award blockFruits := sBlock.Body().Fruits blockFruitsLen := big.NewInt(int64(len(blockFruits))) if len(blockFruits) &gt; 0 { minerFruitCoinOne := new(big.Int).Div(minerFruitCoin, blockFruitsLen) for _, v := range sBlock.Body().Fruits { state.AddBalance(v.Coinbase(), minerFruitCoinOne) LogPrint(&quot;minerFruit&quot;, v.Coinbase(), minerFruitCoinOne) } } else { return consensus.ErrInvalidBlock } //committee&#39;s award committeeCoinFruit := new(big.Int).Div(committeeCoin, blockFruitsLen) //all fail committee coinBase failAddr := make(map[common.Address]bool) for _, fruit := range blockFruits { signs := fruit.Body().Signs committeeMembers, errs := election.VerifySigns(signs) if len(committeeMembers) != len(errs) { return consensus.ErrInvalidSignsLength } //Effective and not evil var fruitOkAddr []common.Address for i, cm := range committeeMembers { if errs[i] != nil { continue } cmPubAddr := crypto.PubkeyToAddress(*cm.Publickey) if signs[i].Result == types.VoteAgree { if _, ok := failAddr[cmPubAddr]; !ok { fruitOkAddr = append(fruitOkAddr, cm.Coinbase) } } else { failAddr[cmPubAddr] = false } } if len(fruitOkAddr) == 0 { log.Error(&quot;fruitOkAddr&quot;, &quot;Error&quot;, consensus.ErrInvalidSignsLength.Error()) return nil } // Equal by fruit committeeCoinFruitMember := new(big.Int).Div(committeeCoinFruit, big.NewInt(int64(len(fruitOkAddr)))) for _, v := range fruitOkAddr { state.AddBalance(v, committeeCoinFruitMember) LogPrint(&quot;committee&quot;, v, committeeCoinFruitMember) } } return nil } 从上面这段代码中，我们可以发现挖矿奖励是分配给三方的，分别是： 区块矿工 水果矿工 委员会 也许有人会问啦，如果区块不包含水果，是不是就只要分给区块矿工和委员会两方就可以啦，答案是否定的，如果这个区块不包含水果（len(sBlock.Body().Fruits)&lt;=0），那么这个块是不合法的（ErrInvalidBlock）。 分配流程为： 计算区块的奖励，getBlockReward（） 计算区块矿工，水果矿工，委员会分别应得的奖励 给区块矿工，水果矿工，签名的委员会成员分发奖励。 3 总结 初链使用了fPOW机制，这种设计有效的解决了算力差距导致的小算力矿工挖不到矿的不足，保证了所有矿工的公平性。这种机制的出矿流程是矿工挖到矿后判断是块还是水果，矿工挖到水果后，会将水果放到一个水果池（fruit pool）中，待到挖到块（block）后，便从水果池中取出水果放置在区块中，区块进入委员会进行确认，达成共识就上链。上链后区块矿工，水果矿工及签名的委员会成员都能分到该区块的奖励。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/10/20/f066d55d75eb37fb99060567bd1008fd.html","headline":"初链主网Beta版慢链挖矿解析","dateModified":"2018-10-20T00:00:00+08:00","datePublished":"2018-10-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/10/20/f066d55d75eb37fb99060567bd1008fd.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>初链主网Beta版慢链挖矿解析</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>初链主网Beta版于新加坡时间2018年09月28日08:00正式上线，在此之前，07:56分PBFT委员会第一次共识出块和TrueChain fPOW创世区块被挖出。下面我们就来谈谈慢链的出矿。</p> 
  <h1><a id="1__2"></a>1 启动节点自动挖矿</h1> 
  <p>本帖以docker挖矿为例，详细操作见<a href="https://www.truechain.pro/download/ming/ming-version-docker-zh.pdf" rel="nofollow">docker版挖矿教程</a> 。节点启动分为参不参加委员会竞选挖矿。</p> 
  <h2><a id="11__5"></a>1.1 参与委员会竞选节点挖矿</h2> 
  <p>1）挖矿只挖水果</p> 
  <pre><code>docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine  --minefruit --election console
</code></pre> 
  <p>2）挖矿水果和区块</p> 
  <pre><code>docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --election console
</code></pre> 
  <h2><a id="12__21"></a>1.2 非参与委员会竞选节点挖矿</h2> 
  <p>1）挖矿只挖水果</p> 
  <pre><code>docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine --minefruit console
</code></pre> 
  <p>2）挖矿水果和区块</p> 
  <pre><code>docker run -v $PWD:/truechain-engineering-code -it -p 30311:30311 -p 30310:30310 -p 30303:30303 -p 9215:9215 getrue --datadir /truechain-engineering-code/data --config /truechain-engineering-code/config --testnet --mine console
</code></pre> 
  <h2><a id="13__35"></a>1.3 启动命令解析</h2> 
  <ul> 
   <li>-p 将容器中的端口映射到宿主机</li> 
   <li>–datadir 数据存储的文件夹</li> 
   <li>–minefruit 指定挖矿只挖水果</li> 
   <li>–election 本节点参与委员会竞选</li> 
  </ul> 
  <h1><a id="2_FPOW_40"></a>2 FPOW机制挖矿</h1> 
  <h2><a id="21__41"></a>2.1 挖矿流程</h2> 
  <p>初链采用了水果链（FruitChain）的设计来保证在挖矿过程中所有参与者的公平性。这是一种全新的设计挖矿的设计理念，称之为FPOW。这种设计有效的解决了算力差距导致的小算力矿工挖不到矿的不足，保证了所有矿工的公平性，因为在挖矿过程中挖到相对简单的水果（fruit）也是有奖励的。挖到的水果称之为水果链（FruitChain）。其大致的流程如下图所示。<br> <img src="https://note.youdao.com/yws/api/personal/file/3B1FD5637EE2445994D03CA9F69722D0?method=download&amp;shareKey=9848b2c33035eb895d3db80224f251ab" alt="image"></p> 
  <h2><a id="22__44"></a>2.2 代码实现</h2> 
  <p>上图流程中的代码实现我们可以从源码的truechain-engineering-code/miner/worker.go中找到。</p> 
  <pre><code>block := result.Block
//work := result.Work

if block.IsFruit() {
	if block.FastNumber() == nil {
		// if it does't include a fast block signs, it's not a fruit
		continue
	}
	if block.FastNumber().Cmp(common.Big0) == 0 {
		continue
	}

	//log.Info("🍒 —-------mined fruit"," FB NUMBER",block.FastNumber())

	// add fruit once
	if self.FastBlockNumber != nil{
		if self.FastBlockNumber.Cmp(block.FastNumber()) !=0 {
			log.Info("🍒  ----mined fruit 1","number",block.FastNumber(), "diff", block.FruitDifficulty(), "hash", block.Hash(), "signs", len(block.Signs()))
			//log.Info("not same fruits")
			var newFruits []*types.SnailBlock
			newFruits = append(newFruits, block)
			self.etrue.SnailPool().AddRemoteFruits(newFruits)
		}
	}else{
		log.Info("🍒 ----mined fruit 2","number",block.FastNumber(), "diff", block.FruitDifficulty(), "hash", block.Hash(), "signs", len(block.Signs()))
		var newFruits []*types.SnailBlock
		newFruits = append(newFruits, block)
		self.etrue.SnailPool().AddRemoteFruits(newFruits)
	}

	// make sure the fast number has been fruit
	self.FastBlockNumber.SetUint64(block.FastNumber().Uint64())

	// only have fast block not fruits we need commit new work
	if self.current.fruits == nil{
		self.atCommintNewWoker = false
		// post msg for commitnew work
		var (
			events []interface{}
		)
		events = append(events, chain.NewMinedEvent{Block: block})
		self.chain.PostChainEvents(events)
	}
} else {
	if block.Fruits() == nil{
		self.atCommintNewWoker = false
		continue
	}

	fruits := block.Fruits()
	log.Info("+++++ mined block  ---  ","block number",block.Number(), "fruits", len(fruits), "first", fruits[0].FastNumber(), "end", fruits[len(fruits) - 1].FastNumber())

	stat, err := self.chain.WriteCanonicalBlock(block)
	if err != nil {
		log.Error("Failed writing block to chain", "err", err)
		continue
	}

	// Broadcast the block and announce chain insertion event
	self.mux.Post(chain.NewMinedBlockEvent{Block: block})
	var (
		events []interface{}
	)

	events = append(events, chain.NewMinedEvent{Block: block})

	if stat == chain.CanonStatTy {
		events = append(events, chain.ChainEvent{Block: block, Hash: block.Hash()})
		events = append(events, chain.ChainHeadEvent{Block: block})
	}
	self.chain.PostChainEvents(events)

	// Insert the block into the set of pending ones to wait for confirmations
	self.unconfirmed.Insert(block.NumberU64(), block.Hash())

	self.atCommintNewWoker = false
}
</code></pre> 
  <ol> 
   <li>block := result.Block：首先获取到结果中的block（姑且先叫他block，应为他还有可能只是一个水果而不是块）。</li> 
   <li>通过block.IsFruit()方法判断此block是否是水果（fruit），如果返回true的话，进入方法体，执行水果的操作，反之，执行块的操作。</li> 
   <li>block.IsFruit()返回true。通过self.etrue.SnailPool().AddRemoteFruits(newFruits)将该block添加到水果池（snailpool）中。</li> 
   <li>block.IsFruit()返回false,并且该block中含有fruit，那么提交委员会确认就可以执行上链操作了，self.chain.WriteCanonicalBlock(block)。</li> 
  </ol> 
  <h2><a id="23__130"></a>2.3 水果新鲜度确认</h2> 
  <p>初链通过fPOW机制可以很有效的避免自私挖矿，其原理就是给水果赋予新鲜度的概念。如果一个自私的矿工在挖到块之后不提交委员会确认，自己想再挖到更长的链之后再广播的话，那么，对不起，之前挖到的水果很可能就已经过期了，那么之前没广播的链也就作废了。所以矿工会避免水果过期而及时把自己挖到的块提交委员会确认并上链，从而有效的避免自私挖矿。下面是水果新鲜度确认的代码实现。截取自truechain-engineering-code/consensus/minerva/consensus.go。</p> 
  <pre><code>func (m *Minerva) VerifyFreshness(fruit, block *types.SnailHeader) error {
	var headerNumber *big.Int
	if block == nil {
		// when block is nil, is used to verify new fruits for next block
		headerNumber = new(big.Int).Add(m.sbc.CurrentHeader().Number, common.Big1)
	} else {
		headerNumber = block.Number
	}
	// check freshness
	pointer := m.sbc.GetHeaderByNumber(fruit.PointerNumber.Uint64())
	if pointer == nil {
		return types.ErrSnailHeightNotYet
	}
	if pointer.Hash() != fruit.PointerHash {
		log.Debug("VerifyFreshness get pointer failed.", "fruit", fruit.FastNumber, "pointerNumber", fruit.PointerNumber, "pointerHash", fruit.PointerHash,
			"fruitNumber", fruit.Number, "pointer", pointer.Hash())
		return consensus.ErrUnknownPointer
	}
	freshNumber := new(big.Int).Sub(headerNumber, pointer.Number)
	if freshNumber.Cmp(params.FruitFreshness) &gt; 0 {
		log.Debug("VerifyFreshness failed.", "fruit sb", fruit.Number, "fruit fb", fruit.FastNumber, "poiner", pointer.Number, "current", headerNumber)
		return consensus.ErrFreshness
	}

	return nil
}
</code></pre> 
  <p>从上面的代码块中可知，水果的hash和指针的hash值不相等以及水果新鲜度值大于设置的新鲜值的时候，均会返回VerifyFreshness failed，即该水果已经过期了。</p> 
  <h2><a id="24__162"></a>2.4 挖矿奖励分配</h2> 
  <p>我们说fPOW机制对所有的矿工都是公平的，不会因为普通矿工的算力不够而挖不到块导致得不到奖励，因为就算你算力不够，挖到水果的概率还是比较高的。那么，这个奖励是怎么分配的呢？我们来看分配的代码。</p> 
  <pre><code>// AccumulateRewardsFast credits the coinbase of the given block with the mining
// reward. The total reward consists of the static block reward and rewards for
// included uncles. The coinbase of each uncle block is also rewarded.
func accumulateRewardsFast(election consensus.CommitteeElection, state *state.StateDB, header *types.Header, sBlock *types.SnailBlock) error {
	committeeCoin, minerCoin, minerFruitCoin, e := getBlockReward(header.Number)

	if e != nil {
		return e
	}

	//miner's award
	state.AddBalance(sBlock.Coinbase(), minerCoin)
	LogPrint("miner's award", sBlock.Coinbase(), minerCoin)

	//miner fruit award
	blockFruits := sBlock.Body().Fruits
	blockFruitsLen := big.NewInt(int64(len(blockFruits)))
	if len(blockFruits) &gt; 0 {
		minerFruitCoinOne := new(big.Int).Div(minerFruitCoin, blockFruitsLen)
		for _, v := range sBlock.Body().Fruits {
			state.AddBalance(v.Coinbase(), minerFruitCoinOne)
			LogPrint("minerFruit", v.Coinbase(), minerFruitCoinOne)
		}
	} else {
		return consensus.ErrInvalidBlock
	}

	//committee's award
	committeeCoinFruit := new(big.Int).Div(committeeCoin, blockFruitsLen)

	//all fail committee coinBase
	failAddr := make(map[common.Address]bool)

	for _, fruit := range blockFruits {
		signs := fruit.Body().Signs

		committeeMembers, errs := election.VerifySigns(signs)

		if len(committeeMembers) != len(errs) {
			return consensus.ErrInvalidSignsLength
		}

		//Effective and not evil
		var fruitOkAddr []common.Address
		for i, cm := range committeeMembers {
			if errs[i] != nil {
				continue
			}
			cmPubAddr := crypto.PubkeyToAddress(*cm.Publickey)

			if signs[i].Result == types.VoteAgree {
				if _, ok := failAddr[cmPubAddr]; !ok {
					fruitOkAddr = append(fruitOkAddr, cm.Coinbase)
				}
			} else {
				failAddr[cmPubAddr] = false
			}
		}

		if len(fruitOkAddr) == 0 {
			log.Error("fruitOkAddr", "Error", consensus.ErrInvalidSignsLength.Error())
			return nil
		}

		// Equal by fruit
		committeeCoinFruitMember := new(big.Int).Div(committeeCoinFruit, big.NewInt(int64(len(fruitOkAddr))))
		for _, v := range fruitOkAddr {
			state.AddBalance(v, committeeCoinFruitMember)
			LogPrint("committee", v, committeeCoinFruitMember)
		}
	}

	return nil
}
</code></pre> 
  <p>从上面这段代码中，我们可以发现挖矿奖励是分配给三方的，分别是：</p> 
  <ul> 
   <li>区块矿工</li> 
   <li>水果矿工</li> 
   <li>委员会</li> 
  </ul> 
  <p>也许有人会问啦，如果区块不包含水果，是不是就只要分给区块矿工和委员会两方就可以啦，答案是否定的，如果这个区块不包含水果（len(sBlock.Body().Fruits)&lt;=0），那么这个块是不合法的（ErrInvalidBlock）。<br> 分配流程为：</p> 
  <ol> 
   <li>计算区块的奖励，getBlockReward（）</li> 
   <li>计算区块矿工，水果矿工，委员会分别应得的奖励</li> 
   <li>给区块矿工，水果矿工，签名的委员会成员分发奖励。</li> 
  </ol> 
  <h1><a id="3__251"></a>3 总结</h1> 
  <p>初链使用了fPOW机制，这种设计有效的解决了算力差距导致的小算力矿工挖不到矿的不足，保证了所有矿工的公平性。这种机制的出矿流程是矿工挖到矿后判断是块还是水果，矿工挖到水果后，会将水果放到一个水果池（fruit pool）中，待到挖到块（block）后，便从水果池中取出水果放置在区块中，区块进入委员会进行确认，达成共识就上链。上链后区块矿工，水果矿工及签名的委员会成员都能分到该区块的奖励。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sinat_27935057/article/details/83193018,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/sinat_27935057/article/details/83193018,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
