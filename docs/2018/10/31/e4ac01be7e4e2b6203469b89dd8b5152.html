<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>第二十二篇 墨客区块链(MOAC BlockChain) 墨客公共节点：gateway | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="第二十二篇 墨客区块链(MOAC BlockChain) 墨客公共节点：gateway" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/83582762 2018-10-31，MOAC推出官方公共节点，https://gateway.moac.io。 本文测试环境：Windows 10 + node Ver8.11.1 + chain3 Ver0.1.8。 1.介绍 moac gateway是一个托管的墨客节点集群，为用户提供公开的墨客区块链主网和测试网节点。 出于安全原因，gateway不管理用户的私钥，这意味着gateway不能代表用户签署交易。 因此，在使用chain3的过程中，不能通过sendTransaction、而只能使用sendRawTransaction发出交易。 1.1 主要特性（优势）： 实现不同地理位置的服务器负载均衡； 实现MOAC区块链上的全功能RPC方法； 不再需要技术开发人员部署MOAC Vnode节点； 使用与本地节点完全一样的方式调用Chain3； 保持与最新的MOAC发布版本一致。 1.2 使用方法： 通过以下脚本，可以使用http://gateway.moac.io代替自己的Vnode节点。 之前使用代码连接本地Vnode节点方式： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); 改为通过以下方式连接公共Vnode节点： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/testnet&#39;)); //For testnet var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); //For mainnet 1.3 不足： 使用gateway跟使用本地Vnode节点相比，也有一些不足： 会有延迟，因为用户网络原因，可能有意想不到的无法连接Vnode情况； 无法按自己的方式启动节点，无法看到Vnode界面的反馈，有时候这些反馈很有用且很关键； 某些特殊应用不支持，比如试图使用http://wallet.moac.io部署合约。 &nbsp; 2.账号管理 moac gateway提供Vnode功能的时候，从安全角度考虑，没有启动personal，因此不能通过persoanl.newAccount()创建账号。 鉴于moac gateway需要私钥签名才能发送交易，这里给出管理墨客账号的部分代码。 2.1 安装依赖模块ethereumjs-wallet 在具有管理员权限的控制台中，运行以下命令安装ethereumjs-wallet。 C:\&gt;npm install -g ethereumjs-wallet 此处注意：如果是在Windows上安装并且遇到错误，则可能需要安装Windows构建工具。 在具有管理员权限的控制台中，运行以下命令安装Windows构建工具，然后再尝试安装依赖模块。 C:\&gt;npm install -g windows-build-tools 2.2 离线生成账号privateKey 方法一：node环境下运行以下代码，可以离线生成账号，分别得到私钥、公钥和地址。 var crypto = require(&#39;crypto&#39;); //npm install -g crypto var secp256k1 = require(&#39;secp256k1&#39;); //npm install -g secp256k1 var keccak = require(&#39;keccak&#39;); //npm install -g keccak //获得随机的32个字节作为私钥，在使用中，请注意随机数来源的安全 var privateKey = crypto.randomBytes(32); //获得公钥 var publicKey = secp256k1.publicKeyCreate(privateKey, false).slice(1); //获得地址 var address = keccak(&#39;keccak256&#39;).update(publicKey).digest().slice(-20); console.log(&#39;public key&#39;, publicKey.toString(&#39;hex&#39;)); console.log(&#39;private key&#39;, privateKey.toString(&#39;hex&#39;)); console.log(&#39;address&#39;, &#39;0x&#39; + address.toString(&#39;hex&#39;)); 方法二：node环境下运行以下代码，可以离线生成账号，得到私钥和地址。 var Wallet = require(&#39;ethereumjs-wallet&#39;); //npm install -g ethereumjs-wallet const wallet = Wallet.generate(); console.log(&quot;privateKey: &quot; + wallet.getPrivateKeyString()); console.log(&quot;address: &quot; + wallet.getAddressString()); 运行结果： 2.3 从privateKey得到keystore node环境下运行以下代码，可以从privateKey得到keystore文件内容： var Wallet = require(&#39;ethereumjs-wallet&#39;); var key = Buffer.from(&#39;6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8&#39;, &#39;hex&#39;); //填入privateKey，没有0x var wallet = Wallet.fromPrivateKey(key); var keystore = wallet.toV3String(&#39;123456&#39;); //填入要设置的密码，该密码可以从keystore得到privateKey console.log(&quot;wallet: &quot; + JSON.stringify(keystore)); 运行结果： 将输出内容（wallet后面双引号中的内容），去掉所有“\”符号，新建一个文件，保存到D盘keystore目录下。 2.4 从keystore得到privateKey 从keystore得到privateKey需要提供账号密码。 node环境下运行以下代码，可以从keystore文件得到privateKey： var keythereum = require(&quot;keythereum&quot;); //npm install -g keythereum var datadir = &quot;D:&quot;; //此处需默认保存在keystore目录下，也就是keystore文件实际保存在D:\keystore目录下 var address= &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; const password = &quot;123456&quot;; var keyObject = keythereum.importFromFile(address, datadir); var privateKey = keythereum.recover(password, keyObject); console.log(privateKey.toString(&#39;hex&#39;)); 运行结果： 正确地从keystore得到privateKey。 &nbsp; 3.基础使用测试 使用公共节点，用户通常有些信息需要拿到，而不能像本地节点那样是当然知道的，包括节点版本信息及当前区块高度等。 3.1 版本信息 使用代码如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;https://gateway.moac.io/mainnet&#39;)); var version = chain3.version.api; console.log(version); var version = chain3.version.node; console.log(version); var version = chain3.version.network; console.log(version); 输出结果： 前面是主网信息，后面是测试网信息，通常测试网的Vnode版本会比主网高，得到的结果均为当前最新发布版本。 3.2 区块高度 使用代码如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); if(chain3.isConnected()){ console.log(chain3.mc.blockNumber); } 输出结果：与浏览器同步较好。 以上测试，及部分chain3的基础使用（如获取账号balance等），使用方式与本地节点相同，均输出正确结果。 该步骤测试运行多次，快的时候1秒返回结果，慢的时候需要三十多秒。 &nbsp; 4.发送签名交易 此处测试过程使用本文第二节生成的账号私钥、地址。 先向该地址发送0.5个mc；然后运行以下代码，使用sendRawTransaction发送一个签名交易，该笔交易发送0.2个mc。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); var address = &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; var account = {address:&quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;,secret:&quot;6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8&quot;}; var toAddress = &quot;0x68986c1bcd54ae5dae69310fc64ea544ff1d56c4&quot;; var amount = 0.2; send(chain3, account.address, account.secret, toAddress, amount, txCount = -1) function send(chain3, fromAddress, fromSecret, toAddress, amount, txCount = -1){ var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress); console.log(&quot;Get tx account&quot;, txcount); var gasPrice = 25000000000; var gasLimit = 100000; var value = chain3.toSha(amount, &#39;mc&#39;); var gasTotal = gasPrice * gasLimit + Number(value); console.log(gasPrice, gasLimit, value, chain3.fromSha(gasTotal, &#39;mc&#39;)); var rawTx = { from: fromAddress, to: toAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), value: chain3.intToHex(value), shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); return hash; }else{ console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); } }); } 输出结果： 该步骤测试运行多次，均成功返回结果。 到浏览器查询签名交易发送情况： &nbsp; 5.调用合约 为了测试的方便，该步骤使用一个已经部署好的erc20合约。 在对合约的调用中，有很多调用不需要使用私钥签名，比如获取标准erc20合约的基本属性和balance的调用。 5.1 给新账号发送token 给新账号0xd3ab5cdba1d540fb049b88e05241b3393e52e230发送100个KFZT（标准erc20 token，合约地址看代码）。 5.2 查询账号里的token余额 使用gateway节点，node环境运行以下代码，实现对合约的调用，该调用会查询到账号的token余额，不需要签名。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96A95D8d48f1679&quot;; var address = &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; var abiString = &#39;[ { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;name&quot;,.......... { &quot;indexed&quot;: true, &quot;name&quot;: &quot;_spender&quot;, &quot;type&quot;: &quot;address&quot; }, { &quot;indexed&quot;: false, &quot;name&quot;: &quot;_value&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;Approval&quot;, &quot;type&quot;: &quot;event&quot; } ]&#39;; //调用erc20合约 //基本属性 callContract2(chain3, contractAddress, address, abiString); function callContract2(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(JSON.stringify(token.totalSupply())); console.log(JSON.stringify(token.name())); console.log(JSON.stringify(token.decimals())); console.log(JSON.stringify(token.symbol())); } //调用erc20合约 //查询余额 callContract(chain3, contractAddress, address, abiString); function callContract(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); token.balanceOf.call(address, function(err, result){ console.log(err, JSON.stringify(result)); }); } 输出结果： 该步骤测试运行多次，合约的四个属性都在1秒内返回，而账号token的balance值返回结果均在30多秒。 5.2 发回token 使用gateway节点，node环境运行以下代码，实现对合约的调用，将10个KFZT发回原账号，该调用需要私钥签名。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96A95D8d48f1679&quot;; var address = &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; var account = {address:&quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;,secret:&quot;6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8&quot;}; var abiString = &#39;[ { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;name&quot;,...... { &quot;indexed&quot;: true, &quot;name&quot;: &quot;_spender&quot;, &quot;type&quot;: &quot;address&quot; }, { &quot;indexed&quot;: false, &quot;name&quot;: &quot;_value&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;Approval&quot;, &quot;type&quot;: &quot;event&quot; } ]&#39;; //调用erc20合约 //发送token var amount = 10; //token的最小单位 var anotherAddress = &quot;0x68986c1BCD54Ae5dAe69310fC64Ea544FF1D56C4&quot;; callContract1(chain3, contractAddress, account, abiString, anotherAddress, amount); function callContract1(chain3, contractAddress, account, abiString, anotherAddress, amount){ var address = account.address; var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); var data = token.transfer.getData(anotherAddress, amount); console.log(&#39;data&#39;, data); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(100000), to: contractAddress, data: data, chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); var filter = chain3.mc.filter(&#39;latest&#39;); filter.watch(function(error, result) { var receipt = chain3.mc.getTransaction(hash); if (!error &amp;&amp; receipt &amp;&amp; receipt.blockNumber != null) { console.log(&quot;done.&quot;); filter.stopWatching(); process.exit(0); } }); }else{ console.log(&quot;error:&quot;, err.message); } }); } 输出结果： 该步骤测试运行多次，输出结果至succeed在2秒左右，至done均在60秒以上。 &nbsp; 6.使用RPC 此处测试简单的RPC调用： var request = require(&#39;request&#39;); var url = &quot;http://gateway.moac.io/mainnet&quot;; var requestData = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_gasPrice&quot;,&quot;params&quot;:[],&quot;id&quot;:99}; httprequest(url,requestData); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; 输出结果： 该步骤测试运行多次，返回结果在2秒内。 其他json rpc的使用参考：https://github.com/MOACChain/moac-core/wiki/JSON-RPC。 &nbsp; 本次测试结论： &nbsp; &nbsp; &nbsp; 1.对于许可的功能（主要是RPC和Chain3的调用），可以提供最新版的、稳定的墨客节点功能； &nbsp; &nbsp; &nbsp; 2.实测中，所有查询及签名交易均成功； &nbsp; &nbsp; &nbsp; 3.实测中，与本地节点比较，有延迟现象存在，但没有出现无法连接Vnode的情况。 阅读更多" />
<meta property="og:description" content="版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/83582762 2018-10-31，MOAC推出官方公共节点，https://gateway.moac.io。 本文测试环境：Windows 10 + node Ver8.11.1 + chain3 Ver0.1.8。 1.介绍 moac gateway是一个托管的墨客节点集群，为用户提供公开的墨客区块链主网和测试网节点。 出于安全原因，gateway不管理用户的私钥，这意味着gateway不能代表用户签署交易。 因此，在使用chain3的过程中，不能通过sendTransaction、而只能使用sendRawTransaction发出交易。 1.1 主要特性（优势）： 实现不同地理位置的服务器负载均衡； 实现MOAC区块链上的全功能RPC方法； 不再需要技术开发人员部署MOAC Vnode节点； 使用与本地节点完全一样的方式调用Chain3； 保持与最新的MOAC发布版本一致。 1.2 使用方法： 通过以下脚本，可以使用http://gateway.moac.io代替自己的Vnode节点。 之前使用代码连接本地Vnode节点方式： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); 改为通过以下方式连接公共Vnode节点： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/testnet&#39;)); //For testnet var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); //For mainnet 1.3 不足： 使用gateway跟使用本地Vnode节点相比，也有一些不足： 会有延迟，因为用户网络原因，可能有意想不到的无法连接Vnode情况； 无法按自己的方式启动节点，无法看到Vnode界面的反馈，有时候这些反馈很有用且很关键； 某些特殊应用不支持，比如试图使用http://wallet.moac.io部署合约。 &nbsp; 2.账号管理 moac gateway提供Vnode功能的时候，从安全角度考虑，没有启动personal，因此不能通过persoanl.newAccount()创建账号。 鉴于moac gateway需要私钥签名才能发送交易，这里给出管理墨客账号的部分代码。 2.1 安装依赖模块ethereumjs-wallet 在具有管理员权限的控制台中，运行以下命令安装ethereumjs-wallet。 C:\&gt;npm install -g ethereumjs-wallet 此处注意：如果是在Windows上安装并且遇到错误，则可能需要安装Windows构建工具。 在具有管理员权限的控制台中，运行以下命令安装Windows构建工具，然后再尝试安装依赖模块。 C:\&gt;npm install -g windows-build-tools 2.2 离线生成账号privateKey 方法一：node环境下运行以下代码，可以离线生成账号，分别得到私钥、公钥和地址。 var crypto = require(&#39;crypto&#39;); //npm install -g crypto var secp256k1 = require(&#39;secp256k1&#39;); //npm install -g secp256k1 var keccak = require(&#39;keccak&#39;); //npm install -g keccak //获得随机的32个字节作为私钥，在使用中，请注意随机数来源的安全 var privateKey = crypto.randomBytes(32); //获得公钥 var publicKey = secp256k1.publicKeyCreate(privateKey, false).slice(1); //获得地址 var address = keccak(&#39;keccak256&#39;).update(publicKey).digest().slice(-20); console.log(&#39;public key&#39;, publicKey.toString(&#39;hex&#39;)); console.log(&#39;private key&#39;, privateKey.toString(&#39;hex&#39;)); console.log(&#39;address&#39;, &#39;0x&#39; + address.toString(&#39;hex&#39;)); 方法二：node环境下运行以下代码，可以离线生成账号，得到私钥和地址。 var Wallet = require(&#39;ethereumjs-wallet&#39;); //npm install -g ethereumjs-wallet const wallet = Wallet.generate(); console.log(&quot;privateKey: &quot; + wallet.getPrivateKeyString()); console.log(&quot;address: &quot; + wallet.getAddressString()); 运行结果： 2.3 从privateKey得到keystore node环境下运行以下代码，可以从privateKey得到keystore文件内容： var Wallet = require(&#39;ethereumjs-wallet&#39;); var key = Buffer.from(&#39;6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8&#39;, &#39;hex&#39;); //填入privateKey，没有0x var wallet = Wallet.fromPrivateKey(key); var keystore = wallet.toV3String(&#39;123456&#39;); //填入要设置的密码，该密码可以从keystore得到privateKey console.log(&quot;wallet: &quot; + JSON.stringify(keystore)); 运行结果： 将输出内容（wallet后面双引号中的内容），去掉所有“\”符号，新建一个文件，保存到D盘keystore目录下。 2.4 从keystore得到privateKey 从keystore得到privateKey需要提供账号密码。 node环境下运行以下代码，可以从keystore文件得到privateKey： var keythereum = require(&quot;keythereum&quot;); //npm install -g keythereum var datadir = &quot;D:&quot;; //此处需默认保存在keystore目录下，也就是keystore文件实际保存在D:\keystore目录下 var address= &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; const password = &quot;123456&quot;; var keyObject = keythereum.importFromFile(address, datadir); var privateKey = keythereum.recover(password, keyObject); console.log(privateKey.toString(&#39;hex&#39;)); 运行结果： 正确地从keystore得到privateKey。 &nbsp; 3.基础使用测试 使用公共节点，用户通常有些信息需要拿到，而不能像本地节点那样是当然知道的，包括节点版本信息及当前区块高度等。 3.1 版本信息 使用代码如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;https://gateway.moac.io/mainnet&#39;)); var version = chain3.version.api; console.log(version); var version = chain3.version.node; console.log(version); var version = chain3.version.network; console.log(version); 输出结果： 前面是主网信息，后面是测试网信息，通常测试网的Vnode版本会比主网高，得到的结果均为当前最新发布版本。 3.2 区块高度 使用代码如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); if(chain3.isConnected()){ console.log(chain3.mc.blockNumber); } 输出结果：与浏览器同步较好。 以上测试，及部分chain3的基础使用（如获取账号balance等），使用方式与本地节点相同，均输出正确结果。 该步骤测试运行多次，快的时候1秒返回结果，慢的时候需要三十多秒。 &nbsp; 4.发送签名交易 此处测试过程使用本文第二节生成的账号私钥、地址。 先向该地址发送0.5个mc；然后运行以下代码，使用sendRawTransaction发送一个签名交易，该笔交易发送0.2个mc。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); var address = &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; var account = {address:&quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;,secret:&quot;6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8&quot;}; var toAddress = &quot;0x68986c1bcd54ae5dae69310fc64ea544ff1d56c4&quot;; var amount = 0.2; send(chain3, account.address, account.secret, toAddress, amount, txCount = -1) function send(chain3, fromAddress, fromSecret, toAddress, amount, txCount = -1){ var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress); console.log(&quot;Get tx account&quot;, txcount); var gasPrice = 25000000000; var gasLimit = 100000; var value = chain3.toSha(amount, &#39;mc&#39;); var gasTotal = gasPrice * gasLimit + Number(value); console.log(gasPrice, gasLimit, value, chain3.fromSha(gasTotal, &#39;mc&#39;)); var rawTx = { from: fromAddress, to: toAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), value: chain3.intToHex(value), shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); return hash; }else{ console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); } }); } 输出结果： 该步骤测试运行多次，均成功返回结果。 到浏览器查询签名交易发送情况： &nbsp; 5.调用合约 为了测试的方便，该步骤使用一个已经部署好的erc20合约。 在对合约的调用中，有很多调用不需要使用私钥签名，比如获取标准erc20合约的基本属性和balance的调用。 5.1 给新账号发送token 给新账号0xd3ab5cdba1d540fb049b88e05241b3393e52e230发送100个KFZT（标准erc20 token，合约地址看代码）。 5.2 查询账号里的token余额 使用gateway节点，node环境运行以下代码，实现对合约的调用，该调用会查询到账号的token余额，不需要签名。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96A95D8d48f1679&quot;; var address = &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; var abiString = &#39;[ { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;name&quot;,.......... { &quot;indexed&quot;: true, &quot;name&quot;: &quot;_spender&quot;, &quot;type&quot;: &quot;address&quot; }, { &quot;indexed&quot;: false, &quot;name&quot;: &quot;_value&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;Approval&quot;, &quot;type&quot;: &quot;event&quot; } ]&#39;; //调用erc20合约 //基本属性 callContract2(chain3, contractAddress, address, abiString); function callContract2(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(JSON.stringify(token.totalSupply())); console.log(JSON.stringify(token.name())); console.log(JSON.stringify(token.decimals())); console.log(JSON.stringify(token.symbol())); } //调用erc20合约 //查询余额 callContract(chain3, contractAddress, address, abiString); function callContract(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); token.balanceOf.call(address, function(err, result){ console.log(err, JSON.stringify(result)); }); } 输出结果： 该步骤测试运行多次，合约的四个属性都在1秒内返回，而账号token的balance值返回结果均在30多秒。 5.2 发回token 使用gateway节点，node环境运行以下代码，实现对合约的调用，将10个KFZT发回原账号，该调用需要私钥签名。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96A95D8d48f1679&quot;; var address = &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; var account = {address:&quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;,secret:&quot;6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8&quot;}; var abiString = &#39;[ { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;name&quot;,...... { &quot;indexed&quot;: true, &quot;name&quot;: &quot;_spender&quot;, &quot;type&quot;: &quot;address&quot; }, { &quot;indexed&quot;: false, &quot;name&quot;: &quot;_value&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;Approval&quot;, &quot;type&quot;: &quot;event&quot; } ]&#39;; //调用erc20合约 //发送token var amount = 10; //token的最小单位 var anotherAddress = &quot;0x68986c1BCD54Ae5dAe69310fC64Ea544FF1D56C4&quot;; callContract1(chain3, contractAddress, account, abiString, anotherAddress, amount); function callContract1(chain3, contractAddress, account, abiString, anotherAddress, amount){ var address = account.address; var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); var data = token.transfer.getData(anotherAddress, amount); console.log(&#39;data&#39;, data); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(100000), to: contractAddress, data: data, chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); var filter = chain3.mc.filter(&#39;latest&#39;); filter.watch(function(error, result) { var receipt = chain3.mc.getTransaction(hash); if (!error &amp;&amp; receipt &amp;&amp; receipt.blockNumber != null) { console.log(&quot;done.&quot;); filter.stopWatching(); process.exit(0); } }); }else{ console.log(&quot;error:&quot;, err.message); } }); } 输出结果： 该步骤测试运行多次，输出结果至succeed在2秒左右，至done均在60秒以上。 &nbsp; 6.使用RPC 此处测试简单的RPC调用： var request = require(&#39;request&#39;); var url = &quot;http://gateway.moac.io/mainnet&quot;; var requestData = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_gasPrice&quot;,&quot;params&quot;:[],&quot;id&quot;:99}; httprequest(url,requestData); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; 输出结果： 该步骤测试运行多次，返回结果在2秒内。 其他json rpc的使用参考：https://github.com/MOACChain/moac-core/wiki/JSON-RPC。 &nbsp; 本次测试结论： &nbsp; &nbsp; &nbsp; 1.对于许可的功能（主要是RPC和Chain3的调用），可以提供最新版的、稳定的墨客节点功能； &nbsp; &nbsp; &nbsp; 2.实测中，所有查询及签名交易均成功； &nbsp; &nbsp; &nbsp; 3.实测中，与本地节点比较，有延迟现象存在，但没有出现无法连接Vnode的情况。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/10/31/e4ac01be7e4e2b6203469b89dd8b5152.html" />
<meta property="og:url" content="https://mlh.app/2018/10/31/e4ac01be7e4e2b6203469b89dd8b5152.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-10-31T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/83582762 2018-10-31，MOAC推出官方公共节点，https://gateway.moac.io。 本文测试环境：Windows 10 + node Ver8.11.1 + chain3 Ver0.1.8。 1.介绍 moac gateway是一个托管的墨客节点集群，为用户提供公开的墨客区块链主网和测试网节点。 出于安全原因，gateway不管理用户的私钥，这意味着gateway不能代表用户签署交易。 因此，在使用chain3的过程中，不能通过sendTransaction、而只能使用sendRawTransaction发出交易。 1.1 主要特性（优势）： 实现不同地理位置的服务器负载均衡； 实现MOAC区块链上的全功能RPC方法； 不再需要技术开发人员部署MOAC Vnode节点； 使用与本地节点完全一样的方式调用Chain3； 保持与最新的MOAC发布版本一致。 1.2 使用方法： 通过以下脚本，可以使用http://gateway.moac.io代替自己的Vnode节点。 之前使用代码连接本地Vnode节点方式： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); 改为通过以下方式连接公共Vnode节点： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/testnet&#39;)); //For testnet var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); //For mainnet 1.3 不足： 使用gateway跟使用本地Vnode节点相比，也有一些不足： 会有延迟，因为用户网络原因，可能有意想不到的无法连接Vnode情况； 无法按自己的方式启动节点，无法看到Vnode界面的反馈，有时候这些反馈很有用且很关键； 某些特殊应用不支持，比如试图使用http://wallet.moac.io部署合约。 &nbsp; 2.账号管理 moac gateway提供Vnode功能的时候，从安全角度考虑，没有启动personal，因此不能通过persoanl.newAccount()创建账号。 鉴于moac gateway需要私钥签名才能发送交易，这里给出管理墨客账号的部分代码。 2.1 安装依赖模块ethereumjs-wallet 在具有管理员权限的控制台中，运行以下命令安装ethereumjs-wallet。 C:\\&gt;npm install -g ethereumjs-wallet 此处注意：如果是在Windows上安装并且遇到错误，则可能需要安装Windows构建工具。 在具有管理员权限的控制台中，运行以下命令安装Windows构建工具，然后再尝试安装依赖模块。 C:\\&gt;npm install -g windows-build-tools 2.2 离线生成账号privateKey 方法一：node环境下运行以下代码，可以离线生成账号，分别得到私钥、公钥和地址。 var crypto = require(&#39;crypto&#39;); //npm install -g crypto var secp256k1 = require(&#39;secp256k1&#39;); //npm install -g secp256k1 var keccak = require(&#39;keccak&#39;); //npm install -g keccak //获得随机的32个字节作为私钥，在使用中，请注意随机数来源的安全 var privateKey = crypto.randomBytes(32); //获得公钥 var publicKey = secp256k1.publicKeyCreate(privateKey, false).slice(1); //获得地址 var address = keccak(&#39;keccak256&#39;).update(publicKey).digest().slice(-20); console.log(&#39;public key&#39;, publicKey.toString(&#39;hex&#39;)); console.log(&#39;private key&#39;, privateKey.toString(&#39;hex&#39;)); console.log(&#39;address&#39;, &#39;0x&#39; + address.toString(&#39;hex&#39;)); 方法二：node环境下运行以下代码，可以离线生成账号，得到私钥和地址。 var Wallet = require(&#39;ethereumjs-wallet&#39;); //npm install -g ethereumjs-wallet const wallet = Wallet.generate(); console.log(&quot;privateKey: &quot; + wallet.getPrivateKeyString()); console.log(&quot;address: &quot; + wallet.getAddressString()); 运行结果： 2.3 从privateKey得到keystore node环境下运行以下代码，可以从privateKey得到keystore文件内容： var Wallet = require(&#39;ethereumjs-wallet&#39;); var key = Buffer.from(&#39;6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8&#39;, &#39;hex&#39;); //填入privateKey，没有0x var wallet = Wallet.fromPrivateKey(key); var keystore = wallet.toV3String(&#39;123456&#39;); //填入要设置的密码，该密码可以从keystore得到privateKey console.log(&quot;wallet: &quot; + JSON.stringify(keystore)); 运行结果： 将输出内容（wallet后面双引号中的内容），去掉所有“\\”符号，新建一个文件，保存到D盘keystore目录下。 2.4 从keystore得到privateKey 从keystore得到privateKey需要提供账号密码。 node环境下运行以下代码，可以从keystore文件得到privateKey： var keythereum = require(&quot;keythereum&quot;); //npm install -g keythereum var datadir = &quot;D:&quot;; //此处需默认保存在keystore目录下，也就是keystore文件实际保存在D:\\keystore目录下 var address= &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; const password = &quot;123456&quot;; var keyObject = keythereum.importFromFile(address, datadir); var privateKey = keythereum.recover(password, keyObject); console.log(privateKey.toString(&#39;hex&#39;)); 运行结果： 正确地从keystore得到privateKey。 &nbsp; 3.基础使用测试 使用公共节点，用户通常有些信息需要拿到，而不能像本地节点那样是当然知道的，包括节点版本信息及当前区块高度等。 3.1 版本信息 使用代码如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;https://gateway.moac.io/mainnet&#39;)); var version = chain3.version.api; console.log(version); var version = chain3.version.node; console.log(version); var version = chain3.version.network; console.log(version); 输出结果： 前面是主网信息，后面是测试网信息，通常测试网的Vnode版本会比主网高，得到的结果均为当前最新发布版本。 3.2 区块高度 使用代码如下： var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); if(chain3.isConnected()){ console.log(chain3.mc.blockNumber); } 输出结果：与浏览器同步较好。 以上测试，及部分chain3的基础使用（如获取账号balance等），使用方式与本地节点相同，均输出正确结果。 该步骤测试运行多次，快的时候1秒返回结果，慢的时候需要三十多秒。 &nbsp; 4.发送签名交易 此处测试过程使用本文第二节生成的账号私钥、地址。 先向该地址发送0.5个mc；然后运行以下代码，使用sendRawTransaction发送一个签名交易，该笔交易发送0.2个mc。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); var address = &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; var account = {address:&quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;,secret:&quot;6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8&quot;}; var toAddress = &quot;0x68986c1bcd54ae5dae69310fc64ea544ff1d56c4&quot;; var amount = 0.2; send(chain3, account.address, account.secret, toAddress, amount, txCount = -1) function send(chain3, fromAddress, fromSecret, toAddress, amount, txCount = -1){ var mc = chain3.mc; var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress); console.log(&quot;Get tx account&quot;, txcount); var gasPrice = 25000000000; var gasLimit = 100000; var value = chain3.toSha(amount, &#39;mc&#39;); var gasTotal = gasPrice * gasLimit + Number(value); console.log(gasPrice, gasLimit, value, chain3.fromSha(gasTotal, &#39;mc&#39;)); var rawTx = { from: fromAddress, to: toAddress, nonce: chain3.intToHex(txcount), gasPrice: chain3.intToHex(gasPrice), gasLimit: chain3.intToHex(gasLimit), value: chain3.intToHex(value), shardingFlag: 0, //default is global contract chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, fromSecret); mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); return hash; }else{ console.log(&quot;error:&quot;, err); console.log(&#39;raw tx:&#39;, rawTx); } }); } 输出结果： 该步骤测试运行多次，均成功返回结果。 到浏览器查询签名交易发送情况： &nbsp; 5.调用合约 为了测试的方便，该步骤使用一个已经部署好的erc20合约。 在对合约的调用中，有很多调用不需要使用私钥签名，比如获取标准erc20合约的基本属性和balance的调用。 5.1 给新账号发送token 给新账号0xd3ab5cdba1d540fb049b88e05241b3393e52e230发送100个KFZT（标准erc20 token，合约地址看代码）。 5.2 查询账号里的token余额 使用gateway节点，node环境运行以下代码，实现对合约的调用，该调用会查询到账号的token余额，不需要签名。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96A95D8d48f1679&quot;; var address = &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; var abiString = &#39;[ { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;name&quot;,.......... { &quot;indexed&quot;: true, &quot;name&quot;: &quot;_spender&quot;, &quot;type&quot;: &quot;address&quot; }, { &quot;indexed&quot;: false, &quot;name&quot;: &quot;_value&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;Approval&quot;, &quot;type&quot;: &quot;event&quot; } ]&#39;; //调用erc20合约 //基本属性 callContract2(chain3, contractAddress, address, abiString); function callContract2(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(JSON.stringify(token.totalSupply())); console.log(JSON.stringify(token.name())); console.log(JSON.stringify(token.decimals())); console.log(JSON.stringify(token.symbol())); } //调用erc20合约 //查询余额 callContract(chain3, contractAddress, address, abiString); function callContract(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); token.balanceOf.call(address, function(err, result){ console.log(err, JSON.stringify(result)); }); } 输出结果： 该步骤测试运行多次，合约的四个属性都在1秒内返回，而账号token的balance值返回结果均在30多秒。 5.2 发回token 使用gateway节点，node环境运行以下代码，实现对合约的调用，将10个KFZT发回原账号，该调用需要私钥签名。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://gateway.moac.io/mainnet&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96A95D8d48f1679&quot;; var address = &quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;; var account = {address:&quot;0xd3ab5cdba1d540fb049b88e05241b3393e52e230&quot;,secret:&quot;6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8&quot;}; var abiString = &#39;[ { &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;name&quot;,...... { &quot;indexed&quot;: true, &quot;name&quot;: &quot;_spender&quot;, &quot;type&quot;: &quot;address&quot; }, { &quot;indexed&quot;: false, &quot;name&quot;: &quot;_value&quot;, &quot;type&quot;: &quot;uint256&quot; } ], &quot;name&quot;: &quot;Approval&quot;, &quot;type&quot;: &quot;event&quot; } ]&#39;; //调用erc20合约 //发送token var amount = 10; //token的最小单位 var anotherAddress = &quot;0x68986c1BCD54Ae5dAe69310fC64Ea544FF1D56C4&quot;; callContract1(chain3, contractAddress, account, abiString, anotherAddress, amount); function callContract1(chain3, contractAddress, account, abiString, anotherAddress, amount){ var address = account.address; var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); var data = token.transfer.getData(anotherAddress, amount); console.log(&#39;data&#39;, data); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(100000), to: contractAddress, data: data, chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); var filter = chain3.mc.filter(&#39;latest&#39;); filter.watch(function(error, result) { var receipt = chain3.mc.getTransaction(hash); if (!error &amp;&amp; receipt &amp;&amp; receipt.blockNumber != null) { console.log(&quot;done.&quot;); filter.stopWatching(); process.exit(0); } }); }else{ console.log(&quot;error:&quot;, err.message); } }); } 输出结果： 该步骤测试运行多次，输出结果至succeed在2秒左右，至done均在60秒以上。 &nbsp; 6.使用RPC 此处测试简单的RPC调用： var request = require(&#39;request&#39;); var url = &quot;http://gateway.moac.io/mainnet&quot;; var requestData = {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;mc_gasPrice&quot;,&quot;params&quot;:[],&quot;id&quot;:99}; httprequest(url,requestData); function httprequest(url,data){ request({ url: url, method: &quot;POST&quot;, json: true, body: data }, function(error, response, result) { if (!error &amp;&amp; response.statusCode == 200) { console.log(result) // 请求成功的处理逻辑 } }); }; 输出结果： 该步骤测试运行多次，返回结果在2秒内。 其他json rpc的使用参考：https://github.com/MOACChain/moac-core/wiki/JSON-RPC。 &nbsp; 本次测试结论： &nbsp; &nbsp; &nbsp; 1.对于许可的功能（主要是RPC和Chain3的调用），可以提供最新版的、稳定的墨客节点功能； &nbsp; &nbsp; &nbsp; 2.实测中，所有查询及签名交易均成功； &nbsp; &nbsp; &nbsp; 3.实测中，与本地节点比较，有延迟现象存在，但没有出现无法连接Vnode的情况。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/10/31/e4ac01be7e4e2b6203469b89dd8b5152.html","headline":"第二十二篇 墨客区块链(MOAC BlockChain) 墨客公共节点：gateway","dateModified":"2018-10-31T00:00:00+08:00","datePublished":"2018-10-31T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/10/31/e4ac01be7e4e2b6203469b89dd8b5152.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>第二十二篇 墨客区块链(MOAC BlockChain) 墨客公共节点：gateway</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/83582762 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css"> 
 <div class="htmledit_views"> 
  <p>2018-10-31，MOAC推出官方公共节点，<a href="https://gateway.moac.io/" rel="nofollow">https://gateway.moac.io</a>。</p> 
  <p>本文测试环境：Windows 10 + node Ver8.11.1 + chain3 Ver0.1.8。</p> 
  <p><strong>1.介绍</strong></p> 
  <p>moac gateway是一个托管的墨客节点集群，为用户提供公开的墨客区块链主网和测试网节点。</p> 
  <p>出于安全原因，gateway不管理用户的私钥，这意味着gateway不能代表用户签署交易。</p> 
  <p>因此，在使用chain3的过程中，不能通过sendTransaction、而只能使用sendRawTransaction发出交易。</p> 
  <p><strong>1.1 主要特性（优势）：</strong></p> 
  <ol>
   <li>实现不同地理位置的服务器负载均衡；</li> 
   <li>实现MOAC区块链上的全功能RPC方法；</li> 
   <li>不再需要技术开发人员部署MOAC Vnode节点；</li> 
   <li>使用与本地节点完全一样的方式调用Chain3；</li> 
   <li>保持与最新的MOAC发布版本一致。</li> 
  </ol>
  <p><strong>1.2 使用方法：</strong></p> 
  <p>通过以下脚本，可以使用http://gateway.moac.io代替自己的Vnode节点。</p> 
  <p>之前使用代码连接本地Vnode节点方式：</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://localhost:8545'));</code></pre> 
  <p>改为通过以下方式连接公共Vnode节点：</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://gateway.moac.io/testnet'));  //For testnet
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://gateway.moac.io/mainnet'));  //For mainnet</code></pre> 
  <p><strong>1.3 不足：</strong></p> 
  <p>使用gateway跟使用本地Vnode节点相比，也有一些不足：</p> 
  <ol>
   <li>会有延迟，因为用户网络原因，可能有意想不到的无法连接Vnode情况；</li> 
   <li>无法按自己的方式启动节点，无法看到Vnode界面的反馈，有时候这些反馈很有用且很关键；</li> 
   <li>某些特殊应用不支持，比如试图使用<a href="http://wallet.moac.io/" rel="nofollow">http://wallet.moac.io</a>部署合约。</li> 
  </ol>
  <p>&nbsp;</p> 
  <p><strong>2.账号管理</strong></p> 
  <p>moac gateway提供Vnode功能的时候，从安全角度考虑，没有启动personal，因此不能通过persoanl.newAccount()创建账号。</p> 
  <p>鉴于moac gateway需要私钥签名才能发送交易，这里给出管理墨客账号的部分代码。</p> 
  <p><strong>2.1 安装依赖模块ethereumjs-wallet</strong></p> 
  <p>在具有管理员权限的控制台中，运行以下命令安装ethereumjs-wallet。</p> 
  <pre class="has">
<code>C:\&gt;npm install -g ethereumjs-wallet</code></pre> 
  <p>此处注意：如果是在Windows上安装并且遇到错误，则可能需要安装Windows构建工具。</p> 
  <p>在具有管理员权限的控制台中，运行以下命令安装Windows构建工具，然后再尝试安装依赖模块。</p> 
  <pre class="has">
<code>C:\&gt;npm install -g windows-build-tools</code></pre> 
  <p><strong>2.2 离线生成账号privateKey</strong></p> 
  <p>方法一：node环境下运行以下代码，可以离线生成账号，分别得到私钥、公钥和地址。</p> 
  <pre class="has">
<code>var crypto = require('crypto');         //npm install  -g crypto
var secp256k1 = require('secp256k1');   //npm install  -g secp256k1
var keccak = require('keccak');         //npm install  -g keccak

//获得随机的32个字节作为私钥，在使用中，请注意随机数来源的安全
var privateKey = crypto.randomBytes(32);
//获得公钥
var publicKey = secp256k1.publicKeyCreate(privateKey, false).slice(1);
//获得地址
var address = keccak('keccak256').update(publicKey).digest().slice(-20);

console.log('public key', publicKey.toString('hex'));
console.log('private key', privateKey.toString('hex'));
console.log('address', '0x' + address.toString('hex'));</code></pre> 
  <p>方法二：node环境下运行以下代码，可以离线生成账号，得到私钥和地址。</p> 
  <pre class="has">
<code>var Wallet = require('ethereumjs-wallet');    //npm install -g ethereumjs-wallet
const wallet = Wallet.generate();

console.log("privateKey: " + wallet.getPrivateKeyString());
console.log("address: " + wallet.getAddressString());</code></pre> 
  <p>运行结果：</p> 
  <p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181031161449539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1,size_16,color_FFFFFF,t_70"></p> 
  <p><strong>2.3 从privateKey得到keystore</strong></p> 
  <p>node环境下运行以下代码，可以从privateKey得到keystore文件内容：</p> 
  <pre class="has">
<code>var Wallet = require('ethereumjs-wallet');      
var key = Buffer.from('6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8', 'hex');  //填入privateKey，没有0x
var wallet = Wallet.fromPrivateKey(key);        
var keystore = wallet.toV3String('123456');    //填入要设置的密码，该密码可以从keystore得到privateKey
console.log("wallet: " + JSON.stringify(keystore));</code></pre> 
  <p>运行结果：</p> 
  <p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181031162359558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1,size_16,color_FFFFFF,t_70"></p> 
  <p>将输出内容（wallet后面双引号中的内容），去掉所有“\”符号，新建一个文件，保存到D盘keystore目录下。</p> 
  <p><strong>2.4 从keystore得到privateKey</strong></p> 
  <p>从keystore得到privateKey需要提供账号密码。</p> 
  <p>node环境下运行以下代码，可以从keystore文件得到privateKey：</p> 
  <pre class="has">
<code>var keythereum = require("keythereum");  //npm install -g keythereum
var datadir = "D:";                      //此处需默认保存在keystore目录下，也就是keystore文件实际保存在D:\keystore目录下
var address= "0xd3ab5cdba1d540fb049b88e05241b3393e52e230";
const password = "123456";

var keyObject = keythereum.importFromFile(address, datadir);
var privateKey = keythereum.recover(password, keyObject);
console.log(privateKey.toString('hex'));</code></pre> 
  <p>运行结果：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="190" src="https://img-blog.csdnimg.cn/20181031170804590.png" width="913"></p> 
  <p>正确地从keystore得到privateKey。</p> 
  <p>&nbsp;</p> 
  <p><strong>3.基础使用测试</strong></p> 
  <p>使用公共节点，用户通常有些信息需要拿到，而不能像本地节点那样是当然知道的，包括节点版本信息及当前区块高度等。</p> 
  <p><strong>3.1 版本信息</strong></p> 
  <p>使用代码如下：</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('https://gateway.moac.io/mainnet'));

var version = chain3.version.api;
console.log(version); 

var version = chain3.version.node;
console.log(version); 

var version = chain3.version.network;
console.log(version); </code></pre> 
  <p>输出结果：</p> 
  <p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181101104647840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1,size_16,color_FFFFFF,t_70"></p> 
  <p>前面是主网信息，后面是测试网信息，通常测试网的Vnode版本会比主网高，得到的结果均为当前最新发布版本。</p> 
  <p><strong>3.2 区块高度</strong></p> 
  <p>使用代码如下：</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://gateway.moac.io/mainnet'));

if(chain3.isConnected()){	
    console.log(chain3.mc.blockNumber);
}</code></pre> 
  <p>输出结果：与浏览器同步较好。</p> 
  <p><img alt="" class="has" src="https://img-blog.csdnimg.cn/2018110111295985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1,size_16,color_FFFFFF,t_70"></p> 
  <p>以上测试，及部分chain3的基础使用（如获取账号balance等），使用方式与本地节点相同，均输出正确结果。</p> 
  <p>该步骤测试运行多次，快的时候1秒返回结果，慢的时候需要三十多秒。</p> 
  <p>&nbsp;</p> 
  <p><strong>4.发送签名交易</strong></p> 
  <p>此处测试过程使用本文第二节生成的账号私钥、地址。</p> 
  <p>先向该地址发送0.5个mc；然后运行以下代码，使用sendRawTransaction发送一个签名交易，该笔交易发送0.2个mc。</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://gateway.moac.io/mainnet'));

var address = "0xd3ab5cdba1d540fb049b88e05241b3393e52e230";
var account = {address:"0xd3ab5cdba1d540fb049b88e05241b3393e52e230",secret:"6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8"};

var toAddress = "0x68986c1bcd54ae5dae69310fc64ea544ff1d56c4";
var amount = 0.2;

send(chain3, account.address, account.secret, toAddress, amount, txCount = -1)

function send(chain3, fromAddress, fromSecret, toAddress, amount, txCount = -1){
  var mc = chain3.mc;

  var txcount = txCount &gt;= 0 ? txCount : chain3.mc.getTransactionCount(fromAddress);
  console.log("Get tx account", txcount);

  var gasPrice = 25000000000;
  var gasLimit = 100000;
  var value = chain3.toSha(amount, 'mc');
  var gasTotal = gasPrice * gasLimit + Number(value);
  console.log(gasPrice, gasLimit, value, chain3.fromSha(gasTotal, 'mc'));

  var rawTx = {
    from: fromAddress,
    to: toAddress,
    nonce: chain3.intToHex(txcount),
    gasPrice: chain3.intToHex(gasPrice),
    gasLimit: chain3.intToHex(gasLimit),
    value: chain3.intToHex(value),
    shardingFlag: 0, //default is global contract
    chainId: chain3.version.network
  };

  var signedTx = chain3.signTransaction(rawTx, fromSecret);
  mc.sendRawTransaction(signedTx, function(err, hash) {
      if (!err){
          console.log("succeed: ", hash);
          return hash;
      }else{
          console.log("error:", err);
	        console.log('raw tx:', rawTx);
      }
  });
}</code></pre> 
  <p>输出结果：</p> 
  <p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181101125243792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1,size_16,color_FFFFFF,t_70"></p> 
  <p>该步骤测试运行多次，均成功返回结果。</p> 
  <p>到浏览器查询签名交易发送情况：</p> 
  <p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181101130805698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1,size_16,color_FFFFFF,t_70"></p> 
  <p>&nbsp;</p> 
  <p><strong>5.调用合约</strong></p> 
  <p>为了测试的方便，该步骤使用一个已经部署好的erc20合约。</p> 
  <p>在对合约的调用中，有很多调用不需要使用私钥签名，比如获取标准erc20合约的基本属性和balance的调用。</p> 
  <p><strong>5.1 给新账号发送token</strong></p> 
  <p>给新账号0xd3ab5cdba1d540fb049b88e05241b3393e52e230发送100个KFZT（标准erc20 token，合约地址看代码）。</p> 
  <p><strong>5.2 查询账号里的token余额</strong></p> 
  <p>使用gateway节点，node环境运行以下代码，实现对合约的调用，该调用会查询到账号的token余额，不需要签名。</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://gateway.moac.io/mainnet'));

var contractAddress = "0xA2580D58A58998ca06e6f5b2A96A95D8d48f1679";
var address = "0xd3ab5cdba1d540fb049b88e05241b3393e52e230";
var abiString = '[ { "constant": true, "inputs": [], "name": "name",.......... { "indexed": true, "name": "_spender", "type": "address" }, { "indexed": false, "name": "_value", "type": "uint256" } ], "name": "Approval", "type": "event" } ]';

//调用erc20合约
//基本属性
callContract2(chain3, contractAddress, address, abiString);

function callContract2(chain3, contractAddress, address, abiString){
  var abi = JSON.parse(abiString);
  var contract = chain3.mc.contract(abi);
  var token = contract.at(contractAddress);
  
  console.log(JSON.stringify(token.totalSupply()));
  console.log(JSON.stringify(token.name()));
  console.log(JSON.stringify(token.decimals()));
  console.log(JSON.stringify(token.symbol()));
}

//调用erc20合约
//查询余额
callContract(chain3, contractAddress, address, abiString);

function callContract(chain3, contractAddress, address, abiString){
  var abi = JSON.parse(abiString);
  var contract = chain3.mc.contract(abi);
  var token = contract.at(contractAddress);
  token.balanceOf.call(address, function(err, result){
    console.log(err, JSON.stringify(result));
  });
}</code></pre> 
  <p>输出结果：</p> 
  <p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181102095232982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1,size_16,color_FFFFFF,t_70"></p> 
  <p>该步骤测试运行多次，合约的四个属性都在1秒内返回，而账号token的balance值返回结果均在30多秒。</p> 
  <p><strong>5.2 发回token</strong></p> 
  <p>使用gateway节点，node环境运行以下代码，实现对合约的调用，将10个KFZT发回原账号，该调用需要私钥签名。</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://gateway.moac.io/mainnet'));

var contractAddress = "0xA2580D58A58998ca06e6f5b2A96A95D8d48f1679";
var address = "0xd3ab5cdba1d540fb049b88e05241b3393e52e230";
var account = {address:"0xd3ab5cdba1d540fb049b88e05241b3393e52e230",secret:"6bee6f2a97fc1e2e9d9aa041dbdcebbd50c2ae3488070e01e47dcd38e5840ff8"};
var abiString = '[ { "constant": true, "inputs": [], "name": "name",...... { "indexed": true, "name": "_spender", "type": "address" }, { "indexed": false, "name": "_value", "type": "uint256" } ], "name": "Approval", "type": "event" } ]';

//调用erc20合约
//发送token
var amount = 10;    //token的最小单位
var anotherAddress = "0x68986c1BCD54Ae5dAe69310fC64Ea544FF1D56C4";
callContract1(chain3, contractAddress, account, abiString, anotherAddress, amount);

function callContract1(chain3, contractAddress, account, abiString, anotherAddress, amount){
  var address = account.address;
  var abi = JSON.parse(abiString);
  var contract = chain3.mc.contract(abi);
  var token = contract.at(contractAddress);

  var data = token.transfer.getData(anotherAddress, amount);
  console.log('data', data);
  var txCount = chain3.mc.getTransactionCount(account.address);
  var rawTx = {
    nonce: chain3.intToHex(txCount),
    gasPrice: chain3.intToHex(25000000000),
    gasLimit: chain3.intToHex(100000),
    to: contractAddress,
    data: data,
    chainId: chain3.version.network
  };
  var signedTx = chain3.signTransaction(rawTx, account.secret);
  chain3.mc.sendRawTransaction(signedTx, function(err, hash) {
      if (!err){
          console.log("succeed: ", hash);
          var filter = chain3.mc.filter('latest');
          filter.watch(function(error, result) {
            var receipt = chain3.mc.getTransaction(hash);
            if (!error &amp;&amp; receipt &amp;&amp; receipt.blockNumber != null) {
              console.log("done.");
              filter.stopWatching();
              process.exit(0);
            }
          });
      }else{
          console.log("error:", err.message);
      }
  });
}</code></pre> 
  <p>输出结果：</p> 
  <p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181102110725449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1,size_16,color_FFFFFF,t_70"></p> 
  <p>该步骤测试运行多次，输出结果至succeed在2秒左右，至done均在60秒以上。</p> 
  <p>&nbsp;</p> 
  <p><strong>6.使用RPC</strong></p> 
  <p>此处测试简单的RPC调用：</p> 
  <pre class="has">
<code>var request = require('request');
var url = "http://gateway.moac.io/mainnet";

var requestData = {"jsonrpc":"2.0","method":"mc_gasPrice","params":[],"id":99};

httprequest(url,requestData);

function httprequest(url,data){
	request({
		url: url,
		method: "POST",
		json: true,
		body: data
	}, function(error, response, result) {
		if (!error &amp;&amp; response.statusCode == 200) {
			console.log(result) // 请求成功的处理逻辑
		}
	});
};</code></pre> 
  <p>输出结果：</p> 
  <p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181102173301238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1,size_16,color_FFFFFF,t_70"></p> 
  <p>该步骤测试运行多次，返回结果在2秒内。</p> 
  <p>其他json rpc的使用参考：<a href="https://github.com/MOACChain/moac-core/wiki/JSON-RPC" rel="nofollow">https://github.com/MOACChain/moac-core/wiki/JSON-RPC</a>。</p> 
  <p>&nbsp;</p> 
  <p><span style="color:#f33b45;"><strong>本次测试结论：</strong></span></p> 
  <p>&nbsp; &nbsp; &nbsp; 1.对于许可的功能（主要是RPC和Chain3的调用），可以提供最新版的、稳定的墨客节点功能；</p> 
  <p>&nbsp; &nbsp; &nbsp; 2.实测中，所有查询及签名交易均成功；</p> 
  <p>&nbsp; &nbsp; &nbsp; 3.实测中，与本地节点比较，有延迟现象存在，但没有出现无法连接Vnode的情况。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lyq13573221675/article/details/83582762,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lyq13573221675/article/details/83582762,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
