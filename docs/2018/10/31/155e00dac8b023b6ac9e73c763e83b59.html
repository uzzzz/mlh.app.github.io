<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>从零开始学习比特币开发（九）–P2P 网络建立之消息处理中篇 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="从零开始学习比特币开发（九）–P2P 网络建立之消息处理中篇" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="P2P 网络的建立是在系统启动的第 12 步，最后时刻调用 CConnman::Start 方法开始的。 恭喜你越来越接近比特币的核心了，在上篇中，我们主要讲解了比特币的消息处理线程，接下来，在下篇中，将以具体的比特币消息即比特币协义分析为主。针对比特币的协义，为了从逻辑上进行理解，我们并没有完全按照代码的顺序，而是按照某个具体的消息的 请求----响应 模式来进行分析。 下面我们来看比特币协义相关的代码。 1、节点握手处理 1.1、接收 version 消息 节点作为服务器，处理客户端节点发送的版本请求。 版本消息是每个对等节点都要发送的消息，并且是最先发送、只能发送一次的消息，对等节点双方都要发送这个消息和下面的确认消息，只有双方都发送过版本消息，并且收到确认消息，对等节点间才可以进行后续消息发送。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1621 行。具体处理如下： 检查对等节点的版本字段是否已经设置，如果已经设置，即远程对等节点已经发送过版本消息，那么：在开启 BIP 161 情况下发送拒绝消息；对远程对待节点进行处罚。 if (pfrom-&gt;nVersion != 0) { if (enable_bip61) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(&quot;Duplicate version message&quot;))); } LOCK(cs_main); Misbehaving(pfrom-&gt;GetId(), 1); return false; } Misbehaving 方法进行处理，具体处理如下： 检查是否要增加节点的不良积分，如果不是，即增加的积分数量为 0，则直接退出。 取得节点的状态对象。如果不存在，则直接退出。 把节点的状态对象的不良积分加上要增加的不良积分。 比较节点的不良积分与默认的或用户通过 -banscore 参数指定的不良积分进行比较。如果在增加当前不良积分后大于等于设置的不良积分，并且增加之前小于设置的不良积分，那么设置状态对象为应该禁止，即设置 fShouldBan 属性为真。 这个方法的代码如下： void Misbehaving(NodeId pnode, int howmuch, const std::string&amp; message) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { if (howmuch == 0) return; CNodeState *state = State(pnode); if (state == nullptr) return; state-&gt;nMisbehavior += howmuch; int banscore = gArgs.GetArg(&quot;-banscore&quot;, DEFAULT_BANSCORE_THRESHOLD); std::string message_prefixed = message.empty() ? &quot;&quot; : (&quot;: &quot; + message); if (state-&gt;nMisbehavior &gt;= banscore &amp;&amp; state-&gt;nMisbehavior - howmuch &lt; banscore) { LogPrint(BCLog::NET, &quot;%s: %s peer=%d (%d -&gt; %d) BAN THRESHOLD EXCEEDED%s\n&quot;, __func__, state-&gt;name, pnode, state-&gt;nMisbehavior-howmuch, state-&gt;nMisbehavior, message_prefixed); state-&gt;fShouldBan = true; } else LogPrint(BCLog::NET, &quot;%s: %s peer=%d (%d -&gt; %d)%s\n&quot;, __func__, state-&gt;name, pnode, state-&gt;nMisbehavior-howmuch, state-&gt;nMisbehavior, message_prefixed); } 从输入流中取得远程对等节点发送的版本信息、支持的服务信息、发送时间、显示地址。 vRecv &gt;&gt; nVersion &gt;&gt; nServiceInt &gt;&gt; nTime &gt;&gt; addrMe; nSendVersion = std::min(nVersion, PROTOCOL_VERSION); nServices = ServiceFlags(nServiceInt); 如果对等节点是出站的，调用 CConnman 对象的 SetServices 方法，设置对等节点所支持的服务。 if (!pfrom-&gt;fInbound) { connman-&gt;SetServices(pfrom-&gt;addr, nServices); } 方法内部最终会获取节点的地址信息对象，然后设置其支持的服务属性。 如果对等节点是出站的，且不是临时的试探者，且不是手动指定的，且与本地服务不匹配，那么：在开启 BIP 161 情况下发送拒绝消息；然后设置远程对待节点为断开；然后返回假。 if (!pfrom-&gt;fInbound &amp;&amp; !pfrom-&gt;fFeeler &amp;&amp; !pfrom-&gt;m_manual_connection &amp;&amp; !HasAllDesirableServiceFlags(nServices)) { LogPrint(BCLog::NET, &quot;peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\n&quot;, pfrom-&gt;GetId(), nServices, GetDesirableServiceFlags(nServices)); if (enable_bip61) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,strprintf(&quot;Expected to offer services %08x&quot;, GetDesirableServiceFlags(nServices)))); } pfrom-&gt;fDisconnect = true; return false; } 如果发送的版本的小于协义规定的最小版本 MIN_PEER_PROTO_VERSION，那么：在开启 BIP 161 情况下发送拒绝消息；然后设置远程对待节点为断开；然后返回假。 if (nVersion &lt; MIN_PEER_PROTO_VERSION) { // disconnect from peers older than this proto version LogPrint(BCLog::NET, &quot;peer=%d using obsolete version %i; disconnecting\n&quot;, pfrom-&gt;GetId(), nVersion); if (enable_bip61) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE, strprintf(&quot;Version must be %d or greater&quot;, MIN_PEER_PROTO_VERSION))); } pfrom-&gt;fDisconnect = true; return false; } 如果输入流不为空，则从流中依次取得 addrFrom、nNonce、strSubVer（客户端字符串）、nStartingHeight（客户端区块链的高度）、fRelay等信息。 if (!vRecv.empty()) vRecv &gt;&gt; addrFrom &gt;&gt; nNonce; if (!vRecv.empty()) { vRecv &gt;&gt; LIMITED_STRING(strSubVer, MAX_SUBVERSION_LENGTH); cleanSubVer = SanitizeString(strSubVer); } if (!vRecv.empty()) { vRecv &gt;&gt; nStartingHeight; } if (!vRecv.empty()) vRecv &gt;&gt; fRelay; 如果对等节点节点是入站节点，且连接到自身，那么设置远程对待节点为断开，并返回真。 if (pfrom-&gt;fInbound &amp;&amp; !connman-&gt;CheckIncomingNonce(nNonce)) { LogPrintf(&quot;connected to self at %s, disconnecting\n&quot;, pfrom-&gt;addr.ToString()); pfrom-&gt;fDisconnect = true; return true; } 如果对等节点是入站节点，且其地址是可路由的，那么调用 SeenLocal 方法进行处理。 if (pfrom-&gt;fInbound &amp;&amp; addrMe.IsRoutable()) { SeenLocal(addrMe); } 在 SeenLocal 方法中，如果这个地址在 mapLocalHost 集合中存在，那么设置其对应的 LocalServiceInfo 对象的 nScore 加1。如晨不存在，则直接返回真。 bool SeenLocal(const CService&amp; addr) { { LOCK(cs_mapLocalHost); if (mapLocalHost.count(addr) == 0) return false; mapLocalHost[addr].nScore++; } return true; } 如果是对等节点是入站节点，则调用 PushNodeVersion 方法，发送自身的版本信息给远程对等节点。 节点在收到远程对待节点发送来的版本消息，并且经过检查没问题之后，自身发送一个版本消息给对远程对待节点。 调用 CConnman 对象的 PushMessage 方法，发送版本确认包。 因为当前的 version 消息，是别的节点请求我们的，当我们允许其连接时，发送版本确认包。注意，只有在双方都发送版本确认包之后，双方才可以互相发送消息。 设置对等节点的服务属性、保存地址、对等节点运行的客户端、对等节点区块链的高度、版本等。如果对等节点隔离见证服务，则设置对等节点对应的状态对象的相关属性为真。 pfrom-&gt;nServices = nServices; pfrom-&gt;SetAddrLocal(addrMe); { LOCK(pfrom-&gt;cs_SubVer); pfrom-&gt;strSubVer = strSubVer; pfrom-&gt;cleanSubVer = cleanSubVer; } pfrom-&gt;nStartingHeight = nStartingHeight; pfrom-&gt;fClient = (!(nServices &amp; NODE_NETWORK) &amp;&amp; !(nServices &amp; NODE_NETWORK_LIMITED)); pfrom-&gt;m_limited_node = (!(nServices &amp; NODE_NETWORK) &amp;&amp; (nServices &amp; NODE_NETWORK_LIMITED)); pfrom-&gt;fRelayTxes = fRelay; pfrom-&gt;SetSendVersion(nSendVersion); pfrom-&gt;nVersion = nVersion; 调用 UpdatePreferredDownload 方法，将对等节点设为可能的首先下载节点。 如果节点是出站的或者在白名单中，并且可以提供区块服务，并且 fOneShot 属性为假，即可作为首选下载节点。 如果对等节点不是入站节点，进行如下处理。 如果对等节点不是孤立的，并且不需要进行IBD下载（调用 IsInitialBlockDownload 函数进行判断，通常第一次启动或在常时间离线，比如24小时，有大师区块需要下载时，本方法返回真），那么： 调用 GetLocalAddress 方法，获取对该对等节点来说是最佳的地址。 如果找到的地址是可路由的，那么调用对等节点的 PushAddress 方法，把找到的地址保存在 vAddrToSend 集合中。 否则，调用 IsPeerAddrLocalGood 测试远程对等节点看到的我们的外部IP是否可以路由。如果可以路由，那么调用对等节点的 PushAddress 方法，把地址保存在 vAddrToSend 集合中。 以上代码如下： if (fListen &amp;&amp; !IsInitialBlockDownload()) { CAddress addr = GetLocalAddress(&amp;pfrom-&gt;addr, pfrom-&gt;GetLocalServices()); FastRandomContext insecure_rand; if (addr.IsRoutable()) { LogPrint(BCLog::NET, &quot;ProcessMessages: advertising address %s\n&quot;, addr.ToString()); pfrom-&gt;PushAddress(addr, insecure_rand); } else if (IsPeerAddrLocalGood(pfrom)) { addr.SetIP(addrMe); LogPrint(BCLog::NET, &quot;ProcessMessages: advertising address %s\n&quot;, addr.ToString()); pfrom-&gt;PushAddress(addr, insecure_rand); } } 如果需要，比如：本地保存的远程地址少于 1000个，那么调用 PushMessage 方法，请求远程节点发送更多的地址，即发送getaddr 消息。然后把请求地址的标志设置为真。 if (pfrom-&gt;fOneShot || pfrom-&gt;nVersion &gt;= CADDR_TIME_VERSION || connman-&gt;GetAddressCount() &lt; 1000) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR)); pfrom-&gt;fGetAddr = true; } 调用 MarkAddressGood 方法，保存远程对等节点，表明它是可访问的。 connman-&gt;MarkAddressGood(pfrom-&gt;addr); 如果远程对等节点的版本小于 70012，则发送一个 alert 消息。 if (pfrom-&gt;nVersion &lt;= 70012) { CDataStream finalAlert(ParseHex(&quot;60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50&quot;), SER_NETWORK, PROTOCOL_VERSION); connman-&gt;PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(&quot;alert&quot;, finalAlert)); } 如果节点是临时引导节点，则断开节点，即设置节点的断开属性为真。 if (pfrom-&gt;fFeeler) { assert(pfrom-&gt;fInbound == false); pfrom-&gt;fDisconnect = true; } 版本消息处理完成，返回真。 1.2、接收 verack 消息 节点作为客户端，处理服务器节点发送的版本响应消息，即版本确认消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1805 行。具体处理过程如下： 设置接收到的版本确认消息中的版本号。 pfrom-&gt;SetRecvVersion(std::min(pfrom-&gt;nVersion.load(), PROTOCOL_VERSION)); 如果对等节点不是入站节点，设置对等节点的状态对象的当前连接属性为真。 if (!pfrom-&gt;fInbound) { LOCK(cs_main); State(pfrom-&gt;GetId())-&gt;fCurrentlyConnected = true; } 如果对等节点的版本大于支持使用区块头部来公告区块的最小版本（SENDHEADERS_VERSION = 70012），那么： 调用 PushMessage 方法发送 sendheaders 消息，通知远程对等节点我们更愿意通过 headers 消息来接收新区块的公告，而不是 inv 消息。 这样以后当有新区块需要公告时，远程对等就会通过 headers 消息把区块头部先发送给我们，当我们再次请求时才会发送完整的区块。 如果对等节点的版本大于支持紧凑区块的最小版本（SHORT_IDS_BLOCKS_VERSION = 70014），那么分两种情况处理。 第一种情况，如果同时支持闪电网络，那么给对等节点发送一个紧凑区块版本为 2 的 sendcmpct 消息。 第二种情况，如果不支持闪电网络，那么给对等节点发送一个紧凑区块版本为 1 的 sendcmpct 消息。 无论哪一种情况，远程对等节点以后都会向本节点发送紧凑区块。 代码如下： if (pfrom-&gt;nVersion &gt;= SHORT_IDS_BLOCKS_VERSION) { bool fAnnounceUsingCMPCTBLOCK = false; uint64_t nCMPCTBLOCKVersion = 2; if (pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS) connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion)); nCMPCTBLOCKVersion = 1; connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion)); } 设置对等节点完全成功连接的标志为真，然后返回真。 pfrom-&gt;fSuccessfullyConnected = true; return true; 只有在对等节点双方都各自发送版本消息和确认消息之后，双方才真正建立起连接关系，才可以进行后续的交互，比如请求数据消息等。 2、保持连接的处理 因为在比特币网络中，任何一个节点都可以随时加入网络，也可以随时离开网络，所以两个连接的节点需要定时互相发送 ping 和 pong 来确保接点可以连接，如果在特定的时间内没有 ping 消息，节点即可认为连接已经断开。 2.1、ping 消息 这个消息比较简单，不作具体解释，代码如下： if (strCommand == NetMsgType::PING) { if (pfrom-&gt;nVersion &gt; BIP0031_VERSION) { uint64_t nonce = 0; vRecv &gt;&gt; nonce; connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce)); } return true; } 2.1、pong 消息 这个消息也比较简单，不作具体解释，代码如下： if (strCommand == NetMsgType::PONG) { int64_t pingUsecEnd = nTimeReceived; uint64_t nonce = 0; size_t nAvail = vRecv.in_avail(); bool bPingFinished = false; std::string sProblem; if (nAvail &gt;= sizeof(nonce)) { vRecv &gt;&gt; nonce; if (pfrom-&gt;nPingNonceSent != 0) { if (nonce == pfrom-&gt;nPingNonceSent) { bPingFinished = true; int64_t pingUsecTime = pingUsecEnd - pfrom-&gt;nPingUsecStart; if (pingUsecTime &gt; 0) { pfrom-&gt;nPingUsecTime = pingUsecTime; pfrom-&gt;nMinPingUsecTime = std::min(pfrom-&gt;nMinPingUsecTime.load(), pingUsecTime); } else { sProblem = &quot;Timing mishap&quot;; } } else { sProblem = &quot;Nonce mismatch&quot;; if (nonce == 0) { bPingFinished = true; sProblem = &quot;Nonce zero&quot;; } } } else { sProblem = &quot;Unsolicited pong without ping&quot;; } } else { bPingFinished = true; sProblem = &quot;Short payload&quot;; } if (bPingFinished) { pfrom-&gt;nPingNonceSent = 0; } return true; } 3、获取更多地址的处理 如果对等节点需要更多地址时，会发送 getaddr 消息请求远程对等节点发送更多的地址，当远程对等节点收到请求后，会通过发送 addr 消息传递更多的地址。 3.1、getaddr 消息 节点作为服务器，响应客户端节点发送的请求地址消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2728 行。具体处理如下： 如果对等节点不是入站节点，则忽略该请求，并返回。 if (!pfrom-&gt;fInbound) { return true; } 如果对等节点已发送过请求地址，即远程对等节点重复请求地址，则忽略该请求，并返回。 if (pfrom-&gt;fSentAddr) { return true; } 设置对等节点已发送过请求地址标志为真。清空对等节点的 vAddrToSend 集合。 pfrom-&gt;fSentAddr = true; pfrom-&gt;vAddrToSend.clear(); 调用 GetAddresses 方法，返回要发送的地址。 从地址管理器随机找到 N 个地址，N不能大于最大值 2500，并且这些地址的状态都比较好。 遍历要发送的节点，调用对等节点的 PushAddress 方法，把要发送的地址保存到 vAddrToSend 向量中。 由线程进行定时发送 addr 消息。 返回真。 3.2、addr 消息 节点作为客户端，响应服务器节点返回的地址。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1849 行。具体处理如下： 从输入流中取得远程对等节点发送的地址列表保存到 vAddr 向量中。 std::vector&lt;CAddress&gt; vAddr; vRecv &gt;&gt; vAddr; 如果远程对等节点的版本小于 31402（在这种版本比较老的情况下，我们只在初始时接收 DNS 种子服务器发送的地址），并且本保存的地址已经超过 1000，则直接返回真。 if (pfrom-&gt;nVersion &lt; CADDR_TIME_VERSION &amp;&amp; connman-&gt;GetAddressCount() &gt; 1000) return true; 如果远程对等节点发送的地址超过 1000，调用 Misbehaving 方法，对远程节点进行惩罚，可能导致其被禁止发送。 if (vAddr.size() &gt; 1000) { LOCK(cs_main); Misbehaving(pfrom-&gt;GetId(), 20, strprintf(&quot;message addr size() = %u&quot;, vAddr.size())); return false; } 遍历所有的地址列表，进行如下处理： 如果线程被中止，则返回真。 如果代表的节点不支持 NODE_NETWORK、NODE_NETWORK_LIMITED 两者之一的服务，则处理下一个。 if (!MayHaveUsefulAddressDB(addr.nServices) &amp;&amp; !HasAllDesirableServiceFlags(addr.nServices)) continue; 设置地址的时间属性 if (addr.nTime &lt;= 100000000 || addr.nTime &gt; nNow + 10 * 60) addr.nTime = nNow - 5 * 24 * 60 * 60; 调用对等节点的 AddAddressKnown 方法，把当前地址保存到已知地址 addrKnown 中。 如果地址是可路由的，则加入 vAddrOk 列表中。 if (fReachable) vAddrOk.push_back(addr); 调用 CConnman::AddNewAddresses 方法，保存 vAddrOk 列表中的地址。 AddNewAddresses 方法最终把地址列表保存在 CAddrMan 对象的 mapInfo 属性中。 如果发送的地址数量少于 1000，设置对等节点的获取地址标志为假。以便以后再次获取地址。如果对等节点的 fOneShot 属性为真，则设置对等节点的断开连接标志为真。 if (vAddr.size() &lt; 1000) pfrom-&gt;fGetAddr = false; if (pfrom-&gt;fOneShot) pfrom-&gt;fDisconnect = true; 返回真。 4、sendheaders 消息 节点作为服务器，响应客户端节点发送的更愿意接收头部而不是区块体的设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1899 行。这个消息的处理比较简单，只把节点对应的状态对象的 fPreferHeaders 属性为真。 代码如下： if (strCommand == NetMsgType::SENDHEADERS) { LOCK(cs_main); State(pfrom-&gt;GetId())-&gt;fPreferHeaders = true; return true; } 5、sendcmpct 消息 节点作为服务器，响应客户端节点发送的接收紧凑区块而不是普通区块的设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1905 行。 以 if (strCommand == NetMsgType::SENDCMPCT) { 为开始，具体如下： 从输入流中取得 fAnnounceUsingCMPCTBLOCK、nCMPCTBLOCKVersion 等参数。 vRecv &gt;&gt; fAnnounceUsingCMPCTBLOCK &gt;&gt; nCMPCTBLOCKVersion; 如果紧凑区块版本 nCMPCTBLOCKVersion 等于 1 ，或者节点可以响应包含隔离见证的区块和交易请求，且 nCMPCTBLOCKVersion 等于2，那么进行下面的处理。 if (nCMPCTBLOCKVersion == 1 || ((pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS) &amp;&amp; nCMPCTBLOCKVersion == 2)) { LOCK(cs_main); if (!State(pfrom-&gt;GetId())-&gt;fProvidesHeaderAndIDs) { State(pfrom-&gt;GetId())-&gt;fProvidesHeaderAndIDs = true; State(pfrom-&gt;GetId())-&gt;fWantsCmpctWitness = nCMPCTBLOCKVersion == 2; } if (State(pfrom-&gt;GetId())-&gt;fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces State(pfrom-&gt;GetId())-&gt;fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK; if (!State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion) { if (pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS) State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2); else State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1); } } 返回真。 6、feefilter 消息 节点作为服务器，响应客户端节点发送的费率过滤设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2911 行。 以 if (strCommand == NetMsgType::FEEFILTER) { 为开始，这个处理比较简单，代码如下： if (strCommand == NetMsgType::FEEFILTER) { CAmount newFeeFilter = 0; vRecv &gt;&gt; newFeeFilter; if (MoneyRange(newFeeFilter)) { { LOCK(pfrom-&gt;cs_feeFilter); pfrom-&gt;minFeeFilter = newFeeFilter; } LogPrint(BCLog::NET, &quot;received: feefilter of %s from peer=%d\n&quot;, CFeeRate(newFeeFilter).ToString(), pfrom-&gt;GetId()); } return true; } 其中 MoneyRange 方法检查费率参数是否在 0 到 2100 万比特币之间。 7、filterload 消息 节点作为服务器，响应 SPV 节点发送的布隆过滤设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2851 行。 以 if (strCommand == NetMsgType::FILTERLOAD) { 为开始，具体如下： 从输入流中取得过滤器参数。 CBloomFilter filter; vRecv &gt;&gt; filter; 调用布隆过滤器的 IsWithinSizeConstraints 方法，检查过滤器的是否超过限制区间。如果超过，则调用 Misbehaving 方法，对远程对等节点进行设置，可能导致其被禁止。如果不超过，则： 生成一个新的 CBloomFilter 过滤器对象，并设置节点的过滤器属性 pfilter 为新生成的对象。 调用节点过滤器的 UpdateEmptyFull 方法，重置其内部属性 vData。 设置中继交易属性 fRelayTxes 为真。 以上代码如下： if (!filter.IsWithinSizeConstraints()) { LOCK(cs_main); Misbehaving(pfrom-&gt;GetId(), 100); } else { LOCK(pfrom-&gt;cs_filter); pfrom-&gt;pfilter.reset(new CBloomFilter(filter)); pfrom-&gt;pfilter-&gt;UpdateEmptyFull(); pfrom-&gt;fRelayTxes = true; } 返回真。 8、filteradd 消息 节点作为服务器，响应 SPV 节点发送的增加布隆过滤消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2871 行。 以 if (strCommand == NetMsgType::FILTERADD) { 为开始，具体如下： 从输入流中取得要增加的过滤器。 std::vector&lt;unsigned char&gt; vData; vRecv &gt;&gt; vData; 如果发送的字节数量大于 520，则设置变量 bad 为真。如果不大于，则进行下面的判断。 如果已经发送过 filterload 消息，则把新的过滤器保存到过滤器集合中。否则，设置变量 bad 为真。 代码如下： bool bad = false; if (vData.size() &gt; MAX_SCRIPT_ELEMENT_SIZE) { bad = true; } else { LOCK(pfrom-&gt;cs_filter); if (pfrom-&gt;pfilter) { pfrom-&gt;pfilter-&gt;insert(vData); } else { bad = true; } } 如果变量为真，调用 Misbehaving 方法，惩罚节点。 返回真。 9、filterclear 节点作为服务器，响应 SPV 节点发送的增加布隆过滤消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2895 行。 以 if (strCommand == NetMsgType::FILTERCLEAR) { 为开始，这个消息处理比较简单，代码如下，可以自己理解。 if (strCommand == NetMsgType::FILTERCLEAR) { LOCK(pfrom-&gt;cs_filter); if (pfrom-&gt;GetLocalServices() &amp; NODE_BLOOM) { pfrom-&gt;pfilter.reset(new CBloomFilter()); } pfrom-&gt;fRelayTxes = true; return true; } 我是区小白，Ulord全球社区联盟（优得社区）核心区块链技术开发者，深入研究比特币,以太坊,EOS Dash,Rsk,Java, Nodejs,PHP,Python,C++ 我希望能聚集更多区块链开发者，一起学习共同进步。p 阅读更多" />
<meta property="og:description" content="P2P 网络的建立是在系统启动的第 12 步，最后时刻调用 CConnman::Start 方法开始的。 恭喜你越来越接近比特币的核心了，在上篇中，我们主要讲解了比特币的消息处理线程，接下来，在下篇中，将以具体的比特币消息即比特币协义分析为主。针对比特币的协义，为了从逻辑上进行理解，我们并没有完全按照代码的顺序，而是按照某个具体的消息的 请求----响应 模式来进行分析。 下面我们来看比特币协义相关的代码。 1、节点握手处理 1.1、接收 version 消息 节点作为服务器，处理客户端节点发送的版本请求。 版本消息是每个对等节点都要发送的消息，并且是最先发送、只能发送一次的消息，对等节点双方都要发送这个消息和下面的确认消息，只有双方都发送过版本消息，并且收到确认消息，对等节点间才可以进行后续消息发送。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1621 行。具体处理如下： 检查对等节点的版本字段是否已经设置，如果已经设置，即远程对等节点已经发送过版本消息，那么：在开启 BIP 161 情况下发送拒绝消息；对远程对待节点进行处罚。 if (pfrom-&gt;nVersion != 0) { if (enable_bip61) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(&quot;Duplicate version message&quot;))); } LOCK(cs_main); Misbehaving(pfrom-&gt;GetId(), 1); return false; } Misbehaving 方法进行处理，具体处理如下： 检查是否要增加节点的不良积分，如果不是，即增加的积分数量为 0，则直接退出。 取得节点的状态对象。如果不存在，则直接退出。 把节点的状态对象的不良积分加上要增加的不良积分。 比较节点的不良积分与默认的或用户通过 -banscore 参数指定的不良积分进行比较。如果在增加当前不良积分后大于等于设置的不良积分，并且增加之前小于设置的不良积分，那么设置状态对象为应该禁止，即设置 fShouldBan 属性为真。 这个方法的代码如下： void Misbehaving(NodeId pnode, int howmuch, const std::string&amp; message) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { if (howmuch == 0) return; CNodeState *state = State(pnode); if (state == nullptr) return; state-&gt;nMisbehavior += howmuch; int banscore = gArgs.GetArg(&quot;-banscore&quot;, DEFAULT_BANSCORE_THRESHOLD); std::string message_prefixed = message.empty() ? &quot;&quot; : (&quot;: &quot; + message); if (state-&gt;nMisbehavior &gt;= banscore &amp;&amp; state-&gt;nMisbehavior - howmuch &lt; banscore) { LogPrint(BCLog::NET, &quot;%s: %s peer=%d (%d -&gt; %d) BAN THRESHOLD EXCEEDED%s\n&quot;, __func__, state-&gt;name, pnode, state-&gt;nMisbehavior-howmuch, state-&gt;nMisbehavior, message_prefixed); state-&gt;fShouldBan = true; } else LogPrint(BCLog::NET, &quot;%s: %s peer=%d (%d -&gt; %d)%s\n&quot;, __func__, state-&gt;name, pnode, state-&gt;nMisbehavior-howmuch, state-&gt;nMisbehavior, message_prefixed); } 从输入流中取得远程对等节点发送的版本信息、支持的服务信息、发送时间、显示地址。 vRecv &gt;&gt; nVersion &gt;&gt; nServiceInt &gt;&gt; nTime &gt;&gt; addrMe; nSendVersion = std::min(nVersion, PROTOCOL_VERSION); nServices = ServiceFlags(nServiceInt); 如果对等节点是出站的，调用 CConnman 对象的 SetServices 方法，设置对等节点所支持的服务。 if (!pfrom-&gt;fInbound) { connman-&gt;SetServices(pfrom-&gt;addr, nServices); } 方法内部最终会获取节点的地址信息对象，然后设置其支持的服务属性。 如果对等节点是出站的，且不是临时的试探者，且不是手动指定的，且与本地服务不匹配，那么：在开启 BIP 161 情况下发送拒绝消息；然后设置远程对待节点为断开；然后返回假。 if (!pfrom-&gt;fInbound &amp;&amp; !pfrom-&gt;fFeeler &amp;&amp; !pfrom-&gt;m_manual_connection &amp;&amp; !HasAllDesirableServiceFlags(nServices)) { LogPrint(BCLog::NET, &quot;peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\n&quot;, pfrom-&gt;GetId(), nServices, GetDesirableServiceFlags(nServices)); if (enable_bip61) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,strprintf(&quot;Expected to offer services %08x&quot;, GetDesirableServiceFlags(nServices)))); } pfrom-&gt;fDisconnect = true; return false; } 如果发送的版本的小于协义规定的最小版本 MIN_PEER_PROTO_VERSION，那么：在开启 BIP 161 情况下发送拒绝消息；然后设置远程对待节点为断开；然后返回假。 if (nVersion &lt; MIN_PEER_PROTO_VERSION) { // disconnect from peers older than this proto version LogPrint(BCLog::NET, &quot;peer=%d using obsolete version %i; disconnecting\n&quot;, pfrom-&gt;GetId(), nVersion); if (enable_bip61) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE, strprintf(&quot;Version must be %d or greater&quot;, MIN_PEER_PROTO_VERSION))); } pfrom-&gt;fDisconnect = true; return false; } 如果输入流不为空，则从流中依次取得 addrFrom、nNonce、strSubVer（客户端字符串）、nStartingHeight（客户端区块链的高度）、fRelay等信息。 if (!vRecv.empty()) vRecv &gt;&gt; addrFrom &gt;&gt; nNonce; if (!vRecv.empty()) { vRecv &gt;&gt; LIMITED_STRING(strSubVer, MAX_SUBVERSION_LENGTH); cleanSubVer = SanitizeString(strSubVer); } if (!vRecv.empty()) { vRecv &gt;&gt; nStartingHeight; } if (!vRecv.empty()) vRecv &gt;&gt; fRelay; 如果对等节点节点是入站节点，且连接到自身，那么设置远程对待节点为断开，并返回真。 if (pfrom-&gt;fInbound &amp;&amp; !connman-&gt;CheckIncomingNonce(nNonce)) { LogPrintf(&quot;connected to self at %s, disconnecting\n&quot;, pfrom-&gt;addr.ToString()); pfrom-&gt;fDisconnect = true; return true; } 如果对等节点是入站节点，且其地址是可路由的，那么调用 SeenLocal 方法进行处理。 if (pfrom-&gt;fInbound &amp;&amp; addrMe.IsRoutable()) { SeenLocal(addrMe); } 在 SeenLocal 方法中，如果这个地址在 mapLocalHost 集合中存在，那么设置其对应的 LocalServiceInfo 对象的 nScore 加1。如晨不存在，则直接返回真。 bool SeenLocal(const CService&amp; addr) { { LOCK(cs_mapLocalHost); if (mapLocalHost.count(addr) == 0) return false; mapLocalHost[addr].nScore++; } return true; } 如果是对等节点是入站节点，则调用 PushNodeVersion 方法，发送自身的版本信息给远程对等节点。 节点在收到远程对待节点发送来的版本消息，并且经过检查没问题之后，自身发送一个版本消息给对远程对待节点。 调用 CConnman 对象的 PushMessage 方法，发送版本确认包。 因为当前的 version 消息，是别的节点请求我们的，当我们允许其连接时，发送版本确认包。注意，只有在双方都发送版本确认包之后，双方才可以互相发送消息。 设置对等节点的服务属性、保存地址、对等节点运行的客户端、对等节点区块链的高度、版本等。如果对等节点隔离见证服务，则设置对等节点对应的状态对象的相关属性为真。 pfrom-&gt;nServices = nServices; pfrom-&gt;SetAddrLocal(addrMe); { LOCK(pfrom-&gt;cs_SubVer); pfrom-&gt;strSubVer = strSubVer; pfrom-&gt;cleanSubVer = cleanSubVer; } pfrom-&gt;nStartingHeight = nStartingHeight; pfrom-&gt;fClient = (!(nServices &amp; NODE_NETWORK) &amp;&amp; !(nServices &amp; NODE_NETWORK_LIMITED)); pfrom-&gt;m_limited_node = (!(nServices &amp; NODE_NETWORK) &amp;&amp; (nServices &amp; NODE_NETWORK_LIMITED)); pfrom-&gt;fRelayTxes = fRelay; pfrom-&gt;SetSendVersion(nSendVersion); pfrom-&gt;nVersion = nVersion; 调用 UpdatePreferredDownload 方法，将对等节点设为可能的首先下载节点。 如果节点是出站的或者在白名单中，并且可以提供区块服务，并且 fOneShot 属性为假，即可作为首选下载节点。 如果对等节点不是入站节点，进行如下处理。 如果对等节点不是孤立的，并且不需要进行IBD下载（调用 IsInitialBlockDownload 函数进行判断，通常第一次启动或在常时间离线，比如24小时，有大师区块需要下载时，本方法返回真），那么： 调用 GetLocalAddress 方法，获取对该对等节点来说是最佳的地址。 如果找到的地址是可路由的，那么调用对等节点的 PushAddress 方法，把找到的地址保存在 vAddrToSend 集合中。 否则，调用 IsPeerAddrLocalGood 测试远程对等节点看到的我们的外部IP是否可以路由。如果可以路由，那么调用对等节点的 PushAddress 方法，把地址保存在 vAddrToSend 集合中。 以上代码如下： if (fListen &amp;&amp; !IsInitialBlockDownload()) { CAddress addr = GetLocalAddress(&amp;pfrom-&gt;addr, pfrom-&gt;GetLocalServices()); FastRandomContext insecure_rand; if (addr.IsRoutable()) { LogPrint(BCLog::NET, &quot;ProcessMessages: advertising address %s\n&quot;, addr.ToString()); pfrom-&gt;PushAddress(addr, insecure_rand); } else if (IsPeerAddrLocalGood(pfrom)) { addr.SetIP(addrMe); LogPrint(BCLog::NET, &quot;ProcessMessages: advertising address %s\n&quot;, addr.ToString()); pfrom-&gt;PushAddress(addr, insecure_rand); } } 如果需要，比如：本地保存的远程地址少于 1000个，那么调用 PushMessage 方法，请求远程节点发送更多的地址，即发送getaddr 消息。然后把请求地址的标志设置为真。 if (pfrom-&gt;fOneShot || pfrom-&gt;nVersion &gt;= CADDR_TIME_VERSION || connman-&gt;GetAddressCount() &lt; 1000) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR)); pfrom-&gt;fGetAddr = true; } 调用 MarkAddressGood 方法，保存远程对等节点，表明它是可访问的。 connman-&gt;MarkAddressGood(pfrom-&gt;addr); 如果远程对等节点的版本小于 70012，则发送一个 alert 消息。 if (pfrom-&gt;nVersion &lt;= 70012) { CDataStream finalAlert(ParseHex(&quot;60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50&quot;), SER_NETWORK, PROTOCOL_VERSION); connman-&gt;PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(&quot;alert&quot;, finalAlert)); } 如果节点是临时引导节点，则断开节点，即设置节点的断开属性为真。 if (pfrom-&gt;fFeeler) { assert(pfrom-&gt;fInbound == false); pfrom-&gt;fDisconnect = true; } 版本消息处理完成，返回真。 1.2、接收 verack 消息 节点作为客户端，处理服务器节点发送的版本响应消息，即版本确认消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1805 行。具体处理过程如下： 设置接收到的版本确认消息中的版本号。 pfrom-&gt;SetRecvVersion(std::min(pfrom-&gt;nVersion.load(), PROTOCOL_VERSION)); 如果对等节点不是入站节点，设置对等节点的状态对象的当前连接属性为真。 if (!pfrom-&gt;fInbound) { LOCK(cs_main); State(pfrom-&gt;GetId())-&gt;fCurrentlyConnected = true; } 如果对等节点的版本大于支持使用区块头部来公告区块的最小版本（SENDHEADERS_VERSION = 70012），那么： 调用 PushMessage 方法发送 sendheaders 消息，通知远程对等节点我们更愿意通过 headers 消息来接收新区块的公告，而不是 inv 消息。 这样以后当有新区块需要公告时，远程对等就会通过 headers 消息把区块头部先发送给我们，当我们再次请求时才会发送完整的区块。 如果对等节点的版本大于支持紧凑区块的最小版本（SHORT_IDS_BLOCKS_VERSION = 70014），那么分两种情况处理。 第一种情况，如果同时支持闪电网络，那么给对等节点发送一个紧凑区块版本为 2 的 sendcmpct 消息。 第二种情况，如果不支持闪电网络，那么给对等节点发送一个紧凑区块版本为 1 的 sendcmpct 消息。 无论哪一种情况，远程对等节点以后都会向本节点发送紧凑区块。 代码如下： if (pfrom-&gt;nVersion &gt;= SHORT_IDS_BLOCKS_VERSION) { bool fAnnounceUsingCMPCTBLOCK = false; uint64_t nCMPCTBLOCKVersion = 2; if (pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS) connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion)); nCMPCTBLOCKVersion = 1; connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion)); } 设置对等节点完全成功连接的标志为真，然后返回真。 pfrom-&gt;fSuccessfullyConnected = true; return true; 只有在对等节点双方都各自发送版本消息和确认消息之后，双方才真正建立起连接关系，才可以进行后续的交互，比如请求数据消息等。 2、保持连接的处理 因为在比特币网络中，任何一个节点都可以随时加入网络，也可以随时离开网络，所以两个连接的节点需要定时互相发送 ping 和 pong 来确保接点可以连接，如果在特定的时间内没有 ping 消息，节点即可认为连接已经断开。 2.1、ping 消息 这个消息比较简单，不作具体解释，代码如下： if (strCommand == NetMsgType::PING) { if (pfrom-&gt;nVersion &gt; BIP0031_VERSION) { uint64_t nonce = 0; vRecv &gt;&gt; nonce; connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce)); } return true; } 2.1、pong 消息 这个消息也比较简单，不作具体解释，代码如下： if (strCommand == NetMsgType::PONG) { int64_t pingUsecEnd = nTimeReceived; uint64_t nonce = 0; size_t nAvail = vRecv.in_avail(); bool bPingFinished = false; std::string sProblem; if (nAvail &gt;= sizeof(nonce)) { vRecv &gt;&gt; nonce; if (pfrom-&gt;nPingNonceSent != 0) { if (nonce == pfrom-&gt;nPingNonceSent) { bPingFinished = true; int64_t pingUsecTime = pingUsecEnd - pfrom-&gt;nPingUsecStart; if (pingUsecTime &gt; 0) { pfrom-&gt;nPingUsecTime = pingUsecTime; pfrom-&gt;nMinPingUsecTime = std::min(pfrom-&gt;nMinPingUsecTime.load(), pingUsecTime); } else { sProblem = &quot;Timing mishap&quot;; } } else { sProblem = &quot;Nonce mismatch&quot;; if (nonce == 0) { bPingFinished = true; sProblem = &quot;Nonce zero&quot;; } } } else { sProblem = &quot;Unsolicited pong without ping&quot;; } } else { bPingFinished = true; sProblem = &quot;Short payload&quot;; } if (bPingFinished) { pfrom-&gt;nPingNonceSent = 0; } return true; } 3、获取更多地址的处理 如果对等节点需要更多地址时，会发送 getaddr 消息请求远程对等节点发送更多的地址，当远程对等节点收到请求后，会通过发送 addr 消息传递更多的地址。 3.1、getaddr 消息 节点作为服务器，响应客户端节点发送的请求地址消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2728 行。具体处理如下： 如果对等节点不是入站节点，则忽略该请求，并返回。 if (!pfrom-&gt;fInbound) { return true; } 如果对等节点已发送过请求地址，即远程对等节点重复请求地址，则忽略该请求，并返回。 if (pfrom-&gt;fSentAddr) { return true; } 设置对等节点已发送过请求地址标志为真。清空对等节点的 vAddrToSend 集合。 pfrom-&gt;fSentAddr = true; pfrom-&gt;vAddrToSend.clear(); 调用 GetAddresses 方法，返回要发送的地址。 从地址管理器随机找到 N 个地址，N不能大于最大值 2500，并且这些地址的状态都比较好。 遍历要发送的节点，调用对等节点的 PushAddress 方法，把要发送的地址保存到 vAddrToSend 向量中。 由线程进行定时发送 addr 消息。 返回真。 3.2、addr 消息 节点作为客户端，响应服务器节点返回的地址。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1849 行。具体处理如下： 从输入流中取得远程对等节点发送的地址列表保存到 vAddr 向量中。 std::vector&lt;CAddress&gt; vAddr; vRecv &gt;&gt; vAddr; 如果远程对等节点的版本小于 31402（在这种版本比较老的情况下，我们只在初始时接收 DNS 种子服务器发送的地址），并且本保存的地址已经超过 1000，则直接返回真。 if (pfrom-&gt;nVersion &lt; CADDR_TIME_VERSION &amp;&amp; connman-&gt;GetAddressCount() &gt; 1000) return true; 如果远程对等节点发送的地址超过 1000，调用 Misbehaving 方法，对远程节点进行惩罚，可能导致其被禁止发送。 if (vAddr.size() &gt; 1000) { LOCK(cs_main); Misbehaving(pfrom-&gt;GetId(), 20, strprintf(&quot;message addr size() = %u&quot;, vAddr.size())); return false; } 遍历所有的地址列表，进行如下处理： 如果线程被中止，则返回真。 如果代表的节点不支持 NODE_NETWORK、NODE_NETWORK_LIMITED 两者之一的服务，则处理下一个。 if (!MayHaveUsefulAddressDB(addr.nServices) &amp;&amp; !HasAllDesirableServiceFlags(addr.nServices)) continue; 设置地址的时间属性 if (addr.nTime &lt;= 100000000 || addr.nTime &gt; nNow + 10 * 60) addr.nTime = nNow - 5 * 24 * 60 * 60; 调用对等节点的 AddAddressKnown 方法，把当前地址保存到已知地址 addrKnown 中。 如果地址是可路由的，则加入 vAddrOk 列表中。 if (fReachable) vAddrOk.push_back(addr); 调用 CConnman::AddNewAddresses 方法，保存 vAddrOk 列表中的地址。 AddNewAddresses 方法最终把地址列表保存在 CAddrMan 对象的 mapInfo 属性中。 如果发送的地址数量少于 1000，设置对等节点的获取地址标志为假。以便以后再次获取地址。如果对等节点的 fOneShot 属性为真，则设置对等节点的断开连接标志为真。 if (vAddr.size() &lt; 1000) pfrom-&gt;fGetAddr = false; if (pfrom-&gt;fOneShot) pfrom-&gt;fDisconnect = true; 返回真。 4、sendheaders 消息 节点作为服务器，响应客户端节点发送的更愿意接收头部而不是区块体的设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1899 行。这个消息的处理比较简单，只把节点对应的状态对象的 fPreferHeaders 属性为真。 代码如下： if (strCommand == NetMsgType::SENDHEADERS) { LOCK(cs_main); State(pfrom-&gt;GetId())-&gt;fPreferHeaders = true; return true; } 5、sendcmpct 消息 节点作为服务器，响应客户端节点发送的接收紧凑区块而不是普通区块的设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1905 行。 以 if (strCommand == NetMsgType::SENDCMPCT) { 为开始，具体如下： 从输入流中取得 fAnnounceUsingCMPCTBLOCK、nCMPCTBLOCKVersion 等参数。 vRecv &gt;&gt; fAnnounceUsingCMPCTBLOCK &gt;&gt; nCMPCTBLOCKVersion; 如果紧凑区块版本 nCMPCTBLOCKVersion 等于 1 ，或者节点可以响应包含隔离见证的区块和交易请求，且 nCMPCTBLOCKVersion 等于2，那么进行下面的处理。 if (nCMPCTBLOCKVersion == 1 || ((pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS) &amp;&amp; nCMPCTBLOCKVersion == 2)) { LOCK(cs_main); if (!State(pfrom-&gt;GetId())-&gt;fProvidesHeaderAndIDs) { State(pfrom-&gt;GetId())-&gt;fProvidesHeaderAndIDs = true; State(pfrom-&gt;GetId())-&gt;fWantsCmpctWitness = nCMPCTBLOCKVersion == 2; } if (State(pfrom-&gt;GetId())-&gt;fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces State(pfrom-&gt;GetId())-&gt;fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK; if (!State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion) { if (pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS) State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2); else State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1); } } 返回真。 6、feefilter 消息 节点作为服务器，响应客户端节点发送的费率过滤设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2911 行。 以 if (strCommand == NetMsgType::FEEFILTER) { 为开始，这个处理比较简单，代码如下： if (strCommand == NetMsgType::FEEFILTER) { CAmount newFeeFilter = 0; vRecv &gt;&gt; newFeeFilter; if (MoneyRange(newFeeFilter)) { { LOCK(pfrom-&gt;cs_feeFilter); pfrom-&gt;minFeeFilter = newFeeFilter; } LogPrint(BCLog::NET, &quot;received: feefilter of %s from peer=%d\n&quot;, CFeeRate(newFeeFilter).ToString(), pfrom-&gt;GetId()); } return true; } 其中 MoneyRange 方法检查费率参数是否在 0 到 2100 万比特币之间。 7、filterload 消息 节点作为服务器，响应 SPV 节点发送的布隆过滤设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2851 行。 以 if (strCommand == NetMsgType::FILTERLOAD) { 为开始，具体如下： 从输入流中取得过滤器参数。 CBloomFilter filter; vRecv &gt;&gt; filter; 调用布隆过滤器的 IsWithinSizeConstraints 方法，检查过滤器的是否超过限制区间。如果超过，则调用 Misbehaving 方法，对远程对等节点进行设置，可能导致其被禁止。如果不超过，则： 生成一个新的 CBloomFilter 过滤器对象，并设置节点的过滤器属性 pfilter 为新生成的对象。 调用节点过滤器的 UpdateEmptyFull 方法，重置其内部属性 vData。 设置中继交易属性 fRelayTxes 为真。 以上代码如下： if (!filter.IsWithinSizeConstraints()) { LOCK(cs_main); Misbehaving(pfrom-&gt;GetId(), 100); } else { LOCK(pfrom-&gt;cs_filter); pfrom-&gt;pfilter.reset(new CBloomFilter(filter)); pfrom-&gt;pfilter-&gt;UpdateEmptyFull(); pfrom-&gt;fRelayTxes = true; } 返回真。 8、filteradd 消息 节点作为服务器，响应 SPV 节点发送的增加布隆过滤消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2871 行。 以 if (strCommand == NetMsgType::FILTERADD) { 为开始，具体如下： 从输入流中取得要增加的过滤器。 std::vector&lt;unsigned char&gt; vData; vRecv &gt;&gt; vData; 如果发送的字节数量大于 520，则设置变量 bad 为真。如果不大于，则进行下面的判断。 如果已经发送过 filterload 消息，则把新的过滤器保存到过滤器集合中。否则，设置变量 bad 为真。 代码如下： bool bad = false; if (vData.size() &gt; MAX_SCRIPT_ELEMENT_SIZE) { bad = true; } else { LOCK(pfrom-&gt;cs_filter); if (pfrom-&gt;pfilter) { pfrom-&gt;pfilter-&gt;insert(vData); } else { bad = true; } } 如果变量为真，调用 Misbehaving 方法，惩罚节点。 返回真。 9、filterclear 节点作为服务器，响应 SPV 节点发送的增加布隆过滤消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2895 行。 以 if (strCommand == NetMsgType::FILTERCLEAR) { 为开始，这个消息处理比较简单，代码如下，可以自己理解。 if (strCommand == NetMsgType::FILTERCLEAR) { LOCK(pfrom-&gt;cs_filter); if (pfrom-&gt;GetLocalServices() &amp; NODE_BLOOM) { pfrom-&gt;pfilter.reset(new CBloomFilter()); } pfrom-&gt;fRelayTxes = true; return true; } 我是区小白，Ulord全球社区联盟（优得社区）核心区块链技术开发者，深入研究比特币,以太坊,EOS Dash,Rsk,Java, Nodejs,PHP,Python,C++ 我希望能聚集更多区块链开发者，一起学习共同进步。p 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/10/31/155e00dac8b023b6ac9e73c763e83b59.html" />
<meta property="og:url" content="https://mlh.app/2018/10/31/155e00dac8b023b6ac9e73c763e83b59.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-10-31T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"P2P 网络的建立是在系统启动的第 12 步，最后时刻调用 CConnman::Start 方法开始的。 恭喜你越来越接近比特币的核心了，在上篇中，我们主要讲解了比特币的消息处理线程，接下来，在下篇中，将以具体的比特币消息即比特币协义分析为主。针对比特币的协义，为了从逻辑上进行理解，我们并没有完全按照代码的顺序，而是按照某个具体的消息的 请求----响应 模式来进行分析。 下面我们来看比特币协义相关的代码。 1、节点握手处理 1.1、接收 version 消息 节点作为服务器，处理客户端节点发送的版本请求。 版本消息是每个对等节点都要发送的消息，并且是最先发送、只能发送一次的消息，对等节点双方都要发送这个消息和下面的确认消息，只有双方都发送过版本消息，并且收到确认消息，对等节点间才可以进行后续消息发送。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1621 行。具体处理如下： 检查对等节点的版本字段是否已经设置，如果已经设置，即远程对等节点已经发送过版本消息，那么：在开启 BIP 161 情况下发送拒绝消息；对远程对待节点进行处罚。 if (pfrom-&gt;nVersion != 0) { if (enable_bip61) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(&quot;Duplicate version message&quot;))); } LOCK(cs_main); Misbehaving(pfrom-&gt;GetId(), 1); return false; } Misbehaving 方法进行处理，具体处理如下： 检查是否要增加节点的不良积分，如果不是，即增加的积分数量为 0，则直接退出。 取得节点的状态对象。如果不存在，则直接退出。 把节点的状态对象的不良积分加上要增加的不良积分。 比较节点的不良积分与默认的或用户通过 -banscore 参数指定的不良积分进行比较。如果在增加当前不良积分后大于等于设置的不良积分，并且增加之前小于设置的不良积分，那么设置状态对象为应该禁止，即设置 fShouldBan 属性为真。 这个方法的代码如下： void Misbehaving(NodeId pnode, int howmuch, const std::string&amp; message) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { if (howmuch == 0) return; CNodeState *state = State(pnode); if (state == nullptr) return; state-&gt;nMisbehavior += howmuch; int banscore = gArgs.GetArg(&quot;-banscore&quot;, DEFAULT_BANSCORE_THRESHOLD); std::string message_prefixed = message.empty() ? &quot;&quot; : (&quot;: &quot; + message); if (state-&gt;nMisbehavior &gt;= banscore &amp;&amp; state-&gt;nMisbehavior - howmuch &lt; banscore) { LogPrint(BCLog::NET, &quot;%s: %s peer=%d (%d -&gt; %d) BAN THRESHOLD EXCEEDED%s\\n&quot;, __func__, state-&gt;name, pnode, state-&gt;nMisbehavior-howmuch, state-&gt;nMisbehavior, message_prefixed); state-&gt;fShouldBan = true; } else LogPrint(BCLog::NET, &quot;%s: %s peer=%d (%d -&gt; %d)%s\\n&quot;, __func__, state-&gt;name, pnode, state-&gt;nMisbehavior-howmuch, state-&gt;nMisbehavior, message_prefixed); } 从输入流中取得远程对等节点发送的版本信息、支持的服务信息、发送时间、显示地址。 vRecv &gt;&gt; nVersion &gt;&gt; nServiceInt &gt;&gt; nTime &gt;&gt; addrMe; nSendVersion = std::min(nVersion, PROTOCOL_VERSION); nServices = ServiceFlags(nServiceInt); 如果对等节点是出站的，调用 CConnman 对象的 SetServices 方法，设置对等节点所支持的服务。 if (!pfrom-&gt;fInbound) { connman-&gt;SetServices(pfrom-&gt;addr, nServices); } 方法内部最终会获取节点的地址信息对象，然后设置其支持的服务属性。 如果对等节点是出站的，且不是临时的试探者，且不是手动指定的，且与本地服务不匹配，那么：在开启 BIP 161 情况下发送拒绝消息；然后设置远程对待节点为断开；然后返回假。 if (!pfrom-&gt;fInbound &amp;&amp; !pfrom-&gt;fFeeler &amp;&amp; !pfrom-&gt;m_manual_connection &amp;&amp; !HasAllDesirableServiceFlags(nServices)) { LogPrint(BCLog::NET, &quot;peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n&quot;, pfrom-&gt;GetId(), nServices, GetDesirableServiceFlags(nServices)); if (enable_bip61) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,strprintf(&quot;Expected to offer services %08x&quot;, GetDesirableServiceFlags(nServices)))); } pfrom-&gt;fDisconnect = true; return false; } 如果发送的版本的小于协义规定的最小版本 MIN_PEER_PROTO_VERSION，那么：在开启 BIP 161 情况下发送拒绝消息；然后设置远程对待节点为断开；然后返回假。 if (nVersion &lt; MIN_PEER_PROTO_VERSION) { // disconnect from peers older than this proto version LogPrint(BCLog::NET, &quot;peer=%d using obsolete version %i; disconnecting\\n&quot;, pfrom-&gt;GetId(), nVersion); if (enable_bip61) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE, strprintf(&quot;Version must be %d or greater&quot;, MIN_PEER_PROTO_VERSION))); } pfrom-&gt;fDisconnect = true; return false; } 如果输入流不为空，则从流中依次取得 addrFrom、nNonce、strSubVer（客户端字符串）、nStartingHeight（客户端区块链的高度）、fRelay等信息。 if (!vRecv.empty()) vRecv &gt;&gt; addrFrom &gt;&gt; nNonce; if (!vRecv.empty()) { vRecv &gt;&gt; LIMITED_STRING(strSubVer, MAX_SUBVERSION_LENGTH); cleanSubVer = SanitizeString(strSubVer); } if (!vRecv.empty()) { vRecv &gt;&gt; nStartingHeight; } if (!vRecv.empty()) vRecv &gt;&gt; fRelay; 如果对等节点节点是入站节点，且连接到自身，那么设置远程对待节点为断开，并返回真。 if (pfrom-&gt;fInbound &amp;&amp; !connman-&gt;CheckIncomingNonce(nNonce)) { LogPrintf(&quot;connected to self at %s, disconnecting\\n&quot;, pfrom-&gt;addr.ToString()); pfrom-&gt;fDisconnect = true; return true; } 如果对等节点是入站节点，且其地址是可路由的，那么调用 SeenLocal 方法进行处理。 if (pfrom-&gt;fInbound &amp;&amp; addrMe.IsRoutable()) { SeenLocal(addrMe); } 在 SeenLocal 方法中，如果这个地址在 mapLocalHost 集合中存在，那么设置其对应的 LocalServiceInfo 对象的 nScore 加1。如晨不存在，则直接返回真。 bool SeenLocal(const CService&amp; addr) { { LOCK(cs_mapLocalHost); if (mapLocalHost.count(addr) == 0) return false; mapLocalHost[addr].nScore++; } return true; } 如果是对等节点是入站节点，则调用 PushNodeVersion 方法，发送自身的版本信息给远程对等节点。 节点在收到远程对待节点发送来的版本消息，并且经过检查没问题之后，自身发送一个版本消息给对远程对待节点。 调用 CConnman 对象的 PushMessage 方法，发送版本确认包。 因为当前的 version 消息，是别的节点请求我们的，当我们允许其连接时，发送版本确认包。注意，只有在双方都发送版本确认包之后，双方才可以互相发送消息。 设置对等节点的服务属性、保存地址、对等节点运行的客户端、对等节点区块链的高度、版本等。如果对等节点隔离见证服务，则设置对等节点对应的状态对象的相关属性为真。 pfrom-&gt;nServices = nServices; pfrom-&gt;SetAddrLocal(addrMe); { LOCK(pfrom-&gt;cs_SubVer); pfrom-&gt;strSubVer = strSubVer; pfrom-&gt;cleanSubVer = cleanSubVer; } pfrom-&gt;nStartingHeight = nStartingHeight; pfrom-&gt;fClient = (!(nServices &amp; NODE_NETWORK) &amp;&amp; !(nServices &amp; NODE_NETWORK_LIMITED)); pfrom-&gt;m_limited_node = (!(nServices &amp; NODE_NETWORK) &amp;&amp; (nServices &amp; NODE_NETWORK_LIMITED)); pfrom-&gt;fRelayTxes = fRelay; pfrom-&gt;SetSendVersion(nSendVersion); pfrom-&gt;nVersion = nVersion; 调用 UpdatePreferredDownload 方法，将对等节点设为可能的首先下载节点。 如果节点是出站的或者在白名单中，并且可以提供区块服务，并且 fOneShot 属性为假，即可作为首选下载节点。 如果对等节点不是入站节点，进行如下处理。 如果对等节点不是孤立的，并且不需要进行IBD下载（调用 IsInitialBlockDownload 函数进行判断，通常第一次启动或在常时间离线，比如24小时，有大师区块需要下载时，本方法返回真），那么： 调用 GetLocalAddress 方法，获取对该对等节点来说是最佳的地址。 如果找到的地址是可路由的，那么调用对等节点的 PushAddress 方法，把找到的地址保存在 vAddrToSend 集合中。 否则，调用 IsPeerAddrLocalGood 测试远程对等节点看到的我们的外部IP是否可以路由。如果可以路由，那么调用对等节点的 PushAddress 方法，把地址保存在 vAddrToSend 集合中。 以上代码如下： if (fListen &amp;&amp; !IsInitialBlockDownload()) { CAddress addr = GetLocalAddress(&amp;pfrom-&gt;addr, pfrom-&gt;GetLocalServices()); FastRandomContext insecure_rand; if (addr.IsRoutable()) { LogPrint(BCLog::NET, &quot;ProcessMessages: advertising address %s\\n&quot;, addr.ToString()); pfrom-&gt;PushAddress(addr, insecure_rand); } else if (IsPeerAddrLocalGood(pfrom)) { addr.SetIP(addrMe); LogPrint(BCLog::NET, &quot;ProcessMessages: advertising address %s\\n&quot;, addr.ToString()); pfrom-&gt;PushAddress(addr, insecure_rand); } } 如果需要，比如：本地保存的远程地址少于 1000个，那么调用 PushMessage 方法，请求远程节点发送更多的地址，即发送getaddr 消息。然后把请求地址的标志设置为真。 if (pfrom-&gt;fOneShot || pfrom-&gt;nVersion &gt;= CADDR_TIME_VERSION || connman-&gt;GetAddressCount() &lt; 1000) { connman-&gt;PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR)); pfrom-&gt;fGetAddr = true; } 调用 MarkAddressGood 方法，保存远程对等节点，表明它是可访问的。 connman-&gt;MarkAddressGood(pfrom-&gt;addr); 如果远程对等节点的版本小于 70012，则发送一个 alert 消息。 if (pfrom-&gt;nVersion &lt;= 70012) { CDataStream finalAlert(ParseHex(&quot;60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50&quot;), SER_NETWORK, PROTOCOL_VERSION); connman-&gt;PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(&quot;alert&quot;, finalAlert)); } 如果节点是临时引导节点，则断开节点，即设置节点的断开属性为真。 if (pfrom-&gt;fFeeler) { assert(pfrom-&gt;fInbound == false); pfrom-&gt;fDisconnect = true; } 版本消息处理完成，返回真。 1.2、接收 verack 消息 节点作为客户端，处理服务器节点发送的版本响应消息，即版本确认消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1805 行。具体处理过程如下： 设置接收到的版本确认消息中的版本号。 pfrom-&gt;SetRecvVersion(std::min(pfrom-&gt;nVersion.load(), PROTOCOL_VERSION)); 如果对等节点不是入站节点，设置对等节点的状态对象的当前连接属性为真。 if (!pfrom-&gt;fInbound) { LOCK(cs_main); State(pfrom-&gt;GetId())-&gt;fCurrentlyConnected = true; } 如果对等节点的版本大于支持使用区块头部来公告区块的最小版本（SENDHEADERS_VERSION = 70012），那么： 调用 PushMessage 方法发送 sendheaders 消息，通知远程对等节点我们更愿意通过 headers 消息来接收新区块的公告，而不是 inv 消息。 这样以后当有新区块需要公告时，远程对等就会通过 headers 消息把区块头部先发送给我们，当我们再次请求时才会发送完整的区块。 如果对等节点的版本大于支持紧凑区块的最小版本（SHORT_IDS_BLOCKS_VERSION = 70014），那么分两种情况处理。 第一种情况，如果同时支持闪电网络，那么给对等节点发送一个紧凑区块版本为 2 的 sendcmpct 消息。 第二种情况，如果不支持闪电网络，那么给对等节点发送一个紧凑区块版本为 1 的 sendcmpct 消息。 无论哪一种情况，远程对等节点以后都会向本节点发送紧凑区块。 代码如下： if (pfrom-&gt;nVersion &gt;= SHORT_IDS_BLOCKS_VERSION) { bool fAnnounceUsingCMPCTBLOCK = false; uint64_t nCMPCTBLOCKVersion = 2; if (pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS) connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion)); nCMPCTBLOCKVersion = 1; connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion)); } 设置对等节点完全成功连接的标志为真，然后返回真。 pfrom-&gt;fSuccessfullyConnected = true; return true; 只有在对等节点双方都各自发送版本消息和确认消息之后，双方才真正建立起连接关系，才可以进行后续的交互，比如请求数据消息等。 2、保持连接的处理 因为在比特币网络中，任何一个节点都可以随时加入网络，也可以随时离开网络，所以两个连接的节点需要定时互相发送 ping 和 pong 来确保接点可以连接，如果在特定的时间内没有 ping 消息，节点即可认为连接已经断开。 2.1、ping 消息 这个消息比较简单，不作具体解释，代码如下： if (strCommand == NetMsgType::PING) { if (pfrom-&gt;nVersion &gt; BIP0031_VERSION) { uint64_t nonce = 0; vRecv &gt;&gt; nonce; connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce)); } return true; } 2.1、pong 消息 这个消息也比较简单，不作具体解释，代码如下： if (strCommand == NetMsgType::PONG) { int64_t pingUsecEnd = nTimeReceived; uint64_t nonce = 0; size_t nAvail = vRecv.in_avail(); bool bPingFinished = false; std::string sProblem; if (nAvail &gt;= sizeof(nonce)) { vRecv &gt;&gt; nonce; if (pfrom-&gt;nPingNonceSent != 0) { if (nonce == pfrom-&gt;nPingNonceSent) { bPingFinished = true; int64_t pingUsecTime = pingUsecEnd - pfrom-&gt;nPingUsecStart; if (pingUsecTime &gt; 0) { pfrom-&gt;nPingUsecTime = pingUsecTime; pfrom-&gt;nMinPingUsecTime = std::min(pfrom-&gt;nMinPingUsecTime.load(), pingUsecTime); } else { sProblem = &quot;Timing mishap&quot;; } } else { sProblem = &quot;Nonce mismatch&quot;; if (nonce == 0) { bPingFinished = true; sProblem = &quot;Nonce zero&quot;; } } } else { sProblem = &quot;Unsolicited pong without ping&quot;; } } else { bPingFinished = true; sProblem = &quot;Short payload&quot;; } if (bPingFinished) { pfrom-&gt;nPingNonceSent = 0; } return true; } 3、获取更多地址的处理 如果对等节点需要更多地址时，会发送 getaddr 消息请求远程对等节点发送更多的地址，当远程对等节点收到请求后，会通过发送 addr 消息传递更多的地址。 3.1、getaddr 消息 节点作为服务器，响应客户端节点发送的请求地址消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2728 行。具体处理如下： 如果对等节点不是入站节点，则忽略该请求，并返回。 if (!pfrom-&gt;fInbound) { return true; } 如果对等节点已发送过请求地址，即远程对等节点重复请求地址，则忽略该请求，并返回。 if (pfrom-&gt;fSentAddr) { return true; } 设置对等节点已发送过请求地址标志为真。清空对等节点的 vAddrToSend 集合。 pfrom-&gt;fSentAddr = true; pfrom-&gt;vAddrToSend.clear(); 调用 GetAddresses 方法，返回要发送的地址。 从地址管理器随机找到 N 个地址，N不能大于最大值 2500，并且这些地址的状态都比较好。 遍历要发送的节点，调用对等节点的 PushAddress 方法，把要发送的地址保存到 vAddrToSend 向量中。 由线程进行定时发送 addr 消息。 返回真。 3.2、addr 消息 节点作为客户端，响应服务器节点返回的地址。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1849 行。具体处理如下： 从输入流中取得远程对等节点发送的地址列表保存到 vAddr 向量中。 std::vector&lt;CAddress&gt; vAddr; vRecv &gt;&gt; vAddr; 如果远程对等节点的版本小于 31402（在这种版本比较老的情况下，我们只在初始时接收 DNS 种子服务器发送的地址），并且本保存的地址已经超过 1000，则直接返回真。 if (pfrom-&gt;nVersion &lt; CADDR_TIME_VERSION &amp;&amp; connman-&gt;GetAddressCount() &gt; 1000) return true; 如果远程对等节点发送的地址超过 1000，调用 Misbehaving 方法，对远程节点进行惩罚，可能导致其被禁止发送。 if (vAddr.size() &gt; 1000) { LOCK(cs_main); Misbehaving(pfrom-&gt;GetId(), 20, strprintf(&quot;message addr size() = %u&quot;, vAddr.size())); return false; } 遍历所有的地址列表，进行如下处理： 如果线程被中止，则返回真。 如果代表的节点不支持 NODE_NETWORK、NODE_NETWORK_LIMITED 两者之一的服务，则处理下一个。 if (!MayHaveUsefulAddressDB(addr.nServices) &amp;&amp; !HasAllDesirableServiceFlags(addr.nServices)) continue; 设置地址的时间属性 if (addr.nTime &lt;= 100000000 || addr.nTime &gt; nNow + 10 * 60) addr.nTime = nNow - 5 * 24 * 60 * 60; 调用对等节点的 AddAddressKnown 方法，把当前地址保存到已知地址 addrKnown 中。 如果地址是可路由的，则加入 vAddrOk 列表中。 if (fReachable) vAddrOk.push_back(addr); 调用 CConnman::AddNewAddresses 方法，保存 vAddrOk 列表中的地址。 AddNewAddresses 方法最终把地址列表保存在 CAddrMan 对象的 mapInfo 属性中。 如果发送的地址数量少于 1000，设置对等节点的获取地址标志为假。以便以后再次获取地址。如果对等节点的 fOneShot 属性为真，则设置对等节点的断开连接标志为真。 if (vAddr.size() &lt; 1000) pfrom-&gt;fGetAddr = false; if (pfrom-&gt;fOneShot) pfrom-&gt;fDisconnect = true; 返回真。 4、sendheaders 消息 节点作为服务器，响应客户端节点发送的更愿意接收头部而不是区块体的设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1899 行。这个消息的处理比较简单，只把节点对应的状态对象的 fPreferHeaders 属性为真。 代码如下： if (strCommand == NetMsgType::SENDHEADERS) { LOCK(cs_main); State(pfrom-&gt;GetId())-&gt;fPreferHeaders = true; return true; } 5、sendcmpct 消息 节点作为服务器，响应客户端节点发送的接收紧凑区块而不是普通区块的设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 1905 行。 以 if (strCommand == NetMsgType::SENDCMPCT) { 为开始，具体如下： 从输入流中取得 fAnnounceUsingCMPCTBLOCK、nCMPCTBLOCKVersion 等参数。 vRecv &gt;&gt; fAnnounceUsingCMPCTBLOCK &gt;&gt; nCMPCTBLOCKVersion; 如果紧凑区块版本 nCMPCTBLOCKVersion 等于 1 ，或者节点可以响应包含隔离见证的区块和交易请求，且 nCMPCTBLOCKVersion 等于2，那么进行下面的处理。 if (nCMPCTBLOCKVersion == 1 || ((pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS) &amp;&amp; nCMPCTBLOCKVersion == 2)) { LOCK(cs_main); if (!State(pfrom-&gt;GetId())-&gt;fProvidesHeaderAndIDs) { State(pfrom-&gt;GetId())-&gt;fProvidesHeaderAndIDs = true; State(pfrom-&gt;GetId())-&gt;fWantsCmpctWitness = nCMPCTBLOCKVersion == 2; } if (State(pfrom-&gt;GetId())-&gt;fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces State(pfrom-&gt;GetId())-&gt;fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK; if (!State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion) { if (pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS) State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2); else State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1); } } 返回真。 6、feefilter 消息 节点作为服务器，响应客户端节点发送的费率过滤设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2911 行。 以 if (strCommand == NetMsgType::FEEFILTER) { 为开始，这个处理比较简单，代码如下： if (strCommand == NetMsgType::FEEFILTER) { CAmount newFeeFilter = 0; vRecv &gt;&gt; newFeeFilter; if (MoneyRange(newFeeFilter)) { { LOCK(pfrom-&gt;cs_feeFilter); pfrom-&gt;minFeeFilter = newFeeFilter; } LogPrint(BCLog::NET, &quot;received: feefilter of %s from peer=%d\\n&quot;, CFeeRate(newFeeFilter).ToString(), pfrom-&gt;GetId()); } return true; } 其中 MoneyRange 方法检查费率参数是否在 0 到 2100 万比特币之间。 7、filterload 消息 节点作为服务器，响应 SPV 节点发送的布隆过滤设置消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2851 行。 以 if (strCommand == NetMsgType::FILTERLOAD) { 为开始，具体如下： 从输入流中取得过滤器参数。 CBloomFilter filter; vRecv &gt;&gt; filter; 调用布隆过滤器的 IsWithinSizeConstraints 方法，检查过滤器的是否超过限制区间。如果超过，则调用 Misbehaving 方法，对远程对等节点进行设置，可能导致其被禁止。如果不超过，则： 生成一个新的 CBloomFilter 过滤器对象，并设置节点的过滤器属性 pfilter 为新生成的对象。 调用节点过滤器的 UpdateEmptyFull 方法，重置其内部属性 vData。 设置中继交易属性 fRelayTxes 为真。 以上代码如下： if (!filter.IsWithinSizeConstraints()) { LOCK(cs_main); Misbehaving(pfrom-&gt;GetId(), 100); } else { LOCK(pfrom-&gt;cs_filter); pfrom-&gt;pfilter.reset(new CBloomFilter(filter)); pfrom-&gt;pfilter-&gt;UpdateEmptyFull(); pfrom-&gt;fRelayTxes = true; } 返回真。 8、filteradd 消息 节点作为服务器，响应 SPV 节点发送的增加布隆过滤消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2871 行。 以 if (strCommand == NetMsgType::FILTERADD) { 为开始，具体如下： 从输入流中取得要增加的过滤器。 std::vector&lt;unsigned char&gt; vData; vRecv &gt;&gt; vData; 如果发送的字节数量大于 520，则设置变量 bad 为真。如果不大于，则进行下面的判断。 如果已经发送过 filterload 消息，则把新的过滤器保存到过滤器集合中。否则，设置变量 bad 为真。 代码如下： bool bad = false; if (vData.size() &gt; MAX_SCRIPT_ELEMENT_SIZE) { bad = true; } else { LOCK(pfrom-&gt;cs_filter); if (pfrom-&gt;pfilter) { pfrom-&gt;pfilter-&gt;insert(vData); } else { bad = true; } } 如果变量为真，调用 Misbehaving 方法，惩罚节点。 返回真。 9、filterclear 节点作为服务器，响应 SPV 节点发送的增加布隆过滤消息。 代码在 net_processing.cpp 文件中的 ProcessMessage 方法的 2895 行。 以 if (strCommand == NetMsgType::FILTERCLEAR) { 为开始，这个消息处理比较简单，代码如下，可以自己理解。 if (strCommand == NetMsgType::FILTERCLEAR) { LOCK(pfrom-&gt;cs_filter); if (pfrom-&gt;GetLocalServices() &amp; NODE_BLOOM) { pfrom-&gt;pfilter.reset(new CBloomFilter()); } pfrom-&gt;fRelayTxes = true; return true; } 我是区小白，Ulord全球社区联盟（优得社区）核心区块链技术开发者，深入研究比特币,以太坊,EOS Dash,Rsk,Java, Nodejs,PHP,Python,C++ 我希望能聚集更多区块链开发者，一起学习共同进步。p 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/10/31/155e00dac8b023b6ac9e73c763e83b59.html","headline":"从零开始学习比特币开发（九）–P2P 网络建立之消息处理中篇","dateModified":"2018-10-31T00:00:00+08:00","datePublished":"2018-10-31T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/10/31/155e00dac8b023b6ac9e73c763e83b59.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>从零开始学习比特币开发（九）--P2P 网络建立之消息处理中篇</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>P2P 网络的建立是在系统启动的第 12 步，最后时刻调用 <code>CConnman::Start</code> 方法开始的。</p> 
  <p>恭喜你越来越接近比特币的核心了，在<a href="https://blog.csdn.net/xiyuan688/article/details/83344174" rel="nofollow">上篇</a>中，我们主要讲解了比特币的消息处理线程，接下来，在下篇中，将以具体的比特币消息即比特币协义分析为主。针对比特币的协义，为了从逻辑上进行理解，我们并没有完全按照代码的顺序，而是按照某个具体的消息的 <code>请求----响应</code> 模式来进行分析。</p> 
  <p>下面我们来看比特币协义相关的代码。</p> 
  <h2><a id="1_8"></a>1、节点握手处理</h2> 
  <h3><a id="11_version__10"></a>1.1、接收 <code>version</code> 消息</h3> 
  <p>节点作为服务器，处理客户端节点发送的版本请求。</p> 
  <p>版本消息是每个对等节点都要发送的消息，并且是最先发送、只能发送一次的消息，对等节点双方都要发送这个消息和下面的确认消息，只有双方都发送过版本消息，并且收到确认消息，对等节点间才可以进行后续消息发送。</p> 
  <p>代码在 <code>net_processing.cpp</code> 文件中的 <code>ProcessMessage</code> 方法的 1621 行。具体处理如下：</p> 
  <ol> 
   <li> <p>检查对等节点的版本字段是否已经设置，如果已经设置，即远程对等节点已经发送过版本消息，那么：在开启 BIP 161 情况下发送拒绝消息；对远程对待节点进行处罚。</p> <pre><code> if (pfrom-&gt;nVersion != 0)
 {
     if (enable_bip61) {
         connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string("Duplicate version message")));
     }
     LOCK(cs_main);
     Misbehaving(pfrom-&gt;GetId(), 1);
     return false;
 }
</code></pre> <p><code>Misbehaving</code> 方法进行处理，具体处理如下：</p> 
    <ul> 
     <li>检查是否要增加节点的不良积分，如果不是，即增加的积分数量为 0，则直接退出。</li> 
     <li>取得节点的状态对象。如果不存在，则直接退出。</li> 
     <li>把节点的状态对象的不良积分加上要增加的不良积分。</li> 
     <li>比较节点的不良积分与默认的或用户通过 <code>-banscore</code> 参数指定的不良积分进行比较。如果在增加当前不良积分后大于等于设置的不良积分，并且增加之前小于设置的不良积分，那么设置状态对象为应该禁止，即设置 <code>fShouldBan</code> 属性为真。</li> 
    </ul> <p>这个方法的代码如下：</p> <pre><code> void Misbehaving(NodeId pnode, int howmuch, const std::string&amp; message) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
 {
     if (howmuch == 0)
         return;
   
     CNodeState *state = State(pnode);
     if (state == nullptr)
         return;
   
     state-&gt;nMisbehavior += howmuch;
     int banscore = gArgs.GetArg("-banscore", DEFAULT_BANSCORE_THRESHOLD);
     std::string message_prefixed = message.empty() ? "" : (": " + message);
     if (state-&gt;nMisbehavior &gt;= banscore &amp;&amp; state-&gt;nMisbehavior - howmuch &lt; banscore)
     {
         LogPrint(BCLog::NET, "%s: %s peer=%d (%d -&gt; %d) BAN THRESHOLD EXCEEDED%s\n", __func__, state-&gt;name, pnode, state-&gt;nMisbehavior-howmuch, state-&gt;nMisbehavior, message_prefixed);
         state-&gt;fShouldBan = true;
     } else
         LogPrint(BCLog::NET, "%s: %s peer=%d (%d -&gt; %d)%s\n", __func__, state-&gt;name, pnode, state-&gt;nMisbehavior-howmuch, state-&gt;nMisbehavior, message_prefixed);
 }
</code></pre> </li> 
   <li> <p>从输入流中取得远程对等节点发送的版本信息、支持的服务信息、发送时间、显示地址。</p> <pre><code> vRecv &gt;&gt; nVersion &gt;&gt; nServiceInt &gt;&gt; nTime &gt;&gt; addrMe;
 nSendVersion = std::min(nVersion, PROTOCOL_VERSION);
 nServices = ServiceFlags(nServiceInt);
</code></pre> </li> 
   <li> <p>如果对等节点是出站的，调用 <code>CConnman</code> 对象的 <code>SetServices</code> 方法，设置对等节点所支持的服务。</p> <pre><code> if (!pfrom-&gt;fInbound)
 {
     connman-&gt;SetServices(pfrom-&gt;addr, nServices);
 }
</code></pre> <p>方法内部最终会获取节点的地址信息对象，然后设置其支持的服务属性。</p> </li> 
   <li> <p>如果对等节点是出站的，且不是临时的试探者，且不是手动指定的，且与本地服务不匹配，那么：在开启 BIP 161 情况下发送拒绝消息；然后设置远程对待节点为断开；然后返回假。</p> <pre><code> if (!pfrom-&gt;fInbound &amp;&amp; !pfrom-&gt;fFeeler &amp;&amp; !pfrom-&gt;m_manual_connection &amp;&amp; !HasAllDesirableServiceFlags(nServices))
 {
     LogPrint(BCLog::NET, "peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\n", pfrom-&gt;GetId(), nServices, GetDesirableServiceFlags(nServices));
     if (enable_bip61) {
         connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,strprintf("Expected to offer services %08x", GetDesirableServiceFlags(nServices))));
     }
     pfrom-&gt;fDisconnect = true;
     return false;
 }
</code></pre> </li> 
   <li> <p>如果发送的版本的小于协义规定的最小版本 <code>MIN_PEER_PROTO_VERSION</code>，那么：在开启 BIP 161 情况下发送拒绝消息；然后设置远程对待节点为断开；然后返回假。</p> <pre><code> if (nVersion &lt; MIN_PEER_PROTO_VERSION) {
     // disconnect from peers older than this proto version
     LogPrint(BCLog::NET, "peer=%d using obsolete version %i; disconnecting\n", pfrom-&gt;GetId(), nVersion);
     if (enable_bip61) {
         connman-&gt;PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,
                            strprintf("Version must be %d or greater", MIN_PEER_PROTO_VERSION)));
     }
     pfrom-&gt;fDisconnect = true;
     return false;
 }
</code></pre> </li> 
   <li> <p>如果输入流不为空，则从流中依次取得 addrFrom、nNonce、strSubVer（客户端字符串）、nStartingHeight（客户端区块链的高度）、fRelay等信息。</p> <pre><code> if (!vRecv.empty())
     vRecv &gt;&gt; addrFrom &gt;&gt; nNonce;
 if (!vRecv.empty()) {
     vRecv &gt;&gt; LIMITED_STRING(strSubVer, MAX_SUBVERSION_LENGTH);
     cleanSubVer = SanitizeString(strSubVer);
 }
 if (!vRecv.empty()) {
     vRecv &gt;&gt; nStartingHeight;
 }
 if (!vRecv.empty())
     vRecv &gt;&gt; fRelay;
</code></pre> </li> 
   <li> <p>如果对等节点节点是入站节点，且连接到自身，那么设置远程对待节点为断开，并返回真。</p> <pre><code> if (pfrom-&gt;fInbound &amp;&amp; !connman-&gt;CheckIncomingNonce(nNonce))
 {
     LogPrintf("connected to self at %s, disconnecting\n", pfrom-&gt;addr.ToString());
     pfrom-&gt;fDisconnect = true;
     return true;
 }
</code></pre> </li> 
   <li> <p>如果对等节点是入站节点，且其地址是可路由的，那么调用 <code>SeenLocal</code> 方法进行处理。</p> <pre><code> if (pfrom-&gt;fInbound &amp;&amp; addrMe.IsRoutable())
 {
     SeenLocal(addrMe);
 }
</code></pre> <p>在 <code>SeenLocal</code> 方法中，如果这个地址在 <code>mapLocalHost</code> 集合中存在，那么设置其对应的 <code>LocalServiceInfo</code> 对象的 <code>nScore</code> 加1。如晨不存在，则直接返回真。</p> <pre><code> bool SeenLocal(const CService&amp; addr)
 {
     {
         LOCK(cs_mapLocalHost);
         if (mapLocalHost.count(addr) == 0)
             return false;
         mapLocalHost[addr].nScore++;
     }
     return true;
 }
</code></pre> </li> 
   <li> <p><strong>如果是对等节点是入站节点，则调用 <code>PushNodeVersion</code> 方法，发送自身的版本信息给远程对等节点</strong>。</p> <p>节点在收到远程对待节点发送来的版本消息，并且经过检查没问题之后，自身发送一个版本消息给对远程对待节点。</p> </li> 
   <li> <p><strong>调用 <code>CConnman</code> 对象的 <code>PushMessage</code> 方法，发送版本确认包</strong>。</p> <p>因为当前的 <code>version</code> 消息，是别的节点请求我们的，当我们允许其连接时，发送版本确认包。注意，只有在双方都发送版本确认包之后，双方才可以互相发送消息。</p> </li> 
   <li> <p>设置对等节点的服务属性、保存地址、对等节点运行的客户端、对等节点区块链的高度、版本等。如果对等节点隔离见证服务，则设置对等节点对应的状态对象的相关属性为真。</p> <pre><code> pfrom-&gt;nServices = nServices;
 pfrom-&gt;SetAddrLocal(addrMe);
 {
     LOCK(pfrom-&gt;cs_SubVer);
     pfrom-&gt;strSubVer = strSubVer;
     pfrom-&gt;cleanSubVer = cleanSubVer;
 }
 pfrom-&gt;nStartingHeight = nStartingHeight;
 pfrom-&gt;fClient = (!(nServices &amp; NODE_NETWORK) &amp;&amp; !(nServices &amp; NODE_NETWORK_LIMITED));
 pfrom-&gt;m_limited_node = (!(nServices &amp; NODE_NETWORK) &amp;&amp; (nServices &amp; NODE_NETWORK_LIMITED));
 pfrom-&gt;fRelayTxes = fRelay;
 pfrom-&gt;SetSendVersion(nSendVersion);
 pfrom-&gt;nVersion = nVersion;
</code></pre> </li> 
   <li> <p>调用 <code>UpdatePreferredDownload</code> 方法，将对等节点设为可能的首先下载节点。</p> <p>如果节点是出站的或者在白名单中，并且可以提供区块服务，并且 <code>fOneShot</code> 属性为假，即可作为首选下载节点。</p> </li> 
   <li> <p>如果对等节点不是入站节点，进行如下处理。</p> 
    <ul> 
     <li> <p>如果对等节点不是孤立的，并且不需要进行IBD下载（调用 <code>IsInitialBlockDownload</code> 函数进行判断，通常第一次启动或在常时间离线，比如24小时，有大师区块需要下载时，本方法返回真），那么：</p> 
      <ul> 
       <li>调用 <code>GetLocalAddress</code> 方法，获取对该对等节点来说是最佳的地址。</li> 
       <li>如果找到的地址是可路由的，那么调用对等节点的 <code>PushAddress</code> 方法，把找到的地址保存在 <code>vAddrToSend</code> 集合中。</li> 
       <li>否则，调用 <code>IsPeerAddrLocalGood</code> 测试远程对等节点看到的我们的外部IP是否可以路由。如果可以路由，那么调用对等节点的 <code>PushAddress</code> 方法，把地址保存在 <code>vAddrToSend</code> 集合中。</li> 
      </ul> <p>以上代码如下：</p> <pre><code>if (fListen &amp;&amp; !IsInitialBlockDownload())
{
    CAddress addr = GetLocalAddress(&amp;pfrom-&gt;addr, pfrom-&gt;GetLocalServices());
    FastRandomContext insecure_rand;
    if (addr.IsRoutable())
    {
        LogPrint(BCLog::NET, "ProcessMessages: advertising address %s\n", addr.ToString());
        pfrom-&gt;PushAddress(addr, insecure_rand);
    } else if (IsPeerAddrLocalGood(pfrom)) {
        addr.SetIP(addrMe);
        LogPrint(BCLog::NET, "ProcessMessages: advertising address %s\n", addr.ToString());
        pfrom-&gt;PushAddress(addr, insecure_rand);
    }
}
</code></pre> </li> 
     <li> <p>如果需要，比如：本地保存的远程地址少于 1000个，那么调<strong>用 <code>PushMessage</code> 方法，请求远程节点发送更多的地址，即发送<code>getaddr</code> 消息</strong>。然后把请求地址的标志设置为真。</p> <pre><code>if (pfrom-&gt;fOneShot || pfrom-&gt;nVersion &gt;= CADDR_TIME_VERSION || connman-&gt;GetAddressCount() &lt; 1000)
{
    connman-&gt;PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));
    pfrom-&gt;fGetAddr = true;
}
</code></pre> </li> 
     <li> <p>调用 <code>MarkAddressGood</code> 方法，保存远程对等节点，表明它是可访问的。</p> <pre><code>connman-&gt;MarkAddressGood(pfrom-&gt;addr);
</code></pre> </li> 
    </ul> </li> 
   <li> <p>如果远程对等节点的版本小于 70012，则发送一个 <code>alert</code> 消息。</p> <pre><code> if (pfrom-&gt;nVersion &lt;= 70012) {
     CDataStream finalAlert(ParseHex("60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50"), SER_NETWORK, PROTOCOL_VERSION);
     connman-&gt;PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make("alert", finalAlert));
 }
</code></pre> </li> 
   <li> <p>如果节点是临时引导节点，则断开节点，即设置节点的断开属性为真。</p> <pre><code> if (pfrom-&gt;fFeeler) {
     assert(pfrom-&gt;fInbound == false);
     pfrom-&gt;fDisconnect = true;
 }
</code></pre> </li> 
   <li> <p>版本消息处理完成，返回真。</p> </li> 
  </ol> 
  <h3><a id="12_verack__255"></a>1.2、接收 <code>verack</code> 消息</h3> 
  <p>节点作为客户端，处理服务器节点发送的版本响应消息，即版本确认消息。</p> 
  <p>代码在 <code>net_processing.cpp</code> 文件中的 <code>ProcessMessage</code> 方法的 1805 行。具体处理过程如下：</p> 
  <ol> 
   <li> <p>设置接收到的版本确认消息中的版本号。</p> <pre><code> pfrom-&gt;SetRecvVersion(std::min(pfrom-&gt;nVersion.load(), PROTOCOL_VERSION));
</code></pre> </li> 
   <li> <p>如果对等节点不是入站节点，设置对等节点的状态对象的当前连接属性为真。</p> <pre><code> if (!pfrom-&gt;fInbound) {
     LOCK(cs_main);
     State(pfrom-&gt;GetId())-&gt;fCurrentlyConnected = true;
 }
</code></pre> </li> 
   <li> <p>如果对等节点的版本大于支持使用区块头部来公告区块的最小版本（<code>SENDHEADERS_VERSION = 70012</code>），那么：</p> <p><strong>调用 <code>PushMessage</code> 方法发送 <code>sendheaders</code> 消息，通知远程对等节点我们更愿意通过 <code>headers</code> 消息来接收新区块的公告，而不是 <code>inv</code> 消息</strong>。</p> <p>这样以后当有新区块需要公告时，远程对等就会通过 <code>headers</code> 消息把区块头部先发送给我们，当我们再次请求时才会发送完整的区块。</p> </li> 
   <li> <p>如果对等节点的版本大于支持紧凑区块的最小版本（<code>SHORT_IDS_BLOCKS_VERSION = 70014</code>），那么分两种情况处理。</p> 
    <ul> 
     <li>第一种情况，如果同时支持闪电网络，那么给<strong>对等节点发送一个紧凑区块版本为 2 的 <code>sendcmpct</code> 消息</strong>。</li> 
     <li>第二种情况，如果不支持闪电网络，那么给<strong>对等节点发送一个紧凑区块版本为 1 的 <code>sendcmpct</code> 消息</strong>。</li> 
    </ul> <p>无论哪一种情况，远程对等节点以后都会向本节点发送紧凑区块。</p> <p>代码如下：</p> <pre><code>if (pfrom-&gt;nVersion &gt;= SHORT_IDS_BLOCKS_VERSION) {
    bool fAnnounceUsingCMPCTBLOCK = false;
    uint64_t nCMPCTBLOCKVersion = 2;
    if (pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS)
        connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));
    nCMPCTBLOCKVersion = 1;
    connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));
}
</code></pre> </li> 
   <li> <p>设置对等节点完全成功连接的标志为真，然后返回真。</p> <pre><code> pfrom-&gt;fSuccessfullyConnected = true;
 return true;
</code></pre> </li> 
  </ol> 
  <p>只有在对等节点双方都各自发送版本消息和确认消息之后，双方才真正建立起连接关系，才可以进行后续的交互，比如请求数据消息等。</p> 
  <h2><a id="2_311"></a>2、保持连接的处理</h2> 
  <p>因为在比特币网络中，任何一个节点都可以随时加入网络，也可以随时离开网络，所以两个连接的节点需要定时互相发送 <code>ping</code> 和 <code>pong</code> 来确保接点可以连接，如果在特定的时间内没有 <code>ping</code> 消息，节点即可认为连接已经断开。</p> 
  <h3><a id="21ping__315"></a>2.1、<code>ping</code> 消息</h3> 
  <p>这个消息比较简单，不作具体解释，代码如下：</p> 
  <pre><code>if (strCommand == NetMsgType::PING) {
    if (pfrom-&gt;nVersion &gt; BIP0031_VERSION)
    {
        uint64_t nonce = 0;
        vRecv &gt;&gt; nonce;
        connman-&gt;PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce));
    }
    return true;
}
</code></pre> 
  <h3><a id="21pong__331"></a>2.1、<code>pong</code> 消息</h3> 
  <p>这个消息也比较简单，不作具体解释，代码如下：</p> 
  <pre><code>if (strCommand == NetMsgType::PONG) {
    int64_t pingUsecEnd = nTimeReceived;
    uint64_t nonce = 0;
    size_t nAvail = vRecv.in_avail();
    bool bPingFinished = false;
    std::string sProblem;
    if (nAvail &gt;= sizeof(nonce)) {
        vRecv &gt;&gt; nonce;
        if (pfrom-&gt;nPingNonceSent != 0) {
            if (nonce == pfrom-&gt;nPingNonceSent) {
                bPingFinished = true;
                int64_t pingUsecTime = pingUsecEnd - pfrom-&gt;nPingUsecStart;
                if (pingUsecTime &gt; 0) {
                    pfrom-&gt;nPingUsecTime = pingUsecTime;
                    pfrom-&gt;nMinPingUsecTime = std::min(pfrom-&gt;nMinPingUsecTime.load(), pingUsecTime);
                } else {
                    sProblem = "Timing mishap";
                }
            } else {
                sProblem = "Nonce mismatch";
                if (nonce == 0) {
                    bPingFinished = true;
                    sProblem = "Nonce zero";
                }
            }
        } else {
            sProblem = "Unsolicited pong without ping";
        }
    } else {
        bPingFinished = true;
        sProblem = "Short payload";
    }
    if (bPingFinished) {
        pfrom-&gt;nPingNonceSent = 0;
    }
    return true;
}
</code></pre> 
  <h2><a id="3_377"></a>3、获取更多地址的处理</h2> 
  <p>如果对等节点需要更多地址时，会发送 <code>getaddr</code> 消息请求远程对等节点发送更多的地址，当远程对等节点收到请求后，会通过发送 <code>addr</code> 消息传递更多的地址。</p> 
  <h3><a id="31getaddr__381"></a>3.1、<code>getaddr</code> 消息</h3> 
  <p>节点作为服务器，响应客户端节点发送的请求地址消息。</p> 
  <p>代码在 <code>net_processing.cpp</code> 文件中的 <code>ProcessMessage</code> 方法的 2728 行。具体处理如下：</p> 
  <ol> 
   <li> <p>如果对等节点不是入站节点，则忽略该请求，并返回。</p> <pre><code> if (!pfrom-&gt;fInbound) {
     return true;
 }
</code></pre> </li> 
   <li> <p>如果对等节点已发送过请求地址，即远程对等节点重复请求地址，则忽略该请求，并返回。</p> <pre><code> if (pfrom-&gt;fSentAddr) {
     return true;
 }
</code></pre> </li> 
   <li> <p>设置对等节点已发送过请求地址标志为真。清空对等节点的 <code>vAddrToSend</code> 集合。</p> <pre><code> pfrom-&gt;fSentAddr = true;
 pfrom-&gt;vAddrToSend.clear();
</code></pre> </li> 
   <li> <p>调用 <code>GetAddresses</code> 方法，返回要发送的地址。</p> <p>从地址管理器随机找到 N 个地址，N不能大于最大值 2500，并且这些地址的状态都比较好。</p> </li> 
   <li> <p>遍历要发送的节点，调用对等节点的 <code>PushAddress</code> 方法，把要发送的地址保存到 <code>vAddrToSend</code> 向量中。</p> <p><strong>由线程进行定时发送 <code>addr</code> 消息</strong>。</p> </li> 
   <li> <p>返回真。</p> </li> 
  </ol> 
  <h3><a id="32addr__420"></a>3.2、<code>addr</code> 消息</h3> 
  <p>节点作为客户端，响应服务器节点返回的地址。</p> 
  <p>代码在 <code>net_processing.cpp</code> 文件中的 <code>ProcessMessage</code> 方法的 1849 行。具体处理如下：</p> 
  <ol> 
   <li> <p>从输入流中取得远程对等节点发送的地址列表保存到 <code>vAddr</code> 向量中。</p> <pre><code> std::vector&lt;CAddress&gt; vAddr;
 vRecv &gt;&gt; vAddr;
</code></pre> </li> 
   <li> <p>如果远程对等节点的版本小于 31402（在这种版本比较老的情况下，我们只在初始时接收 DNS 种子服务器发送的地址），并且本保存的地址已经超过 1000，则直接返回真。</p> <pre><code> if (pfrom-&gt;nVersion &lt; CADDR_TIME_VERSION &amp;&amp; connman-&gt;GetAddressCount() &gt; 1000)
     return true;
</code></pre> </li> 
   <li> <p>如果远程对等节点发送的地址超过 1000，调用 <code>Misbehaving</code> 方法，对远程节点进行惩罚，可能导致其被禁止发送。</p> <pre><code> if (vAddr.size() &gt; 1000)
 {
     LOCK(cs_main);
     Misbehaving(pfrom-&gt;GetId(), 20, strprintf("message addr size() = %u", vAddr.size()));
     return false;
 }
</code></pre> </li> 
   <li> <p>遍历所有的地址列表，进行如下处理：</p> 
    <ul> 
     <li> <p>如果线程被中止，则返回真。</p> </li> 
     <li> <p>如果代表的节点不支持 <code>NODE_NETWORK</code>、<code>NODE_NETWORK_LIMITED</code> 两者之一的服务，则处理下一个。</p> <pre><code>if (!MayHaveUsefulAddressDB(addr.nServices) &amp;&amp; !HasAllDesirableServiceFlags(addr.nServices))
    continue;
</code></pre> </li> 
     <li> <p>设置地址的时间属性</p> <pre><code>if (addr.nTime &lt;= 100000000 || addr.nTime &gt; nNow + 10 * 60)
    addr.nTime = nNow - 5 * 24 * 60 * 60;
</code></pre> </li> 
     <li> <p>调用对等节点的 <code>AddAddressKnown</code> 方法，把当前地址保存到已知地址 <code>addrKnown</code> 中。</p> </li> 
     <li> <p>如果地址是可路由的，则加入 <code>vAddrOk</code> 列表中。</p> <pre><code>if (fReachable)
    vAddrOk.push_back(addr);
</code></pre> </li> 
    </ul> </li> 
   <li> <p>调用 <code>CConnman::AddNewAddresses</code> 方法，保存 <code>vAddrOk</code> 列表中的地址。</p> <p><code>AddNewAddresses</code> 方法最终把地址列表保存在 <code>CAddrMan</code> 对象的 <code>mapInfo</code> 属性中。</p> </li> 
   <li> <p>如果发送的地址数量少于 1000，设置对等节点的获取地址标志为假。以便以后再次获取地址。如果对等节点的 <code>fOneShot</code> 属性为真，则设置对等节点的断开连接标志为真。</p> <pre><code> if (vAddr.size() &lt; 1000)
     pfrom-&gt;fGetAddr = false;
 if (pfrom-&gt;fOneShot)
     pfrom-&gt;fDisconnect = true;
</code></pre> </li> 
   <li> <p>返回真。</p> </li> 
  </ol> 
  <h2><a id="4sendheaders__493"></a>4、<code>sendheaders</code> 消息</h2> 
  <p>节点作为服务器，响应客户端节点发送的更愿意接收头部而不是区块体的设置消息。</p> 
  <p>代码在 <code>net_processing.cpp</code> 文件中的 <code>ProcessMessage</code> 方法的 1899 行。这个消息的处理比较简单，只把节点对应的状态对象的 <code>fPreferHeaders</code> 属性为真。</p> 
  <p>代码如下：</p> 
  <pre><code>if (strCommand == NetMsgType::SENDHEADERS) {
    LOCK(cs_main);
    State(pfrom-&gt;GetId())-&gt;fPreferHeaders = true;
    return true;
}
</code></pre> 
  <h2><a id="5sendcmpct__511"></a>5、<code>sendcmpct</code> 消息</h2> 
  <p>节点作为服务器，响应客户端节点发送的接收紧凑区块而不是普通区块的设置消息。</p> 
  <p>代码在 <code>net_processing.cpp</code> 文件中的 <code>ProcessMessage</code> 方法的 1905 行。</p> 
  <p>以 <code>if (strCommand == NetMsgType::SENDCMPCT) {</code> 为开始，具体如下：</p> 
  <ol> 
   <li> <p>从输入流中取得 <code>fAnnounceUsingCMPCTBLOCK</code>、<code>nCMPCTBLOCKVersion</code> 等参数。</p> <pre><code> vRecv &gt;&gt; fAnnounceUsingCMPCTBLOCK &gt;&gt; nCMPCTBLOCKVersion;
</code></pre> </li> 
   <li> <p>如果紧凑区块版本 <code>nCMPCTBLOCKVersion</code> 等于 1 ，或者节点可以响应包含隔离见证的区块和交易请求，且 <code>nCMPCTBLOCKVersion</code> 等于2，那么进行下面的处理。</p> <pre><code> if (nCMPCTBLOCKVersion == 1 || ((pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS) &amp;&amp; nCMPCTBLOCKVersion == 2)) {
     LOCK(cs_main);
     if (!State(pfrom-&gt;GetId())-&gt;fProvidesHeaderAndIDs) {
         State(pfrom-&gt;GetId())-&gt;fProvidesHeaderAndIDs = true;
         State(pfrom-&gt;GetId())-&gt;fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;
     }
     if (State(pfrom-&gt;GetId())-&gt;fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces
         State(pfrom-&gt;GetId())-&gt;fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;
     if (!State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion) {
         if (pfrom-&gt;GetLocalServices() &amp; NODE_WITNESS)
             State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);
         else
             State(pfrom-&gt;GetId())-&gt;fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);
     }
 }
</code></pre> </li> 
   <li> <p>返回真。</p> </li> 
  </ol> 
  <h2><a id="6feefilter__547"></a>6、<code>feefilter</code> 消息</h2> 
  <p>节点作为服务器，响应客户端节点发送的费率过滤设置消息。</p> 
  <p>代码在 <code>net_processing.cpp</code> 文件中的 <code>ProcessMessage</code> 方法的 2911 行。</p> 
  <p>以 <code>if (strCommand == NetMsgType::FEEFILTER) {</code> 为开始，这个处理比较简单，代码如下：</p> 
  <pre><code>if (strCommand == NetMsgType::FEEFILTER) {
    CAmount newFeeFilter = 0;
    vRecv &gt;&gt; newFeeFilter;
    if (MoneyRange(newFeeFilter)) {
        {
            LOCK(pfrom-&gt;cs_feeFilter);
            pfrom-&gt;minFeeFilter = newFeeFilter;
        }
        LogPrint(BCLog::NET, "received: feefilter of %s from peer=%d\n", CFeeRate(newFeeFilter).ToString(), pfrom-&gt;GetId());
    }
    return true;
}
</code></pre> 
  <p>其中 <code>MoneyRange</code> 方法检查费率参数是否在 0 到 2100 万比特币之间。</p> 
  <h2><a id="7filterload__574"></a>7、<code>filterload</code> 消息</h2> 
  <p>节点作为服务器，响应 SPV 节点发送的布隆过滤设置消息。</p> 
  <p>代码在 <code>net_processing.cpp</code> 文件中的 <code>ProcessMessage</code> 方法的 2851 行。</p> 
  <p>以 <code>if (strCommand == NetMsgType::FILTERLOAD) {</code> 为开始，具体如下：</p> 
  <ol> 
   <li> <p>从输入流中取得过滤器参数。</p> <pre><code> CBloomFilter filter;
 vRecv &gt;&gt; filter;
</code></pre> </li> 
   <li> <p>调用布隆过滤器的 <code>IsWithinSizeConstraints</code> 方法，检查过滤器的是否超过限制区间。如果超过，则调用 <code>Misbehaving</code> 方法，对远程对等节点进行设置，可能导致其被禁止。如果不超过，则：</p> 
    <ul> 
     <li>生成一个新的 <code>CBloomFilter</code> 过滤器对象，并设置节点的过滤器属性 <code>pfilter</code> 为新生成的对象。</li> 
     <li>调用节点过滤器的 <code>UpdateEmptyFull</code> 方法，重置其内部属性 <code>vData</code>。</li> 
     <li>设置中继交易属性 <code>fRelayTxes</code> 为真。</li> 
    </ul> <p>以上代码如下：</p> <pre><code>if (!filter.IsWithinSizeConstraints())
{
    LOCK(cs_main);
    Misbehaving(pfrom-&gt;GetId(), 100);
}
else
{
    LOCK(pfrom-&gt;cs_filter);
    pfrom-&gt;pfilter.reset(new CBloomFilter(filter));
    pfrom-&gt;pfilter-&gt;UpdateEmptyFull();
    pfrom-&gt;fRelayTxes = true;
}
</code></pre> </li> 
   <li> <p>返回真。</p> </li> 
  </ol> 
  <h3><a id="8filteradd__614"></a>8、<code>filteradd</code> 消息</h3> 
  <p>节点作为服务器，响应 SPV 节点发送的增加布隆过滤消息。</p> 
  <p>代码在 <code>net_processing.cpp</code> 文件中的 <code>ProcessMessage</code> 方法的 2871 行。</p> 
  <p>以 <code>if (strCommand == NetMsgType::FILTERADD) {</code> 为开始，具体如下：</p> 
  <ol> 
   <li> <p>从输入流中取得要增加的过滤器。</p> <pre><code> std::vector&lt;unsigned char&gt; vData;
 vRecv &gt;&gt; vData;
</code></pre> </li> 
   <li> <p>如果发送的字节数量大于 520，则设置变量 <code>bad</code> 为真。如果不大于，则进行下面的判断。</p> <p>如果已经发送过 <code>filterload</code> 消息，则把新的过滤器保存到过滤器集合中。否则，设置变量 <code>bad</code> 为真。</p> <p>代码如下：</p> <pre><code>bool bad = false;
if (vData.size() &gt; MAX_SCRIPT_ELEMENT_SIZE) {
    bad = true;
} else {
    LOCK(pfrom-&gt;cs_filter);
    if (pfrom-&gt;pfilter) {
        pfrom-&gt;pfilter-&gt;insert(vData);
    } else {
        bad = true;
    }
}
</code></pre> </li> 
   <li> <p>如果变量为真，调用 <code>Misbehaving</code> 方法，惩罚节点。</p> </li> 
   <li> <p>返回真。</p> </li> 
  </ol> 
  <h2><a id="9filterclear_653"></a>9、<code>filterclear</code></h2> 
  <p>节点作为服务器，响应 SPV 节点发送的增加布隆过滤消息。</p> 
  <p>代码在 <code>net_processing.cpp</code> 文件中的 <code>ProcessMessage</code> 方法的 2895 行。</p> 
  <p>以 <code>if (strCommand == NetMsgType::FILTERCLEAR) {</code> 为开始，这个消息处理比较简单，代码如下，可以自己理解。</p> 
  <pre><code>if (strCommand == NetMsgType::FILTERCLEAR) {
    LOCK(pfrom-&gt;cs_filter);
    if (pfrom-&gt;GetLocalServices() &amp; NODE_BLOOM) {
        pfrom-&gt;pfilter.reset(new CBloomFilter());
    }
    pfrom-&gt;fRelayTxes = true;
    return true;
}
</code></pre> 
  <hr> 
  <p><strong>我是区小白，Ulord全球社区联盟（优得社区）核心区块链技术开发者，深入研究比特币,以太坊,EOS Dash,Rsk,Java, Nodejs,PHP,Python,C++ 我希望能聚集更多区块链开发者，一起学习共同进步。p</strong></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-a47e74522c.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Ulord_123/article/details/83586966,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Ulord_123/article/details/83586966,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										if(typeof window.localStorage === "object" && typeof window.csdn.anonymousUserLimit === "object"){
											if(!window.csdn.anonymousUserLimit.judgment()){
												window.csdn.anonymousUserLimit.Jumplogin();
												return false;
											}else if(!currentUserName){
												window.csdn.anonymousUserLimit.updata();
											}
										}
										
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
