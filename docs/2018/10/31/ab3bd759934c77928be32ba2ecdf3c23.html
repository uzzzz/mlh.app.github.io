<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>用以太坊区块链保证Asp.Net Core的API安全（下） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="用以太坊区块链保证Asp.Net Core的API安全（下）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="上一篇用以太坊区块链保证Asp.Net Core的API安全（上）我们介绍了基本的解决方案，这一篇我们重点来看客户端。 正如我们所说，我们的DApp是一个简单的HTML/ES6客户端。我们将在Asp.Net Core 2之上构建客户端，以利用IIS Express和Visual Studio IDE。因此，Startup.cs类中的Configure方法将是： if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseDefaultFiles(); app.UseStaticFiles(); 使DApp成为NPM项目并安装必备条件以使用ES6 Javascript标准。这不是强制性的，可以使用自己的堆栈构建DApp。 从项目文件夹运行Powershell并运行以下NPM命令： npm init npm install webpack npm install babel-core babel-loader --save-dev npm install babel-preset-es2015 --save-dev npm install babel-preset-stage-0 --save-dev npm install babel-polyfill --save npm install babel-runtime --save npm install babel-plugin-transform-runtime --save-dev 要配置webpack/babel，请使用以下配置创建webpack.config.js文件： var path = require(&quot;path&quot;); module.exports = { entry: [ &quot;babel-polyfill&quot;, &quot;./src/main&quot; ], output: { publicPath: &quot;/js/&quot;, path: path.join(__dirname, &quot;/wwwroot/js/&quot;), filename: &quot;main.build.js&quot; } }; 我们已设定webpack将src/main.js文件构建到/www/js/main.build.js。 安装以太坊扩展包： npm install web3 npm install ethereumjs-util Web3是一个javascript封装包，它简化了针对以太坊区块链的JSON RPC调用。Ethereumjs-util提供了一些以太坊特定的实用程序。让我们构建一个非常简单的HTML页面。我们需要一个登录按钮和另一个按钮来从我们的API层加载一些安全数据： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Ethereum Jwt Client&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Ethereum Jwt Client&lt;/h1&gt; &lt;div id=&quot;login-view&quot;&gt; &lt;label&gt;Your account: &lt;/label&gt; &lt;span id=&quot;eth_account_span&quot;&gt;&lt;/span&gt; &lt;button type=&quot;submit&quot; id=&quot;login_btn&quot;&gt;Login&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;data-view&quot;&gt; &lt;button type=&quot;submit&quot; id=&quot;load_data_btn&quot;&gt;Request secured data&lt;/button&gt; &lt;ul id=&quot;data_list&quot;&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;js/main.build.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; DApp逻辑将驻留在src/main.js文件中，正如我们在webpack.config.js文件中指定的那样。src/main.js文件将是： let ethUtil = require(&#39;ethereumjs-util&#39;); let Web3 = require(&#39;web3&#39;); let coinbase = null; let accessToken = null; let init = () =&gt; { if (typeof web3 !== &#39;undefined&#39;) { web3 = new Web3(web3.currentProvider); web3.eth.getCoinbase(function (err, account) { if (err === null &amp;&amp; ethUtil.isValidAddress(account)) { coinbase = account; eth_account_span.innerHTML = coinbase; } else { eth_account_span.innerHTML = &#39;Please unlock your account and refresh the page&#39;; console.error(err); } }); } else { eth_account_span.innerHTML = &#39;Please install or unlock Metamask browser plugin or navigate this page with Mist or another web3 browser&#39;; } }; let request = obj =&gt; { return new Promise((resolve, reject) =&gt; { let xhr = new XMLHttpRequest(); xhr.open(obj.method || &quot;GET&quot;, obj.url); if (obj.headers) { Object.keys(obj.headers).forEach(key =&gt; { xhr.setRequestHeader(key, obj.headers[key]); }); } xhr.onload = () =&gt; { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { resolve(xhr.response); } else { reject(xhr.statusText); } }; xhr.onerror = () =&gt; reject(xhr.statusText); xhr.send(obj.body); }); }; login_btn.addEventListener(&#39;click&#39;, (e) =&gt; { e.preventDefault(); login_btn.setAttribute(&#39;disabled&#39;, &#39;disabled&#39;); login_btn.innerHTML = &#39;Please sign the message&#39;; let plain = &#39;Hi, you request a login from client to Eth Jwt Api. Please sign this message. This is not a transaction, is completely free and 100% secure. We\&#39;ll use your signature to prove your ownership over your private key server side.&#39;; let msg = ethUtil.bufferToHex(new Buffer(plain, &#39;utf8&#39;)); let hash = ethUtil.bufferToHex(ethUtil.keccak256(&quot;\x19Ethereum Signed Message:\n&quot; + plain.length + plain)); let from = coinbase; let params = [msg, from]; let method = &#39;personal_sign&#39;; web3.currentProvider.sendAsync({ method, params, from, }, function (err, result) { if (err || result.error) { login_btn.removeAttribute(&#39;disabled&#39;); login_btn.innerHTML = &#39;Login&#39;; console.error(err); return console.error(result.error); } console.log({ &#39;signature&#39;: result.result, &#39;msg&#39;: msg, &#39;hash&#39;: hash }); login_btn.innerHTML = &#39;Requesting token...&#39;; let loginData = {}; loginData.signer = from; loginData.signature = result.result; loginData.message = msg; loginData.hash = hash; request({ url: &#39;http://localhost:49443/api/token&#39;, body: JSON.stringify(loginData), method: &#39;post&#39;, headers: { &#39;Authorization&#39;: &#39;Bearer &#39; + accessToken, &#39;Content-type&#39;: &#39;application/json&#39; } }).then(data =&gt; { var json = JSON.parse(data); accessToken = json.token; console.log(&#39;access token: &#39; + accessToken); login_btn.removeAttribute(&#39;disabled&#39;); login_btn.innerHTML = &#39;Login&#39;; }).catch(error =&gt; { console.error(error); login_btn.removeAttribute(&#39;disabled&#39;); login_btn.innerHTML = &#39;Login&#39;; }); }); }); load_data_btn.addEventListener(&#39;click&#39;, (e) =&gt; { e.preventDefault(); request({ url: &#39;http://localhost:49443/api/values&#39;, headers: { &#39;Authorization&#39;: &#39;Bearer &#39; + accessToken } }).then(data =&gt; { var json = JSON.parse(data); for (let i = 0; i &lt; json.length; i++) { data_list.innerHTML += &#39;&lt;li&gt;&#39; + json[i] + &#39;&lt;/li&gt;&#39;; } }).catch(error =&gt; { console.error(err); }); }); window.addEventListener(&#39;load&#39;, init); 1.coinbase和accessToken是全局变量，分别存储用户以太坊帐户和JWT token。 2.init函数从Metamask提供的提供程序初始化web3对象，然后它尝试检索用户的帐户（coinbase）。这需要解锁在Metamask中签名的帐户。 3.require函数只是hxr对象的封装，可以轻松地向API层调用ajax。 4.load_data_btn单击处理程序对API层安全端点进行ajax调用。这需要有效的accessToken才能工作，否则，API层将响应401 HTTP响应。 5.login_btn单击是一个两步功能。首先，它要求用户签署任意消息。签名后，它会将帐户，签名，明文消息和带前缀的哈希发送到令牌端点。 请注意，web3.personal.sign将十六进制格式（0x …）的普通字符串的字节数组作为输入。 正如我们所说的，服务器端，我们将使用两种不同的方式从签名中恢复公钥：在一个中我们将使用JSON RPC 接口中的web3.personal.ecrecover（web3.personal.sign对应）;在另一个中，我们将使用底层的ecrecover离线功能。根据文档，web3.personal.sign使用底层签名函数来签署hash和前缀消息，因此，为了使用底层ecrecover对应，我们还需要计算并将此hash发送到令牌端点。 运行两个应用程序并使用安装了Metamask插件的浏览器导航到客户端。请记住，为了将src/main.js文件构建到js/main.build.js，你需要从Powershell运行webpac命令。如果一切正常，客户端将检索coinbase，你将在页面上看到你的帐户： 如果你现在单击“请求数据”按钮，将获得HTTP响应401。如果单击“登录”按钮，Metamask将提示你签名： 签名后，处理程序将对令牌端点进行ajax调用。在此阶段，身份验证方法不会检查任何签名，因此端点将始终发出JWT令牌。一旦收到JWT令牌，客户端就能通过ajax调用安全端点。如果现在单击“请求数据”按钮，将收到HTTP响应200和数据负载： 从签名中检索以太坊帐户 到目前为止，EthereumJwtApi是一个简单的JWT Asp.Net核心示例，因为它不提供任何有效的身份验证方法。 TokenController的关键部分是两个Authenticate方法及其从签名中检索以太坊帐户的能力。为此，你需要安装Nethereum.Web3 NuGet包。Nethereum是以太坊的.Net实现。 Authenticate方法只是对web3.personal.ecrecover函数进行JSON RPC调用： private async Task&lt;UserVM&gt; Authenticate(LoginVM login) { UserVM user = null; var client = new RpcClient(new Uri(_config[&quot;Nethereum:Geth&quot;])); // Require the RPC endpoint of a Geth node as input eg: http://127.0.0.1:8545 var signer = await client.SendRequestAsync&lt;string&gt;(new RpcRequest(1, &quot;personal_ecRecover&quot;, login.Message, login.Signature)); if (signer.ToLower().Equals(login.Signer.ToLower())) { // read user from DB or create a new one // for now we fake a new user user = new UserVM { Account = signer, Name = string.Empty, Email = string.Empty }; } return user; } PRO： web3.personal.sign是web3.personal.sign的对应部分，因此你无需担心其底层实现。 缺点： 需要你自己的Geth节点。不支持Parity，Infura不允许JSON RPC调用web3.personal.*。Authenticate2方法显示了另一种方法，它使用底层ecrecover功能的离线实现： private async Task&lt;UserVM&gt; Authenticate2(LoginVM login) { UserVM user = null; var signer = new Nethereum.Signer.MessageSigner(); var account = signer.EcRecover(login.Hash.HexToByteArray(), login.Signature); if (account.ToLower().Equals(login.Signer.ToLower())) { // read user from DB or create a new one // for now we fake a new user user = new UserVM { Account = account, Name = string.Empty, Email = string.Empty }; } return user; } PRO： 不需要JSON RPC调用就能工作。MessageSigner.EcRecover是Nethereum提供的离线功能。 缺点： 你需要处理web3.personal.sign实现才能正确恢复帐户。出于这个原因，在客户端，我们相应地计算了前缀消息哈希。 结论 现在你拥有基本的知识和一个项目的骨架，可以使用以太坊保护你的Asp.Net Core 2 API。只需几点说明： web3 1.0.0处于测试阶段，web3.personal.sign实现可能会随着时间的推移而变化。请务必在你可以维护的代码库上使用这种身份验证方法。也许Infura某天决定允许web3.personal.ecrecover 😃 ====================================================================== 分享一些以太坊、EOS、比特币等区块链相关的交互式在线编程实战教程： java以太坊开发教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和交易等内容。 以太坊入门教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发进阶教程，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和交易等。 EOS教程，本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 java比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Java代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Java工程师不可多得的比特币开发学习课程。 php比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Php代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Php工程师不可多得的比特币开发学习课程。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多" />
<meta property="og:description" content="上一篇用以太坊区块链保证Asp.Net Core的API安全（上）我们介绍了基本的解决方案，这一篇我们重点来看客户端。 正如我们所说，我们的DApp是一个简单的HTML/ES6客户端。我们将在Asp.Net Core 2之上构建客户端，以利用IIS Express和Visual Studio IDE。因此，Startup.cs类中的Configure方法将是： if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseDefaultFiles(); app.UseStaticFiles(); 使DApp成为NPM项目并安装必备条件以使用ES6 Javascript标准。这不是强制性的，可以使用自己的堆栈构建DApp。 从项目文件夹运行Powershell并运行以下NPM命令： npm init npm install webpack npm install babel-core babel-loader --save-dev npm install babel-preset-es2015 --save-dev npm install babel-preset-stage-0 --save-dev npm install babel-polyfill --save npm install babel-runtime --save npm install babel-plugin-transform-runtime --save-dev 要配置webpack/babel，请使用以下配置创建webpack.config.js文件： var path = require(&quot;path&quot;); module.exports = { entry: [ &quot;babel-polyfill&quot;, &quot;./src/main&quot; ], output: { publicPath: &quot;/js/&quot;, path: path.join(__dirname, &quot;/wwwroot/js/&quot;), filename: &quot;main.build.js&quot; } }; 我们已设定webpack将src/main.js文件构建到/www/js/main.build.js。 安装以太坊扩展包： npm install web3 npm install ethereumjs-util Web3是一个javascript封装包，它简化了针对以太坊区块链的JSON RPC调用。Ethereumjs-util提供了一些以太坊特定的实用程序。让我们构建一个非常简单的HTML页面。我们需要一个登录按钮和另一个按钮来从我们的API层加载一些安全数据： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Ethereum Jwt Client&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Ethereum Jwt Client&lt;/h1&gt; &lt;div id=&quot;login-view&quot;&gt; &lt;label&gt;Your account: &lt;/label&gt; &lt;span id=&quot;eth_account_span&quot;&gt;&lt;/span&gt; &lt;button type=&quot;submit&quot; id=&quot;login_btn&quot;&gt;Login&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;data-view&quot;&gt; &lt;button type=&quot;submit&quot; id=&quot;load_data_btn&quot;&gt;Request secured data&lt;/button&gt; &lt;ul id=&quot;data_list&quot;&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;js/main.build.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; DApp逻辑将驻留在src/main.js文件中，正如我们在webpack.config.js文件中指定的那样。src/main.js文件将是： let ethUtil = require(&#39;ethereumjs-util&#39;); let Web3 = require(&#39;web3&#39;); let coinbase = null; let accessToken = null; let init = () =&gt; { if (typeof web3 !== &#39;undefined&#39;) { web3 = new Web3(web3.currentProvider); web3.eth.getCoinbase(function (err, account) { if (err === null &amp;&amp; ethUtil.isValidAddress(account)) { coinbase = account; eth_account_span.innerHTML = coinbase; } else { eth_account_span.innerHTML = &#39;Please unlock your account and refresh the page&#39;; console.error(err); } }); } else { eth_account_span.innerHTML = &#39;Please install or unlock Metamask browser plugin or navigate this page with Mist or another web3 browser&#39;; } }; let request = obj =&gt; { return new Promise((resolve, reject) =&gt; { let xhr = new XMLHttpRequest(); xhr.open(obj.method || &quot;GET&quot;, obj.url); if (obj.headers) { Object.keys(obj.headers).forEach(key =&gt; { xhr.setRequestHeader(key, obj.headers[key]); }); } xhr.onload = () =&gt; { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { resolve(xhr.response); } else { reject(xhr.statusText); } }; xhr.onerror = () =&gt; reject(xhr.statusText); xhr.send(obj.body); }); }; login_btn.addEventListener(&#39;click&#39;, (e) =&gt; { e.preventDefault(); login_btn.setAttribute(&#39;disabled&#39;, &#39;disabled&#39;); login_btn.innerHTML = &#39;Please sign the message&#39;; let plain = &#39;Hi, you request a login from client to Eth Jwt Api. Please sign this message. This is not a transaction, is completely free and 100% secure. We\&#39;ll use your signature to prove your ownership over your private key server side.&#39;; let msg = ethUtil.bufferToHex(new Buffer(plain, &#39;utf8&#39;)); let hash = ethUtil.bufferToHex(ethUtil.keccak256(&quot;\x19Ethereum Signed Message:\n&quot; + plain.length + plain)); let from = coinbase; let params = [msg, from]; let method = &#39;personal_sign&#39;; web3.currentProvider.sendAsync({ method, params, from, }, function (err, result) { if (err || result.error) { login_btn.removeAttribute(&#39;disabled&#39;); login_btn.innerHTML = &#39;Login&#39;; console.error(err); return console.error(result.error); } console.log({ &#39;signature&#39;: result.result, &#39;msg&#39;: msg, &#39;hash&#39;: hash }); login_btn.innerHTML = &#39;Requesting token...&#39;; let loginData = {}; loginData.signer = from; loginData.signature = result.result; loginData.message = msg; loginData.hash = hash; request({ url: &#39;http://localhost:49443/api/token&#39;, body: JSON.stringify(loginData), method: &#39;post&#39;, headers: { &#39;Authorization&#39;: &#39;Bearer &#39; + accessToken, &#39;Content-type&#39;: &#39;application/json&#39; } }).then(data =&gt; { var json = JSON.parse(data); accessToken = json.token; console.log(&#39;access token: &#39; + accessToken); login_btn.removeAttribute(&#39;disabled&#39;); login_btn.innerHTML = &#39;Login&#39;; }).catch(error =&gt; { console.error(error); login_btn.removeAttribute(&#39;disabled&#39;); login_btn.innerHTML = &#39;Login&#39;; }); }); }); load_data_btn.addEventListener(&#39;click&#39;, (e) =&gt; { e.preventDefault(); request({ url: &#39;http://localhost:49443/api/values&#39;, headers: { &#39;Authorization&#39;: &#39;Bearer &#39; + accessToken } }).then(data =&gt; { var json = JSON.parse(data); for (let i = 0; i &lt; json.length; i++) { data_list.innerHTML += &#39;&lt;li&gt;&#39; + json[i] + &#39;&lt;/li&gt;&#39;; } }).catch(error =&gt; { console.error(err); }); }); window.addEventListener(&#39;load&#39;, init); 1.coinbase和accessToken是全局变量，分别存储用户以太坊帐户和JWT token。 2.init函数从Metamask提供的提供程序初始化web3对象，然后它尝试检索用户的帐户（coinbase）。这需要解锁在Metamask中签名的帐户。 3.require函数只是hxr对象的封装，可以轻松地向API层调用ajax。 4.load_data_btn单击处理程序对API层安全端点进行ajax调用。这需要有效的accessToken才能工作，否则，API层将响应401 HTTP响应。 5.login_btn单击是一个两步功能。首先，它要求用户签署任意消息。签名后，它会将帐户，签名，明文消息和带前缀的哈希发送到令牌端点。 请注意，web3.personal.sign将十六进制格式（0x …）的普通字符串的字节数组作为输入。 正如我们所说的，服务器端，我们将使用两种不同的方式从签名中恢复公钥：在一个中我们将使用JSON RPC 接口中的web3.personal.ecrecover（web3.personal.sign对应）;在另一个中，我们将使用底层的ecrecover离线功能。根据文档，web3.personal.sign使用底层签名函数来签署hash和前缀消息，因此，为了使用底层ecrecover对应，我们还需要计算并将此hash发送到令牌端点。 运行两个应用程序并使用安装了Metamask插件的浏览器导航到客户端。请记住，为了将src/main.js文件构建到js/main.build.js，你需要从Powershell运行webpac命令。如果一切正常，客户端将检索coinbase，你将在页面上看到你的帐户： 如果你现在单击“请求数据”按钮，将获得HTTP响应401。如果单击“登录”按钮，Metamask将提示你签名： 签名后，处理程序将对令牌端点进行ajax调用。在此阶段，身份验证方法不会检查任何签名，因此端点将始终发出JWT令牌。一旦收到JWT令牌，客户端就能通过ajax调用安全端点。如果现在单击“请求数据”按钮，将收到HTTP响应200和数据负载： 从签名中检索以太坊帐户 到目前为止，EthereumJwtApi是一个简单的JWT Asp.Net核心示例，因为它不提供任何有效的身份验证方法。 TokenController的关键部分是两个Authenticate方法及其从签名中检索以太坊帐户的能力。为此，你需要安装Nethereum.Web3 NuGet包。Nethereum是以太坊的.Net实现。 Authenticate方法只是对web3.personal.ecrecover函数进行JSON RPC调用： private async Task&lt;UserVM&gt; Authenticate(LoginVM login) { UserVM user = null; var client = new RpcClient(new Uri(_config[&quot;Nethereum:Geth&quot;])); // Require the RPC endpoint of a Geth node as input eg: http://127.0.0.1:8545 var signer = await client.SendRequestAsync&lt;string&gt;(new RpcRequest(1, &quot;personal_ecRecover&quot;, login.Message, login.Signature)); if (signer.ToLower().Equals(login.Signer.ToLower())) { // read user from DB or create a new one // for now we fake a new user user = new UserVM { Account = signer, Name = string.Empty, Email = string.Empty }; } return user; } PRO： web3.personal.sign是web3.personal.sign的对应部分，因此你无需担心其底层实现。 缺点： 需要你自己的Geth节点。不支持Parity，Infura不允许JSON RPC调用web3.personal.*。Authenticate2方法显示了另一种方法，它使用底层ecrecover功能的离线实现： private async Task&lt;UserVM&gt; Authenticate2(LoginVM login) { UserVM user = null; var signer = new Nethereum.Signer.MessageSigner(); var account = signer.EcRecover(login.Hash.HexToByteArray(), login.Signature); if (account.ToLower().Equals(login.Signer.ToLower())) { // read user from DB or create a new one // for now we fake a new user user = new UserVM { Account = account, Name = string.Empty, Email = string.Empty }; } return user; } PRO： 不需要JSON RPC调用就能工作。MessageSigner.EcRecover是Nethereum提供的离线功能。 缺点： 你需要处理web3.personal.sign实现才能正确恢复帐户。出于这个原因，在客户端，我们相应地计算了前缀消息哈希。 结论 现在你拥有基本的知识和一个项目的骨架，可以使用以太坊保护你的Asp.Net Core 2 API。只需几点说明： web3 1.0.0处于测试阶段，web3.personal.sign实现可能会随着时间的推移而变化。请务必在你可以维护的代码库上使用这种身份验证方法。也许Infura某天决定允许web3.personal.ecrecover 😃 ====================================================================== 分享一些以太坊、EOS、比特币等区块链相关的交互式在线编程实战教程： java以太坊开发教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和交易等内容。 以太坊入门教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发进阶教程，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和交易等。 EOS教程，本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 java比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Java代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Java工程师不可多得的比特币开发学习课程。 php比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Php代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Php工程师不可多得的比特币开发学习课程。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/10/31/ab3bd759934c77928be32ba2ecdf3c23.html" />
<meta property="og:url" content="https://mlh.app/2018/10/31/ab3bd759934c77928be32ba2ecdf3c23.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-10-31T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"上一篇用以太坊区块链保证Asp.Net Core的API安全（上）我们介绍了基本的解决方案，这一篇我们重点来看客户端。 正如我们所说，我们的DApp是一个简单的HTML/ES6客户端。我们将在Asp.Net Core 2之上构建客户端，以利用IIS Express和Visual Studio IDE。因此，Startup.cs类中的Configure方法将是： if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseDefaultFiles(); app.UseStaticFiles(); 使DApp成为NPM项目并安装必备条件以使用ES6 Javascript标准。这不是强制性的，可以使用自己的堆栈构建DApp。 从项目文件夹运行Powershell并运行以下NPM命令： npm init npm install webpack npm install babel-core babel-loader --save-dev npm install babel-preset-es2015 --save-dev npm install babel-preset-stage-0 --save-dev npm install babel-polyfill --save npm install babel-runtime --save npm install babel-plugin-transform-runtime --save-dev 要配置webpack/babel，请使用以下配置创建webpack.config.js文件： var path = require(&quot;path&quot;); module.exports = { entry: [ &quot;babel-polyfill&quot;, &quot;./src/main&quot; ], output: { publicPath: &quot;/js/&quot;, path: path.join(__dirname, &quot;/wwwroot/js/&quot;), filename: &quot;main.build.js&quot; } }; 我们已设定webpack将src/main.js文件构建到/www/js/main.build.js。 安装以太坊扩展包： npm install web3 npm install ethereumjs-util Web3是一个javascript封装包，它简化了针对以太坊区块链的JSON RPC调用。Ethereumjs-util提供了一些以太坊特定的实用程序。让我们构建一个非常简单的HTML页面。我们需要一个登录按钮和另一个按钮来从我们的API层加载一些安全数据： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Ethereum Jwt Client&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Ethereum Jwt Client&lt;/h1&gt; &lt;div id=&quot;login-view&quot;&gt; &lt;label&gt;Your account: &lt;/label&gt; &lt;span id=&quot;eth_account_span&quot;&gt;&lt;/span&gt; &lt;button type=&quot;submit&quot; id=&quot;login_btn&quot;&gt;Login&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;data-view&quot;&gt; &lt;button type=&quot;submit&quot; id=&quot;load_data_btn&quot;&gt;Request secured data&lt;/button&gt; &lt;ul id=&quot;data_list&quot;&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;js/main.build.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; DApp逻辑将驻留在src/main.js文件中，正如我们在webpack.config.js文件中指定的那样。src/main.js文件将是： let ethUtil = require(&#39;ethereumjs-util&#39;); let Web3 = require(&#39;web3&#39;); let coinbase = null; let accessToken = null; let init = () =&gt; { if (typeof web3 !== &#39;undefined&#39;) { web3 = new Web3(web3.currentProvider); web3.eth.getCoinbase(function (err, account) { if (err === null &amp;&amp; ethUtil.isValidAddress(account)) { coinbase = account; eth_account_span.innerHTML = coinbase; } else { eth_account_span.innerHTML = &#39;Please unlock your account and refresh the page&#39;; console.error(err); } }); } else { eth_account_span.innerHTML = &#39;Please install or unlock Metamask browser plugin or navigate this page with Mist or another web3 browser&#39;; } }; let request = obj =&gt; { return new Promise((resolve, reject) =&gt; { let xhr = new XMLHttpRequest(); xhr.open(obj.method || &quot;GET&quot;, obj.url); if (obj.headers) { Object.keys(obj.headers).forEach(key =&gt; { xhr.setRequestHeader(key, obj.headers[key]); }); } xhr.onload = () =&gt; { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { resolve(xhr.response); } else { reject(xhr.statusText); } }; xhr.onerror = () =&gt; reject(xhr.statusText); xhr.send(obj.body); }); }; login_btn.addEventListener(&#39;click&#39;, (e) =&gt; { e.preventDefault(); login_btn.setAttribute(&#39;disabled&#39;, &#39;disabled&#39;); login_btn.innerHTML = &#39;Please sign the message&#39;; let plain = &#39;Hi, you request a login from client to Eth Jwt Api. Please sign this message. This is not a transaction, is completely free and 100% secure. We\\&#39;ll use your signature to prove your ownership over your private key server side.&#39;; let msg = ethUtil.bufferToHex(new Buffer(plain, &#39;utf8&#39;)); let hash = ethUtil.bufferToHex(ethUtil.keccak256(&quot;\\x19Ethereum Signed Message:\\n&quot; + plain.length + plain)); let from = coinbase; let params = [msg, from]; let method = &#39;personal_sign&#39;; web3.currentProvider.sendAsync({ method, params, from, }, function (err, result) { if (err || result.error) { login_btn.removeAttribute(&#39;disabled&#39;); login_btn.innerHTML = &#39;Login&#39;; console.error(err); return console.error(result.error); } console.log({ &#39;signature&#39;: result.result, &#39;msg&#39;: msg, &#39;hash&#39;: hash }); login_btn.innerHTML = &#39;Requesting token...&#39;; let loginData = {}; loginData.signer = from; loginData.signature = result.result; loginData.message = msg; loginData.hash = hash; request({ url: &#39;http://localhost:49443/api/token&#39;, body: JSON.stringify(loginData), method: &#39;post&#39;, headers: { &#39;Authorization&#39;: &#39;Bearer &#39; + accessToken, &#39;Content-type&#39;: &#39;application/json&#39; } }).then(data =&gt; { var json = JSON.parse(data); accessToken = json.token; console.log(&#39;access token: &#39; + accessToken); login_btn.removeAttribute(&#39;disabled&#39;); login_btn.innerHTML = &#39;Login&#39;; }).catch(error =&gt; { console.error(error); login_btn.removeAttribute(&#39;disabled&#39;); login_btn.innerHTML = &#39;Login&#39;; }); }); }); load_data_btn.addEventListener(&#39;click&#39;, (e) =&gt; { e.preventDefault(); request({ url: &#39;http://localhost:49443/api/values&#39;, headers: { &#39;Authorization&#39;: &#39;Bearer &#39; + accessToken } }).then(data =&gt; { var json = JSON.parse(data); for (let i = 0; i &lt; json.length; i++) { data_list.innerHTML += &#39;&lt;li&gt;&#39; + json[i] + &#39;&lt;/li&gt;&#39;; } }).catch(error =&gt; { console.error(err); }); }); window.addEventListener(&#39;load&#39;, init); 1.coinbase和accessToken是全局变量，分别存储用户以太坊帐户和JWT token。 2.init函数从Metamask提供的提供程序初始化web3对象，然后它尝试检索用户的帐户（coinbase）。这需要解锁在Metamask中签名的帐户。 3.require函数只是hxr对象的封装，可以轻松地向API层调用ajax。 4.load_data_btn单击处理程序对API层安全端点进行ajax调用。这需要有效的accessToken才能工作，否则，API层将响应401 HTTP响应。 5.login_btn单击是一个两步功能。首先，它要求用户签署任意消息。签名后，它会将帐户，签名，明文消息和带前缀的哈希发送到令牌端点。 请注意，web3.personal.sign将十六进制格式（0x …）的普通字符串的字节数组作为输入。 正如我们所说的，服务器端，我们将使用两种不同的方式从签名中恢复公钥：在一个中我们将使用JSON RPC 接口中的web3.personal.ecrecover（web3.personal.sign对应）;在另一个中，我们将使用底层的ecrecover离线功能。根据文档，web3.personal.sign使用底层签名函数来签署hash和前缀消息，因此，为了使用底层ecrecover对应，我们还需要计算并将此hash发送到令牌端点。 运行两个应用程序并使用安装了Metamask插件的浏览器导航到客户端。请记住，为了将src/main.js文件构建到js/main.build.js，你需要从Powershell运行webpac命令。如果一切正常，客户端将检索coinbase，你将在页面上看到你的帐户： 如果你现在单击“请求数据”按钮，将获得HTTP响应401。如果单击“登录”按钮，Metamask将提示你签名： 签名后，处理程序将对令牌端点进行ajax调用。在此阶段，身份验证方法不会检查任何签名，因此端点将始终发出JWT令牌。一旦收到JWT令牌，客户端就能通过ajax调用安全端点。如果现在单击“请求数据”按钮，将收到HTTP响应200和数据负载： 从签名中检索以太坊帐户 到目前为止，EthereumJwtApi是一个简单的JWT Asp.Net核心示例，因为它不提供任何有效的身份验证方法。 TokenController的关键部分是两个Authenticate方法及其从签名中检索以太坊帐户的能力。为此，你需要安装Nethereum.Web3 NuGet包。Nethereum是以太坊的.Net实现。 Authenticate方法只是对web3.personal.ecrecover函数进行JSON RPC调用： private async Task&lt;UserVM&gt; Authenticate(LoginVM login) { UserVM user = null; var client = new RpcClient(new Uri(_config[&quot;Nethereum:Geth&quot;])); // Require the RPC endpoint of a Geth node as input eg: http://127.0.0.1:8545 var signer = await client.SendRequestAsync&lt;string&gt;(new RpcRequest(1, &quot;personal_ecRecover&quot;, login.Message, login.Signature)); if (signer.ToLower().Equals(login.Signer.ToLower())) { // read user from DB or create a new one // for now we fake a new user user = new UserVM { Account = signer, Name = string.Empty, Email = string.Empty }; } return user; } PRO： web3.personal.sign是web3.personal.sign的对应部分，因此你无需担心其底层实现。 缺点： 需要你自己的Geth节点。不支持Parity，Infura不允许JSON RPC调用web3.personal.*。Authenticate2方法显示了另一种方法，它使用底层ecrecover功能的离线实现： private async Task&lt;UserVM&gt; Authenticate2(LoginVM login) { UserVM user = null; var signer = new Nethereum.Signer.MessageSigner(); var account = signer.EcRecover(login.Hash.HexToByteArray(), login.Signature); if (account.ToLower().Equals(login.Signer.ToLower())) { // read user from DB or create a new one // for now we fake a new user user = new UserVM { Account = account, Name = string.Empty, Email = string.Empty }; } return user; } PRO： 不需要JSON RPC调用就能工作。MessageSigner.EcRecover是Nethereum提供的离线功能。 缺点： 你需要处理web3.personal.sign实现才能正确恢复帐户。出于这个原因，在客户端，我们相应地计算了前缀消息哈希。 结论 现在你拥有基本的知识和一个项目的骨架，可以使用以太坊保护你的Asp.Net Core 2 API。只需几点说明： web3 1.0.0处于测试阶段，web3.personal.sign实现可能会随着时间的推移而变化。请务必在你可以维护的代码库上使用这种身份验证方法。也许Infura某天决定允许web3.personal.ecrecover 😃 ====================================================================== 分享一些以太坊、EOS、比特币等区块链相关的交互式在线编程实战教程： java以太坊开发教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和交易等内容。 以太坊入门教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发进阶教程，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和交易等。 EOS教程，本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 java比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Java代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Java工程师不可多得的比特币开发学习课程。 php比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Php代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Php工程师不可多得的比特币开发学习课程。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/10/31/ab3bd759934c77928be32ba2ecdf3c23.html","headline":"用以太坊区块链保证Asp.Net Core的API安全（下）","dateModified":"2018-10-31T00:00:00+08:00","datePublished":"2018-10-31T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/10/31/ab3bd759934c77928be32ba2ecdf3c23.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>用以太坊区块链保证Asp.Net Core的API安全（下）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>上一篇<a href="http://blog.hubwiz.com/2018/10/29/ethereum-asp_net_core_api-secure/" rel="nofollow">用以太坊区块链保证Asp.Net Core的API安全（上）</a>我们介绍了基本的解决方案，这一篇我们重点来看客户端。</p> 
  <p>正如我们所说，我们的DApp是一个简单的HTML/ES6客户端。<a href="http://xn--Asp-ot9dm09aukhmml.Net" rel="nofollow">我们将在Asp.Net</a> Core 2之上构建客户端，以利用<strong>IIS Express和Visual Studio IDE</strong>。因此，<code>Startup.cs</code>类中的<code>Configure</code>方法将是：</p> 
  <pre><code>if (env.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}

app.UseDefaultFiles();
app.UseStaticFiles();
</code></pre> 
  <p>使DApp成为<code>NPM</code>项目并安装必备条件以使用ES6 Javascript标准。这不是强制性的，可以使用自己的堆栈构建DApp。</p> 
  <p>从项目文件夹运行<code>Powershell</code>并运行以下<code>NPM</code>命令：</p> 
  <pre><code>npm init
npm install webpack
npm install babel-core babel-loader --save-dev
npm install babel-preset-es2015 --save-dev
npm install babel-preset-stage-0 --save-dev
npm install babel-polyfill --save
npm install babel-runtime --save
npm install babel-plugin-transform-runtime --save-dev
</code></pre> 
  <p>要配置<code>webpack/babel</code>，请使用以下配置创建<code>webpack.config.js</code>文件：</p> 
  <pre><code>var path = require("path");

module.exports = {
    entry: [
        "babel-polyfill",
        "./src/main"
    ],
    output: {
        publicPath: "/js/",
        path: path.join(__dirname, "/wwwroot/js/"),
        filename: "main.build.js"
    }
};
</code></pre> 
  <p>我们已设定<code>webpack</code>将<code>src/main.js</code>文件构建到<code>/www/js/main.build.js</code>。</p> 
  <p>安装以太坊扩展包：</p> 
  <pre><code>npm install web3
npm install ethereumjs-util
</code></pre> 
  <p>Web3是一个<code>javascript</code>封装包，它简化了针对以太坊区块链的JSON RPC调用。<code>Ethereumjs-util</code>提供了一些以太坊特定的实用程序。让我们构建一个非常简单的HTML页面。我们需要一个登录按钮和另一个按钮来从我们的API层加载一些安全数据：</p> 
  <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Ethereum Jwt Client&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Ethereum Jwt Client&lt;/h1&gt;
    &lt;div id="login-view"&gt;
        &lt;label&gt;Your account: &lt;/label&gt; &lt;span id="eth_account_span"&gt;&lt;/span&gt;
        &lt;button type="submit" id="login_btn"&gt;Login&lt;/button&gt;
    &lt;/div&gt;
    &lt;div id="data-view"&gt;
        &lt;button type="submit" id="load_data_btn"&gt;Request secured data&lt;/button&gt;
        &lt;ul id="data_list"&gt;

        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script src="js/main.build.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
  <p>DApp逻辑将驻留在<code>src/main.js</code>文件中，正如我们在<code>webpack.config.js</code>文件中指定的那样。<code>src/main.js</code>文件将是：</p> 
  <pre><code>let ethUtil = require('ethereumjs-util');
let Web3 = require('web3');

let coinbase = null;
let accessToken = null;

let init = () =&gt; {
    if (typeof web3 !== 'undefined') {
        web3 = new Web3(web3.currentProvider);
        web3.eth.getCoinbase(function (err, account) {
            if (err === null &amp;&amp; ethUtil.isValidAddress(account)) {
                coinbase = account;
                eth_account_span.innerHTML = coinbase;
            } else {
                eth_account_span.innerHTML = 'Please unlock your account and refresh the page';
                console.error(err);
            }
        });

    } else {
        eth_account_span.innerHTML = 'Please install or unlock Metamask browser plugin or navigate this page with Mist or another web3 browser';
    }
};

let request = obj =&gt; {
    return new Promise((resolve, reject) =&gt; {
        let xhr = new XMLHttpRequest();
        xhr.open(obj.method || "GET", obj.url);
        if (obj.headers) {
            Object.keys(obj.headers).forEach(key =&gt; {
                xhr.setRequestHeader(key, obj.headers[key]);
            });
        }
        xhr.onload = () =&gt; {
            if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {
                resolve(xhr.response);
            } else {
                reject(xhr.statusText);
            }
        };
        xhr.onerror = () =&gt; reject(xhr.statusText);
        xhr.send(obj.body);
    });
};

login_btn.addEventListener('click', (e) =&gt; {
    e.preventDefault();

    login_btn.setAttribute('disabled', 'disabled');
    login_btn.innerHTML = 'Please sign the message';

    let plain = 'Hi, you request a login from client to Eth Jwt Api. Please sign this message. This is not a transaction, is completely free and 100% secure. We\'ll use your signature to prove your ownership over your private key server side.';
    let msg = ethUtil.bufferToHex(new Buffer(plain, 'utf8'));
    let hash = ethUtil.bufferToHex(ethUtil.keccak256("\x19Ethereum Signed Message:\n" + plain.length + plain));
    let from = coinbase;

    let params = [msg, from];
    let method = 'personal_sign';

    web3.currentProvider.sendAsync({
        method,
        params,
        from,
    }, function (err, result) {
        if (err || result.error) {
            login_btn.removeAttribute('disabled');
            login_btn.innerHTML = 'Login';

            console.error(err);
            return console.error(result.error);
        }
        console.log({
            'signature': result.result,
            'msg': msg,
            'hash': hash
        });

        login_btn.innerHTML = 'Requesting token...';
        let loginData = {};
        loginData.signer = from;
        loginData.signature = result.result;
        loginData.message = msg;
        loginData.hash = hash;

        request({
            url: 'http://localhost:49443/api/token',
            body: JSON.stringify(loginData),
            method: 'post',
            headers: {
                'Authorization': 'Bearer ' + accessToken,
                'Content-type': 'application/json'
            }
        }).then(data =&gt; {
            var json = JSON.parse(data);
            accessToken = json.token;
            console.log('access token: ' + accessToken);

            login_btn.removeAttribute('disabled');
            login_btn.innerHTML = 'Login';
        }).catch(error =&gt; {
            console.error(error);

            login_btn.removeAttribute('disabled');
            login_btn.innerHTML = 'Login';
        });
    });
});

load_data_btn.addEventListener('click', (e) =&gt; {
    e.preventDefault();

    request({
        url: 'http://localhost:49443/api/values',
        headers: {
            'Authorization': 'Bearer ' + accessToken
        }
    }).then(data =&gt; {
        var json = JSON.parse(data);
        for (let i = 0; i &lt; json.length; i++) {
            data_list.innerHTML += '&lt;li&gt;' + json[i] + '&lt;/li&gt;';
        }
    }).catch(error =&gt; {
        console.error(err);
    });

});

window.addEventListener('load', init);
</code></pre> 
  <ul> 
   <li>1.<code>coinbase</code>和<code>accessToken</code>是全局变量，分别存储用户以太坊帐户和JWT token。</li> 
   <li>2.<code>init</code>函数从Metamask提供的提供程序初始化web3对象，然后它尝试检索用户的帐户（coinbase）。这需要解锁在Metamask中签名的帐户。</li> 
   <li>3.<code>require</code>函数只是hxr对象的封装，可以轻松地向API层调用ajax。</li> 
   <li>4.<strong>load_data_btn</strong>单击处理程序对API层安全端点进行ajax调用。这需要有效的<code>accessToken</code>才能工作，否则，API层将响应401 HTTP响应。</li> 
   <li>5.<strong>login_btn</strong>单击是一个两步功能。首先，它要求用户签署任意消息。签名后，它会将帐户，签名，明文消息和带前缀的哈希发送到令牌端点。</li> 
  </ul> 
  <p>请注意，<code>web3.personal.sign</code>将十六进制格式（0x …）的普通字符串的字节数组作为输入。</p> 
  <p>正如我们所说的，服务器端，我们将使用两种不同的方式从签名中恢复公钥：在一个中我们将使用JSON RPC 接口中的<code>web3.personal.ecrecover</code>（web3.personal.sign对应）;在另一个中，我们将使用底层的<code>ecrecover</code>离线功能。根据文档，<code>web3.personal.sign</code>使用底层签名函数来签署hash和前缀消息，因此，为了使用底层<code>ecrecover</code>对应，我们还需要计算并将此hash发送到令牌端点。</p> 
  <p>运行两个应用程序并使用安装了Metamask插件的浏览器导航到客户端。请记住，为了将<code>src/main.js</code>文件构建到<code>js/main.build.js</code>，你需要从<code>Powershell</code>运行<code>webpac</code>命令。如果一切正常，客户端将检索<code>coinbase</code>，你将在页面上看到你的帐户：</p> 
  <p><img src="http://blog.hubwiz.com/2018/10/29/ethereum-asp_net_core_api-secure/index.png" alt=""></p> 
  <p>如果你现在单击“请求数据”按钮，将获得HTTP响应401。如果单击“登录”按钮，Metamask将提示你签名：</p> 
  <p><img src="http://blog.hubwiz.com/2018/10/29/ethereum-asp_net_core_api-secure/message.png" alt=""></p> 
  <p>签名后，处理程序将对令牌端点进行ajax调用。在此阶段，身份验证方法不会检查任何签名，因此端点将始终发出JWT令牌。一旦收到JWT令牌，客户端就能通过ajax调用安全端点。如果现在单击“请求数据”按钮，将收到HTTP响应200和数据负载：</p> 
  <p><img src="http://blog.hubwiz.com/2018/10/29/ethereum-asp_net_core_api-secure/jwtToken.png" alt=""></p> 
  <h3><a id="_237"></a>从签名中检索以太坊帐户</h3> 
  <p>到目前为止，<code>EthereumJwtApi</code>是一个简单的JWT Asp.Net核心示例，因为它不提供任何有效的身份验证方法。</p> 
  <p><code>TokenController</code>的关键部分是两个<code>Authenticate</code>方法及其从签名中检索以太坊帐户的能力。为此，你需要安装<code>Nethereum.Web3 NuGet</code>包。Nethereum是以太坊的.Net实现。</p> 
  <p><code>Authenticate</code>方法只是对<code>web3.personal.ecrecover</code>函数进行JSON RPC调用：</p> 
  <pre><code>private async Task&lt;UserVM&gt; Authenticate(LoginVM login)
{
    UserVM user = null;

    var client = new RpcClient(new Uri(_config["Nethereum:Geth"])); // Require the RPC endpoint of a Geth node as input eg: http://127.0.0.1:8545
    var signer = await client.SendRequestAsync&lt;string&gt;(new RpcRequest(1, "personal_ecRecover", login.Message, login.Signature));

    if (signer.ToLower().Equals(login.Signer.ToLower()))
    {
        // read user from DB or create a new one
        // for now we fake a new user
        user = new UserVM { Account = signer, Name = string.Empty, Email = string.Empty };
    }

    return user;
}
</code></pre> 
  <p>PRO：</p> 
  <p><code>web3.personal.sign</code>是<code>web3.personal.sign</code>的对应部分，因此你无需担心其底层实现。</p> 
  <p>缺点：</p> 
  <p>需要你自己的Geth节点。不支持Parity，Infura不允许JSON RPC调用<code>web3.personal.*</code>。<code>Authenticate2</code>方法显示了另一种方法，它使用底层<code>ecrecover</code>功能的离线实现：</p> 
  <pre><code>private async Task&lt;UserVM&gt; Authenticate2(LoginVM login)
{
    UserVM user = null;

    var signer = new Nethereum.Signer.MessageSigner();
    var account = signer.EcRecover(login.Hash.HexToByteArray(), login.Signature);

    if (account.ToLower().Equals(login.Signer.ToLower()))
    {
        // read user from DB or create a new one
        // for now we fake a new user
        user = new UserVM { Account = account, Name = string.Empty, Email = string.Empty };
    }

    return user;
}
</code></pre> 
  <p>PRO：</p> 
  <p>不需要JSON RPC调用就能工作。<code>MessageSigner.EcRecover</code>是<code>Nethereum</code>提供的离线功能。</p> 
  <p>缺点：</p> 
  <p>你需要处理<code>web3.personal.sign</code>实现才能正确恢复帐户。出于这个原因，在客户端，我们相应地计算了前缀消息哈希。</p> 
  <h3><a id="_299"></a>结论</h3> 
  <p>现在你拥有基本的知识和一个项目的骨架，<a href="http://xn--Asp-vs9da25ergy1a97zsvi3kf3p8apl7cn8d.Net" rel="nofollow">可以使用以太坊保护你的Asp.Net</a> Core 2 API。只需几点说明：</p> 
  <p>web3 1.0.0处于测试阶段，<code>web3.personal.sign</code>实现可能会随着时间的推移而变化。请务必在你可以维护的代码库上使用这种身份验证方法。也许Infura某天决定允许<code>web3.personal.ecrecover</code> 😃</p> 
  <p>======================================================================</p> 
  <p>分享一些以太坊、EOS、比特币等区块链相关的交互式在线编程实战教程：</p> 
  <blockquote> 
   <ul> 
    <li><a href="http://xc.hubwiz.com/course/5b2b6e82c02e6b6a59171de2?affid=1030csdn" rel="nofollow">java以太坊开发教程</a>，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b40462cc02e6b6a59171de4?affid=1030csdn" rel="nofollow">python以太坊</a>，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b36629bc02e6b6a59171de3?affid=1030csdn" rel="nofollow">php以太坊</a>，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和交易等内容。</li> 
    <li><a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=1030csdn" rel="nofollow">以太坊入门教程</a>，主要介绍智能合约与dapp应用开发，适合入门。</li> 
    <li><a href="http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6?affid=1030csdn" rel="nofollow">以太坊开发进阶教程</a>，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b6048c3c02e6b6a59171dee?affid=1030csdn" rel="nofollow">C#以太坊</a>，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和交易等。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b52c0a2c02e6b6a59171ded?affid=1030csdn" rel="nofollow">EOS教程</a>，本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。</li> 
    <li><a href="http://xc.hubwiz.com/course/5bb35c90c02e6b6a59171df0?affid=1030csdn" rel="nofollow">java比特币开发教程</a>，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Java代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Java工程师不可多得的比特币开发学习课程。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b9e779ac02e6b6a59171def?affid=1030csdn" rel="nofollow">php比特币开发教程</a>，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Php代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Php工程师不可多得的比特币开发学习课程。</li> 
   </ul> 
  </blockquote> 
  <p>汇智网原创翻译，转载请标明出处。这里是<a href="https://medium.com/coinmonks/secure-asp-net-core-2-api-with-ethereum-blockchain-88001d5ddb6" rel="nofollow">原文</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/83573100,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/83573100,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
