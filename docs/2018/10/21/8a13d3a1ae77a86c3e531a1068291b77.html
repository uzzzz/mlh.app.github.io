<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>02.以太坊架构和组成 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="02.以太坊架构和组成" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：忠于祖国，忠于人民 https://blog.csdn.net/boss2967/article/details/83244455 01.以太坊整体架构 以太坊是一个区块链应用平台。 分为三层： 底层服务 核心层 顶层应用 02.区块 区块链是比特币使用的底层技术架构。 他本身是一串连续的数据区块，区块之间的连接指针是区块头散列指针，他们是使用密码学散列算法生成的。 区块本质上就是一个数据包，比特币的交易记录会保存在区块中，大约每10分钟生成一个新的区块。 所谓区块：可以定义为记录一段时间内发生的交易和状态的结果的数据结构。是对当前账本状态的一次共识。 比特币的每个数据区块一般包含区块头（Header）和区块体（Body）两部分。 区块头封装了前一个区块的散列值（Prev_Hash），时间戳（Timestamp）,随机数（Nonce）,Merkle树的根值（Tx_Root）和当前区块的散列值等信息。 区块体中则主要包含交易技术和交易详情。 - 每笔交易都被永久的记录在区块中，任何人都可以查询。交易是通过Merkle树的数据结果记录的。其中没仪表交易都包含了数字签名，如此可以保证每一笔交易都不伪造，不能篡改。所有的交易过程都将通过Merkle树的hash过程生成一个唯一的Tx-Root记录到区块中。 用户在验证区块的有效性时，只需根据Merkle树的Hash方法计算出根值并且与区块中Tx_Root进行比较，即可验证真伪，若相同及有效，若不同则无效。 03.区块 ——以太坊 去开主要由区块头，交易列表，和叔区块三部分组成。 区块头： 父块的散列值（PrevHash） 叔区块的散列值（Uncles Hash） 状态树根散列值（stateRoot） 交易树根散列值（Transaction Root） 收据树根散列值（Receipt Root） 时间戳（Timestamp） 随机数（Nonce） 以太坊区块链上区块数据结构的一个重要改变就是保存了三棵Merkle树根 状态树 交易树 收据树 存储三棵树可以方便账户做更多查询 交易列表是由矿工从交易池选择收入区块中的一系列交易 区块链上的第一个区块称为“创世区块” 区块链上除了创世区块意外每个区块都有他的父区块，这些区块连接起来组成一个区块链 以太坊大约每15s可以挖出一个新的区块 以太坊区块结构中状态树的更新 04.账户 账户以地址为索引，地址由公钥衍生而来，取公钥的最后20字节 两种类型的账户 外部账户 简称账户，他们都是由人创建，可以储存以太币 合约账户 合约账户是由外部账户创建的账户 以太坊中这两中账户统称为“状态对象”（存储状态） 外部账户储存以太币余额状态 合约庄户除了余额还有智能合约以及其变量的状态 通过交易的执行，这行状态对象发生变化，而Merkle树用户索引和状态对象的更新。 一个以太坊的账户包含四个部分 该地址交易的次数，他是用于保障被一笔交易能且被处理一次的计数器，有效避免重放攻击 账户目前的以太币余额 账户的合约二进制代码（合约账户） 账户的储存（默认为空） 4.1 外部账户 外部账户（EOA）由私钥来控制，是由用户实际控制的账户 每个外部账户拥有一对公私钥，这对密钥用于签署交易，他的地址由公钥决定。 外部账户不能包含以太坊虚拟机（EVM）代码 我们可以做一个简单的对比，把外部账户看做用户在某个银行办理的一个账户，公钥就是用户为该账户设置的卡号，而私钥则是用户设置的密码。 一个外部账户具有以下特性： 拥有一定的账户余额 可以发送交易 通过私钥控制 以及没有相关的代码 用户在创建好战鼓后一定要记住私钥！如果用户忘记了，那你就滚吧。不可能不滚的。 秘钥通常保存在keystore目录下， 用户可以经常性的备份密钥文件，以防止忘记或者丢失 在以太坊节点之间传递整个目录后者密钥文件是安全的。但是账户的顺序可能会发生比改变。 用户需确保不要依赖或者更改脚本和代码段中的索引。用户自己列出自己创建的账户时，账户汇按字典排序，并且按照账户的创建时间先后排序 4.2 合约账户 合约账户是一个包含合约代码的账户 合约账户不是由私钥文件直接控制，而是由合约代码控制的 合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出 一个合约账户具有下列特性： 拥有一定的以太币余额 有相关联的代码 代码通过交易或者其他合约发送的调用来激活。 当合约被执行时候，智能操作合约庄户拥有的特定储存。 合约账户和普通账户最大的不同就是他还存有智能合约 以太坊区块链上的所有操作都是根据都是根据从账户发出的交易来执行的。 每当合约账户收到一条交易消息时，其他合约代码将被交易输入的参数调用执行。 而合约代码将会在参与到网络中的每一个节点上执行，并将执行结果作为新区块验证的一部分 4.3 私钥和公钥 公钥加密 -公钥认证 私钥的三种形态： Private key就是一份随机生成的256位二进制数字，该256位二进制数字就是私钥最初始的状态 而2以太坊钱包中，私钥和公钥将会以加密的方式保存一份JSON文件，存在keystore子目录下，这份JSON文件就是Keystore,所以用户需要同时备份Keystore和对应的Password 最后一种Memonic code是由BIP39方案，随机生成12-24个容易几乎记住的单词，随机种子，通过提案的方式生成确定性钱包 4.4 钱包 钱包就是一个比较形象的概念，一个外部账户通常由私钥文件来控制，拥有私钥的而用户就可以拥有对应地址的账户里的以太币使用权。 我们通常把管理这些数字密钥的软件成为钱包，而我们所所的备份钱包其实就是备份账户的私钥文件 -以太币钱包分类 Mist钱包 Parity钱包 Etherwall钱包 Brain钱包 钱包备份 防盗：分离备份 防丢：多处本分 分散风向：将资金适当的分散开 常见的钱包备份方式： 多处和分离备份 纸钱包 预防方案：用户可以痛死使用多重签名和多处分离备份，设定一个金额阈值，当用户提取超过该阈值的金额时需要多个私钥，另外把这些私钥多处分离备份，大大降低了资金被盗的风险 05.数据结构与储存 包括以太坊和比特币在内的大多是都是区块链项目，会使用Merkle树或者基于Merkle树的数据结构，比特币- 中保存了一颗Merkle树，而以太坊针对对象设计了三棵Merkle树，分别是状态树，交易树和收据叔，这三种树可以帮助以太坊客户端做一些简易的查询，查询某个账户的余额，某笔交易是否被包含在区块中。 区块，交易等数据最终都是存在LevelDB数据库中，LevelDB数据库是一个键值对数据库，key一般与散列相关，value则是存在储存内容的RLP编码 5.1 数据组织形式 以太坊使用Merkle Patricia树，（MPT）,作为数据组织形式，用来组织管理用户的账户状态，交易信息等重要数据。 MPT是一种加密认证的数据结构，他融合了Merkle树和Tire树（前缀树）两种数据类型的优点 Merkle树 Merkle树是一种树行数据结构，可以是二叉树，也可以是多叉树 由一组叶节点，一组中间节点和一个根节点构成 最下面的叶节点包含基础数据，每个中间节点是他的子节点的散列，根节点是他的子节点的散列，代表了Merkle树的根部。 创建Merkle树的目的是语序区块的数据可以零散的传送 节点可以从一个节点下载区块头，从另外的源下载与其相关的树的其他部分，而依然能够确认所有的数据都是正确的。之所以如此是因为散列向上扩散，如果一个恶意用户尝试在树的下部加入一个伪造的交易，所引起的改动将导致树上的上层节点以及更上层节点的改动，最终导致根节点的改动以及区块散列的改动，这样协议就会将其记录为一个完全不同的区块（几乎可以坑定带着不确定的工作量证明） 如果底层的交易被篡改了，那么其对应的叶节点散列值也会改变，这件最终导致其Merkle树根值变化 Merkle树可以用来储存所有键值对 这颗树的建立从每个节点开始，将节点两两分成多达16个组，并对每个组求散列值，接着对散列结果继续求散列值，如此递归下去，知道整颗树有一个最后的根散列值。 Merkle树具有下列特性 每个数据集对应一个唯一合法的根散列值 很不容易更新，添加， 或者删除树节点，以及生成新的根散列值 不改变根散列值的话就没有办法修改树的任何部分，所以如果跟散列值被包括在签名的文档或者有效区块中，就可以保证这棵树的正确性 任何人都可以只提供一个到特定节点的分支，并且通过密码学方法证明拥有对应内容的节点确实在树里 5.2 Trie树 Trie树也叫做Radix树 在Radic树中，key代表的是从树根到对应value的一条真实的路径 即从根节点开始，key中的每个字符（从前到后）都代表着从根节点触发寻找相应value所要经过的子节点 value储存在叶节点中，是每个路径的最终节点。 假如key中的每个字符都来自一个容量为N且包含的字母都互不相识的字母表，那么树中的每个节点最多会有N个孩子，树的最大深度便是Key的最大程度 优点如果有两个value,他们有着基于相同前缀的key，他们的相同前缀的长度占自身比例越大，则代表着两个value在树中的位置越靠近，并且Trie树中不会有像散列表一样的冲突，也就是说一个key只对应一个value,但是也存在着不平衡的 5.3 Merkle Patricia树 为了保证树的加密安全，每个节点通过他的散列值被引用，对于存储在LEVELDB数据库中的非叶节点，其中数据库中的表现形式：key代表着节点的RLP编码的SHA3散列值，value是节点的RLP编码。想要获得一个节点的内容，只需要根据该节点的散列值访问数据库以获得节点的RLP编码，然后解码即可。 在该方案中，根节点被称为整棵树的加密签名，如果一棵树给定Trie树的根散列值是公开的，那么所有人都可以提供一种证明，即通过提供每步向上的路径证明特定的key是否含有特定的值 引入很多节点类型来提供效率，MPT中节点包括以下4种： 空节点：简单的表示空，在代码中就是一个空串 叶节点：键值对的一个列表，其中key是一种特殊的十六进制编码，value是RLP编码 扩展节点：键值对的列表，但是这里的value是其他接待的散列值，通过这个散列值可以连接到其他节点 分支节点：一个节点为17的列表，MPT中的key被编码成一种特殊的十六进制的表示，再加上最后的value，前16个元素对应的key中的16个可能的十六进制字符，如果有一个键值对在这个分支节点终止，则最后一个元素代表一个值，即分支节点既然可以是搜索路径的终止，也可能是路径的中间节点 MPT还有一个重要的概念：用户对key进行编码的特殊十六进制前缀编码（HP），因为字母表中的字符都是十六进制表示的，所以每个节点最多只能由16个孩子，因为键值对有两个表示形式的节点，所以必须引用一中特殊的终止符表示，用来标示key所对应的值是真实的值还是其他节点的散列值。通过对终止符标识进行赋值，可以区分key所对应的节点的种类，无论key的长度是奇数还是偶数，HP都可以对其进行编码。 以太坊区块链系统中使用MPT树结构，但是每个以太坊区块头不是只包括一颗MPT树，而是为了三种对象设计了三棵树。 5.4 状态树 状态树中的每个节点16个孩子节点，每个叶节点表示一个账户，这些叶节点的父节点由叶节点的散列组成，而这些父节点再组成更高一层的父节点，直至到形成根节点。 状态树包含一个键值映射，其中键是账户地址，值是账户内容 {nonce,balance,codeahash,storageRoot} nonce是账户交易的序数 balance是账户余额 codeHash是代码的散列值 storageRoot是另一棵树的根节点 状态树代表访问区块后的整个状态 账户的状态不是直接存储在每个区块中，所有的账户状态都是以状态数据的形式存在以太坊的节点中 状态数据是一种隐式的数据，意味着他需要从实际的区块链数据中计算出来，交易包含决定新状态数据的所有字段内容。与比特币不同的是，以太坊区块包含了整个状态树的Merkle树根散列和交易列表 状态树是用来记录各个账户的状态的树，他需要经常更新 5.5 交易树 每个区块都有一棵独立的交易树。 区块中交易的顺序主要由矿工决定，在这个块被挖出来前这些数据都是未知的。不过矿工一般会根据交易的GasPrice和Nonce对交易进行排序。 首先会将交易列表中的交易划分到各个发送账户，每个账户的交易根据这些交易的nonce来排序，每个账户的交易排序完成后，再通过比较每个账户的第一条交易，选择最高价格的交易，这写是通过一个堆来实现的、 每挖出一个新块，更新一次交易树 在交易树包含的键值对中，其中每个键是交易的编号，值是交易内容 5.6 收据树 每个区块都有自己的收据树，收据树不需要更新 收据树代表每个交易相应的收据 收据树也包含了一个键值映射，其中键是索引编号，用来指引这个收据相关的交易的位置，值是收据的内容 交易的收据是一个RLP编码的数据结构[medstate,Gas_used,logbloom,logs]，其中 medstate是交易处理后树根的状态，Gas_used是交易处理后Gas的使用量，logs是表格元素的列表，表格有交易执行期间调用的操作码，address是生成日志的合约地址，topicn是最多4个32字节的值，data是任意字节大小的数据，logbllom是交易所有logs的布隆过滤器。 06.数据库支持-LevelDB LevelDB是谷歌实现的一个非常高效的键值对数据库，其中键值都是二进制，目前能够支持十亿级别的数据量。在这个数据量下还有这非常高的性能。 以太坊中共有三个LeveleDB数据库： BlockDB: 保存了块的主体内容，包括块头和交易 StateDB: 保存了账户的状态数据 ExtrasDB：ExtrasDB保存了收据信息和其他辅助信息 LevelDB的用户接口，put(k,v),get(k,v) delete(k,v) 特性： key和value都是任意长度的字节数组，一条记录（即一个键值对）默认是按照key的字典顺序存储，当然开发者也可以重载这个排序函数。 支持遍历，包括前向或者反向 支持原子写操作 支持过滤策略 支持数据自动压缩（snappy压缩算法） 底层提供了抽象接口，允许用户定制 限制： 不是sql类型数据库，没有关系模型 一个表只允许一个进程访问 单机系统没有服务器客户端 以太坊使用LevelDB主要考虑到他的写优化的特点 07.共识机制 共识机制是区块链事务达成分布式共识的算法 由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制 08.Pow PoW 即通过工作结果来证明你完成了相应的工作 PoW 是通过结果证明以确认你完成了 定量的工作 女巫攻击（ Sybil Attack ） 是指在对等网络中，单个节点具有多个身份标识，通过控制系统的大部分节点来削弱系统的安全性 散列函数的特征： - 免碰撞，即不存在输入值不同，经过散列变换，而散列值相同的情况 - 隐匿性，即给定 个散列值，想要反向逆推出输入值，在计算上是不可行的 - 不存在比穷举更好的方法，以使得散列值落在特定的范围 PoW 算法描述： 节点打包经过验证的交易通过不断地更换随机数来探寻合适的散列值（所谓合适的散列值是指该值小于系统提供的某散列值），当节点最先计算出合适的散列值，它所打包的块如果通过其他共识节点的验证，则会被加入到区块链中，这里争取记账权的节点被称为“矿工”。 这些“矿工”在以太坊网络中负责接收、转发、验证并执行交易。 在这个过程中要得到一个符合要求的散列值，节点需要经过大量的散列计算，计算时间则取决于机器的散列运算速度 由于寻找合适的散列值是 个概率事件，所以矿机性能越好，成功的概率就越大，当节点的算力占全网算力的 no/o 时，那么他就有 no/o 的概率找到合适的散列值 打个比方，所有的“矿工”都是登山者团队的首领，他们都拥有 个登山者团队，但是团队的人数有多有少（对应不同的“矿工”有不同的矿机资源） 为了获得奖励这些登山者首领都报名参加了 个登山比赛，山上有很多不同的道路，但是只有 条可以登上山顶，也只有第一个登上山顶的人所在的团队的首领能获得奖励 比赛开始，登山者首领让团队中每人选择一条道路开始登山，如果此路无法到达山顶，那么登山者会下来并重新选上山 最终，有一名登山者将成功登上山顶，他的首领（“矿工”）将会获得奖励 很明显，团队人手多且队员体能好的登山者首领更容易获得奖励，也就是说矿机性能越好，数量越多，那么“矿工”就越可能挖到新块 09.PoS PoS 即基于网络参与者目前所持有的数字货币的数量和时间进行利益分配，是 种对货币所有权的证明 PoS 可以被描述成虚拟挖矿， 般情况下与 PoW 一样， 用户所得利益与购买成本成比例，即买得越多，收获也就越大 在以太坊中， PoS 算法可以这样描述：以太坊区块链由一组验证者决定，任何持有以太币的用户都能发起一笔特殊形式交易，将他们的以太币锁定在一个存储中，从而使自己成为验证者，然后通过一个当前的验证者都能参与的共识算法，完成新区块的产生和验证过程 10.以太币 以太币（ ETH ）是以太坊发行的一种数字货币 以太币是以太网中一个重要元素，在公有链上发起任何一笔交易都需要支付一定的以太币 -以太币的总供给及其发行率是由 2014 年的预售决定的，以太币来源包括“矿前＋ 区块奖励＋叔区块奖励＋叔区块引用奖励”。 具体分配如下： 预付款的贡献者总共有 6000 万个以太币 每挖出 个新的区块，给挖出该区块的矿工奖励 5个以太币 如果一个矿工挖出一个新的区块，但是并不是在主链中，则该区块称为叔区块，如果该块在之后的区块链中作为叔区块被引用 每个叔区块会为挖矿者产出大约 4.375个以太币（ 个以太币奖励的 7/8 ），这被称为叔区块奖励 另外矿工每引用 个叔区块，可以得到大约 0.15 个以太币（最多引用两个叔区块） 当然以太币也不是无限生成的 最小的货币单位为 wei （维） 当一个矿工挖出一个新的区块，他就能获得笔奖励，这笔奖励由两部分构成，分为静态奖励和动态奖励 静态奖励是每挖出 个新块，矿工可以获得 个以太币作为奖励 动态奖励是矿工挖出的区块中包含的所有交易费用归矿工所有，另外如果这个区块有它的叔区块，还可以从每个叔区块引用中获得额外的挖矿奖励的 1/32 （大约 15 个以太币），当然每个区块最多引用 个叔区块，被引用过的叔区块不能重复利用 -叔区块是指该区块父块的父块的子块，同时又不是自己的父块，叔区块不在最长的那条区块链上，而是在分叉链上 这是由于网络延迟的原因使得挖出这个块的矿工没有同步到最新的区块 一个叔区块如果被引用在有效的区块链上，挖到该叔区块的矿 最多可以获得 4.375 个以太币作为奖励 这也保证了以太坊可以在很短的时间内产生新的区块（平均15s ），而不会因为网络同步延迟产生多个分叉 引用叔区块矿工的报酬 除了通过挖矿获取以太币，用户还可以购买以太币 11.交易 以太坊的交易主要是指 条外部账户发送到区块链上另 账户的消息的签名数据包，其主要包含发送者的签名、接收者的地址以及发送者转移给接收者的以太币数量等内容 以太坊上的每一笔交易都需要支付一定的费用，用于支付交易执行所需要的计算开销 计算开销的费用并不是以太币直接计算的，而是引人 Gas 作为执行开销的基本单位，通过GasPrice 与以太币进行换算的 GasPr ce 根据市场波动调整，避免以太币价值受市场价格的影响 12.交易费用 为了防止用户在区块链公有链中发送太多的无意义交易，浪费矿工的计算资源，例如转账金额为 的转账交易，所以各种公有链技术都采用了交易收费的策略，要求交易的发送方为每笔交易付出一定的代价 对于每一笔交易，交易的发送者都需要付出定的交易费；这笔费用会最终由将这个交易打包进主链的矿工收取 12.1. Gas Gas （汽油）是用来衡量一笔交易所消耗的计算资源的基本单位 当矿工收到一笔交易时，会根据交易的内容进行相应的操作 对于转账交易，矿工会根据转账的金额，对交易发送方和接收方的账户余额进行修改 对于创建和调用智能合约的交易，矿工会根据对应的字节码在 EVM 里执行对应的操作 当以太坊节点执行一笔交易所需的计算步骤越多、越复杂，那么就会说这笔交易消耗的 Gas 越多 12.2. Gas Price Gas Price ( Gas 价格）是 单位 Gas 所需的手续费（以太币，即 eth er ） 用户创建一个交易时，可以指定期望的任意 Gas Price ，甚至可以为0 因为矿 有选择收纳交易和收取费用的权利，他们都想使得收益最大化，所以如果大多数交易都以 Gwei 的价格提交，那么很难让矿工接收一个比这个价格低的交易 12.3. Gas Limit Gas 是衡量交易的计算开销的基本单位 以太坊的实际操作中，用户需要注意两个 Gas Limit ( Gas 限制）的概念： 对于单个交易， Gas Limit （有时也会称作 StartGas ）表示交易发送者愿意为这笔交易执行所支付的最大 Gas 数量，需要发送者在发送交易时设置；而对于区块来说， Gas Limit 是单个区块所允许包含的最大 Gas 总量 对于单个交易， Gas Limit 可以保护用户免受错误代码影响以致消耗过多的交易费 在某些场景下，交易发送者并不能提前准确预估出每笔交易将会消耗的 Gas ，例如某个调用智能合约的交易会根据不同的执行时间触发不同的操作 易设置了一个合理的 Gas Limit ，那么如果交易实际消耗的 Gas (Gas Used ）小于 Gas Limit, 那么执行的矿工只会收取实际计算开销（ Gas Used ）对应的交易手续费（ Gas Used * Gas Price ）；而如果 Gas Used 小于 Gas Limit ，那么矿工执行过程中会发现 Gas 已被耗尽而交易没有执行完成，此时矿工会回滚到程序执行前的状态 GasPrice * Gas Limit 表示用户愿意为一笔交易支的最高金额 如果交易没有 Gas Limit 限制，那么某些恶意用户可能会发送一个数十亿步骤的交易，并且没有人能够处理它，因为处理这个交易甚至需要花费比出块间隔更长的时间，然而矿工事前并不知道，所以会导致拒绝服务式攻击 区块的 Gas Limit 表示一个区块所包含的所有交易消耗的 Gas 的上限，由矿工决定它的大小 这完全取决于矿 的意愿 总之，被打包交易的Gas Limit 数量之和不能超过区块的 Gas Limit 区块的 Gas Limit 设置得越大，那么矿工就可以获取越多的交易费，但是需要更多的带宽，同时会加大叔区块出现的频率，造成挖出的区块无法形成最长的交易链 矿工也不能任意地更改区块的 Gas Limit ，根据以太坊协议，当前区块的 Gas Limit 只能基于上个区块的 Gas Limit 上下波动 1/1024 12.交易内容 以太坊中的交易（ Transaction ）是指存储一条从外部账户发送到区块链上另－个账户的消息的签名数据包，它既可以是简单的数字货币一一以太币的转账，也可以是包含智能合约代码的消息 一条交易包含以下内容： from ：交易发送者的地址，必填； to ：交易接收者的地址，如果为空则意味这是一个创建智能合约的交易； value ：发送者要转移给接收者的以太币数量； data （也写作 input ）：存在的数据字段，如果存在，则是表明该交易是 个创建或者调用智能合约交易； Gas Limit （也写作 Gas, StartGas ）：表示这个交易允许消耗的最大 Gas 数量； GasPrice ：表示发送者愿意支付给矿工的 Gas 价格； nonce ：用来区别同一用户发出的不同交易的标记； hash ：由以上信息生成的散列值（哈希值），作为交易的 ID; r,s,v :：交易签名的三个部分，由发送者的私钥对交易 hash 进行签名生成 在不同的场景下，交易有三种类型 转账交易： 转账是最简单的一种交易，从一个账户向另 个账户发送以太币，发送转账交易时只需要指定交易的发送者、接收者、转移的以太币数量即可（在客户端发送交易时， Gas Limit Gas Price nonce hash 、签名可以按照默认方式生成） ）创建智能合约的交易:：创建合约是指将合约部署到区块链上，这也是通过发送交易来实现的。在创建合约的交易中，to字段是一个空字符串，在data字段中指定初始化合约的二进制，在之后合约被调用时，该代码的执行结果将作为合约代码。 执行智能合约的交易：：顾名思义，该交易是为了执行已经部署在区块链上的智能合约，在该交易中，需要将“ 。”字段指定为要调用的智能合约的地址，通过“ data ，，字段指定要调用的方法以及向该方法传递参数 13.数据编码与压缩 RLP ( Recursive Length Prefix ）是一种编码算法，，用于编码任意的具有嵌套结构的二进制数据，是以太坊数据序列化的主要方法 以太坊中的区块 、交易等数据结构会先经过RLP 编码处理，然后再存储到数据库中 RLP 编码只处理两种类型的数据，即字符串和列表 得注意的是，其中并不包括原子数据类型， 如整型、浮点型 一 是按照字典顺序用含关键字的二维数组，另一种是使用更高级 Patricia 树来编码 在以太坊中，当发送数据以及在 MPT 树中保存状态时， 需要使用 RLP 编码 14.以大坊客户端和 API Web3.js API 作为先进共有链的代表之一，及以太坊区块链本质是一串连接的数据区块，区块之间使用密码学算法生成的散列指针连接。 对以太坊的区块，交易，账户等基本组成由一定了解，以太坊的数据结构和存储支持，以便读者对其底层结构有所了解。 以太坊入口 - 客户端和以太坊域名服务，让用户能够了解以太坊的顶层应用 阅读更多" />
<meta property="og:description" content="版权声明：忠于祖国，忠于人民 https://blog.csdn.net/boss2967/article/details/83244455 01.以太坊整体架构 以太坊是一个区块链应用平台。 分为三层： 底层服务 核心层 顶层应用 02.区块 区块链是比特币使用的底层技术架构。 他本身是一串连续的数据区块，区块之间的连接指针是区块头散列指针，他们是使用密码学散列算法生成的。 区块本质上就是一个数据包，比特币的交易记录会保存在区块中，大约每10分钟生成一个新的区块。 所谓区块：可以定义为记录一段时间内发生的交易和状态的结果的数据结构。是对当前账本状态的一次共识。 比特币的每个数据区块一般包含区块头（Header）和区块体（Body）两部分。 区块头封装了前一个区块的散列值（Prev_Hash），时间戳（Timestamp）,随机数（Nonce）,Merkle树的根值（Tx_Root）和当前区块的散列值等信息。 区块体中则主要包含交易技术和交易详情。 - 每笔交易都被永久的记录在区块中，任何人都可以查询。交易是通过Merkle树的数据结果记录的。其中没仪表交易都包含了数字签名，如此可以保证每一笔交易都不伪造，不能篡改。所有的交易过程都将通过Merkle树的hash过程生成一个唯一的Tx-Root记录到区块中。 用户在验证区块的有效性时，只需根据Merkle树的Hash方法计算出根值并且与区块中Tx_Root进行比较，即可验证真伪，若相同及有效，若不同则无效。 03.区块 ——以太坊 去开主要由区块头，交易列表，和叔区块三部分组成。 区块头： 父块的散列值（PrevHash） 叔区块的散列值（Uncles Hash） 状态树根散列值（stateRoot） 交易树根散列值（Transaction Root） 收据树根散列值（Receipt Root） 时间戳（Timestamp） 随机数（Nonce） 以太坊区块链上区块数据结构的一个重要改变就是保存了三棵Merkle树根 状态树 交易树 收据树 存储三棵树可以方便账户做更多查询 交易列表是由矿工从交易池选择收入区块中的一系列交易 区块链上的第一个区块称为“创世区块” 区块链上除了创世区块意外每个区块都有他的父区块，这些区块连接起来组成一个区块链 以太坊大约每15s可以挖出一个新的区块 以太坊区块结构中状态树的更新 04.账户 账户以地址为索引，地址由公钥衍生而来，取公钥的最后20字节 两种类型的账户 外部账户 简称账户，他们都是由人创建，可以储存以太币 合约账户 合约账户是由外部账户创建的账户 以太坊中这两中账户统称为“状态对象”（存储状态） 外部账户储存以太币余额状态 合约庄户除了余额还有智能合约以及其变量的状态 通过交易的执行，这行状态对象发生变化，而Merkle树用户索引和状态对象的更新。 一个以太坊的账户包含四个部分 该地址交易的次数，他是用于保障被一笔交易能且被处理一次的计数器，有效避免重放攻击 账户目前的以太币余额 账户的合约二进制代码（合约账户） 账户的储存（默认为空） 4.1 外部账户 外部账户（EOA）由私钥来控制，是由用户实际控制的账户 每个外部账户拥有一对公私钥，这对密钥用于签署交易，他的地址由公钥决定。 外部账户不能包含以太坊虚拟机（EVM）代码 我们可以做一个简单的对比，把外部账户看做用户在某个银行办理的一个账户，公钥就是用户为该账户设置的卡号，而私钥则是用户设置的密码。 一个外部账户具有以下特性： 拥有一定的账户余额 可以发送交易 通过私钥控制 以及没有相关的代码 用户在创建好战鼓后一定要记住私钥！如果用户忘记了，那你就滚吧。不可能不滚的。 秘钥通常保存在keystore目录下， 用户可以经常性的备份密钥文件，以防止忘记或者丢失 在以太坊节点之间传递整个目录后者密钥文件是安全的。但是账户的顺序可能会发生比改变。 用户需确保不要依赖或者更改脚本和代码段中的索引。用户自己列出自己创建的账户时，账户汇按字典排序，并且按照账户的创建时间先后排序 4.2 合约账户 合约账户是一个包含合约代码的账户 合约账户不是由私钥文件直接控制，而是由合约代码控制的 合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出 一个合约账户具有下列特性： 拥有一定的以太币余额 有相关联的代码 代码通过交易或者其他合约发送的调用来激活。 当合约被执行时候，智能操作合约庄户拥有的特定储存。 合约账户和普通账户最大的不同就是他还存有智能合约 以太坊区块链上的所有操作都是根据都是根据从账户发出的交易来执行的。 每当合约账户收到一条交易消息时，其他合约代码将被交易输入的参数调用执行。 而合约代码将会在参与到网络中的每一个节点上执行，并将执行结果作为新区块验证的一部分 4.3 私钥和公钥 公钥加密 -公钥认证 私钥的三种形态： Private key就是一份随机生成的256位二进制数字，该256位二进制数字就是私钥最初始的状态 而2以太坊钱包中，私钥和公钥将会以加密的方式保存一份JSON文件，存在keystore子目录下，这份JSON文件就是Keystore,所以用户需要同时备份Keystore和对应的Password 最后一种Memonic code是由BIP39方案，随机生成12-24个容易几乎记住的单词，随机种子，通过提案的方式生成确定性钱包 4.4 钱包 钱包就是一个比较形象的概念，一个外部账户通常由私钥文件来控制，拥有私钥的而用户就可以拥有对应地址的账户里的以太币使用权。 我们通常把管理这些数字密钥的软件成为钱包，而我们所所的备份钱包其实就是备份账户的私钥文件 -以太币钱包分类 Mist钱包 Parity钱包 Etherwall钱包 Brain钱包 钱包备份 防盗：分离备份 防丢：多处本分 分散风向：将资金适当的分散开 常见的钱包备份方式： 多处和分离备份 纸钱包 预防方案：用户可以痛死使用多重签名和多处分离备份，设定一个金额阈值，当用户提取超过该阈值的金额时需要多个私钥，另外把这些私钥多处分离备份，大大降低了资金被盗的风险 05.数据结构与储存 包括以太坊和比特币在内的大多是都是区块链项目，会使用Merkle树或者基于Merkle树的数据结构，比特币- 中保存了一颗Merkle树，而以太坊针对对象设计了三棵Merkle树，分别是状态树，交易树和收据叔，这三种树可以帮助以太坊客户端做一些简易的查询，查询某个账户的余额，某笔交易是否被包含在区块中。 区块，交易等数据最终都是存在LevelDB数据库中，LevelDB数据库是一个键值对数据库，key一般与散列相关，value则是存在储存内容的RLP编码 5.1 数据组织形式 以太坊使用Merkle Patricia树，（MPT）,作为数据组织形式，用来组织管理用户的账户状态，交易信息等重要数据。 MPT是一种加密认证的数据结构，他融合了Merkle树和Tire树（前缀树）两种数据类型的优点 Merkle树 Merkle树是一种树行数据结构，可以是二叉树，也可以是多叉树 由一组叶节点，一组中间节点和一个根节点构成 最下面的叶节点包含基础数据，每个中间节点是他的子节点的散列，根节点是他的子节点的散列，代表了Merkle树的根部。 创建Merkle树的目的是语序区块的数据可以零散的传送 节点可以从一个节点下载区块头，从另外的源下载与其相关的树的其他部分，而依然能够确认所有的数据都是正确的。之所以如此是因为散列向上扩散，如果一个恶意用户尝试在树的下部加入一个伪造的交易，所引起的改动将导致树上的上层节点以及更上层节点的改动，最终导致根节点的改动以及区块散列的改动，这样协议就会将其记录为一个完全不同的区块（几乎可以坑定带着不确定的工作量证明） 如果底层的交易被篡改了，那么其对应的叶节点散列值也会改变，这件最终导致其Merkle树根值变化 Merkle树可以用来储存所有键值对 这颗树的建立从每个节点开始，将节点两两分成多达16个组，并对每个组求散列值，接着对散列结果继续求散列值，如此递归下去，知道整颗树有一个最后的根散列值。 Merkle树具有下列特性 每个数据集对应一个唯一合法的根散列值 很不容易更新，添加， 或者删除树节点，以及生成新的根散列值 不改变根散列值的话就没有办法修改树的任何部分，所以如果跟散列值被包括在签名的文档或者有效区块中，就可以保证这棵树的正确性 任何人都可以只提供一个到特定节点的分支，并且通过密码学方法证明拥有对应内容的节点确实在树里 5.2 Trie树 Trie树也叫做Radix树 在Radic树中，key代表的是从树根到对应value的一条真实的路径 即从根节点开始，key中的每个字符（从前到后）都代表着从根节点触发寻找相应value所要经过的子节点 value储存在叶节点中，是每个路径的最终节点。 假如key中的每个字符都来自一个容量为N且包含的字母都互不相识的字母表，那么树中的每个节点最多会有N个孩子，树的最大深度便是Key的最大程度 优点如果有两个value,他们有着基于相同前缀的key，他们的相同前缀的长度占自身比例越大，则代表着两个value在树中的位置越靠近，并且Trie树中不会有像散列表一样的冲突，也就是说一个key只对应一个value,但是也存在着不平衡的 5.3 Merkle Patricia树 为了保证树的加密安全，每个节点通过他的散列值被引用，对于存储在LEVELDB数据库中的非叶节点，其中数据库中的表现形式：key代表着节点的RLP编码的SHA3散列值，value是节点的RLP编码。想要获得一个节点的内容，只需要根据该节点的散列值访问数据库以获得节点的RLP编码，然后解码即可。 在该方案中，根节点被称为整棵树的加密签名，如果一棵树给定Trie树的根散列值是公开的，那么所有人都可以提供一种证明，即通过提供每步向上的路径证明特定的key是否含有特定的值 引入很多节点类型来提供效率，MPT中节点包括以下4种： 空节点：简单的表示空，在代码中就是一个空串 叶节点：键值对的一个列表，其中key是一种特殊的十六进制编码，value是RLP编码 扩展节点：键值对的列表，但是这里的value是其他接待的散列值，通过这个散列值可以连接到其他节点 分支节点：一个节点为17的列表，MPT中的key被编码成一种特殊的十六进制的表示，再加上最后的value，前16个元素对应的key中的16个可能的十六进制字符，如果有一个键值对在这个分支节点终止，则最后一个元素代表一个值，即分支节点既然可以是搜索路径的终止，也可能是路径的中间节点 MPT还有一个重要的概念：用户对key进行编码的特殊十六进制前缀编码（HP），因为字母表中的字符都是十六进制表示的，所以每个节点最多只能由16个孩子，因为键值对有两个表示形式的节点，所以必须引用一中特殊的终止符表示，用来标示key所对应的值是真实的值还是其他节点的散列值。通过对终止符标识进行赋值，可以区分key所对应的节点的种类，无论key的长度是奇数还是偶数，HP都可以对其进行编码。 以太坊区块链系统中使用MPT树结构，但是每个以太坊区块头不是只包括一颗MPT树，而是为了三种对象设计了三棵树。 5.4 状态树 状态树中的每个节点16个孩子节点，每个叶节点表示一个账户，这些叶节点的父节点由叶节点的散列组成，而这些父节点再组成更高一层的父节点，直至到形成根节点。 状态树包含一个键值映射，其中键是账户地址，值是账户内容 {nonce,balance,codeahash,storageRoot} nonce是账户交易的序数 balance是账户余额 codeHash是代码的散列值 storageRoot是另一棵树的根节点 状态树代表访问区块后的整个状态 账户的状态不是直接存储在每个区块中，所有的账户状态都是以状态数据的形式存在以太坊的节点中 状态数据是一种隐式的数据，意味着他需要从实际的区块链数据中计算出来，交易包含决定新状态数据的所有字段内容。与比特币不同的是，以太坊区块包含了整个状态树的Merkle树根散列和交易列表 状态树是用来记录各个账户的状态的树，他需要经常更新 5.5 交易树 每个区块都有一棵独立的交易树。 区块中交易的顺序主要由矿工决定，在这个块被挖出来前这些数据都是未知的。不过矿工一般会根据交易的GasPrice和Nonce对交易进行排序。 首先会将交易列表中的交易划分到各个发送账户，每个账户的交易根据这些交易的nonce来排序，每个账户的交易排序完成后，再通过比较每个账户的第一条交易，选择最高价格的交易，这写是通过一个堆来实现的、 每挖出一个新块，更新一次交易树 在交易树包含的键值对中，其中每个键是交易的编号，值是交易内容 5.6 收据树 每个区块都有自己的收据树，收据树不需要更新 收据树代表每个交易相应的收据 收据树也包含了一个键值映射，其中键是索引编号，用来指引这个收据相关的交易的位置，值是收据的内容 交易的收据是一个RLP编码的数据结构[medstate,Gas_used,logbloom,logs]，其中 medstate是交易处理后树根的状态，Gas_used是交易处理后Gas的使用量，logs是表格元素的列表，表格有交易执行期间调用的操作码，address是生成日志的合约地址，topicn是最多4个32字节的值，data是任意字节大小的数据，logbllom是交易所有logs的布隆过滤器。 06.数据库支持-LevelDB LevelDB是谷歌实现的一个非常高效的键值对数据库，其中键值都是二进制，目前能够支持十亿级别的数据量。在这个数据量下还有这非常高的性能。 以太坊中共有三个LeveleDB数据库： BlockDB: 保存了块的主体内容，包括块头和交易 StateDB: 保存了账户的状态数据 ExtrasDB：ExtrasDB保存了收据信息和其他辅助信息 LevelDB的用户接口，put(k,v),get(k,v) delete(k,v) 特性： key和value都是任意长度的字节数组，一条记录（即一个键值对）默认是按照key的字典顺序存储，当然开发者也可以重载这个排序函数。 支持遍历，包括前向或者反向 支持原子写操作 支持过滤策略 支持数据自动压缩（snappy压缩算法） 底层提供了抽象接口，允许用户定制 限制： 不是sql类型数据库，没有关系模型 一个表只允许一个进程访问 单机系统没有服务器客户端 以太坊使用LevelDB主要考虑到他的写优化的特点 07.共识机制 共识机制是区块链事务达成分布式共识的算法 由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制 08.Pow PoW 即通过工作结果来证明你完成了相应的工作 PoW 是通过结果证明以确认你完成了 定量的工作 女巫攻击（ Sybil Attack ） 是指在对等网络中，单个节点具有多个身份标识，通过控制系统的大部分节点来削弱系统的安全性 散列函数的特征： - 免碰撞，即不存在输入值不同，经过散列变换，而散列值相同的情况 - 隐匿性，即给定 个散列值，想要反向逆推出输入值，在计算上是不可行的 - 不存在比穷举更好的方法，以使得散列值落在特定的范围 PoW 算法描述： 节点打包经过验证的交易通过不断地更换随机数来探寻合适的散列值（所谓合适的散列值是指该值小于系统提供的某散列值），当节点最先计算出合适的散列值，它所打包的块如果通过其他共识节点的验证，则会被加入到区块链中，这里争取记账权的节点被称为“矿工”。 这些“矿工”在以太坊网络中负责接收、转发、验证并执行交易。 在这个过程中要得到一个符合要求的散列值，节点需要经过大量的散列计算，计算时间则取决于机器的散列运算速度 由于寻找合适的散列值是 个概率事件，所以矿机性能越好，成功的概率就越大，当节点的算力占全网算力的 no/o 时，那么他就有 no/o 的概率找到合适的散列值 打个比方，所有的“矿工”都是登山者团队的首领，他们都拥有 个登山者团队，但是团队的人数有多有少（对应不同的“矿工”有不同的矿机资源） 为了获得奖励这些登山者首领都报名参加了 个登山比赛，山上有很多不同的道路，但是只有 条可以登上山顶，也只有第一个登上山顶的人所在的团队的首领能获得奖励 比赛开始，登山者首领让团队中每人选择一条道路开始登山，如果此路无法到达山顶，那么登山者会下来并重新选上山 最终，有一名登山者将成功登上山顶，他的首领（“矿工”）将会获得奖励 很明显，团队人手多且队员体能好的登山者首领更容易获得奖励，也就是说矿机性能越好，数量越多，那么“矿工”就越可能挖到新块 09.PoS PoS 即基于网络参与者目前所持有的数字货币的数量和时间进行利益分配，是 种对货币所有权的证明 PoS 可以被描述成虚拟挖矿， 般情况下与 PoW 一样， 用户所得利益与购买成本成比例，即买得越多，收获也就越大 在以太坊中， PoS 算法可以这样描述：以太坊区块链由一组验证者决定，任何持有以太币的用户都能发起一笔特殊形式交易，将他们的以太币锁定在一个存储中，从而使自己成为验证者，然后通过一个当前的验证者都能参与的共识算法，完成新区块的产生和验证过程 10.以太币 以太币（ ETH ）是以太坊发行的一种数字货币 以太币是以太网中一个重要元素，在公有链上发起任何一笔交易都需要支付一定的以太币 -以太币的总供给及其发行率是由 2014 年的预售决定的，以太币来源包括“矿前＋ 区块奖励＋叔区块奖励＋叔区块引用奖励”。 具体分配如下： 预付款的贡献者总共有 6000 万个以太币 每挖出 个新的区块，给挖出该区块的矿工奖励 5个以太币 如果一个矿工挖出一个新的区块，但是并不是在主链中，则该区块称为叔区块，如果该块在之后的区块链中作为叔区块被引用 每个叔区块会为挖矿者产出大约 4.375个以太币（ 个以太币奖励的 7/8 ），这被称为叔区块奖励 另外矿工每引用 个叔区块，可以得到大约 0.15 个以太币（最多引用两个叔区块） 当然以太币也不是无限生成的 最小的货币单位为 wei （维） 当一个矿工挖出一个新的区块，他就能获得笔奖励，这笔奖励由两部分构成，分为静态奖励和动态奖励 静态奖励是每挖出 个新块，矿工可以获得 个以太币作为奖励 动态奖励是矿工挖出的区块中包含的所有交易费用归矿工所有，另外如果这个区块有它的叔区块，还可以从每个叔区块引用中获得额外的挖矿奖励的 1/32 （大约 15 个以太币），当然每个区块最多引用 个叔区块，被引用过的叔区块不能重复利用 -叔区块是指该区块父块的父块的子块，同时又不是自己的父块，叔区块不在最长的那条区块链上，而是在分叉链上 这是由于网络延迟的原因使得挖出这个块的矿工没有同步到最新的区块 一个叔区块如果被引用在有效的区块链上，挖到该叔区块的矿 最多可以获得 4.375 个以太币作为奖励 这也保证了以太坊可以在很短的时间内产生新的区块（平均15s ），而不会因为网络同步延迟产生多个分叉 引用叔区块矿工的报酬 除了通过挖矿获取以太币，用户还可以购买以太币 11.交易 以太坊的交易主要是指 条外部账户发送到区块链上另 账户的消息的签名数据包，其主要包含发送者的签名、接收者的地址以及发送者转移给接收者的以太币数量等内容 以太坊上的每一笔交易都需要支付一定的费用，用于支付交易执行所需要的计算开销 计算开销的费用并不是以太币直接计算的，而是引人 Gas 作为执行开销的基本单位，通过GasPrice 与以太币进行换算的 GasPr ce 根据市场波动调整，避免以太币价值受市场价格的影响 12.交易费用 为了防止用户在区块链公有链中发送太多的无意义交易，浪费矿工的计算资源，例如转账金额为 的转账交易，所以各种公有链技术都采用了交易收费的策略，要求交易的发送方为每笔交易付出一定的代价 对于每一笔交易，交易的发送者都需要付出定的交易费；这笔费用会最终由将这个交易打包进主链的矿工收取 12.1. Gas Gas （汽油）是用来衡量一笔交易所消耗的计算资源的基本单位 当矿工收到一笔交易时，会根据交易的内容进行相应的操作 对于转账交易，矿工会根据转账的金额，对交易发送方和接收方的账户余额进行修改 对于创建和调用智能合约的交易，矿工会根据对应的字节码在 EVM 里执行对应的操作 当以太坊节点执行一笔交易所需的计算步骤越多、越复杂，那么就会说这笔交易消耗的 Gas 越多 12.2. Gas Price Gas Price ( Gas 价格）是 单位 Gas 所需的手续费（以太币，即 eth er ） 用户创建一个交易时，可以指定期望的任意 Gas Price ，甚至可以为0 因为矿 有选择收纳交易和收取费用的权利，他们都想使得收益最大化，所以如果大多数交易都以 Gwei 的价格提交，那么很难让矿工接收一个比这个价格低的交易 12.3. Gas Limit Gas 是衡量交易的计算开销的基本单位 以太坊的实际操作中，用户需要注意两个 Gas Limit ( Gas 限制）的概念： 对于单个交易， Gas Limit （有时也会称作 StartGas ）表示交易发送者愿意为这笔交易执行所支付的最大 Gas 数量，需要发送者在发送交易时设置；而对于区块来说， Gas Limit 是单个区块所允许包含的最大 Gas 总量 对于单个交易， Gas Limit 可以保护用户免受错误代码影响以致消耗过多的交易费 在某些场景下，交易发送者并不能提前准确预估出每笔交易将会消耗的 Gas ，例如某个调用智能合约的交易会根据不同的执行时间触发不同的操作 易设置了一个合理的 Gas Limit ，那么如果交易实际消耗的 Gas (Gas Used ）小于 Gas Limit, 那么执行的矿工只会收取实际计算开销（ Gas Used ）对应的交易手续费（ Gas Used * Gas Price ）；而如果 Gas Used 小于 Gas Limit ，那么矿工执行过程中会发现 Gas 已被耗尽而交易没有执行完成，此时矿工会回滚到程序执行前的状态 GasPrice * Gas Limit 表示用户愿意为一笔交易支的最高金额 如果交易没有 Gas Limit 限制，那么某些恶意用户可能会发送一个数十亿步骤的交易，并且没有人能够处理它，因为处理这个交易甚至需要花费比出块间隔更长的时间，然而矿工事前并不知道，所以会导致拒绝服务式攻击 区块的 Gas Limit 表示一个区块所包含的所有交易消耗的 Gas 的上限，由矿工决定它的大小 这完全取决于矿 的意愿 总之，被打包交易的Gas Limit 数量之和不能超过区块的 Gas Limit 区块的 Gas Limit 设置得越大，那么矿工就可以获取越多的交易费，但是需要更多的带宽，同时会加大叔区块出现的频率，造成挖出的区块无法形成最长的交易链 矿工也不能任意地更改区块的 Gas Limit ，根据以太坊协议，当前区块的 Gas Limit 只能基于上个区块的 Gas Limit 上下波动 1/1024 12.交易内容 以太坊中的交易（ Transaction ）是指存储一条从外部账户发送到区块链上另－个账户的消息的签名数据包，它既可以是简单的数字货币一一以太币的转账，也可以是包含智能合约代码的消息 一条交易包含以下内容： from ：交易发送者的地址，必填； to ：交易接收者的地址，如果为空则意味这是一个创建智能合约的交易； value ：发送者要转移给接收者的以太币数量； data （也写作 input ）：存在的数据字段，如果存在，则是表明该交易是 个创建或者调用智能合约交易； Gas Limit （也写作 Gas, StartGas ）：表示这个交易允许消耗的最大 Gas 数量； GasPrice ：表示发送者愿意支付给矿工的 Gas 价格； nonce ：用来区别同一用户发出的不同交易的标记； hash ：由以上信息生成的散列值（哈希值），作为交易的 ID; r,s,v :：交易签名的三个部分，由发送者的私钥对交易 hash 进行签名生成 在不同的场景下，交易有三种类型 转账交易： 转账是最简单的一种交易，从一个账户向另 个账户发送以太币，发送转账交易时只需要指定交易的发送者、接收者、转移的以太币数量即可（在客户端发送交易时， Gas Limit Gas Price nonce hash 、签名可以按照默认方式生成） ）创建智能合约的交易:：创建合约是指将合约部署到区块链上，这也是通过发送交易来实现的。在创建合约的交易中，to字段是一个空字符串，在data字段中指定初始化合约的二进制，在之后合约被调用时，该代码的执行结果将作为合约代码。 执行智能合约的交易：：顾名思义，该交易是为了执行已经部署在区块链上的智能合约，在该交易中，需要将“ 。”字段指定为要调用的智能合约的地址，通过“ data ，，字段指定要调用的方法以及向该方法传递参数 13.数据编码与压缩 RLP ( Recursive Length Prefix ）是一种编码算法，，用于编码任意的具有嵌套结构的二进制数据，是以太坊数据序列化的主要方法 以太坊中的区块 、交易等数据结构会先经过RLP 编码处理，然后再存储到数据库中 RLP 编码只处理两种类型的数据，即字符串和列表 得注意的是，其中并不包括原子数据类型， 如整型、浮点型 一 是按照字典顺序用含关键字的二维数组，另一种是使用更高级 Patricia 树来编码 在以太坊中，当发送数据以及在 MPT 树中保存状态时， 需要使用 RLP 编码 14.以大坊客户端和 API Web3.js API 作为先进共有链的代表之一，及以太坊区块链本质是一串连接的数据区块，区块之间使用密码学算法生成的散列指针连接。 对以太坊的区块，交易，账户等基本组成由一定了解，以太坊的数据结构和存储支持，以便读者对其底层结构有所了解。 以太坊入口 - 客户端和以太坊域名服务，让用户能够了解以太坊的顶层应用 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/10/21/8a13d3a1ae77a86c3e531a1068291b77.html" />
<meta property="og:url" content="https://mlh.app/2018/10/21/8a13d3a1ae77a86c3e531a1068291b77.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-10-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：忠于祖国，忠于人民 https://blog.csdn.net/boss2967/article/details/83244455 01.以太坊整体架构 以太坊是一个区块链应用平台。 分为三层： 底层服务 核心层 顶层应用 02.区块 区块链是比特币使用的底层技术架构。 他本身是一串连续的数据区块，区块之间的连接指针是区块头散列指针，他们是使用密码学散列算法生成的。 区块本质上就是一个数据包，比特币的交易记录会保存在区块中，大约每10分钟生成一个新的区块。 所谓区块：可以定义为记录一段时间内发生的交易和状态的结果的数据结构。是对当前账本状态的一次共识。 比特币的每个数据区块一般包含区块头（Header）和区块体（Body）两部分。 区块头封装了前一个区块的散列值（Prev_Hash），时间戳（Timestamp）,随机数（Nonce）,Merkle树的根值（Tx_Root）和当前区块的散列值等信息。 区块体中则主要包含交易技术和交易详情。 - 每笔交易都被永久的记录在区块中，任何人都可以查询。交易是通过Merkle树的数据结果记录的。其中没仪表交易都包含了数字签名，如此可以保证每一笔交易都不伪造，不能篡改。所有的交易过程都将通过Merkle树的hash过程生成一个唯一的Tx-Root记录到区块中。 用户在验证区块的有效性时，只需根据Merkle树的Hash方法计算出根值并且与区块中Tx_Root进行比较，即可验证真伪，若相同及有效，若不同则无效。 03.区块 ——以太坊 去开主要由区块头，交易列表，和叔区块三部分组成。 区块头： 父块的散列值（PrevHash） 叔区块的散列值（Uncles Hash） 状态树根散列值（stateRoot） 交易树根散列值（Transaction Root） 收据树根散列值（Receipt Root） 时间戳（Timestamp） 随机数（Nonce） 以太坊区块链上区块数据结构的一个重要改变就是保存了三棵Merkle树根 状态树 交易树 收据树 存储三棵树可以方便账户做更多查询 交易列表是由矿工从交易池选择收入区块中的一系列交易 区块链上的第一个区块称为“创世区块” 区块链上除了创世区块意外每个区块都有他的父区块，这些区块连接起来组成一个区块链 以太坊大约每15s可以挖出一个新的区块 以太坊区块结构中状态树的更新 04.账户 账户以地址为索引，地址由公钥衍生而来，取公钥的最后20字节 两种类型的账户 外部账户 简称账户，他们都是由人创建，可以储存以太币 合约账户 合约账户是由外部账户创建的账户 以太坊中这两中账户统称为“状态对象”（存储状态） 外部账户储存以太币余额状态 合约庄户除了余额还有智能合约以及其变量的状态 通过交易的执行，这行状态对象发生变化，而Merkle树用户索引和状态对象的更新。 一个以太坊的账户包含四个部分 该地址交易的次数，他是用于保障被一笔交易能且被处理一次的计数器，有效避免重放攻击 账户目前的以太币余额 账户的合约二进制代码（合约账户） 账户的储存（默认为空） 4.1 外部账户 外部账户（EOA）由私钥来控制，是由用户实际控制的账户 每个外部账户拥有一对公私钥，这对密钥用于签署交易，他的地址由公钥决定。 外部账户不能包含以太坊虚拟机（EVM）代码 我们可以做一个简单的对比，把外部账户看做用户在某个银行办理的一个账户，公钥就是用户为该账户设置的卡号，而私钥则是用户设置的密码。 一个外部账户具有以下特性： 拥有一定的账户余额 可以发送交易 通过私钥控制 以及没有相关的代码 用户在创建好战鼓后一定要记住私钥！如果用户忘记了，那你就滚吧。不可能不滚的。 秘钥通常保存在keystore目录下， 用户可以经常性的备份密钥文件，以防止忘记或者丢失 在以太坊节点之间传递整个目录后者密钥文件是安全的。但是账户的顺序可能会发生比改变。 用户需确保不要依赖或者更改脚本和代码段中的索引。用户自己列出自己创建的账户时，账户汇按字典排序，并且按照账户的创建时间先后排序 4.2 合约账户 合约账户是一个包含合约代码的账户 合约账户不是由私钥文件直接控制，而是由合约代码控制的 合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出 一个合约账户具有下列特性： 拥有一定的以太币余额 有相关联的代码 代码通过交易或者其他合约发送的调用来激活。 当合约被执行时候，智能操作合约庄户拥有的特定储存。 合约账户和普通账户最大的不同就是他还存有智能合约 以太坊区块链上的所有操作都是根据都是根据从账户发出的交易来执行的。 每当合约账户收到一条交易消息时，其他合约代码将被交易输入的参数调用执行。 而合约代码将会在参与到网络中的每一个节点上执行，并将执行结果作为新区块验证的一部分 4.3 私钥和公钥 公钥加密 -公钥认证 私钥的三种形态： Private key就是一份随机生成的256位二进制数字，该256位二进制数字就是私钥最初始的状态 而2以太坊钱包中，私钥和公钥将会以加密的方式保存一份JSON文件，存在keystore子目录下，这份JSON文件就是Keystore,所以用户需要同时备份Keystore和对应的Password 最后一种Memonic code是由BIP39方案，随机生成12-24个容易几乎记住的单词，随机种子，通过提案的方式生成确定性钱包 4.4 钱包 钱包就是一个比较形象的概念，一个外部账户通常由私钥文件来控制，拥有私钥的而用户就可以拥有对应地址的账户里的以太币使用权。 我们通常把管理这些数字密钥的软件成为钱包，而我们所所的备份钱包其实就是备份账户的私钥文件 -以太币钱包分类 Mist钱包 Parity钱包 Etherwall钱包 Brain钱包 钱包备份 防盗：分离备份 防丢：多处本分 分散风向：将资金适当的分散开 常见的钱包备份方式： 多处和分离备份 纸钱包 预防方案：用户可以痛死使用多重签名和多处分离备份，设定一个金额阈值，当用户提取超过该阈值的金额时需要多个私钥，另外把这些私钥多处分离备份，大大降低了资金被盗的风险 05.数据结构与储存 包括以太坊和比特币在内的大多是都是区块链项目，会使用Merkle树或者基于Merkle树的数据结构，比特币- 中保存了一颗Merkle树，而以太坊针对对象设计了三棵Merkle树，分别是状态树，交易树和收据叔，这三种树可以帮助以太坊客户端做一些简易的查询，查询某个账户的余额，某笔交易是否被包含在区块中。 区块，交易等数据最终都是存在LevelDB数据库中，LevelDB数据库是一个键值对数据库，key一般与散列相关，value则是存在储存内容的RLP编码 5.1 数据组织形式 以太坊使用Merkle Patricia树，（MPT）,作为数据组织形式，用来组织管理用户的账户状态，交易信息等重要数据。 MPT是一种加密认证的数据结构，他融合了Merkle树和Tire树（前缀树）两种数据类型的优点 Merkle树 Merkle树是一种树行数据结构，可以是二叉树，也可以是多叉树 由一组叶节点，一组中间节点和一个根节点构成 最下面的叶节点包含基础数据，每个中间节点是他的子节点的散列，根节点是他的子节点的散列，代表了Merkle树的根部。 创建Merkle树的目的是语序区块的数据可以零散的传送 节点可以从一个节点下载区块头，从另外的源下载与其相关的树的其他部分，而依然能够确认所有的数据都是正确的。之所以如此是因为散列向上扩散，如果一个恶意用户尝试在树的下部加入一个伪造的交易，所引起的改动将导致树上的上层节点以及更上层节点的改动，最终导致根节点的改动以及区块散列的改动，这样协议就会将其记录为一个完全不同的区块（几乎可以坑定带着不确定的工作量证明） 如果底层的交易被篡改了，那么其对应的叶节点散列值也会改变，这件最终导致其Merkle树根值变化 Merkle树可以用来储存所有键值对 这颗树的建立从每个节点开始，将节点两两分成多达16个组，并对每个组求散列值，接着对散列结果继续求散列值，如此递归下去，知道整颗树有一个最后的根散列值。 Merkle树具有下列特性 每个数据集对应一个唯一合法的根散列值 很不容易更新，添加， 或者删除树节点，以及生成新的根散列值 不改变根散列值的话就没有办法修改树的任何部分，所以如果跟散列值被包括在签名的文档或者有效区块中，就可以保证这棵树的正确性 任何人都可以只提供一个到特定节点的分支，并且通过密码学方法证明拥有对应内容的节点确实在树里 5.2 Trie树 Trie树也叫做Radix树 在Radic树中，key代表的是从树根到对应value的一条真实的路径 即从根节点开始，key中的每个字符（从前到后）都代表着从根节点触发寻找相应value所要经过的子节点 value储存在叶节点中，是每个路径的最终节点。 假如key中的每个字符都来自一个容量为N且包含的字母都互不相识的字母表，那么树中的每个节点最多会有N个孩子，树的最大深度便是Key的最大程度 优点如果有两个value,他们有着基于相同前缀的key，他们的相同前缀的长度占自身比例越大，则代表着两个value在树中的位置越靠近，并且Trie树中不会有像散列表一样的冲突，也就是说一个key只对应一个value,但是也存在着不平衡的 5.3 Merkle Patricia树 为了保证树的加密安全，每个节点通过他的散列值被引用，对于存储在LEVELDB数据库中的非叶节点，其中数据库中的表现形式：key代表着节点的RLP编码的SHA3散列值，value是节点的RLP编码。想要获得一个节点的内容，只需要根据该节点的散列值访问数据库以获得节点的RLP编码，然后解码即可。 在该方案中，根节点被称为整棵树的加密签名，如果一棵树给定Trie树的根散列值是公开的，那么所有人都可以提供一种证明，即通过提供每步向上的路径证明特定的key是否含有特定的值 引入很多节点类型来提供效率，MPT中节点包括以下4种： 空节点：简单的表示空，在代码中就是一个空串 叶节点：键值对的一个列表，其中key是一种特殊的十六进制编码，value是RLP编码 扩展节点：键值对的列表，但是这里的value是其他接待的散列值，通过这个散列值可以连接到其他节点 分支节点：一个节点为17的列表，MPT中的key被编码成一种特殊的十六进制的表示，再加上最后的value，前16个元素对应的key中的16个可能的十六进制字符，如果有一个键值对在这个分支节点终止，则最后一个元素代表一个值，即分支节点既然可以是搜索路径的终止，也可能是路径的中间节点 MPT还有一个重要的概念：用户对key进行编码的特殊十六进制前缀编码（HP），因为字母表中的字符都是十六进制表示的，所以每个节点最多只能由16个孩子，因为键值对有两个表示形式的节点，所以必须引用一中特殊的终止符表示，用来标示key所对应的值是真实的值还是其他节点的散列值。通过对终止符标识进行赋值，可以区分key所对应的节点的种类，无论key的长度是奇数还是偶数，HP都可以对其进行编码。 以太坊区块链系统中使用MPT树结构，但是每个以太坊区块头不是只包括一颗MPT树，而是为了三种对象设计了三棵树。 5.4 状态树 状态树中的每个节点16个孩子节点，每个叶节点表示一个账户，这些叶节点的父节点由叶节点的散列组成，而这些父节点再组成更高一层的父节点，直至到形成根节点。 状态树包含一个键值映射，其中键是账户地址，值是账户内容 {nonce,balance,codeahash,storageRoot} nonce是账户交易的序数 balance是账户余额 codeHash是代码的散列值 storageRoot是另一棵树的根节点 状态树代表访问区块后的整个状态 账户的状态不是直接存储在每个区块中，所有的账户状态都是以状态数据的形式存在以太坊的节点中 状态数据是一种隐式的数据，意味着他需要从实际的区块链数据中计算出来，交易包含决定新状态数据的所有字段内容。与比特币不同的是，以太坊区块包含了整个状态树的Merkle树根散列和交易列表 状态树是用来记录各个账户的状态的树，他需要经常更新 5.5 交易树 每个区块都有一棵独立的交易树。 区块中交易的顺序主要由矿工决定，在这个块被挖出来前这些数据都是未知的。不过矿工一般会根据交易的GasPrice和Nonce对交易进行排序。 首先会将交易列表中的交易划分到各个发送账户，每个账户的交易根据这些交易的nonce来排序，每个账户的交易排序完成后，再通过比较每个账户的第一条交易，选择最高价格的交易，这写是通过一个堆来实现的、 每挖出一个新块，更新一次交易树 在交易树包含的键值对中，其中每个键是交易的编号，值是交易内容 5.6 收据树 每个区块都有自己的收据树，收据树不需要更新 收据树代表每个交易相应的收据 收据树也包含了一个键值映射，其中键是索引编号，用来指引这个收据相关的交易的位置，值是收据的内容 交易的收据是一个RLP编码的数据结构[medstate,Gas_used,logbloom,logs]，其中 medstate是交易处理后树根的状态，Gas_used是交易处理后Gas的使用量，logs是表格元素的列表，表格有交易执行期间调用的操作码，address是生成日志的合约地址，topicn是最多4个32字节的值，data是任意字节大小的数据，logbllom是交易所有logs的布隆过滤器。 06.数据库支持-LevelDB LevelDB是谷歌实现的一个非常高效的键值对数据库，其中键值都是二进制，目前能够支持十亿级别的数据量。在这个数据量下还有这非常高的性能。 以太坊中共有三个LeveleDB数据库： BlockDB: 保存了块的主体内容，包括块头和交易 StateDB: 保存了账户的状态数据 ExtrasDB：ExtrasDB保存了收据信息和其他辅助信息 LevelDB的用户接口，put(k,v),get(k,v) delete(k,v) 特性： key和value都是任意长度的字节数组，一条记录（即一个键值对）默认是按照key的字典顺序存储，当然开发者也可以重载这个排序函数。 支持遍历，包括前向或者反向 支持原子写操作 支持过滤策略 支持数据自动压缩（snappy压缩算法） 底层提供了抽象接口，允许用户定制 限制： 不是sql类型数据库，没有关系模型 一个表只允许一个进程访问 单机系统没有服务器客户端 以太坊使用LevelDB主要考虑到他的写优化的特点 07.共识机制 共识机制是区块链事务达成分布式共识的算法 由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制 08.Pow PoW 即通过工作结果来证明你完成了相应的工作 PoW 是通过结果证明以确认你完成了 定量的工作 女巫攻击（ Sybil Attack ） 是指在对等网络中，单个节点具有多个身份标识，通过控制系统的大部分节点来削弱系统的安全性 散列函数的特征： - 免碰撞，即不存在输入值不同，经过散列变换，而散列值相同的情况 - 隐匿性，即给定 个散列值，想要反向逆推出输入值，在计算上是不可行的 - 不存在比穷举更好的方法，以使得散列值落在特定的范围 PoW 算法描述： 节点打包经过验证的交易通过不断地更换随机数来探寻合适的散列值（所谓合适的散列值是指该值小于系统提供的某散列值），当节点最先计算出合适的散列值，它所打包的块如果通过其他共识节点的验证，则会被加入到区块链中，这里争取记账权的节点被称为“矿工”。 这些“矿工”在以太坊网络中负责接收、转发、验证并执行交易。 在这个过程中要得到一个符合要求的散列值，节点需要经过大量的散列计算，计算时间则取决于机器的散列运算速度 由于寻找合适的散列值是 个概率事件，所以矿机性能越好，成功的概率就越大，当节点的算力占全网算力的 no/o 时，那么他就有 no/o 的概率找到合适的散列值 打个比方，所有的“矿工”都是登山者团队的首领，他们都拥有 个登山者团队，但是团队的人数有多有少（对应不同的“矿工”有不同的矿机资源） 为了获得奖励这些登山者首领都报名参加了 个登山比赛，山上有很多不同的道路，但是只有 条可以登上山顶，也只有第一个登上山顶的人所在的团队的首领能获得奖励 比赛开始，登山者首领让团队中每人选择一条道路开始登山，如果此路无法到达山顶，那么登山者会下来并重新选上山 最终，有一名登山者将成功登上山顶，他的首领（“矿工”）将会获得奖励 很明显，团队人手多且队员体能好的登山者首领更容易获得奖励，也就是说矿机性能越好，数量越多，那么“矿工”就越可能挖到新块 09.PoS PoS 即基于网络参与者目前所持有的数字货币的数量和时间进行利益分配，是 种对货币所有权的证明 PoS 可以被描述成虚拟挖矿， 般情况下与 PoW 一样， 用户所得利益与购买成本成比例，即买得越多，收获也就越大 在以太坊中， PoS 算法可以这样描述：以太坊区块链由一组验证者决定，任何持有以太币的用户都能发起一笔特殊形式交易，将他们的以太币锁定在一个存储中，从而使自己成为验证者，然后通过一个当前的验证者都能参与的共识算法，完成新区块的产生和验证过程 10.以太币 以太币（ ETH ）是以太坊发行的一种数字货币 以太币是以太网中一个重要元素，在公有链上发起任何一笔交易都需要支付一定的以太币 -以太币的总供给及其发行率是由 2014 年的预售决定的，以太币来源包括“矿前＋ 区块奖励＋叔区块奖励＋叔区块引用奖励”。 具体分配如下： 预付款的贡献者总共有 6000 万个以太币 每挖出 个新的区块，给挖出该区块的矿工奖励 5个以太币 如果一个矿工挖出一个新的区块，但是并不是在主链中，则该区块称为叔区块，如果该块在之后的区块链中作为叔区块被引用 每个叔区块会为挖矿者产出大约 4.375个以太币（ 个以太币奖励的 7/8 ），这被称为叔区块奖励 另外矿工每引用 个叔区块，可以得到大约 0.15 个以太币（最多引用两个叔区块） 当然以太币也不是无限生成的 最小的货币单位为 wei （维） 当一个矿工挖出一个新的区块，他就能获得笔奖励，这笔奖励由两部分构成，分为静态奖励和动态奖励 静态奖励是每挖出 个新块，矿工可以获得 个以太币作为奖励 动态奖励是矿工挖出的区块中包含的所有交易费用归矿工所有，另外如果这个区块有它的叔区块，还可以从每个叔区块引用中获得额外的挖矿奖励的 1/32 （大约 15 个以太币），当然每个区块最多引用 个叔区块，被引用过的叔区块不能重复利用 -叔区块是指该区块父块的父块的子块，同时又不是自己的父块，叔区块不在最长的那条区块链上，而是在分叉链上 这是由于网络延迟的原因使得挖出这个块的矿工没有同步到最新的区块 一个叔区块如果被引用在有效的区块链上，挖到该叔区块的矿 最多可以获得 4.375 个以太币作为奖励 这也保证了以太坊可以在很短的时间内产生新的区块（平均15s ），而不会因为网络同步延迟产生多个分叉 引用叔区块矿工的报酬 除了通过挖矿获取以太币，用户还可以购买以太币 11.交易 以太坊的交易主要是指 条外部账户发送到区块链上另 账户的消息的签名数据包，其主要包含发送者的签名、接收者的地址以及发送者转移给接收者的以太币数量等内容 以太坊上的每一笔交易都需要支付一定的费用，用于支付交易执行所需要的计算开销 计算开销的费用并不是以太币直接计算的，而是引人 Gas 作为执行开销的基本单位，通过GasPrice 与以太币进行换算的 GasPr ce 根据市场波动调整，避免以太币价值受市场价格的影响 12.交易费用 为了防止用户在区块链公有链中发送太多的无意义交易，浪费矿工的计算资源，例如转账金额为 的转账交易，所以各种公有链技术都采用了交易收费的策略，要求交易的发送方为每笔交易付出一定的代价 对于每一笔交易，交易的发送者都需要付出定的交易费；这笔费用会最终由将这个交易打包进主链的矿工收取 12.1. Gas Gas （汽油）是用来衡量一笔交易所消耗的计算资源的基本单位 当矿工收到一笔交易时，会根据交易的内容进行相应的操作 对于转账交易，矿工会根据转账的金额，对交易发送方和接收方的账户余额进行修改 对于创建和调用智能合约的交易，矿工会根据对应的字节码在 EVM 里执行对应的操作 当以太坊节点执行一笔交易所需的计算步骤越多、越复杂，那么就会说这笔交易消耗的 Gas 越多 12.2. Gas Price Gas Price ( Gas 价格）是 单位 Gas 所需的手续费（以太币，即 eth er ） 用户创建一个交易时，可以指定期望的任意 Gas Price ，甚至可以为0 因为矿 有选择收纳交易和收取费用的权利，他们都想使得收益最大化，所以如果大多数交易都以 Gwei 的价格提交，那么很难让矿工接收一个比这个价格低的交易 12.3. Gas Limit Gas 是衡量交易的计算开销的基本单位 以太坊的实际操作中，用户需要注意两个 Gas Limit ( Gas 限制）的概念： 对于单个交易， Gas Limit （有时也会称作 StartGas ）表示交易发送者愿意为这笔交易执行所支付的最大 Gas 数量，需要发送者在发送交易时设置；而对于区块来说， Gas Limit 是单个区块所允许包含的最大 Gas 总量 对于单个交易， Gas Limit 可以保护用户免受错误代码影响以致消耗过多的交易费 在某些场景下，交易发送者并不能提前准确预估出每笔交易将会消耗的 Gas ，例如某个调用智能合约的交易会根据不同的执行时间触发不同的操作 易设置了一个合理的 Gas Limit ，那么如果交易实际消耗的 Gas (Gas Used ）小于 Gas Limit, 那么执行的矿工只会收取实际计算开销（ Gas Used ）对应的交易手续费（ Gas Used * Gas Price ）；而如果 Gas Used 小于 Gas Limit ，那么矿工执行过程中会发现 Gas 已被耗尽而交易没有执行完成，此时矿工会回滚到程序执行前的状态 GasPrice * Gas Limit 表示用户愿意为一笔交易支的最高金额 如果交易没有 Gas Limit 限制，那么某些恶意用户可能会发送一个数十亿步骤的交易，并且没有人能够处理它，因为处理这个交易甚至需要花费比出块间隔更长的时间，然而矿工事前并不知道，所以会导致拒绝服务式攻击 区块的 Gas Limit 表示一个区块所包含的所有交易消耗的 Gas 的上限，由矿工决定它的大小 这完全取决于矿 的意愿 总之，被打包交易的Gas Limit 数量之和不能超过区块的 Gas Limit 区块的 Gas Limit 设置得越大，那么矿工就可以获取越多的交易费，但是需要更多的带宽，同时会加大叔区块出现的频率，造成挖出的区块无法形成最长的交易链 矿工也不能任意地更改区块的 Gas Limit ，根据以太坊协议，当前区块的 Gas Limit 只能基于上个区块的 Gas Limit 上下波动 1/1024 12.交易内容 以太坊中的交易（ Transaction ）是指存储一条从外部账户发送到区块链上另－个账户的消息的签名数据包，它既可以是简单的数字货币一一以太币的转账，也可以是包含智能合约代码的消息 一条交易包含以下内容： from ：交易发送者的地址，必填； to ：交易接收者的地址，如果为空则意味这是一个创建智能合约的交易； value ：发送者要转移给接收者的以太币数量； data （也写作 input ）：存在的数据字段，如果存在，则是表明该交易是 个创建或者调用智能合约交易； Gas Limit （也写作 Gas, StartGas ）：表示这个交易允许消耗的最大 Gas 数量； GasPrice ：表示发送者愿意支付给矿工的 Gas 价格； nonce ：用来区别同一用户发出的不同交易的标记； hash ：由以上信息生成的散列值（哈希值），作为交易的 ID; r,s,v :：交易签名的三个部分，由发送者的私钥对交易 hash 进行签名生成 在不同的场景下，交易有三种类型 转账交易： 转账是最简单的一种交易，从一个账户向另 个账户发送以太币，发送转账交易时只需要指定交易的发送者、接收者、转移的以太币数量即可（在客户端发送交易时， Gas Limit Gas Price nonce hash 、签名可以按照默认方式生成） ）创建智能合约的交易:：创建合约是指将合约部署到区块链上，这也是通过发送交易来实现的。在创建合约的交易中，to字段是一个空字符串，在data字段中指定初始化合约的二进制，在之后合约被调用时，该代码的执行结果将作为合约代码。 执行智能合约的交易：：顾名思义，该交易是为了执行已经部署在区块链上的智能合约，在该交易中，需要将“ 。”字段指定为要调用的智能合约的地址，通过“ data ，，字段指定要调用的方法以及向该方法传递参数 13.数据编码与压缩 RLP ( Recursive Length Prefix ）是一种编码算法，，用于编码任意的具有嵌套结构的二进制数据，是以太坊数据序列化的主要方法 以太坊中的区块 、交易等数据结构会先经过RLP 编码处理，然后再存储到数据库中 RLP 编码只处理两种类型的数据，即字符串和列表 得注意的是，其中并不包括原子数据类型， 如整型、浮点型 一 是按照字典顺序用含关键字的二维数组，另一种是使用更高级 Patricia 树来编码 在以太坊中，当发送数据以及在 MPT 树中保存状态时， 需要使用 RLP 编码 14.以大坊客户端和 API Web3.js API 作为先进共有链的代表之一，及以太坊区块链本质是一串连接的数据区块，区块之间使用密码学算法生成的散列指针连接。 对以太坊的区块，交易，账户等基本组成由一定了解，以太坊的数据结构和存储支持，以便读者对其底层结构有所了解。 以太坊入口 - 客户端和以太坊域名服务，让用户能够了解以太坊的顶层应用 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/10/21/8a13d3a1ae77a86c3e531a1068291b77.html","headline":"02.以太坊架构和组成","dateModified":"2018-10-21T00:00:00+08:00","datePublished":"2018-10-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/10/21/8a13d3a1ae77a86c3e531a1068291b77.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>02.以太坊架构和组成</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：忠于祖国，忠于人民 https://blog.csdn.net/boss2967/article/details/83244455 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h3><a id="01_0"></a>01.以太坊整体架构</h3> 
  <p>以太坊是一个区块链应用平台。</p> 
  <p>分为三层：</p> 
  <ul> 
   <li>底层服务</li> 
   <li>核心层</li> 
   <li>顶层应用</li> 
  </ul> 
  <h3><a id="02_9"></a>02.区块</h3> 
  <ul> 
   <li> <p><strong>区块链是比特币使用的底层技术架构</strong>。</p> </li> 
   <li> <p>他本身是一串连续的数据区块，区块之间的连接指针是区块头散列指针，他们是使用密码学散列算法生成的。</p> </li> 
   <li> <p>区块本质上就是一个数据包，比特币的交易记录会保存在区块中，大约每10分钟生成一个新的区块。</p> </li> 
   <li> <p>所谓区块：可以定义为记录一段时间内发生的交易和状态的结果的数据结构。是对当前账本状态的一次共识。</p> </li> 
   <li> <p>比特币的每个数据区块一般包含区块头（Header）和区块体（Body）两部分。</p> 
    <ul> 
     <li>区块头封装了前一个区块的散列值（Prev_Hash），时间戳（Timestamp）,随机数（Nonce）,Merkle树的根值（Tx_Root）和当前区块的散列值等信息。</li> 
     <li>区块体中则主要包含交易技术和交易详情。<br> -<img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181021181734320?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></li> 
    </ul> </li> 
   <li> <p>每笔交易都被永久的记录在区块中，任何人都可以查询。交易是通过Merkle树的数据结果记录的。其中没仪表交易都包含了数字签名，如此可以保证每一笔交易都不伪造，不能篡改。所有的交易过程都将通过Merkle树的hash过程生成一个唯一的Tx-Root记录到区块中。</p> </li> 
   <li> <p>用户在验证区块的有效性时，只需根据Merkle树的Hash方法计算出根值并且与区块中Tx_Root进行比较，即可验证真伪，若相同及有效，若不同则无效。</p> </li> 
  </ul> 
  <h3><a id="03__24"></a>03.区块 ——以太坊</h3> 
  <ul> 
   <li> <p>去开主要由区块头，交易列表，和叔区块三部分组成。</p> 
    <ul> 
     <li>区块头： 
      <ul> 
       <li>父块的散列值（PrevHash）</li> 
       <li>叔区块的散列值（Uncles Hash）</li> 
       <li>状态树根散列值（stateRoot）</li> 
       <li>交易树根散列值（Transaction Root）</li> 
       <li>收据树根散列值（Receipt Root）</li> 
       <li>时间戳（Timestamp）</li> 
       <li>随机数（Nonce）</li> 
      </ul> </li> 
     <li>以太坊区块链上区块数据结构的一个重要改变就是保存了三棵Merkle树根 
      <ul> 
       <li>状态树</li> 
       <li>交易树</li> 
       <li>收据树</li> 
      </ul> </li> 
    </ul> </li> 
   <li> <p>存储三棵树可以方便账户做更多查询</p> </li> 
   <li> <p>交易列表是由矿工从交易池选择收入区块中的一系列交易</p> </li> 
   <li> <p>区块链上的第一个区块称为“创世区块”</p> </li> 
   <li> <p>区块链上除了创世区块意外每个区块都有他的父区块，这些区块连接起来组成一个区块链</p> </li> 
   <li> <p>以太坊大约每15s可以挖出一个新的区块</p> </li> 
   <li> <p>以太坊区块结构中状态树的更新</p> 
    <ul> 
     <li><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181021183832441?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></li> 
    </ul> </li> 
  </ul> 
  <h3><a id="04_47"></a>04.账户</h3> 
  <ul> 
   <li>账户以地址为索引，地址由公钥衍生而来，取公钥的最后20字节</li> 
   <li>两种类型的账户 
    <ul> 
     <li>外部账户 
      <ul> 
       <li>简称账户，他们都是由人创建，可以储存以太币</li> 
      </ul> </li> 
     <li>合约账户 
      <ul> 
       <li>合约账户是由外部账户创建的账户</li> 
      </ul> </li> 
     <li>以太坊中这两中账户统称为“状态对象”（存储状态）</li> 
     <li>外部账户储存以太币余额状态</li> 
     <li>合约庄户除了余额还有智能合约以及其变量的状态<br> 通过交易的执行，这行状态对象发生变化，而Merkle树用户索引和状态对象的更新。</li> 
    </ul> </li> 
  </ul> 
  <p>一个以太坊的账户包含四个部分</p> 
  <ul> 
   <li>该地址交易的次数，他是用于保障被一笔交易能且被处理一次的计数器，有效避免重放攻击</li> 
   <li>账户目前的以太币余额</li> 
   <li>账户的合约二进制代码（合约账户）</li> 
   <li>账户的储存（默认为空）</li> 
  </ul> 
  <h4><a id="41__65"></a>4.1 外部账户</h4> 
  <ul> 
   <li>外部账户（EOA）由私钥来控制，是由用户实际控制的账户</li> 
   <li>每个外部账户拥有一对公私钥，这对密钥用于签署交易，他的地址由公钥决定。</li> 
   <li>外部账户不能包含以太坊虚拟机（EVM）代码</li> 
  </ul> 
  <p>我们可以做一个简单的对比，把外部账户看做用户在某个银行办理的一个账户，公钥就是用户为该账户设置的卡号，而私钥则是用户设置的密码。<br> 一个外部账户具有以下特性：</p> 
  <ul> 
   <li> <p>拥有一定的账户余额</p> </li> 
   <li> <p>可以发送交易</p> </li> 
   <li> <p>通过私钥控制</p> </li> 
   <li> <p>以及没有相关的代码</p> </li> 
   <li> <p>用户在创建好战鼓后一定要记住私钥！如果用户忘记了，那你就滚吧。不可能不滚的。</p> </li> 
   <li> <p>秘钥通常保存在keystore目录下， 用户可以经常性的备份密钥文件，以防止忘记或者丢失</p> </li> 
   <li> <p>在以太坊节点之间传递整个目录后者密钥文件是安全的。但是账户的顺序可能会发生比改变。</p> </li> 
   <li> <p>用户需确保不要依赖或者更改脚本和代码段中的索引。用户自己列出自己创建的账户时，账户汇按字典排序，并且按照账户的创建时间先后排序</p> </li> 
  </ul> 
  <h4><a id="42__83"></a>4.2 合约账户</h4> 
  <ul> 
   <li>合约账户是一个包含合约代码的账户</li> 
   <li>合约账户不是由私钥文件直接控制，而是由合约代码控制的</li> 
   <li>合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出</li> 
   <li>一个合约账户具有下列特性： 
    <ul> 
     <li>拥有一定的以太币余额</li> 
     <li>有相关联的代码</li> 
     <li>代码通过交易或者其他合约发送的调用来激活。</li> 
    </ul> </li> 
   <li>当合约被执行时候，智能操作合约庄户拥有的特定储存。</li> 
   <li>合约账户和普通账户最大的不同就是他还存有智能合约</li> 
   <li>以太坊区块链上的所有操作都是根据都是根据从账户发出的交易来执行的。</li> 
   <li>每当合约账户收到一条交易消息时，其他合约代码将被交易输入的参数调用执行。</li> 
   <li>而合约代码将会在参与到网络中的每一个节点上执行，并将执行结果作为新区块验证的一部分</li> 
  </ul> 
  <h4><a id="43__98"></a>4.3 私钥和公钥</h4> 
  <ul> 
   <li>公钥加密</li> 
  </ul> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181021193741142?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br> -公钥认证<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181021193810646?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br> 私钥的三种形态：</p> 
  <ul> 
   <li>Private key就是一份随机生成的256位二进制数字，该256位二进制数字就是私钥最初始的状态</li> 
   <li>而2以太坊钱包中，私钥和公钥将会以加密的方式保存一份JSON文件，存在keystore子目录下，这份JSON文件就是Keystore,所以用户需要同时备份Keystore和对应的Password</li> 
   <li>最后一种Memonic code是由BIP39方案，随机生成12-24个容易几乎记住的单词，随机种子，通过提案的方式生成确定性钱包</li> 
  </ul> 
  <h4><a id="44__109"></a>4.4 钱包</h4> 
  <p>钱包就是一个比较形象的概念，一个外部账户通常由私钥文件来控制，拥有私钥的而用户就可以拥有对应地址的账户里的以太币使用权。<br> 我们通常把管理这些数字密钥的软件成为钱包，而我们所所的备份钱包其实就是备份账户的私钥文件</p> 
  <p>-以太币钱包分类</p> 
  <ul> 
   <li> <p>Mist钱包</p> </li> 
   <li> <p>Parity钱包</p> </li> 
   <li> <p>Etherwall钱包</p> </li> 
   <li> <p>Brain钱包</p> </li> 
   <li> <p>钱包备份</p> 
    <ul> 
     <li>防盗：分离备份</li> 
     <li>防丢：多处本分</li> 
     <li>分散风向：将资金适当的分散开</li> 
    </ul> </li> 
   <li> <p>常见的钱包备份方式：</p> 
    <ul> 
     <li>多处和分离备份</li> 
     <li>纸钱包<br> 预防方案：用户可以痛死使用多重签名和多处分离备份，设定一个金额阈值，当用户提取超过该阈值的金额时需要多个私钥，另外把这些私钥多处分离备份，大大降低了资金被盗的风险</li> 
    </ul> </li> 
  </ul> 
  <h3><a id="05_128"></a>05.数据结构与储存</h3> 
  <ul> 
   <li>包括以太坊和比特币在内的大多是都是区块链项目，会使用Merkle树或者基于Merkle树的数据结构，比特币- 中保存了一颗Merkle树，而以太坊针对对象设计了三棵Merkle树，分别是状态树，交易树和收据叔，这三种树可以帮助以太坊客户端做一些简易的查询，查询某个账户的余额，某笔交易是否被包含在区块中。</li> 
   <li>区块，交易等数据最终都是存在LevelDB数据库中，LevelDB数据库是一个键值对数据库，key一般与散列相关，value则是存在储存内容的RLP编码</li> 
  </ul> 
  <h4><a id="51__132"></a>5.1 数据组织形式</h4> 
  <ul> 
   <li>以太坊使用Merkle Patricia树，（MPT）,作为数据组织形式，用来组织管理用户的账户状态，交易信息等重要数据。</li> 
   <li>MPT是一种加密认证的数据结构，他融合了Merkle树和Tire树（前缀树）两种数据类型的优点 
    <ul> 
     <li>Merkle树 
      <ul> 
       <li> <p>Merkle树是一种树行数据结构，可以是二叉树，也可以是多叉树</p> </li> 
       <li> <p>由一组叶节点，一组中间节点和一个根节点构成</p> </li> 
       <li> <p>最下面的叶节点包含基础数据，每个中间节点是他的子节点的散列，根节点是他的子节点的散列，代表了Merkle树的根部。</p> </li> 
       <li> <p>创建Merkle树的目的是语序区块的数据可以零散的传送</p> </li> 
       <li> <p>节点可以从一个节点下载区块头，从另外的源下载与其相关的树的其他部分，而依然能够确认所有的数据都是正确的。之所以如此是因为散列向上扩散，如果一个恶意用户尝试在树的下部加入一个伪造的交易，所引起的改动将导致树上的上层节点以及更上层节点的改动，最终导致根节点的改动以及区块散列的改动，这样协议就会将其记录为一个完全不同的区块（几乎可以坑定带着不确定的工作量证明）</p> </li> 
       <li> <p>如果底层的交易被篡改了，那么其对应的叶节点散列值也会改变，这件最终导致其Merkle树根值变化</p> </li> 
       <li> <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181021203552734?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> </li> 
       <li> <p>Merkle树可以用来储存所有键值对</p> 
        <ul> 
         <li>这颗树的建立从每个节点开始，将节点两两分成多达16个组，并对每个组求散列值，接着对散列结果继续求散列值，如此递归下去，知道整颗树有一个最后的根散列值。</li> 
        </ul> </li> 
       <li> <p>Merkle树具有下列特性</p> 
        <ul> 
         <li>每个数据集对应一个唯一合法的根散列值</li> 
         <li>很不容易更新，添加， 或者删除树节点，以及生成新的根散列值</li> 
         <li>不改变根散列值的话就没有办法修改树的任何部分，所以如果跟散列值被包括在签名的文档或者有效区块中，就可以保证这棵树的正确性</li> 
         <li>任何人都可以只提供一个到特定节点的分支，并且通过密码学方法证明拥有对应内容的节点确实在树里</li> 
        </ul> </li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
  <h4><a id="52_Trie_153"></a>5.2 Trie树</h4> 
  <ul> 
   <li>Trie树也叫做Radix树</li> 
   <li>在Radic树中，key代表的是从树根到对应value的一条真实的路径</li> 
   <li>即从根节点开始，key中的每个字符（从前到后）都代表着从根节点触发寻找相应value所要经过的子节点</li> 
   <li>value储存在叶节点中，是每个路径的最终节点。</li> 
   <li>假如key中的每个字符都来自一个容量为N且包含的字母都互不相识的字母表，那么树中的每个节点最多会有N个孩子，树的最大深度便是Key的最大程度</li> 
   <li>优点如果有两个value,他们有着基于相同前缀的key，他们的相同前缀的长度占自身比例越大，则代表着两个value在树中的位置越靠近，并且Trie树中不会有像散列表一样的冲突，也就是说一个key只对应一个value,但是也存在着不平衡的</li> 
  </ul> 
  <h4><a id="53_Merkle_Patricia_161"></a>5.3 Merkle Patricia树</h4> 
  <ul> 
   <li>为了保证树的加密安全，每个节点通过他的散列值被引用，对于存储在LEVELDB数据库中的非叶节点，其中数据库中的表现形式：key代表着节点的RLP编码的SHA3散列值，value是节点的RLP编码。想要获得一个节点的内容，只需要根据该节点的散列值访问数据库以获得节点的RLP编码，然后解码即可。</li> 
   <li>在该方案中，根节点被称为整棵树的加密签名，如果一棵树给定Trie树的根散列值是公开的，那么所有人都可以提供一种证明，即通过提供每步向上的路径证明特定的key是否含有特定的值</li> 
   <li>引入很多节点类型来提供效率，MPT中节点包括以下4种： 
    <ul> 
     <li>空节点：简单的表示空，在代码中就是一个空串</li> 
     <li>叶节点：键值对的一个列表，其中key是一种特殊的十六进制编码，value是RLP编码</li> 
     <li>扩展节点：键值对的列表，但是这里的value是其他接待的散列值，通过这个散列值可以连接到其他节点</li> 
     <li>分支节点：一个节点为17的列表，MPT中的key被编码成一种特殊的十六进制的表示，再加上最后的value，前16个元素对应的key中的16个可能的十六进制字符，如果有一个键值对在这个分支节点终止，则最后一个元素代表一个值，即分支节点既然可以是搜索路径的终止，也可能是路径的中间节点</li> 
    </ul> </li> 
  </ul> 
  <p>MPT还有一个重要的概念：用户对key进行编码的特殊十六进制前缀编码（HP），因为字母表中的字符都是十六进制表示的，所以每个节点最多只能由16个孩子，因为键值对有两个表示形式的节点，所以必须引用一中特殊的终止符表示，用来标示key所对应的值是真实的值还是其他节点的散列值。通过对终止符标识进行赋值，可以区分key所对应的节点的种类，无论key的长度是奇数还是偶数，HP都可以对其进行编码。<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181021212014628?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p>以太坊区块链系统中使用MPT树结构，但是每个以太坊区块头不是只包括一颗MPT树，而是为了三种对象设计了三棵树。<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181021212209756?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <h4><a id="54__176"></a>5.4 状态树</h4> 
  <ul> 
   <li>状态树中的每个节点16个孩子节点，每个叶节点表示一个账户，这些叶节点的父节点由叶节点的散列组成，而这些父节点再组成更高一层的父节点，直至到形成根节点。</li> 
   <li>状态树包含一个键值映射，其中键是账户地址，值是账户内容 {nonce,balance,codeahash,storageRoot} 
    <ul> 
     <li>nonce是账户交易的序数</li> 
     <li>balance是账户余额</li> 
     <li>codeHash是代码的散列值</li> 
     <li>storageRoot是另一棵树的根节点</li> 
    </ul> </li> 
   <li>状态树代表访问区块后的整个状态</li> 
   <li>账户的状态不是直接存储在每个区块中，所有的账户状态都是以状态数据的形式存在以太坊的节点中</li> 
   <li>状态数据是一种隐式的数据，意味着他需要从实际的区块链数据中计算出来，交易包含决定新状态数据的所有字段内容。与比特币不同的是，以太坊区块包含了整个状态树的Merkle树根散列和交易列表</li> 
   <li>状态树是用来记录各个账户的状态的树，他需要经常更新</li> 
  </ul> 
  <h4><a id="55__187"></a>5.5 交易树</h4> 
  <ul> 
   <li>每个区块都有一棵独立的交易树。</li> 
   <li>区块中交易的顺序主要由矿工决定，在这个块被挖出来前这些数据都是未知的。不过矿工一般会根据交易的GasPrice和Nonce对交易进行排序。</li> 
   <li>首先会将交易列表中的交易划分到各个发送账户，每个账户的交易根据这些交易的nonce来排序，每个账户的交易排序完成后，再通过比较每个账户的第一条交易，选择最高价格的交易，这写是通过一个堆来实现的、</li> 
   <li>每挖出一个新块，更新一次交易树</li> 
   <li>在交易树包含的键值对中，其中每个键是交易的编号，值是交易内容</li> 
  </ul> 
  <h4><a id="56__193"></a>5.6 收据树</h4> 
  <ul> 
   <li>每个区块都有自己的收据树，收据树不需要更新</li> 
   <li>收据树代表每个交易相应的收据</li> 
   <li>收据树也包含了一个键值映射，其中键是索引编号，用来指引这个收据相关的交易的位置，值是收据的内容</li> 
   <li>交易的收据是一个RLP编码的数据结构[medstate,Gas_used,logbloom,logs]，其中 medstate是交易处理后树根的状态，Gas_used是交易处理后Gas的使用量，logs是表格元素的列表，表格有交易执行期间调用的操作码，address是生成日志的合约地址，topicn是最多4个32字节的值，data是任意字节大小的数据，logbllom是交易所有logs的布隆过滤器。</li> 
  </ul> 
  <h3><a id="06LevelDB_199"></a>06.数据库支持-LevelDB</h3> 
  <p>LevelDB是谷歌实现的一个非常高效的键值对数据库，其中键值都是二进制，目前能够支持十亿级别的数据量。在这个数据量下还有这非常高的性能。<br> 以太坊中共有三个LeveleDB数据库：</p> 
  <ul> 
   <li>BlockDB: 保存了块的主体内容，包括块头和交易</li> 
   <li>StateDB: 保存了账户的状态数据</li> 
   <li>ExtrasDB：ExtrasDB保存了收据信息和其他辅助信息<br> LevelDB的用户接口，put(k,v),get(k,v) delete(k,v)<br> 特性：</li> 
   <li>key和value都是任意长度的字节数组，一条记录（即一个键值对）默认是按照key的字典顺序存储，当然开发者也可以重载这个排序函数。</li> 
   <li>支持遍历，包括前向或者反向</li> 
   <li>支持原子写操作</li> 
   <li>支持过滤策略</li> 
   <li>支持数据自动压缩（snappy压缩算法）</li> 
   <li>底层提供了抽象接口，允许用户定制</li> 
  </ul> 
  <p>限制：</p> 
  <ul> 
   <li>不是sql类型数据库，没有关系模型</li> 
   <li>一个表只允许一个进程访问</li> 
   <li>单机系统没有服务器客户端<br> 以太坊使用LevelDB主要考虑到他的写优化的特点</li> 
  </ul> 
  <h3><a id="07_222"></a>07.共识机制</h3> 
  <ul> 
   <li>共识机制是区块链事务达成分布式共识的算法</li> 
   <li>由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制</li> 
  </ul> 
  <h3><a id="08Pow_227"></a>08.Pow</h3> 
  <ul> 
   <li>PoW 即通过工作结果来证明你完成了相应的工作</li> 
   <li>PoW 是通过结果证明以确认你完成了 定量的工作</li> 
   <li>女巫攻击（ Sybil Attack ） 
    <ul> 
     <li>是指在对等网络中，单个节点具有多个身份标识，通过控制系统的大部分节点来削弱系统的安全性</li> 
     <li><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023100839309?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></li> 
    </ul> </li> 
  </ul> 
  <p>散列函数的特征：<br> - 免碰撞，即不存在输入值不同，经过散列变换，而散列值相同的情况<br> - 隐匿性，即给定 个散列值，想要反向逆推出输入值，在计算上是不可行的<br> - 不存在比穷举更好的方法，以使得散列值落在特定的范围</p> 
  <p>PoW 算法描述：<br> 节点打包经过验证的交易通过不断地更换随机数来探寻合适的散列值（所谓合适的散列值是指该值小于系统提供的某散列值），当节点最先计算出合适的散列值，它所打包的块如果通过其他共识节点的验证，则会被加入到区块链中，这里争取记账权的节点被称为“矿工”。</p> 
  <ul> 
   <li>这些“矿工”在以太坊网络中负责接收、转发、验证并执行交易。<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023101158229?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></li> 
  </ul> 
  <p>在这个过程中要得到一个符合要求的散列值，节点需要经过大量的散列计算，计算时间则取决于机器的散列运算速度 由于寻找合适的散列值是 个概率事件，所以矿机性能越好，成功的概率就越大，当节点的算力占全网算力的 no/o 时，那么他就有 no/o 的概率找到合适的散列值</p> 
  <p>打个比方，所有的“矿工”都是登山者团队的首领，他们都拥有 个登山者团队，但是团队的人数有多有少（对应不同的“矿工”有不同的矿机资源） 为了获得奖励这些登山者首领都报名参加了 个登山比赛，山上有很多不同的道路，但是只有 条可以登上山顶，也只有第一个登上山顶的人所在的团队的首领能获得奖励 比赛开始，登山者首领让团队中每人选择一条道路开始登山，如果此路无法到达山顶，那么登山者会下来并重新选上山 最终，有一名登山者将成功登上山顶，他的首领（“矿工”）将会获得奖励 很明显，团队人手多且队员体能好的登山者首领更容易获得奖励，也就是说矿机性能越好，数量越多，那么“矿工”就越可能挖到新块</p> 
  <h3><a id="09PoS_248"></a>09.PoS</h3> 
  <ul> 
   <li>PoS 即基于网络参与者目前所持有的数字货币的数量和时间进行利益分配，是 种对货币所有权的证明</li> 
   <li>PoS 可以被描述成虚拟挖矿， 般情况下与 PoW 一样， 用户所得利益与购买成本成比例，即买得越多，收获也就越大</li> 
   <li>在以太坊中， PoS 算法可以这样描述：以太坊区块链由一组验证者决定，任何持有以太币的用户都能发起一笔特殊形式交易，将他们的以太币锁定在一个存储中，从而使自己成为验证者，然后通过一个当前的验证者都能参与的共识算法，完成新区块的产生和验证过程</li> 
   <li></li> 
  </ul> 
  <h3><a id="10_255"></a>10.以太币</h3> 
  <ul> 
   <li> <p>以太币（ ETH ）是以太坊发行的一种数字货币</p> </li> 
   <li> <p>以太币是以太网中一个重要元素，在公有链上发起任何一笔交易都需要支付一定的以太币<br> -以太币的总供给及其发行率是由 2014 年的预售决定的，以太币来源包括“矿前＋ 区块奖励＋叔区块奖励＋叔区块引用奖励”。</p> </li> 
   <li> <p>具体分配如下：</p> 
    <ul> 
     <li>预付款的贡献者总共有 6000 万个以太币</li> 
     <li>每挖出 个新的区块，给挖出该区块的矿工奖励 5个以太币</li> 
     <li>如果一个矿工挖出一个新的区块，但是并不是在主链中，则该区块称为叔区块，如果该块在之后的区块链中作为叔区块被引用 每个叔区块会为挖矿者产出大约 4.375个以太币（ 个以太币奖励的 7/8 ），这被称为叔区块奖励 另外矿工每引用 个叔区块，可以得到大约 0.15 个以太币（最多引用两个叔区块）</li> 
    </ul> </li> 
   <li> <p>当然以太币也不是无限生成的 最小的货币单位为 wei （维）</p> </li> 
   <li> <p>当一个矿工挖出一个新的区块，他就能获得笔奖励，这笔奖励由两部分构成，分为静态奖励和动态奖励</p> 
    <ul> 
     <li>静态奖励是每挖出 个新块，矿工可以获得 个以太币作为奖励</li> 
     <li>动态奖励是矿工挖出的区块中包含的所有交易费用归矿工所有，另外如果这个区块有它的叔区块，还可以从每个叔区块引用中获得额外的挖矿奖励的 1/32 （大约 15 个以太币），当然每个区块最多引用 个叔区块，被引用过的叔区块不能重复利用</li> 
     <li><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023102015411?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></li> 
    </ul> </li> 
  </ul> 
  <p>-叔区块是指该区块父块的父块的子块，同时又不是自己的父块，叔区块不在最长的那条区块链上，而是在分叉链上 这是由于网络延迟的原因使得挖出这个块的矿工没有同步到最新的区块 一个叔区块如果被引用在有效的区块链上，挖到该叔区块的矿 最多可以获得 4.375 个以太币作为奖励 这也保证了以太坊可以在很短的时间内产生新的区块（平均15s ），而不会因为网络同步延迟产生多个分叉</p> 
  <ul> 
   <li> <p>引用叔区块矿工的报酬<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023102228674?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> </li> 
   <li> <p>除了通过挖矿获取以太币，用户还可以购买以太币</p> </li> 
  </ul> 
  <h3><a id="11_278"></a>11.交易</h3> 
  <ul> 
   <li>以太坊的交易主要是指 条外部账户发送到区块链上另 账户的消息的签名数据包，其主要包含发送者的签名、接收者的地址以及发送者转移给接收者的以太币数量等内容</li> 
   <li>以太坊上的每一笔交易都需要支付一定的费用，用于支付交易执行所需要的计算开销</li> 
   <li>计算开销的费用并不是以太币直接计算的，而是引人 Gas 作为执行开销的基本单位，通过GasPrice 与以太币进行换算的</li> 
   <li>GasPr ce 根据市场波动调整，避免以太币价值受市场价格的影响</li> 
  </ul> 
  <h3><a id="12_285"></a>12.交易费用</h3> 
  <ul> 
   <li>为了防止用户在区块链公有链中发送太多的无意义交易，浪费矿工的计算资源，例如转账金额为 的转账交易，所以各种公有链技术都采用了交易收费的策略，要求交易的发送方为每笔交易付出一定的代价</li> 
   <li>对于每一笔交易，交易的发送者都需要付出定的交易费；这笔费用会最终由将这个交易打包进主链的矿工收取</li> 
  </ul> 
  <h4><a id="121_Gas_289"></a>12.1. Gas</h4> 
  <ul> 
   <li>Gas （汽油）是用来衡量一笔交易所消耗的计算资源的基本单位</li> 
   <li>当矿工收到一笔交易时，会根据交易的内容进行相应的操作</li> 
   <li>对于转账交易，矿工会根据转账的金额，对交易发送方和接收方的账户余额进行修改</li> 
   <li>对于创建和调用智能合约的交易，矿工会根据对应的字节码在 EVM 里执行对应的操作</li> 
   <li>当以太坊节点执行一笔交易所需的计算步骤越多、越复杂，那么就会说这笔交易消耗的 Gas 越多</li> 
  </ul> 
  <h4><a id="122_Gas_Price_295"></a>12.2. Gas Price</h4> 
  <p>Gas Price ( Gas 价格）是 单位 Gas 所需的手续费（以太币，即 eth er ）<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023105426409?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <ul> 
   <li>用户创建一个交易时，可以指定期望的任意 Gas Price ，甚至可以为0</li> 
   <li>因为矿 有选择收纳交易和收取费用的权利，他们都想使得收益最大化，所以如果大多数交易都以 Gwei 的价格提交，那么很难让矿工接收一个比这个价格低的交易</li> 
  </ul> 
  <h4><a id="123_Gas_Limit_300"></a>12.3. Gas Limit</h4> 
  <ul> 
   <li>Gas 是衡量交易的计算开销的基本单位</li> 
   <li>以太坊的实际操作中，用户需要注意两个 Gas Limit ( Gas 限制）的概念：</li> 
   <li>对于单个交易， Gas Limit （有时也会称作 StartGas ）表示交易发送者愿意为这笔交易执行所支付的最大 Gas 数量，需要发送者在发送交易时设置；而对于区块来说， Gas Limit 是单个区块所允许包含的最大 Gas 总量</li> 
   <li>对于单个交易， Gas Limit 可以保护用户免受错误代码影响以致消耗过多的交易费</li> 
   <li>在某些场景下，交易发送者并不能提前准确预估出每笔交易将会消耗的 Gas ，例如某个调用智能合约的交易会根据不同的执行时间触发不同的操作</li> 
   <li>易设置了一个合理的 Gas Limit ，那么如果交易实际消耗的 Gas (Gas Used ）小于 Gas Limit, 那么执行的矿工只会收取实际计算开销（ Gas Used ）对应的交易手续费（ Gas Used * Gas Price ）；而如果 Gas Used 小于 Gas Limit ，那么矿工执行过程中会发现 Gas 已被耗尽而交易没有执行完成，此时矿工会回滚到程序执行前的状态</li> 
   <li>GasPrice * Gas Limit 表示用户愿意为一笔交易支的最高金额 如果交易没有 Gas Limit 限制，那么某些恶意用户可能会发送一个数十亿步骤的交易，并且没有人能够处理它，因为处理这个交易甚至需要花费比出块间隔更长的时间，然而矿工事前并不知道，所以会导致拒绝服务式攻击</li> 
   <li>区块的 Gas Limit 表示一个区块所包含的所有交易消耗的 Gas 的上限，由矿工决定它的大小</li> 
   <li>这完全取决于矿 的意愿 总之，被打包交易的Gas Limit 数量之和不能超过区块的 Gas Limit</li> 
   <li>区块的 Gas Limit 设置得越大，那么矿工就可以获取越多的交易费，但是需要更多的带宽，同时会加大叔区块出现的频率，造成挖出的区块无法形成最长的交易链</li> 
   <li>矿工也不能任意地更改区块的 Gas Limit ，根据以太坊协议，当前区块的 Gas Limit 只能基于上个区块的 Gas Limit 上下波动 1/1024</li> 
  </ul> 
  <h3><a id="12_312"></a>12.交易内容</h3> 
  <ul> 
   <li> <p>以太坊中的交易（ Transaction ）是指存储一条从外部账户发送到区块链上另－个账户的消息的签名数据包，它既可以是简单的数字货币一一以太币的转账，也可以是包含智能合约代码的消息</p> </li> 
   <li> <p>一条交易包含以下内容：</p> 
    <ul> 
     <li>from ：交易发送者的地址，必填；</li> 
     <li>to ：交易接收者的地址，如果为空则意味这是一个创建智能合约的交易；</li> 
     <li>value ：发送者要转移给接收者的以太币数量；</li> 
     <li>data （也写作 input ）：存在的数据字段，如果存在，则是表明该交易是 个创建或者调用智能合约交易；</li> 
     <li>Gas Limit （也写作 Gas, StartGas ）：表示这个交易允许消耗的最大 Gas 数量；</li> 
     <li>GasPrice ：表示发送者愿意支付给矿工的 Gas 价格；</li> 
     <li>nonce ：用来区别同一用户发出的不同交易的标记；</li> 
     <li>hash ：由以上信息生成的散列值（哈希值），作为交易的 ID;</li> 
     <li>r,s,v :：交易签名的三个部分，由发送者的私钥对交易 hash 进行签名生成</li> 
    </ul> </li> 
  </ul> 
  <p>在不同的场景下，交易有三种类型</p> 
  <ol> 
   <li>转账交易： 转账是最简单的一种交易，从一个账户向另 个账户发送以太币，发送转账交易时只需要指定交易的发送者、接收者、转移的以太币数量即可（在客户端发送交易时， Gas Limit Gas Price nonce hash 、签名可以按照默认方式生成）<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018102311113539?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></li> 
   <li>）创建智能合约的交易:：创建合约是指将合约部署到区块链上，这也是通过发送交易来实现的。在创建合约的交易中，to字段是一个空字符串，在data字段中指定初始化合约的二进制，在之后合约被调用时，该代码的执行结果将作为合约代码。<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023111716920?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></li> 
   <li>执行智能合约的交易：：顾名思义，该交易是为了执行已经部署在区块链上的智能合约，在该交易中，需要将“ 。”字段指定为要调用的智能合约的地址，通过“ data ，，字段指定要调用的方法以及向该方法传递参数<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023111818348?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></li> 
  </ol> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023115314804?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023115325524?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023115337825?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023115356552?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023115408549?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023115425657?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023115439768?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023115449704?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018102311550859?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p> 
  <h3><a id="13_354"></a>13.数据编码与压缩</h3> 
  <ul> 
   <li>RLP ( Recursive Length Prefix ）是一种编码算法，，用于编码任意的具有嵌套结构的二进制数据，是以太坊数据序列化的主要方法</li> 
   <li>以太坊中的区块 、交易等数据结构会先经过RLP 编码处理，然后再存储到数据库中</li> 
   <li>RLP 编码只处理两种类型的数据，即字符串和列表</li> 
   <li>得注意的是，其中并不包括原子数据类型， 如整型、浮点型</li> 
   <li>一 是按照字典顺序用含关键字的二维数组，另一种是使用更高级 Patricia 树来编码</li> 
   <li>在以太坊中，当发送数据以及在 MPT 树中保存状态时， 需要使用 RLP 编码</li> 
  </ul> 
  <h3><a id="14_API_362"></a>14.以大坊客户端和 API</h3> 
  <ol> 
   <li>Web3.js API<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181023120554730?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></li> 
  </ol> 
  <ul> 
   <li>作为先进共有链的代表之一，及以太坊区块链本质是一串连接的数据区块，区块之间使用密码学算法生成的散列指针连接。</li> 
   <li>对以太坊的区块，交易，账户等基本组成由一定了解，以太坊的数据结构和存储支持，以便读者对其底层结构有所了解。</li> 
   <li>以太坊入口 - 客户端和以太坊域名服务，让用户能够了解以太坊的顶层应用</li> 
  </ul> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/boss2967/article/details/83244455,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/boss2967/article/details/83244455,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
