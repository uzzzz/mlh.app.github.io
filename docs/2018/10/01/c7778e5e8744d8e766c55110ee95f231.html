<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>fabric 1.3 ，全手动部署到5台机器上.支持 kafka 模式的共识机制和 couchdb 存储 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="fabric 1.3 ，全手动部署到5台机器上.支持 kafka 模式的共识机制和 couchdb 存储" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/remote_roamer/article/details/82914666 fabric 1.3 ，全手动部署到5台机器上.支持 kafka 模式的共识机制和 couchdb 存储 参考文档 https://hyperledger-fabric.readthedocs.io/en/release-1.3/ https://www.lijiaocn.com/项目/2018/04/26/hyperledger-fabric-deploy.html https://hyperledgercn.github.io/hyperledgerDocs/ 系统环境：centos 7 64位 docker docker-compose 1. 安装docker sudo yum -y remove docker docker-common container-selinux sudo yum -y remove docker-selinux sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum update yum install docker-engine systemctl enable docker systemctl restart docker 2. 安装docker-compose docker-compose是docker集群管理工具，可自定义一键启动多个docker container。 官网二进制发布: https://github.com/docker/compose/releases 安装手册见网站 : https://docs.docker.com/compose/install/ 安装命令如下: curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose -v 3.准备环境。 IP host 192.168.188.110 cli.alcor.com 192.168.188.111 kafka.alcor.com 192.168.188.120 orderer.alcor.com 192.168.188.221 peer0.org1.alcor.com 192.168.188.222 peer1.org1.alcor.com 192.168.188.223 peer0.org2.alcor.com 192.168.188.224 peer1.org2.alcor.com 每台机器的 hostname 中都增加 ip 解析 vim /etc/hosts 192.168.188.110 cli.alcor.com 192.168.188.111 kafka.alcor.com 192.168.188.120 orderer.alcor.com 192.168.188.221 peer0.org1.alcor.com 192.168.188.222 peer1.org1.alcor.com 192.168.188.223 peer0.org2.alcor.com 192.168.188.224 peer1.org2.alcor.com 工作目录是 /root/fabric 在/root/fabric目录下建立2个子目录 /root/fabric/fabric-deploy 存放部署和配置内容 /root/fabric/fabric-images 存放自己制作的 docker images 4.安装 kafka 和 zookeeper 我在这里使用 docker-compose 安装 zookeeper 和 kafka（3个 kafka 节点） 环境 配置文件存放在 /Users/roamer/Documents/Docker/本地虚拟机/kafka 目录下 kafka 测试流程参考文档： kafka 的使用 5.下载 fabric 1.3 对应网站查看版本信息 https://nexus.hyperledger.org/#nexus-search;quick~fabric 1.3 下载文件自己安装 #登录 cli 主机 mkdir -p /root/fabric/fabric-deploy cd ~/fabric/fabric-deploy wget https://nexus.hyperledger.org/service/local/repositories/releases/content/org/hyperledger/fabric/hyperledger-fabric-1.3.0-stable/linux-amd64.1.3.0-stable-fdc4889/hyperledger-fabric-1.3.0-stable-linux-amd64.1.3.0-stable-fdc4889.tar.gz 用 md5sum 命令进行文件校验 解压fabric tar -xvf hyperledger-fabric-1.3.0-stable-linux-amd64.1.3.0-stable-fdc4889.tar.gz 理解 bin 目录和 config 目录下的文件 6. hyperledger 的证书准备 证书的准备方式有两种，一种用cryptogen命令生成，一种是通过fabric-ca服务生成。 通过cryptogen 来生成 创建一个配置文件crypto-config.yaml，这里配置了两个组织，org1和 org的Template 的 Count是2，表示各自两个peer。 vim crypto-config.yaml #文件内容如下： OrdererOrgs: - Name: Orderer Domain: alcor.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.alcor.com Template: Count: 2 Users: Count: 1 - Name: Org2 Domain: org2.alcor.com Template: Count: 2 Users: Count: 1 生成证书, 所有的文件存放在 /root/fabric/fabric-deploy/certs 目录下 cd /root/fabric/fabric-deploy ./bin/cryptogen generate --config=crypto-config.yaml --output ./certs 通过 ca 服务来生成 7. hyperledger fabric 中的Orderer 配置和安装文件的准备 建立一个存放orderer 配置文件的目录，用于以后复制到 orderer 主机上直接运行 orderer(支持 kafka) cd /root/fabric/fabric-deploy mkdir orderer.alcor.com cd orderer.alcor.com 先将bin/orderer以及证书复制到orderer.alcor.com目录中。 cd /root/fabric/fabric-deploy cp ./bin/orderer orderer.alcor.com cp -rf ./certs/ordererOrganizations/alcor.com/orderers/orderer.alcor.com/* ./orderer.alcor.com/ 然后准备orderer的配置文件orderer.alcor.com/orderer.yaml vi /root/fabric/fabric-deploy/orderer.alcor.com/orderer.yaml #内容如下 General: LedgerType: file ListenAddress: 0.0.0.0 ListenPort: 7050 TLS: Enabled: true PrivateKey: ./tls/server.key Certificate: ./tls/server.crt RootCAs: - ./tls/ca.crt # ClientAuthEnabled: false # ClientRootCAs: LogLevel: debug LogFormat: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; # GenesisMethod: provisional GenesisMethod: file GenesisProfile: SampleInsecureSolo GenesisFile: ./genesisblock LocalMSPDir: ./msp LocalMSPID: OrdererMSP Profile: Enabled: false Address: 0.0.0.0:6060 BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: FileLedger: Location: /opt/fabric/orderer/data Prefix: hyperledger-fabric-ordererledger RAMLedger: HistorySize: 1000 Kafka: Retry: ShortInterval: 5s ShortTotal: 10m LongInterval: 5m LongTotal: 12h NetworkTimeouts: DialTimeout: 10s ReadTimeout: 10s WriteTimeout: 10s Metadata: RetryBackoff: 250ms RetryMax: 3 Producer: RetryBackoff: 100ms RetryMax: 3 Consumer: RetryBackoff: 2s Verbose: false TLS: Enabled: false PrivateKey: #File: path/to/PrivateKey Certificate: #File: path/to/Certificate RootCAs: #File: path/to/RootCAs Version: 注意，orderer将被部署在目标机器（orderer.alcor.com）的/opt/fabric/orderer目录中，如果要部署在其它目录中，需要修改配置文件中路径。 这里需要用到一个data目录，存放orderer的数据: mkdir -p /root/fabric/fabric-deploy/orderer.alcor.com/data 8. hyperledger fabric 中的Peer 配置和安装文件的准备 建立4个存放peer 配置信息的目录 先设置 peer0.org1.alcor.com mkdir -p /root/fabric/fabric-deploy/peer0.org1.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer0.org1.alcor.com/ cp -rf certs/peerOrganizations/org1.alcor.com/peers/peer0.org1.alcor.com/* peer0.org1.alcor.com/ 注意： 一定要复制对应的 peer 和 org 的目录。否则会出现各种错误 生成 peer0.org1.alcor.com 的core.yaml 文件 这里是基于 fabric 1.3版本修改的core.yaml 文件。不兼容fabric 1.2 版本 并且是使用 CouchDB 取代缺省的 LevelDB vi /root/fabric/fabric-deploy/peer0.org1.alcor.com/core.yaml #内容如下: logging: level: info cauthdsl: warning gossip: warning grpc: error ledger: info msp: warning policies: warning peer: gossip: warning format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; peer: id: peer0.org1.alcor.com networkId: dev listenAddress: 0.0.0.0:7051 address: 0.0.0.0:7051 addressAutoDetect: false gomaxprocs: -1 keepalive: minInterval: 60s client: interval: 60s timeout: 20s deliveryClient: interval: 60s timeout: 20s gossip: bootstrap: peer0.org1.alcor.com:7051 useLeaderElection: true orgLeader: false endpoint: maxBlockCountToStore: 100 maxPropagationBurstLatency: 10ms maxPropagationBurstSize: 10 propagateIterations: 1 propagatePeerNum: 3 pullInterval: 4s pullPeerNum: 3 requestStateInfoInterval: 4s publishStateInfoInterval: 4s stateInfoRetentionInterval: publishCertPeriod: 10s skipBlockVerification: false dialTimeout: 3s connTimeout: 2s recvBuffSize: 20 sendBuffSize: 200 digestWaitTime: 1s requestWaitTime: 1500ms responseWaitTime: 2s aliveTimeInterval: 5s aliveExpirationTimeout: 25s reconnectInterval: 25s externalEndpoint: election: startupGracePeriod: 15s membershipSampleInterval: 1s leaderAliveThreshold: 10s leaderElectionDuration: 5s pvtData: pullRetryThreshold: 60s transientstoreMaxBlockRetention: 1000 pushAckTimeout: 3s btlPullMargin: 10 reconcileBatchSize: 10 reconcileSleepInterval: 5m tls: enabled: true clientAuthRequired: false cert: file: tls/server.crt key: file: tls/server.key rootcert: file: tls/ca.crt clientRootCAs: files: - tls/ca.crt clientKey: file: clientCert: file: authentication: timewindow: 15m fileSystemPath: /var/hyperledger/production BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: PKCS11: Library: Label: Pin: Hash: Security: FileKeyStore: KeyStore: mspConfigPath: msp localMspId: Org1MSP client: connTimeout: 3s deliveryclient: reconnectTotalTimeThreshold: 3600s connTimeout: 3s reConnectBackoffThreshold: 3600s localMspType: bccsp profile: enabled: false listenAddress: 0.0.0.0:6060 adminService: handlers: authFilters: - name: DefaultAuth - name: ExpirationCheck # This filter checks identity x509 certificate expiration decorators: - name: DefaultDecorator endorsers: escc: name: DefaultEndorsement library: validators: vscc: name: DefaultValidation library: validatorPoolSize: discovery: enabled: true authCacheEnabled: true authCacheMaxSize: 1000 authCachePurgeRetentionRatio: 0.75 orgMembersAllowedAccess: false vm: endpoint: unix:///var/run/docker.sock docker: tls: enabled: false ca: file: docker/ca.crt cert: file: docker/tls.crt key: file: docker/tls.key attachStdout: false hostConfig: NetworkMode: host Dns: LogConfig: Type: json-file Config: max-size: &quot;50m&quot; max-file: &quot;5&quot; Memory: 2147483648 chaincode: id: path: name: builder: $(DOCKER_NS)/fabric-ccenv:latest pull: false golang: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) dynamicLink: false car: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) java: runtime: $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION) node: runtime: $(BASE_DOCKER_NS)/fabric-baseimage:$(ARCH)-$(BASE_VERSION) startuptimeout: 300s executetimeout: 30s mode: net keepalive: 0 system: +lifecycle: enable cscc: enable lscc: enable escc: enable vscc: enable qscc: enable systemPlugins: logging: level: info shim: warning format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; ledger: blockchain: state: stateDatabase: CouchDB #goleveldb totalQueryLimit: 100000 couchDBConfig: couchDBAddress: 127.0.0.1:5984 username: admin password: password maxRetries: 3 maxRetriesOnStartup: 10 requestTimeout: 35s internalQueryLimit: 1000 maxBatchUpdateSize: 1000 warmIndexesAfterNBlocks: 1 createGlobalChangesDB: false history: enableHistoryDatabase: true metrics: enabled: false reporter: statsd interval: 1s statsdReporter: address: 0.0.0.0:8125 flushInterval: 2s flushBytes: 1432 promReporter: listenAddress: 0.0.0.0:8080 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer0.org1.alcor.com/data 设置 peer1.org1.alcor.com mkdir -p /root/fabric/fabric-deploy/peer1.org1.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer1.org1.alcor.com/ cp -rf certs/peerOrganizations/org1.alcor.com/peers/peer1.org1.alcor.com/* peer1.org1.alcor.com/ 最后修改peer1.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer1.org1.alcor.com，这里直接用sed命令替换: cd /root/fabric/fabric-deploy cp peer0.org1.alcor.com/core.yaml peer1.org1.alcor.com sed -i &quot;s/peer0.org1.alcor.com/peer1.org1.alcor.com/g&quot; peer1.org1.alcor.com/core.yaml 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer1.org1.alcor.com/data 设置 peer0.org2.alcor.com mkdir -p /root/fabric/fabric-deploy/peer0.org2.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer0.org2.alcor.com/ cp -rf certs/peerOrganizations/org2.alcor.com/peers/peer0.org2.alcor.com/* peer0.org2.alcor.com/ 最后修改peer0.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer0.org2.alcor.com，这里直接用sed命令替换: cd /root/fabric/fabric-deploy cp peer0.org1.alcor.com/core.yaml peer0.org2.alcor.com sed -i &quot;s/peer0.org1.alcor.com/peer0.org2.alcor.com/g&quot; peer0.org2.alcor.com/core.yaml 将配置文件中Org1MSP替换成Org2MSP: sed -i &quot;s/Org1MSP/Org2MSP/g&quot; peer0.org2.alcor.com/core.yaml 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer0.org2.alcor.com/data 设置 peer1.org2.alcor.com mkdir -p /root/fabric/fabric-deploy/peer1.org2.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer1.org2.alcor.com/ cp -rf certs/peerOrganizations/org2.alcor.com/peers/peer1.org2.alcor.com/* peer1.org2.alcor.com/ 最后修改peer0.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer1.org2.alcor.com，这里直接用sed命令替换: cd /root/fabric/fabric-deploy cp peer0.org1.alcor.com/core.yaml peer1.org2.alcor.com sed -i &quot;s/peer0.org1.alcor.com/peer1.org2.alcor.com/g&quot; peer1.org2.alcor.com/core.yaml 将配置文件中Org1MSP替换成Org2MSP: sed -i &quot;s/Org1MSP/Org2MSP/g&quot; peer1.org2.alcor.com/core.yaml 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer1.org2.alcor.com/data 9. hyperledger fabric 中的 order 和 peer 目标机器上的 配置文件部署 把准备好的 order 和 peer 上的配置文件复制到宿主机器上。 由于所有配置文件都是在 cli.alcor.com 机器上准备的，所以通过以下步骤复制到相应的主机上。目标地址按照配置文件都是存放在宿主机器/opt/fabric 目录下。 复制到 orderer.alcor.com 上 # 在 orderer.alcor.com 机器上建立 /opt/fabric/orderer 目录 mkdir -p /opt/fabric/orderer #回到 cli.alcor.com机器上，把 orderer的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r orderer.alcor.com/* root@orderer.alcor.com:/opt/fabric/orderer/ 复制到peer0.org1.alcor.com # 在 peer0.org1.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer0.org1.alcor.com的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer0.org1.alcor.com/* root@peer0.org1.alcor.com:/opt/fabric/peer/ 复制到peer1.org1.alcor.com # 在 peer1.org1.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer1.org1.alcor.com 的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer1.org1.alcor.com/* root@peer1.org1.alcor.com:/opt/fabric/peer/ 复制到peer0.org2.alcor.com # 在 peer0.org2.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer0.org2.alcor.com的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer0.org2.alcor.com/* root@peer0.org2.alcor.com:/opt/fabric/peer/ 复制到peer1.org2.alcor.com # 在 peer1.org2.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer1.org2.alcor.com的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer1.org2.alcor.com/* root@peer1.org2.alcor.com:/opt/fabric/peer/ 10. 准备创世纪区块 genesisblock(kafka 模式) 在 cli 机器的 /root/fabric/fabric-deploy/目录下，准备创世纪块的生成配置文件 configtx.yaml vi /root/fabric/fabric-deploy/configtx.yaml #文件内容如下： Organizations: - &amp;OrdererOrg Name: OrdererOrg ID: OrdererMSP MSPDir: ./certs/ordererOrganizations/alcor.com/msp - &amp;Org1 Name: Org1MSP ID: Org1MSP MSPDir: ./certs/peerOrganizations/org1.alcor.com/msp AnchorPeers: - Host: peer0.org1.alcor.com Port: 7051 - &amp;Org2 Name: Org2MSP ID: Org2MSP MSPDir: ./certs/peerOrganizations/org2.alcor.com/msp AnchorPeers: - Host: peer0.org2.alcor.com Port: 7051 Orderer: &amp;OrdererDefaults OrdererType: kafka Addresses: - orderer.alcor.com:7050 BatchTimeout: 2s BatchSize: MaxMessageCount: 10 AbsoluteMaxBytes: 99 MB PreferredMaxBytes: 512 KB Kafka: Brokers: - kafka.alcor.com:9092 # 可以填入多个kafka节点的地址 - kafka.alcor.com:9093 - kafka.alcor.com:9094 Organizations: Application: &amp;ApplicationDefaults Organizations: Profiles: TwoOrgsOrdererGenesis: Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Consortiums: SampleConsortium: Organizations: - *Org1 - *Org2 TwoOrgsChannel: Consortium: SampleConsortium Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 - *Org2 踩坑： 注意: 在1.2版本中。 配置文件的中的 Organizations 部分，必须在文件顶端。否则会出现: 如下错误 ![-w1436](media/15338798435067/15349240598525.jpg) 生成创世纪区块 cd /root/fabric/fabric-deploy ./bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./genesisblock -channelID genesis 生成创世纪区块文件 genesisblock ，并且指定创世区块的 channel id 是 genesis 然后把区块文件 genesisblock 复制到 oderer.alcor.com机器上 #登录到 cli 主机 cd /root/fabric/fabric-deploy scp ./genesisblock root@orderer.alcor.com:/opt/fabric/orderer 11. 启动 orderer 和 peer 启动 orderer # 进入 orderer.alcor.com 主机的 /opt/fabric/orderer 目录，建立一个startOrderer.sh 启动批处理文件.内容如下: ./orderer 2&gt;&amp;1 |tee log #启动 orderer chmod +x startOrderer.sh nohup ./startOrderer.sh &amp; 启动成功后，可以去任意一台 kafka 服务器上的控制台查看 topic 列表，是否有一个 genesis 的 channel。 /opt/kafka_2.11-1.1.1/bin/kafka-topics.sh --zookeeper 192.168.188.111:2181 --list 在4个 peer 上安装 couchDB 详细介绍查看 ： fabric peer 节点使用 CouchDB 来替换 LevelDB. 启动4个 peer #分别进入3个 peer 主机的 /opt/fabric/peer 目录，建立一个startPeer.sh 启动批处理文件，内容如下： ./peer node start 2&gt;&amp;1 |tee log #启动 peer ./startPeer.sh 12. 用户账号创建 在 cli 机器上建立存放用户账号信息的目录 cd /root/fabric/fabric-deploy mkdir users cd users 创立 org1的Admin 用户信息（对应到 peer0.org1.alcor.com 的节点） 创建保存 org1 的 Admin 用户信息的目录 cd /root/fabric/fabric-deploy/users mkdir Admin@org1.alcor.com cd Admin@org1.alcor.com 复制Admin@org1.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org1.alcor.com/users/Admin@org1.alcor.com/* /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/ 复制peer0.org1.alcor.com的配置文件(对应到 peer0.org1.alcor.com 的节点) cp /root/fabric/fabric-deploy/peer0.org1.aclor.com/core.yaml /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/Admin@org1.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer0.org1.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer0.org1.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer0.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer0.org1.aclor.com 的状态 ./peer.sh node status 创立 org1的 User1 用户信息 （对应到 peer1.org1.alcor.com 的节点） 创建保存 org1 的 User1 用户信息的目录（对应到 peer1.org1.alcor.com） 其实是 Admin 的用户证书，如果用的是User1的证书，在 peer node status 的时候，会出现错误： Error trying to connect to local peer: rpc error: code = Unknown desc = access denied cd /root/fabric/fabric-deploy/users mkdir User1@org1.alcor.com cd User1@org1.alcor.com 复制User1@org1.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org1.alcor.com/users/Admin@org1.alcor.com/* /root/fabric/fabric-deploy/users/User1@org1.alcor.com/ 复制peer1.org1.alcor.com的配置文件（对应到 peer1.org1.alcor.com） cp /root/fabric/fabric-deploy/peer1.org1.alcor.com/core.yaml /root/fabric/fabric-deploy/users/User1@org1.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/User1@org1.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer1.org1.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer1.org1.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer1.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer1.org1.alcor.com 的状态 ./peer.sh node status 创立 org2的Admin 用户信息（对应到 peer0.org2.alcor.com 的节点） 创建保存 org2 的 Admin 用户信息的目录 cd /root/fabric/fabric-deploy/users mkdir Admin@org2.alcor.com cd Admin@org2.alcor.com 复制Admin@org2.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org2.alcor.com/users/Admin@org2.alcor.com/* /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/ 复制peer0@org2.alcor.com的配置文件(对应到 peer0.org2.alcor.com 的节点) cp /root/fabric/fabric-deploy/peer0.org2.alcor.com/core.yaml /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/Admin@org2.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer0.org2.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org2MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer0.org2.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer0.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer0.org2.alcor.com 的状态 ./peer.sh node status 创立 org2的User1用户信息（对应到 peer1.org2.alcor.com 的节点） 其实是 Admin 的用户证书，如果用的是User1的证书，在 peer node status 的时候，会出现错误： Error trying to connect to local peer: rpc error: code = Unknown desc = access denied 创建保存 org2 的 User1 用户信息的目录 cd /root/fabric/fabric-deploy/users mkdir User1@org2.alcor.com cd User1@org2.alcor.com 复制Admin@org2.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org2.alcor.com/users/Admin@org2.alcor.com/* /root/fabric/fabric-deploy/users/User1@org2.alcor.com/ 复制peer0@org2.alcor.com的配置文件(对应到 peer0.org2.alcor.com 的节点) cp /root/fabric/fabric-deploy/peer1.org2.alcor.com/core.yaml /root/fabric/fabric-deploy/users/User1@org2.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/User1@org2.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer1.org2.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org2MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer1.org2.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer0.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer0.org2.alcor.com 的状态 ./peer.sh node status 13. channel 的准备和创建 踩坑：channel ID 不能含有大写字母（myTestChannel , myChannel 这种命名是不行的，在创建 channel 的时候，会报错） initializing configtx manager failed: bad channel ID: channel ID &#39;myTestChannel&#39; contains illegal characters 准备channel 文件。用configtxgen生成channel文件 cd /root/fabric/fabric-deploy/ ./bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx mychannel.tx -channelID mychannel 针对每个 org 的peer生成一个anchor文件，每个组织只需要一个： ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP 生成的Org1MSPanchors.tx和Org2MSPanchors.tx备用。 因为下一步操作中要访问orderer.alcor.com，所以需要将验证orderer.alcor.com的根证书复制到用户目录中： cd /root/fabric/fabric-deploy cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/Admin\@org1.alcor.com/ cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/User1\@org1.alcor.com/ cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/Admin\@org2.alcor.com/ cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/User1\@org2.alcor.com/ 14. 创建 channel 在Admin@org1.alcor.com目录中执行下面的命令，： cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh channel create -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/mychannel.tx --tls true --cafile tlsca.alcor.com-cert.pem 执行完成后，会生成一个mychannel.block文件. 这个文件非常重要!所有加入到这个 channel 里面的 peer，都需要用到这个文件 将mychannel.block复制一份到User1@org1.alcor.com 和 Admin@org2.alcor.com、User1@org2.alcor.com中备用 cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block /root/fabric/fabric-deploy/users/User1@org1.alcor.com/ cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/ cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block /root/fabric/fabric-deploy/users/User1@org2.alcor.com/ 15.把 4个 peer加入到 channel 中 把peer0.org1.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 把peer1.org1.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com #这个其实还是org1.alcor.com 的 Admin 用户 ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 把peer0.org2.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 把peer1.org2.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/User1@org2.alcor.com #这个其实还是org2.alcor.com 的 Admin 用户 ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 16.设置锚点 peer . 需要每个组织指定一个anchor peer，anchor peer是组织用来接收orderer下发的区块的peer。 把org1的 anchor peer 设置为 peer0.org1.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh channel update -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/Org1MSPanchors.tx --tls true --cafile ./tlsca.alcor.com-cert.pem 把org2的 anchor peer 设置为 peer0.org2.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh channel update -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/Org2MSPanchors.tx --tls true --cafile ./tlsca.alcor.com-cert.pem 17. go 版本的 chaincode 的安装和部署（在 cli 主机上操作） 安装 go 环境 go 的下载官网 https://golang.org/dl/ 以 root 用户安装 wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz tar -xvf go1.10.3.linux-386.tar.gz mv ./go /usr/local #修改 /etc/profile，增加 如下2行内容 export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin #使得环境变量生效 source /etc/profile #确定 go 的安装成功和版本信息 go version #查看 go 的环境 go env 拉取 demo 的 chaincode 这个需要先安装 gcc 组件 cd ~ go get github.com/roamerxv/chaincode/fabric/examples/go/demo 完成后，生成一个~/go 目录。下面有 src 和bin 目录。/root/go/src/github.com 目录下有个fabric 和 roamerxv 这2个目录。 测试编译 demo.go cd /root/go/src/github.com/roamerxv/chaincode/fabric/examples/go/demo go build #确定生成 demo 可执行文件，说明go 配置正常 chaincode 的打包 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode package demo-pack.out -n demo -v 0.0.1 -s -S -p github.com/roamerxv/chaincode/fabric/examples/go/demo 成功后生成一个 demo-pack.out 文件 chaincode 的签署 ./peer.sh chaincode signpackage demo-pack.out signed-demo-pack.out 成功后，生成 signed-demo-pack.out chaincode 的安装 ./peer.sh chaincode install ./signed-demo-pack.out 由于 peer.sh 中指定了CORE_PEER_ADDRESS=peer0.org1.alcor.com:7051 ，所以，这个安装其实是把 chaincode 文件复制到 peer0.org1.alcor.com 这台机器的 /var/hyperledger/production/chaincodes/ 目录下. 文件名是 demo.0.0.1. 而 /var/hyperledger/production/chaincodes/ 这个路径是由 core.yaml 里面的 peer.fileSystemPath 这个属性指定的。 #同时，可以在 cli 上，通过以下命令查看 peer 上的 chaincode 信息 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode list --installed 注意: 这个安装需要在涉及到的所有 peer 上进行一遍,包括另外的组织 org2. 而且一定要用 admin用户来安装。 所以，把签署后的 signed-demo-pack.out 复制到 ~/fabric/fabric-deploy/users/User1@org1.alcor.com , ~/fabric/fabric-deploy/users/Admin@org2.alcor.com 目录下. cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out /root/fabric/fabric-deploy/users/User1@org1.alcor.com cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out /root/fabric/fabric-deploy/users/Admin@org2.alcor.com cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out /root/fabric/fabric-deploy/users/User1@org2.alcor.com #进入另外3个目录，再次安装 chaincode 到对应的 peer 上 #这个是 安装到 peer1.org1.alcor.com cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com ./peer.sh chaincode install ./signed-demo-pack.out #这个是 安装到 peer0.org2.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh chaincode install ./signed-demo-pack.out #这个是 安装到 peer1.org2.alcor.com cd /root/fabric/fabric-deploy/users/User1@org2.alcor.com ./peer.sh chaincode install ./signed-demo-pack.out chaincode 的初始化 合约安装之后，需要且只需要进行一次初始化，只能由签署合约的用户进行初始化,并且所有的 peer 上的 docker 服务已经启动。谁签署了 chaincode，谁来进行实例化。 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode instantiate -o orderer.alcor.com:7050 --tls true --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo -v 0.0.1 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 第一次进行合约初始化的时候的会比较慢，因为peer 上需要创建、启动容器。 chaincode的调用 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode invoke -o orderer.alcor.com:7050 --tls true --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key1&quot;,&quot;key1value中文isabc&quot;]}&#39; chaincode 的调用，可以调用任意一台安装了这个 chaincode 的peer。这个时候被调用的 peer 上会启动相应的 chaincode 的 docker。 进行查询操作时，不需要指定orderer，例如： cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com ./peer.sh chaincode query -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key1&quot;]}&#39; chaincode 的更新 新合约的打包和签署 cd /home/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode package demo-pack-2.out -n demo -v 0.0.2 -s -S -p github.com/roamerxv/chaincode/fabric/examples/go/demo ./peer.sh chaincode signpackage demo-pack-2.out signed-demo-pack-2.out 新的合约也需要在每个peer上单独安装。 #安装到peer0.org1.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode install ./signed-demo-pack-2.out #安装到peer1.org1.alcor.com cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com ./peer.sh chaincode install ../Admin@org1.alcor.com/signed-demo-pack-2.out #安装到peer0.org2.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh chaincode install ../Admin@org1.alcor.com/signed-demo-pack-2.out #安装到peer1.org2.alcor.com cd /root/fabric/fabric-deploy/users/User1@org2.alcor.com ./peer.sh chaincode install ../Admin@org1.alcor.com/signed-demo-pack-2.out 更新的合约不需要初始化，需要进行更新操作。 cd /home/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode upgrade -o orderer.alcor.com:7050 --tls true --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo -v 0.0.2 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 查询key的历史记录 ./peer.sh chaincode query -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key1&quot;]}&#39; 阅读更多" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/remote_roamer/article/details/82914666 fabric 1.3 ，全手动部署到5台机器上.支持 kafka 模式的共识机制和 couchdb 存储 参考文档 https://hyperledger-fabric.readthedocs.io/en/release-1.3/ https://www.lijiaocn.com/项目/2018/04/26/hyperledger-fabric-deploy.html https://hyperledgercn.github.io/hyperledgerDocs/ 系统环境：centos 7 64位 docker docker-compose 1. 安装docker sudo yum -y remove docker docker-common container-selinux sudo yum -y remove docker-selinux sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum update yum install docker-engine systemctl enable docker systemctl restart docker 2. 安装docker-compose docker-compose是docker集群管理工具，可自定义一键启动多个docker container。 官网二进制发布: https://github.com/docker/compose/releases 安装手册见网站 : https://docs.docker.com/compose/install/ 安装命令如下: curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose -v 3.准备环境。 IP host 192.168.188.110 cli.alcor.com 192.168.188.111 kafka.alcor.com 192.168.188.120 orderer.alcor.com 192.168.188.221 peer0.org1.alcor.com 192.168.188.222 peer1.org1.alcor.com 192.168.188.223 peer0.org2.alcor.com 192.168.188.224 peer1.org2.alcor.com 每台机器的 hostname 中都增加 ip 解析 vim /etc/hosts 192.168.188.110 cli.alcor.com 192.168.188.111 kafka.alcor.com 192.168.188.120 orderer.alcor.com 192.168.188.221 peer0.org1.alcor.com 192.168.188.222 peer1.org1.alcor.com 192.168.188.223 peer0.org2.alcor.com 192.168.188.224 peer1.org2.alcor.com 工作目录是 /root/fabric 在/root/fabric目录下建立2个子目录 /root/fabric/fabric-deploy 存放部署和配置内容 /root/fabric/fabric-images 存放自己制作的 docker images 4.安装 kafka 和 zookeeper 我在这里使用 docker-compose 安装 zookeeper 和 kafka（3个 kafka 节点） 环境 配置文件存放在 /Users/roamer/Documents/Docker/本地虚拟机/kafka 目录下 kafka 测试流程参考文档： kafka 的使用 5.下载 fabric 1.3 对应网站查看版本信息 https://nexus.hyperledger.org/#nexus-search;quick~fabric 1.3 下载文件自己安装 #登录 cli 主机 mkdir -p /root/fabric/fabric-deploy cd ~/fabric/fabric-deploy wget https://nexus.hyperledger.org/service/local/repositories/releases/content/org/hyperledger/fabric/hyperledger-fabric-1.3.0-stable/linux-amd64.1.3.0-stable-fdc4889/hyperledger-fabric-1.3.0-stable-linux-amd64.1.3.0-stable-fdc4889.tar.gz 用 md5sum 命令进行文件校验 解压fabric tar -xvf hyperledger-fabric-1.3.0-stable-linux-amd64.1.3.0-stable-fdc4889.tar.gz 理解 bin 目录和 config 目录下的文件 6. hyperledger 的证书准备 证书的准备方式有两种，一种用cryptogen命令生成，一种是通过fabric-ca服务生成。 通过cryptogen 来生成 创建一个配置文件crypto-config.yaml，这里配置了两个组织，org1和 org的Template 的 Count是2，表示各自两个peer。 vim crypto-config.yaml #文件内容如下： OrdererOrgs: - Name: Orderer Domain: alcor.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.alcor.com Template: Count: 2 Users: Count: 1 - Name: Org2 Domain: org2.alcor.com Template: Count: 2 Users: Count: 1 生成证书, 所有的文件存放在 /root/fabric/fabric-deploy/certs 目录下 cd /root/fabric/fabric-deploy ./bin/cryptogen generate --config=crypto-config.yaml --output ./certs 通过 ca 服务来生成 7. hyperledger fabric 中的Orderer 配置和安装文件的准备 建立一个存放orderer 配置文件的目录，用于以后复制到 orderer 主机上直接运行 orderer(支持 kafka) cd /root/fabric/fabric-deploy mkdir orderer.alcor.com cd orderer.alcor.com 先将bin/orderer以及证书复制到orderer.alcor.com目录中。 cd /root/fabric/fabric-deploy cp ./bin/orderer orderer.alcor.com cp -rf ./certs/ordererOrganizations/alcor.com/orderers/orderer.alcor.com/* ./orderer.alcor.com/ 然后准备orderer的配置文件orderer.alcor.com/orderer.yaml vi /root/fabric/fabric-deploy/orderer.alcor.com/orderer.yaml #内容如下 General: LedgerType: file ListenAddress: 0.0.0.0 ListenPort: 7050 TLS: Enabled: true PrivateKey: ./tls/server.key Certificate: ./tls/server.crt RootCAs: - ./tls/ca.crt # ClientAuthEnabled: false # ClientRootCAs: LogLevel: debug LogFormat: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; # GenesisMethod: provisional GenesisMethod: file GenesisProfile: SampleInsecureSolo GenesisFile: ./genesisblock LocalMSPDir: ./msp LocalMSPID: OrdererMSP Profile: Enabled: false Address: 0.0.0.0:6060 BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: FileLedger: Location: /opt/fabric/orderer/data Prefix: hyperledger-fabric-ordererledger RAMLedger: HistorySize: 1000 Kafka: Retry: ShortInterval: 5s ShortTotal: 10m LongInterval: 5m LongTotal: 12h NetworkTimeouts: DialTimeout: 10s ReadTimeout: 10s WriteTimeout: 10s Metadata: RetryBackoff: 250ms RetryMax: 3 Producer: RetryBackoff: 100ms RetryMax: 3 Consumer: RetryBackoff: 2s Verbose: false TLS: Enabled: false PrivateKey: #File: path/to/PrivateKey Certificate: #File: path/to/Certificate RootCAs: #File: path/to/RootCAs Version: 注意，orderer将被部署在目标机器（orderer.alcor.com）的/opt/fabric/orderer目录中，如果要部署在其它目录中，需要修改配置文件中路径。 这里需要用到一个data目录，存放orderer的数据: mkdir -p /root/fabric/fabric-deploy/orderer.alcor.com/data 8. hyperledger fabric 中的Peer 配置和安装文件的准备 建立4个存放peer 配置信息的目录 先设置 peer0.org1.alcor.com mkdir -p /root/fabric/fabric-deploy/peer0.org1.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer0.org1.alcor.com/ cp -rf certs/peerOrganizations/org1.alcor.com/peers/peer0.org1.alcor.com/* peer0.org1.alcor.com/ 注意： 一定要复制对应的 peer 和 org 的目录。否则会出现各种错误 生成 peer0.org1.alcor.com 的core.yaml 文件 这里是基于 fabric 1.3版本修改的core.yaml 文件。不兼容fabric 1.2 版本 并且是使用 CouchDB 取代缺省的 LevelDB vi /root/fabric/fabric-deploy/peer0.org1.alcor.com/core.yaml #内容如下: logging: level: info cauthdsl: warning gossip: warning grpc: error ledger: info msp: warning policies: warning peer: gossip: warning format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; peer: id: peer0.org1.alcor.com networkId: dev listenAddress: 0.0.0.0:7051 address: 0.0.0.0:7051 addressAutoDetect: false gomaxprocs: -1 keepalive: minInterval: 60s client: interval: 60s timeout: 20s deliveryClient: interval: 60s timeout: 20s gossip: bootstrap: peer0.org1.alcor.com:7051 useLeaderElection: true orgLeader: false endpoint: maxBlockCountToStore: 100 maxPropagationBurstLatency: 10ms maxPropagationBurstSize: 10 propagateIterations: 1 propagatePeerNum: 3 pullInterval: 4s pullPeerNum: 3 requestStateInfoInterval: 4s publishStateInfoInterval: 4s stateInfoRetentionInterval: publishCertPeriod: 10s skipBlockVerification: false dialTimeout: 3s connTimeout: 2s recvBuffSize: 20 sendBuffSize: 200 digestWaitTime: 1s requestWaitTime: 1500ms responseWaitTime: 2s aliveTimeInterval: 5s aliveExpirationTimeout: 25s reconnectInterval: 25s externalEndpoint: election: startupGracePeriod: 15s membershipSampleInterval: 1s leaderAliveThreshold: 10s leaderElectionDuration: 5s pvtData: pullRetryThreshold: 60s transientstoreMaxBlockRetention: 1000 pushAckTimeout: 3s btlPullMargin: 10 reconcileBatchSize: 10 reconcileSleepInterval: 5m tls: enabled: true clientAuthRequired: false cert: file: tls/server.crt key: file: tls/server.key rootcert: file: tls/ca.crt clientRootCAs: files: - tls/ca.crt clientKey: file: clientCert: file: authentication: timewindow: 15m fileSystemPath: /var/hyperledger/production BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: PKCS11: Library: Label: Pin: Hash: Security: FileKeyStore: KeyStore: mspConfigPath: msp localMspId: Org1MSP client: connTimeout: 3s deliveryclient: reconnectTotalTimeThreshold: 3600s connTimeout: 3s reConnectBackoffThreshold: 3600s localMspType: bccsp profile: enabled: false listenAddress: 0.0.0.0:6060 adminService: handlers: authFilters: - name: DefaultAuth - name: ExpirationCheck # This filter checks identity x509 certificate expiration decorators: - name: DefaultDecorator endorsers: escc: name: DefaultEndorsement library: validators: vscc: name: DefaultValidation library: validatorPoolSize: discovery: enabled: true authCacheEnabled: true authCacheMaxSize: 1000 authCachePurgeRetentionRatio: 0.75 orgMembersAllowedAccess: false vm: endpoint: unix:///var/run/docker.sock docker: tls: enabled: false ca: file: docker/ca.crt cert: file: docker/tls.crt key: file: docker/tls.key attachStdout: false hostConfig: NetworkMode: host Dns: LogConfig: Type: json-file Config: max-size: &quot;50m&quot; max-file: &quot;5&quot; Memory: 2147483648 chaincode: id: path: name: builder: $(DOCKER_NS)/fabric-ccenv:latest pull: false golang: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) dynamicLink: false car: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) java: runtime: $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION) node: runtime: $(BASE_DOCKER_NS)/fabric-baseimage:$(ARCH)-$(BASE_VERSION) startuptimeout: 300s executetimeout: 30s mode: net keepalive: 0 system: +lifecycle: enable cscc: enable lscc: enable escc: enable vscc: enable qscc: enable systemPlugins: logging: level: info shim: warning format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; ledger: blockchain: state: stateDatabase: CouchDB #goleveldb totalQueryLimit: 100000 couchDBConfig: couchDBAddress: 127.0.0.1:5984 username: admin password: password maxRetries: 3 maxRetriesOnStartup: 10 requestTimeout: 35s internalQueryLimit: 1000 maxBatchUpdateSize: 1000 warmIndexesAfterNBlocks: 1 createGlobalChangesDB: false history: enableHistoryDatabase: true metrics: enabled: false reporter: statsd interval: 1s statsdReporter: address: 0.0.0.0:8125 flushInterval: 2s flushBytes: 1432 promReporter: listenAddress: 0.0.0.0:8080 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer0.org1.alcor.com/data 设置 peer1.org1.alcor.com mkdir -p /root/fabric/fabric-deploy/peer1.org1.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer1.org1.alcor.com/ cp -rf certs/peerOrganizations/org1.alcor.com/peers/peer1.org1.alcor.com/* peer1.org1.alcor.com/ 最后修改peer1.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer1.org1.alcor.com，这里直接用sed命令替换: cd /root/fabric/fabric-deploy cp peer0.org1.alcor.com/core.yaml peer1.org1.alcor.com sed -i &quot;s/peer0.org1.alcor.com/peer1.org1.alcor.com/g&quot; peer1.org1.alcor.com/core.yaml 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer1.org1.alcor.com/data 设置 peer0.org2.alcor.com mkdir -p /root/fabric/fabric-deploy/peer0.org2.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer0.org2.alcor.com/ cp -rf certs/peerOrganizations/org2.alcor.com/peers/peer0.org2.alcor.com/* peer0.org2.alcor.com/ 最后修改peer0.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer0.org2.alcor.com，这里直接用sed命令替换: cd /root/fabric/fabric-deploy cp peer0.org1.alcor.com/core.yaml peer0.org2.alcor.com sed -i &quot;s/peer0.org1.alcor.com/peer0.org2.alcor.com/g&quot; peer0.org2.alcor.com/core.yaml 将配置文件中Org1MSP替换成Org2MSP: sed -i &quot;s/Org1MSP/Org2MSP/g&quot; peer0.org2.alcor.com/core.yaml 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer0.org2.alcor.com/data 设置 peer1.org2.alcor.com mkdir -p /root/fabric/fabric-deploy/peer1.org2.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer1.org2.alcor.com/ cp -rf certs/peerOrganizations/org2.alcor.com/peers/peer1.org2.alcor.com/* peer1.org2.alcor.com/ 最后修改peer0.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer1.org2.alcor.com，这里直接用sed命令替换: cd /root/fabric/fabric-deploy cp peer0.org1.alcor.com/core.yaml peer1.org2.alcor.com sed -i &quot;s/peer0.org1.alcor.com/peer1.org2.alcor.com/g&quot; peer1.org2.alcor.com/core.yaml 将配置文件中Org1MSP替换成Org2MSP: sed -i &quot;s/Org1MSP/Org2MSP/g&quot; peer1.org2.alcor.com/core.yaml 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer1.org2.alcor.com/data 9. hyperledger fabric 中的 order 和 peer 目标机器上的 配置文件部署 把准备好的 order 和 peer 上的配置文件复制到宿主机器上。 由于所有配置文件都是在 cli.alcor.com 机器上准备的，所以通过以下步骤复制到相应的主机上。目标地址按照配置文件都是存放在宿主机器/opt/fabric 目录下。 复制到 orderer.alcor.com 上 # 在 orderer.alcor.com 机器上建立 /opt/fabric/orderer 目录 mkdir -p /opt/fabric/orderer #回到 cli.alcor.com机器上，把 orderer的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r orderer.alcor.com/* root@orderer.alcor.com:/opt/fabric/orderer/ 复制到peer0.org1.alcor.com # 在 peer0.org1.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer0.org1.alcor.com的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer0.org1.alcor.com/* root@peer0.org1.alcor.com:/opt/fabric/peer/ 复制到peer1.org1.alcor.com # 在 peer1.org1.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer1.org1.alcor.com 的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer1.org1.alcor.com/* root@peer1.org1.alcor.com:/opt/fabric/peer/ 复制到peer0.org2.alcor.com # 在 peer0.org2.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer0.org2.alcor.com的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer0.org2.alcor.com/* root@peer0.org2.alcor.com:/opt/fabric/peer/ 复制到peer1.org2.alcor.com # 在 peer1.org2.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer1.org2.alcor.com的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer1.org2.alcor.com/* root@peer1.org2.alcor.com:/opt/fabric/peer/ 10. 准备创世纪区块 genesisblock(kafka 模式) 在 cli 机器的 /root/fabric/fabric-deploy/目录下，准备创世纪块的生成配置文件 configtx.yaml vi /root/fabric/fabric-deploy/configtx.yaml #文件内容如下： Organizations: - &amp;OrdererOrg Name: OrdererOrg ID: OrdererMSP MSPDir: ./certs/ordererOrganizations/alcor.com/msp - &amp;Org1 Name: Org1MSP ID: Org1MSP MSPDir: ./certs/peerOrganizations/org1.alcor.com/msp AnchorPeers: - Host: peer0.org1.alcor.com Port: 7051 - &amp;Org2 Name: Org2MSP ID: Org2MSP MSPDir: ./certs/peerOrganizations/org2.alcor.com/msp AnchorPeers: - Host: peer0.org2.alcor.com Port: 7051 Orderer: &amp;OrdererDefaults OrdererType: kafka Addresses: - orderer.alcor.com:7050 BatchTimeout: 2s BatchSize: MaxMessageCount: 10 AbsoluteMaxBytes: 99 MB PreferredMaxBytes: 512 KB Kafka: Brokers: - kafka.alcor.com:9092 # 可以填入多个kafka节点的地址 - kafka.alcor.com:9093 - kafka.alcor.com:9094 Organizations: Application: &amp;ApplicationDefaults Organizations: Profiles: TwoOrgsOrdererGenesis: Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Consortiums: SampleConsortium: Organizations: - *Org1 - *Org2 TwoOrgsChannel: Consortium: SampleConsortium Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 - *Org2 踩坑： 注意: 在1.2版本中。 配置文件的中的 Organizations 部分，必须在文件顶端。否则会出现: 如下错误 ![-w1436](media/15338798435067/15349240598525.jpg) 生成创世纪区块 cd /root/fabric/fabric-deploy ./bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./genesisblock -channelID genesis 生成创世纪区块文件 genesisblock ，并且指定创世区块的 channel id 是 genesis 然后把区块文件 genesisblock 复制到 oderer.alcor.com机器上 #登录到 cli 主机 cd /root/fabric/fabric-deploy scp ./genesisblock root@orderer.alcor.com:/opt/fabric/orderer 11. 启动 orderer 和 peer 启动 orderer # 进入 orderer.alcor.com 主机的 /opt/fabric/orderer 目录，建立一个startOrderer.sh 启动批处理文件.内容如下: ./orderer 2&gt;&amp;1 |tee log #启动 orderer chmod +x startOrderer.sh nohup ./startOrderer.sh &amp; 启动成功后，可以去任意一台 kafka 服务器上的控制台查看 topic 列表，是否有一个 genesis 的 channel。 /opt/kafka_2.11-1.1.1/bin/kafka-topics.sh --zookeeper 192.168.188.111:2181 --list 在4个 peer 上安装 couchDB 详细介绍查看 ： fabric peer 节点使用 CouchDB 来替换 LevelDB. 启动4个 peer #分别进入3个 peer 主机的 /opt/fabric/peer 目录，建立一个startPeer.sh 启动批处理文件，内容如下： ./peer node start 2&gt;&amp;1 |tee log #启动 peer ./startPeer.sh 12. 用户账号创建 在 cli 机器上建立存放用户账号信息的目录 cd /root/fabric/fabric-deploy mkdir users cd users 创立 org1的Admin 用户信息（对应到 peer0.org1.alcor.com 的节点） 创建保存 org1 的 Admin 用户信息的目录 cd /root/fabric/fabric-deploy/users mkdir Admin@org1.alcor.com cd Admin@org1.alcor.com 复制Admin@org1.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org1.alcor.com/users/Admin@org1.alcor.com/* /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/ 复制peer0.org1.alcor.com的配置文件(对应到 peer0.org1.alcor.com 的节点) cp /root/fabric/fabric-deploy/peer0.org1.aclor.com/core.yaml /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/Admin@org1.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer0.org1.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer0.org1.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer0.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer0.org1.aclor.com 的状态 ./peer.sh node status 创立 org1的 User1 用户信息 （对应到 peer1.org1.alcor.com 的节点） 创建保存 org1 的 User1 用户信息的目录（对应到 peer1.org1.alcor.com） 其实是 Admin 的用户证书，如果用的是User1的证书，在 peer node status 的时候，会出现错误： Error trying to connect to local peer: rpc error: code = Unknown desc = access denied cd /root/fabric/fabric-deploy/users mkdir User1@org1.alcor.com cd User1@org1.alcor.com 复制User1@org1.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org1.alcor.com/users/Admin@org1.alcor.com/* /root/fabric/fabric-deploy/users/User1@org1.alcor.com/ 复制peer1.org1.alcor.com的配置文件（对应到 peer1.org1.alcor.com） cp /root/fabric/fabric-deploy/peer1.org1.alcor.com/core.yaml /root/fabric/fabric-deploy/users/User1@org1.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/User1@org1.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer1.org1.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer1.org1.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer1.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer1.org1.alcor.com 的状态 ./peer.sh node status 创立 org2的Admin 用户信息（对应到 peer0.org2.alcor.com 的节点） 创建保存 org2 的 Admin 用户信息的目录 cd /root/fabric/fabric-deploy/users mkdir Admin@org2.alcor.com cd Admin@org2.alcor.com 复制Admin@org2.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org2.alcor.com/users/Admin@org2.alcor.com/* /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/ 复制peer0@org2.alcor.com的配置文件(对应到 peer0.org2.alcor.com 的节点) cp /root/fabric/fabric-deploy/peer0.org2.alcor.com/core.yaml /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/Admin@org2.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer0.org2.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org2MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer0.org2.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer0.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer0.org2.alcor.com 的状态 ./peer.sh node status 创立 org2的User1用户信息（对应到 peer1.org2.alcor.com 的节点） 其实是 Admin 的用户证书，如果用的是User1的证书，在 peer node status 的时候，会出现错误： Error trying to connect to local peer: rpc error: code = Unknown desc = access denied 创建保存 org2 的 User1 用户信息的目录 cd /root/fabric/fabric-deploy/users mkdir User1@org2.alcor.com cd User1@org2.alcor.com 复制Admin@org2.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org2.alcor.com/users/Admin@org2.alcor.com/* /root/fabric/fabric-deploy/users/User1@org2.alcor.com/ 复制peer0@org2.alcor.com的配置文件(对应到 peer0.org2.alcor.com 的节点) cp /root/fabric/fabric-deploy/peer1.org2.alcor.com/core.yaml /root/fabric/fabric-deploy/users/User1@org2.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/User1@org2.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer1.org2.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org2MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer1.org2.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer0.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer0.org2.alcor.com 的状态 ./peer.sh node status 13. channel 的准备和创建 踩坑：channel ID 不能含有大写字母（myTestChannel , myChannel 这种命名是不行的，在创建 channel 的时候，会报错） initializing configtx manager failed: bad channel ID: channel ID &#39;myTestChannel&#39; contains illegal characters 准备channel 文件。用configtxgen生成channel文件 cd /root/fabric/fabric-deploy/ ./bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx mychannel.tx -channelID mychannel 针对每个 org 的peer生成一个anchor文件，每个组织只需要一个： ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP 生成的Org1MSPanchors.tx和Org2MSPanchors.tx备用。 因为下一步操作中要访问orderer.alcor.com，所以需要将验证orderer.alcor.com的根证书复制到用户目录中： cd /root/fabric/fabric-deploy cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/Admin\@org1.alcor.com/ cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/User1\@org1.alcor.com/ cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/Admin\@org2.alcor.com/ cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/User1\@org2.alcor.com/ 14. 创建 channel 在Admin@org1.alcor.com目录中执行下面的命令，： cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh channel create -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/mychannel.tx --tls true --cafile tlsca.alcor.com-cert.pem 执行完成后，会生成一个mychannel.block文件. 这个文件非常重要!所有加入到这个 channel 里面的 peer，都需要用到这个文件 将mychannel.block复制一份到User1@org1.alcor.com 和 Admin@org2.alcor.com、User1@org2.alcor.com中备用 cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block /root/fabric/fabric-deploy/users/User1@org1.alcor.com/ cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/ cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block /root/fabric/fabric-deploy/users/User1@org2.alcor.com/ 15.把 4个 peer加入到 channel 中 把peer0.org1.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 把peer1.org1.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com #这个其实还是org1.alcor.com 的 Admin 用户 ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 把peer0.org2.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 把peer1.org2.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/User1@org2.alcor.com #这个其实还是org2.alcor.com 的 Admin 用户 ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 16.设置锚点 peer . 需要每个组织指定一个anchor peer，anchor peer是组织用来接收orderer下发的区块的peer。 把org1的 anchor peer 设置为 peer0.org1.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh channel update -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/Org1MSPanchors.tx --tls true --cafile ./tlsca.alcor.com-cert.pem 把org2的 anchor peer 设置为 peer0.org2.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh channel update -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/Org2MSPanchors.tx --tls true --cafile ./tlsca.alcor.com-cert.pem 17. go 版本的 chaincode 的安装和部署（在 cli 主机上操作） 安装 go 环境 go 的下载官网 https://golang.org/dl/ 以 root 用户安装 wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz tar -xvf go1.10.3.linux-386.tar.gz mv ./go /usr/local #修改 /etc/profile，增加 如下2行内容 export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin #使得环境变量生效 source /etc/profile #确定 go 的安装成功和版本信息 go version #查看 go 的环境 go env 拉取 demo 的 chaincode 这个需要先安装 gcc 组件 cd ~ go get github.com/roamerxv/chaincode/fabric/examples/go/demo 完成后，生成一个~/go 目录。下面有 src 和bin 目录。/root/go/src/github.com 目录下有个fabric 和 roamerxv 这2个目录。 测试编译 demo.go cd /root/go/src/github.com/roamerxv/chaincode/fabric/examples/go/demo go build #确定生成 demo 可执行文件，说明go 配置正常 chaincode 的打包 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode package demo-pack.out -n demo -v 0.0.1 -s -S -p github.com/roamerxv/chaincode/fabric/examples/go/demo 成功后生成一个 demo-pack.out 文件 chaincode 的签署 ./peer.sh chaincode signpackage demo-pack.out signed-demo-pack.out 成功后，生成 signed-demo-pack.out chaincode 的安装 ./peer.sh chaincode install ./signed-demo-pack.out 由于 peer.sh 中指定了CORE_PEER_ADDRESS=peer0.org1.alcor.com:7051 ，所以，这个安装其实是把 chaincode 文件复制到 peer0.org1.alcor.com 这台机器的 /var/hyperledger/production/chaincodes/ 目录下. 文件名是 demo.0.0.1. 而 /var/hyperledger/production/chaincodes/ 这个路径是由 core.yaml 里面的 peer.fileSystemPath 这个属性指定的。 #同时，可以在 cli 上，通过以下命令查看 peer 上的 chaincode 信息 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode list --installed 注意: 这个安装需要在涉及到的所有 peer 上进行一遍,包括另外的组织 org2. 而且一定要用 admin用户来安装。 所以，把签署后的 signed-demo-pack.out 复制到 ~/fabric/fabric-deploy/users/User1@org1.alcor.com , ~/fabric/fabric-deploy/users/Admin@org2.alcor.com 目录下. cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out /root/fabric/fabric-deploy/users/User1@org1.alcor.com cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out /root/fabric/fabric-deploy/users/Admin@org2.alcor.com cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out /root/fabric/fabric-deploy/users/User1@org2.alcor.com #进入另外3个目录，再次安装 chaincode 到对应的 peer 上 #这个是 安装到 peer1.org1.alcor.com cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com ./peer.sh chaincode install ./signed-demo-pack.out #这个是 安装到 peer0.org2.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh chaincode install ./signed-demo-pack.out #这个是 安装到 peer1.org2.alcor.com cd /root/fabric/fabric-deploy/users/User1@org2.alcor.com ./peer.sh chaincode install ./signed-demo-pack.out chaincode 的初始化 合约安装之后，需要且只需要进行一次初始化，只能由签署合约的用户进行初始化,并且所有的 peer 上的 docker 服务已经启动。谁签署了 chaincode，谁来进行实例化。 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode instantiate -o orderer.alcor.com:7050 --tls true --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo -v 0.0.1 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 第一次进行合约初始化的时候的会比较慢，因为peer 上需要创建、启动容器。 chaincode的调用 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode invoke -o orderer.alcor.com:7050 --tls true --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key1&quot;,&quot;key1value中文isabc&quot;]}&#39; chaincode 的调用，可以调用任意一台安装了这个 chaincode 的peer。这个时候被调用的 peer 上会启动相应的 chaincode 的 docker。 进行查询操作时，不需要指定orderer，例如： cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com ./peer.sh chaincode query -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key1&quot;]}&#39; chaincode 的更新 新合约的打包和签署 cd /home/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode package demo-pack-2.out -n demo -v 0.0.2 -s -S -p github.com/roamerxv/chaincode/fabric/examples/go/demo ./peer.sh chaincode signpackage demo-pack-2.out signed-demo-pack-2.out 新的合约也需要在每个peer上单独安装。 #安装到peer0.org1.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode install ./signed-demo-pack-2.out #安装到peer1.org1.alcor.com cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com ./peer.sh chaincode install ../Admin@org1.alcor.com/signed-demo-pack-2.out #安装到peer0.org2.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh chaincode install ../Admin@org1.alcor.com/signed-demo-pack-2.out #安装到peer1.org2.alcor.com cd /root/fabric/fabric-deploy/users/User1@org2.alcor.com ./peer.sh chaincode install ../Admin@org1.alcor.com/signed-demo-pack-2.out 更新的合约不需要初始化，需要进行更新操作。 cd /home/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode upgrade -o orderer.alcor.com:7050 --tls true --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo -v 0.0.2 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 查询key的历史记录 ./peer.sh chaincode query -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key1&quot;]}&#39; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/10/01/c7778e5e8744d8e766c55110ee95f231.html" />
<meta property="og:url" content="https://mlh.app/2018/10/01/c7778e5e8744d8e766c55110ee95f231.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-10-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/remote_roamer/article/details/82914666 fabric 1.3 ，全手动部署到5台机器上.支持 kafka 模式的共识机制和 couchdb 存储 参考文档 https://hyperledger-fabric.readthedocs.io/en/release-1.3/ https://www.lijiaocn.com/项目/2018/04/26/hyperledger-fabric-deploy.html https://hyperledgercn.github.io/hyperledgerDocs/ 系统环境：centos 7 64位 docker docker-compose 1. 安装docker sudo yum -y remove docker docker-common container-selinux sudo yum -y remove docker-selinux sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum update yum install docker-engine systemctl enable docker systemctl restart docker 2. 安装docker-compose docker-compose是docker集群管理工具，可自定义一键启动多个docker container。 官网二进制发布: https://github.com/docker/compose/releases 安装手册见网站 : https://docs.docker.com/compose/install/ 安装命令如下: curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose -v 3.准备环境。 IP host 192.168.188.110 cli.alcor.com 192.168.188.111 kafka.alcor.com 192.168.188.120 orderer.alcor.com 192.168.188.221 peer0.org1.alcor.com 192.168.188.222 peer1.org1.alcor.com 192.168.188.223 peer0.org2.alcor.com 192.168.188.224 peer1.org2.alcor.com 每台机器的 hostname 中都增加 ip 解析 vim /etc/hosts 192.168.188.110 cli.alcor.com 192.168.188.111 kafka.alcor.com 192.168.188.120 orderer.alcor.com 192.168.188.221 peer0.org1.alcor.com 192.168.188.222 peer1.org1.alcor.com 192.168.188.223 peer0.org2.alcor.com 192.168.188.224 peer1.org2.alcor.com 工作目录是 /root/fabric 在/root/fabric目录下建立2个子目录 /root/fabric/fabric-deploy 存放部署和配置内容 /root/fabric/fabric-images 存放自己制作的 docker images 4.安装 kafka 和 zookeeper 我在这里使用 docker-compose 安装 zookeeper 和 kafka（3个 kafka 节点） 环境 配置文件存放在 /Users/roamer/Documents/Docker/本地虚拟机/kafka 目录下 kafka 测试流程参考文档： kafka 的使用 5.下载 fabric 1.3 对应网站查看版本信息 https://nexus.hyperledger.org/#nexus-search;quick~fabric 1.3 下载文件自己安装 #登录 cli 主机 mkdir -p /root/fabric/fabric-deploy cd ~/fabric/fabric-deploy wget https://nexus.hyperledger.org/service/local/repositories/releases/content/org/hyperledger/fabric/hyperledger-fabric-1.3.0-stable/linux-amd64.1.3.0-stable-fdc4889/hyperledger-fabric-1.3.0-stable-linux-amd64.1.3.0-stable-fdc4889.tar.gz 用 md5sum 命令进行文件校验 解压fabric tar -xvf hyperledger-fabric-1.3.0-stable-linux-amd64.1.3.0-stable-fdc4889.tar.gz 理解 bin 目录和 config 目录下的文件 6. hyperledger 的证书准备 证书的准备方式有两种，一种用cryptogen命令生成，一种是通过fabric-ca服务生成。 通过cryptogen 来生成 创建一个配置文件crypto-config.yaml，这里配置了两个组织，org1和 org的Template 的 Count是2，表示各自两个peer。 vim crypto-config.yaml #文件内容如下： OrdererOrgs: - Name: Orderer Domain: alcor.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.alcor.com Template: Count: 2 Users: Count: 1 - Name: Org2 Domain: org2.alcor.com Template: Count: 2 Users: Count: 1 生成证书, 所有的文件存放在 /root/fabric/fabric-deploy/certs 目录下 cd /root/fabric/fabric-deploy ./bin/cryptogen generate --config=crypto-config.yaml --output ./certs 通过 ca 服务来生成 7. hyperledger fabric 中的Orderer 配置和安装文件的准备 建立一个存放orderer 配置文件的目录，用于以后复制到 orderer 主机上直接运行 orderer(支持 kafka) cd /root/fabric/fabric-deploy mkdir orderer.alcor.com cd orderer.alcor.com 先将bin/orderer以及证书复制到orderer.alcor.com目录中。 cd /root/fabric/fabric-deploy cp ./bin/orderer orderer.alcor.com cp -rf ./certs/ordererOrganizations/alcor.com/orderers/orderer.alcor.com/* ./orderer.alcor.com/ 然后准备orderer的配置文件orderer.alcor.com/orderer.yaml vi /root/fabric/fabric-deploy/orderer.alcor.com/orderer.yaml #内容如下 General: LedgerType: file ListenAddress: 0.0.0.0 ListenPort: 7050 TLS: Enabled: true PrivateKey: ./tls/server.key Certificate: ./tls/server.crt RootCAs: - ./tls/ca.crt # ClientAuthEnabled: false # ClientRootCAs: LogLevel: debug LogFormat: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; # GenesisMethod: provisional GenesisMethod: file GenesisProfile: SampleInsecureSolo GenesisFile: ./genesisblock LocalMSPDir: ./msp LocalMSPID: OrdererMSP Profile: Enabled: false Address: 0.0.0.0:6060 BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: FileLedger: Location: /opt/fabric/orderer/data Prefix: hyperledger-fabric-ordererledger RAMLedger: HistorySize: 1000 Kafka: Retry: ShortInterval: 5s ShortTotal: 10m LongInterval: 5m LongTotal: 12h NetworkTimeouts: DialTimeout: 10s ReadTimeout: 10s WriteTimeout: 10s Metadata: RetryBackoff: 250ms RetryMax: 3 Producer: RetryBackoff: 100ms RetryMax: 3 Consumer: RetryBackoff: 2s Verbose: false TLS: Enabled: false PrivateKey: #File: path/to/PrivateKey Certificate: #File: path/to/Certificate RootCAs: #File: path/to/RootCAs Version: 注意，orderer将被部署在目标机器（orderer.alcor.com）的/opt/fabric/orderer目录中，如果要部署在其它目录中，需要修改配置文件中路径。 这里需要用到一个data目录，存放orderer的数据: mkdir -p /root/fabric/fabric-deploy/orderer.alcor.com/data 8. hyperledger fabric 中的Peer 配置和安装文件的准备 建立4个存放peer 配置信息的目录 先设置 peer0.org1.alcor.com mkdir -p /root/fabric/fabric-deploy/peer0.org1.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer0.org1.alcor.com/ cp -rf certs/peerOrganizations/org1.alcor.com/peers/peer0.org1.alcor.com/* peer0.org1.alcor.com/ 注意： 一定要复制对应的 peer 和 org 的目录。否则会出现各种错误 生成 peer0.org1.alcor.com 的core.yaml 文件 这里是基于 fabric 1.3版本修改的core.yaml 文件。不兼容fabric 1.2 版本 并且是使用 CouchDB 取代缺省的 LevelDB vi /root/fabric/fabric-deploy/peer0.org1.alcor.com/core.yaml #内容如下: logging: level: info cauthdsl: warning gossip: warning grpc: error ledger: info msp: warning policies: warning peer: gossip: warning format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; peer: id: peer0.org1.alcor.com networkId: dev listenAddress: 0.0.0.0:7051 address: 0.0.0.0:7051 addressAutoDetect: false gomaxprocs: -1 keepalive: minInterval: 60s client: interval: 60s timeout: 20s deliveryClient: interval: 60s timeout: 20s gossip: bootstrap: peer0.org1.alcor.com:7051 useLeaderElection: true orgLeader: false endpoint: maxBlockCountToStore: 100 maxPropagationBurstLatency: 10ms maxPropagationBurstSize: 10 propagateIterations: 1 propagatePeerNum: 3 pullInterval: 4s pullPeerNum: 3 requestStateInfoInterval: 4s publishStateInfoInterval: 4s stateInfoRetentionInterval: publishCertPeriod: 10s skipBlockVerification: false dialTimeout: 3s connTimeout: 2s recvBuffSize: 20 sendBuffSize: 200 digestWaitTime: 1s requestWaitTime: 1500ms responseWaitTime: 2s aliveTimeInterval: 5s aliveExpirationTimeout: 25s reconnectInterval: 25s externalEndpoint: election: startupGracePeriod: 15s membershipSampleInterval: 1s leaderAliveThreshold: 10s leaderElectionDuration: 5s pvtData: pullRetryThreshold: 60s transientstoreMaxBlockRetention: 1000 pushAckTimeout: 3s btlPullMargin: 10 reconcileBatchSize: 10 reconcileSleepInterval: 5m tls: enabled: true clientAuthRequired: false cert: file: tls/server.crt key: file: tls/server.key rootcert: file: tls/ca.crt clientRootCAs: files: - tls/ca.crt clientKey: file: clientCert: file: authentication: timewindow: 15m fileSystemPath: /var/hyperledger/production BCCSP: Default: SW SW: Hash: SHA2 Security: 256 FileKeyStore: KeyStore: PKCS11: Library: Label: Pin: Hash: Security: FileKeyStore: KeyStore: mspConfigPath: msp localMspId: Org1MSP client: connTimeout: 3s deliveryclient: reconnectTotalTimeThreshold: 3600s connTimeout: 3s reConnectBackoffThreshold: 3600s localMspType: bccsp profile: enabled: false listenAddress: 0.0.0.0:6060 adminService: handlers: authFilters: - name: DefaultAuth - name: ExpirationCheck # This filter checks identity x509 certificate expiration decorators: - name: DefaultDecorator endorsers: escc: name: DefaultEndorsement library: validators: vscc: name: DefaultValidation library: validatorPoolSize: discovery: enabled: true authCacheEnabled: true authCacheMaxSize: 1000 authCachePurgeRetentionRatio: 0.75 orgMembersAllowedAccess: false vm: endpoint: unix:///var/run/docker.sock docker: tls: enabled: false ca: file: docker/ca.crt cert: file: docker/tls.crt key: file: docker/tls.key attachStdout: false hostConfig: NetworkMode: host Dns: LogConfig: Type: json-file Config: max-size: &quot;50m&quot; max-file: &quot;5&quot; Memory: 2147483648 chaincode: id: path: name: builder: $(DOCKER_NS)/fabric-ccenv:latest pull: false golang: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) dynamicLink: false car: runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) java: runtime: $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION) node: runtime: $(BASE_DOCKER_NS)/fabric-baseimage:$(ARCH)-$(BASE_VERSION) startuptimeout: 300s executetimeout: 30s mode: net keepalive: 0 system: +lifecycle: enable cscc: enable lscc: enable escc: enable vscc: enable qscc: enable systemPlugins: logging: level: info shim: warning format: &#39;%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}&#39; ledger: blockchain: state: stateDatabase: CouchDB #goleveldb totalQueryLimit: 100000 couchDBConfig: couchDBAddress: 127.0.0.1:5984 username: admin password: password maxRetries: 3 maxRetriesOnStartup: 10 requestTimeout: 35s internalQueryLimit: 1000 maxBatchUpdateSize: 1000 warmIndexesAfterNBlocks: 1 createGlobalChangesDB: false history: enableHistoryDatabase: true metrics: enabled: false reporter: statsd interval: 1s statsdReporter: address: 0.0.0.0:8125 flushInterval: 2s flushBytes: 1432 promReporter: listenAddress: 0.0.0.0:8080 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer0.org1.alcor.com/data 设置 peer1.org1.alcor.com mkdir -p /root/fabric/fabric-deploy/peer1.org1.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer1.org1.alcor.com/ cp -rf certs/peerOrganizations/org1.alcor.com/peers/peer1.org1.alcor.com/* peer1.org1.alcor.com/ 最后修改peer1.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer1.org1.alcor.com，这里直接用sed命令替换: cd /root/fabric/fabric-deploy cp peer0.org1.alcor.com/core.yaml peer1.org1.alcor.com sed -i &quot;s/peer0.org1.alcor.com/peer1.org1.alcor.com/g&quot; peer1.org1.alcor.com/core.yaml 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer1.org1.alcor.com/data 设置 peer0.org2.alcor.com mkdir -p /root/fabric/fabric-deploy/peer0.org2.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer0.org2.alcor.com/ cp -rf certs/peerOrganizations/org2.alcor.com/peers/peer0.org2.alcor.com/* peer0.org2.alcor.com/ 最后修改peer0.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer0.org2.alcor.com，这里直接用sed命令替换: cd /root/fabric/fabric-deploy cp peer0.org1.alcor.com/core.yaml peer0.org2.alcor.com sed -i &quot;s/peer0.org1.alcor.com/peer0.org2.alcor.com/g&quot; peer0.org2.alcor.com/core.yaml 将配置文件中Org1MSP替换成Org2MSP: sed -i &quot;s/Org1MSP/Org2MSP/g&quot; peer0.org2.alcor.com/core.yaml 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer0.org2.alcor.com/data 设置 peer1.org2.alcor.com mkdir -p /root/fabric/fabric-deploy/peer1.org2.alcor.com 复制 peer 执行文件和证书文件 cd /root/fabric/fabric-deploy cp bin/peer peer1.org2.alcor.com/ cp -rf certs/peerOrganizations/org2.alcor.com/peers/peer1.org2.alcor.com/* peer1.org2.alcor.com/ 最后修改peer0.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer1.org2.alcor.com，这里直接用sed命令替换: cd /root/fabric/fabric-deploy cp peer0.org1.alcor.com/core.yaml peer1.org2.alcor.com sed -i &quot;s/peer0.org1.alcor.com/peer1.org2.alcor.com/g&quot; peer1.org2.alcor.com/core.yaml 将配置文件中Org1MSP替换成Org2MSP: sed -i &quot;s/Org1MSP/Org2MSP/g&quot; peer1.org2.alcor.com/core.yaml 建立 data 目录 mkdir -p /root/fabric/fabric-deploy/peer1.org2.alcor.com/data 9. hyperledger fabric 中的 order 和 peer 目标机器上的 配置文件部署 把准备好的 order 和 peer 上的配置文件复制到宿主机器上。 由于所有配置文件都是在 cli.alcor.com 机器上准备的，所以通过以下步骤复制到相应的主机上。目标地址按照配置文件都是存放在宿主机器/opt/fabric 目录下。 复制到 orderer.alcor.com 上 # 在 orderer.alcor.com 机器上建立 /opt/fabric/orderer 目录 mkdir -p /opt/fabric/orderer #回到 cli.alcor.com机器上，把 orderer的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r orderer.alcor.com/* root@orderer.alcor.com:/opt/fabric/orderer/ 复制到peer0.org1.alcor.com # 在 peer0.org1.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer0.org1.alcor.com的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer0.org1.alcor.com/* root@peer0.org1.alcor.com:/opt/fabric/peer/ 复制到peer1.org1.alcor.com # 在 peer1.org1.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer1.org1.alcor.com 的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer1.org1.alcor.com/* root@peer1.org1.alcor.com:/opt/fabric/peer/ 复制到peer0.org2.alcor.com # 在 peer0.org2.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer0.org2.alcor.com的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer0.org2.alcor.com/* root@peer0.org2.alcor.com:/opt/fabric/peer/ 复制到peer1.org2.alcor.com # 在 peer1.org2.alcor.com 机器上建立 /opt/fabric/peer 目录 mkdir -p /opt/fabric/peer #回到 cli.alcor.com机器上，把 peer1.org2.alcor.com的配置文件复制过去 cd /root/fabric/fabric-deploy scp -r peer1.org2.alcor.com/* root@peer1.org2.alcor.com:/opt/fabric/peer/ 10. 准备创世纪区块 genesisblock(kafka 模式) 在 cli 机器的 /root/fabric/fabric-deploy/目录下，准备创世纪块的生成配置文件 configtx.yaml vi /root/fabric/fabric-deploy/configtx.yaml #文件内容如下： Organizations: - &amp;OrdererOrg Name: OrdererOrg ID: OrdererMSP MSPDir: ./certs/ordererOrganizations/alcor.com/msp - &amp;Org1 Name: Org1MSP ID: Org1MSP MSPDir: ./certs/peerOrganizations/org1.alcor.com/msp AnchorPeers: - Host: peer0.org1.alcor.com Port: 7051 - &amp;Org2 Name: Org2MSP ID: Org2MSP MSPDir: ./certs/peerOrganizations/org2.alcor.com/msp AnchorPeers: - Host: peer0.org2.alcor.com Port: 7051 Orderer: &amp;OrdererDefaults OrdererType: kafka Addresses: - orderer.alcor.com:7050 BatchTimeout: 2s BatchSize: MaxMessageCount: 10 AbsoluteMaxBytes: 99 MB PreferredMaxBytes: 512 KB Kafka: Brokers: - kafka.alcor.com:9092 # 可以填入多个kafka节点的地址 - kafka.alcor.com:9093 - kafka.alcor.com:9094 Organizations: Application: &amp;ApplicationDefaults Organizations: Profiles: TwoOrgsOrdererGenesis: Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Consortiums: SampleConsortium: Organizations: - *Org1 - *Org2 TwoOrgsChannel: Consortium: SampleConsortium Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 - *Org2 踩坑： 注意: 在1.2版本中。 配置文件的中的 Organizations 部分，必须在文件顶端。否则会出现: 如下错误 ![-w1436](media/15338798435067/15349240598525.jpg) 生成创世纪区块 cd /root/fabric/fabric-deploy ./bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./genesisblock -channelID genesis 生成创世纪区块文件 genesisblock ，并且指定创世区块的 channel id 是 genesis 然后把区块文件 genesisblock 复制到 oderer.alcor.com机器上 #登录到 cli 主机 cd /root/fabric/fabric-deploy scp ./genesisblock root@orderer.alcor.com:/opt/fabric/orderer 11. 启动 orderer 和 peer 启动 orderer # 进入 orderer.alcor.com 主机的 /opt/fabric/orderer 目录，建立一个startOrderer.sh 启动批处理文件.内容如下: ./orderer 2&gt;&amp;1 |tee log #启动 orderer chmod +x startOrderer.sh nohup ./startOrderer.sh &amp; 启动成功后，可以去任意一台 kafka 服务器上的控制台查看 topic 列表，是否有一个 genesis 的 channel。 /opt/kafka_2.11-1.1.1/bin/kafka-topics.sh --zookeeper 192.168.188.111:2181 --list 在4个 peer 上安装 couchDB 详细介绍查看 ： fabric peer 节点使用 CouchDB 来替换 LevelDB. 启动4个 peer #分别进入3个 peer 主机的 /opt/fabric/peer 目录，建立一个startPeer.sh 启动批处理文件，内容如下： ./peer node start 2&gt;&amp;1 |tee log #启动 peer ./startPeer.sh 12. 用户账号创建 在 cli 机器上建立存放用户账号信息的目录 cd /root/fabric/fabric-deploy mkdir users cd users 创立 org1的Admin 用户信息（对应到 peer0.org1.alcor.com 的节点） 创建保存 org1 的 Admin 用户信息的目录 cd /root/fabric/fabric-deploy/users mkdir Admin@org1.alcor.com cd Admin@org1.alcor.com 复制Admin@org1.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org1.alcor.com/users/Admin@org1.alcor.com/* /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/ 复制peer0.org1.alcor.com的配置文件(对应到 peer0.org1.alcor.com 的节点) cp /root/fabric/fabric-deploy/peer0.org1.aclor.com/core.yaml /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/Admin@org1.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer0.org1.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer0.org1.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer0.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer0.org1.aclor.com 的状态 ./peer.sh node status 创立 org1的 User1 用户信息 （对应到 peer1.org1.alcor.com 的节点） 创建保存 org1 的 User1 用户信息的目录（对应到 peer1.org1.alcor.com） 其实是 Admin 的用户证书，如果用的是User1的证书，在 peer node status 的时候，会出现错误： Error trying to connect to local peer: rpc error: code = Unknown desc = access denied cd /root/fabric/fabric-deploy/users mkdir User1@org1.alcor.com cd User1@org1.alcor.com 复制User1@org1.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org1.alcor.com/users/Admin@org1.alcor.com/* /root/fabric/fabric-deploy/users/User1@org1.alcor.com/ 复制peer1.org1.alcor.com的配置文件（对应到 peer1.org1.alcor.com） cp /root/fabric/fabric-deploy/peer1.org1.alcor.com/core.yaml /root/fabric/fabric-deploy/users/User1@org1.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/User1@org1.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer1.org1.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org1MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer1.org1.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer1.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer1.org1.alcor.com 的状态 ./peer.sh node status 创立 org2的Admin 用户信息（对应到 peer0.org2.alcor.com 的节点） 创建保存 org2 的 Admin 用户信息的目录 cd /root/fabric/fabric-deploy/users mkdir Admin@org2.alcor.com cd Admin@org2.alcor.com 复制Admin@org2.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org2.alcor.com/users/Admin@org2.alcor.com/* /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/ 复制peer0@org2.alcor.com的配置文件(对应到 peer0.org2.alcor.com 的节点) cp /root/fabric/fabric-deploy/peer0.org2.alcor.com/core.yaml /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/Admin@org2.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer0.org2.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org2MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer0.org2.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer0.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer0.org2.alcor.com 的状态 ./peer.sh node status 创立 org2的User1用户信息（对应到 peer1.org2.alcor.com 的节点） 其实是 Admin 的用户证书，如果用的是User1的证书，在 peer node status 的时候，会出现错误： Error trying to connect to local peer: rpc error: code = Unknown desc = access denied 创建保存 org2 的 User1 用户信息的目录 cd /root/fabric/fabric-deploy/users mkdir User1@org2.alcor.com cd User1@org2.alcor.com 复制Admin@org2.alcor.com用户的证书 cp -rf /root/fabric/fabric-deploy/certs/peerOrganizations/org2.alcor.com/users/Admin@org2.alcor.com/* /root/fabric/fabric-deploy/users/User1@org2.alcor.com/ 复制peer0@org2.alcor.com的配置文件(对应到 peer0.org2.alcor.com 的节点) cp /root/fabric/fabric-deploy/peer1.org2.alcor.com/core.yaml /root/fabric/fabric-deploy/users/User1@org2.alcor.com/ 创建测试脚本(peer.sh) #!/bin/bash cd &quot;/root/fabric/fabric-deploy/users/User1@org2.alcor.com&quot; PATH=`pwd`/../../bin:$PATH export FABRIC_CFG_PATH=`pwd` export CORE_PEER_TLS_ENABLED=true export CORE_PEER_TLS_CERT_FILE=./tls/client.crt export CORE_PEER_TLS_KEY_FILE=./tls/client.key export CORE_PEER_MSPCONFIGPATH=./msp export CORE_PEER_ADDRESS=peer1.org2.alcor.com:7051 export CORE_PEER_LOCALMSPID=Org2MSP export CORE_PEER_TLS_ROOTCERT_FILE=./tls/ca.crt export CORE_PEER_ID=peer1.org2.alcor.com export CORE_LOGGING_LEVEL=DEBUG peer $* 注意： 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 peer0.org1.alcor.com 节点对应 运行 peer.sh 来查看节点 peer0.org2.alcor.com 的状态 ./peer.sh node status 13. channel 的准备和创建 踩坑：channel ID 不能含有大写字母（myTestChannel , myChannel 这种命名是不行的，在创建 channel 的时候，会报错） initializing configtx manager failed: bad channel ID: channel ID &#39;myTestChannel&#39; contains illegal characters 准备channel 文件。用configtxgen生成channel文件 cd /root/fabric/fabric-deploy/ ./bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx mychannel.tx -channelID mychannel 针对每个 org 的peer生成一个anchor文件，每个组织只需要一个： ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP 生成的Org1MSPanchors.tx和Org2MSPanchors.tx备用。 因为下一步操作中要访问orderer.alcor.com，所以需要将验证orderer.alcor.com的根证书复制到用户目录中： cd /root/fabric/fabric-deploy cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/Admin\\@org1.alcor.com/ cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/User1\\@org1.alcor.com/ cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/Admin\\@org2.alcor.com/ cp /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem /root/fabric/fabric-deploy/users/User1\\@org2.alcor.com/ 14. 创建 channel 在Admin@org1.alcor.com目录中执行下面的命令，： cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh channel create -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/mychannel.tx --tls true --cafile tlsca.alcor.com-cert.pem 执行完成后，会生成一个mychannel.block文件. 这个文件非常重要!所有加入到这个 channel 里面的 peer，都需要用到这个文件 将mychannel.block复制一份到User1@org1.alcor.com 和 Admin@org2.alcor.com、User1@org2.alcor.com中备用 cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block /root/fabric/fabric-deploy/users/User1@org1.alcor.com/ cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/ cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block /root/fabric/fabric-deploy/users/User1@org2.alcor.com/ 15.把 4个 peer加入到 channel 中 把peer0.org1.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 把peer1.org1.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com #这个其实还是org1.alcor.com 的 Admin 用户 ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 把peer0.org2.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 把peer1.org2.alcor.com 加入到 channle 中 cd /root/fabric/fabric-deploy/users/User1@org2.alcor.com #这个其实还是org2.alcor.com 的 Admin 用户 ./peer.sh channel join -b mychannel.block #控制台返回成功后，可以用下面命令来查看 ./peer.sh channel list 16.设置锚点 peer . 需要每个组织指定一个anchor peer，anchor peer是组织用来接收orderer下发的区块的peer。 把org1的 anchor peer 设置为 peer0.org1.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh channel update -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/Org1MSPanchors.tx --tls true --cafile ./tlsca.alcor.com-cert.pem 把org2的 anchor peer 设置为 peer0.org2.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh channel update -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/Org2MSPanchors.tx --tls true --cafile ./tlsca.alcor.com-cert.pem 17. go 版本的 chaincode 的安装和部署（在 cli 主机上操作） 安装 go 环境 go 的下载官网 https://golang.org/dl/ 以 root 用户安装 wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz tar -xvf go1.10.3.linux-386.tar.gz mv ./go /usr/local #修改 /etc/profile，增加 如下2行内容 export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin #使得环境变量生效 source /etc/profile #确定 go 的安装成功和版本信息 go version #查看 go 的环境 go env 拉取 demo 的 chaincode 这个需要先安装 gcc 组件 cd ~ go get github.com/roamerxv/chaincode/fabric/examples/go/demo 完成后，生成一个~/go 目录。下面有 src 和bin 目录。/root/go/src/github.com 目录下有个fabric 和 roamerxv 这2个目录。 测试编译 demo.go cd /root/go/src/github.com/roamerxv/chaincode/fabric/examples/go/demo go build #确定生成 demo 可执行文件，说明go 配置正常 chaincode 的打包 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode package demo-pack.out -n demo -v 0.0.1 -s -S -p github.com/roamerxv/chaincode/fabric/examples/go/demo 成功后生成一个 demo-pack.out 文件 chaincode 的签署 ./peer.sh chaincode signpackage demo-pack.out signed-demo-pack.out 成功后，生成 signed-demo-pack.out chaincode 的安装 ./peer.sh chaincode install ./signed-demo-pack.out 由于 peer.sh 中指定了CORE_PEER_ADDRESS=peer0.org1.alcor.com:7051 ，所以，这个安装其实是把 chaincode 文件复制到 peer0.org1.alcor.com 这台机器的 /var/hyperledger/production/chaincodes/ 目录下. 文件名是 demo.0.0.1. 而 /var/hyperledger/production/chaincodes/ 这个路径是由 core.yaml 里面的 peer.fileSystemPath 这个属性指定的。 #同时，可以在 cli 上，通过以下命令查看 peer 上的 chaincode 信息 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode list --installed 注意: 这个安装需要在涉及到的所有 peer 上进行一遍,包括另外的组织 org2. 而且一定要用 admin用户来安装。 所以，把签署后的 signed-demo-pack.out 复制到 ~/fabric/fabric-deploy/users/User1@org1.alcor.com , ~/fabric/fabric-deploy/users/Admin@org2.alcor.com 目录下. cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out /root/fabric/fabric-deploy/users/User1@org1.alcor.com cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out /root/fabric/fabric-deploy/users/Admin@org2.alcor.com cp /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out /root/fabric/fabric-deploy/users/User1@org2.alcor.com #进入另外3个目录，再次安装 chaincode 到对应的 peer 上 #这个是 安装到 peer1.org1.alcor.com cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com ./peer.sh chaincode install ./signed-demo-pack.out #这个是 安装到 peer0.org2.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh chaincode install ./signed-demo-pack.out #这个是 安装到 peer1.org2.alcor.com cd /root/fabric/fabric-deploy/users/User1@org2.alcor.com ./peer.sh chaincode install ./signed-demo-pack.out chaincode 的初始化 合约安装之后，需要且只需要进行一次初始化，只能由签署合约的用户进行初始化,并且所有的 peer 上的 docker 服务已经启动。谁签署了 chaincode，谁来进行实例化。 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode instantiate -o orderer.alcor.com:7050 --tls true --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo -v 0.0.1 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 第一次进行合约初始化的时候的会比较慢，因为peer 上需要创建、启动容器。 chaincode的调用 cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode invoke -o orderer.alcor.com:7050 --tls true --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key1&quot;,&quot;key1value中文isabc&quot;]}&#39; chaincode 的调用，可以调用任意一台安装了这个 chaincode 的peer。这个时候被调用的 peer 上会启动相应的 chaincode 的 docker。 进行查询操作时，不需要指定orderer，例如： cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com ./peer.sh chaincode query -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key1&quot;]}&#39; chaincode 的更新 新合约的打包和签署 cd /home/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode package demo-pack-2.out -n demo -v 0.0.2 -s -S -p github.com/roamerxv/chaincode/fabric/examples/go/demo ./peer.sh chaincode signpackage demo-pack-2.out signed-demo-pack-2.out 新的合约也需要在每个peer上单独安装。 #安装到peer0.org1.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode install ./signed-demo-pack-2.out #安装到peer1.org1.alcor.com cd /root/fabric/fabric-deploy/users/User1@org1.alcor.com ./peer.sh chaincode install ../Admin@org1.alcor.com/signed-demo-pack-2.out #安装到peer0.org2.alcor.com cd /root/fabric/fabric-deploy/users/Admin@org2.alcor.com ./peer.sh chaincode install ../Admin@org1.alcor.com/signed-demo-pack-2.out #安装到peer1.org2.alcor.com cd /root/fabric/fabric-deploy/users/User1@org2.alcor.com ./peer.sh chaincode install ../Admin@org1.alcor.com/signed-demo-pack-2.out 更新的合约不需要初始化，需要进行更新操作。 cd /home/fabric/fabric-deploy/users/Admin@org1.alcor.com ./peer.sh chaincode upgrade -o orderer.alcor.com:7050 --tls true --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo -v 0.0.2 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR(&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 查询key的历史记录 ./peer.sh chaincode query -C mychannel -n demo -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key1&quot;]}&#39; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/10/01/c7778e5e8744d8e766c55110ee95f231.html","headline":"fabric 1.3 ，全手动部署到5台机器上.支持 kafka 模式的共识机制和 couchdb 存储","dateModified":"2018-10-01T00:00:00+08:00","datePublished":"2018-10-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/10/01/c7778e5e8744d8e766c55110ee95f231.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>fabric 1.3 ，全手动部署到5台机器上.支持 kafka 模式的共识机制和 couchdb 存储</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/remote_roamer/article/details/82914666 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1><a id="fabric_13__5_kafka__couchdb__1"></a>fabric 1.3 ，全手动部署到5台机器上.支持 kafka 模式的共识机制和 couchdb 存储</h1> 
  <p>参考文档<br> <a href="https://hyperledger-fabric.readthedocs.io/en/release-1.3/" rel="nofollow">https://hyperledger-fabric.readthedocs.io/en/release-1.3/</a><br> <a href="https://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html" rel="nofollow">https://www.lijiaocn.com/项目/2018/04/26/hyperledger-fabric-deploy.html</a><br> <a href="https://hyperledgercn.github.io/hyperledgerDocs/" rel="nofollow">https://hyperledgercn.github.io/hyperledgerDocs/</a></p> 
  <p>系统环境：centos 7 64位<br> docker<br> docker-compose</p> 
  <h2><a id="1_docker_11"></a>1. 安装docker</h2> 
  <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">sudo</span> yum -y remove docker docker-common container-selinux
<span class="token function">sudo</span> yum -y remove docker-selinux

<span class="token function">sudo</span> yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

yum update

yum <span class="token function">install</span> docker-engine

systemctl <span class="token function">enable</span> docker

systemctl restart docker

</code></pre> 
  <h2><a id="2__dockercompose_29"></a>2. 安装docker-compose</h2> 
  <p>docker-compose是docker集群管理工具，可自定义一键启动多个docker container。<br> 官网二进制发布:<br> <a href="https://github.com/docker/compose/releases" rel="nofollow">https://github.com/docker/compose/releases</a><br> 安装手册见网站 :<br> <a href="https://docs.docker.com/compose/install/" rel="nofollow">https://docs.docker.com/compose/install/</a><br> 安装命令如下:</p> 
  <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">curl</span> -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -s<span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span> <span class="token operator">&gt;</span> /usr/local/bin/docker-compose

<span class="token function">chmod</span> +x /usr/local/bin/docker-compose

<span class="token function">chmod</span> +x /usr/local/bin/docker-compose

docker-compose -v
</code></pre> 
  <h2><a id="3_50"></a>3.准备环境。</h2> 
  <table> 
   <thead> 
    <tr> 
     <th align="left">IP</th> 
     <th align="left">host</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td align="left">192.168.188.110</td> 
     <td align="left"><a href="http://cli.alcor.com" rel="nofollow">cli.alcor.com</a></td> 
    </tr> 
    <tr> 
     <td align="left">192.168.188.111</td> 
     <td align="left"><a href="http://kafka.alcor.com" rel="nofollow">kafka.alcor.com</a></td> 
    </tr> 
    <tr> 
     <td align="left">192.168.188.120</td> 
     <td align="left"><a href="http://orderer.alcor.com" rel="nofollow">orderer.alcor.com</a></td> 
    </tr> 
    <tr> 
     <td align="left">192.168.188.221</td> 
     <td align="left"><a href="http://peer0.org1.alcor.com" rel="nofollow">peer0.org1.alcor.com</a></td> 
    </tr> 
    <tr> 
     <td align="left">192.168.188.222</td> 
     <td align="left"><a href="http://peer1.org1.alcor.com" rel="nofollow">peer1.org1.alcor.com</a></td> 
    </tr> 
    <tr> 
     <td align="left">192.168.188.223</td> 
     <td align="left"><a href="http://peer0.org2.alcor.com" rel="nofollow">peer0.org2.alcor.com</a></td> 
    </tr> 
    <tr> 
     <td align="left">192.168.188.224</td> 
     <td align="left"><a href="http://peer1.org2.alcor.com" rel="nofollow">peer1.org2.alcor.com</a></td> 
    </tr> 
   </tbody> 
  </table>
  <p>每台机器的 hostname 中都增加 ip 解析</p> 
  <pre class=" language-bash"><code class="prism  language-bash">vim /etc/hosts

192.168.188.110   cli.alcor.com
192.168.188.111   kafka.alcor.com
192.168.188.120   orderer.alcor.com
192.168.188.221   peer0.org1.alcor.com
192.168.188.222   peer1.org1.alcor.com
192.168.188.223   peer0.org2.alcor.com
192.168.188.224   peer1.org2.alcor.com
</code></pre> 
  <p>工作目录是 /root/fabric<br> 在/root/fabric目录下建立2个子目录</p> 
  <ul> 
   <li>/root/fabric/fabric-deploy 存放部署和配置内容</li> 
   <li>/root/fabric/fabric-images 存放自己制作的 docker images</li> 
  </ul> 
  <h2><a id="4_kafka__zookeeper_81"></a>4.安装 kafka 和 zookeeper</h2> 
  <p>我在这里使用 docker-compose 安装 zookeeper 和 kafka（3个 kafka 节点） 环境</p> 
  <p>配置文件存放在<br> /Users/roamer/Documents/Docker/本地虚拟机/kafka 目录下</p> 
  <p>kafka 测试流程参考文档：<br> <a>kafka 的使用</a></p> 
  <h2><a id="5_fabric_13_91"></a>5.下载 fabric 1.3</h2> 
  <p>对应网站查看版本信息<br> <a href="https://nexus.hyperledger.org/#nexus-search;quick~fabric%201.3" rel="nofollow">https://nexus.hyperledger.org/#nexus-search;quick~fabric 1.3</a></p> 
  <ol> 
   <li> <p>下载文件自己安装</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment">#登录 cli 主机</span>
<span class="token function">mkdir</span> -p /root/fabric/fabric-deploy 
<span class="token function">cd</span>  ~/fabric/fabric-deploy
<span class="token function">wget</span> https://nexus.hyperledger.org/service/local/repositories/releases/content/org/hyperledger/fabric/hyperledger-fabric-1.3.0-stable/linux-amd64.1.3.0-stable-fdc4889/hyperledger-fabric-1.3.0-stable-linux-amd64.1.3.0-stable-fdc4889.tar.gz
</code></pre> </li> 
   <li> <p>用 md5sum 命令进行文件校验</p> </li> 
   <li> <p>解压fabric</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">tar</span> -xvf hyperledger-fabric-1.3.0-stable-linux-amd64.1.3.0-stable-fdc4889.tar.gz
</code></pre> </li> 
   <li> <p>理解 bin 目录和 config 目录下的文件</p> </li> 
  </ol> 
  <h2><a id="6_hyperledger__114"></a>6. hyperledger 的证书准备</h2> 
  <p>证书的准备方式有两种，一种用cryptogen命令生成，一种是通过fabric-ca服务生成。</p> 
  <ol> 
   <li> <p>通过cryptogen 来生成</p> 
    <ul> 
     <li> <p>创建一个配置文件crypto-config.yaml，这里配置了两个组织，org1和 org的Template 的 Count是2，表示各自两个peer。</p> <pre class=" language-yaml"><code class="prism  language-yaml">vim crypto<span class="token punctuation">-</span>config.yaml

<span class="token comment">#文件内容如下：</span>
<span class="token key atrule">OrdererOrgs</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">Name</span><span class="token punctuation">:</span> Orderer
    <span class="token key atrule">Domain</span><span class="token punctuation">:</span> alcor.com
    <span class="token key atrule">Specs</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">Hostname</span><span class="token punctuation">:</span> orderer
<span class="token key atrule">PeerOrgs</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">Name</span><span class="token punctuation">:</span> Org1
    <span class="token key atrule">Domain</span><span class="token punctuation">:</span> org1.alcor.com
    <span class="token key atrule">Template</span><span class="token punctuation">:</span>
      <span class="token key atrule">Count</span><span class="token punctuation">:</span> <span class="token number">2</span>
    <span class="token key atrule">Users</span><span class="token punctuation">:</span>
      <span class="token key atrule">Count</span><span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token punctuation">-</span> <span class="token key atrule">Name</span><span class="token punctuation">:</span> Org2
    <span class="token key atrule">Domain</span><span class="token punctuation">:</span> org2.alcor.com
    <span class="token key atrule">Template</span><span class="token punctuation">:</span>
      <span class="token key atrule">Count</span><span class="token punctuation">:</span> <span class="token number">2</span>
    <span class="token key atrule">Users</span><span class="token punctuation">:</span>
      <span class="token key atrule">Count</span><span class="token punctuation">:</span> <span class="token number">1</span>
</code></pre> </li> 
     <li> <p>生成证书, 所有的文件存放在 /root/fabric/fabric-deploy/certs 目录下</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy
./bin/cryptogen generate --config<span class="token operator">=</span>crypto-config.yaml --output ./certs
</code></pre> </li> 
    </ul> </li> 
   <li> <p>通过 ca 服务来生成</p> </li> 
  </ol> 
  <h2><a id="7_hyperledger_fabric_Orderer__154"></a>7. hyperledger fabric 中的Orderer 配置和安装文件的准备</h2> 
  <ol> 
   <li> <p>建立一个存放orderer 配置文件的目录，用于以后复制到 orderer 主机上直接运行 orderer(支持 kafka)</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">mkdir</span> orderer.alcor.com
<span class="token function">cd</span> orderer.alcor.com
</code></pre> </li> 
   <li> <p>先将bin/orderer以及证书复制到orderer.alcor.com目录中。</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">cp</span> ./bin/orderer orderer.alcor.com
<span class="token function">cp</span> -rf ./certs/ordererOrganizations/alcor.com/orderers/orderer.alcor.com/* ./orderer.alcor.com/
</code></pre> </li> 
   <li> <p><a href="http://xn--ordererorderer-r79v624awwjzkxmj8c328bdkxaop7bo5zf.alcor.com/orderer.yaml" rel="nofollow">然后准备orderer的配置文件orderer.alcor.com/orderer.yaml</a></p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">vi</span> /root/fabric/fabric-deploy/orderer.alcor.com/orderer.yaml
<span class="token comment">#内容如下</span>
General:
    LedgerType: <span class="token function">file</span>
    ListenAddress: 0.0.0.0
    ListenPort: 7050
    TLS:
        Enabled: <span class="token boolean">true</span>
        PrivateKey: ./tls/server.key
        Certificate: ./tls/server.crt
        RootCAs:
          - ./tls/ca.crt
<span class="token comment"># ClientAuthEnabled: false</span>
<span class="token comment"># ClientRootCAs:</span>
    LogLevel: debug
    LogFormat: <span class="token string">'%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}'</span>
<span class="token comment"># GenesisMethod: provisional</span>
    GenesisMethod: <span class="token function">file</span>
    GenesisProfile: SampleInsecureSolo
    GenesisFile: ./genesisblock
    LocalMSPDir: ./msp
    LocalMSPID: OrdererMSP
    Profile:
        Enabled: <span class="token boolean">false</span>
        Address: 0.0.0.0:6060
    BCCSP:
        Default: SW
        SW:
            Hash: SHA2
            Security: 256
            FileKeyStore:
                KeyStore:
FileLedger:
    Location:  /opt/fabric/orderer/data
    Prefix: hyperledger-fabric-ordererledger
RAMLedger:
    HistorySize: 1000
Kafka:
    Retry:
        ShortInterval: 5s
        ShortTotal: 10m
        LongInterval: 5m
        LongTotal: 12h
        NetworkTimeouts:
            DialTimeout: 10s
            ReadTimeout: 10s
            WriteTimeout: 10s
        Metadata:
            RetryBackoff: 250ms
            RetryMax: 3
        Producer:
            RetryBackoff: 100ms
            RetryMax: 3
        Consumer:
            RetryBackoff: 2s
    Verbose: <span class="token boolean">false</span>
    TLS:
      Enabled: <span class="token boolean">false</span>
      PrivateKey:
        <span class="token comment">#File: path/to/PrivateKey</span>
      Certificate:
        <span class="token comment">#File: path/to/Certificate</span>
      RootCAs:
        <span class="token comment">#File: path/to/RootCAs</span>
    Version:
</code></pre> <font color="red"> 注意，orderer将被部署在目标机器（orderer.alcor.com）的/opt/fabric/orderer目录中，如果要部署在其它目录中，需要修改配置文件中路径。</font> <p>这里需要用到一个data目录，存放orderer的数据:</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">mkdir</span> -p /root/fabric/fabric-deploy/orderer.alcor.com/data
</code></pre> </li> 
  </ol> 
  <h2><a id="8_hyperledger_fabric_Peer__248"></a>8. hyperledger fabric 中的Peer 配置和安装文件的准备</h2> 
  <p>建立4个存放peer 配置信息的目录</p> 
  <ol> 
   <li> <p><font size="+2">先设置 peer0.org1.alcor.com</font></p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">mkdir</span> -p  /root/fabric/fabric-deploy/peer0.org1.alcor.com
</code></pre> 
    <ol> 
     <li> <p>复制 peer 执行文件和证书文件</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">cp</span> bin/peer peer0.org1.alcor.com/
<span class="token function">cp</span> -rf certs/peerOrganizations/org1.alcor.com/peers/peer0.org1.alcor.com/* peer0.org1.alcor.com/
</code></pre> <font color="red"> 注意： 一定要复制对应的 peer 和 org 的目录。否则会出现各种错误 </font> </li> 
     <li> <p>生成 <a href="http://peer0.org1.alcor.com" rel="nofollow">peer0.org1.alcor.com</a> 的core.yaml 文件</p> <font color="red"> 这里是基于 fabric 1.3版本修改的core.yaml 文件。不兼容fabric 1.2 版本 并且是使用 CouchDB 取代缺省的 LevelDB </font> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">vi</span> /root/fabric/fabric-deploy/peer0.org1.alcor.com/core.yaml
<span class="token comment">#内容如下:</span>
logging:
    level:       info
    cauthdsl:   warning
    gossip:     warning
    grpc:       error
    ledger:     info
    msp:        warning
    policies:   warning
    peer:
        gossip: warning

    format: <span class="token string">'%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}'</span>

peer:

    id: peer0.org1.alcor.com

    networkId: dev

    listenAddress: 0.0.0.0:7051

    address: 0.0.0.0:7051

    addressAutoDetect: <span class="token boolean">false</span>

    gomaxprocs: -1

    keepalive:
        minInterval: 60s
        client:
            interval: 60s
            timeout: 20s
        deliveryClient:
            interval: 60s
            timeout: 20s

    gossip:
        bootstrap: peer0.org1.alcor.com:7051

        useLeaderElection: <span class="token boolean">true</span>
        orgLeader: <span class="token boolean">false</span>

        endpoint:
        maxBlockCountToStore: 100
        maxPropagationBurstLatency: 10ms
        maxPropagationBurstSize: 10
        propagateIterations: 1
        propagatePeerNum: 3
        pullInterval: 4s
        pullPeerNum: 3
        requestStateInfoInterval: 4s
        publishStateInfoInterval: 4s
        stateInfoRetentionInterval:
        publishCertPeriod: 10s
        skipBlockVerification: <span class="token boolean">false</span>
        dialTimeout: 3s
        connTimeout: 2s
        recvBuffSize: 20
        sendBuffSize: 200
        digestWaitTime: 1s
        requestWaitTime: 1500ms
        responseWaitTime: 2s
        aliveTimeInterval: 5s
        aliveExpirationTimeout: 25s
        reconnectInterval: 25s
        externalEndpoint:
        election:
            startupGracePeriod: 15s
            membershipSampleInterval: 1s
            leaderAliveThreshold: 10s
            leaderElectionDuration: 5s
        pvtData:
            pullRetryThreshold: 60s
            transientstoreMaxBlockRetention: 1000
            pushAckTimeout: 3s
            btlPullMargin: 10
            reconcileBatchSize: 10
            reconcileSleepInterval: 5m

    tls:
        enabled:  <span class="token boolean">true</span>
        clientAuthRequired: <span class="token boolean">false</span>
        cert:
            file: tls/server.crt
        key:
            file: tls/server.key
        rootcert:
            file: tls/ca.crt
        clientRootCAs:
            files:
              - tls/ca.crt
        clientKey:
            file:
        clientCert:
            file:

    authentication:
        timewindow: 15m

    fileSystemPath: /var/hyperledger/production

    BCCSP:
        Default: SW
        SW:
            Hash: SHA2
            Security: 256
            FileKeyStore:
                KeyStore:
        PKCS11:
            Library:
            Label:
            Pin:
            Hash:
            Security:
            FileKeyStore:
                KeyStore:

    mspConfigPath: msp

    localMspId: Org1MSP

    client:
        connTimeout: 3s

    deliveryclient:
        reconnectTotalTimeThreshold: 3600s

        connTimeout: 3s

        reConnectBackoffThreshold: 3600s

    localMspType: bccsp

    profile:
        enabled:     <span class="token boolean">false</span>
        listenAddress: 0.0.0.0:6060
    adminService:
    handlers:
        authFilters:
          -
            name: DefaultAuth
          -
            name: ExpirationCheck    <span class="token comment"># This filter checks identity x509 certificate expiration</span>
        decorators:
          -
            name: DefaultDecorator
        endorsers:
          escc:
            name: DefaultEndorsement
            library:
        validators:
          vscc:
            name: DefaultValidation
            library:
    validatorPoolSize:
    discovery:
        enabled: <span class="token boolean">true</span>
        authCacheEnabled: <span class="token boolean">true</span>
        authCacheMaxSize: 1000
        authCachePurgeRetentionRatio: 0.75
        orgMembersAllowedAccess: <span class="token boolean">false</span>

vm:
    endpoint: unix:///var/run/docker.sock
    docker:
        tls:
            enabled: <span class="token boolean">false</span>
            ca:
                file: docker/ca.crt
            cert:
                file: docker/tls.crt
            key:
                file: docker/tls.key
        attachStdout: <span class="token boolean">false</span>
        hostConfig:
            NetworkMode: host
            Dns:
            LogConfig:
                Type: json-file
                Config:
                    max-size: <span class="token string">"50m"</span>
                    max-file: <span class="token string">"5"</span>
            Memory: 2147483648


chaincode:
    id:
        path:
        name:

    builder: <span class="token variable"><span class="token variable">$(</span>DOCKER_NS<span class="token variable">)</span></span>/fabric-ccenv:latest
    pull: <span class="token boolean">false</span>

    golang:
        runtime: <span class="token variable"><span class="token variable">$(</span>BASE_DOCKER_NS<span class="token variable">)</span></span>/fabric-baseos:<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>BASE_VERSION<span class="token variable">)</span></span>
        dynamicLink: <span class="token boolean">false</span>

    car:
        runtime: <span class="token variable"><span class="token variable">$(</span>BASE_DOCKER_NS<span class="token variable">)</span></span>/fabric-baseos:<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>BASE_VERSION<span class="token variable">)</span></span>

    java:
        runtime: <span class="token variable"><span class="token variable">$(</span>DOCKER_NS<span class="token variable">)</span></span>/fabric-javaenv:<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>PROJECT_VERSION<span class="token variable">)</span></span>

    node:
        runtime: <span class="token variable"><span class="token variable">$(</span>BASE_DOCKER_NS<span class="token variable">)</span></span>/fabric-baseimage:<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>BASE_VERSION<span class="token variable">)</span></span>
    startuptimeout: 300s

    executetimeout: 30s
    mode: net
    keepalive: 0
    system:
        +lifecycle: <span class="token function">enable</span>
        cscc: <span class="token function">enable</span>
        lscc: <span class="token function">enable</span>
        escc: <span class="token function">enable</span>
        vscc: <span class="token function">enable</span>
        qscc: <span class="token function">enable</span>
    systemPlugins:
    logging:
      level:  info
      shim:   warning
      format: <span class="token string">'%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -&gt; %{level:.4s} %{id:03x}%{color:reset} %{message}'</span>


ledger:

  blockchain:

  state:
    stateDatabase: CouchDB     <span class="token comment">#goleveldb</span>
    totalQueryLimit: 100000
    couchDBConfig:
       couchDBAddress: 127.0.0.1:5984
       username:    admin
       password:    password
       maxRetries: 3
       maxRetriesOnStartup: 10
       requestTimeout: 35s
       internalQueryLimit: 1000
       maxBatchUpdateSize: 1000
       warmIndexesAfterNBlocks: 1
       createGlobalChangesDB: <span class="token boolean">false</span>

  history:
    enableHistoryDatabase: <span class="token boolean">true</span>


metrics:
        enabled: <span class="token boolean">false</span>
        reporter: statsd
        interval: 1s
        statsdReporter:
              address: 0.0.0.0:8125
          flushInterval: 2s
          flushBytes: 1432

    promReporter:
          listenAddress: 0.0.0.0:8080

</code></pre> </li> 
     <li> <p>建立 data 目录</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">mkdir</span> -p /root/fabric/fabric-deploy/peer0.org1.alcor.com/data
</code></pre> </li> 
    </ol> </li> 
   <li> <p><font color="green" size="+2">设置 peer1.org1.alcor.com</font></p> <pre class=" language-bash"><code class="prism  language-bash">   <span class="token function">mkdir</span> -p /root/fabric/fabric-deploy/peer1.org1.alcor.com
</code></pre> 
    <ol> 
     <li> <p>复制 peer 执行文件和证书文件</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">cp</span> bin/peer     peer1.org1.alcor.com/
<span class="token function">cp</span> -rf certs/peerOrganizations/org1.alcor.com/peers/peer1.org1.alcor.com/* peer1.org1.alcor.com/
</code></pre> </li> 
    </ol> </li> 
   <li> <p><a href="http://xn--peer1-3u3hl0wv60b6ld.org1.alcor.com/core.yml%EF%BC%8C%E5%B0%86%E5%85%B6%E4%B8%AD%E7%9A%84peer0.org1.alcor.com%E4%BF%AE%E6%94%B9%E4%B8%BApeer1.org1.alcor.com%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9B%B4%E6%8E%A5%E7%94%A8sed%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2:" rel="nofollow">最后修改peer1.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer1.org1.alcor.com，这里直接用sed命令替换:</a></p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">cp</span> peer0.org1.alcor.com/core.yaml  peer1.org1.alcor.com
<span class="token function">sed</span> -i <span class="token string">"s/peer0.org1.alcor.com/peer1.org1.alcor.com/g"</span> peer1.org1.alcor.com/core.yaml
</code></pre> </li> 
   <li> <p>建立 data 目录</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">mkdir</span> -p /root/fabric/fabric-deploy/peer1.org1.alcor.com/data
</code></pre> </li> 
   <li> <p><font color="cyan" size="+2"> 设置 peer0.org2.alcor.com</font></p> <pre class=" language-bash"><code class="prism  language-bash">    <span class="token function">mkdir</span> -p /root/fabric/fabric-deploy/peer0.org2.alcor.com
</code></pre> 
    <ol> 
     <li> <p>复制 peer 执行文件和证书文件</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">cp</span> bin/peer     peer0.org2.alcor.com/
<span class="token function">cp</span> -rf certs/peerOrganizations/org2.alcor.com/peers/peer0.org2.alcor.com/* peer0.org2.alcor.com/
</code></pre> </li> 
     <li> <p><a href="http://xn--peer0-3u3hl0wv60b6ld.org1.alcor.com/core.yml%EF%BC%8C%E5%B0%86%E5%85%B6%E4%B8%AD%E7%9A%84peer0.org1.alcor.com%E4%BF%AE%E6%94%B9%E4%B8%BApeer0.org2.alcor.com%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9B%B4%E6%8E%A5%E7%94%A8sed%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2:" rel="nofollow">最后修改peer0.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer0.org2.alcor.com，这里直接用sed命令替换:</a></p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">cp</span> peer0.org1.alcor.com/core.yaml  peer0.org2.alcor.com
<span class="token function">sed</span> -i <span class="token string">"s/peer0.org1.alcor.com/peer0.org2.alcor.com/g"</span> peer0.org2.alcor.com/core.yaml
</code></pre> </li> 
    </ol> </li> 
   <li> <p>将配置文件中Org1MSP替换成Org2MSP:</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">sed</span> -i <span class="token string">"s/Org1MSP/Org2MSP/g"</span> peer0.org2.alcor.com/core.yaml    
</code></pre> </li> 
   <li> <p>建立 data 目录</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">mkdir</span> -p /root/fabric/fabric-deploy/peer0.org2.alcor.com/data
</code></pre> </li> 
   <li> <p><font color="blue" size="+2"> 设置 peer1.org2.alcor.com</font></p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">mkdir</span> -p /root/fabric/fabric-deploy/peer1.org2.alcor.com
</code></pre> 
    <ol> 
     <li> <p>复制 peer 执行文件和证书文件</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">cp</span> bin/peer     peer1.org2.alcor.com/
<span class="token function">cp</span> -rf certs/peerOrganizations/org2.alcor.com/peers/peer1.org2.alcor.com/* peer1.org2.alcor.com/
</code></pre> </li> 
     <li> <p><a href="http://xn--peer0-3u3hl0wv60b6ld.org1.alcor.com/core.yml%EF%BC%8C%E5%B0%86%E5%85%B6%E4%B8%AD%E7%9A%84peer0.org1.alcor.com%E4%BF%AE%E6%94%B9%E4%B8%BApeer1.org2.alcor.com%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9B%B4%E6%8E%A5%E7%94%A8sed%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2:" rel="nofollow">最后修改peer0.org1.alcor.com/core.yml，将其中的peer0.org1.alcor.com修改为peer1.org2.alcor.com，这里直接用sed命令替换:</a></p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">cp</span> peer0.org1.alcor.com/core.yaml  peer1.org2.alcor.com
<span class="token function">sed</span> -i <span class="token string">"s/peer0.org1.alcor.com/peer1.org2.alcor.com/g"</span> peer1.org2.alcor.com/core.yaml
</code></pre> </li> 
    </ol> </li> 
   <li> <p>将配置文件中Org1MSP替换成Org2MSP:</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">sed</span> -i <span class="token string">"s/Org1MSP/Org2MSP/g"</span> peer1.org2.alcor.com/core.yaml    
</code></pre> </li> 
   <li> <p>建立 data 目录</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">mkdir</span> -p /root/fabric/fabric-deploy/peer1.org2.alcor.com/data
</code></pre> </li> 
  </ol> 
  <h2><a id="9_hyperledger_fabric__order__peer___641"></a>9. hyperledger fabric 中的 order 和 peer 目标机器上的 配置文件部署</h2> 
  <p>把准备好的 order 和 peer 上的配置文件复制到宿主机器上。<br> 由于所有配置文件都是在 <a href="http://cli.alcor.com" rel="nofollow">cli.alcor.com</a> 机器上准备的，所以通过以下步骤复制到相应的主机上。目标地址按照配置文件都是存放在宿主机器/opt/fabric 目录下。</p> 
  <ol> 
   <li> <p>复制到 <a href="http://orderer.alcor.com" rel="nofollow">orderer.alcor.com</a> 上</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment"># 在 orderer.alcor.com 机器上建立 /opt/fabric/orderer 目录</span>
<span class="token function">mkdir</span> -p /opt/fabric/orderer
</code></pre> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment">#回到 cli.alcor.com机器上，把 orderer的配置文件复制过去</span>
<span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">scp</span> -r orderer.alcor.com/* root@orderer.alcor.com:/opt/fabric/orderer/
</code></pre> </li> 
   <li> <p><a href="http://xn--peer0-6o6hlb698h.org1.alcor.com" rel="nofollow">复制到peer0.org1.alcor.com</a></p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment"># 在 peer0.org1.alcor.com 机器上建立 /opt/fabric/peer 目录</span>
<span class="token function">mkdir</span> -p /opt/fabric/peer
</code></pre> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment">#回到 cli.alcor.com机器上，把 peer0.org1.alcor.com的配置文件复制过去</span>
<span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">scp</span> -r peer0.org1.alcor.com/* root@peer0.org1.alcor.com:/opt/fabric/peer/
</code></pre> </li> 
   <li> <p><a href="http://xn--peer1-6o6hlb698h.org1.alcor.com" rel="nofollow">复制到peer1.org1.alcor.com</a></p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment"># 在 peer1.org1.alcor.com 机器上建立 /opt/fabric/peer 目录</span>
 <span class="token function">mkdir</span> -p /opt/fabric/peer
</code></pre> <pre class=" language-bash"><code class="prism  language-bash"> <span class="token comment">#回到 cli.alcor.com机器上，把 peer1.org1.alcor.com 的配置文件复制过去</span>
 <span class="token function">cd</span> /root/fabric/fabric-deploy
 <span class="token function">scp</span> -r peer1.org1.alcor.com/* root@peer1.org1.alcor.com:/opt/fabric/peer/
</code></pre> </li> 
   <li> <p><a href="http://xn--peer0-6o6hlb698h.org2.alcor.com" rel="nofollow">复制到peer0.org2.alcor.com</a></p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment"># 在 peer0.org2.alcor.com 机器上建立 /opt/fabric/peer 目录</span>
<span class="token function">mkdir</span> -p /opt/fabric/peer
</code></pre> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment">#回到 cli.alcor.com机器上，把 peer0.org2.alcor.com的配置文件复制过去</span>
<span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">scp</span> -r peer0.org2.alcor.com/* root@peer0.org2.alcor.com:/opt/fabric/peer/
</code></pre> </li> 
   <li> <p><a href="http://xn--peer1-6o6hlb698h.org2.alcor.com" rel="nofollow">复制到peer1.org2.alcor.com</a></p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment"># 在 peer1.org2.alcor.com 机器上建立 /opt/fabric/peer 目录</span>
<span class="token function">mkdir</span> -p /opt/fabric/peer
</code></pre> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment">#回到 cli.alcor.com机器上，把 peer1.org2.alcor.com的配置文件复制过去</span>
<span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">scp</span> -r peer1.org2.alcor.com/* root@peer1.org2.alcor.com:/opt/fabric/peer/
</code></pre> </li> 
  </ol> 
  <h2><a id="10__genesisblockkafka__711"></a>10. 准备创世纪区块 genesisblock(kafka 模式)</h2> 
  <ol> 
   <li> <p>在 cli 机器的 /root/fabric/fabric-deploy/目录下，准备创世纪块的生成配置文件 configtx.yaml</p> <pre class=" language-yaml"><code class="prism  language-yaml">vi /root/fabric/fabric<span class="token punctuation">-</span>deploy/configtx.yaml

<span class="token comment">#文件内容如下：</span>
<span class="token key atrule">Organizations</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token important">&amp;OrdererOrg</span>
        <span class="token key atrule">Name</span><span class="token punctuation">:</span> OrdererOrg
        <span class="token key atrule">ID</span><span class="token punctuation">:</span> OrdererMSP
        <span class="token key atrule">MSPDir</span><span class="token punctuation">:</span> ./certs/ordererOrganizations/alcor.com/msp
    <span class="token punctuation">-</span> <span class="token important">&amp;Org1</span>
        <span class="token key atrule">Name</span><span class="token punctuation">:</span> Org1MSP
        <span class="token key atrule">ID</span><span class="token punctuation">:</span> Org1MSP
        <span class="token key atrule">MSPDir</span><span class="token punctuation">:</span> ./certs/peerOrganizations/org1.alcor.com/msp
        <span class="token key atrule">AnchorPeers</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token key atrule">Host</span><span class="token punctuation">:</span> peer0.org1.alcor.com
              <span class="token key atrule">Port</span><span class="token punctuation">:</span> <span class="token number">7051</span>
    <span class="token punctuation">-</span> <span class="token important">&amp;Org2</span>
        <span class="token key atrule">Name</span><span class="token punctuation">:</span> Org2MSP
        <span class="token key atrule">ID</span><span class="token punctuation">:</span> Org2MSP
        <span class="token key atrule">MSPDir</span><span class="token punctuation">:</span> ./certs/peerOrganizations/org2.alcor.com/msp
        <span class="token key atrule">AnchorPeers</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token key atrule">Host</span><span class="token punctuation">:</span> peer0.org2.alcor.com
              <span class="token key atrule">Port</span><span class="token punctuation">:</span> <span class="token number">7051</span>
<span class="token key atrule">Orderer</span><span class="token punctuation">:</span> <span class="token important">&amp;OrdererDefaults</span>
    <span class="token key atrule">OrdererType</span><span class="token punctuation">:</span> kafka
    <span class="token key atrule">Addresses</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> orderer.alcor.com<span class="token punctuation">:</span><span class="token number">7050</span>
    <span class="token key atrule">BatchTimeout</span><span class="token punctuation">:</span> 2s
    <span class="token key atrule">BatchSize</span><span class="token punctuation">:</span>
        <span class="token key atrule">MaxMessageCount</span><span class="token punctuation">:</span> <span class="token number">10</span>
        <span class="token key atrule">AbsoluteMaxBytes</span><span class="token punctuation">:</span> 99 MB
        <span class="token key atrule">PreferredMaxBytes</span><span class="token punctuation">:</span> 512 KB
    <span class="token key atrule">Kafka</span><span class="token punctuation">:</span>
        <span class="token key atrule">Brokers</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> kafka.alcor.com<span class="token punctuation">:</span><span class="token number">9092 </span><span class="token comment"># 可以填入多个kafka节点的地址</span>
            <span class="token punctuation">-</span> kafka.alcor.com<span class="token punctuation">:</span><span class="token number">9093</span>
            <span class="token punctuation">-</span> kafka.alcor.com<span class="token punctuation">:</span><span class="token number">9094</span>
    <span class="token key atrule">Organizations</span><span class="token punctuation">:</span>
<span class="token key atrule">Application</span><span class="token punctuation">:</span> <span class="token important">&amp;ApplicationDefaults</span>
    <span class="token key atrule">Organizations</span><span class="token punctuation">:</span>
<span class="token key atrule">Profiles</span><span class="token punctuation">:</span>
    <span class="token key atrule">TwoOrgsOrdererGenesis</span><span class="token punctuation">:</span>
        <span class="token key atrule">Orderer</span><span class="token punctuation">:</span>
            <span class="token key atrule">&lt;&lt;</span><span class="token punctuation">:</span> <span class="token important">*OrdererDefaults</span>
            <span class="token key atrule">Organizations</span><span class="token punctuation">:</span>
                <span class="token punctuation">-</span> <span class="token important">*OrdererOrg</span>
        <span class="token key atrule">Consortiums</span><span class="token punctuation">:</span>
            <span class="token key atrule">SampleConsortium</span><span class="token punctuation">:</span>
                <span class="token key atrule">Organizations</span><span class="token punctuation">:</span>
                    <span class="token punctuation">-</span> <span class="token important">*Org1</span>
                    <span class="token punctuation">-</span> <span class="token important">*Org2</span>
    <span class="token key atrule">TwoOrgsChannel</span><span class="token punctuation">:</span>
        <span class="token key atrule">Consortium</span><span class="token punctuation">:</span> SampleConsortium
        <span class="token key atrule">Application</span><span class="token punctuation">:</span>
            <span class="token key atrule">&lt;&lt;</span><span class="token punctuation">:</span> <span class="token important">*ApplicationDefaults</span>
            <span class="token key atrule">Organizations</span><span class="token punctuation">:</span>
                <span class="token punctuation">-</span> <span class="token important">*Org1</span>
                <span class="token punctuation">-</span> <span class="token important">*Org2</span>
</code></pre> <font color="red"> 踩坑： 注意: 在1.2版本中。 配置文件的中的 Organizations 部分，必须在文件顶端。否则会出现: 如下错误 ![-w1436](media/15338798435067/15349240598525.jpg) </font> </li> 
   <li> <p>生成创世纪区块</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy
./bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./genesisblock -channelID genesis
</code></pre> <p>生成创世纪区块文件 genesisblock ，并且指定创世区块的 channel id 是 genesis</p> </li> 
   <li> <p>然后把区块文件 genesisblock 复制到 oderer.alcor.com机器上</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment">#登录到 cli 主机</span>
<span class="token function">cd</span> /root/fabric/fabric-deploy
<span class="token function">scp</span> ./genesisblock  root@orderer.alcor.com:/opt/fabric/orderer
</code></pre> </li> 
  </ol> 
  <h2><a id="11__orderer__peer_798"></a>11. 启动 orderer 和 peer</h2> 
  <ol> 
   <li> <p>启动 orderer</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment"># 进入 orderer.alcor.com 主机的 /opt/fabric/orderer 目录，建立一个startOrderer.sh 启动批处理文件.内容如下:</span>

./orderer 2<span class="token operator">&gt;</span><span class="token operator">&amp;</span>1 <span class="token operator">|</span><span class="token function">tee</span> log

<span class="token comment">#启动 orderer</span>
<span class="token function">chmod</span> +x startOrderer.sh
<span class="token function">nohup</span> ./startOrderer.sh <span class="token operator">&amp;</span>
</code></pre> <p>启动成功后，可以去任意一台 kafka 服务器上的控制台查看 topic 列表，是否有一个 genesis 的 channel。</p> <pre class=" language-bash"><code class="prism  language-bash">/opt/kafka_2.11-1.1.1/bin/kafka-topics.sh --zookeeper 192.168.188.111:2181 --list
</code></pre> </li> 
   <li> <p>在4个 peer 上安装 couchDB</p> <p>详细介绍查看 ：<br> <a>fabric peer 节点使用 CouchDB 来替换 LevelDB.</a></p> </li> 
   <li> <p>启动4个 peer</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment">#分别进入3个 peer 主机的 /opt/fabric/peer 目录，建立一个startPeer.sh 启动批处理文件，内容如下：</span>
./peer node start 2<span class="token operator">&gt;</span><span class="token operator">&amp;</span>1 <span class="token operator">|</span><span class="token function">tee</span> log

<span class="token comment">#启动 peer</span>
./startPeer.sh
</code></pre> </li> 
  </ol> 
  <h2><a id="12__832"></a>12. 用户账号创建</h2> 
  <ol> 
   <li> <p>在 cli 机器上建立存放用户账号信息的目录</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span>  /root/fabric/fabric-deploy
<span class="token function">mkdir</span> <span class="token function">users</span> 
<span class="token function">cd</span> <span class="token function">users</span>
</code></pre> </li> 
   <li> <p>创立 org1的Admin 用户信息（对应到 <a href="http://peer0.org1.alcor.com" rel="nofollow">peer0.org1.alcor.com</a> 的节点）</p> 
    <ol> 
     <li> <p>创建保存 org1 的 Admin 用户信息的目录</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy/users
<span class="token function">mkdir</span> Admin@org1.alcor.com
<span class="token function">cd</span>  Admin@org1.alcor.com
</code></pre> </li> 
     <li> <p>复制Admin@org1.alcor.com用户的证书</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cp</span> -rf  /root/fabric/fabric-deploy/certs/peerOrganizations/org1.alcor.com/users/Admin@org1.alcor.com/* /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/

</code></pre> </li> 
     <li> <p>复制peer0.org1.alcor.com的配置文件(对应到 <a href="http://peer0.org1.alcor.com" rel="nofollow">peer0.org1.alcor.com</a> 的节点)</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cp</span> /root/fabric/fabric-deploy/peer0.org1.aclor.com/core.yaml  /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/
</code></pre> </li> 
     <li> <p>创建测试脚本(<a href="http://peer.sh" rel="nofollow">peer.sh</a>)</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">cd</span> <span class="token string">"/root/fabric/fabric-deploy/users/Admin@org1.alcor.com"</span>
PATH<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin:<span class="token variable">$PATH</span>
<span class="token function">export</span> FABRIC_CFG_PATH<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span>
<span class="token function">export</span> CORE_PEER_TLS_ENABLED<span class="token operator">=</span>true
<span class="token function">export</span> CORE_PEER_TLS_CERT_FILE<span class="token operator">=</span>./tls/client.crt
<span class="token function">export</span> CORE_PEER_TLS_KEY_FILE<span class="token operator">=</span>./tls/client.key
<span class="token function">export</span> CORE_PEER_MSPCONFIGPATH<span class="token operator">=</span>./msp
<span class="token function">export</span> CORE_PEER_ADDRESS<span class="token operator">=</span>peer0.org1.alcor.com:7051
<span class="token function">export</span> CORE_PEER_LOCALMSPID<span class="token operator">=</span>Org1MSP
<span class="token function">export</span> CORE_PEER_TLS_ROOTCERT_FILE<span class="token operator">=</span>./tls/ca.crt
<span class="token function">export</span> CORE_PEER_ID<span class="token operator">=</span>peer0.org1.alcor.com
<span class="token function">export</span> CORE_LOGGING_LEVEL<span class="token operator">=</span>DEBUG
peer <span class="token variable">$*</span>
</code></pre> <p>注意：<br> 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 <a href="http://peer0.org1.alcor.com" rel="nofollow">peer0.org1.alcor.com</a> 节点对应</p> </li> 
     <li> <p>运行 <a href="http://peer.sh" rel="nofollow">peer.sh</a> 来查看节点 <a href="http://peer0.org1.aclor.com" rel="nofollow">peer0.org1.aclor.com</a> 的状态</p> <pre class=" language-bash"><code class="prism  language-bash">./peer.sh node status
</code></pre> <p><img src="media/15382874126951/15383298724232.jpg" alt="-w1288"></p> </li> 
    </ol> </li> 
   <li> <p>创立 org1的 User1 用户信息 （对应到 <a href="http://peer1.org1.alcor.com" rel="nofollow">peer1.org1.alcor.com</a> 的节点）</p> 
    <ol> 
     <li> <p>创建保存 org1 的 User1 用户信息的目录（对应到 <a href="http://peer1.org1.alcor.com" rel="nofollow">peer1.org1.alcor.com</a>）</p> <font color="red"> 其实是 <font size="6">Admin </font>的用户证书，如果用的是User1的证书，在 peer node status 的时候，会出现错误： Error trying to connect to local peer: rpc error: code = Unknown desc = access denied </font> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy/users
<span class="token function">mkdir</span> User1@org1.alcor.com
<span class="token function">cd</span>  User1@org1.alcor.com
</code></pre> </li> 
     <li> <p>复制User1@org1.alcor.com用户的证书</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cp</span> -rf  /root/fabric/fabric-deploy/certs/peerOrganizations/org1.alcor.com/users/Admin@org1.alcor.com/* /root/fabric/fabric-deploy/users/User1@org1.alcor.com/

</code></pre> </li> 
     <li> <p>复制peer1.org1.alcor.com的配置文件（对应到 <a href="http://peer1.org1.alcor.com" rel="nofollow">peer1.org1.alcor.com</a>）</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cp</span> /root/fabric/fabric-deploy/peer1.org1.alcor.com/core.yaml  /root/fabric/fabric-deploy/users/User1@org1.alcor.com/
</code></pre> </li> 
     <li> <p>创建测试脚本(<a href="http://peer.sh" rel="nofollow">peer.sh</a>)</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">cd</span> <span class="token string">"/root/fabric/fabric-deploy/users/User1@org1.alcor.com"</span>
PATH<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin:<span class="token variable">$PATH</span>
<span class="token function">export</span> FABRIC_CFG_PATH<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span>
<span class="token function">export</span> CORE_PEER_TLS_ENABLED<span class="token operator">=</span>true
<span class="token function">export</span> CORE_PEER_TLS_CERT_FILE<span class="token operator">=</span>./tls/client.crt
<span class="token function">export</span> CORE_PEER_TLS_KEY_FILE<span class="token operator">=</span>./tls/client.key
<span class="token function">export</span> CORE_PEER_MSPCONFIGPATH<span class="token operator">=</span>./msp
<span class="token function">export</span> CORE_PEER_ADDRESS<span class="token operator">=</span>peer1.org1.alcor.com:7051
<span class="token function">export</span> CORE_PEER_LOCALMSPID<span class="token operator">=</span>Org1MSP
<span class="token function">export</span> CORE_PEER_TLS_ROOTCERT_FILE<span class="token operator">=</span>./tls/ca.crt
<span class="token function">export</span> CORE_PEER_ID<span class="token operator">=</span>peer1.org1.alcor.com
<span class="token function">export</span> CORE_LOGGING_LEVEL<span class="token operator">=</span>DEBUG
peer <span class="token variable">$*</span>
</code></pre> <p>注意：<br> 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 <a href="http://peer1.org1.alcor.com" rel="nofollow">peer1.org1.alcor.com</a> 节点对应</p> </li> 
     <li> <p>运行 <a href="http://peer.sh" rel="nofollow">peer.sh</a> 来查看节点 <a href="http://peer1.org1.alcor.com" rel="nofollow">peer1.org1.alcor.com</a> 的状态</p> <pre class=" language-bash"><code class="prism  language-bash">./peer.sh node status
</code></pre> </li> 
    </ol> </li> 
   <li> <p>创立 org2的Admin 用户信息（对应到 <a href="http://peer0.org2.alcor.com" rel="nofollow">peer0.org2.alcor.com</a> 的节点）</p> 
    <ol> 
     <li> <p>创建保存 org2 的 Admin 用户信息的目录</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy/users
<span class="token function">mkdir</span> Admin@org2.alcor.com
<span class="token function">cd</span>  Admin@org2.alcor.com
</code></pre> </li> 
     <li> <p>复制Admin@org2.alcor.com用户的证书</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cp</span> -rf  /root/fabric/fabric-deploy/certs/peerOrganizations/org2.alcor.com/users/Admin@org2.alcor.com/* /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/

</code></pre> </li> 
     <li> <p>复制peer0@org2.alcor.com的配置文件(对应到 <a href="http://peer0.org2.alcor.com" rel="nofollow">peer0.org2.alcor.com</a> 的节点)</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cp</span> /root/fabric/fabric-deploy/peer0.org2.alcor.com/core.yaml  /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/
</code></pre> </li> 
     <li> <p>创建测试脚本(<a href="http://peer.sh" rel="nofollow">peer.sh</a>)</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">cd</span> <span class="token string">"/root/fabric/fabric-deploy/users/Admin@org2.alcor.com"</span>
PATH<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin:<span class="token variable">$PATH</span>
<span class="token function">export</span> FABRIC_CFG_PATH<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span>
<span class="token function">export</span> CORE_PEER_TLS_ENABLED<span class="token operator">=</span>true
<span class="token function">export</span> CORE_PEER_TLS_CERT_FILE<span class="token operator">=</span>./tls/client.crt
<span class="token function">export</span> CORE_PEER_TLS_KEY_FILE<span class="token operator">=</span>./tls/client.key
<span class="token function">export</span> CORE_PEER_MSPCONFIGPATH<span class="token operator">=</span>./msp
<span class="token function">export</span> CORE_PEER_ADDRESS<span class="token operator">=</span>peer0.org2.alcor.com:7051
<span class="token function">export</span> CORE_PEER_LOCALMSPID<span class="token operator">=</span>Org2MSP
<span class="token function">export</span> CORE_PEER_TLS_ROOTCERT_FILE<span class="token operator">=</span>./tls/ca.crt
<span class="token function">export</span> CORE_PEER_ID<span class="token operator">=</span>peer0.org2.alcor.com
<span class="token function">export</span> CORE_LOGGING_LEVEL<span class="token operator">=</span>DEBUG
peer <span class="token variable">$*</span>
</code></pre> <p>注意：<br> 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 <a href="http://peer0.org1.alcor.com" rel="nofollow">peer0.org1.alcor.com</a> 节点对应</p> </li> 
     <li> <p>运行 <a href="http://peer.sh" rel="nofollow">peer.sh</a> 来查看节点 <a href="http://peer0.org2.alcor.com" rel="nofollow">peer0.org2.alcor.com</a> 的状态</p> <pre class=" language-bash"><code class="prism  language-bash">./peer.sh node status
</code></pre> </li> 
    </ol> </li> 
   <li> <p>创立 org2的User1用户信息（对应到 <a href="http://peer1.org2.alcor.com" rel="nofollow">peer1.org2.alcor.com</a> 的节点）</p> <font color="red"> 其实是 <font size="6">Admin </font>的用户证书，如果用的是User1的证书，在 peer node status 的时候，会出现错误： Error trying to connect to local peer: rpc error: code = Unknown desc = access denied </font> 
    <ol> 
     <li> <p>创建保存 org2 的 User1 用户信息的目录</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy/users
<span class="token function">mkdir</span> User1@org2.alcor.com
<span class="token function">cd</span>  User1@org2.alcor.com
</code></pre> </li> 
     <li> <p>复制Admin@org2.alcor.com用户的证书</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cp</span> -rf  /root/fabric/fabric-deploy/certs/peerOrganizations/org2.alcor.com/users/Admin@org2.alcor.com/* /root/fabric/fabric-deploy/users/User1@org2.alcor.com/

</code></pre> </li> 
     <li> <p>复制peer0@org2.alcor.com的配置文件(对应到 <a href="http://peer0.org2.alcor.com" rel="nofollow">peer0.org2.alcor.com</a> 的节点)</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cp</span> /root/fabric/fabric-deploy/peer1.org2.alcor.com/core.yaml  /root/fabric/fabric-deploy/users/User1@org2.alcor.com/
</code></pre> </li> 
     <li> <p>创建测试脚本(<a href="http://peer.sh" rel="nofollow">peer.sh</a>)</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">cd</span> <span class="token string">"/root/fabric/fabric-deploy/users/User1@org2.alcor.com"</span>
PATH<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/bin:<span class="token variable">$PATH</span>
<span class="token function">export</span> FABRIC_CFG_PATH<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span>
<span class="token function">export</span> CORE_PEER_TLS_ENABLED<span class="token operator">=</span>true
<span class="token function">export</span> CORE_PEER_TLS_CERT_FILE<span class="token operator">=</span>./tls/client.crt
<span class="token function">export</span> CORE_PEER_TLS_KEY_FILE<span class="token operator">=</span>./tls/client.key
<span class="token function">export</span> CORE_PEER_MSPCONFIGPATH<span class="token operator">=</span>./msp
<span class="token function">export</span> CORE_PEER_ADDRESS<span class="token operator">=</span>peer1.org2.alcor.com:7051
<span class="token function">export</span> CORE_PEER_LOCALMSPID<span class="token operator">=</span>Org2MSP
<span class="token function">export</span> CORE_PEER_TLS_ROOTCERT_FILE<span class="token operator">=</span>./tls/ca.crt
<span class="token function">export</span> CORE_PEER_ID<span class="token operator">=</span>peer1.org2.alcor.com
<span class="token function">export</span> CORE_LOGGING_LEVEL<span class="token operator">=</span>DEBUG
peer <span class="token variable">$*</span>
</code></pre> <p>注意：<br> 其中的 pwd 工作目录 和 CORE_PEER_ADDRESS ， CORE_PEER_LOCALMSPID 要和 <a href="http://peer0.org1.alcor.com" rel="nofollow">peer0.org1.alcor.com</a> 节点对应</p> </li> 
     <li> <p>运行 <a href="http://peer.sh" rel="nofollow">peer.sh</a> 来查看节点 <a href="http://peer0.org2.alcor.com" rel="nofollow">peer0.org2.alcor.com</a> 的状态</p> <pre class=" language-bash"><code class="prism  language-bash">./peer.sh node status
</code></pre> </li> 
    </ol> </li> 
  </ol> 
  <h2><a id="13_channel__1055"></a>13. channel 的准备和创建</h2> 
  <font color="red"> 踩坑：channel ID 不能含有大写字母（myTestChannel , myChannel 这种命名是不行的，在创建 channel 的时候，会报错） initializing configtx manager failed: bad channel ID: channel ID 'myTestChannel' contains illegal characters </font> 
  <ol> 
   <li> <p>准备channel 文件。用configtxgen生成channel文件</p> <pre class=" language-bash"><code class="prism  language-bash"> <span class="token function">cd</span> /root/fabric/fabric-deploy/
./bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx mychannel.tx -channelID mychannel

</code></pre> </li> 
   <li> <p>针对每个 org 的peer生成一个anchor文件，每个组织只需要一个：</p> <pre><code>./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP
./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP
</code></pre> <p>生成的Org1MSPanchors.tx和Org2MSPanchors.tx备用。</p> </li> 
   <li> <p><a href="http://xn--orderer-4t3kfd0pye08ls88ads8boxu093i27h0y1c.alcor.com" rel="nofollow">因为下一步操作中要访问orderer.alcor.com</a>，所以需要将验证orderer.alcor.com的根证书复制到用户目录中：</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span>  /root/fabric/fabric-deploy
<span class="token function">cp</span>  /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem  /root/fabric/fabric-deploy/users/Admin\@org1.alcor.com/
<span class="token function">cp</span>  /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem  /root/fabric/fabric-deploy/users/User1\@org1.alcor.com/
<span class="token function">cp</span>  /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem  /root/fabric/fabric-deploy/users/Admin\@org2.alcor.com/
<span class="token function">cp</span>  /root/fabric/fabric-deploy/certs/ordererOrganizations/alcor.com/tlsca/tlsca.alcor.com-cert.pem  /root/fabric/fabric-deploy/users/User1\@org2.alcor.com/

</code></pre> </li> 
  </ol> 
  <h2><a id="14__channel_1090"></a>14. 创建 channel</h2> 
  <ol> 
   <li> <p>在Admin@org1.alcor.com目录中执行下面的命令，：</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span>  /root/fabric/fabric-deploy/users/Admin@org1.alcor.com
./peer.sh channel create -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/mychannel.tx --tls <span class="token boolean">true</span> --cafile tlsca.alcor.com-cert.pem

</code></pre> <p>执行完成后，会生成一个mychannel.block文件.<br> <font color="red"><br> 这个文件非常重要!所有加入到这个 channel 里面的 peer，都需要用到这个文件<br> </font></p> </li> 
   <li> <p>将mychannel.block复制一份到User1@org1.alcor.com 和 <a href="mailto:Admin@org2.alcor.com" rel="nofollow">Admin@org2.alcor.com</a>、User1@org2.alcor.com中备用</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cp</span> /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block  /root/fabric/fabric-deploy/users/User1@org1.alcor.com/    
<span class="token function">cp</span> /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block  /root/fabric/fabric-deploy/users/Admin@org2.alcor.com/
<span class="token function">cp</span> /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/mychannel.block  /root/fabric/fabric-deploy/users/User1@org2.alcor.com/    
</code></pre> </li> 
  </ol> 
  <h2><a id="15_4_peer_channel__1113"></a>15.把 4个 peer加入到 channel 中</h2> 
  <ol> 
   <li> <p><a href="http://xn--peer0-s66j.org1.alcor.com" rel="nofollow">把peer0.org1.alcor.com</a> 加入到 channle 中</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span>  /root/fabric/fabric-deploy/users/Admin@org1.alcor.com
./peer.sh channel <span class="token function">join</span> -b mychannel.block
<span class="token comment">#控制台返回成功后，可以用下面命令来查看</span>
./peer.sh channel list
</code></pre> </li> 
   <li> <p><a href="http://xn--peer1-s66j.org1.alcor.com" rel="nofollow">把peer1.org1.alcor.com</a> 加入到 channle 中</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span>  /root/fabric/fabric-deploy/users/User1@org1.alcor.com <span class="token comment">#这个其实还是org1.alcor.com 的 Admin 用户</span>
./peer.sh channel <span class="token function">join</span> -b mychannel.block
<span class="token comment">#控制台返回成功后，可以用下面命令来查看</span>
./peer.sh channel list
</code></pre> </li> 
   <li> <p><a href="http://xn--peer0-s66j.org2.alcor.com" rel="nofollow">把peer0.org2.alcor.com</a> 加入到 channle 中</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span>  /root/fabric/fabric-deploy/users/Admin@org2.alcor.com
./peer.sh channel <span class="token function">join</span> -b mychannel.block
<span class="token comment">#控制台返回成功后，可以用下面命令来查看</span>
./peer.sh channel list
</code></pre> </li> 
   <li> <p><a href="http://xn--peer1-s66j.org2.alcor.com" rel="nofollow">把peer1.org2.alcor.com</a> 加入到 channle 中</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span>  /root/fabric/fabric-deploy/users/User1@org2.alcor.com <span class="token comment">#这个其实还是org2.alcor.com 的 Admin 用户</span>
./peer.sh channel <span class="token function">join</span> -b mychannel.block
<span class="token comment">#控制台返回成功后，可以用下面命令来查看</span>
./peer.sh channel list
</code></pre> </li> 
  </ol> 
  <h2><a id="16_peer__1152"></a>16.设置锚点 peer .</h2> 
  <p>需要每个组织指定一个anchor peer，anchor peer是组织用来接收orderer下发的区块的peer。</p> 
  <ol> 
   <li>把org1的 anchor peer 设置为 <a href="http://peer0.org1.alcor.com" rel="nofollow">peer0.org1.alcor.com</a></li> 
  </ol> 
  <pre class=" language-bash"><code class="prism  language-bash">  <span class="token function">cd</span>  /root/fabric/fabric-deploy/users/Admin@org1.alcor.com    
  ./peer.sh channel update -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/Org1MSPanchors.tx --tls <span class="token boolean">true</span> --cafile ./tlsca.alcor.com-cert.pem
</code></pre> 
  <ol start="2"> 
   <li>把org2的 anchor peer 设置为 <a href="http://peer0.org2.alcor.com" rel="nofollow">peer0.org2.alcor.com</a></li> 
  </ol> 
  <pre class=" language-bash"><code class="prism  language-bash"> <span class="token function">cd</span>  /root/fabric/fabric-deploy/users/Admin@org2.alcor.com    
 ./peer.sh channel update -o orderer.alcor.com:7050 -c mychannel -f /root/fabric/fabric-deploy/Org2MSPanchors.tx --tls <span class="token boolean">true</span> --cafile ./tlsca.alcor.com-cert.pem
</code></pre> 
  <h2><a id="17_go__chaincode__cli__1170"></a>17. go 版本的 chaincode 的安装和部署（在 cli 主机上操作）</h2> 
  <ol> 
   <li> <p>安装 go 环境</p> <p>go 的下载官网</p> <p><a href="https://golang.org/dl/" rel="nofollow">https://golang.org/dl/</a></p> <p>以 root 用户安装</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">wget</span> https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz

<span class="token function">tar</span> -xvf  go1.10.3.linux-386.tar.gz

<span class="token function">mv</span> ./go  /usr/local

<span class="token comment">#修改 /etc/profile，增加 如下2行内容</span>
<span class="token function">export</span> GOROOT<span class="token operator">=</span>/usr/local/go
<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span><span class="token keyword">:</span><span class="token variable">$GOROOT</span>/bin

<span class="token comment">#使得环境变量生效</span>
<span class="token function">source</span> /etc/profile

<span class="token comment">#确定 go 的安装成功和版本信息</span>
go version 

<span class="token comment">#查看 go 的环境</span>
go <span class="token function">env</span>
</code></pre> </li> 
   <li> <p>拉取 demo 的 chaincode<br> 这个需要先安装 gcc 组件</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> ~
go get github.com/roamerxv/chaincode/fabric/examples/go/demo
</code></pre> <p>完成后，生成一个~/go 目录。下面有 src 和bin 目录。/root/go/src/github.com 目录下有个fabric 和 roamerxv 这2个目录。</p> </li> 
   <li> <p>测试编译 demo.go</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/go/src/github.com/roamerxv/chaincode/fabric/examples/go/demo
go build
<span class="token comment">#确定生成 demo 可执行文件，说明go 配置正常</span>
</code></pre> </li> 
   <li> <p>chaincode 的打包</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy/users/Admin@org1.alcor.com
./peer.sh chaincode package demo-pack.out -n demo -v 0.0.1 -s -S -p github.com/roamerxv/chaincode/fabric/examples/go/demo

</code></pre> <p>成功后生成一个 demo-pack.out 文件</p> </li> 
   <li> <p>chaincode 的签署</p> <pre class=" language-bash"><code class="prism  language-bash">./peer.sh chaincode signpackage demo-pack.out signed-demo-pack.out
</code></pre> <p>成功后，生成 signed-demo-pack.out</p> </li> 
   <li> <p>chaincode 的安装</p> <pre class=" language-bash"><code class="prism  language-bash">./peer.sh chaincode <span class="token function">install</span> ./signed-demo-pack.out
</code></pre> <p>由于 <a href="http://peer.sh" rel="nofollow">peer.sh</a> 中指定了CORE_PEER_ADDRESS=<a href="http://peer0.org1.alcor.com:7051" rel="nofollow">peer0.org1.alcor.com:7051</a> ，所以，这个安装其实是把 chaincode 文件复制到 <a href="http://peer0.org1.alcor.com" rel="nofollow">peer0.org1.alcor.com</a> 这台机器的 /var/hyperledger/production/chaincodes/ 目录下. 文件名是 demo.0.0.1.</p> <p>而 /var/hyperledger/production/chaincodes/ 这个路径是由 core.yaml 里面的 peer.fileSystemPath 这个属性指定的。</p> <p><img src="media/15382874126951/15383353467012.jpg" alt="-w399"></p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment">#同时，可以在 cli 上，通过以下命令查看 peer 上的 chaincode 信息</span>
<span class="token function">cd</span> /root/fabric/fabric-deploy/users/Admin@org1.alcor.com
./peer.sh chaincode list   --installed
</code></pre> <p><img src="media/15382874126951/15383354233467.jpg" alt="-w1124"></p> <font color="red"> 注意: 这个安装需要在涉及到的所有 peer 上进行一遍,包括另外的组织 org2. 而且一定要用 admin用户来安装。 所以，把签署后的 signed-demo-pack.out 复制到 ~/fabric/fabric-deploy/users/User1@org1.alcor.com , ~/fabric/fabric-deploy/users/Admin@org2.alcor.com 目录下. </font> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cp</span> /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out   /root/fabric/fabric-deploy/users/User1@org1.alcor.com
<span class="token function">cp</span> /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out   /root/fabric/fabric-deploy/users/Admin@org2.alcor.com 
<span class="token function">cp</span> /root/fabric/fabric-deploy/users/Admin@org1.alcor.com/signed-demo-pack.out   /root/fabric/fabric-deploy/users/User1@org2.alcor.com

<span class="token comment">#进入另外3个目录，再次安装 chaincode 到对应的 peer 上</span>
<span class="token comment">#这个是 安装到 peer1.org1.alcor.com</span>
<span class="token function">cd</span>  /root/fabric/fabric-deploy/users/User1@org1.alcor.com
./peer.sh chaincode <span class="token function">install</span> ./signed-demo-pack.out

<span class="token comment">#这个是 安装到 peer0.org2.alcor.com</span>
<span class="token function">cd</span>  /root/fabric/fabric-deploy/users/Admin@org2.alcor.com
./peer.sh chaincode <span class="token function">install</span> ./signed-demo-pack.out

<span class="token comment">#这个是 安装到 peer1.org2.alcor.com</span>
<span class="token function">cd</span>  /root/fabric/fabric-deploy/users/User1@org2.alcor.com
./peer.sh chaincode <span class="token function">install</span> ./signed-demo-pack.out

</code></pre> </li> 
   <li> <p>chaincode 的初始化</p> <p>合约安装之后，需要且只需要进行一次初始化，只能由签署合约的用户进行初始化,并且所有的 peer 上的 docker 服务已经启动。谁签署了 chaincode，谁来进行实例化。</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span>  /root/fabric/fabric-deploy/users/Admin@org1.alcor.com
./peer.sh chaincode instantiate -o orderer.alcor.com:7050 --tls <span class="token boolean">true</span> --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo -v 0.0.1 -c <span class="token string">'{"Args":["init"]}'</span> -P <span class="token string">"OR('Org1MSP.member','Org2MSP.member')"</span>
</code></pre> <p>第一次进行合约初始化的时候的会比较慢，因为peer 上需要创建、启动容器。</p> </li> 
   <li> <p>chaincode的调用</p> <pre class=" language-bsh"><code class="prism  language-bsh">cd  /root/fabric/fabric-deploy/users/Admin@org1.alcor.com
./peer.sh chaincode invoke -o orderer.alcor.com:7050  --tls true --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo  -c '{"Args":["write","key1","key1value中文isabc"]}'
</code></pre> <font color="red"> chaincode 的调用，可以调用任意一台安装了这个 chaincode 的peer。这个时候被调用的 peer 上会启动相应的 chaincode 的 docker。 </font> <p>进行查询操作时，不需要指定orderer，例如：</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /root/fabric/fabric-deploy/users/User1@org1.alcor.com
./peer.sh chaincode query -C mychannel -n demo -c <span class="token string">'{"Args":["query","key1"]}'</span>
</code></pre> </li> 
   <li> <p>chaincode 的更新</p> <p>新合约的打包和签署</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /home/fabric/fabric-deploy/users/Admin@org1.alcor.com

./peer.sh chaincode package demo-pack-2.out -n demo -v 0.0.2 -s -S -p github.com/roamerxv/chaincode/fabric/examples/go/demo

./peer.sh chaincode signpackage demo-pack-2.out signed-demo-pack-2.out
</code></pre> <p>新的合约也需要在每个peer上单独安装。</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token comment">#安装到peer0.org1.alcor.com</span>
<span class="token function">cd</span> /root/fabric/fabric-deploy/users/Admin@org1.alcor.com
./peer.sh chaincode <span class="token function">install</span> ./signed-demo-pack-2.out

<span class="token comment">#安装到peer1.org1.alcor.com</span>
<span class="token function">cd</span> /root/fabric/fabric-deploy/users/User1@org1.alcor.com
./peer.sh chaincode <span class="token function">install</span> <span class="token punctuation">..</span>/Admin@org1.alcor.com/signed-demo-pack-2.out

<span class="token comment">#安装到peer0.org2.alcor.com</span>
<span class="token function">cd</span> /root/fabric/fabric-deploy/users/Admin@org2.alcor.com
./peer.sh chaincode <span class="token function">install</span> <span class="token punctuation">..</span>/Admin@org1.alcor.com/signed-demo-pack-2.out

 <span class="token comment">#安装到peer1.org2.alcor.com</span>
<span class="token function">cd</span> /root/fabric/fabric-deploy/users/User1@org2.alcor.com
./peer.sh chaincode <span class="token function">install</span> <span class="token punctuation">..</span>/Admin@org1.alcor.com/signed-demo-pack-2.out
</code></pre> <p>更新的合约不需要初始化，需要进行更新操作。</p> <pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cd</span> /home/fabric/fabric-deploy/users/Admin@org1.alcor.com
./peer.sh chaincode upgrade -o orderer.alcor.com:7050 --tls <span class="token boolean">true</span> --cafile ./tlsca.alcor.com-cert.pem -C mychannel -n demo -v 0.0.2 -c <span class="token string">'{"Args":["init"]}'</span> -P <span class="token string">"OR('Org1MSP.member','Org2MSP.member')"</span>
</code></pre> </li> 
   <li> <p>查询key的历史记录</p> </li> 
  </ol> 
  <pre class=" language-bash"><code class="prism  language-bash">./peer.sh chaincode query -C mychannel -n demo -c <span class="token string">'{"Args":["history","key1"]}'</span>
</code></pre> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-8cccb36679.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/remote_roamer/article/details/82914666,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/remote_roamer/article/details/82914666,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
