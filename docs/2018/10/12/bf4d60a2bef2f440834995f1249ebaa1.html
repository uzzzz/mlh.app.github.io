<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>如何才能招聘到合适的以太坊区块链开发者 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="如何才能招聘到合适的以太坊区块链开发者" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="对优质区块链开发人员的需求很大，这是有充分理由的。区块链和ICO领域在过去几年中爆炸式增长。越来越多的人试图进入并在该领域中扬名立万。但是，为了获得成功，他们拥有一支强大而健全的团队至关重要。区块链开发人员，更准确地说，以太坊开发人员是该团队中最关键的组成部分。 因此，在本指南中，我们将使你的生活更轻松。我们将向你展示如何精确定位和从人群中筛选的优秀的人才。 在我们雇用以太坊开发者之前，重要的是我们要知道我们雇用的是哪类人。 怎么样才算是一个完美NB的以太坊开发者？ 在以太坊开发者精湛的技能中，最重要的是要知道将最优秀的与其他人区分开的基本品质是什么？优秀的开发人员必须不仅仅是具有区块链编码技能的开发人员。我们并不是说只熟悉编码就没有价值，但是，如果你需要一个合适的开发人员来创建一个帝国。那么，你正在寻找的一些主要品质是什么？ 去中心化的坚定信念：这些人认为去中心化将挽救人类。传统公司不会雇佣这些人，因为他们相信社会，公司和政府等机构不应该去中心化。 掌握密码学：区块链开发人员需要掌握加密经济学。加密经济学，密码学和经济学分为两部分。这就是为什么伟大的以太坊开发人员应该对密码学有一种不懈的好奇心。 掌握经济学：加密经济学的后半部分是“经济学”，因此专业开发人员也应该具备经济和博弈论机制的良好知识。如果你正在创建区块链平台，则代码应确保所有参与者都受到经济激励。 极度好奇：为了拥有如此庞大的知识基础，这些人天生就非常好奇。这些人大多都是直到深夜还通过视频，论坛，维基来了解特定问题。 所以，现在我们知道我们正在寻找的那种人。这就是为什么说从头开始了解一些以太坊基础知识是有道理的。 我们为什么这样做？ 因为每个以太坊开发者都应该完全熟悉这些概念。 什么是以太坊？ 这是以太坊网站定义的方式： 以太坊是一个区中的平台，运行智能合约：完全按照程序方式运行的应用程序，没有任何停机，审查，欺诈或第三方干扰的可能性。这些应用程序运行在定制的区块链上，这是一个非常强大的共享的全局基础架构，可以转移价值并体现财产的所有权。 但简单来说，以太坊计划成为未来的终极软件平台。如果未来是去中心化的，并且dAPP变得司空见惯，那么以太坊必须成为它的前沿和中心。 虽然比特币是区块链技术的第一个应用，但它仍然只是一种货币。以太坊带来了区块链技术可能实现的全部应用范围。 正如以太坊联合创始人Gavin Wood博士所说： 比特币首先是一种货币;这是区块链的一个特殊应用。但是，它远非唯一的应用程序。举一个类似情况的过去例子，电子邮件是互联网的一种特殊用途，并且肯定有助于推广它，但还有很多其他的应用。 以太坊采矿如何工作？ 截至目前，以太坊正在使用比特币正在使用的相同的工作量证明（Proof-of-Work）。然而，以太坊很快计划转向权益证明（Proof-of-stake），他们将使用Casper协议来实现这一转变。 那么权益证明和工作量证明之间有什么区别？这实际上是你可以问人们你可能会面试的事情。了解工作量证明和权益证明的工作原理绝对至关重要。 工作量证明：这是大多数加密货币如以太坊和比特币迄今为止遵循的协议。这意味着矿工通过使用专用硬件通过“挖矿”来挖掘加密货币。 权益证明：该协议将使整个挖掘过程成为虚拟的。在这个系统中，我们有验证器而不是矿工。它的工作方式是，作为一个验证器，你首先必须把你的一些以太锁作为赌注。完成后，你将开始验证块，这基本上意味着如果你看到任何你认为可以附加到区块链的块，你可以通过下注来验证它。当块被追加时，你将获得与你投资的比例成比例的奖励。但是，如果你在错误或恶意区块上下注，你投入的股份将被剥夺。 为了实现“权益证明”，以太坊将使用Casper一致性算法。一开始，它将是一个混合风格的系统，其中大多数交易仍将是工作量证明，而每100个交易将成为权益证明。这样做意味着，它将提供真实世界在以太坊平台上来测试验证。但这对于以太坊意味着什么？这个协议的优点是什么？让我们来看看： 权益证明的优点 降低整体能源消耗和货币成本：世界范围比特币矿工每小时花费约50,000美元用电。那是每天120万美元，每月3600万美元，每年约4.5亿美元！只是把最重要的放在那些数字和浪费的电量上。通过使用“权益证明”，你将使整个过程完全虚拟化，并切断所有这些成本。 没有ASIC优势：由于整个过程将是虚拟的，因此不依赖于谁拥有更好的设备或ASIC（专用集成电路）。 使51％的攻击更难：51％的攻击发生在一群矿工获得超过世界散射能力的50％时。使用权益证明可以抵消这种攻击。 无恶意验证者：任何将资金锁定在区块链中的验证人都会确保他们不会向链中添加任何错误或恶意的区块，因为这意味着他们投入的全部股权将被剥夺。 块创建：更快地创建更新的块和整个过程。 可伸缩性：通过引入“分片”概念使区块链可扩展（稍后将详细介绍）。 尽管之前有过各种简单的权益证明实施，但Casper与其他方式的区别在于，它激励了诚实的矿工并惩罚了不诚实的矿工。如果你已经将你的赌注置于恶意区块上，那么赌注将被取走。它将惩罚任何不遵守规则的人。 这是Vitalik解释它的方式： 想象一下，100个人坐在圆桌旁。一个人有一堆文件，每个文件都有不同的交易历史。第一个参与者拿起一支笔并签一张，然后将其传递给下一个做出类似选择的人。如果每个参与者签署了大多数参与者最终签署的交易历史记录，则每个参与者只能获得1美元。如果你在一个页面上签名并稍后签署另外不该签的一页，那么你的房子就会被烧毁。然后他补充说，这可能是正确签署的好动力！ 什么是智能合约？ 智能合约是自动化合约。它们是自动执行的，并且在其代码上写入特定指令，这些指令在特定条件下执行。 你可以在我们的其他文章中了解有关智能合约的更多信息。 智能合约是以太坊生态系统中的任务完成的方式。当有人想要在以太坊完成特定任务时，他们会与一个或多个人签订智能合约。 智能合约是一系列指令，使用编程语言solidity编写，它基于IFTTT逻辑（即IF-THIS-THEN-THAT逻辑）工作。基本上，如果完成了第一组指令，则执行下一个函数，然后执行下一个函数并继续重复，直到合约结束。 理解这一点的最好方法是想象一台自动售货机。你采取的每个步骤都像下一步执行自身的触发器。它有点像多米诺骨牌效应。那么，让我们来看看在与自动售货机交互时你将采取的步骤： 第1步：你给自动售货机一些钱。 第2步：按下与所需产品对应的按钮。 第3步：该产品出来，你收起它。 现在看看所有这些步骤并考虑一下。如果前一个步骤没有执行，其他任何步骤都还可以工作吗？这些步骤中的每一步都与前一步骤直接相关。还有一个要考虑的因素，它是智能合约的一个组成部分。你可以看到，在与自动售货机的整个交互过程中，你（请求者）仅与机器（提供商）合作。绝对没有第三方参与。 那么，现在，如果它在以太坊网络中发生，那么这笔交易将如何？ 假设你刚刚从以太坊网络中的自动售货机购买了一些东西，那么步骤将如何？ 第1步：你给自动售货机一些钱，这由以太坊网络中的所有节点记录，并且交易在分类帐中更新。 第2步：按下与你想要的产品对应的按钮，并在以太坊网络和分类帐中更新记录。 第3步：产品出来，你收集它，这将由所有节点和分类帐记录。 你通过智能合约进行的每笔交易都将由网络记录和更新。这样做是因为它让每个参与合约的人都对他们的行为负责。它通过使整个网络可以看到每个动作来消除人类的恶意 好的，直到现在我们已经涵盖了以太坊是什么，什么是采矿，什么是智能合约。如果你的候选人不能令人满意地回答这些问题，那就让他们在那一瞬间离开。已经不值得你再花时间。 掌握智能合约代码 显然，这应该是所有伟大的开发人员的菜。你可以肯定地了解开发人员的专业知识的一种方法是让他们解释特定合约的工作原理。在这里，我们将向你展示两个solidity代码。你可以通过他们运行此代码并要求他们将其分解并向你解释每个步骤中发生的情况。 代码示例1 代码和解释来自toptal。 pragma solidity 0.4.18; import &quot;./Vehicle.sol&quot;; contract VehicleOwner { address public owner; mapping(bytes32 =&gt; address) public vehicles; event NewVehicleAdded(address indexed newVehicle, uint256 timestamp); function VehicleOwner() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } function createNewVehicle(string model, string make, bytes32 vin) public onlyOwner { address newVehicle = new Vehicle(model, make, vin); vehicles[vin] = newVehicle; NewVehicleAdded(newVehicle, now); } } 让我们一行一行地了解这些代码都干了些什么。 1.代码：pragma solidity 0.4.18; 分析：指定使用的编译器的版本。在这儿是0.4.18 2.代码：import“./Vehicle.sol”;* 分析：导入用于代表新车辆的智能合约。 3.代码：contract VehicleOwner { 分析：声明车主合约。 4.代码： address public owner; mapping(bytes32 =&gt; address) public vehicles; 分析：这是我们充实合约的地方。第一个变量调用所有者owner并表示创建VehicleOwner合约的任何给定实例的以太坊。 第二个称为vehicles车辆，将用于存储车主拥有的车辆清单，通过将其合约地址分配给提供的车辆识别号码。 5.代码： function VehicleOwner() public { owner = msg.sender; } 分析：看看该函数与合约的名称是什么？这是因为这个特定的函数是一个构造函数。它唯一的功能是将调用该函数的地址指定为合约所有者。 6.代码： modifier onlyOwner() { require(msg.sender == owner); _; } 分析：使用此函数修饰符确保只有合约所有者才能访问合约。 看到_？这产生了稍后应用修改器modifier的函数体。 7.代码： function createNewVehicle(string model, string make, bytes32 vin) public onlyOwner { address newVehicle = new Vehicle(model, make, vin); vehicles[vin] = newVehicle; NewVehicleAdded(newVehicle, now); } 分析：这在区块链上创建了一个新合约，这是一种新车辆的代表。车辆合约的构造函数接收三个属性：model，make和vin，后者可用于识别特定车辆。 创建新合约将返回其新分配的地址。在函数中，使用车辆的映射，我们将给定的vin绑定到该地址。最后，该函数广播一个新事件，传入地址和当前时间戳。 代码示例2 contract BasicIterator { address creator; // reserve one &quot;address&quot;-type spot uint8[10] integers; // reserve a chunk of storage for 10 8-bit unsigned integers in an array function BasicIterator() { creator = msg.sender; uint8 x = 0; //Section 1: Assigning values while(x &lt; integers.length) { integers[x] = x; x++; } } function getSum() constant returns (uint) { uint8 sum = 0; uint8 x = 0; //Section 2: Adding the integers in an array. while(x &lt; integers.length) { sum = sum + integers[x]; x++; } return sum; } // Section 3: Killing the contract function kill() { if (msg.sender == creator) { suicide(creator); } } } 那么，让我们来分析吧。 第1节：赋值 在第一步中，我们赋值一个名为“integers”的数组，该数组接收10个8位无符号整数。我们这样做的方式是通过while循环。让我们来看看while循环中发生了什么。 while(x &lt; integers.length) { integers[x] = x; x++; } 请记住，我们已经为整数x赋值“0”。while循环从0变为integers.length。Integers.length是一个返回数组最大容量的函数。因此，如果我们确定一个数组将有10个整数，arrayname.length将返回一个值10。在上面的循环中，x的值从0到9（&lt;10）并将其自身的值赋给整数数组也是如此。因此，在循环结束时，“integers”将具有以下值： 0,1,2,3,4,5,6,7,8,9。 第2节：添加数组内容 在getSum()函数内部，我们将添加数组本身的内容。它的方式是通过重复上面相同的while循环并使用变量“sum”来添加数组的内容。 第3节：终止合约 此功能终止合约并将合约中的剩余资金发回给合约创建者。 因此，这应该可以让你更好地了解solidity合约看起来是什么样子的以及你应该从那里获得什么样的代码细分类型。 以太和gas有什么区别？ 这是你的开发人员应该熟悉的另一个核心概念。 以太是生态系统中的主要标记。这是激励玩家完成智能合约的动力。 gas是满足特定合约所需的燃料量。 当有人提交智能合约时，它具有预先确定的gas价值。合约执行时，合约的每一步都需要一定量的气体来执行。 这可能导致两种情况： 所需的gas超过设定的极限。如果是这种情况，则合约状态将恢复到原始状态，并且所有气体都用完了。 所需gas小于设定的极限。如果是这种情况，那么合约就完成了，剩余的gas将交给合约制定者。 以下是显示Wei的平均gas价格的图表。 gas是以太坊的生命线。 以太坊的所有交易均由矿工验证。基本上，他们必须手动将每个交易放入他们为了验证交易而挖掘的块中。为了换取他们的服务，他们收取了一定的交易费用。 通常，优先考虑高gas费的智能合约，因为矿工有机会在那里收取更高的费用。与比特币相比，收取的费用只是象征性的。 此图表比较了比特币与以太坊的交易费用。 实际上，正如你所看到的，在0.01以太的此次交易中，仅收取0.00000000000002以太的gas作为交易费用&lt;$0.000001。 所以，正如你所看到的，以太坊的矿工只收取非常象征性的交易费用。显然收取交易费是矿工的次要角色，他们的主要工作是…好吧…挖矿！ 问题与解答 提炼所有这些知识，让我们对你可以提出的一些具体问题。 1.问题：合约构造函数是如何定义的？ 解答：构造函数被定义为一个函数，其名称与合约完全相同。 2.问题：在以太坊中记录的事件在哪里？它们的目的是什么？ 解答：日志是合约发出的事件。这些是其交易收据的一部分以及在以太坊虚拟机（EVM）上执行的LOG opcodes操作码的结果。这些事件主要用于与前端通信或作为廉价的数据存储。因为交易的返回值只是交易的hash，区块链需要一些时间来达成共识并验证交易，通过将它们挖掘到新块中。通过发出事件并使前端收听（观察）这些事件，实现了有效的通信。 3.问题：mappings映射是什么？ 解答：映射等同于其他编程语言中的字典或映射。它就是键值存储。 4.问题：修饰语purpose of modifiers的目的是什么？ 解答：顾名思义，他们修改使用它们的功能。但是，在执行函数之前必须满足修饰符的条件。如果不是，那么修饰符会抛出错误。 5.问题：以太坊库libraries是什么？ 解答：以太坊库有助于隔离整体逻辑。它们是一组使用以太坊虚拟机（EVM）在区块链上使用的软件包。所有库都可以在智能合约中部署和链接。它们可以通过DELEGATECALL调用。 6.问题：为什么在智能合约上调用方法需要花钱？ 解答：当调用方法时，它们会改变区块链的状态。由于操作需要gas，因此需要花钱。 哪里可以找到优秀的开发人员？ 在像LinkedIn和谷歌这样的“传统地方”很难找到优秀的开发者。但是，Reddit，GitHub等是寻找这些开发人员的好地方。 另外，还有一件事。由于这是一个利基人才市场，你应该对他们可能在你的城市甚至你自己的国家的事实持开放态度。应该为远程工作做好准备，特别是如果你正在寻找优秀开发者。 这可能是一种痛苦，但这是“质量超过数量”的必须面对的情况之一。 结论 当你面试以太坊开发人员时，你必须记住一件事。他们没有必要彻底回答所有问题。重要的是他们的热情以及他们是否能够专门回答与他们的工作和角色有关的问题。 无论如何，本指南应该帮助你了解特别的区块链开发人员。最后一句忠告，请不要和开发人员的质量妥协。请记住，质量永远胜过数量。 ====================================================================== 分享一些以太坊、EOS、比特币等区块链相关的交互式在线编程实战教程： java以太坊开发教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和交易等内容。 以太坊入门教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发进阶教程，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和交易等。 EOS教程，本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 java比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Java代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Java工程师不可多得的比特币开发学习课程。 php比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Php代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Php工程师不可多得的比特币开发学习课程。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多" />
<meta property="og:description" content="对优质区块链开发人员的需求很大，这是有充分理由的。区块链和ICO领域在过去几年中爆炸式增长。越来越多的人试图进入并在该领域中扬名立万。但是，为了获得成功，他们拥有一支强大而健全的团队至关重要。区块链开发人员，更准确地说，以太坊开发人员是该团队中最关键的组成部分。 因此，在本指南中，我们将使你的生活更轻松。我们将向你展示如何精确定位和从人群中筛选的优秀的人才。 在我们雇用以太坊开发者之前，重要的是我们要知道我们雇用的是哪类人。 怎么样才算是一个完美NB的以太坊开发者？ 在以太坊开发者精湛的技能中，最重要的是要知道将最优秀的与其他人区分开的基本品质是什么？优秀的开发人员必须不仅仅是具有区块链编码技能的开发人员。我们并不是说只熟悉编码就没有价值，但是，如果你需要一个合适的开发人员来创建一个帝国。那么，你正在寻找的一些主要品质是什么？ 去中心化的坚定信念：这些人认为去中心化将挽救人类。传统公司不会雇佣这些人，因为他们相信社会，公司和政府等机构不应该去中心化。 掌握密码学：区块链开发人员需要掌握加密经济学。加密经济学，密码学和经济学分为两部分。这就是为什么伟大的以太坊开发人员应该对密码学有一种不懈的好奇心。 掌握经济学：加密经济学的后半部分是“经济学”，因此专业开发人员也应该具备经济和博弈论机制的良好知识。如果你正在创建区块链平台，则代码应确保所有参与者都受到经济激励。 极度好奇：为了拥有如此庞大的知识基础，这些人天生就非常好奇。这些人大多都是直到深夜还通过视频，论坛，维基来了解特定问题。 所以，现在我们知道我们正在寻找的那种人。这就是为什么说从头开始了解一些以太坊基础知识是有道理的。 我们为什么这样做？ 因为每个以太坊开发者都应该完全熟悉这些概念。 什么是以太坊？ 这是以太坊网站定义的方式： 以太坊是一个区中的平台，运行智能合约：完全按照程序方式运行的应用程序，没有任何停机，审查，欺诈或第三方干扰的可能性。这些应用程序运行在定制的区块链上，这是一个非常强大的共享的全局基础架构，可以转移价值并体现财产的所有权。 但简单来说，以太坊计划成为未来的终极软件平台。如果未来是去中心化的，并且dAPP变得司空见惯，那么以太坊必须成为它的前沿和中心。 虽然比特币是区块链技术的第一个应用，但它仍然只是一种货币。以太坊带来了区块链技术可能实现的全部应用范围。 正如以太坊联合创始人Gavin Wood博士所说： 比特币首先是一种货币;这是区块链的一个特殊应用。但是，它远非唯一的应用程序。举一个类似情况的过去例子，电子邮件是互联网的一种特殊用途，并且肯定有助于推广它，但还有很多其他的应用。 以太坊采矿如何工作？ 截至目前，以太坊正在使用比特币正在使用的相同的工作量证明（Proof-of-Work）。然而，以太坊很快计划转向权益证明（Proof-of-stake），他们将使用Casper协议来实现这一转变。 那么权益证明和工作量证明之间有什么区别？这实际上是你可以问人们你可能会面试的事情。了解工作量证明和权益证明的工作原理绝对至关重要。 工作量证明：这是大多数加密货币如以太坊和比特币迄今为止遵循的协议。这意味着矿工通过使用专用硬件通过“挖矿”来挖掘加密货币。 权益证明：该协议将使整个挖掘过程成为虚拟的。在这个系统中，我们有验证器而不是矿工。它的工作方式是，作为一个验证器，你首先必须把你的一些以太锁作为赌注。完成后，你将开始验证块，这基本上意味着如果你看到任何你认为可以附加到区块链的块，你可以通过下注来验证它。当块被追加时，你将获得与你投资的比例成比例的奖励。但是，如果你在错误或恶意区块上下注，你投入的股份将被剥夺。 为了实现“权益证明”，以太坊将使用Casper一致性算法。一开始，它将是一个混合风格的系统，其中大多数交易仍将是工作量证明，而每100个交易将成为权益证明。这样做意味着，它将提供真实世界在以太坊平台上来测试验证。但这对于以太坊意味着什么？这个协议的优点是什么？让我们来看看： 权益证明的优点 降低整体能源消耗和货币成本：世界范围比特币矿工每小时花费约50,000美元用电。那是每天120万美元，每月3600万美元，每年约4.5亿美元！只是把最重要的放在那些数字和浪费的电量上。通过使用“权益证明”，你将使整个过程完全虚拟化，并切断所有这些成本。 没有ASIC优势：由于整个过程将是虚拟的，因此不依赖于谁拥有更好的设备或ASIC（专用集成电路）。 使51％的攻击更难：51％的攻击发生在一群矿工获得超过世界散射能力的50％时。使用权益证明可以抵消这种攻击。 无恶意验证者：任何将资金锁定在区块链中的验证人都会确保他们不会向链中添加任何错误或恶意的区块，因为这意味着他们投入的全部股权将被剥夺。 块创建：更快地创建更新的块和整个过程。 可伸缩性：通过引入“分片”概念使区块链可扩展（稍后将详细介绍）。 尽管之前有过各种简单的权益证明实施，但Casper与其他方式的区别在于，它激励了诚实的矿工并惩罚了不诚实的矿工。如果你已经将你的赌注置于恶意区块上，那么赌注将被取走。它将惩罚任何不遵守规则的人。 这是Vitalik解释它的方式： 想象一下，100个人坐在圆桌旁。一个人有一堆文件，每个文件都有不同的交易历史。第一个参与者拿起一支笔并签一张，然后将其传递给下一个做出类似选择的人。如果每个参与者签署了大多数参与者最终签署的交易历史记录，则每个参与者只能获得1美元。如果你在一个页面上签名并稍后签署另外不该签的一页，那么你的房子就会被烧毁。然后他补充说，这可能是正确签署的好动力！ 什么是智能合约？ 智能合约是自动化合约。它们是自动执行的，并且在其代码上写入特定指令，这些指令在特定条件下执行。 你可以在我们的其他文章中了解有关智能合约的更多信息。 智能合约是以太坊生态系统中的任务完成的方式。当有人想要在以太坊完成特定任务时，他们会与一个或多个人签订智能合约。 智能合约是一系列指令，使用编程语言solidity编写，它基于IFTTT逻辑（即IF-THIS-THEN-THAT逻辑）工作。基本上，如果完成了第一组指令，则执行下一个函数，然后执行下一个函数并继续重复，直到合约结束。 理解这一点的最好方法是想象一台自动售货机。你采取的每个步骤都像下一步执行自身的触发器。它有点像多米诺骨牌效应。那么，让我们来看看在与自动售货机交互时你将采取的步骤： 第1步：你给自动售货机一些钱。 第2步：按下与所需产品对应的按钮。 第3步：该产品出来，你收起它。 现在看看所有这些步骤并考虑一下。如果前一个步骤没有执行，其他任何步骤都还可以工作吗？这些步骤中的每一步都与前一步骤直接相关。还有一个要考虑的因素，它是智能合约的一个组成部分。你可以看到，在与自动售货机的整个交互过程中，你（请求者）仅与机器（提供商）合作。绝对没有第三方参与。 那么，现在，如果它在以太坊网络中发生，那么这笔交易将如何？ 假设你刚刚从以太坊网络中的自动售货机购买了一些东西，那么步骤将如何？ 第1步：你给自动售货机一些钱，这由以太坊网络中的所有节点记录，并且交易在分类帐中更新。 第2步：按下与你想要的产品对应的按钮，并在以太坊网络和分类帐中更新记录。 第3步：产品出来，你收集它，这将由所有节点和分类帐记录。 你通过智能合约进行的每笔交易都将由网络记录和更新。这样做是因为它让每个参与合约的人都对他们的行为负责。它通过使整个网络可以看到每个动作来消除人类的恶意 好的，直到现在我们已经涵盖了以太坊是什么，什么是采矿，什么是智能合约。如果你的候选人不能令人满意地回答这些问题，那就让他们在那一瞬间离开。已经不值得你再花时间。 掌握智能合约代码 显然，这应该是所有伟大的开发人员的菜。你可以肯定地了解开发人员的专业知识的一种方法是让他们解释特定合约的工作原理。在这里，我们将向你展示两个solidity代码。你可以通过他们运行此代码并要求他们将其分解并向你解释每个步骤中发生的情况。 代码示例1 代码和解释来自toptal。 pragma solidity 0.4.18; import &quot;./Vehicle.sol&quot;; contract VehicleOwner { address public owner; mapping(bytes32 =&gt; address) public vehicles; event NewVehicleAdded(address indexed newVehicle, uint256 timestamp); function VehicleOwner() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } function createNewVehicle(string model, string make, bytes32 vin) public onlyOwner { address newVehicle = new Vehicle(model, make, vin); vehicles[vin] = newVehicle; NewVehicleAdded(newVehicle, now); } } 让我们一行一行地了解这些代码都干了些什么。 1.代码：pragma solidity 0.4.18; 分析：指定使用的编译器的版本。在这儿是0.4.18 2.代码：import“./Vehicle.sol”;* 分析：导入用于代表新车辆的智能合约。 3.代码：contract VehicleOwner { 分析：声明车主合约。 4.代码： address public owner; mapping(bytes32 =&gt; address) public vehicles; 分析：这是我们充实合约的地方。第一个变量调用所有者owner并表示创建VehicleOwner合约的任何给定实例的以太坊。 第二个称为vehicles车辆，将用于存储车主拥有的车辆清单，通过将其合约地址分配给提供的车辆识别号码。 5.代码： function VehicleOwner() public { owner = msg.sender; } 分析：看看该函数与合约的名称是什么？这是因为这个特定的函数是一个构造函数。它唯一的功能是将调用该函数的地址指定为合约所有者。 6.代码： modifier onlyOwner() { require(msg.sender == owner); _; } 分析：使用此函数修饰符确保只有合约所有者才能访问合约。 看到_？这产生了稍后应用修改器modifier的函数体。 7.代码： function createNewVehicle(string model, string make, bytes32 vin) public onlyOwner { address newVehicle = new Vehicle(model, make, vin); vehicles[vin] = newVehicle; NewVehicleAdded(newVehicle, now); } 分析：这在区块链上创建了一个新合约，这是一种新车辆的代表。车辆合约的构造函数接收三个属性：model，make和vin，后者可用于识别特定车辆。 创建新合约将返回其新分配的地址。在函数中，使用车辆的映射，我们将给定的vin绑定到该地址。最后，该函数广播一个新事件，传入地址和当前时间戳。 代码示例2 contract BasicIterator { address creator; // reserve one &quot;address&quot;-type spot uint8[10] integers; // reserve a chunk of storage for 10 8-bit unsigned integers in an array function BasicIterator() { creator = msg.sender; uint8 x = 0; //Section 1: Assigning values while(x &lt; integers.length) { integers[x] = x; x++; } } function getSum() constant returns (uint) { uint8 sum = 0; uint8 x = 0; //Section 2: Adding the integers in an array. while(x &lt; integers.length) { sum = sum + integers[x]; x++; } return sum; } // Section 3: Killing the contract function kill() { if (msg.sender == creator) { suicide(creator); } } } 那么，让我们来分析吧。 第1节：赋值 在第一步中，我们赋值一个名为“integers”的数组，该数组接收10个8位无符号整数。我们这样做的方式是通过while循环。让我们来看看while循环中发生了什么。 while(x &lt; integers.length) { integers[x] = x; x++; } 请记住，我们已经为整数x赋值“0”。while循环从0变为integers.length。Integers.length是一个返回数组最大容量的函数。因此，如果我们确定一个数组将有10个整数，arrayname.length将返回一个值10。在上面的循环中，x的值从0到9（&lt;10）并将其自身的值赋给整数数组也是如此。因此，在循环结束时，“integers”将具有以下值： 0,1,2,3,4,5,6,7,8,9。 第2节：添加数组内容 在getSum()函数内部，我们将添加数组本身的内容。它的方式是通过重复上面相同的while循环并使用变量“sum”来添加数组的内容。 第3节：终止合约 此功能终止合约并将合约中的剩余资金发回给合约创建者。 因此，这应该可以让你更好地了解solidity合约看起来是什么样子的以及你应该从那里获得什么样的代码细分类型。 以太和gas有什么区别？ 这是你的开发人员应该熟悉的另一个核心概念。 以太是生态系统中的主要标记。这是激励玩家完成智能合约的动力。 gas是满足特定合约所需的燃料量。 当有人提交智能合约时，它具有预先确定的gas价值。合约执行时，合约的每一步都需要一定量的气体来执行。 这可能导致两种情况： 所需的gas超过设定的极限。如果是这种情况，则合约状态将恢复到原始状态，并且所有气体都用完了。 所需gas小于设定的极限。如果是这种情况，那么合约就完成了，剩余的gas将交给合约制定者。 以下是显示Wei的平均gas价格的图表。 gas是以太坊的生命线。 以太坊的所有交易均由矿工验证。基本上，他们必须手动将每个交易放入他们为了验证交易而挖掘的块中。为了换取他们的服务，他们收取了一定的交易费用。 通常，优先考虑高gas费的智能合约，因为矿工有机会在那里收取更高的费用。与比特币相比，收取的费用只是象征性的。 此图表比较了比特币与以太坊的交易费用。 实际上，正如你所看到的，在0.01以太的此次交易中，仅收取0.00000000000002以太的gas作为交易费用&lt;$0.000001。 所以，正如你所看到的，以太坊的矿工只收取非常象征性的交易费用。显然收取交易费是矿工的次要角色，他们的主要工作是…好吧…挖矿！ 问题与解答 提炼所有这些知识，让我们对你可以提出的一些具体问题。 1.问题：合约构造函数是如何定义的？ 解答：构造函数被定义为一个函数，其名称与合约完全相同。 2.问题：在以太坊中记录的事件在哪里？它们的目的是什么？ 解答：日志是合约发出的事件。这些是其交易收据的一部分以及在以太坊虚拟机（EVM）上执行的LOG opcodes操作码的结果。这些事件主要用于与前端通信或作为廉价的数据存储。因为交易的返回值只是交易的hash，区块链需要一些时间来达成共识并验证交易，通过将它们挖掘到新块中。通过发出事件并使前端收听（观察）这些事件，实现了有效的通信。 3.问题：mappings映射是什么？ 解答：映射等同于其他编程语言中的字典或映射。它就是键值存储。 4.问题：修饰语purpose of modifiers的目的是什么？ 解答：顾名思义，他们修改使用它们的功能。但是，在执行函数之前必须满足修饰符的条件。如果不是，那么修饰符会抛出错误。 5.问题：以太坊库libraries是什么？ 解答：以太坊库有助于隔离整体逻辑。它们是一组使用以太坊虚拟机（EVM）在区块链上使用的软件包。所有库都可以在智能合约中部署和链接。它们可以通过DELEGATECALL调用。 6.问题：为什么在智能合约上调用方法需要花钱？ 解答：当调用方法时，它们会改变区块链的状态。由于操作需要gas，因此需要花钱。 哪里可以找到优秀的开发人员？ 在像LinkedIn和谷歌这样的“传统地方”很难找到优秀的开发者。但是，Reddit，GitHub等是寻找这些开发人员的好地方。 另外，还有一件事。由于这是一个利基人才市场，你应该对他们可能在你的城市甚至你自己的国家的事实持开放态度。应该为远程工作做好准备，特别是如果你正在寻找优秀开发者。 这可能是一种痛苦，但这是“质量超过数量”的必须面对的情况之一。 结论 当你面试以太坊开发人员时，你必须记住一件事。他们没有必要彻底回答所有问题。重要的是他们的热情以及他们是否能够专门回答与他们的工作和角色有关的问题。 无论如何，本指南应该帮助你了解特别的区块链开发人员。最后一句忠告，请不要和开发人员的质量妥协。请记住，质量永远胜过数量。 ====================================================================== 分享一些以太坊、EOS、比特币等区块链相关的交互式在线编程实战教程： java以太坊开发教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和交易等内容。 以太坊入门教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发进阶教程，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和交易等。 EOS教程，本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 java比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Java代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Java工程师不可多得的比特币开发学习课程。 php比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Php代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Php工程师不可多得的比特币开发学习课程。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/10/12/bf4d60a2bef2f440834995f1249ebaa1.html" />
<meta property="og:url" content="https://mlh.app/2018/10/12/bf4d60a2bef2f440834995f1249ebaa1.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-10-12T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"对优质区块链开发人员的需求很大，这是有充分理由的。区块链和ICO领域在过去几年中爆炸式增长。越来越多的人试图进入并在该领域中扬名立万。但是，为了获得成功，他们拥有一支强大而健全的团队至关重要。区块链开发人员，更准确地说，以太坊开发人员是该团队中最关键的组成部分。 因此，在本指南中，我们将使你的生活更轻松。我们将向你展示如何精确定位和从人群中筛选的优秀的人才。 在我们雇用以太坊开发者之前，重要的是我们要知道我们雇用的是哪类人。 怎么样才算是一个完美NB的以太坊开发者？ 在以太坊开发者精湛的技能中，最重要的是要知道将最优秀的与其他人区分开的基本品质是什么？优秀的开发人员必须不仅仅是具有区块链编码技能的开发人员。我们并不是说只熟悉编码就没有价值，但是，如果你需要一个合适的开发人员来创建一个帝国。那么，你正在寻找的一些主要品质是什么？ 去中心化的坚定信念：这些人认为去中心化将挽救人类。传统公司不会雇佣这些人，因为他们相信社会，公司和政府等机构不应该去中心化。 掌握密码学：区块链开发人员需要掌握加密经济学。加密经济学，密码学和经济学分为两部分。这就是为什么伟大的以太坊开发人员应该对密码学有一种不懈的好奇心。 掌握经济学：加密经济学的后半部分是“经济学”，因此专业开发人员也应该具备经济和博弈论机制的良好知识。如果你正在创建区块链平台，则代码应确保所有参与者都受到经济激励。 极度好奇：为了拥有如此庞大的知识基础，这些人天生就非常好奇。这些人大多都是直到深夜还通过视频，论坛，维基来了解特定问题。 所以，现在我们知道我们正在寻找的那种人。这就是为什么说从头开始了解一些以太坊基础知识是有道理的。 我们为什么这样做？ 因为每个以太坊开发者都应该完全熟悉这些概念。 什么是以太坊？ 这是以太坊网站定义的方式： 以太坊是一个区中的平台，运行智能合约：完全按照程序方式运行的应用程序，没有任何停机，审查，欺诈或第三方干扰的可能性。这些应用程序运行在定制的区块链上，这是一个非常强大的共享的全局基础架构，可以转移价值并体现财产的所有权。 但简单来说，以太坊计划成为未来的终极软件平台。如果未来是去中心化的，并且dAPP变得司空见惯，那么以太坊必须成为它的前沿和中心。 虽然比特币是区块链技术的第一个应用，但它仍然只是一种货币。以太坊带来了区块链技术可能实现的全部应用范围。 正如以太坊联合创始人Gavin Wood博士所说： 比特币首先是一种货币;这是区块链的一个特殊应用。但是，它远非唯一的应用程序。举一个类似情况的过去例子，电子邮件是互联网的一种特殊用途，并且肯定有助于推广它，但还有很多其他的应用。 以太坊采矿如何工作？ 截至目前，以太坊正在使用比特币正在使用的相同的工作量证明（Proof-of-Work）。然而，以太坊很快计划转向权益证明（Proof-of-stake），他们将使用Casper协议来实现这一转变。 那么权益证明和工作量证明之间有什么区别？这实际上是你可以问人们你可能会面试的事情。了解工作量证明和权益证明的工作原理绝对至关重要。 工作量证明：这是大多数加密货币如以太坊和比特币迄今为止遵循的协议。这意味着矿工通过使用专用硬件通过“挖矿”来挖掘加密货币。 权益证明：该协议将使整个挖掘过程成为虚拟的。在这个系统中，我们有验证器而不是矿工。它的工作方式是，作为一个验证器，你首先必须把你的一些以太锁作为赌注。完成后，你将开始验证块，这基本上意味着如果你看到任何你认为可以附加到区块链的块，你可以通过下注来验证它。当块被追加时，你将获得与你投资的比例成比例的奖励。但是，如果你在错误或恶意区块上下注，你投入的股份将被剥夺。 为了实现“权益证明”，以太坊将使用Casper一致性算法。一开始，它将是一个混合风格的系统，其中大多数交易仍将是工作量证明，而每100个交易将成为权益证明。这样做意味着，它将提供真实世界在以太坊平台上来测试验证。但这对于以太坊意味着什么？这个协议的优点是什么？让我们来看看： 权益证明的优点 降低整体能源消耗和货币成本：世界范围比特币矿工每小时花费约50,000美元用电。那是每天120万美元，每月3600万美元，每年约4.5亿美元！只是把最重要的放在那些数字和浪费的电量上。通过使用“权益证明”，你将使整个过程完全虚拟化，并切断所有这些成本。 没有ASIC优势：由于整个过程将是虚拟的，因此不依赖于谁拥有更好的设备或ASIC（专用集成电路）。 使51％的攻击更难：51％的攻击发生在一群矿工获得超过世界散射能力的50％时。使用权益证明可以抵消这种攻击。 无恶意验证者：任何将资金锁定在区块链中的验证人都会确保他们不会向链中添加任何错误或恶意的区块，因为这意味着他们投入的全部股权将被剥夺。 块创建：更快地创建更新的块和整个过程。 可伸缩性：通过引入“分片”概念使区块链可扩展（稍后将详细介绍）。 尽管之前有过各种简单的权益证明实施，但Casper与其他方式的区别在于，它激励了诚实的矿工并惩罚了不诚实的矿工。如果你已经将你的赌注置于恶意区块上，那么赌注将被取走。它将惩罚任何不遵守规则的人。 这是Vitalik解释它的方式： 想象一下，100个人坐在圆桌旁。一个人有一堆文件，每个文件都有不同的交易历史。第一个参与者拿起一支笔并签一张，然后将其传递给下一个做出类似选择的人。如果每个参与者签署了大多数参与者最终签署的交易历史记录，则每个参与者只能获得1美元。如果你在一个页面上签名并稍后签署另外不该签的一页，那么你的房子就会被烧毁。然后他补充说，这可能是正确签署的好动力！ 什么是智能合约？ 智能合约是自动化合约。它们是自动执行的，并且在其代码上写入特定指令，这些指令在特定条件下执行。 你可以在我们的其他文章中了解有关智能合约的更多信息。 智能合约是以太坊生态系统中的任务完成的方式。当有人想要在以太坊完成特定任务时，他们会与一个或多个人签订智能合约。 智能合约是一系列指令，使用编程语言solidity编写，它基于IFTTT逻辑（即IF-THIS-THEN-THAT逻辑）工作。基本上，如果完成了第一组指令，则执行下一个函数，然后执行下一个函数并继续重复，直到合约结束。 理解这一点的最好方法是想象一台自动售货机。你采取的每个步骤都像下一步执行自身的触发器。它有点像多米诺骨牌效应。那么，让我们来看看在与自动售货机交互时你将采取的步骤： 第1步：你给自动售货机一些钱。 第2步：按下与所需产品对应的按钮。 第3步：该产品出来，你收起它。 现在看看所有这些步骤并考虑一下。如果前一个步骤没有执行，其他任何步骤都还可以工作吗？这些步骤中的每一步都与前一步骤直接相关。还有一个要考虑的因素，它是智能合约的一个组成部分。你可以看到，在与自动售货机的整个交互过程中，你（请求者）仅与机器（提供商）合作。绝对没有第三方参与。 那么，现在，如果它在以太坊网络中发生，那么这笔交易将如何？ 假设你刚刚从以太坊网络中的自动售货机购买了一些东西，那么步骤将如何？ 第1步：你给自动售货机一些钱，这由以太坊网络中的所有节点记录，并且交易在分类帐中更新。 第2步：按下与你想要的产品对应的按钮，并在以太坊网络和分类帐中更新记录。 第3步：产品出来，你收集它，这将由所有节点和分类帐记录。 你通过智能合约进行的每笔交易都将由网络记录和更新。这样做是因为它让每个参与合约的人都对他们的行为负责。它通过使整个网络可以看到每个动作来消除人类的恶意 好的，直到现在我们已经涵盖了以太坊是什么，什么是采矿，什么是智能合约。如果你的候选人不能令人满意地回答这些问题，那就让他们在那一瞬间离开。已经不值得你再花时间。 掌握智能合约代码 显然，这应该是所有伟大的开发人员的菜。你可以肯定地了解开发人员的专业知识的一种方法是让他们解释特定合约的工作原理。在这里，我们将向你展示两个solidity代码。你可以通过他们运行此代码并要求他们将其分解并向你解释每个步骤中发生的情况。 代码示例1 代码和解释来自toptal。 pragma solidity 0.4.18; import &quot;./Vehicle.sol&quot;; contract VehicleOwner { address public owner; mapping(bytes32 =&gt; address) public vehicles; event NewVehicleAdded(address indexed newVehicle, uint256 timestamp); function VehicleOwner() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } function createNewVehicle(string model, string make, bytes32 vin) public onlyOwner { address newVehicle = new Vehicle(model, make, vin); vehicles[vin] = newVehicle; NewVehicleAdded(newVehicle, now); } } 让我们一行一行地了解这些代码都干了些什么。 1.代码：pragma solidity 0.4.18; 分析：指定使用的编译器的版本。在这儿是0.4.18 2.代码：import“./Vehicle.sol”;* 分析：导入用于代表新车辆的智能合约。 3.代码：contract VehicleOwner { 分析：声明车主合约。 4.代码： address public owner; mapping(bytes32 =&gt; address) public vehicles; 分析：这是我们充实合约的地方。第一个变量调用所有者owner并表示创建VehicleOwner合约的任何给定实例的以太坊。 第二个称为vehicles车辆，将用于存储车主拥有的车辆清单，通过将其合约地址分配给提供的车辆识别号码。 5.代码： function VehicleOwner() public { owner = msg.sender; } 分析：看看该函数与合约的名称是什么？这是因为这个特定的函数是一个构造函数。它唯一的功能是将调用该函数的地址指定为合约所有者。 6.代码： modifier onlyOwner() { require(msg.sender == owner); _; } 分析：使用此函数修饰符确保只有合约所有者才能访问合约。 看到_？这产生了稍后应用修改器modifier的函数体。 7.代码： function createNewVehicle(string model, string make, bytes32 vin) public onlyOwner { address newVehicle = new Vehicle(model, make, vin); vehicles[vin] = newVehicle; NewVehicleAdded(newVehicle, now); } 分析：这在区块链上创建了一个新合约，这是一种新车辆的代表。车辆合约的构造函数接收三个属性：model，make和vin，后者可用于识别特定车辆。 创建新合约将返回其新分配的地址。在函数中，使用车辆的映射，我们将给定的vin绑定到该地址。最后，该函数广播一个新事件，传入地址和当前时间戳。 代码示例2 contract BasicIterator { address creator; // reserve one &quot;address&quot;-type spot uint8[10] integers; // reserve a chunk of storage for 10 8-bit unsigned integers in an array function BasicIterator() { creator = msg.sender; uint8 x = 0; //Section 1: Assigning values while(x &lt; integers.length) { integers[x] = x; x++; } } function getSum() constant returns (uint) { uint8 sum = 0; uint8 x = 0; //Section 2: Adding the integers in an array. while(x &lt; integers.length) { sum = sum + integers[x]; x++; } return sum; } // Section 3: Killing the contract function kill() { if (msg.sender == creator) { suicide(creator); } } } 那么，让我们来分析吧。 第1节：赋值 在第一步中，我们赋值一个名为“integers”的数组，该数组接收10个8位无符号整数。我们这样做的方式是通过while循环。让我们来看看while循环中发生了什么。 while(x &lt; integers.length) { integers[x] = x; x++; } 请记住，我们已经为整数x赋值“0”。while循环从0变为integers.length。Integers.length是一个返回数组最大容量的函数。因此，如果我们确定一个数组将有10个整数，arrayname.length将返回一个值10。在上面的循环中，x的值从0到9（&lt;10）并将其自身的值赋给整数数组也是如此。因此，在循环结束时，“integers”将具有以下值： 0,1,2,3,4,5,6,7,8,9。 第2节：添加数组内容 在getSum()函数内部，我们将添加数组本身的内容。它的方式是通过重复上面相同的while循环并使用变量“sum”来添加数组的内容。 第3节：终止合约 此功能终止合约并将合约中的剩余资金发回给合约创建者。 因此，这应该可以让你更好地了解solidity合约看起来是什么样子的以及你应该从那里获得什么样的代码细分类型。 以太和gas有什么区别？ 这是你的开发人员应该熟悉的另一个核心概念。 以太是生态系统中的主要标记。这是激励玩家完成智能合约的动力。 gas是满足特定合约所需的燃料量。 当有人提交智能合约时，它具有预先确定的gas价值。合约执行时，合约的每一步都需要一定量的气体来执行。 这可能导致两种情况： 所需的gas超过设定的极限。如果是这种情况，则合约状态将恢复到原始状态，并且所有气体都用完了。 所需gas小于设定的极限。如果是这种情况，那么合约就完成了，剩余的gas将交给合约制定者。 以下是显示Wei的平均gas价格的图表。 gas是以太坊的生命线。 以太坊的所有交易均由矿工验证。基本上，他们必须手动将每个交易放入他们为了验证交易而挖掘的块中。为了换取他们的服务，他们收取了一定的交易费用。 通常，优先考虑高gas费的智能合约，因为矿工有机会在那里收取更高的费用。与比特币相比，收取的费用只是象征性的。 此图表比较了比特币与以太坊的交易费用。 实际上，正如你所看到的，在0.01以太的此次交易中，仅收取0.00000000000002以太的gas作为交易费用&lt;$0.000001。 所以，正如你所看到的，以太坊的矿工只收取非常象征性的交易费用。显然收取交易费是矿工的次要角色，他们的主要工作是…好吧…挖矿！ 问题与解答 提炼所有这些知识，让我们对你可以提出的一些具体问题。 1.问题：合约构造函数是如何定义的？ 解答：构造函数被定义为一个函数，其名称与合约完全相同。 2.问题：在以太坊中记录的事件在哪里？它们的目的是什么？ 解答：日志是合约发出的事件。这些是其交易收据的一部分以及在以太坊虚拟机（EVM）上执行的LOG opcodes操作码的结果。这些事件主要用于与前端通信或作为廉价的数据存储。因为交易的返回值只是交易的hash，区块链需要一些时间来达成共识并验证交易，通过将它们挖掘到新块中。通过发出事件并使前端收听（观察）这些事件，实现了有效的通信。 3.问题：mappings映射是什么？ 解答：映射等同于其他编程语言中的字典或映射。它就是键值存储。 4.问题：修饰语purpose of modifiers的目的是什么？ 解答：顾名思义，他们修改使用它们的功能。但是，在执行函数之前必须满足修饰符的条件。如果不是，那么修饰符会抛出错误。 5.问题：以太坊库libraries是什么？ 解答：以太坊库有助于隔离整体逻辑。它们是一组使用以太坊虚拟机（EVM）在区块链上使用的软件包。所有库都可以在智能合约中部署和链接。它们可以通过DELEGATECALL调用。 6.问题：为什么在智能合约上调用方法需要花钱？ 解答：当调用方法时，它们会改变区块链的状态。由于操作需要gas，因此需要花钱。 哪里可以找到优秀的开发人员？ 在像LinkedIn和谷歌这样的“传统地方”很难找到优秀的开发者。但是，Reddit，GitHub等是寻找这些开发人员的好地方。 另外，还有一件事。由于这是一个利基人才市场，你应该对他们可能在你的城市甚至你自己的国家的事实持开放态度。应该为远程工作做好准备，特别是如果你正在寻找优秀开发者。 这可能是一种痛苦，但这是“质量超过数量”的必须面对的情况之一。 结论 当你面试以太坊开发人员时，你必须记住一件事。他们没有必要彻底回答所有问题。重要的是他们的热情以及他们是否能够专门回答与他们的工作和角色有关的问题。 无论如何，本指南应该帮助你了解特别的区块链开发人员。最后一句忠告，请不要和开发人员的质量妥协。请记住，质量永远胜过数量。 ====================================================================== 分享一些以太坊、EOS、比特币等区块链相关的交互式在线编程实战教程： java以太坊开发教程，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。 php以太坊，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和交易等内容。 以太坊入门教程，主要介绍智能合约与dapp应用开发，适合入门。 以太坊开发进阶教程，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。 python以太坊，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。 C#以太坊，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和交易等。 EOS教程，本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。 java比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Java代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Java工程师不可多得的比特币开发学习课程。 php比特币开发教程，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Php代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Php工程师不可多得的比特币开发学习课程。 汇智网原创翻译，转载请标明出处。这里是原文 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/10/12/bf4d60a2bef2f440834995f1249ebaa1.html","headline":"如何才能招聘到合适的以太坊区块链开发者","dateModified":"2018-10-12T00:00:00+08:00","datePublished":"2018-10-12T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/10/12/bf4d60a2bef2f440834995f1249ebaa1.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>如何才能招聘到合适的以太坊区块链开发者</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>对优质区块链开发人员的需求很大，这是有充分理由的。区块链和ICO领域在过去几年中爆炸式增长。越来越多的人试图进入并在该领域中扬名立万。但是，为了获得成功，他们拥有一支强大而健全的团队至关重要。区块链开发人员，更准确地说，以太坊开发人员是该团队中最关键的组成部分。</p> 
  <p>因此，在本指南中，我们将使你的生活更轻松。我们将向你展示如何精确定位和从人群中筛选的优秀的人才。</p> 
  <p>在我们雇用以太坊开发者之前，重要的是我们要知道我们雇用的是哪类人。</p> 
  <h3><a id="NB_7"></a>怎么样才算是一个完美NB的以太坊开发者？</h3> 
  <p>在以太坊开发者精湛的技能中，最重要的是要知道将最优秀的与其他人区分开的基本品质是什么？优秀的开发人员必须不仅仅是具有区块链编码技能的开发人员。我们并不是说只熟悉编码就没有价值，但是，如果你需要一个合适的开发人员来创建一个帝国。那么，你正在寻找的一些主要品质是什么？</p> 
  <ul> 
   <li>去中心化的坚定信念：这些人认为去中心化将挽救人类。传统公司不会雇佣这些人，因为他们相信社会，公司和政府等机构不应该去中心化。</li> 
   <li>掌握密码学：区块链开发人员需要掌握加密经济学。加密经济学，密码学和经济学分为两部分。这就是为什么伟大的以太坊开发人员应该对密码学有一种不懈的好奇心。</li> 
   <li>掌握经济学：加密经济学的后半部分是“经济学”，因此专业开发人员也应该具备经济和博弈论机制的良好知识。如果你正在创建区块链平台，则代码应确保所有参与者都受到经济激励。</li> 
   <li>极度好奇：为了拥有如此庞大的知识基础，这些人天生就非常好奇。这些人大多都是直到深夜还通过视频，论坛，维基来了解特定问题。</li> 
  </ul> 
  <p>所以，现在我们知道我们正在寻找的那种人。这就是为什么说从头开始了解一些以太坊基础知识是有道理的。</p> 
  <h3><a id="_18"></a>我们为什么这样做？</h3> 
  <p>因为每个以太坊开发者都应该完全熟悉这些概念。</p> 
  <h3><a id="_22"></a>什么是以太坊？</h3> 
  <p>这是以太坊网站定义的方式：</p> 
  <blockquote> 
   <ul> 
    <li>以太坊是一个区中的平台，运行智能合约：完全按照程序方式运行的应用程序，没有任何停机，审查，欺诈或第三方干扰的可能性。这些应用程序运行在定制的区块链上，这是一个非常强大的共享的全局基础架构，可以转移价值并体现财产的所有权。</li> 
   </ul> 
  </blockquote> 
  <p>但简单来说，以太坊计划成为未来的终极软件平台。如果未来是去中心化的，并且dAPP变得司空见惯，那么以太坊必须成为它的前沿和中心。</p> 
  <p>虽然比特币是区块链技术的第一个应用，但它仍然只是一种货币。以太坊带来了区块链技术可能实现的全部应用范围。</p> 
  <p>正如以太坊联合创始人Gavin Wood博士所说：</p> 
  <blockquote> 
   <ul> 
    <li>比特币首先是一种货币;这是区块链的一个特殊应用。但是，它远非唯一的应用程序。举一个类似情况的过去例子，电子邮件是互联网的一种特殊用途，并且肯定有助于推广它，但还有很多其他的应用。</li> 
   </ul> 
  </blockquote> 
  <h3><a id="_36"></a>以太坊采矿如何工作？</h3> 
  <p>截至目前，以太坊正在使用比特币正在使用的相同的工作量证明（Proof-of-Work）。然而，以太坊很快计划转向权益证明（Proof-of-stake），他们将使用<code>Casper</code>协议来实现这一转变。</p> 
  <p>那么权益证明和工作量证明之间有什么区别？这实际上是你可以问人们你可能会面试的事情。了解工作量证明和权益证明的工作原理绝对至关重要。</p> 
  <p>工作量证明：这是大多数加密货币如以太坊和比特币迄今为止遵循的协议。这意味着矿工通过使用专用硬件通过“挖矿”来挖掘加密货币。</p> 
  <p>权益证明：该协议将使整个挖掘过程成为虚拟的。在这个系统中，我们有验证器而不是矿工。它的工作方式是，作为一个验证器，你首先必须把你的一些以太锁作为赌注。完成后，你将开始验证块，这基本上意味着如果你看到任何你认为可以附加到区块链的块，你可以通过下注来验证它。当块被追加时，你将获得与你投资的比例成比例的奖励。但是，如果你在错误或恶意区块上下注，你投入的股份将被剥夺。</p> 
  <p>为了实现“权益证明”，以太坊将使用Casper一致性算法。一开始，它将是一个混合风格的系统，其中大多数交易仍将是工作量证明，而每100个交易将成为权益证明。这样做意味着，它将提供真实世界在以太坊平台上来测试验证。但这对于以太坊意味着什么？这个协议的优点是什么？让我们来看看：</p> 
  <p><img src="http://blog.hubwiz.com/2018/10/11/ethereum-Developer-hire/image1.png" alt=""></p> 
  <h3><a id="_50"></a>权益证明的优点</h3> 
  <ul> 
   <li>降低整体能源消耗和货币成本：世界范围比特币矿工每小时花费约50,000美元用电。那是每天120万美元，每月3600万美元，每年约4.5亿美元！只是把最重要的放在那些数字和浪费的电量上。通过使用“权益证明”，你将使整个过程完全虚拟化，并切断所有这些成本。</li> 
   <li>没有ASIC优势：由于整个过程将是虚拟的，因此不依赖于谁拥有更好的设备或ASIC（专用集成电路）。</li> 
   <li>使51％的攻击更难：51％的攻击发生在一群矿工获得超过世界散射能力的50％时。使用权益证明可以抵消这种攻击。</li> 
   <li>无恶意验证者：任何将资金锁定在区块链中的验证人都会确保他们不会向链中添加任何错误或恶意的区块，因为这意味着他们投入的全部股权将被剥夺。</li> 
   <li>块创建：更快地创建更新的块和整个过程。</li> 
   <li>可伸缩性：通过引入“分片”概念使区块链可扩展（稍后将详细介绍）。</li> 
  </ul> 
  <p>尽管之前有过各种简单的权益证明实施，但Casper与其他方式的区别在于，它激励了诚实的矿工并惩罚了不诚实的矿工。如果你已经将你的赌注置于恶意区块上，那么赌注将被取走。它将惩罚任何不遵守规则的人。</p> 
  <p>这是Vitalik解释它的方式：</p> 
  <blockquote> 
   <ul> 
    <li>想象一下，100个人坐在圆桌旁。一个人有一堆文件，每个文件都有不同的交易历史。第一个参与者拿起一支笔并签一张，然后将其传递给下一个做出类似选择的人。如果每个参与者签署了大多数参与者最终签署的交易历史记录，则每个参与者只能获得1美元。如果你在一个页面上签名并稍后签署另外不该签的一页，那么你的房子就会被烧毁。然后他补充说，这可能是正确签署的好动力！</li> 
   </ul> 
  </blockquote> 
  <h3><a id="_65"></a>什么是智能合约？</h3> 
  <p>智能合约是自动化合约。它们是自动执行的，并且在其代码上写入特定指令，这些指令在特定条件下执行。</p> 
  <p><img src="http://blog.hubwiz.com/2018/10/11/ethereum-Developer-hire/image3.png" alt=""></p> 
  <p>你可以在我们的其他文章中了解有关智能合约的更多信息。</p> 
  <p>智能合约是以太坊生态系统中的任务完成的方式。当有人想要在以太坊完成特定任务时，他们会与一个或多个人签订智能合约。</p> 
  <p>智能合约是一系列指令，使用编程语言<code>solidity</code>编写，它基于IFTTT逻辑（即IF-THIS-THEN-THAT逻辑）工作。基本上，如果完成了第一组指令，则执行下一个函数，然后执行下一个函数并继续重复，直到合约结束。</p> 
  <p>理解这一点的最好方法是想象一台自动售货机。你采取的每个步骤都像下一步执行自身的触发器。它有点像多米诺骨牌效应。那么，让我们来看看在与自动售货机交互时你将采取的步骤：</p> 
  <ul> 
   <li>第1步：你给自动售货机一些钱。</li> 
   <li>第2步：按下与所需产品对应的按钮。</li> 
   <li>第3步：该产品出来，你收起它。</li> 
  </ul> 
  <p>现在看看所有这些步骤并考虑一下。如果前一个步骤没有执行，其他任何步骤都还可以工作吗？这些步骤中的每一步都与前一步骤直接相关。还有一个要考虑的因素，它是智能合约的一个组成部分。你可以看到，在与自动售货机的整个交互过程中，你（请求者）仅与机器（提供商）合作。绝对没有第三方参与。</p> 
  <p>那么，现在，如果它在以太坊网络中发生，那么这笔交易将如何？</p> 
  <p>假设你刚刚从以太坊网络中的自动售货机购买了一些东西，那么步骤将如何？</p> 
  <ul> 
   <li>第1步：你给自动售货机一些钱，这由以太坊网络中的所有节点记录，并且交易在分类帐中更新。</li> 
   <li>第2步：按下与你想要的产品对应的按钮，并在以太坊网络和分类帐中更新记录。</li> 
   <li>第3步：产品出来，你收集它，这将由所有节点和分类帐记录。</li> 
  </ul> 
  <p>你通过智能合约进行的每笔交易都将由网络记录和更新。这样做是因为它让每个参与合约的人都对他们的行为负责。它通过使整个网络可以看到每个动作来消除人类的恶意</p> 
  <p>好的，直到现在我们已经涵盖了以太坊是什么，什么是采矿，什么是智能合约。如果你的候选人不能令人满意地回答这些问题，那就让他们在那一瞬间离开。已经不值得你再花时间。</p> 
  <h3><a id="_97"></a>掌握智能合约代码</h3> 
  <p>显然，这应该是所有伟大的开发人员的菜。你可以肯定地了解开发人员的专业知识的一种方法是让他们解释特定合约的工作原理。在这里，我们将向你展示两个<code>solidity</code>代码。你可以通过他们运行此代码并要求他们将其分解并向你解释每个步骤中发生的情况。</p> 
  <h3><a id="1_101"></a>代码示例1</h3> 
  <p>代码和解释来自toptal。</p> 
  <pre><code>pragma solidity 0.4.18;

import "./Vehicle.sol";


contract VehicleOwner {
    address public owner;
    mapping(bytes32 =&gt; address) public vehicles;

    event NewVehicleAdded(address indexed newVehicle, uint256 timestamp);

    function VehicleOwner() public {
        owner = msg.sender;
    }

    /**
    * @dev Throws if called by any account other than the owner.
    */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function createNewVehicle(string model, string make, bytes32 vin) public onlyOwner {
        address newVehicle = new Vehicle(model, make, vin);
        vehicles[vin] = newVehicle;
        NewVehicleAdded(newVehicle, now);
    }
}
</code></pre> 
  <p>让我们一行一行地了解这些代码都干了些什么。</p> 
  <p>1.<strong>代码：pragma solidity 0.4.18;</strong></p> 
  <p>分析：指定使用的编译器的版本。在这儿是0.4.18</p> 
  <p>2.<em>代码：import“./Vehicle.sol”;</em>*</p> 
  <p>分析：导入用于代表新车辆的智能合约。</p> 
  <p>3.<strong>代码：contract VehicleOwner {</strong></p> 
  <p>分析：声明车主合约。</p> 
  <p>4.代码：</p> 
  <pre><code>address public owner;
mapping(bytes32 =&gt; address) public vehicles;
</code></pre> 
  <p>分析：这是我们充实合约的地方。第一个变量调用所有者<code>owner</code>并表示创建<code>VehicleOwner</code>合约的任何给定实例的以太坊。</p> 
  <p>第二个称为<code>vehicles</code>车辆，将用于存储车主拥有的车辆清单，通过将其合约地址分配给提供的车辆识别号码。</p> 
  <p>5.代码：</p> 
  <pre><code>function VehicleOwner() public {
owner = msg.sender;
}
</code></pre> 
  <p>分析：看看该函数与合约的名称是什么？这是因为这个特定的函数是一个构造函数。它唯一的功能是将调用该函数的地址指定为合约所有者。</p> 
  <p>6.代码：</p> 
  <pre><code>modifier onlyOwner() {
require(msg.sender == owner);
_;
}
</code></pre> 
  <p>分析：使用此函数修饰符确保只有合约所有者才能访问合约。</p> 
  <p>看到<code>_</code>？这产生了稍后应用修改器<code>modifier</code>的函数体。</p> 
  <p>7.代码：</p> 
  <pre><code>function createNewVehicle(string model, string make, bytes32 vin) public onlyOwner {
address newVehicle = new Vehicle(model, make, vin);
vehicles[vin] = newVehicle;
NewVehicleAdded(newVehicle, now);
}
</code></pre> 
  <p>分析：这在区块链上创建了一个新合约，这是一种新车辆的代表。车辆合约的构造函数接收三个属性：model，make和vin，后者可用于识别特定车辆。</p> 
  <p>创建新合约将返回其新分配的地址。在函数中，使用车辆的映射，我们将给定的vin绑定到该地址。最后，该函数广播一个新事件，传入地址和当前时间戳。</p> 
  <h4><a id="2_199"></a>代码示例2</h4> 
  <pre><code>contract BasicIterator
{
address creator; // reserve one "address"-type spot
uint8[10] integers; // reserve a chunk of storage for 10 8-bit unsigned integers in an array

function BasicIterator()
{
creator = msg.sender;
uint8 x = 0;
//Section 1: Assigning values
while(x &lt; integers.length) {
integers[x] = x;  
x++;
} }

function getSum() constant returns (uint) {
uint8 sum = 0;
uint8 x = 0;
//Section 2: Adding the integers in an array.

while(x &lt; integers.length) {
sum = sum + integers[x];
x++;
}

return sum;
}

// Section 3: Killing the contract
function kill()
{
if (msg.sender == creator)
{
suicide(creator);
}
}

}

</code></pre> 
  <p>那么，让我们来分析吧。</p> 
  <p><strong>第1节：赋值</strong></p> 
  <p>在第一步中，我们赋值一个名为“integers”的数组，该数组接收10个8位无符号整数。我们这样做的方式是通过while循环。让我们来看看while循环中发生了什么。</p> 
  <pre><code>while(x &lt; integers.length) {
integers[x] = x;
x++;
}
</code></pre> 
  <p>请记住，我们已经为整数x赋值“0”。while循环从0变为integers.length。Integers.length是一个返回数组最大容量的函数。因此，如果我们确定一个数组将有10个整数，arrayname.length将返回一个值10。在上面的循环中，x的值从0到9（&lt;10）并将其自身的值赋给整数数组也是如此。因此，在循环结束时，“integers”将具有以下值：</p> 
  <pre><code>0,1,2,3,4,5,6,7,8,9。
</code></pre> 
  <p><strong>第2节：添加数组内容</strong></p> 
  <p>在<code>getSum()</code>函数内部，我们将添加数组本身的内容。它的方式是通过重复上面相同的while循环并使用变量“sum”来添加数组的内容。</p> 
  <p><strong>第3节：终止合约</strong></p> 
  <p>此功能终止合约并将合约中的剩余资金发回给合约创建者。</p> 
  <p>因此，这应该可以让你更好地了解<code>solidity</code>合约看起来是什么样子的以及你应该从那里获得什么样的代码细分类型。</p> 
  <h3><a id="gas_272"></a>以太和gas有什么区别？</h3> 
  <p>这是你的开发人员应该熟悉的另一个核心概念。</p> 
  <p>以太是生态系统中的主要标记。这是激励玩家完成智能合约的动力。</p> 
  <p>gas是满足特定合约所需的燃料量。</p> 
  <p>当有人提交智能合约时，它具有预先确定的gas价值。合约执行时，合约的每一步都需要一定量的气体来执行。</p> 
  <p>这可能导致两种情况：</p> 
  <ul> 
   <li>所需的gas超过设定的极限。如果是这种情况，则合约状态将恢复到原始状态，并且所有气体都用完了。</li> 
   <li>所需gas小于设定的极限。如果是这种情况，那么合约就完成了，剩余的gas将交给合约制定者。</li> 
  </ul> 
  <p>以下是显示Wei的平均gas价格的图表。</p> 
  <p><img src="http://blog.hubwiz.com/2018/10/11/ethereum-Developer-hire/image2.png" alt=""></p> 
  <p>gas是以太坊的生命线。</p> 
  <p>以太坊的所有交易均由矿工验证。基本上，他们必须手动将每个交易放入他们为了验证交易而挖掘的块中。为了换取他们的服务，他们收取了一定的交易费用。</p> 
  <p>通常，优先考虑高gas费的智能合约，因为矿工有机会在那里收取更高的费用。与比特币相比，收取的费用只是象征性的。</p> 
  <p>此图表比较了比特币与以太坊的交易费用。</p> 
  <p><img src="http://blog.hubwiz.com/2018/10/11/ethereum-Developer-hire/image5.png" alt=""></p> 
  <p>实际上，正如你所看到的，在0.01以太的此次交易中，仅收取0.00000000000002以太的gas作为交易费用&lt;$0.000001。</p> 
  <p><img src="http://blog.hubwiz.com/2018/10/11/ethereum-Developer-hire/image4.png" alt=""></p> 
  <p>所以，正如你所看到的，以太坊的矿工只收取非常象征性的交易费用。显然收取交易费是矿工的次要角色，他们的主要工作是…好吧…挖矿！</p> 
  <h3><a id="_307"></a>问题与解答</h3> 
  <p>提炼所有这些知识，让我们对你可以提出的一些具体问题。</p> 
  <p>1.问题：合约构造函数是如何定义的？<br> 解答：构造函数被定义为一个函数，其名称与合约完全相同。</p> 
  <p>2.问题：在以太坊中记录的事件在哪里？它们的目的是什么？<br> 解答：日志是合约发出的事件。这些是其交易收据的一部分以及在以太坊虚拟机（EVM）上执行的<code>LOG opcodes</code>操作码的结果。这些事件主要用于与前端通信或作为廉价的数据存储。因为交易的返回值只是交易的hash，区块链需要一些时间来达成共识并验证交易，通过将它们挖掘到新块中。通过发出事件并使前端收听（观察）这些事件，实现了有效的通信。</p> 
  <p>3.问题：mappings映射是什么？<br> 解答：映射等同于其他编程语言中的字典或映射。它就是键值存储。</p> 
  <p>4.问题：修饰语purpose of modifiers的目的是什么？<br> 解答：顾名思义，他们修改使用它们的功能。但是，在执行函数之前必须满足修饰符的条件。如果不是，那么修饰符会抛出错误。</p> 
  <p>5.问题：以太坊库libraries是什么？<br> 解答：以太坊库有助于隔离整体逻辑。它们是一组使用以太坊虚拟机（EVM）在区块链上使用的软件包。所有库都可以在智能合约中部署和链接。它们可以通过<code>DELEGATECALL</code>调用。</p> 
  <p>6.问题：为什么在智能合约上调用方法需要花钱？<br> 解答：当调用方法时，它们会改变区块链的状态。由于操作需要gas，因此需要花钱。</p> 
  <h3><a id="_330"></a>哪里可以找到优秀的开发人员？</h3> 
  <p>在像LinkedIn和谷歌这样的“传统地方”很难找到优秀的开发者。但是，Reddit，GitHub等是寻找这些开发人员的好地方。</p> 
  <p>另外，还有一件事。由于这是一个利基人才市场，你应该对他们可能在你的城市甚至你自己的国家的事实持开放态度。应该为远程工作做好准备，特别是如果你正在寻找优秀开发者。</p> 
  <p>这可能是一种痛苦，但这是“质量超过数量”的必须面对的情况之一。</p> 
  <h3><a id="_338"></a>结论</h3> 
  <p>当你面试以太坊开发人员时，你必须记住一件事。他们没有必要彻底回答所有问题。重要的是他们的热情以及他们是否能够专门回答与他们的工作和角色有关的问题。</p> 
  <p>无论如何，本指南应该帮助你了解特别的区块链开发人员。最后一句忠告，请不要和开发人员的质量妥协。请记住，质量永远胜过数量。</p> 
  <p>======================================================================</p> 
  <p>分享一些以太坊、EOS、比特币等区块链相关的交互式在线编程实战教程：</p> 
  <blockquote> 
   <ul> 
    <li><a href="http://xc.hubwiz.com/course/5b2b6e82c02e6b6a59171de2?affid=1012csdn" rel="nofollow">java以太坊开发教程</a>，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b36629bc02e6b6a59171de3?affid=1012csdn" rel="nofollow">php以太坊</a>，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和交易等内容。</li> 
    <li><a href="http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=1012csdn" rel="nofollow">以太坊入门教程</a>，主要介绍智能合约与dapp应用开发，适合入门。</li> 
    <li><a href="http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6?affid=1012csdn" rel="nofollow">以太坊开发进阶教程</a>，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b40462cc02e6b6a59171de4?affid=1012csdn" rel="nofollow">python以太坊</a>，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b6048c3c02e6b6a59171dee?affid=1012csdn" rel="nofollow">C#以太坊</a>，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和交易等。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b52c0a2c02e6b6a59171ded?affid=1012csdn" rel="nofollow">EOS教程</a>，本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。</li> 
    <li><a href="http://xc.hubwiz.com/course/5bb35c90c02e6b6a59171df0?affid=1012csdn" rel="nofollow">java比特币开发教程</a>，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Java代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Java工程师不可多得的比特币开发学习课程。</li> 
    <li><a href="http://xc.hubwiz.com/course/5b9e779ac02e6b6a59171def?affid=1012csdn" rel="nofollow">php比特币开发教程</a>，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Php代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Php工程师不可多得的比特币开发学习课程。</li> 
   </ul> 
  </blockquote> 
  <p>汇智网原创翻译，转载请标明出处。这里是<a href="http://blog.hubwiz.com/2018/10/11/ethereum-Developer-hire/" rel="nofollow">原文</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/83021636,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/mongo_node/article/details/83021636,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
