<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Fabric的账号体系 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Fabric的账号体系" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：忠于祖国，忠于人民 https://blog.csdn.net/boss2967/article/details/83037332 1.1 Fabric账号简介 Fabric 的账号体系是 Fabric 的重要的组成部分，由于 Fabric 是基于证书而不是传统的户名名和密码形式，所以会有所不同。 在任何非开放系统中都需要通过账号和密码对系统人口进行相关的管理。联盟链的特点是用户非授权时不能接入区块链，所以Fabric系统中存在一套授权体系，称为Fabric的账号体系。 Fabric账号是什么 Fabric 中的账号实际上是根据 PKI 规范生成的一组证书和秘钥文件 。 cryptogen 模块生成的文件中就包含Fabric 账号相关的证书文件，我们通常接触到的账号体系一般是由账号和密码两个属性组成，一旦账号和密码验证成功，后面操作基本和账号，密码没有关系了。但是区块链系统的一个非常重要的特点是：记录在区块链中的数据具有不可逆，不可篡改的特性。Fabric 中每条交易都会加上发起者的标签（签名证书），同时用发起人的私钥进行加密。如果交易需要其他组织的节点提供背书功能，那么背书节点也会在交易中加入自己的签名。这样每一笔交易的操作过程会非常清晰并且不可篡改。 鉴于传统系统中基于账号和密码的验证体系已经无法完成这样的工作，因此 Fabric 设计了基于 PKI 规范的账号系统满足这样的要求。 一个完整的Fabric账号的结构 msp - admincerts - cacerts - keystore - signcerts - tlscacerts tls - ca.crt - server.crt - server.key 这些文件分别存放在msp文件夹和tls文件夹中。 msp文件夹内容 msp中主要存放签名用的证书文件和加密用的私钥文件。一共五部分。 df admincerts:管理员证书 cacerts:根CA服务器的证书 keystore：节点或者账号的私钥 singcerts:符合x.509的节点或者用户证书文件 tlscacerts:TLS根CA的证书 tls文件夹中的内容 tls 文件夹中存放加密通信相关的证书文件。 注：账号的说法是本书对 Fabric 中账号的特定称谓 Fab ic 的官方文档把这些证书称为 Membership Service Providers ，简称为MSP ，我们无法找到更加准确的翻译，所以本书暂且用账号这个比较传统的名词来指代 Fa ric 生成的这些证书，从实际的运行效果看，这些证书文件等同于账号的作用。 本文中账号就是 MSP Fabric账号哪些地方需要用到 启动Orderer的账号 启动Peer的账号 创建Channe的账号 Peer和Orderer是有属于自己的账号，创建Channel使用的是用户账号。其中Peer和常见Channel的用户账号属于有个组织，而Orderer的启动账号只属于他自己。 1.2 基于cryptogen的账户管理体系 cryptogen模块是创建Fabric账号的方式之一。前面了解到cryptogen可以通过配置文件生成Fabric运行所需要的相关账号文件，在配置文件中可以指定每个组织包含的用户数和节点数。然后cryptogen模块会根据配置文件的定义生成相关数据的配置文件。如果系统发生变化，需要引入新的组织，或者组织中需要增加新的账号和用户，这他妈该怎么办？是不是很懵逼，我也没办法… cryptogen模块通过一个配合可以部分解决这个问题。 通过 cryptogen 模块 子命令 owtemplate 显示默认的模板。 Orderer rOrgs: Name: Orderer Domain:example.com Specs: Hosename:orderer PeerOrgs: Name:Org1 Domain:org1.example.com Template: Count:1 Users: Count:1 Name:Org2 Domain:org2.example.com Template: Count:1 Users: Count:1 在配置文件中PerrOrgs节点Template子节点中有个属Count,Count表示当前组织包含Peer节点的数目，同时也会成生成相应数目的配置文件。例子中给出的组织Org1设置的Peer节点数为4，cryptogen模块根据配置文件会给组织Org1生成4个Peer节点所有需要的账号。 进入组织Org1的账号文件夹中， 执行tree -L2 命令内容显示如下： ca aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk ca.orgl . qklszzn . com-cert . pem msp admincerts cacerts tlscacerts peers peer0. org1 . qklszzn com peer1. org1 . qklszzn com peer2. org1 . qklszzn com peer3. org1 . qklszzn com tlsca f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk tlsca orgl qklszzn . com cert . pem users Admin@org1.qklszzn.com User1@org1.qklszzn.com User2@org1.qklszzn.com User3@org1.qklszzn.com User4@org1.qklszzn.com User5@org1.qklszzn.com User6@org2.qklszzn.com 观察上面内容，共生成4个Peer节点账号文件，这些文件夹的命名是由规则的，peer+索引为前缀+域名。所以前缀的值为0 到 Count-1.这里有一个start属性，这就是我们要找的这孙子，费了好大劲。start属性就是继续添加Peer节点使用的，Start用来表示生成Peer节点账号文件的文件夹命名的前缀，默认是0.如果需要增加新的节点，可以给Start属性赋值上一次的count。 这里以上面例子为例。如果需要给组织Org1新增3个Peer节点，可以使用下面配置： PeerOrgs: Name:Org1 Domain:org1.qklszzn.com Template: Count:3 Start:4 通过上面的配置文件， cryptogen 模块可以给组织Org1新增三个Peer节点的配置文件，我们重新回到组织Org1的账号文件目录中，再次执行 tree-L2,显示如下： ca aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk ca.orgl . qklszzn . com-cert . pem msp admincerts cacerts tlscacerts peers peer0. org1 . qklszzn com peer1. org1 . qklszzn com peer2. org1 . qklszzn com peer3. org1 . qklszzn com peer4. org1 . qklszzn com peer5. org1 . qklszzn com peer6. org1 . qklszzn com tlsca f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk tlsca orgl qklszzn . com cert . pem users Admin@org1.qklszzn.com User1@org1.qklszzn.com User2@org1.qklszzn.com User3@org1.qklszzn.com User4@org1.qklszzn.com User5@org1.qklszzn.com User6@org2.qklszzn.com 成功添加了三个Peer节点的配置文件。 那么问题来了，如果动态添加用户账号该怎么办？目前最新的Fabric版本中并没有提供相关的功能。 有没有简单点的解决Fabric账号问题，就是 Fabric-ca 账号服务器。 1.3 Fabric账号服务器： Fabric-ca Fabric-ca项目有 Fabric-ca-server 和Fabric-ca-client 两个模块组成。 Fabric-ca的编译和安装 Fabric-ca是Golang开发的应用程序。下面将演示在Fabric-ca Ubuntu 中安装。 安装系统组件包 sudo apt install btool 1 ibltdl dev 下载源代码并编译 cd $GOPATH/src/github.com/hyperledger git clone http://gerrit.hyperledger.org/r/fabric-ca cd $GPPATH/src/github.com/hyperledger/fabric-ca make fabric-ca-server make fabric-ca-client 安装编译好的可执行文件。 cd $GOPATH/src/github.com/hyperledger/fabric-ca/bin cp $GOPATH/src/github.com/hyperledger/fabric-ca/bin/* /user/local/bin chmod -R 775 /user/local/bin/fabric-ca-server chmod -R 775 /user/local/bin/fabric-ca-client 检查 fabric-ca-server version fabric-ca-client version fabric-ca-server 的启动和配置 fabric-ca-server 启动之后欧是以守护进程方式存在，可以通过fabric-ca-client 或者实现其通信协议的客户端发起请求。fabric-ca-server 有三种方式设置配置信息。 启动参数 环境变量 配置文件 fabric-ca-server 的命令行选项 init:初始化fabric-ca 服务器 start:启动fabric-ca服务器 version:显示版本 fabric-ca-serve的选项 –address:Fabric 服务器的监听地址（默认为“0.0.0. 。”） -b,–boot:系统启动对应的管理员账号和密码 –ca.certfile:CA证书文件（默认为“ca-cert.pen”） –ca.chainfile：CA链证书文件（默认为“ ca-chain.pem”） –ca.keyfile:CA秘钥文件（默认为“ca-key.pem”） -n,–ca.name:证书颁发机构名称 –cacount:CA实例的数量 –cafiles:以逗号分隔的CA配置文件的列表 –crl.expiry:CRL请求到期时间（默认为24h） –crlsizelimit:可接受的CRL的大小限制，以字节为单位（默认为521000） –csr.cn:请求父Fabric-ca服务器的证书签名时使用的公用名称 –csr.hosts:逗号分隔的父类Fabric-ca服务器的主机名，支持多个 –csr.serialnumber:请求父类Fabric-ca服务器的序列号 –db.datasource:数据库的名称（默认为“fabric-ca-server.db”）,仅仅针对–db.type选项为sqlite3有效 –db.tls.certfiles：和数据库TLS通信时用的证书文件，PEM格式 –db.tls.client.certfile:和数据库TLS通信时用的证书文件，PEM格式 –db.tls.client.keyfile:和数据库进行TLS通信时客户端的私钥文件，PEM格式 –db.type:存储账号类型的数据库的类型，目前支持三种数据库类型，sqlite3,postgres,mysql –d,–debug:启动调试级别日志记录。 -H，–home:Fabric-ca服务器的主目录（默认为当前目录） -intermediate.enrollment.label: 操作中使用的标签 -intermediat e.enrollment.profile:发型证书时要使用的签名配置文件的名称 –intermediate. parentserver. caname: 服务器CA名称 -u,–intermediate.parentserver. url：父Fabric-ca服务器的URL –ldap.enabled: 启动LDAP服务进行客户端身份验证和相关属性的管理 –ldap.groupfilter：LDAP 进行组过滤模式，默认值为（ memberUid=%s ) –ldap tls.certfiles:LDAP 服务器的证书文件， PEM 格式（例如root1.pem,root2.pem) –ldap.tls.client.certfile:LDAP 服务客户端的证书文件，PEM格式。 –ldap.tls.client.keyfile:LDAP 服务客户端私钥文件，PEM格式。 –ldap.url:LDAP服务的URL –ldap.userfilter:LDAP服务器的用户过滤器，默认为（uid=%s） -p,–port :Fabric-ca 服务器监听端口（默认为7054） – registry.maxenrollments:最大允许注册的用户数：如果LDAP未启动时有效(默认为-1) –tls.certfile:Fabric-ca 服务器的证书，PEM格式（默认‘tls-cert.pem’） –tls.clientauth.certfiles：Fabric-ca服务器的客户端证书 –tls.clientauth.type:客户端类型（noclientcert） –tls.enabled:在监听端口上启动TLS fabric-ca-server的初始化 fabric-ca-server 还可以通过配置文件进行参数设置。 执行fabric-ca-server的命令init,可以初始化成相关的配置文件。（执行之前先创建相关的文件夹） mkdir -p /opt/hyperledger/fabric-ca-server fabric-ca-server 服务器初始化的命令如下: fabric-ca-server init -b admin:adminpw -b 参数后面的是 fabric-ca-server 服务器管理账号的用 户名和 密码，这里给出的是个例子，而且很多资料都给出了这个例子，但是如果在生产系统中建议务必使用比较复杂的密码，而避免使用本例中的用户名和密码，避免恶意猜测用户名密码的行为。 初始化命令执行完后会在当前的目录下面生成相应的配置文件。 fabric-ca-server-config.yaml :配置文件 fabric-ca-server.db :数据库文件（数据库选择sqlite3时有效） ca-cert.pem:证书文件 msp:私钥文件夹 fabric-ca-server 的配置文件 fabric-ca-server 配置文件的内容可以参考上 步生成的文件 fabric-ca -server-config.yaml. fabric-ca-server的配置文件一共11部分。 通用配置 通用配置部分包含了系统 些公用属性。 port:7054 //监听端口号 debug:false //是否调试 crlsizelimit:512000 cacount: //支持的CA数目 cafiles: //相关CA配置文件 crl: // expiry:24h //授权证书的有效期 tls tls 部分主要包含了 TLS 通信相关的配置，包括是否需要打开 TLS 通信，TLS 通信的证书和私钥等文件的路径等。 tls: enabled:false //是否启用TLS certfile: tls-cert.pem //TLS证书文件 keyfile: //TLS私钥文件 clientauth: // type:noclientcert //客户端类型 certfiles: //客户端证书类型 ca ca 服务器属性的配置，包含发布证书的组织机构的名称和相关的证书文件路径 。 ca: name: //CA 的名字，如果存在多个 CA 服务器，不能重复 keyfile: ca-key.pen //／私钥文件 certfile:ca-cert.pem //／证书文件 chainfile:ca-chain.pen //／证书链文件 registry registry节点包含了客户端注册相关的信息。 registry: maxenrollments:-1 identities: //注册实体信息，可以有多个 name:adminpw type:client affiliation:&quot;&quot; maxenrollments:-1 attrs: hf.Registrar.Roles:“client,user,peer,validator,auditor” hf.Registrar.DelegateRoles:“client,user,validator,auditor” hf.Revoker:true hf.IntermediateCA:true hf.GenCRL:true hf.Registrar.Attributes:&quot;*&quot; db db 部分包含了 Fabric-ca服务器存储账号文件的数据类型的配置。 db: type:sqlite3 datasource:fabric-ca-server.db tls: enabled:false certfiles: db-server-cert.pem client: certfile:db-client-cert.pem keyfile:db-client-key.pem ldap Fabric-ca 可以配置使用远端 DAP 务器来进行注册管理并且保存注册相关的数据， LDAP服务相关的配置信息包含在 ldap 节点中。 ldap: ldap: enabled:true url: ldap://cn://cn=admin,dc=example,dc=org:admin@localhost:10389 /dc=example,dc=org userfilter:(uid=%s) tls: certfiles: ldap-server-cert.pem client: certfile:ldap-client-cert.pem keyfile:ldap-client-key.pem affiliations ffiliations 节点包含了组织中的部门的相关配置信息，这些配置信息在客户端 SDK用时相关的参数必须保持一致。 affiliations : org1: department1 department2 org2: department1 signing 节点 signing 节点包含了证书签发相关的配置，包括证书的到期时间等属性。 signing: default: //默认的签发ecert usage: //证书签发的作用域 digital signature expiry:8760h //证书有效时间 profiles: ca: usage: cert sign expiry:43800h caconstraint: isca:true maxpathlen:0 //现在中间层继续下发节点 tls： usage: signing key encipherment server auth client auth key agreement expiry:8760h csrd csr 节点包含了证书申请请求时需要使用的配置信息。 csr： cn:fabric-ca-server //服务器名称 names: //证书签发单位的基本信息 C:US ST:“North Carolina” L: O:Hyperledger OU:Fabric hosts: robertfeng-All-Series localhost ca: expiry:131400h //证书有效时间 pathlength:1 //下一级服务器是否可以继续其下级服务签发证书， -1为不可。取值大于0时为允许层数 10 . bccsp bsssp节点包含了加密算法相关的配置，在bccsp节点中可以选择相关的加密算法以及相关加密算法的证书文件。 bccsp： default:SW //加密方式，硬件加密和程序加密 sw: hash: SHA2 security:256 filekeystore: keystore:msp/keystore intermediate 当前 CA 作为中间 时相关的配置。 intermediate: parentserver: //上级CA服务器相关信息 url: caname: enrollment: //需要在上级CA服务器进行登记的信息 hosts: //上级CA服务器地址列表，用逗号分隔 profile: //签发用的profile label: //用于HSM操作的标签信息 tls: //TLS通信相关的属性信息 certfiles: //根证书文件 client: //如果启动客户端文件需要的使用到的部分 certfile: //客户端证书文件 keyfile: //客户端私钥文件 fabric-ca-server的启动 配置文件设置好之后就可以启动 fabric-ca-server服务器了。启动命令如下： fabric-ca-server start -H /opt/hyperledger/fabric-ca --boot admin:adminpw 启动完成后可以通过客户端程序或者通过fabric-ca-client模块访问 fabric-ca-server 服务器。 fabric-ca-client的使用 fabric-ca-server 提供了一组RESTAPI接口供第三方应用程序调用。fabric-ca-client对这些接口进行了封装，只需要设计简单的参数便可完成账号注册，账号授权等操作。fabric-ca-client模块由一组子命令和相关的参数选项组成。 fabric-ca-client模块的子命令 fabric-ca-client模块通过相关自命令完成账号注册，授权申请，证书撤销等操作 enroll:登记账号 gencrl:撤销证书 gencsr:创建证书签名 getcacert:获取CA链证书 reenroll:重新登记账号 register:注册一个新账号 revoke:撤销一个账号 version:显示版本信息 fabric-ca-client模块的参数选项 基本管理 –caname:CA服务器名称 -H,–home:客户端的目录，用来存放客户端相关的文件 -M,–mspdir:客户端的账号证书文件的目录 -d,–debug:将客户端的日志设计为debug模式 -u,–url:fabric-ca-server的地址 账号登记 -enrollment.attrs:账号登记请求中的属性 –enrollment.label:登记请求中的HSM相关的标签 –enrollment.profile:登记请求中的profile 账号注册 –id.affiliation:账号注册时组织的部门信息 –id.attrs:账号注册时的属性列表 –id.maxenrollments:当前注册后可以进行登记的次数 –id.name:账号注册时的用户名 –id.secret:账号注册的密码 –id.type 账号注册的类型 默认为user 证书吊销 -a,–revoke.aki:注销证书时需要的公钥 -e,–revoke.name:注销证书时的实体名称 -r,–revoke.reasion:注销的原因 -s,–revoke.serial:注销证书的序列号 CA证签名 –csr.cn:CA签名请求时，请求报文中的通用名 –csr.hosts::CA签名请求时,请求报文中的主机名 –csr.serialnumber::CA签名请求时,请求报文中的序列号 –csr.names::CA签名请求时，请求报文中的附件名称 -m,–myhost::CA签名请求时,请求报文中请求主机名称，默认值是本地主机 TLS通信 –tls.certfiles:TLS通信模式下的证书文件，PEM文件格式 –tls.client.certfile: TLS通信模式下客户端的证书文件，PEM文件格式 –tls.client.keyfile:TLS通信模式下客户端的私钥文件 1.4 将fabric-ca-server绑定到现有的项目中 Fabric-ca是Fabric的cryptogen模块有力补充，在项目中占有非常重要的作用。 绑定 fabric-ca-server 到现有组织 打开 fabric-ca-server的配置文件 fabric-ca-server-config.yaml.在配置文件找到以下内容： ca: name:ca-org1 keyfile: certfile: chainfile:ca-chain.pem 进入证书文件夹，，进入存放组织Org相关的证书的文件夹。执行命令tree -L2: ca aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk ca.orgl . qklszzn . com-cert . pem msp admincerts cacerts tlscacerts peers peer0. org1 . qklszzn com peer1. org1 . qklszzn com peer2. org1 . qklszzn com peer3. org1 . qklszzn com peer4. org1 . qklszzn com peer5. org1 . qklszzn com peer6. org1 . qklszzn com tlsca f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk tlsca orgl qklszzn . com cert . pem users Admin@org1.qklszzn.com User1@org1.qklszzn.com User2@org1.qklszzn.com User3@org1.qklszzn.com User4@org1.qklszzn.com User5@org1.qklszzn.com User6@org2.qklszzn.com 在ca文件夹中存放了将fabric-ca-server绑定到组织org1的相关文件。 现在可以绑定这些文件，绑定。 keyfile:对应ca文件夹中文件名后缀为-sk的文件 certfile:对应ca文件夹中文件名为ca.org1.qklszzn.com-cert.pem的文件 上述步骤 fabric-ca-server 就被绑定到组织 orgl 中了。 通过客户端从已经绑定的fabric-ca-server中生成账号 设置 fabric-ca-client环境变量 创建目录： mkdir -p /opt/hyperledger/fabric-client 目录常见完成之后，利用管理员账号和密码注册，获取管理员账号msp的证书文件。 export FABRIC_CA_CLIENT_HOME =/opt/hyperledger/fabric-client fabric-ca-client enroll -uhttp://admin:adminpw@localhost:7054 - M /opt/hyperledger/fabric_client 注册账号 名为usertest,密码为user2wd 注册命令如下： fabric-ca-client register --id.name usertest --id.type user --id.affiliation org1.deparment1 --id.secret user2wd -u http://localhost:7054 载入账号 将上一步注册的账号usertest加载到本地，首先需要再本地创建给目录用来存放从服务器下载的证书，目录可以是任何目录。 mkdir -p /opt/hyperledger/qklszznuser 在上面创建的目录中，登录账号usertest，并且登录成功的账号的相关文件会保存到制定目录中。 登记账号的命令如下： fabric-ca-client enroll -u http://usertest：user2wd@localhost:7054 -M /opt/hyperledger/qklszznuser/msp 复制管理员签名和公用TLS证书文件 复制管理账号的签名的命令： mkdir /opt/hyperledger/qklszznuser/msp/admincerts cp/opt/hyperledger_commconfig/fabricconfig/cryptoconfig/perrorganizations/org1.qklszzn.com/users/Admin@qklszzn.com/msp/signcerts/* /opt hyperledger/qklszznuser/msp/admincerts 复制公用TLS签名证书的命令如下： mkdir /opt/hyperledger/qklszznuser/tls cp /opt/hyperledger_commconfig/fabricconfig/cryptoconfig/peerOrganizations/org1.qklszzn.com/peers/peer0.org1.qklszzn.com/tls/* /opt/hyperledger/qklszznuser/tls 查看账号 进入文件夹通过tree命令查看证书文件的命令。如下所示： msp admincerts Admin@org1.qklszzn.com-cert.pem cacerts 192-168-23-212-7054.pem keystore 5f470b06e7b34517elf5bc6bl05e2c9ec4a47759378997e826de6f305c075b47_sk signcerts cert . pem tlscacerts tls-192-168-23-212-7054.pem tls ca . crt server . crt server . key fabric-ca-server 客户端访问接口 在Fabric项目中更多的应用场景通过fabric-ca-server提供的RESTAPI接口完成账号注册，账号登记等操作。 1.5 总结 介绍了Fabric是 如何通过账号来进行权限控制的。灵活运用账号功能是开发基础Fabric技术框架项目的先决条件。 阅读更多" />
<meta property="og:description" content="版权声明：忠于祖国，忠于人民 https://blog.csdn.net/boss2967/article/details/83037332 1.1 Fabric账号简介 Fabric 的账号体系是 Fabric 的重要的组成部分，由于 Fabric 是基于证书而不是传统的户名名和密码形式，所以会有所不同。 在任何非开放系统中都需要通过账号和密码对系统人口进行相关的管理。联盟链的特点是用户非授权时不能接入区块链，所以Fabric系统中存在一套授权体系，称为Fabric的账号体系。 Fabric账号是什么 Fabric 中的账号实际上是根据 PKI 规范生成的一组证书和秘钥文件 。 cryptogen 模块生成的文件中就包含Fabric 账号相关的证书文件，我们通常接触到的账号体系一般是由账号和密码两个属性组成，一旦账号和密码验证成功，后面操作基本和账号，密码没有关系了。但是区块链系统的一个非常重要的特点是：记录在区块链中的数据具有不可逆，不可篡改的特性。Fabric 中每条交易都会加上发起者的标签（签名证书），同时用发起人的私钥进行加密。如果交易需要其他组织的节点提供背书功能，那么背书节点也会在交易中加入自己的签名。这样每一笔交易的操作过程会非常清晰并且不可篡改。 鉴于传统系统中基于账号和密码的验证体系已经无法完成这样的工作，因此 Fabric 设计了基于 PKI 规范的账号系统满足这样的要求。 一个完整的Fabric账号的结构 msp - admincerts - cacerts - keystore - signcerts - tlscacerts tls - ca.crt - server.crt - server.key 这些文件分别存放在msp文件夹和tls文件夹中。 msp文件夹内容 msp中主要存放签名用的证书文件和加密用的私钥文件。一共五部分。 df admincerts:管理员证书 cacerts:根CA服务器的证书 keystore：节点或者账号的私钥 singcerts:符合x.509的节点或者用户证书文件 tlscacerts:TLS根CA的证书 tls文件夹中的内容 tls 文件夹中存放加密通信相关的证书文件。 注：账号的说法是本书对 Fabric 中账号的特定称谓 Fab ic 的官方文档把这些证书称为 Membership Service Providers ，简称为MSP ，我们无法找到更加准确的翻译，所以本书暂且用账号这个比较传统的名词来指代 Fa ric 生成的这些证书，从实际的运行效果看，这些证书文件等同于账号的作用。 本文中账号就是 MSP Fabric账号哪些地方需要用到 启动Orderer的账号 启动Peer的账号 创建Channe的账号 Peer和Orderer是有属于自己的账号，创建Channel使用的是用户账号。其中Peer和常见Channel的用户账号属于有个组织，而Orderer的启动账号只属于他自己。 1.2 基于cryptogen的账户管理体系 cryptogen模块是创建Fabric账号的方式之一。前面了解到cryptogen可以通过配置文件生成Fabric运行所需要的相关账号文件，在配置文件中可以指定每个组织包含的用户数和节点数。然后cryptogen模块会根据配置文件的定义生成相关数据的配置文件。如果系统发生变化，需要引入新的组织，或者组织中需要增加新的账号和用户，这他妈该怎么办？是不是很懵逼，我也没办法… cryptogen模块通过一个配合可以部分解决这个问题。 通过 cryptogen 模块 子命令 owtemplate 显示默认的模板。 Orderer rOrgs: Name: Orderer Domain:example.com Specs: Hosename:orderer PeerOrgs: Name:Org1 Domain:org1.example.com Template: Count:1 Users: Count:1 Name:Org2 Domain:org2.example.com Template: Count:1 Users: Count:1 在配置文件中PerrOrgs节点Template子节点中有个属Count,Count表示当前组织包含Peer节点的数目，同时也会成生成相应数目的配置文件。例子中给出的组织Org1设置的Peer节点数为4，cryptogen模块根据配置文件会给组织Org1生成4个Peer节点所有需要的账号。 进入组织Org1的账号文件夹中， 执行tree -L2 命令内容显示如下： ca aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk ca.orgl . qklszzn . com-cert . pem msp admincerts cacerts tlscacerts peers peer0. org1 . qklszzn com peer1. org1 . qklszzn com peer2. org1 . qklszzn com peer3. org1 . qklszzn com tlsca f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk tlsca orgl qklszzn . com cert . pem users Admin@org1.qklszzn.com User1@org1.qklszzn.com User2@org1.qklszzn.com User3@org1.qklszzn.com User4@org1.qklszzn.com User5@org1.qklszzn.com User6@org2.qklszzn.com 观察上面内容，共生成4个Peer节点账号文件，这些文件夹的命名是由规则的，peer+索引为前缀+域名。所以前缀的值为0 到 Count-1.这里有一个start属性，这就是我们要找的这孙子，费了好大劲。start属性就是继续添加Peer节点使用的，Start用来表示生成Peer节点账号文件的文件夹命名的前缀，默认是0.如果需要增加新的节点，可以给Start属性赋值上一次的count。 这里以上面例子为例。如果需要给组织Org1新增3个Peer节点，可以使用下面配置： PeerOrgs: Name:Org1 Domain:org1.qklszzn.com Template: Count:3 Start:4 通过上面的配置文件， cryptogen 模块可以给组织Org1新增三个Peer节点的配置文件，我们重新回到组织Org1的账号文件目录中，再次执行 tree-L2,显示如下： ca aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk ca.orgl . qklszzn . com-cert . pem msp admincerts cacerts tlscacerts peers peer0. org1 . qklszzn com peer1. org1 . qklszzn com peer2. org1 . qklszzn com peer3. org1 . qklszzn com peer4. org1 . qklszzn com peer5. org1 . qklszzn com peer6. org1 . qklszzn com tlsca f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk tlsca orgl qklszzn . com cert . pem users Admin@org1.qklszzn.com User1@org1.qklszzn.com User2@org1.qklszzn.com User3@org1.qklszzn.com User4@org1.qklszzn.com User5@org1.qklszzn.com User6@org2.qklszzn.com 成功添加了三个Peer节点的配置文件。 那么问题来了，如果动态添加用户账号该怎么办？目前最新的Fabric版本中并没有提供相关的功能。 有没有简单点的解决Fabric账号问题，就是 Fabric-ca 账号服务器。 1.3 Fabric账号服务器： Fabric-ca Fabric-ca项目有 Fabric-ca-server 和Fabric-ca-client 两个模块组成。 Fabric-ca的编译和安装 Fabric-ca是Golang开发的应用程序。下面将演示在Fabric-ca Ubuntu 中安装。 安装系统组件包 sudo apt install btool 1 ibltdl dev 下载源代码并编译 cd $GOPATH/src/github.com/hyperledger git clone http://gerrit.hyperledger.org/r/fabric-ca cd $GPPATH/src/github.com/hyperledger/fabric-ca make fabric-ca-server make fabric-ca-client 安装编译好的可执行文件。 cd $GOPATH/src/github.com/hyperledger/fabric-ca/bin cp $GOPATH/src/github.com/hyperledger/fabric-ca/bin/* /user/local/bin chmod -R 775 /user/local/bin/fabric-ca-server chmod -R 775 /user/local/bin/fabric-ca-client 检查 fabric-ca-server version fabric-ca-client version fabric-ca-server 的启动和配置 fabric-ca-server 启动之后欧是以守护进程方式存在，可以通过fabric-ca-client 或者实现其通信协议的客户端发起请求。fabric-ca-server 有三种方式设置配置信息。 启动参数 环境变量 配置文件 fabric-ca-server 的命令行选项 init:初始化fabric-ca 服务器 start:启动fabric-ca服务器 version:显示版本 fabric-ca-serve的选项 –address:Fabric 服务器的监听地址（默认为“0.0.0. 。”） -b,–boot:系统启动对应的管理员账号和密码 –ca.certfile:CA证书文件（默认为“ca-cert.pen”） –ca.chainfile：CA链证书文件（默认为“ ca-chain.pem”） –ca.keyfile:CA秘钥文件（默认为“ca-key.pem”） -n,–ca.name:证书颁发机构名称 –cacount:CA实例的数量 –cafiles:以逗号分隔的CA配置文件的列表 –crl.expiry:CRL请求到期时间（默认为24h） –crlsizelimit:可接受的CRL的大小限制，以字节为单位（默认为521000） –csr.cn:请求父Fabric-ca服务器的证书签名时使用的公用名称 –csr.hosts:逗号分隔的父类Fabric-ca服务器的主机名，支持多个 –csr.serialnumber:请求父类Fabric-ca服务器的序列号 –db.datasource:数据库的名称（默认为“fabric-ca-server.db”）,仅仅针对–db.type选项为sqlite3有效 –db.tls.certfiles：和数据库TLS通信时用的证书文件，PEM格式 –db.tls.client.certfile:和数据库TLS通信时用的证书文件，PEM格式 –db.tls.client.keyfile:和数据库进行TLS通信时客户端的私钥文件，PEM格式 –db.type:存储账号类型的数据库的类型，目前支持三种数据库类型，sqlite3,postgres,mysql –d,–debug:启动调试级别日志记录。 -H，–home:Fabric-ca服务器的主目录（默认为当前目录） -intermediate.enrollment.label: 操作中使用的标签 -intermediat e.enrollment.profile:发型证书时要使用的签名配置文件的名称 –intermediate. parentserver. caname: 服务器CA名称 -u,–intermediate.parentserver. url：父Fabric-ca服务器的URL –ldap.enabled: 启动LDAP服务进行客户端身份验证和相关属性的管理 –ldap.groupfilter：LDAP 进行组过滤模式，默认值为（ memberUid=%s ) –ldap tls.certfiles:LDAP 服务器的证书文件， PEM 格式（例如root1.pem,root2.pem) –ldap.tls.client.certfile:LDAP 服务客户端的证书文件，PEM格式。 –ldap.tls.client.keyfile:LDAP 服务客户端私钥文件，PEM格式。 –ldap.url:LDAP服务的URL –ldap.userfilter:LDAP服务器的用户过滤器，默认为（uid=%s） -p,–port :Fabric-ca 服务器监听端口（默认为7054） – registry.maxenrollments:最大允许注册的用户数：如果LDAP未启动时有效(默认为-1) –tls.certfile:Fabric-ca 服务器的证书，PEM格式（默认‘tls-cert.pem’） –tls.clientauth.certfiles：Fabric-ca服务器的客户端证书 –tls.clientauth.type:客户端类型（noclientcert） –tls.enabled:在监听端口上启动TLS fabric-ca-server的初始化 fabric-ca-server 还可以通过配置文件进行参数设置。 执行fabric-ca-server的命令init,可以初始化成相关的配置文件。（执行之前先创建相关的文件夹） mkdir -p /opt/hyperledger/fabric-ca-server fabric-ca-server 服务器初始化的命令如下: fabric-ca-server init -b admin:adminpw -b 参数后面的是 fabric-ca-server 服务器管理账号的用 户名和 密码，这里给出的是个例子，而且很多资料都给出了这个例子，但是如果在生产系统中建议务必使用比较复杂的密码，而避免使用本例中的用户名和密码，避免恶意猜测用户名密码的行为。 初始化命令执行完后会在当前的目录下面生成相应的配置文件。 fabric-ca-server-config.yaml :配置文件 fabric-ca-server.db :数据库文件（数据库选择sqlite3时有效） ca-cert.pem:证书文件 msp:私钥文件夹 fabric-ca-server 的配置文件 fabric-ca-server 配置文件的内容可以参考上 步生成的文件 fabric-ca -server-config.yaml. fabric-ca-server的配置文件一共11部分。 通用配置 通用配置部分包含了系统 些公用属性。 port:7054 //监听端口号 debug:false //是否调试 crlsizelimit:512000 cacount: //支持的CA数目 cafiles: //相关CA配置文件 crl: // expiry:24h //授权证书的有效期 tls tls 部分主要包含了 TLS 通信相关的配置，包括是否需要打开 TLS 通信，TLS 通信的证书和私钥等文件的路径等。 tls: enabled:false //是否启用TLS certfile: tls-cert.pem //TLS证书文件 keyfile: //TLS私钥文件 clientauth: // type:noclientcert //客户端类型 certfiles: //客户端证书类型 ca ca 服务器属性的配置，包含发布证书的组织机构的名称和相关的证书文件路径 。 ca: name: //CA 的名字，如果存在多个 CA 服务器，不能重复 keyfile: ca-key.pen //／私钥文件 certfile:ca-cert.pem //／证书文件 chainfile:ca-chain.pen //／证书链文件 registry registry节点包含了客户端注册相关的信息。 registry: maxenrollments:-1 identities: //注册实体信息，可以有多个 name:adminpw type:client affiliation:&quot;&quot; maxenrollments:-1 attrs: hf.Registrar.Roles:“client,user,peer,validator,auditor” hf.Registrar.DelegateRoles:“client,user,validator,auditor” hf.Revoker:true hf.IntermediateCA:true hf.GenCRL:true hf.Registrar.Attributes:&quot;*&quot; db db 部分包含了 Fabric-ca服务器存储账号文件的数据类型的配置。 db: type:sqlite3 datasource:fabric-ca-server.db tls: enabled:false certfiles: db-server-cert.pem client: certfile:db-client-cert.pem keyfile:db-client-key.pem ldap Fabric-ca 可以配置使用远端 DAP 务器来进行注册管理并且保存注册相关的数据， LDAP服务相关的配置信息包含在 ldap 节点中。 ldap: ldap: enabled:true url: ldap://cn://cn=admin,dc=example,dc=org:admin@localhost:10389 /dc=example,dc=org userfilter:(uid=%s) tls: certfiles: ldap-server-cert.pem client: certfile:ldap-client-cert.pem keyfile:ldap-client-key.pem affiliations ffiliations 节点包含了组织中的部门的相关配置信息，这些配置信息在客户端 SDK用时相关的参数必须保持一致。 affiliations : org1: department1 department2 org2: department1 signing 节点 signing 节点包含了证书签发相关的配置，包括证书的到期时间等属性。 signing: default: //默认的签发ecert usage: //证书签发的作用域 digital signature expiry:8760h //证书有效时间 profiles: ca: usage: cert sign expiry:43800h caconstraint: isca:true maxpathlen:0 //现在中间层继续下发节点 tls： usage: signing key encipherment server auth client auth key agreement expiry:8760h csrd csr 节点包含了证书申请请求时需要使用的配置信息。 csr： cn:fabric-ca-server //服务器名称 names: //证书签发单位的基本信息 C:US ST:“North Carolina” L: O:Hyperledger OU:Fabric hosts: robertfeng-All-Series localhost ca: expiry:131400h //证书有效时间 pathlength:1 //下一级服务器是否可以继续其下级服务签发证书， -1为不可。取值大于0时为允许层数 10 . bccsp bsssp节点包含了加密算法相关的配置，在bccsp节点中可以选择相关的加密算法以及相关加密算法的证书文件。 bccsp： default:SW //加密方式，硬件加密和程序加密 sw: hash: SHA2 security:256 filekeystore: keystore:msp/keystore intermediate 当前 CA 作为中间 时相关的配置。 intermediate: parentserver: //上级CA服务器相关信息 url: caname: enrollment: //需要在上级CA服务器进行登记的信息 hosts: //上级CA服务器地址列表，用逗号分隔 profile: //签发用的profile label: //用于HSM操作的标签信息 tls: //TLS通信相关的属性信息 certfiles: //根证书文件 client: //如果启动客户端文件需要的使用到的部分 certfile: //客户端证书文件 keyfile: //客户端私钥文件 fabric-ca-server的启动 配置文件设置好之后就可以启动 fabric-ca-server服务器了。启动命令如下： fabric-ca-server start -H /opt/hyperledger/fabric-ca --boot admin:adminpw 启动完成后可以通过客户端程序或者通过fabric-ca-client模块访问 fabric-ca-server 服务器。 fabric-ca-client的使用 fabric-ca-server 提供了一组RESTAPI接口供第三方应用程序调用。fabric-ca-client对这些接口进行了封装，只需要设计简单的参数便可完成账号注册，账号授权等操作。fabric-ca-client模块由一组子命令和相关的参数选项组成。 fabric-ca-client模块的子命令 fabric-ca-client模块通过相关自命令完成账号注册，授权申请，证书撤销等操作 enroll:登记账号 gencrl:撤销证书 gencsr:创建证书签名 getcacert:获取CA链证书 reenroll:重新登记账号 register:注册一个新账号 revoke:撤销一个账号 version:显示版本信息 fabric-ca-client模块的参数选项 基本管理 –caname:CA服务器名称 -H,–home:客户端的目录，用来存放客户端相关的文件 -M,–mspdir:客户端的账号证书文件的目录 -d,–debug:将客户端的日志设计为debug模式 -u,–url:fabric-ca-server的地址 账号登记 -enrollment.attrs:账号登记请求中的属性 –enrollment.label:登记请求中的HSM相关的标签 –enrollment.profile:登记请求中的profile 账号注册 –id.affiliation:账号注册时组织的部门信息 –id.attrs:账号注册时的属性列表 –id.maxenrollments:当前注册后可以进行登记的次数 –id.name:账号注册时的用户名 –id.secret:账号注册的密码 –id.type 账号注册的类型 默认为user 证书吊销 -a,–revoke.aki:注销证书时需要的公钥 -e,–revoke.name:注销证书时的实体名称 -r,–revoke.reasion:注销的原因 -s,–revoke.serial:注销证书的序列号 CA证签名 –csr.cn:CA签名请求时，请求报文中的通用名 –csr.hosts::CA签名请求时,请求报文中的主机名 –csr.serialnumber::CA签名请求时,请求报文中的序列号 –csr.names::CA签名请求时，请求报文中的附件名称 -m,–myhost::CA签名请求时,请求报文中请求主机名称，默认值是本地主机 TLS通信 –tls.certfiles:TLS通信模式下的证书文件，PEM文件格式 –tls.client.certfile: TLS通信模式下客户端的证书文件，PEM文件格式 –tls.client.keyfile:TLS通信模式下客户端的私钥文件 1.4 将fabric-ca-server绑定到现有的项目中 Fabric-ca是Fabric的cryptogen模块有力补充，在项目中占有非常重要的作用。 绑定 fabric-ca-server 到现有组织 打开 fabric-ca-server的配置文件 fabric-ca-server-config.yaml.在配置文件找到以下内容： ca: name:ca-org1 keyfile: certfile: chainfile:ca-chain.pem 进入证书文件夹，，进入存放组织Org相关的证书的文件夹。执行命令tree -L2: ca aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk ca.orgl . qklszzn . com-cert . pem msp admincerts cacerts tlscacerts peers peer0. org1 . qklszzn com peer1. org1 . qklszzn com peer2. org1 . qklszzn com peer3. org1 . qklszzn com peer4. org1 . qklszzn com peer5. org1 . qklszzn com peer6. org1 . qklszzn com tlsca f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk tlsca orgl qklszzn . com cert . pem users Admin@org1.qklszzn.com User1@org1.qklszzn.com User2@org1.qklszzn.com User3@org1.qklszzn.com User4@org1.qklszzn.com User5@org1.qklszzn.com User6@org2.qklszzn.com 在ca文件夹中存放了将fabric-ca-server绑定到组织org1的相关文件。 现在可以绑定这些文件，绑定。 keyfile:对应ca文件夹中文件名后缀为-sk的文件 certfile:对应ca文件夹中文件名为ca.org1.qklszzn.com-cert.pem的文件 上述步骤 fabric-ca-server 就被绑定到组织 orgl 中了。 通过客户端从已经绑定的fabric-ca-server中生成账号 设置 fabric-ca-client环境变量 创建目录： mkdir -p /opt/hyperledger/fabric-client 目录常见完成之后，利用管理员账号和密码注册，获取管理员账号msp的证书文件。 export FABRIC_CA_CLIENT_HOME =/opt/hyperledger/fabric-client fabric-ca-client enroll -uhttp://admin:adminpw@localhost:7054 - M /opt/hyperledger/fabric_client 注册账号 名为usertest,密码为user2wd 注册命令如下： fabric-ca-client register --id.name usertest --id.type user --id.affiliation org1.deparment1 --id.secret user2wd -u http://localhost:7054 载入账号 将上一步注册的账号usertest加载到本地，首先需要再本地创建给目录用来存放从服务器下载的证书，目录可以是任何目录。 mkdir -p /opt/hyperledger/qklszznuser 在上面创建的目录中，登录账号usertest，并且登录成功的账号的相关文件会保存到制定目录中。 登记账号的命令如下： fabric-ca-client enroll -u http://usertest：user2wd@localhost:7054 -M /opt/hyperledger/qklszznuser/msp 复制管理员签名和公用TLS证书文件 复制管理账号的签名的命令： mkdir /opt/hyperledger/qklszznuser/msp/admincerts cp/opt/hyperledger_commconfig/fabricconfig/cryptoconfig/perrorganizations/org1.qklszzn.com/users/Admin@qklszzn.com/msp/signcerts/* /opt hyperledger/qklszznuser/msp/admincerts 复制公用TLS签名证书的命令如下： mkdir /opt/hyperledger/qklszznuser/tls cp /opt/hyperledger_commconfig/fabricconfig/cryptoconfig/peerOrganizations/org1.qklszzn.com/peers/peer0.org1.qklszzn.com/tls/* /opt/hyperledger/qklszznuser/tls 查看账号 进入文件夹通过tree命令查看证书文件的命令。如下所示： msp admincerts Admin@org1.qklszzn.com-cert.pem cacerts 192-168-23-212-7054.pem keystore 5f470b06e7b34517elf5bc6bl05e2c9ec4a47759378997e826de6f305c075b47_sk signcerts cert . pem tlscacerts tls-192-168-23-212-7054.pem tls ca . crt server . crt server . key fabric-ca-server 客户端访问接口 在Fabric项目中更多的应用场景通过fabric-ca-server提供的RESTAPI接口完成账号注册，账号登记等操作。 1.5 总结 介绍了Fabric是 如何通过账号来进行权限控制的。灵活运用账号功能是开发基础Fabric技术框架项目的先决条件。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-10-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：忠于祖国，忠于人民 https://blog.csdn.net/boss2967/article/details/83037332 1.1 Fabric账号简介 Fabric 的账号体系是 Fabric 的重要的组成部分，由于 Fabric 是基于证书而不是传统的户名名和密码形式，所以会有所不同。 在任何非开放系统中都需要通过账号和密码对系统人口进行相关的管理。联盟链的特点是用户非授权时不能接入区块链，所以Fabric系统中存在一套授权体系，称为Fabric的账号体系。 Fabric账号是什么 Fabric 中的账号实际上是根据 PKI 规范生成的一组证书和秘钥文件 。 cryptogen 模块生成的文件中就包含Fabric 账号相关的证书文件，我们通常接触到的账号体系一般是由账号和密码两个属性组成，一旦账号和密码验证成功，后面操作基本和账号，密码没有关系了。但是区块链系统的一个非常重要的特点是：记录在区块链中的数据具有不可逆，不可篡改的特性。Fabric 中每条交易都会加上发起者的标签（签名证书），同时用发起人的私钥进行加密。如果交易需要其他组织的节点提供背书功能，那么背书节点也会在交易中加入自己的签名。这样每一笔交易的操作过程会非常清晰并且不可篡改。 鉴于传统系统中基于账号和密码的验证体系已经无法完成这样的工作，因此 Fabric 设计了基于 PKI 规范的账号系统满足这样的要求。 一个完整的Fabric账号的结构 msp - admincerts - cacerts - keystore - signcerts - tlscacerts tls - ca.crt - server.crt - server.key 这些文件分别存放在msp文件夹和tls文件夹中。 msp文件夹内容 msp中主要存放签名用的证书文件和加密用的私钥文件。一共五部分。 df admincerts:管理员证书 cacerts:根CA服务器的证书 keystore：节点或者账号的私钥 singcerts:符合x.509的节点或者用户证书文件 tlscacerts:TLS根CA的证书 tls文件夹中的内容 tls 文件夹中存放加密通信相关的证书文件。 注：账号的说法是本书对 Fabric 中账号的特定称谓 Fab ic 的官方文档把这些证书称为 Membership Service Providers ，简称为MSP ，我们无法找到更加准确的翻译，所以本书暂且用账号这个比较传统的名词来指代 Fa ric 生成的这些证书，从实际的运行效果看，这些证书文件等同于账号的作用。 本文中账号就是 MSP Fabric账号哪些地方需要用到 启动Orderer的账号 启动Peer的账号 创建Channe的账号 Peer和Orderer是有属于自己的账号，创建Channel使用的是用户账号。其中Peer和常见Channel的用户账号属于有个组织，而Orderer的启动账号只属于他自己。 1.2 基于cryptogen的账户管理体系 cryptogen模块是创建Fabric账号的方式之一。前面了解到cryptogen可以通过配置文件生成Fabric运行所需要的相关账号文件，在配置文件中可以指定每个组织包含的用户数和节点数。然后cryptogen模块会根据配置文件的定义生成相关数据的配置文件。如果系统发生变化，需要引入新的组织，或者组织中需要增加新的账号和用户，这他妈该怎么办？是不是很懵逼，我也没办法… cryptogen模块通过一个配合可以部分解决这个问题。 通过 cryptogen 模块 子命令 owtemplate 显示默认的模板。 Orderer rOrgs: Name: Orderer Domain:example.com Specs: Hosename:orderer PeerOrgs: Name:Org1 Domain:org1.example.com Template: Count:1 Users: Count:1 Name:Org2 Domain:org2.example.com Template: Count:1 Users: Count:1 在配置文件中PerrOrgs节点Template子节点中有个属Count,Count表示当前组织包含Peer节点的数目，同时也会成生成相应数目的配置文件。例子中给出的组织Org1设置的Peer节点数为4，cryptogen模块根据配置文件会给组织Org1生成4个Peer节点所有需要的账号。 进入组织Org1的账号文件夹中， 执行tree -L2 命令内容显示如下： ca aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk ca.orgl . qklszzn . com-cert . pem msp admincerts cacerts tlscacerts peers peer0. org1 . qklszzn com peer1. org1 . qklszzn com peer2. org1 . qklszzn com peer3. org1 . qklszzn com tlsca f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk tlsca orgl qklszzn . com cert . pem users Admin@org1.qklszzn.com User1@org1.qklszzn.com User2@org1.qklszzn.com User3@org1.qklszzn.com User4@org1.qklszzn.com User5@org1.qklszzn.com User6@org2.qklszzn.com 观察上面内容，共生成4个Peer节点账号文件，这些文件夹的命名是由规则的，peer+索引为前缀+域名。所以前缀的值为0 到 Count-1.这里有一个start属性，这就是我们要找的这孙子，费了好大劲。start属性就是继续添加Peer节点使用的，Start用来表示生成Peer节点账号文件的文件夹命名的前缀，默认是0.如果需要增加新的节点，可以给Start属性赋值上一次的count。 这里以上面例子为例。如果需要给组织Org1新增3个Peer节点，可以使用下面配置： PeerOrgs: Name:Org1 Domain:org1.qklszzn.com Template: Count:3 Start:4 通过上面的配置文件， cryptogen 模块可以给组织Org1新增三个Peer节点的配置文件，我们重新回到组织Org1的账号文件目录中，再次执行 tree-L2,显示如下： ca aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk ca.orgl . qklszzn . com-cert . pem msp admincerts cacerts tlscacerts peers peer0. org1 . qklszzn com peer1. org1 . qklszzn com peer2. org1 . qklszzn com peer3. org1 . qklszzn com peer4. org1 . qklszzn com peer5. org1 . qklszzn com peer6. org1 . qklszzn com tlsca f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk tlsca orgl qklszzn . com cert . pem users Admin@org1.qklszzn.com User1@org1.qklszzn.com User2@org1.qklszzn.com User3@org1.qklszzn.com User4@org1.qklszzn.com User5@org1.qklszzn.com User6@org2.qklszzn.com 成功添加了三个Peer节点的配置文件。 那么问题来了，如果动态添加用户账号该怎么办？目前最新的Fabric版本中并没有提供相关的功能。 有没有简单点的解决Fabric账号问题，就是 Fabric-ca 账号服务器。 1.3 Fabric账号服务器： Fabric-ca Fabric-ca项目有 Fabric-ca-server 和Fabric-ca-client 两个模块组成。 Fabric-ca的编译和安装 Fabric-ca是Golang开发的应用程序。下面将演示在Fabric-ca Ubuntu 中安装。 安装系统组件包 sudo apt install btool 1 ibltdl dev 下载源代码并编译 cd $GOPATH/src/github.com/hyperledger git clone http://gerrit.hyperledger.org/r/fabric-ca cd $GPPATH/src/github.com/hyperledger/fabric-ca make fabric-ca-server make fabric-ca-client 安装编译好的可执行文件。 cd $GOPATH/src/github.com/hyperledger/fabric-ca/bin cp $GOPATH/src/github.com/hyperledger/fabric-ca/bin/* /user/local/bin chmod -R 775 /user/local/bin/fabric-ca-server chmod -R 775 /user/local/bin/fabric-ca-client 检查 fabric-ca-server version fabric-ca-client version fabric-ca-server 的启动和配置 fabric-ca-server 启动之后欧是以守护进程方式存在，可以通过fabric-ca-client 或者实现其通信协议的客户端发起请求。fabric-ca-server 有三种方式设置配置信息。 启动参数 环境变量 配置文件 fabric-ca-server 的命令行选项 init:初始化fabric-ca 服务器 start:启动fabric-ca服务器 version:显示版本 fabric-ca-serve的选项 –address:Fabric 服务器的监听地址（默认为“0.0.0. 。”） -b,–boot:系统启动对应的管理员账号和密码 –ca.certfile:CA证书文件（默认为“ca-cert.pen”） –ca.chainfile：CA链证书文件（默认为“ ca-chain.pem”） –ca.keyfile:CA秘钥文件（默认为“ca-key.pem”） -n,–ca.name:证书颁发机构名称 –cacount:CA实例的数量 –cafiles:以逗号分隔的CA配置文件的列表 –crl.expiry:CRL请求到期时间（默认为24h） –crlsizelimit:可接受的CRL的大小限制，以字节为单位（默认为521000） –csr.cn:请求父Fabric-ca服务器的证书签名时使用的公用名称 –csr.hosts:逗号分隔的父类Fabric-ca服务器的主机名，支持多个 –csr.serialnumber:请求父类Fabric-ca服务器的序列号 –db.datasource:数据库的名称（默认为“fabric-ca-server.db”）,仅仅针对–db.type选项为sqlite3有效 –db.tls.certfiles：和数据库TLS通信时用的证书文件，PEM格式 –db.tls.client.certfile:和数据库TLS通信时用的证书文件，PEM格式 –db.tls.client.keyfile:和数据库进行TLS通信时客户端的私钥文件，PEM格式 –db.type:存储账号类型的数据库的类型，目前支持三种数据库类型，sqlite3,postgres,mysql –d,–debug:启动调试级别日志记录。 -H，–home:Fabric-ca服务器的主目录（默认为当前目录） -intermediate.enrollment.label: 操作中使用的标签 -intermediat e.enrollment.profile:发型证书时要使用的签名配置文件的名称 –intermediate. parentserver. caname: 服务器CA名称 -u,–intermediate.parentserver. url：父Fabric-ca服务器的URL –ldap.enabled: 启动LDAP服务进行客户端身份验证和相关属性的管理 –ldap.groupfilter：LDAP 进行组过滤模式，默认值为（ memberUid=%s ) –ldap tls.certfiles:LDAP 服务器的证书文件， PEM 格式（例如root1.pem,root2.pem) –ldap.tls.client.certfile:LDAP 服务客户端的证书文件，PEM格式。 –ldap.tls.client.keyfile:LDAP 服务客户端私钥文件，PEM格式。 –ldap.url:LDAP服务的URL –ldap.userfilter:LDAP服务器的用户过滤器，默认为（uid=%s） -p,–port :Fabric-ca 服务器监听端口（默认为7054） – registry.maxenrollments:最大允许注册的用户数：如果LDAP未启动时有效(默认为-1) –tls.certfile:Fabric-ca 服务器的证书，PEM格式（默认‘tls-cert.pem’） –tls.clientauth.certfiles：Fabric-ca服务器的客户端证书 –tls.clientauth.type:客户端类型（noclientcert） –tls.enabled:在监听端口上启动TLS fabric-ca-server的初始化 fabric-ca-server 还可以通过配置文件进行参数设置。 执行fabric-ca-server的命令init,可以初始化成相关的配置文件。（执行之前先创建相关的文件夹） mkdir -p /opt/hyperledger/fabric-ca-server fabric-ca-server 服务器初始化的命令如下: fabric-ca-server init -b admin:adminpw -b 参数后面的是 fabric-ca-server 服务器管理账号的用 户名和 密码，这里给出的是个例子，而且很多资料都给出了这个例子，但是如果在生产系统中建议务必使用比较复杂的密码，而避免使用本例中的用户名和密码，避免恶意猜测用户名密码的行为。 初始化命令执行完后会在当前的目录下面生成相应的配置文件。 fabric-ca-server-config.yaml :配置文件 fabric-ca-server.db :数据库文件（数据库选择sqlite3时有效） ca-cert.pem:证书文件 msp:私钥文件夹 fabric-ca-server 的配置文件 fabric-ca-server 配置文件的内容可以参考上 步生成的文件 fabric-ca -server-config.yaml. fabric-ca-server的配置文件一共11部分。 通用配置 通用配置部分包含了系统 些公用属性。 port:7054 //监听端口号 debug:false //是否调试 crlsizelimit:512000 cacount: //支持的CA数目 cafiles: //相关CA配置文件 crl: // expiry:24h //授权证书的有效期 tls tls 部分主要包含了 TLS 通信相关的配置，包括是否需要打开 TLS 通信，TLS 通信的证书和私钥等文件的路径等。 tls: enabled:false //是否启用TLS certfile: tls-cert.pem //TLS证书文件 keyfile: //TLS私钥文件 clientauth: // type:noclientcert //客户端类型 certfiles: //客户端证书类型 ca ca 服务器属性的配置，包含发布证书的组织机构的名称和相关的证书文件路径 。 ca: name: //CA 的名字，如果存在多个 CA 服务器，不能重复 keyfile: ca-key.pen //／私钥文件 certfile:ca-cert.pem //／证书文件 chainfile:ca-chain.pen //／证书链文件 registry registry节点包含了客户端注册相关的信息。 registry: maxenrollments:-1 identities: //注册实体信息，可以有多个 name:adminpw type:client affiliation:&quot;&quot; maxenrollments:-1 attrs: hf.Registrar.Roles:“client,user,peer,validator,auditor” hf.Registrar.DelegateRoles:“client,user,validator,auditor” hf.Revoker:true hf.IntermediateCA:true hf.GenCRL:true hf.Registrar.Attributes:&quot;*&quot; db db 部分包含了 Fabric-ca服务器存储账号文件的数据类型的配置。 db: type:sqlite3 datasource:fabric-ca-server.db tls: enabled:false certfiles: db-server-cert.pem client: certfile:db-client-cert.pem keyfile:db-client-key.pem ldap Fabric-ca 可以配置使用远端 DAP 务器来进行注册管理并且保存注册相关的数据， LDAP服务相关的配置信息包含在 ldap 节点中。 ldap: ldap: enabled:true url: ldap://cn://cn=admin,dc=example,dc=org:admin@localhost:10389 /dc=example,dc=org userfilter:(uid=%s) tls: certfiles: ldap-server-cert.pem client: certfile:ldap-client-cert.pem keyfile:ldap-client-key.pem affiliations ffiliations 节点包含了组织中的部门的相关配置信息，这些配置信息在客户端 SDK用时相关的参数必须保持一致。 affiliations : org1: department1 department2 org2: department1 signing 节点 signing 节点包含了证书签发相关的配置，包括证书的到期时间等属性。 signing: default: //默认的签发ecert usage: //证书签发的作用域 digital signature expiry:8760h //证书有效时间 profiles: ca: usage: cert sign expiry:43800h caconstraint: isca:true maxpathlen:0 //现在中间层继续下发节点 tls： usage: signing key encipherment server auth client auth key agreement expiry:8760h csrd csr 节点包含了证书申请请求时需要使用的配置信息。 csr： cn:fabric-ca-server //服务器名称 names: //证书签发单位的基本信息 C:US ST:“North Carolina” L: O:Hyperledger OU:Fabric hosts: robertfeng-All-Series localhost ca: expiry:131400h //证书有效时间 pathlength:1 //下一级服务器是否可以继续其下级服务签发证书， -1为不可。取值大于0时为允许层数 10 . bccsp bsssp节点包含了加密算法相关的配置，在bccsp节点中可以选择相关的加密算法以及相关加密算法的证书文件。 bccsp： default:SW //加密方式，硬件加密和程序加密 sw: hash: SHA2 security:256 filekeystore: keystore:msp/keystore intermediate 当前 CA 作为中间 时相关的配置。 intermediate: parentserver: //上级CA服务器相关信息 url: caname: enrollment: //需要在上级CA服务器进行登记的信息 hosts: //上级CA服务器地址列表，用逗号分隔 profile: //签发用的profile label: //用于HSM操作的标签信息 tls: //TLS通信相关的属性信息 certfiles: //根证书文件 client: //如果启动客户端文件需要的使用到的部分 certfile: //客户端证书文件 keyfile: //客户端私钥文件 fabric-ca-server的启动 配置文件设置好之后就可以启动 fabric-ca-server服务器了。启动命令如下： fabric-ca-server start -H /opt/hyperledger/fabric-ca --boot admin:adminpw 启动完成后可以通过客户端程序或者通过fabric-ca-client模块访问 fabric-ca-server 服务器。 fabric-ca-client的使用 fabric-ca-server 提供了一组RESTAPI接口供第三方应用程序调用。fabric-ca-client对这些接口进行了封装，只需要设计简单的参数便可完成账号注册，账号授权等操作。fabric-ca-client模块由一组子命令和相关的参数选项组成。 fabric-ca-client模块的子命令 fabric-ca-client模块通过相关自命令完成账号注册，授权申请，证书撤销等操作 enroll:登记账号 gencrl:撤销证书 gencsr:创建证书签名 getcacert:获取CA链证书 reenroll:重新登记账号 register:注册一个新账号 revoke:撤销一个账号 version:显示版本信息 fabric-ca-client模块的参数选项 基本管理 –caname:CA服务器名称 -H,–home:客户端的目录，用来存放客户端相关的文件 -M,–mspdir:客户端的账号证书文件的目录 -d,–debug:将客户端的日志设计为debug模式 -u,–url:fabric-ca-server的地址 账号登记 -enrollment.attrs:账号登记请求中的属性 –enrollment.label:登记请求中的HSM相关的标签 –enrollment.profile:登记请求中的profile 账号注册 –id.affiliation:账号注册时组织的部门信息 –id.attrs:账号注册时的属性列表 –id.maxenrollments:当前注册后可以进行登记的次数 –id.name:账号注册时的用户名 –id.secret:账号注册的密码 –id.type 账号注册的类型 默认为user 证书吊销 -a,–revoke.aki:注销证书时需要的公钥 -e,–revoke.name:注销证书时的实体名称 -r,–revoke.reasion:注销的原因 -s,–revoke.serial:注销证书的序列号 CA证签名 –csr.cn:CA签名请求时，请求报文中的通用名 –csr.hosts::CA签名请求时,请求报文中的主机名 –csr.serialnumber::CA签名请求时,请求报文中的序列号 –csr.names::CA签名请求时，请求报文中的附件名称 -m,–myhost::CA签名请求时,请求报文中请求主机名称，默认值是本地主机 TLS通信 –tls.certfiles:TLS通信模式下的证书文件，PEM文件格式 –tls.client.certfile: TLS通信模式下客户端的证书文件，PEM文件格式 –tls.client.keyfile:TLS通信模式下客户端的私钥文件 1.4 将fabric-ca-server绑定到现有的项目中 Fabric-ca是Fabric的cryptogen模块有力补充，在项目中占有非常重要的作用。 绑定 fabric-ca-server 到现有组织 打开 fabric-ca-server的配置文件 fabric-ca-server-config.yaml.在配置文件找到以下内容： ca: name:ca-org1 keyfile: certfile: chainfile:ca-chain.pem 进入证书文件夹，，进入存放组织Org相关的证书的文件夹。执行命令tree -L2: ca aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk ca.orgl . qklszzn . com-cert . pem msp admincerts cacerts tlscacerts peers peer0. org1 . qklszzn com peer1. org1 . qklszzn com peer2. org1 . qklszzn com peer3. org1 . qklszzn com peer4. org1 . qklszzn com peer5. org1 . qklszzn com peer6. org1 . qklszzn com tlsca f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk tlsca orgl qklszzn . com cert . pem users Admin@org1.qklszzn.com User1@org1.qklszzn.com User2@org1.qklszzn.com User3@org1.qklszzn.com User4@org1.qklszzn.com User5@org1.qklszzn.com User6@org2.qklszzn.com 在ca文件夹中存放了将fabric-ca-server绑定到组织org1的相关文件。 现在可以绑定这些文件，绑定。 keyfile:对应ca文件夹中文件名后缀为-sk的文件 certfile:对应ca文件夹中文件名为ca.org1.qklszzn.com-cert.pem的文件 上述步骤 fabric-ca-server 就被绑定到组织 orgl 中了。 通过客户端从已经绑定的fabric-ca-server中生成账号 设置 fabric-ca-client环境变量 创建目录： mkdir -p /opt/hyperledger/fabric-client 目录常见完成之后，利用管理员账号和密码注册，获取管理员账号msp的证书文件。 export FABRIC_CA_CLIENT_HOME =/opt/hyperledger/fabric-client fabric-ca-client enroll -uhttp://admin:adminpw@localhost:7054 - M /opt/hyperledger/fabric_client 注册账号 名为usertest,密码为user2wd 注册命令如下： fabric-ca-client register --id.name usertest --id.type user --id.affiliation org1.deparment1 --id.secret user2wd -u http://localhost:7054 载入账号 将上一步注册的账号usertest加载到本地，首先需要再本地创建给目录用来存放从服务器下载的证书，目录可以是任何目录。 mkdir -p /opt/hyperledger/qklszznuser 在上面创建的目录中，登录账号usertest，并且登录成功的账号的相关文件会保存到制定目录中。 登记账号的命令如下： fabric-ca-client enroll -u http://usertest：user2wd@localhost:7054 -M /opt/hyperledger/qklszznuser/msp 复制管理员签名和公用TLS证书文件 复制管理账号的签名的命令： mkdir /opt/hyperledger/qklszznuser/msp/admincerts cp/opt/hyperledger_commconfig/fabricconfig/cryptoconfig/perrorganizations/org1.qklszzn.com/users/Admin@qklszzn.com/msp/signcerts/* /opt hyperledger/qklszznuser/msp/admincerts 复制公用TLS签名证书的命令如下： mkdir /opt/hyperledger/qklszznuser/tls cp /opt/hyperledger_commconfig/fabricconfig/cryptoconfig/peerOrganizations/org1.qklszzn.com/peers/peer0.org1.qklszzn.com/tls/* /opt/hyperledger/qklszznuser/tls 查看账号 进入文件夹通过tree命令查看证书文件的命令。如下所示： msp admincerts Admin@org1.qklszzn.com-cert.pem cacerts 192-168-23-212-7054.pem keystore 5f470b06e7b34517elf5bc6bl05e2c9ec4a47759378997e826de6f305c075b47_sk signcerts cert . pem tlscacerts tls-192-168-23-212-7054.pem tls ca . crt server . crt server . key fabric-ca-server 客户端访问接口 在Fabric项目中更多的应用场景通过fabric-ca-server提供的RESTAPI接口完成账号注册，账号登记等操作。 1.5 总结 介绍了Fabric是 如何通过账号来进行权限控制的。灵活运用账号功能是开发基础Fabric技术框架项目的先决条件。 阅读更多","@type":"BlogPosting","url":"/2018/10/13/2ef8653f5d51d36e301dc26cf28b3915.html","headline":"Fabric的账号体系","dateModified":"2018-10-13T00:00:00+08:00","datePublished":"2018-10-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/10/13/2ef8653f5d51d36e301dc26cf28b3915.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>06. Fabric的账号体系</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：忠于祖国，忠于人民 https://blog.csdn.net/boss2967/article/details/83037332 
 </div> 
 <div class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h3><a id="11_Fabric_0"></a>1.1 Fabric账号简介</h3> 
  <p><strong>Fabric 的账号体系是 Fabric 的重要的组成部分，由于 Fabric 是基于证书而不是传统的户名名和密码形式，所以会有所不同。</strong><br> 在任何非开放系统中都需要通过账号和密码对系统人口进行相关的管理。联盟链的特点是用户非授权时不能接入区块链，所以Fabric系统中存在一套授权体系，称为Fabric的账号体系。</p> 
  <h4><a id="Fabric_3"></a>Fabric账号是什么</h4> 
  <p><strong>Fabric 中的账号实际上是根据 PKI 规范生成的一组证书和秘钥文件 。</strong><br> cryptogen 模块生成的文件中就包含Fabric 账号相关的证书文件，我们通常接触到的账号体系一般是由账号和密码两个属性组成，一旦账号和密码验证成功，后面操作基本和账号，密码没有关系了。但是区块链系统的一个非常重要的特点是：记录在区块链中的数据具有不可逆，不可篡改的特性。Fabric 中每条交易都会加上发起者的标签（签名证书），同时用发起人的私钥进行加密。如果交易需要其他组织的节点提供背书功能，那么背书节点也会在交易中加入自己的签名。这样每一笔交易的操作过程会非常清晰并且不可篡改。 鉴于传统系统中基于账号和密码的验证体系已经无法完成这样的工作，因此 Fabric 设计了基于 PKI 规范的账号系统满足这样的要求。</p> 
  <h5><a id="Fabric_6"></a>一个完整的Fabric账号的结构</h5> 
  <blockquote> 
   <ul> 
    <li> <p>msp<br> - admincerts<br> - cacerts<br> - keystore<br> - signcerts<br> - tlscacerts</p> </li> 
    <li> <p>tls<br> - ca.crt<br> - server.crt<br> - server.key</p> </li> 
   </ul> 
  </blockquote> 
  <p>这些文件分别存放在msp文件夹和tls文件夹中。</p> 
  <h5><a id="msp_21"></a>msp文件夹内容</h5> 
  <p>msp中主要存放签名用的证书文件和加密用的私钥文件。一共五部分。<br> df</p> 
  <ul> 
   <li>admincerts:管理员证书</li> 
   <li>cacerts:根CA服务器的证书</li> 
   <li>keystore：节点或者账号的私钥</li> 
   <li>singcerts:符合x.509的节点或者用户证书文件</li> 
   <li>tlscacerts:TLS根CA的证书</li> 
  </ul> 
  <h5><a id="tls_29"></a>tls文件夹中的内容</h5> 
  <p>tls 文件夹中存放加密通信相关的证书文件。</p> 
  <blockquote> 
   <p>注：账号的说法是本书对 Fabric 中账号的特定称谓 Fab ic 的官方文档把这些证书称为 Membership Service Providers ，简称为MSP ，我们无法找到更加准确的翻译，所以本书暂且用账号这个比较传统的名词来指代 Fa ric 生成的这些证书，从实际的运行效果看，这些证书文件等同于账号的作用。</p> 
  </blockquote> 
  <p><strong>本文中账号就是 MSP</strong></p> 
  <h4><a id="Fabric_35"></a>Fabric账号哪些地方需要用到</h4> 
  <ul> 
   <li>启动Orderer的账号</li> 
   <li>启动Peer的账号</li> 
   <li>创建Channe的账号<br> Peer和Orderer是有属于自己的账号，创建Channel使用的是用户账号。其中Peer和常见Channel的用户账号属于有个组织，而Orderer的启动账号只属于他自己。</li> 
  </ul> 
  <h3><a id="12_cryptogen_40"></a>1.2 基于cryptogen的账户管理体系</h3> 
  <p>cryptogen模块是创建Fabric账号的方式之一。前面了解到cryptogen可以通过配置文件生成Fabric运行所需要的相关账号文件，在配置文件中可以指定每个组织包含的用户数和节点数。然后cryptogen模块会根据配置文件的定义生成相关数据的配置文件。如果系统发生变化，需要引入新的组织，或者组织中需要增加新的账号和用户，这他妈该怎么办？是不是很懵逼，我也没办法…<br> cryptogen模块通过一个配合可以部分解决这个问题。</p> 
  <ol> 
   <li>通过 cryptogen 模块 子命令 owtemplate 显示默认的模板。</li> 
  </ol> 
  <blockquote> 
   <ul> 
    <li>Orderer rOrgs: 
     <ul> 
      <li>Name: Orderer 
       <ul> 
        <li>Domain:example.com</li> 
        <li>Specs: 
         <ul> 
          <li>Hosename:orderer</li> 
         </ul> </li> 
       </ul> </li> 
      <li>PeerOrgs: 
       <ul> 
        <li>Name:Org1 
         <ul> 
          <li>Domain:org1.example.com</li> 
          <li>Template: 
           <ul> 
            <li>Count:1</li> 
           </ul> </li> 
          <li>Users: 
           <ul> 
            <li>Count:1</li> 
           </ul> </li> 
         </ul> </li> 
        <li>Name:Org2 
         <ul> 
          <li>Domain:org2.example.com</li> 
          <li>Template: 
           <ul> 
            <li>Count:1</li> 
           </ul> </li> 
          <li>Users: 
           <ul> 
            <li>Count:1</li> 
           </ul> </li> 
         </ul> </li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <p>在配置文件中PerrOrgs节点Template子节点中有个属Count,Count表示当前组织包含Peer节点的数目，同时也会成生成相应数目的配置文件。例子中给出的组织Org1设置的Peer节点数为4，cryptogen模块根据配置文件会给组织Org1生成4个Peer节点所有需要的账号。</p> 
  <ol start="2"> 
   <li>进入组织Org1的账号文件夹中， 执行tree -L2 命令内容显示如下：</li> 
  </ol> 
  <blockquote> 
   <ul> 
    <li>ca 
     <ul> 
      <li>aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk</li> 
      <li>ca.orgl . qklszzn . com-cert . pem</li> 
     </ul> </li> 
    <li>msp 
     <ul> 
      <li>admincerts</li> 
      <li>cacerts</li> 
      <li>tlscacerts</li> 
     </ul> </li> 
    <li>peers 
     <ul> 
      <li>peer0. org1 . qklszzn com</li> 
      <li>peer1. org1 . qklszzn com</li> 
      <li>peer2. org1 . qklszzn com</li> 
      <li>peer3. org1 . qklszzn com</li> 
     </ul> </li> 
    <li>tlsca 
     <ul> 
      <li>f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk</li> 
      <li>tlsca orgl qklszzn . com cert . pem</li> 
     </ul> </li> 
    <li>users 
     <ul> 
      <li><a href="mailto:Admin@org1.qklszzn.com" rel="nofollow">Admin@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User1@org1.qklszzn.com" rel="nofollow">User1@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User2@org1.qklszzn.com" rel="nofollow">User2@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User3@org1.qklszzn.com" rel="nofollow">User3@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User4@org1.qklszzn.com" rel="nofollow">User4@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User5@org1.qklszzn.com" rel="nofollow">User5@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User6@org2.qklszzn.com" rel="nofollow">User6@org2.qklszzn.com</a></li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <p>观察上面内容，共生成4个Peer节点账号文件，这些文件夹的命名是由规则的，peer+索引为前缀+域名。所以前缀的值为0 到 Count-1.这里有一个start属性，这就是我们要找的这孙子，费了好大劲。start属性就是继续添加Peer节点使用的，Start用来表示生成Peer节点账号文件的文件夹命名的前缀，默认是0.如果需要增加新的节点，可以给Start属性赋值上一次的count。</p> 
  <p>这里以上面例子为例。如果需要给组织Org1新增3个Peer节点，可以使用下面配置：</p> 
  <blockquote> 
   <ul> 
    <li>PeerOrgs: 
     <ul> 
      <li>Name:Org1 
       <ul> 
        <li>Domain:org1.qklszzn.com</li> 
        <li>Template: 
         <ul> 
          <li>Count:3</li> 
          <li><font color="red">Start:4</font></li> 
         </ul> </li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <p>通过上面的配置文件， cryptogen 模块可以给组织Org1新增三个Peer节点的配置文件，我们重新回到组织Org1的账号文件目录中，再次执行 <font color="red">tree-L2</font>,显示如下：</p> 
  <blockquote> 
   <ul> 
    <li>ca 
     <ul> 
      <li>aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk</li> 
      <li>ca.orgl . qklszzn . com-cert . pem</li> 
     </ul> </li> 
    <li>msp 
     <ul> 
      <li>admincerts</li> 
      <li>cacerts</li> 
      <li>tlscacerts</li> 
     </ul> </li> 
    <li>peers 
     <ul> 
      <li>peer0. org1 . qklszzn com</li> 
      <li>peer1. org1 . qklszzn com</li> 
      <li>peer2. org1 . qklszzn com</li> 
      <li>peer3. org1 . qklszzn com</li> 
      <li><font color="red">peer4. org1 . qklszzn com</font></li> 
      <li><font color="red">peer5. org1 . qklszzn com</font></li> 
      <li><font color="red">peer6. org1 . qklszzn com</font></li> 
     </ul> </li> 
    <li>tlsca 
     <ul> 
      <li>f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk</li> 
      <li>tlsca orgl qklszzn . com cert . pem</li> 
     </ul> </li> 
    <li>users 
     <ul> 
      <li><a href="mailto:Admin@org1.qklszzn.com" rel="nofollow">Admin@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User1@org1.qklszzn.com" rel="nofollow">User1@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User2@org1.qklszzn.com" rel="nofollow">User2@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User3@org1.qklszzn.com" rel="nofollow">User3@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User4@org1.qklszzn.com" rel="nofollow">User4@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User5@org1.qklszzn.com" rel="nofollow">User5@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User6@org2.qklszzn.com" rel="nofollow">User6@org2.qklszzn.com</a></li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <p>成功添加了三个Peer节点的配置文件。</p> 
  <p>那么问题来了，如果动态添加用户账号该怎么办？目前最新的Fabric版本中并没有提供相关的功能。<br> 有没有简单点的解决Fabric账号问题，就是 <font color="red">Fabric-ca 账号服务器</font>。</p> 
  <h3><a id="13_Fabric_Fabricca_135"></a>1.3 Fabric账号服务器： Fabric-ca</h3> 
  <p>Fabric-ca项目有 Fabric-ca-server 和Fabric-ca-client 两个模块组成。</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181013122552555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Fabric-ca下Fabric系统中的作用示意图"></p> 
  <h4><a id="Fabricca_140"></a>Fabric-ca的编译和安装</h4> 
  <p>Fabric-ca是Golang开发的应用程序。下面将演示在Fabric-ca Ubuntu 中安装。</p> 
  <ol> 
   <li>安装系统组件包</li> 
  </ol> 
  <blockquote> 
   <p><code>sudo apt install btool 1 ibltdl dev</code></p> 
  </blockquote> 
  <ol start="2"> 
   <li>下载源代码并编译</li> 
  </ol> 
  <blockquote> 
   <p><code>cd $GOPATH/src/github.com/hyperledger</code> <code>git clone http://gerrit.hyperledger.org/r/fabric-ca</code> <code>cd $GPPATH/src/github.com/hyperledger/fabric-ca</code> <code>make fabric-ca-server</code><br> <code>make fabric-ca-client</code></p> 
  </blockquote> 
  <ol start="3"> 
   <li>安装编译好的可执行文件。</li> 
  </ol> 
  <blockquote> 
   <p><code>cd $GOPATH/src/github.com/hyperledger/fabric-ca/bin</code> <code>cp $GOPATH/src/github.com/hyperledger/fabric-ca/bin/* /user/local/bin</code><br> <code>chmod -R 775 /user/local/bin/fabric-ca-server</code> <code>chmod -R 775 /user/local/bin/fabric-ca-client</code></p> 
  </blockquote> 
  <ol start="4"> 
   <li>检查</li> 
  </ol> 
  <blockquote> 
   <p><code>fabric-ca-server version</code> <code>fabric-ca-client version</code></p> 
  </blockquote> 
  <h4><a id="fabriccaserver__167"></a>fabric-ca-server 的启动和配置</h4> 
  <p>fabric-ca-server 启动之后欧是以守护进程方式存在，可以通过fabric-ca-client 或者实现其通信协议的客户端发起请求。fabric-ca-server 有三种方式设置配置信息。</p> 
  <ul> 
   <li>启动参数</li> 
   <li>环境变量</li> 
   <li>配置文件</li> 
  </ul> 
  <h5><a id="fabriccaserver__172"></a>fabric-ca-server 的命令行选项</h5> 
  <blockquote> 
   <ul> 
    <li>init:初始化fabric-ca 服务器</li> 
    <li>start:启动fabric-ca服务器</li> 
    <li>version:显示版本</li> 
   </ul> 
  </blockquote> 
  <h5><a id="fabriccaserve_178"></a>fabric-ca-serve的选项</h5> 
  <blockquote> 
   <ul> 
    <li>–address:Fabric 服务器的监听地址（默认为“0.0.0. 。”）</li> 
    <li>-b,–boot:系统启动对应的管理员账号和密码</li> 
    <li>–ca.certfile:CA证书文件（默认为“ca-cert.pen”）</li> 
    <li>–ca.chainfile：CA链证书文件（默认为“ ca-chain.pem”）</li> 
    <li>–ca.keyfile:CA秘钥文件（默认为“ca-key.pem”）</li> 
    <li>-n,–ca.name:证书颁发机构名称</li> 
    <li>–cacount:CA实例的数量</li> 
    <li>–cafiles:以逗号分隔的CA配置文件的列表</li> 
    <li>–crl.expiry:CRL请求到期时间（默认为24h）</li> 
    <li>–crlsizelimit:可接受的CRL的大小限制，以字节为单位（默认为521000）</li> 
    <li>–csr.cn:请求父Fabric-ca服务器的证书签名时使用的公用名称</li> 
    <li>–csr.hosts:逗号分隔的父类Fabric-ca服务器的主机名，支持多个</li> 
    <li>–csr.serialnumber:请求父类Fabric-ca服务器的序列号</li> 
    <li>–db.datasource:数据库的名称（默认为“fabric-ca-server.db”）,仅仅针对–db.type选项为sqlite3有效</li> 
    <li>–db.tls.certfiles：和数据库TLS通信时用的证书文件，PEM格式</li> 
    <li>–db.tls.client.certfile:和数据库TLS通信时用的证书文件，PEM格式</li> 
    <li>–db.tls.client.keyfile:和数据库进行TLS通信时客户端的私钥文件，PEM格式</li> 
    <li>–db.type:存储账号类型的数据库的类型，目前支持三种数据库类型，sqlite3,postgres,mysql</li> 
    <li>–d,–debug:启动调试级别日志记录。</li> 
    <li>-H，–home:Fabric-ca服务器的主目录（默认为当前目录）</li> 
    <li>-intermediate.enrollment.label: 操作中使用的标签</li> 
    <li>-intermediat e.enrollment.profile:发型证书时要使用的签名配置文件的名称</li> 
    <li>–intermediate. parentserver. caname: 服务器CA名称</li> 
    <li>-u,–intermediate.parentserver. url：父Fabric-ca服务器的URL</li> 
    <li>–ldap.enabled: 启动LDAP服务进行客户端身份验证和相关属性的管理</li> 
    <li>–ldap.groupfilter：LDAP 进行组过滤模式，默认值为（ memberUid=%s )</li> 
    <li>–ldap tls.certfiles:LDAP 服务器的证书文件， PEM 格式（例如root1.pem,root2.pem)</li> 
    <li>–ldap.tls.client.certfile:LDAP 服务客户端的证书文件，PEM格式。</li> 
    <li>–ldap.tls.client.keyfile:LDAP 服务客户端私钥文件，PEM格式。</li> 
    <li>–ldap.url:LDAP服务的URL</li> 
    <li>–ldap.userfilter:LDAP服务器的用户过滤器，默认为（uid=%s）</li> 
    <li>-p,–port :Fabric-ca 服务器监听端口（默认为7054）</li> 
    <li>– registry.maxenrollments:最大允许注册的用户数：如果LDAP未启动时有效(默认为-1)</li> 
    <li>–tls.certfile:Fabric-ca 服务器的证书，PEM格式（默认‘tls-cert.pem’）</li> 
    <li>–tls.clientauth.certfiles：Fabric-ca服务器的客户端证书</li> 
    <li>–tls.clientauth.type:客户端类型（noclientcert）</li> 
    <li>–tls.enabled:在监听端口上启动TLS</li> 
   </ul> 
  </blockquote> 
  <h5><a id="fabriccaserver_219"></a>fabric-ca-server的初始化</h5> 
  <p>fabric-ca-server 还可以通过配置文件进行参数设置。</p> 
  <p>执行fabric-ca-server的命令init,可以初始化成相关的配置文件。（执行之前先创建相关的文件夹）</p> 
  <blockquote> 
   <p><code>mkdir -p /opt/hyperledger/fabric-ca-server</code></p> 
  </blockquote> 
  <p>fabric-ca-server 服务器初始化的命令如下:</p> 
  <blockquote> 
   <p><code>fabric-ca-server init -b admin:adminpw</code></p> 
  </blockquote> 
  <blockquote> 
   <p>-b 参数后面的是 fabric-ca-server 服务器管理账号的用 户名和 密码，这里给出的是个例子，而且很多资料都给出了这个例子，但是如果在生产系统中建议务必使用比较复杂的密码，而避免使用本例中的用户名和密码，避免恶意猜测用户名密码的行为。</p> 
  </blockquote> 
  <p>初始化命令执行完后会在当前的目录下面生成相应的配置文件。</p> 
  <blockquote> 
   <ul> 
    <li>fabric-ca-server-config.yaml :配置文件</li> 
    <li>fabric-ca-server.db :数据库文件（数据库选择sqlite3时有效）</li> 
    <li>ca-cert.pem:证书文件</li> 
    <li>msp:私钥文件夹</li> 
   </ul> 
  </blockquote> 
  <h5><a id="fabriccaserver__240"></a>fabric-ca-server 的配置文件</h5> 
  <p>fabric-ca-server 配置文件的内容可以参考上 步生成的文件 fabric-ca -server-config.yaml.</p> 
  <p>fabric-ca-server的配置文件一共11部分。</p> 
  <ol> 
   <li>通用配置</li> 
  </ol> 
  <p><font color="red">通用配置部分包含了系统 些公用属性。</font></p> 
  <blockquote> 
   <ul> 
    <li>port:7054 //监听端口号</li> 
    <li>debug:false //是否调试</li> 
    <li>crlsizelimit:512000</li> 
    <li>cacount: //支持的CA数目</li> 
    <li>cafiles: //相关CA配置文件</li> 
    <li>crl: // 
     <ul> 
      <li>expiry:24h //授权证书的有效期</li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <ol start="2"> 
   <li>tls</li> 
  </ol> 
  <p><font color="red">tls 部分主要包含了 TLS 通信相关的配置，包括是否需要打开 TLS 通信，TLS 通信的证书和私钥等文件的路径等。</font></p> 
  <blockquote> 
   <ul> 
    <li>tls: 
     <ul> 
      <li>enabled:false //是否启用TLS</li> 
      <li>certfile: tls-cert.pem //TLS证书文件</li> 
      <li>keyfile: //TLS私钥文件</li> 
      <li>clientauth: // 
       <ul> 
        <li>type:noclientcert //客户端类型</li> 
        <li>certfiles: //客户端证书类型</li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <ol start="3"> 
   <li>ca</li> 
  </ol> 
  <p><font color="red">ca 服务器属性的配置，包含发布证书的组织机构的名称和相关的证书文件路径 。</font></p> 
  <blockquote> 
   <ul> 
    <li>ca: 
     <ul> 
      <li>name: //CA 的名字，如果存在多个 CA 服务器，不能重复</li> 
      <li>keyfile: ca-key.pen //／私钥文件</li> 
      <li>certfile:ca-cert.pem //／证书文件</li> 
      <li>chainfile:ca-chain.pen //／证书链文件</li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <ol start="4"> 
   <li>registry</li> 
  </ol> 
  <p><font color="red">registry节点包含了客户端注册相关的信息。</font></p> 
  <blockquote> 
   <ul> 
    <li>registry: 
     <ul> 
      <li>maxenrollments:-1</li> 
      <li>identities: //注册实体信息，可以有多个 
       <ul> 
        <li>name:adminpw</li> 
        <li>type:client</li> 
        <li>affiliation:""</li> 
        <li>maxenrollments:-1</li> 
        <li>attrs: 
         <ul> 
          <li>hf.Registrar.Roles:“client,user,peer,validator,auditor”</li> 
          <li>hf.Registrar.DelegateRoles:“client,user,validator,auditor”</li> 
          <li>hf.Revoker:true</li> 
          <li>hf.IntermediateCA:true</li> 
          <li>hf.GenCRL:true</li> 
          <li>hf.Registrar.Attributes:"*"</li> 
         </ul> </li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <ol start="5"> 
   <li>db</li> 
  </ol> 
  <p><font color="red">db 部分包含了 Fabric-ca服务器存储账号文件的数据类型的配置。</font></p> 
  <blockquote> 
   <ul> 
    <li>db: 
     <ul> 
      <li>type:sqlite3</li> 
      <li>datasource:fabric-ca-server.db</li> 
      <li>tls: 
       <ul> 
        <li>enabled:false</li> 
        <li>certfiles: 
         <ul> 
          <li>db-server-cert.pem</li> 
          <li>client: 
           <ul> 
            <li>certfile:db-client-cert.pem</li> 
            <li>keyfile:db-client-key.pem</li> 
           </ul> </li> 
         </ul> </li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <ol start="6"> 
   <li>ldap</li> 
  </ol> 
  <p><font color="red">Fabric-ca 可以配置使用远端 DAP 务器来进行注册管理并且保存注册相关的数据， LDAP服务相关的配置信息包含在 ldap 节点中。</font></p> 
  <blockquote> 
   <ul> 
    <li>ldap:</li> 
    <li>ldap: 
     <ul> 
      <li>enabled:true</li> 
      <li>url: ldap://cn://cn=admin,dc=example,dc=org:admin@localhost:10389<br> /dc=example,dc=org</li> 
      <li>userfilter:(uid=%s)</li> 
      <li>tls: 
       <ul> 
        <li>certfiles: 
         <ul> 
          <li>ldap-server-cert.pem</li> 
         </ul> </li> 
        <li>client: 
         <ul> 
          <li>certfile:ldap-client-cert.pem</li> 
          <li>keyfile:ldap-client-key.pem</li> 
         </ul> </li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <ol start="7"> 
   <li>affiliations</li> 
  </ol> 
  <p><font color="red">ffiliations 节点包含了组织中的部门的相关配置信息，这些配置信息在客户端 SDK用时相关的参数必须保持一致。</font></p> 
  <blockquote> 
   <ul> 
    <li>affiliations : 
     <ul> 
      <li>org1: 
       <ul> 
        <li>department1</li> 
        <li>department2</li> 
       </ul> </li> 
      <li>org2: 
       <ul> 
        <li>department1</li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <ol start="8"> 
   <li>signing 节点</li> 
  </ol> 
  <p><font color="red">signing 节点包含了证书签发相关的配置，包括证书的到期时间等属性。</font></p> 
  <blockquote> 
   <ul> 
    <li>signing: 
     <ul> 
      <li>default: //默认的签发ecert 
       <ul> 
        <li>usage: //证书签发的作用域 
         <ul> 
          <li>digital signature</li> 
          <li>expiry:8760h //证书有效时间</li> 
         </ul> </li> 
        <li>profiles: 
         <ul> 
          <li>ca: 
           <ul> 
            <li>usage: 
             <ul> 
              <li>cert sign</li> 
             </ul> </li> 
            <li>expiry:43800h</li> 
            <li>caconstraint: 
             <ul> 
              <li>isca:true</li> 
              <li>maxpathlen:0 //现在中间层继续下发节点</li> 
             </ul> </li> 
           </ul> </li> 
          <li>tls： 
           <ul> 
            <li>usage: 
             <ul> 
              <li>signing</li> 
              <li>key encipherment</li> 
              <li>server auth</li> 
              <li>client auth</li> 
              <li>key agreement</li> 
             </ul> </li> 
            <li>expiry:8760h</li> 
           </ul> </li> 
         </ul> </li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <ol start="9"> 
   <li>csrd</li> 
  </ol> 
  <p><font color="red">csr 节点包含了证书申请请求时需要使用的配置信息。</font></p> 
  <blockquote> 
   <ul> 
    <li>csr： 
     <ul> 
      <li>cn:fabric-ca-server //服务器名称</li> 
      <li>names: //证书签发单位的基本信息 
       <ul> 
        <li>C:US 
         <ul> 
          <li>ST:“North Carolina”</li> 
          <li>L:</li> 
          <li>O:Hyperledger</li> 
          <li>OU:Fabric</li> 
         </ul> </li> 
        <li>hosts: 
         <ul> 
          <li>robertfeng-All-Series</li> 
          <li>localhost</li> 
         </ul> </li> 
        <li>ca:</li> 
        <li>expiry:131400h //证书有效时间</li> 
        <li>pathlength:1 //下一级服务器是否可以继续其下级服务签发证书， -1为不可。取值大于0时为允许层数</li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <p>10 . bccsp</p> 
  <p><font color="red">bsssp节点包含了加密算法相关的配置，在bccsp节点中可以选择相关的加密算法以及相关加密算法的证书文件。</font></p> 
  <blockquote> 
   <ul> 
    <li>bccsp： 
     <ul> 
      <li>default:SW //加密方式，硬件加密和程序加密</li> 
      <li>sw: 
       <ul> 
        <li>hash: SHA2</li> 
        <li>security:256</li> 
        <li>filekeystore: 
         <ul> 
          <li>keystore:msp/keystore</li> 
         </ul> </li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <ol start="11"> 
   <li>intermediate</li> 
  </ol> 
  <p><font color="red">当前 CA 作为中间 时相关的配置。</font></p> 
  <blockquote> 
   <ul> 
    <li>intermediate: 
     <ul> 
      <li>parentserver: //上级CA服务器相关信息</li> 
      <li>url:</li> 
      <li>caname:</li> 
     </ul> </li> 
    <li>enrollment: //需要在上级CA服务器进行登记的信息 
     <ul> 
      <li>hosts: //上级CA服务器地址列表，用逗号分隔</li> 
      <li>profile: //签发用的profile</li> 
      <li>label: //用于HSM操作的标签信息</li> 
     </ul> </li> 
    <li>tls: //TLS通信相关的属性信息 
     <ul> 
      <li>certfiles: //根证书文件</li> 
      <li>client: //如果启动客户端文件需要的使用到的部分 
       <ul> 
        <li>certfile: //客户端证书文件</li> 
        <li>keyfile: //客户端私钥文件</li> 
       </ul> </li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <h5><a id="fabriccaserver_411"></a>fabric-ca-server的启动</h5> 
  <p>配置文件设置好之后就可以启动 fabric-ca-server服务器了。启动命令如下：</p> 
  <blockquote> 
   <p><code>fabric-ca-server start -H /opt/hyperledger/fabric-ca --boot admin:adminpw</code></p> 
  </blockquote> 
  <p>启动完成后可以通过客户端程序或者通过fabric-ca-client模块访问 fabric-ca-server 服务器。</p> 
  <h4><a id="fabriccaclient_420"></a>fabric-ca-client的使用</h4> 
  <p>fabric-ca-server 提供了一组RESTAPI接口供第三方应用程序调用。fabric-ca-client对这些接口进行了封装，只需要设计简单的参数便可完成账号注册，账号授权等操作。fabric-ca-client模块由一组子命令和相关的参数选项组成。</p> 
  <h5><a id="fabriccaclient_422"></a>fabric-ca-client模块的子命令</h5> 
  <p><font color="red">fabric-ca-client模块通过相关自命令完成账号注册，授权申请，证书撤销等操作</font></p> 
  <ul> 
   <li>enroll:登记账号</li> 
   <li>gencrl:撤销证书</li> 
   <li>gencsr:创建证书签名</li> 
   <li>getcacert:获取CA链证书</li> 
   <li>reenroll:重新登记账号</li> 
   <li>register:注册一个新账号</li> 
   <li>revoke:撤销一个账号</li> 
   <li>version:显示版本信息</li> 
  </ul> 
  <h5><a id="fabriccaclient_433"></a>fabric-ca-client模块的参数选项</h5> 
  <ol> 
   <li>基本管理</li> 
  </ol> 
  <blockquote> 
   <ul> 
    <li>–caname:CA服务器名称</li> 
    <li>-H,–home:客户端的目录，用来存放客户端相关的文件</li> 
    <li>-M,–mspdir:客户端的账号证书文件的目录</li> 
    <li>-d,–debug:将客户端的日志设计为debug模式</li> 
    <li>-u,–url:fabric-ca-server的地址</li> 
   </ul> 
  </blockquote> 
  <ol start="2"> 
   <li>账号登记</li> 
  </ol> 
  <blockquote> 
   <ul> 
    <li>-enrollment.attrs:账号登记请求中的属性</li> 
    <li>–enrollment.label:登记请求中的HSM相关的标签</li> 
    <li>–enrollment.profile:登记请求中的profile</li> 
   </ul> 
  </blockquote> 
  <ol start="3"> 
   <li>账号注册</li> 
  </ol> 
  <blockquote> 
   <ul> 
    <li>–id.affiliation:账号注册时组织的部门信息</li> 
    <li>–id.attrs:账号注册时的属性列表</li> 
    <li>–id.maxenrollments:当前注册后可以进行登记的次数</li> 
    <li>–id.name:账号注册时的用户名</li> 
    <li>–id.secret:账号注册的密码</li> 
    <li>–id.type 账号注册的类型 默认为user</li> 
   </ul> 
  </blockquote> 
  <ol start="4"> 
   <li>证书吊销</li> 
  </ol> 
  <blockquote> 
   <ul> 
    <li>-a,–revoke.aki:注销证书时需要的公钥</li> 
    <li>-e,–revoke.name:注销证书时的实体名称</li> 
    <li>-r,–revoke.reasion:注销的原因</li> 
    <li>-s,–revoke.serial:注销证书的序列号</li> 
   </ul> 
  </blockquote> 
  <ol start="5"> 
   <li>CA证签名</li> 
  </ol> 
  <blockquote> 
   <ul> 
    <li>–csr.cn:CA签名请求时，请求报文中的通用名</li> 
    <li>–csr.hosts::CA签名请求时,请求报文中的主机名</li> 
    <li>–csr.serialnumber::CA签名请求时,请求报文中的序列号</li> 
    <li>–csr.names::CA签名请求时，请求报文中的附件名称</li> 
    <li>-m,–myhost::CA签名请求时,请求报文中请求主机名称，默认值是本地主机</li> 
   </ul> 
  </blockquote> 
  <ol start="6"> 
   <li>TLS通信</li> 
  </ol> 
  <blockquote> 
   <ul> 
    <li>–tls.certfiles:TLS通信模式下的证书文件，PEM文件格式</li> 
    <li>–tls.client.certfile: TLS通信模式下客户端的证书文件，PEM文件格式</li> 
    <li>–tls.client.keyfile:TLS通信模式下客户端的私钥文件</li> 
   </ul> 
  </blockquote> 
  <h3><a id="14_fabriccaserver_473"></a>1.4 将fabric-ca-server绑定到现有的项目中</h3> 
  <p>Fabric-ca是Fabric的cryptogen模块有力补充，在项目中占有非常重要的作用。</p> 
  <h4><a id="_fabriccaserver__475"></a>绑定 fabric-ca-server 到现有组织</h4> 
  <ol> 
   <li>打开 fabric-ca-server的配置文件 fabric-ca-server-config.yaml.在配置文件找到以下内容：</li> 
  </ol> 
  <ul> 
   <li>ca: 
    <ul> 
     <li>name:ca-org1</li> 
     <li>keyfile:</li> 
     <li>certfile:</li> 
     <li>chainfile:ca-chain.pem</li> 
    </ul> </li> 
  </ul> 
  <ol start="2"> 
   <li>进入证书文件夹，，进入存放组织Org相关的证书的文件夹。执行命令tree -L2:</li> 
  </ol> 
  <blockquote> 
   <ul> 
    <li>ca 
     <ul> 
      <li>aldb72lc0cfb6fl07fc4550ld29866633d2la3492c87bb352687b2e8e85b652e sk</li> 
      <li>ca.orgl . qklszzn . com-cert . pem</li> 
     </ul> </li> 
    <li>msp 
     <ul> 
      <li>admincerts</li> 
      <li>cacerts</li> 
      <li>tlscacerts</li> 
     </ul> </li> 
    <li>peers 
     <ul> 
      <li>peer0. org1 . qklszzn com</li> 
      <li>peer1. org1 . qklszzn com</li> 
      <li>peer2. org1 . qklszzn com</li> 
      <li>peer3. org1 . qklszzn com</li> 
      <li><font color="red">peer4. org1 . qklszzn com</font></li> 
      <li><font color="red">peer5. org1 . qklszzn com</font></li> 
      <li><font color="red">peer6. org1 . qklszzn com</font></li> 
     </ul> </li> 
    <li>tlsca 
     <ul> 
      <li>f92d78e8195795 e 3all5c4cl29d78edaac70ec4f5ef4764df43elde245e7d467_ sk</li> 
      <li>tlsca orgl qklszzn . com cert . pem</li> 
     </ul> </li> 
    <li>users 
     <ul> 
      <li><a href="mailto:Admin@org1.qklszzn.com" rel="nofollow">Admin@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User1@org1.qklszzn.com" rel="nofollow">User1@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User2@org1.qklszzn.com" rel="nofollow">User2@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User3@org1.qklszzn.com" rel="nofollow">User3@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User4@org1.qklszzn.com" rel="nofollow">User4@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User5@org1.qklszzn.com" rel="nofollow">User5@org1.qklszzn.com</a></li> 
      <li><a href="mailto:User6@org2.qklszzn.com" rel="nofollow">User6@org2.qklszzn.com</a></li> 
     </ul> </li> 
   </ul> 
  </blockquote> 
  <p>在ca文件夹中存放了将fabric-ca-server绑定到组织org1的相关文件。<br> 现在可以绑定这些文件，绑定。</p> 
  <ul> 
   <li>keyfile:对应ca文件夹中文件名后缀为-sk的文件</li> 
   <li>certfile:对应ca文件夹中文件名为ca.org1.qklszzn.com-cert.pem的文件<br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20181013161001430?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jvc3MyOTY3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="配置"></li> 
  </ul> 
  <p>上述步骤 fabric-ca-server 就被绑定到组织 orgl 中了。</p> 
  <h4><a id="fabriccaserver_520"></a>通过客户端从已经绑定的fabric-ca-server中生成账号</h4> 
  <ol> 
   <li>设置 fabric-ca-client环境变量<br> 创建目录：</li> 
  </ol> 
  <blockquote> 
   <p><code>mkdir -p /opt/hyperledger/fabric-client</code></p> 
  </blockquote> 
  <p>目录常见完成之后，利用管理员账号和密码注册，获取管理员账号msp的证书文件。</p> 
  <blockquote> 
   <p><code>export FABRIC_CA_CLIENT_HOME =/opt/hyperledger/fabric-client fabric-ca-client enroll -uhttp://admin:adminpw@localhost:7054 - M /opt/hyperledger/fabric_client</code></p> 
  </blockquote> 
  <ol start="2"> 
   <li>注册账号<br> 名为usertest,密码为user2wd 注册命令如下：</li> 
  </ol> 
  <blockquote> 
   <p><code>fabric-ca-client register --id.name usertest --id.type user --id.affiliation org1.deparment1 --id.secret user2wd -u http://localhost:7054</code></p> 
  </blockquote> 
  <ol start="3"> 
   <li>载入账号<br> 将上一步注册的账号usertest加载到本地，首先需要再本地创建给目录用来存放从服务器下载的证书，目录可以是任何目录。</li> 
  </ol> 
  <blockquote> 
   <p><code>mkdir -p /opt/hyperledger/qklszznuser</code></p> 
  </blockquote> 
  <p>在上面创建的目录中，登录账号usertest，并且登录成功的账号的相关文件会保存到制定目录中。 登记账号的命令如下：</p> 
  <blockquote> 
   <p><code>fabric-ca-client enroll -u http://usertest：user2wd@localhost:7054 -M /opt/hyperledger/qklszznuser/msp</code></p> 
  </blockquote> 
  <ol start="4"> 
   <li>复制管理员签名和公用TLS证书文件<br> 复制管理账号的签名的命令：</li> 
  </ol> 
  <blockquote> 
   <p><code>mkdir /opt/hyperledger/qklszznuser/msp/admincerts</code><br> <code>cp/opt/hyperledger_commconfig/fabricconfig/cryptoconfig/perrorganizations/org1.qklszzn.com/users/Admin@qklszzn.com/msp/signcerts/* /opt hyperledger/qklszznuser/msp/admincerts</code></p> 
  </blockquote> 
  <p>复制公用TLS签名证书的命令如下：</p> 
  <blockquote> 
   <p><code>mkdir /opt/hyperledger/qklszznuser/tls</code> <code>cp /opt/hyperledger_commconfig/fabricconfig/cryptoconfig/peerOrganizations/org1.qklszzn.com/peers/peer0.org1.qklszzn.com/tls/* /opt/hyperledger/qklszznuser/tls</code></p> 
  </blockquote> 
  <ol start="5"> 
   <li>查看账号<br> 进入文件夹通过tree命令查看证书文件的命令。如下所示：</li> 
  </ol> 
  <blockquote> 
   <ul> 
    <li>msp 
     <ul> 
      <li>admincerts 
       <ul> 
        <li>Admin@org1.qklszzn.com-cert.pem</li> 
       </ul> </li> 
      <li>cacerts 
       <ul> 
        <li>192-168-23-212-7054.pem</li> 
       </ul> </li> 
      <li>keystore 
       <ul> 
        <li>5f470b06e7b34517elf5bc6bl05e2c9ec4a47759378997e826de6f305c075b47_sk</li> 
       </ul> </li> 
      <li>signcerts 
       <ul> 
        <li>cert . pem</li> 
       </ul> </li> 
      <li>tlscacerts 
       <ul> 
        <li>tls-192-168-23-212-7054.pem</li> 
       </ul> </li> 
     </ul> </li> 
    <li>tls</li> 
    <li>ca . crt</li> 
    <li>server . crt</li> 
    <li>server . key</li> 
   </ul> 
  </blockquote> 
  <ol start="6"> 
   <li>fabric-ca-server 客户端访问接口<br> 在Fabric项目中更多的应用场景通过fabric-ca-server提供的RESTAPI接口完成账号注册，账号登记等操作。</li> 
  </ol> 
  <h4><a id="15__582"></a>1.5 总结</h4> 
  <p>介绍了Fabric是 如何通过账号来进行权限控制的。灵活运用账号功能是开发基础Fabric技术框架项目的先决条件。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7f770a53f2.css" rel="stylesheet"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/boss2967/article/details/83037332,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/boss2967/article/details/83037332,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
