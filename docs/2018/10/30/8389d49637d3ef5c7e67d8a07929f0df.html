<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>用户发送http交易请求到rpc服务，tx写入txpool中的pending队列，最后打包成区块的整个流程 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="用户发送http交易请求到rpc服务，tx写入txpool中的pending队列，最后打包成区块的整个流程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="用户发送http交易请求到rpc服务，再到txpool，最后打包成区块的整个流程： 1.经过http.Server等一系列调用后，最终会进入rpc/http.go里ServeHttp方法，最后会调用ServeSingleRequest方法 &nbsp; srv.ServeSingleRequest(ctx, codec, OptionMethodInvocation) 2. rpc/server.go里的ServeSingleRequest方法&nbsp;&nbsp; &nbsp; func (s *Server) ServeSingleRequest(ctx context.Context, codec ServerCodec, options CodecOption) { &nbsp;&nbsp;&nbsp;&nbsp;s.serveRequest(ctx, codec, true, options) } 3.rpc/server.go里的serveRequest方法 &nbsp; 这个方法将会实现解码用户发来的json字符串，得到方法名和参数列表，然后调用相应的方法执行。 for atomic.LoadInt32(&amp;s.run) == 1 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reqs, batch, err := s.readRequest(codec) &nbsp;&nbsp; &nbsp; // If a single shot request is executing, run and return immediately &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if singleShot { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if batch { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.execBatch(ctx, codec, reqs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.exec(ctx, codec, reqs[0]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For multi-shot connections, start a goroutine to serve and loop back &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pend.Add(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func(reqs []*serverRequest, batch bool) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer pend.Done() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if batch { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.execBatch(ctx, codec, reqs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.exec(ctx, codec, reqs[0]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}(reqs, batch) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; 关键方法有三个：readRequest，execBatch和exec方法 &nbsp; 3.1 readRequest方法，主要实现了解码请求一条请求 &nbsp; &nbsp; 3.1.1 ReadRequestHeaders &nbsp; &nbsp; reqs, batch, err := codec.ReadRequestHeaders() &nbsp;&nbsp; rpc/json.go里的ReadRequestHeaders方法实现了根据传进来的method参数，解析出命名空间和对应的方法。 &nbsp; &nbsp; &nbsp;return parseRequest(incomingMsg) &nbsp;&nbsp; rpc/json.go里的parseRequest方法的内容：&nbsp;&nbsp; &nbsp; elems := strings.Split(in.Method, serviceMethodSeparator) &nbsp;&nbsp;&nbsp;&nbsp;if len(elems) != 2 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, false, &amp;methodNotFoundError{in.Method, &quot;&quot;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// regular RPC call &nbsp;&nbsp;&nbsp;&nbsp;if len(in.Payload) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return []rpcRequest{{service: elems[0], method: elems[1], id: &amp;in.Id}}, false, nil &nbsp;&nbsp;&nbsp;&nbsp;} return []rpcRequest{{service: elems[0], method: elems[1], id: &amp;in.Id, params: in.Payload}}, false, nil &nbsp; &nbsp; 这部分代码实现分割方法名，比如eth_getTransaction ,eth为namespace， getTransaction为方法 &nbsp;&nbsp; &nbsp; 3.1.2 ParseRequestArguments方法实现解释参数列表&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if callb, ok := svc.callbacks[r.method]; ok { // lookup RPC method &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i] = &amp;serverRequest{id: r.id, svcname: svc.name, callb: callb} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if r.params != nil &amp;&amp; len(callb.argTypes) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if args, err := codec.ParseRequestArguments(callb.argTypes, r.params); err == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i].args = args &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i].err = &amp;invalidParamsError{err.Error()} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; 3.2 execBatch方法，实现批处理执行方法 &nbsp; &nbsp;&nbsp; 3.3 exec方法，执行单个调用 &nbsp; &nbsp; &nbsp; // exec executes the given request and writes the result back using the codec. func (s *Server) exec(ctx context.Context, codec ServerCodec, req *serverRequest) { &nbsp;&nbsp;&nbsp;&nbsp;var response interface{} &nbsp;&nbsp;&nbsp;&nbsp;var callback func() &nbsp;&nbsp;&nbsp;&nbsp;if req.err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = codec.CreateErrorResponse(&amp;req.id, req.err) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response, callback = s.handle(ctx, codec, req) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if err := codec.Write(response); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Error(fmt.Sprintf(&quot;%v\n&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;codec.Close() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// when request was a subscribe request this allows these subscriptions to be actived &nbsp;&nbsp;&nbsp;&nbsp;if callback != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback() &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp;&nbsp; 最核心的是调用server的handle方法，主要实现了根据函数名和参数列表，调用该函数。核心代码为： &nbsp;&nbsp; arguments := []reflect.Value{req.callb.rcvr} &nbsp;&nbsp;&nbsp;&nbsp;if req.callb.hasCtx { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments = append(arguments, reflect.ValueOf(ctx)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(req.args) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments = append(arguments, req.args...) // execute RPC method and return result &nbsp;&nbsp;&nbsp;&nbsp;reply := req.callb.method.Func.Call(arguments) &nbsp; 4.假设调用的是eth_sendTransaction方法，将会进入api/api.go里的sendTransaction方法的逻辑。 &nbsp;&nbsp; api.go定义了所有的rpc方法，api/backend.go里的GetAPIs方法把这些rpc方法封装成4大类service， &nbsp; 分别是命名空间为eth的NewPublicTransactionPoolAPI，NewPublicBlockChainAPI，NewPublicAccountAPI &nbsp; 和命名空间为personal的NewPrivateAccountAPI。 &nbsp;&nbsp; eth的NewPublicTransactionPoolAPI 的SendTransaction方法不需要密码， &nbsp;&nbsp; &nbsp; 而personal的NewPrivateAccountAPI的SendTransaction方法需要密码去解密key。 &nbsp; &nbsp; SendTransaction方法最终会实现把交易插入txpoll的pending队列 &nbsp; 5. api/api.go里的命名空间为eth的NewPublicTransactionPoolAPI的SendTransaction方法分析： &nbsp;func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error)&nbsp; { &nbsp; return submitTransaction(ctx, s.b, signed) } &nbsp; 5.1 api.go里的submitTransaction方法的核心内容&nbsp; &nbsp;&nbsp; func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) { &nbsp;&nbsp;&nbsp;&nbsp;if err := b.SendTx(ctx, tx); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; 5.2 node/api_backend.go里的SendTx方法&nbsp;&nbsp; &nbsp; func (b *APIBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return b.kkchain.TxPool().AddLocal(signedTx) } &nbsp; 5.3 core/tx_poll.go里的AddLocal方法&nbsp; &nbsp; func (pool *TxPool) AddLocal(tx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return pool.addTx(tx, !pool.config.NoLocals) } &nbsp;5.4 core/tx_poll.go里的addTx方法&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; func (pool *TxPool) addTx(tx *types.Transaction, local bool) error&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;// Try to inject the transaction and update any state &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.add(tx, local) &nbsp;&nbsp;&nbsp;&nbsp;// If we added a new transaction, run promotion checks and return &nbsp;&nbsp;&nbsp;&nbsp;if !replace { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.promoteExecutables([]common.Address{from}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return nil } &nbsp; &nbsp; addTx方法里核心方法有两个一个是pool.add 方法，一个pool.promoteExecutables方法。add方法如果是替换pending队列里的tx的情况，则会直接替换pengding里的tx。 &nbsp;&nbsp; 而 pool.promoteExecutables实现了把普通队列的tx加入到txpoll的pending队列去。 &nbsp; &nbsp; tx_poll.go的add方法：&nbsp; &nbsp; &nbsp; // If the transaction fails basic validation, discard it &nbsp;&nbsp;&nbsp;&nbsp;if err := pool.validateTx(tx, local); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.WithFields(log.Fields{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;hash&quot;: hash.String(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;err&quot;:&nbsp; err, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).Error(&quot;Discarding invalid transaction&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err &nbsp;&nbsp;&nbsp;&nbsp;} // New transaction isn&#39;t replacing a pending one, push into queue &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.enqueueTx(hash, tx) &nbsp;&nbsp; 其中validateTx方法会做签名和是否超过gaslimit的检查 &nbsp; 5.5 core/tx_poll.go里的pool.promoteExecutables方法，这个方法每次执行都会按顺序尝试删掉以下的逻辑： &nbsp; &nbsp; 删除时间太久的tx，删除账户余额不足或者超过gas的tx，把剩下的tx加入到pending列表。 &nbsp;&nbsp; &nbsp; // Iterate over all accounts and promote any executable transactions &nbsp;&nbsp;&nbsp;&nbsp;for _, addr := range accounts { // Gather all executable transactions and promote them &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash := tx.Hash() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if pool.promoteTx(addr, hash, tx) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Debugf(&quot;Promoting queued transaction,hash: %s&quot;, hash.String()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promoted = append(promoted, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; } &nbsp; // Notify subsystem for new promoted transactions. &nbsp;&nbsp;&nbsp;&nbsp;if len(promoted) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(NewTxsEvent{promoted}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 如果pending的队列大于0，发送tx事件到txFeed中。 &nbsp; 5.6 pool.promoteTx 方法实现把tx加入到txpoll的pending队列去。 &nbsp; &nbsp;&nbsp; func (pool *TxPool) promoteTx(addr common.Address, hash common.Hash, tx *types.Transaction) bool { &nbsp;&nbsp;&nbsp;&nbsp;// Try to insert the transaction into the pending queue &nbsp;&nbsp;&nbsp;&nbsp;if pool.pending[addr] == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.pending[addr] = newTxList(true) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;list := pool.pending[addr] &nbsp;&nbsp;&nbsp;&nbsp;inserted, old := list.Add(tx, pool.config.PriceBump) &nbsp; &nbsp; if !inserted { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// An older transaction was better, discard this &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Remove(hash) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Otherwise discard any previous transaction and mark this &nbsp;&nbsp;&nbsp;&nbsp;if old != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Remove(old.Hash()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Failsafe to work around direct pending inserts (tests) &nbsp;&nbsp;&nbsp;&nbsp;if pool.all.Get(hash) == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Add(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Put(tx) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Set the potentially new pending nonce and notify any subsystems of the new tx &nbsp;&nbsp;&nbsp;&nbsp;pool.beats[addr] = time.Now() &nbsp;&nbsp;&nbsp;&nbsp;pool.pendingState.SetNonce(addr, tx.Nonce()+1) &nbsp;&nbsp;&nbsp;&nbsp;return true &nbsp;&nbsp; &nbsp; &nbsp; 调用core/tx_list.go的Add方法时，如果当前收集的tx在pending队列已经存在，并且老的tx比新的tx的gasprice更大，则新的tx不会再插入到pending列表中去。 &nbsp; &nbsp; &nbsp; 6.txpoll里的tx的处理逻辑： &nbsp; 插入区块分两种情况: &nbsp; 情况1:挖矿的全节点，从txpoll中取出tx进行打包。&nbsp; &nbsp; 情况2:收到别的成功挖矿区块，验证通过后，插入区块 &nbsp;这里讲的是第一种 &nbsp; &nbsp; 6.1 在node/node.go的New方法里&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; node.txPool = core.NewTxPool(txConfig, chainConfig, node.blockchain) &nbsp;node.miner = miner.New(chainConfig, node.blockchain, node.txPool, node.engine) &nbsp;&nbsp; 其中core/tx_poll.go里的NewTxPool方法最终会调用 pool.loop方法 &nbsp; &nbsp; go pool.loop() &nbsp;&nbsp; 其中miner/miner.go里的miner.New方法构建worker实例和会调用miner.onEvent方法 miner := &amp;Miner{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quitCh:&nbsp; &nbsp; &nbsp; make(chan struct{}), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncStartCh: make(chan core.StartEvent), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncDoneCh:&nbsp; make(chan core.DoneEvent), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker:&nbsp; &nbsp; &nbsp; newWorker(config, bc, txpool, engine), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain: &nbsp; &nbsp; &nbsp; bc, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncDone:&nbsp; &nbsp; 1, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;go miner.onEvent() &nbsp; &nbsp; &nbsp; 其中miner/worker.go 里的newWorker方法会订阅txs和chain head事件，并且开启三个协程。 &nbsp;&nbsp; // Subscribe events from tx pool &nbsp;&nbsp;&nbsp;&nbsp;w.txsSub = txpool.SubscribeNewTxsEvent(w.txsCh) &nbsp;&nbsp;&nbsp;&nbsp;// Subscribe events from inbound handler &nbsp;&nbsp;&nbsp;&nbsp;w.chainHeadSub = bc.SubscribeChainHeadEvent(w.chainHeadCh) &nbsp;&nbsp;&nbsp;&nbsp;go w.mineLoop() &nbsp;&nbsp;&nbsp;&nbsp;go w.taskLoop() &nbsp;&nbsp;&nbsp;&nbsp;go w.waitResult() &nbsp;&nbsp;&nbsp;&nbsp;// Submit first work to initialize pending state. &nbsp;&nbsp;&nbsp;&nbsp;w.startCh &lt;- struct{}{} &nbsp;&nbsp;&nbsp;&nbsp;return w &nbsp;&nbsp; miner/worker.go里的mineLoop方法的内容为： &nbsp; &nbsp; func (w *worker) mineLoop() { &nbsp;&nbsp;&nbsp;&nbsp;defer w.txsSub.Unsubscribe() &nbsp;&nbsp;&nbsp;&nbsp;defer w.chainHeadSub.Unsubscribe() &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case txs := &lt;-w.txsCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range txs.Txs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.chainHeadCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if w.isRunning() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.commitTask() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.startCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.commitTask() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Stopped Mining &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp; &nbsp;到这里，就能把rpc发送的sendTransaction请求和txpoll连起来了。因为api/api.go里的SendTransaction方法，如果没问题的话，最终会调用core/tx_poll.go里的pool.promoteExecutables方法，然后在方法里会执行 &nbsp;go pool.txFeed.Send(NewTxsEvent{promoted}。当发送Txs的事件消息给txFeed时，所有订阅了txs事件消息的channel都能收到。这时就会触发mineLoop方法里的case txs:=&lt;-w.txsCh，但是为什么这里只是打印出来而已呢？ &nbsp;&nbsp; &nbsp; 因为core/tx_poll.go里的pool.promoteExecutables方法里会调用pool.promoteTx(addr, hash, tx)时，已经把tx加入到pending队列。后面只需要调用commitTask，就能实现把txpoll中的pending队列里的tx进行打包。 &nbsp; &nbsp;6.2 commitTask分析： &nbsp;&nbsp; 在最初的启动时候会调用一次w.commitTask()，commitTask会从txpoll中取出pending队列的tx打包成区块，最终会把打包的区块写入w.taskCh&nbsp; &nbsp; &nbsp; func (w *worker) commitTask() { &nbsp; //get txs from pending pool &nbsp;&nbsp;&nbsp;&nbsp;pending, count, _ := w.txpool.Pending() &nbsp;&nbsp;&nbsp;&nbsp;txs := make(types.Transactions, 0, count) &nbsp;&nbsp;&nbsp;&nbsp;for _, acctxs := range pending { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range acctxs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txs = append(txs, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(txs) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//apply txs and get block &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if w.commitTransactions(txs, w.miner) == false { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; // Deep copy receipts here to avoid interaction between different tasks. &nbsp;&nbsp;&nbsp;&nbsp;receipts := make([]*types.Receipt, len(w.currentCtx.receipts)) &nbsp;&nbsp;&nbsp;&nbsp;for i, l := range w.currentCtx.receipts { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;receipts[i] = new(types.Receipt) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*receipts[i] = *l &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;block := types.NewBlock(header, w.currentCtx.txs, receipts) &nbsp;&nbsp; w.taskCh &lt;- &amp;task{block: block, state: s, receipts: receipts, createdAt: time.Now()} &nbsp; &nbsp;&nbsp; &nbsp; 而在miner/worker.go里的taskLoop方法中，如果&lt;-w.taskCh有新的内容，会调用go w.seal(task, stopCh) &nbsp; &nbsp; func (w *worker) taskLoop() { &nbsp;&nbsp;&nbsp;&nbsp;var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh chan struct{} &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp;// interrupt aborts the in-flight sealing task. &nbsp;&nbsp;&nbsp;&nbsp;interrupt := func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if stopCh != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(stopCh) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh = nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case task := &lt;-w.taskCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Reject duplicate sealing work due to resubmitting. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interrupt() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh = make(chan struct{}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go w.seal(task, stopCh) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interrupt() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp; &nbsp; worker.go里的w.seal方法会执行共识算法的逻辑，执行完毕后，最后会把结果写入w.resultCh&nbsp;&nbsp; &nbsp;&nbsp; func (w *worker) seal(t *task, stop &lt;-chan struct{}) { &nbsp;&nbsp;&nbsp;&nbsp;var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err error &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res *task &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp;if t.block, err = w.engine.Execute(w.chain, t.block, stop); t.block != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//log.Info(&quot;Successfully sealed new block&quot;, &quot;number&quot;, t.block.Number(), &quot;hash&quot;, t.block.Hash(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&quot;elapsed&quot;, time.Since(t.createdAt)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = t &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Errorf(&quot;Block sealing failed,err: %v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = nil &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;case w.resultCh &lt;- res: &nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh: &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp;&nbsp; 而在waitResult的协程中，如果w.resultCh有内容，表示挖矿成功，会调用blockchain的writeBlockWithState方法写入区块链，并且发送txs和chainhead这两种事件消息。 &nbsp;&nbsp; func (w *worker) waitResult() { &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case result := &lt;-w.resultCh:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := w.chain.WriteBlockWithState(block, result.receipts, result.state) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;events = append(events, core.ChainHeadEvent{Block: block}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;events = append(events, core.NewMinedBlockEvent{Block: block}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.chain.PostChainEvents(events, logs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.engine.PostExecute(w.chain, block) &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp; &nbsp; &nbsp;&nbsp; 到这时，因为发送了chainHead事件，miner/worker.go里的mineLoop方法里w.chainHeadCh将会收到新的内容，从而又重新执行&nbsp;w.commitTask()。 &nbsp;&nbsp; 这样从rpc发送请求到txpoll再到挖矿，挖矿成功，又重新执行commitTask，commitTask将会取出txpoll的pending队列里的所有tx来打包区块，打包成功后，将又进行挖矿，如果挖矿陈工，又会重新执行committask。如此循环。 &nbsp;&nbsp; &nbsp; Pending队列里其实就是下一个可以打包成区块的所有tx。pending的存储格式为pengding[address][Transactions], 之所以这样存储，一个节点可以开多个挖矿账户。 &nbsp; &nbsp;再整体总结一下过程： &nbsp;&nbsp; 1.发送rpc请求，如果请求的方法名为eth_sendTransaction,进入api.go里的SendTransaction方法逻辑，该方法最终会完成两个事情： &nbsp; &nbsp; &nbsp; 1.1 把tx加入txpoll的pending队列 &nbsp; &nbsp; &nbsp; 1.2 发送txs事件消息 &nbsp; 2. 当挖矿成功后，worker.go里的w.seal方法会把结果写入w.resultCh中。waitReuslt协程收到会触发发送chainHead事件。 &nbsp; 3. worker.go里的mineLoop方法收到w.chainHeadCh里的chainHead事件，会执行commitTask方法。 &nbsp; 4. commitTask方法会从txpoll中取中pending[miner address]列表里的所有tx（注意这里的pending列表将会包含第一步收到的rpc交易请求）.然后调用evm执行这些tx，得到receipt收据，把这些txs，receipt和区块头打包成区块，最后把区块发送给w.taskCh. &nbsp; 5. worker.go里的taskLoop方法收到w.taskCh里的消息事件，会调用w.seal方法开始挖矿。如果挖矿成功，于是又跳回第二步。 阅读更多" />
<meta property="og:description" content="用户发送http交易请求到rpc服务，再到txpool，最后打包成区块的整个流程： 1.经过http.Server等一系列调用后，最终会进入rpc/http.go里ServeHttp方法，最后会调用ServeSingleRequest方法 &nbsp; srv.ServeSingleRequest(ctx, codec, OptionMethodInvocation) 2. rpc/server.go里的ServeSingleRequest方法&nbsp;&nbsp; &nbsp; func (s *Server) ServeSingleRequest(ctx context.Context, codec ServerCodec, options CodecOption) { &nbsp;&nbsp;&nbsp;&nbsp;s.serveRequest(ctx, codec, true, options) } 3.rpc/server.go里的serveRequest方法 &nbsp; 这个方法将会实现解码用户发来的json字符串，得到方法名和参数列表，然后调用相应的方法执行。 for atomic.LoadInt32(&amp;s.run) == 1 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reqs, batch, err := s.readRequest(codec) &nbsp;&nbsp; &nbsp; // If a single shot request is executing, run and return immediately &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if singleShot { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if batch { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.execBatch(ctx, codec, reqs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.exec(ctx, codec, reqs[0]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For multi-shot connections, start a goroutine to serve and loop back &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pend.Add(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func(reqs []*serverRequest, batch bool) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer pend.Done() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if batch { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.execBatch(ctx, codec, reqs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.exec(ctx, codec, reqs[0]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}(reqs, batch) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; 关键方法有三个：readRequest，execBatch和exec方法 &nbsp; 3.1 readRequest方法，主要实现了解码请求一条请求 &nbsp; &nbsp; 3.1.1 ReadRequestHeaders &nbsp; &nbsp; reqs, batch, err := codec.ReadRequestHeaders() &nbsp;&nbsp; rpc/json.go里的ReadRequestHeaders方法实现了根据传进来的method参数，解析出命名空间和对应的方法。 &nbsp; &nbsp; &nbsp;return parseRequest(incomingMsg) &nbsp;&nbsp; rpc/json.go里的parseRequest方法的内容：&nbsp;&nbsp; &nbsp; elems := strings.Split(in.Method, serviceMethodSeparator) &nbsp;&nbsp;&nbsp;&nbsp;if len(elems) != 2 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, false, &amp;methodNotFoundError{in.Method, &quot;&quot;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// regular RPC call &nbsp;&nbsp;&nbsp;&nbsp;if len(in.Payload) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return []rpcRequest{{service: elems[0], method: elems[1], id: &amp;in.Id}}, false, nil &nbsp;&nbsp;&nbsp;&nbsp;} return []rpcRequest{{service: elems[0], method: elems[1], id: &amp;in.Id, params: in.Payload}}, false, nil &nbsp; &nbsp; 这部分代码实现分割方法名，比如eth_getTransaction ,eth为namespace， getTransaction为方法 &nbsp;&nbsp; &nbsp; 3.1.2 ParseRequestArguments方法实现解释参数列表&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if callb, ok := svc.callbacks[r.method]; ok { // lookup RPC method &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i] = &amp;serverRequest{id: r.id, svcname: svc.name, callb: callb} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if r.params != nil &amp;&amp; len(callb.argTypes) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if args, err := codec.ParseRequestArguments(callb.argTypes, r.params); err == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i].args = args &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i].err = &amp;invalidParamsError{err.Error()} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; 3.2 execBatch方法，实现批处理执行方法 &nbsp; &nbsp;&nbsp; 3.3 exec方法，执行单个调用 &nbsp; &nbsp; &nbsp; // exec executes the given request and writes the result back using the codec. func (s *Server) exec(ctx context.Context, codec ServerCodec, req *serverRequest) { &nbsp;&nbsp;&nbsp;&nbsp;var response interface{} &nbsp;&nbsp;&nbsp;&nbsp;var callback func() &nbsp;&nbsp;&nbsp;&nbsp;if req.err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = codec.CreateErrorResponse(&amp;req.id, req.err) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response, callback = s.handle(ctx, codec, req) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if err := codec.Write(response); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Error(fmt.Sprintf(&quot;%v\n&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;codec.Close() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// when request was a subscribe request this allows these subscriptions to be actived &nbsp;&nbsp;&nbsp;&nbsp;if callback != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback() &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp;&nbsp; 最核心的是调用server的handle方法，主要实现了根据函数名和参数列表，调用该函数。核心代码为： &nbsp;&nbsp; arguments := []reflect.Value{req.callb.rcvr} &nbsp;&nbsp;&nbsp;&nbsp;if req.callb.hasCtx { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments = append(arguments, reflect.ValueOf(ctx)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(req.args) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments = append(arguments, req.args...) // execute RPC method and return result &nbsp;&nbsp;&nbsp;&nbsp;reply := req.callb.method.Func.Call(arguments) &nbsp; 4.假设调用的是eth_sendTransaction方法，将会进入api/api.go里的sendTransaction方法的逻辑。 &nbsp;&nbsp; api.go定义了所有的rpc方法，api/backend.go里的GetAPIs方法把这些rpc方法封装成4大类service， &nbsp; 分别是命名空间为eth的NewPublicTransactionPoolAPI，NewPublicBlockChainAPI，NewPublicAccountAPI &nbsp; 和命名空间为personal的NewPrivateAccountAPI。 &nbsp;&nbsp; eth的NewPublicTransactionPoolAPI 的SendTransaction方法不需要密码， &nbsp;&nbsp; &nbsp; 而personal的NewPrivateAccountAPI的SendTransaction方法需要密码去解密key。 &nbsp; &nbsp; SendTransaction方法最终会实现把交易插入txpoll的pending队列 &nbsp; 5. api/api.go里的命名空间为eth的NewPublicTransactionPoolAPI的SendTransaction方法分析： &nbsp;func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error)&nbsp; { &nbsp; return submitTransaction(ctx, s.b, signed) } &nbsp; 5.1 api.go里的submitTransaction方法的核心内容&nbsp; &nbsp;&nbsp; func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) { &nbsp;&nbsp;&nbsp;&nbsp;if err := b.SendTx(ctx, tx); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; 5.2 node/api_backend.go里的SendTx方法&nbsp;&nbsp; &nbsp; func (b *APIBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return b.kkchain.TxPool().AddLocal(signedTx) } &nbsp; 5.3 core/tx_poll.go里的AddLocal方法&nbsp; &nbsp; func (pool *TxPool) AddLocal(tx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return pool.addTx(tx, !pool.config.NoLocals) } &nbsp;5.4 core/tx_poll.go里的addTx方法&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; func (pool *TxPool) addTx(tx *types.Transaction, local bool) error&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;// Try to inject the transaction and update any state &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.add(tx, local) &nbsp;&nbsp;&nbsp;&nbsp;// If we added a new transaction, run promotion checks and return &nbsp;&nbsp;&nbsp;&nbsp;if !replace { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.promoteExecutables([]common.Address{from}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return nil } &nbsp; &nbsp; addTx方法里核心方法有两个一个是pool.add 方法，一个pool.promoteExecutables方法。add方法如果是替换pending队列里的tx的情况，则会直接替换pengding里的tx。 &nbsp;&nbsp; 而 pool.promoteExecutables实现了把普通队列的tx加入到txpoll的pending队列去。 &nbsp; &nbsp; tx_poll.go的add方法：&nbsp; &nbsp; &nbsp; // If the transaction fails basic validation, discard it &nbsp;&nbsp;&nbsp;&nbsp;if err := pool.validateTx(tx, local); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.WithFields(log.Fields{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;hash&quot;: hash.String(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;err&quot;:&nbsp; err, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).Error(&quot;Discarding invalid transaction&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err &nbsp;&nbsp;&nbsp;&nbsp;} // New transaction isn&#39;t replacing a pending one, push into queue &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.enqueueTx(hash, tx) &nbsp;&nbsp; 其中validateTx方法会做签名和是否超过gaslimit的检查 &nbsp; 5.5 core/tx_poll.go里的pool.promoteExecutables方法，这个方法每次执行都会按顺序尝试删掉以下的逻辑： &nbsp; &nbsp; 删除时间太久的tx，删除账户余额不足或者超过gas的tx，把剩下的tx加入到pending列表。 &nbsp;&nbsp; &nbsp; // Iterate over all accounts and promote any executable transactions &nbsp;&nbsp;&nbsp;&nbsp;for _, addr := range accounts { // Gather all executable transactions and promote them &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash := tx.Hash() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if pool.promoteTx(addr, hash, tx) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Debugf(&quot;Promoting queued transaction,hash: %s&quot;, hash.String()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promoted = append(promoted, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; } &nbsp; // Notify subsystem for new promoted transactions. &nbsp;&nbsp;&nbsp;&nbsp;if len(promoted) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(NewTxsEvent{promoted}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 如果pending的队列大于0，发送tx事件到txFeed中。 &nbsp; 5.6 pool.promoteTx 方法实现把tx加入到txpoll的pending队列去。 &nbsp; &nbsp;&nbsp; func (pool *TxPool) promoteTx(addr common.Address, hash common.Hash, tx *types.Transaction) bool { &nbsp;&nbsp;&nbsp;&nbsp;// Try to insert the transaction into the pending queue &nbsp;&nbsp;&nbsp;&nbsp;if pool.pending[addr] == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.pending[addr] = newTxList(true) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;list := pool.pending[addr] &nbsp;&nbsp;&nbsp;&nbsp;inserted, old := list.Add(tx, pool.config.PriceBump) &nbsp; &nbsp; if !inserted { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// An older transaction was better, discard this &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Remove(hash) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Otherwise discard any previous transaction and mark this &nbsp;&nbsp;&nbsp;&nbsp;if old != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Remove(old.Hash()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Failsafe to work around direct pending inserts (tests) &nbsp;&nbsp;&nbsp;&nbsp;if pool.all.Get(hash) == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Add(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Put(tx) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Set the potentially new pending nonce and notify any subsystems of the new tx &nbsp;&nbsp;&nbsp;&nbsp;pool.beats[addr] = time.Now() &nbsp;&nbsp;&nbsp;&nbsp;pool.pendingState.SetNonce(addr, tx.Nonce()+1) &nbsp;&nbsp;&nbsp;&nbsp;return true &nbsp;&nbsp; &nbsp; &nbsp; 调用core/tx_list.go的Add方法时，如果当前收集的tx在pending队列已经存在，并且老的tx比新的tx的gasprice更大，则新的tx不会再插入到pending列表中去。 &nbsp; &nbsp; &nbsp; 6.txpoll里的tx的处理逻辑： &nbsp; 插入区块分两种情况: &nbsp; 情况1:挖矿的全节点，从txpoll中取出tx进行打包。&nbsp; &nbsp; 情况2:收到别的成功挖矿区块，验证通过后，插入区块 &nbsp;这里讲的是第一种 &nbsp; &nbsp; 6.1 在node/node.go的New方法里&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; node.txPool = core.NewTxPool(txConfig, chainConfig, node.blockchain) &nbsp;node.miner = miner.New(chainConfig, node.blockchain, node.txPool, node.engine) &nbsp;&nbsp; 其中core/tx_poll.go里的NewTxPool方法最终会调用 pool.loop方法 &nbsp; &nbsp; go pool.loop() &nbsp;&nbsp; 其中miner/miner.go里的miner.New方法构建worker实例和会调用miner.onEvent方法 miner := &amp;Miner{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quitCh:&nbsp; &nbsp; &nbsp; make(chan struct{}), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncStartCh: make(chan core.StartEvent), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncDoneCh:&nbsp; make(chan core.DoneEvent), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker:&nbsp; &nbsp; &nbsp; newWorker(config, bc, txpool, engine), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain: &nbsp; &nbsp; &nbsp; bc, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncDone:&nbsp; &nbsp; 1, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;go miner.onEvent() &nbsp; &nbsp; &nbsp; 其中miner/worker.go 里的newWorker方法会订阅txs和chain head事件，并且开启三个协程。 &nbsp;&nbsp; // Subscribe events from tx pool &nbsp;&nbsp;&nbsp;&nbsp;w.txsSub = txpool.SubscribeNewTxsEvent(w.txsCh) &nbsp;&nbsp;&nbsp;&nbsp;// Subscribe events from inbound handler &nbsp;&nbsp;&nbsp;&nbsp;w.chainHeadSub = bc.SubscribeChainHeadEvent(w.chainHeadCh) &nbsp;&nbsp;&nbsp;&nbsp;go w.mineLoop() &nbsp;&nbsp;&nbsp;&nbsp;go w.taskLoop() &nbsp;&nbsp;&nbsp;&nbsp;go w.waitResult() &nbsp;&nbsp;&nbsp;&nbsp;// Submit first work to initialize pending state. &nbsp;&nbsp;&nbsp;&nbsp;w.startCh &lt;- struct{}{} &nbsp;&nbsp;&nbsp;&nbsp;return w &nbsp;&nbsp; miner/worker.go里的mineLoop方法的内容为： &nbsp; &nbsp; func (w *worker) mineLoop() { &nbsp;&nbsp;&nbsp;&nbsp;defer w.txsSub.Unsubscribe() &nbsp;&nbsp;&nbsp;&nbsp;defer w.chainHeadSub.Unsubscribe() &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case txs := &lt;-w.txsCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range txs.Txs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.chainHeadCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if w.isRunning() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.commitTask() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.startCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.commitTask() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Stopped Mining &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp; &nbsp;到这里，就能把rpc发送的sendTransaction请求和txpoll连起来了。因为api/api.go里的SendTransaction方法，如果没问题的话，最终会调用core/tx_poll.go里的pool.promoteExecutables方法，然后在方法里会执行 &nbsp;go pool.txFeed.Send(NewTxsEvent{promoted}。当发送Txs的事件消息给txFeed时，所有订阅了txs事件消息的channel都能收到。这时就会触发mineLoop方法里的case txs:=&lt;-w.txsCh，但是为什么这里只是打印出来而已呢？ &nbsp;&nbsp; &nbsp; 因为core/tx_poll.go里的pool.promoteExecutables方法里会调用pool.promoteTx(addr, hash, tx)时，已经把tx加入到pending队列。后面只需要调用commitTask，就能实现把txpoll中的pending队列里的tx进行打包。 &nbsp; &nbsp;6.2 commitTask分析： &nbsp;&nbsp; 在最初的启动时候会调用一次w.commitTask()，commitTask会从txpoll中取出pending队列的tx打包成区块，最终会把打包的区块写入w.taskCh&nbsp; &nbsp; &nbsp; func (w *worker) commitTask() { &nbsp; //get txs from pending pool &nbsp;&nbsp;&nbsp;&nbsp;pending, count, _ := w.txpool.Pending() &nbsp;&nbsp;&nbsp;&nbsp;txs := make(types.Transactions, 0, count) &nbsp;&nbsp;&nbsp;&nbsp;for _, acctxs := range pending { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range acctxs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txs = append(txs, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(txs) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//apply txs and get block &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if w.commitTransactions(txs, w.miner) == false { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; // Deep copy receipts here to avoid interaction between different tasks. &nbsp;&nbsp;&nbsp;&nbsp;receipts := make([]*types.Receipt, len(w.currentCtx.receipts)) &nbsp;&nbsp;&nbsp;&nbsp;for i, l := range w.currentCtx.receipts { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;receipts[i] = new(types.Receipt) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*receipts[i] = *l &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;block := types.NewBlock(header, w.currentCtx.txs, receipts) &nbsp;&nbsp; w.taskCh &lt;- &amp;task{block: block, state: s, receipts: receipts, createdAt: time.Now()} &nbsp; &nbsp;&nbsp; &nbsp; 而在miner/worker.go里的taskLoop方法中，如果&lt;-w.taskCh有新的内容，会调用go w.seal(task, stopCh) &nbsp; &nbsp; func (w *worker) taskLoop() { &nbsp;&nbsp;&nbsp;&nbsp;var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh chan struct{} &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp;// interrupt aborts the in-flight sealing task. &nbsp;&nbsp;&nbsp;&nbsp;interrupt := func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if stopCh != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(stopCh) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh = nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case task := &lt;-w.taskCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Reject duplicate sealing work due to resubmitting. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interrupt() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh = make(chan struct{}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go w.seal(task, stopCh) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interrupt() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp; &nbsp; worker.go里的w.seal方法会执行共识算法的逻辑，执行完毕后，最后会把结果写入w.resultCh&nbsp;&nbsp; &nbsp;&nbsp; func (w *worker) seal(t *task, stop &lt;-chan struct{}) { &nbsp;&nbsp;&nbsp;&nbsp;var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err error &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res *task &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp;if t.block, err = w.engine.Execute(w.chain, t.block, stop); t.block != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//log.Info(&quot;Successfully sealed new block&quot;, &quot;number&quot;, t.block.Number(), &quot;hash&quot;, t.block.Hash(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&quot;elapsed&quot;, time.Since(t.createdAt)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = t &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Errorf(&quot;Block sealing failed,err: %v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = nil &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;case w.resultCh &lt;- res: &nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh: &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp;&nbsp; 而在waitResult的协程中，如果w.resultCh有内容，表示挖矿成功，会调用blockchain的writeBlockWithState方法写入区块链，并且发送txs和chainhead这两种事件消息。 &nbsp;&nbsp; func (w *worker) waitResult() { &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case result := &lt;-w.resultCh:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := w.chain.WriteBlockWithState(block, result.receipts, result.state) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;events = append(events, core.ChainHeadEvent{Block: block}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;events = append(events, core.NewMinedBlockEvent{Block: block}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.chain.PostChainEvents(events, logs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.engine.PostExecute(w.chain, block) &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp; &nbsp; &nbsp;&nbsp; 到这时，因为发送了chainHead事件，miner/worker.go里的mineLoop方法里w.chainHeadCh将会收到新的内容，从而又重新执行&nbsp;w.commitTask()。 &nbsp;&nbsp; 这样从rpc发送请求到txpoll再到挖矿，挖矿成功，又重新执行commitTask，commitTask将会取出txpoll的pending队列里的所有tx来打包区块，打包成功后，将又进行挖矿，如果挖矿陈工，又会重新执行committask。如此循环。 &nbsp;&nbsp; &nbsp; Pending队列里其实就是下一个可以打包成区块的所有tx。pending的存储格式为pengding[address][Transactions], 之所以这样存储，一个节点可以开多个挖矿账户。 &nbsp; &nbsp;再整体总结一下过程： &nbsp;&nbsp; 1.发送rpc请求，如果请求的方法名为eth_sendTransaction,进入api.go里的SendTransaction方法逻辑，该方法最终会完成两个事情： &nbsp; &nbsp; &nbsp; 1.1 把tx加入txpoll的pending队列 &nbsp; &nbsp; &nbsp; 1.2 发送txs事件消息 &nbsp; 2. 当挖矿成功后，worker.go里的w.seal方法会把结果写入w.resultCh中。waitReuslt协程收到会触发发送chainHead事件。 &nbsp; 3. worker.go里的mineLoop方法收到w.chainHeadCh里的chainHead事件，会执行commitTask方法。 &nbsp; 4. commitTask方法会从txpoll中取中pending[miner address]列表里的所有tx（注意这里的pending列表将会包含第一步收到的rpc交易请求）.然后调用evm执行这些tx，得到receipt收据，把这些txs，receipt和区块头打包成区块，最后把区块发送给w.taskCh. &nbsp; 5. worker.go里的taskLoop方法收到w.taskCh里的消息事件，会调用w.seal方法开始挖矿。如果挖矿成功，于是又跳回第二步。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-10-30T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"用户发送http交易请求到rpc服务，再到txpool，最后打包成区块的整个流程： 1.经过http.Server等一系列调用后，最终会进入rpc/http.go里ServeHttp方法，最后会调用ServeSingleRequest方法 &nbsp; srv.ServeSingleRequest(ctx, codec, OptionMethodInvocation) 2. rpc/server.go里的ServeSingleRequest方法&nbsp;&nbsp; &nbsp; func (s *Server) ServeSingleRequest(ctx context.Context, codec ServerCodec, options CodecOption) { &nbsp;&nbsp;&nbsp;&nbsp;s.serveRequest(ctx, codec, true, options) } 3.rpc/server.go里的serveRequest方法 &nbsp; 这个方法将会实现解码用户发来的json字符串，得到方法名和参数列表，然后调用相应的方法执行。 for atomic.LoadInt32(&amp;s.run) == 1 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reqs, batch, err := s.readRequest(codec) &nbsp;&nbsp; &nbsp; // If a single shot request is executing, run and return immediately &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if singleShot { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if batch { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.execBatch(ctx, codec, reqs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.exec(ctx, codec, reqs[0]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For multi-shot connections, start a goroutine to serve and loop back &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pend.Add(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func(reqs []*serverRequest, batch bool) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer pend.Done() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if batch { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.execBatch(ctx, codec, reqs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.exec(ctx, codec, reqs[0]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}(reqs, batch) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; 关键方法有三个：readRequest，execBatch和exec方法 &nbsp; 3.1 readRequest方法，主要实现了解码请求一条请求 &nbsp; &nbsp; 3.1.1 ReadRequestHeaders &nbsp; &nbsp; reqs, batch, err := codec.ReadRequestHeaders() &nbsp;&nbsp; rpc/json.go里的ReadRequestHeaders方法实现了根据传进来的method参数，解析出命名空间和对应的方法。 &nbsp; &nbsp; &nbsp;return parseRequest(incomingMsg) &nbsp;&nbsp; rpc/json.go里的parseRequest方法的内容：&nbsp;&nbsp; &nbsp; elems := strings.Split(in.Method, serviceMethodSeparator) &nbsp;&nbsp;&nbsp;&nbsp;if len(elems) != 2 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, false, &amp;methodNotFoundError{in.Method, &quot;&quot;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// regular RPC call &nbsp;&nbsp;&nbsp;&nbsp;if len(in.Payload) == 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return []rpcRequest{{service: elems[0], method: elems[1], id: &amp;in.Id}}, false, nil &nbsp;&nbsp;&nbsp;&nbsp;} return []rpcRequest{{service: elems[0], method: elems[1], id: &amp;in.Id, params: in.Payload}}, false, nil &nbsp; &nbsp; 这部分代码实现分割方法名，比如eth_getTransaction ,eth为namespace， getTransaction为方法 &nbsp;&nbsp; &nbsp; 3.1.2 ParseRequestArguments方法实现解释参数列表&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if callb, ok := svc.callbacks[r.method]; ok { // lookup RPC method &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i] = &amp;serverRequest{id: r.id, svcname: svc.name, callb: callb} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if r.params != nil &amp;&amp; len(callb.argTypes) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if args, err := codec.ParseRequestArguments(callb.argTypes, r.params); err == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i].args = args &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i].err = &amp;invalidParamsError{err.Error()} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; 3.2 execBatch方法，实现批处理执行方法 &nbsp; &nbsp;&nbsp; 3.3 exec方法，执行单个调用 &nbsp; &nbsp; &nbsp; // exec executes the given request and writes the result back using the codec. func (s *Server) exec(ctx context.Context, codec ServerCodec, req *serverRequest) { &nbsp;&nbsp;&nbsp;&nbsp;var response interface{} &nbsp;&nbsp;&nbsp;&nbsp;var callback func() &nbsp;&nbsp;&nbsp;&nbsp;if req.err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = codec.CreateErrorResponse(&amp;req.id, req.err) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response, callback = s.handle(ctx, codec, req) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if err := codec.Write(response); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Error(fmt.Sprintf(&quot;%v\\n&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;codec.Close() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// when request was a subscribe request this allows these subscriptions to be actived &nbsp;&nbsp;&nbsp;&nbsp;if callback != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback() &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp;&nbsp; 最核心的是调用server的handle方法，主要实现了根据函数名和参数列表，调用该函数。核心代码为： &nbsp;&nbsp; arguments := []reflect.Value{req.callb.rcvr} &nbsp;&nbsp;&nbsp;&nbsp;if req.callb.hasCtx { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments = append(arguments, reflect.ValueOf(ctx)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(req.args) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments = append(arguments, req.args...) // execute RPC method and return result &nbsp;&nbsp;&nbsp;&nbsp;reply := req.callb.method.Func.Call(arguments) &nbsp; 4.假设调用的是eth_sendTransaction方法，将会进入api/api.go里的sendTransaction方法的逻辑。 &nbsp;&nbsp; api.go定义了所有的rpc方法，api/backend.go里的GetAPIs方法把这些rpc方法封装成4大类service， &nbsp; 分别是命名空间为eth的NewPublicTransactionPoolAPI，NewPublicBlockChainAPI，NewPublicAccountAPI &nbsp; 和命名空间为personal的NewPrivateAccountAPI。 &nbsp;&nbsp; eth的NewPublicTransactionPoolAPI 的SendTransaction方法不需要密码， &nbsp;&nbsp; &nbsp; 而personal的NewPrivateAccountAPI的SendTransaction方法需要密码去解密key。 &nbsp; &nbsp; SendTransaction方法最终会实现把交易插入txpoll的pending队列 &nbsp; 5. api/api.go里的命名空间为eth的NewPublicTransactionPoolAPI的SendTransaction方法分析： &nbsp;func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error)&nbsp; { &nbsp; return submitTransaction(ctx, s.b, signed) } &nbsp; 5.1 api.go里的submitTransaction方法的核心内容&nbsp; &nbsp;&nbsp; func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) { &nbsp;&nbsp;&nbsp;&nbsp;if err := b.SendTx(ctx, tx); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; 5.2 node/api_backend.go里的SendTx方法&nbsp;&nbsp; &nbsp; func (b *APIBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return b.kkchain.TxPool().AddLocal(signedTx) } &nbsp; 5.3 core/tx_poll.go里的AddLocal方法&nbsp; &nbsp; func (pool *TxPool) AddLocal(tx *types.Transaction) error { &nbsp;&nbsp;&nbsp;&nbsp;return pool.addTx(tx, !pool.config.NoLocals) } &nbsp;5.4 core/tx_poll.go里的addTx方法&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; func (pool *TxPool) addTx(tx *types.Transaction, local bool) error&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;// Try to inject the transaction and update any state &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.add(tx, local) &nbsp;&nbsp;&nbsp;&nbsp;// If we added a new transaction, run promotion checks and return &nbsp;&nbsp;&nbsp;&nbsp;if !replace { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.promoteExecutables([]common.Address{from}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return nil } &nbsp; &nbsp; addTx方法里核心方法有两个一个是pool.add 方法，一个pool.promoteExecutables方法。add方法如果是替换pending队列里的tx的情况，则会直接替换pengding里的tx。 &nbsp;&nbsp; 而 pool.promoteExecutables实现了把普通队列的tx加入到txpoll的pending队列去。 &nbsp; &nbsp; tx_poll.go的add方法：&nbsp; &nbsp; &nbsp; // If the transaction fails basic validation, discard it &nbsp;&nbsp;&nbsp;&nbsp;if err := pool.validateTx(tx, local); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.WithFields(log.Fields{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;hash&quot;: hash.String(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;err&quot;:&nbsp; err, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).Error(&quot;Discarding invalid transaction&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err &nbsp;&nbsp;&nbsp;&nbsp;} // New transaction isn&#39;t replacing a pending one, push into queue &nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.enqueueTx(hash, tx) &nbsp;&nbsp; 其中validateTx方法会做签名和是否超过gaslimit的检查 &nbsp; 5.5 core/tx_poll.go里的pool.promoteExecutables方法，这个方法每次执行都会按顺序尝试删掉以下的逻辑： &nbsp; &nbsp; 删除时间太久的tx，删除账户余额不足或者超过gas的tx，把剩下的tx加入到pending列表。 &nbsp;&nbsp; &nbsp; // Iterate over all accounts and promote any executable transactions &nbsp;&nbsp;&nbsp;&nbsp;for _, addr := range accounts { // Gather all executable transactions and promote them &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash := tx.Hash() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if pool.promoteTx(addr, hash, tx) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Debugf(&quot;Promoting queued transaction,hash: %s&quot;, hash.String()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promoted = append(promoted, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; } &nbsp; // Notify subsystem for new promoted transactions. &nbsp;&nbsp;&nbsp;&nbsp;if len(promoted) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(NewTxsEvent{promoted}) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; 如果pending的队列大于0，发送tx事件到txFeed中。 &nbsp; 5.6 pool.promoteTx 方法实现把tx加入到txpoll的pending队列去。 &nbsp; &nbsp;&nbsp; func (pool *TxPool) promoteTx(addr common.Address, hash common.Hash, tx *types.Transaction) bool { &nbsp;&nbsp;&nbsp;&nbsp;// Try to insert the transaction into the pending queue &nbsp;&nbsp;&nbsp;&nbsp;if pool.pending[addr] == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.pending[addr] = newTxList(true) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;list := pool.pending[addr] &nbsp;&nbsp;&nbsp;&nbsp;inserted, old := list.Add(tx, pool.config.PriceBump) &nbsp; &nbsp; if !inserted { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// An older transaction was better, discard this &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Remove(hash) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Otherwise discard any previous transaction and mark this &nbsp;&nbsp;&nbsp;&nbsp;if old != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Remove(old.Hash()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Failsafe to work around direct pending inserts (tests) &nbsp;&nbsp;&nbsp;&nbsp;if pool.all.Get(hash) == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Add(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Put(tx) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// Set the potentially new pending nonce and notify any subsystems of the new tx &nbsp;&nbsp;&nbsp;&nbsp;pool.beats[addr] = time.Now() &nbsp;&nbsp;&nbsp;&nbsp;pool.pendingState.SetNonce(addr, tx.Nonce()+1) &nbsp;&nbsp;&nbsp;&nbsp;return true &nbsp;&nbsp; &nbsp; &nbsp; 调用core/tx_list.go的Add方法时，如果当前收集的tx在pending队列已经存在，并且老的tx比新的tx的gasprice更大，则新的tx不会再插入到pending列表中去。 &nbsp; &nbsp; &nbsp; 6.txpoll里的tx的处理逻辑： &nbsp; 插入区块分两种情况: &nbsp; 情况1:挖矿的全节点，从txpoll中取出tx进行打包。&nbsp; &nbsp; 情况2:收到别的成功挖矿区块，验证通过后，插入区块 &nbsp;这里讲的是第一种 &nbsp; &nbsp; 6.1 在node/node.go的New方法里&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; node.txPool = core.NewTxPool(txConfig, chainConfig, node.blockchain) &nbsp;node.miner = miner.New(chainConfig, node.blockchain, node.txPool, node.engine) &nbsp;&nbsp; 其中core/tx_poll.go里的NewTxPool方法最终会调用 pool.loop方法 &nbsp; &nbsp; go pool.loop() &nbsp;&nbsp; 其中miner/miner.go里的miner.New方法构建worker实例和会调用miner.onEvent方法 miner := &amp;Miner{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quitCh:&nbsp; &nbsp; &nbsp; make(chan struct{}), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncStartCh: make(chan core.StartEvent), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncDoneCh:&nbsp; make(chan core.DoneEvent), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker:&nbsp; &nbsp; &nbsp; newWorker(config, bc, txpool, engine), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain: &nbsp; &nbsp; &nbsp; bc, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncDone:&nbsp; &nbsp; 1, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;go miner.onEvent() &nbsp; &nbsp; &nbsp; 其中miner/worker.go 里的newWorker方法会订阅txs和chain head事件，并且开启三个协程。 &nbsp;&nbsp; // Subscribe events from tx pool &nbsp;&nbsp;&nbsp;&nbsp;w.txsSub = txpool.SubscribeNewTxsEvent(w.txsCh) &nbsp;&nbsp;&nbsp;&nbsp;// Subscribe events from inbound handler &nbsp;&nbsp;&nbsp;&nbsp;w.chainHeadSub = bc.SubscribeChainHeadEvent(w.chainHeadCh) &nbsp;&nbsp;&nbsp;&nbsp;go w.mineLoop() &nbsp;&nbsp;&nbsp;&nbsp;go w.taskLoop() &nbsp;&nbsp;&nbsp;&nbsp;go w.waitResult() &nbsp;&nbsp;&nbsp;&nbsp;// Submit first work to initialize pending state. &nbsp;&nbsp;&nbsp;&nbsp;w.startCh &lt;- struct{}{} &nbsp;&nbsp;&nbsp;&nbsp;return w &nbsp;&nbsp; miner/worker.go里的mineLoop方法的内容为： &nbsp; &nbsp; func (w *worker) mineLoop() { &nbsp;&nbsp;&nbsp;&nbsp;defer w.txsSub.Unsubscribe() &nbsp;&nbsp;&nbsp;&nbsp;defer w.chainHeadSub.Unsubscribe() &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case txs := &lt;-w.txsCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range txs.Txs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.chainHeadCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if w.isRunning() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.commitTask() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.startCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.commitTask() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Stopped Mining &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp; &nbsp;到这里，就能把rpc发送的sendTransaction请求和txpoll连起来了。因为api/api.go里的SendTransaction方法，如果没问题的话，最终会调用core/tx_poll.go里的pool.promoteExecutables方法，然后在方法里会执行 &nbsp;go pool.txFeed.Send(NewTxsEvent{promoted}。当发送Txs的事件消息给txFeed时，所有订阅了txs事件消息的channel都能收到。这时就会触发mineLoop方法里的case txs:=&lt;-w.txsCh，但是为什么这里只是打印出来而已呢？ &nbsp;&nbsp; &nbsp; 因为core/tx_poll.go里的pool.promoteExecutables方法里会调用pool.promoteTx(addr, hash, tx)时，已经把tx加入到pending队列。后面只需要调用commitTask，就能实现把txpoll中的pending队列里的tx进行打包。 &nbsp; &nbsp;6.2 commitTask分析： &nbsp;&nbsp; 在最初的启动时候会调用一次w.commitTask()，commitTask会从txpoll中取出pending队列的tx打包成区块，最终会把打包的区块写入w.taskCh&nbsp; &nbsp; &nbsp; func (w *worker) commitTask() { &nbsp; //get txs from pending pool &nbsp;&nbsp;&nbsp;&nbsp;pending, count, _ := w.txpool.Pending() &nbsp;&nbsp;&nbsp;&nbsp;txs := make(types.Transactions, 0, count) &nbsp;&nbsp;&nbsp;&nbsp;for _, acctxs := range pending { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range acctxs { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txs = append(txs, tx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if len(txs) &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//apply txs and get block &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if w.commitTransactions(txs, w.miner) == false { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp; // Deep copy receipts here to avoid interaction between different tasks. &nbsp;&nbsp;&nbsp;&nbsp;receipts := make([]*types.Receipt, len(w.currentCtx.receipts)) &nbsp;&nbsp;&nbsp;&nbsp;for i, l := range w.currentCtx.receipts { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;receipts[i] = new(types.Receipt) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*receipts[i] = *l &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;block := types.NewBlock(header, w.currentCtx.txs, receipts) &nbsp;&nbsp; w.taskCh &lt;- &amp;task{block: block, state: s, receipts: receipts, createdAt: time.Now()} &nbsp; &nbsp;&nbsp; &nbsp; 而在miner/worker.go里的taskLoop方法中，如果&lt;-w.taskCh有新的内容，会调用go w.seal(task, stopCh) &nbsp; &nbsp; func (w *worker) taskLoop() { &nbsp;&nbsp;&nbsp;&nbsp;var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh chan struct{} &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp;// interrupt aborts the in-flight sealing task. &nbsp;&nbsp;&nbsp;&nbsp;interrupt := func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if stopCh != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(stopCh) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh = nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case task := &lt;-w.taskCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Reject duplicate sealing work due to resubmitting. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interrupt() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh = make(chan struct{}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go w.seal(task, stopCh) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interrupt() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp; &nbsp; worker.go里的w.seal方法会执行共识算法的逻辑，执行完毕后，最后会把结果写入w.resultCh&nbsp;&nbsp; &nbsp;&nbsp; func (w *worker) seal(t *task, stop &lt;-chan struct{}) { &nbsp;&nbsp;&nbsp;&nbsp;var ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err error &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res *task &nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp;if t.block, err = w.engine.Execute(w.chain, t.block, stop); t.block != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//log.Info(&quot;Successfully sealed new block&quot;, &quot;number&quot;, t.block.Number(), &quot;hash&quot;, t.block.Hash(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&quot;elapsed&quot;, time.Since(t.createdAt)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = t &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Errorf(&quot;Block sealing failed,err: %v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = nil &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;case w.resultCh &lt;- res: &nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh: &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp;&nbsp; 而在waitResult的协程中，如果w.resultCh有内容，表示挖矿成功，会调用blockchain的writeBlockWithState方法写入区块链，并且发送txs和chainhead这两种事件消息。 &nbsp;&nbsp; func (w *worker) waitResult() { &nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case result := &lt;-w.resultCh:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := w.chain.WriteBlockWithState(block, result.receipts, result.state) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;events = append(events, core.ChainHeadEvent{Block: block}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;events = append(events, core.NewMinedBlockEvent{Block: block}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.chain.PostChainEvents(events, logs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.engine.PostExecute(w.chain, block) &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp; &nbsp; &nbsp;&nbsp; 到这时，因为发送了chainHead事件，miner/worker.go里的mineLoop方法里w.chainHeadCh将会收到新的内容，从而又重新执行&nbsp;w.commitTask()。 &nbsp;&nbsp; 这样从rpc发送请求到txpoll再到挖矿，挖矿成功，又重新执行commitTask，commitTask将会取出txpoll的pending队列里的所有tx来打包区块，打包成功后，将又进行挖矿，如果挖矿陈工，又会重新执行committask。如此循环。 &nbsp;&nbsp; &nbsp; Pending队列里其实就是下一个可以打包成区块的所有tx。pending的存储格式为pengding[address][Transactions], 之所以这样存储，一个节点可以开多个挖矿账户。 &nbsp; &nbsp;再整体总结一下过程： &nbsp;&nbsp; 1.发送rpc请求，如果请求的方法名为eth_sendTransaction,进入api.go里的SendTransaction方法逻辑，该方法最终会完成两个事情： &nbsp; &nbsp; &nbsp; 1.1 把tx加入txpoll的pending队列 &nbsp; &nbsp; &nbsp; 1.2 发送txs事件消息 &nbsp; 2. 当挖矿成功后，worker.go里的w.seal方法会把结果写入w.resultCh中。waitReuslt协程收到会触发发送chainHead事件。 &nbsp; 3. worker.go里的mineLoop方法收到w.chainHeadCh里的chainHead事件，会执行commitTask方法。 &nbsp; 4. commitTask方法会从txpoll中取中pending[miner address]列表里的所有tx（注意这里的pending列表将会包含第一步收到的rpc交易请求）.然后调用evm执行这些tx，得到receipt收据，把这些txs，receipt和区块头打包成区块，最后把区块发送给w.taskCh. &nbsp; 5. worker.go里的taskLoop方法收到w.taskCh里的消息事件，会调用w.seal方法开始挖矿。如果挖矿成功，于是又跳回第二步。 阅读更多","@type":"BlogPosting","url":"/2018/10/30/8389d49637d3ef5c7e67d8a07929f0df.html","headline":"用户发送http交易请求到rpc服务，tx写入txpool中的pending队列，最后打包成区块的整个流程","dateModified":"2018-10-30T00:00:00+08:00","datePublished":"2018-10-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/10/30/8389d49637d3ef5c7e67d8a07929f0df.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>用户发送http交易请求到rpc服务，tx写入txpool中的pending队列，最后打包成区块的整个流程</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-2c6a5211c9.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h2><strong>用户发送http交易请求到rpc服务，再到txpool，最后打包成区块的整个流程：</strong></h2> 
  <p>1.经过http.Server等一系列调用后，最终会进入rpc/http.go里ServeHttp方法，最后会调用ServeSingleRequest方法</p> 
  <pre class="has">
<code class="language-Go">&nbsp; srv.ServeSingleRequest(ctx, codec, OptionMethodInvocation)</code></pre> 
  <p>2. rpc/server.go里的ServeSingleRequest方法&nbsp;&nbsp;</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-Go"> func (s *Server) ServeSingleRequest(ctx context.Context, codec ServerCodec, options CodecOption) {

&nbsp;&nbsp;&nbsp;&nbsp;s.serveRequest(ctx, codec, true, options)

}</code></pre> 
  <p>3.rpc/server.go里的serveRequest方法</p> 
  <p>&nbsp; 这个方法将会实现解码用户发来的json字符串，得到方法名和参数列表，然后调用相应的方法执行。</p> 
  <pre class="has">
<code class="language-Go">for atomic.LoadInt32(&amp;s.run) == 1 {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reqs, batch, err := s.readRequest(codec)

&nbsp;&nbsp; &nbsp; // If a single shot request is executing, run and return immediately

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if singleShot {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if batch {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.execBatch(ctx, codec, reqs)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.exec(ctx, codec, reqs[0])

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For multi-shot connections, start a goroutine to serve and loop back

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pend.Add(1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func(reqs []*serverRequest, batch bool) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer pend.Done()

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if batch {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.execBatch(ctx, codec, reqs)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.exec(ctx, codec, reqs[0])

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}(reqs, batch)

&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre> 
  <p>&nbsp;&nbsp; 关键方法有三个：readRequest，execBatch和exec方法</p> 
  <p>&nbsp; 3.1 readRequest方法，主要实现了解码请求一条请求</p> 
  <p>&nbsp; &nbsp; 3.1.1 ReadRequestHeaders</p> 
  <p>&nbsp; &nbsp;</p> 
  <pre class="has">
<code class="language-Go"> reqs, batch, err := codec.ReadRequestHeaders()</code></pre> 
  <p>&nbsp;&nbsp; rpc/json.go里的ReadRequestHeaders方法实现了根据传进来的method参数，解析出命名空间和对应的方法。</p> 
  <p>&nbsp; &nbsp;</p> 
  <pre class="has">
<code class="language-Go"> &nbsp;return parseRequest(incomingMsg)</code></pre> 
  <p>&nbsp;&nbsp; rpc/json.go里的parseRequest方法的内容：&nbsp;&nbsp;</p> 
  <pre class="has">
<code class="language-Go">&nbsp; elems := strings.Split(in.Method, serviceMethodSeparator)

&nbsp;&nbsp;&nbsp;&nbsp;if len(elems) != 2 {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil, false, &amp;methodNotFoundError{in.Method, ""}

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// regular RPC call

&nbsp;&nbsp;&nbsp;&nbsp;if len(in.Payload) == 0 {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return []rpcRequest{{service: elems[0], method: elems[1], id: &amp;in.Id}}, false, nil

&nbsp;&nbsp;&nbsp;&nbsp;}

return []rpcRequest{{service: elems[0], method: elems[1], id: &amp;in.Id, params: in.Payload}}, false, nil

</code></pre> 
  <p>&nbsp; &nbsp; 这部分代码实现分割方法名，比如eth_getTransaction ,eth为namespace， getTransaction为方法</p> 
  <p>&nbsp;&nbsp; &nbsp; 3.1.2 ParseRequestArguments方法实现解释参数列表&nbsp; &nbsp;</p> 
  <p>&nbsp; &nbsp;&nbsp;</p> 
  <pre class="has">
<code class="language-Go"> if callb, ok := svc.callbacks[r.method]; ok { // lookup RPC method

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i] = &amp;serverRequest{id: r.id, svcname: svc.name, callb: callb}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if r.params != nil &amp;&amp; len(callb.argTypes) &gt; 0 {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if args, err := codec.ParseRequestArguments(callb.argTypes, r.params); err == nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i].args = args

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requests[i].err = &amp;invalidParamsError{err.Error()}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}



</code></pre> 
  <p>&nbsp;&nbsp; 3.2 execBatch方法，实现批处理执行方法</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;&nbsp; 3.3 exec方法，执行单个调用</p> 
  <p>&nbsp; &nbsp;</p> 
  <pre class="has">
<code class="language-Go">&nbsp; // exec executes the given request and writes the result back using the codec.

func (s *Server) exec(ctx context.Context, codec ServerCodec, req *serverRequest) {

&nbsp;&nbsp;&nbsp;&nbsp;var response interface{}

&nbsp;&nbsp;&nbsp;&nbsp;var callback func()

&nbsp;&nbsp;&nbsp;&nbsp;if req.err != nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = codec.CreateErrorResponse(&amp;req.id, req.err)

&nbsp;&nbsp;&nbsp;&nbsp;} else {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response, callback = s.handle(ctx, codec, req)

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;if err := codec.Write(response); err != nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Error(fmt.Sprintf("%v\n", err))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;codec.Close()

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// when request was a subscribe request this allows these subscriptions to be actived

&nbsp;&nbsp;&nbsp;&nbsp;if callback != nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback()

&nbsp;&nbsp;&nbsp;&nbsp;}

}</code></pre> 
  <p>&nbsp;&nbsp; 最核心的是调用server的handle方法，主要实现了根据函数名和参数列表，调用该函数。核心代码为：</p> 
  <p>&nbsp;&nbsp;</p> 
  <pre class="has">
<code class="language-Go">arguments := []reflect.Value{req.callb.rcvr}

&nbsp;&nbsp;&nbsp;&nbsp;if req.callb.hasCtx {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments = append(arguments, reflect.ValueOf(ctx))

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;if len(req.args) &gt; 0 {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments = append(arguments, req.args...)

// execute RPC method and return result

&nbsp;&nbsp;&nbsp;&nbsp;reply := req.callb.method.Func.Call(arguments)</code></pre> 
  <p>&nbsp;</p> 
  <p>4.假设调用的是eth_sendTransaction方法，将会进入api/api.go里的sendTransaction方法的逻辑。</p> 
  <p>&nbsp;&nbsp; api.go定义了所有的rpc方法，api/backend.go里的GetAPIs方法把这些rpc方法封装成4大类service，</p> 
  <p>&nbsp; 分别是命名空间为eth的NewPublicTransactionPoolAPI，NewPublicBlockChainAPI，NewPublicAccountAPI</p> 
  <p>&nbsp; 和命名空间为personal的NewPrivateAccountAPI。</p> 
  <p>&nbsp;&nbsp; eth的NewPublicTransactionPoolAPI 的SendTransaction方法不需要密码，</p> 
  <p>&nbsp;&nbsp; &nbsp; 而personal的NewPrivateAccountAPI的SendTransaction方法需要密码去解密key。</p> 
  <p>&nbsp; &nbsp; SendTransaction方法最终会实现把交易插入txpoll的pending队列</p> 
  <p>&nbsp;</p> 
  <p>5. api/api.go里的命名空间为eth的NewPublicTransactionPoolAPI的SendTransaction方法分析：</p> 
  <pre class="has">
<code class="language-Go">&nbsp;func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error)&nbsp; {

&nbsp; return submitTransaction(ctx, s.b, signed)

}</code></pre> 
  <p>&nbsp; 5.1 api.go里的submitTransaction方法的核心内容&nbsp;</p> 
  <p>&nbsp;&nbsp;</p> 
  <pre class="has">
<code class="language-Go">func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) {

&nbsp;&nbsp;&nbsp;&nbsp;if err := b.SendTx(ctx, tx); err != nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return common.Hash{}, err

&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre> 
  <p>&nbsp;&nbsp; 5.2 node/api_backend.go里的SendTx方法&nbsp;&nbsp;</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-Go"> func (b *APIBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error {

&nbsp;&nbsp;&nbsp;&nbsp;return b.kkchain.TxPool().AddLocal(signedTx)

}</code></pre> 
  <p>&nbsp; 5.3 core/tx_poll.go里的AddLocal方法&nbsp;</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-Go"> func (pool *TxPool) AddLocal(tx *types.Transaction) error {

&nbsp;&nbsp;&nbsp;&nbsp;return pool.addTx(tx, !pool.config.NoLocals)

}</code></pre> 
  <p>&nbsp;5.4 core/tx_poll.go里的addTx方法&nbsp; &nbsp; &nbsp;</p> 
  <p>&nbsp;&nbsp;</p> 
  <pre class="has">
<code class="language-Go">func (pool *TxPool) addTx(tx *types.Transaction, local bool) error&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;// Try to inject the transaction and update any state

&nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.add(tx, local)

&nbsp;&nbsp;&nbsp;&nbsp;// If we added a new transaction, run promotion checks and return

&nbsp;&nbsp;&nbsp;&nbsp;if !replace {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from, _ := types.Sender(pool.signer, tx) // already validated

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.promoteExecutables([]common.Address{from})

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;return nil

}</code></pre> 
  <p>&nbsp; &nbsp; addTx方法里核心方法有两个一个是pool.add 方法，一个pool.promoteExecutables方法。add方法如果是替换pending队列里的tx的情况，则会直接替换pengding里的tx。</p> 
  <p>&nbsp;&nbsp; 而 pool.promoteExecutables实现了把普通队列的tx加入到txpoll的pending队列去。</p> 
  <p>&nbsp; &nbsp; tx_poll.go的add方法：&nbsp;</p> 
  <p>&nbsp; &nbsp;</p> 
  <pre class="has">
<code class="language-Go"> // If the transaction fails basic validation, discard it

&nbsp;&nbsp;&nbsp;&nbsp;if err := pool.validateTx(tx, local); err != nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.WithFields(log.Fields{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"hash": hash.String(),

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"err":&nbsp; err,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).Error("Discarding invalid transaction")

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false, err

&nbsp;&nbsp;&nbsp;&nbsp;}

// New transaction isn't replacing a pending one, push into queue

&nbsp;&nbsp;&nbsp;&nbsp;replace, err := pool.enqueueTx(hash, tx)</code></pre> 
  <p>&nbsp;&nbsp; 其中validateTx方法会做签名和是否超过gaslimit的检查</p> 
  <p>&nbsp;</p> 
  <p>5.5 core/tx_poll.go里的pool.promoteExecutables方法，这个方法每次执行都会按顺序尝试删掉以下的逻辑：</p> 
  <p>&nbsp; &nbsp; 删除时间太久的tx，删除账户余额不足或者超过gas的tx，把剩下的tx加入到pending列表。</p> 
  <p>&nbsp;&nbsp;</p> 
  <pre class="has">
<code class="language-Go">&nbsp; // Iterate over all accounts and promote any executable transactions

&nbsp;&nbsp;&nbsp;&nbsp;for _, addr := range accounts {

// Gather all executable transactions and promote them

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash := tx.Hash()

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if pool.promoteTx(addr, hash, tx) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Debugf("Promoting queued transaction,hash: %s", hash.String())

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promoted = append(promoted, tx)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp; }

&nbsp; // Notify subsystem for new promoted transactions.

&nbsp;&nbsp;&nbsp;&nbsp;if len(promoted) &gt; 0 {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go pool.txFeed.Send(NewTxsEvent{promoted})

&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre> 
  <p>&nbsp; &nbsp; 如果pending的队列大于0，发送tx事件到txFeed中。</p> 
  <p>&nbsp;</p> 
  <p>5.6 pool.promoteTx 方法实现把tx加入到txpoll的pending队列去。</p> 
  <p>&nbsp; &nbsp;&nbsp;</p> 
  <pre class="has">
<code class="language-Go">func (pool *TxPool) promoteTx(addr common.Address, hash common.Hash, tx *types.Transaction) bool {

&nbsp;&nbsp;&nbsp;&nbsp;// Try to insert the transaction into the pending queue

&nbsp;&nbsp;&nbsp;&nbsp;if pool.pending[addr] == nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.pending[addr] = newTxList(true)

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;list := pool.pending[addr]

&nbsp;&nbsp;&nbsp;&nbsp;inserted, old := list.Add(tx, pool.config.PriceBump)

&nbsp; &nbsp; if !inserted {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// An older transaction was better, discard this

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Remove(hash)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed()

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Otherwise discard any previous transaction and mark this

&nbsp;&nbsp;&nbsp;&nbsp;if old != nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Remove(old.Hash())

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Removed()

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Failsafe to work around direct pending inserts (tests)

&nbsp;&nbsp;&nbsp;&nbsp;if pool.all.Get(hash) == nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.all.Add(tx)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.priced.Put(tx)

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Set the potentially new pending nonce and notify any subsystems of the new tx

&nbsp;&nbsp;&nbsp;&nbsp;pool.beats[addr] = time.Now()

&nbsp;&nbsp;&nbsp;&nbsp;pool.pendingState.SetNonce(addr, tx.Nonce()+1)

&nbsp;&nbsp;&nbsp;&nbsp;return true</code></pre> 
  <p>&nbsp;&nbsp; &nbsp; &nbsp; 调用core/tx_list.go的Add方法时，如果当前收集的tx在pending队列已经存在，并且老的tx比新的tx的gasprice更大，则新的tx不会再插入到pending列表中去。 &nbsp; &nbsp;</p> 
  <p>&nbsp;</p> 
  <p>6.txpoll里的tx的处理逻辑：</p> 
  <p>&nbsp; 插入区块分两种情况:</p> 
  <p>&nbsp; 情况1:挖矿的全节点，从txpoll中取出tx进行打包。&nbsp;</p> 
  <p>&nbsp; 情况2:收到别的成功挖矿区块，验证通过后，插入区块</p> 
  <p>&nbsp;这里讲的是第一种</p> 
  <p>&nbsp; &nbsp; 6.1 在node/node.go的New方法里&nbsp;&nbsp;&nbsp;&nbsp;</p> 
  <p>&nbsp;&nbsp;</p> 
  <pre class="has">
<code class="language-Go">node.txPool = core.NewTxPool(txConfig, chainConfig, node.blockchain)

&nbsp;node.miner = miner.New(chainConfig, node.blockchain, node.txPool, node.engine)</code></pre> 
  <p>&nbsp;&nbsp; 其中core/tx_poll.go里的NewTxPool方法最终会调用 pool.loop方法</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-Go"> &nbsp; go pool.loop()</code></pre> 
  <p>&nbsp;&nbsp; 其中miner/miner.go里的miner.New方法构建worker实例和会调用miner.onEvent方法</p> 
  <pre class="has">
<code class="language-Go">miner := &amp;Miner{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quitCh:&nbsp; &nbsp; &nbsp; make(chan struct{}),

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncStartCh: make(chan core.StartEvent),

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncDoneCh:&nbsp; make(chan core.DoneEvent),

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worker:&nbsp; &nbsp; &nbsp; newWorker(config, bc, txpool, engine),

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain: &nbsp; &nbsp; &nbsp; bc,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncDone:&nbsp; &nbsp; 1,

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;go miner.onEvent()</code></pre> 
  <p>&nbsp; &nbsp; &nbsp; 其中miner/worker.go 里的newWorker方法会订阅txs和chain head事件，并且开启三个协程。</p> 
  <p>&nbsp;&nbsp;</p> 
  <pre class="has">
<code class="language-Go">// Subscribe events from tx pool

&nbsp;&nbsp;&nbsp;&nbsp;w.txsSub = txpool.SubscribeNewTxsEvent(w.txsCh)

&nbsp;&nbsp;&nbsp;&nbsp;// Subscribe events from inbound handler

&nbsp;&nbsp;&nbsp;&nbsp;w.chainHeadSub = bc.SubscribeChainHeadEvent(w.chainHeadCh)

&nbsp;&nbsp;&nbsp;&nbsp;go w.mineLoop()

&nbsp;&nbsp;&nbsp;&nbsp;go w.taskLoop()

&nbsp;&nbsp;&nbsp;&nbsp;go w.waitResult()

&nbsp;&nbsp;&nbsp;&nbsp;// Submit first work to initialize pending state.

&nbsp;&nbsp;&nbsp;&nbsp;w.startCh &lt;- struct{}{}

&nbsp;&nbsp;&nbsp;&nbsp;return w</code></pre> 
  <p>&nbsp;&nbsp; miner/worker.go里的mineLoop方法的内容为：</p> 
  <p>&nbsp; &nbsp;</p> 
  <pre class="has">
<code class="language-Go">func (w *worker) mineLoop() {

&nbsp;&nbsp;&nbsp;&nbsp;defer w.txsSub.Unsubscribe()

&nbsp;&nbsp;&nbsp;&nbsp;defer w.chainHeadSub.Unsubscribe()

&nbsp;&nbsp;&nbsp;&nbsp;for {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case txs := &lt;-w.txsCh:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range txs.Txs {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(tx)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.chainHeadCh:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if w.isRunning() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.commitTask()

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.startCh:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.commitTask()

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Stopped Mining

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;}

}</code></pre> 
  <p>&nbsp; &nbsp;到这里，就能把rpc发送的sendTransaction请求和txpoll连起来了。因为api/api.go里的SendTransaction方法，如果没问题的话，最终会调用core/tx_poll.go里的pool.promoteExecutables方法，然后在方法里会执行</p> 
  <p>&nbsp;go pool.txFeed.Send(NewTxsEvent{promoted}。当发送Txs的事件消息给txFeed时，所有订阅了txs事件消息的channel都能收到。这时就会触发mineLoop方法里的case txs:=&lt;-w.txsCh，但是为什么这里只是打印出来而已呢？</p> 
  <p>&nbsp;&nbsp; &nbsp; 因为core/tx_poll.go里的pool.promoteExecutables方法里会调用pool.promoteTx(addr, hash, tx)时，已经把tx加入到pending队列。后面只需要调用commitTask，就能实现把txpoll中的pending队列里的tx进行打包。</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;6.2 commitTask分析：</p> 
  <p>&nbsp;&nbsp; 在最初的启动时候会调用一次w.commitTask()，commitTask会从txpoll中取出pending队列的tx打包成区块，最终会把打包的区块写入w.taskCh&nbsp;</p> 
  <p>&nbsp; &nbsp;</p> 
  <pre class="has">
<code class="language-Go">func (w *worker) commitTask() {

&nbsp; //get txs from pending pool

&nbsp;&nbsp;&nbsp;&nbsp;pending, count, _ := w.txpool.Pending()

&nbsp;&nbsp;&nbsp;&nbsp;txs := make(types.Transactions, 0, count)

&nbsp;&nbsp;&nbsp;&nbsp;for _, acctxs := range pending {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, tx := range acctxs {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txs = append(txs, tx)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;if len(txs) &gt; 0 {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//apply txs and get block

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if w.commitTransactions(txs, w.miner) == false {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp; // Deep copy receipts here to avoid interaction between different tasks.

&nbsp;&nbsp;&nbsp;&nbsp;receipts := make([]*types.Receipt, len(w.currentCtx.receipts))

&nbsp;&nbsp;&nbsp;&nbsp;for i, l := range w.currentCtx.receipts {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;receipts[i] = new(types.Receipt)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*receipts[i] = *l

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;block := types.NewBlock(header, w.currentCtx.txs, receipts)

&nbsp;&nbsp; w.taskCh &lt;- &amp;task{block: block, state: s, receipts: receipts, createdAt: time.Now()}</code></pre> 
  <p>&nbsp;</p> 
  <p>&nbsp;&nbsp; &nbsp; 而在miner/worker.go里的taskLoop方法中，如果&lt;-w.taskCh有新的内容，会调用go w.seal(task, stopCh)</p> 
  <p>&nbsp; &nbsp;</p> 
  <pre class="has">
<code class="language-Go">func (w *worker) taskLoop() {

&nbsp;&nbsp;&nbsp;&nbsp;var (

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh chan struct{}

&nbsp;&nbsp;&nbsp;&nbsp;)

&nbsp;&nbsp;&nbsp;&nbsp;// interrupt aborts the in-flight sealing task.

&nbsp;&nbsp;&nbsp;&nbsp;interrupt := func() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if stopCh != nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(stopCh)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh = nil

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;for {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case task := &lt;-w.taskCh:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Reject duplicate sealing work due to resubmitting.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interrupt()

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCh = make(chan struct{})

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go w.seal(task, stopCh)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interrupt()

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;}

}</code></pre> 
  <p>&nbsp; &nbsp; worker.go里的w.seal方法会执行共识算法的逻辑，执行完毕后，最后会把结果写入w.resultCh&nbsp;&nbsp;</p> 
  <p>&nbsp;&nbsp;</p> 
  <pre class="has">
<code class="language-Go"> func (w *worker) seal(t *task, stop &lt;-chan struct{}) {

&nbsp;&nbsp;&nbsp;&nbsp;var (

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err error

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res *task

&nbsp;&nbsp;&nbsp;&nbsp;)

&nbsp;&nbsp;&nbsp;&nbsp;if t.block, err = w.engine.Execute(w.chain, t.block, stop); t.block != nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//log.Info("Successfully sealed new block", "number", t.block.Number(), "hash", t.block.Hash(),

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;"elapsed", time.Since(t.createdAt))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = t

&nbsp;&nbsp;&nbsp;&nbsp;} else {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Errorf("Block sealing failed,err: %v", err)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = nil

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;select {

&nbsp;&nbsp;&nbsp;&nbsp;case w.resultCh &lt;- res:

&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-w.quitCh:

&nbsp;&nbsp;&nbsp;&nbsp;}

}</code></pre> 
  <p>&nbsp;&nbsp; 而在waitResult的协程中，如果w.resultCh有内容，表示挖矿成功，会调用blockchain的writeBlockWithState方法写入区块链，并且发送txs和chainhead这两种事件消息。</p> 
  <p>&nbsp;&nbsp;</p> 
  <pre class="has">
<code class="language-Go">func (w *worker) waitResult() {

&nbsp;&nbsp;&nbsp;&nbsp;for {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case result := &lt;-w.resultCh:&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := w.chain.WriteBlockWithState(block, result.receipts, result.state)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;events = append(events, core.ChainHeadEvent{Block: block})

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;events = append(events, core.NewMinedBlockEvent{Block: block})

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.chain.PostChainEvents(events, logs)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.engine.PostExecute(w.chain, block)

&nbsp;&nbsp;&nbsp;&nbsp;}

}</code></pre> 
  <p>&nbsp; &nbsp;</p> 
  <p>&nbsp;&nbsp; 到这时，因为发送了chainHead事件，miner/worker.go里的mineLoop方法里w.chainHeadCh将会收到新的内容，从而又重新执行&nbsp;w.commitTask()。</p> 
  <p>&nbsp;&nbsp; 这样从rpc发送请求到txpoll再到挖矿，挖矿成功，又重新执行commitTask，commitTask将会取出txpoll的pending队列里的所有tx来打包区块，打包成功后，将又进行挖矿，如果挖矿陈工，又会重新执行committask。如此循环。</p> 
  <p>&nbsp;&nbsp; &nbsp; Pending队列里其实就是下一个可以打包成区块的所有tx。pending的存储格式为pengding[address][Transactions], 之所以这样存储，一个节点可以开多个挖矿账户。</p> 
  <p>&nbsp;</p> 
  <h2><strong>&nbsp;再整体总结一下过程：</strong></h2> 
  <p>&nbsp;&nbsp; 1.发送rpc请求，如果请求的方法名为eth_sendTransaction,进入api.go里的SendTransaction方法逻辑，该方法最终会完成两个事情：</p> 
  <p>&nbsp; &nbsp; &nbsp; 1.1 把tx加入txpoll的pending队列</p> 
  <p>&nbsp; &nbsp; &nbsp; 1.2 发送txs事件消息</p> 
  <p>&nbsp; 2. 当挖矿成功后，worker.go里的w.seal方法会把结果写入w.resultCh中。waitReuslt协程收到会触发发送chainHead事件。</p> 
  <p>&nbsp; 3. worker.go里的mineLoop方法收到w.chainHeadCh里的chainHead事件，会执行commitTask方法。</p> 
  <p>&nbsp; 4. commitTask方法会从txpoll中取中pending[miner address]列表里的所有tx（注意这里的pending列表将会包含第一步收到的rpc交易请求）.然后调用evm执行这些tx，得到receipt收据，把这些txs，receipt和区块头打包成区块，最后把区块发送给w.taskCh.</p> 
  <p>&nbsp; 5. worker.go里的taskLoop方法收到w.taskCh里的消息事件，会调用w.seal方法开始挖矿。如果挖矿成功，于是又跳回第二步。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/kojhliang/article/details/83548182,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/kojhliang/article/details/83548182,&quot;}">阅读更多</a> 
</div> 
<script>
						(function(){
							function setArticleH(btnReadmore,posi){
								var winH = $(window).height();
								var articleBox = $("div.article_content");
								var artH = articleBox.height();
								if(artH > winH*posi){
									articleBox.css({
										'height':winH*posi+'px',
										'overflow':'hidden'
									})
									btnReadmore.click(function(){
										if(typeof window.localStorage === "object" && typeof window.csdn.anonymousUserLimit === "object"){
											if(!window.csdn.anonymousUserLimit.judgment()){
												window.csdn.anonymousUserLimit.Jumplogin();
												return false;
											}else if(!currentUserName){
												window.csdn.anonymousUserLimit.updata();
											}
										}
										
										articleBox.removeAttr("style");
										$(this).parent().remove();
									})
								}else{
									btnReadmore.parent().remove();
								}
							}
							var btnReadmore = $("#btn-readmore");
							if(btnReadmore.length>0){
								if(currentUserName){
									setArticleH(btnReadmore,3);
								}else{
									setArticleH(btnReadmore,1.2);
								}
							}
						})()
					</script>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
