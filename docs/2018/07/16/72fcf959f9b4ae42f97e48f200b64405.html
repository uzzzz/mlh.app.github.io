<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>RChain运行原理[6] - Casper共识之安全性 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="RChain运行原理[6] - Casper共识之安全性" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="在上一篇《Casper共识之估值函数》中介绍了验证者(validator)在打包区块时选择父级区块的逻辑，还剩下了一个问题-区块(block)在加入到DAG链后何时才能被认可？ 认可即为共识，在解决“如何做”之前需要理解“为什么要这样”，所以本篇是下一篇的铺垫，解释Casper共识的原理。 1 概述 共识协议是在分布式环境中对某个命题在拜占庭容错度内(Byzantine Fault Tolerance)达成一致的算法。 Casper协议分为两部分 Casper CBC(Correct By Construction) : CBC是一个高度抽象的共识协议框架，同时也是方法论与过程。 在各类实际的应用中，需要达成共识的命题逻辑多种多样。而CBC本身将具体的命题逻辑剥离出去，不关注具体的使用场景，然后建立通用的模型并证明此模型具有的特性。 这样CBC就是一个通用的共识协议框架，能够适用于各种场景。 派生协议 : 针对某个具体的场景与特定的命题逻辑，在CBC框架内进行细化与适配，从而得到具体的共识协议。 比如全网需要在选择0和1这个命题上达成共识，则发展出来了Casper the Friendly Binary 上一篇中讲到的通过GHOST对DAG链进行分支选择。分支选择也是一个需要达成共识的命题，因此就有了RChain所采用的Casper TFG(the Friendly GHOST) 所有这些派生协议无须再次证明自然地继承了CBC的安全性(Safety) : 所有遵循协议的结点做出的选择都是一致的，它们不会做出相互冲突的选择。 2 模型 了解CBC协议可以查阅Vlad的论文。由于CBC是一个共识协议的抽象框架，直接理解起来有点费力。 本文尝试结合RChain，对论文中的推导步骤尽量做出相对通俗的解释。 2.1 定义：协议状态与转换 首先，CBC定义了两个基本概念：协议状态(protocol states)和状态转换(transitions)。 协议状态用σ表示，代表协议处于的某种状态。 状态转换用−→表示。代表协议状态转换到了某个后续的状态。比如σ −→ σ&#39;就表示协议状态σ转换到了状态σ&#39; 同时协议状态也定义了两个基本性质 传递性(transitivity) σ1 −→ σ2 ∧ σ2 −→ σ3 ⇒ σ1 −→ σ3 如果σ1转换为σ2,σ2转换到σ3, 那么σ1能够转换到σ3 同一性(identity) σ −→ σ 每个状态都有个固有的状态转换到它自身 解释： 协议状态是一个抽象的概念，在TFG中，协议状态具象成了消息的集合。具体到RChain中，协议状态即是前文中讲的消息状态树，其中包含了所有收到的以及当前验证者生成的区块。 而状态的转换即是在共识过程中对应的协议状态改变。在TFG中是消息集合的变化。具体在RChain中，当前验证者生成区块或者接受到来自其它验证者生成的区块，都会导致消息状态树的改变，这种改变即是转换。 2.2 定义：估值函数 Estimator 在上一篇中介绍的估值函数ε，在CBC中的定义为ε : |Σ| -&gt; Prop(C)。 |Σ| 定义为所有的协议状态以及协议状态的转换 -&gt; Prop(C) 得出共识C的命题(propositions) 解释： 估值函数根据协议状态与已经它们之间的转换得出某需要共识的命题。在TFG中有 e = ε(σ)，根据消息状态树的状态选择父区块，也就是分支选择。 2.3 定义：估值安全 Estimate Safety 估值函数ε(σ) =&gt; p返回的估值(estimate)是命题p。在TFG中命题是某个分支选择。在RChain中具体到新区块的父区块选择。 CBC中对估值的安全性(estimate safety)定义：S(p,σ) &lt;=&gt; ∀ σ&#39;, σ−→σ&#39; ε(σ&#39;) =&gt; p。 S(p,σ) 表示p在σ状态下是安全的 &lt;=&gt; 当且仅当 ∀ σ&#39;, σ−→σ&#39; 表示σ&#39;是σ任意的未来状态 ε(σ&#39;) =&gt; p 估值函数对于σ&#39;状态输出p 解释：对于σ的任意未来状态σ&#39;，当且仅当ε(σ&#39;)输出p，则p在σ状态下是安全的。 具体到RChain，如果某个区块选择的分支是未来任意后续区块选择分支的一部分，那么这个区块的选择就是安全的。 估值安全是一种本地属性(local property)，它表示在某个验证者的视角内，对于某个区块的分支选择与历史区块以及未来区块的分支选择之间的关系。 2.4 定义：共同未来状态 σ1 ∼ σ2 σ1 ∼ σ2 &lt;=&gt; ∃σ3 : (σ1 → σ3) ∧ (σ2 → σ3) σ1 ∼ σ2 表示σ1与σ2存在共同的未来状态 &lt;=&gt; 当且仅当 (σ1 → σ3) ∧ (σ2 → σ3) σ3是它们各自的未来状态 解释：σ1和σ2共同未来状态表示它们都能够转换到相同的状态σ3。特别要注意的是，此定义的重点在于存在某种共同的未来状态，并不是说双方一定要向此未来状态转换。 3 安全性证明 - 第一部分 从上面的定义出发开始证明。 3.1 引理I：前向安全性 Forwards Safety ∀σ&#39; : σ−→σ&#39;, S(p,σ) ⇒ S(p,σ&#39;) 解释：证明过程如下 对于σ&#39;的任意未来状态σ&#39;&#39;，由于状态的传递性σ−→σ&#39;−→σ&#39;&#39;，σ&#39;&#39;是σ&#39;的未来状态必定也是σ的未来状态。 p在σ状态下是安全的，根据估值安全的定义，对于σ的任意未来状态都会输出同样的命题p。 因此对于σ&#39;的任意未来状态σ&#39;&#39;，都有ε(σ&#39;&#39;) =&gt; p, 这正是估值安全的定义，所以有S(p,σ&#39;)。 所以有：如果p在σ状态下是安全的，那么p在σ的任意未来状态σ&#39;下也是安全的。 在RChain中的含义是，如果某区块的分支选择是安全的，那么对于未来任意区块该选择都是安全的。 3.2 引理II：当前一致性 Current Consistency S(p, σ) ⇒ ¬S(¬p, σ) 解释：证明过程如下 如果p在σ状态下是安全的，那么对于σ的任意未来状态σ&#39;都有ε(σ&#39;) =&gt; p ¬p是p的逆命题，p和¬p不可能同时为真。 而任意未来状态下ε(σ&#39;)都是输出p命题，不可能输出¬p 那么S(¬p, σ)一定为假，也就是说¬p在σ状态下是不安全的，也就是¬S(¬p, σ) 这条引理的含义是，如果p是σ状态下安全的估值，那么其它与此估值矛盾的估值都是不安全的。 在TFG中的含义是，在某区块的分支选择上，不存在多个相互矛盾且安全的分支选择。 比如命题p在某区块表示“选择分支a”；那么¬p表示“不选择分支a”。 如果“选择分支a”是安全的，那么“不选择分支a”的其它分支选择肯定是不安全的。 3.3 引理III：后向一致性 Backwards Consistency ∀σ : σ → σ&#39;, S(p, σ&#39;) ⇒ ¬S(¬p, σ) 解释：如果p在σ&#39;状态下是安全的，那么它的逆命题¬p在此状态的前置状态下一定是不安全的。 证明此引理需要反证法。 首先假设逆命题¬p在σ状态下是安全的 根据引理I，¬p在σ的任意未来状态σ&#39;下也是安全的，即S(¬p, σ&#39;) 根据引理II，有¬S(p, σ&#39;)，而这与S(p, σ&#39;)矛盾 因此，逆命题¬p在σ状态下一定是不安全的，即¬S(¬p, σ) 在RChain中的含义:如果某区块的分支选择是安全的，那么任何前置区块中与当前分支选择矛盾的选择都是不安全的。 3.4 证明：从估值安全到共识安全 在这里先假设σ1和σ2有共同的未来状态σ3,也就是σ1 ∼ σ2。在此假设的基础上做如下推导： 在σ1和它的未来状态σ3间使用引理I，得出 S(p,σ1) ⇒ S(p,σ3)。即p如果在σ1状态安全一定也在σ3状态下安全。 在σ3和它的过去状态σ2间使用引理III，得出 S(p,σ3) ⇒ ¬S(¬p,σ2)。即p如果在σ3状态下安全则它的逆命题¬p在过去状态σ2一定不安全。 因此σ1和σ2彼此之间也有了关系：S(p,σ1) ⇒ ¬S(¬p,σ2), 而它等价于 ¬(S(p, σ1) ∧ S(¬p, σ2)) 不可能同时存在命题p在σ1状态估值安全而逆命题¬p在σ2状态也估值安全 ¬S(p, σ1) ∨ ¬S(¬p, σ2) 不可能同时存在命题p在σ1状态估值不安全而逆命题¬p在σ2状态也估值不安全 命题p在具有未来共同未来状态的σ1和σ2中，要么命题p对于它们都是安全的;要么逆命题¬p对于它们都是安全的。而协议的参与者如果都做出使命题p都对于自己的协议状态估值安全的决定，它们就命题p做出了一致的决定，不会产生冲突。这也就证明了共识协议的安全性(Safety)。 具体到RChain中，有两个验证者v1和v2。v1在σ1状态下做出了估值安全的分支选择e1，同时v2在σ2状态下做出了安全估值的分支选择e2，现在假设它们有一个未来的共同状态σ3。根据e = ε(σ)，它们必定在未来的共同状态选择了相同的分支。而又根据估值安全的定义，e1/e2这两个分支选择必定被未来的分支选择包含，它们在未来某刻选择了相同的分支。而GHOST选择的分支是唯一的，那么可以直观得到e1和e2这两个分支选择必定是其中一个包含（或等于）另外一个。也就是说，验证者选择的分支必定一致。 结论：具有共同未来状态的协议参与者如果都做出估值安全的决定，必将有共识安全。 4 安全性证明 - 第二部分 第一部分的证明是不完备的，因为它假设了σ1和σ2总是存在共同未来状态。共同的未来状态σ3并不是说σ1和σ2一定要向此状态进行转换，而是作为证明中的一个跳板，通过两个引理的依次代入而得出σ1和σ2之间的确定性关系。只要σ1和σ2存在任何理论上共同的未来状态，那么第一部分的证明总是有效的。因此接下来需要考虑：σ1和σ2是否总是存在共同的未来状态？ 4.1 非平凡 Non-triviality 非平凡是数学用语，比如“零除以任何实数都等于零”这个命题在0这个实数上是非平凡的。非平凡表示存在某种特例。 在TFG中，协议状态即是消息的集合。那么对于任意两个协议状态σ1和σ2，它们的并集σ1∪σ2必定是它们的共同未来状态。这个推导看上去是没有问题的，但它却是非平凡的。 在有这样一种情况：如果命题p和逆命题¬p在σ0状态都不是估值安全的。 σ0状态有两个后续状态σ1和σ2，其中命题p在σ1状态下是估值安全的，逆命题¬p在σ2状态下也是估值安全的。 首先假设σ1和σ2在这种情况下有共同的未来状态σ3 根据引理I，S(p,σ1) ⇒ S(p,σ3), S(¬p,σ1) ⇒ S(¬p,σ3)。即S(p,σ3) ∧ S(¬p,σ3)，命题p和逆命题¬p在σ3状态下同时安全。 根据引理II，S(p,σ3) ⇒ ¬S(¬p, σ3)，命题p和逆命题¬p在σ3状态下不可能同时安全。 上述两部推导结果矛盾，因此假设不成立。σ1和σ2在这种情况下不可能有共同的未来状态。 具体到RChain中，消息状态树的区块总是增加的，假设有两颗不同的消息状态树，如果把它们的区块合并成一颗新的消息状态树，即是它们的共同未来状态。这种说法貌似是正确的，但如果某个恶意验证者在某个状态下（也就是某个高度），输出了两个截然不同的区块且分支选择不同。那么这个恶意验证者生成的这两个区块是无法合并到同一颗消息状态树中，也就没有共同的未来状态。恶意验证者的这种行为称之为“模棱两可”(Equivocation)，它属于拜占庭错误，具体的细节后文再论。 “零除以任何实数都等于零”这个命题加上额外条件排除非平凡域后，就有了“零除以任何非零实数都等于零”这个正确的命题了。 同样， 对于原命题“σ1∪σ2是σ1和σ2的共同未来状态”加上额外的条件“σ1∪σ2中具有少于N个拜占庭错误”就排除掉非平凡域，这个命题就是正确的了。 所以验证者需要计算(count)拜占庭错误以便将它们排除掉。 4.2 结论 将上面第一部分和第二部分结合起来，有： 在少于N个拜占庭错误的情况下，协议参与者如果都做出估值安全的决定，必将有共识安全。 因此需要引入保证金机制(PoS)从经济利益的层面上来避免验证者成为拜占庭叛徒。 5 错误类型 现在回过头去看，验证者在打包的过程中，可能存在下面几类错误。 5.1 无效的消息 这个很好剔除掉，验证者在接收到其它验证者的区块时，必须在本地重算(replay)一次得到相同的结果才能加入到本地的消息状态树。因此无效的消息不可能触发协议状态转换。 5.2 消息延迟、丢失或者乱序 由于Casper是异步协议，消息(区块)发送给其它验证者并不需要确认返回，因此可能由于网络原因导致消息的延迟、丢失或者乱序。乱序比较好处理，因为每个区块都有justifications字段，能够方便地在消息状态树中重建出正确的顺序。对于延迟或丢失，接收方是无法分辨是由于网络原因造成还是发送方造成，因此使用同样的逻辑处理它们a。消息延迟、丢失会对共识协议的活性(liveness)产生负面影响，也就是延迟区块达到最终安全性的时间。因此Casper并不是完全异步的协议，会有超时判断机制。 如果出现某验证者经常性地延迟或丢失消息，会进入一个同步的过程将此验证者从验证池中踢出(eject)，以保证共识协议的活性。至于会不会对保证金进行少量的罚没，目前还没有定论。 5.3 Equivocation 从攻击者的角度来说，想要对其它验证者的协议状态产生不利影响并不是那么容易的事情。 首先区块内包含的状态改变必须依据规则化简，否则就是前文中的无效消息。其次，如果故意丢失或者延迟消息，则会被踢出。拜占庭叛徒验证者在打包过程中，唯一能够做手脚的在于估值e = ε(σ)，也就是对父区块的选择上。但也不是那么容易，因为ε对于所有的验证者都是一致的，所以验证者并不能随意地为新区块选择父区块。 RChain为了提高并行度，特别是吞吐率，必须允许所有验证者能够同时打包且它们的包有可能同时进入到DAG链。这也是选择CasperTFG的原因-如果RChain采用BTC那样的方式每次只允许一个验证者出块,必将大大限制并行度。在这样的情况下，每个验证者任何时候都能够出块，而且打包的成本很低。这就会导致Nothing-at-stake的问题。 而且，验证者有动机这么做：只有进入到DAG被认可的分支才能收到Rewards，那么验证者为了提高自己获得奖励的概率，小心地构造σ，在同一高度输出多个不同分支选择的块。从而会引起上文所说的Equivocation。如果全网的拜占庭错误数过大，最终会导致共识失败，也就是无法取得一致性。 PoS对这类行为的惩罚是非常严厉的。发现一次会罚没所有的保证金。 每个区块中有signature字段，由打包的验证者签名无法伪造。如果其它验证者发现某验证者在同一高度有两个不同的区块，通过调用PoS的Slash API罚没验证者所有的保证金。 当然，检举的验证者会获得奖励，来源于保证金。这就是PoS防止拜占庭错误的机制：每个验证者的stake也是其它验证者监督它的奖金。 本文地址:https://blog.csdn.net/wangjia184/article/details/81059229 转载须注明出处。 下一篇《Casper共识之预言机》 阅读更多" />
<meta property="og:description" content="在上一篇《Casper共识之估值函数》中介绍了验证者(validator)在打包区块时选择父级区块的逻辑，还剩下了一个问题-区块(block)在加入到DAG链后何时才能被认可？ 认可即为共识，在解决“如何做”之前需要理解“为什么要这样”，所以本篇是下一篇的铺垫，解释Casper共识的原理。 1 概述 共识协议是在分布式环境中对某个命题在拜占庭容错度内(Byzantine Fault Tolerance)达成一致的算法。 Casper协议分为两部分 Casper CBC(Correct By Construction) : CBC是一个高度抽象的共识协议框架，同时也是方法论与过程。 在各类实际的应用中，需要达成共识的命题逻辑多种多样。而CBC本身将具体的命题逻辑剥离出去，不关注具体的使用场景，然后建立通用的模型并证明此模型具有的特性。 这样CBC就是一个通用的共识协议框架，能够适用于各种场景。 派生协议 : 针对某个具体的场景与特定的命题逻辑，在CBC框架内进行细化与适配，从而得到具体的共识协议。 比如全网需要在选择0和1这个命题上达成共识，则发展出来了Casper the Friendly Binary 上一篇中讲到的通过GHOST对DAG链进行分支选择。分支选择也是一个需要达成共识的命题，因此就有了RChain所采用的Casper TFG(the Friendly GHOST) 所有这些派生协议无须再次证明自然地继承了CBC的安全性(Safety) : 所有遵循协议的结点做出的选择都是一致的，它们不会做出相互冲突的选择。 2 模型 了解CBC协议可以查阅Vlad的论文。由于CBC是一个共识协议的抽象框架，直接理解起来有点费力。 本文尝试结合RChain，对论文中的推导步骤尽量做出相对通俗的解释。 2.1 定义：协议状态与转换 首先，CBC定义了两个基本概念：协议状态(protocol states)和状态转换(transitions)。 协议状态用σ表示，代表协议处于的某种状态。 状态转换用−→表示。代表协议状态转换到了某个后续的状态。比如σ −→ σ&#39;就表示协议状态σ转换到了状态σ&#39; 同时协议状态也定义了两个基本性质 传递性(transitivity) σ1 −→ σ2 ∧ σ2 −→ σ3 ⇒ σ1 −→ σ3 如果σ1转换为σ2,σ2转换到σ3, 那么σ1能够转换到σ3 同一性(identity) σ −→ σ 每个状态都有个固有的状态转换到它自身 解释： 协议状态是一个抽象的概念，在TFG中，协议状态具象成了消息的集合。具体到RChain中，协议状态即是前文中讲的消息状态树，其中包含了所有收到的以及当前验证者生成的区块。 而状态的转换即是在共识过程中对应的协议状态改变。在TFG中是消息集合的变化。具体在RChain中，当前验证者生成区块或者接受到来自其它验证者生成的区块，都会导致消息状态树的改变，这种改变即是转换。 2.2 定义：估值函数 Estimator 在上一篇中介绍的估值函数ε，在CBC中的定义为ε : |Σ| -&gt; Prop(C)。 |Σ| 定义为所有的协议状态以及协议状态的转换 -&gt; Prop(C) 得出共识C的命题(propositions) 解释： 估值函数根据协议状态与已经它们之间的转换得出某需要共识的命题。在TFG中有 e = ε(σ)，根据消息状态树的状态选择父区块，也就是分支选择。 2.3 定义：估值安全 Estimate Safety 估值函数ε(σ) =&gt; p返回的估值(estimate)是命题p。在TFG中命题是某个分支选择。在RChain中具体到新区块的父区块选择。 CBC中对估值的安全性(estimate safety)定义：S(p,σ) &lt;=&gt; ∀ σ&#39;, σ−→σ&#39; ε(σ&#39;) =&gt; p。 S(p,σ) 表示p在σ状态下是安全的 &lt;=&gt; 当且仅当 ∀ σ&#39;, σ−→σ&#39; 表示σ&#39;是σ任意的未来状态 ε(σ&#39;) =&gt; p 估值函数对于σ&#39;状态输出p 解释：对于σ的任意未来状态σ&#39;，当且仅当ε(σ&#39;)输出p，则p在σ状态下是安全的。 具体到RChain，如果某个区块选择的分支是未来任意后续区块选择分支的一部分，那么这个区块的选择就是安全的。 估值安全是一种本地属性(local property)，它表示在某个验证者的视角内，对于某个区块的分支选择与历史区块以及未来区块的分支选择之间的关系。 2.4 定义：共同未来状态 σ1 ∼ σ2 σ1 ∼ σ2 &lt;=&gt; ∃σ3 : (σ1 → σ3) ∧ (σ2 → σ3) σ1 ∼ σ2 表示σ1与σ2存在共同的未来状态 &lt;=&gt; 当且仅当 (σ1 → σ3) ∧ (σ2 → σ3) σ3是它们各自的未来状态 解释：σ1和σ2共同未来状态表示它们都能够转换到相同的状态σ3。特别要注意的是，此定义的重点在于存在某种共同的未来状态，并不是说双方一定要向此未来状态转换。 3 安全性证明 - 第一部分 从上面的定义出发开始证明。 3.1 引理I：前向安全性 Forwards Safety ∀σ&#39; : σ−→σ&#39;, S(p,σ) ⇒ S(p,σ&#39;) 解释：证明过程如下 对于σ&#39;的任意未来状态σ&#39;&#39;，由于状态的传递性σ−→σ&#39;−→σ&#39;&#39;，σ&#39;&#39;是σ&#39;的未来状态必定也是σ的未来状态。 p在σ状态下是安全的，根据估值安全的定义，对于σ的任意未来状态都会输出同样的命题p。 因此对于σ&#39;的任意未来状态σ&#39;&#39;，都有ε(σ&#39;&#39;) =&gt; p, 这正是估值安全的定义，所以有S(p,σ&#39;)。 所以有：如果p在σ状态下是安全的，那么p在σ的任意未来状态σ&#39;下也是安全的。 在RChain中的含义是，如果某区块的分支选择是安全的，那么对于未来任意区块该选择都是安全的。 3.2 引理II：当前一致性 Current Consistency S(p, σ) ⇒ ¬S(¬p, σ) 解释：证明过程如下 如果p在σ状态下是安全的，那么对于σ的任意未来状态σ&#39;都有ε(σ&#39;) =&gt; p ¬p是p的逆命题，p和¬p不可能同时为真。 而任意未来状态下ε(σ&#39;)都是输出p命题，不可能输出¬p 那么S(¬p, σ)一定为假，也就是说¬p在σ状态下是不安全的，也就是¬S(¬p, σ) 这条引理的含义是，如果p是σ状态下安全的估值，那么其它与此估值矛盾的估值都是不安全的。 在TFG中的含义是，在某区块的分支选择上，不存在多个相互矛盾且安全的分支选择。 比如命题p在某区块表示“选择分支a”；那么¬p表示“不选择分支a”。 如果“选择分支a”是安全的，那么“不选择分支a”的其它分支选择肯定是不安全的。 3.3 引理III：后向一致性 Backwards Consistency ∀σ : σ → σ&#39;, S(p, σ&#39;) ⇒ ¬S(¬p, σ) 解释：如果p在σ&#39;状态下是安全的，那么它的逆命题¬p在此状态的前置状态下一定是不安全的。 证明此引理需要反证法。 首先假设逆命题¬p在σ状态下是安全的 根据引理I，¬p在σ的任意未来状态σ&#39;下也是安全的，即S(¬p, σ&#39;) 根据引理II，有¬S(p, σ&#39;)，而这与S(p, σ&#39;)矛盾 因此，逆命题¬p在σ状态下一定是不安全的，即¬S(¬p, σ) 在RChain中的含义:如果某区块的分支选择是安全的，那么任何前置区块中与当前分支选择矛盾的选择都是不安全的。 3.4 证明：从估值安全到共识安全 在这里先假设σ1和σ2有共同的未来状态σ3,也就是σ1 ∼ σ2。在此假设的基础上做如下推导： 在σ1和它的未来状态σ3间使用引理I，得出 S(p,σ1) ⇒ S(p,σ3)。即p如果在σ1状态安全一定也在σ3状态下安全。 在σ3和它的过去状态σ2间使用引理III，得出 S(p,σ3) ⇒ ¬S(¬p,σ2)。即p如果在σ3状态下安全则它的逆命题¬p在过去状态σ2一定不安全。 因此σ1和σ2彼此之间也有了关系：S(p,σ1) ⇒ ¬S(¬p,σ2), 而它等价于 ¬(S(p, σ1) ∧ S(¬p, σ2)) 不可能同时存在命题p在σ1状态估值安全而逆命题¬p在σ2状态也估值安全 ¬S(p, σ1) ∨ ¬S(¬p, σ2) 不可能同时存在命题p在σ1状态估值不安全而逆命题¬p在σ2状态也估值不安全 命题p在具有未来共同未来状态的σ1和σ2中，要么命题p对于它们都是安全的;要么逆命题¬p对于它们都是安全的。而协议的参与者如果都做出使命题p都对于自己的协议状态估值安全的决定，它们就命题p做出了一致的决定，不会产生冲突。这也就证明了共识协议的安全性(Safety)。 具体到RChain中，有两个验证者v1和v2。v1在σ1状态下做出了估值安全的分支选择e1，同时v2在σ2状态下做出了安全估值的分支选择e2，现在假设它们有一个未来的共同状态σ3。根据e = ε(σ)，它们必定在未来的共同状态选择了相同的分支。而又根据估值安全的定义，e1/e2这两个分支选择必定被未来的分支选择包含，它们在未来某刻选择了相同的分支。而GHOST选择的分支是唯一的，那么可以直观得到e1和e2这两个分支选择必定是其中一个包含（或等于）另外一个。也就是说，验证者选择的分支必定一致。 结论：具有共同未来状态的协议参与者如果都做出估值安全的决定，必将有共识安全。 4 安全性证明 - 第二部分 第一部分的证明是不完备的，因为它假设了σ1和σ2总是存在共同未来状态。共同的未来状态σ3并不是说σ1和σ2一定要向此状态进行转换，而是作为证明中的一个跳板，通过两个引理的依次代入而得出σ1和σ2之间的确定性关系。只要σ1和σ2存在任何理论上共同的未来状态，那么第一部分的证明总是有效的。因此接下来需要考虑：σ1和σ2是否总是存在共同的未来状态？ 4.1 非平凡 Non-triviality 非平凡是数学用语，比如“零除以任何实数都等于零”这个命题在0这个实数上是非平凡的。非平凡表示存在某种特例。 在TFG中，协议状态即是消息的集合。那么对于任意两个协议状态σ1和σ2，它们的并集σ1∪σ2必定是它们的共同未来状态。这个推导看上去是没有问题的，但它却是非平凡的。 在有这样一种情况：如果命题p和逆命题¬p在σ0状态都不是估值安全的。 σ0状态有两个后续状态σ1和σ2，其中命题p在σ1状态下是估值安全的，逆命题¬p在σ2状态下也是估值安全的。 首先假设σ1和σ2在这种情况下有共同的未来状态σ3 根据引理I，S(p,σ1) ⇒ S(p,σ3), S(¬p,σ1) ⇒ S(¬p,σ3)。即S(p,σ3) ∧ S(¬p,σ3)，命题p和逆命题¬p在σ3状态下同时安全。 根据引理II，S(p,σ3) ⇒ ¬S(¬p, σ3)，命题p和逆命题¬p在σ3状态下不可能同时安全。 上述两部推导结果矛盾，因此假设不成立。σ1和σ2在这种情况下不可能有共同的未来状态。 具体到RChain中，消息状态树的区块总是增加的，假设有两颗不同的消息状态树，如果把它们的区块合并成一颗新的消息状态树，即是它们的共同未来状态。这种说法貌似是正确的，但如果某个恶意验证者在某个状态下（也就是某个高度），输出了两个截然不同的区块且分支选择不同。那么这个恶意验证者生成的这两个区块是无法合并到同一颗消息状态树中，也就没有共同的未来状态。恶意验证者的这种行为称之为“模棱两可”(Equivocation)，它属于拜占庭错误，具体的细节后文再论。 “零除以任何实数都等于零”这个命题加上额外条件排除非平凡域后，就有了“零除以任何非零实数都等于零”这个正确的命题了。 同样， 对于原命题“σ1∪σ2是σ1和σ2的共同未来状态”加上额外的条件“σ1∪σ2中具有少于N个拜占庭错误”就排除掉非平凡域，这个命题就是正确的了。 所以验证者需要计算(count)拜占庭错误以便将它们排除掉。 4.2 结论 将上面第一部分和第二部分结合起来，有： 在少于N个拜占庭错误的情况下，协议参与者如果都做出估值安全的决定，必将有共识安全。 因此需要引入保证金机制(PoS)从经济利益的层面上来避免验证者成为拜占庭叛徒。 5 错误类型 现在回过头去看，验证者在打包的过程中，可能存在下面几类错误。 5.1 无效的消息 这个很好剔除掉，验证者在接收到其它验证者的区块时，必须在本地重算(replay)一次得到相同的结果才能加入到本地的消息状态树。因此无效的消息不可能触发协议状态转换。 5.2 消息延迟、丢失或者乱序 由于Casper是异步协议，消息(区块)发送给其它验证者并不需要确认返回，因此可能由于网络原因导致消息的延迟、丢失或者乱序。乱序比较好处理，因为每个区块都有justifications字段，能够方便地在消息状态树中重建出正确的顺序。对于延迟或丢失，接收方是无法分辨是由于网络原因造成还是发送方造成，因此使用同样的逻辑处理它们a。消息延迟、丢失会对共识协议的活性(liveness)产生负面影响，也就是延迟区块达到最终安全性的时间。因此Casper并不是完全异步的协议，会有超时判断机制。 如果出现某验证者经常性地延迟或丢失消息，会进入一个同步的过程将此验证者从验证池中踢出(eject)，以保证共识协议的活性。至于会不会对保证金进行少量的罚没，目前还没有定论。 5.3 Equivocation 从攻击者的角度来说，想要对其它验证者的协议状态产生不利影响并不是那么容易的事情。 首先区块内包含的状态改变必须依据规则化简，否则就是前文中的无效消息。其次，如果故意丢失或者延迟消息，则会被踢出。拜占庭叛徒验证者在打包过程中，唯一能够做手脚的在于估值e = ε(σ)，也就是对父区块的选择上。但也不是那么容易，因为ε对于所有的验证者都是一致的，所以验证者并不能随意地为新区块选择父区块。 RChain为了提高并行度，特别是吞吐率，必须允许所有验证者能够同时打包且它们的包有可能同时进入到DAG链。这也是选择CasperTFG的原因-如果RChain采用BTC那样的方式每次只允许一个验证者出块,必将大大限制并行度。在这样的情况下，每个验证者任何时候都能够出块，而且打包的成本很低。这就会导致Nothing-at-stake的问题。 而且，验证者有动机这么做：只有进入到DAG被认可的分支才能收到Rewards，那么验证者为了提高自己获得奖励的概率，小心地构造σ，在同一高度输出多个不同分支选择的块。从而会引起上文所说的Equivocation。如果全网的拜占庭错误数过大，最终会导致共识失败，也就是无法取得一致性。 PoS对这类行为的惩罚是非常严厉的。发现一次会罚没所有的保证金。 每个区块中有signature字段，由打包的验证者签名无法伪造。如果其它验证者发现某验证者在同一高度有两个不同的区块，通过调用PoS的Slash API罚没验证者所有的保证金。 当然，检举的验证者会获得奖励，来源于保证金。这就是PoS防止拜占庭错误的机制：每个验证者的stake也是其它验证者监督它的奖金。 本文地址:https://blog.csdn.net/wangjia184/article/details/81059229 转载须注明出处。 下一篇《Casper共识之预言机》 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/07/16/72fcf959f9b4ae42f97e48f200b64405.html" />
<meta property="og:url" content="https://mlh.app/2018/07/16/72fcf959f9b4ae42f97e48f200b64405.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-16T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"在上一篇《Casper共识之估值函数》中介绍了验证者(validator)在打包区块时选择父级区块的逻辑，还剩下了一个问题-区块(block)在加入到DAG链后何时才能被认可？ 认可即为共识，在解决“如何做”之前需要理解“为什么要这样”，所以本篇是下一篇的铺垫，解释Casper共识的原理。 1 概述 共识协议是在分布式环境中对某个命题在拜占庭容错度内(Byzantine Fault Tolerance)达成一致的算法。 Casper协议分为两部分 Casper CBC(Correct By Construction) : CBC是一个高度抽象的共识协议框架，同时也是方法论与过程。 在各类实际的应用中，需要达成共识的命题逻辑多种多样。而CBC本身将具体的命题逻辑剥离出去，不关注具体的使用场景，然后建立通用的模型并证明此模型具有的特性。 这样CBC就是一个通用的共识协议框架，能够适用于各种场景。 派生协议 : 针对某个具体的场景与特定的命题逻辑，在CBC框架内进行细化与适配，从而得到具体的共识协议。 比如全网需要在选择0和1这个命题上达成共识，则发展出来了Casper the Friendly Binary 上一篇中讲到的通过GHOST对DAG链进行分支选择。分支选择也是一个需要达成共识的命题，因此就有了RChain所采用的Casper TFG(the Friendly GHOST) 所有这些派生协议无须再次证明自然地继承了CBC的安全性(Safety) : 所有遵循协议的结点做出的选择都是一致的，它们不会做出相互冲突的选择。 2 模型 了解CBC协议可以查阅Vlad的论文。由于CBC是一个共识协议的抽象框架，直接理解起来有点费力。 本文尝试结合RChain，对论文中的推导步骤尽量做出相对通俗的解释。 2.1 定义：协议状态与转换 首先，CBC定义了两个基本概念：协议状态(protocol states)和状态转换(transitions)。 协议状态用σ表示，代表协议处于的某种状态。 状态转换用−→表示。代表协议状态转换到了某个后续的状态。比如σ −→ σ&#39;就表示协议状态σ转换到了状态σ&#39; 同时协议状态也定义了两个基本性质 传递性(transitivity) σ1 −→ σ2 ∧ σ2 −→ σ3 ⇒ σ1 −→ σ3 如果σ1转换为σ2,σ2转换到σ3, 那么σ1能够转换到σ3 同一性(identity) σ −→ σ 每个状态都有个固有的状态转换到它自身 解释： 协议状态是一个抽象的概念，在TFG中，协议状态具象成了消息的集合。具体到RChain中，协议状态即是前文中讲的消息状态树，其中包含了所有收到的以及当前验证者生成的区块。 而状态的转换即是在共识过程中对应的协议状态改变。在TFG中是消息集合的变化。具体在RChain中，当前验证者生成区块或者接受到来自其它验证者生成的区块，都会导致消息状态树的改变，这种改变即是转换。 2.2 定义：估值函数 Estimator 在上一篇中介绍的估值函数ε，在CBC中的定义为ε : |Σ| -&gt; Prop(C)。 |Σ| 定义为所有的协议状态以及协议状态的转换 -&gt; Prop(C) 得出共识C的命题(propositions) 解释： 估值函数根据协议状态与已经它们之间的转换得出某需要共识的命题。在TFG中有 e = ε(σ)，根据消息状态树的状态选择父区块，也就是分支选择。 2.3 定义：估值安全 Estimate Safety 估值函数ε(σ) =&gt; p返回的估值(estimate)是命题p。在TFG中命题是某个分支选择。在RChain中具体到新区块的父区块选择。 CBC中对估值的安全性(estimate safety)定义：S(p,σ) &lt;=&gt; ∀ σ&#39;, σ−→σ&#39; ε(σ&#39;) =&gt; p。 S(p,σ) 表示p在σ状态下是安全的 &lt;=&gt; 当且仅当 ∀ σ&#39;, σ−→σ&#39; 表示σ&#39;是σ任意的未来状态 ε(σ&#39;) =&gt; p 估值函数对于σ&#39;状态输出p 解释：对于σ的任意未来状态σ&#39;，当且仅当ε(σ&#39;)输出p，则p在σ状态下是安全的。 具体到RChain，如果某个区块选择的分支是未来任意后续区块选择分支的一部分，那么这个区块的选择就是安全的。 估值安全是一种本地属性(local property)，它表示在某个验证者的视角内，对于某个区块的分支选择与历史区块以及未来区块的分支选择之间的关系。 2.4 定义：共同未来状态 σ1 ∼ σ2 σ1 ∼ σ2 &lt;=&gt; ∃σ3 : (σ1 → σ3) ∧ (σ2 → σ3) σ1 ∼ σ2 表示σ1与σ2存在共同的未来状态 &lt;=&gt; 当且仅当 (σ1 → σ3) ∧ (σ2 → σ3) σ3是它们各自的未来状态 解释：σ1和σ2共同未来状态表示它们都能够转换到相同的状态σ3。特别要注意的是，此定义的重点在于存在某种共同的未来状态，并不是说双方一定要向此未来状态转换。 3 安全性证明 - 第一部分 从上面的定义出发开始证明。 3.1 引理I：前向安全性 Forwards Safety ∀σ&#39; : σ−→σ&#39;, S(p,σ) ⇒ S(p,σ&#39;) 解释：证明过程如下 对于σ&#39;的任意未来状态σ&#39;&#39;，由于状态的传递性σ−→σ&#39;−→σ&#39;&#39;，σ&#39;&#39;是σ&#39;的未来状态必定也是σ的未来状态。 p在σ状态下是安全的，根据估值安全的定义，对于σ的任意未来状态都会输出同样的命题p。 因此对于σ&#39;的任意未来状态σ&#39;&#39;，都有ε(σ&#39;&#39;) =&gt; p, 这正是估值安全的定义，所以有S(p,σ&#39;)。 所以有：如果p在σ状态下是安全的，那么p在σ的任意未来状态σ&#39;下也是安全的。 在RChain中的含义是，如果某区块的分支选择是安全的，那么对于未来任意区块该选择都是安全的。 3.2 引理II：当前一致性 Current Consistency S(p, σ) ⇒ ¬S(¬p, σ) 解释：证明过程如下 如果p在σ状态下是安全的，那么对于σ的任意未来状态σ&#39;都有ε(σ&#39;) =&gt; p ¬p是p的逆命题，p和¬p不可能同时为真。 而任意未来状态下ε(σ&#39;)都是输出p命题，不可能输出¬p 那么S(¬p, σ)一定为假，也就是说¬p在σ状态下是不安全的，也就是¬S(¬p, σ) 这条引理的含义是，如果p是σ状态下安全的估值，那么其它与此估值矛盾的估值都是不安全的。 在TFG中的含义是，在某区块的分支选择上，不存在多个相互矛盾且安全的分支选择。 比如命题p在某区块表示“选择分支a”；那么¬p表示“不选择分支a”。 如果“选择分支a”是安全的，那么“不选择分支a”的其它分支选择肯定是不安全的。 3.3 引理III：后向一致性 Backwards Consistency ∀σ : σ → σ&#39;, S(p, σ&#39;) ⇒ ¬S(¬p, σ) 解释：如果p在σ&#39;状态下是安全的，那么它的逆命题¬p在此状态的前置状态下一定是不安全的。 证明此引理需要反证法。 首先假设逆命题¬p在σ状态下是安全的 根据引理I，¬p在σ的任意未来状态σ&#39;下也是安全的，即S(¬p, σ&#39;) 根据引理II，有¬S(p, σ&#39;)，而这与S(p, σ&#39;)矛盾 因此，逆命题¬p在σ状态下一定是不安全的，即¬S(¬p, σ) 在RChain中的含义:如果某区块的分支选择是安全的，那么任何前置区块中与当前分支选择矛盾的选择都是不安全的。 3.4 证明：从估值安全到共识安全 在这里先假设σ1和σ2有共同的未来状态σ3,也就是σ1 ∼ σ2。在此假设的基础上做如下推导： 在σ1和它的未来状态σ3间使用引理I，得出 S(p,σ1) ⇒ S(p,σ3)。即p如果在σ1状态安全一定也在σ3状态下安全。 在σ3和它的过去状态σ2间使用引理III，得出 S(p,σ3) ⇒ ¬S(¬p,σ2)。即p如果在σ3状态下安全则它的逆命题¬p在过去状态σ2一定不安全。 因此σ1和σ2彼此之间也有了关系：S(p,σ1) ⇒ ¬S(¬p,σ2), 而它等价于 ¬(S(p, σ1) ∧ S(¬p, σ2)) 不可能同时存在命题p在σ1状态估值安全而逆命题¬p在σ2状态也估值安全 ¬S(p, σ1) ∨ ¬S(¬p, σ2) 不可能同时存在命题p在σ1状态估值不安全而逆命题¬p在σ2状态也估值不安全 命题p在具有未来共同未来状态的σ1和σ2中，要么命题p对于它们都是安全的;要么逆命题¬p对于它们都是安全的。而协议的参与者如果都做出使命题p都对于自己的协议状态估值安全的决定，它们就命题p做出了一致的决定，不会产生冲突。这也就证明了共识协议的安全性(Safety)。 具体到RChain中，有两个验证者v1和v2。v1在σ1状态下做出了估值安全的分支选择e1，同时v2在σ2状态下做出了安全估值的分支选择e2，现在假设它们有一个未来的共同状态σ3。根据e = ε(σ)，它们必定在未来的共同状态选择了相同的分支。而又根据估值安全的定义，e1/e2这两个分支选择必定被未来的分支选择包含，它们在未来某刻选择了相同的分支。而GHOST选择的分支是唯一的，那么可以直观得到e1和e2这两个分支选择必定是其中一个包含（或等于）另外一个。也就是说，验证者选择的分支必定一致。 结论：具有共同未来状态的协议参与者如果都做出估值安全的决定，必将有共识安全。 4 安全性证明 - 第二部分 第一部分的证明是不完备的，因为它假设了σ1和σ2总是存在共同未来状态。共同的未来状态σ3并不是说σ1和σ2一定要向此状态进行转换，而是作为证明中的一个跳板，通过两个引理的依次代入而得出σ1和σ2之间的确定性关系。只要σ1和σ2存在任何理论上共同的未来状态，那么第一部分的证明总是有效的。因此接下来需要考虑：σ1和σ2是否总是存在共同的未来状态？ 4.1 非平凡 Non-triviality 非平凡是数学用语，比如“零除以任何实数都等于零”这个命题在0这个实数上是非平凡的。非平凡表示存在某种特例。 在TFG中，协议状态即是消息的集合。那么对于任意两个协议状态σ1和σ2，它们的并集σ1∪σ2必定是它们的共同未来状态。这个推导看上去是没有问题的，但它却是非平凡的。 在有这样一种情况：如果命题p和逆命题¬p在σ0状态都不是估值安全的。 σ0状态有两个后续状态σ1和σ2，其中命题p在σ1状态下是估值安全的，逆命题¬p在σ2状态下也是估值安全的。 首先假设σ1和σ2在这种情况下有共同的未来状态σ3 根据引理I，S(p,σ1) ⇒ S(p,σ3), S(¬p,σ1) ⇒ S(¬p,σ3)。即S(p,σ3) ∧ S(¬p,σ3)，命题p和逆命题¬p在σ3状态下同时安全。 根据引理II，S(p,σ3) ⇒ ¬S(¬p, σ3)，命题p和逆命题¬p在σ3状态下不可能同时安全。 上述两部推导结果矛盾，因此假设不成立。σ1和σ2在这种情况下不可能有共同的未来状态。 具体到RChain中，消息状态树的区块总是增加的，假设有两颗不同的消息状态树，如果把它们的区块合并成一颗新的消息状态树，即是它们的共同未来状态。这种说法貌似是正确的，但如果某个恶意验证者在某个状态下（也就是某个高度），输出了两个截然不同的区块且分支选择不同。那么这个恶意验证者生成的这两个区块是无法合并到同一颗消息状态树中，也就没有共同的未来状态。恶意验证者的这种行为称之为“模棱两可”(Equivocation)，它属于拜占庭错误，具体的细节后文再论。 “零除以任何实数都等于零”这个命题加上额外条件排除非平凡域后，就有了“零除以任何非零实数都等于零”这个正确的命题了。 同样， 对于原命题“σ1∪σ2是σ1和σ2的共同未来状态”加上额外的条件“σ1∪σ2中具有少于N个拜占庭错误”就排除掉非平凡域，这个命题就是正确的了。 所以验证者需要计算(count)拜占庭错误以便将它们排除掉。 4.2 结论 将上面第一部分和第二部分结合起来，有： 在少于N个拜占庭错误的情况下，协议参与者如果都做出估值安全的决定，必将有共识安全。 因此需要引入保证金机制(PoS)从经济利益的层面上来避免验证者成为拜占庭叛徒。 5 错误类型 现在回过头去看，验证者在打包的过程中，可能存在下面几类错误。 5.1 无效的消息 这个很好剔除掉，验证者在接收到其它验证者的区块时，必须在本地重算(replay)一次得到相同的结果才能加入到本地的消息状态树。因此无效的消息不可能触发协议状态转换。 5.2 消息延迟、丢失或者乱序 由于Casper是异步协议，消息(区块)发送给其它验证者并不需要确认返回，因此可能由于网络原因导致消息的延迟、丢失或者乱序。乱序比较好处理，因为每个区块都有justifications字段，能够方便地在消息状态树中重建出正确的顺序。对于延迟或丢失，接收方是无法分辨是由于网络原因造成还是发送方造成，因此使用同样的逻辑处理它们a。消息延迟、丢失会对共识协议的活性(liveness)产生负面影响，也就是延迟区块达到最终安全性的时间。因此Casper并不是完全异步的协议，会有超时判断机制。 如果出现某验证者经常性地延迟或丢失消息，会进入一个同步的过程将此验证者从验证池中踢出(eject)，以保证共识协议的活性。至于会不会对保证金进行少量的罚没，目前还没有定论。 5.3 Equivocation 从攻击者的角度来说，想要对其它验证者的协议状态产生不利影响并不是那么容易的事情。 首先区块内包含的状态改变必须依据规则化简，否则就是前文中的无效消息。其次，如果故意丢失或者延迟消息，则会被踢出。拜占庭叛徒验证者在打包过程中，唯一能够做手脚的在于估值e = ε(σ)，也就是对父区块的选择上。但也不是那么容易，因为ε对于所有的验证者都是一致的，所以验证者并不能随意地为新区块选择父区块。 RChain为了提高并行度，特别是吞吐率，必须允许所有验证者能够同时打包且它们的包有可能同时进入到DAG链。这也是选择CasperTFG的原因-如果RChain采用BTC那样的方式每次只允许一个验证者出块,必将大大限制并行度。在这样的情况下，每个验证者任何时候都能够出块，而且打包的成本很低。这就会导致Nothing-at-stake的问题。 而且，验证者有动机这么做：只有进入到DAG被认可的分支才能收到Rewards，那么验证者为了提高自己获得奖励的概率，小心地构造σ，在同一高度输出多个不同分支选择的块。从而会引起上文所说的Equivocation。如果全网的拜占庭错误数过大，最终会导致共识失败，也就是无法取得一致性。 PoS对这类行为的惩罚是非常严厉的。发现一次会罚没所有的保证金。 每个区块中有signature字段，由打包的验证者签名无法伪造。如果其它验证者发现某验证者在同一高度有两个不同的区块，通过调用PoS的Slash API罚没验证者所有的保证金。 当然，检举的验证者会获得奖励，来源于保证金。这就是PoS防止拜占庭错误的机制：每个验证者的stake也是其它验证者监督它的奖金。 本文地址:https://blog.csdn.net/wangjia184/article/details/81059229 转载须注明出处。 下一篇《Casper共识之预言机》 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/07/16/72fcf959f9b4ae42f97e48f200b64405.html","headline":"RChain运行原理[6] - Casper共识之安全性","dateModified":"2018-07-16T00:00:00+08:00","datePublished":"2018-07-16T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/07/16/72fcf959f9b4ae42f97e48f200b64405.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>RChain运行原理[6] - Casper共识之安全性</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>在上一篇《<a href="https://blog.csdn.net/wangjia184/article/details/80813671" rel="nofollow">Casper共识之估值函数</a>》中介绍了验证者(validator)在打包区块时选择父级区块的逻辑，还剩下了一个问题-区块(block)在加入到DAG链后何时才能被认可？ <br> 认可即为共识，在解决“如何做”之前需要理解“为什么要这样”，所以本篇是下一篇的铺垫，解释Casper共识的原理。</p> 
  <h1 id="1-概述">1 概述</h1> 
  <p><strong>共识协议是在分布式环境中对某个命题在拜占庭容错度内(Byzantine Fault Tolerance)达成一致的算法。</strong></p> 
  <p>Casper协议分为两部分</p> 
  <ul> 
   <li><strong>Casper CBC</strong>(Correct By Construction) : CBC是一个高度抽象的共识协议框架，同时也是方法论与过程。 <br> 在各类实际的应用中，需要达成共识的命题逻辑多种多样。而CBC本身将具体的命题逻辑剥离出去，不关注具体的使用场景，然后建立通用的模型并证明此模型具有的特性。 <br> 这样CBC就是一个通用的共识协议框架，能够适用于各种场景。</li> 
   <li><strong>派生协议</strong> : 针对某个具体的场景与特定的命题逻辑，在CBC框架内进行细化与适配，从而得到具体的共识协议。 <br> 
    <ul>
     <li>比如全网需要在选择0和1这个命题上达成共识，则发展出来了Casper the Friendly Binary</li> 
     <li>上一篇中讲到的通过GHOST对DAG链进行分支选择。分支选择也是一个需要达成共识的命题，因此就有了RChain所采用的Casper TFG(the Friendly GHOST)</li>
    </ul></li> 
  </ul> 
  <p>所有这些派生协议无须再次证明自然地继承了CBC的<strong>安全性</strong>(Safety) : 所有遵循协议的结点做出的选择都是一致的，它们不会做出相互冲突的选择。</p> 
  <h1 id="2-模型">2 模型</h1> 
  <p>了解CBC协议可以查阅Vlad的<a href="https://github.com/ethereum/research/blob/master/papers/cbc-consensus/AbstractCBC.pdf" rel="nofollow">论文</a>。由于CBC是一个共识协议的抽象框架，直接理解起来有点费力。 <br> 本文尝试结合RChain，对论文中的推导步骤尽量做出相对通俗的解释。</p> 
  <h2 id="21-定义协议状态与转换">2.1 定义：协议状态与转换</h2> 
  <p>首先，CBC定义了两个基本概念：协议状态(protocol states)和状态转换(transitions)。</p> 
  <ul> 
   <li>协议状态用<code>σ</code>表示，代表协议处于的某种状态。</li> 
   <li>状态转换用<code>−→</code>表示。代表协议状态转换到了某个后续的状态。比如<code>σ −→ σ'</code>就表示协议状态<code>σ</code>转换到了状态<code>σ'</code></li> 
  </ul> 
  <p>同时协议状态也定义了两个基本性质</p> 
  <ul> 
   <li>传递性(transitivity) <code>σ1 −→ σ2 ∧ σ2 −→ σ3 ⇒ σ1 −→ σ3</code> 如果<code>σ1</code>转换为<code>σ2</code>,<code>σ2</code>转换到<code>σ3</code>, 那么<code>σ1</code>能够转换到<code>σ3</code></li> 
   <li>同一性(identity) <code>σ −→ σ</code> 每个状态都有个固有的状态转换到它自身</li> 
  </ul> 
  <p><strong>解释</strong>： <br> 协议状态是一个抽象的概念，在TFG中，协议状态具象成了消息的集合。具体到RChain中，协议状态即是前文中讲的消息状态树，其中包含了所有收到的以及当前验证者生成的区块。 <br> 而状态的转换即是在共识过程中对应的协议状态改变。在TFG中是消息集合的变化。具体在RChain中，当前验证者生成区块或者接受到来自其它验证者生成的区块，都会导致消息状态树的改变，这种改变即是转换。</p> 
  <h2 id="22-定义估值函数-estimator">2.2 定义：估值函数 Estimator</h2> 
  <p>在上一篇中介绍的估值函数<code>ε</code>，在CBC中的定义为<code>ε : |Σ| -&gt; Prop(C)</code>。</p> 
  <ul> 
   <li><code>|Σ|</code> 定义为所有的协议状态以及协议状态的转换</li> 
   <li><code>-&gt; Prop(C)</code> 得出共识<code>C</code>的命题(propositions)</li> 
  </ul> 
  <p><strong>解释</strong>： <br> 估值函数根据协议状态与已经它们之间的转换得出某需要共识的命题。在TFG中有 <code>e = ε(σ)</code>，根据消息状态树的状态选择父区块，也就是分支选择。</p> 
  <h2 id="23-定义估值安全-estimate-safety">2.3 定义：估值安全 Estimate Safety</h2> 
  <p>估值函数<code>ε(σ) =&gt; p</code>返回的估值(estimate)是命题<code>p</code>。在TFG中命题是某个分支选择。在RChain中具体到新区块的父区块选择。</p> 
  <p>CBC中对估值的安全性(estimate safety)定义：<code>S(p,σ) &lt;=&gt; ∀ σ', σ−→σ' ε(σ') =&gt; p</code>。</p> 
  <ul> 
   <li><code>S(p,σ)</code> 表示<code>p</code>在<code>σ</code>状态下是安全的</li> 
   <li><code>&lt;=&gt;</code> 当且仅当</li> 
   <li><code>∀ σ', σ−→σ'</code> 表示<code>σ'</code>是<code>σ</code>任意的未来状态</li> 
   <li><code>ε(σ') =&gt; p</code> 估值函数对于<code>σ'</code>状态输出<code>p</code></li> 
  </ul> 
  <p><strong>解释</strong>：对于<code>σ</code>的任意未来状态<code>σ'</code>，当且仅当<code>ε(σ')</code>输出<code>p</code>，则<code>p</code>在<code>σ</code>状态下是安全的。 <br> 具体到RChain，如果某个区块选择的分支是未来任意后续区块选择分支的一部分，那么这个区块的选择就是安全的。 <br> 估值安全是一种本地属性(local property)，它表示在某个验证者的视角内，对于某个区块的分支选择与历史区块以及未来区块的分支选择之间的关系。</p> 
  <h2 id="24-定义共同未来状态-σ1-σ2">2.4 定义：共同未来状态 <code>σ1 ∼ σ2</code></h2> 
  <p><code>σ1 ∼ σ2 &lt;=&gt; ∃σ3 : (σ1 → σ3) ∧ (σ2 → σ3)</code></p> 
  <ul> 
   <li><code>σ1 ∼ σ2</code> 表示<code>σ1</code>与<code>σ2</code>存在共同的未来状态</li> 
   <li><code>&lt;=&gt;</code> 当且仅当</li> 
   <li><code>(σ1 → σ3) ∧ (σ2 → σ3)</code> <code>σ3</code>是它们各自的未来状态</li> 
  </ul> 
  <p><img src="https://img-blog.csdn.net/20180716080147416?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdqaWExODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p><strong>解释</strong>：<code>σ1</code>和<code>σ2</code>共同未来状态表示它们都能够转换到相同的状态<code>σ3</code>。特别要注意的是，此定义的重点在于<strong>存在</strong>某种共同的未来状态，并不是说双方一定要向此未来状态转换。</p> 
  <h1 id="3-安全性证明-第一部分">3 安全性证明 - 第一部分</h1> 
  <p>从上面的定义出发开始证明。</p> 
  <h2 id="31-引理i前向安全性-forwards-safety">3.1 引理I：前向安全性 Forwards Safety</h2> 
  <p><code>∀σ' : σ−→σ', S(p,σ) ⇒ S(p,σ')</code></p> 
  <p><strong>解释</strong>：证明过程如下</p> 
  <ul> 
   <li>对于<code>σ'</code>的任意未来状态<code>σ''</code>，由于状态的传递性<code>σ−→σ'−→σ''</code>，<code>σ''</code>是<code>σ'</code>的未来状态必定也是<code>σ</code>的未来状态。</li> 
   <li><code>p</code>在<code>σ</code>状态下是安全的，根据估值安全的定义，对于<code>σ</code>的任意未来状态都会输出同样的命题<code>p</code>。</li> 
   <li>因此对于<code>σ'</code>的任意未来状态<code>σ''</code>，都有<code>ε(σ'') =&gt; p</code>, 这正是估值安全的定义，所以有<code>S(p,σ')</code>。</li> 
  </ul> 
  <p>所以有：如果<code>p</code>在<code>σ</code>状态下是安全的，那么<code>p</code>在<code>σ</code>的任意未来状态<code>σ'</code>下也是安全的。 <br> 在RChain中的含义是，<strong>如果某区块的分支选择是安全的，那么对于未来任意区块该选择都是安全的</strong>。</p> 
  <h2 id="32-引理ii当前一致性-current-consistency">3.2 引理II：当前一致性 Current Consistency</h2> 
  <p><code>S(p, σ) ⇒ ¬S(¬p, σ)</code></p> 
  <p><strong>解释</strong>：证明过程如下</p> 
  <ul> 
   <li>如果<code>p</code>在<code>σ</code>状态下是安全的，那么对于<code>σ</code>的任意未来状态<code>σ'</code>都有<code>ε(σ') =&gt; p</code></li> 
   <li><code>¬p</code>是<code>p</code>的逆命题，<code>p</code>和<code>¬p</code>不可能同时为真。</li> 
   <li>而任意未来状态下<code>ε(σ')</code>都是输出<code>p</code>命题，不可能输出<code>¬p</code></li> 
   <li>那么<code>S(¬p, σ)</code>一定为假，也就是说<code>¬p</code>在<code>σ</code>状态下是不安全的，也就是<code>¬S(¬p, σ)</code></li> 
  </ul> 
  <p>这条引理的含义是，如果<code>p</code>是<code>σ</code>状态下安全的估值，那么其它与此估值矛盾的估值都是不安全的。 <br> 在TFG中的含义是，<strong>在某区块的分支选择上，不存在多个相互矛盾且安全的分支选择</strong>。 <br> 比如命题<code>p</code>在某区块表示“选择分支a”；那么<code>¬p</code>表示“不选择分支a”。 <br> 如果“选择分支a”是安全的，那么“不选择分支a”的其它分支选择肯定是不安全的。</p> 
  <h2 id="33-引理iii后向一致性-backwards-consistency">3.3 引理III：后向一致性 Backwards Consistency</h2> 
  <p><code>∀σ : σ → σ', S(p, σ') ⇒ ¬S(¬p, σ)</code></p> 
  <p><strong>解释</strong>：如果<code>p</code>在<code>σ'</code>状态下是安全的，那么它的逆命题<code>¬p</code>在此状态的前置状态下一定是不安全的。 <br> 证明此引理需要反证法。</p> 
  <ul> 
   <li>首先假设逆命题<code>¬p</code>在<code>σ</code>状态下是安全的</li> 
   <li>根据引理I，<code>¬p</code>在<code>σ</code>的任意未来状态<code>σ'</code>下也是安全的，即<code>S(¬p, σ')</code></li> 
   <li>根据引理II，有<code>¬S(p, σ')</code>，而这与<code>S(p, σ')</code>矛盾</li> 
   <li>因此，逆命题<code>¬p</code>在<code>σ</code>状态下一定是不安全的，即<code>¬S(¬p, σ)</code></li> 
  </ul> 
  <p>在RChain中的含义:<strong>如果某区块的分支选择是安全的，那么任何前置区块中与当前分支选择矛盾的选择都是不安全的</strong>。</p> 
  <h2 id="34-证明从估值安全到共识安全">3.4 证明：从估值安全到共识安全</h2> 
  <p>在这里先假设<code>σ1</code>和<code>σ2</code>有共同的未来状态<code>σ3</code>,也就是<code>σ1 ∼ σ2</code>。在此假设的基础上做如下推导：</p> 
  <ul> 
   <li>在<code>σ1</code>和它的未来状态<code>σ3</code>间使用引理I，得出 <code>S(p,σ1) ⇒ S(p,σ3)</code>。即<code>p</code>如果在<code>σ1</code>状态安全一定也在<code>σ3</code>状态下安全。</li> 
   <li>在<code>σ3</code>和它的过去状态<code>σ2</code>间使用引理III，得出 <code>S(p,σ3) ⇒ ¬S(¬p,σ2)</code>。即<code>p</code>如果在<code>σ3</code>状态下安全则它的逆命题<code>¬p</code>在过去状态<code>σ2</code>一定不安全。</li> 
  </ul> 
  <p><img src="https://img-blog.csdn.net/20180716080240869?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdqaWExODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <p>因此<code>σ1</code>和<code>σ2</code>彼此之间也有了关系：<code>S(p,σ1) ⇒ ¬S(¬p,σ2)</code>, 而它等价于</p> 
  <ul> 
   <li><code>¬(S(p, σ1) ∧ S(¬p, σ2))</code> 不可能同时存在命题<code>p</code>在<code>σ1</code>状态估值安全而逆命题<code>¬p</code>在<code>σ2</code>状态也估值安全</li> 
   <li><code>¬S(p, σ1) ∨ ¬S(¬p, σ2)</code> 不可能同时存在命题<code>p</code>在<code>σ1</code>状态估值不安全而逆命题<code>¬p</code>在<code>σ2</code>状态也估值不安全</li> 
  </ul> 
  <p>命题<code>p</code>在具有未来共同未来状态的<code>σ1</code>和<code>σ2</code>中，要么命题<code>p</code>对于它们都是安全的;要么逆命题<code>¬p</code>对于它们都是安全的。而协议的参与者如果都做出使命题<code>p</code>都对于自己的协议状态估值安全的决定，它们就命题<code>p</code>做出了一致的决定，不会产生冲突。这也就<strong>证明了共识协议的安全性</strong>(Safety)。</p> 
  <p>具体到RChain中，有两个验证者v1和v2。v1在σ1状态下做出了估值安全的分支选择e1，同时v2在σ2状态下做出了安全估值的分支选择e2，现在假设它们有一个未来的共同状态σ3。根据<code>e = ε(σ)</code>，它们必定在未来的共同状态选择了相同的分支。而又根据估值安全的定义，e1/e2这两个分支选择必定被未来的分支选择包含，它们在未来某刻选择了相同的分支。而GHOST选择的分支是唯一的，那么可以直观得到e1和e2这两个分支选择必定是其中一个包含（或等于）另外一个。也就是说，验证者选择的分支必定一致。</p> 
  <p>结论：<strong>具有共同未来状态的协议参与者如果都做出估值安全的决定，必将有共识安全</strong>。</p> 
  <h1 id="4-安全性证明-第二部分">4 安全性证明 - 第二部分</h1> 
  <p>第一部分的证明是不完备的，因为它假设了<code>σ1</code>和<code>σ2</code>总是存在共同未来状态。共同的未来状态<code>σ3</code>并不是说<code>σ1</code>和<code>σ2</code>一定要向此状态进行转换，而是作为证明中的一个跳板，通过两个引理的依次代入而得出<code>σ1</code>和<code>σ2</code>之间的确定性关系。只要<code>σ1</code>和<code>σ2</code>存在任何理论上共同的未来状态，那么第一部分的证明总是有效的。因此接下来需要考虑：<code>σ1</code>和<code>σ2</code>是否<strong>总是</strong>存在共同的未来状态？</p> 
  <h2 id="41-非平凡-non-triviality">4.1 非平凡 Non-triviality</h2> 
  <p>非平凡是数学用语，比如“零除以任何实数都等于零”这个命题在0这个实数上是非平凡的。非平凡表示存在某种特例。</p> 
  <p>在TFG中，协议状态即是消息的集合。那么对于任意两个协议状态<code>σ1</code>和<code>σ2</code>，它们的并集<code>σ1∪σ2</code>必定是它们的共同未来状态。这个推导看上去是没有问题的，但它却是<strong>非平凡</strong>的。</p> 
  <p>在有这样一种情况：如果命题<code>p</code>和逆命题<code>¬p</code>在<code>σ0</code>状态都不是估值安全的。 <br> <code>σ0</code>状态有两个后续状态<code>σ1</code>和<code>σ2</code>，其中命题<code>p</code>在<code>σ1</code>状态下是估值安全的，逆命题<code>¬p</code>在<code>σ2</code>状态下也是估值安全的。 <br> <img src="https://img-blog.csdn.net/20180716080413811?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdqaWExODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p> 
  <ul> 
   <li>首先假设<code>σ1</code>和<code>σ2</code>在这种情况下有共同的未来状态<code>σ3</code></li> 
   <li>根据引理I，<code>S(p,σ1) ⇒ S(p,σ3)</code>, <code>S(¬p,σ1) ⇒ S(¬p,σ3)</code>。即<code>S(p,σ3) ∧ S(¬p,σ3)</code>，命题<code>p</code>和逆命题<code>¬p</code>在<code>σ3</code>状态下同时安全。</li> 
   <li>根据引理II，<code>S(p,σ3) ⇒ ¬S(¬p, σ3)</code>，命题<code>p</code>和逆命题<code>¬p</code>在<code>σ3</code>状态下不可能同时安全。</li> 
   <li>上述两部推导结果矛盾，因此假设不成立。<code>σ1</code>和<code>σ2</code>在这种情况下不可能有共同的未来状态。</li> 
  </ul> 
  <p>具体到RChain中，消息状态树的区块总是增加的，假设有两颗不同的消息状态树，如果把它们的区块合并成一颗新的消息状态树，即是它们的共同未来状态。这种说法貌似是正确的，但如果某个恶意验证者在某个状态下（也就是某个高度），输出了两个截然不同的区块且分支选择不同。那么这个恶意验证者生成的这两个区块是无法合并到同一颗消息状态树中，也就没有共同的未来状态。恶意验证者的这种行为称之为“模棱两可”(Equivocation)，它属于拜占庭错误，具体的细节后文再论。</p> 
  <p>“零除以任何实数都等于零”这个命题加上额外条件排除非平凡域后，就有了“零除以任何非零实数都等于零”这个正确的命题了。 <br> 同样， 对于原命题“<code>σ1∪σ2</code>是<code>σ1</code>和<code>σ2</code>的共同未来状态”加上额外的条件“<code>σ1∪σ2</code>中具有少于N个拜占庭错误”就排除掉非平凡域，这个命题就是正确的了。 <br> 所以验证者需要计算(count)拜占庭错误以便将它们排除掉。</p> 
  <h2 id="42-结论">4.2 结论</h2> 
  <p>将上面第一部分和第二部分结合起来，有： <br> <strong>在少于N个拜占庭错误的情况下，协议参与者如果都做出估值安全的决定，必将有共识安全。</strong> <br> 因此需要引入保证金机制(PoS)从经济利益的层面上来避免验证者成为拜占庭叛徒。</p> 
  <h1 id="5-错误类型">5 错误类型</h1> 
  <p>现在回过头去看，验证者在打包的过程中，可能存在下面几类错误。</p> 
  <h2 id="51-无效的消息">5.1 无效的消息</h2> 
  <p>这个很好剔除掉，验证者在接收到其它验证者的区块时，必须在本地重算(replay)一次得到相同的结果才能加入到本地的消息状态树。因此无效的消息不可能触发协议状态转换。</p> 
  <h2 id="52-消息延迟丢失或者乱序">5.2 消息延迟、丢失或者乱序</h2> 
  <p>由于Casper是异步协议，消息(区块)发送给其它验证者并不需要确认返回，因此可能由于网络原因导致消息的延迟、丢失或者乱序。乱序比较好处理，因为每个区块都有<code>justifications</code>字段，能够方便地在消息状态树中重建出正确的顺序。对于延迟或丢失，接收方是无法分辨是由于网络原因造成还是发送方造成，因此使用同样的逻辑处理它们a。消息延迟、丢失会对共识协议的活性(liveness)产生负面影响，也就是延迟区块达到最终安全性的时间。因此Casper并不是完全异步的协议，会有超时判断机制。 <br> 如果出现某验证者经常性地延迟或丢失消息，会进入一个同步的过程将此验证者从验证池中踢出(eject)，以保证共识协议的活性。至于会不会对保证金进行少量的罚没，目前还没有定论。</p> 
  <h2 id="53-equivocation">5.3 Equivocation</h2> 
  <p>从攻击者的角度来说，想要对其它验证者的协议状态产生不利影响并不是那么容易的事情。 <br> 首先区块内包含的状态改变必须依据规则化简，否则就是前文中的无效消息。其次，如果故意丢失或者延迟消息，则会被踢出。拜占庭叛徒验证者在打包过程中，唯一能够做手脚的在于估值<code>e = ε(σ)</code>，也就是对父区块的选择上。但也不是那么容易，因为<code>ε</code>对于所有的验证者都是一致的，所以验证者并不能随意地为新区块选择父区块。</p> 
  <p>RChain为了提高并行度，特别是吞吐率，必须允许所有验证者能够同时打包且它们的包有可能同时进入到DAG链。这也是选择CasperTFG的原因-如果RChain采用BTC那样的方式每次只允许一个验证者出块,必将大大限制并行度。在这样的情况下，每个验证者任何时候都能够出块，而且打包的成本很低。这就会导致Nothing-at-stake的问题。</p> 
  <p>而且，验证者有动机这么做：只有进入到DAG被认可的分支才能收到Rewards，那么验证者为了提高自己获得奖励的概率，小心地构造<code>σ</code>，在同一高度输出多个不同分支选择的块。从而会引起上文所说的Equivocation。如果全网的拜占庭错误数过大，最终会导致共识失败，也就是无法取得一致性。 <br> PoS对这类行为的惩罚是非常严厉的。发现一次会罚没所有的保证金。 <br> 每个区块中有<code>signature</code>字段，由打包的验证者签名无法伪造。如果其它验证者发现某验证者在同一高度有两个不同的区块，通过调用PoS的Slash API罚没验证者所有的保证金。 <br> 当然，检举的验证者会获得奖励，来源于保证金。这就是PoS防止拜占庭错误的机制：每个验证者的stake也是其它验证者监督它的奖金。</p> 
  <p>本文地址:<a href="https://blog.csdn.net/wangjia184/article/details/81059229" rel="nofollow">https://blog.csdn.net/wangjia184/article/details/81059229</a> <br> 转载须注明出处。</p> 
  <p>下一篇《<a href="https://blog.csdn.net/wangjia184/article/details/81059271" rel="nofollow">Casper共识之预言机</a>》</p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wangjia184/article/details/81059229,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wangjia184/article/details/81059229,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
