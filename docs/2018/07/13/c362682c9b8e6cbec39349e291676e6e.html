<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Bitcoinj开发 WalletAppKit 生成钱包，恢复钱包，发送btc | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Bitcoinj开发 WalletAppKit 生成钱包，恢复钱包，发送btc" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1.测试网络 获取btc&nbsp;https://testnet.coinfaucet.eu/en/ https://live.blockcypher.com/ btc:https://github.com/Samourai-Wallet/samourai-wallet-android eth:https://gitter.im/web3j/web3j eos:https://eos.io/ 2.引入库 &nbsp; implementation &#39;org.bitcoinj:bitcoinj-core:0.14.7&#39; //btc 3.主要代码 public class BitUtil { public static final String passphrase = &quot;&quot;; /** * 通过Wallet 获取 助记词 * @param wallet * @return */ public static List&lt;String&gt; getSeedWordsFromWallet(Wallet wallet){ DeterministicSeed seed = wallet.getKeyChainSeed(); return seed.getMnemonicCode(); } /** * 通过私钥获取ECKey * @param priKey * @return */ public static ECKey getECKeyFromPriKey(String priKey){ ECKey ecKey = ECKey.fromPrivate(Numeric.toBigInt(priKey)); return ecKey; } public static String getPubKeyFrom(ECKey ecKey){ NetworkParameters params =getParams(); return ecKey.toAddress(params).toBase58().toString(); } //通过speed 获取钱包 public static Wallet getFromSpeed(String seedCode){ NetworkParameters params = getParams(); DeterministicSeed seed; try { seed = new DeterministicSeed(seedCode, null, passphrase,Utils.currentTimeSeconds() ); Wallet restoredWallet = Wallet.fromSeed(params, seed); return restoredWallet; } catch (UnreadableWalletException e) { e.printStackTrace(); } return null; } //通过本地文件获取Wallet public static Wallet getWalletFromFile(String filePath){ try { return Wallet.loadFromFile(new File(filePath)); } catch (UnreadableWalletException e) { e.printStackTrace(); } return null; } //发送交易 public static void send(Wallet wallet,String recipientAddress, String amount){ NetworkParameters params = getParams(); Address targetAddress = Address.fromBase58(params, recipientAddress); // Do the send of 1 BTC in the background. This could throw InsufficientMoneyException. SPVBlockStore blockStore = null; try { blockStore = new SPVBlockStore(params, getBLockFile()); } catch (BlockStoreException e) { e.printStackTrace(); } BlockChain chain = null; try { chain = new BlockChain(params, wallet,blockStore); PeerGroup peerGroup = new PeerGroup(params, chain); try { Wallet.SendResult result = wallet.sendCoins(peerGroup, targetAddress, Coin.parseCoin(amount)); // Save the wallet to disk, optional if using auto saving (see below). //wallet.saveToFile(....); // Wait for the transaction to propagate across the P2P network, indicating acceptance. try { Transaction transaction = result.broadcastComplete.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } return; } catch (InsufficientMoneyException e) { e.printStackTrace(); } } catch (BlockStoreException e) { e.printStackTrace(); } } public static String send(WalletAppKit walletAppKit,String recipientAddress, String amount){ NetworkParameters params = getParams(); String err = &quot;&quot;; if(TextUtils.isEmpty(recipientAddress) || recipientAddress.equals(&quot;Scan recipient QR&quot;)) { err = &quot;Select recipient&quot;; return err; } if(TextUtils.isEmpty(amount) | Double.parseDouble(amount) &lt;= 0) { err = &quot;Select valid amount&quot;; return err; } if(walletAppKit.wallet().getBalance().isLessThan(Coin.parseCoin(amount))) { err = &quot;You got not enough coins&quot;; return err; } SendRequest request = SendRequest.to(Address.fromBase58(params, recipientAddress), Coin.parseCoin(amount)); try { walletAppKit.wallet().completeTx(request); walletAppKit.wallet().commitTx(request.tx); walletAppKit.peerGroup().broadcastTransaction(request.tx).broadcast(); return &quot;&quot;; } catch (InsufficientMoneyException e) { e.printStackTrace(); return e.getMessage(); } } public static File getBLockFile(){ File file = new File(&quot;/tmp/bitcoin-blocks&quot;); if(!file.exists()){ try { boolean newFile = file.createNewFile(); if(newFile){ return file; } } catch (IOException e) { e.printStackTrace(); } } return file; } public static void getWallet(){ NetworkParameters params = getParams(); Wallet wallet = new Wallet(params); List&lt;ECKey&gt; keys = new ArrayList&lt;&gt;(); ECKey ecKey = new ECKey(); //加密eckey ecKey.encrypt(wallet.getKeyCrypter(),wallet.getKeyCrypter().deriveKey(&quot;123456&quot;)); keys.add(ecKey); wallet.importKeysAndEncrypt(keys,&quot;123456&quot;); try { SPVBlockStore blockStore = new SPVBlockStore(params, getBLockFile()); BlockChain chain = new BlockChain(params, wallet,blockStore); PeerGroup peerGroup = new PeerGroup(params, chain); peerGroup.addWallet(wallet); peerGroup.startAsync(); peerGroup.downloadBlockChain(); //startAndWait() } catch (BlockStoreException e) { e.printStackTrace(); } } public static void testAddress(Wallet wallet){ Address a = wallet.currentReceiveAddress(); ECKey b = wallet.currentReceiveKey(); Address c = wallet.freshReceiveAddress(); } public static void userSPeed(Wallet wallet){ NetworkParameters params = getParams(); DeterministicSeed seed = wallet.getKeyChainSeed(); println(&quot;Seed words are: &quot; + Joiner.on(&quot; &quot;).join(seed.getMnemonicCode())); println(&quot;Seed birthday is: &quot; + seed.getCreationTimeSeconds()); //通过speed 获取Wallet String seedCode = &quot;yard impulse luxury drive today throw farm pepper survey wreck glass federal&quot;; String seedCode2 = &quot;liberty identify erase shuffle dignity armed produce mention actual you top vendor&quot;; long creationtime = 1409478661L; DeterministicSeed seed2; try { seed2 = new DeterministicSeed(seedCode, null, &quot;&quot;, creationtime); Wallet restoredWallet = Wallet.fromSeed(params, seed2); } catch (UnreadableWalletException e) { e.printStackTrace(); } } public static NetworkParameters getParams(){ return Constant.IS_PRODUCTION ? MainNetParams.get() : TestNet3Params.get(); } public static void t(Wallet wallet,String recipientAddress,String password,String mount){ Address a =Address.fromBase58(getParams(), recipientAddress); SendRequest req = SendRequest.to(a, Coin.parseCoin(mount)); req.aesKey = wallet.getKeyCrypter().deriveKey(password); try { wallet.sendCoins(req); } catch (InsufficientMoneyException e) { e.printStackTrace(); } } public static void watchAddress(){ Wallet toWatch = null; DeterministicKey watchingKey = toWatch.getWatchingKey(); String s = watchingKey.serializePubB58(getParams()); long creationTimeSeconds = watchingKey.getCreationTimeSeconds(); DeterministicKey key = DeterministicKey.deserializeB58(null, &quot;key data goes here&quot;,getParams()); Wallet wallet = Wallet.fromWatchingKey(getParams(), key); NetworkParameters params = TestNet3Params.get(); DeterministicSeed seed = new DeterministicSeed(new SecureRandom(),128,&quot;password&quot;, Utils.currentTimeSeconds()); wallet = Wallet.fromSeed(params,seed); //tobytes byte[] bytes = MnemonicCode.toSeed(new ArrayList&lt;&gt;(), passphrase); } public static void test(){ NetworkParameters params = TestNet3Params.get(); DeterministicSeed seed = new DeterministicSeed(new SecureRandom(),128,&quot;123456&quot;,Utils.currentTimeSeconds()); List&lt;String&gt; mnemonicCode = seed.getMnemonicCode(); LogUtil.e(&quot;mnemonicCode&quot;+mnemonicCode); // byte[] bytes = MnemonicCode.toSeed(mnemonicCode, &quot;123456&quot;); Wallet wallet = Wallet.fromSeed(params,seed); } public static void test2(ECKey ceKey){ NetworkParameters params =getParams(); String s = ceKey.toAddress(params).toBase58().toString(); String privateKeyAsWiF = ceKey.getPrivateKeyAsWiF(params);// 私钥， WIF(Wallet Import Format) LogUtil.e(privateKeyAsWiF+&quot;==========&quot;+s); } //通过私钥拿到eckey public static ECKey getECkey(String prikey){ ECKey key = DumpedPrivateKey.fromBase58(getParams(), prikey).getKey(); return key; } //通过助记词导入新钱包 public static Wallet createWallet(String seedCode,String password) { KeyChainGroup kcg; DeterministicSeed deterministicSeed = null; try { deterministicSeed = new DeterministicSeed(seedCode, null, password, Utils.currentTimeSeconds()); } catch (UnreadableWalletException e) { e.printStackTrace(); } kcg = new KeyChainGroup(getParams(), deterministicSeed); Wallet wallet = new Wallet(getParams(), kcg); return wallet; } //创建新钱包。 public static Wallet createWallet2() { KeyChainGroup kcg = new KeyChainGroup(getParams()); Wallet wallet = new Wallet(getParams(), kcg); wallet.getParams().getId(); return wallet; } //通过助记词 public static WalletAppKit getWalletKit(Context context,String seedcode){ WalletAppKit walletAppKit = new WalletAppKit(getParams(), context.getCacheDir(), Constant.WALLET_NAME) { @Override protected void onSetupCompleted() { if (wallet().getImportedKeys().size() &lt; 1) wallet().importKey(new ECKey()); wallet().allowSpendingUnconfirmedTransactions(); setupWalletListeners(wallet()); ECKey ecKey = wallet().getImportedKeys().get(0); LogUtil.e(getPubKeyFrom(ecKey)); // test2(ecKey); // //打印助记词 List&lt;String&gt; seedWordsFromWallet = getSeedWordsFromWallet(wallet()); LogUtil.e(seedWordsFromWallet.toString()); //当前地址 String s1 = wallet().currentReceiveAddress().toBase58(); // String s2 = wallet().currentChangeAddress().toBase58(); String privateKeyAsWiF = wallet().currentReceiveKey().getPrivateKeyAsWiF(getParams()); LogUtil.e(&quot;currentReceiveAddress=&quot;+s1+&quot;===privateKeyAsWiF=&quot;+privateKeyAsWiF); //LogUtil.e(&quot;freshReceiveAddress=&quot;+s+&quot;===&quot;+&quot;currentReceiveAddress=&quot;+s1); } }; walletAppKit.setAutoSave(true); walletAppKit.setBlockingStartup(false); setDownListener(walletAppKit); if (getParams() == RegTestParams.get()) { AppContext.walletAppKit.connectToLocalHost(); } if(!StringUtils.isEmpty(seedcode)){ try { DeterministicSeed seed = new DeterministicSeed(seedcode, null, passphrase,Utils.currentTimeSeconds()); walletAppKit.restoreWalletFromSeed(seed); } catch (UnreadableWalletException e) { e.printStackTrace(); } } walletAppKit.startAsync(); walletAppKit.awaitRunning(); return walletAppKit; } //加载本地文件 public static WalletAppKit getWalletKit(Context context){ return getWalletKit(context,&quot;&quot;); } public static void setDownListener(WalletAppKit walletAppKit){ walletAppKit.setDownloadListener(new DownloadProgressTracker() { @Override protected void progress(double pct, int blocksSoFar, Date date) { super.progress(pct, blocksSoFar, date); int percentage = (int) pct; LogUtil.e(percentage+&quot;percentage&quot;); } @Override protected void doneDownload() { super.doneDownload(); String myAddress = walletAppKit.wallet().currentReceiveAddress().toBase58(); String s = walletAppKit.wallet().getBalance().toFriendlyString(); BtcData btcData = new BtcData(myAddress,s); RxBus.getInstance().send(new MessageModel(BTC_DATA,btcData)); LogUtil.e(myAddress+&quot;==&quot;+s); } }); } public static void setupWalletListeners(Wallet wallet) { wallet.addCoinsReceivedEventListener((wallet1, tx, prevBalance, newBalance) -&gt; { String s = wallet.getBalance().toFriendlyString(); String s1 = &quot;&quot;; if(tx.getPurpose() == Transaction.Purpose.UNKNOWN) { s1 = newBalance.minus(prevBalance).toFriendlyString(); } LogUtil.e(s+&quot;===&quot;+s1); }); wallet.addCoinsSentEventListener((wallet12, tx, prevBalance, newBalance) -&gt; { String s = wallet.getBalance().toFriendlyString(); String s1 = &quot;Sent &quot;+prevBalance.minus(newBalance).minus(tx.getFee()).toFriendlyString(); LogUtil.e(s+&quot;===&quot;+s1); }); } public void Test() { ECKey k1 = new ECKey(); // some random key // encrypting a key KeyCrypter crypter1 = new KeyCrypterScrypt(); KeyParameter aesKey1 = crypter1.deriveKey(&quot;some arbitrary passphrase&quot;); ECKey k2 = k1.encrypt(crypter1, aesKey1); //System.out.println(k2.isEncrypted()); // true // decrypting a key KeyCrypter crypter2 = k2.getKeyCrypter(); KeyParameter aesKey2 = crypter2.deriveKey(&quot;some arbitrary passphrase&quot;); ECKey k3 = k2.decrypt(aesKey2); //System.out.println(k1.equals(k3)); // true } public static void closedWallet(){ AppContext.walletAppKit.stopAsync(); AppContext.walletAppKit.awaitTerminated(); } public static void test2(){ DeterministicKey deterministicKey = AppContext.walletAppKit.wallet().getWatchingKey().dropPrivateBytes(); deterministicKey = HDKeyDerivation.createMasterPubKeyFromBytes(deterministicKey.getPubKey(), deterministicKey.getChainCode()); String xPublicKey = deterministicKey.serializePubB58(getParams()); String privateKey= AppContext.walletAppKit.wallet().getKeyByPath(DeterministicKeyChain.ACCOUNT_ZERO_PATH).getPrivateKeyAsWiF(getParams()); Log.e(&quot;key&quot;, xPublicKey.toString()); Log.e(&quot;privatekey&quot;, privateKey.toString()); if (getParams() == RegTestParams.get()) { AppContext.walletAppKit.connectToLocalHost(); } } public static void si(String privateKey,String recipientAddress,String amount){ SendRequest request = SendRequest.to(Address.fromBase58(getParams(), recipientAddress), Coin.parseCoin(amount)); Signingtrasaction(privateKey,request.tx.getHashAsString()); } public static void Signingtrasaction(String wif, String msg) { try { // creating a key object from WiF DumpedPrivateKey dpk = DumpedPrivateKey.fromBase58(getParams(), wif); ECKey key = dpk.getKey(); // checking our key object // NetworkParameters main = MainNetParams.get(); String check = key.getPrivateKeyAsWiF(getParams()); System.out.println(wif.equals(check)); // true Log.e(&quot;wif check&quot;, String.valueOf(wif.equals(check))); // creating Sha object from string Sha256Hash hash = Sha256Hash.wrap(msg); // creating signature ECKey.ECDSASignature sig = key.sign(hash); // encoding byte[] res = sig.encodeToDER(); // converting to hex //String hex = DatatypeConverter.printHexBinary(res); // String hex = new String(res); String hex = android.util.Base64.encodeToString(res, 16); Log.e(&quot;sigendTransiction&quot;, hex.toString()); Log.e(&quot;decrypttx&quot;,&quot;&quot;+ Hex.decode(sig.encodeToDER())); } catch (Exception e) { //signingkey = ecdsa.from_string(privateKey.decode(&#39;hex&#39;), curve=ecdsa.SECP256k1) Log.e(&quot;signing exception&quot;, e.getMessage().toString()); } } } &nbsp; &nbsp; &nbsp; 阅读更多" />
<meta property="og:description" content="1.测试网络 获取btc&nbsp;https://testnet.coinfaucet.eu/en/ https://live.blockcypher.com/ btc:https://github.com/Samourai-Wallet/samourai-wallet-android eth:https://gitter.im/web3j/web3j eos:https://eos.io/ 2.引入库 &nbsp; implementation &#39;org.bitcoinj:bitcoinj-core:0.14.7&#39; //btc 3.主要代码 public class BitUtil { public static final String passphrase = &quot;&quot;; /** * 通过Wallet 获取 助记词 * @param wallet * @return */ public static List&lt;String&gt; getSeedWordsFromWallet(Wallet wallet){ DeterministicSeed seed = wallet.getKeyChainSeed(); return seed.getMnemonicCode(); } /** * 通过私钥获取ECKey * @param priKey * @return */ public static ECKey getECKeyFromPriKey(String priKey){ ECKey ecKey = ECKey.fromPrivate(Numeric.toBigInt(priKey)); return ecKey; } public static String getPubKeyFrom(ECKey ecKey){ NetworkParameters params =getParams(); return ecKey.toAddress(params).toBase58().toString(); } //通过speed 获取钱包 public static Wallet getFromSpeed(String seedCode){ NetworkParameters params = getParams(); DeterministicSeed seed; try { seed = new DeterministicSeed(seedCode, null, passphrase,Utils.currentTimeSeconds() ); Wallet restoredWallet = Wallet.fromSeed(params, seed); return restoredWallet; } catch (UnreadableWalletException e) { e.printStackTrace(); } return null; } //通过本地文件获取Wallet public static Wallet getWalletFromFile(String filePath){ try { return Wallet.loadFromFile(new File(filePath)); } catch (UnreadableWalletException e) { e.printStackTrace(); } return null; } //发送交易 public static void send(Wallet wallet,String recipientAddress, String amount){ NetworkParameters params = getParams(); Address targetAddress = Address.fromBase58(params, recipientAddress); // Do the send of 1 BTC in the background. This could throw InsufficientMoneyException. SPVBlockStore blockStore = null; try { blockStore = new SPVBlockStore(params, getBLockFile()); } catch (BlockStoreException e) { e.printStackTrace(); } BlockChain chain = null; try { chain = new BlockChain(params, wallet,blockStore); PeerGroup peerGroup = new PeerGroup(params, chain); try { Wallet.SendResult result = wallet.sendCoins(peerGroup, targetAddress, Coin.parseCoin(amount)); // Save the wallet to disk, optional if using auto saving (see below). //wallet.saveToFile(....); // Wait for the transaction to propagate across the P2P network, indicating acceptance. try { Transaction transaction = result.broadcastComplete.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } return; } catch (InsufficientMoneyException e) { e.printStackTrace(); } } catch (BlockStoreException e) { e.printStackTrace(); } } public static String send(WalletAppKit walletAppKit,String recipientAddress, String amount){ NetworkParameters params = getParams(); String err = &quot;&quot;; if(TextUtils.isEmpty(recipientAddress) || recipientAddress.equals(&quot;Scan recipient QR&quot;)) { err = &quot;Select recipient&quot;; return err; } if(TextUtils.isEmpty(amount) | Double.parseDouble(amount) &lt;= 0) { err = &quot;Select valid amount&quot;; return err; } if(walletAppKit.wallet().getBalance().isLessThan(Coin.parseCoin(amount))) { err = &quot;You got not enough coins&quot;; return err; } SendRequest request = SendRequest.to(Address.fromBase58(params, recipientAddress), Coin.parseCoin(amount)); try { walletAppKit.wallet().completeTx(request); walletAppKit.wallet().commitTx(request.tx); walletAppKit.peerGroup().broadcastTransaction(request.tx).broadcast(); return &quot;&quot;; } catch (InsufficientMoneyException e) { e.printStackTrace(); return e.getMessage(); } } public static File getBLockFile(){ File file = new File(&quot;/tmp/bitcoin-blocks&quot;); if(!file.exists()){ try { boolean newFile = file.createNewFile(); if(newFile){ return file; } } catch (IOException e) { e.printStackTrace(); } } return file; } public static void getWallet(){ NetworkParameters params = getParams(); Wallet wallet = new Wallet(params); List&lt;ECKey&gt; keys = new ArrayList&lt;&gt;(); ECKey ecKey = new ECKey(); //加密eckey ecKey.encrypt(wallet.getKeyCrypter(),wallet.getKeyCrypter().deriveKey(&quot;123456&quot;)); keys.add(ecKey); wallet.importKeysAndEncrypt(keys,&quot;123456&quot;); try { SPVBlockStore blockStore = new SPVBlockStore(params, getBLockFile()); BlockChain chain = new BlockChain(params, wallet,blockStore); PeerGroup peerGroup = new PeerGroup(params, chain); peerGroup.addWallet(wallet); peerGroup.startAsync(); peerGroup.downloadBlockChain(); //startAndWait() } catch (BlockStoreException e) { e.printStackTrace(); } } public static void testAddress(Wallet wallet){ Address a = wallet.currentReceiveAddress(); ECKey b = wallet.currentReceiveKey(); Address c = wallet.freshReceiveAddress(); } public static void userSPeed(Wallet wallet){ NetworkParameters params = getParams(); DeterministicSeed seed = wallet.getKeyChainSeed(); println(&quot;Seed words are: &quot; + Joiner.on(&quot; &quot;).join(seed.getMnemonicCode())); println(&quot;Seed birthday is: &quot; + seed.getCreationTimeSeconds()); //通过speed 获取Wallet String seedCode = &quot;yard impulse luxury drive today throw farm pepper survey wreck glass federal&quot;; String seedCode2 = &quot;liberty identify erase shuffle dignity armed produce mention actual you top vendor&quot;; long creationtime = 1409478661L; DeterministicSeed seed2; try { seed2 = new DeterministicSeed(seedCode, null, &quot;&quot;, creationtime); Wallet restoredWallet = Wallet.fromSeed(params, seed2); } catch (UnreadableWalletException e) { e.printStackTrace(); } } public static NetworkParameters getParams(){ return Constant.IS_PRODUCTION ? MainNetParams.get() : TestNet3Params.get(); } public static void t(Wallet wallet,String recipientAddress,String password,String mount){ Address a =Address.fromBase58(getParams(), recipientAddress); SendRequest req = SendRequest.to(a, Coin.parseCoin(mount)); req.aesKey = wallet.getKeyCrypter().deriveKey(password); try { wallet.sendCoins(req); } catch (InsufficientMoneyException e) { e.printStackTrace(); } } public static void watchAddress(){ Wallet toWatch = null; DeterministicKey watchingKey = toWatch.getWatchingKey(); String s = watchingKey.serializePubB58(getParams()); long creationTimeSeconds = watchingKey.getCreationTimeSeconds(); DeterministicKey key = DeterministicKey.deserializeB58(null, &quot;key data goes here&quot;,getParams()); Wallet wallet = Wallet.fromWatchingKey(getParams(), key); NetworkParameters params = TestNet3Params.get(); DeterministicSeed seed = new DeterministicSeed(new SecureRandom(),128,&quot;password&quot;, Utils.currentTimeSeconds()); wallet = Wallet.fromSeed(params,seed); //tobytes byte[] bytes = MnemonicCode.toSeed(new ArrayList&lt;&gt;(), passphrase); } public static void test(){ NetworkParameters params = TestNet3Params.get(); DeterministicSeed seed = new DeterministicSeed(new SecureRandom(),128,&quot;123456&quot;,Utils.currentTimeSeconds()); List&lt;String&gt; mnemonicCode = seed.getMnemonicCode(); LogUtil.e(&quot;mnemonicCode&quot;+mnemonicCode); // byte[] bytes = MnemonicCode.toSeed(mnemonicCode, &quot;123456&quot;); Wallet wallet = Wallet.fromSeed(params,seed); } public static void test2(ECKey ceKey){ NetworkParameters params =getParams(); String s = ceKey.toAddress(params).toBase58().toString(); String privateKeyAsWiF = ceKey.getPrivateKeyAsWiF(params);// 私钥， WIF(Wallet Import Format) LogUtil.e(privateKeyAsWiF+&quot;==========&quot;+s); } //通过私钥拿到eckey public static ECKey getECkey(String prikey){ ECKey key = DumpedPrivateKey.fromBase58(getParams(), prikey).getKey(); return key; } //通过助记词导入新钱包 public static Wallet createWallet(String seedCode,String password) { KeyChainGroup kcg; DeterministicSeed deterministicSeed = null; try { deterministicSeed = new DeterministicSeed(seedCode, null, password, Utils.currentTimeSeconds()); } catch (UnreadableWalletException e) { e.printStackTrace(); } kcg = new KeyChainGroup(getParams(), deterministicSeed); Wallet wallet = new Wallet(getParams(), kcg); return wallet; } //创建新钱包。 public static Wallet createWallet2() { KeyChainGroup kcg = new KeyChainGroup(getParams()); Wallet wallet = new Wallet(getParams(), kcg); wallet.getParams().getId(); return wallet; } //通过助记词 public static WalletAppKit getWalletKit(Context context,String seedcode){ WalletAppKit walletAppKit = new WalletAppKit(getParams(), context.getCacheDir(), Constant.WALLET_NAME) { @Override protected void onSetupCompleted() { if (wallet().getImportedKeys().size() &lt; 1) wallet().importKey(new ECKey()); wallet().allowSpendingUnconfirmedTransactions(); setupWalletListeners(wallet()); ECKey ecKey = wallet().getImportedKeys().get(0); LogUtil.e(getPubKeyFrom(ecKey)); // test2(ecKey); // //打印助记词 List&lt;String&gt; seedWordsFromWallet = getSeedWordsFromWallet(wallet()); LogUtil.e(seedWordsFromWallet.toString()); //当前地址 String s1 = wallet().currentReceiveAddress().toBase58(); // String s2 = wallet().currentChangeAddress().toBase58(); String privateKeyAsWiF = wallet().currentReceiveKey().getPrivateKeyAsWiF(getParams()); LogUtil.e(&quot;currentReceiveAddress=&quot;+s1+&quot;===privateKeyAsWiF=&quot;+privateKeyAsWiF); //LogUtil.e(&quot;freshReceiveAddress=&quot;+s+&quot;===&quot;+&quot;currentReceiveAddress=&quot;+s1); } }; walletAppKit.setAutoSave(true); walletAppKit.setBlockingStartup(false); setDownListener(walletAppKit); if (getParams() == RegTestParams.get()) { AppContext.walletAppKit.connectToLocalHost(); } if(!StringUtils.isEmpty(seedcode)){ try { DeterministicSeed seed = new DeterministicSeed(seedcode, null, passphrase,Utils.currentTimeSeconds()); walletAppKit.restoreWalletFromSeed(seed); } catch (UnreadableWalletException e) { e.printStackTrace(); } } walletAppKit.startAsync(); walletAppKit.awaitRunning(); return walletAppKit; } //加载本地文件 public static WalletAppKit getWalletKit(Context context){ return getWalletKit(context,&quot;&quot;); } public static void setDownListener(WalletAppKit walletAppKit){ walletAppKit.setDownloadListener(new DownloadProgressTracker() { @Override protected void progress(double pct, int blocksSoFar, Date date) { super.progress(pct, blocksSoFar, date); int percentage = (int) pct; LogUtil.e(percentage+&quot;percentage&quot;); } @Override protected void doneDownload() { super.doneDownload(); String myAddress = walletAppKit.wallet().currentReceiveAddress().toBase58(); String s = walletAppKit.wallet().getBalance().toFriendlyString(); BtcData btcData = new BtcData(myAddress,s); RxBus.getInstance().send(new MessageModel(BTC_DATA,btcData)); LogUtil.e(myAddress+&quot;==&quot;+s); } }); } public static void setupWalletListeners(Wallet wallet) { wallet.addCoinsReceivedEventListener((wallet1, tx, prevBalance, newBalance) -&gt; { String s = wallet.getBalance().toFriendlyString(); String s1 = &quot;&quot;; if(tx.getPurpose() == Transaction.Purpose.UNKNOWN) { s1 = newBalance.minus(prevBalance).toFriendlyString(); } LogUtil.e(s+&quot;===&quot;+s1); }); wallet.addCoinsSentEventListener((wallet12, tx, prevBalance, newBalance) -&gt; { String s = wallet.getBalance().toFriendlyString(); String s1 = &quot;Sent &quot;+prevBalance.minus(newBalance).minus(tx.getFee()).toFriendlyString(); LogUtil.e(s+&quot;===&quot;+s1); }); } public void Test() { ECKey k1 = new ECKey(); // some random key // encrypting a key KeyCrypter crypter1 = new KeyCrypterScrypt(); KeyParameter aesKey1 = crypter1.deriveKey(&quot;some arbitrary passphrase&quot;); ECKey k2 = k1.encrypt(crypter1, aesKey1); //System.out.println(k2.isEncrypted()); // true // decrypting a key KeyCrypter crypter2 = k2.getKeyCrypter(); KeyParameter aesKey2 = crypter2.deriveKey(&quot;some arbitrary passphrase&quot;); ECKey k3 = k2.decrypt(aesKey2); //System.out.println(k1.equals(k3)); // true } public static void closedWallet(){ AppContext.walletAppKit.stopAsync(); AppContext.walletAppKit.awaitTerminated(); } public static void test2(){ DeterministicKey deterministicKey = AppContext.walletAppKit.wallet().getWatchingKey().dropPrivateBytes(); deterministicKey = HDKeyDerivation.createMasterPubKeyFromBytes(deterministicKey.getPubKey(), deterministicKey.getChainCode()); String xPublicKey = deterministicKey.serializePubB58(getParams()); String privateKey= AppContext.walletAppKit.wallet().getKeyByPath(DeterministicKeyChain.ACCOUNT_ZERO_PATH).getPrivateKeyAsWiF(getParams()); Log.e(&quot;key&quot;, xPublicKey.toString()); Log.e(&quot;privatekey&quot;, privateKey.toString()); if (getParams() == RegTestParams.get()) { AppContext.walletAppKit.connectToLocalHost(); } } public static void si(String privateKey,String recipientAddress,String amount){ SendRequest request = SendRequest.to(Address.fromBase58(getParams(), recipientAddress), Coin.parseCoin(amount)); Signingtrasaction(privateKey,request.tx.getHashAsString()); } public static void Signingtrasaction(String wif, String msg) { try { // creating a key object from WiF DumpedPrivateKey dpk = DumpedPrivateKey.fromBase58(getParams(), wif); ECKey key = dpk.getKey(); // checking our key object // NetworkParameters main = MainNetParams.get(); String check = key.getPrivateKeyAsWiF(getParams()); System.out.println(wif.equals(check)); // true Log.e(&quot;wif check&quot;, String.valueOf(wif.equals(check))); // creating Sha object from string Sha256Hash hash = Sha256Hash.wrap(msg); // creating signature ECKey.ECDSASignature sig = key.sign(hash); // encoding byte[] res = sig.encodeToDER(); // converting to hex //String hex = DatatypeConverter.printHexBinary(res); // String hex = new String(res); String hex = android.util.Base64.encodeToString(res, 16); Log.e(&quot;sigendTransiction&quot;, hex.toString()); Log.e(&quot;decrypttx&quot;,&quot;&quot;+ Hex.decode(sig.encodeToDER())); } catch (Exception e) { //signingkey = ecdsa.from_string(privateKey.decode(&#39;hex&#39;), curve=ecdsa.SECP256k1) Log.e(&quot;signing exception&quot;, e.getMessage().toString()); } } } &nbsp; &nbsp; &nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/07/13/c362682c9b8e6cbec39349e291676e6e.html" />
<meta property="og:url" content="https://mlh.app/2018/07/13/c362682c9b8e6cbec39349e291676e6e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"1.测试网络 获取btc&nbsp;https://testnet.coinfaucet.eu/en/ https://live.blockcypher.com/ btc:https://github.com/Samourai-Wallet/samourai-wallet-android eth:https://gitter.im/web3j/web3j eos:https://eos.io/ 2.引入库 &nbsp; implementation &#39;org.bitcoinj:bitcoinj-core:0.14.7&#39; //btc 3.主要代码 public class BitUtil { public static final String passphrase = &quot;&quot;; /** * 通过Wallet 获取 助记词 * @param wallet * @return */ public static List&lt;String&gt; getSeedWordsFromWallet(Wallet wallet){ DeterministicSeed seed = wallet.getKeyChainSeed(); return seed.getMnemonicCode(); } /** * 通过私钥获取ECKey * @param priKey * @return */ public static ECKey getECKeyFromPriKey(String priKey){ ECKey ecKey = ECKey.fromPrivate(Numeric.toBigInt(priKey)); return ecKey; } public static String getPubKeyFrom(ECKey ecKey){ NetworkParameters params =getParams(); return ecKey.toAddress(params).toBase58().toString(); } //通过speed 获取钱包 public static Wallet getFromSpeed(String seedCode){ NetworkParameters params = getParams(); DeterministicSeed seed; try { seed = new DeterministicSeed(seedCode, null, passphrase,Utils.currentTimeSeconds() ); Wallet restoredWallet = Wallet.fromSeed(params, seed); return restoredWallet; } catch (UnreadableWalletException e) { e.printStackTrace(); } return null; } //通过本地文件获取Wallet public static Wallet getWalletFromFile(String filePath){ try { return Wallet.loadFromFile(new File(filePath)); } catch (UnreadableWalletException e) { e.printStackTrace(); } return null; } //发送交易 public static void send(Wallet wallet,String recipientAddress, String amount){ NetworkParameters params = getParams(); Address targetAddress = Address.fromBase58(params, recipientAddress); // Do the send of 1 BTC in the background. This could throw InsufficientMoneyException. SPVBlockStore blockStore = null; try { blockStore = new SPVBlockStore(params, getBLockFile()); } catch (BlockStoreException e) { e.printStackTrace(); } BlockChain chain = null; try { chain = new BlockChain(params, wallet,blockStore); PeerGroup peerGroup = new PeerGroup(params, chain); try { Wallet.SendResult result = wallet.sendCoins(peerGroup, targetAddress, Coin.parseCoin(amount)); // Save the wallet to disk, optional if using auto saving (see below). //wallet.saveToFile(....); // Wait for the transaction to propagate across the P2P network, indicating acceptance. try { Transaction transaction = result.broadcastComplete.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } return; } catch (InsufficientMoneyException e) { e.printStackTrace(); } } catch (BlockStoreException e) { e.printStackTrace(); } } public static String send(WalletAppKit walletAppKit,String recipientAddress, String amount){ NetworkParameters params = getParams(); String err = &quot;&quot;; if(TextUtils.isEmpty(recipientAddress) || recipientAddress.equals(&quot;Scan recipient QR&quot;)) { err = &quot;Select recipient&quot;; return err; } if(TextUtils.isEmpty(amount) | Double.parseDouble(amount) &lt;= 0) { err = &quot;Select valid amount&quot;; return err; } if(walletAppKit.wallet().getBalance().isLessThan(Coin.parseCoin(amount))) { err = &quot;You got not enough coins&quot;; return err; } SendRequest request = SendRequest.to(Address.fromBase58(params, recipientAddress), Coin.parseCoin(amount)); try { walletAppKit.wallet().completeTx(request); walletAppKit.wallet().commitTx(request.tx); walletAppKit.peerGroup().broadcastTransaction(request.tx).broadcast(); return &quot;&quot;; } catch (InsufficientMoneyException e) { e.printStackTrace(); return e.getMessage(); } } public static File getBLockFile(){ File file = new File(&quot;/tmp/bitcoin-blocks&quot;); if(!file.exists()){ try { boolean newFile = file.createNewFile(); if(newFile){ return file; } } catch (IOException e) { e.printStackTrace(); } } return file; } public static void getWallet(){ NetworkParameters params = getParams(); Wallet wallet = new Wallet(params); List&lt;ECKey&gt; keys = new ArrayList&lt;&gt;(); ECKey ecKey = new ECKey(); //加密eckey ecKey.encrypt(wallet.getKeyCrypter(),wallet.getKeyCrypter().deriveKey(&quot;123456&quot;)); keys.add(ecKey); wallet.importKeysAndEncrypt(keys,&quot;123456&quot;); try { SPVBlockStore blockStore = new SPVBlockStore(params, getBLockFile()); BlockChain chain = new BlockChain(params, wallet,blockStore); PeerGroup peerGroup = new PeerGroup(params, chain); peerGroup.addWallet(wallet); peerGroup.startAsync(); peerGroup.downloadBlockChain(); //startAndWait() } catch (BlockStoreException e) { e.printStackTrace(); } } public static void testAddress(Wallet wallet){ Address a = wallet.currentReceiveAddress(); ECKey b = wallet.currentReceiveKey(); Address c = wallet.freshReceiveAddress(); } public static void userSPeed(Wallet wallet){ NetworkParameters params = getParams(); DeterministicSeed seed = wallet.getKeyChainSeed(); println(&quot;Seed words are: &quot; + Joiner.on(&quot; &quot;).join(seed.getMnemonicCode())); println(&quot;Seed birthday is: &quot; + seed.getCreationTimeSeconds()); //通过speed 获取Wallet String seedCode = &quot;yard impulse luxury drive today throw farm pepper survey wreck glass federal&quot;; String seedCode2 = &quot;liberty identify erase shuffle dignity armed produce mention actual you top vendor&quot;; long creationtime = 1409478661L; DeterministicSeed seed2; try { seed2 = new DeterministicSeed(seedCode, null, &quot;&quot;, creationtime); Wallet restoredWallet = Wallet.fromSeed(params, seed2); } catch (UnreadableWalletException e) { e.printStackTrace(); } } public static NetworkParameters getParams(){ return Constant.IS_PRODUCTION ? MainNetParams.get() : TestNet3Params.get(); } public static void t(Wallet wallet,String recipientAddress,String password,String mount){ Address a =Address.fromBase58(getParams(), recipientAddress); SendRequest req = SendRequest.to(a, Coin.parseCoin(mount)); req.aesKey = wallet.getKeyCrypter().deriveKey(password); try { wallet.sendCoins(req); } catch (InsufficientMoneyException e) { e.printStackTrace(); } } public static void watchAddress(){ Wallet toWatch = null; DeterministicKey watchingKey = toWatch.getWatchingKey(); String s = watchingKey.serializePubB58(getParams()); long creationTimeSeconds = watchingKey.getCreationTimeSeconds(); DeterministicKey key = DeterministicKey.deserializeB58(null, &quot;key data goes here&quot;,getParams()); Wallet wallet = Wallet.fromWatchingKey(getParams(), key); NetworkParameters params = TestNet3Params.get(); DeterministicSeed seed = new DeterministicSeed(new SecureRandom(),128,&quot;password&quot;, Utils.currentTimeSeconds()); wallet = Wallet.fromSeed(params,seed); //tobytes byte[] bytes = MnemonicCode.toSeed(new ArrayList&lt;&gt;(), passphrase); } public static void test(){ NetworkParameters params = TestNet3Params.get(); DeterministicSeed seed = new DeterministicSeed(new SecureRandom(),128,&quot;123456&quot;,Utils.currentTimeSeconds()); List&lt;String&gt; mnemonicCode = seed.getMnemonicCode(); LogUtil.e(&quot;mnemonicCode&quot;+mnemonicCode); // byte[] bytes = MnemonicCode.toSeed(mnemonicCode, &quot;123456&quot;); Wallet wallet = Wallet.fromSeed(params,seed); } public static void test2(ECKey ceKey){ NetworkParameters params =getParams(); String s = ceKey.toAddress(params).toBase58().toString(); String privateKeyAsWiF = ceKey.getPrivateKeyAsWiF(params);// 私钥， WIF(Wallet Import Format) LogUtil.e(privateKeyAsWiF+&quot;==========&quot;+s); } //通过私钥拿到eckey public static ECKey getECkey(String prikey){ ECKey key = DumpedPrivateKey.fromBase58(getParams(), prikey).getKey(); return key; } //通过助记词导入新钱包 public static Wallet createWallet(String seedCode,String password) { KeyChainGroup kcg; DeterministicSeed deterministicSeed = null; try { deterministicSeed = new DeterministicSeed(seedCode, null, password, Utils.currentTimeSeconds()); } catch (UnreadableWalletException e) { e.printStackTrace(); } kcg = new KeyChainGroup(getParams(), deterministicSeed); Wallet wallet = new Wallet(getParams(), kcg); return wallet; } //创建新钱包。 public static Wallet createWallet2() { KeyChainGroup kcg = new KeyChainGroup(getParams()); Wallet wallet = new Wallet(getParams(), kcg); wallet.getParams().getId(); return wallet; } //通过助记词 public static WalletAppKit getWalletKit(Context context,String seedcode){ WalletAppKit walletAppKit = new WalletAppKit(getParams(), context.getCacheDir(), Constant.WALLET_NAME) { @Override protected void onSetupCompleted() { if (wallet().getImportedKeys().size() &lt; 1) wallet().importKey(new ECKey()); wallet().allowSpendingUnconfirmedTransactions(); setupWalletListeners(wallet()); ECKey ecKey = wallet().getImportedKeys().get(0); LogUtil.e(getPubKeyFrom(ecKey)); // test2(ecKey); // //打印助记词 List&lt;String&gt; seedWordsFromWallet = getSeedWordsFromWallet(wallet()); LogUtil.e(seedWordsFromWallet.toString()); //当前地址 String s1 = wallet().currentReceiveAddress().toBase58(); // String s2 = wallet().currentChangeAddress().toBase58(); String privateKeyAsWiF = wallet().currentReceiveKey().getPrivateKeyAsWiF(getParams()); LogUtil.e(&quot;currentReceiveAddress=&quot;+s1+&quot;===privateKeyAsWiF=&quot;+privateKeyAsWiF); //LogUtil.e(&quot;freshReceiveAddress=&quot;+s+&quot;===&quot;+&quot;currentReceiveAddress=&quot;+s1); } }; walletAppKit.setAutoSave(true); walletAppKit.setBlockingStartup(false); setDownListener(walletAppKit); if (getParams() == RegTestParams.get()) { AppContext.walletAppKit.connectToLocalHost(); } if(!StringUtils.isEmpty(seedcode)){ try { DeterministicSeed seed = new DeterministicSeed(seedcode, null, passphrase,Utils.currentTimeSeconds()); walletAppKit.restoreWalletFromSeed(seed); } catch (UnreadableWalletException e) { e.printStackTrace(); } } walletAppKit.startAsync(); walletAppKit.awaitRunning(); return walletAppKit; } //加载本地文件 public static WalletAppKit getWalletKit(Context context){ return getWalletKit(context,&quot;&quot;); } public static void setDownListener(WalletAppKit walletAppKit){ walletAppKit.setDownloadListener(new DownloadProgressTracker() { @Override protected void progress(double pct, int blocksSoFar, Date date) { super.progress(pct, blocksSoFar, date); int percentage = (int) pct; LogUtil.e(percentage+&quot;percentage&quot;); } @Override protected void doneDownload() { super.doneDownload(); String myAddress = walletAppKit.wallet().currentReceiveAddress().toBase58(); String s = walletAppKit.wallet().getBalance().toFriendlyString(); BtcData btcData = new BtcData(myAddress,s); RxBus.getInstance().send(new MessageModel(BTC_DATA,btcData)); LogUtil.e(myAddress+&quot;==&quot;+s); } }); } public static void setupWalletListeners(Wallet wallet) { wallet.addCoinsReceivedEventListener((wallet1, tx, prevBalance, newBalance) -&gt; { String s = wallet.getBalance().toFriendlyString(); String s1 = &quot;&quot;; if(tx.getPurpose() == Transaction.Purpose.UNKNOWN) { s1 = newBalance.minus(prevBalance).toFriendlyString(); } LogUtil.e(s+&quot;===&quot;+s1); }); wallet.addCoinsSentEventListener((wallet12, tx, prevBalance, newBalance) -&gt; { String s = wallet.getBalance().toFriendlyString(); String s1 = &quot;Sent &quot;+prevBalance.minus(newBalance).minus(tx.getFee()).toFriendlyString(); LogUtil.e(s+&quot;===&quot;+s1); }); } public void Test() { ECKey k1 = new ECKey(); // some random key // encrypting a key KeyCrypter crypter1 = new KeyCrypterScrypt(); KeyParameter aesKey1 = crypter1.deriveKey(&quot;some arbitrary passphrase&quot;); ECKey k2 = k1.encrypt(crypter1, aesKey1); //System.out.println(k2.isEncrypted()); // true // decrypting a key KeyCrypter crypter2 = k2.getKeyCrypter(); KeyParameter aesKey2 = crypter2.deriveKey(&quot;some arbitrary passphrase&quot;); ECKey k3 = k2.decrypt(aesKey2); //System.out.println(k1.equals(k3)); // true } public static void closedWallet(){ AppContext.walletAppKit.stopAsync(); AppContext.walletAppKit.awaitTerminated(); } public static void test2(){ DeterministicKey deterministicKey = AppContext.walletAppKit.wallet().getWatchingKey().dropPrivateBytes(); deterministicKey = HDKeyDerivation.createMasterPubKeyFromBytes(deterministicKey.getPubKey(), deterministicKey.getChainCode()); String xPublicKey = deterministicKey.serializePubB58(getParams()); String privateKey= AppContext.walletAppKit.wallet().getKeyByPath(DeterministicKeyChain.ACCOUNT_ZERO_PATH).getPrivateKeyAsWiF(getParams()); Log.e(&quot;key&quot;, xPublicKey.toString()); Log.e(&quot;privatekey&quot;, privateKey.toString()); if (getParams() == RegTestParams.get()) { AppContext.walletAppKit.connectToLocalHost(); } } public static void si(String privateKey,String recipientAddress,String amount){ SendRequest request = SendRequest.to(Address.fromBase58(getParams(), recipientAddress), Coin.parseCoin(amount)); Signingtrasaction(privateKey,request.tx.getHashAsString()); } public static void Signingtrasaction(String wif, String msg) { try { // creating a key object from WiF DumpedPrivateKey dpk = DumpedPrivateKey.fromBase58(getParams(), wif); ECKey key = dpk.getKey(); // checking our key object // NetworkParameters main = MainNetParams.get(); String check = key.getPrivateKeyAsWiF(getParams()); System.out.println(wif.equals(check)); // true Log.e(&quot;wif check&quot;, String.valueOf(wif.equals(check))); // creating Sha object from string Sha256Hash hash = Sha256Hash.wrap(msg); // creating signature ECKey.ECDSASignature sig = key.sign(hash); // encoding byte[] res = sig.encodeToDER(); // converting to hex //String hex = DatatypeConverter.printHexBinary(res); // String hex = new String(res); String hex = android.util.Base64.encodeToString(res, 16); Log.e(&quot;sigendTransiction&quot;, hex.toString()); Log.e(&quot;decrypttx&quot;,&quot;&quot;+ Hex.decode(sig.encodeToDER())); } catch (Exception e) { //signingkey = ecdsa.from_string(privateKey.decode(&#39;hex&#39;), curve=ecdsa.SECP256k1) Log.e(&quot;signing exception&quot;, e.getMessage().toString()); } } } &nbsp; &nbsp; &nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/07/13/c362682c9b8e6cbec39349e291676e6e.html","headline":"Bitcoinj开发 WalletAppKit 生成钱包，恢复钱包，发送btc","dateModified":"2018-07-13T00:00:00+08:00","datePublished":"2018-07-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/07/13/c362682c9b8e6cbec39349e291676e6e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Bitcoinj开发 WalletAppKit 生成钱包，恢复钱包，发送btc</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>1.测试网络 获取btc&nbsp;<a href="https://testnet.coinfaucet.eu/en/" rel="nofollow">https://testnet.coinfaucet.eu/en/</a></p> 
  <p><a href="https://live.blockcypher.com/" rel="nofollow">https://live.blockcypher.com/</a></p> 
  <p>btc:<br><a href="https://github.com/Samourai-Wallet/samourai-wallet-android" rel="nofollow">https://github.com/Samourai-Wallet/samourai-wallet-android</a><br> eth:<br><a href="https://gitter.im/web3j/web3j" rel="nofollow">https://gitter.im/web3j/web3j</a><br> eos:<br><a href="https://eos.io/" rel="nofollow">https://eos.io/</a></p> 
  <p>2.引入库</p> 
  <p>&nbsp;</p> 
  <pre>
<code class="language-html hljs">implementation 'org.bitcoinj:bitcoinj-core:0.14.7' //btc</code></pre> 
  <p>3.主要代码</p> 
  <pre class="has">
<code class="language-java">public class BitUtil {
    public static final String passphrase = "";
    /**
     * 通过Wallet 获取 助记词
     * @param wallet
     * @return
     */
    public static List&lt;String&gt; getSeedWordsFromWallet(Wallet wallet){
        DeterministicSeed seed = wallet.getKeyChainSeed();
        return  seed.getMnemonicCode();
    }

    /**
     * 通过私钥获取ECKey
     * @param priKey
     * @return
     */
    public static ECKey getECKeyFromPriKey(String priKey){
        ECKey ecKey = ECKey.fromPrivate(Numeric.toBigInt(priKey));
        return ecKey;
    }
    public  static String getPubKeyFrom(ECKey ecKey){
        NetworkParameters params =getParams();
       return ecKey.toAddress(params).toBase58().toString();
    }


    //通过speed 获取钱包
    public static Wallet getFromSpeed(String seedCode){
        NetworkParameters params = getParams();
        DeterministicSeed seed;
        try {
            seed = new DeterministicSeed(seedCode, null, passphrase,Utils.currentTimeSeconds() );

            Wallet restoredWallet = Wallet.fromSeed(params, seed);
            return  restoredWallet;
        } catch (UnreadableWalletException e) {
            e.printStackTrace();
        }
        return  null;
    }



    //通过本地文件获取Wallet
    public static  Wallet getWalletFromFile(String filePath){
        try {
            return  Wallet.loadFromFile(new File(filePath));
        } catch (UnreadableWalletException e) {
            e.printStackTrace();
        }
        return null;
    }


    //发送交易
    public static void send(Wallet wallet,String recipientAddress, String amount){
        NetworkParameters params = getParams();
       Address targetAddress  = Address.fromBase58(params, recipientAddress);
    // Do the send of 1 BTC in the background. This could throw InsufficientMoneyException.
        SPVBlockStore blockStore = null;
        try {
            blockStore = new SPVBlockStore(params, getBLockFile());
        } catch (BlockStoreException e) {
            e.printStackTrace();
        }
        BlockChain chain = null;
        try {
            chain = new BlockChain(params, wallet,blockStore);
            PeerGroup peerGroup = new PeerGroup(params, chain);
            try {
                Wallet.SendResult result = wallet.sendCoins(peerGroup, targetAddress, Coin.parseCoin(amount));
                // Save the wallet to disk, optional if using auto saving (see below).
                //wallet.saveToFile(....);
                    // Wait for the transaction to propagate across the P2P network, indicating acceptance.
                try {
                    Transaction transaction = result.broadcastComplete.get();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    e.printStackTrace();
                }
                return;
            } catch (InsufficientMoneyException e) {
                e.printStackTrace();
            }
        } catch (BlockStoreException e) {
            e.printStackTrace();
        }

    }

    public static  String send(WalletAppKit walletAppKit,String recipientAddress, String amount){
        NetworkParameters params = getParams();
        String err = "";
        if(TextUtils.isEmpty(recipientAddress) || recipientAddress.equals("Scan recipient QR")) {
            err = "Select recipient";
            return err;
        }
        if(TextUtils.isEmpty(amount) | Double.parseDouble(amount) &lt;= 0) {
            err = "Select valid amount";
            return err;

        }
        if(walletAppKit.wallet().getBalance().isLessThan(Coin.parseCoin(amount))) {
            err = "You got not enough coins";
            return err;
        }
        SendRequest request = SendRequest.to(Address.fromBase58(params, recipientAddress), Coin.parseCoin(amount));
        try {
            walletAppKit.wallet().completeTx(request);
            walletAppKit.wallet().commitTx(request.tx);
            walletAppKit.peerGroup().broadcastTransaction(request.tx).broadcast();
            return "";
        } catch (InsufficientMoneyException e) {
            e.printStackTrace();
            return  e.getMessage();
        }
    }



    public static File getBLockFile(){
        File file = new File("/tmp/bitcoin-blocks");
        if(!file.exists()){
            try {
                boolean newFile = file.createNewFile();
                if(newFile){
                    return file;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return file;
    }

   public static void getWallet(){
       NetworkParameters params = getParams();
       Wallet wallet = new Wallet(params);

       List&lt;ECKey&gt; keys = new ArrayList&lt;&gt;();
       ECKey ecKey = new ECKey();
       //加密eckey
       ecKey.encrypt(wallet.getKeyCrypter(),wallet.getKeyCrypter().deriveKey("123456"));
       keys.add(ecKey);


       wallet.importKeysAndEncrypt(keys,"123456");
       try {
           SPVBlockStore blockStore = new SPVBlockStore(params, getBLockFile());
           BlockChain chain = new BlockChain(params, wallet,blockStore);
           PeerGroup peerGroup = new PeerGroup(params, chain);
           peerGroup.addWallet(wallet);
           peerGroup.startAsync();
           peerGroup.downloadBlockChain();
           //startAndWait()
       } catch (BlockStoreException e) {
           e.printStackTrace();
       }
   }


   public static void testAddress(Wallet wallet){
       Address a = wallet.currentReceiveAddress();
       ECKey b = wallet.currentReceiveKey();
       Address c = wallet.freshReceiveAddress();
   }




   public static void userSPeed(Wallet wallet){

       NetworkParameters params = getParams();
       DeterministicSeed seed = wallet.getKeyChainSeed();
       println("Seed words are: " + Joiner.on(" ").join(seed.getMnemonicCode()));
       println("Seed birthday is: " + seed.getCreationTimeSeconds());


       //通过speed 获取Wallet
       String seedCode = "yard impulse luxury drive today throw farm pepper survey wreck glass federal";
       String seedCode2 = "liberty identify erase shuffle dignity armed produce mention actual you top vendor";
       long creationtime = 1409478661L;
       DeterministicSeed seed2;
       try {
           seed2 = new DeterministicSeed(seedCode, null, "", creationtime);
           Wallet restoredWallet = Wallet.fromSeed(params, seed2);
       } catch (UnreadableWalletException e) {
           e.printStackTrace();
       }

   }

   public static NetworkParameters getParams(){
        return Constant.IS_PRODUCTION ? MainNetParams.get() : TestNet3Params.get();
   }


   public static void t(Wallet wallet,String recipientAddress,String password,String mount){
       Address a =Address.fromBase58(getParams(), recipientAddress);
       SendRequest req = SendRequest.to(a, Coin.parseCoin(mount));
       req.aesKey = wallet.getKeyCrypter().deriveKey(password);
       try {
           wallet.sendCoins(req);
       } catch (InsufficientMoneyException e) {
           e.printStackTrace();
       }
   }

   public static void watchAddress(){
       Wallet toWatch = null;
       DeterministicKey watchingKey = toWatch.getWatchingKey();
       String s = watchingKey.serializePubB58(getParams());
       long creationTimeSeconds = watchingKey.getCreationTimeSeconds();


       DeterministicKey key = DeterministicKey.deserializeB58(null, "key data goes here",getParams());

       Wallet wallet = Wallet.fromWatchingKey(getParams(), key);


       NetworkParameters params = TestNet3Params.get();

       DeterministicSeed seed = new DeterministicSeed(new SecureRandom(),128,"password", Utils.currentTimeSeconds());
       wallet = Wallet.fromSeed(params,seed);

        //tobytes
       byte[] bytes = MnemonicCode.toSeed(new ArrayList&lt;&gt;(), passphrase);

   }

   public static void test(){
       NetworkParameters params = TestNet3Params.get();
       DeterministicSeed seed = new DeterministicSeed(new SecureRandom(),128,"123456",Utils.currentTimeSeconds());
       List&lt;String&gt; mnemonicCode = seed.getMnemonicCode();
       LogUtil.e("mnemonicCode"+mnemonicCode);
//       byte[] bytes = MnemonicCode.toSeed(mnemonicCode, "123456");
       Wallet wallet = Wallet.fromSeed(params,seed);
   }

   public static void test2(ECKey ceKey){
       NetworkParameters params =getParams();
       String s = ceKey.toAddress(params).toBase58().toString();
       String privateKeyAsWiF = ceKey.getPrivateKeyAsWiF(params);// 私钥， WIF(Wallet Import Format)
       LogUtil.e(privateKeyAsWiF+"=========="+s);
   }



   //通过私钥拿到eckey
   public static ECKey getECkey(String prikey){
       ECKey key = DumpedPrivateKey.fromBase58(getParams(), prikey).getKey();
       return key;
   }


   //通过助记词导入新钱包
   public static Wallet createWallet(String seedCode,String password) {
        KeyChainGroup kcg;
        DeterministicSeed deterministicSeed = null;
        try {
            deterministicSeed = new DeterministicSeed(seedCode, null, password, Utils.currentTimeSeconds());
        } catch (UnreadableWalletException e) {
            e.printStackTrace();
        }
        kcg = new KeyChainGroup(getParams(), deterministicSeed);
        Wallet wallet = new Wallet(getParams(), kcg);
        return wallet;
    }

    //创建新钱包。
    public static Wallet createWallet2() {
        KeyChainGroup kcg = new KeyChainGroup(getParams());
        Wallet wallet = new Wallet(getParams(), kcg);
        wallet.getParams().getId();
        return wallet;

    }

    //通过助记词
    public static WalletAppKit getWalletKit(Context context,String seedcode){
        WalletAppKit walletAppKit = new WalletAppKit(getParams(), context.getCacheDir(), Constant.WALLET_NAME) {
            @Override
            protected void onSetupCompleted() {
                if (wallet().getImportedKeys().size() &lt; 1) wallet().importKey(new ECKey());
                wallet().allowSpendingUnconfirmedTransactions();
                setupWalletListeners(wallet());
                ECKey ecKey = wallet().getImportedKeys().get(0);
                LogUtil.e(getPubKeyFrom(ecKey));
//                test2(ecKey);
//                //打印助记词
                List&lt;String&gt; seedWordsFromWallet = getSeedWordsFromWallet(wallet());
                LogUtil.e(seedWordsFromWallet.toString());
                //当前地址
                String s1 = wallet().currentReceiveAddress().toBase58();

               // String s2 = wallet().currentChangeAddress().toBase58();
                String privateKeyAsWiF = wallet().currentReceiveKey().getPrivateKeyAsWiF(getParams());
                LogUtil.e("currentReceiveAddress="+s1+"===privateKeyAsWiF="+privateKeyAsWiF);
                //LogUtil.e("freshReceiveAddress="+s+"==="+"currentReceiveAddress="+s1);
            }
        };


        walletAppKit.setAutoSave(true);
        walletAppKit.setBlockingStartup(false);

        setDownListener(walletAppKit);
        if (getParams() == RegTestParams.get()) {
            AppContext.walletAppKit.connectToLocalHost();
        }
        if(!StringUtils.isEmpty(seedcode)){
            try {
                DeterministicSeed seed = new DeterministicSeed(seedcode, null, passphrase,Utils.currentTimeSeconds());
                walletAppKit.restoreWalletFromSeed(seed);
            } catch (UnreadableWalletException e) {
                e.printStackTrace();
            }

        }
        walletAppKit.startAsync();
        walletAppKit.awaitRunning();
        return  walletAppKit;
    }

    //加载本地文件
    public static WalletAppKit getWalletKit(Context context){
        return getWalletKit(context,"");
    }


    public static void setDownListener(WalletAppKit walletAppKit){
        walletAppKit.setDownloadListener(new DownloadProgressTracker() {
            @Override
            protected void progress(double pct, int blocksSoFar, Date date) {
                super.progress(pct, blocksSoFar, date);
                int percentage = (int) pct;
                LogUtil.e(percentage+"percentage");
            }

            @Override
            protected void doneDownload() {
                super.doneDownload();
                String myAddress = walletAppKit.wallet().currentReceiveAddress().toBase58();
                String s = walletAppKit.wallet().getBalance().toFriendlyString();
                BtcData btcData = new BtcData(myAddress,s);
                RxBus.getInstance().send(new MessageModel(BTC_DATA,btcData));
                LogUtil.e(myAddress+"=="+s);

            }
        });
    }

    public  static void  setupWalletListeners(Wallet wallet) {
        wallet.addCoinsReceivedEventListener((wallet1, tx, prevBalance, newBalance) -&gt; {
            String s = wallet.getBalance().toFriendlyString();
            String s1 = "";
            if(tx.getPurpose() == Transaction.Purpose.UNKNOWN) {
                 s1 = newBalance.minus(prevBalance).toFriendlyString();
            }
            LogUtil.e(s+"==="+s1);
        });
        wallet.addCoinsSentEventListener((wallet12, tx, prevBalance, newBalance) -&gt; {
            String s = wallet.getBalance().toFriendlyString();
            String s1 = "Sent "+prevBalance.minus(newBalance).minus(tx.getFee()).toFriendlyString();
            LogUtil.e(s+"==="+s1);
        });


    }

    public void Test() {

        ECKey k1 = new ECKey(); // some random key

        // encrypting a key
        KeyCrypter crypter1 = new KeyCrypterScrypt();

        KeyParameter aesKey1 = crypter1.deriveKey("some arbitrary passphrase");
        ECKey k2 = k1.encrypt(crypter1, aesKey1);
            //System.out.println(k2.isEncrypted()); // true

        // decrypting a key
        KeyCrypter crypter2 = k2.getKeyCrypter();
        KeyParameter aesKey2 = crypter2.deriveKey("some arbitrary passphrase");
        ECKey k3 = k2.decrypt(aesKey2);

        //System.out.println(k1.equals(k3));  // true
    }


    public static void closedWallet(){
        AppContext.walletAppKit.stopAsync();
        AppContext.walletAppKit.awaitTerminated();
    }

    public static void test2(){
        DeterministicKey deterministicKey = AppContext.walletAppKit.wallet().getWatchingKey().dropPrivateBytes();
        deterministicKey = HDKeyDerivation.createMasterPubKeyFromBytes(deterministicKey.getPubKey(), deterministicKey.getChainCode());
        String xPublicKey = deterministicKey.serializePubB58(getParams());
        String  privateKey= AppContext.walletAppKit.wallet().getKeyByPath(DeterministicKeyChain.ACCOUNT_ZERO_PATH).getPrivateKeyAsWiF(getParams());
        Log.e("key", xPublicKey.toString());
        Log.e("privatekey", privateKey.toString());
        if (getParams() == RegTestParams.get()) {
            AppContext.walletAppKit.connectToLocalHost();
        }
    }

    public static void si(String privateKey,String recipientAddress,String amount){
        SendRequest request = SendRequest.to(Address.fromBase58(getParams(),
                recipientAddress), Coin.parseCoin(amount));
        Signingtrasaction(privateKey,request.tx.getHashAsString());
    }

    public static  void Signingtrasaction(String wif, String msg) {
        try {
            // creating a key object from WiF
            DumpedPrivateKey dpk = DumpedPrivateKey.fromBase58(getParams(), wif);
            ECKey key = dpk.getKey();
            // checking our key object
            // NetworkParameters main = MainNetParams.get();
            String check = key.getPrivateKeyAsWiF(getParams());
            System.out.println(wif.equals(check));  // true
            Log.e("wif check", String.valueOf(wif.equals(check)));
            // creating Sha object from string
            Sha256Hash hash = Sha256Hash.wrap(msg);
            // creating signature
            ECKey.ECDSASignature sig = key.sign(hash);
            // encoding
            byte[] res = sig.encodeToDER();
            // converting to hex
            //String hex = DatatypeConverter.printHexBinary(res);
            // String hex = new String(res);
            String hex = android.util.Base64.encodeToString(res, 16);
            Log.e("sigendTransiction", hex.toString());
            Log.e("decrypttx",""+ Hex.decode(sig.encodeToDER()));
        } catch (Exception e) {   //signingkey = ecdsa.from_string(privateKey.decode('hex'), curve=ecdsa.SECP256k1)
            Log.e("signing exception", e.getMessage().toString());
        }
    }


}</code></pre> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180713173954858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1anVubG9uZzM5MTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yujunlong3919/article/details/81035278,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yujunlong3919/article/details/81035278,&quot;}">阅读更多</a> 
 <!-- <a class="btn" href="https://passport.csdn.net/account/login?utm_source=csdn_blog_pc_more_login" target="_self" id="btn-lobinreadmore" data-track-view='{"mod":"popu_557","con":",https://blog.csdn.net/yujunlong3919/article/details/81035278,"}' data-track-click='{"mod":"popu_557","con":",https://blog.csdn.net/yujunlong3919/article/details/81035278,"}'>登录后自动展开</a> --> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
