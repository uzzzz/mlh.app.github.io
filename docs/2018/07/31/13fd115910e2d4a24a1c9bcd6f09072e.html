<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>fabric v1.0.0 多节点（3节点）部署 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="fabric v1.0.0 多节点（3节点）部署" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="首先按照https://blog.csdn.net/qq_30852577/article/details/79170406在三个节点实现免密码登录，按照链接https://blog.csdn.net/qq_30852577/article/details/80896031安装docker、docker-compose与go环境，安装完成后执行下面操作 1.生成公私钥和证书 Fabric中有两种类型的公私钥和证书，一种是给节点之前通讯安全而准备的TLS证书，另一种是用户登录和权限控制的用户证书。这些证书本来应该是由CA来颁发，但是目前只有两个社区，所以目前暂时没有启用CA节点，但是Fabric帮我们提供了一个crytogen工具来生成证书。 1.1编译cryptogen 编译生成 cryptogen之前我们需要安装一个软件包，否则编译时会报错 sudo apt install libtool libltdl3-dev Fabric提供了专门编译cryptogen的入口，我们只需要运行以下命令即可： cd /home/hadoop/go/src/github.com/hyperledger/fabric make cryptogen 运行后系统返回如下结果即代表编译成功了 build/bin/cryptogen CGO_CFLAGS=&quot; &quot; GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install -tags &quot;&quot; -ldflags &quot;-X github.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0&quot; github.com/hyperledger/fabric/common/tools/cryptogen Binary available as build/bin/cryptogen 我们在build/bin文件夹下就可以看到编译出来的cryptogen程序。 &nbsp; 1.2配置crypto-config.yaml examples/e2e_cli/crypto-config.yaml已经提供了一个Orderer Org和两个Peer Org的配置，该模板中也对字段进行了注释。我们可以把配置修改一下： OrdererOrgs: - Name: Orderer Domain: example.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.example.com Template: Count: 1 Users: Count: 1 - Name: Org2 Domain: org2.example.com Template: Count: 1 Users: Count: 1 &nbsp; Name和Domain就是关于这个组织的名字和域名，这主要是用于生成证书的时候，证书内会包含该信息。而Template Count=1是说我们要生成1套公私钥和证书，因为我们一个组织只需要一个peer节点。最后Users. Count=1是说每个Template下面会有几个普通User（注意，Admin是Admin，不包含在这个计数中），这里配置了1，也就是说我们只需要一个普通用户User1@org2.example.com&nbsp;我们可以根据实际需要调整这个配置文件，增删Org Users等。 &nbsp; 1.3生成公私钥和证书 我们配置好crypto-config.yaml文件后，就可以用cryptogen去读取该文件，并生成对应的公私钥和证书了： cd examples/e2e_cli/ ../../build/bin/cryptogen generate --config=./crypto-config.yaml 生成的文件都保存到crypto-config文件夹，我们可以进入该文件夹查看生成了哪些文件： tree crypto-config 2.生成创世区块和Channel配置区块 2.1编译生成configtxgen 与前面1.1说到的类似，我们可以通过make命令生成configtxgen程序： cd /home/hadoop/go/src/github.com/hyperledger/fabric make configtxgen 运行后的结果为： build/bin/configtxgen CGO_CFLAGS=&quot; &quot; GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install -tags &quot;nopkcs11&quot; -ldflags &quot;-X github.com/hyperledger/fabric/common/configtx/tool/configtxgen/metadata.Version=1.0.0&quot; github.com/hyperledger/fabric/common/configtx/tool/configtxgen Binary available as build/bin/configtxgen 2.2配置configtx.yaml 官方提供的examples/e2e_cli/configtx.yaml这个文件里面配置了由2个Org参与的Orderer共识配置TwoOrgsOrdererGenesis，以及由2个Org参与的Channel配置：TwoOrgsChannel。Orderer可以设置共识的算法是Solo还是Kafka，以及共识时区块大小，超时时间等，我们使用默认值即可，不用更改。而Peer节点的配置包含了MSP的配置，锚节点的配置。如果我们有更多的Org，或者有更多的Channel，那么就可以根据模板进行对应的修改。 2.3生成创世区块 配置修改好后，我们就用configtxgen 生成创世区块。并把这个区块保存到本地channel-artifacts文件夹中： cd examples/e2e_cli/ ../../build/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 2.4生成Channel配置区块 ../../build/bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel 另外关于锚节点的更新，我们也需要使用这个程序来生成文件： ../../build/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ../../build/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP 最终，我们在channel-artifacts文件夹中，应该是能够看到4个文件。 channel-artifacts/&nbsp;├── channel.tx&nbsp;├── genesis.block&nbsp;├── Org1MSPanchors.tx&nbsp;└── Org2MSPanchors.tx &nbsp; 3.配置docker-compose文件 前面对节点和用户的公私钥以及证书，还有创世区块都生成完毕，接下来我们就可以分别为两个peer和一个orderer配置docker-compose的yaml文件，分别分发给三台虚拟机以后就可以启动Fabric的Docker环境了。 3.1 修改基础配置文件 peer和orderder的基础配置文件在base文件里面。 因为我们只有两个组织，每个组织只有一个peer，所以只需修改base/docker-compose-base.yaml文件，删除peer1.org1.example.com和peer1.org2.example.com。另外在单击模式下，4个peer会映射主机不同的端口，但是我们在多机部署的时候是不需要映射不同端口的，所以将所有peer的端口映射都改为相同的，修改完成的docker-compose-base.yaml文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: orderer.example.com: container_name: orderer.example.com image: hyperledger/fabric-orderer environment: - ORDERER_GENERAL_LOGLEVEL=debug - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 - ORDERER_GENERAL_GENESISMETHOD=file - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block - ORDERER_GENERAL_LOCALMSPID=OrdererMSP - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp # enabled TLS - ORDERER_GENERAL_TLS_ENABLED=true - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] working_dir: /opt/gopath/src/github.com/hyperledger/fabric command: orderer volumes: - ../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls ports: - 7050:7050 peer0.org1.example.com: container_name: peer0.org1.example.com extends: file: peer-base.yaml service: peer-base environment: - CORE_PEER_ID=peer0.org1.example.com - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_CHAINCODELISTENADDRESS=peer0.org1.example.com:7052 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP volumes: - /var/run/:/host/var/run/ - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls ports: - 7051:7051 - 7052:7052 - 7053:7053 peer0.org2.example.com: container_name: peer0.org2.example.com extends: file: peer-base.yaml service: peer-base environment: - CORE_PEER_ID=peer0.org2.example.com - CORE_PEER_ADDRESS=peer0.org2.example.com:7051 - CORE_PEER_CHAINCODELISTENADDRESS=peer0.org2.example.com:7052 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org2.example.com:7051 - CORE_PEER_LOCALMSPID=Org2MSP volumes: - /var/run/:/host/var/run/ - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp:/etc/hyperledger/fabric/msp - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls:/etc/hyperledger/fabric/tls ports: - 7051:7051 - 7052:7052 - 7053:7053 &nbsp; 3.2设置orderer节点的docker-compose文件 e2e_cli提供了多个docker-compose文件，我们可以根据docker-compose-cli来修改 cp docker-compose-cli.yaml docker-compose-orderer.yaml orderer服务器上我们只需要保留order设置，其他peer和cli设置都可以删除。orderer配置文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: orderer.example.com: extends: file: base/docker-compose-base.yaml service: orderer.example.com container_name: orderer.example.com 3.3设置peer节点的docker-compose文件 先为peer0.org1.example.com配置，与创建orderer的配置文件类似，我们也复制一个yaml文件出来进行修改： cp docker-compose-cli.yaml docker-compose-peer0org1.yaml 去掉orderer的配置，只保留一个peer和cli，因为我们要多级部署，节点与节点之前又是通过主机名通讯，所以需要修改容器中的host文件，也就是extra_hosts设置。因为之后我们要连接couchdb，所以这里加入couchdb的配置，这里的192.168.1.162:5984是我映射CouchDB后的Linux的IP地址和IP,然后是设置用户名和密码。 同样，cli也需要能够和各个节点通讯，所以cli下面也需要添加extra_hosts设置，去掉无效的依赖，并且去掉command这一行，因为我们是每个peer都会有个对应的客户端，也就是cli，所以我只需要去手动执行一次命令，而不是自动运行。 修改后的配置文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: peer0.org1.example.com: container_name: peer0.org1.example.com environment: - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=192.168.1.162:5984 - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=password extends: file: base/docker-compose-base.yaml service: peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; cli: container_name: cli image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_TLS_ENABLED=true - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer volumes: - /var/run/:/host/var/run/ - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts depends_on: - peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; - &quot;peer0.org1.example.com:192.168.1.162&quot; - &quot;peer0.org2.example.com:192.168.1.163&quot; peer0.org2.example.com配置文件,根据peer0.org1.example.com修改即可 cp docker-compose-peer0org1.yaml docker-compose-peer0org2.yaml 修改后的配置文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: peer0.org2.example.com: container_name: peer0.org2.example.com environment: - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=192.168.1.163:5984 - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=password extends: file: base/docker-compose-base.yaml service: peer0.org2.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; cli: container_name: cli image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org2.example.com:7051 - CORE_PEER_LOCALMSPID=Org2MSP - CORE_PEER_TLS_ENABLED=true - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer volumes: - /var/run/:/host/var/run/ - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts depends_on: - peer0.org2.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; - &quot;peer0.org1.example.com:192.168.1.162&quot; - &quot;peer0.org2.example.com:192.168.1.163&quot; 3.4分发配置文件 前面4步的操作，我们都是在orderer.example.com上完成的，接下来我们需要将这些文件分发到另外2台服务器上。Linux之间的文件传输，我们可以使用scp命令。 我先登录peer0.org1.example.com，将本地的e2e_cli文件夹删除： rm -r e2e_cli 然后再登录到orderer服务器上，退回到examples文件夹，因为这样可以方便的把其下的e2e_cli文件夹整个传到peer0.org1服务器上。 scp -r e2e_cli root@192.168.1.162:/home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/ 接下来继续使用scp命令将orderer上的文件夹传送给peer0.org2.example.com。 以下为启动fabric部分 4.启动orderer节点和peer节点 4.1 启动orderer节点 在orderer服务器上运行： cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli docker-compose -f docker-compose-orderer.yaml up -d 运行完毕后我们可以使用docker ps看到运行了一个名字为orderer.example.com的容器。 &nbsp;此时，自动按照指定配置创建系统通道，还没有应用通道 4.2 启动peer节点 在peer0.org1.example.com服务器执行命令： cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli docker-compose -f docker-compose-peer0org1.yaml up -d 运行完毕后我们使用docker ps应该可以看到peer、cli两个个正在运行的容器。&nbsp; 接下来切回到peer0.org2.example.com服务器。运行相同的命令： cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli docker-compose -f docker-compose-peer0org2.yaml up -d 现在我们整个Fabric网络已经成型，接下来是创建channel和运行ChainCode。&nbsp; 5.创建channel，各peer加入channel 5.1 创建channel 我们切换到peer0.org1.example.com服务器上，使用该服务器上的cli来运行创建Channel和运行ChainCode的操作。先用以下命令进入CLI内部Bash： docker exec -it cli bash 创建Channel的命令是peer channel create，我们前面创建Channel的配置区块时，指定了Channel的名字是mychannel，那么这里我们必须创建同样名字的Channel，创建了应用通道。 ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls true --cafile $ORDERER_CA 执行该命令后，系统会提示： 2017-10-30 18:30:35.210 UTC [channelCmd] readBlock -&gt; DEBU 020 Received block:0 系统会在cli内部的当前目录创建一个mychannel.block文件，这个文件非常重要，接下来其他节点要加入这个Channel就必须使用这个文件。&nbsp; 5.2各个peer加入channel 还是在peer0.org1的CLI上，我们要将这个Peer加入mychannel就很简单，只需要运行如下命令： peer channel join -b mychannel.block 系统返回消息： 2017-10-30 18:40:21.405&nbsp;UTC [channelCmd] executeJoin -&gt; INFO 006 Peer joined the channel! &nbsp; 修改cli的环境变量，使其指向peer0.org2 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel join -b mychannel.block 这样peer0.org1和peer0.org2就都已经加入channel了。 注：这一切都是我在peer0.org1的cli内完成的，这是由于加入channel依赖 [channel-ID].block文件，而且在peer0.org1服务器的cli内也留有了peer0.org2的证书文件，因此两个节点的加入都在一个cli内完成了。其实当一个节点创建channel以后可以把[channel-ID].block文件从容器内拷贝到主机，再分发给其他节点，这样其他节点就可以通过[channel-ID].block加入channel了。当cli容器被销毁时该容器下所有的文件都会被销毁，但是如果备份了[channel-ID].block，那么即使所有的peer和cli被销毁了，也可以再次通过[channel-ID].block加入channel、同步区块。&nbsp; 5.3 更新锚节点 关于AnchorPeer，其实我的每个组织只有一个peer节点，所以更新不更新锚节点也不重要。 对于Org1来说，peer0.org1是锚节点，我们需要切换到peer0.org1服务器上并更新锚节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 &nbsp; peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls true --cafile $ORDERER_CA 另外对于Org2，peer0.org2是锚节点，切换到peer0.org2服务器上然后执行如下命令： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls true --cafile $ORDERER_CA 6.chaincode的安装与运行 6.1 安装chaincode 对需要共识的peer节点都要安装链码 以peer0.org1为例，先切换至该节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 在cli上为每一个peer安装链上代码，用peer chaincode install命令可以安装指定的ChainCode并对其命名： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 安装的过程其实就是对CLI中指定的代码进行编译打包，并把打包好的文件发送到Peer，等待接下来的实例化。 切换到peer0.org2服务器，给peer0.org2安装链上代码： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02&nbsp; 6.2 实例化chaincode 实例化链上代码主要是在Peer所在的机器上对前面安装好的链上代码进行包装，生成对应Channel的Docker镜像和Docker容器。并且在实例化时我们可以指定背书策略。我们在peer0.org1服务器的cli内运行以下命令完成实例化： peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 使用docker ps可以看到有新的容器&nbsp;dev-peer0.org1.example.com-mycc-1.0正在运行。 6.3 在一个peer发起交易&nbsp; 在peer0.org1上发起交易 查询a的余额，peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 返回结果 Query result： 100 转账：a向b转账10元 peer chaincode invoke -o orderer.example.com:7050&nbsp; --tls true --cafile $ORDERER_CA -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 6.4 在另一个节点上查询交易 前面的操作都是在org1下面做的，那么处于同一个区块链（同一个Channel下）的org2，是否会看org1的更改呢？切换到peer0.org2服务器，由于mycc已经在前面org1的时候实例化了，也就是说对应的区块已经生成了，所以在org2不能再次初始化。我们直接运行查询命令： 首先CLI指向peer1.org2，然后查询 peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 需要较长时间（几十秒） 因为peer0.org2也需要生成Docker镜像，创建对应的容器，才能通过容器返回结果，所以等的时间会稍长一点。我们回到Ubuntu终端，执行docker ps，可以看到peer0.org2也多了一个容器：dev-peer0.org2.example.com-mycc-1.0&nbsp;&nbsp; 7. 查看日志 这样整个区块链网络算是正式跑通了！如果想知道orderer和peer之间具体都发生了些什么我们可以进入对应的服务器，输入命令： docker logs -f orderer.example.com docker logs -f peer0.org1.example.com docker logs -f peer0.org2.example.com 这样就可以查看对应的日志，也可以查询报错。 8.退出CLI客户端后操作（以peer0org2退出后再查询余额为例） （1） 进入CLI内部 docker exec -it cli bash （2）公私钥认证 CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt （3）操作链码 peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 参考：http://www.cnblogs.com/preminem/p/7729723.html https://www.cnblogs.com/studyzy/p/7237287.html 阅读更多" />
<meta property="og:description" content="首先按照https://blog.csdn.net/qq_30852577/article/details/79170406在三个节点实现免密码登录，按照链接https://blog.csdn.net/qq_30852577/article/details/80896031安装docker、docker-compose与go环境，安装完成后执行下面操作 1.生成公私钥和证书 Fabric中有两种类型的公私钥和证书，一种是给节点之前通讯安全而准备的TLS证书，另一种是用户登录和权限控制的用户证书。这些证书本来应该是由CA来颁发，但是目前只有两个社区，所以目前暂时没有启用CA节点，但是Fabric帮我们提供了一个crytogen工具来生成证书。 1.1编译cryptogen 编译生成 cryptogen之前我们需要安装一个软件包，否则编译时会报错 sudo apt install libtool libltdl3-dev Fabric提供了专门编译cryptogen的入口，我们只需要运行以下命令即可： cd /home/hadoop/go/src/github.com/hyperledger/fabric make cryptogen 运行后系统返回如下结果即代表编译成功了 build/bin/cryptogen CGO_CFLAGS=&quot; &quot; GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install -tags &quot;&quot; -ldflags &quot;-X github.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0&quot; github.com/hyperledger/fabric/common/tools/cryptogen Binary available as build/bin/cryptogen 我们在build/bin文件夹下就可以看到编译出来的cryptogen程序。 &nbsp; 1.2配置crypto-config.yaml examples/e2e_cli/crypto-config.yaml已经提供了一个Orderer Org和两个Peer Org的配置，该模板中也对字段进行了注释。我们可以把配置修改一下： OrdererOrgs: - Name: Orderer Domain: example.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.example.com Template: Count: 1 Users: Count: 1 - Name: Org2 Domain: org2.example.com Template: Count: 1 Users: Count: 1 &nbsp; Name和Domain就是关于这个组织的名字和域名，这主要是用于生成证书的时候，证书内会包含该信息。而Template Count=1是说我们要生成1套公私钥和证书，因为我们一个组织只需要一个peer节点。最后Users. Count=1是说每个Template下面会有几个普通User（注意，Admin是Admin，不包含在这个计数中），这里配置了1，也就是说我们只需要一个普通用户User1@org2.example.com&nbsp;我们可以根据实际需要调整这个配置文件，增删Org Users等。 &nbsp; 1.3生成公私钥和证书 我们配置好crypto-config.yaml文件后，就可以用cryptogen去读取该文件，并生成对应的公私钥和证书了： cd examples/e2e_cli/ ../../build/bin/cryptogen generate --config=./crypto-config.yaml 生成的文件都保存到crypto-config文件夹，我们可以进入该文件夹查看生成了哪些文件： tree crypto-config 2.生成创世区块和Channel配置区块 2.1编译生成configtxgen 与前面1.1说到的类似，我们可以通过make命令生成configtxgen程序： cd /home/hadoop/go/src/github.com/hyperledger/fabric make configtxgen 运行后的结果为： build/bin/configtxgen CGO_CFLAGS=&quot; &quot; GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install -tags &quot;nopkcs11&quot; -ldflags &quot;-X github.com/hyperledger/fabric/common/configtx/tool/configtxgen/metadata.Version=1.0.0&quot; github.com/hyperledger/fabric/common/configtx/tool/configtxgen Binary available as build/bin/configtxgen 2.2配置configtx.yaml 官方提供的examples/e2e_cli/configtx.yaml这个文件里面配置了由2个Org参与的Orderer共识配置TwoOrgsOrdererGenesis，以及由2个Org参与的Channel配置：TwoOrgsChannel。Orderer可以设置共识的算法是Solo还是Kafka，以及共识时区块大小，超时时间等，我们使用默认值即可，不用更改。而Peer节点的配置包含了MSP的配置，锚节点的配置。如果我们有更多的Org，或者有更多的Channel，那么就可以根据模板进行对应的修改。 2.3生成创世区块 配置修改好后，我们就用configtxgen 生成创世区块。并把这个区块保存到本地channel-artifacts文件夹中： cd examples/e2e_cli/ ../../build/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 2.4生成Channel配置区块 ../../build/bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel 另外关于锚节点的更新，我们也需要使用这个程序来生成文件： ../../build/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ../../build/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP 最终，我们在channel-artifacts文件夹中，应该是能够看到4个文件。 channel-artifacts/&nbsp;├── channel.tx&nbsp;├── genesis.block&nbsp;├── Org1MSPanchors.tx&nbsp;└── Org2MSPanchors.tx &nbsp; 3.配置docker-compose文件 前面对节点和用户的公私钥以及证书，还有创世区块都生成完毕，接下来我们就可以分别为两个peer和一个orderer配置docker-compose的yaml文件，分别分发给三台虚拟机以后就可以启动Fabric的Docker环境了。 3.1 修改基础配置文件 peer和orderder的基础配置文件在base文件里面。 因为我们只有两个组织，每个组织只有一个peer，所以只需修改base/docker-compose-base.yaml文件，删除peer1.org1.example.com和peer1.org2.example.com。另外在单击模式下，4个peer会映射主机不同的端口，但是我们在多机部署的时候是不需要映射不同端口的，所以将所有peer的端口映射都改为相同的，修改完成的docker-compose-base.yaml文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: orderer.example.com: container_name: orderer.example.com image: hyperledger/fabric-orderer environment: - ORDERER_GENERAL_LOGLEVEL=debug - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 - ORDERER_GENERAL_GENESISMETHOD=file - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block - ORDERER_GENERAL_LOCALMSPID=OrdererMSP - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp # enabled TLS - ORDERER_GENERAL_TLS_ENABLED=true - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] working_dir: /opt/gopath/src/github.com/hyperledger/fabric command: orderer volumes: - ../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls ports: - 7050:7050 peer0.org1.example.com: container_name: peer0.org1.example.com extends: file: peer-base.yaml service: peer-base environment: - CORE_PEER_ID=peer0.org1.example.com - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_CHAINCODELISTENADDRESS=peer0.org1.example.com:7052 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP volumes: - /var/run/:/host/var/run/ - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls ports: - 7051:7051 - 7052:7052 - 7053:7053 peer0.org2.example.com: container_name: peer0.org2.example.com extends: file: peer-base.yaml service: peer-base environment: - CORE_PEER_ID=peer0.org2.example.com - CORE_PEER_ADDRESS=peer0.org2.example.com:7051 - CORE_PEER_CHAINCODELISTENADDRESS=peer0.org2.example.com:7052 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org2.example.com:7051 - CORE_PEER_LOCALMSPID=Org2MSP volumes: - /var/run/:/host/var/run/ - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp:/etc/hyperledger/fabric/msp - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls:/etc/hyperledger/fabric/tls ports: - 7051:7051 - 7052:7052 - 7053:7053 &nbsp; 3.2设置orderer节点的docker-compose文件 e2e_cli提供了多个docker-compose文件，我们可以根据docker-compose-cli来修改 cp docker-compose-cli.yaml docker-compose-orderer.yaml orderer服务器上我们只需要保留order设置，其他peer和cli设置都可以删除。orderer配置文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: orderer.example.com: extends: file: base/docker-compose-base.yaml service: orderer.example.com container_name: orderer.example.com 3.3设置peer节点的docker-compose文件 先为peer0.org1.example.com配置，与创建orderer的配置文件类似，我们也复制一个yaml文件出来进行修改： cp docker-compose-cli.yaml docker-compose-peer0org1.yaml 去掉orderer的配置，只保留一个peer和cli，因为我们要多级部署，节点与节点之前又是通过主机名通讯，所以需要修改容器中的host文件，也就是extra_hosts设置。因为之后我们要连接couchdb，所以这里加入couchdb的配置，这里的192.168.1.162:5984是我映射CouchDB后的Linux的IP地址和IP,然后是设置用户名和密码。 同样，cli也需要能够和各个节点通讯，所以cli下面也需要添加extra_hosts设置，去掉无效的依赖，并且去掉command这一行，因为我们是每个peer都会有个对应的客户端，也就是cli，所以我只需要去手动执行一次命令，而不是自动运行。 修改后的配置文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: peer0.org1.example.com: container_name: peer0.org1.example.com environment: - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=192.168.1.162:5984 - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=password extends: file: base/docker-compose-base.yaml service: peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; cli: container_name: cli image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_TLS_ENABLED=true - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer volumes: - /var/run/:/host/var/run/ - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts depends_on: - peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; - &quot;peer0.org1.example.com:192.168.1.162&quot; - &quot;peer0.org2.example.com:192.168.1.163&quot; peer0.org2.example.com配置文件,根据peer0.org1.example.com修改即可 cp docker-compose-peer0org1.yaml docker-compose-peer0org2.yaml 修改后的配置文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: peer0.org2.example.com: container_name: peer0.org2.example.com environment: - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=192.168.1.163:5984 - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=password extends: file: base/docker-compose-base.yaml service: peer0.org2.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; cli: container_name: cli image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org2.example.com:7051 - CORE_PEER_LOCALMSPID=Org2MSP - CORE_PEER_TLS_ENABLED=true - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer volumes: - /var/run/:/host/var/run/ - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts depends_on: - peer0.org2.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; - &quot;peer0.org1.example.com:192.168.1.162&quot; - &quot;peer0.org2.example.com:192.168.1.163&quot; 3.4分发配置文件 前面4步的操作，我们都是在orderer.example.com上完成的，接下来我们需要将这些文件分发到另外2台服务器上。Linux之间的文件传输，我们可以使用scp命令。 我先登录peer0.org1.example.com，将本地的e2e_cli文件夹删除： rm -r e2e_cli 然后再登录到orderer服务器上，退回到examples文件夹，因为这样可以方便的把其下的e2e_cli文件夹整个传到peer0.org1服务器上。 scp -r e2e_cli root@192.168.1.162:/home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/ 接下来继续使用scp命令将orderer上的文件夹传送给peer0.org2.example.com。 以下为启动fabric部分 4.启动orderer节点和peer节点 4.1 启动orderer节点 在orderer服务器上运行： cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli docker-compose -f docker-compose-orderer.yaml up -d 运行完毕后我们可以使用docker ps看到运行了一个名字为orderer.example.com的容器。 &nbsp;此时，自动按照指定配置创建系统通道，还没有应用通道 4.2 启动peer节点 在peer0.org1.example.com服务器执行命令： cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli docker-compose -f docker-compose-peer0org1.yaml up -d 运行完毕后我们使用docker ps应该可以看到peer、cli两个个正在运行的容器。&nbsp; 接下来切回到peer0.org2.example.com服务器。运行相同的命令： cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli docker-compose -f docker-compose-peer0org2.yaml up -d 现在我们整个Fabric网络已经成型，接下来是创建channel和运行ChainCode。&nbsp; 5.创建channel，各peer加入channel 5.1 创建channel 我们切换到peer0.org1.example.com服务器上，使用该服务器上的cli来运行创建Channel和运行ChainCode的操作。先用以下命令进入CLI内部Bash： docker exec -it cli bash 创建Channel的命令是peer channel create，我们前面创建Channel的配置区块时，指定了Channel的名字是mychannel，那么这里我们必须创建同样名字的Channel，创建了应用通道。 ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls true --cafile $ORDERER_CA 执行该命令后，系统会提示： 2017-10-30 18:30:35.210 UTC [channelCmd] readBlock -&gt; DEBU 020 Received block:0 系统会在cli内部的当前目录创建一个mychannel.block文件，这个文件非常重要，接下来其他节点要加入这个Channel就必须使用这个文件。&nbsp; 5.2各个peer加入channel 还是在peer0.org1的CLI上，我们要将这个Peer加入mychannel就很简单，只需要运行如下命令： peer channel join -b mychannel.block 系统返回消息： 2017-10-30 18:40:21.405&nbsp;UTC [channelCmd] executeJoin -&gt; INFO 006 Peer joined the channel! &nbsp; 修改cli的环境变量，使其指向peer0.org2 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel join -b mychannel.block 这样peer0.org1和peer0.org2就都已经加入channel了。 注：这一切都是我在peer0.org1的cli内完成的，这是由于加入channel依赖 [channel-ID].block文件，而且在peer0.org1服务器的cli内也留有了peer0.org2的证书文件，因此两个节点的加入都在一个cli内完成了。其实当一个节点创建channel以后可以把[channel-ID].block文件从容器内拷贝到主机，再分发给其他节点，这样其他节点就可以通过[channel-ID].block加入channel了。当cli容器被销毁时该容器下所有的文件都会被销毁，但是如果备份了[channel-ID].block，那么即使所有的peer和cli被销毁了，也可以再次通过[channel-ID].block加入channel、同步区块。&nbsp; 5.3 更新锚节点 关于AnchorPeer，其实我的每个组织只有一个peer节点，所以更新不更新锚节点也不重要。 对于Org1来说，peer0.org1是锚节点，我们需要切换到peer0.org1服务器上并更新锚节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 &nbsp; peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls true --cafile $ORDERER_CA 另外对于Org2，peer0.org2是锚节点，切换到peer0.org2服务器上然后执行如下命令： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls true --cafile $ORDERER_CA 6.chaincode的安装与运行 6.1 安装chaincode 对需要共识的peer节点都要安装链码 以peer0.org1为例，先切换至该节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 在cli上为每一个peer安装链上代码，用peer chaincode install命令可以安装指定的ChainCode并对其命名： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 安装的过程其实就是对CLI中指定的代码进行编译打包，并把打包好的文件发送到Peer，等待接下来的实例化。 切换到peer0.org2服务器，给peer0.org2安装链上代码： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02&nbsp; 6.2 实例化chaincode 实例化链上代码主要是在Peer所在的机器上对前面安装好的链上代码进行包装，生成对应Channel的Docker镜像和Docker容器。并且在实例化时我们可以指定背书策略。我们在peer0.org1服务器的cli内运行以下命令完成实例化： peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 使用docker ps可以看到有新的容器&nbsp;dev-peer0.org1.example.com-mycc-1.0正在运行。 6.3 在一个peer发起交易&nbsp; 在peer0.org1上发起交易 查询a的余额，peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 返回结果 Query result： 100 转账：a向b转账10元 peer chaincode invoke -o orderer.example.com:7050&nbsp; --tls true --cafile $ORDERER_CA -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 6.4 在另一个节点上查询交易 前面的操作都是在org1下面做的，那么处于同一个区块链（同一个Channel下）的org2，是否会看org1的更改呢？切换到peer0.org2服务器，由于mycc已经在前面org1的时候实例化了，也就是说对应的区块已经生成了，所以在org2不能再次初始化。我们直接运行查询命令： 首先CLI指向peer1.org2，然后查询 peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 需要较长时间（几十秒） 因为peer0.org2也需要生成Docker镜像，创建对应的容器，才能通过容器返回结果，所以等的时间会稍长一点。我们回到Ubuntu终端，执行docker ps，可以看到peer0.org2也多了一个容器：dev-peer0.org2.example.com-mycc-1.0&nbsp;&nbsp; 7. 查看日志 这样整个区块链网络算是正式跑通了！如果想知道orderer和peer之间具体都发生了些什么我们可以进入对应的服务器，输入命令： docker logs -f orderer.example.com docker logs -f peer0.org1.example.com docker logs -f peer0.org2.example.com 这样就可以查看对应的日志，也可以查询报错。 8.退出CLI客户端后操作（以peer0org2退出后再查询余额为例） （1） 进入CLI内部 docker exec -it cli bash （2）公私钥认证 CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt （3）操作链码 peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 参考：http://www.cnblogs.com/preminem/p/7729723.html https://www.cnblogs.com/studyzy/p/7237287.html 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/07/31/13fd115910e2d4a24a1c9bcd6f09072e.html" />
<meta property="og:url" content="https://mlh.app/2018/07/31/13fd115910e2d4a24a1c9bcd6f09072e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-31T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"首先按照https://blog.csdn.net/qq_30852577/article/details/79170406在三个节点实现免密码登录，按照链接https://blog.csdn.net/qq_30852577/article/details/80896031安装docker、docker-compose与go环境，安装完成后执行下面操作 1.生成公私钥和证书 Fabric中有两种类型的公私钥和证书，一种是给节点之前通讯安全而准备的TLS证书，另一种是用户登录和权限控制的用户证书。这些证书本来应该是由CA来颁发，但是目前只有两个社区，所以目前暂时没有启用CA节点，但是Fabric帮我们提供了一个crytogen工具来生成证书。 1.1编译cryptogen 编译生成 cryptogen之前我们需要安装一个软件包，否则编译时会报错 sudo apt install libtool libltdl3-dev Fabric提供了专门编译cryptogen的入口，我们只需要运行以下命令即可： cd /home/hadoop/go/src/github.com/hyperledger/fabric make cryptogen 运行后系统返回如下结果即代表编译成功了 build/bin/cryptogen CGO_CFLAGS=&quot; &quot; GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install -tags &quot;&quot; -ldflags &quot;-X github.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0&quot; github.com/hyperledger/fabric/common/tools/cryptogen Binary available as build/bin/cryptogen 我们在build/bin文件夹下就可以看到编译出来的cryptogen程序。 &nbsp; 1.2配置crypto-config.yaml examples/e2e_cli/crypto-config.yaml已经提供了一个Orderer Org和两个Peer Org的配置，该模板中也对字段进行了注释。我们可以把配置修改一下： OrdererOrgs: - Name: Orderer Domain: example.com Specs: - Hostname: orderer PeerOrgs: - Name: Org1 Domain: org1.example.com Template: Count: 1 Users: Count: 1 - Name: Org2 Domain: org2.example.com Template: Count: 1 Users: Count: 1 &nbsp; Name和Domain就是关于这个组织的名字和域名，这主要是用于生成证书的时候，证书内会包含该信息。而Template Count=1是说我们要生成1套公私钥和证书，因为我们一个组织只需要一个peer节点。最后Users. Count=1是说每个Template下面会有几个普通User（注意，Admin是Admin，不包含在这个计数中），这里配置了1，也就是说我们只需要一个普通用户User1@org2.example.com&nbsp;我们可以根据实际需要调整这个配置文件，增删Org Users等。 &nbsp; 1.3生成公私钥和证书 我们配置好crypto-config.yaml文件后，就可以用cryptogen去读取该文件，并生成对应的公私钥和证书了： cd examples/e2e_cli/ ../../build/bin/cryptogen generate --config=./crypto-config.yaml 生成的文件都保存到crypto-config文件夹，我们可以进入该文件夹查看生成了哪些文件： tree crypto-config 2.生成创世区块和Channel配置区块 2.1编译生成configtxgen 与前面1.1说到的类似，我们可以通过make命令生成configtxgen程序： cd /home/hadoop/go/src/github.com/hyperledger/fabric make configtxgen 运行后的结果为： build/bin/configtxgen CGO_CFLAGS=&quot; &quot; GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install -tags &quot;nopkcs11&quot; -ldflags &quot;-X github.com/hyperledger/fabric/common/configtx/tool/configtxgen/metadata.Version=1.0.0&quot; github.com/hyperledger/fabric/common/configtx/tool/configtxgen Binary available as build/bin/configtxgen 2.2配置configtx.yaml 官方提供的examples/e2e_cli/configtx.yaml这个文件里面配置了由2个Org参与的Orderer共识配置TwoOrgsOrdererGenesis，以及由2个Org参与的Channel配置：TwoOrgsChannel。Orderer可以设置共识的算法是Solo还是Kafka，以及共识时区块大小，超时时间等，我们使用默认值即可，不用更改。而Peer节点的配置包含了MSP的配置，锚节点的配置。如果我们有更多的Org，或者有更多的Channel，那么就可以根据模板进行对应的修改。 2.3生成创世区块 配置修改好后，我们就用configtxgen 生成创世区块。并把这个区块保存到本地channel-artifacts文件夹中： cd examples/e2e_cli/ ../../build/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 2.4生成Channel配置区块 ../../build/bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel 另外关于锚节点的更新，我们也需要使用这个程序来生成文件： ../../build/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP ../../build/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP 最终，我们在channel-artifacts文件夹中，应该是能够看到4个文件。 channel-artifacts/&nbsp;├── channel.tx&nbsp;├── genesis.block&nbsp;├── Org1MSPanchors.tx&nbsp;└── Org2MSPanchors.tx &nbsp; 3.配置docker-compose文件 前面对节点和用户的公私钥以及证书，还有创世区块都生成完毕，接下来我们就可以分别为两个peer和一个orderer配置docker-compose的yaml文件，分别分发给三台虚拟机以后就可以启动Fabric的Docker环境了。 3.1 修改基础配置文件 peer和orderder的基础配置文件在base文件里面。 因为我们只有两个组织，每个组织只有一个peer，所以只需修改base/docker-compose-base.yaml文件，删除peer1.org1.example.com和peer1.org2.example.com。另外在单击模式下，4个peer会映射主机不同的端口，但是我们在多机部署的时候是不需要映射不同端口的，所以将所有peer的端口映射都改为相同的，修改完成的docker-compose-base.yaml文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: orderer.example.com: container_name: orderer.example.com image: hyperledger/fabric-orderer environment: - ORDERER_GENERAL_LOGLEVEL=debug - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 - ORDERER_GENERAL_GENESISMETHOD=file - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block - ORDERER_GENERAL_LOCALMSPID=OrdererMSP - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp # enabled TLS - ORDERER_GENERAL_TLS_ENABLED=true - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] working_dir: /opt/gopath/src/github.com/hyperledger/fabric command: orderer volumes: - ../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls ports: - 7050:7050 peer0.org1.example.com: container_name: peer0.org1.example.com extends: file: peer-base.yaml service: peer-base environment: - CORE_PEER_ID=peer0.org1.example.com - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_CHAINCODELISTENADDRESS=peer0.org1.example.com:7052 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP volumes: - /var/run/:/host/var/run/ - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls ports: - 7051:7051 - 7052:7052 - 7053:7053 peer0.org2.example.com: container_name: peer0.org2.example.com extends: file: peer-base.yaml service: peer-base environment: - CORE_PEER_ID=peer0.org2.example.com - CORE_PEER_ADDRESS=peer0.org2.example.com:7051 - CORE_PEER_CHAINCODELISTENADDRESS=peer0.org2.example.com:7052 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org2.example.com:7051 - CORE_PEER_LOCALMSPID=Org2MSP volumes: - /var/run/:/host/var/run/ - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp:/etc/hyperledger/fabric/msp - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls:/etc/hyperledger/fabric/tls ports: - 7051:7051 - 7052:7052 - 7053:7053 &nbsp; 3.2设置orderer节点的docker-compose文件 e2e_cli提供了多个docker-compose文件，我们可以根据docker-compose-cli来修改 cp docker-compose-cli.yaml docker-compose-orderer.yaml orderer服务器上我们只需要保留order设置，其他peer和cli设置都可以删除。orderer配置文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: orderer.example.com: extends: file: base/docker-compose-base.yaml service: orderer.example.com container_name: orderer.example.com 3.3设置peer节点的docker-compose文件 先为peer0.org1.example.com配置，与创建orderer的配置文件类似，我们也复制一个yaml文件出来进行修改： cp docker-compose-cli.yaml docker-compose-peer0org1.yaml 去掉orderer的配置，只保留一个peer和cli，因为我们要多级部署，节点与节点之前又是通过主机名通讯，所以需要修改容器中的host文件，也就是extra_hosts设置。因为之后我们要连接couchdb，所以这里加入couchdb的配置，这里的192.168.1.162:5984是我映射CouchDB后的Linux的IP地址和IP,然后是设置用户名和密码。 同样，cli也需要能够和各个节点通讯，所以cli下面也需要添加extra_hosts设置，去掉无效的依赖，并且去掉command这一行，因为我们是每个peer都会有个对应的客户端，也就是cli，所以我只需要去手动执行一次命令，而不是自动运行。 修改后的配置文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: peer0.org1.example.com: container_name: peer0.org1.example.com environment: - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=192.168.1.162:5984 - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=password extends: file: base/docker-compose-base.yaml service: peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; cli: container_name: cli image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_TLS_ENABLED=true - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer volumes: - /var/run/:/host/var/run/ - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts depends_on: - peer0.org1.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; - &quot;peer0.org1.example.com:192.168.1.162&quot; - &quot;peer0.org2.example.com:192.168.1.163&quot; peer0.org2.example.com配置文件,根据peer0.org1.example.com修改即可 cp docker-compose-peer0org1.yaml docker-compose-peer0org2.yaml 修改后的配置文件如下： # Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # version: &#39;2&#39; services: peer0.org2.example.com: container_name: peer0.org2.example.com environment: - CORE_LEDGER_STATE_STATEDATABASE=CouchDB - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=192.168.1.163:5984 - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=password extends: file: base/docker-compose-base.yaml service: peer0.org2.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; cli: container_name: cli image: hyperledger/fabric-tools tty: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=cli - CORE_PEER_ADDRESS=peer0.org2.example.com:7051 - CORE_PEER_LOCALMSPID=Org2MSP - CORE_PEER_TLS_ENABLED=true - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer volumes: - /var/run/:/host/var/run/ - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts depends_on: - peer0.org2.example.com extra_hosts: - &quot;orderer.example.com:192.168.1.161&quot; - &quot;peer0.org1.example.com:192.168.1.162&quot; - &quot;peer0.org2.example.com:192.168.1.163&quot; 3.4分发配置文件 前面4步的操作，我们都是在orderer.example.com上完成的，接下来我们需要将这些文件分发到另外2台服务器上。Linux之间的文件传输，我们可以使用scp命令。 我先登录peer0.org1.example.com，将本地的e2e_cli文件夹删除： rm -r e2e_cli 然后再登录到orderer服务器上，退回到examples文件夹，因为这样可以方便的把其下的e2e_cli文件夹整个传到peer0.org1服务器上。 scp -r e2e_cli root@192.168.1.162:/home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/ 接下来继续使用scp命令将orderer上的文件夹传送给peer0.org2.example.com。 以下为启动fabric部分 4.启动orderer节点和peer节点 4.1 启动orderer节点 在orderer服务器上运行： cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli docker-compose -f docker-compose-orderer.yaml up -d 运行完毕后我们可以使用docker ps看到运行了一个名字为orderer.example.com的容器。 &nbsp;此时，自动按照指定配置创建系统通道，还没有应用通道 4.2 启动peer节点 在peer0.org1.example.com服务器执行命令： cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli docker-compose -f docker-compose-peer0org1.yaml up -d 运行完毕后我们使用docker ps应该可以看到peer、cli两个个正在运行的容器。&nbsp; 接下来切回到peer0.org2.example.com服务器。运行相同的命令： cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli docker-compose -f docker-compose-peer0org2.yaml up -d 现在我们整个Fabric网络已经成型，接下来是创建channel和运行ChainCode。&nbsp; 5.创建channel，各peer加入channel 5.1 创建channel 我们切换到peer0.org1.example.com服务器上，使用该服务器上的cli来运行创建Channel和运行ChainCode的操作。先用以下命令进入CLI内部Bash： docker exec -it cli bash 创建Channel的命令是peer channel create，我们前面创建Channel的配置区块时，指定了Channel的名字是mychannel，那么这里我们必须创建同样名字的Channel，创建了应用通道。 ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls true --cafile $ORDERER_CA 执行该命令后，系统会提示： 2017-10-30 18:30:35.210 UTC [channelCmd] readBlock -&gt; DEBU 020 Received block:0 系统会在cli内部的当前目录创建一个mychannel.block文件，这个文件非常重要，接下来其他节点要加入这个Channel就必须使用这个文件。&nbsp; 5.2各个peer加入channel 还是在peer0.org1的CLI上，我们要将这个Peer加入mychannel就很简单，只需要运行如下命令： peer channel join -b mychannel.block 系统返回消息： 2017-10-30 18:40:21.405&nbsp;UTC [channelCmd] executeJoin -&gt; INFO 006 Peer joined the channel! &nbsp; 修改cli的环境变量，使其指向peer0.org2 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel join -b mychannel.block 这样peer0.org1和peer0.org2就都已经加入channel了。 注：这一切都是我在peer0.org1的cli内完成的，这是由于加入channel依赖 [channel-ID].block文件，而且在peer0.org1服务器的cli内也留有了peer0.org2的证书文件，因此两个节点的加入都在一个cli内完成了。其实当一个节点创建channel以后可以把[channel-ID].block文件从容器内拷贝到主机，再分发给其他节点，这样其他节点就可以通过[channel-ID].block加入channel了。当cli容器被销毁时该容器下所有的文件都会被销毁，但是如果备份了[channel-ID].block，那么即使所有的peer和cli被销毁了，也可以再次通过[channel-ID].block加入channel、同步区块。&nbsp; 5.3 更新锚节点 关于AnchorPeer，其实我的每个组织只有一个peer节点，所以更新不更新锚节点也不重要。 对于Org1来说，peer0.org1是锚节点，我们需要切换到peer0.org1服务器上并更新锚节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 &nbsp; peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls true --cafile $ORDERER_CA 另外对于Org2，peer0.org2是锚节点，切换到peer0.org2服务器上然后执行如下命令： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls true --cafile $ORDERER_CA 6.chaincode的安装与运行 6.1 安装chaincode 对需要共识的peer节点都要安装链码 以peer0.org1为例，先切换至该节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 在cli上为每一个peer安装链上代码，用peer chaincode install命令可以安装指定的ChainCode并对其命名： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 安装的过程其实就是对CLI中指定的代码进行编译打包，并把打包好的文件发送到Peer，等待接下来的实例化。 切换到peer0.org2服务器，给peer0.org2安装链上代码： peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02&nbsp; 6.2 实例化chaincode 实例化链上代码主要是在Peer所在的机器上对前面安装好的链上代码进行包装，生成对应Channel的Docker镜像和Docker容器。并且在实例化时我们可以指定背书策略。我们在peer0.org1服务器的cli内运行以下命令完成实例化： peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 使用docker ps可以看到有新的容器&nbsp;dev-peer0.org1.example.com-mycc-1.0正在运行。 6.3 在一个peer发起交易&nbsp; 在peer0.org1上发起交易 查询a的余额，peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 返回结果 Query result： 100 转账：a向b转账10元 peer chaincode invoke -o orderer.example.com:7050&nbsp; --tls true --cafile $ORDERER_CA -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 6.4 在另一个节点上查询交易 前面的操作都是在org1下面做的，那么处于同一个区块链（同一个Channel下）的org2，是否会看org1的更改呢？切换到peer0.org2服务器，由于mycc已经在前面org1的时候实例化了，也就是说对应的区块已经生成了，所以在org2不能再次初始化。我们直接运行查询命令： 首先CLI指向peer1.org2，然后查询 peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 需要较长时间（几十秒） 因为peer0.org2也需要生成Docker镜像，创建对应的容器，才能通过容器返回结果，所以等的时间会稍长一点。我们回到Ubuntu终端，执行docker ps，可以看到peer0.org2也多了一个容器：dev-peer0.org2.example.com-mycc-1.0&nbsp;&nbsp; 7. 查看日志 这样整个区块链网络算是正式跑通了！如果想知道orderer和peer之间具体都发生了些什么我们可以进入对应的服务器，输入命令： docker logs -f orderer.example.com docker logs -f peer0.org1.example.com docker logs -f peer0.org2.example.com 这样就可以查看对应的日志，也可以查询报错。 8.退出CLI客户端后操作（以peer0org2退出后再查询余额为例） （1） 进入CLI内部 docker exec -it cli bash （2）公私钥认证 CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt （3）操作链码 peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 参考：http://www.cnblogs.com/preminem/p/7729723.html https://www.cnblogs.com/studyzy/p/7237287.html 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/07/31/13fd115910e2d4a24a1c9bcd6f09072e.html","headline":"fabric v1.0.0 多节点（3节点）部署","dateModified":"2018-07-31T00:00:00+08:00","datePublished":"2018-07-31T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/07/31/13fd115910e2d4a24a1c9bcd6f09072e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>fabric v1.0.0 多节点（3节点）部署</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>首先按照<a href="https://blog.csdn.net/qq_30852577/article/details/79170406" rel="nofollow">https://blog.csdn.net/qq_30852577/article/details/79170406</a>在三个节点实现免密码登录，按照链接<a href="https://blog.csdn.net/qq_30852577/article/details/80896031" rel="nofollow">https://blog.csdn.net/qq_30852577/article/details/80896031</a>安装docker、docker-compose与go环境，安装完成后执行下面操作</p> 
  <h1 style="margin-left:0cm;"><strong>1.生成公私钥和证书</strong></h1> 
  <p style="margin-left:0cm;"><span style="color:#000000;">Fabric</span><span style="color:#000000;">中有两种类型的公私钥和证书，一种是给节点之前通讯安全而准备的</span><span style="color:#000000;">TLS</span><span style="color:#000000;">证书，另一种是用户登录和权限控制的用户证书。这些证书本来应该是由</span><span style="color:#000000;">CA</span><span style="color:#000000;">来颁发，但是目前只有两个社区，所以目前暂时没有启用</span><span style="color:#000000;">CA</span><span style="color:#000000;">节点，但是</span><span style="color:#000000;">Fabric</span><span style="color:#000000;">帮我们提供了一个</span><span style="color:#000000;">crytogen</span><span style="color:#000000;">工具来生成证书。</span></p> 
  <h2 style="margin-left:0cm;"><strong>1.1编译cryptogen</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">编译生成</span><span style="color:#000000;"> cryptogen</span><span style="color:#000000;">之前我们需要安装一个软件包，否则编译时会报错</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">sudo apt install libtool libltdl3-dev</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">Fabric</span><span style="color:#000000;">提供了专门编译</span><span style="color:#000000;">cryptogen</span><span style="color:#000000;">的入口，我们只需要运行以下命令即可：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">cd /home/hadoop/go/src/github.com/hyperledger/fabric</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">make cryptogen</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">运行后系统返回如下结果即代表编译成功了</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">build/bin/cryptogen </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CGO_CFLAGS=" " GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install -tags "" -ldflags "-X github.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0" github.com/hyperledger/fabric/common/tools/cryptogen </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">Binary available as build/bin/cryptogen</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">我们在</span><span style="color:#000000;">build/bin</span><span style="color:#000000;">文件夹下就可以看到编译出来的</span><span style="color:#000000;">cryptogen</span><span style="color:#000000;">程序。</span></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 style="margin-left:0cm;"><strong>1.2配置crypto-config.yaml</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">examples/e2e_cli/crypto-config.yaml</span><span style="color:#000000;">已经提供了一个</span><span style="color:#000000;">Orderer Org</span><span style="color:#000000;">和两个</span><span style="color:#000000;">Peer Org的配置，该模板中也对字段进行了注释。我们可以把配置修改一下：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">OrdererOrgs:
 
  
  - Name: Orderer
    Domain: example.com
    
    
    Specs:
      - Hostname: orderer

PeerOrgs:
  
  - Name: Org1
    Domain: org1.example.com
     
    Template:
      Count: 1
      
    Users:
      Count: 1
  
  - Name: Org2
    Domain: org2.example.com
    Template:
      Count: 1
    Users:
      Count: 1
</code></pre> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">Name</span><span style="color:#000000;">和</span><span style="color:#000000;">Domain</span><span style="color:#000000;">就是关于这个组织的名字和域名，这主要是用于生成证书的时候，证书内会包含该信息。而</span><span style="color:#000000;">Template Count=1</span><span style="color:#000000;">是说我们要生成</span><span style="color:#000000;">1</span><span style="color:#000000;">套公私钥和证书，因为我们一个组织只需要一个</span><span style="color:#000000;">peer</span><span style="color:#000000;">节点。最后</span><span style="color:#000000;">Users. Count=1</span><span style="color:#000000;">是说每个</span><span style="color:#000000;">Template</span><span style="color:#000000;">下面会有几个普通</span><span style="color:#000000;">User</span><span style="color:#000000;">（注意，</span><span style="color:#000000;">Admin</span><span style="color:#000000;">是</span><span style="color:#000000;">Admin</span><span style="color:#000000;">，不包含在这个计数中），这里配置了</span><span style="color:#000000;">1</span><span style="color:#000000;">，也就是说我们只需要一个普通用户</span><span style="color:#000000;"><a href="mailto:User1@org2.example.com" rel="nofollow"><span style="color:#3b5999;">User1@org2.example.com</span></a>&nbsp;</span><span style="color:#000000;">我们可以根据实际需要调整这个配置文件，增删</span><span style="color:#000000;">Org Users</span><span style="color:#000000;">等。</span></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 style="margin-left:0cm;"><strong>1.3生成公私钥和证书</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">我们配置好</span><span style="color:#000000;">crypto-config.yaml</span><span style="color:#000000;">文件后，就可以用</span><span style="color:#000000;">cryptogen</span><span style="color:#000000;">去读取该文件，并生成对应的公私钥和证书了：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">cd examples/e2e_cli/</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">../../build/bin/cryptogen generate --config=./crypto-config.yaml</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">生成的文件都保存到</span><span style="color:#000000;">crypto-config</span><span style="color:#000000;">文件夹，我们可以进入该文件夹查看生成了哪些文件：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">tree crypto-config</code></pre> 
  <h1 style="margin-left:0cm;"><strong>2.生成创世区块和Channel配置区块</strong></h1> 
  <h2 style="margin-left:0cm;"><strong>2.1编译生成configtxgen</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">与前面</span><span style="color:#000000;">1.1</span><span style="color:#000000;">说到的类似，我们可以通过</span><span style="color:#000000;">make</span><span style="color:#000000;">命令生成</span><span style="color:#000000;">configtxgen</span><span style="color:#000000;">程序：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">cd /home/hadoop/go/src/github.com/hyperledger/fabric
</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">make configtxgen</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">运行后的结果为：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">build/bin/configtxgen </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CGO_CFLAGS=" " GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install -tags "nopkcs11" -ldflags "-X github.com/hyperledger/fabric/common/configtx/tool/configtxgen/metadata.Version=1.0.0" github.com/hyperledger/fabric/common/configtx/tool/configtxgen </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">Binary available as build/bin/configtxgen</code></pre> 
  <h2 style="margin-left:0cm;"><strong>2.2配置configtx.yaml</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">官方提供的</span><span style="color:#000000;">examples/e2e_cli/configtx.yaml</span><span style="color:#000000;">这个文件里面配置了由</span><span style="color:#000000;">2</span><span style="color:#000000;">个</span><span style="color:#000000;">Org</span><span style="color:#000000;">参与的</span><span style="color:#000000;">Orderer</span><span style="color:#000000;">共识配置</span><span style="color:#000000;">TwoOrgsOrdererGenesis</span><span style="color:#000000;">，以及由</span><span style="color:#000000;">2</span><span style="color:#000000;">个</span><span style="color:#000000;">Org</span><span style="color:#000000;">参与的</span><span style="color:#000000;">Channel</span><span style="color:#000000;">配置：</span><span style="color:#000000;">TwoOrgsChannel</span><span style="color:#000000;">。</span><span style="color:#000000;">Orderer</span><span style="color:#000000;">可以设置共识的算法是</span><span style="color:#000000;">Solo</span><span style="color:#000000;">还是</span><span style="color:#000000;">Kafka</span><span style="color:#000000;">，以及共识时区块大小，超时时间等，我们使用默认值即可，不用更改。而</span><span style="color:#000000;">Peer</span><span style="color:#000000;">节点的配置包含了</span><span style="color:#000000;">MSP</span><span style="color:#000000;">的配置，锚节点的配置。如果我们有更多的</span><span style="color:#000000;">Org</span><span style="color:#000000;">，或者有更多的</span><span style="color:#000000;">Channel</span><span style="color:#000000;">，那么就可以根据模板进行对应的修改。</span></p> 
  <h2 style="margin-left:0cm;"><strong>2.3生成创世区块</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">配置修改好后，我们就用</span><span style="color:#000000;">configtxgen </span><span style="color:#000000;">生成创世区块。并把这个区块保存到本地</span><span style="color:#000000;">channel-artifacts</span><span style="color:#000000;">文件夹中：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">cd examples/e2e_cli/
</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">../../build/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block</code></pre> 
  <h2 style="margin-left:0cm;"><strong>2.4生成Channel配置区块</strong></h2> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">../../build/bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">另外关于锚节点的更新，我们也需要使用这个程序来生成文件：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">../../build/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP
</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">../../build/bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">最终，我们在</span><span style="color:#000000;">channel-artifacts</span><span style="color:#000000;">文件夹中，应该是能够看到</span><span style="color:#000000;">4</span><span style="color:#000000;">个文件。</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">channel-artifacts/&nbsp;</span><br><span style="color:#000000;">├</span><span style="color:#000000;">──</span><span style="color:#000000;"> channel.tx</span>&nbsp;<br><span style="color:#000000;">├</span><span style="color:#000000;">──</span><span style="color:#000000;"> genesis.block</span>&nbsp;<br><span style="color:#000000;">├</span><span style="color:#000000;">──</span><span style="color:#000000;"> Org1MSPanchors.tx</span>&nbsp;<br><span style="color:#000000;">└──</span><span style="color:#000000;"> Org2MSPanchors.tx</span></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h1 style="margin-left:0cm;"><strong>3.配置docker-compose文件</strong></h1> 
  <p style="margin-left:0cm;"><span style="color:#000000;">前面对节点和用户的公私钥以及证书，还有创世区块都生成完毕，接下来我们就可以分别为两个</span><span style="color:#000000;">peer</span><span style="color:#000000;">和一个</span><span style="color:#000000;">orderer</span><span style="color:#000000;">配置</span><span style="color:#000000;">docker-compose</span><span style="color:#000000;">的</span><span style="color:#000000;">yaml</span><span style="color:#000000;">文件，分别分发给三台虚拟机以后就可以启动</span><span style="color:#000000;">Fabric</span><span style="color:#000000;">的</span><span style="color:#000000;">Docker</span><span style="color:#000000;">环境了。</span></p> 
  <h2 style="margin-left:0cm;"><strong>3.1 修改基础配置文件</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">peer</span><span style="color:#000000;">和</span><span style="color:#000000;">orderder</span><span style="color:#000000;">的基础配置文件在</span><span style="color:#000000;">base</span><span style="color:#000000;">文件里面。</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">因为我们只有两个组织，每个组织只有一个</span><span style="color:#000000;">peer</span><span style="color:#000000;">，所以只需修改</span><span style="color:#000000;">base/docker-compose-base.yaml</span><span style="color:#000000;">文件，删除</span><span style="color:#000000;">peer1.org1.example.com</span><span style="color:#000000;">和</span><span style="color:#000000;">peer1.org2.example.com</span><span style="color:#000000;">。另外在单击模式下，</span><span style="color:#000000;">4</span><span style="color:#000000;">个</span><span style="color:#000000;">peer</span><span style="color:#000000;">会映射主机不同的端口，但是我们在多机部署的时候是不需要映射不同端口的，所以将所有</span><span style="color:#000000;">peer</span><span style="color:#000000;">的端口映射都改为相同的，修改完成的</span><span style="color:#000000;">docker-compose-base.yaml文件如下：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html"># Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

version: '2'

services:

  orderer.example.com:
    container_name: orderer.example.com
    image: hyperledger/fabric-orderer
    environment:
      - ORDERER_GENERAL_LOGLEVEL=debug
      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
      - ORDERER_GENERAL_GENESISMETHOD=file
      - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block
      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
      - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp
      # enabled TLS
      - ORDERER_GENERAL_TLS_ENABLED=true
      - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key
      - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt
      - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric
    command: orderer
    volumes:
    - ../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block
    - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp
    - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls
    ports:
      - 7050:7050

  peer0.org1.example.com:
    container_name: peer0.org1.example.com
    extends:
      file: peer-base.yaml
      service: peer-base
    environment:
      - CORE_PEER_ID=peer0.org1.example.com
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      - CORE_PEER_CHAINCODELISTENADDRESS=peer0.org1.example.com:7052
      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051
      - CORE_PEER_LOCALMSPID=Org1MSP
    volumes:
        - /var/run/:/host/var/run/
        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp
        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls
    ports:
      - 7051:7051
      - 7052:7052
      - 7053:7053

  

  peer0.org2.example.com:
    container_name: peer0.org2.example.com
    extends:
      file: peer-base.yaml
      service: peer-base
    environment:
      - CORE_PEER_ID=peer0.org2.example.com
      - CORE_PEER_ADDRESS=peer0.org2.example.com:7051
      - CORE_PEER_CHAINCODELISTENADDRESS=peer0.org2.example.com:7052
      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org2.example.com:7051
      - CORE_PEER_LOCALMSPID=Org2MSP
    volumes:
        - /var/run/:/host/var/run/
        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp:/etc/hyperledger/fabric/msp
        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls:/etc/hyperledger/fabric/tls
    ports:
      - 7051:7051
      - 7052:7052
      - 7053:7053
</code></pre> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">3.2</span><span style="color:#000000;">设置</span><span style="color:#000000;">orderer</span><span style="color:#000000;">节点的</span><span style="color:#000000;">docker-compose</span><span style="color:#000000;">文件</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">e2e_cli</span><span style="color:#000000;">提供了多个</span><span style="color:#000000;">docker-compose</span><span style="color:#000000;">文件，我们可以根据</span><span style="color:#000000;">docker-compose-cli</span><span style="color:#000000;">来修改</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">cp docker-compose-cli.yaml docker-compose-orderer.yaml</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">orderer</span><span style="color:#000000;">服务器上我们只需要保留</span><span style="color:#000000;">order</span><span style="color:#000000;">设置，其他</span><span style="color:#000000;">peer</span><span style="color:#000000;">和</span><span style="color:#000000;">cli</span><span style="color:#000000;">设置都可以删除。</span><span style="color:#000000;">orderer配置文件如下：</span></p> 
  <pre class="has">
<code># Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

version: '2'

services:

  orderer.example.com:
    extends:
      file:   base/docker-compose-base.yaml
      service: orderer.example.com
    container_name: orderer.example.com
</code></pre> 
  <h2 style="margin-left:0cm;"><strong>3.3设置peer节点的docker-compose文件</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">先为</span><span style="color:#000000;">peer0.org1.example.com</span><span style="color:#000000;">配置，与创建</span><span style="color:#000000;">orderer</span><span style="color:#000000;">的配置文件类似，我们也复制一个</span><span style="color:#000000;">yaml</span><span style="color:#000000;">文件出来进行修改：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">cp docker-compose-cli.yaml docker-compose-peer0org1.yaml</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">去掉</span><span style="color:#000000;">orderer</span><span style="color:#000000;">的配置，只保留一个</span><span style="color:#000000;">peer</span><span style="color:#000000;">和</span><span style="color:#000000;">cli</span><span style="color:#000000;">，因为我们要多级部署，节点与节点之前又是通过主机名通讯，所以需要修改容器中的</span><span style="color:#000000;">host</span><span style="color:#000000;">文件，也就是</span><span style="color:#000000;">extra_hosts</span><span style="color:#000000;">设置。因为之后我们要连接</span><span style="color:#000000;">couchdb</span><span style="color:#000000;">，所以这里加入</span><span style="color:#000000;">couchdb</span><span style="color:#000000;">的配置，这里的</span><span style="color:#000000;">192.168.1.162:5984</span><span style="color:#000000;">是我映射</span><span style="color:#000000;">CouchDB</span><span style="color:#000000;">后的</span><span style="color:#000000;">Linux</span><span style="color:#000000;">的</span><span style="color:#000000;">IP</span><span style="color:#000000;">地址和</span><span style="color:#000000;">IP,</span><span style="color:#000000;">然后是设置用户名和密码。</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">同样，</span><span style="color:#000000;">cli</span><span style="color:#000000;">也需要能够和各个节点通讯，所以</span><span style="color:#000000;">cli</span><span style="color:#000000;">下面也需要添加</span><span style="color:#000000;">extra_hosts</span><span style="color:#000000;">设置，去掉无效的依赖，并且去掉</span><span style="color:#000000;">command</span><span style="color:#000000;">这一行，因为我们是每个</span><span style="color:#000000;">peer</span><span style="color:#000000;">都会有个对应的客户端，也就是</span><span style="color:#000000;">cli</span><span style="color:#000000;">，所以我只需要去手动执行一次命令，而不是自动运行。</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">修改后的配置文件如下：</span></p> 
  <pre class="has">
<code># Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

version: '2'

services:

  peer0.org1.example.com:
    container_name: peer0.org1.example.com
    environment:
     - CORE_LEDGER_STATE_STATEDATABASE=CouchDB
     - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=192.168.1.162:5984
     - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin
     - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=password
    extends:
      file:  base/docker-compose-base.yaml
      service: peer0.org1.example.com
    extra_hosts:
     - "orderer.example.com:192.168.1.161"

  cli:
    container_name: cli
    image: hyperledger/fabric-tools
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_ID=cli
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    volumes:
        - /var/run/:/host/var/run/
        - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go
        - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
        - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/
        - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts
    depends_on:
      - peer0.org1.example.com
    extra_hosts:
     - "orderer.example.com:192.168.1.161"
     - "peer0.org1.example.com:192.168.1.162"
     - "peer0.org2.example.com:192.168.1.163"
</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">peer0.org2.example.com</span><span style="color:#000000;">配置文件</span><span style="color:#000000;">,</span><span style="color:#000000;">根据</span><span style="color:#000000;">peer0.org1.example.com</span><span style="color:#000000;">修改即可</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">cp docker-compose-peer0org1.yaml docker-compose-peer0org2.yaml</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">修改后的配置文件如下：</span></p> 
  <pre class="has">
<code># Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

version: '2'

services:

  peer0.org2.example.com:
    container_name: peer0.org2.example.com
    environment:
     - CORE_LEDGER_STATE_STATEDATABASE=CouchDB
     - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=192.168.1.163:5984
     - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin
     - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=password
    extends:
      file:  base/docker-compose-base.yaml
      service: peer0.org2.example.com
    extra_hosts:
     - "orderer.example.com:192.168.1.161"

  cli:
    container_name: cli
    image: hyperledger/fabric-tools
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_ID=cli
      - CORE_PEER_ADDRESS=peer0.org2.example.com:7051
      - CORE_PEER_LOCALMSPID=Org2MSP
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    volumes:
        - /var/run/:/host/var/run/
        - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go
        - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
        - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/
        - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts
    depends_on:
      - peer0.org2.example.com
    extra_hosts:
     - "orderer.example.com:192.168.1.161"
     - "peer0.org1.example.com:192.168.1.162"
     - "peer0.org2.example.com:192.168.1.163"
</code></pre> 
  <p style="margin-left:0cm;"><strong>3.4分发配置文件</strong></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">前面</span><span style="color:#000000;">4</span><span style="color:#000000;">步的操作，我们都是在</span><span style="color:#000000;">orderer.example.com</span><span style="color:#000000;">上完成的，接下来我们需要将这些文件分发到另外</span><span style="color:#000000;">2</span><span style="color:#000000;">台服务器上。</span><span style="color:#000000;">Linux</span><span style="color:#000000;">之间的文件传输，我们可以使用</span><span style="color:#000000;">scp</span><span style="color:#000000;">命令。</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">我先登录</span><span style="color:#000000;">peer0.org1.example.com</span><span style="color:#000000;">，将本地的</span><span style="color:#000000;">e2e_cli</span><span style="color:#000000;">文件夹删除：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">rm -r e2e_cli</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">然后再登录到</span><span style="color:#000000;">orderer</span><span style="color:#000000;">服务器上，退回到</span><span style="color:#000000;">examples</span><span style="color:#000000;">文件夹，因为这样可以方便的把其下的</span><span style="color:#000000;">e2e_cli</span><span style="color:#000000;">文件夹整个传到</span><span style="color:#000000;">peer0.org1</span><span style="color:#000000;">服务器上。</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">scp -r e2e_cli root@192.168.1.162:/home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">接下来继续使用</span><span style="color:#000000;">scp</span><span style="color:#000000;">命令将</span><span style="color:#000000;">orderer</span><span style="color:#000000;">上的文件夹传送给</span><span style="color:#000000;">peer0.org2.example.com</span><span style="color:#000000;">。</span></p> 
  <p style="margin-left:0cm;"><strong>以下为启动fabric部分</strong></p> 
  <h1 style="margin-left:0cm;"><strong>4.启动orderer节点和peer节点</strong></h1> 
  <h2 style="margin-left:0cm;"><strong>4.1 启动orderer节点</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">在</span><span style="color:#000000;">orderer</span><span style="color:#000000;">服务器上运行：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli



docker-compose -f docker-compose-orderer.yaml up -d</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">运行完毕后我们可以使用</span><span style="color:#000000;">docker ps</span><span style="color:#000000;">看到运行了一个名字为</span><span style="color:#000000;">orderer.example.com</span><span style="color:#000000;">的容器。</span></p> 
  <p style="margin-left:0cm;">&nbsp;<span style="color:#000000;">此时，自动按照指定配置创建系统通道，还没有应用通道</span></p> 
  <h2 style="margin-left:0cm;"><strong>4.2 启动peer节点</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">在</span><span style="color:#000000;">peer0.org1.example.com</span><span style="color:#000000;">服务器执行命令：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">docker-compose -f docker-compose-peer0org1.yaml up -d</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">运行完毕后我们使用</span><span style="color:#000000;">docker ps</span><span style="color:#000000;">应该可以看到</span><span style="color:#000000;">peer</span><span style="color:#000000;">、</span><span style="color:#000000;">cli</span><span style="color:#000000;">两个个正在运行的容器。</span>&nbsp;</p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">接下来切回到</span><span style="color:#000000;">peer0.org2.example.com</span><span style="color:#000000;">服务器。运行相同的命令：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">docker-compose -f docker-compose-peer0org2.yaml up -d</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">现在我们整个</span><span style="color:#000000;">Fabric</span><span style="color:#000000;">网络已经成型，接下来是创建</span><span style="color:#000000;">channel</span><span style="color:#000000;">和运行</span><span style="color:#000000;">ChainCode</span><span style="color:#000000;">。</span>&nbsp;</p> 
  <h1 style="margin-left:0cm;"><strong>5.创建channel，各peer加入channel</strong></h1> 
  <h2 style="margin-left:0cm;"><strong>5.1 创建channel</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">我们切换到</span><span style="color:#000000;">peer0.org1.example.com</span><span style="color:#000000;">服务器上，使用该服务器上的</span><span style="color:#000000;">cli</span><span style="color:#000000;">来运行创建</span><span style="color:#000000;">Channel</span><span style="color:#000000;">和运行</span><span style="color:#000000;">ChainCode</span><span style="color:#000000;">的操作。先用以下命令进入</span><span style="color:#000000;">CLI</span><span style="color:#000000;">内部</span><span style="color:#000000;">Bash</span><span style="color:#000000;">：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">docker exec -it cli bash</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">创建</span><span style="color:#000000;">Channel</span><span style="color:#000000;">的命令是</span><span style="color:#000000;">peer channel create</span><span style="color:#000000;">，我们前面创建</span><span style="color:#000000;">Channel</span><span style="color:#000000;">的配置区块时，指定了</span><span style="color:#000000;">Channel</span><span style="color:#000000;">的名字是</span><span style="color:#000000;">mychannel</span><span style="color:#000000;">，那么这里我们必须创建同样名字的</span><span style="color:#000000;">Channel</span><span style="color:#000000;">，创建了应用通道。</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls true --cafile $ORDERER_CA</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">执行该命令后，系统会提示：</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">2017-10-30 18:30:35.210 UTC [channelCmd] readBlock -&gt; DEBU 020 Received block:0</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">系统会在</span><span style="color:#000000;">cli</span><span style="color:#000000;">内部的当前目录创建一个</span><span style="color:#000000;">mychannel.block</span><span style="color:#000000;">文件，这个文件非常重要，接下来其他节点要加入这个</span><span style="color:#000000;">Channel</span><span style="color:#000000;">就必须使用这个文件。</span>&nbsp;</p> 
  <h2 style="margin-left:0cm;"><strong>5.2各个peer加入channel</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">还是在</span><span style="color:#000000;">peer0.org1</span><span style="color:#000000;">的</span><span style="color:#000000;">CLI</span><span style="color:#000000;">上，我们要将这个</span><span style="color:#000000;">Peer</span><span style="color:#000000;">加入</span><span style="color:#000000;">mychannel</span><span style="color:#000000;">就很简单，只需要运行如下命令：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">peer channel join -b mychannel.block</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">系统返回消息：</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">2017-10-30 18:40:21.405&nbsp;UTC [channelCmd] executeJoin -&gt; INFO 006 Peer joined the channel!</span></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">修改</span><span style="color:#000000;">cli</span><span style="color:#000000;">的环境变量，使其指向peer0.org2</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_LOCALMSPID="Org2MSP" </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_ADDRESS=peer0.org2.example.com:7051</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">peer channel join -b mychannel.block</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">这样</span><span style="color:#000000;">peer0.org1</span><span style="color:#000000;">和</span><span style="color:#000000;">peer0.org2</span><span style="color:#000000;">就都已经加入</span><span style="color:#000000;">channel</span><span style="color:#000000;">了。</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">注：这一切都是我在</span><span style="color:#000000;">peer0.org1</span><span style="color:#000000;">的</span><span style="color:#000000;">cli</span><span style="color:#000000;">内完成的，这是由于加入</span><span style="color:#000000;">channel</span><span style="color:#000000;">依赖</span><span style="color:#000000;"> [channel-ID].block</span><span style="color:#000000;">文件，而且在</span><span style="color:#000000;">peer0.org1</span><span style="color:#000000;">服务器的</span><span style="color:#000000;">cli</span><span style="color:#000000;">内也留有了</span><span style="color:#000000;">peer0.org2</span><span style="color:#000000;">的证书文件，因此两个节点的加入都在一个</span><span style="color:#000000;">cli</span><span style="color:#000000;">内完成了。其实当一个节点创建</span><span style="color:#000000;">channel</span><span style="color:#000000;">以后可以把</span><span style="color:#000000;">[channel-ID].block</span><span style="color:#000000;">文件从容器内拷贝到主机，再分发给其他节点，这样其他节点就可以通过</span><span style="color:#000000;">[channel-ID].block</span><span style="color:#000000;">加入</span><span style="color:#000000;">channel</span><span style="color:#000000;">了。当</span><span style="color:#000000;">cli</span><span style="color:#000000;">容器被销毁时该容器下所有的文件都会被销毁，但是如果备份了</span><span style="color:#000000;">[channel-ID].block</span><span style="color:#000000;">，那么即使所有的</span><span style="color:#000000;">peer</span><span style="color:#000000;">和</span><span style="color:#000000;">cli</span><span style="color:#000000;">被销毁了，也可以再次通过</span><span style="color:#000000;">[channel-ID].block</span><span style="color:#000000;">加入</span><span style="color:#000000;">channel</span><span style="color:#000000;">、同步区块。</span>&nbsp;</p> 
  <h2 style="margin-left:0cm;"><strong>5.3 更新锚节点</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">关于</span><span style="color:#000000;">AnchorPeer</span><span style="color:#000000;">，其实我的每个组织只有一个</span><span style="color:#000000;">peer</span><span style="color:#000000;">节点，所以更新不更新锚节点也不重要。</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">对于</span><span style="color:#000000;">Org1</span><span style="color:#000000;">来说，</span><span style="color:#000000;">peer0.org1</span><span style="color:#000000;">是锚节点，我们需要切换到</span><span style="color:#000000;">peer0.org1服务器上并更新锚节点：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_LOCALMSPID="Org1MSP" </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_ADDRESS=peer0.org1.example.com:7051</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">&nbsp; peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls true --cafile $ORDERER_CA</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">另外对于</span><span style="color:#000000;">Org2</span><span style="color:#000000;">，</span><span style="color:#000000;">peer0.org2</span><span style="color:#000000;">是锚节点，切换到</span><span style="color:#000000;">peer0.org2服务器上然后执行如下命令：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_LOCALMSPID="Org2MSP" </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp </code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_ADDRESS=peer0.org2.example.com:7051</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls true --cafile $ORDERER_CA</code></pre> 
  <h1 style="margin-left:0cm;"><strong>6.chaincode的安装与运行</strong></h1> 
  <h2 style="margin-left:0cm;"><strong>6.1 安装chaincode</strong></h2> 
  <p style="margin-left:0cm;">对需要共识的peer节点都要安装链码</p> 
  <p style="margin-left:0cm;">以peer0.org1为例，先切换至该节点：</p> 
  <p style="margin-left:0cm;">CORE_PEER_LOCALMSPID="Org1MSP"</p> 
  <p style="margin-left:0cm;">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</p> 
  <p style="margin-left:0cm;">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</p> 
  <p style="margin-left:0cm;">CORE_PEER_ADDRESS=peer0.org1.example.com:7051</p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">在</span><span style="color:#000000;">cli</span><span style="color:#000000;">上为每一个</span><span style="color:#000000;">peer</span><span style="color:#000000;">安装链上代码，用</span><span style="color:#000000;">peer chaincode install</span><span style="color:#000000;">命令可以安装指定的</span><span style="color:#000000;">ChainCode</span><span style="color:#000000;">并对其命名：</span></p> 
  <p style="margin-left:0cm;">peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">安装的过程其实就是对</span><span style="color:#000000;">CLI</span><span style="color:#000000;">中指定的代码进行编译打包，并把打包好的文件发送到</span><span style="color:#000000;">Peer</span><span style="color:#000000;">，等待接下来的实例化。</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">切换到</span><span style="color:#000000;">peer0.org2</span><span style="color:#000000;">服务器，给</span><span style="color:#000000;">peer0.org2</span><span style="color:#000000;">安装链上代码：</span></p> 
  <p style="margin-left:0cm;">peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02&nbsp;</p> 
  <h2 style="margin-left:0cm;"><strong>6.2 实例化chaincode</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">实例化链上代码主要是在</span><span style="color:#000000;">Peer</span><span style="color:#000000;">所在的机器上对前面安装好的链上代码进行包装，生成对应</span><span style="color:#000000;">Channel</span><span style="color:#000000;">的</span><span style="color:#000000;">Docker</span><span style="color:#000000;">镜像和</span><span style="color:#000000;">Docker</span><span style="color:#000000;">容器。并且在实例化时我们可以指定背书策略。我们在</span><span style="color:#000000;">peer0.org1</span><span style="color:#000000;">服务器的</span><span style="color:#000000;">cli</span><span style="color:#000000;">内运行以下命令完成实例化：</span></p> 
  <p style="margin-left:0cm;">peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc -v 1.0 -c '{"Args":["init","a","100","b","200"]}' -P "OR ('Org1MSP.member','Org2MSP.member')"</p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">使用</span><span style="color:#000000;">docker ps</span><span style="color:#000000;">可以看到有新的容器</span><span style="color:#000000;">&nbsp;dev-peer0.org1.example.com-mycc-1.0</span><span style="color:#000000;">正在运行。</span></p> 
  <h2 style="margin-left:0cm;"><strong>6.3 在一个peer发起交易&nbsp;</strong></h2> 
  <p style="margin-left:0cm;">在peer0.org1上发起交易</p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">查询a的余额，peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'</code></pre> 
  <p style="margin-left:0cm;">返回结果</p> 
  <p style="margin-left:0cm;">Query result： 100</p> 
  <p style="margin-left:0cm;">转账：a向b转账10元</p> 
  <p style="margin-left:0cm;">peer chaincode invoke -o orderer.example.com:7050&nbsp; --tls true --cafile $ORDERER_CA -C mychannel -n mycc -c '{"Args":["invoke","a","b","10"]}'</p> 
  <h2 style="margin-left:0cm;"><strong>6.4 在另一个节点上查询交易</strong></h2> 
  <p style="margin-left:0cm;"><span style="color:#000000;">前面的操作都是在</span><span style="color:#000000;">org1</span><span style="color:#000000;">下面做的，那么处于同一个区块链（同一个</span><span style="color:#000000;">Channel</span><span style="color:#000000;">下）的</span><span style="color:#000000;">org2</span><span style="color:#000000;">，是否会看</span><span style="color:#000000;">org1</span><span style="color:#000000;">的更改呢？切换到</span><span style="color:#000000;">peer0.org2</span><span style="color:#000000;">服务器，由于</span><span style="color:#000000;">mycc</span><span style="color:#000000;">已经在前面</span><span style="color:#000000;">org1</span><span style="color:#000000;">的时候实例化了，也就是说对应的区块已经生成了，所以在</span><span style="color:#000000;">org2</span><span style="color:#000000;">不能再次初始化。我们直接运行查询命令：</span></p> 
  <p style="margin-left:0cm;">首先CLI指向peer1.org2，然后查询</p> 
  <p style="margin-left:0cm;">peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'</p> 
  <p style="margin-left:0cm;">需要较长时间（几十秒）</p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">因为</span><span style="color:#000000;">peer0.org2</span><span style="color:#000000;">也需要生成</span><span style="color:#000000;">Docker</span><span style="color:#000000;">镜像，创建对应的容器，才能通过容器返回结果，所以等的时间会稍长一点。我们回到</span><span style="color:#000000;">Ubuntu</span><span style="color:#000000;">终端，执行</span><span style="color:#000000;">docker ps</span><span style="color:#000000;">，可以看到</span><span style="color:#000000;">peer0.org2</span><span style="color:#000000;">也多了一个容器：</span><span style="color:#000000;">dev-peer0.org2.example.com-mycc-1.0&nbsp;&nbsp;</span></p> 
  <h1 style="margin-left:0cm;"><strong>7. 查看日志</strong></h1> 
  <p style="margin-left:0cm;"><span style="color:#000000;">这样整个区块链网络算是正式跑通了！如果想知道</span><span style="color:#000000;">orderer</span><span style="color:#000000;">和</span><span style="color:#000000;">peer</span><span style="color:#000000;">之间具体都发生了些什么我们可以进入对应的服务器，输入命令：</span></p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">docker logs -f orderer.example.com</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">docker logs -f peer0.org1.example.com</code></pre> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">docker logs -f peer0.org2.example.com</code></pre> 
  <p style="margin-left:0cm;"><span style="color:#000000;">这样就可以查看对应的日志，也可以查询报错。</span></p> 
  <h1 style="margin-left:0cm;"><strong>8.退出CLI客户端后操作（以peer0org2退出后再查询余额为例）</strong></h1> 
  <p style="margin-left:0cm;">（1） 进入CLI内部</p> 
  <p style="margin-left:0cm;">docker exec -it cli bash</p> 
  <p style="margin-left:0cm;">（2）公私钥认证</p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt </code></pre> 
  <p style="margin-left:0cm;">（3）操作链码</p> 
  <pre class="has" style="margin-left:0cm;">
<code class="language-html">peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'</code></pre> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">参考：<a href="http://www.cnblogs.com/preminem/p/7729723.html" rel="nofollow">http://www.cnblogs.com/preminem/p/7729723.html</a></p> 
  <p style="margin-left:0cm;">https://www.cnblogs.com/studyzy/p/7237287.html</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_30852577/article/details/81298096,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_30852577/article/details/81298096,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
