<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>超级账本HyperLedger：Fabric的Chaincode（智能合约、链码）开发、使用演示 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="超级账本HyperLedger：Fabric的Chaincode（智能合约、链码）开发、使用演示" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="作者:&nbsp;李佶澳&nbsp;&nbsp;&nbsp;转载请保留：原文地址&nbsp;&nbsp;&nbsp;发布时间：2018/07/17 10:20:00 说明 Example-1：demo 合约安装&amp;单合约调用 获取合约代码 安装合约&amp;初始化 合约直接调用 并发或快速修改数据时需要注意的问题 合约链式调用 参考 说明 这是网易云课堂“IT技术快速入门学院”使用的素材。 这里演示合约的用法，合约代码托管在在Github上：合约代码。 怎样写合约参考： 超级账本HyperLedger：Fabric Chaincode（智能合约、链码）开发方法 Example-1：demo example-1: demo中演示了最基本、最常用的方法，可以通过这个合约进行下面操作： func (t *Chaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response { function, args := stub.GetFunctionAndParameters() switch function { //返回调用者信息 case &quot;creator&quot;: return t.creator(stub, args) //调用改合约中的其它方法，用来演示复杂的调用 case &quot;call&quot;: return t.call(stub, args) //直接对key的内容进行append，用来演示这样操作的结果 case &quot;append&quot;: return t.append(stub, args) //读取当前用户的属性值 case &quot;attr&quot;: return t.attr(stub, args) //查询一个key的当前值 case &quot;query&quot;: if len(args) != 1 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.query(stub, args[0]) //查询一个key的所有历史值 case &quot;history&quot;: if len(args) != 1 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.history(stub, args[0]) //创建一个key，并写入key的值 case &quot;write&quot;: //写入 if len(args) != 2 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.write(stub, args[0], args[1]) //通过当前合约，到另一个合约中进行查询 case &quot;query_chaincode&quot;: if len(args) != 2 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.query_chaincode(stub, args[0], args[1]) //通过当前合约，到另一个合约中进行写入 case &quot;write_chaincode&quot;: if len(args) != 3 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.write_chaincode(stub, args[0], args[1], args[2]) default: return shim.Error(&quot;Invalid invoke function name.&quot;) } } 完整代码： 合约代码。 合约安装&amp;单合约调用 获取合约代码 可以用下面的方式获取合约源代码： mkdir -p $GOPATH/github.com/introclass cd $GOPATH/github.com/introclass git https://github.com/introclass/hyperledger-fabric-chaincodes.git 或者： go get github.com/introclass/hyperledger-fabric-chaincodes 安装合约&amp;初始化 安装合约： cd /opt/app/fabric/cli/user/member1.example.com/Admin-peer0.member1.example.com ./3_install_chaincode.sh 合约初始化： ./4_instantiate_chaincode.sh 到另一个Peer上再安装一次合约： cd /opt/app/fabric/cli/user/member1.example.com/Admin-peer1.member1.example.com/ ./3_install_chaincode.sh &lt;不需要再次实例化&gt; 合约直接调用 下面的操作可以在任意一个Peer进行。 查看当前调用者，调用creator方法： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;creator&quot;]}&#39; 2018-07-18 12:45:48.083 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:45:48.083 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: peers.member1.example.com�-----BEGIN CERTIFICATE----- MIICIjCCAcmgAwIBAgIRANQT46AE7SALHhoFnvodmiowCgYIKoZIzj0EAwIweTEL MAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG cmFuY2lzY28xHDAaBgNVBAoTE21lbWJlcjEuZXhhbXBsZS5jb20xHzAdBgNVBAMT FmNhLm1lbWJlcjEuZXhhbXBsZS5jb20wHhcNMTgwNzE1MDcwMzIzWhcNMjgwNzEy MDcwMzIzWjBeMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQG A1UEBxMNU2FuIEZyYW5jaXNjbzEiMCAGA1UEAwwZQWRtaW5AbWVtYmVyMS5leGFt cGxlLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDMq5zAdcQgGWklQMdTf irdHhbTBsLALJ0hjKFfaLIRyKO7Bq39HFrxPybLc/d4PXDXXrQsS9HCnKj9PSO6u DBSjTTBLMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1UdIwQkMCKA IIPK7RfYFuMcuUQahKin2FxuaskfZl3WWtCMmEhN06lMMAoGCCqGSM49BAMCA0cA MEQCIBnA0dhz/AnvsjNoWEuNBWIxRgKpG9CHbScrbQ7U9WK+AiAaZ4Qi7OZd8zev ZZUxizW00+GqDXJWJ9VX6edtKDNVFw== -----END CERTIFICATE----- 2018-07-18 12:45:48.087 CST [main] main -&gt; INFO 003 Exiting..... 写入Key: $ ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key&quot;,&quot;keyvalue&quot;]}&#39; 2018-07-18 12:48:30.728 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:48:30.728 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc 2018-07-18 12:48:30.775 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200 2018-07-18 12:48:30.775 CST [main] main -&gt; INFO 004 Exiting..... 查询刚写入的key: $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key&quot;]}&#39; 2018-07-18 12:49:14.464 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:49:14.464 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: keyvalue &lt;-- 查询的结果 2018-07-18 12:49:14.468 CST [main] main -&gt; INFO 003 Exiting..... 更改key的值: $ ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key&quot;,&quot;keyvalue1&quot;]}&#39; 2018-07-18 12:50:44.023 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:50:44.023 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc 2018-07-18 12:50:44.027 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200 2018-07-18 12:50:44.028 CST [main] main -&gt; INFO 004 Exiting..... 查询key的历史数据： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key&quot;]}&#39; 2018-07-18 12:52:25.332 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:52:25.332 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: {&quot;93ea6b185bb886c70f66b8b0dc8f5c727043269e2b7b7e76ae36644cd8ef3916&quot;:&quot;keyvalue&quot;,&quot;f87a0f6f972226a57ade04a8e54db1a014d12cbab40abcbd8a5d65fe10bdfeff&quot;:&quot;keyvalue1&quot;} &lt;可以看到历史值有两个&gt; 2018-07-18 12:52:25.340 CST [main] main -&gt; INFO 003 Exiting..... 并发或快速修改数据时需要注意的问题 合约中的append方法的用是，读取一个key的value，然后在读取出来的数值上修改，最后重新写入账本。 需要特别注意，这种做法是有问题的，例如下面脚本预期的最终结果是[“1”,”2”,”3”,”4”,”5”,”6”,”7”,”8”,”9”,”10”]： for i in {1..10} do echo $i sleep 1 ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &quot;{\&quot;Args\&quot;:[\&quot;append\&quot;,\&quot;key-array\&quot;,\&quot;$i\&quot;]}&quot; done 但执行结束后，得到的结果却是： ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-array&quot;]}&#39; 2018-07-18 13:28:35.996 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:28:35.997 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;,&quot;9&quot;] 2018-07-18 13:28:36.001 CST [main] main -&gt; INFO 003 Exiting..... 查看历史价值，发现也有很多缺失的数据： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key-array&quot;]}&#39; 2018-07-18 13:28:44.773 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:28:44.773 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: { &quot;2bace9ac4812416969f623a471e902ecb6198bc9d16c1ca1e7e9586adf6cd428&quot;:&quot;[\&quot;1\&quot;,\&quot;3\&quot;,\&quot;5\&quot;,\&quot;7\&quot;,\&quot;9\&quot;]&quot;, &quot;6832ef710f74a39bc08e3386d0eb8aa757cb53ccd7fe149b042417b5cc436750&quot;:&quot;[\&quot;1\&quot;,\&quot;3\&quot;,\&quot;5\&quot;]&quot;, &quot;8c041cd53f045999dc41ca1facb8dbce8acb4a07ff5dd558a53f8f2908789b3d&quot;:&quot;[\&quot;1\&quot;]&quot;, &quot;d1b68113730f0bb8adb9a19c64594e64729b4a1c1aa81a412edd6b1b1ad84e06&quot;:&quot;[\&quot;1\&quot;,\&quot;3\&quot;]&quot;, &quot;d5fe258cc64d5f10f63b8a9f3c1d321d966f4d5c45b17b5b8c31eccad231e3fd&quot;:&quot;[\&quot;1\&quot;,\&quot;3\&quot;,\&quot;5\&quot;,\&quot;7\&quot;]&quot;} 2018-07-18 13:28:44.777 CST [main] main -&gt; INFO 003 Exiting..... 出现这种结果的原因是，其中一些append操作是基于“旧”的数据的：之前的append操作依旧修改了数据，但是当前的append还不能查询到最新的数据。 这些append操作不会被接受。 如果只“修改”数据，则会是另一种结果： for i in {1..10} do ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &quot;{\&quot;Args\&quot;:[\&quot;write\&quot;,\&quot;key-single\&quot;,\&quot;$i\&quot;]}&quot; done 执行以后查询当前值，为10： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:41:45.257 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:41:45.257 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 10 2018-07-18 13:41:45.261 CST [main] main -&gt; INFO 003 Exiting..... 但可以在历史数据中找到所有的值： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:42:47.206 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:42:47.206 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: { &quot;0b6e46b6397ad2e76b2de842f162d558ce88b2409656d16a30b9f53f6a038357&quot;:&quot;6&quot;, &quot;1015deb1cdfd3e08a5da2fd03ddeb0e1df69287d88c017f7d55678405fbac774&quot;:&quot;8&quot;, &quot;5291a41b310b31b14b5b96c981dc9a6923ed4c956b52ee4e662fc65167531435&quot;:&quot;3&quot;, &quot;691678195fd7fbd7787ff6fb128adff87c34de9c96e62b599320d8c1966a8397&quot;:&quot;7&quot;, &quot;876374f0551eb227351f5312ca494d141cdddae99e7d67ffeffdd0094e5532bb&quot;:&quot;1&quot;, &quot;8b02dae72f1d6f9a4db6e2daa4947be1d5bcdbfa4f4fbb7a69382cc85510732b&quot;:&quot;4&quot;, &quot;b5c89bacda118d0e0a7777aad8083c1920ac90201e3dac0e8df6385038afee5c&quot;:&quot;10&quot;, &quot;de111d7b19b68918502a52d36f49fbd17a18db46a69379d3566f8d0531307871&quot;:&quot;2&quot;, &quot;e2dbb13a5d42c33756341f487357a526e669ca5fbdefd7e49026f12e3979889c&quot;:&quot;5&quot;, &quot;eb802055364096703b351cea60c0392119c487b0ab3a9cd6ed344ee897b6fa1a&quot;:&quot;9&quot;} 2018-07-18 13:42:47.210 CST [main] main -&gt; INFO 003 Exiting..... 并发写入的问题可以参考： HyperLedger High-Throughput Network Hyperledger Fabric and how it isn’t concurrent out of the box. How hyperledger handle the Concurrent of “invoke” of the same Key-Value pair of chaincode? 合约链式调用 就是通过当前合约，调用另一个合约。 demo合约中提供了一个call方法，可以很方便的测试合约链式调用： [&quot;call&quot;,&quot;chaincode&quot;,&quot;method&quot;...] 通过demo合约调用另一个合约 例如再部署一个叫做mycc2的合约，也使用demo的源代码，部署的合约名不同。 通过mycc调用mycc2的query： 在mycc2中查询不到通过mycc写入的数据 $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:53:15.680 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:53:15.680 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:53:15.774 CST [main] main -&gt; INFO 003 Exiting..... 直接调用mycc2也是一样查不到 $ ./peer.sh chaincode query -C mychannel -n mycc2 -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:55:23.315 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:55:23.315 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:55:23.327 CST [main] main -&gt; INFO 003 Exiting..... 在mycc中可以查到 $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:53:31.077 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:53:31.077 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 10 2018-07-18 13:53:31.082 CST [main] main -&gt; INFO 003 Exiting..... 如果用query方式调用另一个合约的invoke是无效的： 在mycc2中写入key $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;write&quot;,&quot;key-single&quot;,&quot;inmycc2&quot;]}&#39; 2018-07-18 13:59:25.610 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:25.610 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:59:25.615 CST [main] main -&gt; INFO 003 Exiting..... 无效，查询不到key $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:59:15.796 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:15.796 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:59:15.802 CST [main] main -&gt; INFO 003 Exiting..... 如果用invoke方式调用另一个合约的invoke是有效的： $ ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;write&quot;,&quot;key-single&quot;,&quot;inmycc2&quot;]}&#39; 2018-07-18 13:59:48.432 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:48.432 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc 2018-07-18 13:59:48.439 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200 2018-07-18 13:59:48.440 CST [main] main -&gt; INFO 004 Exiting..... 可以查询到 $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:59:55.470 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:55.470 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: inmycc2 2018-07-18 13:59:55.476 CST [main] main -&gt; INFO 003 Exiting..... 参考 演示使用的合约代码 example-1: demo 超级账本HyperLedger：Fabric Chaincode（智能合约、链码）开发方法 Hyperledger Fabric and how it isn’t concurrent out of the box. How hyperledger handle the Concurrent of “invoke” of the same Key-Value pair of chaincode? HyperLedger High-Throughput Network 限时活动，每邀请一人即返回25元！ 阅读更多" />
<meta property="og:description" content="作者:&nbsp;李佶澳&nbsp;&nbsp;&nbsp;转载请保留：原文地址&nbsp;&nbsp;&nbsp;发布时间：2018/07/17 10:20:00 说明 Example-1：demo 合约安装&amp;单合约调用 获取合约代码 安装合约&amp;初始化 合约直接调用 并发或快速修改数据时需要注意的问题 合约链式调用 参考 说明 这是网易云课堂“IT技术快速入门学院”使用的素材。 这里演示合约的用法，合约代码托管在在Github上：合约代码。 怎样写合约参考： 超级账本HyperLedger：Fabric Chaincode（智能合约、链码）开发方法 Example-1：demo example-1: demo中演示了最基本、最常用的方法，可以通过这个合约进行下面操作： func (t *Chaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response { function, args := stub.GetFunctionAndParameters() switch function { //返回调用者信息 case &quot;creator&quot;: return t.creator(stub, args) //调用改合约中的其它方法，用来演示复杂的调用 case &quot;call&quot;: return t.call(stub, args) //直接对key的内容进行append，用来演示这样操作的结果 case &quot;append&quot;: return t.append(stub, args) //读取当前用户的属性值 case &quot;attr&quot;: return t.attr(stub, args) //查询一个key的当前值 case &quot;query&quot;: if len(args) != 1 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.query(stub, args[0]) //查询一个key的所有历史值 case &quot;history&quot;: if len(args) != 1 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.history(stub, args[0]) //创建一个key，并写入key的值 case &quot;write&quot;: //写入 if len(args) != 2 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.write(stub, args[0], args[1]) //通过当前合约，到另一个合约中进行查询 case &quot;query_chaincode&quot;: if len(args) != 2 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.query_chaincode(stub, args[0], args[1]) //通过当前合约，到另一个合约中进行写入 case &quot;write_chaincode&quot;: if len(args) != 3 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.write_chaincode(stub, args[0], args[1], args[2]) default: return shim.Error(&quot;Invalid invoke function name.&quot;) } } 完整代码： 合约代码。 合约安装&amp;单合约调用 获取合约代码 可以用下面的方式获取合约源代码： mkdir -p $GOPATH/github.com/introclass cd $GOPATH/github.com/introclass git https://github.com/introclass/hyperledger-fabric-chaincodes.git 或者： go get github.com/introclass/hyperledger-fabric-chaincodes 安装合约&amp;初始化 安装合约： cd /opt/app/fabric/cli/user/member1.example.com/Admin-peer0.member1.example.com ./3_install_chaincode.sh 合约初始化： ./4_instantiate_chaincode.sh 到另一个Peer上再安装一次合约： cd /opt/app/fabric/cli/user/member1.example.com/Admin-peer1.member1.example.com/ ./3_install_chaincode.sh &lt;不需要再次实例化&gt; 合约直接调用 下面的操作可以在任意一个Peer进行。 查看当前调用者，调用creator方法： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;creator&quot;]}&#39; 2018-07-18 12:45:48.083 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:45:48.083 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: peers.member1.example.com�-----BEGIN CERTIFICATE----- MIICIjCCAcmgAwIBAgIRANQT46AE7SALHhoFnvodmiowCgYIKoZIzj0EAwIweTEL MAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG cmFuY2lzY28xHDAaBgNVBAoTE21lbWJlcjEuZXhhbXBsZS5jb20xHzAdBgNVBAMT FmNhLm1lbWJlcjEuZXhhbXBsZS5jb20wHhcNMTgwNzE1MDcwMzIzWhcNMjgwNzEy MDcwMzIzWjBeMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQG A1UEBxMNU2FuIEZyYW5jaXNjbzEiMCAGA1UEAwwZQWRtaW5AbWVtYmVyMS5leGFt cGxlLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDMq5zAdcQgGWklQMdTf irdHhbTBsLALJ0hjKFfaLIRyKO7Bq39HFrxPybLc/d4PXDXXrQsS9HCnKj9PSO6u DBSjTTBLMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1UdIwQkMCKA IIPK7RfYFuMcuUQahKin2FxuaskfZl3WWtCMmEhN06lMMAoGCCqGSM49BAMCA0cA MEQCIBnA0dhz/AnvsjNoWEuNBWIxRgKpG9CHbScrbQ7U9WK+AiAaZ4Qi7OZd8zev ZZUxizW00+GqDXJWJ9VX6edtKDNVFw== -----END CERTIFICATE----- 2018-07-18 12:45:48.087 CST [main] main -&gt; INFO 003 Exiting..... 写入Key: $ ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key&quot;,&quot;keyvalue&quot;]}&#39; 2018-07-18 12:48:30.728 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:48:30.728 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc 2018-07-18 12:48:30.775 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200 2018-07-18 12:48:30.775 CST [main] main -&gt; INFO 004 Exiting..... 查询刚写入的key: $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key&quot;]}&#39; 2018-07-18 12:49:14.464 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:49:14.464 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: keyvalue &lt;-- 查询的结果 2018-07-18 12:49:14.468 CST [main] main -&gt; INFO 003 Exiting..... 更改key的值: $ ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key&quot;,&quot;keyvalue1&quot;]}&#39; 2018-07-18 12:50:44.023 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:50:44.023 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc 2018-07-18 12:50:44.027 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200 2018-07-18 12:50:44.028 CST [main] main -&gt; INFO 004 Exiting..... 查询key的历史数据： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key&quot;]}&#39; 2018-07-18 12:52:25.332 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:52:25.332 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: {&quot;93ea6b185bb886c70f66b8b0dc8f5c727043269e2b7b7e76ae36644cd8ef3916&quot;:&quot;keyvalue&quot;,&quot;f87a0f6f972226a57ade04a8e54db1a014d12cbab40abcbd8a5d65fe10bdfeff&quot;:&quot;keyvalue1&quot;} &lt;可以看到历史值有两个&gt; 2018-07-18 12:52:25.340 CST [main] main -&gt; INFO 003 Exiting..... 并发或快速修改数据时需要注意的问题 合约中的append方法的用是，读取一个key的value，然后在读取出来的数值上修改，最后重新写入账本。 需要特别注意，这种做法是有问题的，例如下面脚本预期的最终结果是[“1”,”2”,”3”,”4”,”5”,”6”,”7”,”8”,”9”,”10”]： for i in {1..10} do echo $i sleep 1 ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &quot;{\&quot;Args\&quot;:[\&quot;append\&quot;,\&quot;key-array\&quot;,\&quot;$i\&quot;]}&quot; done 但执行结束后，得到的结果却是： ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-array&quot;]}&#39; 2018-07-18 13:28:35.996 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:28:35.997 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;,&quot;9&quot;] 2018-07-18 13:28:36.001 CST [main] main -&gt; INFO 003 Exiting..... 查看历史价值，发现也有很多缺失的数据： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key-array&quot;]}&#39; 2018-07-18 13:28:44.773 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:28:44.773 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: { &quot;2bace9ac4812416969f623a471e902ecb6198bc9d16c1ca1e7e9586adf6cd428&quot;:&quot;[\&quot;1\&quot;,\&quot;3\&quot;,\&quot;5\&quot;,\&quot;7\&quot;,\&quot;9\&quot;]&quot;, &quot;6832ef710f74a39bc08e3386d0eb8aa757cb53ccd7fe149b042417b5cc436750&quot;:&quot;[\&quot;1\&quot;,\&quot;3\&quot;,\&quot;5\&quot;]&quot;, &quot;8c041cd53f045999dc41ca1facb8dbce8acb4a07ff5dd558a53f8f2908789b3d&quot;:&quot;[\&quot;1\&quot;]&quot;, &quot;d1b68113730f0bb8adb9a19c64594e64729b4a1c1aa81a412edd6b1b1ad84e06&quot;:&quot;[\&quot;1\&quot;,\&quot;3\&quot;]&quot;, &quot;d5fe258cc64d5f10f63b8a9f3c1d321d966f4d5c45b17b5b8c31eccad231e3fd&quot;:&quot;[\&quot;1\&quot;,\&quot;3\&quot;,\&quot;5\&quot;,\&quot;7\&quot;]&quot;} 2018-07-18 13:28:44.777 CST [main] main -&gt; INFO 003 Exiting..... 出现这种结果的原因是，其中一些append操作是基于“旧”的数据的：之前的append操作依旧修改了数据，但是当前的append还不能查询到最新的数据。 这些append操作不会被接受。 如果只“修改”数据，则会是另一种结果： for i in {1..10} do ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &quot;{\&quot;Args\&quot;:[\&quot;write\&quot;,\&quot;key-single\&quot;,\&quot;$i\&quot;]}&quot; done 执行以后查询当前值，为10： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:41:45.257 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:41:45.257 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 10 2018-07-18 13:41:45.261 CST [main] main -&gt; INFO 003 Exiting..... 但可以在历史数据中找到所有的值： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:42:47.206 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:42:47.206 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: { &quot;0b6e46b6397ad2e76b2de842f162d558ce88b2409656d16a30b9f53f6a038357&quot;:&quot;6&quot;, &quot;1015deb1cdfd3e08a5da2fd03ddeb0e1df69287d88c017f7d55678405fbac774&quot;:&quot;8&quot;, &quot;5291a41b310b31b14b5b96c981dc9a6923ed4c956b52ee4e662fc65167531435&quot;:&quot;3&quot;, &quot;691678195fd7fbd7787ff6fb128adff87c34de9c96e62b599320d8c1966a8397&quot;:&quot;7&quot;, &quot;876374f0551eb227351f5312ca494d141cdddae99e7d67ffeffdd0094e5532bb&quot;:&quot;1&quot;, &quot;8b02dae72f1d6f9a4db6e2daa4947be1d5bcdbfa4f4fbb7a69382cc85510732b&quot;:&quot;4&quot;, &quot;b5c89bacda118d0e0a7777aad8083c1920ac90201e3dac0e8df6385038afee5c&quot;:&quot;10&quot;, &quot;de111d7b19b68918502a52d36f49fbd17a18db46a69379d3566f8d0531307871&quot;:&quot;2&quot;, &quot;e2dbb13a5d42c33756341f487357a526e669ca5fbdefd7e49026f12e3979889c&quot;:&quot;5&quot;, &quot;eb802055364096703b351cea60c0392119c487b0ab3a9cd6ed344ee897b6fa1a&quot;:&quot;9&quot;} 2018-07-18 13:42:47.210 CST [main] main -&gt; INFO 003 Exiting..... 并发写入的问题可以参考： HyperLedger High-Throughput Network Hyperledger Fabric and how it isn’t concurrent out of the box. How hyperledger handle the Concurrent of “invoke” of the same Key-Value pair of chaincode? 合约链式调用 就是通过当前合约，调用另一个合约。 demo合约中提供了一个call方法，可以很方便的测试合约链式调用： [&quot;call&quot;,&quot;chaincode&quot;,&quot;method&quot;...] 通过demo合约调用另一个合约 例如再部署一个叫做mycc2的合约，也使用demo的源代码，部署的合约名不同。 通过mycc调用mycc2的query： 在mycc2中查询不到通过mycc写入的数据 $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:53:15.680 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:53:15.680 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:53:15.774 CST [main] main -&gt; INFO 003 Exiting..... 直接调用mycc2也是一样查不到 $ ./peer.sh chaincode query -C mychannel -n mycc2 -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:55:23.315 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:55:23.315 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:55:23.327 CST [main] main -&gt; INFO 003 Exiting..... 在mycc中可以查到 $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:53:31.077 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:53:31.077 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 10 2018-07-18 13:53:31.082 CST [main] main -&gt; INFO 003 Exiting..... 如果用query方式调用另一个合约的invoke是无效的： 在mycc2中写入key $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;write&quot;,&quot;key-single&quot;,&quot;inmycc2&quot;]}&#39; 2018-07-18 13:59:25.610 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:25.610 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:59:25.615 CST [main] main -&gt; INFO 003 Exiting..... 无效，查询不到key $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:59:15.796 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:15.796 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:59:15.802 CST [main] main -&gt; INFO 003 Exiting..... 如果用invoke方式调用另一个合约的invoke是有效的： $ ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;write&quot;,&quot;key-single&quot;,&quot;inmycc2&quot;]}&#39; 2018-07-18 13:59:48.432 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:48.432 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc 2018-07-18 13:59:48.439 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200 2018-07-18 13:59:48.440 CST [main] main -&gt; INFO 004 Exiting..... 可以查询到 $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:59:55.470 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:55.470 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: inmycc2 2018-07-18 13:59:55.476 CST [main] main -&gt; INFO 003 Exiting..... 参考 演示使用的合约代码 example-1: demo 超级账本HyperLedger：Fabric Chaincode（智能合约、链码）开发方法 Hyperledger Fabric and how it isn’t concurrent out of the box. How hyperledger handle the Concurrent of “invoke” of the same Key-Value pair of chaincode? HyperLedger High-Throughput Network 限时活动，每邀请一人即返回25元！ 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/07/20/f0de579686e963280186ed7c941e31b3.html" />
<meta property="og:url" content="https://mlh.app/2018/07/20/f0de579686e963280186ed7c941e31b3.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"作者:&nbsp;李佶澳&nbsp;&nbsp;&nbsp;转载请保留：原文地址&nbsp;&nbsp;&nbsp;发布时间：2018/07/17 10:20:00 说明 Example-1：demo 合约安装&amp;单合约调用 获取合约代码 安装合约&amp;初始化 合约直接调用 并发或快速修改数据时需要注意的问题 合约链式调用 参考 说明 这是网易云课堂“IT技术快速入门学院”使用的素材。 这里演示合约的用法，合约代码托管在在Github上：合约代码。 怎样写合约参考： 超级账本HyperLedger：Fabric Chaincode（智能合约、链码）开发方法 Example-1：demo example-1: demo中演示了最基本、最常用的方法，可以通过这个合约进行下面操作： func (t *Chaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response { function, args := stub.GetFunctionAndParameters() switch function { //返回调用者信息 case &quot;creator&quot;: return t.creator(stub, args) //调用改合约中的其它方法，用来演示复杂的调用 case &quot;call&quot;: return t.call(stub, args) //直接对key的内容进行append，用来演示这样操作的结果 case &quot;append&quot;: return t.append(stub, args) //读取当前用户的属性值 case &quot;attr&quot;: return t.attr(stub, args) //查询一个key的当前值 case &quot;query&quot;: if len(args) != 1 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.query(stub, args[0]) //查询一个key的所有历史值 case &quot;history&quot;: if len(args) != 1 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.history(stub, args[0]) //创建一个key，并写入key的值 case &quot;write&quot;: //写入 if len(args) != 2 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.write(stub, args[0], args[1]) //通过当前合约，到另一个合约中进行查询 case &quot;query_chaincode&quot;: if len(args) != 2 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.query_chaincode(stub, args[0], args[1]) //通过当前合约，到另一个合约中进行写入 case &quot;write_chaincode&quot;: if len(args) != 3 { return shim.Error(&quot;parametes&#39;s number is wrong&quot;) } return t.write_chaincode(stub, args[0], args[1], args[2]) default: return shim.Error(&quot;Invalid invoke function name.&quot;) } } 完整代码： 合约代码。 合约安装&amp;单合约调用 获取合约代码 可以用下面的方式获取合约源代码： mkdir -p $GOPATH/github.com/introclass cd $GOPATH/github.com/introclass git https://github.com/introclass/hyperledger-fabric-chaincodes.git 或者： go get github.com/introclass/hyperledger-fabric-chaincodes 安装合约&amp;初始化 安装合约： cd /opt/app/fabric/cli/user/member1.example.com/Admin-peer0.member1.example.com ./3_install_chaincode.sh 合约初始化： ./4_instantiate_chaincode.sh 到另一个Peer上再安装一次合约： cd /opt/app/fabric/cli/user/member1.example.com/Admin-peer1.member1.example.com/ ./3_install_chaincode.sh &lt;不需要再次实例化&gt; 合约直接调用 下面的操作可以在任意一个Peer进行。 查看当前调用者，调用creator方法： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;creator&quot;]}&#39; 2018-07-18 12:45:48.083 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:45:48.083 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: peers.member1.example.com�-----BEGIN CERTIFICATE----- MIICIjCCAcmgAwIBAgIRANQT46AE7SALHhoFnvodmiowCgYIKoZIzj0EAwIweTEL MAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG cmFuY2lzY28xHDAaBgNVBAoTE21lbWJlcjEuZXhhbXBsZS5jb20xHzAdBgNVBAMT FmNhLm1lbWJlcjEuZXhhbXBsZS5jb20wHhcNMTgwNzE1MDcwMzIzWhcNMjgwNzEy MDcwMzIzWjBeMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQG A1UEBxMNU2FuIEZyYW5jaXNjbzEiMCAGA1UEAwwZQWRtaW5AbWVtYmVyMS5leGFt cGxlLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDMq5zAdcQgGWklQMdTf irdHhbTBsLALJ0hjKFfaLIRyKO7Bq39HFrxPybLc/d4PXDXXrQsS9HCnKj9PSO6u DBSjTTBLMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1UdIwQkMCKA IIPK7RfYFuMcuUQahKin2FxuaskfZl3WWtCMmEhN06lMMAoGCCqGSM49BAMCA0cA MEQCIBnA0dhz/AnvsjNoWEuNBWIxRgKpG9CHbScrbQ7U9WK+AiAaZ4Qi7OZd8zev ZZUxizW00+GqDXJWJ9VX6edtKDNVFw== -----END CERTIFICATE----- 2018-07-18 12:45:48.087 CST [main] main -&gt; INFO 003 Exiting..... 写入Key: $ ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key&quot;,&quot;keyvalue&quot;]}&#39; 2018-07-18 12:48:30.728 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:48:30.728 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc 2018-07-18 12:48:30.775 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200 2018-07-18 12:48:30.775 CST [main] main -&gt; INFO 004 Exiting..... 查询刚写入的key: $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key&quot;]}&#39; 2018-07-18 12:49:14.464 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:49:14.464 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: keyvalue &lt;-- 查询的结果 2018-07-18 12:49:14.468 CST [main] main -&gt; INFO 003 Exiting..... 更改key的值: $ ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;write&quot;,&quot;key&quot;,&quot;keyvalue1&quot;]}&#39; 2018-07-18 12:50:44.023 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:50:44.023 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc 2018-07-18 12:50:44.027 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200 2018-07-18 12:50:44.028 CST [main] main -&gt; INFO 004 Exiting..... 查询key的历史数据： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key&quot;]}&#39; 2018-07-18 12:52:25.332 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 12:52:25.332 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: {&quot;93ea6b185bb886c70f66b8b0dc8f5c727043269e2b7b7e76ae36644cd8ef3916&quot;:&quot;keyvalue&quot;,&quot;f87a0f6f972226a57ade04a8e54db1a014d12cbab40abcbd8a5d65fe10bdfeff&quot;:&quot;keyvalue1&quot;} &lt;可以看到历史值有两个&gt; 2018-07-18 12:52:25.340 CST [main] main -&gt; INFO 003 Exiting..... 并发或快速修改数据时需要注意的问题 合约中的append方法的用是，读取一个key的value，然后在读取出来的数值上修改，最后重新写入账本。 需要特别注意，这种做法是有问题的，例如下面脚本预期的最终结果是[“1”,”2”,”3”,”4”,”5”,”6”,”7”,”8”,”9”,”10”]： for i in {1..10} do echo $i sleep 1 ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &quot;{\\&quot;Args\\&quot;:[\\&quot;append\\&quot;,\\&quot;key-array\\&quot;,\\&quot;$i\\&quot;]}&quot; done 但执行结束后，得到的结果却是： ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-array&quot;]}&#39; 2018-07-18 13:28:35.996 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:28:35.997 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;,&quot;9&quot;] 2018-07-18 13:28:36.001 CST [main] main -&gt; INFO 003 Exiting..... 查看历史价值，发现也有很多缺失的数据： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key-array&quot;]}&#39; 2018-07-18 13:28:44.773 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:28:44.773 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: { &quot;2bace9ac4812416969f623a471e902ecb6198bc9d16c1ca1e7e9586adf6cd428&quot;:&quot;[\\&quot;1\\&quot;,\\&quot;3\\&quot;,\\&quot;5\\&quot;,\\&quot;7\\&quot;,\\&quot;9\\&quot;]&quot;, &quot;6832ef710f74a39bc08e3386d0eb8aa757cb53ccd7fe149b042417b5cc436750&quot;:&quot;[\\&quot;1\\&quot;,\\&quot;3\\&quot;,\\&quot;5\\&quot;]&quot;, &quot;8c041cd53f045999dc41ca1facb8dbce8acb4a07ff5dd558a53f8f2908789b3d&quot;:&quot;[\\&quot;1\\&quot;]&quot;, &quot;d1b68113730f0bb8adb9a19c64594e64729b4a1c1aa81a412edd6b1b1ad84e06&quot;:&quot;[\\&quot;1\\&quot;,\\&quot;3\\&quot;]&quot;, &quot;d5fe258cc64d5f10f63b8a9f3c1d321d966f4d5c45b17b5b8c31eccad231e3fd&quot;:&quot;[\\&quot;1\\&quot;,\\&quot;3\\&quot;,\\&quot;5\\&quot;,\\&quot;7\\&quot;]&quot;} 2018-07-18 13:28:44.777 CST [main] main -&gt; INFO 003 Exiting..... 出现这种结果的原因是，其中一些append操作是基于“旧”的数据的：之前的append操作依旧修改了数据，但是当前的append还不能查询到最新的数据。 这些append操作不会被接受。 如果只“修改”数据，则会是另一种结果： for i in {1..10} do ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &quot;{\\&quot;Args\\&quot;:[\\&quot;write\\&quot;,\\&quot;key-single\\&quot;,\\&quot;$i\\&quot;]}&quot; done 执行以后查询当前值，为10： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:41:45.257 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:41:45.257 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 10 2018-07-18 13:41:45.261 CST [main] main -&gt; INFO 003 Exiting..... 但可以在历史数据中找到所有的值： $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;history&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:42:47.206 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:42:47.206 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: { &quot;0b6e46b6397ad2e76b2de842f162d558ce88b2409656d16a30b9f53f6a038357&quot;:&quot;6&quot;, &quot;1015deb1cdfd3e08a5da2fd03ddeb0e1df69287d88c017f7d55678405fbac774&quot;:&quot;8&quot;, &quot;5291a41b310b31b14b5b96c981dc9a6923ed4c956b52ee4e662fc65167531435&quot;:&quot;3&quot;, &quot;691678195fd7fbd7787ff6fb128adff87c34de9c96e62b599320d8c1966a8397&quot;:&quot;7&quot;, &quot;876374f0551eb227351f5312ca494d141cdddae99e7d67ffeffdd0094e5532bb&quot;:&quot;1&quot;, &quot;8b02dae72f1d6f9a4db6e2daa4947be1d5bcdbfa4f4fbb7a69382cc85510732b&quot;:&quot;4&quot;, &quot;b5c89bacda118d0e0a7777aad8083c1920ac90201e3dac0e8df6385038afee5c&quot;:&quot;10&quot;, &quot;de111d7b19b68918502a52d36f49fbd17a18db46a69379d3566f8d0531307871&quot;:&quot;2&quot;, &quot;e2dbb13a5d42c33756341f487357a526e669ca5fbdefd7e49026f12e3979889c&quot;:&quot;5&quot;, &quot;eb802055364096703b351cea60c0392119c487b0ab3a9cd6ed344ee897b6fa1a&quot;:&quot;9&quot;} 2018-07-18 13:42:47.210 CST [main] main -&gt; INFO 003 Exiting..... 并发写入的问题可以参考： HyperLedger High-Throughput Network Hyperledger Fabric and how it isn’t concurrent out of the box. How hyperledger handle the Concurrent of “invoke” of the same Key-Value pair of chaincode? 合约链式调用 就是通过当前合约，调用另一个合约。 demo合约中提供了一个call方法，可以很方便的测试合约链式调用： [&quot;call&quot;,&quot;chaincode&quot;,&quot;method&quot;...] 通过demo合约调用另一个合约 例如再部署一个叫做mycc2的合约，也使用demo的源代码，部署的合约名不同。 通过mycc调用mycc2的query： 在mycc2中查询不到通过mycc写入的数据 $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:53:15.680 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:53:15.680 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:53:15.774 CST [main] main -&gt; INFO 003 Exiting..... 直接调用mycc2也是一样查不到 $ ./peer.sh chaincode query -C mychannel -n mycc2 -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:55:23.315 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:55:23.315 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:55:23.327 CST [main] main -&gt; INFO 003 Exiting..... 在mycc中可以查到 $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:53:31.077 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:53:31.077 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 10 2018-07-18 13:53:31.082 CST [main] main -&gt; INFO 003 Exiting..... 如果用query方式调用另一个合约的invoke是无效的： 在mycc2中写入key $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;write&quot;,&quot;key-single&quot;,&quot;inmycc2&quot;]}&#39; 2018-07-18 13:59:25.610 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:25.610 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:59:25.615 CST [main] main -&gt; INFO 003 Exiting..... 无效，查询不到key $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:59:15.796 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:15.796 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: 2018-07-18 13:59:15.802 CST [main] main -&gt; INFO 003 Exiting..... 如果用invoke方式调用另一个合约的invoke是有效的： $ ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;write&quot;,&quot;key-single&quot;,&quot;inmycc2&quot;]}&#39; 2018-07-18 13:59:48.432 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:48.432 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc 2018-07-18 13:59:48.439 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200 2018-07-18 13:59:48.440 CST [main] main -&gt; INFO 004 Exiting..... 可以查询到 $ ./peer.sh chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;call&quot;,&quot;mycc2&quot;,&quot;query&quot;,&quot;key-single&quot;]}&#39; 2018-07-18 13:59:55.470 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc 2018-07-18 13:59:55.470 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc Query Result: inmycc2 2018-07-18 13:59:55.476 CST [main] main -&gt; INFO 003 Exiting..... 参考 演示使用的合约代码 example-1: demo 超级账本HyperLedger：Fabric Chaincode（智能合约、链码）开发方法 Hyperledger Fabric and how it isn’t concurrent out of the box. How hyperledger handle the Concurrent of “invoke” of the same Key-Value pair of chaincode? HyperLedger High-Throughput Network 限时活动，每邀请一人即返回25元！ 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/07/20/f0de579686e963280186ed7c941e31b3.html","headline":"超级账本HyperLedger：Fabric的Chaincode（智能合约、链码）开发、使用演示","dateModified":"2018-07-20T00:00:00+08:00","datePublished":"2018-07-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/07/20/f0de579686e963280186ed7c941e31b3.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>超级账本HyperLedger：Fabric的Chaincode（智能合约、链码）开发、使用演示</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>作者:&nbsp;<a href="http://www.lijiaocn.com/2010/10/10/about.html" rel="nofollow">李佶澳</a>&nbsp;&nbsp;&nbsp;转载请保留：<a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/07/17/hyperledger-fabric-chaincodes-example.html" rel="nofollow">原文地址</a>&nbsp;&nbsp;&nbsp;发布时间：2018/07/17 10:20:00</p> 
  <ul id="markdown-toc">
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/07/17/hyperledger-fabric-chaincodes-example.html#%E8%AF%B4%E6%98%8E" rel="nofollow" id="markdown-toc-说明">说明</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/07/17/hyperledger-fabric-chaincodes-example.html#example-1demo" rel="nofollow" id="markdown-toc-example-1demo">Example-1：demo</a> 
    <ul>
     <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/07/17/hyperledger-fabric-chaincodes-example.html#%E5%90%88%E7%BA%A6%E5%AE%89%E8%A3%85%E5%8D%95%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8" rel="nofollow" id="markdown-toc-合约安装单合约调用">合约安装&amp;单合约调用</a> 
      <ul>
       <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/07/17/hyperledger-fabric-chaincodes-example.html#%E8%8E%B7%E5%8F%96%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81" rel="nofollow" id="markdown-toc-获取合约代码">获取合约代码</a></li> 
       <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/07/17/hyperledger-fabric-chaincodes-example.html#%E5%AE%89%E8%A3%85%E5%90%88%E7%BA%A6%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow" id="markdown-toc-安装合约初始化">安装合约&amp;初始化</a></li> 
       <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/07/17/hyperledger-fabric-chaincodes-example.html#%E5%90%88%E7%BA%A6%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8" rel="nofollow" id="markdown-toc-合约直接调用">合约直接调用</a></li> 
      </ul></li> 
     <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/07/17/hyperledger-fabric-chaincodes-example.html#%E5%B9%B6%E5%8F%91%E6%88%96%E5%BF%AB%E9%80%9F%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow" id="markdown-toc-并发或快速修改数据时需要注意的问题">并发或快速修改数据时需要注意的问题</a></li> 
     <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/07/17/hyperledger-fabric-chaincodes-example.html#%E5%90%88%E7%BA%A6%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8" rel="nofollow" id="markdown-toc-合约链式调用">合约链式调用</a></li> 
    </ul></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/07/17/hyperledger-fabric-chaincodes-example.html#%E5%8F%82%E8%80%83" rel="nofollow" id="markdown-toc-参考">参考</a></li> 
  </ul>
  <h2 id="说明">说明</h2> 
  <p>这是网易云课堂“<a href="https://study.163.com/provider/400000000376006/course.htm?share=2&amp;shareId=400000000376006" rel="nofollow">IT技术快速入门学院</a>”使用的素材。</p> 
  <p>这里演示合约的用法，合约代码托管在在Github上：<a href="https://github.com/introclass/hyperledger-fabric-chaincodes" rel="nofollow">合约代码</a>。</p> 
  <p>怎样写合约参考： <a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/05/05/hyperledger-fabric-chaincode.html" rel="nofollow">超级账本HyperLedger：Fabric Chaincode（智能合约、链码）开发方法</a></p> 
  <h2 id="example-1demo">Example-1：demo</h2> 
  <p><a href="https://github.com/introclass/hyperledger-fabric-chaincodes/tree/master/demo" rel="nofollow">example-1: demo</a>中演示了最基本、最常用的方法，可以通过这个合约进行下面操作：</p> 
  <pre class="has">
<code>func (t *Chaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
    function, args := stub.GetFunctionAndParameters()
    switch function {
    //返回调用者信息
    case "creator":
        return t.creator(stub, args)
    //调用改合约中的其它方法，用来演示复杂的调用
    case "call":
        return t.call(stub, args)
    //直接对key的内容进行append，用来演示这样操作的结果
    case "append":
        return t.append(stub, args)
    //读取当前用户的属性值
    case "attr":
        return t.attr(stub, args)
    //查询一个key的当前值
    case "query":
        if len(args) != 1 {
            return shim.Error("parametes's number is wrong")
        }
        return t.query(stub, args[0])
    //查询一个key的所有历史值
    case "history":
        if len(args) != 1 {
            return shim.Error("parametes's number is wrong")
        }
        return t.history(stub, args[0])
    //创建一个key，并写入key的值
    case "write": //写入
        if len(args) != 2 {
            return shim.Error("parametes's number is wrong")
        }
        return t.write(stub, args[0], args[1])
    //通过当前合约，到另一个合约中进行查询
    case "query_chaincode":
        if len(args) != 2 {
            return shim.Error("parametes's number is wrong")
        }
        return t.query_chaincode(stub, args[0], args[1])
    //通过当前合约，到另一个合约中进行写入
    case "write_chaincode":
        if len(args) != 3 {
            return shim.Error("parametes's number is wrong")
        }
        return t.write_chaincode(stub, args[0], args[1], args[2])
    default:
        return shim.Error("Invalid invoke function name.")
    }
}
</code></pre> 
  <p>完整代码： <a href="https://github.com/introclass/hyperledger-fabric-chaincodes" rel="nofollow">合约代码</a>。</p> 
  <h3 id="合约安装单合约调用">合约安装&amp;单合约调用</h3> 
  <p>获取合约代码</p> 
  <p>可以用下面的方式获取合约源代码：</p> 
  <pre class="has">
<code>mkdir -p $GOPATH/github.com/introclass
cd $GOPATH/github.com/introclass
git https://github.com/introclass/hyperledger-fabric-chaincodes.git
</code></pre> 
  <p>或者：</p> 
  <pre class="has">
<code>go get github.com/introclass/hyperledger-fabric-chaincodes
</code></pre> 
  <p>安装合约&amp;初始化</p> 
  <p>安装合约：</p> 
  <pre class="has">
<code>cd /opt/app/fabric/cli/user/member1.example.com/Admin-peer0.member1.example.com
 ./3_install_chaincode.sh
</code></pre> 
  <p>合约初始化：</p> 
  <pre class="has">
<code>./4_instantiate_chaincode.sh
</code></pre> 
  <p>到另一个Peer上再安装一次合约：</p> 
  <pre class="has">
<code>cd /opt/app/fabric/cli/user/member1.example.com/Admin-peer1.member1.example.com/
./3_install_chaincode.sh
&lt;不需要再次实例化&gt;
</code></pre> 
  <p>合约直接调用</p> 
  <p>下面的操作可以在任意一个Peer进行。</p> 
  <p>查看当前调用者，调用creator方法：</p> 
  <pre class="has">
<code>$ ./peer.sh chaincode query -C mychannel -n mycc -c  '{"Args":["creator"]}'
2018-07-18 12:45:48.083 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 12:45:48.083 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result:
peers.member1.example.com�-----BEGIN CERTIFICATE-----
MIICIjCCAcmgAwIBAgIRANQT46AE7SALHhoFnvodmiowCgYIKoZIzj0EAwIweTEL
MAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG
cmFuY2lzY28xHDAaBgNVBAoTE21lbWJlcjEuZXhhbXBsZS5jb20xHzAdBgNVBAMT
FmNhLm1lbWJlcjEuZXhhbXBsZS5jb20wHhcNMTgwNzE1MDcwMzIzWhcNMjgwNzEy
MDcwMzIzWjBeMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQG
A1UEBxMNU2FuIEZyYW5jaXNjbzEiMCAGA1UEAwwZQWRtaW5AbWVtYmVyMS5leGFt
cGxlLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDMq5zAdcQgGWklQMdTf
irdHhbTBsLALJ0hjKFfaLIRyKO7Bq39HFrxPybLc/d4PXDXXrQsS9HCnKj9PSO6u
DBSjTTBLMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1UdIwQkMCKA
IIPK7RfYFuMcuUQahKin2FxuaskfZl3WWtCMmEhN06lMMAoGCCqGSM49BAMCA0cA
MEQCIBnA0dhz/AnvsjNoWEuNBWIxRgKpG9CHbScrbQ7U9WK+AiAaZ4Qi7OZd8zev
ZZUxizW00+GqDXJWJ9VX6edtKDNVFw==
-----END CERTIFICATE-----

2018-07-18 12:45:48.087 CST [main] main -&gt; INFO 003 Exiting.....
</code></pre> 
  <p>写入Key:</p> 
  <pre class="has">
<code>$ ./peer.sh  chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c '{"Args":["write","key","keyvalue"]}'
2018-07-18 12:48:30.728 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 12:48:30.728 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
2018-07-18 12:48:30.775 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200
2018-07-18 12:48:30.775 CST [main] main -&gt; INFO 004 Exiting.....
</code></pre> 
  <p>查询刚写入的key:</p> 
  <pre class="has">
<code>$ ./peer.sh chaincode query -C mychannel -n mycc -c '{"Args":["query","key"]}'
2018-07-18 12:49:14.464 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 12:49:14.464 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result: keyvalue    &lt;-- 查询的结果
2018-07-18 12:49:14.468 CST [main] main -&gt; INFO 003 Exiting.....
</code></pre> 
  <p>更改key的值:</p> 
  <pre class="has">
<code>$ ./peer.sh  chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c '{"Args":["write","key","keyvalue1"]}'
2018-07-18 12:50:44.023 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 12:50:44.023 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
2018-07-18 12:50:44.027 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200
2018-07-18 12:50:44.028 CST [main] main -&gt; INFO 004 Exiting.....
</code></pre> 
  <p>查询key的历史数据：</p> 
  <pre class="has">
<code>$ ./peer.sh chaincode query -C mychannel -n mycc -c '{"Args":["history","key"]}'
2018-07-18 12:52:25.332 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 12:52:25.332 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result: {"93ea6b185bb886c70f66b8b0dc8f5c727043269e2b7b7e76ae36644cd8ef3916":"keyvalue","f87a0f6f972226a57ade04a8e54db1a014d12cbab40abcbd8a5d65fe10bdfeff":"keyvalue1"}
&lt;可以看到历史值有两个&gt;
2018-07-18 12:52:25.340 CST [main] main -&gt; INFO 003 Exiting.....
</code></pre> 
  <h3 id="并发或快速修改数据时需要注意的问题">并发或快速修改数据时需要注意的问题</h3> 
  <p>合约中的append方法的用是，读取一个key的value，然后在读取出来的数值上修改，最后重新写入账本。</p> 
  <p>需要特别注意，这种做法是有问题的，例如下面脚本预期的最终结果是[“1”,”2”,”3”,”4”,”5”,”6”,”7”,”8”,”9”,”10”]：</p> 
  <pre class="has">
<code>for i in {1..10}
do
    echo $i
    sleep 1
    ./peer.sh chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c "{\"Args\":[\"append\",\"key-array\",\"$i\"]}"
done
</code></pre> 
  <p>但执行结束后，得到的结果却是：</p> 
  <pre class="has">
<code>./peer.sh chaincode query -C mychannel -n mycc -c '{"Args":["query","key-array"]}'
2018-07-18 13:28:35.996 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 13:28:35.997 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result: ["1","3","5","7","9"]
2018-07-18 13:28:36.001 CST [main] main -&gt; INFO 003 Exiting.....
</code></pre> 
  <p>查看历史价值，发现也有很多缺失的数据：</p> 
  <pre class="has">
<code>$ ./peer.sh chaincode query -C mychannel -n mycc -c '{"Args":["history","key-array"]}'
2018-07-18 13:28:44.773 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 13:28:44.773 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result: {
	"2bace9ac4812416969f623a471e902ecb6198bc9d16c1ca1e7e9586adf6cd428":"[\"1\",\"3\",\"5\",\"7\",\"9\"]",
	"6832ef710f74a39bc08e3386d0eb8aa757cb53ccd7fe149b042417b5cc436750":"[\"1\",\"3\",\"5\"]",
	"8c041cd53f045999dc41ca1facb8dbce8acb4a07ff5dd558a53f8f2908789b3d":"[\"1\"]",
	"d1b68113730f0bb8adb9a19c64594e64729b4a1c1aa81a412edd6b1b1ad84e06":"[\"1\",\"3\"]",
	"d5fe258cc64d5f10f63b8a9f3c1d321d966f4d5c45b17b5b8c31eccad231e3fd":"[\"1\",\"3\",\"5\",\"7\"]"}
2018-07-18 13:28:44.777 CST [main] main -&gt; INFO 003 Exiting.....
</code></pre> 
  <p>出现这种结果的原因是，其中一些append操作是基于“旧”的数据的：之前的append操作依旧修改了数据，但是当前的append还不能查询到最新的数据。</p> 
  <p>这些append操作不会被接受。</p> 
  <p>如果只“修改”数据，则会是另一种结果：</p> 
  <pre class="has">
<code>for i in {1..10}
do
    ./peer.sh  chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c "{\"Args\":[\"write\",\"key-single\",\"$i\"]}"
done
</code></pre> 
  <p>执行以后查询当前值，为10：</p> 
  <pre class="has">
<code>$ ./peer.sh chaincode query -C mychannel -n mycc -c '{"Args":["query","key-single"]}'
2018-07-18 13:41:45.257 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 13:41:45.257 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result: 10
2018-07-18 13:41:45.261 CST [main] main -&gt; INFO 003 Exiting.....
</code></pre> 
  <p>但可以在历史数据中找到所有的值：</p> 
  <pre class="has">
<code>$ ./peer.sh chaincode query -C mychannel -n mycc -c '{"Args":["history","key-single"]}'
2018-07-18 13:42:47.206 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 13:42:47.206 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result: {
	"0b6e46b6397ad2e76b2de842f162d558ce88b2409656d16a30b9f53f6a038357":"6",
	"1015deb1cdfd3e08a5da2fd03ddeb0e1df69287d88c017f7d55678405fbac774":"8",
	"5291a41b310b31b14b5b96c981dc9a6923ed4c956b52ee4e662fc65167531435":"3",
	"691678195fd7fbd7787ff6fb128adff87c34de9c96e62b599320d8c1966a8397":"7",
	"876374f0551eb227351f5312ca494d141cdddae99e7d67ffeffdd0094e5532bb":"1",
	"8b02dae72f1d6f9a4db6e2daa4947be1d5bcdbfa4f4fbb7a69382cc85510732b":"4",
	"b5c89bacda118d0e0a7777aad8083c1920ac90201e3dac0e8df6385038afee5c":"10",
	"de111d7b19b68918502a52d36f49fbd17a18db46a69379d3566f8d0531307871":"2",
	"e2dbb13a5d42c33756341f487357a526e669ca5fbdefd7e49026f12e3979889c":"5",
	"eb802055364096703b351cea60c0392119c487b0ab3a9cd6ed344ee897b6fa1a":"9"}
2018-07-18 13:42:47.210 CST [main] main -&gt; INFO 003 Exiting.....
</code></pre> 
  <p>并发写入的问题可以参考：</p> 
  <p><a href="https://github.com/hyperledger/fabric-samples/tree/release-1.2/high-throughput" rel="nofollow">HyperLedger High-Throughput Network</a></p> 
  <p><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/05/05/hyperledger-fabric-chaincode.html" rel="nofollow">Hyperledger Fabric and how it isn’t concurrent out of the box.</a></p> 
  <p><a href="https://medium.com/wearetheledger/hyperledger-fabric-concurrency-really-eccd901e4040" rel="nofollow">How hyperledger handle the Concurrent of “invoke” of the same Key-Value pair of chaincode?</a></p> 
  <h3 id="合约链式调用">合约链式调用</h3> 
  <p>就是通过当前合约，调用另一个合约。</p> 
  <p>demo合约中提供了一个call方法，可以很方便的测试合约链式调用：</p> 
  <pre class="has">
<code>["call","chaincode","method"...]   通过demo合约调用另一个合约
</code></pre> 
  <p>例如再部署一个叫做mycc2的合约，也使用demo的源代码，部署的合约名不同。</p> 
  <p>通过mycc调用mycc2的query：</p> 
  <pre class="has">
<code>在mycc2中查询不到通过mycc写入的数据
$ ./peer.sh chaincode query -C mychannel -n mycc -c '{"Args":["call","mycc2","query","key-single"]}'
2018-07-18 13:53:15.680 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 13:53:15.680 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result:
2018-07-18 13:53:15.774 CST [main] main -&gt; INFO 003 Exiting.....

直接调用mycc2也是一样查不到
$ ./peer.sh chaincode query -C mychannel -n mycc2 -c '{"Args":["query","key-single"]}'
2018-07-18 13:55:23.315 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 13:55:23.315 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result:
2018-07-18 13:55:23.327 CST [main] main -&gt; INFO 003 Exiting.....

在mycc中可以查到
$ ./peer.sh chaincode query -C mychannel -n mycc -c '{"Args":["query","key-single"]}'
2018-07-18 13:53:31.077 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 13:53:31.077 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result: 10
2018-07-18 13:53:31.082 CST [main] main -&gt; INFO 003 Exiting.....
</code></pre> 
  <p>如果用query方式调用另一个合约的invoke是无效的：</p> 
  <pre class="has">
<code>在mycc2中写入key
$ ./peer.sh chaincode query -C mychannel -n mycc -c '{"Args":["call","mycc2","write","key-single","inmycc2"]}'
2018-07-18 13:59:25.610 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 13:59:25.610 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result:
2018-07-18 13:59:25.615 CST [main] main -&gt; INFO 003 Exiting.....

无效，查询不到key
$ ./peer.sh chaincode query -C mychannel -n mycc -c '{"Args":["call","mycc2","query","key-single"]}'
2018-07-18 13:59:15.796 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 13:59:15.796 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result:
2018-07-18 13:59:15.802 CST [main] main -&gt; INFO 003 Exiting.....
</code></pre> 
  <p>如果用invoke方式调用另一个合约的invoke是有效的：</p> 
  <pre class="has">
<code>$ ./peer.sh  chaincode invoke -o orderer0.member1.example.com:7050 --tls true --cafile tlsca.member1.example.com-cert.pem -C mychannel -n mycc -c '{"Args":["call","mycc2","write","key-single","inmycc2"]}'
2018-07-18 13:59:48.432 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 13:59:48.432 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
2018-07-18 13:59:48.439 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 003 Chaincode invoke successful. result: status:200
2018-07-18 13:59:48.440 CST [main] main -&gt; INFO 004 Exiting.....

可以查询到
$ ./peer.sh chaincode query -C mychannel -n mycc -c '{"Args":["call","mycc2","query","key-single"]}'
2018-07-18 13:59:55.470 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc
2018-07-18 13:59:55.470 CST [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc
Query Result: inmycc2
2018-07-18 13:59:55.476 CST [main] main -&gt; INFO 003 Exiting.....
</code></pre> 
  <h2 id="参考">参考</h2> 
  <ol>
   <li><a href="https://github.com/introclass/hyperledger-fabric-chaincodes" rel="nofollow">演示使用的合约代码</a></li> 
   <li><a href="https://github.com/introclass/hyperledger-fabric-chaincodes/tree/master/demo" rel="nofollow">example-1: demo</a></li> 
   <li><a href="http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/05/05/hyperledger-fabric-chaincode.html" rel="nofollow">超级账本HyperLedger：Fabric Chaincode（智能合约、链码）开发方法</a></li> 
   <li><a href="https://medium.com/wearetheledger/hyperledger-fabric-concurrency-really-eccd901e4040" rel="nofollow">Hyperledger Fabric and how it isn’t concurrent out of the box.</a></li> 
   <li><a href="https://stackoverflow.com/questions/37691994/how-hyperledger-handle-the-concurrent-of-invoke-of-the-same-key-value-pair-of?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" rel="nofollow">How hyperledger handle the Concurrent of “invoke” of the same Key-Value pair of chaincode?</a></li> 
   <li><a href="https://github.com/hyperledger/fabric-samples/tree/release-1.2/high-throughput" rel="nofollow">HyperLedger High-Throughput Network</a></li> 
  </ol>
  <h3>限时活动，每邀请一人即返回25元！</h3> 
  <h3><img alt="" class="has" src="http://www.lijiaocn.com/img/hyperledger-class/fabric-class-all.jpeg"></h3> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lijiaocn/article/details/81128663,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lijiaocn/article/details/81128663,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
