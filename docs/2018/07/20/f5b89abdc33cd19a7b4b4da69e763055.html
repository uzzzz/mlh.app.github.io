<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链概论（开发者入门篇 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链概论（开发者入门篇" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="有关区块链的文章很多，但是我总感觉每一篇读完之后理解的都不透彻。趁着刚学习完一些理论知识，来自己整理篇终极入门。 （可以收藏但不支持转载） &nbsp; 区块链的监管 区块链并不是一个新技术，而是一堆已有技术的结合，包括分布式技术、密码学等等。比特币诞生与2009年，区块链作为其后端支撑，在2015年才掀起浪潮，大家逐渐发现区块链的应用领域远远不止代币（代币这个词很好理解，作为钱币的替代品，在特定的场合或者范围内才有效。比如比特币莱特币以太币等等等等。) 我国对于代币的监管较严格，中国人民银行宣布，发行初始代币(ICOs)是一种非法的融资手段。但同时，我国支持区块链技术的发展，并在16年12月其归为互联网金融的一项技术（参考《北京市“十三五”时期金融业发展规划》），在之前的8月，北京市金融工作局已经在推动中关村区块链联盟设立。 截止2018.5，北京、上海、广州、深圳、浙江、贵州等地在内的十八个地区出台了相关区块链项目鼓励政策。各地区将区块链研发及应用作为重要战略发展目标，并出台详细鼓励政策。所以抛开代币这个概念，区块链的未来还是值得期待的。 最近由于参加项目，收集了一些区块链在各领域在2018-2023年市场价值的预测数据，做了个柱状图。 但是这个数据吧，我认为看看就好并不能当真 = =，毕竟现在区块链的底层技术还不成熟，发展空间较大。由于供应链金融这块很贴紧区块链的运作方式，所以目前也在大力发展。 感觉说了一堆没用的。其实是想大家先了解下这个领域，包括他的制度。 &nbsp; 区块链概述 Melanie Swan在《区块链：新经济蓝图及导读》中将区块链应用分为区块链1.0、2.0和3.0 区块链1.0：比特币，支撑虚拟货币应用，转账、汇款和数字化支付相关的密码学货币应用。 区块链2.0：支撑智能合约应用合约是经济、市场和金融的区块链应用的基石。应用包括股票、债券、期货、贷款、抵押、产权、智能财产和智能合约。2.0的代表是以太坊，以智能合约为中心，用户可以自己编辑智能合约（这当然存在一定的风险，比如TheDAO事件，黑客就是从智能合约中的漏洞入手。） 区块链3.0：应用是超越货币、金融和市场的范围的去中心化应用，特别是政府、健康、科学、文艺和艺术领域。3.0的代表是EOS(so called 3.0)，但是平台好像不是很稳定，速度并没有他对外宣称的那么快。其实3.0可能还在发展中。 &nbsp; 比特币分类： 1. 公有链(Public blockchain)：对所有人开放，任何人都可以参与。 &nbsp; &nbsp; 应用包括：比特币、以太坊、虚拟货币、面向大众的电子商务、互联网金融等B2C\C2C\C2B等场景 2.&nbsp;私有链(Private blockchain)：对单独的个人或实体开放 &nbsp; &nbsp; 应用包括：数据库管理、审计，防范内部和外部的对数据安全的攻击，是许可链 3.&nbsp;联盟链(Consortium blockchain)：对特定的组织团体开放 &nbsp; &nbsp; 应用包括：40多家银行参与的区块链联盟R3，和Linux基金会支持的超级账本Hyperledger，需要注册许可，许可链 &nbsp;&nbsp;&nbsp;&nbsp;用于机构间交易、结算或清算等B2B形式 4. 侧链(sidechains)：比特币平均每十分钟出一个区块，每个区块1MB大小，使得大概每秒才能确认7笔交易。侧链来提升效率。&nbsp; &nbsp; &nbsp; 闪电网络把很多交易放在侧链，只有在做清算时才用上主链，大大提高交易速率，又不会增加主链的存储负担。 5. 互联链(interchain)：各自垂直领域的区块链互联互通，形成区块链全球网络。 &nbsp; 区块链行业架构：协议层、扩展层、应用层。 协议层 底层技术，完整的区块链产品，维护网络节点，提供API调用。通常提供简单的客户端。 构建了网络环境，搭建了交易通道，指定了节点奖励规则， 技术：网络编程、分布式算法、加密签名、数据存储技术。 语言：网络编程能力强的，对并发处理简单的。比如Nodejs, Go &nbsp; 进一步分为存储层和网络层。 比特币选择的是谷歌的LevelDB，读写性能好。 网络层是编码的重点和难点，包括点对点网络中的分布式算法、加密签名。《Nodejs开发加密货币》 也有将点对点网络的实现单独分开： 节点查找、数据传输和验证等逻辑独立 共识算法、加密签名、数据存储等组成核心层 &nbsp; 扩展层 类似电脑驱动，让区块链产品更加实用。 有两类，一是各类交易市场，法币兑换加密货币。 二是针对某个方向的扩展实现，例如智能合约，即达到某个条件，合约自动执行，比如证券转移。 技术没有限制，分布式存储、机器学习、VR、物联网、大数据等等。 任何需要第三方支付的产品都可以方便的使用区块链 任何需要确权、征信和追溯的信息，也可以借助区块链。 &nbsp; 应用层 各种客户端（DAPP、钱包等）。 &nbsp; 比特币协议层使用C++开发、官方客户端钱包用Qt、第三方钱包用Python，共识算法采用PoW(Proof of work)工作量证明机制。 以太坊给出了Go(go-ethereum)\Java(Ethereum(J))\Python等多语言的实现。客户端有Rust, Ruby, Javascript等。 &nbsp; 大家对区块链的定义都是分布式的公开数据库，或者叫他账本。所以功能明显：存储。存储的是什么？不可篡改的交易。 一段时间内产生的交易被打包进一个区块中，这个区块被挖出来之后（称为挖矿），连接到最长的链条上（区块数量最多），就构成了区块链。 我们根据比特币区块链来理解区块链的工作方式。 &nbsp; 比特币地址 首先我们来看一下比特币地址。作为交易的用户，我们首先每个人要有个地址，这样我才能给你转账。 比特币地址由数字和字母组成。生成过程如下： 公私钥若是有问题参考密码学。 非对称加密：每个人有两把钥匙，其中一把只有自己知道（私钥），另一把可以公布于众（公钥）；通过私钥加密过的信息，只要公钥才能解密，连私钥都不能，公钥可以通过私钥生成很多把。 用户随机生成私钥，然后通过私钥产生公钥，对公钥进行SHA256加密函数加密，再使用RIPEMD160加密，得到了公钥HASH。再经过两次SHA256加密，取前四字节作为校验码加入到原公钥HASH中，再添加相应的版本号（目前为0x00），将这些字节合并后通过Base58，生成58字节的比特币地址。 &nbsp; 交易 对于每个账户，比特币存储的不是其余额（还剩多少比特币），而是交易记录。比如A转给我1个比特币，B转给我2两个比特币，存储的是这些账单。而比特币的创新在于UTXO（Unspent Transaction Output，未花费的交易输出）。也就是说，我要发起一笔交易，转账给C两个比特币，这时交易的输入则是部分UTXO。我有一些别人转账给我的账单，来自A的1个和B的两个，那么我转给C的这个交易，使用的就可能是B转给我的这笔钱。 我们来看看交易的输入与输出： previous tx的值是即是一笔UTXO的哈希，在例子中则是选择C转给我的2个比特币，将这些钱给C。作为输入的交易可以是多个。（比如我想转D3个比特币。A与B的交易单个肯定不够） 输入脚本：也就是scriptSig是转账人私钥生成的数字签名，即需要转账人证明自己有与公钥哈希对应的私钥，这样他才可以使用这笔UTXO。scriptSig下一行是转账人的公钥。 Value就是转账的金额。 scriptPubKey：是输出脚本，其中包含了若干脚本命令，以及收款方的地址。 &nbsp; 现在我们来看脚本的执行过程。 比特币的脚本基于堆栈，后进先出。 交易1 ：A转账给B 输入：A的签名&amp;公钥 输出：B的公钥HASH 交易2：B转账给C 输入：B的签名&amp;公钥 输出：C的公钥HASH 先执行交易2的输入脚本，从左向右，将签名与公钥入栈；然后执行交易1的输出脚本OP_DUP——复制栈顶元素。 然后OP_HASH160计算栈顶元素的HASH，也就是A的公钥HASH，即A的比特币地址。然后将交易1的输出中的地址（A的地址）压栈。 接下来OP_EQUALVERIFY判断栈顶前两个元素是否相等。如果相等继续执行，如果不相等中断。最后使用OP_CHECKSIG来进行签名校验，即公私钥匹配。 一串指令证明了想要花费该UTXO中比特币的人，是否有对应的私钥，也就是这笔转账是否是转给A的，或者是A是否有权限可以花。 &nbsp; 挖矿 然后我们有必要来看一下挖矿。 先看一眼区块头部的数据结构。 其中Merkle树是对交易的散列树。两两合并最终形成根节点。来看一个更完整的图： 我们常说挖矿就是寻找这个随机数Nonce，其实在区块生成时的散列是固定的，Nonce的值从0开始。其中第一个交易是coinbase（挖矿交易），即挖矿交易会的输出地址是你的独一无二的地址，所以虽然区块生成时的散列是固定的，但每个区块的merkle tree根节点不同，所以对于每个矿工来说，被挖区块的散列是不同的。 挖矿的目的就是改变这个Nonce的值，通常从0开始往上增加。每改变一次Nonce，我们就对区块重新计算HASH，直到得出的HASH值满足区块头中的目标值。这个目标值是一个标准，通常前n位为0，如果矿工计算出的HASH值小于等于该目标值，也就是至少前n位为0时，挖矿成功。目标值也叫难度值，比特币规定十分钟挖出一个区块，若是快于或者慢于十分钟，目标值就会自动调整，使得挖矿更难或者更容易。保证十分钟产出一个区块。 当然区块中的交易，就是这10分钟内产生的交易。如果交易太多（因为每个区块大小为1MB，存储交易数量有限），则继续由下一个区块打包。 找到这个随机数不容易，因为散列函数的性质决定了不能一下就猜到数字，只有一个一个试，因为通常从0开始一个一个往上加，所以说最后的Nonce值，就是矿工执行哈希散列的次数。 同时我们可以发现，找随机数不容易，但是验证却极其简单，只需要将随机数带入区块，其他节点一次散列即可对某个挖出区块的矿工节点进行验证。 &nbsp; &nbsp; 阅读更多" />
<meta property="og:description" content="有关区块链的文章很多，但是我总感觉每一篇读完之后理解的都不透彻。趁着刚学习完一些理论知识，来自己整理篇终极入门。 （可以收藏但不支持转载） &nbsp; 区块链的监管 区块链并不是一个新技术，而是一堆已有技术的结合，包括分布式技术、密码学等等。比特币诞生与2009年，区块链作为其后端支撑，在2015年才掀起浪潮，大家逐渐发现区块链的应用领域远远不止代币（代币这个词很好理解，作为钱币的替代品，在特定的场合或者范围内才有效。比如比特币莱特币以太币等等等等。) 我国对于代币的监管较严格，中国人民银行宣布，发行初始代币(ICOs)是一种非法的融资手段。但同时，我国支持区块链技术的发展，并在16年12月其归为互联网金融的一项技术（参考《北京市“十三五”时期金融业发展规划》），在之前的8月，北京市金融工作局已经在推动中关村区块链联盟设立。 截止2018.5，北京、上海、广州、深圳、浙江、贵州等地在内的十八个地区出台了相关区块链项目鼓励政策。各地区将区块链研发及应用作为重要战略发展目标，并出台详细鼓励政策。所以抛开代币这个概念，区块链的未来还是值得期待的。 最近由于参加项目，收集了一些区块链在各领域在2018-2023年市场价值的预测数据，做了个柱状图。 但是这个数据吧，我认为看看就好并不能当真 = =，毕竟现在区块链的底层技术还不成熟，发展空间较大。由于供应链金融这块很贴紧区块链的运作方式，所以目前也在大力发展。 感觉说了一堆没用的。其实是想大家先了解下这个领域，包括他的制度。 &nbsp; 区块链概述 Melanie Swan在《区块链：新经济蓝图及导读》中将区块链应用分为区块链1.0、2.0和3.0 区块链1.0：比特币，支撑虚拟货币应用，转账、汇款和数字化支付相关的密码学货币应用。 区块链2.0：支撑智能合约应用合约是经济、市场和金融的区块链应用的基石。应用包括股票、债券、期货、贷款、抵押、产权、智能财产和智能合约。2.0的代表是以太坊，以智能合约为中心，用户可以自己编辑智能合约（这当然存在一定的风险，比如TheDAO事件，黑客就是从智能合约中的漏洞入手。） 区块链3.0：应用是超越货币、金融和市场的范围的去中心化应用，特别是政府、健康、科学、文艺和艺术领域。3.0的代表是EOS(so called 3.0)，但是平台好像不是很稳定，速度并没有他对外宣称的那么快。其实3.0可能还在发展中。 &nbsp; 比特币分类： 1. 公有链(Public blockchain)：对所有人开放，任何人都可以参与。 &nbsp; &nbsp; 应用包括：比特币、以太坊、虚拟货币、面向大众的电子商务、互联网金融等B2C\C2C\C2B等场景 2.&nbsp;私有链(Private blockchain)：对单独的个人或实体开放 &nbsp; &nbsp; 应用包括：数据库管理、审计，防范内部和外部的对数据安全的攻击，是许可链 3.&nbsp;联盟链(Consortium blockchain)：对特定的组织团体开放 &nbsp; &nbsp; 应用包括：40多家银行参与的区块链联盟R3，和Linux基金会支持的超级账本Hyperledger，需要注册许可，许可链 &nbsp;&nbsp;&nbsp;&nbsp;用于机构间交易、结算或清算等B2B形式 4. 侧链(sidechains)：比特币平均每十分钟出一个区块，每个区块1MB大小，使得大概每秒才能确认7笔交易。侧链来提升效率。&nbsp; &nbsp; &nbsp; 闪电网络把很多交易放在侧链，只有在做清算时才用上主链，大大提高交易速率，又不会增加主链的存储负担。 5. 互联链(interchain)：各自垂直领域的区块链互联互通，形成区块链全球网络。 &nbsp; 区块链行业架构：协议层、扩展层、应用层。 协议层 底层技术，完整的区块链产品，维护网络节点，提供API调用。通常提供简单的客户端。 构建了网络环境，搭建了交易通道，指定了节点奖励规则， 技术：网络编程、分布式算法、加密签名、数据存储技术。 语言：网络编程能力强的，对并发处理简单的。比如Nodejs, Go &nbsp; 进一步分为存储层和网络层。 比特币选择的是谷歌的LevelDB，读写性能好。 网络层是编码的重点和难点，包括点对点网络中的分布式算法、加密签名。《Nodejs开发加密货币》 也有将点对点网络的实现单独分开： 节点查找、数据传输和验证等逻辑独立 共识算法、加密签名、数据存储等组成核心层 &nbsp; 扩展层 类似电脑驱动，让区块链产品更加实用。 有两类，一是各类交易市场，法币兑换加密货币。 二是针对某个方向的扩展实现，例如智能合约，即达到某个条件，合约自动执行，比如证券转移。 技术没有限制，分布式存储、机器学习、VR、物联网、大数据等等。 任何需要第三方支付的产品都可以方便的使用区块链 任何需要确权、征信和追溯的信息，也可以借助区块链。 &nbsp; 应用层 各种客户端（DAPP、钱包等）。 &nbsp; 比特币协议层使用C++开发、官方客户端钱包用Qt、第三方钱包用Python，共识算法采用PoW(Proof of work)工作量证明机制。 以太坊给出了Go(go-ethereum)\Java(Ethereum(J))\Python等多语言的实现。客户端有Rust, Ruby, Javascript等。 &nbsp; 大家对区块链的定义都是分布式的公开数据库，或者叫他账本。所以功能明显：存储。存储的是什么？不可篡改的交易。 一段时间内产生的交易被打包进一个区块中，这个区块被挖出来之后（称为挖矿），连接到最长的链条上（区块数量最多），就构成了区块链。 我们根据比特币区块链来理解区块链的工作方式。 &nbsp; 比特币地址 首先我们来看一下比特币地址。作为交易的用户，我们首先每个人要有个地址，这样我才能给你转账。 比特币地址由数字和字母组成。生成过程如下： 公私钥若是有问题参考密码学。 非对称加密：每个人有两把钥匙，其中一把只有自己知道（私钥），另一把可以公布于众（公钥）；通过私钥加密过的信息，只要公钥才能解密，连私钥都不能，公钥可以通过私钥生成很多把。 用户随机生成私钥，然后通过私钥产生公钥，对公钥进行SHA256加密函数加密，再使用RIPEMD160加密，得到了公钥HASH。再经过两次SHA256加密，取前四字节作为校验码加入到原公钥HASH中，再添加相应的版本号（目前为0x00），将这些字节合并后通过Base58，生成58字节的比特币地址。 &nbsp; 交易 对于每个账户，比特币存储的不是其余额（还剩多少比特币），而是交易记录。比如A转给我1个比特币，B转给我2两个比特币，存储的是这些账单。而比特币的创新在于UTXO（Unspent Transaction Output，未花费的交易输出）。也就是说，我要发起一笔交易，转账给C两个比特币，这时交易的输入则是部分UTXO。我有一些别人转账给我的账单，来自A的1个和B的两个，那么我转给C的这个交易，使用的就可能是B转给我的这笔钱。 我们来看看交易的输入与输出： previous tx的值是即是一笔UTXO的哈希，在例子中则是选择C转给我的2个比特币，将这些钱给C。作为输入的交易可以是多个。（比如我想转D3个比特币。A与B的交易单个肯定不够） 输入脚本：也就是scriptSig是转账人私钥生成的数字签名，即需要转账人证明自己有与公钥哈希对应的私钥，这样他才可以使用这笔UTXO。scriptSig下一行是转账人的公钥。 Value就是转账的金额。 scriptPubKey：是输出脚本，其中包含了若干脚本命令，以及收款方的地址。 &nbsp; 现在我们来看脚本的执行过程。 比特币的脚本基于堆栈，后进先出。 交易1 ：A转账给B 输入：A的签名&amp;公钥 输出：B的公钥HASH 交易2：B转账给C 输入：B的签名&amp;公钥 输出：C的公钥HASH 先执行交易2的输入脚本，从左向右，将签名与公钥入栈；然后执行交易1的输出脚本OP_DUP——复制栈顶元素。 然后OP_HASH160计算栈顶元素的HASH，也就是A的公钥HASH，即A的比特币地址。然后将交易1的输出中的地址（A的地址）压栈。 接下来OP_EQUALVERIFY判断栈顶前两个元素是否相等。如果相等继续执行，如果不相等中断。最后使用OP_CHECKSIG来进行签名校验，即公私钥匹配。 一串指令证明了想要花费该UTXO中比特币的人，是否有对应的私钥，也就是这笔转账是否是转给A的，或者是A是否有权限可以花。 &nbsp; 挖矿 然后我们有必要来看一下挖矿。 先看一眼区块头部的数据结构。 其中Merkle树是对交易的散列树。两两合并最终形成根节点。来看一个更完整的图： 我们常说挖矿就是寻找这个随机数Nonce，其实在区块生成时的散列是固定的，Nonce的值从0开始。其中第一个交易是coinbase（挖矿交易），即挖矿交易会的输出地址是你的独一无二的地址，所以虽然区块生成时的散列是固定的，但每个区块的merkle tree根节点不同，所以对于每个矿工来说，被挖区块的散列是不同的。 挖矿的目的就是改变这个Nonce的值，通常从0开始往上增加。每改变一次Nonce，我们就对区块重新计算HASH，直到得出的HASH值满足区块头中的目标值。这个目标值是一个标准，通常前n位为0，如果矿工计算出的HASH值小于等于该目标值，也就是至少前n位为0时，挖矿成功。目标值也叫难度值，比特币规定十分钟挖出一个区块，若是快于或者慢于十分钟，目标值就会自动调整，使得挖矿更难或者更容易。保证十分钟产出一个区块。 当然区块中的交易，就是这10分钟内产生的交易。如果交易太多（因为每个区块大小为1MB，存储交易数量有限），则继续由下一个区块打包。 找到这个随机数不容易，因为散列函数的性质决定了不能一下就猜到数字，只有一个一个试，因为通常从0开始一个一个往上加，所以说最后的Nonce值，就是矿工执行哈希散列的次数。 同时我们可以发现，找随机数不容易，但是验证却极其简单，只需要将随机数带入区块，其他节点一次散列即可对某个挖出区块的矿工节点进行验证。 &nbsp; &nbsp; 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"有关区块链的文章很多，但是我总感觉每一篇读完之后理解的都不透彻。趁着刚学习完一些理论知识，来自己整理篇终极入门。 （可以收藏但不支持转载） &nbsp; 区块链的监管 区块链并不是一个新技术，而是一堆已有技术的结合，包括分布式技术、密码学等等。比特币诞生与2009年，区块链作为其后端支撑，在2015年才掀起浪潮，大家逐渐发现区块链的应用领域远远不止代币（代币这个词很好理解，作为钱币的替代品，在特定的场合或者范围内才有效。比如比特币莱特币以太币等等等等。) 我国对于代币的监管较严格，中国人民银行宣布，发行初始代币(ICOs)是一种非法的融资手段。但同时，我国支持区块链技术的发展，并在16年12月其归为互联网金融的一项技术（参考《北京市“十三五”时期金融业发展规划》），在之前的8月，北京市金融工作局已经在推动中关村区块链联盟设立。 截止2018.5，北京、上海、广州、深圳、浙江、贵州等地在内的十八个地区出台了相关区块链项目鼓励政策。各地区将区块链研发及应用作为重要战略发展目标，并出台详细鼓励政策。所以抛开代币这个概念，区块链的未来还是值得期待的。 最近由于参加项目，收集了一些区块链在各领域在2018-2023年市场价值的预测数据，做了个柱状图。 但是这个数据吧，我认为看看就好并不能当真 = =，毕竟现在区块链的底层技术还不成熟，发展空间较大。由于供应链金融这块很贴紧区块链的运作方式，所以目前也在大力发展。 感觉说了一堆没用的。其实是想大家先了解下这个领域，包括他的制度。 &nbsp; 区块链概述 Melanie Swan在《区块链：新经济蓝图及导读》中将区块链应用分为区块链1.0、2.0和3.0 区块链1.0：比特币，支撑虚拟货币应用，转账、汇款和数字化支付相关的密码学货币应用。 区块链2.0：支撑智能合约应用合约是经济、市场和金融的区块链应用的基石。应用包括股票、债券、期货、贷款、抵押、产权、智能财产和智能合约。2.0的代表是以太坊，以智能合约为中心，用户可以自己编辑智能合约（这当然存在一定的风险，比如TheDAO事件，黑客就是从智能合约中的漏洞入手。） 区块链3.0：应用是超越货币、金融和市场的范围的去中心化应用，特别是政府、健康、科学、文艺和艺术领域。3.0的代表是EOS(so called 3.0)，但是平台好像不是很稳定，速度并没有他对外宣称的那么快。其实3.0可能还在发展中。 &nbsp; 比特币分类： 1. 公有链(Public blockchain)：对所有人开放，任何人都可以参与。 &nbsp; &nbsp; 应用包括：比特币、以太坊、虚拟货币、面向大众的电子商务、互联网金融等B2C\\C2C\\C2B等场景 2.&nbsp;私有链(Private blockchain)：对单独的个人或实体开放 &nbsp; &nbsp; 应用包括：数据库管理、审计，防范内部和外部的对数据安全的攻击，是许可链 3.&nbsp;联盟链(Consortium blockchain)：对特定的组织团体开放 &nbsp; &nbsp; 应用包括：40多家银行参与的区块链联盟R3，和Linux基金会支持的超级账本Hyperledger，需要注册许可，许可链 &nbsp;&nbsp;&nbsp;&nbsp;用于机构间交易、结算或清算等B2B形式 4. 侧链(sidechains)：比特币平均每十分钟出一个区块，每个区块1MB大小，使得大概每秒才能确认7笔交易。侧链来提升效率。&nbsp; &nbsp; &nbsp; 闪电网络把很多交易放在侧链，只有在做清算时才用上主链，大大提高交易速率，又不会增加主链的存储负担。 5. 互联链(interchain)：各自垂直领域的区块链互联互通，形成区块链全球网络。 &nbsp; 区块链行业架构：协议层、扩展层、应用层。 协议层 底层技术，完整的区块链产品，维护网络节点，提供API调用。通常提供简单的客户端。 构建了网络环境，搭建了交易通道，指定了节点奖励规则， 技术：网络编程、分布式算法、加密签名、数据存储技术。 语言：网络编程能力强的，对并发处理简单的。比如Nodejs, Go &nbsp; 进一步分为存储层和网络层。 比特币选择的是谷歌的LevelDB，读写性能好。 网络层是编码的重点和难点，包括点对点网络中的分布式算法、加密签名。《Nodejs开发加密货币》 也有将点对点网络的实现单独分开： 节点查找、数据传输和验证等逻辑独立 共识算法、加密签名、数据存储等组成核心层 &nbsp; 扩展层 类似电脑驱动，让区块链产品更加实用。 有两类，一是各类交易市场，法币兑换加密货币。 二是针对某个方向的扩展实现，例如智能合约，即达到某个条件，合约自动执行，比如证券转移。 技术没有限制，分布式存储、机器学习、VR、物联网、大数据等等。 任何需要第三方支付的产品都可以方便的使用区块链 任何需要确权、征信和追溯的信息，也可以借助区块链。 &nbsp; 应用层 各种客户端（DAPP、钱包等）。 &nbsp; 比特币协议层使用C++开发、官方客户端钱包用Qt、第三方钱包用Python，共识算法采用PoW(Proof of work)工作量证明机制。 以太坊给出了Go(go-ethereum)\\Java(Ethereum(J))\\Python等多语言的实现。客户端有Rust, Ruby, Javascript等。 &nbsp; 大家对区块链的定义都是分布式的公开数据库，或者叫他账本。所以功能明显：存储。存储的是什么？不可篡改的交易。 一段时间内产生的交易被打包进一个区块中，这个区块被挖出来之后（称为挖矿），连接到最长的链条上（区块数量最多），就构成了区块链。 我们根据比特币区块链来理解区块链的工作方式。 &nbsp; 比特币地址 首先我们来看一下比特币地址。作为交易的用户，我们首先每个人要有个地址，这样我才能给你转账。 比特币地址由数字和字母组成。生成过程如下： 公私钥若是有问题参考密码学。 非对称加密：每个人有两把钥匙，其中一把只有自己知道（私钥），另一把可以公布于众（公钥）；通过私钥加密过的信息，只要公钥才能解密，连私钥都不能，公钥可以通过私钥生成很多把。 用户随机生成私钥，然后通过私钥产生公钥，对公钥进行SHA256加密函数加密，再使用RIPEMD160加密，得到了公钥HASH。再经过两次SHA256加密，取前四字节作为校验码加入到原公钥HASH中，再添加相应的版本号（目前为0x00），将这些字节合并后通过Base58，生成58字节的比特币地址。 &nbsp; 交易 对于每个账户，比特币存储的不是其余额（还剩多少比特币），而是交易记录。比如A转给我1个比特币，B转给我2两个比特币，存储的是这些账单。而比特币的创新在于UTXO（Unspent Transaction Output，未花费的交易输出）。也就是说，我要发起一笔交易，转账给C两个比特币，这时交易的输入则是部分UTXO。我有一些别人转账给我的账单，来自A的1个和B的两个，那么我转给C的这个交易，使用的就可能是B转给我的这笔钱。 我们来看看交易的输入与输出： previous tx的值是即是一笔UTXO的哈希，在例子中则是选择C转给我的2个比特币，将这些钱给C。作为输入的交易可以是多个。（比如我想转D3个比特币。A与B的交易单个肯定不够） 输入脚本：也就是scriptSig是转账人私钥生成的数字签名，即需要转账人证明自己有与公钥哈希对应的私钥，这样他才可以使用这笔UTXO。scriptSig下一行是转账人的公钥。 Value就是转账的金额。 scriptPubKey：是输出脚本，其中包含了若干脚本命令，以及收款方的地址。 &nbsp; 现在我们来看脚本的执行过程。 比特币的脚本基于堆栈，后进先出。 交易1 ：A转账给B 输入：A的签名&amp;公钥 输出：B的公钥HASH 交易2：B转账给C 输入：B的签名&amp;公钥 输出：C的公钥HASH 先执行交易2的输入脚本，从左向右，将签名与公钥入栈；然后执行交易1的输出脚本OP_DUP——复制栈顶元素。 然后OP_HASH160计算栈顶元素的HASH，也就是A的公钥HASH，即A的比特币地址。然后将交易1的输出中的地址（A的地址）压栈。 接下来OP_EQUALVERIFY判断栈顶前两个元素是否相等。如果相等继续执行，如果不相等中断。最后使用OP_CHECKSIG来进行签名校验，即公私钥匹配。 一串指令证明了想要花费该UTXO中比特币的人，是否有对应的私钥，也就是这笔转账是否是转给A的，或者是A是否有权限可以花。 &nbsp; 挖矿 然后我们有必要来看一下挖矿。 先看一眼区块头部的数据结构。 其中Merkle树是对交易的散列树。两两合并最终形成根节点。来看一个更完整的图： 我们常说挖矿就是寻找这个随机数Nonce，其实在区块生成时的散列是固定的，Nonce的值从0开始。其中第一个交易是coinbase（挖矿交易），即挖矿交易会的输出地址是你的独一无二的地址，所以虽然区块生成时的散列是固定的，但每个区块的merkle tree根节点不同，所以对于每个矿工来说，被挖区块的散列是不同的。 挖矿的目的就是改变这个Nonce的值，通常从0开始往上增加。每改变一次Nonce，我们就对区块重新计算HASH，直到得出的HASH值满足区块头中的目标值。这个目标值是一个标准，通常前n位为0，如果矿工计算出的HASH值小于等于该目标值，也就是至少前n位为0时，挖矿成功。目标值也叫难度值，比特币规定十分钟挖出一个区块，若是快于或者慢于十分钟，目标值就会自动调整，使得挖矿更难或者更容易。保证十分钟产出一个区块。 当然区块中的交易，就是这10分钟内产生的交易。如果交易太多（因为每个区块大小为1MB，存储交易数量有限），则继续由下一个区块打包。 找到这个随机数不容易，因为散列函数的性质决定了不能一下就猜到数字，只有一个一个试，因为通常从0开始一个一个往上加，所以说最后的Nonce值，就是矿工执行哈希散列的次数。 同时我们可以发现，找随机数不容易，但是验证却极其简单，只需要将随机数带入区块，其他节点一次散列即可对某个挖出区块的矿工节点进行验证。 &nbsp; &nbsp; 阅读更多","@type":"BlogPosting","url":"/2018/07/20/f5b89abdc33cd19a7b4b4da69e763055.html","headline":"区块链概论（开发者入门篇","dateModified":"2018-07-20T00:00:00+08:00","datePublished":"2018-07-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/07/20/f5b89abdc33cd19a7b4b4da69e763055.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链概论（开发者入门篇</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>有关区块链的文章很多，但是我总感觉每一篇读完之后理解的都不透彻。趁着刚学习完一些理论知识，来自己整理篇终极入门。</p> 
  <p>（可以收藏但不支持转载）</p> 
  <hr>
  <p>&nbsp;</p> 
  <h1><span style="color:#7c79e5;"><strong>区块链的监管</strong></span></h1> 
  <hr>
  <p>区块链并不是一个新技术，而是一堆已有技术的结合，包括分布式技术、密码学等等。比特币诞生与2009年，区块链作为其后端支撑，在2015年才掀起浪潮，大家逐渐发现区块链的应用领域远远不止代币（代币这个词很好理解，作为钱币的替代品，在特定的场合或者范围内才有效。比如比特币莱特币以太币等等等等。)</p> 
  <p>我国对于代币的监管较严格，中国人民银行宣布，发行初始代币(ICOs)是一种非法的融资手段。但同时，我国支持区块链技术的发展，并在16年12月其归为<strong>互联网金融</strong>的一项技术（参考《北京市“十三五”时期金融业发展规划》），在之前的8月，北京市金融工作局已经在推动中关村区块链联盟设立。</p> 
  <p>截止2018.5，北京、上海、广州、深圳、浙江、贵州等地在内的十八个地区出台了相关区块链项目鼓励政策。各地区将区块链研发及应用作为重要战略发展目标，并出台详细鼓励政策。所以抛开代币这个概念，区块链的未来还是值得期待的。</p> 
  <p>最近由于参加项目，收集了一些区块链在各领域在2018-2023年市场价值的预测数据，做了个柱状图。</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180720100926459?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsNTIzNTg3MTgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>但是这个数据吧，我认为看看就好并不能当真 = =，毕竟现在区块链的底层技术还不成熟，发展空间较大。由于供应链金融这块很贴紧区块链的运作方式，所以目前也在大力发展。</p> 
  <p>感觉说了一堆没用的。其实是想大家先了解下这个领域，包括他的制度。</p> 
  <p>&nbsp;</p> 
  <h1><span style="color:#7c79e5;"><strong>区块链概述</strong></span></h1> 
  <hr>
  <p style="margin-left:0in;">Melanie Swan在《区块链：新经济蓝图及导读》中将区块链应用分为区块链1.0、2.0和3.0</p> 
  <p style="margin-left:0in;">区块链1.0：比特币，支撑虚拟货币应用，转账、汇款和数字化支付相关的密码学货币应用。</p> 
  <p style="margin-left:0in;">区块链2.0：支撑智能合约应用合约是经济、市场和金融的区块链应用的基石。应用包括股票、债券、期货、贷款、抵押、产权、智能财产和智能合约。2.0的代表是以太坊，以智能合约为中心，用户可以自己编辑智能合约（这当然存在一定的风险，比如TheDAO事件，黑客就是从智能合约中的漏洞入手。）</p> 
  <p style="margin-left:0in;">区块链3.0：应用是超越货币、金融和市场的范围的去中心化应用，特别是政府、健康、科学、文艺和艺术领域。3.0的代表是EOS(so called 3.0)，但是平台好像不是很稳定，速度并没有他对外宣称的那么快。其实3.0可能还在发展中。</p> 
  <p style="margin-left:0in;">&nbsp;</p> 
  <h3 style="margin-left:0in;"><strong>比特币分类：</strong></h3> 
  <hr>
  <p style="margin-left:0in;">1. <strong>公有链</strong>(Public blockchain)：对所有人开放，任何人都可以参与。</p> 
  <p style="margin-left:0in;">&nbsp; &nbsp; 应用包括：比特币、以太坊、虚拟货币、面向大众的电子商务、互联网金融等B2C\C2C\C2B等场景</p> 
  <p style="margin-left:0in;">2.&nbsp;<strong>私有链</strong>(Private blockchain)：对单独的个人或实体开放</p> 
  <p style="margin-left:0in;">&nbsp; &nbsp; 应用包括：数据库管理、审计，防范内部和外部的对数据安全的攻击，是许可链</p> 
  <p style="margin-left:0in;">3.&nbsp;<strong>联盟链</strong>(Consortium blockchain)：对特定的组织团体开放</p> 
  <p style="margin-left:0in;">&nbsp; &nbsp; 应用包括：40多家银行参与的区块链联盟R3，和Linux基金会支持的超级账本Hyperledger，需要注册许可，许可链</p> 
  <p style="margin-left:0in;">&nbsp;&nbsp;&nbsp;&nbsp;用于机构间交易、结算或清算等B2B形式</p> 
  <p style="margin-left:0in;">4.<strong> 侧链</strong>(sidechains)：比特币平均每十分钟出一个区块，每个区块1MB大小，使得大概每秒才能确认7笔交易。侧链来提升效率。&nbsp; &nbsp; &nbsp; 闪电网络把很多交易放在侧链，只有在做清算时才用上主链，大大提高交易速率，又不会增加主链的存储负担。</p> 
  <p style="margin-left:0in;">5. <strong>互联链</strong>(interchain)：各自垂直领域的区块链互联互通，形成区块链全球网络。</p> 
  <p style="margin-left:0in;">&nbsp;</p> 
  <h3 style="margin-left:0in;"><strong>区块链行业架构：</strong>协议层、扩展层、应用层。</h3> 
  <hr>
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180720102416981?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsNTIzNTg3MTgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0in;"><span style="color:#2e75b5;"><strong>协议层</strong></span></p> 
  <p style="margin-left:0in;">底层技术，完整的区块链产品，维护网络节点，提供API调用。通常提供简单的客户端。</p> 
  <p style="margin-left:0in;">构建了网络环境，搭建了交易通道，指定了节点奖励规则，</p> 
  <p style="margin-left:0in;"><strong>技术：</strong>网络编程、分布式算法、加密签名、数据存储技术。</p> 
  <p style="margin-left:0in;"><strong>语言：</strong>网络编程能力强的，对并发处理简单的。比如Nodejs, Go</p> 
  <p style="margin-left:0in;">&nbsp;</p> 
  <p style="margin-left:0in;">进一步分为存储层和网络层。</p> 
  <p style="margin-left:0in;">比特币选择的是谷歌的LevelDB，读写性能好。</p> 
  <p style="margin-left:0in;">网络层是编码的重点和难点，包括点对点网络中的分布式算法、加密签名。《Nodejs开发加密货币》</p> 
  <p style="margin-left:0in;"><strong>也有将点对点网络的实现单独分开：</strong></p> 
  <p style="margin-left:0in;"><strong>节点查找、数据传输和验证等逻辑独立</strong></p> 
  <p style="margin-left:0in;"><strong>共识算法、加密签名、数据存储等组成核心层</strong></p> 
  <p style="margin-left:0in;">&nbsp;</p> 
  <p style="margin-left:0in;"><span style="color:#2e75b5;"><strong>扩展层</strong></span></p> 
  <p style="margin-left:0in;">类似电脑驱动，让区块链产品更加实用。</p> 
  <p style="margin-left:0in;">有两类，一是各类交易市场，法币兑换加密货币。</p> 
  <p style="margin-left:0in;">二是针对某个方向的扩展实现，例如智能合约，即达到某个条件，合约自动执行，比如证券转移。</p> 
  <p style="margin-left:0in;">技术没有限制，分布式存储、机器学习、VR、物联网、大数据等等。</p> 
  <p style="margin-left:0in;"><strong><u>任何需要第三方支付的产品都可以方便的使用区块链</u></strong></p> 
  <p style="margin-left:0in;"><strong><u>任何需要确权、征信和追溯的信息，也可以借助区块链。</u></strong></p> 
  <p style="margin-left:0in;">&nbsp;</p> 
  <p style="margin-left:0in;"><span style="color:#2e75b5;"><strong>应用层</strong></span></p> 
  <p style="margin-left:0in;">各种客户端（DAPP、钱包等）。</p> 
  <p style="margin-left:0in;">&nbsp;</p> 
  <p style="margin-left:0in;">比特币协议层使用C++开发、官方客户端钱包用Qt、第三方钱包用Python，共识算法采用PoW(Proof of work)工作量证明机制。</p> 
  <p style="margin-left:0in;">以太坊给出了Go(go-ethereum)\Java(Ethereum(J))\Python等多语言的实现。客户端有Rust, Ruby, Javascript等。</p> 
  <p style="margin-left:0in;">&nbsp;</p> 
  <p style="margin-left:0in;">大家对区块链的定义都是分布式的公开数据库，或者叫他账本。所以功能明显：存储。存储的是什么？不可篡改的交易。</p> 
  <p style="margin-left:0in;">一段时间内产生的交易被打包进一个区块中，这个区块被挖出来之后（称为挖矿），连接到最长的链条上（区块数量最多），就构成了区块链。</p> 
  <p style="margin-left:0in;">我们根据比特币区块链来理解区块链的工作方式。</p> 
  <p style="margin-left:0in;">&nbsp;</p> 
  <h1 style="margin-left:0in;"><span style="color:#7c79e5;"><strong>比特币地址</strong></span></h1> 
  <hr>
  <p style="margin-left:0in;">首先我们来看一下比特币地址。作为交易的用户，我们首先每个人要有个地址，这样我才能给你转账。</p> 
  <p style="margin-left:0in;">比特币地址由数字和字母组成。生成过程如下：</p> 
  <p style="margin-left:0in;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180720111959584?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsNTIzNTg3MTgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0in;">公私钥若是有问题参考密码学。</p> 
  <p style="margin-left:0in;">非对称加密：每个人有两把钥匙，其中一把只有自己知道（私钥），另一把可以公布于众（公钥）；通过私钥加密过的信息，只要公钥才能解密，连私钥都不能，公钥可以通过私钥生成很多把。</p> 
  <p style="margin-left:0in;">用户随机生成私钥，然后通过私钥产生公钥，对公钥进行SHA256加密函数加密，再使用RIPEMD160加密，得到了公钥HASH。再经过两次SHA256加密，取前四字节作为校验码加入到原公钥HASH中，再添加相应的版本号（目前为0x00），将这些字节合并后通过Base58，生成58字节的比特币地址。</p> 
  <p style="margin-left:0in;">&nbsp;</p> 
  <h1 style="margin-left:0in;"><span style="color:#7c79e5;"><strong>交易</strong></span></h1> 
  <hr>
  <p style="margin-left:0in;">对于每个账户，比特币存储的不是其余额（还剩多少比特币），而是交易记录。比如A转给我1个比特币，B转给我2两个比特币，存储的是这些账单。而比特币的创新在于UTXO（Unspent Transaction Output，未花费的交易输出）。也就是说，我要发起一笔交易，转账给C两个比特币，这时交易的输入则是部分UTXO。我有一些别人转账给我的账单，来自A的1个和B的两个，那么我转给C的这个交易，使用的就可能是B转给我的这笔钱。</p> 
  <p style="margin-left:0in;">我们来看看交易的输入与输出：</p> 
  <p style="margin-left:0in;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180804142523693?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsNTIzNTg3MTgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0in;">previous tx的值是即是一笔UTXO的哈希，在例子中则是选择C转给我的2个比特币，将这些钱给C。作为输入的交易可以是多个。（比如我想转D3个比特币。A与B的交易单个肯定不够）</p> 
  <p style="margin-left:0in;">输入脚本：也就是scriptSig是转账人私钥生成的数字签名，即需要转账人证明自己有与公钥哈希对应的私钥，这样他才可以使用这笔UTXO。scriptSig下一行是转账人的公钥。</p> 
  <p style="margin-left:0in;">Value就是转账的金额。</p> 
  <p style="margin-left:0in;">scriptPubKey：是输出脚本，其中包含了若干脚本命令，以及收款方的地址。</p> 
  <p style="margin-left:0in;">&nbsp;</p> 
  <p style="margin-left:0in;">现在我们来看脚本的执行过程。</p> 
  <p style="margin-left:0in;">比特币的脚本基于堆栈，后进先出。</p> 
  <p style="margin-left:0in;">交易1 ：A转账给B</p> 
  <p style="margin-left:0in;">输入：A的签名&amp;公钥</p> 
  <p style="margin-left:0in;">输出：B的公钥HASH</p> 
  <p style="margin-left:0in;">交易2：B转账给C</p> 
  <p style="margin-left:0in;">输入：B的签名&amp;公钥</p> 
  <p style="margin-left:0in;">输出：C的公钥HASH</p> 
  <p style="margin-left:0in;">先执行交易2的输入脚本，从左向右，将签名与公钥入栈；然后执行交易1的输出脚本OP_DUP——复制栈顶元素。</p> 
  <p style="margin-left:0in;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180804144715571?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsNTIzNTg3MTgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0in;">然后OP_HASH160计算栈顶元素的HASH，也就是A的公钥HASH，即A的比特币地址。然后将交易1的输出中的地址（A的地址）压栈。</p> 
  <p style="margin-left:0in;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180804145150221?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsNTIzNTg3MTgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0in;">接下来OP_EQUALVERIFY判断栈顶前两个元素是否相等。如果相等继续执行，如果不相等中断。最后使用OP_CHECKSIG来进行签名校验，即公私钥匹配。</p> 
  <p style="margin-left:0in;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180804145532678?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsNTIzNTg3MTgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0in;">一串指令证明了想要花费该UTXO中比特币的人，是否有对应的私钥，也就是这笔转账是否是转给A的，或者是A是否有权限可以花。</p> 
  <hr>
  <h1 style="margin-left:0in;">&nbsp;</h1> 
  <h1 style="margin-left:0in;"><span style="color:#7c79e5;">挖矿</span></h1> 
  <hr>
  <p style="margin-left:0in;">然后我们有必要来看一下挖矿。</p> 
  <p style="margin-left:0in;">先看一眼区块头部的数据结构。</p> 
  <p style="margin-left:0in;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180804150513525?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsNTIzNTg3MTgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0in;">其中Merkle树是对交易的散列树。两两合并最终形成根节点。来看一个更完整的图：</p> 
  <p style="margin-left:0in;"><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180804151114447?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsNTIzNTg3MTgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p style="margin-left:0in;">我们常说挖矿就是寻找这个随机数Nonce，其实在区块生成时的散列是固定的，Nonce的值从0开始。其中第一个交易是coinbase（挖矿交易），即挖矿交易会的输出地址是你的独一无二的地址，所以虽然区块生成时的散列是固定的，但每个区块的merkle tree根节点不同，所以对于每个矿工来说，被挖区块的散列是不同的。</p> 
  <p style="margin-left:0in;">挖矿的目的就是改变这个Nonce的值，通常从0开始往上增加。每改变一次Nonce，我们就对区块重新计算HASH，直到得出的HASH值满足区块头中的目标值。这个目标值是一个标准，通常前n位为0，如果矿工计算出的HASH值小于等于该目标值，也就是至少前n位为0时，挖矿成功。目标值也叫难度值，比特币规定十分钟挖出一个区块，若是快于或者慢于十分钟，目标值就会自动调整，使得挖矿更难或者更容易。保证十分钟产出一个区块。</p> 
  <p style="margin-left:0in;">当然区块中的交易，就是这10分钟内产生的交易。如果交易太多（因为每个区块大小为1MB，存储交易数量有限），则继续由下一个区块打包。</p> 
  <p style="margin-left:0in;">找到这个随机数不容易，因为散列函数的性质决定了不能一下就猜到数字，只有一个一个试，因为通常从0开始一个一个往上加，所以说最后的Nonce值，就是矿工执行哈希散列的次数。</p> 
  <p style="margin-left:0in;">同时我们可以发现，找随机数不容易，但是验证却极其简单，只需要将随机数带入区块，其他节点一次散列即可对某个挖出区块的矿工节点进行验证。</p> 
  <p style="margin-left:0in;">&nbsp;</p> 
  <p style="margin-left:0in;">&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ll523587181/article/details/81126819,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/ll523587181/article/details/81126819,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
