<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>生成比特币创世块C/C++源代码 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="生成比特币创世块C/C++源代码" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #include &lt;inttypes.h&gt; #include &lt;ctype.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #include &lt;openssl/sha.h&gt; //Copied from Bitcoin source const uint64_t COIN = 100000000; const uint64_t CENT = 1000000; uint32_t OP_CHECKSIG = 172; // This is expressed as 0xAC bool generateBlock = false; uint32_t startNonce = 0; uint32_t unixtime = 0; typedef struct { /* Hash of Tx */ uint8_t merkleHash[32]; /* Tx serialization before hashing */ uint8_t *serializedData; /* Tx version */ uint32_t version; /* Input */ uint8_t numInputs; // Program assumes one input uint8_t prevOutput[32]; uint32_t prevoutIndex; uint8_t *scriptSig;// nBitsLen + nBits + 0x01 + 0x04 + ScriptSig_len + timestamp uint32_t sequence; /* Output */ uint8_t numOutputs; // Program assumes one output uint64_t outValue; uint8_t *pubkeyScript;//0x41 + pubkey + OP_CHECKSIG /* Final */ uint32_t locktime; } Transaction; // Got this off the internet. Am not sure if it can fail in some circumstances void byteswap(uint8_t *buf, int length) { int i; uint8_t temp; for (i = 0; i &lt; length / 2; i++) { temp = buf[i]; buf[i] = buf[length - i - 1]; buf[length - i - 1] = temp; } } // Following two functions are borrowed from cgminer. char *bin2hex(const unsigned char *p, size_t len) { char *s = (char*)malloc((len * 2) + 1); unsigned int i; if (!s) return NULL; for (i = 0; i &lt; len; i++) sprintf_s(s + (i * 2), 3, &quot;%02x&quot;, (unsigned int)p[i]); return s; } size_t hex2bin(unsigned char *p, const char *hexstr, size_t len) { int ret = 0; size_t retlen = len; while (*hexstr &amp;&amp; len) { char hex_byte[4]; unsigned int v; if (!hexstr[1]) { return ret; } memset(hex_byte, 0, 4); hex_byte[0] = hexstr[0]; hex_byte[1] = hexstr[1]; if (sscanf_s(hex_byte, &quot;%x&quot;, &amp;v) != 1) { return ret; } *p = (unsigned char)v; p++; hexstr += 2; len--; } if (len == 0 &amp;&amp; *hexstr == 0) ret = retlen; return ret; } Transaction *InitTransaction() { Transaction *transaction; transaction = (Transaction *)calloc(1, sizeof(*transaction)); if (!transaction) { return NULL; } // Set some initial data that will remain constant throughout the program transaction-&gt;version = 1; transaction-&gt;numInputs = 1; transaction-&gt;numOutputs = 1; transaction-&gt;locktime = 0; transaction-&gt;prevoutIndex = 0xFFFFFFFF; transaction-&gt;sequence = 0xFFFFFFFF; transaction-&gt;outValue = 50 * COIN; // We initialize the previous output to 0 as there is none memset(transaction-&gt;prevOutput, 0, 32); return transaction; } //运行命令：./genesisgen [PubKey] [TimeStamp] [nBits] int main(int argc, char *argv[]) { Transaction *transaction; unsigned char hash1[32], hash2[32]; char timestamp[255], pubkey[132]; uint32_t timestamp_len = 0, scriptSig_len = 0, pubkey_len = 0, pubkeyScript_len = 0; uint32_t nBits = 0; if ((argc - 1) &lt; 3) { fprintf(stderr, &quot;Usage: genesisgen [options] &lt;pubkey&gt; \&quot;&lt;timestamp&gt;\&quot; &lt;nBits&gt;\n&quot;); return 0; } pubkey_len = strlen(argv[1]) / 2; // One byte is represented as two hex characters, thus we divide by two to get real length. timestamp_len = strlen(argv[2]); if (pubkey_len != 65) { fprintf(stderr, &quot;Invalid public key length! %s\n&quot;, argv[1]); return 0; } if (timestamp_len &gt; 254 || timestamp_len &lt;= 0) { fprintf(stderr, &quot;Size of timestamp is 0 or exceeds maximum length of 254 characters!\n&quot;); return 0; } transaction = InitTransaction(); if (!transaction) { fprintf(stderr, &quot;Could not allocate memory! Exiting...\n&quot;); return 0; } strncpy_s(pubkey, argv[1], sizeof(pubkey)); strncpy_s(timestamp, argv[2], sizeof(timestamp)); sscanf_s(argv[3], &quot;%lu&quot;, (long unsigned int *)&amp;nBits); pubkey_len = strlen(pubkey) &gt;&gt; 1; scriptSig_len = timestamp_len; // Encode pubkey to binary and prepend pubkey size, then append the OP_CHECKSIG byte transaction-&gt;pubkeyScript = (uint8_t*)malloc((pubkey_len + 2) * sizeof(uint8_t)); pubkeyScript_len = hex2bin(transaction-&gt;pubkeyScript + 1, pubkey, pubkey_len); // No error checking, yeah. transaction-&gt;pubkeyScript[0] = 0x41; // A public key is 32 bytes X coordinate, 32 bytes Y coordinate and one byte 0x04, so 65 bytes i.e 0x41 in Hex. pubkeyScript_len += 1; transaction-&gt;pubkeyScript[pubkeyScript_len++] = OP_CHECKSIG; // Encode timestamp to binary transaction-&gt;scriptSig = (uint8_t*)malloc(scriptSig_len * sizeof(uint8_t)); uint32_t scriptSig_pos = 0; // This is basically how I believe the size of the nBits is calculated if (nBits &lt;= 255) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x01; transaction-&gt;scriptSig[scriptSig_pos++] = (uint8_t)nBits; } else if (nBits &lt;= 65535) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x02; memcpy(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, 2); scriptSig_pos += 2; } else if (nBits &lt;= 16777215) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x03; memcpy(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, 3); scriptSig_pos += 3; } else //else if(nBits &lt;= 4294967296LL) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x04; memcpy(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, 4); scriptSig_pos += 4; } // Important! In the Bitcoin code there is a statement &#39;CBigNum(4)&#39; // i&#39;ve been wondering for a while what it is but // seeing as alt-coins keep it the same, we&#39;ll do it here as well // It should essentially mean PUSH 1 byte on the stack which in this case is 0x04 or just 4 transaction-&gt;scriptSig[scriptSig_pos++] = 0x01; transaction-&gt;scriptSig[scriptSig_pos++] = 0x04; transaction-&gt;scriptSig[scriptSig_pos++] = (uint8_t)scriptSig_len; scriptSig_len += scriptSig_pos; transaction-&gt;scriptSig = (uint8_t*)realloc(transaction-&gt;scriptSig, scriptSig_len * sizeof(uint8_t)); memcpy(transaction-&gt;scriptSig + scriptSig_pos, (const unsigned char *)timestamp, timestamp_len); // Here we are asuming some values will have the same size uint32_t serializedLen = 4 // tx version + 1 // number of inputs + 32 // hash of previous output + 4 // previous output&#39;s index + 1 // 1 byte for the size of scriptSig + scriptSig_len + 4 // size of sequence + 1 // number of outputs + 8 // 8 bytes for coin value + 1 // 1 byte to represent size of the pubkey Script + pubkeyScript_len + 4; // 4 bytes for lock time // Now let&#39;s serialize the data uint32_t serializedData_pos = 0; transaction-&gt;serializedData = (uint8_t*)malloc(serializedLen * sizeof(uint8_t)); memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;version, 4); serializedData_pos += 4; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;numInputs, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;prevOutput, 32); serializedData_pos += 32; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;prevoutIndex, 4); serializedData_pos += 4; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;scriptSig_len, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;scriptSig, scriptSig_len); serializedData_pos += scriptSig_len; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;sequence, 4); serializedData_pos += 4; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;numOutputs, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;outValue, 8); serializedData_pos += 8; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;pubkeyScript_len, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;pubkeyScript, pubkeyScript_len); serializedData_pos += pubkeyScript_len; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;locktime, 4); serializedData_pos += 4; // Now that the data is serialized // we hash it with SHA256 and then hash that result to get merkle hash SHA256(transaction-&gt;serializedData, serializedLen, hash1); SHA256(hash1, 32, hash2); // This copy isn&#39;t necessary imo, but here for clarity memcpy(transaction-&gt;merkleHash, hash2, 32); char *merkleHash = bin2hex(transaction-&gt;merkleHash, 32); byteswap(transaction-&gt;merkleHash, 32); char *merkleHashSwapped = bin2hex(transaction-&gt;merkleHash, 32); char *txScriptSig = bin2hex(transaction-&gt;scriptSig, scriptSig_len); char *pubScriptSig = bin2hex(transaction-&gt;pubkeyScript, pubkeyScript_len); printf(&quot;\nCoinbase: %s\n\nPubkeyScript: %s\n\nMerkle Hash: %s\nByteswapped: %s\n&quot;, txScriptSig, pubScriptSig, merkleHash, merkleHashSwapped); //if(generateBlock) { printf(&quot;Generating block...\n&quot;); if (!unixtime) { unixtime = time(NULL); } unsigned char block_header[80], block_hash1[32], block_hash2[32]; uint32_t blockversion = 1; memcpy(block_header, &amp;blockversion, 4); memset(block_header + 4, 0, 32); byteswap(transaction-&gt;merkleHash, 32); // We swapped it before, so do it again now. memcpy(block_header + 36, transaction-&gt;merkleHash, 32); memcpy(block_header + 68, &amp;unixtime, 4); memcpy(block_header + 72, &amp;nBits, 4); memcpy(block_header + 76, &amp;startNonce, 4); uint32_t *pNonce = (uint32_t *)(block_header + 76); uint32_t *pUnixtime = (uint32_t *)(block_header + 68); unsigned int counter = 0, start = time(NULL); while (1) { SHA256(block_header, 80, block_hash1); SHA256(block_hash1, 32, block_hash2); unsigned int check = *((uint32_t *)(block_hash2 + 28)); // The hash is in little-endian, so we check the last 4 bytes. if (check == 0) // \x00\x00\x00\x00 { byteswap(block_hash2, 32); char *blockHash = bin2hex(block_hash2, 32); printf(&quot;\nBlock found!\nHash: %s\nNonce: %u\nUnix time: %u&quot;, blockHash, startNonce, unixtime); free(blockHash); break; } startNonce++; counter += 1; if (time(NULL) - start &gt;= 1) { printf(&quot;\r%d Hashes/s, Nonce %u\r&quot;, counter, startNonce); counter = 0; start = time(NULL); } *pNonce = startNonce; if (startNonce &gt; 4294967294LL) { //printf(&quot;\nBlock found!\nHash: %s\nNonce: %u\nUnix time: %u&quot;, blockHash, startNonce, unixtime); unixtime++; *pUnixtime = unixtime; startNonce = 0; } } } // Lots of cleanup free(merkleHash); free(merkleHashSwapped); free(txScriptSig); free(pubScriptSig); free(transaction-&gt;serializedData); free(transaction-&gt;scriptSig); free(transaction-&gt;pubkeyScript); free(transaction); getchar(); return 0; } 阅读更多" />
<meta property="og:description" content="#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #include &lt;inttypes.h&gt; #include &lt;ctype.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #include &lt;openssl/sha.h&gt; //Copied from Bitcoin source const uint64_t COIN = 100000000; const uint64_t CENT = 1000000; uint32_t OP_CHECKSIG = 172; // This is expressed as 0xAC bool generateBlock = false; uint32_t startNonce = 0; uint32_t unixtime = 0; typedef struct { /* Hash of Tx */ uint8_t merkleHash[32]; /* Tx serialization before hashing */ uint8_t *serializedData; /* Tx version */ uint32_t version; /* Input */ uint8_t numInputs; // Program assumes one input uint8_t prevOutput[32]; uint32_t prevoutIndex; uint8_t *scriptSig;// nBitsLen + nBits + 0x01 + 0x04 + ScriptSig_len + timestamp uint32_t sequence; /* Output */ uint8_t numOutputs; // Program assumes one output uint64_t outValue; uint8_t *pubkeyScript;//0x41 + pubkey + OP_CHECKSIG /* Final */ uint32_t locktime; } Transaction; // Got this off the internet. Am not sure if it can fail in some circumstances void byteswap(uint8_t *buf, int length) { int i; uint8_t temp; for (i = 0; i &lt; length / 2; i++) { temp = buf[i]; buf[i] = buf[length - i - 1]; buf[length - i - 1] = temp; } } // Following two functions are borrowed from cgminer. char *bin2hex(const unsigned char *p, size_t len) { char *s = (char*)malloc((len * 2) + 1); unsigned int i; if (!s) return NULL; for (i = 0; i &lt; len; i++) sprintf_s(s + (i * 2), 3, &quot;%02x&quot;, (unsigned int)p[i]); return s; } size_t hex2bin(unsigned char *p, const char *hexstr, size_t len) { int ret = 0; size_t retlen = len; while (*hexstr &amp;&amp; len) { char hex_byte[4]; unsigned int v; if (!hexstr[1]) { return ret; } memset(hex_byte, 0, 4); hex_byte[0] = hexstr[0]; hex_byte[1] = hexstr[1]; if (sscanf_s(hex_byte, &quot;%x&quot;, &amp;v) != 1) { return ret; } *p = (unsigned char)v; p++; hexstr += 2; len--; } if (len == 0 &amp;&amp; *hexstr == 0) ret = retlen; return ret; } Transaction *InitTransaction() { Transaction *transaction; transaction = (Transaction *)calloc(1, sizeof(*transaction)); if (!transaction) { return NULL; } // Set some initial data that will remain constant throughout the program transaction-&gt;version = 1; transaction-&gt;numInputs = 1; transaction-&gt;numOutputs = 1; transaction-&gt;locktime = 0; transaction-&gt;prevoutIndex = 0xFFFFFFFF; transaction-&gt;sequence = 0xFFFFFFFF; transaction-&gt;outValue = 50 * COIN; // We initialize the previous output to 0 as there is none memset(transaction-&gt;prevOutput, 0, 32); return transaction; } //运行命令：./genesisgen [PubKey] [TimeStamp] [nBits] int main(int argc, char *argv[]) { Transaction *transaction; unsigned char hash1[32], hash2[32]; char timestamp[255], pubkey[132]; uint32_t timestamp_len = 0, scriptSig_len = 0, pubkey_len = 0, pubkeyScript_len = 0; uint32_t nBits = 0; if ((argc - 1) &lt; 3) { fprintf(stderr, &quot;Usage: genesisgen [options] &lt;pubkey&gt; \&quot;&lt;timestamp&gt;\&quot; &lt;nBits&gt;\n&quot;); return 0; } pubkey_len = strlen(argv[1]) / 2; // One byte is represented as two hex characters, thus we divide by two to get real length. timestamp_len = strlen(argv[2]); if (pubkey_len != 65) { fprintf(stderr, &quot;Invalid public key length! %s\n&quot;, argv[1]); return 0; } if (timestamp_len &gt; 254 || timestamp_len &lt;= 0) { fprintf(stderr, &quot;Size of timestamp is 0 or exceeds maximum length of 254 characters!\n&quot;); return 0; } transaction = InitTransaction(); if (!transaction) { fprintf(stderr, &quot;Could not allocate memory! Exiting...\n&quot;); return 0; } strncpy_s(pubkey, argv[1], sizeof(pubkey)); strncpy_s(timestamp, argv[2], sizeof(timestamp)); sscanf_s(argv[3], &quot;%lu&quot;, (long unsigned int *)&amp;nBits); pubkey_len = strlen(pubkey) &gt;&gt; 1; scriptSig_len = timestamp_len; // Encode pubkey to binary and prepend pubkey size, then append the OP_CHECKSIG byte transaction-&gt;pubkeyScript = (uint8_t*)malloc((pubkey_len + 2) * sizeof(uint8_t)); pubkeyScript_len = hex2bin(transaction-&gt;pubkeyScript + 1, pubkey, pubkey_len); // No error checking, yeah. transaction-&gt;pubkeyScript[0] = 0x41; // A public key is 32 bytes X coordinate, 32 bytes Y coordinate and one byte 0x04, so 65 bytes i.e 0x41 in Hex. pubkeyScript_len += 1; transaction-&gt;pubkeyScript[pubkeyScript_len++] = OP_CHECKSIG; // Encode timestamp to binary transaction-&gt;scriptSig = (uint8_t*)malloc(scriptSig_len * sizeof(uint8_t)); uint32_t scriptSig_pos = 0; // This is basically how I believe the size of the nBits is calculated if (nBits &lt;= 255) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x01; transaction-&gt;scriptSig[scriptSig_pos++] = (uint8_t)nBits; } else if (nBits &lt;= 65535) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x02; memcpy(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, 2); scriptSig_pos += 2; } else if (nBits &lt;= 16777215) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x03; memcpy(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, 3); scriptSig_pos += 3; } else //else if(nBits &lt;= 4294967296LL) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x04; memcpy(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, 4); scriptSig_pos += 4; } // Important! In the Bitcoin code there is a statement &#39;CBigNum(4)&#39; // i&#39;ve been wondering for a while what it is but // seeing as alt-coins keep it the same, we&#39;ll do it here as well // It should essentially mean PUSH 1 byte on the stack which in this case is 0x04 or just 4 transaction-&gt;scriptSig[scriptSig_pos++] = 0x01; transaction-&gt;scriptSig[scriptSig_pos++] = 0x04; transaction-&gt;scriptSig[scriptSig_pos++] = (uint8_t)scriptSig_len; scriptSig_len += scriptSig_pos; transaction-&gt;scriptSig = (uint8_t*)realloc(transaction-&gt;scriptSig, scriptSig_len * sizeof(uint8_t)); memcpy(transaction-&gt;scriptSig + scriptSig_pos, (const unsigned char *)timestamp, timestamp_len); // Here we are asuming some values will have the same size uint32_t serializedLen = 4 // tx version + 1 // number of inputs + 32 // hash of previous output + 4 // previous output&#39;s index + 1 // 1 byte for the size of scriptSig + scriptSig_len + 4 // size of sequence + 1 // number of outputs + 8 // 8 bytes for coin value + 1 // 1 byte to represent size of the pubkey Script + pubkeyScript_len + 4; // 4 bytes for lock time // Now let&#39;s serialize the data uint32_t serializedData_pos = 0; transaction-&gt;serializedData = (uint8_t*)malloc(serializedLen * sizeof(uint8_t)); memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;version, 4); serializedData_pos += 4; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;numInputs, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;prevOutput, 32); serializedData_pos += 32; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;prevoutIndex, 4); serializedData_pos += 4; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;scriptSig_len, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;scriptSig, scriptSig_len); serializedData_pos += scriptSig_len; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;sequence, 4); serializedData_pos += 4; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;numOutputs, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;outValue, 8); serializedData_pos += 8; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;pubkeyScript_len, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;pubkeyScript, pubkeyScript_len); serializedData_pos += pubkeyScript_len; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;locktime, 4); serializedData_pos += 4; // Now that the data is serialized // we hash it with SHA256 and then hash that result to get merkle hash SHA256(transaction-&gt;serializedData, serializedLen, hash1); SHA256(hash1, 32, hash2); // This copy isn&#39;t necessary imo, but here for clarity memcpy(transaction-&gt;merkleHash, hash2, 32); char *merkleHash = bin2hex(transaction-&gt;merkleHash, 32); byteswap(transaction-&gt;merkleHash, 32); char *merkleHashSwapped = bin2hex(transaction-&gt;merkleHash, 32); char *txScriptSig = bin2hex(transaction-&gt;scriptSig, scriptSig_len); char *pubScriptSig = bin2hex(transaction-&gt;pubkeyScript, pubkeyScript_len); printf(&quot;\nCoinbase: %s\n\nPubkeyScript: %s\n\nMerkle Hash: %s\nByteswapped: %s\n&quot;, txScriptSig, pubScriptSig, merkleHash, merkleHashSwapped); //if(generateBlock) { printf(&quot;Generating block...\n&quot;); if (!unixtime) { unixtime = time(NULL); } unsigned char block_header[80], block_hash1[32], block_hash2[32]; uint32_t blockversion = 1; memcpy(block_header, &amp;blockversion, 4); memset(block_header + 4, 0, 32); byteswap(transaction-&gt;merkleHash, 32); // We swapped it before, so do it again now. memcpy(block_header + 36, transaction-&gt;merkleHash, 32); memcpy(block_header + 68, &amp;unixtime, 4); memcpy(block_header + 72, &amp;nBits, 4); memcpy(block_header + 76, &amp;startNonce, 4); uint32_t *pNonce = (uint32_t *)(block_header + 76); uint32_t *pUnixtime = (uint32_t *)(block_header + 68); unsigned int counter = 0, start = time(NULL); while (1) { SHA256(block_header, 80, block_hash1); SHA256(block_hash1, 32, block_hash2); unsigned int check = *((uint32_t *)(block_hash2 + 28)); // The hash is in little-endian, so we check the last 4 bytes. if (check == 0) // \x00\x00\x00\x00 { byteswap(block_hash2, 32); char *blockHash = bin2hex(block_hash2, 32); printf(&quot;\nBlock found!\nHash: %s\nNonce: %u\nUnix time: %u&quot;, blockHash, startNonce, unixtime); free(blockHash); break; } startNonce++; counter += 1; if (time(NULL) - start &gt;= 1) { printf(&quot;\r%d Hashes/s, Nonce %u\r&quot;, counter, startNonce); counter = 0; start = time(NULL); } *pNonce = startNonce; if (startNonce &gt; 4294967294LL) { //printf(&quot;\nBlock found!\nHash: %s\nNonce: %u\nUnix time: %u&quot;, blockHash, startNonce, unixtime); unixtime++; *pUnixtime = unixtime; startNonce = 0; } } } // Lots of cleanup free(merkleHash); free(merkleHashSwapped); free(txScriptSig); free(pubScriptSig); free(transaction-&gt;serializedData); free(transaction-&gt;scriptSig); free(transaction-&gt;pubkeyScript); free(transaction); getchar(); return 0; } 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/07/05/6e3695e0a4a9aafb0ab70a23c2d26659.html" />
<meta property="og:url" content="https://mlh.app/2018/07/05/6e3695e0a4a9aafb0ab70a23c2d26659.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-05T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #include &lt;inttypes.h&gt; #include &lt;ctype.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #include &lt;openssl/sha.h&gt; //Copied from Bitcoin source const uint64_t COIN = 100000000; const uint64_t CENT = 1000000; uint32_t OP_CHECKSIG = 172; // This is expressed as 0xAC bool generateBlock = false; uint32_t startNonce = 0; uint32_t unixtime = 0; typedef struct { /* Hash of Tx */ uint8_t merkleHash[32]; /* Tx serialization before hashing */ uint8_t *serializedData; /* Tx version */ uint32_t version; /* Input */ uint8_t numInputs; // Program assumes one input uint8_t prevOutput[32]; uint32_t prevoutIndex; uint8_t *scriptSig;// nBitsLen + nBits + 0x01 + 0x04 + ScriptSig_len + timestamp uint32_t sequence; /* Output */ uint8_t numOutputs; // Program assumes one output uint64_t outValue; uint8_t *pubkeyScript;//0x41 + pubkey + OP_CHECKSIG /* Final */ uint32_t locktime; } Transaction; // Got this off the internet. Am not sure if it can fail in some circumstances void byteswap(uint8_t *buf, int length) { int i; uint8_t temp; for (i = 0; i &lt; length / 2; i++) { temp = buf[i]; buf[i] = buf[length - i - 1]; buf[length - i - 1] = temp; } } // Following two functions are borrowed from cgminer. char *bin2hex(const unsigned char *p, size_t len) { char *s = (char*)malloc((len * 2) + 1); unsigned int i; if (!s) return NULL; for (i = 0; i &lt; len; i++) sprintf_s(s + (i * 2), 3, &quot;%02x&quot;, (unsigned int)p[i]); return s; } size_t hex2bin(unsigned char *p, const char *hexstr, size_t len) { int ret = 0; size_t retlen = len; while (*hexstr &amp;&amp; len) { char hex_byte[4]; unsigned int v; if (!hexstr[1]) { return ret; } memset(hex_byte, 0, 4); hex_byte[0] = hexstr[0]; hex_byte[1] = hexstr[1]; if (sscanf_s(hex_byte, &quot;%x&quot;, &amp;v) != 1) { return ret; } *p = (unsigned char)v; p++; hexstr += 2; len--; } if (len == 0 &amp;&amp; *hexstr == 0) ret = retlen; return ret; } Transaction *InitTransaction() { Transaction *transaction; transaction = (Transaction *)calloc(1, sizeof(*transaction)); if (!transaction) { return NULL; } // Set some initial data that will remain constant throughout the program transaction-&gt;version = 1; transaction-&gt;numInputs = 1; transaction-&gt;numOutputs = 1; transaction-&gt;locktime = 0; transaction-&gt;prevoutIndex = 0xFFFFFFFF; transaction-&gt;sequence = 0xFFFFFFFF; transaction-&gt;outValue = 50 * COIN; // We initialize the previous output to 0 as there is none memset(transaction-&gt;prevOutput, 0, 32); return transaction; } //运行命令：./genesisgen [PubKey] [TimeStamp] [nBits] int main(int argc, char *argv[]) { Transaction *transaction; unsigned char hash1[32], hash2[32]; char timestamp[255], pubkey[132]; uint32_t timestamp_len = 0, scriptSig_len = 0, pubkey_len = 0, pubkeyScript_len = 0; uint32_t nBits = 0; if ((argc - 1) &lt; 3) { fprintf(stderr, &quot;Usage: genesisgen [options] &lt;pubkey&gt; \\&quot;&lt;timestamp&gt;\\&quot; &lt;nBits&gt;\\n&quot;); return 0; } pubkey_len = strlen(argv[1]) / 2; // One byte is represented as two hex characters, thus we divide by two to get real length. timestamp_len = strlen(argv[2]); if (pubkey_len != 65) { fprintf(stderr, &quot;Invalid public key length! %s\\n&quot;, argv[1]); return 0; } if (timestamp_len &gt; 254 || timestamp_len &lt;= 0) { fprintf(stderr, &quot;Size of timestamp is 0 or exceeds maximum length of 254 characters!\\n&quot;); return 0; } transaction = InitTransaction(); if (!transaction) { fprintf(stderr, &quot;Could not allocate memory! Exiting...\\n&quot;); return 0; } strncpy_s(pubkey, argv[1], sizeof(pubkey)); strncpy_s(timestamp, argv[2], sizeof(timestamp)); sscanf_s(argv[3], &quot;%lu&quot;, (long unsigned int *)&amp;nBits); pubkey_len = strlen(pubkey) &gt;&gt; 1; scriptSig_len = timestamp_len; // Encode pubkey to binary and prepend pubkey size, then append the OP_CHECKSIG byte transaction-&gt;pubkeyScript = (uint8_t*)malloc((pubkey_len + 2) * sizeof(uint8_t)); pubkeyScript_len = hex2bin(transaction-&gt;pubkeyScript + 1, pubkey, pubkey_len); // No error checking, yeah. transaction-&gt;pubkeyScript[0] = 0x41; // A public key is 32 bytes X coordinate, 32 bytes Y coordinate and one byte 0x04, so 65 bytes i.e 0x41 in Hex. pubkeyScript_len += 1; transaction-&gt;pubkeyScript[pubkeyScript_len++] = OP_CHECKSIG; // Encode timestamp to binary transaction-&gt;scriptSig = (uint8_t*)malloc(scriptSig_len * sizeof(uint8_t)); uint32_t scriptSig_pos = 0; // This is basically how I believe the size of the nBits is calculated if (nBits &lt;= 255) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x01; transaction-&gt;scriptSig[scriptSig_pos++] = (uint8_t)nBits; } else if (nBits &lt;= 65535) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x02; memcpy(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, 2); scriptSig_pos += 2; } else if (nBits &lt;= 16777215) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x03; memcpy(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, 3); scriptSig_pos += 3; } else //else if(nBits &lt;= 4294967296LL) { transaction-&gt;scriptSig[scriptSig_pos++] = 0x04; memcpy(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, 4); scriptSig_pos += 4; } // Important! In the Bitcoin code there is a statement &#39;CBigNum(4)&#39; // i&#39;ve been wondering for a while what it is but // seeing as alt-coins keep it the same, we&#39;ll do it here as well // It should essentially mean PUSH 1 byte on the stack which in this case is 0x04 or just 4 transaction-&gt;scriptSig[scriptSig_pos++] = 0x01; transaction-&gt;scriptSig[scriptSig_pos++] = 0x04; transaction-&gt;scriptSig[scriptSig_pos++] = (uint8_t)scriptSig_len; scriptSig_len += scriptSig_pos; transaction-&gt;scriptSig = (uint8_t*)realloc(transaction-&gt;scriptSig, scriptSig_len * sizeof(uint8_t)); memcpy(transaction-&gt;scriptSig + scriptSig_pos, (const unsigned char *)timestamp, timestamp_len); // Here we are asuming some values will have the same size uint32_t serializedLen = 4 // tx version + 1 // number of inputs + 32 // hash of previous output + 4 // previous output&#39;s index + 1 // 1 byte for the size of scriptSig + scriptSig_len + 4 // size of sequence + 1 // number of outputs + 8 // 8 bytes for coin value + 1 // 1 byte to represent size of the pubkey Script + pubkeyScript_len + 4; // 4 bytes for lock time // Now let&#39;s serialize the data uint32_t serializedData_pos = 0; transaction-&gt;serializedData = (uint8_t*)malloc(serializedLen * sizeof(uint8_t)); memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;version, 4); serializedData_pos += 4; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;numInputs, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;prevOutput, 32); serializedData_pos += 32; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;prevoutIndex, 4); serializedData_pos += 4; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;scriptSig_len, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;scriptSig, scriptSig_len); serializedData_pos += scriptSig_len; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;sequence, 4); serializedData_pos += 4; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;numOutputs, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;outValue, 8); serializedData_pos += 8; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;pubkeyScript_len, 1); serializedData_pos += 1; memcpy(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;pubkeyScript, pubkeyScript_len); serializedData_pos += pubkeyScript_len; memcpy(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;locktime, 4); serializedData_pos += 4; // Now that the data is serialized // we hash it with SHA256 and then hash that result to get merkle hash SHA256(transaction-&gt;serializedData, serializedLen, hash1); SHA256(hash1, 32, hash2); // This copy isn&#39;t necessary imo, but here for clarity memcpy(transaction-&gt;merkleHash, hash2, 32); char *merkleHash = bin2hex(transaction-&gt;merkleHash, 32); byteswap(transaction-&gt;merkleHash, 32); char *merkleHashSwapped = bin2hex(transaction-&gt;merkleHash, 32); char *txScriptSig = bin2hex(transaction-&gt;scriptSig, scriptSig_len); char *pubScriptSig = bin2hex(transaction-&gt;pubkeyScript, pubkeyScript_len); printf(&quot;\\nCoinbase: %s\\n\\nPubkeyScript: %s\\n\\nMerkle Hash: %s\\nByteswapped: %s\\n&quot;, txScriptSig, pubScriptSig, merkleHash, merkleHashSwapped); //if(generateBlock) { printf(&quot;Generating block...\\n&quot;); if (!unixtime) { unixtime = time(NULL); } unsigned char block_header[80], block_hash1[32], block_hash2[32]; uint32_t blockversion = 1; memcpy(block_header, &amp;blockversion, 4); memset(block_header + 4, 0, 32); byteswap(transaction-&gt;merkleHash, 32); // We swapped it before, so do it again now. memcpy(block_header + 36, transaction-&gt;merkleHash, 32); memcpy(block_header + 68, &amp;unixtime, 4); memcpy(block_header + 72, &amp;nBits, 4); memcpy(block_header + 76, &amp;startNonce, 4); uint32_t *pNonce = (uint32_t *)(block_header + 76); uint32_t *pUnixtime = (uint32_t *)(block_header + 68); unsigned int counter = 0, start = time(NULL); while (1) { SHA256(block_header, 80, block_hash1); SHA256(block_hash1, 32, block_hash2); unsigned int check = *((uint32_t *)(block_hash2 + 28)); // The hash is in little-endian, so we check the last 4 bytes. if (check == 0) // \\x00\\x00\\x00\\x00 { byteswap(block_hash2, 32); char *blockHash = bin2hex(block_hash2, 32); printf(&quot;\\nBlock found!\\nHash: %s\\nNonce: %u\\nUnix time: %u&quot;, blockHash, startNonce, unixtime); free(blockHash); break; } startNonce++; counter += 1; if (time(NULL) - start &gt;= 1) { printf(&quot;\\r%d Hashes/s, Nonce %u\\r&quot;, counter, startNonce); counter = 0; start = time(NULL); } *pNonce = startNonce; if (startNonce &gt; 4294967294LL) { //printf(&quot;\\nBlock found!\\nHash: %s\\nNonce: %u\\nUnix time: %u&quot;, blockHash, startNonce, unixtime); unixtime++; *pUnixtime = unixtime; startNonce = 0; } } } // Lots of cleanup free(merkleHash); free(merkleHashSwapped); free(txScriptSig); free(pubScriptSig); free(transaction-&gt;serializedData); free(transaction-&gt;scriptSig); free(transaction-&gt;pubkeyScript); free(transaction); getchar(); return 0; } 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/07/05/6e3695e0a4a9aafb0ab70a23c2d26659.html","headline":"生成比特币创世块C/C++源代码","dateModified":"2018-07-05T00:00:00+08:00","datePublished":"2018-07-05T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/07/05/6e3695e0a4a9aafb0ab70a23c2d26659.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>生成比特币创世块C/C++源代码</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <pre class="prettyprint"><code class=" hljs cpp">
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdbool.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;inttypes.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;ctype.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;time.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;openssl/sha.h&gt;</span>

<span class="hljs-comment">//Copied from Bitcoin source</span>
<span class="hljs-keyword">const</span> uint64_t COIN = <span class="hljs-number">100000000</span>;
<span class="hljs-keyword">const</span> uint64_t CENT = <span class="hljs-number">1000000</span>;

uint32_t OP_CHECKSIG = <span class="hljs-number">172</span>; <span class="hljs-comment">// This is expressed as 0xAC</span>
<span class="hljs-keyword">bool</span> generateBlock = <span class="hljs-keyword">false</span>;
uint32_t startNonce = <span class="hljs-number">0</span>;
uint32_t unixtime = <span class="hljs-number">0</span>;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">/* Hash of Tx */</span>
    uint8_t merkleHash[<span class="hljs-number">32</span>];

    <span class="hljs-comment">/* Tx serialization before hashing */</span>
    uint8_t *serializedData;

    <span class="hljs-comment">/* Tx version */</span>
    uint32_t version;

    <span class="hljs-comment">/* Input */</span>
    uint8_t numInputs; <span class="hljs-comment">// Program assumes one input</span>
    uint8_t prevOutput[<span class="hljs-number">32</span>];
    uint32_t prevoutIndex;
    uint8_t *scriptSig;<span class="hljs-comment">// nBitsLen + nBits + 0x01 + 0x04 + ScriptSig_len + timestamp</span>
    uint32_t sequence;

    <span class="hljs-comment">/* Output */</span>
    uint8_t numOutputs; <span class="hljs-comment">// Program assumes one output</span>
    uint64_t outValue;
    uint8_t *pubkeyScript;<span class="hljs-comment">//0x41 + pubkey + OP_CHECKSIG</span>

    <span class="hljs-comment">/* Final */</span>
    uint32_t locktime;
} Transaction;

<span class="hljs-comment">// Got this off the internet. Am not sure if it can fail in some circumstances</span>
<span class="hljs-keyword">void</span> byteswap(uint8_t *buf, <span class="hljs-keyword">int</span> length)
{
    <span class="hljs-keyword">int</span> i;
    uint8_t temp;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length / <span class="hljs-number">2</span>; i++)
    {
        temp = buf[i];
        buf[i] = buf[length - i - <span class="hljs-number">1</span>];
        buf[length - i - <span class="hljs-number">1</span>] = temp;
    }
}

<span class="hljs-comment">// Following two functions are borrowed from cgminer.</span>
<span class="hljs-keyword">char</span> *bin2hex(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *p, size_t len)
{
    <span class="hljs-keyword">char</span> *s = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>((len * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i;

    <span class="hljs-keyword">if</span> (!s)
        <span class="hljs-keyword">return</span> NULL;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)
        sprintf_s(s + (i * <span class="hljs-number">2</span>), <span class="hljs-number">3</span>, <span class="hljs-string">"%02x"</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)p[i]);


    <span class="hljs-keyword">return</span> s;
}

size_t hex2bin(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *p, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *hexstr, size_t len)
{
    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
    size_t retlen = len;

    <span class="hljs-keyword">while</span> (*hexstr &amp;&amp; len) {
        <span class="hljs-keyword">char</span> hex_byte[<span class="hljs-number">4</span>];
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v;

        <span class="hljs-keyword">if</span> (!hexstr[<span class="hljs-number">1</span>]) {
            <span class="hljs-keyword">return</span> ret;
        }

        <span class="hljs-built_in">memset</span>(hex_byte, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);
        hex_byte[<span class="hljs-number">0</span>] = hexstr[<span class="hljs-number">0</span>];
        hex_byte[<span class="hljs-number">1</span>] = hexstr[<span class="hljs-number">1</span>];

        <span class="hljs-keyword">if</span> (sscanf_s(hex_byte, <span class="hljs-string">"%x"</span>, &amp;v) != <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> ret;
        }

        *p = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)v;

        p++;
        hexstr += <span class="hljs-number">2</span>;
        len--;
    }

    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span> &amp;&amp; *hexstr == <span class="hljs-number">0</span>)
        ret = retlen;

    <span class="hljs-keyword">return</span> ret;
}

Transaction *InitTransaction()
{
    Transaction *transaction;

    transaction = (Transaction *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(*transaction));
    <span class="hljs-keyword">if</span> (!transaction)
    {
        <span class="hljs-keyword">return</span> NULL;
    }

    <span class="hljs-comment">// Set some initial data that will remain constant throughout the program</span>
    transaction-&gt;version = <span class="hljs-number">1</span>;
    transaction-&gt;numInputs = <span class="hljs-number">1</span>;
    transaction-&gt;numOutputs = <span class="hljs-number">1</span>;
    transaction-&gt;locktime = <span class="hljs-number">0</span>;
    transaction-&gt;prevoutIndex = <span class="hljs-number">0xFFFFFFFF</span>;
    transaction-&gt;sequence = <span class="hljs-number">0xFFFFFFFF</span>;
    transaction-&gt;outValue = <span class="hljs-number">50</span> * COIN;

    <span class="hljs-comment">// We initialize the previous output to 0 as there is none</span>
    <span class="hljs-built_in">memset</span>(transaction-&gt;prevOutput, <span class="hljs-number">0</span>, <span class="hljs-number">32</span>);

    <span class="hljs-keyword">return</span> transaction;
}

<span class="hljs-comment">//运行命令：./genesisgen [PubKey] [TimeStamp] [nBits]</span>
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])
{
    Transaction *transaction;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> hash1[<span class="hljs-number">32</span>], hash2[<span class="hljs-number">32</span>];
    <span class="hljs-keyword">char</span> timestamp[<span class="hljs-number">255</span>], pubkey[<span class="hljs-number">132</span>];
    uint32_t timestamp_len = <span class="hljs-number">0</span>, scriptSig_len = <span class="hljs-number">0</span>, pubkey_len = <span class="hljs-number">0</span>, pubkeyScript_len = <span class="hljs-number">0</span>;
    uint32_t nBits = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> ((argc - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">3</span>)
    {
        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Usage: genesisgen [options] &lt;pubkey&gt; \"&lt;timestamp&gt;\" &lt;nBits&gt;\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    pubkey_len = <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>; <span class="hljs-comment">// One byte is represented as two hex characters, thus we divide by two to get real length.</span>
    timestamp_len = <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">2</span>]);

    <span class="hljs-keyword">if</span> (pubkey_len != <span class="hljs-number">65</span>)
    {
        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Invalid public key length! %s\n"</span>, argv[<span class="hljs-number">1</span>]);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">if</span> (timestamp_len &gt; <span class="hljs-number">254</span> || timestamp_len &lt;= <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Size of timestamp is 0 or exceeds maximum length of 254 characters!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    transaction = InitTransaction();
    <span class="hljs-keyword">if</span> (!transaction)
    {
        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Could not allocate memory! Exiting...\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    strncpy_s(pubkey, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(pubkey));
    strncpy_s(timestamp, argv[<span class="hljs-number">2</span>], <span class="hljs-keyword">sizeof</span>(timestamp));
    sscanf_s(argv[<span class="hljs-number">3</span>], <span class="hljs-string">"%lu"</span>, (<span class="hljs-keyword">long</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)&amp;nBits);

    pubkey_len = <span class="hljs-built_in">strlen</span>(pubkey) &gt;&gt; <span class="hljs-number">1</span>;
    scriptSig_len = timestamp_len;

    <span class="hljs-comment">// Encode pubkey to binary and prepend pubkey size, then append the OP_CHECKSIG byte</span>
    transaction-&gt;pubkeyScript = (uint8_t*)<span class="hljs-built_in">malloc</span>((pubkey_len + <span class="hljs-number">2</span>) * <span class="hljs-keyword">sizeof</span>(uint8_t));
    pubkeyScript_len = hex2bin(transaction-&gt;pubkeyScript + <span class="hljs-number">1</span>, pubkey, pubkey_len); <span class="hljs-comment">// No error checking, yeah.</span>
    transaction-&gt;pubkeyScript[<span class="hljs-number">0</span>] = <span class="hljs-number">0x41</span>; <span class="hljs-comment">// A public key is 32 bytes X coordinate, 32 bytes Y coordinate and one byte 0x04, so 65 bytes i.e 0x41 in Hex.</span>
    pubkeyScript_len += <span class="hljs-number">1</span>;
    transaction-&gt;pubkeyScript[pubkeyScript_len++] = OP_CHECKSIG;

    <span class="hljs-comment">// Encode timestamp to binary</span>
    transaction-&gt;scriptSig = (uint8_t*)<span class="hljs-built_in">malloc</span>(scriptSig_len * <span class="hljs-keyword">sizeof</span>(uint8_t));
    uint32_t scriptSig_pos = <span class="hljs-number">0</span>;


    <span class="hljs-comment">// This is basically how I believe the size of the nBits is calculated</span>
    <span class="hljs-keyword">if</span> (nBits &lt;= <span class="hljs-number">255</span>)
    {
        transaction-&gt;scriptSig[scriptSig_pos++] = <span class="hljs-number">0x01</span>;
        transaction-&gt;scriptSig[scriptSig_pos++] = (uint8_t)nBits;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nBits &lt;= <span class="hljs-number">65535</span>)
    {
        transaction-&gt;scriptSig[scriptSig_pos++] = <span class="hljs-number">0x02</span>;
        <span class="hljs-built_in">memcpy</span>(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, <span class="hljs-number">2</span>);
        scriptSig_pos += <span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nBits &lt;= <span class="hljs-number">16777215</span>)
    {
        transaction-&gt;scriptSig[scriptSig_pos++] = <span class="hljs-number">0x03</span>;
        <span class="hljs-built_in">memcpy</span>(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, <span class="hljs-number">3</span>);
        scriptSig_pos += <span class="hljs-number">3</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-comment">//else if(nBits &lt;= 4294967296LL)</span>
    {
        transaction-&gt;scriptSig[scriptSig_pos++] = <span class="hljs-number">0x04</span>;
        <span class="hljs-built_in">memcpy</span>(transaction-&gt;scriptSig + scriptSig_pos, &amp;nBits, <span class="hljs-number">4</span>);
        scriptSig_pos += <span class="hljs-number">4</span>;
    }

    <span class="hljs-comment">// Important! In the Bitcoin code there is a statement 'CBigNum(4)' </span>
    <span class="hljs-comment">// i've been wondering for a while what it is but</span>
    <span class="hljs-comment">// seeing as alt-coins keep it the same, we'll do it here as well</span>
    <span class="hljs-comment">// It should essentially mean PUSH 1 byte on the stack which in this case is 0x04 or just 4</span>
    transaction-&gt;scriptSig[scriptSig_pos++] = <span class="hljs-number">0x01</span>;
    transaction-&gt;scriptSig[scriptSig_pos++] = <span class="hljs-number">0x04</span>;

    transaction-&gt;scriptSig[scriptSig_pos++] = (uint8_t)scriptSig_len;

    scriptSig_len += scriptSig_pos;
    transaction-&gt;scriptSig = (uint8_t*)realloc(transaction-&gt;scriptSig, scriptSig_len * <span class="hljs-keyword">sizeof</span>(uint8_t));
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;scriptSig + scriptSig_pos, (<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)timestamp, timestamp_len);

    <span class="hljs-comment">// Here we are asuming some values will have the same size</span>
    uint32_t serializedLen =
        <span class="hljs-number">4</span>    <span class="hljs-comment">// tx version</span>
        + <span class="hljs-number">1</span>   <span class="hljs-comment">// number of inputs</span>
        + <span class="hljs-number">32</span>  <span class="hljs-comment">// hash of previous output</span>
        + <span class="hljs-number">4</span>   <span class="hljs-comment">// previous output's index</span>
        + <span class="hljs-number">1</span>   <span class="hljs-comment">// 1 byte for the size of scriptSig</span>
        + scriptSig_len
        + <span class="hljs-number">4</span>   <span class="hljs-comment">// size of sequence</span>
        + <span class="hljs-number">1</span>   <span class="hljs-comment">// number of outputs</span>
        + <span class="hljs-number">8</span>   <span class="hljs-comment">// 8 bytes for coin value</span>
        + <span class="hljs-number">1</span>   <span class="hljs-comment">// 1 byte to represent size of the pubkey Script</span>
        + pubkeyScript_len
        + <span class="hljs-number">4</span>;   <span class="hljs-comment">// 4 bytes for lock time</span>

               <span class="hljs-comment">// Now let's serialize the data</span>
    uint32_t serializedData_pos = <span class="hljs-number">0</span>;
    transaction-&gt;serializedData = (uint8_t*)<span class="hljs-built_in">malloc</span>(serializedLen * <span class="hljs-keyword">sizeof</span>(uint8_t));
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;version, <span class="hljs-number">4</span>);
    serializedData_pos += <span class="hljs-number">4</span>;
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;numInputs, <span class="hljs-number">1</span>);
    serializedData_pos += <span class="hljs-number">1</span>;
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;prevOutput, <span class="hljs-number">32</span>);
    serializedData_pos += <span class="hljs-number">32</span>;
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;prevoutIndex, <span class="hljs-number">4</span>);
    serializedData_pos += <span class="hljs-number">4</span>;
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, &amp;scriptSig_len, <span class="hljs-number">1</span>);
    serializedData_pos += <span class="hljs-number">1</span>;
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;scriptSig, scriptSig_len);
    serializedData_pos += scriptSig_len;
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;sequence, <span class="hljs-number">4</span>);
    serializedData_pos += <span class="hljs-number">4</span>;
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;numOutputs, <span class="hljs-number">1</span>);
    serializedData_pos += <span class="hljs-number">1</span>;
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;outValue, <span class="hljs-number">8</span>);
    serializedData_pos += <span class="hljs-number">8</span>;
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, &amp;pubkeyScript_len, <span class="hljs-number">1</span>);
    serializedData_pos += <span class="hljs-number">1</span>;
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, transaction-&gt;pubkeyScript, pubkeyScript_len);
    serializedData_pos += pubkeyScript_len;
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;serializedData + serializedData_pos, &amp;transaction-&gt;locktime, <span class="hljs-number">4</span>);
    serializedData_pos += <span class="hljs-number">4</span>;

    <span class="hljs-comment">// Now that the data is serialized</span>
    <span class="hljs-comment">// we hash it with SHA256 and then hash that result to get merkle hash</span>
    SHA256(transaction-&gt;serializedData, serializedLen, hash1);
    SHA256(hash1, <span class="hljs-number">32</span>, hash2);

    <span class="hljs-comment">// This copy isn't necessary imo, but here for clarity</span>
    <span class="hljs-built_in">memcpy</span>(transaction-&gt;merkleHash, hash2, <span class="hljs-number">32</span>);

    <span class="hljs-keyword">char</span> *merkleHash = bin2hex(transaction-&gt;merkleHash, <span class="hljs-number">32</span>);
    byteswap(transaction-&gt;merkleHash, <span class="hljs-number">32</span>);
    <span class="hljs-keyword">char</span> *merkleHashSwapped = bin2hex(transaction-&gt;merkleHash, <span class="hljs-number">32</span>);
    <span class="hljs-keyword">char</span> *txScriptSig = bin2hex(transaction-&gt;scriptSig, scriptSig_len);
    <span class="hljs-keyword">char</span> *pubScriptSig = bin2hex(transaction-&gt;pubkeyScript, pubkeyScript_len);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nCoinbase: %s\n\nPubkeyScript: %s\n\nMerkle Hash: %s\nByteswapped: %s\n"</span>, txScriptSig, pubScriptSig, merkleHash, merkleHashSwapped);

    <span class="hljs-comment">//if(generateBlock)</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Generating block...\n"</span>);
        <span class="hljs-keyword">if</span> (!unixtime)
        {
            unixtime = time(NULL);
        }

        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> block_header[<span class="hljs-number">80</span>], block_hash1[<span class="hljs-number">32</span>], block_hash2[<span class="hljs-number">32</span>];
        uint32_t blockversion = <span class="hljs-number">1</span>;
        <span class="hljs-built_in">memcpy</span>(block_header, &amp;blockversion, <span class="hljs-number">4</span>);
        <span class="hljs-built_in">memset</span>(block_header + <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">32</span>);
        byteswap(transaction-&gt;merkleHash, <span class="hljs-number">32</span>); <span class="hljs-comment">// We swapped it before, so do it again now.</span>
        <span class="hljs-built_in">memcpy</span>(block_header + <span class="hljs-number">36</span>, transaction-&gt;merkleHash, <span class="hljs-number">32</span>);
        <span class="hljs-built_in">memcpy</span>(block_header + <span class="hljs-number">68</span>, &amp;unixtime, <span class="hljs-number">4</span>);
        <span class="hljs-built_in">memcpy</span>(block_header + <span class="hljs-number">72</span>, &amp;nBits, <span class="hljs-number">4</span>);
        <span class="hljs-built_in">memcpy</span>(block_header + <span class="hljs-number">76</span>, &amp;startNonce, <span class="hljs-number">4</span>);

        uint32_t *pNonce = (uint32_t *)(block_header + <span class="hljs-number">76</span>);
        uint32_t *pUnixtime = (uint32_t *)(block_header + <span class="hljs-number">68</span>);
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>, start = time(NULL);
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
        {
            SHA256(block_header, <span class="hljs-number">80</span>, block_hash1);
            SHA256(block_hash1, <span class="hljs-number">32</span>, block_hash2);

            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> check = *((uint32_t *)(block_hash2 + <span class="hljs-number">28</span>)); <span class="hljs-comment">// The hash is in little-endian, so we check the last 4 bytes.</span>
            <span class="hljs-keyword">if</span> (check == <span class="hljs-number">0</span>) <span class="hljs-comment">// \x00\x00\x00\x00</span>
            {
                byteswap(block_hash2, <span class="hljs-number">32</span>);
                <span class="hljs-keyword">char</span> *blockHash = bin2hex(block_hash2, <span class="hljs-number">32</span>);
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nBlock found!\nHash: %s\nNonce: %u\nUnix time: %u"</span>, blockHash, startNonce, unixtime);
                <span class="hljs-built_in">free</span>(blockHash);
                <span class="hljs-keyword">break</span>;
            }

            startNonce++;
            counter += <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (time(NULL) - start &gt;= <span class="hljs-number">1</span>)
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r%d Hashes/s, Nonce %u\r"</span>, counter, startNonce);
                counter = <span class="hljs-number">0</span>;
                start = time(NULL);
            }
            *pNonce = startNonce;
            <span class="hljs-keyword">if</span> (startNonce &gt; <span class="hljs-number">4294967294L</span>L)
            {
                <span class="hljs-comment">//printf("\nBlock found!\nHash: %s\nNonce: %u\nUnix time: %u", blockHash, startNonce, unixtime);</span>
                unixtime++;
                *pUnixtime = unixtime;
                startNonce = <span class="hljs-number">0</span>;
            }
        }
    }

    <span class="hljs-comment">// Lots of cleanup</span>
    <span class="hljs-built_in">free</span>(merkleHash);
    <span class="hljs-built_in">free</span>(merkleHashSwapped);
    <span class="hljs-built_in">free</span>(txScriptSig);
    <span class="hljs-built_in">free</span>(pubScriptSig);
    <span class="hljs-built_in">free</span>(transaction-&gt;serializedData);
    <span class="hljs-built_in">free</span>(transaction-&gt;scriptSig);
    <span class="hljs-built_in">free</span>(transaction-&gt;pubkeyScript);
    <span class="hljs-built_in">free</span>(transaction);

    getchar();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/anda0109/article/details/80927832,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/anda0109/article/details/80927832,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
