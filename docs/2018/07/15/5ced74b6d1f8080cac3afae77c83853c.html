<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊源码分析—Ethash共识算法 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊源码分析—Ethash共识算法" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Ethereum当前和Bitcoin一样，采用基于工作量证明(Proof of Work,PoW)的共识算法来产生新的区块。与Bitcoin不同的是，Ethereum采用的共识算法可以抵御ASIC矿机对挖矿工作的垄断地位，这个算法叫做Ethash。 为什么要反ASIC PoW的的核心是Hash运算，谁的Hash运算更快，谁就更有可能挖掘出新的区块，获得更多的经济利益。在Bitcoin的发展过程中，挖矿设备经历了(CPU=&gt;GPU=&gt;ASIC)的进化过程，其中的动机就是为了更快地进行Hash运算。随着矿机门槛地提高，参与者久越来越少，这与区块链的去中心化构想背道而驰。 因此，在共识算法设计时，为了减少ASIC矿机的优势(专用并行计算)，Ethereum增加了对于内存的要求，即在进行挖矿的过程中，需要占用消耗大量的内存空间，而这是ASIC矿机不具备的(配置符合运算那能力的内存太贵了，即使配置，这也就等同于大量CPU了)。即将挖矿算法从CPU密集型(CPU bound)转化为IO密集型(I/O bound) Dagger-Hashimoto Ethash是从Dagger-Hashimoto算法改动而来的，而Dagger-Hashimoto的原型是Thaddeus Dryja提出的Hashimoto算法，它在传统Bitcoin的工作量证明的基础上增加了消耗内存的步骤。 传统的PoW的本质是不断尝试不同的nonce，计算HASH hash_output=HASH(prev_hash,merkleroot,nonce) h a s h _ o u t p u t = H A S H ( p r e v _ h a s h , m e r k l e r o o t , n o n c e ) 如果计算结果满足 hash_output&lt;target h a s h _ o u t p u t &lt; t a r g e t ，则说明计算的 nonce是有效的 而对于Hashimoto，HASH运算仅仅是第一步，其算法如下: nonce:　64-bits.正在尝试的nonce值 get_txid(T):历史区块上的交易T的hash total_transactions:　历史上的所有交易的个数 hash_output_A = HASH(prev_hash,merkle_root,nonce) for i = 0 to 63 do shifted_A = hash_output_A &gt;&gt; i transaction = shifted_A mod total_transactions txid[i] = get_txit(transaction) &lt;&lt; i end of txid_mix = txid[0]^txid[1]...txid[63] final_output = txid_mix ^ （nonce&lt;&lt;192) 可以看出，在进行了HASH运算后，还需要进行64轮的混淆(mix)运算，而混淆的源数据是区块链上的历史交易，矿工节点在运行此算法时，需要访问内存中的历史交易信息(这是内存消耗的来源)，最终只有当　 final_output&lt;target f i n a l _ o u t p u t &lt; t a r g e t 　时，才算是找到了有效的nonce Dagger-Hashimoto相比于Hashimoto，不同点在于混淆运算的数据源不是区块链上的历史交易，而是以特定算法生成的约1GB大小的数据集合(dataset)，矿工节点在挖矿时，需要将这1GB数据全部载入内存。 Ethash算法概要 矿工挖矿不再是仅仅将找到的nonce填入区块头，还需要填入一项MixDigest，这是在挖矿过程中计算出来的，它可以作为矿工的确在进行消耗内存挖矿工作量的证明。验证者在验证区块时也会用到这一项。 先计算出约16MB大小的cache，约1GB的dataset由这约16MB的cache按特定算法生成，dataset中每一项数据都由cache中的256项数据参与生成，cache中的这256项数据可以看做是dataset中数据的parent。只所以是约，是因为其真正的大小是比16MB和1GB稍微小一点(为了好描述，以下将省略约) cache和dataset的内容并非不变，它每隔一个epoch(30000个区块)就需要重新计算 cache和dataset的大小并非一成不变，16MB和1GB只是初始值，这个大小在每年会增大73%,这是为了抵消掉摩尔定律下硬件性能的提升，即使硬件性能提升了，那么最终计算所代表的工作量不会变化很多。结合上一条，那么其实每经过30000个区块，cache和dataset就会增大一点，并且重新计算 全节点(比如矿工)会存储整个 cache和dataset，而轻客户端只需要存储 cache。挖矿(seal)时需要dataset在内存中便于随时存取，而验证(verify)时，只需要有cache就行，需要的dataset临时计算就行。 Ethash源码解析 dataset生成 dataset通过generate()方法生成，首先是生成cache，再从cache生成dataset 挖矿(Seal) 在挖矿与共识中提到了，共识算法通过实现Engine.Seal接口，来实现挖矿,Ethash算法也不例外。 其顶层流程如下: Seal调用中，启动一个go routine来调用ethash.mine()进行实际的挖矿，参数中的block是待挖掘的区块(已经打包好了交易)，而nonce是一个随机值，作为挖矿过程尝试nonce的初始值。 mine()调用首先计算后续挖矿需要的一些变量。hash为区块头中除了nonce和mixdigest的Hash值，dataset为挖掘这个区块时需要的混淆数据集合(占用1GB内存),target是本区块最终Hash需要达到的目标，它与区块难度成反比 对本次尝试的nonce进行hashmotoFull()函数计算最终result(最终Hash值)和digest，如果满足target要求，则结束挖矿，否则增加nonce，再调用hashmotoFull() func hashimotoFull(dataset []uint32, hash []byte, nonce uint64) ([]byte, []byte) { lookup := func(index uint32) []uint32 { offset := index * hashWords return dataset[offset : offset+hashWords] } return hashimoto(hash, nonce, uint64(len(dataset))*4, lookup) } hashmotoFull()是运算的核心，内部调用hashmoto()，第三个参数为dataset的大小（即1GB）,第四个参数是一个lookup函数，它接收index参数，返回dataset中64字节的数据。 func hashimoto(hash []byte, nonce uint64, size uint64, lookup func(index uint32) []uint32) ([]byte, []byte) { // 将dataset划分为2维矩阵，每行mixBytes=128字节，共1073739904/128=8388593行 rows := uint32(size / mixBytes) //　将hash与待尝试的nonce组合成64字节的seed seed := make([]byte, 40) copy(seed, hash) binary.LittleEndian.PutUint64(seed[32:], nonce) seed = crypto.Keccak512(seed) seedHead := binary.LittleEndian.Uint32(seed) // 将64字节的seed转化为32个uint32的mix数组(前后16个uint32内容相同) mix := make([]uint32, mixBytes/4) for i := 0; i &lt; len(mix); i++ { mix[i] = binary.LittleEndian.Uint32(seed[i%16*4:]) } temp := make([]uint32, len(mix)) //　进行总共loopAccesses=64轮的混淆计算，每次计算会去dataset里查询数据 for i := 0; i &lt; loopAccesses; i++ { parent := fnv(uint32(i)^seedHead, mix[i%len(mix)]) % rows for j := uint32(0); j &lt; mixBytes/hashBytes; j++ { copy(temp[j*hashWords:], lookup(2*parent+j)) } fnvHash(mix, temp) } // 压缩mix：将32个uint32的mix压缩成8个uint32 for i := 0; i &lt; len(mix); i += 4 { mix[i/4] = fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3]) } mix = mix[:len(mix)/4] // 用8个uint32的mix填充32字节的digest digest := make([]byte, common.HashLength) for i, val := range mix { binary.LittleEndian.PutUint32(digest[i*4:], val) } //　对seed+digest计算hash，得到最终的hash值 return digest, crypto.Keccak256(append(seed, digest...)) } 验证(Verify) 验证时VerifySeal()调用hashimotoLight()，Light表明验证者不需要完整的dataset，它需要用到的dataset中的数据都是临时从cache中计算。 func hashimotoLight(size uint64, cache []uint32, hash []byte, nonce uint64) ([]byte, []byte) { keccak512 := makeHasher(sha3.NewKeccak512()) //lookup函数和hashimotoFull中的不同，它调用generateDatasetItem从cache中临时计算 lookup := func(index uint32) []uint32 { rawData := generateDatasetItem(cache, index, keccak512) // return 64 byte data := make([]uint32, len(rawData)/4) // 16 个　uint32 for i := 0; i &lt; len(data); i++ { data[i] = binary.LittleEndian.Uint32(rawData[i*4:]) } return data } return hashimoto(hash, nonce, size, lookup) } 除了lookup函数不同，其余部分hashimotoFull完全一样 总结 Ethash相比与Bitcoin的挖矿算法，增加了对内存使用的要求，要求矿工提供在挖矿过程中使用了大量内存的工作量证明,最终达到抵抗ASIC矿机的目的。 参考资料 1 Ethash-Design-Rationale 2 what-actually-is-a-dag 3 why-dagger-hashimoto-for-ethereum 阅读更多" />
<meta property="og:description" content="Ethereum当前和Bitcoin一样，采用基于工作量证明(Proof of Work,PoW)的共识算法来产生新的区块。与Bitcoin不同的是，Ethereum采用的共识算法可以抵御ASIC矿机对挖矿工作的垄断地位，这个算法叫做Ethash。 为什么要反ASIC PoW的的核心是Hash运算，谁的Hash运算更快，谁就更有可能挖掘出新的区块，获得更多的经济利益。在Bitcoin的发展过程中，挖矿设备经历了(CPU=&gt;GPU=&gt;ASIC)的进化过程，其中的动机就是为了更快地进行Hash运算。随着矿机门槛地提高，参与者久越来越少，这与区块链的去中心化构想背道而驰。 因此，在共识算法设计时，为了减少ASIC矿机的优势(专用并行计算)，Ethereum增加了对于内存的要求，即在进行挖矿的过程中，需要占用消耗大量的内存空间，而这是ASIC矿机不具备的(配置符合运算那能力的内存太贵了，即使配置，这也就等同于大量CPU了)。即将挖矿算法从CPU密集型(CPU bound)转化为IO密集型(I/O bound) Dagger-Hashimoto Ethash是从Dagger-Hashimoto算法改动而来的，而Dagger-Hashimoto的原型是Thaddeus Dryja提出的Hashimoto算法，它在传统Bitcoin的工作量证明的基础上增加了消耗内存的步骤。 传统的PoW的本质是不断尝试不同的nonce，计算HASH hash_output=HASH(prev_hash,merkleroot,nonce) h a s h _ o u t p u t = H A S H ( p r e v _ h a s h , m e r k l e r o o t , n o n c e ) 如果计算结果满足 hash_output&lt;target h a s h _ o u t p u t &lt; t a r g e t ，则说明计算的 nonce是有效的 而对于Hashimoto，HASH运算仅仅是第一步，其算法如下: nonce:　64-bits.正在尝试的nonce值 get_txid(T):历史区块上的交易T的hash total_transactions:　历史上的所有交易的个数 hash_output_A = HASH(prev_hash,merkle_root,nonce) for i = 0 to 63 do shifted_A = hash_output_A &gt;&gt; i transaction = shifted_A mod total_transactions txid[i] = get_txit(transaction) &lt;&lt; i end of txid_mix = txid[0]^txid[1]...txid[63] final_output = txid_mix ^ （nonce&lt;&lt;192) 可以看出，在进行了HASH运算后，还需要进行64轮的混淆(mix)运算，而混淆的源数据是区块链上的历史交易，矿工节点在运行此算法时，需要访问内存中的历史交易信息(这是内存消耗的来源)，最终只有当　 final_output&lt;target f i n a l _ o u t p u t &lt; t a r g e t 　时，才算是找到了有效的nonce Dagger-Hashimoto相比于Hashimoto，不同点在于混淆运算的数据源不是区块链上的历史交易，而是以特定算法生成的约1GB大小的数据集合(dataset)，矿工节点在挖矿时，需要将这1GB数据全部载入内存。 Ethash算法概要 矿工挖矿不再是仅仅将找到的nonce填入区块头，还需要填入一项MixDigest，这是在挖矿过程中计算出来的，它可以作为矿工的确在进行消耗内存挖矿工作量的证明。验证者在验证区块时也会用到这一项。 先计算出约16MB大小的cache，约1GB的dataset由这约16MB的cache按特定算法生成，dataset中每一项数据都由cache中的256项数据参与生成，cache中的这256项数据可以看做是dataset中数据的parent。只所以是约，是因为其真正的大小是比16MB和1GB稍微小一点(为了好描述，以下将省略约) cache和dataset的内容并非不变，它每隔一个epoch(30000个区块)就需要重新计算 cache和dataset的大小并非一成不变，16MB和1GB只是初始值，这个大小在每年会增大73%,这是为了抵消掉摩尔定律下硬件性能的提升，即使硬件性能提升了，那么最终计算所代表的工作量不会变化很多。结合上一条，那么其实每经过30000个区块，cache和dataset就会增大一点，并且重新计算 全节点(比如矿工)会存储整个 cache和dataset，而轻客户端只需要存储 cache。挖矿(seal)时需要dataset在内存中便于随时存取，而验证(verify)时，只需要有cache就行，需要的dataset临时计算就行。 Ethash源码解析 dataset生成 dataset通过generate()方法生成，首先是生成cache，再从cache生成dataset 挖矿(Seal) 在挖矿与共识中提到了，共识算法通过实现Engine.Seal接口，来实现挖矿,Ethash算法也不例外。 其顶层流程如下: Seal调用中，启动一个go routine来调用ethash.mine()进行实际的挖矿，参数中的block是待挖掘的区块(已经打包好了交易)，而nonce是一个随机值，作为挖矿过程尝试nonce的初始值。 mine()调用首先计算后续挖矿需要的一些变量。hash为区块头中除了nonce和mixdigest的Hash值，dataset为挖掘这个区块时需要的混淆数据集合(占用1GB内存),target是本区块最终Hash需要达到的目标，它与区块难度成反比 对本次尝试的nonce进行hashmotoFull()函数计算最终result(最终Hash值)和digest，如果满足target要求，则结束挖矿，否则增加nonce，再调用hashmotoFull() func hashimotoFull(dataset []uint32, hash []byte, nonce uint64) ([]byte, []byte) { lookup := func(index uint32) []uint32 { offset := index * hashWords return dataset[offset : offset+hashWords] } return hashimoto(hash, nonce, uint64(len(dataset))*4, lookup) } hashmotoFull()是运算的核心，内部调用hashmoto()，第三个参数为dataset的大小（即1GB）,第四个参数是一个lookup函数，它接收index参数，返回dataset中64字节的数据。 func hashimoto(hash []byte, nonce uint64, size uint64, lookup func(index uint32) []uint32) ([]byte, []byte) { // 将dataset划分为2维矩阵，每行mixBytes=128字节，共1073739904/128=8388593行 rows := uint32(size / mixBytes) //　将hash与待尝试的nonce组合成64字节的seed seed := make([]byte, 40) copy(seed, hash) binary.LittleEndian.PutUint64(seed[32:], nonce) seed = crypto.Keccak512(seed) seedHead := binary.LittleEndian.Uint32(seed) // 将64字节的seed转化为32个uint32的mix数组(前后16个uint32内容相同) mix := make([]uint32, mixBytes/4) for i := 0; i &lt; len(mix); i++ { mix[i] = binary.LittleEndian.Uint32(seed[i%16*4:]) } temp := make([]uint32, len(mix)) //　进行总共loopAccesses=64轮的混淆计算，每次计算会去dataset里查询数据 for i := 0; i &lt; loopAccesses; i++ { parent := fnv(uint32(i)^seedHead, mix[i%len(mix)]) % rows for j := uint32(0); j &lt; mixBytes/hashBytes; j++ { copy(temp[j*hashWords:], lookup(2*parent+j)) } fnvHash(mix, temp) } // 压缩mix：将32个uint32的mix压缩成8个uint32 for i := 0; i &lt; len(mix); i += 4 { mix[i/4] = fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3]) } mix = mix[:len(mix)/4] // 用8个uint32的mix填充32字节的digest digest := make([]byte, common.HashLength) for i, val := range mix { binary.LittleEndian.PutUint32(digest[i*4:], val) } //　对seed+digest计算hash，得到最终的hash值 return digest, crypto.Keccak256(append(seed, digest...)) } 验证(Verify) 验证时VerifySeal()调用hashimotoLight()，Light表明验证者不需要完整的dataset，它需要用到的dataset中的数据都是临时从cache中计算。 func hashimotoLight(size uint64, cache []uint32, hash []byte, nonce uint64) ([]byte, []byte) { keccak512 := makeHasher(sha3.NewKeccak512()) //lookup函数和hashimotoFull中的不同，它调用generateDatasetItem从cache中临时计算 lookup := func(index uint32) []uint32 { rawData := generateDatasetItem(cache, index, keccak512) // return 64 byte data := make([]uint32, len(rawData)/4) // 16 个　uint32 for i := 0; i &lt; len(data); i++ { data[i] = binary.LittleEndian.Uint32(rawData[i*4:]) } return data } return hashimoto(hash, nonce, size, lookup) } 除了lookup函数不同，其余部分hashimotoFull完全一样 总结 Ethash相比与Bitcoin的挖矿算法，增加了对内存使用的要求，要求矿工提供在挖矿过程中使用了大量内存的工作量证明,最终达到抵抗ASIC矿机的目的。 参考资料 1 Ethash-Design-Rationale 2 what-actually-is-a-dag 3 why-dagger-hashimoto-for-ethereum 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-15T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Ethereum当前和Bitcoin一样，采用基于工作量证明(Proof of Work,PoW)的共识算法来产生新的区块。与Bitcoin不同的是，Ethereum采用的共识算法可以抵御ASIC矿机对挖矿工作的垄断地位，这个算法叫做Ethash。 为什么要反ASIC PoW的的核心是Hash运算，谁的Hash运算更快，谁就更有可能挖掘出新的区块，获得更多的经济利益。在Bitcoin的发展过程中，挖矿设备经历了(CPU=&gt;GPU=&gt;ASIC)的进化过程，其中的动机就是为了更快地进行Hash运算。随着矿机门槛地提高，参与者久越来越少，这与区块链的去中心化构想背道而驰。 因此，在共识算法设计时，为了减少ASIC矿机的优势(专用并行计算)，Ethereum增加了对于内存的要求，即在进行挖矿的过程中，需要占用消耗大量的内存空间，而这是ASIC矿机不具备的(配置符合运算那能力的内存太贵了，即使配置，这也就等同于大量CPU了)。即将挖矿算法从CPU密集型(CPU bound)转化为IO密集型(I/O bound) Dagger-Hashimoto Ethash是从Dagger-Hashimoto算法改动而来的，而Dagger-Hashimoto的原型是Thaddeus Dryja提出的Hashimoto算法，它在传统Bitcoin的工作量证明的基础上增加了消耗内存的步骤。 传统的PoW的本质是不断尝试不同的nonce，计算HASH hash_output=HASH(prev_hash,merkleroot,nonce) h a s h _ o u t p u t = H A S H ( p r e v _ h a s h , m e r k l e r o o t , n o n c e ) 如果计算结果满足 hash_output&lt;target h a s h _ o u t p u t &lt; t a r g e t ，则说明计算的 nonce是有效的 而对于Hashimoto，HASH运算仅仅是第一步，其算法如下: nonce:　64-bits.正在尝试的nonce值 get_txid(T):历史区块上的交易T的hash total_transactions:　历史上的所有交易的个数 hash_output_A = HASH(prev_hash,merkle_root,nonce) for i = 0 to 63 do shifted_A = hash_output_A &gt;&gt; i transaction = shifted_A mod total_transactions txid[i] = get_txit(transaction) &lt;&lt; i end of txid_mix = txid[0]^txid[1]...txid[63] final_output = txid_mix ^ （nonce&lt;&lt;192) 可以看出，在进行了HASH运算后，还需要进行64轮的混淆(mix)运算，而混淆的源数据是区块链上的历史交易，矿工节点在运行此算法时，需要访问内存中的历史交易信息(这是内存消耗的来源)，最终只有当　 final_output&lt;target f i n a l _ o u t p u t &lt; t a r g e t 　时，才算是找到了有效的nonce Dagger-Hashimoto相比于Hashimoto，不同点在于混淆运算的数据源不是区块链上的历史交易，而是以特定算法生成的约1GB大小的数据集合(dataset)，矿工节点在挖矿时，需要将这1GB数据全部载入内存。 Ethash算法概要 矿工挖矿不再是仅仅将找到的nonce填入区块头，还需要填入一项MixDigest，这是在挖矿过程中计算出来的，它可以作为矿工的确在进行消耗内存挖矿工作量的证明。验证者在验证区块时也会用到这一项。 先计算出约16MB大小的cache，约1GB的dataset由这约16MB的cache按特定算法生成，dataset中每一项数据都由cache中的256项数据参与生成，cache中的这256项数据可以看做是dataset中数据的parent。只所以是约，是因为其真正的大小是比16MB和1GB稍微小一点(为了好描述，以下将省略约) cache和dataset的内容并非不变，它每隔一个epoch(30000个区块)就需要重新计算 cache和dataset的大小并非一成不变，16MB和1GB只是初始值，这个大小在每年会增大73%,这是为了抵消掉摩尔定律下硬件性能的提升，即使硬件性能提升了，那么最终计算所代表的工作量不会变化很多。结合上一条，那么其实每经过30000个区块，cache和dataset就会增大一点，并且重新计算 全节点(比如矿工)会存储整个 cache和dataset，而轻客户端只需要存储 cache。挖矿(seal)时需要dataset在内存中便于随时存取，而验证(verify)时，只需要有cache就行，需要的dataset临时计算就行。 Ethash源码解析 dataset生成 dataset通过generate()方法生成，首先是生成cache，再从cache生成dataset 挖矿(Seal) 在挖矿与共识中提到了，共识算法通过实现Engine.Seal接口，来实现挖矿,Ethash算法也不例外。 其顶层流程如下: Seal调用中，启动一个go routine来调用ethash.mine()进行实际的挖矿，参数中的block是待挖掘的区块(已经打包好了交易)，而nonce是一个随机值，作为挖矿过程尝试nonce的初始值。 mine()调用首先计算后续挖矿需要的一些变量。hash为区块头中除了nonce和mixdigest的Hash值，dataset为挖掘这个区块时需要的混淆数据集合(占用1GB内存),target是本区块最终Hash需要达到的目标，它与区块难度成反比 对本次尝试的nonce进行hashmotoFull()函数计算最终result(最终Hash值)和digest，如果满足target要求，则结束挖矿，否则增加nonce，再调用hashmotoFull() func hashimotoFull(dataset []uint32, hash []byte, nonce uint64) ([]byte, []byte) { lookup := func(index uint32) []uint32 { offset := index * hashWords return dataset[offset : offset+hashWords] } return hashimoto(hash, nonce, uint64(len(dataset))*4, lookup) } hashmotoFull()是运算的核心，内部调用hashmoto()，第三个参数为dataset的大小（即1GB）,第四个参数是一个lookup函数，它接收index参数，返回dataset中64字节的数据。 func hashimoto(hash []byte, nonce uint64, size uint64, lookup func(index uint32) []uint32) ([]byte, []byte) { // 将dataset划分为2维矩阵，每行mixBytes=128字节，共1073739904/128=8388593行 rows := uint32(size / mixBytes) //　将hash与待尝试的nonce组合成64字节的seed seed := make([]byte, 40) copy(seed, hash) binary.LittleEndian.PutUint64(seed[32:], nonce) seed = crypto.Keccak512(seed) seedHead := binary.LittleEndian.Uint32(seed) // 将64字节的seed转化为32个uint32的mix数组(前后16个uint32内容相同) mix := make([]uint32, mixBytes/4) for i := 0; i &lt; len(mix); i++ { mix[i] = binary.LittleEndian.Uint32(seed[i%16*4:]) } temp := make([]uint32, len(mix)) //　进行总共loopAccesses=64轮的混淆计算，每次计算会去dataset里查询数据 for i := 0; i &lt; loopAccesses; i++ { parent := fnv(uint32(i)^seedHead, mix[i%len(mix)]) % rows for j := uint32(0); j &lt; mixBytes/hashBytes; j++ { copy(temp[j*hashWords:], lookup(2*parent+j)) } fnvHash(mix, temp) } // 压缩mix：将32个uint32的mix压缩成8个uint32 for i := 0; i &lt; len(mix); i += 4 { mix[i/4] = fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3]) } mix = mix[:len(mix)/4] // 用8个uint32的mix填充32字节的digest digest := make([]byte, common.HashLength) for i, val := range mix { binary.LittleEndian.PutUint32(digest[i*4:], val) } //　对seed+digest计算hash，得到最终的hash值 return digest, crypto.Keccak256(append(seed, digest...)) } 验证(Verify) 验证时VerifySeal()调用hashimotoLight()，Light表明验证者不需要完整的dataset，它需要用到的dataset中的数据都是临时从cache中计算。 func hashimotoLight(size uint64, cache []uint32, hash []byte, nonce uint64) ([]byte, []byte) { keccak512 := makeHasher(sha3.NewKeccak512()) //lookup函数和hashimotoFull中的不同，它调用generateDatasetItem从cache中临时计算 lookup := func(index uint32) []uint32 { rawData := generateDatasetItem(cache, index, keccak512) // return 64 byte data := make([]uint32, len(rawData)/4) // 16 个　uint32 for i := 0; i &lt; len(data); i++ { data[i] = binary.LittleEndian.Uint32(rawData[i*4:]) } return data } return hashimoto(hash, nonce, size, lookup) } 除了lookup函数不同，其余部分hashimotoFull完全一样 总结 Ethash相比与Bitcoin的挖矿算法，增加了对内存使用的要求，要求矿工提供在挖矿过程中使用了大量内存的工作量证明,最终达到抵抗ASIC矿机的目的。 参考资料 1 Ethash-Design-Rationale 2 what-actually-is-a-dag 3 why-dagger-hashimoto-for-ethereum 阅读更多","@type":"BlogPosting","url":"/2018/07/15/5ced74b6d1f8080cac3afae77c83853c.html","headline":"以太坊源码分析—Ethash共识算法","dateModified":"2018-07-15T00:00:00+08:00","datePublished":"2018-07-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/07/15/5ced74b6d1f8080cac3afae77c83853c.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊源码分析—Ethash共识算法</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p>Ethereum当前和Bitcoin一样，采用基于工作量证明(Proof of Work,PoW)的共识算法来产生新的区块。与Bitcoin不同的是，Ethereum采用的共识算法可以抵御ASIC矿机对挖矿工作的垄断地位，这个算法叫做<code>Ethash</code>。</p> 
  <h4 id="为什么要反asic">为什么要反ASIC</h4> 
  <p>PoW的的核心是Hash运算，谁的Hash运算更快，谁就更有可能挖掘出新的区块，获得更多的经济利益。在Bitcoin的发展过程中，挖矿设备经历了(CPU=&gt;GPU=&gt;ASIC)的进化过程，其中的动机就是为了更快地进行Hash运算。随着矿机门槛地提高，参与者久越来越少，这与区块链的<strong>去中心化</strong>构想背道而驰。 <br> 因此，在共识算法设计时，为了减少ASIC矿机的优势(专用并行计算)，Ethereum增加了对于内存的要求，即在进行挖矿的过程中，需要占用消耗大量的内存空间，而这是ASIC矿机不具备的(配置符合运算那能力的内存太贵了，即使配置，这也就等同于大量CPU了)。即将挖矿算法从CPU密集型(CPU bound)转化为IO密集型(I/O bound)</p> 
  <h4 id="dagger-hashimoto">Dagger-Hashimoto</h4> 
  <p><code>Ethash</code>是从<code>Dagger-Hashimoto</code>算法改动而来的，而<code>Dagger-Hashimoto</code>的原型是Thaddeus Dryja提出的<a href="http://diyhpl.us/~bryan/papers2/bitcoin/meh/hashimoto.pdf" rel="nofollow">Hashimoto算法</a>，它在传统Bitcoin的工作量证明的基础上增加了消耗内存的步骤。</p> 
  <p>传统的PoW的本质是不断尝试不同的<code>nonce</code>，计算HASH <br> <span class="MathJax_Preview" style="color: inherit; display: none;"></span></p>
  <div class="MathJax_Display" style="text-align: center;">
   <span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi mathvariant=&quot;normal&quot;>&amp;#x005F;</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>=</mo><mi>H</mi><mi>A</mi><mi>S</mi><mi>H</mi><mo stretchy=&quot;false&quot;>(</mo><mi>p</mi><mi>r</mi><mi>e</mi><mi>v</mi><mi mathvariant=&quot;normal&quot;>&amp;#x005F;</mi><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo>,</mo><mi>m</mi><mi>e</mi><mi>r</mi><mi>k</mi><mi>l</mi><msub><mi>e</mi><mi>r</mi></msub><mi>o</mi><mi>o</mi><mi>t</mi><mo>,</mo><mi>n</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-1" style="width: 27.887em; display: inline-block;"><span style="display: inline-block; position: relative; width: 21.445em; height: 0px; font-size: 130%;"><span style="position: absolute; clip: rect(1.685em, 1021.4em, 2.839em, -999.998em); top: -2.498em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: STIXGeneral; font-style: italic;">h</span><span class="mi" id="MathJax-Span-4" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-5" style="font-family: STIXGeneral; font-style: italic;">s</span><span class="mi" id="MathJax-Span-6" style="font-family: STIXGeneral; font-style: italic;">h</span><span class="mi" id="MathJax-Span-7" style="font-family: STIXGeneral;">_</span><span class="mi" id="MathJax-Span-8" style="font-family: STIXGeneral; font-style: italic;">o</span><span class="mi" id="MathJax-Span-9" style="font-family: STIXGeneral; font-style: italic;">u</span><span class="mi" id="MathJax-Span-10" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-11" style="font-family: STIXGeneral; font-style: italic;">p</span><span class="mi" id="MathJax-Span-12" style="font-family: STIXGeneral; font-style: italic;">u</span><span class="mi" id="MathJax-Span-13" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mo" id="MathJax-Span-14" style="font-family: STIXGeneral; padding-left: 0.339em;">=</span><span class="mi" id="MathJax-Span-15" style="font-family: STIXGeneral; font-style: italic; padding-left: 0.339em;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.05em;"></span></span><span class="mi" id="MathJax-Span-16" style="font-family: STIXGeneral; font-style: italic;">A</span><span class="mi" id="MathJax-Span-17" style="font-family: STIXGeneral; font-style: italic;">S<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-18" style="font-family: STIXGeneral; font-style: italic;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.05em;"></span></span><span class="mo" id="MathJax-Span-19" style="font-family: STIXGeneral;">(</span><span class="mi" id="MathJax-Span-20" style="font-family: STIXGeneral; font-style: italic;">p</span><span class="mi" id="MathJax-Span-21" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-22" style="font-family: STIXGeneral; font-style: italic;">e</span><span class="mi" id="MathJax-Span-23" style="font-family: STIXGeneral; font-style: italic;">v</span><span class="mi" id="MathJax-Span-24" style="font-family: STIXGeneral;">_</span><span class="mi" id="MathJax-Span-25" style="font-family: STIXGeneral; font-style: italic;">h</span><span class="mi" id="MathJax-Span-26" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-27" style="font-family: STIXGeneral; font-style: italic;">s</span><span class="mi" id="MathJax-Span-28" style="font-family: STIXGeneral; font-style: italic;">h</span><span class="mo" id="MathJax-Span-29" style="font-family: STIXGeneral;">,</span><span class="mi" id="MathJax-Span-30" style="font-family: STIXGeneral; font-style: italic; padding-left: 0.195em;">m</span><span class="mi" id="MathJax-Span-31" style="font-family: STIXGeneral; font-style: italic;">e</span><span class="mi" id="MathJax-Span-32" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-33" style="font-family: STIXGeneral; font-style: italic;">k<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-34" style="font-family: STIXGeneral; font-style: italic;">l<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="msubsup" id="MathJax-Span-35"><span style="display: inline-block; position: relative; width: 0.82em; height: 0px;"><span style="position: absolute; clip: rect(3.416em, 1000.43em, 4.137em, -999.998em); top: -3.988em; left: 0em;"><span class="mi" id="MathJax-Span-36" style="font-family: STIXGeneral; font-style: italic;">e</span><span style="display: inline-block; width: 0px; height: 3.993em;"></span></span><span style="position: absolute; top: -3.844em; left: 0.435em;"><span class="mi" id="MathJax-Span-37" style="font-size: 70.7%; font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span style="display: inline-block; width: 0px; height: 3.993em;"></span></span></span></span><span class="mi" id="MathJax-Span-38" style="font-family: STIXGeneral; font-style: italic;">o</span><span class="mi" id="MathJax-Span-39" style="font-family: STIXGeneral; font-style: italic;">o</span><span class="mi" id="MathJax-Span-40" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mo" id="MathJax-Span-41" style="font-family: STIXGeneral;">,</span><span class="mi" id="MathJax-Span-42" style="font-family: STIXGeneral; font-style: italic; padding-left: 0.195em;">n</span><span class="mi" id="MathJax-Span-43" style="font-family: STIXGeneral; font-style: italic;">o</span><span class="mi" id="MathJax-Span-44" style="font-family: STIXGeneral; font-style: italic;">n</span><span class="mi" id="MathJax-Span-45" style="font-family: STIXGeneral; font-style: italic;">c</span><span class="mi" id="MathJax-Span-46" style="font-family: STIXGeneral; font-style: italic;">e</span><span class="mo" id="MathJax-Span-47" style="font-family: STIXGeneral;">)</span></span><span style="display: inline-block; width: 0px; height: 2.502em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.253em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
      <mi>
       h
      </mi>
      <mi>
       a
      </mi>
      <mi>
       s
      </mi>
      <mi>
       h
      </mi>
      <mi mathvariant="normal">
       _
      </mi>
      <mi>
       o
      </mi>
      <mi>
       u
      </mi>
      <mi>
       t
      </mi>
      <mi>
       p
      </mi>
      <mi>
       u
      </mi>
      <mi>
       t
      </mi>
      <mo>
       =
      </mo>
      <mi>
       H
      </mi>
      <mi>
       A
      </mi>
      <mi>
       S
      </mi>
      <mi>
       H
      </mi>
      <mo stretchy="false">
       (
      </mo>
      <mi>
       p
      </mi>
      <mi>
       r
      </mi>
      <mi>
       e
      </mi>
      <mi>
       v
      </mi>
      <mi mathvariant="normal">
       _
      </mi>
      <mi>
       h
      </mi>
      <mi>
       a
      </mi>
      <mi>
       s
      </mi>
      <mi>
       h
      </mi>
      <mo>
       ,
      </mo>
      <mi>
       m
      </mi>
      <mi>
       e
      </mi>
      <mi>
       r
      </mi>
      <mi>
       k
      </mi>
      <mi>
       l
      </mi>
      <msub>
       <mi>
        e
       </mi>
       <mi>
        r
       </mi>
      </msub>
      <mi>
       o
      </mi>
      <mi>
       o
      </mi>
      <mi>
       t
      </mi>
      <mo>
       ,
      </mo>
      <mi>
       n
      </mi>
      <mi>
       o
      </mi>
      <mi>
       n
      </mi>
      <mi>
       c
      </mi>
      <mi>
       e
      </mi>
      <mo stretchy="false">
       )
      </mo>
     </math></span></span>
  </div>
  <script type="math/tex; mode=display" id="MathJax-Element-1">hash\_output=HASH(prev\_hash,merkle_root,nonce)</script> 
  <br> 如果计算结果满足
  <span class="MathJax_Preview" style="color: inherit; display: none;"></span>
  <span class="MathJax" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi mathvariant=&quot;normal&quot;>&amp;#x005F;</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>&amp;lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></math>" role="presentation" style="position: relative;">
   <nobr aria-hidden="true">
    <span class="math" id="MathJax-Span-48" style="width: 11.349em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.704em; height: 0px; font-size: 130%;"><span style="position: absolute; clip: rect(1.685em, 1008.7em, 2.839em, -999.998em); top: -2.498em; left: 0em;"><span class="mrow" id="MathJax-Span-49"><span class="mi" id="MathJax-Span-50" style="font-family: STIXGeneral; font-style: italic;">h</span><span class="mi" id="MathJax-Span-51" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-52" style="font-family: STIXGeneral; font-style: italic;">s</span><span class="mi" id="MathJax-Span-53" style="font-family: STIXGeneral; font-style: italic;">h</span><span class="mi" id="MathJax-Span-54" style="font-family: STIXGeneral;">_</span><span class="mi" id="MathJax-Span-55" style="font-family: STIXGeneral; font-style: italic;">o</span><span class="mi" id="MathJax-Span-56" style="font-family: STIXGeneral; font-style: italic;">u</span><span class="mi" id="MathJax-Span-57" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-58" style="font-family: STIXGeneral; font-style: italic;">p</span><span class="mi" id="MathJax-Span-59" style="font-family: STIXGeneral; font-style: italic;">u</span><span class="mi" id="MathJax-Span-60" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mo" id="MathJax-Span-61" style="font-family: STIXGeneral; padding-left: 0.339em;">&lt;</span><span class="mi" id="MathJax-Span-62" style="font-family: STIXGeneral; font-style: italic; padding-left: 0.339em;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-63" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-64" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-65" style="font-family: STIXGeneral; font-style: italic;">g</span><span class="mi" id="MathJax-Span-66" style="font-family: STIXGeneral; font-style: italic;">e</span><span class="mi" id="MathJax-Span-67" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.502em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.253em;"></span></span>
   </nobr><span class="MJX_Assistive_MathML" role="presentation">
    <math xmlns="http://www.w3.org/1998/Math/MathML">
     <mi>
      h
     </mi>
     <mi>
      a
     </mi>
     <mi>
      s
     </mi>
     <mi>
      h
     </mi>
     <mi mathvariant="normal">
      _
     </mi>
     <mi>
      o
     </mi>
     <mi>
      u
     </mi>
     <mi>
      t
     </mi>
     <mi>
      p
     </mi>
     <mi>
      u
     </mi>
     <mi>
      t
     </mi>
     <mo>
      &lt;
     </mo>
     <mi>
      t
     </mi>
     <mi>
      a
     </mi>
     <mi>
      r
     </mi>
     <mi>
      g
     </mi>
     <mi>
      e
     </mi>
     <mi>
      t
     </mi>
    </math></span></span>
  <script type="math/tex" id="MathJax-Element-2">hash\_output<target</script>，则说明计算的
  <code>nonce</code>是有效的
  <p></p> 
  <p>而对于Hashimoto，HASH运算仅仅是第一步，其算法如下:</p> 
  <pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">nonce:</span>　<span class="hljs-number">64</span>-bits.正在尝试的nonce值
get_txid(T):历史区块上的交易T的hash
<span class="hljs-label">total_transactions:</span>　历史上的所有交易的个数</code></pre> 
  <pre class="prettyprint"><code class=" hljs applescript">hash_output_A = HASH(prev_hash,merkle_root,nonce)
<span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-number">63</span> do 
    shifted_A = hash_output_A &gt;&gt; i
    <span class="hljs-keyword">transaction</span> = shifted_A <span class="hljs-keyword">mod</span> total_transactions
    txid[i] = get_txit(<span class="hljs-keyword">transaction</span>) &lt;&lt; i
<span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span>
txid_mix = txid[<span class="hljs-number">0</span>]^txid[<span class="hljs-number">1</span>]...txid[<span class="hljs-number">63</span>]
final_output = txid_mix ^ （nonce&lt;&lt;<span class="hljs-number">192</span>)</code></pre> 
  <p>可以看出，在进行了HASH运算后，还需要进行64轮的混淆(mix)运算，而混淆的源数据是区块链上的历史交易，矿工节点在运行此算法时，需要访问内存中的历史交易信息(这是内存消耗的来源)，最终只有当　<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-12-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi><mi mathvariant=&quot;normal&quot;>&amp;#x005F;</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>&amp;lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></math>" role="presentation" style="position: relative;">
    <nobr aria-hidden="true">
     <span class="math" id="MathJax-Span-257" style="width: 11.445em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.8em; height: 0px; font-size: 130%;"><span style="position: absolute; clip: rect(1.685em, 1008.8em, 2.839em, -999.998em); top: -2.498em; left: 0em;"><span class="mrow" id="MathJax-Span-258"><span class="mi" id="MathJax-Span-259" style="font-family: STIXGeneral; font-style: italic;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.147em;"></span></span><span class="mi" id="MathJax-Span-260" style="font-family: STIXGeneral; font-style: italic;">i</span><span class="mi" id="MathJax-Span-261" style="font-family: STIXGeneral; font-style: italic;">n</span><span class="mi" id="MathJax-Span-262" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-263" style="font-family: STIXGeneral; font-style: italic;">l<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-264" style="font-family: STIXGeneral;">_</span><span class="mi" id="MathJax-Span-265" style="font-family: STIXGeneral; font-style: italic;">o</span><span class="mi" id="MathJax-Span-266" style="font-family: STIXGeneral; font-style: italic;">u</span><span class="mi" id="MathJax-Span-267" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-268" style="font-family: STIXGeneral; font-style: italic;">p</span><span class="mi" id="MathJax-Span-269" style="font-family: STIXGeneral; font-style: italic;">u</span><span class="mi" id="MathJax-Span-270" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mo" id="MathJax-Span-271" style="font-family: STIXGeneral; padding-left: 0.339em;">&lt;</span><span class="mi" id="MathJax-Span-272" style="font-family: STIXGeneral; font-style: italic; padding-left: 0.339em;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-273" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-274" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-275" style="font-family: STIXGeneral; font-style: italic;">g</span><span class="mi" id="MathJax-Span-276" style="font-family: STIXGeneral; font-style: italic;">e</span><span class="mi" id="MathJax-Span-277" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.502em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.316em;"></span></span>
    </nobr><span class="MJX_Assistive_MathML" role="presentation">
     <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mi>
       f
      </mi>
      <mi>
       i
      </mi>
      <mi>
       n
      </mi>
      <mi>
       a
      </mi>
      <mi>
       l
      </mi>
      <mi mathvariant="normal">
       _
      </mi>
      <mi>
       o
      </mi>
      <mi>
       u
      </mi>
      <mi>
       t
      </mi>
      <mi>
       p
      </mi>
      <mi>
       u
      </mi>
      <mi>
       t
      </mi>
      <mo>
       &lt;
      </mo>
      <mi>
       t
      </mi>
      <mi>
       a
      </mi>
      <mi>
       r
      </mi>
      <mi>
       g
      </mi>
      <mi>
       e
      </mi>
      <mi>
       t
      </mi>
     </math></span></span><script type="math/tex" id="MathJax-Element-12">final\_output < target</script>　时，才算是找到了有效的<code>nonce</code></p> 
  <p><code>Dagger-Hashimoto</code>相比于Hashimoto，不同点在于混淆运算的数据源不是区块链上的历史交易，而是以特定算法生成的约1GB大小的数据集合(<code>dataset</code>)，矿工节点在挖矿时，需要将这1GB数据全部载入内存。</p> 
  <h4 id="ethash算法概要">Ethash算法概要</h4> 
  <ul> 
   <li>矿工挖矿不再是仅仅将找到的<code>nonce</code>填入区块头，还需要填入一项<code>MixDigest</code>，这是在挖矿过程中计算出来的，它可以作为矿工的确在进行消耗内存挖矿工作量的证明。验证者在验证区块时也会用到这一项。</li> 
   <li>先计算出约16MB大小的<code>cache</code>，约1GB的<code>dataset</code>由这约16MB的<code>cache</code>按特定算法生成，dataset中每一项数据都由<code>cache</code>中的256项数据参与生成，<code>cache</code>中的这256项数据可以看做是<code>dataset</code>中数据的<code>parent</code>。只所以是<strong>约</strong>，是因为其真正的大小是比16MB和1GB稍微小一点(为了好描述，以下将省略<strong>约</strong>)</li> 
   <li><code>cache</code>和<code>dataset</code>的内容并非不变，它每隔一个<code>epoch</code>(30000个区块)就需要重新计算</li> 
   <li><code>cache</code>和<code>dataset</code>的大小并非一成不变，16MB和1GB只是初始值，这个大小在每年会增大73%,这是为了抵消掉摩尔定律下硬件性能的提升，即使硬件性能提升了，那么最终计算所代表的工作量不会变化很多。结合上一条，那么其实每经过30000个区块，<code>cache</code>和<code>dataset</code>就会增大一点，并且重新计算</li> 
   <li>全节点(比如矿工)会存储整个 <code>cache</code>和<code>dataset</code>，而轻客户端只需要存储 <code>cache</code>。挖矿(seal)时需要<code>dataset</code>在内存中便于随时存取，而验证(verify)时，只需要有cache就行，需要的<code>dataset</code>临时计算就行。</li> 
  </ul> 
  <h4 id="ethash源码解析">Ethash源码解析</h4> 
  <h5 id="dataset生成">dataset生成</h5> 
  <p><code>dataset</code>通过<code>generate()</code>方法生成，首先是生成cache，再从cache生成dataset</p> 
  <h5 id="挖矿seal-1">挖矿(Seal)</h5> 
  <p>在<a href="https://blog.csdn.net/chenmo187j3x1/article/details/80782230" rel="nofollow">挖矿与共识</a>中提到了，共识算法通过实现<code>Engine.Seal</code>接口，来实现挖矿,Ethash算法也不例外。 <br> 其顶层流程如下: <br> <img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180715000627522?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5tbzE4N0ozWDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Seal" title=""></p> 
  <ul> 
   <li>Seal调用中，启动一个go routine来调用<code>ethash.mine()</code>进行实际的挖矿，参数中的block是待挖掘的区块(已经打包好了交易)，而<code>nonce</code>是一个随机值，作为挖矿过程尝试<code>nonce</code>的初始值。</li> 
   <li><code>mine()</code>调用首先计算后续挖矿需要的一些变量。<strong>hash</strong>为区块头中除了<code>nonce</code>和<code>mixdigest</code>的Hash值，<strong>dataset</strong>为挖掘这个区块时需要的混淆数据集合(占用1GB内存),<strong>target</strong>是本区块最终Hash需要达到的目标，它与区块难度成反比</li> 
   <li>对本次尝试的<code>nonce</code>进行<code>hashmotoFull()</code>函数计算最终<code>result</code>(最终Hash值)和<code>digest</code>，如果满足target要求，则结束挖矿，否则增加<code>nonce</code>，再调用<code>hashmotoFull()</code></li> 
  </ul> 
  <pre class="prettyprint"><code class=" hljs go"><span class="hljs-keyword">func</span> hashimotoFull(dataset []<span class="hljs-typename">uint32</span>, hash []<span class="hljs-typename">byte</span>, nonce <span class="hljs-typename">uint64</span>) ([]<span class="hljs-typename">byte</span>, []<span class="hljs-typename">byte</span>) {
    lookup := <span class="hljs-keyword">func</span>(index <span class="hljs-typename">uint32</span>) []<span class="hljs-typename">uint32</span> {
        offset := index * hashWords
        <span class="hljs-keyword">return</span> dataset[offset : offset+hashWords]
    }
    <span class="hljs-keyword">return</span> hashimoto(hash, nonce, <span class="hljs-typename">uint64</span>(<span class="hljs-built_in">len</span>(dataset))<span class="hljs-number">*4</span>, lookup)
}</code></pre> 
  <p><code>hashmotoFull()</code>是运算的核心，内部调用<code>hashmoto()</code>，第三个参数为<code>dataset</code>的大小（即1GB）,第四个参数是一个<code>lookup</code>函数，它接收<strong>index</strong>参数，返回<code>dataset</code>中64字节的数据。</p> 
  <pre class="prettyprint"><code class=" hljs go"><span class="hljs-keyword">func</span> hashimoto(hash []<span class="hljs-typename">byte</span>, nonce <span class="hljs-typename">uint64</span>, size <span class="hljs-typename">uint64</span>, lookup <span class="hljs-keyword">func</span>(index <span class="hljs-typename">uint32</span>) []<span class="hljs-typename">uint32</span>) ([]<span class="hljs-typename">byte</span>, []<span class="hljs-typename">byte</span>) {
    <span class="hljs-comment">// 将dataset划分为2维矩阵，每行mixBytes=128字节，共1073739904/128=8388593行</span>
    rows := <span class="hljs-typename">uint32</span>(size / mixBytes)

    <span class="hljs-comment">//　将hash与待尝试的nonce组合成64字节的seed</span>
    seed := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>,<span class="hljs-number"> 40</span>)
    <span class="hljs-built_in">copy</span>(seed, hash)
    binary.LittleEndian.PutUint64(seed<span class="hljs-number">[32</span>:], nonce)

    seed = crypto.Keccak512(seed)
    seedHead := binary.LittleEndian.Uint32(seed)

    <span class="hljs-comment">// 将64字节的seed转化为32个uint32的mix数组(前后16个uint32内容相同)</span>
    mix := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">uint32</span>, mixBytes<span class="hljs-number">/4</span>)
    <span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 0</span>; i &lt; <span class="hljs-built_in">len</span>(mix); i++ {
        mix[i] = binary.LittleEndian.Uint32(seed[i<span class="hljs-number">%16</span><span class="hljs-number">*4</span>:])
    }

    temp := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">uint32</span>, <span class="hljs-built_in">len</span>(mix))

    <span class="hljs-comment">//　进行总共loopAccesses=64轮的混淆计算，每次计算会去dataset里查询数据</span>
    <span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 0</span>; i &lt; loopAccesses; i++ {
        parent := fnv(<span class="hljs-typename">uint32</span>(i)^seedHead, mix[i%<span class="hljs-built_in">len</span>(mix)]) % rows
        <span class="hljs-keyword">for</span> j := <span class="hljs-typename">uint32</span><span class="hljs-number">(0</span>); j &lt; mixBytes/hashBytes; j++ {
            <span class="hljs-built_in">copy</span>(temp[j*hashWords:], lookup<span class="hljs-number">(2</span>*parent+j))
        }
        fnvHash(mix, temp)
    }
    <span class="hljs-comment">// 压缩mix：将32个uint32的mix压缩成8个uint32</span>
    <span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 0</span>; i &lt; <span class="hljs-built_in">len</span>(mix); i +=<span class="hljs-number"> 4</span> {
        mix[i<span class="hljs-number">/4</span>] = fnv(fnv(fnv(mix[i], mix[i<span class="hljs-number">+1</span>]), mix[i<span class="hljs-number">+2</span>]), mix[i<span class="hljs-number">+3</span>])
    }
    mix = mix[:<span class="hljs-built_in">len</span>(mix)<span class="hljs-number">/4</span>]

    <span class="hljs-comment">// 用8个uint32的mix填充32字节的digest</span>
    digest := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, common.HashLength)
    <span class="hljs-keyword">for</span> i, val := <span class="hljs-keyword">range</span> mix {
        binary.LittleEndian.PutUint32(digest[i<span class="hljs-number">*4</span>:], val)
    }
    <span class="hljs-comment">//　对seed+digest计算hash，得到最终的hash值</span>
    <span class="hljs-keyword">return</span> digest, crypto.Keccak256(<span class="hljs-built_in">append</span>(seed, digest...))
}</code></pre> 
  <h5 id="验证verify">验证(Verify)</h5> 
  <p>验证时<code>VerifySeal()</code>调用<code>hashimotoLight()</code>，<strong>Light</strong>表明验证者不需要完整的dataset，它需要用到的dataset中的数据都是临时从cache中计算。</p> 
  <pre class="prettyprint"><code class=" hljs go"><span class="hljs-keyword">func</span> hashimotoLight(size <span class="hljs-typename">uint64</span>, cache []<span class="hljs-typename">uint32</span>, hash []<span class="hljs-typename">byte</span>, nonce <span class="hljs-typename">uint64</span>) ([]<span class="hljs-typename">byte</span>, []<span class="hljs-typename">byte</span>) {
    keccak512 := makeHasher(sha3.NewKeccak512())

    <span class="hljs-comment">//lookup函数和hashimotoFull中的不同，它调用generateDatasetItem从cache中临时计算</span>
    lookup := <span class="hljs-keyword">func</span>(index <span class="hljs-typename">uint32</span>) []<span class="hljs-typename">uint32</span> {
        rawData := generateDatasetItem(cache, index, keccak512) <span class="hljs-comment">// return 64 byte</span>

        data := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">uint32</span>, <span class="hljs-built_in">len</span>(rawData)<span class="hljs-number">/4</span>) <span class="hljs-comment">// 16 个　uint32</span>
        <span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 0</span>; i &lt; <span class="hljs-built_in">len</span>(data); i++ {
            data[i] = binary.LittleEndian.Uint32(rawData[i<span class="hljs-number">*4</span>:])
        }
        <span class="hljs-keyword">return</span> data
    }

    <span class="hljs-keyword">return</span> hashimoto(hash, nonce, size, lookup)
}</code></pre> 
  <p>除了<code>lookup</code>函数不同，其余部分<code>hashimotoFull</code>完全一样</p> 
  <h4 id="总结">总结</h4> 
  <p>Ethash相比与Bitcoin的挖矿算法，增加了对内存使用的要求，要求矿工提供在挖矿过程中使用了大量内存的工作量证明,最终达到抵抗ASIC矿机的目的。</p> 
  <h4 id="参考资料">参考资料</h4> 
  <p>1 <a href="https://github.com/ethereum/wiki/wiki/Ethash-Design-Rationale" rel="nofollow">Ethash-Design-Rationale</a> <br> 2 <a href="https://ethereum.stackexchange.com/questions/1993/what-actually-is-a-dag" rel="nofollow">what-actually-is-a-dag</a> <br> 3 <a href="https://medium.com/verifyas/why-dagger-hashimoto-for-ethereum-773f0792a689" rel="nofollow">why-dagger-hashimoto-for-ethereum</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/chenmo187J3X1/article/details/81041416,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/chenmo187J3X1/article/details/81041416,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
