<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>ubuntu16.04下fabric v1.0.0手动多步骤安装(单机版) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="ubuntu16.04下fabric v1.0.0手动多步骤安装(单机版)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1. 安装docker与docker-compose（docker-compose要支持v2版本的yaml） 参考https://docs.docker.com/install/linux/docker-ce/ubuntu/ 1.1 使用国内阿里源安装docker curl -fsSLhttp://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository &quot;deb [arch=amd64]http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs)stable&quot; sudo apt-get -y update sudo apt-get install docker-ce 1.2 添加阿里云的docker hub镜像 sudo mkdir -p /etc/docker vim /etc/docker/daemon.json 添加 { &quot;registry-mirrors&quot; : [&quot;https://obou6wyb.mirror.aliyuncs.com&quot;] } 重启docker sudo systemctl daemon-reload 加载docker.service sudo systemctl restart docker.service 重启docker服务 1.3 安装docker-compose（docker-compose是python下的编排工具） 首先安装pip，sudo apt-get install python-pip curl-Lhttps://get.daocloud.io/docker/compose/releases/download/1.21.2/docker-compose-`uname-s`-`uname -m`&gt;/usr/local/bin/docker-compose chmod+x /usr/local/bin/docker-compose docker-composeversion 2. 安装go环境(我是安装在/home/hadoop目录中) 2.1 下载安装go cd /home/hadoop/ wget https://studygolang.com/dl/golang/go1.10.1.linux-amd64.tar.gz tar -C /usr/local -xzf go1.10.1.linux-amd64.tar.gz mkdir gopath 2.2 配置环境变量 vim/etc/profile 添加 export PATH=$PATH:/usr/local/go/bin #export GOPATH=/opt/gopath export GOPATH=/home/hadoop/gopath export GOROOT=/usr/local/go source /etc/profile 使环境变量生效 go version查看go是否安装成功 3. Fabric下载与docker镜像下载 3.1 Fabric源码下载 mkdir-p /home/hadoop/gopath/src/github.com/hyperledger cd /home/hadoop/gopath/src/github.com/hyperledger git clone https://github.com/hyperledger/fabric.git cd fabric git checkout v1.0.0（切记：一定要做，切换至对应分支） 3.2 fabric镜像下载 cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli/ source download-dockerimages.sh -c x86_64-1.0.0 -f x86_64-1.0.0 （切记：版本要与fabric对应住） docker images 查看镜像列表 4． 启动fabric网络并测试chaincode 4.1 傻瓜式安装 ./network_setup.sh up 该过程主要做了以下操作 1）&nbsp;&nbsp;生成公私钥和证书 2）&nbsp;&nbsp;生成创世区块和channel通道配置信息 3）&nbsp;&nbsp;启动fabric环境的容器 4）&nbsp;&nbsp;创建通道 5）&nbsp;&nbsp;各个peer加入通道 6）&nbsp;&nbsp;安装链上代码 7）&nbsp;&nbsp;实例化代码 4.2 手动分步骤安装 4.2.1生成公私钥和证书 1）编译生成cryptogen cd /home/hadoop/gopath/src/github.com/hyperledger/fabric make cryptogen 运行后返回结果 build/bin/cryptogen CGO_CFLAGS=&quot;&quot; GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin goinstall -tags &quot;&quot; -ldflags &quot;-Xgithub.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0&quot;github.com/hyperledger/fabric/common/tools/cryptogen Binary available asbuild/bin/cryptogen 2）生成公私钥和证书 cd examples/e2e_cli/ ../../build/bin/cryptogen generate--config=./crypto-config.yaml 此时生成了公私钥，并保存在crypto-config文件中 tree crypto-config查看生成的证书 4.2.2生成创世区块和channel通道配置信息 1）编译生成configtxgen cd /home/hadoop/gopath/src/github.com/hyperledger/fabric make configtxgen 运行后结果 build/bin/configtxgen CGO_CFLAGS=&quot; &quot;GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install-tags &quot;nopkcs11&quot; -ldflags &quot;-Xgithub.com/hyperledger/fabric/common/configtx/tool/configtxgen/metadata.Version=1.0.0&quot;github.com/hyperledger/fabric/common/configtx/tool/configtxgen Binary available as build/bin/configtxgen 2）生成创世区块 cd examples/e2e_cli/ ../../build/bin/configtxgen -profileTwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 3）生成channel通道配置 ../../build/bin/configtxgen -profileTwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelIDmychannel 4）另外关于锚节点更新，我们也需要使用这个程序来生成文件 ../../build/bin/configtxgen -profileTwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx-channelID mychannel -asOrg Org1MSP ../../build/bin/configtxgen -profileTwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx-channelID mychannel -asOrg Org2MSP 两个组织，生成两个锚节点 &nbsp; 此时能看到channel-artifacts下四个文件 channel-artifacts/ ├── channel.tx ├── genesis.block ├── Org1MSPanchors.tx └── Org2MSPanchors.tx 4.2.3 启动fabric docker环境的容器 由于手动部署，启动前需要将docker-compose-cli.yaml中信息更改 vim docker-compose-cli.yaml 注释掉command: /bin/bash -c &#39;./scripts/script.sh${CHANNEL_NAME}; sleep $TIMEOUT&#39; 另更正一个错误 /base/peer.yaml中将network信息elecli_default改为ele_cli_default（ele_cli文件夹的默认网络名称） docker-compose -f docker-compose-cli.yaml up-d 此时显示启动了四个peer，一个orderer，一个cli客户端 4.2.4 创建channel，各peer加入通道 1）创建channel docker exec -it cli bash 进入客户端容器 创建Channel的命令是peer channelcreate，我们前面创建2.4创建Channel的配置区块时，指定了Channel的名字是mychannel，那么这里我们必须创建同样名字的channel。 &nbsp; ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer channel create -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tlstrue --cafile $ORDERER_CA 此时创建成功一个maychannel.block文件，其他peer节点加入都需要该文件 2）各peer加入channel peerchannel join -b mychannel.block （CLI客户端默认链接peer0.org1，因此该节点加入比较简单） 其他节点加入（以peer1.org1为例）： CLI指向peer1.org1 CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer1.org1.example.com:7051 加入通道： peerchannel join -b mychannel.block 依次将所有peer节点加入通道 3）更新锚节点 对于Org1来说，peer0.org1是锚节点，我们需要连接上它并更新锚节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 &nbsp; peer channel update -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx--tls true --cafile $ORDERER_CA 对于Org2，peer0.org2是锚节点，对应的更新代码是： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 &nbsp; peer channel update -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx--tls true --cafile $ORDERER_CA 4.2.5 安装链上代码（共识算法）及实例化测试 1） 安装链码 对需要共识的peer节点都要安装链码 以peer0.org1为例，先切换至该节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 安装链码： peer chaincode install -n mycc -v 1.0 -pgithub.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 2）实例化链码 对链上代码实例化，生成对应通道，对应链码的docker镜像和容器，并指定背书策略 peer chaincode instantiate -oorderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc-v 1.0 -c&#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]}&#39;-P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 此时，dockerps可以看到多了一个dev的容器，如果再开一个peer，则再多一个dev容器 3）交易 在peer0.org1上发起交易 查询a的余额，peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 返回结果 Query result： 100 转账：a向b转账10元 peer chaincode invoke -oorderer.example.com:7050&nbsp; --tls true--cafile $ORDERER_CA -C mychannel -n mycc -c&#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 在另一个节点查询： 首先CLI指向peer1.org2并安装链码，然后查询 peer chaincode query -C mychannel -n mycc -c&#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 需要较长时间（几十秒） 5. 报错信息 root@namenode:/home/hadoop/gopath/src/github.com/hyperledger/fabric#make cryptogen build/bin/cryptogen CGO_CFLAGS=&quot; &quot;GOBIN=/home/hadoop/gopath/src/github.com/hyperledger/fabric/build/bin goinstall -tags &quot;&quot; -ldflags &quot;-Xgithub.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0&quot;github.com/hyperledger/fabric/common/tools/cryptogen #github.com/hyperledger/fabric/vendor/github.com/miekg/pkcs11 vendor/github.com/miekg/pkcs11/pkcs11.go:29:18:fatal error: ltdl.h: No such file or directory compilation terminated. Makefile:227: recipe for target&#39;build/bin/cryptogen&#39; failed make: *** [build/bin/cryptogen] Error2 &nbsp; 解决：下载安装libltdl-dev apt-get install libtool libltdl-dev &nbsp; &nbsp; 参考：https://www.cnblogs.com/studyzy/p/7451276.html https://www.jianshu.com/p/16903ed42f17 &nbsp; 阅读更多" />
<meta property="og:description" content="1. 安装docker与docker-compose（docker-compose要支持v2版本的yaml） 参考https://docs.docker.com/install/linux/docker-ce/ubuntu/ 1.1 使用国内阿里源安装docker curl -fsSLhttp://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository &quot;deb [arch=amd64]http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs)stable&quot; sudo apt-get -y update sudo apt-get install docker-ce 1.2 添加阿里云的docker hub镜像 sudo mkdir -p /etc/docker vim /etc/docker/daemon.json 添加 { &quot;registry-mirrors&quot; : [&quot;https://obou6wyb.mirror.aliyuncs.com&quot;] } 重启docker sudo systemctl daemon-reload 加载docker.service sudo systemctl restart docker.service 重启docker服务 1.3 安装docker-compose（docker-compose是python下的编排工具） 首先安装pip，sudo apt-get install python-pip curl-Lhttps://get.daocloud.io/docker/compose/releases/download/1.21.2/docker-compose-`uname-s`-`uname -m`&gt;/usr/local/bin/docker-compose chmod+x /usr/local/bin/docker-compose docker-composeversion 2. 安装go环境(我是安装在/home/hadoop目录中) 2.1 下载安装go cd /home/hadoop/ wget https://studygolang.com/dl/golang/go1.10.1.linux-amd64.tar.gz tar -C /usr/local -xzf go1.10.1.linux-amd64.tar.gz mkdir gopath 2.2 配置环境变量 vim/etc/profile 添加 export PATH=$PATH:/usr/local/go/bin #export GOPATH=/opt/gopath export GOPATH=/home/hadoop/gopath export GOROOT=/usr/local/go source /etc/profile 使环境变量生效 go version查看go是否安装成功 3. Fabric下载与docker镜像下载 3.1 Fabric源码下载 mkdir-p /home/hadoop/gopath/src/github.com/hyperledger cd /home/hadoop/gopath/src/github.com/hyperledger git clone https://github.com/hyperledger/fabric.git cd fabric git checkout v1.0.0（切记：一定要做，切换至对应分支） 3.2 fabric镜像下载 cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli/ source download-dockerimages.sh -c x86_64-1.0.0 -f x86_64-1.0.0 （切记：版本要与fabric对应住） docker images 查看镜像列表 4． 启动fabric网络并测试chaincode 4.1 傻瓜式安装 ./network_setup.sh up 该过程主要做了以下操作 1）&nbsp;&nbsp;生成公私钥和证书 2）&nbsp;&nbsp;生成创世区块和channel通道配置信息 3）&nbsp;&nbsp;启动fabric环境的容器 4）&nbsp;&nbsp;创建通道 5）&nbsp;&nbsp;各个peer加入通道 6）&nbsp;&nbsp;安装链上代码 7）&nbsp;&nbsp;实例化代码 4.2 手动分步骤安装 4.2.1生成公私钥和证书 1）编译生成cryptogen cd /home/hadoop/gopath/src/github.com/hyperledger/fabric make cryptogen 运行后返回结果 build/bin/cryptogen CGO_CFLAGS=&quot;&quot; GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin goinstall -tags &quot;&quot; -ldflags &quot;-Xgithub.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0&quot;github.com/hyperledger/fabric/common/tools/cryptogen Binary available asbuild/bin/cryptogen 2）生成公私钥和证书 cd examples/e2e_cli/ ../../build/bin/cryptogen generate--config=./crypto-config.yaml 此时生成了公私钥，并保存在crypto-config文件中 tree crypto-config查看生成的证书 4.2.2生成创世区块和channel通道配置信息 1）编译生成configtxgen cd /home/hadoop/gopath/src/github.com/hyperledger/fabric make configtxgen 运行后结果 build/bin/configtxgen CGO_CFLAGS=&quot; &quot;GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install-tags &quot;nopkcs11&quot; -ldflags &quot;-Xgithub.com/hyperledger/fabric/common/configtx/tool/configtxgen/metadata.Version=1.0.0&quot;github.com/hyperledger/fabric/common/configtx/tool/configtxgen Binary available as build/bin/configtxgen 2）生成创世区块 cd examples/e2e_cli/ ../../build/bin/configtxgen -profileTwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 3）生成channel通道配置 ../../build/bin/configtxgen -profileTwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelIDmychannel 4）另外关于锚节点更新，我们也需要使用这个程序来生成文件 ../../build/bin/configtxgen -profileTwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx-channelID mychannel -asOrg Org1MSP ../../build/bin/configtxgen -profileTwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx-channelID mychannel -asOrg Org2MSP 两个组织，生成两个锚节点 &nbsp; 此时能看到channel-artifacts下四个文件 channel-artifacts/ ├── channel.tx ├── genesis.block ├── Org1MSPanchors.tx └── Org2MSPanchors.tx 4.2.3 启动fabric docker环境的容器 由于手动部署，启动前需要将docker-compose-cli.yaml中信息更改 vim docker-compose-cli.yaml 注释掉command: /bin/bash -c &#39;./scripts/script.sh${CHANNEL_NAME}; sleep $TIMEOUT&#39; 另更正一个错误 /base/peer.yaml中将network信息elecli_default改为ele_cli_default（ele_cli文件夹的默认网络名称） docker-compose -f docker-compose-cli.yaml up-d 此时显示启动了四个peer，一个orderer，一个cli客户端 4.2.4 创建channel，各peer加入通道 1）创建channel docker exec -it cli bash 进入客户端容器 创建Channel的命令是peer channelcreate，我们前面创建2.4创建Channel的配置区块时，指定了Channel的名字是mychannel，那么这里我们必须创建同样名字的channel。 &nbsp; ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer channel create -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tlstrue --cafile $ORDERER_CA 此时创建成功一个maychannel.block文件，其他peer节点加入都需要该文件 2）各peer加入channel peerchannel join -b mychannel.block （CLI客户端默认链接peer0.org1，因此该节点加入比较简单） 其他节点加入（以peer1.org1为例）： CLI指向peer1.org1 CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer1.org1.example.com:7051 加入通道： peerchannel join -b mychannel.block 依次将所有peer节点加入通道 3）更新锚节点 对于Org1来说，peer0.org1是锚节点，我们需要连接上它并更新锚节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 &nbsp; peer channel update -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx--tls true --cafile $ORDERER_CA 对于Org2，peer0.org2是锚节点，对应的更新代码是： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 &nbsp; peer channel update -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx--tls true --cafile $ORDERER_CA 4.2.5 安装链上代码（共识算法）及实例化测试 1） 安装链码 对需要共识的peer节点都要安装链码 以peer0.org1为例，先切换至该节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 安装链码： peer chaincode install -n mycc -v 1.0 -pgithub.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 2）实例化链码 对链上代码实例化，生成对应通道，对应链码的docker镜像和容器，并指定背书策略 peer chaincode instantiate -oorderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc-v 1.0 -c&#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]}&#39;-P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 此时，dockerps可以看到多了一个dev的容器，如果再开一个peer，则再多一个dev容器 3）交易 在peer0.org1上发起交易 查询a的余额，peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 返回结果 Query result： 100 转账：a向b转账10元 peer chaincode invoke -oorderer.example.com:7050&nbsp; --tls true--cafile $ORDERER_CA -C mychannel -n mycc -c&#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 在另一个节点查询： 首先CLI指向peer1.org2并安装链码，然后查询 peer chaincode query -C mychannel -n mycc -c&#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 需要较长时间（几十秒） 5. 报错信息 root@namenode:/home/hadoop/gopath/src/github.com/hyperledger/fabric#make cryptogen build/bin/cryptogen CGO_CFLAGS=&quot; &quot;GOBIN=/home/hadoop/gopath/src/github.com/hyperledger/fabric/build/bin goinstall -tags &quot;&quot; -ldflags &quot;-Xgithub.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0&quot;github.com/hyperledger/fabric/common/tools/cryptogen #github.com/hyperledger/fabric/vendor/github.com/miekg/pkcs11 vendor/github.com/miekg/pkcs11/pkcs11.go:29:18:fatal error: ltdl.h: No such file or directory compilation terminated. Makefile:227: recipe for target&#39;build/bin/cryptogen&#39; failed make: *** [build/bin/cryptogen] Error2 &nbsp; 解决：下载安装libltdl-dev apt-get install libtool libltdl-dev &nbsp; &nbsp; 参考：https://www.cnblogs.com/studyzy/p/7451276.html https://www.jianshu.com/p/16903ed42f17 &nbsp; 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-04T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"1. 安装docker与docker-compose（docker-compose要支持v2版本的yaml） 参考https://docs.docker.com/install/linux/docker-ce/ubuntu/ 1.1 使用国内阿里源安装docker curl -fsSLhttp://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository &quot;deb [arch=amd64]http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs)stable&quot; sudo apt-get -y update sudo apt-get install docker-ce 1.2 添加阿里云的docker hub镜像 sudo mkdir -p /etc/docker vim /etc/docker/daemon.json 添加 { &quot;registry-mirrors&quot; : [&quot;https://obou6wyb.mirror.aliyuncs.com&quot;] } 重启docker sudo systemctl daemon-reload 加载docker.service sudo systemctl restart docker.service 重启docker服务 1.3 安装docker-compose（docker-compose是python下的编排工具） 首先安装pip，sudo apt-get install python-pip curl-Lhttps://get.daocloud.io/docker/compose/releases/download/1.21.2/docker-compose-`uname-s`-`uname -m`&gt;/usr/local/bin/docker-compose chmod+x /usr/local/bin/docker-compose docker-composeversion 2. 安装go环境(我是安装在/home/hadoop目录中) 2.1 下载安装go cd /home/hadoop/ wget https://studygolang.com/dl/golang/go1.10.1.linux-amd64.tar.gz tar -C /usr/local -xzf go1.10.1.linux-amd64.tar.gz mkdir gopath 2.2 配置环境变量 vim/etc/profile 添加 export PATH=$PATH:/usr/local/go/bin #export GOPATH=/opt/gopath export GOPATH=/home/hadoop/gopath export GOROOT=/usr/local/go source /etc/profile 使环境变量生效 go version查看go是否安装成功 3. Fabric下载与docker镜像下载 3.1 Fabric源码下载 mkdir-p /home/hadoop/gopath/src/github.com/hyperledger cd /home/hadoop/gopath/src/github.com/hyperledger git clone https://github.com/hyperledger/fabric.git cd fabric git checkout v1.0.0（切记：一定要做，切换至对应分支） 3.2 fabric镜像下载 cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli/ source download-dockerimages.sh -c x86_64-1.0.0 -f x86_64-1.0.0 （切记：版本要与fabric对应住） docker images 查看镜像列表 4． 启动fabric网络并测试chaincode 4.1 傻瓜式安装 ./network_setup.sh up 该过程主要做了以下操作 1）&nbsp;&nbsp;生成公私钥和证书 2）&nbsp;&nbsp;生成创世区块和channel通道配置信息 3）&nbsp;&nbsp;启动fabric环境的容器 4）&nbsp;&nbsp;创建通道 5）&nbsp;&nbsp;各个peer加入通道 6）&nbsp;&nbsp;安装链上代码 7）&nbsp;&nbsp;实例化代码 4.2 手动分步骤安装 4.2.1生成公私钥和证书 1）编译生成cryptogen cd /home/hadoop/gopath/src/github.com/hyperledger/fabric make cryptogen 运行后返回结果 build/bin/cryptogen CGO_CFLAGS=&quot;&quot; GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin goinstall -tags &quot;&quot; -ldflags &quot;-Xgithub.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0&quot;github.com/hyperledger/fabric/common/tools/cryptogen Binary available asbuild/bin/cryptogen 2）生成公私钥和证书 cd examples/e2e_cli/ ../../build/bin/cryptogen generate--config=./crypto-config.yaml 此时生成了公私钥，并保存在crypto-config文件中 tree crypto-config查看生成的证书 4.2.2生成创世区块和channel通道配置信息 1）编译生成configtxgen cd /home/hadoop/gopath/src/github.com/hyperledger/fabric make configtxgen 运行后结果 build/bin/configtxgen CGO_CFLAGS=&quot; &quot;GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install-tags &quot;nopkcs11&quot; -ldflags &quot;-Xgithub.com/hyperledger/fabric/common/configtx/tool/configtxgen/metadata.Version=1.0.0&quot;github.com/hyperledger/fabric/common/configtx/tool/configtxgen Binary available as build/bin/configtxgen 2）生成创世区块 cd examples/e2e_cli/ ../../build/bin/configtxgen -profileTwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 3）生成channel通道配置 ../../build/bin/configtxgen -profileTwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelIDmychannel 4）另外关于锚节点更新，我们也需要使用这个程序来生成文件 ../../build/bin/configtxgen -profileTwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx-channelID mychannel -asOrg Org1MSP ../../build/bin/configtxgen -profileTwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx-channelID mychannel -asOrg Org2MSP 两个组织，生成两个锚节点 &nbsp; 此时能看到channel-artifacts下四个文件 channel-artifacts/ ├── channel.tx ├── genesis.block ├── Org1MSPanchors.tx └── Org2MSPanchors.tx 4.2.3 启动fabric docker环境的容器 由于手动部署，启动前需要将docker-compose-cli.yaml中信息更改 vim docker-compose-cli.yaml 注释掉command: /bin/bash -c &#39;./scripts/script.sh${CHANNEL_NAME}; sleep $TIMEOUT&#39; 另更正一个错误 /base/peer.yaml中将network信息elecli_default改为ele_cli_default（ele_cli文件夹的默认网络名称） docker-compose -f docker-compose-cli.yaml up-d 此时显示启动了四个peer，一个orderer，一个cli客户端 4.2.4 创建channel，各peer加入通道 1）创建channel docker exec -it cli bash 进入客户端容器 创建Channel的命令是peer channelcreate，我们前面创建2.4创建Channel的配置区块时，指定了Channel的名字是mychannel，那么这里我们必须创建同样名字的channel。 &nbsp; ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem peer channel create -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tlstrue --cafile $ORDERER_CA 此时创建成功一个maychannel.block文件，其他peer节点加入都需要该文件 2）各peer加入channel peerchannel join -b mychannel.block （CLI客户端默认链接peer0.org1，因此该节点加入比较简单） 其他节点加入（以peer1.org1为例）： CLI指向peer1.org1 CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer1.org1.example.com:7051 加入通道： peerchannel join -b mychannel.block 依次将所有peer节点加入通道 3）更新锚节点 对于Org1来说，peer0.org1是锚节点，我们需要连接上它并更新锚节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 &nbsp; peer channel update -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx--tls true --cafile $ORDERER_CA 对于Org2，peer0.org2是锚节点，对应的更新代码是： CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 &nbsp; peer channel update -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx--tls true --cafile $ORDERER_CA 4.2.5 安装链上代码（共识算法）及实例化测试 1） 安装链码 对需要共识的peer节点都要安装链码 以peer0.org1为例，先切换至该节点： CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp CORE_PEER_ADDRESS=peer0.org1.example.com:7051 安装链码： peer chaincode install -n mycc -v 1.0 -pgithub.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 2）实例化链码 对链上代码实例化，生成对应通道，对应链码的docker镜像和容器，并指定背书策略 peer chaincode instantiate -oorderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc-v 1.0 -c&#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]}&#39;-P &quot;OR (&#39;Org1MSP.member&#39;,&#39;Org2MSP.member&#39;)&quot; 此时，dockerps可以看到多了一个dev的容器，如果再开一个peer，则再多一个dev容器 3）交易 在peer0.org1上发起交易 查询a的余额，peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 返回结果 Query result： 100 转账：a向b转账10元 peer chaincode invoke -oorderer.example.com:7050&nbsp; --tls true--cafile $ORDERER_CA -C mychannel -n mycc -c&#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39; 在另一个节点查询： 首先CLI指向peer1.org2并安装链码，然后查询 peer chaincode query -C mychannel -n mycc -c&#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39; 需要较长时间（几十秒） 5. 报错信息 root@namenode:/home/hadoop/gopath/src/github.com/hyperledger/fabric#make cryptogen build/bin/cryptogen CGO_CFLAGS=&quot; &quot;GOBIN=/home/hadoop/gopath/src/github.com/hyperledger/fabric/build/bin goinstall -tags &quot;&quot; -ldflags &quot;-Xgithub.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0&quot;github.com/hyperledger/fabric/common/tools/cryptogen #github.com/hyperledger/fabric/vendor/github.com/miekg/pkcs11 vendor/github.com/miekg/pkcs11/pkcs11.go:29:18:fatal error: ltdl.h: No such file or directory compilation terminated. Makefile:227: recipe for target&#39;build/bin/cryptogen&#39; failed make: *** [build/bin/cryptogen] Error2 &nbsp; 解决：下载安装libltdl-dev apt-get install libtool libltdl-dev &nbsp; &nbsp; 参考：https://www.cnblogs.com/studyzy/p/7451276.html https://www.jianshu.com/p/16903ed42f17 &nbsp; 阅读更多","@type":"BlogPosting","url":"/2018/07/04/702aa9179cdc98851335469eb77bf346.html","headline":"ubuntu16.04下fabric v1.0.0手动多步骤安装(单机版)","dateModified":"2018-07-04T00:00:00+08:00","datePublished":"2018-07-04T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/07/04/702aa9179cdc98851335469eb77bf346.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>ubuntu16.04下fabric v1.0.0手动多步骤安装(单机版)</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h1>1. 安装docker与docker-compose（docker-compose要支持v2版本的yaml）</h1> 
  <p>参考https://docs.docker.com/install/linux/docker-ce/ubuntu/</p> 
  <h2>1.1 使用国内阿里源安装docker</h2> 
  <p>curl -fsSLhttp://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</p> 
  <p>add-apt-repository "deb [arch=amd64]http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs)stable"</p> 
  <p>sudo apt-get -y update</p> 
  <p>sudo apt-get install docker-ce</p> 
  <h2>1.2 添加阿里云的docker hub镜像</h2> 
  <p>sudo mkdir -p /etc/docker</p> 
  <p>vim /etc/docker/daemon.json</p> 
  <p>添加</p> 
  <p><span style="color:#000000;">{ "registry-mirrors" : ["https://obou6wyb.mirror.aliyuncs.com"] }</span></p> 
  <p><span style="color:#000000;">重启docker</span></p> 
  <p><span style="color:#000000;">sudo systemctl daemon-reload 加载docker.service</span></p> 
  <p><span style="color:#000000;">sudo systemctl restart docker.service 重启docker服务</span></p> 
  <h2>1.3 安装docker-compose（docker-compose是python下的编排工具）</h2> 
  <p>首先安装pip，sudo apt-get install python-pip</p> 
  <p>curl-Lhttps://get.daocloud.io/docker/compose/releases/download/1.21.2/docker-compose-`uname-s`-`uname -m`&gt;/usr/local/bin/docker-compose</p> 
  <p>chmod+x /usr/local/bin/docker-compose</p> 
  <p>docker-composeversion</p> 
  <h1>2. 安装go环境(我是安装在/home/hadoop目录中)</h1> 
  <h2>2.1 下载安装go</h2> 
  <p>cd /home/hadoop/</p> 
  <p>wget https://studygolang.com/dl/golang/go1.10.1.linux-amd64.tar.gz</p> 
  <p>tar -C /usr/local -xzf go1.10.1.linux-amd64.tar.gz</p> 
  <p>mkdir gopath</p> 
  <h2>2.2 配置环境变量</h2> 
  <p>vim/etc/profile</p> 
  <p>添加</p> 
  <p>export PATH=$PATH:/usr/local/go/bin</p> 
  <p>#export GOPATH=/opt/gopath</p> 
  <p>export GOPATH=/home/hadoop/gopath</p> 
  <p>export GOROOT=/usr/local/go</p> 
  <p>source /etc/profile 使环境变量生效</p> 
  <p>go version查看go是否安装成功</p> 
  <h1>3. Fabric下载与docker镜像下载</h1> 
  <h2>3.1 Fabric源码下载</h2> 
  <p>mkdir-p /home/hadoop/gopath/src/github.com/hyperledger</p> 
  <p>cd /home/hadoop/gopath/src/github.com/hyperledger</p> 
  <p>git clone <a href="https://github.com/hyperledger/fabric.git" rel="nofollow">https://github.com/hyperledger/fabric.git</a></p> 
  <p><span style="color:#4ea1db;">cd fabric</span></p> 
  <p>git checkout v1.0.0（切记：一定要做，切换至对应分支）</p> 
  <h2>3.2 fabric镜像下载</h2> 
  <p>cd /home/hadoop/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli/</p> 
  <p>source download-dockerimages.sh -c x86_64-1.0.0 -f x86_64-1.0.0</p> 
  <p>（切记：版本要与fabric对应住）</p> 
  <p>docker images 查看镜像列表</p> 
  <h1>4． 启动fabric网络并测试chaincode</h1> 
  <h2>4.1 傻瓜式安装</h2> 
  <p>./network_setup.sh up</p> 
  <p>该过程主要做了以下操作</p> 
  <p>1）&nbsp;&nbsp;生成公私钥和证书</p> 
  <p>2）&nbsp;&nbsp;生成创世区块和channel通道配置信息</p> 
  <p>3）&nbsp;&nbsp;启动fabric环境的容器</p> 
  <p>4）&nbsp;&nbsp;创建通道</p> 
  <p>5）&nbsp;&nbsp;各个peer加入通道</p> 
  <p>6）&nbsp;&nbsp;安装链上代码</p> 
  <p>7）&nbsp;&nbsp;实例化代码</p> 
  <h2>4.2 手动分步骤安装</h2> 
  <h3>4.2.1生成公私钥和证书</h3> 
  <p>1）编译生成cryptogen</p> 
  <p><span style="color:#4ea1db;">cd /home/hadoop/gopath/src/github.com/hyperledger/fabric</span></p> 
  <p>make cryptogen</p> 
  <p>运行后返回结果</p> 
  <p><em>build/bin/cryptogen </em></p> 
  <p><em>CGO_CFLAGS="" GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin goinstall -tags "" -ldflags "-Xgithub.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0"github.com/hyperledger/fabric/common/tools/cryptogen </em></p> 
  <p><em>Binary available asbuild/bin/cryptogen</em></p> 
  <p>2）生成公私钥和证书</p> 
  <p>cd examples/e2e_cli/</p> 
  <p>../../build/bin/cryptogen generate--config=./crypto-config.yaml</p> 
  <p>此时生成了公私钥，并保存在crypto-config文件中</p> 
  <pre>
<code class="language-html hljs">tree crypto-config查看生成的证书</code></pre> 
  <h3>4.2.2生成创世区块和channel通道配置信息</h3> 
  <p>1）编译生成configtxgen</p> 
  <p>cd /home/hadoop/gopath/src/github.com/hyperledger/fabric</p> 
  <p>make configtxgen</p> 
  <p>运行后结果</p> 
  <p><em>build/bin/configtxgen </em></p> 
  <p><em>CGO_CFLAGS=" "GOBIN=/home/studyzy/go/src/github.com/hyperledger/fabric/build/bin go install-tags "nopkcs11" -ldflags "-Xgithub.com/hyperledger/fabric/common/configtx/tool/configtxgen/metadata.Version=1.0.0"github.com/hyperledger/fabric/common/configtx/tool/configtxgen </em></p> 
  <p><em>Binary available as build/bin/configtxgen</em></p> 
  <p>2）生成创世区块</p> 
  <p>cd examples/e2e_cli/</p> 
  <p>../../build/bin/configtxgen -profileTwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block</p> 
  <p>3）生成channel通道配置</p> 
  <p>../../build/bin/configtxgen -profileTwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelIDmychannel</p> 
  <p>4）另外关于锚节点更新，我们也需要使用这个程序来生成文件</p> 
  <p>../../build/bin/configtxgen -profileTwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx-channelID mychannel -asOrg Org1MSP</p> 
  <p>../../build/bin/configtxgen -profileTwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx-channelID mychannel -asOrg Org2MSP</p> 
  <p>两个组织，生成两个锚节点</p> 
  <p>&nbsp;</p> 
  <p>此时能看到channel-artifacts下四个文件</p> 
  <p>channel-artifacts/</p> 
  <p>├── channel.tx</p> 
  <p>├── genesis.block</p> 
  <p>├── Org1MSPanchors.tx</p> 
  <p>└── Org2MSPanchors.tx</p> 
  <h3>4.2.3 启动fabric docker环境的容器</h3> 
  <p>由于手动部署，启动前需要将<a name="OLE_LINK17">docker-compose-cli.yaml</a>中信息更改</p> 
  <p>vim docker-compose-cli.yaml</p> 
  <p>注释掉command: /bin/bash -c './scripts/script.sh${CHANNEL_NAME}; sleep $TIMEOUT'</p> 
  <p>另更正一个错误 /base/peer.yaml中将network信息elecli_default改为ele_cli_default（ele_cli文件夹的默认网络名称）</p> 
  <p>docker-compose -f docker-compose-cli.yaml up-d</p> 
  <p>此时显示启动了四个peer，一个orderer，一个cli客户端</p> 
  <h3>4.2.4 创建channel，各peer加入通道</h3> 
  <p>1）创建channel</p> 
  <p>docker exec -it cli bash 进入客户端容器</p> 
  <p>创建Channel的命令是peer channelcreate，我们前面创建2.4创建Channel的配置区块时，指定了Channel的名字是mychannel，那么这里我们必须创建同样名字的channel。</p> 
  <p>&nbsp;</p> 
  <p>ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</p> 
  <p>peer channel create -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tlstrue --cafile $ORDERER_CA</p> 
  <p>此时创建成功一个maychannel.block文件，其他peer节点加入都需要该文件</p> 
  <p>2）各peer加入channel</p> 
  <p>peerchannel join -b mychannel.block （CLI客户端默认链接peer0.org1，因此该节点加入比较简单）</p> 
  <p>其他节点加入（以peer1.org1为例）：</p> 
  <p>CLI指向peer1.org1</p> 
  <p>CORE_PEER_LOCALMSPID="Org1MSP"</p> 
  <p>CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/<span style="color:#ff0000;">peer1.org1</span>.example.com/tls/ca.crt</p> 
  <p>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</p> 
  <p>CORE_PEER_ADDRESS=<span style="color:#ff0000;">peer1.org1.</span>example.com:7051</p> 
  <p>加入通道：</p> 
  <p>peerchannel join -b mychannel.block</p> 
  <p>依次将所有peer节点加入通道</p> 
  <p>3）更新锚节点</p> 
  <p>对于Org1来说，peer0.org1是锚节点，我们需要连接上它并更新锚节点：</p> 
  <p>CORE_PEER_LOCALMSPID="Org1MSP"</p> 
  <p>CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</p> 
  <p>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</p> 
  <p>CORE_PEER_ADDRESS=peer0.org1.example.com:7051</p> 
  <p>&nbsp;</p> 
  <p>peer channel update -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx--tls true --cafile $ORDERER_CA</p> 
  <p>对于Org2，peer0.org2是锚节点，对应的更新代码是：</p> 
  <p>CORE_PEER_LOCALMSPID="Org2MSP"</p> 
  <p>CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</p> 
  <p>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</p> 
  <p>CORE_PEER_ADDRESS=peer0.org2.example.com:7051</p> 
  <p>&nbsp;</p> 
  <p>peer channel update -oorderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx--tls true --cafile $ORDERER_CA</p> 
  <h3>4.2.5 安装链上代码（共识算法）及实例化测试</h3> 
  <p>1） 安装链码</p> 
  <p>对需要共识的peer节点都要安装链码</p> 
  <p>以peer0.org1为例，先切换至该节点：</p> 
  <p>CORE_PEER_LOCALMSPID="Org1MSP"</p> 
  <p>CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</p> 
  <p>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</p> 
  <p>CORE_PEER_ADDRESS=peer0.org1.example.com:7051</p> 
  <p>安装链码：</p> 
  <p>peer chaincode install -n mycc -v 1.0 -pgithub.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</p> 
  <p>2）实例化链码</p> 
  <p>对链上代码实例化，生成对应通道，对应链码的docker镜像和容器，并指定背书策略</p> 
  <p>peer chaincode instantiate -oorderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n mycc-v 1.0 -c'{"Args":["init","a","100","b","200"]}'-P "OR ('Org1MSP.member','Org2MSP.member')"</p> 
  <p>此时，dockerps可以看到多了一个dev的容器，如果再开一个peer，则再多一个dev容器</p> 
  <p>3）交易</p> 
  <p>在peer0.org1上发起交易</p> 
  <pre>
<code class="language-html hljs">查询a的余额，peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'</code></pre> 
  <p>返回结果</p> 
  <p>Query result： 100</p> 
  <p>转账：a向b转账10元</p> 
  <p>peer chaincode invoke -oorderer.example.com:7050&nbsp; --tls true--cafile $ORDERER_CA -C mychannel -n mycc -c'{"Args":["invoke","a","b","10"]}'</p> 
  <p>在另一个节点查询：</p> 
  <p>首先CLI指向peer1.org2并安装链码，然后查询</p> 
  <p>peer chaincode query -C mychannel -n mycc -c'{"Args":["query","a"]}'</p> 
  <p>需要较长时间（几十秒）</p> 
  <h1>5. 报错信息</h1> 
  <p>root@namenode:/home/hadoop/gopath/src/github.com/hyperledger/fabric#make cryptogen</p> 
  <p>build/bin/cryptogen</p> 
  <p>CGO_CFLAGS=" "GOBIN=/home/hadoop/gopath/src/github.com/hyperledger/fabric/build/bin goinstall -tags "" -ldflags "-Xgithub.com/hyperledger/fabric/common/tools/cryptogen/metadata.Version=1.0.0"github.com/hyperledger/fabric/common/tools/cryptogen</p> 
  <p>#github.com/hyperledger/fabric/vendor/github.com/miekg/pkcs11</p> 
  <p>vendor/github.com/miekg/pkcs11/pkcs11.go:29:18:fatal error: ltdl.h: No such file or directory</p> 
  <p>compilation terminated.</p> 
  <p>Makefile:227: recipe for target'build/bin/cryptogen' failed</p> 
  <p>make: *** [build/bin/cryptogen] Error2</p> 
  <p>&nbsp;</p> 
  <p>解决：下载安装libltdl-dev</p> 
  <p><strong>apt-get install libtool libltdl-dev</strong></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>参考：<a href="https://www.cnblogs.com/studyzy/p/7451276.html" rel="nofollow">https://www.cnblogs.com/studyzy/p/7451276.html</a></p> 
  <p>https://www.jianshu.com/p/16903ed42f17</p> 
  <p>&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_30852577/article/details/80896031,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_30852577/article/details/80896031,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
