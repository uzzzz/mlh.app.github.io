<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>fabric源码阅读第二篇上 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="fabric源码阅读第二篇上" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="今天讲fabric的创世块的源码 主要围绕这个命令 ：export FABRIC_CFG_PATH=$PWD ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 生成创世块 main的方法在 /fabric/common/tools/configtxgen包下的 func main() { //定义变量用户接受命令参数 var outputBlock, outputChannelCreateTx, profile, configPath, channelID, inspectBlock, inspectChannelCreateTx, outputAnchorPeersUpdate, asOrg, printOrg string flag.StringVar(&amp;outputBlock, &quot;outputBlock&quot;, &quot;&quot;, &quot;The path to write the genesis block to (if set)&quot;) flag.StringVar(&amp;channelID, &quot;channelID&quot;, &quot;&quot;, &quot;The channel ID to use in the configtx&quot;) flag.StringVar(&amp;outputChannelCreateTx, &quot;outputCreateChannelTx&quot;, &quot;&quot;, &quot;The path to write a channel creation configtx to (if set)&quot;) flag.StringVar(&amp;profile, &quot;profile&quot;, genesisconfig.SampleInsecureSoloProfile, &quot;The profile from configtx.yaml to use for generation.&quot;) flag.StringVar(&amp;configPath, &quot;configPath&quot;, &quot;&quot;, &quot;The path containing the configuration to use (if set)&quot;) flag.StringVar(&amp;inspectBlock, &quot;inspectBlock&quot;, &quot;&quot;, &quot;Prints the configuration contained in the block at the specified path&quot;) flag.StringVar(&amp;inspectChannelCreateTx, &quot;inspectChannelCreateTx&quot;, &quot;&quot;, &quot;Prints the configuration contained in the transaction at the specified path&quot;) flag.StringVar(&amp;outputAnchorPeersUpdate, &quot;outputAnchorPeersUpdate&quot;, &quot;&quot;, &quot;Creates an config update to update an anchor peer (works only with the default channel creation, and only for the first update)&quot;) flag.StringVar(&amp;asOrg, &quot;asOrg&quot;, &quot;&quot;, &quot;Performs the config generation as a particular organization (by name), only including values in the write set that org (likely) has privilege to set&quot;) flag.StringVar(&amp;printOrg, &quot;printOrg&quot;, &quot;&quot;, &quot;Prints the definition of an organization as JSON. (useful for adding an org to a channel manually)&quot;) version := flag.Bool(&quot;version&quot;, false, &quot;Show version information&quot;) flag.Parse()//接收到的参数，解析，然后上面所有的变量都会获得相对应的值 if channelID == &quot;&quot; { channelID = genesisconfig.TestChainID//设置channelId logger.Warningf(&quot;Omitting the channel ID for configtxgen is deprecated. Explicitly passing the channel ID will be required in the future, defaulting to &#39;%s&#39;.&quot;, channelID) } // show version if *version { printVersion()//打印版本信息 os.Exit(exitCode) } logging.SetLevel(logging.INFO, &quot;&quot;) // don&#39;t need to panic when running via command line defer func() { if err := recover(); err != nil { if strings.Contains(fmt.Sprint(err), &quot;Error reading configuration: Unsupported Config Type&quot;) { logger.Error(&quot;Could not find configtx.yaml. &quot; + &quot;Please make sure that FABRIC_CFG_PATH or --configPath is set to a path &quot; + &quot;which contains configtx.yaml&quot;) os.Exit(1) } if strings.Contains(fmt.Sprint(err), &quot;Could not find profile&quot;) { logger.Error(fmt.Sprint(err) + &quot;. &quot; + &quot;Please make sure that FABRIC_CFG_PATH or --configPath is set to a path &quot; + &quot;which contains configtx.yaml with the specified profile&quot;) os.Exit(1) } logger.Panic(err) } }() logger.Info(&quot;Loading configuration&quot;) factory.InitFactories(nil)//初始化算法工厂 var profileConfig *genesisconfig.Profile if outputBlock != &quot;&quot; || outputChannelCreateTx != &quot;&quot; || outputAnchorPeersUpdate != &quot;&quot; { if configPath != &quot;&quot; { profileConfig = genesisconfig.Load(profile, configPath)//load配置文件 } else { profileConfig = genesisconfig.Load(profile) } } var topLevelConfig *genesisconfig.TopLevel if configPath != &quot;&quot; { topLevelConfig = genesisconfig.LoadTopLevel(configPath) } else { topLevelConfig = genesisconfig.LoadTopLevel() } //生成创世块 if outputBlock != &quot;&quot; { if err := doOutputBlock(profileConfig, channelID, outputBlock); err != nil { logger.Fatalf(&quot;Error on outputBlock: %s&quot;, err) } } //创建通道配置文件 if outputChannelCreateTx != &quot;&quot; { if err := doOutputChannelCreateTx(profileConfig, channelID, outputChannelCreateTx); err != nil { logger.Fatalf(&quot;Error on outputChannelCreateTx: %s&quot;, err) } } //验证创世块 if inspectBlock != &quot;&quot; { if err := doInspectBlock(inspectBlock); err != nil { logger.Fatalf(&quot;Error on inspectBlock: %s&quot;, err) } } //验证通道配置文件 if inspectChannelCreateTx != &quot;&quot; { if err := doInspectChannelCreateTx(inspectChannelCreateTx); err != nil { logger.Fatalf(&quot;Error on inspectChannelCreateTx: %s&quot;, err) } } //更新Peer节点 if outputAnchorPeersUpdate != &quot;&quot; { if err := doOutputAnchorPeersUpdate(profileConfig, channelID, outputAnchorPeersUpdate, asOrg); err != nil { logger.Fatalf(&quot;Error on inspectChannelCreateTx: %s&quot;, err) } } //打印org if printOrg != &quot;&quot; { if err := doPrintOrg(topLevelConfig, printOrg); err != nil { logger.Fatalf(&quot;Error on printOrg: %s&quot;, err) } } } flag 和kingpin的包作用一样，不知道为什么一个源码会有两种命令的生成方式。 我们看一下genesisconfig 这个是在 configtxgen/localconfig/config.go中 func LoadTopLevel(configPaths ...string) *TopLevel { config := viper.New()//创建一个Viper对象 if len(configPaths) &gt; 0 { for _, p := range configPaths { config.AddConfigPath(p) } config.SetConfigName(configName)//设置configName } else { cf.InitViper(config, configName)如果没有传路径，那就生成一个。 } // For environment variables config.SetEnvPrefix(Prefix)//设置环境变量 config.AutomaticEnv() replacer := strings.NewReplacer(&quot;.&quot;, &quot;_&quot;)//替换 config.SetEnvKeyReplacer(replacer)//设置key err := config.ReadInConfig()//读取配置文件 if err != nil { logger.Panic(&quot;Error reading configuration: &quot;, err) } logger.Debugf(&quot;Using config file: %s&quot;, config.ConfigFileUsed()) var uconf TopLevel err = viperutil.EnhancedExactUnmarshal(config, &amp;uconf)//构件DecoderConfig对象 if err != nil { logger.Panic(&quot;Error unmarshaling config into struct: &quot;, err) } (&amp;uconf).completeInitialization(filepath.Dir(config.ConfigFileUsed()))//初始化 logger.Infof(&quot;Loaded configuration: %s&quot;, config.ConfigFileUsed()) return &amp;uconf//返回配置文件 } 再看doOutputBlock（）方法 func doOutputBlock(config *genesisconfig.Profile, channelID string, outputBlock string) error { pgen := encoder.New(config)//配置文件加密 logger.Info(&quot;Generating genesis block&quot;) if config.Consortiums == nil { logger.Warning(&quot;Genesis block does not contain a consortiums group definition. This block cannot be used for orderer bootstrap.&quot;) } genesisBlock := pgen.GenesisBlockForChannel(channelID)//根据通道id生成block. logger.Info(&quot;Writing genesis block&quot;) err := ioutil.WriteFile(outputBlock, utils.MarshalOrPanic(genesisBlock), 0644)//把创世块保存到文件 if err != nil { return fmt.Errorf(&quot;Error writing genesis block: %s&quot;, err) } return nil } 然后看一下 encoder.New(config) 方法 func New(config *genesisconfig.Profile) *Bootstrapper { channelGroup, err := NewChannelGroup(config)//创建一个通道的数组 if err != nil { logger.Panicf(&quot;Error creating channel group: %s&quot;, err) } return &amp;Bootstrapper{//返回bootstrapper对象 channelGroup: channelGroup, } } 然后看一下&nbsp;NewChannelGroup（）方法（生成一个通道分组） func NewChannelGroup(conf *genesisconfig.Profile) (*cb.ConfigGroup, error) { if conf.Orderer == nil {//conf配置文件的orderer return nil, errors.New(&quot;missing orderer config section&quot;) } channelGroup := cb.NewConfigGroup()//创建一个新的对象 if len(conf.Policies) == 0 { logger.Warningf(&quot;Default policy emission is deprecated, please include policy specificiations for the channel group in configtx.yaml&quot;) addImplicitMetaPolicyDefaults(channelGroup) } else { if err := addPolicies(channelGroup, conf.Policies, channelconfig.AdminsPolicyKey); err != nil { return nil, errors.Wrapf(err, &quot;error adding policies to channel group&quot;) } } addValue(channelGroup, channelconfig.HashingAlgorithmValue(), channelconfig.AdminsPolicyKey) addValue(channelGroup, channelconfig.BlockDataHashingStructureValue(), channelconfig.AdminsPolicyKey) addValue(channelGroup, channelconfig.OrdererAddressesValue(conf.Orderer.Addresses), ordererAdminsPolicyName) if conf.Consortium != &quot;&quot; { addValue(channelGroup, channelconfig.ConsortiumValue(conf.Consortium), channelconfig.AdminsPolicyKey) } if len(conf.Capabilities) &gt; 0 { addValue(channelGroup, channelconfig.CapabilitiesValue(conf.Capabilities), channelconfig.AdminsPolicyKey) } var err error channelGroup.Groups[channelconfig.OrdererGroupKey], err = NewOrdererGroup(conf.Orderer) if err != nil { return nil, errors.Wrap(err, &quot;could not create orderer group&quot;) } if conf.Application != nil { channelGroup.Groups[channelconfig.ApplicationGroupKey], err = NewApplicationGroup(conf.Application) if err != nil { return nil, errors.Wrap(err, &quot;could not create application group&quot;) } } if conf.Consortiums != nil { channelGroup.Groups[channelconfig.ConsortiumsGroupKey], err = NewConsortiumsGroup(conf.Consortiums) if err != nil { return nil, errors.Wrap(err, &quot;could not create consortiums group&quot;) } } channelGroup.ModPolicy = channelconfig.AdminsPolicyKey return channelGroup, nil } 我们看一下GenesisBlockForChannel（）方法，为通道创建初始化块 func (bs *Bootstrapper) GenesisBlockForChannel(channelID string) *cb.Block { block, err := genesis.NewFactoryImpl(bs.channelGroup).Block(channelID) if err != nil { logger.Panicf(&quot;Error creating genesis block from channel group: %s&quot;, err) } return block } 这个方法的实现在 、common/genesis/genesis.go中 // NewFactoryImpl creates a new Factory. func NewFactoryImpl(channelGroup *cb.ConfigGroup) Factory { return &amp;factory{channelGroup: channelGroup} } // Block constructs and returns a genesis block for a given channel ID. func (f *factory) Block(channelID string) (*cb.Block, error) { payloadChannelHeader := utils.MakeChannelHeader(cb.HeaderType_CONFIG, msgVersion, channelID, epoch)//创建通道header payloadSignatureHeader := utils.MakeSignatureHeader(nil, utils.CreateNonceOrPanic())//创建签名header utils.SetTxID(payloadChannelHeader, payloadSignatureHeader)//设置TXId payloadHeader := utils.MakePayloadHeader(payloadChannelHeader, payloadSignatureHeader) payload := &amp;cb.Payload{Header: payloadHeader, Data: utils.MarshalOrPanic(&amp;cb.ConfigEnvelope{Config: &amp;cb.Config{ChannelGroup: f.channelGroup}})} envelope := &amp;cb.Envelope{Payload: utils.MarshalOrPanic(payload), Signature: nil} block := cb.NewBlock(0, nil)//生成创世块 block.Data = &amp;cb.BlockData{Data: [][]byte{utils.MarshalOrPanic(envelope)}} block.Header.DataHash = block.Data.Hash() block.Metadata.Metadata[cb.BlockMetadataIndex_LAST_CONFIG] = utils.MarshalOrPanic(&amp;cb.Metadata{ Value: utils.MarshalOrPanic(&amp;cb.LastConfig{Index: 0}), }) return block, nil } 先讲到证书的创世块的生成。里面有很多不是很明了的东西，后面我们会再做一个详细的讲解。 阅读更多" />
<meta property="og:description" content="今天讲fabric的创世块的源码 主要围绕这个命令 ：export FABRIC_CFG_PATH=$PWD ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 生成创世块 main的方法在 /fabric/common/tools/configtxgen包下的 func main() { //定义变量用户接受命令参数 var outputBlock, outputChannelCreateTx, profile, configPath, channelID, inspectBlock, inspectChannelCreateTx, outputAnchorPeersUpdate, asOrg, printOrg string flag.StringVar(&amp;outputBlock, &quot;outputBlock&quot;, &quot;&quot;, &quot;The path to write the genesis block to (if set)&quot;) flag.StringVar(&amp;channelID, &quot;channelID&quot;, &quot;&quot;, &quot;The channel ID to use in the configtx&quot;) flag.StringVar(&amp;outputChannelCreateTx, &quot;outputCreateChannelTx&quot;, &quot;&quot;, &quot;The path to write a channel creation configtx to (if set)&quot;) flag.StringVar(&amp;profile, &quot;profile&quot;, genesisconfig.SampleInsecureSoloProfile, &quot;The profile from configtx.yaml to use for generation.&quot;) flag.StringVar(&amp;configPath, &quot;configPath&quot;, &quot;&quot;, &quot;The path containing the configuration to use (if set)&quot;) flag.StringVar(&amp;inspectBlock, &quot;inspectBlock&quot;, &quot;&quot;, &quot;Prints the configuration contained in the block at the specified path&quot;) flag.StringVar(&amp;inspectChannelCreateTx, &quot;inspectChannelCreateTx&quot;, &quot;&quot;, &quot;Prints the configuration contained in the transaction at the specified path&quot;) flag.StringVar(&amp;outputAnchorPeersUpdate, &quot;outputAnchorPeersUpdate&quot;, &quot;&quot;, &quot;Creates an config update to update an anchor peer (works only with the default channel creation, and only for the first update)&quot;) flag.StringVar(&amp;asOrg, &quot;asOrg&quot;, &quot;&quot;, &quot;Performs the config generation as a particular organization (by name), only including values in the write set that org (likely) has privilege to set&quot;) flag.StringVar(&amp;printOrg, &quot;printOrg&quot;, &quot;&quot;, &quot;Prints the definition of an organization as JSON. (useful for adding an org to a channel manually)&quot;) version := flag.Bool(&quot;version&quot;, false, &quot;Show version information&quot;) flag.Parse()//接收到的参数，解析，然后上面所有的变量都会获得相对应的值 if channelID == &quot;&quot; { channelID = genesisconfig.TestChainID//设置channelId logger.Warningf(&quot;Omitting the channel ID for configtxgen is deprecated. Explicitly passing the channel ID will be required in the future, defaulting to &#39;%s&#39;.&quot;, channelID) } // show version if *version { printVersion()//打印版本信息 os.Exit(exitCode) } logging.SetLevel(logging.INFO, &quot;&quot;) // don&#39;t need to panic when running via command line defer func() { if err := recover(); err != nil { if strings.Contains(fmt.Sprint(err), &quot;Error reading configuration: Unsupported Config Type&quot;) { logger.Error(&quot;Could not find configtx.yaml. &quot; + &quot;Please make sure that FABRIC_CFG_PATH or --configPath is set to a path &quot; + &quot;which contains configtx.yaml&quot;) os.Exit(1) } if strings.Contains(fmt.Sprint(err), &quot;Could not find profile&quot;) { logger.Error(fmt.Sprint(err) + &quot;. &quot; + &quot;Please make sure that FABRIC_CFG_PATH or --configPath is set to a path &quot; + &quot;which contains configtx.yaml with the specified profile&quot;) os.Exit(1) } logger.Panic(err) } }() logger.Info(&quot;Loading configuration&quot;) factory.InitFactories(nil)//初始化算法工厂 var profileConfig *genesisconfig.Profile if outputBlock != &quot;&quot; || outputChannelCreateTx != &quot;&quot; || outputAnchorPeersUpdate != &quot;&quot; { if configPath != &quot;&quot; { profileConfig = genesisconfig.Load(profile, configPath)//load配置文件 } else { profileConfig = genesisconfig.Load(profile) } } var topLevelConfig *genesisconfig.TopLevel if configPath != &quot;&quot; { topLevelConfig = genesisconfig.LoadTopLevel(configPath) } else { topLevelConfig = genesisconfig.LoadTopLevel() } //生成创世块 if outputBlock != &quot;&quot; { if err := doOutputBlock(profileConfig, channelID, outputBlock); err != nil { logger.Fatalf(&quot;Error on outputBlock: %s&quot;, err) } } //创建通道配置文件 if outputChannelCreateTx != &quot;&quot; { if err := doOutputChannelCreateTx(profileConfig, channelID, outputChannelCreateTx); err != nil { logger.Fatalf(&quot;Error on outputChannelCreateTx: %s&quot;, err) } } //验证创世块 if inspectBlock != &quot;&quot; { if err := doInspectBlock(inspectBlock); err != nil { logger.Fatalf(&quot;Error on inspectBlock: %s&quot;, err) } } //验证通道配置文件 if inspectChannelCreateTx != &quot;&quot; { if err := doInspectChannelCreateTx(inspectChannelCreateTx); err != nil { logger.Fatalf(&quot;Error on inspectChannelCreateTx: %s&quot;, err) } } //更新Peer节点 if outputAnchorPeersUpdate != &quot;&quot; { if err := doOutputAnchorPeersUpdate(profileConfig, channelID, outputAnchorPeersUpdate, asOrg); err != nil { logger.Fatalf(&quot;Error on inspectChannelCreateTx: %s&quot;, err) } } //打印org if printOrg != &quot;&quot; { if err := doPrintOrg(topLevelConfig, printOrg); err != nil { logger.Fatalf(&quot;Error on printOrg: %s&quot;, err) } } } flag 和kingpin的包作用一样，不知道为什么一个源码会有两种命令的生成方式。 我们看一下genesisconfig 这个是在 configtxgen/localconfig/config.go中 func LoadTopLevel(configPaths ...string) *TopLevel { config := viper.New()//创建一个Viper对象 if len(configPaths) &gt; 0 { for _, p := range configPaths { config.AddConfigPath(p) } config.SetConfigName(configName)//设置configName } else { cf.InitViper(config, configName)如果没有传路径，那就生成一个。 } // For environment variables config.SetEnvPrefix(Prefix)//设置环境变量 config.AutomaticEnv() replacer := strings.NewReplacer(&quot;.&quot;, &quot;_&quot;)//替换 config.SetEnvKeyReplacer(replacer)//设置key err := config.ReadInConfig()//读取配置文件 if err != nil { logger.Panic(&quot;Error reading configuration: &quot;, err) } logger.Debugf(&quot;Using config file: %s&quot;, config.ConfigFileUsed()) var uconf TopLevel err = viperutil.EnhancedExactUnmarshal(config, &amp;uconf)//构件DecoderConfig对象 if err != nil { logger.Panic(&quot;Error unmarshaling config into struct: &quot;, err) } (&amp;uconf).completeInitialization(filepath.Dir(config.ConfigFileUsed()))//初始化 logger.Infof(&quot;Loaded configuration: %s&quot;, config.ConfigFileUsed()) return &amp;uconf//返回配置文件 } 再看doOutputBlock（）方法 func doOutputBlock(config *genesisconfig.Profile, channelID string, outputBlock string) error { pgen := encoder.New(config)//配置文件加密 logger.Info(&quot;Generating genesis block&quot;) if config.Consortiums == nil { logger.Warning(&quot;Genesis block does not contain a consortiums group definition. This block cannot be used for orderer bootstrap.&quot;) } genesisBlock := pgen.GenesisBlockForChannel(channelID)//根据通道id生成block. logger.Info(&quot;Writing genesis block&quot;) err := ioutil.WriteFile(outputBlock, utils.MarshalOrPanic(genesisBlock), 0644)//把创世块保存到文件 if err != nil { return fmt.Errorf(&quot;Error writing genesis block: %s&quot;, err) } return nil } 然后看一下 encoder.New(config) 方法 func New(config *genesisconfig.Profile) *Bootstrapper { channelGroup, err := NewChannelGroup(config)//创建一个通道的数组 if err != nil { logger.Panicf(&quot;Error creating channel group: %s&quot;, err) } return &amp;Bootstrapper{//返回bootstrapper对象 channelGroup: channelGroup, } } 然后看一下&nbsp;NewChannelGroup（）方法（生成一个通道分组） func NewChannelGroup(conf *genesisconfig.Profile) (*cb.ConfigGroup, error) { if conf.Orderer == nil {//conf配置文件的orderer return nil, errors.New(&quot;missing orderer config section&quot;) } channelGroup := cb.NewConfigGroup()//创建一个新的对象 if len(conf.Policies) == 0 { logger.Warningf(&quot;Default policy emission is deprecated, please include policy specificiations for the channel group in configtx.yaml&quot;) addImplicitMetaPolicyDefaults(channelGroup) } else { if err := addPolicies(channelGroup, conf.Policies, channelconfig.AdminsPolicyKey); err != nil { return nil, errors.Wrapf(err, &quot;error adding policies to channel group&quot;) } } addValue(channelGroup, channelconfig.HashingAlgorithmValue(), channelconfig.AdminsPolicyKey) addValue(channelGroup, channelconfig.BlockDataHashingStructureValue(), channelconfig.AdminsPolicyKey) addValue(channelGroup, channelconfig.OrdererAddressesValue(conf.Orderer.Addresses), ordererAdminsPolicyName) if conf.Consortium != &quot;&quot; { addValue(channelGroup, channelconfig.ConsortiumValue(conf.Consortium), channelconfig.AdminsPolicyKey) } if len(conf.Capabilities) &gt; 0 { addValue(channelGroup, channelconfig.CapabilitiesValue(conf.Capabilities), channelconfig.AdminsPolicyKey) } var err error channelGroup.Groups[channelconfig.OrdererGroupKey], err = NewOrdererGroup(conf.Orderer) if err != nil { return nil, errors.Wrap(err, &quot;could not create orderer group&quot;) } if conf.Application != nil { channelGroup.Groups[channelconfig.ApplicationGroupKey], err = NewApplicationGroup(conf.Application) if err != nil { return nil, errors.Wrap(err, &quot;could not create application group&quot;) } } if conf.Consortiums != nil { channelGroup.Groups[channelconfig.ConsortiumsGroupKey], err = NewConsortiumsGroup(conf.Consortiums) if err != nil { return nil, errors.Wrap(err, &quot;could not create consortiums group&quot;) } } channelGroup.ModPolicy = channelconfig.AdminsPolicyKey return channelGroup, nil } 我们看一下GenesisBlockForChannel（）方法，为通道创建初始化块 func (bs *Bootstrapper) GenesisBlockForChannel(channelID string) *cb.Block { block, err := genesis.NewFactoryImpl(bs.channelGroup).Block(channelID) if err != nil { logger.Panicf(&quot;Error creating genesis block from channel group: %s&quot;, err) } return block } 这个方法的实现在 、common/genesis/genesis.go中 // NewFactoryImpl creates a new Factory. func NewFactoryImpl(channelGroup *cb.ConfigGroup) Factory { return &amp;factory{channelGroup: channelGroup} } // Block constructs and returns a genesis block for a given channel ID. func (f *factory) Block(channelID string) (*cb.Block, error) { payloadChannelHeader := utils.MakeChannelHeader(cb.HeaderType_CONFIG, msgVersion, channelID, epoch)//创建通道header payloadSignatureHeader := utils.MakeSignatureHeader(nil, utils.CreateNonceOrPanic())//创建签名header utils.SetTxID(payloadChannelHeader, payloadSignatureHeader)//设置TXId payloadHeader := utils.MakePayloadHeader(payloadChannelHeader, payloadSignatureHeader) payload := &amp;cb.Payload{Header: payloadHeader, Data: utils.MarshalOrPanic(&amp;cb.ConfigEnvelope{Config: &amp;cb.Config{ChannelGroup: f.channelGroup}})} envelope := &amp;cb.Envelope{Payload: utils.MarshalOrPanic(payload), Signature: nil} block := cb.NewBlock(0, nil)//生成创世块 block.Data = &amp;cb.BlockData{Data: [][]byte{utils.MarshalOrPanic(envelope)}} block.Header.DataHash = block.Data.Hash() block.Metadata.Metadata[cb.BlockMetadataIndex_LAST_CONFIG] = utils.MarshalOrPanic(&amp;cb.Metadata{ Value: utils.MarshalOrPanic(&amp;cb.LastConfig{Index: 0}), }) return block, nil } 先讲到证书的创世块的生成。里面有很多不是很明了的东西，后面我们会再做一个详细的讲解。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"今天讲fabric的创世块的源码 主要围绕这个命令 ：export FABRIC_CFG_PATH=$PWD ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 生成创世块 main的方法在 /fabric/common/tools/configtxgen包下的 func main() { //定义变量用户接受命令参数 var outputBlock, outputChannelCreateTx, profile, configPath, channelID, inspectBlock, inspectChannelCreateTx, outputAnchorPeersUpdate, asOrg, printOrg string flag.StringVar(&amp;outputBlock, &quot;outputBlock&quot;, &quot;&quot;, &quot;The path to write the genesis block to (if set)&quot;) flag.StringVar(&amp;channelID, &quot;channelID&quot;, &quot;&quot;, &quot;The channel ID to use in the configtx&quot;) flag.StringVar(&amp;outputChannelCreateTx, &quot;outputCreateChannelTx&quot;, &quot;&quot;, &quot;The path to write a channel creation configtx to (if set)&quot;) flag.StringVar(&amp;profile, &quot;profile&quot;, genesisconfig.SampleInsecureSoloProfile, &quot;The profile from configtx.yaml to use for generation.&quot;) flag.StringVar(&amp;configPath, &quot;configPath&quot;, &quot;&quot;, &quot;The path containing the configuration to use (if set)&quot;) flag.StringVar(&amp;inspectBlock, &quot;inspectBlock&quot;, &quot;&quot;, &quot;Prints the configuration contained in the block at the specified path&quot;) flag.StringVar(&amp;inspectChannelCreateTx, &quot;inspectChannelCreateTx&quot;, &quot;&quot;, &quot;Prints the configuration contained in the transaction at the specified path&quot;) flag.StringVar(&amp;outputAnchorPeersUpdate, &quot;outputAnchorPeersUpdate&quot;, &quot;&quot;, &quot;Creates an config update to update an anchor peer (works only with the default channel creation, and only for the first update)&quot;) flag.StringVar(&amp;asOrg, &quot;asOrg&quot;, &quot;&quot;, &quot;Performs the config generation as a particular organization (by name), only including values in the write set that org (likely) has privilege to set&quot;) flag.StringVar(&amp;printOrg, &quot;printOrg&quot;, &quot;&quot;, &quot;Prints the definition of an organization as JSON. (useful for adding an org to a channel manually)&quot;) version := flag.Bool(&quot;version&quot;, false, &quot;Show version information&quot;) flag.Parse()//接收到的参数，解析，然后上面所有的变量都会获得相对应的值 if channelID == &quot;&quot; { channelID = genesisconfig.TestChainID//设置channelId logger.Warningf(&quot;Omitting the channel ID for configtxgen is deprecated. Explicitly passing the channel ID will be required in the future, defaulting to &#39;%s&#39;.&quot;, channelID) } // show version if *version { printVersion()//打印版本信息 os.Exit(exitCode) } logging.SetLevel(logging.INFO, &quot;&quot;) // don&#39;t need to panic when running via command line defer func() { if err := recover(); err != nil { if strings.Contains(fmt.Sprint(err), &quot;Error reading configuration: Unsupported Config Type&quot;) { logger.Error(&quot;Could not find configtx.yaml. &quot; + &quot;Please make sure that FABRIC_CFG_PATH or --configPath is set to a path &quot; + &quot;which contains configtx.yaml&quot;) os.Exit(1) } if strings.Contains(fmt.Sprint(err), &quot;Could not find profile&quot;) { logger.Error(fmt.Sprint(err) + &quot;. &quot; + &quot;Please make sure that FABRIC_CFG_PATH or --configPath is set to a path &quot; + &quot;which contains configtx.yaml with the specified profile&quot;) os.Exit(1) } logger.Panic(err) } }() logger.Info(&quot;Loading configuration&quot;) factory.InitFactories(nil)//初始化算法工厂 var profileConfig *genesisconfig.Profile if outputBlock != &quot;&quot; || outputChannelCreateTx != &quot;&quot; || outputAnchorPeersUpdate != &quot;&quot; { if configPath != &quot;&quot; { profileConfig = genesisconfig.Load(profile, configPath)//load配置文件 } else { profileConfig = genesisconfig.Load(profile) } } var topLevelConfig *genesisconfig.TopLevel if configPath != &quot;&quot; { topLevelConfig = genesisconfig.LoadTopLevel(configPath) } else { topLevelConfig = genesisconfig.LoadTopLevel() } //生成创世块 if outputBlock != &quot;&quot; { if err := doOutputBlock(profileConfig, channelID, outputBlock); err != nil { logger.Fatalf(&quot;Error on outputBlock: %s&quot;, err) } } //创建通道配置文件 if outputChannelCreateTx != &quot;&quot; { if err := doOutputChannelCreateTx(profileConfig, channelID, outputChannelCreateTx); err != nil { logger.Fatalf(&quot;Error on outputChannelCreateTx: %s&quot;, err) } } //验证创世块 if inspectBlock != &quot;&quot; { if err := doInspectBlock(inspectBlock); err != nil { logger.Fatalf(&quot;Error on inspectBlock: %s&quot;, err) } } //验证通道配置文件 if inspectChannelCreateTx != &quot;&quot; { if err := doInspectChannelCreateTx(inspectChannelCreateTx); err != nil { logger.Fatalf(&quot;Error on inspectChannelCreateTx: %s&quot;, err) } } //更新Peer节点 if outputAnchorPeersUpdate != &quot;&quot; { if err := doOutputAnchorPeersUpdate(profileConfig, channelID, outputAnchorPeersUpdate, asOrg); err != nil { logger.Fatalf(&quot;Error on inspectChannelCreateTx: %s&quot;, err) } } //打印org if printOrg != &quot;&quot; { if err := doPrintOrg(topLevelConfig, printOrg); err != nil { logger.Fatalf(&quot;Error on printOrg: %s&quot;, err) } } } flag 和kingpin的包作用一样，不知道为什么一个源码会有两种命令的生成方式。 我们看一下genesisconfig 这个是在 configtxgen/localconfig/config.go中 func LoadTopLevel(configPaths ...string) *TopLevel { config := viper.New()//创建一个Viper对象 if len(configPaths) &gt; 0 { for _, p := range configPaths { config.AddConfigPath(p) } config.SetConfigName(configName)//设置configName } else { cf.InitViper(config, configName)如果没有传路径，那就生成一个。 } // For environment variables config.SetEnvPrefix(Prefix)//设置环境变量 config.AutomaticEnv() replacer := strings.NewReplacer(&quot;.&quot;, &quot;_&quot;)//替换 config.SetEnvKeyReplacer(replacer)//设置key err := config.ReadInConfig()//读取配置文件 if err != nil { logger.Panic(&quot;Error reading configuration: &quot;, err) } logger.Debugf(&quot;Using config file: %s&quot;, config.ConfigFileUsed()) var uconf TopLevel err = viperutil.EnhancedExactUnmarshal(config, &amp;uconf)//构件DecoderConfig对象 if err != nil { logger.Panic(&quot;Error unmarshaling config into struct: &quot;, err) } (&amp;uconf).completeInitialization(filepath.Dir(config.ConfigFileUsed()))//初始化 logger.Infof(&quot;Loaded configuration: %s&quot;, config.ConfigFileUsed()) return &amp;uconf//返回配置文件 } 再看doOutputBlock（）方法 func doOutputBlock(config *genesisconfig.Profile, channelID string, outputBlock string) error { pgen := encoder.New(config)//配置文件加密 logger.Info(&quot;Generating genesis block&quot;) if config.Consortiums == nil { logger.Warning(&quot;Genesis block does not contain a consortiums group definition. This block cannot be used for orderer bootstrap.&quot;) } genesisBlock := pgen.GenesisBlockForChannel(channelID)//根据通道id生成block. logger.Info(&quot;Writing genesis block&quot;) err := ioutil.WriteFile(outputBlock, utils.MarshalOrPanic(genesisBlock), 0644)//把创世块保存到文件 if err != nil { return fmt.Errorf(&quot;Error writing genesis block: %s&quot;, err) } return nil } 然后看一下 encoder.New(config) 方法 func New(config *genesisconfig.Profile) *Bootstrapper { channelGroup, err := NewChannelGroup(config)//创建一个通道的数组 if err != nil { logger.Panicf(&quot;Error creating channel group: %s&quot;, err) } return &amp;Bootstrapper{//返回bootstrapper对象 channelGroup: channelGroup, } } 然后看一下&nbsp;NewChannelGroup（）方法（生成一个通道分组） func NewChannelGroup(conf *genesisconfig.Profile) (*cb.ConfigGroup, error) { if conf.Orderer == nil {//conf配置文件的orderer return nil, errors.New(&quot;missing orderer config section&quot;) } channelGroup := cb.NewConfigGroup()//创建一个新的对象 if len(conf.Policies) == 0 { logger.Warningf(&quot;Default policy emission is deprecated, please include policy specificiations for the channel group in configtx.yaml&quot;) addImplicitMetaPolicyDefaults(channelGroup) } else { if err := addPolicies(channelGroup, conf.Policies, channelconfig.AdminsPolicyKey); err != nil { return nil, errors.Wrapf(err, &quot;error adding policies to channel group&quot;) } } addValue(channelGroup, channelconfig.HashingAlgorithmValue(), channelconfig.AdminsPolicyKey) addValue(channelGroup, channelconfig.BlockDataHashingStructureValue(), channelconfig.AdminsPolicyKey) addValue(channelGroup, channelconfig.OrdererAddressesValue(conf.Orderer.Addresses), ordererAdminsPolicyName) if conf.Consortium != &quot;&quot; { addValue(channelGroup, channelconfig.ConsortiumValue(conf.Consortium), channelconfig.AdminsPolicyKey) } if len(conf.Capabilities) &gt; 0 { addValue(channelGroup, channelconfig.CapabilitiesValue(conf.Capabilities), channelconfig.AdminsPolicyKey) } var err error channelGroup.Groups[channelconfig.OrdererGroupKey], err = NewOrdererGroup(conf.Orderer) if err != nil { return nil, errors.Wrap(err, &quot;could not create orderer group&quot;) } if conf.Application != nil { channelGroup.Groups[channelconfig.ApplicationGroupKey], err = NewApplicationGroup(conf.Application) if err != nil { return nil, errors.Wrap(err, &quot;could not create application group&quot;) } } if conf.Consortiums != nil { channelGroup.Groups[channelconfig.ConsortiumsGroupKey], err = NewConsortiumsGroup(conf.Consortiums) if err != nil { return nil, errors.Wrap(err, &quot;could not create consortiums group&quot;) } } channelGroup.ModPolicy = channelconfig.AdminsPolicyKey return channelGroup, nil } 我们看一下GenesisBlockForChannel（）方法，为通道创建初始化块 func (bs *Bootstrapper) GenesisBlockForChannel(channelID string) *cb.Block { block, err := genesis.NewFactoryImpl(bs.channelGroup).Block(channelID) if err != nil { logger.Panicf(&quot;Error creating genesis block from channel group: %s&quot;, err) } return block } 这个方法的实现在 、common/genesis/genesis.go中 // NewFactoryImpl creates a new Factory. func NewFactoryImpl(channelGroup *cb.ConfigGroup) Factory { return &amp;factory{channelGroup: channelGroup} } // Block constructs and returns a genesis block for a given channel ID. func (f *factory) Block(channelID string) (*cb.Block, error) { payloadChannelHeader := utils.MakeChannelHeader(cb.HeaderType_CONFIG, msgVersion, channelID, epoch)//创建通道header payloadSignatureHeader := utils.MakeSignatureHeader(nil, utils.CreateNonceOrPanic())//创建签名header utils.SetTxID(payloadChannelHeader, payloadSignatureHeader)//设置TXId payloadHeader := utils.MakePayloadHeader(payloadChannelHeader, payloadSignatureHeader) payload := &amp;cb.Payload{Header: payloadHeader, Data: utils.MarshalOrPanic(&amp;cb.ConfigEnvelope{Config: &amp;cb.Config{ChannelGroup: f.channelGroup}})} envelope := &amp;cb.Envelope{Payload: utils.MarshalOrPanic(payload), Signature: nil} block := cb.NewBlock(0, nil)//生成创世块 block.Data = &amp;cb.BlockData{Data: [][]byte{utils.MarshalOrPanic(envelope)}} block.Header.DataHash = block.Data.Hash() block.Metadata.Metadata[cb.BlockMetadataIndex_LAST_CONFIG] = utils.MarshalOrPanic(&amp;cb.Metadata{ Value: utils.MarshalOrPanic(&amp;cb.LastConfig{Index: 0}), }) return block, nil } 先讲到证书的创世块的生成。里面有很多不是很明了的东西，后面我们会再做一个详细的讲解。 阅读更多","@type":"BlogPosting","url":"/2018/07/24/401816faed455ef86cadfd8690537ed0.html","headline":"fabric源码阅读第二篇上","dateModified":"2018-07-24T00:00:00+08:00","datePublished":"2018-07-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/07/24/401816faed455ef86cadfd8690537ed0.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>fabric源码阅读第二篇上</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>今天讲fabric的创世块的源码 主要围绕这个命令 ：export FABRIC_CFG_PATH=$PWD ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 生成创世块</p> 
  <p>main的方法在 /fabric/common/tools/configtxgen包下的</p> 
  <pre class="has">
<code class="language-html">func main() {
//定义变量用户接受命令参数
   var outputBlock, outputChannelCreateTx, profile, configPath, channelID, inspectBlock, inspectChannelCreateTx, outputAnchorPeersUpdate, asOrg, printOrg string

   flag.StringVar(&amp;outputBlock, "outputBlock", "", "The path to write the genesis block to (if set)")
   flag.StringVar(&amp;channelID, "channelID", "", "The channel ID to use in the configtx")
   flag.StringVar(&amp;outputChannelCreateTx, "outputCreateChannelTx", "", "The path to write a channel creation configtx to (if set)")
   flag.StringVar(&amp;profile, "profile", genesisconfig.SampleInsecureSoloProfile, "The profile from configtx.yaml to use for generation.")
   flag.StringVar(&amp;configPath, "configPath", "", "The path containing the configuration to use (if set)")
   flag.StringVar(&amp;inspectBlock, "inspectBlock", "", "Prints the configuration contained in the block at the specified path")
   flag.StringVar(&amp;inspectChannelCreateTx, "inspectChannelCreateTx", "", "Prints the configuration contained in the transaction at the specified path")
   flag.StringVar(&amp;outputAnchorPeersUpdate, "outputAnchorPeersUpdate", "", "Creates an config update to update an anchor peer (works only with the default channel creation, and only for the first update)")
   flag.StringVar(&amp;asOrg, "asOrg", "", "Performs the config generation as a particular organization (by name), only including values in the write set that org (likely) has privilege to set")
   flag.StringVar(&amp;printOrg, "printOrg", "", "Prints the definition of an organization as JSON. (useful for adding an org to a channel manually)")

   version := flag.Bool("version", false, "Show version information")

   flag.Parse()//接收到的参数，解析，然后上面所有的变量都会获得相对应的值

   if channelID == "" {
      channelID = genesisconfig.TestChainID//设置channelId
      logger.Warningf("Omitting the channel ID for configtxgen is deprecated.  Explicitly passing the channel ID will be required in the future, defaulting to '%s'.", channelID)
   }

   // show version
   if *version {
      printVersion()//打印版本信息
      os.Exit(exitCode)
   }

   logging.SetLevel(logging.INFO, "")

   // don't need to panic when running via command line
   defer func() {
      if err := recover(); err != nil {
         if strings.Contains(fmt.Sprint(err), "Error reading configuration: Unsupported Config Type") {
            logger.Error("Could not find configtx.yaml. " +
               "Please make sure that FABRIC_CFG_PATH or --configPath is set to a path " +
               "which contains configtx.yaml")
            os.Exit(1)
         }
         if strings.Contains(fmt.Sprint(err), "Could not find profile") {
            logger.Error(fmt.Sprint(err) + ". " +
               "Please make sure that FABRIC_CFG_PATH or --configPath is set to a path " +
               "which contains configtx.yaml with the specified profile")
            os.Exit(1)
         }
         logger.Panic(err)
      }
   }()

   logger.Info("Loading configuration")
   factory.InitFactories(nil)//初始化算法工厂
   var profileConfig *genesisconfig.Profile
   if outputBlock != "" || outputChannelCreateTx != "" || outputAnchorPeersUpdate != "" {
      if configPath != "" {
         profileConfig = genesisconfig.Load(profile, configPath)//load配置文件
      } else {
         profileConfig = genesisconfig.Load(profile)
      }
   }
   var topLevelConfig *genesisconfig.TopLevel
   if configPath != "" {
      topLevelConfig = genesisconfig.LoadTopLevel(configPath)
   } else {
      topLevelConfig = genesisconfig.LoadTopLevel()
   }

//生成创世块
   if outputBlock != "" {
      if err := doOutputBlock(profileConfig, channelID, outputBlock); err != nil {
         logger.Fatalf("Error on outputBlock: %s", err)
      }
   }
//创建通道配置文件
   if outputChannelCreateTx != "" {
      if err := doOutputChannelCreateTx(profileConfig, channelID, outputChannelCreateTx); err != nil {
         logger.Fatalf("Error on outputChannelCreateTx: %s", err)
      }
   }
//验证创世块
   if inspectBlock != "" {
      if err := doInspectBlock(inspectBlock); err != nil {
         logger.Fatalf("Error on inspectBlock: %s", err)
      }
   }
//验证通道配置文件
   if inspectChannelCreateTx != "" {
      if err := doInspectChannelCreateTx(inspectChannelCreateTx); err != nil {
         logger.Fatalf("Error on inspectChannelCreateTx: %s", err)
      }
   }
//更新Peer节点
   if outputAnchorPeersUpdate != "" {
      if err := doOutputAnchorPeersUpdate(profileConfig, channelID, outputAnchorPeersUpdate, asOrg); err != nil {
         logger.Fatalf("Error on inspectChannelCreateTx: %s", err)
      }
   }
//打印org
   if printOrg != "" {
      if err := doPrintOrg(topLevelConfig, printOrg); err != nil {
         logger.Fatalf("Error on printOrg: %s", err)
      }
   }
}</code></pre> 
  <p>flag 和kingpin的包作用一样，不知道为什么一个源码会有两种命令的生成方式。</p> 
  <p>我们看一下genesisconfig 这个是在 configtxgen/localconfig/config.go中</p> 
  <pre class="has">
<code class="language-html">func LoadTopLevel(configPaths ...string) *TopLevel {
   config := viper.New()//创建一个Viper对象
   if len(configPaths) &gt; 0 {
      for _, p := range configPaths {
         config.AddConfigPath(p)
      }
      config.SetConfigName(configName)//设置configName
   } else {
      cf.InitViper(config, configName)如果没有传路径，那就生成一个。
   }

   // For environment variables
   config.SetEnvPrefix(Prefix)//设置环境变量
   config.AutomaticEnv()

   replacer := strings.NewReplacer(".", "_")//替换
   config.SetEnvKeyReplacer(replacer)//设置key

   err := config.ReadInConfig()//读取配置文件
   if err != nil {
      logger.Panic("Error reading configuration: ", err)
   }
   logger.Debugf("Using config file: %s", config.ConfigFileUsed())

   var uconf TopLevel
   err = viperutil.EnhancedExactUnmarshal(config, &amp;uconf)//构件DecoderConfig对象
   if err != nil {
      logger.Panic("Error unmarshaling config into struct: ", err)
   }

   (&amp;uconf).completeInitialization(filepath.Dir(config.ConfigFileUsed()))//初始化

   logger.Infof("Loaded configuration: %s", config.ConfigFileUsed())

   return &amp;uconf//返回配置文件
}</code></pre> 
  <p>再看doOutputBlock（）方法</p> 
  <pre class="has">
<code class="language-html">func doOutputBlock(config *genesisconfig.Profile, channelID string, outputBlock string) error {
   pgen := encoder.New(config)//配置文件加密
   logger.Info("Generating genesis block")
   if config.Consortiums == nil {
      logger.Warning("Genesis block does not contain a consortiums group definition.  This block cannot be used for orderer bootstrap.")
   }
   genesisBlock := pgen.GenesisBlockForChannel(channelID)//根据通道id生成block.
   logger.Info("Writing genesis block")
   err := ioutil.WriteFile(outputBlock, utils.MarshalOrPanic(genesisBlock), 0644)//把创世块保存到文件
   if err != nil {
      return fmt.Errorf("Error writing genesis block: %s", err)
   }
   return nil
}</code></pre> 
  <p>然后看一下 encoder.New(config) 方法</p> 
  <pre class="has">
<code class="language-html">func New(config *genesisconfig.Profile) *Bootstrapper {
   channelGroup, err := NewChannelGroup(config)//创建一个通道的数组
   if err != nil {
      logger.Panicf("Error creating channel group: %s", err)
   }
   return &amp;Bootstrapper{//返回bootstrapper对象
      channelGroup: channelGroup,
   }
}
</code></pre> 
  <p>然后看一下&nbsp;NewChannelGroup（）方法（生成一个通道分组）</p> 
  <pre class="has">
<code class="language-html">func NewChannelGroup(conf *genesisconfig.Profile) (*cb.ConfigGroup, error) {
   if conf.Orderer == nil {//conf配置文件的orderer
      return nil, errors.New("missing orderer config section")
   }

   channelGroup := cb.NewConfigGroup()//创建一个新的对象
   if len(conf.Policies) == 0 {
      logger.Warningf("Default policy emission is deprecated, please include policy specificiations for the channel group in configtx.yaml")
      addImplicitMetaPolicyDefaults(channelGroup)
   } else {
      if err := addPolicies(channelGroup, conf.Policies, channelconfig.AdminsPolicyKey); err != nil {
         return nil, errors.Wrapf(err, "error adding policies to channel group")
      }
   }

   addValue(channelGroup, channelconfig.HashingAlgorithmValue(), channelconfig.AdminsPolicyKey)
   addValue(channelGroup, channelconfig.BlockDataHashingStructureValue(), channelconfig.AdminsPolicyKey)
   addValue(channelGroup, channelconfig.OrdererAddressesValue(conf.Orderer.Addresses), ordererAdminsPolicyName)

   if conf.Consortium != "" {
      addValue(channelGroup, channelconfig.ConsortiumValue(conf.Consortium), channelconfig.AdminsPolicyKey)
   }

   if len(conf.Capabilities) &gt; 0 {
      addValue(channelGroup, channelconfig.CapabilitiesValue(conf.Capabilities), channelconfig.AdminsPolicyKey)
   }

   var err error
   channelGroup.Groups[channelconfig.OrdererGroupKey], err = NewOrdererGroup(conf.Orderer)
   if err != nil {
      return nil, errors.Wrap(err, "could not create orderer group")
   }

   if conf.Application != nil {
      channelGroup.Groups[channelconfig.ApplicationGroupKey], err = NewApplicationGroup(conf.Application)
      if err != nil {
         return nil, errors.Wrap(err, "could not create application group")
      }
   }

   if conf.Consortiums != nil {
      channelGroup.Groups[channelconfig.ConsortiumsGroupKey], err = NewConsortiumsGroup(conf.Consortiums)
      if err != nil {
         return nil, errors.Wrap(err, "could not create consortiums group")
      }
   }

   channelGroup.ModPolicy = channelconfig.AdminsPolicyKey
   return channelGroup, nil
}</code></pre> 
  <p>我们看一下GenesisBlockForChannel（）方法，为通道创建初始化块</p> 
  <pre class="has">
<code class="language-html">func (bs *Bootstrapper) GenesisBlockForChannel(channelID string) *cb.Block {
   block, err := genesis.NewFactoryImpl(bs.channelGroup).Block(channelID)
   if err != nil {
      logger.Panicf("Error creating genesis block from channel group: %s", err)
   }
   return block
}</code></pre> 
  <p>这个方法的实现在 、common/genesis/genesis.go中</p> 
  <pre class="has">
<code class="language-html">// NewFactoryImpl creates a new Factory.
func NewFactoryImpl(channelGroup *cb.ConfigGroup) Factory {
   return &amp;factory{channelGroup: channelGroup}
}

// Block constructs and returns a genesis block for a given channel ID.
func (f *factory) Block(channelID string) (*cb.Block, error) {
   payloadChannelHeader := utils.MakeChannelHeader(cb.HeaderType_CONFIG, msgVersion, channelID, epoch)//创建通道header
   payloadSignatureHeader := utils.MakeSignatureHeader(nil, utils.CreateNonceOrPanic())//创建签名header
   utils.SetTxID(payloadChannelHeader, payloadSignatureHeader)//设置TXId
   payloadHeader := utils.MakePayloadHeader(payloadChannelHeader, payloadSignatureHeader)
   payload := &amp;cb.Payload{Header: payloadHeader, Data: utils.MarshalOrPanic(&amp;cb.ConfigEnvelope{Config: &amp;cb.Config{ChannelGroup: f.channelGroup}})}
   envelope := &amp;cb.Envelope{Payload: utils.MarshalOrPanic(payload), Signature: nil}

   block := cb.NewBlock(0, nil)//生成创世块
   block.Data = &amp;cb.BlockData{Data: [][]byte{utils.MarshalOrPanic(envelope)}}
   block.Header.DataHash = block.Data.Hash()
   block.Metadata.Metadata[cb.BlockMetadataIndex_LAST_CONFIG] = utils.MarshalOrPanic(&amp;cb.Metadata{
      Value: utils.MarshalOrPanic(&amp;cb.LastConfig{Index: 0}),
   })
   return block, nil
}
</code></pre> 
  <p>先讲到证书的创世块的生成。里面有很多不是很明了的东西，后面我们会再做一个详细的讲解。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_15693861/article/details/81190902,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_15693861/article/details/81190902,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
