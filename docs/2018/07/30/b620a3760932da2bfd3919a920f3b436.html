<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>第八篇 墨客区块链(MOAC BlockChain) 程序猿怎么部署和调用智能合约 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="第八篇 墨客区块链(MOAC BlockChain) 程序猿怎么部署和调用智能合约" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/81285250 在本博客《第四篇 在墨客区块链（MOAC BlockChain）部署ERC-20合约》和《第五篇 在墨客区块链（MOAC BlockChain）部署ERC-721合约》，已经有使用网页版钱包部署智能合约的方法。 本文基于墨客区块链（MOAC BlockChain），详细说明使用代码部署和调用智能合约的方法。 环境： 墨客区块链版本：nuwa-vnode1.0.2.win.zip； 操作系统：64位Windows 10家庭版。 &nbsp; 1.安装并启动本地节点 1.1 安装moac节点 请参考文档《第三篇 墨客区块链（MOAC BlockChain）节点安装教程》。 1.2 启动moac节点 打开命令终端（cmd），转到墨客当前目录，在命令行中执行： D:\nuwa1.0.2.win&gt;moac --rpc 确保本地节点中某个账号有足够的moac以进行智能合约部署和调用。 &nbsp; 2.编写并编译智能合约 2.1 编写智能合约 本篇实际测试代码TestToken20.sol附在《第四篇 在墨客区块链（MOAC BlockChain）部署ERC-20合约》文章末尾，TestToken721.sol附在《第五篇 在墨客区块链（MOAC BlockChain）部署ERC-721合约》文章末尾。 修改20合约TestToken20.sol的参数部分，直接写入参数值。 uint256 public totalSupply = 1000000; //发行总量 string public name = &quot;My test token&quot;; //名称 uint8 public decimals = 8; //返回token使用的小数点位数。 string public symbol = &quot;MTT&quot;; //token简称 这样在部署的时候不需要导入参数。 注意：这些代码为测试实例使用，非标准部署智能合约代码。 2.2 使用本地solidity编译器编译合约 需要有本地的solidity编译环境。安装命令： C:&gt;npm install -g solc //默认安装最新版本 C:&gt;npm install -g solc@0.4.21 //安装指定版本 进入TestToken20.sol所在目录，编译合约： C:&gt;solcjs --bin --abi -o bin TestToken20.sol 运行后，输出TestToken20.abi及TestToken20.bin到bin目录下，TestToken20.abi里边放的就是abi的内容，TestToken20.bin里边放的就是bytecode的内容。 2.3 使用remix编译合约 Remix是一个开发Solidity智能合约的网络版开发软件。 登陆Remix&nbsp;后，把中间的编辑框里的合约内容删除，然后把自己的合约代码复制到编辑框里。在右上角的菜单里Compile下面选中Auto Compile。 编译后会在右边区域显示是否有error、warning等信息。如果没有报错（Warning可以忽略），点击“Details”显示编译后详细信息。 可以得到跟2.2节一样的bytecode内容和abi内容。拷贝出来备用。 还有FUNCTIONHASHES，包含了本合约中的函数通过hash算法Keccak256得到前4个字节，调用合约时会用到。 &nbsp; 3.部署智能合约 3.1 部署 部署智能合约文件deploy.js，内容如下： var abiString = &#39;[{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;name&quot;,......&quot;type&quot;:&quot;event&quot;}]&#39;; //编译结果的abi var bytecodeString = &#39;606060405234801561001057600080fd5b5060......75fd0029&#39;; //编译结果的bytecode var account = {address:&quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;,secret:&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); createContract(chain3, account, abiString, bytecodeString); function createContract(chain3, account, abiString, bytecodeString){ var bytecode = &quot;0x&quot; + bytecodeString; var abi = JSON.parse(abiString); console.log(&#39;bytecode&#39;, bytecode); console.log(&#39;abi&#39;, abiString); var gasValue = chain3.mc.estimateGas({data: bytecode}); console.log(&quot;gas estimate on contract:&quot;, gasValue); var address = account.address; var secret = account.secret; var txCount = chain3.mc.getTransactionCount(address); console.log(&quot;get tx account&quot;, txCount) var rawTx = { from: address, nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(400000), data: bytecode, chainId: chain3.version.network, }; var signedTx = chain3.signTransaction(rawTx, account.secret); console.log(&quot;send signed tx:&quot;, signedTx); console.log(&quot;len&quot;, signedTx.length); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); }else{ console.log(&quot;error:&quot;, err.message); } }); } 代码中的account是本地节点的一个账号，需要付出本次部署智能合约的gas费。部署后的合约也归该账号所有。 合约部署完成后，如果没有报错，会返回一个hash值，通过这个hash值到浏览器可以查询到本次合约部署的详细信息。 或者通过节点命令得到相应信息。 &gt;mc.getTransactionReceipt(&quot;transactionHash&quot;) 3.2 从keystore得到privateKey 本节中部署智能合约时，代码使用sendRawTransaction需要私钥签名，得到本地节点账号的私钥有两种方式： 方式一：使用“keystore + password”的方式将账号导入手机版钱包TokenPocket，然后导出私钥。 方式二：使用如下代码getPrivateKey.js得到本地节点账号的私钥。 var keythereum = require(&quot;keythereum&quot;); var datadir = &quot;C:\\Users\\lyq2018\\AppData\\Roaming\\MoacNode&quot;; //moacnode目录，根据实际修改 //var datadir = &quot;/Users/gm/Library/MoacNode&quot;; //苹果mac系统moacnode目录，根据实际修改 var address= &quot;0x68986c1bcd54ae5dae69310XXXXXXXXXXXXXXXXX&quot;; //本地节点账号，根据实际修改 const password = &quot;password&quot;; //账号密码，根据实际修改 var keyObject = keythereum.importFromFile(address, datadir); var privateKey = keythereum.recover(password, keyObject); //输出私钥 console.log(privateKey.toString(&#39;hex&#39;)); 代码运行需要nodejs和python2.7环境，同时需要导入keythereum。 c:\&gt;npm install -g keythereum 3.3 从privateKey得到keystore 有时候用户会需要从私钥导出keystore用于节点，此时得到本地节点账号的keystore有两种方式： 方式一：使用“私钥”的方式将账号导入手机版钱包TokenPocket，然后导出为keystore。 方式二：使用如下代码getKeystore.js得到本地节点账号的keystore。 var Wallet = require(&#39;ethereumjs-wallet&#39;); var privateKey = &#39;bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX&#39;; var key = Buffer.from(privateKey, &#39;hex&#39;); var wallet = Wallet.fromPrivateKey(key); wallet.toV3String(&#39;password&#39;); console.log(&quot;Get keystore&quot;, wallet.toV3String(&#39;password&#39;)); 代码运行需要nodejs和python2.7环境，同时需要导入ethereumjs-wallet。 c:\&gt;npm install -g ethereumjs-wallet 安装时如果报类似“npm ERR! Unexpected end of JSON input while parsing near......”的错，可以先清理缓存再安装。 c:\&gt;npm cache clean --force &nbsp; 4.调用智能合约 以下为TestToken20.sol的调用代码，call_erc20.js。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96AXXXXXXXXXXXX&quot;; //智能合约地址 var address = &quot;0x68986c1BCD54Ae5dAe69310fC64EXXXXXXXXXXXX&quot;; var account = {address:&quot;0x68986c1BCD54Ae5dAe69310fC64XXXXXXXXXXXX&quot;,secret:&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; var abiString = &#39;[{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;name&quot;,......&quot;type&quot;:&quot;event&quot;}]&#39;; //智能合约的abi //调用erc20合约 //基本属性 callContract1(chain3, contractAddress, address, abiString); function callContract1(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(JSON.stringify(token.totalSupply())); //总量 console.log(JSON.stringify(token.name())); //名称 console.log(JSON.stringify(token.decimals())); //位数 console.log(JSON.stringify(token.symbol())); //简称 } //调用erc20合约 //通过abi生成智能合约对象, 直接通过对应合约方法进行call调用 //查询余额 callContract2(chain3, contractAddress, address, abiString); function callContract2(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); token.balanceOf.call(address, function(err, result){ console.log(err, JSON.stringify(result)); }); } //调用erc20合约 //通过对交易签名进行调用 //发送代币 var amount = 100; //发送数量 var anotherAddress = &quot;0x745c57ca5318093115d61bbca3687ca02cxxxxxx&quot;; //接收地址 callContract3(chain3, contractAddress, account, abiString, anotherAddress, amount); function callContract3(chain3, contractAddress, account, abiString, anotherAddress, amount){ var address = account.address; var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); var data = token.transfer.getData(anotherAddress, amount); console.log(&#39;data&#39;, data); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(100000), to: contractAddress, data: data, chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); var filter = chain3.mc.filter(&#39;latest&#39;); filter.watch(function(error, result) { var receipt = chain3.mc.getTransaction(hash); if (!error &amp;&amp; receipt &amp;&amp; receipt.blockNumber != null) { console.log(&quot;done.&quot;); filter.stopWatching(); process.exit(0); } }); }else{ console.log(&quot;error:&quot;, err.message); } }); } 以上代码三个调用实例的函数分别为callContract1、callContract2、callContract3；可以根据需要单独或组合使用。 &nbsp; 以下为TestToken721.sol的调用代码，call_erc721.js。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96AXXXXXXXXXXXX&quot;; //智能合约地址 var address = &quot;0x68986c1BCD54Ae5dAe69310fC64EXXXXXXXXXXXX&quot;; var account = {address:&quot;0x68986c1BCD54Ae5dAe69310fC64XXXXXXXXXXXX&quot;,secret:&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; var abiString = &#39;[{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;name&quot;,......&quot;type&quot;:&quot;event&quot;}]&#39;; //智能合约的abi //调用erc721合约 //读合约 callContract(chain3, contractAddress, address, abiString); function callContract(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); var tokenID = 5; //从0开始的编号 //输出721 token的name token.name.call(function(err, result){ console.log(err, JSON.stringify(result)); }); //输出balance token.balanceOf.call(address, function(err, result){ console.log( &quot;721 getBalanceof&quot;,err, JSON.stringify(result)); }); //输出该tokenID的属性 token.getProperty.call(tokenID, function(err, result){ console.log( &quot;721 getTitle&quot;,err, JSON.stringify(result)); }); //输出tokenID的拥有者 token.ownerOf.call(tokenID, function(err, result){ console.log( &quot;721 ownerOf&quot;,err, JSON.stringify(result)); }); //输出某个地址拥有的所有tokenID token.tokensOfOwner.call(address, function(err, result){ console.log( &quot;721 tokensOfOwner&quot;,err, JSON.stringify(result)); }); } //调用erc721合约 //创建721token callContract1(chain3, account, contractAddress, address, abiString) function callContract1(chain3, account, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(&#39;data&#39;, token.createToken.getData(&quot;property&quot;,address)); //导入token的属性 var privateKey = new Buffer(account.secret, &quot;hex&quot;); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(400000), to: contractAddress, data: token.createToken.getData(&quot;property&quot;,address), chainId: chain3.version.network, }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); }else{ console.log(&quot;error:&quot;, err.message); } }); } //调用erc721合约 //发送721token var tokenID = 100; //721token编号 var anotherAddress = &quot;0x745c57ca5318093115d61bbca3687ca02cxxxxxx&quot;; //接收地址 callContract2(chain3, account, contractAddress, anotherAddress, tokenID, abiString) function callContract2(chain3, account, contractAddress, anotherAddress, tokenID, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(&#39;data&#39;, token.transfer.getData(anotherAddress,tokenID )); var privateKey = new Buffer(account.secret, &quot;hex&quot;); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(400000), to: contractAddress, data: token.transfer.getData(anotherAddress,tokenID ), chainId: chain3.version.network, }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); }else{ console.log(&quot;error:&quot;, err.message); } }); } //调用721合约的时候 //得到所有拥有该721token的地址 var tokenNow = 0; //tokenID从该编号开始，必须 &gt;= 0 var tokenMax = 8; //tokenID到该编号结束，必须已经create token到该编号 callContract3(tokenNow, chain3, contractAddress, address, abiString); function callContract3(tokenNow, chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); //console.log(&quot;以下输出721合约的owner：&quot;); token.ownerOf.call(tokenNow, function(err, result){ console.log( &quot;721 ownerOf&quot;,tokenNow,err, JSON.stringify(result)); }); //通过tokenID循环 if (tokenNow &lt; tokenMax){ allContract3(tokenNow+1, chain3, contractAddress, address, abiString); } } &nbsp; 阅读更多" />
<meta property="og:description" content="版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/81285250 在本博客《第四篇 在墨客区块链（MOAC BlockChain）部署ERC-20合约》和《第五篇 在墨客区块链（MOAC BlockChain）部署ERC-721合约》，已经有使用网页版钱包部署智能合约的方法。 本文基于墨客区块链（MOAC BlockChain），详细说明使用代码部署和调用智能合约的方法。 环境： 墨客区块链版本：nuwa-vnode1.0.2.win.zip； 操作系统：64位Windows 10家庭版。 &nbsp; 1.安装并启动本地节点 1.1 安装moac节点 请参考文档《第三篇 墨客区块链（MOAC BlockChain）节点安装教程》。 1.2 启动moac节点 打开命令终端（cmd），转到墨客当前目录，在命令行中执行： D:\nuwa1.0.2.win&gt;moac --rpc 确保本地节点中某个账号有足够的moac以进行智能合约部署和调用。 &nbsp; 2.编写并编译智能合约 2.1 编写智能合约 本篇实际测试代码TestToken20.sol附在《第四篇 在墨客区块链（MOAC BlockChain）部署ERC-20合约》文章末尾，TestToken721.sol附在《第五篇 在墨客区块链（MOAC BlockChain）部署ERC-721合约》文章末尾。 修改20合约TestToken20.sol的参数部分，直接写入参数值。 uint256 public totalSupply = 1000000; //发行总量 string public name = &quot;My test token&quot;; //名称 uint8 public decimals = 8; //返回token使用的小数点位数。 string public symbol = &quot;MTT&quot;; //token简称 这样在部署的时候不需要导入参数。 注意：这些代码为测试实例使用，非标准部署智能合约代码。 2.2 使用本地solidity编译器编译合约 需要有本地的solidity编译环境。安装命令： C:&gt;npm install -g solc //默认安装最新版本 C:&gt;npm install -g solc@0.4.21 //安装指定版本 进入TestToken20.sol所在目录，编译合约： C:&gt;solcjs --bin --abi -o bin TestToken20.sol 运行后，输出TestToken20.abi及TestToken20.bin到bin目录下，TestToken20.abi里边放的就是abi的内容，TestToken20.bin里边放的就是bytecode的内容。 2.3 使用remix编译合约 Remix是一个开发Solidity智能合约的网络版开发软件。 登陆Remix&nbsp;后，把中间的编辑框里的合约内容删除，然后把自己的合约代码复制到编辑框里。在右上角的菜单里Compile下面选中Auto Compile。 编译后会在右边区域显示是否有error、warning等信息。如果没有报错（Warning可以忽略），点击“Details”显示编译后详细信息。 可以得到跟2.2节一样的bytecode内容和abi内容。拷贝出来备用。 还有FUNCTIONHASHES，包含了本合约中的函数通过hash算法Keccak256得到前4个字节，调用合约时会用到。 &nbsp; 3.部署智能合约 3.1 部署 部署智能合约文件deploy.js，内容如下： var abiString = &#39;[{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;name&quot;,......&quot;type&quot;:&quot;event&quot;}]&#39;; //编译结果的abi var bytecodeString = &#39;606060405234801561001057600080fd5b5060......75fd0029&#39;; //编译结果的bytecode var account = {address:&quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;,secret:&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); createContract(chain3, account, abiString, bytecodeString); function createContract(chain3, account, abiString, bytecodeString){ var bytecode = &quot;0x&quot; + bytecodeString; var abi = JSON.parse(abiString); console.log(&#39;bytecode&#39;, bytecode); console.log(&#39;abi&#39;, abiString); var gasValue = chain3.mc.estimateGas({data: bytecode}); console.log(&quot;gas estimate on contract:&quot;, gasValue); var address = account.address; var secret = account.secret; var txCount = chain3.mc.getTransactionCount(address); console.log(&quot;get tx account&quot;, txCount) var rawTx = { from: address, nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(400000), data: bytecode, chainId: chain3.version.network, }; var signedTx = chain3.signTransaction(rawTx, account.secret); console.log(&quot;send signed tx:&quot;, signedTx); console.log(&quot;len&quot;, signedTx.length); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); }else{ console.log(&quot;error:&quot;, err.message); } }); } 代码中的account是本地节点的一个账号，需要付出本次部署智能合约的gas费。部署后的合约也归该账号所有。 合约部署完成后，如果没有报错，会返回一个hash值，通过这个hash值到浏览器可以查询到本次合约部署的详细信息。 或者通过节点命令得到相应信息。 &gt;mc.getTransactionReceipt(&quot;transactionHash&quot;) 3.2 从keystore得到privateKey 本节中部署智能合约时，代码使用sendRawTransaction需要私钥签名，得到本地节点账号的私钥有两种方式： 方式一：使用“keystore + password”的方式将账号导入手机版钱包TokenPocket，然后导出私钥。 方式二：使用如下代码getPrivateKey.js得到本地节点账号的私钥。 var keythereum = require(&quot;keythereum&quot;); var datadir = &quot;C:\\Users\\lyq2018\\AppData\\Roaming\\MoacNode&quot;; //moacnode目录，根据实际修改 //var datadir = &quot;/Users/gm/Library/MoacNode&quot;; //苹果mac系统moacnode目录，根据实际修改 var address= &quot;0x68986c1bcd54ae5dae69310XXXXXXXXXXXXXXXXX&quot;; //本地节点账号，根据实际修改 const password = &quot;password&quot;; //账号密码，根据实际修改 var keyObject = keythereum.importFromFile(address, datadir); var privateKey = keythereum.recover(password, keyObject); //输出私钥 console.log(privateKey.toString(&#39;hex&#39;)); 代码运行需要nodejs和python2.7环境，同时需要导入keythereum。 c:\&gt;npm install -g keythereum 3.3 从privateKey得到keystore 有时候用户会需要从私钥导出keystore用于节点，此时得到本地节点账号的keystore有两种方式： 方式一：使用“私钥”的方式将账号导入手机版钱包TokenPocket，然后导出为keystore。 方式二：使用如下代码getKeystore.js得到本地节点账号的keystore。 var Wallet = require(&#39;ethereumjs-wallet&#39;); var privateKey = &#39;bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX&#39;; var key = Buffer.from(privateKey, &#39;hex&#39;); var wallet = Wallet.fromPrivateKey(key); wallet.toV3String(&#39;password&#39;); console.log(&quot;Get keystore&quot;, wallet.toV3String(&#39;password&#39;)); 代码运行需要nodejs和python2.7环境，同时需要导入ethereumjs-wallet。 c:\&gt;npm install -g ethereumjs-wallet 安装时如果报类似“npm ERR! Unexpected end of JSON input while parsing near......”的错，可以先清理缓存再安装。 c:\&gt;npm cache clean --force &nbsp; 4.调用智能合约 以下为TestToken20.sol的调用代码，call_erc20.js。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96AXXXXXXXXXXXX&quot;; //智能合约地址 var address = &quot;0x68986c1BCD54Ae5dAe69310fC64EXXXXXXXXXXXX&quot;; var account = {address:&quot;0x68986c1BCD54Ae5dAe69310fC64XXXXXXXXXXXX&quot;,secret:&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; var abiString = &#39;[{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;name&quot;,......&quot;type&quot;:&quot;event&quot;}]&#39;; //智能合约的abi //调用erc20合约 //基本属性 callContract1(chain3, contractAddress, address, abiString); function callContract1(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(JSON.stringify(token.totalSupply())); //总量 console.log(JSON.stringify(token.name())); //名称 console.log(JSON.stringify(token.decimals())); //位数 console.log(JSON.stringify(token.symbol())); //简称 } //调用erc20合约 //通过abi生成智能合约对象, 直接通过对应合约方法进行call调用 //查询余额 callContract2(chain3, contractAddress, address, abiString); function callContract2(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); token.balanceOf.call(address, function(err, result){ console.log(err, JSON.stringify(result)); }); } //调用erc20合约 //通过对交易签名进行调用 //发送代币 var amount = 100; //发送数量 var anotherAddress = &quot;0x745c57ca5318093115d61bbca3687ca02cxxxxxx&quot;; //接收地址 callContract3(chain3, contractAddress, account, abiString, anotherAddress, amount); function callContract3(chain3, contractAddress, account, abiString, anotherAddress, amount){ var address = account.address; var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); var data = token.transfer.getData(anotherAddress, amount); console.log(&#39;data&#39;, data); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(100000), to: contractAddress, data: data, chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); var filter = chain3.mc.filter(&#39;latest&#39;); filter.watch(function(error, result) { var receipt = chain3.mc.getTransaction(hash); if (!error &amp;&amp; receipt &amp;&amp; receipt.blockNumber != null) { console.log(&quot;done.&quot;); filter.stopWatching(); process.exit(0); } }); }else{ console.log(&quot;error:&quot;, err.message); } }); } 以上代码三个调用实例的函数分别为callContract1、callContract2、callContract3；可以根据需要单独或组合使用。 &nbsp; 以下为TestToken721.sol的调用代码，call_erc721.js。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96AXXXXXXXXXXXX&quot;; //智能合约地址 var address = &quot;0x68986c1BCD54Ae5dAe69310fC64EXXXXXXXXXXXX&quot;; var account = {address:&quot;0x68986c1BCD54Ae5dAe69310fC64XXXXXXXXXXXX&quot;,secret:&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; var abiString = &#39;[{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;name&quot;,......&quot;type&quot;:&quot;event&quot;}]&#39;; //智能合约的abi //调用erc721合约 //读合约 callContract(chain3, contractAddress, address, abiString); function callContract(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); var tokenID = 5; //从0开始的编号 //输出721 token的name token.name.call(function(err, result){ console.log(err, JSON.stringify(result)); }); //输出balance token.balanceOf.call(address, function(err, result){ console.log( &quot;721 getBalanceof&quot;,err, JSON.stringify(result)); }); //输出该tokenID的属性 token.getProperty.call(tokenID, function(err, result){ console.log( &quot;721 getTitle&quot;,err, JSON.stringify(result)); }); //输出tokenID的拥有者 token.ownerOf.call(tokenID, function(err, result){ console.log( &quot;721 ownerOf&quot;,err, JSON.stringify(result)); }); //输出某个地址拥有的所有tokenID token.tokensOfOwner.call(address, function(err, result){ console.log( &quot;721 tokensOfOwner&quot;,err, JSON.stringify(result)); }); } //调用erc721合约 //创建721token callContract1(chain3, account, contractAddress, address, abiString) function callContract1(chain3, account, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(&#39;data&#39;, token.createToken.getData(&quot;property&quot;,address)); //导入token的属性 var privateKey = new Buffer(account.secret, &quot;hex&quot;); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(400000), to: contractAddress, data: token.createToken.getData(&quot;property&quot;,address), chainId: chain3.version.network, }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); }else{ console.log(&quot;error:&quot;, err.message); } }); } //调用erc721合约 //发送721token var tokenID = 100; //721token编号 var anotherAddress = &quot;0x745c57ca5318093115d61bbca3687ca02cxxxxxx&quot;; //接收地址 callContract2(chain3, account, contractAddress, anotherAddress, tokenID, abiString) function callContract2(chain3, account, contractAddress, anotherAddress, tokenID, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(&#39;data&#39;, token.transfer.getData(anotherAddress,tokenID )); var privateKey = new Buffer(account.secret, &quot;hex&quot;); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(400000), to: contractAddress, data: token.transfer.getData(anotherAddress,tokenID ), chainId: chain3.version.network, }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); }else{ console.log(&quot;error:&quot;, err.message); } }); } //调用721合约的时候 //得到所有拥有该721token的地址 var tokenNow = 0; //tokenID从该编号开始，必须 &gt;= 0 var tokenMax = 8; //tokenID到该编号结束，必须已经create token到该编号 callContract3(tokenNow, chain3, contractAddress, address, abiString); function callContract3(tokenNow, chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); //console.log(&quot;以下输出721合约的owner：&quot;); token.ownerOf.call(tokenNow, function(err, result){ console.log( &quot;721 ownerOf&quot;,tokenNow,err, JSON.stringify(result)); }); //通过tokenID循环 if (tokenNow &lt; tokenMax){ allContract3(tokenNow+1, chain3, contractAddress, address, abiString); } } &nbsp; 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-30T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/81285250 在本博客《第四篇 在墨客区块链（MOAC BlockChain）部署ERC-20合约》和《第五篇 在墨客区块链（MOAC BlockChain）部署ERC-721合约》，已经有使用网页版钱包部署智能合约的方法。 本文基于墨客区块链（MOAC BlockChain），详细说明使用代码部署和调用智能合约的方法。 环境： 墨客区块链版本：nuwa-vnode1.0.2.win.zip； 操作系统：64位Windows 10家庭版。 &nbsp; 1.安装并启动本地节点 1.1 安装moac节点 请参考文档《第三篇 墨客区块链（MOAC BlockChain）节点安装教程》。 1.2 启动moac节点 打开命令终端（cmd），转到墨客当前目录，在命令行中执行： D:\\nuwa1.0.2.win&gt;moac --rpc 确保本地节点中某个账号有足够的moac以进行智能合约部署和调用。 &nbsp; 2.编写并编译智能合约 2.1 编写智能合约 本篇实际测试代码TestToken20.sol附在《第四篇 在墨客区块链（MOAC BlockChain）部署ERC-20合约》文章末尾，TestToken721.sol附在《第五篇 在墨客区块链（MOAC BlockChain）部署ERC-721合约》文章末尾。 修改20合约TestToken20.sol的参数部分，直接写入参数值。 uint256 public totalSupply = 1000000; //发行总量 string public name = &quot;My test token&quot;; //名称 uint8 public decimals = 8; //返回token使用的小数点位数。 string public symbol = &quot;MTT&quot;; //token简称 这样在部署的时候不需要导入参数。 注意：这些代码为测试实例使用，非标准部署智能合约代码。 2.2 使用本地solidity编译器编译合约 需要有本地的solidity编译环境。安装命令： C:&gt;npm install -g solc //默认安装最新版本 C:&gt;npm install -g solc@0.4.21 //安装指定版本 进入TestToken20.sol所在目录，编译合约： C:&gt;solcjs --bin --abi -o bin TestToken20.sol 运行后，输出TestToken20.abi及TestToken20.bin到bin目录下，TestToken20.abi里边放的就是abi的内容，TestToken20.bin里边放的就是bytecode的内容。 2.3 使用remix编译合约 Remix是一个开发Solidity智能合约的网络版开发软件。 登陆Remix&nbsp;后，把中间的编辑框里的合约内容删除，然后把自己的合约代码复制到编辑框里。在右上角的菜单里Compile下面选中Auto Compile。 编译后会在右边区域显示是否有error、warning等信息。如果没有报错（Warning可以忽略），点击“Details”显示编译后详细信息。 可以得到跟2.2节一样的bytecode内容和abi内容。拷贝出来备用。 还有FUNCTIONHASHES，包含了本合约中的函数通过hash算法Keccak256得到前4个字节，调用合约时会用到。 &nbsp; 3.部署智能合约 3.1 部署 部署智能合约文件deploy.js，内容如下： var abiString = &#39;[{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;name&quot;,......&quot;type&quot;:&quot;event&quot;}]&#39;; //编译结果的abi var bytecodeString = &#39;606060405234801561001057600080fd5b5060......75fd0029&#39;; //编译结果的bytecode var account = {address:&quot;0x745c57ca5318093115d61bbca368XXXXXXXXXXXX&quot;,secret:&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); createContract(chain3, account, abiString, bytecodeString); function createContract(chain3, account, abiString, bytecodeString){ var bytecode = &quot;0x&quot; + bytecodeString; var abi = JSON.parse(abiString); console.log(&#39;bytecode&#39;, bytecode); console.log(&#39;abi&#39;, abiString); var gasValue = chain3.mc.estimateGas({data: bytecode}); console.log(&quot;gas estimate on contract:&quot;, gasValue); var address = account.address; var secret = account.secret; var txCount = chain3.mc.getTransactionCount(address); console.log(&quot;get tx account&quot;, txCount) var rawTx = { from: address, nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(400000), data: bytecode, chainId: chain3.version.network, }; var signedTx = chain3.signTransaction(rawTx, account.secret); console.log(&quot;send signed tx:&quot;, signedTx); console.log(&quot;len&quot;, signedTx.length); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); }else{ console.log(&quot;error:&quot;, err.message); } }); } 代码中的account是本地节点的一个账号，需要付出本次部署智能合约的gas费。部署后的合约也归该账号所有。 合约部署完成后，如果没有报错，会返回一个hash值，通过这个hash值到浏览器可以查询到本次合约部署的详细信息。 或者通过节点命令得到相应信息。 &gt;mc.getTransactionReceipt(&quot;transactionHash&quot;) 3.2 从keystore得到privateKey 本节中部署智能合约时，代码使用sendRawTransaction需要私钥签名，得到本地节点账号的私钥有两种方式： 方式一：使用“keystore + password”的方式将账号导入手机版钱包TokenPocket，然后导出私钥。 方式二：使用如下代码getPrivateKey.js得到本地节点账号的私钥。 var keythereum = require(&quot;keythereum&quot;); var datadir = &quot;C:\\\\Users\\\\lyq2018\\\\AppData\\\\Roaming\\\\MoacNode&quot;; //moacnode目录，根据实际修改 //var datadir = &quot;/Users/gm/Library/MoacNode&quot;; //苹果mac系统moacnode目录，根据实际修改 var address= &quot;0x68986c1bcd54ae5dae69310XXXXXXXXXXXXXXXXX&quot;; //本地节点账号，根据实际修改 const password = &quot;password&quot;; //账号密码，根据实际修改 var keyObject = keythereum.importFromFile(address, datadir); var privateKey = keythereum.recover(password, keyObject); //输出私钥 console.log(privateKey.toString(&#39;hex&#39;)); 代码运行需要nodejs和python2.7环境，同时需要导入keythereum。 c:\\&gt;npm install -g keythereum 3.3 从privateKey得到keystore 有时候用户会需要从私钥导出keystore用于节点，此时得到本地节点账号的keystore有两种方式： 方式一：使用“私钥”的方式将账号导入手机版钱包TokenPocket，然后导出为keystore。 方式二：使用如下代码getKeystore.js得到本地节点账号的keystore。 var Wallet = require(&#39;ethereumjs-wallet&#39;); var privateKey = &#39;bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX&#39;; var key = Buffer.from(privateKey, &#39;hex&#39;); var wallet = Wallet.fromPrivateKey(key); wallet.toV3String(&#39;password&#39;); console.log(&quot;Get keystore&quot;, wallet.toV3String(&#39;password&#39;)); 代码运行需要nodejs和python2.7环境，同时需要导入ethereumjs-wallet。 c:\\&gt;npm install -g ethereumjs-wallet 安装时如果报类似“npm ERR! Unexpected end of JSON input while parsing near......”的错，可以先清理缓存再安装。 c:\\&gt;npm cache clean --force &nbsp; 4.调用智能合约 以下为TestToken20.sol的调用代码，call_erc20.js。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96AXXXXXXXXXXXX&quot;; //智能合约地址 var address = &quot;0x68986c1BCD54Ae5dAe69310fC64EXXXXXXXXXXXX&quot;; var account = {address:&quot;0x68986c1BCD54Ae5dAe69310fC64XXXXXXXXXXXX&quot;,secret:&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; var abiString = &#39;[{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;name&quot;,......&quot;type&quot;:&quot;event&quot;}]&#39;; //智能合约的abi //调用erc20合约 //基本属性 callContract1(chain3, contractAddress, address, abiString); function callContract1(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(JSON.stringify(token.totalSupply())); //总量 console.log(JSON.stringify(token.name())); //名称 console.log(JSON.stringify(token.decimals())); //位数 console.log(JSON.stringify(token.symbol())); //简称 } //调用erc20合约 //通过abi生成智能合约对象, 直接通过对应合约方法进行call调用 //查询余额 callContract2(chain3, contractAddress, address, abiString); function callContract2(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); token.balanceOf.call(address, function(err, result){ console.log(err, JSON.stringify(result)); }); } //调用erc20合约 //通过对交易签名进行调用 //发送代币 var amount = 100; //发送数量 var anotherAddress = &quot;0x745c57ca5318093115d61bbca3687ca02cxxxxxx&quot;; //接收地址 callContract3(chain3, contractAddress, account, abiString, anotherAddress, amount); function callContract3(chain3, contractAddress, account, abiString, anotherAddress, amount){ var address = account.address; var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); var data = token.transfer.getData(anotherAddress, amount); console.log(&#39;data&#39;, data); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(100000), to: contractAddress, data: data, chainId: chain3.version.network }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); var filter = chain3.mc.filter(&#39;latest&#39;); filter.watch(function(error, result) { var receipt = chain3.mc.getTransaction(hash); if (!error &amp;&amp; receipt &amp;&amp; receipt.blockNumber != null) { console.log(&quot;done.&quot;); filter.stopWatching(); process.exit(0); } }); }else{ console.log(&quot;error:&quot;, err.message); } }); } 以上代码三个调用实例的函数分别为callContract1、callContract2、callContract3；可以根据需要单独或组合使用。 &nbsp; 以下为TestToken721.sol的调用代码，call_erc721.js。 var Chain3 = require(&#39;chain3&#39;); var chain3 = new Chain3(new Chain3.providers.HttpProvider(&#39;http://localhost:8545&#39;)); var contractAddress = &quot;0xA2580D58A58998ca06e6f5b2A96AXXXXXXXXXXXX&quot;; //智能合约地址 var address = &quot;0x68986c1BCD54Ae5dAe69310fC64EXXXXXXXXXXXX&quot;; var account = {address:&quot;0x68986c1BCD54Ae5dAe69310fC64XXXXXXXXXXXX&quot;,secret:&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;}; var abiString = &#39;[{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;name&quot;,......&quot;type&quot;:&quot;event&quot;}]&#39;; //智能合约的abi //调用erc721合约 //读合约 callContract(chain3, contractAddress, address, abiString); function callContract(chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); var tokenID = 5; //从0开始的编号 //输出721 token的name token.name.call(function(err, result){ console.log(err, JSON.stringify(result)); }); //输出balance token.balanceOf.call(address, function(err, result){ console.log( &quot;721 getBalanceof&quot;,err, JSON.stringify(result)); }); //输出该tokenID的属性 token.getProperty.call(tokenID, function(err, result){ console.log( &quot;721 getTitle&quot;,err, JSON.stringify(result)); }); //输出tokenID的拥有者 token.ownerOf.call(tokenID, function(err, result){ console.log( &quot;721 ownerOf&quot;,err, JSON.stringify(result)); }); //输出某个地址拥有的所有tokenID token.tokensOfOwner.call(address, function(err, result){ console.log( &quot;721 tokensOfOwner&quot;,err, JSON.stringify(result)); }); } //调用erc721合约 //创建721token callContract1(chain3, account, contractAddress, address, abiString) function callContract1(chain3, account, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(&#39;data&#39;, token.createToken.getData(&quot;property&quot;,address)); //导入token的属性 var privateKey = new Buffer(account.secret, &quot;hex&quot;); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(400000), to: contractAddress, data: token.createToken.getData(&quot;property&quot;,address), chainId: chain3.version.network, }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); }else{ console.log(&quot;error:&quot;, err.message); } }); } //调用erc721合约 //发送721token var tokenID = 100; //721token编号 var anotherAddress = &quot;0x745c57ca5318093115d61bbca3687ca02cxxxxxx&quot;; //接收地址 callContract2(chain3, account, contractAddress, anotherAddress, tokenID, abiString) function callContract2(chain3, account, contractAddress, anotherAddress, tokenID, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); console.log(&#39;data&#39;, token.transfer.getData(anotherAddress,tokenID )); var privateKey = new Buffer(account.secret, &quot;hex&quot;); var txCount = chain3.mc.getTransactionCount(account.address); var rawTx = { nonce: chain3.intToHex(txCount), gasPrice: chain3.intToHex(25000000000), gasLimit: chain3.intToHex(400000), to: contractAddress, data: token.transfer.getData(anotherAddress,tokenID ), chainId: chain3.version.network, }; var signedTx = chain3.signTransaction(rawTx, account.secret); chain3.mc.sendRawTransaction(signedTx, function(err, hash) { if (!err){ console.log(&quot;succeed: &quot;, hash); }else{ console.log(&quot;error:&quot;, err.message); } }); } //调用721合约的时候 //得到所有拥有该721token的地址 var tokenNow = 0; //tokenID从该编号开始，必须 &gt;= 0 var tokenMax = 8; //tokenID到该编号结束，必须已经create token到该编号 callContract3(tokenNow, chain3, contractAddress, address, abiString); function callContract3(tokenNow, chain3, contractAddress, address, abiString){ var abi = JSON.parse(abiString); var contract = chain3.mc.contract(abi); var token = contract.at(contractAddress); //console.log(&quot;以下输出721合约的owner：&quot;); token.ownerOf.call(tokenNow, function(err, result){ console.log( &quot;721 ownerOf&quot;,tokenNow,err, JSON.stringify(result)); }); //通过tokenID循环 if (tokenNow &lt; tokenMax){ allContract3(tokenNow+1, chain3, contractAddress, address, abiString); } } &nbsp; 阅读更多","@type":"BlogPosting","url":"/2018/07/30/b620a3760932da2bfd3919a920f3b436.html","headline":"第八篇 墨客区块链(MOAC BlockChain) 程序猿怎么部署和调用智能合约","dateModified":"2018-07-30T00:00:00+08:00","datePublished":"2018-07-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/07/30/b620a3760932da2bfd3919a920f3b436.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>第八篇 墨客区块链(MOAC BlockChain) 程序猿怎么部署和调用智能合约</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：Copyright Reserved © 2018-2020 https://blog.csdn.net/lyq13573221675/article/details/81285250 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>在本博客《<a href="https://blog.csdn.net/lyq13573221675/article/details/81085339" rel="nofollow">第四篇 在墨客区块链（MOAC BlockChain）部署ERC-20合约</a>》和《<a href="https://blog.csdn.net/lyq13573221675/article/details/81109474" rel="nofollow">第五篇 在墨客区块链（MOAC BlockChain）部署ERC-721合约</a>》，已经有使用网页版钱包部署智能合约的方法。</p> 
  <p>本文基于墨客区块链（MOAC BlockChain），详细说明使用代码部署和调用智能合约的方法。</p> 
  <p><strong>环境：</strong></p> 
  <p>墨客区块链版本：<a href="https://github.com/MOACChain/moac-core/releases/download/v1.0.2/nuwa-vnode1.0.2.win.zip" rel="nofollow"><strong>nuwa-vnode1.0.2.win.zip</strong></a>；</p> 
  <p>操作系统：64位Windows 10家庭版。</p> 
  <p>&nbsp;</p> 
  <p><strong>1.安装并启动本地节点</strong></p> 
  <p><strong>1.1 安装moac节点</strong></p> 
  <p>请参考文档《<a href="https://blog.csdn.net/lyq13573221675/article/details/81078424" rel="nofollow">第三篇 墨客区块链（MOAC BlockChain）节点安装教程</a>》。</p> 
  <p><strong>1.2 启动moac节点</strong></p> 
  <p>打开命令终端（cmd），转到墨客当前目录，在命令行中执行：</p> 
  <pre class="has">
<code>D:\nuwa1.0.2.win&gt;moac --rpc</code></pre> 
  <p>确保本地节点中某个账号有足够的moac以进行智能合约部署和调用。</p> 
  <p>&nbsp;</p> 
  <p><strong>2.编写并编译智能合约</strong></p> 
  <p><strong>2.1 编写智能合约</strong></p> 
  <p>本篇实际测试代码TestToken20.sol附在《<a href="https://blog.csdn.net/lyq13573221675/article/details/81085339" rel="nofollow">第四篇 在墨客区块链（MOAC BlockChain）部署ERC-20合约</a>》文章末尾，TestToken721.sol附在《<a href="https://blog.csdn.net/lyq13573221675/article/details/81109474" rel="nofollow">第五篇 在墨客区块链（MOAC BlockChain）部署ERC-721合约</a>》文章末尾。</p> 
  <p>修改20合约TestToken20.sol的参数部分，直接写入参数值。</p> 
  <pre class="has">
<code>    uint256 public totalSupply = 1000000;	        //发行总量
    string  public name = "My test token";              //名称
    uint8   public decimals = 8;               	        //返回token使用的小数点位数。
    string  public symbol = "MTT";                      //token简称</code></pre> 
  <p>这样在部署的时候不需要导入参数。</p> 
  <p><strong>注意：</strong>这些代码为测试实例使用，非标准部署智能合约代码。</p> 
  <p><strong>2.2 使用本地solidity编译器编译合约</strong></p> 
  <p>需要有本地的solidity编译环境。安装命令：</p> 
  <pre class="has">
<code>C:&gt;npm install -g solc            //默认安装最新版本
C:&gt;npm install -g solc@0.4.21     //安装指定版本</code></pre> 
  <p>进入<span style="color:#4f4f4f;">TestToken20.sol所在目录，编译合约：</span></p> 
  <pre class="has">
<code>C:&gt;solcjs --bin --abi -o bin TestToken20.sol
</code></pre> 
  <p>运行后，输出<span style="color:#4f4f4f;">TestToken20</span>.abi及<span style="color:#4f4f4f;">TestToken20</span>.bin到bin目录下，<span style="color:#4f4f4f;">TestToken20</span>.abi里边放的就是abi的内容，<span style="color:#4f4f4f;">TestToken20</span>.bin里边放的就是bytecode的内容。</p> 
  <p><strong>2.3 使用remix编译合约</strong></p> 
  <p><a href="https://link.jianshu.com/?t=remix.ethereum.org" rel="nofollow">Remix</a>是一个开发Solidity智能合约的网络版开发软件。</p> 
  <p>登陆<a href="https://link.jianshu.com/?t=remix.ethereum.org" rel="nofollow">Remix</a>&nbsp;后，把中间的编辑框里的合约内容删除，然后把自己的合约代码复制到编辑框里。在右上角的菜单里Compile下面选中Auto Compile。</p> 
  <p>编译后会在右边区域显示是否有error、warning等信息。如果没有报错（Warning可以忽略），点击“Details”显示编译后详细信息。</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/2018073016571296?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>可以得到跟2.2节一样的bytecode内容和abi内容。拷贝出来备用。</p> 
  <p>还有FUNCTIONHASHES，包含了本合约中的函数通过hash算法Keccak256得到前4个字节，调用合约时会用到。</p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180730171317684?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>&nbsp;</p> 
  <p><strong>3.部署智能合约</strong></p> 
  <p><strong>3.1 部署</strong></p> 
  <p>部署智能合约文件deploy.js，内容如下：</p> 
  <pre class="has">
<code>var abiString = '[{"constant":true,"inputs":[],"name":"name",......"type":"event"}]';     //编译结果的abi
var bytecodeString = '606060405234801561001057600080fd5b5060......75fd0029';              //编译结果的bytecode
var account = {address:"0x745c57ca5318093115d61bbca368XXXXXXXXXXXX",secret:"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"};

var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://localhost:8545'));

createContract(chain3, account, abiString, bytecodeString);

function createContract(chain3, account, abiString, bytecodeString){
    var bytecode = "0x" + bytecodeString;
    var abi = JSON.parse(abiString);

    console.log('bytecode', bytecode);
    console.log('abi', abiString);

    var gasValue = chain3.mc.estimateGas({data: bytecode});
    console.log("gas estimate on contract:", gasValue);

    var address = account.address;
    var secret = account.secret;

    var txCount = chain3.mc.getTransactionCount(address);
    console.log("get tx account", txCount)
    
    var rawTx = {
        from: address,
        nonce: chain3.intToHex(txCount),
        gasPrice: chain3.intToHex(25000000000),
        gasLimit: chain3.intToHex(400000),
        data: bytecode,
        chainId: chain3.version.network,
    };

    var signedTx = chain3.signTransaction(rawTx, account.secret);

    console.log("send signed tx:", signedTx);
    console.log("len", signedTx.length);

    chain3.mc.sendRawTransaction(signedTx, function(err, hash) {
        if (!err){
            console.log("succeed: ", hash);
        }else{
            console.log("error:", err.message);
        }
    });
}
</code></pre> 
  <p>代码中的account是本地节点的一个账号，需要付出本次部署智能合约的gas费。部署后的合约也归该账号所有。</p> 
  <p>合约部署完成后，如果没有报错，会返回一个hash值，通过这个hash值到浏览器可以查询到本次合约部署的详细信息。</p> 
  <p>或者通过节点命令得到相应信息。</p> 
  <pre class="has">
<code>&gt;mc.getTransactionReceipt("transactionHash")</code></pre> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180731111448422?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5cTEzNTczMjIxNjc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p><strong>3.2 从keystore得到privateKey</strong></p> 
  <p>本节中部署智能合约时，代码使用sendRawTransaction需要私钥签名，得到本地节点账号的私钥有两种方式：</p> 
  <ul>
   <li>方式一：使用“keystore + password”的方式将账号导入手机版钱包TokenPocket，然后导出私钥。</li> 
   <li>方式二：使用如下代码getPrivateKey.js得到本地节点账号的私钥。</li> 
  </ul>
  <pre class="has">
<code>var keythereum = require("keythereum");
var datadir = "C:\\Users\\lyq2018\\AppData\\Roaming\\MoacNode";  //moacnode目录，根据实际修改
//var datadir = "/Users/gm/Library/MoacNode";                    //苹果mac系统moacnode目录，根据实际修改
var address= "0x68986c1bcd54ae5dae69310XXXXXXXXXXXXXXXXX";       //本地节点账号，根据实际修改
const password = "password";                                     //账号密码，根据实际修改

var keyObject = keythereum.importFromFile(address, datadir);
var privateKey = keythereum.recover(password, keyObject);        //输出私钥
console.log(privateKey.toString('hex'));</code></pre> 
  <p>代码运行需要nodejs和python2.7环境，同时需要导入keythereum。</p> 
  <pre class="has">
<code>c:\&gt;npm install -g keythereum</code></pre> 
  <p><strong>3.3 从privateKey得到keystore</strong></p> 
  <p>有时候用户会需要从私钥导出keystore用于节点，此时得到本地节点账号的keystore有两种方式：</p> 
  <ul>
   <li>方式一：使用“私钥”的方式将账号导入手机版钱包TokenPocket，然后导出为keystore。</li> 
   <li>方式二：使用如下代码getKeystore.js得到本地节点账号的keystore。</li> 
  </ul>
  <pre class="has">
<code>var Wallet = require('ethereumjs-wallet');
var privateKey = 'bb673026deda3c3cd0c63f6ccddfb02a7ae320078aa8XXXXXXXXXXXXXXXXXXXX';
var key = Buffer.from(privateKey, 'hex');
var wallet = Wallet.fromPrivateKey(key);
    
wallet.toV3String('password');
console.log("Get keystore", wallet.toV3String('password'));</code></pre> 
  <p>代码运行需要nodejs和python2.7环境，同时需要导入ethereumjs-wallet。</p> 
  <pre class="has">
<code>c:\&gt;npm install -g ethereumjs-wallet</code></pre> 
  <p>安装时如果报类似“npm ERR! Unexpected end of JSON input while parsing near......”的错，可以先清理缓存再安装。</p> 
  <pre class="has">
<code>c:\&gt;npm cache clean --force</code></pre> 
  <p>&nbsp;</p> 
  <p><strong>4.调用智能合约</strong></p> 
  <p>以下为TestToken20.sol的调用代码，call_erc20.js。</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://localhost:8545'));

var contractAddress = "0xA2580D58A58998ca06e6f5b2A96AXXXXXXXXXXXX";                       //智能合约地址
var address = "0x68986c1BCD54Ae5dAe69310fC64EXXXXXXXXXXXX";
var account = {address:"0x68986c1BCD54Ae5dAe69310fC64XXXXXXXXXXXX",secret:"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"};
var abiString = '[{"constant":true,"inputs":[],"name":"name",......"type":"event"}]';     //智能合约的abi

//调用erc20合约
//基本属性
callContract1(chain3, contractAddress, address, abiString);

function callContract1(chain3, contractAddress, address, abiString){
    var abi = JSON.parse(abiString);
    var contract = chain3.mc.contract(abi);
    var token = contract.at(contractAddress);
  
    console.log(JSON.stringify(token.totalSupply()));      //总量
    console.log(JSON.stringify(token.name()));             //名称
    console.log(JSON.stringify(token.decimals()));         //位数
    console.log(JSON.stringify(token.symbol()));           //简称
}

//调用erc20合约
//通过abi生成智能合约对象, 直接通过对应合约方法进行call调用
//查询余额
callContract2(chain3, contractAddress, address, abiString);

function callContract2(chain3, contractAddress, address, abiString){
    var abi = JSON.parse(abiString);
    var contract = chain3.mc.contract(abi);
    var token = contract.at(contractAddress);
    token.balanceOf.call(address, function(err, result){
        console.log(err, JSON.stringify(result));
    });
}

//调用erc20合约
//通过对交易签名进行调用
//发送代币
var amount = 100;                                                       //发送数量
var anotherAddress = "0x745c57ca5318093115d61bbca3687ca02cxxxxxx";      //接收地址
callContract3(chain3, contractAddress, account, abiString, anotherAddress, amount);

function callContract3(chain3, contractAddress, account, abiString, anotherAddress, amount){
    var address = account.address;
    var abi = JSON.parse(abiString);
    var contract = chain3.mc.contract(abi);
    var token = contract.at(contractAddress);

    var data = token.transfer.getData(anotherAddress, amount);
    console.log('data', data);
    var txCount = chain3.mc.getTransactionCount(account.address);
    var rawTx = {
        nonce: chain3.intToHex(txCount),
        gasPrice: chain3.intToHex(25000000000),
        gasLimit: chain3.intToHex(100000),
        to: contractAddress,
        data: data,
        chainId: chain3.version.network
    };
    var signedTx = chain3.signTransaction(rawTx, account.secret);
    chain3.mc.sendRawTransaction(signedTx, function(err, hash) {
        if (!err){
            console.log("succeed: ", hash);
            var filter = chain3.mc.filter('latest');
            filter.watch(function(error, result) {
                var receipt = chain3.mc.getTransaction(hash);
                if (!error &amp;&amp; receipt &amp;&amp; receipt.blockNumber != null) {
                    console.log("done.");
                    filter.stopWatching();
                    process.exit(0);
                }
            });
        }else{
            console.log("error:", err.message);
        }
    });
}</code></pre> 
  <p>以上代码三个调用实例的函数分别为callContract1、callContract2、callContract3；可以根据需要单独或组合使用。</p> 
  <p>&nbsp;</p> 
  <p>以下为TestToken721.sol的调用代码，call_erc721.js。</p> 
  <pre class="has">
<code>var Chain3 = require('chain3');
var chain3 = new Chain3(new Chain3.providers.HttpProvider('http://localhost:8545'));

var contractAddress = "0xA2580D58A58998ca06e6f5b2A96AXXXXXXXXXXXX";                       //智能合约地址
var address = "0x68986c1BCD54Ae5dAe69310fC64EXXXXXXXXXXXX";
var account = {address:"0x68986c1BCD54Ae5dAe69310fC64XXXXXXXXXXXX",secret:"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"};
var abiString = '[{"constant":true,"inputs":[],"name":"name",......"type":"event"}]';     //智能合约的abi

//调用erc721合约
//读合约
callContract(chain3, contractAddress, address, abiString);

function callContract(chain3, contractAddress, address, abiString){
    var abi = JSON.parse(abiString);
    var contract = chain3.mc.contract(abi);
    var token = contract.at(contractAddress);
    var tokenID = 5;		//从0开始的编号
    
    //输出721 token的name
    token.name.call(function(err, result){
        console.log(err, JSON.stringify(result));
    });
	
    //输出balance
    token.balanceOf.call(address, function(err, result){
        console.log( "721 getBalanceof",err, JSON.stringify(result));
    });
	
    //输出该tokenID的属性
    token.getProperty.call(tokenID, function(err, result){
        console.log( "721 getTitle",err, JSON.stringify(result));
    });	
		
    //输出tokenID的拥有者
    token.ownerOf.call(tokenID, function(err, result){
        console.log( "721 ownerOf",err, JSON.stringify(result));
    });

    //输出某个地址拥有的所有tokenID
    token.tokensOfOwner.call(address, function(err, result){
        console.log( "721 tokensOfOwner",err, JSON.stringify(result));
    });	
}

//调用erc721合约
//创建721token
callContract1(chain3, account, contractAddress, address, abiString)

function callContract1(chain3, account, contractAddress, address, abiString){
    var abi = JSON.parse(abiString);
    var contract = chain3.mc.contract(abi);
    var token = contract.at(contractAddress);

    console.log('data', token.createToken.getData("property",address));    //导入token的属性
    var privateKey = new Buffer(account.secret, "hex");
    var txCount = chain3.mc.getTransactionCount(account.address);
    var rawTx = {
        nonce: chain3.intToHex(txCount),
        gasPrice: chain3.intToHex(25000000000),
        gasLimit: chain3.intToHex(400000),
        to: contractAddress,
        data: token.createToken.getData("property",address),
        chainId: chain3.version.network,
    };

    var signedTx = chain3.signTransaction(rawTx, account.secret);
    chain3.mc.sendRawTransaction(signedTx, function(err, hash) {
        if (!err){
            console.log("succeed: ", hash);
        }else{
            console.log("error:", err.message);
        }
    });
}

//调用erc721合约
//发送721token
var tokenID = 100;                                                      //721token编号
var anotherAddress = "0x745c57ca5318093115d61bbca3687ca02cxxxxxx";      //接收地址
callContract2(chain3, account, contractAddress, anotherAddress, tokenID, abiString)

function callContract2(chain3, account, contractAddress, anotherAddress, tokenID, abiString){
    var abi = JSON.parse(abiString);
    var contract = chain3.mc.contract(abi);
    var token = contract.at(contractAddress);

    console.log('data', token.transfer.getData(anotherAddress,tokenID ));
    var privateKey = new Buffer(account.secret, "hex");
    var txCount = chain3.mc.getTransactionCount(account.address);
    var rawTx = {
        nonce: chain3.intToHex(txCount),
        gasPrice: chain3.intToHex(25000000000),
        gasLimit: chain3.intToHex(400000),
        to: contractAddress,
        data: token.transfer.getData(anotherAddress,tokenID ),
        chainId: chain3.version.network,
    };

    var signedTx = chain3.signTransaction(rawTx, account.secret);
    chain3.mc.sendRawTransaction(signedTx, function(err, hash) {
        if (!err){
            console.log("succeed: ", hash);
        }else{
            console.log("error:", err.message);
        }
    });
}

//调用721合约的时候
//得到所有拥有该721token的地址
var tokenNow = 0;    //tokenID从该编号开始，必须 &gt;= 0
var tokenMax = 8;    //tokenID到该编号结束，必须已经create token到该编号
callContract3(tokenNow, chain3, contractAddress, address, abiString);

function callContract3(tokenNow, chain3, contractAddress, address, abiString){
    var abi = JSON.parse(abiString);
    var contract = chain3.mc.contract(abi);
    var token = contract.at(contractAddress);  
    //console.log("以下输出721合约的owner：");
    token.ownerOf.call(tokenNow, function(err, result){
        console.log( "721 ownerOf",tokenNow,err, JSON.stringify(result));
    });
    //通过tokenID循环
    if (tokenNow &lt; tokenMax){
        allContract3(tokenNow+1, chain3, contractAddress, address, abiString);
    }	
}
</code></pre> 
  <p>&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lyq13573221675/article/details/81285250,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lyq13573221675/article/details/81285250,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
