<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>深入浅出区块链教程——3.浅说区块链共识机制 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="深入浅出区块链教程——3.浅说区块链共识机制" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="浅说区块链共识机制 区块链发展至今，已经形成了各种不同类型的共识机制，这里我们就展开聊一聊区块链共识机制到底是什么，以及区块链的共识过程到底是怎样的。 分布式系统的经典问题： 拜占庭将军问题 拜占庭将军问题其实是虚构出来的一个故事，是为了方便通俗地介绍分布式系统所面临的难题。这里仅作一个简短的说明，你可以在中文社区找到更丰富的通俗解释材料。 为了避免重复，我们换一种表述形式，还是以上一次的村子为例，假设随着村子和人口的发展，大村子演变成了十一个小村子并分散在各地，各地的通信只能靠信鸽进行。 大家约定了每年都会举办一个相亲大会，至于谁能举办，每年轮流从两个备选村子，A 村和 B 村中选择一个，然后大家投票，票数多者可以赢得举办权。 由于地图很大，任何一个村子的投票都无法靠一只信鸽传输到每个村子，必须靠一个中继村子代为传输，这也就意味着有中继村子可以读到其他村子的投票信息。 那么，如何防止下面两个问题的出现呢？ 投票者的“精分”，这里所谓的“精分”是指某个村子的投票行为不一致，发送给第一个村子的投票消息为“投票给 A”，而发送给第二个村子的投票消息却为“投票给 B”。 中继村子作弊，即篡改上一村的投票消息。 上面讨论的问题我们可以认为是简化的 “拜占庭将军问题”（完整的拜占庭将军问题还有将军 - 副官模型，如果感兴趣的话，你可以自行阅读）。 我们回头再看区块链。区块链本质上也是分布式系统的一种，其共识机制也是为了上述问题而提出的解决方案。 什么是区块链共识机制？ 共识机制是区块链是核心的组成要素之一，它决定了区块链的业务吞吐量、交易速度、不可篡改性、准入门槛等等，是最为关键的技术要素之一。 要理解区块链共识机制，首先就需要理解区块链共识机制到底解决了什么问题。 共识机制主要解决了两个问题： 谁有权利； 作弊问题。 上一次我们构造了一个中心化记账的场景，在这个场景下，记账问题其实可以简化为大家信任中心记账者即可。 然而在分布式记账的场景下，问题更为复杂。首先，大家面临的最大问题是谁有权利记账，其次是如何避免记账者作弊。毕竟，谁都有权利记账，也就意味着谁都有可能作弊。 以上两部分共同构成了区块链共识机制。 另外补充一点，在比特币社区，“共识”（consensus）这个词已经跳出了技术的范畴。通常人们在表述一个比特币上的问题时，共识的内涵还包括比特币的使用者、开发者、矿工来达成社区共识的部分，所以“共识”这个词在区块链领域还有些“民主”的味道，不单单是技术领域的“共识”。 最经典的入门型共识机制：PoW 工作量证明 PoW （Proof of Work）工作量证明可以解决上述的两个问题， 还记得上文提到的“24 点”那个游戏吗？“24 点”其实是尽可能随机地选取系统中任意的节点来规避作弊者，这个方案的实践其实就是 PoW 共识机制。 产生记账者的随机性其实来自于谁最先计算出 24 点的答案，这个问题可以简化成谁拥有的计算资源更多，谁就拥有整个系统的最大概率的记账权。一旦这个概率超过一半以上，那么这个系统就有一定的中心化风险。 如何理解上面一段话呢？ 举个例子，李四家发明了一种算盘，可以快速计算 24 点答案，比起其他人掰手指头，李四家总是有很大的概率拿下记账权，换句话说，也就是李四和全村其他所有人竞争，相当于算盘对全村其他人手指头的竞争。 如果算盘足够强大，就能有一半的概率获得记账权，那么李四个人的诚实性，就成为了系统的唯一破绽。 比如李四在第一次记账时篡改部分交易，第二次还是他记账，还继续篡改交易，那么两次修改如果自洽的话，是可以形成假账的，这就是所谓的中心化风险。 在比特币的51%攻击中，当攻击块链的长度超过原块链2个区块，所有的客户端将丢弃原块链，接受攻击块链。ref 如果攻击链只篡改了一个区块，那么广播的时候其他结点会进行验证，这样篡改信息一下子就暴露了。难点在于篡改之后要持续篡改，直到超过主分支两个区块（注意这里是超过主分支2个区块，而不是篡改2个区块，实际上可能要连续篡改很长一段区块，这得储蓄保证很高的算力），这样攻击链才能成为主分支。 所以在 PoW 这种机制中，计算资源（又称算力）是决定记账权的唯一因素。与之对应的，便是计算难度。 计算难度又称作挖矿难度，计算难度是区块链为了控制产生答案的速度，比如平均 10 分钟就有一个答案产生，平均 2 分钟一个答案产生。 在上述场景中，因为李四有了算盘，强大的计算资源突然加入以后，肯定会让整个系统的产生答案的速度变快很多，作为系统本身会自适应，将难度提升，降低答案产生的速度。 上面介绍了这么多，其实是想引出另外一个问题，PoW 到底是如何避免作弊者的呢？答案就是计算资源（算力）。 设想，如果一个作弊者想篡改信封里面的交易，首先得获得记账权，也就是装信封的权利。 而影响记账权的唯一因素只有计算资源（算力）的大小，如果想篡改交易，只能投入大量的计算资源与整个系统中其他所有人进行对抗，这是十分困难的，尤其在整个系统有一定基础计算资源（算力）的情况下。 PoW 中一个有趣的设计是激励机制，在 PoW 共识机制下，我们假设所有 参与者都是理性的 ，理性的意思就是单纯逐利，不考虑家庭、爱好等其他因素。有了理性的前提，PoW 共识机制会给每个诚实的记账者予以奖励，这个设计可以抗击作弊收益的问题。 怎么进行抗击的呢？整个过程是这样的，理性的人如果作弊、篡改账本肯定需要投入成本，也就是计算资源，而篡改后的收益是篡改账本获得的收益减去投入成本，而如果把相同的资源用于正常挖矿，那么获得的收益将更多。所以，作弊者在作弊过程中投入的计算资源过大，反而得不偿失。 PoW 工作量证明的补充：解决双花攻击 上面给出了一个结论，我们说作弊的收益往往小于诚实计算的收益。这一点其实对应到区块链领域有个著名的问题：双花攻击（double-spending） 。 双花攻击是指一个代币被花费了两次，这在任意的区块链系统中是不被允许的。如果避免了双花问题，基本就能避免上述作弊中收益过大的问题，因为攻击者首先要窃取到你的私钥，同时又能控制了你的计算资源（算力）。 为了方便分析，我们回到上一篇中广播交易的那一节。那一节中我介绍了广播的内容分为两种，第一种是 Transaction，第二种是区块，也就是信封。 第一种又被称为未确认的 Transaction，第二种信封中所有的交易被称作已确认的 Transaction。 所有记账节点都会遵循以下两条规则： 规则一：一个代币如果已经被花费，那么会被标记成已花费，如果再次接收到这个代币被花费的请求，那么记账节点会拒绝打包这笔交易； 规则二：如果同时接收到两个信封，这两个信封中装的两笔交易出现了一个代币被花费了两次的情况，这种情况也就是我们所说的分叉（Fork），那么选择挖矿难度比较大的那个信封。 规则一避免了未确认的交易出现双花，规则二基本避免已经确认的交易中（信封中）的双花问题。 假设作弊者的计算资源（算力）占整个系统的 30%，那么连续两次获得记账权的概率是 9%，看起来作弊的可能性还是挺高的，如果是连续 6 次获得记账权呢？概率直降到万分之七。（达到6个确认就安全记录在案了） 在比特币中，这个 6 也就是 6 次确认，表示连续 6 个块过去了，如果我的交易没有被双花的话，那么它被篡改的可能性将越来越小，最后变得几乎不可能被篡改。这也是区块链不可被篡改说法的由来。（但并不是不可能连续产生！！！可以参考51%攻击） 试想，如果任何作弊者花了大量的成本获取了系统 30% 的计算资源（算力），最后只有万分之七的概率获得篡改的可能性，比起作弊，还不如诚实记账的收益高。 总结 这里只是简单地列举了比特币中的POW共识机制，其最巧妙的设计是将数字系统和实体资源相挂钩，用经济学上的博弈来抑制数字系统的篡改（可以做恶篡改，但是无利可图），这是比特币的不可篡改原理。 而抛开比特币单独来看区块链，尤其是那些规模较小的链，从技术层面其实是可以被篡改的。 上一篇：区块链到底是怎么运行的 下一篇：区块链的应用类型 目录：深入浅出区块链教程 阅读更多" />
<meta property="og:description" content="浅说区块链共识机制 区块链发展至今，已经形成了各种不同类型的共识机制，这里我们就展开聊一聊区块链共识机制到底是什么，以及区块链的共识过程到底是怎样的。 分布式系统的经典问题： 拜占庭将军问题 拜占庭将军问题其实是虚构出来的一个故事，是为了方便通俗地介绍分布式系统所面临的难题。这里仅作一个简短的说明，你可以在中文社区找到更丰富的通俗解释材料。 为了避免重复，我们换一种表述形式，还是以上一次的村子为例，假设随着村子和人口的发展，大村子演变成了十一个小村子并分散在各地，各地的通信只能靠信鸽进行。 大家约定了每年都会举办一个相亲大会，至于谁能举办，每年轮流从两个备选村子，A 村和 B 村中选择一个，然后大家投票，票数多者可以赢得举办权。 由于地图很大，任何一个村子的投票都无法靠一只信鸽传输到每个村子，必须靠一个中继村子代为传输，这也就意味着有中继村子可以读到其他村子的投票信息。 那么，如何防止下面两个问题的出现呢？ 投票者的“精分”，这里所谓的“精分”是指某个村子的投票行为不一致，发送给第一个村子的投票消息为“投票给 A”，而发送给第二个村子的投票消息却为“投票给 B”。 中继村子作弊，即篡改上一村的投票消息。 上面讨论的问题我们可以认为是简化的 “拜占庭将军问题”（完整的拜占庭将军问题还有将军 - 副官模型，如果感兴趣的话，你可以自行阅读）。 我们回头再看区块链。区块链本质上也是分布式系统的一种，其共识机制也是为了上述问题而提出的解决方案。 什么是区块链共识机制？ 共识机制是区块链是核心的组成要素之一，它决定了区块链的业务吞吐量、交易速度、不可篡改性、准入门槛等等，是最为关键的技术要素之一。 要理解区块链共识机制，首先就需要理解区块链共识机制到底解决了什么问题。 共识机制主要解决了两个问题： 谁有权利； 作弊问题。 上一次我们构造了一个中心化记账的场景，在这个场景下，记账问题其实可以简化为大家信任中心记账者即可。 然而在分布式记账的场景下，问题更为复杂。首先，大家面临的最大问题是谁有权利记账，其次是如何避免记账者作弊。毕竟，谁都有权利记账，也就意味着谁都有可能作弊。 以上两部分共同构成了区块链共识机制。 另外补充一点，在比特币社区，“共识”（consensus）这个词已经跳出了技术的范畴。通常人们在表述一个比特币上的问题时，共识的内涵还包括比特币的使用者、开发者、矿工来达成社区共识的部分，所以“共识”这个词在区块链领域还有些“民主”的味道，不单单是技术领域的“共识”。 最经典的入门型共识机制：PoW 工作量证明 PoW （Proof of Work）工作量证明可以解决上述的两个问题， 还记得上文提到的“24 点”那个游戏吗？“24 点”其实是尽可能随机地选取系统中任意的节点来规避作弊者，这个方案的实践其实就是 PoW 共识机制。 产生记账者的随机性其实来自于谁最先计算出 24 点的答案，这个问题可以简化成谁拥有的计算资源更多，谁就拥有整个系统的最大概率的记账权。一旦这个概率超过一半以上，那么这个系统就有一定的中心化风险。 如何理解上面一段话呢？ 举个例子，李四家发明了一种算盘，可以快速计算 24 点答案，比起其他人掰手指头，李四家总是有很大的概率拿下记账权，换句话说，也就是李四和全村其他所有人竞争，相当于算盘对全村其他人手指头的竞争。 如果算盘足够强大，就能有一半的概率获得记账权，那么李四个人的诚实性，就成为了系统的唯一破绽。 比如李四在第一次记账时篡改部分交易，第二次还是他记账，还继续篡改交易，那么两次修改如果自洽的话，是可以形成假账的，这就是所谓的中心化风险。 在比特币的51%攻击中，当攻击块链的长度超过原块链2个区块，所有的客户端将丢弃原块链，接受攻击块链。ref 如果攻击链只篡改了一个区块，那么广播的时候其他结点会进行验证，这样篡改信息一下子就暴露了。难点在于篡改之后要持续篡改，直到超过主分支两个区块（注意这里是超过主分支2个区块，而不是篡改2个区块，实际上可能要连续篡改很长一段区块，这得储蓄保证很高的算力），这样攻击链才能成为主分支。 所以在 PoW 这种机制中，计算资源（又称算力）是决定记账权的唯一因素。与之对应的，便是计算难度。 计算难度又称作挖矿难度，计算难度是区块链为了控制产生答案的速度，比如平均 10 分钟就有一个答案产生，平均 2 分钟一个答案产生。 在上述场景中，因为李四有了算盘，强大的计算资源突然加入以后，肯定会让整个系统的产生答案的速度变快很多，作为系统本身会自适应，将难度提升，降低答案产生的速度。 上面介绍了这么多，其实是想引出另外一个问题，PoW 到底是如何避免作弊者的呢？答案就是计算资源（算力）。 设想，如果一个作弊者想篡改信封里面的交易，首先得获得记账权，也就是装信封的权利。 而影响记账权的唯一因素只有计算资源（算力）的大小，如果想篡改交易，只能投入大量的计算资源与整个系统中其他所有人进行对抗，这是十分困难的，尤其在整个系统有一定基础计算资源（算力）的情况下。 PoW 中一个有趣的设计是激励机制，在 PoW 共识机制下，我们假设所有 参与者都是理性的 ，理性的意思就是单纯逐利，不考虑家庭、爱好等其他因素。有了理性的前提，PoW 共识机制会给每个诚实的记账者予以奖励，这个设计可以抗击作弊收益的问题。 怎么进行抗击的呢？整个过程是这样的，理性的人如果作弊、篡改账本肯定需要投入成本，也就是计算资源，而篡改后的收益是篡改账本获得的收益减去投入成本，而如果把相同的资源用于正常挖矿，那么获得的收益将更多。所以，作弊者在作弊过程中投入的计算资源过大，反而得不偿失。 PoW 工作量证明的补充：解决双花攻击 上面给出了一个结论，我们说作弊的收益往往小于诚实计算的收益。这一点其实对应到区块链领域有个著名的问题：双花攻击（double-spending） 。 双花攻击是指一个代币被花费了两次，这在任意的区块链系统中是不被允许的。如果避免了双花问题，基本就能避免上述作弊中收益过大的问题，因为攻击者首先要窃取到你的私钥，同时又能控制了你的计算资源（算力）。 为了方便分析，我们回到上一篇中广播交易的那一节。那一节中我介绍了广播的内容分为两种，第一种是 Transaction，第二种是区块，也就是信封。 第一种又被称为未确认的 Transaction，第二种信封中所有的交易被称作已确认的 Transaction。 所有记账节点都会遵循以下两条规则： 规则一：一个代币如果已经被花费，那么会被标记成已花费，如果再次接收到这个代币被花费的请求，那么记账节点会拒绝打包这笔交易； 规则二：如果同时接收到两个信封，这两个信封中装的两笔交易出现了一个代币被花费了两次的情况，这种情况也就是我们所说的分叉（Fork），那么选择挖矿难度比较大的那个信封。 规则一避免了未确认的交易出现双花，规则二基本避免已经确认的交易中（信封中）的双花问题。 假设作弊者的计算资源（算力）占整个系统的 30%，那么连续两次获得记账权的概率是 9%，看起来作弊的可能性还是挺高的，如果是连续 6 次获得记账权呢？概率直降到万分之七。（达到6个确认就安全记录在案了） 在比特币中，这个 6 也就是 6 次确认，表示连续 6 个块过去了，如果我的交易没有被双花的话，那么它被篡改的可能性将越来越小，最后变得几乎不可能被篡改。这也是区块链不可被篡改说法的由来。（但并不是不可能连续产生！！！可以参考51%攻击） 试想，如果任何作弊者花了大量的成本获取了系统 30% 的计算资源（算力），最后只有万分之七的概率获得篡改的可能性，比起作弊，还不如诚实记账的收益高。 总结 这里只是简单地列举了比特币中的POW共识机制，其最巧妙的设计是将数字系统和实体资源相挂钩，用经济学上的博弈来抑制数字系统的篡改（可以做恶篡改，但是无利可图），这是比特币的不可篡改原理。 而抛开比特币单独来看区块链，尤其是那些规模较小的链，从技术层面其实是可以被篡改的。 上一篇：区块链到底是怎么运行的 下一篇：区块链的应用类型 目录：深入浅出区块链教程 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/07/30/c136dbba7b2717764f6e0483ec54df78.html" />
<meta property="og:url" content="https://mlh.app/2018/07/30/c136dbba7b2717764f6e0483ec54df78.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-30T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"浅说区块链共识机制 区块链发展至今，已经形成了各种不同类型的共识机制，这里我们就展开聊一聊区块链共识机制到底是什么，以及区块链的共识过程到底是怎样的。 分布式系统的经典问题： 拜占庭将军问题 拜占庭将军问题其实是虚构出来的一个故事，是为了方便通俗地介绍分布式系统所面临的难题。这里仅作一个简短的说明，你可以在中文社区找到更丰富的通俗解释材料。 为了避免重复，我们换一种表述形式，还是以上一次的村子为例，假设随着村子和人口的发展，大村子演变成了十一个小村子并分散在各地，各地的通信只能靠信鸽进行。 大家约定了每年都会举办一个相亲大会，至于谁能举办，每年轮流从两个备选村子，A 村和 B 村中选择一个，然后大家投票，票数多者可以赢得举办权。 由于地图很大，任何一个村子的投票都无法靠一只信鸽传输到每个村子，必须靠一个中继村子代为传输，这也就意味着有中继村子可以读到其他村子的投票信息。 那么，如何防止下面两个问题的出现呢？ 投票者的“精分”，这里所谓的“精分”是指某个村子的投票行为不一致，发送给第一个村子的投票消息为“投票给 A”，而发送给第二个村子的投票消息却为“投票给 B”。 中继村子作弊，即篡改上一村的投票消息。 上面讨论的问题我们可以认为是简化的 “拜占庭将军问题”（完整的拜占庭将军问题还有将军 - 副官模型，如果感兴趣的话，你可以自行阅读）。 我们回头再看区块链。区块链本质上也是分布式系统的一种，其共识机制也是为了上述问题而提出的解决方案。 什么是区块链共识机制？ 共识机制是区块链是核心的组成要素之一，它决定了区块链的业务吞吐量、交易速度、不可篡改性、准入门槛等等，是最为关键的技术要素之一。 要理解区块链共识机制，首先就需要理解区块链共识机制到底解决了什么问题。 共识机制主要解决了两个问题： 谁有权利； 作弊问题。 上一次我们构造了一个中心化记账的场景，在这个场景下，记账问题其实可以简化为大家信任中心记账者即可。 然而在分布式记账的场景下，问题更为复杂。首先，大家面临的最大问题是谁有权利记账，其次是如何避免记账者作弊。毕竟，谁都有权利记账，也就意味着谁都有可能作弊。 以上两部分共同构成了区块链共识机制。 另外补充一点，在比特币社区，“共识”（consensus）这个词已经跳出了技术的范畴。通常人们在表述一个比特币上的问题时，共识的内涵还包括比特币的使用者、开发者、矿工来达成社区共识的部分，所以“共识”这个词在区块链领域还有些“民主”的味道，不单单是技术领域的“共识”。 最经典的入门型共识机制：PoW 工作量证明 PoW （Proof of Work）工作量证明可以解决上述的两个问题， 还记得上文提到的“24 点”那个游戏吗？“24 点”其实是尽可能随机地选取系统中任意的节点来规避作弊者，这个方案的实践其实就是 PoW 共识机制。 产生记账者的随机性其实来自于谁最先计算出 24 点的答案，这个问题可以简化成谁拥有的计算资源更多，谁就拥有整个系统的最大概率的记账权。一旦这个概率超过一半以上，那么这个系统就有一定的中心化风险。 如何理解上面一段话呢？ 举个例子，李四家发明了一种算盘，可以快速计算 24 点答案，比起其他人掰手指头，李四家总是有很大的概率拿下记账权，换句话说，也就是李四和全村其他所有人竞争，相当于算盘对全村其他人手指头的竞争。 如果算盘足够强大，就能有一半的概率获得记账权，那么李四个人的诚实性，就成为了系统的唯一破绽。 比如李四在第一次记账时篡改部分交易，第二次还是他记账，还继续篡改交易，那么两次修改如果自洽的话，是可以形成假账的，这就是所谓的中心化风险。 在比特币的51%攻击中，当攻击块链的长度超过原块链2个区块，所有的客户端将丢弃原块链，接受攻击块链。ref 如果攻击链只篡改了一个区块，那么广播的时候其他结点会进行验证，这样篡改信息一下子就暴露了。难点在于篡改之后要持续篡改，直到超过主分支两个区块（注意这里是超过主分支2个区块，而不是篡改2个区块，实际上可能要连续篡改很长一段区块，这得储蓄保证很高的算力），这样攻击链才能成为主分支。 所以在 PoW 这种机制中，计算资源（又称算力）是决定记账权的唯一因素。与之对应的，便是计算难度。 计算难度又称作挖矿难度，计算难度是区块链为了控制产生答案的速度，比如平均 10 分钟就有一个答案产生，平均 2 分钟一个答案产生。 在上述场景中，因为李四有了算盘，强大的计算资源突然加入以后，肯定会让整个系统的产生答案的速度变快很多，作为系统本身会自适应，将难度提升，降低答案产生的速度。 上面介绍了这么多，其实是想引出另外一个问题，PoW 到底是如何避免作弊者的呢？答案就是计算资源（算力）。 设想，如果一个作弊者想篡改信封里面的交易，首先得获得记账权，也就是装信封的权利。 而影响记账权的唯一因素只有计算资源（算力）的大小，如果想篡改交易，只能投入大量的计算资源与整个系统中其他所有人进行对抗，这是十分困难的，尤其在整个系统有一定基础计算资源（算力）的情况下。 PoW 中一个有趣的设计是激励机制，在 PoW 共识机制下，我们假设所有 参与者都是理性的 ，理性的意思就是单纯逐利，不考虑家庭、爱好等其他因素。有了理性的前提，PoW 共识机制会给每个诚实的记账者予以奖励，这个设计可以抗击作弊收益的问题。 怎么进行抗击的呢？整个过程是这样的，理性的人如果作弊、篡改账本肯定需要投入成本，也就是计算资源，而篡改后的收益是篡改账本获得的收益减去投入成本，而如果把相同的资源用于正常挖矿，那么获得的收益将更多。所以，作弊者在作弊过程中投入的计算资源过大，反而得不偿失。 PoW 工作量证明的补充：解决双花攻击 上面给出了一个结论，我们说作弊的收益往往小于诚实计算的收益。这一点其实对应到区块链领域有个著名的问题：双花攻击（double-spending） 。 双花攻击是指一个代币被花费了两次，这在任意的区块链系统中是不被允许的。如果避免了双花问题，基本就能避免上述作弊中收益过大的问题，因为攻击者首先要窃取到你的私钥，同时又能控制了你的计算资源（算力）。 为了方便分析，我们回到上一篇中广播交易的那一节。那一节中我介绍了广播的内容分为两种，第一种是 Transaction，第二种是区块，也就是信封。 第一种又被称为未确认的 Transaction，第二种信封中所有的交易被称作已确认的 Transaction。 所有记账节点都会遵循以下两条规则： 规则一：一个代币如果已经被花费，那么会被标记成已花费，如果再次接收到这个代币被花费的请求，那么记账节点会拒绝打包这笔交易； 规则二：如果同时接收到两个信封，这两个信封中装的两笔交易出现了一个代币被花费了两次的情况，这种情况也就是我们所说的分叉（Fork），那么选择挖矿难度比较大的那个信封。 规则一避免了未确认的交易出现双花，规则二基本避免已经确认的交易中（信封中）的双花问题。 假设作弊者的计算资源（算力）占整个系统的 30%，那么连续两次获得记账权的概率是 9%，看起来作弊的可能性还是挺高的，如果是连续 6 次获得记账权呢？概率直降到万分之七。（达到6个确认就安全记录在案了） 在比特币中，这个 6 也就是 6 次确认，表示连续 6 个块过去了，如果我的交易没有被双花的话，那么它被篡改的可能性将越来越小，最后变得几乎不可能被篡改。这也是区块链不可被篡改说法的由来。（但并不是不可能连续产生！！！可以参考51%攻击） 试想，如果任何作弊者花了大量的成本获取了系统 30% 的计算资源（算力），最后只有万分之七的概率获得篡改的可能性，比起作弊，还不如诚实记账的收益高。 总结 这里只是简单地列举了比特币中的POW共识机制，其最巧妙的设计是将数字系统和实体资源相挂钩，用经济学上的博弈来抑制数字系统的篡改（可以做恶篡改，但是无利可图），这是比特币的不可篡改原理。 而抛开比特币单独来看区块链，尤其是那些规模较小的链，从技术层面其实是可以被篡改的。 上一篇：区块链到底是怎么运行的 下一篇：区块链的应用类型 目录：深入浅出区块链教程 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/07/30/c136dbba7b2717764f6e0483ec54df78.html","headline":"深入浅出区块链教程——3.浅说区块链共识机制","dateModified":"2018-07-30T00:00:00+08:00","datePublished":"2018-07-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/07/30/c136dbba7b2717764f6e0483ec54df78.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>深入浅出区块链教程——3.浅说区块链共识机制</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h1 id="浅说区块链共识机制">浅说区块链共识机制</h1> 
  <p>区块链发展至今，已经形成了各种不同类型的共识机制，这里我们就展开聊一聊区块链共识机制到底是什么，以及区块链的共识过程到底是怎样的。</p> 
  <h2 id="分布式系统的经典问题-拜占庭将军问题">分布式系统的经典问题： 拜占庭将军问题</h2> 
  <p>拜占庭将军问题其实是虚构出来的一个故事，是为了方便通俗地介绍分布式系统所面临的难题。这里仅作一个简短的说明，你可以在中文社区找到更丰富的通俗解释材料。</p> 
  <p>为了避免重复，我们换一种表述形式，还是以上一次的村子为例，假设随着村子和人口的发展，大村子演变成了十一个小村子并分散在各地，各地的通信只能靠信鸽进行。</p> 
  <p>大家约定了每年都会举办一个相亲大会，至于谁能举办，每年轮流从两个备选村子，A 村和 B 村中选择一个，然后大家投票，票数多者可以赢得举办权。</p> 
  <p>由于地图很大，任何一个村子的投票都无法靠一只信鸽传输到每个村子，必须靠一个中继村子代为传输，这也就意味着有中继村子可以读到其他村子的投票信息。</p> 
  <p>那么，如何防止下面两个问题的出现呢？</p> 
  <ol> 
   <li>投票者的“精分”，这里所谓的“精分”是指某个村子的投票行为不一致，发送给第一个村子的投票消息为“投票给 A”，而发送给第二个村子的投票消息却为“投票给 B”。</li> 
   <li>中继村子作弊，即篡改上一村的投票消息。 <br> 上面讨论的问题我们可以认为是简化的 “拜占庭将军问题”（完整的拜占庭将军问题还有将军 - 副官模型，如果感兴趣的话，你可以自行阅读）。</li> 
  </ol> 
  <p>我们回头再看区块链。区块链本质上也是分布式系统的一种，其共识机制也是为了上述问题而提出的解决方案。</p> 
  <h2 id="什么是区块链共识机制">什么是区块链共识机制？</h2> 
  <p>共识机制是区块链是核心的组成要素之一，它决定了区块链的业务吞吐量、交易速度、不可篡改性、准入门槛等等，是最为关键的技术要素之一。</p> 
  <p>要理解区块链共识机制，首先就需要理解区块链共识机制到底解决了什么问题。</p> 
  <p>共识机制主要解决了两个问题：</p> 
  <ol> 
   <li>谁有权利；</li> 
   <li>作弊问题。 </li> 
  </ol> 
  <p>上一次我们构造了一个中心化记账的场景，在这个场景下，记账问题其实可以简化为大家信任中心记账者即可。</p> 
  <p>然而在分布式记账的场景下，问题更为复杂。首先，大家面临的最大问题是谁有权利记账，其次是如何避免记账者作弊。毕竟，<strong>谁都有权利记账，也就意味着谁都有可能作弊</strong>。</p> 
  <p>以上两部分共同构成了区块链共识机制。</p> 
  <p>另外补充一点，在比特币社区，“共识”（consensus）这个词已经跳出了技术的范畴。通常人们在表述一个比特币上的问题时，共识的内涵还包括比特币的使用者、开发者、矿工来达成社区共识的部分，所以“共识”这个词在区块链领域还有些“民主”的味道，不单单是技术领域的“共识”。</p> 
  <h2 id="最经典的入门型共识机制pow-工作量证明">最经典的入门型共识机制：PoW 工作量证明</h2> 
  <p>PoW （Proof of Work）工作量证明可以解决上述的两个问题，</p> 
  <p>还记得上文提到的“24 点”那个游戏吗？“24 点”其实是尽可能随机地选取系统中任意的节点来规避作弊者，这个方案的实践其实就是 PoW 共识机制。</p> 
  <p>产生记账者的随机性其实来自于谁最先计算出 24 点的答案，这个问题可以简化成谁拥有的计算资源更多，谁就拥有整个系统的最大概率的记账权。一旦这个概率超过一半以上，那么这个系统就有一定的中心化风险。</p> 
  <p>如何理解上面一段话呢？</p> 
  <p>举个例子，李四家发明了一种算盘，可以快速计算 24 点答案，比起其他人掰手指头，李四家总是有很大的概率拿下记账权，换句话说，也就是李四和全村其他所有人竞争，相当于算盘对全村其他人手指头的竞争。</p> 
  <p>如果算盘足够强大，就能有一半的概率获得记账权，那么李四个人的诚实性，就成为了系统的唯一破绽。</p> 
  <p>比如李四在第一次记账时篡改部分交易，第二次还是他记账，还继续篡改交易，<strong><code>那么两次修改如果自洽的话，是可以形成假账的，这就是所谓的中心化风险</code></strong>。 </p> 
  <hr> 
  <p><strong><code>在比特币的51%攻击中，当攻击块链的长度超过原块链2个区块，所有的客户端将丢弃原块链，接受攻击块链。</code><a href="http://www.8btc.com/51attack" rel="nofollow">ref</a></strong> <br> <strong>如果攻击链只篡改了一个区块，那么广播的时候其他结点会进行验证，这样篡改信息一下子就暴露了。难点在于篡改之后要持续篡改，直到超过主分支两个区块（注意这里是超过主分支2个区块，而不是篡改2个区块，实际上可能要连续篡改很长一段区块，这得储蓄保证很高的算力），这样攻击链才能成为主分支。</strong></p> 
  <hr> 
  <p>所以在 PoW 这种机制中，计算资源（又称算力）是决定记账权的唯一因素。与之对应的，便是计算难度。</p> 
  <p><code>计算难度又称作挖矿难度</code>，计算难度是区块链为了控制产生答案的速度，比如平均 10 分钟就有一个答案产生，平均 2 分钟一个答案产生。</p> 
  <p>在上述场景中，因为李四有了算盘，强大的计算资源突然加入以后，肯定会让整个系统的产生答案的速度变快很多，作为系统本身会自适应，将难度提升，降低答案产生的速度。</p> 
  <p>上面介绍了这么多，其实是想引出另外一个问题，PoW 到底是如何避免作弊者的呢？答案就是计算资源（算力）。</p> 
  <p>设想，如果一个作弊者想篡改信封里面的交易，首先得获得记账权，也就是装信封的权利。</p> 
  <p>而影响记账权的唯一因素只有计算资源（算力）的大小，<strong>如果想篡改交易，只能投入大量的计算资源与整个系统中其他所有人进行对抗，这是十分困难的</strong>，尤其在整个系统有一定基础计算资源（算力）的情况下。</p> 
  <p>PoW 中一个有趣的设计是激励机制，在 PoW 共识机制下，我们假设所有 <strong><code>参与者都是理性的</code></strong> ，理性的意思就是单纯逐利，不考虑家庭、爱好等其他因素。有了理性的前提，PoW 共识机制会给每个诚实的记账者予以奖励，这个设计可以抗击作弊收益的问题。</p> 
  <p>怎么进行抗击的呢？整个过程是这样的，理性的人如果作弊、篡改账本肯定需要投入成本，也就是计算资源，而篡改后的收益是篡改账本获得的收益减去投入成本，<strong>而如果把相同的资源用于正常挖矿，那么获得的收益将更多</strong>。所以，作弊者在作弊过程中投入的计算资源过大，反而得不偿失。</p> 
  <h2 id="pow-工作量证明的补充解决双花攻击">PoW 工作量证明的补充：解决双花攻击</h2> 
  <p>上面给出了一个结论，我们说<strong>作弊的收益往往小于诚实计算的收益</strong>。这一点其实对应到区块链领域有个著名的问题：双花攻击（double-spending） 。</p> 
  <p>双花攻击是指一个代币被花费了两次，这在任意的区块链系统中是不被允许的。如果避免了双花问题，基本就能避免上述作弊中收益过大的问题，因为攻击者首先要窃取到你的私钥，同时又能控制了你的计算资源（算力）。</p> 
  <p>为了方便分析，我们回到上一篇中广播交易的那一节。那一节中我介绍了广播的内容分为两种，第一种是 Transaction，第二种是区块，也就是信封。</p> 
  <p>第一种又被称为未确认的 Transaction，第二种信封中所有的交易被称作已确认的 Transaction。</p> 
  <p>所有记账节点都会遵循以下两条规则：</p> 
  <p>规则一：一个代币如果已经被花费，那么会被标记成已花费，<strong>如果再次接收到这个代币被花费的请求，那么记账节点会拒绝打包这笔交易</strong>；</p> 
  <p>规则二：如果同时接收到两个信封，<strong>这两个信封中装的两笔交易出现了一个代币被花费了两次的情况</strong>，这种情况也就是我们所说的分叉（Fork），<strong>那么选择挖矿难度比较大的那个信封</strong>。</p> 
  <p><code>规则一避免了未确认的交易出现双花，规则二基本避免已经确认的交易中（信封中）的双花问题</code>。</p> 
  <p>假设作弊者的计算资源（算力）占整个系统的 30%，那么连续两次获得记账权的概率是 9%，看起来作弊的可能性还是挺高的，如果是连续 6 次获得记账权呢？概率直降到万分之七。（达到6个确认就安全记录在案了）</p> 
  <p>在比特币中，这个 6 也就是 6 次确认，表示连续 6 个块过去了，如果我的交易没有被双花的话，那么它被篡改的可能性将越来越小，最后变得几乎不可能被篡改。这也是区块链不可被篡改说法的由来。（<strong>但并不是不可能连续产生！！！可以参考<a href="http://www.8btc.com/51attack" rel="nofollow">51%攻击</a></strong>）</p> 
  <p>试想，如果任何作弊者花了大量的成本获取了系统 30% 的计算资源（算力），最后只有万分之七的概率获得篡改的可能性，比起作弊，还不如诚实记账的收益高。</p> 
  <h2 id="总结">总结</h2> 
  <p>这里只是简单地列举了比特币中的POW共识机制，<strong>其最巧妙的设计是将数字系统和实体资源相挂钩，用经济学上的博弈来抑制数字系统的篡改（<code>可以做恶篡改，但是无利可图</code>），这是<code>比特币的不可篡改原理</code>。</strong> 而抛开比特币单独来看区块链，尤其是那些规模较小的链，从技术层面其实是可以被篡改的。</p> 
  <hr> 
  <p>上一篇：<a href="https://github.com/yjjnls/blockchain-tutorial-cn/blob/master/doc/02.%E5%8C%BA%E5%9D%97%E9%93%BE%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84.md" rel="nofollow">区块链到底是怎么运行的</a> 下一篇：<a href="https://github.com/yjjnls/blockchain-tutorial-cn/blob/master/doc/04.%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%BA%94%E7%94%A8%E7%B1%BB%E5%9E%8B.md" rel="nofollow">区块链的应用类型</a> </p> 
  <p>目录：<a href="https://github.com/yjjnls/blockchain-tutorial-cn" rel="nofollow">深入浅出区块链教程</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yjjnls/article/details/81283801,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yjjnls/article/details/81283801,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
