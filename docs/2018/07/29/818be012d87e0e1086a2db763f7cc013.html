<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【以太坊通证token标准】ERC20系列、ERC721系列、ERC865 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【以太坊通证token标准】ERC20系列、ERC721系列、ERC865" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="文章部分内容摘自，在此鸣谢： 1、笔名辉哥（简书链接：https://www.jianshu.com/p/fc4dbe1fbf2c）； 2、天涯社区（arrieneechaina）； 本文阐述内容： ERC系列概要 ERC20： ERC20、ERC223、ERC621、ERC827 ERC721： ERC721、ERC875、ERC998、ERC1155 ERC865 ERC的定义及标准列表 ERC代表“Etuereum Request for Comment&quot;，这是Ethereum版的意见征求稿 （RFC），RFC是由互联网工程任务组制定的一个概念。 RFC中的备忘录包含技术和组织注意事项。 对于ERC，意见征求稿中包括一些关于以太坊网络建设的技术指导。 ERC是Ethereum开发者为以太坊社区编写的。 因此，ERC的创建流程中包括开发人员。 为了创建一个以太坊平台的标准，开发人员应当提交了一个以太坊改进方案（EIP）， 改进方案中包括协议规范和合约标准。 一旦EIP被委员会批准并最终确定，它就成为ERC。 EIP的完整列表可以在Github（https://github.com/ethereum/EIPs）网址找到。 草稿（Draft） 处于打开状态，便于考察讨论； 接受（Accepted） 即将被接受，例如将包含在下一个硬分叉中； 定稿（Final） 在上一个硬分叉中被接受，已定稿； 延期（Deferred） 不会马上被接受，但也许在将来的硬分叉版本会考虑。 1、ERC20系列： ERC20、ERC223、ERC621、ERC827 ERC20标准 状态：定稿（Final） 提交记录： https://github.com/ethereum/EIPs/issues/20 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md 推荐样例： https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC20 ERC-20标准中定义了以下函数接口： totalSupply()： # 返回代币供给总量 balanceOf(address _owner)： # 返回_owner的帐户余额 transfer(address _to,uint256 _value)： # 并将数量为_value的代币转入地址_to并触发transfer事件 transferFrom(address _from,address _to,uint256_value)： # 将地址_from中的_value数量的代币转入地址_to ，并触发transfer事件 approve(address _spender,uint256 _value)： # 允许_spender提取限额_value的代币 allowance(address _owner,address _spender）： # 返回_spender可从_owner提款的代币数量上限 ERC-20于2015年提出并于2017年9月正式实施。这是代币标准化的一个很好的起点。 然而，开发者社区 已经注意到它存在一些缺陷和漏洞，此外，还有一些场景它不能很好的满足。因此陆续提出了其他的ERC标准。 ERC223 状态：草稿(Draft) 提交记录： https://github.com/ethereum/EIPs/issues/223 标准说明： https://github.com/Dexaran/ERC223-token-standard 推荐样例： https://github.com/Dexaran/ERC223-token-standard/tree/Recommended 开发人员Dexaran在一篇文章中详细描述了ERC20不适合的两种场景： 在ERC20中执行交易有两种方式：transfer函数，approve + transferFrom机制，通证余额只是通证合约中的一个变量。 通证的交易是合约内部变量的变化。 转出账户的余额将减少，转入账户的余额将增加。 交易发生时， transfer()函数不会通知转入账户。 因此转入账户将无法识别传入的交易！ 我写了一个例子，可以展示这一导致未处理的交易和资金损失的过程 。 因此，如果接收账户是合约账户，那么必须使用approve + transferFrom机制来发送通证。 如果接受账户是外部帐户，则必须通过transfer函数发送通证。 如果选择了错误的机制，通证将卡在合约内（合约将不会识别交易），没有办法来提取这些卡壳的通证。 函数接口说明： transfer(address _to, uint _value)： # 会区分代币是发往外部账户地址还是发往智能合约地址。 transfer(address _to, uint _value, bytes _data)： # 会区分代币是发往外部账户地址还是发往智能合约地址，还可以传送数据。 ERC621 状态：草稿(Draft) 提交记录： https://github.com/ethereum/EIPs/issues/621 标准说明：（无） 推荐样例： https://github.com/skmgoldin/EIP621Token/blob/master/contracts/EIP621Token.sol ERC-621是ERC-20标准的扩展。 它增加了两个额外的功能， increaseSupply和decreaseSupply 。这可以增加和减少流通中的令牌供应。 ERC-20只允许单一的通证发放事件。 这将供应量限制在一个固定的不可改变的数目。 ERC-621建议totalSupply应当是可修改的。 函数接口说明： increaseSupply(uint value, address to)： # 可以给特定账户to增加value值的供应量，代币总供应量totalSupply也同步增加； decreaseSupply(uint value, address from)： # 可以给特定账户to减少value值的账户余额，代币总供应余额totalSupply也同步减少； ERC827 状态： 草稿(Draft) 提交记录： https://github.com/ethereum/EIPs/issues/827 标准说明： 推荐样例： https://github.com/windingtree/erc827/blob/master/contracts/ERC827/ERC827Token.sol 它允许转让通证并允许持有人允许第三方使用通证。 以太坊上的通证可以被其他应用程序重复使用，这其中也包括钱包和交易所。 当需要支持第三方动态消费限额调整时这一点非常有用。 该标准目前处于草稿状态，并被证明有使用安全风险，建议暂不使用。 &nbsp; 2、ERC721系列 ERC721 状态： 定稿（Final） 提交记录： https://github.com/ethereum/EIPs/issues/721 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md 推荐样例： 1）https://www.cryptokitties.co/ 2）https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC721 ERC-721与ERC-20和ERC-223都大不相同。 它描述了一个不可互换的通证，官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。 这意味着每个通证是完全不同的，并且每个通证对不同的用户都有不同的价值。 理解这种通证的一个方法就是回忆CryptoKittes。 每一个数字猫都是独立的，其价值取决于其稀缺性和用户的购买欲。 ERC-721令牌可用于任何交易所，但通证价值是“每个通证的唯一性和稀缺性所决定的结果”。标准中规定的接口函数包括name、symbol、totalSupply、balanceOf、ownerOf、approve、takeOwnership 、 transfer 、tokenOfOwnerByIndex和tokenMetadata 。 它还定义了两个事件： Transfer和Approval 。 Gerald Nash的 这篇文章很好地解释了可互换性的概念。 函数接口说明： balanceOf(address _owner): # 返回由_owner 持有的NFTs的数量。 ownerOf(uint256 _tokenId): # 返回tokenId代币持有者的地址。 exists(uint256 _tokenId)： # tokenId代币是否存在，返回BOOL值； approve(address _to, uint256 _tokenId): # 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。 getApproved(uint256 _tokenId)： # 获得_tokenId授权的地址； setApprovalForAll(address _operator, bool _approved): # 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。 isApprovedForAll(address _owner, address _operator)： # 用来查询授权。 transferFrom(address _from, address _to, uint256 _tokenId) # 不建议使用本函数，建议使用safeTransferFrom函数。 safeTransferFrom(address _from, address _to, uint256 _tokenId): # 把_tokenId代币从_from账户安全转移到_to账户，安全是指如果目标地址为合约地址，则执行onERC721Received进行资产转移，否则的话交易会回滚；如果目标地址为外部账号地址，则正常转移。 ERC875 状态： 还处于pull request下（issue） 提交记录： https://github.com/ethereum/EIPs/issues/875 标准说明： 推荐样例： https://github.com/alpha-wallet/ERC875-Example AlphaWallet自主开发了ERC875协议族。该协议不仅会让数字资产变得具有收藏价值，同时也能帮助现实世界中不可拆分替代、具有物权唯一性的资产上链，这就能为线下服务的链上操作提供了可能性。 虽然另一种协议ERC721也能实现token的不可置换性，但其存在需要交易双方支付gas费用、无法简单实现原子化交易等一些不易于用户使用的问题。 ERC875内置了两个密码学协议， 一方面能够简单实现原子化交易（atomic swap）——直接搭建去中心化市场、降低普通用户使用门槛，卖家无需持有以太币，买家支付一次gas即能完成；另外一方面可以简单打包处理大量交易。 拿基于ERC721的加密猫来说，换用ERC875协议的话，能够实现。用户在商家网站法币购猫，通过MagicLink免费把猫导入用户的钱包，之后用户还可以在不需要持有以太币的情况下，通过MagicLink把猫售出或者免费转让，全部过程都是无中心的原子化交易。另外商家可以一次批发100只猫给分销商。 接口函数或者变量说明： totalTickets # ticket总量 inventory # 库存 ticketIndex # 索引 expiryTimeStamp # 过期时间 owner # 所有人 admin # 管理者 transferFee # 交易Fee numOfTransfers # 交易数量 name # 全称 symbol # 简称 decimals # （支持的）小数位 Token(uint256[] numberOfTokens, string evName,uint expiry, string eventSymbol, address adminAddr): # 构建函数，样例如example: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], &quot;MJcomeback&quot;, 1603152000, &quot;MJC&quot;, &quot;0x007bEe82BDd9e866b2bd114780a47f2261C684E3&quot;] getDecimals(): # 返回代币的小数点后位数值； trade(uint256 expiry,uint256[] tokenIndices,uint8 v,bytes32 r,bytes32 s): # 交易函数，例如：0, [3, 4],27,&quot;0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB&quot;,&quot;0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2&quot; name(): # 返回代币名称； symbol(): # 返回代币表示； getAmountTransferred(): # 返回已传输的数量； isContractExpired()： # 合约是否过期； balanceOf(address _owner)： # 返回账户余额； transfer(address _to, uint256[] tokenIndices)： # 资产转账； transferFrom(address _from, address _to, uint256[] tokenIndices)： ** endContract()**： # 结束合约； **getContractAddress() **： # 获取合约地址； ERC998 状态： 草稿（Draft） 提交记录： https://github.com/ethereum/EIPs/issues/998 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-998.md 推荐样例： https://github.com/mattlockyer/composables-998 不同的ERC代币可以被兼容的ERC-998代币既代表一组相似资产（ERC-20代币），一种独特资产的分类（ERC-721代币），或者内嵌于单比交易的混合体。 这个协议是以不可以替代代币为基础的全新复杂型数字资产。一个ERC-998代币可以作为一个数字资产投资组合。 中心资产和辅助资产的结合 第一个使用案例是可以和不同数字资产和零件结合外加附加增值功能的中心NFT币。增值可以通过个人花费时间和精力，或者购买来实现。 &nbsp; 在奢侈品行业里，这些可以作为应用于不同时尚品牌的“外表”和“包装”。 比如说，中心的不可替代货币是外表，可以辅助鞋子和钱包，每一个都代表了他们自己的NFT。这一整个套装都作为一部分组合到ERC-998代币里面。 单一资产的几个组成部分 作为附加债券的一部分，单一的数字资产可以被ERC-998代币群组所代表。因为每一个部分都是由自己的NFT被独特的体现出来的，NFT代币组合可以保证货品的绝对真实性。然而，除非依附于实际商品的形式，每一个NFT都没有自己的价值。这是一个可以附加在类似手表，珠宝这样价值商品上的非常强势的防伪手段。 上图所示为劳力士的三个组件，每个组件都有一个单独的序列号 - 表壳、表面和指针。单独来看，这些部件几乎没有任何价值，但它们一起构成了一个真正的劳力士手表，由一个ERC-998代币所代表。分组集合 通常被认为是组合的任何东西，例如一副牌，一本历史邮票或罕见的硬币收集等，可以在一个组合型代币下结合在一起。因此，完整的组合可以由单个数字资产表示。 大多数奢侈品牌都有很大众的产品，每年都会使用重新设计的型号，这些产品往往成为收藏品。在奢侈品战略下，消费者购买经典和品牌，这些都是通过多年来产品的演变出来的。作为上图中的示例，该品牌在三年内发布了其第一、二、三代模型，这些模型被分组为一个组合代币。 同时，这也更为品牌加强与老客户的联系。例如，如果用户可以通过Smart-Links这样可组合的代币，显示他们对某个品牌的所有收藏品，那么该品牌将能够通过独家邀请和优惠来奖励这位客户。 ERC1155 状态： 草稿（Draft） 提交记录： https://github.com/ethereum/EIPs/issues/1155 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md 推荐样例： https://enjincoin.io/ ERC-1155是一种定义token的新标准，1155是这种方法的编号。1155标准定义了一种解决上述问题的新方法。现在『物品』（可能包含ERC20的token或ERC721的token或两者都有）可以被单一的一个合约（打包处理）来定义了。合约里包含区别token们所需的最小量的数据。合约的状态包含了每个token ID的配置信息和管理收集的所有行为。ERC-1155的灵活性更强，它使得开发者可以自行选择是批量生成某一种特定的token，还是构建不可被复制的惟一元数据。 ERC-1155支持原子交换，“原子交换”是指不通过中介物而将一种token换成为另外一种token。 ERC-1155的最大进步就是可以融合不同token（可能是“可替换”的代币与“不可替换”的代币的混合体）进行“打包处理”。 函数接口说明： # (基本定义同上) name(uint256 _itemId)： symbol(uint256 _itemId)： decimals(uint256 _itemId)： totalSupply(uint256 _itemId)： balanceOf(uint256 _itemId, address _owner)： allowance(uint256 _itemId, address _owner, address _spender)： transfer(uint256[] _itemId, address[] _to, uint256[] _value)： transferFrom(uint256[] _itemId, address[] _from, address[] _to, uint256[] _value)： approve(uint256[] _itemId, address[] _spender, uint256[] _value)： increaseApproval(uint256[] _itemId, address[] _spender, uint256[] _addedValue)： decreaseApproval(uint256[] _itemId, address[] _spender, uint256[] _subtractedValue)： ownerOf(uint256 _itemId)： itemURI(uint256 _itemId)： itemByIndex(uint256 _itemId, uint256 _index)： itemOfOwnerByIndex(uint256 _itemId, address _owner, uint256 _index)： 3、ERC865 状态： 还处于pull request下（issue） 提交记录： https://github.com/ethereum/EIPs/issues/865 标准说明： 推荐样例： https://github.com/lavawallet/lava-wallet 以太坊开发者Bhaskar Sharma在Medium网站上发表了一篇文章，提出了一个在以太坊中使用对用户更友好的代币的提案，这一提案将允许用户来采用去中心化应用程序（DApps）时使用代币（tokens）来支付交易费用，而不是用以太币ETH来支付。 他认为，以太坊区块链中的费用支付问题为新手带来了麻烦，这些费用用于支付矿工将交易打包到区块并确保区块链的安全。用户必须认识以太坊的工作原理，这样才能理解燃料（gas）价格和成本。用户还需要获得必要的以太币来支付这两种费用。 函数接口说明： transferPreSigned(bytes _signature, address _to, uint256 _value, uint256 _gasPrice, uint256 _nonce)： approvePreSigned(bytes _signature, address _spender, uint256 _value, uint256 _gasPrice, uint256 _nonce)： **approveAndCallPreSigned(bytes _signature, address _spender, uint256 _value, bytes _extraData, uint256 _gasPrice, uint256 _nonce) **： increaseApprovalPreSigned(bytes _signature, address _to, uint256 _amount, uint256 _gasPrice, uint256 _nonce)： decreaseApprovalPreSigned(bytes _signature, address _to, uint256 _amount, uint256 _gasPrice, uint256 _nonce)： revokeSignature(bytes _signature)： 4、更多详情了解可以参考官网github 地址：https://github.com/ethereum/EIPs &nbsp; ----------------------------------------- 有任何建议或问题，欢迎加微信一起学习交流，欢迎从事IT，热爱IT，喜欢深挖源代码的行业大牛加入，一起探讨。 个人微信号：bboyHan，博客地址：https://blog.csdn.net/han0373 &nbsp; &nbsp; 阅读更多" />
<meta property="og:description" content="文章部分内容摘自，在此鸣谢： 1、笔名辉哥（简书链接：https://www.jianshu.com/p/fc4dbe1fbf2c）； 2、天涯社区（arrieneechaina）； 本文阐述内容： ERC系列概要 ERC20： ERC20、ERC223、ERC621、ERC827 ERC721： ERC721、ERC875、ERC998、ERC1155 ERC865 ERC的定义及标准列表 ERC代表“Etuereum Request for Comment&quot;，这是Ethereum版的意见征求稿 （RFC），RFC是由互联网工程任务组制定的一个概念。 RFC中的备忘录包含技术和组织注意事项。 对于ERC，意见征求稿中包括一些关于以太坊网络建设的技术指导。 ERC是Ethereum开发者为以太坊社区编写的。 因此，ERC的创建流程中包括开发人员。 为了创建一个以太坊平台的标准，开发人员应当提交了一个以太坊改进方案（EIP）， 改进方案中包括协议规范和合约标准。 一旦EIP被委员会批准并最终确定，它就成为ERC。 EIP的完整列表可以在Github（https://github.com/ethereum/EIPs）网址找到。 草稿（Draft） 处于打开状态，便于考察讨论； 接受（Accepted） 即将被接受，例如将包含在下一个硬分叉中； 定稿（Final） 在上一个硬分叉中被接受，已定稿； 延期（Deferred） 不会马上被接受，但也许在将来的硬分叉版本会考虑。 1、ERC20系列： ERC20、ERC223、ERC621、ERC827 ERC20标准 状态：定稿（Final） 提交记录： https://github.com/ethereum/EIPs/issues/20 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md 推荐样例： https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC20 ERC-20标准中定义了以下函数接口： totalSupply()： # 返回代币供给总量 balanceOf(address _owner)： # 返回_owner的帐户余额 transfer(address _to,uint256 _value)： # 并将数量为_value的代币转入地址_to并触发transfer事件 transferFrom(address _from,address _to,uint256_value)： # 将地址_from中的_value数量的代币转入地址_to ，并触发transfer事件 approve(address _spender,uint256 _value)： # 允许_spender提取限额_value的代币 allowance(address _owner,address _spender）： # 返回_spender可从_owner提款的代币数量上限 ERC-20于2015年提出并于2017年9月正式实施。这是代币标准化的一个很好的起点。 然而，开发者社区 已经注意到它存在一些缺陷和漏洞，此外，还有一些场景它不能很好的满足。因此陆续提出了其他的ERC标准。 ERC223 状态：草稿(Draft) 提交记录： https://github.com/ethereum/EIPs/issues/223 标准说明： https://github.com/Dexaran/ERC223-token-standard 推荐样例： https://github.com/Dexaran/ERC223-token-standard/tree/Recommended 开发人员Dexaran在一篇文章中详细描述了ERC20不适合的两种场景： 在ERC20中执行交易有两种方式：transfer函数，approve + transferFrom机制，通证余额只是通证合约中的一个变量。 通证的交易是合约内部变量的变化。 转出账户的余额将减少，转入账户的余额将增加。 交易发生时， transfer()函数不会通知转入账户。 因此转入账户将无法识别传入的交易！ 我写了一个例子，可以展示这一导致未处理的交易和资金损失的过程 。 因此，如果接收账户是合约账户，那么必须使用approve + transferFrom机制来发送通证。 如果接受账户是外部帐户，则必须通过transfer函数发送通证。 如果选择了错误的机制，通证将卡在合约内（合约将不会识别交易），没有办法来提取这些卡壳的通证。 函数接口说明： transfer(address _to, uint _value)： # 会区分代币是发往外部账户地址还是发往智能合约地址。 transfer(address _to, uint _value, bytes _data)： # 会区分代币是发往外部账户地址还是发往智能合约地址，还可以传送数据。 ERC621 状态：草稿(Draft) 提交记录： https://github.com/ethereum/EIPs/issues/621 标准说明：（无） 推荐样例： https://github.com/skmgoldin/EIP621Token/blob/master/contracts/EIP621Token.sol ERC-621是ERC-20标准的扩展。 它增加了两个额外的功能， increaseSupply和decreaseSupply 。这可以增加和减少流通中的令牌供应。 ERC-20只允许单一的通证发放事件。 这将供应量限制在一个固定的不可改变的数目。 ERC-621建议totalSupply应当是可修改的。 函数接口说明： increaseSupply(uint value, address to)： # 可以给特定账户to增加value值的供应量，代币总供应量totalSupply也同步增加； decreaseSupply(uint value, address from)： # 可以给特定账户to减少value值的账户余额，代币总供应余额totalSupply也同步减少； ERC827 状态： 草稿(Draft) 提交记录： https://github.com/ethereum/EIPs/issues/827 标准说明： 推荐样例： https://github.com/windingtree/erc827/blob/master/contracts/ERC827/ERC827Token.sol 它允许转让通证并允许持有人允许第三方使用通证。 以太坊上的通证可以被其他应用程序重复使用，这其中也包括钱包和交易所。 当需要支持第三方动态消费限额调整时这一点非常有用。 该标准目前处于草稿状态，并被证明有使用安全风险，建议暂不使用。 &nbsp; 2、ERC721系列 ERC721 状态： 定稿（Final） 提交记录： https://github.com/ethereum/EIPs/issues/721 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md 推荐样例： 1）https://www.cryptokitties.co/ 2）https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC721 ERC-721与ERC-20和ERC-223都大不相同。 它描述了一个不可互换的通证，官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。 这意味着每个通证是完全不同的，并且每个通证对不同的用户都有不同的价值。 理解这种通证的一个方法就是回忆CryptoKittes。 每一个数字猫都是独立的，其价值取决于其稀缺性和用户的购买欲。 ERC-721令牌可用于任何交易所，但通证价值是“每个通证的唯一性和稀缺性所决定的结果”。标准中规定的接口函数包括name、symbol、totalSupply、balanceOf、ownerOf、approve、takeOwnership 、 transfer 、tokenOfOwnerByIndex和tokenMetadata 。 它还定义了两个事件： Transfer和Approval 。 Gerald Nash的 这篇文章很好地解释了可互换性的概念。 函数接口说明： balanceOf(address _owner): # 返回由_owner 持有的NFTs的数量。 ownerOf(uint256 _tokenId): # 返回tokenId代币持有者的地址。 exists(uint256 _tokenId)： # tokenId代币是否存在，返回BOOL值； approve(address _to, uint256 _tokenId): # 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。 getApproved(uint256 _tokenId)： # 获得_tokenId授权的地址； setApprovalForAll(address _operator, bool _approved): # 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。 isApprovedForAll(address _owner, address _operator)： # 用来查询授权。 transferFrom(address _from, address _to, uint256 _tokenId) # 不建议使用本函数，建议使用safeTransferFrom函数。 safeTransferFrom(address _from, address _to, uint256 _tokenId): # 把_tokenId代币从_from账户安全转移到_to账户，安全是指如果目标地址为合约地址，则执行onERC721Received进行资产转移，否则的话交易会回滚；如果目标地址为外部账号地址，则正常转移。 ERC875 状态： 还处于pull request下（issue） 提交记录： https://github.com/ethereum/EIPs/issues/875 标准说明： 推荐样例： https://github.com/alpha-wallet/ERC875-Example AlphaWallet自主开发了ERC875协议族。该协议不仅会让数字资产变得具有收藏价值，同时也能帮助现实世界中不可拆分替代、具有物权唯一性的资产上链，这就能为线下服务的链上操作提供了可能性。 虽然另一种协议ERC721也能实现token的不可置换性，但其存在需要交易双方支付gas费用、无法简单实现原子化交易等一些不易于用户使用的问题。 ERC875内置了两个密码学协议， 一方面能够简单实现原子化交易（atomic swap）——直接搭建去中心化市场、降低普通用户使用门槛，卖家无需持有以太币，买家支付一次gas即能完成；另外一方面可以简单打包处理大量交易。 拿基于ERC721的加密猫来说，换用ERC875协议的话，能够实现。用户在商家网站法币购猫，通过MagicLink免费把猫导入用户的钱包，之后用户还可以在不需要持有以太币的情况下，通过MagicLink把猫售出或者免费转让，全部过程都是无中心的原子化交易。另外商家可以一次批发100只猫给分销商。 接口函数或者变量说明： totalTickets # ticket总量 inventory # 库存 ticketIndex # 索引 expiryTimeStamp # 过期时间 owner # 所有人 admin # 管理者 transferFee # 交易Fee numOfTransfers # 交易数量 name # 全称 symbol # 简称 decimals # （支持的）小数位 Token(uint256[] numberOfTokens, string evName,uint expiry, string eventSymbol, address adminAddr): # 构建函数，样例如example: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], &quot;MJcomeback&quot;, 1603152000, &quot;MJC&quot;, &quot;0x007bEe82BDd9e866b2bd114780a47f2261C684E3&quot;] getDecimals(): # 返回代币的小数点后位数值； trade(uint256 expiry,uint256[] tokenIndices,uint8 v,bytes32 r,bytes32 s): # 交易函数，例如：0, [3, 4],27,&quot;0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB&quot;,&quot;0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2&quot; name(): # 返回代币名称； symbol(): # 返回代币表示； getAmountTransferred(): # 返回已传输的数量； isContractExpired()： # 合约是否过期； balanceOf(address _owner)： # 返回账户余额； transfer(address _to, uint256[] tokenIndices)： # 资产转账； transferFrom(address _from, address _to, uint256[] tokenIndices)： ** endContract()**： # 结束合约； **getContractAddress() **： # 获取合约地址； ERC998 状态： 草稿（Draft） 提交记录： https://github.com/ethereum/EIPs/issues/998 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-998.md 推荐样例： https://github.com/mattlockyer/composables-998 不同的ERC代币可以被兼容的ERC-998代币既代表一组相似资产（ERC-20代币），一种独特资产的分类（ERC-721代币），或者内嵌于单比交易的混合体。 这个协议是以不可以替代代币为基础的全新复杂型数字资产。一个ERC-998代币可以作为一个数字资产投资组合。 中心资产和辅助资产的结合 第一个使用案例是可以和不同数字资产和零件结合外加附加增值功能的中心NFT币。增值可以通过个人花费时间和精力，或者购买来实现。 &nbsp; 在奢侈品行业里，这些可以作为应用于不同时尚品牌的“外表”和“包装”。 比如说，中心的不可替代货币是外表，可以辅助鞋子和钱包，每一个都代表了他们自己的NFT。这一整个套装都作为一部分组合到ERC-998代币里面。 单一资产的几个组成部分 作为附加债券的一部分，单一的数字资产可以被ERC-998代币群组所代表。因为每一个部分都是由自己的NFT被独特的体现出来的，NFT代币组合可以保证货品的绝对真实性。然而，除非依附于实际商品的形式，每一个NFT都没有自己的价值。这是一个可以附加在类似手表，珠宝这样价值商品上的非常强势的防伪手段。 上图所示为劳力士的三个组件，每个组件都有一个单独的序列号 - 表壳、表面和指针。单独来看，这些部件几乎没有任何价值，但它们一起构成了一个真正的劳力士手表，由一个ERC-998代币所代表。分组集合 通常被认为是组合的任何东西，例如一副牌，一本历史邮票或罕见的硬币收集等，可以在一个组合型代币下结合在一起。因此，完整的组合可以由单个数字资产表示。 大多数奢侈品牌都有很大众的产品，每年都会使用重新设计的型号，这些产品往往成为收藏品。在奢侈品战略下，消费者购买经典和品牌，这些都是通过多年来产品的演变出来的。作为上图中的示例，该品牌在三年内发布了其第一、二、三代模型，这些模型被分组为一个组合代币。 同时，这也更为品牌加强与老客户的联系。例如，如果用户可以通过Smart-Links这样可组合的代币，显示他们对某个品牌的所有收藏品，那么该品牌将能够通过独家邀请和优惠来奖励这位客户。 ERC1155 状态： 草稿（Draft） 提交记录： https://github.com/ethereum/EIPs/issues/1155 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md 推荐样例： https://enjincoin.io/ ERC-1155是一种定义token的新标准，1155是这种方法的编号。1155标准定义了一种解决上述问题的新方法。现在『物品』（可能包含ERC20的token或ERC721的token或两者都有）可以被单一的一个合约（打包处理）来定义了。合约里包含区别token们所需的最小量的数据。合约的状态包含了每个token ID的配置信息和管理收集的所有行为。ERC-1155的灵活性更强，它使得开发者可以自行选择是批量生成某一种特定的token，还是构建不可被复制的惟一元数据。 ERC-1155支持原子交换，“原子交换”是指不通过中介物而将一种token换成为另外一种token。 ERC-1155的最大进步就是可以融合不同token（可能是“可替换”的代币与“不可替换”的代币的混合体）进行“打包处理”。 函数接口说明： # (基本定义同上) name(uint256 _itemId)： symbol(uint256 _itemId)： decimals(uint256 _itemId)： totalSupply(uint256 _itemId)： balanceOf(uint256 _itemId, address _owner)： allowance(uint256 _itemId, address _owner, address _spender)： transfer(uint256[] _itemId, address[] _to, uint256[] _value)： transferFrom(uint256[] _itemId, address[] _from, address[] _to, uint256[] _value)： approve(uint256[] _itemId, address[] _spender, uint256[] _value)： increaseApproval(uint256[] _itemId, address[] _spender, uint256[] _addedValue)： decreaseApproval(uint256[] _itemId, address[] _spender, uint256[] _subtractedValue)： ownerOf(uint256 _itemId)： itemURI(uint256 _itemId)： itemByIndex(uint256 _itemId, uint256 _index)： itemOfOwnerByIndex(uint256 _itemId, address _owner, uint256 _index)： 3、ERC865 状态： 还处于pull request下（issue） 提交记录： https://github.com/ethereum/EIPs/issues/865 标准说明： 推荐样例： https://github.com/lavawallet/lava-wallet 以太坊开发者Bhaskar Sharma在Medium网站上发表了一篇文章，提出了一个在以太坊中使用对用户更友好的代币的提案，这一提案将允许用户来采用去中心化应用程序（DApps）时使用代币（tokens）来支付交易费用，而不是用以太币ETH来支付。 他认为，以太坊区块链中的费用支付问题为新手带来了麻烦，这些费用用于支付矿工将交易打包到区块并确保区块链的安全。用户必须认识以太坊的工作原理，这样才能理解燃料（gas）价格和成本。用户还需要获得必要的以太币来支付这两种费用。 函数接口说明： transferPreSigned(bytes _signature, address _to, uint256 _value, uint256 _gasPrice, uint256 _nonce)： approvePreSigned(bytes _signature, address _spender, uint256 _value, uint256 _gasPrice, uint256 _nonce)： **approveAndCallPreSigned(bytes _signature, address _spender, uint256 _value, bytes _extraData, uint256 _gasPrice, uint256 _nonce) **： increaseApprovalPreSigned(bytes _signature, address _to, uint256 _amount, uint256 _gasPrice, uint256 _nonce)： decreaseApprovalPreSigned(bytes _signature, address _to, uint256 _amount, uint256 _gasPrice, uint256 _nonce)： revokeSignature(bytes _signature)： 4、更多详情了解可以参考官网github 地址：https://github.com/ethereum/EIPs &nbsp; ----------------------------------------- 有任何建议或问题，欢迎加微信一起学习交流，欢迎从事IT，热爱IT，喜欢深挖源代码的行业大牛加入，一起探讨。 个人微信号：bboyHan，博客地址：https://blog.csdn.net/han0373 &nbsp; &nbsp; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/07/29/818be012d87e0e1086a2db763f7cc013.html" />
<meta property="og:url" content="https://mlh.app/2018/07/29/818be012d87e0e1086a2db763f7cc013.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"文章部分内容摘自，在此鸣谢： 1、笔名辉哥（简书链接：https://www.jianshu.com/p/fc4dbe1fbf2c）； 2、天涯社区（arrieneechaina）； 本文阐述内容： ERC系列概要 ERC20： ERC20、ERC223、ERC621、ERC827 ERC721： ERC721、ERC875、ERC998、ERC1155 ERC865 ERC的定义及标准列表 ERC代表“Etuereum Request for Comment&quot;，这是Ethereum版的意见征求稿 （RFC），RFC是由互联网工程任务组制定的一个概念。 RFC中的备忘录包含技术和组织注意事项。 对于ERC，意见征求稿中包括一些关于以太坊网络建设的技术指导。 ERC是Ethereum开发者为以太坊社区编写的。 因此，ERC的创建流程中包括开发人员。 为了创建一个以太坊平台的标准，开发人员应当提交了一个以太坊改进方案（EIP）， 改进方案中包括协议规范和合约标准。 一旦EIP被委员会批准并最终确定，它就成为ERC。 EIP的完整列表可以在Github（https://github.com/ethereum/EIPs）网址找到。 草稿（Draft） 处于打开状态，便于考察讨论； 接受（Accepted） 即将被接受，例如将包含在下一个硬分叉中； 定稿（Final） 在上一个硬分叉中被接受，已定稿； 延期（Deferred） 不会马上被接受，但也许在将来的硬分叉版本会考虑。 1、ERC20系列： ERC20、ERC223、ERC621、ERC827 ERC20标准 状态：定稿（Final） 提交记录： https://github.com/ethereum/EIPs/issues/20 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md 推荐样例： https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC20 ERC-20标准中定义了以下函数接口： totalSupply()： # 返回代币供给总量 balanceOf(address _owner)： # 返回_owner的帐户余额 transfer(address _to,uint256 _value)： # 并将数量为_value的代币转入地址_to并触发transfer事件 transferFrom(address _from,address _to,uint256_value)： # 将地址_from中的_value数量的代币转入地址_to ，并触发transfer事件 approve(address _spender,uint256 _value)： # 允许_spender提取限额_value的代币 allowance(address _owner,address _spender）： # 返回_spender可从_owner提款的代币数量上限 ERC-20于2015年提出并于2017年9月正式实施。这是代币标准化的一个很好的起点。 然而，开发者社区 已经注意到它存在一些缺陷和漏洞，此外，还有一些场景它不能很好的满足。因此陆续提出了其他的ERC标准。 ERC223 状态：草稿(Draft) 提交记录： https://github.com/ethereum/EIPs/issues/223 标准说明： https://github.com/Dexaran/ERC223-token-standard 推荐样例： https://github.com/Dexaran/ERC223-token-standard/tree/Recommended 开发人员Dexaran在一篇文章中详细描述了ERC20不适合的两种场景： 在ERC20中执行交易有两种方式：transfer函数，approve + transferFrom机制，通证余额只是通证合约中的一个变量。 通证的交易是合约内部变量的变化。 转出账户的余额将减少，转入账户的余额将增加。 交易发生时， transfer()函数不会通知转入账户。 因此转入账户将无法识别传入的交易！ 我写了一个例子，可以展示这一导致未处理的交易和资金损失的过程 。 因此，如果接收账户是合约账户，那么必须使用approve + transferFrom机制来发送通证。 如果接受账户是外部帐户，则必须通过transfer函数发送通证。 如果选择了错误的机制，通证将卡在合约内（合约将不会识别交易），没有办法来提取这些卡壳的通证。 函数接口说明： transfer(address _to, uint _value)： # 会区分代币是发往外部账户地址还是发往智能合约地址。 transfer(address _to, uint _value, bytes _data)： # 会区分代币是发往外部账户地址还是发往智能合约地址，还可以传送数据。 ERC621 状态：草稿(Draft) 提交记录： https://github.com/ethereum/EIPs/issues/621 标准说明：（无） 推荐样例： https://github.com/skmgoldin/EIP621Token/blob/master/contracts/EIP621Token.sol ERC-621是ERC-20标准的扩展。 它增加了两个额外的功能， increaseSupply和decreaseSupply 。这可以增加和减少流通中的令牌供应。 ERC-20只允许单一的通证发放事件。 这将供应量限制在一个固定的不可改变的数目。 ERC-621建议totalSupply应当是可修改的。 函数接口说明： increaseSupply(uint value, address to)： # 可以给特定账户to增加value值的供应量，代币总供应量totalSupply也同步增加； decreaseSupply(uint value, address from)： # 可以给特定账户to减少value值的账户余额，代币总供应余额totalSupply也同步减少； ERC827 状态： 草稿(Draft) 提交记录： https://github.com/ethereum/EIPs/issues/827 标准说明： 推荐样例： https://github.com/windingtree/erc827/blob/master/contracts/ERC827/ERC827Token.sol 它允许转让通证并允许持有人允许第三方使用通证。 以太坊上的通证可以被其他应用程序重复使用，这其中也包括钱包和交易所。 当需要支持第三方动态消费限额调整时这一点非常有用。 该标准目前处于草稿状态，并被证明有使用安全风险，建议暂不使用。 &nbsp; 2、ERC721系列 ERC721 状态： 定稿（Final） 提交记录： https://github.com/ethereum/EIPs/issues/721 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md 推荐样例： 1）https://www.cryptokitties.co/ 2）https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC721 ERC-721与ERC-20和ERC-223都大不相同。 它描述了一个不可互换的通证，官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。 这意味着每个通证是完全不同的，并且每个通证对不同的用户都有不同的价值。 理解这种通证的一个方法就是回忆CryptoKittes。 每一个数字猫都是独立的，其价值取决于其稀缺性和用户的购买欲。 ERC-721令牌可用于任何交易所，但通证价值是“每个通证的唯一性和稀缺性所决定的结果”。标准中规定的接口函数包括name、symbol、totalSupply、balanceOf、ownerOf、approve、takeOwnership 、 transfer 、tokenOfOwnerByIndex和tokenMetadata 。 它还定义了两个事件： Transfer和Approval 。 Gerald Nash的 这篇文章很好地解释了可互换性的概念。 函数接口说明： balanceOf(address _owner): # 返回由_owner 持有的NFTs的数量。 ownerOf(uint256 _tokenId): # 返回tokenId代币持有者的地址。 exists(uint256 _tokenId)： # tokenId代币是否存在，返回BOOL值； approve(address _to, uint256 _tokenId): # 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。 getApproved(uint256 _tokenId)： # 获得_tokenId授权的地址； setApprovalForAll(address _operator, bool _approved): # 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。 isApprovedForAll(address _owner, address _operator)： # 用来查询授权。 transferFrom(address _from, address _to, uint256 _tokenId) # 不建议使用本函数，建议使用safeTransferFrom函数。 safeTransferFrom(address _from, address _to, uint256 _tokenId): # 把_tokenId代币从_from账户安全转移到_to账户，安全是指如果目标地址为合约地址，则执行onERC721Received进行资产转移，否则的话交易会回滚；如果目标地址为外部账号地址，则正常转移。 ERC875 状态： 还处于pull request下（issue） 提交记录： https://github.com/ethereum/EIPs/issues/875 标准说明： 推荐样例： https://github.com/alpha-wallet/ERC875-Example AlphaWallet自主开发了ERC875协议族。该协议不仅会让数字资产变得具有收藏价值，同时也能帮助现实世界中不可拆分替代、具有物权唯一性的资产上链，这就能为线下服务的链上操作提供了可能性。 虽然另一种协议ERC721也能实现token的不可置换性，但其存在需要交易双方支付gas费用、无法简单实现原子化交易等一些不易于用户使用的问题。 ERC875内置了两个密码学协议， 一方面能够简单实现原子化交易（atomic swap）——直接搭建去中心化市场、降低普通用户使用门槛，卖家无需持有以太币，买家支付一次gas即能完成；另外一方面可以简单打包处理大量交易。 拿基于ERC721的加密猫来说，换用ERC875协议的话，能够实现。用户在商家网站法币购猫，通过MagicLink免费把猫导入用户的钱包，之后用户还可以在不需要持有以太币的情况下，通过MagicLink把猫售出或者免费转让，全部过程都是无中心的原子化交易。另外商家可以一次批发100只猫给分销商。 接口函数或者变量说明： totalTickets # ticket总量 inventory # 库存 ticketIndex # 索引 expiryTimeStamp # 过期时间 owner # 所有人 admin # 管理者 transferFee # 交易Fee numOfTransfers # 交易数量 name # 全称 symbol # 简称 decimals # （支持的）小数位 Token(uint256[] numberOfTokens, string evName,uint expiry, string eventSymbol, address adminAddr): # 构建函数，样例如example: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], &quot;MJcomeback&quot;, 1603152000, &quot;MJC&quot;, &quot;0x007bEe82BDd9e866b2bd114780a47f2261C684E3&quot;] getDecimals(): # 返回代币的小数点后位数值； trade(uint256 expiry,uint256[] tokenIndices,uint8 v,bytes32 r,bytes32 s): # 交易函数，例如：0, [3, 4],27,&quot;0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB&quot;,&quot;0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2&quot; name(): # 返回代币名称； symbol(): # 返回代币表示； getAmountTransferred(): # 返回已传输的数量； isContractExpired()： # 合约是否过期； balanceOf(address _owner)： # 返回账户余额； transfer(address _to, uint256[] tokenIndices)： # 资产转账； transferFrom(address _from, address _to, uint256[] tokenIndices)： ** endContract()**： # 结束合约； **getContractAddress() **： # 获取合约地址； ERC998 状态： 草稿（Draft） 提交记录： https://github.com/ethereum/EIPs/issues/998 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-998.md 推荐样例： https://github.com/mattlockyer/composables-998 不同的ERC代币可以被兼容的ERC-998代币既代表一组相似资产（ERC-20代币），一种独特资产的分类（ERC-721代币），或者内嵌于单比交易的混合体。 这个协议是以不可以替代代币为基础的全新复杂型数字资产。一个ERC-998代币可以作为一个数字资产投资组合。 中心资产和辅助资产的结合 第一个使用案例是可以和不同数字资产和零件结合外加附加增值功能的中心NFT币。增值可以通过个人花费时间和精力，或者购买来实现。 &nbsp; 在奢侈品行业里，这些可以作为应用于不同时尚品牌的“外表”和“包装”。 比如说，中心的不可替代货币是外表，可以辅助鞋子和钱包，每一个都代表了他们自己的NFT。这一整个套装都作为一部分组合到ERC-998代币里面。 单一资产的几个组成部分 作为附加债券的一部分，单一的数字资产可以被ERC-998代币群组所代表。因为每一个部分都是由自己的NFT被独特的体现出来的，NFT代币组合可以保证货品的绝对真实性。然而，除非依附于实际商品的形式，每一个NFT都没有自己的价值。这是一个可以附加在类似手表，珠宝这样价值商品上的非常强势的防伪手段。 上图所示为劳力士的三个组件，每个组件都有一个单独的序列号 - 表壳、表面和指针。单独来看，这些部件几乎没有任何价值，但它们一起构成了一个真正的劳力士手表，由一个ERC-998代币所代表。分组集合 通常被认为是组合的任何东西，例如一副牌，一本历史邮票或罕见的硬币收集等，可以在一个组合型代币下结合在一起。因此，完整的组合可以由单个数字资产表示。 大多数奢侈品牌都有很大众的产品，每年都会使用重新设计的型号，这些产品往往成为收藏品。在奢侈品战略下，消费者购买经典和品牌，这些都是通过多年来产品的演变出来的。作为上图中的示例，该品牌在三年内发布了其第一、二、三代模型，这些模型被分组为一个组合代币。 同时，这也更为品牌加强与老客户的联系。例如，如果用户可以通过Smart-Links这样可组合的代币，显示他们对某个品牌的所有收藏品，那么该品牌将能够通过独家邀请和优惠来奖励这位客户。 ERC1155 状态： 草稿（Draft） 提交记录： https://github.com/ethereum/EIPs/issues/1155 标准说明： https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md 推荐样例： https://enjincoin.io/ ERC-1155是一种定义token的新标准，1155是这种方法的编号。1155标准定义了一种解决上述问题的新方法。现在『物品』（可能包含ERC20的token或ERC721的token或两者都有）可以被单一的一个合约（打包处理）来定义了。合约里包含区别token们所需的最小量的数据。合约的状态包含了每个token ID的配置信息和管理收集的所有行为。ERC-1155的灵活性更强，它使得开发者可以自行选择是批量生成某一种特定的token，还是构建不可被复制的惟一元数据。 ERC-1155支持原子交换，“原子交换”是指不通过中介物而将一种token换成为另外一种token。 ERC-1155的最大进步就是可以融合不同token（可能是“可替换”的代币与“不可替换”的代币的混合体）进行“打包处理”。 函数接口说明： # (基本定义同上) name(uint256 _itemId)： symbol(uint256 _itemId)： decimals(uint256 _itemId)： totalSupply(uint256 _itemId)： balanceOf(uint256 _itemId, address _owner)： allowance(uint256 _itemId, address _owner, address _spender)： transfer(uint256[] _itemId, address[] _to, uint256[] _value)： transferFrom(uint256[] _itemId, address[] _from, address[] _to, uint256[] _value)： approve(uint256[] _itemId, address[] _spender, uint256[] _value)： increaseApproval(uint256[] _itemId, address[] _spender, uint256[] _addedValue)： decreaseApproval(uint256[] _itemId, address[] _spender, uint256[] _subtractedValue)： ownerOf(uint256 _itemId)： itemURI(uint256 _itemId)： itemByIndex(uint256 _itemId, uint256 _index)： itemOfOwnerByIndex(uint256 _itemId, address _owner, uint256 _index)： 3、ERC865 状态： 还处于pull request下（issue） 提交记录： https://github.com/ethereum/EIPs/issues/865 标准说明： 推荐样例： https://github.com/lavawallet/lava-wallet 以太坊开发者Bhaskar Sharma在Medium网站上发表了一篇文章，提出了一个在以太坊中使用对用户更友好的代币的提案，这一提案将允许用户来采用去中心化应用程序（DApps）时使用代币（tokens）来支付交易费用，而不是用以太币ETH来支付。 他认为，以太坊区块链中的费用支付问题为新手带来了麻烦，这些费用用于支付矿工将交易打包到区块并确保区块链的安全。用户必须认识以太坊的工作原理，这样才能理解燃料（gas）价格和成本。用户还需要获得必要的以太币来支付这两种费用。 函数接口说明： transferPreSigned(bytes _signature, address _to, uint256 _value, uint256 _gasPrice, uint256 _nonce)： approvePreSigned(bytes _signature, address _spender, uint256 _value, uint256 _gasPrice, uint256 _nonce)： **approveAndCallPreSigned(bytes _signature, address _spender, uint256 _value, bytes _extraData, uint256 _gasPrice, uint256 _nonce) **： increaseApprovalPreSigned(bytes _signature, address _to, uint256 _amount, uint256 _gasPrice, uint256 _nonce)： decreaseApprovalPreSigned(bytes _signature, address _to, uint256 _amount, uint256 _gasPrice, uint256 _nonce)： revokeSignature(bytes _signature)： 4、更多详情了解可以参考官网github 地址：https://github.com/ethereum/EIPs &nbsp; ----------------------------------------- 有任何建议或问题，欢迎加微信一起学习交流，欢迎从事IT，热爱IT，喜欢深挖源代码的行业大牛加入，一起探讨。 个人微信号：bboyHan，博客地址：https://blog.csdn.net/han0373 &nbsp; &nbsp; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/07/29/818be012d87e0e1086a2db763f7cc013.html","headline":"【以太坊通证token标准】ERC20系列、ERC721系列、ERC865","dateModified":"2018-07-29T00:00:00+08:00","datePublished":"2018-07-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/07/29/818be012d87e0e1086a2db763f7cc013.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【以太坊通证token标准】ERC20系列、ERC721系列、ERC865</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <blockquote> 
   <p>文章部分内容摘自，在此鸣谢：</p> 
   <p>1、笔名辉哥（简书链接：https://www.jianshu.com/p/fc4dbe1fbf2c）；</p> 
   <p>2、天涯社区（arrieneechaina）；</p> 
  </blockquote> 
  <h3>本文阐述内容：</h3> 
  <p>ERC系列概要</p> 
  <blockquote> 
   <p><strong>ERC20：</strong></p> 
   <p>ERC20、ERC223、ERC621、ERC827</p> 
   <p><strong>ERC721：</strong></p> 
   <p>ERC721、ERC875、ERC998、ERC1155</p> 
   <p><strong>ERC865</strong></p> 
  </blockquote> 
  <h3>ERC的定义及标准列表</h3> 
  <p>ERC代表“Etuereum Request for Comment"，这是Ethereum版的意见征求稿 （RFC），RFC是由互联网工程任务组制定的一个概念。 RFC中的备忘录包含技术和组织注意事项。 对于ERC，意见征求稿中包括一些关于以太坊网络建设的技术指导。</p> 
  <p>ERC是Ethereum开发者为以太坊社区编写的。 因此，ERC的创建流程中包括开发人员。 为了创建一个以太坊平台的标准，开发人员应当提交了一个以太坊改进方案（EIP）， 改进方案中包括协议规范和合约标准。 一旦EIP被委员会批准并最终确定，它就成为ERC。 EIP的完整列表可以在Github（<a href="https://github.com/ethereum/EIPs" rel="nofollow">https://github.com/ethereum/EIPs</a>）网址找到。</p> 
  <table border="1" cellpadding="1" cellspacing="1" style="width:500px;">
   <thead>
    <tr>
     <th scope="col">草稿（Draft）</th> 
     <th scope="col">处于打开状态，便于考察讨论；</th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>接受（Accepted）</td> 
     <td>即将被接受，例如将包含在下一个硬分叉中；</td> 
    </tr>
    <tr>
     <td>定稿（Final）</td> 
     <td>在上一个硬分叉中被接受，已定稿；</td> 
    </tr>
    <tr>
     <td>延期（Deferred）</td> 
     <td>不会马上被接受，但也许在将来的硬分叉版本会考虑。</td> 
    </tr>
   </tbody>
  </table>
  <h1><span style="color:#3399ea;">1、ERC20系列：</span></h1> 
  <blockquote> 
   <p>ERC20、ERC223、ERC621、ERC827</p> 
  </blockquote> 
  <h3>ERC20标准</h3> 
  <blockquote> 
   <p>状态：定稿（Final）<br> 提交记录：<br> https://github.com/ethereum/EIPs/issues/20<br> 标准说明：<br> https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md<br> 推荐样例：<br> https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC20</p> 
  </blockquote> 
  <p>ERC-20标准中定义了以下函数接口：</p> 
  <pre class="has">
<code class="language-bash">totalSupply()：
# 返回代币供给总量
balanceOf(address _owner)：
# 返回_owner的帐户余额
transfer(address _to,uint256 _value)：
# 并将数量为_value的代币转入地址_to并触发transfer事件
transferFrom(address _from,address _to,uint256_value)：
# 将地址_from中的_value数量的代币转入地址_to ，并触发transfer事件
approve(address _spender,uint256 _value)：
# 允许_spender提取限额_value的代币
allowance(address _owner,address _spender）：
# 返回_spender可从_owner提款的代币数量上限</code></pre> 
  <p>ERC-20于2015年提出并于2017年9月正式实施。这是代币标准化的一个很好的起点。 然而，开发者社区 已经注意到它存在一些缺陷和漏洞，此外，还有一些场景它不能很好的满足。因此陆续提出了其他的ERC标准。</p> 
  <h3>ERC223</h3> 
  <blockquote> 
   <p>状态：草稿(Draft)<br> 提交记录：<br> https://github.com/ethereum/EIPs/issues/223<br> 标准说明：<br> https://github.com/Dexaran/ERC223-token-standard<br> 推荐样例：<br> https://github.com/Dexaran/ERC223-token-standard/tree/Recommended</p> 
  </blockquote> 
  <p>开发人员Dexaran在一篇文章中详细描述了ERC20不适合的两种场景：</p> 
  <blockquote> 
   <p>在ERC20中执行交易有两种方式：transfer函数，approve + transferFrom机制，通证余额只是通证合约中的一个变量。<br> 通证的交易是合约内部变量的变化。 转出账户的余额将减少，转入账户的余额将增加。<br> 交易发生时， transfer()函数不会通知转入账户。 因此转入账户将无法识别传入的交易！ 我写了一个例子，可以展示这一导致未处理的交易和资金损失的过程 。<br> 因此，如果接收账户是合约账户，那么必须使用approve + transferFrom机制来发送通证。<br> 如果接受账户是外部帐户，则必须通过transfer函数发送通证。 如果选择了错误的机制，通证将卡在合约内（合约将不会识别交易），没有办法来提取这些卡壳的通证。</p> 
  </blockquote> 
  <p>函数接口说明：</p> 
  <pre class="has">
<code class="language-bash">transfer(address _to, uint _value)：
# 会区分代币是发往外部账户地址还是发往智能合约地址。
transfer(address _to, uint _value, bytes _data)：
# 会区分代币是发往外部账户地址还是发往智能合约地址，还可以传送数据。
</code></pre> 
  <h3>ERC621</h3> 
  <blockquote> 
   <p>状态：草稿(Draft)</p> 
   <p>提交记录：<br> https://github.com/ethereum/EIPs/issues/621</p> 
   <p>标准说明：（无）</p> 
   <p>推荐样例：<br> https://github.com/skmgoldin/EIP621Token/blob/master/contracts/EIP621Token.sol</p> 
  </blockquote> 
  <p>ERC-621是ERC-20标准的扩展。 它增加了两个额外的功能， increaseSupply和decreaseSupply 。这可以增加和减少流通中的令牌供应。 ERC-20只允许单一的通证发放事件。 这将供应量限制在一个固定的不可改变的数目。 ERC-621建议totalSupply应当是可修改的。</p> 
  <p>函数接口说明：</p> 
  <pre class="has">
<code class="language-bash">increaseSupply(uint value, address to)：
# 可以给特定账户to增加value值的供应量，代币总供应量totalSupply也同步增加；
decreaseSupply(uint value, address from)：
# 可以给特定账户to减少value值的账户余额，代币总供应余额totalSupply也同步减少；</code></pre> 
  <h3>ERC827</h3> 
  <blockquote> 
   <p>状态：<br> 草稿(Draft)</p> 
   <p>提交记录：<br> https://github.com/ethereum/EIPs/issues/827</p> 
   <p>标准说明：</p> 
   <p>推荐样例：<br> https://github.com/windingtree/erc827/blob/master/contracts/ERC827/ERC827Token.sol</p> 
  </blockquote> 
  <p>它允许转让通证并允许持有人允许第三方使用通证。 以太坊上的通证可以被其他应用程序重复使用，这其中也包括钱包和交易所。 当需要支持第三方动态消费限额调整时这一点非常有用。<br> 该标准目前处于草稿状态，并被证明有使用安全风险，建议暂不使用。</p> 
  <p>&nbsp;</p> 
  <h1><span style="color:#3399ea;">2、ERC721系列</span></h1> 
  <h3>ERC721</h3> 
  <blockquote> 
   <p>状态：<br> 定稿（Final）<br> 提交记录：<br> https://github.com/ethereum/EIPs/issues/721<br> 标准说明：<br> https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md<br> 推荐样例：<br> 1）https://www.cryptokitties.co/<br> 2）https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC721</p> 
  </blockquote> 
  <p>ERC-721与ERC-20和ERC-223都大不相同。 它描述了一个不可互换的通证，官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。 这意味着每个通证是完全不同的，并且每个通证对不同的用户都有不同的价值。 理解这种通证的一个方法就是回忆CryptoKittes。 每一个数字猫都是独立的，其价值取决于其稀缺性和用户的购买欲。</p> 
  <p>ERC-721令牌可用于任何交易所，但通证价值是“每个通证的唯一性和稀缺性所决定的结果”。标准中规定的接口函数包括name、symbol、totalSupply、balanceOf、ownerOf、approve、takeOwnership 、 transfer 、tokenOfOwnerByIndex和tokenMetadata 。 它还定义了两个事件： Transfer和Approval 。 Gerald Nash的 这篇文章很好地解释了可互换性的概念。</p> 
  <p>函数接口说明：</p> 
  <pre class="has">
<code class="language-bash">balanceOf(address _owner):
# 返回由_owner 持有的NFTs的数量。
ownerOf(uint256 _tokenId):
# 返回tokenId代币持有者的地址。
exists(uint256 _tokenId)：
# tokenId代币是否存在，返回BOOL值；
approve(address _to, uint256 _tokenId):
# 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。
getApproved(uint256 _tokenId)：
# 获得_tokenId授权的地址；
setApprovalForAll(address _operator, bool _approved):
# 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。
isApprovedForAll(address _owner, address _operator)：
# 用来查询授权。
transferFrom(address _from, address _to, uint256 _tokenId)
# 不建议使用本函数，建议使用safeTransferFrom函数。
safeTransferFrom(address _from, address _to, uint256 _tokenId):
# 把_tokenId代币从_from账户安全转移到_to账户，安全是指如果目标地址为合约地址，则执行onERC721Received进行资产转移，否则的话交易会回滚；如果目标地址为外部账号地址，则正常转移。</code></pre> 
  <h3>ERC875</h3> 
  <blockquote> 
   <p>状态：<br> 还处于pull request下（issue）</p> 
   <p>提交记录：<br> https://github.com/ethereum/EIPs/issues/875</p> 
   <p>标准说明：</p> 
   <p>推荐样例：<br> https://github.com/alpha-wallet/ERC875-Example</p> 
  </blockquote> 
  <p>AlphaWallet自主开发了ERC875协议族。该协议不仅会让数字资产变得具有收藏价值，同时也能帮助现实世界中不可拆分替代、具有物权唯一性的资产上链，这就能为线下服务的链上操作提供了可能性。<br> 虽然另一种协议ERC721也能实现token的不可置换性，但其存在需要交易双方支付gas费用、无法简单实现原子化交易等一些不易于用户使用的问题。<br> ERC875内置了两个密码学协议， 一方面能够简单实现原子化交易（atomic swap）——直接搭建去中心化市场、降低普通用户使用门槛，卖家无需持有以太币，买家支付一次gas即能完成；另外一方面可以简单打包处理大量交易。<br> 拿基于ERC721的加密猫来说，换用ERC875协议的话，能够实现。用户在商家网站法币购猫，通过MagicLink免费把猫导入用户的钱包，之后用户还可以在不需要持有以太币的情况下，通过MagicLink把猫售出或者免费转让，全部过程都是无中心的原子化交易。另外商家可以一次批发100只猫给分销商。</p> 
  <p>接口函数或者变量说明：</p> 
  <pre class="has">
<code class="language-bash">totalTickets # ticket总量
inventory # 库存
ticketIndex # 索引
expiryTimeStamp # 过期时间
owner # 所有人
admin # 管理者
transferFee # 交易Fee
numOfTransfers # 交易数量
name # 全称
symbol # 简称
decimals # （支持的）小数位

Token(uint256[] numberOfTokens, string evName,uint expiry, string eventSymbol, address adminAddr):
# 构建函数，样例如example: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "MJcomeback", 1603152000, "MJC", "0x007bEe82BDd9e866b2bd114780a47f2261C684E3"]
getDecimals():
# 返回代币的小数点后位数值；
trade(uint256 expiry,uint256[] tokenIndices,uint8 v,bytes32 r,bytes32 s):
# 交易函数，例如：0, [3, 4],27,"0x2C011885E2D8FF02F813A4CB83EC51E1BFD5A7848B3B3400AE746FB08ADCFBFB","0x21E80BAD65535DA1D692B4CEE3E740CD3282CCDC0174D4CF1E2F70483A6F4EB2"

name():
# 返回代币名称；
symbol():
# 返回代币表示；
getAmountTransferred():
# 返回已传输的数量；
isContractExpired()：
# 合约是否过期；
balanceOf(address _owner)：
# 返回账户余额；
transfer(address _to, uint256[] tokenIndices)：
# 资产转账；
transferFrom(address _from, address _to, uint256[] tokenIndices)：
** endContract()**：
# 结束合约；
**getContractAddress() **：
# 获取合约地址；
</code></pre> 
  <h3>ERC998</h3> 
  <blockquote> 
   <p>状态：<br> 草稿（Draft）</p> 
   <p>提交记录：<br> https://github.com/ethereum/EIPs/issues/998</p> 
   <p>标准说明：<br> https://github.com/ethereum/EIPs/blob/master/EIPS/eip-998.md</p> 
   <p>推荐样例：<br> https://github.com/mattlockyer/composables-998</p> 
  </blockquote> 
  <p>不同的ERC代币可以被兼容的ERC-998代币既代表一组相似资产（ERC-20代币），一种独特资产的分类（ERC-721代币），或者内嵌于单比交易的混合体。<br> 这个协议是以不可以替代代币为基础的全新复杂型数字资产。一个ERC-998代币可以作为一个数字资产投资组合。</p> 
  <p><strong>中心资产和辅助资产的结合</strong><br> 第一个使用案例是可以和不同数字资产和零件结合外加附加增值功能的中心NFT币。增值可以通过个人花费时间和精力，或者购买来实现。</p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" src="https://upload-images.jianshu.io/upload_images/1190574-5cfd2860eda91014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/695"></p> 
  <p>在奢侈品行业里，这些可以作为应用于不同时尚品牌的“外表”和“包装”。 比如说，中心的不可替代货币是外表，可以辅助鞋子和钱包，每一个都代表了他们自己的NFT。这一整个套装都作为一部分组合到ERC-998代币里面。</p> 
  <p><strong>单一资产的几个组成部分</strong><br> 作为附加债券的一部分，单一的数字资产可以被ERC-998代币群组所代表。因为每一个部分都是由自己的NFT被独特的体现出来的，NFT代币组合可以保证货品的绝对真实性。然而，除非依附于实际商品的形式，每一个NFT都没有自己的价值。这是一个可以附加在类似手表，珠宝这样价值商品上的非常强势的防伪手段。</p> 
  <p><img alt="" class="has" src="https://upload-images.jianshu.io/upload_images/1190574-503dd2519d966dd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700"></p> 
  <p>上图所示为劳力士的三个组件，每个组件都有一个单独的序列号 - 表壳、表面和指针。单独来看，这些部件几乎没有任何价值，但它们一起构成了一个真正的劳力士手表，由一个ERC-998代币所代表。<br><strong>分组集合</strong><br> 通常被认为是组合的任何东西，例如一副牌，一本历史邮票或罕见的硬币收集等，可以在一个组合型代币下结合在一起。因此，完整的组合可以由单个数字资产表示。<br> 大多数奢侈品牌都有很大众的产品，每年都会使用重新设计的型号，这些产品往往成为收藏品。在奢侈品战略下，消费者购买经典和品牌，这些都是通过多年来产品的演变出来的。作为上图中的示例，该品牌在三年内发布了其第一、二、三代模型，这些模型被分组为一个组合代币。<br> 同时，这也更为品牌加强与老客户的联系。例如，如果用户可以通过Smart-Links这样可组合的代币，显示他们对某个品牌的所有收藏品，那么该品牌将能够通过独家邀请和优惠来奖励这位客户。</p> 
  <h3>ERC1155</h3> 
  <blockquote> 
   <p>状态：<br> 草稿（Draft）</p> 
   <p>提交记录：<br> https://github.com/ethereum/EIPs/issues/1155</p> 
   <p>标准说明：<br> https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md</p> 
   <p>推荐样例：</p> 
   <p>https://enjincoin.io/</p> 
  </blockquote> 
  <p>ERC-1155是一种定义token的新标准，1155是这种方法的编号。1155标准定义了一种解决上述问题的新方法。现在『物品』（可能包含ERC20的token或ERC721的token或两者都有）可以被单一的一个合约（打包处理）来定义了。合约里包含区别token们所需的最小量的数据。合约的状态包含了每个token ID的配置信息和管理收集的所有行为。ERC-1155的灵活性更强，它使得开发者可以自行选择是批量生成某一种特定的token，还是构建不可被复制的惟一元数据。<br> ERC-1155支持原子交换，“原子交换”是指不通过中介物而将一种token换成为另外一种token。<br> ERC-1155的最大进步就是可以融合不同token（可能是“可替换”的代币与“不可替换”的代币的混合体）进行“打包处理”。</p> 
  <p>函数接口说明：</p> 
  <pre class="has">
<code class="language-bash"># (基本定义同上)
name(uint256 _itemId)：

symbol(uint256 _itemId)：

decimals(uint256 _itemId)：

totalSupply(uint256 _itemId)：

balanceOf(uint256 _itemId, address _owner)：

allowance(uint256 _itemId, address _owner, address _spender)：

transfer(uint256[] _itemId, address[] _to, uint256[] _value)：

transferFrom(uint256[] _itemId, address[] _from, address[] _to, uint256[] _value)：

approve(uint256[] _itemId, address[] _spender, uint256[] _value)：

increaseApproval(uint256[] _itemId, address[] _spender, uint256[] _addedValue)：

decreaseApproval(uint256[] _itemId, address[] _spender, uint256[] _subtractedValue)：

ownerOf(uint256 _itemId)：

itemURI(uint256 _itemId)：

itemByIndex(uint256 _itemId, uint256 _index)：

itemOfOwnerByIndex(uint256 _itemId, address _owner, uint256 _index)：</code></pre> 
  <h1><span style="color:#3399ea;">3、ERC865</span></h1> 
  <blockquote> 
   <p>状态：<br> 还处于pull request下（issue）</p> 
   <p>提交记录：<br> https://github.com/ethereum/EIPs/issues/865</p> 
   <p>标准说明：</p> 
   <p>推荐样例：<br> https://github.com/lavawallet/lava-wallet</p> 
  </blockquote> 
  <p>以太坊开发者Bhaskar Sharma在Medium网站上发表了一篇文章，提出了一个在以太坊中使用对用户更友好的代币的提案，这一提案将允许用户来采用去中心化应用程序（DApps）时使用代币（tokens）来支付交易费用，而不是用以太币ETH来支付。<br> 他认为，以太坊区块链中的费用支付问题为新手带来了麻烦，这些费用用于支付矿工将交易打包到区块并确保区块链的安全。用户必须认识以太坊的工作原理，这样才能理解燃料（gas）价格和成本。用户还需要获得必要的以太币来支付这两种费用。</p> 
  <p>函数接口说明：</p> 
  <pre class="has">
<code class="language-bash">transferPreSigned(bytes _signature, address _to, uint256 _value, uint256 _gasPrice, uint256 _nonce)：

approvePreSigned(bytes _signature, address _spender, uint256 _value, uint256 _gasPrice, uint256 _nonce)：

**approveAndCallPreSigned(bytes _signature, address _spender, uint256 _value, bytes _extraData, uint256 _gasPrice, uint256 _nonce) **：

increaseApprovalPreSigned(bytes _signature, address _to, uint256 _amount, uint256 _gasPrice, uint256 _nonce)：

decreaseApprovalPreSigned(bytes _signature, address _to, uint256 _amount, uint256 _gasPrice, uint256 _nonce)：

revokeSignature(bytes _signature)：</code></pre> 
  <h1><span style="color:#3399ea;">4、更多详情了解可以参考官网github</span></h1> 
  <p>地址：<a href="https://github.com/ethereum/EIPs" rel="nofollow">https://github.com/ethereum/EIPs</a></p> 
  <p>&nbsp;</p> 
  <p>-----------------------------------------</p> 
  <p>有任何建议或问题，欢迎加微信一起学习交流，欢迎从事IT，热爱IT，喜欢深挖源代码的行业大牛加入，一起探讨。</p> 
  <p>个人微信号：bboyHan，博客地址：<a href="https://blog.csdn.net/han0373" rel="nofollow">https://blog.csdn.net/han0373</a></p> 
  <p><img alt="" class="has" src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20180523174712577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbjAzNzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/han0373/article/details/81268658,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/han0373/article/details/81268658,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
