<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>一起学：以太坊智能合约开发 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="一起学：以太坊智能合约开发" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="课程介绍 无论在科技圈还是金融圈，“区块链”俨然成了最热的词汇。2016年，区块链写入了国家的十三五规划中；2017年，央行基于区块链技术的数字票据交易平台测试成功；同年，工信部发布了首个区块链参考架构标准。 经过2017年如火如荼的投资盛宴，区块链开始逐渐走向应用落地，业内都在积极探索使用场景。如金融领域的资产贸易、支付系统、金融服务，其他领域的电子商务、社交通讯、游戏娱乐等等。同时，BAT、迅雷、小米、网易等互联网龙头企业纷纷加入研发队伍中。 正如移动互联网兴起之时一样，区块链 DApp 应用市场初期肯定会有一波红利期。对此有兴趣的开发者，不可错过。  以太坊是现阶段业内生态最好的公链，本达人课的内容将基于以太坊平台，共包含四大部分：  第一部分（第01-02课）介绍以太坊相关概念及开发环境的准备，包括以太坊节点、EVM 虚拟机、Gas 机制及开发测试用的私有链 Ganache。  第二部分（第03-05课）从编写简单的 Hello world 合约入手，学习智能合约的开发、编译、部署及网页与智能合约的交互，并学习通过 Truffle 开发框架快速构建 DApp 应用，及如何将合约部署到 Ropsten 测试网和主网。  第三部分（第06-07课）通过详细学习 Solidity 语法，实现一个去中心化的投票 DApp，加深对智能合约开发的理解与应用，全方位提升你的技术实力与思维方式。  第四部分（第08-09课）对去年火热的 ICO 代币发行进行技术上的解读，分析 ERC20 合约代码，并实现代币的增发、兑换、冻结等高级功能。 作者简介 旷文杰，资深 PHP 开发，曾就职于阿里巴巴旗下美妆电商平台。现在区块链领域深耕，在某区块链创业公司任技术经理，对以太坊智能合约有较深入的研究。热爱技术交流，常在个人博客上分享技术心得。 课程内容 第01课：理解以太坊相关概念 2009年比特币开创了去中心化加密货币的先河，同时也诞生了具有划时代意义的区块链技术。分布式数据存储、点对点传输、共识机制、加密算法等计算机技术组成了新型应用模式。然而比特币也并不完美，它只能当作支付手段，无法围绕它建立应用生态。所以业内称比特币为区块链1.0。 2013年，俄罗斯90后 Vitalik Buterin 在基于比特币的区块链技术基础之上，提出了以太坊平台。一个开源的、图灵完备的、有智能合约功能的、下一代加密货币与去中心化应用平台。 经过近五年的时间发展，以太坊已经成为业内公认的最好的公链之一，围绕它的生态建设已经初具规模。我们称之为区块链2.0。 本达人课基于以太坊平台，快速带领大家学习以太坊智能合约的开发，并掌握去中心化应用的开发、编译、部署的完整过程。在开始之前，本篇将以通俗易懂的方式介绍以太坊开发中涉及到的相关概念，带领大家轻松入门。 以太坊 以太坊（Ethereum）是一个建立在区块链技术之上的、图灵完备的去中心化应用平台。它允许任何人在平台中通过智能合约技术开发、部署和使用去中心化应用。 有没有感到和 iOS、Android 平台有点类似？ 在区块链1.0时代，我们如果需要编写区块链应用需要先从 Github 上 Download 一份比特币源码，然后修改底层代码如网络协议、共识机制、加密算法等等，再发布到网络中。2013、2014年的很多山寨币就是这样产生的，改一改比特币的代码，甚至是调整其中的某些参数就造出了一个新的应用、新的币种。 而以太坊平台，是对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，开发者只需专注于应用本身，而不用关注底层技术的具体实现，从而大大降低了难度。我们可以简单的理解，以太坊平台提供了很多模块让用户来搭建应用。如果将搭建应用比作造房子，那么以太坊就提供了地基、墙面、屋顶、地板等模块。用户只需像搭积木一样就可以把房子搭起来，而且房子的布局、装饰等等都是可以随意组装的。因此，在以太坊平台上可以快速建立去中心化应用，并且成本也更低。 目前围绕以太坊已经形成了一个较为完善的开发生态圈：社区支持、开发框架、开发工具等等。 以太坊客户端（节点） 一个以太坊客户端就是一个以太坊节点。它提供账户管理、数字资产管理、挖矿、转账、智能合约的部署和执行等等功能。对于我们开发者来说，它就是一个开发者工具。 需要注意的是，在区块链网络中是没有中心服务器的。所有以太坊节点组成了以太坊的整个区块链网络，每个节点都在无时无刻同步区块数据。 如上图所示（图片来自网络），左边是去中心化的网络，右边是中心化网络。我们举个不恰当的例子来加深理解。在浏览器——服务器架构中，服务器是中心化的，所有的动态数据都保存在服务器端。如果服务器发生故障，则所有的浏览器端都无法正常访问应用。而在区块链的去中心化网络中，所有的节点都会保存相同的数据，任意节点发生故障，都不影响整个区块链数据的写入与读取。 Geth 是典型的以太坊客户端。Geth 这个名字是 Go Ethereum 开源项目的简称。它是基于 Go 语言开发且实现了 Ethereum 协议的客户端软件。 Geth 提供了一个交互式命令控制台，通过命令来操作以太坊的各种功能（API）。 Geth 会一直同步以太坊区块链上的所有数据。目前 fast 同步模式下，数据量已经有近 70G；full 同步模式下，已经达到了几百 G。 在开发过程中，我们推荐使用以太坊区块链的私有链 Ganache （只有几百 M），免去同步以太坊全部区块数据的麻烦。在后续的文章中会介绍 Ganache。 账户 以太坊中账户分为两类： 外部账户（EOA） 该类账户被公钥——私钥对控制（用户），没有关联任何代码。 外部账户的地址由公钥衍生而来。 合约账户（CA） 该类账户为智能合约分配的账户，被合约代码控制且有代码与之关联。 智能合约的部署会把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址就是合约账户。 合约账户存储了代码，外部账户则没有。除了这点之外，这两类账户对于以太坊虚拟机（EVM）来说都是一样的。 如上图所示，外部账户与外部账户之间交易仅仅是转账。但是外部账户到合约账户，是可以激活各种操作的。 智能合约 网络上关于智能合约的解释都很晦涩。我们可以简单的理解为在区块链上，由事件驱动、以代码形式存在、可执行的特殊交易合同。它是代码与数据的集合，是以太坊的核心。 智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等场景。同时，智能合约在其他行业中的应用场景同样值得期待。 目前除数字货币之外，真正落地的应用还不多，业内各方都在积极探索使用场景和可落地应用。和移动互联网刚兴起之时，各行各业的 App 如雨后春笋般爆发一样，去中心化应用的市场在初期肯定有一个红利期。大家可抓住这波机会。 Solidity Solidity 是一门和 JavaScript 类似的编程语言，文件扩展名以 .sol 结尾。它用于智能合约的开发，并能编译成以太坊虚拟机（EVM）字节码，部署到以太坊底层区块链网络上。 以太坊虚拟机（EVM） EVM 即以太坊虚拟机，全称是 Ethereum Virtual Machine。它是以太坊智能合约的运行环境。 EVM 是由以太坊节点提供。每个以太坊节点中都包含 EVM。 Solidity 之于 EVM，就像 Java 跟 JVM 的关系一样。 以太坊虚拟机是一个隔离的环境，在 EVM 内部运行的代码跟外部没有联系。 EVM 运行在以太坊节点上，当我们把合约部署到以太坊区块链网络上之后，合约就可以在以太坊网络中运行了。 合约编译 以太坊虚拟机上运行的是合约的字节码，类似于汇编语言。这就需要我们在部署之前先对合约进行编译，转换成字节码。 推荐使用 solc 编译器。 合约部署 合约部署就是将编译好的合约字节码，通过外部账号以发送交易的形式部署到以太坊区块链网络上。由实际矿工出块之后，才会真正部署成功。 合约运行 合约部署后，当需要调用这个智能合约的方法时，只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在 EVM 中执行了。 Gas Gas 即矿工费。以太坊上每笔交易的执行（被矿工打包）都会被收取一定数量的 Gas。Gas的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发一个 out of gas 异常。当前调用帧所做的所有状态修改都将被回滚。如果执行结束，还有gas剩余，这些 Gas 将会返还给发送账户。因此，我们需要一个有以太币余额的外部账户，来为发起的交易支付 Gas。 如果没有这个限制，就会出现无法停止（如：死循环）的合约来阻塞以太坊区块链网络。 Gas 可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量、类型、占用的内存等等），所需的 Gas 就越多。Gas 的最小单位是 wei: 1eth=$10^{18}$wei=$10^{9}$gwei GasLimit：愿意支付矿工费的上限。 GasPrice：矿工费单价。 gas = GasLimit * GasPrice 去中心化应用（DApp） DApp 全称是 Decentralized App。以太坊社区把基于智能合约的应用称为去中心化的应用。如果我们把区块链理解为一个不可篡改的分布式账本数据库，智能合约理解为和数据库打交道的程序，那就很容易理解 DApp 了。一个 DApp 不单单有智能合约，还需要有一个友好的用户界面和其他的业务程序。在接下来的课程中，我们将实战开发一个简单的DApp。 Truffle Truffle 是目前最流行的 DApp 开发框架，它可以帮我们处理掉很多繁琐的事情，让我们更专注于智能合约的开发，迅速开始编码 -&gt; 编译 -&gt; 部署 -&gt; 测试 -&gt; 打包 DApp 的流程。 总结 最后我们来简单总结一下。以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用。应用中，我们可以使用 Solidity 来编写和区块链交互的智能合约，合约编写好之后，我们通过一个有余额的外部账户将合约部署到以太坊节点上，并运行合约（使用 Truffle 框架可以更好的帮助我们做这些事情）。 本篇中以太坊的这些概念，初次接触者对它们有一个基本的了解即可，没有必要把每一个概念都掌握的很细致、准确。学习是一个循序渐进、逐步深入的过程，很多时候，我们会发现过了一段时间后，对于同一个概念，会有不一样的理解与认知。 第02课：搭建开发环境 在正式开始以太坊智能合约的开发之前，我们需要先做好准备工作，包括相关环境的搭建、IDE 的选择等等，才能让我们的开发之旅得心应手。 操作系统 推荐使用 MacOS 或 Linux 系统。谨慎使用 Windows 来开发智能合约，可能会遇到很多奇葩的问题。本课程所有文章中的运行环境都是基于 MacOS 系统。 IDE 支持 Solidity 语法 工欲善其事，必先利于器。在使用 Solidity 语言 开始编写智能合约之前，需要一款得心应手的 IDE。本篇推荐使用 Atom 或是 IntelliJ IDEA 系列的 WebStorm。下面分别介绍它们如何安装支持 Solidity 语法的插件。 Atom 打开 Preferences - Install 操作面板，在右边的搜索框中输入“solidity”后点击 Packages 按钮进行搜索： 从图中可以看到，搜索结果页中 linter-solidity 和 autocomplete-solidity 两个插件的下载次数特别多。linter-solidity 插件用于 Solidity 语法高亮，autocomplete-solidity 插件用于 Solidity 语法的自动补全。我们分别点击 install 按钮来安装这两个插件，Atom 会自动下载并安装，重启 Atom 后即可看到效果（友情提示：翻墙后，两个插件下载会更快）。 Webstorm 接下来介绍在 Webstorm 中如何安装支持 Solidity 语法高亮的插件。打开 Preferences - Plugins 面板： 按图所示，在右边搜索框内输入“solidity”，并点击 Search in repositories。接下来就会看到我们需要用的插件 Intellij-Solidity： 选中 Intellij-Solidity 插件，点击右边面板中的 install 按钮，WebStorm 就开始下载插件并自动安装。重启 WebStorm 之后即生效。需要注意的是，此插件只支持 Solidity 语法高亮，并不支持语法自动补全。 安装 Node 智能合约的开发语言 Solidity 是类似于 Javascript 的一门语言。同时，后面我们需要用到的 Truffle 快速开发框架也是基于 Javascript。所以，我们需要安装好 Node 环境。打开 Node 中文网 并下载相应的安装包： 按提示步骤即可安装成功。本课程所有文章的 Node 环境都是基于如下版本： $ node -vv8.9.0$ npm -v5.5.1 节点工具 Ganache 上一篇我们有提到 Geth 节点工具。不过 Geth 会一直同步以太坊区块链上的所有数据。目前 fast 同步模式下，数据量已经有近70G；full 同步模式下，已经达到了几百G。在开发过程中，它会消耗大量的磁盘空间及时间来进行同步操作。所以，我们推荐在开发中使用 Ganache。 Ganache只有几百 M 大小，可以快速启动个人以太坊区块链，并可以使用它来运行测试，执行命令、检查状态，同时控制链条的运行方式。 安装 打开 Ganache 官网，并点击 DOWNLOAD 按钮： 下载完后，直接按提示即可安装成功。打开后的界面如图所示： 可以看到 ACCOUNTS 面板里已经生成了10个账户可用。每个账户里都有100枚 ETH。 Ganache 特征 通过 Ganache，我们可以： 快速查看所有账户的当前状态，包括他们的地址、私钥、交易和余额； 查看 Ganache 内部区块链的日志输出，包括响应和其他重要的调试信息 检查所有块和交易，以获取相关问题的信息 需要注意的是，Ganache每次重启，都会将数据还原到初始状态。 以下是 Ganache 的几个重要面板的截图： Infura 在智能合约开发完，通过 Ganache 部署成功并进行了初步校验后，我们需要将合约部署到 Ropsten 测试网，及 Mainnet 主网。这里我们推荐使用 Infura。 Infura 提供了托管的以太坊节点，不再需要我们消耗大量的磁盘空间和时间来搭建本地节点。同时，它为我们的 DApp 应用提供了以太坊节点支持，我们通过 API 和开发人员工具就可以安全、可靠和可扩展的访问以太坊节点。目前已经为9000多名开发人员和 DApp 应用提供以太坊节点服务。 申请节点访问 URL 我们在浏览器上打开 https://infura.io/signup （需翻墙），填写一些资料后即可免费申请 Infura 的以太坊节点访问 URL： 填写完你的姓名、邮箱地址，并进行了人机校验后，点击 Submit 按钮提交信息，Infura 就为你分配了各个网络的以太坊节点访问 URL（红框处）： 需要注意的是，Infura 并不会帮你保存这些信息，你需要手动复制并在本地保存。一旦丢失或忘记，是找不回这些信息的，只能重新申请。 至此，我们的开发环境就准备好了，下一篇文章就正式开始动手编写智能合约了。 第03课：Hello world 合约开发 绝大部分开发者学习一门语言的时候，都是从输出一个 Hello World 开始。我们也从实现一个 Hello World 合约为切入点，开始进入智能合约的世界吧。 环境准备 前面已经介绍了 Node 和 npm 的安装。本系列文章依赖的环境版本： Node：v8.9.0 Npm：5.5.1 接下来，在你的代码目录里，创建名为 smartcontract 的文件夹，并创建如下两个文件 package.json 、Hello.sol 。 smartcontract ├── Hello.sol └── package.json 在 package.json 文件里，添加如下依赖包配置： { &quot;name&quot;: &quot;smartcontract&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;dependencies&quot;: { &quot;fs&quot;: &quot;0.0.1-security&quot;, &quot;solc&quot;: &quot;^0.4.21&quot;, &quot;web3&quot;: &quot;^0.20.0&quot; }} fs 模块用于文件的相关操作； solc 模块是编译器； web3 模块是以太坊提供的工具包，主要用于与合约的通信。 接下来执行 npm install 下载相关的依赖包。 编写合约代码 环境准备好后，就可以开始编写合约代码了。 打开 Hello.sol 文件，编写代码如下： //pragma关键字：版本申明。//用来指示编译器将代码编译成特定版本，以免引起兼容性问题//此处不支持0.4.0之前的编译器，也不支持0.5.0之后的编译器（条件为 ^）pragma solidity ^0.4.0;//contract关键字：合约申明//和Java、PHP中的class类似//此处是申明一个名为Hello的合约contract Hello { //public: 函数访问属性(后续文章为详细阐述) //returns (string): 定义返回值类型为string function say(string name) public returns (string) { return name; }} 代码很简单。就是实现了用户输入什么字符串，合约就原样返回的操作。 接下来，我们需要编写合约部署脚本。 合约部署脚本 在 smartcontract 目录下，新建名为 deploy.js 的文件。代码如下： //设置web3连接var Web3 = require(&#39;web3&#39;);//http://localhost:7545 为Ganache提供的节点链接var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取合约var fs = require(&#39;fs&#39;);var contractCode = fs.readFileSync(&#39;Hello.sol&#39;).toString();//编译合约代码var solc = require(&#39;solc&#39;);var compileCode = solc.compile(contractCode);console.log(compileCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;:Hello&#39;].interface);var byteCode = compileCode.contracts[&#39;:Hello&#39;].bytecode;//创建合约对象var VotingContract = web3.eth.contract(abi);//部署合约，并返回部署对象var deployedContract = VotingContract.new({ data:byteCode, from:web3.eth.accounts[0], //部署合约的外部账户地址 gas:750000 //部署合约的矿工费});console.log(deployedContract); 代码里我加上了简单的注释。这里解释一下 abi 这个概念。 abi 全称是 Application Binary Interface，即应用程序二进制接口。简单的说，就是合约对外的接口描述。 需要注意的是，矿工费 Gas 为750000。以太坊上每笔交易的执行（被矿工打包）都会被收取一定数量的 Gas。Gas 的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发一个 out of gas 异常。当前调用帧所做的所有状态修改都将被回滚。如果执行结束，还有Gas剩余，这些 Gas 将会返还给发送账户。因此，如果部署时抛出 out of gas 的异常，我们可适当的提高 Gas 值。 合约部署 在当前目录下，执行 node deploy.js 命令。我们在部署脚本里将 compileCode 变量打印出来了，粗略看看就行： { contracts: { &#39;:Hello&#39;: { assembly: [Object], bytecode: &#39;6060604052341561000f57600080fd5b61016c8061001e6000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063d5c6130114610046575b600080fd5b341561005157600080fd5b6100a1600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061011c565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100e15780820151818401526020810190506100c6565b50505050905090810190601f16801561010e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61012461012c565b819050919050565b6020604051908101604052806000815250905600a165627a7a72305820ff14cafd1df21e1edf19eff7598bc82a98940cc0fe045d6107d04bb224014f990029&#39;, functionHashes: [Object], gasEstimates: [Object], interface: &#39;[{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;name&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;name&quot;:&quot;say&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;}]&#39;, metadata: &#39;{&quot;compiler&quot;:{&quot;version&quot;:&quot;0.4.21+commit.dfe3193c&quot;},&quot;language&quot;:&quot;Solidity&quot;,&quot;output&quot;:{&quot;abi&quot;:[{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;name&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;name&quot;:&quot;say&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;}],&quot;devdoc&quot;:{&quot;methods&quot;:{}},&quot;userdoc&quot;:{&quot;methods&quot;:{}}},&quot;settings&quot;:{&quot;compilationTarget&quot;:{&quot;&quot;:&quot;Hello&quot;},&quot;evmVersion&quot;:&quot;byzantium&quot;,&quot;libraries&quot;:{},&quot;optimizer&quot;:{&quot;enabled&quot;:false,&quot;runs&quot;:200},&quot;remappings&quot;:[]},&quot;sources&quot;:{&quot;&quot;:{&quot;keccak256&quot;:&quot;0x2e3dd18fbfbd17bb4f866b1bfbb38082172a0bb58d9396b63bab04e67d9d8e08&quot;,&quot;urls&quot;:[&quot;bzzr://d1aae746dfab03e712d8a3cb76b7d4b5bf60f48fafbffa04dfa8a2d53ad5d0ca&quot;]}},&quot;version&quot;:1}&#39;, opcodes: &#39;PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x16C DUP1 PUSH2 0x1E PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x41 JUMPI PUSH1 0x0 CALLDATALOAD PUSH29 0x100000000000000000000000000000000000000000000000000000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0xD5C61301 EQ PUSH2 0x46 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE ISZERO PUSH2 0x51 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xA1 PUSH1 0x4 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP3 ADD DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP POP SWAP2 SWAP1 POP POP PUSH2 0x11C JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0xE1 JUMPI DUP1 DUP3 ADD MLOAD DUP2 DUP5 ADD MSTORE PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH2 0xC6 JUMP JUMPDEST POP POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x10E JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x124 PUSH2 0x12C JUMP JUMPDEST DUP2 SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x0 DUP2 MSTORE POP SWAP1 JUMP STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 SELFDESTRUCT EQ 0xca REVERT SAR CALLCODE 0x1e 0x1e 0xdf NOT 0xef 0xf7 MSIZE DUP12 0xc8 0x2a SWAP9 SWAP5 0xc 0xc0 INVALID DIV 0x5d PUSH2 0x7D0 0x4b 0xb2 0x24 ADD 0x4f SWAP10 STOP 0x29 &#39;, runtimeBytecode: &#39;606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063d5c6130114610046575b600080fd5b341561005157600080fd5b6100a1600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061011c565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100e15780820151818401526020810190506100c6565b50505050905090810190601f16801561010e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61012461012c565b819050919050565b6020604051908101604052806000815250905600a165627a7a72305820ff14cafd1df21e1edf19eff7598bc82a98940cc0fe045d6107d04bb224014f990029&#39;, srcmap: &#39;25:102:0:-;;;;;;;;;;;;;;;;;&#39;, srcmapRuntime: &#39;25:102:0:-;;;;;;;;;;;;;;;;;;;;;;;;47:78;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;23:1:-1;8:100;33:3;30:1;27:10;8:100;;;99:1;94:3;90:11;84:18;80:1;75:3;71:11;64:39;52:2;49:1;45:10;40:15;;8:100;;;12:14;47:78:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;89:6;;:::i;:::-;114:4;107:11;;47:78;;;:::o;25:102::-;;;;;;;;;;;;;;;:::o&#39; } }, errors: [ &#39;:5:5: Warning: Function state mutability can be restricted to pure\n function say(string name) public returns (string) {\n ^ (Relevant source part starts here and spans across multiple lines).\n&#39; ], sourceList: [ &#39;&#39; ], sources: { &#39;&#39;: { AST: [Object] } } } 打开 Ganache 的 LOGS 面板，可以看到部署产生的交易（Transaction）日志： 箭头所指就是部署成功后的合约地址：0xbf474d24ba8b19811db5deb51137ddccbe3ff288（每个人部署后的地址可能都不相同）。 我们记录下来，后面的合约调用代码里需要用到。同时，也可以打开 ACCOUNTS 面板，观察账户余额的变化。 合约调用 合约部署成功之后，我们写一段代码来调用合约里的 say() 方法，检测一下效果。在 smartcontract 目录下，新建名为 run.js 的文件，代码如下： //设置web3连接var Web3 = require(&#39;web3&#39;);//http://localhost:7545 为Ganache提供的节点链接var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取合约var fs = require(&#39;fs&#39;);var contractCode = fs.readFileSync(&#39;Hello.sol&#39;).toString();//编译合约代码var solc = require(&#39;solc&#39;);var compileCode = solc.compile(contractCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;:Hello&#39;].interface);var byteCode = compileCode.contracts[&#39;:Hello&#39;].bytecode;//创建合约对象var VotingContract = web3.eth.contract(abi);//0xbf474d24ba8b19811db5deb51137ddccbe3ff288为合约部署地址var contractInstance = VotingContract.at(&quot;0xbf474d24ba8b19811db5deb51137ddccbe3ff288&quot;);var result = contractInstance.say.call(&#39;Hello world&#39;);console.log(result); 我们来执行 node run.js 命令，可以看到在终端里输出了 Hello world 。 字符串拼接 我们可以扩展一下。如果我们事先在合约里定义好 Hello 字符串，如何与 name 变量进行字符串拼接？ 在智能合约里进行字符串的拼接可不是一件简单的事情。我们先用绝大部分编程语言都通用的连接符 + 和 . 来尝试着修改代码： //pragma关键字：版本申明。//用来指示编译器将代码编译成特定版本，以免引起兼容性问题//此处不支持0.4.0之前的编译器，也不支持0.5.0之后的编译器（条件为 ^）pragma solidity ^0.4.0;//contract关键字：合约申明//和Java、PHP中的class类似//此处是申明一个名为Hello的合约contract Hello { string str=&quot;Hello &quot;; //public: 函数访问属性(后续文章为详细阐述) //returns (string): 定义返回值类型为string function say(string name) public returns (string) { return str + name; }} 运行 node deploy.js 部署脚本后，抛出了一个异常： TypeError: Operator + not compatible with types string storage ref and string memory return str + name; 我们将其修改为“.”并尝试部署后，也抛出一个异常： TypeError: Member &quot;name&quot; not found or not visible after argument-dependent lookup in string storage ref return str . name; 说明在智能合约里，“+”和“.”都不是连接符。通过查阅 Solidity 官方文档，我们发现 Solidity 语言并不提供字符串连接符的语法： 那有没有其他方式，可以实现字符串的拼接功能呢？ 以太坊核心开发团队已经为其提供了字符串的扩展类。从 strings.sol 处下载字符串工具合约，保存到 smartcontract 目录中： smartcontract ├── Hello.sol ├── deploy.js ├── node_modules ├── package.json ├── run.js └── strings.sol 修改 Hello.sol 代码： pragma solidity ^0.4.0;//导入 strings.sol 工具合约import &quot;./strings.sol&quot;; //注意这里contract Hello { //将 strings 工具合约用于所有数据类型 using strings for *; //注意这里 string str=&quot;Hello &quot;; function say(string name) public returns (string) { return str.toSlice().concat(name.toSlice()); }} 运行部署脚本 node deploy.js 后，抛出一个异常： ParserError: Source &quot;strings.sol&quot; not found: File not supplied initially. import &quot;./strings.sol&quot; 提示 strings.sol 文件找不到，这并不是合约代码有问题，而是 solc 编译器 的问题。 solc 编译器 目前不支持关联文件的自动引入。我们期望编译器以更智能的方式引入关联的文件，但是这意味着它至少需要 fs 模块，而 fs 模块反过来又增加了 solc 模块的大小，同时也增加了不必要的依赖。 所以，我们需要修改部署脚本文件 deploy.js 的代码： //设置web3连接var Web3 = require(&#39;web3&#39;);var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取strings.sol和hello.sol两个合约 var fs = require(&#39;fs&#39;);var contractCode = { //注意这里的变化 &quot;strings.sol&quot;:fs.readFileSync(&#39;strings.sol&#39;).toString(), &quot;Hello.sol&quot;:fs.readFileSync(&#39;Hello.sol&#39;).toString()};//编译合约代码var solc = require(&#39;solc&#39;);var compileCode = solc.compile({ //注意这里的变化 sources:contractCode},1);console.log(compileCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;Hello.sol:Hello&#39;].interface); //注意这里的变化var byteCode = compileCode.contracts[&#39;Hello.sol:Hello&#39;].bytecode; //注意这里的变化//创建合约对象var VotingContract = web3.eth.contract(abi);//部署合约，并返回部署对象var deployedContract = VotingContract.new({ data:byteCode, from:web3.eth.accounts[0], gas:750000});console.log(deployedContract); 读取 strings.sol 和 Hello.sol 两个合约文件，并一同编译即可。再次执行 node deploy.js 命令，合约部署成功。记录下合约地址：0x58a73dea66cea789dcfb5b4a94b7247ca010b781（每个人执行的合约地址可能都不相同）。 同时，合约调用脚本 run.js 的代码修改部分和 deploy.js 相同： //设置web3连接var Web3 = require(&#39;web3&#39;);var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取strings.sol和hello.sol两个合约 var fs = require(&#39;fs&#39;);var contractCode = { &quot;strings.sol&quot;:fs.readFileSync(&#39;strings.sol&#39;).toString(), //注意这里的变化 &quot;Hello.sol&quot;:fs.readFileSync(&#39;Hello.sol&#39;).toString() //注意这里的变化};//编译合约代码成字节码var solc = require(&#39;solc&#39;);var compileCode = solc.compile({ //注意这里的变化 sources:contractCode},1);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;Hello.sol:Hello&#39;].interface); //注意这里的变化var byteCode = compileCode.contracts[&#39;Hello.sol:Hello&#39;].bytecode; //注意这里的变化//创建合约对象var VotingContract = web3.eth.contract(abi);var contractInstance = VotingContract.at(&quot;0x58a73dea66cea789dcfb5b4a94b7247ca010b781&quot;);var result = contractInstance.say.call(&#39;world&#39;);console.log(result);console.log(contractInstance.say.call(&#39;Guys&#39;)); 执行脚本后，可以看到终端打印出了两行字符串： Hello world Hello Guys strings.sol 工具合约中还提供了字符串的比较、查找、切割等方法，大家可以动手尝试。本篇不做过多介绍。 至此，第一个智能合约 Hello world 的代码编写、编译、部署、 调用的过程就完成了。建议大家动手执行一遍，加深理解。 第04课：Truffle 构建 DApp 应用 第05课：部署合约到 Ropsten 测试网和主网 第06课：Solidity 详解 第07课：去中心化投票 DApp 的开发 第08篇：ERC20 代币发行 第09课：实现代币的增发、冻结等高级功能 阅读全文: http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac 阅读更多" />
<meta property="og:description" content="课程介绍 无论在科技圈还是金融圈，“区块链”俨然成了最热的词汇。2016年，区块链写入了国家的十三五规划中；2017年，央行基于区块链技术的数字票据交易平台测试成功；同年，工信部发布了首个区块链参考架构标准。 经过2017年如火如荼的投资盛宴，区块链开始逐渐走向应用落地，业内都在积极探索使用场景。如金融领域的资产贸易、支付系统、金融服务，其他领域的电子商务、社交通讯、游戏娱乐等等。同时，BAT、迅雷、小米、网易等互联网龙头企业纷纷加入研发队伍中。 正如移动互联网兴起之时一样，区块链 DApp 应用市场初期肯定会有一波红利期。对此有兴趣的开发者，不可错过。  以太坊是现阶段业内生态最好的公链，本达人课的内容将基于以太坊平台，共包含四大部分：  第一部分（第01-02课）介绍以太坊相关概念及开发环境的准备，包括以太坊节点、EVM 虚拟机、Gas 机制及开发测试用的私有链 Ganache。  第二部分（第03-05课）从编写简单的 Hello world 合约入手，学习智能合约的开发、编译、部署及网页与智能合约的交互，并学习通过 Truffle 开发框架快速构建 DApp 应用，及如何将合约部署到 Ropsten 测试网和主网。  第三部分（第06-07课）通过详细学习 Solidity 语法，实现一个去中心化的投票 DApp，加深对智能合约开发的理解与应用，全方位提升你的技术实力与思维方式。  第四部分（第08-09课）对去年火热的 ICO 代币发行进行技术上的解读，分析 ERC20 合约代码，并实现代币的增发、兑换、冻结等高级功能。 作者简介 旷文杰，资深 PHP 开发，曾就职于阿里巴巴旗下美妆电商平台。现在区块链领域深耕，在某区块链创业公司任技术经理，对以太坊智能合约有较深入的研究。热爱技术交流，常在个人博客上分享技术心得。 课程内容 第01课：理解以太坊相关概念 2009年比特币开创了去中心化加密货币的先河，同时也诞生了具有划时代意义的区块链技术。分布式数据存储、点对点传输、共识机制、加密算法等计算机技术组成了新型应用模式。然而比特币也并不完美，它只能当作支付手段，无法围绕它建立应用生态。所以业内称比特币为区块链1.0。 2013年，俄罗斯90后 Vitalik Buterin 在基于比特币的区块链技术基础之上，提出了以太坊平台。一个开源的、图灵完备的、有智能合约功能的、下一代加密货币与去中心化应用平台。 经过近五年的时间发展，以太坊已经成为业内公认的最好的公链之一，围绕它的生态建设已经初具规模。我们称之为区块链2.0。 本达人课基于以太坊平台，快速带领大家学习以太坊智能合约的开发，并掌握去中心化应用的开发、编译、部署的完整过程。在开始之前，本篇将以通俗易懂的方式介绍以太坊开发中涉及到的相关概念，带领大家轻松入门。 以太坊 以太坊（Ethereum）是一个建立在区块链技术之上的、图灵完备的去中心化应用平台。它允许任何人在平台中通过智能合约技术开发、部署和使用去中心化应用。 有没有感到和 iOS、Android 平台有点类似？ 在区块链1.0时代，我们如果需要编写区块链应用需要先从 Github 上 Download 一份比特币源码，然后修改底层代码如网络协议、共识机制、加密算法等等，再发布到网络中。2013、2014年的很多山寨币就是这样产生的，改一改比特币的代码，甚至是调整其中的某些参数就造出了一个新的应用、新的币种。 而以太坊平台，是对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，开发者只需专注于应用本身，而不用关注底层技术的具体实现，从而大大降低了难度。我们可以简单的理解，以太坊平台提供了很多模块让用户来搭建应用。如果将搭建应用比作造房子，那么以太坊就提供了地基、墙面、屋顶、地板等模块。用户只需像搭积木一样就可以把房子搭起来，而且房子的布局、装饰等等都是可以随意组装的。因此，在以太坊平台上可以快速建立去中心化应用，并且成本也更低。 目前围绕以太坊已经形成了一个较为完善的开发生态圈：社区支持、开发框架、开发工具等等。 以太坊客户端（节点） 一个以太坊客户端就是一个以太坊节点。它提供账户管理、数字资产管理、挖矿、转账、智能合约的部署和执行等等功能。对于我们开发者来说，它就是一个开发者工具。 需要注意的是，在区块链网络中是没有中心服务器的。所有以太坊节点组成了以太坊的整个区块链网络，每个节点都在无时无刻同步区块数据。 如上图所示（图片来自网络），左边是去中心化的网络，右边是中心化网络。我们举个不恰当的例子来加深理解。在浏览器——服务器架构中，服务器是中心化的，所有的动态数据都保存在服务器端。如果服务器发生故障，则所有的浏览器端都无法正常访问应用。而在区块链的去中心化网络中，所有的节点都会保存相同的数据，任意节点发生故障，都不影响整个区块链数据的写入与读取。 Geth 是典型的以太坊客户端。Geth 这个名字是 Go Ethereum 开源项目的简称。它是基于 Go 语言开发且实现了 Ethereum 协议的客户端软件。 Geth 提供了一个交互式命令控制台，通过命令来操作以太坊的各种功能（API）。 Geth 会一直同步以太坊区块链上的所有数据。目前 fast 同步模式下，数据量已经有近 70G；full 同步模式下，已经达到了几百 G。 在开发过程中，我们推荐使用以太坊区块链的私有链 Ganache （只有几百 M），免去同步以太坊全部区块数据的麻烦。在后续的文章中会介绍 Ganache。 账户 以太坊中账户分为两类： 外部账户（EOA） 该类账户被公钥——私钥对控制（用户），没有关联任何代码。 外部账户的地址由公钥衍生而来。 合约账户（CA） 该类账户为智能合约分配的账户，被合约代码控制且有代码与之关联。 智能合约的部署会把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址就是合约账户。 合约账户存储了代码，外部账户则没有。除了这点之外，这两类账户对于以太坊虚拟机（EVM）来说都是一样的。 如上图所示，外部账户与外部账户之间交易仅仅是转账。但是外部账户到合约账户，是可以激活各种操作的。 智能合约 网络上关于智能合约的解释都很晦涩。我们可以简单的理解为在区块链上，由事件驱动、以代码形式存在、可执行的特殊交易合同。它是代码与数据的集合，是以太坊的核心。 智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等场景。同时，智能合约在其他行业中的应用场景同样值得期待。 目前除数字货币之外，真正落地的应用还不多，业内各方都在积极探索使用场景和可落地应用。和移动互联网刚兴起之时，各行各业的 App 如雨后春笋般爆发一样，去中心化应用的市场在初期肯定有一个红利期。大家可抓住这波机会。 Solidity Solidity 是一门和 JavaScript 类似的编程语言，文件扩展名以 .sol 结尾。它用于智能合约的开发，并能编译成以太坊虚拟机（EVM）字节码，部署到以太坊底层区块链网络上。 以太坊虚拟机（EVM） EVM 即以太坊虚拟机，全称是 Ethereum Virtual Machine。它是以太坊智能合约的运行环境。 EVM 是由以太坊节点提供。每个以太坊节点中都包含 EVM。 Solidity 之于 EVM，就像 Java 跟 JVM 的关系一样。 以太坊虚拟机是一个隔离的环境，在 EVM 内部运行的代码跟外部没有联系。 EVM 运行在以太坊节点上，当我们把合约部署到以太坊区块链网络上之后，合约就可以在以太坊网络中运行了。 合约编译 以太坊虚拟机上运行的是合约的字节码，类似于汇编语言。这就需要我们在部署之前先对合约进行编译，转换成字节码。 推荐使用 solc 编译器。 合约部署 合约部署就是将编译好的合约字节码，通过外部账号以发送交易的形式部署到以太坊区块链网络上。由实际矿工出块之后，才会真正部署成功。 合约运行 合约部署后，当需要调用这个智能合约的方法时，只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在 EVM 中执行了。 Gas Gas 即矿工费。以太坊上每笔交易的执行（被矿工打包）都会被收取一定数量的 Gas。Gas的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发一个 out of gas 异常。当前调用帧所做的所有状态修改都将被回滚。如果执行结束，还有gas剩余，这些 Gas 将会返还给发送账户。因此，我们需要一个有以太币余额的外部账户，来为发起的交易支付 Gas。 如果没有这个限制，就会出现无法停止（如：死循环）的合约来阻塞以太坊区块链网络。 Gas 可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量、类型、占用的内存等等），所需的 Gas 就越多。Gas 的最小单位是 wei: 1eth=$10^{18}$wei=$10^{9}$gwei GasLimit：愿意支付矿工费的上限。 GasPrice：矿工费单价。 gas = GasLimit * GasPrice 去中心化应用（DApp） DApp 全称是 Decentralized App。以太坊社区把基于智能合约的应用称为去中心化的应用。如果我们把区块链理解为一个不可篡改的分布式账本数据库，智能合约理解为和数据库打交道的程序，那就很容易理解 DApp 了。一个 DApp 不单单有智能合约，还需要有一个友好的用户界面和其他的业务程序。在接下来的课程中，我们将实战开发一个简单的DApp。 Truffle Truffle 是目前最流行的 DApp 开发框架，它可以帮我们处理掉很多繁琐的事情，让我们更专注于智能合约的开发，迅速开始编码 -&gt; 编译 -&gt; 部署 -&gt; 测试 -&gt; 打包 DApp 的流程。 总结 最后我们来简单总结一下。以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用。应用中，我们可以使用 Solidity 来编写和区块链交互的智能合约，合约编写好之后，我们通过一个有余额的外部账户将合约部署到以太坊节点上，并运行合约（使用 Truffle 框架可以更好的帮助我们做这些事情）。 本篇中以太坊的这些概念，初次接触者对它们有一个基本的了解即可，没有必要把每一个概念都掌握的很细致、准确。学习是一个循序渐进、逐步深入的过程，很多时候，我们会发现过了一段时间后，对于同一个概念，会有不一样的理解与认知。 第02课：搭建开发环境 在正式开始以太坊智能合约的开发之前，我们需要先做好准备工作，包括相关环境的搭建、IDE 的选择等等，才能让我们的开发之旅得心应手。 操作系统 推荐使用 MacOS 或 Linux 系统。谨慎使用 Windows 来开发智能合约，可能会遇到很多奇葩的问题。本课程所有文章中的运行环境都是基于 MacOS 系统。 IDE 支持 Solidity 语法 工欲善其事，必先利于器。在使用 Solidity 语言 开始编写智能合约之前，需要一款得心应手的 IDE。本篇推荐使用 Atom 或是 IntelliJ IDEA 系列的 WebStorm。下面分别介绍它们如何安装支持 Solidity 语法的插件。 Atom 打开 Preferences - Install 操作面板，在右边的搜索框中输入“solidity”后点击 Packages 按钮进行搜索： 从图中可以看到，搜索结果页中 linter-solidity 和 autocomplete-solidity 两个插件的下载次数特别多。linter-solidity 插件用于 Solidity 语法高亮，autocomplete-solidity 插件用于 Solidity 语法的自动补全。我们分别点击 install 按钮来安装这两个插件，Atom 会自动下载并安装，重启 Atom 后即可看到效果（友情提示：翻墙后，两个插件下载会更快）。 Webstorm 接下来介绍在 Webstorm 中如何安装支持 Solidity 语法高亮的插件。打开 Preferences - Plugins 面板： 按图所示，在右边搜索框内输入“solidity”，并点击 Search in repositories。接下来就会看到我们需要用的插件 Intellij-Solidity： 选中 Intellij-Solidity 插件，点击右边面板中的 install 按钮，WebStorm 就开始下载插件并自动安装。重启 WebStorm 之后即生效。需要注意的是，此插件只支持 Solidity 语法高亮，并不支持语法自动补全。 安装 Node 智能合约的开发语言 Solidity 是类似于 Javascript 的一门语言。同时，后面我们需要用到的 Truffle 快速开发框架也是基于 Javascript。所以，我们需要安装好 Node 环境。打开 Node 中文网 并下载相应的安装包： 按提示步骤即可安装成功。本课程所有文章的 Node 环境都是基于如下版本： $ node -vv8.9.0$ npm -v5.5.1 节点工具 Ganache 上一篇我们有提到 Geth 节点工具。不过 Geth 会一直同步以太坊区块链上的所有数据。目前 fast 同步模式下，数据量已经有近70G；full 同步模式下，已经达到了几百G。在开发过程中，它会消耗大量的磁盘空间及时间来进行同步操作。所以，我们推荐在开发中使用 Ganache。 Ganache只有几百 M 大小，可以快速启动个人以太坊区块链，并可以使用它来运行测试，执行命令、检查状态，同时控制链条的运行方式。 安装 打开 Ganache 官网，并点击 DOWNLOAD 按钮： 下载完后，直接按提示即可安装成功。打开后的界面如图所示： 可以看到 ACCOUNTS 面板里已经生成了10个账户可用。每个账户里都有100枚 ETH。 Ganache 特征 通过 Ganache，我们可以： 快速查看所有账户的当前状态，包括他们的地址、私钥、交易和余额； 查看 Ganache 内部区块链的日志输出，包括响应和其他重要的调试信息 检查所有块和交易，以获取相关问题的信息 需要注意的是，Ganache每次重启，都会将数据还原到初始状态。 以下是 Ganache 的几个重要面板的截图： Infura 在智能合约开发完，通过 Ganache 部署成功并进行了初步校验后，我们需要将合约部署到 Ropsten 测试网，及 Mainnet 主网。这里我们推荐使用 Infura。 Infura 提供了托管的以太坊节点，不再需要我们消耗大量的磁盘空间和时间来搭建本地节点。同时，它为我们的 DApp 应用提供了以太坊节点支持，我们通过 API 和开发人员工具就可以安全、可靠和可扩展的访问以太坊节点。目前已经为9000多名开发人员和 DApp 应用提供以太坊节点服务。 申请节点访问 URL 我们在浏览器上打开 https://infura.io/signup （需翻墙），填写一些资料后即可免费申请 Infura 的以太坊节点访问 URL： 填写完你的姓名、邮箱地址，并进行了人机校验后，点击 Submit 按钮提交信息，Infura 就为你分配了各个网络的以太坊节点访问 URL（红框处）： 需要注意的是，Infura 并不会帮你保存这些信息，你需要手动复制并在本地保存。一旦丢失或忘记，是找不回这些信息的，只能重新申请。 至此，我们的开发环境就准备好了，下一篇文章就正式开始动手编写智能合约了。 第03课：Hello world 合约开发 绝大部分开发者学习一门语言的时候，都是从输出一个 Hello World 开始。我们也从实现一个 Hello World 合约为切入点，开始进入智能合约的世界吧。 环境准备 前面已经介绍了 Node 和 npm 的安装。本系列文章依赖的环境版本： Node：v8.9.0 Npm：5.5.1 接下来，在你的代码目录里，创建名为 smartcontract 的文件夹，并创建如下两个文件 package.json 、Hello.sol 。 smartcontract ├── Hello.sol └── package.json 在 package.json 文件里，添加如下依赖包配置： { &quot;name&quot;: &quot;smartcontract&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;dependencies&quot;: { &quot;fs&quot;: &quot;0.0.1-security&quot;, &quot;solc&quot;: &quot;^0.4.21&quot;, &quot;web3&quot;: &quot;^0.20.0&quot; }} fs 模块用于文件的相关操作； solc 模块是编译器； web3 模块是以太坊提供的工具包，主要用于与合约的通信。 接下来执行 npm install 下载相关的依赖包。 编写合约代码 环境准备好后，就可以开始编写合约代码了。 打开 Hello.sol 文件，编写代码如下： //pragma关键字：版本申明。//用来指示编译器将代码编译成特定版本，以免引起兼容性问题//此处不支持0.4.0之前的编译器，也不支持0.5.0之后的编译器（条件为 ^）pragma solidity ^0.4.0;//contract关键字：合约申明//和Java、PHP中的class类似//此处是申明一个名为Hello的合约contract Hello { //public: 函数访问属性(后续文章为详细阐述) //returns (string): 定义返回值类型为string function say(string name) public returns (string) { return name; }} 代码很简单。就是实现了用户输入什么字符串，合约就原样返回的操作。 接下来，我们需要编写合约部署脚本。 合约部署脚本 在 smartcontract 目录下，新建名为 deploy.js 的文件。代码如下： //设置web3连接var Web3 = require(&#39;web3&#39;);//http://localhost:7545 为Ganache提供的节点链接var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取合约var fs = require(&#39;fs&#39;);var contractCode = fs.readFileSync(&#39;Hello.sol&#39;).toString();//编译合约代码var solc = require(&#39;solc&#39;);var compileCode = solc.compile(contractCode);console.log(compileCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;:Hello&#39;].interface);var byteCode = compileCode.contracts[&#39;:Hello&#39;].bytecode;//创建合约对象var VotingContract = web3.eth.contract(abi);//部署合约，并返回部署对象var deployedContract = VotingContract.new({ data:byteCode, from:web3.eth.accounts[0], //部署合约的外部账户地址 gas:750000 //部署合约的矿工费});console.log(deployedContract); 代码里我加上了简单的注释。这里解释一下 abi 这个概念。 abi 全称是 Application Binary Interface，即应用程序二进制接口。简单的说，就是合约对外的接口描述。 需要注意的是，矿工费 Gas 为750000。以太坊上每笔交易的执行（被矿工打包）都会被收取一定数量的 Gas。Gas 的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发一个 out of gas 异常。当前调用帧所做的所有状态修改都将被回滚。如果执行结束，还有Gas剩余，这些 Gas 将会返还给发送账户。因此，如果部署时抛出 out of gas 的异常，我们可适当的提高 Gas 值。 合约部署 在当前目录下，执行 node deploy.js 命令。我们在部署脚本里将 compileCode 变量打印出来了，粗略看看就行： { contracts: { &#39;:Hello&#39;: { assembly: [Object], bytecode: &#39;6060604052341561000f57600080fd5b61016c8061001e6000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063d5c6130114610046575b600080fd5b341561005157600080fd5b6100a1600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061011c565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100e15780820151818401526020810190506100c6565b50505050905090810190601f16801561010e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61012461012c565b819050919050565b6020604051908101604052806000815250905600a165627a7a72305820ff14cafd1df21e1edf19eff7598bc82a98940cc0fe045d6107d04bb224014f990029&#39;, functionHashes: [Object], gasEstimates: [Object], interface: &#39;[{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;name&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;name&quot;:&quot;say&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;}]&#39;, metadata: &#39;{&quot;compiler&quot;:{&quot;version&quot;:&quot;0.4.21+commit.dfe3193c&quot;},&quot;language&quot;:&quot;Solidity&quot;,&quot;output&quot;:{&quot;abi&quot;:[{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;name&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;name&quot;:&quot;say&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;}],&quot;devdoc&quot;:{&quot;methods&quot;:{}},&quot;userdoc&quot;:{&quot;methods&quot;:{}}},&quot;settings&quot;:{&quot;compilationTarget&quot;:{&quot;&quot;:&quot;Hello&quot;},&quot;evmVersion&quot;:&quot;byzantium&quot;,&quot;libraries&quot;:{},&quot;optimizer&quot;:{&quot;enabled&quot;:false,&quot;runs&quot;:200},&quot;remappings&quot;:[]},&quot;sources&quot;:{&quot;&quot;:{&quot;keccak256&quot;:&quot;0x2e3dd18fbfbd17bb4f866b1bfbb38082172a0bb58d9396b63bab04e67d9d8e08&quot;,&quot;urls&quot;:[&quot;bzzr://d1aae746dfab03e712d8a3cb76b7d4b5bf60f48fafbffa04dfa8a2d53ad5d0ca&quot;]}},&quot;version&quot;:1}&#39;, opcodes: &#39;PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x16C DUP1 PUSH2 0x1E PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x41 JUMPI PUSH1 0x0 CALLDATALOAD PUSH29 0x100000000000000000000000000000000000000000000000000000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0xD5C61301 EQ PUSH2 0x46 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE ISZERO PUSH2 0x51 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xA1 PUSH1 0x4 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP3 ADD DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP POP SWAP2 SWAP1 POP POP PUSH2 0x11C JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0xE1 JUMPI DUP1 DUP3 ADD MLOAD DUP2 DUP5 ADD MSTORE PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH2 0xC6 JUMP JUMPDEST POP POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x10E JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x124 PUSH2 0x12C JUMP JUMPDEST DUP2 SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x0 DUP2 MSTORE POP SWAP1 JUMP STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 SELFDESTRUCT EQ 0xca REVERT SAR CALLCODE 0x1e 0x1e 0xdf NOT 0xef 0xf7 MSIZE DUP12 0xc8 0x2a SWAP9 SWAP5 0xc 0xc0 INVALID DIV 0x5d PUSH2 0x7D0 0x4b 0xb2 0x24 ADD 0x4f SWAP10 STOP 0x29 &#39;, runtimeBytecode: &#39;606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063d5c6130114610046575b600080fd5b341561005157600080fd5b6100a1600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061011c565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100e15780820151818401526020810190506100c6565b50505050905090810190601f16801561010e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61012461012c565b819050919050565b6020604051908101604052806000815250905600a165627a7a72305820ff14cafd1df21e1edf19eff7598bc82a98940cc0fe045d6107d04bb224014f990029&#39;, srcmap: &#39;25:102:0:-;;;;;;;;;;;;;;;;;&#39;, srcmapRuntime: &#39;25:102:0:-;;;;;;;;;;;;;;;;;;;;;;;;47:78;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;23:1:-1;8:100;33:3;30:1;27:10;8:100;;;99:1;94:3;90:11;84:18;80:1;75:3;71:11;64:39;52:2;49:1;45:10;40:15;;8:100;;;12:14;47:78:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;89:6;;:::i;:::-;114:4;107:11;;47:78;;;:::o;25:102::-;;;;;;;;;;;;;;;:::o&#39; } }, errors: [ &#39;:5:5: Warning: Function state mutability can be restricted to pure\n function say(string name) public returns (string) {\n ^ (Relevant source part starts here and spans across multiple lines).\n&#39; ], sourceList: [ &#39;&#39; ], sources: { &#39;&#39;: { AST: [Object] } } } 打开 Ganache 的 LOGS 面板，可以看到部署产生的交易（Transaction）日志： 箭头所指就是部署成功后的合约地址：0xbf474d24ba8b19811db5deb51137ddccbe3ff288（每个人部署后的地址可能都不相同）。 我们记录下来，后面的合约调用代码里需要用到。同时，也可以打开 ACCOUNTS 面板，观察账户余额的变化。 合约调用 合约部署成功之后，我们写一段代码来调用合约里的 say() 方法，检测一下效果。在 smartcontract 目录下，新建名为 run.js 的文件，代码如下： //设置web3连接var Web3 = require(&#39;web3&#39;);//http://localhost:7545 为Ganache提供的节点链接var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取合约var fs = require(&#39;fs&#39;);var contractCode = fs.readFileSync(&#39;Hello.sol&#39;).toString();//编译合约代码var solc = require(&#39;solc&#39;);var compileCode = solc.compile(contractCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;:Hello&#39;].interface);var byteCode = compileCode.contracts[&#39;:Hello&#39;].bytecode;//创建合约对象var VotingContract = web3.eth.contract(abi);//0xbf474d24ba8b19811db5deb51137ddccbe3ff288为合约部署地址var contractInstance = VotingContract.at(&quot;0xbf474d24ba8b19811db5deb51137ddccbe3ff288&quot;);var result = contractInstance.say.call(&#39;Hello world&#39;);console.log(result); 我们来执行 node run.js 命令，可以看到在终端里输出了 Hello world 。 字符串拼接 我们可以扩展一下。如果我们事先在合约里定义好 Hello 字符串，如何与 name 变量进行字符串拼接？ 在智能合约里进行字符串的拼接可不是一件简单的事情。我们先用绝大部分编程语言都通用的连接符 + 和 . 来尝试着修改代码： //pragma关键字：版本申明。//用来指示编译器将代码编译成特定版本，以免引起兼容性问题//此处不支持0.4.0之前的编译器，也不支持0.5.0之后的编译器（条件为 ^）pragma solidity ^0.4.0;//contract关键字：合约申明//和Java、PHP中的class类似//此处是申明一个名为Hello的合约contract Hello { string str=&quot;Hello &quot;; //public: 函数访问属性(后续文章为详细阐述) //returns (string): 定义返回值类型为string function say(string name) public returns (string) { return str + name; }} 运行 node deploy.js 部署脚本后，抛出了一个异常： TypeError: Operator + not compatible with types string storage ref and string memory return str + name; 我们将其修改为“.”并尝试部署后，也抛出一个异常： TypeError: Member &quot;name&quot; not found or not visible after argument-dependent lookup in string storage ref return str . name; 说明在智能合约里，“+”和“.”都不是连接符。通过查阅 Solidity 官方文档，我们发现 Solidity 语言并不提供字符串连接符的语法： 那有没有其他方式，可以实现字符串的拼接功能呢？ 以太坊核心开发团队已经为其提供了字符串的扩展类。从 strings.sol 处下载字符串工具合约，保存到 smartcontract 目录中： smartcontract ├── Hello.sol ├── deploy.js ├── node_modules ├── package.json ├── run.js └── strings.sol 修改 Hello.sol 代码： pragma solidity ^0.4.0;//导入 strings.sol 工具合约import &quot;./strings.sol&quot;; //注意这里contract Hello { //将 strings 工具合约用于所有数据类型 using strings for *; //注意这里 string str=&quot;Hello &quot;; function say(string name) public returns (string) { return str.toSlice().concat(name.toSlice()); }} 运行部署脚本 node deploy.js 后，抛出一个异常： ParserError: Source &quot;strings.sol&quot; not found: File not supplied initially. import &quot;./strings.sol&quot; 提示 strings.sol 文件找不到，这并不是合约代码有问题，而是 solc 编译器 的问题。 solc 编译器 目前不支持关联文件的自动引入。我们期望编译器以更智能的方式引入关联的文件，但是这意味着它至少需要 fs 模块，而 fs 模块反过来又增加了 solc 模块的大小，同时也增加了不必要的依赖。 所以，我们需要修改部署脚本文件 deploy.js 的代码： //设置web3连接var Web3 = require(&#39;web3&#39;);var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取strings.sol和hello.sol两个合约 var fs = require(&#39;fs&#39;);var contractCode = { //注意这里的变化 &quot;strings.sol&quot;:fs.readFileSync(&#39;strings.sol&#39;).toString(), &quot;Hello.sol&quot;:fs.readFileSync(&#39;Hello.sol&#39;).toString()};//编译合约代码var solc = require(&#39;solc&#39;);var compileCode = solc.compile({ //注意这里的变化 sources:contractCode},1);console.log(compileCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;Hello.sol:Hello&#39;].interface); //注意这里的变化var byteCode = compileCode.contracts[&#39;Hello.sol:Hello&#39;].bytecode; //注意这里的变化//创建合约对象var VotingContract = web3.eth.contract(abi);//部署合约，并返回部署对象var deployedContract = VotingContract.new({ data:byteCode, from:web3.eth.accounts[0], gas:750000});console.log(deployedContract); 读取 strings.sol 和 Hello.sol 两个合约文件，并一同编译即可。再次执行 node deploy.js 命令，合约部署成功。记录下合约地址：0x58a73dea66cea789dcfb5b4a94b7247ca010b781（每个人执行的合约地址可能都不相同）。 同时，合约调用脚本 run.js 的代码修改部分和 deploy.js 相同： //设置web3连接var Web3 = require(&#39;web3&#39;);var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取strings.sol和hello.sol两个合约 var fs = require(&#39;fs&#39;);var contractCode = { &quot;strings.sol&quot;:fs.readFileSync(&#39;strings.sol&#39;).toString(), //注意这里的变化 &quot;Hello.sol&quot;:fs.readFileSync(&#39;Hello.sol&#39;).toString() //注意这里的变化};//编译合约代码成字节码var solc = require(&#39;solc&#39;);var compileCode = solc.compile({ //注意这里的变化 sources:contractCode},1);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;Hello.sol:Hello&#39;].interface); //注意这里的变化var byteCode = compileCode.contracts[&#39;Hello.sol:Hello&#39;].bytecode; //注意这里的变化//创建合约对象var VotingContract = web3.eth.contract(abi);var contractInstance = VotingContract.at(&quot;0x58a73dea66cea789dcfb5b4a94b7247ca010b781&quot;);var result = contractInstance.say.call(&#39;world&#39;);console.log(result);console.log(contractInstance.say.call(&#39;Guys&#39;)); 执行脚本后，可以看到终端打印出了两行字符串： Hello world Hello Guys strings.sol 工具合约中还提供了字符串的比较、查找、切割等方法，大家可以动手尝试。本篇不做过多介绍。 至此，第一个智能合约 Hello world 的代码编写、编译、部署、 调用的过程就完成了。建议大家动手执行一遍，加深理解。 第04课：Truffle 构建 DApp 应用 第05课：部署合约到 Ropsten 测试网和主网 第06课：Solidity 详解 第07课：去中心化投票 DApp 的开发 第08篇：ERC20 代币发行 第09课：实现代币的增发、冻结等高级功能 阅读全文: http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac 阅读更多" />
<link rel="canonical" href="https://mlh.app/2018/07/03/14aa094283c1435c3f84293e34b0cc8c.html" />
<meta property="og:url" content="https://mlh.app/2018/07/03/14aa094283c1435c3f84293e34b0cc8c.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-03T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"课程介绍 无论在科技圈还是金融圈，“区块链”俨然成了最热的词汇。2016年，区块链写入了国家的十三五规划中；2017年，央行基于区块链技术的数字票据交易平台测试成功；同年，工信部发布了首个区块链参考架构标准。 经过2017年如火如荼的投资盛宴，区块链开始逐渐走向应用落地，业内都在积极探索使用场景。如金融领域的资产贸易、支付系统、金融服务，其他领域的电子商务、社交通讯、游戏娱乐等等。同时，BAT、迅雷、小米、网易等互联网龙头企业纷纷加入研发队伍中。 正如移动互联网兴起之时一样，区块链 DApp 应用市场初期肯定会有一波红利期。对此有兴趣的开发者，不可错过。  以太坊是现阶段业内生态最好的公链，本达人课的内容将基于以太坊平台，共包含四大部分：  第一部分（第01-02课）介绍以太坊相关概念及开发环境的准备，包括以太坊节点、EVM 虚拟机、Gas 机制及开发测试用的私有链 Ganache。  第二部分（第03-05课）从编写简单的 Hello world 合约入手，学习智能合约的开发、编译、部署及网页与智能合约的交互，并学习通过 Truffle 开发框架快速构建 DApp 应用，及如何将合约部署到 Ropsten 测试网和主网。  第三部分（第06-07课）通过详细学习 Solidity 语法，实现一个去中心化的投票 DApp，加深对智能合约开发的理解与应用，全方位提升你的技术实力与思维方式。  第四部分（第08-09课）对去年火热的 ICO 代币发行进行技术上的解读，分析 ERC20 合约代码，并实现代币的增发、兑换、冻结等高级功能。 作者简介 旷文杰，资深 PHP 开发，曾就职于阿里巴巴旗下美妆电商平台。现在区块链领域深耕，在某区块链创业公司任技术经理，对以太坊智能合约有较深入的研究。热爱技术交流，常在个人博客上分享技术心得。 课程内容 第01课：理解以太坊相关概念 2009年比特币开创了去中心化加密货币的先河，同时也诞生了具有划时代意义的区块链技术。分布式数据存储、点对点传输、共识机制、加密算法等计算机技术组成了新型应用模式。然而比特币也并不完美，它只能当作支付手段，无法围绕它建立应用生态。所以业内称比特币为区块链1.0。 2013年，俄罗斯90后 Vitalik Buterin 在基于比特币的区块链技术基础之上，提出了以太坊平台。一个开源的、图灵完备的、有智能合约功能的、下一代加密货币与去中心化应用平台。 经过近五年的时间发展，以太坊已经成为业内公认的最好的公链之一，围绕它的生态建设已经初具规模。我们称之为区块链2.0。 本达人课基于以太坊平台，快速带领大家学习以太坊智能合约的开发，并掌握去中心化应用的开发、编译、部署的完整过程。在开始之前，本篇将以通俗易懂的方式介绍以太坊开发中涉及到的相关概念，带领大家轻松入门。 以太坊 以太坊（Ethereum）是一个建立在区块链技术之上的、图灵完备的去中心化应用平台。它允许任何人在平台中通过智能合约技术开发、部署和使用去中心化应用。 有没有感到和 iOS、Android 平台有点类似？ 在区块链1.0时代，我们如果需要编写区块链应用需要先从 Github 上 Download 一份比特币源码，然后修改底层代码如网络协议、共识机制、加密算法等等，再发布到网络中。2013、2014年的很多山寨币就是这样产生的，改一改比特币的代码，甚至是调整其中的某些参数就造出了一个新的应用、新的币种。 而以太坊平台，是对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，开发者只需专注于应用本身，而不用关注底层技术的具体实现，从而大大降低了难度。我们可以简单的理解，以太坊平台提供了很多模块让用户来搭建应用。如果将搭建应用比作造房子，那么以太坊就提供了地基、墙面、屋顶、地板等模块。用户只需像搭积木一样就可以把房子搭起来，而且房子的布局、装饰等等都是可以随意组装的。因此，在以太坊平台上可以快速建立去中心化应用，并且成本也更低。 目前围绕以太坊已经形成了一个较为完善的开发生态圈：社区支持、开发框架、开发工具等等。 以太坊客户端（节点） 一个以太坊客户端就是一个以太坊节点。它提供账户管理、数字资产管理、挖矿、转账、智能合约的部署和执行等等功能。对于我们开发者来说，它就是一个开发者工具。 需要注意的是，在区块链网络中是没有中心服务器的。所有以太坊节点组成了以太坊的整个区块链网络，每个节点都在无时无刻同步区块数据。 如上图所示（图片来自网络），左边是去中心化的网络，右边是中心化网络。我们举个不恰当的例子来加深理解。在浏览器——服务器架构中，服务器是中心化的，所有的动态数据都保存在服务器端。如果服务器发生故障，则所有的浏览器端都无法正常访问应用。而在区块链的去中心化网络中，所有的节点都会保存相同的数据，任意节点发生故障，都不影响整个区块链数据的写入与读取。 Geth 是典型的以太坊客户端。Geth 这个名字是 Go Ethereum 开源项目的简称。它是基于 Go 语言开发且实现了 Ethereum 协议的客户端软件。 Geth 提供了一个交互式命令控制台，通过命令来操作以太坊的各种功能（API）。 Geth 会一直同步以太坊区块链上的所有数据。目前 fast 同步模式下，数据量已经有近 70G；full 同步模式下，已经达到了几百 G。 在开发过程中，我们推荐使用以太坊区块链的私有链 Ganache （只有几百 M），免去同步以太坊全部区块数据的麻烦。在后续的文章中会介绍 Ganache。 账户 以太坊中账户分为两类： 外部账户（EOA） 该类账户被公钥——私钥对控制（用户），没有关联任何代码。 外部账户的地址由公钥衍生而来。 合约账户（CA） 该类账户为智能合约分配的账户，被合约代码控制且有代码与之关联。 智能合约的部署会把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址就是合约账户。 合约账户存储了代码，外部账户则没有。除了这点之外，这两类账户对于以太坊虚拟机（EVM）来说都是一样的。 如上图所示，外部账户与外部账户之间交易仅仅是转账。但是外部账户到合约账户，是可以激活各种操作的。 智能合约 网络上关于智能合约的解释都很晦涩。我们可以简单的理解为在区块链上，由事件驱动、以代码形式存在、可执行的特殊交易合同。它是代码与数据的集合，是以太坊的核心。 智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等场景。同时，智能合约在其他行业中的应用场景同样值得期待。 目前除数字货币之外，真正落地的应用还不多，业内各方都在积极探索使用场景和可落地应用。和移动互联网刚兴起之时，各行各业的 App 如雨后春笋般爆发一样，去中心化应用的市场在初期肯定有一个红利期。大家可抓住这波机会。 Solidity Solidity 是一门和 JavaScript 类似的编程语言，文件扩展名以 .sol 结尾。它用于智能合约的开发，并能编译成以太坊虚拟机（EVM）字节码，部署到以太坊底层区块链网络上。 以太坊虚拟机（EVM） EVM 即以太坊虚拟机，全称是 Ethereum Virtual Machine。它是以太坊智能合约的运行环境。 EVM 是由以太坊节点提供。每个以太坊节点中都包含 EVM。 Solidity 之于 EVM，就像 Java 跟 JVM 的关系一样。 以太坊虚拟机是一个隔离的环境，在 EVM 内部运行的代码跟外部没有联系。 EVM 运行在以太坊节点上，当我们把合约部署到以太坊区块链网络上之后，合约就可以在以太坊网络中运行了。 合约编译 以太坊虚拟机上运行的是合约的字节码，类似于汇编语言。这就需要我们在部署之前先对合约进行编译，转换成字节码。 推荐使用 solc 编译器。 合约部署 合约部署就是将编译好的合约字节码，通过外部账号以发送交易的形式部署到以太坊区块链网络上。由实际矿工出块之后，才会真正部署成功。 合约运行 合约部署后，当需要调用这个智能合约的方法时，只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在 EVM 中执行了。 Gas Gas 即矿工费。以太坊上每笔交易的执行（被矿工打包）都会被收取一定数量的 Gas。Gas的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发一个 out of gas 异常。当前调用帧所做的所有状态修改都将被回滚。如果执行结束，还有gas剩余，这些 Gas 将会返还给发送账户。因此，我们需要一个有以太币余额的外部账户，来为发起的交易支付 Gas。 如果没有这个限制，就会出现无法停止（如：死循环）的合约来阻塞以太坊区块链网络。 Gas 可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量、类型、占用的内存等等），所需的 Gas 就越多。Gas 的最小单位是 wei: 1eth=$10^{18}$wei=$10^{9}$gwei GasLimit：愿意支付矿工费的上限。 GasPrice：矿工费单价。 gas = GasLimit * GasPrice 去中心化应用（DApp） DApp 全称是 Decentralized App。以太坊社区把基于智能合约的应用称为去中心化的应用。如果我们把区块链理解为一个不可篡改的分布式账本数据库，智能合约理解为和数据库打交道的程序，那就很容易理解 DApp 了。一个 DApp 不单单有智能合约，还需要有一个友好的用户界面和其他的业务程序。在接下来的课程中，我们将实战开发一个简单的DApp。 Truffle Truffle 是目前最流行的 DApp 开发框架，它可以帮我们处理掉很多繁琐的事情，让我们更专注于智能合约的开发，迅速开始编码 -&gt; 编译 -&gt; 部署 -&gt; 测试 -&gt; 打包 DApp 的流程。 总结 最后我们来简单总结一下。以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用。应用中，我们可以使用 Solidity 来编写和区块链交互的智能合约，合约编写好之后，我们通过一个有余额的外部账户将合约部署到以太坊节点上，并运行合约（使用 Truffle 框架可以更好的帮助我们做这些事情）。 本篇中以太坊的这些概念，初次接触者对它们有一个基本的了解即可，没有必要把每一个概念都掌握的很细致、准确。学习是一个循序渐进、逐步深入的过程，很多时候，我们会发现过了一段时间后，对于同一个概念，会有不一样的理解与认知。 第02课：搭建开发环境 在正式开始以太坊智能合约的开发之前，我们需要先做好准备工作，包括相关环境的搭建、IDE 的选择等等，才能让我们的开发之旅得心应手。 操作系统 推荐使用 MacOS 或 Linux 系统。谨慎使用 Windows 来开发智能合约，可能会遇到很多奇葩的问题。本课程所有文章中的运行环境都是基于 MacOS 系统。 IDE 支持 Solidity 语法 工欲善其事，必先利于器。在使用 Solidity 语言 开始编写智能合约之前，需要一款得心应手的 IDE。本篇推荐使用 Atom 或是 IntelliJ IDEA 系列的 WebStorm。下面分别介绍它们如何安装支持 Solidity 语法的插件。 Atom 打开 Preferences - Install 操作面板，在右边的搜索框中输入“solidity”后点击 Packages 按钮进行搜索： 从图中可以看到，搜索结果页中 linter-solidity 和 autocomplete-solidity 两个插件的下载次数特别多。linter-solidity 插件用于 Solidity 语法高亮，autocomplete-solidity 插件用于 Solidity 语法的自动补全。我们分别点击 install 按钮来安装这两个插件，Atom 会自动下载并安装，重启 Atom 后即可看到效果（友情提示：翻墙后，两个插件下载会更快）。 Webstorm 接下来介绍在 Webstorm 中如何安装支持 Solidity 语法高亮的插件。打开 Preferences - Plugins 面板： 按图所示，在右边搜索框内输入“solidity”，并点击 Search in repositories。接下来就会看到我们需要用的插件 Intellij-Solidity： 选中 Intellij-Solidity 插件，点击右边面板中的 install 按钮，WebStorm 就开始下载插件并自动安装。重启 WebStorm 之后即生效。需要注意的是，此插件只支持 Solidity 语法高亮，并不支持语法自动补全。 安装 Node 智能合约的开发语言 Solidity 是类似于 Javascript 的一门语言。同时，后面我们需要用到的 Truffle 快速开发框架也是基于 Javascript。所以，我们需要安装好 Node 环境。打开 Node 中文网 并下载相应的安装包： 按提示步骤即可安装成功。本课程所有文章的 Node 环境都是基于如下版本： $ node -vv8.9.0$ npm -v5.5.1 节点工具 Ganache 上一篇我们有提到 Geth 节点工具。不过 Geth 会一直同步以太坊区块链上的所有数据。目前 fast 同步模式下，数据量已经有近70G；full 同步模式下，已经达到了几百G。在开发过程中，它会消耗大量的磁盘空间及时间来进行同步操作。所以，我们推荐在开发中使用 Ganache。 Ganache只有几百 M 大小，可以快速启动个人以太坊区块链，并可以使用它来运行测试，执行命令、检查状态，同时控制链条的运行方式。 安装 打开 Ganache 官网，并点击 DOWNLOAD 按钮： 下载完后，直接按提示即可安装成功。打开后的界面如图所示： 可以看到 ACCOUNTS 面板里已经生成了10个账户可用。每个账户里都有100枚 ETH。 Ganache 特征 通过 Ganache，我们可以： 快速查看所有账户的当前状态，包括他们的地址、私钥、交易和余额； 查看 Ganache 内部区块链的日志输出，包括响应和其他重要的调试信息 检查所有块和交易，以获取相关问题的信息 需要注意的是，Ganache每次重启，都会将数据还原到初始状态。 以下是 Ganache 的几个重要面板的截图： Infura 在智能合约开发完，通过 Ganache 部署成功并进行了初步校验后，我们需要将合约部署到 Ropsten 测试网，及 Mainnet 主网。这里我们推荐使用 Infura。 Infura 提供了托管的以太坊节点，不再需要我们消耗大量的磁盘空间和时间来搭建本地节点。同时，它为我们的 DApp 应用提供了以太坊节点支持，我们通过 API 和开发人员工具就可以安全、可靠和可扩展的访问以太坊节点。目前已经为9000多名开发人员和 DApp 应用提供以太坊节点服务。 申请节点访问 URL 我们在浏览器上打开 https://infura.io/signup （需翻墙），填写一些资料后即可免费申请 Infura 的以太坊节点访问 URL： 填写完你的姓名、邮箱地址，并进行了人机校验后，点击 Submit 按钮提交信息，Infura 就为你分配了各个网络的以太坊节点访问 URL（红框处）： 需要注意的是，Infura 并不会帮你保存这些信息，你需要手动复制并在本地保存。一旦丢失或忘记，是找不回这些信息的，只能重新申请。 至此，我们的开发环境就准备好了，下一篇文章就正式开始动手编写智能合约了。 第03课：Hello world 合约开发 绝大部分开发者学习一门语言的时候，都是从输出一个 Hello World 开始。我们也从实现一个 Hello World 合约为切入点，开始进入智能合约的世界吧。 环境准备 前面已经介绍了 Node 和 npm 的安装。本系列文章依赖的环境版本： Node：v8.9.0 Npm：5.5.1 接下来，在你的代码目录里，创建名为 smartcontract 的文件夹，并创建如下两个文件 package.json 、Hello.sol 。 smartcontract ├── Hello.sol └── package.json 在 package.json 文件里，添加如下依赖包配置： { &quot;name&quot;: &quot;smartcontract&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;dependencies&quot;: { &quot;fs&quot;: &quot;0.0.1-security&quot;, &quot;solc&quot;: &quot;^0.4.21&quot;, &quot;web3&quot;: &quot;^0.20.0&quot; }} fs 模块用于文件的相关操作； solc 模块是编译器； web3 模块是以太坊提供的工具包，主要用于与合约的通信。 接下来执行 npm install 下载相关的依赖包。 编写合约代码 环境准备好后，就可以开始编写合约代码了。 打开 Hello.sol 文件，编写代码如下： //pragma关键字：版本申明。//用来指示编译器将代码编译成特定版本，以免引起兼容性问题//此处不支持0.4.0之前的编译器，也不支持0.5.0之后的编译器（条件为 ^）pragma solidity ^0.4.0;//contract关键字：合约申明//和Java、PHP中的class类似//此处是申明一个名为Hello的合约contract Hello { //public: 函数访问属性(后续文章为详细阐述) //returns (string): 定义返回值类型为string function say(string name) public returns (string) { return name; }} 代码很简单。就是实现了用户输入什么字符串，合约就原样返回的操作。 接下来，我们需要编写合约部署脚本。 合约部署脚本 在 smartcontract 目录下，新建名为 deploy.js 的文件。代码如下： //设置web3连接var Web3 = require(&#39;web3&#39;);//http://localhost:7545 为Ganache提供的节点链接var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取合约var fs = require(&#39;fs&#39;);var contractCode = fs.readFileSync(&#39;Hello.sol&#39;).toString();//编译合约代码var solc = require(&#39;solc&#39;);var compileCode = solc.compile(contractCode);console.log(compileCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;:Hello&#39;].interface);var byteCode = compileCode.contracts[&#39;:Hello&#39;].bytecode;//创建合约对象var VotingContract = web3.eth.contract(abi);//部署合约，并返回部署对象var deployedContract = VotingContract.new({ data:byteCode, from:web3.eth.accounts[0], //部署合约的外部账户地址 gas:750000 //部署合约的矿工费});console.log(deployedContract); 代码里我加上了简单的注释。这里解释一下 abi 这个概念。 abi 全称是 Application Binary Interface，即应用程序二进制接口。简单的说，就是合约对外的接口描述。 需要注意的是，矿工费 Gas 为750000。以太坊上每笔交易的执行（被矿工打包）都会被收取一定数量的 Gas。Gas 的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发一个 out of gas 异常。当前调用帧所做的所有状态修改都将被回滚。如果执行结束，还有Gas剩余，这些 Gas 将会返还给发送账户。因此，如果部署时抛出 out of gas 的异常，我们可适当的提高 Gas 值。 合约部署 在当前目录下，执行 node deploy.js 命令。我们在部署脚本里将 compileCode 变量打印出来了，粗略看看就行： { contracts: { &#39;:Hello&#39;: { assembly: [Object], bytecode: &#39;6060604052341561000f57600080fd5b61016c8061001e6000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063d5c6130114610046575b600080fd5b341561005157600080fd5b6100a1600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061011c565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100e15780820151818401526020810190506100c6565b50505050905090810190601f16801561010e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61012461012c565b819050919050565b6020604051908101604052806000815250905600a165627a7a72305820ff14cafd1df21e1edf19eff7598bc82a98940cc0fe045d6107d04bb224014f990029&#39;, functionHashes: [Object], gasEstimates: [Object], interface: &#39;[{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;name&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;name&quot;:&quot;say&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;}]&#39;, metadata: &#39;{&quot;compiler&quot;:{&quot;version&quot;:&quot;0.4.21+commit.dfe3193c&quot;},&quot;language&quot;:&quot;Solidity&quot;,&quot;output&quot;:{&quot;abi&quot;:[{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;name&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;name&quot;:&quot;say&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;}],&quot;devdoc&quot;:{&quot;methods&quot;:{}},&quot;userdoc&quot;:{&quot;methods&quot;:{}}},&quot;settings&quot;:{&quot;compilationTarget&quot;:{&quot;&quot;:&quot;Hello&quot;},&quot;evmVersion&quot;:&quot;byzantium&quot;,&quot;libraries&quot;:{},&quot;optimizer&quot;:{&quot;enabled&quot;:false,&quot;runs&quot;:200},&quot;remappings&quot;:[]},&quot;sources&quot;:{&quot;&quot;:{&quot;keccak256&quot;:&quot;0x2e3dd18fbfbd17bb4f866b1bfbb38082172a0bb58d9396b63bab04e67d9d8e08&quot;,&quot;urls&quot;:[&quot;bzzr://d1aae746dfab03e712d8a3cb76b7d4b5bf60f48fafbffa04dfa8a2d53ad5d0ca&quot;]}},&quot;version&quot;:1}&#39;, opcodes: &#39;PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x16C DUP1 PUSH2 0x1E PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x41 JUMPI PUSH1 0x0 CALLDATALOAD PUSH29 0x100000000000000000000000000000000000000000000000000000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0xD5C61301 EQ PUSH2 0x46 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE ISZERO PUSH2 0x51 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xA1 PUSH1 0x4 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP3 ADD DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP POP SWAP2 SWAP1 POP POP PUSH2 0x11C JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0xE1 JUMPI DUP1 DUP3 ADD MLOAD DUP2 DUP5 ADD MSTORE PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH2 0xC6 JUMP JUMPDEST POP POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x10E JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x124 PUSH2 0x12C JUMP JUMPDEST DUP2 SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x0 DUP2 MSTORE POP SWAP1 JUMP STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 SELFDESTRUCT EQ 0xca REVERT SAR CALLCODE 0x1e 0x1e 0xdf NOT 0xef 0xf7 MSIZE DUP12 0xc8 0x2a SWAP9 SWAP5 0xc 0xc0 INVALID DIV 0x5d PUSH2 0x7D0 0x4b 0xb2 0x24 ADD 0x4f SWAP10 STOP 0x29 &#39;, runtimeBytecode: &#39;606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063d5c6130114610046575b600080fd5b341561005157600080fd5b6100a1600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061011c565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100e15780820151818401526020810190506100c6565b50505050905090810190601f16801561010e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61012461012c565b819050919050565b6020604051908101604052806000815250905600a165627a7a72305820ff14cafd1df21e1edf19eff7598bc82a98940cc0fe045d6107d04bb224014f990029&#39;, srcmap: &#39;25:102:0:-;;;;;;;;;;;;;;;;;&#39;, srcmapRuntime: &#39;25:102:0:-;;;;;;;;;;;;;;;;;;;;;;;;47:78;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;23:1:-1;8:100;33:3;30:1;27:10;8:100;;;99:1;94:3;90:11;84:18;80:1;75:3;71:11;64:39;52:2;49:1;45:10;40:15;;8:100;;;12:14;47:78:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;89:6;;:::i;:::-;114:4;107:11;;47:78;;;:::o;25:102::-;;;;;;;;;;;;;;;:::o&#39; } }, errors: [ &#39;:5:5: Warning: Function state mutability can be restricted to pure\\n function say(string name) public returns (string) {\\n ^ (Relevant source part starts here and spans across multiple lines).\\n&#39; ], sourceList: [ &#39;&#39; ], sources: { &#39;&#39;: { AST: [Object] } } } 打开 Ganache 的 LOGS 面板，可以看到部署产生的交易（Transaction）日志： 箭头所指就是部署成功后的合约地址：0xbf474d24ba8b19811db5deb51137ddccbe3ff288（每个人部署后的地址可能都不相同）。 我们记录下来，后面的合约调用代码里需要用到。同时，也可以打开 ACCOUNTS 面板，观察账户余额的变化。 合约调用 合约部署成功之后，我们写一段代码来调用合约里的 say() 方法，检测一下效果。在 smartcontract 目录下，新建名为 run.js 的文件，代码如下： //设置web3连接var Web3 = require(&#39;web3&#39;);//http://localhost:7545 为Ganache提供的节点链接var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取合约var fs = require(&#39;fs&#39;);var contractCode = fs.readFileSync(&#39;Hello.sol&#39;).toString();//编译合约代码var solc = require(&#39;solc&#39;);var compileCode = solc.compile(contractCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;:Hello&#39;].interface);var byteCode = compileCode.contracts[&#39;:Hello&#39;].bytecode;//创建合约对象var VotingContract = web3.eth.contract(abi);//0xbf474d24ba8b19811db5deb51137ddccbe3ff288为合约部署地址var contractInstance = VotingContract.at(&quot;0xbf474d24ba8b19811db5deb51137ddccbe3ff288&quot;);var result = contractInstance.say.call(&#39;Hello world&#39;);console.log(result); 我们来执行 node run.js 命令，可以看到在终端里输出了 Hello world 。 字符串拼接 我们可以扩展一下。如果我们事先在合约里定义好 Hello 字符串，如何与 name 变量进行字符串拼接？ 在智能合约里进行字符串的拼接可不是一件简单的事情。我们先用绝大部分编程语言都通用的连接符 + 和 . 来尝试着修改代码： //pragma关键字：版本申明。//用来指示编译器将代码编译成特定版本，以免引起兼容性问题//此处不支持0.4.0之前的编译器，也不支持0.5.0之后的编译器（条件为 ^）pragma solidity ^0.4.0;//contract关键字：合约申明//和Java、PHP中的class类似//此处是申明一个名为Hello的合约contract Hello { string str=&quot;Hello &quot;; //public: 函数访问属性(后续文章为详细阐述) //returns (string): 定义返回值类型为string function say(string name) public returns (string) { return str + name; }} 运行 node deploy.js 部署脚本后，抛出了一个异常： TypeError: Operator + not compatible with types string storage ref and string memory return str + name; 我们将其修改为“.”并尝试部署后，也抛出一个异常： TypeError: Member &quot;name&quot; not found or not visible after argument-dependent lookup in string storage ref return str . name; 说明在智能合约里，“+”和“.”都不是连接符。通过查阅 Solidity 官方文档，我们发现 Solidity 语言并不提供字符串连接符的语法： 那有没有其他方式，可以实现字符串的拼接功能呢？ 以太坊核心开发团队已经为其提供了字符串的扩展类。从 strings.sol 处下载字符串工具合约，保存到 smartcontract 目录中： smartcontract ├── Hello.sol ├── deploy.js ├── node_modules ├── package.json ├── run.js └── strings.sol 修改 Hello.sol 代码： pragma solidity ^0.4.0;//导入 strings.sol 工具合约import &quot;./strings.sol&quot;; //注意这里contract Hello { //将 strings 工具合约用于所有数据类型 using strings for *; //注意这里 string str=&quot;Hello &quot;; function say(string name) public returns (string) { return str.toSlice().concat(name.toSlice()); }} 运行部署脚本 node deploy.js 后，抛出一个异常： ParserError: Source &quot;strings.sol&quot; not found: File not supplied initially. import &quot;./strings.sol&quot; 提示 strings.sol 文件找不到，这并不是合约代码有问题，而是 solc 编译器 的问题。 solc 编译器 目前不支持关联文件的自动引入。我们期望编译器以更智能的方式引入关联的文件，但是这意味着它至少需要 fs 模块，而 fs 模块反过来又增加了 solc 模块的大小，同时也增加了不必要的依赖。 所以，我们需要修改部署脚本文件 deploy.js 的代码： //设置web3连接var Web3 = require(&#39;web3&#39;);var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取strings.sol和hello.sol两个合约 var fs = require(&#39;fs&#39;);var contractCode = { //注意这里的变化 &quot;strings.sol&quot;:fs.readFileSync(&#39;strings.sol&#39;).toString(), &quot;Hello.sol&quot;:fs.readFileSync(&#39;Hello.sol&#39;).toString()};//编译合约代码var solc = require(&#39;solc&#39;);var compileCode = solc.compile({ //注意这里的变化 sources:contractCode},1);console.log(compileCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;Hello.sol:Hello&#39;].interface); //注意这里的变化var byteCode = compileCode.contracts[&#39;Hello.sol:Hello&#39;].bytecode; //注意这里的变化//创建合约对象var VotingContract = web3.eth.contract(abi);//部署合约，并返回部署对象var deployedContract = VotingContract.new({ data:byteCode, from:web3.eth.accounts[0], gas:750000});console.log(deployedContract); 读取 strings.sol 和 Hello.sol 两个合约文件，并一同编译即可。再次执行 node deploy.js 命令，合约部署成功。记录下合约地址：0x58a73dea66cea789dcfb5b4a94b7247ca010b781（每个人执行的合约地址可能都不相同）。 同时，合约调用脚本 run.js 的代码修改部分和 deploy.js 相同： //设置web3连接var Web3 = require(&#39;web3&#39;);var web3 = new Web3(new Web3.providers.HttpProvider(&#39;http://localhost:7545&#39;));//读取strings.sol和hello.sol两个合约 var fs = require(&#39;fs&#39;);var contractCode = { &quot;strings.sol&quot;:fs.readFileSync(&#39;strings.sol&#39;).toString(), //注意这里的变化 &quot;Hello.sol&quot;:fs.readFileSync(&#39;Hello.sol&#39;).toString() //注意这里的变化};//编译合约代码成字节码var solc = require(&#39;solc&#39;);var compileCode = solc.compile({ //注意这里的变化 sources:contractCode},1);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[&#39;Hello.sol:Hello&#39;].interface); //注意这里的变化var byteCode = compileCode.contracts[&#39;Hello.sol:Hello&#39;].bytecode; //注意这里的变化//创建合约对象var VotingContract = web3.eth.contract(abi);var contractInstance = VotingContract.at(&quot;0x58a73dea66cea789dcfb5b4a94b7247ca010b781&quot;);var result = contractInstance.say.call(&#39;world&#39;);console.log(result);console.log(contractInstance.say.call(&#39;Guys&#39;)); 执行脚本后，可以看到终端打印出了两行字符串： Hello world Hello Guys strings.sol 工具合约中还提供了字符串的比较、查找、切割等方法，大家可以动手尝试。本篇不做过多介绍。 至此，第一个智能合约 Hello world 的代码编写、编译、部署、 调用的过程就完成了。建议大家动手执行一遍，加深理解。 第04课：Truffle 构建 DApp 应用 第05课：部署合约到 Ropsten 测试网和主网 第06课：Solidity 详解 第07课：去中心化投票 DApp 的开发 第08篇：ERC20 代币发行 第09课：实现代币的增发、冻结等高级功能 阅读全文: http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2018/07/03/14aa094283c1435c3f84293e34b0cc8c.html","headline":"一起学：以太坊智能合约开发","dateModified":"2018-07-03T00:00:00+08:00","datePublished":"2018-07-03T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2018/07/03/14aa094283c1435c3f84293e34b0cc8c.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>一起学：以太坊智能合约开发</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h4><strong>课程介绍</strong></h4>
  <p>无论在科技圈还是金融圈，“区块链”俨然成了最热的词汇。2016年，区块链写入了国家的十三五规划中；2017年，央行基于区块链技术的数字票据交易平台测试成功；同年，工信部发布了首个区块链参考架构标准。 经过2017年如火如荼的投资盛宴，区块链开始逐渐走向应用落地，业内都在积极探索使用场景。如金融领域的资产贸易、支付系统、金融服务，其他领域的电子商务、社交通讯、游戏娱乐等等。同时，BAT、迅雷、小米、网易等互联网龙头企业纷纷加入研发队伍中。 正如移动互联网兴起之时一样，区块链 DApp 应用市场初期肯定会有一波红利期。对此有兴趣的开发者，不可错过。</p>
  <p> 以太坊是现阶段业内生态最好的公链，本达人课的内容将基于以太坊平台，共包含四大部分： </p>
  <p>第一部分（第01-02课）介绍以太坊相关概念及开发环境的准备，包括以太坊节点、EVM 虚拟机、Gas 机制及开发测试用的私有链 Ganache。</p>
  <p> 第二部分（第03-05课）从编写简单的 Hello world 合约入手，学习智能合约的开发、编译、部署及网页与智能合约的交互，并学习通过 Truffle 开发框架快速构建 DApp 应用，及如何将合约部署到 Ropsten 测试网和主网。</p>
  <p> 第三部分（第06-07课）通过详细学习 Solidity 语法，实现一个去中心化的投票 DApp，加深对智能合约开发的理解与应用，全方位提升你的技术实力与思维方式。 </p>
  <p>第四部分（第08-09课）对去年火热的 ICO 代币发行进行技术上的解读，分析 ERC20 合约代码，并实现代币的增发、兑换、冻结等高级功能。</p>
  <h4><strong>作者简介</strong></h4>
  <p>旷文杰，资深 PHP 开发，曾就职于阿里巴巴旗下美妆电商平台。现在区块链领域深耕，在某区块链创业公司任技术经理，对以太坊智能合约有较深入的研究。热爱技术交流，常在个人博客上分享技术心得。</p>
  <h4><strong>课程内容</strong></h4>
  <h5><strong>第01课：理解以太坊相关概念</strong></h5>
  <p>2009年比特币开创了去中心化加密货币的先河，同时也诞生了具有划时代意义的区块链技术。分布式数据存储、点对点传输、共识机制、加密算法等计算机技术组成了新型应用模式。然而比特币也并不完美，它只能当作支付手段，无法围绕它建立应用生态。所以业内称比特币为区块链1.0。</p>
  <p>2013年，俄罗斯90后 Vitalik Buterin 在基于比特币的区块链技术基础之上，提出了以太坊平台。一个开源的、图灵完备的、有智能合约功能的、下一代加密货币与去中心化应用平台。 经过近五年的时间发展，以太坊已经成为业内公认的最好的公链之一，围绕它的生态建设已经初具规模。我们称之为区块链2.0。</p>
  <p>本达人课基于以太坊平台，快速带领大家学习以太坊智能合约的开发，并掌握去中心化应用的开发、编译、部署的完整过程。在开始之前，本篇将以通俗易懂的方式介绍以太坊开发中涉及到的相关概念，带领大家轻松入门。</p>
  <h3>以太坊</h3>
  <p>以太坊（Ethereum）是一个建立在区块链技术之上的、图灵完备的去中心化应用平台。它允许任何人在平台中通过智能合约技术开发、部署和使用去中心化应用。</p>
  <blockquote> 
   <p>有没有感到和 iOS、Android 平台有点类似？</p>
  </blockquote>
  <p>在区块链1.0时代，我们如果需要编写区块链应用需要先从 Github 上 Download 一份比特币源码，然后修改底层代码如网络协议、共识机制、加密算法等等，再发布到网络中。2013、2014年的很多山寨币就是这样产生的，改一改比特币的代码，甚至是调整其中的某些参数就造出了一个新的应用、新的币种。</p>
  <p>而以太坊平台，是对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，开发者只需专注于应用本身，而不用关注底层技术的具体实现，从而大大降低了难度。我们可以简单的理解，以太坊平台提供了很多模块让用户来搭建应用。如果将搭建应用比作造房子，那么以太坊就提供了地基、墙面、屋顶、地板等模块。用户只需像搭积木一样就可以把房子搭起来，而且房子的布局、装饰等等都是可以随意组装的。因此，在以太坊平台上可以快速建立去中心化应用，并且成本也更低。</p>
  <blockquote> 
   <p>目前围绕以太坊已经形成了一个较为完善的开发生态圈：社区支持、开发框架、开发工具等等。</p>
  </blockquote>
  <h4>以太坊客户端（节点）</h4>
  <p>一个以太坊客户端就是一个以太坊节点。它提供账户管理、数字资产管理、挖矿、转账、智能合约的部署和执行等等功能。对于我们开发者来说，它就是一个开发者工具。</p>
  <p>需要注意的是，在区块链网络中是没有中心服务器的。所有以太坊节点组成了以太坊的整个区块链网络，每个节点都在无时无刻同步区块数据。</p>
  <p><img src="http://images.gitbook.cn/a3811dc0-4794-11e8-bf94-13531a9dca90" alt="enter image description here"></p>
  <p>如上图所示（图片来自网络），左边是去中心化的网络，右边是中心化网络。我们举个不恰当的例子来加深理解。在浏览器——服务器架构中，服务器是中心化的，所有的动态数据都保存在服务器端。如果服务器发生故障，则所有的浏览器端都无法正常访问应用。而在区块链的去中心化网络中，所有的节点都会保存相同的数据，任意节点发生故障，都不影响整个区块链数据的写入与读取。</p>
  <p><strong>Geth</strong> 是典型的以太坊客户端。Geth 这个名字是 Go Ethereum 开源项目的简称。它是基于 Go 语言开发且实现了 Ethereum 协议的客户端软件。</p>
  <p>Geth 提供了一个交互式命令控制台，通过命令来操作以太坊的各种功能（API）。</p>
  <blockquote> 
   <p>Geth 会一直同步以太坊区块链上的所有数据。目前 fast 同步模式下，数据量已经有近 70G；full 同步模式下，已经达到了几百 G。</p>
  </blockquote>
  <p>在开发过程中，我们推荐使用以太坊区块链的私有链 <strong>Ganache</strong> （只有几百 M），免去同步以太坊全部区块数据的麻烦。在后续的文章中会介绍 Ganache。</p>
  <h4>账户</h4>
  <p>以太坊中账户分为两类：</p>
  <ul>
   <li><p>外部账户（EOA）</p>
    <blockquote> 
     <p>该类账户被公钥——私钥对控制（用户），没有关联任何代码。 外部账户的地址由公钥衍生而来。</p>
    </blockquote></li>
   <li><p>合约账户（CA）</p>
    <blockquote> 
     <p>该类账户为智能合约分配的账户，被合约代码控制且有代码与之关联。 智能合约的部署会把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址就是合约账户。</p>
    </blockquote></li>
  </ul>
  <p>合约账户存储了代码，外部账户则没有。除了这点之外，这两类账户对于以太坊虚拟机（EVM）来说都是一样的。</p>
  <p><img src="http://images.gitbook.cn/02970790-479d-11e8-890e-8950f84a2f8b" alt="账户"></p>
  <p>如上图所示，外部账户与外部账户之间交易仅仅是转账。但是外部账户到合约账户，是可以激活各种操作的。</p>
  <h3>智能合约</h3>
  <p>网络上关于智能合约的解释都很晦涩。我们可以简单的理解为在区块链上，由事件驱动、以代码形式存在、可执行的特殊交易合同。它是代码与数据的集合，是以太坊的核心。</p>
  <p>智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等场景。同时，智能合约在其他行业中的应用场景同样值得期待。</p>
  <p>目前除数字货币之外，真正落地的应用还不多，业内各方都在积极探索使用场景和可落地应用。和移动互联网刚兴起之时，各行各业的 App 如雨后春笋般爆发一样，去中心化应用的市场在初期肯定有一个红利期。大家可抓住这波机会。</p>
  <h3>Solidity</h3>
  <p>Solidity 是一门和 JavaScript 类似的编程语言，文件扩展名以 <strong>.sol</strong> 结尾。它用于智能合约的开发，并能编译成以太坊虚拟机（EVM）字节码，部署到以太坊底层区块链网络上。</p>
  <h3>以太坊虚拟机（EVM）</h3>
  <p>EVM 即以太坊虚拟机，全称是 Ethereum Virtual Machine。它是以太坊智能合约的运行环境。</p>
  <ul>
   <li>EVM 是由以太坊节点提供。每个以太坊节点中都包含 EVM。</li>
   <li>Solidity 之于 EVM，就像 Java 跟 JVM 的关系一样。</li>
   <li>以太坊虚拟机是一个隔离的环境，在 EVM 内部运行的代码跟外部没有联系。</li>
  </ul>
  <p>EVM 运行在以太坊节点上，当我们把合约部署到以太坊区块链网络上之后，合约就可以在以太坊网络中运行了。</p>
  <h4>合约编译</h4>
  <p>以太坊虚拟机上运行的是合约的字节码，类似于汇编语言。这就需要我们在部署之前先对合约进行编译，转换成字节码。</p>
  <blockquote> 
   <p>推荐使用 solc 编译器。</p>
  </blockquote>
  <h4>合约部署</h4>
  <p>合约部署就是将编译好的合约字节码，通过外部账号以发送交易的形式部署到以太坊区块链网络上。由实际矿工出块之后，才会真正部署成功。</p>
  <h4>合约运行</h4>
  <p>合约部署后，当需要调用这个智能合约的方法时，只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在 EVM 中执行了。</p>
  <h3>Gas</h3>
  <p>Gas 即矿工费。以太坊上每笔交易的执行（被矿工打包）都会被收取一定数量的 Gas。Gas的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发一个 <strong>out of gas</strong> 异常。当前调用帧所做的所有状态修改都将被回滚。如果执行结束，还有gas剩余，这些 Gas 将会返还给发送账户。因此，我们需要一个有以太币余额的外部账户，来为发起的交易支付 Gas。</p>
  <blockquote> 
   <p>如果没有这个限制，就会出现无法停止（如：死循环）的合约来阻塞以太坊区块链网络。</p>
  </blockquote>
  <p>Gas 可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量、类型、占用的内存等等），所需的 Gas 就越多。Gas 的最小单位是 wei:</p>
  <p>1eth=$10^{18}$wei=$10^{9}$gwei</p>
  <blockquote> 
   <p>GasLimit：愿意支付矿工费的上限。 GasPrice：矿工费单价。</p>
  </blockquote>
  <p>gas = GasLimit * GasPrice</p>
  <p><img src="http://images.gitbook.cn/176cc070-47a1-11e8-b473-a34c15316faa" alt="gas"></p>
  <h3>去中心化应用（DApp）</h3>
  <p>DApp 全称是 Decentralized App。以太坊社区把基于智能合约的应用称为去中心化的应用。如果我们把区块链理解为一个不可篡改的分布式账本数据库，智能合约理解为和数据库打交道的程序，那就很容易理解 DApp 了。一个 DApp 不单单有智能合约，还需要有一个友好的用户界面和其他的业务程序。在接下来的课程中，我们将实战开发一个简单的DApp。</p>
  <h4>Truffle</h4>
  <p>Truffle 是目前最流行的 DApp 开发框架，它可以帮我们处理掉很多繁琐的事情，让我们更专注于智能合约的开发，迅速开始<strong>编码</strong> -&gt; <strong>编译</strong> -&gt; <strong>部署</strong> -&gt; <strong>测试</strong> -&gt; <strong>打包 DApp</strong> 的流程。</p>
  <h3>总结</h3>
  <p>最后我们来简单总结一下。以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用。应用中，我们可以使用 Solidity 来编写和区块链交互的智能合约，合约编写好之后，我们通过一个有余额的外部账户将合约部署到以太坊节点上，并运行合约（使用 Truffle 框架可以更好的帮助我们做这些事情）。</p>
  <p>本篇中以太坊的这些概念，初次接触者对它们有一个基本的了解即可，没有必要把每一个概念都掌握的很细致、准确。学习是一个循序渐进、逐步深入的过程，很多时候，我们会发现过了一段时间后，对于同一个概念，会有不一样的理解与认知。</p>
  <h5><strong>第02课：搭建开发环境</strong></h5>
  <p>在正式开始以太坊智能合约的开发之前，我们需要先做好准备工作，包括相关环境的搭建、IDE 的选择等等，才能让我们的开发之旅得心应手。</p>
  <h3>操作系统</h3>
  <p>推荐使用 <strong>MacOS</strong> 或 <strong>Linux</strong> 系统。谨慎使用 Windows 来开发智能合约，可能会遇到很多奇葩的问题。本课程所有文章中的运行环境都是基于 <strong>MacOS</strong> 系统。</p>
  <h3>IDE 支持 Solidity 语法</h3>
  <p>工欲善其事，必先利于器。在使用 <strong>Solidity 语言</strong> 开始编写智能合约之前，需要一款得心应手的 IDE。本篇推荐使用 <strong>Atom</strong> 或是 IntelliJ IDEA 系列的 <strong>WebStorm</strong>。下面分别介绍它们如何安装支持 Solidity 语法的插件。</p>
  <h4>Atom</h4>
  <p>打开 <strong>Preferences - Install</strong> 操作面板，在右边的搜索框中输入“solidity”后点击 <strong>Packages</strong> 按钮进行搜索：</p>
  <p><img src="http://images.gitbook.cn/b1c92260-485c-11e8-a46c-5b5659f0694d" alt="Preferences - Install"></p>
  <p><img src="http://images.gitbook.cn/6f124a10-4860-11e8-bba9-7d40f1c7a26b" alt="install solidity plugins"></p>
  <p>从图中可以看到，搜索结果页中 <strong>linter-solidity</strong> 和 <strong>autocomplete-solidity</strong> 两个插件的下载次数特别多。<strong>linter-solidity</strong> 插件用于 <strong>Solidity</strong> 语法高亮，<strong>autocomplete-solidity</strong> 插件用于 <strong>Solidity</strong> 语法的自动补全。我们分别点击 <strong>install</strong> 按钮来安装这两个插件，Atom 会自动下载并安装，重启 Atom 后即可看到效果（<strong>友情提示</strong>：翻墙后，两个插件下载会更快）。</p>
  <p><img src="http://images.gitbook.cn/238549a0-4863-11e8-b266-d1e705a93725" alt="Solidity语法自动补全"></p>
  <h4>Webstorm</h4>
  <p>接下来介绍在 <strong>Webstorm</strong> 中如何安装支持 Solidity 语法高亮的插件。打开 <strong>Preferences</strong> - <strong>Plugins</strong> 面板：</p>
  <p><img src="http://images.gitbook.cn/0e8a8520-4876-11e8-bba9-7d40f1c7a26b" alt="Preferences - plugins面板"></p>
  <p>按图所示，在右边搜索框内输入“solidity”，并点击 <strong>Search in repositories</strong>。接下来就会看到我们需要用的插件 <strong>Intellij-Solidity</strong>：</p>
  <p><img src="http://images.gitbook.cn/290e8b80-4876-11e8-b9ff-f16cdfc76aff" alt="Intellij-Solidity"></p>
  <p>选中 <strong>Intellij-Solidity</strong> 插件，点击右边面板中的 <strong>install</strong> 按钮，WebStorm 就开始下载插件并自动安装。重启 WebStorm 之后即生效。需要注意的是，此插件只支持 Solidity 语法高亮，并不支持语法自动补全。</p>
  <h3>安装 Node</h3>
  <p>智能合约的开发语言 <strong>Solidity</strong> 是类似于 Javascript 的一门语言。同时，后面我们需要用到的 <strong>Truffle</strong> 快速开发框架也是基于 Javascript。所以，我们需要安装好 Node 环境。打开 <a href="http://nodejs.cn/download/" rel="nofollow">Node 中文网</a> 并下载相应的安装包：</p>
  <p><img src="http://images.gitbook.cn/9f017fd0-4896-11e8-b266-d1e705a93725" alt="Node"></p>
  <p>按提示步骤即可安装成功。本课程所有文章的 Node 环境都是基于如下版本：</p>
  <pre><code>$ node -vv8.9.0$ npm -v5.5.1</code></pre>
  <h3>节点工具 Ganache</h3>
  <p>上一篇我们有提到 <strong>Geth</strong> 节点工具。不过 Geth 会一直同步以太坊区块链上的所有数据。目前 fast 同步模式下，数据量已经有近70G；full 同步模式下，已经达到了几百G。在开发过程中，它会消耗大量的磁盘空间及时间来进行同步操作。所以，我们推荐在开发中使用 Ganache。</p>
  <p>Ganache只有几百 M 大小，可以快速启动个人以太坊区块链，并可以使用它来运行测试，执行命令、检查状态，同时控制链条的运行方式。</p>
  <h4>安装</h4>
  <p>打开 <a href="http://truffleframework.com/ganache/" rel="nofollow">Ganache 官网</a>，并点击 <strong>DOWNLOAD</strong> 按钮：</p>
  <p><img src="http://images.gitbook.cn/5d681610-48f5-11e8-ad1e-d1386429f0d8" alt="下载"></p>
  <p>下载完后，直接按提示即可安装成功。打开后的界面如图所示：</p>
  <p><img src="http://images.gitbook.cn/68790870-48f5-11e8-b790-016dbce67732" alt="安装成功"></p>
  <p>可以看到 <strong>ACCOUNTS</strong> 面板里已经生成了10个账户可用。每个账户里都有100枚 ETH。</p>
  <h4>Ganache 特征</h4>
  <p>通过 Ganache，我们可以：</p>
  <ul>
   <li>快速查看所有账户的当前状态，包括他们的地址、私钥、交易和余额；</li>
   <li>查看 Ganache 内部区块链的日志输出，包括响应和其他重要的调试信息</li>
   <li>检查所有块和交易，以获取相关问题的信息</li>
  </ul>
  <p>需要注意的是，Ganache每次重启，都会将数据还原到初始状态。</p>
  <p>以下是 Ganache 的几个重要面板的截图：</p>
  <p><img src="http://images.gitbook.cn/d93d4580-63b2-11e8-b82b-ffbb9d1e8856" alt="区块面板"></p>
  <p><img src="http://images.gitbook.cn/e77b5bf0-63b2-11e8-b82c-e1d608026a45" alt="交易面板"></p>
  <p><img src="http://images.gitbook.cn/f46442a0-63b2-11e8-b82c-e1d608026a45" alt="日志面板"></p>
  <h3>Infura</h3>
  <p>在智能合约开发完，通过 Ganache 部署成功并进行了初步校验后，我们需要将合约部署到 Ropsten 测试网，及 Mainnet 主网。这里我们推荐使用 <strong>Infura</strong>。</p>
  <p><strong>Infura</strong> 提供了托管的以太坊节点，不再需要我们消耗大量的磁盘空间和时间来搭建本地节点。同时，它为我们的 DApp 应用提供了以太坊节点支持，我们通过 API 和开发人员工具就可以安全、可靠和可扩展的访问以太坊节点。目前已经为9000多名开发人员和 DApp 应用提供以太坊节点服务。</p>
  <h4>申请节点访问 URL</h4>
  <p>我们在浏览器上打开 <a href="https://infura.io/signup" rel="nofollow">https://infura.io/signup</a> （需翻墙），填写一些资料后即可免费申请 Infura 的以太坊节点访问 URL：</p>
  <p><img src="http://images.gitbook.cn/4421b770-4903-11e8-b790-016dbce67732" alt="申请"></p>
  <p>填写完你的姓名、邮箱地址，并进行了人机校验后，点击 <strong>Submit</strong> 按钮提交信息，Infura 就为你分配了各个网络的以太坊节点访问 URL（红框处）：</p>
  <p><img src="http://images.gitbook.cn/618a4ab0-4904-11e8-9e33-bf33f6000d05" alt="enter image description here"></p>
  <p>需要注意的是，Infura 并不会帮你保存这些信息，你需要手动复制并在本地保存。一旦丢失或忘记，是找不回这些信息的，只能重新申请。</p>
  <p>至此，我们的开发环境就准备好了，下一篇文章就正式开始动手编写智能合约了。</p>
  <h5><strong>第03课：Hello world 合约开发</strong></h5>
  <p>绝大部分开发者学习一门语言的时候，都是从输出一个 <strong>Hello World</strong> 开始。我们也从实现一个 <strong>Hello World</strong> 合约为切入点，开始进入智能合约的世界吧。</p>
  <h3>环境准备</h3>
  <p>前面已经介绍了 <strong>Node</strong> 和 <strong>npm</strong> 的安装。本系列文章依赖的环境版本：</p>
  <blockquote> 
   <p>Node：v8.9.0 Npm：5.5.1</p>
  </blockquote>
  <p>接下来，在你的代码目录里，创建名为 <strong>smartcontract</strong> 的文件夹，并创建如下两个文件 <strong>package.json</strong> 、<strong>Hello.sol</strong> 。</p>
  <blockquote> 
   <p>smartcontract ├── Hello.sol └── package.json</p>
  </blockquote>
  <p>在 <strong>package.json</strong> 文件里，添加如下依赖包配置：</p>
  <pre><code>{  "name": "smartcontract",  "version": "0.0.1",  "dependencies": {    "fs": "0.0.1-security",    "solc": "^0.4.21",    "web3": "^0.20.0"  }}</code></pre>
  <blockquote> 
   <p>fs 模块用于文件的相关操作； solc 模块是编译器； web3 模块是以太坊提供的工具包，主要用于与合约的通信。</p>
  </blockquote>
  <p>接下来执行 <strong>npm install</strong> 下载相关的依赖包。</p>
  <h3>编写合约代码</h3>
  <p>环境准备好后，就可以开始编写合约代码了。 打开 <strong>Hello.sol</strong> 文件，编写代码如下：</p>
  <pre><code>//pragma关键字：版本申明。//用来指示编译器将代码编译成特定版本，以免引起兼容性问题//此处不支持0.4.0之前的编译器，也不支持0.5.0之后的编译器（条件为 ^）pragma solidity ^0.4.0;//contract关键字：合约申明//和Java、PHP中的class类似//此处是申明一个名为Hello的合约contract Hello {    //public: 函数访问属性(后续文章为详细阐述)    //returns (string): 定义返回值类型为string    function say(string name) public returns (string) {        return name;    }}</code></pre>
  <p>代码很简单。就是实现了用户输入什么字符串，合约就原样返回的操作。</p>
  <p>接下来，我们需要编写<strong>合约部署</strong>脚本。</p>
  <h3>合约部署脚本</h3>
  <p>在 <strong>smartcontract</strong> 目录下，新建名为 <strong>deploy.js</strong> 的文件。代码如下：</p>
  <pre><code>//设置web3连接var Web3 = require('web3');//http://localhost:7545 为Ganache提供的节点链接var web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:7545'));//读取合约var fs = require('fs');var contractCode = fs.readFileSync('Hello.sol').toString();//编译合约代码var solc = require('solc');var compileCode = solc.compile(contractCode);console.log(compileCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[':Hello'].interface);var byteCode = compileCode.contracts[':Hello'].bytecode;//创建合约对象var VotingContract = web3.eth.contract(abi);//部署合约，并返回部署对象var deployedContract = VotingContract.new({    data:byteCode,    from:web3.eth.accounts[0],  //部署合约的外部账户地址    gas:750000        //部署合约的矿工费});console.log(deployedContract);</code></pre>
  <p>代码里我加上了简单的注释。这里解释一下 <strong>abi</strong> 这个概念。</p>
  <blockquote> 
   <p>abi 全称是 Application Binary Interface，即应用程序二进制接口。简单的说，就是合约对外的接口描述。</p>
  </blockquote>
  <p>需要注意的是，矿工费 Gas 为750000。以太坊上每笔交易的执行（被矿工打包）都会被收取一定数量的 Gas。Gas 的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发一个 <strong>out of gas</strong> 异常。当前调用帧所做的所有状态修改都将被回滚。如果执行结束，还有Gas剩余，这些 Gas 将会返还给发送账户。因此，如果部署时抛出 <strong>out of gas</strong> 的异常，我们可适当的提高 Gas 值。</p>
  <h3>合约部署</h3>
  <p>在当前目录下，执行 <strong>node deploy.js</strong> 命令。我们在部署脚本里将 <strong>compileCode</strong> 变量打印出来了，粗略看看就行：</p>
  <pre><code>{ contracts:   { ':Hello':      { assembly: [Object],        bytecode: '6060604052341561000f57600080fd5b61016c8061001e6000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063d5c6130114610046575b600080fd5b341561005157600080fd5b6100a1600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061011c565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100e15780820151818401526020810190506100c6565b50505050905090810190601f16801561010e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61012461012c565b819050919050565b6020604051908101604052806000815250905600a165627a7a72305820ff14cafd1df21e1edf19eff7598bc82a98940cc0fe045d6107d04bb224014f990029',        functionHashes: [Object],        gasEstimates: [Object],        interface: '[{"constant":false,"inputs":[{"name":"name","type":"string"}],"name":"say","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"nonpayable","type":"function"}]',        metadata: '{"compiler":{"version":"0.4.21+commit.dfe3193c"},"language":"Solidity","output":{"abi":[{"constant":false,"inputs":[{"name":"name","type":"string"}],"name":"say","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"nonpayable","type":"function"}],"devdoc":{"methods":{}},"userdoc":{"methods":{}}},"settings":{"compilationTarget":{"":"Hello"},"evmVersion":"byzantium","libraries":{},"optimizer":{"enabled":false,"runs":200},"remappings":[]},"sources":{"":{"keccak256":"0x2e3dd18fbfbd17bb4f866b1bfbb38082172a0bb58d9396b63bab04e67d9d8e08","urls":["bzzr://d1aae746dfab03e712d8a3cb76b7d4b5bf60f48fafbffa04dfa8a2d53ad5d0ca"]}},"version":1}',        opcodes: 'PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x16C DUP1 PUSH2 0x1E PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x41 JUMPI PUSH1 0x0 CALLDATALOAD PUSH29 0x100000000000000000000000000000000000000000000000000000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0xD5C61301 EQ PUSH2 0x46 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE ISZERO PUSH2 0x51 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xA1 PUSH1 0x4 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP3 ADD DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP POP SWAP2 SWAP1 POP POP PUSH2 0x11C JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0xE1 JUMPI DUP1 DUP3 ADD MLOAD DUP2 DUP5 ADD MSTORE PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH2 0xC6 JUMP JUMPDEST POP POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x10E JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x124 PUSH2 0x12C JUMP JUMPDEST DUP2 SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x0 DUP2 MSTORE POP SWAP1 JUMP STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 SELFDESTRUCT EQ 0xca REVERT SAR CALLCODE 0x1e 0x1e 0xdf NOT 0xef 0xf7 MSIZE DUP12 0xc8 0x2a SWAP9 SWAP5 0xc 0xc0 INVALID DIV 0x5d PUSH2 0x7D0 0x4b 0xb2 0x24 ADD 0x4f SWAP10 STOP 0x29 ',        runtimeBytecode: '606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063d5c6130114610046575b600080fd5b341561005157600080fd5b6100a1600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061011c565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100e15780820151818401526020810190506100c6565b50505050905090810190601f16801561010e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61012461012c565b819050919050565b6020604051908101604052806000815250905600a165627a7a72305820ff14cafd1df21e1edf19eff7598bc82a98940cc0fe045d6107d04bb224014f990029',        srcmap: '25:102:0:-;;;;;;;;;;;;;;;;;',        srcmapRuntime: '25:102:0:-;;;;;;;;;;;;;;;;;;;;;;;;47:78;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;23:1:-1;8:100;33:3;30:1;27:10;8:100;;;99:1;94:3;90:11;84:18;80:1;75:3;71:11;64:39;52:2;49:1;45:10;40:15;;8:100;;;12:14;47:78:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;89:6;;:::i;:::-;114:4;107:11;;47:78;;;:::o;25:102::-;;;;;;;;;;;;;;;:::o' } },  errors:   [ ':5:5: Warning: Function state mutability can be restricted to pure\n    function say(string name) public returns (string) {\n    ^ (Relevant source part starts here and spans across multiple lines).\n' ],  sourceList: [ '' ],  sources: { '': { AST: [Object] } } }</code></pre>
  <p>打开 Ganache 的 <strong>LOGS</strong> 面板，可以看到部署产生的交易（Transaction）日志：</p>
  <p><img src="http://images.gitbook.cn/a0891770-5d61-11e8-a470-91ba7afbc420" alt="transaction"></p>
  <p>箭头所指就是部署成功后的合约地址：0xbf474d24ba8b19811db5deb51137ddccbe3ff288（每个人部署后的地址可能都不相同）。</p>
  <p>我们记录下来，后面的合约调用代码里需要用到。同时，也可以打开 <strong>ACCOUNTS</strong> 面板，观察账户余额的变化。</p>
  <h3>合约调用</h3>
  <p>合约部署成功之后，我们写一段代码来调用合约里的 <strong>say()</strong> 方法，检测一下效果。在 <strong>smartcontract</strong> 目录下，新建名为 <strong>run.js</strong> 的文件，代码如下：</p>
  <pre><code>//设置web3连接var Web3 = require('web3');//http://localhost:7545 为Ganache提供的节点链接var web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:7545'));//读取合约var fs = require('fs');var contractCode = fs.readFileSync('Hello.sol').toString();//编译合约代码var solc = require('solc');var compileCode = solc.compile(contractCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts[':Hello'].interface);var byteCode = compileCode.contracts[':Hello'].bytecode;//创建合约对象var VotingContract = web3.eth.contract(abi);//0xbf474d24ba8b19811db5deb51137ddccbe3ff288为合约部署地址var contractInstance = VotingContract.at("0xbf474d24ba8b19811db5deb51137ddccbe3ff288");var result = contractInstance.say.call('Hello world');console.log(result);</code></pre>
  <p>我们来执行 <strong>node run.js</strong> 命令，可以看到在终端里输出了 <strong>Hello world</strong> 。</p>
  <h3>字符串拼接</h3>
  <p>我们可以扩展一下。如果我们事先在合约里定义好 <strong>Hello</strong> 字符串，如何与 <strong>name</strong> 变量进行字符串拼接？</p>
  <p>在智能合约里进行字符串的拼接可不是一件简单的事情。我们先用绝大部分编程语言都通用的连接符 <strong>+</strong> 和 <strong>.</strong> 来尝试着修改代码：</p>
  <pre><code>//pragma关键字：版本申明。//用来指示编译器将代码编译成特定版本，以免引起兼容性问题//此处不支持0.4.0之前的编译器，也不支持0.5.0之后的编译器（条件为 ^）pragma solidity ^0.4.0;//contract关键字：合约申明//和Java、PHP中的class类似//此处是申明一个名为Hello的合约contract Hello {    string str="Hello ";    //public: 函数访问属性(后续文章为详细阐述)    //returns (string): 定义返回值类型为string    function say(string name) public returns (string) {        return str + name;    }}</code></pre>
  <p>运行 <strong>node deploy.js</strong> 部署脚本后，抛出了一个异常：</p>
  <blockquote> 
   <p>TypeError: Operator + not compatible with types string storage ref and string memory<br> return str + name;</p>
  </blockquote>
  <p>我们将其修改为“<strong>.</strong>”并尝试部署后，也抛出一个异常：</p>
  <blockquote> 
   <p>TypeError: Member "name" not found or not visible after argument-dependent lookup in string storage ref return str . name;</p>
  </blockquote>
  <p>说明在智能合约里，“<strong>+</strong>”和“<strong>.</strong>”都不是连接符。通过查阅 <a href="https://solidity.readthedocs.io/en/latest/frequently-asked-questions.html#can-i-concatenate-two-strings" rel="nofollow">Solidity 官方文档</a>，我们发现 <strong>Solidity</strong> 语言并不提供字符串连接符的语法：</p>
  <p><img src="http://images.gitbook.cn/45df9960-5d62-11e8-96f0-bfb8000c0196" alt="Solidity文档"></p>
  <p>那有没有其他方式，可以实现字符串的拼接功能呢？</p>
  <p>以太坊核心开发团队已经为其提供了字符串的扩展类。从 <a href="https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol" rel="nofollow">strings.sol</a> 处下载字符串工具合约，保存到 <strong>smartcontract</strong> 目录中：</p>
  <pre><code>smartcontract  ├── Hello.sol  ├── deploy.js  ├── node_modules  ├── package.json  ├── run.js  └── strings.sol</code></pre>
  <p>修改 <strong>Hello.sol</strong> 代码：</p>
  <pre><code>pragma solidity ^0.4.0;//导入 strings.sol 工具合约import "./strings.sol"; //注意这里contract Hello {    //将 strings 工具合约用于所有数据类型    using strings for *;    //注意这里    string str="Hello ";    function say(string name) public returns (string) {        return str.toSlice().concat(name.toSlice());    }}</code></pre>
  <p>运行部署脚本 <strong>node deploy.js</strong> 后，抛出一个异常：</p>
  <blockquote> 
   <p>ParserError: Source "strings.sol" not found: File not supplied initially. import "./strings.sol"</p>
  </blockquote>
  <p>提示 <strong>strings.sol</strong> 文件找不到，这并不是合约代码有问题，而是 <strong>solc 编译器</strong> 的问题。</p>
  <p><strong>solc 编译器</strong> 目前不支持关联文件的自动引入。我们期望编译器以更智能的方式引入关联的文件，但是这意味着它至少需要 fs 模块，而 fs 模块反过来又增加了 solc 模块的大小，同时也增加了不必要的依赖。</p>
  <p>所以，我们需要修改部署脚本文件 <strong>deploy.js</strong> 的代码：</p>
  <pre><code>//设置web3连接var Web3 = require('web3');var web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:7545'));//读取strings.sol和hello.sol两个合约     var fs = require('fs');var contractCode = {     //注意这里的变化    "strings.sol":fs.readFileSync('strings.sol').toString(),    "Hello.sol":fs.readFileSync('Hello.sol').toString()};//编译合约代码var solc = require('solc');var compileCode = solc.compile({    //注意这里的变化    sources:contractCode},1);console.log(compileCode);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts['Hello.sol:Hello'].interface);  //注意这里的变化var byteCode = compileCode.contracts['Hello.sol:Hello'].bytecode;   //注意这里的变化//创建合约对象var VotingContract = web3.eth.contract(abi);//部署合约，并返回部署对象var deployedContract = VotingContract.new({    data:byteCode,    from:web3.eth.accounts[0],    gas:750000});console.log(deployedContract);</code></pre>
  <p>读取 <strong>strings.sol</strong> 和 <strong>Hello.sol</strong> 两个合约文件，并一同编译即可。再次执行 <strong>node deploy.js</strong> 命令，合约部署成功。记录下合约地址：0x58a73dea66cea789dcfb5b4a94b7247ca010b781（每个人执行的合约地址可能都不相同）。</p>
  <p>同时，合约调用脚本 <strong>run.js</strong> 的代码修改部分和 <strong>deploy.js</strong> 相同：</p>
  <pre><code>//设置web3连接var Web3 = require('web3');var web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:7545'));//读取strings.sol和hello.sol两个合约 var fs = require('fs');var contractCode = {    "strings.sol":fs.readFileSync('strings.sol').toString(),     //注意这里的变化    "Hello.sol":fs.readFileSync('Hello.sol').toString()   //注意这里的变化};//编译合约代码成字节码var solc = require('solc');var compileCode = solc.compile({   //注意这里的变化    sources:contractCode},1);//获取合约abi和字节码var abi = JSON.parse(compileCode.contracts['Hello.sol:Hello'].interface);  //注意这里的变化var byteCode = compileCode.contracts['Hello.sol:Hello'].bytecode;   //注意这里的变化//创建合约对象var VotingContract = web3.eth.contract(abi);var contractInstance = VotingContract.at("0x58a73dea66cea789dcfb5b4a94b7247ca010b781");var result = contractInstance.say.call('world');console.log(result);console.log(contractInstance.say.call('Guys'));</code></pre>
  <p>执行脚本后，可以看到终端打印出了两行字符串：</p>
  <blockquote> 
   <p>Hello world Hello Guys</p>
  </blockquote>
  <p><strong>strings.sol</strong></p>
  <p>工具合约中还提供了字符串的比较、查找、切割等方法，大家可以动手尝试。本篇不做过多介绍。</p>
  <p>至此，第一个智能合约 <strong>Hello world</strong> 的代码编写、编译、部署、 调用的过程就完成了。建议大家动手执行一遍，加深理解。</p>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a></h5>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"><strong>第04课：Truffle 构建 DApp 应用</strong></a></h5>
  <a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a></h5>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"><strong>第05课：部署合约到 Ropsten 测试网和主网</strong></a></h5>
  <a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a></h5>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"><strong>第06课：Solidity 详解</strong></a></h5>
  <a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a></h5>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"><strong>第07课：去中心化投票 DApp 的开发</strong></a></h5>
  <a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a></h5>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"><strong>第08篇：ERC20 代币发行</strong></a></h5>
  <a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a></h5>
  <h5><a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"><strong>第09课：实现代币的增发、冻结等高级功能</strong></a></h5>
  <a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow"></a>
  <p>阅读全文: <a href="http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac?utm_source=csdn_blog" rel="nofollow">http://gitbook.cn/gitchat/column/5b0d2c1a9a9fcc0507a3f5ac</a></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/valada/article/details/80892582,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/valada/article/details/80892582,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
