<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>《Nodejs开发加密货币》之八：一个精巧的p2p网络实现 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="《Nodejs开发加密货币》之八：一个精巧的p2p网络实现" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="关于 《Nodejs开发加密货币》，是一个加密货币产品的详细开发文档，涉及到使用Nodejs开发产品的方方面面，从前端到后台、从服务器到客户端、从PC到移动、加密解密、区款链等各个环节。代码完全开源、文章免费分享。 相关资源见 http://ebookchain.org QQ交流群: 185046161 前言 加密货币都是去中心化的应用，去中心化的基础就是P2P网络，其作用和地位不言而喻，无可替代。 事实上，P2P网络不是什么新技术。但是，使用Nodejs开发的P2P网络，确实值得围观。这一篇，我们就来看看Ebookcoin的点对点网络是如何实现的。 源码 主要源码地址： peer.js: https://github.com/Ebookcoin/ebookcoin/blob/master/modules/peer.js transport.js: https://github.com/Ebookcoin/ebookcoin/blob/master/modules/transport.js router.js: https://github.com/Ebookcoin/ebookcoin/blob/master/helpers/router.js 类图 流程图 解读 基于http的web应用，抓住路由的定义、设计与实现，是快速弄清业务逻辑的简单方法。目前，分析的是modules文件夹下的各个模块文件，这些模块基本都是独立的Express微应用，在开发和设计上相互独立，各不冲突，逻辑清晰，这为学习分析，提供了便利。 1.路由扩展 任何应用，只要提供Web访问能力或第三方访问的Api，都需要提供从地址到逻辑的请求分发功能，这就是路由。Ebookcoin是基于http协议的Express应用，Express底层基于Nodejs的connect模块，因此其路由设计简单而灵活。 前面，在入门部分，已经讲到对路由的分拆调用，这里是其简单实现。先看看helper/router.js吧。 // 27行 var Router = function () { var router = require(&#39;express&#39;).Router(); router.use(function (req, res, next) { res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;); next(); }); router.map = map; return router; } ... 这段代码定义了一个Express路由器Router，并扩展了两个功能： 允许任何客户端调用。其实，就是设置了跨域请求，选项Access-Control-Allow-Origin设置为*，自然任何IP和端口的节点都可以访问和被访问。 添加了地址映射方法。该方法的主要内容如下： // 3行 function map(root, config) { var router = this; Object.keys(config).forEach(function (params) { var route = params.split(&quot; &quot;); if (route.length != 2 || [&quot;post&quot;, &quot;get&quot;, &quot;put&quot;].indexOf(route[0]) == -1) { throw Error(&quot;wrong map config&quot;); } router[route[0]](route[1], function (req, res, next) { root[config[params]]({&quot;body&quot;: route[0] == &quot;get&quot; ? req.query : req.body}, function (err, response) { if (err) { res.json({&quot;success&quot;: false, &quot;error&quot;: err}); } else { return res.json(extend({}, {&quot;success&quot;: true}, response)); } }); }); }); } 该方法，接受两个对象作为参数： root: 定义了所要开放Api的逻辑函数; config: 定义了路由和root定义的函数的对应关系。 其运行的结果，就相当于： router.get(&#39;/peers&#39;, function(req, res, next){ root.getPeers(...); }) 这里关键的小技巧是，在js代码中，对象也是hash值，root.getPeers() 与 root‘getPeers’ 是一致的。不过后者可以用字符串变量代替，更加灵活，有点像ruby里的元编程。这是脚本语言的优势（简单的字符串拼接处理）。 扩展一下，在类似sails的框架（基于express)里，很多都是可以使用类似config.json的文件直接配置的，包括路由。参考这个函数，很容易理解和实现。 2.节点路由 很轻松就能在peer.js里找到上述map方法的使用： // 3行 Router = require(&#39;../helpers/router.js&#39;) // 25 private.attachApi = function () { var router = new Router(); router.use(function (req, res, next) { if (modules) return next(); res.status(500).send({success: false, error: &quot;Blockchain is loading&quot;}); }); // 34行 router.map(shared, { &quot;get /&quot;: &quot;getPeers&quot;, &quot;get /version&quot;: &quot;version&quot;, &quot;get /get&quot;: &quot;getPeer&quot; }); router.use(function (req, res) { res.status(500).send({success: false, error: &quot;API endpoint not found&quot;}); }); // 44行 library.network.app.use(&#39;/api/peers&#39;, router); library.network.app.use(function (err, req, res, next) { if (!err) return next(); library.logger.error(req.url, err.toString()); res.status(500).send({success: false, error: err.toString()}); }); }; 上面代码的34行，可以直观想象到，会有类似/version的路由出现，44行是express应用，这里就是将定义好的路由放在/api/peers前缀之下，可以确信peer.js文件提供了下面3个公共Api地址： http://ip:port/api/peers/ http://ip:port/api/peers/version http://ip:port/api/peers/get 当然，是不是可以直接这么调用，要看具体对应的函数是否还有其他的参数要求，比如：/api/peers/get，按照restful的api设计原则，可以理解为是获得具体某个节点信息，那么总该给个id之类的限定条件吧。看源码： // 455行 library.scheme.validate(query, { type: &quot;object&quot;, properties: { ip_str: { type: &quot;string&quot;, minLength: 1 }, port: { type: &quot;integer&quot;, minimum: 0, maximum: 65535 } }, required: [&#39;ip_str&#39;, &#39;port&#39;] }, function (err) { ... // 480行 private.getByFilter({ ... }); }); 这里，在具体运行过程中，library就是app.js里传过来的scope，该参数包含的scheme代表了一个z_schema实例。 z_schema是一个第三方组件，具体请看参考链接。该组件提供了json数据格式验证功能。上述代码的意思是：对请求参数query进行验证，验证规则是：object类型，属性ip_str要求长度不小于1的字符串，属性port要求0~65535之间的整数，并且都不能空（必需）。 这就说明，我们应该这样请求http://ip:port/api/peers/get?ip_str=0.0.0.0&amp;port=1234，不然会返回错误信息。回头看看getPeers方法的实现，没有required字段，对应可以直接访问http://ip:port/api/peers/。 看480行，上面的地址，都会调用private.getByFilter()，并由它从sqlite数据库里查询数据表peers。这里涉及到 　dblite第三方组件 　(请看参考链接)，对请求操作sqlite数据库进行了简单封装。 3.节点保存 大多数应用，读数据相对简单，难在写数据。上面的代码，都是get请求，可以查寻节点及其信息。我们自然会问，查询的信息从哪里来？初始的节点在哪里？节点变更了，怎么办？ （1）初始化节点 从现实角度考虑，在一个P2P网络中，一个孤立的节点，在没有其他任何节点信息的情况下，仅仅靠网络扫描去寻找其他节点，将是一件很难完成的事情，更别提高效和安全了。 因此，在运行软件之前，初始化一些节点供联网使用，是最简单直接的解决方案。这个在配置文件config.json里，有直接体现： // config.json 15行 &quot;peers&quot;: { &quot;list&quot;: [], &quot;blackList&quot;: [], &quot;options&quot;: { &quot;timeout&quot;: 4000 } }, ... list的数据格式为： [ { ip: 0.0.0.0, port: 7000 }, ... ] 当然，也可以在启动的时候，通过参数--peers 1.2.3.4:70001, 2.1.2.3:7002提供（代码见app.js47行）。 （2）写入节点 写入节点，就是持久化，或者保存到数据库，或者保存到某个文件。这里保存到sqlite3数据库里的peers表了，代码如下： // peer.js 347行 Peer.prototype.onBlockchainReady = function () { async.eachSeries(library.config.peers.list, function (peer, cb) { library.dbLite.query(&quot;INSERT OR IGNORE INTO peers(ip, port, state, sharePort) VALUES($ip, $port, $state, $sharePort)&quot;, { ip: ip.toLong(peer.ip), port: peer.port, state: 2, //初始状态为2，都是健康的节点 sharePort: Number(true) }, cb); }, function (err) { if (err) { library.logger.error(&#39;onBlockchainReady&#39;, err); } private.count(function (err, count) { if (count) { private.updatePeerList(function (err) { err &amp;&amp; library.logger.error(&#39;updatePeerList&#39;, err); library.bus.message(&#39;peerReady&#39;); }) library.logger.info(&#39;Peers ready, stored &#39; + count); } else { library.logger.warn(&#39;Peers list is empty&#39;); } }); }); } 这段代码的意思是，当区块链（后面篇章分析）加载完毕的时候（触发事件），依次将配置的节点写入数据库，如果数据库已经存在相同的记录就忽略，然后更新节点列表，触发节点加载完毕事件。 这里对数据库Sqlite的插入操作，插入语句是library.dbLite.query(&quot;INSERT OR IGNORE INTO peers，有意思的是IGNORE操作字符串，是sqlite3支持的（见参考），当数据库有相同记录的时候，该记录被忽略，继续往下执行。 执行成功，就会调用library.bus.message(&#39;peerReady&#39;)，进而触发peerReady事件。该事件的功能就是： （3）更新节点 事件onPeerReady函数，如下： // peer.js 374行 Peer.prototype.onPeerReady = function () { setImmediate(function nextUpdatePeerList() { private.updatePeerList(function (err) { err &amp;&amp; library.logger.error(&#39;updatePeerList timer&#39;, err); setTimeout(nextUpdatePeerList, 60 * 1000); }) }); setImmediate(function nextBanManager() { private.banManager(function (err) { err &amp;&amp; library.logger.error(&#39;banManager timer&#39;, err); setTimeout(nextBanManager, 65 * 1000) }); }); } 两个setImmediate函数的调用，一个循环更新节点列表，一个循环更新节点状态。 第一个循环调用 看看第一个循环调用的函数updatePeerList， private.updatePeerList = function (cb) { // 53行 modules.transport.getFromRandomPeer({ api: &#39;/list&#39;, method: &#39;GET&#39; }, function (err, data) { ... library.scheme.validate(data.body, { ... // 124行 self.update(peer, cb); }); }, cb); }); }); }; 看53行，我们知道，程序通过transport模块的.getFromRandomPeer方法，逐个随机的验证节点信息，并将其做删除和更新处理。如此一来，各种调用关系更加清晰，看流程图更加直观。.getFromRandomPeer的代码： // transport.js 474行 Transport.prototype.getFromRandomPeer = function (config, options, cb) { ... // 481行 async.retry(20, function (cb) { modules.peer.list(config, function (err, peers) { if (!err &amp;&amp; peers.length) { var peer = peers[0]; // 485行 self.getFromPeer(peer, options, cb); } else { return cb(err || &quot;No peers in db&quot;); } }); ... }; 代码很简单，重要的是理解async.retry的用法（下篇技术分享，详细学习），该方法就是要重复调用第一个task函数20次，有正确返回结果就传给回调函数。这里，只要查到一个节点，就会传给485行的getFromPeer函数，该函数是检验处理现存节点的核心函数，代码如下： // transport.js 500行 Transport.prototype.getFromPeer = function (peer, options, cb) { ... var req = { // 519行： 获得节点地址 url: &#39;http://&#39; + ip.fromLong(peer.ip) + &#39;:&#39; + peer.port + url, ... }; // 532行： 使用`request`组件发送请求 return request(req, function (err, response, body) { if (err || response.statusCode != 200) { ... if (peer) { if (err &amp;&amp; (err.code == &quot;ETIMEDOUT&quot; || err.code == &quot;ESOCKETTIMEDOUT&quot; || err.code == &quot;ECONNREFUSED&quot;)) { // 542行： 对于无法请求的，自然要删除 modules.peer.remove(peer.ip, peer.port, function (err) { ... }); } else { if (!options.not_ban) { // 549行： 对于状态码不是200的，比如304等禁止状态，就要更改其状态 modules.peer.state(peer.ip, peer.port, 0, 600, function (err) { ... }); } } } cb &amp;&amp; cb(err || (&#39;request status code&#39; + response.statusCode)); return; } ... if (port &gt; 0 &amp;&amp; port &lt;= 65535 &amp;&amp; response.headers[&#39;version&#39;] == library.config.version) { // 595行： 一切问题都不存在 modules.peer.update({ ip: peer.ip, port: port, state: 2, // 598行： 看来健康的节点状态为2 ... }); } 这里最重要的是532行，request第三方组件的使用，请看参考链接。官方定义为简单的http客户端，功能足够强大，可以模拟浏览器访问信息，经常被用来做测试。 第二个循环调用 第二个循环调用的函数很简单，就是循环更改state和clock字段，主要是将禁止的状态state=0，修改为1，如下： // 142行 private.banManager = function (cb) { library.dbLite.query(&quot;UPDATE peers SET state = 1, clock = null where (state = 0 and clock - $now &lt; 0)&quot;, {now: Date.now()}, cb); } 综上，整个P2P网络的读写和更新都已经清楚，回头再看活动图和类图，就更加明朗了。 最后，补充一下数据库里，节点表格peers的字段信息：　 id,ip,port,state,os,sharePort,version,clock 总结 本篇，重点阅读了peer.js文件，学习了一个使用Nodejs开发的P2P网络架构，其特点是： 产品提供初始节点列表，保障了初始化节点快速完成，不至于成为孤立节点; 节点具备跨域访问能力，任何节点之间都可以自由访问; 节点具备自我更新能力，定期查询和更新死掉的节点，保障网络始终畅通; 一旦达到一定的节点数量，就会形成一个互联互通的不死网络。搭建在这种网络上的服务，会充满怎样的诱惑？加密货币为什么会被认为是下一代互联网？这加起来不足千行的代码，可以给我们足够多的遐想空间。 这部分代码，涉及到dblite，request，z_schema等第三方组件，以及Ebookcoin自行实现的事件处理方法library.bus(在app.js文件的行)，都很简单，不再分享或赘述，请自行查阅。本篇涉及的代码中，关于回调的设计很多，值得总结和研究。async组件，被反复使用，有必须汇总一下，请关注后续的技术分享。 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 电子书阅读： http://bitcoin-on-nodejs.ebookchain.org 参考 z_schema组件: https://github.com/Ebookcoin/z_schema dblite组件： https://github.com/Ebookcoin/dblite request组件： http://github.com/request/request SQL As Understood By SQLite： https://www.sqlite.org/lang_conflict.html 阅读更多" />
<meta property="og:description" content="关于 《Nodejs开发加密货币》，是一个加密货币产品的详细开发文档，涉及到使用Nodejs开发产品的方方面面，从前端到后台、从服务器到客户端、从PC到移动、加密解密、区款链等各个环节。代码完全开源、文章免费分享。 相关资源见 http://ebookchain.org QQ交流群: 185046161 前言 加密货币都是去中心化的应用，去中心化的基础就是P2P网络，其作用和地位不言而喻，无可替代。 事实上，P2P网络不是什么新技术。但是，使用Nodejs开发的P2P网络，确实值得围观。这一篇，我们就来看看Ebookcoin的点对点网络是如何实现的。 源码 主要源码地址： peer.js: https://github.com/Ebookcoin/ebookcoin/blob/master/modules/peer.js transport.js: https://github.com/Ebookcoin/ebookcoin/blob/master/modules/transport.js router.js: https://github.com/Ebookcoin/ebookcoin/blob/master/helpers/router.js 类图 流程图 解读 基于http的web应用，抓住路由的定义、设计与实现，是快速弄清业务逻辑的简单方法。目前，分析的是modules文件夹下的各个模块文件，这些模块基本都是独立的Express微应用，在开发和设计上相互独立，各不冲突，逻辑清晰，这为学习分析，提供了便利。 1.路由扩展 任何应用，只要提供Web访问能力或第三方访问的Api，都需要提供从地址到逻辑的请求分发功能，这就是路由。Ebookcoin是基于http协议的Express应用，Express底层基于Nodejs的connect模块，因此其路由设计简单而灵活。 前面，在入门部分，已经讲到对路由的分拆调用，这里是其简单实现。先看看helper/router.js吧。 // 27行 var Router = function () { var router = require(&#39;express&#39;).Router(); router.use(function (req, res, next) { res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;); next(); }); router.map = map; return router; } ... 这段代码定义了一个Express路由器Router，并扩展了两个功能： 允许任何客户端调用。其实，就是设置了跨域请求，选项Access-Control-Allow-Origin设置为*，自然任何IP和端口的节点都可以访问和被访问。 添加了地址映射方法。该方法的主要内容如下： // 3行 function map(root, config) { var router = this; Object.keys(config).forEach(function (params) { var route = params.split(&quot; &quot;); if (route.length != 2 || [&quot;post&quot;, &quot;get&quot;, &quot;put&quot;].indexOf(route[0]) == -1) { throw Error(&quot;wrong map config&quot;); } router[route[0]](route[1], function (req, res, next) { root[config[params]]({&quot;body&quot;: route[0] == &quot;get&quot; ? req.query : req.body}, function (err, response) { if (err) { res.json({&quot;success&quot;: false, &quot;error&quot;: err}); } else { return res.json(extend({}, {&quot;success&quot;: true}, response)); } }); }); }); } 该方法，接受两个对象作为参数： root: 定义了所要开放Api的逻辑函数; config: 定义了路由和root定义的函数的对应关系。 其运行的结果，就相当于： router.get(&#39;/peers&#39;, function(req, res, next){ root.getPeers(...); }) 这里关键的小技巧是，在js代码中，对象也是hash值，root.getPeers() 与 root‘getPeers’ 是一致的。不过后者可以用字符串变量代替，更加灵活，有点像ruby里的元编程。这是脚本语言的优势（简单的字符串拼接处理）。 扩展一下，在类似sails的框架（基于express)里，很多都是可以使用类似config.json的文件直接配置的，包括路由。参考这个函数，很容易理解和实现。 2.节点路由 很轻松就能在peer.js里找到上述map方法的使用： // 3行 Router = require(&#39;../helpers/router.js&#39;) // 25 private.attachApi = function () { var router = new Router(); router.use(function (req, res, next) { if (modules) return next(); res.status(500).send({success: false, error: &quot;Blockchain is loading&quot;}); }); // 34行 router.map(shared, { &quot;get /&quot;: &quot;getPeers&quot;, &quot;get /version&quot;: &quot;version&quot;, &quot;get /get&quot;: &quot;getPeer&quot; }); router.use(function (req, res) { res.status(500).send({success: false, error: &quot;API endpoint not found&quot;}); }); // 44行 library.network.app.use(&#39;/api/peers&#39;, router); library.network.app.use(function (err, req, res, next) { if (!err) return next(); library.logger.error(req.url, err.toString()); res.status(500).send({success: false, error: err.toString()}); }); }; 上面代码的34行，可以直观想象到，会有类似/version的路由出现，44行是express应用，这里就是将定义好的路由放在/api/peers前缀之下，可以确信peer.js文件提供了下面3个公共Api地址： http://ip:port/api/peers/ http://ip:port/api/peers/version http://ip:port/api/peers/get 当然，是不是可以直接这么调用，要看具体对应的函数是否还有其他的参数要求，比如：/api/peers/get，按照restful的api设计原则，可以理解为是获得具体某个节点信息，那么总该给个id之类的限定条件吧。看源码： // 455行 library.scheme.validate(query, { type: &quot;object&quot;, properties: { ip_str: { type: &quot;string&quot;, minLength: 1 }, port: { type: &quot;integer&quot;, minimum: 0, maximum: 65535 } }, required: [&#39;ip_str&#39;, &#39;port&#39;] }, function (err) { ... // 480行 private.getByFilter({ ... }); }); 这里，在具体运行过程中，library就是app.js里传过来的scope，该参数包含的scheme代表了一个z_schema实例。 z_schema是一个第三方组件，具体请看参考链接。该组件提供了json数据格式验证功能。上述代码的意思是：对请求参数query进行验证，验证规则是：object类型，属性ip_str要求长度不小于1的字符串，属性port要求0~65535之间的整数，并且都不能空（必需）。 这就说明，我们应该这样请求http://ip:port/api/peers/get?ip_str=0.0.0.0&amp;port=1234，不然会返回错误信息。回头看看getPeers方法的实现，没有required字段，对应可以直接访问http://ip:port/api/peers/。 看480行，上面的地址，都会调用private.getByFilter()，并由它从sqlite数据库里查询数据表peers。这里涉及到 　dblite第三方组件 　(请看参考链接)，对请求操作sqlite数据库进行了简单封装。 3.节点保存 大多数应用，读数据相对简单，难在写数据。上面的代码，都是get请求，可以查寻节点及其信息。我们自然会问，查询的信息从哪里来？初始的节点在哪里？节点变更了，怎么办？ （1）初始化节点 从现实角度考虑，在一个P2P网络中，一个孤立的节点，在没有其他任何节点信息的情况下，仅仅靠网络扫描去寻找其他节点，将是一件很难完成的事情，更别提高效和安全了。 因此，在运行软件之前，初始化一些节点供联网使用，是最简单直接的解决方案。这个在配置文件config.json里，有直接体现： // config.json 15行 &quot;peers&quot;: { &quot;list&quot;: [], &quot;blackList&quot;: [], &quot;options&quot;: { &quot;timeout&quot;: 4000 } }, ... list的数据格式为： [ { ip: 0.0.0.0, port: 7000 }, ... ] 当然，也可以在启动的时候，通过参数--peers 1.2.3.4:70001, 2.1.2.3:7002提供（代码见app.js47行）。 （2）写入节点 写入节点，就是持久化，或者保存到数据库，或者保存到某个文件。这里保存到sqlite3数据库里的peers表了，代码如下： // peer.js 347行 Peer.prototype.onBlockchainReady = function () { async.eachSeries(library.config.peers.list, function (peer, cb) { library.dbLite.query(&quot;INSERT OR IGNORE INTO peers(ip, port, state, sharePort) VALUES($ip, $port, $state, $sharePort)&quot;, { ip: ip.toLong(peer.ip), port: peer.port, state: 2, //初始状态为2，都是健康的节点 sharePort: Number(true) }, cb); }, function (err) { if (err) { library.logger.error(&#39;onBlockchainReady&#39;, err); } private.count(function (err, count) { if (count) { private.updatePeerList(function (err) { err &amp;&amp; library.logger.error(&#39;updatePeerList&#39;, err); library.bus.message(&#39;peerReady&#39;); }) library.logger.info(&#39;Peers ready, stored &#39; + count); } else { library.logger.warn(&#39;Peers list is empty&#39;); } }); }); } 这段代码的意思是，当区块链（后面篇章分析）加载完毕的时候（触发事件），依次将配置的节点写入数据库，如果数据库已经存在相同的记录就忽略，然后更新节点列表，触发节点加载完毕事件。 这里对数据库Sqlite的插入操作，插入语句是library.dbLite.query(&quot;INSERT OR IGNORE INTO peers，有意思的是IGNORE操作字符串，是sqlite3支持的（见参考），当数据库有相同记录的时候，该记录被忽略，继续往下执行。 执行成功，就会调用library.bus.message(&#39;peerReady&#39;)，进而触发peerReady事件。该事件的功能就是： （3）更新节点 事件onPeerReady函数，如下： // peer.js 374行 Peer.prototype.onPeerReady = function () { setImmediate(function nextUpdatePeerList() { private.updatePeerList(function (err) { err &amp;&amp; library.logger.error(&#39;updatePeerList timer&#39;, err); setTimeout(nextUpdatePeerList, 60 * 1000); }) }); setImmediate(function nextBanManager() { private.banManager(function (err) { err &amp;&amp; library.logger.error(&#39;banManager timer&#39;, err); setTimeout(nextBanManager, 65 * 1000) }); }); } 两个setImmediate函数的调用，一个循环更新节点列表，一个循环更新节点状态。 第一个循环调用 看看第一个循环调用的函数updatePeerList， private.updatePeerList = function (cb) { // 53行 modules.transport.getFromRandomPeer({ api: &#39;/list&#39;, method: &#39;GET&#39; }, function (err, data) { ... library.scheme.validate(data.body, { ... // 124行 self.update(peer, cb); }); }, cb); }); }); }; 看53行，我们知道，程序通过transport模块的.getFromRandomPeer方法，逐个随机的验证节点信息，并将其做删除和更新处理。如此一来，各种调用关系更加清晰，看流程图更加直观。.getFromRandomPeer的代码： // transport.js 474行 Transport.prototype.getFromRandomPeer = function (config, options, cb) { ... // 481行 async.retry(20, function (cb) { modules.peer.list(config, function (err, peers) { if (!err &amp;&amp; peers.length) { var peer = peers[0]; // 485行 self.getFromPeer(peer, options, cb); } else { return cb(err || &quot;No peers in db&quot;); } }); ... }; 代码很简单，重要的是理解async.retry的用法（下篇技术分享，详细学习），该方法就是要重复调用第一个task函数20次，有正确返回结果就传给回调函数。这里，只要查到一个节点，就会传给485行的getFromPeer函数，该函数是检验处理现存节点的核心函数，代码如下： // transport.js 500行 Transport.prototype.getFromPeer = function (peer, options, cb) { ... var req = { // 519行： 获得节点地址 url: &#39;http://&#39; + ip.fromLong(peer.ip) + &#39;:&#39; + peer.port + url, ... }; // 532行： 使用`request`组件发送请求 return request(req, function (err, response, body) { if (err || response.statusCode != 200) { ... if (peer) { if (err &amp;&amp; (err.code == &quot;ETIMEDOUT&quot; || err.code == &quot;ESOCKETTIMEDOUT&quot; || err.code == &quot;ECONNREFUSED&quot;)) { // 542行： 对于无法请求的，自然要删除 modules.peer.remove(peer.ip, peer.port, function (err) { ... }); } else { if (!options.not_ban) { // 549行： 对于状态码不是200的，比如304等禁止状态，就要更改其状态 modules.peer.state(peer.ip, peer.port, 0, 600, function (err) { ... }); } } } cb &amp;&amp; cb(err || (&#39;request status code&#39; + response.statusCode)); return; } ... if (port &gt; 0 &amp;&amp; port &lt;= 65535 &amp;&amp; response.headers[&#39;version&#39;] == library.config.version) { // 595行： 一切问题都不存在 modules.peer.update({ ip: peer.ip, port: port, state: 2, // 598行： 看来健康的节点状态为2 ... }); } 这里最重要的是532行，request第三方组件的使用，请看参考链接。官方定义为简单的http客户端，功能足够强大，可以模拟浏览器访问信息，经常被用来做测试。 第二个循环调用 第二个循环调用的函数很简单，就是循环更改state和clock字段，主要是将禁止的状态state=0，修改为1，如下： // 142行 private.banManager = function (cb) { library.dbLite.query(&quot;UPDATE peers SET state = 1, clock = null where (state = 0 and clock - $now &lt; 0)&quot;, {now: Date.now()}, cb); } 综上，整个P2P网络的读写和更新都已经清楚，回头再看活动图和类图，就更加明朗了。 最后，补充一下数据库里，节点表格peers的字段信息：　 id,ip,port,state,os,sharePort,version,clock 总结 本篇，重点阅读了peer.js文件，学习了一个使用Nodejs开发的P2P网络架构，其特点是： 产品提供初始节点列表，保障了初始化节点快速完成，不至于成为孤立节点; 节点具备跨域访问能力，任何节点之间都可以自由访问; 节点具备自我更新能力，定期查询和更新死掉的节点，保障网络始终畅通; 一旦达到一定的节点数量，就会形成一个互联互通的不死网络。搭建在这种网络上的服务，会充满怎样的诱惑？加密货币为什么会被认为是下一代互联网？这加起来不足千行的代码，可以给我们足够多的遐想空间。 这部分代码，涉及到dblite，request，z_schema等第三方组件，以及Ebookcoin自行实现的事件处理方法library.bus(在app.js文件的行)，都很简单，不再分享或赘述，请自行查阅。本篇涉及的代码中，关于回调的设计很多，值得总结和研究。async组件，被反复使用，有必须汇总一下，请关注后续的技术分享。 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 电子书阅读： http://bitcoin-on-nodejs.ebookchain.org 参考 z_schema组件: https://github.com/Ebookcoin/z_schema dblite组件： https://github.com/Ebookcoin/dblite request组件： http://github.com/request/request SQL As Understood By SQLite： https://www.sqlite.org/lang_conflict.html 阅读更多" />
<link rel="canonical" href="https://mlh.app/2016/05/04/a7878ae7cd17f62140ed6d9879df20e0.html" />
<meta property="og:url" content="https://mlh.app/2016/05/04/a7878ae7cd17f62140ed6d9879df20e0.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-04T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"关于 《Nodejs开发加密货币》，是一个加密货币产品的详细开发文档，涉及到使用Nodejs开发产品的方方面面，从前端到后台、从服务器到客户端、从PC到移动、加密解密、区款链等各个环节。代码完全开源、文章免费分享。 相关资源见 http://ebookchain.org QQ交流群: 185046161 前言 加密货币都是去中心化的应用，去中心化的基础就是P2P网络，其作用和地位不言而喻，无可替代。 事实上，P2P网络不是什么新技术。但是，使用Nodejs开发的P2P网络，确实值得围观。这一篇，我们就来看看Ebookcoin的点对点网络是如何实现的。 源码 主要源码地址： peer.js: https://github.com/Ebookcoin/ebookcoin/blob/master/modules/peer.js transport.js: https://github.com/Ebookcoin/ebookcoin/blob/master/modules/transport.js router.js: https://github.com/Ebookcoin/ebookcoin/blob/master/helpers/router.js 类图 流程图 解读 基于http的web应用，抓住路由的定义、设计与实现，是快速弄清业务逻辑的简单方法。目前，分析的是modules文件夹下的各个模块文件，这些模块基本都是独立的Express微应用，在开发和设计上相互独立，各不冲突，逻辑清晰，这为学习分析，提供了便利。 1.路由扩展 任何应用，只要提供Web访问能力或第三方访问的Api，都需要提供从地址到逻辑的请求分发功能，这就是路由。Ebookcoin是基于http协议的Express应用，Express底层基于Nodejs的connect模块，因此其路由设计简单而灵活。 前面，在入门部分，已经讲到对路由的分拆调用，这里是其简单实现。先看看helper/router.js吧。 // 27行 var Router = function () { var router = require(&#39;express&#39;).Router(); router.use(function (req, res, next) { res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;); next(); }); router.map = map; return router; } ... 这段代码定义了一个Express路由器Router，并扩展了两个功能： 允许任何客户端调用。其实，就是设置了跨域请求，选项Access-Control-Allow-Origin设置为*，自然任何IP和端口的节点都可以访问和被访问。 添加了地址映射方法。该方法的主要内容如下： // 3行 function map(root, config) { var router = this; Object.keys(config).forEach(function (params) { var route = params.split(&quot; &quot;); if (route.length != 2 || [&quot;post&quot;, &quot;get&quot;, &quot;put&quot;].indexOf(route[0]) == -1) { throw Error(&quot;wrong map config&quot;); } router[route[0]](route[1], function (req, res, next) { root[config[params]]({&quot;body&quot;: route[0] == &quot;get&quot; ? req.query : req.body}, function (err, response) { if (err) { res.json({&quot;success&quot;: false, &quot;error&quot;: err}); } else { return res.json(extend({}, {&quot;success&quot;: true}, response)); } }); }); }); } 该方法，接受两个对象作为参数： root: 定义了所要开放Api的逻辑函数; config: 定义了路由和root定义的函数的对应关系。 其运行的结果，就相当于： router.get(&#39;/peers&#39;, function(req, res, next){ root.getPeers(...); }) 这里关键的小技巧是，在js代码中，对象也是hash值，root.getPeers() 与 root‘getPeers’ 是一致的。不过后者可以用字符串变量代替，更加灵活，有点像ruby里的元编程。这是脚本语言的优势（简单的字符串拼接处理）。 扩展一下，在类似sails的框架（基于express)里，很多都是可以使用类似config.json的文件直接配置的，包括路由。参考这个函数，很容易理解和实现。 2.节点路由 很轻松就能在peer.js里找到上述map方法的使用： // 3行 Router = require(&#39;../helpers/router.js&#39;) // 25 private.attachApi = function () { var router = new Router(); router.use(function (req, res, next) { if (modules) return next(); res.status(500).send({success: false, error: &quot;Blockchain is loading&quot;}); }); // 34行 router.map(shared, { &quot;get /&quot;: &quot;getPeers&quot;, &quot;get /version&quot;: &quot;version&quot;, &quot;get /get&quot;: &quot;getPeer&quot; }); router.use(function (req, res) { res.status(500).send({success: false, error: &quot;API endpoint not found&quot;}); }); // 44行 library.network.app.use(&#39;/api/peers&#39;, router); library.network.app.use(function (err, req, res, next) { if (!err) return next(); library.logger.error(req.url, err.toString()); res.status(500).send({success: false, error: err.toString()}); }); }; 上面代码的34行，可以直观想象到，会有类似/version的路由出现，44行是express应用，这里就是将定义好的路由放在/api/peers前缀之下，可以确信peer.js文件提供了下面3个公共Api地址： http://ip:port/api/peers/ http://ip:port/api/peers/version http://ip:port/api/peers/get 当然，是不是可以直接这么调用，要看具体对应的函数是否还有其他的参数要求，比如：/api/peers/get，按照restful的api设计原则，可以理解为是获得具体某个节点信息，那么总该给个id之类的限定条件吧。看源码： // 455行 library.scheme.validate(query, { type: &quot;object&quot;, properties: { ip_str: { type: &quot;string&quot;, minLength: 1 }, port: { type: &quot;integer&quot;, minimum: 0, maximum: 65535 } }, required: [&#39;ip_str&#39;, &#39;port&#39;] }, function (err) { ... // 480行 private.getByFilter({ ... }); }); 这里，在具体运行过程中，library就是app.js里传过来的scope，该参数包含的scheme代表了一个z_schema实例。 z_schema是一个第三方组件，具体请看参考链接。该组件提供了json数据格式验证功能。上述代码的意思是：对请求参数query进行验证，验证规则是：object类型，属性ip_str要求长度不小于1的字符串，属性port要求0~65535之间的整数，并且都不能空（必需）。 这就说明，我们应该这样请求http://ip:port/api/peers/get?ip_str=0.0.0.0&amp;port=1234，不然会返回错误信息。回头看看getPeers方法的实现，没有required字段，对应可以直接访问http://ip:port/api/peers/。 看480行，上面的地址，都会调用private.getByFilter()，并由它从sqlite数据库里查询数据表peers。这里涉及到 　dblite第三方组件 　(请看参考链接)，对请求操作sqlite数据库进行了简单封装。 3.节点保存 大多数应用，读数据相对简单，难在写数据。上面的代码，都是get请求，可以查寻节点及其信息。我们自然会问，查询的信息从哪里来？初始的节点在哪里？节点变更了，怎么办？ （1）初始化节点 从现实角度考虑，在一个P2P网络中，一个孤立的节点，在没有其他任何节点信息的情况下，仅仅靠网络扫描去寻找其他节点，将是一件很难完成的事情，更别提高效和安全了。 因此，在运行软件之前，初始化一些节点供联网使用，是最简单直接的解决方案。这个在配置文件config.json里，有直接体现： // config.json 15行 &quot;peers&quot;: { &quot;list&quot;: [], &quot;blackList&quot;: [], &quot;options&quot;: { &quot;timeout&quot;: 4000 } }, ... list的数据格式为： [ { ip: 0.0.0.0, port: 7000 }, ... ] 当然，也可以在启动的时候，通过参数--peers 1.2.3.4:70001, 2.1.2.3:7002提供（代码见app.js47行）。 （2）写入节点 写入节点，就是持久化，或者保存到数据库，或者保存到某个文件。这里保存到sqlite3数据库里的peers表了，代码如下： // peer.js 347行 Peer.prototype.onBlockchainReady = function () { async.eachSeries(library.config.peers.list, function (peer, cb) { library.dbLite.query(&quot;INSERT OR IGNORE INTO peers(ip, port, state, sharePort) VALUES($ip, $port, $state, $sharePort)&quot;, { ip: ip.toLong(peer.ip), port: peer.port, state: 2, //初始状态为2，都是健康的节点 sharePort: Number(true) }, cb); }, function (err) { if (err) { library.logger.error(&#39;onBlockchainReady&#39;, err); } private.count(function (err, count) { if (count) { private.updatePeerList(function (err) { err &amp;&amp; library.logger.error(&#39;updatePeerList&#39;, err); library.bus.message(&#39;peerReady&#39;); }) library.logger.info(&#39;Peers ready, stored &#39; + count); } else { library.logger.warn(&#39;Peers list is empty&#39;); } }); }); } 这段代码的意思是，当区块链（后面篇章分析）加载完毕的时候（触发事件），依次将配置的节点写入数据库，如果数据库已经存在相同的记录就忽略，然后更新节点列表，触发节点加载完毕事件。 这里对数据库Sqlite的插入操作，插入语句是library.dbLite.query(&quot;INSERT OR IGNORE INTO peers，有意思的是IGNORE操作字符串，是sqlite3支持的（见参考），当数据库有相同记录的时候，该记录被忽略，继续往下执行。 执行成功，就会调用library.bus.message(&#39;peerReady&#39;)，进而触发peerReady事件。该事件的功能就是： （3）更新节点 事件onPeerReady函数，如下： // peer.js 374行 Peer.prototype.onPeerReady = function () { setImmediate(function nextUpdatePeerList() { private.updatePeerList(function (err) { err &amp;&amp; library.logger.error(&#39;updatePeerList timer&#39;, err); setTimeout(nextUpdatePeerList, 60 * 1000); }) }); setImmediate(function nextBanManager() { private.banManager(function (err) { err &amp;&amp; library.logger.error(&#39;banManager timer&#39;, err); setTimeout(nextBanManager, 65 * 1000) }); }); } 两个setImmediate函数的调用，一个循环更新节点列表，一个循环更新节点状态。 第一个循环调用 看看第一个循环调用的函数updatePeerList， private.updatePeerList = function (cb) { // 53行 modules.transport.getFromRandomPeer({ api: &#39;/list&#39;, method: &#39;GET&#39; }, function (err, data) { ... library.scheme.validate(data.body, { ... // 124行 self.update(peer, cb); }); }, cb); }); }); }; 看53行，我们知道，程序通过transport模块的.getFromRandomPeer方法，逐个随机的验证节点信息，并将其做删除和更新处理。如此一来，各种调用关系更加清晰，看流程图更加直观。.getFromRandomPeer的代码： // transport.js 474行 Transport.prototype.getFromRandomPeer = function (config, options, cb) { ... // 481行 async.retry(20, function (cb) { modules.peer.list(config, function (err, peers) { if (!err &amp;&amp; peers.length) { var peer = peers[0]; // 485行 self.getFromPeer(peer, options, cb); } else { return cb(err || &quot;No peers in db&quot;); } }); ... }; 代码很简单，重要的是理解async.retry的用法（下篇技术分享，详细学习），该方法就是要重复调用第一个task函数20次，有正确返回结果就传给回调函数。这里，只要查到一个节点，就会传给485行的getFromPeer函数，该函数是检验处理现存节点的核心函数，代码如下： // transport.js 500行 Transport.prototype.getFromPeer = function (peer, options, cb) { ... var req = { // 519行： 获得节点地址 url: &#39;http://&#39; + ip.fromLong(peer.ip) + &#39;:&#39; + peer.port + url, ... }; // 532行： 使用`request`组件发送请求 return request(req, function (err, response, body) { if (err || response.statusCode != 200) { ... if (peer) { if (err &amp;&amp; (err.code == &quot;ETIMEDOUT&quot; || err.code == &quot;ESOCKETTIMEDOUT&quot; || err.code == &quot;ECONNREFUSED&quot;)) { // 542行： 对于无法请求的，自然要删除 modules.peer.remove(peer.ip, peer.port, function (err) { ... }); } else { if (!options.not_ban) { // 549行： 对于状态码不是200的，比如304等禁止状态，就要更改其状态 modules.peer.state(peer.ip, peer.port, 0, 600, function (err) { ... }); } } } cb &amp;&amp; cb(err || (&#39;request status code&#39; + response.statusCode)); return; } ... if (port &gt; 0 &amp;&amp; port &lt;= 65535 &amp;&amp; response.headers[&#39;version&#39;] == library.config.version) { // 595行： 一切问题都不存在 modules.peer.update({ ip: peer.ip, port: port, state: 2, // 598行： 看来健康的节点状态为2 ... }); } 这里最重要的是532行，request第三方组件的使用，请看参考链接。官方定义为简单的http客户端，功能足够强大，可以模拟浏览器访问信息，经常被用来做测试。 第二个循环调用 第二个循环调用的函数很简单，就是循环更改state和clock字段，主要是将禁止的状态state=0，修改为1，如下： // 142行 private.banManager = function (cb) { library.dbLite.query(&quot;UPDATE peers SET state = 1, clock = null where (state = 0 and clock - $now &lt; 0)&quot;, {now: Date.now()}, cb); } 综上，整个P2P网络的读写和更新都已经清楚，回头再看活动图和类图，就更加明朗了。 最后，补充一下数据库里，节点表格peers的字段信息：　 id,ip,port,state,os,sharePort,version,clock 总结 本篇，重点阅读了peer.js文件，学习了一个使用Nodejs开发的P2P网络架构，其特点是： 产品提供初始节点列表，保障了初始化节点快速完成，不至于成为孤立节点; 节点具备跨域访问能力，任何节点之间都可以自由访问; 节点具备自我更新能力，定期查询和更新死掉的节点，保障网络始终畅通; 一旦达到一定的节点数量，就会形成一个互联互通的不死网络。搭建在这种网络上的服务，会充满怎样的诱惑？加密货币为什么会被认为是下一代互联网？这加起来不足千行的代码，可以给我们足够多的遐想空间。 这部分代码，涉及到dblite，request，z_schema等第三方组件，以及Ebookcoin自行实现的事件处理方法library.bus(在app.js文件的行)，都很简单，不再分享或赘述，请自行查阅。本篇涉及的代码中，关于回调的设计很多，值得总结和研究。async组件，被反复使用，有必须汇总一下，请关注后续的技术分享。 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 电子书阅读： http://bitcoin-on-nodejs.ebookchain.org 参考 z_schema组件: https://github.com/Ebookcoin/z_schema dblite组件： https://github.com/Ebookcoin/dblite request组件： http://github.com/request/request SQL As Understood By SQLite： https://www.sqlite.org/lang_conflict.html 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2016/05/04/a7878ae7cd17f62140ed6d9879df20e0.html","headline":"《Nodejs开发加密货币》之八：一个精巧的p2p网络实现","dateModified":"2016-05-04T00:00:00+08:00","datePublished":"2016-05-04T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2016/05/04/a7878ae7cd17f62140ed6d9879df20e0.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>《Nodejs开发加密货币》之八：一个精巧的p2p网络实现</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h2 id="关于">关于</h2> 
  <p>《Nodejs开发加密货币》，是一个加密货币产品的详细开发文档，涉及到使用Nodejs开发产品的方方面面，从前端到后台、从服务器到客户端、从PC到移动、加密解密、区款链等各个环节。代码完全开源、文章免费分享。 相关资源见 <a href="http://ebookchain.org" rel="nofollow">http://ebookchain.org</a></p> 
  <p>QQ交流群: 185046161</p> 
  <h2 id="前言">前言</h2> 
  <p>加密货币都是去中心化的应用，去中心化的基础就是P2P网络，其作用和地位不言而喻，无可替代。</p> 
  <p>事实上，P2P网络不是什么新技术。但是，使用Nodejs开发的P2P网络，确实值得围观。这一篇，我们就来看看Ebookcoin的点对点网络是如何实现的。</p> 
  <h2 id="源码">源码</h2> 
  <p>主要源码地址：</p> 
  <p>peer.js: <a href="https://github.com/Ebookcoin/ebookcoin/blob/master/modules/peer.js" rel="nofollow">https://github.com/Ebookcoin/ebookcoin/blob/master/modules/peer.js</a></p> 
  <p>transport.js: <a href="https://github.com/Ebookcoin/ebookcoin/blob/master/modules/transport.js" rel="nofollow">https://github.com/Ebookcoin/ebookcoin/blob/master/modules/transport.js</a></p> 
  <p>router.js: <a href="https://github.com/Ebookcoin/ebookcoin/blob/master/helpers/router.js" rel="nofollow">https://github.com/Ebookcoin/ebookcoin/blob/master/helpers/router.js</a></p> 
  <h2 id="类图">类图</h2> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20160504102101561" alt="peer-class.png" title=""></p> 
  <h2 id="流程图">流程图</h2> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20160504102121769" alt="peer-activity.png" title=""></p> 
  <h2 id="解读">解读</h2> 
  <p>基于http的web应用，抓住路由的定义、设计与实现，是快速弄清业务逻辑的简单方法。目前，分析的是<code>modules</code>文件夹下的各个模块文件，这些模块基本都是独立的Express微应用，在开发和设计上相互独立，各不冲突，逻辑清晰，这为学习分析，提供了便利。</p> 
  <h4 id="1路由扩展">1.路由扩展</h4> 
  <p>任何应用，只要提供Web访问能力或第三方访问的Api，都需要提供从地址到逻辑的请求分发功能，这就是路由。Ebookcoin是基于http协议的Express应用，Express底层基于Nodejs的connect模块，因此其路由设计简单而灵活。</p> 
  <p>前面，在入门部分，已经讲到对路由的分拆调用，这里是其简单实现。先看看<code>helper/router.js</code>吧。</p> 
  <pre class="prettyprint"><code class=" hljs r">// <span class="hljs-number">27</span>行
var Router = <span class="hljs-keyword">function</span> () {
    var router = <span class="hljs-keyword">require</span>(<span class="hljs-string">'express'</span>).Router();

    router.use(<span class="hljs-keyword">function</span> (req, res, <span class="hljs-keyword">next</span>) {
        res.header(<span class="hljs-string">"Access-Control-Allow-Origin"</span>, <span class="hljs-string">"*"</span>);
        res.header(<span class="hljs-string">"Access-Control-Allow-Headers"</span>, <span class="hljs-string">"Origin, X-Requested-With, Content-Type, Accept"</span>);
        <span class="hljs-keyword">next</span>();
    });

    router.map = map;

    <span class="hljs-keyword">return</span> router;
}
<span class="hljs-keyword">...</span></code></pre> 
  <p>这段代码定义了一个Express路由器<code>Router</code>，并扩展了两个功能：</p> 
  <ul> 
   <li>允许任何客户端调用。其实，就是设置了跨域请求，选项<code>Access-Control-Allow-Origin</code>设置为<code>*</code>，自然任何IP和端口的节点都可以访问和被访问。</li> 
   <li>添加了地址映射方法。该方法的主要内容如下：</li> 
  </ul> 
  <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-comment">// 3行</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span><span class="hljs-params">(root, config)</span> {</span>
    <span class="hljs-keyword">var</span> router = <span class="hljs-keyword">this</span>;
    <span class="hljs-built_in">Object</span>.keys(config).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(params)</span> {</span>
        <span class="hljs-keyword">var</span> route = params.split(<span class="hljs-string">" "</span>);
        <span class="hljs-keyword">if</span> (route.length != <span class="hljs-number">2</span> || [<span class="hljs-string">"post"</span>, <span class="hljs-string">"get"</span>, <span class="hljs-string">"put"</span>].indexOf(route[<span class="hljs-number">0</span>]) == -<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"wrong map config"</span>);
        }
        router[route[<span class="hljs-number">0</span>]](route[<span class="hljs-number">1</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res, next)</span> {</span>
            root[config[params]]({<span class="hljs-string">"body"</span>: route[<span class="hljs-number">0</span>] == <span class="hljs-string">"get"</span> ? req.query : req.body}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, response)</span> {</span>
                <span class="hljs-keyword">if</span> (err) {
                    res.json({<span class="hljs-string">"success"</span>: <span class="hljs-literal">false</span>, <span class="hljs-string">"error"</span>: err});
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> res.json(extend({}, {<span class="hljs-string">"success"</span>: <span class="hljs-literal">true</span>}, response));
                }
            });
        });
    });
}</code></pre> 
  <p>该方法，接受两个对象作为参数：</p> 
  <ul> 
   <li>root: 定义了所要开放Api的逻辑函数;</li> 
   <li>config: 定义了路由和root定义的函数的对应关系。</li> 
  </ul> 
  <p>其运行的结果，就相当于：</p> 
  <pre class="prettyprint"><code class=" hljs r">router.get(<span class="hljs-string">'/peers'</span>, <span class="hljs-keyword">function</span>(req, res, <span class="hljs-keyword">next</span>){
    root.getPeers(<span class="hljs-keyword">...</span>);
})</code></pre> 
  <p>这里关键的小技巧是，在js代码中，对象也是hash值，root.getPeers() 与 root<a href="" rel="nofollow">‘getPeers’</a> 是一致的。不过后者可以用字符串变量代替，更加灵活，有点像ruby里的元编程。这是脚本语言的优势（简单的字符串拼接处理）。</p> 
  <p>扩展一下，在类似sails的框架（基于express)里，很多都是可以使用类似<code>config.json</code>的文件直接配置的，包括路由。参考这个函数，很容易理解和实现。</p> 
  <h4 id="2节点路由">2.节点路由</h4> 
  <p>很轻松就能在<code>peer.js</code>里找到上述map方法的使用：</p> 
  <pre class="prettyprint"><code class=" hljs php"><span class="hljs-comment">// 3行</span>
Router = <span class="hljs-keyword">require</span>(<span class="hljs-string">'../helpers/router.js'</span>)

<span class="hljs-comment">// 25</span>
<span class="hljs-keyword">private</span>.attachApi = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> Router();

    router.<span class="hljs-keyword">use</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res, next)</span> {</span>
        <span class="hljs-keyword">if</span> (modules) <span class="hljs-keyword">return</span> next();
        res.status(<span class="hljs-number">500</span>).send({success: <span class="hljs-keyword">false</span>, error: <span class="hljs-string">"Blockchain is loading"</span>});
    });

    <span class="hljs-comment">// 34行</span>
    router.map(shared, {
        <span class="hljs-string">"get /"</span>: <span class="hljs-string">"getPeers"</span>,
        <span class="hljs-string">"get /version"</span>: <span class="hljs-string">"version"</span>,
        <span class="hljs-string">"get /get"</span>: <span class="hljs-string">"getPeer"</span>
    });

    router.<span class="hljs-keyword">use</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res)</span> {</span>
        res.status(<span class="hljs-number">500</span>).send({success: <span class="hljs-keyword">false</span>, error: <span class="hljs-string">"API endpoint not found"</span>});
    });

  <span class="hljs-comment">// 44行</span>
    library.network.app.<span class="hljs-keyword">use</span>(<span class="hljs-string">'/api/peers'</span>, router);
    library.network.app.<span class="hljs-keyword">use</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, req, res, next)</span> {</span>
        <span class="hljs-keyword">if</span> (!err) <span class="hljs-keyword">return</span> next();
        library.logger.error(req.url, err.toString());
        res.status(<span class="hljs-number">500</span>).send({success: <span class="hljs-keyword">false</span>, error: err.toString()});
    });
};</code></pre> 
  <p>上面代码的34行，可以直观想象到，会有类似<code>/version</code>的路由出现，44行是express应用，这里就是将定义好的路由放在<code>/api/peers</code>前缀之下，可以确信<code>peer.js</code>文件提供了下面3个公共Api地址：</p> 
  <blockquote> 
   <p><a href="http://ip:port/api/peers/" rel="nofollow">http://ip:port/api/peers/</a></p> 
   <p><a href="http://ip:port/api/peers/version" rel="nofollow">http://ip:port/api/peers/version</a></p> 
   <p><a href="http://ip:port/api/peers/get" rel="nofollow">http://ip:port/api/peers/get</a></p> 
  </blockquote> 
  <p>当然，是不是可以直接这么调用，要看具体对应的函数是否还有其他的参数要求，比如：<code>/api/peers/get</code>，按照restful的api设计原则，可以理解为是获得具体某个节点信息，那么总该给个<code>id</code>之类的限定条件吧。看源码：</p> 
  <pre class="prettyprint"><code class=" hljs r">// <span class="hljs-number">455</span>行
library.scheme.validate(query, {
        type: <span class="hljs-string">"object"</span>,
        properties: {
            ip_str: {
                type: <span class="hljs-string">"string"</span>,
                minLength: <span class="hljs-number">1</span>
            },
            port: {
                type: <span class="hljs-string">"integer"</span>,
                minimum: <span class="hljs-number">0</span>,
                maximum: <span class="hljs-number">65535</span>
            }
        },
        required: [<span class="hljs-string">'ip_str'</span>, <span class="hljs-string">'port'</span>]
    }, <span class="hljs-keyword">function</span> (err) {
        <span class="hljs-keyword">...</span>
        // <span class="hljs-number">480</span>行
        private.getByFilter({
            <span class="hljs-keyword">...</span>
        });
    });</code></pre> 
  <p>这里，在具体运行过程中，library就是<code>app.js</code>里传过来的<code>scope</code>，该参数包含的scheme代表了一个<code>z_schema</code>实例。</p> 
  <p><code>z_schema</code>是一个第三方组件，具体请看参考链接。该组件提供了json数据格式验证功能。上述代码的意思是：对请求参数<code>query</code>进行验证，验证规则是：object类型，属性<code>ip_str</code>要求长度不小于1的字符串，属性<code>port</code>要求0~65535之间的整数，并且都不能空（必需）。</p> 
  <p>这就说明，我们应该这样请求<code>http://ip:port/api/peers/get?ip_str=0.0.0.0&amp;port=1234</code>，不然会返回错误信息。回头看看<code>getPeers</code>方法的实现，没有<code>required</code>字段，对应可以直接访问<code>http://ip:port/api/peers/</code>。</p> 
  <p>看480行，上面的地址，都会调用<code>private.getByFilter()</code>，并由它从sqlite数据库里查询数据表<code>peers</code>。这里涉及到 　<a href="https://github.com/Ebookcoin/dblite" rel="nofollow">dblite第三方组件</a> 　(请看参考链接)，对请求操作sqlite数据库进行了简单封装。</p> 
  <h4 id="3节点保存">3.节点保存</h4> 
  <p>大多数应用，读数据相对简单，难在写数据。上面的代码，都是<code>get</code>请求，可以查寻节点及其信息。我们自然会问，查询的信息从哪里来？初始的节点在哪里？节点变更了，怎么办？</p> 
  <p><strong>（1）初始化节点</strong></p> 
  <p>从现实角度考虑，在一个P2P网络中，一个孤立的节点，在没有其他任何节点信息的情况下，仅仅靠网络扫描去寻找其他节点，将是一件很难完成的事情，更别提高效和安全了。</p> 
  <p>因此，在运行软件之前，初始化一些节点供联网使用，是最简单直接的解决方案。这个在配置文件<code>config.json</code>里，有直接体现：</p> 
  <pre class="prettyprint"><code class=" hljs r">// config.json <span class="hljs-number">15</span>行
<span class="hljs-string">"peers"</span>: {
        <span class="hljs-string">"list"</span>: [],
        <span class="hljs-string">"blackList"</span>: [],
        <span class="hljs-string">"options"</span>: {
                <span class="hljs-string">"timeout"</span>: <span class="hljs-number">4000</span>
        }
},
<span class="hljs-keyword">...</span></code></pre> 
  <p>list的数据格式为：</p> 
  <pre class="prettyprint"><code class=" hljs r">[
    {
        ip: <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>,
        port: <span class="hljs-number">7000</span>
    },
    <span class="hljs-keyword">...</span>
]</code></pre> 
  <p>当然，也可以在启动的时候，通过参数<code>--peers 1.2.3.4:70001, 2.1.2.3:7002</code>提供（代码见<code>app.js</code>47行）。</p> 
  <p><strong>（2）写入节点</strong></p> 
  <p>写入节点，就是持久化，或者保存到数据库，或者保存到某个文件。这里保存到sqlite3数据库里的<code>peers</code>表了，代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs php"><span class="hljs-comment">// peer.js 347行</span>
Peer.prototype.onBlockchainReady = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    async.eachSeries(library.config.peers.<span class="hljs-keyword">list</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(peer, cb)</span> {</span>
        library.dbLite.query(<span class="hljs-string">"INSERT OR IGNORE INTO peers(ip, port, state, sharePort) VALUES($ip, $port, $state, $sharePort)"</span>, {
            ip: ip.toLong(peer.ip),
            port: peer.port,
            state: <span class="hljs-number">2</span>, <span class="hljs-comment">//初始状态为2，都是健康的节点</span>
            sharePort: Number(<span class="hljs-keyword">true</span>)
        }, cb);
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
        <span class="hljs-keyword">if</span> (err) {
            library.logger.error(<span class="hljs-string">'onBlockchainReady'</span>, err);
        }

        <span class="hljs-keyword">private</span>.count(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, count)</span> {</span>
            <span class="hljs-keyword">if</span> (count) {
                <span class="hljs-keyword">private</span>.updatePeerList(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
                    err &amp;&amp; library.logger.error(<span class="hljs-string">'updatePeerList'</span>, err);
                    library.bus.message(<span class="hljs-string">'peerReady'</span>);
                })
                library.logger.info(<span class="hljs-string">'Peers ready, stored '</span> + count);
            } <span class="hljs-keyword">else</span> {
                library.logger.warn(<span class="hljs-string">'Peers list is empty'</span>);
            }
        });
    });
}</code></pre> 
  <p>这段代码的意思是，当区块链（后面篇章分析）加载完毕的时候（触发事件），依次将配置的节点写入数据库，如果数据库已经存在相同的记录就忽略，然后更新节点列表，触发节点加载完毕事件。</p> 
  <p>这里对数据库<code>Sqlite</code>的插入操作，插入语句是<code>library.dbLite.query("INSERT OR IGNORE INTO peers</code>，有意思的是<code>IGNORE</code>操作字符串，是sqlite3支持的（见参考），当数据库有相同记录的时候，该记录被忽略，继续往下执行。</p> 
  <p>执行成功，就会调用<code>library.bus.message('peerReady')</code>，进而触发<code>peerReady</code>事件。该事件的功能就是：</p> 
  <p><strong>（3）更新节点</strong></p> 
  <p>事件<code>onPeerReady</code>函数，如下：</p> 
  <pre class="prettyprint"><code class=" hljs php"><span class="hljs-comment">// peer.js 374行</span>
Peer.prototype.onPeerReady = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    setImmediate(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextUpdatePeerList</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">private</span>.updatePeerList(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
            err &amp;&amp; library.logger.error(<span class="hljs-string">'updatePeerList timer'</span>, err);
            setTimeout(nextUpdatePeerList, <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>);
        })
    });

    setImmediate(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextBanManager</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">private</span>.banManager(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
            err &amp;&amp; library.logger.error(<span class="hljs-string">'banManager timer'</span>, err);
            setTimeout(nextBanManager, <span class="hljs-number">65</span> * <span class="hljs-number">1000</span>)
        });
    });
}</code></pre> 
  <p>两个<code>setImmediate</code>函数的调用，一个循环更新节点列表，一个循环更新节点状态。</p> 
  <p><strong>第一个循环调用</strong></p> 
  <p>看看第一个循环调用的函数<code>updatePeerList</code>，</p> 
  <pre class="prettyprint"><code class=" hljs r">private.updatePeerList = <span class="hljs-keyword">function</span> (cb) {
    // <span class="hljs-number">53</span>行
    modules.transport.getFromRandomPeer({
        api: <span class="hljs-string">'/list'</span>,
        method: <span class="hljs-string">'GET'</span>
    }, <span class="hljs-keyword">function</span> (err, data) {
        <span class="hljs-keyword">...</span>
        library.scheme.validate(data.body, {
                    <span class="hljs-keyword">...</span>
                    // <span class="hljs-number">124</span>行
                    self.update(peer, cb);
                });
            }, cb);
        });
    });
};</code></pre> 
  <p>看53行，我们知道，程序通过<code>transport</code>模块的<code>.getFromRandomPeer</code>方法，逐个随机的验证节点信息，并将其做删除和更新处理。如此一来，各种调用关系更加清晰，看流程图更加直观。<code>.getFromRandomPeer</code>的代码：</p> 
  <pre class="prettyprint"><code class=" hljs r">// transport.js <span class="hljs-number">474</span>行
Transport.prototype.getFromRandomPeer = <span class="hljs-keyword">function</span> (config, options, cb) {
    <span class="hljs-keyword">...</span>

    // <span class="hljs-number">481</span>行
    async.retry(<span class="hljs-number">20</span>, <span class="hljs-keyword">function</span> (cb) {
        modules.peer.list(config, <span class="hljs-keyword">function</span> (err, peers) {
            <span class="hljs-keyword">if</span> (!err &amp;&amp; peers.length) {
                var peer = peers[<span class="hljs-number">0</span>];

                // <span class="hljs-number">485</span>行
                self.getFromPeer(peer, options, cb);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> cb(err || <span class="hljs-string">"No peers in db"</span>);
            }
        });
   <span class="hljs-keyword">...</span>
};</code></pre> 
  <p>代码很简单，重要的是理解<code>async.retry</code>的用法（下篇技术分享，详细学习），该方法就是要重复调用第一个task函数20次，有正确返回结果就传给回调函数。这里，只要查到一个节点，就会传给485行的<code>getFromPeer</code>函数，该函数是检验处理现存节点的核心函数，代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs r">// transport.js <span class="hljs-number">500</span>行
Transport.prototype.getFromPeer = <span class="hljs-keyword">function</span> (peer, options, cb) {
    <span class="hljs-keyword">...</span>
    var req = {
        // <span class="hljs-number">519</span>行： 获得节点地址
        url: <span class="hljs-string">'http://'</span> + ip.fromLong(peer.ip) + <span class="hljs-string">':'</span> + peer.port + url,
        <span class="hljs-keyword">...</span>
    };

    // <span class="hljs-number">532</span>行： 使用`request`组件发送请求
    <span class="hljs-keyword">return</span> request(req, <span class="hljs-keyword">function</span> (err, response, body) {
        <span class="hljs-keyword">if</span> (err || response.statusCode != <span class="hljs-number">200</span>) {
            <span class="hljs-keyword">...</span>
            <span class="hljs-keyword">if</span> (peer) {
                <span class="hljs-keyword">if</span> (err &amp;&amp; (err.code == <span class="hljs-string">"ETIMEDOUT"</span> || err.code == <span class="hljs-string">"ESOCKETTIMEDOUT"</span> || err.code == <span class="hljs-string">"ECONNREFUSED"</span>)) {

                    // <span class="hljs-number">542</span>行： 对于无法请求的，自然要删除
                    modules.peer.remove(peer.ip, peer.port, <span class="hljs-keyword">function</span> (err) {
                    <span class="hljs-keyword">...</span>
                    });
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (!options.not_ban) {

                        // <span class="hljs-number">549</span>行： 对于状态码不是<span class="hljs-number">200</span>的，比如<span class="hljs-number">304</span>等禁止状态，就要更改其状态
                        modules.peer.state(peer.ip, peer.port, <span class="hljs-number">0</span>, <span class="hljs-number">600</span>, <span class="hljs-keyword">function</span> (err) {
                        <span class="hljs-keyword">...</span>
                        });
                    }
                }
            }
            cb &amp;&amp; cb(err || (<span class="hljs-string">'request status code'</span> + response.statusCode));
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">...</span>
        <span class="hljs-keyword">if</span> (port &gt; <span class="hljs-number">0</span> &amp;&amp; port &lt;= <span class="hljs-number">65535</span> &amp;&amp; response.headers[<span class="hljs-string">'version'</span>] == library.config.version) {
            // <span class="hljs-number">595</span>行： 一切问题都不存在
            modules.peer.update({
                ip: peer.ip,
                port: port,
                state: <span class="hljs-number">2</span>, // <span class="hljs-number">598</span>行： 看来健康的节点状态为<span class="hljs-number">2</span>
                <span class="hljs-keyword">...</span>
    });
}</code></pre> 
  <p>这里最重要的是532行，<code>request</code>第三方组件的使用，请看参考链接。官方定义为简单的http客户端，功能足够强大，可以模拟浏览器访问信息，经常被用来做测试。</p> 
  <p><strong>第二个循环调用</strong></p> 
  <p>第二个循环调用的函数很简单，就是循环更改<code>state</code>和<code>clock</code>字段，主要是将禁止的状态<code>state=0</code>，修改为<code>1</code>，如下：</p> 
  <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-comment">// 142行</span>
private.banManager = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> {</span>
    library.dbLite.query(<span class="hljs-string">"UPDATE peers SET state = 1, clock = null where (state = 0 and clock - $now &lt; 0)"</span>, {now: <span class="hljs-built_in">Date</span>.now()}, cb);
}</code></pre> 
  <p>综上，整个P2P网络的读写和更新都已经清楚，回头再看活动图和类图，就更加明朗了。</p> 
  <p>最后，补充一下数据库里，节点表格<code>peers</code>的字段信息：　</p> 
  <pre class="prettyprint"><code class=" hljs applescript"><span class="hljs-property">id</span>,ip,port,state,os,sharePort,<span class="hljs-property">version</span>,clock</code></pre> 
  <h2 id="总结">总结</h2> 
  <p>本篇，重点阅读了<code>peer.js</code>文件，学习了一个使用Nodejs开发的P2P网络架构，其特点是：</p> 
  <ul> 
   <li>产品提供初始节点列表，保障了初始化节点快速完成，不至于成为孤立节点;</li> 
   <li>节点具备跨域访问能力，任何节点之间都可以自由访问;</li> 
   <li>节点具备自我更新能力，定期查询和更新死掉的节点，保障网络始终畅通;</li> 
  </ul> 
  <p>一旦达到一定的节点数量，就会形成一个互联互通的<code>不死网络</code>。搭建在这种网络上的服务，会充满怎样的诱惑？加密货币为什么会被认为是下一代互联网？这加起来不足千行的代码，可以给我们足够多的遐想空间。</p> 
  <p>这部分代码，涉及到<code>dblite，request，z_schema</code>等第三方组件，以及Ebookcoin自行实现的事件处理方法<code>library.bus</code>(在<code>app.js</code>文件的行)，都很简单，不再分享或赘述，请自行查阅。本篇涉及的代码中，关于回调的设计很多，值得总结和研究。<code>async</code>组件，被反复使用，有必须汇总一下，请关注后续的技术分享。</p> 
  <h2 id="链接">链接</h2> 
  <p><strong>本系列文章即时更新，若要掌握最新内容，请关注下面的链接</strong></p> 
  <p>本源文地址： <a href="https://github.com/imfly/bitcoin-on-nodejs" rel="nofollow">https://github.com/imfly/bitcoin-on-nodejs</a></p> 
  <p>电子书阅读： <a href="http://bitcoin-on-nodejs.ebookchain.org/3-源码解读/3-一个精巧的p2p网络实现.html" rel="nofollow">http://bitcoin-on-nodejs.ebookchain.org</a></p> 
  <h2 id="参考">参考</h2> 
  <p>z_schema组件: <a href="https://github.com/Ebookcoin/z_schema" rel="nofollow">https://github.com/Ebookcoin/z_schema</a></p> 
  <p>dblite组件： <a href="https://github.com/Ebookcoin/dblite" rel="nofollow">https://github.com/Ebookcoin/dblite</a></p> 
  <p>request组件： <a href="http://github.com/request/request" rel="nofollow">http://github.com/request/request</a></p> 
  <p>SQL As Understood By SQLite： <a href="https://www.sqlite.org/lang_conflict.html" rel="nofollow">https://www.sqlite.org/lang_conflict.html</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/imfly/article/details/51312812,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/imfly/article/details/51312812,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
