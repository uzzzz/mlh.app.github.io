<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>SM2算法第二十八篇：Openssl有关大数运算函数介绍（全面） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="SM2算法第二十八篇：Openssl有关大数运算函数介绍（全面）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1．初始化函数 &nbsp; BIGNUM *BN_new(void);&nbsp;&nbsp;&nbsp; 新生成一个BIGNUM结构 &nbsp; void BN_free(BIGNUM *a);&nbsp;&nbsp; 释放一个BIGNUM结构，释放完后a=NULL; &nbsp; void BN_init(BIGNUM *);&nbsp;&nbsp;&nbsp; 初始化所有项均为0，一般为BN_ init(&amp;c) &nbsp; void BN_clear(BIGNUM *a);&nbsp; 将a中所有项均赋值为0，但是内存并没有释放 &nbsp; void BN_clear_free(BIGNUM *a); 相当与将BN_free和BN_clear综合，要不就赋值0，要不就释放空间。 &nbsp; 2．上下文情景函数，存储计算中的中间过程 BN_CTX *BN_CTX_new(void);申请一个新的上下文结构 &nbsp; void BN_CTX_init(BN_CTX *c);将所有的项赋值为0，一般BN_CTX_init(&amp;c) &nbsp; &nbsp;&nbsp;void BN_CTX_free(BN_CTX *c);释放上下文结构，释放完后c=NULL; &nbsp; 3．复制以及交换函数 &nbsp; BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);将b复制给a,正确返回a，错误返回NULL &nbsp; &nbsp; BIGNUM *BN_dup(const BIGNUM *a);新建一个BIGNUM结构，将a复制给新建结构返回，错误返回NULL &nbsp; &nbsp; BIGNUM *BN_swap(BIGNUM *a, BIGNUM *b);交换a,b &nbsp; 4．取位函数 &nbsp; &nbsp;int BN_num_bytes(const BIGNUM *a);返回a的位数，大量使用 &nbsp; int BN_num_bits(const BIGNUM *a); &nbsp; int BN_num_bits_word(BN_ULONG w);他返回有意义比特的位数，例如0x00000432 为11。 &nbsp; 5．基本计算函数 &nbsp; &nbsp;int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);r=a+b &nbsp; int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);r=a-b &nbsp; int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);r=a*b &nbsp; int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);r=a*a,效率高于bn_mul(r,a,a) &nbsp; int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);d=a/b,r=a%b &nbsp; int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);r=a%b &nbsp; int BN_nnmod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);r=abs(a%b) &nbsp; int BN_mod_add(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);r=abs((a+b)%m)) &nbsp; int BN_mod_sub(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx); r=abs((a-b)%m)) &nbsp; int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;BN_CTX *ctx); r=abs((a*b)%m)) &nbsp; int BN_mod_sqr(BIGNUM *ret, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx); r=abs((a*a)%m)) &nbsp; int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);r=pow(a,p) &nbsp; int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const BIGNUM *m, BN_CTX *ctx); r=pow(a,p)%M &nbsp; int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);r=a,b最大公约数 &nbsp; int BN_add_word(BIGNUM *a, BN_ULONG w); &nbsp; int BN_sub_word(BIGNUM *a, BN_ULONG w); &nbsp; int BN_mul_word(BIGNUM *a, BN_ULONG w); &nbsp; BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w); &nbsp; BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w); &nbsp; BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);模逆，((a*r)%n==1). &nbsp; &nbsp; &nbsp; 6．比较函数 &nbsp;int BN_cmp(BIGNUM *a, BIGNUM *b); &nbsp;&nbsp;-1 if a &lt; b, 0 if a == b and 1 if a &gt; b. &nbsp; int BN_ucmp(BIGNUM *a, BIGNUM *b);&nbsp; 比较a,b觉得值，返回值和上同。 &nbsp; int BN_is_zero(BIGNUM *a); &nbsp; int BN_is_one(BIGNUM *a); &nbsp; int BN_is_word(BIGNUM *a, BN_ULONG w); &nbsp; int BN_is_odd(BIGNUM *a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上面四个返回1，假如条件成立，否则将返回0 &nbsp; 7．设置函数 &nbsp;int BN_zero(BIGNUM *a);&nbsp; 设置a为0 &nbsp; int BN_one(BIGNUM *a);&nbsp;&nbsp; 设置a为1 &nbsp; const BIGNUM *BN_value_one(void); 返回一个为1的大数 &nbsp; int BN_set_word(BIGNUM *a, unsigned long w); 设置a为w &nbsp; unsigned long BN_get_word(BIGNUM *a); 假如a能表示为long型，那么返回一个long型数 &nbsp; 8．随机数函数 &nbsp;int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);产生一个加密用的强bits的伪随机数，若top=-1，最高位为0，top=0， 最高位为1，top=1,最高位和次高位为1，bottom为真，随机数为偶数 &nbsp; &nbsp;int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);产生一个伪随机数，应用于某些目的。 &nbsp; int BN_rand_range(BIGNUM *rnd, BIGNUM *range);产生的0&lt;rnd&lt;range &nbsp; int BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);同上面道理 &nbsp; 9．产生素数函数 BIGNUM *BN_generate_prime(BIGNUM *ret, int bits,int safe, BIGNUM *add, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);产生一个bits位的素数，后面几个参数都可以为NULL &nbsp; int BN_is_prime(const BIGNUM *p, int nchecks, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg); &nbsp; 判断是否为素数，返回0表示成功，1表示错误概率小于0。25，-1表示错误 &nbsp; 10．位数函数 &nbsp;int BN_set_bit(BIGNUM *a, int n);将a中的第n位设置为1，假如a小于n位将扩展 &nbsp; int BN_clear_bit(BIGNUM *a, int n);将a中的第n为设置为0，假如a小于n位将出错 &nbsp; int BN_is_bit_set(const BIGNUM *a, int n);测试是否已经设置，1表示已设置 &nbsp; int BN_mask_bits(BIGNUM *a, int n);将a截断至n位，假如a小于n位将出错 &nbsp; int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);a左移n位，结果存于r &nbsp; int BN_lshift1(BIGNUM *r, BIGNUM *a); a左移1位，结果存于r &nbsp; int BN_rshift(BIGNUM *r, BIGNUM *a, int n); a右移n位，结果存于r &nbsp; int BN_rshift1(BIGNUM *r, BIGNUM *a); a左移1位，结果存于r &nbsp; 11．与字符串的转换函数 int BN_bn2bin(const BIGNUM *a, unsigned char *to);将abs（a）转化为字符串存入to，to的空间必须大于BN_num_bytes(a) &nbsp; BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);将s中的len位的正整数转化为大数 &nbsp; char *BN_bn2hex(const BIGNUM *a);转化为16进制字符串 &nbsp; char *BN_bn2dec(const BIGNUM *a);转化为10进制字符串 &nbsp; int BN_hex2bn(BIGNUM **a, const char *str);同上理 &nbsp; int BN_dec2bn(BIGNUM **a, const char *str);同上理 &nbsp; int BN_print(BIO *fp, const BIGNUM *a);将大数16进制形式写入内存中 &nbsp; int BN_print_fp(FILE *fp, const BIGNUM *a); 将大数16进制形式写入文件 &nbsp; int BN_bn2mpi(const BIGNUM *a, unsigned char *to); &nbsp; BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret); &nbsp; 12．其他函数 下面函数可以进行更有效率的模乘和模除，假如在重复在同一模下重复进行模乘和模除计算，计算r=(a*b)%m 利用了recp=1/m &nbsp; BN_RECP_CTX *BN_RECP_CTX_new(void); &nbsp; void BN_RECP_CTX_init(BN_RECP_CTX *recp); &nbsp; void BN_RECP_CTX_free(BN_RECP_CTX *recp); &nbsp; int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx); &nbsp; int BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b, &nbsp; BN_RECP_CTX *recp, BN_CTX *ctx); &nbsp; 下面函数采用蒙哥马利算法进行模幂计算，可以提高效率，他也主要应用于在同一模下进行多次幂运算 &nbsp; BN_MONT_CTX *BN_MONT_CTX_new(void); &nbsp; void BN_MONT_CTX_init(BN_MONT_CTX *ctx); &nbsp; void BN_MONT_CTX_free(BN_MONT_CTX *mont); &nbsp; int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx); &nbsp; BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from); &nbsp; int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_MONT_CTX *mont, BN_CTX *ctx); &nbsp; int BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx); &nbsp; int BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx); 阅读更多" />
<meta property="og:description" content="1．初始化函数 &nbsp; BIGNUM *BN_new(void);&nbsp;&nbsp;&nbsp; 新生成一个BIGNUM结构 &nbsp; void BN_free(BIGNUM *a);&nbsp;&nbsp; 释放一个BIGNUM结构，释放完后a=NULL; &nbsp; void BN_init(BIGNUM *);&nbsp;&nbsp;&nbsp; 初始化所有项均为0，一般为BN_ init(&amp;c) &nbsp; void BN_clear(BIGNUM *a);&nbsp; 将a中所有项均赋值为0，但是内存并没有释放 &nbsp; void BN_clear_free(BIGNUM *a); 相当与将BN_free和BN_clear综合，要不就赋值0，要不就释放空间。 &nbsp; 2．上下文情景函数，存储计算中的中间过程 BN_CTX *BN_CTX_new(void);申请一个新的上下文结构 &nbsp; void BN_CTX_init(BN_CTX *c);将所有的项赋值为0，一般BN_CTX_init(&amp;c) &nbsp; &nbsp;&nbsp;void BN_CTX_free(BN_CTX *c);释放上下文结构，释放完后c=NULL; &nbsp; 3．复制以及交换函数 &nbsp; BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);将b复制给a,正确返回a，错误返回NULL &nbsp; &nbsp; BIGNUM *BN_dup(const BIGNUM *a);新建一个BIGNUM结构，将a复制给新建结构返回，错误返回NULL &nbsp; &nbsp; BIGNUM *BN_swap(BIGNUM *a, BIGNUM *b);交换a,b &nbsp; 4．取位函数 &nbsp; &nbsp;int BN_num_bytes(const BIGNUM *a);返回a的位数，大量使用 &nbsp; int BN_num_bits(const BIGNUM *a); &nbsp; int BN_num_bits_word(BN_ULONG w);他返回有意义比特的位数，例如0x00000432 为11。 &nbsp; 5．基本计算函数 &nbsp; &nbsp;int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);r=a+b &nbsp; int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);r=a-b &nbsp; int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);r=a*b &nbsp; int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);r=a*a,效率高于bn_mul(r,a,a) &nbsp; int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);d=a/b,r=a%b &nbsp; int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);r=a%b &nbsp; int BN_nnmod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);r=abs(a%b) &nbsp; int BN_mod_add(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);r=abs((a+b)%m)) &nbsp; int BN_mod_sub(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx); r=abs((a-b)%m)) &nbsp; int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;BN_CTX *ctx); r=abs((a*b)%m)) &nbsp; int BN_mod_sqr(BIGNUM *ret, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx); r=abs((a*a)%m)) &nbsp; int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);r=pow(a,p) &nbsp; int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const BIGNUM *m, BN_CTX *ctx); r=pow(a,p)%M &nbsp; int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);r=a,b最大公约数 &nbsp; int BN_add_word(BIGNUM *a, BN_ULONG w); &nbsp; int BN_sub_word(BIGNUM *a, BN_ULONG w); &nbsp; int BN_mul_word(BIGNUM *a, BN_ULONG w); &nbsp; BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w); &nbsp; BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w); &nbsp; BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);模逆，((a*r)%n==1). &nbsp; &nbsp; &nbsp; 6．比较函数 &nbsp;int BN_cmp(BIGNUM *a, BIGNUM *b); &nbsp;&nbsp;-1 if a &lt; b, 0 if a == b and 1 if a &gt; b. &nbsp; int BN_ucmp(BIGNUM *a, BIGNUM *b);&nbsp; 比较a,b觉得值，返回值和上同。 &nbsp; int BN_is_zero(BIGNUM *a); &nbsp; int BN_is_one(BIGNUM *a); &nbsp; int BN_is_word(BIGNUM *a, BN_ULONG w); &nbsp; int BN_is_odd(BIGNUM *a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上面四个返回1，假如条件成立，否则将返回0 &nbsp; 7．设置函数 &nbsp;int BN_zero(BIGNUM *a);&nbsp; 设置a为0 &nbsp; int BN_one(BIGNUM *a);&nbsp;&nbsp; 设置a为1 &nbsp; const BIGNUM *BN_value_one(void); 返回一个为1的大数 &nbsp; int BN_set_word(BIGNUM *a, unsigned long w); 设置a为w &nbsp; unsigned long BN_get_word(BIGNUM *a); 假如a能表示为long型，那么返回一个long型数 &nbsp; 8．随机数函数 &nbsp;int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);产生一个加密用的强bits的伪随机数，若top=-1，最高位为0，top=0， 最高位为1，top=1,最高位和次高位为1，bottom为真，随机数为偶数 &nbsp; &nbsp;int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);产生一个伪随机数，应用于某些目的。 &nbsp; int BN_rand_range(BIGNUM *rnd, BIGNUM *range);产生的0&lt;rnd&lt;range &nbsp; int BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);同上面道理 &nbsp; 9．产生素数函数 BIGNUM *BN_generate_prime(BIGNUM *ret, int bits,int safe, BIGNUM *add, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);产生一个bits位的素数，后面几个参数都可以为NULL &nbsp; int BN_is_prime(const BIGNUM *p, int nchecks, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg); &nbsp; 判断是否为素数，返回0表示成功，1表示错误概率小于0。25，-1表示错误 &nbsp; 10．位数函数 &nbsp;int BN_set_bit(BIGNUM *a, int n);将a中的第n位设置为1，假如a小于n位将扩展 &nbsp; int BN_clear_bit(BIGNUM *a, int n);将a中的第n为设置为0，假如a小于n位将出错 &nbsp; int BN_is_bit_set(const BIGNUM *a, int n);测试是否已经设置，1表示已设置 &nbsp; int BN_mask_bits(BIGNUM *a, int n);将a截断至n位，假如a小于n位将出错 &nbsp; int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);a左移n位，结果存于r &nbsp; int BN_lshift1(BIGNUM *r, BIGNUM *a); a左移1位，结果存于r &nbsp; int BN_rshift(BIGNUM *r, BIGNUM *a, int n); a右移n位，结果存于r &nbsp; int BN_rshift1(BIGNUM *r, BIGNUM *a); a左移1位，结果存于r &nbsp; 11．与字符串的转换函数 int BN_bn2bin(const BIGNUM *a, unsigned char *to);将abs（a）转化为字符串存入to，to的空间必须大于BN_num_bytes(a) &nbsp; BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);将s中的len位的正整数转化为大数 &nbsp; char *BN_bn2hex(const BIGNUM *a);转化为16进制字符串 &nbsp; char *BN_bn2dec(const BIGNUM *a);转化为10进制字符串 &nbsp; int BN_hex2bn(BIGNUM **a, const char *str);同上理 &nbsp; int BN_dec2bn(BIGNUM **a, const char *str);同上理 &nbsp; int BN_print(BIO *fp, const BIGNUM *a);将大数16进制形式写入内存中 &nbsp; int BN_print_fp(FILE *fp, const BIGNUM *a); 将大数16进制形式写入文件 &nbsp; int BN_bn2mpi(const BIGNUM *a, unsigned char *to); &nbsp; BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret); &nbsp; 12．其他函数 下面函数可以进行更有效率的模乘和模除，假如在重复在同一模下重复进行模乘和模除计算，计算r=(a*b)%m 利用了recp=1/m &nbsp; BN_RECP_CTX *BN_RECP_CTX_new(void); &nbsp; void BN_RECP_CTX_init(BN_RECP_CTX *recp); &nbsp; void BN_RECP_CTX_free(BN_RECP_CTX *recp); &nbsp; int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx); &nbsp; int BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b, &nbsp; BN_RECP_CTX *recp, BN_CTX *ctx); &nbsp; 下面函数采用蒙哥马利算法进行模幂计算，可以提高效率，他也主要应用于在同一模下进行多次幂运算 &nbsp; BN_MONT_CTX *BN_MONT_CTX_new(void); &nbsp; void BN_MONT_CTX_init(BN_MONT_CTX *ctx); &nbsp; void BN_MONT_CTX_free(BN_MONT_CTX *mont); &nbsp; int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx); &nbsp; BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from); &nbsp; int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_MONT_CTX *mont, BN_CTX *ctx); &nbsp; int BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx); &nbsp; int BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx); 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"1．初始化函数 &nbsp; BIGNUM *BN_new(void);&nbsp;&nbsp;&nbsp; 新生成一个BIGNUM结构 &nbsp; void BN_free(BIGNUM *a);&nbsp;&nbsp; 释放一个BIGNUM结构，释放完后a=NULL; &nbsp; void BN_init(BIGNUM *);&nbsp;&nbsp;&nbsp; 初始化所有项均为0，一般为BN_ init(&amp;c) &nbsp; void BN_clear(BIGNUM *a);&nbsp; 将a中所有项均赋值为0，但是内存并没有释放 &nbsp; void BN_clear_free(BIGNUM *a); 相当与将BN_free和BN_clear综合，要不就赋值0，要不就释放空间。 &nbsp; 2．上下文情景函数，存储计算中的中间过程 BN_CTX *BN_CTX_new(void);申请一个新的上下文结构 &nbsp; void BN_CTX_init(BN_CTX *c);将所有的项赋值为0，一般BN_CTX_init(&amp;c) &nbsp; &nbsp;&nbsp;void BN_CTX_free(BN_CTX *c);释放上下文结构，释放完后c=NULL; &nbsp; 3．复制以及交换函数 &nbsp; BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);将b复制给a,正确返回a，错误返回NULL &nbsp; &nbsp; BIGNUM *BN_dup(const BIGNUM *a);新建一个BIGNUM结构，将a复制给新建结构返回，错误返回NULL &nbsp; &nbsp; BIGNUM *BN_swap(BIGNUM *a, BIGNUM *b);交换a,b &nbsp; 4．取位函数 &nbsp; &nbsp;int BN_num_bytes(const BIGNUM *a);返回a的位数，大量使用 &nbsp; int BN_num_bits(const BIGNUM *a); &nbsp; int BN_num_bits_word(BN_ULONG w);他返回有意义比特的位数，例如0x00000432 为11。 &nbsp; 5．基本计算函数 &nbsp; &nbsp;int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);r=a+b &nbsp; int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);r=a-b &nbsp; int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);r=a*b &nbsp; int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);r=a*a,效率高于bn_mul(r,a,a) &nbsp; int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);d=a/b,r=a%b &nbsp; int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);r=a%b &nbsp; int BN_nnmod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);r=abs(a%b) &nbsp; int BN_mod_add(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);r=abs((a+b)%m)) &nbsp; int BN_mod_sub(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx); r=abs((a-b)%m)) &nbsp; int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;BN_CTX *ctx); r=abs((a*b)%m)) &nbsp; int BN_mod_sqr(BIGNUM *ret, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx); r=abs((a*a)%m)) &nbsp; int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);r=pow(a,p) &nbsp; int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const BIGNUM *m, BN_CTX *ctx); r=pow(a,p)%M &nbsp; int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);r=a,b最大公约数 &nbsp; int BN_add_word(BIGNUM *a, BN_ULONG w); &nbsp; int BN_sub_word(BIGNUM *a, BN_ULONG w); &nbsp; int BN_mul_word(BIGNUM *a, BN_ULONG w); &nbsp; BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w); &nbsp; BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w); &nbsp; BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);模逆，((a*r)%n==1). &nbsp; &nbsp; &nbsp; 6．比较函数 &nbsp;int BN_cmp(BIGNUM *a, BIGNUM *b); &nbsp;&nbsp;-1 if a &lt; b, 0 if a == b and 1 if a &gt; b. &nbsp; int BN_ucmp(BIGNUM *a, BIGNUM *b);&nbsp; 比较a,b觉得值，返回值和上同。 &nbsp; int BN_is_zero(BIGNUM *a); &nbsp; int BN_is_one(BIGNUM *a); &nbsp; int BN_is_word(BIGNUM *a, BN_ULONG w); &nbsp; int BN_is_odd(BIGNUM *a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上面四个返回1，假如条件成立，否则将返回0 &nbsp; 7．设置函数 &nbsp;int BN_zero(BIGNUM *a);&nbsp; 设置a为0 &nbsp; int BN_one(BIGNUM *a);&nbsp;&nbsp; 设置a为1 &nbsp; const BIGNUM *BN_value_one(void); 返回一个为1的大数 &nbsp; int BN_set_word(BIGNUM *a, unsigned long w); 设置a为w &nbsp; unsigned long BN_get_word(BIGNUM *a); 假如a能表示为long型，那么返回一个long型数 &nbsp; 8．随机数函数 &nbsp;int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);产生一个加密用的强bits的伪随机数，若top=-1，最高位为0，top=0， 最高位为1，top=1,最高位和次高位为1，bottom为真，随机数为偶数 &nbsp; &nbsp;int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);产生一个伪随机数，应用于某些目的。 &nbsp; int BN_rand_range(BIGNUM *rnd, BIGNUM *range);产生的0&lt;rnd&lt;range &nbsp; int BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);同上面道理 &nbsp; 9．产生素数函数 BIGNUM *BN_generate_prime(BIGNUM *ret, int bits,int safe, BIGNUM *add, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);产生一个bits位的素数，后面几个参数都可以为NULL &nbsp; int BN_is_prime(const BIGNUM *p, int nchecks, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg); &nbsp; 判断是否为素数，返回0表示成功，1表示错误概率小于0。25，-1表示错误 &nbsp; 10．位数函数 &nbsp;int BN_set_bit(BIGNUM *a, int n);将a中的第n位设置为1，假如a小于n位将扩展 &nbsp; int BN_clear_bit(BIGNUM *a, int n);将a中的第n为设置为0，假如a小于n位将出错 &nbsp; int BN_is_bit_set(const BIGNUM *a, int n);测试是否已经设置，1表示已设置 &nbsp; int BN_mask_bits(BIGNUM *a, int n);将a截断至n位，假如a小于n位将出错 &nbsp; int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);a左移n位，结果存于r &nbsp; int BN_lshift1(BIGNUM *r, BIGNUM *a); a左移1位，结果存于r &nbsp; int BN_rshift(BIGNUM *r, BIGNUM *a, int n); a右移n位，结果存于r &nbsp; int BN_rshift1(BIGNUM *r, BIGNUM *a); a左移1位，结果存于r &nbsp; 11．与字符串的转换函数 int BN_bn2bin(const BIGNUM *a, unsigned char *to);将abs（a）转化为字符串存入to，to的空间必须大于BN_num_bytes(a) &nbsp; BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);将s中的len位的正整数转化为大数 &nbsp; char *BN_bn2hex(const BIGNUM *a);转化为16进制字符串 &nbsp; char *BN_bn2dec(const BIGNUM *a);转化为10进制字符串 &nbsp; int BN_hex2bn(BIGNUM **a, const char *str);同上理 &nbsp; int BN_dec2bn(BIGNUM **a, const char *str);同上理 &nbsp; int BN_print(BIO *fp, const BIGNUM *a);将大数16进制形式写入内存中 &nbsp; int BN_print_fp(FILE *fp, const BIGNUM *a); 将大数16进制形式写入文件 &nbsp; int BN_bn2mpi(const BIGNUM *a, unsigned char *to); &nbsp; BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret); &nbsp; 12．其他函数 下面函数可以进行更有效率的模乘和模除，假如在重复在同一模下重复进行模乘和模除计算，计算r=(a*b)%m 利用了recp=1/m &nbsp; BN_RECP_CTX *BN_RECP_CTX_new(void); &nbsp; void BN_RECP_CTX_init(BN_RECP_CTX *recp); &nbsp; void BN_RECP_CTX_free(BN_RECP_CTX *recp); &nbsp; int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx); &nbsp; int BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b, &nbsp; BN_RECP_CTX *recp, BN_CTX *ctx); &nbsp; 下面函数采用蒙哥马利算法进行模幂计算，可以提高效率，他也主要应用于在同一模下进行多次幂运算 &nbsp; BN_MONT_CTX *BN_MONT_CTX_new(void); &nbsp; void BN_MONT_CTX_init(BN_MONT_CTX *ctx); &nbsp; void BN_MONT_CTX_free(BN_MONT_CTX *mont); &nbsp; int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx); &nbsp; BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from); &nbsp; int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_MONT_CTX *mont, BN_CTX *ctx); &nbsp; int BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx); &nbsp; int BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx); 阅读更多","@type":"BlogPosting","url":"/2016/05/21/3e4251d1dae784104caf1a12ce86d81d.html","headline":"SM2算法第二十八篇：Openssl有关大数运算函数介绍（全面）","dateModified":"2016-05-21T00:00:00+08:00","datePublished":"2016-05-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2016/05/21/3e4251d1dae784104caf1a12ce86d81d.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>SM2算法第二十八篇：Openssl有关大数运算函数介绍（全面）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005854" style="color:rgb(1,150,227);">1</a>．初始化函数<span style="border:0px;background:transparent;"></span> </h2>
  <p style="border:0px;text-indent:0em;background:transparent;"> </p> 
  <p style="border:0px;text-indent:0em;background:transparent;"> &nbsp;</p> 
  <p style="border:0px;text-indent:0em;background:transparent;"> </p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> <span style="border:0px;font-size:13px;background:transparent;">BIGNUM *BN_new(void);&nbsp;&nbsp;&nbsp; 新生成一个BIGNUM结构</span></p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> &nbsp;</p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> <span style="border:0px;font-size:13px;background:transparent;">void BN_free(BIGNUM *a);&nbsp;&nbsp; 释放一个BIGNUM结构，释放完后a=NULL;</span></p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> &nbsp;</p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> <span style="border:0px;font-size:13px;background:transparent;">void BN_init(BIGNUM *);&nbsp;&nbsp;&nbsp; 初始化所有项均为0，一般为BN_ init(&amp;c)</span></p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> &nbsp;</p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> <span style="border:0px;font-size:13px;background:transparent;">void BN_clear(BIGNUM *a);&nbsp; 将a中所有项均赋值为0，但是内存并没有释放</span></p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> &nbsp;</p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> <span style="border:0px;font-size:13px;background:transparent;">void BN_clear_free(BIGNUM *a); 相当与将BN_free和BN_clear综合，要不就赋值0，要不就释放空间。</span></p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> &nbsp;</p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> </p> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005747" style="color:rgb(1,150,227);"></a><a name="_Toc92005855" style="color:rgb(1,150,227);">2</a>．上下文情景函数，存储计算中的中间过程</h2> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> <span style="border:0px;font-size:13px;background:transparent;">BN_CTX *BN_CTX_new(void);申请一个新的上下文结构</span></p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> &nbsp;</p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> <span style="border:0px;font-size:13px;background:transparent;">void BN_CTX_init(BN_CTX *c);将所有的项赋值为0，一般BN_CTX_init(&amp;c)</span></p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> &nbsp;</p> 
  <p style="border:0px;font-size:13px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;line-height:24.05px;"> </p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;void BN_CTX_free(BN_CTX *c);释放上下文结构，释放完后c=NULL;</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005748" style="color:rgb(1,150,227);"></a><a name="_Toc92005856" style="color:rgb(1,150,227);">3</a>．复制以及交换函数</h2> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp; BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);将b复制给a,正确返回a，错误返回NULL</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp; BIGNUM *BN_dup(const BIGNUM *a);新建一个BIGNUM结构，将a复制给新建结构返回，错误返回NULL</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp; BIGNUM *BN_swap(BIGNUM *a, BIGNUM *b);交换a,b</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005749" style="color:rgb(1,150,227);"></a><a name="_Toc92005857" style="color:rgb(1,150,227);">4</a>．取位函数<span style="border:0px;background:transparent;"></span> </h2>
  <p style="border:0px;text-indent:0em;background:transparent;"> </p> 
  <p style="border:0px;text-indent:0em;background:transparent;"> &nbsp;</p> 
  <p style="border:0px;text-indent:0em;background:transparent;"> </p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;int BN_num_bytes(const BIGNUM *a);返回a的位数，大量使用</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_num_bits(const BIGNUM *a);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_num_bits_word(BN_ULONG w);他返回有意义比特的位数，例如0x00000432 为11。</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005750" style="color:rgb(1,150,227);"></a><a name="_Toc92005858" style="color:rgb(1,150,227);">5</a>．基本计算函数<span style="border:0px;background:transparent;"></span> </h2>
  <p style="border:0px;text-indent:0em;background:transparent;"> </p> 
  <p style="border:0px;text-indent:0em;background:transparent;"> &nbsp;</p> 
  <p style="border:0px;text-indent:0em;background:transparent;"> </p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);">&nbsp;<span style="border:0px;font-size:13px;background:transparent;">int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);r=a+b</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);r=a-b</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);r=a*b</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);r=a*a,效率高于bn_mul(r,a,a)</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);d=a/b,r=a%b</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);r=a%b</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_nnmod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);r=abs(a%b)</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_mod_add(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);r=abs((a+b)%m))</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_mod_sub(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx); r=abs((a-b)%m))</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;BN_CTX *ctx); r=abs((a*b)%m))</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_mod_sqr(BIGNUM *ret, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx); r=abs((a*a)%m))</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);r=pow(a,p)</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const BIGNUM *m, BN_CTX *ctx); r=pow(a,p)%M</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);r=a,b最大公约数</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_add_word(BIGNUM *a, BN_ULONG w);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_sub_word(BIGNUM *a, BN_ULONG w);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_mul_word(BIGNUM *a, BN_ULONG w);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);模逆，((a*r)%n==1).</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005751" style="color:rgb(1,150,227);"></a><a name="_Toc92005859" style="color:rgb(1,150,227);">6</a>．比较函数</h2> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;int BN_cmp(BIGNUM *a, BIGNUM *b); &nbsp;&nbsp;-1 if <strong>a</strong> &lt; <strong>b</strong>, 0 if <strong>a</strong> == <strong>b</strong> and 1 if <strong>a</strong> &gt; <strong>b</strong>.</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_ucmp(BIGNUM *a, BIGNUM *b);&nbsp; 比较a,b觉得值，返回值和上同。</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_is_zero(BIGNUM *a);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_is_one(BIGNUM *a);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_is_word(BIGNUM *a, BN_ULONG w);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_is_odd(BIGNUM *a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上面四个返回1，假如条件成立，否则将返回0</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005752" style="color:rgb(1,150,227);"></a><a name="_Toc92005860" style="color:rgb(1,150,227);">7</a>．设置函数</h2> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;int BN_zero(BIGNUM *a);&nbsp; 设置a为0</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_one(BIGNUM *a);&nbsp;&nbsp; 设置a为1</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> const BIGNUM *BN_value_one(void); 返回一个为1的大数</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_set_word(BIGNUM *a, unsigned long w); 设置a为w</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> unsigned long BN_get_word(BIGNUM *a); 假如a能表示为long型，那么返回一个long型数</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005753" style="color:rgb(1,150,227);"></a><a name="_Toc92005861" style="color:rgb(1,150,227);">8</a>．随机数函数</h2> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);产生一个加密用的强bits的伪随机数，若top=-1，最高位为0，top=0， 最高位为1，<strong>top</strong>=1,最高位和次高位为1，bottom为真，随机数为偶数 </span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);产生一个伪随机数，应用于某些目的。</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_rand_range(BIGNUM *rnd, BIGNUM *range);产生的0&lt;rnd&lt;range</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);同上面道理</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005754" style="color:rgb(1,150,227);"></a><a name="_Toc92005862" style="color:rgb(1,150,227);">9</a>．产生素数函数</h2> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">BIGNUM *BN_generate_prime(BIGNUM *ret, int bits,int safe, BIGNUM *add,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);产生一个bits位的素数，后面几个参数都可以为NULL</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_is_prime(const BIGNUM *p, int nchecks,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);">判断是否为素数，返回<span style="border:0px;font-size:13px;background:transparent;">0表示成功，1表示错误概率小于0。25，-1表示错误</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005755" style="color:rgb(1,150,227);"></a><a name="_Toc92005863" style="color:rgb(1,150,227);">10</a>．位数函数</h2> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;int BN_set_bit(BIGNUM *a, int n);将a中的第n位设置为1，假如a小于n位将扩展</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_clear_bit(BIGNUM *a, int n);将a中的第n为设置为0，假如a小于n位将出错</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_is_bit_set(const BIGNUM *a, int n);测试是否已经设置，1表示已设置</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_mask_bits(BIGNUM *a, int n);将a截断至n位，假如a小于n位将出错</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);a左移n位，结果存于r</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_lshift1(BIGNUM *r, BIGNUM *a); a左移1位，结果存于r</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_rshift(BIGNUM *r, BIGNUM *a, int n); a右移n位，结果存于r</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_rshift1(BIGNUM *r, BIGNUM *a); a左移1位，结果存于r</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005756" style="color:rgb(1,150,227);"></a><a name="_Toc92005864" style="color:rgb(1,150,227);">11</a>．与字符串的转换函数</h2> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">int BN_bn2bin(const BIGNUM *a, unsigned char *to);将abs（a）转化为字符串存入to，to的空间必须大于BN_num_bytes(<strong>a</strong>)</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);将s中的len位的正整数转化为大数</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> char *BN_bn2hex(const BIGNUM *a);转化为16进制字符串</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> char *BN_bn2dec(const BIGNUM *a);转化为10进制字符串</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_hex2bn(BIGNUM **a, const char *str);同上理</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_dec2bn(BIGNUM **a, const char *str);同上理</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_print(BIO *fp, const BIGNUM *a);将大数16进制形式写入内存中</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_print_fp(FILE *fp, const BIGNUM *a); 将大数16进制形式写入文件</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_bn2mpi(const BIGNUM *a, unsigned char *to);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <h2 style="border:0px;font-size:16px;line-height:29.6px;font-family:'Microsoft YaHei', '微软雅黑', Arial, 'Lucida Grande', Tahoma, sans-serif;"> <a name="_Toc92005757" style="color:rgb(1,150,227);"></a><a name="_Toc92005865" style="color:rgb(1,150,227);">12</a>．其他函数</h2> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);">下面函数可以进行更有效率的模乘和模除，假如在重复在同一模下重复进行模乘和模除计算，计算<span style="border:0px;font-size:13px;background:transparent;">r=(a*b)%m 利用了recp=1/m</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">BN_RECP_CTX *BN_RECP_CTX_new(void);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> void BN_RECP_CTX_init(BN_RECP_CTX *recp);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> void BN_RECP_CTX_free(BN_RECP_CTX *recp);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> BN_RECP_CTX *recp, BN_CTX *ctx);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);">下面函数采用蒙哥马利<span class="wp_keywordlink" style="border:0px;font-size:13px;background:transparent;"><a href="http://www.xuebuyuan.com/category/%E7%AE%97%E6%B3%95" rel="nofollow" title="算法" style="text-decoration:none;color:rgb(1,150,227);">算法</a></span>进行模幂计算，可以提高效率，他也主要应用于在同一模下进行多次幂运算<span style="border:0px;font-size:13px;background:transparent;"></span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">BN_MONT_CTX *BN_MONT_CTX_new(void);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> void BN_MONT_CTX_init(BN_MONT_CTX *ctx);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> void BN_MONT_CTX_free(BN_MONT_CTX *mont);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_MONT_CTX *mont, BN_CTX *ctx);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;"> int BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,</span></pre>
  <p style="border:0px;font-size:13px;text-indent:0em;background:transparent;">&nbsp;</p> 
  <pre style="font-size:13px;line-height:24.05px;background-color:rgb(255,255,255);"><span style="border:0px;font-size:13px;background:transparent;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN_CTX *ctx);</span></pre> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_30866297/article/details/51471035,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/qq_30866297/article/details/51471035,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
