<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>AES加密算法C代码分析 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="AES加密算法C代码分析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="0.引言 对于加密算法的软件实现，通常已经有很多的成熟的库可供选择，只需要根据自己的要求进行选择即可相应的库即可（有的可能需要进行些许修改）。这里选择的是C语言实现的一个开源密码库mbedTLS，mbedTLS由XySSL发展而来，后改为PolarSSL，PolarSSL被ARM公司收购后改成了mbedTLS，主要用于物联网等安全嵌入式领域。mbedTLS实现了常见的分组加密算法、hash算法、RSA以及ECC公钥密码体制，一个适用于嵌入式的SSL协议以及X509证书等，基本能够满足大部分的嵌入式安全应用。 1.AES加密算法代码分析 这里不再详细的介绍AES的数学原理以及设计思路等，只是结合软件进行代码分析，关于AES的官方文档可以在NIST网站上下载得到。 1）数据结构 数据结构与算法密切相关，通常分组加密算法定义的数据结构都较为类似，mbedTLS的AES定义了如下数据结构： typedef struct { int nr; /*!&lt; number of rounds */ uint32_t *rk; /*!&lt; AES round keys */ uint32_t buf[68]; /*!&lt; unaligned data */ } mbedtls_aes_context; 2）算法主体 分组加密算法的软件实现通常会采用“查找表”的方式来提高算法的运算速度，通过表格或者预计算表格直接查表得到对应的算法运算结果。 对算法的分析仅仅以加密算法为例，解密算法的过程基本类似，只是前向表格改为逆向表格而已。 下面先给出代码再进行分析： 1 void mbedtls_aes_encrypt( mbedtls_aes_context *ctx, 2 const unsigned char input[16], 3 unsigned char output[16] ) 4 { 5 int i; 6 uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3; 7 8 RK = ctx-&gt;rk; 9 10 GET_UINT32_LE( X0, input, 0 ); X0 ^= *RK++; 11 GET_UINT32_LE( X1, input, 4 ); X1 ^= *RK++; 12 GET_UINT32_LE( X2, input, 8 ); X2 ^= *RK++; 13 GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++; 14 15 for( i = ( ctx-&gt;nr &gt;&gt; 1 ) - 1; i &gt; 0; i-- ) 16 { 17 AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 ); 18 AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 ); 19 } 20 21 AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 ); 22 23 X0 = *RK++ ^ \ 24 ( (uint32_t) FSb[ ( Y0 ) &amp; 0xFF ] ) ^ 25 ( (uint32_t) FSb[ ( Y1 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 26 ( (uint32_t) FSb[ ( Y2 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 27 ( (uint32_t) FSb[ ( Y3 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 28 29 X1 = *RK++ ^ \ 30 ( (uint32_t) FSb[ ( Y1 ) &amp; 0xFF ] ) ^ 31 ( (uint32_t) FSb[ ( Y2 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 32 ( (uint32_t) FSb[ ( Y3 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 33 ( (uint32_t) FSb[ ( Y0 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 34 35 X2 = *RK++ ^ \ 36 ( (uint32_t) FSb[ ( Y2 ) &amp; 0xFF ] ) ^ 37 ( (uint32_t) FSb[ ( Y3 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 38 ( (uint32_t) FSb[ ( Y0 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 39 ( (uint32_t) FSb[ ( Y1 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 40 41 X3 = *RK++ ^ \ 42 ( (uint32_t) FSb[ ( Y3 ) &amp; 0xFF ] ) ^ 43 ( (uint32_t) FSb[ ( Y0 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 44 ( (uint32_t) FSb[ ( Y1 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 45 ( (uint32_t) FSb[ ( Y2 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 46 47 PUT_UINT32_LE( X0, output, 0 ); 48 PUT_UINT32_LE( X1, output, 4 ); 49 PUT_UINT32_LE( X2, output, 8 ); 50 PUT_UINT32_LE( X3, output, 12 ); 51 } 分析可以得到算法的过程为： 轮密钥加-&gt;N-1轮轮变换-&gt;末轮变换 其中末轮变换只有：字节置换（subbyte)/行移位（shiftrow)/轮密钥加（addroundkey) 中间的轮变换则为：字节置换（subbyte)/行移位（shiftrow)/列混合（mixcol)/轮密钥加（addroundkey) 上述代码中，RK为轮密钥，FSb为S盒（Subbyte）的查找表，FTx则包括字节置换与列混合两个过程，因为行移位为线性变换，其运算过程可以和列混合进行交换。 AES_ROUND由宏定义得到，代码如下： 1 #define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3) \ 2 { \ 3 X0 = *RK++ ^ FT0[ ( Y0 ) &amp; 0xFF ] ^ \ 4 FT1[ ( Y1 &gt;&gt; 8 ) &amp; 0xFF ] ^ \ 5 FT2[ ( Y2 &gt;&gt; 16 ) &amp; 0xFF ] ^ \ 6 FT3[ ( Y3 &gt;&gt; 24 ) &amp; 0xFF ]; \ 7 \ 8 X1 = *RK++ ^ FT0[ ( Y1 ) &amp; 0xFF ] ^ \ 9 FT1[ ( Y2 &gt;&gt; 8 ) &amp; 0xFF ] ^ \ 10 FT2[ ( Y3 &gt;&gt; 16 ) &amp; 0xFF ] ^ \ 11 FT3[ ( Y0 &gt;&gt; 24 ) &amp; 0xFF ]; \ 12 \ 13 X2 = *RK++ ^ FT0[ ( Y2 ) &amp; 0xFF ] ^ \ 14 FT1[ ( Y3 &gt;&gt; 8 ) &amp; 0xFF ] ^ \ 15 FT2[ ( Y0 &gt;&gt; 16 ) &amp; 0xFF ] ^ \ 16 FT3[ ( Y1 &gt;&gt; 24 ) &amp; 0xFF ]; \ 17 \ 18 X3 = *RK++ ^ FT0[ ( Y3 ) &amp; 0xFF ] ^ \ 19 FT1[ ( Y0 &gt;&gt; 8 ) &amp; 0xFF ] ^ \ 20 FT2[ ( Y1 &gt;&gt; 16 ) &amp; 0xFF ] ^ \ 21 FT3[ ( Y2 &gt;&gt; 24 ) &amp; 0xFF ]; \ 22 } mbedTLS给出了两种实现，1.ROM_TABLE的方式，所有表格直接给出，不再一一列出各种表格；2.表格预计算的方式，由于AES的设计是基于有限域的，表格预计算需要一些有限域的辅助函数，整个预计算的过程如下： 1 #define ROTL8(x) ( ( x &lt;&lt; 8 ) &amp; 0xFFFFFFFF ) | ( x &gt;&gt; 24 ) 2 #define XTIME(x) ( ( x &lt;&lt; 1 ) ^ ( ( x &amp; 0x80 ) ? 0x1B : 0x00 ) ) 3 #define MUL(x,y) ( ( x &amp;&amp; y ) ? pow[(log[x]+log[y]) % 255] : 0 ) 4 5 static int aes_init_done = 0; 6 7 static void aes_gen_tables( void ) 8 { 9 int i, x, y, z; 10 int pow[256]; 11 int log[256]; 12 13 /* 14 * compute pow and log tables over GF(2^8) 15 */ 16 for( i = 0, x = 1; i &lt; 256; i++ ) 17 { 18 pow[i] = x; 19 log[x] = i; 20 x = ( x ^ XTIME( x ) ) &amp; 0xFF; 21 } 22 23 /* 24 * calculate the round constants 25 */ 26 for( i = 0, x = 1; i &lt; 10; i++ ) 27 { 28 RCON[i] = (uint32_t) x; 29 x = XTIME( x ) &amp; 0xFF; 30 } 31 32 /* 33 * generate the forward and reverse S-boxes 34 */ 35 FSb[0x00] = 0x63; 36 RSb[0x63] = 0x00; 37 38 for( i = 1; i &lt; 256; i++ ) 39 { 40 x = pow[255 - log[i]]; 41 42 y = x; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 43 x ^= y; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 44 x ^= y; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 45 x ^= y; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 46 x ^= y ^ 0x63; 47 48 FSb[i] = (unsigned char) x; 49 RSb[x] = (unsigned char) i; 50 } 51 52 /* 53 * generate the forward and reverse tables 54 */ 55 for( i = 0; i &lt; 256; i++ ) 56 { 57 x = FSb[i]; 58 y = XTIME( x ) &amp; 0xFF; 59 z = ( y ^ x ) &amp; 0xFF; 60 61 FT0[i] = ( (uint32_t) y ) ^ 62 ( (uint32_t) x &lt;&lt; 8 ) ^ 63 ( (uint32_t) x &lt;&lt; 16 ) ^ 64 ( (uint32_t) z &lt;&lt; 24 ); 65 66 FT1[i] = ROTL8( FT0[i] ); 67 FT2[i] = ROTL8( FT1[i] ); 68 FT3[i] = ROTL8( FT2[i] ); 69 70 x = RSb[i]; 71 72 RT0[i] = ( (uint32_t) MUL( 0x0E, x ) ) ^ 73 ( (uint32_t) MUL( 0x09, x ) &lt;&lt; 8 ) ^ 74 ( (uint32_t) MUL( 0x0D, x ) &lt;&lt; 16 ) ^ 75 ( (uint32_t) MUL( 0x0B, x ) &lt;&lt; 24 ); 76 77 RT1[i] = ROTL8( RT0[i] ); 78 RT2[i] = ROTL8( RT1[i] ); 79 RT3[i] = ROTL8( RT2[i] ); 80 } 81 } 在有限域运算中，使用了对数表的方式来实现有限域的乘法操作，这是AES设计者在提交算法是所提供的一种计算方式。 38~50行代码进行有限域求逆算法（使用对数表），再进行仿射变换，求得S盒，同时可以得到逆向S盒。AES的S盒设计为（A*x-1+b)，A为2进制矩阵，b为2进制列向量（0x63）。 再计算FTx,FTx的计算需要有限域乘法操作，其乘法为固定乘法操作，主要有x2与x3,（逆变换乘数为0x0e,0x09,0x0d,0x0b)。其中有限域的乘法运算也是基于对数表完成的。 2.算法简介 …… 阅读更多" />
<meta property="og:description" content="0.引言 对于加密算法的软件实现，通常已经有很多的成熟的库可供选择，只需要根据自己的要求进行选择即可相应的库即可（有的可能需要进行些许修改）。这里选择的是C语言实现的一个开源密码库mbedTLS，mbedTLS由XySSL发展而来，后改为PolarSSL，PolarSSL被ARM公司收购后改成了mbedTLS，主要用于物联网等安全嵌入式领域。mbedTLS实现了常见的分组加密算法、hash算法、RSA以及ECC公钥密码体制，一个适用于嵌入式的SSL协议以及X509证书等，基本能够满足大部分的嵌入式安全应用。 1.AES加密算法代码分析 这里不再详细的介绍AES的数学原理以及设计思路等，只是结合软件进行代码分析，关于AES的官方文档可以在NIST网站上下载得到。 1）数据结构 数据结构与算法密切相关，通常分组加密算法定义的数据结构都较为类似，mbedTLS的AES定义了如下数据结构： typedef struct { int nr; /*!&lt; number of rounds */ uint32_t *rk; /*!&lt; AES round keys */ uint32_t buf[68]; /*!&lt; unaligned data */ } mbedtls_aes_context; 2）算法主体 分组加密算法的软件实现通常会采用“查找表”的方式来提高算法的运算速度，通过表格或者预计算表格直接查表得到对应的算法运算结果。 对算法的分析仅仅以加密算法为例，解密算法的过程基本类似，只是前向表格改为逆向表格而已。 下面先给出代码再进行分析： 1 void mbedtls_aes_encrypt( mbedtls_aes_context *ctx, 2 const unsigned char input[16], 3 unsigned char output[16] ) 4 { 5 int i; 6 uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3; 7 8 RK = ctx-&gt;rk; 9 10 GET_UINT32_LE( X0, input, 0 ); X0 ^= *RK++; 11 GET_UINT32_LE( X1, input, 4 ); X1 ^= *RK++; 12 GET_UINT32_LE( X2, input, 8 ); X2 ^= *RK++; 13 GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++; 14 15 for( i = ( ctx-&gt;nr &gt;&gt; 1 ) - 1; i &gt; 0; i-- ) 16 { 17 AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 ); 18 AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 ); 19 } 20 21 AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 ); 22 23 X0 = *RK++ ^ \ 24 ( (uint32_t) FSb[ ( Y0 ) &amp; 0xFF ] ) ^ 25 ( (uint32_t) FSb[ ( Y1 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 26 ( (uint32_t) FSb[ ( Y2 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 27 ( (uint32_t) FSb[ ( Y3 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 28 29 X1 = *RK++ ^ \ 30 ( (uint32_t) FSb[ ( Y1 ) &amp; 0xFF ] ) ^ 31 ( (uint32_t) FSb[ ( Y2 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 32 ( (uint32_t) FSb[ ( Y3 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 33 ( (uint32_t) FSb[ ( Y0 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 34 35 X2 = *RK++ ^ \ 36 ( (uint32_t) FSb[ ( Y2 ) &amp; 0xFF ] ) ^ 37 ( (uint32_t) FSb[ ( Y3 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 38 ( (uint32_t) FSb[ ( Y0 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 39 ( (uint32_t) FSb[ ( Y1 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 40 41 X3 = *RK++ ^ \ 42 ( (uint32_t) FSb[ ( Y3 ) &amp; 0xFF ] ) ^ 43 ( (uint32_t) FSb[ ( Y0 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 44 ( (uint32_t) FSb[ ( Y1 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 45 ( (uint32_t) FSb[ ( Y2 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 46 47 PUT_UINT32_LE( X0, output, 0 ); 48 PUT_UINT32_LE( X1, output, 4 ); 49 PUT_UINT32_LE( X2, output, 8 ); 50 PUT_UINT32_LE( X3, output, 12 ); 51 } 分析可以得到算法的过程为： 轮密钥加-&gt;N-1轮轮变换-&gt;末轮变换 其中末轮变换只有：字节置换（subbyte)/行移位（shiftrow)/轮密钥加（addroundkey) 中间的轮变换则为：字节置换（subbyte)/行移位（shiftrow)/列混合（mixcol)/轮密钥加（addroundkey) 上述代码中，RK为轮密钥，FSb为S盒（Subbyte）的查找表，FTx则包括字节置换与列混合两个过程，因为行移位为线性变换，其运算过程可以和列混合进行交换。 AES_ROUND由宏定义得到，代码如下： 1 #define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3) \ 2 { \ 3 X0 = *RK++ ^ FT0[ ( Y0 ) &amp; 0xFF ] ^ \ 4 FT1[ ( Y1 &gt;&gt; 8 ) &amp; 0xFF ] ^ \ 5 FT2[ ( Y2 &gt;&gt; 16 ) &amp; 0xFF ] ^ \ 6 FT3[ ( Y3 &gt;&gt; 24 ) &amp; 0xFF ]; \ 7 \ 8 X1 = *RK++ ^ FT0[ ( Y1 ) &amp; 0xFF ] ^ \ 9 FT1[ ( Y2 &gt;&gt; 8 ) &amp; 0xFF ] ^ \ 10 FT2[ ( Y3 &gt;&gt; 16 ) &amp; 0xFF ] ^ \ 11 FT3[ ( Y0 &gt;&gt; 24 ) &amp; 0xFF ]; \ 12 \ 13 X2 = *RK++ ^ FT0[ ( Y2 ) &amp; 0xFF ] ^ \ 14 FT1[ ( Y3 &gt;&gt; 8 ) &amp; 0xFF ] ^ \ 15 FT2[ ( Y0 &gt;&gt; 16 ) &amp; 0xFF ] ^ \ 16 FT3[ ( Y1 &gt;&gt; 24 ) &amp; 0xFF ]; \ 17 \ 18 X3 = *RK++ ^ FT0[ ( Y3 ) &amp; 0xFF ] ^ \ 19 FT1[ ( Y0 &gt;&gt; 8 ) &amp; 0xFF ] ^ \ 20 FT2[ ( Y1 &gt;&gt; 16 ) &amp; 0xFF ] ^ \ 21 FT3[ ( Y2 &gt;&gt; 24 ) &amp; 0xFF ]; \ 22 } mbedTLS给出了两种实现，1.ROM_TABLE的方式，所有表格直接给出，不再一一列出各种表格；2.表格预计算的方式，由于AES的设计是基于有限域的，表格预计算需要一些有限域的辅助函数，整个预计算的过程如下： 1 #define ROTL8(x) ( ( x &lt;&lt; 8 ) &amp; 0xFFFFFFFF ) | ( x &gt;&gt; 24 ) 2 #define XTIME(x) ( ( x &lt;&lt; 1 ) ^ ( ( x &amp; 0x80 ) ? 0x1B : 0x00 ) ) 3 #define MUL(x,y) ( ( x &amp;&amp; y ) ? pow[(log[x]+log[y]) % 255] : 0 ) 4 5 static int aes_init_done = 0; 6 7 static void aes_gen_tables( void ) 8 { 9 int i, x, y, z; 10 int pow[256]; 11 int log[256]; 12 13 /* 14 * compute pow and log tables over GF(2^8) 15 */ 16 for( i = 0, x = 1; i &lt; 256; i++ ) 17 { 18 pow[i] = x; 19 log[x] = i; 20 x = ( x ^ XTIME( x ) ) &amp; 0xFF; 21 } 22 23 /* 24 * calculate the round constants 25 */ 26 for( i = 0, x = 1; i &lt; 10; i++ ) 27 { 28 RCON[i] = (uint32_t) x; 29 x = XTIME( x ) &amp; 0xFF; 30 } 31 32 /* 33 * generate the forward and reverse S-boxes 34 */ 35 FSb[0x00] = 0x63; 36 RSb[0x63] = 0x00; 37 38 for( i = 1; i &lt; 256; i++ ) 39 { 40 x = pow[255 - log[i]]; 41 42 y = x; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 43 x ^= y; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 44 x ^= y; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 45 x ^= y; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 46 x ^= y ^ 0x63; 47 48 FSb[i] = (unsigned char) x; 49 RSb[x] = (unsigned char) i; 50 } 51 52 /* 53 * generate the forward and reverse tables 54 */ 55 for( i = 0; i &lt; 256; i++ ) 56 { 57 x = FSb[i]; 58 y = XTIME( x ) &amp; 0xFF; 59 z = ( y ^ x ) &amp; 0xFF; 60 61 FT0[i] = ( (uint32_t) y ) ^ 62 ( (uint32_t) x &lt;&lt; 8 ) ^ 63 ( (uint32_t) x &lt;&lt; 16 ) ^ 64 ( (uint32_t) z &lt;&lt; 24 ); 65 66 FT1[i] = ROTL8( FT0[i] ); 67 FT2[i] = ROTL8( FT1[i] ); 68 FT3[i] = ROTL8( FT2[i] ); 69 70 x = RSb[i]; 71 72 RT0[i] = ( (uint32_t) MUL( 0x0E, x ) ) ^ 73 ( (uint32_t) MUL( 0x09, x ) &lt;&lt; 8 ) ^ 74 ( (uint32_t) MUL( 0x0D, x ) &lt;&lt; 16 ) ^ 75 ( (uint32_t) MUL( 0x0B, x ) &lt;&lt; 24 ); 76 77 RT1[i] = ROTL8( RT0[i] ); 78 RT2[i] = ROTL8( RT1[i] ); 79 RT3[i] = ROTL8( RT2[i] ); 80 } 81 } 在有限域运算中，使用了对数表的方式来实现有限域的乘法操作，这是AES设计者在提交算法是所提供的一种计算方式。 38~50行代码进行有限域求逆算法（使用对数表），再进行仿射变换，求得S盒，同时可以得到逆向S盒。AES的S盒设计为（A*x-1+b)，A为2进制矩阵，b为2进制列向量（0x63）。 再计算FTx,FTx的计算需要有限域乘法操作，其乘法为固定乘法操作，主要有x2与x3,（逆变换乘数为0x0e,0x09,0x0d,0x0b)。其中有限域的乘法运算也是基于对数表完成的。 2.算法简介 …… 阅读更多" />
<link rel="canonical" href="https://mlh.app/2016/05/08/7b30e93082af2172430f9c540b1760c2.html" />
<meta property="og:url" content="https://mlh.app/2016/05/08/7b30e93082af2172430f9c540b1760c2.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-08T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"0.引言 对于加密算法的软件实现，通常已经有很多的成熟的库可供选择，只需要根据自己的要求进行选择即可相应的库即可（有的可能需要进行些许修改）。这里选择的是C语言实现的一个开源密码库mbedTLS，mbedTLS由XySSL发展而来，后改为PolarSSL，PolarSSL被ARM公司收购后改成了mbedTLS，主要用于物联网等安全嵌入式领域。mbedTLS实现了常见的分组加密算法、hash算法、RSA以及ECC公钥密码体制，一个适用于嵌入式的SSL协议以及X509证书等，基本能够满足大部分的嵌入式安全应用。 1.AES加密算法代码分析 这里不再详细的介绍AES的数学原理以及设计思路等，只是结合软件进行代码分析，关于AES的官方文档可以在NIST网站上下载得到。 1）数据结构 数据结构与算法密切相关，通常分组加密算法定义的数据结构都较为类似，mbedTLS的AES定义了如下数据结构： typedef struct { int nr; /*!&lt; number of rounds */ uint32_t *rk; /*!&lt; AES round keys */ uint32_t buf[68]; /*!&lt; unaligned data */ } mbedtls_aes_context; 2）算法主体 分组加密算法的软件实现通常会采用“查找表”的方式来提高算法的运算速度，通过表格或者预计算表格直接查表得到对应的算法运算结果。 对算法的分析仅仅以加密算法为例，解密算法的过程基本类似，只是前向表格改为逆向表格而已。 下面先给出代码再进行分析： 1 void mbedtls_aes_encrypt( mbedtls_aes_context *ctx, 2 const unsigned char input[16], 3 unsigned char output[16] ) 4 { 5 int i; 6 uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3; 7 8 RK = ctx-&gt;rk; 9 10 GET_UINT32_LE( X0, input, 0 ); X0 ^= *RK++; 11 GET_UINT32_LE( X1, input, 4 ); X1 ^= *RK++; 12 GET_UINT32_LE( X2, input, 8 ); X2 ^= *RK++; 13 GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++; 14 15 for( i = ( ctx-&gt;nr &gt;&gt; 1 ) - 1; i &gt; 0; i-- ) 16 { 17 AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 ); 18 AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 ); 19 } 20 21 AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 ); 22 23 X0 = *RK++ ^ \\ 24 ( (uint32_t) FSb[ ( Y0 ) &amp; 0xFF ] ) ^ 25 ( (uint32_t) FSb[ ( Y1 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 26 ( (uint32_t) FSb[ ( Y2 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 27 ( (uint32_t) FSb[ ( Y3 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 28 29 X1 = *RK++ ^ \\ 30 ( (uint32_t) FSb[ ( Y1 ) &amp; 0xFF ] ) ^ 31 ( (uint32_t) FSb[ ( Y2 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 32 ( (uint32_t) FSb[ ( Y3 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 33 ( (uint32_t) FSb[ ( Y0 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 34 35 X2 = *RK++ ^ \\ 36 ( (uint32_t) FSb[ ( Y2 ) &amp; 0xFF ] ) ^ 37 ( (uint32_t) FSb[ ( Y3 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 38 ( (uint32_t) FSb[ ( Y0 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 39 ( (uint32_t) FSb[ ( Y1 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 40 41 X3 = *RK++ ^ \\ 42 ( (uint32_t) FSb[ ( Y3 ) &amp; 0xFF ] ) ^ 43 ( (uint32_t) FSb[ ( Y0 &gt;&gt; 8 ) &amp; 0xFF ] &lt;&lt; 8 ) ^ 44 ( (uint32_t) FSb[ ( Y1 &gt;&gt; 16 ) &amp; 0xFF ] &lt;&lt; 16 ) ^ 45 ( (uint32_t) FSb[ ( Y2 &gt;&gt; 24 ) &amp; 0xFF ] &lt;&lt; 24 ); 46 47 PUT_UINT32_LE( X0, output, 0 ); 48 PUT_UINT32_LE( X1, output, 4 ); 49 PUT_UINT32_LE( X2, output, 8 ); 50 PUT_UINT32_LE( X3, output, 12 ); 51 } 分析可以得到算法的过程为： 轮密钥加-&gt;N-1轮轮变换-&gt;末轮变换 其中末轮变换只有：字节置换（subbyte)/行移位（shiftrow)/轮密钥加（addroundkey) 中间的轮变换则为：字节置换（subbyte)/行移位（shiftrow)/列混合（mixcol)/轮密钥加（addroundkey) 上述代码中，RK为轮密钥，FSb为S盒（Subbyte）的查找表，FTx则包括字节置换与列混合两个过程，因为行移位为线性变换，其运算过程可以和列混合进行交换。 AES_ROUND由宏定义得到，代码如下： 1 #define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3) \\ 2 { \\ 3 X0 = *RK++ ^ FT0[ ( Y0 ) &amp; 0xFF ] ^ \\ 4 FT1[ ( Y1 &gt;&gt; 8 ) &amp; 0xFF ] ^ \\ 5 FT2[ ( Y2 &gt;&gt; 16 ) &amp; 0xFF ] ^ \\ 6 FT3[ ( Y3 &gt;&gt; 24 ) &amp; 0xFF ]; \\ 7 \\ 8 X1 = *RK++ ^ FT0[ ( Y1 ) &amp; 0xFF ] ^ \\ 9 FT1[ ( Y2 &gt;&gt; 8 ) &amp; 0xFF ] ^ \\ 10 FT2[ ( Y3 &gt;&gt; 16 ) &amp; 0xFF ] ^ \\ 11 FT3[ ( Y0 &gt;&gt; 24 ) &amp; 0xFF ]; \\ 12 \\ 13 X2 = *RK++ ^ FT0[ ( Y2 ) &amp; 0xFF ] ^ \\ 14 FT1[ ( Y3 &gt;&gt; 8 ) &amp; 0xFF ] ^ \\ 15 FT2[ ( Y0 &gt;&gt; 16 ) &amp; 0xFF ] ^ \\ 16 FT3[ ( Y1 &gt;&gt; 24 ) &amp; 0xFF ]; \\ 17 \\ 18 X3 = *RK++ ^ FT0[ ( Y3 ) &amp; 0xFF ] ^ \\ 19 FT1[ ( Y0 &gt;&gt; 8 ) &amp; 0xFF ] ^ \\ 20 FT2[ ( Y1 &gt;&gt; 16 ) &amp; 0xFF ] ^ \\ 21 FT3[ ( Y2 &gt;&gt; 24 ) &amp; 0xFF ]; \\ 22 } mbedTLS给出了两种实现，1.ROM_TABLE的方式，所有表格直接给出，不再一一列出各种表格；2.表格预计算的方式，由于AES的设计是基于有限域的，表格预计算需要一些有限域的辅助函数，整个预计算的过程如下： 1 #define ROTL8(x) ( ( x &lt;&lt; 8 ) &amp; 0xFFFFFFFF ) | ( x &gt;&gt; 24 ) 2 #define XTIME(x) ( ( x &lt;&lt; 1 ) ^ ( ( x &amp; 0x80 ) ? 0x1B : 0x00 ) ) 3 #define MUL(x,y) ( ( x &amp;&amp; y ) ? pow[(log[x]+log[y]) % 255] : 0 ) 4 5 static int aes_init_done = 0; 6 7 static void aes_gen_tables( void ) 8 { 9 int i, x, y, z; 10 int pow[256]; 11 int log[256]; 12 13 /* 14 * compute pow and log tables over GF(2^8) 15 */ 16 for( i = 0, x = 1; i &lt; 256; i++ ) 17 { 18 pow[i] = x; 19 log[x] = i; 20 x = ( x ^ XTIME( x ) ) &amp; 0xFF; 21 } 22 23 /* 24 * calculate the round constants 25 */ 26 for( i = 0, x = 1; i &lt; 10; i++ ) 27 { 28 RCON[i] = (uint32_t) x; 29 x = XTIME( x ) &amp; 0xFF; 30 } 31 32 /* 33 * generate the forward and reverse S-boxes 34 */ 35 FSb[0x00] = 0x63; 36 RSb[0x63] = 0x00; 37 38 for( i = 1; i &lt; 256; i++ ) 39 { 40 x = pow[255 - log[i]]; 41 42 y = x; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 43 x ^= y; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 44 x ^= y; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 45 x ^= y; y = ( ( y &lt;&lt; 1 ) | ( y &gt;&gt; 7 ) ) &amp; 0xFF; 46 x ^= y ^ 0x63; 47 48 FSb[i] = (unsigned char) x; 49 RSb[x] = (unsigned char) i; 50 } 51 52 /* 53 * generate the forward and reverse tables 54 */ 55 for( i = 0; i &lt; 256; i++ ) 56 { 57 x = FSb[i]; 58 y = XTIME( x ) &amp; 0xFF; 59 z = ( y ^ x ) &amp; 0xFF; 60 61 FT0[i] = ( (uint32_t) y ) ^ 62 ( (uint32_t) x &lt;&lt; 8 ) ^ 63 ( (uint32_t) x &lt;&lt; 16 ) ^ 64 ( (uint32_t) z &lt;&lt; 24 ); 65 66 FT1[i] = ROTL8( FT0[i] ); 67 FT2[i] = ROTL8( FT1[i] ); 68 FT3[i] = ROTL8( FT2[i] ); 69 70 x = RSb[i]; 71 72 RT0[i] = ( (uint32_t) MUL( 0x0E, x ) ) ^ 73 ( (uint32_t) MUL( 0x09, x ) &lt;&lt; 8 ) ^ 74 ( (uint32_t) MUL( 0x0D, x ) &lt;&lt; 16 ) ^ 75 ( (uint32_t) MUL( 0x0B, x ) &lt;&lt; 24 ); 76 77 RT1[i] = ROTL8( RT0[i] ); 78 RT2[i] = ROTL8( RT1[i] ); 79 RT3[i] = ROTL8( RT2[i] ); 80 } 81 } 在有限域运算中，使用了对数表的方式来实现有限域的乘法操作，这是AES设计者在提交算法是所提供的一种计算方式。 38~50行代码进行有限域求逆算法（使用对数表），再进行仿射变换，求得S盒，同时可以得到逆向S盒。AES的S盒设计为（A*x-1+b)，A为2进制矩阵，b为2进制列向量（0x63）。 再计算FTx,FTx的计算需要有限域乘法操作，其乘法为固定乘法操作，主要有x2与x3,（逆变换乘数为0x0e,0x09,0x0d,0x0b)。其中有限域的乘法运算也是基于对数表完成的。 2.算法简介 …… 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2016/05/08/7b30e93082af2172430f9c540b1760c2.html","headline":"AES加密算法C代码分析","dateModified":"2016-05-08T00:00:00+08:00","datePublished":"2016-05-08T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2016/05/08/7b30e93082af2172430f9c540b1760c2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>AES加密算法C代码分析</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views">
   0.引言 
  <p>对于加密算法的软件实现，通常已经有很多的成熟的库可供选择，只需要根据自己的要求进行选择即可相应的库即可（有的可能需要进行些许修改）。这里选择的是C语言实现的一个开源密码库mbedTLS，mbedTLS由XySSL发展而来，后改为PolarSSL，PolarSSL被ARM公司收购后改成了mbedTLS，主要用于物联网等安全嵌入式领域。mbedTLS实现了常见的分组加密算法、hash算法、RSA以及ECC公钥密码体制，一个适用于嵌入式的SSL协议以及X509证书等，基本能够满足大部分的嵌入式安全应用。</p> 
  <p>1.AES加密算法代码分析</p> 
  <p>这里不再详细的介绍AES的数学原理以及设计思路等，只是结合软件进行代码分析，关于AES的官方文档可以在NIST网站上下载得到。</p> 
  <p>1）数据结构</p> 
  <p>数据结构与算法密切相关，通常分组加密算法定义的数据结构都较为类似，mbedTLS的AES定义了如下数据结构：</p> 
  <div class="cnblogs_code"> 
   <pre>typedef <span style="color:#0000ff;">struct</span><span style="color:#000000;">
{
    </span><span style="color:#0000ff;">int</span> nr;                     <span style="color:#008000;">/*</span><span style="color:#008000;">!&lt;  number of rounds  </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    uint32_t </span>*rk;               <span style="color:#008000;">/*</span><span style="color:#008000;">!&lt;  AES round keys    </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    uint32_t buf[</span><span style="color:#800080;">68</span>];           <span style="color:#008000;">/*</span><span style="color:#008000;">!&lt;  unaligned data    </span><span style="color:#008000;">*/</span><span style="color:#000000;">
}
mbedtls_aes_context;</span></pre> 
  </div> 
  <p>2）算法主体</p> 
  <p>分组加密算法的软件实现通常会采用“查找表”的方式来提高算法的运算速度，通过表格或者预计算表格直接查表得到对应的算法运算结果。</p> 
  <p>对算法的分析仅仅以加密算法为例，解密算法的过程基本类似，只是前向表格改为逆向表格而已。</p> 
  <p>下面先给出代码再进行分析：</p> 
  <div class="cnblogs_code"> 
   <pre><span style="color:#008080;"> 1</span> <span style="color:#0000ff;">void</span> mbedtls_aes_encrypt( mbedtls_aes_context *<span style="color:#000000;">ctx,
</span><span style="color:#008080;"> 2</span>                           <span style="color:#0000ff;">const</span> unsigned <span style="color:#0000ff;">char</span> input[<span style="color:#800080;">16</span><span style="color:#000000;">],
</span><span style="color:#008080;"> 3</span>                           unsigned <span style="color:#0000ff;">char</span> output[<span style="color:#800080;">16</span><span style="color:#000000;">] )
</span><span style="color:#008080;"> 4</span> <span style="color:#000000;">{
</span><span style="color:#008080;"> 5</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> i;
</span><span style="color:#008080;"> 6</span>     uint32_t *<span style="color:#000000;">RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
</span><span style="color:#008080;"> 7</span> 
<span style="color:#008080;"> 8</span>     RK = ctx-&gt;<span style="color:#000000;">rk;
</span><span style="color:#008080;"> 9</span> 
<span style="color:#008080;">10</span>     GET_UINT32_LE( X0, input,  <span style="color:#800080;">0</span> ); X0 ^= *RK++<span style="color:#000000;">;
</span><span style="color:#008080;">11</span>     GET_UINT32_LE( X1, input,  <span style="color:#800080;">4</span> ); X1 ^= *RK++<span style="color:#000000;">;
</span><span style="color:#008080;">12</span>     GET_UINT32_LE( X2, input,  <span style="color:#800080;">8</span> ); X2 ^= *RK++<span style="color:#000000;">;
</span><span style="color:#008080;">13</span>     GET_UINT32_LE( X3, input, <span style="color:#800080;">12</span> ); X3 ^= *RK++<span style="color:#000000;">;
</span><span style="color:#008080;">14</span> 
<span style="color:#008080;">15</span>     <span style="color:#0000ff;">for</span>( i = ( ctx-&gt;nr &gt;&gt; <span style="color:#800080;">1</span> ) - <span style="color:#800080;">1</span>; i &gt; <span style="color:#800080;">0</span>; i--<span style="color:#000000;"> )
</span><span style="color:#008080;">16</span> <span style="color:#000000;">    {
</span><span style="color:#008080;">17</span> <span style="color:#000000;">        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
</span><span style="color:#008080;">18</span> <span style="color:#000000;">        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
</span><span style="color:#008080;">19</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">20</span> 
<span style="color:#008080;">21</span> <span style="color:#000000;">    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
</span><span style="color:#008080;">22</span> 
<span style="color:#008080;">23</span>     X0 = *RK++ ^<span style="color:#000000;"> \
</span><span style="color:#008080;">24</span>             ( (uint32_t) FSb[ ( Y0       ) &amp; <span style="color:#800080;">0xFF</span> ]       ) ^
<span style="color:#008080;">25</span>             ( (uint32_t) FSb[ ( Y1 &gt;&gt;  <span style="color:#800080;">8</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt;  <span style="color:#800080;">8</span> ) ^
<span style="color:#008080;">26</span>             ( (uint32_t) FSb[ ( Y2 &gt;&gt; <span style="color:#800080;">16</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt; <span style="color:#800080;">16</span> ) ^
<span style="color:#008080;">27</span>             ( (uint32_t) FSb[ ( Y3 &gt;&gt; <span style="color:#800080;">24</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt; <span style="color:#800080;">24</span><span style="color:#000000;"> );
</span><span style="color:#008080;">28</span> 
<span style="color:#008080;">29</span>     X1 = *RK++ ^<span style="color:#000000;"> \
</span><span style="color:#008080;">30</span>             ( (uint32_t) FSb[ ( Y1       ) &amp; <span style="color:#800080;">0xFF</span> ]       ) ^
<span style="color:#008080;">31</span>             ( (uint32_t) FSb[ ( Y2 &gt;&gt;  <span style="color:#800080;">8</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt;  <span style="color:#800080;">8</span> ) ^
<span style="color:#008080;">32</span>             ( (uint32_t) FSb[ ( Y3 &gt;&gt; <span style="color:#800080;">16</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt; <span style="color:#800080;">16</span> ) ^
<span style="color:#008080;">33</span>             ( (uint32_t) FSb[ ( Y0 &gt;&gt; <span style="color:#800080;">24</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt; <span style="color:#800080;">24</span><span style="color:#000000;"> );
</span><span style="color:#008080;">34</span> 
<span style="color:#008080;">35</span>     X2 = *RK++ ^<span style="color:#000000;"> \
</span><span style="color:#008080;">36</span>             ( (uint32_t) FSb[ ( Y2       ) &amp; <span style="color:#800080;">0xFF</span> ]       ) ^
<span style="color:#008080;">37</span>             ( (uint32_t) FSb[ ( Y3 &gt;&gt;  <span style="color:#800080;">8</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt;  <span style="color:#800080;">8</span> ) ^
<span style="color:#008080;">38</span>             ( (uint32_t) FSb[ ( Y0 &gt;&gt; <span style="color:#800080;">16</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt; <span style="color:#800080;">16</span> ) ^
<span style="color:#008080;">39</span>             ( (uint32_t) FSb[ ( Y1 &gt;&gt; <span style="color:#800080;">24</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt; <span style="color:#800080;">24</span><span style="color:#000000;"> );
</span><span style="color:#008080;">40</span> 
<span style="color:#008080;">41</span>     X3 = *RK++ ^<span style="color:#000000;"> \
</span><span style="color:#008080;">42</span>             ( (uint32_t) FSb[ ( Y3       ) &amp; <span style="color:#800080;">0xFF</span> ]       ) ^
<span style="color:#008080;">43</span>             ( (uint32_t) FSb[ ( Y0 &gt;&gt;  <span style="color:#800080;">8</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt;  <span style="color:#800080;">8</span> ) ^
<span style="color:#008080;">44</span>             ( (uint32_t) FSb[ ( Y1 &gt;&gt; <span style="color:#800080;">16</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt; <span style="color:#800080;">16</span> ) ^
<span style="color:#008080;">45</span>             ( (uint32_t) FSb[ ( Y2 &gt;&gt; <span style="color:#800080;">24</span> ) &amp; <span style="color:#800080;">0xFF</span> ] &lt;&lt; <span style="color:#800080;">24</span><span style="color:#000000;"> );
</span><span style="color:#008080;">46</span> 
<span style="color:#008080;">47</span>     PUT_UINT32_LE( X0, output,  <span style="color:#800080;">0</span><span style="color:#000000;"> );
</span><span style="color:#008080;">48</span>     PUT_UINT32_LE( X1, output,  <span style="color:#800080;">4</span><span style="color:#000000;"> );
</span><span style="color:#008080;">49</span>     PUT_UINT32_LE( X2, output,  <span style="color:#800080;">8</span><span style="color:#000000;"> );
</span><span style="color:#008080;">50</span>     PUT_UINT32_LE( X3, output, <span style="color:#800080;">12</span><span style="color:#000000;"> );
</span><span style="color:#008080;">51</span> }</pre> 
  </div> 
  <p>分析可以得到算法的过程为：</p> 
  <p>轮密钥加-&gt;N-1轮轮变换-&gt;末轮变换</p> 
  <p>其中末轮变换只有：字节置换（subbyte)/行移位（shiftrow)/轮密钥加（addroundkey)</p> 
  <p>中间的轮变换则为：字节置换（subbyte)/行移位（shiftrow)/列混合（mixcol)/轮密钥加（addroundkey)</p> 
  <p>上述代码中，RK为轮密钥，FSb为S盒（Subbyte）的查找表，FTx则包括字节置换与列混合两个过程，因为行移位为线性变换，其运算过程可以和列混合进行交换。</p> 
  <p>AES_ROUND由宏定义得到，代码如下：</p> 
  <div class="cnblogs_code"> 
   <pre><span style="color:#008080;"> 1</span> <span style="color:#0000ff;">#define</span> AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
<span style="color:#008080;"> 2</span> <span style="color:#000000;">{                                               \
</span><span style="color:#008080;"> 3</span>     X0 = *RK++ ^ FT0[ ( Y0       ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;"> 4</span>                  FT1[ ( Y1 &gt;&gt;  <span style="color:#800080;">8</span> ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;"> 5</span>                  FT2[ ( Y2 &gt;&gt; <span style="color:#800080;">16</span> ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;"> 6</span>                  FT3[ ( Y3 &gt;&gt; <span style="color:#800080;">24</span> ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;"> ];    \
</span><span style="color:#008080;"> 7</span> <span style="color:#000000;">                                                \
</span><span style="color:#008080;"> 8</span>     X1 = *RK++ ^ FT0[ ( Y1       ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;"> 9</span>                  FT1[ ( Y2 &gt;&gt;  <span style="color:#800080;">8</span> ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;">10</span>                  FT2[ ( Y3 &gt;&gt; <span style="color:#800080;">16</span> ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;">11</span>                  FT3[ ( Y0 &gt;&gt; <span style="color:#800080;">24</span> ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;"> ];    \
</span><span style="color:#008080;">12</span> <span style="color:#000000;">                                                \
</span><span style="color:#008080;">13</span>     X2 = *RK++ ^ FT0[ ( Y2       ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;">14</span>                  FT1[ ( Y3 &gt;&gt;  <span style="color:#800080;">8</span> ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;">15</span>                  FT2[ ( Y0 &gt;&gt; <span style="color:#800080;">16</span> ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;">16</span>                  FT3[ ( Y1 &gt;&gt; <span style="color:#800080;">24</span> ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;"> ];    \
</span><span style="color:#008080;">17</span> <span style="color:#000000;">                                                \
</span><span style="color:#008080;">18</span>     X3 = *RK++ ^ FT0[ ( Y3       ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;">19</span>                  FT1[ ( Y0 &gt;&gt;  <span style="color:#800080;">8</span> ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;">20</span>                  FT2[ ( Y1 &gt;&gt; <span style="color:#800080;">16</span> ) &amp; <span style="color:#800080;">0xFF</span> ] ^<span style="color:#000000;">   \
</span><span style="color:#008080;">21</span>                  FT3[ ( Y2 &gt;&gt; <span style="color:#800080;">24</span> ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;"> ];    \
</span><span style="color:#008080;">22</span> }</pre> 
  </div> 
  <p>mbedTLS给出了两种实现，1.ROM_TABLE的方式，所有表格直接给出，不再一一列出各种表格；2.表格预计算的方式，由于AES的设计是基于有限域的，表格预计算需要一些有限域的辅助函数，整个预计算的过程如下：</p> 
  <div class="cnblogs_code"> 
   <pre><span style="color:#008080;"> 1</span> <span style="color:#0000ff;">#define</span> ROTL8(x) ( ( x &lt;&lt; 8 ) &amp; 0xFFFFFFFF ) | ( x &gt;&gt; 24 )
<span style="color:#008080;"> 2</span> <span style="color:#0000ff;">#define</span> XTIME(x) ( ( x &lt;&lt; 1 ) ^ ( ( x &amp; 0x80 ) ? 0x1B : 0x00 ) )
<span style="color:#008080;"> 3</span> <span style="color:#0000ff;">#define</span> MUL(x,y) ( ( x &amp;&amp; y ) ? pow[(log[x]+log[y]) % 255] : 0 )
<span style="color:#008080;"> 4</span> 
<span style="color:#008080;"> 5</span> <span style="color:#0000ff;">static</span> <span style="color:#0000ff;">int</span> aes_init_done = <span style="color:#800080;">0</span><span style="color:#000000;">;
</span><span style="color:#008080;"> 6</span> 
<span style="color:#008080;"> 7</span> <span style="color:#0000ff;">static</span> <span style="color:#0000ff;">void</span> aes_gen_tables( <span style="color:#0000ff;">void</span><span style="color:#000000;"> )
</span><span style="color:#008080;"> 8</span> <span style="color:#000000;">{
</span><span style="color:#008080;"> 9</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> i, x, y, z;
</span><span style="color:#008080;">10</span>     <span style="color:#0000ff;">int</span> pow[<span style="color:#800080;">256</span><span style="color:#000000;">];
</span><span style="color:#008080;">11</span>     <span style="color:#0000ff;">int</span> log[<span style="color:#800080;">256</span><span style="color:#000000;">];
</span><span style="color:#008080;">12</span> 
<span style="color:#008080;">13</span>     <span style="color:#008000;">/*</span>
<span style="color:#008080;">14</span> <span style="color:#008000;">     * compute pow and log tables over GF(2^8)
</span><span style="color:#008080;">15</span>      <span style="color:#008000;">*/</span>
<span style="color:#008080;">16</span>     <span style="color:#0000ff;">for</span>( i = <span style="color:#800080;">0</span>, x = <span style="color:#800080;">1</span>; i &lt; <span style="color:#800080;">256</span>; i++<span style="color:#000000;"> )
</span><span style="color:#008080;">17</span> <span style="color:#000000;">    {
</span><span style="color:#008080;">18</span>         pow[i] =<span style="color:#000000;"> x;
</span><span style="color:#008080;">19</span>         log[x] =<span style="color:#000000;"> i;
</span><span style="color:#008080;">20</span>         x = ( x ^ XTIME( x ) ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;">;
</span><span style="color:#008080;">21</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">22</span> 
<span style="color:#008080;">23</span>     <span style="color:#008000;">/*</span>
<span style="color:#008080;">24</span> <span style="color:#008000;">     * calculate the round constants
</span><span style="color:#008080;">25</span>      <span style="color:#008000;">*/</span>
<span style="color:#008080;">26</span>     <span style="color:#0000ff;">for</span>( i = <span style="color:#800080;">0</span>, x = <span style="color:#800080;">1</span>; i &lt; <span style="color:#800080;">10</span>; i++<span style="color:#000000;"> )
</span><span style="color:#008080;">27</span> <span style="color:#000000;">    {
</span><span style="color:#008080;">28</span>         RCON[i] =<span style="color:#000000;"> (uint32_t) x;
</span><span style="color:#008080;">29</span>         x = XTIME( x ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;">;
</span><span style="color:#008080;">30</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">31</span> 
<span style="color:#008080;">32</span>     <span style="color:#008000;">/*</span>
<span style="color:#008080;">33</span> <span style="color:#008000;">     * generate the forward and reverse S-boxes
</span><span style="color:#008080;">34</span>      <span style="color:#008000;">*/</span>
<span style="color:#008080;">35</span>     FSb[<span style="color:#800080;">0x00</span>] = <span style="color:#800080;">0x63</span><span style="color:#000000;">;
</span><span style="color:#008080;">36</span>     RSb[<span style="color:#800080;">0x63</span>] = <span style="color:#800080;">0x00</span><span style="color:#000000;">;
</span><span style="color:#008080;">37</span> 
<span style="color:#008080;">38</span>     <span style="color:#0000ff;">for</span>( i = <span style="color:#800080;">1</span>; i &lt; <span style="color:#800080;">256</span>; i++<span style="color:#000000;"> )
</span><span style="color:#008080;">39</span> <span style="color:#000000;">    {
</span><span style="color:#008080;">40</span>         x = pow[<span style="color:#800080;">255</span> -<span style="color:#000000;"> log[i]];
</span><span style="color:#008080;">41</span> 
<span style="color:#008080;">42</span>         y  = x; y = ( ( y &lt;&lt; <span style="color:#800080;">1</span> ) | ( y &gt;&gt; <span style="color:#800080;">7</span> ) ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;">;
</span><span style="color:#008080;">43</span>         x ^= y; y = ( ( y &lt;&lt; <span style="color:#800080;">1</span> ) | ( y &gt;&gt; <span style="color:#800080;">7</span> ) ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;">;
</span><span style="color:#008080;">44</span>         x ^= y; y = ( ( y &lt;&lt; <span style="color:#800080;">1</span> ) | ( y &gt;&gt; <span style="color:#800080;">7</span> ) ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;">;
</span><span style="color:#008080;">45</span>         x ^= y; y = ( ( y &lt;&lt; <span style="color:#800080;">1</span> ) | ( y &gt;&gt; <span style="color:#800080;">7</span> ) ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;">;
</span><span style="color:#008080;">46</span>         x ^= y ^ <span style="color:#800080;">0x63</span><span style="color:#000000;">;
</span><span style="color:#008080;">47</span> 
<span style="color:#008080;">48</span>         FSb[i] = (unsigned <span style="color:#0000ff;">char</span><span style="color:#000000;">) x;
</span><span style="color:#008080;">49</span>         RSb[x] = (unsigned <span style="color:#0000ff;">char</span><span style="color:#000000;">) i;
</span><span style="color:#008080;">50</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">51</span> 
<span style="color:#008080;">52</span>     <span style="color:#008000;">/*</span>
<span style="color:#008080;">53</span> <span style="color:#008000;">     * generate the forward and reverse tables
</span><span style="color:#008080;">54</span>      <span style="color:#008000;">*/</span>
<span style="color:#008080;">55</span>     <span style="color:#0000ff;">for</span>( i = <span style="color:#800080;">0</span>; i &lt; <span style="color:#800080;">256</span>; i++<span style="color:#000000;"> )
</span><span style="color:#008080;">56</span> <span style="color:#000000;">    {
</span><span style="color:#008080;">57</span>         x =<span style="color:#000000;"> FSb[i];
</span><span style="color:#008080;">58</span>         y = XTIME( x ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;">;
</span><span style="color:#008080;">59</span>         z =  ( y ^ x ) &amp; <span style="color:#800080;">0xFF</span><span style="color:#000000;">;
</span><span style="color:#008080;">60</span> 
<span style="color:#008080;">61</span>         FT0[i] = ( (uint32_t) y       ) ^
<span style="color:#008080;">62</span>                  ( (uint32_t) x &lt;&lt;  <span style="color:#800080;">8</span> ) ^
<span style="color:#008080;">63</span>                  ( (uint32_t) x &lt;&lt; <span style="color:#800080;">16</span> ) ^
<span style="color:#008080;">64</span>                  ( (uint32_t) z &lt;&lt; <span style="color:#800080;">24</span><span style="color:#000000;"> );
</span><span style="color:#008080;">65</span> 
<span style="color:#008080;">66</span>         FT1[i] =<span style="color:#000000;"> ROTL8( FT0[i] );
</span><span style="color:#008080;">67</span>         FT2[i] =<span style="color:#000000;"> ROTL8( FT1[i] );
</span><span style="color:#008080;">68</span>         FT3[i] =<span style="color:#000000;"> ROTL8( FT2[i] );
</span><span style="color:#008080;">69</span> 
<span style="color:#008080;">70</span>         x =<span style="color:#000000;"> RSb[i];
</span><span style="color:#008080;">71</span> 
<span style="color:#008080;">72</span>         RT0[i] = ( (uint32_t) MUL( <span style="color:#800080;">0x0E</span>, x )       ) ^
<span style="color:#008080;">73</span>                  ( (uint32_t) MUL( <span style="color:#800080;">0x09</span>, x ) &lt;&lt;  <span style="color:#800080;">8</span> ) ^
<span style="color:#008080;">74</span>                  ( (uint32_t) MUL( <span style="color:#800080;">0x0D</span>, x ) &lt;&lt; <span style="color:#800080;">16</span> ) ^
<span style="color:#008080;">75</span>                  ( (uint32_t) MUL( <span style="color:#800080;">0x0B</span>, x ) &lt;&lt; <span style="color:#800080;">24</span><span style="color:#000000;"> );
</span><span style="color:#008080;">76</span> 
<span style="color:#008080;">77</span>         RT1[i] =<span style="color:#000000;"> ROTL8( RT0[i] );
</span><span style="color:#008080;">78</span>         RT2[i] =<span style="color:#000000;"> ROTL8( RT1[i] );
</span><span style="color:#008080;">79</span>         RT3[i] =<span style="color:#000000;"> ROTL8( RT2[i] );
</span><span style="color:#008080;">80</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">81</span> }</pre> 
  </div> 
  <p><span style="line-height:1.5;">在有限域运算中，使用了对数表的方式来实现有限域的乘法操作，这是AES设计者在提交算法是所提供的一种计算方式。</span></p> 
  <p>38~50行代码进行有限域求逆算法（使用对数表），再进行仿射变换，求得S盒，同时可以得到逆向S盒。AES的S盒设计为（A*x<sup>-1</sup>+b)，A为2进制矩阵，b为2进制列向量（0x63）。</p> 
  <p>再计算FTx,FTx的计算需要有限域乘法操作，其乘法为固定乘法操作，主要有x2与x3,（逆变换乘数为0x0e,0x09,0x0d,0x0b)。其中有限域的乘法运算也是基于对数表完成的。</p> 
  <p>2.算法简介</p> 
  <p>……</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lkiller_hust/article/details/51344827,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lkiller_hust/article/details/51344827,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
