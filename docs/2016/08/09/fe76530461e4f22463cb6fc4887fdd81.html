<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>BlockChain技术系列(三)- fabric协议介绍 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="BlockChain技术系列(三)- fabric协议介绍" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="fabric的点对点（peer-to-peer）通信是建立在允许双向的基于流的消息gRPC上的。它使用Protocol Buffers来序列化peer之间传输的数据结构。Protocol buffers 是语言无关，平台无关并具有可扩展机制来序列化结构化的数据的技术。数据结构，消息和服务是使用&nbsp;proto3 language注释来描述的。 3.1 消息 消息在节点之间通过Messageproto 结构封装来传递的，可以分为 4 种类型：发现（Discovery）, 交易（Transaction）, 同步(Synchronization)和共识(Consensus)。每种类型在payload中定义了多种子类型。 message Message { enum Type { UNDEFINED = 0; DISC_HELLO = 1; DISC_DISCONNECT = 2; DISC_GET_PEERS = 3; DISC_PEERS = 4; DISC_NEWMSG = 5; CHAIN_STATUS = 6; CHAIN_TRANSACTION = 7; CHAIN_GET_TRANSACTIONS = 8; CHAIN_QUERY = 9; SYNC_GET_BLOCKS = 11; SYNC_BLOCKS = 12; SYNC_BLOCK_ADDED = 13; SYNC_STATE_GET_SNAPSHOT = 14; SYNC_STATE_SNAPSHOT = 15; SYNC_STATE_GET_DELTAS = 16; SYNC_STATE_DELTAS = 17; RESPONSE = 20; CONSENSUS = 21; } Type type = 1; bytes payload = 2; google.protobuf.Timestamp timestamp = 3; } payload是由不同的消息类型所包含的不同的像Transaction或Response这样的对象的不透明的字节数组。例如：type为CHAIN_TRANSACTION那么payload就是一个Transaction对象。 3.1.1 发现消息 在启动时，如果CORE_PEER_DISCOVERY_ROOTNODE被指定，那么 peer 就会运行发现协议。CORE_PEER_DISCOVERY_ROOTNODE是网络（任意peer）中扮演用来发现所有 peer 的起点角色的另一个 peer 的 IP 地址。协议序列以payload是一个包含： message HelloMessage { PeerEndpoint peerEndpoint = 1; uint64 blockNumber = 2; } message PeerEndpoint { PeerID ID = 1; string address = 2; enum Type { UNDEFINED = 0; VALIDATOR = 1; NON_VALIDATOR = 2; } Type type = 3; bytes pkiID = 4; } message PeerID { string name = 1; } 这样的端点的HelloMessage对象的DISC_HELLO消息开始的。 域的定义: PeerID&nbsp;是在启动时或配置文件中定义的 peer 的任意名字 PeerEndpoint&nbsp;描述了端点和它是验证还是非验证 peer pkiID&nbsp;是 peer 的加密ID address&nbsp;以ip:port这样的格式表示的 peer 的主机名或IP和端口 blockNumber&nbsp;是 peer 的区块链的当前的高度 如果收到的DISC_HELLO&nbsp;消息的块的高度比当前 peer 的块的高度高，那么它马上初始化同步协议来追上当前的网络。 DISC_HELLO之后，peer 会周期性的发送DISC_GET_PEERS来发现任意想要加入网络的 peer。收到DISC_GET_PEERS后，peer 会发送payload&nbsp;包含PeerEndpoint的数组的DISC_PEERS作为响应。这是不会使用其它的发现消息类型。 3.1.2 交易消息 有三种不同的交易类型：部署（Deploy），调用（Invoke）和查询（Query）。部署交易向链上安装指定的链码，调用和查询交易会调用部署号的链码。另一种需要考虑的类型是创建（Create）交易，其中部署好的链码是可以在链上实例化并寻址的。这种类型在写这份文档时还没有被实现。 3.1.2.1 交易的数据结构 CHAIN_TRANSACTION和CHAIN_QUERY类型的消息会在payload带有Transaction对象： message Transaction { enum Type { UNDEFINED = 0; CHAINCODE_DEPLOY = 1; CHAINCODE_INVOKE = 2; CHAINCODE_QUERY = 3; CHAINCODE_TERMINATE = 4; } Type type = 1; string uuid = 5; bytes chaincodeID = 2; bytes payloadHash = 3; ConfidentialityLevel confidentialityLevel = 7; bytes nonce = 8; bytes cert = 9; bytes signature = 10; bytes metadata = 4; google.protobuf.Timestamp timestamp = 6; } message TransactionPayload { bytes payload = 1; } enum ConfidentialityLevel { PUBLIC = 0; CONFIDENTIAL = 1; } 域的定义: type&nbsp;- 交易的类型, 为1时表示: UNDEFINED&nbsp;- 为未来的使用所保留. CHAINCODE_DEPLOY&nbsp;- 代表部署新的链码. CHAINCODE_INVOKE&nbsp;- 代表一个链码函数被执行并修改了世界状态 CHAINCODE_QUERY&nbsp;- 代表一个链码函数被执行并可能只读取了世界状态 CHAINCODE_TERMINATE&nbsp;- 标记的链码不可用，所以链码中的函数将不能被调用 chaincodeID&nbsp;- 链码源码，路径，构造函数和参数哈希所得到的ID payloadHash&nbsp;-&nbsp;TransactionPayload.payload所定义的哈希字节. metadata&nbsp;- 应用可能使用的，由自己定义的任意交易相关的元数据 uuid&nbsp;- 交易的唯一ID timestamp&nbsp;- peer 收到交易时的时间戳 confidentialityLevel&nbsp;- 数据保密的级别。当前有两个级别。未来可能会有多个级别。 nonce&nbsp;- 为安全而使用 cert&nbsp;- 交易者的证书 signature&nbsp;- 交易者的签名 TransactionPayload.payload&nbsp;- 交易的payload所定义的字节。由于payload可以很大，所以交易消息只包含payload的哈希 交易安全的详细信息可以在第四节找到 3.1.2.2 交易规范 一个交易通常会关联链码定义及其执行环境（像语言和安全上下文）的链码规范。现在，有一个使用Go语言来编写链码的实现。将来可能会添加新的语言。 message ChaincodeSpec { enum Type { UNDEFINED = 0; GOLANG = 1; NODE = 2; } Type type = 1; ChaincodeID chaincodeID = 2; ChaincodeInput ctorMsg = 3; int32 timeout = 4; string secureContext = 5; ConfidentialityLevel confidentialityLevel = 6; bytes metadata = 7; } message ChaincodeID { string path = 1; string name = 2; } message ChaincodeInput { string function = 1; repeated string args = 2; } 域的定义: chaincodeID&nbsp;- 链码源码的路径和名字 ctorMsg&nbsp;- 调用的函数名及参数 timeout&nbsp;- 执行交易所需的时间（以毫秒表示） confidentialityLevel&nbsp;- 这个交易的保密级别 secureContext&nbsp;- 交易者的安全上下文 metadata&nbsp;- 应用想要传递下去的任何数据 当 peer 收到chaincodeSpec后以合适的交易消息包装它并广播到网络 3.1.2.3 部署交易 部署交易的类型是CHAINCODE_DEPLOY，且它的payload包含ChaincodeDeploymentSpec对象。 message ChaincodeDeploymentSpec { ChaincodeSpec chaincodeSpec = 1; google.protobuf.Timestamp effectiveDate = 2; bytes codePackage = 3; } 域的定义: chaincodeSpec&nbsp;- 参看上面的3.1.2.2节. effectiveDate&nbsp;- 链码准备好可被调用的时间 codePackage&nbsp;- 链码源码的gzip 当验证 peer 部署链码时，它通常会校验codePackage的哈希来保证交易被部署到网络后没有被篡改。 3.1.2.4 调用交易 调用交易的类型是CHAINCODE_DEPLOY，且它的payload包含ChaincodeInvocationSpec对象。 message ChaincodeInvocationSpec { ChaincodeSpec chaincodeSpec = 1; } 3.1.2.5 查询交易 查询交易除了消息类型是CHAINCODE_QUERY其它和调用交易一样 3.1.3 同步消息 同步协议以3.1.1节描述的，当 peer 知道它自己的区块落后于其它 peer 或和它们不一样后所发起的。peer 广播SYNC_GET_BLOCKS，SYNC_STATE_GET_SNAPSHOT或SYNC_STATE_GET_DELTAS并分别接收SYNC_BLOCKS,&nbsp;SYNC_STATE_SNAPSHOT或SYNC_STATE_DELTAS。 安装的共识插件（如：pbft）决定同步协议是如何被应用的。每个小时是针对具体的状态来设计的： SYNC_GET_BLOCKS&nbsp;是一个SyncBlockRange对象，包含一个连续区块的范围的payload的请求。 message SyncBlockRange { uint64 start = 1; uint64 end = 2; uint64 end = 3; } 接收peer使用包含&nbsp;SyncBlocks对象的payload的SYNC_BLOCKS信息来响应 message SyncBlocks { SyncBlockRange range = 1; repeated Block blocks = 2; } start和end标识包含的区块的开始和结束，返回区块的顺序由start和end的值定义。如：当start=3，end=5时区块的顺序将会是3，4，5。当start=5，end=3时区块的顺序将会是5，4，3。 SYNC_STATE_GET_SNAPSHOT&nbsp;请求当前世界状态的快照。&nbsp;payload是一个SyncStateSnapshotRequest对象 message SyncStateSnapshotRequest { uint64 correlationId = 1; } correlationId是请求 peer 用来追踪响应消息的。接受 peer 回复payload为SyncStateSnapshot实例的SYNC_STATE_SNAPSHOT信息 message SyncStateSnapshot { bytes delta = 1; uint64 sequence = 2; uint64 blockNumber = 3; SyncStateSnapshotRequest request = 4; } 这条消息包含快照或以0开始的快照流序列中的一块。终止消息是len(delta) == 0的块 SYNC_STATE_GET_DELTAS&nbsp;请求连续区块的状态变化。默认情况下总账维护500笔交易变化。 delta(j)是block(i)和block(j)之间的状态转变，其中i=j-1。&nbsp;payload包含SyncStateDeltasRequest实例 message SyncStateDeltasRequest { SyncBlockRange range = 1; } 接收 peer 使用包含&nbsp;SyncStateDeltas实例的payload的SYNC_STATE_DELTAS信息来响应 message SyncStateDeltas { SyncBlockRange range = 1; repeated bytes deltas = 2; } delta可能以顺序（从i到j）或倒序（从j到i）来表示状态转变 3.1.4 共识消息 共识处理交易，一个CONSENSUS消息是由共识框架接收到CHAIN_TRANSACTION消息时在内部初始化的。框架把CHAIN_TRANSACTION转换为&nbsp;CONSENSUS然后以相同的payload广播到验证 peer。共识插件接收这条消息并根据内部算法来处理。插件可能创建自定义的子类型来管理共识有穷状态机。3.4节会介绍详细信息。 3.2 总账 总账由两个主要的部分组成，一个是区块链，一个是世界状态。区块链是在总账中的一系列连接好的用来记录交易的区块。世界状态是一个用来存储交易执行状态的键-值(key-value)数据库 3.2.1 区块链 3.2.1.1 区块 区块链是由一个区块链表定义的，每个区块包含它在链中前一个区块的哈希。区块包含的另外两个重要信息是它包含区块执行所有交易后的交易列表和世界状态的哈希 message Block { version = 1; google.protobuf.Timestamp timestamp = 2; bytes transactionsHash = 3; bytes stateHash = 4; bytes previousBlockHash = 5; bytes consensusMetadata = 6; NonHashData nonHashData = 7; } message BlockTransactions { repeated Transaction transactions = 1; } 域的定义: version&nbsp;- 用来追踪协议变化的版本号 timestamp&nbsp;- 由区块提议者填充的时间戳 transactionsHash&nbsp;- 区块中交易的merkle root hash stateHash&nbsp;- 世界状态的merkle root hash previousBlockHash&nbsp;- 前一个区块的hash consensusMetadata&nbsp;- 共识可能会引入的一些可选的元数据 nonHashData&nbsp;-&nbsp;NonHashData消息会在计算区块的哈希前设置为nil，但是在数据库中存储为区块的一部分 BlockTransactions.transactions&nbsp;- 交易消息的数组，由于交易的大小，它们不会被直接包含在区块中 3.2.1.2 区块哈希 previousBlockHash哈希是通过下面算法计算的 使用protocol buffer库把区块消息序列化为字节码 使用FIPS 202描述的SHA3 SHAKE256算法来对序列化后的区块消息计算大小为512位的哈希值 transactionHash是交易merkle树的根。定义merkle tree实现是一个代办 stateHash在3.2.2.1节中定义. 3.2.1.3 非散列数据(NonHashData) NonHashData消息是用来存储不需要所有 peer 都具有相同值的块元数据。他们是建议值。 message NonHashData { google.protobuf.Timestamp localLedgerCommitTimestamp = 1; repeated TransactionResult transactionResults = 2; } message TransactionResult { string uuid = 1; bytes result = 2; uint32 errorCode = 3; string error = 4; } localLedgerCommitTimestamp&nbsp;- 标识区块提交到本地总账的时间戳 TransactionResult&nbsp;- 交易结果的数组 TransactionResult.uuid&nbsp;- 交易的ID TransactionResult.result&nbsp;- 交易的返回值 TransactionResult.errorCode&nbsp;- 可以用来记录关联交易的错误信息的代码 TransactionResult.error&nbsp;- 用来记录关联交易的错误信息的字符串 3.2.1.4 交易执行 一个交易定义了它们部署或执行的链码。区块中的所有交易都可以在记录到总账中的区块之前运行。当链码执行时，他们可能会改变世界状态。之后世界状态的哈希会被记录在区块中。 3.2.2 世界状态 peer 的世界状态涉及到所有被部署的链码的状态集合。进一步说，链码的状态由键值对集合来表示。所以，逻辑上说，peer 的世界状态也是键值对的集合，其中键有元组{chaincodeID, ckey}组成。这里我们使用术语key来标识世界状态的键，如：元组{chaincodeID, ckey}&nbsp;，而且我们使用cKey来标识链码中的唯一键。 为了下面描述的目的，假定chaincodeID是有效的utf8字符串，且ckey和value是一个或多个任意的字节的序列 3.2.2.1 世界状态的哈希 当网络活动时，很多像交易提交和同步 peer 这样的场合可能需要计算 peer 观察到的世界状态的加密-哈希。例如，共识协议可能需要保证网络中最小数量的 peer 观察到同样的世界状态。 应为计算世界状态的加密-哈希是一个非常昂贵的操作，组织世界状态来使得当它改变时能高效效的计算加密-哈希是非常可取的。将来，可以根据不同的负载条件来设计不同的组织形式。 由于fabric是被期望在不同的负载条件下都能正常工作，所以需要一个可拔插的机制来支持世界状态的组织。 3.2.2.1.1 Bucket-tree Bucket-tree&nbsp;是世界状态的组织方式的实现。为了下面描述的目的，世界状态的键被表示成两个组件(chaincodeID&nbsp;and&nbsp;ckey) 的通过nil字节的级联，如：key&nbsp;=&nbsp;chaincodeID+nil+cKey。 这个方法的模型是一个merkle-tree在hash table桶的顶部来计算世界状态的加密-哈希 这个方法的核心是世界状态的key-values被假定存储在由预先决定的桶的数量(numBuckets)所组成的哈希表中。一个哈希函数(hashFunction) 被用来确定包含给定键的桶数量。注意hashFunction不代表SHA3这样的加密-哈希方法，而是决定给定的键的桶的数量的正规的编程语言散列函数。 为了对 merkle-tree建模，有序桶扮演了树上的叶子节点-编号最低的桶是树中的最左边的叶子节点。为了构造树的最后第二层，叶子节点的预定义数量 (maxGroupingAtEachLevel)，从左边开始把每个这样的分组组合在一起，一个节点被当作组中所有叶子节点的共同父节点来插入到最后第二层中。注意最后的父节点的数量可能会少于maxGroupingAtEachLevel这个构造方式继续使用在更高的层级上直到树的根节点被构造。 下面这个表展示的在{numBuckets=10009 and maxGroupingAtEachLevel=10}的配置下会得到的树在不同层级上的节点数。 Level Number of nodes 0 1 1 2 2 11 3 101 4 1001 5 10009 为了计算世界状态的加密-哈希，需要计算每个桶的加密-哈希，并假设它们是merkle-tree的叶子节点的加密-哈希。为了计算桶的加密-哈希，存储在桶中的键值对首先被序列化为字节码并在其上应用加密-哈希函数。为了序列化桶的键值对，所有具有公共chaincodeID前缀的键值对分别序列化并以chaincodeID的升序的方式追加在一起。为了序列化一个chaincodeID的键值对，会涉及到下面的信息： chaincodeID的长度(chaincodeID的字节数) chaincodeID的utf8字节码 chaincodeID的键值对数量 对于每个键值对(以ckey排序) ckey的长度 ckey的字节码 值的长度 值的字节码 对于上面列表的所有数值类型项（如：chaincodeID的长度），使用protobuf的变体编码方式。上面这种编码方式的目的是为了桶中的键值对的字节表示方式不会被任意其他键值对的组合所产生，并减少了序列化字节码的总体大小。 例如：考虑具有chaincodeID1_key1:value1, chaincodeID1_key2:value2, 和 chaincodeID2_key1:value1这样名字的键值对的桶。序列化后的桶看上去会像：12 + chaincodeID1 + 2 + 4 + key1 + 6 + value1 + 4 + key2 + 6 + value2 + 12 + chaincodeID2 + 1 + 4 + key1 + 6 + value1 如果桶中没有键值对，那么加密-哈希为nil。 中间节点和根节点的加密-哈希与标准merkle-tree的计算方法一样，即：应用加密-哈希函数到所有子节点的加密-哈希从左到右级联后得到的字节码。进一步说，如果一个子节点的加密-哈希为nil，那么这个子节点的加密-哈希在级联子节点的加密-哈希是就被省略。如果它只有一个子节点，那么它的加密-哈希就是子节点的加密-哈希。最后，根节点的加密-哈希就是世界状态的加密-哈希。 上面这种方法在状态中少数键值对改变时计算加密-哈希是有性能优势的。主要的优势包括： 那些没有变化的桶的计算会被跳过 merkle-tree的宽度和深度可以通过配置numBuckets和maxGroupingAtEachLevel参数来控制。树的不同深度和宽度对性能和不同的资源都会产生不同的影响。 在一个具体的部署中，所有的 peer 都期望使用相同的numBuckets, maxGroupingAtEachLevel, 和 hashFunction的配置。进一步说，如果任何一个配置在之后的阶段被改变，那么这些改变需要应用到所有的 peer 中，来保证 peer 节点之间的加密-哈希的比较是有意义的。即使，这可能会导致基于实现的已有数据的迁移。例如：一种实现希望存储树中所有节点最后计算的加密-哈希，那么它就需要被重新计算。 3.3 链码（Chaincode） 链码是在交易（参看3.1.2节）被部署是分发到网络上，并被所有验证 peer 通过隔离的沙箱来管理的应用级代码。尽管任意的虚拟技术都可以支持沙箱，现在是通过Docker容器来运行链码的。这节中描述的协议可以启用不同虚拟实现的插入与运行。 3.3.1 虚拟机实例化 一个实现VM接口的虚拟机 type VM interface { build(ctxt context.Context, id string, args []string, env []string, attachstdin bool, attachstdout bool, reader io.Reader) error start(ctxt context.Context, id string, args []string, env []string, attachstdin bool, attachstdout bool) error stop(ctxt context.Context, id string, timeout uint, dontkill bool, dontremove bool) error } fabric在处理链码上的部署交易或其他交易时，如果这个链码的VM未启动（崩溃或之前的不活动导致的关闭）时实例化VM。每个链码镜像通过build函数构建，通过start函数启动，并使用stop函数停止。 一旦链码容器被启动，它使用gRPC来连接到启动这个链码的验证 peer，并为链码上的调用和查询交易建立通道。 3.3.2 链码协议 验证 peer 和它的链码之间是通过gRPC流来通信的。链码容器上有shim层来处理链码与验证 peer 之间的protobuf消息协议。 message ChaincodeMessage { enum Type { UNDEFINED = 0; REGISTER = 1; REGISTERED = 2; INIT = 3; READY = 4; TRANSACTION = 5; COMPLETED = 6; ERROR = 7; GET_STATE = 8; PUT_STATE = 9; DEL_STATE = 10; INVOKE_CHAINCODE = 11; INVOKE_QUERY = 12; RESPONSE = 13; QUERY = 14; QUERY_COMPLETED = 15; QUERY_ERROR = 16; RANGE_QUERY_STATE = 17; } Type type = 1; google.protobuf.Timestamp timestamp = 2; bytes payload = 3; string uuid = 4; } 域的定义: Type&nbsp;是消息的类型 payload&nbsp;是消息的payload. 每个payload取决于Type. uuid&nbsp;消息唯一的ID 消息的类型在下面的小节中描述 链码实现被验证 peer 在处理部署，调用或查询交易时调用的Chaincode接口 type Chaincode interface { Invoke(stub *ChaincodeStub, function string, args []string) (error) Query(stub *ChaincodeStub, function string, args []string) ([]byte, error) } Init,&nbsp;Invoke&nbsp;和&nbsp;Query函数使用function&nbsp;and&nbsp;args参数来支持多种交易。Init是构造函数，它只在部署交易是被执行。Query函数是不允许修改链码的状态的；它只能读取和计算并以byte数组的形式返回。 3.3.2.1 链码部署 当部署时（链码容器已经启动），shim层发送一次性的具有包含ChaincodeID的payload的REGISTER消息给验证 peer。然后 peer 以REGISTERED或ERROR来响应成功或失败。当收到ERROR后shim关闭连接并退出。 注册之后，验证 peer 发送具有包含ChaincodeInput对象的INIT消息。shim使用从ChaincodeInput获得的参数来调用Init函数，通过像设置持久化状态这样操作来初始化链码。 shim根据Init函数的返回值，响应RESPONSE或ERROR消息。如果没有错误，那么链码初始化完成，并准备好接收调用和查询交易。 3.3.2.2 链码调用 当处理调用交易时，验证 peer 发送TRANSACTION消息给链码容器的shim，由它来调用链码的Invoke函数，并传递从ChaincodeInput得到的参数。shim响应RESPONSE或ERROR消息来表示函数完成。如果接收到ERROR函数，payload包含链码所产生的错误信息。 3.3.2.3 来代码查询 与调用交易一样，验证 peer 发送QUERY消息给链码容器的shim，由它来调用链码的Query函数，并传递从ChaincodeInput得到的参数。Query函数可能会返回状态值或错误，它会把它通过RESPONSE或ERROR消息来传递给验证 peer。 3.3.2.4 链码状态 每个链码可能都定义了它自己的持久化状态变量。例如，一个链码可能创建电视，汽车或股票这样的资产来保存资产属性。当Invoke函数处理时，链码可能会更新状态变量，例如改变资产所有者。链码会根据下面这些消息类型类操作状态变量： PUT_STATE 链码发送一个payload包含PutStateInfo对象的PU_STATE消息来保存键值对。 message PutStateInfo { string key = 1; bytes value = 2; } GET_STATE 链码发送一个由payload指定要获取值的键的GET_STATE消息。 DEL_STATE 链码发送一个由payload指定要删除值的键的DEL_STATE消息。 RANGE_QUERY_STATE 链码发送一个payload包含RANGE_QUERY_STATE对象的RANGE_QUERY_STATE来获取一个范围内的值。 message RangeQueryState { string startKey = 1; string endKey = 2; } startKey和endKey假设是通过字典排序的. 验证 peer 响应一个payload是RangeQueryStateResponse对象的RESPONSE消息 message RangeQueryStateResponse { repeated RangeQueryStateKeyValue keysAndValues = 1; bool hasMore = 2; string ID = 3; } message RangeQueryStateKeyValue { string key = 1; bytes value = 2; } 如果相应中hasMore=true，这表示有在请求的返回中还有另外的键。链码可以通过发送包含与响应中ID相同的ID的RangeQueryStateNext消息来获取下一集合。 message RangeQueryStateNext { string ID = 1; } 当链码结束读取范围，它会发送带有ID的RangeQueryStateClose消息来期望它关闭。 message RangeQueryStateClose { string ID = 1; } INVOKE_CHAINCODE 链码可以通过发送payload包含&nbsp;ChaincodeSpec对象的INVOKE_CHAINCODE消息给验证 peer 来在相同的交易上下文中调用另一个链码 QUERY_CHAINCODE 链码可以通过发送payload包含&nbsp;ChaincodeSpec对象的QUERY_CHAINCODE消息给验证 peer 来在相同的交易上下文中查询另一个链码 3.4 插拔式共识框架 共识框架定义了每个共识插件都需要实现的接口： consensus.Consenter: 允许共识插件从网络上接收消息的接口 consensus.CPI: 共识编程接口Consensus Programming Interface&nbsp;(CPI) 是共识插件用来与栈交互的，这个接口可以分为两部分： consensus.Communicator: 用来发送（广播或单播）消息到其他的验证 peer consensus.LedgerStack: 这个接口使得执行框架像总账一样方便 就像下面描述的细节一样，consensus.LedgerStack封装了其他接口，consensus.Executor接口是共识框架的核心部分。换句话说，consensus.Executor接口允许一个（批量）交易启动，执行，根据需要回滚，预览和提交。每一个共识插件都需要满足以所有验证 peer 上全序的方式把批量（块）交易（通过consensus.Executor.CommitTxBatch）被提交到总账中（参看下面的consensus.Executor接口获得详细细节）。 当前，共识框架由consensus,&nbsp;controller和helper这三个包组成。使用controller和helper包的主要原因是防止Go语言的“循环引入”和当插件更新时的最小化代码变化。 controller&nbsp;包规范了验证 peer 所使用的共识插件 helper&nbsp;是围绕公式插件的垫片，它是用来与剩下的栈交互的，如为其他 peer 维护消息。 这里有2个共识插件提供：pbft和noops： obcpbft包包含实现&nbsp;PBFT&nbsp;[1] 和&nbsp;Sieve&nbsp;共识协议的共识插件。参看第5节的详细介绍 noops&nbsp;是一个为开发和测试提供的&#39;&#39;假的&#39;&#39;共识插件. 它处理所有共识消息但不提供共识功能，它也是一个好的学习如何开发一个共识插件的简单例子。 3.4.1&nbsp;Consenter&nbsp;接口 定义: type Consenter interface { RecvMsg(msg *pb.Message) error } Consenter接口是插件对（外部的）客户端请求的入口，当处理共识时，共识消息在内部（如从共识模块）产生。NewConsenter创建Consenter插件。RecvMsg`以到达共识的顺序来处理进来的交易。 阅读下面的helper.HandleMessage来理解 peer 是如何和这个接口来交互的。 3.4.2&nbsp;CPI接口 定义: type CPI interface { Inquirer Communicator SecurityUtils LedgerStack } CPI&nbsp;允许插件和栈交互。它是由helper.Helper对象实现的。回想一下这个对象是： 在helper.NewConsensusHandler被调用时初始化的 当它们的插件构造了consensus.Consenter对象，那么它对插件的作者是可访问的 3.4.3&nbsp;Inquirer接口 定义: type Inquirer interface { GetNetworkInfo() (self *pb.PeerEndpoint, network []*pb.PeerEndpoint, err error) GetNetworkHandles() (self *pb.PeerID, network []*pb.PeerID, err error) } 这个接口是consensus.CPI接口的一部分。它是用来获取网络中验证 peer 的（GetNetworkHandles）处理，以及那些验证 peer 的明细(GetNetworkInfo)： 注意pees由pb.PeerID对象确定。这是一个protobuf消息，当前定义为（注意这个定义很可能会被修改）： message PeerID { string name = 1; } 3.4.4&nbsp;Communicator接口 定义: type Communicator interface { Broadcast(msg *pb.Message) error Unicast(msg *pb.Message, receiverHandle *pb.PeerID) error } 这个接口是consensus.CPI接口的一部分。它是用来与网络上其它 peer 通信的（helper.Broadcast,&nbsp;helper.Unicast）： 3.4.5&nbsp;SecurityUtils接口 定义: type SecurityUtils interface { Sign(msg []byte) ([]byte, error) Verify(peerID *pb.PeerID, signature []byte, message []byte) error } 这个接口是consensus.CPI接口的一部分。它用来处理消息签名(Sign)的加密操作和验证签名(Verify) 3.4.6&nbsp;LedgerStack&nbsp;接口 定义: type LedgerStack interface { Executor Ledger RemoteLedgers } CPI接口的主要成员，LedgerStack&nbsp;组与fabric的其它部分与共识相互作用，如执行交易，查询和更新总账。这个接口支持对本地区块链和状体的查询，更新本地区块链和状态，查询共识网络上其它节点的区块链和状态。它是有Executor,Ledger和RemoteLedgers这三个接口组成的。下面会描述它们。 3.4.7&nbsp;Executor&nbsp;接口 定义: type Executor interface { BeginTxBatch(id interface{}) error ExecTXs(id interface{}, txs []*pb.Transaction) ([]byte, []error) CommitTxBatch(id interface{}, transactions []*pb.Transaction, transactionsResults []*pb.TransactionResult, metadata []byte) error RollbackTxBatch(id interface{}) error PreviewCommitTxBatchBlock(id interface{}, transactions []*pb.Transaction, metadata []byte) (*pb.Block, error) } executor接口是LedgerStack接口最常使用的部分，且是共识网络工作的必要部分。接口允许交易启动，执行，根据需要回滚，预览和提交。这个接口由下面这些方法组成。 3.4.7.1 开始批量交易 BeginTxBatch(id interface{}) error 这个调用接受任意的，故意含糊的id，来使得共识插件可以保证与这个具体的批量相关的交易才会被执行。例如：在pbft实现中，这个id是被执行交易的编码过的哈希。 3.4.7.2 执行交易 ExecTXs(id interface{}, txs []*pb.Transaction) ([]byte, []error) 这个调用根据总账当前的状态接受一组交易，并返回带有对应着交易组的错误信息组的当前状态的哈希。注意一个交易所产生的错误不影响批量交易的安全提交。当遇到失败所采用的策略取决与共识插件的实现。这个接口调用多次是安全的。 3.4.7.3 提交与回滚交易 RollbackTxBatch(id interface{}) error 这个调用忽略了批量执行。这会废弃掉对当前状态的操作，并把总账状态回归到之前的状态。批量是从BeginBatchTx开始的，如果需要开始一个新的就需要在执行任意交易之前重新创建一个。 PreviewCommitTxBatchBlock(id interface{}, transactions []*pb.Transaction, metadata []byte) (*pb.Block, error) 这个调用是共识插件对非确定性交易执行的测试时最有用的方法。区块返回的哈希表部分会保证，当CommitTxBatch被立即调用时的区块是同一个。这个保证会被任意新的交易的执行所打破。 CommitTxBatch(id interface{}, transactions []*pb.Transaction, transactionsResults []*pb.TransactionResult, metadata []byte) error 这个调用提交区块到区块链中。区块必须以全序提交到区块链中，CommitTxBatch结束批量交易，在执行或提交任意的交易之前必须先调用BeginTxBatch。 3.4.8&nbsp;Ledger&nbsp;接口 定义： type Ledger interface { ReadOnlyLedger UtilLedger WritableLedger } Ledger&nbsp;接口是为了允许共识插件询问或可能改变区块链当前状态。它是由下面描述的三个接口组成的 3.4.8.1&nbsp;ReadOnlyLedger&nbsp;接口 定义： type ReadOnlyLedger interface { GetBlock(id uint64) (block *pb.Block, err error) GetCurrentStateHash() (stateHash []byte, err error) GetBlockchainSize() (uint64, error) } ReadOnlyLedger&nbsp;接口是为了查询总账的本地备份，而不会修改它。它是由下面这些函数组成的。 GetBlockchainSize() (uint64, error) 这个函数返回区块链总账的长度。一般来说，这个函数永远不会失败，在这种不太可能发生情况下，错误被传递给调用者，由它确定是否需要恢复。具有最大区块值的区块的值为GetBlockchainSize()-1 注意在区块链总账的本地副本是腐坏或不完整的情况下，这个调用会返回链中最大的区块值+1。这允许节点在旧的块是腐坏或丢失的情况下能继续操作当前状态/块。 GetBlock(id uint64) (block *pb.Block, err error) 这个调用返回区块链中块的数值id。一般来说这个调用是不会失败的，除非请求的区块超出当前区块链的长度，或者底层的区块链被腐坏了。GetBlock的失败可能可以通过状态转换机制来取回它。 GetCurrentStateHash() (stateHash []byte, err error) 这个盗用返回总账的当前状态的哈希。一般来说，这个函数永远不会失败，在这种不太可能发生情况下，错误被传递给调用者，由它确定是否需要恢复。 3.4.8.2&nbsp;UtilLedger&nbsp;接口 定义： type UtilLedger interface { HashBlock(block *pb.Block) ([]byte, error) VerifyBlockchain(start, finish uint64) (uint64, error) } UtilLedger&nbsp;接口定义了一些由本地总账提供的有用的功能。使用mock接口来重载这些功能在测试时非常有用。这个接口由两个函数构成。 会会 HashBlock(block *pb.Block) ([]byte, error) 尽管*pb.Block定义了GetHash方法，为了mock测试，重载这个方法会非常有用。因此，建议GetHash方法不直接调用，而是通过UtilLedger.HashBlock接口来调用这个方法。一般来说，这个函数永远不会失败，但是错误还是会传递给调用者，让它决定是否使用适当的恢复。 VerifyBlockchain(start, finish uint64) (uint64, error) 这个方法是用来校验区块链中的大的区域。它会从高的块start到低的块finish，返回第一个块的PreviousBlockHash与块的前一个块的哈希不相符的块编号以及错误信息。注意，它一般会标识最后一个好的块的编号，而不是第一个坏的块的编号。 3.4.8.3&nbsp;WritableLedger&nbsp;接口 定义： type WritableLedger interface { PutBlock(blockNumber uint64, block *pb.Block) error ApplyStateDelta(id interface{}, delta *statemgmt.StateDelta) error CommitStateDelta(id interface{}) error RollbackStateDelta(id interface{}) error EmptyState() error } WritableLedger&nbsp;接口允许调用者更新区块链。注意这NOT&nbsp;不是共识插件的通常用法。当前的状态需要通过Executor接口执行交易来修改，新的区块在交易提交时生成。相反的，这个接口主要是用来状态改变和腐化恢复。特别的，这个接口下的函数永远不能直接暴露给共识消息，这样会导致打破区块链所承诺的不可修改这一概念。这个结构包含下面这些函数。 -&nbsp;&nbsp;PutBlock(blockNumber uint64, block *pb.Block) error&nbsp;&nbsp;这个函数根据给定的区块编号把底层区块插入到区块链中。注意这是一个不安全的接口，所以它不会有错误返回或返回。插入一个比当前区块高度更高的区块是被允许的，通用，重写一个已经提交的区块也是被允许的。记住，由于哈希技术使得创建一个链上的更早的块是不可行的，所以这并不影响链的可审计性和不可变性。任何尝试重写区块链的历史的操作都能很容易的被侦测到。这个函数一般只用于状态转移API。 -&nbsp;&nbsp;ApplyStateDelta(id interface{}, delta *statemgmt.StateDelta) error&nbsp; 这个函数接收状态变化，并把它应用到当前的状态。变化量的应用会使得状态向前或向后转变，这取决于状态变化量的构造，与`Executor`方法一样，`ApplyStateDelta`接受一个同样会被传递给`CommitStateDelta` or `RollbackStateDelta`不透明的接口`id` -&nbsp;&nbsp;CommitStateDelta(id interface{}) error&nbsp; 这个方法提交在`ApplyStateDelta`中应用的状态变化。这通常是在调用者调用`ApplyStateDelta`后通过校验由`GetCurrentStateHash()`获得的状态哈希之后调用的。这个函数接受与传递给`ApplyStateDelta`一样的`id`。 -&nbsp;&nbsp;RollbackStateDelta(id interface{}) error&nbsp; 这个函数撤销在`ApplyStateDelta`中应用的状态变化量。这通常是在调用者调用`ApplyStateDelta`后与由`GetCurrentStateHash()`获得的状态哈希校验失败后调用的。这个函数接受与传递给`ApplyStateDelta`一样的`id`。 -&nbsp;&nbsp;EmptyState() error&nbsp; 这个函数将会删除整个当前状态，得到原始的空状态。这通常是通过变化量加载整个新的状态时调用的。这一样只对状态转移API有用。 3.4.9&nbsp;RemoteLedgers&nbsp;接口 定义： type RemoteLedgers interface { GetRemoteBlocks(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncBlocks, error) GetRemoteStateSnapshot(peerID uint64) (&lt;-chan *pb.SyncStateSnapshot, error) GetRemoteStateDeltas(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncStateDeltas, error) } RemoteLedgers&nbsp;接口的存在主要是为了启用状态转移，和向其它副本询问区块链的状态。和WritableLedger接口一样，这不是给正常的操作使用，而是为追赶，错误恢复等操作而设计的。这个接口中的所有函数调用这都有责任来处理超时。这个接口包含下面这些函数： GetRemoteBlocks(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncBlocks, error) 这个函数尝试从由peerID指定的 peer 中取出由start和finish标识的范围中的*pb.SyncBlocks流。一般情况下，由于区块链必须是从结束到开始这样的顺序来验证的，所以start是比finish更高的块编号。由于慢速的结构，其它请求的返回可能出现在这个通道中，所以调用者必须验证返回的是期望的块。第二次以同样的peerID来调用这个方法会导致第一次的通道关闭。 GetRemoteStateSnapshot(peerID uint64) (&lt;-chan *pb.SyncStateSnapshot, error) 这个函数尝试从由peerID指定的 peer 中取出*pb.SyncStateSnapshot流。为了应用结果，首先需要通过WritableLedger的EmptyState调用来清空存在在状态，然后顺序应用包含在流中的变化量。 GetRemoteStateDeltas(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncStateDeltas, error) 这个函数尝试从由peerID指定的 peer 中取出由start和finish标识的范围中的*pb.SyncStateDeltas流。由于慢速的结构，其它请求的返回可能出现在这个通道中，所以调用者必须验证返回的是期望的块变化量。第二次以同样的peerID来调用这个方法会导致第一次的通道关闭。 3.4.10&nbsp;controller包 3.4.10.1 controller.NewConsenter 签名: func NewConsenter(cpi consensus.CPI) (consenter consensus.Consenter) 这个函数读取为peer过程指定的core.yaml配置文件中的peer.validator.consensus的值。键peer.validator.consensus的有效值指定运行noops还是obcpbft共识。（注意，它最终被改变为noops或custom。在custom情况下，验证 peer 将会运行由consensus/config.yaml中定义的共识插件） 插件的作者需要编辑函数体，来保证路由到它们包中正确的构造函数。例如，对于obcpbft&nbsp;我们指向obcpft.GetPlugin构造器。 这个函数是当设置返回信息处理器的consenter域时，被helper.NewConsensusHandler调用的。输入参数cpi是由helper.NewHelper构造器输出的，并实现了consensus.CPI接口 3.4.11&nbsp;helper包 3.4.11.1 高层次概述 验证 peer 通过helper.NewConsesusHandler函数(一个处理器工厂)，为每个连接的 peer 建立消息处理器(helper.ConsensusHandler)。每个进来的消息都会检查它的类型(helper.HandleMessage)；如果这是为了共识必须到达的消息，它会传递到 peer 的共识对象(consensus.Consenter)。其它的信息会传递到栈中的下一个信息处理器。 3.4.11.2 helper.ConsensusHandler 定义： type ConsensusHandler struct { chatStream peer.ChatStream consenter consensus.Consenter coordinator peer.MessageHandlerCoordinator done chan struct{} peerHandler peer.MessageHandler } 共识中的上下文，我们只关注域coordinator和consenter。coordinator就像名字隐含的那样，它被用来在 peer 的信息处理器之间做协调。例如，当 peer 希望Broadcast时，对象被访问。共识需要到达的共识者会接收到消息并处理它们。 注意，fabric/peer/peer.go定义了peer.MessageHandler&nbsp;(接口)，和peer.MessageHandlerCoordinator（接口）类型。 3.4.11.3 helper.NewConsensusHandler 签名: func NewConsensusHandler(coord peer.MessageHandlerCoordinator, stream peer.ChatStream, initiatedStream bool, next peer.MessageHandler) (peer.MessageHandler, error) 创建一个helper.ConsensusHandler对象。为每个coordinator设置同样的消息处理器。同时把consenter设置为controller.NewConsenter(NewHelper(coord)) 3.4.11.4 helper.Helper 定义: type Helper struct { coordinator peer.MessageHandlerCoordinator } 包含验证peer的coordinator的引用。对象是否为peer实现了consensus.CPI接口。 3.4.11.5 helper.NewHelper 签名: func NewHelper(mhc peer.MessageHandlerCoordinator) consensus.CPI 返回coordinator被设置为输入参数mhc（helper.ConsensusHandler消息处理器的coordinator域）的helper.Helper对象。这个对象实现了consensus.CPI接口，从而允许插件与栈进行交互。 3.4.11.6 helper.HandleMessage 回忆一下，helper.NewConsensusHandler返回的helper.ConsesusHandler对象实现了&nbsp;peer.MessageHandler&nbsp;接口： type MessageHandler interface { RemoteLedger HandleMessage(msg *pb.Message) error SendMessage(msg *pb.Message) error To() (pb.PeerEndpoint, error) Stop() error } 在共识的上下文中，我们只关心HandleMessage方法。签名： func (handler *ConsensusHandler) HandleMessage(msg *pb.Message) error 这个函数检查进来的Message的Type。有四种情况： 等于pb.Message_CONSENSUS：传递给处理器的consenter.RecvMsg函数。 等于pb.Message_CHAIN_TRANSACTION&nbsp;(如：一个外部部署的请求): 一个响应请求首先被发送给用户，然后把消息传递给consenter.RecvMsg函数 等于pb.Message_CHAIN_QUERY&nbsp;(如：查询): 传递给helper.doChainQuery方法来在本地执行 其它: 传递给栈中下一个处理器的HandleMessage方法 3.5 事件 事件框架提供了生产和消费预定义或自定义的事件的能力。它有3个基础组件： 事件流 事件适配器 事件结构 3.5.1 事件流 事件流是用来发送和接收事件的gRPC通道。每个消费者会与事件框架建立事件流，并快速传递它感兴趣的事件。事件生成者通过事件流只发送合适的事件给连接到生产者的消费者。 事件流初始化缓冲和超时参数。缓冲保存着几个等待投递的事件，超时参数在缓冲满时有三个选项： 如果超时小于0，丢弃新到来的事件 如果超时等于0，阻塞事件知道缓冲再次可用 如果超时大于0，等待指定的超时时间，如果缓冲还是满的话就丢弃事件 3.5.1.1 事件生产者 事件生产者暴露函数Send(e *pb.Event)来发送事件，其中Event可以是预定义的Block或Generic事件。将来会定义更多的事件来包括其它的fabric元素。 message Generic { string eventType = 1; bytes payload = 2; } eventType和payload是由事件生产者任意定义的。例如，JSON数据可能被用在payload中。链码或插件发出Generic事件来与消费者通讯。 3.5.1.2 事件消费者 事件消费者允许外部应用监听事件。每个事件消费者通过时间流注册事件适配器。消费者框架可以看成是事件流与适配器之间的桥梁。一种典型的事件消费者使用方式： adapter = &lt;adapter supplied by the client application to register and receive events&gt; consumerClient = NewEventsClient(&lt;event consumer address&gt;, adapter) consumerClient.Start() ... ... consumerClient.Stop() 3.5.2 事件适配器 事件适配器封装了三种流交互的切面： 返回所有感兴趣的事件列表的接口 当事件消费者框架接受到事件后调用的接口 当事件总线终止时，事件消费者框架会调用的接口 引用的实现提供了Golang指定语言绑定 EventAdapter interface { GetInterestedEvents() ([]*ehpb.Interest, error) Recv(msg *ehpb.Event) (bool,error) Disconnected(err error) } 把gRPC当成事件总线协议来使用，允许事件消费者框架对于不同的语言的绑定可移植而不影响事件生成者框架。 3.5.3 事件框架 这节详细描述了事件系统的消息结构。为了简单起见，消息直接使用Golang描述。 事件消费者和生产者之间通信的核心消息是事件。 message Event { oneof Event { //consumer events Register register = 1; //producer events Block block = 2; Generic generic = 3; } } 每一个上面的定义必须是Register,&nbsp;Block或Generic中的一种。 就像之前提到过的一样，消费者通过与生产者建立连接来创建事件总线，并发送Register事件。Register事件实质上是一组声明消费者感兴趣的事件的Interest消息。 message Interest { enum ResponseType { //don&#39;t send events (used to cancel interest) DONTSEND = 0; //send protobuf objects PROTOBUF = 1; //marshall into JSON structure JSON = 2; } string eventType = 1; ResponseType responseType = 2; } 事件可以通过protobuf结构直接发送，也可以通过指定适当的responseType来发送JSON结构。 当前，生产者框架可以生成Block和Generic事件。Block是用来封装区块链中区块属性的消息。 阅读更多" />
<meta property="og:description" content="fabric的点对点（peer-to-peer）通信是建立在允许双向的基于流的消息gRPC上的。它使用Protocol Buffers来序列化peer之间传输的数据结构。Protocol buffers 是语言无关，平台无关并具有可扩展机制来序列化结构化的数据的技术。数据结构，消息和服务是使用&nbsp;proto3 language注释来描述的。 3.1 消息 消息在节点之间通过Messageproto 结构封装来传递的，可以分为 4 种类型：发现（Discovery）, 交易（Transaction）, 同步(Synchronization)和共识(Consensus)。每种类型在payload中定义了多种子类型。 message Message { enum Type { UNDEFINED = 0; DISC_HELLO = 1; DISC_DISCONNECT = 2; DISC_GET_PEERS = 3; DISC_PEERS = 4; DISC_NEWMSG = 5; CHAIN_STATUS = 6; CHAIN_TRANSACTION = 7; CHAIN_GET_TRANSACTIONS = 8; CHAIN_QUERY = 9; SYNC_GET_BLOCKS = 11; SYNC_BLOCKS = 12; SYNC_BLOCK_ADDED = 13; SYNC_STATE_GET_SNAPSHOT = 14; SYNC_STATE_SNAPSHOT = 15; SYNC_STATE_GET_DELTAS = 16; SYNC_STATE_DELTAS = 17; RESPONSE = 20; CONSENSUS = 21; } Type type = 1; bytes payload = 2; google.protobuf.Timestamp timestamp = 3; } payload是由不同的消息类型所包含的不同的像Transaction或Response这样的对象的不透明的字节数组。例如：type为CHAIN_TRANSACTION那么payload就是一个Transaction对象。 3.1.1 发现消息 在启动时，如果CORE_PEER_DISCOVERY_ROOTNODE被指定，那么 peer 就会运行发现协议。CORE_PEER_DISCOVERY_ROOTNODE是网络（任意peer）中扮演用来发现所有 peer 的起点角色的另一个 peer 的 IP 地址。协议序列以payload是一个包含： message HelloMessage { PeerEndpoint peerEndpoint = 1; uint64 blockNumber = 2; } message PeerEndpoint { PeerID ID = 1; string address = 2; enum Type { UNDEFINED = 0; VALIDATOR = 1; NON_VALIDATOR = 2; } Type type = 3; bytes pkiID = 4; } message PeerID { string name = 1; } 这样的端点的HelloMessage对象的DISC_HELLO消息开始的。 域的定义: PeerID&nbsp;是在启动时或配置文件中定义的 peer 的任意名字 PeerEndpoint&nbsp;描述了端点和它是验证还是非验证 peer pkiID&nbsp;是 peer 的加密ID address&nbsp;以ip:port这样的格式表示的 peer 的主机名或IP和端口 blockNumber&nbsp;是 peer 的区块链的当前的高度 如果收到的DISC_HELLO&nbsp;消息的块的高度比当前 peer 的块的高度高，那么它马上初始化同步协议来追上当前的网络。 DISC_HELLO之后，peer 会周期性的发送DISC_GET_PEERS来发现任意想要加入网络的 peer。收到DISC_GET_PEERS后，peer 会发送payload&nbsp;包含PeerEndpoint的数组的DISC_PEERS作为响应。这是不会使用其它的发现消息类型。 3.1.2 交易消息 有三种不同的交易类型：部署（Deploy），调用（Invoke）和查询（Query）。部署交易向链上安装指定的链码，调用和查询交易会调用部署号的链码。另一种需要考虑的类型是创建（Create）交易，其中部署好的链码是可以在链上实例化并寻址的。这种类型在写这份文档时还没有被实现。 3.1.2.1 交易的数据结构 CHAIN_TRANSACTION和CHAIN_QUERY类型的消息会在payload带有Transaction对象： message Transaction { enum Type { UNDEFINED = 0; CHAINCODE_DEPLOY = 1; CHAINCODE_INVOKE = 2; CHAINCODE_QUERY = 3; CHAINCODE_TERMINATE = 4; } Type type = 1; string uuid = 5; bytes chaincodeID = 2; bytes payloadHash = 3; ConfidentialityLevel confidentialityLevel = 7; bytes nonce = 8; bytes cert = 9; bytes signature = 10; bytes metadata = 4; google.protobuf.Timestamp timestamp = 6; } message TransactionPayload { bytes payload = 1; } enum ConfidentialityLevel { PUBLIC = 0; CONFIDENTIAL = 1; } 域的定义: type&nbsp;- 交易的类型, 为1时表示: UNDEFINED&nbsp;- 为未来的使用所保留. CHAINCODE_DEPLOY&nbsp;- 代表部署新的链码. CHAINCODE_INVOKE&nbsp;- 代表一个链码函数被执行并修改了世界状态 CHAINCODE_QUERY&nbsp;- 代表一个链码函数被执行并可能只读取了世界状态 CHAINCODE_TERMINATE&nbsp;- 标记的链码不可用，所以链码中的函数将不能被调用 chaincodeID&nbsp;- 链码源码，路径，构造函数和参数哈希所得到的ID payloadHash&nbsp;-&nbsp;TransactionPayload.payload所定义的哈希字节. metadata&nbsp;- 应用可能使用的，由自己定义的任意交易相关的元数据 uuid&nbsp;- 交易的唯一ID timestamp&nbsp;- peer 收到交易时的时间戳 confidentialityLevel&nbsp;- 数据保密的级别。当前有两个级别。未来可能会有多个级别。 nonce&nbsp;- 为安全而使用 cert&nbsp;- 交易者的证书 signature&nbsp;- 交易者的签名 TransactionPayload.payload&nbsp;- 交易的payload所定义的字节。由于payload可以很大，所以交易消息只包含payload的哈希 交易安全的详细信息可以在第四节找到 3.1.2.2 交易规范 一个交易通常会关联链码定义及其执行环境（像语言和安全上下文）的链码规范。现在，有一个使用Go语言来编写链码的实现。将来可能会添加新的语言。 message ChaincodeSpec { enum Type { UNDEFINED = 0; GOLANG = 1; NODE = 2; } Type type = 1; ChaincodeID chaincodeID = 2; ChaincodeInput ctorMsg = 3; int32 timeout = 4; string secureContext = 5; ConfidentialityLevel confidentialityLevel = 6; bytes metadata = 7; } message ChaincodeID { string path = 1; string name = 2; } message ChaincodeInput { string function = 1; repeated string args = 2; } 域的定义: chaincodeID&nbsp;- 链码源码的路径和名字 ctorMsg&nbsp;- 调用的函数名及参数 timeout&nbsp;- 执行交易所需的时间（以毫秒表示） confidentialityLevel&nbsp;- 这个交易的保密级别 secureContext&nbsp;- 交易者的安全上下文 metadata&nbsp;- 应用想要传递下去的任何数据 当 peer 收到chaincodeSpec后以合适的交易消息包装它并广播到网络 3.1.2.3 部署交易 部署交易的类型是CHAINCODE_DEPLOY，且它的payload包含ChaincodeDeploymentSpec对象。 message ChaincodeDeploymentSpec { ChaincodeSpec chaincodeSpec = 1; google.protobuf.Timestamp effectiveDate = 2; bytes codePackage = 3; } 域的定义: chaincodeSpec&nbsp;- 参看上面的3.1.2.2节. effectiveDate&nbsp;- 链码准备好可被调用的时间 codePackage&nbsp;- 链码源码的gzip 当验证 peer 部署链码时，它通常会校验codePackage的哈希来保证交易被部署到网络后没有被篡改。 3.1.2.4 调用交易 调用交易的类型是CHAINCODE_DEPLOY，且它的payload包含ChaincodeInvocationSpec对象。 message ChaincodeInvocationSpec { ChaincodeSpec chaincodeSpec = 1; } 3.1.2.5 查询交易 查询交易除了消息类型是CHAINCODE_QUERY其它和调用交易一样 3.1.3 同步消息 同步协议以3.1.1节描述的，当 peer 知道它自己的区块落后于其它 peer 或和它们不一样后所发起的。peer 广播SYNC_GET_BLOCKS，SYNC_STATE_GET_SNAPSHOT或SYNC_STATE_GET_DELTAS并分别接收SYNC_BLOCKS,&nbsp;SYNC_STATE_SNAPSHOT或SYNC_STATE_DELTAS。 安装的共识插件（如：pbft）决定同步协议是如何被应用的。每个小时是针对具体的状态来设计的： SYNC_GET_BLOCKS&nbsp;是一个SyncBlockRange对象，包含一个连续区块的范围的payload的请求。 message SyncBlockRange { uint64 start = 1; uint64 end = 2; uint64 end = 3; } 接收peer使用包含&nbsp;SyncBlocks对象的payload的SYNC_BLOCKS信息来响应 message SyncBlocks { SyncBlockRange range = 1; repeated Block blocks = 2; } start和end标识包含的区块的开始和结束，返回区块的顺序由start和end的值定义。如：当start=3，end=5时区块的顺序将会是3，4，5。当start=5，end=3时区块的顺序将会是5，4，3。 SYNC_STATE_GET_SNAPSHOT&nbsp;请求当前世界状态的快照。&nbsp;payload是一个SyncStateSnapshotRequest对象 message SyncStateSnapshotRequest { uint64 correlationId = 1; } correlationId是请求 peer 用来追踪响应消息的。接受 peer 回复payload为SyncStateSnapshot实例的SYNC_STATE_SNAPSHOT信息 message SyncStateSnapshot { bytes delta = 1; uint64 sequence = 2; uint64 blockNumber = 3; SyncStateSnapshotRequest request = 4; } 这条消息包含快照或以0开始的快照流序列中的一块。终止消息是len(delta) == 0的块 SYNC_STATE_GET_DELTAS&nbsp;请求连续区块的状态变化。默认情况下总账维护500笔交易变化。 delta(j)是block(i)和block(j)之间的状态转变，其中i=j-1。&nbsp;payload包含SyncStateDeltasRequest实例 message SyncStateDeltasRequest { SyncBlockRange range = 1; } 接收 peer 使用包含&nbsp;SyncStateDeltas实例的payload的SYNC_STATE_DELTAS信息来响应 message SyncStateDeltas { SyncBlockRange range = 1; repeated bytes deltas = 2; } delta可能以顺序（从i到j）或倒序（从j到i）来表示状态转变 3.1.4 共识消息 共识处理交易，一个CONSENSUS消息是由共识框架接收到CHAIN_TRANSACTION消息时在内部初始化的。框架把CHAIN_TRANSACTION转换为&nbsp;CONSENSUS然后以相同的payload广播到验证 peer。共识插件接收这条消息并根据内部算法来处理。插件可能创建自定义的子类型来管理共识有穷状态机。3.4节会介绍详细信息。 3.2 总账 总账由两个主要的部分组成，一个是区块链，一个是世界状态。区块链是在总账中的一系列连接好的用来记录交易的区块。世界状态是一个用来存储交易执行状态的键-值(key-value)数据库 3.2.1 区块链 3.2.1.1 区块 区块链是由一个区块链表定义的，每个区块包含它在链中前一个区块的哈希。区块包含的另外两个重要信息是它包含区块执行所有交易后的交易列表和世界状态的哈希 message Block { version = 1; google.protobuf.Timestamp timestamp = 2; bytes transactionsHash = 3; bytes stateHash = 4; bytes previousBlockHash = 5; bytes consensusMetadata = 6; NonHashData nonHashData = 7; } message BlockTransactions { repeated Transaction transactions = 1; } 域的定义: version&nbsp;- 用来追踪协议变化的版本号 timestamp&nbsp;- 由区块提议者填充的时间戳 transactionsHash&nbsp;- 区块中交易的merkle root hash stateHash&nbsp;- 世界状态的merkle root hash previousBlockHash&nbsp;- 前一个区块的hash consensusMetadata&nbsp;- 共识可能会引入的一些可选的元数据 nonHashData&nbsp;-&nbsp;NonHashData消息会在计算区块的哈希前设置为nil，但是在数据库中存储为区块的一部分 BlockTransactions.transactions&nbsp;- 交易消息的数组，由于交易的大小，它们不会被直接包含在区块中 3.2.1.2 区块哈希 previousBlockHash哈希是通过下面算法计算的 使用protocol buffer库把区块消息序列化为字节码 使用FIPS 202描述的SHA3 SHAKE256算法来对序列化后的区块消息计算大小为512位的哈希值 transactionHash是交易merkle树的根。定义merkle tree实现是一个代办 stateHash在3.2.2.1节中定义. 3.2.1.3 非散列数据(NonHashData) NonHashData消息是用来存储不需要所有 peer 都具有相同值的块元数据。他们是建议值。 message NonHashData { google.protobuf.Timestamp localLedgerCommitTimestamp = 1; repeated TransactionResult transactionResults = 2; } message TransactionResult { string uuid = 1; bytes result = 2; uint32 errorCode = 3; string error = 4; } localLedgerCommitTimestamp&nbsp;- 标识区块提交到本地总账的时间戳 TransactionResult&nbsp;- 交易结果的数组 TransactionResult.uuid&nbsp;- 交易的ID TransactionResult.result&nbsp;- 交易的返回值 TransactionResult.errorCode&nbsp;- 可以用来记录关联交易的错误信息的代码 TransactionResult.error&nbsp;- 用来记录关联交易的错误信息的字符串 3.2.1.4 交易执行 一个交易定义了它们部署或执行的链码。区块中的所有交易都可以在记录到总账中的区块之前运行。当链码执行时，他们可能会改变世界状态。之后世界状态的哈希会被记录在区块中。 3.2.2 世界状态 peer 的世界状态涉及到所有被部署的链码的状态集合。进一步说，链码的状态由键值对集合来表示。所以，逻辑上说，peer 的世界状态也是键值对的集合，其中键有元组{chaincodeID, ckey}组成。这里我们使用术语key来标识世界状态的键，如：元组{chaincodeID, ckey}&nbsp;，而且我们使用cKey来标识链码中的唯一键。 为了下面描述的目的，假定chaincodeID是有效的utf8字符串，且ckey和value是一个或多个任意的字节的序列 3.2.2.1 世界状态的哈希 当网络活动时，很多像交易提交和同步 peer 这样的场合可能需要计算 peer 观察到的世界状态的加密-哈希。例如，共识协议可能需要保证网络中最小数量的 peer 观察到同样的世界状态。 应为计算世界状态的加密-哈希是一个非常昂贵的操作，组织世界状态来使得当它改变时能高效效的计算加密-哈希是非常可取的。将来，可以根据不同的负载条件来设计不同的组织形式。 由于fabric是被期望在不同的负载条件下都能正常工作，所以需要一个可拔插的机制来支持世界状态的组织。 3.2.2.1.1 Bucket-tree Bucket-tree&nbsp;是世界状态的组织方式的实现。为了下面描述的目的，世界状态的键被表示成两个组件(chaincodeID&nbsp;and&nbsp;ckey) 的通过nil字节的级联，如：key&nbsp;=&nbsp;chaincodeID+nil+cKey。 这个方法的模型是一个merkle-tree在hash table桶的顶部来计算世界状态的加密-哈希 这个方法的核心是世界状态的key-values被假定存储在由预先决定的桶的数量(numBuckets)所组成的哈希表中。一个哈希函数(hashFunction) 被用来确定包含给定键的桶数量。注意hashFunction不代表SHA3这样的加密-哈希方法，而是决定给定的键的桶的数量的正规的编程语言散列函数。 为了对 merkle-tree建模，有序桶扮演了树上的叶子节点-编号最低的桶是树中的最左边的叶子节点。为了构造树的最后第二层，叶子节点的预定义数量 (maxGroupingAtEachLevel)，从左边开始把每个这样的分组组合在一起，一个节点被当作组中所有叶子节点的共同父节点来插入到最后第二层中。注意最后的父节点的数量可能会少于maxGroupingAtEachLevel这个构造方式继续使用在更高的层级上直到树的根节点被构造。 下面这个表展示的在{numBuckets=10009 and maxGroupingAtEachLevel=10}的配置下会得到的树在不同层级上的节点数。 Level Number of nodes 0 1 1 2 2 11 3 101 4 1001 5 10009 为了计算世界状态的加密-哈希，需要计算每个桶的加密-哈希，并假设它们是merkle-tree的叶子节点的加密-哈希。为了计算桶的加密-哈希，存储在桶中的键值对首先被序列化为字节码并在其上应用加密-哈希函数。为了序列化桶的键值对，所有具有公共chaincodeID前缀的键值对分别序列化并以chaincodeID的升序的方式追加在一起。为了序列化一个chaincodeID的键值对，会涉及到下面的信息： chaincodeID的长度(chaincodeID的字节数) chaincodeID的utf8字节码 chaincodeID的键值对数量 对于每个键值对(以ckey排序) ckey的长度 ckey的字节码 值的长度 值的字节码 对于上面列表的所有数值类型项（如：chaincodeID的长度），使用protobuf的变体编码方式。上面这种编码方式的目的是为了桶中的键值对的字节表示方式不会被任意其他键值对的组合所产生，并减少了序列化字节码的总体大小。 例如：考虑具有chaincodeID1_key1:value1, chaincodeID1_key2:value2, 和 chaincodeID2_key1:value1这样名字的键值对的桶。序列化后的桶看上去会像：12 + chaincodeID1 + 2 + 4 + key1 + 6 + value1 + 4 + key2 + 6 + value2 + 12 + chaincodeID2 + 1 + 4 + key1 + 6 + value1 如果桶中没有键值对，那么加密-哈希为nil。 中间节点和根节点的加密-哈希与标准merkle-tree的计算方法一样，即：应用加密-哈希函数到所有子节点的加密-哈希从左到右级联后得到的字节码。进一步说，如果一个子节点的加密-哈希为nil，那么这个子节点的加密-哈希在级联子节点的加密-哈希是就被省略。如果它只有一个子节点，那么它的加密-哈希就是子节点的加密-哈希。最后，根节点的加密-哈希就是世界状态的加密-哈希。 上面这种方法在状态中少数键值对改变时计算加密-哈希是有性能优势的。主要的优势包括： 那些没有变化的桶的计算会被跳过 merkle-tree的宽度和深度可以通过配置numBuckets和maxGroupingAtEachLevel参数来控制。树的不同深度和宽度对性能和不同的资源都会产生不同的影响。 在一个具体的部署中，所有的 peer 都期望使用相同的numBuckets, maxGroupingAtEachLevel, 和 hashFunction的配置。进一步说，如果任何一个配置在之后的阶段被改变，那么这些改变需要应用到所有的 peer 中，来保证 peer 节点之间的加密-哈希的比较是有意义的。即使，这可能会导致基于实现的已有数据的迁移。例如：一种实现希望存储树中所有节点最后计算的加密-哈希，那么它就需要被重新计算。 3.3 链码（Chaincode） 链码是在交易（参看3.1.2节）被部署是分发到网络上，并被所有验证 peer 通过隔离的沙箱来管理的应用级代码。尽管任意的虚拟技术都可以支持沙箱，现在是通过Docker容器来运行链码的。这节中描述的协议可以启用不同虚拟实现的插入与运行。 3.3.1 虚拟机实例化 一个实现VM接口的虚拟机 type VM interface { build(ctxt context.Context, id string, args []string, env []string, attachstdin bool, attachstdout bool, reader io.Reader) error start(ctxt context.Context, id string, args []string, env []string, attachstdin bool, attachstdout bool) error stop(ctxt context.Context, id string, timeout uint, dontkill bool, dontremove bool) error } fabric在处理链码上的部署交易或其他交易时，如果这个链码的VM未启动（崩溃或之前的不活动导致的关闭）时实例化VM。每个链码镜像通过build函数构建，通过start函数启动，并使用stop函数停止。 一旦链码容器被启动，它使用gRPC来连接到启动这个链码的验证 peer，并为链码上的调用和查询交易建立通道。 3.3.2 链码协议 验证 peer 和它的链码之间是通过gRPC流来通信的。链码容器上有shim层来处理链码与验证 peer 之间的protobuf消息协议。 message ChaincodeMessage { enum Type { UNDEFINED = 0; REGISTER = 1; REGISTERED = 2; INIT = 3; READY = 4; TRANSACTION = 5; COMPLETED = 6; ERROR = 7; GET_STATE = 8; PUT_STATE = 9; DEL_STATE = 10; INVOKE_CHAINCODE = 11; INVOKE_QUERY = 12; RESPONSE = 13; QUERY = 14; QUERY_COMPLETED = 15; QUERY_ERROR = 16; RANGE_QUERY_STATE = 17; } Type type = 1; google.protobuf.Timestamp timestamp = 2; bytes payload = 3; string uuid = 4; } 域的定义: Type&nbsp;是消息的类型 payload&nbsp;是消息的payload. 每个payload取决于Type. uuid&nbsp;消息唯一的ID 消息的类型在下面的小节中描述 链码实现被验证 peer 在处理部署，调用或查询交易时调用的Chaincode接口 type Chaincode interface { Invoke(stub *ChaincodeStub, function string, args []string) (error) Query(stub *ChaincodeStub, function string, args []string) ([]byte, error) } Init,&nbsp;Invoke&nbsp;和&nbsp;Query函数使用function&nbsp;and&nbsp;args参数来支持多种交易。Init是构造函数，它只在部署交易是被执行。Query函数是不允许修改链码的状态的；它只能读取和计算并以byte数组的形式返回。 3.3.2.1 链码部署 当部署时（链码容器已经启动），shim层发送一次性的具有包含ChaincodeID的payload的REGISTER消息给验证 peer。然后 peer 以REGISTERED或ERROR来响应成功或失败。当收到ERROR后shim关闭连接并退出。 注册之后，验证 peer 发送具有包含ChaincodeInput对象的INIT消息。shim使用从ChaincodeInput获得的参数来调用Init函数，通过像设置持久化状态这样操作来初始化链码。 shim根据Init函数的返回值，响应RESPONSE或ERROR消息。如果没有错误，那么链码初始化完成，并准备好接收调用和查询交易。 3.3.2.2 链码调用 当处理调用交易时，验证 peer 发送TRANSACTION消息给链码容器的shim，由它来调用链码的Invoke函数，并传递从ChaincodeInput得到的参数。shim响应RESPONSE或ERROR消息来表示函数完成。如果接收到ERROR函数，payload包含链码所产生的错误信息。 3.3.2.3 来代码查询 与调用交易一样，验证 peer 发送QUERY消息给链码容器的shim，由它来调用链码的Query函数，并传递从ChaincodeInput得到的参数。Query函数可能会返回状态值或错误，它会把它通过RESPONSE或ERROR消息来传递给验证 peer。 3.3.2.4 链码状态 每个链码可能都定义了它自己的持久化状态变量。例如，一个链码可能创建电视，汽车或股票这样的资产来保存资产属性。当Invoke函数处理时，链码可能会更新状态变量，例如改变资产所有者。链码会根据下面这些消息类型类操作状态变量： PUT_STATE 链码发送一个payload包含PutStateInfo对象的PU_STATE消息来保存键值对。 message PutStateInfo { string key = 1; bytes value = 2; } GET_STATE 链码发送一个由payload指定要获取值的键的GET_STATE消息。 DEL_STATE 链码发送一个由payload指定要删除值的键的DEL_STATE消息。 RANGE_QUERY_STATE 链码发送一个payload包含RANGE_QUERY_STATE对象的RANGE_QUERY_STATE来获取一个范围内的值。 message RangeQueryState { string startKey = 1; string endKey = 2; } startKey和endKey假设是通过字典排序的. 验证 peer 响应一个payload是RangeQueryStateResponse对象的RESPONSE消息 message RangeQueryStateResponse { repeated RangeQueryStateKeyValue keysAndValues = 1; bool hasMore = 2; string ID = 3; } message RangeQueryStateKeyValue { string key = 1; bytes value = 2; } 如果相应中hasMore=true，这表示有在请求的返回中还有另外的键。链码可以通过发送包含与响应中ID相同的ID的RangeQueryStateNext消息来获取下一集合。 message RangeQueryStateNext { string ID = 1; } 当链码结束读取范围，它会发送带有ID的RangeQueryStateClose消息来期望它关闭。 message RangeQueryStateClose { string ID = 1; } INVOKE_CHAINCODE 链码可以通过发送payload包含&nbsp;ChaincodeSpec对象的INVOKE_CHAINCODE消息给验证 peer 来在相同的交易上下文中调用另一个链码 QUERY_CHAINCODE 链码可以通过发送payload包含&nbsp;ChaincodeSpec对象的QUERY_CHAINCODE消息给验证 peer 来在相同的交易上下文中查询另一个链码 3.4 插拔式共识框架 共识框架定义了每个共识插件都需要实现的接口： consensus.Consenter: 允许共识插件从网络上接收消息的接口 consensus.CPI: 共识编程接口Consensus Programming Interface&nbsp;(CPI) 是共识插件用来与栈交互的，这个接口可以分为两部分： consensus.Communicator: 用来发送（广播或单播）消息到其他的验证 peer consensus.LedgerStack: 这个接口使得执行框架像总账一样方便 就像下面描述的细节一样，consensus.LedgerStack封装了其他接口，consensus.Executor接口是共识框架的核心部分。换句话说，consensus.Executor接口允许一个（批量）交易启动，执行，根据需要回滚，预览和提交。每一个共识插件都需要满足以所有验证 peer 上全序的方式把批量（块）交易（通过consensus.Executor.CommitTxBatch）被提交到总账中（参看下面的consensus.Executor接口获得详细细节）。 当前，共识框架由consensus,&nbsp;controller和helper这三个包组成。使用controller和helper包的主要原因是防止Go语言的“循环引入”和当插件更新时的最小化代码变化。 controller&nbsp;包规范了验证 peer 所使用的共识插件 helper&nbsp;是围绕公式插件的垫片，它是用来与剩下的栈交互的，如为其他 peer 维护消息。 这里有2个共识插件提供：pbft和noops： obcpbft包包含实现&nbsp;PBFT&nbsp;[1] 和&nbsp;Sieve&nbsp;共识协议的共识插件。参看第5节的详细介绍 noops&nbsp;是一个为开发和测试提供的&#39;&#39;假的&#39;&#39;共识插件. 它处理所有共识消息但不提供共识功能，它也是一个好的学习如何开发一个共识插件的简单例子。 3.4.1&nbsp;Consenter&nbsp;接口 定义: type Consenter interface { RecvMsg(msg *pb.Message) error } Consenter接口是插件对（外部的）客户端请求的入口，当处理共识时，共识消息在内部（如从共识模块）产生。NewConsenter创建Consenter插件。RecvMsg`以到达共识的顺序来处理进来的交易。 阅读下面的helper.HandleMessage来理解 peer 是如何和这个接口来交互的。 3.4.2&nbsp;CPI接口 定义: type CPI interface { Inquirer Communicator SecurityUtils LedgerStack } CPI&nbsp;允许插件和栈交互。它是由helper.Helper对象实现的。回想一下这个对象是： 在helper.NewConsensusHandler被调用时初始化的 当它们的插件构造了consensus.Consenter对象，那么它对插件的作者是可访问的 3.4.3&nbsp;Inquirer接口 定义: type Inquirer interface { GetNetworkInfo() (self *pb.PeerEndpoint, network []*pb.PeerEndpoint, err error) GetNetworkHandles() (self *pb.PeerID, network []*pb.PeerID, err error) } 这个接口是consensus.CPI接口的一部分。它是用来获取网络中验证 peer 的（GetNetworkHandles）处理，以及那些验证 peer 的明细(GetNetworkInfo)： 注意pees由pb.PeerID对象确定。这是一个protobuf消息，当前定义为（注意这个定义很可能会被修改）： message PeerID { string name = 1; } 3.4.4&nbsp;Communicator接口 定义: type Communicator interface { Broadcast(msg *pb.Message) error Unicast(msg *pb.Message, receiverHandle *pb.PeerID) error } 这个接口是consensus.CPI接口的一部分。它是用来与网络上其它 peer 通信的（helper.Broadcast,&nbsp;helper.Unicast）： 3.4.5&nbsp;SecurityUtils接口 定义: type SecurityUtils interface { Sign(msg []byte) ([]byte, error) Verify(peerID *pb.PeerID, signature []byte, message []byte) error } 这个接口是consensus.CPI接口的一部分。它用来处理消息签名(Sign)的加密操作和验证签名(Verify) 3.4.6&nbsp;LedgerStack&nbsp;接口 定义: type LedgerStack interface { Executor Ledger RemoteLedgers } CPI接口的主要成员，LedgerStack&nbsp;组与fabric的其它部分与共识相互作用，如执行交易，查询和更新总账。这个接口支持对本地区块链和状体的查询，更新本地区块链和状态，查询共识网络上其它节点的区块链和状态。它是有Executor,Ledger和RemoteLedgers这三个接口组成的。下面会描述它们。 3.4.7&nbsp;Executor&nbsp;接口 定义: type Executor interface { BeginTxBatch(id interface{}) error ExecTXs(id interface{}, txs []*pb.Transaction) ([]byte, []error) CommitTxBatch(id interface{}, transactions []*pb.Transaction, transactionsResults []*pb.TransactionResult, metadata []byte) error RollbackTxBatch(id interface{}) error PreviewCommitTxBatchBlock(id interface{}, transactions []*pb.Transaction, metadata []byte) (*pb.Block, error) } executor接口是LedgerStack接口最常使用的部分，且是共识网络工作的必要部分。接口允许交易启动，执行，根据需要回滚，预览和提交。这个接口由下面这些方法组成。 3.4.7.1 开始批量交易 BeginTxBatch(id interface{}) error 这个调用接受任意的，故意含糊的id，来使得共识插件可以保证与这个具体的批量相关的交易才会被执行。例如：在pbft实现中，这个id是被执行交易的编码过的哈希。 3.4.7.2 执行交易 ExecTXs(id interface{}, txs []*pb.Transaction) ([]byte, []error) 这个调用根据总账当前的状态接受一组交易，并返回带有对应着交易组的错误信息组的当前状态的哈希。注意一个交易所产生的错误不影响批量交易的安全提交。当遇到失败所采用的策略取决与共识插件的实现。这个接口调用多次是安全的。 3.4.7.3 提交与回滚交易 RollbackTxBatch(id interface{}) error 这个调用忽略了批量执行。这会废弃掉对当前状态的操作，并把总账状态回归到之前的状态。批量是从BeginBatchTx开始的，如果需要开始一个新的就需要在执行任意交易之前重新创建一个。 PreviewCommitTxBatchBlock(id interface{}, transactions []*pb.Transaction, metadata []byte) (*pb.Block, error) 这个调用是共识插件对非确定性交易执行的测试时最有用的方法。区块返回的哈希表部分会保证，当CommitTxBatch被立即调用时的区块是同一个。这个保证会被任意新的交易的执行所打破。 CommitTxBatch(id interface{}, transactions []*pb.Transaction, transactionsResults []*pb.TransactionResult, metadata []byte) error 这个调用提交区块到区块链中。区块必须以全序提交到区块链中，CommitTxBatch结束批量交易，在执行或提交任意的交易之前必须先调用BeginTxBatch。 3.4.8&nbsp;Ledger&nbsp;接口 定义： type Ledger interface { ReadOnlyLedger UtilLedger WritableLedger } Ledger&nbsp;接口是为了允许共识插件询问或可能改变区块链当前状态。它是由下面描述的三个接口组成的 3.4.8.1&nbsp;ReadOnlyLedger&nbsp;接口 定义： type ReadOnlyLedger interface { GetBlock(id uint64) (block *pb.Block, err error) GetCurrentStateHash() (stateHash []byte, err error) GetBlockchainSize() (uint64, error) } ReadOnlyLedger&nbsp;接口是为了查询总账的本地备份，而不会修改它。它是由下面这些函数组成的。 GetBlockchainSize() (uint64, error) 这个函数返回区块链总账的长度。一般来说，这个函数永远不会失败，在这种不太可能发生情况下，错误被传递给调用者，由它确定是否需要恢复。具有最大区块值的区块的值为GetBlockchainSize()-1 注意在区块链总账的本地副本是腐坏或不完整的情况下，这个调用会返回链中最大的区块值+1。这允许节点在旧的块是腐坏或丢失的情况下能继续操作当前状态/块。 GetBlock(id uint64) (block *pb.Block, err error) 这个调用返回区块链中块的数值id。一般来说这个调用是不会失败的，除非请求的区块超出当前区块链的长度，或者底层的区块链被腐坏了。GetBlock的失败可能可以通过状态转换机制来取回它。 GetCurrentStateHash() (stateHash []byte, err error) 这个盗用返回总账的当前状态的哈希。一般来说，这个函数永远不会失败，在这种不太可能发生情况下，错误被传递给调用者，由它确定是否需要恢复。 3.4.8.2&nbsp;UtilLedger&nbsp;接口 定义： type UtilLedger interface { HashBlock(block *pb.Block) ([]byte, error) VerifyBlockchain(start, finish uint64) (uint64, error) } UtilLedger&nbsp;接口定义了一些由本地总账提供的有用的功能。使用mock接口来重载这些功能在测试时非常有用。这个接口由两个函数构成。 会会 HashBlock(block *pb.Block) ([]byte, error) 尽管*pb.Block定义了GetHash方法，为了mock测试，重载这个方法会非常有用。因此，建议GetHash方法不直接调用，而是通过UtilLedger.HashBlock接口来调用这个方法。一般来说，这个函数永远不会失败，但是错误还是会传递给调用者，让它决定是否使用适当的恢复。 VerifyBlockchain(start, finish uint64) (uint64, error) 这个方法是用来校验区块链中的大的区域。它会从高的块start到低的块finish，返回第一个块的PreviousBlockHash与块的前一个块的哈希不相符的块编号以及错误信息。注意，它一般会标识最后一个好的块的编号，而不是第一个坏的块的编号。 3.4.8.3&nbsp;WritableLedger&nbsp;接口 定义： type WritableLedger interface { PutBlock(blockNumber uint64, block *pb.Block) error ApplyStateDelta(id interface{}, delta *statemgmt.StateDelta) error CommitStateDelta(id interface{}) error RollbackStateDelta(id interface{}) error EmptyState() error } WritableLedger&nbsp;接口允许调用者更新区块链。注意这NOT&nbsp;不是共识插件的通常用法。当前的状态需要通过Executor接口执行交易来修改，新的区块在交易提交时生成。相反的，这个接口主要是用来状态改变和腐化恢复。特别的，这个接口下的函数永远不能直接暴露给共识消息，这样会导致打破区块链所承诺的不可修改这一概念。这个结构包含下面这些函数。 -&nbsp;&nbsp;PutBlock(blockNumber uint64, block *pb.Block) error&nbsp;&nbsp;这个函数根据给定的区块编号把底层区块插入到区块链中。注意这是一个不安全的接口，所以它不会有错误返回或返回。插入一个比当前区块高度更高的区块是被允许的，通用，重写一个已经提交的区块也是被允许的。记住，由于哈希技术使得创建一个链上的更早的块是不可行的，所以这并不影响链的可审计性和不可变性。任何尝试重写区块链的历史的操作都能很容易的被侦测到。这个函数一般只用于状态转移API。 -&nbsp;&nbsp;ApplyStateDelta(id interface{}, delta *statemgmt.StateDelta) error&nbsp; 这个函数接收状态变化，并把它应用到当前的状态。变化量的应用会使得状态向前或向后转变，这取决于状态变化量的构造，与`Executor`方法一样，`ApplyStateDelta`接受一个同样会被传递给`CommitStateDelta` or `RollbackStateDelta`不透明的接口`id` -&nbsp;&nbsp;CommitStateDelta(id interface{}) error&nbsp; 这个方法提交在`ApplyStateDelta`中应用的状态变化。这通常是在调用者调用`ApplyStateDelta`后通过校验由`GetCurrentStateHash()`获得的状态哈希之后调用的。这个函数接受与传递给`ApplyStateDelta`一样的`id`。 -&nbsp;&nbsp;RollbackStateDelta(id interface{}) error&nbsp; 这个函数撤销在`ApplyStateDelta`中应用的状态变化量。这通常是在调用者调用`ApplyStateDelta`后与由`GetCurrentStateHash()`获得的状态哈希校验失败后调用的。这个函数接受与传递给`ApplyStateDelta`一样的`id`。 -&nbsp;&nbsp;EmptyState() error&nbsp; 这个函数将会删除整个当前状态，得到原始的空状态。这通常是通过变化量加载整个新的状态时调用的。这一样只对状态转移API有用。 3.4.9&nbsp;RemoteLedgers&nbsp;接口 定义： type RemoteLedgers interface { GetRemoteBlocks(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncBlocks, error) GetRemoteStateSnapshot(peerID uint64) (&lt;-chan *pb.SyncStateSnapshot, error) GetRemoteStateDeltas(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncStateDeltas, error) } RemoteLedgers&nbsp;接口的存在主要是为了启用状态转移，和向其它副本询问区块链的状态。和WritableLedger接口一样，这不是给正常的操作使用，而是为追赶，错误恢复等操作而设计的。这个接口中的所有函数调用这都有责任来处理超时。这个接口包含下面这些函数： GetRemoteBlocks(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncBlocks, error) 这个函数尝试从由peerID指定的 peer 中取出由start和finish标识的范围中的*pb.SyncBlocks流。一般情况下，由于区块链必须是从结束到开始这样的顺序来验证的，所以start是比finish更高的块编号。由于慢速的结构，其它请求的返回可能出现在这个通道中，所以调用者必须验证返回的是期望的块。第二次以同样的peerID来调用这个方法会导致第一次的通道关闭。 GetRemoteStateSnapshot(peerID uint64) (&lt;-chan *pb.SyncStateSnapshot, error) 这个函数尝试从由peerID指定的 peer 中取出*pb.SyncStateSnapshot流。为了应用结果，首先需要通过WritableLedger的EmptyState调用来清空存在在状态，然后顺序应用包含在流中的变化量。 GetRemoteStateDeltas(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncStateDeltas, error) 这个函数尝试从由peerID指定的 peer 中取出由start和finish标识的范围中的*pb.SyncStateDeltas流。由于慢速的结构，其它请求的返回可能出现在这个通道中，所以调用者必须验证返回的是期望的块变化量。第二次以同样的peerID来调用这个方法会导致第一次的通道关闭。 3.4.10&nbsp;controller包 3.4.10.1 controller.NewConsenter 签名: func NewConsenter(cpi consensus.CPI) (consenter consensus.Consenter) 这个函数读取为peer过程指定的core.yaml配置文件中的peer.validator.consensus的值。键peer.validator.consensus的有效值指定运行noops还是obcpbft共识。（注意，它最终被改变为noops或custom。在custom情况下，验证 peer 将会运行由consensus/config.yaml中定义的共识插件） 插件的作者需要编辑函数体，来保证路由到它们包中正确的构造函数。例如，对于obcpbft&nbsp;我们指向obcpft.GetPlugin构造器。 这个函数是当设置返回信息处理器的consenter域时，被helper.NewConsensusHandler调用的。输入参数cpi是由helper.NewHelper构造器输出的，并实现了consensus.CPI接口 3.4.11&nbsp;helper包 3.4.11.1 高层次概述 验证 peer 通过helper.NewConsesusHandler函数(一个处理器工厂)，为每个连接的 peer 建立消息处理器(helper.ConsensusHandler)。每个进来的消息都会检查它的类型(helper.HandleMessage)；如果这是为了共识必须到达的消息，它会传递到 peer 的共识对象(consensus.Consenter)。其它的信息会传递到栈中的下一个信息处理器。 3.4.11.2 helper.ConsensusHandler 定义： type ConsensusHandler struct { chatStream peer.ChatStream consenter consensus.Consenter coordinator peer.MessageHandlerCoordinator done chan struct{} peerHandler peer.MessageHandler } 共识中的上下文，我们只关注域coordinator和consenter。coordinator就像名字隐含的那样，它被用来在 peer 的信息处理器之间做协调。例如，当 peer 希望Broadcast时，对象被访问。共识需要到达的共识者会接收到消息并处理它们。 注意，fabric/peer/peer.go定义了peer.MessageHandler&nbsp;(接口)，和peer.MessageHandlerCoordinator（接口）类型。 3.4.11.3 helper.NewConsensusHandler 签名: func NewConsensusHandler(coord peer.MessageHandlerCoordinator, stream peer.ChatStream, initiatedStream bool, next peer.MessageHandler) (peer.MessageHandler, error) 创建一个helper.ConsensusHandler对象。为每个coordinator设置同样的消息处理器。同时把consenter设置为controller.NewConsenter(NewHelper(coord)) 3.4.11.4 helper.Helper 定义: type Helper struct { coordinator peer.MessageHandlerCoordinator } 包含验证peer的coordinator的引用。对象是否为peer实现了consensus.CPI接口。 3.4.11.5 helper.NewHelper 签名: func NewHelper(mhc peer.MessageHandlerCoordinator) consensus.CPI 返回coordinator被设置为输入参数mhc（helper.ConsensusHandler消息处理器的coordinator域）的helper.Helper对象。这个对象实现了consensus.CPI接口，从而允许插件与栈进行交互。 3.4.11.6 helper.HandleMessage 回忆一下，helper.NewConsensusHandler返回的helper.ConsesusHandler对象实现了&nbsp;peer.MessageHandler&nbsp;接口： type MessageHandler interface { RemoteLedger HandleMessage(msg *pb.Message) error SendMessage(msg *pb.Message) error To() (pb.PeerEndpoint, error) Stop() error } 在共识的上下文中，我们只关心HandleMessage方法。签名： func (handler *ConsensusHandler) HandleMessage(msg *pb.Message) error 这个函数检查进来的Message的Type。有四种情况： 等于pb.Message_CONSENSUS：传递给处理器的consenter.RecvMsg函数。 等于pb.Message_CHAIN_TRANSACTION&nbsp;(如：一个外部部署的请求): 一个响应请求首先被发送给用户，然后把消息传递给consenter.RecvMsg函数 等于pb.Message_CHAIN_QUERY&nbsp;(如：查询): 传递给helper.doChainQuery方法来在本地执行 其它: 传递给栈中下一个处理器的HandleMessage方法 3.5 事件 事件框架提供了生产和消费预定义或自定义的事件的能力。它有3个基础组件： 事件流 事件适配器 事件结构 3.5.1 事件流 事件流是用来发送和接收事件的gRPC通道。每个消费者会与事件框架建立事件流，并快速传递它感兴趣的事件。事件生成者通过事件流只发送合适的事件给连接到生产者的消费者。 事件流初始化缓冲和超时参数。缓冲保存着几个等待投递的事件，超时参数在缓冲满时有三个选项： 如果超时小于0，丢弃新到来的事件 如果超时等于0，阻塞事件知道缓冲再次可用 如果超时大于0，等待指定的超时时间，如果缓冲还是满的话就丢弃事件 3.5.1.1 事件生产者 事件生产者暴露函数Send(e *pb.Event)来发送事件，其中Event可以是预定义的Block或Generic事件。将来会定义更多的事件来包括其它的fabric元素。 message Generic { string eventType = 1; bytes payload = 2; } eventType和payload是由事件生产者任意定义的。例如，JSON数据可能被用在payload中。链码或插件发出Generic事件来与消费者通讯。 3.5.1.2 事件消费者 事件消费者允许外部应用监听事件。每个事件消费者通过时间流注册事件适配器。消费者框架可以看成是事件流与适配器之间的桥梁。一种典型的事件消费者使用方式： adapter = &lt;adapter supplied by the client application to register and receive events&gt; consumerClient = NewEventsClient(&lt;event consumer address&gt;, adapter) consumerClient.Start() ... ... consumerClient.Stop() 3.5.2 事件适配器 事件适配器封装了三种流交互的切面： 返回所有感兴趣的事件列表的接口 当事件消费者框架接受到事件后调用的接口 当事件总线终止时，事件消费者框架会调用的接口 引用的实现提供了Golang指定语言绑定 EventAdapter interface { GetInterestedEvents() ([]*ehpb.Interest, error) Recv(msg *ehpb.Event) (bool,error) Disconnected(err error) } 把gRPC当成事件总线协议来使用，允许事件消费者框架对于不同的语言的绑定可移植而不影响事件生成者框架。 3.5.3 事件框架 这节详细描述了事件系统的消息结构。为了简单起见，消息直接使用Golang描述。 事件消费者和生产者之间通信的核心消息是事件。 message Event { oneof Event { //consumer events Register register = 1; //producer events Block block = 2; Generic generic = 3; } } 每一个上面的定义必须是Register,&nbsp;Block或Generic中的一种。 就像之前提到过的一样，消费者通过与生产者建立连接来创建事件总线，并发送Register事件。Register事件实质上是一组声明消费者感兴趣的事件的Interest消息。 message Interest { enum ResponseType { //don&#39;t send events (used to cancel interest) DONTSEND = 0; //send protobuf objects PROTOBUF = 1; //marshall into JSON structure JSON = 2; } string eventType = 1; ResponseType responseType = 2; } 事件可以通过protobuf结构直接发送，也可以通过指定适当的responseType来发送JSON结构。 当前，生产者框架可以生成Block和Generic事件。Block是用来封装区块链中区块属性的消息。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-08-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"fabric的点对点（peer-to-peer）通信是建立在允许双向的基于流的消息gRPC上的。它使用Protocol Buffers来序列化peer之间传输的数据结构。Protocol buffers 是语言无关，平台无关并具有可扩展机制来序列化结构化的数据的技术。数据结构，消息和服务是使用&nbsp;proto3 language注释来描述的。 3.1 消息 消息在节点之间通过Messageproto 结构封装来传递的，可以分为 4 种类型：发现（Discovery）, 交易（Transaction）, 同步(Synchronization)和共识(Consensus)。每种类型在payload中定义了多种子类型。 message Message { enum Type { UNDEFINED = 0; DISC_HELLO = 1; DISC_DISCONNECT = 2; DISC_GET_PEERS = 3; DISC_PEERS = 4; DISC_NEWMSG = 5; CHAIN_STATUS = 6; CHAIN_TRANSACTION = 7; CHAIN_GET_TRANSACTIONS = 8; CHAIN_QUERY = 9; SYNC_GET_BLOCKS = 11; SYNC_BLOCKS = 12; SYNC_BLOCK_ADDED = 13; SYNC_STATE_GET_SNAPSHOT = 14; SYNC_STATE_SNAPSHOT = 15; SYNC_STATE_GET_DELTAS = 16; SYNC_STATE_DELTAS = 17; RESPONSE = 20; CONSENSUS = 21; } Type type = 1; bytes payload = 2; google.protobuf.Timestamp timestamp = 3; } payload是由不同的消息类型所包含的不同的像Transaction或Response这样的对象的不透明的字节数组。例如：type为CHAIN_TRANSACTION那么payload就是一个Transaction对象。 3.1.1 发现消息 在启动时，如果CORE_PEER_DISCOVERY_ROOTNODE被指定，那么 peer 就会运行发现协议。CORE_PEER_DISCOVERY_ROOTNODE是网络（任意peer）中扮演用来发现所有 peer 的起点角色的另一个 peer 的 IP 地址。协议序列以payload是一个包含： message HelloMessage { PeerEndpoint peerEndpoint = 1; uint64 blockNumber = 2; } message PeerEndpoint { PeerID ID = 1; string address = 2; enum Type { UNDEFINED = 0; VALIDATOR = 1; NON_VALIDATOR = 2; } Type type = 3; bytes pkiID = 4; } message PeerID { string name = 1; } 这样的端点的HelloMessage对象的DISC_HELLO消息开始的。 域的定义: PeerID&nbsp;是在启动时或配置文件中定义的 peer 的任意名字 PeerEndpoint&nbsp;描述了端点和它是验证还是非验证 peer pkiID&nbsp;是 peer 的加密ID address&nbsp;以ip:port这样的格式表示的 peer 的主机名或IP和端口 blockNumber&nbsp;是 peer 的区块链的当前的高度 如果收到的DISC_HELLO&nbsp;消息的块的高度比当前 peer 的块的高度高，那么它马上初始化同步协议来追上当前的网络。 DISC_HELLO之后，peer 会周期性的发送DISC_GET_PEERS来发现任意想要加入网络的 peer。收到DISC_GET_PEERS后，peer 会发送payload&nbsp;包含PeerEndpoint的数组的DISC_PEERS作为响应。这是不会使用其它的发现消息类型。 3.1.2 交易消息 有三种不同的交易类型：部署（Deploy），调用（Invoke）和查询（Query）。部署交易向链上安装指定的链码，调用和查询交易会调用部署号的链码。另一种需要考虑的类型是创建（Create）交易，其中部署好的链码是可以在链上实例化并寻址的。这种类型在写这份文档时还没有被实现。 3.1.2.1 交易的数据结构 CHAIN_TRANSACTION和CHAIN_QUERY类型的消息会在payload带有Transaction对象： message Transaction { enum Type { UNDEFINED = 0; CHAINCODE_DEPLOY = 1; CHAINCODE_INVOKE = 2; CHAINCODE_QUERY = 3; CHAINCODE_TERMINATE = 4; } Type type = 1; string uuid = 5; bytes chaincodeID = 2; bytes payloadHash = 3; ConfidentialityLevel confidentialityLevel = 7; bytes nonce = 8; bytes cert = 9; bytes signature = 10; bytes metadata = 4; google.protobuf.Timestamp timestamp = 6; } message TransactionPayload { bytes payload = 1; } enum ConfidentialityLevel { PUBLIC = 0; CONFIDENTIAL = 1; } 域的定义: type&nbsp;- 交易的类型, 为1时表示: UNDEFINED&nbsp;- 为未来的使用所保留. CHAINCODE_DEPLOY&nbsp;- 代表部署新的链码. CHAINCODE_INVOKE&nbsp;- 代表一个链码函数被执行并修改了世界状态 CHAINCODE_QUERY&nbsp;- 代表一个链码函数被执行并可能只读取了世界状态 CHAINCODE_TERMINATE&nbsp;- 标记的链码不可用，所以链码中的函数将不能被调用 chaincodeID&nbsp;- 链码源码，路径，构造函数和参数哈希所得到的ID payloadHash&nbsp;-&nbsp;TransactionPayload.payload所定义的哈希字节. metadata&nbsp;- 应用可能使用的，由自己定义的任意交易相关的元数据 uuid&nbsp;- 交易的唯一ID timestamp&nbsp;- peer 收到交易时的时间戳 confidentialityLevel&nbsp;- 数据保密的级别。当前有两个级别。未来可能会有多个级别。 nonce&nbsp;- 为安全而使用 cert&nbsp;- 交易者的证书 signature&nbsp;- 交易者的签名 TransactionPayload.payload&nbsp;- 交易的payload所定义的字节。由于payload可以很大，所以交易消息只包含payload的哈希 交易安全的详细信息可以在第四节找到 3.1.2.2 交易规范 一个交易通常会关联链码定义及其执行环境（像语言和安全上下文）的链码规范。现在，有一个使用Go语言来编写链码的实现。将来可能会添加新的语言。 message ChaincodeSpec { enum Type { UNDEFINED = 0; GOLANG = 1; NODE = 2; } Type type = 1; ChaincodeID chaincodeID = 2; ChaincodeInput ctorMsg = 3; int32 timeout = 4; string secureContext = 5; ConfidentialityLevel confidentialityLevel = 6; bytes metadata = 7; } message ChaincodeID { string path = 1; string name = 2; } message ChaincodeInput { string function = 1; repeated string args = 2; } 域的定义: chaincodeID&nbsp;- 链码源码的路径和名字 ctorMsg&nbsp;- 调用的函数名及参数 timeout&nbsp;- 执行交易所需的时间（以毫秒表示） confidentialityLevel&nbsp;- 这个交易的保密级别 secureContext&nbsp;- 交易者的安全上下文 metadata&nbsp;- 应用想要传递下去的任何数据 当 peer 收到chaincodeSpec后以合适的交易消息包装它并广播到网络 3.1.2.3 部署交易 部署交易的类型是CHAINCODE_DEPLOY，且它的payload包含ChaincodeDeploymentSpec对象。 message ChaincodeDeploymentSpec { ChaincodeSpec chaincodeSpec = 1; google.protobuf.Timestamp effectiveDate = 2; bytes codePackage = 3; } 域的定义: chaincodeSpec&nbsp;- 参看上面的3.1.2.2节. effectiveDate&nbsp;- 链码准备好可被调用的时间 codePackage&nbsp;- 链码源码的gzip 当验证 peer 部署链码时，它通常会校验codePackage的哈希来保证交易被部署到网络后没有被篡改。 3.1.2.4 调用交易 调用交易的类型是CHAINCODE_DEPLOY，且它的payload包含ChaincodeInvocationSpec对象。 message ChaincodeInvocationSpec { ChaincodeSpec chaincodeSpec = 1; } 3.1.2.5 查询交易 查询交易除了消息类型是CHAINCODE_QUERY其它和调用交易一样 3.1.3 同步消息 同步协议以3.1.1节描述的，当 peer 知道它自己的区块落后于其它 peer 或和它们不一样后所发起的。peer 广播SYNC_GET_BLOCKS，SYNC_STATE_GET_SNAPSHOT或SYNC_STATE_GET_DELTAS并分别接收SYNC_BLOCKS,&nbsp;SYNC_STATE_SNAPSHOT或SYNC_STATE_DELTAS。 安装的共识插件（如：pbft）决定同步协议是如何被应用的。每个小时是针对具体的状态来设计的： SYNC_GET_BLOCKS&nbsp;是一个SyncBlockRange对象，包含一个连续区块的范围的payload的请求。 message SyncBlockRange { uint64 start = 1; uint64 end = 2; uint64 end = 3; } 接收peer使用包含&nbsp;SyncBlocks对象的payload的SYNC_BLOCKS信息来响应 message SyncBlocks { SyncBlockRange range = 1; repeated Block blocks = 2; } start和end标识包含的区块的开始和结束，返回区块的顺序由start和end的值定义。如：当start=3，end=5时区块的顺序将会是3，4，5。当start=5，end=3时区块的顺序将会是5，4，3。 SYNC_STATE_GET_SNAPSHOT&nbsp;请求当前世界状态的快照。&nbsp;payload是一个SyncStateSnapshotRequest对象 message SyncStateSnapshotRequest { uint64 correlationId = 1; } correlationId是请求 peer 用来追踪响应消息的。接受 peer 回复payload为SyncStateSnapshot实例的SYNC_STATE_SNAPSHOT信息 message SyncStateSnapshot { bytes delta = 1; uint64 sequence = 2; uint64 blockNumber = 3; SyncStateSnapshotRequest request = 4; } 这条消息包含快照或以0开始的快照流序列中的一块。终止消息是len(delta) == 0的块 SYNC_STATE_GET_DELTAS&nbsp;请求连续区块的状态变化。默认情况下总账维护500笔交易变化。 delta(j)是block(i)和block(j)之间的状态转变，其中i=j-1。&nbsp;payload包含SyncStateDeltasRequest实例 message SyncStateDeltasRequest { SyncBlockRange range = 1; } 接收 peer 使用包含&nbsp;SyncStateDeltas实例的payload的SYNC_STATE_DELTAS信息来响应 message SyncStateDeltas { SyncBlockRange range = 1; repeated bytes deltas = 2; } delta可能以顺序（从i到j）或倒序（从j到i）来表示状态转变 3.1.4 共识消息 共识处理交易，一个CONSENSUS消息是由共识框架接收到CHAIN_TRANSACTION消息时在内部初始化的。框架把CHAIN_TRANSACTION转换为&nbsp;CONSENSUS然后以相同的payload广播到验证 peer。共识插件接收这条消息并根据内部算法来处理。插件可能创建自定义的子类型来管理共识有穷状态机。3.4节会介绍详细信息。 3.2 总账 总账由两个主要的部分组成，一个是区块链，一个是世界状态。区块链是在总账中的一系列连接好的用来记录交易的区块。世界状态是一个用来存储交易执行状态的键-值(key-value)数据库 3.2.1 区块链 3.2.1.1 区块 区块链是由一个区块链表定义的，每个区块包含它在链中前一个区块的哈希。区块包含的另外两个重要信息是它包含区块执行所有交易后的交易列表和世界状态的哈希 message Block { version = 1; google.protobuf.Timestamp timestamp = 2; bytes transactionsHash = 3; bytes stateHash = 4; bytes previousBlockHash = 5; bytes consensusMetadata = 6; NonHashData nonHashData = 7; } message BlockTransactions { repeated Transaction transactions = 1; } 域的定义: version&nbsp;- 用来追踪协议变化的版本号 timestamp&nbsp;- 由区块提议者填充的时间戳 transactionsHash&nbsp;- 区块中交易的merkle root hash stateHash&nbsp;- 世界状态的merkle root hash previousBlockHash&nbsp;- 前一个区块的hash consensusMetadata&nbsp;- 共识可能会引入的一些可选的元数据 nonHashData&nbsp;-&nbsp;NonHashData消息会在计算区块的哈希前设置为nil，但是在数据库中存储为区块的一部分 BlockTransactions.transactions&nbsp;- 交易消息的数组，由于交易的大小，它们不会被直接包含在区块中 3.2.1.2 区块哈希 previousBlockHash哈希是通过下面算法计算的 使用protocol buffer库把区块消息序列化为字节码 使用FIPS 202描述的SHA3 SHAKE256算法来对序列化后的区块消息计算大小为512位的哈希值 transactionHash是交易merkle树的根。定义merkle tree实现是一个代办 stateHash在3.2.2.1节中定义. 3.2.1.3 非散列数据(NonHashData) NonHashData消息是用来存储不需要所有 peer 都具有相同值的块元数据。他们是建议值。 message NonHashData { google.protobuf.Timestamp localLedgerCommitTimestamp = 1; repeated TransactionResult transactionResults = 2; } message TransactionResult { string uuid = 1; bytes result = 2; uint32 errorCode = 3; string error = 4; } localLedgerCommitTimestamp&nbsp;- 标识区块提交到本地总账的时间戳 TransactionResult&nbsp;- 交易结果的数组 TransactionResult.uuid&nbsp;- 交易的ID TransactionResult.result&nbsp;- 交易的返回值 TransactionResult.errorCode&nbsp;- 可以用来记录关联交易的错误信息的代码 TransactionResult.error&nbsp;- 用来记录关联交易的错误信息的字符串 3.2.1.4 交易执行 一个交易定义了它们部署或执行的链码。区块中的所有交易都可以在记录到总账中的区块之前运行。当链码执行时，他们可能会改变世界状态。之后世界状态的哈希会被记录在区块中。 3.2.2 世界状态 peer 的世界状态涉及到所有被部署的链码的状态集合。进一步说，链码的状态由键值对集合来表示。所以，逻辑上说，peer 的世界状态也是键值对的集合，其中键有元组{chaincodeID, ckey}组成。这里我们使用术语key来标识世界状态的键，如：元组{chaincodeID, ckey}&nbsp;，而且我们使用cKey来标识链码中的唯一键。 为了下面描述的目的，假定chaincodeID是有效的utf8字符串，且ckey和value是一个或多个任意的字节的序列 3.2.2.1 世界状态的哈希 当网络活动时，很多像交易提交和同步 peer 这样的场合可能需要计算 peer 观察到的世界状态的加密-哈希。例如，共识协议可能需要保证网络中最小数量的 peer 观察到同样的世界状态。 应为计算世界状态的加密-哈希是一个非常昂贵的操作，组织世界状态来使得当它改变时能高效效的计算加密-哈希是非常可取的。将来，可以根据不同的负载条件来设计不同的组织形式。 由于fabric是被期望在不同的负载条件下都能正常工作，所以需要一个可拔插的机制来支持世界状态的组织。 3.2.2.1.1 Bucket-tree Bucket-tree&nbsp;是世界状态的组织方式的实现。为了下面描述的目的，世界状态的键被表示成两个组件(chaincodeID&nbsp;and&nbsp;ckey) 的通过nil字节的级联，如：key&nbsp;=&nbsp;chaincodeID+nil+cKey。 这个方法的模型是一个merkle-tree在hash table桶的顶部来计算世界状态的加密-哈希 这个方法的核心是世界状态的key-values被假定存储在由预先决定的桶的数量(numBuckets)所组成的哈希表中。一个哈希函数(hashFunction) 被用来确定包含给定键的桶数量。注意hashFunction不代表SHA3这样的加密-哈希方法，而是决定给定的键的桶的数量的正规的编程语言散列函数。 为了对 merkle-tree建模，有序桶扮演了树上的叶子节点-编号最低的桶是树中的最左边的叶子节点。为了构造树的最后第二层，叶子节点的预定义数量 (maxGroupingAtEachLevel)，从左边开始把每个这样的分组组合在一起，一个节点被当作组中所有叶子节点的共同父节点来插入到最后第二层中。注意最后的父节点的数量可能会少于maxGroupingAtEachLevel这个构造方式继续使用在更高的层级上直到树的根节点被构造。 下面这个表展示的在{numBuckets=10009 and maxGroupingAtEachLevel=10}的配置下会得到的树在不同层级上的节点数。 Level Number of nodes 0 1 1 2 2 11 3 101 4 1001 5 10009 为了计算世界状态的加密-哈希，需要计算每个桶的加密-哈希，并假设它们是merkle-tree的叶子节点的加密-哈希。为了计算桶的加密-哈希，存储在桶中的键值对首先被序列化为字节码并在其上应用加密-哈希函数。为了序列化桶的键值对，所有具有公共chaincodeID前缀的键值对分别序列化并以chaincodeID的升序的方式追加在一起。为了序列化一个chaincodeID的键值对，会涉及到下面的信息： chaincodeID的长度(chaincodeID的字节数) chaincodeID的utf8字节码 chaincodeID的键值对数量 对于每个键值对(以ckey排序) ckey的长度 ckey的字节码 值的长度 值的字节码 对于上面列表的所有数值类型项（如：chaincodeID的长度），使用protobuf的变体编码方式。上面这种编码方式的目的是为了桶中的键值对的字节表示方式不会被任意其他键值对的组合所产生，并减少了序列化字节码的总体大小。 例如：考虑具有chaincodeID1_key1:value1, chaincodeID1_key2:value2, 和 chaincodeID2_key1:value1这样名字的键值对的桶。序列化后的桶看上去会像：12 + chaincodeID1 + 2 + 4 + key1 + 6 + value1 + 4 + key2 + 6 + value2 + 12 + chaincodeID2 + 1 + 4 + key1 + 6 + value1 如果桶中没有键值对，那么加密-哈希为nil。 中间节点和根节点的加密-哈希与标准merkle-tree的计算方法一样，即：应用加密-哈希函数到所有子节点的加密-哈希从左到右级联后得到的字节码。进一步说，如果一个子节点的加密-哈希为nil，那么这个子节点的加密-哈希在级联子节点的加密-哈希是就被省略。如果它只有一个子节点，那么它的加密-哈希就是子节点的加密-哈希。最后，根节点的加密-哈希就是世界状态的加密-哈希。 上面这种方法在状态中少数键值对改变时计算加密-哈希是有性能优势的。主要的优势包括： 那些没有变化的桶的计算会被跳过 merkle-tree的宽度和深度可以通过配置numBuckets和maxGroupingAtEachLevel参数来控制。树的不同深度和宽度对性能和不同的资源都会产生不同的影响。 在一个具体的部署中，所有的 peer 都期望使用相同的numBuckets, maxGroupingAtEachLevel, 和 hashFunction的配置。进一步说，如果任何一个配置在之后的阶段被改变，那么这些改变需要应用到所有的 peer 中，来保证 peer 节点之间的加密-哈希的比较是有意义的。即使，这可能会导致基于实现的已有数据的迁移。例如：一种实现希望存储树中所有节点最后计算的加密-哈希，那么它就需要被重新计算。 3.3 链码（Chaincode） 链码是在交易（参看3.1.2节）被部署是分发到网络上，并被所有验证 peer 通过隔离的沙箱来管理的应用级代码。尽管任意的虚拟技术都可以支持沙箱，现在是通过Docker容器来运行链码的。这节中描述的协议可以启用不同虚拟实现的插入与运行。 3.3.1 虚拟机实例化 一个实现VM接口的虚拟机 type VM interface { build(ctxt context.Context, id string, args []string, env []string, attachstdin bool, attachstdout bool, reader io.Reader) error start(ctxt context.Context, id string, args []string, env []string, attachstdin bool, attachstdout bool) error stop(ctxt context.Context, id string, timeout uint, dontkill bool, dontremove bool) error } fabric在处理链码上的部署交易或其他交易时，如果这个链码的VM未启动（崩溃或之前的不活动导致的关闭）时实例化VM。每个链码镜像通过build函数构建，通过start函数启动，并使用stop函数停止。 一旦链码容器被启动，它使用gRPC来连接到启动这个链码的验证 peer，并为链码上的调用和查询交易建立通道。 3.3.2 链码协议 验证 peer 和它的链码之间是通过gRPC流来通信的。链码容器上有shim层来处理链码与验证 peer 之间的protobuf消息协议。 message ChaincodeMessage { enum Type { UNDEFINED = 0; REGISTER = 1; REGISTERED = 2; INIT = 3; READY = 4; TRANSACTION = 5; COMPLETED = 6; ERROR = 7; GET_STATE = 8; PUT_STATE = 9; DEL_STATE = 10; INVOKE_CHAINCODE = 11; INVOKE_QUERY = 12; RESPONSE = 13; QUERY = 14; QUERY_COMPLETED = 15; QUERY_ERROR = 16; RANGE_QUERY_STATE = 17; } Type type = 1; google.protobuf.Timestamp timestamp = 2; bytes payload = 3; string uuid = 4; } 域的定义: Type&nbsp;是消息的类型 payload&nbsp;是消息的payload. 每个payload取决于Type. uuid&nbsp;消息唯一的ID 消息的类型在下面的小节中描述 链码实现被验证 peer 在处理部署，调用或查询交易时调用的Chaincode接口 type Chaincode interface { Invoke(stub *ChaincodeStub, function string, args []string) (error) Query(stub *ChaincodeStub, function string, args []string) ([]byte, error) } Init,&nbsp;Invoke&nbsp;和&nbsp;Query函数使用function&nbsp;and&nbsp;args参数来支持多种交易。Init是构造函数，它只在部署交易是被执行。Query函数是不允许修改链码的状态的；它只能读取和计算并以byte数组的形式返回。 3.3.2.1 链码部署 当部署时（链码容器已经启动），shim层发送一次性的具有包含ChaincodeID的payload的REGISTER消息给验证 peer。然后 peer 以REGISTERED或ERROR来响应成功或失败。当收到ERROR后shim关闭连接并退出。 注册之后，验证 peer 发送具有包含ChaincodeInput对象的INIT消息。shim使用从ChaincodeInput获得的参数来调用Init函数，通过像设置持久化状态这样操作来初始化链码。 shim根据Init函数的返回值，响应RESPONSE或ERROR消息。如果没有错误，那么链码初始化完成，并准备好接收调用和查询交易。 3.3.2.2 链码调用 当处理调用交易时，验证 peer 发送TRANSACTION消息给链码容器的shim，由它来调用链码的Invoke函数，并传递从ChaincodeInput得到的参数。shim响应RESPONSE或ERROR消息来表示函数完成。如果接收到ERROR函数，payload包含链码所产生的错误信息。 3.3.2.3 来代码查询 与调用交易一样，验证 peer 发送QUERY消息给链码容器的shim，由它来调用链码的Query函数，并传递从ChaincodeInput得到的参数。Query函数可能会返回状态值或错误，它会把它通过RESPONSE或ERROR消息来传递给验证 peer。 3.3.2.4 链码状态 每个链码可能都定义了它自己的持久化状态变量。例如，一个链码可能创建电视，汽车或股票这样的资产来保存资产属性。当Invoke函数处理时，链码可能会更新状态变量，例如改变资产所有者。链码会根据下面这些消息类型类操作状态变量： PUT_STATE 链码发送一个payload包含PutStateInfo对象的PU_STATE消息来保存键值对。 message PutStateInfo { string key = 1; bytes value = 2; } GET_STATE 链码发送一个由payload指定要获取值的键的GET_STATE消息。 DEL_STATE 链码发送一个由payload指定要删除值的键的DEL_STATE消息。 RANGE_QUERY_STATE 链码发送一个payload包含RANGE_QUERY_STATE对象的RANGE_QUERY_STATE来获取一个范围内的值。 message RangeQueryState { string startKey = 1; string endKey = 2; } startKey和endKey假设是通过字典排序的. 验证 peer 响应一个payload是RangeQueryStateResponse对象的RESPONSE消息 message RangeQueryStateResponse { repeated RangeQueryStateKeyValue keysAndValues = 1; bool hasMore = 2; string ID = 3; } message RangeQueryStateKeyValue { string key = 1; bytes value = 2; } 如果相应中hasMore=true，这表示有在请求的返回中还有另外的键。链码可以通过发送包含与响应中ID相同的ID的RangeQueryStateNext消息来获取下一集合。 message RangeQueryStateNext { string ID = 1; } 当链码结束读取范围，它会发送带有ID的RangeQueryStateClose消息来期望它关闭。 message RangeQueryStateClose { string ID = 1; } INVOKE_CHAINCODE 链码可以通过发送payload包含&nbsp;ChaincodeSpec对象的INVOKE_CHAINCODE消息给验证 peer 来在相同的交易上下文中调用另一个链码 QUERY_CHAINCODE 链码可以通过发送payload包含&nbsp;ChaincodeSpec对象的QUERY_CHAINCODE消息给验证 peer 来在相同的交易上下文中查询另一个链码 3.4 插拔式共识框架 共识框架定义了每个共识插件都需要实现的接口： consensus.Consenter: 允许共识插件从网络上接收消息的接口 consensus.CPI: 共识编程接口Consensus Programming Interface&nbsp;(CPI) 是共识插件用来与栈交互的，这个接口可以分为两部分： consensus.Communicator: 用来发送（广播或单播）消息到其他的验证 peer consensus.LedgerStack: 这个接口使得执行框架像总账一样方便 就像下面描述的细节一样，consensus.LedgerStack封装了其他接口，consensus.Executor接口是共识框架的核心部分。换句话说，consensus.Executor接口允许一个（批量）交易启动，执行，根据需要回滚，预览和提交。每一个共识插件都需要满足以所有验证 peer 上全序的方式把批量（块）交易（通过consensus.Executor.CommitTxBatch）被提交到总账中（参看下面的consensus.Executor接口获得详细细节）。 当前，共识框架由consensus,&nbsp;controller和helper这三个包组成。使用controller和helper包的主要原因是防止Go语言的“循环引入”和当插件更新时的最小化代码变化。 controller&nbsp;包规范了验证 peer 所使用的共识插件 helper&nbsp;是围绕公式插件的垫片，它是用来与剩下的栈交互的，如为其他 peer 维护消息。 这里有2个共识插件提供：pbft和noops： obcpbft包包含实现&nbsp;PBFT&nbsp;[1] 和&nbsp;Sieve&nbsp;共识协议的共识插件。参看第5节的详细介绍 noops&nbsp;是一个为开发和测试提供的&#39;&#39;假的&#39;&#39;共识插件. 它处理所有共识消息但不提供共识功能，它也是一个好的学习如何开发一个共识插件的简单例子。 3.4.1&nbsp;Consenter&nbsp;接口 定义: type Consenter interface { RecvMsg(msg *pb.Message) error } Consenter接口是插件对（外部的）客户端请求的入口，当处理共识时，共识消息在内部（如从共识模块）产生。NewConsenter创建Consenter插件。RecvMsg`以到达共识的顺序来处理进来的交易。 阅读下面的helper.HandleMessage来理解 peer 是如何和这个接口来交互的。 3.4.2&nbsp;CPI接口 定义: type CPI interface { Inquirer Communicator SecurityUtils LedgerStack } CPI&nbsp;允许插件和栈交互。它是由helper.Helper对象实现的。回想一下这个对象是： 在helper.NewConsensusHandler被调用时初始化的 当它们的插件构造了consensus.Consenter对象，那么它对插件的作者是可访问的 3.4.3&nbsp;Inquirer接口 定义: type Inquirer interface { GetNetworkInfo() (self *pb.PeerEndpoint, network []*pb.PeerEndpoint, err error) GetNetworkHandles() (self *pb.PeerID, network []*pb.PeerID, err error) } 这个接口是consensus.CPI接口的一部分。它是用来获取网络中验证 peer 的（GetNetworkHandles）处理，以及那些验证 peer 的明细(GetNetworkInfo)： 注意pees由pb.PeerID对象确定。这是一个protobuf消息，当前定义为（注意这个定义很可能会被修改）： message PeerID { string name = 1; } 3.4.4&nbsp;Communicator接口 定义: type Communicator interface { Broadcast(msg *pb.Message) error Unicast(msg *pb.Message, receiverHandle *pb.PeerID) error } 这个接口是consensus.CPI接口的一部分。它是用来与网络上其它 peer 通信的（helper.Broadcast,&nbsp;helper.Unicast）： 3.4.5&nbsp;SecurityUtils接口 定义: type SecurityUtils interface { Sign(msg []byte) ([]byte, error) Verify(peerID *pb.PeerID, signature []byte, message []byte) error } 这个接口是consensus.CPI接口的一部分。它用来处理消息签名(Sign)的加密操作和验证签名(Verify) 3.4.6&nbsp;LedgerStack&nbsp;接口 定义: type LedgerStack interface { Executor Ledger RemoteLedgers } CPI接口的主要成员，LedgerStack&nbsp;组与fabric的其它部分与共识相互作用，如执行交易，查询和更新总账。这个接口支持对本地区块链和状体的查询，更新本地区块链和状态，查询共识网络上其它节点的区块链和状态。它是有Executor,Ledger和RemoteLedgers这三个接口组成的。下面会描述它们。 3.4.7&nbsp;Executor&nbsp;接口 定义: type Executor interface { BeginTxBatch(id interface{}) error ExecTXs(id interface{}, txs []*pb.Transaction) ([]byte, []error) CommitTxBatch(id interface{}, transactions []*pb.Transaction, transactionsResults []*pb.TransactionResult, metadata []byte) error RollbackTxBatch(id interface{}) error PreviewCommitTxBatchBlock(id interface{}, transactions []*pb.Transaction, metadata []byte) (*pb.Block, error) } executor接口是LedgerStack接口最常使用的部分，且是共识网络工作的必要部分。接口允许交易启动，执行，根据需要回滚，预览和提交。这个接口由下面这些方法组成。 3.4.7.1 开始批量交易 BeginTxBatch(id interface{}) error 这个调用接受任意的，故意含糊的id，来使得共识插件可以保证与这个具体的批量相关的交易才会被执行。例如：在pbft实现中，这个id是被执行交易的编码过的哈希。 3.4.7.2 执行交易 ExecTXs(id interface{}, txs []*pb.Transaction) ([]byte, []error) 这个调用根据总账当前的状态接受一组交易，并返回带有对应着交易组的错误信息组的当前状态的哈希。注意一个交易所产生的错误不影响批量交易的安全提交。当遇到失败所采用的策略取决与共识插件的实现。这个接口调用多次是安全的。 3.4.7.3 提交与回滚交易 RollbackTxBatch(id interface{}) error 这个调用忽略了批量执行。这会废弃掉对当前状态的操作，并把总账状态回归到之前的状态。批量是从BeginBatchTx开始的，如果需要开始一个新的就需要在执行任意交易之前重新创建一个。 PreviewCommitTxBatchBlock(id interface{}, transactions []*pb.Transaction, metadata []byte) (*pb.Block, error) 这个调用是共识插件对非确定性交易执行的测试时最有用的方法。区块返回的哈希表部分会保证，当CommitTxBatch被立即调用时的区块是同一个。这个保证会被任意新的交易的执行所打破。 CommitTxBatch(id interface{}, transactions []*pb.Transaction, transactionsResults []*pb.TransactionResult, metadata []byte) error 这个调用提交区块到区块链中。区块必须以全序提交到区块链中，CommitTxBatch结束批量交易，在执行或提交任意的交易之前必须先调用BeginTxBatch。 3.4.8&nbsp;Ledger&nbsp;接口 定义： type Ledger interface { ReadOnlyLedger UtilLedger WritableLedger } Ledger&nbsp;接口是为了允许共识插件询问或可能改变区块链当前状态。它是由下面描述的三个接口组成的 3.4.8.1&nbsp;ReadOnlyLedger&nbsp;接口 定义： type ReadOnlyLedger interface { GetBlock(id uint64) (block *pb.Block, err error) GetCurrentStateHash() (stateHash []byte, err error) GetBlockchainSize() (uint64, error) } ReadOnlyLedger&nbsp;接口是为了查询总账的本地备份，而不会修改它。它是由下面这些函数组成的。 GetBlockchainSize() (uint64, error) 这个函数返回区块链总账的长度。一般来说，这个函数永远不会失败，在这种不太可能发生情况下，错误被传递给调用者，由它确定是否需要恢复。具有最大区块值的区块的值为GetBlockchainSize()-1 注意在区块链总账的本地副本是腐坏或不完整的情况下，这个调用会返回链中最大的区块值+1。这允许节点在旧的块是腐坏或丢失的情况下能继续操作当前状态/块。 GetBlock(id uint64) (block *pb.Block, err error) 这个调用返回区块链中块的数值id。一般来说这个调用是不会失败的，除非请求的区块超出当前区块链的长度，或者底层的区块链被腐坏了。GetBlock的失败可能可以通过状态转换机制来取回它。 GetCurrentStateHash() (stateHash []byte, err error) 这个盗用返回总账的当前状态的哈希。一般来说，这个函数永远不会失败，在这种不太可能发生情况下，错误被传递给调用者，由它确定是否需要恢复。 3.4.8.2&nbsp;UtilLedger&nbsp;接口 定义： type UtilLedger interface { HashBlock(block *pb.Block) ([]byte, error) VerifyBlockchain(start, finish uint64) (uint64, error) } UtilLedger&nbsp;接口定义了一些由本地总账提供的有用的功能。使用mock接口来重载这些功能在测试时非常有用。这个接口由两个函数构成。 会会 HashBlock(block *pb.Block) ([]byte, error) 尽管*pb.Block定义了GetHash方法，为了mock测试，重载这个方法会非常有用。因此，建议GetHash方法不直接调用，而是通过UtilLedger.HashBlock接口来调用这个方法。一般来说，这个函数永远不会失败，但是错误还是会传递给调用者，让它决定是否使用适当的恢复。 VerifyBlockchain(start, finish uint64) (uint64, error) 这个方法是用来校验区块链中的大的区域。它会从高的块start到低的块finish，返回第一个块的PreviousBlockHash与块的前一个块的哈希不相符的块编号以及错误信息。注意，它一般会标识最后一个好的块的编号，而不是第一个坏的块的编号。 3.4.8.3&nbsp;WritableLedger&nbsp;接口 定义： type WritableLedger interface { PutBlock(blockNumber uint64, block *pb.Block) error ApplyStateDelta(id interface{}, delta *statemgmt.StateDelta) error CommitStateDelta(id interface{}) error RollbackStateDelta(id interface{}) error EmptyState() error } WritableLedger&nbsp;接口允许调用者更新区块链。注意这NOT&nbsp;不是共识插件的通常用法。当前的状态需要通过Executor接口执行交易来修改，新的区块在交易提交时生成。相反的，这个接口主要是用来状态改变和腐化恢复。特别的，这个接口下的函数永远不能直接暴露给共识消息，这样会导致打破区块链所承诺的不可修改这一概念。这个结构包含下面这些函数。 -&nbsp;&nbsp;PutBlock(blockNumber uint64, block *pb.Block) error&nbsp;&nbsp;这个函数根据给定的区块编号把底层区块插入到区块链中。注意这是一个不安全的接口，所以它不会有错误返回或返回。插入一个比当前区块高度更高的区块是被允许的，通用，重写一个已经提交的区块也是被允许的。记住，由于哈希技术使得创建一个链上的更早的块是不可行的，所以这并不影响链的可审计性和不可变性。任何尝试重写区块链的历史的操作都能很容易的被侦测到。这个函数一般只用于状态转移API。 -&nbsp;&nbsp;ApplyStateDelta(id interface{}, delta *statemgmt.StateDelta) error&nbsp; 这个函数接收状态变化，并把它应用到当前的状态。变化量的应用会使得状态向前或向后转变，这取决于状态变化量的构造，与`Executor`方法一样，`ApplyStateDelta`接受一个同样会被传递给`CommitStateDelta` or `RollbackStateDelta`不透明的接口`id` -&nbsp;&nbsp;CommitStateDelta(id interface{}) error&nbsp; 这个方法提交在`ApplyStateDelta`中应用的状态变化。这通常是在调用者调用`ApplyStateDelta`后通过校验由`GetCurrentStateHash()`获得的状态哈希之后调用的。这个函数接受与传递给`ApplyStateDelta`一样的`id`。 -&nbsp;&nbsp;RollbackStateDelta(id interface{}) error&nbsp; 这个函数撤销在`ApplyStateDelta`中应用的状态变化量。这通常是在调用者调用`ApplyStateDelta`后与由`GetCurrentStateHash()`获得的状态哈希校验失败后调用的。这个函数接受与传递给`ApplyStateDelta`一样的`id`。 -&nbsp;&nbsp;EmptyState() error&nbsp; 这个函数将会删除整个当前状态，得到原始的空状态。这通常是通过变化量加载整个新的状态时调用的。这一样只对状态转移API有用。 3.4.9&nbsp;RemoteLedgers&nbsp;接口 定义： type RemoteLedgers interface { GetRemoteBlocks(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncBlocks, error) GetRemoteStateSnapshot(peerID uint64) (&lt;-chan *pb.SyncStateSnapshot, error) GetRemoteStateDeltas(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncStateDeltas, error) } RemoteLedgers&nbsp;接口的存在主要是为了启用状态转移，和向其它副本询问区块链的状态。和WritableLedger接口一样，这不是给正常的操作使用，而是为追赶，错误恢复等操作而设计的。这个接口中的所有函数调用这都有责任来处理超时。这个接口包含下面这些函数： GetRemoteBlocks(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncBlocks, error) 这个函数尝试从由peerID指定的 peer 中取出由start和finish标识的范围中的*pb.SyncBlocks流。一般情况下，由于区块链必须是从结束到开始这样的顺序来验证的，所以start是比finish更高的块编号。由于慢速的结构，其它请求的返回可能出现在这个通道中，所以调用者必须验证返回的是期望的块。第二次以同样的peerID来调用这个方法会导致第一次的通道关闭。 GetRemoteStateSnapshot(peerID uint64) (&lt;-chan *pb.SyncStateSnapshot, error) 这个函数尝试从由peerID指定的 peer 中取出*pb.SyncStateSnapshot流。为了应用结果，首先需要通过WritableLedger的EmptyState调用来清空存在在状态，然后顺序应用包含在流中的变化量。 GetRemoteStateDeltas(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncStateDeltas, error) 这个函数尝试从由peerID指定的 peer 中取出由start和finish标识的范围中的*pb.SyncStateDeltas流。由于慢速的结构，其它请求的返回可能出现在这个通道中，所以调用者必须验证返回的是期望的块变化量。第二次以同样的peerID来调用这个方法会导致第一次的通道关闭。 3.4.10&nbsp;controller包 3.4.10.1 controller.NewConsenter 签名: func NewConsenter(cpi consensus.CPI) (consenter consensus.Consenter) 这个函数读取为peer过程指定的core.yaml配置文件中的peer.validator.consensus的值。键peer.validator.consensus的有效值指定运行noops还是obcpbft共识。（注意，它最终被改变为noops或custom。在custom情况下，验证 peer 将会运行由consensus/config.yaml中定义的共识插件） 插件的作者需要编辑函数体，来保证路由到它们包中正确的构造函数。例如，对于obcpbft&nbsp;我们指向obcpft.GetPlugin构造器。 这个函数是当设置返回信息处理器的consenter域时，被helper.NewConsensusHandler调用的。输入参数cpi是由helper.NewHelper构造器输出的，并实现了consensus.CPI接口 3.4.11&nbsp;helper包 3.4.11.1 高层次概述 验证 peer 通过helper.NewConsesusHandler函数(一个处理器工厂)，为每个连接的 peer 建立消息处理器(helper.ConsensusHandler)。每个进来的消息都会检查它的类型(helper.HandleMessage)；如果这是为了共识必须到达的消息，它会传递到 peer 的共识对象(consensus.Consenter)。其它的信息会传递到栈中的下一个信息处理器。 3.4.11.2 helper.ConsensusHandler 定义： type ConsensusHandler struct { chatStream peer.ChatStream consenter consensus.Consenter coordinator peer.MessageHandlerCoordinator done chan struct{} peerHandler peer.MessageHandler } 共识中的上下文，我们只关注域coordinator和consenter。coordinator就像名字隐含的那样，它被用来在 peer 的信息处理器之间做协调。例如，当 peer 希望Broadcast时，对象被访问。共识需要到达的共识者会接收到消息并处理它们。 注意，fabric/peer/peer.go定义了peer.MessageHandler&nbsp;(接口)，和peer.MessageHandlerCoordinator（接口）类型。 3.4.11.3 helper.NewConsensusHandler 签名: func NewConsensusHandler(coord peer.MessageHandlerCoordinator, stream peer.ChatStream, initiatedStream bool, next peer.MessageHandler) (peer.MessageHandler, error) 创建一个helper.ConsensusHandler对象。为每个coordinator设置同样的消息处理器。同时把consenter设置为controller.NewConsenter(NewHelper(coord)) 3.4.11.4 helper.Helper 定义: type Helper struct { coordinator peer.MessageHandlerCoordinator } 包含验证peer的coordinator的引用。对象是否为peer实现了consensus.CPI接口。 3.4.11.5 helper.NewHelper 签名: func NewHelper(mhc peer.MessageHandlerCoordinator) consensus.CPI 返回coordinator被设置为输入参数mhc（helper.ConsensusHandler消息处理器的coordinator域）的helper.Helper对象。这个对象实现了consensus.CPI接口，从而允许插件与栈进行交互。 3.4.11.6 helper.HandleMessage 回忆一下，helper.NewConsensusHandler返回的helper.ConsesusHandler对象实现了&nbsp;peer.MessageHandler&nbsp;接口： type MessageHandler interface { RemoteLedger HandleMessage(msg *pb.Message) error SendMessage(msg *pb.Message) error To() (pb.PeerEndpoint, error) Stop() error } 在共识的上下文中，我们只关心HandleMessage方法。签名： func (handler *ConsensusHandler) HandleMessage(msg *pb.Message) error 这个函数检查进来的Message的Type。有四种情况： 等于pb.Message_CONSENSUS：传递给处理器的consenter.RecvMsg函数。 等于pb.Message_CHAIN_TRANSACTION&nbsp;(如：一个外部部署的请求): 一个响应请求首先被发送给用户，然后把消息传递给consenter.RecvMsg函数 等于pb.Message_CHAIN_QUERY&nbsp;(如：查询): 传递给helper.doChainQuery方法来在本地执行 其它: 传递给栈中下一个处理器的HandleMessage方法 3.5 事件 事件框架提供了生产和消费预定义或自定义的事件的能力。它有3个基础组件： 事件流 事件适配器 事件结构 3.5.1 事件流 事件流是用来发送和接收事件的gRPC通道。每个消费者会与事件框架建立事件流，并快速传递它感兴趣的事件。事件生成者通过事件流只发送合适的事件给连接到生产者的消费者。 事件流初始化缓冲和超时参数。缓冲保存着几个等待投递的事件，超时参数在缓冲满时有三个选项： 如果超时小于0，丢弃新到来的事件 如果超时等于0，阻塞事件知道缓冲再次可用 如果超时大于0，等待指定的超时时间，如果缓冲还是满的话就丢弃事件 3.5.1.1 事件生产者 事件生产者暴露函数Send(e *pb.Event)来发送事件，其中Event可以是预定义的Block或Generic事件。将来会定义更多的事件来包括其它的fabric元素。 message Generic { string eventType = 1; bytes payload = 2; } eventType和payload是由事件生产者任意定义的。例如，JSON数据可能被用在payload中。链码或插件发出Generic事件来与消费者通讯。 3.5.1.2 事件消费者 事件消费者允许外部应用监听事件。每个事件消费者通过时间流注册事件适配器。消费者框架可以看成是事件流与适配器之间的桥梁。一种典型的事件消费者使用方式： adapter = &lt;adapter supplied by the client application to register and receive events&gt; consumerClient = NewEventsClient(&lt;event consumer address&gt;, adapter) consumerClient.Start() ... ... consumerClient.Stop() 3.5.2 事件适配器 事件适配器封装了三种流交互的切面： 返回所有感兴趣的事件列表的接口 当事件消费者框架接受到事件后调用的接口 当事件总线终止时，事件消费者框架会调用的接口 引用的实现提供了Golang指定语言绑定 EventAdapter interface { GetInterestedEvents() ([]*ehpb.Interest, error) Recv(msg *ehpb.Event) (bool,error) Disconnected(err error) } 把gRPC当成事件总线协议来使用，允许事件消费者框架对于不同的语言的绑定可移植而不影响事件生成者框架。 3.5.3 事件框架 这节详细描述了事件系统的消息结构。为了简单起见，消息直接使用Golang描述。 事件消费者和生产者之间通信的核心消息是事件。 message Event { oneof Event { //consumer events Register register = 1; //producer events Block block = 2; Generic generic = 3; } } 每一个上面的定义必须是Register,&nbsp;Block或Generic中的一种。 就像之前提到过的一样，消费者通过与生产者建立连接来创建事件总线，并发送Register事件。Register事件实质上是一组声明消费者感兴趣的事件的Interest消息。 message Interest { enum ResponseType { //don&#39;t send events (used to cancel interest) DONTSEND = 0; //send protobuf objects PROTOBUF = 1; //marshall into JSON structure JSON = 2; } string eventType = 1; ResponseType responseType = 2; } 事件可以通过protobuf结构直接发送，也可以通过指定适当的responseType来发送JSON结构。 当前，生产者框架可以生成Block和Generic事件。Block是用来封装区块链中区块属性的消息。 阅读更多","@type":"BlogPosting","url":"/2016/08/09/fe76530461e4f22463cb6fc4887fdd81.html","headline":"BlockChain技术系列(三)- fabric协议介绍","dateModified":"2016-08-09T00:00:00+08:00","datePublished":"2016-08-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2016/08/09/fe76530461e4f22463cb6fc4887fdd81.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>BlockChain技术系列(三)- fabric协议介绍</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> fabric的点对点（peer-to-peer）通信是建立在允许双向的基于流的消息<a target="_blank" href="http://www.grpc.io/docs/" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; background-color:transparent">gRPC</a>上的。它使用<a target="_blank" href="https://developers.google.com/protocol-buffers" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; background-color:transparent">Protocol Buffers</a>来序列化peer之间传输的数据结构。Protocol buffers 是语言无关，平台无关并具有可扩展机制来序列化结构化的数据的技术。数据结构，消息和服务是使用&nbsp;<a target="_blank" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; background-color:transparent">proto3 language</a>注释来描述的。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-31-消息" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#31-消息" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.1 消息</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 消息在节点之间通过<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Message</code>proto 结构封装来传递的，可以分为 4 种类型：发现（Discovery）, 交易（Transaction）, 同步(Synchronization)和共识(Consensus)。每种类型在<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>中定义了多种子类型。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message Message {
   enum Type {
        UNDEFINED = 0;

        DISC_HELLO = 1;
        DISC_DISCONNECT = 2;
        DISC_GET_PEERS = 3;
        DISC_PEERS = 4;
        DISC_NEWMSG = 5;

        CHAIN_STATUS = 6;
        CHAIN_TRANSACTION = 7;
        CHAIN_GET_TRANSACTIONS = 8;
        CHAIN_QUERY = 9;

        SYNC_GET_BLOCKS = 11;
        SYNC_BLOCKS = 12;
        SYNC_BLOCK_ADDED = 13;

        SYNC_STATE_GET_SNAPSHOT = 14;
        SYNC_STATE_SNAPSHOT = 15;
        SYNC_STATE_GET_DELTAS = 16;
        SYNC_STATE_DELTAS = 17;

        RESPONSE = 20;
        CONSENSUS = 21;
    }
    Type type = 1;
    bytes payload = 2;
    google.protobuf.Timestamp timestamp = 3;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>是由不同的消息类型所包含的不同的像<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Transaction</code>或<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Response</code>这样的对象的不透明的字节数组。例如：<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">type</code>为<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAIN_TRANSACTION</code>那么<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>就是一个<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Transaction</code>对象。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-311-发现消息" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#311-发现消息" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.1.1 发现消息</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 在启动时，如果<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CORE_PEER_DISCOVERY_ROOTNODE</code>被指定，那么 peer 就会运行发现协议。<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CORE_PEER_DISCOVERY_ROOTNODE</code>是网络（任意peer）中扮演用来发现所有 peer 的起点角色的另一个 peer 的 IP 地址。协议序列以<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>是一个包含：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message HelloMessage {
  PeerEndpoint peerEndpoint = 1;
  uint64 blockNumber = 2;
}
message PeerEndpoint {
    PeerID ID = 1;
    string address = 2;
    enum Type {
      UNDEFINED = 0;
      VALIDATOR = 1;
      NON_VALIDATOR = 2;
    }
    Type type = 3;
    bytes pkiID = 4;
}

message PeerID {
    string name = 1;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这样的端点的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">HelloMessage</code>对象的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">DISC_HELLO</code>消息开始的。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <span style="font-weight:600">域的定义:</span></p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">PeerID</code>&nbsp;是在启动时或配置文件中定义的 peer 的任意名字</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">PeerEndpoint</code>&nbsp;描述了端点和它是验证还是非验证 peer</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">pkiID</code>&nbsp;是 peer 的加密ID</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">address</code>&nbsp;以<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ip:port</code>这样的格式表示的 peer 的主机名或IP和端口</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">blockNumber</code>&nbsp;是 peer 的区块链的当前的高度</li>
  </ul> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 如果收到的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">DISC_HELLO</code>&nbsp;消息的块的高度比当前 peer 的块的高度高，那么它马上初始化同步协议来追上当前的网络。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">DISC_HELLO</code>之后，peer 会周期性的发送<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">DISC_GET_PEERS</code>来发现任意想要加入网络的 peer。收到<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">DISC_GET_PEERS</code>后，peer 会发送<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>&nbsp;包含<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">PeerEndpoint</code>的数组的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">DISC_PEERS</code>作为响应。这是不会使用其它的发现消息类型。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-312-交易消息" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#312-交易消息" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.1.2 交易消息</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 有三种不同的交易类型：部署（Deploy），调用（Invoke）和查询（Query）。部署交易向链上安装指定的链码，调用和查询交易会调用部署号的链码。另一种需要考虑的类型是创建（Create）交易，其中部署好的链码是可以在链上实例化并寻址的。这种类型在写这份文档时还没有被实现。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3121-交易的数据结构" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3121-交易的数据结构" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.1.2.1 交易的数据结构</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAIN_TRANSACTION</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAIN_QUERY</code>类型的消息会在<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>带有<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Transaction</code>对象：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message Transaction {
    enum Type {
        UNDEFINED = 0;
        CHAINCODE_DEPLOY = 1;
        CHAINCODE_INVOKE = 2;
        CHAINCODE_QUERY = 3;
        CHAINCODE_TERMINATE = 4;
    }
    Type type = 1;
    string uuid = 5;
    bytes chaincodeID = 2;
    bytes payloadHash = 3;

    ConfidentialityLevel confidentialityLevel = 7;
    bytes nonce = 8;
    bytes cert = 9;
    bytes signature = 10;

    bytes metadata = 4;
    google.protobuf.Timestamp timestamp = 6;
}

message TransactionPayload {
    bytes payload = 1;
}

enum ConfidentialityLevel {
    PUBLIC = 0;
    CONFIDENTIAL = 1;
}

</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <span style="font-weight:600">域的定义:</span></p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">type</code>&nbsp;- 交易的类型, 为1时表示: 
    <ul style="padding-left:2em; margin-top:0px; margin-bottom:0px"> 
     <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">UNDEFINED</code>&nbsp;- 为未来的使用所保留.</li>
     <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAINCODE_DEPLOY</code>&nbsp;- 代表部署新的链码. 
      <ul style="padding-left:2em; margin-top:0px; margin-bottom:0px"> 
       <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAINCODE_INVOKE</code>&nbsp;- 代表一个链码函数被执行并修改了世界状态</li>
       <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAINCODE_QUERY</code>&nbsp;- 代表一个链码函数被执行并可能只读取了世界状态</li>
       <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAINCODE_TERMINATE</code>&nbsp;- 标记的链码不可用，所以链码中的函数将不能被调用</li>
      </ul> </li>
    </ul> </li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">chaincodeID</code>&nbsp;- 链码源码，路径，构造函数和参数哈希所得到的ID</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payloadHash</code>&nbsp;-&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">TransactionPayload.payload</code>所定义的哈希字节.</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">metadata</code>&nbsp;- 应用可能使用的，由自己定义的任意交易相关的元数据</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">uuid</code>&nbsp;- 交易的唯一ID</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">timestamp</code>&nbsp;- peer 收到交易时的时间戳</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">confidentialityLevel</code>&nbsp;- 数据保密的级别。当前有两个级别。未来可能会有多个级别。</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">nonce</code>&nbsp;- 为安全而使用</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">cert</code>&nbsp;- 交易者的证书</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">signature</code>&nbsp;- 交易者的签名</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">TransactionPayload.payload</code>&nbsp;- 交易的payload所定义的字节。由于payload可以很大，所以交易消息只包含payload的哈希</li>
  </ul> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 交易安全的详细信息可以在第四节找到</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3122-交易规范" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3122-交易规范" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.1.2.2 交易规范</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 一个交易通常会关联链码定义及其执行环境（像语言和安全上下文）的链码规范。现在，有一个使用Go语言来编写链码的实现。将来可能会添加新的语言。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message ChaincodeSpec {
    enum Type {
        UNDEFINED = 0;
        GOLANG = 1;
        NODE = 2;
    }
    Type type = 1;
    ChaincodeID chaincodeID = 2;
    ChaincodeInput ctorMsg = 3;
    int32 timeout = 4;
    string secureContext = 5;
    ConfidentialityLevel confidentialityLevel = 6;
    bytes metadata = 7;
}

message ChaincodeID {
    string path = 1;
    string name = 2;
}

message ChaincodeInput {
    string function = 1;
    repeated string args  = 2;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <span style="font-weight:600">域的定义:</span></p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">chaincodeID</code>&nbsp;- 链码源码的路径和名字</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ctorMsg</code>&nbsp;- 调用的函数名及参数</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">timeout</code>&nbsp;- 执行交易所需的时间（以毫秒表示）</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">confidentialityLevel</code>&nbsp;- 这个交易的保密级别</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">secureContext</code>&nbsp;- 交易者的安全上下文</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">metadata</code>&nbsp;- 应用想要传递下去的任何数据</li>
  </ul> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 当 peer 收到<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">chaincodeSpec</code>后以合适的交易消息包装它并广播到网络</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3123-部署交易" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3123-部署交易" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.1.2.3 部署交易</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 部署交易的类型是<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAINCODE_DEPLOY</code>，且它的payload包含<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ChaincodeDeploymentSpec</code>对象。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message ChaincodeDeploymentSpec {
    ChaincodeSpec chaincodeSpec = 1;
    google.protobuf.Timestamp effectiveDate = 2;
    bytes codePackage = 3;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <span style="font-weight:600">域的定义:</span></p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">chaincodeSpec</code>&nbsp;- 参看上面的3.1.2.2节.</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">effectiveDate</code>&nbsp;- 链码准备好可被调用的时间</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">codePackage</code>&nbsp;- 链码源码的gzip</li>
  </ul> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 当验证 peer 部署链码时，它通常会校验<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">codePackage</code>的哈希来保证交易被部署到网络后没有被篡改。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3124-调用交易" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3124-调用交易" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.1.2.4 调用交易</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 调用交易的类型是<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAINCODE_DEPLOY</code>，且它的payload包含<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ChaincodeInvocationSpec</code>对象。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message ChaincodeInvocationSpec {
    ChaincodeSpec chaincodeSpec = 1;
}
</code></pre> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3125-查询交易" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3125-查询交易" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.1.2.5 查询交易</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 查询交易除了消息类型是<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAINCODE_QUERY</code>其它和调用交易一样</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-313-同步消息" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#313-同步消息" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.1.3 同步消息</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 同步协议以3.1.1节描述的，当 peer 知道它自己的区块落后于其它 peer 或和它们不一样后所发起的。peer 广播<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SYNC_GET_BLOCKS</code>，<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SYNC_STATE_GET_SNAPSHOT</code>或<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SYNC_STATE_GET_DELTAS</code>并分别接收<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SYNC_BLOCKS</code>,&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SYNC_STATE_SNAPSHOT</code>或<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SYNC_STATE_DELTAS</code>。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 安装的共识插件（如：pbft）决定同步协议是如何被应用的。每个小时是针对具体的状态来设计的：</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <span style="font-weight:600">SYNC_GET_BLOCKS</span>&nbsp;是一个<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SyncBlockRange</code>对象，包含一个连续区块的范围的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>的请求。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message SyncBlockRange {
    uint64 start = 1;
    uint64 end = 2;
    uint64 end = 3;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 接收peer使用包含&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SyncBlocks</code>对象的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SYNC_BLOCKS</code>信息来响应</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message SyncBlocks {
    SyncBlockRange range = 1;
    repeated Block blocks = 2;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">start</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">end</code>标识包含的区块的开始和结束，返回区块的顺序由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">start</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">end</code>的值定义。如：当<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">start</code>=3，<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">end</code>=5时区块的顺序将会是3，4，5。当<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">start</code>=5，<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">end</code>=3时区块的顺序将会是5，4，3。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <span style="font-weight:600">SYNC_STATE_GET_SNAPSHOT</span>&nbsp;请求当前世界状态的快照。&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>是一个<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SyncStateSnapshotRequest</code>对象</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message SyncStateSnapshotRequest {
  uint64 correlationId = 1;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">correlationId</code>是请求 peer 用来追踪响应消息的。接受 peer 回复<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>为<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SyncStateSnapshot</code>实例的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SYNC_STATE_SNAPSHOT</code>信息</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message SyncStateSnapshot {
    bytes delta = 1;
    uint64 sequence = 2;
    uint64 blockNumber = 3;
    SyncStateSnapshotRequest request = 4;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这条消息包含快照或以0开始的快照流序列中的一块。终止消息是len(delta) == 0的块</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <span style="font-weight:600">SYNC_STATE_GET_DELTAS</span>&nbsp;请求连续区块的状态变化。默认情况下总账维护500笔交易变化。 delta(j)是block(i)和block(j)之间的状态转变，其中i=j-1。&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>包含<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SyncStateDeltasRequest</code>实例</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message SyncStateDeltasRequest {
    SyncBlockRange range = 1;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 接收 peer 使用包含&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SyncStateDeltas</code>实例的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">SYNC_STATE_DELTAS</code>信息来响应</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message SyncStateDeltas {
    SyncBlockRange range = 1;
    repeated bytes deltas = 2;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> delta可能以顺序（从i到j）或倒序（从j到i）来表示状态转变</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-314-共识消息" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#314-共识消息" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.1.4 共识消息</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 共识处理交易，一个<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CONSENSUS</code>消息是由共识框架接收到<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAIN_TRANSACTION</code>消息时在内部初始化的。框架把<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CHAIN_TRANSACTION</code>转换为&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CONSENSUS</code>然后以相同的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>广播到验证 peer。共识插件接收这条消息并根据内部算法来处理。插件可能创建自定义的子类型来管理共识有穷状态机。3.4节会介绍详细信息。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-32-总账" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#32-总账" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.2 总账</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 总账由两个主要的部分组成，一个是区块链，一个是世界状态。区块链是在总账中的一系列连接好的用来记录交易的区块。世界状态是一个用来存储交易执行状态的键-值(key-value)数据库</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-321-区块链" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#321-区块链" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.2.1 区块链</h3> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3211-区块" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3211-区块" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.2.1.1 区块</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 区块链是由一个区块链表定义的，每个区块包含它在链中前一个区块的哈希。区块包含的另外两个重要信息是它包含区块执行所有交易后的交易列表和世界状态的哈希</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message Block {
  version = 1;
  google.protobuf.Timestamp timestamp = 2;
  bytes transactionsHash = 3;
  bytes stateHash = 4;
  bytes previousBlockHash = 5;
  bytes consensusMetadata = 6;
  NonHashData nonHashData = 7;
}

message BlockTransactions {
  repeated Transaction transactions = 1;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <span style="font-weight:600">域的定义:</span></p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">version</code>&nbsp;- 用来追踪协议变化的版本号</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">timestamp</code>&nbsp;- 由区块提议者填充的时间戳</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">transactionsHash</code>&nbsp;- 区块中交易的merkle root hash</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">stateHash</code>&nbsp;- 世界状态的merkle root hash</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">previousBlockHash</code>&nbsp;- 前一个区块的hash</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensusMetadata</code>&nbsp;- 共识可能会引入的一些可选的元数据</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">nonHashData</code>&nbsp;-&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">NonHashData</code>消息会在计算区块的哈希前设置为nil，但是在数据库中存储为区块的一部分</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">BlockTransactions.transactions</code>&nbsp;- 交易消息的数组，由于交易的大小，它们不会被直接包含在区块中</li>
  </ul> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3212-区块哈希" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3212-区块哈希" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.2.1.2 区块哈希</h4> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""> <p style="margin-top:16px; margin-bottom:16px"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">previousBlockHash</code>哈希是通过下面算法计算的</p> 
    <ol style="padding-left:2em; margin-top:0px; margin-bottom:0px; list-style-type:lower-roman"> 
     <li style=""> <p style="margin-top:16px; margin-bottom:16px">使用protocol buffer库把区块消息序列化为字节码</p> </li>
     <li style="margin-top:0.25em"> <p style="margin-top:16px; margin-bottom:16px">使用<a target="_blank" href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; background-color:transparent">FIPS 202</a>描述的SHA3 SHAKE256算法来对序列化后的区块消息计算大小为512位的哈希值</p> </li>
    </ol> </li>
   <li style="margin-top:0.25em"> <p style="margin-top:16px; margin-bottom:16px"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">transactionHash</code>是交易merkle树的根。定义merkle tree实现是一个代办</p> </li>
   <li style="margin-top:0.25em"> <p style="margin-top:16px; margin-bottom:16px"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">stateHash</code>在3.2.2.1节中定义.</p> </li>
  </ul> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3213-非散列数据nonhashdata" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3213-非散列数据nonhashdata" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.2.1.3 非散列数据(NonHashData)</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> NonHashData消息是用来存储不需要所有 peer 都具有相同值的块元数据。他们是建议值。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message NonHashData {
  google.protobuf.Timestamp localLedgerCommitTimestamp = 1;
  repeated TransactionResult transactionResults = 2;
}

message TransactionResult {
  string uuid = 1;
  bytes result = 2;
  uint32 errorCode = 3;
  string error = 4;
}
</code></pre> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""> <p style="margin-top:16px; margin-bottom:16px"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">localLedgerCommitTimestamp</code>&nbsp;- 标识区块提交到本地总账的时间戳</p> </li>
   <li style="margin-top:0.25em"> <p style="margin-top:16px; margin-bottom:16px"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">TransactionResult</code>&nbsp;- 交易结果的数组</p> </li>
   <li style="margin-top:0.25em"> <p style="margin-top:16px; margin-bottom:16px"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">TransactionResult.uuid</code>&nbsp;- 交易的ID</p> </li>
   <li style="margin-top:0.25em"> <p style="margin-top:16px; margin-bottom:16px"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">TransactionResult.result</code>&nbsp;- 交易的返回值</p> </li>
   <li style="margin-top:0.25em"> <p style="margin-top:16px; margin-bottom:16px"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">TransactionResult.errorCode</code>&nbsp;- 可以用来记录关联交易的错误信息的代码</p> </li>
   <li style="margin-top:0.25em"> <p style="margin-top:16px; margin-bottom:16px"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">TransactionResult.error</code>&nbsp;- 用来记录关联交易的错误信息的字符串</p> </li>
  </ul> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3214-交易执行" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3214-交易执行" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.2.1.4 交易执行</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 一个交易定义了它们部署或执行的链码。区块中的所有交易都可以在记录到总账中的区块之前运行。当链码执行时，他们可能会改变世界状态。之后世界状态的哈希会被记录在区块中。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-322-世界状态" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#322-世界状态" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.2.2 世界状态</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> peer 的<span style="">世界状态</span>涉及到所有被部署的链码的<span style="">状态</span>集合。进一步说，链码的状态由键值对集合来表示。所以，逻辑上说，peer 的世界状态也是键值对的集合，其中键有元组<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">{chaincodeID, ckey}</code>组成。这里我们使用术语<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">key</code>来标识世界状态的键，如：元组<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">{chaincodeID, ckey}</code>&nbsp;，而且我们使用<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">cKey</code>来标识链码中的唯一键。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 为了下面描述的目的，假定<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">chaincodeID</code>是有效的utf8字符串，且<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ckey</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">value</code>是一个或多个任意的字节的序列</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3221-世界状态的哈希" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3221-世界状态的哈希" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.2.2.1 世界状态的哈希</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 当网络活动时，很多像交易提交和同步 peer 这样的场合可能需要计算 peer 观察到的世界状态的加密-哈希。例如，共识协议可能需要保证网络中<span style="">最小</span>数量的 peer 观察到同样的世界状态。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 应为计算世界状态的加密-哈希是一个非常昂贵的操作，组织世界状态来使得当它改变时能高效效的计算加密-哈希是非常可取的。将来，可以根据不同的负载条件来设计不同的组织形式。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 由于fabric是被期望在不同的负载条件下都能正常工作，所以需要一个可拔插的机制来支持世界状态的组织。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-32211-bucket-tree" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#32211-bucket-tree" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.2.2.1.1 Bucket-tree</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <span style="">Bucket-tree</span>&nbsp;是世界状态的组织方式的实现。为了下面描述的目的，世界状态的键被表示成两个组件(<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">chaincodeID</code>&nbsp;and&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ckey</code>) 的通过nil字节的级联，如：<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">key</code>&nbsp;=&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">chaincodeID</code>+<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">nil</code>+<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">cKey</code>。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个方法的模型是一个<span style="">merkle-tree</span>在<span style="">hash table</span>桶的顶部来计算<span style="">世界状态</span>的加密-哈希</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个方法的核心是世界状态的<span style="">key-values</span>被假定存储在由预先决定的桶的数量(<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">numBuckets</code>)所组成的哈希表中。一个哈希函数(<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">hashFunction</code>) 被用来确定包含给定键的桶数量。注意<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">hashFunction</code>不代表SHA3这样的加密-哈希方法，而是决定给定的键的桶的数量的正规的编程语言散列函数。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 为了对 merkle-tree建模，有序桶扮演了树上的叶子节点-编号最低的桶是树中的最左边的叶子节点。为了构造树的最后第二层，叶子节点的预定义数量 (<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">maxGroupingAtEachLevel</code>)，从左边开始把每个这样的分组组合在一起，一个节点被当作组中所有叶子节点的共同父节点来插入到最后第二层中。注意最后的父节点的数量可能会少于<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">maxGroupingAtEachLevel</code>这个构造方式继续使用在更高的层级上直到树的根节点被构造。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 下面这个表展示的在<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">{numBuckets=10009 and maxGroupingAtEachLevel=10}</code>的配置下会得到的树在不同层级上的节点数。</p> 
  <table style="border-spacing:0px; border-collapse:collapse; margin-top:0px; margin-bottom:16px; display:block; width:888px; overflow:auto; word-break:keep-all; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <thead style=""> 
    <tr style="border-top-width:1px; border-top-style:solid; border-top-color:rgb(204,204,204)"> 
     <th style="padding:6px 13px; border:1px solid rgb(221,221,221)">Level</th> 
     <th align="center" style="padding:6px 13px; border:1px solid rgb(221,221,221)">Number of nodes</th> 
    </tr> 
   </thead> 
   <tbody style=""> 
    <tr style="border-top-width:1px; border-top-style:solid; border-top-color:rgb(204,204,204)"> 
     <td style="padding:6px 13px; border:1px solid rgb(221,221,221)">0</td> 
     <td align="center" style="padding:6px 13px; border:1px solid rgb(221,221,221)">1</td> 
    </tr> 
    <tr style="border-top-width:1px; border-top-style:solid; border-top-color:rgb(204,204,204); background-color:rgb(248,248,248)"> 
     <td style="padding:6px 13px; border:1px solid rgb(221,221,221)">1</td> 
     <td align="center" style="padding:6px 13px; border:1px solid rgb(221,221,221)">2</td> 
    </tr> 
    <tr style="border-top-width:1px; border-top-style:solid; border-top-color:rgb(204,204,204)"> 
     <td style="padding:6px 13px; border:1px solid rgb(221,221,221)">2</td> 
     <td align="center" style="padding:6px 13px; border:1px solid rgb(221,221,221)">11</td> 
    </tr> 
    <tr style="border-top-width:1px; border-top-style:solid; border-top-color:rgb(204,204,204); background-color:rgb(248,248,248)"> 
     <td style="padding:6px 13px; border:1px solid rgb(221,221,221)">3</td> 
     <td align="center" style="padding:6px 13px; border:1px solid rgb(221,221,221)">101</td> 
    </tr> 
    <tr style="border-top-width:1px; border-top-style:solid; border-top-color:rgb(204,204,204)"> 
     <td style="padding:6px 13px; border:1px solid rgb(221,221,221)">4</td> 
     <td align="center" style="padding:6px 13px; border:1px solid rgb(221,221,221)">1001</td> 
    </tr> 
    <tr style="border-top-width:1px; border-top-style:solid; border-top-color:rgb(204,204,204); background-color:rgb(248,248,248)"> 
     <td style="padding:6px 13px; border:1px solid rgb(221,221,221)">5</td> 
     <td align="center" style="padding:6px 13px; border:1px solid rgb(221,221,221)">10009</td> 
    </tr> 
   </tbody> 
  </table> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 为了计算世界状态的加密-哈希，需要计算每个桶的加密-哈希，并假设它们是merkle-tree的叶子节点的加密-哈希。为了计算桶的加密-哈希，存储在桶中的键值对首先被序列化为字节码并在其上应用加密-哈希函数。为了序列化桶的键值对，所有具有公共chaincodeID前缀的键值对分别序列化并以chaincodeID的升序的方式追加在一起。为了序列化一个chaincodeID的键值对，会涉及到下面的信息：</p> 
  <ol style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style="">chaincodeID的长度(chaincodeID的字节数)</li>
   <li style="margin-top:0.25em">chaincodeID的utf8字节码</li>
   <li style="margin-top:0.25em">chaincodeID的键值对数量</li>
   <li style="margin-top:0.25em">对于每个键值对(以ckey排序) 
    <ul style="padding-left:2em; margin-top:0px; margin-bottom:0px"> 
     <li style="">ckey的长度</li>
     <li style="margin-top:0.25em">ckey的字节码</li>
     <li style="margin-top:0.25em">值的长度</li>
     <li style="margin-top:0.25em">值的字节码</li>
    </ul> </li>
  </ol> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 对于上面列表的所有数值类型项（如：chaincodeID的长度），使用protobuf的变体编码方式。上面这种编码方式的目的是为了桶中的键值对的字节表示方式不会被任意其他键值对的组合所产生，并减少了序列化字节码的总体大小。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 例如：考虑具有<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">chaincodeID1_key1:value1, chaincodeID1_key2:value2, 和 chaincodeID2_key1:value1</code>这样名字的键值对的桶。序列化后的桶看上去会像：<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">12 + chaincodeID1 + 2 + 4 + key1 + 6 + value1 + 4 + key2 + 6 + value2 + 12 + chaincodeID2 + 1 + 4 + key1 + 6 + value1</code></p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 如果桶中没有键值对，那么加密-哈希为<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">nil</code>。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 中间节点和根节点的加密-哈希与标准merkle-tree的计算方法一样，即：应用加密-哈希函数到所有子节点的加密-哈希从左到右级联后得到的字节码。进一步说，如果一个子节点的加密-哈希为<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">nil</code>，那么这个子节点的加密-哈希在级联子节点的加密-哈希是就被省略。如果它只有一个子节点，那么它的加密-哈希就是子节点的加密-哈希。最后，根节点的加密-哈希就是世界状态的加密-哈希。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 上面这种方法在状态中少数键值对改变时计算加密-哈希是有性能优势的。主要的优势包括：</p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style="">那些没有变化的桶的计算会被跳过</li>
   <li style="margin-top:0.25em">merkle-tree的宽度和深度可以通过配置<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">numBuckets</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">maxGroupingAtEachLevel</code>参数来控制。树的不同深度和宽度对性能和不同的资源都会产生不同的影响。</li>
  </ul> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 在一个具体的部署中，所有的 peer 都期望使用相同的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">numBuckets, maxGroupingAtEachLevel, 和 hashFunction</code>的配置。进一步说，如果任何一个配置在之后的阶段被改变，那么这些改变需要应用到所有的 peer 中，来保证 peer 节点之间的加密-哈希的比较是有意义的。即使，这可能会导致基于实现的已有数据的迁移。例如：一种实现希望存储树中所有节点最后计算的加密-哈希，那么它就需要被重新计算。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-33-链码chaincode" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#33-链码chaincode" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.3 链码（Chaincode）</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 链码是在交易（参看3.1.2节）被部署是分发到网络上，并被所有验证 peer 通过隔离的沙箱来管理的应用级代码。尽管任意的虚拟技术都可以支持沙箱，现在是通过Docker容器来运行链码的。这节中描述的协议可以启用不同虚拟实现的插入与运行。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-331-虚拟机实例化" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#331-虚拟机实例化" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.3.1 虚拟机实例化</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 一个实现VM接口的虚拟机</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type VM interface {
    build(ctxt context.Context, id string, args []string, env []string, attachstdin bool, attachstdout bool, reader io.Reader) error
    start(ctxt context.Context, id string, args []string, env []string, attachstdin bool, attachstdout bool) error
    stop(ctxt context.Context, id string, timeout uint, dontkill bool, dontremove bool) error
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> fabric在处理链码上的部署交易或其他交易时，如果这个链码的VM未启动（崩溃或之前的不活动导致的关闭）时实例化VM。每个链码镜像通过<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">build</code>函数构建，通过<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">start</code>函数启动，并使用<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">stop</code>函数停止。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 一旦链码容器被启动，它使用gRPC来连接到启动这个链码的验证 peer，并为链码上的调用和查询交易建立通道。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-332-链码协议" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#332-链码协议" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.3.2 链码协议</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 验证 peer 和它的链码之间是通过gRPC流来通信的。链码容器上有shim层来处理链码与验证 peer 之间的protobuf消息协议。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message ChaincodeMessage {

    enum Type {
        UNDEFINED = 0;
        REGISTER = 1;
        REGISTERED = 2;
        INIT = 3;
        READY = 4;
        TRANSACTION = 5;
        COMPLETED = 6;
        ERROR = 7;
        GET_STATE = 8;
        PUT_STATE = 9;
        DEL_STATE = 10;
        INVOKE_CHAINCODE = 11;
        INVOKE_QUERY = 12;
        RESPONSE = 13;
        QUERY = 14;
        QUERY_COMPLETED = 15;
        QUERY_ERROR = 16;
        RANGE_QUERY_STATE = 17;
    }

    Type type = 1;
    google.protobuf.Timestamp timestamp = 2;
    bytes payload = 3;
    string uuid = 4;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <span style="font-weight:600">域的定义:</span></p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Type</code>&nbsp;是消息的类型</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>&nbsp;是消息的payload. 每个payload取决于<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Type</code>.</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">uuid</code>&nbsp;消息唯一的ID</li>
  </ul> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 消息的类型在下面的小节中描述</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 链码实现被验证 peer 在处理部署，调用或查询交易时调用的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Chaincode</code>接口</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type Chaincode interface {
    Invoke(stub *ChaincodeStub, function string, args []string) (error)
    Query(stub *ChaincodeStub, function string, args []string) ([]byte, error)
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Init</code>,&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Invoke</code>&nbsp;和&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Query</code>函数使用<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">function</code>&nbsp;and&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">args</code>参数来支持多种交易。<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Init</code>是构造函数，它只在部署交易是被执行。<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Query</code>函数是不允许修改链码的状态的；它只能读取和计算并以byte数组的形式返回。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3321-链码部署" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3321-链码部署" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.3.2.1 链码部署</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 当部署时（链码容器已经启动），shim层发送一次性的具有包含<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ChaincodeID</code>的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">REGISTER</code>消息给验证 peer。然后 peer 以<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">REGISTERED</code>或<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ERROR</code>来响应成功或失败。当收到<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ERROR</code>后shim关闭连接并退出。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 注册之后，验证 peer 发送具有包含<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ChaincodeInput</code>对象的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">INIT</code>消息。shim使用从<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ChaincodeInput</code>获得的参数来调用<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Init</code>函数，通过像设置持久化状态这样操作来初始化链码。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> shim根据<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Init</code>函数的返回值，响应<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">RESPONSE</code>或<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ERROR</code>消息。如果没有错误，那么链码初始化完成，并准备好接收调用和查询交易。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3322-链码调用" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3322-链码调用" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.3.2.2 链码调用</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 当处理调用交易时，验证 peer 发送<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">TRANSACTION</code>消息给链码容器的shim，由它来调用链码的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Invoke</code>函数，并传递从<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ChaincodeInput</code>得到的参数。shim响应<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">RESPONSE</code>或<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ERROR</code>消息来表示函数完成。如果接收到<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ERROR</code>函数，<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>包含链码所产生的错误信息。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3323-来代码查询" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3323-来代码查询" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.3.2.3 来代码查询</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 与调用交易一样，验证 peer 发送<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">QUERY</code>消息给链码容器的shim，由它来调用链码的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Query</code>函数，并传递从<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ChaincodeInput</code>得到的参数。<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Query</code>函数可能会返回状态值或错误，它会把它通过<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">RESPONSE</code>或<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ERROR</code>消息来传递给验证 peer。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3324-链码状态" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3324-链码状态" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.3.2.4 链码状态</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 每个链码可能都定义了它自己的持久化状态变量。例如，一个链码可能创建电视，汽车或股票这样的资产来保存资产属性。当<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Invoke</code>函数处理时，链码可能会更新状态变量，例如改变资产所有者。链码会根据下面这些消息类型类操作状态变量：</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-put_state" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#put_state" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>PUT_STATE</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 链码发送一个<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>包含<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">PutStateInfo</code>对象的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">PU_STATE</code>消息来保存键值对。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message PutStateInfo {
    string key = 1;
    bytes value = 2;
}
</code></pre> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-get_state" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#get_state" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>GET_STATE</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 链码发送一个由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>指定要获取值的键的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">GET_STATE</code>消息。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-del_state" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#del_state" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>DEL_STATE</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 链码发送一个由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>指定要删除值的键的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">DEL_STATE</code>消息。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-range_query_state" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#range_query_state" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>RANGE_QUERY_STATE</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 链码发送一个<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>包含<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">RANGE_QUERY_STATE</code>对象的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">RANGE_QUERY_STATE</code>来获取一个范围内的值。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message RangeQueryState {
    string startKey = 1;
    string endKey = 2;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">startKey</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">endKey</code>假设是通过字典排序的. 验证 peer 响应一个<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>是<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">RangeQueryStateResponse</code>对象的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">RESPONSE</code>消息</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message RangeQueryStateResponse {
    repeated RangeQueryStateKeyValue keysAndValues = 1;
    bool hasMore = 2;
    string ID = 3;
}
message RangeQueryStateKeyValue {
    string key = 1;
    bytes value = 2;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 如果相应中<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">hasMore=true</code>，这表示有在请求的返回中还有另外的键。链码可以通过发送包含与响应中ID相同的ID的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">RangeQueryStateNext</code>消息来获取下一集合。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message RangeQueryStateNext {
    string ID = 1;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 当链码结束读取范围，它会发送带有ID的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">RangeQueryStateClose</code>消息来期望它关闭。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message RangeQueryStateClose {
  string ID = 1;
}
</code></pre> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-invoke_chaincode" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#invoke_chaincode" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>INVOKE_CHAINCODE</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 链码可以通过发送<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>包含&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ChaincodeSpec</code>对象的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">INVOKE_CHAINCODE</code>消息给验证 peer 来在相同的交易上下文中调用另一个链码</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-query_chaincode" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#query_chaincode" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>QUERY_CHAINCODE</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 链码可以通过发送<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>包含&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ChaincodeSpec</code>对象的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">QUERY_CHAINCODE</code>消息给验证 peer 来在相同的交易上下文中查询另一个链码</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-34-插拔式共识框架" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#34-插拔式共识框架" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4 插拔式共识框架</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 共识框架定义了每个共识插件都需要实现的接口：</p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.Consenter</code>: 允许共识插件从网络上接收消息的接口</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.CPI</code>: 共识编程接口<span style="">Consensus Programming Interface</span>&nbsp;(<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CPI</code>) 是共识插件用来与栈交互的，这个接口可以分为两部分： 
    <ul style="padding-left:2em; margin-top:0px; margin-bottom:0px"> 
     <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.Communicator</code>: 用来发送（广播或单播）消息到其他的验证 peer</li>
     <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.LedgerStack</code>: 这个接口使得执行框架像总账一样方便</li>
    </ul> </li>
  </ul> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 就像下面描述的细节一样，<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.LedgerStack</code>封装了其他接口，<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.Executor</code>接口是共识框架的核心部分。换句话说，<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.Executor</code>接口允许一个（批量）交易启动，执行，根据需要回滚，预览和提交。每一个共识插件都需要满足以所有验证 peer 上全序的方式把批量（块）交易（通过<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.Executor.CommitTxBatch</code>）被提交到总账中（参看下面的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.Executor</code>接口获得详细细节）。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 当前，共识框架由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus</code>,&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">controller</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper</code>这三个包组成。使用<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">controller</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper</code>包的主要原因是防止Go语言的“循环引入”和当插件更新时的最小化代码变化。</p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">controller</code>&nbsp;包规范了验证 peer 所使用的共识插件</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper</code>&nbsp;是围绕公式插件的垫片，它是用来与剩下的栈交互的，如为其他 peer 维护消息。</li>
  </ul> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这里有2个共识插件提供：<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">pbft</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">noops</code>：</p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">obcpbft</code>包包含实现&nbsp;<span style="">PBFT</span>&nbsp;[1] 和&nbsp;<span style="">Sieve</span>&nbsp;共识协议的共识插件。参看第5节的详细介绍</li>
   <li style="margin-top:0.25em"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">noops</code>&nbsp;是一个为开发和测试提供的''假的''共识插件. 它处理所有共识消息但不提供共识功能，它也是一个好的学习如何开发一个共识插件的简单例子。</li>
  </ul> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-341-consenter-接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#341-consenter-接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.1&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">Consenter</code>&nbsp;接口</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义:</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type Consenter interface {
    RecvMsg(msg *pb.Message) error
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Consenter</code>接口是插件对（外部的）客户端请求的入口，当处理共识时，共识消息在内部（如从共识模块）产生。NewConsenter<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">创建</code>Consenter<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">插件。</code>RecvMsg`以到达共识的顺序来处理进来的交易。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 阅读下面的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.HandleMessage</code>来理解 peer 是如何和这个接口来交互的。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-342-cpi接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#342-cpi接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.2&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">CPI</code>接口</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义:</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type CPI interface {
    Inquirer
    Communicator
    SecurityUtils
    LedgerStack
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CPI</code>&nbsp;允许插件和栈交互。它是由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.Helper</code>对象实现的。回想一下这个对象是：</p> 
  <ol style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style="">在<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.NewConsensusHandler</code>被调用时初始化的</li>
   <li style="margin-top:0.25em">当它们的插件构造了<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.Consenter</code>对象，那么它对插件的作者是可访问的</li>
  </ol> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-343-inquirer接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#343-inquirer接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.3&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">Inquirer</code>接口</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义:</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type Inquirer interface {
        GetNetworkInfo() (self *pb.PeerEndpoint, network []*pb.PeerEndpoint, err error)
        GetNetworkHandles() (self *pb.PeerID, network []*pb.PeerID, err error)
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个接口是<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.CPI</code>接口的一部分。它是用来获取网络中验证 peer 的（<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">GetNetworkHandles</code>）处理，以及那些验证 peer 的明细(<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">GetNetworkInfo</code>)：</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 注意pees由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">pb.PeerID</code>对象确定。这是一个protobuf消息，当前定义为（注意这个定义很可能会被修改）：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message PeerID {
    string name = 1;
}
</code></pre> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-344-communicator接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#344-communicator接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.4&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">Communicator</code>接口</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义:</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type Communicator interface {
    Broadcast(msg *pb.Message) error
    Unicast(msg *pb.Message, receiverHandle *pb.PeerID) error
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个接口是<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.CPI</code>接口的一部分。它是用来与网络上其它 peer 通信的（<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.Broadcast</code>,&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.Unicast</code>）：</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-345-securityutils接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#345-securityutils接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.5&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">SecurityUtils</code>接口</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义:</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type SecurityUtils interface {
        Sign(msg []byte) ([]byte, error)
        Verify(peerID *pb.PeerID, signature []byte, message []byte) error
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个接口是<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.CPI</code>接口的一部分。它用来处理消息签名(<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Sign</code>)的加密操作和验证签名(<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Verify</code>)</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-346-ledgerstack-接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#346-ledgerstack-接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.6&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">LedgerStack</code>&nbsp;接口</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义:</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type LedgerStack interface {
    Executor
    Ledger
    RemoteLedgers
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CPI</code>接口的主要成员，<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">LedgerStack</code>&nbsp;组与fabric的其它部分与共识相互作用，如执行交易，查询和更新总账。这个接口支持对本地区块链和状体的查询，更新本地区块链和状态，查询共识网络上其它节点的区块链和状态。它是有<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Executor</code>,<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Ledger</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">RemoteLedgers</code>这三个接口组成的。下面会描述它们。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-347-executor-接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#347-executor-接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.7&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">Executor</code>&nbsp;接口</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义:</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type Executor interface {
    BeginTxBatch(id interface{}) error
    ExecTXs(id interface{}, txs []*pb.Transaction) ([]byte, []error)  
    CommitTxBatch(id interface{}, transactions []*pb.Transaction, transactionsResults []*pb.TransactionResult, metadata []byte) error  
    RollbackTxBatch(id interface{}) error  
    PreviewCommitTxBatchBlock(id interface{}, transactions []*pb.Transaction, metadata []byte) (*pb.Block, error)  
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> executor接口是<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">LedgerStack</code>接口最常使用的部分，且是共识网络工作的必要部分。接口允许交易启动，执行，根据需要回滚，预览和提交。这个接口由下面这些方法组成。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3471-开始批量交易" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3471-开始批量交易" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.7.1 开始批量交易</h4> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">BeginTxBatch(id interface{}) error
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个调用接受任意的，故意含糊的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">id</code>，来使得共识插件可以保证与这个具体的批量相关的交易才会被执行。例如：在pbft实现中，这个<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">id</code>是被执行交易的编码过的哈希。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3472-执行交易" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3472-执行交易" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.7.2 执行交易</h4> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">ExecTXs(id interface{}, txs []*pb.Transaction) ([]byte, []error)
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个调用根据总账当前的状态接受一组交易，并返回带有对应着交易组的错误信息组的当前状态的哈希。注意一个交易所产生的错误不影响批量交易的安全提交。当遇到失败所采用的策略取决与共识插件的实现。这个接口调用多次是安全的。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3473-提交与回滚交易" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3473-提交与回滚交易" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.7.3 提交与回滚交易</h4> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">RollbackTxBatch(id interface{}) error
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个调用忽略了批量执行。这会废弃掉对当前状态的操作，并把总账状态回归到之前的状态。批量是从<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">BeginBatchTx</code>开始的，如果需要开始一个新的就需要在执行任意交易之前重新创建一个。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">PreviewCommitTxBatchBlock(id interface{}, transactions []*pb.Transaction, metadata []byte) (*pb.Block, error)
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个调用是共识插件对非确定性交易执行的测试时最有用的方法。区块返回的哈希表部分会保证，当<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CommitTxBatch</code>被立即调用时的区块是同一个。这个保证会被任意新的交易的执行所打破。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">CommitTxBatch(id interface{}, transactions []*pb.Transaction, transactionsResults []*pb.TransactionResult, metadata []byte) error
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个调用提交区块到区块链中。区块必须以全序提交到区块链中，<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">CommitTxBatch</code>结束批量交易，在执行或提交任意的交易之前必须先调用<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">BeginTxBatch</code>。</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-348-ledger-接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#348-ledger-接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.8&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">Ledger</code>&nbsp;接口</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type Ledger interface {
    ReadOnlyLedger
    UtilLedger
    WritableLedger
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Ledger</code>&nbsp;接口是为了允许共识插件询问或可能改变区块链当前状态。它是由下面描述的三个接口组成的</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3481-readonlyledger-接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3481-readonlyledger-接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.8.1&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">ReadOnlyLedger</code>&nbsp;接口</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type ReadOnlyLedger interface {
    GetBlock(id uint64) (block *pb.Block, err error)
    GetCurrentStateHash() (stateHash []byte, err error)
    GetBlockchainSize() (uint64, error)
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">ReadOnlyLedger</code>&nbsp;接口是为了查询总账的本地备份，而不会修改它。它是由下面这些函数组成的。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">GetBlockchainSize() (uint64, error)
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个函数返回区块链总账的长度。一般来说，这个函数永远不会失败，在这种不太可能发生情况下，错误被传递给调用者，由它确定是否需要恢复。具有最大区块值的区块的值为<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">GetBlockchainSize()-1</code></p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 注意在区块链总账的本地副本是腐坏或不完整的情况下，这个调用会返回链中最大的区块值+1。这允许节点在旧的块是腐坏或丢失的情况下能继续操作当前状态/块。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">GetBlock(id uint64) (block *pb.Block, err error)
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个调用返回区块链中块的数值<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">id</code>。一般来说这个调用是不会失败的，除非请求的区块超出当前区块链的长度，或者底层的区块链被腐坏了。<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">GetBlock</code>的失败可能可以通过状态转换机制来取回它。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">GetCurrentStateHash() (stateHash []byte, err error)
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个盗用返回总账的当前状态的哈希。一般来说，这个函数永远不会失败，在这种不太可能发生情况下，错误被传递给调用者，由它确定是否需要恢复。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3482-utilledger-接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3482-utilledger-接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.8.2&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">UtilLedger</code>&nbsp;接口</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type UtilLedger interface {
    HashBlock(block *pb.Block) ([]byte, error)
    VerifyBlockchain(start, finish uint64) (uint64, error)
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">UtilLedger</code>&nbsp;接口定义了一些由本地总账提供的有用的功能。使用mock接口来重载这些功能在测试时非常有用。这个接口由两个函数构成。 会会</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">HashBlock(block *pb.Block) ([]byte, error)
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 尽管<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">*pb.Block</code>定义了<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">GetHash</code>方法，为了mock测试，重载这个方法会非常有用。因此，建议<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">GetHash</code>方法不直接调用，而是通过<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">UtilLedger.HashBlock</code>接口来调用这个方法。一般来说，这个函数永远不会失败，但是错误还是会传递给调用者，让它决定是否使用适当的恢复。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">VerifyBlockchain(start, finish uint64) (uint64, error)
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个方法是用来校验区块链中的大的区域。它会从高的块<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">start</code>到低的块<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">finish</code>，返回第一个块的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">PreviousBlockHash</code>与块的前一个块的哈希不相符的块编号以及错误信息。注意，它一般会标识最后一个好的块的编号，而不是第一个坏的块的编号。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3483-writableledger-接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3483-writableledger-接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.8.3&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">WritableLedger</code>&nbsp;接口</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type WritableLedger interface {
    PutBlock(blockNumber uint64, block *pb.Block) error
    ApplyStateDelta(id interface{}, delta *statemgmt.StateDelta) error
    CommitStateDelta(id interface{}) error
    RollbackStateDelta(id interface{}) error
    EmptyState() error
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">WritableLedger</code>&nbsp;接口允许调用者更新区块链。注意这<span style="">NOT&nbsp;不是</span>共识插件的通常用法。当前的状态需要通过<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Executor</code>接口执行交易来修改，新的区块在交易提交时生成。相反的，这个接口主要是用来状态改变和腐化恢复。特别的，这个接口下的函数<span style="">永远</span>不能直接暴露给共识消息，这样会导致打破区块链所承诺的不可修改这一概念。这个结构包含下面这些函数。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> -&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">&nbsp;PutBlock(blockNumber uint64, block *pb.Block) error&nbsp;</code>&nbsp;这个函数根据给定的区块编号把底层区块插入到区块链中。注意这是一个不安全的接口，所以它不会有错误返回或返回。插入一个比当前区块高度更高的区块是被允许的，通用，重写一个已经提交的区块也是被允许的。记住，由于哈希技术使得创建一个链上的更早的块是不可行的，所以这并不影响链的可审计性和不可变性。任何尝试重写区块链的历史的操作都能很容易的被侦测到。这个函数一般只用于状态转移API。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> -&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">&nbsp;ApplyStateDelta(id interface{}, delta *statemgmt.StateDelta) error&nbsp;</code></p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">这个函数接收状态变化，并把它应用到当前的状态。变化量的应用会使得状态向前或向后转变，这取决于状态变化量的构造，与`Executor`方法一样，`ApplyStateDelta`接受一个同样会被传递给`CommitStateDelta` or `RollbackStateDelta`不透明的接口`id`
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> -&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">&nbsp;CommitStateDelta(id interface{}) error&nbsp;</code></p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">这个方法提交在`ApplyStateDelta`中应用的状态变化。这通常是在调用者调用`ApplyStateDelta`后通过校验由`GetCurrentStateHash()`获得的状态哈希之后调用的。这个函数接受与传递给`ApplyStateDelta`一样的`id`。
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> -&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">&nbsp;RollbackStateDelta(id interface{}) error&nbsp;</code></p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">这个函数撤销在`ApplyStateDelta`中应用的状态变化量。这通常是在调用者调用`ApplyStateDelta`后与由`GetCurrentStateHash()`获得的状态哈希校验失败后调用的。这个函数接受与传递给`ApplyStateDelta`一样的`id`。
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> -&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">&nbsp;EmptyState() error&nbsp;</code></p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">这个函数将会删除整个当前状态，得到原始的空状态。这通常是通过变化量加载整个新的状态时调用的。这一样只对状态转移API有用。
</code></pre> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-349-remoteledgers-接口" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#349-remoteledgers-接口" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.9&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">RemoteLedgers</code>&nbsp;接口</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type RemoteLedgers interface {
    GetRemoteBlocks(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncBlocks, error)
    GetRemoteStateSnapshot(peerID uint64) (&lt;-chan *pb.SyncStateSnapshot, error)
    GetRemoteStateDeltas(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncStateDeltas, error)
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">RemoteLedgers</code>&nbsp;接口的存在主要是为了启用状态转移，和向其它副本询问区块链的状态。和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">WritableLedger</code>接口一样，这不是给正常的操作使用，而是为追赶，错误恢复等操作而设计的。这个接口中的所有函数调用这都有责任来处理超时。这个接口包含下面这些函数：</p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style=""> <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">GetRemoteBlocks(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncBlocks, error)
</code></pre> <p style="margin-top:16px; margin-bottom:16px">这个函数尝试从由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">peerID</code>指定的 peer 中取出由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">start</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">finish</code>标识的范围中的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">*pb.SyncBlocks</code>流。一般情况下，由于区块链必须是从结束到开始这样的顺序来验证的，所以<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">start</code>是比<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">finish</code>更高的块编号。由于慢速的结构，其它请求的返回可能出现在这个通道中，所以调用者必须验证返回的是期望的块。第二次以同样的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">peerID</code>来调用这个方法会导致第一次的通道关闭。</p> </li>
   <li style="margin-top:0.25em"> <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">GetRemoteStateSnapshot(peerID uint64) (&lt;-chan *pb.SyncStateSnapshot, error)
</code></pre> <p style="margin-top:16px; margin-bottom:16px">这个函数尝试从由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">peerID</code>指定的 peer 中取出<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">*pb.SyncStateSnapshot</code>流。为了应用结果，首先需要通过<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">WritableLedger</code>的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">EmptyState</code>调用来清空存在在状态，然后顺序应用包含在流中的变化量。</p> <h2 style="margin-top:24px; margin-bottom:16px; line-height:1.25; padding-bottom:0.3em; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(238,238,238)"> </h2> <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">  GetRemoteStateDeltas(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncStateDeltas, error)
</code></pre> <p style="margin-top:16px; margin-bottom:16px">这个函数尝试从由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">peerID</code>指定的 peer 中取出由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">start</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">finish</code>标识的范围中的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">*pb.SyncStateDeltas</code>流。由于慢速的结构，其它请求的返回可能出现在这个通道中，所以调用者必须验证返回的是期望的块变化量。第二次以同样的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">peerID</code>来调用这个方法会导致第一次的通道关闭。</p> </li>
  </ul> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3410-controller包" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3410-controller包" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.10&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">controller</code>包</h3> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-34101-controllernewconsenter" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#34101-controllernewconsenter" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.10.1 controller.NewConsenter</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 签名:</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">func NewConsenter(cpi consensus.CPI) (consenter consensus.Consenter)
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个函数读取为<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">peer</code>过程指定的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">core.yaml</code>配置文件中的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">peer.validator.consensus</code>的值。键<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">peer.validator.consensus</code>的有效值指定运行<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">noops</code>还是<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">obcpbft</code>共识。（注意，它最终被改变为<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">noops</code>或<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">custom</code>。在<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">custom</code>情况下，验证 peer 将会运行由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus/config.yaml</code>中定义的共识插件）</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 插件的作者需要编辑函数体，来保证路由到它们包中正确的构造函数。例如，对于<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">obcpbft</code>&nbsp;我们指向<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">obcpft.GetPlugin</code>构造器。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个函数是当设置返回信息处理器的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consenter</code>域时，被<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.NewConsensusHandler</code>调用的。输入参数<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">cpi</code>是由<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.NewHelper</code>构造器输出的，并实现了<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.CPI</code>接口</p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3411-helper包" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3411-helper包" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.11&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:undefined; padding:0.2em 0px; margin:0px">helper</code>包</h3> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-34111-高层次概述" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#34111-高层次概述" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.11.1 高层次概述</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 验证 peer 通过<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.NewConsesusHandler</code>函数(一个处理器工厂)，为每个连接的 peer 建立消息处理器(<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.ConsensusHandler</code>)。每个进来的消息都会检查它的类型(<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.HandleMessage</code>)；如果这是为了共识必须到达的消息，它会传递到 peer 的共识对象(<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.Consenter</code>)。其它的信息会传递到栈中的下一个信息处理器。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-34112-helperconsensushandler" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#34112-helperconsensushandler" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.11.2 helper.ConsensusHandler</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type ConsensusHandler struct {
    chatStream  peer.ChatStream
    consenter   consensus.Consenter
    coordinator peer.MessageHandlerCoordinator
    done        chan struct{}
    peerHandler peer.MessageHandler
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 共识中的上下文，我们只关注域<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">coordinator</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consenter</code>。<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">coordinator</code>就像名字隐含的那样，它被用来在 peer 的信息处理器之间做协调。例如，当 peer 希望<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Broadcast</code>时，对象被访问。共识需要到达的共识者会接收到消息并处理它们。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 注意，<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">fabric/peer/peer.go</code>定义了<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">peer.MessageHandler</code>&nbsp;(接口)，和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">peer.MessageHandlerCoordinator</code>（接口）类型。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-34113-helpernewconsensushandler" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#34113-helpernewconsensushandler" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.11.3 helper.NewConsensusHandler</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 签名:</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">func NewConsensusHandler(coord peer.MessageHandlerCoordinator, stream peer.ChatStream, initiatedStream bool, next peer.MessageHandler) (peer.MessageHandler, error)
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 创建一个<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.ConsensusHandler</code>对象。为每个<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">coordinator</code>设置同样的消息处理器。同时把<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consenter</code>设置为<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">controller.NewConsenter(NewHelper(coord))</code></p> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-34114-helperhelper" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#34114-helperhelper" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.11.4 helper.Helper</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 定义:</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type Helper struct {
    coordinator peer.MessageHandlerCoordinator
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 包含验证peer的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">coordinator</code>的引用。对象是否为peer实现了<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.CPI</code>接口。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-34115-helpernewhelper" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#34115-helpernewhelper" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.11.5 helper.NewHelper</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 签名:</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">func NewHelper(mhc peer.MessageHandlerCoordinator) consensus.CPI
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 返回<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">coordinator</code>被设置为输入参数<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">mhc</code>（<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.ConsensusHandler</code>消息处理器的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">coordinator</code>域）的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.Helper</code>对象。这个对象实现了<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consensus.CPI</code>接口，从而允许插件与栈进行交互。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-34116-helperhandlemessage" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#34116-helperhandlemessage" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.4.11.6 helper.HandleMessage</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 回忆一下，<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.NewConsensusHandler</code>返回的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.ConsesusHandler</code>对象实现了&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">peer.MessageHandler</code>&nbsp;接口：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">type MessageHandler interface {
    RemoteLedger
    HandleMessage(msg *pb.Message) error
    SendMessage(msg *pb.Message) error
    To() (pb.PeerEndpoint, error)
    Stop() error
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 在共识的上下文中，我们只关心<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">HandleMessage</code>方法。签名：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">func (handler *ConsensusHandler) HandleMessage(msg *pb.Message) error
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这个函数检查进来的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Message</code>的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Type</code>。有四种情况：</p> 
  <ol style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style="">等于<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">pb.Message_CONSENSUS</code>：传递给处理器的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consenter.RecvMsg</code>函数。</li>
   <li style="margin-top:0.25em">等于<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">pb.Message_CHAIN_TRANSACTION</code>&nbsp;(如：一个外部部署的请求): 一个响应请求首先被发送给用户，然后把消息传递给<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">consenter.RecvMsg</code>函数</li>
   <li style="margin-top:0.25em">等于<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">pb.Message_CHAIN_QUERY</code>&nbsp;(如：查询): 传递给<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">helper.doChainQuery</code>方法来在本地执行</li>
   <li style="margin-top:0.25em">其它: 传递给栈中下一个处理器的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">HandleMessage</code>方法</li>
  </ol> 
  <h3 style="margin-top:24px; margin-bottom:16px; font-size:1.25em; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-35-事件" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#35-事件" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.5 事件</h3> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 事件框架提供了生产和消费预定义或自定义的事件的能力。它有3个基础组件：</p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style="">事件流</li>
   <li style="margin-top:0.25em">事件适配器</li>
   <li style="margin-top:0.25em">事件结构</li>
  </ul> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-351-事件流" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#351-事件流" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.5.1 事件流</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 事件流是用来发送和接收事件的gRPC通道。每个消费者会与事件框架建立事件流，并快速传递它感兴趣的事件。事件生成者通过事件流只发送合适的事件给连接到生产者的消费者。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 事件流初始化缓冲和超时参数。缓冲保存着几个等待投递的事件，超时参数在缓冲满时有三个选项：</p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style="">如果超时小于0，丢弃新到来的事件</li>
   <li style="margin-top:0.25em">如果超时等于0，阻塞事件知道缓冲再次可用</li>
   <li style="margin-top:0.25em">如果超时大于0，等待指定的超时时间，如果缓冲还是满的话就丢弃事件</li>
  </ul> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3511-事件生产者" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3511-事件生产者" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.5.1.1 事件生产者</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 事件生产者暴露函数<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Send(e *pb.Event)</code>来发送事件，其中<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Event</code>可以是预定义的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Block</code>或<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Generic</code>事件。将来会定义更多的事件来包括其它的fabric元素。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">message Generic {
    string eventType = 1;
    bytes payload = 2;
}
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> <code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">eventType</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>是由事件生产者任意定义的。例如，JSON数据可能被用在<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">payload</code>中。链码或插件发出<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Generic</code>事件来与消费者通讯。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-3512-事件消费者" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#3512-事件消费者" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.5.1.2 事件消费者</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 事件消费者允许外部应用监听事件。每个事件消费者通过时间流注册事件适配器。消费者框架可以看成是事件流与适配器之间的桥梁。一种典型的事件消费者使用方式：</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">adapter = &lt;adapter supplied by the client application to register and receive events&gt;
consumerClient = NewEventsClient(&lt;event consumer address&gt;, adapter)
consumerClient.Start()
...
...
consumerClient.Stop()
</code></pre> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-352-事件适配器" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#352-事件适配器" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.5.2 事件适配器</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 事件适配器封装了三种流交互的切面：</p> 
  <ul style="padding-left:2em; margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 
   <li style="">返回所有感兴趣的事件列表的接口</li>
   <li style="margin-top:0.25em">当事件消费者框架接受到事件后调用的接口</li>
   <li style="margin-top:0.25em">当事件总线终止时，事件消费者框架会调用的接口</li>
  </ul> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 引用的实现提供了Golang指定语言绑定</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">      EventAdapter interface {
         GetInterestedEvents() ([]*ehpb.Interest, error)
         Recv(msg *ehpb.Event) (bool,error)
         Disconnected(err error)
      }
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 把gRPC当成事件总线协议来使用，允许事件消费者框架对于不同的语言的绑定可移植而不影响事件生成者框架。</p> 
  <h4 style="margin-top:24px; margin-bottom:16px; font-size:16px; line-height:1.25; color:rgb(51,51,51)"> <a target="_blank" id="user-content-353-事件框架" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#353-事件框架" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a>3.5.3 事件框架</h4> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 这节详细描述了事件系统的消息结构。为了简单起见，消息直接使用Golang描述。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 事件消费者和生产者之间通信的核心消息是事件。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">    message Event {
        oneof Event {
            //consumer events
            Register register = 1;

            //producer events
            Block block = 2;
            Generic generic = 3;
       }
    }
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 每一个上面的定义必须是<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Register</code>,&nbsp;<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Block</code>或<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Generic</code>中的一种。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 就像之前提到过的一样，消费者通过与生产者建立连接来创建事件总线，并发送<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Register</code>事件。<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Register</code>事件实质上是一组声明消费者感兴趣的事件的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Interest</code>消息。</p> 
  <pre style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; margin-top:0px; margin-bottom:16px; line-height:1.45; word-wrap:normal; padding:16px; overflow:auto; color:rgb(51,51,51); background-color:rgb(247,247,247)"><code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0px; margin:0px; word-break:normal; border:0px; display:inline; overflow:visible; line-height:inherit; word-wrap:normal; background:transparent">    message Interest {
        enum ResponseType {
            //don't send events (used to cancel interest)
            DONTSEND = 0;
            //send protobuf objects
            PROTOBUF = 1;
            //marshall into JSON structure
            JSON = 2;
        }
        string eventType = 1;
        ResponseType responseType = 2;
    }
</code></pre> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 事件可以通过protobuf结构直接发送，也可以通过指定适当的<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">responseType</code>来发送JSON结构。</p> 
  <p style="margin-top:0px; margin-bottom:16px; color:rgb(51,51,51); font-size:16px; line-height:24px"> 当前，生产者框架可以生成<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Block</code>和<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Generic</code>事件。<code style="font-family:Consolas,'Liberation Mono',Menlo,Courier,monospace; font-size:13.6px; padding:0.2em 0px; margin:0px">Block</code>是用来封装区块链中区块属性的消息。</p> 
  <div>
   <br> 
  </div> 
  <h2 style="margin-top:24px; margin-bottom:16px; line-height:1.25; padding-bottom:0.3em; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(238,238,238); color:rgb(51,51,51)"> <a target="_blank" id="user-content-4-安全-1" class="anchor" href="https://github.com/hyperledger/fabric/blob/49538bbc631459ddbf35e61562542600460d745e/docs/protocol-spec_zh.md#4-安全-1" rel="nofollow" style="color:rgb(64,120,192); text-decoration:none; float:left; padding-right:4px; margin-left:-20px; line-height:1; background-color:transparent"></a></h2> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jason_wang1989/article/details/52160154,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jason_wang1989/article/details/52160154,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
