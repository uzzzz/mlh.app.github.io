<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>《Nodejs开发加密货币》之二十一：交易 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="《Nodejs开发加密货币》之二十一：交易" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="题外话：这篇文章，耗费了我大量精力，用UML表达javascript类及流程本来就不是什么容易的事情，用来描述加密货币交易这种验证逻辑非常多的代码更难，加之Nodejs的回调在这些代码里嵌套很深，所以如何把异步调用变成人类容易理解的顺序调用，也做了一番取舍，时间不知不觉就过了一星期。 所幸，赶在比特币减半的今天完成并发布这篇文章，也算在区块链火热的今天，《Nodejs开发加密货币》走到了一个关键节点：触及了加密货币的灵魂和腹地。动辄几千一枚的比特币等加密货币可能会消亡，但是背后的技术却蓬勃发展，玩技术的要善于把握先机，抢占技术高点，让自己时刻成为稀缺的资源，自身价值才能一路高升。 本书是市面上唯一一本讲解Nodejs开发加密货币的实践书籍，与那些纯粹为了举例而提供的代码示例不同，全书代码，哪怕是前端代码实例，都是来自正在运行的真实项目，所以无论您是学习Nodejs技术找寻实践项目，还是学习前端设计、web开发等，或者深入区块链研究，都值得参考。 书中项目亿书完全开源，本书完全开源，链接在文末，敬请关注或参与。 前言 我们在第一部分《了解加密货币》里说过，加密货币是“利益”转移的程序化，其核心目标是保证数字财富或价值安全、透明、快速的转移。因此，交易是加密货币系统中最重要的部分，加密货币的核心就是交易，加密解密、P2P网络、区块链等一系列技术都是围绕交易展开的。 这一篇，我们就来研究亿书提供的交易类型及代码实现，集中总结交易的生命周期及实现过程，把在《地址》和《签名和多重签名》里故意漏掉的判断逻辑补充完整。 源码 transaction-types.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/helpers/transaction-types.js transaction.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/logic/transaction.js transactions.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/transactions.js 类图 解读 1、交易的本质 从经济学角度来说，交易就是一种价值交换。在《精通比特币》（见参考）一书里，作者是这样定义比特币交易的：简单地说，交易是指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”就是一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。 交易，在汉语词典里，既可以是名词，代表交易内容的数据信息（技术上叫做数据结构），又可以是动词，代表一个操作过程。把这些重要信息汇总到一起，既让用户容易理解，又要体现加密货币特点，可以这样定义一个交易操作： 加密货币交易是指人们通过加密货币网络，把加密货币进行有效转移， 并把交易数据保存到区块链的过程。 这个定义与我们的直观感受比较接近。通常，大家喜欢把加密货币交易，比做纸质支票，支票本身就是记录一笔交易的数据结构，从签署支票到兑付完成的过程就是一个交易操作行为。一笔加密货币交易就是一个有着货币转移目的的电子支票，只有在交易被执行时才会在金融体系中体现，而且交易发起人并不一定是签署该笔交易的人。 交易可以被任何人在线上或线下创建，即便创建这笔交易的人不是这个账户的授权签字人。这一点非常好理解，假如有一张空的纸质支票，我们可以自己填写，也可以找人填写，最后只要有支付权限的领导签名，支票就能生效，就可以兑付。加密货币也是如此，无论谁创建的加密货币交易，只要被资金所有者（们）数字签名，交易就能实现。 交易只是一些经过加密处理的字节码，不含任何机密信息、私钥或密码，可被包括wifi、无线电在内的任何网络公开传播，甚至可以被处理成二维码、表情符号、短信等形式发送。只要这笔交易能进入加密货币网络，那么发送者并不需要信任用来传播该笔交易的任何一个网络节点。同时，这些节点也不需要信任发送者，不用记录发送者的任何身份信息。相反，电子商务网站的交易，不仅包含敏感信息，而且依赖加密网络连接完成信息传输。 因此，从本质上讲，加密货币交易是价值所有权的变更，价值转移仅仅是这种行为的结果。加密货币总量就是那些，从始至终都不会变化，人为丢失的是人类流通使用的私钥权限，总量仍在网络上不会丢失。记录加密货币总量的区块链就那一条，这个链条可以越来越长，越来越大，但是增加的仅仅是交易信息，即价值所有权变更信息。用个不慎确切的比喻，加密货币就像一列永不停息的火车，上下的是人次，固定的是座位，您只有在自己的人生旅途中才拥有某个座位的所有权（使用权）。 从设计原理上说，加密货币淡化了交易者帐号，简化为输入输出，所谓的账户也只是存在于客户端钱包这类具体的应用层的软件里，就像那列火车总要有火车站吧，而某一段旅程的火车票是有具体所属的，是要与现实人的帐号或身份对应的，所以火车站是要记录用户信息，要有检票、验票的过程。 亿书的原理也是如此，只不过亿书通过进一步扩展交易类型，强化了用户帐号的存在，使得更加适合处理各类资产所有权，从而为数字版权保护奠定良好架构基础。 2、交易生命周期 加密货币的整个系统，都是为了确保正确地生成交易、快速地传播和验证交易，并最终写入全球交易总账簿——区块链而设计。因此，从开发设计角度考虑，一笔交易必须包括下列过程： 生成一笔交易。这里是指一条包含交易双方加密货币地址、数量、时间戳和有效签名等信息，而且不含任何私密信息的合法交易数据; 广播到网络。几乎每个节点都会获得这笔交易数据。 验证交易合法性。生成交易的节点和其他节点都要验证，没有得到验证的交易，是不能进入加密货币网络的。 写入区块链。 下面，我们来详细阅读分析亿书的交易是如何实现的。 3、亿书交易类型 目前，亿书已经完成或正在开发的交易类型，包括14种（后续会有更多），分别是： // helpers/transaction-types.js module.exports = { SEND : 0, SIGNATURE : 1, DELEGATE : 2, VOTE : 3, USERNAME : 4, FOLLOW : 5, MULTI: 6, DAPP: 7, IN_TRANSFER: 8, OUT_TRANSFER: 9, ARTICALE : 10, EBOOK: 11， BUY: 12， READ: 13 } 其中， SEND是最基本的转账交易，SIGNATURE是上一篇提到的“签名”交易，DELEGATE是注册为受托人，VOTE是投票，USERNAME是注册用户别名地址，FOLLOW是添加联系人，MULTI是注册多重签名帐号，DAPP是侧链应用，IN_TRANSFER是转入Aapp资金，OUT_TRANSFER转出Aapp资金，这些是现有版本已经完成的功能。 ARTICALE是发布文章，EBOOK是发布电子书，BUY是购买（电子书或其他商品），READ是付费阅读（电子书等），这些功能会逐步添加。 这些交易，除了SEND转账交易外，其他的交易类型，我们暂且称它们为功能性交易（在比特币的圈子里，有人称为伪交易）。 4、交易基本流程 亿书交易类型尽管多样，但是交易的基本逻辑是一样的。整个加密货币都是交易逻辑的有效组成部分，要比传统电子商务网站复杂的多，但与交易直接相关的代码，却又非常简单清晰。从开发角度说，实现一笔交易，亿书需要这样几个步骤： （1）生成交易数据 交易是人类行为，涉及到甲乙双方（货币发送者和接收者，我们用甲乙方来代替，下文同）和交易数额，这在很多交易，特别是版权交易方面更加重要。甲方是主动发起交易的有效用户，是亿书币的支付方，是交易的支付来源。乙方比较灵活，可以是另一个有合法地址的用户，也可以是亿书系统本身（功能性交易），是亿书币的接收方。 简单的一句话就是：谁与谁交易了多少钱。用下面转账交易部分的代码举例，请看modules/transactions.js文件里的763和800行，一笔交易必须包含如下字段： 交易类型。代码里表示为 type: TransactionTypes.SEND; 支付帐号。代码里指的是 sender: account; 接受帐号。代码里指的是 recipientId: recipientId, 如果用的是别名地址，就是 recipientUsername: recipientUsername，如果是功能性交易，这里就不需要了; 交易数量。代码里指的是 amount: body.amount。 这些数据有的要求用户输入，比如用户密钥，交易数量等，这些数据是否正确，也是非常关键的事情。这是软件程序验证逻辑的一个重要部分，不可或缺。这个很好理解，如果一个人胡乱填写密钥和接受地址，也能把币发送出去，那就笑话了。但具体校验过程较为繁琐，这里主要涉及到：发起交易的用户是否存在、密钥是否正确、是否多重签名帐号、是否有支付密码，以及接受方用户地址是否合法等，都要逐个检验。 详情看这里的流程图： （2）给合法交易签名 基本信息正确之后，一笔合法交易，还要使用甲乙方的公钥签名，确保交易所属。同时，还要准确记录它的交易时间戳，方便追溯。还要生成交易ID，每个交易ID都包含了丰富的加密信息，需要复杂的生成过程，绝不像传统的网站系统，让数据库自动生成索引就可以充当ID了。 详情看这里的流程图： （3）验证交易合法性 通常，一笔交易经过6-10个区块之后，这笔交易被认为是无法更改的，即已确认，因为这时候拒绝、变更的难度已经非常大，理论上已经不可能。这里的交易合法性，除了基本信息正确之外，主要是指保证交易是未确认的交易，也不是用户重复提交的交易，即双花交易。双花交易是加密货币特有的现象，通俗的说，就是用户在交易确认之前（有一段时间，比特币时间更长），又一次提交了相同交易信息，导致一笔钱花两次，这种情况是必须要避免的。 每笔交易在广播到网络之前必须验证合法性，不合法的交易没有机会广播到网络。节点收到新的交易信息时，要重新验证。如此一来，任何对网络的攻击，都只会影响一个节点，安全性大大提高。 验证合法的交易就可以直接加入区块链了，因此从上面的第一步到现在，亿书都是在一个节点上完成的。这也为下面的广播处理打下基础，一旦交易被广播到网络，在其他节点，这里的验证和处理过程就会重复执行一次。 验证的过程，看这里的流程图： （4）广播到点对点网络 没有中心服务器，必须借助点对点网络，把交易数据写入分布式公共账本——区块链，保证交易数据永远无法篡改，而且可以轻松查询追溯。这在中心化的服务器上，为了应对个别交易摩擦，保证交易记录可追溯，要采取更多的技术手段，记录更多的数据字段，意味着要保持大量数据冗余，付出更多资金成本。 因为交易数据不含私密信息，对网络没有苛刻要求，因此加密货币的网络可以覆盖很广，对网络的编程也变得灵活很多。理论上，只要能保证联通的便捷和快速，具体设计中不需要考虑更多复杂的因素。当然，就亿书这款产品而言，独有的用户协作和分享功能，对网络编程的性能有自身的要求，就另当别论，这方面将在下一个版本中体现出来。 这里，仅仅是加密货币基础网络功能，交易广播到网络的流程如下： 5、转账交易分析 前面几篇，我们接触到几种交易类型，比如：注册别名地址和多重签名地址，不过并没有研究具体的交易过程，下面通过分析转账交易来学习整个交易、验证的过程。 代码实现在modules/transactions.js文件里，主要Api如下： // 148行 router.map(shared, { &quot;get /&quot;: &quot;getTransactions&quot;, &quot;get /get&quot;: &quot;getTransaction&quot;, &quot;get /unconfirmed/get&quot;: &quot;getUnconfirmedTransaction&quot;, &quot;get /unconfirmed&quot;: &quot;getUnconfirmedTransactions&quot;, &quot;put /&quot;: &quot;addTransactions&quot; }); // 160行 library.network.app.use(&#39;/api/transactions&#39;, router); 解析一下，就是： get /api/transactions/ -&gt; shared.getTransactions get /api/transactions/get -&gt; shared.getTransaction get /api/transactions/unconfirmed/get -&gt; shared.getUnconfirmedTransaction get /api/transactions/unconfirmed -&gt; shared.getUnconfirmedTransactions put /api/transactions/ -&gt; shared.addTransactions 我们仍然把读取数据的Api放一放，因为他们很简单，重点掌握写数据的操作，put /api/transactions/，对应方法shared.addTransactions，代码如下： // 652行 shared.addTransactions = function (req, cb) { var body = req.body; library.scheme.validate(body, { type: &quot;object&quot;, properties: { secret: { type: &quot;string&quot;, minLength: 1, maxLength: 100 }, amount: { type: &quot;integer&quot;, minimum: 1, maximum: constants.totalAmount }, recipientId: { type: &quot;string&quot;, minLength: 1 }, publicKey: { type: &quot;string&quot;, format: &quot;publicKey&quot; }, secondSecret: { type: &quot;string&quot;, minLength: 1, maxLength: 100 }, multisigAccountPublicKey: { type: &quot;string&quot;, format: &quot;publicKey&quot; } }, // required: [&quot;secret&quot;, &quot;amount&quot;, &quot;recipientId&quot;] }, function (err) { // 验证数据格式 if (err) { return cb(err[0].message); } // 验证密码信息 var hash = crypto.createHash(&#39;sha256&#39;).update(body.secret, &#39;utf8&#39;).digest(); var keypair = ed.MakeKeypair(hash); if (body.publicKey) { if (keypair.publicKey.toString(&#39;hex&#39;) != body.publicKey) { return cb(&quot;Invalid passphrase&quot;); } } var query = {}; // 乙方（接收方）地址转换，保证可以用户名转账 var isAddress = /^[0-9]+[L|l]$/g; if (isAddress.test(body.recipientId)) { query.address = body.recipientId; } else { query.username = body.recipientId; } library.balancesSequence.add(function (cb) { // 验证乙方用户合法性 modules.accounts.getAccount(query, function (err, recipient) { if (err) { return cb(err.toString()); } if (!recipient &amp;&amp; query.username) { return cb(&quot;Recipient not found&quot;); } var recipientId = recipient ? recipient.address : body.recipientId; var recipientUsername = recipient ? recipient.username : null; // 验证甲方（发送方）用户合法性 if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { // 验证多重签名 modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) { if (err) { return cb(err.toString()); } // 多重签名帐号不存在 if (!account || !account.publicKey) { return cb(&quot;Multisignature account not found&quot;); } // 多重签名帐号未激活 if (!account || !account.multisignatures) { return cb(&quot;Account does not have multisignatures enabled&quot;); } // 帐号不属于该多重签名组 if (account.multisignatures.indexOf(keypair.publicKey.toString(&#39;hex&#39;)) &lt; 0) { return cb(&quot;Account does not belong to multisignature group&quot;); } // 接着验证甲方（发送方）用户合法性 modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) { if (err) { return cb(err.toString()); } // 甲方帐号不存在 if (!requester || !requester.publicKey) { return cb(&quot;Invalid requester&quot;); } // 甲方支付密码（二次签名）不正确 if (requester.secondSignature &amp;&amp; !body.secondSecret) { return cb(&quot;Invalid second passphrase&quot;); } // 甲方帐号公钥与多重签名帐号公钥是不一样的（因为两个账户是不一样的） if (requester.publicKey == account.publicKey) { return cb(&quot;Invalid requester&quot;); } var secondKeypair = null; if (requester.secondSignature) { var secondHash = crypto.createHash(&#39;sha256&#39;).update(body.secondSecret, &#39;utf8&#39;).digest(); secondKeypair = ed.MakeKeypair(secondHash); } try { // 763行 把上述数据整理成需要的交易数据结构，并给交易添加时间戳、签名、生成ID、计算交易费等 var transaction = library.logic.transaction.create({ type: TransactionTypes.SEND, amount: body.amount, sender: account, recipientId: recipientId, recipientUsername: recipientUsername, keypair: keypair, requester: keypair, secondKeypair: secondKeypair }); } catch (e) { return cb(e.toString()); } // 776行 处理交易 modules.transactions.receiveTransactions([transaction], cb); }); }); } else { // 直接验证甲方（发送方）用户合法性，这里的请求者requester就是发出交易者sender ... }); } 上面这段代码涉及到的就是生成交易数据，这与之前的《地址》、《签名和多重签名》里提到的功能性交易差不多，这里把该方法代码完整粘贴出来，具体逻辑请看代码里的注释和前面的流程图。 接下来，776行，通过receiveTransactions方法处理交易，该方法最终调用的是下面的方法。关键部分，已经添加了注释，请结合上面的流程图阅读，不再详述。 // modules/transactions.js文件 // 337行 Transactions.prototype.processUnconfirmedTransaction = function (transaction, broadcast, cb) { modules.accounts.setAccountAndGet({publicKey: transaction.senderPublicKey}, function (err, sender) { // 这是个闭包，在下面的程序运行结束的时候才调用，因此是验证完毕，才写入区块链、广播到网络 function done(err) { if (err) { return cb(err); } // 这里 加入区块链 操作 private.addUnconfirmedTransaction(transaction, sender, function (err) { if (err) { return cb(err); } // 触发事件，广播到网络 library.bus.message(&#39;unconfirmedTransaction&#39;, transaction, broadcast); cb(); }); } if (err) { return done(err); } if (transaction.requesterPublicKey &amp;&amp; sender &amp;&amp; sender.multisignatures &amp;&amp; sender.multisignatures.length) { modules.accounts.getAccount({publicKey: transaction.requesterPublicKey}, function (err, requester) { if (err) { return done(err); } if (!requester) { return cb(&quot;Invalid requester&quot;); } // 开始执行一系列验证，包括交易是不是已经存在 library.logic.transaction.process(transaction, sender, requester, function (err, transaction) { if (err) { return done(err); } // 检查是否交易已经存在（包括双花交易） if (private.unconfirmedTransactionsIdIndex[transaction.id] !== undefined || private.doubleSpendingTransactions[transaction.id]) { return cb(&quot;Transaction already exists&quot;); } // 这里是 直接验证交易签名等信息，接着调用闭包 done()，把交易写入区块链并广播到网络 library.logic.transaction.verify(transaction, sender, done); }); }); } else { ... } 总结 这里的编码逻辑非常清晰，但作为非常核心的部分，使用了大量编程技巧，需要比较熟练的开发技能。代码中涉及到大量的回调和验证，有的回调嵌套很深，需要对异步较为深入的理解，掌握熟练的回调处理方法，不然理解和编码都会有很多困扰。因此，好好熟悉基本编码技巧，从小处着手打好基础很重要。 本文涉及的流程图相对比较复杂，为了印刷方便，我把完整的流程图拆分成为四张，处理过程花费了大量时间，但是很多细节仍然无法照顾到，也无法保证没有错误和疏漏，请看到问题的小伙伴及时反馈给我。 交易是怎么写入区块链的，上面仅仅点到为止，不够详细和深入。为了进一步阐述区块链的原理，需要专门拿出一篇来，详细讲述。而且，作为目前加密货币的“网红”，区块链也值得我们好好研究。请看下一篇：《神秘的区块链》 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 电子书阅读： http://bitcoin-on-nodejs.ebookchain.org 亿书官网： http://ebookchain.org 亿书官方QQ群：185046161（亿书完全开源开放，欢迎各界小伙伴参与） 参考 亿书白皮书： http://ebookchain.org/ebookchain.pdf 精通比特币（英文） 精通比特币（中文） 阅读更多" />
<meta property="og:description" content="题外话：这篇文章，耗费了我大量精力，用UML表达javascript类及流程本来就不是什么容易的事情，用来描述加密货币交易这种验证逻辑非常多的代码更难，加之Nodejs的回调在这些代码里嵌套很深，所以如何把异步调用变成人类容易理解的顺序调用，也做了一番取舍，时间不知不觉就过了一星期。 所幸，赶在比特币减半的今天完成并发布这篇文章，也算在区块链火热的今天，《Nodejs开发加密货币》走到了一个关键节点：触及了加密货币的灵魂和腹地。动辄几千一枚的比特币等加密货币可能会消亡，但是背后的技术却蓬勃发展，玩技术的要善于把握先机，抢占技术高点，让自己时刻成为稀缺的资源，自身价值才能一路高升。 本书是市面上唯一一本讲解Nodejs开发加密货币的实践书籍，与那些纯粹为了举例而提供的代码示例不同，全书代码，哪怕是前端代码实例，都是来自正在运行的真实项目，所以无论您是学习Nodejs技术找寻实践项目，还是学习前端设计、web开发等，或者深入区块链研究，都值得参考。 书中项目亿书完全开源，本书完全开源，链接在文末，敬请关注或参与。 前言 我们在第一部分《了解加密货币》里说过，加密货币是“利益”转移的程序化，其核心目标是保证数字财富或价值安全、透明、快速的转移。因此，交易是加密货币系统中最重要的部分，加密货币的核心就是交易，加密解密、P2P网络、区块链等一系列技术都是围绕交易展开的。 这一篇，我们就来研究亿书提供的交易类型及代码实现，集中总结交易的生命周期及实现过程，把在《地址》和《签名和多重签名》里故意漏掉的判断逻辑补充完整。 源码 transaction-types.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/helpers/transaction-types.js transaction.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/logic/transaction.js transactions.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/transactions.js 类图 解读 1、交易的本质 从经济学角度来说，交易就是一种价值交换。在《精通比特币》（见参考）一书里，作者是这样定义比特币交易的：简单地说，交易是指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”就是一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。 交易，在汉语词典里，既可以是名词，代表交易内容的数据信息（技术上叫做数据结构），又可以是动词，代表一个操作过程。把这些重要信息汇总到一起，既让用户容易理解，又要体现加密货币特点，可以这样定义一个交易操作： 加密货币交易是指人们通过加密货币网络，把加密货币进行有效转移， 并把交易数据保存到区块链的过程。 这个定义与我们的直观感受比较接近。通常，大家喜欢把加密货币交易，比做纸质支票，支票本身就是记录一笔交易的数据结构，从签署支票到兑付完成的过程就是一个交易操作行为。一笔加密货币交易就是一个有着货币转移目的的电子支票，只有在交易被执行时才会在金融体系中体现，而且交易发起人并不一定是签署该笔交易的人。 交易可以被任何人在线上或线下创建，即便创建这笔交易的人不是这个账户的授权签字人。这一点非常好理解，假如有一张空的纸质支票，我们可以自己填写，也可以找人填写，最后只要有支付权限的领导签名，支票就能生效，就可以兑付。加密货币也是如此，无论谁创建的加密货币交易，只要被资金所有者（们）数字签名，交易就能实现。 交易只是一些经过加密处理的字节码，不含任何机密信息、私钥或密码，可被包括wifi、无线电在内的任何网络公开传播，甚至可以被处理成二维码、表情符号、短信等形式发送。只要这笔交易能进入加密货币网络，那么发送者并不需要信任用来传播该笔交易的任何一个网络节点。同时，这些节点也不需要信任发送者，不用记录发送者的任何身份信息。相反，电子商务网站的交易，不仅包含敏感信息，而且依赖加密网络连接完成信息传输。 因此，从本质上讲，加密货币交易是价值所有权的变更，价值转移仅仅是这种行为的结果。加密货币总量就是那些，从始至终都不会变化，人为丢失的是人类流通使用的私钥权限，总量仍在网络上不会丢失。记录加密货币总量的区块链就那一条，这个链条可以越来越长，越来越大，但是增加的仅仅是交易信息，即价值所有权变更信息。用个不慎确切的比喻，加密货币就像一列永不停息的火车，上下的是人次，固定的是座位，您只有在自己的人生旅途中才拥有某个座位的所有权（使用权）。 从设计原理上说，加密货币淡化了交易者帐号，简化为输入输出，所谓的账户也只是存在于客户端钱包这类具体的应用层的软件里，就像那列火车总要有火车站吧，而某一段旅程的火车票是有具体所属的，是要与现实人的帐号或身份对应的，所以火车站是要记录用户信息，要有检票、验票的过程。 亿书的原理也是如此，只不过亿书通过进一步扩展交易类型，强化了用户帐号的存在，使得更加适合处理各类资产所有权，从而为数字版权保护奠定良好架构基础。 2、交易生命周期 加密货币的整个系统，都是为了确保正确地生成交易、快速地传播和验证交易，并最终写入全球交易总账簿——区块链而设计。因此，从开发设计角度考虑，一笔交易必须包括下列过程： 生成一笔交易。这里是指一条包含交易双方加密货币地址、数量、时间戳和有效签名等信息，而且不含任何私密信息的合法交易数据; 广播到网络。几乎每个节点都会获得这笔交易数据。 验证交易合法性。生成交易的节点和其他节点都要验证，没有得到验证的交易，是不能进入加密货币网络的。 写入区块链。 下面，我们来详细阅读分析亿书的交易是如何实现的。 3、亿书交易类型 目前，亿书已经完成或正在开发的交易类型，包括14种（后续会有更多），分别是： // helpers/transaction-types.js module.exports = { SEND : 0, SIGNATURE : 1, DELEGATE : 2, VOTE : 3, USERNAME : 4, FOLLOW : 5, MULTI: 6, DAPP: 7, IN_TRANSFER: 8, OUT_TRANSFER: 9, ARTICALE : 10, EBOOK: 11， BUY: 12， READ: 13 } 其中， SEND是最基本的转账交易，SIGNATURE是上一篇提到的“签名”交易，DELEGATE是注册为受托人，VOTE是投票，USERNAME是注册用户别名地址，FOLLOW是添加联系人，MULTI是注册多重签名帐号，DAPP是侧链应用，IN_TRANSFER是转入Aapp资金，OUT_TRANSFER转出Aapp资金，这些是现有版本已经完成的功能。 ARTICALE是发布文章，EBOOK是发布电子书，BUY是购买（电子书或其他商品），READ是付费阅读（电子书等），这些功能会逐步添加。 这些交易，除了SEND转账交易外，其他的交易类型，我们暂且称它们为功能性交易（在比特币的圈子里，有人称为伪交易）。 4、交易基本流程 亿书交易类型尽管多样，但是交易的基本逻辑是一样的。整个加密货币都是交易逻辑的有效组成部分，要比传统电子商务网站复杂的多，但与交易直接相关的代码，却又非常简单清晰。从开发角度说，实现一笔交易，亿书需要这样几个步骤： （1）生成交易数据 交易是人类行为，涉及到甲乙双方（货币发送者和接收者，我们用甲乙方来代替，下文同）和交易数额，这在很多交易，特别是版权交易方面更加重要。甲方是主动发起交易的有效用户，是亿书币的支付方，是交易的支付来源。乙方比较灵活，可以是另一个有合法地址的用户，也可以是亿书系统本身（功能性交易），是亿书币的接收方。 简单的一句话就是：谁与谁交易了多少钱。用下面转账交易部分的代码举例，请看modules/transactions.js文件里的763和800行，一笔交易必须包含如下字段： 交易类型。代码里表示为 type: TransactionTypes.SEND; 支付帐号。代码里指的是 sender: account; 接受帐号。代码里指的是 recipientId: recipientId, 如果用的是别名地址，就是 recipientUsername: recipientUsername，如果是功能性交易，这里就不需要了; 交易数量。代码里指的是 amount: body.amount。 这些数据有的要求用户输入，比如用户密钥，交易数量等，这些数据是否正确，也是非常关键的事情。这是软件程序验证逻辑的一个重要部分，不可或缺。这个很好理解，如果一个人胡乱填写密钥和接受地址，也能把币发送出去，那就笑话了。但具体校验过程较为繁琐，这里主要涉及到：发起交易的用户是否存在、密钥是否正确、是否多重签名帐号、是否有支付密码，以及接受方用户地址是否合法等，都要逐个检验。 详情看这里的流程图： （2）给合法交易签名 基本信息正确之后，一笔合法交易，还要使用甲乙方的公钥签名，确保交易所属。同时，还要准确记录它的交易时间戳，方便追溯。还要生成交易ID，每个交易ID都包含了丰富的加密信息，需要复杂的生成过程，绝不像传统的网站系统，让数据库自动生成索引就可以充当ID了。 详情看这里的流程图： （3）验证交易合法性 通常，一笔交易经过6-10个区块之后，这笔交易被认为是无法更改的，即已确认，因为这时候拒绝、变更的难度已经非常大，理论上已经不可能。这里的交易合法性，除了基本信息正确之外，主要是指保证交易是未确认的交易，也不是用户重复提交的交易，即双花交易。双花交易是加密货币特有的现象，通俗的说，就是用户在交易确认之前（有一段时间，比特币时间更长），又一次提交了相同交易信息，导致一笔钱花两次，这种情况是必须要避免的。 每笔交易在广播到网络之前必须验证合法性，不合法的交易没有机会广播到网络。节点收到新的交易信息时，要重新验证。如此一来，任何对网络的攻击，都只会影响一个节点，安全性大大提高。 验证合法的交易就可以直接加入区块链了，因此从上面的第一步到现在，亿书都是在一个节点上完成的。这也为下面的广播处理打下基础，一旦交易被广播到网络，在其他节点，这里的验证和处理过程就会重复执行一次。 验证的过程，看这里的流程图： （4）广播到点对点网络 没有中心服务器，必须借助点对点网络，把交易数据写入分布式公共账本——区块链，保证交易数据永远无法篡改，而且可以轻松查询追溯。这在中心化的服务器上，为了应对个别交易摩擦，保证交易记录可追溯，要采取更多的技术手段，记录更多的数据字段，意味着要保持大量数据冗余，付出更多资金成本。 因为交易数据不含私密信息，对网络没有苛刻要求，因此加密货币的网络可以覆盖很广，对网络的编程也变得灵活很多。理论上，只要能保证联通的便捷和快速，具体设计中不需要考虑更多复杂的因素。当然，就亿书这款产品而言，独有的用户协作和分享功能，对网络编程的性能有自身的要求，就另当别论，这方面将在下一个版本中体现出来。 这里，仅仅是加密货币基础网络功能，交易广播到网络的流程如下： 5、转账交易分析 前面几篇，我们接触到几种交易类型，比如：注册别名地址和多重签名地址，不过并没有研究具体的交易过程，下面通过分析转账交易来学习整个交易、验证的过程。 代码实现在modules/transactions.js文件里，主要Api如下： // 148行 router.map(shared, { &quot;get /&quot;: &quot;getTransactions&quot;, &quot;get /get&quot;: &quot;getTransaction&quot;, &quot;get /unconfirmed/get&quot;: &quot;getUnconfirmedTransaction&quot;, &quot;get /unconfirmed&quot;: &quot;getUnconfirmedTransactions&quot;, &quot;put /&quot;: &quot;addTransactions&quot; }); // 160行 library.network.app.use(&#39;/api/transactions&#39;, router); 解析一下，就是： get /api/transactions/ -&gt; shared.getTransactions get /api/transactions/get -&gt; shared.getTransaction get /api/transactions/unconfirmed/get -&gt; shared.getUnconfirmedTransaction get /api/transactions/unconfirmed -&gt; shared.getUnconfirmedTransactions put /api/transactions/ -&gt; shared.addTransactions 我们仍然把读取数据的Api放一放，因为他们很简单，重点掌握写数据的操作，put /api/transactions/，对应方法shared.addTransactions，代码如下： // 652行 shared.addTransactions = function (req, cb) { var body = req.body; library.scheme.validate(body, { type: &quot;object&quot;, properties: { secret: { type: &quot;string&quot;, minLength: 1, maxLength: 100 }, amount: { type: &quot;integer&quot;, minimum: 1, maximum: constants.totalAmount }, recipientId: { type: &quot;string&quot;, minLength: 1 }, publicKey: { type: &quot;string&quot;, format: &quot;publicKey&quot; }, secondSecret: { type: &quot;string&quot;, minLength: 1, maxLength: 100 }, multisigAccountPublicKey: { type: &quot;string&quot;, format: &quot;publicKey&quot; } }, // required: [&quot;secret&quot;, &quot;amount&quot;, &quot;recipientId&quot;] }, function (err) { // 验证数据格式 if (err) { return cb(err[0].message); } // 验证密码信息 var hash = crypto.createHash(&#39;sha256&#39;).update(body.secret, &#39;utf8&#39;).digest(); var keypair = ed.MakeKeypair(hash); if (body.publicKey) { if (keypair.publicKey.toString(&#39;hex&#39;) != body.publicKey) { return cb(&quot;Invalid passphrase&quot;); } } var query = {}; // 乙方（接收方）地址转换，保证可以用户名转账 var isAddress = /^[0-9]+[L|l]$/g; if (isAddress.test(body.recipientId)) { query.address = body.recipientId; } else { query.username = body.recipientId; } library.balancesSequence.add(function (cb) { // 验证乙方用户合法性 modules.accounts.getAccount(query, function (err, recipient) { if (err) { return cb(err.toString()); } if (!recipient &amp;&amp; query.username) { return cb(&quot;Recipient not found&quot;); } var recipientId = recipient ? recipient.address : body.recipientId; var recipientUsername = recipient ? recipient.username : null; // 验证甲方（发送方）用户合法性 if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { // 验证多重签名 modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) { if (err) { return cb(err.toString()); } // 多重签名帐号不存在 if (!account || !account.publicKey) { return cb(&quot;Multisignature account not found&quot;); } // 多重签名帐号未激活 if (!account || !account.multisignatures) { return cb(&quot;Account does not have multisignatures enabled&quot;); } // 帐号不属于该多重签名组 if (account.multisignatures.indexOf(keypair.publicKey.toString(&#39;hex&#39;)) &lt; 0) { return cb(&quot;Account does not belong to multisignature group&quot;); } // 接着验证甲方（发送方）用户合法性 modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) { if (err) { return cb(err.toString()); } // 甲方帐号不存在 if (!requester || !requester.publicKey) { return cb(&quot;Invalid requester&quot;); } // 甲方支付密码（二次签名）不正确 if (requester.secondSignature &amp;&amp; !body.secondSecret) { return cb(&quot;Invalid second passphrase&quot;); } // 甲方帐号公钥与多重签名帐号公钥是不一样的（因为两个账户是不一样的） if (requester.publicKey == account.publicKey) { return cb(&quot;Invalid requester&quot;); } var secondKeypair = null; if (requester.secondSignature) { var secondHash = crypto.createHash(&#39;sha256&#39;).update(body.secondSecret, &#39;utf8&#39;).digest(); secondKeypair = ed.MakeKeypair(secondHash); } try { // 763行 把上述数据整理成需要的交易数据结构，并给交易添加时间戳、签名、生成ID、计算交易费等 var transaction = library.logic.transaction.create({ type: TransactionTypes.SEND, amount: body.amount, sender: account, recipientId: recipientId, recipientUsername: recipientUsername, keypair: keypair, requester: keypair, secondKeypair: secondKeypair }); } catch (e) { return cb(e.toString()); } // 776行 处理交易 modules.transactions.receiveTransactions([transaction], cb); }); }); } else { // 直接验证甲方（发送方）用户合法性，这里的请求者requester就是发出交易者sender ... }); } 上面这段代码涉及到的就是生成交易数据，这与之前的《地址》、《签名和多重签名》里提到的功能性交易差不多，这里把该方法代码完整粘贴出来，具体逻辑请看代码里的注释和前面的流程图。 接下来，776行，通过receiveTransactions方法处理交易，该方法最终调用的是下面的方法。关键部分，已经添加了注释，请结合上面的流程图阅读，不再详述。 // modules/transactions.js文件 // 337行 Transactions.prototype.processUnconfirmedTransaction = function (transaction, broadcast, cb) { modules.accounts.setAccountAndGet({publicKey: transaction.senderPublicKey}, function (err, sender) { // 这是个闭包，在下面的程序运行结束的时候才调用，因此是验证完毕，才写入区块链、广播到网络 function done(err) { if (err) { return cb(err); } // 这里 加入区块链 操作 private.addUnconfirmedTransaction(transaction, sender, function (err) { if (err) { return cb(err); } // 触发事件，广播到网络 library.bus.message(&#39;unconfirmedTransaction&#39;, transaction, broadcast); cb(); }); } if (err) { return done(err); } if (transaction.requesterPublicKey &amp;&amp; sender &amp;&amp; sender.multisignatures &amp;&amp; sender.multisignatures.length) { modules.accounts.getAccount({publicKey: transaction.requesterPublicKey}, function (err, requester) { if (err) { return done(err); } if (!requester) { return cb(&quot;Invalid requester&quot;); } // 开始执行一系列验证，包括交易是不是已经存在 library.logic.transaction.process(transaction, sender, requester, function (err, transaction) { if (err) { return done(err); } // 检查是否交易已经存在（包括双花交易） if (private.unconfirmedTransactionsIdIndex[transaction.id] !== undefined || private.doubleSpendingTransactions[transaction.id]) { return cb(&quot;Transaction already exists&quot;); } // 这里是 直接验证交易签名等信息，接着调用闭包 done()，把交易写入区块链并广播到网络 library.logic.transaction.verify(transaction, sender, done); }); }); } else { ... } 总结 这里的编码逻辑非常清晰，但作为非常核心的部分，使用了大量编程技巧，需要比较熟练的开发技能。代码中涉及到大量的回调和验证，有的回调嵌套很深，需要对异步较为深入的理解，掌握熟练的回调处理方法，不然理解和编码都会有很多困扰。因此，好好熟悉基本编码技巧，从小处着手打好基础很重要。 本文涉及的流程图相对比较复杂，为了印刷方便，我把完整的流程图拆分成为四张，处理过程花费了大量时间，但是很多细节仍然无法照顾到，也无法保证没有错误和疏漏，请看到问题的小伙伴及时反馈给我。 交易是怎么写入区块链的，上面仅仅点到为止，不够详细和深入。为了进一步阐述区块链的原理，需要专门拿出一篇来，详细讲述。而且，作为目前加密货币的“网红”，区块链也值得我们好好研究。请看下一篇：《神秘的区块链》 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 电子书阅读： http://bitcoin-on-nodejs.ebookchain.org 亿书官网： http://ebookchain.org 亿书官方QQ群：185046161（亿书完全开源开放，欢迎各界小伙伴参与） 参考 亿书白皮书： http://ebookchain.org/ebookchain.pdf 精通比特币（英文） 精通比特币（中文） 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-07-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"题外话：这篇文章，耗费了我大量精力，用UML表达javascript类及流程本来就不是什么容易的事情，用来描述加密货币交易这种验证逻辑非常多的代码更难，加之Nodejs的回调在这些代码里嵌套很深，所以如何把异步调用变成人类容易理解的顺序调用，也做了一番取舍，时间不知不觉就过了一星期。 所幸，赶在比特币减半的今天完成并发布这篇文章，也算在区块链火热的今天，《Nodejs开发加密货币》走到了一个关键节点：触及了加密货币的灵魂和腹地。动辄几千一枚的比特币等加密货币可能会消亡，但是背后的技术却蓬勃发展，玩技术的要善于把握先机，抢占技术高点，让自己时刻成为稀缺的资源，自身价值才能一路高升。 本书是市面上唯一一本讲解Nodejs开发加密货币的实践书籍，与那些纯粹为了举例而提供的代码示例不同，全书代码，哪怕是前端代码实例，都是来自正在运行的真实项目，所以无论您是学习Nodejs技术找寻实践项目，还是学习前端设计、web开发等，或者深入区块链研究，都值得参考。 书中项目亿书完全开源，本书完全开源，链接在文末，敬请关注或参与。 前言 我们在第一部分《了解加密货币》里说过，加密货币是“利益”转移的程序化，其核心目标是保证数字财富或价值安全、透明、快速的转移。因此，交易是加密货币系统中最重要的部分，加密货币的核心就是交易，加密解密、P2P网络、区块链等一系列技术都是围绕交易展开的。 这一篇，我们就来研究亿书提供的交易类型及代码实现，集中总结交易的生命周期及实现过程，把在《地址》和《签名和多重签名》里故意漏掉的判断逻辑补充完整。 源码 transaction-types.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/helpers/transaction-types.js transaction.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/logic/transaction.js transactions.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/transactions.js 类图 解读 1、交易的本质 从经济学角度来说，交易就是一种价值交换。在《精通比特币》（见参考）一书里，作者是这样定义比特币交易的：简单地说，交易是指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”就是一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。 交易，在汉语词典里，既可以是名词，代表交易内容的数据信息（技术上叫做数据结构），又可以是动词，代表一个操作过程。把这些重要信息汇总到一起，既让用户容易理解，又要体现加密货币特点，可以这样定义一个交易操作： 加密货币交易是指人们通过加密货币网络，把加密货币进行有效转移， 并把交易数据保存到区块链的过程。 这个定义与我们的直观感受比较接近。通常，大家喜欢把加密货币交易，比做纸质支票，支票本身就是记录一笔交易的数据结构，从签署支票到兑付完成的过程就是一个交易操作行为。一笔加密货币交易就是一个有着货币转移目的的电子支票，只有在交易被执行时才会在金融体系中体现，而且交易发起人并不一定是签署该笔交易的人。 交易可以被任何人在线上或线下创建，即便创建这笔交易的人不是这个账户的授权签字人。这一点非常好理解，假如有一张空的纸质支票，我们可以自己填写，也可以找人填写，最后只要有支付权限的领导签名，支票就能生效，就可以兑付。加密货币也是如此，无论谁创建的加密货币交易，只要被资金所有者（们）数字签名，交易就能实现。 交易只是一些经过加密处理的字节码，不含任何机密信息、私钥或密码，可被包括wifi、无线电在内的任何网络公开传播，甚至可以被处理成二维码、表情符号、短信等形式发送。只要这笔交易能进入加密货币网络，那么发送者并不需要信任用来传播该笔交易的任何一个网络节点。同时，这些节点也不需要信任发送者，不用记录发送者的任何身份信息。相反，电子商务网站的交易，不仅包含敏感信息，而且依赖加密网络连接完成信息传输。 因此，从本质上讲，加密货币交易是价值所有权的变更，价值转移仅仅是这种行为的结果。加密货币总量就是那些，从始至终都不会变化，人为丢失的是人类流通使用的私钥权限，总量仍在网络上不会丢失。记录加密货币总量的区块链就那一条，这个链条可以越来越长，越来越大，但是增加的仅仅是交易信息，即价值所有权变更信息。用个不慎确切的比喻，加密货币就像一列永不停息的火车，上下的是人次，固定的是座位，您只有在自己的人生旅途中才拥有某个座位的所有权（使用权）。 从设计原理上说，加密货币淡化了交易者帐号，简化为输入输出，所谓的账户也只是存在于客户端钱包这类具体的应用层的软件里，就像那列火车总要有火车站吧，而某一段旅程的火车票是有具体所属的，是要与现实人的帐号或身份对应的，所以火车站是要记录用户信息，要有检票、验票的过程。 亿书的原理也是如此，只不过亿书通过进一步扩展交易类型，强化了用户帐号的存在，使得更加适合处理各类资产所有权，从而为数字版权保护奠定良好架构基础。 2、交易生命周期 加密货币的整个系统，都是为了确保正确地生成交易、快速地传播和验证交易，并最终写入全球交易总账簿——区块链而设计。因此，从开发设计角度考虑，一笔交易必须包括下列过程： 生成一笔交易。这里是指一条包含交易双方加密货币地址、数量、时间戳和有效签名等信息，而且不含任何私密信息的合法交易数据; 广播到网络。几乎每个节点都会获得这笔交易数据。 验证交易合法性。生成交易的节点和其他节点都要验证，没有得到验证的交易，是不能进入加密货币网络的。 写入区块链。 下面，我们来详细阅读分析亿书的交易是如何实现的。 3、亿书交易类型 目前，亿书已经完成或正在开发的交易类型，包括14种（后续会有更多），分别是： // helpers/transaction-types.js module.exports = { SEND : 0, SIGNATURE : 1, DELEGATE : 2, VOTE : 3, USERNAME : 4, FOLLOW : 5, MULTI: 6, DAPP: 7, IN_TRANSFER: 8, OUT_TRANSFER: 9, ARTICALE : 10, EBOOK: 11， BUY: 12， READ: 13 } 其中， SEND是最基本的转账交易，SIGNATURE是上一篇提到的“签名”交易，DELEGATE是注册为受托人，VOTE是投票，USERNAME是注册用户别名地址，FOLLOW是添加联系人，MULTI是注册多重签名帐号，DAPP是侧链应用，IN_TRANSFER是转入Aapp资金，OUT_TRANSFER转出Aapp资金，这些是现有版本已经完成的功能。 ARTICALE是发布文章，EBOOK是发布电子书，BUY是购买（电子书或其他商品），READ是付费阅读（电子书等），这些功能会逐步添加。 这些交易，除了SEND转账交易外，其他的交易类型，我们暂且称它们为功能性交易（在比特币的圈子里，有人称为伪交易）。 4、交易基本流程 亿书交易类型尽管多样，但是交易的基本逻辑是一样的。整个加密货币都是交易逻辑的有效组成部分，要比传统电子商务网站复杂的多，但与交易直接相关的代码，却又非常简单清晰。从开发角度说，实现一笔交易，亿书需要这样几个步骤： （1）生成交易数据 交易是人类行为，涉及到甲乙双方（货币发送者和接收者，我们用甲乙方来代替，下文同）和交易数额，这在很多交易，特别是版权交易方面更加重要。甲方是主动发起交易的有效用户，是亿书币的支付方，是交易的支付来源。乙方比较灵活，可以是另一个有合法地址的用户，也可以是亿书系统本身（功能性交易），是亿书币的接收方。 简单的一句话就是：谁与谁交易了多少钱。用下面转账交易部分的代码举例，请看modules/transactions.js文件里的763和800行，一笔交易必须包含如下字段： 交易类型。代码里表示为 type: TransactionTypes.SEND; 支付帐号。代码里指的是 sender: account; 接受帐号。代码里指的是 recipientId: recipientId, 如果用的是别名地址，就是 recipientUsername: recipientUsername，如果是功能性交易，这里就不需要了; 交易数量。代码里指的是 amount: body.amount。 这些数据有的要求用户输入，比如用户密钥，交易数量等，这些数据是否正确，也是非常关键的事情。这是软件程序验证逻辑的一个重要部分，不可或缺。这个很好理解，如果一个人胡乱填写密钥和接受地址，也能把币发送出去，那就笑话了。但具体校验过程较为繁琐，这里主要涉及到：发起交易的用户是否存在、密钥是否正确、是否多重签名帐号、是否有支付密码，以及接受方用户地址是否合法等，都要逐个检验。 详情看这里的流程图： （2）给合法交易签名 基本信息正确之后，一笔合法交易，还要使用甲乙方的公钥签名，确保交易所属。同时，还要准确记录它的交易时间戳，方便追溯。还要生成交易ID，每个交易ID都包含了丰富的加密信息，需要复杂的生成过程，绝不像传统的网站系统，让数据库自动生成索引就可以充当ID了。 详情看这里的流程图： （3）验证交易合法性 通常，一笔交易经过6-10个区块之后，这笔交易被认为是无法更改的，即已确认，因为这时候拒绝、变更的难度已经非常大，理论上已经不可能。这里的交易合法性，除了基本信息正确之外，主要是指保证交易是未确认的交易，也不是用户重复提交的交易，即双花交易。双花交易是加密货币特有的现象，通俗的说，就是用户在交易确认之前（有一段时间，比特币时间更长），又一次提交了相同交易信息，导致一笔钱花两次，这种情况是必须要避免的。 每笔交易在广播到网络之前必须验证合法性，不合法的交易没有机会广播到网络。节点收到新的交易信息时，要重新验证。如此一来，任何对网络的攻击，都只会影响一个节点，安全性大大提高。 验证合法的交易就可以直接加入区块链了，因此从上面的第一步到现在，亿书都是在一个节点上完成的。这也为下面的广播处理打下基础，一旦交易被广播到网络，在其他节点，这里的验证和处理过程就会重复执行一次。 验证的过程，看这里的流程图： （4）广播到点对点网络 没有中心服务器，必须借助点对点网络，把交易数据写入分布式公共账本——区块链，保证交易数据永远无法篡改，而且可以轻松查询追溯。这在中心化的服务器上，为了应对个别交易摩擦，保证交易记录可追溯，要采取更多的技术手段，记录更多的数据字段，意味着要保持大量数据冗余，付出更多资金成本。 因为交易数据不含私密信息，对网络没有苛刻要求，因此加密货币的网络可以覆盖很广，对网络的编程也变得灵活很多。理论上，只要能保证联通的便捷和快速，具体设计中不需要考虑更多复杂的因素。当然，就亿书这款产品而言，独有的用户协作和分享功能，对网络编程的性能有自身的要求，就另当别论，这方面将在下一个版本中体现出来。 这里，仅仅是加密货币基础网络功能，交易广播到网络的流程如下： 5、转账交易分析 前面几篇，我们接触到几种交易类型，比如：注册别名地址和多重签名地址，不过并没有研究具体的交易过程，下面通过分析转账交易来学习整个交易、验证的过程。 代码实现在modules/transactions.js文件里，主要Api如下： // 148行 router.map(shared, { &quot;get /&quot;: &quot;getTransactions&quot;, &quot;get /get&quot;: &quot;getTransaction&quot;, &quot;get /unconfirmed/get&quot;: &quot;getUnconfirmedTransaction&quot;, &quot;get /unconfirmed&quot;: &quot;getUnconfirmedTransactions&quot;, &quot;put /&quot;: &quot;addTransactions&quot; }); // 160行 library.network.app.use(&#39;/api/transactions&#39;, router); 解析一下，就是： get /api/transactions/ -&gt; shared.getTransactions get /api/transactions/get -&gt; shared.getTransaction get /api/transactions/unconfirmed/get -&gt; shared.getUnconfirmedTransaction get /api/transactions/unconfirmed -&gt; shared.getUnconfirmedTransactions put /api/transactions/ -&gt; shared.addTransactions 我们仍然把读取数据的Api放一放，因为他们很简单，重点掌握写数据的操作，put /api/transactions/，对应方法shared.addTransactions，代码如下： // 652行 shared.addTransactions = function (req, cb) { var body = req.body; library.scheme.validate(body, { type: &quot;object&quot;, properties: { secret: { type: &quot;string&quot;, minLength: 1, maxLength: 100 }, amount: { type: &quot;integer&quot;, minimum: 1, maximum: constants.totalAmount }, recipientId: { type: &quot;string&quot;, minLength: 1 }, publicKey: { type: &quot;string&quot;, format: &quot;publicKey&quot; }, secondSecret: { type: &quot;string&quot;, minLength: 1, maxLength: 100 }, multisigAccountPublicKey: { type: &quot;string&quot;, format: &quot;publicKey&quot; } }, // required: [&quot;secret&quot;, &quot;amount&quot;, &quot;recipientId&quot;] }, function (err) { // 验证数据格式 if (err) { return cb(err[0].message); } // 验证密码信息 var hash = crypto.createHash(&#39;sha256&#39;).update(body.secret, &#39;utf8&#39;).digest(); var keypair = ed.MakeKeypair(hash); if (body.publicKey) { if (keypair.publicKey.toString(&#39;hex&#39;) != body.publicKey) { return cb(&quot;Invalid passphrase&quot;); } } var query = {}; // 乙方（接收方）地址转换，保证可以用户名转账 var isAddress = /^[0-9]+[L|l]$/g; if (isAddress.test(body.recipientId)) { query.address = body.recipientId; } else { query.username = body.recipientId; } library.balancesSequence.add(function (cb) { // 验证乙方用户合法性 modules.accounts.getAccount(query, function (err, recipient) { if (err) { return cb(err.toString()); } if (!recipient &amp;&amp; query.username) { return cb(&quot;Recipient not found&quot;); } var recipientId = recipient ? recipient.address : body.recipientId; var recipientUsername = recipient ? recipient.username : null; // 验证甲方（发送方）用户合法性 if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { // 验证多重签名 modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) { if (err) { return cb(err.toString()); } // 多重签名帐号不存在 if (!account || !account.publicKey) { return cb(&quot;Multisignature account not found&quot;); } // 多重签名帐号未激活 if (!account || !account.multisignatures) { return cb(&quot;Account does not have multisignatures enabled&quot;); } // 帐号不属于该多重签名组 if (account.multisignatures.indexOf(keypair.publicKey.toString(&#39;hex&#39;)) &lt; 0) { return cb(&quot;Account does not belong to multisignature group&quot;); } // 接着验证甲方（发送方）用户合法性 modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) { if (err) { return cb(err.toString()); } // 甲方帐号不存在 if (!requester || !requester.publicKey) { return cb(&quot;Invalid requester&quot;); } // 甲方支付密码（二次签名）不正确 if (requester.secondSignature &amp;&amp; !body.secondSecret) { return cb(&quot;Invalid second passphrase&quot;); } // 甲方帐号公钥与多重签名帐号公钥是不一样的（因为两个账户是不一样的） if (requester.publicKey == account.publicKey) { return cb(&quot;Invalid requester&quot;); } var secondKeypair = null; if (requester.secondSignature) { var secondHash = crypto.createHash(&#39;sha256&#39;).update(body.secondSecret, &#39;utf8&#39;).digest(); secondKeypair = ed.MakeKeypair(secondHash); } try { // 763行 把上述数据整理成需要的交易数据结构，并给交易添加时间戳、签名、生成ID、计算交易费等 var transaction = library.logic.transaction.create({ type: TransactionTypes.SEND, amount: body.amount, sender: account, recipientId: recipientId, recipientUsername: recipientUsername, keypair: keypair, requester: keypair, secondKeypair: secondKeypair }); } catch (e) { return cb(e.toString()); } // 776行 处理交易 modules.transactions.receiveTransactions([transaction], cb); }); }); } else { // 直接验证甲方（发送方）用户合法性，这里的请求者requester就是发出交易者sender ... }); } 上面这段代码涉及到的就是生成交易数据，这与之前的《地址》、《签名和多重签名》里提到的功能性交易差不多，这里把该方法代码完整粘贴出来，具体逻辑请看代码里的注释和前面的流程图。 接下来，776行，通过receiveTransactions方法处理交易，该方法最终调用的是下面的方法。关键部分，已经添加了注释，请结合上面的流程图阅读，不再详述。 // modules/transactions.js文件 // 337行 Transactions.prototype.processUnconfirmedTransaction = function (transaction, broadcast, cb) { modules.accounts.setAccountAndGet({publicKey: transaction.senderPublicKey}, function (err, sender) { // 这是个闭包，在下面的程序运行结束的时候才调用，因此是验证完毕，才写入区块链、广播到网络 function done(err) { if (err) { return cb(err); } // 这里 加入区块链 操作 private.addUnconfirmedTransaction(transaction, sender, function (err) { if (err) { return cb(err); } // 触发事件，广播到网络 library.bus.message(&#39;unconfirmedTransaction&#39;, transaction, broadcast); cb(); }); } if (err) { return done(err); } if (transaction.requesterPublicKey &amp;&amp; sender &amp;&amp; sender.multisignatures &amp;&amp; sender.multisignatures.length) { modules.accounts.getAccount({publicKey: transaction.requesterPublicKey}, function (err, requester) { if (err) { return done(err); } if (!requester) { return cb(&quot;Invalid requester&quot;); } // 开始执行一系列验证，包括交易是不是已经存在 library.logic.transaction.process(transaction, sender, requester, function (err, transaction) { if (err) { return done(err); } // 检查是否交易已经存在（包括双花交易） if (private.unconfirmedTransactionsIdIndex[transaction.id] !== undefined || private.doubleSpendingTransactions[transaction.id]) { return cb(&quot;Transaction already exists&quot;); } // 这里是 直接验证交易签名等信息，接着调用闭包 done()，把交易写入区块链并广播到网络 library.logic.transaction.verify(transaction, sender, done); }); }); } else { ... } 总结 这里的编码逻辑非常清晰，但作为非常核心的部分，使用了大量编程技巧，需要比较熟练的开发技能。代码中涉及到大量的回调和验证，有的回调嵌套很深，需要对异步较为深入的理解，掌握熟练的回调处理方法，不然理解和编码都会有很多困扰。因此，好好熟悉基本编码技巧，从小处着手打好基础很重要。 本文涉及的流程图相对比较复杂，为了印刷方便，我把完整的流程图拆分成为四张，处理过程花费了大量时间，但是很多细节仍然无法照顾到，也无法保证没有错误和疏漏，请看到问题的小伙伴及时反馈给我。 交易是怎么写入区块链的，上面仅仅点到为止，不够详细和深入。为了进一步阐述区块链的原理，需要专门拿出一篇来，详细讲述。而且，作为目前加密货币的“网红”，区块链也值得我们好好研究。请看下一篇：《神秘的区块链》 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 电子书阅读： http://bitcoin-on-nodejs.ebookchain.org 亿书官网： http://ebookchain.org 亿书官方QQ群：185046161（亿书完全开源开放，欢迎各界小伙伴参与） 参考 亿书白皮书： http://ebookchain.org/ebookchain.pdf 精通比特币（英文） 精通比特币（中文） 阅读更多","@type":"BlogPosting","url":"/2016/07/09/6ff3e9b1b6cacf37620762e8b12e5da0.html","headline":"《Nodejs开发加密货币》之二十一：交易","dateModified":"2016-07-09T00:00:00+08:00","datePublished":"2016-07-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2016/07/09/6ff3e9b1b6cacf37620762e8b12e5da0.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>《Nodejs开发加密货币》之二十一：交易</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <p><strong>题外话</strong>：这篇文章，耗费了我大量精力，用UML表达javascript类及流程本来就不是什么容易的事情，用来描述加密货币<code>交易</code>这种验证逻辑非常多的代码更难，加之Nodejs的回调在这些代码里嵌套很深，所以如何把异步调用变成人类容易理解的顺序调用，也做了一番取舍，时间不知不觉就过了一星期。</p> 
  <p>所幸，赶在比特币减半的今天完成并发布这篇文章，也算在区块链火热的今天，《Nodejs开发加密货币》走到了一个关键节点：触及了加密货币的灵魂和腹地。动辄几千一枚的比特币等加密货币可能会消亡，但是背后的技术却蓬勃发展，玩技术的要善于把握先机，抢占技术高点，让自己时刻成为稀缺的资源，自身价值才能一路高升。</p> 
  <p>本书是市面上唯一一本讲解Nodejs开发加密货币的实践书籍，与那些纯粹为了举例而提供的代码示例不同，全书代码，哪怕是前端代码实例，都是来自正在运行的真实项目，所以无论您是学习Nodejs技术找寻实践项目，还是学习前端设计、web开发等，或者深入区块链研究，都值得参考。</p> 
  <p>书中项目亿书完全开源，本书完全开源，链接在文末，敬请关注或参与。</p> 
  <h2 id="前言"><strong>前言</strong></h2> 
  <p>我们在第一部分《了解加密货币》里说过，加密货币是“利益”转移的程序化，其核心目标是保证数字财富或价值安全、透明、快速的转移。因此，交易是加密货币系统中最重要的部分，加密货币的核心就是<code>交易</code>，加密解密、P2P网络、区块链等一系列技术都是围绕交易展开的。</p> 
  <p>这一篇，我们就来研究亿书提供的交易类型及代码实现，集中总结交易的生命周期及实现过程，把在《地址》和《签名和多重签名》里故意漏掉的判断逻辑补充完整。</p> 
  <h2 id="源码"><strong>源码</strong></h2> 
  <p>transaction-types.js <a href="https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/helpers/transaction-types.js" rel="nofollow">https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/helpers/transaction-types.js</a></p> 
  <p>transaction.js <a href="https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/logic/transaction.js" rel="nofollow">https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/logic/transaction.js</a></p> 
  <p>transactions.js <a href="https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/transactions.js" rel="nofollow">https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/transactions.js</a></p> 
  <h2 id="类图"><strong>类图</strong></h2> 
  <p><img src="https://img-blog.csdn.net/20160709065907461" alt="transactions-clase.png" title=""></p> 
  <h2 id="解读"><strong>解读</strong></h2> 
  <h4 id="1交易的本质"><strong>1、交易的本质</strong></h4> 
  <p>从经济学角度来说，交易就是一种价值交换。在《精通比特币》（见参考）一书里，作者是这样定义比特币交易的：简单地说，交易是指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”就是一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。</p> 
  <p>交易，在汉语词典里，既可以是名词，代表交易内容的数据信息（技术上叫做数据结构），又可以是动词，代表一个操作过程。把这些重要信息汇总到一起，既让用户容易理解，又要体现加密货币特点，可以这样定义一个交易操作：</p> 
  <blockquote> 
   <p>加密货币交易是指人们通过加密货币网络，把加密货币进行有效转移， <br> 并把交易数据保存到区块链的过程。</p> 
  </blockquote> 
  <p>这个定义与我们的直观感受比较接近。通常，大家喜欢把加密货币交易，比做纸质支票，支票本身就是记录一笔交易的数据结构，从签署支票到兑付完成的过程就是一个交易操作行为。一笔加密货币交易就是一个有着货币转移目的的电子支票，只有在交易被执行时才会在金融体系中体现，而且交易发起人并不一定是签署该笔交易的人。</p> 
  <p>交易可以被任何人在线上或线下创建，即便创建这笔交易的人不是这个账户的授权签字人。这一点非常好理解，假如有一张空的纸质支票，我们可以自己填写，也可以找人填写，最后只要有支付权限的领导签名，支票就能生效，就可以兑付。加密货币也是如此，无论谁创建的加密货币交易，只要被资金所有者（们）数字签名，交易就能实现。</p> 
  <p>交易只是一些经过加密处理的字节码，不含任何机密信息、私钥或密码，可被包括wifi、无线电在内的任何网络公开传播，甚至可以被处理成二维码、表情符号、短信等形式发送。只要这笔交易能进入加密货币网络，那么发送者并不需要信任用来传播该笔交易的任何一个网络节点。同时，这些节点也不需要信任发送者，不用记录发送者的任何身份信息。相反，电子商务网站的交易，不仅包含敏感信息，而且依赖加密网络连接完成信息传输。</p> 
  <p>因此，从本质上讲，加密货币交易是价值所有权的变更，价值转移仅仅是这种行为的结果。加密货币总量就是那些，从始至终都不会变化，人为丢失的是人类流通使用的私钥权限，总量仍在网络上不会丢失。记录加密货币总量的区块链就那一条，这个链条可以越来越长，越来越大，但是增加的仅仅是交易信息，即价值所有权变更信息。用个不慎确切的比喻，加密货币就像一列永不停息的火车，上下的是人次，固定的是座位，您只有在自己的人生旅途中才拥有某个座位的所有权（使用权）。</p> 
  <p>从设计原理上说，加密货币淡化了交易者帐号，简化为输入输出，所谓的账户也只是存在于客户端钱包这类具体的应用层的软件里，就像那列火车总要有火车站吧，而某一段旅程的火车票是有具体所属的，是要与现实人的帐号或身份对应的，所以火车站是要记录用户信息，要有检票、验票的过程。</p> 
  <p>亿书的原理也是如此，只不过亿书通过进一步扩展交易类型，强化了用户帐号的存在，使得更加适合处理各类资产所有权，从而为数字版权保护奠定良好架构基础。</p> 
  <h4 id="2交易生命周期"><strong>2、交易生命周期</strong></h4> 
  <p>加密货币的整个系统，都是为了确保正确地生成交易、快速地传播和验证交易，并最终写入全球交易总账簿——区块链而设计。因此，从开发设计角度考虑，一笔交易必须包括下列过程：</p> 
  <ol> 
   <li>生成一笔交易。这里是指一条包含交易双方加密货币地址、数量、时间戳和有效签名等信息，而且不含任何私密信息的合法交易数据;</li> 
   <li>广播到网络。几乎每个节点都会获得这笔交易数据。</li> 
   <li>验证交易合法性。生成交易的节点和其他节点都要验证，没有得到验证的交易，是不能进入加密货币网络的。</li> 
   <li>写入区块链。</li> 
  </ol> 
  <p>下面，我们来详细阅读分析亿书的交易是如何实现的。</p> 
  <h4 id="3亿书交易类型"><strong>3、亿书交易类型</strong></h4> 
  <p>目前，亿书已经完成或正在开发的交易类型，包括14种（后续会有更多），分别是：</p> 
  <pre class="prettyprint"><code class=" hljs fsharp"><span class="hljs-comment">// helpers/transaction-types.js</span>
<span class="hljs-keyword">module</span>.exports = {
    SEND : <span class="hljs-number">0</span>,
    SIGNATURE : <span class="hljs-number">1</span>,
    DELEGATE : <span class="hljs-number">2</span>,
    VOTE : <span class="hljs-number">3</span>,
    USERNAME : <span class="hljs-number">4</span>,
    FOLLOW : <span class="hljs-number">5</span>,
    MULTI: <span class="hljs-number">6</span>,
    DAPP: <span class="hljs-number">7</span>,
    IN_TRANSFER: <span class="hljs-number">8</span>,
    OUT_TRANSFER: <span class="hljs-number">9</span>,
    ARTICALE : <span class="hljs-number">10</span>,
    EBOOK: <span class="hljs-number">11</span>，
  BUY: <span class="hljs-number">12</span>，
    READ: <span class="hljs-number">13</span>
}</code></pre> 
  <p>其中，</p> 
  <p><code>SEND</code>是最基本的转账交易，<code>SIGNATURE</code>是上一篇提到的“签名”交易，<code>DELEGATE</code>是注册为受托人，<code>VOTE</code>是投票，<code>USERNAME</code>是注册用户别名地址，<code>FOLLOW</code>是添加联系人，<code>MULTI</code>是注册多重签名帐号，<code>DAPP</code>是侧链应用，<code>IN_TRANSFER</code>是转入Aapp资金，<code>OUT_TRANSFER</code>转出Aapp资金，这些是现有版本已经完成的功能。</p> 
  <p><code>ARTICALE</code>是发布文章，<code>EBOOK</code>是发布电子书，<code>BUY</code>是购买（电子书或其他商品），<code>READ</code>是付费阅读（电子书等），这些功能会逐步添加。</p> 
  <p>这些交易，除了<code>SEND</code>转账交易外，其他的交易类型，我们暂且称它们为功能性交易（在比特币的圈子里，有人称为伪交易）。</p> 
  <h4 id="4交易基本流程"><strong>4、交易基本流程</strong></h4> 
  <p>亿书交易类型尽管多样，但是交易的基本逻辑是一样的。整个加密货币都是交易逻辑的有效组成部分，要比传统电子商务网站复杂的多，但与交易直接相关的代码，却又非常简单清晰。从开发角度说，实现一笔交易，亿书需要这样几个步骤：</p> 
  <p>（1）生成交易数据</p> 
  <p>交易是人类行为，涉及到甲乙双方（货币发送者和接收者，我们用甲乙方来代替，下文同）和交易数额，这在很多交易，特别是版权交易方面更加重要。甲方是主动发起交易的有效用户，是亿书币的支付方，是交易的支付来源。乙方比较灵活，可以是另一个有合法地址的用户，也可以是亿书系统本身（功能性交易），是亿书币的接收方。</p> 
  <p>简单的一句话就是：谁与谁交易了多少钱。用下面转账交易部分的代码举例，请看<code>modules/transactions.js</code>文件里的763和800行，一笔交易必须包含如下字段：</p> 
  <ul> 
   <li>交易类型。代码里表示为 type: TransactionTypes.SEND;</li> 
   <li>支付帐号。代码里指的是 sender: account;</li> 
   <li>接受帐号。代码里指的是 recipientId: recipientId, 如果用的是别名地址，就是 recipientUsername: recipientUsername，如果是功能性交易，这里就不需要了;</li> 
   <li>交易数量。代码里指的是 amount: body.amount。</li> 
  </ul> 
  <p>这些数据有的要求用户输入，比如用户密钥，交易数量等，这些数据是否正确，也是非常关键的事情。这是软件程序验证逻辑的一个重要部分，不可或缺。这个很好理解，如果一个人胡乱填写密钥和接受地址，也能把币发送出去，那就笑话了。但具体校验过程较为繁琐，这里主要涉及到：发起交易的用户是否存在、密钥是否正确、是否多重签名帐号、是否有支付密码，以及接受方用户地址是否合法等，都要逐个检验。</p> 
  <p>详情看这里的流程图：</p> 
  <p><img src="https://img-blog.csdn.net/20160709065508018" alt="addTransaction-activity.png" title=""></p> 
  <p>（2）给合法交易签名</p> 
  <p>基本信息正确之后，一笔合法交易，还要使用甲乙方的公钥签名，确保交易所属。同时，还要准确记录它的交易时间戳，方便追溯。还要生成交易ID，每个交易ID都包含了丰富的加密信息，需要复杂的生成过程，绝不像传统的网站系统，让数据库自动生成索引就可以充当ID了。</p> 
  <p>详情看这里的流程图：</p> 
  <p><img src="https://img-blog.csdn.net/20160709065557050" alt="signTransaction-activity.png" title=""></p> 
  <p>（3）验证交易合法性</p> 
  <p>通常，一笔交易经过6-10个区块之后，这笔交易被认为是无法更改的，即已确认，因为这时候拒绝、变更的难度已经非常大，理论上已经不可能。这里的交易合法性，除了基本信息正确之外，主要是指保证交易是未确认的交易，也不是用户重复提交的交易，即双花交易。双花交易是加密货币特有的现象，通俗的说，就是用户在交易确认之前（有一段时间，比特币时间更长），又一次提交了相同交易信息，导致一笔钱花两次，这种情况是必须要避免的。</p> 
  <p>每笔交易在广播到网络之前必须验证合法性，不合法的交易没有机会广播到网络。节点收到新的交易信息时，要重新验证。如此一来，任何对网络的攻击，都只会影响一个节点，安全性大大提高。</p> 
  <p>验证合法的交易就可以直接加入区块链了，因此从上面的第一步到现在，亿书都是在一个节点上完成的。这也为下面的广播处理打下基础，一旦交易被广播到网络，在其他节点，这里的验证和处理过程就会重复执行一次。</p> 
  <p>验证的过程，看这里的流程图：</p> 
  <p><img src="https://img-blog.csdn.net/20160709065644958" alt="verifyTransaction-activity.png" title=""></p> 
  <p>（4）广播到点对点网络</p> 
  <p>没有中心服务器，必须借助点对点网络，把交易数据写入分布式公共账本——区块链，保证交易数据永远无法篡改，而且可以轻松查询追溯。这在中心化的服务器上，为了应对个别交易摩擦，保证交易记录可追溯，要采取更多的技术手段，记录更多的数据字段，意味着要保持大量数据冗余，付出更多资金成本。</p> 
  <p>因为交易数据不含私密信息，对网络没有苛刻要求，因此加密货币的网络可以覆盖很广，对网络的编程也变得灵活很多。理论上，只要能保证联通的便捷和快速，具体设计中不需要考虑更多复杂的因素。当然，就亿书这款产品而言，独有的用户协作和分享功能，对网络编程的性能有自身的要求，就另当别论，这方面将在下一个版本中体现出来。</p> 
  <p>这里，仅仅是加密货币基础网络功能，交易广播到网络的流程如下：</p> 
  <p><img src="https://img-blog.csdn.net/20160709065727941" alt="broadcastTransaction-activity.png" title=""></p> 
  <h4 id="5转账交易分析">5、转账交易分析</h4> 
  <p>前面几篇，我们接触到几种交易类型，比如：注册别名地址和多重签名地址，不过并没有研究具体的交易过程，下面通过分析<code>转账交易</code>来学习整个交易、验证的过程。</p> 
  <p>代码实现在<code>modules/transactions.js</code>文件里，主要Api如下：</p> 
  <pre class="prettyprint"><code class=" hljs rust"><span class="hljs-comment">// 148行</span>
router.map(shared, {
  <span class="hljs-string">"get /"</span>: <span class="hljs-string">"getTransactions"</span>,
  <span class="hljs-string">"get /get"</span>: <span class="hljs-string">"getTransaction"</span>,
  <span class="hljs-string">"get /unconfirmed/get"</span>: <span class="hljs-string">"getUnconfirmedTransaction"</span>,
  <span class="hljs-string">"get /unconfirmed"</span>: <span class="hljs-string">"getUnconfirmedTransactions"</span>,
  <span class="hljs-string">"put /"</span>: <span class="hljs-string">"addTransactions"</span>
});

<span class="hljs-comment">// 160行</span>
library.network.app.<span class="hljs-keyword">use</span>(<span class="hljs-string">'/api/transactions'</span>, router);</code></pre> 
  <p>解析一下，就是：</p> 
  <pre class="prettyprint"><code class=" hljs vbnet"><span class="hljs-keyword">get</span> /api/transactions/ -&gt; <span class="hljs-keyword">shared</span>.getTransactions
<span class="hljs-keyword">get</span> /api/transactions/<span class="hljs-keyword">get</span> -&gt; <span class="hljs-keyword">shared</span>.getTransaction
<span class="hljs-keyword">get</span> /api/transactions/unconfirmed/<span class="hljs-keyword">get</span> -&gt; <span class="hljs-keyword">shared</span>.getUnconfirmedTransaction
<span class="hljs-keyword">get</span> /api/transactions/unconfirmed -&gt; <span class="hljs-keyword">shared</span>.getUnconfirmedTransactions
put /api/transactions/ -&gt; <span class="hljs-keyword">shared</span>.addTransactions</code></pre> 
  <p>我们仍然把读取数据的Api放一放，因为他们很简单，重点掌握写数据的操作，<code>put /api/transactions/</code>，对应方法<code>shared.addTransactions</code>，代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-comment">// 652行</span>
shared.addTransactions = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, cb)</span> {</span>
    <span class="hljs-keyword">var</span> body = req.body;
    library.scheme.validate(body, {
        type: <span class="hljs-string">"object"</span>,
        properties: {
            secret: {
                type: <span class="hljs-string">"string"</span>,
                minLength: <span class="hljs-number">1</span>,
                maxLength: <span class="hljs-number">100</span>
            },
            amount: {
                type: <span class="hljs-string">"integer"</span>,
                minimum: <span class="hljs-number">1</span>,
                maximum: constants.totalAmount
            },
            recipientId: {
                type: <span class="hljs-string">"string"</span>,
                minLength: <span class="hljs-number">1</span>
            },
            publicKey: {
                type: <span class="hljs-string">"string"</span>,
                format: <span class="hljs-string">"publicKey"</span>
            },
            secondSecret: {
                type: <span class="hljs-string">"string"</span>,
                minLength: <span class="hljs-number">1</span>,
                maxLength: <span class="hljs-number">100</span>
            },
            multisigAccountPublicKey: {
                type: <span class="hljs-string">"string"</span>,
                format: <span class="hljs-string">"publicKey"</span>
            }
        },
        <span class="hljs-comment">//</span>
        required: [<span class="hljs-string">"secret"</span>, <span class="hljs-string">"amount"</span>, <span class="hljs-string">"recipientId"</span>]
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
        <span class="hljs-comment">// 验证数据格式</span>
        <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-keyword">return</span> cb(err[<span class="hljs-number">0</span>].message);
        }

        <span class="hljs-comment">// 验证密码信息</span>
        <span class="hljs-keyword">var</span> hash = crypto.createHash(<span class="hljs-string">'sha256'</span>).update(body.secret, <span class="hljs-string">'utf8'</span>).digest();
        <span class="hljs-keyword">var</span> keypair = ed.MakeKeypair(hash);

        <span class="hljs-keyword">if</span> (body.publicKey) {
            <span class="hljs-keyword">if</span> (keypair.publicKey.toString(<span class="hljs-string">'hex'</span>) != body.publicKey) {
                <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Invalid passphrase"</span>);
            }
        }

        <span class="hljs-keyword">var</span> query = {};

        <span class="hljs-comment">// 乙方（接收方）地址转换，保证可以用户名转账</span>
        <span class="hljs-keyword">var</span> isAddress = <span class="hljs-regexp">/^[0-9]+[L|l]$/g</span>;
        <span class="hljs-keyword">if</span> (isAddress.test(body.recipientId)) {
            query.address = body.recipientId;
        } <span class="hljs-keyword">else</span> {
            query.username = body.recipientId;
        }

        library.balancesSequence.add(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> {</span>
            <span class="hljs-comment">// 验证乙方用户合法性</span>
            modules.accounts.getAccount(query, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, recipient)</span> {</span>
                <span class="hljs-keyword">if</span> (err) {
                    <span class="hljs-keyword">return</span> cb(err.toString());
                }
                <span class="hljs-keyword">if</span> (!recipient &amp;&amp; query.username) {
                    <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Recipient not found"</span>);
                }

                <span class="hljs-keyword">var</span> recipientId = recipient ? recipient.address : body.recipientId;
                <span class="hljs-keyword">var</span> recipientUsername = recipient ? recipient.username : <span class="hljs-literal">null</span>;

                <span class="hljs-comment">// 验证甲方（发送方）用户合法性</span>
                <span class="hljs-keyword">if</span> (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(<span class="hljs-string">'hex'</span>)) {
                    <span class="hljs-comment">// 验证多重签名</span>
                    modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, account)</span> {</span>
                        <span class="hljs-keyword">if</span> (err) {
                            <span class="hljs-keyword">return</span> cb(err.toString());
                        }
                        <span class="hljs-comment">// 多重签名帐号不存在</span>
                        <span class="hljs-keyword">if</span> (!account || !account.publicKey) {
                            <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Multisignature account not found"</span>);
                        }
                        <span class="hljs-comment">// 多重签名帐号未激活</span>
                        <span class="hljs-keyword">if</span> (!account || !account.multisignatures) {
                            <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Account does not have multisignatures enabled"</span>);
                        }
                        <span class="hljs-comment">// 帐号不属于该多重签名组</span>
                        <span class="hljs-keyword">if</span> (account.multisignatures.indexOf(keypair.publicKey.toString(<span class="hljs-string">'hex'</span>)) &lt; <span class="hljs-number">0</span>) {
                            <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Account does not belong to multisignature group"</span>);
                        }

                        <span class="hljs-comment">// 接着验证甲方（发送方）用户合法性</span>
                        modules.accounts.getAccount({publicKey: keypair.publicKey}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, requester)</span> {</span>
                            <span class="hljs-keyword">if</span> (err) {
                                <span class="hljs-keyword">return</span> cb(err.toString());
                            }
                            <span class="hljs-comment">// 甲方帐号不存在</span>
                            <span class="hljs-keyword">if</span> (!requester || !requester.publicKey) {
                                <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Invalid requester"</span>);
                            }

                            <span class="hljs-comment">// 甲方支付密码（二次签名）不正确</span>
                            <span class="hljs-keyword">if</span> (requester.secondSignature &amp;&amp; !body.secondSecret) {
                                <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Invalid second passphrase"</span>);
                            }

                            <span class="hljs-comment">// 甲方帐号公钥与多重签名帐号公钥是不一样的（因为两个账户是不一样的）</span>
                            <span class="hljs-keyword">if</span> (requester.publicKey == account.publicKey) {
                                <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Invalid requester"</span>);
                            }

                            <span class="hljs-keyword">var</span> secondKeypair = <span class="hljs-literal">null</span>;

                            <span class="hljs-keyword">if</span> (requester.secondSignature) {
                                <span class="hljs-keyword">var</span> secondHash = crypto.createHash(<span class="hljs-string">'sha256'</span>).update(body.secondSecret, <span class="hljs-string">'utf8'</span>).digest();
                                secondKeypair = ed.MakeKeypair(secondHash);
                            }

                            <span class="hljs-keyword">try</span> {
                                <span class="hljs-comment">// 763行 把上述数据整理成需要的交易数据结构，并给交易添加时间戳、签名、生成ID、计算交易费等</span>
                                <span class="hljs-keyword">var</span> transaction = library.logic.transaction.create({
                                    type: TransactionTypes.SEND,
                                    amount: body.amount,
                                    sender: account,
                                    recipientId: recipientId,
                                    recipientUsername: recipientUsername,
                                    keypair: keypair,
                                    requester: keypair,
                                    secondKeypair: secondKeypair
                                });
                            } <span class="hljs-keyword">catch</span> (e) {
                                <span class="hljs-keyword">return</span> cb(e.toString());
                            }

                            <span class="hljs-comment">// 776行 处理交易</span>
                            modules.transactions.receiveTransactions([transaction], cb);
                        });
                    });
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 直接验证甲方（发送方）用户合法性，这里的请求者requester就是发出交易者sender </span>
                    ...
    });
}</code></pre> 
  <p>上面这段代码涉及到的就是生成交易数据，这与之前的《地址》、《签名和多重签名》里提到的功能性交易差不多，这里把该方法代码完整粘贴出来，具体逻辑请看代码里的注释和前面的流程图。</p> 
  <p>接下来，776行，通过<code>receiveTransactions</code>方法处理交易，该方法最终调用的是下面的方法。关键部分，已经添加了注释，请结合上面的流程图阅读，不再详述。</p> 
  <pre class="prettyprint"><code class=" hljs actionscript"><span class="hljs-comment">// modules/transactions.js文件</span>
<span class="hljs-comment">// 337行</span>
Transactions.prototype.processUnconfirmedTransaction = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(transaction, broadcast, cb)</span> {</span>
    modules.accounts.setAccountAndGet({publicKey: transaction.senderPublicKey}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, sender)</span> {</span>
        <span class="hljs-comment">// 这是个闭包，在下面的程序运行结束的时候才调用，因此是验证完毕，才写入区块链、广播到网络</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">done</span><span class="hljs-params">(err)</span> {</span>
            <span class="hljs-keyword">if</span> (err) {
                <span class="hljs-keyword">return</span> cb(err);
            }
            <span class="hljs-comment">// 这里 加入区块链 操作</span>
            <span class="hljs-keyword">private</span>.addUnconfirmedTransaction(transaction, sender, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
                <span class="hljs-keyword">if</span> (err) {
                    <span class="hljs-keyword">return</span> cb(err);
                }
                <span class="hljs-comment">// 触发事件，广播到网络</span>
                library.bus.message(<span class="hljs-string">'unconfirmedTransaction'</span>, transaction, broadcast);

                cb();
            });
        }

        <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-keyword">return</span> done(err);
        }

        <span class="hljs-keyword">if</span> (transaction.requesterPublicKey &amp;&amp; sender &amp;&amp; sender.multisignatures &amp;&amp; sender.multisignatures.length) {
            modules.accounts.getAccount({publicKey: transaction.requesterPublicKey}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, requester)</span> {</span>
                <span class="hljs-keyword">if</span> (err) {
                    <span class="hljs-keyword">return</span> done(err);
                }

                <span class="hljs-keyword">if</span> (!requester) {
                    <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Invalid requester"</span>);
                }
                <span class="hljs-comment">// 开始执行一系列验证，包括交易是不是已经存在</span>
                library.logic.transaction.process(transaction, sender, requester, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, transaction)</span> {</span>
                    <span class="hljs-keyword">if</span> (err) {
                        <span class="hljs-keyword">return</span> done(err);
                    }

                    <span class="hljs-comment">// 检查是否交易已经存在（包括双花交易）</span>
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">private</span>.unconfirmedTransactionsIdIndex[transaction.id] !== <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">private</span>.doubleSpendingTransactions[transaction.id]) {
                        <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Transaction already exists"</span>);
                    }
                    <span class="hljs-comment">// 这里是 直接验证交易签名等信息，接着调用闭包 done()，把交易写入区块链并广播到网络</span>
                    library.logic.transaction.verify(transaction, sender, done);
                });
            });
        } <span class="hljs-keyword">else</span> {
            ...
}</code></pre> 
  <h2 id="总结"><strong>总结</strong></h2> 
  <p>这里的编码逻辑非常清晰，但作为非常核心的部分，使用了大量编程技巧，需要比较熟练的开发技能。代码中涉及到大量的回调和验证，有的回调嵌套很深，需要对异步较为深入的理解，掌握熟练的回调处理方法，不然理解和编码都会有很多困扰。因此，好好熟悉基本编码技巧，从小处着手打好基础很重要。</p> 
  <p>本文涉及的流程图相对比较复杂，为了印刷方便，我把完整的流程图拆分成为四张，处理过程花费了大量时间，但是很多细节仍然无法照顾到，也无法保证没有错误和疏漏，请看到问题的小伙伴及时反馈给我。</p> 
  <p>交易是怎么写入区块链的，上面仅仅点到为止，不够详细和深入。为了进一步阐述区块链的原理，需要专门拿出一篇来，详细讲述。而且，作为目前加密货币的“网红”，区块链也值得我们好好研究。请看下一篇：<strong>《神秘的区块链》</strong></p> 
  <h2 id="链接"><strong>链接</strong></h2> 
  <p><strong>本系列文章即时更新，若要掌握最新内容，请关注下面的链接</strong></p> 
  <p>本源文地址： <a href="https://github.com/imfly/bitcoin-on-nodejs" rel="nofollow">https://github.com/imfly/bitcoin-on-nodejs</a></p> 
  <p>电子书阅读： <a href="http://bitcoin-on-nodejs.ebookchain.org/3-源码解读/6-签名和多重签名.html" rel="nofollow">http://bitcoin-on-nodejs.ebookchain.org</a></p> 
  <p>亿书官网： <a href="http://ebookchain.org" rel="nofollow">http://ebookchain.org</a></p> 
  <p>亿书官方QQ群：185046161（亿书完全开源开放，欢迎各界小伙伴参与）</p> 
  <h2 id="参考">参考</h2> 
  <p>亿书白皮书： <a href="http://ebookchain.org/ebookchain.pdf" rel="nofollow">http://ebookchain.org/ebookchain.pdf</a></p> 
  <p><a href="https://github.com/imfly/bitcoinbook" rel="nofollow">精通比特币（英文）</a></p> 
  <p><a href="http://book.8btc.com/master_bitcoin" rel="nofollow">精通比特币（中文）</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/imfly/article/details/51864946,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/imfly/article/details/51864946,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
