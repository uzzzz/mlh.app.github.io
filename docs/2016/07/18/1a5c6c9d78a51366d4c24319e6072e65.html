<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【Leetcode 动态规划】 买卖股票 I II III IV 冷却，共5题 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【Leetcode 动态规划】 买卖股票 I II III IV 冷却，共5题" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="转自http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html Best Time to Buy and Sell Stock I Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to findthe maximum profit. 题意：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。 如果只允许进行一次交易，也就是说只允许买一支股票并卖掉，求最大的收益。 分析：动态规划法。从前向后遍历数组，记录当前出现过的最低价格，作为买入价格，并计算以当天价格出售的收益，作为可能的最大收益，整个遍历过程中，出现过的最大收益就是所求。 代码：O(n)时间，O(1)空间。 public class Solution { public int maxProfit(int[] prices) { if (prices.length &lt; 2) return 0; int maxProfit = 0; int curMin = prices[0]; for (int i = 1; i &lt; prices.length; i++) { curMin = Math.min(curMin, prices[i]); maxProfit = Math.max(maxProfit, prices[i] - curMin); } return maxProfit; } } Best Time to Buy and Sell Stock II Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。交易次数不限，但一次只能交易一支股票，也就是说手上最多只能持有一支股票，求最大收益。 分析：贪心法。从前向后遍历数组，只要当天的价格高于前一天的价格，就算入收益。 代码：时间O(n)，空间O(1)。 public class Solution { public int maxProfit(int[] prices) { if (prices.length &lt; 2) return 0; int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) { int diff = prices[i] - prices[i - 1]; if (diff &gt; 0) { maxProfit += diff; } } return maxProfit; } } Best Time to Buy and Sell Stock III Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题意：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。最多交易两次，手上最多只能持有一支股票，求最大收益。 分析：动态规划法。以第i天为分界线，计算第i天之前进行一次交易的最大收益preProfit[i]，和第i天之后进行一次交易的最大收益postProfit[i]，最后遍历一遍，max{preProfit[i] + postProfit[i]} (0≤i≤n-1)就是最大收益。第i天之前和第i天之后进行一次的最大收益求法同Best Time to Buy and Sell Stock I。 代码：时间O(n)，空间O(n)。 public class Solution { public int maxProfit(int[] prices) { if (prices.length &lt; 2) return 0; int n = prices.length; int[] preProfit = new int[n]; int[] postProfit = new int[n]; int curMin = prices[0]; for (int i = 1; i &lt; n; i++) { curMin = Math.min(curMin, prices[i]); preProfit[i] = Math.max(preProfit[i - 1], prices[i] - curMin);//第i天卖出 } int curMax = prices[n - 1]; for (int i = n - 2; i &gt;= 0; i--) {//从后往前遍历 curMax = Math.max(curMax, prices[i]); postProfit[i] = Math.max(postProfit[i + 1], curMax - prices[i]);//第i天买入 } int maxProfit = 0; for (int i = 0; i &lt; n; i++) { maxProfit = Math.max(maxProfit, preProfit[i] + postProfit[i]); } return maxProfit; } } Best Time to Buy and Sell Stock IV Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题意：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。最多交易k次，手上最多只能持有一支股票，求最大收益。 分析：特殊动态规划法。传统的动态规划我们会这样想，到第i天时进行j次交易的最大收益，要么等于到第i-1天时进行j次交易的最大收益（第i天价格低于第i-1天的价格），要么等于到第i-1天时进行j-1次交易，然后第i天进行一次交易（第i天价格高于第i-1天价格时）。于是得到动规方程如下（其中diff = prices[i] – prices[i – 1]）： profit[i][j] = max(profit[i – 1][j], profit[i – 1][j – 1] + diff) 看起来很有道理，但其实不对，为什么不对呢？因为diff是第i天和第i-1天的差额收益，如果第i-1天当天本身也有交易呢（也就是说第i-1天刚卖出了股票，然后又买入等到第i天再卖出），那么这两次交易就可以合为一次交易，这样profit[i – 1][j – 1] + diff实际上只进行了j-1次交易，而不是最多可以的j次，这样得到的最大收益就小了。 那么怎样计算第i天进行交易的情况的最大收益，才会避免少计算一次交易呢？我们用一个局部最优解和全局最有解表示到第i天进行j次的收益，这就是该动态规划的特殊之处。 我们定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。它们的递推式为（其中diff = prices[i] – prices[i – 1]）：local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)global[i][j] = max(local[i][j], global[i - 1][j])，其中局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值后相比，两者之中取较大值，而全局最优比较局部最优和前一天的全局最优。 local[i][j]和global[i][j]的区别是：local[i][j]意味着在第i天一定有交易（卖出）发生，当第i天的价格高于第i-1天（即diff &gt; 0）时，那么可以把这次交易（第i-1天买入第i天卖出）跟第i-1天的交易（卖出）合并为一次交易，即local[i][j]=local[i-1][j]+diff；当第i天的价格不高于第i-1天（即diff&lt;=0）时，那么local[i][j]=global[i-1][j-1]+diff，而由于diff&lt;=0，所以可写成local[i][j]=global[i-1][j-1]。global[i][j]就是我们所求的前i天最多进行k次交易的最大收益，可分为两种情况：如果第i天没有交易（卖出），那么global[i][j]=global[i-1][j]；如果第i天有交易（卖出），那么global[i][j]=local[i][j]。 参考：http://www.cnblogs.com/grandyang/p/4295761.html 代码：时间O(nk)，空间O(nk)。 public class Solution { public int maxProfit(int k, int[] prices) { if (prices.length &lt; 2) return 0; int days = prices.length; if (k &gt;= days) return maxProfit2(prices); int[][] local = new int[days][k + 1]; int[][] global = new int[days][k + 1]; for (int i = 1; i &lt; days ; i++) { int diff = prices[i] - prices[i - 1]; for (int j = 1; j &lt;= k; j++) { local[i][j] = Math.max(global[i - 1][j - 1], local[i - 1][j] + diff); global[i][j] = Math.max(global[i - 1][j], local[i][j]); } } return global[days - 1][k]; } public int maxProfit2(int[] prices) { int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) { if (prices[i] &gt; prices[i - 1]) { maxProfit += prices[i] - prices[i - 1]; } } return maxProfit; } } 我们知道，动规所用的二维辅助数组可以降为一维的，即只用大小为k的一维数组记录到达第i天时的局部最优解和全局最优解。需要注意的是，由于第i天时交易k次的最优解依赖于第i-1天时交易k-1次的最优解，所以数组更新应当从后往前（即从k到1）更新。 代码：时间O(nk)，空间O(k)。 public class Solution { public int maxProfit(int k, int[] prices) { if (prices.length &lt; 2) return 0; if (k &gt;= prices.length) return maxProfit2(prices); int[] local = new int[k + 1]; int[] global = new int[k + 1]; for (int i = 1; i &lt; prices.length ; i++) { int diff = prices[i] - prices[i - 1]; for (int j = k; j &gt; 0; j--) { local[j] = Math.max(global[j - 1], local[j] + diff); global[j] = Math.max(global[j], local[j]); } } return global[k]; } public int maxProfit2(int[] prices) { int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) { if (prices[i] &gt; prices[i - 1]) { maxProfit += prices[i] - prices[i - 1]; } } return maxProfit; } } 补充：这道题还有一个陷阱，就是当k大于天数时，其实就退化成&nbsp;Best Time to Buy and Sell Stock II&nbsp;了。 另外，Best Time to Buy and Sell Stock III&nbsp;就是本题k=2的情况，所以说IV是II和III的综合。 309. Best Time to Buy and Sell Stock with Cooldown 在第二题（次数不限）的基础上，卖完股票的转天不能买。求最大收益。 分析：http://www.cnblogs.com/grandyang/p/4997417.html 维护三个一维数组buy, sell，和rest。其中：buy[i]表示在第i天之前最后一个操作是买，此时的最大收益。sell[i]表示在第i天之前最后一个操作是卖，此时的最大收益。rest[i]表示在第i天之前最后一个操作是冷冻期，此时的最大收益。我们写出递推式为： buy[i] = max(rest[i-1] - price, buy[i-1]) sell[i] = max(buy[i-1] + price, sell[i-1]) rest[i] = max(sell[i-1], buy[i-1], rest[i-1])上述递推式很好的表示了在买之前有冷冻期，买之前要卖掉之前的股票。一个小技巧是如何保证[buy, rest, buy]的情况不会出现，这是由于buy[i] &lt;= rest[i]， 即rest[i] = max(sell[i-1], rest[i-1])，这保证了[buy, rest, buy]不会出现。 另外，由于冷冻期的存在，我们可以得出rest[i] = sell[i-1]，这样，我们可以将上面三个递推式精简到两个： buy[i] = max(sell[i-2] - price, buy[i-1]) sell[i] = max(buy[i-1] + price, sell[i-1]) 由于i只依赖于i-1和i-2，所以我们可以在O(1)的空间复杂度完成算法: pre_buy = buy;【因为buy是上一轮的，此句含义：pre_buy = buy[i-1]】 buy = max(pre_buy, pre_sell - prices[i]);【此句含义：buy[i]即buy = max（buy[i-1]即pre_buy，sell[i-2]【尚未更新的即上一轮的pre_sell】 - prices[i]）】 pre_sell = sell;【因为sell是上一轮的，此句含义：sell[i-1] = sell】 sell = max(pre_sell, pre_buy + prices[i]);【此句含义：sell[i]即sell = max（sell[i-1]即pre_sell，buy[i-1]【已更新为pre_buy了】 + prices[i]）】 参见代码如下： class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if(n == 0) return 0; int buy = 0x80000000, sell = 0, pre_buy = 0, pre_sell = 0; for(int i = 0; i &lt; n; ++i) {//把buy初值设为-prices[0]，for循环从i = 1开始，也对！ pre_buy = buy; buy = max(pre_buy, pre_sell - prices[i]); pre_sell = sell; sell = max(pre_sell, pre_buy + prices[i]); } return sell; } }; 阅读更多" />
<meta property="og:description" content="转自http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html Best Time to Buy and Sell Stock I Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to findthe maximum profit. 题意：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。 如果只允许进行一次交易，也就是说只允许买一支股票并卖掉，求最大的收益。 分析：动态规划法。从前向后遍历数组，记录当前出现过的最低价格，作为买入价格，并计算以当天价格出售的收益，作为可能的最大收益，整个遍历过程中，出现过的最大收益就是所求。 代码：O(n)时间，O(1)空间。 public class Solution { public int maxProfit(int[] prices) { if (prices.length &lt; 2) return 0; int maxProfit = 0; int curMin = prices[0]; for (int i = 1; i &lt; prices.length; i++) { curMin = Math.min(curMin, prices[i]); maxProfit = Math.max(maxProfit, prices[i] - curMin); } return maxProfit; } } Best Time to Buy and Sell Stock II Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。交易次数不限，但一次只能交易一支股票，也就是说手上最多只能持有一支股票，求最大收益。 分析：贪心法。从前向后遍历数组，只要当天的价格高于前一天的价格，就算入收益。 代码：时间O(n)，空间O(1)。 public class Solution { public int maxProfit(int[] prices) { if (prices.length &lt; 2) return 0; int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) { int diff = prices[i] - prices[i - 1]; if (diff &gt; 0) { maxProfit += diff; } } return maxProfit; } } Best Time to Buy and Sell Stock III Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题意：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。最多交易两次，手上最多只能持有一支股票，求最大收益。 分析：动态规划法。以第i天为分界线，计算第i天之前进行一次交易的最大收益preProfit[i]，和第i天之后进行一次交易的最大收益postProfit[i]，最后遍历一遍，max{preProfit[i] + postProfit[i]} (0≤i≤n-1)就是最大收益。第i天之前和第i天之后进行一次的最大收益求法同Best Time to Buy and Sell Stock I。 代码：时间O(n)，空间O(n)。 public class Solution { public int maxProfit(int[] prices) { if (prices.length &lt; 2) return 0; int n = prices.length; int[] preProfit = new int[n]; int[] postProfit = new int[n]; int curMin = prices[0]; for (int i = 1; i &lt; n; i++) { curMin = Math.min(curMin, prices[i]); preProfit[i] = Math.max(preProfit[i - 1], prices[i] - curMin);//第i天卖出 } int curMax = prices[n - 1]; for (int i = n - 2; i &gt;= 0; i--) {//从后往前遍历 curMax = Math.max(curMax, prices[i]); postProfit[i] = Math.max(postProfit[i + 1], curMax - prices[i]);//第i天买入 } int maxProfit = 0; for (int i = 0; i &lt; n; i++) { maxProfit = Math.max(maxProfit, preProfit[i] + postProfit[i]); } return maxProfit; } } Best Time to Buy and Sell Stock IV Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题意：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。最多交易k次，手上最多只能持有一支股票，求最大收益。 分析：特殊动态规划法。传统的动态规划我们会这样想，到第i天时进行j次交易的最大收益，要么等于到第i-1天时进行j次交易的最大收益（第i天价格低于第i-1天的价格），要么等于到第i-1天时进行j-1次交易，然后第i天进行一次交易（第i天价格高于第i-1天价格时）。于是得到动规方程如下（其中diff = prices[i] – prices[i – 1]）： profit[i][j] = max(profit[i – 1][j], profit[i – 1][j – 1] + diff) 看起来很有道理，但其实不对，为什么不对呢？因为diff是第i天和第i-1天的差额收益，如果第i-1天当天本身也有交易呢（也就是说第i-1天刚卖出了股票，然后又买入等到第i天再卖出），那么这两次交易就可以合为一次交易，这样profit[i – 1][j – 1] + diff实际上只进行了j-1次交易，而不是最多可以的j次，这样得到的最大收益就小了。 那么怎样计算第i天进行交易的情况的最大收益，才会避免少计算一次交易呢？我们用一个局部最优解和全局最有解表示到第i天进行j次的收益，这就是该动态规划的特殊之处。 我们定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。它们的递推式为（其中diff = prices[i] – prices[i – 1]）：local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)global[i][j] = max(local[i][j], global[i - 1][j])，其中局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值后相比，两者之中取较大值，而全局最优比较局部最优和前一天的全局最优。 local[i][j]和global[i][j]的区别是：local[i][j]意味着在第i天一定有交易（卖出）发生，当第i天的价格高于第i-1天（即diff &gt; 0）时，那么可以把这次交易（第i-1天买入第i天卖出）跟第i-1天的交易（卖出）合并为一次交易，即local[i][j]=local[i-1][j]+diff；当第i天的价格不高于第i-1天（即diff&lt;=0）时，那么local[i][j]=global[i-1][j-1]+diff，而由于diff&lt;=0，所以可写成local[i][j]=global[i-1][j-1]。global[i][j]就是我们所求的前i天最多进行k次交易的最大收益，可分为两种情况：如果第i天没有交易（卖出），那么global[i][j]=global[i-1][j]；如果第i天有交易（卖出），那么global[i][j]=local[i][j]。 参考：http://www.cnblogs.com/grandyang/p/4295761.html 代码：时间O(nk)，空间O(nk)。 public class Solution { public int maxProfit(int k, int[] prices) { if (prices.length &lt; 2) return 0; int days = prices.length; if (k &gt;= days) return maxProfit2(prices); int[][] local = new int[days][k + 1]; int[][] global = new int[days][k + 1]; for (int i = 1; i &lt; days ; i++) { int diff = prices[i] - prices[i - 1]; for (int j = 1; j &lt;= k; j++) { local[i][j] = Math.max(global[i - 1][j - 1], local[i - 1][j] + diff); global[i][j] = Math.max(global[i - 1][j], local[i][j]); } } return global[days - 1][k]; } public int maxProfit2(int[] prices) { int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) { if (prices[i] &gt; prices[i - 1]) { maxProfit += prices[i] - prices[i - 1]; } } return maxProfit; } } 我们知道，动规所用的二维辅助数组可以降为一维的，即只用大小为k的一维数组记录到达第i天时的局部最优解和全局最优解。需要注意的是，由于第i天时交易k次的最优解依赖于第i-1天时交易k-1次的最优解，所以数组更新应当从后往前（即从k到1）更新。 代码：时间O(nk)，空间O(k)。 public class Solution { public int maxProfit(int k, int[] prices) { if (prices.length &lt; 2) return 0; if (k &gt;= prices.length) return maxProfit2(prices); int[] local = new int[k + 1]; int[] global = new int[k + 1]; for (int i = 1; i &lt; prices.length ; i++) { int diff = prices[i] - prices[i - 1]; for (int j = k; j &gt; 0; j--) { local[j] = Math.max(global[j - 1], local[j] + diff); global[j] = Math.max(global[j], local[j]); } } return global[k]; } public int maxProfit2(int[] prices) { int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) { if (prices[i] &gt; prices[i - 1]) { maxProfit += prices[i] - prices[i - 1]; } } return maxProfit; } } 补充：这道题还有一个陷阱，就是当k大于天数时，其实就退化成&nbsp;Best Time to Buy and Sell Stock II&nbsp;了。 另外，Best Time to Buy and Sell Stock III&nbsp;就是本题k=2的情况，所以说IV是II和III的综合。 309. Best Time to Buy and Sell Stock with Cooldown 在第二题（次数不限）的基础上，卖完股票的转天不能买。求最大收益。 分析：http://www.cnblogs.com/grandyang/p/4997417.html 维护三个一维数组buy, sell，和rest。其中：buy[i]表示在第i天之前最后一个操作是买，此时的最大收益。sell[i]表示在第i天之前最后一个操作是卖，此时的最大收益。rest[i]表示在第i天之前最后一个操作是冷冻期，此时的最大收益。我们写出递推式为： buy[i] = max(rest[i-1] - price, buy[i-1]) sell[i] = max(buy[i-1] + price, sell[i-1]) rest[i] = max(sell[i-1], buy[i-1], rest[i-1])上述递推式很好的表示了在买之前有冷冻期，买之前要卖掉之前的股票。一个小技巧是如何保证[buy, rest, buy]的情况不会出现，这是由于buy[i] &lt;= rest[i]， 即rest[i] = max(sell[i-1], rest[i-1])，这保证了[buy, rest, buy]不会出现。 另外，由于冷冻期的存在，我们可以得出rest[i] = sell[i-1]，这样，我们可以将上面三个递推式精简到两个： buy[i] = max(sell[i-2] - price, buy[i-1]) sell[i] = max(buy[i-1] + price, sell[i-1]) 由于i只依赖于i-1和i-2，所以我们可以在O(1)的空间复杂度完成算法: pre_buy = buy;【因为buy是上一轮的，此句含义：pre_buy = buy[i-1]】 buy = max(pre_buy, pre_sell - prices[i]);【此句含义：buy[i]即buy = max（buy[i-1]即pre_buy，sell[i-2]【尚未更新的即上一轮的pre_sell】 - prices[i]）】 pre_sell = sell;【因为sell是上一轮的，此句含义：sell[i-1] = sell】 sell = max(pre_sell, pre_buy + prices[i]);【此句含义：sell[i]即sell = max（sell[i-1]即pre_sell，buy[i-1]【已更新为pre_buy了】 + prices[i]）】 参见代码如下： class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if(n == 0) return 0; int buy = 0x80000000, sell = 0, pre_buy = 0, pre_sell = 0; for(int i = 0; i &lt; n; ++i) {//把buy初值设为-prices[0]，for循环从i = 1开始，也对！ pre_buy = buy; buy = max(pre_buy, pre_sell - prices[i]); pre_sell = sell; sell = max(pre_sell, pre_buy + prices[i]); } return sell; } }; 阅读更多" />
<link rel="canonical" href="https://mlh.app/2016/07/18/1a5c6c9d78a51366d4c24319e6072e65.html" />
<meta property="og:url" content="https://mlh.app/2016/07/18/1a5c6c9d78a51366d4c24319e6072e65.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-07-18T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"转自http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html Best Time to Buy and Sell Stock I Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to findthe maximum profit. 题意：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。 如果只允许进行一次交易，也就是说只允许买一支股票并卖掉，求最大的收益。 分析：动态规划法。从前向后遍历数组，记录当前出现过的最低价格，作为买入价格，并计算以当天价格出售的收益，作为可能的最大收益，整个遍历过程中，出现过的最大收益就是所求。 代码：O(n)时间，O(1)空间。 public class Solution { public int maxProfit(int[] prices) { if (prices.length &lt; 2) return 0; int maxProfit = 0; int curMin = prices[0]; for (int i = 1; i &lt; prices.length; i++) { curMin = Math.min(curMin, prices[i]); maxProfit = Math.max(maxProfit, prices[i] - curMin); } return maxProfit; } } Best Time to Buy and Sell Stock II Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。交易次数不限，但一次只能交易一支股票，也就是说手上最多只能持有一支股票，求最大收益。 分析：贪心法。从前向后遍历数组，只要当天的价格高于前一天的价格，就算入收益。 代码：时间O(n)，空间O(1)。 public class Solution { public int maxProfit(int[] prices) { if (prices.length &lt; 2) return 0; int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) { int diff = prices[i] - prices[i - 1]; if (diff &gt; 0) { maxProfit += diff; } } return maxProfit; } } Best Time to Buy and Sell Stock III Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题意：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。最多交易两次，手上最多只能持有一支股票，求最大收益。 分析：动态规划法。以第i天为分界线，计算第i天之前进行一次交易的最大收益preProfit[i]，和第i天之后进行一次交易的最大收益postProfit[i]，最后遍历一遍，max{preProfit[i] + postProfit[i]} (0≤i≤n-1)就是最大收益。第i天之前和第i天之后进行一次的最大收益求法同Best Time to Buy and Sell Stock I。 代码：时间O(n)，空间O(n)。 public class Solution { public int maxProfit(int[] prices) { if (prices.length &lt; 2) return 0; int n = prices.length; int[] preProfit = new int[n]; int[] postProfit = new int[n]; int curMin = prices[0]; for (int i = 1; i &lt; n; i++) { curMin = Math.min(curMin, prices[i]); preProfit[i] = Math.max(preProfit[i - 1], prices[i] - curMin);//第i天卖出 } int curMax = prices[n - 1]; for (int i = n - 2; i &gt;= 0; i--) {//从后往前遍历 curMax = Math.max(curMax, prices[i]); postProfit[i] = Math.max(postProfit[i + 1], curMax - prices[i]);//第i天买入 } int maxProfit = 0; for (int i = 0; i &lt; n; i++) { maxProfit = Math.max(maxProfit, preProfit[i] + postProfit[i]); } return maxProfit; } } Best Time to Buy and Sell Stock IV Description:&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题意：用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。最多交易k次，手上最多只能持有一支股票，求最大收益。 分析：特殊动态规划法。传统的动态规划我们会这样想，到第i天时进行j次交易的最大收益，要么等于到第i-1天时进行j次交易的最大收益（第i天价格低于第i-1天的价格），要么等于到第i-1天时进行j-1次交易，然后第i天进行一次交易（第i天价格高于第i-1天价格时）。于是得到动规方程如下（其中diff = prices[i] – prices[i – 1]）： profit[i][j] = max(profit[i – 1][j], profit[i – 1][j – 1] + diff) 看起来很有道理，但其实不对，为什么不对呢？因为diff是第i天和第i-1天的差额收益，如果第i-1天当天本身也有交易呢（也就是说第i-1天刚卖出了股票，然后又买入等到第i天再卖出），那么这两次交易就可以合为一次交易，这样profit[i – 1][j – 1] + diff实际上只进行了j-1次交易，而不是最多可以的j次，这样得到的最大收益就小了。 那么怎样计算第i天进行交易的情况的最大收益，才会避免少计算一次交易呢？我们用一个局部最优解和全局最有解表示到第i天进行j次的收益，这就是该动态规划的特殊之处。 我们定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。它们的递推式为（其中diff = prices[i] – prices[i – 1]）：local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)global[i][j] = max(local[i][j], global[i - 1][j])，其中局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值后相比，两者之中取较大值，而全局最优比较局部最优和前一天的全局最优。 local[i][j]和global[i][j]的区别是：local[i][j]意味着在第i天一定有交易（卖出）发生，当第i天的价格高于第i-1天（即diff &gt; 0）时，那么可以把这次交易（第i-1天买入第i天卖出）跟第i-1天的交易（卖出）合并为一次交易，即local[i][j]=local[i-1][j]+diff；当第i天的价格不高于第i-1天（即diff&lt;=0）时，那么local[i][j]=global[i-1][j-1]+diff，而由于diff&lt;=0，所以可写成local[i][j]=global[i-1][j-1]。global[i][j]就是我们所求的前i天最多进行k次交易的最大收益，可分为两种情况：如果第i天没有交易（卖出），那么global[i][j]=global[i-1][j]；如果第i天有交易（卖出），那么global[i][j]=local[i][j]。 参考：http://www.cnblogs.com/grandyang/p/4295761.html 代码：时间O(nk)，空间O(nk)。 public class Solution { public int maxProfit(int k, int[] prices) { if (prices.length &lt; 2) return 0; int days = prices.length; if (k &gt;= days) return maxProfit2(prices); int[][] local = new int[days][k + 1]; int[][] global = new int[days][k + 1]; for (int i = 1; i &lt; days ; i++) { int diff = prices[i] - prices[i - 1]; for (int j = 1; j &lt;= k; j++) { local[i][j] = Math.max(global[i - 1][j - 1], local[i - 1][j] + diff); global[i][j] = Math.max(global[i - 1][j], local[i][j]); } } return global[days - 1][k]; } public int maxProfit2(int[] prices) { int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) { if (prices[i] &gt; prices[i - 1]) { maxProfit += prices[i] - prices[i - 1]; } } return maxProfit; } } 我们知道，动规所用的二维辅助数组可以降为一维的，即只用大小为k的一维数组记录到达第i天时的局部最优解和全局最优解。需要注意的是，由于第i天时交易k次的最优解依赖于第i-1天时交易k-1次的最优解，所以数组更新应当从后往前（即从k到1）更新。 代码：时间O(nk)，空间O(k)。 public class Solution { public int maxProfit(int k, int[] prices) { if (prices.length &lt; 2) return 0; if (k &gt;= prices.length) return maxProfit2(prices); int[] local = new int[k + 1]; int[] global = new int[k + 1]; for (int i = 1; i &lt; prices.length ; i++) { int diff = prices[i] - prices[i - 1]; for (int j = k; j &gt; 0; j--) { local[j] = Math.max(global[j - 1], local[j] + diff); global[j] = Math.max(global[j], local[j]); } } return global[k]; } public int maxProfit2(int[] prices) { int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) { if (prices[i] &gt; prices[i - 1]) { maxProfit += prices[i] - prices[i - 1]; } } return maxProfit; } } 补充：这道题还有一个陷阱，就是当k大于天数时，其实就退化成&nbsp;Best Time to Buy and Sell Stock II&nbsp;了。 另外，Best Time to Buy and Sell Stock III&nbsp;就是本题k=2的情况，所以说IV是II和III的综合。 309. Best Time to Buy and Sell Stock with Cooldown 在第二题（次数不限）的基础上，卖完股票的转天不能买。求最大收益。 分析：http://www.cnblogs.com/grandyang/p/4997417.html 维护三个一维数组buy, sell，和rest。其中：buy[i]表示在第i天之前最后一个操作是买，此时的最大收益。sell[i]表示在第i天之前最后一个操作是卖，此时的最大收益。rest[i]表示在第i天之前最后一个操作是冷冻期，此时的最大收益。我们写出递推式为： buy[i] = max(rest[i-1] - price, buy[i-1]) sell[i] = max(buy[i-1] + price, sell[i-1]) rest[i] = max(sell[i-1], buy[i-1], rest[i-1])上述递推式很好的表示了在买之前有冷冻期，买之前要卖掉之前的股票。一个小技巧是如何保证[buy, rest, buy]的情况不会出现，这是由于buy[i] &lt;= rest[i]， 即rest[i] = max(sell[i-1], rest[i-1])，这保证了[buy, rest, buy]不会出现。 另外，由于冷冻期的存在，我们可以得出rest[i] = sell[i-1]，这样，我们可以将上面三个递推式精简到两个： buy[i] = max(sell[i-2] - price, buy[i-1]) sell[i] = max(buy[i-1] + price, sell[i-1]) 由于i只依赖于i-1和i-2，所以我们可以在O(1)的空间复杂度完成算法: pre_buy = buy;【因为buy是上一轮的，此句含义：pre_buy = buy[i-1]】 buy = max(pre_buy, pre_sell - prices[i]);【此句含义：buy[i]即buy = max（buy[i-1]即pre_buy，sell[i-2]【尚未更新的即上一轮的pre_sell】 - prices[i]）】 pre_sell = sell;【因为sell是上一轮的，此句含义：sell[i-1] = sell】 sell = max(pre_sell, pre_buy + prices[i]);【此句含义：sell[i]即sell = max（sell[i-1]即pre_sell，buy[i-1]【已更新为pre_buy了】 + prices[i]）】 参见代码如下： class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if(n == 0) return 0; int buy = 0x80000000, sell = 0, pre_buy = 0, pre_sell = 0; for(int i = 0; i &lt; n; ++i) {//把buy初值设为-prices[0]，for循环从i = 1开始，也对！ pre_buy = buy; buy = max(pre_buy, pre_sell - prices[i]); pre_sell = sell; sell = max(pre_sell, pre_buy + prices[i]); } return sell; } }; 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2016/07/18/1a5c6c9d78a51366d4c24319e6072e65.html","headline":"【Leetcode 动态规划】 买卖股票 I II III IV 冷却，共5题","dateModified":"2016-07-18T00:00:00+08:00","datePublished":"2016-07-18T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2016/07/18/1a5c6c9d78a51366d4c24319e6072e65.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【Leetcode 动态规划】 买卖股票 I II III IV 冷却，共5题</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h2 style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:24px;font-weight:300;line-height:28.8px;"></h2>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="font-size:24px;line-height:28.8px;">转自http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html</span></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="font-size:24px;line-height:28.8px;"><br></span></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="font-size:24px;line-height:28.8px;">Best Time to Buy and Sell Stock I</span></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">Description:</span>&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find<br>the maximum profit.</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">题意：</span>用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。 如果<span style="border:0px;color:#FF0000;">只允许进行一次交易</span>，也就是说只允许买一支股票并卖掉，求最大的收益。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">分析：</span><span style="border:0px;color:#0000FF;">动态规划法</span>。从前向后遍历数组，记录当前出现过的最低价格，作为买入价格，并计算以当天价格出售的收益，作为可能的最大收益，整个遍历过程中，出现过的最大收益就是所求。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">代码：</span><span style="border:0px;color:#0000FF;">O(n)时间，O(1)空间。</span></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;"></span></p>
  <pre><code class="language-cpp">public class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length &lt; 2) return 0;
        
        int maxProfit = 0;
        int curMin = prices[0];
        
        for (int i = 1; i &lt; prices.length; i++) {
            curMin = Math.min(curMin, prices[i]);
            maxProfit = Math.max(maxProfit, prices[i] - curMin);
        }
        
        return maxProfit;
    }
}</code></pre>
  <p></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;"></span></p>
  <h2 style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:24px;font-weight:300;line-height:28.8px;">Best Time to Buy and Sell Stock II</h2>
  <p></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">Description:</span>&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">题目：</span>用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。<span style="border:0px;color:#FF0000;">交易次数不限</span>，但一次只能交易一支股票，也就是说手上最多只能持有一支股票，求最大收益。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">分析：</span><span style="border:0px;color:#0000FF;">贪心法</span>。从前向后遍历数组，只要当天的价格高于前一天的价格，就算入收益。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">代码：</span><span style="border:0px;color:#0000FF;">时间O(n)，空间O(1)。</span></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;"></span></p>
  <pre><code class="language-cpp">public class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length &lt; 2) return 0;
        
        int maxProfit = 0;
        for (int i = 1; i &lt; prices.length; i++) {
            int diff = prices[i] - prices[i - 1];
            if (diff &gt; 0) {
                maxProfit += diff;
            }
        }
        
        return maxProfit;
    }
}</code></pre>
  <p></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;"></span></p>
  <h2 style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:24px;font-weight:300;line-height:28.8px;">Best Time to Buy and Sell Stock III</h2>
  <p></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">Description:</span>&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">题意：</span>用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。<span style="border:0px;color:#FF0000;">最多交易两次</span>，手上最多只能持有一支股票，求最大收益。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">分析：</span><span style="border:0px;color:#0000FF;">动态规划法</span>。以第i天为分界线，计算第i天之前进行一次交易的最大收益preProfit[i]，和第i天之后进行一次交易的最大收益postProfit[i]，最后遍历一遍，max{preProfit[i] + postProfit[i]} (0≤i≤n-1)就是最大收益。第i天之前和第i天之后进行一次的最大收益求法同Best Time to Buy and Sell Stock I。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><br></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">代码：</span><span style="border:0px;color:#0000FF;">时间O(n)，空间O(n)。</span></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;"></span></p>
  <pre><code class="language-cpp">public class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length &lt; 2) return 0;
        
        int n = prices.length;
        int[] preProfit = new int[n];
        int[] postProfit = new int[n];
        
        int curMin = prices[0];
        for (int i = 1; i &lt; n; i++) {
            curMin = Math.min(curMin, prices[i]);
            preProfit[i] = Math.max(preProfit[i - 1], prices[i] - curMin);//第i天卖出
        }
        
        int curMax = prices[n - 1];
        for (int i = n - 2; i &gt;= 0; i--) {//从后往前遍历
            curMax = Math.max(curMax, prices[i]);
            postProfit[i] = Math.max(postProfit[i + 1], curMax - prices[i]);//第i天买入
        }
        
        int maxProfit = 0;
        for (int i = 0; i &lt; n; i++) {
            maxProfit = Math.max(maxProfit, preProfit[i] + postProfit[i]);
        }
        
        return  maxProfit;
    }
}</code></pre>
  <p></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;"></span></p>
  <h2 style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:24px;font-weight:300;line-height:28.8px;">Best Time to Buy and Sell Stock IV</h2>
  <p></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">Description:</span>&nbsp;Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">题意：</span>用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。<span style="border:0px;color:#FF0000;">最多交易k次</span>，手上最多只能持有一支股票，求最大收益。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">分析：</span><span style="border:0px;color:#0000FF;">特殊动态规划法</span>。传统的动态规划我们会这样想，到第i天时进行j次交易的最大收益，要么等于到第i-1天时进行j次交易的最大收益（第i天价格低于第i-1天的价格），要么等于到第i-1天时进行j-1次交易，然后第i天进行一次交易（第i天价格高于第i-1天价格时）。于是得到动规方程如下（其中diff = prices[i] – prices[i – 1]）：</p>
  <blockquote style="border-width:0px 0px 0px 5px;border-left-style:solid;font-size:16px;font-style:italic;font-family:'微软雅黑', Arial, Helvetica, sans-serif;line-height:28.8px;">
   <p style="border:0px;">profit[i][j] = max(profit[i – 1][j], profit[i – 1][j – 1] + diff)</p>
  </blockquote>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;color:#FF0000;">看起来很有道理，但其实不对，为什么不对呢？因为diff是第i天和第i-1天的差额收益，如果第i-1天当天本身也有交易呢（也就是说第i-1天刚卖出了股票，然后又买入等到第i天再卖出），那么这两次交易就可以合为一次交易，这样profit[i – 1][j – 1] + diff实际上只进行了j-1次交易，而不是最多可以的j次，这样得到的最大收益就小了。</span></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;">那么怎样计算第i天进行交易的情况的最大收益，才会避免少计算一次交易呢？我们用一个局部最优解和全局最有解表示到第i天进行j次的收益，这就是该动态规划的特殊之处。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;">我们定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。它们的递推式为<span style="font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;">（其中diff = prices[i] – prices[i – 1]）</span>：<br>local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)<br>global[i][j] = max(local[i][j], global[i - 1][j])，<br>其中局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值后相比，两者之中取较大值，而全局最优比较局部最优和前一天的全局最优。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;">local[i][j]和global[i][j]的区别是：<span style="border:0px;color:rgb(255,0,0);">local[i][j]意味着在第i天一定有交易（卖出）发生</span>，当第i天的价格高于第i-1天（即diff &gt; 0）时，那么可以把这次交易（第i-1天买入第i天卖出）跟第i-1天的交易（卖出）合并为一次交易，即local[i][j]=local[i-1][j]+diff；当第i天的价格不高于第i-1天（即diff&lt;=0）时，那么local[i][j]=global[i-1][j-1]+diff，而由于diff&lt;=0，所以可写成local[i][j]=global[i-1][j-1]。<span style="border:0px;color:rgb(255,0,0);">global[i][j]就是我们所求的前i天最多进行k次交易的最大收益</span>，可分为两种情况：如果第i天没有交易（卖出），那么global[i][j]=global[i-1][j]；如果第i天有交易（卖出），那么global[i][j]=local[i][j]。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;">参考：http://www.cnblogs.com/grandyang/p/4295761.html</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">代码：</span><span style="border:0px;color:#0000FF;">时间O(nk)，空间O(nk)。</span></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;"></span></p>
  <pre><code class="language-cpp">public class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices.length &lt; 2) return 0;
        
        int days = prices.length;
        if (k &gt;= days) return maxProfit2(prices);
        
        int[][] local = new int[days][k + 1];
        int[][] global = new int[days][k + 1];
        
        for (int i = 1; i &lt; days ; i++) {
            int diff = prices[i] - prices[i - 1];
            
            for (int j = 1; j &lt;= k; j++) {
                local[i][j] = Math.max(global[i - 1][j - 1], local[i - 1][j] + diff);
                global[i][j] = Math.max(global[i - 1][j], local[i][j]);
             }
        }
        
        return global[days - 1][k];
    }
    
    
    public int maxProfit2(int[] prices) {
        int maxProfit = 0;
        
        for (int i = 1; i &lt; prices.length; i++) {
            if (prices[i] &gt; prices[i - 1]) {
                maxProfit += prices[i] - prices[i - 1];
            }
        }
        
        return maxProfit;
    }
}</code></pre>
  <p></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;"></span></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;">我们知道，动规所用的二维辅助数组可以降为一维的，即只用大小为k的一维数组记录到达第i天时的局部最优解和全局最优解。需要注意的是，由于第i天时交易k次的最优解依赖于第i-1天时交易k-1次的最优解，所以数组更新应当从后往前（即从k到1）更新。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">代码：</span><span style="border:0px;color:#0000FF;">时间O(nk)，空间O(k)。</span></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;"></span></p>
  <pre><code class="language-cpp">public class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices.length &lt; 2) return 0;
        if (k &gt;= prices.length) return maxProfit2(prices);
        
        int[] local = new int[k + 1];
        int[] global = new int[k + 1];
        
        for (int i = 1; i &lt; prices.length ; i++) {
            int diff = prices[i] - prices[i - 1];
            
            for (int j = k; j &gt; 0; j--) {
                local[j] = Math.max(global[j - 1], local[j] + diff);
                global[j] = Math.max(global[j], local[j]);
            }
        }     
        return global[k];
    }   
    
    public int maxProfit2(int[] prices) {
        int maxProfit = 0;
        
        for (int i = 1; i &lt; prices.length; i++) {
            if (prices[i] &gt; prices[i - 1]) {
                maxProfit += prices[i] - prices[i - 1];
            }
        }
        return maxProfit;
    }
}</code></pre>
  <p></p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><span style="border:0px;">补充：</span>这道题还有一个陷阱，就是当k大于天数时，其实就退化成&nbsp;<span style="border:0px;"><span style="border:0px;">Best Time to Buy and Sell Stock II</span></span>&nbsp;了。 另外，<span style="border:0px;"><span style="border:0px;">Best Time to Buy and Sell Stock III</span></span>&nbsp;就是本题k=2的情况，所以说IV是II和III的综合。</p>
  <p style="border:0px;font-family:'微软雅黑', Arial, Helvetica, sans-serif;font-size:16px;line-height:28.8px;"><br></p>
  <p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:24px;line-height:26.4px;">309. Best Time to Buy and Sell Stock with Cooldown</span></p>
  <p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:26.4px;"><span style="font-size:14px;">在第二题（次数不限）的基础上，卖完股票的转天不能买。求最大收益。</span></span></p>
  <p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:26.4px;"><span style="font-size:14px;">分析：http://www.cnblogs.com/grandyang/p/4997417.html</span></span></p>
  <p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:26.4px;"><span style="font-size:14px;">维护三个一维数组buy, sell，和rest。其中：<br>buy[i]表示在第i天之前最后一个操作是买，此时的最大收益。<br>sell[i]表示在第i天之前最后一个操作是卖，此时的最大收益。<br>rest[i]表示在第i天之前最后一个操作是冷冻期，此时的最大收益。<br>我们写出递推式为：</span><br></span></p>
  <p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:26.4px;"><span style="font-size:14px;"></span></span></p>
  <pre><code class="language-cpp">buy[i]  = max(rest[i-1] - price, buy[i-1]) 
sell[i] = max(buy[i-1] + price, sell[i-1])
rest[i] = max(sell[i-1], buy[i-1], rest[i-1])</code></pre>上述递推式很好的表示了在买之前有冷冻期，买之前要卖掉之前的股票。一个小技巧是如何保证[buy, rest, buy]的情况不会出现，这是由于buy[i] &lt;= rest[i]， 即rest[i] = max(sell[i-1], rest[i-1])，这保证了[buy, rest, buy]不会出现。
  <br>另外，由于冷冻期的存在，我们可以得出rest[i] = sell[i-1]，这样，我们可以将上面三个递推式精简到两个：
  <br>
  <p></p>
  <p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:26.4px;"><span style="font-size:14px;"></span></span></p>
  <pre><code class="language-cpp">buy[i]  = max(sell[i-2] - price, buy[i-1]) 
sell[i] = max(buy[i-1] + price, sell[i-1])</code></pre>
  <p>由于i只依赖于i-1和i-2，所以我们可以在O(1)的空间复杂度完成算法:</p>
  <p></p>
  <pre><code class="language-cpp">pre_buy = buy;【因为buy是上一轮的，此句含义：pre_buy = buy[i-1]】
buy = max(pre_buy, pre_sell - prices[i]);【此句含义：buy[i]即buy  =  max（buy[i-1]即pre_buy，sell[i-2]【尚未更新的即上一轮的pre_sell】 - prices[i]）】
pre_sell = sell;【因为sell是上一轮的，此句含义：sell[i-1] = sell】
sell = max(pre_sell, pre_buy + prices[i]);【此句含义：sell[i]即sell   =   max（sell[i-1]即pre_sell，buy[i-1]【已更新为pre_buy了】 + prices[i]）】</code></pre>
  <p></p>
  <p>参见代码如下：</p>
  <p></p>
  <pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int n = prices.size();
        if(n == 0) return 0;
        
        int buy = 0x80000000, sell = 0, pre_buy = 0, pre_sell = 0;
        for(int i = 0; i &lt; n; ++i) {//把buy初值设为-prices[0]，for循环从i = 1开始，也对！
            pre_buy = buy;
            buy = max(pre_buy, pre_sell - prices[i]);
            pre_sell = sell;
            sell = max(pre_sell, pre_buy + prices[i]);
        }
        return sell;
    }
};</code></pre>
  <br>
  <br>
  <p></p>
  <br>
  <br>
  <p></p>
  <p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:26.4px;"><span style="font-size:14px;"><br></span></span></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Dr_Unknown/article/details/51939121,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Dr_Unknown/article/details/51939121,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
