<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>《Nodejs开发加密货币》之十八：地址 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="《Nodejs开发加密货币》之十八：地址" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="前言 上篇我们介绍了亿书的共识机制，是入门部分的补充，这篇开始介绍包括共识机制在内的加密货币的核心技术实现。另外，DPOS共识机制，首先需要通过用户注册为受托人，然后才会有一系列其他的操作，因此要从用户帐号开始。而对于亿书这款加密货币而言，用户帐号本质就是加密货币的地址。本篇，我们就来好好研究它。 源码 account.js https://github.com/Ebookcoin/ebookcoin/blob/master/logic/account.js accounts.js https://github.com/Ebookcoin/ebookcoin/blob/master/modules/accounts.js contacts.js https://github.com/Ebookcoin/ebookcoin/blob/master/modules/contacts.js 类图 地址主要通过modules/accounts.js模块处理，类图如下： 流程图 这里的逻辑并不复杂，其本质就是一种交易，所以，我们将在《交易》那篇提供详细的流程图。 解读 计算机软件是人类活动的模拟和程序化，也就是大家所谓的“虚拟化”。在设计的时候，都会设想一个角色（Role）代替人类，负责完成要开发的各类操作。这个角色，通常在开发中被定义为用户（User），用户看到并可操作的就是用户帐号，在此基础上，才能进行权限认证，记录和管理与用户有关的各类操作。 比特币里的用户角色仅仅就是一个比特币地址，该地址是通过Hash算法进行加密处理的字符串，因此我们叫它Hash地址。同时，基于真实网络的复杂性，对于IP地址的追踪也不容易，所以比特币的匿名性很好（因为压根就没有给你暴露名字的机会）。 亿书作为一款加密货币产品，自然也提供了类似的Hash地址。并基于该地址，扩展提供了其他功能，比如“别名地址”。原因有三个： 本质需要。版权保护应用，必然要明确版权所有人，实名信息是基本要求，如果再进行完全的匿名操作，显然有点不合适，属于跟自己过不去。当然，普通阅读用户不需要实名，亿书允许保持足够的匿名性。 用户需要。复杂的字符串地址不适合人类脑记，很多人在最初接触比特币的时候，非常不习惯，经常弄混、忘记自己的比特币地址就是很好的证明。 产品需要。说到交互功能，比特币除了交易之外，是没有什么交互的。而作为面向普通用户的亿书，要提供基本写作、团队协作、自出版等极具个性化的功能，交互功能被摆在突出位置，充满个性化的用户名是必须的。 具体操作时，可以实现下面的需求，详见 亿书白皮书 ： 用户可以注册一个用户名，它相当于是用户帐户的一个别名; 用户名都是唯一的; 注册后无法更改或删除; 用户名可作为支付地址，所以称为别名地址，类似于人们常用的支付宝帐号，其它用户可以直接向该用户的用户名付款，用户不再需要记下一长串的加密货币地址; 用户可以维护一个联系人列表。 这些操作和信息，都可以在客户端里完成，如下图所示： 1.公共Api 看 modules/accounts.js 368行的代码， 如下： // 368行 router.map(shared, { &quot;post /open&quot;: &quot;open&quot;, &quot;get /getBalance&quot;: &quot;getBalance&quot;, &quot;get /getPublicKey&quot;: &quot;getPublickey&quot;, &quot;post /generatePublicKey&quot;: &quot;generatePublickey&quot;, &quot;get /delegates&quot;: &quot;getDelegates&quot;, &quot;get /delegates/fee&quot;: &quot;getDelegatesFee&quot;, &quot;put /delegates&quot;: &quot;addDelegates&quot;, &quot;get /username/get&quot;: &quot;getUsername&quot;, &quot;get /username/fee&quot;: &quot;getUsernameFee&quot;, &quot;put /username&quot;: &quot;addUsername&quot;, &quot;get /&quot;: &quot;getAccount&quot; }); // 439行 library.network.app.use(&#39;/api/accounts&#39;, router); 前面，我们分析过，这里的router是helpers/router.js的一个实例。上述代码，最终会在439行的调用中，映射为公共Api，并分别对应shared中的方法，如： // accounts get /api/accounts/ -&gt; shared.getAccount //帐号主页 post /api/accounts/open -&gt; shared.open //登录 get /api/accounts/getBalance -&gt; shared.getBalance get /api/accounts/getPublicKey -&gt; shared.getPublickey post /api/accounts/generatePublicKey -&gt; shared.generatePublickey // username get /api/accounts/username/get -&gt; shared.getUsername get /api/accounts/username/fee -&gt; shared.getUsernameFee put /api/accounts/username -&gt; shared.addUsername //注册用户名 // delegates get /api/accounts/delegates -&gt; shared.getDelegates get /api/accounts/delegates/fee -&gt; shared.getDelegatesFee put /api/accounts/delegates -&gt; shared.addDelegates // count 对应431行单独定义 get /api/accounts/count -&gt; private.accounts // 另外两个是在debug或top环境下调试用的，暂且不表。 ... 这里的delegates（受托人）api，以及后面的debug环境下的api，暂且不提。通盘浏览这些公开接口信息，我们知道，可以直接浏览的信息主要包括余额（balance)、公钥（publicKey)、用户名（username）及修改用户名需要花费的费用（fee），以及受托人及其费用等，可以产生公钥和添加用户名。但是，没有删除和修改用户名的功能，所以一旦注册了用户名，想要修改，只能重新注册一个。 2.Hash地址 比特币地址是使用前缀来区分的，比如：1开头的地址就是我们实际使用的地址，3开头的地址是测试地址。而亿书，使用后缀来区分，通常以L结尾。代码在modules/accounts.js文件里： // 455行 Accounts.prototype.generateAddressByPublicKey = function (publicKey) { var publicKeyHash = crypto.createHash(&#39;sha256&#39;).update(publicKey, &#39;hex&#39;).digest(); var temp = new Buffer(8); for (var i = 0; i &lt; 8; i++) { temp[i] = publicKeyHash[7 - i]; } var address = bignum.fromBuffer(temp).toString() + &#39;L&#39;; if (!address) { throw Error(&quot;wrong publicKey &quot; + publicKey); } return address; }; 另一个类似的地址，就是区块链的以c结尾的块地址，用来标注generatorId，代码与上面的基本一致： // logic/block.js 20行 private.getAddressByPublicKey = function (publicKey) { var publicKeyHash = crypto.createHash(&#39;sha256&#39;).update(publicKey, &#39;hex&#39;).digest(); var temp = new Buffer(8); for (var i = 0; i &lt; 8; i++) { temp[i] = publicKeyHash[7 - i]; } var address = bignum.fromBuffer(temp).toString() + &quot;C&quot;; return address; } // 上面的方法，在312行dbRead函数里调用， generatorId: private.getAddressByPublicKey(raw.b_generatorPublicKey), 3.别名地址 用户名相当于地址别名，就像支付宝帐号，所以白皮书说“别名地址”。我们知道，只有在转移支付的时候，才会用到地址（接受地址和发送地址），所以体现把用户名当作地址的逻辑代码，自然要在处理“资金转移”的交易代码里，看看modules/transactions.js文件，具体如下： // modules/transactions.js 文件 // 652行 shared.addTransactions = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... }, // 685行 required: [&quot;secret&quot;, &quot;amount&quot;, &quot;recipientId&quot;] }, function (err) { ... // 702行 var isAddress = /^[0-9]+[L|l]$/g; if (isAddress.test(body.recipientId)) { query.address = body.recipientId; } else { query.username = body.recipientId; } library.balancesSequence.add(function (cb) { modules.accounts.getAccount(query, function (err, recipient) { ... // 717行 var recipientId = recipient ? recipient.address : body.recipientId; var recipientUsername = recipient ? recipient.username : null; ... try { var transaction = library.logic.transaction.create({ // 764行 type: TransactionTypes.SEND, amount: body.amount, sender: account, recipientId: recipientId, recipientUsername: recipientUsername, keypair: keypair, requester: keypair, secondKeypair: secondKeypair }); } catch (e) { return cb(e.toString()); } ... 上述代码，实现的就是资金转账的功能（后台编码的交易类型TransactionTypes.SEND，见764行），毫无疑问，必须提供三个参数”secret”, “amount”, “recipientId”（见685行）。从702行可知，其中recipientId 可以是字符串地址，也可以是用户名。从764行以后的代码还可以了解到，交易时的recipientId和recipientUsername字段都保存在数据库里了。 4.注册用户名 亿书默认不提供别名地址，需要用户注册。从上面的Api，很容易找到“注册用户名”的源码方法shared.addUsername，如下： // 868行 shared.addUsername = function (req, cb) { var body = req.body; library.scheme.validate(body, { type: &quot;object&quot;, properties: { ... }, // 890行 required: [&#39;secret&#39;, &#39;username&#39;] }, function (err) { // 896行 var hash = crypto.createHash(&#39;sha256&#39;).update(body.secret, &#39;utf8&#39;).digest(); var keypair = ed.MakeKeypair(hash); if (body.publicKey) { if (keypair.publicKey.toString(&#39;hex&#39;) != body.publicKey) { return cb(&quot;Invalid passphrase&quot;); } } library.balancesSequence.add(function (cb) { if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) { ... modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) { ... try { // 949行 var transaction = library.logic.transaction.create({ type: TransactionTypes.USERNAME, username: body.username, sender: account, keypair: keypair, secondKeypair: secondKeypair, requester: keypair }); } catch (e) { return cb(e.toString()); } modules.transactions.receiveTransactions([transaction], cb); }); }); } else { self.getAccount({publicKey: keypair.publicKey.toString(&#39;hex&#39;)}, function (err, account) { ... try { // 984行 var transaction = library.logic.transaction.create({ type: TransactionTypes.USERNAME, username: body.username, sender: account, keypair: keypair, secondKeypair: secondKeypair }); } catch (e) { return cb(e.toString()); } modules.transactions.receiveTransactions([transaction], cb); }); } ... 分析代码949行和984行，可以了解到，所谓的注册用户名，实质上就是提交了一个TransactionTypes.USERNAME类型的交易。890行代码，说明该Api必须两个参数，用户要提供明文密码(secret)和用户名(username)。 5.联系人列表 亿书具备社交功能，维护了一个联系人列表。与传统中心化软件不同的是，加密货币系统里，处处是交易，用户关注其他用户的行为，也是一项交易（内部的交易类型为TransactionTypes.FOLLOW）。 这项功能的源码在文件modules/contacts.js里，类图如下： 与其他模块文件一样，我们可以非常清晰的看到该文件提供的公共Api，如下： // modules/contacts.js文件 // 198行 router.map(shared, { &quot;get /unconfirmed&quot;: &quot;getUnconfirmedContacts&quot;, &quot;get /&quot;: &quot;getContacts&quot;, &quot;put /&quot;: &quot;addContact&quot;, &quot;get /fee&quot;: &quot;getFee&quot; }); 这些Api很简单，我们重点关注其中两个Api： put /api/contacts -&gt; shared.addContact //添加关注功能 get /api/contacts -&gt; shared.getContacts //获得列表 对应方法的源码： // 406行 shared.addContact = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... // 431行 required: [&quot;secret&quot;, &quot;following&quot;] }, function (err) { ... // 448行 var followingAddress = body.following.substring(1, body.following.length); var isAddress = /^[0-9]+[L|l]$/g; if (isAddress.test(followingAddress)) { query.address = followingAddress; } else { query.username = followingAddress; } library.balancesSequence.add(function (cb) { if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { ... try { var transaction = library.logic.transaction.create({ type: TransactionTypes.FOLLOW, sender: account, keypair: keypair, secondKeypair: secondKeypair, contactAddress: followingAddress, // 511行 requester: keypair }); } catch (e) { return cb(e.toString()); } modules.transactions.receiveTransactions([transaction], cb); }); }); ... 431行，添加关注需要两个参数”secret”和”following”，这里”following”其实就是用户的帐号地址或用户名（见448行）。然后，经过一系列验证之后，写入数据库的contactAddress字段（见511行），一个关注的操作过程就完成了。 然后，用户通过客户端浏览自己的联系人列表，需要用到另一个Api，对应的方法是shared.getContacts，如下： shared.getContacts = function (req, cb) { // 362行 modules.accounts.getAccount({address: query.address}, function (err, account) { ... async.series({ contacts: function (cb) { // 372行 if (!account.contacts.length) { return cb(null, []); } modules.accounts.getAccounts({address: {$in: account.contacts}}, [&quot;address&quot;, &quot;username&quot;], cb); }, followers: function (cb) { if (!account.followers.length) { return cb(null, []); } modules.accounts.getAccounts({address: {$in: account.followers}}, [&quot;address&quot;, &quot;username&quot;], cb); } ... }); }); }); }; 这段代码最重要的部分，就是362行modules.accounts.getAccount方法的调用，获得对应地址的用户帐号（account）实例，联系人都保存在该实例的account.contacts里。 总结 读完代码，可以发现，代码逻辑非常简单，仅仅相当于两个基本功能，一个是生成加密货币的Hash地址，另一个是通过交易模块扩展和关联其他功能。其中，Hash地址是基础，在整个亿书的开发设计中，无处不在，签名、验证和交易，以及区块链等需要它。接下来我们介绍签名和验证，请看下一篇：签名和多重签名。 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 首发区块链俱乐部： http://chainclub.org 亿书官方网站： http://ebookchain.org 亿书开发QQ群： 185046161 (亿书为开源项目，欢迎各界小伙伴参与） 参考 亿书白皮书 http://ebookchain.org/ebookchain.pdf 阅读更多" />
<meta property="og:description" content="前言 上篇我们介绍了亿书的共识机制，是入门部分的补充，这篇开始介绍包括共识机制在内的加密货币的核心技术实现。另外，DPOS共识机制，首先需要通过用户注册为受托人，然后才会有一系列其他的操作，因此要从用户帐号开始。而对于亿书这款加密货币而言，用户帐号本质就是加密货币的地址。本篇，我们就来好好研究它。 源码 account.js https://github.com/Ebookcoin/ebookcoin/blob/master/logic/account.js accounts.js https://github.com/Ebookcoin/ebookcoin/blob/master/modules/accounts.js contacts.js https://github.com/Ebookcoin/ebookcoin/blob/master/modules/contacts.js 类图 地址主要通过modules/accounts.js模块处理，类图如下： 流程图 这里的逻辑并不复杂，其本质就是一种交易，所以，我们将在《交易》那篇提供详细的流程图。 解读 计算机软件是人类活动的模拟和程序化，也就是大家所谓的“虚拟化”。在设计的时候，都会设想一个角色（Role）代替人类，负责完成要开发的各类操作。这个角色，通常在开发中被定义为用户（User），用户看到并可操作的就是用户帐号，在此基础上，才能进行权限认证，记录和管理与用户有关的各类操作。 比特币里的用户角色仅仅就是一个比特币地址，该地址是通过Hash算法进行加密处理的字符串，因此我们叫它Hash地址。同时，基于真实网络的复杂性，对于IP地址的追踪也不容易，所以比特币的匿名性很好（因为压根就没有给你暴露名字的机会）。 亿书作为一款加密货币产品，自然也提供了类似的Hash地址。并基于该地址，扩展提供了其他功能，比如“别名地址”。原因有三个： 本质需要。版权保护应用，必然要明确版权所有人，实名信息是基本要求，如果再进行完全的匿名操作，显然有点不合适，属于跟自己过不去。当然，普通阅读用户不需要实名，亿书允许保持足够的匿名性。 用户需要。复杂的字符串地址不适合人类脑记，很多人在最初接触比特币的时候，非常不习惯，经常弄混、忘记自己的比特币地址就是很好的证明。 产品需要。说到交互功能，比特币除了交易之外，是没有什么交互的。而作为面向普通用户的亿书，要提供基本写作、团队协作、自出版等极具个性化的功能，交互功能被摆在突出位置，充满个性化的用户名是必须的。 具体操作时，可以实现下面的需求，详见 亿书白皮书 ： 用户可以注册一个用户名，它相当于是用户帐户的一个别名; 用户名都是唯一的; 注册后无法更改或删除; 用户名可作为支付地址，所以称为别名地址，类似于人们常用的支付宝帐号，其它用户可以直接向该用户的用户名付款，用户不再需要记下一长串的加密货币地址; 用户可以维护一个联系人列表。 这些操作和信息，都可以在客户端里完成，如下图所示： 1.公共Api 看 modules/accounts.js 368行的代码， 如下： // 368行 router.map(shared, { &quot;post /open&quot;: &quot;open&quot;, &quot;get /getBalance&quot;: &quot;getBalance&quot;, &quot;get /getPublicKey&quot;: &quot;getPublickey&quot;, &quot;post /generatePublicKey&quot;: &quot;generatePublickey&quot;, &quot;get /delegates&quot;: &quot;getDelegates&quot;, &quot;get /delegates/fee&quot;: &quot;getDelegatesFee&quot;, &quot;put /delegates&quot;: &quot;addDelegates&quot;, &quot;get /username/get&quot;: &quot;getUsername&quot;, &quot;get /username/fee&quot;: &quot;getUsernameFee&quot;, &quot;put /username&quot;: &quot;addUsername&quot;, &quot;get /&quot;: &quot;getAccount&quot; }); // 439行 library.network.app.use(&#39;/api/accounts&#39;, router); 前面，我们分析过，这里的router是helpers/router.js的一个实例。上述代码，最终会在439行的调用中，映射为公共Api，并分别对应shared中的方法，如： // accounts get /api/accounts/ -&gt; shared.getAccount //帐号主页 post /api/accounts/open -&gt; shared.open //登录 get /api/accounts/getBalance -&gt; shared.getBalance get /api/accounts/getPublicKey -&gt; shared.getPublickey post /api/accounts/generatePublicKey -&gt; shared.generatePublickey // username get /api/accounts/username/get -&gt; shared.getUsername get /api/accounts/username/fee -&gt; shared.getUsernameFee put /api/accounts/username -&gt; shared.addUsername //注册用户名 // delegates get /api/accounts/delegates -&gt; shared.getDelegates get /api/accounts/delegates/fee -&gt; shared.getDelegatesFee put /api/accounts/delegates -&gt; shared.addDelegates // count 对应431行单独定义 get /api/accounts/count -&gt; private.accounts // 另外两个是在debug或top环境下调试用的，暂且不表。 ... 这里的delegates（受托人）api，以及后面的debug环境下的api，暂且不提。通盘浏览这些公开接口信息，我们知道，可以直接浏览的信息主要包括余额（balance)、公钥（publicKey)、用户名（username）及修改用户名需要花费的费用（fee），以及受托人及其费用等，可以产生公钥和添加用户名。但是，没有删除和修改用户名的功能，所以一旦注册了用户名，想要修改，只能重新注册一个。 2.Hash地址 比特币地址是使用前缀来区分的，比如：1开头的地址就是我们实际使用的地址，3开头的地址是测试地址。而亿书，使用后缀来区分，通常以L结尾。代码在modules/accounts.js文件里： // 455行 Accounts.prototype.generateAddressByPublicKey = function (publicKey) { var publicKeyHash = crypto.createHash(&#39;sha256&#39;).update(publicKey, &#39;hex&#39;).digest(); var temp = new Buffer(8); for (var i = 0; i &lt; 8; i++) { temp[i] = publicKeyHash[7 - i]; } var address = bignum.fromBuffer(temp).toString() + &#39;L&#39;; if (!address) { throw Error(&quot;wrong publicKey &quot; + publicKey); } return address; }; 另一个类似的地址，就是区块链的以c结尾的块地址，用来标注generatorId，代码与上面的基本一致： // logic/block.js 20行 private.getAddressByPublicKey = function (publicKey) { var publicKeyHash = crypto.createHash(&#39;sha256&#39;).update(publicKey, &#39;hex&#39;).digest(); var temp = new Buffer(8); for (var i = 0; i &lt; 8; i++) { temp[i] = publicKeyHash[7 - i]; } var address = bignum.fromBuffer(temp).toString() + &quot;C&quot;; return address; } // 上面的方法，在312行dbRead函数里调用， generatorId: private.getAddressByPublicKey(raw.b_generatorPublicKey), 3.别名地址 用户名相当于地址别名，就像支付宝帐号，所以白皮书说“别名地址”。我们知道，只有在转移支付的时候，才会用到地址（接受地址和发送地址），所以体现把用户名当作地址的逻辑代码，自然要在处理“资金转移”的交易代码里，看看modules/transactions.js文件，具体如下： // modules/transactions.js 文件 // 652行 shared.addTransactions = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... }, // 685行 required: [&quot;secret&quot;, &quot;amount&quot;, &quot;recipientId&quot;] }, function (err) { ... // 702行 var isAddress = /^[0-9]+[L|l]$/g; if (isAddress.test(body.recipientId)) { query.address = body.recipientId; } else { query.username = body.recipientId; } library.balancesSequence.add(function (cb) { modules.accounts.getAccount(query, function (err, recipient) { ... // 717行 var recipientId = recipient ? recipient.address : body.recipientId; var recipientUsername = recipient ? recipient.username : null; ... try { var transaction = library.logic.transaction.create({ // 764行 type: TransactionTypes.SEND, amount: body.amount, sender: account, recipientId: recipientId, recipientUsername: recipientUsername, keypair: keypair, requester: keypair, secondKeypair: secondKeypair }); } catch (e) { return cb(e.toString()); } ... 上述代码，实现的就是资金转账的功能（后台编码的交易类型TransactionTypes.SEND，见764行），毫无疑问，必须提供三个参数”secret”, “amount”, “recipientId”（见685行）。从702行可知，其中recipientId 可以是字符串地址，也可以是用户名。从764行以后的代码还可以了解到，交易时的recipientId和recipientUsername字段都保存在数据库里了。 4.注册用户名 亿书默认不提供别名地址，需要用户注册。从上面的Api，很容易找到“注册用户名”的源码方法shared.addUsername，如下： // 868行 shared.addUsername = function (req, cb) { var body = req.body; library.scheme.validate(body, { type: &quot;object&quot;, properties: { ... }, // 890行 required: [&#39;secret&#39;, &#39;username&#39;] }, function (err) { // 896行 var hash = crypto.createHash(&#39;sha256&#39;).update(body.secret, &#39;utf8&#39;).digest(); var keypair = ed.MakeKeypair(hash); if (body.publicKey) { if (keypair.publicKey.toString(&#39;hex&#39;) != body.publicKey) { return cb(&quot;Invalid passphrase&quot;); } } library.balancesSequence.add(function (cb) { if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) { ... modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) { ... try { // 949行 var transaction = library.logic.transaction.create({ type: TransactionTypes.USERNAME, username: body.username, sender: account, keypair: keypair, secondKeypair: secondKeypair, requester: keypair }); } catch (e) { return cb(e.toString()); } modules.transactions.receiveTransactions([transaction], cb); }); }); } else { self.getAccount({publicKey: keypair.publicKey.toString(&#39;hex&#39;)}, function (err, account) { ... try { // 984行 var transaction = library.logic.transaction.create({ type: TransactionTypes.USERNAME, username: body.username, sender: account, keypair: keypair, secondKeypair: secondKeypair }); } catch (e) { return cb(e.toString()); } modules.transactions.receiveTransactions([transaction], cb); }); } ... 分析代码949行和984行，可以了解到，所谓的注册用户名，实质上就是提交了一个TransactionTypes.USERNAME类型的交易。890行代码，说明该Api必须两个参数，用户要提供明文密码(secret)和用户名(username)。 5.联系人列表 亿书具备社交功能，维护了一个联系人列表。与传统中心化软件不同的是，加密货币系统里，处处是交易，用户关注其他用户的行为，也是一项交易（内部的交易类型为TransactionTypes.FOLLOW）。 这项功能的源码在文件modules/contacts.js里，类图如下： 与其他模块文件一样，我们可以非常清晰的看到该文件提供的公共Api，如下： // modules/contacts.js文件 // 198行 router.map(shared, { &quot;get /unconfirmed&quot;: &quot;getUnconfirmedContacts&quot;, &quot;get /&quot;: &quot;getContacts&quot;, &quot;put /&quot;: &quot;addContact&quot;, &quot;get /fee&quot;: &quot;getFee&quot; }); 这些Api很简单，我们重点关注其中两个Api： put /api/contacts -&gt; shared.addContact //添加关注功能 get /api/contacts -&gt; shared.getContacts //获得列表 对应方法的源码： // 406行 shared.addContact = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... // 431行 required: [&quot;secret&quot;, &quot;following&quot;] }, function (err) { ... // 448行 var followingAddress = body.following.substring(1, body.following.length); var isAddress = /^[0-9]+[L|l]$/g; if (isAddress.test(followingAddress)) { query.address = followingAddress; } else { query.username = followingAddress; } library.balancesSequence.add(function (cb) { if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { ... try { var transaction = library.logic.transaction.create({ type: TransactionTypes.FOLLOW, sender: account, keypair: keypair, secondKeypair: secondKeypair, contactAddress: followingAddress, // 511行 requester: keypair }); } catch (e) { return cb(e.toString()); } modules.transactions.receiveTransactions([transaction], cb); }); }); ... 431行，添加关注需要两个参数”secret”和”following”，这里”following”其实就是用户的帐号地址或用户名（见448行）。然后，经过一系列验证之后，写入数据库的contactAddress字段（见511行），一个关注的操作过程就完成了。 然后，用户通过客户端浏览自己的联系人列表，需要用到另一个Api，对应的方法是shared.getContacts，如下： shared.getContacts = function (req, cb) { // 362行 modules.accounts.getAccount({address: query.address}, function (err, account) { ... async.series({ contacts: function (cb) { // 372行 if (!account.contacts.length) { return cb(null, []); } modules.accounts.getAccounts({address: {$in: account.contacts}}, [&quot;address&quot;, &quot;username&quot;], cb); }, followers: function (cb) { if (!account.followers.length) { return cb(null, []); } modules.accounts.getAccounts({address: {$in: account.followers}}, [&quot;address&quot;, &quot;username&quot;], cb); } ... }); }); }); }; 这段代码最重要的部分，就是362行modules.accounts.getAccount方法的调用，获得对应地址的用户帐号（account）实例，联系人都保存在该实例的account.contacts里。 总结 读完代码，可以发现，代码逻辑非常简单，仅仅相当于两个基本功能，一个是生成加密货币的Hash地址，另一个是通过交易模块扩展和关联其他功能。其中，Hash地址是基础，在整个亿书的开发设计中，无处不在，签名、验证和交易，以及区块链等需要它。接下来我们介绍签名和验证，请看下一篇：签名和多重签名。 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 首发区块链俱乐部： http://chainclub.org 亿书官方网站： http://ebookchain.org 亿书开发QQ群： 185046161 (亿书为开源项目，欢迎各界小伙伴参与） 参考 亿书白皮书 http://ebookchain.org/ebookchain.pdf 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-06-25T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"前言 上篇我们介绍了亿书的共识机制，是入门部分的补充，这篇开始介绍包括共识机制在内的加密货币的核心技术实现。另外，DPOS共识机制，首先需要通过用户注册为受托人，然后才会有一系列其他的操作，因此要从用户帐号开始。而对于亿书这款加密货币而言，用户帐号本质就是加密货币的地址。本篇，我们就来好好研究它。 源码 account.js https://github.com/Ebookcoin/ebookcoin/blob/master/logic/account.js accounts.js https://github.com/Ebookcoin/ebookcoin/blob/master/modules/accounts.js contacts.js https://github.com/Ebookcoin/ebookcoin/blob/master/modules/contacts.js 类图 地址主要通过modules/accounts.js模块处理，类图如下： 流程图 这里的逻辑并不复杂，其本质就是一种交易，所以，我们将在《交易》那篇提供详细的流程图。 解读 计算机软件是人类活动的模拟和程序化，也就是大家所谓的“虚拟化”。在设计的时候，都会设想一个角色（Role）代替人类，负责完成要开发的各类操作。这个角色，通常在开发中被定义为用户（User），用户看到并可操作的就是用户帐号，在此基础上，才能进行权限认证，记录和管理与用户有关的各类操作。 比特币里的用户角色仅仅就是一个比特币地址，该地址是通过Hash算法进行加密处理的字符串，因此我们叫它Hash地址。同时，基于真实网络的复杂性，对于IP地址的追踪也不容易，所以比特币的匿名性很好（因为压根就没有给你暴露名字的机会）。 亿书作为一款加密货币产品，自然也提供了类似的Hash地址。并基于该地址，扩展提供了其他功能，比如“别名地址”。原因有三个： 本质需要。版权保护应用，必然要明确版权所有人，实名信息是基本要求，如果再进行完全的匿名操作，显然有点不合适，属于跟自己过不去。当然，普通阅读用户不需要实名，亿书允许保持足够的匿名性。 用户需要。复杂的字符串地址不适合人类脑记，很多人在最初接触比特币的时候，非常不习惯，经常弄混、忘记自己的比特币地址就是很好的证明。 产品需要。说到交互功能，比特币除了交易之外，是没有什么交互的。而作为面向普通用户的亿书，要提供基本写作、团队协作、自出版等极具个性化的功能，交互功能被摆在突出位置，充满个性化的用户名是必须的。 具体操作时，可以实现下面的需求，详见 亿书白皮书 ： 用户可以注册一个用户名，它相当于是用户帐户的一个别名; 用户名都是唯一的; 注册后无法更改或删除; 用户名可作为支付地址，所以称为别名地址，类似于人们常用的支付宝帐号，其它用户可以直接向该用户的用户名付款，用户不再需要记下一长串的加密货币地址; 用户可以维护一个联系人列表。 这些操作和信息，都可以在客户端里完成，如下图所示： 1.公共Api 看 modules/accounts.js 368行的代码， 如下： // 368行 router.map(shared, { &quot;post /open&quot;: &quot;open&quot;, &quot;get /getBalance&quot;: &quot;getBalance&quot;, &quot;get /getPublicKey&quot;: &quot;getPublickey&quot;, &quot;post /generatePublicKey&quot;: &quot;generatePublickey&quot;, &quot;get /delegates&quot;: &quot;getDelegates&quot;, &quot;get /delegates/fee&quot;: &quot;getDelegatesFee&quot;, &quot;put /delegates&quot;: &quot;addDelegates&quot;, &quot;get /username/get&quot;: &quot;getUsername&quot;, &quot;get /username/fee&quot;: &quot;getUsernameFee&quot;, &quot;put /username&quot;: &quot;addUsername&quot;, &quot;get /&quot;: &quot;getAccount&quot; }); // 439行 library.network.app.use(&#39;/api/accounts&#39;, router); 前面，我们分析过，这里的router是helpers/router.js的一个实例。上述代码，最终会在439行的调用中，映射为公共Api，并分别对应shared中的方法，如： // accounts get /api/accounts/ -&gt; shared.getAccount //帐号主页 post /api/accounts/open -&gt; shared.open //登录 get /api/accounts/getBalance -&gt; shared.getBalance get /api/accounts/getPublicKey -&gt; shared.getPublickey post /api/accounts/generatePublicKey -&gt; shared.generatePublickey // username get /api/accounts/username/get -&gt; shared.getUsername get /api/accounts/username/fee -&gt; shared.getUsernameFee put /api/accounts/username -&gt; shared.addUsername //注册用户名 // delegates get /api/accounts/delegates -&gt; shared.getDelegates get /api/accounts/delegates/fee -&gt; shared.getDelegatesFee put /api/accounts/delegates -&gt; shared.addDelegates // count 对应431行单独定义 get /api/accounts/count -&gt; private.accounts // 另外两个是在debug或top环境下调试用的，暂且不表。 ... 这里的delegates（受托人）api，以及后面的debug环境下的api，暂且不提。通盘浏览这些公开接口信息，我们知道，可以直接浏览的信息主要包括余额（balance)、公钥（publicKey)、用户名（username）及修改用户名需要花费的费用（fee），以及受托人及其费用等，可以产生公钥和添加用户名。但是，没有删除和修改用户名的功能，所以一旦注册了用户名，想要修改，只能重新注册一个。 2.Hash地址 比特币地址是使用前缀来区分的，比如：1开头的地址就是我们实际使用的地址，3开头的地址是测试地址。而亿书，使用后缀来区分，通常以L结尾。代码在modules/accounts.js文件里： // 455行 Accounts.prototype.generateAddressByPublicKey = function (publicKey) { var publicKeyHash = crypto.createHash(&#39;sha256&#39;).update(publicKey, &#39;hex&#39;).digest(); var temp = new Buffer(8); for (var i = 0; i &lt; 8; i++) { temp[i] = publicKeyHash[7 - i]; } var address = bignum.fromBuffer(temp).toString() + &#39;L&#39;; if (!address) { throw Error(&quot;wrong publicKey &quot; + publicKey); } return address; }; 另一个类似的地址，就是区块链的以c结尾的块地址，用来标注generatorId，代码与上面的基本一致： // logic/block.js 20行 private.getAddressByPublicKey = function (publicKey) { var publicKeyHash = crypto.createHash(&#39;sha256&#39;).update(publicKey, &#39;hex&#39;).digest(); var temp = new Buffer(8); for (var i = 0; i &lt; 8; i++) { temp[i] = publicKeyHash[7 - i]; } var address = bignum.fromBuffer(temp).toString() + &quot;C&quot;; return address; } // 上面的方法，在312行dbRead函数里调用， generatorId: private.getAddressByPublicKey(raw.b_generatorPublicKey), 3.别名地址 用户名相当于地址别名，就像支付宝帐号，所以白皮书说“别名地址”。我们知道，只有在转移支付的时候，才会用到地址（接受地址和发送地址），所以体现把用户名当作地址的逻辑代码，自然要在处理“资金转移”的交易代码里，看看modules/transactions.js文件，具体如下： // modules/transactions.js 文件 // 652行 shared.addTransactions = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... }, // 685行 required: [&quot;secret&quot;, &quot;amount&quot;, &quot;recipientId&quot;] }, function (err) { ... // 702行 var isAddress = /^[0-9]+[L|l]$/g; if (isAddress.test(body.recipientId)) { query.address = body.recipientId; } else { query.username = body.recipientId; } library.balancesSequence.add(function (cb) { modules.accounts.getAccount(query, function (err, recipient) { ... // 717行 var recipientId = recipient ? recipient.address : body.recipientId; var recipientUsername = recipient ? recipient.username : null; ... try { var transaction = library.logic.transaction.create({ // 764行 type: TransactionTypes.SEND, amount: body.amount, sender: account, recipientId: recipientId, recipientUsername: recipientUsername, keypair: keypair, requester: keypair, secondKeypair: secondKeypair }); } catch (e) { return cb(e.toString()); } ... 上述代码，实现的就是资金转账的功能（后台编码的交易类型TransactionTypes.SEND，见764行），毫无疑问，必须提供三个参数”secret”, “amount”, “recipientId”（见685行）。从702行可知，其中recipientId 可以是字符串地址，也可以是用户名。从764行以后的代码还可以了解到，交易时的recipientId和recipientUsername字段都保存在数据库里了。 4.注册用户名 亿书默认不提供别名地址，需要用户注册。从上面的Api，很容易找到“注册用户名”的源码方法shared.addUsername，如下： // 868行 shared.addUsername = function (req, cb) { var body = req.body; library.scheme.validate(body, { type: &quot;object&quot;, properties: { ... }, // 890行 required: [&#39;secret&#39;, &#39;username&#39;] }, function (err) { // 896行 var hash = crypto.createHash(&#39;sha256&#39;).update(body.secret, &#39;utf8&#39;).digest(); var keypair = ed.MakeKeypair(hash); if (body.publicKey) { if (keypair.publicKey.toString(&#39;hex&#39;) != body.publicKey) { return cb(&quot;Invalid passphrase&quot;); } } library.balancesSequence.add(function (cb) { if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) { ... modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) { ... try { // 949行 var transaction = library.logic.transaction.create({ type: TransactionTypes.USERNAME, username: body.username, sender: account, keypair: keypair, secondKeypair: secondKeypair, requester: keypair }); } catch (e) { return cb(e.toString()); } modules.transactions.receiveTransactions([transaction], cb); }); }); } else { self.getAccount({publicKey: keypair.publicKey.toString(&#39;hex&#39;)}, function (err, account) { ... try { // 984行 var transaction = library.logic.transaction.create({ type: TransactionTypes.USERNAME, username: body.username, sender: account, keypair: keypair, secondKeypair: secondKeypair }); } catch (e) { return cb(e.toString()); } modules.transactions.receiveTransactions([transaction], cb); }); } ... 分析代码949行和984行，可以了解到，所谓的注册用户名，实质上就是提交了一个TransactionTypes.USERNAME类型的交易。890行代码，说明该Api必须两个参数，用户要提供明文密码(secret)和用户名(username)。 5.联系人列表 亿书具备社交功能，维护了一个联系人列表。与传统中心化软件不同的是，加密货币系统里，处处是交易，用户关注其他用户的行为，也是一项交易（内部的交易类型为TransactionTypes.FOLLOW）。 这项功能的源码在文件modules/contacts.js里，类图如下： 与其他模块文件一样，我们可以非常清晰的看到该文件提供的公共Api，如下： // modules/contacts.js文件 // 198行 router.map(shared, { &quot;get /unconfirmed&quot;: &quot;getUnconfirmedContacts&quot;, &quot;get /&quot;: &quot;getContacts&quot;, &quot;put /&quot;: &quot;addContact&quot;, &quot;get /fee&quot;: &quot;getFee&quot; }); 这些Api很简单，我们重点关注其中两个Api： put /api/contacts -&gt; shared.addContact //添加关注功能 get /api/contacts -&gt; shared.getContacts //获得列表 对应方法的源码： // 406行 shared.addContact = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... // 431行 required: [&quot;secret&quot;, &quot;following&quot;] }, function (err) { ... // 448行 var followingAddress = body.following.substring(1, body.following.length); var isAddress = /^[0-9]+[L|l]$/g; if (isAddress.test(followingAddress)) { query.address = followingAddress; } else { query.username = followingAddress; } library.balancesSequence.add(function (cb) { if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { ... try { var transaction = library.logic.transaction.create({ type: TransactionTypes.FOLLOW, sender: account, keypair: keypair, secondKeypair: secondKeypair, contactAddress: followingAddress, // 511行 requester: keypair }); } catch (e) { return cb(e.toString()); } modules.transactions.receiveTransactions([transaction], cb); }); }); ... 431行，添加关注需要两个参数”secret”和”following”，这里”following”其实就是用户的帐号地址或用户名（见448行）。然后，经过一系列验证之后，写入数据库的contactAddress字段（见511行），一个关注的操作过程就完成了。 然后，用户通过客户端浏览自己的联系人列表，需要用到另一个Api，对应的方法是shared.getContacts，如下： shared.getContacts = function (req, cb) { // 362行 modules.accounts.getAccount({address: query.address}, function (err, account) { ... async.series({ contacts: function (cb) { // 372行 if (!account.contacts.length) { return cb(null, []); } modules.accounts.getAccounts({address: {$in: account.contacts}}, [&quot;address&quot;, &quot;username&quot;], cb); }, followers: function (cb) { if (!account.followers.length) { return cb(null, []); } modules.accounts.getAccounts({address: {$in: account.followers}}, [&quot;address&quot;, &quot;username&quot;], cb); } ... }); }); }); }; 这段代码最重要的部分，就是362行modules.accounts.getAccount方法的调用，获得对应地址的用户帐号（account）实例，联系人都保存在该实例的account.contacts里。 总结 读完代码，可以发现，代码逻辑非常简单，仅仅相当于两个基本功能，一个是生成加密货币的Hash地址，另一个是通过交易模块扩展和关联其他功能。其中，Hash地址是基础，在整个亿书的开发设计中，无处不在，签名、验证和交易，以及区块链等需要它。接下来我们介绍签名和验证，请看下一篇：签名和多重签名。 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 首发区块链俱乐部： http://chainclub.org 亿书官方网站： http://ebookchain.org 亿书开发QQ群： 185046161 (亿书为开源项目，欢迎各界小伙伴参与） 参考 亿书白皮书 http://ebookchain.org/ebookchain.pdf 阅读更多","@type":"BlogPosting","url":"/2016/06/25/d22d15c21c92c3308a63fbd18374f726.html","headline":"《Nodejs开发加密货币》之十八：地址","dateModified":"2016-06-25T00:00:00+08:00","datePublished":"2016-06-25T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2016/06/25/d22d15c21c92c3308a63fbd18374f726.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>《Nodejs开发加密货币》之十八：地址</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h2 id="前言">前言</h2> 
  <p>上篇我们介绍了亿书的共识机制，是入门部分的补充，这篇开始介绍包括共识机制在内的加密货币的核心技术实现。另外，DPOS共识机制，首先需要通过用户注册为受托人，然后才会有一系列其他的操作，因此要从用户帐号开始。而对于亿书这款加密货币而言，用户帐号本质就是加密货币的<code>地址</code>。本篇，我们就来好好研究它。</p> 
  <h2 id="源码">源码</h2> 
  <p>account.js <a href="https://github.com/Ebookcoin/ebookcoin/blob/master/logic/account.js" rel="nofollow">https://github.com/Ebookcoin/ebookcoin/blob/master/logic/account.js</a></p> 
  <p>accounts.js <a href="https://github.com/Ebookcoin/ebookcoin/blob/master/modules/accounts.js" rel="nofollow">https://github.com/Ebookcoin/ebookcoin/blob/master/modules/accounts.js</a></p> 
  <p>contacts.js <a href="https://github.com/Ebookcoin/ebookcoin/blob/master/modules/contacts.js" rel="nofollow">https://github.com/Ebookcoin/ebookcoin/blob/master/modules/contacts.js</a></p> 
  <h2 id="类图">类图</h2> 
  <p>地址主要通过<code>modules/accounts.js</code>模块处理，类图如下：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20160625091812840" alt="accounts-class.png" title=""></p> 
  <h2 id="流程图">流程图</h2> 
  <p>这里的逻辑并不复杂，其本质就是一种<code>交易</code>，所以，我们将在《交易》那篇提供详细的流程图。</p> 
  <h2 id="解读">解读</h2> 
  <p>计算机软件是人类活动的模拟和程序化，也就是大家所谓的“虚拟化”。在设计的时候，都会设想一个角色（Role）代替人类，负责完成要开发的各类操作。这个角色，通常在开发中被定义为用户（User），用户看到并可操作的就是用户帐号，在此基础上，才能进行权限认证，记录和管理与用户有关的各类操作。</p> 
  <p>比特币里的用户角色仅仅就是一个比特币地址，该地址是通过Hash算法进行加密处理的字符串，因此我们叫它<code>Hash地址</code>。同时，基于真实网络的复杂性，对于IP地址的追踪也不容易，所以比特币的匿名性很好（因为压根就没有给你暴露名字的机会）。</p> 
  <p>亿书作为一款加密货币产品，自然也提供了类似的<code>Hash地址</code>。并基于该地址，扩展提供了其他功能，比如“别名地址”。原因有三个：</p> 
  <ol> 
   <li><strong>本质需要</strong>。版权保护应用，必然要明确版权所有人，实名信息是基本要求，如果再进行完全的匿名操作，显然有点不合适，属于跟自己过不去。当然，普通阅读用户不需要实名，亿书允许保持足够的匿名性。</li> 
   <li><strong>用户需要</strong>。复杂的字符串地址不适合人类脑记，很多人在最初接触比特币的时候，非常不习惯，经常弄混、忘记自己的比特币地址就是很好的证明。</li> 
   <li><strong>产品需要</strong>。说到交互功能，比特币除了交易之外，是没有什么交互的。而作为面向普通用户的亿书，要提供基本写作、团队协作、自出版等极具个性化的功能，交互功能被摆在突出位置，充满个性化的用户名是必须的。</li> 
  </ol> 
  <p>具体操作时，可以实现下面的需求，详见 <a href="http://ebookchain.org/ebookchain.pdf" rel="nofollow">亿书白皮书</a> ：</p> 
  <ol> 
   <li>用户可以注册一个用户名，它相当于是用户帐户的一个别名;</li> 
   <li>用户名都是唯一的;</li> 
   <li>注册后无法更改或删除;</li> 
   <li>用户名可作为支付地址，所以称为<code>别名地址</code>，类似于人们常用的支付宝帐号，其它用户可以直接向该用户的用户名付款，用户不再需要记下一长串的加密货币地址;</li> 
   <li>用户可以维护一个联系人列表。</li> 
  </ol> 
  <p>这些操作和信息，都可以在客户端里完成，如下图所示：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20160625091737291" alt="wallet-add-username" title=""></p> 
  <h4 id="1公共api">1.公共Api</h4> 
  <p>看 <code>modules/accounts.js</code> 368行的代码， 如下：</p> 
  <pre class="prettyprint"><code class=" hljs rust"><span class="hljs-comment">// 368行</span>
router.map(shared, {
  <span class="hljs-string">"post /open"</span>: <span class="hljs-string">"open"</span>,
  <span class="hljs-string">"get /getBalance"</span>: <span class="hljs-string">"getBalance"</span>,
  <span class="hljs-string">"get /getPublicKey"</span>: <span class="hljs-string">"getPublickey"</span>,
  <span class="hljs-string">"post /generatePublicKey"</span>: <span class="hljs-string">"generatePublickey"</span>,
  <span class="hljs-string">"get /delegates"</span>: <span class="hljs-string">"getDelegates"</span>,
  <span class="hljs-string">"get /delegates/fee"</span>: <span class="hljs-string">"getDelegatesFee"</span>,
  <span class="hljs-string">"put /delegates"</span>: <span class="hljs-string">"addDelegates"</span>,
  <span class="hljs-string">"get /username/get"</span>: <span class="hljs-string">"getUsername"</span>,
  <span class="hljs-string">"get /username/fee"</span>: <span class="hljs-string">"getUsernameFee"</span>,
  <span class="hljs-string">"put /username"</span>: <span class="hljs-string">"addUsername"</span>,
  <span class="hljs-string">"get /"</span>: <span class="hljs-string">"getAccount"</span>
});

<span class="hljs-comment">// 439行</span>
library.network.app.<span class="hljs-keyword">use</span>(<span class="hljs-string">'/api/accounts'</span>, router);</code></pre> 
  <p>前面，我们分析过，这里的router是<code>helpers/router.js</code>的一个实例。上述代码，最终会在439行的调用中，映射为公共Api，并分别对应<code>shared</code>中的方法，如：</p> 
  <pre class="prettyprint"><code class=" hljs livecodeserver">// accounts
<span class="hljs-built_in">get</span> /api/accounts/ -&gt; shared.getAccount<span class="hljs-comment"> //帐号主页</span>

<span class="hljs-built_in">post</span> /api/accounts/<span class="hljs-built_in">open</span> -&gt; shared.<span class="hljs-built_in">open</span><span class="hljs-comment"> //登录</span>
<span class="hljs-built_in">get</span> /api/accounts/getBalance -&gt; shared.getBalance
<span class="hljs-built_in">get</span> /api/accounts/getPublicKey -&gt; shared.getPublickey
<span class="hljs-built_in">post</span> /api/accounts/generatePublicKey -&gt; shared.generatePublickey
<span class="hljs-comment"> // username</span>
<span class="hljs-built_in">get</span> /api/accounts/username/<span class="hljs-built_in">get</span> -&gt; shared.getUsername
<span class="hljs-built_in">get</span> /api/accounts/username/fee -&gt; shared.getUsernameFee
<span class="hljs-built_in">put</span> /api/accounts/username -&gt; shared.addUsername<span class="hljs-comment"> //注册用户名</span>
<span class="hljs-comment"> // delegates</span>
<span class="hljs-built_in">get</span> /api/accounts/delegates -&gt; shared.getDelegates
<span class="hljs-built_in">get</span> /api/accounts/delegates/fee -&gt; shared.getDelegatesFee
<span class="hljs-built_in">put</span> /api/accounts/delegates -&gt; shared.addDelegates
<span class="hljs-comment"> // count 对应431行单独定义</span>
<span class="hljs-built_in">get</span> /api/accounts/count -&gt; <span class="hljs-keyword">private</span>.accounts
<span class="hljs-comment"> // 另外两个是在debug或top环境下调试用的，暂且不表。</span>
...</code></pre> 
  <p>这里的<code>delegates</code>（受托人）api，以及后面的debug环境下的api，暂且不提。通盘浏览这些公开接口信息，我们知道，可以直接浏览的信息主要包括余额（balance)、公钥（publicKey)、用户名（username）及修改用户名需要花费的费用（fee），以及受托人及其费用等，可以产生公钥和添加用户名。但是，没有删除和修改用户名的功能，所以一旦注册了用户名，想要修改，只能重新注册一个。</p> 
  <h4 id="2hash地址">2.Hash地址</h4> 
  <p>比特币地址是使用前缀来区分的，比如：1开头的地址就是我们实际使用的地址，3开头的地址是测试地址。而亿书，使用后缀来区分，通常以L结尾。代码在modules/accounts.js文件里：</p> 
  <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-comment">// 455行</span>
Accounts.prototype.generateAddressByPublicKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(publicKey)</span> {</span>
    <span class="hljs-keyword">var</span> publicKeyHash = crypto.createHash(<span class="hljs-string">'sha256'</span>).update(publicKey, <span class="hljs-string">'hex'</span>).digest();
    <span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">8</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) {
        temp[i] = publicKeyHash[<span class="hljs-number">7</span> - i];
    }

    <span class="hljs-keyword">var</span> address = bignum.fromBuffer(temp).toString() + <span class="hljs-string">'L'</span>;
    <span class="hljs-keyword">if</span> (!address) {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"wrong publicKey "</span> + publicKey);
    }
    <span class="hljs-keyword">return</span> address;
};</code></pre> 
  <p>另一个类似的地址，就是区块链的以c结尾的块地址，用来标注<code>generatorId</code>，代码与上面的基本一致：</p> 
  <pre class="prettyprint"><code class=" hljs php"><span class="hljs-comment">// logic/block.js 20行</span>
<span class="hljs-keyword">private</span>.getAddressByPublicKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(publicKey)</span> {</span>
    <span class="hljs-keyword">var</span> publicKeyHash = crypto.createHash(<span class="hljs-string">'sha256'</span>).update(publicKey, <span class="hljs-string">'hex'</span>).digest();
    <span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">8</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) {
        temp[i] = publicKeyHash[<span class="hljs-number">7</span> - i];
    }

    <span class="hljs-keyword">var</span> address = bignum.fromBuffer(temp).toString() + <span class="hljs-string">"C"</span>;
    <span class="hljs-keyword">return</span> address;
}

<span class="hljs-comment">// 上面的方法，在312行dbRead函数里调用，</span>
generatorId: <span class="hljs-keyword">private</span>.getAddressByPublicKey(raw.b_generatorPublicKey),</code></pre> 
  <h4 id="3别名地址">3.别名地址</h4> 
  <p>用户名相当于地址别名，就像支付宝帐号，所以白皮书说“别名地址”。我们知道，只有在转移支付的时候，才会用到地址（接受地址和发送地址），所以体现把用户名当作地址的逻辑代码，自然要在处理“资金转移”的交易代码里，看看<code>modules/transactions.js</code>文件，具体如下：</p> 
  <pre class="prettyprint"><code class=" hljs r">// modules/transactions.js 文件
// <span class="hljs-number">652</span>行
shared.addTransactions = <span class="hljs-keyword">function</span> (req, cb) {
    var body = req.body;
    library.scheme.validate(body, {
        <span class="hljs-keyword">...</span>
        },
    // <span class="hljs-number">685</span>行
        required: [<span class="hljs-string">"secret"</span>, <span class="hljs-string">"amount"</span>, <span class="hljs-string">"recipientId"</span>]
    }, <span class="hljs-keyword">function</span> (err) {
    <span class="hljs-keyword">...</span>

    // <span class="hljs-number">702</span>行
        var isAddress = /^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+[L|l]$/g;
        <span class="hljs-keyword">if</span> (isAddress.test(body.recipientId)) {
            query.address = body.recipientId;
        } <span class="hljs-keyword">else</span> {
            query.username = body.recipientId;
        }

    library.balancesSequence.add(<span class="hljs-keyword">function</span> (cb) {
            modules.accounts.getAccount(query, <span class="hljs-keyword">function</span> (err, recipient) {
                <span class="hljs-keyword">...</span>
        // <span class="hljs-number">717</span>行
                var recipientId = recipient ? recipient.address : body.recipientId;
                var recipientUsername = recipient ? recipient.username : null;

                            <span class="hljs-keyword">...</span>

                            <span class="hljs-keyword">try</span> {
                                var transaction = library.logic.transaction.create({
                  // <span class="hljs-number">764</span>行
                  type: TransactionTypes.SEND,
                                    amount: body.amount,
                                    sender: account,
                                    recipientId: recipientId,
                                    recipientUsername: recipientUsername,
                                    keypair: keypair,
                                    requester: keypair,
                                    secondKeypair: secondKeypair
                                });
                            } catch (e) {
                                <span class="hljs-keyword">return</span> cb(e.toString());
                            }
                        <span class="hljs-keyword">...</span></code></pre> 
  <p>上述代码，实现的就是资金转账的功能（后台编码的交易类型<code>TransactionTypes.SEND</code>，见764行），毫无疑问，必须提供三个参数”secret”, “amount”, “recipientId”（见685行）。从702行可知，其中<code>recipientId</code> 可以是字符串地址，也可以是用户名。从764行以后的代码还可以了解到，交易时的<code>recipientId</code>和<code>recipientUsername</code>字段都保存在数据库里了。</p> 
  <h4 id="4注册用户名">4.注册用户名</h4> 
  <p>亿书默认不提供别名地址，需要用户注册。从上面的Api，很容易找到“注册用户名”的源码方法<code>shared.addUsername</code>，如下：</p> 
  <pre class="prettyprint"><code class=" hljs r">// <span class="hljs-number">868</span>行
shared.addUsername = <span class="hljs-keyword">function</span> (req, cb) {
    var body = req.body;
    library.scheme.validate(body, {
        type: <span class="hljs-string">"object"</span>,
        properties: {
      <span class="hljs-keyword">...</span>
        },

    // <span class="hljs-number">890</span>行
        required: [<span class="hljs-string">'secret'</span>, <span class="hljs-string">'username'</span>]
    }, <span class="hljs-keyword">function</span> (err) {
      // <span class="hljs-number">896</span>行
        var hash = crypto.createHash(<span class="hljs-string">'sha256'</span>).update(body.secret, <span class="hljs-string">'utf8'</span>).digest();
        var keypair = ed.MakeKeypair(hash);

        <span class="hljs-keyword">if</span> (body.publicKey) {
            <span class="hljs-keyword">if</span> (keypair.publicKey.toString(<span class="hljs-string">'hex'</span>) != body.publicKey) {
                <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Invalid passphrase"</span>);
            }
        }

        library.balancesSequence.add(<span class="hljs-keyword">function</span> (cb) {
            <span class="hljs-keyword">if</span> (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(<span class="hljs-string">'hex'</span>)) {
                modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, <span class="hljs-keyword">function</span> (err, account) {
          <span class="hljs-keyword">...</span>

                    modules.accounts.getAccount({publicKey: keypair.publicKey}, <span class="hljs-keyword">function</span> (err, requester) {
            <span class="hljs-keyword">...</span>
                        <span class="hljs-keyword">try</span> {
              // <span class="hljs-number">949</span>行
                            var transaction = library.logic.transaction.create({
                                type: TransactionTypes.USERNAME,
                                username: body.username,
                                sender: account,
                                keypair: keypair,
                                secondKeypair: secondKeypair,
                                requester: keypair
                            });
                        } catch (e) {
                            <span class="hljs-keyword">return</span> cb(e.toString());
                        }
                        modules.transactions.receiveTransactions([transaction], cb);
                    });
                });
            } <span class="hljs-keyword">else</span> {
                self.getAccount({publicKey: keypair.publicKey.toString(<span class="hljs-string">'hex'</span>)}, <span class="hljs-keyword">function</span> (err, account) {
                    <span class="hljs-keyword">...</span>

                    <span class="hljs-keyword">try</span> {
            // <span class="hljs-number">984</span>行
                        var transaction = library.logic.transaction.create({
                            type: TransactionTypes.USERNAME,
                            username: body.username,
                            sender: account,
                            keypair: keypair,
                            secondKeypair: secondKeypair
                        });
                    } catch (e) {
                        <span class="hljs-keyword">return</span> cb(e.toString());
                    }
                    modules.transactions.receiveTransactions([transaction], cb);
                });
            }

        <span class="hljs-keyword">...</span></code></pre> 
  <p>分析代码949行和984行，可以了解到，所谓的<code>注册用户名</code>，实质上就是提交了一个<code>TransactionTypes.USERNAME</code>类型的交易。890行代码，说明该Api必须两个参数，用户要提供明文密码(secret)和用户名(username)。</p> 
  <h4 id="5联系人列表">5.联系人列表</h4> 
  <p>亿书具备社交功能，维护了一个联系人列表。与传统中心化软件不同的是，加密货币系统里，处处是交易，用户关注其他用户的行为，也是一项交易（内部的交易类型为<code>TransactionTypes.FOLLOW</code>）。</p> 
  <p>这项功能的源码在文件<code>modules/contacts.js</code>里，类图如下：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20160625091839637" alt="contacts-class.png" title=""></p> 
  <p>与其他模块文件一样，我们可以非常清晰的看到该文件提供的公共Api，如下：</p> 
  <pre class="prettyprint"><code class=" hljs d"><span class="hljs-comment">// modules/contacts.js文件</span>
<span class="hljs-comment">// 198行</span>
router.map(<span class="hljs-keyword">shared</span>, {
  <span class="hljs-string">"get /unconfirmed"</span>: <span class="hljs-string">"getUnconfirmedContacts"</span>,
  <span class="hljs-string">"get /"</span>: <span class="hljs-string">"getContacts"</span>,
  <span class="hljs-string">"put /"</span>: <span class="hljs-string">"addContact"</span>,
  <span class="hljs-string">"get /fee"</span>: <span class="hljs-string">"getFee"</span>
});</code></pre> 
  <p>这些Api很简单，我们重点关注其中两个Api：</p> 
  <pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-built_in">put</span> /api/contacts -&gt; shared.addContact<span class="hljs-comment"> //添加关注功能</span>
<span class="hljs-built_in">get</span> /api/contacts -&gt; shared.getContacts<span class="hljs-comment"> //获得列表</span></code></pre> 
  <p>对应方法的源码：</p> 
  <pre class="prettyprint"><code class=" hljs r">// <span class="hljs-number">406</span>行
shared.addContact = <span class="hljs-keyword">function</span> (req, cb) {
    var body = req.body;
    library.scheme.validate(body, {
        <span class="hljs-keyword">...</span>
    // <span class="hljs-number">431</span>行
        required: [<span class="hljs-string">"secret"</span>, <span class="hljs-string">"following"</span>]
    }, <span class="hljs-keyword">function</span> (err) {
        <span class="hljs-keyword">...</span>

    // <span class="hljs-number">448</span>行
        var followingAddress = body.following.substring(<span class="hljs-number">1</span>, body.following.length);
        var isAddress = /^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+[L|l]$/g;
        <span class="hljs-keyword">if</span> (isAddress.test(followingAddress)) {
            query.address = followingAddress;
        } <span class="hljs-keyword">else</span> {
            query.username = followingAddress;
        }

        library.balancesSequence.add(<span class="hljs-keyword">function</span> (cb) {
            <span class="hljs-keyword">if</span> (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(<span class="hljs-string">'hex'</span>)) {
        <span class="hljs-keyword">...</span>
                        <span class="hljs-keyword">try</span> {
                            var transaction = library.logic.transaction.create({
                                type: TransactionTypes.FOLLOW,
                                sender: account,
                                keypair: keypair,
                                secondKeypair: secondKeypair,
                                contactAddress: followingAddress, // <span class="hljs-number">511</span>行
                                requester: keypair
                            });
                        } catch (e) {
                            <span class="hljs-keyword">return</span> cb(e.toString());
                        }
                        modules.transactions.receiveTransactions([transaction], cb);
                    });
                });
            <span class="hljs-keyword">...</span></code></pre> 
  <p>431行，添加关注需要两个参数”secret”和”following”，这里”following”其实就是用户的帐号地址或用户名（见448行）。然后，经过一系列验证之后，写入数据库的<code>contactAddress</code>字段（见511行），一个关注的操作过程就完成了。</p> 
  <p>然后，用户通过客户端浏览自己的联系人列表，需要用到另一个Api，对应的方法是<code>shared.getContacts</code>，如下：</p> 
  <pre class="prettyprint"><code class=" hljs r">shared.getContacts = <span class="hljs-keyword">function</span> (req, cb) {
      // <span class="hljs-number">362</span>行
        modules.accounts.getAccount({address: query.address}, <span class="hljs-keyword">function</span> (err, account) {
            <span class="hljs-keyword">...</span>

            async.series({
                contacts: <span class="hljs-keyword">function</span> (cb) {
          // <span class="hljs-number">372</span>行
                    <span class="hljs-keyword">if</span> (!account.contacts.length) {
                        <span class="hljs-keyword">return</span> cb(null, []);
                    }
                    modules.accounts.getAccounts({address: {$<span class="hljs-keyword">in</span>: account.contacts}}, [<span class="hljs-string">"address"</span>, <span class="hljs-string">"username"</span>], cb);
                },
                followers: <span class="hljs-keyword">function</span> (cb) {
                    <span class="hljs-keyword">if</span> (!account.followers.length) {
                        <span class="hljs-keyword">return</span> cb(null, []);
                    }
                    modules.accounts.getAccounts({address: {$<span class="hljs-keyword">in</span>: account.followers}}, [<span class="hljs-string">"address"</span>, <span class="hljs-string">"username"</span>], cb);
                }
            <span class="hljs-keyword">...</span>
            });
        });
    });
};</code></pre> 
  <p>这段代码最重要的部分，就是362行<code>modules.accounts.getAccount</code>方法的调用，获得对应地址的用户帐号（<code>account</code>）实例，联系人都保存在该实例的<code>account.contacts</code>里。</p> 
  <h2 id="总结">总结</h2> 
  <p>读完代码，可以发现，代码逻辑非常简单，仅仅相当于两个基本功能，一个是生成加密货币的Hash地址，另一个是通过<code>交易</code>模块扩展和关联其他功能。其中，Hash地址是基础，在整个亿书的开发设计中，无处不在，签名、验证和交易，以及区块链等需要它。接下来我们介绍签名和验证，请看下一篇：<strong>签名和多重签名</strong>。</p> 
  <h2 id="链接">链接</h2> 
  <p><strong>本系列文章即时更新，若要掌握最新内容，请关注下面的链接</strong></p> 
  <p>本源文地址： <a href="https://github.com/imfly/bitcoin-on-nodejs" rel="nofollow">https://github.com/imfly/bitcoin-on-nodejs</a></p> 
  <p>首发区块链俱乐部： <a href="http://chainclub.org" rel="nofollow">http://chainclub.org</a></p> 
  <p>亿书官方网站： <a href="http://ebookchain.org" rel="nofollow">http://ebookchain.org</a></p> 
  <p>亿书开发QQ群： 185046161 (亿书为开源项目，欢迎各界小伙伴参与）</p> 
  <h2 id="参考">参考</h2> 
  <p><a href="http://ebookchain.org/ebookchain.pdf" rel="nofollow">亿书白皮书 http://ebookchain.org/ebookchain.pdf</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/imfly/article/details/51757186,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/imfly/article/details/51757186,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
