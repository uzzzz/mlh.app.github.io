<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>聚合支付ping++流程和SDK使用，你没看错，是一样的 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="聚合支付ping++流程和SDK使用，你没看错，是一样的" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Ping++ SDK 1.简介 Ping++ SDK包括Server和Client两部分。 其中Server目前支持&nbsp;PHP，Java，Python，Node.js，Ruby，Go，C#&nbsp;七种语言。 Client目前支持&nbsp;iOS终端，Android终端，手机网页和PC网页这四种平台，分别对应iOS，Android，HTML5和PC这四种Client SDK。 2.环境 为了提高接入效率，Ping++提供了Live和Test两个工作模式提供开发者接入时使用，这两种模式切换非常简单，只需要在使用Server SDK 的过程中设置&nbsp;API Key&nbsp;时根据自己的需要使用相应的Key即可，设置为test key 表明使用Test 模式，设置为live key 则使用Live模式。Test Key 在你注册Ping++后即可自动获得，Live key 则是在你完成签约后获得。 1??Test 模式 Test模式提供开发测试时使用。因为Test模式吧支付流程与渠道草书隔离开，所以开发可以与渠道申请同时进行，从而缩短接入调试时间，Test 模式中发起虚拟交易不会调用真实支付控件，支付时客户端会调转到Ping++提供的支付页面 2??Live 模式 Live 时应用上线的模式。该模式下会发生真实的交易，调起真实的支付控件产生真实的资金流动，所以请确保在Test模式下所有的攻能逗测试通过后，在切换到Live模式。 3.参数 应用在接入 Ping++ SDK 时，需要使用以下三个参数，这三个参数你可以在管理平台中获取： 1??API Key：是 Ping++ 分配给你的唯一身份标识，即上面说到的Test Key&nbsp;和&nbsp;Live Key。 2??应用ID：是 Ping++ 分配给你的应用的唯一标识。 3??Notify URL：是 Ping++&nbsp;系统用来向你的应用后台推送异步通知时使用的地址，该地址必须是一个互联网可以访问的地址。你可以在 Ping++ 管理平台中对应的应用内进行设置。 下面介绍下Ping++如何发起并完成支付 1.&nbsp;Client 发送支付要素给 Server 用户选择渠道点击交易按钮， Client 收集交易所需的相关参数传递给 Server （服务器的地址为代码中的 URL） &nbsp; NSMutableURLRequest * postRequest=[NSMutableURLRequest requestWithURL:url]; &nbsp; &nbsp; NSDictionary* dict = @{ &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @&quot;channel&quot; : self.channel, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @&quot;amount&quot;&nbsp; : amountStr &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }; [postRequest setHTTPMethod:@&quot;POST&quot;]; &nbsp; &nbsp; [postRequest setValue:@&quot;application/json; charset=utf-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; &nbsp; &nbsp; NSData* data = [NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil]; &nbsp; &nbsp; NSString *bodyData = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; &nbsp; &nbsp; [postRequest setHTTPBody:[NSData dataWithBytes:[bodyData UTF8String] length:strlen([bodyData UTF8String])]]; &nbsp; &nbsp; ViewController * __weak weakSelf = self; &nbsp; &nbsp; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; &nbsp; &nbsp; [self showAlertWait]; &nbsp; &nbsp; [NSURLConnection sendAsynchronousRequest:postRequest queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) { &nbsp; &nbsp; &nbsp; &nbsp; dispatch_async(dispatch_get_main_queue(), ^{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*)response; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf hideAlert]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (httpResponse.statusCode != 200) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;statusCode=%ld error = %@&quot;, (long)httpResponse.statusCode, connectionError); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:kErrorNet]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (connectionError != nil) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;error = %@&quot;, connectionError); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:kErrorNet]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSString* charge = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;charge = %@&quot;, charge); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //客户端从服务器端拿到charge对象后，调用下面的方法 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//请看3.Client 调起支付控件完成支付 &nbsp; &nbsp; &nbsp; &nbsp;}); &nbsp; &nbsp; }]; &nbsp; 2. Server 发送支付请求并将返回的支付凭据传给 Client Server 接收并处理 Client 传过来的数据，使用 Ping++ 提供的方法向 Ping++ 发起交易，并将从 Ping++ 获得的带支付凭据的 Charge 对象返回给 Client。 3. Client 调起支付控件完成支付 Client 接收 Server 返回的带支付凭据的 Charge 对象并用之调起支付插件完成交易. //客户端从服务器端拿到charge对象后，调用下面的方法 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Pingpp createPayment:charge viewController:weakSelf appURLScheme:kUrlScheme withCompletion:^(NSString *result, PingppError *error) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;completion block: %@&quot;, result); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error == nil) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;支付成功&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;PingppError: code=%lu msg=%@&quot;, (unsigned&nbsp; long)error.code, [error getMsg]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;支付失败&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:result]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }]; 4. 渠道同步返回支付结果给 Client 在上一步中用户完成了支付，渠道会返回一个支付结果给客户端，这里 Client 需要做的是处理此结果。 渠道为银联、百度钱包或者渠道为支付宝但未安装支付宝钱包时，交易结果会在调起插件时的 Completion 中返回。 渠道为微信、支付宝且安装了支付宝钱包时，请实现&nbsp;UIApplicationDelegate&nbsp;的&nbsp;- application:openURL:sourceApplication:annotation:&nbsp;方法： #warning 渠道为微信、支付宝且安装了支付宝钱包时实现方法 - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary*)options{ &nbsp; &nbsp; [Pingpp handleOpenURL:[NSURL URLWithString:kUrl] withCompletion:^(NSString *result, PingppError *error) { &nbsp; &nbsp; &nbsp; &nbsp; if ([result isEqualToString:@&quot;success&quot;]) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //... &nbsp; &nbsp; &nbsp; &nbsp; }else{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;PingppError: code=%lu msg=%@&quot;, error.code, [error getMsg]); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; }]; &nbsp; &nbsp; return YES; } 5. Server 收到 Ping++ 发送的交易结果的异步通知 Ping++ 会把从渠道收到的异步通知告诉商户 Server，客户 Server 接收到异步通知是一个带支付状态的完整的 Charge 对象，客户在接收到异步通知后需要回复 success 给 Ping++ 表明成功收到异步通知。所有的交易结果，商户均须以异步通知结果为准。关于异步通知具体请参见 API Reference 文档。 阅读更多" />
<meta property="og:description" content="Ping++ SDK 1.简介 Ping++ SDK包括Server和Client两部分。 其中Server目前支持&nbsp;PHP，Java，Python，Node.js，Ruby，Go，C#&nbsp;七种语言。 Client目前支持&nbsp;iOS终端，Android终端，手机网页和PC网页这四种平台，分别对应iOS，Android，HTML5和PC这四种Client SDK。 2.环境 为了提高接入效率，Ping++提供了Live和Test两个工作模式提供开发者接入时使用，这两种模式切换非常简单，只需要在使用Server SDK 的过程中设置&nbsp;API Key&nbsp;时根据自己的需要使用相应的Key即可，设置为test key 表明使用Test 模式，设置为live key 则使用Live模式。Test Key 在你注册Ping++后即可自动获得，Live key 则是在你完成签约后获得。 1??Test 模式 Test模式提供开发测试时使用。因为Test模式吧支付流程与渠道草书隔离开，所以开发可以与渠道申请同时进行，从而缩短接入调试时间，Test 模式中发起虚拟交易不会调用真实支付控件，支付时客户端会调转到Ping++提供的支付页面 2??Live 模式 Live 时应用上线的模式。该模式下会发生真实的交易，调起真实的支付控件产生真实的资金流动，所以请确保在Test模式下所有的攻能逗测试通过后，在切换到Live模式。 3.参数 应用在接入 Ping++ SDK 时，需要使用以下三个参数，这三个参数你可以在管理平台中获取： 1??API Key：是 Ping++ 分配给你的唯一身份标识，即上面说到的Test Key&nbsp;和&nbsp;Live Key。 2??应用ID：是 Ping++ 分配给你的应用的唯一标识。 3??Notify URL：是 Ping++&nbsp;系统用来向你的应用后台推送异步通知时使用的地址，该地址必须是一个互联网可以访问的地址。你可以在 Ping++ 管理平台中对应的应用内进行设置。 下面介绍下Ping++如何发起并完成支付 1.&nbsp;Client 发送支付要素给 Server 用户选择渠道点击交易按钮， Client 收集交易所需的相关参数传递给 Server （服务器的地址为代码中的 URL） &nbsp; NSMutableURLRequest * postRequest=[NSMutableURLRequest requestWithURL:url]; &nbsp; &nbsp; NSDictionary* dict = @{ &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @&quot;channel&quot; : self.channel, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @&quot;amount&quot;&nbsp; : amountStr &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }; [postRequest setHTTPMethod:@&quot;POST&quot;]; &nbsp; &nbsp; [postRequest setValue:@&quot;application/json; charset=utf-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; &nbsp; &nbsp; NSData* data = [NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil]; &nbsp; &nbsp; NSString *bodyData = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; &nbsp; &nbsp; [postRequest setHTTPBody:[NSData dataWithBytes:[bodyData UTF8String] length:strlen([bodyData UTF8String])]]; &nbsp; &nbsp; ViewController * __weak weakSelf = self; &nbsp; &nbsp; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; &nbsp; &nbsp; [self showAlertWait]; &nbsp; &nbsp; [NSURLConnection sendAsynchronousRequest:postRequest queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) { &nbsp; &nbsp; &nbsp; &nbsp; dispatch_async(dispatch_get_main_queue(), ^{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*)response; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf hideAlert]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (httpResponse.statusCode != 200) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;statusCode=%ld error = %@&quot;, (long)httpResponse.statusCode, connectionError); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:kErrorNet]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (connectionError != nil) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;error = %@&quot;, connectionError); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:kErrorNet]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSString* charge = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;charge = %@&quot;, charge); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //客户端从服务器端拿到charge对象后，调用下面的方法 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//请看3.Client 调起支付控件完成支付 &nbsp; &nbsp; &nbsp; &nbsp;}); &nbsp; &nbsp; }]; &nbsp; 2. Server 发送支付请求并将返回的支付凭据传给 Client Server 接收并处理 Client 传过来的数据，使用 Ping++ 提供的方法向 Ping++ 发起交易，并将从 Ping++ 获得的带支付凭据的 Charge 对象返回给 Client。 3. Client 调起支付控件完成支付 Client 接收 Server 返回的带支付凭据的 Charge 对象并用之调起支付插件完成交易. //客户端从服务器端拿到charge对象后，调用下面的方法 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Pingpp createPayment:charge viewController:weakSelf appURLScheme:kUrlScheme withCompletion:^(NSString *result, PingppError *error) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;completion block: %@&quot;, result); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error == nil) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;支付成功&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;PingppError: code=%lu msg=%@&quot;, (unsigned&nbsp; long)error.code, [error getMsg]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;支付失败&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:result]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }]; 4. 渠道同步返回支付结果给 Client 在上一步中用户完成了支付，渠道会返回一个支付结果给客户端，这里 Client 需要做的是处理此结果。 渠道为银联、百度钱包或者渠道为支付宝但未安装支付宝钱包时，交易结果会在调起插件时的 Completion 中返回。 渠道为微信、支付宝且安装了支付宝钱包时，请实现&nbsp;UIApplicationDelegate&nbsp;的&nbsp;- application:openURL:sourceApplication:annotation:&nbsp;方法： #warning 渠道为微信、支付宝且安装了支付宝钱包时实现方法 - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary*)options{ &nbsp; &nbsp; [Pingpp handleOpenURL:[NSURL URLWithString:kUrl] withCompletion:^(NSString *result, PingppError *error) { &nbsp; &nbsp; &nbsp; &nbsp; if ([result isEqualToString:@&quot;success&quot;]) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //... &nbsp; &nbsp; &nbsp; &nbsp; }else{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;PingppError: code=%lu msg=%@&quot;, error.code, [error getMsg]); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; }]; &nbsp; &nbsp; return YES; } 5. Server 收到 Ping++ 发送的交易结果的异步通知 Ping++ 会把从渠道收到的异步通知告诉商户 Server，客户 Server 接收到异步通知是一个带支付状态的完整的 Charge 对象，客户在接收到异步通知后需要回复 success 给 Ping++ 表明成功收到异步通知。所有的交易结果，商户均须以异步通知结果为准。关于异步通知具体请参见 API Reference 文档。 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-06-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Ping++ SDK 1.简介 Ping++ SDK包括Server和Client两部分。 其中Server目前支持&nbsp;PHP，Java，Python，Node.js，Ruby，Go，C#&nbsp;七种语言。 Client目前支持&nbsp;iOS终端，Android终端，手机网页和PC网页这四种平台，分别对应iOS，Android，HTML5和PC这四种Client SDK。 2.环境 为了提高接入效率，Ping++提供了Live和Test两个工作模式提供开发者接入时使用，这两种模式切换非常简单，只需要在使用Server SDK 的过程中设置&nbsp;API Key&nbsp;时根据自己的需要使用相应的Key即可，设置为test key 表明使用Test 模式，设置为live key 则使用Live模式。Test Key 在你注册Ping++后即可自动获得，Live key 则是在你完成签约后获得。 1??Test 模式 Test模式提供开发测试时使用。因为Test模式吧支付流程与渠道草书隔离开，所以开发可以与渠道申请同时进行，从而缩短接入调试时间，Test 模式中发起虚拟交易不会调用真实支付控件，支付时客户端会调转到Ping++提供的支付页面 2??Live 模式 Live 时应用上线的模式。该模式下会发生真实的交易，调起真实的支付控件产生真实的资金流动，所以请确保在Test模式下所有的攻能逗测试通过后，在切换到Live模式。 3.参数 应用在接入 Ping++ SDK 时，需要使用以下三个参数，这三个参数你可以在管理平台中获取： 1??API Key：是 Ping++ 分配给你的唯一身份标识，即上面说到的Test Key&nbsp;和&nbsp;Live Key。 2??应用ID：是 Ping++ 分配给你的应用的唯一标识。 3??Notify URL：是 Ping++&nbsp;系统用来向你的应用后台推送异步通知时使用的地址，该地址必须是一个互联网可以访问的地址。你可以在 Ping++ 管理平台中对应的应用内进行设置。 下面介绍下Ping++如何发起并完成支付 1.&nbsp;Client 发送支付要素给 Server 用户选择渠道点击交易按钮， Client 收集交易所需的相关参数传递给 Server （服务器的地址为代码中的 URL） &nbsp; NSMutableURLRequest * postRequest=[NSMutableURLRequest requestWithURL:url]; &nbsp; &nbsp; NSDictionary* dict = @{ &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @&quot;channel&quot; : self.channel, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @&quot;amount&quot;&nbsp; : amountStr &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }; [postRequest setHTTPMethod:@&quot;POST&quot;]; &nbsp; &nbsp; [postRequest setValue:@&quot;application/json; charset=utf-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; &nbsp; &nbsp; NSData* data = [NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil]; &nbsp; &nbsp; NSString *bodyData = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; &nbsp; &nbsp; [postRequest setHTTPBody:[NSData dataWithBytes:[bodyData UTF8String] length:strlen([bodyData UTF8String])]]; &nbsp; &nbsp; ViewController * __weak weakSelf = self; &nbsp; &nbsp; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; &nbsp; &nbsp; [self showAlertWait]; &nbsp; &nbsp; [NSURLConnection sendAsynchronousRequest:postRequest queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) { &nbsp; &nbsp; &nbsp; &nbsp; dispatch_async(dispatch_get_main_queue(), ^{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*)response; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf hideAlert]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (httpResponse.statusCode != 200) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;statusCode=%ld error = %@&quot;, (long)httpResponse.statusCode, connectionError); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:kErrorNet]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (connectionError != nil) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;error = %@&quot;, connectionError); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:kErrorNet]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSString* charge = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;charge = %@&quot;, charge); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //客户端从服务器端拿到charge对象后，调用下面的方法 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//请看3.Client 调起支付控件完成支付 &nbsp; &nbsp; &nbsp; &nbsp;}); &nbsp; &nbsp; }]; &nbsp; 2. Server 发送支付请求并将返回的支付凭据传给 Client Server 接收并处理 Client 传过来的数据，使用 Ping++ 提供的方法向 Ping++ 发起交易，并将从 Ping++ 获得的带支付凭据的 Charge 对象返回给 Client。 3. Client 调起支付控件完成支付 Client 接收 Server 返回的带支付凭据的 Charge 对象并用之调起支付插件完成交易. //客户端从服务器端拿到charge对象后，调用下面的方法 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Pingpp createPayment:charge viewController:weakSelf appURLScheme:kUrlScheme withCompletion:^(NSString *result, PingppError *error) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;completion block: %@&quot;, result); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error == nil) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;支付成功&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;PingppError: code=%lu msg=%@&quot;, (unsigned&nbsp; long)error.code, [error getMsg]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;支付失败&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:result]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }]; 4. 渠道同步返回支付结果给 Client 在上一步中用户完成了支付，渠道会返回一个支付结果给客户端，这里 Client 需要做的是处理此结果。 渠道为银联、百度钱包或者渠道为支付宝但未安装支付宝钱包时，交易结果会在调起插件时的 Completion 中返回。 渠道为微信、支付宝且安装了支付宝钱包时，请实现&nbsp;UIApplicationDelegate&nbsp;的&nbsp;- application:openURL:sourceApplication:annotation:&nbsp;方法： #warning 渠道为微信、支付宝且安装了支付宝钱包时实现方法 - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary*)options{ &nbsp; &nbsp; [Pingpp handleOpenURL:[NSURL URLWithString:kUrl] withCompletion:^(NSString *result, PingppError *error) { &nbsp; &nbsp; &nbsp; &nbsp; if ([result isEqualToString:@&quot;success&quot;]) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //... &nbsp; &nbsp; &nbsp; &nbsp; }else{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@&quot;PingppError: code=%lu msg=%@&quot;, error.code, [error getMsg]); &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; }]; &nbsp; &nbsp; return YES; } 5. Server 收到 Ping++ 发送的交易结果的异步通知 Ping++ 会把从渠道收到的异步通知告诉商户 Server，客户 Server 接收到异步通知是一个带支付状态的完整的 Charge 对象，客户在接收到异步通知后需要回复 success 给 Ping++ 表明成功收到异步通知。所有的交易结果，商户均须以异步通知结果为准。关于异步通知具体请参见 API Reference 文档。 阅读更多","@type":"BlogPosting","url":"/2016/06/06/ac775eb66e02f8abd02678b8cc6ba78b.html","headline":"聚合支付ping++流程和SDK使用，你没看错，是一样的","dateModified":"2016-06-06T00:00:00+08:00","datePublished":"2016-06-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2016/06/06/ac775eb66e02f8abd02678b8cc6ba78b.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>聚合支付ping++流程和SDK使用，你没看错，是一样的</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> Ping++ SDK</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 1.简介</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> Ping++ SDK包括Server和Client两部分。</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 其中Server目前支持&nbsp;<strong><em><a href="http://www.2cto.com/kf/web/php/" rel="nofollow" class="keylink" style="color:rgb(51,51,51);text-decoration:none;">PHP</a>，<a href="http://www.2cto.com/kf/ware/Java/" rel="nofollow" class="keylink" style="color:rgb(51,51,51);text-decoration:none;">Java</a>，<a href="http://www.2cto.com/kf/web/Python/" rel="nofollow" class="keylink" style="color:rgb(51,51,51);text-decoration:none;">Python</a>，Node.js，Ruby，Go，C#</em></strong>&nbsp;七种语言。</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> Client目前支持&nbsp;<em><strong>iOS终端，<a href="http://www.2cto.com/kf/yidong/Android/" rel="nofollow" class="keylink" style="color:rgb(51,51,51);text-decoration:none;">Android</a>终端，手机网页</strong></em>和<em><strong>PC网页</strong></em>这四种平台，分别对应<em><strong>iOS，Android，HTML5</strong></em>和<em><strong>PC</strong></em>这四种Client SDK。</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 2.环境</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 为了提高接入效率，Ping++提供了Live和Test两个工作模式提供开发者接入时使用，这两种模式切换非常简单，只需要在使用Server SDK 的过程中设置&nbsp;<strong>API Key&nbsp;</strong>时根据自己的需要使用相应的Key即可，设置为test key 表明使用Test 模式，设置为live key 则使用Live模式。Test Key 在你注册Ping++后即可自动获得，Live key 则是在你完成签约后获得。</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 1??Test 模式</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> Test模式提供开发测试时使用。因为Test模式吧支付流程与渠道草书隔离开，所以开发可以与渠道申请同时进行，从而缩短接入调试时间，Test 模式中发起虚拟交易不会调用真实支付控件，支付时客户端会调转到Ping++提供的支付页面</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 2??Live 模式</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> Live 时应用上线的模式。该模式下会发生真实的交易，调起真实的支付控件产生真实的资金流动，所以请确保在Test模式下所有的攻能逗测试通过后，在切换到Live模式。</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 3.参数</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 应用在接入 Ping++ SDK 时，需要使用以下三个参数，这三个参数你可以在管理平台中获取：</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 1??API Key：是 Ping++ 分配给你的唯一身份标识，即上面说到的<strong>Test Key</strong>&nbsp;和&nbsp;<strong>Live Key。</strong></p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> <strong>2??</strong>应用ID：是 Ping++ 分配给你的应用的唯一标识。</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 3??Notify URL：是 Ping++&nbsp;<a href="http://www.2cto.com/os/" rel="nofollow" class="keylink" style="color:rgb(51,51,51);text-decoration:none;">系统</a>用来向你的应用后台推送异步通知时使用的地址，该地址必须是一个互联网可以访问的地址。你可以在 Ping++ 管理平台中对应的应用内进行设置。</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 下面介绍下Ping++如何发起并完成支付</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> <img alt="\" src="http://www.2cto.com/uploadfile/Collfiles/20160215/201602150910448.png" style="border-width:0px;list-style:none;display:block;width:630px;"></p> 
  <h4 style="color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 1.&nbsp;Client 发送支付要素给 Server</h4> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 用户选择渠道点击交易按钮， Client 收集交易所需的相关参数传递给 Server （服务器的地址为代码中的 URL）</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp;</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> NSMutableURLRequest * postRequest=[NSMutableURLRequest requestWithURL:url];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; NSDictionary* dict = @{</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @"channel" : self.channel,</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @"amount"&nbsp; : amountStr</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> [postRequest setHTTPMethod:@"POST"];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; [postRequest setValue:@"application/json; charset=utf-8" forHTTPHeaderField:@"Content-Type"];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; NSData* data = [NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; NSString *bodyData = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; [postRequest setHTTPBody:[NSData dataWithBytes:[bodyData UTF8String] length:strlen([bodyData UTF8String])]];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; ViewController * __weak weakSelf = self;</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; NSOperationQueue *queue = [[NSOperationQueue alloc] init];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; [self showAlertWait];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; [NSURLConnection sendAsynchronousRequest:postRequest queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; dispatch_async(dispatch_get_main_queue(), ^{</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*)response;</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf hideAlert];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (httpResponse.statusCode != 200) {</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@"statusCode=%ld error = %@", (long)httpResponse.statusCode, connectionError);</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:kErrorNet];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (connectionError != nil) {</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@"error = %@", connectionError);</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:kErrorNet];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSString* charge = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@"charge = %@", charge);</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //客户端从服务器端拿到charge对象后，调用下面的方法</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//请看3.Client 调起支付控件完成支付</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp;});</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; }];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp;</p> 
  <h4 style="color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 2. Server 发送支付请求并将返回的支付凭据传给 Client</h4> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> Server 接收并处理 Client 传过来的数据，使用 Ping++ 提供的方法向 Ping++ 发起交易，并将从 Ping++ 获得的带支付凭据的 Charge 对象返回给 Client。</p> 
  <h4 style="color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 3. Client 调起支付控件完成支付</h4> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> Client 接收 Server 返回的带支付凭据的 Charge 对象并用之调起支付插件完成交易.</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> //客户端从服务器端拿到charge对象后，调用下面的方法</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Pingpp createPayment:charge viewController:weakSelf appURLScheme:kUrlScheme withCompletion:^(NSString *result, PingppError *error) {</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@"completion block: %@", result);</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error == nil) {</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@"支付成功");</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@"PingppError: code=%lu msg=%@", (unsigned&nbsp; long)error.code, [error getMsg]);</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@"支付失败");</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [weakSelf showAlertMessage:result];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }];</p> 
  <h4 style="color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 4. 渠道同步返回支付结果给 Client</h4> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 在上一步中用户完成了支付，渠道会返回一个支付结果给客户端，这里 Client 需要做的是处理此结果。</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 渠道为银联、百度钱包或者渠道为支付宝但未安装支付宝钱包时，交易结果会在调起插件时的 Completion 中返回。 渠道为微信、支付宝且安装了支付宝钱包时，请实现&nbsp;<code>UIApplicationDelegate</code>&nbsp;的&nbsp;<code>- application:openURL:sourceApplication:annotation:</code>&nbsp;方法：</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> #warning 渠道为微信、支付宝且安装了支付宝钱包时实现方法</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary*)options{</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; [Pingpp handleOpenURL:[NSURL URLWithString:kUrl] withCompletion:^(NSString *result, PingppError *error) {</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; if ([result isEqualToString:@"success"]) {</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //...</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; }else{</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSLog(@"PingppError: code=%lu msg=%@", error.code, [error getMsg]);</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; &nbsp; &nbsp; }</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; }];</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> &nbsp; &nbsp; return YES;</p> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> }</p> 
  <h4 style="color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> 5. Server 收到 Ping++ 发送的交易结果的异步通知</h4> 
  <p style="border-width:0px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:'宋体';font-size:14px;line-height:28px;background-color:rgb(249,249,249);"> Ping++ 会把从渠道收到的异步通知告诉商户 Server，客户 Server 接收到异步通知是一个带支付状态的完整的 Charge 对象，客户在接收到异步通知后需要回复 success 给 Ping++ 表明成功收到异步通知。所有的交易结果，商户均须以异步通知结果为准。关于异步通知具体请参见 API Reference 文档。</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wang_Bo_JustOne/article/details/51597699,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/wang_Bo_JustOne/article/details/51597699,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
