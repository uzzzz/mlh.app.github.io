<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>《Nodejs开发加密货币》之十九：签名和多重签名 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="《Nodejs开发加密货币》之十九：签名和多重签名" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="前言 加密货币是一种数字资产，随着区块链等相关技术的创新和突破，很多有形或无形资产实现了去中心化。比如我们这里分享的 亿书 就是要把数字出版物版权进行保护，实现去中心化，解决业界多年来版权保护不力的难题。 无论数字资产，还是数字出版版权，都是有明确所有权的，当前实现数字资产所属的技术手段就是本篇要介绍的签名。而多重签名是对签名的扩展使用，给数字资产转移提供了安全保障和技术手段。本篇，从基本概念入手，详细了解签名和多重签名的作用和代码实现。 源码 主要源码地址： signatures.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/signatures.js multisignatures.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/multisignatures.js 解读 签名 （1）签名的作用和特点 名字的解释。签名是什么？有人第一反应是日常生活中的用笔签名，那么我会说，你的直觉是对的。不过，当很多小伙伴看到网上的很多解释，却又迷惑了，事实上不同概念在不同领域的表述是有差别的，但本质相同。我坚信生活是一切创作的源泉，任何一个概念都能从生活中找到原型，这里的“签名”也是如此。 签名的作用。日常生活中，凡是需要确认归属的（是签名人的，不是其他的），都需要所有者进行签名。比如，我签名了一份文件，出了问题，责任我负，我签名了一个支票，就代表将由我支付。我们普通老百姓最常见的场景，就是去银行办业务，银行职员会让你反复签一大堆的单据，想必每个人都会有深刻的印象。 签名的特点。人的笔迹是很个性化的，越熟练的字体，个性特征越固定，因此一个人的名字，不同的人写出完全相同笔迹的概率非常小，即便是专业模仿也可以通过技术鉴别出来，这样一来，人的签名就具有唯一性、可验证的特点，并被法律认可。 签名的验证如果，你拿着一张支票去银行兑换，银行职员会对支票上的签名和印章仔细比对，确保印章大小、样式，以及付款人签名等，与银行留存的信息一致，才会给你兑付，这就是签名验证。 （2）比特币客户端签名功能 数字资产需要签名。类比人类签名，比特币也有签名功能。如果了解比特币钱包（客户端软件），就会发现它提供了一个消息签名的功能，可以用来对其他用户通过比特币网络之外的信息进行签名和验证。我个人使用的是 比特币官方网站 提供的比太钱包，如图： 这个功能干什么用的呢？有好多小伙伴不清楚，这里举个简单的例子解释一下，具体使用的时候绝不限于这些应用。 Alice开了一个网店，但没有直接接入比特币网络，不能自动确认和验证支付者。客户Imfly购买了她的产品，并用比特币支付了全部货款。因为比特币地址和交易都是公开匿名的，为了防止冒充冒领实，Alice需要确认Imfly提供的那个付款地址确实是imfly本人的，否则不能发货。这时候，就需要Imfly先把支付货款的比特币地址和相关交易签名信息（如图），然后通过QQ或邮件传给Alice，Alice使用客户端验证信息签名，才能确认交易确实是Imfly的。 想象一下，如果没有签名功能会怎么样呢？因为比特币仅是一个匿名、安全的支付手段，但却无法确认支付方或收款方是谁，信息的不确定性，将使得比特币网络之外的交易无法达成。在中心化的世界里，这个问题是通过运营平台这个第三方达成的，比如支付宝等，双方的全部信息，平台都掌握，任何一方出现欺诈，都需要通过向平台投诉来解决。用户需要对第三方平台绝对信任，并通过牺牲个人信息安全获得交易的基本保障。 （3）电子签名 通过上述分析，可以理解的是，签名的作用是确定资产所属，其特征是简单、安全、可验证。把这个概念抽象出来，应用到计算机系统里，为了确定数字资产所属，也需要进行签名，这就是大家经常看到的“电子签名”的概念。在网络世界里，签名可以对任何需要确认的数字资产进行处理，比如比特币地址、电子书版权等，并以此来宣告重要资产的所属，这让无需监管的去中心化交易成为可能。 具体开发设计中，就是加密技术代替人的笔迹，不然任何签名方法都会被模仿，而且模仿的成本极低，相反，验证的成本却很高。具体的加密或验证技术，请参考前面的章节，这里我们介绍亿书是如何使用签名技术的。 亿书也具备签名能力，只不过，目前没有单独提供签名信息的操作供用户使用，而是通过签名，添加了支付密码功能，对用户帐号资产追加了一层保护。 （4）亿书的支付密码 签名方法在modules/signatures.js文件里，类图如下： 我们还是从Api开始，代码如下： // modules/signatures.js文件 // 179行 router.map(shared, { &quot;get /fee&quot;: &quot;getFee&quot;, &quot;put /&quot;: &quot;addSignature&quot; }); // 188行 library.network.app.use(&#39;/api/signatures&#39;, router); 通过上面的代码，可以了解签名提供了两个简单的公共接口： get /api/signatures/fee -&gt; shared.getFee put /api/signatures/ -&gt; shared.addSignature //签名操作 显然，最核心的方法也就是shared.addSignature，代码： // 215行 shared.addSignature = function (req, cb) { ... library.scheme.validate(body, { properties: { ... }, required: [&quot;secret&quot;, &quot;secondSecret&quot;] }, function (err) { ... library.balancesSequence.add(function (cb) { if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) { ... try { var transaction = library.logic.transaction.create({ type: TransactionTypes.SIGNATURE, // 297行 sender: account, keypair: keypair, requester: keypair, secondKeypair: secondKeypair, }); } catch (e) { return cb(e.toString()); } ... } 毫无疑问，支付密码也是一个简单的交易（交易类型TransactionTypes.SIGNATURE，见297行）。基于此，我们不难想象，添加类似比特币的签名功能也是件非常简单的事情，我们会在亿书下一个版本里添加这项功能，具体请关注 亿书币版本库 最新进展。 多重签名 上面我们提到，比特币的匿名性，使交易处于不可信之中，最终导致用户不敢交易。有了签名功能，就有了确认双方信息的有效手段，问题总算有了解决方案。聪明的小伙伴会发现，签名和验证过程除了繁琐，并没有让我们觉得比使用第三方平台更有效、更安全。有没有更好的解决方案呢？回答是：有，那就是多重签名。 （1）基本概念 多重签名，可以简单的理解为一个数字资产的多个签名。签名标定的是数字资产所属和权限，多重签名预示着数字资产可由多人支配和管理。在加密货币领域，如果要动用一个加密货币地址的资金，通常需要该地址的所有人使用他的私钥（由用户专属保护）进行签名。那么，多重签名，就是动用这笔资金需要多个私钥签名，通常这笔资金或数字资产会保存在一个多重签名的地址或帐号里。这就好比，我们工作中有一份文件，需要多个部门签署才能生效一样。 在实际的操作过程中，一个多重签名地址可以关联n个私钥，在需要转账等操作时，只要其中的m个私钥签名就可以把资金转移了，其中m要小于等于n，也就是说m/n小于1，可以是2/3, 3/5等等，是要在建立这个多重签名地址的时候确定好的。 （2）工作原理 数字资产在某种情况下，需要多人支配。换句话说，在某些特定条件下，数字资产如果无法确认归属某个特定的人，那么最好让相关人共同签署它的所有权。 仍然举上面的例子，在Alice发货之后，Imfly收到货之前，这笔钱应该由第三方信用比较高的中介暂时保存，这个阶段，这笔钱要么是Alice的，要么是Imfly的，最终的归属要看Imfly是否收到货。所以，这个第三方，无论如何都是应该有的，不然Imfly就要承担大部分风险（因为比特币的单向不可逆，Imfly发送之后就没有办法收回了） 这样一来，这笔钱的所属关系，在交易过程中涉及到Alice、Imfly和平台第三方（虽然不属于它，但它有权裁定资金去向），那么就应该由他们三方签名，因此网上购物就是典型的多重签名的例子。其多重签名模型就是2/3，也就是说只要他们中的两个签名，资金就可以被转移。 具体到这个例子，Imfly把钱打给一个关联三方私钥的多重签名地址，如果整个交易过程顺利，只要Alice和Imfly两个签名，这笔钱就会顺利到达Alice手里。如果不顺利，他们任何一人提出仲裁，平台第三方调查之后，通过签名就能把这笔钱转给Alice或退回Imfly。这非常类似淘宝和京东的模式，但是比他们更加便捷和安全，至少不用担心第三方倒闭、挪用资金或携款跑路。 （3）应用场景 很显然，多重签名给了加密货币腾飞的翅膀，让它单一单项支付的能力更具吸引力，让加密货币技术应用到各行各业成为可能。这里简单的罗列几个应用场景，供探索和思考： 电子商务。比较常见的是2/3的模式。上面电子商务网站的例子，就是最典型的场景之一，目前已经有成功的案例了。延伸一下，这类应用本质就是中介，所以还可用在各类中介机构性质的服务上。 财产分割。比如夫妻双方共有财产，可以使用1/2的模式，一个账户谁都可以使用，跟各自拥有帐号一样，好处是系统忠实记录了每个人的花销，闹掰的时候很容易清算。扩展到公司合伙经营，可以使用1/n模式，n个人合伙人，都可以直接支配共有资金，具体清算时，一目了然。 资金监管。其实，这是多重签名的最直接作用，一笔钱需要多个人签名才能使用，任何一个人都无法直接动用资金，这在生活中太常见了，只要灵活设置多重签名的比重模式，就能解决生活中很多问题。比如，接着上面夫妻的例子，夫妻要储备一笔资金，供孩子上大学使用，在这之前谁都不能动，那么把模式改为2/2，不仅限制了夫妻双方，也给黑客攻击增加了难度。 多重签名的设计，让各种业务去中心化充满无限可能。 （4）亿书的多重签名 多重签名方法在modules/multisignatures.js文件里，类图如下： 实现Api的代码如下： // 318行 router.map(shared, { &quot;get /pending&quot;: &quot;pending&quot;, // Get pending transactions &quot;post /sign&quot;: &quot;sign&quot;, // Sign transaction &quot;put /&quot;: &quot;addMultisignature&quot;, // Add multisignature &quot;get /accounts&quot;: &quot;getAccounts&quot; }); // 329行 library.network.app.use(&#39;/api/multisignatures&#39;, router); 解析一下，最后产生的Api如下： get /api/multisignatures/pending -&gt; shared.pending // 查询等待中的交易 post /api/multisignatures/sign -&gt; shared.sign // 签名交易 put /api/multisignatures/ -&gt; shared.addMultisignature // 创建多重签名帐号 get /api/multisignatures/accounts -&gt; shared.getAccounts // 获得关联的帐号（对应者用户私钥） 提供的功能很显然，包括：待交易查询、关联帐号列表查询，用户签名交易，创建多重签名帐号等4个核心功能。我们先从创建多重签名帐号开始，这个Api使用的是http的put方法，对应的自然是更新操作，不查看代码也可以猜想到，该功能应该是在已有帐号基础上的操作，从客户端钱包设置菜单里，可以看到如图操作： 看看shared.addMultisignature的源代码如下： // modules/multisignatures.js文件 shared.addMultisignature = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... // 732行 required: [&#39;min&#39;, &#39;lifetime&#39;, &#39;keysgroup&#39;, &#39;secret&#39;] }, function (err) { ... library.balancesSequence.add(function (cb) { modules.accounts.getAccount({publicKey: keypair.publicKey.toString(&#39;hex&#39;)}, function (err, account) { ... // 767行 try { var transaction = library.logic.transaction.create({ type: TransactionTypes.MULTI, // 769行 sender: account, keypair: keypair, secondKeypair: secondKeypair, min: body.min, keysgroup: body.keysgroup, lifetime: body.lifetime }); } catch (e) { return cb(e.toString()); } ... }; 从732行可知，创建一个多重签名，必须’min’, ‘lifetime’, ‘keysgroup’, ‘secret’这四参数（其实，一个默认参数就是当前帐号），min代表上面讲到的m值，即需要确认的人数;lifetime代表生命周期;keysgroup包含多重签名关联的全部帐号，它是数组类型，包含的元素个数就是n;secret是用户密码，与用户私钥对应。 经过一系列的验证之后，作为一个交易（交易类型TransactionTypes.MULTI，769行）保存到数据库(区款链)里。创建成功的帐号，可以显示多重帐号菜单，对交易进行操作。接下来，自然应该能够查看全部关联的帐号（请看shared.getAccounts方法），查看待确认的交易（请看shared.pending方法），这两个方法仅仅是简单的查询，没什么难度，这里不再浪费篇幅。 如果用户同意交易，就可以对待确认的交易进行签名（shared.sign方法），这个方法的源码如下： // 586行 shared.sign = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... required: [&#39;transactionId&#39;, &#39;secret&#39;] }, function (err) { ... // 632行 function done(cb) { library.balancesSequence.add(function (cb) { // 634行 var transaction = modules.transactions.getUnconfirmedTransaction(body.transactionId); if (!transaction) { return cb(&quot;Transaction not found&quot;); } // 640行 transaction.signatures = transaction.signatures || []; transaction.signatures.push(sign); library.bus.message(&#39;signature&#39;, { signature: sign, transaction: transaction.id }, true); cb(); }, function (err) { if (err) { return cb(err.toString()); } cb(null, {transactionId: transaction.id}); }); } ... }; 这个方法，相比单独的签名方法，不同的是单独的签名方法相当于一个新建交易，而这里的多重签名的用户签名，显然仅仅是对未确认交易（634行）进行签名确认（640行维护了一个签名数组，641行的push方法把用户签名写入数组）。而且，相比独立签名，验证也更复杂，我们将在下一篇《交易》一文中集中讨论验证问题。您也可以结合下一篇的内容，阅读和理解这里的签名方法。 总结 在加密货币里，每一个交易都涉及到使用私钥签名，用于确认每笔资金所有人。确定了所有人，自然就确定了资金转移的条件、目标和方向，就为我们下一步进行资金转移操作奠定了基础。很自然的，该研究一下亿书的交易了，请看下一篇：《交易》。 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 首发区块链俱乐部： http://chainclub.org 亿书官方网站： http://ebookchain.org 亿书开发QQ群： 185046161 (亿书为开源项目，欢迎各界小伙伴参与） 参考 亿书白皮书 http://ebookchain.org/ebookchain.pdf 阅读更多" />
<meta property="og:description" content="前言 加密货币是一种数字资产，随着区块链等相关技术的创新和突破，很多有形或无形资产实现了去中心化。比如我们这里分享的 亿书 就是要把数字出版物版权进行保护，实现去中心化，解决业界多年来版权保护不力的难题。 无论数字资产，还是数字出版版权，都是有明确所有权的，当前实现数字资产所属的技术手段就是本篇要介绍的签名。而多重签名是对签名的扩展使用，给数字资产转移提供了安全保障和技术手段。本篇，从基本概念入手，详细了解签名和多重签名的作用和代码实现。 源码 主要源码地址： signatures.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/signatures.js multisignatures.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/multisignatures.js 解读 签名 （1）签名的作用和特点 名字的解释。签名是什么？有人第一反应是日常生活中的用笔签名，那么我会说，你的直觉是对的。不过，当很多小伙伴看到网上的很多解释，却又迷惑了，事实上不同概念在不同领域的表述是有差别的，但本质相同。我坚信生活是一切创作的源泉，任何一个概念都能从生活中找到原型，这里的“签名”也是如此。 签名的作用。日常生活中，凡是需要确认归属的（是签名人的，不是其他的），都需要所有者进行签名。比如，我签名了一份文件，出了问题，责任我负，我签名了一个支票，就代表将由我支付。我们普通老百姓最常见的场景，就是去银行办业务，银行职员会让你反复签一大堆的单据，想必每个人都会有深刻的印象。 签名的特点。人的笔迹是很个性化的，越熟练的字体，个性特征越固定，因此一个人的名字，不同的人写出完全相同笔迹的概率非常小，即便是专业模仿也可以通过技术鉴别出来，这样一来，人的签名就具有唯一性、可验证的特点，并被法律认可。 签名的验证如果，你拿着一张支票去银行兑换，银行职员会对支票上的签名和印章仔细比对，确保印章大小、样式，以及付款人签名等，与银行留存的信息一致，才会给你兑付，这就是签名验证。 （2）比特币客户端签名功能 数字资产需要签名。类比人类签名，比特币也有签名功能。如果了解比特币钱包（客户端软件），就会发现它提供了一个消息签名的功能，可以用来对其他用户通过比特币网络之外的信息进行签名和验证。我个人使用的是 比特币官方网站 提供的比太钱包，如图： 这个功能干什么用的呢？有好多小伙伴不清楚，这里举个简单的例子解释一下，具体使用的时候绝不限于这些应用。 Alice开了一个网店，但没有直接接入比特币网络，不能自动确认和验证支付者。客户Imfly购买了她的产品，并用比特币支付了全部货款。因为比特币地址和交易都是公开匿名的，为了防止冒充冒领实，Alice需要确认Imfly提供的那个付款地址确实是imfly本人的，否则不能发货。这时候，就需要Imfly先把支付货款的比特币地址和相关交易签名信息（如图），然后通过QQ或邮件传给Alice，Alice使用客户端验证信息签名，才能确认交易确实是Imfly的。 想象一下，如果没有签名功能会怎么样呢？因为比特币仅是一个匿名、安全的支付手段，但却无法确认支付方或收款方是谁，信息的不确定性，将使得比特币网络之外的交易无法达成。在中心化的世界里，这个问题是通过运营平台这个第三方达成的，比如支付宝等，双方的全部信息，平台都掌握，任何一方出现欺诈，都需要通过向平台投诉来解决。用户需要对第三方平台绝对信任，并通过牺牲个人信息安全获得交易的基本保障。 （3）电子签名 通过上述分析，可以理解的是，签名的作用是确定资产所属，其特征是简单、安全、可验证。把这个概念抽象出来，应用到计算机系统里，为了确定数字资产所属，也需要进行签名，这就是大家经常看到的“电子签名”的概念。在网络世界里，签名可以对任何需要确认的数字资产进行处理，比如比特币地址、电子书版权等，并以此来宣告重要资产的所属，这让无需监管的去中心化交易成为可能。 具体开发设计中，就是加密技术代替人的笔迹，不然任何签名方法都会被模仿，而且模仿的成本极低，相反，验证的成本却很高。具体的加密或验证技术，请参考前面的章节，这里我们介绍亿书是如何使用签名技术的。 亿书也具备签名能力，只不过，目前没有单独提供签名信息的操作供用户使用，而是通过签名，添加了支付密码功能，对用户帐号资产追加了一层保护。 （4）亿书的支付密码 签名方法在modules/signatures.js文件里，类图如下： 我们还是从Api开始，代码如下： // modules/signatures.js文件 // 179行 router.map(shared, { &quot;get /fee&quot;: &quot;getFee&quot;, &quot;put /&quot;: &quot;addSignature&quot; }); // 188行 library.network.app.use(&#39;/api/signatures&#39;, router); 通过上面的代码，可以了解签名提供了两个简单的公共接口： get /api/signatures/fee -&gt; shared.getFee put /api/signatures/ -&gt; shared.addSignature //签名操作 显然，最核心的方法也就是shared.addSignature，代码： // 215行 shared.addSignature = function (req, cb) { ... library.scheme.validate(body, { properties: { ... }, required: [&quot;secret&quot;, &quot;secondSecret&quot;] }, function (err) { ... library.balancesSequence.add(function (cb) { if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) { ... try { var transaction = library.logic.transaction.create({ type: TransactionTypes.SIGNATURE, // 297行 sender: account, keypair: keypair, requester: keypair, secondKeypair: secondKeypair, }); } catch (e) { return cb(e.toString()); } ... } 毫无疑问，支付密码也是一个简单的交易（交易类型TransactionTypes.SIGNATURE，见297行）。基于此，我们不难想象，添加类似比特币的签名功能也是件非常简单的事情，我们会在亿书下一个版本里添加这项功能，具体请关注 亿书币版本库 最新进展。 多重签名 上面我们提到，比特币的匿名性，使交易处于不可信之中，最终导致用户不敢交易。有了签名功能，就有了确认双方信息的有效手段，问题总算有了解决方案。聪明的小伙伴会发现，签名和验证过程除了繁琐，并没有让我们觉得比使用第三方平台更有效、更安全。有没有更好的解决方案呢？回答是：有，那就是多重签名。 （1）基本概念 多重签名，可以简单的理解为一个数字资产的多个签名。签名标定的是数字资产所属和权限，多重签名预示着数字资产可由多人支配和管理。在加密货币领域，如果要动用一个加密货币地址的资金，通常需要该地址的所有人使用他的私钥（由用户专属保护）进行签名。那么，多重签名，就是动用这笔资金需要多个私钥签名，通常这笔资金或数字资产会保存在一个多重签名的地址或帐号里。这就好比，我们工作中有一份文件，需要多个部门签署才能生效一样。 在实际的操作过程中，一个多重签名地址可以关联n个私钥，在需要转账等操作时，只要其中的m个私钥签名就可以把资金转移了，其中m要小于等于n，也就是说m/n小于1，可以是2/3, 3/5等等，是要在建立这个多重签名地址的时候确定好的。 （2）工作原理 数字资产在某种情况下，需要多人支配。换句话说，在某些特定条件下，数字资产如果无法确认归属某个特定的人，那么最好让相关人共同签署它的所有权。 仍然举上面的例子，在Alice发货之后，Imfly收到货之前，这笔钱应该由第三方信用比较高的中介暂时保存，这个阶段，这笔钱要么是Alice的，要么是Imfly的，最终的归属要看Imfly是否收到货。所以，这个第三方，无论如何都是应该有的，不然Imfly就要承担大部分风险（因为比特币的单向不可逆，Imfly发送之后就没有办法收回了） 这样一来，这笔钱的所属关系，在交易过程中涉及到Alice、Imfly和平台第三方（虽然不属于它，但它有权裁定资金去向），那么就应该由他们三方签名，因此网上购物就是典型的多重签名的例子。其多重签名模型就是2/3，也就是说只要他们中的两个签名，资金就可以被转移。 具体到这个例子，Imfly把钱打给一个关联三方私钥的多重签名地址，如果整个交易过程顺利，只要Alice和Imfly两个签名，这笔钱就会顺利到达Alice手里。如果不顺利，他们任何一人提出仲裁，平台第三方调查之后，通过签名就能把这笔钱转给Alice或退回Imfly。这非常类似淘宝和京东的模式，但是比他们更加便捷和安全，至少不用担心第三方倒闭、挪用资金或携款跑路。 （3）应用场景 很显然，多重签名给了加密货币腾飞的翅膀，让它单一单项支付的能力更具吸引力，让加密货币技术应用到各行各业成为可能。这里简单的罗列几个应用场景，供探索和思考： 电子商务。比较常见的是2/3的模式。上面电子商务网站的例子，就是最典型的场景之一，目前已经有成功的案例了。延伸一下，这类应用本质就是中介，所以还可用在各类中介机构性质的服务上。 财产分割。比如夫妻双方共有财产，可以使用1/2的模式，一个账户谁都可以使用，跟各自拥有帐号一样，好处是系统忠实记录了每个人的花销，闹掰的时候很容易清算。扩展到公司合伙经营，可以使用1/n模式，n个人合伙人，都可以直接支配共有资金，具体清算时，一目了然。 资金监管。其实，这是多重签名的最直接作用，一笔钱需要多个人签名才能使用，任何一个人都无法直接动用资金，这在生活中太常见了，只要灵活设置多重签名的比重模式，就能解决生活中很多问题。比如，接着上面夫妻的例子，夫妻要储备一笔资金，供孩子上大学使用，在这之前谁都不能动，那么把模式改为2/2，不仅限制了夫妻双方，也给黑客攻击增加了难度。 多重签名的设计，让各种业务去中心化充满无限可能。 （4）亿书的多重签名 多重签名方法在modules/multisignatures.js文件里，类图如下： 实现Api的代码如下： // 318行 router.map(shared, { &quot;get /pending&quot;: &quot;pending&quot;, // Get pending transactions &quot;post /sign&quot;: &quot;sign&quot;, // Sign transaction &quot;put /&quot;: &quot;addMultisignature&quot;, // Add multisignature &quot;get /accounts&quot;: &quot;getAccounts&quot; }); // 329行 library.network.app.use(&#39;/api/multisignatures&#39;, router); 解析一下，最后产生的Api如下： get /api/multisignatures/pending -&gt; shared.pending // 查询等待中的交易 post /api/multisignatures/sign -&gt; shared.sign // 签名交易 put /api/multisignatures/ -&gt; shared.addMultisignature // 创建多重签名帐号 get /api/multisignatures/accounts -&gt; shared.getAccounts // 获得关联的帐号（对应者用户私钥） 提供的功能很显然，包括：待交易查询、关联帐号列表查询，用户签名交易，创建多重签名帐号等4个核心功能。我们先从创建多重签名帐号开始，这个Api使用的是http的put方法，对应的自然是更新操作，不查看代码也可以猜想到，该功能应该是在已有帐号基础上的操作，从客户端钱包设置菜单里，可以看到如图操作： 看看shared.addMultisignature的源代码如下： // modules/multisignatures.js文件 shared.addMultisignature = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... // 732行 required: [&#39;min&#39;, &#39;lifetime&#39;, &#39;keysgroup&#39;, &#39;secret&#39;] }, function (err) { ... library.balancesSequence.add(function (cb) { modules.accounts.getAccount({publicKey: keypair.publicKey.toString(&#39;hex&#39;)}, function (err, account) { ... // 767行 try { var transaction = library.logic.transaction.create({ type: TransactionTypes.MULTI, // 769行 sender: account, keypair: keypair, secondKeypair: secondKeypair, min: body.min, keysgroup: body.keysgroup, lifetime: body.lifetime }); } catch (e) { return cb(e.toString()); } ... }; 从732行可知，创建一个多重签名，必须’min’, ‘lifetime’, ‘keysgroup’, ‘secret’这四参数（其实，一个默认参数就是当前帐号），min代表上面讲到的m值，即需要确认的人数;lifetime代表生命周期;keysgroup包含多重签名关联的全部帐号，它是数组类型，包含的元素个数就是n;secret是用户密码，与用户私钥对应。 经过一系列的验证之后，作为一个交易（交易类型TransactionTypes.MULTI，769行）保存到数据库(区款链)里。创建成功的帐号，可以显示多重帐号菜单，对交易进行操作。接下来，自然应该能够查看全部关联的帐号（请看shared.getAccounts方法），查看待确认的交易（请看shared.pending方法），这两个方法仅仅是简单的查询，没什么难度，这里不再浪费篇幅。 如果用户同意交易，就可以对待确认的交易进行签名（shared.sign方法），这个方法的源码如下： // 586行 shared.sign = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... required: [&#39;transactionId&#39;, &#39;secret&#39;] }, function (err) { ... // 632行 function done(cb) { library.balancesSequence.add(function (cb) { // 634行 var transaction = modules.transactions.getUnconfirmedTransaction(body.transactionId); if (!transaction) { return cb(&quot;Transaction not found&quot;); } // 640行 transaction.signatures = transaction.signatures || []; transaction.signatures.push(sign); library.bus.message(&#39;signature&#39;, { signature: sign, transaction: transaction.id }, true); cb(); }, function (err) { if (err) { return cb(err.toString()); } cb(null, {transactionId: transaction.id}); }); } ... }; 这个方法，相比单独的签名方法，不同的是单独的签名方法相当于一个新建交易，而这里的多重签名的用户签名，显然仅仅是对未确认交易（634行）进行签名确认（640行维护了一个签名数组，641行的push方法把用户签名写入数组）。而且，相比独立签名，验证也更复杂，我们将在下一篇《交易》一文中集中讨论验证问题。您也可以结合下一篇的内容，阅读和理解这里的签名方法。 总结 在加密货币里，每一个交易都涉及到使用私钥签名，用于确认每笔资金所有人。确定了所有人，自然就确定了资金转移的条件、目标和方向，就为我们下一步进行资金转移操作奠定了基础。很自然的，该研究一下亿书的交易了，请看下一篇：《交易》。 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 首发区块链俱乐部： http://chainclub.org 亿书官方网站： http://ebookchain.org 亿书开发QQ群： 185046161 (亿书为开源项目，欢迎各界小伙伴参与） 参考 亿书白皮书 http://ebookchain.org/ebookchain.pdf 阅读更多" />
<link rel="canonical" href="https://mlh.app/2016/06/28/a30e0a72bffd610ac2cb7d467209b53f.html" />
<meta property="og:url" content="https://mlh.app/2016/06/28/a30e0a72bffd610ac2cb7d467209b53f.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-06-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"前言 加密货币是一种数字资产，随着区块链等相关技术的创新和突破，很多有形或无形资产实现了去中心化。比如我们这里分享的 亿书 就是要把数字出版物版权进行保护，实现去中心化，解决业界多年来版权保护不力的难题。 无论数字资产，还是数字出版版权，都是有明确所有权的，当前实现数字资产所属的技术手段就是本篇要介绍的签名。而多重签名是对签名的扩展使用，给数字资产转移提供了安全保障和技术手段。本篇，从基本概念入手，详细了解签名和多重签名的作用和代码实现。 源码 主要源码地址： signatures.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/signatures.js multisignatures.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/multisignatures.js 解读 签名 （1）签名的作用和特点 名字的解释。签名是什么？有人第一反应是日常生活中的用笔签名，那么我会说，你的直觉是对的。不过，当很多小伙伴看到网上的很多解释，却又迷惑了，事实上不同概念在不同领域的表述是有差别的，但本质相同。我坚信生活是一切创作的源泉，任何一个概念都能从生活中找到原型，这里的“签名”也是如此。 签名的作用。日常生活中，凡是需要确认归属的（是签名人的，不是其他的），都需要所有者进行签名。比如，我签名了一份文件，出了问题，责任我负，我签名了一个支票，就代表将由我支付。我们普通老百姓最常见的场景，就是去银行办业务，银行职员会让你反复签一大堆的单据，想必每个人都会有深刻的印象。 签名的特点。人的笔迹是很个性化的，越熟练的字体，个性特征越固定，因此一个人的名字，不同的人写出完全相同笔迹的概率非常小，即便是专业模仿也可以通过技术鉴别出来，这样一来，人的签名就具有唯一性、可验证的特点，并被法律认可。 签名的验证如果，你拿着一张支票去银行兑换，银行职员会对支票上的签名和印章仔细比对，确保印章大小、样式，以及付款人签名等，与银行留存的信息一致，才会给你兑付，这就是签名验证。 （2）比特币客户端签名功能 数字资产需要签名。类比人类签名，比特币也有签名功能。如果了解比特币钱包（客户端软件），就会发现它提供了一个消息签名的功能，可以用来对其他用户通过比特币网络之外的信息进行签名和验证。我个人使用的是 比特币官方网站 提供的比太钱包，如图： 这个功能干什么用的呢？有好多小伙伴不清楚，这里举个简单的例子解释一下，具体使用的时候绝不限于这些应用。 Alice开了一个网店，但没有直接接入比特币网络，不能自动确认和验证支付者。客户Imfly购买了她的产品，并用比特币支付了全部货款。因为比特币地址和交易都是公开匿名的，为了防止冒充冒领实，Alice需要确认Imfly提供的那个付款地址确实是imfly本人的，否则不能发货。这时候，就需要Imfly先把支付货款的比特币地址和相关交易签名信息（如图），然后通过QQ或邮件传给Alice，Alice使用客户端验证信息签名，才能确认交易确实是Imfly的。 想象一下，如果没有签名功能会怎么样呢？因为比特币仅是一个匿名、安全的支付手段，但却无法确认支付方或收款方是谁，信息的不确定性，将使得比特币网络之外的交易无法达成。在中心化的世界里，这个问题是通过运营平台这个第三方达成的，比如支付宝等，双方的全部信息，平台都掌握，任何一方出现欺诈，都需要通过向平台投诉来解决。用户需要对第三方平台绝对信任，并通过牺牲个人信息安全获得交易的基本保障。 （3）电子签名 通过上述分析，可以理解的是，签名的作用是确定资产所属，其特征是简单、安全、可验证。把这个概念抽象出来，应用到计算机系统里，为了确定数字资产所属，也需要进行签名，这就是大家经常看到的“电子签名”的概念。在网络世界里，签名可以对任何需要确认的数字资产进行处理，比如比特币地址、电子书版权等，并以此来宣告重要资产的所属，这让无需监管的去中心化交易成为可能。 具体开发设计中，就是加密技术代替人的笔迹，不然任何签名方法都会被模仿，而且模仿的成本极低，相反，验证的成本却很高。具体的加密或验证技术，请参考前面的章节，这里我们介绍亿书是如何使用签名技术的。 亿书也具备签名能力，只不过，目前没有单独提供签名信息的操作供用户使用，而是通过签名，添加了支付密码功能，对用户帐号资产追加了一层保护。 （4）亿书的支付密码 签名方法在modules/signatures.js文件里，类图如下： 我们还是从Api开始，代码如下： // modules/signatures.js文件 // 179行 router.map(shared, { &quot;get /fee&quot;: &quot;getFee&quot;, &quot;put /&quot;: &quot;addSignature&quot; }); // 188行 library.network.app.use(&#39;/api/signatures&#39;, router); 通过上面的代码，可以了解签名提供了两个简单的公共接口： get /api/signatures/fee -&gt; shared.getFee put /api/signatures/ -&gt; shared.addSignature //签名操作 显然，最核心的方法也就是shared.addSignature，代码： // 215行 shared.addSignature = function (req, cb) { ... library.scheme.validate(body, { properties: { ... }, required: [&quot;secret&quot;, &quot;secondSecret&quot;] }, function (err) { ... library.balancesSequence.add(function (cb) { if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#39;hex&#39;)) { modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) { ... try { var transaction = library.logic.transaction.create({ type: TransactionTypes.SIGNATURE, // 297行 sender: account, keypair: keypair, requester: keypair, secondKeypair: secondKeypair, }); } catch (e) { return cb(e.toString()); } ... } 毫无疑问，支付密码也是一个简单的交易（交易类型TransactionTypes.SIGNATURE，见297行）。基于此，我们不难想象，添加类似比特币的签名功能也是件非常简单的事情，我们会在亿书下一个版本里添加这项功能，具体请关注 亿书币版本库 最新进展。 多重签名 上面我们提到，比特币的匿名性，使交易处于不可信之中，最终导致用户不敢交易。有了签名功能，就有了确认双方信息的有效手段，问题总算有了解决方案。聪明的小伙伴会发现，签名和验证过程除了繁琐，并没有让我们觉得比使用第三方平台更有效、更安全。有没有更好的解决方案呢？回答是：有，那就是多重签名。 （1）基本概念 多重签名，可以简单的理解为一个数字资产的多个签名。签名标定的是数字资产所属和权限，多重签名预示着数字资产可由多人支配和管理。在加密货币领域，如果要动用一个加密货币地址的资金，通常需要该地址的所有人使用他的私钥（由用户专属保护）进行签名。那么，多重签名，就是动用这笔资金需要多个私钥签名，通常这笔资金或数字资产会保存在一个多重签名的地址或帐号里。这就好比，我们工作中有一份文件，需要多个部门签署才能生效一样。 在实际的操作过程中，一个多重签名地址可以关联n个私钥，在需要转账等操作时，只要其中的m个私钥签名就可以把资金转移了，其中m要小于等于n，也就是说m/n小于1，可以是2/3, 3/5等等，是要在建立这个多重签名地址的时候确定好的。 （2）工作原理 数字资产在某种情况下，需要多人支配。换句话说，在某些特定条件下，数字资产如果无法确认归属某个特定的人，那么最好让相关人共同签署它的所有权。 仍然举上面的例子，在Alice发货之后，Imfly收到货之前，这笔钱应该由第三方信用比较高的中介暂时保存，这个阶段，这笔钱要么是Alice的，要么是Imfly的，最终的归属要看Imfly是否收到货。所以，这个第三方，无论如何都是应该有的，不然Imfly就要承担大部分风险（因为比特币的单向不可逆，Imfly发送之后就没有办法收回了） 这样一来，这笔钱的所属关系，在交易过程中涉及到Alice、Imfly和平台第三方（虽然不属于它，但它有权裁定资金去向），那么就应该由他们三方签名，因此网上购物就是典型的多重签名的例子。其多重签名模型就是2/3，也就是说只要他们中的两个签名，资金就可以被转移。 具体到这个例子，Imfly把钱打给一个关联三方私钥的多重签名地址，如果整个交易过程顺利，只要Alice和Imfly两个签名，这笔钱就会顺利到达Alice手里。如果不顺利，他们任何一人提出仲裁，平台第三方调查之后，通过签名就能把这笔钱转给Alice或退回Imfly。这非常类似淘宝和京东的模式，但是比他们更加便捷和安全，至少不用担心第三方倒闭、挪用资金或携款跑路。 （3）应用场景 很显然，多重签名给了加密货币腾飞的翅膀，让它单一单项支付的能力更具吸引力，让加密货币技术应用到各行各业成为可能。这里简单的罗列几个应用场景，供探索和思考： 电子商务。比较常见的是2/3的模式。上面电子商务网站的例子，就是最典型的场景之一，目前已经有成功的案例了。延伸一下，这类应用本质就是中介，所以还可用在各类中介机构性质的服务上。 财产分割。比如夫妻双方共有财产，可以使用1/2的模式，一个账户谁都可以使用，跟各自拥有帐号一样，好处是系统忠实记录了每个人的花销，闹掰的时候很容易清算。扩展到公司合伙经营，可以使用1/n模式，n个人合伙人，都可以直接支配共有资金，具体清算时，一目了然。 资金监管。其实，这是多重签名的最直接作用，一笔钱需要多个人签名才能使用，任何一个人都无法直接动用资金，这在生活中太常见了，只要灵活设置多重签名的比重模式，就能解决生活中很多问题。比如，接着上面夫妻的例子，夫妻要储备一笔资金，供孩子上大学使用，在这之前谁都不能动，那么把模式改为2/2，不仅限制了夫妻双方，也给黑客攻击增加了难度。 多重签名的设计，让各种业务去中心化充满无限可能。 （4）亿书的多重签名 多重签名方法在modules/multisignatures.js文件里，类图如下： 实现Api的代码如下： // 318行 router.map(shared, { &quot;get /pending&quot;: &quot;pending&quot;, // Get pending transactions &quot;post /sign&quot;: &quot;sign&quot;, // Sign transaction &quot;put /&quot;: &quot;addMultisignature&quot;, // Add multisignature &quot;get /accounts&quot;: &quot;getAccounts&quot; }); // 329行 library.network.app.use(&#39;/api/multisignatures&#39;, router); 解析一下，最后产生的Api如下： get /api/multisignatures/pending -&gt; shared.pending // 查询等待中的交易 post /api/multisignatures/sign -&gt; shared.sign // 签名交易 put /api/multisignatures/ -&gt; shared.addMultisignature // 创建多重签名帐号 get /api/multisignatures/accounts -&gt; shared.getAccounts // 获得关联的帐号（对应者用户私钥） 提供的功能很显然，包括：待交易查询、关联帐号列表查询，用户签名交易，创建多重签名帐号等4个核心功能。我们先从创建多重签名帐号开始，这个Api使用的是http的put方法，对应的自然是更新操作，不查看代码也可以猜想到，该功能应该是在已有帐号基础上的操作，从客户端钱包设置菜单里，可以看到如图操作： 看看shared.addMultisignature的源代码如下： // modules/multisignatures.js文件 shared.addMultisignature = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... // 732行 required: [&#39;min&#39;, &#39;lifetime&#39;, &#39;keysgroup&#39;, &#39;secret&#39;] }, function (err) { ... library.balancesSequence.add(function (cb) { modules.accounts.getAccount({publicKey: keypair.publicKey.toString(&#39;hex&#39;)}, function (err, account) { ... // 767行 try { var transaction = library.logic.transaction.create({ type: TransactionTypes.MULTI, // 769行 sender: account, keypair: keypair, secondKeypair: secondKeypair, min: body.min, keysgroup: body.keysgroup, lifetime: body.lifetime }); } catch (e) { return cb(e.toString()); } ... }; 从732行可知，创建一个多重签名，必须’min’, ‘lifetime’, ‘keysgroup’, ‘secret’这四参数（其实，一个默认参数就是当前帐号），min代表上面讲到的m值，即需要确认的人数;lifetime代表生命周期;keysgroup包含多重签名关联的全部帐号，它是数组类型，包含的元素个数就是n;secret是用户密码，与用户私钥对应。 经过一系列的验证之后，作为一个交易（交易类型TransactionTypes.MULTI，769行）保存到数据库(区款链)里。创建成功的帐号，可以显示多重帐号菜单，对交易进行操作。接下来，自然应该能够查看全部关联的帐号（请看shared.getAccounts方法），查看待确认的交易（请看shared.pending方法），这两个方法仅仅是简单的查询，没什么难度，这里不再浪费篇幅。 如果用户同意交易，就可以对待确认的交易进行签名（shared.sign方法），这个方法的源码如下： // 586行 shared.sign = function (req, cb) { var body = req.body; library.scheme.validate(body, { ... required: [&#39;transactionId&#39;, &#39;secret&#39;] }, function (err) { ... // 632行 function done(cb) { library.balancesSequence.add(function (cb) { // 634行 var transaction = modules.transactions.getUnconfirmedTransaction(body.transactionId); if (!transaction) { return cb(&quot;Transaction not found&quot;); } // 640行 transaction.signatures = transaction.signatures || []; transaction.signatures.push(sign); library.bus.message(&#39;signature&#39;, { signature: sign, transaction: transaction.id }, true); cb(); }, function (err) { if (err) { return cb(err.toString()); } cb(null, {transactionId: transaction.id}); }); } ... }; 这个方法，相比单独的签名方法，不同的是单独的签名方法相当于一个新建交易，而这里的多重签名的用户签名，显然仅仅是对未确认交易（634行）进行签名确认（640行维护了一个签名数组，641行的push方法把用户签名写入数组）。而且，相比独立签名，验证也更复杂，我们将在下一篇《交易》一文中集中讨论验证问题。您也可以结合下一篇的内容，阅读和理解这里的签名方法。 总结 在加密货币里，每一个交易都涉及到使用私钥签名，用于确认每笔资金所有人。确定了所有人，自然就确定了资金转移的条件、目标和方向，就为我们下一步进行资金转移操作奠定了基础。很自然的，该研究一下亿书的交易了，请看下一篇：《交易》。 链接 本系列文章即时更新，若要掌握最新内容，请关注下面的链接 本源文地址： https://github.com/imfly/bitcoin-on-nodejs 首发区块链俱乐部： http://chainclub.org 亿书官方网站： http://ebookchain.org 亿书开发QQ群： 185046161 (亿书为开源项目，欢迎各界小伙伴参与） 参考 亿书白皮书 http://ebookchain.org/ebookchain.pdf 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2016/06/28/a30e0a72bffd610ac2cb7d467209b53f.html","headline":"《Nodejs开发加密货币》之十九：签名和多重签名","dateModified":"2016-06-28T00:00:00+08:00","datePublished":"2016-06-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2016/06/28/a30e0a72bffd610ac2cb7d467209b53f.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>《Nodejs开发加密货币》之十九：签名和多重签名</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="markdown_views"> 
  <h2 id="前言">前言</h2> 
  <p>加密货币是一种数字资产，随着区块链等相关技术的创新和突破，很多有形或无形资产实现了去中心化。比如我们这里分享的 <a href="http://ebookchain.org/" rel="nofollow">亿书</a> 就是要把数字出版物版权进行保护，实现去中心化，解决业界多年来版权保护不力的难题。</p> 
  <p>无论数字资产，还是数字出版版权，都是有明确所有权的，当前实现数字资产所属的技术手段就是本篇要介绍的<code>签名</code>。而<code>多重签名</code>是对<code>签名</code>的扩展使用，给数字资产转移提供了安全保障和技术手段。本篇，从基本概念入手，详细了解<code>签名</code>和<code>多重签名</code>的作用和代码实现。</p> 
  <h2 id="源码">源码</h2> 
  <p>主要源码地址：</p> 
  <p>signatures.js <a href="https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/signatures.js" rel="nofollow">https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/signatures.js</a></p> 
  <p>multisignatures.js <a href="https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/multisignatures.js" rel="nofollow">https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/multisignatures.js</a></p> 
  <h2 id="解读">解读</h2> 
  <h4 id="签名">签名</h4> 
  <p>（1）签名的作用和特点</p> 
  <p><strong>名字的解释</strong>。<code>签名</code>是什么？有人第一反应是日常生活中的用笔<code>签名</code>，那么我会说，你的直觉是对的。不过，当很多小伙伴看到网上的很多解释，却又迷惑了，事实上不同概念在不同领域的表述是有差别的，但本质相同。我坚信生活是一切创作的源泉，任何一个概念都能从生活中找到原型，这里的“签名”也是如此。</p> 
  <p><strong>签名的作用</strong>。日常生活中，凡是需要确认归属的（是签名人的，不是其他的），都需要所有者进行签名。比如，我签名了一份文件，出了问题，责任我负，我签名了一个支票，就代表将由我支付。我们普通老百姓最常见的场景，就是去银行办业务，银行职员会让你反复签一大堆的单据，想必每个人都会有深刻的印象。</p> 
  <p><strong>签名的特点</strong>。人的笔迹是很个性化的，越熟练的字体，个性特征越固定，因此一个人的名字，不同的人写出完全相同笔迹的概率非常小，即便是专业模仿也可以通过技术鉴别出来，这样一来，人的<code>签名</code>就具有唯一性、可验证的特点，并被法律认可。</p> 
  <p><strong>签名的验证</strong>如果，你拿着一张支票去银行兑换，银行职员会对支票上的签名和印章仔细比对，确保印章大小、样式，以及付款人签名等，与银行留存的信息一致，才会给你兑付，这就是<code>签名</code>验证。</p> 
  <p>（2）比特币客户端签名功能</p> 
  <p>数字资产需要签名。类比人类签名，比特币也有签名功能。如果了解比特币钱包（客户端软件），就会发现它提供了一个消息签名的功能，可以用来对其他用户通过比特币网络之外的信息进行签名和验证。我个人使用的是 <a href="https://www.bitcoin.org/" rel="nofollow">比特币官方网站</a> 提供的比太钱包，如图：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20160628105544636" alt="bither-wallet-sign.png" title=""></p> 
  <p>这个功能干什么用的呢？有好多小伙伴不清楚，这里举个简单的例子解释一下，具体使用的时候绝不限于这些应用。</p> 
  <p>Alice开了一个网店，但没有直接接入比特币网络，不能自动确认和验证支付者。客户Imfly购买了她的产品，并用比特币支付了全部货款。因为比特币地址和交易都是公开匿名的，为了防止冒充冒领实，Alice需要确认Imfly提供的那个付款地址确实是imfly本人的，否则不能发货。这时候，就需要Imfly先把支付货款的比特币地址和相关交易<code>签名信息</code>（如图），然后通过QQ或邮件传给Alice，Alice使用客户端<code>验证信息签名</code>，才能确认交易确实是Imfly的。</p> 
  <p>想象一下，如果没有<code>签名</code>功能会怎么样呢？因为比特币仅是一个匿名、安全的支付手段，但却无法确认支付方或收款方是谁，信息的不确定性，将使得比特币网络之外的交易无法达成。在中心化的世界里，这个问题是通过运营平台这个第三方达成的，比如支付宝等，双方的全部信息，平台都掌握，任何一方出现欺诈，都需要通过向平台投诉来解决。用户需要对第三方平台绝对信任，并通过牺牲个人信息安全获得交易的基本保障。</p> 
  <p>（3）电子签名</p> 
  <p>通过上述分析，可以理解的是，<code>签名</code>的作用是确定资产所属，其特征是简单、安全、可验证。把这个概念抽象出来，应用到计算机系统里，为了确定数字资产所属，也需要进行<code>签名</code>，这就是大家经常看到的“电子签名”的概念。在网络世界里，<code>签名</code>可以对任何需要确认的数字资产进行处理，比如比特币地址、电子书版权等，并以此来宣告重要资产的所属，这让无需监管的去中心化交易成为可能。</p> 
  <p>具体开发设计中，就是加密技术代替人的笔迹，不然任何签名方法都会被模仿，而且模仿的成本极低，相反，验证的成本却很高。具体的加密或验证技术，请参考前面的章节，这里我们介绍亿书是如何使用签名技术的。</p> 
  <p>亿书也具备签名能力，只不过，目前没有单独提供<code>签名信息</code>的操作供用户使用，而是通过签名，添加了<code>支付密码</code>功能，对用户帐号资产追加了一层保护。</p> 
  <p>（4）亿书的支付密码</p> 
  <p><code>签名</code>方法在<code>modules/signatures.js</code>文件里，类图如下：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20160628105629652" alt="signatures-class.png" title=""></p> 
  <p>我们还是从Api开始，代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs rust"><span class="hljs-comment">// modules/signatures.js文件</span>
<span class="hljs-comment">// 179行</span>
router.map(shared, {
  <span class="hljs-string">"get /fee"</span>: <span class="hljs-string">"getFee"</span>,
  <span class="hljs-string">"put /"</span>: <span class="hljs-string">"addSignature"</span>
});

<span class="hljs-comment">// 188行</span>
library.network.app.<span class="hljs-keyword">use</span>(<span class="hljs-string">'/api/signatures'</span>, router);</code></pre> 
  <p>通过上面的代码，可以了解<code>签名</code>提供了两个简单的公共接口：</p> 
  <pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-built_in">get</span> /api/signatures/fee -&gt; shared.getFee
<span class="hljs-built_in">put</span> /api/signatures/ -&gt; shared.addSignature<span class="hljs-comment"> //签名操作</span></code></pre> 
  <p>显然，最核心的方法也就是<code>shared.addSignature</code>，代码：</p> 
  <pre class="prettyprint"><code class=" hljs r">// <span class="hljs-number">215</span>行
shared.addSignature = <span class="hljs-keyword">function</span> (req, cb) {
    <span class="hljs-keyword">...</span>
    library.scheme.validate(body, {
        properties: {
            <span class="hljs-keyword">...</span>
        },
        required: [<span class="hljs-string">"secret"</span>, <span class="hljs-string">"secondSecret"</span>]
    }, <span class="hljs-keyword">function</span> (err) {
        <span class="hljs-keyword">...</span>

        library.balancesSequence.add(<span class="hljs-keyword">function</span> (cb) {
            <span class="hljs-keyword">if</span> (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(<span class="hljs-string">'hex'</span>)) {
                modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, <span class="hljs-keyword">function</span> (err, account) {
                    <span class="hljs-keyword">...</span>

                        <span class="hljs-keyword">try</span> {
                            var transaction = library.logic.transaction.create({
                                type: TransactionTypes.SIGNATURE, // <span class="hljs-number">297</span>行
                                sender: account,
                                keypair: keypair,
                                requester: keypair,
                                secondKeypair: secondKeypair,

                            });
                        } catch (e) {
                            <span class="hljs-keyword">return</span> cb(e.toString());
                        }
            <span class="hljs-keyword">...</span>         
}</code></pre> 
  <p>毫无疑问，<code>支付密码</code>也是一个简单的交易（交易类型<code>TransactionTypes.SIGNATURE</code>，见297行）。基于此，我们不难想象，添加类似比特币的<code>签名</code>功能也是件非常简单的事情，我们会在亿书下一个版本里添加这项功能，具体请关注 <a href="https://github.com/Ebookcoin/ebookcoin" rel="nofollow">亿书币版本库</a> 最新进展。</p> 
  <h4 id="多重签名">多重签名</h4> 
  <p>上面我们提到，比特币的匿名性，使交易处于不可信之中，最终导致用户不敢交易。有了签名功能，就有了确认双方信息的有效手段，问题总算有了解决方案。聪明的小伙伴会发现，签名和验证过程除了繁琐，并没有让我们觉得比使用第三方平台更有效、更安全。有没有更好的解决方案呢？回答是：有，那就是多重签名。</p> 
  <p>（1）基本概念</p> 
  <p>多重签名，可以简单的理解为一个数字资产的多个签名。签名标定的是数字资产所属和权限，多重签名预示着数字资产可由多人支配和管理。在加密货币领域，如果要动用一个加密货币地址的资金，通常需要该地址的所有人使用他的私钥（由用户专属保护）进行签名。那么，多重签名，就是动用这笔资金需要多个私钥签名，通常这笔资金或数字资产会保存在一个多重签名的地址或帐号里。这就好比，我们工作中有一份文件，需要多个部门签署才能生效一样。</p> 
  <p>在实际的操作过程中，一个多重签名地址可以关联n个私钥，在需要转账等操作时，只要其中的m个私钥签名就可以把资金转移了，其中m要小于等于n，也就是说m/n小于1，可以是2/3, 3/5等等，是要在建立这个多重签名地址的时候确定好的。</p> 
  <p>（2）工作原理</p> 
  <p>数字资产在某种情况下，需要多人支配。换句话说，在某些特定条件下，数字资产如果无法确认归属某个特定的人，那么最好让相关人共同签署它的所有权。</p> 
  <p>仍然举上面的例子，在Alice发货之后，Imfly收到货之前，这笔钱应该由第三方信用比较高的中介暂时保存，这个阶段，这笔钱要么是Alice的，要么是Imfly的，最终的归属要看Imfly是否收到货。所以，这个第三方，无论如何都是应该有的，不然Imfly就要承担大部分风险（因为比特币的单向不可逆，Imfly发送之后就没有办法收回了）</p> 
  <p>这样一来，这笔钱的所属关系，在交易过程中涉及到Alice、Imfly和平台第三方（虽然不属于它，但它有权裁定资金去向），那么就应该由他们三方签名，因此网上购物就是典型的多重签名的例子。其多重签名模型就是2/3，也就是说只要他们中的两个签名，资金就可以被转移。</p> 
  <p>具体到这个例子，Imfly把钱打给一个关联三方私钥的多重签名地址，如果整个交易过程顺利，只要Alice和Imfly两个签名，这笔钱就会顺利到达Alice手里。如果不顺利，他们任何一人提出仲裁，平台第三方调查之后，通过签名就能把这笔钱转给Alice或退回Imfly。这非常类似淘宝和京东的模式，但是比他们更加便捷和安全，至少不用担心第三方倒闭、挪用资金或携款跑路。</p> 
  <p>（3）应用场景</p> 
  <p>很显然，多重签名给了加密货币腾飞的翅膀，让它单一单项支付的能力更具吸引力，让加密货币技术应用到各行各业成为可能。这里简单的罗列几个应用场景，供探索和思考：</p> 
  <ul> 
   <li>电子商务。比较常见的是2/3的模式。上面电子商务网站的例子，就是最典型的场景之一，目前已经有成功的案例了。延伸一下，这类应用本质就是中介，所以还可用在各类中介机构性质的服务上。</li> 
   <li>财产分割。比如夫妻双方共有财产，可以使用1/2的模式，一个账户谁都可以使用，跟各自拥有帐号一样，好处是系统忠实记录了每个人的花销，闹掰的时候很容易清算。扩展到公司合伙经营，可以使用1/n模式，n个人合伙人，都可以直接支配共有资金，具体清算时，一目了然。</li> 
   <li>资金监管。其实，这是多重签名的最直接作用，一笔钱需要多个人签名才能使用，任何一个人都无法直接动用资金，这在生活中太常见了，只要灵活设置多重签名的比重模式，就能解决生活中很多问题。比如，接着上面夫妻的例子，夫妻要储备一笔资金，供孩子上大学使用，在这之前谁都不能动，那么把模式改为2/2，不仅限制了夫妻双方，也给黑客攻击增加了难度。</li> 
  </ul> 
  <p>多重签名的设计，让各种业务去中心化充满无限可能。</p> 
  <p>（4）亿书的多重签名</p> 
  <p><code>多重签名</code>方法在<code>modules/multisignatures.js</code>文件里，类图如下：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20160628105654668" alt="multisignatures-class.png" title=""></p> 
  <p>实现Api的代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs rust"><span class="hljs-comment">// 318行</span>
router.map(shared, {
  <span class="hljs-string">"get /pending"</span>: <span class="hljs-string">"pending"</span>, <span class="hljs-comment">// Get pending transactions</span>
  <span class="hljs-string">"post /sign"</span>: <span class="hljs-string">"sign"</span>, <span class="hljs-comment">// Sign transaction</span>
  <span class="hljs-string">"put /"</span>: <span class="hljs-string">"addMultisignature"</span>, <span class="hljs-comment">// Add multisignature</span>
  <span class="hljs-string">"get /accounts"</span>: <span class="hljs-string">"getAccounts"</span>
});

<span class="hljs-comment">// 329行</span>
library.network.app.<span class="hljs-keyword">use</span>(<span class="hljs-string">'/api/multisignatures'</span>, router);</code></pre> 
  <p>解析一下，最后产生的Api如下：</p> 
  <pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-built_in">get</span> /api/multisignatures/pending -&gt; shared.pending<span class="hljs-comment"> // 查询等待中的交易</span>
<span class="hljs-built_in">post</span> /api/multisignatures/sign -&gt; shared.sign<span class="hljs-comment"> // 签名交易</span>
<span class="hljs-built_in">put</span> /api/multisignatures/ -&gt; shared.addMultisignature<span class="hljs-comment"> // 创建多重签名帐号</span>
<span class="hljs-built_in">get</span> /api/multisignatures/accounts -&gt; shared.getAccounts<span class="hljs-comment"> // 获得关联的帐号（对应者用户私钥）</span></code></pre> 
  <p>提供的功能很显然，包括：待交易查询、关联帐号列表查询，用户签名交易，创建多重签名帐号等4个核心功能。我们先从创建多重签名帐号开始，这个Api使用的是http的<code>put</code>方法，对应的自然是<code>更新</code>操作，不查看代码也可以猜想到，该功能应该是在已有帐号基础上的操作，从客户端钱包<code>设置</code>菜单里，可以看到如图操作：</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20160628110000507" alt="addMultisignature.png" title=""></p> 
  <p>看看<code>shared.addMultisignature</code>的源代码如下：</p> 
  <pre class="prettyprint"><code class=" hljs r">// modules/multisignatures.js文件
shared.addMultisignature = <span class="hljs-keyword">function</span> (req, cb) {
    var body = req.body;
    library.scheme.validate(body, {
        <span class="hljs-keyword">...</span>

    // <span class="hljs-number">732</span>行
        required: [<span class="hljs-string">'min'</span>, <span class="hljs-string">'lifetime'</span>, <span class="hljs-string">'keysgroup'</span>, <span class="hljs-string">'secret'</span>]
    }, <span class="hljs-keyword">function</span> (err) {
      <span class="hljs-keyword">...</span>

        library.balancesSequence.add(<span class="hljs-keyword">function</span> (cb) {
            modules.accounts.getAccount({publicKey: keypair.publicKey.toString(<span class="hljs-string">'hex'</span>)}, <span class="hljs-keyword">function</span> (err, account) {
                <span class="hljs-keyword">...</span>

        // <span class="hljs-number">767</span>行
                <span class="hljs-keyword">try</span> {
                    var transaction = library.logic.transaction.create({
                        type: TransactionTypes.MULTI, // <span class="hljs-number">769</span>行
                        sender: account,
                        keypair: keypair,
                        secondKeypair: secondKeypair,
                        min: body.min,
                        keysgroup: body.keysgroup,
                        lifetime: body.lifetime
                    });
                } catch (e) {
                    <span class="hljs-keyword">return</span> cb(e.toString());
                }

                <span class="hljs-keyword">...</span>
};</code></pre> 
  <p>从732行可知，创建一个多重签名，必须’min’, ‘lifetime’, ‘keysgroup’, ‘secret’这四参数（其实，一个默认参数就是当前帐号），min代表上面讲到的<code>m</code>值，即需要确认的人数;lifetime代表生命周期;keysgroup包含多重签名关联的全部帐号，它是数组类型，包含的元素个数就是<code>n</code>;secret是用户密码，与用户私钥对应。</p> 
  <p>经过一系列的验证之后，作为一个交易（交易类型TransactionTypes.MULTI，769行）保存到数据库(区款链)里。创建成功的帐号，可以显示多重帐号菜单，对交易进行操作。接下来，自然应该能够查看全部关联的帐号（请看shared.getAccounts方法），查看<code>待确认的交易</code>（请看shared.pending方法），这两个方法仅仅是简单的查询，没什么难度，这里不再浪费篇幅。</p> 
  <p>如果用户同意交易，就可以对<code>待确认的交易</code>进行签名（shared.sign方法），这个方法的源码如下：</p> 
  <pre class="prettyprint"><code class=" hljs r">// <span class="hljs-number">586</span>行
shared.sign = <span class="hljs-keyword">function</span> (req, cb) {
    var body = req.body;
    library.scheme.validate(body, {
        <span class="hljs-keyword">...</span>
        required: [<span class="hljs-string">'transactionId'</span>, <span class="hljs-string">'secret'</span>]
    }, <span class="hljs-keyword">function</span> (err) {
        <span class="hljs-keyword">...</span>

    // <span class="hljs-number">632</span>行
        <span class="hljs-keyword">function</span> done(cb) {
            library.balancesSequence.add(<span class="hljs-keyword">function</span> (cb) {
        // <span class="hljs-number">634</span>行
                var transaction = modules.transactions.getUnconfirmedTransaction(body.transactionId);

                <span class="hljs-keyword">if</span> (!transaction) {
                    <span class="hljs-keyword">return</span> cb(<span class="hljs-string">"Transaction not found"</span>);
                }

        // <span class="hljs-number">640</span>行
                transaction.signatures = transaction.signatures || [];
                transaction.signatures.push(sign);

                library.bus.message(<span class="hljs-string">'signature'</span>, {
                    signature: sign,
                    transaction: transaction.id
                }, true);
                cb();
            }, <span class="hljs-keyword">function</span> (err) {
                <span class="hljs-keyword">if</span> (err) {
                    <span class="hljs-keyword">return</span> cb(err.toString());
                }

                cb(null, {transactionId: transaction.id});
            });
        }

        <span class="hljs-keyword">...</span>
};</code></pre> 
  <p>这个方法，相比单独的签名方法，不同的是单独的签名方法相当于一个新建交易，而这里的多重签名的用户签名，显然仅仅是对未确认交易（634行）进行签名确认（640行维护了一个签名数组，641行的push方法把用户签名写入数组）。而且，相比独立签名，验证也更复杂，我们将在下一篇《交易》一文中集中讨论验证问题。您也可以结合下一篇的内容，阅读和理解这里的签名方法。</p> 
  <h2 id="总结">总结</h2> 
  <p>在加密货币里，每一个交易都涉及到使用私钥签名，用于确认每笔资金所有人。确定了所有人，自然就确定了资金转移的条件、目标和方向，就为我们下一步进行资金转移操作奠定了基础。很自然的，该研究一下亿书的交易了，请看下一篇：<strong>《交易》</strong>。</p> 
  <h2 id="链接">链接</h2> 
  <p><strong>本系列文章即时更新，若要掌握最新内容，请关注下面的链接</strong></p> 
  <p>本源文地址： <a href="https://github.com/imfly/bitcoin-on-nodejs" rel="nofollow">https://github.com/imfly/bitcoin-on-nodejs</a></p> 
  <p>首发区块链俱乐部： <a href="http://chainclub.org" rel="nofollow">http://chainclub.org</a></p> 
  <p>亿书官方网站： <a href="http://ebookchain.org" rel="nofollow">http://ebookchain.org</a></p> 
  <p>亿书开发QQ群： 185046161 (亿书为开源项目，欢迎各界小伙伴参与）</p> 
  <h2 id="参考">参考</h2> 
  <p><a href="http://ebookchain.org/ebookchain.pdf" rel="nofollow">亿书白皮书 http://ebookchain.org/ebookchain.pdf</a></p> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/imfly/article/details/51774391,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/imfly/article/details/51774391,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
