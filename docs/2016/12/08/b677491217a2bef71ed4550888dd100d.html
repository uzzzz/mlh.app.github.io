<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链如何在技术上实现去中心化的呢？ | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链如何在技术上实现去中心化的呢？" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="内容来源：书《区块链世界》 主编：井底望天／武文源／史伯平／赵国栋 本文内容为区块链入门级阅读材料，但是还是需要一定的基础知识才能理解，目前国内关于区块链的知识普及还比较少，本文虽然篇幅较长，好在文章语言质朴，耐心解释，希望能帮助到区块链初学者快速认知和理解。 “论天下大势，分久必合，合久必分”，这是历史的规律。合的意思就是集中管理，也可以说是中心化；分的意思就是分散管理，也可叫做去中心化。 中心化的好处是认证、管理机制明确统一，可以集中力量办大事，效率高；而弊端是管理、仲裁工作庞杂，机制上的任何缺陷都会造成问题，同时缺少权力的制约，从而出现不堪重负或者集中力量办坏事的情况。所以就有了以去中心化弥补中心化不足的需求。 从社会发展上来讲，在以前由于技术的限制和制度的约束，不管是人人自由还是人人平等，理想很丰满，但现实有点骨感。而区块链的出现在技术上实现了真正去中心化的可能，而这也必将促进社会的变革和进步。 那么区块链是如何在技术上实现去中心化的呢？核心主要是下面三种技术。 加密技术 密码技术体系有多种分类。基本上来讲，可以将密码技术分为对称加密体系和非对称加密体系，两个体系各自有不同的使用场景和技术路线。 图2-2 对称加密 &nbsp; 对称加密算法在加密和解密时使用的是同一个秘钥，这就决定了对称加密算法的两方需要事先进行秘钥协商，或者通信的双方需要预先知道双方使用的秘钥，保证一方的加密可以被另一方解密； 非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥其中一个是公开密钥（public key，公钥），另一个是私有密钥（private key，私钥）。 公钥是可以公开的，也需要通过公共的渠道公开给相应的通信方；而私钥是非对称加密算法中的关键，需要安全地保护好。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果使用私钥进行数据的签名，只有公有密钥可以来验签。 图2-3非对称加密 &nbsp; 因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。由非对称加密算法形成的非对称加密体系解决了信息公开传送和密钥管理问题，是一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。 &nbsp; 非对称加密算法 1、非对称加密与对称加密相比，其安全性更好； 2、非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。比特币采用椭圆曲线加密算法来产生公钥和私钥对，钱包地址即是公钥，私钥由用户保存。 &nbsp; Hash（哈希）算法 区块链系统中除了使用非对称加密算法之外，另一个重要的密码技术是Hash（哈希）算法或者叫散列技术。 所谓Hash，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是散列值的空间长度通常远小于输入的空间长度，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一地确定输入值。或者简单地说，就是一种将任意长度的数据信息压缩成某一固定长度的数据信息摘要的函数。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 图2-4 &nbsp;Hash算法 &nbsp; 散列函数有如下一个基本特性即免碰撞性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的——这个特性使得散列函数具有确定性的结果；但另一方面，散列函数的输入和输出不是一一对应的，如果两个散列值相同，两个输入值很可能是相同的，但并不能绝对肯定二者一定是相等的。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。 &nbsp; 区块链系统一般采用Hash算法来快速验证用户的身份。如果用户宣称对某个钱包具有所有权并且要改变钱包对应的信息（在比特币中，就是使用钱包中的余额），他必须提交一个请求，这个请求包括三个部分：钱包地址、明文请求、明文请求由钱包对应的私钥Hash过的签名。这个请求将被发送要区块链网络中。 每个节点可以用钱包的公钥来验证这个请求是否对应于这个签名，也就是通过这个办法来验证用户对钱包的所有权（拥有合适的私钥，但是不需要公开这个私钥）。 图2-5 &nbsp; 相比非对称加密，Hash算法一般快几个数量级以上，从而使得验证的过程可以非常快速。常用Hash算法有MD5、SHA1、SHA256、SHA512、HMAC等。 点对点通信技术 点对点通信技术（Peer to Peer通信技术），是一种对等连接的互联网技术，依赖网络中参与者共同的计算能力和带宽，而不是把依赖都聚集在较少的几台服务器上。这类网络可以用于多种用途，各种档案分享软件已经得到了广泛的使用。P2P技术也被使用在类似VoIP等实时媒体业务的数据通信中。 图2-6 点对点网络 纯点对点网络没有客户端或服务器的概念，只有平等的同级节点，同时对网络上的其它节点充当客户端和服务器。这种网络设计模型不同于传统的“客户端-服务器”模型，在“客户端-服务器”模型中通信通常来往于一个中央服务器，而中央服务器就是系统中的单点故障源头。点对点技术和形成的网络，也由于设计和实施方案的不同，也出现了不同的网络模型。 Ø&nbsp; 纯P2P网络模型 在此模型中，网络节点同时作为客户端和服务器，没有中心的服务器，没有中心的路由器。这样形成的网络完全根据系统中节点的活跃程度来保持，网络通信也主要是节点之间路由信息的广播，系统中的通信冗余比较大。 Ø&nbsp; 分层式P2P网络模型 在此模式中，网络节点的角色更加丰富了，网络中有一个中心服务器保存节点的信息并对请求这些信息的要求做出响应。同时节点负责发布这些信息（因为中心服务器并不保存文件），使得中心服务器知道它们想共享什么文件，让需要它的节点下载其可共享的资源。路由终端使用地址，通过被一组索引引用来取得绝对地址。 主要特征 1、所有节点参与提供资源，包括带宽，存储空间和计算能力； 2、网络的分布式，增加了系统的防故障的健壮性，消除了单点故障； 主要应用 文件共享：Napster、Guntella、BitTorrent、eMule、Maze 即时通信：Skype、GTalk、QQ 流媒体：PPLive、PPStream、AnySee 共享存储：CFS、Total Recall、Ocean Store、Granary 对等计算：SETI@home、Groove 分布式共识技术 由于点对点通信的原因，分布式系统或者点对点网络中，每个节点是按自己的规则运行的。为保持整个系统数据的一致性，需要借助分布式共识技术。传统的分布式技术中，由于本身的技术特点并不需要数据的一致性，更多的是数据的准确性，包括主从、Sharding技术等，但是在点对点网络中每个节点之间并没有依赖关系，所以就更需要数据一致性的机制。 分布式系统的一致性算法是从上世纪70年代就开始研究的经典问题。理解分布式共识算法，需要理解下面两个名词，分别是“异步”和“共识”。 异步：此处的异步不同于通常技术术语中的异步调用的异步，而是指在一个分布式系统中，对消息的处理速度或者消息送达时间不做任何假设。此就是著名的FLP不可能性定理。 共识：当多个主机通过异步通讯方式组成网络集群时，这个网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，即取得共识。 Ø&nbsp; CAP理论 CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。 图2-7 CAP理论 这是由分布式系统本身的特性决定的，包括网络的异步性质、通信的不可靠性质等，所以在分布式系统设计中，需要对这三者进行选择，根据系统的设计需求进行考虑。 Ø&nbsp; 节点通信方式 在分布式系统中，节点的通信技术分为共享内存（Shared Memory）和消息传递（Messages Passing）两种方式。 共享内存是指通信的多方在某个区域有公共的数据操作区域，解决了多方的数据交互问题，共享内存方式是多方直接通信比较直接和有效的方式，但是缺点也是比较明显的，就是公共的区域需要进行互斥操作，避免由于一方的操作影响到另一方的操作，所以在多方协同方面需要专门的设计。 消息传递是指多方在通信方面直接借助消息包进行交互，这种消息包的传递可以是系统内的，也可以是系统外的；可以是文件型的，也可以是网络型的。消息的多方之间互相不影响，但是消息传递增加了分布式系统的设计难度。 Ø&nbsp; Paxos Paxos是最初、最简单的分布式共识算法，是Leslie Lamport（也是LaTeX的实现者）于1990年提出的一种基于消息传递的一致性算法，是通过节点之间来回两次实现状态复制。 Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。 Paxos算法难以理解，更难以实现。 Paxos相关的论文是The Part-Time Parliament&nbsp;，基于Paxos算法也产生了一些改进算法，例如Egalitarian Paxos、Fast Paxos、Multi-Paxos等。 Ø&nbsp; Raft Raft正是因为Paxos算法不容易理解和实现而提出的，Raft通过在系统中引入强势领导者来解决相互系统之间的协调问题，Raft是Paxos的简化版本。Paxos和Raft的区别在于选举的具体过程不同。 在Raft中，任何时候一个服务器可以扮演下面角色之一： a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leader: 处理所有客户端交互、日志复制等，一般一次只有一个Leader； b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Follower: 类似选民，完全被动； c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。 Raft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。 Ø&nbsp; PBFT PBFT也称为拜占庭攻击容错算法。这里的拜占庭攻击，学术名称也称为主动型攻击，即它不是被动型攻击，不是简单的数据窃取和数据窃听，拜占庭攻击实现的是对消息的窃听，同时对消息进行恶意修改的目的。 PBFT算法由Castro和Liskov于1999年提出，是第一个比较广泛的BFT算法，在PBFT算法中至多可以容忍不超过系统全部节点的数量的三分之一拜占庭节点，即如果有超过三分之二的正常节点，系统就可以正常运转。 PBFT采取三阶段协议进行工作，包括pre-prepare、prepare和commit三个阶段。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 图2-8 &nbsp;PBFT三阶段 Ø&nbsp; POW POW，全称为Proof of work，也即POW证明机制是基于工作量的，通过工作量的证明来实现系统的数据共识。 POW机制在比特币系统出现之前已经有研究人员在使用，主要是用在防垃圾邮件方面。由于传统的邮件发送是没有任何成本的，这也导致了现在垃圾邮件的泛滥，通过工作量机制实现大量垃圾邮件发送的成本提升，也就有效的防止了垃圾邮件的大规模发送。 在比特币系统中POW证明机制决定了系统数据共识的来源方，也就是比特币系统中区块链的记账方的争夺，只需要向系统证明节点能够快速提供相应的工作量，节点就有向区块链中写入数据的权利。 POW证明机制基于的是数学上难以快速计算的问题，包括Hash碰撞问题、大数分解问题、椭圆曲线问题等。由于这些数学上“难”的问题没有计算的捷径，每个节点只能通过大量的穷举才能找到对应的答案，这是POW证明机制的优点，同时也是POW证明机制的缺点。由于POW是一种赢者通吃的模式，就容易导致系统中弱小的参与方只是陪练的角色，同时也浪费了系统大量的资源，是一种不“绿色”的机制。 POW现在的主要实现系统是比特币系统和以太坊系统。 &nbsp; Ø&nbsp; POS POS，全称为Proof of Stake，由Quantum Mechanic于2011年在bitcointalk论坛上面提出。 POS需要系统中运行一种代币，使用这种代币来表示系统中各个节点的权利，节点拥有更多的代币就拥有更多的发言权、更多的责任，同时也获得更多的收益。POS证明机制称为股权证明机制，黑客要攻击系统需要获得足够多的系统代币，这和算力无关，POS机制比POW机制环保，这是它的优点，同时也是它的缺点所在。&nbsp; POS机制的权利是由代币天然固定在系统中，使得POS系统运行产生的区块成本比POW低，所以POS代币的内在价值没有POW凝聚的价值大，所以人们对POS产生的代币多少持不信任态度。 POS机制一般和POW结合来使用，通过POS来控制POW工作量证明的难度，纯粹的POS机制实现比较困难。 POS目前主要在Peercoin和Nxt系统中实现，以太坊也计划转移到POS证明机制，称为Casper机制。另外还要有一些POS的变形，包括POS+POW以及DPOS等。 综合来看，以这些技术为基础，区块链实现了它去中心化的本质特征。通过非对称密码技术，实现了区块链的历史可信；通过点对点通信，实现了区块链网络的不可停止；通过共识机制，实现了区块链网络链条的唯一、数据的唯一，保障了系统的正常运行。 FLP不可能性：（FLP Impossibility）是分布式领域中一个非常著名的定理。该定理的论文是由Fischer, Lynch and Patterson三位作者于1985年发表,之后该论文毫无疑问得获得了Dijkstra奖。FLP给出了一个令人吃惊的结论：在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！ &nbsp; 转载／投稿请扫描以下二维码联系 阅读更多" />
<meta property="og:description" content="内容来源：书《区块链世界》 主编：井底望天／武文源／史伯平／赵国栋 本文内容为区块链入门级阅读材料，但是还是需要一定的基础知识才能理解，目前国内关于区块链的知识普及还比较少，本文虽然篇幅较长，好在文章语言质朴，耐心解释，希望能帮助到区块链初学者快速认知和理解。 “论天下大势，分久必合，合久必分”，这是历史的规律。合的意思就是集中管理，也可以说是中心化；分的意思就是分散管理，也可叫做去中心化。 中心化的好处是认证、管理机制明确统一，可以集中力量办大事，效率高；而弊端是管理、仲裁工作庞杂，机制上的任何缺陷都会造成问题，同时缺少权力的制约，从而出现不堪重负或者集中力量办坏事的情况。所以就有了以去中心化弥补中心化不足的需求。 从社会发展上来讲，在以前由于技术的限制和制度的约束，不管是人人自由还是人人平等，理想很丰满，但现实有点骨感。而区块链的出现在技术上实现了真正去中心化的可能，而这也必将促进社会的变革和进步。 那么区块链是如何在技术上实现去中心化的呢？核心主要是下面三种技术。 加密技术 密码技术体系有多种分类。基本上来讲，可以将密码技术分为对称加密体系和非对称加密体系，两个体系各自有不同的使用场景和技术路线。 图2-2 对称加密 &nbsp; 对称加密算法在加密和解密时使用的是同一个秘钥，这就决定了对称加密算法的两方需要事先进行秘钥协商，或者通信的双方需要预先知道双方使用的秘钥，保证一方的加密可以被另一方解密； 非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥其中一个是公开密钥（public key，公钥），另一个是私有密钥（private key，私钥）。 公钥是可以公开的，也需要通过公共的渠道公开给相应的通信方；而私钥是非对称加密算法中的关键，需要安全地保护好。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果使用私钥进行数据的签名，只有公有密钥可以来验签。 图2-3非对称加密 &nbsp; 因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。由非对称加密算法形成的非对称加密体系解决了信息公开传送和密钥管理问题，是一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。 &nbsp; 非对称加密算法 1、非对称加密与对称加密相比，其安全性更好； 2、非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。比特币采用椭圆曲线加密算法来产生公钥和私钥对，钱包地址即是公钥，私钥由用户保存。 &nbsp; Hash（哈希）算法 区块链系统中除了使用非对称加密算法之外，另一个重要的密码技术是Hash（哈希）算法或者叫散列技术。 所谓Hash，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是散列值的空间长度通常远小于输入的空间长度，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一地确定输入值。或者简单地说，就是一种将任意长度的数据信息压缩成某一固定长度的数据信息摘要的函数。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 图2-4 &nbsp;Hash算法 &nbsp; 散列函数有如下一个基本特性即免碰撞性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的——这个特性使得散列函数具有确定性的结果；但另一方面，散列函数的输入和输出不是一一对应的，如果两个散列值相同，两个输入值很可能是相同的，但并不能绝对肯定二者一定是相等的。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。 &nbsp; 区块链系统一般采用Hash算法来快速验证用户的身份。如果用户宣称对某个钱包具有所有权并且要改变钱包对应的信息（在比特币中，就是使用钱包中的余额），他必须提交一个请求，这个请求包括三个部分：钱包地址、明文请求、明文请求由钱包对应的私钥Hash过的签名。这个请求将被发送要区块链网络中。 每个节点可以用钱包的公钥来验证这个请求是否对应于这个签名，也就是通过这个办法来验证用户对钱包的所有权（拥有合适的私钥，但是不需要公开这个私钥）。 图2-5 &nbsp; 相比非对称加密，Hash算法一般快几个数量级以上，从而使得验证的过程可以非常快速。常用Hash算法有MD5、SHA1、SHA256、SHA512、HMAC等。 点对点通信技术 点对点通信技术（Peer to Peer通信技术），是一种对等连接的互联网技术，依赖网络中参与者共同的计算能力和带宽，而不是把依赖都聚集在较少的几台服务器上。这类网络可以用于多种用途，各种档案分享软件已经得到了广泛的使用。P2P技术也被使用在类似VoIP等实时媒体业务的数据通信中。 图2-6 点对点网络 纯点对点网络没有客户端或服务器的概念，只有平等的同级节点，同时对网络上的其它节点充当客户端和服务器。这种网络设计模型不同于传统的“客户端-服务器”模型，在“客户端-服务器”模型中通信通常来往于一个中央服务器，而中央服务器就是系统中的单点故障源头。点对点技术和形成的网络，也由于设计和实施方案的不同，也出现了不同的网络模型。 Ø&nbsp; 纯P2P网络模型 在此模型中，网络节点同时作为客户端和服务器，没有中心的服务器，没有中心的路由器。这样形成的网络完全根据系统中节点的活跃程度来保持，网络通信也主要是节点之间路由信息的广播，系统中的通信冗余比较大。 Ø&nbsp; 分层式P2P网络模型 在此模式中，网络节点的角色更加丰富了，网络中有一个中心服务器保存节点的信息并对请求这些信息的要求做出响应。同时节点负责发布这些信息（因为中心服务器并不保存文件），使得中心服务器知道它们想共享什么文件，让需要它的节点下载其可共享的资源。路由终端使用地址，通过被一组索引引用来取得绝对地址。 主要特征 1、所有节点参与提供资源，包括带宽，存储空间和计算能力； 2、网络的分布式，增加了系统的防故障的健壮性，消除了单点故障； 主要应用 文件共享：Napster、Guntella、BitTorrent、eMule、Maze 即时通信：Skype、GTalk、QQ 流媒体：PPLive、PPStream、AnySee 共享存储：CFS、Total Recall、Ocean Store、Granary 对等计算：SETI@home、Groove 分布式共识技术 由于点对点通信的原因，分布式系统或者点对点网络中，每个节点是按自己的规则运行的。为保持整个系统数据的一致性，需要借助分布式共识技术。传统的分布式技术中，由于本身的技术特点并不需要数据的一致性，更多的是数据的准确性，包括主从、Sharding技术等，但是在点对点网络中每个节点之间并没有依赖关系，所以就更需要数据一致性的机制。 分布式系统的一致性算法是从上世纪70年代就开始研究的经典问题。理解分布式共识算法，需要理解下面两个名词，分别是“异步”和“共识”。 异步：此处的异步不同于通常技术术语中的异步调用的异步，而是指在一个分布式系统中，对消息的处理速度或者消息送达时间不做任何假设。此就是著名的FLP不可能性定理。 共识：当多个主机通过异步通讯方式组成网络集群时，这个网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，即取得共识。 Ø&nbsp; CAP理论 CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。 图2-7 CAP理论 这是由分布式系统本身的特性决定的，包括网络的异步性质、通信的不可靠性质等，所以在分布式系统设计中，需要对这三者进行选择，根据系统的设计需求进行考虑。 Ø&nbsp; 节点通信方式 在分布式系统中，节点的通信技术分为共享内存（Shared Memory）和消息传递（Messages Passing）两种方式。 共享内存是指通信的多方在某个区域有公共的数据操作区域，解决了多方的数据交互问题，共享内存方式是多方直接通信比较直接和有效的方式，但是缺点也是比较明显的，就是公共的区域需要进行互斥操作，避免由于一方的操作影响到另一方的操作，所以在多方协同方面需要专门的设计。 消息传递是指多方在通信方面直接借助消息包进行交互，这种消息包的传递可以是系统内的，也可以是系统外的；可以是文件型的，也可以是网络型的。消息的多方之间互相不影响，但是消息传递增加了分布式系统的设计难度。 Ø&nbsp; Paxos Paxos是最初、最简单的分布式共识算法，是Leslie Lamport（也是LaTeX的实现者）于1990年提出的一种基于消息传递的一致性算法，是通过节点之间来回两次实现状态复制。 Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。 Paxos算法难以理解，更难以实现。 Paxos相关的论文是The Part-Time Parliament&nbsp;，基于Paxos算法也产生了一些改进算法，例如Egalitarian Paxos、Fast Paxos、Multi-Paxos等。 Ø&nbsp; Raft Raft正是因为Paxos算法不容易理解和实现而提出的，Raft通过在系统中引入强势领导者来解决相互系统之间的协调问题，Raft是Paxos的简化版本。Paxos和Raft的区别在于选举的具体过程不同。 在Raft中，任何时候一个服务器可以扮演下面角色之一： a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leader: 处理所有客户端交互、日志复制等，一般一次只有一个Leader； b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Follower: 类似选民，完全被动； c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。 Raft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。 Ø&nbsp; PBFT PBFT也称为拜占庭攻击容错算法。这里的拜占庭攻击，学术名称也称为主动型攻击，即它不是被动型攻击，不是简单的数据窃取和数据窃听，拜占庭攻击实现的是对消息的窃听，同时对消息进行恶意修改的目的。 PBFT算法由Castro和Liskov于1999年提出，是第一个比较广泛的BFT算法，在PBFT算法中至多可以容忍不超过系统全部节点的数量的三分之一拜占庭节点，即如果有超过三分之二的正常节点，系统就可以正常运转。 PBFT采取三阶段协议进行工作，包括pre-prepare、prepare和commit三个阶段。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 图2-8 &nbsp;PBFT三阶段 Ø&nbsp; POW POW，全称为Proof of work，也即POW证明机制是基于工作量的，通过工作量的证明来实现系统的数据共识。 POW机制在比特币系统出现之前已经有研究人员在使用，主要是用在防垃圾邮件方面。由于传统的邮件发送是没有任何成本的，这也导致了现在垃圾邮件的泛滥，通过工作量机制实现大量垃圾邮件发送的成本提升，也就有效的防止了垃圾邮件的大规模发送。 在比特币系统中POW证明机制决定了系统数据共识的来源方，也就是比特币系统中区块链的记账方的争夺，只需要向系统证明节点能够快速提供相应的工作量，节点就有向区块链中写入数据的权利。 POW证明机制基于的是数学上难以快速计算的问题，包括Hash碰撞问题、大数分解问题、椭圆曲线问题等。由于这些数学上“难”的问题没有计算的捷径，每个节点只能通过大量的穷举才能找到对应的答案，这是POW证明机制的优点，同时也是POW证明机制的缺点。由于POW是一种赢者通吃的模式，就容易导致系统中弱小的参与方只是陪练的角色，同时也浪费了系统大量的资源，是一种不“绿色”的机制。 POW现在的主要实现系统是比特币系统和以太坊系统。 &nbsp; Ø&nbsp; POS POS，全称为Proof of Stake，由Quantum Mechanic于2011年在bitcointalk论坛上面提出。 POS需要系统中运行一种代币，使用这种代币来表示系统中各个节点的权利，节点拥有更多的代币就拥有更多的发言权、更多的责任，同时也获得更多的收益。POS证明机制称为股权证明机制，黑客要攻击系统需要获得足够多的系统代币，这和算力无关，POS机制比POW机制环保，这是它的优点，同时也是它的缺点所在。&nbsp; POS机制的权利是由代币天然固定在系统中，使得POS系统运行产生的区块成本比POW低，所以POS代币的内在价值没有POW凝聚的价值大，所以人们对POS产生的代币多少持不信任态度。 POS机制一般和POW结合来使用，通过POS来控制POW工作量证明的难度，纯粹的POS机制实现比较困难。 POS目前主要在Peercoin和Nxt系统中实现，以太坊也计划转移到POS证明机制，称为Casper机制。另外还要有一些POS的变形，包括POS+POW以及DPOS等。 综合来看，以这些技术为基础，区块链实现了它去中心化的本质特征。通过非对称密码技术，实现了区块链的历史可信；通过点对点通信，实现了区块链网络的不可停止；通过共识机制，实现了区块链网络链条的唯一、数据的唯一，保障了系统的正常运行。 FLP不可能性：（FLP Impossibility）是分布式领域中一个非常著名的定理。该定理的论文是由Fischer, Lynch and Patterson三位作者于1985年发表,之后该论文毫无疑问得获得了Dijkstra奖。FLP给出了一个令人吃惊的结论：在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！ &nbsp; 转载／投稿请扫描以下二维码联系 阅读更多" />
<link rel="canonical" href="https://mlh.app/2016/12/08/b677491217a2bef71ed4550888dd100d.html" />
<meta property="og:url" content="https://mlh.app/2016/12/08/b677491217a2bef71ed4550888dd100d.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-12-08T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"内容来源：书《区块链世界》 主编：井底望天／武文源／史伯平／赵国栋 本文内容为区块链入门级阅读材料，但是还是需要一定的基础知识才能理解，目前国内关于区块链的知识普及还比较少，本文虽然篇幅较长，好在文章语言质朴，耐心解释，希望能帮助到区块链初学者快速认知和理解。 “论天下大势，分久必合，合久必分”，这是历史的规律。合的意思就是集中管理，也可以说是中心化；分的意思就是分散管理，也可叫做去中心化。 中心化的好处是认证、管理机制明确统一，可以集中力量办大事，效率高；而弊端是管理、仲裁工作庞杂，机制上的任何缺陷都会造成问题，同时缺少权力的制约，从而出现不堪重负或者集中力量办坏事的情况。所以就有了以去中心化弥补中心化不足的需求。 从社会发展上来讲，在以前由于技术的限制和制度的约束，不管是人人自由还是人人平等，理想很丰满，但现实有点骨感。而区块链的出现在技术上实现了真正去中心化的可能，而这也必将促进社会的变革和进步。 那么区块链是如何在技术上实现去中心化的呢？核心主要是下面三种技术。 加密技术 密码技术体系有多种分类。基本上来讲，可以将密码技术分为对称加密体系和非对称加密体系，两个体系各自有不同的使用场景和技术路线。 图2-2 对称加密 &nbsp; 对称加密算法在加密和解密时使用的是同一个秘钥，这就决定了对称加密算法的两方需要事先进行秘钥协商，或者通信的双方需要预先知道双方使用的秘钥，保证一方的加密可以被另一方解密； 非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥其中一个是公开密钥（public key，公钥），另一个是私有密钥（private key，私钥）。 公钥是可以公开的，也需要通过公共的渠道公开给相应的通信方；而私钥是非对称加密算法中的关键，需要安全地保护好。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果使用私钥进行数据的签名，只有公有密钥可以来验签。 图2-3非对称加密 &nbsp; 因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。由非对称加密算法形成的非对称加密体系解决了信息公开传送和密钥管理问题，是一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。 &nbsp; 非对称加密算法 1、非对称加密与对称加密相比，其安全性更好； 2、非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。比特币采用椭圆曲线加密算法来产生公钥和私钥对，钱包地址即是公钥，私钥由用户保存。 &nbsp; Hash（哈希）算法 区块链系统中除了使用非对称加密算法之外，另一个重要的密码技术是Hash（哈希）算法或者叫散列技术。 所谓Hash，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是散列值的空间长度通常远小于输入的空间长度，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一地确定输入值。或者简单地说，就是一种将任意长度的数据信息压缩成某一固定长度的数据信息摘要的函数。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 图2-4 &nbsp;Hash算法 &nbsp; 散列函数有如下一个基本特性即免碰撞性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的——这个特性使得散列函数具有确定性的结果；但另一方面，散列函数的输入和输出不是一一对应的，如果两个散列值相同，两个输入值很可能是相同的，但并不能绝对肯定二者一定是相等的。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。 &nbsp; 区块链系统一般采用Hash算法来快速验证用户的身份。如果用户宣称对某个钱包具有所有权并且要改变钱包对应的信息（在比特币中，就是使用钱包中的余额），他必须提交一个请求，这个请求包括三个部分：钱包地址、明文请求、明文请求由钱包对应的私钥Hash过的签名。这个请求将被发送要区块链网络中。 每个节点可以用钱包的公钥来验证这个请求是否对应于这个签名，也就是通过这个办法来验证用户对钱包的所有权（拥有合适的私钥，但是不需要公开这个私钥）。 图2-5 &nbsp; 相比非对称加密，Hash算法一般快几个数量级以上，从而使得验证的过程可以非常快速。常用Hash算法有MD5、SHA1、SHA256、SHA512、HMAC等。 点对点通信技术 点对点通信技术（Peer to Peer通信技术），是一种对等连接的互联网技术，依赖网络中参与者共同的计算能力和带宽，而不是把依赖都聚集在较少的几台服务器上。这类网络可以用于多种用途，各种档案分享软件已经得到了广泛的使用。P2P技术也被使用在类似VoIP等实时媒体业务的数据通信中。 图2-6 点对点网络 纯点对点网络没有客户端或服务器的概念，只有平等的同级节点，同时对网络上的其它节点充当客户端和服务器。这种网络设计模型不同于传统的“客户端-服务器”模型，在“客户端-服务器”模型中通信通常来往于一个中央服务器，而中央服务器就是系统中的单点故障源头。点对点技术和形成的网络，也由于设计和实施方案的不同，也出现了不同的网络模型。 Ø&nbsp; 纯P2P网络模型 在此模型中，网络节点同时作为客户端和服务器，没有中心的服务器，没有中心的路由器。这样形成的网络完全根据系统中节点的活跃程度来保持，网络通信也主要是节点之间路由信息的广播，系统中的通信冗余比较大。 Ø&nbsp; 分层式P2P网络模型 在此模式中，网络节点的角色更加丰富了，网络中有一个中心服务器保存节点的信息并对请求这些信息的要求做出响应。同时节点负责发布这些信息（因为中心服务器并不保存文件），使得中心服务器知道它们想共享什么文件，让需要它的节点下载其可共享的资源。路由终端使用地址，通过被一组索引引用来取得绝对地址。 主要特征 1、所有节点参与提供资源，包括带宽，存储空间和计算能力； 2、网络的分布式，增加了系统的防故障的健壮性，消除了单点故障； 主要应用 文件共享：Napster、Guntella、BitTorrent、eMule、Maze 即时通信：Skype、GTalk、QQ 流媒体：PPLive、PPStream、AnySee 共享存储：CFS、Total Recall、Ocean Store、Granary 对等计算：SETI@home、Groove 分布式共识技术 由于点对点通信的原因，分布式系统或者点对点网络中，每个节点是按自己的规则运行的。为保持整个系统数据的一致性，需要借助分布式共识技术。传统的分布式技术中，由于本身的技术特点并不需要数据的一致性，更多的是数据的准确性，包括主从、Sharding技术等，但是在点对点网络中每个节点之间并没有依赖关系，所以就更需要数据一致性的机制。 分布式系统的一致性算法是从上世纪70年代就开始研究的经典问题。理解分布式共识算法，需要理解下面两个名词，分别是“异步”和“共识”。 异步：此处的异步不同于通常技术术语中的异步调用的异步，而是指在一个分布式系统中，对消息的处理速度或者消息送达时间不做任何假设。此就是著名的FLP不可能性定理。 共识：当多个主机通过异步通讯方式组成网络集群时，这个网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，即取得共识。 Ø&nbsp; CAP理论 CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。 图2-7 CAP理论 这是由分布式系统本身的特性决定的，包括网络的异步性质、通信的不可靠性质等，所以在分布式系统设计中，需要对这三者进行选择，根据系统的设计需求进行考虑。 Ø&nbsp; 节点通信方式 在分布式系统中，节点的通信技术分为共享内存（Shared Memory）和消息传递（Messages Passing）两种方式。 共享内存是指通信的多方在某个区域有公共的数据操作区域，解决了多方的数据交互问题，共享内存方式是多方直接通信比较直接和有效的方式，但是缺点也是比较明显的，就是公共的区域需要进行互斥操作，避免由于一方的操作影响到另一方的操作，所以在多方协同方面需要专门的设计。 消息传递是指多方在通信方面直接借助消息包进行交互，这种消息包的传递可以是系统内的，也可以是系统外的；可以是文件型的，也可以是网络型的。消息的多方之间互相不影响，但是消息传递增加了分布式系统的设计难度。 Ø&nbsp; Paxos Paxos是最初、最简单的分布式共识算法，是Leslie Lamport（也是LaTeX的实现者）于1990年提出的一种基于消息传递的一致性算法，是通过节点之间来回两次实现状态复制。 Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。 Paxos算法难以理解，更难以实现。 Paxos相关的论文是The Part-Time Parliament&nbsp;，基于Paxos算法也产生了一些改进算法，例如Egalitarian Paxos、Fast Paxos、Multi-Paxos等。 Ø&nbsp; Raft Raft正是因为Paxos算法不容易理解和实现而提出的，Raft通过在系统中引入强势领导者来解决相互系统之间的协调问题，Raft是Paxos的简化版本。Paxos和Raft的区别在于选举的具体过程不同。 在Raft中，任何时候一个服务器可以扮演下面角色之一： a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leader: 处理所有客户端交互、日志复制等，一般一次只有一个Leader； b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Follower: 类似选民，完全被动； c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。 Raft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。 Ø&nbsp; PBFT PBFT也称为拜占庭攻击容错算法。这里的拜占庭攻击，学术名称也称为主动型攻击，即它不是被动型攻击，不是简单的数据窃取和数据窃听，拜占庭攻击实现的是对消息的窃听，同时对消息进行恶意修改的目的。 PBFT算法由Castro和Liskov于1999年提出，是第一个比较广泛的BFT算法，在PBFT算法中至多可以容忍不超过系统全部节点的数量的三分之一拜占庭节点，即如果有超过三分之二的正常节点，系统就可以正常运转。 PBFT采取三阶段协议进行工作，包括pre-prepare、prepare和commit三个阶段。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 图2-8 &nbsp;PBFT三阶段 Ø&nbsp; POW POW，全称为Proof of work，也即POW证明机制是基于工作量的，通过工作量的证明来实现系统的数据共识。 POW机制在比特币系统出现之前已经有研究人员在使用，主要是用在防垃圾邮件方面。由于传统的邮件发送是没有任何成本的，这也导致了现在垃圾邮件的泛滥，通过工作量机制实现大量垃圾邮件发送的成本提升，也就有效的防止了垃圾邮件的大规模发送。 在比特币系统中POW证明机制决定了系统数据共识的来源方，也就是比特币系统中区块链的记账方的争夺，只需要向系统证明节点能够快速提供相应的工作量，节点就有向区块链中写入数据的权利。 POW证明机制基于的是数学上难以快速计算的问题，包括Hash碰撞问题、大数分解问题、椭圆曲线问题等。由于这些数学上“难”的问题没有计算的捷径，每个节点只能通过大量的穷举才能找到对应的答案，这是POW证明机制的优点，同时也是POW证明机制的缺点。由于POW是一种赢者通吃的模式，就容易导致系统中弱小的参与方只是陪练的角色，同时也浪费了系统大量的资源，是一种不“绿色”的机制。 POW现在的主要实现系统是比特币系统和以太坊系统。 &nbsp; Ø&nbsp; POS POS，全称为Proof of Stake，由Quantum Mechanic于2011年在bitcointalk论坛上面提出。 POS需要系统中运行一种代币，使用这种代币来表示系统中各个节点的权利，节点拥有更多的代币就拥有更多的发言权、更多的责任，同时也获得更多的收益。POS证明机制称为股权证明机制，黑客要攻击系统需要获得足够多的系统代币，这和算力无关，POS机制比POW机制环保，这是它的优点，同时也是它的缺点所在。&nbsp; POS机制的权利是由代币天然固定在系统中，使得POS系统运行产生的区块成本比POW低，所以POS代币的内在价值没有POW凝聚的价值大，所以人们对POS产生的代币多少持不信任态度。 POS机制一般和POW结合来使用，通过POS来控制POW工作量证明的难度，纯粹的POS机制实现比较困难。 POS目前主要在Peercoin和Nxt系统中实现，以太坊也计划转移到POS证明机制，称为Casper机制。另外还要有一些POS的变形，包括POS+POW以及DPOS等。 综合来看，以这些技术为基础，区块链实现了它去中心化的本质特征。通过非对称密码技术，实现了区块链的历史可信；通过点对点通信，实现了区块链网络的不可停止；通过共识机制，实现了区块链网络链条的唯一、数据的唯一，保障了系统的正常运行。 FLP不可能性：（FLP Impossibility）是分布式领域中一个非常著名的定理。该定理的论文是由Fischer, Lynch and Patterson三位作者于1985年发表,之后该论文毫无疑问得获得了Dijkstra奖。FLP给出了一个令人吃惊的结论：在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！ &nbsp; 转载／投稿请扫描以下二维码联系 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2016/12/08/b677491217a2bef71ed4550888dd100d.html","headline":"区块链如何在技术上实现去中心化的呢？","dateModified":"2016-12-08T00:00:00+08:00","datePublished":"2016-12-08T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2016/12/08/b677491217a2bef71ed4550888dd100d.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链如何在技术上实现去中心化的呢？</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/fcTCLwqsqxOdj2x0wDhZLYlWYNNvdvzCfml8zHPgwicZlf9BMwxqhOOtJbicZ4sRP0zA4QoquSwwHyNgg2lCRCtg/640?wx_fmt=png" alt="640?wx_fmt=png"><br></p> 
  <p style="text-align:center;"><br></p> 
  <p style="text-align:center;"><span style="font-size:14px;"><strong> 内容来源：书《区块链世界》</strong></span></p> 
  <p style="text-align:center;"><strong><span style="font-size:14px;">主编：井底望天／武文源／史伯平／赵国栋</span></strong></p> 
  <p style="text-align:center;"><span style="font-size:14px;"><strong><br></strong></span></p> 
  <p style="text-align:center;"><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/fcTCLwqsqxOdj2x0wDhZLYlWYNNvdvzCNUuorxLmKvtsias5fQKKZia44hNT5KntrIrzicCIpFxvZNe9LIhExWKMg/640?wx_fmt=png" alt="640?wx_fmt=png"></p> 
  <p><br></p> 
  <p><strong>本文内容为区块链入门级阅读材料，但是还是需要一定的基础知识才能理解，<span>目前国内关于区块链的知识普及还比较少，本文虽然篇幅较长，</span>好在文章语言质朴，耐心解释，希望能帮助到区块链初学者快速认知和理解。</strong></p> 
  <p><br></p> 
  <p><br></p> 
  <p><span style="font-size:14px;">“论天下大势，分久必合，合久必分”，这是历史的规律。合的意思就是集中管理，也可以说是中心化；分的意思就是分散管理，也可叫做去中心化。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">中心化的<strong>好处</strong>是认证、管理机制明确统一，可以集中力量办大事，效率高；而弊端是管理、仲裁工作庞杂，机制上的任何缺陷都会造成问题，同时缺少权力的制约，从而出现不堪重负或者集中力量办坏事的情况。所以就有了以去中心化弥补中心化不足的需求。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">从社会发展上来讲，在以前由于技术的限制和制度的约束，不管是人人自由还是人人平等，理想很丰满，但现实有点<strong>骨感</strong>。而区块链的出现在技术上实现了真正去中心化的可能，而这也必将促进社会的变革和进步。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">那么区块链是如何在技术上实现去中心化的呢？核心主要是下面三种技术。</span></p> 
  <h4><span style="font-family:'微软雅黑';"><br></span></h4> 
  <h4><span style="color:rgb(217,33,66);"><strong><span style="font-family:'微软雅黑';">加密技术</span></strong></span></h4> 
  <p><br><span style="font-size:14px;"> 密码技术体系有多种分类。基本上来讲，可以将密码技术分为<strong>对称加密体系和非对称加密体系</strong>，两个体系各自有不同的使用场景和技术路线。</span></p> 
  <p style="text-align:center;"><strong><span style="font-family:'微软雅黑';"><br></span></strong></p> 
  <p style="text-align:center;"><strong><span style="font-family:'微软雅黑';"></span></strong></p> 
  <p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/fcTCLwqsqxMyP7omDKPibz50FGTspOibh42PUfE6d4sepfw1tc3UcElGiagAp0MRT8nyZnAPOSDVx7GicQR50owIIg/0" alt="0"></p> 
  <p style="text-align:center;"><strong><span style="font-family:'微软雅黑';"></span></strong><br></p> 
  <p style="text-align:center;"><span style="font-size:12px;"><strong><span style="font-family:'微软雅黑';">图</span></strong><strong>2-2 </strong><strong><span style="font-family:'微软雅黑';">对称加密</span></strong></span></p> 
  <p style="text-indent:32px;">&nbsp;</p> 
  <p><span style="font-size:14px;">对称加密算法在加密和解密时使用的是同一个秘钥，这就决定了对称加密算法的两方需要事先进行秘钥协商，或者通信的双方需要预先知道双方使用的秘钥，保证一方的加密可以被另一方解密；</span></p> 
  <p><br><span style="font-size:14px;"> 非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥其中一个是<strong>公开密钥（public key，公钥）</strong>，另一个是<strong>私有密钥（private key，私钥）</strong>。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">公钥是可以公开的，也需要通过公共的渠道公开给相应的通信方；而私钥是非对称加密算法中的关键，需要安全地保护好。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果使用私钥进行数据的签名，只有公有密钥可以来验签。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><strong><span style="font-family:'微软雅黑';"><br></span></strong></p> 
  <p style="text-align:center;"><strong><span style="font-family:'微软雅黑';"></span></strong></p> 
  <p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/fcTCLwqsqxMyP7omDKPibz50FGTspOibh44HHZy5Z72N0LiaFib1mWYCzx5HgxULDneeclj9tiaItsdiaw5G3Hw6k7DQ/0" alt="0"></p> 
  <p style="text-align:center;"><strong><span style="font-family:'微软雅黑';"></span></strong><br></p> 
  <p style="text-align:center;"><span style="font-size:12px;"><strong><span style="font-family:'微软雅黑';">图</span></strong><strong>2-3</strong><strong><span style="font-family:'微软雅黑';">非对称加密</span></strong></span></p> 
  <p style="text-indent:32px;">&nbsp;</p> 
  <p><span style="font-size:14px;">因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。由非对称加密算法形成的非对称加密体系解决了信息公开传送和密钥管理问题，是一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。</span></p> 
  <p>&nbsp;</p> 
  <ul style="list-style-type:disc;" class="list-paddingleft-2">
   <li><p><strong><span style="font-size:16px;line-height:107%;font-family:'微软雅黑';">非对称加密算法</span></strong></p><p><strong><span style="font-size:16px;line-height:107%;font-family:'微软雅黑';"></span></strong></p><p><strong><span style="font-size:16px;line-height:107%;font-family:'微软雅黑';"><br></span></strong></p></li> 
  </ul>
  <p><strong><span style="font-size:16px;line-height:107%;font-family:'微软雅黑';"></span></strong><span style="font-size:14px;"><span style="text-indent:32px;">1</span><span style="text-indent:32px;font-family:'微软雅黑';">、非对称加密与对称加密相比，其安全性更好；</span></span></p> 
  <p><span style="font-size:14px;">2<span style="font-size:14px;font-family:'微软雅黑';">、</span>非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</span></p> 
  <p><span style="font-size:14px;">在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。比特币采用椭圆曲线加密算法来产生公钥和私钥对，钱包地址即是公钥，私钥由用户保存。</span></p> 
  <p style="text-indent:32px;">&nbsp;</p> 
  <ul style="list-style-type:disc;" class="list-paddingleft-2">
   <li><p><strong><span style="font-size:16px;line-height:107%;font-family:'微软雅黑';">Hash</span></strong><strong><span style="font-size:16px;line-height:107%;font-family:'微软雅黑';">（哈希）算法</span></strong></p><p><strong><span style="font-size:16px;line-height:107%;font-family:'微软雅黑';"></span></strong></p><p><strong><span style="font-size:16px;line-height:107%;font-family:'微软雅黑';"><br></span></strong></p></li> 
  </ul>
  <p><span style="font-size:14px;"><span style="font-family:'微软雅黑';">区块链系统中除了使用非对称加密算法之外，另一个重要的密码技术是</span><strong>Hash<span style="font-family:'微软雅黑';">（哈希）算法或者叫散列技术</span></strong><span style="font-family:'微软雅黑';">。</span></span></p> 
  <p><span style="font-size:14px;font-family:'微软雅黑';"><br></span></p> 
  <p><span style="font-size:14px;"><span style="font-size:14px;font-family:'微软雅黑';">所谓</span>Hash<span style="font-size:14px;font-family:'微软雅黑';">，就是把任意长度的</span><span style="font-size:14px;font-family:'微软雅黑';">输入</span><span style="font-size:14px;font-family:'微软雅黑';">通过散列算法变换成固定长度的</span><span style="font-size:14px;font-family:'微软雅黑';">输出</span><span style="font-size:14px;font-family:'微软雅黑';">，该输出就是散列值。这种转换是一种压缩映射，也就是散列值的空间长度通常远小于输入的空间长度，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一地确定输入值。或者简单地说，就是一种将任意长度的数据信息压缩成某一固定长度的数据</span><span style="font-size:14px;font-family:'微软雅黑';">信息摘要</span><span style="font-size:14px;font-family:'微软雅黑';">的函数。</span></span></p> 
  <p style="text-align:center;text-indent:0;"><strong><span style="font-family:'宋体';"><br></span></strong></p> 
  <p style="text-align:center;text-indent:0;"><strong><span style="font-family:'宋体';"></span></strong></p> 
  <p><br></p> 
  <p style="text-align:center;text-indent:0;"><strong><span style="font-family:'宋体';"></span></strong></p> 
  <p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/fcTCLwqsqxMyP7omDKPibz50FGTspOibh4YNTPSgwFIhpyYWfTjP07gicicVpxc98zpR1ZPjj7JtHHLtmBhehZuyJw/0" alt="0"></p> 
  <p style="text-align:left;text-indent:0px;"><strong><span style="font-family:'宋体';"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></strong><span style="font-size:12px;"><strong><span style="font-family:'宋体';"> &nbsp; &nbsp; &nbsp; 图</span></strong><strong>2-4</strong></span><br><br></p> 
  <p style="text-align:left;text-indent:0px;"><span style="color:rgb(217,33,66);"><strong>&nbsp;Hash</strong><strong><span style="color:rgb(217,33,66);font-family:'宋体';">算法</span></strong></span></p> 
  <p style="text-indent:32px;text-align:left;">&nbsp;</p> 
  <p><span style="font-size:14px;">散列函数有如下一个基本特性即<strong>免碰撞性</strong>：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的——这个特性使得散列函数具有确定性的结果；但另一方面，散列函数的输入和输出不是一一对应的，如果两个散列值相同，两个输入值很可能是相同的，但并不能绝对肯定二者一定是相等的。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。</span></p> 
  <p style="text-indent:32px;">&nbsp;</p> 
  <p><span style="font-size:14px;">区块链系统一般采用Hash算法来快速验证用户的身份。如果用户宣称对某个钱包具有所有权并且要改变钱包对应的信息（在比特币中，就是使用钱包中的余额），他必须提交一个<strong>请求</strong>，这个请求包括三个部分：<strong>钱包地址、明文请求、明文请求</strong>由钱包对应的私钥Hash过的签名。这个请求将被发送要区块链网络中。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">每个节点可以用钱包的公钥来验证这个请求是否对应于这个签名，也就是通过这个办法来验证用户对钱包的所有权（拥有合适的私钥，但是不需要公开这个私钥）。</span></p> 
  <p style="text-align:center;text-indent:32px;"><strong><span style="font-family:'微软雅黑';"><br></span></strong></p> 
  <p style="text-align:center;text-indent:32px;"><strong><span style="font-family:'微软雅黑';"></span></strong></p> 
  <p><br></p> 
  <p style="text-align:center;text-indent:32px;"><strong><span style="font-family:'微软雅黑';"></span></strong><img style="width:516px;" src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/fcTCLwqsqxMyP7omDKPibz50FGTspOibh44sI0OAt6piblx1Cziao3qWH0ic5IB3E5UWe2nkEdwcy7wBKkNveTJicmGA/0" alt="0"></p> 
  <p style="text-align:center;text-indent:32px;"><span style="font-size:12px;"><strong><span style="font-family:'微软雅黑';">图</span>2-5</strong></span></p> 
  <p style="text-indent:32px;">&nbsp;</p> 
  <p><span style="font-size:14px;">相比非对称加密，Hash算法一般快几个数量级以上，从而使得验证的过程可以非常快速。常用Hash算法有MD5、SHA1、SHA256、SHA512、HMAC等。</span></p> 
  <p><br></p> 
  <h4><span style="color:rgb(217,33,66);"><strong><span style="color:rgb(217,33,66);font-family:'微软雅黑';">点对点通信技术</span></strong></span></h4> 
  <p><br><span style="font-size:14px;"> 点对点通信技术（Peer to Peer通信技术），是一种对等连接的互联网技术，依赖网络中参与者共同的计算能力和带宽，而不是把依赖都聚集在较少的几台服务器上。这类网络可以用于多种用途，各种档案分享软件已经得到了广泛的使用。P2P技术也被使用在类似VoIP等实时媒体业务的数据通信中。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p style="text-indent:32px;"><img style="width:516px;" src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/fcTCLwqsqxMyP7omDKPibz50FGTspOibh42mqITibBJtKM5BXESjREhtTCLesiawCLUg2okTib906jZNxtJI2Omgl2Q/0" alt="0"></p> 
  <p style="text-align:center;line-height:150%;"><span style="font-size:12px;"><strong><span style="font-family:'微软雅黑';">图</span>2-6 </strong><strong><span style="font-family:'微软雅黑';">点对点网络</span></strong></span></p> 
  <p><br></p> 
  <p><span style="font-size:14px;">纯点对点网络没有客户端或服务器的概念，只有平等的同级节点，同时对网络上的其它节点充当客户端和服务器。这种网络设计模型不同于传统的“客户端-服务器”模型，在“客户端-服务器”模型中通信通常来往于一个中央服务器，而中央服务器就是系统中的单点故障源头。点对点技术和形成的网络，也由于设计和实施方案的不同，也出现了不同的网络模型。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p style="margin-left:28px;text-align:left;line-height:150%;"><span style="line-height:150%;font-family:Wingdings;">Ø<span>&nbsp; </span></span><strong><span style="line-height:150%;font-family:'微软雅黑';">纯P2P网络模型</span></strong></p> 
  <p><span style="font-size:14px;">在此模型中，网络节点同时作为客户端和服务器，没有中心的服务器，没有中心的路由器。这样形成的网络完全根据系统中节点的活跃程度来保持，网络通信也主要是节点之间路由信息的广播，系统中的通信冗余比较大。</span></p> 
  <p><br></p> 
  <p style="margin-left:28px;text-align:left;line-height:150%;"><span style="line-height:150%;font-family:Wingdings;">Ø<span>&nbsp; </span></span><strong><span style="line-height:150%;font-family:'微软雅黑';">分层式P2P网络模型</span></strong></p> 
  <p><span style="font-size:14px;">在此模式中，网络节点的角色更加丰富了，网络中有一个中心服务器保存节点的信息并对请求这些信息的要求做出响应。同时节点负责发布这些信息（因为中心服务器并不保存文件），使得中心服务器知道它们想共享什么文件，让需要它的节点下载其可共享的资源。路由终端使用地址，通过被一组索引引用来取得绝对地址。</span></p> 
  <p><br></p> 
  <ul style="list-style-type:disc;" class="list-paddingleft-2">
   <li><p style="line-height:150%;"><strong><span style="font-size:16px;line-height:150%;font-family:'微软雅黑';">主要特征</span></strong></p></li> 
  </ul>
  <p style="text-indent:32px;"><span style="font-size:14px;">1<span style="font-family:'微软雅黑';">、所有节点参与提供资源，包括带宽，存储空间和计算能力；</span></span></p> 
  <p style="text-indent:32px;"><span style="font-size:14px;">2<span style="font-size:14px;font-family:'微软雅黑';">、网络的分布式，增加了系统的防故障的健壮性，消除了单点故障；</span></span></p> 
  <p style="text-indent:32px;"><span style="font-size:14px;font-family:'微软雅黑';"><br></span></p> 
  <ul style="list-style-type:disc;" class="list-paddingleft-2">
   <li><p style="line-height:150%;"><strong><span style="font-size:16px;line-height:150%;font-family:'微软雅黑';">主要应用</span></strong></p></li> 
  </ul>
  <p style="text-indent:32px;"><span style="font-size:14px;"><span style="font-family:'微软雅黑';">文件共享：</span>Napster<span style="font-family:'微软雅黑';">、</span>Guntella<span style="font-family:'微软雅黑';">、</span>BitTorrent<span style="font-family:'微软雅黑';">、</span>eMule<span style="font-family:'微软雅黑';">、</span>Maze</span></p> 
  <p style="text-indent:32px;"><span style="font-size:14px;"><span style="font-size:14px;font-family:'微软雅黑';">即时通信：</span>Skype<span style="font-size:14px;font-family:'微软雅黑';">、</span>GTalk<span style="font-size:14px;font-family:'微软雅黑';">、</span>QQ</span></p> 
  <p style="text-indent:32px;"><span style="font-size:14px;"><span style="font-size:14px;font-family:'微软雅黑';">流媒体：</span>PPLive<span style="font-size:14px;font-family:'微软雅黑';">、</span>PPStream<span style="font-size:14px;font-family:'微软雅黑';">、</span>AnySee</span></p> 
  <p style="text-indent:32px;"><span style="font-size:14px;"><span style="font-size:14px;font-family:'微软雅黑';">共享存储：</span>CFS<span style="font-size:14px;font-family:'微软雅黑';">、</span>Total Recall<span style="font-size:14px;font-family:'微软雅黑';">、</span>Ocean Store<span style="font-size:14px;font-family:'微软雅黑';">、</span>Granary</span></p> 
  <p style="text-indent:32px;"><span style="font-size:14px;"><span style="font-size:14px;font-family:'微软雅黑';">对等计算：</span>SETI@home<span style="font-size:14px;font-family:'微软雅黑';">、</span>Groove</span></p> 
  <p style="text-indent:32px;"><span style="font-size:14px;color:rgb(217,33,66);"><br></span></p> 
  <h4><span style="color:rgb(217,33,66);"><strong><span style="color:rgb(217,33,66);font-family:'微软雅黑';">分布式共识技术</span></strong></span></h4> 
  <p><span style="font-family:'微软雅黑';"><br></span></p> 
  <p><span style="font-size:14px;">由于点对点通信的原因，分布式系统或者点对点网络中，每个节点是按自己的规则运行的。为保持整个系统数据的一致性，需要借助分布式共识技术。传统的分布式技术中，由于本身的技术特点并不需要数据的一致性，更多的是数据的准确性，包括主从、Sharding技术等，但是在点对点网络中每个节点之间并没有依赖关系，所以就更需要数据一致性的机制。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">分布式系统的一致性算法是从上世纪70年代就开始研究的经典问题。理解分布式共识算法，需要理解下面两个名词，分别是“异步”和“共识”。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><strong><span style="font-size:14px;">异步：</span></strong><span style="font-size:14px;">此处的异步不同于通常技术术语中的异步调用的异步，而是指在一个分布式系统中，对消息的处理速度或者消息送达时间不做任何假设。此就是著名的FLP不可能性定理。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><strong><span style="font-size:14px;">共识：</span></strong><span style="font-size:14px;">当多个主机通过异步通讯方式组成网络集群时，这个网络默认是不可靠的，那么在这些不可靠主机之间复制状态需要采取一种机制，以保证每个主机的状态最终达成相同一致性状态，即取得共识。</span></p> 
  <p><br></p> 
  <p style="margin-left:28px;text-align:left;line-height:150%;"><span style="font-size:15px;line-height:150%;font-family:Wingdings;">Ø<span>&nbsp; </span></span><strong><span style="font-size:15px;line-height:150%;">CAP</span></strong><strong><span style="font-size:15px;line-height:150%;font-family:'宋体';">理论</span></strong></p> 
  <p><span style="font-size:14px;">CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p style="text-align:center;text-indent:32px;line-height:150%;"><span style="line-height:150%;"></span></p> 
  <p style="text-align:center;"><img style="width:393px;" src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/fcTCLwqsqxMyP7omDKPibz50FGTspOibh4iamydkWSaQgTm4DiclwmO9YcSNGS0GeCbrNMUia0qEBV8DfOulUbOWp1g/0" alt="0"></p> 
  <p style="text-align:center;text-indent:32px;line-height:150%;"><span style="line-height:150%;"></span><br></p> 
  <p style="text-align:center;text-indent:32px;line-height:150%;"><span style="font-size:12px;"><strong><span style="line-height:150%;font-family:'宋体';">图</span></strong><strong><span style="line-height:150%;">2-7 CAP</span></strong><strong><span style="line-height:150%;font-family:'宋体';">理论</span></strong></span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">这是由分布式系统本身的特性决定的，包括网络的异步性质、通信的不可靠性质等，所以在分布式系统设计中，需要对这三者进行选择，根据系统的设计需求进行考虑。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p style="margin-left:28px;text-align:left;line-height:150%;"><span style="line-height:150%;font-family:Wingdings;">Ø<span>&nbsp; </span></span><strong><span style="line-height:150%;font-family:'微软雅黑';">节点通信方式</span></strong></p> 
  <p><span style="font-size:14px;">在分布式系统中，节点的通信技术分为共享内存（Shared Memory）和消息传递（Messages Passing）两种方式。</span></p> 
  <p><span style="font-size:14px;">共享内存是指通信的多方在某个区域有公共的数据操作区域，解决了多方的数据交互问题，共享内存方式是多方直接通信比较直接和有效的方式，但是缺点也是比较明显的，就是公共的区域需要进行互斥操作，避免由于一方的操作影响到另一方的操作，所以在多方协同方面需要专门的设计。</span></p> 
  <p><span style="font-size:14px;">消息传递是指多方在通信方面直接借助消息包进行交互，这种消息包的传递可以是系统内的，也可以是系统外的；可以是文件型的，也可以是网络型的。消息的多方之间互相不影响，但是消息传递增加了分布式系统的设计难度。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p style="margin-left:28px;text-align:left;line-height:150%;"><span style="font-size:15px;line-height:150%;font-family:Wingdings;">Ø<span>&nbsp; </span></span><strong><span style="font-size:15px;line-height:150%;">Paxos</span></strong></p> 
  <p><span style="font-size:14px;">Paxos是最初、最简单的分布式共识算法，是Leslie Lamport（也是LaTeX的实现者）于1990年提出的一种基于消息传递的一致性算法，是通过节点之间来回两次实现状态复制。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">Paxos算法难以理解，更难以实现。</span></p> 
  <p><span style="font-size:14px;">Paxos相关的论文是The Part-Time Parliament&nbsp;，基于Paxos算法也产生了一些改进算法，例如Egalitarian Paxos、Fast Paxos、Multi-Paxos等。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p style="margin-left:28px;text-align:left;line-height:150%;"><span style="font-size:15px;line-height:150%;font-family:Wingdings;">Ø<span>&nbsp; </span></span><strong><span style="font-size:15px;line-height:150%;">Raft</span></strong></p> 
  <p><span style="font-size:14px;">Raft正是因为Paxos算法不容易理解和实现而提出的，Raft通过在系统中引入强势领导者来解决相互系统之间的协调问题，Raft是Paxos的简化版本。Paxos和Raft的区别在于选举的具体过程不同。</span></p> 
  <p><span style="font-size:14px;">在Raft中，任何时候一个服务器可以扮演下面角色之一：</span></p> 
  <p><span style="font-size:14px;">a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leader: 处理所有客户端交互、日志复制等，一般一次只有一个Leader；</span></p> 
  <p><span style="font-size:14px;">b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Follower: 类似选民，完全被动；</span></p> 
  <p><span style="font-size:14px;">c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。</span></p> 
  <p><span style="font-size:14px;">Raft阶段分为两个，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p style="margin-left:28px;text-align:left;line-height:150%;"><span style="font-size:15px;line-height:150%;font-family:Wingdings;">Ø<span>&nbsp; </span></span><strong><span style="font-size:15px;line-height:150%;">PBFT</span></strong></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">PBFT也称为拜占庭攻击容错算法。这里的拜占庭攻击，学术名称也称为主动型攻击，即它不是被动型攻击，不是简单的数据窃取和数据窃听，拜占庭攻击实现的是对消息的窃听，同时对消息进行恶意修改的目的。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">PBFT算法由Castro和Liskov于1999年提出，是第一个比较广泛的BFT算法，在PBFT算法中至多可以容忍不超过系统全部节点的数量的三分之一拜占庭节点，即如果有超过三分之二的正常节点，系统就可以正常运转。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">PBFT采取三阶段协议进行工作，包括pre-prepare、prepare和commit三个阶段。</span></p> 
  <p style="text-indent:32px;"><span style="font-family:'微软雅黑';"><br></span></p> 
  <p style="text-indent:32px;"><span style="font-family:'微软雅黑';"></span></p> 
  <p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/fcTCLwqsqxMyP7omDKPibz50FGTspOibh4EUR4sDxvebBpZVoFBH4thWlFNRh4iaiaBFG7udUibtHibZXVYWF5MkbX2w/0" alt="0"></p> 
  <p><strong style="text-align:center;text-indent:32px;"><span style="line-height:150%;font-family:'宋体';"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></strong><span style="font-size:12px;"><strong style="text-align:center;text-indent:32px;"><span style="line-height:150%;font-family:'宋体';">&nbsp; 图</span></strong><strong style="text-align:center;text-indent:32px;"><span style="line-height:150%;">2-8</span></strong></span></p> 
  <p style="text-align:center;text-indent:32px;line-height:150%;"><br></p> 
  <p style="text-align:center;text-indent:32px;line-height:150%;"><strong><span style="line-height:150%;">&nbsp;PBFT</span></strong><strong><span style="line-height:150%;font-family:'宋体';">三阶段</span></strong></p> 
  <p style="margin-left:28px;text-align:left;line-height:150%;"><span style="font-size:15px;line-height:150%;font-family:Wingdings;">Ø<span>&nbsp; </span></span><strong><span style="font-size:15px;line-height:150%;">POW</span></strong></p> 
  <p><span style="font-size:14px;">POW，全称为Proof of work，也即POW证明机制是基于工作量的，通过工作量的证明来实现系统的数据共识。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">POW机制在比特币系统出现之前已经有研究人员在使用，主要是用在<strong>防垃圾邮件</strong>方面。由于传统的邮件发送是没有任何成本的，这也导致了现在垃圾邮件的泛滥，通过工作量机制实现大量垃圾邮件发送的成本提升，也就有效的防止了垃圾邮件的大规模发送。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">在比特币系统中POW证明机制决定了系统数据共识的来源方，也就是比特币系统中区块链的记账方的争夺，只需要向系统证明节点能够快速提供相应的工作量，节点就有向区块链中写入数据的权利。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">POW证明机制基于的是数学上难以快速计算的问题，包括<strong>Hash碰撞问题、大数分解问题、椭圆曲线问题</strong>等。由于这些数学上“难”的问题没有计算的捷径，每个节点只能通过大量的穷举才能找到对应的答案，这是POW证明机制的优点，同时也是POW证明机制的缺点。由于POW是一种赢者通吃的模式，就容易导致系统中弱小的参与方只是陪练的角色，同时也浪费了系统大量的资源，是一种不“绿色”的机制。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p style="text-indent:32px;"><span style="font-size:14px;"><strong><span style="font-size:14px;background:rgb(254,254,254);">POW</span></strong><strong><span style="font-size:14px;font-family:'微软雅黑';background:rgb(254,254,254);">现在的主要实现系统是比特币系统和以太坊系统。</span></strong></span></p> 
  <p style="text-indent:32px;"><strong><span style="background:#FEFEFE;">&nbsp;</span></strong></p> 
  <p style="margin-left:28px;text-align:left;line-height:150%;"><span style="font-size:15px;line-height:150%;font-family:Wingdings;">Ø<span>&nbsp; </span></span><strong><span style="font-size:15px;line-height:150%;">POS</span></strong></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">POS，全称为Proof of Stake，由Quantum Mechanic于2011年在bitcointalk论坛上面提出。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">POS需要系统中运行一种代币，使用这种代币来表示系统中各个节点的权利，节点拥有更多的代币就拥有更多的发言权、更多的责任，同时也获得更多的收益。POS证明机制称为股权证明机制，黑客要攻击系统需要获得足够多的系统代币，这和算力无关，POS机制比POW机制环保，这是它的优点，同时也是它的缺点所在。&nbsp;</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">POS机制的权利是由代币天然固定在系统中，使得POS系统运行产生的区块成本比POW低，所以POS代币的内在价值没有POW凝聚的价值大，所以人们对POS产生的代币多少持不信任态度。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">POS机制一般和POW结合来使用，通过POS来控制POW工作量证明的难度，纯粹的POS机制实现比较困难。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><span style="font-size:14px;">POS目前主要在Peercoin和Nxt系统中实现，以太坊也计划转移到POS证明机制，称为Casper机制。另外还要有一些POS的变形，包括POS+POW以及DPOS等。</span></p> 
  <p><span style="font-size:14px;"><br></span></p> 
  <p><strong><span style="font-size:14px;">综合来看，以这些技术为基础，区块链实现了它去中心化的本质特征。通过非对称密码技术，实现了区块链的历史可信；通过点对点通信，实现了区块链网络的不可停止；通过共识机制，实现了区块链网络链条的唯一、数据的唯一，保障了系统的正常运行。</span></strong></p> 
  <p><br></p> 
  <p><strong><span style="font-size:14px;">FLP不可能性：（FLP Impossibility）是分布式领域中一个非常著名的定理。该定理的论文是由Fischer, Lynch and Patterson三位作者于1985年发表,之后该论文毫无疑问得获得了Dijkstra奖。FLP给出了一个令人吃惊的结论：在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！</span></strong><br></p> 
  <p><strong><span style="font-size:14px;"><br></span></strong></p> 
  <p><strong><span style="font-size:14px;"><br></span></strong></p> 
  <p style="text-align:center;">&nbsp;<strong style="font-size:14px;"><img style="width:67px;" src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/fcTCLwqsqxP7rDTEHTMSJB5icKb2QlnAeT5EBxNHnS2W4uBibFiaHWQBtsDro5cwDLqibn91Be6zxrP1e4O5TbCcQg/0" alt="0"></strong></p> 
  <p><img style="font-size:14px;text-align:center;" src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/fcTCLwqsqxOdj2x0wDhZLYlWYNNvdvzCNUuorxLmKvtsias5fQKKZia44hNT5KntrIrzicCIpFxvZNe9LIhExWKMg/640?wx_fmt=png" alt="640?wx_fmt=png"><br></p> 
  <p style="text-align:center;"><span style="font-size:14px;"><strong>转载／投稿请扫描以下二维码联系</strong></span></p> 
  <p style="text-align:center;"><span style="font-size:14px;"><strong><br></strong></span></p> 
  <p><span style="font-size:14px;"><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/fcTCLwqsqxOdj2x0wDhZLYlWYNNvdvzCObibrWJohwOD3xuQoicatFKuKxlMOWaq32AvwiabicYt7xpfKygiaTB1eOQ/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/dCtv1Y7qt8U/article/details/78085074,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/dCtv1Y7qt8U/article/details/78085074,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
