<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Hyperledger Fabric的PBFT源码分析（一） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Hyperledger Fabric的PBFT源码分析（一）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="一、PBFT的原理概述 1.算法公式: replicaCount &nbsp;int 变量定义在pbftCore结构体中 N (N在代码中对应replicaCount整型变量)是所有replicas的集合，每一个replica用一个整数来表示，如{ 0, 1, 2, 3,...N - 1 } N-1 = 3f -----&gt; f = N- 1/3 f 是最大可容忍的出错节点，也就是说准许错为1/3 2.图解PBFT执行过程 客户端发过来的请求其实是发给主replica，这里假设所得还没有选出主replica 这里大家估计也可以看出来图3和图4是一样的，其实这是一个互相确认的过程 客户端 Client----&gt;REQUEST---&gt;replicas 1. REQUEST携带 operation, timestamp，给每一个REQUEST加上时间戳，这样后来的REQUEST会有高于前面的时间戳 2.replicas会接收请求，如果他们验证了条请求，就会将它写入到自己的log中。在共识算法保证下每个replica完成对该请求的执行后直接将回复返回给client： 3.REPLY携带当前的view序号和时间戳，还有replica节点的编号，会返回执行结果 4.共识算法中有一个weak certificate，在这里，client也会等待weak certificate：即有f+1个replicas回复，并且它们的回复拥有相同的 t 和 r，由于至多有f个faulty replicas，所以确保了回复是合法的。我们叫这个weak certificate为 reply certificate。 5.处于active状态每一个replica会与每一个的client共享一份秘钥。 pre-prepare阶段 1.主节点收到来自Client的一条请求并分配了一个编号给这个请求，2.主节点会广播一条PRE-PREPARE信息给备份节点，3.这个PRE-PREPARE信息包含该请求的编号、所在的view和自身的一个digest。4.直到该信息送达到每一个备份节点，接下来就看收到信息的备份节点们同不同意5.主节点分配给该请求的这个编号n，即是否accept这条PRE-PREPARE信息， 6.如果一个备份节点accept了这条PRE-PREPARE，它就会进入下面的prepare阶段。 prepare阶段 1.备份节点进入prepared阶段后，广播一条PREPARE信息给主节点和其它的备份节点，直到PREPARE信息都抵达那三个节点。同时，该备份节点也会分别收到来自其它备份节点的PREPARE信息。 2.该备份节点将综合这些PREPARE信息做出自己对编号n的最终裁决。当这个备份节点开始综合比较来自其它两个备份节点的PREPARE信息和自身的PREPARE信息时，如果该备份节点发现其它两个节点都同意主节点分配的编号，又看了一下自己，自己也同意主节点的分配，a quorum certificate with the PRE-PREPARE and 2 f matching PREPARE messages for sequence number n, view v, and request m，如果一个replica达到了英文所说的条件，比如就是上面的斜体字描述的一种情况，那么我们就说该请求在这个replica上的状态是prepared，该replica就拥有了一个证书叫prepared certificate。那我们是不是就可以说至此排序工作已经完成，全网节点都达成了一个一致的请求序列呢，每一个replica开始照着这个序列执行吧。这是有漏洞的，设想一下，在t1时刻只有replica 1把请求m（编号为n）带到了prepared状态，其他两个备份节点replica 2， replica 3还没有来得及收集完来自其它节点的PREPARE信息进行判断，那么这时发生了view change进入到了一个新的view中，replica 1还认为给m分配的编号n已经得到了一个quorum同意，可以继续納入序列中，或者可以执行了，但对于replica 2来说，它来到了新的view中，它失去了对请求m的判断，甚至在上个view中它还有收集全其他节点发出的PREPARE信息，所以对于replica 2来说，给请求m分配的编号n将不作数，同理replica 3也是。那么replica 1一个人认为作数不足以让全网都认同，所以再新的view中，请求m的编号n将作废，需要重新发起提案。所以就有了下面的commit阶段。 &nbsp; &nbsp; &nbsp; &nbsp; 需要注意的是，该备份节点会将自己收到的PRE-PREPARE和发送的PREPARE信息记录到自己的log中。 &nbsp; &nbsp; &nbsp; &nbsp; 该备份节点发出PREPARE信息表示该节点同意主节点在view v中将编号n分配给请求m，不发即表示不同意。 &nbsp; &nbsp; &nbsp; &nbsp; 如果一个replica对请求m发出了PRE-PREPARE和PREPARE信息，那么我们就说该请求m在这个replica节点上处于pre-prepared状态。 Commit阶段 紧接着prepare阶段，当一个replica节点发现有一个quorum同意编号分配时，它就会广播一条COMMIT信息给其它所有节点告诉他们它有一个prepared certificate了。与此同时它也会陆续收到来自其它节点的COMMIT信息，如果它收到了2f+1条COMMIT（包括自身的一条，这些来自不同节点的COMMIT携带相同的编号n和view v），我们就说该节点拥有了一个叫committed certificate的证书，请求在这个节点上达到了committed状态。此时只通过这一个节点，我们就能断定该请求已经在一个quorum中到达了prepared状态，寄一个quorum的节点们都同意了编号n的分配。当请求m到达commited状态后，该请求就会被该节点执行。 由此观之核心代码执行的过程如下 二、共识算法代码解析 1.代码目录结构 // GetEngine returns initialized peer.Engine //============================================================================ //它初始化一个consenter和一个helper，并互相把一个句柄赋值给了对方。 //这样做的目的，就是为了可以让外部调用内部，内部可以调用外部 //============================================================================ func GetEngine(coord peer.MessageHandlerCoordinator) (peer.Engine, error) { &nbsp;&nbsp;&nbsp;&nbsp;var err error &nbsp;&nbsp;&nbsp;&nbsp;engineOnce.Do(func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine = new(EngineImpl) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.helper = NewHelper(coord) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.consenter = controller.NewConsenter(engine.helper) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.helper.setConsenter(engine.consenter) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.peerEndpoint, err = coord.GetPeerEndpoint() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.consensusFan = util.NewMessageFan() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Debug(&quot;Starting up message thread for consenter&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The channel never closes, so this should never break &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for msg := range engine.consensusFan.GetOutChannel() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.consenter.RecvMsg(msg.Msg, msg.Sender) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;return engine, err } //============================================================================== // NewConsenter constructs a Consenter object if not already present //============================================================================== //============================================================================== //调用controller获取一个plugin，当选择是pbft算法时，它会调用pbft.go 里的 //GetPlugin(c consensus.Stack)方法，在pbft.go里面把所有的外部参数读进算法内部 //============================================================================== func NewConsenter(stack consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;plugin := strings.ToLower(viper.GetString(&quot;peer.validator.consensus.plugin&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if plugin == &quot;pbft&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;Creating consensus plugin %s&quot;, plugin) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return pbft.GetPlugin(stack) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;logger.Info(&quot;Creating default consensus plugin (noops)&quot;) &nbsp;&nbsp;&nbsp;&nbsp;return noops.GetNoops(stack) } controller目录下是共识插件选择模块的函数 ----&gt;HyperLedger提供了两种算法PBFT和noops ----&gt;默认单节点情况下使用noops即相当于没有共识算法 func NewConsenter(stack consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;plugin := strings.ToLower(viper.GetString(&quot;peer.validator.consensus.plugin&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if plugin == &quot;pbft&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;Creating consensus plugin %s&quot;, plugin) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return pbft.GetPlugin(stack) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;logger.Info(&quot;Creating default consensus plugin (noops)&quot;) &nbsp;&nbsp;&nbsp;&nbsp;return noops.GetNoops(stack) } 函数中可以看出目前Hyperledger Fabric只支持PBFT和NOOPS executor和helper是两个相互依赖的模块 ----&gt;主要提供了共识算法和外部衔接的一块代码。主要负责事件处理的转接 helper ---&gt;这里面主要包含了对外部接口的一个调用，比如执行处理transaction，stateupdate，持久化一些对象等 noops&nbsp; ---&gt;noops相当于没有共识算法 pbft ---&gt; HyperLedger的默认共识算法 util&nbsp; ---&gt;交互需要的工具包，最主要的一个实现的功能就是它的消息机制。 func GetPlugin(c consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;if pluginInstance == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pluginInstance = New(c) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return pluginInstance } func New(stack consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;handle, _, _ := stack.GetNetworkHandles() &nbsp;&nbsp;&nbsp;&nbsp;id, _ := getValidatorID(handle) &nbsp;&nbsp;&nbsp;&nbsp;switch strings.ToLower(config.GetString(&quot;general.mode&quot;)) { &nbsp;&nbsp;&nbsp;&nbsp;case &quot;batch&quot;: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return newObcBatch(id, config, stack) &nbsp;&nbsp;&nbsp;&nbsp;default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Invalid PBFT mode: %s&quot;, config.GetString(&quot;general.mode&quot;))) &nbsp;&nbsp;&nbsp;&nbsp;} } //==============================================================================//在newobcbatch时，会初始化得到一个pbftcore的一个实例，这个是算法的核心模块。//并此时会启动一个batchTimer（这个batchTimer是一个计时器，//当batchTimer timeout后会触发一个sendbatch操作，这个只有primary节点才会去做）。//当然此时会创建一个事件处理机制，这个事件处理机制是各个模块沟通的一个bridge。//============================================================================== func newObcBatch(id uint64, config *viper.Viper, stack consensus.Stack) *obcBatch { &nbsp;&nbsp;&nbsp;&nbsp;var err error &nbsp;&nbsp;&nbsp;&nbsp;op := &amp;obcBatch{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obcGeneric: obcGeneric{stack: stack}, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;op.persistForward.persistor = stack &nbsp;&nbsp;&nbsp;&nbsp;logger.Debugf(&quot;Replica %d obtaining startup information&quot;, id) &nbsp;&nbsp;&nbsp;&nbsp;op.manager = events.NewManagerImpl() // TODO, this is hacky, eventually rip it out &nbsp;&nbsp;&nbsp;&nbsp;op.manager.SetReceiver(op) &nbsp;&nbsp;&nbsp;&nbsp;etf := events.NewTimerFactoryImpl(op.manager) &nbsp;&nbsp;&nbsp;&nbsp;op.pbft = newPbftCore(id, config, op, etf) &nbsp;&nbsp;&nbsp;&nbsp;op.manager.Start() &nbsp;&nbsp;&nbsp;&nbsp;blockchainInfoBlob := stack.GetBlockchainInfoBlob() &nbsp;&nbsp;&nbsp;&nbsp;op.externalEventReceiver.manager = op.manager &nbsp;&nbsp;&nbsp;&nbsp;op.broadcaster = newBroadcaster(id, op.pbft.N, op.pbft.f, op.pbft.broadcastTimeout, stack) &nbsp;&nbsp;&nbsp;&nbsp;op.manager.Queue() &lt;- workEvent(func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op.pbft.stateTransfer(&amp;stateUpdateTarget{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkpointMessage: checkpointMessage{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqNo: op.pbft.lastExec, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: blockchainInfoBlob, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;op.batchSize = config.GetInt(&quot;general.batchsize&quot;) &nbsp;&nbsp;&nbsp;&nbsp;op.batchStore = nil &nbsp;&nbsp;&nbsp;&nbsp;op.batchTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.batch&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse batch timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Batch size = %d&quot;, op.batchSize) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Batch timeout = %v&quot;, op.batchTimeout) &nbsp;&nbsp;&nbsp;&nbsp;if op.batchTimeout &gt;= op.pbft.requestTimeout { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op.pbft.requestTimeout = 3 * op.batchTimeout / 2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Warningf(&quot;Configured request timeout must be greater than batch timeout, setting to %v&quot;, op.pbft.requestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if op.pbft.requestTimeout &gt;= op.pbft.nullRequestTimeout &amp;&amp; op.pbft.nullRequestTimeout != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op.pbft.nullRequestTimeout = 3 * op.pbft.requestTimeout / 2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Warningf(&quot;Configured null request timeout must be greater than request timeout, setting to %v&quot;, op.pbft.nullRequestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;op.incomingChan = make(chan *batchMessage) &nbsp;&nbsp;&nbsp;&nbsp;op.batchTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;op.reqStore = newRequestStore() &nbsp;&nbsp;&nbsp;&nbsp;op.deduplicator = newDeduplicator() &nbsp;&nbsp;&nbsp;&nbsp;op.idleChan = make(chan struct{}) &nbsp;&nbsp;&nbsp;&nbsp;close(op.idleChan) // TODO remove eventually &nbsp;&nbsp;&nbsp;&nbsp;return op } func newPbftCore(id uint64, config *viper.Viper, consumer innerStack, etf events.TimerFactory) *pbftCore { &nbsp;&nbsp;&nbsp;&nbsp;var err error &nbsp;&nbsp;&nbsp;&nbsp;instance := &amp;pbftCore{} &nbsp;&nbsp;&nbsp;&nbsp;instance.id = id &nbsp;&nbsp;&nbsp;&nbsp;instance.consumer = consumer &nbsp;&nbsp;&nbsp;&nbsp;//============================================================================== &nbsp;&nbsp;&nbsp;&nbsp;// 4. 在初始化pbftcore时，在把所用配置读进的同时，创建了三个timer &nbsp;&nbsp;&nbsp;&nbsp;//============================================================================== &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;//newViewTimer对应于viewChangeTimerEvent{}，当这个timer在一定时间没有close时， &nbsp;&nbsp;&nbsp;&nbsp;//就会触发一个viewchange事件 &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;instance.newViewTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;//vcResendTimer对应viewChangeResendTimerEvent，发出viewchange过时时会 &nbsp;&nbsp;&nbsp;&nbsp;//触发一个将viewchange从新发送 &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;instance.vcResendTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;//nullRequestTimer对应nullRequestEvent，如果主节点长期没有发送preprepare消息， &nbsp;&nbsp;&nbsp;&nbsp;//也就是分配了seq的reqBatch。它timeout就认为主节点挂掉了然后发送viewchange消息 &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;instance.nullRequestTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;instance.N = config.GetInt(&quot;general.N&quot;) //网络中验证器的最大数量赋值 &nbsp;&nbsp;&nbsp;&nbsp;//==================================================================================// &nbsp;&nbsp;&nbsp;&nbsp;/*N是所有replicas的集合，每一个replica用一个整数来表示，依次为 &nbsp;&nbsp;&nbsp;&nbsp;{ 0, …, |N - 1 } &nbsp;&nbsp;&nbsp;&nbsp;简单起见，我们定义 &nbsp;&nbsp;&nbsp;&nbsp;|N = 3f + 1 &nbsp;&nbsp;&nbsp;&nbsp;f 是最大可容忍的faulty节点 &nbsp;&nbsp;&nbsp;&nbsp;另外我们将一个view中的primary节点定义为replica p， &nbsp;&nbsp;&nbsp;&nbsp;p = v mod |N &nbsp;&nbsp;&nbsp;&nbsp;v 是view的编号，从0开始一直连续下去，这样可以理解为从replica 0 到 replica |N-1 依次当primary节点，当每一次view change发生时。 &nbsp;&nbsp;&nbsp;&nbsp;*/ &nbsp;&nbsp;&nbsp;&nbsp;//==================================================================================// &nbsp;&nbsp;&nbsp;&nbsp;instance.f = config.GetInt(&quot;general.f&quot;) //默认的最大容错数量赋值 &nbsp;&nbsp;&nbsp;&nbsp;if instance.f*3+1 &gt; instance.N { //默认的最大容错数量大于网络中验证器的最大数量 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Sprintf(&quot;need at least %d enough replicas to tolerate %d byzantine faults, but only %d replicas configured&quot;, instance.f*3+1, instance.f, instance.N)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;instance.K = uint64(config.GetInt(&quot;general.K&quot;)) //检查点时间段赋值 &nbsp;&nbsp;&nbsp;&nbsp;//计算日志的大小值赋值,日志倍增器 &nbsp;&nbsp;&nbsp;&nbsp;instance.logMultiplier = uint64(config.GetInt(&quot;general.logmultiplier&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if instance.logMultiplier &lt; 2 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;Log multiplier must be greater than or equal to 2&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//日志大小计算 &nbsp;&nbsp;&nbsp;&nbsp;instance.L = instance.logMultiplier * instance.K // 日志大小 &nbsp;&nbsp;&nbsp;&nbsp;//自动视图改变的时间段 &nbsp;&nbsp;&nbsp;&nbsp;instance.viewChangePeriod = uint64(config.GetInt(&quot;general.viewchangeperiod&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;//这个节点是否故意充当拜占庭;testnet用于调试 &nbsp;&nbsp;&nbsp;&nbsp;instance.byzantine = config.GetBool(&quot;general.byzantine&quot;) &nbsp;&nbsp;&nbsp;&nbsp;//请求过程超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.requestTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.request&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse request timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//重发视图改变之前超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.vcResendTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.resendviewchange&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse request timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//新的视图超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.newViewTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.viewchange&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse new view timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//超时持续 &nbsp;&nbsp;&nbsp;&nbsp;instance.nullRequestTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.nullrequest&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.nullRequestTimeout = 0 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//广播过程超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.broadcastTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.broadcast&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse new broadcast timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//查看view发生 &nbsp;&nbsp;&nbsp;&nbsp;instance.activeView = true &nbsp;&nbsp;&nbsp;&nbsp;//replicas的数量; PBFT `|R|` &nbsp;&nbsp;&nbsp;&nbsp;instance.replicaCount = instance.N &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT type = %T&quot;, instance.consumer) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Max number of validating peers (N) = %v&quot;, instance.N) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Max number of failing peers (f) = %v&quot;, instance.f) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT byzantine flag = %v&quot;, instance.byzantine) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT request timeout = %v&quot;, instance.requestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT view change timeout = %v&quot;, instance.newViewTimeout) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Checkpoint period (K) = %v&quot;, instance.K) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT broadcast timeout = %v&quot;, instance.broadcastTimeout) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Log multiplier = %v&quot;, instance.logMultiplier) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT log size (L) = %v&quot;, instance.L) &nbsp;&nbsp;&nbsp;&nbsp;//超时持续 &nbsp;&nbsp;&nbsp;&nbsp;if instance.nullRequestTimeout &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT null requests timeout = %v&quot;, instance.nullRequestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT null requests disabled&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//在自动视图改变的时间段 &nbsp;&nbsp;&nbsp;&nbsp;if instance.viewChangePeriod &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT view change period = %v&quot;, instance.viewChangePeriod) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT automatic view change disabled&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// init the logs &nbsp;&nbsp;&nbsp;&nbsp;//跟踪法定证书请求 &nbsp;&nbsp;&nbsp;&nbsp;instance.certStore = make(map[msgID]*msgCert) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪请求批次 &nbsp;&nbsp;&nbsp;&nbsp;instance.reqBatchStore = make(map[string]*RequestBatch) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪检查点设置 &nbsp;&nbsp;&nbsp;&nbsp;instance.checkpointStore = make(map[Checkpoint]bool) &nbsp;&nbsp;&nbsp;&nbsp;//检查点状态; 映射lastExec到全局hash &nbsp;&nbsp;&nbsp;&nbsp;instance.chkpts = make(map[uint64]string) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪视view change消息 &nbsp;&nbsp;&nbsp;&nbsp;instance.viewChangeStore = make(map[vcidx]*ViewChange) &nbsp;&nbsp;&nbsp;&nbsp;instance.pset = make(map[uint64]*ViewChange_PQ) &nbsp;&nbsp;&nbsp;&nbsp;instance.qset = make(map[qidx]*ViewChange_PQ) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪我们接收后者发送的最后一个新视图 &nbsp;&nbsp;&nbsp;&nbsp;instance.newViewStore = make(map[uint64]*NewView) &nbsp;&nbsp;&nbsp;&nbsp;// initialize state transfer &nbsp;&nbsp;&nbsp;&nbsp;//观察每一个replica最高薄弱点序列数 &nbsp;&nbsp;&nbsp;&nbsp;instance.hChkpts = make(map[uint64]uint64) &nbsp;&nbsp;&nbsp;&nbsp;//检查点状态; 映射lastExec到全局hash &nbsp;&nbsp;&nbsp;&nbsp;instance.chkpts[0] = &quot;XXX GENESIS&quot; &nbsp;&nbsp;&nbsp;&nbsp;// 在我们使用视图改变期间最后超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.lastNewViewTimeout = instance.newViewTimeout &nbsp;&nbsp;&nbsp;&nbsp;//跟踪我们是否正在等待请求批处理执行 &nbsp;&nbsp;&nbsp;&nbsp;instance.outstandingReqBatches = make(map[string]*RequestBatch) &nbsp;&nbsp;&nbsp;&nbsp;//对于所有已经分配我们可能错过的在视图改变期间的非检查点的请求批次 &nbsp;&nbsp;&nbsp;&nbsp;instance.missingReqBatches = make(map[string]bool) &nbsp;&nbsp;&nbsp;&nbsp;//将变量的值恢复到初始状态 &nbsp;&nbsp;&nbsp;&nbsp;instance.restoreState() &nbsp;&nbsp;&nbsp;&nbsp;// 执行视图改变的下一个序号 &nbsp;&nbsp;&nbsp;&nbsp;instance.viewChangeSeqNo = ^uint64(0) // infinity &nbsp;&nbsp;&nbsp;&nbsp;//更新视图改变序列号 &nbsp;&nbsp;&nbsp;&nbsp;instance.updateViewChangeSeqNo() &nbsp;&nbsp;&nbsp;&nbsp;return instance } 代码走到newPbftCore的过程，等待下周更新........... 阅读更多" />
<meta property="og:description" content="一、PBFT的原理概述 1.算法公式: replicaCount &nbsp;int 变量定义在pbftCore结构体中 N (N在代码中对应replicaCount整型变量)是所有replicas的集合，每一个replica用一个整数来表示，如{ 0, 1, 2, 3,...N - 1 } N-1 = 3f -----&gt; f = N- 1/3 f 是最大可容忍的出错节点，也就是说准许错为1/3 2.图解PBFT执行过程 客户端发过来的请求其实是发给主replica，这里假设所得还没有选出主replica 这里大家估计也可以看出来图3和图4是一样的，其实这是一个互相确认的过程 客户端 Client----&gt;REQUEST---&gt;replicas 1. REQUEST携带 operation, timestamp，给每一个REQUEST加上时间戳，这样后来的REQUEST会有高于前面的时间戳 2.replicas会接收请求，如果他们验证了条请求，就会将它写入到自己的log中。在共识算法保证下每个replica完成对该请求的执行后直接将回复返回给client： 3.REPLY携带当前的view序号和时间戳，还有replica节点的编号，会返回执行结果 4.共识算法中有一个weak certificate，在这里，client也会等待weak certificate：即有f+1个replicas回复，并且它们的回复拥有相同的 t 和 r，由于至多有f个faulty replicas，所以确保了回复是合法的。我们叫这个weak certificate为 reply certificate。 5.处于active状态每一个replica会与每一个的client共享一份秘钥。 pre-prepare阶段 1.主节点收到来自Client的一条请求并分配了一个编号给这个请求，2.主节点会广播一条PRE-PREPARE信息给备份节点，3.这个PRE-PREPARE信息包含该请求的编号、所在的view和自身的一个digest。4.直到该信息送达到每一个备份节点，接下来就看收到信息的备份节点们同不同意5.主节点分配给该请求的这个编号n，即是否accept这条PRE-PREPARE信息， 6.如果一个备份节点accept了这条PRE-PREPARE，它就会进入下面的prepare阶段。 prepare阶段 1.备份节点进入prepared阶段后，广播一条PREPARE信息给主节点和其它的备份节点，直到PREPARE信息都抵达那三个节点。同时，该备份节点也会分别收到来自其它备份节点的PREPARE信息。 2.该备份节点将综合这些PREPARE信息做出自己对编号n的最终裁决。当这个备份节点开始综合比较来自其它两个备份节点的PREPARE信息和自身的PREPARE信息时，如果该备份节点发现其它两个节点都同意主节点分配的编号，又看了一下自己，自己也同意主节点的分配，a quorum certificate with the PRE-PREPARE and 2 f matching PREPARE messages for sequence number n, view v, and request m，如果一个replica达到了英文所说的条件，比如就是上面的斜体字描述的一种情况，那么我们就说该请求在这个replica上的状态是prepared，该replica就拥有了一个证书叫prepared certificate。那我们是不是就可以说至此排序工作已经完成，全网节点都达成了一个一致的请求序列呢，每一个replica开始照着这个序列执行吧。这是有漏洞的，设想一下，在t1时刻只有replica 1把请求m（编号为n）带到了prepared状态，其他两个备份节点replica 2， replica 3还没有来得及收集完来自其它节点的PREPARE信息进行判断，那么这时发生了view change进入到了一个新的view中，replica 1还认为给m分配的编号n已经得到了一个quorum同意，可以继续納入序列中，或者可以执行了，但对于replica 2来说，它来到了新的view中，它失去了对请求m的判断，甚至在上个view中它还有收集全其他节点发出的PREPARE信息，所以对于replica 2来说，给请求m分配的编号n将不作数，同理replica 3也是。那么replica 1一个人认为作数不足以让全网都认同，所以再新的view中，请求m的编号n将作废，需要重新发起提案。所以就有了下面的commit阶段。 &nbsp; &nbsp; &nbsp; &nbsp; 需要注意的是，该备份节点会将自己收到的PRE-PREPARE和发送的PREPARE信息记录到自己的log中。 &nbsp; &nbsp; &nbsp; &nbsp; 该备份节点发出PREPARE信息表示该节点同意主节点在view v中将编号n分配给请求m，不发即表示不同意。 &nbsp; &nbsp; &nbsp; &nbsp; 如果一个replica对请求m发出了PRE-PREPARE和PREPARE信息，那么我们就说该请求m在这个replica节点上处于pre-prepared状态。 Commit阶段 紧接着prepare阶段，当一个replica节点发现有一个quorum同意编号分配时，它就会广播一条COMMIT信息给其它所有节点告诉他们它有一个prepared certificate了。与此同时它也会陆续收到来自其它节点的COMMIT信息，如果它收到了2f+1条COMMIT（包括自身的一条，这些来自不同节点的COMMIT携带相同的编号n和view v），我们就说该节点拥有了一个叫committed certificate的证书，请求在这个节点上达到了committed状态。此时只通过这一个节点，我们就能断定该请求已经在一个quorum中到达了prepared状态，寄一个quorum的节点们都同意了编号n的分配。当请求m到达commited状态后，该请求就会被该节点执行。 由此观之核心代码执行的过程如下 二、共识算法代码解析 1.代码目录结构 // GetEngine returns initialized peer.Engine //============================================================================ //它初始化一个consenter和一个helper，并互相把一个句柄赋值给了对方。 //这样做的目的，就是为了可以让外部调用内部，内部可以调用外部 //============================================================================ func GetEngine(coord peer.MessageHandlerCoordinator) (peer.Engine, error) { &nbsp;&nbsp;&nbsp;&nbsp;var err error &nbsp;&nbsp;&nbsp;&nbsp;engineOnce.Do(func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine = new(EngineImpl) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.helper = NewHelper(coord) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.consenter = controller.NewConsenter(engine.helper) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.helper.setConsenter(engine.consenter) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.peerEndpoint, err = coord.GetPeerEndpoint() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.consensusFan = util.NewMessageFan() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Debug(&quot;Starting up message thread for consenter&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The channel never closes, so this should never break &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for msg := range engine.consensusFan.GetOutChannel() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.consenter.RecvMsg(msg.Msg, msg.Sender) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;return engine, err } //============================================================================== // NewConsenter constructs a Consenter object if not already present //============================================================================== //============================================================================== //调用controller获取一个plugin，当选择是pbft算法时，它会调用pbft.go 里的 //GetPlugin(c consensus.Stack)方法，在pbft.go里面把所有的外部参数读进算法内部 //============================================================================== func NewConsenter(stack consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;plugin := strings.ToLower(viper.GetString(&quot;peer.validator.consensus.plugin&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if plugin == &quot;pbft&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;Creating consensus plugin %s&quot;, plugin) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return pbft.GetPlugin(stack) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;logger.Info(&quot;Creating default consensus plugin (noops)&quot;) &nbsp;&nbsp;&nbsp;&nbsp;return noops.GetNoops(stack) } controller目录下是共识插件选择模块的函数 ----&gt;HyperLedger提供了两种算法PBFT和noops ----&gt;默认单节点情况下使用noops即相当于没有共识算法 func NewConsenter(stack consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;plugin := strings.ToLower(viper.GetString(&quot;peer.validator.consensus.plugin&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if plugin == &quot;pbft&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;Creating consensus plugin %s&quot;, plugin) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return pbft.GetPlugin(stack) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;logger.Info(&quot;Creating default consensus plugin (noops)&quot;) &nbsp;&nbsp;&nbsp;&nbsp;return noops.GetNoops(stack) } 函数中可以看出目前Hyperledger Fabric只支持PBFT和NOOPS executor和helper是两个相互依赖的模块 ----&gt;主要提供了共识算法和外部衔接的一块代码。主要负责事件处理的转接 helper ---&gt;这里面主要包含了对外部接口的一个调用，比如执行处理transaction，stateupdate，持久化一些对象等 noops&nbsp; ---&gt;noops相当于没有共识算法 pbft ---&gt; HyperLedger的默认共识算法 util&nbsp; ---&gt;交互需要的工具包，最主要的一个实现的功能就是它的消息机制。 func GetPlugin(c consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;if pluginInstance == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pluginInstance = New(c) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return pluginInstance } func New(stack consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;handle, _, _ := stack.GetNetworkHandles() &nbsp;&nbsp;&nbsp;&nbsp;id, _ := getValidatorID(handle) &nbsp;&nbsp;&nbsp;&nbsp;switch strings.ToLower(config.GetString(&quot;general.mode&quot;)) { &nbsp;&nbsp;&nbsp;&nbsp;case &quot;batch&quot;: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return newObcBatch(id, config, stack) &nbsp;&nbsp;&nbsp;&nbsp;default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Invalid PBFT mode: %s&quot;, config.GetString(&quot;general.mode&quot;))) &nbsp;&nbsp;&nbsp;&nbsp;} } //==============================================================================//在newobcbatch时，会初始化得到一个pbftcore的一个实例，这个是算法的核心模块。//并此时会启动一个batchTimer（这个batchTimer是一个计时器，//当batchTimer timeout后会触发一个sendbatch操作，这个只有primary节点才会去做）。//当然此时会创建一个事件处理机制，这个事件处理机制是各个模块沟通的一个bridge。//============================================================================== func newObcBatch(id uint64, config *viper.Viper, stack consensus.Stack) *obcBatch { &nbsp;&nbsp;&nbsp;&nbsp;var err error &nbsp;&nbsp;&nbsp;&nbsp;op := &amp;obcBatch{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obcGeneric: obcGeneric{stack: stack}, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;op.persistForward.persistor = stack &nbsp;&nbsp;&nbsp;&nbsp;logger.Debugf(&quot;Replica %d obtaining startup information&quot;, id) &nbsp;&nbsp;&nbsp;&nbsp;op.manager = events.NewManagerImpl() // TODO, this is hacky, eventually rip it out &nbsp;&nbsp;&nbsp;&nbsp;op.manager.SetReceiver(op) &nbsp;&nbsp;&nbsp;&nbsp;etf := events.NewTimerFactoryImpl(op.manager) &nbsp;&nbsp;&nbsp;&nbsp;op.pbft = newPbftCore(id, config, op, etf) &nbsp;&nbsp;&nbsp;&nbsp;op.manager.Start() &nbsp;&nbsp;&nbsp;&nbsp;blockchainInfoBlob := stack.GetBlockchainInfoBlob() &nbsp;&nbsp;&nbsp;&nbsp;op.externalEventReceiver.manager = op.manager &nbsp;&nbsp;&nbsp;&nbsp;op.broadcaster = newBroadcaster(id, op.pbft.N, op.pbft.f, op.pbft.broadcastTimeout, stack) &nbsp;&nbsp;&nbsp;&nbsp;op.manager.Queue() &lt;- workEvent(func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op.pbft.stateTransfer(&amp;stateUpdateTarget{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkpointMessage: checkpointMessage{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqNo: op.pbft.lastExec, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: blockchainInfoBlob, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;op.batchSize = config.GetInt(&quot;general.batchsize&quot;) &nbsp;&nbsp;&nbsp;&nbsp;op.batchStore = nil &nbsp;&nbsp;&nbsp;&nbsp;op.batchTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.batch&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse batch timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Batch size = %d&quot;, op.batchSize) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Batch timeout = %v&quot;, op.batchTimeout) &nbsp;&nbsp;&nbsp;&nbsp;if op.batchTimeout &gt;= op.pbft.requestTimeout { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op.pbft.requestTimeout = 3 * op.batchTimeout / 2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Warningf(&quot;Configured request timeout must be greater than batch timeout, setting to %v&quot;, op.pbft.requestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if op.pbft.requestTimeout &gt;= op.pbft.nullRequestTimeout &amp;&amp; op.pbft.nullRequestTimeout != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op.pbft.nullRequestTimeout = 3 * op.pbft.requestTimeout / 2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Warningf(&quot;Configured null request timeout must be greater than request timeout, setting to %v&quot;, op.pbft.nullRequestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;op.incomingChan = make(chan *batchMessage) &nbsp;&nbsp;&nbsp;&nbsp;op.batchTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;op.reqStore = newRequestStore() &nbsp;&nbsp;&nbsp;&nbsp;op.deduplicator = newDeduplicator() &nbsp;&nbsp;&nbsp;&nbsp;op.idleChan = make(chan struct{}) &nbsp;&nbsp;&nbsp;&nbsp;close(op.idleChan) // TODO remove eventually &nbsp;&nbsp;&nbsp;&nbsp;return op } func newPbftCore(id uint64, config *viper.Viper, consumer innerStack, etf events.TimerFactory) *pbftCore { &nbsp;&nbsp;&nbsp;&nbsp;var err error &nbsp;&nbsp;&nbsp;&nbsp;instance := &amp;pbftCore{} &nbsp;&nbsp;&nbsp;&nbsp;instance.id = id &nbsp;&nbsp;&nbsp;&nbsp;instance.consumer = consumer &nbsp;&nbsp;&nbsp;&nbsp;//============================================================================== &nbsp;&nbsp;&nbsp;&nbsp;// 4. 在初始化pbftcore时，在把所用配置读进的同时，创建了三个timer &nbsp;&nbsp;&nbsp;&nbsp;//============================================================================== &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;//newViewTimer对应于viewChangeTimerEvent{}，当这个timer在一定时间没有close时， &nbsp;&nbsp;&nbsp;&nbsp;//就会触发一个viewchange事件 &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;instance.newViewTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;//vcResendTimer对应viewChangeResendTimerEvent，发出viewchange过时时会 &nbsp;&nbsp;&nbsp;&nbsp;//触发一个将viewchange从新发送 &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;instance.vcResendTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;//nullRequestTimer对应nullRequestEvent，如果主节点长期没有发送preprepare消息， &nbsp;&nbsp;&nbsp;&nbsp;//也就是分配了seq的reqBatch。它timeout就认为主节点挂掉了然后发送viewchange消息 &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;instance.nullRequestTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;instance.N = config.GetInt(&quot;general.N&quot;) //网络中验证器的最大数量赋值 &nbsp;&nbsp;&nbsp;&nbsp;//==================================================================================// &nbsp;&nbsp;&nbsp;&nbsp;/*N是所有replicas的集合，每一个replica用一个整数来表示，依次为 &nbsp;&nbsp;&nbsp;&nbsp;{ 0, …, |N - 1 } &nbsp;&nbsp;&nbsp;&nbsp;简单起见，我们定义 &nbsp;&nbsp;&nbsp;&nbsp;|N = 3f + 1 &nbsp;&nbsp;&nbsp;&nbsp;f 是最大可容忍的faulty节点 &nbsp;&nbsp;&nbsp;&nbsp;另外我们将一个view中的primary节点定义为replica p， &nbsp;&nbsp;&nbsp;&nbsp;p = v mod |N &nbsp;&nbsp;&nbsp;&nbsp;v 是view的编号，从0开始一直连续下去，这样可以理解为从replica 0 到 replica |N-1 依次当primary节点，当每一次view change发生时。 &nbsp;&nbsp;&nbsp;&nbsp;*/ &nbsp;&nbsp;&nbsp;&nbsp;//==================================================================================// &nbsp;&nbsp;&nbsp;&nbsp;instance.f = config.GetInt(&quot;general.f&quot;) //默认的最大容错数量赋值 &nbsp;&nbsp;&nbsp;&nbsp;if instance.f*3+1 &gt; instance.N { //默认的最大容错数量大于网络中验证器的最大数量 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Sprintf(&quot;need at least %d enough replicas to tolerate %d byzantine faults, but only %d replicas configured&quot;, instance.f*3+1, instance.f, instance.N)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;instance.K = uint64(config.GetInt(&quot;general.K&quot;)) //检查点时间段赋值 &nbsp;&nbsp;&nbsp;&nbsp;//计算日志的大小值赋值,日志倍增器 &nbsp;&nbsp;&nbsp;&nbsp;instance.logMultiplier = uint64(config.GetInt(&quot;general.logmultiplier&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if instance.logMultiplier &lt; 2 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;Log multiplier must be greater than or equal to 2&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//日志大小计算 &nbsp;&nbsp;&nbsp;&nbsp;instance.L = instance.logMultiplier * instance.K // 日志大小 &nbsp;&nbsp;&nbsp;&nbsp;//自动视图改变的时间段 &nbsp;&nbsp;&nbsp;&nbsp;instance.viewChangePeriod = uint64(config.GetInt(&quot;general.viewchangeperiod&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;//这个节点是否故意充当拜占庭;testnet用于调试 &nbsp;&nbsp;&nbsp;&nbsp;instance.byzantine = config.GetBool(&quot;general.byzantine&quot;) &nbsp;&nbsp;&nbsp;&nbsp;//请求过程超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.requestTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.request&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse request timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//重发视图改变之前超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.vcResendTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.resendviewchange&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse request timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//新的视图超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.newViewTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.viewchange&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse new view timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//超时持续 &nbsp;&nbsp;&nbsp;&nbsp;instance.nullRequestTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.nullrequest&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.nullRequestTimeout = 0 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//广播过程超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.broadcastTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.broadcast&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse new broadcast timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//查看view发生 &nbsp;&nbsp;&nbsp;&nbsp;instance.activeView = true &nbsp;&nbsp;&nbsp;&nbsp;//replicas的数量; PBFT `|R|` &nbsp;&nbsp;&nbsp;&nbsp;instance.replicaCount = instance.N &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT type = %T&quot;, instance.consumer) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Max number of validating peers (N) = %v&quot;, instance.N) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Max number of failing peers (f) = %v&quot;, instance.f) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT byzantine flag = %v&quot;, instance.byzantine) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT request timeout = %v&quot;, instance.requestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT view change timeout = %v&quot;, instance.newViewTimeout) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Checkpoint period (K) = %v&quot;, instance.K) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT broadcast timeout = %v&quot;, instance.broadcastTimeout) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Log multiplier = %v&quot;, instance.logMultiplier) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT log size (L) = %v&quot;, instance.L) &nbsp;&nbsp;&nbsp;&nbsp;//超时持续 &nbsp;&nbsp;&nbsp;&nbsp;if instance.nullRequestTimeout &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT null requests timeout = %v&quot;, instance.nullRequestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT null requests disabled&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//在自动视图改变的时间段 &nbsp;&nbsp;&nbsp;&nbsp;if instance.viewChangePeriod &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT view change period = %v&quot;, instance.viewChangePeriod) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT automatic view change disabled&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// init the logs &nbsp;&nbsp;&nbsp;&nbsp;//跟踪法定证书请求 &nbsp;&nbsp;&nbsp;&nbsp;instance.certStore = make(map[msgID]*msgCert) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪请求批次 &nbsp;&nbsp;&nbsp;&nbsp;instance.reqBatchStore = make(map[string]*RequestBatch) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪检查点设置 &nbsp;&nbsp;&nbsp;&nbsp;instance.checkpointStore = make(map[Checkpoint]bool) &nbsp;&nbsp;&nbsp;&nbsp;//检查点状态; 映射lastExec到全局hash &nbsp;&nbsp;&nbsp;&nbsp;instance.chkpts = make(map[uint64]string) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪视view change消息 &nbsp;&nbsp;&nbsp;&nbsp;instance.viewChangeStore = make(map[vcidx]*ViewChange) &nbsp;&nbsp;&nbsp;&nbsp;instance.pset = make(map[uint64]*ViewChange_PQ) &nbsp;&nbsp;&nbsp;&nbsp;instance.qset = make(map[qidx]*ViewChange_PQ) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪我们接收后者发送的最后一个新视图 &nbsp;&nbsp;&nbsp;&nbsp;instance.newViewStore = make(map[uint64]*NewView) &nbsp;&nbsp;&nbsp;&nbsp;// initialize state transfer &nbsp;&nbsp;&nbsp;&nbsp;//观察每一个replica最高薄弱点序列数 &nbsp;&nbsp;&nbsp;&nbsp;instance.hChkpts = make(map[uint64]uint64) &nbsp;&nbsp;&nbsp;&nbsp;//检查点状态; 映射lastExec到全局hash &nbsp;&nbsp;&nbsp;&nbsp;instance.chkpts[0] = &quot;XXX GENESIS&quot; &nbsp;&nbsp;&nbsp;&nbsp;// 在我们使用视图改变期间最后超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.lastNewViewTimeout = instance.newViewTimeout &nbsp;&nbsp;&nbsp;&nbsp;//跟踪我们是否正在等待请求批处理执行 &nbsp;&nbsp;&nbsp;&nbsp;instance.outstandingReqBatches = make(map[string]*RequestBatch) &nbsp;&nbsp;&nbsp;&nbsp;//对于所有已经分配我们可能错过的在视图改变期间的非检查点的请求批次 &nbsp;&nbsp;&nbsp;&nbsp;instance.missingReqBatches = make(map[string]bool) &nbsp;&nbsp;&nbsp;&nbsp;//将变量的值恢复到初始状态 &nbsp;&nbsp;&nbsp;&nbsp;instance.restoreState() &nbsp;&nbsp;&nbsp;&nbsp;// 执行视图改变的下一个序号 &nbsp;&nbsp;&nbsp;&nbsp;instance.viewChangeSeqNo = ^uint64(0) // infinity &nbsp;&nbsp;&nbsp;&nbsp;//更新视图改变序列号 &nbsp;&nbsp;&nbsp;&nbsp;instance.updateViewChangeSeqNo() &nbsp;&nbsp;&nbsp;&nbsp;return instance } 代码走到newPbftCore的过程，等待下周更新........... 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-12-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"一、PBFT的原理概述 1.算法公式: replicaCount &nbsp;int 变量定义在pbftCore结构体中 N (N在代码中对应replicaCount整型变量)是所有replicas的集合，每一个replica用一个整数来表示，如{ 0, 1, 2, 3,...N - 1 } N-1 = 3f -----&gt; f = N- 1/3 f 是最大可容忍的出错节点，也就是说准许错为1/3 2.图解PBFT执行过程 客户端发过来的请求其实是发给主replica，这里假设所得还没有选出主replica 这里大家估计也可以看出来图3和图4是一样的，其实这是一个互相确认的过程 客户端 Client----&gt;REQUEST---&gt;replicas 1. REQUEST携带 operation, timestamp，给每一个REQUEST加上时间戳，这样后来的REQUEST会有高于前面的时间戳 2.replicas会接收请求，如果他们验证了条请求，就会将它写入到自己的log中。在共识算法保证下每个replica完成对该请求的执行后直接将回复返回给client： 3.REPLY携带当前的view序号和时间戳，还有replica节点的编号，会返回执行结果 4.共识算法中有一个weak certificate，在这里，client也会等待weak certificate：即有f+1个replicas回复，并且它们的回复拥有相同的 t 和 r，由于至多有f个faulty replicas，所以确保了回复是合法的。我们叫这个weak certificate为 reply certificate。 5.处于active状态每一个replica会与每一个的client共享一份秘钥。 pre-prepare阶段 1.主节点收到来自Client的一条请求并分配了一个编号给这个请求，2.主节点会广播一条PRE-PREPARE信息给备份节点，3.这个PRE-PREPARE信息包含该请求的编号、所在的view和自身的一个digest。4.直到该信息送达到每一个备份节点，接下来就看收到信息的备份节点们同不同意5.主节点分配给该请求的这个编号n，即是否accept这条PRE-PREPARE信息， 6.如果一个备份节点accept了这条PRE-PREPARE，它就会进入下面的prepare阶段。 prepare阶段 1.备份节点进入prepared阶段后，广播一条PREPARE信息给主节点和其它的备份节点，直到PREPARE信息都抵达那三个节点。同时，该备份节点也会分别收到来自其它备份节点的PREPARE信息。 2.该备份节点将综合这些PREPARE信息做出自己对编号n的最终裁决。当这个备份节点开始综合比较来自其它两个备份节点的PREPARE信息和自身的PREPARE信息时，如果该备份节点发现其它两个节点都同意主节点分配的编号，又看了一下自己，自己也同意主节点的分配，a quorum certificate with the PRE-PREPARE and 2 f matching PREPARE messages for sequence number n, view v, and request m，如果一个replica达到了英文所说的条件，比如就是上面的斜体字描述的一种情况，那么我们就说该请求在这个replica上的状态是prepared，该replica就拥有了一个证书叫prepared certificate。那我们是不是就可以说至此排序工作已经完成，全网节点都达成了一个一致的请求序列呢，每一个replica开始照着这个序列执行吧。这是有漏洞的，设想一下，在t1时刻只有replica 1把请求m（编号为n）带到了prepared状态，其他两个备份节点replica 2， replica 3还没有来得及收集完来自其它节点的PREPARE信息进行判断，那么这时发生了view change进入到了一个新的view中，replica 1还认为给m分配的编号n已经得到了一个quorum同意，可以继续納入序列中，或者可以执行了，但对于replica 2来说，它来到了新的view中，它失去了对请求m的判断，甚至在上个view中它还有收集全其他节点发出的PREPARE信息，所以对于replica 2来说，给请求m分配的编号n将不作数，同理replica 3也是。那么replica 1一个人认为作数不足以让全网都认同，所以再新的view中，请求m的编号n将作废，需要重新发起提案。所以就有了下面的commit阶段。 &nbsp; &nbsp; &nbsp; &nbsp; 需要注意的是，该备份节点会将自己收到的PRE-PREPARE和发送的PREPARE信息记录到自己的log中。 &nbsp; &nbsp; &nbsp; &nbsp; 该备份节点发出PREPARE信息表示该节点同意主节点在view v中将编号n分配给请求m，不发即表示不同意。 &nbsp; &nbsp; &nbsp; &nbsp; 如果一个replica对请求m发出了PRE-PREPARE和PREPARE信息，那么我们就说该请求m在这个replica节点上处于pre-prepared状态。 Commit阶段 紧接着prepare阶段，当一个replica节点发现有一个quorum同意编号分配时，它就会广播一条COMMIT信息给其它所有节点告诉他们它有一个prepared certificate了。与此同时它也会陆续收到来自其它节点的COMMIT信息，如果它收到了2f+1条COMMIT（包括自身的一条，这些来自不同节点的COMMIT携带相同的编号n和view v），我们就说该节点拥有了一个叫committed certificate的证书，请求在这个节点上达到了committed状态。此时只通过这一个节点，我们就能断定该请求已经在一个quorum中到达了prepared状态，寄一个quorum的节点们都同意了编号n的分配。当请求m到达commited状态后，该请求就会被该节点执行。 由此观之核心代码执行的过程如下 二、共识算法代码解析 1.代码目录结构 // GetEngine returns initialized peer.Engine //============================================================================ //它初始化一个consenter和一个helper，并互相把一个句柄赋值给了对方。 //这样做的目的，就是为了可以让外部调用内部，内部可以调用外部 //============================================================================ func GetEngine(coord peer.MessageHandlerCoordinator) (peer.Engine, error) { &nbsp;&nbsp;&nbsp;&nbsp;var err error &nbsp;&nbsp;&nbsp;&nbsp;engineOnce.Do(func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine = new(EngineImpl) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.helper = NewHelper(coord) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.consenter = controller.NewConsenter(engine.helper) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.helper.setConsenter(engine.consenter) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.peerEndpoint, err = coord.GetPeerEndpoint() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.consensusFan = util.NewMessageFan() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Debug(&quot;Starting up message thread for consenter&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The channel never closes, so this should never break &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for msg := range engine.consensusFan.GetOutChannel() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.consenter.RecvMsg(msg.Msg, msg.Sender) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;return engine, err } //============================================================================== // NewConsenter constructs a Consenter object if not already present //============================================================================== //============================================================================== //调用controller获取一个plugin，当选择是pbft算法时，它会调用pbft.go 里的 //GetPlugin(c consensus.Stack)方法，在pbft.go里面把所有的外部参数读进算法内部 //============================================================================== func NewConsenter(stack consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;plugin := strings.ToLower(viper.GetString(&quot;peer.validator.consensus.plugin&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if plugin == &quot;pbft&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;Creating consensus plugin %s&quot;, plugin) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return pbft.GetPlugin(stack) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;logger.Info(&quot;Creating default consensus plugin (noops)&quot;) &nbsp;&nbsp;&nbsp;&nbsp;return noops.GetNoops(stack) } controller目录下是共识插件选择模块的函数 ----&gt;HyperLedger提供了两种算法PBFT和noops ----&gt;默认单节点情况下使用noops即相当于没有共识算法 func NewConsenter(stack consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;plugin := strings.ToLower(viper.GetString(&quot;peer.validator.consensus.plugin&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if plugin == &quot;pbft&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;Creating consensus plugin %s&quot;, plugin) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return pbft.GetPlugin(stack) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;logger.Info(&quot;Creating default consensus plugin (noops)&quot;) &nbsp;&nbsp;&nbsp;&nbsp;return noops.GetNoops(stack) } 函数中可以看出目前Hyperledger Fabric只支持PBFT和NOOPS executor和helper是两个相互依赖的模块 ----&gt;主要提供了共识算法和外部衔接的一块代码。主要负责事件处理的转接 helper ---&gt;这里面主要包含了对外部接口的一个调用，比如执行处理transaction，stateupdate，持久化一些对象等 noops&nbsp; ---&gt;noops相当于没有共识算法 pbft ---&gt; HyperLedger的默认共识算法 util&nbsp; ---&gt;交互需要的工具包，最主要的一个实现的功能就是它的消息机制。 func GetPlugin(c consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;if pluginInstance == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pluginInstance = New(c) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return pluginInstance } func New(stack consensus.Stack) consensus.Consenter { &nbsp;&nbsp;&nbsp;&nbsp;handle, _, _ := stack.GetNetworkHandles() &nbsp;&nbsp;&nbsp;&nbsp;id, _ := getValidatorID(handle) &nbsp;&nbsp;&nbsp;&nbsp;switch strings.ToLower(config.GetString(&quot;general.mode&quot;)) { &nbsp;&nbsp;&nbsp;&nbsp;case &quot;batch&quot;: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return newObcBatch(id, config, stack) &nbsp;&nbsp;&nbsp;&nbsp;default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Invalid PBFT mode: %s&quot;, config.GetString(&quot;general.mode&quot;))) &nbsp;&nbsp;&nbsp;&nbsp;} } //==============================================================================//在newobcbatch时，会初始化得到一个pbftcore的一个实例，这个是算法的核心模块。//并此时会启动一个batchTimer（这个batchTimer是一个计时器，//当batchTimer timeout后会触发一个sendbatch操作，这个只有primary节点才会去做）。//当然此时会创建一个事件处理机制，这个事件处理机制是各个模块沟通的一个bridge。//============================================================================== func newObcBatch(id uint64, config *viper.Viper, stack consensus.Stack) *obcBatch { &nbsp;&nbsp;&nbsp;&nbsp;var err error &nbsp;&nbsp;&nbsp;&nbsp;op := &amp;obcBatch{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obcGeneric: obcGeneric{stack: stack}, &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;op.persistForward.persistor = stack &nbsp;&nbsp;&nbsp;&nbsp;logger.Debugf(&quot;Replica %d obtaining startup information&quot;, id) &nbsp;&nbsp;&nbsp;&nbsp;op.manager = events.NewManagerImpl() // TODO, this is hacky, eventually rip it out &nbsp;&nbsp;&nbsp;&nbsp;op.manager.SetReceiver(op) &nbsp;&nbsp;&nbsp;&nbsp;etf := events.NewTimerFactoryImpl(op.manager) &nbsp;&nbsp;&nbsp;&nbsp;op.pbft = newPbftCore(id, config, op, etf) &nbsp;&nbsp;&nbsp;&nbsp;op.manager.Start() &nbsp;&nbsp;&nbsp;&nbsp;blockchainInfoBlob := stack.GetBlockchainInfoBlob() &nbsp;&nbsp;&nbsp;&nbsp;op.externalEventReceiver.manager = op.manager &nbsp;&nbsp;&nbsp;&nbsp;op.broadcaster = newBroadcaster(id, op.pbft.N, op.pbft.f, op.pbft.broadcastTimeout, stack) &nbsp;&nbsp;&nbsp;&nbsp;op.manager.Queue() &lt;- workEvent(func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op.pbft.stateTransfer(&amp;stateUpdateTarget{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkpointMessage: checkpointMessage{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqNo: op.pbft.lastExec, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: blockchainInfoBlob, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;op.batchSize = config.GetInt(&quot;general.batchsize&quot;) &nbsp;&nbsp;&nbsp;&nbsp;op.batchStore = nil &nbsp;&nbsp;&nbsp;&nbsp;op.batchTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.batch&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse batch timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Batch size = %d&quot;, op.batchSize) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Batch timeout = %v&quot;, op.batchTimeout) &nbsp;&nbsp;&nbsp;&nbsp;if op.batchTimeout &gt;= op.pbft.requestTimeout { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op.pbft.requestTimeout = 3 * op.batchTimeout / 2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Warningf(&quot;Configured request timeout must be greater than batch timeout, setting to %v&quot;, op.pbft.requestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if op.pbft.requestTimeout &gt;= op.pbft.nullRequestTimeout &amp;&amp; op.pbft.nullRequestTimeout != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op.pbft.nullRequestTimeout = 3 * op.pbft.requestTimeout / 2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Warningf(&quot;Configured null request timeout must be greater than request timeout, setting to %v&quot;, op.pbft.nullRequestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;op.incomingChan = make(chan *batchMessage) &nbsp;&nbsp;&nbsp;&nbsp;op.batchTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;op.reqStore = newRequestStore() &nbsp;&nbsp;&nbsp;&nbsp;op.deduplicator = newDeduplicator() &nbsp;&nbsp;&nbsp;&nbsp;op.idleChan = make(chan struct{}) &nbsp;&nbsp;&nbsp;&nbsp;close(op.idleChan) // TODO remove eventually &nbsp;&nbsp;&nbsp;&nbsp;return op } func newPbftCore(id uint64, config *viper.Viper, consumer innerStack, etf events.TimerFactory) *pbftCore { &nbsp;&nbsp;&nbsp;&nbsp;var err error &nbsp;&nbsp;&nbsp;&nbsp;instance := &amp;pbftCore{} &nbsp;&nbsp;&nbsp;&nbsp;instance.id = id &nbsp;&nbsp;&nbsp;&nbsp;instance.consumer = consumer &nbsp;&nbsp;&nbsp;&nbsp;//============================================================================== &nbsp;&nbsp;&nbsp;&nbsp;// 4. 在初始化pbftcore时，在把所用配置读进的同时，创建了三个timer &nbsp;&nbsp;&nbsp;&nbsp;//============================================================================== &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;//newViewTimer对应于viewChangeTimerEvent{}，当这个timer在一定时间没有close时， &nbsp;&nbsp;&nbsp;&nbsp;//就会触发一个viewchange事件 &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;instance.newViewTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;//vcResendTimer对应viewChangeResendTimerEvent，发出viewchange过时时会 &nbsp;&nbsp;&nbsp;&nbsp;//触发一个将viewchange从新发送 &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;instance.vcResendTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;//nullRequestTimer对应nullRequestEvent，如果主节点长期没有发送preprepare消息， &nbsp;&nbsp;&nbsp;&nbsp;//也就是分配了seq的reqBatch。它timeout就认为主节点挂掉了然后发送viewchange消息 &nbsp;&nbsp;&nbsp;&nbsp;//========================================================================== &nbsp;&nbsp;&nbsp;&nbsp;instance.nullRequestTimer = etf.CreateTimer() &nbsp;&nbsp;&nbsp;&nbsp;instance.N = config.GetInt(&quot;general.N&quot;) //网络中验证器的最大数量赋值 &nbsp;&nbsp;&nbsp;&nbsp;//==================================================================================// &nbsp;&nbsp;&nbsp;&nbsp;/*N是所有replicas的集合，每一个replica用一个整数来表示，依次为 &nbsp;&nbsp;&nbsp;&nbsp;{ 0, …, |N - 1 } &nbsp;&nbsp;&nbsp;&nbsp;简单起见，我们定义 &nbsp;&nbsp;&nbsp;&nbsp;|N = 3f + 1 &nbsp;&nbsp;&nbsp;&nbsp;f 是最大可容忍的faulty节点 &nbsp;&nbsp;&nbsp;&nbsp;另外我们将一个view中的primary节点定义为replica p， &nbsp;&nbsp;&nbsp;&nbsp;p = v mod |N &nbsp;&nbsp;&nbsp;&nbsp;v 是view的编号，从0开始一直连续下去，这样可以理解为从replica 0 到 replica |N-1 依次当primary节点，当每一次view change发生时。 &nbsp;&nbsp;&nbsp;&nbsp;*/ &nbsp;&nbsp;&nbsp;&nbsp;//==================================================================================// &nbsp;&nbsp;&nbsp;&nbsp;instance.f = config.GetInt(&quot;general.f&quot;) //默认的最大容错数量赋值 &nbsp;&nbsp;&nbsp;&nbsp;if instance.f*3+1 &gt; instance.N { //默认的最大容错数量大于网络中验证器的最大数量 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Sprintf(&quot;need at least %d enough replicas to tolerate %d byzantine faults, but only %d replicas configured&quot;, instance.f*3+1, instance.f, instance.N)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;instance.K = uint64(config.GetInt(&quot;general.K&quot;)) //检查点时间段赋值 &nbsp;&nbsp;&nbsp;&nbsp;//计算日志的大小值赋值,日志倍增器 &nbsp;&nbsp;&nbsp;&nbsp;instance.logMultiplier = uint64(config.GetInt(&quot;general.logmultiplier&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if instance.logMultiplier &lt; 2 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(&quot;Log multiplier must be greater than or equal to 2&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//日志大小计算 &nbsp;&nbsp;&nbsp;&nbsp;instance.L = instance.logMultiplier * instance.K // 日志大小 &nbsp;&nbsp;&nbsp;&nbsp;//自动视图改变的时间段 &nbsp;&nbsp;&nbsp;&nbsp;instance.viewChangePeriod = uint64(config.GetInt(&quot;general.viewchangeperiod&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;//这个节点是否故意充当拜占庭;testnet用于调试 &nbsp;&nbsp;&nbsp;&nbsp;instance.byzantine = config.GetBool(&quot;general.byzantine&quot;) &nbsp;&nbsp;&nbsp;&nbsp;//请求过程超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.requestTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.request&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse request timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//重发视图改变之前超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.vcResendTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.resendviewchange&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse request timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//新的视图超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.newViewTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.viewchange&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse new view timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//超时持续 &nbsp;&nbsp;&nbsp;&nbsp;instance.nullRequestTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.nullrequest&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.nullRequestTimeout = 0 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//广播过程超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.broadcastTimeout, err = time.ParseDuration(config.GetString(&quot;general.timeout.broadcast&quot;)) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(fmt.Errorf(&quot;Cannot parse new broadcast timeout: %s&quot;, err)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//查看view发生 &nbsp;&nbsp;&nbsp;&nbsp;instance.activeView = true &nbsp;&nbsp;&nbsp;&nbsp;//replicas的数量; PBFT `|R|` &nbsp;&nbsp;&nbsp;&nbsp;instance.replicaCount = instance.N &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT type = %T&quot;, instance.consumer) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Max number of validating peers (N) = %v&quot;, instance.N) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Max number of failing peers (f) = %v&quot;, instance.f) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT byzantine flag = %v&quot;, instance.byzantine) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT request timeout = %v&quot;, instance.requestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT view change timeout = %v&quot;, instance.newViewTimeout) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Checkpoint period (K) = %v&quot;, instance.K) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT broadcast timeout = %v&quot;, instance.broadcastTimeout) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT Log multiplier = %v&quot;, instance.logMultiplier) &nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT log size (L) = %v&quot;, instance.L) &nbsp;&nbsp;&nbsp;&nbsp;//超时持续 &nbsp;&nbsp;&nbsp;&nbsp;if instance.nullRequestTimeout &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT null requests timeout = %v&quot;, instance.nullRequestTimeout) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT null requests disabled&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//在自动视图改变的时间段 &nbsp;&nbsp;&nbsp;&nbsp;if instance.viewChangePeriod &gt; 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT view change period = %v&quot;, instance.viewChangePeriod) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Infof(&quot;PBFT automatic view change disabled&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// init the logs &nbsp;&nbsp;&nbsp;&nbsp;//跟踪法定证书请求 &nbsp;&nbsp;&nbsp;&nbsp;instance.certStore = make(map[msgID]*msgCert) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪请求批次 &nbsp;&nbsp;&nbsp;&nbsp;instance.reqBatchStore = make(map[string]*RequestBatch) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪检查点设置 &nbsp;&nbsp;&nbsp;&nbsp;instance.checkpointStore = make(map[Checkpoint]bool) &nbsp;&nbsp;&nbsp;&nbsp;//检查点状态; 映射lastExec到全局hash &nbsp;&nbsp;&nbsp;&nbsp;instance.chkpts = make(map[uint64]string) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪视view change消息 &nbsp;&nbsp;&nbsp;&nbsp;instance.viewChangeStore = make(map[vcidx]*ViewChange) &nbsp;&nbsp;&nbsp;&nbsp;instance.pset = make(map[uint64]*ViewChange_PQ) &nbsp;&nbsp;&nbsp;&nbsp;instance.qset = make(map[qidx]*ViewChange_PQ) &nbsp;&nbsp;&nbsp;&nbsp;//跟踪我们接收后者发送的最后一个新视图 &nbsp;&nbsp;&nbsp;&nbsp;instance.newViewStore = make(map[uint64]*NewView) &nbsp;&nbsp;&nbsp;&nbsp;// initialize state transfer &nbsp;&nbsp;&nbsp;&nbsp;//观察每一个replica最高薄弱点序列数 &nbsp;&nbsp;&nbsp;&nbsp;instance.hChkpts = make(map[uint64]uint64) &nbsp;&nbsp;&nbsp;&nbsp;//检查点状态; 映射lastExec到全局hash &nbsp;&nbsp;&nbsp;&nbsp;instance.chkpts[0] = &quot;XXX GENESIS&quot; &nbsp;&nbsp;&nbsp;&nbsp;// 在我们使用视图改变期间最后超时 &nbsp;&nbsp;&nbsp;&nbsp;instance.lastNewViewTimeout = instance.newViewTimeout &nbsp;&nbsp;&nbsp;&nbsp;//跟踪我们是否正在等待请求批处理执行 &nbsp;&nbsp;&nbsp;&nbsp;instance.outstandingReqBatches = make(map[string]*RequestBatch) &nbsp;&nbsp;&nbsp;&nbsp;//对于所有已经分配我们可能错过的在视图改变期间的非检查点的请求批次 &nbsp;&nbsp;&nbsp;&nbsp;instance.missingReqBatches = make(map[string]bool) &nbsp;&nbsp;&nbsp;&nbsp;//将变量的值恢复到初始状态 &nbsp;&nbsp;&nbsp;&nbsp;instance.restoreState() &nbsp;&nbsp;&nbsp;&nbsp;// 执行视图改变的下一个序号 &nbsp;&nbsp;&nbsp;&nbsp;instance.viewChangeSeqNo = ^uint64(0) // infinity &nbsp;&nbsp;&nbsp;&nbsp;//更新视图改变序列号 &nbsp;&nbsp;&nbsp;&nbsp;instance.updateViewChangeSeqNo() &nbsp;&nbsp;&nbsp;&nbsp;return instance } 代码走到newPbftCore的过程，等待下周更新........... 阅读更多","@type":"BlogPosting","url":"/2016/12/21/d477637d8f98d640f382af81c71d1334.html","headline":"Hyperledger Fabric的PBFT源码分析（一）","dateModified":"2016-12-21T00:00:00+08:00","datePublished":"2016-12-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2016/12/21/d477637d8f98d640f382af81c71d1334.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Hyperledger Fabric的PBFT源码分析（一）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>一、PBFT的原理概述</p> 
  <p>1.算法公式:<br></p> 
  <p>replicaCount &nbsp;int 变量定义在pbftCore结构体中<br> N (N在代码中对应replicaCount整型变量)是所有replicas的集合，每一个replica用一个整数来表示，如{ 0, 1, 2, 3,...N - 1 }<br><br><br> N-1 = 3f -----&gt; f = N- 1/3<br><br><br> f 是最大可容忍的出错节点，也就是说准许错为1/3<br></p> 
  <p>2.图解PBFT执行过程<br></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20161221165350278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmdfeGlueGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p> 
  <p>客户端发过来的请求其实是发给主replica，这里假设所得还没有选出主replica</p> 
  <p><br></p> 
  <p><br></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20161221165620498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmdfeGlueGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p> 
  <p><br></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20161221165753682?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmdfeGlueGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20161221165834261?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmdfeGlueGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p> 
  <p>这里大家估计也可以看出来图3和图4是一样的，其实这是一个互相确认的过程</p> 
  <p><br></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20161221170028187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmdfeGlueGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p> 
  <p><br></p> 
  <p>客户端<br><br><br> Client----&gt;REQUEST---&gt;replicas<br> 1. REQUEST携带 operation, timestamp，给每一个REQUEST加上时间戳，这样后来的REQUEST会有高于前面的时间戳<br><br> 2.replicas会接收请求，如果他们验证了条请求，就会将它写入到自己的log中。在共识算法保证下每个replica完成对该请求的执行后直接将回复返回给client：<br><br> 3.REPLY携带当前的view序号和时间戳，还有replica节点的编号，会返回执行结果<br><br> 4.共识算法中有一个weak certificate，在这里，client也会等待weak certificate：即有f+1个replicas回复，并且它们的回复拥有相同的 t 和 r，由于至多有f个faulty replicas，所以确保了回复是合法的。我们叫这个weak certificate为 reply certificate。<br><br> 5.处于active状态每一个replica会与每一个的client共享一份秘钥。<br></p> 
  <p><br></p> 
  <p>pre-prepare阶段</p> 
  <p><br><span></span>1.主节点收到来自Client的一条请求并分配了一个编号给这个请求，<br><span></span>2.主节点会广播一条PRE-PREPARE信息给备份节点，<br><span></span>3.这个PRE-PREPARE信息包含该请求的编号、所在的view和自身的一个digest。<br><span></span>4.直到该信息送达到每一个备份节点，接下来就看收到信息的备份节点们同不同意<br><span></span>5.主节点分配给该请求的这个编号n，即是否accept这条PRE-PREPARE信息，<br></p> 
  <p><span></span>6.如果一个备份节点accept了这条PRE-PREPARE，它就会进入下面的prepare阶段。</p> 
  <p>prepare阶段</p> 
  <p><br> 1.备份节点进入prepared阶段后，广播一条PREPARE信息给主节点和其它的备份节点，直到PREPARE信息都抵达那三个节点。同时，该备份节点也会分别收到来自其它备份节点的PREPARE信息。<br> 2.该备份节点将综合这些PREPARE信息做出自己对编号n的最终裁决。当这个备份节点开始综合比较来自其它两个备份节点的PREPARE信息和自身的PREPARE信息时，如果该备份节点发现其它两个节点都同意主节点分配的编号，又看了一下自己，自己也同意主节点的分配，a quorum certificate with the PRE-PREPARE and 2 f matching PREPARE messages for sequence number n, view v, and request m，如果一个replica达到了英文所说的条件，比如就是上面的斜体字描述的一种情况，那么我们就说该请求在这个replica上的状态是prepared，该replica就拥有了一个证书叫prepared certificate。那我们是不是就可以说至此排序工作已经完成，全网节点都达成了一个一致的请求序列呢，每一个replica开始照着这个序列执行吧。这是有漏洞的，设想一下，在t1时刻只有replica 1把请求m（编号为n）带到了prepared状态，其他两个备份节点replica 2， replica 3还没有来得及收集完来自其它节点的PREPARE信息进行判断，那么这时发生了view change进入到了一个新的view中，replica 1还认为给m分配的编号n已经得到了一个quorum同意，可以继续納入序列中，或者可以执行了，但对于replica 2来说，它来到了新的view中，它失去了对请求m的判断，甚至在上个view中它还有收集全其他节点发出的PREPARE信息，所以对于replica 2来说，给请求m分配的编号n将不作数，同理replica 3也是。那么replica 1一个人认为作数不足以让全网都认同，所以再新的view中，请求m的编号n将作废，需要重新发起提案。所以就有了下面的commit阶段。<br> &nbsp; &nbsp; &nbsp; &nbsp; 需要注意的是，该备份节点会将自己收到的PRE-PREPARE和发送的PREPARE信息记录到自己的log中。<br> &nbsp; &nbsp; &nbsp; &nbsp; 该备份节点发出PREPARE信息表示该节点同意主节点在view v中将编号n分配给请求m，不发即表示不同意。<br> &nbsp; &nbsp; &nbsp; &nbsp; 如果一个replica对请求m发出了PRE-PREPARE和PREPARE信息，那么我们就说该请求m在这个replica节点上处于pre-prepared状态。<br></p> 
  <p><br></p> 
  <p>Commit阶段</p> 
  <p>紧接着prepare阶段，当一个replica节点发现有一个quorum同意编号分配时，它就会广播一条COMMIT信息给其它所有节点告诉他们它有一个prepared certificate了。与此同时它也会陆续收到来自其它节点的COMMIT信息，如果它收到了2f+1条COMMIT（包括自身的一条，这些来自不同节点的COMMIT携带相同的编号n和view v），我们就说该节点拥有了一个叫committed certificate的证书，请求在这个节点上达到了committed状态。此时只通过这一个节点，我们就能断定该请求已经在一个quorum中到达了prepared状态，寄一个quorum的节点们都同意了编号n的分配。当请求m到达commited状态后，该请求就会被该节点执行。</p> 
  <p><br></p> 
  <p>由此观之核心代码执行的过程如下</p> 
  <p><br><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20161221170509818?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmdfeGlueGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p> 
  <p>二、共识算法代码解析</p> 
  <p>1.代码目录结构</p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20161221170800572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmdfeGlueGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p> 
  <p></p> 
  <pre><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">GetEngine</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">returns</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">initialized</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">peer.Engine</span></pre> 
  <pre><span style="color:#008000;">//============================================================================</span></pre> 
  <pre><span style="color:#008000;">//它初始化一个consenter和一个helper，并互相把一个句柄赋值给了对方。</span></pre> 
  <pre><span style="color:#008000;">//这样做的目的，就是为了可以让外部调用内部，内部可以调用外部</span></pre> 
  <pre><span style="color:#008000;">//============================================================================</span></pre> 
  <pre><span style="font-weight:600;color:#000080;">func</span><span style="color:#c0c0c0;"> </span>GetEngine(coord<span style="color:#c0c0c0;"> </span>peer.MessageHandlerCoordinator)<span style="color:#c0c0c0;"> </span>(peer.Engine,<span style="color:#c0c0c0;"> </span><span style="color:#000080;">error</span>)<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">var</span><span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span><span style="color:#000080;">error</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>engineOnce.Do(<span style="font-weight:600;color:#000080;">func</span>()<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>engine<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">new</span>(EngineImpl)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>engine.helper<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>NewHelper(coord)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>engine.consenter<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>controller.NewConsenter(engine.helper)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>engine.helper.setConsenter(engine.consenter)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>engine.peerEndpoint,<span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>coord.GetPeerEndpoint()</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>engine.consensusFan<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>util.NewMessageFan()</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">go</span><span style="color:#c0c0c0;"> </span><span style="font-weight:600;color:#000080;">func</span>()<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Debug(<span style="color:#008000;">"Starting</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">up</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">message</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">thread</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">for</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">consenter"</span>)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">The</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">channel</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">never</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">closes,</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">so</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">this</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">should</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">never</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">break</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">for</span><span style="color:#c0c0c0;"> </span>msg<span style="color:#c0c0c0;"> </span>:=<span style="color:#c0c0c0;"> </span><span style="font-weight:600;color:#000080;">range</span><span style="color:#c0c0c0;"> </span>engine.consensusFan.GetOutChannel()<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>engine.consenter.RecvMsg(msg.Msg,<span style="color:#c0c0c0;"> </span>msg.Sender)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>}()</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>})</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">return</span><span style="color:#c0c0c0;"> </span>engine,<span style="color:#c0c0c0;"> </span>err</pre> 
  <pre>}</pre> 
  <p></p> 
  <p><br></p> 
  <p></p> 
  <pre><span style="color:#008000;">//==============================================================================</span></pre> 
  <pre><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">NewConsenter</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">constructs</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">a</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">Consenter</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">object</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">if</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">not</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">already</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">present</span></pre> 
  <pre><span style="color:#008000;">//==============================================================================</span></pre> 
  <pre><span style="color:#008000;">//==============================================================================</span></pre> 
  <pre><span style="color:#008000;">//调用controller获取一个plugin，当选择是pbft算法时，它会调用pbft.go</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">里的</span></pre> 
  <pre><span style="color:#008000;">//GetPlugin(c</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">consensus.Stack)方法，在pbft.go里面把所有的外部参数读进算法内部</span></pre> 
  <pre><span style="color:#008000;">//==============================================================================</span></pre> 
  <pre><span style="font-weight:600;color:#000080;">func</span><span style="color:#c0c0c0;"> </span>NewConsenter(stack<span style="color:#c0c0c0;"> </span>consensus.Stack)<span style="color:#c0c0c0;"> </span>consensus.Consenter<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>plugin<span style="color:#c0c0c0;"> </span>:=<span style="color:#c0c0c0;"> </span>strings.ToLower(viper.GetString(<span style="color:#008000;">"peer.validator.consensus.plugin"</span>))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>plugin<span style="color:#c0c0c0;"> </span>==<span style="color:#c0c0c0;"> </span><span style="color:#008000;">"pbft"</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"Creating</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">consensus</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">plugin</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%s"</span>,<span style="color:#c0c0c0;"> </span>plugin)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">return</span><span style="color:#c0c0c0;"> </span>pbft.GetPlugin(stack)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Info(<span style="color:#008000;">"Creating</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">default</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">consensus</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">plugin</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">(noops)"</span>)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">return</span><span style="color:#c0c0c0;"> </span>noops.GetNoops(stack)</pre> 
  <pre></pre> 
  <pre>}</pre> 
  <p></p> 
  <p>controller目录下是共识插件选择模块的函数<br> ----&gt;HyperLedger提供了两种算法PBFT和noops<br> ----&gt;默认单节点情况下使用noops即相当于没有共识算法<br></p> 
  <p></p> 
  <pre><span style="font-weight:600;color:#000080;">func</span><span style="color:#c0c0c0;"> </span>NewConsenter(stack<span style="color:#c0c0c0;"> </span>consensus.Stack)<span style="color:#c0c0c0;"> </span>consensus.Consenter<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>plugin<span style="color:#c0c0c0;"> </span>:=<span style="color:#c0c0c0;"> </span>strings.ToLower(viper.GetString(<span style="color:#008000;">"peer.validator.consensus.plugin"</span>))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>plugin<span style="color:#c0c0c0;"> </span>==<span style="color:#c0c0c0;"> </span><span style="color:#008000;">"pbft"</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"Creating</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">consensus</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">plugin</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%s"</span>,<span style="color:#c0c0c0;"> </span>plugin)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">return</span><span style="color:#c0c0c0;"> </span>pbft.GetPlugin(stack)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Info(<span style="color:#008000;">"Creating</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">default</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">consensus</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">plugin</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">(noops)"</span>)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">return</span><span style="color:#c0c0c0;"> </span>noops.GetNoops(stack)</pre> 
  <pre></pre> 
  <pre>}</pre> 函数中可以看出目前Hyperledger Fabric只支持PBFT和NOOPS 
  <p></p> 
  <p><br></p> 
  <p>executor和helper是两个相互依赖的模块<br> ----&gt;主要提供了共识算法和外部衔接的一块代码。主要负责事件处理的转接<br></p> 
  <p>helper<br> ---&gt;这里面主要包含了对外部接口的一个调用，比如执行处理transaction，stateupdate，持久化一些对象等<br> noops&nbsp;<br> ---&gt;noops相当于没有共识算法<br> pbft<br> ---&gt; HyperLedger的默认共识算法<br> util&nbsp;<br> ---&gt;交互需要的工具包，最主要的一个实现的功能就是它的消息机制。<br></p> 
  <p><br></p> 
  <p></p> 
  <pre><span style="font-weight:600;color:#000080;">func</span><span style="color:#c0c0c0;"> </span>GetPlugin(c<span style="color:#c0c0c0;"> </span>consensus.Stack)<span style="color:#c0c0c0;"> </span>consensus.Consenter<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>pluginInstance<span style="color:#c0c0c0;"> </span>==<span style="color:#c0c0c0;"> </span><span style="color:#000080;">nil</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>pluginInstance<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>New(c)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">return</span><span style="color:#c0c0c0;"> </span>pluginInstance</pre> 
  <pre>}</pre> 
  <br>
  <p></p> 
  <p></p> 
  <pre><span style="font-weight:600;color:#000080;">func</span><span style="color:#c0c0c0;"> </span>New(stack<span style="color:#c0c0c0;"> </span>consensus.Stack)<span style="color:#c0c0c0;"> </span>consensus.Consenter<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>handle,<span style="color:#c0c0c0;"> </span>_,<span style="color:#c0c0c0;"> </span>_<span style="color:#c0c0c0;"> </span>:=<span style="color:#c0c0c0;"> </span>stack.GetNetworkHandles()</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>id,<span style="color:#c0c0c0;"> </span>_<span style="color:#c0c0c0;"> </span>:=<span style="color:#c0c0c0;"> </span>getValidatorID(handle)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">switch</span><span style="color:#c0c0c0;"> </span>strings.ToLower(config.GetString(<span style="color:#008000;">"general.mode"</span>))<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">case</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">"batch"</span>:</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">return</span><span style="color:#c0c0c0;"> </span>newObcBatch(id,<span style="color:#c0c0c0;"> </span>config,<span style="color:#c0c0c0;"> </span>stack)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">default</span>:</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#000080;">panic</span>(fmt.Errorf(<span style="color:#008000;">"Invalid</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">mode:</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%s"</span>,<span style="color:#c0c0c0;"> </span>config.GetString(<span style="color:#008000;">"general.mode"</span>)))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre>}</pre> 
  <pre></pre> //==============================================================================//在newobcbatch时，会初始化得到一个pbftcore的一个实例，这个是算法的核心模块。//并此时会启动一个batchTimer（这个batchTimer是一个计时器，//当batchTimer timeout后会触发一个sendbatch操作，这个只有primary节点才会去做）。//当然此时会创建一个事件处理机制，这个事件处理机制是各个模块沟通的一个bridge。//============================================================================== 
  <p></p> 
  <p></p> 
  <pre><span style="font-weight:600;color:#000080;">func</span><span style="color:#c0c0c0;"> </span>newObcBatch(id<span style="color:#c0c0c0;"> </span><span style="color:#000080;">uint64</span>,<span style="color:#c0c0c0;"> </span>config<span style="color:#c0c0c0;"> </span>*viper.Viper,<span style="color:#c0c0c0;"> </span>stack<span style="color:#c0c0c0;"> </span>consensus.Stack)<span style="color:#c0c0c0;"> </span>*obcBatch<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">var</span><span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span><span style="color:#000080;">error</span></pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op<span style="color:#c0c0c0;"> </span>:=<span style="color:#c0c0c0;"> </span>&amp;obcBatch{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>obcGeneric:<span style="color:#c0c0c0;"> </span>obcGeneric{stack:<span style="color:#c0c0c0;"> </span>stack},</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.persistForward.persistor<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>stack</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Debugf(<span style="color:#008000;">"Replica</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%d</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">obtaining</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">startup</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">information"</span>,<span style="color:#c0c0c0;"> </span>id)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.manager<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>events.NewManagerImpl()<span style="color:#c0c0c0;"> </span><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">TODO,</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">this</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">is</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">hacky,</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">eventually</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">rip</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">it</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">out</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.manager.SetReceiver(op)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>etf<span style="color:#c0c0c0;"> </span>:=<span style="color:#c0c0c0;"> </span>events.NewTimerFactoryImpl(op.manager)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.pbft<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>newPbftCore(id,<span style="color:#c0c0c0;"> </span>config,<span style="color:#c0c0c0;"> </span>op,<span style="color:#c0c0c0;"> </span>etf)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.manager.Start()</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>blockchainInfoBlob<span style="color:#c0c0c0;"> </span>:=<span style="color:#c0c0c0;"> </span>stack.GetBlockchainInfoBlob()</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.externalEventReceiver.manager<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>op.manager</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.broadcaster<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>newBroadcaster(id,<span style="color:#c0c0c0;"> </span>op.pbft.N,<span style="color:#c0c0c0;"> </span>op.pbft.f,<span style="color:#c0c0c0;"> </span>op.pbft.broadcastTimeout,<span style="color:#c0c0c0;"> </span>stack)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.manager.Queue()<span style="color:#c0c0c0;"> </span>&lt;-<span style="color:#c0c0c0;"> </span>workEvent(<span style="font-weight:600;color:#000080;">func</span>()<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>op.pbft.stateTransfer(&amp;stateUpdateTarget{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>checkpointMessage:<span style="color:#c0c0c0;"> </span>checkpointMessage{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>seqNo:<span style="color:#c0c0c0;"> </span>op.pbft.lastExec,</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>id:<span style="color:#c0c0c0;">    </span>blockchainInfoBlob,</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>},</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>})</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>})</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.batchSize<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>config.GetInt(<span style="color:#008000;">"general.batchsize"</span>)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.batchStore<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">nil</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.batchTimeout,<span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>time.ParseDuration(config.GetString(<span style="color:#008000;">"general.timeout.batch"</span>))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>!=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">nil</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#000080;">panic</span>(fmt.Errorf(<span style="color:#008000;">"Cannot</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">parse</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">batch</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout:</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%s"</span>,<span style="color:#c0c0c0;"> </span>err))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">Batch</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">size</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%d"</span>,<span style="color:#c0c0c0;"> </span>op.batchSize)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">Batch</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>op.batchTimeout)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>op.batchTimeout<span style="color:#c0c0c0;"> </span>&gt;=<span style="color:#c0c0c0;"> </span>op.pbft.requestTimeout<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>op.pbft.requestTimeout<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#800080;">3</span><span style="color:#c0c0c0;"> </span>*<span style="color:#c0c0c0;"> </span>op.batchTimeout<span style="color:#c0c0c0;"> </span>/<span style="color:#c0c0c0;"> </span><span style="color:#800080;">2</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Warningf(<span style="color:#008000;">"Configured</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">request</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">must</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">be</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">greater</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">than</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">batch</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout,</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">setting</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">to</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>op.pbft.requestTimeout)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>op.pbft.requestTimeout<span style="color:#c0c0c0;"> </span>&gt;=<span style="color:#c0c0c0;"> </span>op.pbft.nullRequestTimeout<span style="color:#c0c0c0;"> </span>&amp;&amp;<span style="color:#c0c0c0;"> </span>op.pbft.nullRequestTimeout<span style="color:#c0c0c0;"> </span>!=<span style="color:#c0c0c0;"> </span><span style="color:#800080;">0</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>op.pbft.nullRequestTimeout<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#800080;">3</span><span style="color:#c0c0c0;"> </span>*<span style="color:#c0c0c0;"> </span>op.pbft.requestTimeout<span style="color:#c0c0c0;"> </span>/<span style="color:#c0c0c0;"> </span><span style="color:#800080;">2</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Warningf(<span style="color:#008000;">"Configured</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">null</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">request</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">must</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">be</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">greater</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">than</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">request</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout,</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">setting</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">to</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>op.pbft.nullRequestTimeout)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.incomingChan<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">chan</span><span style="color:#c0c0c0;"> </span>*batchMessage)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.batchTimer<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>etf.CreateTimer()</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.reqStore<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>newRequestStore()</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.deduplicator<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>newDeduplicator()</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>op.idleChan<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">chan</span><span style="color:#c0c0c0;"> </span><span style="font-weight:600;color:#000080;">struct</span>{})</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#000080;">close</span>(op.idleChan)<span style="color:#c0c0c0;"> </span><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="font-weight:600;color:#006000;background-color:#e0e0e0;">TODO</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">remove</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">eventually</span></pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">return</span><span style="color:#c0c0c0;"> </span>op</pre> 
  <pre>}</pre> 
  <br>
  <p></p> 
  <p><br></p> 
  <p></p> 
  <pre><span style="font-weight:600;color:#000080;">func</span><span style="color:#c0c0c0;"> </span>newPbftCore(id<span style="color:#c0c0c0;"> </span><span style="color:#000080;">uint64</span>,<span style="color:#c0c0c0;"> </span>config<span style="color:#c0c0c0;"> </span>*viper.Viper,<span style="color:#c0c0c0;"> </span>consumer<span style="color:#c0c0c0;"> </span>innerStack,<span style="color:#c0c0c0;"> </span>etf<span style="color:#c0c0c0;"> </span>events.TimerFactory)<span style="color:#c0c0c0;"> </span>*pbftCore<span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">var</span><span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span><span style="color:#000080;">error</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance<span style="color:#c0c0c0;"> </span>:=<span style="color:#c0c0c0;"> </span>&amp;pbftCore{}</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.id<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>id</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.consumer<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>consumer</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//==============================================================================</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">4.</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">在初始化pbftcore时，在把所用配置读进的同时，创建了三个timer</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//==============================================================================</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//==========================================================================</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//newViewTimer对应于viewChangeTimerEvent{}，当这个timer在一定时间没有close时，</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//就会触发一个viewchange事件</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//==========================================================================</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.newViewTimer<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>etf.CreateTimer()</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//==========================================================================</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//vcResendTimer对应viewChangeResendTimerEvent，发出viewchange过时时会</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//触发一个将viewchange从新发送</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//==========================================================================</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.vcResendTimer<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>etf.CreateTimer()</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//==========================================================================</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//nullRequestTimer对应nullRequestEvent，如果主节点长期没有发送preprepare消息，</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//也就是分配了seq的reqBatch。它timeout就认为主节点挂掉了然后发送viewchange消息</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//==========================================================================</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.nullRequestTimer<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>etf.CreateTimer()</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.N<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>config.GetInt(<span style="color:#008000;">"general.N"</span>)<span style="color:#c0c0c0;"> </span><span style="color:#008000;">//网络中验证器的最大数量赋值</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//==================================================================================//</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">/*N是所有replicas的集合，每一个replica用一个整数来表示，依次为</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">{</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">0,</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">…,</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">|N</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">-</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">1</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">}</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">简单起见，我们定义</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">|N</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">3f</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">+</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">1</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">f</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">是最大可容忍的faulty节点</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">另外我们将一个view中的primary节点定义为replica</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">p，</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">p</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">v</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">mod</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">|N</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">v</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">是view的编号，从0开始一直连续下去，这样可以理解为从replica</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">0</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">到</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">replica</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">|N-1</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">依次当primary节点，当每一次view</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">change发生时。</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">*/</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//==================================================================================//</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.f<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>config.GetInt(<span style="color:#008000;">"general.f"</span>)<span style="color:#c0c0c0;"> </span><span style="color:#008000;">//默认的最大容错数量赋值</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>instance.f*<span style="color:#800080;">3</span>+<span style="color:#800080;">1</span><span style="color:#c0c0c0;"> </span>&gt;<span style="color:#c0c0c0;"> </span>instance.N<span style="color:#c0c0c0;"> </span>{<span style="color:#c0c0c0;">        </span><span style="color:#008000;">//默认的最大容错数量大于网络中验证器的最大数量</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#000080;">panic</span>(fmt.Sprintf(<span style="color:#008000;">"need</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">at</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">least</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%d</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">enough</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">replicas</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">to</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">tolerate</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%d</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">byzantine</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">faults,</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">but</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">only</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%d</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">replicas</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">configured"</span>,<span style="color:#c0c0c0;"> </span>instance.f*<span style="color:#800080;">3</span>+<span style="color:#800080;">1</span>,<span style="color:#c0c0c0;"> </span>instance.f,<span style="color:#c0c0c0;"> </span>instance.N))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.K<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">uint64</span>(config.GetInt(<span style="color:#008000;">"general.K"</span>))<span style="color:#c0c0c0;"> </span><span style="color:#008000;">//检查点时间段赋值</span></pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//计算日志的大小值赋值,日志倍增器</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.logMultiplier<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">uint64</span>(config.GetInt(<span style="color:#008000;">"general.logmultiplier"</span>))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>instance.logMultiplier<span style="color:#c0c0c0;"> </span>&lt;<span style="color:#c0c0c0;"> </span><span style="color:#800080;">2</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#000080;">panic</span>(<span style="color:#008000;">"Log</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">multiplier</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">must</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">be</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">greater</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">than</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">or</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">equal</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">to</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">2"</span>)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//日志大小计算</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.L<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>instance.logMultiplier<span style="color:#c0c0c0;"> </span>*<span style="color:#c0c0c0;"> </span>instance.K<span style="color:#c0c0c0;"> </span><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">日志大小</span></pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//自动视图改变的时间段</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.viewChangePeriod<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">uint64</span>(config.GetInt(<span style="color:#008000;">"general.viewchangeperiod"</span>))</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//这个节点是否故意充当拜占庭;testnet用于调试</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.byzantine<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>config.GetBool(<span style="color:#008000;">"general.byzantine"</span>)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//请求过程超时</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.requestTimeout,<span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>time.ParseDuration(config.GetString(<span style="color:#008000;">"general.timeout.request"</span>))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>!=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">nil</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#000080;">panic</span>(fmt.Errorf(<span style="color:#008000;">"Cannot</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">parse</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">request</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout:</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%s"</span>,<span style="color:#c0c0c0;"> </span>err))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//重发视图改变之前超时</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.vcResendTimeout,<span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>time.ParseDuration(config.GetString(<span style="color:#008000;">"general.timeout.resendviewchange"</span>))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>!=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">nil</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#000080;">panic</span>(fmt.Errorf(<span style="color:#008000;">"Cannot</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">parse</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">request</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout:</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%s"</span>,<span style="color:#c0c0c0;"> </span>err))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//新的视图超时</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.newViewTimeout,<span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>time.ParseDuration(config.GetString(<span style="color:#008000;">"general.timeout.viewchange"</span>))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>!=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">nil</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#000080;">panic</span>(fmt.Errorf(<span style="color:#008000;">"Cannot</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">parse</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">new</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">view</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout:</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%s"</span>,<span style="color:#c0c0c0;"> </span>err))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//超时持续</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.nullRequestTimeout,<span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>time.ParseDuration(config.GetString(<span style="color:#008000;">"general.timeout.nullrequest"</span>))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>!=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">nil</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.nullRequestTimeout<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#800080;">0</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//广播过程超时</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.broadcastTimeout,<span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>time.ParseDuration(config.GetString(<span style="color:#008000;">"general.timeout.broadcast"</span>))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>err<span style="color:#c0c0c0;"> </span>!=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">nil</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#000080;">panic</span>(fmt.Errorf(<span style="color:#008000;">"Cannot</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">parse</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">new</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">broadcast</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout:</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%s"</span>,<span style="color:#c0c0c0;"> </span>err))</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//查看view发生</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.activeView<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">true</span></pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//replicas的数量;</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">`|R|`</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.replicaCount<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>instance.N</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">type</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%T"</span>,<span style="color:#c0c0c0;"> </span>instance.consumer)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">Max</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">number</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">of</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">validating</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">peers</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">(N)</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>instance.N)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">Max</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">number</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">of</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">failing</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">peers</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">(f)</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>instance.f)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">byzantine</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">flag</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>instance.byzantine)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">request</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>instance.requestTimeout)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">view</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">change</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>instance.newViewTimeout)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">Checkpoint</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">period</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">(K)</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>instance.K)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">broadcast</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>instance.broadcastTimeout)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">Log</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">multiplier</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>instance.logMultiplier)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">log</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">size</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">(L)</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>instance.L)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//超时持续</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>instance.nullRequestTimeout<span style="color:#c0c0c0;"> </span>&gt;<span style="color:#c0c0c0;"> </span><span style="color:#800080;">0</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">null</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">requests</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">timeout</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>instance.nullRequestTimeout)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<span style="color:#c0c0c0;"> </span><span style="font-weight:600;color:#000080;">else</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">null</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">requests</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">disabled"</span>)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//在自动视图改变的时间段</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">if</span><span style="color:#c0c0c0;"> </span>instance.viewChangePeriod<span style="color:#c0c0c0;"> </span>&gt;<span style="color:#c0c0c0;"> </span><span style="color:#800080;">0</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">view</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">change</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">period</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">=</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">%v"</span>,<span style="color:#c0c0c0;"> </span>instance.viewChangePeriod)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<span style="color:#c0c0c0;"> </span><span style="font-weight:600;color:#000080;">else</span><span style="color:#c0c0c0;"> </span>{</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>logger.Infof(<span style="color:#008000;">"PBFT</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">automatic</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">view</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">change</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">disabled"</span>)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">init</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">the</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">logs</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//跟踪法定证书请求</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.certStore<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">map</span>[msgID]*msgCert)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//跟踪请求批次</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.reqBatchStore<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">map</span>[<span style="color:#000080;">string</span>]*RequestBatch)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//跟踪检查点设置</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.checkpointStore<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">map</span>[Checkpoint]<span style="color:#000080;">bool</span>)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//检查点状态;</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">映射lastExec到全局hash</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.chkpts<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">map</span>[<span style="color:#000080;">uint64</span>]<span style="color:#000080;">string</span>)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//跟踪视view</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">change消息</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.viewChangeStore<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">map</span>[vcidx]*ViewChange)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.pset<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">map</span>[<span style="color:#000080;">uint64</span>]*ViewChange_PQ)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.qset<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">map</span>[qidx]*ViewChange_PQ)</pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//跟踪我们接收后者发送的最后一个新视图</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.newViewStore<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">map</span>[<span style="color:#000080;">uint64</span>]*NewView)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">initialize</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">state</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">transfer</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//观察每一个replica最高薄弱点序列数</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.hChkpts<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">map</span>[<span style="color:#000080;">uint64</span>]<span style="color:#000080;">uint64</span>)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//检查点状态;</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">映射lastExec到全局hash</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.chkpts[<span style="color:#800080;">0</span>]<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#008000;">"XXX</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">GENESIS"</span></pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">在我们使用视图改变期间最后超时</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.lastNewViewTimeout<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>instance.newViewTimeout</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//跟踪我们是否正在等待请求批处理执行</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.outstandingReqBatches<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">map</span>[<span style="color:#000080;">string</span>]*RequestBatch)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//对于所有已经分配我们可能错过的在视图改变期间的非检查点的请求批次</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.missingReqBatches<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span><span style="color:#000080;">make</span>(<span style="font-weight:600;color:#000080;">map</span>[<span style="color:#000080;">string</span>]<span style="color:#000080;">bool</span>)</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//将变量的值恢复到初始状态</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.restoreState()</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">执行视图改变的下一个序号</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.viewChangeSeqNo<span style="color:#c0c0c0;"> </span>=<span style="color:#c0c0c0;"> </span>^<span style="color:#000080;">uint64</span>(<span style="color:#800080;">0</span>)<span style="color:#c0c0c0;"> </span><span style="color:#008000;">//</span><span style="color:#c0c0c0;"> </span><span style="color:#008000;">infinity</span></pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//更新视图改变序列号</span></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span>instance.updateViewChangeSeqNo()</pre> 
  <pre></pre> 
  <pre><span style="color:#c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;color:#000080;">return</span><span style="color:#c0c0c0;"> </span>instance</pre> 
  <pre>}</pre> 
  <br>
  <p></p> 
  <p><img src="https://blog.uzzz.org/_p?https://img-blog.csdn.net/20161221172823748?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmdfeGlueGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p> 
  <p>代码走到newPbftCore的过程，等待下周更新...........</p> 
  <p><br></p> 
  <p><br></p> 
  <p><br></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jiang_xinxing/article/details/53787071,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/jiang_xinxing/article/details/53787071,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
