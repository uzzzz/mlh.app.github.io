<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Excel添加SHA256计算函数 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Excel添加SHA256计算函数" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="工作中需要将一批Email地址转换成SHA256的值，能想到的最方便的方法莫过于通过Excel的VBA来实现了，但是从来没有写过VBA的程序，百度也没搜到有用信息，只能去Google上查，很Easy的在Stackoverflow找到一个有用的问答： 参考问答： http://stackoverflow.com/questions/22672564/porting-sha-256-library-to-excel 操作成功后，将详细过程记录一下，当作备忘，也方便其他人参考。 本文以Excel2010为例进行操作，同时在WPS2013上验证也没有问题。 下面是详细步骤： 1、点击“开发工具”页面的“Visual Basic” 2、在打开界面的“工程”空白处点击右键，选择插入类模块 3、在打开的类1文件中输入以下代码 &#39;******************************************************************************* &#39; MODULE: CSHA256 &#39; FILENAME: CSHA256.cls &#39; AUTHOR: Phil Fresle &#39; CREATED: 10-Apr-2001 &#39; COPYRIGHT: Copyright 2001 Phil Fresle. All Rights Reserved. &#39; &#39; DESCRIPTION: &#39; This class is used to generate a SHA-256 &#39;digest&#39; or &#39;signature&#39; of a string. &#39; The SHA-256 algorithm is one of the industry standard methods for generating &#39; digital signatures. It is generically known as a digest, digital signature, &#39; one-way encryption, hash or checksum algorithm. A common use for SHA-256 is &#39; for password encryption as it is one-way in nature, that does not mean that &#39; your passwords are not free from a dictionary attack. If you are using the &#39; routine for passwords, you can make it a little more secure by concatenating &#39; some known random characters to the password before you generate the signature &#39; and on subsequent tests, so even if a hacker knows you are using SHA-256 for &#39; your passwords, the random characters will make it harder to dictionary attack. &#39; &#39; *** CAUTION *** &#39; See the comment attached to the SHA256 method below regarding use on systems &#39; with different character sets. &#39; &#39; This is &#39;free&#39; software with the following restrictions: &#39; &#39; You may not redistribute this code as a &#39;sample&#39; or &#39;demo&#39;. However, you are free &#39; to use the source code in your own code, but you may not claim that you created &#39; the sample code. It is expressly forbidden to sell or profit from this source code &#39; other than by the knowledge gained or the enhanced value added by your own code. &#39; &#39; Use of this software is also done so at your own risk. The code is supplied as &#39; is without warranty or guarantee of any kind. &#39; &#39; Should you wish to commission some derivative work based on this code provided &#39; here, or any consultancy work, please do not hesitate to contact us. &#39; &#39; Web Site: http://www.frez.co.uk &#39; E-mail: sales@frez.co.uk &#39; &#39; MODIFICATION HISTORY: &#39; 10-Apr-2001 Phil Fresle Initial Version &#39;******************************************************************************* Option Explicit Private m_lOnBits(30) As Long Private m_l2Power(30) As Long Private K(63) As Long Private Const BITS_TO_A_BYTE As Long = 8 Private Const BYTES_TO_A_WORD As Long = 4 Private Const BITS_TO_A_WORD As Long = BYTES_TO_A_WORD * BITS_TO_A_BYTE &#39;******************************************************************************* &#39; Class_Initialize (SUB) &#39;******************************************************************************* Private Sub Class_Initialize() &#39; Could have done this with a loop calculating each value, but simply &#39; assigning the values is quicker - BITS SET FROM RIGHT m_lOnBits(0) = 1 &#39; 00000000000000000000000000000001 m_lOnBits(1) = 3 &#39; 00000000000000000000000000000011 m_lOnBits(2) = 7 &#39; 00000000000000000000000000000111 m_lOnBits(3) = 15 &#39; 00000000000000000000000000001111 m_lOnBits(4) = 31 &#39; 00000000000000000000000000011111 m_lOnBits(5) = 63 &#39; 00000000000000000000000000111111 m_lOnBits(6) = 127 &#39; 00000000000000000000000001111111 m_lOnBits(7) = 255 &#39; 00000000000000000000000011111111 m_lOnBits(8) = 511 &#39; 00000000000000000000000111111111 m_lOnBits(9) = 1023 &#39; 00000000000000000000001111111111 m_lOnBits(10) = 2047 &#39; 00000000000000000000011111111111 m_lOnBits(11) = 4095 &#39; 00000000000000000000111111111111 m_lOnBits(12) = 8191 &#39; 00000000000000000001111111111111 m_lOnBits(13) = 16383 &#39; 00000000000000000011111111111111 m_lOnBits(14) = 32767 &#39; 00000000000000000111111111111111 m_lOnBits(15) = 65535 &#39; 00000000000000001111111111111111 m_lOnBits(16) = 131071 &#39; 00000000000000011111111111111111 m_lOnBits(17) = 262143 &#39; 00000000000000111111111111111111 m_lOnBits(18) = 524287 &#39; 00000000000001111111111111111111 m_lOnBits(19) = 1048575 &#39; 00000000000011111111111111111111 m_lOnBits(20) = 2097151 &#39; 00000000000111111111111111111111 m_lOnBits(21) = 4194303 &#39; 00000000001111111111111111111111 m_lOnBits(22) = 8388607 &#39; 00000000011111111111111111111111 m_lOnBits(23) = 16777215 &#39; 00000000111111111111111111111111 m_lOnBits(24) = 33554431 &#39; 00000001111111111111111111111111 m_lOnBits(25) = 67108863 &#39; 00000011111111111111111111111111 m_lOnBits(26) = 134217727 &#39; 00000111111111111111111111111111 m_lOnBits(27) = 268435455 &#39; 00001111111111111111111111111111 m_lOnBits(28) = 536870911 &#39; 00011111111111111111111111111111 m_lOnBits(29) = 1073741823 &#39; 00111111111111111111111111111111 m_lOnBits(30) = 2147483647 &#39; 01111111111111111111111111111111 &#39; Could have done this with a loop calculating each value, but simply &#39; assigning the values is quicker - POWERS OF 2 m_l2Power(0) = 1 &#39; 00000000000000000000000000000001 m_l2Power(1) = 2 &#39; 00000000000000000000000000000010 m_l2Power(2) = 4 &#39; 00000000000000000000000000000100 m_l2Power(3) = 8 &#39; 00000000000000000000000000001000 m_l2Power(4) = 16 &#39; 00000000000000000000000000010000 m_l2Power(5) = 32 &#39; 00000000000000000000000000100000 m_l2Power(6) = 64 &#39; 00000000000000000000000001000000 m_l2Power(7) = 128 &#39; 00000000000000000000000010000000 m_l2Power(8) = 256 &#39; 00000000000000000000000100000000 m_l2Power(9) = 512 &#39; 00000000000000000000001000000000 m_l2Power(10) = 1024 &#39; 00000000000000000000010000000000 m_l2Power(11) = 2048 &#39; 00000000000000000000100000000000 m_l2Power(12) = 4096 &#39; 00000000000000000001000000000000 m_l2Power(13) = 8192 &#39; 00000000000000000010000000000000 m_l2Power(14) = 16384 &#39; 00000000000000000100000000000000 m_l2Power(15) = 32768 &#39; 00000000000000001000000000000000 m_l2Power(16) = 65536 &#39; 00000000000000010000000000000000 m_l2Power(17) = 131072 &#39; 00000000000000100000000000000000 m_l2Power(18) = 262144 &#39; 00000000000001000000000000000000 m_l2Power(19) = 524288 &#39; 00000000000010000000000000000000 m_l2Power(20) = 1048576 &#39; 00000000000100000000000000000000 m_l2Power(21) = 2097152 &#39; 00000000001000000000000000000000 m_l2Power(22) = 4194304 &#39; 00000000010000000000000000000000 m_l2Power(23) = 8388608 &#39; 00000000100000000000000000000000 m_l2Power(24) = 16777216 &#39; 00000001000000000000000000000000 m_l2Power(25) = 33554432 &#39; 00000010000000000000000000000000 m_l2Power(26) = 67108864 &#39; 00000100000000000000000000000000 m_l2Power(27) = 134217728 &#39; 00001000000000000000000000000000 m_l2Power(28) = 268435456 &#39; 00010000000000000000000000000000 m_l2Power(29) = 536870912 &#39; 00100000000000000000000000000000 m_l2Power(30) = 1073741824 &#39; 01000000000000000000000000000000 &#39; Just put together the K array once K(0) = &amp;H428A2F98 K(1) = &amp;H71374491 K(2) = &amp;HB5C0FBCF K(3) = &amp;HE9B5DBA5 K(4) = &amp;H3956C25B K(5) = &amp;H59F111F1 K(6) = &amp;H923F82A4 K(7) = &amp;HAB1C5ED5 K(8) = &amp;HD807AA98 K(9) = &amp;H12835B01 K(10) = &amp;H243185BE K(11) = &amp;H550C7DC3 K(12) = &amp;H72BE5D74 K(13) = &amp;H80DEB1FE K(14) = &amp;H9BDC06A7 K(15) = &amp;HC19BF174 K(16) = &amp;HE49B69C1 K(17) = &amp;HEFBE4786 K(18) = &amp;HFC19DC6 K(19) = &amp;H240CA1CC K(20) = &amp;H2DE92C6F K(21) = &amp;H4A7484AA K(22) = &amp;H5CB0A9DC K(23) = &amp;H76F988DA K(24) = &amp;H983E5152 K(25) = &amp;HA831C66D K(26) = &amp;HB00327C8 K(27) = &amp;HBF597FC7 K(28) = &amp;HC6E00BF3 K(29) = &amp;HD5A79147 K(30) = &amp;H6CA6351 K(31) = &amp;H14292967 K(32) = &amp;H27B70A85 K(33) = &amp;H2E1B2138 K(34) = &amp;H4D2C6DFC K(35) = &amp;H53380D13 K(36) = &amp;H650A7354 K(37) = &amp;H766A0ABB K(38) = &amp;H81C2C92E K(39) = &amp;H92722C85 K(40) = &amp;HA2BFE8A1 K(41) = &amp;HA81A664B K(42) = &amp;HC24B8B70 K(43) = &amp;HC76C51A3 K(44) = &amp;HD192E819 K(45) = &amp;HD6990624 K(46) = &amp;HF40E3585 K(47) = &amp;H106AA070 K(48) = &amp;H19A4C116 K(49) = &amp;H1E376C08 K(50) = &amp;H2748774C K(51) = &amp;H34B0BCB5 K(52) = &amp;H391C0CB3 K(53) = &amp;H4ED8AA4A K(54) = &amp;H5B9CCA4F K(55) = &amp;H682E6FF3 K(56) = &amp;H748F82EE K(57) = &amp;H78A5636F K(58) = &amp;H84C87814 K(59) = &amp;H8CC70208 K(60) = &amp;H90BEFFFA K(61) = &amp;HA4506CEB K(62) = &amp;HBEF9A3F7 K(63) = &amp;HC67178F2 End Sub &#39;******************************************************************************* &#39; LShift (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In) - lValue - Long - The value to be shifted &#39; (In) - iShiftBits - Integer - The number of bits to shift the value by &#39; &#39; RETURN VALUE: &#39; Long - The shifted long integer &#39; &#39; DESCRIPTION: &#39; A left shift takes all the set binary bits and moves them left, in-filling &#39; with zeros in the vacated bits on the right. This function is equivalent to &#39; the &lt;&lt; operator in Java and C++ &#39;******************************************************************************* Private Function LShift(ByVal lValue As Long, _ ByVal iShiftBits As Integer) As Long &#39; NOTE: If you can guarantee that the Shift parameter will be in the &#39; range 1 to 30 you can safely strip of this first nested if structure for &#39; speed. &#39; &#39; A shift of zero is no shift at all. If iShiftBits = 0 Then LShift = lValue Exit Function &#39; A shift of 31 will result in the right most bit becoming the left most &#39; bit and all other bits being cleared ElseIf iShiftBits = 31 Then If lValue And 1 Then LShift = &amp;H80000000 Else LShift = 0 End If Exit Function &#39; A shift of less than zero or more than 31 is undefined ElseIf iShiftBits &lt; 0 Or iShiftBits &gt; 31 Then Err.Raise 6 End If &#39; If the left most bit that remains will end up in the negative bit &#39; position (&amp;H80000000) we would end up with an overflow if we took the &#39; standard route. We need to strip the left most bit and add it back &#39; afterwards. If (lValue And m_l2Power(31 - iShiftBits)) Then &#39; (Value And OnBits(31 - (Shift + 1))) chops off the left most bits that &#39; we are shifting into, but also the left most bit we still want as this &#39; is going to end up in the negative bit marker position (&amp;H80000000). &#39; After the multiplication/shift we Or the result with &amp;H80000000 to &#39; turn the negative bit on. LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * _ m_l2Power(iShiftBits)) Or &amp;H80000000 Else &#39; (Value And OnBits(31-Shift)) chops off the left most bits that we are &#39; shifting into so we do not get an overflow error when we do the &#39; multiplication/shift LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * _ m_l2Power(iShiftBits)) End If End Function &#39;******************************************************************************* &#39; RShift (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In) - lValue - Long - The value to be shifted &#39; (In) - iShiftBits - Integer - The number of bits to shift the value by &#39; &#39; RETURN VALUE: &#39; Long - The shifted long integer &#39; &#39; DESCRIPTION: &#39; The right shift of an unsigned long integer involves shifting all the set bits &#39; to the right and in-filling on the left with zeros. This function is &#39; equivalent to the &gt;&gt;&gt; operator in Java or the &gt;&gt; operator in C++ when used on &#39; an unsigned long. &#39;******************************************************************************* Private Function RShift(ByVal lValue As Long, _ ByVal iShiftBits As Integer) As Long &#39; NOTE: If you can guarantee that the Shift parameter will be in the &#39; range 1 to 30 you can safely strip of this first nested if structure for &#39; speed. &#39; &#39; A shift of zero is no shift at all If iShiftBits = 0 Then RShift = lValue Exit Function &#39; A shift of 31 will clear all bits and move the left most bit to the right &#39; most bit position ElseIf iShiftBits = 31 Then If lValue And &amp;H80000000 Then RShift = 1 Else RShift = 0 End If Exit Function &#39; A shift of less than zero or more than 31 is undefined ElseIf iShiftBits &lt; 0 Or iShiftBits &gt; 31 Then Err.Raise 6 End If &#39; We do not care about the top most bit or the final bit, the top most bit &#39; will be taken into account in the next stage, the final bit (whether it &#39; is an odd number or not) is being shifted into, so we do not give a jot &#39; about it RShift = (lValue And &amp;H7FFFFFFE) \ m_l2Power(iShiftBits) &#39; If the top most bit (&amp;H80000000) was set we need to do things differently &#39; as in a normal VB signed long integer the top most bit is used to indicate &#39; the sign of the number, when it is set it is a negative number, so just &#39; deviding by a factor of 2 as above would not work. &#39; NOTE: (lValue And &amp;H80000000) is equivalent to (lValue &lt; 0), you could &#39; get a very marginal speed improvement by changing the test to (lValue &lt; 0) If (lValue And &amp;H80000000) Then &#39; We take the value computed so far, and then add the left most negative &#39; bit after it has been shifted to the right the appropriate number of &#39; places RShift = (RShift Or (&amp;H40000000 \ m_l2Power(iShiftBits - 1))) End If End Function &#39;******************************************************************************* &#39; AddUnsigned (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In) - lX - Long - First value &#39; (In) - lY - Long - Second value &#39; &#39; RETURN VALUE: &#39; Long - Result &#39; &#39; DESCRIPTION: &#39; Adds two potentially large unsigned numbers without overflowing &#39;******************************************************************************* Private Function AddUnsigned(ByVal lX As Long, _ ByVal lY As Long) As Long Dim lX4 As Long Dim lY4 As Long Dim lX8 As Long Dim lY8 As Long Dim lResult As Long lX8 = lX And &amp;H80000000 lY8 = lY And &amp;H80000000 lX4 = lX And &amp;H40000000 lY4 = lY And &amp;H40000000 lResult = (lX And &amp;H3FFFFFFF) + (lY And &amp;H3FFFFFFF) If lX4 And lY4 Then lResult = lResult Xor &amp;H80000000 Xor lX8 Xor lY8 ElseIf lX4 Or lY4 Then If lResult And &amp;H40000000 Then lResult = lResult Xor &amp;HC0000000 Xor lX8 Xor lY8 Else lResult = lResult Xor &amp;H40000000 Xor lX8 Xor lY8 End If Else lResult = lResult Xor lX8 Xor lY8 End If AddUnsigned = lResult End Function &#39;******************************************************************************* &#39; Ch (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Ch(ByVal x As Long, _ ByVal y As Long, _ ByVal z As Long) As Long Ch = ((x And y) Xor ((Not x) And z)) End Function &#39;******************************************************************************* &#39; Maj (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Maj(ByVal x As Long, _ ByVal y As Long, _ ByVal z As Long) As Long Maj = ((x And y) Xor (x And z) Xor (y And z)) End Function &#39;******************************************************************************* &#39; S (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function (rotate right) &#39;******************************************************************************* Private Function S(ByVal x As Long, _ ByVal n As Long) As Long S = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4))))) End Function &#39;******************************************************************************* &#39; R (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function (just a right shift) &#39;******************************************************************************* Private Function R(ByVal x As Long, _ ByVal n As Long) As Long R = RShift(x, CInt(n And m_lOnBits(4))) End Function &#39;******************************************************************************* &#39; Sigma0 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Sigma0(ByVal x As Long) As Long Sigma0 = (S(x, 2) Xor S(x, 13) Xor S(x, 22)) End Function &#39;******************************************************************************* &#39; Sigma1 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Sigma1(ByVal x As Long) As Long Sigma1 = (S(x, 6) Xor S(x, 11) Xor S(x, 25)) End Function &#39;******************************************************************************* &#39; Gamma0 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Gamma0(ByVal x As Long) As Long Gamma0 = (S(x, 7) Xor S(x, 18) Xor R(x, 3)) End Function &#39;******************************************************************************* &#39; Gamma1 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Gamma1(ByVal x As Long) As Long Gamma1 = (S(x, 17) Xor S(x, 19) Xor R(x, 10)) End Function &#39;******************************************************************************* &#39; ConvertToWordArray (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In/Out) - sMessage - String - String message &#39; &#39; RETURN VALUE: &#39; Long() - Converted message as long array &#39; &#39; DESCRIPTION: &#39; Takes the string message and puts it in a long array with padding according to &#39; the SHA-256 rules (similar to MD5 routine). &#39;******************************************************************************* Private Function ConvertToWordArray(sMessage As String) As Long() Dim lMessageLength As Long Dim lNumberOfWords As Long Dim lWordArray() As Long Dim lBytePosition As Long Dim lByteCount As Long Dim lWordCount As Long Dim lByte As Long Const MODULUS_BITS As Long = 512 Const CONGRUENT_BITS As Long = 448 lMessageLength = Len(sMessage) &#39; Get padded number of words. Message needs to be congruent to 448 bits, &#39; modulo 512 bits. If it is exactly congruent to 448 bits, modulo 512 bits &#39; it must still have another 512 bits added. 512 bits = 64 bytes &#39; (or 16 * 4 byte words), 448 bits = 56 bytes. This means lNumberOfWords must &#39; be a multiple of 16 (i.e. 16 * 4 (bytes) * 8 (bits)) lNumberOfWords = (((lMessageLength + _ ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ _ (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * _ (MODULUS_BITS \ BITS_TO_A_WORD) ReDim lWordArray(lNumberOfWords - 1) &#39; Combine each block of 4 bytes (ascii code of character) into one long &#39; value and store in the message. The high-order (most significant) bit of &#39; each byte is listed first. However, unlike MD5 we put the high-order &#39; (most significant) byte first in each word. lBytePosition = 0 lByteCount = 0 Do Until lByteCount &gt;= lMessageLength &#39; Each word is 4 bytes lWordCount = lByteCount \ BYTES_TO_A_WORD lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE &#39; NOTE: This is where we are using just the first byte of each unicode &#39; character, you may want to make the change here, or to the SHA256 method &#39; so it accepts a byte array. lByte = AscB(Mid(sMessage, lByteCount + 1, 1)) lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition) lByteCount = lByteCount + 1 Loop &#39; Terminate according to SHA-256 rules with a 1 bit, zeros and the length in &#39; bits stored in the last two words lWordCount = lByteCount \ BYTES_TO_A_WORD lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE &#39; Add a terminating 1 bit, all the rest of the bits to the end of the &#39; word array will default to zero lWordArray(lWordCount) = lWordArray(lWordCount) Or _ LShift(&amp;H80, lBytePosition) &#39; We put the length of the message in bits into the last two words, to get &#39; the length in bits we need to multiply by 8 (or left shift 3). This left &#39; shifted value is put in the last word. Any bits shifted off the left edge &#39; need to be put in the penultimate word, we can work out which bits by shifting &#39; right the length by 29 bits. lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3) lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29) ConvertToWordArray = lWordArray End Function &#39;******************************************************************************* &#39; SHA256 (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In/Out) - sMessage - String - Message to digest &#39; &#39; RETURN VALUE: &#39; String - The digest &#39; &#39; DESCRIPTION: &#39; Takes a string and uses the SHA-256 digest to produce a signature for it. &#39; &#39; NOTE: Due to the way in which the string is processed the routine assumes a &#39; single byte character set. VB passes unicode (2-byte) character strings, the &#39; ConvertToWordArray function uses on the first byte for each character. This &#39; has been done this way for ease of use, to make the routine truely portable &#39; you could accept a byte array instead, it would then be up to the calling &#39; routine to make sure that the byte array is generated from their string in &#39; a manner consistent with the string type. &#39;******************************************************************************* Public Function SHA256(sMessage As String) As String Dim HASH(7) As Long Dim M() As Long Dim W(63) As Long Dim a As Long Dim b As Long Dim c As Long Dim d As Long Dim e As Long Dim f As Long Dim g As Long Dim h As Long Dim i As Long Dim j As Long Dim T1 As Long Dim T2 As Long &#39; Initial hash values HASH(0) = &amp;H6A09E667 HASH(1) = &amp;HBB67AE85 HASH(2) = &amp;H3C6EF372 HASH(3) = &amp;HA54FF53A HASH(4) = &amp;H510E527F HASH(5) = &amp;H9B05688C HASH(6) = &amp;H1F83D9AB HASH(7) = &amp;H5BE0CD19 &#39; Preprocessing. Append padding bits and length and convert to words M = ConvertToWordArray(sMessage) &#39; Main loop For i = 0 To UBound(M) Step 16 a = HASH(0) b = HASH(1) c = HASH(2) d = HASH(3) e = HASH(4) f = HASH(5) g = HASH(6) h = HASH(7) For j = 0 To 63 If j &lt; 16 Then W(j) = M(j + i) Else W(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(W(j - 2)), _ W(j - 7)), Gamma0(W(j - 15))), W(j - 16)) End If T1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(h, Sigma1(e)), _ Ch(e, f, g)), K(j)), W(j)) T2 = AddUnsigned(Sigma0(a), Maj(a, b, c)) h = g g = f f = e e = AddUnsigned(d, T1) d = c c = b b = a a = AddUnsigned(T1, T2) Next HASH(0) = AddUnsigned(a, HASH(0)) HASH(1) = AddUnsigned(b, HASH(1)) HASH(2) = AddUnsigned(c, HASH(2)) HASH(3) = AddUnsigned(d, HASH(3)) HASH(4) = AddUnsigned(e, HASH(4)) HASH(5) = AddUnsigned(f, HASH(5)) HASH(6) = AddUnsigned(g, HASH(6)) HASH(7) = AddUnsigned(h, HASH(7)) Next &#39; Output the 256 bit digest SHA256 = LCase(Right(&quot;00000000&quot; &amp; Hex(HASH(0)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(1)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(2)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(3)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(4)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(5)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(6)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(7)), 8)) End Function 4、在属性里面修改模块类名为CSHA256（属性窗口通常在左边，如果没有看到属性窗口就自己打开它，在“视图”菜单中点击“属性窗口”） 5、再次在界面的“工程”空白处点击右键，选择插入模块，模块中输入以下代码 Public Function FunSHA256(sMessage As String) Dim clsX As CSHA256 Set clsX = New CSHA256 FunSHA256 = clsX.SHA256(sMessage) Set clsX = Nothing End Function 6、保存并关闭，然后在该Excel中就可以通过调用函数FunSHA256来计算SHA256值了。 最后和网上的一些在线程序对比下结果，没问题的话就可以了。比如：Email地址 example@gmail.com经过哈希处理后的值为 264e53d93759bde067fd01ef2698f98d1253c730d12f021116f02eebcfa9ace6。 查看原文： http://xuhehuan.com/2310.html 阅读更多" />
<meta property="og:description" content="工作中需要将一批Email地址转换成SHA256的值，能想到的最方便的方法莫过于通过Excel的VBA来实现了，但是从来没有写过VBA的程序，百度也没搜到有用信息，只能去Google上查，很Easy的在Stackoverflow找到一个有用的问答： 参考问答： http://stackoverflow.com/questions/22672564/porting-sha-256-library-to-excel 操作成功后，将详细过程记录一下，当作备忘，也方便其他人参考。 本文以Excel2010为例进行操作，同时在WPS2013上验证也没有问题。 下面是详细步骤： 1、点击“开发工具”页面的“Visual Basic” 2、在打开界面的“工程”空白处点击右键，选择插入类模块 3、在打开的类1文件中输入以下代码 &#39;******************************************************************************* &#39; MODULE: CSHA256 &#39; FILENAME: CSHA256.cls &#39; AUTHOR: Phil Fresle &#39; CREATED: 10-Apr-2001 &#39; COPYRIGHT: Copyright 2001 Phil Fresle. All Rights Reserved. &#39; &#39; DESCRIPTION: &#39; This class is used to generate a SHA-256 &#39;digest&#39; or &#39;signature&#39; of a string. &#39; The SHA-256 algorithm is one of the industry standard methods for generating &#39; digital signatures. It is generically known as a digest, digital signature, &#39; one-way encryption, hash or checksum algorithm. A common use for SHA-256 is &#39; for password encryption as it is one-way in nature, that does not mean that &#39; your passwords are not free from a dictionary attack. If you are using the &#39; routine for passwords, you can make it a little more secure by concatenating &#39; some known random characters to the password before you generate the signature &#39; and on subsequent tests, so even if a hacker knows you are using SHA-256 for &#39; your passwords, the random characters will make it harder to dictionary attack. &#39; &#39; *** CAUTION *** &#39; See the comment attached to the SHA256 method below regarding use on systems &#39; with different character sets. &#39; &#39; This is &#39;free&#39; software with the following restrictions: &#39; &#39; You may not redistribute this code as a &#39;sample&#39; or &#39;demo&#39;. However, you are free &#39; to use the source code in your own code, but you may not claim that you created &#39; the sample code. It is expressly forbidden to sell or profit from this source code &#39; other than by the knowledge gained or the enhanced value added by your own code. &#39; &#39; Use of this software is also done so at your own risk. The code is supplied as &#39; is without warranty or guarantee of any kind. &#39; &#39; Should you wish to commission some derivative work based on this code provided &#39; here, or any consultancy work, please do not hesitate to contact us. &#39; &#39; Web Site: http://www.frez.co.uk &#39; E-mail: sales@frez.co.uk &#39; &#39; MODIFICATION HISTORY: &#39; 10-Apr-2001 Phil Fresle Initial Version &#39;******************************************************************************* Option Explicit Private m_lOnBits(30) As Long Private m_l2Power(30) As Long Private K(63) As Long Private Const BITS_TO_A_BYTE As Long = 8 Private Const BYTES_TO_A_WORD As Long = 4 Private Const BITS_TO_A_WORD As Long = BYTES_TO_A_WORD * BITS_TO_A_BYTE &#39;******************************************************************************* &#39; Class_Initialize (SUB) &#39;******************************************************************************* Private Sub Class_Initialize() &#39; Could have done this with a loop calculating each value, but simply &#39; assigning the values is quicker - BITS SET FROM RIGHT m_lOnBits(0) = 1 &#39; 00000000000000000000000000000001 m_lOnBits(1) = 3 &#39; 00000000000000000000000000000011 m_lOnBits(2) = 7 &#39; 00000000000000000000000000000111 m_lOnBits(3) = 15 &#39; 00000000000000000000000000001111 m_lOnBits(4) = 31 &#39; 00000000000000000000000000011111 m_lOnBits(5) = 63 &#39; 00000000000000000000000000111111 m_lOnBits(6) = 127 &#39; 00000000000000000000000001111111 m_lOnBits(7) = 255 &#39; 00000000000000000000000011111111 m_lOnBits(8) = 511 &#39; 00000000000000000000000111111111 m_lOnBits(9) = 1023 &#39; 00000000000000000000001111111111 m_lOnBits(10) = 2047 &#39; 00000000000000000000011111111111 m_lOnBits(11) = 4095 &#39; 00000000000000000000111111111111 m_lOnBits(12) = 8191 &#39; 00000000000000000001111111111111 m_lOnBits(13) = 16383 &#39; 00000000000000000011111111111111 m_lOnBits(14) = 32767 &#39; 00000000000000000111111111111111 m_lOnBits(15) = 65535 &#39; 00000000000000001111111111111111 m_lOnBits(16) = 131071 &#39; 00000000000000011111111111111111 m_lOnBits(17) = 262143 &#39; 00000000000000111111111111111111 m_lOnBits(18) = 524287 &#39; 00000000000001111111111111111111 m_lOnBits(19) = 1048575 &#39; 00000000000011111111111111111111 m_lOnBits(20) = 2097151 &#39; 00000000000111111111111111111111 m_lOnBits(21) = 4194303 &#39; 00000000001111111111111111111111 m_lOnBits(22) = 8388607 &#39; 00000000011111111111111111111111 m_lOnBits(23) = 16777215 &#39; 00000000111111111111111111111111 m_lOnBits(24) = 33554431 &#39; 00000001111111111111111111111111 m_lOnBits(25) = 67108863 &#39; 00000011111111111111111111111111 m_lOnBits(26) = 134217727 &#39; 00000111111111111111111111111111 m_lOnBits(27) = 268435455 &#39; 00001111111111111111111111111111 m_lOnBits(28) = 536870911 &#39; 00011111111111111111111111111111 m_lOnBits(29) = 1073741823 &#39; 00111111111111111111111111111111 m_lOnBits(30) = 2147483647 &#39; 01111111111111111111111111111111 &#39; Could have done this with a loop calculating each value, but simply &#39; assigning the values is quicker - POWERS OF 2 m_l2Power(0) = 1 &#39; 00000000000000000000000000000001 m_l2Power(1) = 2 &#39; 00000000000000000000000000000010 m_l2Power(2) = 4 &#39; 00000000000000000000000000000100 m_l2Power(3) = 8 &#39; 00000000000000000000000000001000 m_l2Power(4) = 16 &#39; 00000000000000000000000000010000 m_l2Power(5) = 32 &#39; 00000000000000000000000000100000 m_l2Power(6) = 64 &#39; 00000000000000000000000001000000 m_l2Power(7) = 128 &#39; 00000000000000000000000010000000 m_l2Power(8) = 256 &#39; 00000000000000000000000100000000 m_l2Power(9) = 512 &#39; 00000000000000000000001000000000 m_l2Power(10) = 1024 &#39; 00000000000000000000010000000000 m_l2Power(11) = 2048 &#39; 00000000000000000000100000000000 m_l2Power(12) = 4096 &#39; 00000000000000000001000000000000 m_l2Power(13) = 8192 &#39; 00000000000000000010000000000000 m_l2Power(14) = 16384 &#39; 00000000000000000100000000000000 m_l2Power(15) = 32768 &#39; 00000000000000001000000000000000 m_l2Power(16) = 65536 &#39; 00000000000000010000000000000000 m_l2Power(17) = 131072 &#39; 00000000000000100000000000000000 m_l2Power(18) = 262144 &#39; 00000000000001000000000000000000 m_l2Power(19) = 524288 &#39; 00000000000010000000000000000000 m_l2Power(20) = 1048576 &#39; 00000000000100000000000000000000 m_l2Power(21) = 2097152 &#39; 00000000001000000000000000000000 m_l2Power(22) = 4194304 &#39; 00000000010000000000000000000000 m_l2Power(23) = 8388608 &#39; 00000000100000000000000000000000 m_l2Power(24) = 16777216 &#39; 00000001000000000000000000000000 m_l2Power(25) = 33554432 &#39; 00000010000000000000000000000000 m_l2Power(26) = 67108864 &#39; 00000100000000000000000000000000 m_l2Power(27) = 134217728 &#39; 00001000000000000000000000000000 m_l2Power(28) = 268435456 &#39; 00010000000000000000000000000000 m_l2Power(29) = 536870912 &#39; 00100000000000000000000000000000 m_l2Power(30) = 1073741824 &#39; 01000000000000000000000000000000 &#39; Just put together the K array once K(0) = &amp;H428A2F98 K(1) = &amp;H71374491 K(2) = &amp;HB5C0FBCF K(3) = &amp;HE9B5DBA5 K(4) = &amp;H3956C25B K(5) = &amp;H59F111F1 K(6) = &amp;H923F82A4 K(7) = &amp;HAB1C5ED5 K(8) = &amp;HD807AA98 K(9) = &amp;H12835B01 K(10) = &amp;H243185BE K(11) = &amp;H550C7DC3 K(12) = &amp;H72BE5D74 K(13) = &amp;H80DEB1FE K(14) = &amp;H9BDC06A7 K(15) = &amp;HC19BF174 K(16) = &amp;HE49B69C1 K(17) = &amp;HEFBE4786 K(18) = &amp;HFC19DC6 K(19) = &amp;H240CA1CC K(20) = &amp;H2DE92C6F K(21) = &amp;H4A7484AA K(22) = &amp;H5CB0A9DC K(23) = &amp;H76F988DA K(24) = &amp;H983E5152 K(25) = &amp;HA831C66D K(26) = &amp;HB00327C8 K(27) = &amp;HBF597FC7 K(28) = &amp;HC6E00BF3 K(29) = &amp;HD5A79147 K(30) = &amp;H6CA6351 K(31) = &amp;H14292967 K(32) = &amp;H27B70A85 K(33) = &amp;H2E1B2138 K(34) = &amp;H4D2C6DFC K(35) = &amp;H53380D13 K(36) = &amp;H650A7354 K(37) = &amp;H766A0ABB K(38) = &amp;H81C2C92E K(39) = &amp;H92722C85 K(40) = &amp;HA2BFE8A1 K(41) = &amp;HA81A664B K(42) = &amp;HC24B8B70 K(43) = &amp;HC76C51A3 K(44) = &amp;HD192E819 K(45) = &amp;HD6990624 K(46) = &amp;HF40E3585 K(47) = &amp;H106AA070 K(48) = &amp;H19A4C116 K(49) = &amp;H1E376C08 K(50) = &amp;H2748774C K(51) = &amp;H34B0BCB5 K(52) = &amp;H391C0CB3 K(53) = &amp;H4ED8AA4A K(54) = &amp;H5B9CCA4F K(55) = &amp;H682E6FF3 K(56) = &amp;H748F82EE K(57) = &amp;H78A5636F K(58) = &amp;H84C87814 K(59) = &amp;H8CC70208 K(60) = &amp;H90BEFFFA K(61) = &amp;HA4506CEB K(62) = &amp;HBEF9A3F7 K(63) = &amp;HC67178F2 End Sub &#39;******************************************************************************* &#39; LShift (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In) - lValue - Long - The value to be shifted &#39; (In) - iShiftBits - Integer - The number of bits to shift the value by &#39; &#39; RETURN VALUE: &#39; Long - The shifted long integer &#39; &#39; DESCRIPTION: &#39; A left shift takes all the set binary bits and moves them left, in-filling &#39; with zeros in the vacated bits on the right. This function is equivalent to &#39; the &lt;&lt; operator in Java and C++ &#39;******************************************************************************* Private Function LShift(ByVal lValue As Long, _ ByVal iShiftBits As Integer) As Long &#39; NOTE: If you can guarantee that the Shift parameter will be in the &#39; range 1 to 30 you can safely strip of this first nested if structure for &#39; speed. &#39; &#39; A shift of zero is no shift at all. If iShiftBits = 0 Then LShift = lValue Exit Function &#39; A shift of 31 will result in the right most bit becoming the left most &#39; bit and all other bits being cleared ElseIf iShiftBits = 31 Then If lValue And 1 Then LShift = &amp;H80000000 Else LShift = 0 End If Exit Function &#39; A shift of less than zero or more than 31 is undefined ElseIf iShiftBits &lt; 0 Or iShiftBits &gt; 31 Then Err.Raise 6 End If &#39; If the left most bit that remains will end up in the negative bit &#39; position (&amp;H80000000) we would end up with an overflow if we took the &#39; standard route. We need to strip the left most bit and add it back &#39; afterwards. If (lValue And m_l2Power(31 - iShiftBits)) Then &#39; (Value And OnBits(31 - (Shift + 1))) chops off the left most bits that &#39; we are shifting into, but also the left most bit we still want as this &#39; is going to end up in the negative bit marker position (&amp;H80000000). &#39; After the multiplication/shift we Or the result with &amp;H80000000 to &#39; turn the negative bit on. LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * _ m_l2Power(iShiftBits)) Or &amp;H80000000 Else &#39; (Value And OnBits(31-Shift)) chops off the left most bits that we are &#39; shifting into so we do not get an overflow error when we do the &#39; multiplication/shift LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * _ m_l2Power(iShiftBits)) End If End Function &#39;******************************************************************************* &#39; RShift (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In) - lValue - Long - The value to be shifted &#39; (In) - iShiftBits - Integer - The number of bits to shift the value by &#39; &#39; RETURN VALUE: &#39; Long - The shifted long integer &#39; &#39; DESCRIPTION: &#39; The right shift of an unsigned long integer involves shifting all the set bits &#39; to the right and in-filling on the left with zeros. This function is &#39; equivalent to the &gt;&gt;&gt; operator in Java or the &gt;&gt; operator in C++ when used on &#39; an unsigned long. &#39;******************************************************************************* Private Function RShift(ByVal lValue As Long, _ ByVal iShiftBits As Integer) As Long &#39; NOTE: If you can guarantee that the Shift parameter will be in the &#39; range 1 to 30 you can safely strip of this first nested if structure for &#39; speed. &#39; &#39; A shift of zero is no shift at all If iShiftBits = 0 Then RShift = lValue Exit Function &#39; A shift of 31 will clear all bits and move the left most bit to the right &#39; most bit position ElseIf iShiftBits = 31 Then If lValue And &amp;H80000000 Then RShift = 1 Else RShift = 0 End If Exit Function &#39; A shift of less than zero or more than 31 is undefined ElseIf iShiftBits &lt; 0 Or iShiftBits &gt; 31 Then Err.Raise 6 End If &#39; We do not care about the top most bit or the final bit, the top most bit &#39; will be taken into account in the next stage, the final bit (whether it &#39; is an odd number or not) is being shifted into, so we do not give a jot &#39; about it RShift = (lValue And &amp;H7FFFFFFE) \ m_l2Power(iShiftBits) &#39; If the top most bit (&amp;H80000000) was set we need to do things differently &#39; as in a normal VB signed long integer the top most bit is used to indicate &#39; the sign of the number, when it is set it is a negative number, so just &#39; deviding by a factor of 2 as above would not work. &#39; NOTE: (lValue And &amp;H80000000) is equivalent to (lValue &lt; 0), you could &#39; get a very marginal speed improvement by changing the test to (lValue &lt; 0) If (lValue And &amp;H80000000) Then &#39; We take the value computed so far, and then add the left most negative &#39; bit after it has been shifted to the right the appropriate number of &#39; places RShift = (RShift Or (&amp;H40000000 \ m_l2Power(iShiftBits - 1))) End If End Function &#39;******************************************************************************* &#39; AddUnsigned (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In) - lX - Long - First value &#39; (In) - lY - Long - Second value &#39; &#39; RETURN VALUE: &#39; Long - Result &#39; &#39; DESCRIPTION: &#39; Adds two potentially large unsigned numbers without overflowing &#39;******************************************************************************* Private Function AddUnsigned(ByVal lX As Long, _ ByVal lY As Long) As Long Dim lX4 As Long Dim lY4 As Long Dim lX8 As Long Dim lY8 As Long Dim lResult As Long lX8 = lX And &amp;H80000000 lY8 = lY And &amp;H80000000 lX4 = lX And &amp;H40000000 lY4 = lY And &amp;H40000000 lResult = (lX And &amp;H3FFFFFFF) + (lY And &amp;H3FFFFFFF) If lX4 And lY4 Then lResult = lResult Xor &amp;H80000000 Xor lX8 Xor lY8 ElseIf lX4 Or lY4 Then If lResult And &amp;H40000000 Then lResult = lResult Xor &amp;HC0000000 Xor lX8 Xor lY8 Else lResult = lResult Xor &amp;H40000000 Xor lX8 Xor lY8 End If Else lResult = lResult Xor lX8 Xor lY8 End If AddUnsigned = lResult End Function &#39;******************************************************************************* &#39; Ch (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Ch(ByVal x As Long, _ ByVal y As Long, _ ByVal z As Long) As Long Ch = ((x And y) Xor ((Not x) And z)) End Function &#39;******************************************************************************* &#39; Maj (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Maj(ByVal x As Long, _ ByVal y As Long, _ ByVal z As Long) As Long Maj = ((x And y) Xor (x And z) Xor (y And z)) End Function &#39;******************************************************************************* &#39; S (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function (rotate right) &#39;******************************************************************************* Private Function S(ByVal x As Long, _ ByVal n As Long) As Long S = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4))))) End Function &#39;******************************************************************************* &#39; R (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function (just a right shift) &#39;******************************************************************************* Private Function R(ByVal x As Long, _ ByVal n As Long) As Long R = RShift(x, CInt(n And m_lOnBits(4))) End Function &#39;******************************************************************************* &#39; Sigma0 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Sigma0(ByVal x As Long) As Long Sigma0 = (S(x, 2) Xor S(x, 13) Xor S(x, 22)) End Function &#39;******************************************************************************* &#39; Sigma1 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Sigma1(ByVal x As Long) As Long Sigma1 = (S(x, 6) Xor S(x, 11) Xor S(x, 25)) End Function &#39;******************************************************************************* &#39; Gamma0 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Gamma0(ByVal x As Long) As Long Gamma0 = (S(x, 7) Xor S(x, 18) Xor R(x, 3)) End Function &#39;******************************************************************************* &#39; Gamma1 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Gamma1(ByVal x As Long) As Long Gamma1 = (S(x, 17) Xor S(x, 19) Xor R(x, 10)) End Function &#39;******************************************************************************* &#39; ConvertToWordArray (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In/Out) - sMessage - String - String message &#39; &#39; RETURN VALUE: &#39; Long() - Converted message as long array &#39; &#39; DESCRIPTION: &#39; Takes the string message and puts it in a long array with padding according to &#39; the SHA-256 rules (similar to MD5 routine). &#39;******************************************************************************* Private Function ConvertToWordArray(sMessage As String) As Long() Dim lMessageLength As Long Dim lNumberOfWords As Long Dim lWordArray() As Long Dim lBytePosition As Long Dim lByteCount As Long Dim lWordCount As Long Dim lByte As Long Const MODULUS_BITS As Long = 512 Const CONGRUENT_BITS As Long = 448 lMessageLength = Len(sMessage) &#39; Get padded number of words. Message needs to be congruent to 448 bits, &#39; modulo 512 bits. If it is exactly congruent to 448 bits, modulo 512 bits &#39; it must still have another 512 bits added. 512 bits = 64 bytes &#39; (or 16 * 4 byte words), 448 bits = 56 bytes. This means lNumberOfWords must &#39; be a multiple of 16 (i.e. 16 * 4 (bytes) * 8 (bits)) lNumberOfWords = (((lMessageLength + _ ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ _ (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * _ (MODULUS_BITS \ BITS_TO_A_WORD) ReDim lWordArray(lNumberOfWords - 1) &#39; Combine each block of 4 bytes (ascii code of character) into one long &#39; value and store in the message. The high-order (most significant) bit of &#39; each byte is listed first. However, unlike MD5 we put the high-order &#39; (most significant) byte first in each word. lBytePosition = 0 lByteCount = 0 Do Until lByteCount &gt;= lMessageLength &#39; Each word is 4 bytes lWordCount = lByteCount \ BYTES_TO_A_WORD lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE &#39; NOTE: This is where we are using just the first byte of each unicode &#39; character, you may want to make the change here, or to the SHA256 method &#39; so it accepts a byte array. lByte = AscB(Mid(sMessage, lByteCount + 1, 1)) lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition) lByteCount = lByteCount + 1 Loop &#39; Terminate according to SHA-256 rules with a 1 bit, zeros and the length in &#39; bits stored in the last two words lWordCount = lByteCount \ BYTES_TO_A_WORD lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE &#39; Add a terminating 1 bit, all the rest of the bits to the end of the &#39; word array will default to zero lWordArray(lWordCount) = lWordArray(lWordCount) Or _ LShift(&amp;H80, lBytePosition) &#39; We put the length of the message in bits into the last two words, to get &#39; the length in bits we need to multiply by 8 (or left shift 3). This left &#39; shifted value is put in the last word. Any bits shifted off the left edge &#39; need to be put in the penultimate word, we can work out which bits by shifting &#39; right the length by 29 bits. lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3) lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29) ConvertToWordArray = lWordArray End Function &#39;******************************************************************************* &#39; SHA256 (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In/Out) - sMessage - String - Message to digest &#39; &#39; RETURN VALUE: &#39; String - The digest &#39; &#39; DESCRIPTION: &#39; Takes a string and uses the SHA-256 digest to produce a signature for it. &#39; &#39; NOTE: Due to the way in which the string is processed the routine assumes a &#39; single byte character set. VB passes unicode (2-byte) character strings, the &#39; ConvertToWordArray function uses on the first byte for each character. This &#39; has been done this way for ease of use, to make the routine truely portable &#39; you could accept a byte array instead, it would then be up to the calling &#39; routine to make sure that the byte array is generated from their string in &#39; a manner consistent with the string type. &#39;******************************************************************************* Public Function SHA256(sMessage As String) As String Dim HASH(7) As Long Dim M() As Long Dim W(63) As Long Dim a As Long Dim b As Long Dim c As Long Dim d As Long Dim e As Long Dim f As Long Dim g As Long Dim h As Long Dim i As Long Dim j As Long Dim T1 As Long Dim T2 As Long &#39; Initial hash values HASH(0) = &amp;H6A09E667 HASH(1) = &amp;HBB67AE85 HASH(2) = &amp;H3C6EF372 HASH(3) = &amp;HA54FF53A HASH(4) = &amp;H510E527F HASH(5) = &amp;H9B05688C HASH(6) = &amp;H1F83D9AB HASH(7) = &amp;H5BE0CD19 &#39; Preprocessing. Append padding bits and length and convert to words M = ConvertToWordArray(sMessage) &#39; Main loop For i = 0 To UBound(M) Step 16 a = HASH(0) b = HASH(1) c = HASH(2) d = HASH(3) e = HASH(4) f = HASH(5) g = HASH(6) h = HASH(7) For j = 0 To 63 If j &lt; 16 Then W(j) = M(j + i) Else W(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(W(j - 2)), _ W(j - 7)), Gamma0(W(j - 15))), W(j - 16)) End If T1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(h, Sigma1(e)), _ Ch(e, f, g)), K(j)), W(j)) T2 = AddUnsigned(Sigma0(a), Maj(a, b, c)) h = g g = f f = e e = AddUnsigned(d, T1) d = c c = b b = a a = AddUnsigned(T1, T2) Next HASH(0) = AddUnsigned(a, HASH(0)) HASH(1) = AddUnsigned(b, HASH(1)) HASH(2) = AddUnsigned(c, HASH(2)) HASH(3) = AddUnsigned(d, HASH(3)) HASH(4) = AddUnsigned(e, HASH(4)) HASH(5) = AddUnsigned(f, HASH(5)) HASH(6) = AddUnsigned(g, HASH(6)) HASH(7) = AddUnsigned(h, HASH(7)) Next &#39; Output the 256 bit digest SHA256 = LCase(Right(&quot;00000000&quot; &amp; Hex(HASH(0)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(1)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(2)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(3)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(4)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(5)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(6)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(7)), 8)) End Function 4、在属性里面修改模块类名为CSHA256（属性窗口通常在左边，如果没有看到属性窗口就自己打开它，在“视图”菜单中点击“属性窗口”） 5、再次在界面的“工程”空白处点击右键，选择插入模块，模块中输入以下代码 Public Function FunSHA256(sMessage As String) Dim clsX As CSHA256 Set clsX = New CSHA256 FunSHA256 = clsX.SHA256(sMessage) Set clsX = Nothing End Function 6、保存并关闭，然后在该Excel中就可以通过调用函数FunSHA256来计算SHA256值了。 最后和网上的一些在线程序对比下结果，没问题的话就可以了。比如：Email地址 example@gmail.com经过哈希处理后的值为 264e53d93759bde067fd01ef2698f98d1253c730d12f021116f02eebcfa9ace6。 查看原文： http://xuhehuan.com/2310.html 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-01-14T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"工作中需要将一批Email地址转换成SHA256的值，能想到的最方便的方法莫过于通过Excel的VBA来实现了，但是从来没有写过VBA的程序，百度也没搜到有用信息，只能去Google上查，很Easy的在Stackoverflow找到一个有用的问答： 参考问答： http://stackoverflow.com/questions/22672564/porting-sha-256-library-to-excel 操作成功后，将详细过程记录一下，当作备忘，也方便其他人参考。 本文以Excel2010为例进行操作，同时在WPS2013上验证也没有问题。 下面是详细步骤： 1、点击“开发工具”页面的“Visual Basic” 2、在打开界面的“工程”空白处点击右键，选择插入类模块 3、在打开的类1文件中输入以下代码 &#39;******************************************************************************* &#39; MODULE: CSHA256 &#39; FILENAME: CSHA256.cls &#39; AUTHOR: Phil Fresle &#39; CREATED: 10-Apr-2001 &#39; COPYRIGHT: Copyright 2001 Phil Fresle. All Rights Reserved. &#39; &#39; DESCRIPTION: &#39; This class is used to generate a SHA-256 &#39;digest&#39; or &#39;signature&#39; of a string. &#39; The SHA-256 algorithm is one of the industry standard methods for generating &#39; digital signatures. It is generically known as a digest, digital signature, &#39; one-way encryption, hash or checksum algorithm. A common use for SHA-256 is &#39; for password encryption as it is one-way in nature, that does not mean that &#39; your passwords are not free from a dictionary attack. If you are using the &#39; routine for passwords, you can make it a little more secure by concatenating &#39; some known random characters to the password before you generate the signature &#39; and on subsequent tests, so even if a hacker knows you are using SHA-256 for &#39; your passwords, the random characters will make it harder to dictionary attack. &#39; &#39; *** CAUTION *** &#39; See the comment attached to the SHA256 method below regarding use on systems &#39; with different character sets. &#39; &#39; This is &#39;free&#39; software with the following restrictions: &#39; &#39; You may not redistribute this code as a &#39;sample&#39; or &#39;demo&#39;. However, you are free &#39; to use the source code in your own code, but you may not claim that you created &#39; the sample code. It is expressly forbidden to sell or profit from this source code &#39; other than by the knowledge gained or the enhanced value added by your own code. &#39; &#39; Use of this software is also done so at your own risk. The code is supplied as &#39; is without warranty or guarantee of any kind. &#39; &#39; Should you wish to commission some derivative work based on this code provided &#39; here, or any consultancy work, please do not hesitate to contact us. &#39; &#39; Web Site: http://www.frez.co.uk &#39; E-mail: sales@frez.co.uk &#39; &#39; MODIFICATION HISTORY: &#39; 10-Apr-2001 Phil Fresle Initial Version &#39;******************************************************************************* Option Explicit Private m_lOnBits(30) As Long Private m_l2Power(30) As Long Private K(63) As Long Private Const BITS_TO_A_BYTE As Long = 8 Private Const BYTES_TO_A_WORD As Long = 4 Private Const BITS_TO_A_WORD As Long = BYTES_TO_A_WORD * BITS_TO_A_BYTE &#39;******************************************************************************* &#39; Class_Initialize (SUB) &#39;******************************************************************************* Private Sub Class_Initialize() &#39; Could have done this with a loop calculating each value, but simply &#39; assigning the values is quicker - BITS SET FROM RIGHT m_lOnBits(0) = 1 &#39; 00000000000000000000000000000001 m_lOnBits(1) = 3 &#39; 00000000000000000000000000000011 m_lOnBits(2) = 7 &#39; 00000000000000000000000000000111 m_lOnBits(3) = 15 &#39; 00000000000000000000000000001111 m_lOnBits(4) = 31 &#39; 00000000000000000000000000011111 m_lOnBits(5) = 63 &#39; 00000000000000000000000000111111 m_lOnBits(6) = 127 &#39; 00000000000000000000000001111111 m_lOnBits(7) = 255 &#39; 00000000000000000000000011111111 m_lOnBits(8) = 511 &#39; 00000000000000000000000111111111 m_lOnBits(9) = 1023 &#39; 00000000000000000000001111111111 m_lOnBits(10) = 2047 &#39; 00000000000000000000011111111111 m_lOnBits(11) = 4095 &#39; 00000000000000000000111111111111 m_lOnBits(12) = 8191 &#39; 00000000000000000001111111111111 m_lOnBits(13) = 16383 &#39; 00000000000000000011111111111111 m_lOnBits(14) = 32767 &#39; 00000000000000000111111111111111 m_lOnBits(15) = 65535 &#39; 00000000000000001111111111111111 m_lOnBits(16) = 131071 &#39; 00000000000000011111111111111111 m_lOnBits(17) = 262143 &#39; 00000000000000111111111111111111 m_lOnBits(18) = 524287 &#39; 00000000000001111111111111111111 m_lOnBits(19) = 1048575 &#39; 00000000000011111111111111111111 m_lOnBits(20) = 2097151 &#39; 00000000000111111111111111111111 m_lOnBits(21) = 4194303 &#39; 00000000001111111111111111111111 m_lOnBits(22) = 8388607 &#39; 00000000011111111111111111111111 m_lOnBits(23) = 16777215 &#39; 00000000111111111111111111111111 m_lOnBits(24) = 33554431 &#39; 00000001111111111111111111111111 m_lOnBits(25) = 67108863 &#39; 00000011111111111111111111111111 m_lOnBits(26) = 134217727 &#39; 00000111111111111111111111111111 m_lOnBits(27) = 268435455 &#39; 00001111111111111111111111111111 m_lOnBits(28) = 536870911 &#39; 00011111111111111111111111111111 m_lOnBits(29) = 1073741823 &#39; 00111111111111111111111111111111 m_lOnBits(30) = 2147483647 &#39; 01111111111111111111111111111111 &#39; Could have done this with a loop calculating each value, but simply &#39; assigning the values is quicker - POWERS OF 2 m_l2Power(0) = 1 &#39; 00000000000000000000000000000001 m_l2Power(1) = 2 &#39; 00000000000000000000000000000010 m_l2Power(2) = 4 &#39; 00000000000000000000000000000100 m_l2Power(3) = 8 &#39; 00000000000000000000000000001000 m_l2Power(4) = 16 &#39; 00000000000000000000000000010000 m_l2Power(5) = 32 &#39; 00000000000000000000000000100000 m_l2Power(6) = 64 &#39; 00000000000000000000000001000000 m_l2Power(7) = 128 &#39; 00000000000000000000000010000000 m_l2Power(8) = 256 &#39; 00000000000000000000000100000000 m_l2Power(9) = 512 &#39; 00000000000000000000001000000000 m_l2Power(10) = 1024 &#39; 00000000000000000000010000000000 m_l2Power(11) = 2048 &#39; 00000000000000000000100000000000 m_l2Power(12) = 4096 &#39; 00000000000000000001000000000000 m_l2Power(13) = 8192 &#39; 00000000000000000010000000000000 m_l2Power(14) = 16384 &#39; 00000000000000000100000000000000 m_l2Power(15) = 32768 &#39; 00000000000000001000000000000000 m_l2Power(16) = 65536 &#39; 00000000000000010000000000000000 m_l2Power(17) = 131072 &#39; 00000000000000100000000000000000 m_l2Power(18) = 262144 &#39; 00000000000001000000000000000000 m_l2Power(19) = 524288 &#39; 00000000000010000000000000000000 m_l2Power(20) = 1048576 &#39; 00000000000100000000000000000000 m_l2Power(21) = 2097152 &#39; 00000000001000000000000000000000 m_l2Power(22) = 4194304 &#39; 00000000010000000000000000000000 m_l2Power(23) = 8388608 &#39; 00000000100000000000000000000000 m_l2Power(24) = 16777216 &#39; 00000001000000000000000000000000 m_l2Power(25) = 33554432 &#39; 00000010000000000000000000000000 m_l2Power(26) = 67108864 &#39; 00000100000000000000000000000000 m_l2Power(27) = 134217728 &#39; 00001000000000000000000000000000 m_l2Power(28) = 268435456 &#39; 00010000000000000000000000000000 m_l2Power(29) = 536870912 &#39; 00100000000000000000000000000000 m_l2Power(30) = 1073741824 &#39; 01000000000000000000000000000000 &#39; Just put together the K array once K(0) = &amp;H428A2F98 K(1) = &amp;H71374491 K(2) = &amp;HB5C0FBCF K(3) = &amp;HE9B5DBA5 K(4) = &amp;H3956C25B K(5) = &amp;H59F111F1 K(6) = &amp;H923F82A4 K(7) = &amp;HAB1C5ED5 K(8) = &amp;HD807AA98 K(9) = &amp;H12835B01 K(10) = &amp;H243185BE K(11) = &amp;H550C7DC3 K(12) = &amp;H72BE5D74 K(13) = &amp;H80DEB1FE K(14) = &amp;H9BDC06A7 K(15) = &amp;HC19BF174 K(16) = &amp;HE49B69C1 K(17) = &amp;HEFBE4786 K(18) = &amp;HFC19DC6 K(19) = &amp;H240CA1CC K(20) = &amp;H2DE92C6F K(21) = &amp;H4A7484AA K(22) = &amp;H5CB0A9DC K(23) = &amp;H76F988DA K(24) = &amp;H983E5152 K(25) = &amp;HA831C66D K(26) = &amp;HB00327C8 K(27) = &amp;HBF597FC7 K(28) = &amp;HC6E00BF3 K(29) = &amp;HD5A79147 K(30) = &amp;H6CA6351 K(31) = &amp;H14292967 K(32) = &amp;H27B70A85 K(33) = &amp;H2E1B2138 K(34) = &amp;H4D2C6DFC K(35) = &amp;H53380D13 K(36) = &amp;H650A7354 K(37) = &amp;H766A0ABB K(38) = &amp;H81C2C92E K(39) = &amp;H92722C85 K(40) = &amp;HA2BFE8A1 K(41) = &amp;HA81A664B K(42) = &amp;HC24B8B70 K(43) = &amp;HC76C51A3 K(44) = &amp;HD192E819 K(45) = &amp;HD6990624 K(46) = &amp;HF40E3585 K(47) = &amp;H106AA070 K(48) = &amp;H19A4C116 K(49) = &amp;H1E376C08 K(50) = &amp;H2748774C K(51) = &amp;H34B0BCB5 K(52) = &amp;H391C0CB3 K(53) = &amp;H4ED8AA4A K(54) = &amp;H5B9CCA4F K(55) = &amp;H682E6FF3 K(56) = &amp;H748F82EE K(57) = &amp;H78A5636F K(58) = &amp;H84C87814 K(59) = &amp;H8CC70208 K(60) = &amp;H90BEFFFA K(61) = &amp;HA4506CEB K(62) = &amp;HBEF9A3F7 K(63) = &amp;HC67178F2 End Sub &#39;******************************************************************************* &#39; LShift (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In) - lValue - Long - The value to be shifted &#39; (In) - iShiftBits - Integer - The number of bits to shift the value by &#39; &#39; RETURN VALUE: &#39; Long - The shifted long integer &#39; &#39; DESCRIPTION: &#39; A left shift takes all the set binary bits and moves them left, in-filling &#39; with zeros in the vacated bits on the right. This function is equivalent to &#39; the &lt;&lt; operator in Java and C++ &#39;******************************************************************************* Private Function LShift(ByVal lValue As Long, _ ByVal iShiftBits As Integer) As Long &#39; NOTE: If you can guarantee that the Shift parameter will be in the &#39; range 1 to 30 you can safely strip of this first nested if structure for &#39; speed. &#39; &#39; A shift of zero is no shift at all. If iShiftBits = 0 Then LShift = lValue Exit Function &#39; A shift of 31 will result in the right most bit becoming the left most &#39; bit and all other bits being cleared ElseIf iShiftBits = 31 Then If lValue And 1 Then LShift = &amp;H80000000 Else LShift = 0 End If Exit Function &#39; A shift of less than zero or more than 31 is undefined ElseIf iShiftBits &lt; 0 Or iShiftBits &gt; 31 Then Err.Raise 6 End If &#39; If the left most bit that remains will end up in the negative bit &#39; position (&amp;H80000000) we would end up with an overflow if we took the &#39; standard route. We need to strip the left most bit and add it back &#39; afterwards. If (lValue And m_l2Power(31 - iShiftBits)) Then &#39; (Value And OnBits(31 - (Shift + 1))) chops off the left most bits that &#39; we are shifting into, but also the left most bit we still want as this &#39; is going to end up in the negative bit marker position (&amp;H80000000). &#39; After the multiplication/shift we Or the result with &amp;H80000000 to &#39; turn the negative bit on. LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * _ m_l2Power(iShiftBits)) Or &amp;H80000000 Else &#39; (Value And OnBits(31-Shift)) chops off the left most bits that we are &#39; shifting into so we do not get an overflow error when we do the &#39; multiplication/shift LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * _ m_l2Power(iShiftBits)) End If End Function &#39;******************************************************************************* &#39; RShift (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In) - lValue - Long - The value to be shifted &#39; (In) - iShiftBits - Integer - The number of bits to shift the value by &#39; &#39; RETURN VALUE: &#39; Long - The shifted long integer &#39; &#39; DESCRIPTION: &#39; The right shift of an unsigned long integer involves shifting all the set bits &#39; to the right and in-filling on the left with zeros. This function is &#39; equivalent to the &gt;&gt;&gt; operator in Java or the &gt;&gt; operator in C++ when used on &#39; an unsigned long. &#39;******************************************************************************* Private Function RShift(ByVal lValue As Long, _ ByVal iShiftBits As Integer) As Long &#39; NOTE: If you can guarantee that the Shift parameter will be in the &#39; range 1 to 30 you can safely strip of this first nested if structure for &#39; speed. &#39; &#39; A shift of zero is no shift at all If iShiftBits = 0 Then RShift = lValue Exit Function &#39; A shift of 31 will clear all bits and move the left most bit to the right &#39; most bit position ElseIf iShiftBits = 31 Then If lValue And &amp;H80000000 Then RShift = 1 Else RShift = 0 End If Exit Function &#39; A shift of less than zero or more than 31 is undefined ElseIf iShiftBits &lt; 0 Or iShiftBits &gt; 31 Then Err.Raise 6 End If &#39; We do not care about the top most bit or the final bit, the top most bit &#39; will be taken into account in the next stage, the final bit (whether it &#39; is an odd number or not) is being shifted into, so we do not give a jot &#39; about it RShift = (lValue And &amp;H7FFFFFFE) \\ m_l2Power(iShiftBits) &#39; If the top most bit (&amp;H80000000) was set we need to do things differently &#39; as in a normal VB signed long integer the top most bit is used to indicate &#39; the sign of the number, when it is set it is a negative number, so just &#39; deviding by a factor of 2 as above would not work. &#39; NOTE: (lValue And &amp;H80000000) is equivalent to (lValue &lt; 0), you could &#39; get a very marginal speed improvement by changing the test to (lValue &lt; 0) If (lValue And &amp;H80000000) Then &#39; We take the value computed so far, and then add the left most negative &#39; bit after it has been shifted to the right the appropriate number of &#39; places RShift = (RShift Or (&amp;H40000000 \\ m_l2Power(iShiftBits - 1))) End If End Function &#39;******************************************************************************* &#39; AddUnsigned (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In) - lX - Long - First value &#39; (In) - lY - Long - Second value &#39; &#39; RETURN VALUE: &#39; Long - Result &#39; &#39; DESCRIPTION: &#39; Adds two potentially large unsigned numbers without overflowing &#39;******************************************************************************* Private Function AddUnsigned(ByVal lX As Long, _ ByVal lY As Long) As Long Dim lX4 As Long Dim lY4 As Long Dim lX8 As Long Dim lY8 As Long Dim lResult As Long lX8 = lX And &amp;H80000000 lY8 = lY And &amp;H80000000 lX4 = lX And &amp;H40000000 lY4 = lY And &amp;H40000000 lResult = (lX And &amp;H3FFFFFFF) + (lY And &amp;H3FFFFFFF) If lX4 And lY4 Then lResult = lResult Xor &amp;H80000000 Xor lX8 Xor lY8 ElseIf lX4 Or lY4 Then If lResult And &amp;H40000000 Then lResult = lResult Xor &amp;HC0000000 Xor lX8 Xor lY8 Else lResult = lResult Xor &amp;H40000000 Xor lX8 Xor lY8 End If Else lResult = lResult Xor lX8 Xor lY8 End If AddUnsigned = lResult End Function &#39;******************************************************************************* &#39; Ch (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Ch(ByVal x As Long, _ ByVal y As Long, _ ByVal z As Long) As Long Ch = ((x And y) Xor ((Not x) And z)) End Function &#39;******************************************************************************* &#39; Maj (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Maj(ByVal x As Long, _ ByVal y As Long, _ ByVal z As Long) As Long Maj = ((x And y) Xor (x And z) Xor (y And z)) End Function &#39;******************************************************************************* &#39; S (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function (rotate right) &#39;******************************************************************************* Private Function S(ByVal x As Long, _ ByVal n As Long) As Long S = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4))))) End Function &#39;******************************************************************************* &#39; R (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function (just a right shift) &#39;******************************************************************************* Private Function R(ByVal x As Long, _ ByVal n As Long) As Long R = RShift(x, CInt(n And m_lOnBits(4))) End Function &#39;******************************************************************************* &#39; Sigma0 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Sigma0(ByVal x As Long) As Long Sigma0 = (S(x, 2) Xor S(x, 13) Xor S(x, 22)) End Function &#39;******************************************************************************* &#39; Sigma1 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Sigma1(ByVal x As Long) As Long Sigma1 = (S(x, 6) Xor S(x, 11) Xor S(x, 25)) End Function &#39;******************************************************************************* &#39; Gamma0 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Gamma0(ByVal x As Long) As Long Gamma0 = (S(x, 7) Xor S(x, 18) Xor R(x, 3)) End Function &#39;******************************************************************************* &#39; Gamma1 (FUNCTION) &#39; &#39; DESCRIPTION: &#39; SHA-256 function &#39;******************************************************************************* Private Function Gamma1(ByVal x As Long) As Long Gamma1 = (S(x, 17) Xor S(x, 19) Xor R(x, 10)) End Function &#39;******************************************************************************* &#39; ConvertToWordArray (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In/Out) - sMessage - String - String message &#39; &#39; RETURN VALUE: &#39; Long() - Converted message as long array &#39; &#39; DESCRIPTION: &#39; Takes the string message and puts it in a long array with padding according to &#39; the SHA-256 rules (similar to MD5 routine). &#39;******************************************************************************* Private Function ConvertToWordArray(sMessage As String) As Long() Dim lMessageLength As Long Dim lNumberOfWords As Long Dim lWordArray() As Long Dim lBytePosition As Long Dim lByteCount As Long Dim lWordCount As Long Dim lByte As Long Const MODULUS_BITS As Long = 512 Const CONGRUENT_BITS As Long = 448 lMessageLength = Len(sMessage) &#39; Get padded number of words. Message needs to be congruent to 448 bits, &#39; modulo 512 bits. If it is exactly congruent to 448 bits, modulo 512 bits &#39; it must still have another 512 bits added. 512 bits = 64 bytes &#39; (or 16 * 4 byte words), 448 bits = 56 bytes. This means lNumberOfWords must &#39; be a multiple of 16 (i.e. 16 * 4 (bytes) * 8 (bits)) lNumberOfWords = (((lMessageLength + _ ((MODULUS_BITS - CONGRUENT_BITS) \\ BITS_TO_A_BYTE)) \\ _ (MODULUS_BITS \\ BITS_TO_A_BYTE)) + 1) * _ (MODULUS_BITS \\ BITS_TO_A_WORD) ReDim lWordArray(lNumberOfWords - 1) &#39; Combine each block of 4 bytes (ascii code of character) into one long &#39; value and store in the message. The high-order (most significant) bit of &#39; each byte is listed first. However, unlike MD5 we put the high-order &#39; (most significant) byte first in each word. lBytePosition = 0 lByteCount = 0 Do Until lByteCount &gt;= lMessageLength &#39; Each word is 4 bytes lWordCount = lByteCount \\ BYTES_TO_A_WORD lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE &#39; NOTE: This is where we are using just the first byte of each unicode &#39; character, you may want to make the change here, or to the SHA256 method &#39; so it accepts a byte array. lByte = AscB(Mid(sMessage, lByteCount + 1, 1)) lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition) lByteCount = lByteCount + 1 Loop &#39; Terminate according to SHA-256 rules with a 1 bit, zeros and the length in &#39; bits stored in the last two words lWordCount = lByteCount \\ BYTES_TO_A_WORD lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE &#39; Add a terminating 1 bit, all the rest of the bits to the end of the &#39; word array will default to zero lWordArray(lWordCount) = lWordArray(lWordCount) Or _ LShift(&amp;H80, lBytePosition) &#39; We put the length of the message in bits into the last two words, to get &#39; the length in bits we need to multiply by 8 (or left shift 3). This left &#39; shifted value is put in the last word. Any bits shifted off the left edge &#39; need to be put in the penultimate word, we can work out which bits by shifting &#39; right the length by 29 bits. lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3) lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29) ConvertToWordArray = lWordArray End Function &#39;******************************************************************************* &#39; SHA256 (FUNCTION) &#39; &#39; PARAMETERS: &#39; (In/Out) - sMessage - String - Message to digest &#39; &#39; RETURN VALUE: &#39; String - The digest &#39; &#39; DESCRIPTION: &#39; Takes a string and uses the SHA-256 digest to produce a signature for it. &#39; &#39; NOTE: Due to the way in which the string is processed the routine assumes a &#39; single byte character set. VB passes unicode (2-byte) character strings, the &#39; ConvertToWordArray function uses on the first byte for each character. This &#39; has been done this way for ease of use, to make the routine truely portable &#39; you could accept a byte array instead, it would then be up to the calling &#39; routine to make sure that the byte array is generated from their string in &#39; a manner consistent with the string type. &#39;******************************************************************************* Public Function SHA256(sMessage As String) As String Dim HASH(7) As Long Dim M() As Long Dim W(63) As Long Dim a As Long Dim b As Long Dim c As Long Dim d As Long Dim e As Long Dim f As Long Dim g As Long Dim h As Long Dim i As Long Dim j As Long Dim T1 As Long Dim T2 As Long &#39; Initial hash values HASH(0) = &amp;H6A09E667 HASH(1) = &amp;HBB67AE85 HASH(2) = &amp;H3C6EF372 HASH(3) = &amp;HA54FF53A HASH(4) = &amp;H510E527F HASH(5) = &amp;H9B05688C HASH(6) = &amp;H1F83D9AB HASH(7) = &amp;H5BE0CD19 &#39; Preprocessing. Append padding bits and length and convert to words M = ConvertToWordArray(sMessage) &#39; Main loop For i = 0 To UBound(M) Step 16 a = HASH(0) b = HASH(1) c = HASH(2) d = HASH(3) e = HASH(4) f = HASH(5) g = HASH(6) h = HASH(7) For j = 0 To 63 If j &lt; 16 Then W(j) = M(j + i) Else W(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(W(j - 2)), _ W(j - 7)), Gamma0(W(j - 15))), W(j - 16)) End If T1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(h, Sigma1(e)), _ Ch(e, f, g)), K(j)), W(j)) T2 = AddUnsigned(Sigma0(a), Maj(a, b, c)) h = g g = f f = e e = AddUnsigned(d, T1) d = c c = b b = a a = AddUnsigned(T1, T2) Next HASH(0) = AddUnsigned(a, HASH(0)) HASH(1) = AddUnsigned(b, HASH(1)) HASH(2) = AddUnsigned(c, HASH(2)) HASH(3) = AddUnsigned(d, HASH(3)) HASH(4) = AddUnsigned(e, HASH(4)) HASH(5) = AddUnsigned(f, HASH(5)) HASH(6) = AddUnsigned(g, HASH(6)) HASH(7) = AddUnsigned(h, HASH(7)) Next &#39; Output the 256 bit digest SHA256 = LCase(Right(&quot;00000000&quot; &amp; Hex(HASH(0)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(1)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(2)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(3)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(4)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(5)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(6)), 8) &amp; _ Right(&quot;00000000&quot; &amp; Hex(HASH(7)), 8)) End Function 4、在属性里面修改模块类名为CSHA256（属性窗口通常在左边，如果没有看到属性窗口就自己打开它，在“视图”菜单中点击“属性窗口”） 5、再次在界面的“工程”空白处点击右键，选择插入模块，模块中输入以下代码 Public Function FunSHA256(sMessage As String) Dim clsX As CSHA256 Set clsX = New CSHA256 FunSHA256 = clsX.SHA256(sMessage) Set clsX = Nothing End Function 6、保存并关闭，然后在该Excel中就可以通过调用函数FunSHA256来计算SHA256值了。 最后和网上的一些在线程序对比下结果，没问题的话就可以了。比如：Email地址 example@gmail.com经过哈希处理后的值为 264e53d93759bde067fd01ef2698f98d1253c730d12f021116f02eebcfa9ace6。 查看原文： http://xuhehuan.com/2310.html 阅读更多","@type":"BlogPosting","url":"/2016/01/14/f5b0b01845b275e623bbdd545a6d0928.html","headline":"Excel添加SHA256计算函数","dateModified":"2016-01-14T00:00:00+08:00","datePublished":"2016-01-14T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2016/01/14/f5b0b01845b275e623bbdd545a6d0928.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Excel添加SHA256计算函数</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <pre>工作中需要将一批Email地址转换成SHA256的值，能想到的最方便的方法莫过于通过Excel的VBA来实现了，但是从来没有写过VBA的程序，百度也没搜到有用信息，只能去Google上查，很Easy的在Stackoverflow找到一个有用的问答：
</pre>
  <blockquote>
   参考问答：
   <a href="http://stackoverflow.com/questions/22672564/porting-sha-256-library-to-excel" rel="nofollow">http://stackoverflow.com/questions/22672564/porting-sha-256-library-to-excel</a>
  </blockquote> 操作成功后，将详细过程记录一下，当作备忘，也方便其他人参考。 本文以Excel2010为例进行操作，同时在WPS2013上验证也没有问题。 下面是详细步骤： 1、点击“开发工具”页面的“Visual Basic” 
  <a href="http://xuhehuan.com/wp-content/uploads/2016/01/excel-visual-basic.jpg" rel="nofollow"><img class="alignnone size-full wp-image-2318" src="http://xuhehuan.com/wp-content/uploads/2016/01/excel-visual-basic.jpg" alt="excel-visual-basic"></a> 2、在打开界面的“工程”空白处点击右键，选择插入类模块 
  <a href="http://xuhehuan.com/wp-content/uploads/2016/01/excel-class-module.jpg" rel="nofollow"><img class="alignnone size-full wp-image-2315" src="http://xuhehuan.com/wp-content/uploads/2016/01/excel-class-module.jpg" alt="excel-class-module"></a> 3、在打开的类1文件中输入以下代码 
  <pre><code class="language-vb">'*******************************************************************************
' MODULE:       CSHA256
' FILENAME:     CSHA256.cls
' AUTHOR:       Phil Fresle
' CREATED:      10-Apr-2001
' COPYRIGHT:    Copyright 2001 Phil Fresle. All Rights Reserved.
'
' DESCRIPTION:
' This class is used to generate a SHA-256 'digest' or 'signature' of a string.
' The SHA-256 algorithm is one of the industry standard methods for generating
' digital signatures. It is generically known as a digest, digital signature,
' one-way encryption, hash or checksum algorithm. A common use for SHA-256 is
' for password encryption as it is one-way in nature, that does not mean that
' your passwords are not free from a dictionary attack. If you are using the
' routine for passwords, you can make it a little more secure by concatenating
' some known random characters to the password before you generate the signature
' and on subsequent tests, so even if a hacker knows you are using SHA-256 for
' your passwords, the random characters will make it harder to dictionary attack.
'
' *** CAUTION ***
' See the comment attached to the SHA256 method below regarding use on systems
' with different character sets.
'
' This is 'free' software with the following restrictions:
'
' You may not redistribute this code as a 'sample' or 'demo'. However, you are free
' to use the source code in your own code, but you may not claim that you created
' the sample code. It is expressly forbidden to sell or profit from this source code
' other than by the knowledge gained or the enhanced value added by your own code.
'
' Use of this software is also done so at your own risk. The code is supplied as
' is without warranty or guarantee of any kind.
'
' Should you wish to commission some derivative work based on this code provided
' here, or any consultancy work, please do not hesitate to contact us.
'
' Web Site:  http://www.frez.co.uk
' E-mail:    sales@frez.co.uk
'
' MODIFICATION HISTORY:
' 10-Apr-2001   Phil Fresle     Initial Version
'*******************************************************************************
Option Explicit

Private m_lOnBits(30)   As Long
Private m_l2Power(30)   As Long
Private K(63)           As Long

Private Const BITS_TO_A_BYTE  As Long = 8
Private Const BYTES_TO_A_WORD As Long = 4
Private Const BITS_TO_A_WORD  As Long = BYTES_TO_A_WORD * BITS_TO_A_BYTE

'*******************************************************************************
' Class_Initialize (SUB)
'*******************************************************************************
Private Sub Class_Initialize()
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - BITS SET FROM RIGHT
    m_lOnBits(0) = 1            ' 00000000000000000000000000000001
    m_lOnBits(1) = 3            ' 00000000000000000000000000000011
    m_lOnBits(2) = 7            ' 00000000000000000000000000000111
    m_lOnBits(3) = 15           ' 00000000000000000000000000001111
    m_lOnBits(4) = 31           ' 00000000000000000000000000011111
    m_lOnBits(5) = 63           ' 00000000000000000000000000111111
    m_lOnBits(6) = 127          ' 00000000000000000000000001111111
    m_lOnBits(7) = 255          ' 00000000000000000000000011111111
    m_lOnBits(8) = 511          ' 00000000000000000000000111111111
    m_lOnBits(9) = 1023         ' 00000000000000000000001111111111
    m_lOnBits(10) = 2047        ' 00000000000000000000011111111111
    m_lOnBits(11) = 4095        ' 00000000000000000000111111111111
    m_lOnBits(12) = 8191        ' 00000000000000000001111111111111
    m_lOnBits(13) = 16383       ' 00000000000000000011111111111111
    m_lOnBits(14) = 32767       ' 00000000000000000111111111111111
    m_lOnBits(15) = 65535       ' 00000000000000001111111111111111
    m_lOnBits(16) = 131071      ' 00000000000000011111111111111111
    m_lOnBits(17) = 262143      ' 00000000000000111111111111111111
    m_lOnBits(18) = 524287      ' 00000000000001111111111111111111
    m_lOnBits(19) = 1048575     ' 00000000000011111111111111111111
    m_lOnBits(20) = 2097151     ' 00000000000111111111111111111111
    m_lOnBits(21) = 4194303     ' 00000000001111111111111111111111
    m_lOnBits(22) = 8388607     ' 00000000011111111111111111111111
    m_lOnBits(23) = 16777215    ' 00000000111111111111111111111111
    m_lOnBits(24) = 33554431    ' 00000001111111111111111111111111
    m_lOnBits(25) = 67108863    ' 00000011111111111111111111111111
    m_lOnBits(26) = 134217727   ' 00000111111111111111111111111111
    m_lOnBits(27) = 268435455   ' 00001111111111111111111111111111
    m_lOnBits(28) = 536870911   ' 00011111111111111111111111111111
    m_lOnBits(29) = 1073741823  ' 00111111111111111111111111111111
    m_lOnBits(30) = 2147483647  ' 01111111111111111111111111111111
    
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - POWERS OF 2
    m_l2Power(0) = 1            ' 00000000000000000000000000000001
    m_l2Power(1) = 2            ' 00000000000000000000000000000010
    m_l2Power(2) = 4            ' 00000000000000000000000000000100
    m_l2Power(3) = 8            ' 00000000000000000000000000001000
    m_l2Power(4) = 16           ' 00000000000000000000000000010000
    m_l2Power(5) = 32           ' 00000000000000000000000000100000
    m_l2Power(6) = 64           ' 00000000000000000000000001000000
    m_l2Power(7) = 128          ' 00000000000000000000000010000000
    m_l2Power(8) = 256          ' 00000000000000000000000100000000
    m_l2Power(9) = 512          ' 00000000000000000000001000000000
    m_l2Power(10) = 1024        ' 00000000000000000000010000000000
    m_l2Power(11) = 2048        ' 00000000000000000000100000000000
    m_l2Power(12) = 4096        ' 00000000000000000001000000000000
    m_l2Power(13) = 8192        ' 00000000000000000010000000000000
    m_l2Power(14) = 16384       ' 00000000000000000100000000000000
    m_l2Power(15) = 32768       ' 00000000000000001000000000000000
    m_l2Power(16) = 65536       ' 00000000000000010000000000000000
    m_l2Power(17) = 131072      ' 00000000000000100000000000000000
    m_l2Power(18) = 262144      ' 00000000000001000000000000000000
    m_l2Power(19) = 524288      ' 00000000000010000000000000000000
    m_l2Power(20) = 1048576     ' 00000000000100000000000000000000
    m_l2Power(21) = 2097152     ' 00000000001000000000000000000000
    m_l2Power(22) = 4194304     ' 00000000010000000000000000000000
    m_l2Power(23) = 8388608     ' 00000000100000000000000000000000
    m_l2Power(24) = 16777216    ' 00000001000000000000000000000000
    m_l2Power(25) = 33554432    ' 00000010000000000000000000000000
    m_l2Power(26) = 67108864    ' 00000100000000000000000000000000
    m_l2Power(27) = 134217728   ' 00001000000000000000000000000000
    m_l2Power(28) = 268435456   ' 00010000000000000000000000000000
    m_l2Power(29) = 536870912   ' 00100000000000000000000000000000
    m_l2Power(30) = 1073741824  ' 01000000000000000000000000000000
    
    ' Just put together the K array once
    K(0) = &amp;H428A2F98
    K(1) = &amp;H71374491
    K(2) = &amp;HB5C0FBCF
    K(3) = &amp;HE9B5DBA5
    K(4) = &amp;H3956C25B
    K(5) = &amp;H59F111F1
    K(6) = &amp;H923F82A4
    K(7) = &amp;HAB1C5ED5
    K(8) = &amp;HD807AA98
    K(9) = &amp;H12835B01
    K(10) = &amp;H243185BE
    K(11) = &amp;H550C7DC3
    K(12) = &amp;H72BE5D74
    K(13) = &amp;H80DEB1FE
    K(14) = &amp;H9BDC06A7
    K(15) = &amp;HC19BF174
    K(16) = &amp;HE49B69C1
    K(17) = &amp;HEFBE4786
    K(18) = &amp;HFC19DC6
    K(19) = &amp;H240CA1CC
    K(20) = &amp;H2DE92C6F
    K(21) = &amp;H4A7484AA
    K(22) = &amp;H5CB0A9DC
    K(23) = &amp;H76F988DA
    K(24) = &amp;H983E5152
    K(25) = &amp;HA831C66D
    K(26) = &amp;HB00327C8
    K(27) = &amp;HBF597FC7
    K(28) = &amp;HC6E00BF3
    K(29) = &amp;HD5A79147
    K(30) = &amp;H6CA6351
    K(31) = &amp;H14292967
    K(32) = &amp;H27B70A85
    K(33) = &amp;H2E1B2138
    K(34) = &amp;H4D2C6DFC
    K(35) = &amp;H53380D13
    K(36) = &amp;H650A7354
    K(37) = &amp;H766A0ABB
    K(38) = &amp;H81C2C92E
    K(39) = &amp;H92722C85
    K(40) = &amp;HA2BFE8A1
    K(41) = &amp;HA81A664B
    K(42) = &amp;HC24B8B70
    K(43) = &amp;HC76C51A3
    K(44) = &amp;HD192E819
    K(45) = &amp;HD6990624
    K(46) = &amp;HF40E3585
    K(47) = &amp;H106AA070
    K(48) = &amp;H19A4C116
    K(49) = &amp;H1E376C08
    K(50) = &amp;H2748774C
    K(51) = &amp;H34B0BCB5
    K(52) = &amp;H391C0CB3
    K(53) = &amp;H4ED8AA4A
    K(54) = &amp;H5B9CCA4F
    K(55) = &amp;H682E6FF3
    K(56) = &amp;H748F82EE
    K(57) = &amp;H78A5636F
    K(58) = &amp;H84C87814
    K(59) = &amp;H8CC70208
    K(60) = &amp;H90BEFFFA
    K(61) = &amp;HA4506CEB
    K(62) = &amp;HBEF9A3F7
    K(63) = &amp;HC67178F2
End Sub

'*******************************************************************************
' LShift (FUNCTION)
'
' PARAMETERS:
' (In) - lValue     - Long    - The value to be shifted
' (In) - iShiftBits - Integer - The number of bits to shift the value by
'
' RETURN VALUE:
' Long - The shifted long integer
'
' DESCRIPTION:
' A left shift takes all the set binary bits and moves them left, in-filling
' with zeros in the vacated bits on the right. This function is equivalent to
' the &lt;&lt; operator in Java and C++
'*******************************************************************************
Private Function LShift(ByVal lValue As Long, _
                        ByVal iShiftBits As Integer) As Long
    ' NOTE: If you can guarantee that the Shift parameter will be in the
    ' range 1 to 30 you can safely strip of this first nested if structure for
    ' speed.
    '
    ' A shift of zero is no shift at all.
    If iShiftBits = 0 Then
        LShift = lValue
        Exit Function
        
    ' A shift of 31 will result in the right most bit becoming the left most
    ' bit and all other bits being cleared
    ElseIf iShiftBits = 31 Then
        If lValue And 1 Then
            LShift = &amp;H80000000
        Else
            LShift = 0
        End If
        Exit Function
        
    ' A shift of less than zero or more than 31 is undefined
    ElseIf iShiftBits &lt; 0 Or iShiftBits &gt; 31 Then
        Err.Raise 6
    End If
    
    ' If the left most bit that remains will end up in the negative bit
    ' position (&amp;H80000000) we would end up with an overflow if we took the
    ' standard route. We need to strip the left most bit and add it back
    ' afterwards.
    If (lValue And m_l2Power(31 - iShiftBits)) Then
    
        ' (Value And OnBits(31 - (Shift + 1))) chops off the left most bits that
        ' we are shifting into, but also the left most bit we still want as this
        ' is going to end up in the negative bit marker position (&amp;H80000000).
        ' After the multiplication/shift we Or the result with &amp;H80000000 to
        ' turn the negative bit on.
        LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * _
            m_l2Power(iShiftBits)) Or &amp;H80000000
    
    Else
    
        ' (Value And OnBits(31-Shift)) chops off the left most bits that we are
        ' shifting into so we do not get an overflow error when we do the
        ' multiplication/shift
        LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * _
            m_l2Power(iShiftBits))
        
    End If
End Function

'*******************************************************************************
' RShift (FUNCTION)
'
' PARAMETERS:
' (In) - lValue     - Long    - The value to be shifted
' (In) - iShiftBits - Integer - The number of bits to shift the value by
'
' RETURN VALUE:
' Long - The shifted long integer
'
' DESCRIPTION:
' The right shift of an unsigned long integer involves shifting all the set bits
' to the right and in-filling on the left with zeros. This function is
' equivalent to the &gt;&gt;&gt; operator in Java or the &gt;&gt; operator in C++ when used on
' an unsigned long.
'*******************************************************************************
Private Function RShift(ByVal lValue As Long, _
                        ByVal iShiftBits As Integer) As Long
    
    ' NOTE: If you can guarantee that the Shift parameter will be in the
    ' range 1 to 30 you can safely strip of this first nested if structure for
    ' speed.
    '
    ' A shift of zero is no shift at all
    If iShiftBits = 0 Then
        RShift = lValue
        Exit Function
        
    ' A shift of 31 will clear all bits and move the left most bit to the right
    ' most bit position
    ElseIf iShiftBits = 31 Then
        If lValue And &amp;H80000000 Then
            RShift = 1
        Else
            RShift = 0
        End If
        Exit Function
        
    ' A shift of less than zero or more than 31 is undefined
    ElseIf iShiftBits &lt; 0 Or iShiftBits &gt; 31 Then
        Err.Raise 6
    End If
    
    ' We do not care about the top most bit or the final bit, the top most bit
    ' will be taken into account in the next stage, the final bit (whether it
    ' is an odd number or not) is being shifted into, so we do not give a jot
    ' about it
    RShift = (lValue And &amp;H7FFFFFFE) \ m_l2Power(iShiftBits)
    
    ' If the top most bit (&amp;H80000000) was set we need to do things differently
    ' as in a normal VB signed long integer the top most bit is used to indicate
    ' the sign of the number, when it is set it is a negative number, so just
    ' deviding by a factor of 2 as above would not work.
    ' NOTE: (lValue And  &amp;H80000000) is equivalent to (lValue &lt; 0), you could
    ' get a very marginal speed improvement by changing the test to (lValue &lt; 0)
    If (lValue And &amp;H80000000) Then
        ' We take the value computed so far, and then add the left most negative
        ' bit after it has been shifted to the right the appropriate number of
        ' places
        RShift = (RShift Or (&amp;H40000000 \ m_l2Power(iShiftBits - 1)))
    End If
End Function

'*******************************************************************************
' AddUnsigned (FUNCTION)
'
' PARAMETERS:
' (In) - lX - Long - First value
' (In) - lY - Long - Second value
'
' RETURN VALUE:
' Long - Result
'
' DESCRIPTION:
' Adds two potentially large unsigned numbers without overflowing
'*******************************************************************************
Private Function AddUnsigned(ByVal lX As Long, _
                             ByVal lY As Long) As Long
    Dim lX4     As Long
    Dim lY4     As Long
    Dim lX8     As Long
    Dim lY8     As Long
    Dim lResult As Long
 
    lX8 = lX And &amp;H80000000
    lY8 = lY And &amp;H80000000
    lX4 = lX And &amp;H40000000
    lY4 = lY And &amp;H40000000
 
    lResult = (lX And &amp;H3FFFFFFF) + (lY And &amp;H3FFFFFFF)
 
    If lX4 And lY4 Then
        lResult = lResult Xor &amp;H80000000 Xor lX8 Xor lY8
    ElseIf lX4 Or lY4 Then
        If lResult And &amp;H40000000 Then
            lResult = lResult Xor &amp;HC0000000 Xor lX8 Xor lY8
        Else
            lResult = lResult Xor &amp;H40000000 Xor lX8 Xor lY8
        End If
    Else
        lResult = lResult Xor lX8 Xor lY8
    End If
 
    AddUnsigned = lResult
End Function

'*******************************************************************************
' Ch (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Ch(ByVal x As Long, _
                    ByVal y As Long, _
                    ByVal z As Long) As Long
    Ch = ((x And y) Xor ((Not x) And z))
End Function

'*******************************************************************************
' Maj (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Maj(ByVal x As Long, _
                     ByVal y As Long, _
                     ByVal z As Long) As Long
    Maj = ((x And y) Xor (x And z) Xor (y And z))
End Function

'*******************************************************************************
' S (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function (rotate right)
'*******************************************************************************
Private Function S(ByVal x As Long, _
                   ByVal n As Long) As Long
    S = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4)))))
End Function

'*******************************************************************************
' R (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function (just a right shift)
'*******************************************************************************
Private Function R(ByVal x As Long, _
                   ByVal n As Long) As Long
    R = RShift(x, CInt(n And m_lOnBits(4)))
End Function

'*******************************************************************************
' Sigma0 (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Sigma0(ByVal x As Long) As Long
    Sigma0 = (S(x, 2) Xor S(x, 13) Xor S(x, 22))
End Function

'*******************************************************************************
' Sigma1 (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Sigma1(ByVal x As Long) As Long
    Sigma1 = (S(x, 6) Xor S(x, 11) Xor S(x, 25))
End Function

'*******************************************************************************
' Gamma0 (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Gamma0(ByVal x As Long) As Long
    Gamma0 = (S(x, 7) Xor S(x, 18) Xor R(x, 3))
End Function

'*******************************************************************************
' Gamma1 (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Gamma1(ByVal x As Long) As Long
    Gamma1 = (S(x, 17) Xor S(x, 19) Xor R(x, 10))
End Function

'*******************************************************************************
' ConvertToWordArray (FUNCTION)
'
' PARAMETERS:
' (In/Out) - sMessage - String - String message
'
' RETURN VALUE:
' Long() - Converted message as long array
'
' DESCRIPTION:
' Takes the string message and puts it in a long array with padding according to
' the SHA-256 rules (similar to MD5 routine).
'*******************************************************************************
Private Function ConvertToWordArray(sMessage As String) As Long()
    Dim lMessageLength  As Long
    Dim lNumberOfWords  As Long
    Dim lWordArray()    As Long
    Dim lBytePosition   As Long
    Dim lByteCount      As Long
    Dim lWordCount      As Long
    Dim lByte           As Long
    
    Const MODULUS_BITS      As Long = 512
    Const CONGRUENT_BITS    As Long = 448
    
    lMessageLength = Len(sMessage)
    
    ' Get padded number of words. Message needs to be congruent to 448 bits,
    ' modulo 512 bits. If it is exactly congruent to 448 bits, modulo 512 bits
    ' it must still have another 512 bits added. 512 bits = 64 bytes
    ' (or 16 * 4 byte words), 448 bits = 56 bytes. This means lNumberOfWords must
    ' be a multiple of 16 (i.e. 16 * 4 (bytes) * 8 (bits))
    lNumberOfWords = (((lMessageLength + _
        ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ _
        (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * _
        (MODULUS_BITS \ BITS_TO_A_WORD)
    ReDim lWordArray(lNumberOfWords - 1)
    
    ' Combine each block of 4 bytes (ascii code of character) into one long
    ' value and store in the message. The high-order (most significant) bit of
    ' each byte is listed first. However, unlike MD5 we put the high-order
    ' (most significant) byte first in each word.
    lBytePosition = 0
    lByteCount = 0
    Do Until lByteCount &gt;= lMessageLength
        ' Each word is 4 bytes
        lWordCount = lByteCount \ BYTES_TO_A_WORD
        
        lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE
        
        ' NOTE: This is where we are using just the first byte of each unicode
        ' character, you may want to make the change here, or to the SHA256 method
        ' so it accepts a byte array.
        lByte = AscB(Mid(sMessage, lByteCount + 1, 1))
        
        lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition)
        lByteCount = lByteCount + 1
    Loop

    ' Terminate according to SHA-256 rules with a 1 bit, zeros and the length in
    ' bits stored in the last two words
    lWordCount = lByteCount \ BYTES_TO_A_WORD
    lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE

    ' Add a terminating 1 bit, all the rest of the bits to the end of the
    ' word array will default to zero
    lWordArray(lWordCount) = lWordArray(lWordCount) Or _
        LShift(&amp;H80, lBytePosition)

    ' We put the length of the message in bits into the last two words, to get
    ' the length in bits we need to multiply by 8 (or left shift 3). This left
    ' shifted value is put in the last word. Any bits shifted off the left edge
    ' need to be put in the penultimate word, we can work out which bits by shifting
    ' right the length by 29 bits.
    lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3)
    lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29)
    
    ConvertToWordArray = lWordArray
End Function

'*******************************************************************************
' SHA256 (FUNCTION)
'
' PARAMETERS:
' (In/Out) - sMessage - String - Message to digest
'
' RETURN VALUE:
' String - The digest
'
' DESCRIPTION:
' Takes a string and uses the SHA-256 digest to produce a signature for it.
'
' NOTE: Due to the way in which the string is processed the routine assumes a
' single byte character set. VB passes unicode (2-byte) character strings, the
' ConvertToWordArray function uses on the first byte for each character. This
' has been done this way for ease of use, to make the routine truely portable
' you could accept a byte array instead, it would then be up to the calling
' routine to make sure that the byte array is generated from their string in
' a manner consistent with the string type.
'*******************************************************************************
Public Function SHA256(sMessage As String) As String
    Dim HASH(7) As Long
    Dim M()     As Long
    Dim W(63)   As Long
    Dim a       As Long
    Dim b       As Long
    Dim c       As Long
    Dim d       As Long
    Dim e       As Long
    Dim f       As Long
    Dim g       As Long
    Dim h       As Long
    Dim i       As Long
    Dim j       As Long
    Dim T1      As Long
    Dim T2      As Long
    
    ' Initial hash values
    HASH(0) = &amp;H6A09E667
    HASH(1) = &amp;HBB67AE85
    HASH(2) = &amp;H3C6EF372
    HASH(3) = &amp;HA54FF53A
    HASH(4) = &amp;H510E527F
    HASH(5) = &amp;H9B05688C
    HASH(6) = &amp;H1F83D9AB
    HASH(7) = &amp;H5BE0CD19
    
    ' Preprocessing. Append padding bits and length and convert to words
    M = ConvertToWordArray(sMessage)
    
    ' Main loop
    For i = 0 To UBound(M) Step 16
        a = HASH(0)
        b = HASH(1)
        c = HASH(2)
        d = HASH(3)
        e = HASH(4)
        f = HASH(5)
        g = HASH(6)
        h = HASH(7)
        
        For j = 0 To 63
            If j &lt; 16 Then
                W(j) = M(j + i)
            Else
                W(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(W(j - 2)), _
                    W(j - 7)), Gamma0(W(j - 15))), W(j - 16))
            End If
                
            T1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(h, Sigma1(e)), _
                Ch(e, f, g)), K(j)), W(j))
            T2 = AddUnsigned(Sigma0(a), Maj(a, b, c))
            
            h = g
            g = f
            f = e
            e = AddUnsigned(d, T1)
            d = c
            c = b
            b = a
            a = AddUnsigned(T1, T2)
        Next
        
        HASH(0) = AddUnsigned(a, HASH(0))
        HASH(1) = AddUnsigned(b, HASH(1))
        HASH(2) = AddUnsigned(c, HASH(2))
        HASH(3) = AddUnsigned(d, HASH(3))
        HASH(4) = AddUnsigned(e, HASH(4))
        HASH(5) = AddUnsigned(f, HASH(5))
        HASH(6) = AddUnsigned(g, HASH(6))
        HASH(7) = AddUnsigned(h, HASH(7))
    Next
    
    ' Output the 256 bit digest
    SHA256 = LCase(Right("00000000" &amp; Hex(HASH(0)), 8) &amp; _
        Right("00000000" &amp; Hex(HASH(1)), 8) &amp; _
        Right("00000000" &amp; Hex(HASH(2)), 8) &amp; _
        Right("00000000" &amp; Hex(HASH(3)), 8) &amp; _
        Right("00000000" &amp; Hex(HASH(4)), 8) &amp; _
        Right("00000000" &amp; Hex(HASH(5)), 8) &amp; _
        Right("00000000" &amp; Hex(HASH(6)), 8) &amp; _
        Right("00000000" &amp; Hex(HASH(7)), 8))
End Function</code></pre> 4、在属性里面修改模块类名为CSHA256（属性窗口通常在左边，如果没有看到属性窗口就自己打开它，在“视图”菜单中点击“属性窗口”） 
  <a href="http://xuhehuan.com/wp-content/uploads/2016/01/excel-class-module-name.jpg" rel="nofollow"><img class="alignnone size-full wp-image-2316" src="http://xuhehuan.com/wp-content/uploads/2016/01/excel-class-module-name.jpg" alt="excel-class-module-name"></a> 5、再次在界面的“工程”空白处点击右键，选择插入模块，模块中输入以下代码 
  <pre><code class="language-vb">Public Function FunSHA256(sMessage As String)

    Dim clsX As CSHA256
    Set clsX = New CSHA256

    FunSHA256 = clsX.SHA256(sMessage)

    Set clsX = Nothing

End Function</code></pre> 6、保存并关闭，然后在该Excel中就可以通过调用函数FunSHA256来计算SHA256值了。 最后和网上的一些在线程序对比下结果，没问题的话就可以了。比如：Email地址
  <code>example@gmail.com</code>经过哈希处理后的值为
  <code>264e53d93759bde067fd01ef2698f98d1253c730d12f021116f02eebcfa9ace6</code>。
  <br>
  <br>查看原文：
  <a href="http://xuhehuan.com/2310.html" rel="nofollow">http://xuhehuan.com/2310.html</a> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/xhhjin/article/details/50520621,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/xhhjin/article/details/50520621,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
