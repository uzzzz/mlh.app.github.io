<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【python】matplotlib动态显示 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【python】matplotlib动态显示" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/zyxhangiian123456789/article/details/89159530 1.matplotlib动态绘图 python在绘图的时候，需要开启 interactive mode。核心代码如下： plt.ion(); #开启interactive mode 成功的关键函数 fig = plt.figure(1); for i in range(100): filepath=&quot;E:/Model/weights-improvement-&quot; + str(i + 1) + &quot;.hdf5&quot;; model.load_weights(filepath); #测试数据 x_new = np.linspace(low, up, 1000); y_new = getfit(model,x_new); # 显示数据 plt.clf(); plt.plot(x,y); plt.scatter(x_sample, y_sample); plt.plot(x_new,y_new); ffpath = &quot;E:/imgs/&quot; + str(i) + &quot;.jpg&quot;; plt.savefig(ffpath); plt.pause(0.01) # 暂停0.01秒 ani = animation.FuncAnimation(plt.figure(2), update,range(100),init_func=init, interval=500); ani.save(&quot;E:/test.gif&quot;,writer=&#39;pillow&#39;); plt.ioff() # 关闭交互模式 2.实例 已知下面采样自Sin函数的数据： 　 x y 1 0.093 -0.81 2 0.58 -0.45 3 1.04 -0.007 4 1.55 0.48 5 2.15 0.89 6 2.62 0.997 7 2.71 0.995 8 2.73 0.993 9 3.03 0.916 10 3.14 0.86 11 3.58 0.57 12 3.66 0.504 13 3.81 0.369 14 3.83 0.35 15 4.39 -0.199 16 4.44 -0.248 17 4.6 -0.399 18 5.39 -0.932 19 5.54 -0.975 20 5.76 -0.999 通过一个简单的三层神经网络训练一个Sin函数的拟合器，并可视化模型训练过程的拟合曲线。 2.1 网络训练实现&nbsp; 主要做的事情是定义一个三层的神经网络，输入层节点数为1，隐藏层节点数为10，输出层节点数为1。 import math; import random; from matplotlib import pyplot as plt from keras.models import Sequential from keras.layers.core import Dense from keras.optimizers import Adam import numpy as np from keras.callbacks import ModelCheckpoint import os #采样函数 def sample(low, up, num): data = []; for i in range(num): #采样 tmp = random.uniform(low, up); data.append(tmp); data.sort(); return data; #sin函数 def func(x): y = []; for i in range(len(x)): tmp = math.sin(x[i] - math.pi/3); y.append(tmp); return y; #获取模型拟合结果 def getfit(model,x): y = []; for i in range(len(x)): tmp = model.predict([x[i]], 10); y.append(tmp[0][0]); return y; #删除同一目录下的所有文件 def del_file(path): ls = os.listdir(path) for i in ls: c_path = os.path.join(path, i) if os.path.isdir(c_path): del_file(c_path) else: os.remove(c_path) if __name__ == &#39;__main__&#39;: path = &quot;E:/Model/&quot;; del_file(path); low = 0; up = 2 * math.pi; x = np.linspace(low, up, 1000); y = func(x); # 数据采样 # x_sample = sample(low,up,20); x_sample = [0.09326442022999694, 0.5812590520508311, 1.040490143783586, 1.5504427746047338, 2.1589557183817036, 2.6235357787018407, 2.712578091093361, 2.7379109336528167, 3.0339662651841186, 3.147676812083248, 3.58596337171837, 3.6621496731124314, 3.81130899864203, 3.833092859928872, 4.396611340802901, 4.4481080339256875, 4.609657879057151, 5.399731063412583, 5.54299720786794, 5.764084730699906]; y_sample = func(x_sample); # callback filepath=&quot;E:/Model/weights-improvement-{epoch:00d}.hdf5&quot;; checkpoint= ModelCheckpoint(filepath, verbose=1, save_best_only=False, mode=&#39;max&#39;); callbacks_list= [checkpoint]; # 建立顺序神经网络层次模型 model = Sequential(); model.add(Dense(10, input_dim=1, init=&#39;uniform&#39;, activation=&#39;relu&#39;)); model.add(Dense(1, init=&#39;uniform&#39;, activation=&#39;tanh&#39;)); adam = Adam(lr = 0.05); model.compile(loss=&#39;mean_squared_error&#39;, optimizer=adam, metrics=[&#39;accuracy&#39;]); model.fit(x_sample, y_sample, nb_epoch=1000, batch_size=20,callbacks=callbacks_list); #测试数据 x_new = np.linspace(low, up, 1000); y_new = getfit(model,x_new); # 数据可视化 plt.plot(x,y); plt.scatter(x_sample, y_sample); plt.plot(x_new,y_new); plt.show(); 2.2 模型保存 &nbsp;在神经网络训练的过程中，有一个非常重要的操作，就是将训练过程中模型的参数保存到本地，这是后面拟合过程可视化的基础。训练过程中保存的模型文件，如下图所示。 模型保存的关键在于fit函数中callback函数的设置，注意到，下面的代码，每次迭代，算法都会执行callbacks函数指定的函数列表中的方法。这里，我们的回调函数设置为ModelCheckpoint，其参数如下表所示： 参数 含义 filename 字符串，保存模型的路径 verbose 信息展示模式，0或1 (Epoch 00001: saving model to ...) mode ‘auto’，‘min’，‘max’ monitor 需要监视的值 save_best_only 当设置为True时，监测值有改进时才会保存当前的模型。在save_best_only=True时决定性能最佳模型的评判准则，例如，当监测值为val_acc时，模式应为max，当监测值为val_loss时，模式应为min。在auto模式下，评价准则由被监测值的名字自动推断 save_weights_only 若设置为True，则只保存模型权重，否则将保存整个模型（包括模型结构，配置信息等） period CheckPoint之间的间隔的epoch数 # callback filepath=&quot;E:/Model/weights-improvement-{epoch:00d}.hdf5&quot;; checkpoint= ModelCheckpoint(filepath, verbose=1, save_best_only=False, mode=&#39;max&#39;); callbacks_list= [checkpoint]; # 建立顺序神经网络层次模型 model = Sequential(); model.add(Dense(10, input_dim=1, init=&#39;uniform&#39;, activation=&#39;relu&#39;)); model.add(Dense(1, init=&#39;uniform&#39;, activation=&#39;tanh&#39;)); adam = Adam(lr = 0.05); model.compile(loss=&#39;mean_squared_error&#39;, optimizer=adam, metrics=[&#39;accuracy&#39;]); model.fit(x_sample, y_sample, nb_epoch=1000, batch_size=20,callbacks=callbacks_list); 2.3&nbsp;拟合过程可视化实现&nbsp; 利用上述保存的模型，我们就可以通过matplotlib实时地显示拟合过程。 import math; import random; from matplotlib import pyplot as plt from keras.models import Sequential from keras.layers.core import Dense import numpy as np import matplotlib.animation as animation from PIL import Image #定义kdd99数据预处理函数 def sample(low, up, num): data = []; for i in range(num): #采样 tmp = random.uniform(low, up); data.append(tmp); data.sort(); return data; def func(x): y = []; for i in range(len(x)): tmp = math.sin(x[i] - math.pi/3); y.append(tmp); return y; def getfit(model,x): y = []; for i in range(len(x)): tmp = model.predict([x[i]], 10); y.append(tmp[0][0]); return y; def init(): fpath = &quot;E:/imgs/0.jpg&quot;; img = Image.open(fpath); plt.axis(&#39;off&#39;) # 关掉坐标轴为 off return plt.imshow(img); def update(i): fpath = &quot;E:/imgs/&quot; + str(i) + &quot;.jpg&quot;; img = Image.open(fpath); plt.axis(&#39;off&#39;) # 关掉坐标轴为 off return plt.imshow(img); if __name__ == &#39;__main__&#39;: low = 0; up = 2 * math.pi; x = np.linspace(low, up, 1000); y = func(x); # 数据采样 # x_sample = sample(low,up,20); x_sample = [0.09326442022999694, 0.5812590520508311, 1.040490143783586, 1.5504427746047338, 2.1589557183817036, 2.6235357787018407, 2.712578091093361, 2.7379109336528167, 3.0339662651841186, 3.147676812083248, 3.58596337171837, 3.6621496731124314, 3.81130899864203, 3.833092859928872, 4.396611340802901, 4.4481080339256875, 4.609657879057151, 5.399731063412583, 5.54299720786794, 5.764084730699906]; y_sample = func(x_sample); # 建立顺序神经网络层次模型 model = Sequential(); model.add(Dense(10, input_dim=1, init=&#39;uniform&#39;, activation=&#39;relu&#39;)); model.add(Dense(1, init=&#39;uniform&#39;, activation=&#39;tanh&#39;)); plt.ion(); #开启interactive mode 成功的关键函数 fig = plt.figure(1); for i in range(100): filepath=&quot;E:/Model/weights-improvement-&quot; + str(i + 1) + &quot;.hdf5&quot;; model.load_weights(filepath); #测试数据 x_new = np.linspace(low, up, 1000); y_new = getfit(model,x_new); # 显示数据 plt.clf(); plt.plot(x,y); plt.scatter(x_sample, y_sample); plt.plot(x_new,y_new); ffpath = &quot;E:/imgs/&quot; + str(i) + &quot;.jpg&quot;; plt.savefig(ffpath); plt.pause(0.01) # 暂停0.01秒 ani = animation.FuncAnimation(plt.figure(2), update,range(100),init_func=init, interval=500); ani.save(&quot;E:/test.gif&quot;,writer=&#39;pillow&#39;); plt.ioff() # 关闭交互模式" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/zyxhangiian123456789/article/details/89159530 1.matplotlib动态绘图 python在绘图的时候，需要开启 interactive mode。核心代码如下： plt.ion(); #开启interactive mode 成功的关键函数 fig = plt.figure(1); for i in range(100): filepath=&quot;E:/Model/weights-improvement-&quot; + str(i + 1) + &quot;.hdf5&quot;; model.load_weights(filepath); #测试数据 x_new = np.linspace(low, up, 1000); y_new = getfit(model,x_new); # 显示数据 plt.clf(); plt.plot(x,y); plt.scatter(x_sample, y_sample); plt.plot(x_new,y_new); ffpath = &quot;E:/imgs/&quot; + str(i) + &quot;.jpg&quot;; plt.savefig(ffpath); plt.pause(0.01) # 暂停0.01秒 ani = animation.FuncAnimation(plt.figure(2), update,range(100),init_func=init, interval=500); ani.save(&quot;E:/test.gif&quot;,writer=&#39;pillow&#39;); plt.ioff() # 关闭交互模式 2.实例 已知下面采样自Sin函数的数据： 　 x y 1 0.093 -0.81 2 0.58 -0.45 3 1.04 -0.007 4 1.55 0.48 5 2.15 0.89 6 2.62 0.997 7 2.71 0.995 8 2.73 0.993 9 3.03 0.916 10 3.14 0.86 11 3.58 0.57 12 3.66 0.504 13 3.81 0.369 14 3.83 0.35 15 4.39 -0.199 16 4.44 -0.248 17 4.6 -0.399 18 5.39 -0.932 19 5.54 -0.975 20 5.76 -0.999 通过一个简单的三层神经网络训练一个Sin函数的拟合器，并可视化模型训练过程的拟合曲线。 2.1 网络训练实现&nbsp; 主要做的事情是定义一个三层的神经网络，输入层节点数为1，隐藏层节点数为10，输出层节点数为1。 import math; import random; from matplotlib import pyplot as plt from keras.models import Sequential from keras.layers.core import Dense from keras.optimizers import Adam import numpy as np from keras.callbacks import ModelCheckpoint import os #采样函数 def sample(low, up, num): data = []; for i in range(num): #采样 tmp = random.uniform(low, up); data.append(tmp); data.sort(); return data; #sin函数 def func(x): y = []; for i in range(len(x)): tmp = math.sin(x[i] - math.pi/3); y.append(tmp); return y; #获取模型拟合结果 def getfit(model,x): y = []; for i in range(len(x)): tmp = model.predict([x[i]], 10); y.append(tmp[0][0]); return y; #删除同一目录下的所有文件 def del_file(path): ls = os.listdir(path) for i in ls: c_path = os.path.join(path, i) if os.path.isdir(c_path): del_file(c_path) else: os.remove(c_path) if __name__ == &#39;__main__&#39;: path = &quot;E:/Model/&quot;; del_file(path); low = 0; up = 2 * math.pi; x = np.linspace(low, up, 1000); y = func(x); # 数据采样 # x_sample = sample(low,up,20); x_sample = [0.09326442022999694, 0.5812590520508311, 1.040490143783586, 1.5504427746047338, 2.1589557183817036, 2.6235357787018407, 2.712578091093361, 2.7379109336528167, 3.0339662651841186, 3.147676812083248, 3.58596337171837, 3.6621496731124314, 3.81130899864203, 3.833092859928872, 4.396611340802901, 4.4481080339256875, 4.609657879057151, 5.399731063412583, 5.54299720786794, 5.764084730699906]; y_sample = func(x_sample); # callback filepath=&quot;E:/Model/weights-improvement-{epoch:00d}.hdf5&quot;; checkpoint= ModelCheckpoint(filepath, verbose=1, save_best_only=False, mode=&#39;max&#39;); callbacks_list= [checkpoint]; # 建立顺序神经网络层次模型 model = Sequential(); model.add(Dense(10, input_dim=1, init=&#39;uniform&#39;, activation=&#39;relu&#39;)); model.add(Dense(1, init=&#39;uniform&#39;, activation=&#39;tanh&#39;)); adam = Adam(lr = 0.05); model.compile(loss=&#39;mean_squared_error&#39;, optimizer=adam, metrics=[&#39;accuracy&#39;]); model.fit(x_sample, y_sample, nb_epoch=1000, batch_size=20,callbacks=callbacks_list); #测试数据 x_new = np.linspace(low, up, 1000); y_new = getfit(model,x_new); # 数据可视化 plt.plot(x,y); plt.scatter(x_sample, y_sample); plt.plot(x_new,y_new); plt.show(); 2.2 模型保存 &nbsp;在神经网络训练的过程中，有一个非常重要的操作，就是将训练过程中模型的参数保存到本地，这是后面拟合过程可视化的基础。训练过程中保存的模型文件，如下图所示。 模型保存的关键在于fit函数中callback函数的设置，注意到，下面的代码，每次迭代，算法都会执行callbacks函数指定的函数列表中的方法。这里，我们的回调函数设置为ModelCheckpoint，其参数如下表所示： 参数 含义 filename 字符串，保存模型的路径 verbose 信息展示模式，0或1 (Epoch 00001: saving model to ...) mode ‘auto’，‘min’，‘max’ monitor 需要监视的值 save_best_only 当设置为True时，监测值有改进时才会保存当前的模型。在save_best_only=True时决定性能最佳模型的评判准则，例如，当监测值为val_acc时，模式应为max，当监测值为val_loss时，模式应为min。在auto模式下，评价准则由被监测值的名字自动推断 save_weights_only 若设置为True，则只保存模型权重，否则将保存整个模型（包括模型结构，配置信息等） period CheckPoint之间的间隔的epoch数 # callback filepath=&quot;E:/Model/weights-improvement-{epoch:00d}.hdf5&quot;; checkpoint= ModelCheckpoint(filepath, verbose=1, save_best_only=False, mode=&#39;max&#39;); callbacks_list= [checkpoint]; # 建立顺序神经网络层次模型 model = Sequential(); model.add(Dense(10, input_dim=1, init=&#39;uniform&#39;, activation=&#39;relu&#39;)); model.add(Dense(1, init=&#39;uniform&#39;, activation=&#39;tanh&#39;)); adam = Adam(lr = 0.05); model.compile(loss=&#39;mean_squared_error&#39;, optimizer=adam, metrics=[&#39;accuracy&#39;]); model.fit(x_sample, y_sample, nb_epoch=1000, batch_size=20,callbacks=callbacks_list); 2.3&nbsp;拟合过程可视化实现&nbsp; 利用上述保存的模型，我们就可以通过matplotlib实时地显示拟合过程。 import math; import random; from matplotlib import pyplot as plt from keras.models import Sequential from keras.layers.core import Dense import numpy as np import matplotlib.animation as animation from PIL import Image #定义kdd99数据预处理函数 def sample(low, up, num): data = []; for i in range(num): #采样 tmp = random.uniform(low, up); data.append(tmp); data.sort(); return data; def func(x): y = []; for i in range(len(x)): tmp = math.sin(x[i] - math.pi/3); y.append(tmp); return y; def getfit(model,x): y = []; for i in range(len(x)): tmp = model.predict([x[i]], 10); y.append(tmp[0][0]); return y; def init(): fpath = &quot;E:/imgs/0.jpg&quot;; img = Image.open(fpath); plt.axis(&#39;off&#39;) # 关掉坐标轴为 off return plt.imshow(img); def update(i): fpath = &quot;E:/imgs/&quot; + str(i) + &quot;.jpg&quot;; img = Image.open(fpath); plt.axis(&#39;off&#39;) # 关掉坐标轴为 off return plt.imshow(img); if __name__ == &#39;__main__&#39;: low = 0; up = 2 * math.pi; x = np.linspace(low, up, 1000); y = func(x); # 数据采样 # x_sample = sample(low,up,20); x_sample = [0.09326442022999694, 0.5812590520508311, 1.040490143783586, 1.5504427746047338, 2.1589557183817036, 2.6235357787018407, 2.712578091093361, 2.7379109336528167, 3.0339662651841186, 3.147676812083248, 3.58596337171837, 3.6621496731124314, 3.81130899864203, 3.833092859928872, 4.396611340802901, 4.4481080339256875, 4.609657879057151, 5.399731063412583, 5.54299720786794, 5.764084730699906]; y_sample = func(x_sample); # 建立顺序神经网络层次模型 model = Sequential(); model.add(Dense(10, input_dim=1, init=&#39;uniform&#39;, activation=&#39;relu&#39;)); model.add(Dense(1, init=&#39;uniform&#39;, activation=&#39;tanh&#39;)); plt.ion(); #开启interactive mode 成功的关键函数 fig = plt.figure(1); for i in range(100): filepath=&quot;E:/Model/weights-improvement-&quot; + str(i + 1) + &quot;.hdf5&quot;; model.load_weights(filepath); #测试数据 x_new = np.linspace(low, up, 1000); y_new = getfit(model,x_new); # 显示数据 plt.clf(); plt.plot(x,y); plt.scatter(x_sample, y_sample); plt.plot(x_new,y_new); ffpath = &quot;E:/imgs/&quot; + str(i) + &quot;.jpg&quot;; plt.savefig(ffpath); plt.pause(0.01) # 暂停0.01秒 ani = animation.FuncAnimation(plt.figure(2), update,range(100),init_func=init, interval=500); ani.save(&quot;E:/test.gif&quot;,writer=&#39;pillow&#39;); plt.ioff() # 关闭交互模式" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/zyxhangiian123456789/article/details/89159530 1.matplotlib动态绘图 python在绘图的时候，需要开启 interactive mode。核心代码如下： plt.ion(); #开启interactive mode 成功的关键函数 fig = plt.figure(1); for i in range(100): filepath=&quot;E:/Model/weights-improvement-&quot; + str(i + 1) + &quot;.hdf5&quot;; model.load_weights(filepath); #测试数据 x_new = np.linspace(low, up, 1000); y_new = getfit(model,x_new); # 显示数据 plt.clf(); plt.plot(x,y); plt.scatter(x_sample, y_sample); plt.plot(x_new,y_new); ffpath = &quot;E:/imgs/&quot; + str(i) + &quot;.jpg&quot;; plt.savefig(ffpath); plt.pause(0.01) # 暂停0.01秒 ani = animation.FuncAnimation(plt.figure(2), update,range(100),init_func=init, interval=500); ani.save(&quot;E:/test.gif&quot;,writer=&#39;pillow&#39;); plt.ioff() # 关闭交互模式 2.实例 已知下面采样自Sin函数的数据： 　 x y 1 0.093 -0.81 2 0.58 -0.45 3 1.04 -0.007 4 1.55 0.48 5 2.15 0.89 6 2.62 0.997 7 2.71 0.995 8 2.73 0.993 9 3.03 0.916 10 3.14 0.86 11 3.58 0.57 12 3.66 0.504 13 3.81 0.369 14 3.83 0.35 15 4.39 -0.199 16 4.44 -0.248 17 4.6 -0.399 18 5.39 -0.932 19 5.54 -0.975 20 5.76 -0.999 通过一个简单的三层神经网络训练一个Sin函数的拟合器，并可视化模型训练过程的拟合曲线。 2.1 网络训练实现&nbsp; 主要做的事情是定义一个三层的神经网络，输入层节点数为1，隐藏层节点数为10，输出层节点数为1。 import math; import random; from matplotlib import pyplot as plt from keras.models import Sequential from keras.layers.core import Dense from keras.optimizers import Adam import numpy as np from keras.callbacks import ModelCheckpoint import os #采样函数 def sample(low, up, num): data = []; for i in range(num): #采样 tmp = random.uniform(low, up); data.append(tmp); data.sort(); return data; #sin函数 def func(x): y = []; for i in range(len(x)): tmp = math.sin(x[i] - math.pi/3); y.append(tmp); return y; #获取模型拟合结果 def getfit(model,x): y = []; for i in range(len(x)): tmp = model.predict([x[i]], 10); y.append(tmp[0][0]); return y; #删除同一目录下的所有文件 def del_file(path): ls = os.listdir(path) for i in ls: c_path = os.path.join(path, i) if os.path.isdir(c_path): del_file(c_path) else: os.remove(c_path) if __name__ == &#39;__main__&#39;: path = &quot;E:/Model/&quot;; del_file(path); low = 0; up = 2 * math.pi; x = np.linspace(low, up, 1000); y = func(x); # 数据采样 # x_sample = sample(low,up,20); x_sample = [0.09326442022999694, 0.5812590520508311, 1.040490143783586, 1.5504427746047338, 2.1589557183817036, 2.6235357787018407, 2.712578091093361, 2.7379109336528167, 3.0339662651841186, 3.147676812083248, 3.58596337171837, 3.6621496731124314, 3.81130899864203, 3.833092859928872, 4.396611340802901, 4.4481080339256875, 4.609657879057151, 5.399731063412583, 5.54299720786794, 5.764084730699906]; y_sample = func(x_sample); # callback filepath=&quot;E:/Model/weights-improvement-{epoch:00d}.hdf5&quot;; checkpoint= ModelCheckpoint(filepath, verbose=1, save_best_only=False, mode=&#39;max&#39;); callbacks_list= [checkpoint]; # 建立顺序神经网络层次模型 model = Sequential(); model.add(Dense(10, input_dim=1, init=&#39;uniform&#39;, activation=&#39;relu&#39;)); model.add(Dense(1, init=&#39;uniform&#39;, activation=&#39;tanh&#39;)); adam = Adam(lr = 0.05); model.compile(loss=&#39;mean_squared_error&#39;, optimizer=adam, metrics=[&#39;accuracy&#39;]); model.fit(x_sample, y_sample, nb_epoch=1000, batch_size=20,callbacks=callbacks_list); #测试数据 x_new = np.linspace(low, up, 1000); y_new = getfit(model,x_new); # 数据可视化 plt.plot(x,y); plt.scatter(x_sample, y_sample); plt.plot(x_new,y_new); plt.show(); 2.2 模型保存 &nbsp;在神经网络训练的过程中，有一个非常重要的操作，就是将训练过程中模型的参数保存到本地，这是后面拟合过程可视化的基础。训练过程中保存的模型文件，如下图所示。 模型保存的关键在于fit函数中callback函数的设置，注意到，下面的代码，每次迭代，算法都会执行callbacks函数指定的函数列表中的方法。这里，我们的回调函数设置为ModelCheckpoint，其参数如下表所示： 参数 含义 filename 字符串，保存模型的路径 verbose 信息展示模式，0或1 (Epoch 00001: saving model to ...) mode ‘auto’，‘min’，‘max’ monitor 需要监视的值 save_best_only 当设置为True时，监测值有改进时才会保存当前的模型。在save_best_only=True时决定性能最佳模型的评判准则，例如，当监测值为val_acc时，模式应为max，当监测值为val_loss时，模式应为min。在auto模式下，评价准则由被监测值的名字自动推断 save_weights_only 若设置为True，则只保存模型权重，否则将保存整个模型（包括模型结构，配置信息等） period CheckPoint之间的间隔的epoch数 # callback filepath=&quot;E:/Model/weights-improvement-{epoch:00d}.hdf5&quot;; checkpoint= ModelCheckpoint(filepath, verbose=1, save_best_only=False, mode=&#39;max&#39;); callbacks_list= [checkpoint]; # 建立顺序神经网络层次模型 model = Sequential(); model.add(Dense(10, input_dim=1, init=&#39;uniform&#39;, activation=&#39;relu&#39;)); model.add(Dense(1, init=&#39;uniform&#39;, activation=&#39;tanh&#39;)); adam = Adam(lr = 0.05); model.compile(loss=&#39;mean_squared_error&#39;, optimizer=adam, metrics=[&#39;accuracy&#39;]); model.fit(x_sample, y_sample, nb_epoch=1000, batch_size=20,callbacks=callbacks_list); 2.3&nbsp;拟合过程可视化实现&nbsp; 利用上述保存的模型，我们就可以通过matplotlib实时地显示拟合过程。 import math; import random; from matplotlib import pyplot as plt from keras.models import Sequential from keras.layers.core import Dense import numpy as np import matplotlib.animation as animation from PIL import Image #定义kdd99数据预处理函数 def sample(low, up, num): data = []; for i in range(num): #采样 tmp = random.uniform(low, up); data.append(tmp); data.sort(); return data; def func(x): y = []; for i in range(len(x)): tmp = math.sin(x[i] - math.pi/3); y.append(tmp); return y; def getfit(model,x): y = []; for i in range(len(x)): tmp = model.predict([x[i]], 10); y.append(tmp[0][0]); return y; def init(): fpath = &quot;E:/imgs/0.jpg&quot;; img = Image.open(fpath); plt.axis(&#39;off&#39;) # 关掉坐标轴为 off return plt.imshow(img); def update(i): fpath = &quot;E:/imgs/&quot; + str(i) + &quot;.jpg&quot;; img = Image.open(fpath); plt.axis(&#39;off&#39;) # 关掉坐标轴为 off return plt.imshow(img); if __name__ == &#39;__main__&#39;: low = 0; up = 2 * math.pi; x = np.linspace(low, up, 1000); y = func(x); # 数据采样 # x_sample = sample(low,up,20); x_sample = [0.09326442022999694, 0.5812590520508311, 1.040490143783586, 1.5504427746047338, 2.1589557183817036, 2.6235357787018407, 2.712578091093361, 2.7379109336528167, 3.0339662651841186, 3.147676812083248, 3.58596337171837, 3.6621496731124314, 3.81130899864203, 3.833092859928872, 4.396611340802901, 4.4481080339256875, 4.609657879057151, 5.399731063412583, 5.54299720786794, 5.764084730699906]; y_sample = func(x_sample); # 建立顺序神经网络层次模型 model = Sequential(); model.add(Dense(10, input_dim=1, init=&#39;uniform&#39;, activation=&#39;relu&#39;)); model.add(Dense(1, init=&#39;uniform&#39;, activation=&#39;tanh&#39;)); plt.ion(); #开启interactive mode 成功的关键函数 fig = plt.figure(1); for i in range(100): filepath=&quot;E:/Model/weights-improvement-&quot; + str(i + 1) + &quot;.hdf5&quot;; model.load_weights(filepath); #测试数据 x_new = np.linspace(low, up, 1000); y_new = getfit(model,x_new); # 显示数据 plt.clf(); plt.plot(x,y); plt.scatter(x_sample, y_sample); plt.plot(x_new,y_new); ffpath = &quot;E:/imgs/&quot; + str(i) + &quot;.jpg&quot;; plt.savefig(ffpath); plt.pause(0.01) # 暂停0.01秒 ani = animation.FuncAnimation(plt.figure(2), update,range(100),init_func=init, interval=500); ani.save(&quot;E:/test.gif&quot;,writer=&#39;pillow&#39;); plt.ioff() # 关闭交互模式","@type":"BlogPosting","url":"/2019/04/09/727800.html","headline":"【python】matplotlib动态显示","dateModified":"2019-04-09T00:00:00+08:00","datePublished":"2019-04-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/09/727800.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【python】matplotlib动态显示</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/zyxhangiian123456789/article/details/89159530 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1>1.matplotlib动态绘图</h1> 
  <p style="text-indent:50px;">python在绘图的时候，需要开启 interactive mode。核心代码如下：</p> 
  <pre class="has">
<code>    plt.ion(); #开启interactive mode 成功的关键函数
    fig = plt.figure(1);
    
    for i in range(100):
        filepath="E:/Model/weights-improvement-" + str(i + 1) + ".hdf5";
        model.load_weights(filepath);
        #测试数据
        x_new = np.linspace(low, up, 1000);
        y_new = getfit(model,x_new);
        # 显示数据
        plt.clf();
        plt.plot(x,y); 
        plt.scatter(x_sample, y_sample);
        plt.plot(x_new,y_new);
        
        ffpath = "E:/imgs/" + str(i) + ".jpg";
        plt.savefig(ffpath);

        plt.pause(0.01)             # 暂停0.01秒
        
    ani = animation.FuncAnimation(plt.figure(2), update,range(100),init_func=init, interval=500);
    ani.save("E:/test.gif",writer='pillow');
    
    plt.ioff()                 # 关闭交互模式</code></pre> 
  <h1>2.实例</h1> 
  <p style="text-indent:50px;">已知下面采样自Sin函数的数据：</p> 
  <table cellspacing="0" style="width:144pt;">
   <tbody>
    <tr>
     <td style="vertical-align:bottom;width:48pt;"><span style="color:#000000;">　</span></td> 
     <td style="text-align:center;vertical-align:middle;width:48pt;"><span style="color:#000000;">x</span></td> 
     <td style="text-align:center;vertical-align:middle;width:48pt;"><span style="color:#000000;">y</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">1</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.093</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">-0.81</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">2</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.58</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">-0.45</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">3</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">1.04</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">-0.007</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">4</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">1.55</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.48</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">5</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">2.15</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.89</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">6</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">2.62</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.997</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">7</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">2.71</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.995</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">8</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">2.73</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.993</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">9</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">3.03</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.916</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">10</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">3.14</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.86</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">11</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">3.58</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.57</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">12</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">3.66</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.504</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">13</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">3.81</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">0.369</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">14</span></td> 
     <td style="text-align:center;vertical-align:middle;"><span style="color:#000000;">3.83</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">0.35</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">15</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">4.39</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">-0.199</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">16</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">4.44</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">-0.248</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">17</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">4.6</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">-0.399</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">18</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">5.39</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">-0.932</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">19</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">5.54</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">-0.975</span></td> 
    </tr>
    <tr>
     <td style="vertical-align:bottom;"><span style="color:#000000;">20</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">5.76</span></td> 
     <td style="text-align:center;vertical-align:bottom;"><span style="color:#000000;">-0.999</span></td> 
    </tr>
   </tbody>
  </table>
  <p style="text-indent:50px;">通过一个简单的三层神经网络训练一个Sin函数的拟合器，并可视化模型训练过程的拟合曲线。</p> 
  <p style="text-align:center;"><img alt="" class="has" height="300" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190409194755701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5eGhhbmdpaWFuMTIzNDU2Nzg5,size_16,color_FFFFFF,t_70" width="300"></p> 
  <h2>2.1 网络训练实现&nbsp;</h2> 
  <p style="text-indent:50px;">主要做的事情是定义一个三层的神经网络，输入层节点数为1，隐藏层节点数为10，输出层节点数为1。</p> 
  <pre class="has">
<code>import math;
import random;
from matplotlib import pyplot as plt
from keras.models import Sequential
from keras.layers.core import Dense
from keras.optimizers import Adam
import numpy as np
from keras.callbacks import ModelCheckpoint
import os


#采样函数
def sample(low, up, num):
    data = [];
    for i in range(num):
        #采样
        tmp = random.uniform(low, up);
        data.append(tmp);
    data.sort();
    return data;

#sin函数
def func(x):
    y = [];
    for i in range(len(x)):
        tmp = math.sin(x[i] - math.pi/3);
        y.append(tmp);
    return y;

#获取模型拟合结果
def getfit(model,x):    
    y = [];
    for i in range(len(x)):
        tmp = model.predict([x[i]], 10);
        y.append(tmp[0][0]);
    return y;

#删除同一目录下的所有文件
def del_file(path):
    ls = os.listdir(path)
    for i in ls:
        c_path = os.path.join(path, i)
        if os.path.isdir(c_path):
            del_file(c_path)
        else:
            os.remove(c_path)

if __name__ == '__main__':    
    path = "E:/Model/";
    del_file(path);
    
    low = 0;
    up = 2 * math.pi;
    x = np.linspace(low, up, 1000);
    y = func(x);
    
    # 数据采样
#     x_sample = sample(low,up,20);
    x_sample = [0.09326442022999694, 0.5812590520508311, 1.040490143783586, 1.5504427746047338, 2.1589557183817036, 2.6235357787018407, 2.712578091093361, 2.7379109336528167, 3.0339662651841186, 3.147676812083248, 3.58596337171837, 3.6621496731124314, 3.81130899864203, 3.833092859928872, 4.396611340802901, 4.4481080339256875, 4.609657879057151, 5.399731063412583, 5.54299720786794, 5.764084730699906];
    y_sample = func(x_sample);
    
    # callback
    filepath="E:/Model/weights-improvement-{epoch:00d}.hdf5";
    checkpoint= ModelCheckpoint(filepath, verbose=1, save_best_only=False, mode='max');
    callbacks_list= [checkpoint];
    
    # 建立顺序神经网络层次模型
    model = Sequential();  
    model.add(Dense(10, input_dim=1, init='uniform', activation='relu'));
    model.add(Dense(1, init='uniform', activation='tanh'));
    adam = Adam(lr = 0.05);
    model.compile(loss='mean_squared_error', optimizer=adam, metrics=['accuracy']);
    model.fit(x_sample, y_sample, nb_epoch=1000, batch_size=20,callbacks=callbacks_list);
    
    #测试数据
    x_new = np.linspace(low, up, 1000);
    y_new = getfit(model,x_new);
    
    # 数据可视化
    plt.plot(x,y); 
    plt.scatter(x_sample, y_sample);
    plt.plot(x_new,y_new);
    
    plt.show();</code></pre> 
  <h2>2.2 模型保存</h2> 
  <p style="text-indent:50px;">&nbsp;在神经网络训练的过程中，有一个非常重要的操作，就是将训练过程中模型的参数保存到本地，这是后面拟合过程可视化的基础。训练过程中保存的模型文件，如下图所示。</p> 
  <p style="text-align:center;"><img alt="" class="has" height="483" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190409195718834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5eGhhbmdpaWFuMTIzNDU2Nzg5,size_16,color_FFFFFF,t_70" width="900"></p> 
  <p style="text-indent:50px;">模型保存的关键在于fit函数中callback函数的设置，注意到，下面的代码，每次迭代，算法都会执行callbacks函数指定的函数列表中的方法。这里，我们的回调函数设置为ModelCheckpoint，其参数如下表所示：</p> 
  <table border="1" cellpadding="1" cellspacing="1" style="width:500px;">
   <tbody>
    <tr>
     <td>参数</td> 
     <td>含义</td> 
    </tr>
    <tr>
     <td>filename</td> 
     <td>字符串，保存模型的路径</td> 
    </tr>
    <tr>
     <td>verbose</td> 
     <td> <p>信息展示模式，0或1</p> <p>(Epoch 00001: saving model to ...)</p> </td> 
    </tr>
    <tr>
     <td>mode</td> 
     <td>‘auto’，‘min’，‘max’</td> 
    </tr>
    <tr>
     <td>monitor</td> 
     <td>需要监视的值</td> 
    </tr>
    <tr>
     <td>save_best_only</td> 
     <td>当设置为True时，监测值有改进时才会保存当前的模型。在save_best_only=True时决定性能最佳模型的评判准则，例如，当监测值为val_acc时，模式应为max，当监测值为val_loss时，模式应为min。在auto模式下，评价准则由被监测值的名字自动推断</td> 
    </tr>
    <tr>
     <td>save_weights_only</td> 
     <td>若设置为True，则只保存模型权重，否则将保存整个模型（包括模型结构，配置信息等）</td> 
    </tr>
    <tr>
     <td>period</td> 
     <td>CheckPoint之间的间隔的epoch数</td> 
    </tr>
   </tbody>
  </table>
  <pre class="has">
<code>    # callback
    filepath="E:/Model/weights-improvement-{epoch:00d}.hdf5";
    checkpoint= ModelCheckpoint(filepath, verbose=1, save_best_only=False, mode='max');
    callbacks_list= [checkpoint];
    
    # 建立顺序神经网络层次模型
    model = Sequential();  
    model.add(Dense(10, input_dim=1, init='uniform', activation='relu'));
    model.add(Dense(1, init='uniform', activation='tanh'));
    adam = Adam(lr = 0.05);
    model.compile(loss='mean_squared_error', optimizer=adam, metrics=['accuracy']);
    model.fit(x_sample, y_sample, nb_epoch=1000, batch_size=20,callbacks=callbacks_list);</code></pre> 
  <h2>2.3&nbsp;拟合过程可视化实现&nbsp;</h2> 
  <p style="text-indent:50px;">利用上述保存的模型，我们就可以通过matplotlib实时地显示拟合过程。</p> 
  <pre class="has">
<code>import math;
import random;
from matplotlib import pyplot as plt
from keras.models import Sequential
from keras.layers.core import Dense
import numpy as np
import matplotlib.animation as animation
from PIL import Image

#定义kdd99数据预处理函数
def sample(low, up, num):
    data = [];
    for i in range(num):
        #采样
        tmp = random.uniform(low, up);
        data.append(tmp);
    data.sort();
    return data;

def func(x):
    y = [];
    for i in range(len(x)):
        tmp = math.sin(x[i] - math.pi/3);
        y.append(tmp);
    return y;

def getfit(model,x):    
    y = [];
    for i in range(len(x)):
        tmp = model.predict([x[i]], 10);
        y.append(tmp[0][0]);
    return y;

def init():
    fpath = "E:/imgs/0.jpg";
    img = Image.open(fpath);
    plt.axis('off') # 关掉坐标轴为 off
    return plt.imshow(img);

def update(i): 
    fpath = "E:/imgs/" + str(i) + ".jpg";
    img = Image.open(fpath);
    plt.axis('off') # 关掉坐标轴为 off
    return plt.imshow(img);

if __name__ == '__main__':    
    low = 0;
    up = 2 * math.pi;
    x = np.linspace(low, up, 1000);
    y = func(x);
    
    # 数据采样
#     x_sample = sample(low,up,20);
    x_sample = [0.09326442022999694, 0.5812590520508311, 1.040490143783586, 1.5504427746047338, 2.1589557183817036, 2.6235357787018407, 2.712578091093361, 2.7379109336528167, 3.0339662651841186, 3.147676812083248, 3.58596337171837, 3.6621496731124314, 3.81130899864203, 3.833092859928872, 4.396611340802901, 4.4481080339256875, 4.609657879057151, 5.399731063412583, 5.54299720786794, 5.764084730699906];
    y_sample = func(x_sample);
    
    # 建立顺序神经网络层次模型
    model = Sequential();  
    model.add(Dense(10, input_dim=1, init='uniform', activation='relu'));
    model.add(Dense(1, init='uniform', activation='tanh'));
        
    plt.ion(); #开启interactive mode 成功的关键函数
    fig = plt.figure(1);
    
    for i in range(100):
        filepath="E:/Model/weights-improvement-" + str(i + 1) + ".hdf5";
        model.load_weights(filepath);
        #测试数据
        x_new = np.linspace(low, up, 1000);
        y_new = getfit(model,x_new);
        # 显示数据
        plt.clf();
        plt.plot(x,y); 
        plt.scatter(x_sample, y_sample);
        plt.plot(x_new,y_new);
        
        ffpath = "E:/imgs/" + str(i) + ".jpg";
        plt.savefig(ffpath);

        plt.pause(0.01)             # 暂停0.01秒
        
    ani = animation.FuncAnimation(plt.figure(2), update,range(100),init_func=init, interval=500);
    ani.save("E:/test.gif",writer='pillow');
    
    plt.ioff()                 # 关闭交互模式</code></pre> 
  <p style="text-align:center;"><img alt="" class="has" height="480" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190409194329604.gif" width="640"></p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
