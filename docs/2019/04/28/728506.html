<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>彻底吃透浏览器的缓存机制！ | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="彻底吃透浏览器的缓存机制！" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="作者 | 浪里行舟 责编 | 胡巍巍 前言 缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。 接下来的内容中我们将通过缓存位置、缓存策略以及实际场景应用缓存策略来探讨浏览器缓存机制。 缓存位置 从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache 1.Service Worker Service&nbsp;Worker&nbsp;是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用&nbsp;Service&nbsp;Worker的话，传输协议必须为&nbsp;HTTPS。因为&nbsp;Service&nbsp;Worker&nbsp;中涉及到请求拦截，所以必须使用&nbsp;HTTPS&nbsp;协议来保障安全。Service&nbsp;Worker&nbsp;的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service&nbsp;Worker&nbsp;实现缓存功能一般分为三个步骤：首先需要先注册&nbsp;Service&nbsp;Worker，然后监听到&nbsp;install&nbsp;事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当&nbsp;Service&nbsp;Worker&nbsp;没有命中缓存的时候，我们需要去调用&nbsp;fetch&nbsp;函数获取数据。也就是说，如果我们没有在&nbsp;Service&nbsp;Worker&nbsp;命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从&nbsp;Memory&nbsp;Cache&nbsp;中还是从网络请求中获取的数据，浏览器都会显示我们是从&nbsp;Service&nbsp;Worker&nbsp;中获取的内容。 2.Memory Cache Memory&nbsp;Cache&nbsp;也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。&nbsp;一旦我们关闭&nbsp;Tab&nbsp;页面，内存中的缓存也就被释放了。 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。 内存缓存中有一块重要的缓存资源是preloader相关指令（例如&nbsp;&lt;linkrel=&quot;prefetch&quot;&gt;）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 3.Disk Cache Disk&nbsp;Cache&nbsp;也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之&nbsp;Memory&nbsp;Cache&nbsp;胜在容量和存储时效性上。 在所有浏览器缓存中，Disk&nbsp;Cache&nbsp;覆盖面基本是最大的。它会根据&nbsp;HTTP&nbsp;Herder&nbsp;中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自&nbsp;Disk&nbsp;Cache，关于&nbsp;HTTP&nbsp;的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 4.Push Cache Push&nbsp;Cache（推送缓存）是&nbsp;HTTP/2&nbsp;中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 Push&nbsp;Cache&nbsp;在国内能够查到的资料很少，也是因为&nbsp;HTTP/2&nbsp;在国内不够普及。这里推荐阅读&nbsp;JakeArchibald的&nbsp;HTTP/2&nbsp;push&nbsp;is&nbsp;tougher&nbsp;than&nbsp;I&nbsp;thought&nbsp;这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push&nbsp;Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置&nbsp;HTTP&nbsp;Header&nbsp;来实现的。 缓存过程分析 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求&nbsp;–&nbsp;服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图： 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。 强缓存 强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from&nbsp;disk&nbsp;cache或from&nbsp;memory&nbsp;cache。强缓存可以通过设置两种&nbsp;HTTP&nbsp;Header&nbsp;实现：Expires&nbsp;和&nbsp;Cache-Control。 1.Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age&nbsp;+&nbsp;请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires&nbsp;是&nbsp;HTTP/1&nbsp;的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。&nbsp; Expires:Wed,22Oct201808:41:00GMT表示资源会在&nbsp;Wed,&nbsp;22&nbsp;Oct&nbsp;2018&nbsp;08:41:00&nbsp;GMT&nbsp;后过期，需要再次请求。 2.Cache-Control 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当&nbsp;Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 Cache-Control&nbsp;可以在请求头或者响应头中设置，并且可以组合使用多种指令： public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如&nbsp;Browser&nbsp;&lt;--&nbsp;proxy1&nbsp;&lt;--&nbsp;proxy2&nbsp;&lt;--&nbsp;Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给&nbsp;Browser&nbsp;而不再向proxy2要。 private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser&nbsp;&lt;--&nbsp;proxy1&nbsp;&lt;--&nbsp;proxy2&nbsp;&lt;--&nbsp;Server，proxy&nbsp;会老老实实把Server&nbsp;返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。 no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用&nbsp;Cache-Control的缓存控制方式做前置验证，而是使用&nbsp;Etag&nbsp;或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age：max-age=xxx&nbsp;(xxx&nbsp;is&nbsp;numeric)表示缓存内容将在xxx秒后失效 s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires&nbsp;header。 max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。 min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。 3.Expires和Cache-Control两者对比 其实这两者差别不大，区别就在于&nbsp;Expires&nbsp;是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not&nbsp;Modified： 协商缓存失效，返回200和请求结果： 协商缓存可以通过设置两种&nbsp;HTTP&nbsp;Header&nbsp;实现：Last-Modified&nbsp;和&nbsp;ETag&nbsp;。&nbsp; 1.Last-Modified和If-Modified-Since 浏览器在第一次访问资源时，服务器返回资源的同时，在response&nbsp;header中添加&nbsp;Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header； Last-Modified:&nbsp;Fri,&nbsp;22&nbsp;Jul&nbsp;2016&nbsp;01:47:00&nbsp;GMT 浏览器下一次请求这个资源，浏览器检测到有&nbsp;Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据&nbsp;If-Modified-Since&nbsp;中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。 但是&nbsp;Last-Modified&nbsp;存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在&nbsp;HTTP&nbsp;/&nbsp;1.1&nbsp;出现了&nbsp;ETag&nbsp;和&nbsp;If-None-Match 2.ETag和If-None-Match Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request&nbsp;header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET&nbsp;200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 3.两者之间对比： 首先在精确度上，Etag要优于Last-Modified。 Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag 缓存机制 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified&nbsp;/&nbsp;If-Modified-Since和Etag&nbsp;/&nbsp;If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下： 看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的&nbsp;Date&nbsp;减去&nbsp;Last-Modified&nbsp;值的&nbsp;10%&nbsp;作为缓存时间。 实际场景应用缓存策略 1.频繁变动的资源 Cache-Control:&nbsp;no-cache 对于频繁变动的资源，首先需要使用&nbsp;Cache-Control:no-cache&nbsp;使浏览器每次都请求服务器，然后配合&nbsp;ETag&nbsp;或者&nbsp;Last-Modified&nbsp;来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 2.不常变化的资源 Cache-Control:&nbsp;max-age=31536000 通常在处理这类资源时，给它们的&nbsp;Cache-Control&nbsp;配置一个很大的&nbsp;max-age=31536000&nbsp;(一年)，这样浏览器之后请求相同的&nbsp;URL&nbsp;会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加&nbsp;hash，&nbsp;版本号等动态字符，之后更改动态字符，从而达到更改引用&nbsp;URL&nbsp;的目的，让之前的强制缓存失效&nbsp;(其实并未立即失效，只是不再使用了而已)。在线提供的类库&nbsp;(如&nbsp;jquery-3.3.1.min.js,&nbsp;lodash.min.js&nbsp;等)&nbsp;均采用这个模式。 用户行为对浏览器缓存的影响 所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有&nbsp;3&nbsp;种： 打开网页，地址栏输入地址：&nbsp;查找&nbsp;disk&nbsp;cache&nbsp;中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新&nbsp;(F5)：因为&nbsp;TAB&nbsp;并没有关闭，因此&nbsp;memory&nbsp;cache&nbsp;是可用的，会被优先使用(如果匹配的话)。其次才是&nbsp;disk&nbsp;cache。 强制刷新&nbsp;(Ctrl&nbsp;+&nbsp;F5)：浏览器不使用缓存，因此发送的请求头部均带有&nbsp;Cache-control:no-cache(为了兼容，还带了&nbsp;Pragma:no-cache),服务器直接返回&nbsp;200&nbsp;和最新内容。 参考文章： 浅谈web缓存 web缓存机制 彻底理解浏览器的缓存机制 前端面试之道 一文读懂前端缓存 A Tale of Four Caches HTTP/2 push is tougher than I thought 设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2 【End】 &nbsp;热 文&nbsp;推 荐&nbsp; 戳他↓↓↓ ☞刘强东深夜写信诉苦；华为不排斥卖给苹果&nbsp;5G&nbsp;芯片；Facebook&nbsp;再宕机&nbsp;|&nbsp;极客头条 ☞马云再谈&nbsp;996：真正的&nbsp;996&nbsp;与被剥削无关 ☞摩拜被收购的这一年 ☞Python的10个“秘籍”，这些技术专家全都告诉你了 ☞漫画：图的&nbsp;“最短路径”&nbsp;问题&nbsp;|&nbsp;技术头条 ☞从&nbsp;0&nbsp;到管理&nbsp;200&nbsp;人，这位程序员是如何做到的？&nbsp;|&nbsp;程序员有话说 ☞4000万假币流入波场, 发生在凌晨的BTT假币攻击事件始末及细节披露 System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 你点的每个“在看”，我都认真当成了喜欢" />
<meta property="og:description" content="作者 | 浪里行舟 责编 | 胡巍巍 前言 缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。 接下来的内容中我们将通过缓存位置、缓存策略以及实际场景应用缓存策略来探讨浏览器缓存机制。 缓存位置 从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache 1.Service Worker Service&nbsp;Worker&nbsp;是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用&nbsp;Service&nbsp;Worker的话，传输协议必须为&nbsp;HTTPS。因为&nbsp;Service&nbsp;Worker&nbsp;中涉及到请求拦截，所以必须使用&nbsp;HTTPS&nbsp;协议来保障安全。Service&nbsp;Worker&nbsp;的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service&nbsp;Worker&nbsp;实现缓存功能一般分为三个步骤：首先需要先注册&nbsp;Service&nbsp;Worker，然后监听到&nbsp;install&nbsp;事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当&nbsp;Service&nbsp;Worker&nbsp;没有命中缓存的时候，我们需要去调用&nbsp;fetch&nbsp;函数获取数据。也就是说，如果我们没有在&nbsp;Service&nbsp;Worker&nbsp;命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从&nbsp;Memory&nbsp;Cache&nbsp;中还是从网络请求中获取的数据，浏览器都会显示我们是从&nbsp;Service&nbsp;Worker&nbsp;中获取的内容。 2.Memory Cache Memory&nbsp;Cache&nbsp;也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。&nbsp;一旦我们关闭&nbsp;Tab&nbsp;页面，内存中的缓存也就被释放了。 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。 内存缓存中有一块重要的缓存资源是preloader相关指令（例如&nbsp;&lt;linkrel=&quot;prefetch&quot;&gt;）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 3.Disk Cache Disk&nbsp;Cache&nbsp;也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之&nbsp;Memory&nbsp;Cache&nbsp;胜在容量和存储时效性上。 在所有浏览器缓存中，Disk&nbsp;Cache&nbsp;覆盖面基本是最大的。它会根据&nbsp;HTTP&nbsp;Herder&nbsp;中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自&nbsp;Disk&nbsp;Cache，关于&nbsp;HTTP&nbsp;的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 4.Push Cache Push&nbsp;Cache（推送缓存）是&nbsp;HTTP/2&nbsp;中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 Push&nbsp;Cache&nbsp;在国内能够查到的资料很少，也是因为&nbsp;HTTP/2&nbsp;在国内不够普及。这里推荐阅读&nbsp;JakeArchibald的&nbsp;HTTP/2&nbsp;push&nbsp;is&nbsp;tougher&nbsp;than&nbsp;I&nbsp;thought&nbsp;这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push&nbsp;Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置&nbsp;HTTP&nbsp;Header&nbsp;来实现的。 缓存过程分析 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求&nbsp;–&nbsp;服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图： 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。 强缓存 强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from&nbsp;disk&nbsp;cache或from&nbsp;memory&nbsp;cache。强缓存可以通过设置两种&nbsp;HTTP&nbsp;Header&nbsp;实现：Expires&nbsp;和&nbsp;Cache-Control。 1.Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age&nbsp;+&nbsp;请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires&nbsp;是&nbsp;HTTP/1&nbsp;的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。&nbsp; Expires:Wed,22Oct201808:41:00GMT表示资源会在&nbsp;Wed,&nbsp;22&nbsp;Oct&nbsp;2018&nbsp;08:41:00&nbsp;GMT&nbsp;后过期，需要再次请求。 2.Cache-Control 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当&nbsp;Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 Cache-Control&nbsp;可以在请求头或者响应头中设置，并且可以组合使用多种指令： public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如&nbsp;Browser&nbsp;&lt;--&nbsp;proxy1&nbsp;&lt;--&nbsp;proxy2&nbsp;&lt;--&nbsp;Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给&nbsp;Browser&nbsp;而不再向proxy2要。 private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser&nbsp;&lt;--&nbsp;proxy1&nbsp;&lt;--&nbsp;proxy2&nbsp;&lt;--&nbsp;Server，proxy&nbsp;会老老实实把Server&nbsp;返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。 no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用&nbsp;Cache-Control的缓存控制方式做前置验证，而是使用&nbsp;Etag&nbsp;或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age：max-age=xxx&nbsp;(xxx&nbsp;is&nbsp;numeric)表示缓存内容将在xxx秒后失效 s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires&nbsp;header。 max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。 min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。 3.Expires和Cache-Control两者对比 其实这两者差别不大，区别就在于&nbsp;Expires&nbsp;是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not&nbsp;Modified： 协商缓存失效，返回200和请求结果： 协商缓存可以通过设置两种&nbsp;HTTP&nbsp;Header&nbsp;实现：Last-Modified&nbsp;和&nbsp;ETag&nbsp;。&nbsp; 1.Last-Modified和If-Modified-Since 浏览器在第一次访问资源时，服务器返回资源的同时，在response&nbsp;header中添加&nbsp;Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header； Last-Modified:&nbsp;Fri,&nbsp;22&nbsp;Jul&nbsp;2016&nbsp;01:47:00&nbsp;GMT 浏览器下一次请求这个资源，浏览器检测到有&nbsp;Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据&nbsp;If-Modified-Since&nbsp;中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。 但是&nbsp;Last-Modified&nbsp;存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在&nbsp;HTTP&nbsp;/&nbsp;1.1&nbsp;出现了&nbsp;ETag&nbsp;和&nbsp;If-None-Match 2.ETag和If-None-Match Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request&nbsp;header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET&nbsp;200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 3.两者之间对比： 首先在精确度上，Etag要优于Last-Modified。 Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag 缓存机制 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified&nbsp;/&nbsp;If-Modified-Since和Etag&nbsp;/&nbsp;If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下： 看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的&nbsp;Date&nbsp;减去&nbsp;Last-Modified&nbsp;值的&nbsp;10%&nbsp;作为缓存时间。 实际场景应用缓存策略 1.频繁变动的资源 Cache-Control:&nbsp;no-cache 对于频繁变动的资源，首先需要使用&nbsp;Cache-Control:no-cache&nbsp;使浏览器每次都请求服务器，然后配合&nbsp;ETag&nbsp;或者&nbsp;Last-Modified&nbsp;来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 2.不常变化的资源 Cache-Control:&nbsp;max-age=31536000 通常在处理这类资源时，给它们的&nbsp;Cache-Control&nbsp;配置一个很大的&nbsp;max-age=31536000&nbsp;(一年)，这样浏览器之后请求相同的&nbsp;URL&nbsp;会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加&nbsp;hash，&nbsp;版本号等动态字符，之后更改动态字符，从而达到更改引用&nbsp;URL&nbsp;的目的，让之前的强制缓存失效&nbsp;(其实并未立即失效，只是不再使用了而已)。在线提供的类库&nbsp;(如&nbsp;jquery-3.3.1.min.js,&nbsp;lodash.min.js&nbsp;等)&nbsp;均采用这个模式。 用户行为对浏览器缓存的影响 所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有&nbsp;3&nbsp;种： 打开网页，地址栏输入地址：&nbsp;查找&nbsp;disk&nbsp;cache&nbsp;中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新&nbsp;(F5)：因为&nbsp;TAB&nbsp;并没有关闭，因此&nbsp;memory&nbsp;cache&nbsp;是可用的，会被优先使用(如果匹配的话)。其次才是&nbsp;disk&nbsp;cache。 强制刷新&nbsp;(Ctrl&nbsp;+&nbsp;F5)：浏览器不使用缓存，因此发送的请求头部均带有&nbsp;Cache-control:no-cache(为了兼容，还带了&nbsp;Pragma:no-cache),服务器直接返回&nbsp;200&nbsp;和最新内容。 参考文章： 浅谈web缓存 web缓存机制 彻底理解浏览器的缓存机制 前端面试之道 一文读懂前端缓存 A Tale of Four Caches HTTP/2 push is tougher than I thought 设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2 【End】 &nbsp;热 文&nbsp;推 荐&nbsp; 戳他↓↓↓ ☞刘强东深夜写信诉苦；华为不排斥卖给苹果&nbsp;5G&nbsp;芯片；Facebook&nbsp;再宕机&nbsp;|&nbsp;极客头条 ☞马云再谈&nbsp;996：真正的&nbsp;996&nbsp;与被剥削无关 ☞摩拜被收购的这一年 ☞Python的10个“秘籍”，这些技术专家全都告诉你了 ☞漫画：图的&nbsp;“最短路径”&nbsp;问题&nbsp;|&nbsp;技术头条 ☞从&nbsp;0&nbsp;到管理&nbsp;200&nbsp;人，这位程序员是如何做到的？&nbsp;|&nbsp;程序员有话说 ☞4000万假币流入波场, 发生在凌晨的BTT假币攻击事件始末及细节披露 System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 你点的每个“在看”，我都认真当成了喜欢" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"作者 | 浪里行舟 责编 | 胡巍巍 前言 缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。 接下来的内容中我们将通过缓存位置、缓存策略以及实际场景应用缓存策略来探讨浏览器缓存机制。 缓存位置 从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache 1.Service Worker Service&nbsp;Worker&nbsp;是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用&nbsp;Service&nbsp;Worker的话，传输协议必须为&nbsp;HTTPS。因为&nbsp;Service&nbsp;Worker&nbsp;中涉及到请求拦截，所以必须使用&nbsp;HTTPS&nbsp;协议来保障安全。Service&nbsp;Worker&nbsp;的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service&nbsp;Worker&nbsp;实现缓存功能一般分为三个步骤：首先需要先注册&nbsp;Service&nbsp;Worker，然后监听到&nbsp;install&nbsp;事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当&nbsp;Service&nbsp;Worker&nbsp;没有命中缓存的时候，我们需要去调用&nbsp;fetch&nbsp;函数获取数据。也就是说，如果我们没有在&nbsp;Service&nbsp;Worker&nbsp;命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从&nbsp;Memory&nbsp;Cache&nbsp;中还是从网络请求中获取的数据，浏览器都会显示我们是从&nbsp;Service&nbsp;Worker&nbsp;中获取的内容。 2.Memory Cache Memory&nbsp;Cache&nbsp;也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。&nbsp;一旦我们关闭&nbsp;Tab&nbsp;页面，内存中的缓存也就被释放了。 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。 内存缓存中有一块重要的缓存资源是preloader相关指令（例如&nbsp;&lt;linkrel=&quot;prefetch&quot;&gt;）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 3.Disk Cache Disk&nbsp;Cache&nbsp;也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之&nbsp;Memory&nbsp;Cache&nbsp;胜在容量和存储时效性上。 在所有浏览器缓存中，Disk&nbsp;Cache&nbsp;覆盖面基本是最大的。它会根据&nbsp;HTTP&nbsp;Herder&nbsp;中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自&nbsp;Disk&nbsp;Cache，关于&nbsp;HTTP&nbsp;的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 4.Push Cache Push&nbsp;Cache（推送缓存）是&nbsp;HTTP/2&nbsp;中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 Push&nbsp;Cache&nbsp;在国内能够查到的资料很少，也是因为&nbsp;HTTP/2&nbsp;在国内不够普及。这里推荐阅读&nbsp;JakeArchibald的&nbsp;HTTP/2&nbsp;push&nbsp;is&nbsp;tougher&nbsp;than&nbsp;I&nbsp;thought&nbsp;这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push&nbsp;Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置&nbsp;HTTP&nbsp;Header&nbsp;来实现的。 缓存过程分析 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求&nbsp;–&nbsp;服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图： 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。 强缓存 强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from&nbsp;disk&nbsp;cache或from&nbsp;memory&nbsp;cache。强缓存可以通过设置两种&nbsp;HTTP&nbsp;Header&nbsp;实现：Expires&nbsp;和&nbsp;Cache-Control。 1.Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age&nbsp;+&nbsp;请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires&nbsp;是&nbsp;HTTP/1&nbsp;的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。&nbsp; Expires:Wed,22Oct201808:41:00GMT表示资源会在&nbsp;Wed,&nbsp;22&nbsp;Oct&nbsp;2018&nbsp;08:41:00&nbsp;GMT&nbsp;后过期，需要再次请求。 2.Cache-Control 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当&nbsp;Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 Cache-Control&nbsp;可以在请求头或者响应头中设置，并且可以组合使用多种指令： public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如&nbsp;Browser&nbsp;&lt;--&nbsp;proxy1&nbsp;&lt;--&nbsp;proxy2&nbsp;&lt;--&nbsp;Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给&nbsp;Browser&nbsp;而不再向proxy2要。 private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser&nbsp;&lt;--&nbsp;proxy1&nbsp;&lt;--&nbsp;proxy2&nbsp;&lt;--&nbsp;Server，proxy&nbsp;会老老实实把Server&nbsp;返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。 no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用&nbsp;Cache-Control的缓存控制方式做前置验证，而是使用&nbsp;Etag&nbsp;或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age：max-age=xxx&nbsp;(xxx&nbsp;is&nbsp;numeric)表示缓存内容将在xxx秒后失效 s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires&nbsp;header。 max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。 min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。 3.Expires和Cache-Control两者对比 其实这两者差别不大，区别就在于&nbsp;Expires&nbsp;是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not&nbsp;Modified： 协商缓存失效，返回200和请求结果： 协商缓存可以通过设置两种&nbsp;HTTP&nbsp;Header&nbsp;实现：Last-Modified&nbsp;和&nbsp;ETag&nbsp;。&nbsp; 1.Last-Modified和If-Modified-Since 浏览器在第一次访问资源时，服务器返回资源的同时，在response&nbsp;header中添加&nbsp;Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header； Last-Modified:&nbsp;Fri,&nbsp;22&nbsp;Jul&nbsp;2016&nbsp;01:47:00&nbsp;GMT 浏览器下一次请求这个资源，浏览器检测到有&nbsp;Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据&nbsp;If-Modified-Since&nbsp;中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。 但是&nbsp;Last-Modified&nbsp;存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在&nbsp;HTTP&nbsp;/&nbsp;1.1&nbsp;出现了&nbsp;ETag&nbsp;和&nbsp;If-None-Match 2.ETag和If-None-Match Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request&nbsp;header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET&nbsp;200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 3.两者之间对比： 首先在精确度上，Etag要优于Last-Modified。 Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag 缓存机制 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified&nbsp;/&nbsp;If-Modified-Since和Etag&nbsp;/&nbsp;If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下： 看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的&nbsp;Date&nbsp;减去&nbsp;Last-Modified&nbsp;值的&nbsp;10%&nbsp;作为缓存时间。 实际场景应用缓存策略 1.频繁变动的资源 Cache-Control:&nbsp;no-cache 对于频繁变动的资源，首先需要使用&nbsp;Cache-Control:no-cache&nbsp;使浏览器每次都请求服务器，然后配合&nbsp;ETag&nbsp;或者&nbsp;Last-Modified&nbsp;来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 2.不常变化的资源 Cache-Control:&nbsp;max-age=31536000 通常在处理这类资源时，给它们的&nbsp;Cache-Control&nbsp;配置一个很大的&nbsp;max-age=31536000&nbsp;(一年)，这样浏览器之后请求相同的&nbsp;URL&nbsp;会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加&nbsp;hash，&nbsp;版本号等动态字符，之后更改动态字符，从而达到更改引用&nbsp;URL&nbsp;的目的，让之前的强制缓存失效&nbsp;(其实并未立即失效，只是不再使用了而已)。在线提供的类库&nbsp;(如&nbsp;jquery-3.3.1.min.js,&nbsp;lodash.min.js&nbsp;等)&nbsp;均采用这个模式。 用户行为对浏览器缓存的影响 所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有&nbsp;3&nbsp;种： 打开网页，地址栏输入地址：&nbsp;查找&nbsp;disk&nbsp;cache&nbsp;中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新&nbsp;(F5)：因为&nbsp;TAB&nbsp;并没有关闭，因此&nbsp;memory&nbsp;cache&nbsp;是可用的，会被优先使用(如果匹配的话)。其次才是&nbsp;disk&nbsp;cache。 强制刷新&nbsp;(Ctrl&nbsp;+&nbsp;F5)：浏览器不使用缓存，因此发送的请求头部均带有&nbsp;Cache-control:no-cache(为了兼容，还带了&nbsp;Pragma:no-cache),服务器直接返回&nbsp;200&nbsp;和最新内容。 参考文章： 浅谈web缓存 web缓存机制 彻底理解浏览器的缓存机制 前端面试之道 一文读懂前端缓存 A Tale of Four Caches HTTP/2 push is tougher than I thought 设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2 【End】 &nbsp;热 文&nbsp;推 荐&nbsp; 戳他↓↓↓ ☞刘强东深夜写信诉苦；华为不排斥卖给苹果&nbsp;5G&nbsp;芯片；Facebook&nbsp;再宕机&nbsp;|&nbsp;极客头条 ☞马云再谈&nbsp;996：真正的&nbsp;996&nbsp;与被剥削无关 ☞摩拜被收购的这一年 ☞Python的10个“秘籍”，这些技术专家全都告诉你了 ☞漫画：图的&nbsp;“最短路径”&nbsp;问题&nbsp;|&nbsp;技术头条 ☞从&nbsp;0&nbsp;到管理&nbsp;200&nbsp;人，这位程序员是如何做到的？&nbsp;|&nbsp;程序员有话说 ☞4000万假币流入波场, 发生在凌晨的BTT假币攻击事件始末及细节披露 System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 你点的每个“在看”，我都认真当成了喜欢","@type":"BlogPosting","url":"/2019/04/28/728506.html","headline":"彻底吃透浏览器的缓存机制！","dateModified":"2019-04-28T00:00:00+08:00","datePublished":"2019-04-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/28/728506.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>彻底吃透浏览器的缓存机制！</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><img class="" data-copyright="0" data-ratio="0.15644171779141106" data-src="https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAug5zOzy32A3RIVhRwowK5ogg1hJ631uGyu9zOMKfTddDnSrsxicbCQNm59Qeo3lDYCvF70I9ibGvA9g/640?wx_fmt=gif" data-type="gif" data-w="652" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAug5zOzy32A3RIVhRwowK5ogg1hJ631uGyu9zOMKfTddDnSrsxicbCQNm59Qeo3lDYCvF70I9ibGvA9g/640?wx_fmt=gif"></p> 
<p style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><img class="" data-copyright="0" data-ratio="0.64875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuheuu1BQs7OkP5xEa3iboN7NJCianzG8vnxqPDRnW7qlvicSMI07GJUzDicrnAUwRmtoyibV1fABJoYy7Q/640?wx_fmt=jpeg" data-type="jpeg" data-w="800" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuheuu1BQs7OkP5xEa3iboN7NJCianzG8vnxqPDRnW7qlvicSMI07GJUzDicrnAUwRmtoyibV1fABJoYy7Q/640?wx_fmt=jpeg"></p> 
<p style="letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">作者 | 浪里行舟</span></p> 
<p style="letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">责编 | 胡巍巍</span><br></p> 
<p style="margin-bottom: 15px;line-height: normal;margin-left: 8px;margin-right: 8px;letter-spacing: 1px;"><br></p> 
<p style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LXSAriayI15u06ibNNlXzIcor2tTtgJBKFxkIicJ8tiaRKRaictbrQEssdSg/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LXSAriayI15u06ibNNlXzIcor2tTtgJBKFxkIicJ8tiaRKRaictbrQEssdSg/640?wx_fmt=png"></strong></span></p> 
<h2></h2> 
<h2 style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong>前言</strong></span><span style="font-size: 15px;"></span></h2> 
<p style="letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">接下来的内容中我们将通过缓存位置、缓存策略以及实际场景应用缓存策略来探讨浏览器缓存机制。</span></p> 
<p style="text-align: center;margin-bottom: 15px;line-height: 1.75em;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.4283777677361048" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vdtd7YfRS2Fqr7nC5L5ibhlnZTHAaKAbGDD8nHSyUiaZI3UtJZ3OEg8Cg/640?wx_fmt=png" data-type="png" data-w="2213" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vdtd7YfRS2Fqr7nC5L5ibhlnZTHAaKAbGDD8nHSyUiaZI3UtJZ3OEg8Cg/640?wx_fmt=png"></p> 
<p><br></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"></span></p> 
<p style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LwYnW1VvkaHWiaL6W1Mr1yiaNLQpxwhyqice9F1yJzMHticssPX515qyvog/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LwYnW1VvkaHWiaL6W1Mr1yiaNLQpxwhyqice9F1yJzMHticssPX515qyvog/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong>缓存位置</strong></span><span style="font-size: 15px;"></span></h2> 
<p style="letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。</span></p> 
<ul style="list-style-type: square;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">Service Worker</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">Memory Cache</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">Disk Cache</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">Push Cache</span></p></li> 
</ul> 
<h3 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">1.Service Worker</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Service&nbsp;Worker&nbsp;是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用&nbsp;Service&nbsp;Worker的话，传输协议必须为&nbsp;HTTPS。因为&nbsp;Service&nbsp;Worker&nbsp;中涉及到请求拦截，所以必须使用&nbsp;HTTPS&nbsp;协议来保障安全。Service&nbsp;Worker&nbsp;的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Service&nbsp;Worker&nbsp;实现缓存功能一般分为三个步骤：首先需要先注册&nbsp;Service&nbsp;Worker，然后监听到&nbsp;install&nbsp;事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">当&nbsp;Service&nbsp;Worker&nbsp;没有命中缓存的时候，我们需要去调用&nbsp;fetch&nbsp;函数获取数据。也就是说，如果我们没有在&nbsp;Service&nbsp;Worker&nbsp;命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从&nbsp;Memory&nbsp;Cache&nbsp;中还是从网络请求中获取的数据，浏览器都会显示我们是从&nbsp;Service&nbsp;Worker&nbsp;中获取的内容。</span></p> 
<h3 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">2.Memory Cache</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Memory&nbsp;Cache&nbsp;也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。&nbsp;一旦我们关闭&nbsp;Tab&nbsp;页面，内存中的缓存也就被释放了。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。</span></p> 
<p style="text-align: center;margin-bottom: 15px;line-height: 1.75em;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.18295454545454545" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05v1CHh01HicAOfeUQBRWYcwHxibN4BxgmjdR0AZOibNTq8h7oMhJmmVrjqw/640?wx_fmt=png" data-type="png" data-w="880" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05v1CHh01HicAOfeUQBRWYcwHxibN4BxgmjdR0AZOibNTq8h7oMhJmmVrjqw/640?wx_fmt=png"></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">内存缓存中有一块重要的缓存资源是preloader相关指令（例如&nbsp;&lt;linkrel="prefetch"&gt;）下载的资源。</span><span style="font-size: 15px;">总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。</span><br><span style="font-size: 15px;"></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。</span></p> 
<h3 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">3.Disk Cache</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Disk&nbsp;Cache&nbsp;也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之&nbsp;Memory&nbsp;Cache&nbsp;胜在容量和存储时效性上。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">在所有浏览器缓存中，Disk&nbsp;Cache&nbsp;覆盖面基本是最大的。它会根据&nbsp;HTTP&nbsp;Herder&nbsp;中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自&nbsp;Disk&nbsp;Cache，关于&nbsp;HTTP&nbsp;的协议头中的缓存字段，我们会在下文进行详细介绍。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？关于这点，网上说法不一，不过以下观点比较靠得住：</span></p> 
<ul style="list-style-type: square;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">对于大文件来说，大概率是不存储在内存中的，反之优先</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">当前系统内存使用率高的话，文件优先存储进硬盘</span></p></li> 
</ul> 
<h3 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">4.Push Cache</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Push&nbsp;Cache（推送缓存）是&nbsp;HTTP/2&nbsp;中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Push&nbsp;Cache&nbsp;在国内能够查到的资料很少，也是因为&nbsp;HTTP/2&nbsp;在国内不够普及。这里推荐阅读&nbsp;JakeArchibald的&nbsp;HTTP/2&nbsp;push&nbsp;is&nbsp;tougher&nbsp;than&nbsp;I&nbsp;thought&nbsp;这篇文章，文章中的几个结论：</span></p> 
<ul style="list-style-type: square;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">可以推送 no-cache 和 no-store 的资源</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">一旦连接被关闭，Push Cache 就被释放</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push&nbsp;Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">Push Cache 中的缓存只能被使用一次</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">浏览器可以拒绝接受已经存在的资源推送</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">你可以给其他域名推送资源</span></p></li> 
</ul> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置&nbsp;HTTP&nbsp;Header&nbsp;来实现的。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lb4ybNEVGnaAvEDwENKzW27LUKFDGZPKcBneWwTaTpaJyG2C3em7libQ/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lb4ybNEVGnaAvEDwENKzW27LUKFDGZPKcBneWwTaTpaJyG2C3em7libQ/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong>缓存过程分析</strong><strong><span style="font-size: 15px;"></span></strong></span></h2> 
<p style="letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求&nbsp;–&nbsp;服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图：</span></p> 
<p style="text-align: center;margin-bottom: 15px;line-height: 1.75em;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.764179104477612" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vicp2ia1Dibe1B58wIbPAWpw4LC73HJ2rHibF6x9nHHQCSdsMgSqCkicg2Ew/640?wx_fmt=png" data-type="png" data-w="670" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vicp2ia1Dibe1B58wIbPAWpw4LC73HJ2rHibF6x9nHHQCSdsMgSqCkicg2Ew/640?wx_fmt=png"></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">由上图我们可以知道：</span></p> 
<ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
 <li><p style="text-align: justify;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="font-size: 15px;">浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</span></p></li> 
 <li><p style="letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</span><br></p></li> 
</ul> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><br></p> 
<p style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LLqyf6BY4rMfY2LsU81MibFjicKDLjMjib5R23h8uo6GtGDY8OufWJfpEw/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LLqyf6BY4rMfY2LsU81MibFjicKDLjMjib5R23h8uo6GtGDY8OufWJfpEw/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong>强缓存</strong></span><span style="font-size: 15px;"></span></h2> 
<p style="letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from&nbsp;disk&nbsp;cache或from&nbsp;memory&nbsp;cache。强缓存可以通过设置两种&nbsp;HTTP&nbsp;Header&nbsp;实现：Expires&nbsp;和&nbsp;Cache-Control。</span></p> 
<h3 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">1.Expires</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age&nbsp;+&nbsp;请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Expires&nbsp;是&nbsp;HTTP/1&nbsp;的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。&nbsp;</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Expires:Wed,22Oct201808:41:00GMT表示资源会在&nbsp;Wed,&nbsp;22&nbsp;Oct&nbsp;2018&nbsp;08:41:00&nbsp;GMT&nbsp;后过期，需要再次请求。</span></p> 
<h3 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">2.Cache-Control</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当&nbsp;Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Cache-Control&nbsp;可以在请求头或者响应头中设置，并且可以组合使用多种指令：</span></p> 
<p style="text-align: center;margin-bottom: 15px;line-height: 1.75em;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.6103202846975089" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vcibS0icTicbPia780MP1HUNelV9ydkcSMk0RTibOopIpdAbo8sJPDzL2EqQ/640?wx_fmt=png" data-type="png" data-w="562" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vcibS0icTicbPia780MP1HUNelV9ydkcSMk0RTibOopIpdAbo8sJPDzL2EqQ/640?wx_fmt=png"></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">public：</span><span style="font-size: 15px;">所有内容都将被缓存（客户端和代理服务器都可缓存）。</span><span style="font-size: 15px;">具体来说响应可被任何中间节点缓存，如&nbsp;Browser&nbsp;&lt;--&nbsp;proxy1&nbsp;&lt;--&nbsp;proxy2&nbsp;&lt;--&nbsp;Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给&nbsp;Browser&nbsp;而不再向proxy2要。</span><br><span style="font-size: 15px;"></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser&nbsp;&lt;--&nbsp;proxy1&nbsp;&lt;--&nbsp;proxy2&nbsp;&lt;--&nbsp;Server，proxy&nbsp;会老老实实把Server&nbsp;返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用&nbsp;Cache-Control的缓存控制方式做前置验证，而是使用&nbsp;Etag&nbsp;或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">max-age：max-age=xxx&nbsp;(xxx&nbsp;is&nbsp;numeric)表示缓存内容将在xxx秒后失效</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires&nbsp;header。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。</span></p> 
<p style="text-align: center;margin-bottom: 15px;line-height: 1.75em;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.901219512195122" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vHhW1kEJQ49wqpx8LTzrJh3hwXuQ6Z9fgQXOMklmicA2DtNG1bksuStg/640?wx_fmt=png" data-type="png" data-w="820" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vHhW1kEJQ49wqpx8LTzrJh3hwXuQ6Z9fgQXOMklmicA2DtNG1bksuStg/640?wx_fmt=png"></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。</span><span style="font-size: 15px;">比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。</span><br><span style="font-size: 15px;"></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"></span></p> 
<h3 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">3.Expires和Cache-Control两者对比</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">其实这两者差别不大，区别就在于&nbsp;Expires&nbsp;是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LzUzfol6q1COlZYpeYXqe0aia45DXyhcTQW8voWvibFJvEjfmkhPvCrEg/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LzUzfol6q1COlZYpeYXqe0aia45DXyhcTQW8voWvibFJvEjfmkhPvCrEg/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong>协商缓存</strong></span><span style="font-size: 15px;"></span></h2> 
<p style="letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</span></p> 
<p style="letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;letter-spacing: 1px;">协商缓存生效，返回304和Not&nbsp;Modified：</span><span style="font-size: 15px;letter-spacing: 1px;"></span></strong></p> 
<p style="text-align: center;margin-bottom: 15px;line-height: 1.75em;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.7602256699576869" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vwhTKricFIZ7DDm791A8Xle82nfhcvNZoXQpLlAhLDwYdnRvXzUicBO8w/640?wx_fmt=png" data-type="png" data-w="709" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vwhTKricFIZ7DDm791A8Xle82nfhcvNZoXQpLlAhLDwYdnRvXzUicBO8w/640?wx_fmt=png"></p> 
<p style="letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">协商缓存失效，返回200和请求结果：</span><span style="font-size: 15px;"></span></strong><br><span style="font-size: 15px;letter-spacing: 1px;"></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><img class="rich_pages" data-copyright="0" data-ratio="0.764179104477612" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vicp2ia1Dibe1B58wIbPAWpw4LC73HJ2rHibF6x9nHHQCSdsMgSqCkicg2Ew/640?wx_fmt=png" data-type="png" data-w="670" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vicp2ia1Dibe1B58wIbPAWpw4LC73HJ2rHibF6x9nHHQCSdsMgSqCkicg2Ew/640?wx_fmt=png"><span style="font-size: 15px;letter-spacing: 1px;text-align: justify;">协商缓存可以通过设置两种&nbsp;HTTP&nbsp;Header&nbsp;实现：</span><span style="font-size: 15px;letter-spacing: 1px;text-align: justify;">Last-Modified&nbsp;和&nbsp;ETag&nbsp;。</span><span style="font-size: 15px;letter-spacing: 1px;text-align: justify;">&nbsp;</span></p> 
<h3 style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">1.Last-Modified和If-Modified-Since</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">浏览器在第一次访问资源时，服务器返回资源的同时，在response&nbsp;header中添加&nbsp;Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="font-size: 14px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-selector-tag" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Last-Modified</span>:&nbsp;<span class="hljs-selector-tag" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Fri</span>,&nbsp;22&nbsp;<span class="hljs-selector-tag" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Jul</span>&nbsp;2016&nbsp;01<span class="hljs-selector-pseudo" style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">:47:00</span>&nbsp;<span class="hljs-selector-tag" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">GMT</span><br></p></pre> 
</section> 
<p style="margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">浏览器下一次请求这个资源，浏览器检测到有&nbsp;Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据&nbsp;If-Modified-Since&nbsp;中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><img class="rich_pages" data-copyright="0" data-ratio="0.867579908675799" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vyxTtaiaoV6FazSGYzA0Dz1wVggiagQAeNIryuicIz90LLLxTyJQSM8fLQ/640?wx_fmt=png" data-type="png" data-w="438" style="letter-spacing: 0.5px;text-align: center;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vyxTtaiaoV6FazSGYzA0Dz1wVggiagQAeNIryuicIz90LLLxTyJQSM8fLQ/640?wx_fmt=png"></p> 
<h4 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">但是&nbsp;Last-Modified&nbsp;存在一些弊端：</span><br></h4> 
<ul style="list-style-type: square;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</span></p></li> 
</ul> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在&nbsp;HTTP&nbsp;/&nbsp;1.1&nbsp;出现了&nbsp;ETag&nbsp;和&nbsp;If-None-Match</span></p> 
<h3 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">2.ETag和If-None-Match</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request&nbsp;header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET&nbsp;200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><img class="rich_pages" data-copyright="0" data-ratio="0.46886446886446886" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vprEFYicxgv0GWsJbPZoSv1bNg3PL1llN2jeLoaqZQcCsu9W3vKHoLzQ/640?wx_fmt=png" data-type="png" data-w="546" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vprEFYicxgv0GWsJbPZoSv1bNg3PL1llN2jeLoaqZQcCsu9W3vKHoLzQ/640?wx_fmt=png"></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong style="font-size: 16px;"><span style="font-size: 15px;">3.两者之间对比：</span></strong><br><span style="font-size: 15px;"></span></p> 
<h3 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"></span></h3> 
<ul style="list-style-type: square;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">首先在精确度上，Etag要优于Last-Modified。</span></p></li> 
</ul> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</span></p> 
<ul style="list-style-type: square;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">第三在优先级上，服务器校验优先考虑Etag</span></p></li> 
</ul> 
<p style="text-align: justify;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><br></p> 
<p style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L8DRknQu3FB9eZicibvOSlVrgnllB3XcGnsrw4zCk19ic0QjZkTPoqFMWw/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L8DRknQu3FB9eZicibvOSlVrgnllB3XcGnsrw4zCk19ic0QjZkTPoqFMWw/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong>缓存机制</strong></span><span style="font-size: 15px;"></span></h2> 
<p style="margin-bottom: 15px;line-height: 1.75em;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified&nbsp;/&nbsp;If-Modified-Since和Etag&nbsp;/&nbsp;If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下：</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><img class="rich_pages" data-copyright="0" data-ratio="0.8901734104046243" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05v76ibPwJDNeqpLQFXdAkGupDTMyOMTECichxVAXydMA02LGDAblJnydiaQ/640?wx_fmt=png" data-type="png" data-w="519" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05v76ibPwJDNeqpLQFXdAkGupDTMyOMTECichxVAXydMA02LGDAblJnydiaQ/640?wx_fmt=png"></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">看到这里，不知道你是否存在这样一个疑问:</span><span style="font-size: 15px;">如果什么缓存策略都没设置，那么浏览器会怎么处理？</span><br><span style="font-size: 15px;"></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的&nbsp;Date&nbsp;减去&nbsp;Last-Modified&nbsp;值的&nbsp;10%&nbsp;作为缓存时间。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;line-height: 1.75em;margin-bottom: 15px;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LFV97HltQYlNPKDzX97K1Ll0EicLrBIuWQtgLtQYdFKkkLcWKGUeMTfg/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LFV97HltQYlNPKDzX97K1Ll0EicLrBIuWQtgLtQYdFKkkLcWKGUeMTfg/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;line-height: 1.75em;margin-bottom: 15px;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong>实际场景应用缓存策略</strong></span><span style="font-size: 15px;"></span></h2> 
<p style="margin-bottom: 15px;line-height: 1.75em;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<h3 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">1.频繁变动的资源</span></strong><span style="font-size: 15px;"></span></h3> 
<blockquote> 
 <p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Cache-Control:&nbsp;no-cache</span></p> 
</blockquote> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">对于频繁变动的资源，首先需要使用&nbsp;Cache-Control:no-cache&nbsp;使浏览器每次都请求服务器，然后配合&nbsp;ETag&nbsp;或者&nbsp;Last-Modified&nbsp;来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</span></p> 
<h3 style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">2.不常变化的资源</span></strong><span style="font-size: 15px;"></span></h3> 
<blockquote> 
 <p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Cache-Control:&nbsp;max-age=31536000</span></p> 
</blockquote> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">通常在处理这类资源时，给它们的&nbsp;Cache-Control&nbsp;配置一个很大的&nbsp;max-age=31536000&nbsp;(一年)，这样浏览器之后请求相同的&nbsp;URL&nbsp;会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加&nbsp;hash，&nbsp;版本号等动态字符，之后更改动态字符，从而达到更改引用&nbsp;URL&nbsp;的目的，让之前的强制缓存失效&nbsp;(其实并未立即失效，只是不再使用了而已)。在线提供的类库&nbsp;(如&nbsp;jquery-3.3.1.min.js,&nbsp;lodash.min.js&nbsp;等)&nbsp;均采用这个模式。</span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;line-height: 1.75em;margin-bottom: 15px;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lf6AGBpotDb1DGltQgly1vKzgCCOtT3OQn43luu8r1JxUV1PmiaSAViaw/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lf6AGBpotDb1DGltQgly1vKzgCCOtT3OQn43luu8r1JxUV1PmiaSAViaw/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;line-height: 1.75em;margin-bottom: 15px;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 18px;"><strong>用户行为对浏览器缓存的影响</strong></span><span style="font-size: 15px;"></span></h2> 
<p style="margin-bottom: 15px;line-height: 1.75em;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有&nbsp;3&nbsp;种：</span></p> 
<ul style="list-style-type: square;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">打开网页，地址栏输入地址：&nbsp;查找&nbsp;disk&nbsp;cache&nbsp;中是否有匹配。如有则使用；如没有则发送网络请求。</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">普通刷新&nbsp;(F5)：因为&nbsp;TAB&nbsp;并没有关闭，因此&nbsp;memory&nbsp;cache&nbsp;是可用的，会被优先使用(如果匹配的话)。其次才是&nbsp;disk&nbsp;cache。</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;line-height: 1.75em;margin-bottom: 15px;"><span style="font-size: 15px;">强制刷新&nbsp;(Ctrl&nbsp;+&nbsp;F5)：浏览器不使用缓存，因此发送的请求头部均带有&nbsp;Cache-control:no-cache(为了兼容，还带了&nbsp;Pragma:no-cache),服务器直接返回&nbsp;200&nbsp;和最新内容。</span></p></li> 
</ul> 
<p style="text-align: justify;letter-spacing: 1px;margin-bottom: 15px;line-height: normal;margin-left: 8px;margin-right: 8px;"><span style="color: rgb(136, 136, 136);font-size: 12px;">参考文章：<br></span></p> 
<ul style="list-style-type: square;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="text-align: justify;letter-spacing: 1px;margin-bottom: 15px;line-height: normal;"><span style="color: rgb(136, 136, 136);font-size: 12px;">浅谈web缓存</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;margin-bottom: 15px;line-height: normal;"><span style="color: rgb(136, 136, 136);font-size: 12px;">web缓存机制</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;margin-bottom: 15px;line-height: normal;"><span style="color: rgb(136, 136, 136);font-size: 12px;">彻底理解浏览器的缓存机制</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;margin-bottom: 15px;line-height: normal;"><span style="color: rgb(136, 136, 136);font-size: 12px;">前端面试之道</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;margin-bottom: 15px;line-height: normal;"><span style="color: rgb(136, 136, 136);font-size: 12px;">一文读懂前端缓存</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;margin-bottom: 15px;line-height: normal;"><span style="color: rgb(136, 136, 136);font-size: 12px;">A Tale of Four Caches</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;margin-bottom: 15px;line-height: normal;"><span style="color: rgb(136, 136, 136);font-size: 12px;">HTTP/2 push is tougher than I thought</span></p></li> 
 <li><p style="text-align: justify;letter-spacing: 1px;margin-bottom: 15px;line-height: normal;"><span style="color: rgb(136, 136, 136);font-size: 12px;">设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2</span><span style="font-size: 15px;"></span></p></li> 
</ul> 
<p style="margin: 15px 8px;max-width: 100%;min-height: 1em;white-space: normal;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: center;line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;">【End】</span></p> 
<p style="text-align: center;margin-bottom: 15px;line-height: 1.75em;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.5482233502538071" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAujhfYVeoHzgzwUiayZ9JO5NiaTBicuQuQmqhNMCzxviaaDN66o3OHQtNIXHyTAmuexAQUib0Fl37dkBuIw/640?wx_fmt=jpeg" data-type="jpeg" data-w="591" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAujhfYVeoHzgzwUiayZ9JO5NiaTBicuQuQmqhNMCzxviaaDN66o3OHQtNIXHyTAmuexAQUib0Fl37dkBuIw/640?wx_fmt=jpeg"></p> 
<p style="margin-bottom: 15px;max-width: 100%;min-height: 1em;white-space: normal;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: center;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(255, 255, 255);background-color: rgb(60, 142, 216);font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">&nbsp;热 文</strong>&nbsp;推 荐&nbsp;</strong></span><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"></p> 
<p style="margin-bottom: 10px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);text-align: center;letter-spacing: 1px;line-height: normal;margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">戳他↓↓↓</span></strong></p> 
<p style="margin-bottom: 15px;max-width: 100%;min-height: 1em;white-space: normal;text-align: center;letter-spacing: 1px;line-height: normal;margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=Mzg3MDA4NDkxMQ==&amp;mid=2247483853&amp;idx=1&amp;sn=263387c7332067e0b095e55a85f2fb03&amp;chksm=ce92798df9e5f09bf384374838ca7fb17c4b804de649105534d4be52d304b25c72bd60143940&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="1" style="text-decoration: underline;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;line-height: 0;top: auto;left: auto;right: auto;bottom: auto;font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;line-height: 0;top: auto;left: auto;right: auto;bottom: auto;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span class="js_jump_icon h5_image_link" data-positionback="static" style="top: auto;left: auto;margin: 0px;right: auto;bottom: auto;"><img class="rich_pages" data-copyright="0" data-cropselx1="0" data-cropselx2="556" data-cropsely1="0" data-cropsely2="371" data-ratio="0.5555555555555556" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAug6obiaOZB9a8g4b3Y7Cb1ic6AwhibEDwbsZicndVSbmbIWXvv2kAuxLvjo3TI8aT1G1NmyNrOicZtyM9A/640?wx_fmt=png" data-type="png" data-w="900" style="top: auto;left: auto;right: auto;bottom: auto;box-sizing: border-box !important;overflow-wrap: break-word !important;visibility: visible !important;width: 556px !important;margin: 0px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAug6obiaOZB9a8g4b3Y7Cb1ic6AwhibEDwbsZicndVSbmbIWXvv2kAuxLvjo3TI8aT1G1NmyNrOicZtyM9A/640?wx_fmt=png"></span></span></a></p> 
<p style="margin-bottom: 15px;max-width: 100%;min-height: 1em;white-space: normal;letter-spacing: 1px;line-height: normal;margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650718197&amp;idx=1&amp;sn=2b6c9ccff7b9d452bc355d99314aedd5&amp;chksm=bea6ce2689d14730106658ccd5df300ec5c699d3b27aac11ad8b9e853acaf877a46c9a8e67f2&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2"><span style="color: rgb(0, 82, 255);"><span style="color: rgb(0, 82, 255);max-width: 100%;background-color: rgb(255, 255, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">☞</span></span><span style="color: rgb(0, 82, 255);"><span style="color: rgb(0, 82, 255);max-width: 100%;background-color: rgb(255, 255, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;"></span></span><span style="color: rgb(0, 82, 255);"><span style="color: rgb(0, 82, 255);font-size: 14px;">刘强东深夜写信诉苦；华为不排斥卖给苹果&nbsp;5G&nbsp;芯片；Facebook&nbsp;再宕机&nbsp;|&nbsp;极客头条</span></span></a></p> 
<p style="margin-bottom: 15px;max-width: 100%;min-height: 1em;white-space: normal;letter-spacing: 1px;line-height: normal;margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650718176&amp;idx=1&amp;sn=b14ddc4e1fe03b9b848255755731fff7&amp;chksm=bea6ce3389d14725e8e6cbdf60f0d55056dc500241a31756e331b84e3950ed9968596761a6df&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2"><span style="max-width: 100%;background-color: rgb(255, 255, 255);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞马云再谈&nbsp;996：</span><span style="max-width: 100%;background-color: rgb(255, 255, 255);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">真正的&nbsp;996&nbsp;与被剥削无关</span></a></p> 
<p style="margin-bottom: 15px;max-width: 100%;min-height: 1em;white-space: normal;letter-spacing: 1px;line-height: normal;margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650718157&amp;idx=1&amp;sn=58f4cc0b2abcfcbacc610ae64b9a266d&amp;chksm=bea6ce1e89d1470831a717998f9a77934ac649fadbae49f25951c8de42f28ea1cd8db9c2d476&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2"><span style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;background-color: rgb(255, 255, 255);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞摩拜被收购的这一年</span></a><span style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;color: rgb(0, 82, 255);background-color: rgb(255, 255, 255);font-size: 14px;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650718157&amp;idx=1&amp;sn=58f4cc0b2abcfcbacc610ae64b9a266d&amp;chksm=bea6ce1e89d1470831a717998f9a77934ac649fadbae49f25951c8de42f28ea1cd8db9c2d476&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"></a></span></p> 
<p style="margin-bottom: 15px;max-width: 100%;min-height: 1em;white-space: normal;letter-spacing: 1px;line-height: normal;margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzU5MjEwMTE2OQ==&amp;mid=2247485595&amp;idx=1&amp;sn=54ad59ea409b1e12876e11c54796f4c9&amp;chksm=fe25a2c5c9522bd3f69b92e1abcdd8e8469ad62eb530df68b42a7ce0dc1312560f05a8bfc72b&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(0, 82, 255);background-color: rgb(255, 255, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">☞Python的10个“秘籍”，这些技术专家全都告诉你了</span></a></p> 
<p style="margin-bottom: 15px;max-width: 100%;min-height: 1em;white-space: normal;letter-spacing: 1px;line-height: normal;margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzA3MjY1MTQwNQ==&amp;mid=2649827123&amp;idx=1&amp;sn=ff0c0dc98c1112eacbc3901e994a1b02&amp;chksm=871e80d1b06909c70bf28147a576d76247fd248124d8085971925e867f8fe54c5b81a46ec096&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(0, 82, 255);background-color: rgb(255, 255, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">☞漫画：图的&nbsp;“最短路径”&nbsp;问题&nbsp;|&nbsp;技术头条</span></a></p> 
<p style="margin-bottom: 15px;max-width: 100%;min-height: 1em;white-space: normal;letter-spacing: 1px;line-height: normal;margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&amp;mid=2651010206&amp;idx=3&amp;sn=656ab65290d57157c2d3dbd9fc526b28&amp;chksm=8bad8769bcda0e7fdb1eb6c249291e614aaf5bba795ff6f67e669b74c19a65ad0349982356eb&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(0, 82, 255);background-color: rgb(255, 255, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">☞从&nbsp;0&nbsp;到管理&nbsp;200&nbsp;人，这位程序员是如何做到的？&nbsp;|&nbsp;程序员有话说</span></a></p> 
<p style="margin-bottom: 15px;max-width: 100%;min-height: 1em;white-space: normal;letter-spacing: 1px;line-height: normal;margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247494271&amp;idx=1&amp;sn=bb7c975cab505692192aafa00419807c&amp;chksm=fc7fb482cb083d94776b657bad7c778aacd840a49195d4d92871bd6d2aa565690f809161e6f7&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(0, 82, 255);background-color: rgb(255, 255, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">☞4000万假币流入波场, 发生在凌晨的BTT假币攻击事件始末及细节披露</span></a></p> 
<section style="max-width: 100%;letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
 <section class="" style="max-width: 100%;font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
  <pre style="max-width: 100%;font-size: inherit;color: inherit;line-height: inherit;box-sizing: border-box !important;overflow-wrap: break-word !important;"><p style="margin-bottom: 15px;padding: 0.5em;max-width: 100%;min-height: 1em;font-size: 14px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;background: rgb(34, 34, 34);color: rgb(170, 170, 170);line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">System.out.println(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个在看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">console.log(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(50, 170, 238);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">print</span>(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(50, 170, 238);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">printf</span>(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！\n"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">cout&nbsp;&lt;&lt;&nbsp;<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span>&nbsp;&lt;&lt;&nbsp;endl;<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">Console.WriteLine(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">Response.Write(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;overflow-wrap: break-word !important;">alert(</span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: break-word !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;overflow-wrap: break-word !important;">)</span><br style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;font-variant-numeric: normal;line-height: inherit;widows: 1;color: rgb(50, 170, 238);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">echo </span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: break-word !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span></p></pre> 
 </section> 
</section> 
<section class="" data-tools="135编辑器" data-id="94250" style="max-width: 100%;box-sizing: border-box;letter-spacing: 0.544px;white-space: normal;border-width: 0px;border-style: none;border-color: initial;overflow-wrap: break-word !important;"> 
 <section class="" data-tools="135编辑器" data-id="91842" style="max-width: 100%;box-sizing: border-box;border-width: 0px;border-style: none;border-color: initial;overflow-wrap: break-word !important;text-align: right;"> 
  <section style="max-width: 100%;display: inline-block;clear: both;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
   <section class="" data-brushtype="text" style="padding: 18px 15px 20px 10px;max-width: 100%;box-sizing: border-box;color: rgb(86, 146, 214);background-image: url(&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdy66AHd7QqL7A2s5icSBE0aw4iaKOKPnXGYxQPhG7VMpbbYV6VJprSh7w/640?wx_fmt=png&quot;);background-repeat: no-repeat;text-align: center;background-size: 100% 100%;font-size: 16px;letter-spacing: 1.5px;overflow-wrap: break-word !important;"> 
    <section style="max-width: 100%;display: flex;justify-content: center;align-items: center;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
     <section style="margin-left: 2px;max-width: 100%;width: 20px;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
      <img class="" data-ratio="0.8936170212765957" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdvAd0o9e1LlUGA2k0Yib222agOxzweXhahA9GuzJcGBg0dA4DzlibxRqw/640?wx_fmt=png" data-type="png" data-w="47" style="margin-bottom: -6px;box-sizing: border-box !important;overflow-wrap: break-word !important;visibility: visible !important;width: 20px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdvAd0o9e1LlUGA2k0Yib222agOxzweXhahA9GuzJcGBg0dA4DzlibxRqw/640?wx_fmt=png"> 
     </section> 
     <section class="" data-brushtype="text" style="max-width: 100%;font-size: 14px;color: rgb(51, 51, 51);box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: right;"> 
      <span style="max-width: 100%;font-family: 楷体, 楷体_GB2312, SimKai;box-sizing: border-box !important;overflow-wrap: break-word !important;">你点的每个“在看”，我都认真当成了喜欢</span> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
