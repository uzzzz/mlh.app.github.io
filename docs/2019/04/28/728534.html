<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>算法学习之暴力穷举递归法 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="算法学习之暴力穷举递归法" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="暴力法 【例题1】：输入一个整数n，按从小到大的顺序输出所有形如abcde/fghij=n的表达式，其中a~j恰好为数字0~9的一个排列（可以有前导0），2&lt;=n&lt;=79。 代码如下： #include &lt;cstdio&gt; #include &lt;cstring&gt; bool vis[10];//【visit数组】用下标判断数字是否已经被访问过； char str[15];//vis里的数字是按照0-9的顺序，str是按a和b给定的顺序 bool check(int a, int b) { &nbsp; &nbsp; sprintf(str, &quot;%05d%05d&quot;, a, b); //【格式化字符串】int sprintf( char *buffer, const char *format [, argument] ... )。除了前两个参数类型固定外，后面可以接任意多个参数，这取决于第二个参数需要几个后继参数。而它的精华，显然就在第二个参数：【格式化字符串】上。 &nbsp; &nbsp; memset(vis, 0, sizeof(vis)); //【memse】t：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行【清零操作】的一种最快方法。它有三个参数，一是所要set的首地址，二是set的值，三是set的字节数，vis肯定是个数组，因为数组在传参时能自动转成指向数组的首元素的指针，如果不是数组，应该写成memset(&amp;vis, 0, sizeof(vis)); &nbsp; &nbsp; for (int i = 0; i &lt; 10; i++) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; if (vis[str[i]-&#39;0&#39;]) &nbsp;return false;//如果已访问，返回false &nbsp; &nbsp; &nbsp; &nbsp; vis[str[i]-&#39;0&#39;] = true;//未访问，改变该数字对应的访问数组的值 &nbsp; &nbsp; } &nbsp; &nbsp; return true; &nbsp;} &nbsp;int main() &nbsp;{ &nbsp; &nbsp; int n; &nbsp; &nbsp; bool first = true; &nbsp; &nbsp; while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; bool exist = false; &nbsp; &nbsp; &nbsp; &nbsp; if (first) &nbsp;first = false; &nbsp; &nbsp; &nbsp; &nbsp; else &nbsp;printf(&quot;\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 1234; i &lt;= 98765; i++) &nbsp;{&nbsp;//这里设abcde为A，fghij为B。没有必要枚举0~9的所有排列，只需枚举B就可以算出A，然后判断是否所有数字不相同即可。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int ans; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i % n == 0) //A可以整除n就说明这样的B存在，可以继续计算 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans = i / n;//计算出B； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ans &lt; 1234) &nbsp;continue;//排除a&lt;1234的情况； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (check(i, ans))//判断是否符合各个位不相同 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exist = true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%05d / %05d = %d\n&quot;, i, ans, n);//不足n位前补0：【%0nd】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (!exist) &nbsp;printf(&quot;There are no solutions for %d.\n&quot;, n); &nbsp; &nbsp; } &nbsp; &nbsp; return 0; &nbsp;} 总结： 1.暴力求解法并非是一味的暴力，本题中两个数之间有整除关系，只需确定一个；再利用每个数字都不同来筛选； 2.先找出满足整除条件的，然后筛掉不足1234的； 3.不会的知识点主要集中在【判断两个字符串中是否有重复数字】： （1）格式化：用sprintf把两个数字格式化成一个字符串； （2）memset函数的常用用法：对结构体或数组进行清零； （3）visit数组记录该数字是否被访问过，一旦visit[str-‘0’]的值被改编为true，即可返回false，排除这一组答案。 4.所谓的暴力并不是全暴力，要适当的节省时间空间，其中可能还穿插着一些小技巧。 【例题2】：输入n个元素组成的序列S，你需要找出一个乘积最大的连续子序列。如果这个最大的乘积不是正数，应输出0（表示无解）。1&lt;=n&lt;=18,-10&lt;=Si&lt;=10。 分析：连续子序列---&gt;联想到两要素:起点和终点---&gt;只需枚举起点和终点。 代码如下： #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int main() { &nbsp; &nbsp; int t,number,i,j,n,a[20]; &nbsp; &nbsp; long long ans,max1; &nbsp; &nbsp; number=0; &nbsp; &nbsp; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; for(i=1;i&lt;=n;i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf(&quot;%d&quot;,&amp;a[i]); &nbsp; &nbsp; &nbsp; &nbsp; max1=0; &nbsp; &nbsp; &nbsp; &nbsp; for(i=1;i&lt;=n;i++) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=a[i]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(ans&gt;max1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max1=ans; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(j=i+1;j&lt;=n;j++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans*=a[j]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(ans&gt;max1) max1=ans; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Case #%d: The maximum product is %lld.\n\n&quot;,++number,max1); &nbsp; &nbsp; } &nbsp; &nbsp; return 0; } 总结： 无论是求拥有连续最大和还是积的子序列，思想都是一样的。需要设定一个当前积ans，一个最大积max，第一重循环先固定第一个位置不动，把a[i]的值赋给ans，如果ans&gt;max，就改变max的值为ans的值（也就是说，如果在这里改变了max的值，最大子序列的第一个位置就要发生变化）。嵌套在其中的第二重循环用于确定末位置，ans=ans*a[j]，同样的，如果ans&gt;max，就改变max的值为ans的值。 如果还要添加功能，即记录最大子序列的起始位置和终止位置，则还需要两个变量start，end...... 【例题三】：给你一个数k，求所有使得1/k = 1/x + 1/y成立的x≥y的整数对。 题目分析：数论，枚举。首先通过x&gt;=y这个条件化简已知条件，可以得出k+1&lt;=y&lt;=2*k，枚举所有在区间（k+1，2k）上的y即可。当1/k - 1/y（通分）的结果分子为1即为一组解。 代码如下： #include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int a[10011];int b[10011];int main(){&nbsp; &nbsp; int n;&nbsp; &nbsp; while (scanf(&quot;%d&quot;,&amp;n))&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; int m = 2*n,count = 0;&nbsp; &nbsp; &nbsp; &nbsp; for (int i = n+1 ; i &lt;= m ; ++ i) &nbsp; &nbsp; &nbsp; &nbsp; //这里用i代表变化的y：从n+1到2n&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i*n % (i-n) == 0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a[count] = i*n/(i-n); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//一个分数的分母&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b[count] = i;//另一个分母&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count ++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%d\n&quot;,count);&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0 ; i &lt; count ; ++ i)&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;1/%d = 1/%d + 1/%d\n&quot;,n,a[i],b[i]);&nbsp; &nbsp; }&nbsp; &nbsp; return 0;} 总结：思路很明了，关键是变量的表示要明确。 枚举法 &nbsp; &nbsp; &nbsp; &nbsp;枚举法又称为穷举法，它是在计算机算法设计中用得最多的一种编程思想。它的实现方式是：在已知答案范围的情况下，依次地枚举该范围内所有的取值，并对每个取值进行考查，确定是否满足条件。经过循环遍历之后，筛选出符合要求的结果来。这种方法充分利用了计算机运算速度快的特点，思路简单直接，能够解决大部分的问题。 &nbsp; &nbsp; &nbsp; &nbsp; 什么样的问题适合使用穷举法来解决呢？归纳起来，遇到了如下的三种情况，将优先考虑使用穷举法： 1.&nbsp;答案的范围已知： 虽然事先并不知道确切的结果，但能预计到结果会落在哪个取值范围内。譬如说： ①求1-100之间所有的素数：&nbsp;无论结果如何，都在1-100的范围之内。 ②求2000－2015年间有几个月的13号是周日？这15年间共有180个月，月份的个数最多不会超过180 ③验证1000以内的哥德巴赫猜想：即找出1000之内所有的合数，看是否能够分解为两个质数之和。如果仔细观察，将会发现许多题目的结果范围都是已知的，都可以使用穷举法来实现。 2.&nbsp;答案的结果是离散的，不是连续的。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果要求出1－2之间所有的小数，就无法用穷举法来实现，因为其结果是无限连续的。 3.&nbsp;对时间上的要求不严格。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;蓝桥杯比赛中的许多题目对于算法的设计是有时间要求的，有时会非常苛刻。如果用穷举法则耗时过长，不可取。例如求出21位的水仙花数，使用穷举法可能会花费30分钟的时间。而蓝桥杯试题通常要求时间限制在1秒钟之内完成，少数会延长至3分钟。在这种情况下，必须使用新的算法来解决问题。 &nbsp; &nbsp; &nbsp; &nbsp;下面举个经典的例子：100块砖100人来搬，男人一人搬4块，女人一人搬3块，小孩3人抬一块，问男，女，小孩各几人？ &nbsp; &nbsp; &nbsp; 分析：若设男，女，小孩人数分别为X，Y，Z，则只能够列出两个等式：&nbsp;X+Y+Z＝100，4X+3Y+Z/3＝100&nbsp;。三个未知数两个等式，无法求解。这就只能够使用穷举法来实现，具体做法如下： &nbsp; &nbsp; &nbsp; &nbsp;先确定每种类型人员的数量的取值范围，由题意可知，男人X的取值范围是0~100/4＝25&nbsp;女人Y的取值范围是0~100/3＝33&nbsp;小孩的取值范围是0~99（必须不大于100且为3的倍数）。使用穷举法遍历所有可能的取值结果，逐一判断筛选出正确的结果。编程如下： for(int&nbsp;x=0;&nbsp;x&lt;=25;&nbsp;x++) for(int&nbsp;y=0;&nbsp;y&lt;=33;&nbsp;y++) for(int&nbsp;z=0;&nbsp;z&lt;=99;&nbsp;z+=3) if((x+y+z==100)&amp;&amp;(4*x+3*y+z/3==100)) {输出找到的结果} &nbsp; &nbsp; &nbsp; &nbsp; 如果仔细分析一下，就会发现由于x+y+z==100，那么只需要考虑x和y的遍历取值；z值可以通过100－x&nbsp;-&nbsp;y来实现。当然，z值是3的倍数，上述代码可修改如下： for(int&nbsp;x=0;&nbsp;x&lt;=25;&nbsp;x++) for(int&nbsp;y=0;&nbsp;y&lt;=33;&nbsp;y++) {&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;z&nbsp;=&nbsp;100&nbsp;-&nbsp;x&nbsp;-&nbsp;y; if((z%3==0)&amp;&amp;(4*x+3*y+z/3==100)) {输出找到的结果} } &nbsp; &nbsp; &nbsp; &nbsp; 从这道题的解决过程中，我们可以发现使用穷举法的一般过程：确定需要哪几个变量，此题需要3个变量x，y，&nbsp;z&nbsp;&nbsp;如果是其它的题目，所需变量的个数与类型有可能不尽相同，这个要由具体情况而定。确定每个变量的取值范围，如上例之中X的范围是0~25，&nbsp;y的取值范围是0~33，&nbsp;z的取值范围是0~33。设置多层的嵌套循环，通常为for循环，最内层之中设置条件判断，满足输出条件时，输出相关的提示信息。 &nbsp; &nbsp; &nbsp; &nbsp;再来一道可以使用穷举法解决的问题：有一群海盗（不多于20人），在船上比拼酒量。过程如下：打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。再打开一瓶酒平分，又有倒下的，再次重复......&nbsp;直到开了第4瓶酒，坐着的已经所剩无几，海盗船长也在其中。当第4瓶酒平分喝下后，大家都倒下了。&nbsp;等船长醒来，发现海盗船搁浅了。他在航海日志中写到：“......昨天，我正好喝了一瓶.......奉劝大家，开船不喝酒，喝酒别开船......” &nbsp; &nbsp; &nbsp; &nbsp;请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人。&nbsp;如果有多个可能的答案，请列出所有答案，每个答案占一行。 &nbsp; &nbsp; &nbsp; &nbsp;格式是：人数,人数,... &nbsp; &nbsp; &nbsp; &nbsp;例如,有一种可能是：20,5,4,2,0 &nbsp; &nbsp; &nbsp; &nbsp;蓝桥杯中的许多题目都会提供一个答案的示例，通过分析这个示例可以加深对当前这道题的理解。以本题为例，通过研究示例答案可以看出如下的特点： （1）答案只可能有4个数，分别代表每轮参与的人数，最后的0是固定的。 （2）每轮的人数是不断减少的，下一轮只能够比上一轮人数更少。 （3）每轮人数被1除之后，累加和是1（刚好一瓶酒） 即&nbsp;1/20+1/5+1/4+1/2=1 根据上述的分析，可以确定如下的变量s1,&nbsp;s2,&nbsp;s3,&nbsp;s4分别代表每轮的人数。这四个变量的取值范围分别是1≤s1≤20,1≤s2≤s1,1≤s3≤s2,1≤s4≤s3 据此来设置4层的嵌套循环,并加上最内层的条件判断如下： for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) if(1/s1+1/s2+1/s3+1/s4==1){输出结果}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;理论上来看是正确的，但实际运行时，由于/运算符在左右两边均为整数时，表示整除而不是除法，所以上述的条件判断需要改写为更复杂的形式： (s1*s2*s3+s1*s3*s4+s1*s3*s4+s2*s3*s4)/(s1*s2*s3*s4)==1 &nbsp; &nbsp; &nbsp; &nbsp;根据笔者指导蓝桥杯的经验，至少有三分之一的问题都可以通过穷举的方法来实现，因此，把穷举法练习使用好，意义非常重大。 &nbsp; 递归法 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;基于前面中介绍如何应用穷举法来解决具体的编程问题。穷举法最为常用，可以解决大部分常见的问题。现在再来介绍一种新的解题思路： 递归法它可以看成是对穷举法的一种补充。它的思路是在不方便穷举所有的可能时，通过设置特定的函数，在该函数内部反复地调用自身并输入不同的参数，以达到遍历所有可能性的目的。使用递归法代码量小，编码简单，逻辑清晰，不易出错。下面通过一个经典的例子来让大家感受下递归法的应用方法。 例1： 汉诺塔问题 汉诺塔问题是最经典的只能够使用递归的方法解决的问题 题目描述如下：据传说，在古代世界中心的贝拿勒斯（印度北部）的圣庙里，一块在黄铜板上插着3根宝石针。印度教的主神梵天在创造世界时，在其中的一根针上自下而上地穿好了由大至小的64层金片，即为汉诺塔。无论白天黑夜，总有一个僧侣按如下的法则移动这些金片，一次只能够移动一层，不管在哪根针上，小片必须在大片的上面。 要求借助于第二根针将整个汉诺塔移至第三根针上。&nbsp; 假设汉诺塔只有4层，其具体的移动过程如下动画所示： 本题具有如下的特点，使之不能使用穷举法： 1. 不便于穷举： 如果用数学的方法估算，假设一秒钟移动一片，将64层的汉诺塔移至另一根针上所需的步骤是个天文数字：共需接近5845亿年。 由于取值范围过大，且无法循环，不可能将所有的过程都穷举实现出来。 2. 可以经由一系列有限的步骤实现，其中的每个步骤都很相似，这道题为例，初始时有n层，第一大步就是将上面的n-1层移动至第三根针上，再将最下面的第n层移动至第二根针上，再将第三根针上的n-1层借助第一根针移动至第二根针上。在移动n-1层时，所使用的过程与移动n层是相同的，无非是初始针，目标针和辅助针和移动的层数不同而已。 只要满足这样的条件，都可以试着使用递归的方法来设计 过程如下： 定义函数 moveHanNoi（层数，初始针，辅助针，目标针） { if(层数＝＝1)&nbsp; {直接从初始针移动至目标针} else { moveHanNoi(层数－1，初始针，目标针，辅助针) &nbsp; //将（层数－1）层汉诺塔由初始针，利用目标针移至辅助针 直接从初始针移动第n层至目标针 moveHanNoi(层数－1，辅助针，初始针，目标针) &nbsp; //将（层数－1）层汉诺塔由辅助针，利用初始针移至目标针 } } 这样一来，只需要第一次输入初始人层数，初始针，辅助针，目标针的参数，即可得到结果。省却了复杂的循环遍历的麻烦。像这种在一个函数内部又调用自身，只是每次调用时传递参数不同的现象，称为递归。 下面再举两个例子来强化大家对于递归算法的认识： 例2： 给定一个正整数，输出它的阶乘。 数学中阶乘的定义就是从1开始逐步累乘自然数到当前的数，使用！来表示阶乘，如 1！ ＝ 1 2！ ＝ 1*2 3！＝1*2*3 4！ ＝ 1*2*3*4 …… 很快大家就会想到使用穷举法，确实，用穷举法能够非常直接地解决此问题，核心代码如下（C#） …… int sum =1; for(int i=1; i&lt;=n; i++) sum *= i; 输出sum的结果 再来仔细地分析阶乘的分解过程，很容易发现了如下的规律： 1！ ＝1 2！ ＝ 2*1！ ＝ 2 3！ ＝ 3*2！＝3*2*1！ ＝ 6 4！ ＝ 4*3！＝4*3*2！＝4*3*2*1！ ＝ 24 总结如下： 1的阶乘为1，其它任何数的阶乘等于n乘以（n-1）的阶乘。 这里为了求得n的阶乘，必须用同样的方法求得（n-1）的阶乘，再与当前数相乘得到结果。这与汉诺塔中的递归过程何其相似。设计递归的算法如下： 定义函数 &nbsp;jiecheng（int 当前数） 返回当前数的阶乘 { if（当前数 ＝＝ 1） 返回1； else 返回当前数与（当前数－1）阶乘的乘积 } 用C#语言实现如下： int jiecheng(int curNum) {return curNum==1?1:curNum*jiecheng(curNum-1);} 例3： 在8*8的国际象棋棋盘上，放置了8个皇后，使之不能相互攻击，找出所有满足条件的布局 分析：&nbsp; （1） 由于国际象棋中皇后的威力最大，横、竖、斜三个方向均可攻击。若想8个皇后和平共处，必须保证棋盘上横、竖、斜三个方向上最多只有一个皇后。 （2） 8*8的棋盘可以使用8*8的二维数组来表示，0代表空，1代表皇后，将此二维数组输出即可表示棋盘的状态。 （3） 以列为单位，自左至右依次地在每一列中由上到下放置皇后，每放置一个之后，看它是否与现有的皇后相冲突。若没有冲突，继续试探下一列。若有冲突，尝试摆放到下一行。最终当试探完最后一列且无冲突之后，输出结果。 设行号为0－7， 列号为0－7&nbsp;其执行过程如下： 定义函数 &nbsp; place(当前列号，棋盘) &nbsp; //表示试探棋盘上的某一列 { if（列号＝＝8） {输出当前棋盘的状态，返回；} 从第0行遍历至第7行，每次遍历时 { 1. 放置皇后，当前位置为1 2.观察是否与已有的皇后位置冲突 //可设置一个函数来进行判断 无冲突时： 试探下一列，调用自身place(当前列号+1，棋盘) 3. 撤消皇后所在的位置 } } 通过上面的例子，可以得出递归法的编程模式如下： 1. 尝试着做某种最基本的操作，该操作将会改变现有的状态 汉诺塔： 移动一层塔，导致初始针，辅助针，目标针的状态改变。 阶乘： 当前数乘以比它小一的数的阶乘，改变了累乘的结果。 八皇后： 放置一个皇后在棋盘格式里，当前棋盘的状态改变了。 2. 根据当前的状态，观察是否到了 不需要递归的时刻，如： 汉诺塔： 前n-1层已经移动至辅助针，直接将当前层移动至目标针，不需要递归。 阶乘： 当前数为1时，不需要递归，直接返回1 八皇后：0－7列全部试探完毕，不再递归 3.如果未到不必递归时，递归地调用自身，注意每次调用时的参数不同： 汉诺塔： 若当前n-1层未完全移至辅助针，需要递归调用自身，使用的参数“层数”，“初始针”，“目标针”，“辅助针”都会发生变化 阶乘： 当前数不为1时，递归调用阶乘本身，参数要变成“当前数－1”，返回值为当前数*下一阶乘数 4. 撤消当前的操作，状态还原（可选） 八皇后问题中，在某一列上放置了皇后，无论是否合适，都要在试探完毕之后撤走，再放置到下一位置。这个撤消的操作在迷宫类的题目中非常重要，否则无法得到所有的可能状态。但汉诺塔与阶乘问题中不需要状态还原。" />
<meta property="og:description" content="暴力法 【例题1】：输入一个整数n，按从小到大的顺序输出所有形如abcde/fghij=n的表达式，其中a~j恰好为数字0~9的一个排列（可以有前导0），2&lt;=n&lt;=79。 代码如下： #include &lt;cstdio&gt; #include &lt;cstring&gt; bool vis[10];//【visit数组】用下标判断数字是否已经被访问过； char str[15];//vis里的数字是按照0-9的顺序，str是按a和b给定的顺序 bool check(int a, int b) { &nbsp; &nbsp; sprintf(str, &quot;%05d%05d&quot;, a, b); //【格式化字符串】int sprintf( char *buffer, const char *format [, argument] ... )。除了前两个参数类型固定外，后面可以接任意多个参数，这取决于第二个参数需要几个后继参数。而它的精华，显然就在第二个参数：【格式化字符串】上。 &nbsp; &nbsp; memset(vis, 0, sizeof(vis)); //【memse】t：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行【清零操作】的一种最快方法。它有三个参数，一是所要set的首地址，二是set的值，三是set的字节数，vis肯定是个数组，因为数组在传参时能自动转成指向数组的首元素的指针，如果不是数组，应该写成memset(&amp;vis, 0, sizeof(vis)); &nbsp; &nbsp; for (int i = 0; i &lt; 10; i++) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; if (vis[str[i]-&#39;0&#39;]) &nbsp;return false;//如果已访问，返回false &nbsp; &nbsp; &nbsp; &nbsp; vis[str[i]-&#39;0&#39;] = true;//未访问，改变该数字对应的访问数组的值 &nbsp; &nbsp; } &nbsp; &nbsp; return true; &nbsp;} &nbsp;int main() &nbsp;{ &nbsp; &nbsp; int n; &nbsp; &nbsp; bool first = true; &nbsp; &nbsp; while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; bool exist = false; &nbsp; &nbsp; &nbsp; &nbsp; if (first) &nbsp;first = false; &nbsp; &nbsp; &nbsp; &nbsp; else &nbsp;printf(&quot;\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 1234; i &lt;= 98765; i++) &nbsp;{&nbsp;//这里设abcde为A，fghij为B。没有必要枚举0~9的所有排列，只需枚举B就可以算出A，然后判断是否所有数字不相同即可。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int ans; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i % n == 0) //A可以整除n就说明这样的B存在，可以继续计算 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans = i / n;//计算出B； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ans &lt; 1234) &nbsp;continue;//排除a&lt;1234的情况； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (check(i, ans))//判断是否符合各个位不相同 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exist = true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%05d / %05d = %d\n&quot;, i, ans, n);//不足n位前补0：【%0nd】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (!exist) &nbsp;printf(&quot;There are no solutions for %d.\n&quot;, n); &nbsp; &nbsp; } &nbsp; &nbsp; return 0; &nbsp;} 总结： 1.暴力求解法并非是一味的暴力，本题中两个数之间有整除关系，只需确定一个；再利用每个数字都不同来筛选； 2.先找出满足整除条件的，然后筛掉不足1234的； 3.不会的知识点主要集中在【判断两个字符串中是否有重复数字】： （1）格式化：用sprintf把两个数字格式化成一个字符串； （2）memset函数的常用用法：对结构体或数组进行清零； （3）visit数组记录该数字是否被访问过，一旦visit[str-‘0’]的值被改编为true，即可返回false，排除这一组答案。 4.所谓的暴力并不是全暴力，要适当的节省时间空间，其中可能还穿插着一些小技巧。 【例题2】：输入n个元素组成的序列S，你需要找出一个乘积最大的连续子序列。如果这个最大的乘积不是正数，应输出0（表示无解）。1&lt;=n&lt;=18,-10&lt;=Si&lt;=10。 分析：连续子序列---&gt;联想到两要素:起点和终点---&gt;只需枚举起点和终点。 代码如下： #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int main() { &nbsp; &nbsp; int t,number,i,j,n,a[20]; &nbsp; &nbsp; long long ans,max1; &nbsp; &nbsp; number=0; &nbsp; &nbsp; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; for(i=1;i&lt;=n;i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf(&quot;%d&quot;,&amp;a[i]); &nbsp; &nbsp; &nbsp; &nbsp; max1=0; &nbsp; &nbsp; &nbsp; &nbsp; for(i=1;i&lt;=n;i++) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=a[i]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(ans&gt;max1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max1=ans; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(j=i+1;j&lt;=n;j++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans*=a[j]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(ans&gt;max1) max1=ans; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Case #%d: The maximum product is %lld.\n\n&quot;,++number,max1); &nbsp; &nbsp; } &nbsp; &nbsp; return 0; } 总结： 无论是求拥有连续最大和还是积的子序列，思想都是一样的。需要设定一个当前积ans，一个最大积max，第一重循环先固定第一个位置不动，把a[i]的值赋给ans，如果ans&gt;max，就改变max的值为ans的值（也就是说，如果在这里改变了max的值，最大子序列的第一个位置就要发生变化）。嵌套在其中的第二重循环用于确定末位置，ans=ans*a[j]，同样的，如果ans&gt;max，就改变max的值为ans的值。 如果还要添加功能，即记录最大子序列的起始位置和终止位置，则还需要两个变量start，end...... 【例题三】：给你一个数k，求所有使得1/k = 1/x + 1/y成立的x≥y的整数对。 题目分析：数论，枚举。首先通过x&gt;=y这个条件化简已知条件，可以得出k+1&lt;=y&lt;=2*k，枚举所有在区间（k+1，2k）上的y即可。当1/k - 1/y（通分）的结果分子为1即为一组解。 代码如下： #include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int a[10011];int b[10011];int main(){&nbsp; &nbsp; int n;&nbsp; &nbsp; while (scanf(&quot;%d&quot;,&amp;n))&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; int m = 2*n,count = 0;&nbsp; &nbsp; &nbsp; &nbsp; for (int i = n+1 ; i &lt;= m ; ++ i) &nbsp; &nbsp; &nbsp; &nbsp; //这里用i代表变化的y：从n+1到2n&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i*n % (i-n) == 0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a[count] = i*n/(i-n); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//一个分数的分母&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b[count] = i;//另一个分母&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count ++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%d\n&quot;,count);&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0 ; i &lt; count ; ++ i)&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;1/%d = 1/%d + 1/%d\n&quot;,n,a[i],b[i]);&nbsp; &nbsp; }&nbsp; &nbsp; return 0;} 总结：思路很明了，关键是变量的表示要明确。 枚举法 &nbsp; &nbsp; &nbsp; &nbsp;枚举法又称为穷举法，它是在计算机算法设计中用得最多的一种编程思想。它的实现方式是：在已知答案范围的情况下，依次地枚举该范围内所有的取值，并对每个取值进行考查，确定是否满足条件。经过循环遍历之后，筛选出符合要求的结果来。这种方法充分利用了计算机运算速度快的特点，思路简单直接，能够解决大部分的问题。 &nbsp; &nbsp; &nbsp; &nbsp; 什么样的问题适合使用穷举法来解决呢？归纳起来，遇到了如下的三种情况，将优先考虑使用穷举法： 1.&nbsp;答案的范围已知： 虽然事先并不知道确切的结果，但能预计到结果会落在哪个取值范围内。譬如说： ①求1-100之间所有的素数：&nbsp;无论结果如何，都在1-100的范围之内。 ②求2000－2015年间有几个月的13号是周日？这15年间共有180个月，月份的个数最多不会超过180 ③验证1000以内的哥德巴赫猜想：即找出1000之内所有的合数，看是否能够分解为两个质数之和。如果仔细观察，将会发现许多题目的结果范围都是已知的，都可以使用穷举法来实现。 2.&nbsp;答案的结果是离散的，不是连续的。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果要求出1－2之间所有的小数，就无法用穷举法来实现，因为其结果是无限连续的。 3.&nbsp;对时间上的要求不严格。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;蓝桥杯比赛中的许多题目对于算法的设计是有时间要求的，有时会非常苛刻。如果用穷举法则耗时过长，不可取。例如求出21位的水仙花数，使用穷举法可能会花费30分钟的时间。而蓝桥杯试题通常要求时间限制在1秒钟之内完成，少数会延长至3分钟。在这种情况下，必须使用新的算法来解决问题。 &nbsp; &nbsp; &nbsp; &nbsp;下面举个经典的例子：100块砖100人来搬，男人一人搬4块，女人一人搬3块，小孩3人抬一块，问男，女，小孩各几人？ &nbsp; &nbsp; &nbsp; 分析：若设男，女，小孩人数分别为X，Y，Z，则只能够列出两个等式：&nbsp;X+Y+Z＝100，4X+3Y+Z/3＝100&nbsp;。三个未知数两个等式，无法求解。这就只能够使用穷举法来实现，具体做法如下： &nbsp; &nbsp; &nbsp; &nbsp;先确定每种类型人员的数量的取值范围，由题意可知，男人X的取值范围是0~100/4＝25&nbsp;女人Y的取值范围是0~100/3＝33&nbsp;小孩的取值范围是0~99（必须不大于100且为3的倍数）。使用穷举法遍历所有可能的取值结果，逐一判断筛选出正确的结果。编程如下： for(int&nbsp;x=0;&nbsp;x&lt;=25;&nbsp;x++) for(int&nbsp;y=0;&nbsp;y&lt;=33;&nbsp;y++) for(int&nbsp;z=0;&nbsp;z&lt;=99;&nbsp;z+=3) if((x+y+z==100)&amp;&amp;(4*x+3*y+z/3==100)) {输出找到的结果} &nbsp; &nbsp; &nbsp; &nbsp; 如果仔细分析一下，就会发现由于x+y+z==100，那么只需要考虑x和y的遍历取值；z值可以通过100－x&nbsp;-&nbsp;y来实现。当然，z值是3的倍数，上述代码可修改如下： for(int&nbsp;x=0;&nbsp;x&lt;=25;&nbsp;x++) for(int&nbsp;y=0;&nbsp;y&lt;=33;&nbsp;y++) {&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;z&nbsp;=&nbsp;100&nbsp;-&nbsp;x&nbsp;-&nbsp;y; if((z%3==0)&amp;&amp;(4*x+3*y+z/3==100)) {输出找到的结果} } &nbsp; &nbsp; &nbsp; &nbsp; 从这道题的解决过程中，我们可以发现使用穷举法的一般过程：确定需要哪几个变量，此题需要3个变量x，y，&nbsp;z&nbsp;&nbsp;如果是其它的题目，所需变量的个数与类型有可能不尽相同，这个要由具体情况而定。确定每个变量的取值范围，如上例之中X的范围是0~25，&nbsp;y的取值范围是0~33，&nbsp;z的取值范围是0~33。设置多层的嵌套循环，通常为for循环，最内层之中设置条件判断，满足输出条件时，输出相关的提示信息。 &nbsp; &nbsp; &nbsp; &nbsp;再来一道可以使用穷举法解决的问题：有一群海盗（不多于20人），在船上比拼酒量。过程如下：打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。再打开一瓶酒平分，又有倒下的，再次重复......&nbsp;直到开了第4瓶酒，坐着的已经所剩无几，海盗船长也在其中。当第4瓶酒平分喝下后，大家都倒下了。&nbsp;等船长醒来，发现海盗船搁浅了。他在航海日志中写到：“......昨天，我正好喝了一瓶.......奉劝大家，开船不喝酒，喝酒别开船......” &nbsp; &nbsp; &nbsp; &nbsp;请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人。&nbsp;如果有多个可能的答案，请列出所有答案，每个答案占一行。 &nbsp; &nbsp; &nbsp; &nbsp;格式是：人数,人数,... &nbsp; &nbsp; &nbsp; &nbsp;例如,有一种可能是：20,5,4,2,0 &nbsp; &nbsp; &nbsp; &nbsp;蓝桥杯中的许多题目都会提供一个答案的示例，通过分析这个示例可以加深对当前这道题的理解。以本题为例，通过研究示例答案可以看出如下的特点： （1）答案只可能有4个数，分别代表每轮参与的人数，最后的0是固定的。 （2）每轮的人数是不断减少的，下一轮只能够比上一轮人数更少。 （3）每轮人数被1除之后，累加和是1（刚好一瓶酒） 即&nbsp;1/20+1/5+1/4+1/2=1 根据上述的分析，可以确定如下的变量s1,&nbsp;s2,&nbsp;s3,&nbsp;s4分别代表每轮的人数。这四个变量的取值范围分别是1≤s1≤20,1≤s2≤s1,1≤s3≤s2,1≤s4≤s3 据此来设置4层的嵌套循环,并加上最内层的条件判断如下： for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) if(1/s1+1/s2+1/s3+1/s4==1){输出结果}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;理论上来看是正确的，但实际运行时，由于/运算符在左右两边均为整数时，表示整除而不是除法，所以上述的条件判断需要改写为更复杂的形式： (s1*s2*s3+s1*s3*s4+s1*s3*s4+s2*s3*s4)/(s1*s2*s3*s4)==1 &nbsp; &nbsp; &nbsp; &nbsp;根据笔者指导蓝桥杯的经验，至少有三分之一的问题都可以通过穷举的方法来实现，因此，把穷举法练习使用好，意义非常重大。 &nbsp; 递归法 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;基于前面中介绍如何应用穷举法来解决具体的编程问题。穷举法最为常用，可以解决大部分常见的问题。现在再来介绍一种新的解题思路： 递归法它可以看成是对穷举法的一种补充。它的思路是在不方便穷举所有的可能时，通过设置特定的函数，在该函数内部反复地调用自身并输入不同的参数，以达到遍历所有可能性的目的。使用递归法代码量小，编码简单，逻辑清晰，不易出错。下面通过一个经典的例子来让大家感受下递归法的应用方法。 例1： 汉诺塔问题 汉诺塔问题是最经典的只能够使用递归的方法解决的问题 题目描述如下：据传说，在古代世界中心的贝拿勒斯（印度北部）的圣庙里，一块在黄铜板上插着3根宝石针。印度教的主神梵天在创造世界时，在其中的一根针上自下而上地穿好了由大至小的64层金片，即为汉诺塔。无论白天黑夜，总有一个僧侣按如下的法则移动这些金片，一次只能够移动一层，不管在哪根针上，小片必须在大片的上面。 要求借助于第二根针将整个汉诺塔移至第三根针上。&nbsp; 假设汉诺塔只有4层，其具体的移动过程如下动画所示： 本题具有如下的特点，使之不能使用穷举法： 1. 不便于穷举： 如果用数学的方法估算，假设一秒钟移动一片，将64层的汉诺塔移至另一根针上所需的步骤是个天文数字：共需接近5845亿年。 由于取值范围过大，且无法循环，不可能将所有的过程都穷举实现出来。 2. 可以经由一系列有限的步骤实现，其中的每个步骤都很相似，这道题为例，初始时有n层，第一大步就是将上面的n-1层移动至第三根针上，再将最下面的第n层移动至第二根针上，再将第三根针上的n-1层借助第一根针移动至第二根针上。在移动n-1层时，所使用的过程与移动n层是相同的，无非是初始针，目标针和辅助针和移动的层数不同而已。 只要满足这样的条件，都可以试着使用递归的方法来设计 过程如下： 定义函数 moveHanNoi（层数，初始针，辅助针，目标针） { if(层数＝＝1)&nbsp; {直接从初始针移动至目标针} else { moveHanNoi(层数－1，初始针，目标针，辅助针) &nbsp; //将（层数－1）层汉诺塔由初始针，利用目标针移至辅助针 直接从初始针移动第n层至目标针 moveHanNoi(层数－1，辅助针，初始针，目标针) &nbsp; //将（层数－1）层汉诺塔由辅助针，利用初始针移至目标针 } } 这样一来，只需要第一次输入初始人层数，初始针，辅助针，目标针的参数，即可得到结果。省却了复杂的循环遍历的麻烦。像这种在一个函数内部又调用自身，只是每次调用时传递参数不同的现象，称为递归。 下面再举两个例子来强化大家对于递归算法的认识： 例2： 给定一个正整数，输出它的阶乘。 数学中阶乘的定义就是从1开始逐步累乘自然数到当前的数，使用！来表示阶乘，如 1！ ＝ 1 2！ ＝ 1*2 3！＝1*2*3 4！ ＝ 1*2*3*4 …… 很快大家就会想到使用穷举法，确实，用穷举法能够非常直接地解决此问题，核心代码如下（C#） …… int sum =1; for(int i=1; i&lt;=n; i++) sum *= i; 输出sum的结果 再来仔细地分析阶乘的分解过程，很容易发现了如下的规律： 1！ ＝1 2！ ＝ 2*1！ ＝ 2 3！ ＝ 3*2！＝3*2*1！ ＝ 6 4！ ＝ 4*3！＝4*3*2！＝4*3*2*1！ ＝ 24 总结如下： 1的阶乘为1，其它任何数的阶乘等于n乘以（n-1）的阶乘。 这里为了求得n的阶乘，必须用同样的方法求得（n-1）的阶乘，再与当前数相乘得到结果。这与汉诺塔中的递归过程何其相似。设计递归的算法如下： 定义函数 &nbsp;jiecheng（int 当前数） 返回当前数的阶乘 { if（当前数 ＝＝ 1） 返回1； else 返回当前数与（当前数－1）阶乘的乘积 } 用C#语言实现如下： int jiecheng(int curNum) {return curNum==1?1:curNum*jiecheng(curNum-1);} 例3： 在8*8的国际象棋棋盘上，放置了8个皇后，使之不能相互攻击，找出所有满足条件的布局 分析：&nbsp; （1） 由于国际象棋中皇后的威力最大，横、竖、斜三个方向均可攻击。若想8个皇后和平共处，必须保证棋盘上横、竖、斜三个方向上最多只有一个皇后。 （2） 8*8的棋盘可以使用8*8的二维数组来表示，0代表空，1代表皇后，将此二维数组输出即可表示棋盘的状态。 （3） 以列为单位，自左至右依次地在每一列中由上到下放置皇后，每放置一个之后，看它是否与现有的皇后相冲突。若没有冲突，继续试探下一列。若有冲突，尝试摆放到下一行。最终当试探完最后一列且无冲突之后，输出结果。 设行号为0－7， 列号为0－7&nbsp;其执行过程如下： 定义函数 &nbsp; place(当前列号，棋盘) &nbsp; //表示试探棋盘上的某一列 { if（列号＝＝8） {输出当前棋盘的状态，返回；} 从第0行遍历至第7行，每次遍历时 { 1. 放置皇后，当前位置为1 2.观察是否与已有的皇后位置冲突 //可设置一个函数来进行判断 无冲突时： 试探下一列，调用自身place(当前列号+1，棋盘) 3. 撤消皇后所在的位置 } } 通过上面的例子，可以得出递归法的编程模式如下： 1. 尝试着做某种最基本的操作，该操作将会改变现有的状态 汉诺塔： 移动一层塔，导致初始针，辅助针，目标针的状态改变。 阶乘： 当前数乘以比它小一的数的阶乘，改变了累乘的结果。 八皇后： 放置一个皇后在棋盘格式里，当前棋盘的状态改变了。 2. 根据当前的状态，观察是否到了 不需要递归的时刻，如： 汉诺塔： 前n-1层已经移动至辅助针，直接将当前层移动至目标针，不需要递归。 阶乘： 当前数为1时，不需要递归，直接返回1 八皇后：0－7列全部试探完毕，不再递归 3.如果未到不必递归时，递归地调用自身，注意每次调用时的参数不同： 汉诺塔： 若当前n-1层未完全移至辅助针，需要递归调用自身，使用的参数“层数”，“初始针”，“目标针”，“辅助针”都会发生变化 阶乘： 当前数不为1时，递归调用阶乘本身，参数要变成“当前数－1”，返回值为当前数*下一阶乘数 4. 撤消当前的操作，状态还原（可选） 八皇后问题中，在某一列上放置了皇后，无论是否合适，都要在试探完毕之后撤走，再放置到下一位置。这个撤消的操作在迷宫类的题目中非常重要，否则无法得到所有的可能状态。但汉诺塔与阶乘问题中不需要状态还原。" />
<link rel="canonical" href="https://mlh.app/2019/04/28/728534.html" />
<meta property="og:url" content="https://mlh.app/2019/04/28/728534.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"暴力法 【例题1】：输入一个整数n，按从小到大的顺序输出所有形如abcde/fghij=n的表达式，其中a~j恰好为数字0~9的一个排列（可以有前导0），2&lt;=n&lt;=79。 代码如下： #include &lt;cstdio&gt; #include &lt;cstring&gt; bool vis[10];//【visit数组】用下标判断数字是否已经被访问过； char str[15];//vis里的数字是按照0-9的顺序，str是按a和b给定的顺序 bool check(int a, int b) { &nbsp; &nbsp; sprintf(str, &quot;%05d%05d&quot;, a, b); //【格式化字符串】int sprintf( char *buffer, const char *format [, argument] ... )。除了前两个参数类型固定外，后面可以接任意多个参数，这取决于第二个参数需要几个后继参数。而它的精华，显然就在第二个参数：【格式化字符串】上。 &nbsp; &nbsp; memset(vis, 0, sizeof(vis)); //【memse】t：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行【清零操作】的一种最快方法。它有三个参数，一是所要set的首地址，二是set的值，三是set的字节数，vis肯定是个数组，因为数组在传参时能自动转成指向数组的首元素的指针，如果不是数组，应该写成memset(&amp;vis, 0, sizeof(vis)); &nbsp; &nbsp; for (int i = 0; i &lt; 10; i++) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; if (vis[str[i]-&#39;0&#39;]) &nbsp;return false;//如果已访问，返回false &nbsp; &nbsp; &nbsp; &nbsp; vis[str[i]-&#39;0&#39;] = true;//未访问，改变该数字对应的访问数组的值 &nbsp; &nbsp; } &nbsp; &nbsp; return true; &nbsp;} &nbsp;int main() &nbsp;{ &nbsp; &nbsp; int n; &nbsp; &nbsp; bool first = true; &nbsp; &nbsp; while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; bool exist = false; &nbsp; &nbsp; &nbsp; &nbsp; if (first) &nbsp;first = false; &nbsp; &nbsp; &nbsp; &nbsp; else &nbsp;printf(&quot;\\n&quot;); &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 1234; i &lt;= 98765; i++) &nbsp;{&nbsp;//这里设abcde为A，fghij为B。没有必要枚举0~9的所有排列，只需枚举B就可以算出A，然后判断是否所有数字不相同即可。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int ans; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i % n == 0) //A可以整除n就说明这样的B存在，可以继续计算 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans = i / n;//计算出B； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ans &lt; 1234) &nbsp;continue;//排除a&lt;1234的情况； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (check(i, ans))//判断是否符合各个位不相同 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exist = true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%05d / %05d = %d\\n&quot;, i, ans, n);//不足n位前补0：【%0nd】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; if (!exist) &nbsp;printf(&quot;There are no solutions for %d.\\n&quot;, n); &nbsp; &nbsp; } &nbsp; &nbsp; return 0; &nbsp;} 总结： 1.暴力求解法并非是一味的暴力，本题中两个数之间有整除关系，只需确定一个；再利用每个数字都不同来筛选； 2.先找出满足整除条件的，然后筛掉不足1234的； 3.不会的知识点主要集中在【判断两个字符串中是否有重复数字】： （1）格式化：用sprintf把两个数字格式化成一个字符串； （2）memset函数的常用用法：对结构体或数组进行清零； （3）visit数组记录该数字是否被访问过，一旦visit[str-‘0’]的值被改编为true，即可返回false，排除这一组答案。 4.所谓的暴力并不是全暴力，要适当的节省时间空间，其中可能还穿插着一些小技巧。 【例题2】：输入n个元素组成的序列S，你需要找出一个乘积最大的连续子序列。如果这个最大的乘积不是正数，应输出0（表示无解）。1&lt;=n&lt;=18,-10&lt;=Si&lt;=10。 分析：连续子序列---&gt;联想到两要素:起点和终点---&gt;只需枚举起点和终点。 代码如下： #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int main() { &nbsp; &nbsp; int t,number,i,j,n,a[20]; &nbsp; &nbsp; long long ans,max1; &nbsp; &nbsp; number=0; &nbsp; &nbsp; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; for(i=1;i&lt;=n;i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf(&quot;%d&quot;,&amp;a[i]); &nbsp; &nbsp; &nbsp; &nbsp; max1=0; &nbsp; &nbsp; &nbsp; &nbsp; for(i=1;i&lt;=n;i++) &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=a[i]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(ans&gt;max1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max1=ans; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(j=i+1;j&lt;=n;j++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans*=a[j]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(ans&gt;max1) max1=ans; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Case #%d: The maximum product is %lld.\\n\\n&quot;,++number,max1); &nbsp; &nbsp; } &nbsp; &nbsp; return 0; } 总结： 无论是求拥有连续最大和还是积的子序列，思想都是一样的。需要设定一个当前积ans，一个最大积max，第一重循环先固定第一个位置不动，把a[i]的值赋给ans，如果ans&gt;max，就改变max的值为ans的值（也就是说，如果在这里改变了max的值，最大子序列的第一个位置就要发生变化）。嵌套在其中的第二重循环用于确定末位置，ans=ans*a[j]，同样的，如果ans&gt;max，就改变max的值为ans的值。 如果还要添加功能，即记录最大子序列的起始位置和终止位置，则还需要两个变量start，end...... 【例题三】：给你一个数k，求所有使得1/k = 1/x + 1/y成立的x≥y的整数对。 题目分析：数论，枚举。首先通过x&gt;=y这个条件化简已知条件，可以得出k+1&lt;=y&lt;=2*k，枚举所有在区间（k+1，2k）上的y即可。当1/k - 1/y（通分）的结果分子为1即为一组解。 代码如下： #include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int a[10011];int b[10011];int main(){&nbsp; &nbsp; int n;&nbsp; &nbsp; while (scanf(&quot;%d&quot;,&amp;n))&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; int m = 2*n,count = 0;&nbsp; &nbsp; &nbsp; &nbsp; for (int i = n+1 ; i &lt;= m ; ++ i) &nbsp; &nbsp; &nbsp; &nbsp; //这里用i代表变化的y：从n+1到2n&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i*n % (i-n) == 0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a[count] = i*n/(i-n); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//一个分数的分母&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b[count] = i;//另一个分母&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count ++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%d\\n&quot;,count);&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0 ; i &lt; count ; ++ i)&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;1/%d = 1/%d + 1/%d\\n&quot;,n,a[i],b[i]);&nbsp; &nbsp; }&nbsp; &nbsp; return 0;} 总结：思路很明了，关键是变量的表示要明确。 枚举法 &nbsp; &nbsp; &nbsp; &nbsp;枚举法又称为穷举法，它是在计算机算法设计中用得最多的一种编程思想。它的实现方式是：在已知答案范围的情况下，依次地枚举该范围内所有的取值，并对每个取值进行考查，确定是否满足条件。经过循环遍历之后，筛选出符合要求的结果来。这种方法充分利用了计算机运算速度快的特点，思路简单直接，能够解决大部分的问题。 &nbsp; &nbsp; &nbsp; &nbsp; 什么样的问题适合使用穷举法来解决呢？归纳起来，遇到了如下的三种情况，将优先考虑使用穷举法： 1.&nbsp;答案的范围已知： 虽然事先并不知道确切的结果，但能预计到结果会落在哪个取值范围内。譬如说： ①求1-100之间所有的素数：&nbsp;无论结果如何，都在1-100的范围之内。 ②求2000－2015年间有几个月的13号是周日？这15年间共有180个月，月份的个数最多不会超过180 ③验证1000以内的哥德巴赫猜想：即找出1000之内所有的合数，看是否能够分解为两个质数之和。如果仔细观察，将会发现许多题目的结果范围都是已知的，都可以使用穷举法来实现。 2.&nbsp;答案的结果是离散的，不是连续的。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果要求出1－2之间所有的小数，就无法用穷举法来实现，因为其结果是无限连续的。 3.&nbsp;对时间上的要求不严格。 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;蓝桥杯比赛中的许多题目对于算法的设计是有时间要求的，有时会非常苛刻。如果用穷举法则耗时过长，不可取。例如求出21位的水仙花数，使用穷举法可能会花费30分钟的时间。而蓝桥杯试题通常要求时间限制在1秒钟之内完成，少数会延长至3分钟。在这种情况下，必须使用新的算法来解决问题。 &nbsp; &nbsp; &nbsp; &nbsp;下面举个经典的例子：100块砖100人来搬，男人一人搬4块，女人一人搬3块，小孩3人抬一块，问男，女，小孩各几人？ &nbsp; &nbsp; &nbsp; 分析：若设男，女，小孩人数分别为X，Y，Z，则只能够列出两个等式：&nbsp;X+Y+Z＝100，4X+3Y+Z/3＝100&nbsp;。三个未知数两个等式，无法求解。这就只能够使用穷举法来实现，具体做法如下： &nbsp; &nbsp; &nbsp; &nbsp;先确定每种类型人员的数量的取值范围，由题意可知，男人X的取值范围是0~100/4＝25&nbsp;女人Y的取值范围是0~100/3＝33&nbsp;小孩的取值范围是0~99（必须不大于100且为3的倍数）。使用穷举法遍历所有可能的取值结果，逐一判断筛选出正确的结果。编程如下： for(int&nbsp;x=0;&nbsp;x&lt;=25;&nbsp;x++) for(int&nbsp;y=0;&nbsp;y&lt;=33;&nbsp;y++) for(int&nbsp;z=0;&nbsp;z&lt;=99;&nbsp;z+=3) if((x+y+z==100)&amp;&amp;(4*x+3*y+z/3==100)) {输出找到的结果} &nbsp; &nbsp; &nbsp; &nbsp; 如果仔细分析一下，就会发现由于x+y+z==100，那么只需要考虑x和y的遍历取值；z值可以通过100－x&nbsp;-&nbsp;y来实现。当然，z值是3的倍数，上述代码可修改如下： for(int&nbsp;x=0;&nbsp;x&lt;=25;&nbsp;x++) for(int&nbsp;y=0;&nbsp;y&lt;=33;&nbsp;y++) {&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;z&nbsp;=&nbsp;100&nbsp;-&nbsp;x&nbsp;-&nbsp;y; if((z%3==0)&amp;&amp;(4*x+3*y+z/3==100)) {输出找到的结果} } &nbsp; &nbsp; &nbsp; &nbsp; 从这道题的解决过程中，我们可以发现使用穷举法的一般过程：确定需要哪几个变量，此题需要3个变量x，y，&nbsp;z&nbsp;&nbsp;如果是其它的题目，所需变量的个数与类型有可能不尽相同，这个要由具体情况而定。确定每个变量的取值范围，如上例之中X的范围是0~25，&nbsp;y的取值范围是0~33，&nbsp;z的取值范围是0~33。设置多层的嵌套循环，通常为for循环，最内层之中设置条件判断，满足输出条件时，输出相关的提示信息。 &nbsp; &nbsp; &nbsp; &nbsp;再来一道可以使用穷举法解决的问题：有一群海盗（不多于20人），在船上比拼酒量。过程如下：打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。再打开一瓶酒平分，又有倒下的，再次重复......&nbsp;直到开了第4瓶酒，坐着的已经所剩无几，海盗船长也在其中。当第4瓶酒平分喝下后，大家都倒下了。&nbsp;等船长醒来，发现海盗船搁浅了。他在航海日志中写到：“......昨天，我正好喝了一瓶.......奉劝大家，开船不喝酒，喝酒别开船......” &nbsp; &nbsp; &nbsp; &nbsp;请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人。&nbsp;如果有多个可能的答案，请列出所有答案，每个答案占一行。 &nbsp; &nbsp; &nbsp; &nbsp;格式是：人数,人数,... &nbsp; &nbsp; &nbsp; &nbsp;例如,有一种可能是：20,5,4,2,0 &nbsp; &nbsp; &nbsp; &nbsp;蓝桥杯中的许多题目都会提供一个答案的示例，通过分析这个示例可以加深对当前这道题的理解。以本题为例，通过研究示例答案可以看出如下的特点： （1）答案只可能有4个数，分别代表每轮参与的人数，最后的0是固定的。 （2）每轮的人数是不断减少的，下一轮只能够比上一轮人数更少。 （3）每轮人数被1除之后，累加和是1（刚好一瓶酒） 即&nbsp;1/20+1/5+1/4+1/2=1 根据上述的分析，可以确定如下的变量s1,&nbsp;s2,&nbsp;s3,&nbsp;s4分别代表每轮的人数。这四个变量的取值范围分别是1≤s1≤20,1≤s2≤s1,1≤s3≤s2,1≤s4≤s3 据此来设置4层的嵌套循环,并加上最内层的条件判断如下： for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++) if(1/s1+1/s2+1/s3+1/s4==1){输出结果}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;理论上来看是正确的，但实际运行时，由于/运算符在左右两边均为整数时，表示整除而不是除法，所以上述的条件判断需要改写为更复杂的形式： (s1*s2*s3+s1*s3*s4+s1*s3*s4+s2*s3*s4)/(s1*s2*s3*s4)==1 &nbsp; &nbsp; &nbsp; &nbsp;根据笔者指导蓝桥杯的经验，至少有三分之一的问题都可以通过穷举的方法来实现，因此，把穷举法练习使用好，意义非常重大。 &nbsp; 递归法 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;基于前面中介绍如何应用穷举法来解决具体的编程问题。穷举法最为常用，可以解决大部分常见的问题。现在再来介绍一种新的解题思路： 递归法它可以看成是对穷举法的一种补充。它的思路是在不方便穷举所有的可能时，通过设置特定的函数，在该函数内部反复地调用自身并输入不同的参数，以达到遍历所有可能性的目的。使用递归法代码量小，编码简单，逻辑清晰，不易出错。下面通过一个经典的例子来让大家感受下递归法的应用方法。 例1： 汉诺塔问题 汉诺塔问题是最经典的只能够使用递归的方法解决的问题 题目描述如下：据传说，在古代世界中心的贝拿勒斯（印度北部）的圣庙里，一块在黄铜板上插着3根宝石针。印度教的主神梵天在创造世界时，在其中的一根针上自下而上地穿好了由大至小的64层金片，即为汉诺塔。无论白天黑夜，总有一个僧侣按如下的法则移动这些金片，一次只能够移动一层，不管在哪根针上，小片必须在大片的上面。 要求借助于第二根针将整个汉诺塔移至第三根针上。&nbsp; 假设汉诺塔只有4层，其具体的移动过程如下动画所示： 本题具有如下的特点，使之不能使用穷举法： 1. 不便于穷举： 如果用数学的方法估算，假设一秒钟移动一片，将64层的汉诺塔移至另一根针上所需的步骤是个天文数字：共需接近5845亿年。 由于取值范围过大，且无法循环，不可能将所有的过程都穷举实现出来。 2. 可以经由一系列有限的步骤实现，其中的每个步骤都很相似，这道题为例，初始时有n层，第一大步就是将上面的n-1层移动至第三根针上，再将最下面的第n层移动至第二根针上，再将第三根针上的n-1层借助第一根针移动至第二根针上。在移动n-1层时，所使用的过程与移动n层是相同的，无非是初始针，目标针和辅助针和移动的层数不同而已。 只要满足这样的条件，都可以试着使用递归的方法来设计 过程如下： 定义函数 moveHanNoi（层数，初始针，辅助针，目标针） { if(层数＝＝1)&nbsp; {直接从初始针移动至目标针} else { moveHanNoi(层数－1，初始针，目标针，辅助针) &nbsp; //将（层数－1）层汉诺塔由初始针，利用目标针移至辅助针 直接从初始针移动第n层至目标针 moveHanNoi(层数－1，辅助针，初始针，目标针) &nbsp; //将（层数－1）层汉诺塔由辅助针，利用初始针移至目标针 } } 这样一来，只需要第一次输入初始人层数，初始针，辅助针，目标针的参数，即可得到结果。省却了复杂的循环遍历的麻烦。像这种在一个函数内部又调用自身，只是每次调用时传递参数不同的现象，称为递归。 下面再举两个例子来强化大家对于递归算法的认识： 例2： 给定一个正整数，输出它的阶乘。 数学中阶乘的定义就是从1开始逐步累乘自然数到当前的数，使用！来表示阶乘，如 1！ ＝ 1 2！ ＝ 1*2 3！＝1*2*3 4！ ＝ 1*2*3*4 …… 很快大家就会想到使用穷举法，确实，用穷举法能够非常直接地解决此问题，核心代码如下（C#） …… int sum =1; for(int i=1; i&lt;=n; i++) sum *= i; 输出sum的结果 再来仔细地分析阶乘的分解过程，很容易发现了如下的规律： 1！ ＝1 2！ ＝ 2*1！ ＝ 2 3！ ＝ 3*2！＝3*2*1！ ＝ 6 4！ ＝ 4*3！＝4*3*2！＝4*3*2*1！ ＝ 24 总结如下： 1的阶乘为1，其它任何数的阶乘等于n乘以（n-1）的阶乘。 这里为了求得n的阶乘，必须用同样的方法求得（n-1）的阶乘，再与当前数相乘得到结果。这与汉诺塔中的递归过程何其相似。设计递归的算法如下： 定义函数 &nbsp;jiecheng（int 当前数） 返回当前数的阶乘 { if（当前数 ＝＝ 1） 返回1； else 返回当前数与（当前数－1）阶乘的乘积 } 用C#语言实现如下： int jiecheng(int curNum) {return curNum==1?1:curNum*jiecheng(curNum-1);} 例3： 在8*8的国际象棋棋盘上，放置了8个皇后，使之不能相互攻击，找出所有满足条件的布局 分析：&nbsp; （1） 由于国际象棋中皇后的威力最大，横、竖、斜三个方向均可攻击。若想8个皇后和平共处，必须保证棋盘上横、竖、斜三个方向上最多只有一个皇后。 （2） 8*8的棋盘可以使用8*8的二维数组来表示，0代表空，1代表皇后，将此二维数组输出即可表示棋盘的状态。 （3） 以列为单位，自左至右依次地在每一列中由上到下放置皇后，每放置一个之后，看它是否与现有的皇后相冲突。若没有冲突，继续试探下一列。若有冲突，尝试摆放到下一行。最终当试探完最后一列且无冲突之后，输出结果。 设行号为0－7， 列号为0－7&nbsp;其执行过程如下： 定义函数 &nbsp; place(当前列号，棋盘) &nbsp; //表示试探棋盘上的某一列 { if（列号＝＝8） {输出当前棋盘的状态，返回；} 从第0行遍历至第7行，每次遍历时 { 1. 放置皇后，当前位置为1 2.观察是否与已有的皇后位置冲突 //可设置一个函数来进行判断 无冲突时： 试探下一列，调用自身place(当前列号+1，棋盘) 3. 撤消皇后所在的位置 } } 通过上面的例子，可以得出递归法的编程模式如下： 1. 尝试着做某种最基本的操作，该操作将会改变现有的状态 汉诺塔： 移动一层塔，导致初始针，辅助针，目标针的状态改变。 阶乘： 当前数乘以比它小一的数的阶乘，改变了累乘的结果。 八皇后： 放置一个皇后在棋盘格式里，当前棋盘的状态改变了。 2. 根据当前的状态，观察是否到了 不需要递归的时刻，如： 汉诺塔： 前n-1层已经移动至辅助针，直接将当前层移动至目标针，不需要递归。 阶乘： 当前数为1时，不需要递归，直接返回1 八皇后：0－7列全部试探完毕，不再递归 3.如果未到不必递归时，递归地调用自身，注意每次调用时的参数不同： 汉诺塔： 若当前n-1层未完全移至辅助针，需要递归调用自身，使用的参数“层数”，“初始针”，“目标针”，“辅助针”都会发生变化 阶乘： 当前数不为1时，递归调用阶乘本身，参数要变成“当前数－1”，返回值为当前数*下一阶乘数 4. 撤消当前的操作，状态还原（可选） 八皇后问题中，在某一列上放置了皇后，无论是否合适，都要在试探完毕之后撤走，再放置到下一位置。这个撤消的操作在迷宫类的题目中非常重要，否则无法得到所有的可能状态。但汉诺塔与阶乘问题中不需要状态还原。","@type":"BlogPosting","url":"https://mlh.app/2019/04/28/728534.html","headline":"算法学习之暴力穷举递归法","dateModified":"2019-04-28T00:00:00+08:00","datePublished":"2019-04-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/28/728534.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>算法学习之暴力穷举递归法</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="text-align: center;"><span style="font-size: 32px;font-weight: bold;">暴力法</span></p> 
<p style="text-align: justify;"><span style="font-size: 16px;">【例题1】：输入一个整数n，按从小到大的顺序输出所有形如abcde/fghij=n的表达式，其中a~j恰好为数字0~9的一个排列（可以有前导0），2&lt;=n&lt;=79。</span></p> 
<p><span style="font-size: 18px;color: rgb(255, 153, 0);">代码如下：</span></p> 
<p><span style="font-size: 18px;">#include &lt;cstdio&gt;</span></p> 
<p><span style="font-size: 18px;">#include &lt;cstring&gt;</span></p> 
<p><span style="font-size: 18px;">bool vis[10];//</span><span style="font-size: 18px;color: rgb(204, 51, 204);">【visit数组】用下标判断数字是否已经被访问过；</span></p> 
<p><span style="font-size: 18px;">char str[15];//</span><span style="font-size: 18px;color: rgb(204, 51, 204);">vis里的数字是按照0-9的顺序，str是按a和b给定的顺序</span></p> 
<p><span style="font-size: 18px;">bool check(int a, int b)</span></p> 
<p><span style="font-size: 18px;">{</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; sprintf(str, "%05d%05d", a, b);</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(204, 51, 204);">//【格式化字符串】int sprintf( char *buffer, const char *format [, argument] ... )。除了前两个参数类型固定外，后面可以接任意多个参数，这取决于第二个参数需要几个后继参数。而它的精华，显然就在第二个参数：【格式化字符串】上。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">&nbsp; &nbsp; memset(vis, 0, sizeof(vis));</span></p> 
<p style="text-align: justify;"><span style="text-align: left;font-size: 18px;color: rgb(204, 51, 204);">//【</span><span style="text-align: left;font-size: 18px;font-family: Arial;color: rgb(204, 51, 204);">memse】t：作用是在一段内存块中填充某个给定的值，它是对较大的</span><span style="text-align: left;font-size: 18px;font-family: Arial;color: rgb(0, 56, 132);">结构体</span><span style="text-align: left;font-size: 18px;font-family: Arial;color: rgb(204, 51, 204);">或</span><span style="text-align: left;font-size: 18px;font-family: Arial;color: rgb(0, 56, 132);">数组</span><span style="text-align: left;font-size: 18px;font-family: Arial;color: rgb(204, 51, 204);">进行【清零操作】的一种最快方法。</span><span style="text-align: left;font-size: 18px;color: rgb(204, 51, 204);">它有三个参数，一是所要set的首地址，二是set的值，三是set的字节数，vis肯定是个数组，因为数组在传参时能自动转成指向数组的首元素的指针，如果不是数组，应该写成memset(&amp;vis, 0, sizeof(vis));</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; for (int i = 0; i &lt; 10; i++)</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; {</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; if (vis[str[i]-'0']) &nbsp;return false;//如果已访问，返回false</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; vis[str[i]-'0'] = true;//未访问，改变该数字对应的访问数组的值</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; }</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; return true;</span></p> 
<p><span style="font-size: 18px;">&nbsp;}</span></p> 
<p><span style="font-size: 18px;">&nbsp;int main()</span></p> 
<p><span style="font-size: 18px;">&nbsp;{</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; int n;</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; bool first = true;</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; while (scanf("%d", &amp;n) &amp;&amp; n)</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; {</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; bool exist = false;</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; if (first) &nbsp;first = false;</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; else &nbsp;printf("\n");</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 1234; i &lt;= 98765; i++)</span></p> 
<p><span style="font-size: 18px;">&nbsp;{&nbsp;</span><span style="font-size: 18px;color: rgb(204, 51, 204);">//这里设abcde为A，fghij为B。没有必要枚举0~9的所有排列，只需枚举B就可以算出A，然后判断是否所有数字不相同即可。</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int ans;</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i % n == 0) //A可以整除n就说明这样的B存在，可以继续计算</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans = i / n;//计算出B；</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ans &lt; 1234) &nbsp;continue;//排除a&lt;1234的情况；</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (check(i, ans))//判断是否符合各个位不相同</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exist = true;</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%05d / %05d = %d\n", i, ans, n);//</span><span style="font-size: 18px;color: rgb(204, 51, 204);">不足n位前补0：【%0nd】</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; if (!exist) &nbsp;printf("There are no solutions for %d.\n", n);</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; }</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; return 0;</span></p> 
<p><span style="font-size: 18px;">&nbsp;}</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(51, 51, 255);font-weight: bold;">总结：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(51, 51, 255);font-weight: bold;">1.暴力求解法并非是一味的暴力，本题中两个数之间有整除关系，只需确定一个；再利用每个数字都不同来筛选；</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(51, 51, 255);font-weight: bold;">2.先找出满足整除条件的，然后筛掉不足1234的；</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(255, 0, 0);font-weight: bold;">3.不会的知识点主要集中在【判断两个字符串中是否有重复数字】：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(255, 0, 0);font-weight: bold;">（1）格式化：用sprintf把两个数字格式化成一个字符串；</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(255, 0, 0);font-weight: bold;">（2）memset函数的常用用法：对结构体或数组进行清零；</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(255, 0, 0);font-weight: bold;">（3）visit数组记录该数字是否被访问过，一旦visit[str-‘0’]的值被改编为true，即可返回false，排除这一组答案。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(51, 51, 255);font-weight: bold;">4.所谓的暴力并不是全暴力，要适当的节省时间空间，其中可能还穿插着一些小技巧。</span></p> 
<p><span style="font-size: 18px;"><br></span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">【例题2】：输入n个元素组成的序列S，你需要找出一个乘积最大的连续子序列。如果这个最大的乘积不是正数，应输出0（表示无解）。1&lt;=n&lt;=18,-10&lt;=Si&lt;=10。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(255, 102, 0);">分析：连续子序列---&gt;联想到两要素:起点和终点---&gt;只需枚举起点和终点。</span></p> 
<p><span style="font-size: 18px;color: rgb(255, 102, 0);">代码如下：</span></p> 
<p><span style="font-size: 18px;">#include&lt;iostream&gt;</span></p> 
<p><span style="font-size: 18px;">#include&lt;cstdio&gt;</span></p> 
<p><span style="font-size: 18px;">using namespace std;</span></p> 
<p><span style="font-size: 18px;">int main()</span></p> 
<p><span style="font-size: 18px;">{</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; int t,number,i,j,n,a[20];</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; long long ans,max1;</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; number=0;</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; while(scanf("%d",&amp;n)!=EOF)</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; {</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; for(i=1;i&lt;=n;i++)</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%d",&amp;a[i]);</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; max1=0;</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; for(i=1;i&lt;=n;i++)</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=a[i];</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(ans&gt;max1)</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max1=ans;</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(j=i+1;j&lt;=n;j++)</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans*=a[j];</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(ans&gt;max1) max1=ans;</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; printf("Case #%d: The maximum product is %lld.\n\n",++number,max1);</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; }</span></p> 
<p><span style="font-size: 18px;">&nbsp; &nbsp; return 0;</span></p> 
<p><span style="font-size: 18px;">}</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(51, 51, 255);font-weight: bold;">总结：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(51, 51, 255);font-weight: bold;">无论是求拥有连续最大和还是积的子序列，思想都是一样的。需要设定一个当前积ans，一个最大积max，第一重循环先固定第一个位置不动，把a[i]的值赋给ans，如果ans&gt;max，就改变max的值为ans的值（也就是说，如果在这里改变了max的值，最大子序列的第一个位置就要发生变化）。嵌套在其中的第二重循环用于确定末位置，ans=ans*a[j]，同样的，如果ans&gt;max，就改变max的值为ans的值。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(51, 51, 255);font-weight: bold;">如果还要添加功能，即记录最大子序列的起始位置和终止位置，则还需要两个变量start，end......</span></p> 
<p><span style="font-size: 18px;color: rgb(51, 51, 255);font-weight: bold;"></span></p> 
<p><span style="font-size:18px;"><br></span></p> 
<p style="text-align: justify;"><span style="font-size:18px;">【例题三】：<span style="color:rgb(54,46,43);font-family:Arial;line-height:26px;">给你一个数k，求所有使得1/k = 1/x + 1/y成立的x≥y的整数对。</span></span></p> 
<p style="font-family: Arial;line-height: 26px;text-align: justify;"><span style="color: rgb(204, 51, 204);font-size: 18px;">题目分析：数论，枚举。首先通过x&gt;=y这个条件化简已知条件，可以得出k+1&lt;=y&lt;=2*k，枚举所有在区间（k+1，2k）上的y即可。当1/k - 1/y（通分）的结果分子为1即为一组解。</span></p> 
<p style="color:rgb(54,46,43);font-family:Arial;line-height:26px;"><span style="font-size:18px;">代码如下：</span></p> 
<p style="color:rgb(54,46,43);font-family:Arial;line-height:26px;"><span style="font-size:18px;">#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>using namespace std;<br><br>int a[10011];<br>int b[10011];<br><br>int main()<br>{<br>&nbsp; &nbsp; int n;<br>&nbsp; &nbsp; while (scanf("%d",&amp;n))<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; int m = 2*n,count = 0;<br>&nbsp; &nbsp; &nbsp; &nbsp; for (int i = n+1 ; i &lt;= m ; ++ i)</span></p> 
<p style="color:rgb(54,46,43);font-family:Arial;line-height:26px;"><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; //这里用i代表变化的y：从n+1到2n<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i*n % (i-n) == 0)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a[count] = i*n/(i-n);</span></p> 
<p style="color:rgb(54,46,43);font-family:Arial;line-height:26px;"><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//一个分数的分母<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b[count] = i;//另一个分母<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count ++;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br><br><br>&nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n",count);<br>&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0 ; i &lt; count ; ++ i)<br>&nbsp; &nbsp; &nbsp; &nbsp; printf("1/%d = 1/%d + 1/%d\n",n,a[i],b[i]);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return 0;<br>}<br></span></p> 
<p style="font-family:Arial;line-height:26px;"><span style="font-size:18px;color:#cc33cc;">总结：思路很明了，关键是变量的表示要明确。</span></p> 
<p><span style="font-size: 18px;color: rgb(51, 51, 255);font-weight: bold;"><br></span></p> 
<p style="text-align: center;"><span style="font-weight: bold;font-size: 32px;">枚举法</span></p> 
<p style="text-align: justify;"><span style="font-weight: bold;"><span style="font-weight: 700;">&nbsp; &nbsp; &nbsp; </span><span style="font-weight: bold;font-size: 18px;color: rgb(255, 76, 0);"><span style="font-size: 18px;font-weight: 700;">&nbsp;</span><span style="font-weight: bold;font-size: 18px;color: rgb(2, 30, 170);"><span style="font-size: 18px;font-weight: 700;">枚举法</span>又称为<span style="font-size: 18px;font-weight: 700;">穷举法</span>，它是在计算机算法设计中用得最多的一种编程思想。它的实现方式是：在已知答案范围的情况下，依次地枚举该范围内所有的取值，并对每个取值进行考查，确定是否满足条件。经过循环遍历之后，筛选出符合要求的结果来。这种方法充分利用了计算机运算速度快的特点，思路简单直接，能够解决大部分的问题。</span></span></span></p> 
<p style="text-align: justify;">&nbsp; &nbsp; &nbsp; <span style="font-size: 20px;">&nbsp; 什么样的问题适合使用穷举法来解决呢？归纳起来，遇到了如下的三种情况，将优先考虑使用穷举法：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;"><strong><span style="color: rgb(2, 30, 170);">1.&nbsp;答案的范围已知：</span></strong></span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">虽然事先并不知道确切的结果，但能预计到结果会落在哪个取值范围内。譬如说：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">①求1-100之间所有的素数：&nbsp;无论结果如何，都在1-100的范围之内。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">②求2000－2015年间有几个月的13号是周日？这15年间共有180个月，月份的个数最多不会超过180</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">③验证1000以内的哥德巴赫猜想：即找出1000之内所有的合数，看是否能够分解为两个质数之和。如果仔细观察，将会发现许多题目的结果范围都是已知的，都可以使用穷举法来实现。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;"><strong><span style="color: rgb(2, 30, 170);">2.&nbsp;答案的结果是离散的，不是连续的。</span></strong></span></p> 
<p style="text-align: justify;">&nbsp; &nbsp; &nbsp; &nbsp;<span style="font-size: 18px;">&nbsp;如果要求出1－2之间所有的小数，就无法用穷举法来实现，因为其结果是无限连续的。</span></p> 
<p style="text-align: justify;"><span style="color: rgb(2, 30, 170);font-size: 18px;"><strong>3.&nbsp;对时间上的要求不严格。</strong></span></p> 
<p style="text-align: justify;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="font-size: 18px;">蓝桥杯比赛中的许多题目对于算法的设计是有时间要求的，有时会非常苛刻。如果用穷举法则耗时过长，不可取。例如求出21位的水仙花数，使用穷举法可能会花费30分钟的时间。而蓝桥杯试题通常要求时间限制在1秒钟之内完成，少数会延长至3分钟。在这种情况下，必须使用新的算法来解决问题。</span></p> 
<p style="text-align: justify;">&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: rgb(0, 0, 0);"><strong><span style="font-size: 18px;">下面举个经典的例子：100块砖100人来搬，男人一人搬4块，女人一人搬3块，小孩3人抬一块，问男，女，小孩各几人？</span></strong></span></p> 
<p style="text-align: justify;">&nbsp; &nbsp; &nbsp; <span style="color: rgb(172, 57, 255);">分析：若设男，女，小孩人数分别为X，Y，Z，则只能够列出两个等式：&nbsp;X+Y+Z＝100，4X+3Y+Z/3＝100&nbsp;。三个未知数两个等式，无法求解。这就只能够使用穷举法来实现，具体做法如下：</span></p> 
<p style="text-align: justify;"><strong><span style="color: rgb(255, 76, 0);">&nbsp; &nbsp; &nbsp; <span style="color: rgb(172, 57, 255);">&nbsp;</span></span></strong><span style="color: rgb(255, 76, 0);"><span style="color: rgb(172, 57, 255);">先确定每种类型人员的数量的取值范围，由题意可知，男人X的取值范围是0~100/4＝25&nbsp;女人Y的取值范围是0~100/3＝33&nbsp;小孩的取值范围是0~99（必须不大于100且为3的倍数）。使用穷举法遍历所有可能的取值结果，逐一判断筛选出正确的结果。编程如下：</span></span></p> 
<p style="text-align: justify;">for(int&nbsp;x=0;&nbsp;x&lt;=25;&nbsp;x++)</p> 
<p style="text-align: justify;">for(int&nbsp;y=0;&nbsp;y&lt;=33;&nbsp;y++)</p> 
<p style="text-align: justify;">for(int&nbsp;z=0;&nbsp;z&lt;=99;&nbsp;z+=3)</p> 
<p style="text-align: justify;">if((x+y+z==100)&amp;&amp;(4*x+3*y+z/3==100)) {输出找到的结果}</p> 
<p style="text-align: justify;"><span style="color: rgb(172, 57, 255);">&nbsp; &nbsp; &nbsp; &nbsp; 如果仔细分析一下，就会发现由于x+y+z==100，那么只需要考虑x和y的遍历取值；z值可以通过100－x&nbsp;-&nbsp;y来实现。当然，z值是3的倍数，上述代码可修改如下：</span></p> 
<p style="text-align: justify;">for(int&nbsp;x=0;&nbsp;x&lt;=25;&nbsp;x++)</p> 
<p style="text-align: justify;">for(int&nbsp;y=0;&nbsp;y&lt;=33;&nbsp;y++)</p> 
<p style="text-align: justify;">{&nbsp;&nbsp;&nbsp;&nbsp;</p> 
<p style="text-align: justify;">int&nbsp;z&nbsp;=&nbsp;100&nbsp;-&nbsp;x&nbsp;-&nbsp;y;</p> 
<p style="text-align: justify;">if((z%3==0)&amp;&amp;(4*x+3*y+z/3==100)) {输出找到的结果}</p> 
<p style="text-align: justify;">}</p> 
<p style="text-align: justify;">&nbsp; &nbsp; &nbsp; &nbsp;<strong><span style="color: rgb(255, 76, 0);font-size: 18px;"> 从这道题的解决过程中，我们可以发现使用穷举法的一般过程：确定需要哪几个变量，此题需要3个变量x，y，&nbsp;z&nbsp;&nbsp;如果是其它的题目，所需变量的个数与类型有可能不尽相同，这个要由具体情况而定。确定每个变量的取值范围，如上例之中X的范围是0~25，&nbsp;y的取值范围是0~33，&nbsp;z的取值范围是0~33。设置多层的嵌套循环，通常为for循环，最内层之中设置条件判断，满足输出条件时，输出相关的提示信息。</span></strong></p> 
<p style="text-align: justify;"><br></p> 
<p style="text-align: justify;">&nbsp; &nbsp; &nbsp; &nbsp;<span style="font-size: 18px;">再来一道可以使用穷举法解决的问题：有一群海盗（不多于20人），在船上比拼酒量。过程如下：打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。再打开一瓶酒平分，又有倒下的，再次重复......&nbsp;直到开了第4瓶酒，坐着的已经所剩无几，海盗船长也在其中。当第4瓶酒平分喝下后，大家都倒下了。&nbsp;等船长醒来，发现海盗船搁浅了。他在航海日志中写到：“......昨天，我正好喝了一瓶.......奉劝大家，开船不喝酒，喝酒别开船......”</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp;请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人。&nbsp;如果有多个可能的答案，请列出所有答案，每个答案占一行。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp;格式是：人数,人数,...</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp;例如,有一种可能是：20,5,4,2,0</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; <span style="font-size: 18px;color: rgb(172, 57, 255);">&nbsp;蓝桥杯中的许多题目都会提供一个答案的示例，通过分析这个示例可以加深对当前这道题的理解。以本题为例，通过研究示例答案可以看出如下的特点：</span></span></p> 
<p style="text-align: justify;"><span style="color: rgb(172, 57, 255);font-size: 18px;">（1）答案只可能有4个数，分别代表每轮参与的人数，最后的0是固定的。</span></p> 
<p style="text-align: justify;"><span style="color: rgb(172, 57, 255);font-size: 18px;">（2）每轮的人数是不断减少的，下一轮只能够比上一轮人数更少。</span></p> 
<p style="text-align: justify;"><span style="color: rgb(172, 57, 255);font-size: 18px;">（3）每轮人数被1除之后，累加和是1（刚好一瓶酒）</span></p> 
<p style="text-align: justify;"><span style="color: rgb(172, 57, 255);font-size: 18px;">即&nbsp;1/20+1/5+1/4+1/2=1</span></p> 
<p style="text-align: justify;"><span style="color: rgb(172, 57, 255);font-size: 18px;">根据上述的分析，可以确定如下的变量s1,&nbsp;s2,&nbsp;s3,&nbsp;s4分别代表每轮的人数。这四个变量的取值范围分别是1≤s1≤20,1≤s2≤s1,1≤s3≤s2,1≤s4≤s3 据此来设置4层的嵌套循环,并加上最内层的条件判断如下：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++)</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++)</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++)</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">for(int&nbsp;s1=1;&nbsp;s1&lt;=20;&nbsp;s1++)</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">if(1/s1+1/s2+1/s3+1/s4==1){输出结果}&nbsp;</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp;理论上来看是正确的，但实际运行时，由于/运算符在左右两边均为整数时，表示整除而不是除法，所以上述的条件判断需要改写为更复杂的形式：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">(s1*s2*s3+s1*s3*s4+s1*s3*s4+s2*s3*s4)/(s1*s2*s3*s4)==1</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp;根据笔者指导蓝桥杯的经验，至少有三分之一的问题都可以通过穷举的方法来实现，因此，把穷举法练习使用好，意义非常重大。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">&nbsp;</span></p> 
<p style="text-align: center;"><span style="font-weight: bold;font-size: 32px;">递归法</span></p> 
<p style="text-align: left;text-indent: 0em;"><br></p> 
<p style="text-align: justify;">&nbsp; &nbsp; &nbsp; <span style="font-size: 18px;">&nbsp;&nbsp;<span style="font-size: 18px;color: rgb(2, 30, 170);">基于前面中介绍如何应用穷举法来解决具体的编程问题。穷举法最为常用，可以解决大部分常见的问题。现在再来介绍一种新的解题思路： 递归法它可以看成是对穷举法的一种补充。它的思路是在不方便穷举所有的可能时，通过设置特定的函数，在该函数内部反复地调用自身并输入不同的参数，以达到遍历所有可能性的目的。使用递归法代码量小，编码简单，逻辑清晰，不易出错。下面通过一个经典的例子来让大家感受下递归法的应用方法。</span></span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">例1： 汉诺塔问题</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">汉诺塔问题是最经典的只能够使用递归的方法解决的问题</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">题目描述如下：据传说，在古代世界中心的贝拿勒斯（印度北部）的圣庙里，一块在黄铜板上插着3根宝石针。印度教的主神梵天在创造世界时，在其中的一根针上自下而上地穿好了由大至小的64层金片，即为汉诺塔。无论白天黑夜，总有一个僧侣按如下的法则移动这些金片，一次只能够移动一层，不管在哪根针上，小片必须在大片的上面。 要求借助于第二根针将整个汉诺塔移至第三根针上。&nbsp;</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">假设汉诺塔只有4层，其具体的移动过程如下动画所示：</span></p> 
<p style="text-align: justify;"><br></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(172, 57, 255);">本题具有如下的特点，使之不能使用穷举法：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(172, 57, 255);">1. 不便于穷举： 如果用数学的方法估算，假设一秒钟移动一片，将64层的汉诺塔移至另一根针上所需的步骤是个天文数字：共需接近5845亿年。 由于取值范围过大，且无法循环，不可能将所有的过程都穷举实现出来。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(172, 57, 255);">2. 可以经由一系列有限的步骤实现，其中的每个步骤都很相似，这道题为例，初始时有n层，第一大步就是将上面的n-1层移动至第三根针上，再将最下面的第n层移动至第二根针上，再将第三根针上的n-1层借助第一根针移动至第二根针上。在移动n-1层时，所使用的过程与移动n层是相同的，无非是初始针，目标针和辅助针和移动的层数不同而已。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(172, 57, 255);">只要满足这样的条件，都可以试着使用递归的方法来设计</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">过程如下：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">定义函数 moveHanNoi（层数，初始针，辅助针，目标针）</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">{</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">if(层数＝＝1)&nbsp;</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">{直接从初始针移动至目标针}</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">else</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">{</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">moveHanNoi(层数－1，初始针，目标针，辅助针) &nbsp; //将（层数－1）层汉诺塔由初始针，利用目标针移至辅助针</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">直接从初始针移动第n层至目标针</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">moveHanNoi(层数－1，辅助针，初始针，目标针) &nbsp; //将（层数－1）层汉诺塔由辅助针，利用初始针移至目标针</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">}</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">}</span></p> 
<p style="text-align: justify;"><br></p> 
<p style="text-align: justify;"><span style="color: rgb(255, 76, 0);"><strong><span style="font-size: 18px;">这样一来，只需要第一次输入初始人层数，初始针，辅助针，目标针的参数，即可得到结果。省却了复杂的循环遍历的麻烦。</span></strong></span><strong style="color: rgb(255, 76, 0);"><span style="font-size: 18px;">像这种在一个函数内部又调用自身，只是每次调用时传递参数不同的现象，称为递归。</span></strong></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">下面再举两个例子来强化大家对于递归算法的认识：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">例2： 给定一个正整数，输出它的阶乘。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">数学中阶乘的定义就是从1开始逐步累乘自然数到当前的数，使用！来表示阶乘，如</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">1！ ＝ 1</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">2！ ＝ 1*2</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">3！＝1*2*3</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">4！ ＝ 1*2*3*4</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">……</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(172, 57, 255);">很快大家就会想到使用穷举法，确实，用穷举法能够非常直接地解决此问题，核心代码如下（C#）</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(172, 57, 255);">……</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">int sum =1;</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">for(int i=1; i&lt;=n; i++)</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">sum *= i;</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">输出sum的结果</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">再来仔细地分析阶乘的分解过程，很容易发现了如下的规律：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">1！ ＝1</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">2！ ＝ 2*1！ ＝ 2</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">3！ ＝ 3*2！＝3*2*1！ ＝ 6</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">4！ ＝ 4*3！＝4*3*2！＝4*3*2*1！ ＝ 24</span></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">总结如下： 1的阶乘为1，其它任何数的阶乘等于n乘以（n-1）的阶乘。 这里为了求得n的阶乘，必须用同样的方法求得（n-1）的阶乘，再与当前数相乘得到结果。这与汉诺塔中的递归过程何其相似。设计递归的算法如下：</span></strong></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">定义函数 &nbsp;jiecheng（int 当前数） 返回当前数的阶乘</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">{</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">if（当前数 ＝＝ 1） 返回1；</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">else 返回当前数与（当前数－1）阶乘的乘积</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">}</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">用C#语言实现如下：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">int jiecheng(int curNum)</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">{return curNum==1?1:curNum*jiecheng(curNum-1);}</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;"><br></span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">例3： 在8*8的国际象棋棋盘上，放置了8个皇后，使之不能相互攻击，找出所有满足条件的布局</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(172, 57, 255);">分析：&nbsp;</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(172, 57, 255);">（1） 由于国际象棋中皇后的威力最大，横、竖、斜三个方向均可攻击。若想8个皇后和平共处，必须保证棋盘上横、竖、斜三个方向上最多只有一个皇后。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(172, 57, 255);">（2） 8*8的棋盘可以使用8*8的二维数组来表示，0代表空，1代表皇后，将此二维数组输出即可表示棋盘的状态。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;color: rgb(172, 57, 255);">（3） 以列为单位，自左至右依次地在每一列中由上到下放置皇后，每放置一个之后，看它是否与现有的皇后相冲突。若没有冲突，继续试探下一列。若有冲突，尝试摆放到下一行。最终当试探完最后一列且无冲突之后，输出结果</span><span style="font-size: 18px;">。</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">设行号为0－7， 列号为0－7&nbsp;其执行过程如下：</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">定义函数 &nbsp; place(当前列号，棋盘) &nbsp; //表示试探棋盘上的某一列</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">{</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">if（列号＝＝8）</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">{输出当前棋盘的状态，返回；}</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">从第0行遍历至第7行，每次遍历时</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">{</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">1. 放置皇后，当前位置为1</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">2.观察是否与已有的皇后位置冲突 //可设置一个函数来进行判断</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">无冲突时： 试探下一列，调用自身place(当前列号+1，棋盘)</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">3. 撤消皇后所在的位置</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">}</span></p> 
<p style="text-align: justify;"><span style="font-size: 18px;">}</span></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">通过上面的例子，可以得出递归法的编程模式如下：</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">1. 尝试着做某种最基本的操作，该操作将会改变现有的状态</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">汉诺塔： 移动一层塔，导致初始针，辅助针，目标针的状态改变。</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">阶乘： 当前数乘以比它小一的数的阶乘，改变了累乘的结果。</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">八皇后： 放置一个皇后在棋盘格式里，当前棋盘的状态改变了。</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">2. 根据当前的状态，观察是否到了 不需要递归的时刻，如：</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">汉诺塔： 前n-1层已经移动至辅助针，直接将当前层移动至目标针，不需要递归。</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">阶乘： 当前数为1时，不需要递归，直接返回1</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">八皇后：0－7列全部试探完毕，不再递归</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">3.如果未到不必递归时，递归地调用自身，注意每次调用时的参数不同：</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">汉诺塔： 若当前n-1层未完全移</span></strong><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">至辅助针，需要递归调用自身，使用的参数“层数”，“初始针”，“目标针”，“辅助针”都会发生变化</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">阶乘： 当前数不为1时，递归调用阶乘本身，参数要变成“当前数－1”，返回值为当前数*下一阶乘数</span></strong></p> 
<p style="text-align: justify;"><strong><span style="font-size: 18px;color: rgb(255, 76, 0);">4. 撤消当前的操作，状态还原（可选）</span></strong></p> 
<p style="text-align: justify;"><strong><span style="color: rgb(255, 76, 0);"><span style="color: rgb(255, 76, 0);font-size: 18px;">八皇后问题中，在某一列上放置了皇后，无论是否合适，都要在试探完毕之后撤走，再放置到下一位置。这个撤消的操作在迷宫类的题目中非常重要，否则无法得到所有的可能状态</span>。但汉诺塔与阶乘问题中不需要状态还原。</span></strong></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
