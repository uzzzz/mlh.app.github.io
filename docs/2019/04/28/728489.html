<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>程序员如何掌握 React 开发的黄金法则？ 技术头条 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="程序员如何掌握 React 开发的黄金法则？ 技术头条" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文有关 React 的“黄金法则”只是以一个新的角度，对展示组件和容器组件的现有概念的重新阐述。 作者 |&nbsp;Rico Kahler 译者 | 苏本如 责编 | 屠敏 出品 | CSDN（ID：CSDNnews） 以下为译文： 最近，我在开发组件时采用了一种新的思路。这不一定是一种全新的想法，而是对原有思维方式的一种微妙调整。这种新的思路就是： 组件开发的黄金法则 以最自然的方式创建和定义组件，只需要考虑它们需要什么去实现功能。 再次澄清，这是对原有思维方式的一种微妙调整，你可能认为你已经遵循了它，但违背它也很容易。 举个例子，假设你有如下的PersonCard组件： 如果你想“自然地”定义这个组件，那么你可能会写出下面的API： PersonCard.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;name:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;jobTitle:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;pictureUrl:&nbsp;PropTypes.string.isRequired,}; “自然的” PersonCard API 看上去非常直接，我们看看PersonCard这个组件需要什么属性就可以工作。这里，PersonCard组件只需要名称，职务和照片URL。 但假如你需要实现“根据用户的设置，决定是否显示正式照片”的功能。你就可能会尝试编写这样的API： PersonCard.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;name:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;jobTitle:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;officialPictureUrl:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;pictureUrl:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;preferOfficial:&nbsp;PropTypes.boolean.isRequired,}; 复杂化的PersonCard API 看起来似乎这个复杂化的组件需要那些额外的props来实现它的功能，但实际上，上面的组件看起来并没有什么不同，也不需要那些额外的props。这些额外的属性所做的是将这个preferOfficial设置与组件结合起来，但这样做会导致在其它场合（例如：不需要显示正式照片的场合）使用这个组件感到非常“不自然”。 容器的作用 那么，如果“决定显示哪个照片URL”的逻辑不属于这个组件本身，它应该属于哪里？ 如果用一个index文件来替代怎么样？ 我们采用了一种文件夹结构，其中每个组件都放在一个自命名的文件夹，index文件负责在你的“自然组件”和外部世界之间牵线搭桥。我们称此文件为“容器”（灵感来自于 React Redux的容器组件概念：https://redux.js.org/basics/usage-with-react#presentational-and-container-components）。 /PersonCard&nbsp;&nbsp;-PersonCard.js&nbsp;------&nbsp;the&nbsp;&quot;natural&quot;&nbsp;component&nbsp;&nbsp;-index.js&nbsp;-----------&nbsp;the&nbsp;&quot;container&quot; 容器：我们将容器定义为插入在你的自然组件和外部世界之间（负责连接这两部分）的一小段代码。因为这个原因，有时候我们也把这些“容器”叫做“injector （注入器）”。 自然组件：如果你被要求一张照片，你的“自然组件”就是这些用来显示这张照片的代码，你不需要知道如何获得数据的细节，也不需要知道它在应用程序中的位置，所有你需要知道的是它应该起作用。 外部世界：这里指的是你的应用程序所拥有的任何资源（例如Redux Store），而这些资源是可以被转换以满足你的自然组件的props。 本文的目标：我们如何编写“自然的”组件并确保它不会被来自外部世界的垃圾污染？为什么这样做更好？ 备注：本文中的“容器”概念虽然是受到这两个链接（Dan Abramov和React Redux）中的术语的启发，但是本文中的“容器”定义略有不同。 Dan Abramov的容器和本文中容器的唯一区别是在概念层面上。Dan在文章中说有两种组件：展示组件和容器组件。而本文我们更进一步，把它区分为组件和容器。 即使我们使用组件实现容器，我们也不会在概念层面将容器视为组件。这就是为什么我们建议将容器放在index文件中的原因，因为它是你的自然组件和外部世界之间的桥梁，并不是独立的。 你可能发现，本文的重点是关注组件，然而容器却占据了大半篇幅。为什么呢 这是因为：编写自然组件更容易，更有趣。而让你的组件连接到外部世界（容器的工作）有点难度。 依我看，导致你的“自然组件”被外部世界的垃圾污染的主要原因有三个： 奇怪的数据结构 超出组件范围的要求（如上例） 在组件挂载或更新时的事件触发 接下来，我将尝试用不同类型容器的实现示例，对上述三种情形进行阐述。 使用奇怪的数据结构 有时候为了渲染所需要的信息，需要将不同类型的数据链接在一起，并将其转换成为更合理的格式。因为没有更合适的词，所以这里我用了“奇怪的”这个词。“奇怪的数据结构”就是那种让你的组件使用起来“不自然”的数据结构。 将“奇怪的”数据结构直接传递到组件中，并在组件内部进行转换是非常诱人的，但这会导致混乱，并且常常使得组件测试很难进行。 最近，当我被分配去创建一个组件，并从我们用来支持一个特定类型表单的特定数据结构中获取数据时，我发现自己落入了这个陷阱（示例如下）。 ChipField.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;field:&nbsp;PropTypes.object.isRequired,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&lt;--&nbsp;the&nbsp;&quot;weird&quot;&nbsp;data&nbsp;structure&nbsp;&nbsp;onEditField:&nbsp;PropTypes.func.isRequired,&nbsp;&nbsp;//&nbsp;&lt;--&nbsp;and&nbsp;a&nbsp;weird&nbsp;event&nbsp;too}; 这个组件将这个奇怪的数据结构field作为一个props。事实上，如果我们后面不再用到这个组件的话，这样做是可以接受的。但是后来这个组件在一个与这个奇怪的数据结构无关的地方又用到了，这样它就成了一个真正的问题。 因为组件需要这个数据结构，所以重用它变得不可能，重构它也很困难。我们最初编写的测试程序也令人困惑，因为模拟了这种奇怪的数据结构。我们无法理解这些测试程序，并且在最终重构时无法重新编写它们。 不幸的是，奇怪的数据结构是不可避免的，但是使用容器是处理它们的一种很好的方法。我从这个例子学到的一点是，以这种方式构建组件，让你可以选择对组件进行提取，并将其转变为可重用的组件。但是如果你将一个奇怪的数据结构传递到一个组件中，你将失去这个选择。 注意：我并不是建议你所写的所有组件从一开始就应该是通用的。而是建议你想一想你的组件从根本上讲要实现什么，然后弥合间隙。如果你这样做了，您就会选择将你的组件转变为可重用的组件，这种转变需要的工作量很小。 使用函数组件实现容器 如果严格映射props，一个简单的实现方式是使用函数组件： import&nbsp;React&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;getValuesFromField&nbsp;from&nbsp;&#39;./helpers/getValuesFromField&#39;;import&nbsp;transformValuesToField&nbsp;from&nbsp;&#39;./helpers/transformValuesToField&#39;;import&nbsp;ChipField&nbsp;from&nbsp;&#39;./ChipField&#39;;export&nbsp;default&nbsp;function&nbsp;ChipFieldContainer({&nbsp;field,&nbsp;onEditField&nbsp;})&nbsp;{&nbsp;&nbsp;const&nbsp;values&nbsp;=&nbsp;getValuesFromField(field);&nbsp;&nbsp;function&nbsp;handleOnChange(values)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;onEditField(transformValuesToField(values));&nbsp;&nbsp;}&nbsp;&nbsp;return&nbsp;&lt;ChipField&nbsp;values={values}&nbsp;onChange={handleOnChange}&nbsp;/&gt;;}//&nbsp;external&nbsp;propsChipFieldContainer.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;field:&nbsp;PropTypes.object.isRequired,&nbsp;&nbsp;onEditField:&nbsp;PropTypes.func.isRequired,}; 组件的文件夹结构像下面这样： /ChipField&nbsp;&nbsp;-ChipField.js&nbsp;------------------&nbsp;the&nbsp;&quot;natural&quot;&nbsp;chip&nbsp;field&nbsp;&nbsp;-ChipField.test.js&nbsp;&nbsp;-index.js&nbsp;----------------------&nbsp;the&nbsp;&quot;container&quot;&nbsp;&nbsp;-index.test.js&nbsp;&nbsp;/helpers&nbsp;-----------------------&nbsp;a&nbsp;folder&nbsp;for&nbsp;the&nbsp;helpers/utils&nbsp;&nbsp;&nbsp;&nbsp;-getValuesFromField.js&nbsp;&nbsp;&nbsp;&nbsp;-getValuesFromField.test.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValuesToField.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValuesToField.test.js 你可能在想“这种实现方式的要做的工作太多了”。你有这种想法很正常。是的，这里看起来要做的工作是多了，因为需要维护更多的文件，而且看上去也不那么直观。但是你可能忽视了一点： 其实真正的工作量并没有增加，不管你是在组件外部或者是在组件内部转换数据，需要的工作量其实都是一样的。区别只是在于，当你把数据转换放在组件外进行时，你就能够更准确地测试出你的数据转换是否正确，同时也分离了关注点。 组件之外实现需求 对于上面提到的PersonCard的示例，当你将组件开发的“黄金法则”应用其上时，你很可能会意识到某些需求超出了实际组件的范围。那么这些需求如何实现呢？ 你应该猜到了答案：对，使用容器。 你可以通过创建容器来做一些额外的工作来保持组件的自然性。当你这样做的时候，你最终会得到一个更加简单而且功能单一的组件，和一个更好测试的容器。 让我们用一个PersonCard容器的实现来举例说明。 使用高阶组件实现容器 React Redux使用高阶组件来实现从Redux Store推送和映射props的容器。因为“容器”这个术语是从React Redux得到来的，所以毫不奇怪，React Redux的connect就是一个容器。 无论你是使用函数组件来映射props， 还是使用高阶组件connect到Redux Store，其中的黄金法则和容器的作用都是相同的。首先，编写你的自然组件，然后使用高阶组件来弥合间隙。 import&nbsp;{&nbsp;connect&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;getPictureUrl&nbsp;from&nbsp;&#39;./helpers/getPictureUrl&#39;;import&nbsp;PersonCard&nbsp;from&nbsp;&#39;./PersonCard&#39;;const&nbsp;mapStateToProps&nbsp;=&nbsp;(state,&nbsp;ownProps)&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;const&nbsp;{&nbsp;person&nbsp;}&nbsp;=&nbsp;ownProps;&nbsp;&nbsp;const&nbsp;{&nbsp;name,&nbsp;jobTitle,&nbsp;customPictureUrl,&nbsp;officialPictureUrl&nbsp;}&nbsp;=&nbsp;person;&nbsp;&nbsp;const&nbsp;{&nbsp;preferOfficial&nbsp;}&nbsp;=&nbsp;state.settings;&nbsp;&nbsp;const&nbsp;pictureUrl&nbsp;=&nbsp;getPictureUrl(preferOfficial,&nbsp;customPictureUrl,&nbsp;officialPictureUrl);&nbsp;&nbsp;return&nbsp;{&nbsp;name,&nbsp;jobTitle,&nbsp;pictureUrl&nbsp;};};const&nbsp;mapDispatchToProps&nbsp;=&nbsp;null;export&nbsp;default&nbsp;connect(&nbsp;&nbsp;mapStateToProps,&nbsp;&nbsp;mapDispatchToProps,)(PersonCard); 使用高阶组件的容器实现 上述实现的文件夹结构如下： /PersonCard&nbsp;&nbsp;-PersonCard.js&nbsp;-----------------&nbsp;natural&nbsp;component&nbsp;&nbsp;-PersonCard.test.js&nbsp;&nbsp;-index.js&nbsp;----------------------&nbsp;container&nbsp;&nbsp;-index.test.js&nbsp;&nbsp;/helpers&nbsp;&nbsp;&nbsp;&nbsp;-getPictureUrl.js&nbsp;------------&nbsp;helper&nbsp;&nbsp;&nbsp;&nbsp;-getPictureUrl.test.js 注意：在这个示例中，/helpers文件夹里只有一个getPictureURL，真实情况应该还有其它helpers，这里只是演示你可以把这个逻辑分离出来。您还可能注意到，无论对于哪种容器实现，文件夹结构其实都是一样的。 如果你有Redux的使用经验，你可能已经熟悉上面的示例。这里再重复一次，黄金法则不是一种全新的想法，而是对原有思维方式的一种微妙调整。 此外，在你用高阶组件实现容器时，你还可以在功能上将高阶组件组合在一起，亦即你可以将props从一个高阶组件传递到下一个。在过去，我们曾经将多个高阶组件链接在一起，来实现单个容器。 备注：React社区似乎有正在远离高阶组件的趋势。 我也会推荐同这样做。我从使用高阶组件得来的经验是，对于不熟悉函数组件的团队成员来说，它们可能会令人困惑，并且会导致所谓的“封装地狱”，即组件被封装太多次，从而导致严重的性能问题。 这里我列出一些相关的文章和资源供参考： Hooks talk (2018) ：https://youtu.be/dpw9EHDh2bM?t=710 Recompose talk (2016) ：https://youtu.be/zD_judE-bXk?t=1101 Use a Render Prop! (2017)：https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce When to NOT use Render Props (2018)：https://blog.kentcdodds.com/when-to-not-use-render-props-5397bbeff746 好了，到了我们谈谈React Hooks(钩子)的时候了。 使用hooks实现容器 你可能问为什么本文要讨论Hooks, 原因是使用Hooks来实现容器要容易得多。 如果你还不熟悉React Hooks，那么我建议你观看Dan Abramov和Ryan Florence在React 2018大会上的演讲视频，视频中有React Hooks的概念介绍（https://youtu.be/dpw9EHDh2bM）。 简而言之，React团队引入Hooks是为了应对高阶组件以及类似的模式带来的问题。React Hooks旨在替代它们，成为大多数场景下的最佳解决方案。 这意味着我们可以通过使用一个函数组件和Hooks来实现容器。 在下面的示例中，我们使用了useRoute和useRedux这两个Hooks来表示“外部世界”，我们使用getValues这个helper将“外部世界”映射为你的自然组件可用的props。我们还使用transformValues这个helper将组件的输出转换为由dispatch表示的外部世界。 import&nbsp;React&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;{&nbsp;useRouter&nbsp;}&nbsp;from&nbsp;&#39;react-router&#39;;import&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;actionCreator&nbsp;from&nbsp;&#39;your-redux-stuff&#39;;import&nbsp;getValues&nbsp;from&nbsp;&#39;./helpers/getVaules&#39;;import&nbsp;transformValues&nbsp;from&nbsp;&#39;./helpers/transformValues&#39;;import&nbsp;FooComponent&nbsp;from&nbsp;&#39;./FooComponent&#39;;export&nbsp;default&nbsp;function&nbsp;FooComponentContainer(props)&nbsp;{&nbsp;&nbsp;//&nbsp;hooks&nbsp;&nbsp;const&nbsp;{&nbsp;match&nbsp;}&nbsp;=&nbsp;useRouter({&nbsp;path:&nbsp;/*&nbsp;...&nbsp;*/&nbsp;});&nbsp;&nbsp;//&nbsp;NOTE:&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won&#39;t&nbsp;look&nbsp;like&nbsp;this&nbsp;&nbsp;const&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();&nbsp;&nbsp;//&nbsp;mapping&nbsp;&nbsp;const&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);&nbsp;&nbsp;function&nbsp;handleChange(e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;transformed&nbsp;=&nbsp;transformValues(e);&nbsp;&nbsp;&nbsp;&nbsp;dispatch(actionCreator(transformed));&nbsp;&nbsp;}&nbsp;&nbsp;//&nbsp;natural&nbsp;component&nbsp;&nbsp;return&nbsp;&lt;FooComponent&nbsp;{...props}&nbsp;onChange={handleChange}&nbsp;/&gt;;}FooComponentContainer.propTypes&nbsp;=&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}; 使用hooks来实现容器 参考文件夹结构如下： /FooComponent&nbsp;-----------&nbsp;the&nbsp;whole&nbsp;component&nbsp;for&nbsp;others&nbsp;to&nbsp;import&nbsp;&nbsp;-FooComponent.js&nbsp;------&nbsp;the&nbsp;&quot;natural&quot;&nbsp;part&nbsp;of&nbsp;the&nbsp;component&nbsp;&nbsp;-FooComponent.test.js&nbsp;&nbsp;-index.js&nbsp;-------------&nbsp;the&nbsp;&quot;container&quot;&nbsp;that&nbsp;bridges&nbsp;the&nbsp;gap&nbsp;&nbsp;-index.js.test.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;provides&nbsp;dependencies&nbsp;&nbsp;/helpers&nbsp;--------------&nbsp;isolated&nbsp;helpers&nbsp;that&nbsp;you&nbsp;can&nbsp;test&nbsp;easily&nbsp;&nbsp;&nbsp;&nbsp;-getValues.js&nbsp;&nbsp;&nbsp;&nbsp;-getValues.test.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValues.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValues.test.js 容器内触发事件 最后一种背离自然组件的情形，通常发生在需要触发一个与组件挂载和更新组件props相关的事件的时候。 举个例子，你的任务是开发一个“仪表板”的功能。设计团队给了一个“仪表板”的模板，你把它转换成一个React组件。现在，您必须用数据填充这个“仪表板”。 你发现，当你挂载这个组件，你需要调用一个函数(例如dispatch(fetchAction))，来得到这些数据。 在这个场景中，我添加了componentDidMount和componentDidUpdate两个生命周期方法，并添加了onMount或onDashboardIdChanged两个props，因为我需要一些事件来触发，以便将组件和外部世界链接起来。 按照黄金法则，onMount和onDashboardIdChanged这两个props是“不自然”的，因此应该放在容器中。 使用Hooks的好处在于，它使得在组件挂载（onMount）或者组件props更新时的事件分发变得更简单！ 组件挂载时的事件触发： 若要在组件挂载时触发一个事件，就需要使用一个空的数组作为传入参数来调用Hook useEffect（如下图）。 import&nbsp;React,&nbsp;{&nbsp;useEffect&nbsp;}&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;fetchSomething_reduxAction&nbsp;from&nbsp;&#39;your-redux-stuff&#39;;import&nbsp;getValues&nbsp;from&nbsp;&#39;./helpers/getVaules&#39;;import&nbsp;FooComponent&nbsp;from&nbsp;&#39;./FooComponent&#39;;export&nbsp;default&nbsp;function&nbsp;FooComponentContainer(props)&nbsp;{&nbsp;&nbsp;//&nbsp;hooks&nbsp;&nbsp;//&nbsp;NOTE:&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won&#39;t&nbsp;look&nbsp;like&nbsp;this&nbsp;&nbsp;const&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();&nbsp;&nbsp;//&nbsp;dispatch&nbsp;action&nbsp;onMount&nbsp;&nbsp;useEffect(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch(fetchSomething_reduxAction);&nbsp;&nbsp;},&nbsp;[]);&nbsp;//&nbsp;the&nbsp;empty&nbsp;array&nbsp;tells&nbsp;react&nbsp;to&nbsp;only&nbsp;fire&nbsp;on&nbsp;mount&nbsp;&nbsp;//&nbsp;https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects&nbsp;&nbsp;//&nbsp;mapping&nbsp;&nbsp;const&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);&nbsp;&nbsp;//&nbsp;natural&nbsp;component&nbsp;&nbsp;return&nbsp;&lt;FooComponent&nbsp;{...props}&nbsp;/&gt;;}FooComponentContainer.propTypes&nbsp;=&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}; 使用Hooks的组件挂载时的容器内触发事件 组件prop更新时的事件触发： useEffect这个Hook能够在重新渲染和属性更新时调用你提供的函数之间，检查属性的变化。 在使用Hook useEffect之前，我发现自己在组件中添加了“不自然”的生命周期方法和OnPropertyChanged属性，因为我没有什么办法在组件外部比较属性的差异（示例如下）： import&nbsp;React&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;/**&nbsp;*&nbsp;Before&nbsp;`useEffect`,&nbsp;I&nbsp;found&nbsp;myself&nbsp;adding&nbsp;&quot;unnatural&quot;&nbsp;props&nbsp;*&nbsp;to&nbsp;my&nbsp;components&nbsp;that&nbsp;only&nbsp;fired&nbsp;events&nbsp;when&nbsp;the&nbsp;props&nbsp;diffed.&nbsp;*&nbsp;*&nbsp;I&#39;d&nbsp;find&nbsp;that&nbsp;the&nbsp;component&#39;s&nbsp;`render`&nbsp;didn&#39;t&nbsp;even&nbsp;use&nbsp;`id`&nbsp;*&nbsp;most&nbsp;of&nbsp;the&nbsp;time&nbsp;*/export&nbsp;default&nbsp;class&nbsp;BeforeUseEffect&nbsp;extends&nbsp;React.Component&nbsp;{&nbsp;&nbsp;static&nbsp;propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;id:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;&nbsp;&nbsp;onIdChange:&nbsp;PropTypes.func.isRequired,&nbsp;&nbsp;};&nbsp;&nbsp;componentDidMount()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.props.onIdChange(this.props.id);&nbsp;&nbsp;}&nbsp;&nbsp;componentDidUpdate(prevProps)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(prevProps.id&nbsp;!==&nbsp;this.props.id)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.props.onIdChange(this.props.id);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;render()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;//&nbsp;...&nbsp;&nbsp;}} 旧方法: 使用类来实现属性更新时的事件触发 现在有了Hook useEffect，就有了一种非常轻量级的方法来实现prop更新时的事件触发，而不需要在真实组件中添加不必要的props（示例如下）。 import&nbsp;React,&nbsp;{&nbsp;useEffect&nbsp;}&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;fetchSomething_reduxAction&nbsp;from&nbsp;&#39;your-redux-stuff&#39;;import&nbsp;getValues&nbsp;from&nbsp;&#39;./helpers/getVaules&#39;;import&nbsp;FooComponent&nbsp;from&nbsp;&#39;./FooComponent&#39;;export&nbsp;default&nbsp;function&nbsp;FooComponentContainer({&nbsp;id&nbsp;})&nbsp;{&nbsp;&nbsp;//&nbsp;hooks&nbsp;&nbsp;//&nbsp;NOTE:&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won&#39;t&nbsp;look&nbsp;like&nbsp;this&nbsp;&nbsp;const&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();&nbsp;&nbsp;//&nbsp;dispatch&nbsp;action&nbsp;onMount&nbsp;&nbsp;useEffect(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch(fetchSomething_reduxAction);&nbsp;&nbsp;},&nbsp;[id]);&nbsp;//&nbsp;`useEffect`&nbsp;will&nbsp;watch&nbsp;this&nbsp;`id`&nbsp;prop&nbsp;and&nbsp;fire&nbsp;the&nbsp;effect&nbsp;when&nbsp;it&nbsp;differs&nbsp;&nbsp;//&nbsp;https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects&nbsp;&nbsp;//&nbsp;mapping&nbsp;&nbsp;const&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);&nbsp;&nbsp;//&nbsp;natural&nbsp;component&nbsp;&nbsp;return&nbsp;&lt;FooComponent&nbsp;{...props}&nbsp;/&gt;;}FooComponentContainer.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;id:&nbsp;PropTypes.string.isRequired,}; 新方法：使用hook useEffect来实现属性更新时的事件触发 免责声明：除了使用useEffect这个hook,也有其它一些方法可以在容器内使用其他高阶组件（如recompose’s lifecycle的示例：https://github.com/acdlite/recompose/blob/3db12ce7121a050b533476958ff3d66ded1c4bb8/docs/API.md#lifecycle）来比较prop的差异，或者创建一个生命周期组件（如react router内部实现的示例：https://github.com/ReactTraining/react-router/blob/89a72d58ac55b2d8640c25e86d1f1496e4ba8d6c/packages/react-router/modules/Lifecycle.js），但这些方法要么让团队成员感到困惑，要么是非常规做法。 这样做的好处是什么？ 享受组件开发的乐趣 对我来说，组件开发是前端开发中最有趣和最令人开心的部分。你可以把你的团队的想法和梦想变成真实的体验，这是一种很好的感觉，我认为我们应该在团队内分享，因为这和我们每个人都是相关的。 你的组件API和体验被“外部世界”破坏的场景永远不会出现。你的组件正如你想要的那样，没有额外的props, 这是我最喜欢的黄金法则的地方。 更多测试和重用的机会 采用这样的体系结构，你基本上是在渲染时引入了一个新的数据层。而在这个“层”中，你可以将你的关注点在进入组件的数据的正确性和组件的工作方式之间进行切换。 不管你是否知道，这个层已经存在于你的应用程序中，但是它可能与表现逻辑结合在一起。我发现，当我渲染这一层时，我可以进行大量的代码优化，并重用大量的逻辑，否则我可能在不知道共性的情况下重复编写这些逻辑。 通过添加一些定制的Hooks，这些好处将变得更加明显。定制的Hooks为我们提供了一种更简单的方法来提取逻辑并支持外部更新，而这是helper函数无法做到的。 最大化团队产出 当一个团队共同工作时，你可以将容器开发和组件开发的工作分配给不同的团队成员。如果API的规格已经确定，那么下面三部分的开发工作可以同步进行： Web API（如后端）开发 编写从Web API（或类似）获取数据，并将数据转换为组件的API 组件开发 有例外情形吗？ 就像真正的黄金法则一样，这里的黄金法则也是一个黄金拇指法则。在某些场景，编写看似不自然的组件API以降低某些转换的复杂性也是一种合理的做法。 一个简单的例子是props的名称。如果开发人员以更“自然”的理由来对props重命名，那么将使事情变得更复杂。 过分地强调这个法则是可能发生的，结果是你可能陷入困境。 结束语 本文的“黄金法则”只是以一个新的角度，对展示组件和容器组件的现有概念的重新阐述。如果你能清楚你的组件到底要做什么，那么你可能会得到更简单易读的部分！ 原文：https://medium.freecodecamp.org/how-the-golden-rule-of-react-components-can-help-you-write-better-code-127046b478eb 本文为CSDN翻译，转载请注明来源出处。 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞为什么雷军指责“华为不懂研发”？| 畅言 ☞抛弃 VS Code 我还能用啥编辑器？| 技术头条 ☞如何看待程序员“面试造火箭、工作拧螺丝”？| 畅言 ☞斯坦福区块链匪帮传奇，那些睡地毯、没日没夜写代码的编程少年 ☞程序员逆袭为美国最佳 CEO，他说因为爱情 ☞开什么玩笑？股票价格如何经得起AI的推敲？| 技术头条 ☞云计算之基，一文带你速懂虚拟化KVM和XEN ☞程序员被骗&quot;黑砖窑&quot;：监禁、恐吓、996无休编程！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 点击阅读原文，输入关键词，即可搜索您想要的 CSDN 文章。 你点的每个“在看”，我都认真当成了喜欢" />
<meta property="og:description" content="本文有关 React 的“黄金法则”只是以一个新的角度，对展示组件和容器组件的现有概念的重新阐述。 作者 |&nbsp;Rico Kahler 译者 | 苏本如 责编 | 屠敏 出品 | CSDN（ID：CSDNnews） 以下为译文： 最近，我在开发组件时采用了一种新的思路。这不一定是一种全新的想法，而是对原有思维方式的一种微妙调整。这种新的思路就是： 组件开发的黄金法则 以最自然的方式创建和定义组件，只需要考虑它们需要什么去实现功能。 再次澄清，这是对原有思维方式的一种微妙调整，你可能认为你已经遵循了它，但违背它也很容易。 举个例子，假设你有如下的PersonCard组件： 如果你想“自然地”定义这个组件，那么你可能会写出下面的API： PersonCard.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;name:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;jobTitle:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;pictureUrl:&nbsp;PropTypes.string.isRequired,}; “自然的” PersonCard API 看上去非常直接，我们看看PersonCard这个组件需要什么属性就可以工作。这里，PersonCard组件只需要名称，职务和照片URL。 但假如你需要实现“根据用户的设置，决定是否显示正式照片”的功能。你就可能会尝试编写这样的API： PersonCard.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;name:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;jobTitle:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;officialPictureUrl:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;pictureUrl:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;preferOfficial:&nbsp;PropTypes.boolean.isRequired,}; 复杂化的PersonCard API 看起来似乎这个复杂化的组件需要那些额外的props来实现它的功能，但实际上，上面的组件看起来并没有什么不同，也不需要那些额外的props。这些额外的属性所做的是将这个preferOfficial设置与组件结合起来，但这样做会导致在其它场合（例如：不需要显示正式照片的场合）使用这个组件感到非常“不自然”。 容器的作用 那么，如果“决定显示哪个照片URL”的逻辑不属于这个组件本身，它应该属于哪里？ 如果用一个index文件来替代怎么样？ 我们采用了一种文件夹结构，其中每个组件都放在一个自命名的文件夹，index文件负责在你的“自然组件”和外部世界之间牵线搭桥。我们称此文件为“容器”（灵感来自于 React Redux的容器组件概念：https://redux.js.org/basics/usage-with-react#presentational-and-container-components）。 /PersonCard&nbsp;&nbsp;-PersonCard.js&nbsp;------&nbsp;the&nbsp;&quot;natural&quot;&nbsp;component&nbsp;&nbsp;-index.js&nbsp;-----------&nbsp;the&nbsp;&quot;container&quot; 容器：我们将容器定义为插入在你的自然组件和外部世界之间（负责连接这两部分）的一小段代码。因为这个原因，有时候我们也把这些“容器”叫做“injector （注入器）”。 自然组件：如果你被要求一张照片，你的“自然组件”就是这些用来显示这张照片的代码，你不需要知道如何获得数据的细节，也不需要知道它在应用程序中的位置，所有你需要知道的是它应该起作用。 外部世界：这里指的是你的应用程序所拥有的任何资源（例如Redux Store），而这些资源是可以被转换以满足你的自然组件的props。 本文的目标：我们如何编写“自然的”组件并确保它不会被来自外部世界的垃圾污染？为什么这样做更好？ 备注：本文中的“容器”概念虽然是受到这两个链接（Dan Abramov和React Redux）中的术语的启发，但是本文中的“容器”定义略有不同。 Dan Abramov的容器和本文中容器的唯一区别是在概念层面上。Dan在文章中说有两种组件：展示组件和容器组件。而本文我们更进一步，把它区分为组件和容器。 即使我们使用组件实现容器，我们也不会在概念层面将容器视为组件。这就是为什么我们建议将容器放在index文件中的原因，因为它是你的自然组件和外部世界之间的桥梁，并不是独立的。 你可能发现，本文的重点是关注组件，然而容器却占据了大半篇幅。为什么呢 这是因为：编写自然组件更容易，更有趣。而让你的组件连接到外部世界（容器的工作）有点难度。 依我看，导致你的“自然组件”被外部世界的垃圾污染的主要原因有三个： 奇怪的数据结构 超出组件范围的要求（如上例） 在组件挂载或更新时的事件触发 接下来，我将尝试用不同类型容器的实现示例，对上述三种情形进行阐述。 使用奇怪的数据结构 有时候为了渲染所需要的信息，需要将不同类型的数据链接在一起，并将其转换成为更合理的格式。因为没有更合适的词，所以这里我用了“奇怪的”这个词。“奇怪的数据结构”就是那种让你的组件使用起来“不自然”的数据结构。 将“奇怪的”数据结构直接传递到组件中，并在组件内部进行转换是非常诱人的，但这会导致混乱，并且常常使得组件测试很难进行。 最近，当我被分配去创建一个组件，并从我们用来支持一个特定类型表单的特定数据结构中获取数据时，我发现自己落入了这个陷阱（示例如下）。 ChipField.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;field:&nbsp;PropTypes.object.isRequired,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&lt;--&nbsp;the&nbsp;&quot;weird&quot;&nbsp;data&nbsp;structure&nbsp;&nbsp;onEditField:&nbsp;PropTypes.func.isRequired,&nbsp;&nbsp;//&nbsp;&lt;--&nbsp;and&nbsp;a&nbsp;weird&nbsp;event&nbsp;too}; 这个组件将这个奇怪的数据结构field作为一个props。事实上，如果我们后面不再用到这个组件的话，这样做是可以接受的。但是后来这个组件在一个与这个奇怪的数据结构无关的地方又用到了，这样它就成了一个真正的问题。 因为组件需要这个数据结构，所以重用它变得不可能，重构它也很困难。我们最初编写的测试程序也令人困惑，因为模拟了这种奇怪的数据结构。我们无法理解这些测试程序，并且在最终重构时无法重新编写它们。 不幸的是，奇怪的数据结构是不可避免的，但是使用容器是处理它们的一种很好的方法。我从这个例子学到的一点是，以这种方式构建组件，让你可以选择对组件进行提取，并将其转变为可重用的组件。但是如果你将一个奇怪的数据结构传递到一个组件中，你将失去这个选择。 注意：我并不是建议你所写的所有组件从一开始就应该是通用的。而是建议你想一想你的组件从根本上讲要实现什么，然后弥合间隙。如果你这样做了，您就会选择将你的组件转变为可重用的组件，这种转变需要的工作量很小。 使用函数组件实现容器 如果严格映射props，一个简单的实现方式是使用函数组件： import&nbsp;React&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;getValuesFromField&nbsp;from&nbsp;&#39;./helpers/getValuesFromField&#39;;import&nbsp;transformValuesToField&nbsp;from&nbsp;&#39;./helpers/transformValuesToField&#39;;import&nbsp;ChipField&nbsp;from&nbsp;&#39;./ChipField&#39;;export&nbsp;default&nbsp;function&nbsp;ChipFieldContainer({&nbsp;field,&nbsp;onEditField&nbsp;})&nbsp;{&nbsp;&nbsp;const&nbsp;values&nbsp;=&nbsp;getValuesFromField(field);&nbsp;&nbsp;function&nbsp;handleOnChange(values)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;onEditField(transformValuesToField(values));&nbsp;&nbsp;}&nbsp;&nbsp;return&nbsp;&lt;ChipField&nbsp;values={values}&nbsp;onChange={handleOnChange}&nbsp;/&gt;;}//&nbsp;external&nbsp;propsChipFieldContainer.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;field:&nbsp;PropTypes.object.isRequired,&nbsp;&nbsp;onEditField:&nbsp;PropTypes.func.isRequired,}; 组件的文件夹结构像下面这样： /ChipField&nbsp;&nbsp;-ChipField.js&nbsp;------------------&nbsp;the&nbsp;&quot;natural&quot;&nbsp;chip&nbsp;field&nbsp;&nbsp;-ChipField.test.js&nbsp;&nbsp;-index.js&nbsp;----------------------&nbsp;the&nbsp;&quot;container&quot;&nbsp;&nbsp;-index.test.js&nbsp;&nbsp;/helpers&nbsp;-----------------------&nbsp;a&nbsp;folder&nbsp;for&nbsp;the&nbsp;helpers/utils&nbsp;&nbsp;&nbsp;&nbsp;-getValuesFromField.js&nbsp;&nbsp;&nbsp;&nbsp;-getValuesFromField.test.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValuesToField.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValuesToField.test.js 你可能在想“这种实现方式的要做的工作太多了”。你有这种想法很正常。是的，这里看起来要做的工作是多了，因为需要维护更多的文件，而且看上去也不那么直观。但是你可能忽视了一点： 其实真正的工作量并没有增加，不管你是在组件外部或者是在组件内部转换数据，需要的工作量其实都是一样的。区别只是在于，当你把数据转换放在组件外进行时，你就能够更准确地测试出你的数据转换是否正确，同时也分离了关注点。 组件之外实现需求 对于上面提到的PersonCard的示例，当你将组件开发的“黄金法则”应用其上时，你很可能会意识到某些需求超出了实际组件的范围。那么这些需求如何实现呢？ 你应该猜到了答案：对，使用容器。 你可以通过创建容器来做一些额外的工作来保持组件的自然性。当你这样做的时候，你最终会得到一个更加简单而且功能单一的组件，和一个更好测试的容器。 让我们用一个PersonCard容器的实现来举例说明。 使用高阶组件实现容器 React Redux使用高阶组件来实现从Redux Store推送和映射props的容器。因为“容器”这个术语是从React Redux得到来的，所以毫不奇怪，React Redux的connect就是一个容器。 无论你是使用函数组件来映射props， 还是使用高阶组件connect到Redux Store，其中的黄金法则和容器的作用都是相同的。首先，编写你的自然组件，然后使用高阶组件来弥合间隙。 import&nbsp;{&nbsp;connect&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;getPictureUrl&nbsp;from&nbsp;&#39;./helpers/getPictureUrl&#39;;import&nbsp;PersonCard&nbsp;from&nbsp;&#39;./PersonCard&#39;;const&nbsp;mapStateToProps&nbsp;=&nbsp;(state,&nbsp;ownProps)&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;const&nbsp;{&nbsp;person&nbsp;}&nbsp;=&nbsp;ownProps;&nbsp;&nbsp;const&nbsp;{&nbsp;name,&nbsp;jobTitle,&nbsp;customPictureUrl,&nbsp;officialPictureUrl&nbsp;}&nbsp;=&nbsp;person;&nbsp;&nbsp;const&nbsp;{&nbsp;preferOfficial&nbsp;}&nbsp;=&nbsp;state.settings;&nbsp;&nbsp;const&nbsp;pictureUrl&nbsp;=&nbsp;getPictureUrl(preferOfficial,&nbsp;customPictureUrl,&nbsp;officialPictureUrl);&nbsp;&nbsp;return&nbsp;{&nbsp;name,&nbsp;jobTitle,&nbsp;pictureUrl&nbsp;};};const&nbsp;mapDispatchToProps&nbsp;=&nbsp;null;export&nbsp;default&nbsp;connect(&nbsp;&nbsp;mapStateToProps,&nbsp;&nbsp;mapDispatchToProps,)(PersonCard); 使用高阶组件的容器实现 上述实现的文件夹结构如下： /PersonCard&nbsp;&nbsp;-PersonCard.js&nbsp;-----------------&nbsp;natural&nbsp;component&nbsp;&nbsp;-PersonCard.test.js&nbsp;&nbsp;-index.js&nbsp;----------------------&nbsp;container&nbsp;&nbsp;-index.test.js&nbsp;&nbsp;/helpers&nbsp;&nbsp;&nbsp;&nbsp;-getPictureUrl.js&nbsp;------------&nbsp;helper&nbsp;&nbsp;&nbsp;&nbsp;-getPictureUrl.test.js 注意：在这个示例中，/helpers文件夹里只有一个getPictureURL，真实情况应该还有其它helpers，这里只是演示你可以把这个逻辑分离出来。您还可能注意到，无论对于哪种容器实现，文件夹结构其实都是一样的。 如果你有Redux的使用经验，你可能已经熟悉上面的示例。这里再重复一次，黄金法则不是一种全新的想法，而是对原有思维方式的一种微妙调整。 此外，在你用高阶组件实现容器时，你还可以在功能上将高阶组件组合在一起，亦即你可以将props从一个高阶组件传递到下一个。在过去，我们曾经将多个高阶组件链接在一起，来实现单个容器。 备注：React社区似乎有正在远离高阶组件的趋势。 我也会推荐同这样做。我从使用高阶组件得来的经验是，对于不熟悉函数组件的团队成员来说，它们可能会令人困惑，并且会导致所谓的“封装地狱”，即组件被封装太多次，从而导致严重的性能问题。 这里我列出一些相关的文章和资源供参考： Hooks talk (2018) ：https://youtu.be/dpw9EHDh2bM?t=710 Recompose talk (2016) ：https://youtu.be/zD_judE-bXk?t=1101 Use a Render Prop! (2017)：https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce When to NOT use Render Props (2018)：https://blog.kentcdodds.com/when-to-not-use-render-props-5397bbeff746 好了，到了我们谈谈React Hooks(钩子)的时候了。 使用hooks实现容器 你可能问为什么本文要讨论Hooks, 原因是使用Hooks来实现容器要容易得多。 如果你还不熟悉React Hooks，那么我建议你观看Dan Abramov和Ryan Florence在React 2018大会上的演讲视频，视频中有React Hooks的概念介绍（https://youtu.be/dpw9EHDh2bM）。 简而言之，React团队引入Hooks是为了应对高阶组件以及类似的模式带来的问题。React Hooks旨在替代它们，成为大多数场景下的最佳解决方案。 这意味着我们可以通过使用一个函数组件和Hooks来实现容器。 在下面的示例中，我们使用了useRoute和useRedux这两个Hooks来表示“外部世界”，我们使用getValues这个helper将“外部世界”映射为你的自然组件可用的props。我们还使用transformValues这个helper将组件的输出转换为由dispatch表示的外部世界。 import&nbsp;React&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;{&nbsp;useRouter&nbsp;}&nbsp;from&nbsp;&#39;react-router&#39;;import&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;actionCreator&nbsp;from&nbsp;&#39;your-redux-stuff&#39;;import&nbsp;getValues&nbsp;from&nbsp;&#39;./helpers/getVaules&#39;;import&nbsp;transformValues&nbsp;from&nbsp;&#39;./helpers/transformValues&#39;;import&nbsp;FooComponent&nbsp;from&nbsp;&#39;./FooComponent&#39;;export&nbsp;default&nbsp;function&nbsp;FooComponentContainer(props)&nbsp;{&nbsp;&nbsp;//&nbsp;hooks&nbsp;&nbsp;const&nbsp;{&nbsp;match&nbsp;}&nbsp;=&nbsp;useRouter({&nbsp;path:&nbsp;/*&nbsp;...&nbsp;*/&nbsp;});&nbsp;&nbsp;//&nbsp;NOTE:&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won&#39;t&nbsp;look&nbsp;like&nbsp;this&nbsp;&nbsp;const&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();&nbsp;&nbsp;//&nbsp;mapping&nbsp;&nbsp;const&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);&nbsp;&nbsp;function&nbsp;handleChange(e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;transformed&nbsp;=&nbsp;transformValues(e);&nbsp;&nbsp;&nbsp;&nbsp;dispatch(actionCreator(transformed));&nbsp;&nbsp;}&nbsp;&nbsp;//&nbsp;natural&nbsp;component&nbsp;&nbsp;return&nbsp;&lt;FooComponent&nbsp;{...props}&nbsp;onChange={handleChange}&nbsp;/&gt;;}FooComponentContainer.propTypes&nbsp;=&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}; 使用hooks来实现容器 参考文件夹结构如下： /FooComponent&nbsp;-----------&nbsp;the&nbsp;whole&nbsp;component&nbsp;for&nbsp;others&nbsp;to&nbsp;import&nbsp;&nbsp;-FooComponent.js&nbsp;------&nbsp;the&nbsp;&quot;natural&quot;&nbsp;part&nbsp;of&nbsp;the&nbsp;component&nbsp;&nbsp;-FooComponent.test.js&nbsp;&nbsp;-index.js&nbsp;-------------&nbsp;the&nbsp;&quot;container&quot;&nbsp;that&nbsp;bridges&nbsp;the&nbsp;gap&nbsp;&nbsp;-index.js.test.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;provides&nbsp;dependencies&nbsp;&nbsp;/helpers&nbsp;--------------&nbsp;isolated&nbsp;helpers&nbsp;that&nbsp;you&nbsp;can&nbsp;test&nbsp;easily&nbsp;&nbsp;&nbsp;&nbsp;-getValues.js&nbsp;&nbsp;&nbsp;&nbsp;-getValues.test.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValues.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValues.test.js 容器内触发事件 最后一种背离自然组件的情形，通常发生在需要触发一个与组件挂载和更新组件props相关的事件的时候。 举个例子，你的任务是开发一个“仪表板”的功能。设计团队给了一个“仪表板”的模板，你把它转换成一个React组件。现在，您必须用数据填充这个“仪表板”。 你发现，当你挂载这个组件，你需要调用一个函数(例如dispatch(fetchAction))，来得到这些数据。 在这个场景中，我添加了componentDidMount和componentDidUpdate两个生命周期方法，并添加了onMount或onDashboardIdChanged两个props，因为我需要一些事件来触发，以便将组件和外部世界链接起来。 按照黄金法则，onMount和onDashboardIdChanged这两个props是“不自然”的，因此应该放在容器中。 使用Hooks的好处在于，它使得在组件挂载（onMount）或者组件props更新时的事件分发变得更简单！ 组件挂载时的事件触发： 若要在组件挂载时触发一个事件，就需要使用一个空的数组作为传入参数来调用Hook useEffect（如下图）。 import&nbsp;React,&nbsp;{&nbsp;useEffect&nbsp;}&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;fetchSomething_reduxAction&nbsp;from&nbsp;&#39;your-redux-stuff&#39;;import&nbsp;getValues&nbsp;from&nbsp;&#39;./helpers/getVaules&#39;;import&nbsp;FooComponent&nbsp;from&nbsp;&#39;./FooComponent&#39;;export&nbsp;default&nbsp;function&nbsp;FooComponentContainer(props)&nbsp;{&nbsp;&nbsp;//&nbsp;hooks&nbsp;&nbsp;//&nbsp;NOTE:&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won&#39;t&nbsp;look&nbsp;like&nbsp;this&nbsp;&nbsp;const&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();&nbsp;&nbsp;//&nbsp;dispatch&nbsp;action&nbsp;onMount&nbsp;&nbsp;useEffect(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch(fetchSomething_reduxAction);&nbsp;&nbsp;},&nbsp;[]);&nbsp;//&nbsp;the&nbsp;empty&nbsp;array&nbsp;tells&nbsp;react&nbsp;to&nbsp;only&nbsp;fire&nbsp;on&nbsp;mount&nbsp;&nbsp;//&nbsp;https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects&nbsp;&nbsp;//&nbsp;mapping&nbsp;&nbsp;const&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);&nbsp;&nbsp;//&nbsp;natural&nbsp;component&nbsp;&nbsp;return&nbsp;&lt;FooComponent&nbsp;{...props}&nbsp;/&gt;;}FooComponentContainer.propTypes&nbsp;=&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}; 使用Hooks的组件挂载时的容器内触发事件 组件prop更新时的事件触发： useEffect这个Hook能够在重新渲染和属性更新时调用你提供的函数之间，检查属性的变化。 在使用Hook useEffect之前，我发现自己在组件中添加了“不自然”的生命周期方法和OnPropertyChanged属性，因为我没有什么办法在组件外部比较属性的差异（示例如下）： import&nbsp;React&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;/**&nbsp;*&nbsp;Before&nbsp;`useEffect`,&nbsp;I&nbsp;found&nbsp;myself&nbsp;adding&nbsp;&quot;unnatural&quot;&nbsp;props&nbsp;*&nbsp;to&nbsp;my&nbsp;components&nbsp;that&nbsp;only&nbsp;fired&nbsp;events&nbsp;when&nbsp;the&nbsp;props&nbsp;diffed.&nbsp;*&nbsp;*&nbsp;I&#39;d&nbsp;find&nbsp;that&nbsp;the&nbsp;component&#39;s&nbsp;`render`&nbsp;didn&#39;t&nbsp;even&nbsp;use&nbsp;`id`&nbsp;*&nbsp;most&nbsp;of&nbsp;the&nbsp;time&nbsp;*/export&nbsp;default&nbsp;class&nbsp;BeforeUseEffect&nbsp;extends&nbsp;React.Component&nbsp;{&nbsp;&nbsp;static&nbsp;propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;id:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;&nbsp;&nbsp;onIdChange:&nbsp;PropTypes.func.isRequired,&nbsp;&nbsp;};&nbsp;&nbsp;componentDidMount()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.props.onIdChange(this.props.id);&nbsp;&nbsp;}&nbsp;&nbsp;componentDidUpdate(prevProps)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(prevProps.id&nbsp;!==&nbsp;this.props.id)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.props.onIdChange(this.props.id);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;render()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;//&nbsp;...&nbsp;&nbsp;}} 旧方法: 使用类来实现属性更新时的事件触发 现在有了Hook useEffect，就有了一种非常轻量级的方法来实现prop更新时的事件触发，而不需要在真实组件中添加不必要的props（示例如下）。 import&nbsp;React,&nbsp;{&nbsp;useEffect&nbsp;}&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;fetchSomething_reduxAction&nbsp;from&nbsp;&#39;your-redux-stuff&#39;;import&nbsp;getValues&nbsp;from&nbsp;&#39;./helpers/getVaules&#39;;import&nbsp;FooComponent&nbsp;from&nbsp;&#39;./FooComponent&#39;;export&nbsp;default&nbsp;function&nbsp;FooComponentContainer({&nbsp;id&nbsp;})&nbsp;{&nbsp;&nbsp;//&nbsp;hooks&nbsp;&nbsp;//&nbsp;NOTE:&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won&#39;t&nbsp;look&nbsp;like&nbsp;this&nbsp;&nbsp;const&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();&nbsp;&nbsp;//&nbsp;dispatch&nbsp;action&nbsp;onMount&nbsp;&nbsp;useEffect(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch(fetchSomething_reduxAction);&nbsp;&nbsp;},&nbsp;[id]);&nbsp;//&nbsp;`useEffect`&nbsp;will&nbsp;watch&nbsp;this&nbsp;`id`&nbsp;prop&nbsp;and&nbsp;fire&nbsp;the&nbsp;effect&nbsp;when&nbsp;it&nbsp;differs&nbsp;&nbsp;//&nbsp;https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects&nbsp;&nbsp;//&nbsp;mapping&nbsp;&nbsp;const&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);&nbsp;&nbsp;//&nbsp;natural&nbsp;component&nbsp;&nbsp;return&nbsp;&lt;FooComponent&nbsp;{...props}&nbsp;/&gt;;}FooComponentContainer.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;id:&nbsp;PropTypes.string.isRequired,}; 新方法：使用hook useEffect来实现属性更新时的事件触发 免责声明：除了使用useEffect这个hook,也有其它一些方法可以在容器内使用其他高阶组件（如recompose’s lifecycle的示例：https://github.com/acdlite/recompose/blob/3db12ce7121a050b533476958ff3d66ded1c4bb8/docs/API.md#lifecycle）来比较prop的差异，或者创建一个生命周期组件（如react router内部实现的示例：https://github.com/ReactTraining/react-router/blob/89a72d58ac55b2d8640c25e86d1f1496e4ba8d6c/packages/react-router/modules/Lifecycle.js），但这些方法要么让团队成员感到困惑，要么是非常规做法。 这样做的好处是什么？ 享受组件开发的乐趣 对我来说，组件开发是前端开发中最有趣和最令人开心的部分。你可以把你的团队的想法和梦想变成真实的体验，这是一种很好的感觉，我认为我们应该在团队内分享，因为这和我们每个人都是相关的。 你的组件API和体验被“外部世界”破坏的场景永远不会出现。你的组件正如你想要的那样，没有额外的props, 这是我最喜欢的黄金法则的地方。 更多测试和重用的机会 采用这样的体系结构，你基本上是在渲染时引入了一个新的数据层。而在这个“层”中，你可以将你的关注点在进入组件的数据的正确性和组件的工作方式之间进行切换。 不管你是否知道，这个层已经存在于你的应用程序中，但是它可能与表现逻辑结合在一起。我发现，当我渲染这一层时，我可以进行大量的代码优化，并重用大量的逻辑，否则我可能在不知道共性的情况下重复编写这些逻辑。 通过添加一些定制的Hooks，这些好处将变得更加明显。定制的Hooks为我们提供了一种更简单的方法来提取逻辑并支持外部更新，而这是helper函数无法做到的。 最大化团队产出 当一个团队共同工作时，你可以将容器开发和组件开发的工作分配给不同的团队成员。如果API的规格已经确定，那么下面三部分的开发工作可以同步进行： Web API（如后端）开发 编写从Web API（或类似）获取数据，并将数据转换为组件的API 组件开发 有例外情形吗？ 就像真正的黄金法则一样，这里的黄金法则也是一个黄金拇指法则。在某些场景，编写看似不自然的组件API以降低某些转换的复杂性也是一种合理的做法。 一个简单的例子是props的名称。如果开发人员以更“自然”的理由来对props重命名，那么将使事情变得更复杂。 过分地强调这个法则是可能发生的，结果是你可能陷入困境。 结束语 本文的“黄金法则”只是以一个新的角度，对展示组件和容器组件的现有概念的重新阐述。如果你能清楚你的组件到底要做什么，那么你可能会得到更简单易读的部分！ 原文：https://medium.freecodecamp.org/how-the-golden-rule-of-react-components-can-help-you-write-better-code-127046b478eb 本文为CSDN翻译，转载请注明来源出处。 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞为什么雷军指责“华为不懂研发”？| 畅言 ☞抛弃 VS Code 我还能用啥编辑器？| 技术头条 ☞如何看待程序员“面试造火箭、工作拧螺丝”？| 畅言 ☞斯坦福区块链匪帮传奇，那些睡地毯、没日没夜写代码的编程少年 ☞程序员逆袭为美国最佳 CEO，他说因为爱情 ☞开什么玩笑？股票价格如何经得起AI的推敲？| 技术头条 ☞云计算之基，一文带你速懂虚拟化KVM和XEN ☞程序员被骗&quot;黑砖窑&quot;：监禁、恐吓、996无休编程！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 点击阅读原文，输入关键词，即可搜索您想要的 CSDN 文章。 你点的每个“在看”，我都认真当成了喜欢" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本文有关 React 的“黄金法则”只是以一个新的角度，对展示组件和容器组件的现有概念的重新阐述。 作者 |&nbsp;Rico Kahler 译者 | 苏本如 责编 | 屠敏 出品 | CSDN（ID：CSDNnews） 以下为译文： 最近，我在开发组件时采用了一种新的思路。这不一定是一种全新的想法，而是对原有思维方式的一种微妙调整。这种新的思路就是： 组件开发的黄金法则 以最自然的方式创建和定义组件，只需要考虑它们需要什么去实现功能。 再次澄清，这是对原有思维方式的一种微妙调整，你可能认为你已经遵循了它，但违背它也很容易。 举个例子，假设你有如下的PersonCard组件： 如果你想“自然地”定义这个组件，那么你可能会写出下面的API： PersonCard.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;name:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;jobTitle:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;pictureUrl:&nbsp;PropTypes.string.isRequired,}; “自然的” PersonCard API 看上去非常直接，我们看看PersonCard这个组件需要什么属性就可以工作。这里，PersonCard组件只需要名称，职务和照片URL。 但假如你需要实现“根据用户的设置，决定是否显示正式照片”的功能。你就可能会尝试编写这样的API： PersonCard.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;name:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;jobTitle:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;officialPictureUrl:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;pictureUrl:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;preferOfficial:&nbsp;PropTypes.boolean.isRequired,}; 复杂化的PersonCard API 看起来似乎这个复杂化的组件需要那些额外的props来实现它的功能，但实际上，上面的组件看起来并没有什么不同，也不需要那些额外的props。这些额外的属性所做的是将这个preferOfficial设置与组件结合起来，但这样做会导致在其它场合（例如：不需要显示正式照片的场合）使用这个组件感到非常“不自然”。 容器的作用 那么，如果“决定显示哪个照片URL”的逻辑不属于这个组件本身，它应该属于哪里？ 如果用一个index文件来替代怎么样？ 我们采用了一种文件夹结构，其中每个组件都放在一个自命名的文件夹，index文件负责在你的“自然组件”和外部世界之间牵线搭桥。我们称此文件为“容器”（灵感来自于 React Redux的容器组件概念：https://redux.js.org/basics/usage-with-react#presentational-and-container-components）。 /PersonCard&nbsp;&nbsp;-PersonCard.js&nbsp;------&nbsp;the&nbsp;&quot;natural&quot;&nbsp;component&nbsp;&nbsp;-index.js&nbsp;-----------&nbsp;the&nbsp;&quot;container&quot; 容器：我们将容器定义为插入在你的自然组件和外部世界之间（负责连接这两部分）的一小段代码。因为这个原因，有时候我们也把这些“容器”叫做“injector （注入器）”。 自然组件：如果你被要求一张照片，你的“自然组件”就是这些用来显示这张照片的代码，你不需要知道如何获得数据的细节，也不需要知道它在应用程序中的位置，所有你需要知道的是它应该起作用。 外部世界：这里指的是你的应用程序所拥有的任何资源（例如Redux Store），而这些资源是可以被转换以满足你的自然组件的props。 本文的目标：我们如何编写“自然的”组件并确保它不会被来自外部世界的垃圾污染？为什么这样做更好？ 备注：本文中的“容器”概念虽然是受到这两个链接（Dan Abramov和React Redux）中的术语的启发，但是本文中的“容器”定义略有不同。 Dan Abramov的容器和本文中容器的唯一区别是在概念层面上。Dan在文章中说有两种组件：展示组件和容器组件。而本文我们更进一步，把它区分为组件和容器。 即使我们使用组件实现容器，我们也不会在概念层面将容器视为组件。这就是为什么我们建议将容器放在index文件中的原因，因为它是你的自然组件和外部世界之间的桥梁，并不是独立的。 你可能发现，本文的重点是关注组件，然而容器却占据了大半篇幅。为什么呢 这是因为：编写自然组件更容易，更有趣。而让你的组件连接到外部世界（容器的工作）有点难度。 依我看，导致你的“自然组件”被外部世界的垃圾污染的主要原因有三个： 奇怪的数据结构 超出组件范围的要求（如上例） 在组件挂载或更新时的事件触发 接下来，我将尝试用不同类型容器的实现示例，对上述三种情形进行阐述。 使用奇怪的数据结构 有时候为了渲染所需要的信息，需要将不同类型的数据链接在一起，并将其转换成为更合理的格式。因为没有更合适的词，所以这里我用了“奇怪的”这个词。“奇怪的数据结构”就是那种让你的组件使用起来“不自然”的数据结构。 将“奇怪的”数据结构直接传递到组件中，并在组件内部进行转换是非常诱人的，但这会导致混乱，并且常常使得组件测试很难进行。 最近，当我被分配去创建一个组件，并从我们用来支持一个特定类型表单的特定数据结构中获取数据时，我发现自己落入了这个陷阱（示例如下）。 ChipField.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;field:&nbsp;PropTypes.object.isRequired,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&lt;--&nbsp;the&nbsp;&quot;weird&quot;&nbsp;data&nbsp;structure&nbsp;&nbsp;onEditField:&nbsp;PropTypes.func.isRequired,&nbsp;&nbsp;//&nbsp;&lt;--&nbsp;and&nbsp;a&nbsp;weird&nbsp;event&nbsp;too}; 这个组件将这个奇怪的数据结构field作为一个props。事实上，如果我们后面不再用到这个组件的话，这样做是可以接受的。但是后来这个组件在一个与这个奇怪的数据结构无关的地方又用到了，这样它就成了一个真正的问题。 因为组件需要这个数据结构，所以重用它变得不可能，重构它也很困难。我们最初编写的测试程序也令人困惑，因为模拟了这种奇怪的数据结构。我们无法理解这些测试程序，并且在最终重构时无法重新编写它们。 不幸的是，奇怪的数据结构是不可避免的，但是使用容器是处理它们的一种很好的方法。我从这个例子学到的一点是，以这种方式构建组件，让你可以选择对组件进行提取，并将其转变为可重用的组件。但是如果你将一个奇怪的数据结构传递到一个组件中，你将失去这个选择。 注意：我并不是建议你所写的所有组件从一开始就应该是通用的。而是建议你想一想你的组件从根本上讲要实现什么，然后弥合间隙。如果你这样做了，您就会选择将你的组件转变为可重用的组件，这种转变需要的工作量很小。 使用函数组件实现容器 如果严格映射props，一个简单的实现方式是使用函数组件： import&nbsp;React&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;getValuesFromField&nbsp;from&nbsp;&#39;./helpers/getValuesFromField&#39;;import&nbsp;transformValuesToField&nbsp;from&nbsp;&#39;./helpers/transformValuesToField&#39;;import&nbsp;ChipField&nbsp;from&nbsp;&#39;./ChipField&#39;;export&nbsp;default&nbsp;function&nbsp;ChipFieldContainer({&nbsp;field,&nbsp;onEditField&nbsp;})&nbsp;{&nbsp;&nbsp;const&nbsp;values&nbsp;=&nbsp;getValuesFromField(field);&nbsp;&nbsp;function&nbsp;handleOnChange(values)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;onEditField(transformValuesToField(values));&nbsp;&nbsp;}&nbsp;&nbsp;return&nbsp;&lt;ChipField&nbsp;values={values}&nbsp;onChange={handleOnChange}&nbsp;/&gt;;}//&nbsp;external&nbsp;propsChipFieldContainer.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;field:&nbsp;PropTypes.object.isRequired,&nbsp;&nbsp;onEditField:&nbsp;PropTypes.func.isRequired,}; 组件的文件夹结构像下面这样： /ChipField&nbsp;&nbsp;-ChipField.js&nbsp;------------------&nbsp;the&nbsp;&quot;natural&quot;&nbsp;chip&nbsp;field&nbsp;&nbsp;-ChipField.test.js&nbsp;&nbsp;-index.js&nbsp;----------------------&nbsp;the&nbsp;&quot;container&quot;&nbsp;&nbsp;-index.test.js&nbsp;&nbsp;/helpers&nbsp;-----------------------&nbsp;a&nbsp;folder&nbsp;for&nbsp;the&nbsp;helpers/utils&nbsp;&nbsp;&nbsp;&nbsp;-getValuesFromField.js&nbsp;&nbsp;&nbsp;&nbsp;-getValuesFromField.test.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValuesToField.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValuesToField.test.js 你可能在想“这种实现方式的要做的工作太多了”。你有这种想法很正常。是的，这里看起来要做的工作是多了，因为需要维护更多的文件，而且看上去也不那么直观。但是你可能忽视了一点： 其实真正的工作量并没有增加，不管你是在组件外部或者是在组件内部转换数据，需要的工作量其实都是一样的。区别只是在于，当你把数据转换放在组件外进行时，你就能够更准确地测试出你的数据转换是否正确，同时也分离了关注点。 组件之外实现需求 对于上面提到的PersonCard的示例，当你将组件开发的“黄金法则”应用其上时，你很可能会意识到某些需求超出了实际组件的范围。那么这些需求如何实现呢？ 你应该猜到了答案：对，使用容器。 你可以通过创建容器来做一些额外的工作来保持组件的自然性。当你这样做的时候，你最终会得到一个更加简单而且功能单一的组件，和一个更好测试的容器。 让我们用一个PersonCard容器的实现来举例说明。 使用高阶组件实现容器 React Redux使用高阶组件来实现从Redux Store推送和映射props的容器。因为“容器”这个术语是从React Redux得到来的，所以毫不奇怪，React Redux的connect就是一个容器。 无论你是使用函数组件来映射props， 还是使用高阶组件connect到Redux Store，其中的黄金法则和容器的作用都是相同的。首先，编写你的自然组件，然后使用高阶组件来弥合间隙。 import&nbsp;{&nbsp;connect&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;getPictureUrl&nbsp;from&nbsp;&#39;./helpers/getPictureUrl&#39;;import&nbsp;PersonCard&nbsp;from&nbsp;&#39;./PersonCard&#39;;const&nbsp;mapStateToProps&nbsp;=&nbsp;(state,&nbsp;ownProps)&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;const&nbsp;{&nbsp;person&nbsp;}&nbsp;=&nbsp;ownProps;&nbsp;&nbsp;const&nbsp;{&nbsp;name,&nbsp;jobTitle,&nbsp;customPictureUrl,&nbsp;officialPictureUrl&nbsp;}&nbsp;=&nbsp;person;&nbsp;&nbsp;const&nbsp;{&nbsp;preferOfficial&nbsp;}&nbsp;=&nbsp;state.settings;&nbsp;&nbsp;const&nbsp;pictureUrl&nbsp;=&nbsp;getPictureUrl(preferOfficial,&nbsp;customPictureUrl,&nbsp;officialPictureUrl);&nbsp;&nbsp;return&nbsp;{&nbsp;name,&nbsp;jobTitle,&nbsp;pictureUrl&nbsp;};};const&nbsp;mapDispatchToProps&nbsp;=&nbsp;null;export&nbsp;default&nbsp;connect(&nbsp;&nbsp;mapStateToProps,&nbsp;&nbsp;mapDispatchToProps,)(PersonCard); 使用高阶组件的容器实现 上述实现的文件夹结构如下： /PersonCard&nbsp;&nbsp;-PersonCard.js&nbsp;-----------------&nbsp;natural&nbsp;component&nbsp;&nbsp;-PersonCard.test.js&nbsp;&nbsp;-index.js&nbsp;----------------------&nbsp;container&nbsp;&nbsp;-index.test.js&nbsp;&nbsp;/helpers&nbsp;&nbsp;&nbsp;&nbsp;-getPictureUrl.js&nbsp;------------&nbsp;helper&nbsp;&nbsp;&nbsp;&nbsp;-getPictureUrl.test.js 注意：在这个示例中，/helpers文件夹里只有一个getPictureURL，真实情况应该还有其它helpers，这里只是演示你可以把这个逻辑分离出来。您还可能注意到，无论对于哪种容器实现，文件夹结构其实都是一样的。 如果你有Redux的使用经验，你可能已经熟悉上面的示例。这里再重复一次，黄金法则不是一种全新的想法，而是对原有思维方式的一种微妙调整。 此外，在你用高阶组件实现容器时，你还可以在功能上将高阶组件组合在一起，亦即你可以将props从一个高阶组件传递到下一个。在过去，我们曾经将多个高阶组件链接在一起，来实现单个容器。 备注：React社区似乎有正在远离高阶组件的趋势。 我也会推荐同这样做。我从使用高阶组件得来的经验是，对于不熟悉函数组件的团队成员来说，它们可能会令人困惑，并且会导致所谓的“封装地狱”，即组件被封装太多次，从而导致严重的性能问题。 这里我列出一些相关的文章和资源供参考： Hooks talk (2018) ：https://youtu.be/dpw9EHDh2bM?t=710 Recompose talk (2016) ：https://youtu.be/zD_judE-bXk?t=1101 Use a Render Prop! (2017)：https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce When to NOT use Render Props (2018)：https://blog.kentcdodds.com/when-to-not-use-render-props-5397bbeff746 好了，到了我们谈谈React Hooks(钩子)的时候了。 使用hooks实现容器 你可能问为什么本文要讨论Hooks, 原因是使用Hooks来实现容器要容易得多。 如果你还不熟悉React Hooks，那么我建议你观看Dan Abramov和Ryan Florence在React 2018大会上的演讲视频，视频中有React Hooks的概念介绍（https://youtu.be/dpw9EHDh2bM）。 简而言之，React团队引入Hooks是为了应对高阶组件以及类似的模式带来的问题。React Hooks旨在替代它们，成为大多数场景下的最佳解决方案。 这意味着我们可以通过使用一个函数组件和Hooks来实现容器。 在下面的示例中，我们使用了useRoute和useRedux这两个Hooks来表示“外部世界”，我们使用getValues这个helper将“外部世界”映射为你的自然组件可用的props。我们还使用transformValues这个helper将组件的输出转换为由dispatch表示的外部世界。 import&nbsp;React&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;{&nbsp;useRouter&nbsp;}&nbsp;from&nbsp;&#39;react-router&#39;;import&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;actionCreator&nbsp;from&nbsp;&#39;your-redux-stuff&#39;;import&nbsp;getValues&nbsp;from&nbsp;&#39;./helpers/getVaules&#39;;import&nbsp;transformValues&nbsp;from&nbsp;&#39;./helpers/transformValues&#39;;import&nbsp;FooComponent&nbsp;from&nbsp;&#39;./FooComponent&#39;;export&nbsp;default&nbsp;function&nbsp;FooComponentContainer(props)&nbsp;{&nbsp;&nbsp;//&nbsp;hooks&nbsp;&nbsp;const&nbsp;{&nbsp;match&nbsp;}&nbsp;=&nbsp;useRouter({&nbsp;path:&nbsp;/*&nbsp;...&nbsp;*/&nbsp;});&nbsp;&nbsp;//&nbsp;NOTE:&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won&#39;t&nbsp;look&nbsp;like&nbsp;this&nbsp;&nbsp;const&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();&nbsp;&nbsp;//&nbsp;mapping&nbsp;&nbsp;const&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);&nbsp;&nbsp;function&nbsp;handleChange(e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;transformed&nbsp;=&nbsp;transformValues(e);&nbsp;&nbsp;&nbsp;&nbsp;dispatch(actionCreator(transformed));&nbsp;&nbsp;}&nbsp;&nbsp;//&nbsp;natural&nbsp;component&nbsp;&nbsp;return&nbsp;&lt;FooComponent&nbsp;{...props}&nbsp;onChange={handleChange}&nbsp;/&gt;;}FooComponentContainer.propTypes&nbsp;=&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}; 使用hooks来实现容器 参考文件夹结构如下： /FooComponent&nbsp;-----------&nbsp;the&nbsp;whole&nbsp;component&nbsp;for&nbsp;others&nbsp;to&nbsp;import&nbsp;&nbsp;-FooComponent.js&nbsp;------&nbsp;the&nbsp;&quot;natural&quot;&nbsp;part&nbsp;of&nbsp;the&nbsp;component&nbsp;&nbsp;-FooComponent.test.js&nbsp;&nbsp;-index.js&nbsp;-------------&nbsp;the&nbsp;&quot;container&quot;&nbsp;that&nbsp;bridges&nbsp;the&nbsp;gap&nbsp;&nbsp;-index.js.test.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;provides&nbsp;dependencies&nbsp;&nbsp;/helpers&nbsp;--------------&nbsp;isolated&nbsp;helpers&nbsp;that&nbsp;you&nbsp;can&nbsp;test&nbsp;easily&nbsp;&nbsp;&nbsp;&nbsp;-getValues.js&nbsp;&nbsp;&nbsp;&nbsp;-getValues.test.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValues.js&nbsp;&nbsp;&nbsp;&nbsp;-transformValues.test.js 容器内触发事件 最后一种背离自然组件的情形，通常发生在需要触发一个与组件挂载和更新组件props相关的事件的时候。 举个例子，你的任务是开发一个“仪表板”的功能。设计团队给了一个“仪表板”的模板，你把它转换成一个React组件。现在，您必须用数据填充这个“仪表板”。 你发现，当你挂载这个组件，你需要调用一个函数(例如dispatch(fetchAction))，来得到这些数据。 在这个场景中，我添加了componentDidMount和componentDidUpdate两个生命周期方法，并添加了onMount或onDashboardIdChanged两个props，因为我需要一些事件来触发，以便将组件和外部世界链接起来。 按照黄金法则，onMount和onDashboardIdChanged这两个props是“不自然”的，因此应该放在容器中。 使用Hooks的好处在于，它使得在组件挂载（onMount）或者组件props更新时的事件分发变得更简单！ 组件挂载时的事件触发： 若要在组件挂载时触发一个事件，就需要使用一个空的数组作为传入参数来调用Hook useEffect（如下图）。 import&nbsp;React,&nbsp;{&nbsp;useEffect&nbsp;}&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;fetchSomething_reduxAction&nbsp;from&nbsp;&#39;your-redux-stuff&#39;;import&nbsp;getValues&nbsp;from&nbsp;&#39;./helpers/getVaules&#39;;import&nbsp;FooComponent&nbsp;from&nbsp;&#39;./FooComponent&#39;;export&nbsp;default&nbsp;function&nbsp;FooComponentContainer(props)&nbsp;{&nbsp;&nbsp;//&nbsp;hooks&nbsp;&nbsp;//&nbsp;NOTE:&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won&#39;t&nbsp;look&nbsp;like&nbsp;this&nbsp;&nbsp;const&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();&nbsp;&nbsp;//&nbsp;dispatch&nbsp;action&nbsp;onMount&nbsp;&nbsp;useEffect(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch(fetchSomething_reduxAction);&nbsp;&nbsp;},&nbsp;[]);&nbsp;//&nbsp;the&nbsp;empty&nbsp;array&nbsp;tells&nbsp;react&nbsp;to&nbsp;only&nbsp;fire&nbsp;on&nbsp;mount&nbsp;&nbsp;//&nbsp;https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects&nbsp;&nbsp;//&nbsp;mapping&nbsp;&nbsp;const&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);&nbsp;&nbsp;//&nbsp;natural&nbsp;component&nbsp;&nbsp;return&nbsp;&lt;FooComponent&nbsp;{...props}&nbsp;/&gt;;}FooComponentContainer.propTypes&nbsp;=&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}; 使用Hooks的组件挂载时的容器内触发事件 组件prop更新时的事件触发： useEffect这个Hook能够在重新渲染和属性更新时调用你提供的函数之间，检查属性的变化。 在使用Hook useEffect之前，我发现自己在组件中添加了“不自然”的生命周期方法和OnPropertyChanged属性，因为我没有什么办法在组件外部比较属性的差异（示例如下）： import&nbsp;React&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;/**&nbsp;*&nbsp;Before&nbsp;`useEffect`,&nbsp;I&nbsp;found&nbsp;myself&nbsp;adding&nbsp;&quot;unnatural&quot;&nbsp;props&nbsp;*&nbsp;to&nbsp;my&nbsp;components&nbsp;that&nbsp;only&nbsp;fired&nbsp;events&nbsp;when&nbsp;the&nbsp;props&nbsp;diffed.&nbsp;*&nbsp;*&nbsp;I&#39;d&nbsp;find&nbsp;that&nbsp;the&nbsp;component&#39;s&nbsp;`render`&nbsp;didn&#39;t&nbsp;even&nbsp;use&nbsp;`id`&nbsp;*&nbsp;most&nbsp;of&nbsp;the&nbsp;time&nbsp;*/export&nbsp;default&nbsp;class&nbsp;BeforeUseEffect&nbsp;extends&nbsp;React.Component&nbsp;{&nbsp;&nbsp;static&nbsp;propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;id:&nbsp;PropTypes.string.isRequired,&nbsp;&nbsp;&nbsp;&nbsp;onIdChange:&nbsp;PropTypes.func.isRequired,&nbsp;&nbsp;};&nbsp;&nbsp;componentDidMount()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.props.onIdChange(this.props.id);&nbsp;&nbsp;}&nbsp;&nbsp;componentDidUpdate(prevProps)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(prevProps.id&nbsp;!==&nbsp;this.props.id)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.props.onIdChange(this.props.id);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;render()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;//&nbsp;...&nbsp;&nbsp;}} 旧方法: 使用类来实现属性更新时的事件触发 现在有了Hook useEffect，就有了一种非常轻量级的方法来实现prop更新时的事件触发，而不需要在真实组件中添加不必要的props（示例如下）。 import&nbsp;React,&nbsp;{&nbsp;useEffect&nbsp;}&nbsp;from&nbsp;&#39;react&#39;;import&nbsp;PropTypes&nbsp;from&nbsp;&#39;prop-types&#39;;import&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;from&nbsp;&#39;react-redux&#39;;import&nbsp;fetchSomething_reduxAction&nbsp;from&nbsp;&#39;your-redux-stuff&#39;;import&nbsp;getValues&nbsp;from&nbsp;&#39;./helpers/getVaules&#39;;import&nbsp;FooComponent&nbsp;from&nbsp;&#39;./FooComponent&#39;;export&nbsp;default&nbsp;function&nbsp;FooComponentContainer({&nbsp;id&nbsp;})&nbsp;{&nbsp;&nbsp;//&nbsp;hooks&nbsp;&nbsp;//&nbsp;NOTE:&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won&#39;t&nbsp;look&nbsp;like&nbsp;this&nbsp;&nbsp;const&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();&nbsp;&nbsp;//&nbsp;dispatch&nbsp;action&nbsp;onMount&nbsp;&nbsp;useEffect(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch(fetchSomething_reduxAction);&nbsp;&nbsp;},&nbsp;[id]);&nbsp;//&nbsp;`useEffect`&nbsp;will&nbsp;watch&nbsp;this&nbsp;`id`&nbsp;prop&nbsp;and&nbsp;fire&nbsp;the&nbsp;effect&nbsp;when&nbsp;it&nbsp;differs&nbsp;&nbsp;//&nbsp;https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects&nbsp;&nbsp;//&nbsp;mapping&nbsp;&nbsp;const&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);&nbsp;&nbsp;//&nbsp;natural&nbsp;component&nbsp;&nbsp;return&nbsp;&lt;FooComponent&nbsp;{...props}&nbsp;/&gt;;}FooComponentContainer.propTypes&nbsp;=&nbsp;{&nbsp;&nbsp;id:&nbsp;PropTypes.string.isRequired,}; 新方法：使用hook useEffect来实现属性更新时的事件触发 免责声明：除了使用useEffect这个hook,也有其它一些方法可以在容器内使用其他高阶组件（如recompose’s lifecycle的示例：https://github.com/acdlite/recompose/blob/3db12ce7121a050b533476958ff3d66ded1c4bb8/docs/API.md#lifecycle）来比较prop的差异，或者创建一个生命周期组件（如react router内部实现的示例：https://github.com/ReactTraining/react-router/blob/89a72d58ac55b2d8640c25e86d1f1496e4ba8d6c/packages/react-router/modules/Lifecycle.js），但这些方法要么让团队成员感到困惑，要么是非常规做法。 这样做的好处是什么？ 享受组件开发的乐趣 对我来说，组件开发是前端开发中最有趣和最令人开心的部分。你可以把你的团队的想法和梦想变成真实的体验，这是一种很好的感觉，我认为我们应该在团队内分享，因为这和我们每个人都是相关的。 你的组件API和体验被“外部世界”破坏的场景永远不会出现。你的组件正如你想要的那样，没有额外的props, 这是我最喜欢的黄金法则的地方。 更多测试和重用的机会 采用这样的体系结构，你基本上是在渲染时引入了一个新的数据层。而在这个“层”中，你可以将你的关注点在进入组件的数据的正确性和组件的工作方式之间进行切换。 不管你是否知道，这个层已经存在于你的应用程序中，但是它可能与表现逻辑结合在一起。我发现，当我渲染这一层时，我可以进行大量的代码优化，并重用大量的逻辑，否则我可能在不知道共性的情况下重复编写这些逻辑。 通过添加一些定制的Hooks，这些好处将变得更加明显。定制的Hooks为我们提供了一种更简单的方法来提取逻辑并支持外部更新，而这是helper函数无法做到的。 最大化团队产出 当一个团队共同工作时，你可以将容器开发和组件开发的工作分配给不同的团队成员。如果API的规格已经确定，那么下面三部分的开发工作可以同步进行： Web API（如后端）开发 编写从Web API（或类似）获取数据，并将数据转换为组件的API 组件开发 有例外情形吗？ 就像真正的黄金法则一样，这里的黄金法则也是一个黄金拇指法则。在某些场景，编写看似不自然的组件API以降低某些转换的复杂性也是一种合理的做法。 一个简单的例子是props的名称。如果开发人员以更“自然”的理由来对props重命名，那么将使事情变得更复杂。 过分地强调这个法则是可能发生的，结果是你可能陷入困境。 结束语 本文的“黄金法则”只是以一个新的角度，对展示组件和容器组件的现有概念的重新阐述。如果你能清楚你的组件到底要做什么，那么你可能会得到更简单易读的部分！ 原文：https://medium.freecodecamp.org/how-the-golden-rule-of-react-components-can-help-you-write-better-code-127046b478eb 本文为CSDN翻译，转载请注明来源出处。 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞为什么雷军指责“华为不懂研发”？| 畅言 ☞抛弃 VS Code 我还能用啥编辑器？| 技术头条 ☞如何看待程序员“面试造火箭、工作拧螺丝”？| 畅言 ☞斯坦福区块链匪帮传奇，那些睡地毯、没日没夜写代码的编程少年 ☞程序员逆袭为美国最佳 CEO，他说因为爱情 ☞开什么玩笑？股票价格如何经得起AI的推敲？| 技术头条 ☞云计算之基，一文带你速懂虚拟化KVM和XEN ☞程序员被骗&quot;黑砖窑&quot;：监禁、恐吓、996无休编程！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 点击阅读原文，输入关键词，即可搜索您想要的 CSDN 文章。 你点的每个“在看”，我都认真当成了喜欢","@type":"BlogPosting","url":"/2019/04/28/728489.html","headline":"程序员如何掌握 React 开发的黄金法则？ 技术头条","dateModified":"2019-04-28T00:00:00+08:00","datePublished":"2019-04-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/28/728489.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>程序员如何掌握 React 开发的黄金法则？ | 技术头条</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><img class="" data-copyright="0" data-ratio="0.15644171779141106" data-src="https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAug5zOzy32A3RIVhRwowK5ogg1hJ631uGyu9zOMKfTddDnSrsxicbCQNm59Qeo3lDYCvF70I9ibGvA9g/640?wx_fmt=gif" data-type="gif" data-w="652" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAug5zOzy32A3RIVhRwowK5ogg1hJ631uGyu9zOMKfTddDnSrsxicbCQNm59Qeo3lDYCvF70I9ibGvA9g/640?wx_fmt=gif"><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="color: rgb(136, 136, 136);font-size: 15px;"><span style="font-size: 15px;letter-spacing: 1px;">本文有关 React 的“黄金法则”只是以一个新的角度，对展示组件和容器组件的现有概念的重新阐述。</span></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 15px;"><img class="rich_pages" data-copyright="0" data-ratio="0.42578125" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhI8C5ClI5jSxetNJ4HTQcx8AlDaA9ic7ILdpkjjibS9jhQia1Zic4ruLI61UmA8xTicF9w8t8aMN2QytA/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" style="text-align: center;white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhI8C5ClI5jSxetNJ4HTQcx8AlDaA9ic7ILdpkjjibS9jhQia1Zic4ruLI61UmA8xTicF9w8t8aMN2QytA/640?wx_fmt=jpeg"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);text-align: left;letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(136, 136, 136);box-sizing: border-box !important;word-wrap: break-word !important;">作者 |&nbsp;Rico Kahler</span><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);text-align: left;letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(136, 136, 136);box-sizing: border-box !important;word-wrap: break-word !important;">译者 | 苏本如</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);text-align: left;letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(136, 136, 136);box-sizing: border-box !important;word-wrap: break-word !important;">责编 | 屠敏</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);text-align: left;letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(136, 136, 136);box-sizing: border-box !important;word-wrap: break-word !important;">出品 | CSDN（ID：CSDNnews）</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">以下为译文：</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">最近，我在开发组件时采用了一种新的思路。这不一定是一种全新的想法，而是对原有思维方式的一种微妙调整。这种新的思路就是：</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">组件开发的黄金法则</span></strong></p> 
<blockquote class="js_blockquote_wrap" data-type="2" data-url="" data-author-name="" data-content-utf8-length="32" data-source-title=""> 
 <section class="js_blockquote_digest"> 
  <section>
    以最自然的方式创建和定义组件，只需要考虑它们需要什么去实现功能。 
  </section> 
 </section> 
</blockquote> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">再次澄清，这是对原有思维方式的一种微妙调整，你可能认为你已经遵循了它，但违背它也很容易。</span><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">举个例子，假设你有如下的PersonCard组件：</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="font-size: 15px;"><img class="rich_pages" data-copyright="0" data-ratio="0.2807017543859649" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhI8C5ClI5jSxetNJ4HTQcxeJLWylfGOAib9mQt4GdricYDmtric3Xy0bZpbzlkUD9ouVs0y8jbicKkvw/640?wx_fmt=png" data-type="png" data-w="684" style="text-align: center;white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhI8C5ClI5jSxetNJ4HTQcxeJLWylfGOAib9mQt4GdricYDmtric3Xy0bZpbzlkUD9ouVs0y8jbicKkvw/640?wx_fmt=png"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">如果你想“自然地”定义这个组件，那么你可能会写出下面的API：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs cpp" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">PersonCard.propTypes&nbsp;=&nbsp;{<br>&nbsp;&nbsp;name:&nbsp;PropTypes.<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">string</span>.isRequired,<br>&nbsp;&nbsp;jobTitle:&nbsp;PropTypes.<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">string</span>.isRequired,<br>&nbsp;&nbsp;pictureUrl:&nbsp;PropTypes.<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">string</span>.isRequired,<br>};</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="font-size: 14px;color: rgb(136, 136, 136);">“自然的” PersonCard API</span><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">看上去非常直接，我们看看PersonCard这个组件需要什么属性就可以工作。这里，PersonCard组件只需要名称，职务和照片URL。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">但假如你需要实现“根据用户的设置，决定是否显示正式照片”的功能。你就可能会尝试编写这样的API：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs cpp" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">PersonCard.propTypes&nbsp;=&nbsp;{<br>&nbsp;&nbsp;name:&nbsp;PropTypes.<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">string</span>.isRequired,<br>&nbsp;&nbsp;jobTitle:&nbsp;PropTypes.<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">string</span>.isRequired,<br>&nbsp;&nbsp;officialPictureUrl:&nbsp;PropTypes.<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">string</span>.isRequired,<br>&nbsp;&nbsp;pictureUrl:&nbsp;PropTypes.<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">string</span>.isRequired,<br>&nbsp;&nbsp;preferOfficial:&nbsp;PropTypes.boolean.isRequired,<br>};<br></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="font-size: 14px;color: rgb(136, 136, 136);">复杂化的PersonCard API</span><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">看起来似乎这个复杂化的组件需要那些额外的props来实现它的功能，但实际上，上面的组件看起来并没有什么不同，也不需要那些额外的props。这些额外的属性所做的是将这个preferOfficial设置与组件结合起来，但这样做会导致在其它场合（例如：不需要显示正式照片的场合）使用这个组件感到非常“不自然”。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LXSAriayI15u06ibNNlXzIcor2tTtgJBKFxkIicJ8tiaRKRaictbrQEssdSg/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LXSAriayI15u06ibNNlXzIcor2tTtgJBKFxkIicJ8tiaRKRaictbrQEssdSg/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><span style="font-size: 18px;">容器的作用</span></strong><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">那么，如果“决定显示哪个照片URL”的逻辑不属于这个组件本身，它应该属于哪里？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">如果用一个index文件来替代怎么样？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">我们采用了一种文件夹结构，其中每个组件都放在一个自命名的文件夹，index文件负责在你的“自然组件”和外部世界之间牵线搭桥。我们称此文件为“容器”（灵感来自于 React Redux的容器组件概念：https://redux.js.org/basics/usage-with-react#presentational-and-container-components）。</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs sql" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">/PersonCard<br>&nbsp;&nbsp;-PersonCard.js&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">------&nbsp;the&nbsp;"natural"&nbsp;component</span><br>&nbsp;&nbsp;-index.js&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">-----------&nbsp;the&nbsp;"container"</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">容器：</span></strong><span style="font-size: 15px;">我们将容器定义为插入在你的自然组件和外部世界之间（负责连接这两部分）的一小段代码。因为这个原因，有时候我们也把这些“容器”叫做“injector （注入器）”。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">自然组件：</span></strong><span style="font-size: 15px;">如果你被要求一张照片，你的“自然组件”就是这些用来显示这张照片的代码，你不需要知道如何获得数据的细节，也不需要知道它在应用程序中的位置，所有你需要知道的是它应该起作用。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">外部世界：</span></strong><span style="font-size: 15px;">这里指的是你的应用程序所拥有的任何资源（例如Redux Store），而这些资源是可以被转换以满足你的自然组件的props。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">本文的目标</span></strong><strong><span style="font-size: 15px;">：</span></strong><span style="font-size: 15px;">我们如何编写“自然的”组件并确保它不会被来自外部世界的垃圾污染？为什么这样做更好？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"></span></p> 
<blockquote class="js_blockquote_wrap" data-type="2" data-url="" data-author-name="" data-content-utf8-length="234" data-source-title=""> 
 <section class="js_blockquote_digest"> 
  <section> 
   <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">备注：本文中的“容器”概念虽然是受到这两个链接（Dan Abramov和React Redux）中的术语的启发，但是本文中的“容器”定义略有不同。</span></p> 
   <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"></span></p> 
   <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">Dan Abramov的容器和本文中容器的唯一区别是在概念层面上。Dan在文章中说有两种组件：展示组件和容器组件。而本文我们更进一步，把它区分为组件和容器。</span></p> 
   <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">即使我们使用组件实现容器，我们也不会在概念层面将容器视为组件。这就是为什么我们建议将容器放在index文件中的原因，因为它是你的自然组件和外部世界之间的桥梁，并不是独立的。</span></p> 
  </section> 
 </section> 
</blockquote> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">你可能发现，本文的重点是关注组件，然而容器却占据了大半篇幅。为什么呢</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这是因为：编写自然组件更容易，更有趣。而让你的组件连接到外部世界（容器的工作）有点难度。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">依我看，导致你的“自然组件”被外部世界的垃圾污染的主要原因有三个：</span></p> 
<ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
 <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">奇怪的数据结构</span></p></li> 
 <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">超出组件范围的要求（如上例）</span></p></li> 
 <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">在组件挂载或更新时的事件触发</span></p></li> 
</ol> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">接下来，我将尝试用不同类型容器的实现示例，对上述三种情形进行阐述。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LwYnW1VvkaHWiaL6W1Mr1yiaNLQpxwhyqice9F1yJzMHticssPX515qyvog/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LwYnW1VvkaHWiaL6W1Mr1yiaNLQpxwhyqice9F1yJzMHticssPX515qyvog/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><span style="font-size: 18px;">使用奇怪的数据结构</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">有时候为了渲染所需要的信息，需要将不同类型的数据链接在一起，并将其转换成为更合理的格式。因为没有更合适的词，所以这里我用了“奇怪的”这个词。“奇怪的数据结构”就是那种让你的组件使用起来“不自然”的数据结构。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">将“奇怪的”数据结构直接传递到组件中，并在组件内部进行转换是非常诱人的，但这会导致混乱，并且常常使得组件测试很难进行。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;letter-spacing: 1px;">最近，当我被分配去创建一个组件，并从我们用来支持一个特定类型表单的特定数据结构中获取数据时，我发现自己落入了这个陷阱（示例如下）。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="font-size: 15px;"><img class="rich_pages" data-copyright="0" data-ratio="0.1559792027729636" data-src="https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAuhI8C5ClI5jSxetNJ4HTQcxgTDDt8NHM4suAD2Pkk8Yp5olyRZ7UcrD6FmUibDFVEBqnfxN7615uOw/640?wx_fmt=gif" data-type="gif" data-w="577" style="text-align: center;white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAuhI8C5ClI5jSxetNJ4HTQcxgTDDt8NHM4suAD2Pkk8Yp5olyRZ7UcrD6FmUibDFVEBqnfxN7615uOw/640?wx_fmt=gif"></span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs cs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">ChipField.propTypes&nbsp;=&nbsp;{<br>&nbsp;&nbsp;field:&nbsp;PropTypes.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">object</span>.isRequired,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;&lt;--&nbsp;the&nbsp;"weird"&nbsp;data&nbsp;structure</span><br>&nbsp;&nbsp;onEditField:&nbsp;PropTypes.func.isRequired,&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;&lt;--&nbsp;and&nbsp;a&nbsp;weird&nbsp;event&nbsp;too</span><br>};</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这个组件将这个奇怪的数据结构field作为一个props。事实上，如果我们后面不再用到这个组件的话，这样做是可以接受的。但是后来这个组件在一个与这个奇怪的数据结构无关的地方又用到了，这样它就成了一个真正的问题。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">因为组件需要这个数据结构，所以重用它变得不可能，重构它也很困难。我们最初编写的测试程序也令人困惑，因为模拟了这种奇怪的数据结构。我们无法理解这些测试程序，并且在最终重构时无法重新编写它们。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">不幸的是，奇怪的数据结构是不可避免的，但是使用容器是处理它们的一种很好的方法。我从这个例子学到的一点是，以这种方式构建组件，让你可以选择对组件进行提取，并将其转变为可重用的组件。但是如果你将一个奇怪的数据结构传递到一个组件中，你将失去这个选择。</span></p> 
<blockquote class="js_blockquote_wrap" data-type="2" data-url="" data-author-name="" data-content-utf8-length="100" data-source-title=""> 
 <section class="js_blockquote_digest"> 
  <section>
    注意：我并不是建议你所写的所有组件从一开始就应该是通用的。而是建议你想一想你的组件从根本上讲要实现什么，然后弥合间隙。如果你这样做了，您就会选择将你的组件转变为可重用的组件，这种转变需要的工作量很小。 
  </section> 
 </section> 
</blockquote> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 16px;"><strong>使用函数组件实现容器</strong></span><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">如果严格映射props，一个简单的实现方式是使用函数组件：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs javascript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;React&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'react'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;PropTypes&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'prop-types'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;getValuesFromField&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./helpers/getValuesFromField'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;transformValuesToField&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./helpers/transformValuesToField'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;ChipField&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./ChipField'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">export</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">default</span>&nbsp;<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">function</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">ChipFieldContainer</span>(<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">{&nbsp;field,&nbsp;onEditField&nbsp;}</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;values&nbsp;=&nbsp;getValuesFromField(field);<br><br>&nbsp;&nbsp;<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">function</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">handleOnChange</span>(<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">values</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;onEditField(transformValuesToField(values));<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="xml" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">ChipField</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">values</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">{values}</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">onChange</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">{handleOnChange}</span>&nbsp;/&gt;</span>;<br>}<br><br>//&nbsp;external&nbsp;props<br>ChipFieldContainer.propTypes&nbsp;=&nbsp;{<br>&nbsp;&nbsp;field:&nbsp;PropTypes.object.isRequired,<br>&nbsp;&nbsp;onEditField:&nbsp;PropTypes.func.isRequired,<br>};</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">组件的文件夹结构像下面这样：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs sql" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">/ChipField<br>&nbsp;&nbsp;-ChipField.js&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">------------------&nbsp;the&nbsp;"natural"&nbsp;chip&nbsp;field</span><br>&nbsp;&nbsp;-ChipField.test.js<br>&nbsp;&nbsp;-index.js&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">----------------------&nbsp;the&nbsp;"container"</span><br>&nbsp;&nbsp;-index.test.js<br>&nbsp;&nbsp;/helpers&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">-----------------------&nbsp;a&nbsp;folder&nbsp;for&nbsp;the&nbsp;helpers/utils</span><br>&nbsp;&nbsp;&nbsp;&nbsp;-getValuesFromField.js<br>&nbsp;&nbsp;&nbsp;&nbsp;-getValuesFromField.test.js<br>&nbsp;&nbsp;&nbsp;&nbsp;-transformValuesToField.js<br>&nbsp;&nbsp;&nbsp;&nbsp;-transformValuesToField.test.js</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">你可能在想“这种实现方式的要做的工作太多了”。你有这种想法很正常。是的，这里看起来要做的工作是多了，因为需要维护更多的文件，而且看上去也不那么直观。但是你可能忽视了一点：</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">其实真正的工作量并没有增加，不管你是在组件外部或者是在组件内部转换数据，需要的工作量其实都是一样的。区别只是在于，当你把数据转换放在组件外进行时，你就能够更准确地测试出你的数据转换是否正确，同时也分离了关注点。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lb4ybNEVGnaAvEDwENKzW27LUKFDGZPKcBneWwTaTpaJyG2C3em7libQ/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lb4ybNEVGnaAvEDwENKzW27LUKFDGZPKcBneWwTaTpaJyG2C3em7libQ/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><span style="font-size: 18px;">组件之外实现需求</span></strong><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">对于上面提到的PersonCard的示例，当你将组件开发的“黄金法则”应用其上时，你很可能会意识到某些需求超出了实际组件的范围。那么这些需求如何实现呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">你应该猜到了答案：对，使用容器。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">你可以通过创建容器来做一些额外的工作来保持组件的自然性。当你这样做的时候，你最终会得到一个更加简单而且功能单一的组件，和一个更好测试的容器。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">让我们用一个PersonCard容器的实现来举例说明。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 16px;"><strong>使用高阶组件实现容器</strong></span><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">React Redux使用高阶组件来实现从Redux Store推送和映射props的容器。因为“容器”这个术语是从React Redux得到来的，所以毫不奇怪，React Redux的connect就是一个容器。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">无论你是使用函数组件来映射props， 还是使用高阶组件connect到Redux Store，其中的黄金法则和容器的作用都是相同的。首先，编写你的自然组件，然后使用高阶组件来弥合间隙。</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs javascript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;{&nbsp;connect&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'react-redux'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;getPictureUrl&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./helpers/getPictureUrl'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;PersonCard&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./PersonCard'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;mapStateToProps&nbsp;=&nbsp;<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">(<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">state,&nbsp;ownProps</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;{&nbsp;person&nbsp;}&nbsp;=&nbsp;ownProps;<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;{&nbsp;name,&nbsp;jobTitle,&nbsp;customPictureUrl,&nbsp;officialPictureUrl&nbsp;}&nbsp;=&nbsp;person;<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;{&nbsp;preferOfficial&nbsp;}&nbsp;=&nbsp;state.settings;<br><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;pictureUrl&nbsp;=&nbsp;getPictureUrl(preferOfficial,&nbsp;customPictureUrl,&nbsp;officialPictureUrl);<br><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;{&nbsp;name,&nbsp;jobTitle,&nbsp;pictureUrl&nbsp;};<br>};<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;mapDispatchToProps&nbsp;=&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">null</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">export</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">default</span>&nbsp;connect(<br>&nbsp;&nbsp;mapStateToProps,<br>&nbsp;&nbsp;mapDispatchToProps,<br>)(PersonCard);</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">使用高阶组件的容器实现</span><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">上述实现的文件夹结构如下：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs sql" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">/PersonCard<br>&nbsp;&nbsp;-PersonCard.js&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">-----------------&nbsp;natural&nbsp;component</span><br>&nbsp;&nbsp;-PersonCard.test.js<br>&nbsp;&nbsp;-index.js&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">----------------------&nbsp;container</span><br>&nbsp;&nbsp;-index.test.js<br>&nbsp;&nbsp;/helpers<br>&nbsp;&nbsp;&nbsp;&nbsp;-getPictureUrl.js&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">------------&nbsp;helper</span><br>&nbsp;&nbsp;&nbsp;&nbsp;-getPictureUrl.test.js</code></pre> 
</section> 
<blockquote class="js_blockquote_wrap" data-type="2" data-url="" data-author-name="" data-content-utf8-length="109" data-source-title=""> 
 <section class="js_blockquote_digest"> 
  <section>
    注意：在这个示例中，/helpers文件夹里只有一个getPictureURL，真实情况应该还有其它helpers，这里只是演示你可以把这个逻辑分离出来。您还可能注意到，无论对于哪种容器实现，文件夹结构其实都是一样的。 
  </section> 
 </section> 
</blockquote> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">如果你有Redux的使用经验，你可能已经熟悉上面的示例。这里再重复一次，黄金法则不是一种全新的想法，而是对原有思维方式的一种微妙调整。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">此外，在你用高阶组件实现容器时，你还可以在功能上将高阶组件组合在一起，亦即你可以将props从一个高阶组件传递到下一个。在过去，我们曾经将多个高阶组件链接在一起，来实现单个容器。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"></span></p> 
<section> 
 <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">备注：React社区似乎有正在远离高阶组件的趋势。</span></p> 
 <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">我也会推荐同这样做。我从使用高阶组件得来的经验是，对于不熟悉函数组件的团队成员来说，它们可能会令人困惑，并且会导致所谓的“封装地狱”，即组件被封装太多次，从而导致严重的性能问题。</span></p> 
 <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这里我列出一些相关的文章和资源供参考：</span></p> 
 <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
  <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">Hooks talk (2018) ：https://youtu.be/dpw9EHDh2bM?t=710</span></p></li> 
  <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">Recompose talk (2016) ：https://youtu.be/zD_judE-bXk?t=1101</span></p></li> 
  <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">Use a Render Prop! (2017)：https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce</span></p></li> 
  <li> 
   <section class="js_blockquote_digest"> 
    <section> 
     <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">When to NOT use Render Props (2018)：https://blog.kentcdodds.com/when-to-not-use-render-props-5397bbeff746</span></p> 
    </section> 
   </section></li> 
 </ul> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">好了，到了我们谈谈React Hooks(钩子)的时候了。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LLqyf6BY4rMfY2LsU81MibFjicKDLjMjib5R23h8uo6GtGDY8OufWJfpEw/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LLqyf6BY4rMfY2LsU81MibFjicKDLjMjib5R23h8uo6GtGDY8OufWJfpEw/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><span style="font-size: 18px;">使用hooks实现容器</span></strong><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">你可能问为什么本文要讨论Hooks, 原因是使用Hooks来实现容器要容易得多。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">如果你还不熟悉React Hooks，那么我建议你观看Dan Abramov和Ryan Florence在React 2018大会上的演讲视频，视频中有React Hooks的概念介绍（https://youtu.be/dpw9EHDh2bM）。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">简而言之，React团队引入Hooks是为了应对高阶组件以及类似的模式带来的问题。React Hooks旨在替代它们，成为大多数场景下的最佳解决方案。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这意味着我们可以通过使用一个函数组件和Hooks来实现容器。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">在下面的示例中，我们使用了useRoute和useRedux这两个Hooks来表示“外部世界”，我们使用getValues这个helper将“外部世界”映射为你的自然组件可用的props。我们还使用transformValues这个helper将组件的输出转换为由dispatch表示的外部世界。</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs javascript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;React&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'react'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;PropTypes&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'prop-types'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;{&nbsp;useRouter&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'react-router'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'react-redux'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;actionCreator&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'your-redux-stuff'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;getValues&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./helpers/getVaules'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;transformValues&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./helpers/transformValues'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;FooComponent&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./FooComponent'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">export</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">default</span>&nbsp;<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">function</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">FooComponentContainer</span>(<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">props</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;hooks</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;{&nbsp;match&nbsp;}&nbsp;=&nbsp;useRouter({&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">path</span>:&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">/*&nbsp;...&nbsp;*/</span>&nbsp;});<br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;<span class="hljs-doctag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">NOTE:</span>&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won't&nbsp;look&nbsp;like&nbsp;this</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();<br><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;mapping</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);<br><br>&nbsp;&nbsp;<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">function</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">handleChange</span>(<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">e</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;transformed&nbsp;=&nbsp;transformValues(e);<br>&nbsp;&nbsp;&nbsp;&nbsp;dispatch(actionCreator(transformed));<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;natural&nbsp;component</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="xml" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">FooComponent</span>&nbsp;{<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">...props</span>}&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">onChange</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">{handleChange}</span>&nbsp;/&gt;</span>;<br>}<br><br>FooComponentContainer.propTypes&nbsp;=&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;};</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="font-size: 14px;color: rgb(136, 136, 136);">使用hooks来实现容器</span><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">参考文件夹结构如下：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs lua" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">/FooComponent&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">-----------&nbsp;the&nbsp;whole&nbsp;component&nbsp;for&nbsp;others&nbsp;to&nbsp;import</span><br>&nbsp;&nbsp;-FooComponent.js&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">------&nbsp;the&nbsp;"natural"&nbsp;part&nbsp;of&nbsp;the&nbsp;component</span><br>&nbsp;&nbsp;-FooComponent.test.js<br>&nbsp;&nbsp;-index.js&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">-------------&nbsp;the&nbsp;"container"&nbsp;that&nbsp;bridges&nbsp;the&nbsp;gap</span><br>&nbsp;&nbsp;-index.js.test.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">and</span>&nbsp;provides&nbsp;dependencies<br>&nbsp;&nbsp;/helpers&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">--------------&nbsp;isolated&nbsp;helpers&nbsp;that&nbsp;you&nbsp;can&nbsp;test&nbsp;easily</span><br>&nbsp;&nbsp;&nbsp;&nbsp;-getValues.js<br>&nbsp;&nbsp;&nbsp;&nbsp;-getValues.test.js<br>&nbsp;&nbsp;&nbsp;&nbsp;-transformValues.js<br>&nbsp;&nbsp;&nbsp;&nbsp;-transformValues.test.js</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LzUzfol6q1COlZYpeYXqe0aia45DXyhcTQW8voWvibFJvEjfmkhPvCrEg/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LzUzfol6q1COlZYpeYXqe0aia45DXyhcTQW8voWvibFJvEjfmkhPvCrEg/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><span style="font-size: 18px;">容器内触发事件</span></strong><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">最后一种背离自然组件的情形，通常发生在需要触发一个与组件挂载和更新组件props相关的事件的时候。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">举个例子，你的任务是开发一个“仪表板”的功能。设计团队给了一个“仪表板”的模板，你把它转换成一个React组件。现在，您必须用数据填充这个“仪表板”。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">你发现，当你挂载这个组件，你需要调用一个函数(例如dispatch(fetchAction))，来得到这些数据。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">在这个场景中，我添加了componentDidMount和componentDidUpdate两个生命周期方法，并添加了onMount或onDashboardIdChanged两个props，因为我需要一些事件来触发，以便将组件和外部世界链接起来。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">按照黄金法则，onMount和onDashboardIdChanged这两个props是“不自然”的，因此应该放在容器中。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">使用Hooks的好处在于，它使得在组件挂载（onMount）或者组件props更新时的事件分发变得更简单！</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">组件挂载时的事件触发：</span></strong><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">若要在组件挂载时触发一个事件，就需要使用一个空的数组作为传入参数来调用Hook useEffect（如下图）。</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs javascript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;React,&nbsp;{&nbsp;useEffect&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'react'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;PropTypes&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'prop-types'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'react-redux'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;fetchSomething_reduxAction&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'your-redux-stuff'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;getValues&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./helpers/getVaules'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;FooComponent&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./FooComponent'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">export</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">default</span>&nbsp;<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">function</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">FooComponentContainer</span>(<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">props</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;hooks</span><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;<span class="hljs-doctag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">NOTE:</span>&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won't&nbsp;look&nbsp;like&nbsp;this</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();<br><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;dispatch&nbsp;action&nbsp;onMount</span><br>&nbsp;&nbsp;useEffect(<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;dispatch(fetchSomething_reduxAction);<br>&nbsp;&nbsp;},&nbsp;[]);&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;the&nbsp;empty&nbsp;array&nbsp;tells&nbsp;react&nbsp;to&nbsp;only&nbsp;fire&nbsp;on&nbsp;mount</span><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects</span><br><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;mapping</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);<br><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;natural&nbsp;component</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="xml" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">FooComponent</span>&nbsp;{<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">...props</span>}&nbsp;/&gt;</span>;<br>}<br><br>FooComponentContainer.propTypes&nbsp;=&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;};</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="font-size: 14px;color: rgb(136, 136, 136);">使用Hooks的组件挂载时的容器内触发事件</span><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 16px;"><strong>组件prop更新时的事件触发：</strong></span><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">useEffect这个Hook能够在重新渲染和属性更新时调用你提供的函数之间，检查属性的变化。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">在使用Hook useEffect之前，我发现自己在组件中添加了“不自然”的生命周期方法和OnPropertyChanged属性，因为我没有什么办法在组件外部比较属性的差异（示例如下）：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs javascript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;React&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'react'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;PropTypes&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'prop-types'</span>;<br><br><span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">/**<br>&nbsp;*&nbsp;Before&nbsp;`useEffect`,&nbsp;I&nbsp;found&nbsp;myself&nbsp;adding&nbsp;"unnatural"&nbsp;props<br>&nbsp;*&nbsp;to&nbsp;my&nbsp;components&nbsp;that&nbsp;only&nbsp;fired&nbsp;events&nbsp;when&nbsp;the&nbsp;props&nbsp;diffed.<br>&nbsp;*<br>&nbsp;*&nbsp;I'd&nbsp;find&nbsp;that&nbsp;the&nbsp;component's&nbsp;`render`&nbsp;didn't&nbsp;even&nbsp;use&nbsp;`id`<br>&nbsp;*&nbsp;most&nbsp;of&nbsp;the&nbsp;time<br>&nbsp;*/</span><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">export</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">default</span>&nbsp;<span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">BeforeUseEffect</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">extends</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">React</span>.<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">Component</span>&nbsp;</span>{<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">static</span>&nbsp;propTypes&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">id</span>:&nbsp;PropTypes.string.isRequired,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">onIdChange</span>:&nbsp;PropTypes.func.isRequired,<br>&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;componentDidMount()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.props.onIdChange(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.props.id);<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;componentDidUpdate(prevProps)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;(prevProps.id&nbsp;!==&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.props.id)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.props.onIdChange(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.props.id);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;render()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;...</span><br>&nbsp;&nbsp;}<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">旧方法: 使用类来实现属性更新时的事件触发</span><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">现在有了Hook useEffect，就有了一种非常轻量级的方法来实现prop更新时的事件触发，而不需要在真实组件中添加不必要的props（示例如下）。</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs javascript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;React,&nbsp;{&nbsp;useEffect&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'react'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;PropTypes&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'prop-types'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;{&nbsp;useRedux&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'react-redux'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;fetchSomething_reduxAction&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'your-redux-stuff'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;getValues&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./helpers/getVaules'</span>;<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;FooComponent&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">from</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'./FooComponent'</span>;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">export</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">default</span>&nbsp;<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">function</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">FooComponentContainer</span>(<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">{&nbsp;id&nbsp;}</span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;hooks</span><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;<span class="hljs-doctag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">NOTE:</span>&nbsp;`useRedux`&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet&nbsp;and&nbsp;probably&nbsp;won't&nbsp;look&nbsp;like&nbsp;this</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;{&nbsp;state,&nbsp;dispatch&nbsp;}&nbsp;=&nbsp;useRedux();<br><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;dispatch&nbsp;action&nbsp;onMount</span><br>&nbsp;&nbsp;useEffect(<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;dispatch(fetchSomething_reduxAction);<br>&nbsp;&nbsp;},&nbsp;[id]);&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;`useEffect`&nbsp;will&nbsp;watch&nbsp;this&nbsp;`id`&nbsp;prop&nbsp;and&nbsp;fire&nbsp;the&nbsp;effect&nbsp;when&nbsp;it&nbsp;differs</span><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects</span><br><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;mapping</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;props&nbsp;=&nbsp;getValues(state,&nbsp;match);<br><br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;natural&nbsp;component</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="xml" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">FooComponent</span>&nbsp;{<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">...props</span>}&nbsp;/&gt;</span>;<br>}<br><br>FooComponentContainer.propTypes&nbsp;=&nbsp;{<br>&nbsp;&nbsp;id:&nbsp;PropTypes.string.isRequired,<br>};</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">新方法：使用hook useEffect来实现属性更新时的事件触发</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: justify;"><span style="text-align: justify;font-size: 15px;">免责声明：除了使用useEffect这个hook,也有其它一些方法可以在容器内使用其他高阶组件（如recompose’s lifecycle的示例：https://github.com/acdlite/recompose/blob/3db12ce7121a050b533476958ff3d66ded1c4bb8/docs/API.md#lifecycle）来比较prop的差异，或者创建一个生命周期组件（如react router内部实现的示例：https://github.com/ReactTraining/react-router/blob/89a72d58ac55b2d8640c25e86d1f1496e4ba8d6c/packages/react-router/modules/Lifecycle.js），但这些方法要么让团队成员感到困惑，要么是非常规做法。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="text-align: justify;font-size: 15px;"><br></span><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L8DRknQu3FB9eZicibvOSlVrgnllB3XcGnsrw4zCk19ic0QjZkTPoqFMWw/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L8DRknQu3FB9eZicibvOSlVrgnllB3XcGnsrw4zCk19ic0QjZkTPoqFMWw/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><span style="font-size: 18px;">这样做的好处是什么？</span></strong><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 16px;"><strong>享受组件开发的乐趣</strong></span><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">对我来说，组件开发是前端开发中最有趣和最令人开心的部分。你可以把你的团队的想法和梦想变成真实的体验，这是一种很好的感觉，我认为我们应该在团队内分享，因为这和我们每个人都是相关的。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">你的组件API和体验被“外部世界”破坏的场景永远不会出现。你的组件正如你想要的那样，没有额外的props, 这是我最喜欢的黄金法则的地方。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 16px;"><strong>更多测试和重用的机会</strong></span><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">采用这样的体系结构，你基本上是在渲染时引入了一个新的数据层。而在这个“层”中，你可以将你的关注点在进入组件的数据的正确性和组件的工作方式之间进行切换。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">不管你是否知道，这个层已经存在于你的应用程序中，但是它可能与表现逻辑结合在一起。我发现，当我渲染这一层时，我可以进行大量的代码优化，并重用大量的逻辑，否则我可能在不知道共性的情况下重复编写这些逻辑。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">通过添加一些定制的Hooks，这些好处将变得更加明显。定制的Hooks为我们提供了一种更简单的方法来提取逻辑并支持外部更新，而这是helper函数无法做到的。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 16px;"><strong>最大化团队产出</strong></span><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">当一个团队共同工作时，你可以将容器开发和组件开发的工作分配给不同的团队成员。如果API的规格已经确定，那么下面三部分的开发工作可以同步进行：</span></p> 
<ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
 <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">Web API（如后端）开发</span></p></li> 
 <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">编写从Web API（或类似）获取数据，并将数据转换为组件的API</span></p></li> 
 <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">组件开发</span></p></li> 
</ol> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LFV97HltQYlNPKDzX97K1Ll0EicLrBIuWQtgLtQYdFKkkLcWKGUeMTfg/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LFV97HltQYlNPKDzX97K1Ll0EicLrBIuWQtgLtQYdFKkkLcWKGUeMTfg/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><span style="font-size: 18px;">有例外情形吗？</span></strong><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">就像真正的黄金法则一样，这里的黄金法则也是一个黄金拇指法则。在某些场景，编写看似不自然的组件API以降低某些转换的复杂性也是一种合理的做法。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">一个简单的例子是props的名称。如果开发人员以更“自然”的理由来对props重命名，那么将使事情变得更复杂。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">过分地强调这个法则是可能发生的，结果是你可能陷入困境。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lf6AGBpotDb1DGltQgly1vKzgCCOtT3OQn43luu8r1JxUV1PmiaSAViaw/640?wx_fmt=png" data-type="png" data-w="160" style="text-align: center;white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lf6AGBpotDb1DGltQgly1vKzgCCOtT3OQn43luu8r1JxUV1PmiaSAViaw/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><strong><span style="font-size: 18px;">结束语</span></strong><span style="font-size: 15px;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">本文的“黄金法则”只是以一个新的角度，对展示组件和容器组件的现有概念的重新阐述。如果你能清楚你的组件到底要做什么，那么你可能会得到更简单易读的部分！</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;color: rgb(136, 136, 136);">原文：https://medium.freecodecamp.org/how-the-golden-rule-of-react-components-can-help-you-write-better-code-127046b478eb</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;line-height: 1.75em;letter-spacing: 1px;"><span style="letter-spacing: 1px;background-color: rgb(255, 255, 255);font-size: 15px;color: rgb(136, 136, 136);">本文为CSDN翻译，转载请注明来源出处。</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.5482233502538071" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAug39yByOmcISc1L0Exsb7CNugP5wV0jXZJO3A5phGZmodPk0Kic8270crj5QPOpzthxcuiaa8EhX8vg/640?wx_fmt=jpeg" data-type="jpeg" data-w="591" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAug39yByOmcISc1L0Exsb7CNugP5wV0jXZJO3A5phGZmodPk0Kic8270crj5QPOpzthxcuiaa8EhX8vg/640?wx_fmt=jpeg"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">作为码一代，想教码二代却无从下手：</span><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">听说少儿编程很火，可它有哪些好处呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">孩子多大开始学习比较好呢？又该如何学习呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">最新的编程教育政策又有哪些呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">下面给大家介绍CSDN新成员：<strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">极客宝宝（ID：</strong><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">geek_baby）</strong></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);text-align: center;line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">戳他了解更多↓↓↓</span></strong><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);text-align: center;line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><img class="rich_pages " data-copyright="0" data-cropselx1="180" data-cropselx2="438" data-cropsely1="0" data-cropsely2="258" data-ratio="0.3697916666666667" data-s="300,640" data-type="jpeg" data-w="960" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vbbgCLnCbTPs0mGuVrLHntraYT5MIPrhkqQCmnqobLOf7nkWPh5j6vw/640?wx_fmt=jpeg" style="box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;visibility: visible !important;width: 618px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vbbgCLnCbTPs0mGuVrLHntraYT5MIPrhkqQCmnqobLOf7nkWPh5j6vw/640?wx_fmt=jpeg"></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);text-align: center;letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;background-color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">&nbsp;热 文</strong>&nbsp;推 荐&nbsp;</strong></span></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=Mzg3MDA4NDkxMQ==&amp;mid=2247483883&amp;idx=1&amp;sn=7af3d0e822e979583e9f9a5d515c26ab&amp;chksm=ce9279abf9e5f0bdba5b84c77d487bd84e71da35bb9d8e1e95769d7e62f3cfe5f83cccec7ec2&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="color: rgb(0, 82, 255);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">☞</a></span><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650718694&amp;idx=1&amp;sn=2494bd59866aa70454d325f8d45caf5d&amp;chksm=bea6b03589d1392364e078d984f8a34aa22502565ac64677ebf47ea918b9b2c99e1467f31983&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">为什么雷军指责“华为不懂研发”？</span><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">| 畅言</span></a><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=Mzg3MDA4NDkxMQ==&amp;mid=2247483883&amp;idx=1&amp;sn=7af3d0e822e979583e9f9a5d515c26ab&amp;chksm=ce9279abf9e5f0bdba5b84c77d487bd84e71da35bb9d8e1e95769d7e62f3cfe5f83cccec7ec2&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="color: rgb(0, 82, 255);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">☞</a></span><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650718694&amp;idx=3&amp;sn=821144e7434131fdf61765320f0c8cde&amp;chksm=bea6b03589d139235d9a3e1f508d3e491e98bf87052d1658fcfa520ba8553364e2d03fc4857b&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">抛弃 VS Code 我还能用啥编辑器？</span><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">| 技术头条</span></a><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=Mzg3MDA4NDkxMQ==&amp;mid=2247483883&amp;idx=1&amp;sn=7af3d0e822e979583e9f9a5d515c26ab&amp;chksm=ce9279abf9e5f0bdba5b84c77d487bd84e71da35bb9d8e1e95769d7e62f3cfe5f83cccec7ec2&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="color: rgb(0, 82, 255);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">☞</a></span><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650718661&amp;idx=4&amp;sn=f95a6b267abf9a70b477cd2e9b67ffcb&amp;chksm=bea6b01689d13900c5965193bd2672a8580a88df11bf5642d5658b96e46d1c6448beaa808170&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="color: rgb(0, 82, 255);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;font-size: 14px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">如何看待程序员“面试造火箭、工作拧螺丝”？</span></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650718661&amp;idx=4&amp;sn=f95a6b267abf9a70b477cd2e9b67ffcb&amp;chksm=bea6b01689d13900c5965193bd2672a8580a88df11bf5642d5658b96e46d1c6448beaa808170&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="color: rgb(0, 82, 255);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;font-size: 14px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">| 畅言</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=Mzg3MDA4NDkxMQ==&amp;mid=2247483883&amp;idx=1&amp;sn=7af3d0e822e979583e9f9a5d515c26ab&amp;chksm=ce9279abf9e5f0bdba5b84c77d487bd84e71da35bb9d8e1e95769d7e62f3cfe5f83cccec7ec2&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">☞斯坦福区块链匪帮传奇，那些睡地毯、没日没夜写代码的编程少年</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&amp;mid=2651010412&amp;idx=1&amp;sn=3b4369d5b8b6cb4e2c03dd05271c6378&amp;chksm=8bad869bbcda0f8d6d39aa1622c3f02a578d08786fc883e2ecd61f576d1ea9c9fd91f4aa3cf8&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">☞程序员逆袭为美国最佳 CEO，他说因为爱情</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&amp;mid=2247504538&amp;idx=1&amp;sn=dc672ba34b2203a126def345e48b8168&amp;chksm=e99ee163dee96875e5216901dd0dd779d204f88145acd6a3f4e5bd3e2c18a51e2eefe69e5171&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">☞开什么玩笑？股票价格如何经得起AI的推敲？| 技术头条</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzA3MjY1MTQwNQ==&amp;mid=2649827271&amp;idx=2&amp;sn=fe08c701d4c3b2001132f1411033d936&amp;chksm=871e8025b069093368b438766d68b7d038c67cdad7f6e0dd2597f3bbb117ace6c2d182d2fa86&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">☞云计算之基，一文带你速懂虚拟化KVM和XEN</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzA5MjcxNjc2Ng==&amp;mid=2650559766&amp;idx=1&amp;sn=fb6e44a97e108113a772c6c2bba25289&amp;chksm=88601ea7bf1797b117aa0625a3efa316fa660eb90654a96013c14a03c4eb3a71bb75b6bab646&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;">☞程序员被骗"黑砖窑"：</span><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;">监禁、恐吓、996无休编程！</span></a></span></p> 
<section style="max-width: 100%;letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
 <section class="" style="max-width: 100%;font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
  <pre style="max-width: 100%;font-size: inherit;color: inherit;line-height: inherit;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;padding: 0.5em;max-width: 100%;min-height: 1em;font-size: 14px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;background: rgb(34, 34, 34);color: rgb(170, 170, 170);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">System.out.println(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个在看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">console.log(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(50, 170, 238);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: inherit !important;word-break: inherit !important;">print</span>(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(50, 170, 238);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: inherit !important;word-break: inherit !important;">printf</span>(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">在</span>看吧！\n"</span>);<br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">cout&nbsp;&lt;&lt;&nbsp;<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">在</span>看吧！"</span>&nbsp;&lt;&lt;&nbsp;endl;<br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">Console.WriteLine(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">Response.Write(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">alert(</span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;color: rgb(255, 204, 51);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">在</span>看吧！"</span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">)</span><br style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;font-variant-numeric: normal;line-height: inherit;widows: 1;color: rgb(50, 170, 238);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: inherit !important;word-break: inherit !important;">echo </span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;color: rgb(255, 204, 51);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">在</span>看吧！"</span></p></pre> 
 </section> 
</section> 
<p style="margin: 15px 8px;max-width: 100%;min-height: 1em;white-space: normal;background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height: 1.75em;letter-spacing: 1px;text-align: left;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><img class="__bg_gif" data-ratio="0.8" data-type="gif" data-w="200" title="" data-src="https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAujr9dOtwUGfl03zJzLBRXbZs8g1RcNcLr7qm5qEy419tofZ8dq1sIW75xZwq2K4zIzcTtaDOy4OTg/640?wx_fmt=gif" style="box-sizing: border-box;font-family: 微软雅黑;font-size: 16px;letter-spacing: 0.544px;vertical-align: middle;word-wrap: break-word !important;overflow-wrap: break-word !important;visibility: visible !important;width: 45px !important;" width="45" height="" border="0" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAujr9dOtwUGfl03zJzLBRXbZs8g1RcNcLr7qm5qEy419tofZ8dq1sIW75xZwq2K4zIzcTtaDOy4OTg/640?wx_fmt=gif"><strong style="max-width: 100%;color: rgb(55, 55, 93);font-family: 微软雅黑;font-size: 16px;letter-spacing: 0.544px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 1px;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;widows: 1;box-sizing: border-box !important;word-wrap: break-word !important;">点击阅读原文，输入关键词，即可搜索您想要的 CSDN 文章。</span></strong></strong></p> 
<section class="" data-tools="135编辑器" data-id="94250" style="max-width: 100%;box-sizing: border-box;letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);border-width: 0px;border-style: none;border-color: initial;overflow-wrap: break-word !important;"> 
 <section class="" data-tools="135编辑器" data-id="91842" style="max-width: 100%;box-sizing: border-box;border-width: 0px;border-style: none;border-color: initial;text-align: right;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
  <section style="max-width: 100%;display: inline-block;clear: both;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
   <section class="" data-brushtype="text" style="padding: 18px 15px 20px 10px;max-width: 100%;box-sizing: border-box;color: rgb(86, 146, 214);background-image: url(&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdy66AHd7QqL7A2s5icSBE0aw4iaKOKPnXGYxQPhG7VMpbbYV6VJprSh7w/640?wx_fmt=png&quot;);background-repeat: no-repeat;text-align: center;background-size: 100% 100%;font-size: 16px;letter-spacing: 1.5px;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
    <section style="max-width: 100%;display: flex;justify-content: center;align-items: center;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
     <section style="margin-left: 2px;max-width: 100%;width: 20px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
      <img class="" data-ratio="0.8936170212765957" data-type="png" data-w="47" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdvAd0o9e1LlUGA2k0Yib222agOxzweXhahA9GuzJcGBg0dA4DzlibxRqw/640?wx_fmt=png" style="margin-bottom: -6px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;visibility: visible !important;width: 20px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdvAd0o9e1LlUGA2k0Yib222agOxzweXhahA9GuzJcGBg0dA4DzlibxRqw/640?wx_fmt=png"> 
     </section> 
     <section class="" data-brushtype="text" style="max-width: 100%;font-size: 14px;color: rgb(51, 51, 51);text-align: right;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
      <span style="max-width: 100%;font-family: 楷体, 楷体_GB2312, SimKai;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">你点的每个“在看”，我都认真当成了喜欢</span> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
