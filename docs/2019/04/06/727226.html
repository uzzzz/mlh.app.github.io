<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>蚂蚁区块链第11课 以租房积分管理系统为例讲透蚂蚁Solidity语言差异精要 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="蚂蚁区块链第11课 以租房积分管理系统为例讲透蚂蚁Solidity语言差异精要" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：如需转载，请私信联系作者。 https://blog.csdn.net/wangdenghui2005/article/details/89060692 1，摘要 本文以住房租赁积分管理系统为例，给大家演示CLOUD IDE如何编译调试solidity智能合约，并以此为例，给大家分享以太坊SOLIDITY跟蚂蚁区块链SOLIDITY语言的差异点。 2，住房租赁积分管理系统的背景和目标 背景 基于区块链智能合约的住房租赁积分管理系统旨在有效地服务于公众群体、市民，真正让那些为城市当前发展做出努力的人有房住、租得起，让那些为城市建设长远发展做出贡献的人有房产、买得起。为此，建立住房租赁积分制度，从住房租赁市场主体属性、政策激励、租赁行为三方面，运用区块链、大数据等前沿技术，建立科学、有效的住房租赁积分全生命周期管理机制，营造活力、健康、有序、可持续的住房租赁生态。 目标 通过使用区块链平台作为底层数据支撑，确保隐私保护和数据不可篡改，达到公平、公正、透明的目的；利用积分决策引擎，结合住房租赁积分评价体系，产出应用于住房租赁场景的综合积分方案。该方案具备横向扩展性，在底层技术、数据不变的基础上，未来能够支撑经济信用积分、绿色生活积分等诸多积分体系的建设，从而扩展形成城市信用体系，应用于如医疗教育、金融借贷、绿色生活等诸多场景。 3，合约设计 权限管理 在住房租赁积分管理系统中，主要分为 4 种角色，分别是管理者、操作者、观察者以及市民。管理者、操作者、观察者是智能合约的操作人员，每个角色可以对应多名人员。市民是租赁积分智能合约服务的对象，是整个智能合约的核心用户。 角色操作权限 管理者是合约的超级管理员，能够对管理者、操作者以及观察者进行添加、删除、查询操作。 操作者可以查询操作者信息。 观察者可以查询观察者信息。 积分操作权限 管理者：具有积分奖励、积分查询、积分转移、积分违规扣除、积分权益兑换等积分操作权限。 操作者：操作者是由管理者设置的积分操作角色，该角色可以是具体的人员也可以是系统服务，具有积分奖励、积分转移、积分违规扣除、积分权益兑换等积分操作权限。 观察者：观察者是由管理者设置的积分查询角色，该角色可以是具体的人员也可以是系统服务，具有积分查询的操作权限。 市民：市民是住房租赁积分系统的用户，是住房租赁积分系统的实际权益对象。 市民可以通过组织机构的租赁积分外部服务系统代理的观察者权限查看自己的积分状况。 租赁积分外部服务系统会根据市民的合规表现，通过操作者的权限进行积分奖励或积分违规扣除。 市民可以通过租赁积分外部服务系统代理的操作者权限进行积分权益兑换或积分转移操作。 积分管理 租赁积分智能合约提供的服务方法包括 积分奖励、积分查询、积分权益兑换、积分违规扣除、积分转移 以及积分达到阈值后触发 积分事件。 积分奖励（awardScore） 在市民租赁房屋的过程中，针对租赁的时间、租赁过程中产生的行为，为市民进行积分累计。 积分查询（queryScore） 市民可通过租赁积分外部服务系统代理的观察者权限查看自己的积分状况。 积分权益兑换（exchangeScore） 市民的积分达到指定阈值后可以享有相应的权益，如租房优惠、买房资格、落户资格等。 积分违规扣除（deductScore） 在市民租赁房屋的过程中，针对租赁过程中产生的错误行为，对市民惩罚性的扣减积分。住房租赁积分作为正向激励的积分体系，鼓励民众积极向上。对于积分主体的伪造资料行为，视情节严重程度扣减积分、取消积分资格以及收回积分对应的权益。 积分事件（SCORE_EQUITY_NOTICE） 当积分权益实时增加时，会触发积分权益检查。若积分达到了指定的阈值，则会产生相应的积分权益通知事件。通过外部服务系统通知到具体的市民。 积分转移（transferScore） 当市民因工作关系、家庭因素需要到其他城市生活时，可以将该城市的积分转移到目标城市的积分系统。为满足该合约的调用，目标合约需要有对应的积分奖励方法（awardScore），且需要为发起合约提供操作权限，即将发起合约的地址设置为操作者或管理员。 4，智能合约代码 pragma solidity ^0.4.20; contract LeasingScoreManager { identity[] adminList; identity[] observerList; identity[] calculatorList; //用于记录管理数组被置位元素 uint adminDeled; uint observerDeled; uint calculatorDeled; mapping (bytes32 =&gt; uint) leasingScore; enum ScoreAction { //奖励积分， 因相关行为，进行积分奖励 ActionAwardScore, //积分权益兑换，花费指定积分 ActionExchangeScore, //扣除积分， 因违规等， 扣除积分 ActionDeductScore, //查询积分 ActionQueryScore //积分转移, 将积分转移到其他的合约。 } enum UserRole { RoleAdmin, //管理员 RoleCalculator, //积分操作员 RoleObserver, //积分查看人员 RolePlayer //积分参与者 } //是否为有效的操作人 event VALID(bool valid, UserRole role); //admin/observer/calculator 用户存在 event USER_EXIST(bool exist, UserRole role); //积分事件 event SCORE_OPERATOR(ScoreAction action, string describe); //积分操作错误 event SCORE_ERROR(ScoreAction action, string describe); //积分权益通知 event SCORE_EQUITY_NOTICE(string action, uint score, string describe); constructor() public { adminList.push(msg.sender); adminList.push(this); } function indexAdmin(identity admin) view returns (uint) { for (uint i = 0; i &lt; adminList.length; i++) { if (adminList[i] == admin) { return i; } } return adminList.length; } function validAdmin(identity admin) view returns (bool) { return indexAdmin(admin) &lt; adminList.length; } function indexCalculator(identity calculator) view returns (uint) { for (uint i = 0; i &lt; calculatorList.length; i++) { if (calculatorList[i] == calculator) { return i; } } return calculatorList.length; } function validCalculator(identity calculator) view returns (bool) { return indexCalculator(calculator) &lt; calculatorList.length; } function indexObserver(identity observer) view returns (uint) { for (uint i = 0; i &lt; observerList.length; i++) { if (observerList[i] == observer) { return i; } } return observerList.length; } function validObserver(identity observer) view returns (bool) { return indexObserver(observer) &lt; observerList.length; } modifier onlyAdmin { bool isValid = validAdmin(msg.sender); emit VALID(isValid, UserRole.RoleAdmin); require(isValid); _; } modifier onlyCalculatorOrAdmin { bool isValid = validAdmin(msg.sender); if(isValid) { emit VALID(isValid, UserRole.RoleAdmin); } else { isValid = validCalculator(msg.sender); emit VALID(isValid, UserRole.RoleCalculator); } require(isValid); _; } modifier onlyObserverOrAdmin { bool isValid = validAdmin(msg.sender); if(isValid) { emit VALID(isValid, UserRole.RoleAdmin); } else { isValid = validObserver(msg.sender); emit VALID(isValid, UserRole.RoleObserver); } require(isValid); _; } function addAdmin(identity admin) public onlyAdmin { bool isExist = validAdmin(admin); emit USER_EXIST(isExist, UserRole.RoleAdmin); require(!isExist); if(adminDeled &gt; 0) { uint deled = 1; for (uint i = 0; i &lt; adminList.length; i++) { if(deled&amp;adminDeled != 0) { adminList[i] = admin; adminDeled ^= deled; break; } deled &lt;&lt;= 1; } } else { adminList.push(admin); } } function removeAdmin(identity admin) public onlyAdmin { uint index = indexAdmin(admin); bool isValid = index != adminList.length; emit USER_EXIST(isValid, UserRole.RoleAdmin); require(isValid); delete adminList[index]; adminDeled ^= 1 &lt;&lt; index; } function queryAdmins() view public onlyAdmin returns (identity[]) { return adminList; } function addCalculator(identity calculator) public onlyAdmin { bool isExist = validCalculator(calculator); emit USER_EXIST(isExist, UserRole.RoleCalculator); require(!isExist); if(calculatorDeled &gt; 0) { uint deled = 1; for (uint i = 0; i &lt; calculatorList.length; i++) { if(deled&amp;calculatorDeled != 0) { calculatorList[i] = calculator; calculatorDeled ^= deled; break; } deled &lt;&lt;= 1; } } else { calculatorList.push(calculator); } } function removeCalculator(identity calculator) public onlyAdmin { uint index = indexCalculator(calculator); bool isValid = index &lt; calculatorList.length; emit USER_EXIST(isValid, UserRole.RoleCalculator); require(isValid); delete calculatorList[index]; calculatorDeled ^= 1 &lt;&lt; index; } function queryCalculators() view public onlyCalculatorOrAdmin returns (identity[]) { return calculatorList; } function addObserver(identity observer) public onlyAdmin { bool isExist = validObserver(observer); emit USER_EXIST(isExist, UserRole.RoleObserver); require(!isExist); if(observerDeled &gt; 0) { uint deled = 1; for (uint i = 0; i &lt; observerList.length; i++) { if(deled&amp;observerDeled != 0) { observerList[i] = observer; observerDeled ^= deled; break; } deled &lt;&lt;= 1; } } else { observerList.push(observer); } } function removeObserver(identity observer) public onlyAdmin { uint index = indexCalculator(observer); bool isValid = index &lt; observerList.length; emit USER_EXIST(isValid, UserRole.RoleObserver); require(isValid); delete observerList[index]; observerDeled ^= 1 &lt;&lt; index; } function queryObservers() view public onlyObserverOrAdmin returns (identity[]) { return observerList; } function checkScoreEquity(uint balance, uint score) { uint total = balance + score; if(total &gt;= 100 &amp;&amp; balance &lt; 100) { emit SCORE_EQUITY_NOTICE(&quot;RentConcessions&quot;, total, &quot;Citizens enjoy a 90% discount on rental housing&quot;); } if(total &gt;= 200 &amp;&amp; balance &lt; 200) { emit SCORE_EQUITY_NOTICE(&quot;RentConcessions_1&quot;, total, &quot;Citizens enjoy a 80% discount on rental housing&quot;); } if(total &gt;= 300 &amp;&amp; balance &lt; 300) { emit SCORE_EQUITY_NOTICE(&quot;PurchaseDiscount&quot;, total, &quot;Citizens enjoy a 90% discount on purchase housing&quot;); } } //积分奖励 function awardScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin { uint balance = leasingScore[player]; leasingScore[player] = balance + score; emit SCORE_OPERATOR(ScoreAction.ActionAwardScore, describe); checkScoreEquity(balance, score); } //积分权级兑换，为消费者主动意愿，若不够花，则不扣除积分，且发送失败事件。 function exchangeScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin returns (bool) { emit SCORE_OPERATOR(ScoreAction.ActionExchangeScore, describe); if(leasingScore[player] &gt;= score) { leasingScore[player] -= score; return true; } emit SCORE_ERROR(ScoreAction.ActionExchangeScore, &quot;Score not enough to exchange&quot;); return false; } //积分扣除，为消费者被动意愿，进行强制积分扣除，若积分不够，则清零，且发送失败时间 function deductScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin { emit SCORE_OPERATOR(ScoreAction.ActionDeductScore, describe); uint balance = leasingScore[player]; if(balance &gt;= score) { leasingScore[player] -= score; } else { if(balance != 0) { leasingScore[player] = 0; } emit SCORE_ERROR(ScoreAction.ActionDeductScore, &quot;Score not enough to deduct&quot;); } } //积分查询 function queryScore(bytes32 player, string describe) view public onlyObserverOrAdmin returns (uint) { emit SCORE_OPERATOR(ScoreAction.ActionQueryScore, describe); return leasingScore[player]; } //拼接字符串 function stringAdd(string a, string b) returns(string){ bytes memory _a = bytes(a); bytes memory _b = bytes(b); bytes memory res = new bytes(_a.length + _b.length); for(uint i = 0;i &lt; _a.length;i++) res[i] = _a[i]; for(uint j = 0;j &lt; _b.length;j++) res[_a.length+j] = _b[j]; return string(res); } //积分转移，将积分从一个一个合约转移到另一个合约 function transferScore(bytes32 player, uint score, LeasingScoreManager toContract, string describe) public onlyCalculatorOrAdmin { //判断积分是否够用并扣除 describe = stringAdd(&quot;Transfer score: &quot;, describe); require(exchangeScore(player, score, describe)); toContract.awardScore(player, score, describe); } } 5，合约编译/部署/测试 5.1 账号信息 参考《蚂蚁区块链第8课 如何创建新的账户，获取私钥和identity标识？》 文章获得辉哥需要的账号的解密私钥和identity。 角色定义如下，其中的私钥已被辉哥篡改过了，防止被误用。 管理者 - test002 identity: 0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20 管理者 - ella identity: 0xfb2cb45b6b443241e38145b6445a6e0ebee0410d19e71d9fd0adf5fc382d49e5 私钥：0x2ac3bc8673454b6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019 操作员 - duncanwang identity: 0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1 私钥：0x46f9c8c5037a92d7fd811b350a42dc63591fb772ea2c104b89ccb48e1784c76c 观察员 - ouyang identity: 0xe26ef3b9bb0244244935f0176e2e4b5b623be3634276ee897810a380ae8c1314 私钥：0x2bc3bc8673454a6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019 市民 - dingheng identity: 0xccaa69e5e5583f2e34885450669c518a6febcdec9040a4d0a2d41cd9f8f8ca40 私钥：0x2bc3bc8673454a6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019 因为目前(2019.04.06)蚂蚁BAAS系统存在一个BUG，导致ella等账号不能被用于智能合约部署，辉哥目前可使用的账号只有test002和duncanwang账号，辉哥在测试用例设计上做了一个小调整。 5.2 合约编译/部署 参考《蚂蚁区块链第5课 如何配置Cloud IDE证书并进行Solidity智能合约调试？》 完成智能合约的编译和部署，采用默认的test002账号。 【告警】在蚂蚁BAAS系统中，相同的合约名称只能使用一次。 如果该合约已部署，可按“已部署合约”根据已部署的智能合约名称来调用合约。 5.3 模拟测试（基本函数测试成功） 账号：test002 账号identity: 0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20 创建 LeasingScoreManager，其合约identity: 0x64d555c5c89575982d319fe7ddd2eb1741a5d3c4386fac168ed5440958ed5044 （1）管理员test002做账户设置操作 &lt;1&gt; 管理员test002部署合约（上海合约）后增加自己为管理员 function addAdmin(identity admin) public onlyAdmin addAdmin(0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20) 结果： tx hash: 0x842c8d85080878942a9fa0c1f356f3284305cb0317ce5aca2ed43291d8cd1a80 log: VALID(bool,uint8): true,0 USER_EXIST(bool,uint8): false,0 &lt;2&gt; 管理员test002增加操作员 duncanwang function addCalculator(identity calculator) public onlyAdmin addCalculator(0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1) 结果： tx hash: 0xe68c2fa466885221dba293e95f803e511ba46e9e111ef1e44e685a2df2e2269b log: VALID(bool,uint8): true,0 USER_EXIST(bool,uint8): false,1 &lt;3&gt; 管理员test002增加观察员 duncanwang function addObserver(identity observer) public onlyAdmin addObserver(0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1) 结果：未记录。 账号切换到duncanwang账号： （2） 操作员duncanwang给市民dingheng增加100积分，理由：在马路上勇敢扶起一位摔倒的80岁老奶奶。 function awardScore(bytes32 player, uint score, string describe) awardScore(“dingheng”,100, “理由：dingheng在马路上勇敢扶起一位摔倒的80岁老奶奶。”) 输出信息： tx hash:0x591daac5d038de4d9a3f437dd8aeea466772b28562792225be3d5af2903ef122 log VALID(bool,uint8): true,1 SCORE_OPERATOR(uint8,string):0,理由：dingheng在马路上勇敢扶起一位摔倒的80岁老奶奶。 SCORE_EQUITY_NOTICE(string,uint256,string): RentConcessions,100,Citizens enjoy a 90% discount on rental housing （3） 操作员duncanwang收到市民dingheng申请，理由：需要租房1年，花费80积分。 function exchangeScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin returns (bool) exchangeScore(“dingheng”, 80, “理由：需要租房1年，花费80积分。”) 输出信息： tx hash:0xd7ce3c91a3b6e3c05117616c4d6e4ad1bc05e5ba8dd016189223a81dbdc0b68a log VALID(bool,uint8): true,1 SCORE_OPERATOR(uint8,string): 1,理由：需要租房1年，花费80积分。 （4）操作员duncanwang发现市民dingheng房租到期后，未及时退租。扣10个积分，电话催丁恒来退租。 function deductScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin deductScore(“dingheng”, 10, “理由：dingheng房租到期后，未及时退租。扣10个积分。”) 输出信息： tx hash:0x970e9ad61dfd9e264cd1bd12ca0d8426d1bbe9a178b0ec88d82d6a30ec2c5c99 log: VALID(bool,uint8): true,1 SCORE_OPERATOR(uint8,string): 2,理由：dingheng房租到期后，未及时退租。扣10个积分。 6，蚂蚁BAAS Solidity语法差异精要 6.1 合约数据类型 蚂蚁区块链合约平台基本支持 Solidity 所有的数据类型，但是对于一些用户编写的合约的输入参数类型并没有完全的支持，比如参数输入中二维数组的输入。同时，蚂蚁区块链合约平台提供了 identity 类型来标注每一个用户的身份，不支持原生 Solidity 中的 address 类型，identity 的长度为 32 字节。 蚂蚁BAAS的identity就是账号名称的SHA256算法产生的32字节内容。 例如，在站长工具网站http://tool.chinaz.com/tools/hash.aspx中输入账号名字duncanwang，获得其identity为0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1 更多信息，可查看 Solidity 官网关于类型的文档（英文）。 6.2 合约关键字 蚂蚁区块链合约平台支持的 Solidity 语法基本与官方文档一致，具体语法介绍可参看 Solidity 官方文档（英文）。 本文主要介绍 Solidity 合约函数构造的常用 权限关键字 和 修饰关键字。 6.3 平台接口函数 蚂蚁区块链合约平台为合约开发者提供一些新的特性接口支持，包括对区块数据获取、交易数据获取、加密方法的支持。 区块数据接口函数 block.blockhash(uint blockNumber) returns (bytes32)：传入 blockNumber，返回块的哈希值。 block.gaslimit (uint)：系统中的 gas 最大值。 block.number (uint)：当前块高度。 block.timestamp (uint)：当前区块创建的时间戳。 now (uint)：block.timestamp 的别名。 交易数据接口函数 msg.data (bytes)：用户的输入数据。 msg.gas (uint)：用户交易中的 gas 值。 msg.sender (identity)：用户交易中的发送方。 msg.sig (bytes4)：用户交易输入数据的前四字节。 msg.value (uint)：用户交易中的 gas 值。 蚂蚁区块链合约平台还支持查询交易哈希，示例如下： tx.txhash (identity) 可通过此方法获取当前交易的哈希值。 6.4 不支持TOKEN转账相关函数 【告警】不支持TOKEN，不支持地址相关的转账函数了。 .balance (uint256): 以 Wei 为单位的 地址类型 的余额。 .transfer(uint256 amount): 向 地址类型 发送数量为 amount 的 Wei，失败时抛出异常，发送 2300 gas 的矿工费，不可调节。 .send(uint256 amount) returns (bool): 向 地址类型 发送数量为 amount 的 Wei，失败时返回 false，发送 2300 gas 的矿工费用，不可调节。 .call(...) returns (bool): 发出低级函数 CALL，失败时返回 false，发送所有可用 gas，可调节。 .callcode(...) returns (bool)： 发出低级函数 CALLCODE，失败时返回 false，发送所有可用 gas，可调节。 .delegatecall(...) returns (bool): 发出低级函数 DELEGATECALL，失败时返回 false，发送所有可用 gas，可调节。 6.5 支持合约间调用 蚂蚁区块链合约平台主要支持两种合约调用方式，分别为 call 和 delegatecall。 call call 类型的合约调用主要是通过调用其他合约代码获取某个方法的调用结果。同时，在执行该合约时，被调用合约的变量会被修改（即修改的是被调用合约的内存），调用执行成功时返回 true，失败则返回 false。如果被调用合约不存在，则返回执行调用合约的 fallback 函数。 函数原型 id.call(bytes4(keccak256(data), args)) returns (bool result) 请求参数 参数 必选 类型 说明 id 是 identity 被调用合约 ID data 是 string 被调用合约方法签名 args 是 var 被调用合约方法传入参数 返回值 参数 必选 类型 说明 result 是 bool 方法返回值，成功为 true，否则为 false。 delegatecall delegatecall 类型的合约调用也是调用其他合约的方法，与 call 不同的是，delegatecall 修改的是合约调用方的内存。此方法的主要目的在于让合约能够在不传输自身状态（如 balance、storage）的情况下使用其他合约的代码。delegatecall 不支持传输 value。 函数原型 id.delegatecall(bytes4(keccak256(data), args)) returns (bool result) 请求参数 参数 必选 类型 说明 id 是 identity 被调用合约 ID data 是 string 被调用合约方法签名 args 是 var 被调用合约方法传入参数 返回值 参数 必选 类型 说明 result 是 bool 方法返回值，成功为 true，否则为 false。 7，参考 （1） Solidity 合约开发 https://tech.antfin.com/docs/2/101909 （2）Solidity官方中文文档 https://solidity-cn.readthedocs.io/zh/develop/" />
<meta property="og:description" content="版权声明：如需转载，请私信联系作者。 https://blog.csdn.net/wangdenghui2005/article/details/89060692 1，摘要 本文以住房租赁积分管理系统为例，给大家演示CLOUD IDE如何编译调试solidity智能合约，并以此为例，给大家分享以太坊SOLIDITY跟蚂蚁区块链SOLIDITY语言的差异点。 2，住房租赁积分管理系统的背景和目标 背景 基于区块链智能合约的住房租赁积分管理系统旨在有效地服务于公众群体、市民，真正让那些为城市当前发展做出努力的人有房住、租得起，让那些为城市建设长远发展做出贡献的人有房产、买得起。为此，建立住房租赁积分制度，从住房租赁市场主体属性、政策激励、租赁行为三方面，运用区块链、大数据等前沿技术，建立科学、有效的住房租赁积分全生命周期管理机制，营造活力、健康、有序、可持续的住房租赁生态。 目标 通过使用区块链平台作为底层数据支撑，确保隐私保护和数据不可篡改，达到公平、公正、透明的目的；利用积分决策引擎，结合住房租赁积分评价体系，产出应用于住房租赁场景的综合积分方案。该方案具备横向扩展性，在底层技术、数据不变的基础上，未来能够支撑经济信用积分、绿色生活积分等诸多积分体系的建设，从而扩展形成城市信用体系，应用于如医疗教育、金融借贷、绿色生活等诸多场景。 3，合约设计 权限管理 在住房租赁积分管理系统中，主要分为 4 种角色，分别是管理者、操作者、观察者以及市民。管理者、操作者、观察者是智能合约的操作人员，每个角色可以对应多名人员。市民是租赁积分智能合约服务的对象，是整个智能合约的核心用户。 角色操作权限 管理者是合约的超级管理员，能够对管理者、操作者以及观察者进行添加、删除、查询操作。 操作者可以查询操作者信息。 观察者可以查询观察者信息。 积分操作权限 管理者：具有积分奖励、积分查询、积分转移、积分违规扣除、积分权益兑换等积分操作权限。 操作者：操作者是由管理者设置的积分操作角色，该角色可以是具体的人员也可以是系统服务，具有积分奖励、积分转移、积分违规扣除、积分权益兑换等积分操作权限。 观察者：观察者是由管理者设置的积分查询角色，该角色可以是具体的人员也可以是系统服务，具有积分查询的操作权限。 市民：市民是住房租赁积分系统的用户，是住房租赁积分系统的实际权益对象。 市民可以通过组织机构的租赁积分外部服务系统代理的观察者权限查看自己的积分状况。 租赁积分外部服务系统会根据市民的合规表现，通过操作者的权限进行积分奖励或积分违规扣除。 市民可以通过租赁积分外部服务系统代理的操作者权限进行积分权益兑换或积分转移操作。 积分管理 租赁积分智能合约提供的服务方法包括 积分奖励、积分查询、积分权益兑换、积分违规扣除、积分转移 以及积分达到阈值后触发 积分事件。 积分奖励（awardScore） 在市民租赁房屋的过程中，针对租赁的时间、租赁过程中产生的行为，为市民进行积分累计。 积分查询（queryScore） 市民可通过租赁积分外部服务系统代理的观察者权限查看自己的积分状况。 积分权益兑换（exchangeScore） 市民的积分达到指定阈值后可以享有相应的权益，如租房优惠、买房资格、落户资格等。 积分违规扣除（deductScore） 在市民租赁房屋的过程中，针对租赁过程中产生的错误行为，对市民惩罚性的扣减积分。住房租赁积分作为正向激励的积分体系，鼓励民众积极向上。对于积分主体的伪造资料行为，视情节严重程度扣减积分、取消积分资格以及收回积分对应的权益。 积分事件（SCORE_EQUITY_NOTICE） 当积分权益实时增加时，会触发积分权益检查。若积分达到了指定的阈值，则会产生相应的积分权益通知事件。通过外部服务系统通知到具体的市民。 积分转移（transferScore） 当市民因工作关系、家庭因素需要到其他城市生活时，可以将该城市的积分转移到目标城市的积分系统。为满足该合约的调用，目标合约需要有对应的积分奖励方法（awardScore），且需要为发起合约提供操作权限，即将发起合约的地址设置为操作者或管理员。 4，智能合约代码 pragma solidity ^0.4.20; contract LeasingScoreManager { identity[] adminList; identity[] observerList; identity[] calculatorList; //用于记录管理数组被置位元素 uint adminDeled; uint observerDeled; uint calculatorDeled; mapping (bytes32 =&gt; uint) leasingScore; enum ScoreAction { //奖励积分， 因相关行为，进行积分奖励 ActionAwardScore, //积分权益兑换，花费指定积分 ActionExchangeScore, //扣除积分， 因违规等， 扣除积分 ActionDeductScore, //查询积分 ActionQueryScore //积分转移, 将积分转移到其他的合约。 } enum UserRole { RoleAdmin, //管理员 RoleCalculator, //积分操作员 RoleObserver, //积分查看人员 RolePlayer //积分参与者 } //是否为有效的操作人 event VALID(bool valid, UserRole role); //admin/observer/calculator 用户存在 event USER_EXIST(bool exist, UserRole role); //积分事件 event SCORE_OPERATOR(ScoreAction action, string describe); //积分操作错误 event SCORE_ERROR(ScoreAction action, string describe); //积分权益通知 event SCORE_EQUITY_NOTICE(string action, uint score, string describe); constructor() public { adminList.push(msg.sender); adminList.push(this); } function indexAdmin(identity admin) view returns (uint) { for (uint i = 0; i &lt; adminList.length; i++) { if (adminList[i] == admin) { return i; } } return adminList.length; } function validAdmin(identity admin) view returns (bool) { return indexAdmin(admin) &lt; adminList.length; } function indexCalculator(identity calculator) view returns (uint) { for (uint i = 0; i &lt; calculatorList.length; i++) { if (calculatorList[i] == calculator) { return i; } } return calculatorList.length; } function validCalculator(identity calculator) view returns (bool) { return indexCalculator(calculator) &lt; calculatorList.length; } function indexObserver(identity observer) view returns (uint) { for (uint i = 0; i &lt; observerList.length; i++) { if (observerList[i] == observer) { return i; } } return observerList.length; } function validObserver(identity observer) view returns (bool) { return indexObserver(observer) &lt; observerList.length; } modifier onlyAdmin { bool isValid = validAdmin(msg.sender); emit VALID(isValid, UserRole.RoleAdmin); require(isValid); _; } modifier onlyCalculatorOrAdmin { bool isValid = validAdmin(msg.sender); if(isValid) { emit VALID(isValid, UserRole.RoleAdmin); } else { isValid = validCalculator(msg.sender); emit VALID(isValid, UserRole.RoleCalculator); } require(isValid); _; } modifier onlyObserverOrAdmin { bool isValid = validAdmin(msg.sender); if(isValid) { emit VALID(isValid, UserRole.RoleAdmin); } else { isValid = validObserver(msg.sender); emit VALID(isValid, UserRole.RoleObserver); } require(isValid); _; } function addAdmin(identity admin) public onlyAdmin { bool isExist = validAdmin(admin); emit USER_EXIST(isExist, UserRole.RoleAdmin); require(!isExist); if(adminDeled &gt; 0) { uint deled = 1; for (uint i = 0; i &lt; adminList.length; i++) { if(deled&amp;adminDeled != 0) { adminList[i] = admin; adminDeled ^= deled; break; } deled &lt;&lt;= 1; } } else { adminList.push(admin); } } function removeAdmin(identity admin) public onlyAdmin { uint index = indexAdmin(admin); bool isValid = index != adminList.length; emit USER_EXIST(isValid, UserRole.RoleAdmin); require(isValid); delete adminList[index]; adminDeled ^= 1 &lt;&lt; index; } function queryAdmins() view public onlyAdmin returns (identity[]) { return adminList; } function addCalculator(identity calculator) public onlyAdmin { bool isExist = validCalculator(calculator); emit USER_EXIST(isExist, UserRole.RoleCalculator); require(!isExist); if(calculatorDeled &gt; 0) { uint deled = 1; for (uint i = 0; i &lt; calculatorList.length; i++) { if(deled&amp;calculatorDeled != 0) { calculatorList[i] = calculator; calculatorDeled ^= deled; break; } deled &lt;&lt;= 1; } } else { calculatorList.push(calculator); } } function removeCalculator(identity calculator) public onlyAdmin { uint index = indexCalculator(calculator); bool isValid = index &lt; calculatorList.length; emit USER_EXIST(isValid, UserRole.RoleCalculator); require(isValid); delete calculatorList[index]; calculatorDeled ^= 1 &lt;&lt; index; } function queryCalculators() view public onlyCalculatorOrAdmin returns (identity[]) { return calculatorList; } function addObserver(identity observer) public onlyAdmin { bool isExist = validObserver(observer); emit USER_EXIST(isExist, UserRole.RoleObserver); require(!isExist); if(observerDeled &gt; 0) { uint deled = 1; for (uint i = 0; i &lt; observerList.length; i++) { if(deled&amp;observerDeled != 0) { observerList[i] = observer; observerDeled ^= deled; break; } deled &lt;&lt;= 1; } } else { observerList.push(observer); } } function removeObserver(identity observer) public onlyAdmin { uint index = indexCalculator(observer); bool isValid = index &lt; observerList.length; emit USER_EXIST(isValid, UserRole.RoleObserver); require(isValid); delete observerList[index]; observerDeled ^= 1 &lt;&lt; index; } function queryObservers() view public onlyObserverOrAdmin returns (identity[]) { return observerList; } function checkScoreEquity(uint balance, uint score) { uint total = balance + score; if(total &gt;= 100 &amp;&amp; balance &lt; 100) { emit SCORE_EQUITY_NOTICE(&quot;RentConcessions&quot;, total, &quot;Citizens enjoy a 90% discount on rental housing&quot;); } if(total &gt;= 200 &amp;&amp; balance &lt; 200) { emit SCORE_EQUITY_NOTICE(&quot;RentConcessions_1&quot;, total, &quot;Citizens enjoy a 80% discount on rental housing&quot;); } if(total &gt;= 300 &amp;&amp; balance &lt; 300) { emit SCORE_EQUITY_NOTICE(&quot;PurchaseDiscount&quot;, total, &quot;Citizens enjoy a 90% discount on purchase housing&quot;); } } //积分奖励 function awardScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin { uint balance = leasingScore[player]; leasingScore[player] = balance + score; emit SCORE_OPERATOR(ScoreAction.ActionAwardScore, describe); checkScoreEquity(balance, score); } //积分权级兑换，为消费者主动意愿，若不够花，则不扣除积分，且发送失败事件。 function exchangeScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin returns (bool) { emit SCORE_OPERATOR(ScoreAction.ActionExchangeScore, describe); if(leasingScore[player] &gt;= score) { leasingScore[player] -= score; return true; } emit SCORE_ERROR(ScoreAction.ActionExchangeScore, &quot;Score not enough to exchange&quot;); return false; } //积分扣除，为消费者被动意愿，进行强制积分扣除，若积分不够，则清零，且发送失败时间 function deductScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin { emit SCORE_OPERATOR(ScoreAction.ActionDeductScore, describe); uint balance = leasingScore[player]; if(balance &gt;= score) { leasingScore[player] -= score; } else { if(balance != 0) { leasingScore[player] = 0; } emit SCORE_ERROR(ScoreAction.ActionDeductScore, &quot;Score not enough to deduct&quot;); } } //积分查询 function queryScore(bytes32 player, string describe) view public onlyObserverOrAdmin returns (uint) { emit SCORE_OPERATOR(ScoreAction.ActionQueryScore, describe); return leasingScore[player]; } //拼接字符串 function stringAdd(string a, string b) returns(string){ bytes memory _a = bytes(a); bytes memory _b = bytes(b); bytes memory res = new bytes(_a.length + _b.length); for(uint i = 0;i &lt; _a.length;i++) res[i] = _a[i]; for(uint j = 0;j &lt; _b.length;j++) res[_a.length+j] = _b[j]; return string(res); } //积分转移，将积分从一个一个合约转移到另一个合约 function transferScore(bytes32 player, uint score, LeasingScoreManager toContract, string describe) public onlyCalculatorOrAdmin { //判断积分是否够用并扣除 describe = stringAdd(&quot;Transfer score: &quot;, describe); require(exchangeScore(player, score, describe)); toContract.awardScore(player, score, describe); } } 5，合约编译/部署/测试 5.1 账号信息 参考《蚂蚁区块链第8课 如何创建新的账户，获取私钥和identity标识？》 文章获得辉哥需要的账号的解密私钥和identity。 角色定义如下，其中的私钥已被辉哥篡改过了，防止被误用。 管理者 - test002 identity: 0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20 管理者 - ella identity: 0xfb2cb45b6b443241e38145b6445a6e0ebee0410d19e71d9fd0adf5fc382d49e5 私钥：0x2ac3bc8673454b6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019 操作员 - duncanwang identity: 0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1 私钥：0x46f9c8c5037a92d7fd811b350a42dc63591fb772ea2c104b89ccb48e1784c76c 观察员 - ouyang identity: 0xe26ef3b9bb0244244935f0176e2e4b5b623be3634276ee897810a380ae8c1314 私钥：0x2bc3bc8673454a6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019 市民 - dingheng identity: 0xccaa69e5e5583f2e34885450669c518a6febcdec9040a4d0a2d41cd9f8f8ca40 私钥：0x2bc3bc8673454a6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019 因为目前(2019.04.06)蚂蚁BAAS系统存在一个BUG，导致ella等账号不能被用于智能合约部署，辉哥目前可使用的账号只有test002和duncanwang账号，辉哥在测试用例设计上做了一个小调整。 5.2 合约编译/部署 参考《蚂蚁区块链第5课 如何配置Cloud IDE证书并进行Solidity智能合约调试？》 完成智能合约的编译和部署，采用默认的test002账号。 【告警】在蚂蚁BAAS系统中，相同的合约名称只能使用一次。 如果该合约已部署，可按“已部署合约”根据已部署的智能合约名称来调用合约。 5.3 模拟测试（基本函数测试成功） 账号：test002 账号identity: 0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20 创建 LeasingScoreManager，其合约identity: 0x64d555c5c89575982d319fe7ddd2eb1741a5d3c4386fac168ed5440958ed5044 （1）管理员test002做账户设置操作 &lt;1&gt; 管理员test002部署合约（上海合约）后增加自己为管理员 function addAdmin(identity admin) public onlyAdmin addAdmin(0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20) 结果： tx hash: 0x842c8d85080878942a9fa0c1f356f3284305cb0317ce5aca2ed43291d8cd1a80 log: VALID(bool,uint8): true,0 USER_EXIST(bool,uint8): false,0 &lt;2&gt; 管理员test002增加操作员 duncanwang function addCalculator(identity calculator) public onlyAdmin addCalculator(0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1) 结果： tx hash: 0xe68c2fa466885221dba293e95f803e511ba46e9e111ef1e44e685a2df2e2269b log: VALID(bool,uint8): true,0 USER_EXIST(bool,uint8): false,1 &lt;3&gt; 管理员test002增加观察员 duncanwang function addObserver(identity observer) public onlyAdmin addObserver(0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1) 结果：未记录。 账号切换到duncanwang账号： （2） 操作员duncanwang给市民dingheng增加100积分，理由：在马路上勇敢扶起一位摔倒的80岁老奶奶。 function awardScore(bytes32 player, uint score, string describe) awardScore(“dingheng”,100, “理由：dingheng在马路上勇敢扶起一位摔倒的80岁老奶奶。”) 输出信息： tx hash:0x591daac5d038de4d9a3f437dd8aeea466772b28562792225be3d5af2903ef122 log VALID(bool,uint8): true,1 SCORE_OPERATOR(uint8,string):0,理由：dingheng在马路上勇敢扶起一位摔倒的80岁老奶奶。 SCORE_EQUITY_NOTICE(string,uint256,string): RentConcessions,100,Citizens enjoy a 90% discount on rental housing （3） 操作员duncanwang收到市民dingheng申请，理由：需要租房1年，花费80积分。 function exchangeScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin returns (bool) exchangeScore(“dingheng”, 80, “理由：需要租房1年，花费80积分。”) 输出信息： tx hash:0xd7ce3c91a3b6e3c05117616c4d6e4ad1bc05e5ba8dd016189223a81dbdc0b68a log VALID(bool,uint8): true,1 SCORE_OPERATOR(uint8,string): 1,理由：需要租房1年，花费80积分。 （4）操作员duncanwang发现市民dingheng房租到期后，未及时退租。扣10个积分，电话催丁恒来退租。 function deductScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin deductScore(“dingheng”, 10, “理由：dingheng房租到期后，未及时退租。扣10个积分。”) 输出信息： tx hash:0x970e9ad61dfd9e264cd1bd12ca0d8426d1bbe9a178b0ec88d82d6a30ec2c5c99 log: VALID(bool,uint8): true,1 SCORE_OPERATOR(uint8,string): 2,理由：dingheng房租到期后，未及时退租。扣10个积分。 6，蚂蚁BAAS Solidity语法差异精要 6.1 合约数据类型 蚂蚁区块链合约平台基本支持 Solidity 所有的数据类型，但是对于一些用户编写的合约的输入参数类型并没有完全的支持，比如参数输入中二维数组的输入。同时，蚂蚁区块链合约平台提供了 identity 类型来标注每一个用户的身份，不支持原生 Solidity 中的 address 类型，identity 的长度为 32 字节。 蚂蚁BAAS的identity就是账号名称的SHA256算法产生的32字节内容。 例如，在站长工具网站http://tool.chinaz.com/tools/hash.aspx中输入账号名字duncanwang，获得其identity为0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1 更多信息，可查看 Solidity 官网关于类型的文档（英文）。 6.2 合约关键字 蚂蚁区块链合约平台支持的 Solidity 语法基本与官方文档一致，具体语法介绍可参看 Solidity 官方文档（英文）。 本文主要介绍 Solidity 合约函数构造的常用 权限关键字 和 修饰关键字。 6.3 平台接口函数 蚂蚁区块链合约平台为合约开发者提供一些新的特性接口支持，包括对区块数据获取、交易数据获取、加密方法的支持。 区块数据接口函数 block.blockhash(uint blockNumber) returns (bytes32)：传入 blockNumber，返回块的哈希值。 block.gaslimit (uint)：系统中的 gas 最大值。 block.number (uint)：当前块高度。 block.timestamp (uint)：当前区块创建的时间戳。 now (uint)：block.timestamp 的别名。 交易数据接口函数 msg.data (bytes)：用户的输入数据。 msg.gas (uint)：用户交易中的 gas 值。 msg.sender (identity)：用户交易中的发送方。 msg.sig (bytes4)：用户交易输入数据的前四字节。 msg.value (uint)：用户交易中的 gas 值。 蚂蚁区块链合约平台还支持查询交易哈希，示例如下： tx.txhash (identity) 可通过此方法获取当前交易的哈希值。 6.4 不支持TOKEN转账相关函数 【告警】不支持TOKEN，不支持地址相关的转账函数了。 .balance (uint256): 以 Wei 为单位的 地址类型 的余额。 .transfer(uint256 amount): 向 地址类型 发送数量为 amount 的 Wei，失败时抛出异常，发送 2300 gas 的矿工费，不可调节。 .send(uint256 amount) returns (bool): 向 地址类型 发送数量为 amount 的 Wei，失败时返回 false，发送 2300 gas 的矿工费用，不可调节。 .call(...) returns (bool): 发出低级函数 CALL，失败时返回 false，发送所有可用 gas，可调节。 .callcode(...) returns (bool)： 发出低级函数 CALLCODE，失败时返回 false，发送所有可用 gas，可调节。 .delegatecall(...) returns (bool): 发出低级函数 DELEGATECALL，失败时返回 false，发送所有可用 gas，可调节。 6.5 支持合约间调用 蚂蚁区块链合约平台主要支持两种合约调用方式，分别为 call 和 delegatecall。 call call 类型的合约调用主要是通过调用其他合约代码获取某个方法的调用结果。同时，在执行该合约时，被调用合约的变量会被修改（即修改的是被调用合约的内存），调用执行成功时返回 true，失败则返回 false。如果被调用合约不存在，则返回执行调用合约的 fallback 函数。 函数原型 id.call(bytes4(keccak256(data), args)) returns (bool result) 请求参数 参数 必选 类型 说明 id 是 identity 被调用合约 ID data 是 string 被调用合约方法签名 args 是 var 被调用合约方法传入参数 返回值 参数 必选 类型 说明 result 是 bool 方法返回值，成功为 true，否则为 false。 delegatecall delegatecall 类型的合约调用也是调用其他合约的方法，与 call 不同的是，delegatecall 修改的是合约调用方的内存。此方法的主要目的在于让合约能够在不传输自身状态（如 balance、storage）的情况下使用其他合约的代码。delegatecall 不支持传输 value。 函数原型 id.delegatecall(bytes4(keccak256(data), args)) returns (bool result) 请求参数 参数 必选 类型 说明 id 是 identity 被调用合约 ID data 是 string 被调用合约方法签名 args 是 var 被调用合约方法传入参数 返回值 参数 必选 类型 说明 result 是 bool 方法返回值，成功为 true，否则为 false。 7，参考 （1） Solidity 合约开发 https://tech.antfin.com/docs/2/101909 （2）Solidity官方中文文档 https://solidity-cn.readthedocs.io/zh/develop/" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：如需转载，请私信联系作者。 https://blog.csdn.net/wangdenghui2005/article/details/89060692 1，摘要 本文以住房租赁积分管理系统为例，给大家演示CLOUD IDE如何编译调试solidity智能合约，并以此为例，给大家分享以太坊SOLIDITY跟蚂蚁区块链SOLIDITY语言的差异点。 2，住房租赁积分管理系统的背景和目标 背景 基于区块链智能合约的住房租赁积分管理系统旨在有效地服务于公众群体、市民，真正让那些为城市当前发展做出努力的人有房住、租得起，让那些为城市建设长远发展做出贡献的人有房产、买得起。为此，建立住房租赁积分制度，从住房租赁市场主体属性、政策激励、租赁行为三方面，运用区块链、大数据等前沿技术，建立科学、有效的住房租赁积分全生命周期管理机制，营造活力、健康、有序、可持续的住房租赁生态。 目标 通过使用区块链平台作为底层数据支撑，确保隐私保护和数据不可篡改，达到公平、公正、透明的目的；利用积分决策引擎，结合住房租赁积分评价体系，产出应用于住房租赁场景的综合积分方案。该方案具备横向扩展性，在底层技术、数据不变的基础上，未来能够支撑经济信用积分、绿色生活积分等诸多积分体系的建设，从而扩展形成城市信用体系，应用于如医疗教育、金融借贷、绿色生活等诸多场景。 3，合约设计 权限管理 在住房租赁积分管理系统中，主要分为 4 种角色，分别是管理者、操作者、观察者以及市民。管理者、操作者、观察者是智能合约的操作人员，每个角色可以对应多名人员。市民是租赁积分智能合约服务的对象，是整个智能合约的核心用户。 角色操作权限 管理者是合约的超级管理员，能够对管理者、操作者以及观察者进行添加、删除、查询操作。 操作者可以查询操作者信息。 观察者可以查询观察者信息。 积分操作权限 管理者：具有积分奖励、积分查询、积分转移、积分违规扣除、积分权益兑换等积分操作权限。 操作者：操作者是由管理者设置的积分操作角色，该角色可以是具体的人员也可以是系统服务，具有积分奖励、积分转移、积分违规扣除、积分权益兑换等积分操作权限。 观察者：观察者是由管理者设置的积分查询角色，该角色可以是具体的人员也可以是系统服务，具有积分查询的操作权限。 市民：市民是住房租赁积分系统的用户，是住房租赁积分系统的实际权益对象。 市民可以通过组织机构的租赁积分外部服务系统代理的观察者权限查看自己的积分状况。 租赁积分外部服务系统会根据市民的合规表现，通过操作者的权限进行积分奖励或积分违规扣除。 市民可以通过租赁积分外部服务系统代理的操作者权限进行积分权益兑换或积分转移操作。 积分管理 租赁积分智能合约提供的服务方法包括 积分奖励、积分查询、积分权益兑换、积分违规扣除、积分转移 以及积分达到阈值后触发 积分事件。 积分奖励（awardScore） 在市民租赁房屋的过程中，针对租赁的时间、租赁过程中产生的行为，为市民进行积分累计。 积分查询（queryScore） 市民可通过租赁积分外部服务系统代理的观察者权限查看自己的积分状况。 积分权益兑换（exchangeScore） 市民的积分达到指定阈值后可以享有相应的权益，如租房优惠、买房资格、落户资格等。 积分违规扣除（deductScore） 在市民租赁房屋的过程中，针对租赁过程中产生的错误行为，对市民惩罚性的扣减积分。住房租赁积分作为正向激励的积分体系，鼓励民众积极向上。对于积分主体的伪造资料行为，视情节严重程度扣减积分、取消积分资格以及收回积分对应的权益。 积分事件（SCORE_EQUITY_NOTICE） 当积分权益实时增加时，会触发积分权益检查。若积分达到了指定的阈值，则会产生相应的积分权益通知事件。通过外部服务系统通知到具体的市民。 积分转移（transferScore） 当市民因工作关系、家庭因素需要到其他城市生活时，可以将该城市的积分转移到目标城市的积分系统。为满足该合约的调用，目标合约需要有对应的积分奖励方法（awardScore），且需要为发起合约提供操作权限，即将发起合约的地址设置为操作者或管理员。 4，智能合约代码 pragma solidity ^0.4.20; contract LeasingScoreManager { identity[] adminList; identity[] observerList; identity[] calculatorList; //用于记录管理数组被置位元素 uint adminDeled; uint observerDeled; uint calculatorDeled; mapping (bytes32 =&gt; uint) leasingScore; enum ScoreAction { //奖励积分， 因相关行为，进行积分奖励 ActionAwardScore, //积分权益兑换，花费指定积分 ActionExchangeScore, //扣除积分， 因违规等， 扣除积分 ActionDeductScore, //查询积分 ActionQueryScore //积分转移, 将积分转移到其他的合约。 } enum UserRole { RoleAdmin, //管理员 RoleCalculator, //积分操作员 RoleObserver, //积分查看人员 RolePlayer //积分参与者 } //是否为有效的操作人 event VALID(bool valid, UserRole role); //admin/observer/calculator 用户存在 event USER_EXIST(bool exist, UserRole role); //积分事件 event SCORE_OPERATOR(ScoreAction action, string describe); //积分操作错误 event SCORE_ERROR(ScoreAction action, string describe); //积分权益通知 event SCORE_EQUITY_NOTICE(string action, uint score, string describe); constructor() public { adminList.push(msg.sender); adminList.push(this); } function indexAdmin(identity admin) view returns (uint) { for (uint i = 0; i &lt; adminList.length; i++) { if (adminList[i] == admin) { return i; } } return adminList.length; } function validAdmin(identity admin) view returns (bool) { return indexAdmin(admin) &lt; adminList.length; } function indexCalculator(identity calculator) view returns (uint) { for (uint i = 0; i &lt; calculatorList.length; i++) { if (calculatorList[i] == calculator) { return i; } } return calculatorList.length; } function validCalculator(identity calculator) view returns (bool) { return indexCalculator(calculator) &lt; calculatorList.length; } function indexObserver(identity observer) view returns (uint) { for (uint i = 0; i &lt; observerList.length; i++) { if (observerList[i] == observer) { return i; } } return observerList.length; } function validObserver(identity observer) view returns (bool) { return indexObserver(observer) &lt; observerList.length; } modifier onlyAdmin { bool isValid = validAdmin(msg.sender); emit VALID(isValid, UserRole.RoleAdmin); require(isValid); _; } modifier onlyCalculatorOrAdmin { bool isValid = validAdmin(msg.sender); if(isValid) { emit VALID(isValid, UserRole.RoleAdmin); } else { isValid = validCalculator(msg.sender); emit VALID(isValid, UserRole.RoleCalculator); } require(isValid); _; } modifier onlyObserverOrAdmin { bool isValid = validAdmin(msg.sender); if(isValid) { emit VALID(isValid, UserRole.RoleAdmin); } else { isValid = validObserver(msg.sender); emit VALID(isValid, UserRole.RoleObserver); } require(isValid); _; } function addAdmin(identity admin) public onlyAdmin { bool isExist = validAdmin(admin); emit USER_EXIST(isExist, UserRole.RoleAdmin); require(!isExist); if(adminDeled &gt; 0) { uint deled = 1; for (uint i = 0; i &lt; adminList.length; i++) { if(deled&amp;adminDeled != 0) { adminList[i] = admin; adminDeled ^= deled; break; } deled &lt;&lt;= 1; } } else { adminList.push(admin); } } function removeAdmin(identity admin) public onlyAdmin { uint index = indexAdmin(admin); bool isValid = index != adminList.length; emit USER_EXIST(isValid, UserRole.RoleAdmin); require(isValid); delete adminList[index]; adminDeled ^= 1 &lt;&lt; index; } function queryAdmins() view public onlyAdmin returns (identity[]) { return adminList; } function addCalculator(identity calculator) public onlyAdmin { bool isExist = validCalculator(calculator); emit USER_EXIST(isExist, UserRole.RoleCalculator); require(!isExist); if(calculatorDeled &gt; 0) { uint deled = 1; for (uint i = 0; i &lt; calculatorList.length; i++) { if(deled&amp;calculatorDeled != 0) { calculatorList[i] = calculator; calculatorDeled ^= deled; break; } deled &lt;&lt;= 1; } } else { calculatorList.push(calculator); } } function removeCalculator(identity calculator) public onlyAdmin { uint index = indexCalculator(calculator); bool isValid = index &lt; calculatorList.length; emit USER_EXIST(isValid, UserRole.RoleCalculator); require(isValid); delete calculatorList[index]; calculatorDeled ^= 1 &lt;&lt; index; } function queryCalculators() view public onlyCalculatorOrAdmin returns (identity[]) { return calculatorList; } function addObserver(identity observer) public onlyAdmin { bool isExist = validObserver(observer); emit USER_EXIST(isExist, UserRole.RoleObserver); require(!isExist); if(observerDeled &gt; 0) { uint deled = 1; for (uint i = 0; i &lt; observerList.length; i++) { if(deled&amp;observerDeled != 0) { observerList[i] = observer; observerDeled ^= deled; break; } deled &lt;&lt;= 1; } } else { observerList.push(observer); } } function removeObserver(identity observer) public onlyAdmin { uint index = indexCalculator(observer); bool isValid = index &lt; observerList.length; emit USER_EXIST(isValid, UserRole.RoleObserver); require(isValid); delete observerList[index]; observerDeled ^= 1 &lt;&lt; index; } function queryObservers() view public onlyObserverOrAdmin returns (identity[]) { return observerList; } function checkScoreEquity(uint balance, uint score) { uint total = balance + score; if(total &gt;= 100 &amp;&amp; balance &lt; 100) { emit SCORE_EQUITY_NOTICE(&quot;RentConcessions&quot;, total, &quot;Citizens enjoy a 90% discount on rental housing&quot;); } if(total &gt;= 200 &amp;&amp; balance &lt; 200) { emit SCORE_EQUITY_NOTICE(&quot;RentConcessions_1&quot;, total, &quot;Citizens enjoy a 80% discount on rental housing&quot;); } if(total &gt;= 300 &amp;&amp; balance &lt; 300) { emit SCORE_EQUITY_NOTICE(&quot;PurchaseDiscount&quot;, total, &quot;Citizens enjoy a 90% discount on purchase housing&quot;); } } //积分奖励 function awardScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin { uint balance = leasingScore[player]; leasingScore[player] = balance + score; emit SCORE_OPERATOR(ScoreAction.ActionAwardScore, describe); checkScoreEquity(balance, score); } //积分权级兑换，为消费者主动意愿，若不够花，则不扣除积分，且发送失败事件。 function exchangeScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin returns (bool) { emit SCORE_OPERATOR(ScoreAction.ActionExchangeScore, describe); if(leasingScore[player] &gt;= score) { leasingScore[player] -= score; return true; } emit SCORE_ERROR(ScoreAction.ActionExchangeScore, &quot;Score not enough to exchange&quot;); return false; } //积分扣除，为消费者被动意愿，进行强制积分扣除，若积分不够，则清零，且发送失败时间 function deductScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin { emit SCORE_OPERATOR(ScoreAction.ActionDeductScore, describe); uint balance = leasingScore[player]; if(balance &gt;= score) { leasingScore[player] -= score; } else { if(balance != 0) { leasingScore[player] = 0; } emit SCORE_ERROR(ScoreAction.ActionDeductScore, &quot;Score not enough to deduct&quot;); } } //积分查询 function queryScore(bytes32 player, string describe) view public onlyObserverOrAdmin returns (uint) { emit SCORE_OPERATOR(ScoreAction.ActionQueryScore, describe); return leasingScore[player]; } //拼接字符串 function stringAdd(string a, string b) returns(string){ bytes memory _a = bytes(a); bytes memory _b = bytes(b); bytes memory res = new bytes(_a.length + _b.length); for(uint i = 0;i &lt; _a.length;i++) res[i] = _a[i]; for(uint j = 0;j &lt; _b.length;j++) res[_a.length+j] = _b[j]; return string(res); } //积分转移，将积分从一个一个合约转移到另一个合约 function transferScore(bytes32 player, uint score, LeasingScoreManager toContract, string describe) public onlyCalculatorOrAdmin { //判断积分是否够用并扣除 describe = stringAdd(&quot;Transfer score: &quot;, describe); require(exchangeScore(player, score, describe)); toContract.awardScore(player, score, describe); } } 5，合约编译/部署/测试 5.1 账号信息 参考《蚂蚁区块链第8课 如何创建新的账户，获取私钥和identity标识？》 文章获得辉哥需要的账号的解密私钥和identity。 角色定义如下，其中的私钥已被辉哥篡改过了，防止被误用。 管理者 - test002 identity: 0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20 管理者 - ella identity: 0xfb2cb45b6b443241e38145b6445a6e0ebee0410d19e71d9fd0adf5fc382d49e5 私钥：0x2ac3bc8673454b6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019 操作员 - duncanwang identity: 0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1 私钥：0x46f9c8c5037a92d7fd811b350a42dc63591fb772ea2c104b89ccb48e1784c76c 观察员 - ouyang identity: 0xe26ef3b9bb0244244935f0176e2e4b5b623be3634276ee897810a380ae8c1314 私钥：0x2bc3bc8673454a6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019 市民 - dingheng identity: 0xccaa69e5e5583f2e34885450669c518a6febcdec9040a4d0a2d41cd9f8f8ca40 私钥：0x2bc3bc8673454a6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019 因为目前(2019.04.06)蚂蚁BAAS系统存在一个BUG，导致ella等账号不能被用于智能合约部署，辉哥目前可使用的账号只有test002和duncanwang账号，辉哥在测试用例设计上做了一个小调整。 5.2 合约编译/部署 参考《蚂蚁区块链第5课 如何配置Cloud IDE证书并进行Solidity智能合约调试？》 完成智能合约的编译和部署，采用默认的test002账号。 【告警】在蚂蚁BAAS系统中，相同的合约名称只能使用一次。 如果该合约已部署，可按“已部署合约”根据已部署的智能合约名称来调用合约。 5.3 模拟测试（基本函数测试成功） 账号：test002 账号identity: 0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20 创建 LeasingScoreManager，其合约identity: 0x64d555c5c89575982d319fe7ddd2eb1741a5d3c4386fac168ed5440958ed5044 （1）管理员test002做账户设置操作 &lt;1&gt; 管理员test002部署合约（上海合约）后增加自己为管理员 function addAdmin(identity admin) public onlyAdmin addAdmin(0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20) 结果： tx hash: 0x842c8d85080878942a9fa0c1f356f3284305cb0317ce5aca2ed43291d8cd1a80 log: VALID(bool,uint8): true,0 USER_EXIST(bool,uint8): false,0 &lt;2&gt; 管理员test002增加操作员 duncanwang function addCalculator(identity calculator) public onlyAdmin addCalculator(0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1) 结果： tx hash: 0xe68c2fa466885221dba293e95f803e511ba46e9e111ef1e44e685a2df2e2269b log: VALID(bool,uint8): true,0 USER_EXIST(bool,uint8): false,1 &lt;3&gt; 管理员test002增加观察员 duncanwang function addObserver(identity observer) public onlyAdmin addObserver(0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1) 结果：未记录。 账号切换到duncanwang账号： （2） 操作员duncanwang给市民dingheng增加100积分，理由：在马路上勇敢扶起一位摔倒的80岁老奶奶。 function awardScore(bytes32 player, uint score, string describe) awardScore(“dingheng”,100, “理由：dingheng在马路上勇敢扶起一位摔倒的80岁老奶奶。”) 输出信息： tx hash:0x591daac5d038de4d9a3f437dd8aeea466772b28562792225be3d5af2903ef122 log VALID(bool,uint8): true,1 SCORE_OPERATOR(uint8,string):0,理由：dingheng在马路上勇敢扶起一位摔倒的80岁老奶奶。 SCORE_EQUITY_NOTICE(string,uint256,string): RentConcessions,100,Citizens enjoy a 90% discount on rental housing （3） 操作员duncanwang收到市民dingheng申请，理由：需要租房1年，花费80积分。 function exchangeScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin returns (bool) exchangeScore(“dingheng”, 80, “理由：需要租房1年，花费80积分。”) 输出信息： tx hash:0xd7ce3c91a3b6e3c05117616c4d6e4ad1bc05e5ba8dd016189223a81dbdc0b68a log VALID(bool,uint8): true,1 SCORE_OPERATOR(uint8,string): 1,理由：需要租房1年，花费80积分。 （4）操作员duncanwang发现市民dingheng房租到期后，未及时退租。扣10个积分，电话催丁恒来退租。 function deductScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin deductScore(“dingheng”, 10, “理由：dingheng房租到期后，未及时退租。扣10个积分。”) 输出信息： tx hash:0x970e9ad61dfd9e264cd1bd12ca0d8426d1bbe9a178b0ec88d82d6a30ec2c5c99 log: VALID(bool,uint8): true,1 SCORE_OPERATOR(uint8,string): 2,理由：dingheng房租到期后，未及时退租。扣10个积分。 6，蚂蚁BAAS Solidity语法差异精要 6.1 合约数据类型 蚂蚁区块链合约平台基本支持 Solidity 所有的数据类型，但是对于一些用户编写的合约的输入参数类型并没有完全的支持，比如参数输入中二维数组的输入。同时，蚂蚁区块链合约平台提供了 identity 类型来标注每一个用户的身份，不支持原生 Solidity 中的 address 类型，identity 的长度为 32 字节。 蚂蚁BAAS的identity就是账号名称的SHA256算法产生的32字节内容。 例如，在站长工具网站http://tool.chinaz.com/tools/hash.aspx中输入账号名字duncanwang，获得其identity为0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1 更多信息，可查看 Solidity 官网关于类型的文档（英文）。 6.2 合约关键字 蚂蚁区块链合约平台支持的 Solidity 语法基本与官方文档一致，具体语法介绍可参看 Solidity 官方文档（英文）。 本文主要介绍 Solidity 合约函数构造的常用 权限关键字 和 修饰关键字。 6.3 平台接口函数 蚂蚁区块链合约平台为合约开发者提供一些新的特性接口支持，包括对区块数据获取、交易数据获取、加密方法的支持。 区块数据接口函数 block.blockhash(uint blockNumber) returns (bytes32)：传入 blockNumber，返回块的哈希值。 block.gaslimit (uint)：系统中的 gas 最大值。 block.number (uint)：当前块高度。 block.timestamp (uint)：当前区块创建的时间戳。 now (uint)：block.timestamp 的别名。 交易数据接口函数 msg.data (bytes)：用户的输入数据。 msg.gas (uint)：用户交易中的 gas 值。 msg.sender (identity)：用户交易中的发送方。 msg.sig (bytes4)：用户交易输入数据的前四字节。 msg.value (uint)：用户交易中的 gas 值。 蚂蚁区块链合约平台还支持查询交易哈希，示例如下： tx.txhash (identity) 可通过此方法获取当前交易的哈希值。 6.4 不支持TOKEN转账相关函数 【告警】不支持TOKEN，不支持地址相关的转账函数了。 .balance (uint256): 以 Wei 为单位的 地址类型 的余额。 .transfer(uint256 amount): 向 地址类型 发送数量为 amount 的 Wei，失败时抛出异常，发送 2300 gas 的矿工费，不可调节。 .send(uint256 amount) returns (bool): 向 地址类型 发送数量为 amount 的 Wei，失败时返回 false，发送 2300 gas 的矿工费用，不可调节。 .call(...) returns (bool): 发出低级函数 CALL，失败时返回 false，发送所有可用 gas，可调节。 .callcode(...) returns (bool)： 发出低级函数 CALLCODE，失败时返回 false，发送所有可用 gas，可调节。 .delegatecall(...) returns (bool): 发出低级函数 DELEGATECALL，失败时返回 false，发送所有可用 gas，可调节。 6.5 支持合约间调用 蚂蚁区块链合约平台主要支持两种合约调用方式，分别为 call 和 delegatecall。 call call 类型的合约调用主要是通过调用其他合约代码获取某个方法的调用结果。同时，在执行该合约时，被调用合约的变量会被修改（即修改的是被调用合约的内存），调用执行成功时返回 true，失败则返回 false。如果被调用合约不存在，则返回执行调用合约的 fallback 函数。 函数原型 id.call(bytes4(keccak256(data), args)) returns (bool result) 请求参数 参数 必选 类型 说明 id 是 identity 被调用合约 ID data 是 string 被调用合约方法签名 args 是 var 被调用合约方法传入参数 返回值 参数 必选 类型 说明 result 是 bool 方法返回值，成功为 true，否则为 false。 delegatecall delegatecall 类型的合约调用也是调用其他合约的方法，与 call 不同的是，delegatecall 修改的是合约调用方的内存。此方法的主要目的在于让合约能够在不传输自身状态（如 balance、storage）的情况下使用其他合约的代码。delegatecall 不支持传输 value。 函数原型 id.delegatecall(bytes4(keccak256(data), args)) returns (bool result) 请求参数 参数 必选 类型 说明 id 是 identity 被调用合约 ID data 是 string 被调用合约方法签名 args 是 var 被调用合约方法传入参数 返回值 参数 必选 类型 说明 result 是 bool 方法返回值，成功为 true，否则为 false。 7，参考 （1） Solidity 合约开发 https://tech.antfin.com/docs/2/101909 （2）Solidity官方中文文档 https://solidity-cn.readthedocs.io/zh/develop/","@type":"BlogPosting","url":"/2019/04/06/727226.html","headline":"蚂蚁区块链第11课 以租房积分管理系统为例讲透蚂蚁Solidity语言差异精要","dateModified":"2019-04-06T00:00:00+08:00","datePublished":"2019-04-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/06/727226.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>蚂蚁区块链第11课 以租房积分管理系统为例讲透蚂蚁Solidity语言差异精要</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：如需转载，请私信联系作者。 https://blog.csdn.net/wangdenghui2005/article/details/89060692 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p><img src="https://upload-images.jianshu.io/upload_images/1190574-6787c20fa81dfb45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> 
  <h1><a id="1_2"></a>1，摘要</h1> 
  <p>本文以住房租赁积分管理系统为例，给大家演示CLOUD IDE如何编译调试solidity智能合约，并以此为例，给大家分享以太坊SOLIDITY跟蚂蚁区块链SOLIDITY语言的差异点。</p> 
  <h1><a id="2_5"></a>2，住房租赁积分管理系统的背景和目标</h1> 
  <h2><a id="_6"></a>背景</h2> 
  <p>基于区块链智能合约的住房租赁积分管理系统旨在有效地服务于公众群体、市民，真正让那些为城市当前发展做出努力的人有房住、租得起，让那些为城市建设长远发展做出贡献的人有房产、买得起。为此，建立住房租赁积分制度，从住房租赁市场主体属性、政策激励、租赁行为三方面，运用区块链、大数据等前沿技术，建立科学、有效的住房租赁积分全生命周期管理机制，营造活力、健康、有序、可持续的住房租赁生态。</p> 
  <h2><a id="_10"></a>目标</h2> 
  <p>通过使用区块链平台作为底层数据支撑，确保隐私保护和数据不可篡改，达到公平、公正、透明的目的；利用积分决策引擎，结合住房租赁积分评价体系，产出应用于住房租赁场景的综合积分方案。该方案具备横向扩展性，在底层技术、数据不变的基础上，未来能够支撑经济信用积分、绿色生活积分等诸多积分体系的建设，从而扩展形成城市信用体系，应用于如医疗教育、金融借贷、绿色生活等诸多场景。</p> 
  <h1><a id="3_14"></a>3，合约设计</h1> 
  <h3><a id="_16"></a>权限管理</h3> 
  <p>在住房租赁积分管理系统中，主要分为 4 种角色，分别是管理者、操作者、观察者以及市民。管理者、操作者、观察者是智能合约的操作人员，每个角色可以对应多名人员。市民是租赁积分智能合约服务的对象，是整个智能合约的核心用户。</p> 
  <h4><a id="_20"></a>角色操作权限</h4> 
  <ul> 
   <li>管理者是合约的超级管理员，能够对管理者、操作者以及观察者进行添加、删除、查询操作。</li> 
   <li>操作者可以查询操作者信息。</li> 
   <li>观察者可以查询观察者信息。</li> 
  </ul> 
  <p><img src="http://upload-images.jianshu.io/upload_images/1190574-33caefa5d2c56dc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p> 
  <h4><a id="_28"></a>积分操作权限</h4> 
  <ul> 
   <li>管理者：具有积分奖励、积分查询、积分转移、积分违规扣除、积分权益兑换等积分操作权限。</li> 
   <li>操作者：操作者是由管理者设置的积分操作角色，该角色可以是具体的人员也可以是系统服务，具有积分奖励、积分转移、积分违规扣除、积分权益兑换等积分操作权限。</li> 
   <li>观察者：观察者是由管理者设置的积分查询角色，该角色可以是具体的人员也可以是系统服务，具有积分查询的操作权限。</li> 
   <li>市民：市民是住房租赁积分系统的用户，是住房租赁积分系统的实际权益对象。 
    <ul> 
     <li>市民可以通过组织机构的租赁积分外部服务系统代理的观察者权限查看自己的积分状况。</li> 
     <li>租赁积分外部服务系统会根据市民的合规表现，通过操作者的权限进行积分奖励或积分违规扣除。</li> 
     <li>市民可以通过租赁积分外部服务系统代理的操作者权限进行积分权益兑换或积分转移操作。</li> 
    </ul> </li> 
  </ul> 
  <p><img src="http://upload-images.jianshu.io/upload_images/1190574-267dd679126e5c98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"></p> 
  <h3><a id="_40"></a>积分管理</h3> 
  <p>租赁积分智能合约提供的服务方法包括 <a href="https://tech.antfin.com/docs/2/110277#%E7%A7%AF%E5%88%86%E5%A5%96%E5%8A%B1%EF%BC%88awardScore%EF%BC%89" rel="nofollow">积分奖励</a>、<a href="https://tech.antfin.com/docs/2/110277#%E7%A7%AF%E5%88%86%E6%9F%A5%E8%AF%A2%EF%BC%88queryScore%EF%BC%89" rel="nofollow">积分查询</a>、<a href="https://tech.antfin.com/docs/2/110277#%E7%A7%AF%E5%88%86%E6%9D%83%E7%9B%8A%E5%85%91%E6%8D%A2%EF%BC%88exchangeScore%EF%BC%89" rel="nofollow">积分权益兑换</a>、<a href="https://tech.antfin.com/docs/2/110277#%E7%A7%AF%E5%88%86%E8%BF%9D%E8%A7%84%E6%89%A3%E9%99%A4%EF%BC%88deductScore%EF%BC%89" rel="nofollow">积分违规扣除</a>、<a href="https://tech.antfin.com/docs/2/110277#%E7%A7%AF%E5%88%86%E8%BD%AC%E7%A7%BB%EF%BC%88transferScore%EF%BC%89" rel="nofollow">积分转移</a> 以及积分达到阈值后触发 <a href="https://tech.antfin.com/docs/2/110277#%E7%A7%AF%E5%88%86%E4%BA%8B%E4%BB%B6%EF%BC%88SCORE_EQUITY_NOTICE%EF%BC%89" rel="nofollow">积分事件</a>。</p> 
  <p><img src="http://upload-images.jianshu.io/upload_images/1190574-b372e4fb04566b7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3"></p> 
  <h4><a id="awardScore_46"></a>积分奖励（awardScore）</h4> 
  <p>在市民租赁房屋的过程中，针对租赁的时间、租赁过程中产生的行为，为市民进行积分累计。</p> 
  <h4><a id="queryScore_50"></a>积分查询（queryScore）</h4> 
  <p>市民可通过租赁积分外部服务系统代理的观察者权限查看自己的积分状况。</p> 
  <h4><a id="exchangeScore_54"></a>积分权益兑换（exchangeScore）</h4> 
  <p>市民的积分达到指定阈值后可以享有相应的权益，如租房优惠、买房资格、落户资格等。</p> 
  <h4><a id="deductScore_58"></a>积分违规扣除（deductScore）</h4> 
  <p>在市民租赁房屋的过程中，针对租赁过程中产生的错误行为，对市民惩罚性的扣减积分。住房租赁积分作为正向激励的积分体系，鼓励民众积极向上。对于积分主体的伪造资料行为，视情节严重程度扣减积分、取消积分资格以及收回积分对应的权益。</p> 
  <h4><a id="SCORE_EQUITY_NOTICE_62"></a>积分事件（SCORE_EQUITY_NOTICE）</h4> 
  <p>当积分权益实时增加时，会触发积分权益检查。若积分达到了指定的阈值，则会产生相应的积分权益通知事件。通过外部服务系统通知到具体的市民。</p> 
  <h4><a id="transferScore_66"></a>积分转移（transferScore）</h4> 
  <p>当市民因工作关系、家庭因素需要到其他城市生活时，可以将该城市的积分转移到目标城市的积分系统。为满足该合约的调用，目标合约需要有对应的积分奖励方法（<code>awardScore</code>），且需要为发起合约提供操作权限，即将发起合约的地址设置为操作者或管理员。</p> 
  <h1><a id="4_70"></a>4，智能合约代码</h1> 
  <pre><code>pragma solidity ^0.4.20;
 
contract LeasingScoreManager {
    identity[] adminList;
    identity[] observerList;
    identity[] calculatorList;
 
    //用于记录管理数组被置位元素
    uint adminDeled;
    uint observerDeled;
    uint calculatorDeled;
 
    mapping (bytes32 =&gt; uint) leasingScore;
 
    enum ScoreAction {
        //奖励积分， 因相关行为，进行积分奖励
        ActionAwardScore,
        //积分权益兑换，花费指定积分
        ActionExchangeScore,
        //扣除积分， 因违规等， 扣除积分
        ActionDeductScore,
        //查询积分
        ActionQueryScore
        //积分转移, 将积分转移到其他的合约。
    }
 
    enum UserRole {
        RoleAdmin, //管理员
        RoleCalculator, //积分操作员
        RoleObserver, //积分查看人员
        RolePlayer //积分参与者
    }
 
    //是否为有效的操作人
    event VALID(bool valid, UserRole role);
    //admin/observer/calculator 用户存在
    event USER_EXIST(bool exist, UserRole role);
    //积分事件
    event SCORE_OPERATOR(ScoreAction action, string describe);
    //积分操作错误
    event SCORE_ERROR(ScoreAction action, string describe);
    //积分权益通知
    event SCORE_EQUITY_NOTICE(string action, uint score, string describe);
 
    constructor() public {
        adminList.push(msg.sender);
        adminList.push(this);
    }
 
    function indexAdmin(identity admin) view returns (uint) {
        for (uint i = 0; i &lt; adminList.length; i++) {
            if (adminList[i] == admin) {
                return i;
            }
        }
        return adminList.length;
    }
 
    function validAdmin(identity admin) view returns (bool) {
        return indexAdmin(admin) &lt; adminList.length;
    }
 
    function indexCalculator(identity calculator) view returns (uint) {
        for (uint i = 0; i &lt; calculatorList.length; i++) {
            if (calculatorList[i] == calculator) {
                return i;
            }
        }
        return calculatorList.length;
    }
 
    function validCalculator(identity calculator) view returns (bool) {
        return indexCalculator(calculator) &lt; calculatorList.length;
    }
 
    function indexObserver(identity observer) view returns (uint) {
        for (uint i = 0; i &lt; observerList.length; i++) {
            if (observerList[i] == observer) {
                return i;
            }
        }
        return observerList.length;
    }
 
    function validObserver(identity observer) view returns (bool) {
        return indexObserver(observer) &lt; observerList.length;
    }
 
    modifier onlyAdmin {
        bool isValid = validAdmin(msg.sender);
        emit VALID(isValid, UserRole.RoleAdmin);
        require(isValid);
        _;
    }
 
    modifier onlyCalculatorOrAdmin {
        bool isValid = validAdmin(msg.sender);
        if(isValid) {
            emit VALID(isValid, UserRole.RoleAdmin);
        } else {
            isValid = validCalculator(msg.sender);
            emit VALID(isValid, UserRole.RoleCalculator);
        }
        require(isValid);
        _;
    }
 
    modifier onlyObserverOrAdmin {
        bool isValid = validAdmin(msg.sender);
        if(isValid) {
            emit VALID(isValid, UserRole.RoleAdmin);
        } else {
            isValid = validObserver(msg.sender);
            emit VALID(isValid, UserRole.RoleObserver);
        }
        require(isValid);
        _;
    }
 
    function addAdmin(identity admin) public onlyAdmin {
        bool isExist = validAdmin(admin);
        emit USER_EXIST(isExist, UserRole.RoleAdmin);
        require(!isExist);
        if(adminDeled &gt; 0) {
            uint deled = 1;
            for (uint i = 0; i &lt; adminList.length; i++) {
                if(deled&amp;adminDeled != 0) {
                    adminList[i] = admin;
                    adminDeled ^= deled;
                    break;
                }
                deled &lt;&lt;= 1;
            }
        } else {
            adminList.push(admin);
        }
    }
 
    function removeAdmin(identity admin) public onlyAdmin {
        uint index = indexAdmin(admin);
        bool isValid = index != adminList.length;
        emit USER_EXIST(isValid, UserRole.RoleAdmin);
        require(isValid);
        delete adminList[index];
        adminDeled ^= 1 &lt;&lt; index;
    }
 
    function queryAdmins() view public onlyAdmin returns (identity[]) {
        return adminList;
    }
 
    function addCalculator(identity calculator) public onlyAdmin {
        bool isExist = validCalculator(calculator);
        emit USER_EXIST(isExist, UserRole.RoleCalculator);
        require(!isExist);
        if(calculatorDeled &gt; 0) {
            uint deled = 1;
            for (uint i = 0; i &lt; calculatorList.length; i++) {
                if(deled&amp;calculatorDeled != 0) {
                    calculatorList[i] = calculator;
                    calculatorDeled ^= deled;
                    break;
                }
                deled &lt;&lt;= 1;
            }
        } else {
            calculatorList.push(calculator);
        }
    }
 
    function removeCalculator(identity calculator) public onlyAdmin {
        uint index = indexCalculator(calculator);
        bool isValid = index &lt; calculatorList.length;
        emit USER_EXIST(isValid, UserRole.RoleCalculator);
        require(isValid);
        delete calculatorList[index];
        calculatorDeled ^= 1 &lt;&lt; index;
    }
 
    function queryCalculators() view public onlyCalculatorOrAdmin returns (identity[]) {
        return calculatorList;
    }
 
    function addObserver(identity observer) public onlyAdmin {
        bool isExist = validObserver(observer);
        emit USER_EXIST(isExist, UserRole.RoleObserver);
        require(!isExist);
        if(observerDeled &gt; 0) {
            uint deled = 1;
            for (uint i = 0; i &lt; observerList.length; i++) {
                if(deled&amp;observerDeled != 0) {
                    observerList[i] = observer;
                    observerDeled ^= deled;
                    break;
                }
                deled &lt;&lt;= 1;
            }
        } else {
            observerList.push(observer);
        }
    }
 
    function removeObserver(identity observer) public onlyAdmin {
        uint index = indexCalculator(observer);
        bool isValid = index &lt; observerList.length;
        emit USER_EXIST(isValid, UserRole.RoleObserver);
        require(isValid);
        delete observerList[index];
        observerDeled ^= 1 &lt;&lt; index;
    }
 
    function queryObservers() view public onlyObserverOrAdmin returns (identity[]) {
        return observerList;
    }
 
    function checkScoreEquity(uint balance, uint score) {
        uint total = balance + score;
        if(total &gt;= 100 &amp;&amp; balance &lt; 100) {
            emit SCORE_EQUITY_NOTICE("RentConcessions", total, "Citizens enjoy a 90% discount on rental housing");
        }
        if(total &gt;= 200 &amp;&amp; balance &lt; 200) {
            emit SCORE_EQUITY_NOTICE("RentConcessions_1", total, "Citizens enjoy a 80% discount on rental housing");
        }
        if(total &gt;= 300 &amp;&amp; balance &lt; 300) {
            emit SCORE_EQUITY_NOTICE("PurchaseDiscount", total, "Citizens enjoy a 90% discount on purchase housing");
        }
    }
 
    //积分奖励
    function awardScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin {
        uint balance = leasingScore[player];
        leasingScore[player] = balance + score;
        emit SCORE_OPERATOR(ScoreAction.ActionAwardScore, describe);
        checkScoreEquity(balance, score);
    }
 
    //积分权级兑换，为消费者主动意愿，若不够花，则不扣除积分，且发送失败事件。
    function exchangeScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin returns (bool) {
        emit SCORE_OPERATOR(ScoreAction.ActionExchangeScore, describe);
        if(leasingScore[player] &gt;= score) {
            leasingScore[player] -= score;
            return true;
        }
        emit SCORE_ERROR(ScoreAction.ActionExchangeScore, "Score not enough to exchange");
        return false;
    }
 
    //积分扣除，为消费者被动意愿，进行强制积分扣除，若积分不够，则清零，且发送失败时间
    function deductScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin {
        emit SCORE_OPERATOR(ScoreAction.ActionDeductScore, describe);
        uint balance = leasingScore[player];
        if(balance &gt;= score) {
            leasingScore[player] -= score;
        } else {
            if(balance != 0) {
                leasingScore[player] = 0;
            }
            emit SCORE_ERROR(ScoreAction.ActionDeductScore, "Score not enough to deduct");
        }
    }
 
    //积分查询
    function queryScore(bytes32 player, string describe) view public onlyObserverOrAdmin returns (uint) {
        emit SCORE_OPERATOR(ScoreAction.ActionQueryScore, describe);
        return leasingScore[player];
    }
 
    //拼接字符串
    function stringAdd(string a, string b) returns(string){
        bytes memory _a = bytes(a);
        bytes memory _b = bytes(b);
        bytes memory res = new bytes(_a.length + _b.length);
        for(uint i = 0;i &lt; _a.length;i++)
            res[i] = _a[i];
        for(uint j = 0;j &lt; _b.length;j++)
            res[_a.length+j] = _b[j];  
        return string(res);
    }
 
    //积分转移，将积分从一个一个合约转移到另一个合约
    function transferScore(bytes32 player, uint score, LeasingScoreManager toContract, string describe) public onlyCalculatorOrAdmin {
        //判断积分是否够用并扣除
        describe =  stringAdd("Transfer score: ", describe);
        require(exchangeScore(player, score, describe));
        toContract.awardScore(player, score, describe);
    }
}
</code></pre> 
  <h1><a id="5_360"></a>5，合约编译/部署/测试</h1> 
  <h2><a id="51__361"></a>5.1 账号信息</h2> 
  <p>参考<a href="https://www.jianshu.com/p/566c34a916eb" rel="nofollow">《蚂蚁区块链第8课 如何创建新的账户，获取私钥和identity标识？》</a> 文章获得辉哥需要的账号的解密私钥和identity。</p> 
  <p>角色定义如下，其中的私钥已被辉哥篡改过了，防止被误用。</p> 
  <pre><code>管理者 - test002  identity: 0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20
管理者 - ella  identity: 0xfb2cb45b6b443241e38145b6445a6e0ebee0410d19e71d9fd0adf5fc382d49e5
私钥：0x2ac3bc8673454b6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019
操作员 - duncanwang identity: 0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1 
私钥：0x46f9c8c5037a92d7fd811b350a42dc63591fb772ea2c104b89ccb48e1784c76c
观察员 - ouyang identity: 0xe26ef3b9bb0244244935f0176e2e4b5b623be3634276ee897810a380ae8c1314
私钥：0x2bc3bc8673454a6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019
市民 - dingheng identity: 0xccaa69e5e5583f2e34885450669c518a6febcdec9040a4d0a2d41cd9f8f8ca40
私钥：0x2bc3bc8673454a6de00fc8815b5f2676084d2e6c74d3a0fdf34b5e63ead6e019
</code></pre> 
  <p>因为目前(2019.04.06)蚂蚁BAAS系统存在一个BUG，导致ella等账号不能被用于智能合约部署，辉哥目前可使用的账号只有test002和duncanwang账号，辉哥在测试用例设计上做了一个小调整。</p> 
  <h2><a id="52__378"></a>5.2 合约编译/部署</h2> 
  <p>参考<a href="https://www.jianshu.com/p/8026592b451d" rel="nofollow">《蚂蚁区块链第5课 如何配置Cloud IDE证书并进行Solidity智能合约调试？》</a> 完成智能合约的编译和部署，采用默认的test002账号。<br> <strong>【告警】在蚂蚁BAAS系统中，相同的合约名称只能使用一次。</strong><br> 如果该合约已部署，可按“已部署合约”根据已部署的智能合约名称来调用合约。</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/1190574-3cb3db8ab658a12c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用test002部署的LeasingScoreManager合约"></p> 
  <h2><a id="53__385"></a>5.3 模拟测试（基本函数测试成功）</h2> 
  <p>账号：test002<br> 账号identity: 0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20<br> 创建 LeasingScoreManager，其合约identity: 0x64d555c5c89575982d319fe7ddd2eb1741a5d3c4386fac168ed5440958ed5044</p> 
  <h4><a id="1test002_390"></a>（1）管理员test002做账户设置操作</h4> 
  <p><strong>&lt;1&gt; 管理员test002部署合约（上海合约）后增加自己为管理员</strong><br> function addAdmin(identity admin) public onlyAdmin<br> addAdmin(0xd6b1f9e8a0da740fa04245a41b78eba7be9214cf96e7f6594899706e64050d20)<br> <img src="https://upload-images.jianshu.io/upload_images/1190574-e1c0d98996f8f9e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1- 管理员test002部署合约（上海合约）后增加自己为管理员"></p> 
  <p>结果：</p> 
  <blockquote> 
   <p>tx hash: 0x842c8d85080878942a9fa0c1f356f3284305cb0317ce5aca2ed43291d8cd1a80<br> log:<br> VALID(bool,uint8): true,0<br> USER_EXIST(bool,uint8): false,0</p> 
  </blockquote> 
  <p><strong>&lt;2&gt; 管理员test002增加操作员 duncanwang</strong><br> function addCalculator(identity calculator) public onlyAdmin<br> addCalculator(0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1)</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/1190574-1a2c7c354a8f11af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2- 管理员test002增加操作员 duncanwang"></p> 
  <p>结果：</p> 
  <blockquote> 
   <p>tx hash: 0xe68c2fa466885221dba293e95f803e511ba46e9e111ef1e44e685a2df2e2269b<br> log:<br> VALID(bool,uint8): true,0<br> USER_EXIST(bool,uint8): false,1</p> 
  </blockquote> 
  <p><strong>&lt;3&gt; 管理员test002增加观察员 duncanwang</strong><br> function addObserver(identity observer) public onlyAdmin<br> addObserver(0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1)</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/1190574-eff59ed2a7b8df77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-管理员test002增加观察员 duncanwang"></p> 
  <blockquote> 
   <p>结果：未记录。</p> 
  </blockquote> 
  <p><strong>账号切换到duncanwang账号：</strong></p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/1190574-4b4b5c711dab8aef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.切换到duncanwang账号"></p> 
  <h4><a id="2_duncanwangdingheng10080_430"></a>（2） 操作员duncanwang给市民dingheng增加100积分，理由：在马路上勇敢扶起一位摔倒的80岁老奶奶。</h4> 
  <p>function awardScore(bytes32 player, uint score, string describe)<br> awardScore(“dingheng”,100, “理由：dingheng在马路上勇敢扶起一位摔倒的80岁老奶奶。”)<br> <img src="https://upload-images.jianshu.io/upload_images/1190574-0092a266a12770fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.增加积分"></p> 
  <p>输出信息：</p> 
  <blockquote> 
   <p>tx hash:0x591daac5d038de4d9a3f437dd8aeea466772b28562792225be3d5af2903ef122<br> log<br> VALID(bool,uint8): true,1<br> SCORE_OPERATOR(uint8,string):0,理由：dingheng在马路上勇敢扶起一位摔倒的80岁老奶奶。<br> SCORE_EQUITY_NOTICE(string,uint256,string): RentConcessions,100,Citizens enjoy a 90% discount on rental housing</p> 
  </blockquote> 
  <h4><a id="3_duncanwangdingheng180_442"></a>（3） 操作员duncanwang收到市民dingheng申请，理由：需要租房1年，花费80积分。</h4> 
  <p>function exchangeScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin returns (bool)<br> exchangeScore(“dingheng”, 80, “理由：需要租房1年，花费80积分。”)</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/1190574-10bbb715bbc71916.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.租房花费积分"></p> 
  <p>输出信息：</p> 
  <blockquote> 
   <p>tx hash:0xd7ce3c91a3b6e3c05117616c4d6e4ad1bc05e5ba8dd016189223a81dbdc0b68a<br> log<br> VALID(bool,uint8): true,1<br> SCORE_OPERATOR(uint8,string): 1,理由：需要租房1年，花费80积分。</p> 
  </blockquote> 
  <h4><a id="4duncanwangdingheng10_455"></a>（4）操作员duncanwang发现市民dingheng房租到期后，未及时退租。扣10个积分，电话催丁恒来退租。</h4> 
  <p>function deductScore(bytes32 player, uint score, string describe) public onlyCalculatorOrAdmin<br> deductScore(“dingheng”, 10, “理由：dingheng房租到期后，未及时退租。扣10个积分。”)</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/1190574-399824534dc2fa6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10 租房到期未退租扣除积分"></p> 
  <p>输出信息：</p> 
  <blockquote> 
   <p>tx hash:0x970e9ad61dfd9e264cd1bd12ca0d8426d1bbe9a178b0ec88d82d6a30ec2c5c99<br> log:<br> VALID(bool,uint8): true,1<br> SCORE_OPERATOR(uint8,string): 2,理由：dingheng房租到期后，未及时退租。扣10个积分。</p> 
  </blockquote> 
  <h1><a id="6BAAS_Solidity_467"></a>6，蚂蚁BAAS Solidity语法差异精要</h1> 
  <h2><a id="61__468"></a>6.1 合约数据类型</h2> 
  <p>蚂蚁区块链合约平台基本支持 Solidity 所有的数据类型，但是对于一些用户编写的合约的输入参数类型并没有完全的支持，比如参数输入中二维数组的输入。同时，蚂蚁区块链合约平台提供了 identity 类型来标注每一个用户的身份，不支持原生 Solidity 中的 address 类型，identity 的长度为 32 字节。<br> 蚂蚁BAAS的identity就是账号名称的SHA256算法产生的32字节内容。<br> 例如，在站长工具网站<a href="https://links.jianshu.com/go?to=http%3A%2F%2Ftool.chinaz.com%2Ftools%2Fhash.aspx" rel="nofollow">http://tool.chinaz.com/tools/hash.aspx</a>中输入账号名字duncanwang，获得其identity为0x4983bcbaf60b9c90dc9d9a0b38a8931aad9a444acaa2adcbc61c5e3e218c49e1</p> 
  <p><img src="https://upload-images.jianshu.io/upload_images/1190574-88a6ec6715c8dc1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> 
  <p>更多信息，可查看 <a href="https://solidity.readthedocs.io/en/v0.4.24/types.html" rel="nofollow">Solidity 官网关于类型的文档（英文）</a>。</p> 
  <h2><a id="62__477"></a>6.2 合约关键字</h2> 
  <blockquote> 
   <p>蚂蚁区块链合约平台支持的 Solidity 语法基本与官方文档一致，具体语法介绍可参看 <a href="https://solidity.readthedocs.io/en/v0.4.24/solidity-in-depth.html" rel="nofollow">Solidity 官方文档（英文）</a>。</p> 
  </blockquote> 
  <p>本文主要介绍 Solidity 合约函数构造的常用 <a href="https://tech.antfin.com/docs/2/101968##%20%E5%87%BD%E6%95%B0%E6%9D%83%E9%99%90%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">权限关键字</a> 和 <a href="https://tech.antfin.com/docs/2/101968##%20%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">修饰关键字</a>。</p> 
  <h2><a id="63__482"></a>6.3 平台接口函数</h2> 
  <p>蚂蚁区块链合约平台为合约开发者提供一些新的特性接口支持，包括对区块数据获取、交易数据获取、加密方法的支持。</p> 
  <h3><a id="_485"></a>区块数据接口函数</h3> 
  <ul> 
   <li>block.blockhash(uint blockNumber) returns (bytes32)：传入 <code>blockNumber</code>，返回块的哈希值。</li> 
   <li>block.gaslimit (uint)：系统中的 gas 最大值。</li> 
   <li>block.number (uint)：当前块高度。</li> 
   <li>block.timestamp (uint)：当前区块创建的时间戳。</li> 
   <li>now (uint)：<code>block.timestamp</code> 的别名。</li> 
  </ul> 
  <h3><a id="_493"></a>交易数据接口函数</h3> 
  <ul> 
   <li>msg.data (bytes)：用户的输入数据。</li> 
   <li>msg.gas (uint)：用户交易中的 gas 值。</li> 
   <li>msg.sender (identity)：用户交易中的发送方。</li> 
   <li>msg.sig (bytes4)：用户交易输入数据的前四字节。</li> 
   <li>msg.value (uint)：用户交易中的 gas 值。</li> 
  </ul> 
  <p>蚂蚁区块链合约平台还支持查询交易哈希，示例如下：</p> 
  <pre><code>tx.txhash (identity)
</code></pre> 
  <p>可通过此方法获取当前交易的哈希值。</p> 
  <h2><a id="64_TOKEN_510"></a>6.4 不支持TOKEN转账相关函数</h2> 
  <p><strong>【告警】不支持TOKEN，不支持地址相关的转账函数了。</strong></p> 
  <address>.balance (uint256): 以 Wei 为单位的 地址类型 的余额。 <address>.transfer(uint256 amount): 向 地址类型 发送数量为 amount 的 Wei，失败时抛出异常，发送 2300 gas 的矿工费，不可调节。 <address>.send(uint256 amount) returns (bool): 向 地址类型 发送数量为 amount 的 Wei，失败时返回 false，发送 2300 gas 的矿工费用，不可调节。 <address>.call(...) returns (bool): 发出低级函数 CALL，失败时返回 false，发送所有可用 gas，可调节。 <address>.callcode(...) returns (bool)： 发出低级函数 CALLCODE，失败时返回 false，发送所有可用 gas，可调节。 <address>.delegatecall(...) returns (bool): 发出低级函数 DELEGATECALL，失败时返回 false，发送所有可用 gas，可调节。 </address></address></address></address></address></address>
  <h2><a id="65__526"></a>6.5 支持合约间调用</h2> 
  <p>蚂蚁区块链合约平台主要支持两种合约调用方式，分别为 <code>call</code> 和 <code>delegatecall</code>。</p> 
  <h3><a id="call_529"></a>call</h3> 
  <p><code>call</code> 类型的合约调用主要是通过调用其他合约代码获取某个方法的调用结果。同时，在执行该合约时，被调用合约的变量会被修改（即修改的是被调用合约的内存），调用执行成功时返回 true，失败则返回 false。如果被调用合约不存在，则返回执行调用合约的 <code>fallback</code> 函数。</p> 
  <h4><a id="_533"></a>函数原型</h4> 
  <pre><code>id.call(bytes4(keccak256(data), args)) returns (bool result)
</code></pre> 
  <h4><a id="_539"></a>请求参数</h4> 
  <table> 
   <thead> 
    <tr> 
     <th>参数</th> 
     <th>必选</th> 
     <th>类型</th> 
     <th>说明</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>id</td> 
     <td>是</td> 
     <td>identity</td> 
     <td>被调用合约 ID</td> 
    </tr> 
    <tr> 
     <td>data</td> 
     <td>是</td> 
     <td>string</td> 
     <td>被调用合约方法签名</td> 
    </tr> 
    <tr> 
     <td>args</td> 
     <td>是</td> 
     <td>var</td> 
     <td>被调用合约方法传入参数</td> 
    </tr> 
   </tbody> 
  </table>
  <h4><a id="_547"></a>返回值</h4> 
  <table> 
   <thead> 
    <tr> 
     <th>参数</th> 
     <th>必选</th> 
     <th>类型</th> 
     <th>说明</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>result</td> 
     <td>是</td> 
     <td>bool</td> 
     <td>方法返回值，成功为 true，否则为 false。</td> 
    </tr> 
   </tbody> 
  </table>
  <h3><a id="delegatecall_553"></a>delegatecall</h3> 
  <p><code>delegatecall</code> 类型的合约调用也是调用其他合约的方法，与 <code>call</code> 不同的是，<code>delegatecall</code> 修改的是合约调用方的内存。此方法的主要目的在于让合约能够在不传输自身状态（如 <code>balance</code>、<code>storage</code>）的情况下使用其他合约的代码。<code>delegatecall</code> 不支持传输 value。</p> 
  <h4><a id="_557"></a>函数原型</h4> 
  <pre><code>id.delegatecall(bytes4(keccak256(data), args)) returns (bool result)
</code></pre> 
  <h4><a id="_563"></a>请求参数</h4> 
  <table> 
   <thead> 
    <tr> 
     <th>参数</th> 
     <th>必选</th> 
     <th>类型</th> 
     <th>说明</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>id</td> 
     <td>是</td> 
     <td>identity</td> 
     <td>被调用合约 ID</td> 
    </tr> 
    <tr> 
     <td>data</td> 
     <td>是</td> 
     <td>string</td> 
     <td>被调用合约方法签名</td> 
    </tr> 
    <tr> 
     <td>args</td> 
     <td>是</td> 
     <td>var</td> 
     <td>被调用合约方法传入参数</td> 
    </tr> 
   </tbody> 
  </table>
  <h4><a id="_571"></a>返回值</h4> 
  <table> 
   <thead> 
    <tr> 
     <th>参数</th> 
     <th>必选</th> 
     <th>类型</th> 
     <th>说明</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>result</td> 
     <td>是</td> 
     <td>bool</td> 
     <td>方法返回值，成功为 true，否则为 false。</td> 
    </tr> 
   </tbody> 
  </table>
  <h1><a id="7_578"></a>7，参考</h1> 
  <p>（1） Solidity 合约开发 <a href="https://tech.antfin.com/docs/2/101909" rel="nofollow">https://tech.antfin.com/docs/2/101909</a><br> （2）Solidity官方中文文档 <a href="https://solidity-cn.readthedocs.io/zh/develop/" rel="nofollow">https://solidity-cn.readthedocs.io/zh/develop/</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
