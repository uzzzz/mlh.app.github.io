<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>汇编语言（王爽第三版）实验1 查看CPU和内存，用机器指令和汇编指令编程 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="汇编语言（王爽第三版）实验1 查看CPU和内存，用机器指令和汇编指令编程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="实验1 查看CPU和内存，用机器指令和汇编指令编程 1.预备知识：Debug的使用 我们以后所有的实验中，都将用到debug程序，首先学习一下它的主要用法。 （1）什么是Debug？ Debug是DOS、Windows都提供的实模式（8086方式）程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 知识小贴士：实模式和保护模式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intel的80286处理器于1982年问世了，它的地址总线位数增加到了24位，因此可以访问到16M的内存空间。更重要的是从此开始引进了一个全新理念--保护模式。这种模式下内存段的访问受到了限制。访问内存时不能直接从段寄存器中获得段的起始地址了，而需要经过额外转换和检查。为了和过去兼容，80286内存寻址可以有两种方式，一种是先进的保护模式，另一种是老式的8086方式，被成为实模式。系统启动时处理器处于实模式，只能访问1M空间，经过处理可进入保护模式，访问空间扩大到16M，但是要想从保护模式返回到实模式，你只有重新启动机器。还有一个致命的缺陷是80286虽然扩大了访问空间，但是每个段的大小还是64k，程序规模仍受到限制。因此这个先天低能儿注定寿命不会很久。很快它就被天资卓越的兄弟--80386代替了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80386是一个32位的CPU，也就是它的ALU数据总线是32位的，同时它的地址总线与数据总线宽度一致，也是32位，因此，其寻址能力达到4GB。对于内存来说，似乎是足够了。从理论上说，当数据总线与地址总线宽度一致时，其CPU结构应该简洁明了。但是，80386无法做到这一点。作为X86产品系列的一员，80386必须维持那些段寄存器的存在，还必须支持实模式，同时又要能支持保护模式，这给Intel的设计人员带来很大的挑战。Intel选择了在段寄存器的基础上构筑保护模式，并且保留段寄存器16位。在保护模式下,它的段范围不再受限于64K，可以达到4G。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从8086的16位到80386的32位处理器，这看起来是处理器位数的变化，但实质上是处理器体系结构的变化，从寻址方式上说，就是从“实模式”到“保护模式”的变化。从80386以后，Intel的CPU经历了80486、Pentium、PentiumII、PentiumIII等型号，虽然它们在速度上提高了好几个数量级，功能上也有不少改进，但基本上属于同一种系统结构的改进与加强，而无本质的变化，所以我们把80386以后的处理器统称为IA32（32 Bit Intel Architecture）。 （2）我们用到的Debug功能 R命令查看、改变CPU寄存器的内容； D命令查看内存中的内容； E命令改写内存中的内容； U命令将内存中的机器指令翻译成汇编指令； T命令执行一条机器指令； A命令以汇编指令的格式在内存中写入一条机器指令。 P命令 到了 int 21H，我们要用P命令执行；进入循环时用p命令也可以退出循环 G命令g命令调试时能跳到想去的地址，特别是调试循环代码时 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug的命令比较多（详细请看资料），共有20多个，但这6个命令是和汇编学习密切相关的。在以后的实验中，我们还会用到一个P命令。 （3）进入Debug。 （4）用R命令查看、改变CPU寄存器的内容。由于开发环境的不同，cmd调试结果也是不同的，这里只是将它们的意义说明。 -r AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107看图说明： 【1】ax，bx，cx，dx，cx，ip是我们讲过的6中寄存器，其中ax，bx，cx，dx都是通用寄存器，但是它们也有特定的用途，以后慢慢了解。cs和ip寄存器是专门寄存器。 【2】0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107 含义：CS=0B04&nbsp; IP=0100 也就是CPU将要读取的从0B04:0100开始内存单元的指令，这个指令机器码是：E80400；debug程序将这个机器码翻译成汇编指令是CALL&nbsp;&nbsp;&nbsp; 0107 理解：这个CPU指向的地址cs：ip就是CPU将要读取并执行的指令代码。当然，这个代码对于我们来说是没有任何意义的。 在debug状态下，我们可以使用R命令修改上述寄存器的值。 例如： r cs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指令含义：修改cs寄存器值 r ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指令含义：修改ip寄存器值 r ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指令含义：修改ax寄存器值 （5）使用D命令查看内存中的内容。 直接显示从某单元地址开始内容； 指令格式：d 段地址：偏移地址 例如： -d 0b04:0 0B04:0000&nbsp; CD 20 FF 9F 00 9A EE FE-1D F0 4F 03 68 05 8A 03 &nbsp;&nbsp; . ........O.h... 0B04:0010&nbsp; 68 05 17 03 68 05 1C 04-01 01 01 00 02 FF FF FF&nbsp;&nbsp; h...h........... 0B04:0020&nbsp; FF FF FF FF FF FF FF FF-FF FF FF FF 15 05 4E 01&nbsp;&nbsp; ..............N. 0B04:0030&nbsp; 28 0A 14 00 18 00 04 0B-FF FF FF FF 00 00 00 00&nbsp;&nbsp; (............... 0B04:0040&nbsp; 05 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00&nbsp;&nbsp; ................ 0B04:0050&nbsp; CD 21 CB 00 00 00 00 00-00 00 00 00 00 20 20 20&nbsp;&nbsp; .!........... 0B04:0060&nbsp; 20 20 20 20 20 20 20 20-00 00 00 00 00 20 20 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ..... 0B04:0070&nbsp; 20 20 20 20 20 20 20 20-00 00 00 00 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ........ 【1】中间的红色部分是从指定地址开始的内存单元中的内容，每一行为16个字节，用16进制格式输出。内存单元是从低地址向高地址显示的。在红色区域左边的是每行的起始地址（段地址：偏移地址）；偏移地址的变化都是16的整数倍，在debug中就是10H。红色区域的右侧是将内存单元存储的值所对应的ASCII码字符，如果不在ASCII码的范围，以“.”形式列出（表示不可识别的ASCII码）。 【2】在debug中，使用D命令显示的内存单元，是为了便于我们调试程序时查看内存的状态。此处注意，真正的内存依然是单列、连续的线性存储空间。而不是像debug中显示的按照表的形式存在。 【3】使用d命令后，我们可以继续使用单个的“d”命令，继续显示连续的内存单元内容。每次显示128个单元（128个字节）内容。 【4】使用 d 段地址：偏移地址（开始） 偏移地址（结束）来显示一段连续内存单元的内容；例如：-d 0b04:0 7 显示的是从0~7共8个内存单元的内容。 （6）用Debug的E命令改写内存中的内容： 【1】可以使用E命令来改写内存中的内容，按照字节单元的方式修改 例如：-e 0b04:0&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从内存单元0b04:0开始，改写内存单元的内容。回车键结束；注意使用空格。 【2】可以使用E命令修改内存中内容，直接按照ASCII码的方式修改 例如： -e 0b04:100 &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,1,&#39;a+b&#39;&nbsp;&nbsp;&nbsp;&nbsp; ;修改内存单元，直接写入ASCII码 -d 0b04:100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;查看内存单元 0B04:0100&nbsp; 61 62 63 64 65 01 61 2B-62 8A F1 80 FC 01 74 09&nbsp;&nbsp; abcde.a+b.....t. 【3】使用E命令修改代码段中指令的代码，这个太累了。不推荐。 （7）使用U命令查看指定内存单元开始的汇编代码和机器码。 -u 0b04:100 0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107 0B04:0103 32C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XOR&nbsp;&nbsp;&nbsp;&nbsp; AL,AL 0B04:0105 AA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STOSB 0B04:0106 C3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RET 0B04:0107 B400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AH,00 …… 这里我们看见右侧的是汇编代码，中间的是机器码，左侧的是内存单元地址（物理地址）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 小技巧：如果将某个段内存的段地址赋值给段寄存器，则在执行命令时，使用寄存器名称即可。例如：-u 0b04:100&nbsp;&nbsp;&nbsp; 等价于-u cs:100（因为cs=0b04） （8）使用t命令执行cs:ip指向的内存单元的指令，单步的执行。注意执行后，每个寄存器值的变化。 （9）使用A命令，以汇编指令的形式在内存中写入机器指令。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上面使用E命令可以在内存中修改单元内容，达到写入机器指令的目的，太累了，写的都是机器码；这个命令就很好，直接按照汇编指令形式写入指令； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意此指令不接受汇编的伪指令。只接受正确的汇编指令。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用回车键结束汇编指令的写入。 2. 实验任务 （1）使用debug，将下面的程序段写入内存，逐条执行，观察每条指令执行后CPU中相关寄存器中内容的变化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 机器码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 汇编指令 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b8 20 4e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax，4E20H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 05 16 14 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax，1416H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bb 00 20 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx,2000H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax,bx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89 c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx,ax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax,bx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b8 1a 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 001aH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bb 26 00&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx,0026H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add al,bl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 dc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ah,bl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 c7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add bh,al &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b4 00 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah,0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add al,bl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 04 9c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add al,9cH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提示，可用E命令和A命令以两种方式将指令写入内存。注意用T命令执行时，cs:ip的指向。 打开cmd窗口（命令提示符窗口），键入debug；回车 -r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;查看寄存器的状态 AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107&nbsp; 我们发现CS=0B04 ； IP=0100，也就是说CPU从这里读取代码并执行。我们也在这开始吧。（注：这个是我的系统debug，你的机器系统不一样，导致debug后寄存器状态不同。） 【1】首先使用E命令 -e cs:100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;使用e命令在cs：100开始修改内存单元内容 0B04:0100&nbsp; E8.b8&nbsp;&nbsp; 04.20&nbsp;&nbsp; 00.4e&nbsp;&nbsp; 32.05&nbsp;&nbsp; C0.16&nbsp;&nbsp; AA.14&nbsp;&nbsp; C3.bb&nbsp;&nbsp; B4.00 0B04:0108&nbsp; 00.20&nbsp;&nbsp; 8A.01&nbsp;&nbsp; F1.d8&nbsp; …… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用e命令在cs：100开始修改内存单元内容，将上边的机器码逐个写入内存中。注意红色的是CPU要执行的机器码。回车后修改完毕。 -u cs:100 0B04:0100 B8204E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,4E20 0B04:0103 051614&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp; AX,1416 0B04:0106 BB0020&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; BX,2000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用u命令查看下，看看汇编指令是否正常？ ……太累了，此处省略一万字。将所有的机器码都使用上述方式用E命令写入到cs：100开始的内存单元中。 【2】使用a命令，直接写入汇编指令。 -a cs:100 0B04:0100 mov ax, 4e20 0B04:0103 add ax,1416H ^ Error 0B04:0103 add ax,1416 0B04:0106 mov bx,2000 0B04:0109 add ax,bx 0B04:010B mov bx,ax 0B04:010D add ax,bx 0B04:010F mov ax,001a 0B04:0112 mov bx,0026 0B04:0115 add al,bl 0B04:0117 add ah,bl 0B04:0119 add bh,al 0B04:011B mov ah,0 0B04:011D add al,bl 0B04:011F add al,9c &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在cs:100开始的内存单元处，使用汇编指令写入执行代码。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意红色的为什么报错？在debug中，一律按照16机制计算（不带H），如果是十进制数值，你需要转换为16进制。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 写汇编源程序时，你可以随便使用任何进制，因为有编译器自动给你转换了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们发现，使用a命令比较方便，但这二种方式的结果是一样的，都是在cs：100开始的内存单元中写入了这些指令。 我们使用d命令查看下这段内存的内容： -d cs:100 0B04:0100&nbsp; B8 20 4E 05 16 14 BB 00-20 01 D8 89 C3 01 D8 B8&nbsp;&nbsp; . N..... ....... 0B04:0110&nbsp; 1A 00 BB 26 00 00 D8 00-DC 00 C7 B4 00 00 D8 04&nbsp;&nbsp; ...&amp;............ 0B04:0120&nbsp; 9C FC 00 74 20 80 FC 01-75 22 3A CE 75 05 80 3C&nbsp;&nbsp; ...t ...u&quot;:.u..&lt;&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们发现，内存单元中也都是存储着16进制的数据，跟其他内存空间存储的结构是一样的，但这里存储的是CPU执行的代码。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从而验证了，内存单元存储的数据不区分数值还是指令，在于你在应用层面上的解析。 【3】怎么执行？使用T命令，确保cs存储的就是我们期望的代码段的段地址，ip存储的也是我们期望的开始偏移地址，如果不是，我们可以使用r命令修改cs或ip的值。 -r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;显示寄存器状态值， AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0100 B8204E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,4E20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;这条指令就是CPU将要读取的指令 -t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;执行MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,4E20指令 AX=4E20&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0103&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0103 051614&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp; AX,1416 执行完毕后，我们发现ax寄存器的值变化了。 按要求，逐步执行t命令，体会汇编指令导致寄存器变量值的变化。 （2）将下面3条指令写入从2000:0开始的内存单元中，利用这3条指令计算2的8次方。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax，1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax，ax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp 2000:0003 【1】使用a命令在2000：0处写入这3条代码 -a 2000:0 2000:0000 mov ax, 1 2000:0003 add ax,ax 2000:0005 jmp 2000:0003 使用u命令我们查看下是否写入成功； -u 2000:0 2000:0000 B80100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,0001 2000:0003 01C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp; AX,AX 2000:0005 EBFC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JMP&nbsp;&nbsp;&nbsp;&nbsp; 0003 【2】使用r命令查看寄存器状态 -r AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 发现CS=0B04&nbsp; IP=0100不是我们期望的，我们把代码写入了2000:0000H了。希望CPU从2000:0000H开始执行。故将cs和ip修改为2000和0000； 使用r命令直接修改。 -r cs CS 0B04 :2000 -r ip IP 0100 :0 【3】使用t命令执行代码，注意观察ax值的变化。由于jmp 2000:0003指令导致这段程序流程为死循环，执行8次循环后，使用q命令直接退出吧。 （3）查看内存中的内容。 PC机主板上的ROM中写有一个生产日期，在内存FFF00H~FFFFFH的某几个单元中，请找到这个生产日期，并试图改变它。 【1】使用d命令查看内存单元的内容，由于物理地址是：FFF00H，我们可以假定偏移地址是0，那么段地址是FFF0H，也就是我们使用D命令查询的是从FFF0：0~FFF0：00FFH的范围。 打开cmd，键入debug -d fff0:0 ff …… FFF0:00F0&nbsp; EA 5B E0 00 F0 31 30 2F-30 35 2F 30 37 00 FC AD&nbsp;&nbsp; .[...10/05/07... 我们发现在00f5开始的内存单元存储着主板的生产日期。看红色标记。 &nbsp; &nbsp; 尝试使用e命令修改此段内容，发现成功了！（兴奋！），重新打开cmd，查看内存发现显示依然是原来的结果，为毛？因为只读，不让你改。这里只是模拟模式一个假象。在实模式下，你试试就知道了。 （4）向内存从B800H开始的单元中填写数据，如： -e b810：0000&nbsp; 01 01 02 02 02 03 03 04 04 观察产生的现象；再改变填写的地址，观察产生的现象。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们发现，写入的数据在屏幕的第1行第9列开始显示ASCII字符。其中2个字节代表显示一个字符，前一个字节代表字符本身，后一个字符代表字符的属性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 结论：在DOS或命令提示符窗口下，B800：0000开始是显示缓冲区。以后我们多次接触这个。 &nbsp;" />
<meta property="og:description" content="实验1 查看CPU和内存，用机器指令和汇编指令编程 1.预备知识：Debug的使用 我们以后所有的实验中，都将用到debug程序，首先学习一下它的主要用法。 （1）什么是Debug？ Debug是DOS、Windows都提供的实模式（8086方式）程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 知识小贴士：实模式和保护模式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intel的80286处理器于1982年问世了，它的地址总线位数增加到了24位，因此可以访问到16M的内存空间。更重要的是从此开始引进了一个全新理念--保护模式。这种模式下内存段的访问受到了限制。访问内存时不能直接从段寄存器中获得段的起始地址了，而需要经过额外转换和检查。为了和过去兼容，80286内存寻址可以有两种方式，一种是先进的保护模式，另一种是老式的8086方式，被成为实模式。系统启动时处理器处于实模式，只能访问1M空间，经过处理可进入保护模式，访问空间扩大到16M，但是要想从保护模式返回到实模式，你只有重新启动机器。还有一个致命的缺陷是80286虽然扩大了访问空间，但是每个段的大小还是64k，程序规模仍受到限制。因此这个先天低能儿注定寿命不会很久。很快它就被天资卓越的兄弟--80386代替了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80386是一个32位的CPU，也就是它的ALU数据总线是32位的，同时它的地址总线与数据总线宽度一致，也是32位，因此，其寻址能力达到4GB。对于内存来说，似乎是足够了。从理论上说，当数据总线与地址总线宽度一致时，其CPU结构应该简洁明了。但是，80386无法做到这一点。作为X86产品系列的一员，80386必须维持那些段寄存器的存在，还必须支持实模式，同时又要能支持保护模式，这给Intel的设计人员带来很大的挑战。Intel选择了在段寄存器的基础上构筑保护模式，并且保留段寄存器16位。在保护模式下,它的段范围不再受限于64K，可以达到4G。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从8086的16位到80386的32位处理器，这看起来是处理器位数的变化，但实质上是处理器体系结构的变化，从寻址方式上说，就是从“实模式”到“保护模式”的变化。从80386以后，Intel的CPU经历了80486、Pentium、PentiumII、PentiumIII等型号，虽然它们在速度上提高了好几个数量级，功能上也有不少改进，但基本上属于同一种系统结构的改进与加强，而无本质的变化，所以我们把80386以后的处理器统称为IA32（32 Bit Intel Architecture）。 （2）我们用到的Debug功能 R命令查看、改变CPU寄存器的内容； D命令查看内存中的内容； E命令改写内存中的内容； U命令将内存中的机器指令翻译成汇编指令； T命令执行一条机器指令； A命令以汇编指令的格式在内存中写入一条机器指令。 P命令 到了 int 21H，我们要用P命令执行；进入循环时用p命令也可以退出循环 G命令g命令调试时能跳到想去的地址，特别是调试循环代码时 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug的命令比较多（详细请看资料），共有20多个，但这6个命令是和汇编学习密切相关的。在以后的实验中，我们还会用到一个P命令。 （3）进入Debug。 （4）用R命令查看、改变CPU寄存器的内容。由于开发环境的不同，cmd调试结果也是不同的，这里只是将它们的意义说明。 -r AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107看图说明： 【1】ax，bx，cx，dx，cx，ip是我们讲过的6中寄存器，其中ax，bx，cx，dx都是通用寄存器，但是它们也有特定的用途，以后慢慢了解。cs和ip寄存器是专门寄存器。 【2】0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107 含义：CS=0B04&nbsp; IP=0100 也就是CPU将要读取的从0B04:0100开始内存单元的指令，这个指令机器码是：E80400；debug程序将这个机器码翻译成汇编指令是CALL&nbsp;&nbsp;&nbsp; 0107 理解：这个CPU指向的地址cs：ip就是CPU将要读取并执行的指令代码。当然，这个代码对于我们来说是没有任何意义的。 在debug状态下，我们可以使用R命令修改上述寄存器的值。 例如： r cs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指令含义：修改cs寄存器值 r ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指令含义：修改ip寄存器值 r ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指令含义：修改ax寄存器值 （5）使用D命令查看内存中的内容。 直接显示从某单元地址开始内容； 指令格式：d 段地址：偏移地址 例如： -d 0b04:0 0B04:0000&nbsp; CD 20 FF 9F 00 9A EE FE-1D F0 4F 03 68 05 8A 03 &nbsp;&nbsp; . ........O.h... 0B04:0010&nbsp; 68 05 17 03 68 05 1C 04-01 01 01 00 02 FF FF FF&nbsp;&nbsp; h...h........... 0B04:0020&nbsp; FF FF FF FF FF FF FF FF-FF FF FF FF 15 05 4E 01&nbsp;&nbsp; ..............N. 0B04:0030&nbsp; 28 0A 14 00 18 00 04 0B-FF FF FF FF 00 00 00 00&nbsp;&nbsp; (............... 0B04:0040&nbsp; 05 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00&nbsp;&nbsp; ................ 0B04:0050&nbsp; CD 21 CB 00 00 00 00 00-00 00 00 00 00 20 20 20&nbsp;&nbsp; .!........... 0B04:0060&nbsp; 20 20 20 20 20 20 20 20-00 00 00 00 00 20 20 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ..... 0B04:0070&nbsp; 20 20 20 20 20 20 20 20-00 00 00 00 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ........ 【1】中间的红色部分是从指定地址开始的内存单元中的内容，每一行为16个字节，用16进制格式输出。内存单元是从低地址向高地址显示的。在红色区域左边的是每行的起始地址（段地址：偏移地址）；偏移地址的变化都是16的整数倍，在debug中就是10H。红色区域的右侧是将内存单元存储的值所对应的ASCII码字符，如果不在ASCII码的范围，以“.”形式列出（表示不可识别的ASCII码）。 【2】在debug中，使用D命令显示的内存单元，是为了便于我们调试程序时查看内存的状态。此处注意，真正的内存依然是单列、连续的线性存储空间。而不是像debug中显示的按照表的形式存在。 【3】使用d命令后，我们可以继续使用单个的“d”命令，继续显示连续的内存单元内容。每次显示128个单元（128个字节）内容。 【4】使用 d 段地址：偏移地址（开始） 偏移地址（结束）来显示一段连续内存单元的内容；例如：-d 0b04:0 7 显示的是从0~7共8个内存单元的内容。 （6）用Debug的E命令改写内存中的内容： 【1】可以使用E命令来改写内存中的内容，按照字节单元的方式修改 例如：-e 0b04:0&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从内存单元0b04:0开始，改写内存单元的内容。回车键结束；注意使用空格。 【2】可以使用E命令修改内存中内容，直接按照ASCII码的方式修改 例如： -e 0b04:100 &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,1,&#39;a+b&#39;&nbsp;&nbsp;&nbsp;&nbsp; ;修改内存单元，直接写入ASCII码 -d 0b04:100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;查看内存单元 0B04:0100&nbsp; 61 62 63 64 65 01 61 2B-62 8A F1 80 FC 01 74 09&nbsp;&nbsp; abcde.a+b.....t. 【3】使用E命令修改代码段中指令的代码，这个太累了。不推荐。 （7）使用U命令查看指定内存单元开始的汇编代码和机器码。 -u 0b04:100 0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107 0B04:0103 32C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XOR&nbsp;&nbsp;&nbsp;&nbsp; AL,AL 0B04:0105 AA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STOSB 0B04:0106 C3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RET 0B04:0107 B400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AH,00 …… 这里我们看见右侧的是汇编代码，中间的是机器码，左侧的是内存单元地址（物理地址）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 小技巧：如果将某个段内存的段地址赋值给段寄存器，则在执行命令时，使用寄存器名称即可。例如：-u 0b04:100&nbsp;&nbsp;&nbsp; 等价于-u cs:100（因为cs=0b04） （8）使用t命令执行cs:ip指向的内存单元的指令，单步的执行。注意执行后，每个寄存器值的变化。 （9）使用A命令，以汇编指令的形式在内存中写入机器指令。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上面使用E命令可以在内存中修改单元内容，达到写入机器指令的目的，太累了，写的都是机器码；这个命令就很好，直接按照汇编指令形式写入指令； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意此指令不接受汇编的伪指令。只接受正确的汇编指令。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用回车键结束汇编指令的写入。 2. 实验任务 （1）使用debug，将下面的程序段写入内存，逐条执行，观察每条指令执行后CPU中相关寄存器中内容的变化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 机器码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 汇编指令 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b8 20 4e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax，4E20H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 05 16 14 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax，1416H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bb 00 20 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx,2000H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax,bx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89 c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx,ax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax,bx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b8 1a 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 001aH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bb 26 00&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx,0026H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add al,bl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 dc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ah,bl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 c7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add bh,al &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b4 00 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah,0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add al,bl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 04 9c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add al,9cH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提示，可用E命令和A命令以两种方式将指令写入内存。注意用T命令执行时，cs:ip的指向。 打开cmd窗口（命令提示符窗口），键入debug；回车 -r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;查看寄存器的状态 AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107&nbsp; 我们发现CS=0B04 ； IP=0100，也就是说CPU从这里读取代码并执行。我们也在这开始吧。（注：这个是我的系统debug，你的机器系统不一样，导致debug后寄存器状态不同。） 【1】首先使用E命令 -e cs:100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;使用e命令在cs：100开始修改内存单元内容 0B04:0100&nbsp; E8.b8&nbsp;&nbsp; 04.20&nbsp;&nbsp; 00.4e&nbsp;&nbsp; 32.05&nbsp;&nbsp; C0.16&nbsp;&nbsp; AA.14&nbsp;&nbsp; C3.bb&nbsp;&nbsp; B4.00 0B04:0108&nbsp; 00.20&nbsp;&nbsp; 8A.01&nbsp;&nbsp; F1.d8&nbsp; …… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用e命令在cs：100开始修改内存单元内容，将上边的机器码逐个写入内存中。注意红色的是CPU要执行的机器码。回车后修改完毕。 -u cs:100 0B04:0100 B8204E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,4E20 0B04:0103 051614&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp; AX,1416 0B04:0106 BB0020&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; BX,2000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用u命令查看下，看看汇编指令是否正常？ ……太累了，此处省略一万字。将所有的机器码都使用上述方式用E命令写入到cs：100开始的内存单元中。 【2】使用a命令，直接写入汇编指令。 -a cs:100 0B04:0100 mov ax, 4e20 0B04:0103 add ax,1416H ^ Error 0B04:0103 add ax,1416 0B04:0106 mov bx,2000 0B04:0109 add ax,bx 0B04:010B mov bx,ax 0B04:010D add ax,bx 0B04:010F mov ax,001a 0B04:0112 mov bx,0026 0B04:0115 add al,bl 0B04:0117 add ah,bl 0B04:0119 add bh,al 0B04:011B mov ah,0 0B04:011D add al,bl 0B04:011F add al,9c &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在cs:100开始的内存单元处，使用汇编指令写入执行代码。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意红色的为什么报错？在debug中，一律按照16机制计算（不带H），如果是十进制数值，你需要转换为16进制。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 写汇编源程序时，你可以随便使用任何进制，因为有编译器自动给你转换了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们发现，使用a命令比较方便，但这二种方式的结果是一样的，都是在cs：100开始的内存单元中写入了这些指令。 我们使用d命令查看下这段内存的内容： -d cs:100 0B04:0100&nbsp; B8 20 4E 05 16 14 BB 00-20 01 D8 89 C3 01 D8 B8&nbsp;&nbsp; . N..... ....... 0B04:0110&nbsp; 1A 00 BB 26 00 00 D8 00-DC 00 C7 B4 00 00 D8 04&nbsp;&nbsp; ...&amp;............ 0B04:0120&nbsp; 9C FC 00 74 20 80 FC 01-75 22 3A CE 75 05 80 3C&nbsp;&nbsp; ...t ...u&quot;:.u..&lt;&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们发现，内存单元中也都是存储着16进制的数据，跟其他内存空间存储的结构是一样的，但这里存储的是CPU执行的代码。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从而验证了，内存单元存储的数据不区分数值还是指令，在于你在应用层面上的解析。 【3】怎么执行？使用T命令，确保cs存储的就是我们期望的代码段的段地址，ip存储的也是我们期望的开始偏移地址，如果不是，我们可以使用r命令修改cs或ip的值。 -r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;显示寄存器状态值， AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0100 B8204E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,4E20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;这条指令就是CPU将要读取的指令 -t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;执行MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,4E20指令 AX=4E20&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0103&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0103 051614&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp; AX,1416 执行完毕后，我们发现ax寄存器的值变化了。 按要求，逐步执行t命令，体会汇编指令导致寄存器变量值的变化。 （2）将下面3条指令写入从2000:0开始的内存单元中，利用这3条指令计算2的8次方。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax，1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax，ax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp 2000:0003 【1】使用a命令在2000：0处写入这3条代码 -a 2000:0 2000:0000 mov ax, 1 2000:0003 add ax,ax 2000:0005 jmp 2000:0003 使用u命令我们查看下是否写入成功； -u 2000:0 2000:0000 B80100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,0001 2000:0003 01C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp; AX,AX 2000:0005 EBFC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JMP&nbsp;&nbsp;&nbsp;&nbsp; 0003 【2】使用r命令查看寄存器状态 -r AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 发现CS=0B04&nbsp; IP=0100不是我们期望的，我们把代码写入了2000:0000H了。希望CPU从2000:0000H开始执行。故将cs和ip修改为2000和0000； 使用r命令直接修改。 -r cs CS 0B04 :2000 -r ip IP 0100 :0 【3】使用t命令执行代码，注意观察ax值的变化。由于jmp 2000:0003指令导致这段程序流程为死循环，执行8次循环后，使用q命令直接退出吧。 （3）查看内存中的内容。 PC机主板上的ROM中写有一个生产日期，在内存FFF00H~FFFFFH的某几个单元中，请找到这个生产日期，并试图改变它。 【1】使用d命令查看内存单元的内容，由于物理地址是：FFF00H，我们可以假定偏移地址是0，那么段地址是FFF0H，也就是我们使用D命令查询的是从FFF0：0~FFF0：00FFH的范围。 打开cmd，键入debug -d fff0:0 ff …… FFF0:00F0&nbsp; EA 5B E0 00 F0 31 30 2F-30 35 2F 30 37 00 FC AD&nbsp;&nbsp; .[...10/05/07... 我们发现在00f5开始的内存单元存储着主板的生产日期。看红色标记。 &nbsp; &nbsp; 尝试使用e命令修改此段内容，发现成功了！（兴奋！），重新打开cmd，查看内存发现显示依然是原来的结果，为毛？因为只读，不让你改。这里只是模拟模式一个假象。在实模式下，你试试就知道了。 （4）向内存从B800H开始的单元中填写数据，如： -e b810：0000&nbsp; 01 01 02 02 02 03 03 04 04 观察产生的现象；再改变填写的地址，观察产生的现象。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们发现，写入的数据在屏幕的第1行第9列开始显示ASCII字符。其中2个字节代表显示一个字符，前一个字节代表字符本身，后一个字符代表字符的属性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 结论：在DOS或命令提示符窗口下，B800：0000开始是显示缓冲区。以后我们多次接触这个。 &nbsp;" />
<link rel="canonical" href="https://mlh.app/2019/04/06/727700.html" />
<meta property="og:url" content="https://mlh.app/2019/04/06/727700.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"实验1 查看CPU和内存，用机器指令和汇编指令编程 1.预备知识：Debug的使用 我们以后所有的实验中，都将用到debug程序，首先学习一下它的主要用法。 （1）什么是Debug？ Debug是DOS、Windows都提供的实模式（8086方式）程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 知识小贴士：实模式和保护模式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intel的80286处理器于1982年问世了，它的地址总线位数增加到了24位，因此可以访问到16M的内存空间。更重要的是从此开始引进了一个全新理念--保护模式。这种模式下内存段的访问受到了限制。访问内存时不能直接从段寄存器中获得段的起始地址了，而需要经过额外转换和检查。为了和过去兼容，80286内存寻址可以有两种方式，一种是先进的保护模式，另一种是老式的8086方式，被成为实模式。系统启动时处理器处于实模式，只能访问1M空间，经过处理可进入保护模式，访问空间扩大到16M，但是要想从保护模式返回到实模式，你只有重新启动机器。还有一个致命的缺陷是80286虽然扩大了访问空间，但是每个段的大小还是64k，程序规模仍受到限制。因此这个先天低能儿注定寿命不会很久。很快它就被天资卓越的兄弟--80386代替了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80386是一个32位的CPU，也就是它的ALU数据总线是32位的，同时它的地址总线与数据总线宽度一致，也是32位，因此，其寻址能力达到4GB。对于内存来说，似乎是足够了。从理论上说，当数据总线与地址总线宽度一致时，其CPU结构应该简洁明了。但是，80386无法做到这一点。作为X86产品系列的一员，80386必须维持那些段寄存器的存在，还必须支持实模式，同时又要能支持保护模式，这给Intel的设计人员带来很大的挑战。Intel选择了在段寄存器的基础上构筑保护模式，并且保留段寄存器16位。在保护模式下,它的段范围不再受限于64K，可以达到4G。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从8086的16位到80386的32位处理器，这看起来是处理器位数的变化，但实质上是处理器体系结构的变化，从寻址方式上说，就是从“实模式”到“保护模式”的变化。从80386以后，Intel的CPU经历了80486、Pentium、PentiumII、PentiumIII等型号，虽然它们在速度上提高了好几个数量级，功能上也有不少改进，但基本上属于同一种系统结构的改进与加强，而无本质的变化，所以我们把80386以后的处理器统称为IA32（32 Bit Intel Architecture）。 （2）我们用到的Debug功能 R命令查看、改变CPU寄存器的内容； D命令查看内存中的内容； E命令改写内存中的内容； U命令将内存中的机器指令翻译成汇编指令； T命令执行一条机器指令； A命令以汇编指令的格式在内存中写入一条机器指令。 P命令 到了 int 21H，我们要用P命令执行；进入循环时用p命令也可以退出循环 G命令g命令调试时能跳到想去的地址，特别是调试循环代码时 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug的命令比较多（详细请看资料），共有20多个，但这6个命令是和汇编学习密切相关的。在以后的实验中，我们还会用到一个P命令。 （3）进入Debug。 （4）用R命令查看、改变CPU寄存器的内容。由于开发环境的不同，cmd调试结果也是不同的，这里只是将它们的意义说明。 -r AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107看图说明： 【1】ax，bx，cx，dx，cx，ip是我们讲过的6中寄存器，其中ax，bx，cx，dx都是通用寄存器，但是它们也有特定的用途，以后慢慢了解。cs和ip寄存器是专门寄存器。 【2】0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107 含义：CS=0B04&nbsp; IP=0100 也就是CPU将要读取的从0B04:0100开始内存单元的指令，这个指令机器码是：E80400；debug程序将这个机器码翻译成汇编指令是CALL&nbsp;&nbsp;&nbsp; 0107 理解：这个CPU指向的地址cs：ip就是CPU将要读取并执行的指令代码。当然，这个代码对于我们来说是没有任何意义的。 在debug状态下，我们可以使用R命令修改上述寄存器的值。 例如： r cs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指令含义：修改cs寄存器值 r ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指令含义：修改ip寄存器值 r ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指令含义：修改ax寄存器值 （5）使用D命令查看内存中的内容。 直接显示从某单元地址开始内容； 指令格式：d 段地址：偏移地址 例如： -d 0b04:0 0B04:0000&nbsp; CD 20 FF 9F 00 9A EE FE-1D F0 4F 03 68 05 8A 03 &nbsp;&nbsp; . ........O.h... 0B04:0010&nbsp; 68 05 17 03 68 05 1C 04-01 01 01 00 02 FF FF FF&nbsp;&nbsp; h...h........... 0B04:0020&nbsp; FF FF FF FF FF FF FF FF-FF FF FF FF 15 05 4E 01&nbsp;&nbsp; ..............N. 0B04:0030&nbsp; 28 0A 14 00 18 00 04 0B-FF FF FF FF 00 00 00 00&nbsp;&nbsp; (............... 0B04:0040&nbsp; 05 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00&nbsp;&nbsp; ................ 0B04:0050&nbsp; CD 21 CB 00 00 00 00 00-00 00 00 00 00 20 20 20&nbsp;&nbsp; .!........... 0B04:0060&nbsp; 20 20 20 20 20 20 20 20-00 00 00 00 00 20 20 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ..... 0B04:0070&nbsp; 20 20 20 20 20 20 20 20-00 00 00 00 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ........ 【1】中间的红色部分是从指定地址开始的内存单元中的内容，每一行为16个字节，用16进制格式输出。内存单元是从低地址向高地址显示的。在红色区域左边的是每行的起始地址（段地址：偏移地址）；偏移地址的变化都是16的整数倍，在debug中就是10H。红色区域的右侧是将内存单元存储的值所对应的ASCII码字符，如果不在ASCII码的范围，以“.”形式列出（表示不可识别的ASCII码）。 【2】在debug中，使用D命令显示的内存单元，是为了便于我们调试程序时查看内存的状态。此处注意，真正的内存依然是单列、连续的线性存储空间。而不是像debug中显示的按照表的形式存在。 【3】使用d命令后，我们可以继续使用单个的“d”命令，继续显示连续的内存单元内容。每次显示128个单元（128个字节）内容。 【4】使用 d 段地址：偏移地址（开始） 偏移地址（结束）来显示一段连续内存单元的内容；例如：-d 0b04:0 7 显示的是从0~7共8个内存单元的内容。 （6）用Debug的E命令改写内存中的内容： 【1】可以使用E命令来改写内存中的内容，按照字节单元的方式修改 例如：-e 0b04:0&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从内存单元0b04:0开始，改写内存单元的内容。回车键结束；注意使用空格。 【2】可以使用E命令修改内存中内容，直接按照ASCII码的方式修改 例如： -e 0b04:100 &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,1,&#39;a+b&#39;&nbsp;&nbsp;&nbsp;&nbsp; ;修改内存单元，直接写入ASCII码 -d 0b04:100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;查看内存单元 0B04:0100&nbsp; 61 62 63 64 65 01 61 2B-62 8A F1 80 FC 01 74 09&nbsp;&nbsp; abcde.a+b.....t. 【3】使用E命令修改代码段中指令的代码，这个太累了。不推荐。 （7）使用U命令查看指定内存单元开始的汇编代码和机器码。 -u 0b04:100 0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107 0B04:0103 32C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XOR&nbsp;&nbsp;&nbsp;&nbsp; AL,AL 0B04:0105 AA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STOSB 0B04:0106 C3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RET 0B04:0107 B400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AH,00 …… 这里我们看见右侧的是汇编代码，中间的是机器码，左侧的是内存单元地址（物理地址）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 小技巧：如果将某个段内存的段地址赋值给段寄存器，则在执行命令时，使用寄存器名称即可。例如：-u 0b04:100&nbsp;&nbsp;&nbsp; 等价于-u cs:100（因为cs=0b04） （8）使用t命令执行cs:ip指向的内存单元的指令，单步的执行。注意执行后，每个寄存器值的变化。 （9）使用A命令，以汇编指令的形式在内存中写入机器指令。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上面使用E命令可以在内存中修改单元内容，达到写入机器指令的目的，太累了，写的都是机器码；这个命令就很好，直接按照汇编指令形式写入指令； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意此指令不接受汇编的伪指令。只接受正确的汇编指令。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用回车键结束汇编指令的写入。 2. 实验任务 （1）使用debug，将下面的程序段写入内存，逐条执行，观察每条指令执行后CPU中相关寄存器中内容的变化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 机器码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 汇编指令 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b8 20 4e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax，4E20H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 05 16 14 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax，1416H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bb 00 20 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx,2000H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax,bx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89 c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx,ax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax,bx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b8 1a 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 001aH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bb 26 00&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx,0026H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add al,bl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 dc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ah,bl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 c7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add bh,al &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b4 00 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah,0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add al,bl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 04 9c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add al,9cH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提示，可用E命令和A命令以两种方式将指令写入内存。注意用T命令执行时，cs:ip的指向。 打开cmd窗口（命令提示符窗口），键入debug；回车 -r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;查看寄存器的状态 AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0100 E80400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp; 0107&nbsp; 我们发现CS=0B04 ； IP=0100，也就是说CPU从这里读取代码并执行。我们也在这开始吧。（注：这个是我的系统debug，你的机器系统不一样，导致debug后寄存器状态不同。） 【1】首先使用E命令 -e cs:100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;使用e命令在cs：100开始修改内存单元内容 0B04:0100&nbsp; E8.b8&nbsp;&nbsp; 04.20&nbsp;&nbsp; 00.4e&nbsp;&nbsp; 32.05&nbsp;&nbsp; C0.16&nbsp;&nbsp; AA.14&nbsp;&nbsp; C3.bb&nbsp;&nbsp; B4.00 0B04:0108&nbsp; 00.20&nbsp;&nbsp; 8A.01&nbsp;&nbsp; F1.d8&nbsp; …… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用e命令在cs：100开始修改内存单元内容，将上边的机器码逐个写入内存中。注意红色的是CPU要执行的机器码。回车后修改完毕。 -u cs:100 0B04:0100 B8204E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,4E20 0B04:0103 051614&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp; AX,1416 0B04:0106 BB0020&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; BX,2000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用u命令查看下，看看汇编指令是否正常？ ……太累了，此处省略一万字。将所有的机器码都使用上述方式用E命令写入到cs：100开始的内存单元中。 【2】使用a命令，直接写入汇编指令。 -a cs:100 0B04:0100 mov ax, 4e20 0B04:0103 add ax,1416H ^ Error 0B04:0103 add ax,1416 0B04:0106 mov bx,2000 0B04:0109 add ax,bx 0B04:010B mov bx,ax 0B04:010D add ax,bx 0B04:010F mov ax,001a 0B04:0112 mov bx,0026 0B04:0115 add al,bl 0B04:0117 add ah,bl 0B04:0119 add bh,al 0B04:011B mov ah,0 0B04:011D add al,bl 0B04:011F add al,9c &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在cs:100开始的内存单元处，使用汇编指令写入执行代码。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意红色的为什么报错？在debug中，一律按照16机制计算（不带H），如果是十进制数值，你需要转换为16进制。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 写汇编源程序时，你可以随便使用任何进制，因为有编译器自动给你转换了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们发现，使用a命令比较方便，但这二种方式的结果是一样的，都是在cs：100开始的内存单元中写入了这些指令。 我们使用d命令查看下这段内存的内容： -d cs:100 0B04:0100&nbsp; B8 20 4E 05 16 14 BB 00-20 01 D8 89 C3 01 D8 B8&nbsp;&nbsp; . N..... ....... 0B04:0110&nbsp; 1A 00 BB 26 00 00 D8 00-DC 00 C7 B4 00 00 D8 04&nbsp;&nbsp; ...&amp;............ 0B04:0120&nbsp; 9C FC 00 74 20 80 FC 01-75 22 3A CE 75 05 80 3C&nbsp;&nbsp; ...t ...u&quot;:.u..&lt;&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们发现，内存单元中也都是存储着16进制的数据，跟其他内存空间存储的结构是一样的，但这里存储的是CPU执行的代码。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从而验证了，内存单元存储的数据不区分数值还是指令，在于你在应用层面上的解析。 【3】怎么执行？使用T命令，确保cs存储的就是我们期望的代码段的段地址，ip存储的也是我们期望的开始偏移地址，如果不是，我们可以使用r命令修改cs或ip的值。 -r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;显示寄存器状态值， AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0100 B8204E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,4E20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;这条指令就是CPU将要读取的指令 -t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;执行MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,4E20指令 AX=4E20&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0103&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 0B04:0103 051614&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp; AX,1416 执行完毕后，我们发现ax寄存器的值变化了。 按要求，逐步执行t命令，体会汇编指令导致寄存器变量值的变化。 （2）将下面3条指令写入从2000:0开始的内存单元中，利用这3条指令计算2的8次方。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax，1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax，ax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp 2000:0003 【1】使用a命令在2000：0处写入这3条代码 -a 2000:0 2000:0000 mov ax, 1 2000:0003 add ax,ax 2000:0005 jmp 2000:0003 使用u命令我们查看下是否写入成功； -u 2000:0 2000:0000 B80100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; AX,0001 2000:0003 01C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp; AX,AX 2000:0005 EBFC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JMP&nbsp;&nbsp;&nbsp;&nbsp; 0003 【2】使用r命令查看寄存器状态 -r AX=0000&nbsp; BX=0000&nbsp; CX=0000&nbsp; DX=0000&nbsp; SP=FFEE&nbsp; BP=0000&nbsp; SI=0000&nbsp; DI=0000 DS=0B04&nbsp; ES=0B04&nbsp; SS=0B04&nbsp; CS=0B04&nbsp; IP=0100&nbsp;&nbsp; NV UP EI PL NZ NA PO NC 发现CS=0B04&nbsp; IP=0100不是我们期望的，我们把代码写入了2000:0000H了。希望CPU从2000:0000H开始执行。故将cs和ip修改为2000和0000； 使用r命令直接修改。 -r cs CS 0B04 :2000 -r ip IP 0100 :0 【3】使用t命令执行代码，注意观察ax值的变化。由于jmp 2000:0003指令导致这段程序流程为死循环，执行8次循环后，使用q命令直接退出吧。 （3）查看内存中的内容。 PC机主板上的ROM中写有一个生产日期，在内存FFF00H~FFFFFH的某几个单元中，请找到这个生产日期，并试图改变它。 【1】使用d命令查看内存单元的内容，由于物理地址是：FFF00H，我们可以假定偏移地址是0，那么段地址是FFF0H，也就是我们使用D命令查询的是从FFF0：0~FFF0：00FFH的范围。 打开cmd，键入debug -d fff0:0 ff …… FFF0:00F0&nbsp; EA 5B E0 00 F0 31 30 2F-30 35 2F 30 37 00 FC AD&nbsp;&nbsp; .[...10/05/07... 我们发现在00f5开始的内存单元存储着主板的生产日期。看红色标记。 &nbsp; &nbsp; 尝试使用e命令修改此段内容，发现成功了！（兴奋！），重新打开cmd，查看内存发现显示依然是原来的结果，为毛？因为只读，不让你改。这里只是模拟模式一个假象。在实模式下，你试试就知道了。 （4）向内存从B800H开始的单元中填写数据，如： -e b810：0000&nbsp; 01 01 02 02 02 03 03 04 04 观察产生的现象；再改变填写的地址，观察产生的现象。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们发现，写入的数据在屏幕的第1行第9列开始显示ASCII字符。其中2个字节代表显示一个字符，前一个字节代表字符本身，后一个字符代表字符的属性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 结论：在DOS或命令提示符窗口下，B800：0000开始是显示缓冲区。以后我们多次接触这个。 &nbsp;","@type":"BlogPosting","url":"https://mlh.app/2019/04/06/727700.html","headline":"汇编语言（王爽第三版）实验1 查看CPU和内存，用机器指令和汇编指令编程","dateModified":"2019-04-06T00:00:00+08:00","datePublished":"2019-04-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/06/727700.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>汇编语言（王爽第三版）实验1 查看CPU和内存，用机器指令和汇编指令编程</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-tomorrow-night"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p align="center"> <b><span> 实验</span></b><b><span>1</span></b> <b><span> 查看</span></b><b><span>CPU</span></b><b><span>和内存，用机器指令和汇编指令编程</span></b></p> 
  <p><b><span>1.</span></b><b><span>预备知识：</span><span>Debug</span></b><b><span>的使用</span></b></p> 
  <p><span> 我们以后所有的实验中，都将用到</span><span>debug</span><span>程序，首先学习一下它的主要用法。</span></p> 
  <p><span> （</span><span>1</span><span>）什么是</span><span>Debug</span><span>？</span></p> 
  <p><span>Debug</span><span>是</span><span>DOS</span><span>、</span><span>Windows</span><span>都提供的实模式（</span><span>8086</span><span>方式）程序的调试工具。使用它，可以查看</span><span>CPU</span><span>各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 知识小贴士：实模式和保护模式</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> intel</span><span>的</span><span>80286</span><span>处理器于</span><span>1982</span><span>年问世了，它的地址总线位数增加到了</span><span>24</span><span>位，因此可以访问到</span><span>16M</span><span>的内存空间。更重要的是从此开始引进了一个全新理念</span><span>--</span><span>保护模式。这种模式下内存段的访问受到了限制。访问内存时不能直接从段寄存器中获得段的起始地址了，而需要经过额外转换和检查。为了和过去兼容，</span><span>80286</span><span>内存寻址可以有两种方式，一种是先进的保护模式，另一种是老式的</span><span>8086</span><span>方式，被成为实模式。系统启动时处理器处于实模式，只能访问</span><span>1M</span><span>空间，经过处理可进入保护模式，访问空间扩大到</span><span>16M</span><span>，但是要想从保护模式返回到实模式，你只有重新启动机器。还有一个致命的缺陷是</span><span>80286</span><span>虽然扩大了访问空间，但是每个段的大小还是</span><span>64k</span><span>，程序规模仍受到限制。因此这个先天低能儿注定寿命不会很久。很快它就被天资卓越的兄弟</span><span>--80386</span><span>代替了。</span><span><br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 80386</span><span>是一个</span><span>32</span><span>位的</span><span>CPU</span><span>，也就是它的</span><span>ALU</span><span>数据总线是</span><span>32</span><span>位的，同时它的地址总线与数据总线宽度一致，也是</span><span>32</span><span>位，因此，其寻址能力达到</span><span>4GB</span><span>。对于内存来说，似乎是足够了。从理论上说，当数据总线与地址总线宽度一致时，其</span><span>CPU</span><span>结构应该简洁明了。但是，</span><span>80386</span><span>无法做到这一点。作为</span><span>X86</span><span>产品系列的一员，</span><span>80386</span><span>必须维持那些段寄存器的存在，还必须支持实模式，同时又要能支持保护模式，这给</span><span>Intel</span><span>的设计人员带来很大的挑战。</span><span>Intel</span><span>选择了在段寄存器的基础上构筑保护模式，并且保留段寄存器</span><span>16</span><span>位。在保护模式下</span><span>,</span><span>它的段范围不再受限于</span><span>64K</span><span>，可以达到</span><span>4G</span><span>。这一下真正解放了软件工程师</span><span>,</span><span>他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。</span><span><br> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 从</span><span>8086</span><span>的</span><span>16</span><span>位到</span><span>80386</span><span>的</span><span>32</span><span>位处理器，这看起来是处理器位数的变化，但实质上是处理器体系结构的变化，从寻址方式上说，就是从</span><span>“</span><span>实模式</span><span>”</span><span>到</span><span>“</span><span>保护模式</span><span>”</span><span>的变化。从</span><span>80386</span><span>以后，</span><span>Intel</span><span>的</span><span>CPU</span><span>经历了</span><span>80486</span><span>、</span><span>Pentium</span><span>、</span><span>PentiumII</span><span>、</span><span>PentiumIII</span><span>等型号，虽然它们在速度上提高了好几个数量级，功能上也有不少改进，但基本上属于同一种系统结构的改进与加强，而无本质的变化，所以我们把</span><span>80386</span><span>以后的处理器统称为</span><span>IA32</span><span>（</span><span>32 Bit Intel Architecture</span><span>）。</span></p> 
  <p><span> （</span><span>2</span><span>）我们用到的</span><span>Debug</span><span>功能</span><span><br></span></p> 
  <blockquote> 
   <p><span>R</span><span>命令查看、改变</span><span>CPU</span><span>寄存器的内容；</span></p> 
   <p><span>D</span><span>命令查看内存中的内容；</span></p> 
   <p><span>E</span><span>命令改写内存中的内容；</span></p> 
   <p><span>U</span><span>命令将内存中的机器指令翻译成汇编指令；</span></p> 
   <p><span>T</span><span>命令执行一条机器指令；</span></p> 
   <p><span>A</span><span>命令以汇编指令的格式在内存中写入一条机器指令。</span></p> 
   <p><span>P</span><span>命令</span> <span> 到了</span> <span>int 21H</span><span>，我们要用</span><span>P</span><span>命令执行；进入循环时用</span><span>p</span><span>命令也可以退出循环</span></p> 
   <p><span>G</span><span>命令</span><span>g</span><span>命令调试时能跳到想去的地址，特别是调试循环代码时</span></p> 
  </blockquote> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> Debug</span><span>的命令比较多（详细请看资料），共有</span><span>20</span><span>多个，但这</span><span>6</span><span>个命令是和汇编学习密切相关的。在以后的实验中，我们还会用到一个</span><span>P</span><span>命令。</span></p> 
  <p><span> （</span><span>3</span><span>）进入</span><span>Debug</span><span>。</span></p> 
  <p><span> （</span><span>4</span><span>）用</span><span>R</span><span>命令查看、改变</span><span>CPU</span><span>寄存器的内容。由于开发环境的不同，</span><span>cmd</span><span>调试结果也是不同的，这里只是将它们的意义说明。</span></p> 
  <p><span><font face="Courier New">-r</font></span></p> 
  <p><font face="Courier New"><span>AX=0000&nbsp;<wbr> BX=0000&nbsp;<wbr> CX=0000&nbsp;<wbr> DX=0000</span><span>&nbsp;<wbr> SP=FFEE&nbsp;<wbr> BP=0000&nbsp;<wbr> SI=0000&nbsp;<wbr> DI=0000</span></font></p> 
  <p><font face="Courier New"><span>DS=0B04&nbsp;<wbr> ES=0B04&nbsp;<wbr> SS=0B04&nbsp;<wbr></span> <span>CS=0B04&nbsp;<wbr> IP=0100</span><span>&nbsp;<wbr>&nbsp;<wbr> NV UP EI PL NZ NA PO NC</span></font></p> 
  <p><span><font face="Courier New">0B04:0100 E80400&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> CALL&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 0107</font><br></span>看图说明：</p> 
  <p><span> 【</span><span>1</span><span>】ax，bx，cx，dx，cx，ip是我们讲过的</span><span>6</span><span>中寄存器，其中</span><span>ax</span><span>，</span><span>bx</span><span>，</span><span>cx</span><span>，</span><span>dx</span><span>都是通用寄存器，但是它们也有特定的用途，以后慢慢了解。</span><span>cs</span><span>和</span><span>ip</span><span>寄存器是专门寄存器。</span></p> 
  <p><span> 【</span><span>2</span><span>】</span><span>0B04:0100 E80400&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> CALL&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 0107</span></p> 
  <p><span> 含义：</span><span>CS=0B04&nbsp;<wbr> IP=0100</span> <span> 也就是</span><span>CPU</span><span>将要读取的从</span><span>0B04:0100</span><span>开始内存单元的指令，这个指令机器码是：</span><span>E80400</span><span>；</span><span>debug</span><span>程序将这个机器码翻译成汇编指令是</span><span>CALL&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 0107</span></p> 
  <p><span> 理解：这个</span><span>CPU</span><span>指向的地址</span><span>cs</span><span>：</span><span>ip</span><span>就是</span><span>CPU</span><span>将要读取并执行的指令代码。当然，这个代码对于我们来说是没有任何意义的。</span></p> 
  <p><span> 在</span><span>debug</span><span>状态下，我们可以使用</span><span>R</span><span>命令修改上述寄存器的值。</span></p> 
  <p><span> 例如：</span></p> 
  <p><span>r cs&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 指令含义：修改</span><span>cs</span><span>寄存器值</span></p> 
  <p><span>r ip&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 指令含义：修改</span><span>ip</span><span>寄存器值</span></p> 
  <p><span>r ax&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 指令含义：修改</span><span>ax</span><span>寄存器值</span></p> 
  <p><span> （</span><span>5</span><span>）使用</span><span>D</span><span>命令查看内存中的内容。</span></p> 
  <p><span> 直接显示从某单元地址开始内容；</span></p> 
  <p><span> 指令格式：</span><span>d</span> <span> 段地址：偏移地址</span></p> 
  <p><span> 例如：</span></p> 
  <p><span>-d 0b04:0</span></p> 
  <p><span>0B04:0000&nbsp;<wbr></span> <font color="red"><span> CD 20 FF 9F 00 9A EE FE-1D F0 4F 03 68 05 8A 03 </span> </font> <span>&nbsp;<wbr>&nbsp;<wbr> . ........O.h...</span></p> 
  <p><span>0B04:0010&nbsp;<wbr> 68 05 17 03 68 05 1C 04-01 01 01 00 02 FF FF FF&nbsp;<wbr>&nbsp;<wbr> h...h...........</span></p> 
  <p><span>0B04:0020&nbsp;<wbr> FF FF FF FF FF FF FF FF-FF FF FF FF 15 05 4E 01&nbsp;<wbr>&nbsp;<wbr> ..............N.</span></p> 
  <p><span>0B04:0030&nbsp;<wbr> 28 0A 14 00 18 00 04 0B-FF FF FF FF 00 00 00 00&nbsp;<wbr>&nbsp;<wbr> (...............</span></p> 
  <p><span>0B04:0040&nbsp;<wbr> 05 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00&nbsp;<wbr>&nbsp;<wbr> ................</span></p> 
  <p><span>0B04:0050&nbsp;<wbr> CD 21 CB 00 00 00 00 00-00 00 00 00 00 20 20 20&nbsp;<wbr>&nbsp;<wbr> .!...........</span></p> 
  <p><span>0B04:0060&nbsp;<wbr> 20 20 20 20 20 20 20 20-00 00 00 00 00 20 20 20&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> .....</span></p> 
  <p><span>0B04:0070&nbsp;<wbr> 20 20 20 20 20 20 20 20-00 00 00 00 00 00 00 00&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> ........</span></p> 
  <p><span> 【</span><span>1</span><span>】中间的红色部分是从指定地址开始的内存单元中的内容，每一行为</span><span>16</span><span>个字节，用</span><span>16</span><span>进制格式输出。内存单元是从低地址向高地址显示的。在红色区域左边的是每行的起始地址（段地址：偏移地址）；偏移地址的变化都是</span><span>16</span><span>的整数倍，在</span><span>debug</span><span>中就是</span><span>10H</span><span>。红色区域的右侧是将内存单元存储的值所对应的</span><span>ASCII</span><span>码字符，如果不在</span><span>ASCII</span><span>码的范围，以“</span><span>.</span><span>”形式列出（表示不可识别的</span><span>ASCII</span><span>码）。</span></p> 
  <p><span> 【</span><span>2</span><span>】在</span><span>debug</span><span>中，使用</span><span>D</span><span>命令显示的内存单元，是为了便于我们调试程序时查看内存的状态。此处注意，真正的内存依然是单列、连续的线性存储空间。而不是像</span><span>debug</span><span>中显示的按照表的形式存在。</span></p> 
  <p><span> 【</span><span>3</span><span>】使用</span><span>d</span><span>命令后，我们可以继续使用单个的“</span><span>d</span><span>”命令，继续显示连续的内存单元内容。每次显示</span><span>128</span><span>个单元（</span><span>128</span><span>个字节）内容。</span></p> 
  <p><span> 【</span><span>4</span><span>】使用</span> <span>d</span> <span> 段地址：偏移地址（开始）</span> <span> 偏移地址（结束）来显示一段连续内存单元的内容；例如：</span><span>-d 0b04:0 7</span> <span> 显示的是从</span><span>0~7</span><span>共</span><span>8</span><span>个内存单元的内容。</span></p> 
  <p><span> （</span><span>6</span><span>）用</span><span>Debug</span><span>的</span><span>E</span><span>命令改写内存中的内容：</span></p> 
  <p><span> 【</span><span>1</span><span>】可以使用</span><span>E</span><span>命令来改写内存中的内容，按照字节单元的方式修改</span></p> 
  <p><span> 例如：</span><span>-e 0b04:0&nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 从内存单元</span><span>0b04:0</span><span>开始，改写内存单元的内容。回车键结束；注意使用空格。</span></p> 
  <p><span> 【</span><span>2</span><span>】可以使用</span><span>E</span><span>命令修改内存中内容，直接按照</span><span>ASCII</span><span>码的方式修改</span></p> 
  <p><span> 例如：</span></p> 
  <p><font face="Courier New"><span>-e 0b04:100 'a','b','c','d','e',1,'a+b'</span><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> ;</span>修改内存单元，直接写入<span>ASCII</span>码</font></p> 
  <p><font face="Courier New"><span>-d 0b04:100</span><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> ;</span>查看内存单元</font></p> 
  <p><span><font face="Courier New">0B04:0100&nbsp;<wbr> 61 62 63 64 65 01 61 2B-62 8A F1 80 FC 01 74 09&nbsp;<wbr>&nbsp;<wbr> abcde.a+b.....t.</font></span></p> 
  <p><span> 【</span><span>3</span><span>】使用</span><span>E</span><span>命令修改代码段中指令的代码，这个太累了。不推荐。</span></p> 
  <p><span> （</span><span>7</span><span>）使用</span><span>U</span><span>命令查看指定内存单元开始的汇编代码和机器码。</span></p> 
  <p><span><font face="Courier New">-u 0b04:100</font></span></p> 
  <p><span><font face="Courier New">0B04:0100 E80400&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> CALL&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 0107</font></span></p> 
  <p><span><font face="Courier New">0B04:0103 32C0&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> XOR&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> AL,AL</font></span></p> 
  <p><span><font face="Courier New">0B04:0105 AA&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> STOSB</font></span></p> 
  <p><span><font face="Courier New">0B04:0106 C3&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> RET</font></span></p> 
  <p><span><font face="Courier New">0B04:0107 B400&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> MOV&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> AH,00</font></span></p> 
  <p><font face="Courier New">……</font></p> 
  <p><span> 这里我们看见右侧的是汇编代码，中间的是机器码，左侧的是内存单元地址（物理地址）。</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 小技巧：如果将某个段内存的段地址赋值给段寄存器，则在执行命令时，使用寄存器名称即可。例如：</span><span>-u 0b04:100&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 等价于</span><span>-u cs:100</span><span>（因为</span><span>cs=0b04</span><span>）</span></p> 
  <p><span> （</span><span>8</span><span>）使用</span><span>t</span><span>命令执行</span><span>cs:ip</span><span>指向的内存单元的指令，单步的执行。注意执行后，每个寄存器值的变化。</span></p> 
  <p><span> （</span><span>9</span><span>）使用</span><span>A</span><span>命令，以汇编指令的形式在内存中写入机器指令。</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 上面使用</span><span>E</span><span>命令可以在内存中修改单元内容，达到写入机器指令的目的，太累了，写的都是机器码；这个命令就很好，直接按照汇编指令形式写入指令；</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 注意此指令不接受汇编的伪指令。只接受正确的汇编指令。</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 使用回车键结束汇编指令的写入。</span></p> 
  <p><b><span>2.</span></b> <b><span> 实验任务</span></b></p> 
  <p><b><span> （</span><span>1</span></b><b><span>）使用</span><span>debug</span></b><b><span>，将下面的程序段写入内存，逐条执行，观察每条指令执行后</span><span>CPU</span></b><b><span>中相关寄存器中内容的变化。</span></b></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 机器码</span><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 汇编指令</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> b8 20 4e&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov ax</span><span>，</span><span>4E20H</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 05 16 14 &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> add ax</span><span>，</span><span>1416H</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> bb 00 20 &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov bx,2000H</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 01 d8&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> add ax,bx</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 89 c3&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov bx,ax</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 01 d8&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> add ax,bx</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> b8 1a 00&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov ax, 001aH</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> bb 26 00&nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov bx,0026H</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 00 d8&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> add al,bl</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 00 dc&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> add ah,bl</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 00 c7&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> add bh,al</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> b4 00 &nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov ah,0</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 00 d8&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> add al,bl</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 04 9c&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> add al,9cH</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 提示，可用</span><span>E</span><span>命令和</span><span>A</span><span>命令以两种方式将指令写入内存。注意用</span><span>T</span><span>命令执行时，</span><span>cs:ip</span><span>的指向。</span></p> 
  <p><span> 打开</span><span>cmd</span><span>窗口（命令提示符窗口），键入</span><span>debug</span><span>；回车</span></p> 
  <p><font face="Courier New"><span>-r</span><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> ;</span>查看寄存器的状态</font></p> 
  <p><span><font face="Courier New">AX=0000&nbsp;<wbr> BX=0000&nbsp;<wbr> CX=0000&nbsp;<wbr> DX=0000&nbsp;<wbr> SP=FFEE&nbsp;<wbr> BP=0000&nbsp;<wbr> SI=0000&nbsp;<wbr> DI=0000</font></span></p> 
  <p><span><font face="Courier New">DS=0B04&nbsp;<wbr> ES=0B04&nbsp;<wbr> SS=0B04&nbsp;<wbr> CS=0B04&nbsp;<wbr> IP=0100&nbsp;<wbr>&nbsp;<wbr> NV UP EI PL NZ NA PO NC</font></span></p> 
  <p><span><font face="Courier New">0B04:0100 E80400&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> CALL&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 0107&nbsp;<wbr></font></span></p> 
  <p><span> 我们发现</span><span>CS=0B04</span> <span> ；</span> <span>IP=0100</span><span>，也就是说</span><span>CPU</span><span>从这里读取代码并执行。我们也在这开始吧。（注：这个是我的系统</span><span>debug</span><span>，你的机器系统不一样，导致</span><span>debug</span><span>后寄存器状态不同。）</span></p> 
  <p><span> 【</span><span>1</span><span>】首先使用</span><span>E</span><span>命令</span></p> 
  <p><span>-e cs:100&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> ;</span><span>使用</span><span>e</span><span>命令在</span><span>cs</span><span>：</span><span>100</span><span>开始修改内存单元内容</span></p> 
  <p><span>0B04:0100&nbsp;<wbr> E8.<span>b8</span>&nbsp;<wbr>&nbsp;<wbr> 04.<span>20</span>&nbsp;<wbr>&nbsp;<wbr> 00.<span>4e</span>&nbsp;<wbr>&nbsp;<wbr> 32.<span>05</span>&nbsp;<wbr>&nbsp;<wbr> C0.<span>16</span>&nbsp;<wbr>&nbsp;<wbr> AA.<span>14</span>&nbsp;<wbr>&nbsp;<wbr> C3.<span>bb</span>&nbsp;<wbr>&nbsp;<wbr> B4.<span>00</span></span></p> 
  <p><span>0B04:0108&nbsp;<wbr> 00.<span>20</span>&nbsp;<wbr>&nbsp;<wbr> 8A.<span>0</span>1&nbsp;<wbr>&nbsp;<wbr> F1.<span>d8</span>&nbsp;<wbr></span> <span>……</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 使用</span><span>e</span><span>命令在</span><span>cs</span><span>：</span><span>100</span><span>开始修改内存单元内容，将上边的机器码逐个写入内存中。注意红色的是</span><span>CPU</span><span>要执行的机器码。回车后修改完毕。</span></p> 
  <p><span><font face="Courier New">-u cs:100</font></span></p> 
  <p><span><font face="Courier New">0B04:0100 B8204E&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> MOV&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> AX,4E20</font></span></p> 
  <p><span><font face="Courier New">0B04:0103 051614&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> ADD&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> AX,1416</font></span></p> 
  <p><span><font face="Courier New">0B04:0106 BB0020&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> MOV&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> BX,2000</font></span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 使用</span><span>u</span><span>命令查看下，看看汇编指令是否正常？</span></p> 
  <p><span> ……太累了，此处省略一万字。将所有的机器码都使用上述方式用</span><span>E</span><span>命令写入到</span><span>cs</span><span>：</span><span>100</span><span>开始的内存单元中。</span></p> 
  <p><span> 【</span><span>2</span><span>】使用</span><span>a</span><span>命令，直接写入汇编指令。</span></p> 
  <p><span>-a cs:100</span></p> 
  <p><span>0B04:0100 mov ax, 4e20</span></p> 
  <font color="red"> 0B04:0103 add ax,1416H </font>
  <p> ^ Error </p> 
  <p><span>0B04:0103 add ax,1416</span></p> 
  <p><span>0B04:0106 mov bx,2000</span></p> 
  <p><span>0B04:0109 add ax,bx</span></p> 
  <p><span>0B04:010B mov bx,ax</span></p> 
  <p><span>0B04:010D add ax,bx</span></p> 
  <p><span>0B04:010F mov ax,001a</span></p> 
  <p><span>0B04:0112 mov bx,0026</span></p> 
  <p><span>0B04:0115 add al,bl</span></p> 
  <p><span>0B04:0117 add ah,bl</span></p> 
  <p><span>0B04:0119 add bh,al</span></p> 
  <p><span>0B04:011B mov ah,0</span></p> 
  <p><span>0B04:011D add al,bl</span></p> 
  <p><span>0B04:011F add al,9c</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 在</span><span>cs:100</span><span>开始的内存单元处，使用汇编指令写入执行代码。</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 注意红色的为什么报错？在</span><span>debug</span><span>中，一律按照</span><span>16</span><span>机制计算（不带</span><span>H</span><span>），如果是十进制数值，你需要转换为</span><span>16</span><span>进制。</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 写汇编源程序时，你可以随便使用任何进制，因为有编译器自动给你转换了。</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 我们发现，使用</span><span>a</span><span>命令比较方便，但这二种方式的结果是一样的，都是在</span><span>cs</span><span>：</span><span>100</span><span>开始的内存单元中写入了这些指令。</span></p> 
  <p><span> 我们使用</span><span>d</span><span>命令查看下这段内存的内容：</span></p> 
  <p><span>-d cs:100</span></p> 
  <p><span>0B04:0100&nbsp;<wbr> B8 20 4E 05 16 14 BB 00-20 01 D8 89 C3 01 D8 B8&nbsp;<wbr>&nbsp;<wbr> . N..... .......</span></p> 
  <p><span>0B04:0110&nbsp;<wbr> 1A 00 BB 26 00 00 D8 00-DC 00 C7 B4 00 00 D8 04&nbsp;<wbr>&nbsp;<wbr> ...&amp;............</span></p> 
  <p><span>0B04:0120&nbsp;<wbr> 9C FC 00 74 20 80 FC 01-75 22 3A CE 75 05 80 3C&nbsp;<wbr>&nbsp;<wbr> ...t ...u":.u..&lt;&lt;/span&gt;</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 我们发现，内存单元中也都是存储着</span><span>16</span><span>进制的数据，跟其他内存空间存储的结构是一样的，但这里存储的是</span><span>CPU</span><span>执行的代码。</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 从而验证了，内存单元存储的数据不区分数值还是指令，在于你在应用层面上的解析。</span></p> 
  <p><span> 【</span><span>3</span><span>】怎么执行？使用</span><span>T</span><span>命令，确保</span><span>cs</span><span>存储的就是我们期望的代码段的段地址，</span><span>ip</span><span>存储的也是我们期望的开始偏移地址，如果不是，我们可以使用</span><span>r</span><span>命令修改</span><span>cs</span><span>或</span><span>ip</span><span>的值。</span></p> 
  <p><span>-r</span><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> ;</span><span>显示寄存器状态值，</span></p> 
  <p><span>AX=0000&nbsp;<wbr> BX=0000&nbsp;<wbr> CX=0000&nbsp;<wbr> DX=0000&nbsp;<wbr> SP=FFEE&nbsp;<wbr> BP=0000&nbsp;<wbr> SI=0000&nbsp;<wbr> DI=0000</span></p> 
  <p><span>DS=0B04&nbsp;<wbr> ES=0B04&nbsp;<wbr> SS=0B04&nbsp;<wbr> CS=0B04&nbsp;<wbr> IP=0100&nbsp;<wbr>&nbsp;<wbr> NV UP EI PL NZ NA PO NC</span></p> 
  <p><span>0B04:0100 B8204E&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> MOV&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> AX,4E20</span><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> ;</span><span>这条指令就是</span><span>CPU</span><span>将要读取的指令</span></p> 
  <p><span>-t</span><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> ;</span><span>执行</span><span>MOV&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> AX,4E20</span><span>指令</span></p> 
  <p><span>AX=4E20</span><span>&nbsp;<wbr> BX=0000&nbsp;<wbr> CX=0000&nbsp;<wbr> DX=0000&nbsp;<wbr> SP=FFEE&nbsp;<wbr> BP=0000&nbsp;<wbr> SI=0000&nbsp;<wbr> DI=0000</span></p> 
  <p><span>DS=0B04&nbsp;<wbr> ES=0B04&nbsp;<wbr> SS=0B04&nbsp;<wbr> CS=0B04&nbsp;<wbr> IP=0103&nbsp;<wbr>&nbsp;<wbr> NV UP EI PL NZ NA PO NC</span></p> 
  <p><span>0B04:0103 051614&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> ADD&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> AX,1416</span></p> 
  <p><span> 执行完毕后，我们发现</span><span>ax</span><span>寄存器的值变化了。</span></p> 
  <p><span> 按要求，逐步执行</span><span>t</span><span>命令，体会汇编指令导致寄存器变量值的变化。</span></p> 
  <p><b><span> （</span><span>2</span></b><b><span>）将下面</span><span>3</span></b><b><span>条指令写入从</span><span>2000:0</span></b><b><span>开始的内存单元中，利用这</span><span>3</span></b><b><span>条指令计算</span><span>2</span></b><b><span>的</span><span>8</span></b><b><span>次方。</span></b></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> mov ax</span><span>，</span><span>1</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> add ax</span><span>，</span><span>ax</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> jmp 2000:0003</span></p> 
  <p><span> 【</span><span>1</span><span>】使用</span><span>a</span><span>命令在</span><span>2000</span><span>：</span><span>0</span><span>处写入这</span><span>3</span><span>条代码</span></p> 
  <p><span>-a 2000:0</span></p> 
  <p><span>2000:0000 mov ax, 1</span></p> 
  <p><span>2000:0003 add ax,ax</span></p> 
  <p><span>2000:0005 jmp 2000:0003</span></p> 
  <p><span> 使用</span><span>u</span><span>命令我们查看下是否写入成功；</span></p> 
  <p><span>-u 2000:0</span></p> 
  <p><span>2000:0000 B80100&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> MOV&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> AX,0001</span></p> 
  <p><span>2000:0003 01C0&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> ADD&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> AX,AX</span></p> 
  <p><span>2000:0005 EBFC&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> JMP&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> 0003</span></p> 
  <p><span> 【</span><span>2</span><span>】使用</span><span>r</span><span>命令查看寄存器状态</span></p> 
  <p><span>-r</span></p> 
  <p><span>AX=0000&nbsp;<wbr> BX=0000&nbsp;<wbr> CX=0000&nbsp;<wbr> DX=0000&nbsp;<wbr> SP=FFEE&nbsp;<wbr> BP=0000&nbsp;<wbr> SI=0000&nbsp;<wbr> DI=0000</span></p> 
  <p><span>DS=0B04&nbsp;<wbr> ES=0B04&nbsp;<wbr> SS=0B04&nbsp;<wbr> CS=0B04&nbsp;<wbr> IP=0100&nbsp;<wbr>&nbsp;<wbr> NV UP EI PL NZ NA PO NC</span></p> 
  <p><span> 发现</span><span>CS=0B04&nbsp;<wbr> IP=0100</span><span>不是我们期望的，我们把代码写入了</span><span>2000:0000H</span><span>了。希望</span><span>CPU</span><span>从</span><span>2000:0000H</span><span>开始执行。故将</span><span>cs</span><span>和</span><span>ip</span><span>修改为</span><span>2000</span><span>和</span><span>0000</span><span>；</span></p> 
  <p><span> 使用</span><span>r</span><span>命令直接修改。</span></p> 
  <p><span>-r cs</span></p> 
  <p><span>CS 0B04</span></p> 
  <p><span>:2000</span></p> 
  <p><span>-r ip</span></p> 
  <p><span>IP 0100</span></p> 
  <p><span>:0</span></p> 
  <p><span> 【</span><span>3</span><span>】使用</span><span>t</span><span>命令执行代码，注意观察</span><span>ax</span><span>值的变化。由于</span><span>jmp 2000:0003</span><span>指令导致这段程序流程为死循环，执行</span><span>8</span><span>次循环后，使用</span><span>q</span><span>命令直接退出吧。</span></p> 
  <p><b><span> （</span><span>3</span></b><b><span>）查看内存中的内容。</span></b></p> 
  <p><span>PC</span><span>机主板上的</span><span>ROM</span><span>中写有一个生产日期，在内存</span><span>FFF00H~FFFFFH</span><span>的某几个单元中，请找到这个生产日期，并试图改变它。</span></p> 
  <p><span> 【</span><span>1</span><span>】使用</span><span>d</span><span>命令查看内存单元的内容，由于物理地址是：</span><span>FFF00H</span><span>，我们可以假定偏移地址是</span><span>0</span><span>，那么段地址是</span><span>FFF0H</span><span>，也就是我们使用</span><span>D</span><span>命令查询的是从</span><span>FFF0</span><span>：</span><span>0~FFF0</span><span>：</span><span>00FFH</span><span>的范围。</span></p> 
  <p><span> 打开</span><span>cmd</span><span>，键入</span><span>debug</span></p> 
  <p><span>-d fff0:0 ff</span></p> 
  <p>……</p> 
  <p><span>FFF0:00F0&nbsp;<wbr> EA 5B E0 00 F0</span> <span>31 30 2F-30 35 2F 30 37</span> <span>00 FC AD&nbsp;<wbr>&nbsp;<wbr> .[...</span><span>10/05/07</span><span>...</span></p> 
  <p><span> 我们发现在</span><span>00f5</span><span>开始的内存单元存储着主板的生产日期。看红色标记。</span></p> 
  <p><span> &nbsp;<wbr> &nbsp;<wbr> 尝试使用</span><span>e</span><span>命令修改此段内容，发现成功了！（兴奋！），重新打开</span><span>cmd</span><span>，查看内存发现显示依然是原来的结果，为毛？因为只读，不让你改。这里只是模拟模式一个假象。在实模式下，你试试就知道了。</span></p> 
  <p><span> （</span><span>4</span><span>）向内存从</span><span>B800H</span><span>开始的单元中填写数据，如：</span></p> 
  <p><span>-e b810</span><span>：</span><span>0000&nbsp;<wbr> 01 01 02 02 02 03 03 04 04</span></p> 
  <p><span> 观察产生的现象；再改变填写的地址，观察产生的现象。</span></p> 
  <p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=171daf8e00102xdln&amp;url=http://album.sina.com.cn/pic/006LW9dSzy7aXS2MEVc1a" rel="nofollow" target="_blank"><img src="http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif" title="" alt="汇编语言（王爽第三版）实验1查看CPU和内存，用机器指令和汇编指令编程"></a><br> <br></p> 
  <p><span> </span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 我们发现，写入的数据在屏幕的第</span><span>1</span><span>行第</span><span>9</span><span>列开始显示</span><span>ASCII</span><span>字符。其中</span><span>2</span><span>个字节代表显示一个字符，前一个字节代表字符本身，后一个字符代表字符的属性。</span></p> 
  <p><span>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr></span> <span> 结论：在</span><span>DOS</span><span>或命令提示符窗口下，</span><span>B800</span><span>：</span><span>0000</span><span>开始是显示缓冲区。以后我们多次接触这个。</span></p> 
  <p><span>&nbsp;<wbr></span></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
