<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>OpenCV精进之路（十六）：图像矫正技术深入探讨 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="OpenCV精进之路（十六）：图像矫正技术深入探讨" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：最终版权归YBAidam所有 https://blog.csdn.net/Aidam_Bo/article/details/89098193 刚进入实验室导师就交给我一个任务，就是让我设计算法给图像进行矫正。哎呀，我不太会图像这块啊，不过还是接下来了，硬着头皮开干吧！ 那什么是图像的矫正呢？举个例子就好明白了。 我的好朋友小明给我拍了这几张照片，因为他的拍照技术不咋地，照片都拍得歪歪扭扭的，比如下面这些照片： 人民币 发票 文本 这些图片让人看得真不舒服！看个图片还要歪脖子看，实在是太烦人了！我叫小明帮我扫描一下一本教科书，小明把每一页书都拍成上面的文本那样了。好气啊那该怎么办呢？一页一页用PS来处理？1000页的矫正啊，当然交给计算机去做！ 真的，对于图像矫正的问题，在图像处理领域还真得多，比如人民币的矫正、文本的矫正、车牌的矫正、身份证矫正等等。这些都是因为拍摄者总不可能100%正确地拍摄好图片，这就要求我们通过后期的图像处理技术将图片还原好，才能进一步做后面的处理，比如数字分割啊数字识别啊，不然歪歪扭扭的文字数字，想识别出来估计就很难了。 上面几个图，我们在日常生活中遇到的可不少，因为拍摄时拍的不好，导致拍出来的图片歪歪扭扭的，很不自然，那么我们能不能把这些图片尽可能地矫正过来呢？ OpenCV告诉我们，没问题！工具我给你，算法你自己设计！ 比如图一，我要想将人民币矫正，并且把人民币整个抠出来保存，该怎么做？那就涉及到了图像的矫正和感兴趣区域提取两大技术了。 总的来说，要进行进行图像矫正，至少有以下几项知识储备： 轮廓提取技术 霍夫变换知识 ROI感兴趣区域知识 下面以人民币矫正、发票矫正、文本矫正为例，一步步剖析如何实现图像矫正。 首先分析如何矫正人民币。 比如我们要矫正这张人民币，思路应该是怎么样？ 首先分析这张图的特点。 在这张图里，人民币有一定的倾斜角度，但是角度不大；人民币的背景是黑色的，而且人民币的边缘应该比较明显。 没错，我们就抓住人民币的的边缘比较明显来做文章！我们是不是可以先把人民币的轮廓找出来（找出来的轮廓当然就是一个大大的矩形），然后用矩形去包围它，得到他的旋转角度，然后根据得到的角度进行旋转，那样不就可以实现矫正了吗！ 再详细地总结处理步骤： 图片灰度化 阈值二值化 检测轮廓 寻找轮廓的包围矩阵，并且获取角度 根据角度进行旋转矫正 对旋转后的图像进行轮廓提取 对轮廓内的图像区域抠出来，成为一张独立图像 我把该矫正算法命名为基于轮廓提取的矫正算法，因为其关键技术就是通过轮廓来获取旋转角度。 #include &quot;opencv2/imgproc.hpp&quot; #include &quot;opencv2/highgui.hpp&quot; #include &lt;iostream&gt; using namespace cv; using namespace std; //第一个参数：输入图片名称；第二个参数：输出图片名称 void GetContoursPic(const char* pSrcFileName, const char* pDstFileName) { Mat srcImg = imread(pSrcFileName); imshow(&quot;原始图&quot;, srcImg); Mat gray, binImg; //灰度化 cvtColor(srcImg, gray, COLOR_RGB2GRAY); imshow(&quot;灰度图&quot;, gray); //二值化 threshold(gray, binImg, 100, 200, CV_THRESH_BINARY); imshow(&quot;二值化&quot;, binImg); vector&lt;vector&lt;Point&gt; &gt; contours; vector&lt;Rect&gt; boundRect(contours.size()); //注意第5个参数为CV_RETR_EXTERNAL，只检索外框 findContours(binImg, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE); //找轮廓 cout &lt;&lt; contours.size() &lt;&lt; endl; for (int i = 0; i &lt; contours.size(); i++) { //需要获取的坐标 CvPoint2D32f rectpoint[4]; CvBox2D rect =minAreaRect(Mat(contours[i])); cvBoxPoints(rect, rectpoint); //获取4个顶点坐标 //与水平线的角度 float angle = rect.angle; cout &lt;&lt; angle &lt;&lt; endl; int line1 = sqrt((rectpoint[1].y - rectpoint[0].y)*(rectpoint[1].y - rectpoint[0].y) + (rectpoint[1].x - rectpoint[0].x)*(rectpoint[1].x - rectpoint[0].x)); int line2 = sqrt((rectpoint[3].y - rectpoint[0].y)*(rectpoint[3].y - rectpoint[0].y) + (rectpoint[3].x - rectpoint[0].x)*(rectpoint[3].x - rectpoint[0].x)); //rectangle(binImg, rectpoint[0], rectpoint[3], Scalar(255), 2); //面积太小的直接pass if (line1 * line2 &lt; 600) { continue; } //为了让正方形横着放，所以旋转角度是不一样的。竖放的，给他加90度，翻过来 if (line1 &gt; line2) { angle = 90 + angle; } //新建一个感兴趣的区域图，大小跟原图一样大 Mat RoiSrcImg(srcImg.rows, srcImg.cols, CV_8UC3); //注意这里必须选CV_8UC3 RoiSrcImg.setTo(0); //颜色都设置为黑色 //imshow(&quot;新建的ROI&quot;, RoiSrcImg); //对得到的轮廓填充一下 drawContours(binImg, contours, -1, Scalar(255),CV_FILLED); //抠图到RoiSrcImg srcImg.copyTo(RoiSrcImg, binImg); //再显示一下看看，除了感兴趣的区域，其他部分都是黑色的了 namedWindow(&quot;RoiSrcImg&quot;, 1); imshow(&quot;RoiSrcImg&quot;, RoiSrcImg); //创建一个旋转后的图像 Mat RatationedImg(RoiSrcImg.rows, RoiSrcImg.cols, CV_8UC1); RatationedImg.setTo(0); //对RoiSrcImg进行旋转 Point2f center = rect.center; //中心点 Mat M2 = getRotationMatrix2D(center, angle, 1);//计算旋转加缩放的变换矩阵 warpAffine(RoiSrcImg, RatationedImg, M2, RoiSrcImg.size(),1, 0, Scalar(0));//仿射变换 imshow(&quot;旋转之后&quot;, RatationedImg); imwrite(&quot;r.jpg&quot;, RatationedImg); //将矫正后的图片保存下来 } #if 1 //对ROI区域进行抠图 //对旋转后的图片进行轮廓提取 vector&lt;vector&lt;Point&gt; &gt; contours2; Mat raw = imread(&quot;r.jpg&quot;); Mat SecondFindImg; //SecondFindImg.setTo(0); cvtColor(raw, SecondFindImg, COLOR_BGR2GRAY); //灰度化 threshold(SecondFindImg, SecondFindImg, 80, 200, CV_THRESH_BINARY); findContours(SecondFindImg, contours2, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE); //cout &lt;&lt; &quot;sec contour:&quot; &lt;&lt; contours2.size() &lt;&lt; endl; for (int j = 0; j &lt; contours2.size(); j++) { //这时候其实就是一个长方形了，所以获取rect Rect rect = boundingRect(Mat(contours2[j])); //面积太小的轮廓直接pass,通过设置过滤面积大小，可以保证只拿到外框 if (rect.area() &lt; 600) { continue; } Mat dstImg = raw(rect); imshow(&quot;dst&quot;, dstImg); imwrite(pDstFileName, dstImg); } #endif } void main() { GetContoursPic(&quot;6.jpg&quot;, &quot;FinalImage.jpg&quot;); waitKey(); } 效果依次如下： 原始图 二值化图 掩膜mask是这样的 旋转矫正之后 将人民币区域抠出来 该算法的效果还是很不错的！那赶紧试试其他图片，我把倾斜的发票图像拿去试试。 原始图 倾斜矫正之后 最后把目标区域抠出来，成为单独的照片。 上面的算法可以很好的处理人民币和发票两种情况的倾斜矫正，那文本矫正可以吗？我赶紧试了一下，结果是失败的。 原图 算法矫正后，还是原样，矫正失败。 认真分析一下，还是很容易看出文本矫正失败的原因的。 原因就在于，人民币图像和发票图像他们有明显的的边界轮廓，而文本图像没有。文本图像的背景是白色的，所以我们没有办法像人民币发票那类有明显边界的矩形物体那样，提取出轮廓并旋转矫正。 经过深入分析可以看出，虽然文本类图像没有明显的边缘轮廓，但是他们有一个很重要的特征，那就是每一行文字都是呈现一条直线形状，而且这些直线都是平行的！ 对于这种情况，我想到了另一种方法：基于直线探测的矫正算法。 首先介绍一下我的算法思路： 用霍夫线变换探测出图像中的所有直线 计算出每条直线的倾斜角，求他们的平均值 根据倾斜角旋转矫正 最后根据文本尺寸裁剪图片 然后给出OpenCV的实现算法： #include &quot;opencv2/imgproc.hpp&quot; #include &quot;opencv2/highgui.hpp&quot; #include &lt;iostream&gt; using namespace cv; using namespace std; #define ERROR 1234 //度数转换 double DegreeTrans(double theta) { double res = theta / CV_PI * 180; return res; } //逆时针旋转图像degree角度（原尺寸） void rotateImage(Mat src, Mat&amp; img_rotate, double degree) { //旋转中心为图像中心 Point2f center; center.x = float(src.cols / 2.0); center.y = float(src.rows / 2.0); int length = 0; length = sqrt(src.cols*src.cols + src.rows*src.rows); //计算二维旋转的仿射变换矩阵 Mat M = getRotationMatrix2D(center, degree, 1); warpAffine(src, img_rotate, M, Size(length, length), 1, 0, Scalar(255,255,255));//仿射变换，背景色填充为白色 } //通过霍夫变换计算角度 double CalcDegree(const Mat &amp;srcImage, Mat &amp;dst) { Mat midImage, dstImage; Canny(srcImage, midImage, 50, 200, 3); cvtColor(midImage, dstImage, CV_GRAY2BGR); //通过霍夫变换检测直线 vector&lt;Vec2f&gt; lines; HoughLines(midImage, lines, 1, CV_PI / 180, 300, 0, 0);//第5个参数就是阈值，阈值越大，检测精度越高 //cout &lt;&lt; lines.size() &lt;&lt; endl; //由于图像不同，阈值不好设定，因为阈值设定过高导致无法检测直线，阈值过低直线太多，速度很慢 //所以根据阈值由大到小设置了三个阈值，如果经过大量试验后，可以固定一个适合的阈值。 if (!lines.size()) { HoughLines(midImage, lines, 1, CV_PI / 180, 200, 0, 0); } //cout &lt;&lt; lines.size() &lt;&lt; endl; if (!lines.size()) { HoughLines(midImage, lines, 1, CV_PI / 180, 150, 0, 0); } //cout &lt;&lt; lines.size() &lt;&lt; endl; if (!lines.size()) { cout &lt;&lt; &quot;没有检测到直线！&quot; &lt;&lt; endl; return ERROR; } float sum = 0; //依次画出每条线段 for (size_t i = 0; i &lt; lines.size(); i++) { float rho = lines[i][0]; float theta = lines[i][1]; Point pt1, pt2; //cout &lt;&lt; theta &lt;&lt; endl; double a = cos(theta), b = sin(theta); double x0 = a*rho, y0 = b*rho; pt1.x = cvRound(x0 + 1000 * (-b)); pt1.y = cvRound(y0 + 1000 * (a)); pt2.x = cvRound(x0 - 1000 * (-b)); pt2.y = cvRound(y0 - 1000 * (a)); //只选角度最小的作为旋转角度 sum += theta; line(dstImage, pt1, pt2, Scalar(55, 100, 195), 1, LINE_AA); //Scalar函数用于调节线段颜色 imshow(&quot;直线探测效果图&quot;, dstImage); } float average = sum / lines.size(); //对所有角度求平均，这样做旋转效果会更好 cout &lt;&lt; &quot;average theta:&quot; &lt;&lt; average &lt;&lt; endl; double angle = DegreeTrans(average) - 90; rotateImage(dstImage, dst, angle); //imshow(&quot;直线探测效果图2&quot;, dstImage); return angle; } void ImageRecify(const char* pInFileName, const char* pOutFileName) { double degree; Mat src = imread(pInFileName); imshow(&quot;原始图&quot;, src); Mat dst; //倾斜角度矫正 degree = CalcDegree(src,dst); if (degree == ERROR) { cout &lt;&lt; &quot;矫正失败！&quot; &lt;&lt; endl; return; } rotateImage(src, dst, degree); cout &lt;&lt; &quot;angle:&quot; &lt;&lt; degree &lt;&lt; endl; imshow(&quot;旋转调整后&quot;, dst); Mat resulyImage = dst(Rect(0, 0, dst.cols, 500)); //根据先验知识，估计好文本的长宽，再裁剪下来 imshow(&quot;裁剪之后&quot;, resulyImage); imwrite(&quot;recified.jpg&quot;, resulyImage); } int main() { ImageRecify(&quot;correct2.jpg&quot;, &quot;FinalImage.jpg&quot;); waitKey(); return 0; } 看看效果。这是原始图 直线探测的效果。 矫正之后的效果。 我们发现矫正之后的图像有较多留白，影响观看，所以需要进一步裁剪，保留文字区域。 赶紧再试多一张。 原始图 直线探测 矫正效果 进一步裁剪 可以看出，基于直线探测的矫正算法在文本处理上效果真的很不错！ 最后总结一下两个算法的应用场景： 基于轮廓提取的矫正算法更适用于车牌、身份证、人民币、书本、发票一类矩形形状而且边界明显的物体矫正。 基于直线探测的矫正算法更适用于文本类的矫正。" />
<meta property="og:description" content="版权声明：最终版权归YBAidam所有 https://blog.csdn.net/Aidam_Bo/article/details/89098193 刚进入实验室导师就交给我一个任务，就是让我设计算法给图像进行矫正。哎呀，我不太会图像这块啊，不过还是接下来了，硬着头皮开干吧！ 那什么是图像的矫正呢？举个例子就好明白了。 我的好朋友小明给我拍了这几张照片，因为他的拍照技术不咋地，照片都拍得歪歪扭扭的，比如下面这些照片： 人民币 发票 文本 这些图片让人看得真不舒服！看个图片还要歪脖子看，实在是太烦人了！我叫小明帮我扫描一下一本教科书，小明把每一页书都拍成上面的文本那样了。好气啊那该怎么办呢？一页一页用PS来处理？1000页的矫正啊，当然交给计算机去做！ 真的，对于图像矫正的问题，在图像处理领域还真得多，比如人民币的矫正、文本的矫正、车牌的矫正、身份证矫正等等。这些都是因为拍摄者总不可能100%正确地拍摄好图片，这就要求我们通过后期的图像处理技术将图片还原好，才能进一步做后面的处理，比如数字分割啊数字识别啊，不然歪歪扭扭的文字数字，想识别出来估计就很难了。 上面几个图，我们在日常生活中遇到的可不少，因为拍摄时拍的不好，导致拍出来的图片歪歪扭扭的，很不自然，那么我们能不能把这些图片尽可能地矫正过来呢？ OpenCV告诉我们，没问题！工具我给你，算法你自己设计！ 比如图一，我要想将人民币矫正，并且把人民币整个抠出来保存，该怎么做？那就涉及到了图像的矫正和感兴趣区域提取两大技术了。 总的来说，要进行进行图像矫正，至少有以下几项知识储备： 轮廓提取技术 霍夫变换知识 ROI感兴趣区域知识 下面以人民币矫正、发票矫正、文本矫正为例，一步步剖析如何实现图像矫正。 首先分析如何矫正人民币。 比如我们要矫正这张人民币，思路应该是怎么样？ 首先分析这张图的特点。 在这张图里，人民币有一定的倾斜角度，但是角度不大；人民币的背景是黑色的，而且人民币的边缘应该比较明显。 没错，我们就抓住人民币的的边缘比较明显来做文章！我们是不是可以先把人民币的轮廓找出来（找出来的轮廓当然就是一个大大的矩形），然后用矩形去包围它，得到他的旋转角度，然后根据得到的角度进行旋转，那样不就可以实现矫正了吗！ 再详细地总结处理步骤： 图片灰度化 阈值二值化 检测轮廓 寻找轮廓的包围矩阵，并且获取角度 根据角度进行旋转矫正 对旋转后的图像进行轮廓提取 对轮廓内的图像区域抠出来，成为一张独立图像 我把该矫正算法命名为基于轮廓提取的矫正算法，因为其关键技术就是通过轮廓来获取旋转角度。 #include &quot;opencv2/imgproc.hpp&quot; #include &quot;opencv2/highgui.hpp&quot; #include &lt;iostream&gt; using namespace cv; using namespace std; //第一个参数：输入图片名称；第二个参数：输出图片名称 void GetContoursPic(const char* pSrcFileName, const char* pDstFileName) { Mat srcImg = imread(pSrcFileName); imshow(&quot;原始图&quot;, srcImg); Mat gray, binImg; //灰度化 cvtColor(srcImg, gray, COLOR_RGB2GRAY); imshow(&quot;灰度图&quot;, gray); //二值化 threshold(gray, binImg, 100, 200, CV_THRESH_BINARY); imshow(&quot;二值化&quot;, binImg); vector&lt;vector&lt;Point&gt; &gt; contours; vector&lt;Rect&gt; boundRect(contours.size()); //注意第5个参数为CV_RETR_EXTERNAL，只检索外框 findContours(binImg, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE); //找轮廓 cout &lt;&lt; contours.size() &lt;&lt; endl; for (int i = 0; i &lt; contours.size(); i++) { //需要获取的坐标 CvPoint2D32f rectpoint[4]; CvBox2D rect =minAreaRect(Mat(contours[i])); cvBoxPoints(rect, rectpoint); //获取4个顶点坐标 //与水平线的角度 float angle = rect.angle; cout &lt;&lt; angle &lt;&lt; endl; int line1 = sqrt((rectpoint[1].y - rectpoint[0].y)*(rectpoint[1].y - rectpoint[0].y) + (rectpoint[1].x - rectpoint[0].x)*(rectpoint[1].x - rectpoint[0].x)); int line2 = sqrt((rectpoint[3].y - rectpoint[0].y)*(rectpoint[3].y - rectpoint[0].y) + (rectpoint[3].x - rectpoint[0].x)*(rectpoint[3].x - rectpoint[0].x)); //rectangle(binImg, rectpoint[0], rectpoint[3], Scalar(255), 2); //面积太小的直接pass if (line1 * line2 &lt; 600) { continue; } //为了让正方形横着放，所以旋转角度是不一样的。竖放的，给他加90度，翻过来 if (line1 &gt; line2) { angle = 90 + angle; } //新建一个感兴趣的区域图，大小跟原图一样大 Mat RoiSrcImg(srcImg.rows, srcImg.cols, CV_8UC3); //注意这里必须选CV_8UC3 RoiSrcImg.setTo(0); //颜色都设置为黑色 //imshow(&quot;新建的ROI&quot;, RoiSrcImg); //对得到的轮廓填充一下 drawContours(binImg, contours, -1, Scalar(255),CV_FILLED); //抠图到RoiSrcImg srcImg.copyTo(RoiSrcImg, binImg); //再显示一下看看，除了感兴趣的区域，其他部分都是黑色的了 namedWindow(&quot;RoiSrcImg&quot;, 1); imshow(&quot;RoiSrcImg&quot;, RoiSrcImg); //创建一个旋转后的图像 Mat RatationedImg(RoiSrcImg.rows, RoiSrcImg.cols, CV_8UC1); RatationedImg.setTo(0); //对RoiSrcImg进行旋转 Point2f center = rect.center; //中心点 Mat M2 = getRotationMatrix2D(center, angle, 1);//计算旋转加缩放的变换矩阵 warpAffine(RoiSrcImg, RatationedImg, M2, RoiSrcImg.size(),1, 0, Scalar(0));//仿射变换 imshow(&quot;旋转之后&quot;, RatationedImg); imwrite(&quot;r.jpg&quot;, RatationedImg); //将矫正后的图片保存下来 } #if 1 //对ROI区域进行抠图 //对旋转后的图片进行轮廓提取 vector&lt;vector&lt;Point&gt; &gt; contours2; Mat raw = imread(&quot;r.jpg&quot;); Mat SecondFindImg; //SecondFindImg.setTo(0); cvtColor(raw, SecondFindImg, COLOR_BGR2GRAY); //灰度化 threshold(SecondFindImg, SecondFindImg, 80, 200, CV_THRESH_BINARY); findContours(SecondFindImg, contours2, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE); //cout &lt;&lt; &quot;sec contour:&quot; &lt;&lt; contours2.size() &lt;&lt; endl; for (int j = 0; j &lt; contours2.size(); j++) { //这时候其实就是一个长方形了，所以获取rect Rect rect = boundingRect(Mat(contours2[j])); //面积太小的轮廓直接pass,通过设置过滤面积大小，可以保证只拿到外框 if (rect.area() &lt; 600) { continue; } Mat dstImg = raw(rect); imshow(&quot;dst&quot;, dstImg); imwrite(pDstFileName, dstImg); } #endif } void main() { GetContoursPic(&quot;6.jpg&quot;, &quot;FinalImage.jpg&quot;); waitKey(); } 效果依次如下： 原始图 二值化图 掩膜mask是这样的 旋转矫正之后 将人民币区域抠出来 该算法的效果还是很不错的！那赶紧试试其他图片，我把倾斜的发票图像拿去试试。 原始图 倾斜矫正之后 最后把目标区域抠出来，成为单独的照片。 上面的算法可以很好的处理人民币和发票两种情况的倾斜矫正，那文本矫正可以吗？我赶紧试了一下，结果是失败的。 原图 算法矫正后，还是原样，矫正失败。 认真分析一下，还是很容易看出文本矫正失败的原因的。 原因就在于，人民币图像和发票图像他们有明显的的边界轮廓，而文本图像没有。文本图像的背景是白色的，所以我们没有办法像人民币发票那类有明显边界的矩形物体那样，提取出轮廓并旋转矫正。 经过深入分析可以看出，虽然文本类图像没有明显的边缘轮廓，但是他们有一个很重要的特征，那就是每一行文字都是呈现一条直线形状，而且这些直线都是平行的！ 对于这种情况，我想到了另一种方法：基于直线探测的矫正算法。 首先介绍一下我的算法思路： 用霍夫线变换探测出图像中的所有直线 计算出每条直线的倾斜角，求他们的平均值 根据倾斜角旋转矫正 最后根据文本尺寸裁剪图片 然后给出OpenCV的实现算法： #include &quot;opencv2/imgproc.hpp&quot; #include &quot;opencv2/highgui.hpp&quot; #include &lt;iostream&gt; using namespace cv; using namespace std; #define ERROR 1234 //度数转换 double DegreeTrans(double theta) { double res = theta / CV_PI * 180; return res; } //逆时针旋转图像degree角度（原尺寸） void rotateImage(Mat src, Mat&amp; img_rotate, double degree) { //旋转中心为图像中心 Point2f center; center.x = float(src.cols / 2.0); center.y = float(src.rows / 2.0); int length = 0; length = sqrt(src.cols*src.cols + src.rows*src.rows); //计算二维旋转的仿射变换矩阵 Mat M = getRotationMatrix2D(center, degree, 1); warpAffine(src, img_rotate, M, Size(length, length), 1, 0, Scalar(255,255,255));//仿射变换，背景色填充为白色 } //通过霍夫变换计算角度 double CalcDegree(const Mat &amp;srcImage, Mat &amp;dst) { Mat midImage, dstImage; Canny(srcImage, midImage, 50, 200, 3); cvtColor(midImage, dstImage, CV_GRAY2BGR); //通过霍夫变换检测直线 vector&lt;Vec2f&gt; lines; HoughLines(midImage, lines, 1, CV_PI / 180, 300, 0, 0);//第5个参数就是阈值，阈值越大，检测精度越高 //cout &lt;&lt; lines.size() &lt;&lt; endl; //由于图像不同，阈值不好设定，因为阈值设定过高导致无法检测直线，阈值过低直线太多，速度很慢 //所以根据阈值由大到小设置了三个阈值，如果经过大量试验后，可以固定一个适合的阈值。 if (!lines.size()) { HoughLines(midImage, lines, 1, CV_PI / 180, 200, 0, 0); } //cout &lt;&lt; lines.size() &lt;&lt; endl; if (!lines.size()) { HoughLines(midImage, lines, 1, CV_PI / 180, 150, 0, 0); } //cout &lt;&lt; lines.size() &lt;&lt; endl; if (!lines.size()) { cout &lt;&lt; &quot;没有检测到直线！&quot; &lt;&lt; endl; return ERROR; } float sum = 0; //依次画出每条线段 for (size_t i = 0; i &lt; lines.size(); i++) { float rho = lines[i][0]; float theta = lines[i][1]; Point pt1, pt2; //cout &lt;&lt; theta &lt;&lt; endl; double a = cos(theta), b = sin(theta); double x0 = a*rho, y0 = b*rho; pt1.x = cvRound(x0 + 1000 * (-b)); pt1.y = cvRound(y0 + 1000 * (a)); pt2.x = cvRound(x0 - 1000 * (-b)); pt2.y = cvRound(y0 - 1000 * (a)); //只选角度最小的作为旋转角度 sum += theta; line(dstImage, pt1, pt2, Scalar(55, 100, 195), 1, LINE_AA); //Scalar函数用于调节线段颜色 imshow(&quot;直线探测效果图&quot;, dstImage); } float average = sum / lines.size(); //对所有角度求平均，这样做旋转效果会更好 cout &lt;&lt; &quot;average theta:&quot; &lt;&lt; average &lt;&lt; endl; double angle = DegreeTrans(average) - 90; rotateImage(dstImage, dst, angle); //imshow(&quot;直线探测效果图2&quot;, dstImage); return angle; } void ImageRecify(const char* pInFileName, const char* pOutFileName) { double degree; Mat src = imread(pInFileName); imshow(&quot;原始图&quot;, src); Mat dst; //倾斜角度矫正 degree = CalcDegree(src,dst); if (degree == ERROR) { cout &lt;&lt; &quot;矫正失败！&quot; &lt;&lt; endl; return; } rotateImage(src, dst, degree); cout &lt;&lt; &quot;angle:&quot; &lt;&lt; degree &lt;&lt; endl; imshow(&quot;旋转调整后&quot;, dst); Mat resulyImage = dst(Rect(0, 0, dst.cols, 500)); //根据先验知识，估计好文本的长宽，再裁剪下来 imshow(&quot;裁剪之后&quot;, resulyImage); imwrite(&quot;recified.jpg&quot;, resulyImage); } int main() { ImageRecify(&quot;correct2.jpg&quot;, &quot;FinalImage.jpg&quot;); waitKey(); return 0; } 看看效果。这是原始图 直线探测的效果。 矫正之后的效果。 我们发现矫正之后的图像有较多留白，影响观看，所以需要进一步裁剪，保留文字区域。 赶紧再试多一张。 原始图 直线探测 矫正效果 进一步裁剪 可以看出，基于直线探测的矫正算法在文本处理上效果真的很不错！ 最后总结一下两个算法的应用场景： 基于轮廓提取的矫正算法更适用于车牌、身份证、人民币、书本、发票一类矩形形状而且边界明显的物体矫正。 基于直线探测的矫正算法更适用于文本类的矫正。" />
<link rel="canonical" href="https://mlh.app/2019/04/08/727756.html" />
<meta property="og:url" content="https://mlh.app/2019/04/08/727756.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-08T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：最终版权归YBAidam所有 https://blog.csdn.net/Aidam_Bo/article/details/89098193 刚进入实验室导师就交给我一个任务，就是让我设计算法给图像进行矫正。哎呀，我不太会图像这块啊，不过还是接下来了，硬着头皮开干吧！ 那什么是图像的矫正呢？举个例子就好明白了。 我的好朋友小明给我拍了这几张照片，因为他的拍照技术不咋地，照片都拍得歪歪扭扭的，比如下面这些照片： 人民币 发票 文本 这些图片让人看得真不舒服！看个图片还要歪脖子看，实在是太烦人了！我叫小明帮我扫描一下一本教科书，小明把每一页书都拍成上面的文本那样了。好气啊那该怎么办呢？一页一页用PS来处理？1000页的矫正啊，当然交给计算机去做！ 真的，对于图像矫正的问题，在图像处理领域还真得多，比如人民币的矫正、文本的矫正、车牌的矫正、身份证矫正等等。这些都是因为拍摄者总不可能100%正确地拍摄好图片，这就要求我们通过后期的图像处理技术将图片还原好，才能进一步做后面的处理，比如数字分割啊数字识别啊，不然歪歪扭扭的文字数字，想识别出来估计就很难了。 上面几个图，我们在日常生活中遇到的可不少，因为拍摄时拍的不好，导致拍出来的图片歪歪扭扭的，很不自然，那么我们能不能把这些图片尽可能地矫正过来呢？ OpenCV告诉我们，没问题！工具我给你，算法你自己设计！ 比如图一，我要想将人民币矫正，并且把人民币整个抠出来保存，该怎么做？那就涉及到了图像的矫正和感兴趣区域提取两大技术了。 总的来说，要进行进行图像矫正，至少有以下几项知识储备： 轮廓提取技术 霍夫变换知识 ROI感兴趣区域知识 下面以人民币矫正、发票矫正、文本矫正为例，一步步剖析如何实现图像矫正。 首先分析如何矫正人民币。 比如我们要矫正这张人民币，思路应该是怎么样？ 首先分析这张图的特点。 在这张图里，人民币有一定的倾斜角度，但是角度不大；人民币的背景是黑色的，而且人民币的边缘应该比较明显。 没错，我们就抓住人民币的的边缘比较明显来做文章！我们是不是可以先把人民币的轮廓找出来（找出来的轮廓当然就是一个大大的矩形），然后用矩形去包围它，得到他的旋转角度，然后根据得到的角度进行旋转，那样不就可以实现矫正了吗！ 再详细地总结处理步骤： 图片灰度化 阈值二值化 检测轮廓 寻找轮廓的包围矩阵，并且获取角度 根据角度进行旋转矫正 对旋转后的图像进行轮廓提取 对轮廓内的图像区域抠出来，成为一张独立图像 我把该矫正算法命名为基于轮廓提取的矫正算法，因为其关键技术就是通过轮廓来获取旋转角度。 #include &quot;opencv2/imgproc.hpp&quot; #include &quot;opencv2/highgui.hpp&quot; #include &lt;iostream&gt; using namespace cv; using namespace std; //第一个参数：输入图片名称；第二个参数：输出图片名称 void GetContoursPic(const char* pSrcFileName, const char* pDstFileName) { Mat srcImg = imread(pSrcFileName); imshow(&quot;原始图&quot;, srcImg); Mat gray, binImg; //灰度化 cvtColor(srcImg, gray, COLOR_RGB2GRAY); imshow(&quot;灰度图&quot;, gray); //二值化 threshold(gray, binImg, 100, 200, CV_THRESH_BINARY); imshow(&quot;二值化&quot;, binImg); vector&lt;vector&lt;Point&gt; &gt; contours; vector&lt;Rect&gt; boundRect(contours.size()); //注意第5个参数为CV_RETR_EXTERNAL，只检索外框 findContours(binImg, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE); //找轮廓 cout &lt;&lt; contours.size() &lt;&lt; endl; for (int i = 0; i &lt; contours.size(); i++) { //需要获取的坐标 CvPoint2D32f rectpoint[4]; CvBox2D rect =minAreaRect(Mat(contours[i])); cvBoxPoints(rect, rectpoint); //获取4个顶点坐标 //与水平线的角度 float angle = rect.angle; cout &lt;&lt; angle &lt;&lt; endl; int line1 = sqrt((rectpoint[1].y - rectpoint[0].y)*(rectpoint[1].y - rectpoint[0].y) + (rectpoint[1].x - rectpoint[0].x)*(rectpoint[1].x - rectpoint[0].x)); int line2 = sqrt((rectpoint[3].y - rectpoint[0].y)*(rectpoint[3].y - rectpoint[0].y) + (rectpoint[3].x - rectpoint[0].x)*(rectpoint[3].x - rectpoint[0].x)); //rectangle(binImg, rectpoint[0], rectpoint[3], Scalar(255), 2); //面积太小的直接pass if (line1 * line2 &lt; 600) { continue; } //为了让正方形横着放，所以旋转角度是不一样的。竖放的，给他加90度，翻过来 if (line1 &gt; line2) { angle = 90 + angle; } //新建一个感兴趣的区域图，大小跟原图一样大 Mat RoiSrcImg(srcImg.rows, srcImg.cols, CV_8UC3); //注意这里必须选CV_8UC3 RoiSrcImg.setTo(0); //颜色都设置为黑色 //imshow(&quot;新建的ROI&quot;, RoiSrcImg); //对得到的轮廓填充一下 drawContours(binImg, contours, -1, Scalar(255),CV_FILLED); //抠图到RoiSrcImg srcImg.copyTo(RoiSrcImg, binImg); //再显示一下看看，除了感兴趣的区域，其他部分都是黑色的了 namedWindow(&quot;RoiSrcImg&quot;, 1); imshow(&quot;RoiSrcImg&quot;, RoiSrcImg); //创建一个旋转后的图像 Mat RatationedImg(RoiSrcImg.rows, RoiSrcImg.cols, CV_8UC1); RatationedImg.setTo(0); //对RoiSrcImg进行旋转 Point2f center = rect.center; //中心点 Mat M2 = getRotationMatrix2D(center, angle, 1);//计算旋转加缩放的变换矩阵 warpAffine(RoiSrcImg, RatationedImg, M2, RoiSrcImg.size(),1, 0, Scalar(0));//仿射变换 imshow(&quot;旋转之后&quot;, RatationedImg); imwrite(&quot;r.jpg&quot;, RatationedImg); //将矫正后的图片保存下来 } #if 1 //对ROI区域进行抠图 //对旋转后的图片进行轮廓提取 vector&lt;vector&lt;Point&gt; &gt; contours2; Mat raw = imread(&quot;r.jpg&quot;); Mat SecondFindImg; //SecondFindImg.setTo(0); cvtColor(raw, SecondFindImg, COLOR_BGR2GRAY); //灰度化 threshold(SecondFindImg, SecondFindImg, 80, 200, CV_THRESH_BINARY); findContours(SecondFindImg, contours2, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE); //cout &lt;&lt; &quot;sec contour:&quot; &lt;&lt; contours2.size() &lt;&lt; endl; for (int j = 0; j &lt; contours2.size(); j++) { //这时候其实就是一个长方形了，所以获取rect Rect rect = boundingRect(Mat(contours2[j])); //面积太小的轮廓直接pass,通过设置过滤面积大小，可以保证只拿到外框 if (rect.area() &lt; 600) { continue; } Mat dstImg = raw(rect); imshow(&quot;dst&quot;, dstImg); imwrite(pDstFileName, dstImg); } #endif } void main() { GetContoursPic(&quot;6.jpg&quot;, &quot;FinalImage.jpg&quot;); waitKey(); } 效果依次如下： 原始图 二值化图 掩膜mask是这样的 旋转矫正之后 将人民币区域抠出来 该算法的效果还是很不错的！那赶紧试试其他图片，我把倾斜的发票图像拿去试试。 原始图 倾斜矫正之后 最后把目标区域抠出来，成为单独的照片。 上面的算法可以很好的处理人民币和发票两种情况的倾斜矫正，那文本矫正可以吗？我赶紧试了一下，结果是失败的。 原图 算法矫正后，还是原样，矫正失败。 认真分析一下，还是很容易看出文本矫正失败的原因的。 原因就在于，人民币图像和发票图像他们有明显的的边界轮廓，而文本图像没有。文本图像的背景是白色的，所以我们没有办法像人民币发票那类有明显边界的矩形物体那样，提取出轮廓并旋转矫正。 经过深入分析可以看出，虽然文本类图像没有明显的边缘轮廓，但是他们有一个很重要的特征，那就是每一行文字都是呈现一条直线形状，而且这些直线都是平行的！ 对于这种情况，我想到了另一种方法：基于直线探测的矫正算法。 首先介绍一下我的算法思路： 用霍夫线变换探测出图像中的所有直线 计算出每条直线的倾斜角，求他们的平均值 根据倾斜角旋转矫正 最后根据文本尺寸裁剪图片 然后给出OpenCV的实现算法： #include &quot;opencv2/imgproc.hpp&quot; #include &quot;opencv2/highgui.hpp&quot; #include &lt;iostream&gt; using namespace cv; using namespace std; #define ERROR 1234 //度数转换 double DegreeTrans(double theta) { double res = theta / CV_PI * 180; return res; } //逆时针旋转图像degree角度（原尺寸） void rotateImage(Mat src, Mat&amp; img_rotate, double degree) { //旋转中心为图像中心 Point2f center; center.x = float(src.cols / 2.0); center.y = float(src.rows / 2.0); int length = 0; length = sqrt(src.cols*src.cols + src.rows*src.rows); //计算二维旋转的仿射变换矩阵 Mat M = getRotationMatrix2D(center, degree, 1); warpAffine(src, img_rotate, M, Size(length, length), 1, 0, Scalar(255,255,255));//仿射变换，背景色填充为白色 } //通过霍夫变换计算角度 double CalcDegree(const Mat &amp;srcImage, Mat &amp;dst) { Mat midImage, dstImage; Canny(srcImage, midImage, 50, 200, 3); cvtColor(midImage, dstImage, CV_GRAY2BGR); //通过霍夫变换检测直线 vector&lt;Vec2f&gt; lines; HoughLines(midImage, lines, 1, CV_PI / 180, 300, 0, 0);//第5个参数就是阈值，阈值越大，检测精度越高 //cout &lt;&lt; lines.size() &lt;&lt; endl; //由于图像不同，阈值不好设定，因为阈值设定过高导致无法检测直线，阈值过低直线太多，速度很慢 //所以根据阈值由大到小设置了三个阈值，如果经过大量试验后，可以固定一个适合的阈值。 if (!lines.size()) { HoughLines(midImage, lines, 1, CV_PI / 180, 200, 0, 0); } //cout &lt;&lt; lines.size() &lt;&lt; endl; if (!lines.size()) { HoughLines(midImage, lines, 1, CV_PI / 180, 150, 0, 0); } //cout &lt;&lt; lines.size() &lt;&lt; endl; if (!lines.size()) { cout &lt;&lt; &quot;没有检测到直线！&quot; &lt;&lt; endl; return ERROR; } float sum = 0; //依次画出每条线段 for (size_t i = 0; i &lt; lines.size(); i++) { float rho = lines[i][0]; float theta = lines[i][1]; Point pt1, pt2; //cout &lt;&lt; theta &lt;&lt; endl; double a = cos(theta), b = sin(theta); double x0 = a*rho, y0 = b*rho; pt1.x = cvRound(x0 + 1000 * (-b)); pt1.y = cvRound(y0 + 1000 * (a)); pt2.x = cvRound(x0 - 1000 * (-b)); pt2.y = cvRound(y0 - 1000 * (a)); //只选角度最小的作为旋转角度 sum += theta; line(dstImage, pt1, pt2, Scalar(55, 100, 195), 1, LINE_AA); //Scalar函数用于调节线段颜色 imshow(&quot;直线探测效果图&quot;, dstImage); } float average = sum / lines.size(); //对所有角度求平均，这样做旋转效果会更好 cout &lt;&lt; &quot;average theta:&quot; &lt;&lt; average &lt;&lt; endl; double angle = DegreeTrans(average) - 90; rotateImage(dstImage, dst, angle); //imshow(&quot;直线探测效果图2&quot;, dstImage); return angle; } void ImageRecify(const char* pInFileName, const char* pOutFileName) { double degree; Mat src = imread(pInFileName); imshow(&quot;原始图&quot;, src); Mat dst; //倾斜角度矫正 degree = CalcDegree(src,dst); if (degree == ERROR) { cout &lt;&lt; &quot;矫正失败！&quot; &lt;&lt; endl; return; } rotateImage(src, dst, degree); cout &lt;&lt; &quot;angle:&quot; &lt;&lt; degree &lt;&lt; endl; imshow(&quot;旋转调整后&quot;, dst); Mat resulyImage = dst(Rect(0, 0, dst.cols, 500)); //根据先验知识，估计好文本的长宽，再裁剪下来 imshow(&quot;裁剪之后&quot;, resulyImage); imwrite(&quot;recified.jpg&quot;, resulyImage); } int main() { ImageRecify(&quot;correct2.jpg&quot;, &quot;FinalImage.jpg&quot;); waitKey(); return 0; } 看看效果。这是原始图 直线探测的效果。 矫正之后的效果。 我们发现矫正之后的图像有较多留白，影响观看，所以需要进一步裁剪，保留文字区域。 赶紧再试多一张。 原始图 直线探测 矫正效果 进一步裁剪 可以看出，基于直线探测的矫正算法在文本处理上效果真的很不错！ 最后总结一下两个算法的应用场景： 基于轮廓提取的矫正算法更适用于车牌、身份证、人民币、书本、发票一类矩形形状而且边界明显的物体矫正。 基于直线探测的矫正算法更适用于文本类的矫正。","@type":"BlogPosting","url":"https://mlh.app/2019/04/08/727756.html","headline":"OpenCV精进之路（十六）：图像矫正技术深入探讨","dateModified":"2019-04-08T00:00:00+08:00","datePublished":"2019-04-08T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/08/727756.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>OpenCV精进之路（十六）：图像矫正技术深入探讨</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：最终版权归YBAidam所有 https://blog.csdn.net/Aidam_Bo/article/details/89098193 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>刚进入实验室导师就交给我一个任务，就是让我设计算法给图像进行矫正。哎呀，我不太会图像这块啊，不过还是接下来了，硬着头皮开干吧！</p> 
  <p>那什么是图像的矫正呢？举个例子就好明白了。</p> 
  <p>我的好朋友小明给我拍了这几张照片，因为他的拍照技术不咋地，照片都拍得歪歪扭扭的，比如下面这些照片：</p> 
  <p>人民币<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525103505607-310225545.png"></p> 
  <p>发票<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525103751904-496186937.jpg"></p> 
  <p>文本<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525103811216-1979172263.jpg"></p> 
  <p>这些图片让人看得真不舒服！看个图片还要歪脖子看，实在是太烦人了！我叫小明帮我扫描一下一本教科书，小明把每一页书都拍成上面的文本那样了。好气啊那该怎么办呢？一页一页用PS来处理？1000页的矫正啊，当然交给计算机去做！</p> 
  <p>真的，对于图像矫正的问题，在图像处理领域还真得多，比如人民币的矫正、文本的矫正、车牌的矫正、身份证矫正等等。这些都是因为拍摄者总不可能100%正确地拍摄好图片，这就要求我们通过后期的图像处理技术将图片还原好，才能进一步做后面的处理，比如数字分割啊数字识别啊，不然歪歪扭扭的文字数字，想识别出来估计就很难了。</p> 
  <p>上面几个图，我们在日常生活中遇到的可不少，因为拍摄时拍的不好，导致拍出来的图片歪歪扭扭的，很不自然，那么我们能不能把这些图片尽可能地矫正过来呢？</p> 
  <p>OpenCV告诉我们，没问题！工具我给你，算法你自己设计！</p> 
  <p>比如图一，我要想将人民币矫正，并且把人民币整个抠出来保存，该怎么做？那就涉及到了图像的矫正和感兴趣区域提取两大技术了。</p> 
  <p>总的来说，要进行进行图像矫正，至少有以下几项知识储备：</p> 
  <ul>
   <li>轮廓提取技术</li> 
   <li>霍夫变换知识</li> 
   <li>ROI感兴趣区域知识</li> 
  </ul>
  <p>下面以人民币矫正、发票矫正、文本矫正为例，一步步剖析如何实现图像矫正。</p> 
  <p>首先分析如何矫正人民币。</p> 
  <p>比如我们要矫正这张人民币，思路应该是怎么样？<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525103847982-439543547.png"></p> 
  <p>首先分析这张图的特点。</p> 
  <p>在这张图里，人民币有一定的倾斜角度，但是角度不大；人民币的背景是黑色的，而且人民币的边缘应该比较明显。</p> 
  <p>没错，我们就抓住人民币的的边缘比较明显来做文章！我们是不是可以先把人民币的轮廓找出来（找出来的轮廓当然就是一个大大的矩形），然后用矩形去包围它，得到他的旋转角度，然后根据得到的角度进行旋转，那样不就可以实现矫正了吗！</p> 
  <p>再详细地总结处理步骤：</p> 
  <ol>
   <li>图片灰度化</li> 
   <li>阈值二值化</li> 
   <li>检测轮廓</li> 
   <li>寻找轮廓的包围矩阵，并且获取角度</li> 
   <li>根据角度进行旋转矫正</li> 
   <li>对旋转后的图像进行轮廓提取</li> 
   <li>对轮廓内的图像区域抠出来，成为一张独立图像</li> 
  </ol>
  <p>我把该矫正算法命名为<strong>基于轮廓提取的矫正算法</strong>，因为其关键技术就是通过轮廓来获取旋转角度。</p> 
  <pre class="has">
<code class="language-cpp">#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include &lt;iostream&gt;
using namespace cv;
using namespace std;

//第一个参数：输入图片名称；第二个参数：输出图片名称
void GetContoursPic(const char* pSrcFileName, const char* pDstFileName)
{
    Mat srcImg = imread(pSrcFileName);
    imshow("原始图", srcImg);
    Mat gray, binImg;
    //灰度化
    cvtColor(srcImg, gray, COLOR_RGB2GRAY);
    imshow("灰度图", gray);
    //二值化
    threshold(gray, binImg, 100, 200, CV_THRESH_BINARY);
    imshow("二值化", binImg);

    vector&lt;vector&lt;Point&gt; &gt; contours;
    vector&lt;Rect&gt; boundRect(contours.size());
    //注意第5个参数为CV_RETR_EXTERNAL，只检索外框  
    findContours(binImg, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE); //找轮廓
    cout &lt;&lt; contours.size() &lt;&lt; endl;
    for (int i = 0; i &lt; contours.size(); i++)
    {
        //需要获取的坐标  
        CvPoint2D32f rectpoint[4];
        CvBox2D rect =minAreaRect(Mat(contours[i]));

        cvBoxPoints(rect, rectpoint); //获取4个顶点坐标  
        //与水平线的角度  
        float angle = rect.angle;
        cout &lt;&lt; angle &lt;&lt; endl;

        int line1 = sqrt((rectpoint[1].y - rectpoint[0].y)*(rectpoint[1].y - rectpoint[0].y) + (rectpoint[1].x - rectpoint[0].x)*(rectpoint[1].x - rectpoint[0].x));
        int line2 = sqrt((rectpoint[3].y - rectpoint[0].y)*(rectpoint[3].y - rectpoint[0].y) + (rectpoint[3].x - rectpoint[0].x)*(rectpoint[3].x - rectpoint[0].x));
        //rectangle(binImg, rectpoint[0], rectpoint[3], Scalar(255), 2);
        //面积太小的直接pass
        if (line1 * line2 &lt; 600)
        {
            continue;
        }

        //为了让正方形横着放，所以旋转角度是不一样的。竖放的，给他加90度，翻过来  
        if (line1 &gt; line2) 
        {
            angle = 90 + angle;
        }

        //新建一个感兴趣的区域图，大小跟原图一样大  
        Mat RoiSrcImg(srcImg.rows, srcImg.cols, CV_8UC3); //注意这里必须选CV_8UC3
        RoiSrcImg.setTo(0); //颜色都设置为黑色  
        //imshow("新建的ROI", RoiSrcImg);
        //对得到的轮廓填充一下  
        drawContours(binImg, contours, -1, Scalar(255),CV_FILLED);

        //抠图到RoiSrcImg
        srcImg.copyTo(RoiSrcImg, binImg);


        //再显示一下看看，除了感兴趣的区域，其他部分都是黑色的了  
        namedWindow("RoiSrcImg", 1);
        imshow("RoiSrcImg", RoiSrcImg);

        //创建一个旋转后的图像  
        Mat RatationedImg(RoiSrcImg.rows, RoiSrcImg.cols, CV_8UC1);
        RatationedImg.setTo(0);
        //对RoiSrcImg进行旋转  
        Point2f center = rect.center;  //中心点  
        Mat M2 = getRotationMatrix2D(center, angle, 1);//计算旋转加缩放的变换矩阵 
        warpAffine(RoiSrcImg, RatationedImg, M2, RoiSrcImg.size(),1, 0, Scalar(0));//仿射变换 
        imshow("旋转之后", RatationedImg);
        imwrite("r.jpg", RatationedImg); //将矫正后的图片保存下来
    }

#if 1
    //对ROI区域进行抠图

    //对旋转后的图片进行轮廓提取  
    vector&lt;vector&lt;Point&gt; &gt; contours2;
    Mat raw = imread("r.jpg");
    Mat SecondFindImg;
    //SecondFindImg.setTo(0);
    cvtColor(raw, SecondFindImg, COLOR_BGR2GRAY);  //灰度化  
    threshold(SecondFindImg, SecondFindImg, 80, 200, CV_THRESH_BINARY);
    findContours(SecondFindImg, contours2, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);
    //cout &lt;&lt; "sec contour:" &lt;&lt; contours2.size() &lt;&lt; endl;

    for (int j = 0; j &lt; contours2.size(); j++)
    {
        //这时候其实就是一个长方形了，所以获取rect  
        Rect rect = boundingRect(Mat(contours2[j]));
        //面积太小的轮廓直接pass,通过设置过滤面积大小，可以保证只拿到外框
        if (rect.area() &lt; 600)
        {
            continue;
        }
        Mat dstImg = raw(rect);
        imshow("dst", dstImg);
        imwrite(pDstFileName, dstImg);
    }
#endif


}


void main()
{
    GetContoursPic("6.jpg", "FinalImage.jpg");
    waitKey();
}</code></pre> 
  <p>效果依次如下：<br> 原始图<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525103937935-23597995.png"></p> 
  <p>二值化图<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525103952716-602480846.png"></p> 
  <p>掩膜mask是这样的<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104014544-1241945473.png"></p> 
  <p>旋转矫正之后<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104032091-1002803109.png"></p> 
  <p>将人民币区域抠出来<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104049575-42467248.png"></p> 
  <p>该算法的效果还是很不错的！那赶紧试试其他图片，我把倾斜的发票图像拿去试试。</p> 
  <p>原始图<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104106435-1979163532.png"></p> 
  <p>倾斜矫正之后<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104127232-974049586.png"></p> 
  <p>最后把目标区域抠出来，成为单独的照片。<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104232325-1188630099.png"></p> 
  <p>上面的算法可以很好的处理人民币和发票两种情况的倾斜矫正，那文本矫正可以吗？我赶紧试了一下，结果是失败的。</p> 
  <p>原图<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104248997-1574290710.png"></p> 
  <p>算法矫正后，还是原样，矫正失败。<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104304466-784235363.png"></p> 
  <p>认真分析一下，还是很容易看出文本矫正失败的原因的。</p> 
  <p>原因就在于，人民币图像和发票图像他们有明显的的边界轮廓，而文本图像没有。文本图像的背景是白色的，所以我们没有办法像人民币发票那类有明显边界的矩形物体那样，提取出轮廓并旋转矫正。</p> 
  <p>经过深入分析可以看出，虽然文本类图像没有明显的边缘轮廓，但是他们有一个很重要的特征，那就是每一行文字都是呈现一条直线形状，而且这些直线都是平行的！</p> 
  <p>对于这种情况，我想到了另一种方法：<strong>基于直线探测的矫正算法</strong>。</p> 
  <p>首先介绍一下我的算法思路：</p> 
  <ol>
   <li>用霍夫线变换探测出图像中的所有直线</li> 
   <li>计算出每条直线的倾斜角，求他们的平均值</li> 
   <li>根据倾斜角旋转矫正</li> 
   <li>最后根据文本尺寸裁剪图片</li> 
  </ol>
  <p>然后给出OpenCV的实现算法：</p> 
  <pre class="has">
<code class="language-cpp">
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include &lt;iostream&gt;
using namespace cv;
using namespace std;

#define ERROR 1234

//度数转换
double DegreeTrans(double theta)
{
    double res = theta / CV_PI * 180;
    return res;
}


//逆时针旋转图像degree角度（原尺寸）    
void rotateImage(Mat src, Mat&amp; img_rotate, double degree)
{
    //旋转中心为图像中心    
    Point2f center;
    center.x = float(src.cols / 2.0);
    center.y = float(src.rows / 2.0);
    int length = 0;
    length = sqrt(src.cols*src.cols + src.rows*src.rows);
    //计算二维旋转的仿射变换矩阵  
    Mat M = getRotationMatrix2D(center, degree, 1);
    warpAffine(src, img_rotate, M, Size(length, length), 1, 0, Scalar(255,255,255));//仿射变换，背景色填充为白色  
}

//通过霍夫变换计算角度
double CalcDegree(const Mat &amp;srcImage, Mat &amp;dst)
{
    Mat midImage, dstImage;

    Canny(srcImage, midImage, 50, 200, 3);
    cvtColor(midImage, dstImage, CV_GRAY2BGR);

    //通过霍夫变换检测直线
    vector&lt;Vec2f&gt; lines;
    HoughLines(midImage, lines, 1, CV_PI / 180, 300, 0, 0);//第5个参数就是阈值，阈值越大，检测精度越高
    //cout &lt;&lt; lines.size() &lt;&lt; endl;

    //由于图像不同，阈值不好设定，因为阈值设定过高导致无法检测直线，阈值过低直线太多，速度很慢
    //所以根据阈值由大到小设置了三个阈值，如果经过大量试验后，可以固定一个适合的阈值。

    if (!lines.size())
    {
        HoughLines(midImage, lines, 1, CV_PI / 180, 200, 0, 0);
    }
    //cout &lt;&lt; lines.size() &lt;&lt; endl;

    if (!lines.size())
    {
        HoughLines(midImage, lines, 1, CV_PI / 180, 150, 0, 0);
    }
    //cout &lt;&lt; lines.size() &lt;&lt; endl;
    if (!lines.size())
    {
        cout &lt;&lt; "没有检测到直线！" &lt;&lt; endl;
        return ERROR;
    }

    float sum = 0;
    //依次画出每条线段
    for (size_t i = 0; i &lt; lines.size(); i++)
    {
        float rho = lines[i][0];
        float theta = lines[i][1];
        Point pt1, pt2;
        //cout &lt;&lt; theta &lt;&lt; endl;
        double a = cos(theta), b = sin(theta);
        double x0 = a*rho, y0 = b*rho;
        pt1.x = cvRound(x0 + 1000 * (-b));
        pt1.y = cvRound(y0 + 1000 * (a));
        pt2.x = cvRound(x0 - 1000 * (-b));
        pt2.y = cvRound(y0 - 1000 * (a));
        //只选角度最小的作为旋转角度
        sum += theta;

        line(dstImage, pt1, pt2, Scalar(55, 100, 195), 1, LINE_AA); //Scalar函数用于调节线段颜色

        imshow("直线探测效果图", dstImage);
    }
    float average = sum / lines.size(); //对所有角度求平均，这样做旋转效果会更好

    cout &lt;&lt; "average theta:" &lt;&lt; average &lt;&lt; endl;

    double angle = DegreeTrans(average) - 90;

    rotateImage(dstImage, dst, angle);
    //imshow("直线探测效果图2", dstImage);
    return angle;
}


void ImageRecify(const char* pInFileName, const char* pOutFileName)
{
    double degree;
    Mat src = imread(pInFileName);
    imshow("原始图", src);
    Mat dst;
    //倾斜角度矫正
    degree = CalcDegree(src,dst);
    if (degree == ERROR)
    {
        cout &lt;&lt; "矫正失败！" &lt;&lt; endl;
        return;
    }
    rotateImage(src, dst, degree);
    cout &lt;&lt; "angle:" &lt;&lt; degree &lt;&lt; endl;
    imshow("旋转调整后", dst);

    Mat resulyImage = dst(Rect(0, 0, dst.cols, 500)); //根据先验知识，估计好文本的长宽，再裁剪下来
    imshow("裁剪之后", resulyImage);
    imwrite("recified.jpg", resulyImage); 
}


int main()
{
    ImageRecify("correct2.jpg", "FinalImage.jpg");
    waitKey();
    return 0;
}
</code></pre> 
  <p>看看效果。这是原始图<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104325779-436373391.png"></p> 
  <p>直线探测的效果。<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104339607-1915398474.png"></p> 
  <p>矫正之后的效果。<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104355716-1648522818.png"></p> 
  <p>我们发现矫正之后的图像有较多留白，影响观看，所以需要进一步裁剪，保留文字区域。</p> 
  <p><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104414310-1815639311.png"></p> 
  <p>赶紧再试多一张。</p> 
  <p>原始图<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104430232-667394303.png"></p> 
  <p>直线探测<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104501044-2104246556.png"></p> 
  <p>矫正效果<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104519638-1908093147.png"></p> 
  <p>进一步裁剪<br><img alt="" class="has" src="https://images2015.cnblogs.com/blog/1093303/201705/1093303-20170525104533622-937603413.png"></p> 
  <p>可以看出，基于直线探测的矫正算法在文本处理上效果真的很不错！</p> 
  <p><strong>最后总结一下两个算法的应用场景：</strong></p> 
  <ul>
   <li> <p>基于轮廓提取的矫正算法更适用于车牌、身份证、人民币、书本、发票一类矩形形状而且边界明显的物体矫正。</p> </li> 
   <li> <p>基于直线探测的矫正算法更适用于文本类的矫正。</p> </li> 
  </ul> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
