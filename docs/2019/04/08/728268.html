<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>戳破 hive on spark 调优点 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="戳破 hive on spark 调优点" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/rlnLo2pNEfx9c/article/details/89117446 微信交流群里有人问浪尖hive on spark如何调优，当时浪尖时间忙没时间回答，这里就给出一篇文章详细聊聊。强调一下资源设置调优，这个强经验性质的，这里给出的数值比例仅供参考。 hive on spark 性能远比hive on mr 要好，而且提供了一样的功能。用户的sql无需修改就可以直接运行于hive on spark。 udf函数也是全部支持。 本文主要是想讲hive on spark 在运行于yarn模式的情况下如何调优。 下文举例讲解的yarn节点机器配置，假设有32核，120GB内存。 yarn配置 yarn.nodemanager.resource.cpu-vcores和yarn.nodemanager.resource.memory-mb,这两个参数决定这集群资源管理器能够有多少资源用于运行yarn上的任务。 这两个参数的值是由机器的配置及同时在机器上运行的其它进程共同决定。本文假设仅有hdfs的datanode和yarn的nodemanager运行于该节点。 1. 配置cores 基本配置是datanode和nodemanager各一个核，操作系统两个核，然后剩下28核配置作为yarn资源。也即是yarn.nodemanager.resource.cpu-vcores=28&nbsp; 2. 配置内存&nbsp; 对于内存，预留20GB给操作系统，datanode，nodemanager，剩余100GB作为yarn资源。也即是&nbsp;yarn.nodemanager.resource.memory-mb=100*1024 spark配置 给yarn分配资源以后，那就要想着spark如何使用这些资源了，主要配置对象： execurtor 和driver内存，executro配额，并行度。 1. executor内存 设置executor内存需要考虑如下因素: executor内存越多，越能为更多的查询提供map join的优化。由于垃圾回收的压力会导致开销增加。 某些情况下hdfs的 客户端不能很好的处理并发写入，所以过多的核心可能会导致竞争。 为了最大化使用core，建议将core设置为4，5，6（多核心会导致并发问题，所以写代码的时候尤其是静态的链接等要考虑并发问题）具体分配核心数要结合yarn所提供的核心数。 由于本文中涉及到的node节点是28核，那么很明显分配为4的化可以被整除，spark.executor.cores设置为4 不会有多余的核剩下,设置为5，6都会有core剩余。&nbsp;spark.executor.cores=4，由于总共有28个核，那么最大可以申请的executor数是7。总内存处以7，也即是 100/7，可以得到每个executor约14GB内存。 要知道&nbsp;spark.executor.memory&nbsp;和spark.executor.memoryOverhead&nbsp;共同决定着 executor内存。建议&nbsp;spark.executor.memoryOverhead站总内存的 15%-20%。 那么最终&nbsp;spark.executor.memoryOverhead=2 G&nbsp;和spark.executor.memory=12 G 根据上面的配置的化，每个主机就可以申请7个executor，每个executor可以运行4个任务，每个core一个task。那么每个task的平均内存是 14/4 = 3.5GB。在executor运行的task共享内存。 其实，executor内部是用newCachedThreadPool运行task的。 确保&nbsp;spark.executor.memoryOverhead和&nbsp;spark.executor.memory的和不超过yarn.scheduler.maximum-allocation-mb 2. driver内存 对于drvier的内存配置，当然也包括两个参数。 spark.driver.memoryOverhead 每个driver能从yarn申请的堆外内存的大小。 spark.driver.memory 当运行hive on spark的时候，每个spark driver能申请的最大jvm 堆内存。该参数结合&nbsp;spark.driver.memoryOverhead共同决定着driver的内存大小。 driver的内存大小并不直接影响性能，但是也不要job的运行受限于driver的内存. 这里给出spark driver内存申请的方案，假设yarn.nodemanager.resource.memory-mb是 X。 driver内存申请12GB，假设 X &gt; 50GB driver内存申请 4GB，假设 12GB &lt; X &lt;50GB driver内存申请1GB,假设 1GB &lt; X &lt; 12 GB driver内存申请256MB，假设 X &lt; 1GB 这些数值是&nbsp;spark.driver.memory和&nbsp;spark.driver.memoryOverhead内存的总和。对外内存站总内存的10%-15%。 假设&nbsp;yarn.nodemanager.resource.memory-mb=100*1024MB,那么driver内存设置为12GB，此时&nbsp;spark.driver.memory=10.5gb和spark.driver.memoryOverhead=1.5gb 注意，资源多少直接对应的是数据量的大小。所以要结合资源和数据量进行适当缩减和增加。 3. executor数 executor的数目是由每个节点运行的executor数目和集群的节点数共同决定。如果你有四十个节点，那么hive可以使用的最大executor数就是 280(40*7). 最大数目可能比这个小点，因为driver也会消耗1core和12GB。 当前假设是没有yarn应用在跑。 Hive性能与用于运行查询的executor数量直接相关。 但是，不通查询还是不通。 通常，性能与executor的数量成比例。 例如，查询使用四个executor大约需要使用两个executor的一半时间。 但是，性能在一定数量的executor中达到峰值，高于此值时，增加数量不会改善性能并且可能产生不利影响。 在大多数情况下，使用一半的集群容量（executor数量的一半）可以提供良好的性能。 为了获得最佳性能，最好使用所有可用的executor。 例如，设置spark.executor.instances = 280。 对于基准测试和性能测量，强烈建议这样做。 4. 动态executor申请 虽然将spark.executor.instances设置为最大值通常可以最大限度地提高性能，但不建议在多个用户运行Hive查询的生产环境中这样做。 避免为用户会话分配固定数量的executor，因为如果executor空闲，executor不能被其他用户查询使用。 在生产环境中，应该好好计划executor分配，以允许更多的资源共享。 Spark允许您根据工作负载动态扩展分配给Spark应用程序的集群资源集。 要启用动态分配，请按照动态分配中的步骤进行操作。 除了在某些情况下，强烈建议启用动态分配。 5. 并行度 要使可用的executor得到充分利用，必须同时运行足够的任务（并行）。在大多数情况下，Hive会自动确定并行度，但也可以在调优并发度方面有一些控制权。 在输入端，map任务的数量等于输入格式生成的split数。对于Hive on Spark，输入格式为CombineHiveInputFormat，它可以根据需要对基础输入格式生成的split进行分组。 可以更好地控制stage边界的并行度。调整hive.exec.reducers.bytes.per.reducer以控制每个reducer处理的数据量，Hive根据可用的executor，执行程序内存，以及其他因素来确定最佳分区数。 实验表明，只要生成足够的任务来保持所有可用的executor繁忙，Spark就比MapReduce对hive.exec.reducers.bytes.per.reducer指定的值敏感度低。 为获得最佳性能，请为该属性选择一个值，以便Hive生成足够的任务以完全使用所有可用的executor。 hive配置 Hive on spark 共享了很多hive性能相关的配置。可以像调优hive on mapreduce一样调优hive on spark。 然而，hive.auto.convert.join.noconditionaltask.size是基于统计信息将基础join转化为map join的阈值，可能会对性能产生重大影响。 尽管该配置可以用hive on mr和hive on spark，但是两者的解释不同。 数据的大小有两个统计指标： totalSize- 数据在磁盘上的近似大小。 rawDataSize- 数据在内存中的近似大小。 hive on mr用的是totalSize。hive on spark使用的是rawDataSize。由于可能存在压缩和序列化，这两个值会有较大的差别。 对于hive on spark 需要将&nbsp;hive.auto.convert.join.noconditionaltask.size指定为更大的值，才能将与hive on mr相同的join转化为map join。 可以增加此参数的值，以使地图连接转换更具凶猛。 将common join 转换为 map join 可以提高性能。 如果此值设置得太大，则来自小表的数据将使用过多内存，任务可能会因内存不足而失败。 根据群集环境调整此值。 通过参数&nbsp;hive.stats.collect.rawdatasize&nbsp;可以控制是否收集 rawDataSize 统计信息。 对于hiveserver2，建议再配置两个额外的参数:&nbsp;hive.stats.fetch.column.stats=true&nbsp;和&nbsp;hive.optimize.index.filter=true. Hive性能调优通常建议使用以下属性： hive.optimize.reducededuplication.min.reducer=4hive.optimize.reducededuplication=truehive.merge.mapfiles=truehive.merge.mapredfiles=falsehive.merge.smallfiles.avgsize=16000000hive.merge.size.per.task=256000000hive.merge.sparkfiles=truehive.auto.convert.join=truehive.auto.convert.join.noconditionaltask=truehive.auto.convert.join.noconditionaltask.size=20M(might need to increase for Spark, 200M)hive.optimize.bucketmapjoin.sortedmerge=falsehive.map.aggr.hash.percentmemory=0.5hive.map.aggr=truehive.optimize.sort.dynamic.partition=falsehive.stats.autogather=truehive.stats.fetch.column.stats=truehive.compute.query.using.stats=truehive.limit.pushdown.memory.usage=0.4 (MR and Spark)hive.optimize.index.filter=truehive.exec.reducers.bytes.per.reducer=67108864hive.smbjoin.cache.rows=10000hive.fetch.task.conversion=morehive.fetch.task.conversion.threshold=1073741824hive.optimize.ppd=true 预启动YARN容器 在开始新会话后提交第一个查询时，在查看查询开始之前可能会遇到稍长的延迟。还会注意到，如果再次运行相同的查询，它的完成速度比第一个快得多。 Spark执行程序需要额外的时间来启动和初始化yarn上的Spark，这会导致较长的延迟。此外，Spark不会等待所有executor在启动作业之前全部启动完成，因此在将作业提交到群集后，某些executor可能仍在启动。 但是，对于在Spark上运行的作业，作业提交时可用executor的数量部分决定了reducer的数量。当就绪executor的数量未达到最大值时，作业可能没有最大并行度。这可能会进一步影响第一个查询的性能。 在用户较长期会话中，这个额外时间不会导致任何问题，因为它只在第一次查询执行时发生。然而，诸如Oozie发起的Hive工作之类的短期绘画可能无法实现最佳性能。 为减少启动时间，可以在作业开始前启用容器预热。只有在请求的executor准备就绪时，作业才会开始运行。这样，在reduce那一侧不会减少短会话的并行性。 要启用预热功能，请在发出查询之前将hive.prewarm.enabled设置为true。还可以通过设置hive.prewarm.numcontainers来设置容器数量。默认值为10。 预热的executor的实际数量受spark.executor.instances（静态分配）或spark.dynamicAllocation.maxExecutors（动态分配）的值限制。&nbsp;hive.prewarm.numcontainers的值不应超过分配给用户会话的值。 注意：预热需要几秒钟，对于短会话来说是一个很好的做法，特别是如果查询涉及reduce阶段。 但是，如果hive.prewarm.numcontainers的值高于群集中可用的值，则该过程最多可能需要30秒。 请谨慎使用预热。 [完]&nbsp; 推荐阅读： Hive性能优化（全面） 干货:Flink+Kafka 0.11端到端精确一次处理语义实现" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/rlnLo2pNEfx9c/article/details/89117446 微信交流群里有人问浪尖hive on spark如何调优，当时浪尖时间忙没时间回答，这里就给出一篇文章详细聊聊。强调一下资源设置调优，这个强经验性质的，这里给出的数值比例仅供参考。 hive on spark 性能远比hive on mr 要好，而且提供了一样的功能。用户的sql无需修改就可以直接运行于hive on spark。 udf函数也是全部支持。 本文主要是想讲hive on spark 在运行于yarn模式的情况下如何调优。 下文举例讲解的yarn节点机器配置，假设有32核，120GB内存。 yarn配置 yarn.nodemanager.resource.cpu-vcores和yarn.nodemanager.resource.memory-mb,这两个参数决定这集群资源管理器能够有多少资源用于运行yarn上的任务。 这两个参数的值是由机器的配置及同时在机器上运行的其它进程共同决定。本文假设仅有hdfs的datanode和yarn的nodemanager运行于该节点。 1. 配置cores 基本配置是datanode和nodemanager各一个核，操作系统两个核，然后剩下28核配置作为yarn资源。也即是yarn.nodemanager.resource.cpu-vcores=28&nbsp; 2. 配置内存&nbsp; 对于内存，预留20GB给操作系统，datanode，nodemanager，剩余100GB作为yarn资源。也即是&nbsp;yarn.nodemanager.resource.memory-mb=100*1024 spark配置 给yarn分配资源以后，那就要想着spark如何使用这些资源了，主要配置对象： execurtor 和driver内存，executro配额，并行度。 1. executor内存 设置executor内存需要考虑如下因素: executor内存越多，越能为更多的查询提供map join的优化。由于垃圾回收的压力会导致开销增加。 某些情况下hdfs的 客户端不能很好的处理并发写入，所以过多的核心可能会导致竞争。 为了最大化使用core，建议将core设置为4，5，6（多核心会导致并发问题，所以写代码的时候尤其是静态的链接等要考虑并发问题）具体分配核心数要结合yarn所提供的核心数。 由于本文中涉及到的node节点是28核，那么很明显分配为4的化可以被整除，spark.executor.cores设置为4 不会有多余的核剩下,设置为5，6都会有core剩余。&nbsp;spark.executor.cores=4，由于总共有28个核，那么最大可以申请的executor数是7。总内存处以7，也即是 100/7，可以得到每个executor约14GB内存。 要知道&nbsp;spark.executor.memory&nbsp;和spark.executor.memoryOverhead&nbsp;共同决定着 executor内存。建议&nbsp;spark.executor.memoryOverhead站总内存的 15%-20%。 那么最终&nbsp;spark.executor.memoryOverhead=2 G&nbsp;和spark.executor.memory=12 G 根据上面的配置的化，每个主机就可以申请7个executor，每个executor可以运行4个任务，每个core一个task。那么每个task的平均内存是 14/4 = 3.5GB。在executor运行的task共享内存。 其实，executor内部是用newCachedThreadPool运行task的。 确保&nbsp;spark.executor.memoryOverhead和&nbsp;spark.executor.memory的和不超过yarn.scheduler.maximum-allocation-mb 2. driver内存 对于drvier的内存配置，当然也包括两个参数。 spark.driver.memoryOverhead 每个driver能从yarn申请的堆外内存的大小。 spark.driver.memory 当运行hive on spark的时候，每个spark driver能申请的最大jvm 堆内存。该参数结合&nbsp;spark.driver.memoryOverhead共同决定着driver的内存大小。 driver的内存大小并不直接影响性能，但是也不要job的运行受限于driver的内存. 这里给出spark driver内存申请的方案，假设yarn.nodemanager.resource.memory-mb是 X。 driver内存申请12GB，假设 X &gt; 50GB driver内存申请 4GB，假设 12GB &lt; X &lt;50GB driver内存申请1GB,假设 1GB &lt; X &lt; 12 GB driver内存申请256MB，假设 X &lt; 1GB 这些数值是&nbsp;spark.driver.memory和&nbsp;spark.driver.memoryOverhead内存的总和。对外内存站总内存的10%-15%。 假设&nbsp;yarn.nodemanager.resource.memory-mb=100*1024MB,那么driver内存设置为12GB，此时&nbsp;spark.driver.memory=10.5gb和spark.driver.memoryOverhead=1.5gb 注意，资源多少直接对应的是数据量的大小。所以要结合资源和数据量进行适当缩减和增加。 3. executor数 executor的数目是由每个节点运行的executor数目和集群的节点数共同决定。如果你有四十个节点，那么hive可以使用的最大executor数就是 280(40*7). 最大数目可能比这个小点，因为driver也会消耗1core和12GB。 当前假设是没有yarn应用在跑。 Hive性能与用于运行查询的executor数量直接相关。 但是，不通查询还是不通。 通常，性能与executor的数量成比例。 例如，查询使用四个executor大约需要使用两个executor的一半时间。 但是，性能在一定数量的executor中达到峰值，高于此值时，增加数量不会改善性能并且可能产生不利影响。 在大多数情况下，使用一半的集群容量（executor数量的一半）可以提供良好的性能。 为了获得最佳性能，最好使用所有可用的executor。 例如，设置spark.executor.instances = 280。 对于基准测试和性能测量，强烈建议这样做。 4. 动态executor申请 虽然将spark.executor.instances设置为最大值通常可以最大限度地提高性能，但不建议在多个用户运行Hive查询的生产环境中这样做。 避免为用户会话分配固定数量的executor，因为如果executor空闲，executor不能被其他用户查询使用。 在生产环境中，应该好好计划executor分配，以允许更多的资源共享。 Spark允许您根据工作负载动态扩展分配给Spark应用程序的集群资源集。 要启用动态分配，请按照动态分配中的步骤进行操作。 除了在某些情况下，强烈建议启用动态分配。 5. 并行度 要使可用的executor得到充分利用，必须同时运行足够的任务（并行）。在大多数情况下，Hive会自动确定并行度，但也可以在调优并发度方面有一些控制权。 在输入端，map任务的数量等于输入格式生成的split数。对于Hive on Spark，输入格式为CombineHiveInputFormat，它可以根据需要对基础输入格式生成的split进行分组。 可以更好地控制stage边界的并行度。调整hive.exec.reducers.bytes.per.reducer以控制每个reducer处理的数据量，Hive根据可用的executor，执行程序内存，以及其他因素来确定最佳分区数。 实验表明，只要生成足够的任务来保持所有可用的executor繁忙，Spark就比MapReduce对hive.exec.reducers.bytes.per.reducer指定的值敏感度低。 为获得最佳性能，请为该属性选择一个值，以便Hive生成足够的任务以完全使用所有可用的executor。 hive配置 Hive on spark 共享了很多hive性能相关的配置。可以像调优hive on mapreduce一样调优hive on spark。 然而，hive.auto.convert.join.noconditionaltask.size是基于统计信息将基础join转化为map join的阈值，可能会对性能产生重大影响。 尽管该配置可以用hive on mr和hive on spark，但是两者的解释不同。 数据的大小有两个统计指标： totalSize- 数据在磁盘上的近似大小。 rawDataSize- 数据在内存中的近似大小。 hive on mr用的是totalSize。hive on spark使用的是rawDataSize。由于可能存在压缩和序列化，这两个值会有较大的差别。 对于hive on spark 需要将&nbsp;hive.auto.convert.join.noconditionaltask.size指定为更大的值，才能将与hive on mr相同的join转化为map join。 可以增加此参数的值，以使地图连接转换更具凶猛。 将common join 转换为 map join 可以提高性能。 如果此值设置得太大，则来自小表的数据将使用过多内存，任务可能会因内存不足而失败。 根据群集环境调整此值。 通过参数&nbsp;hive.stats.collect.rawdatasize&nbsp;可以控制是否收集 rawDataSize 统计信息。 对于hiveserver2，建议再配置两个额外的参数:&nbsp;hive.stats.fetch.column.stats=true&nbsp;和&nbsp;hive.optimize.index.filter=true. Hive性能调优通常建议使用以下属性： hive.optimize.reducededuplication.min.reducer=4hive.optimize.reducededuplication=truehive.merge.mapfiles=truehive.merge.mapredfiles=falsehive.merge.smallfiles.avgsize=16000000hive.merge.size.per.task=256000000hive.merge.sparkfiles=truehive.auto.convert.join=truehive.auto.convert.join.noconditionaltask=truehive.auto.convert.join.noconditionaltask.size=20M(might need to increase for Spark, 200M)hive.optimize.bucketmapjoin.sortedmerge=falsehive.map.aggr.hash.percentmemory=0.5hive.map.aggr=truehive.optimize.sort.dynamic.partition=falsehive.stats.autogather=truehive.stats.fetch.column.stats=truehive.compute.query.using.stats=truehive.limit.pushdown.memory.usage=0.4 (MR and Spark)hive.optimize.index.filter=truehive.exec.reducers.bytes.per.reducer=67108864hive.smbjoin.cache.rows=10000hive.fetch.task.conversion=morehive.fetch.task.conversion.threshold=1073741824hive.optimize.ppd=true 预启动YARN容器 在开始新会话后提交第一个查询时，在查看查询开始之前可能会遇到稍长的延迟。还会注意到，如果再次运行相同的查询，它的完成速度比第一个快得多。 Spark执行程序需要额外的时间来启动和初始化yarn上的Spark，这会导致较长的延迟。此外，Spark不会等待所有executor在启动作业之前全部启动完成，因此在将作业提交到群集后，某些executor可能仍在启动。 但是，对于在Spark上运行的作业，作业提交时可用executor的数量部分决定了reducer的数量。当就绪executor的数量未达到最大值时，作业可能没有最大并行度。这可能会进一步影响第一个查询的性能。 在用户较长期会话中，这个额外时间不会导致任何问题，因为它只在第一次查询执行时发生。然而，诸如Oozie发起的Hive工作之类的短期绘画可能无法实现最佳性能。 为减少启动时间，可以在作业开始前启用容器预热。只有在请求的executor准备就绪时，作业才会开始运行。这样，在reduce那一侧不会减少短会话的并行性。 要启用预热功能，请在发出查询之前将hive.prewarm.enabled设置为true。还可以通过设置hive.prewarm.numcontainers来设置容器数量。默认值为10。 预热的executor的实际数量受spark.executor.instances（静态分配）或spark.dynamicAllocation.maxExecutors（动态分配）的值限制。&nbsp;hive.prewarm.numcontainers的值不应超过分配给用户会话的值。 注意：预热需要几秒钟，对于短会话来说是一个很好的做法，特别是如果查询涉及reduce阶段。 但是，如果hive.prewarm.numcontainers的值高于群集中可用的值，则该过程最多可能需要30秒。 请谨慎使用预热。 [完]&nbsp; 推荐阅读： Hive性能优化（全面） 干货:Flink+Kafka 0.11端到端精确一次处理语义实现" />
<link rel="canonical" href="https://mlh.app/2019/04/08/728268.html" />
<meta property="og:url" content="https://mlh.app/2019/04/08/728268.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-08T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/rlnLo2pNEfx9c/article/details/89117446 微信交流群里有人问浪尖hive on spark如何调优，当时浪尖时间忙没时间回答，这里就给出一篇文章详细聊聊。强调一下资源设置调优，这个强经验性质的，这里给出的数值比例仅供参考。 hive on spark 性能远比hive on mr 要好，而且提供了一样的功能。用户的sql无需修改就可以直接运行于hive on spark。 udf函数也是全部支持。 本文主要是想讲hive on spark 在运行于yarn模式的情况下如何调优。 下文举例讲解的yarn节点机器配置，假设有32核，120GB内存。 yarn配置 yarn.nodemanager.resource.cpu-vcores和yarn.nodemanager.resource.memory-mb,这两个参数决定这集群资源管理器能够有多少资源用于运行yarn上的任务。 这两个参数的值是由机器的配置及同时在机器上运行的其它进程共同决定。本文假设仅有hdfs的datanode和yarn的nodemanager运行于该节点。 1. 配置cores 基本配置是datanode和nodemanager各一个核，操作系统两个核，然后剩下28核配置作为yarn资源。也即是yarn.nodemanager.resource.cpu-vcores=28&nbsp; 2. 配置内存&nbsp; 对于内存，预留20GB给操作系统，datanode，nodemanager，剩余100GB作为yarn资源。也即是&nbsp;yarn.nodemanager.resource.memory-mb=100*1024 spark配置 给yarn分配资源以后，那就要想着spark如何使用这些资源了，主要配置对象： execurtor 和driver内存，executro配额，并行度。 1. executor内存 设置executor内存需要考虑如下因素: executor内存越多，越能为更多的查询提供map join的优化。由于垃圾回收的压力会导致开销增加。 某些情况下hdfs的 客户端不能很好的处理并发写入，所以过多的核心可能会导致竞争。 为了最大化使用core，建议将core设置为4，5，6（多核心会导致并发问题，所以写代码的时候尤其是静态的链接等要考虑并发问题）具体分配核心数要结合yarn所提供的核心数。 由于本文中涉及到的node节点是28核，那么很明显分配为4的化可以被整除，spark.executor.cores设置为4 不会有多余的核剩下,设置为5，6都会有core剩余。&nbsp;spark.executor.cores=4，由于总共有28个核，那么最大可以申请的executor数是7。总内存处以7，也即是 100/7，可以得到每个executor约14GB内存。 要知道&nbsp;spark.executor.memory&nbsp;和spark.executor.memoryOverhead&nbsp;共同决定着 executor内存。建议&nbsp;spark.executor.memoryOverhead站总内存的 15%-20%。 那么最终&nbsp;spark.executor.memoryOverhead=2 G&nbsp;和spark.executor.memory=12 G 根据上面的配置的化，每个主机就可以申请7个executor，每个executor可以运行4个任务，每个core一个task。那么每个task的平均内存是 14/4 = 3.5GB。在executor运行的task共享内存。 其实，executor内部是用newCachedThreadPool运行task的。 确保&nbsp;spark.executor.memoryOverhead和&nbsp;spark.executor.memory的和不超过yarn.scheduler.maximum-allocation-mb 2. driver内存 对于drvier的内存配置，当然也包括两个参数。 spark.driver.memoryOverhead 每个driver能从yarn申请的堆外内存的大小。 spark.driver.memory 当运行hive on spark的时候，每个spark driver能申请的最大jvm 堆内存。该参数结合&nbsp;spark.driver.memoryOverhead共同决定着driver的内存大小。 driver的内存大小并不直接影响性能，但是也不要job的运行受限于driver的内存. 这里给出spark driver内存申请的方案，假设yarn.nodemanager.resource.memory-mb是 X。 driver内存申请12GB，假设 X &gt; 50GB driver内存申请 4GB，假设 12GB &lt; X &lt;50GB driver内存申请1GB,假设 1GB &lt; X &lt; 12 GB driver内存申请256MB，假设 X &lt; 1GB 这些数值是&nbsp;spark.driver.memory和&nbsp;spark.driver.memoryOverhead内存的总和。对外内存站总内存的10%-15%。 假设&nbsp;yarn.nodemanager.resource.memory-mb=100*1024MB,那么driver内存设置为12GB，此时&nbsp;spark.driver.memory=10.5gb和spark.driver.memoryOverhead=1.5gb 注意，资源多少直接对应的是数据量的大小。所以要结合资源和数据量进行适当缩减和增加。 3. executor数 executor的数目是由每个节点运行的executor数目和集群的节点数共同决定。如果你有四十个节点，那么hive可以使用的最大executor数就是 280(40*7). 最大数目可能比这个小点，因为driver也会消耗1core和12GB。 当前假设是没有yarn应用在跑。 Hive性能与用于运行查询的executor数量直接相关。 但是，不通查询还是不通。 通常，性能与executor的数量成比例。 例如，查询使用四个executor大约需要使用两个executor的一半时间。 但是，性能在一定数量的executor中达到峰值，高于此值时，增加数量不会改善性能并且可能产生不利影响。 在大多数情况下，使用一半的集群容量（executor数量的一半）可以提供良好的性能。 为了获得最佳性能，最好使用所有可用的executor。 例如，设置spark.executor.instances = 280。 对于基准测试和性能测量，强烈建议这样做。 4. 动态executor申请 虽然将spark.executor.instances设置为最大值通常可以最大限度地提高性能，但不建议在多个用户运行Hive查询的生产环境中这样做。 避免为用户会话分配固定数量的executor，因为如果executor空闲，executor不能被其他用户查询使用。 在生产环境中，应该好好计划executor分配，以允许更多的资源共享。 Spark允许您根据工作负载动态扩展分配给Spark应用程序的集群资源集。 要启用动态分配，请按照动态分配中的步骤进行操作。 除了在某些情况下，强烈建议启用动态分配。 5. 并行度 要使可用的executor得到充分利用，必须同时运行足够的任务（并行）。在大多数情况下，Hive会自动确定并行度，但也可以在调优并发度方面有一些控制权。 在输入端，map任务的数量等于输入格式生成的split数。对于Hive on Spark，输入格式为CombineHiveInputFormat，它可以根据需要对基础输入格式生成的split进行分组。 可以更好地控制stage边界的并行度。调整hive.exec.reducers.bytes.per.reducer以控制每个reducer处理的数据量，Hive根据可用的executor，执行程序内存，以及其他因素来确定最佳分区数。 实验表明，只要生成足够的任务来保持所有可用的executor繁忙，Spark就比MapReduce对hive.exec.reducers.bytes.per.reducer指定的值敏感度低。 为获得最佳性能，请为该属性选择一个值，以便Hive生成足够的任务以完全使用所有可用的executor。 hive配置 Hive on spark 共享了很多hive性能相关的配置。可以像调优hive on mapreduce一样调优hive on spark。 然而，hive.auto.convert.join.noconditionaltask.size是基于统计信息将基础join转化为map join的阈值，可能会对性能产生重大影响。 尽管该配置可以用hive on mr和hive on spark，但是两者的解释不同。 数据的大小有两个统计指标： totalSize- 数据在磁盘上的近似大小。 rawDataSize- 数据在内存中的近似大小。 hive on mr用的是totalSize。hive on spark使用的是rawDataSize。由于可能存在压缩和序列化，这两个值会有较大的差别。 对于hive on spark 需要将&nbsp;hive.auto.convert.join.noconditionaltask.size指定为更大的值，才能将与hive on mr相同的join转化为map join。 可以增加此参数的值，以使地图连接转换更具凶猛。 将common join 转换为 map join 可以提高性能。 如果此值设置得太大，则来自小表的数据将使用过多内存，任务可能会因内存不足而失败。 根据群集环境调整此值。 通过参数&nbsp;hive.stats.collect.rawdatasize&nbsp;可以控制是否收集 rawDataSize 统计信息。 对于hiveserver2，建议再配置两个额外的参数:&nbsp;hive.stats.fetch.column.stats=true&nbsp;和&nbsp;hive.optimize.index.filter=true. Hive性能调优通常建议使用以下属性： hive.optimize.reducededuplication.min.reducer=4hive.optimize.reducededuplication=truehive.merge.mapfiles=truehive.merge.mapredfiles=falsehive.merge.smallfiles.avgsize=16000000hive.merge.size.per.task=256000000hive.merge.sparkfiles=truehive.auto.convert.join=truehive.auto.convert.join.noconditionaltask=truehive.auto.convert.join.noconditionaltask.size=20M(might need to increase for Spark, 200M)hive.optimize.bucketmapjoin.sortedmerge=falsehive.map.aggr.hash.percentmemory=0.5hive.map.aggr=truehive.optimize.sort.dynamic.partition=falsehive.stats.autogather=truehive.stats.fetch.column.stats=truehive.compute.query.using.stats=truehive.limit.pushdown.memory.usage=0.4 (MR and Spark)hive.optimize.index.filter=truehive.exec.reducers.bytes.per.reducer=67108864hive.smbjoin.cache.rows=10000hive.fetch.task.conversion=morehive.fetch.task.conversion.threshold=1073741824hive.optimize.ppd=true 预启动YARN容器 在开始新会话后提交第一个查询时，在查看查询开始之前可能会遇到稍长的延迟。还会注意到，如果再次运行相同的查询，它的完成速度比第一个快得多。 Spark执行程序需要额外的时间来启动和初始化yarn上的Spark，这会导致较长的延迟。此外，Spark不会等待所有executor在启动作业之前全部启动完成，因此在将作业提交到群集后，某些executor可能仍在启动。 但是，对于在Spark上运行的作业，作业提交时可用executor的数量部分决定了reducer的数量。当就绪executor的数量未达到最大值时，作业可能没有最大并行度。这可能会进一步影响第一个查询的性能。 在用户较长期会话中，这个额外时间不会导致任何问题，因为它只在第一次查询执行时发生。然而，诸如Oozie发起的Hive工作之类的短期绘画可能无法实现最佳性能。 为减少启动时间，可以在作业开始前启用容器预热。只有在请求的executor准备就绪时，作业才会开始运行。这样，在reduce那一侧不会减少短会话的并行性。 要启用预热功能，请在发出查询之前将hive.prewarm.enabled设置为true。还可以通过设置hive.prewarm.numcontainers来设置容器数量。默认值为10。 预热的executor的实际数量受spark.executor.instances（静态分配）或spark.dynamicAllocation.maxExecutors（动态分配）的值限制。&nbsp;hive.prewarm.numcontainers的值不应超过分配给用户会话的值。 注意：预热需要几秒钟，对于短会话来说是一个很好的做法，特别是如果查询涉及reduce阶段。 但是，如果hive.prewarm.numcontainers的值高于群集中可用的值，则该过程最多可能需要30秒。 请谨慎使用预热。 [完]&nbsp; 推荐阅读： Hive性能优化（全面） 干货:Flink+Kafka 0.11端到端精确一次处理语义实现","@type":"BlogPosting","url":"https://mlh.app/2019/04/08/728268.html","headline":"戳破 hive on spark 调优点","dateModified":"2019-04-08T00:00:00+08:00","datePublished":"2019-04-08T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/08/728268.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>戳破 | hive on spark 调优点</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/rlnLo2pNEfx9c/article/details/89117446 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="rich_media_content" id="js_content"> 
   <img style="vertical-align:top;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/cZkI8M0nbClYCYIkqfrY3jKxllBevUDd5tXcheeGtYr8aRQpSZTS7fncO0z5lyibEZI7v8YjVHkTXa79OYCZdqQ/640?wx_fmt=png" alt="640?wx_fmt=png">
   <span style="width:100px;"></span>
   <span style="width:80px;"></span>
   <p style="margin-left:auto;text-align:left;font-size:14px;color:rgb(102,102,102);line-height:1.5;">微信交流群里有人问浪尖hive on spark如何调优，当时浪尖时间忙没时间回答，这里就给出一篇文章详细聊聊。强调一下资源设置调优，这个强经验性质的，这里给出的数值比例仅供参考。</p>
   <span style="width:100px;margin-left:-10px;"></span>
   <span style="width:80px;"></span>
   <img style="vertical-align:top;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/cZkI8M0nbClYCYIkqfrY3jKxllBevUDdxOq06gyribibH9twuLMzRTeJWxqepiawF1VTZcLYub1wnWQic3lrqRrSiaw/640?wx_fmt=png" alt="640?wx_fmt=png">
   <p style="margin-left:1em;"><br></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">hive on spark 性能远比hive on mr 要好，而且提供了一样的功能。用户的sql无需修改就可以直接运行于hive on spark。 udf函数也是全部支持。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">本文主要是想讲hive on spark 在运行于yarn模式的情况下如何调优。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">下文举例讲解的yarn节点机器配置，假设有32核，120GB内存。</span></p>
   <img style="width:80px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPgQ1OsgaP0iaM2iaUqyHW5WSDNHVkkrpriboBDrogCqa4GIR4nsNRibTTEue7PRJoL2QPbgWXdSCfuzMQ/640?wx_fmt=png" alt="640?wx_fmt=png">
   <span style="font-size:15px;">yarn配置</span>
   <p style="margin-left:1em;"><br></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">yarn.nodemanager.resource.cpu-vcores和yarn.nodemanager.resource.memory-mb,这两个参数决定这集群资源管理器能够有多少资源用于运行yarn上的任务。 这两个参数的值是由机器的配置及同时在机器上运行的其它进程共同决定。本文假设仅有hdfs的datanode和yarn的nodemanager运行于该节点。</span><br></p>
   <p style="line-height:1.75em;"><strong><span style="font-size:14px;letter-spacing:1px;">1. 配置cores</span></strong></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">基本配置是datanode和nodemanager各一个核，操作系统两个核，然后剩下28核配置作为yarn资源。也即是yarn.nodemanager.resource.cpu-vcores=28&nbsp;</span></p>
   <p style="line-height:1.75em;"><strong><span style="font-size:14px;letter-spacing:1px;">2. 配置内存&nbsp;</span></strong></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">对于内存，预留20GB给操作系统，datanode，nodemanager，剩余100GB作为yarn资源。也即是&nbsp;yarn.nodemanager.resource.memory-mb=100*1024</span></p>
   <img style="width:80px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPgQ1OsgaP0iaM2iaUqyHW5WSDNHVkkrpriboBDrogCqa4GIR4nsNRibTTEue7PRJoL2QPbgWXdSCfuzMQ/640?wx_fmt=png" alt="640?wx_fmt=png">
   <span style="font-size:15px;">spark配置</span>
   <p style="margin-left:1em;"><br></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">给yarn分配资源以后，那就要想着spark如何使用这些资源了，主要配置对象：</span><br></p>
   <p style="line-height:1.75em;"><span style="letter-spacing:1px;"><strong><span style="letter-spacing:1px;font-size:14px;">execurtor 和driver内存，executro配额，并行度</span></strong></span><span style="letter-spacing:1px;"><strong><span style="letter-spacing:1px;font-size:14px;">。</span></strong></span></p>
   <p style="line-height:1.75em;"><strong><span style="font-size:14px;letter-spacing:1px;">1. executor内存</span></strong></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">设置executor内存需要考虑如下因素:</span></p>
   <ul style="margin-left:1em;" class="list-paddingleft-2">
    <li><p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">executor内存越多，越能为更多的查询提供map join的优化。由于垃圾回收的压力会导致开销增加。</span></p></li>
    <li><p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">某些情况下hdfs的 客户端不能很好的处理并发写入，所以过多的核心可能会导致竞争。</span></p></li>
   </ul>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">为了最大化使用core，建议将core设置为4，5，6（多核心会导致并发问题，所以写代码的时候尤其是静态的链接等要考虑并发问题）具体分配核心数要结合yarn所提供的核心数。 由于本文中涉及到的node节点是28核，那么很明显分配为4的化可以被整除，spark.executor.cores设置为4 不会有多余的核剩下,设置为5，6都会有core剩余。&nbsp;spark.executor.cores=4，由于总共有28个核，那么最大可以申请的executor数是7。总内存处以7，也即是 100/7，可以得到每个executor约14GB内存。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">要知道&nbsp;spark.executor.memory&nbsp;和spark.executor.memoryOverhead&nbsp;共同决定着 executor内存。建议&nbsp;spark.executor.memoryOverhead站总内存的 15%-20%。 那么最终&nbsp;spark.executor.memoryOverhead=2 G&nbsp;和spark.executor.memory=12 G</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">根据上面的配置的化，每个主机就可以申请7个executor，每个executor可以运行4个任务，每个core一个task。那么每个task的平均内存是 14/4 = 3.5GB。在executor运行的task共享内存。 其实，executor内部是用newCachedThreadPool运行task的。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">确保&nbsp;spark.executor.memoryOverhead和&nbsp;spark.executor.memory的和不超过yarn.scheduler.maximum-allocation-mb</span></p>
   <p style="line-height:1.75em;"><strong><span style="font-size:14px;letter-spacing:1px;">2. driver内存</span></strong></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">对于drvier的内存配置，当然也包括两个参数。</span></p>
   <ul style="margin-left:1em;" class="list-paddingleft-2">
    <li><p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">spark.driver.memoryOverhead 每个driver能从yarn申请的堆外内存的大小。</span></p></li>
    <li><p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">spark.driver.memory 当运行hive on spark的时候，每个spark driver能申请的最大jvm 堆内存。该参数结合&nbsp;spark.driver.memoryOverhead共同决定着driver的内存大小。</span></p></li>
   </ul>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">driver的内存大小并不直接影响性能，但是也不要job的运行受限于driver的内存. 这里给出spark driver内存申请的方案，假设yarn.nodemanager.resource.memory-mb是 X。</span></p>
   <ul style="margin-left:1em;" class="list-paddingleft-2">
    <li><p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">driver内存申请12GB，假设 X &gt; 50GB</span></p></li>
    <li><p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">driver内存申请 4GB，假设 12GB &lt; X &lt;50GB</span></p></li>
    <li><p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">driver内存申请1GB,假设 1GB &lt; X &lt; 12 GB</span></p></li>
    <li><p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">driver内存申请256MB，假设 X &lt; 1GB</span></p></li>
   </ul>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">这些数值是&nbsp;spark.driver.memory和&nbsp;spark.driver.memoryOverhead内存的总和。对外内存站总内存的10%-15%。 假设&nbsp;yarn.nodemanager.resource.memory-mb=100*1024MB,那么driver内存设置为12GB，此时&nbsp;spark.driver.memory=10.5gb和spark.driver.memoryOverhead=1.5gb</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">注意，资源多少直接对应的是数据量的大小。所以要结合资源和数据量进行适当缩减和增加。</span></p>
   <p style="line-height:1.75em;"><strong><span style="font-size:14px;letter-spacing:1px;">3. executor数</span></strong></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">executor的数目是由每个节点运行的executor数目和集群的节点数共同决定。如果你有四十个节点，那么hive可以使用的最大executor数就是 280(40*7). 最大数目可能比这个小点，因为driver也会消耗1core和12GB。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">当前假设是没有yarn应用在跑。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">Hive性能与用于运行查询的executor数量直接相关。 但是，不通查询还是不通。 通常，性能与executor的数量成比例。 例如，查询使用四个executor大约需要使用两个executor的一半时间。 但是，性能在一定数量的executor中达到峰值，高于此值时，增加数量不会改善性能并且可能产生不利影响。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">在大多数情况下，使用一半的集群容量（executor数量的一半）可以提供良好的性能。 为了获得最佳性能，最好使用所有可用的executor。 例如，设置spark.executor.instances = 280。 对于基准测试和性能测量，强烈建议这样做。</span></p>
   <p style="line-height:1.75em;"><strong><span style="font-size:14px;letter-spacing:1px;">4. 动态executor申请</span></strong></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">虽然将spark.executor.instances设置为最大值通常可以最大限度地提高性能，但不建议在多个用户运行Hive查询的生产环境中这样做。 避免为用户会话分配固定数量的executor，因为如果executor空闲，executor不能被其他用户查询使用。 在生产环境中，应该好好计划executor分配，以允许更多的资源共享。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">Spark允许您根据工作负载动态扩展分配给Spark应用程序的集群资源集。 要启用动态分配，请按照动态分配中的步骤进行操作。 除了在某些情况下，强烈建议启用动态分配。</span></p>
   <p style="line-height:1.75em;"><strong><span style="font-size:14px;letter-spacing:1px;">5. 并行度</span></strong></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">要使可用的executor得到充分利用，必须同时运行足够的任务（并行）。在大多数情况下，Hive会自动确定并行度，但也可以在调优并发度方面有一些控制权。 在输入端，map任务的数量等于输入格式生成的split数。对于Hive on Spark，输入格式为CombineHiveInputFormat，它可以根据需要对基础输入格式生成的split进行分组。 可以更好地控制stage边界的并行度。调整hive.exec.reducers.bytes.per.reducer以控制每个reducer处理的数据量，Hive根据可用的executor，执行程序内存，以及其他因素来确定最佳分区数。 实验表明，只要生成足够的任务来保持所有可用的executor繁忙，Spark就比MapReduce对hive.exec.reducers.bytes.per.reducer指定的值敏感度低。 为获得最佳性能，请为该属性选择一个值，以便Hive生成足够的任务以完全使用所有可用的executor。</span></p>
   <img style="width:80px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPgQ1OsgaP0iaM2iaUqyHW5WSDNHVkkrpriboBDrogCqa4GIR4nsNRibTTEue7PRJoL2QPbgWXdSCfuzMQ/640?wx_fmt=png" alt="640?wx_fmt=png">
   <span style="font-size:15px;">hive配置</span>
   <p style="margin-left:1em;"><br></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">Hive on spark 共享了很多hive性能相关的配置。可以像调优hive on mapreduce一样调优hive on spark。 然而，hive.auto.convert.join.noconditionaltask.size是基于统计信息将基础join转化为map join的阈值，可能会对性能产生重大影响。 尽管该配置可以用hive on mr和hive on spark，但是两者的解释不同。</span><br></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">数据的大小有两个统计指标：</span></p>
   <ul style="margin-left:1em;" class="list-paddingleft-2">
    <li><p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">totalSize- 数据在磁盘上的近似大小。</span></p></li>
    <li><p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">rawDataSize- 数据在内存中的近似大小。</span></p></li>
   </ul>
   <p style="line-height:1.75em;"><span><strong><span style="font-size:14px;letter-spacing:1px;">hive on mr用的是totalSize。hive on spark使用的是rawDataSize</span></strong></span><span style="font-size:14px;letter-spacing:1px;">。由于可能存在压缩和序列化，这两个值会有较大的差别。 对于hive on spark 需要将&nbsp;hive.auto.convert.join.noconditionaltask.size指定为更大的值，才能将与hive on mr相同的join转化为map join。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">可以增加此参数的值，以使地图连接转换更具凶猛。 将common join 转换为 map join 可以提高性能。 如果此值设置得太大，则来自小表的数据将使用过多内存，任务可能会因内存不足而失败。 根据群集环境调整此值。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">通过参数&nbsp;hive.stats.collect.rawdatasize&nbsp;可以控制是否收集 rawDataSize 统计信息。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">对于hiveserver2，建议再配置两个额外的参数:&nbsp;hive.stats.fetch.column.stats=true&nbsp;和&nbsp;hive.optimize.index.filter=true.</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">Hive性能调优通常建议使用以下属性：</span></p>
   <pre style="background:none;"></pre>
   <p style="font-size:.85em;background:rgb(40,44,52);color:rgb(171,178,191);line-height:1.75em;"><span style="letter-spacing:1px;">hive.optimize.reducededuplication.min.reducer=<span class="hljs-default-number" style="letter-spacing:1px;color:rgb(209,154,102);background:rgba(0,0,0,0);width:6px;font-weight:400;font-style:normal;">4</span><br>hive.optimize.reducededuplication=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">true</span><br>hive.merge.mapfiles=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">true</span><br>hive.merge.mapredfiles=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:33px;font-weight:400;font-style:normal;">false</span><br>hive.merge.smallfiles.avgsize=<span class="hljs-default-number" style="letter-spacing:1px;color:rgb(209,154,102);background:rgba(0,0,0,0);width:52px;font-weight:400;font-style:normal;">16000000</span><br>hive.merge.size.per.task=<span class="hljs-default-number" style="letter-spacing:1px;color:rgb(209,154,102);background:rgba(0,0,0,0);width:59px;font-weight:400;font-style:normal;">256000000</span><br>hive.merge.sparkfiles=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">true</span><br>hive.<span class="hljs-default-keyword" style="letter-spacing:1px;color:rgb(198,120,221);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">auto</span>.convert.join=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">true</span><br>hive.<span class="hljs-default-keyword" style="letter-spacing:1px;color:rgb(198,120,221);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">auto</span>.convert.join.noconditionaltask=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">true</span><br>hive.<span class="hljs-default-keyword" style="letter-spacing:1px;color:rgb(198,120,221);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">auto</span>.convert.join.noconditionaltask.size=<span class="hljs-default-number" style="letter-spacing:1px;color:rgb(209,154,102);background:rgba(0,0,0,0);width:13px;font-weight:400;font-style:normal;">20</span>M(might need to increase <span class="hljs-default-keyword" style="letter-spacing:1px;color:rgb(198,120,221);background:rgba(0,0,0,0);width:20px;font-weight:400;font-style:normal;">for</span> Spark, <span class="hljs-default-number" style="letter-spacing:1px;color:rgb(209,154,102);background:rgba(0,0,0,0);width:20px;font-weight:400;font-style:normal;">200</span>M)<br>hive.optimize.bucketmapjoin.sortedmerge=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:33px;font-weight:400;font-style:normal;">false</span><br>hive.<span class="hljs-default-built_in" style="letter-spacing:1px;color:rgb(230,192,123);background:rgba(0,0,0,0);width:19px;font-weight:400;font-style:normal;">map</span>.aggr.hash.percentmemory=<span class="hljs-default-number" style="letter-spacing:1px;color:rgb(209,154,102);background:rgba(0,0,0,0);width:20px;font-weight:400;font-style:normal;">0.5</span><br>hive.<span class="hljs-default-built_in" style="letter-spacing:1px;color:rgb(230,192,123);background:rgba(0,0,0,0);width:19px;font-weight:400;font-style:normal;">map</span>.aggr=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">true</span><br>hive.optimize.sort.dynamic.partition=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:33px;font-weight:400;font-style:normal;">false</span><br>hive.stats.autogather=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">true</span><br>hive.stats.fetch.column.stats=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">true</span><br>hive.compute.query.<span class="hljs-default-keyword" style="letter-spacing:1px;color:rgb(198,120,221);background:rgba(0,0,0,0);width:33px;font-weight:400;font-style:normal;">using</span>.stats=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">true</span><br>hive.limit.pushdown.memory.usage=<span class="hljs-default-number" style="letter-spacing:1px;color:rgb(209,154,102);background:rgba(0,0,0,0);width:20px;font-weight:400;font-style:normal;">0.4</span> (MR <span class="hljs-default-keyword" style="letter-spacing:1px;color:rgb(198,120,221);background:rgba(0,0,0,0);width:19px;font-weight:400;font-style:normal;">and</span> Spark)<br>hive.optimize.index.filter=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">true</span><br>hive.exec.reducers.bytes.per.reducer=<span class="hljs-default-number" style="letter-spacing:1px;color:rgb(209,154,102);background:rgba(0,0,0,0);width:53px;font-weight:400;font-style:normal;">67108864</span><br>hive.smbjoin.cache.rows=<span class="hljs-default-number" style="letter-spacing:1px;color:rgb(209,154,102);background:rgba(0,0,0,0);width:33px;font-weight:400;font-style:normal;">10000</span><br>hive.fetch.task.conversion=more<br>hive.fetch.task.conversion.threshold=<span class="hljs-default-number" style="letter-spacing:1px;color:rgb(209,154,102);background:rgba(0,0,0,0);width:66px;font-weight:400;font-style:normal;">1073741824</span><br>hive.optimize.ppd=<span class="hljs-default-literal" style="letter-spacing:1px;color:rgb(86,182,194);background:rgba(0,0,0,0);width:26px;font-weight:400;font-style:normal;">true</span></span></p>
   <p style="margin-left:1em;"><br></p>
   <img style="width:80px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPgQ1OsgaP0iaM2iaUqyHW5WSDNHVkkrpriboBDrogCqa4GIR4nsNRibTTEue7PRJoL2QPbgWXdSCfuzMQ/640?wx_fmt=png" alt="640?wx_fmt=png">
   <span style="font-size:15px;">预启动YARN容器</span>
   <p style="margin-left:1em;"><br></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">在开始新会话后提交第一个查询时，在查看查询开始之前可能会遇到稍长的延迟。还会注意到，如果再次运行相同的查询，它的完成速度比第一个快得多。</span><br></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">Spark执行程序需要额外的时间来启动和初始化yarn上的Spark，这会导致较长的延迟。此外，Spark不会等待所有executor在启动作业之前全部启动完成，因此在将作业提交到群集后，某些executor可能仍在启动。 但是，对于在Spark上运行的作业，作业提交时可用executor的数量部分决定了reducer的数量。当就绪executor的数量未达到最大值时，作业可能没有最大并行度。这可能会进一步影响第一个查询的性能。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">在用户较长期会话中，这个额外时间不会导致任何问题，因为它只在第一次查询执行时发生。然而，诸如Oozie发起的Hive工作之类的短期绘画可能无法实现最佳性能。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">为减少启动时间，可以在作业开始前启用容器预热。只有在请求的executor准备就绪时，作业才会开始运行。这样，在reduce那一侧不会减少短会话的并行性。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">要启用预热功能，请在发出查询之前将hive.prewarm.enabled设置为true。还可以通过设置hive.prewarm.numcontainers来设置容器数量。默认值为10。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">预热的executor的实际数量受spark.executor.instances（静态分配）或spark.dynamicAllocation.maxExecutors（动态分配）的值限制。&nbsp;hive.prewarm.numcontainers的值不应超过分配给用户会话的值。</span></p>
   <p style="line-height:1.75em;"><span style="font-size:14px;letter-spacing:1px;">注意：预热需要几秒钟，对于短会话来说是一个很好的做法，特别是如果查询涉及reduce阶段。 但是，如果hive.prewarm.numcontainers的值高于群集中可用的值，则该过程最多可能需要30秒。 请谨慎使用预热。</span></p>
   <p style="margin-left:1em;"><strong>[完]&nbsp;</strong></p>
   <p style="margin-left:1em;"><strong><br></strong></p>
   <p style="margin-left:1em;"><span style="font-size:14px;"><strong>推荐阅读：</strong></span></p>
   <p style="margin-left:1em;"><a href="http://mp.weixin.qq.com/s?__biz=MzA3MDY0NTMxOQ==&amp;mid=2247485140&amp;idx=1&amp;sn=dd8d05309b8e2e86b3bde6728c6932ec&amp;chksm=9f38e5fca84f6ceae8eb4791337ccfe81fc6764890100bb2cb7f7aec2ad23b1a78e1e25f56c4&amp;scene=21#wechat_redirect" rel="nofollow" style="font-size:14px;text-decoration:underline;"><span style="font-size:14px;">Hive性能优化（全面）</span></a><br></p>
   <p style="margin-left:1em;"><a href="http://mp.weixin.qq.com/s?__biz=MzA3MDY0NTMxOQ==&amp;mid=2247485150&amp;idx=1&amp;sn=ba0570a9f631501a189d8184807d518b&amp;chksm=9f38e5f6a84f6ce0dd805eae87d6c62e2c96670f14c2bac1607961614ba49f310a4630e31a3b&amp;scene=21#wechat_redirect" rel="nofollow" style="font-size:14px;text-decoration:underline;"><span style="font-size:14px;">干货:Flink+Kafka 0.11端到端精确一次处理语义实现</span></a><br></p>
   <p style="text-align:center;"><img class="rich_pages" style="width:280px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/adI0ApTVBFWF1rkKibTzeA8PicbicYXBsH26a9PXg2HNnlEt1thHBFxUtEjicACeaSlRWictpPziaMdibXmYq34dWfQ9w/640?wx_fmt=png" alt="640?wx_fmt=png"></p> 
  </div> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
