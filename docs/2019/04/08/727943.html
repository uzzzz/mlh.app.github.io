<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链技术入门——核心概念与原理 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链技术入门——核心概念与原理" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="区块链的前世今生 密码朋克（Cypherpunk）：是一个邮件组，里面有许多大牛。 比特币的底层技术： 点对点网络 时间戳 加密技术 工作量证明 可以应用到其他领域。 将这些技术提炼出来，就提出了区块链概念 区块链不是单一的技术，而是一系列技术的集合。 为何叫区块链？：因为比特币系统里的数据是用一个个区块存储的，然后通过hash的方式将一个一个区块连接，形成一个区块的链条，所以叫做区块链。 应用场景： 资产：数字资产发行、支付（跨境支付）、交易、结算 记账：股权交易、供应链金融、商业积分 不可篡改：溯源、众筹、医疗证明、存在性证明 点对点：共享经济、物联网 隐私：匿名交易 比特币是什么？ 比特币是数字货币，即虚拟货币（价值共识——信任），其总量是不变的，是两千一百万个，流通性好，全球无缝点到点流通直接到账 其信任从何而来？ 1.财产只受自己控制 2.无通货膨胀 3.没有假钞 4.流通性好 去中心化记账系统 在中心化的系统里，通常有个中央的服务器，来存储所有的数据，可以理解为就是一个数据库。 而去中心化的系统，数据不再是存储在一个服务器，而是存储于比特币网络的每一个节点里。 问题来了，如果一段时间存在节点的记账数据不一致，那么将以谁的为准呢？ 这就涉及到比特币的原理 比特币的原理？ 一、账本如何验证？ 方案一，少数服从多数（每次验证都与千百万量的账本数据核对，这个效率是非常低下，实际上是不可行的。） 方案二，Hash函数(原始信息）=摘要信息 特点：1.同样的原始信息用同一个哈希函数总能得到同样的摘要信息 2.原始信息发生微小的变化都会导致摘要信息改变 3.摘要信息不可能推导出原始信息 对一个账本原始数据进行hash得到一个hash值，与序号、时间戳构成区块的头部，加上交易记录，就是一个区块，每10分钟更新，链接一个新区块，形成时间上的区块链。 注意：在对第二个账本进行Hash时，会传入第一个账本的Hash值，和第二个账本的原始数据一起进行Hash（就是通过这种方式将块与块相连接！）。 只要区块链中最后一个区块的hash值与其他用户储存账本均一致则是正确的，则账本是正确的。 二、账户所有权问题？ 现实生活中，银行账户和密码与银行存储系统匹配，就可以进行交易。如果你的银行卡和密码都给盗了，盗贼使用你的卡进行消费。我们还可以通过银行和警察叔叔的协助，确定是盗贼使用了你的卡。 但是，在比特币系统中，交易是点到点的，没有第三方 在比特币系统中，比特币账户是一个地址，谁能用这个地址进行交易，谁就拥有这个账户的所有权。密码—&gt;私钥 注意：地址和私钥是非对称的关系，私钥经过一系列Hash运算后得到地址（付款方地址（公钥））。 由上可知，私钥和账户有着绝对确定的直接对应关系，而不能像银行卡那样再修改密码了。谁拥有了私钥，就相当于谁就拥有了这个账户，谁就可以用这个地址进行交易。所以私钥超重要，如果私钥泄露了，比特币就可能丢失。 所以所有权的问题就变成了在不泄露私钥的情况下，证明自己拥有某个地址的私钥。 （也就是验证私钥的正确性就行了）。 （这里我是这样理解的：要想证明自己拥有私钥，就要得到别人的验证，一种方法就是：你直接把密码告诉别人，就好像你把银行密码直接告诉别人，然后说：“你看吧，这个是正确的密码，不信你输入看看，可以取款的，没骗你吧。” 当然，这是傻子才会做的事。有没有不告诉别人密码，然后又可以验证的方法呢？） 这里就用到了非对称加密技术（交易签名）： 1.交易进行Hash得到交易摘要 2.用私钥对摘要进行签名 签名过程： 首先对原始交易过程进行Hash生成交易摘要，然后再用交易摘要和私钥进行一个签名运算。 然后，在签名运算之后，该节点会在整个网络进行广播——内容为原始的交易信息（包含付款方地址【公钥】）和签名信息 而最后接收到的节点又会以同样的方法进行广播，以致传递到所有节点。 验证过程： 用签名和**付款方的地址【公钥】**进行一个验证的运算，如果结果是原始交易信息的摘要（hash值），那么说明这笔交易就是私钥所有者发出的，验证通过。这时候就会把交易的信息写入到账本。然后再次进行广播‘ 签名和验证是个相反的运算，签名是个加密的过程，验证是个解密的过程。而这个付款方地址就是公钥！ 总之，签名过程即 sign{（hash（原始交易信息【包括付款方地址（公钥）】）+私钥} = 签名信息 验证过程即 verify{签名信息+付款方地址（公钥）} == 交易摘要 True（是私钥所有者发出，写入本用户账本并广播） BTC系统中没有银行机制，也就是没有除私钥外对BTC所有者进行验证的方法，只有你拥有使用该地址（账户）上的BTC的私钥，才可以证明这些BTC是你的。如果没有回收机制，会有一些BTC变成幽灵币，不再参与市场，只是维持BTC总数不变。… 三、为什么记账（挖矿）？ 记账：Hash打包过程。在比特币的设计中，完成记账是可以获得一定比特币奖励的，所以大家将记账形象的叫做——挖矿，这个奖励其实就是比特币发行的过程。 记账规则： 一段时间内只有一人可以记账成功（通常是10分钟） 通过解决密码学难题（工作量证明）竞争获得唯一记账权 其他节点则只复制结果 如果只是上述的 hash打包过程，那么每个人都可以轻松完成，而要保证一段时间内只能有一个人记账成功，就必须要故意大大提高计算的难度。 比特币规定这个计算结果要满足以若干个0开头的要求。 这时在计算hash时，就要引入一个随机数变量，不断的去改变随机数，每个都可以得到一个新的hash值，直到找一个符合以若干个0开头的hash值。我们现在的电脑要找出4个0开头的hash，一般需要1、2分钟的时间。 比特币因为现在很多人参与挖矿，算力很强大，所以将挖矿的难度设为以18个0开头。第一找到这个hash的，就可以获得唯一记帐权，这个交易记录集得到的途径： 收集广播中还没有被记录账本的交易，然后交易的有效性验证，（挖矿成功的情况下）添加一笔给自己转账的交易（挖矿奖励） 区块Hash值是16进制字符串，得到18个0的，理论上需要16的18次方次哈希运算。 18个0的计算量是非常巨大的，要非常强大的设备与消耗巨大的电力 所以现在已经没有独立的矿工进行挖矿了，因为几十年也可能挖不出一个。 因此矿工结合起来变成一个矿池，如果挖掘到比特币，按照算力来分成。 而且随着越来越多的人投入挖矿，那么计算难度必然又将加大。成本也将越来越高。最终这样作用下去，成本甚至是接近收益的。 四、共识机制 问题：如果两个节点同时(规定时间段内)完成工作量证明，使用谁的区块？ 为什么要遵守协议：节点工作量只有在其他的节点认同的情况下，其是有效的。 节点独立选择出累计工作量最大（/最长）的区块链，再以此区块链通过不断挖矿来继续延长该区块链，共识机制就是来保证此要求 由于网络的原因，出现以下情况： 有些节点收到#3458A 有些先收到#3458B 还有些同时收到#3458A和#3458B。 先收到#3458A（或B）区块的节点，以#3458A（或B）为父链，继续挖矿，但是总会收到#3458B（或A），则将3458B（或A）作为备用链，待下一工作量证明优先由哪一方完成，则这一方的区块链为累计工作量最大（最长的链 ），舍弃短链。 注意：节点有可能先收到#3479B，随后才收到#3458B，则先将前者作为孤块放入孤块池中，待收到其父块后再接收。 入门核心概念与原理 就到这告一段落" />
<meta property="og:description" content="区块链的前世今生 密码朋克（Cypherpunk）：是一个邮件组，里面有许多大牛。 比特币的底层技术： 点对点网络 时间戳 加密技术 工作量证明 可以应用到其他领域。 将这些技术提炼出来，就提出了区块链概念 区块链不是单一的技术，而是一系列技术的集合。 为何叫区块链？：因为比特币系统里的数据是用一个个区块存储的，然后通过hash的方式将一个一个区块连接，形成一个区块的链条，所以叫做区块链。 应用场景： 资产：数字资产发行、支付（跨境支付）、交易、结算 记账：股权交易、供应链金融、商业积分 不可篡改：溯源、众筹、医疗证明、存在性证明 点对点：共享经济、物联网 隐私：匿名交易 比特币是什么？ 比特币是数字货币，即虚拟货币（价值共识——信任），其总量是不变的，是两千一百万个，流通性好，全球无缝点到点流通直接到账 其信任从何而来？ 1.财产只受自己控制 2.无通货膨胀 3.没有假钞 4.流通性好 去中心化记账系统 在中心化的系统里，通常有个中央的服务器，来存储所有的数据，可以理解为就是一个数据库。 而去中心化的系统，数据不再是存储在一个服务器，而是存储于比特币网络的每一个节点里。 问题来了，如果一段时间存在节点的记账数据不一致，那么将以谁的为准呢？ 这就涉及到比特币的原理 比特币的原理？ 一、账本如何验证？ 方案一，少数服从多数（每次验证都与千百万量的账本数据核对，这个效率是非常低下，实际上是不可行的。） 方案二，Hash函数(原始信息）=摘要信息 特点：1.同样的原始信息用同一个哈希函数总能得到同样的摘要信息 2.原始信息发生微小的变化都会导致摘要信息改变 3.摘要信息不可能推导出原始信息 对一个账本原始数据进行hash得到一个hash值，与序号、时间戳构成区块的头部，加上交易记录，就是一个区块，每10分钟更新，链接一个新区块，形成时间上的区块链。 注意：在对第二个账本进行Hash时，会传入第一个账本的Hash值，和第二个账本的原始数据一起进行Hash（就是通过这种方式将块与块相连接！）。 只要区块链中最后一个区块的hash值与其他用户储存账本均一致则是正确的，则账本是正确的。 二、账户所有权问题？ 现实生活中，银行账户和密码与银行存储系统匹配，就可以进行交易。如果你的银行卡和密码都给盗了，盗贼使用你的卡进行消费。我们还可以通过银行和警察叔叔的协助，确定是盗贼使用了你的卡。 但是，在比特币系统中，交易是点到点的，没有第三方 在比特币系统中，比特币账户是一个地址，谁能用这个地址进行交易，谁就拥有这个账户的所有权。密码—&gt;私钥 注意：地址和私钥是非对称的关系，私钥经过一系列Hash运算后得到地址（付款方地址（公钥））。 由上可知，私钥和账户有着绝对确定的直接对应关系，而不能像银行卡那样再修改密码了。谁拥有了私钥，就相当于谁就拥有了这个账户，谁就可以用这个地址进行交易。所以私钥超重要，如果私钥泄露了，比特币就可能丢失。 所以所有权的问题就变成了在不泄露私钥的情况下，证明自己拥有某个地址的私钥。 （也就是验证私钥的正确性就行了）。 （这里我是这样理解的：要想证明自己拥有私钥，就要得到别人的验证，一种方法就是：你直接把密码告诉别人，就好像你把银行密码直接告诉别人，然后说：“你看吧，这个是正确的密码，不信你输入看看，可以取款的，没骗你吧。” 当然，这是傻子才会做的事。有没有不告诉别人密码，然后又可以验证的方法呢？） 这里就用到了非对称加密技术（交易签名）： 1.交易进行Hash得到交易摘要 2.用私钥对摘要进行签名 签名过程： 首先对原始交易过程进行Hash生成交易摘要，然后再用交易摘要和私钥进行一个签名运算。 然后，在签名运算之后，该节点会在整个网络进行广播——内容为原始的交易信息（包含付款方地址【公钥】）和签名信息 而最后接收到的节点又会以同样的方法进行广播，以致传递到所有节点。 验证过程： 用签名和**付款方的地址【公钥】**进行一个验证的运算，如果结果是原始交易信息的摘要（hash值），那么说明这笔交易就是私钥所有者发出的，验证通过。这时候就会把交易的信息写入到账本。然后再次进行广播‘ 签名和验证是个相反的运算，签名是个加密的过程，验证是个解密的过程。而这个付款方地址就是公钥！ 总之，签名过程即 sign{（hash（原始交易信息【包括付款方地址（公钥）】）+私钥} = 签名信息 验证过程即 verify{签名信息+付款方地址（公钥）} == 交易摘要 True（是私钥所有者发出，写入本用户账本并广播） BTC系统中没有银行机制，也就是没有除私钥外对BTC所有者进行验证的方法，只有你拥有使用该地址（账户）上的BTC的私钥，才可以证明这些BTC是你的。如果没有回收机制，会有一些BTC变成幽灵币，不再参与市场，只是维持BTC总数不变。… 三、为什么记账（挖矿）？ 记账：Hash打包过程。在比特币的设计中，完成记账是可以获得一定比特币奖励的，所以大家将记账形象的叫做——挖矿，这个奖励其实就是比特币发行的过程。 记账规则： 一段时间内只有一人可以记账成功（通常是10分钟） 通过解决密码学难题（工作量证明）竞争获得唯一记账权 其他节点则只复制结果 如果只是上述的 hash打包过程，那么每个人都可以轻松完成，而要保证一段时间内只能有一个人记账成功，就必须要故意大大提高计算的难度。 比特币规定这个计算结果要满足以若干个0开头的要求。 这时在计算hash时，就要引入一个随机数变量，不断的去改变随机数，每个都可以得到一个新的hash值，直到找一个符合以若干个0开头的hash值。我们现在的电脑要找出4个0开头的hash，一般需要1、2分钟的时间。 比特币因为现在很多人参与挖矿，算力很强大，所以将挖矿的难度设为以18个0开头。第一找到这个hash的，就可以获得唯一记帐权，这个交易记录集得到的途径： 收集广播中还没有被记录账本的交易，然后交易的有效性验证，（挖矿成功的情况下）添加一笔给自己转账的交易（挖矿奖励） 区块Hash值是16进制字符串，得到18个0的，理论上需要16的18次方次哈希运算。 18个0的计算量是非常巨大的，要非常强大的设备与消耗巨大的电力 所以现在已经没有独立的矿工进行挖矿了，因为几十年也可能挖不出一个。 因此矿工结合起来变成一个矿池，如果挖掘到比特币，按照算力来分成。 而且随着越来越多的人投入挖矿，那么计算难度必然又将加大。成本也将越来越高。最终这样作用下去，成本甚至是接近收益的。 四、共识机制 问题：如果两个节点同时(规定时间段内)完成工作量证明，使用谁的区块？ 为什么要遵守协议：节点工作量只有在其他的节点认同的情况下，其是有效的。 节点独立选择出累计工作量最大（/最长）的区块链，再以此区块链通过不断挖矿来继续延长该区块链，共识机制就是来保证此要求 由于网络的原因，出现以下情况： 有些节点收到#3458A 有些先收到#3458B 还有些同时收到#3458A和#3458B。 先收到#3458A（或B）区块的节点，以#3458A（或B）为父链，继续挖矿，但是总会收到#3458B（或A），则将3458B（或A）作为备用链，待下一工作量证明优先由哪一方完成，则这一方的区块链为累计工作量最大（最长的链 ），舍弃短链。 注意：节点有可能先收到#3479B，随后才收到#3458B，则先将前者作为孤块放入孤块池中，待收到其父块后再接收。 入门核心概念与原理 就到这告一段落" />
<link rel="canonical" href="https://mlh.app/2019/04/08/727943.html" />
<meta property="og:url" content="https://mlh.app/2019/04/08/727943.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-08T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"区块链的前世今生 密码朋克（Cypherpunk）：是一个邮件组，里面有许多大牛。 比特币的底层技术： 点对点网络 时间戳 加密技术 工作量证明 可以应用到其他领域。 将这些技术提炼出来，就提出了区块链概念 区块链不是单一的技术，而是一系列技术的集合。 为何叫区块链？：因为比特币系统里的数据是用一个个区块存储的，然后通过hash的方式将一个一个区块连接，形成一个区块的链条，所以叫做区块链。 应用场景： 资产：数字资产发行、支付（跨境支付）、交易、结算 记账：股权交易、供应链金融、商业积分 不可篡改：溯源、众筹、医疗证明、存在性证明 点对点：共享经济、物联网 隐私：匿名交易 比特币是什么？ 比特币是数字货币，即虚拟货币（价值共识——信任），其总量是不变的，是两千一百万个，流通性好，全球无缝点到点流通直接到账 其信任从何而来？ 1.财产只受自己控制 2.无通货膨胀 3.没有假钞 4.流通性好 去中心化记账系统 在中心化的系统里，通常有个中央的服务器，来存储所有的数据，可以理解为就是一个数据库。 而去中心化的系统，数据不再是存储在一个服务器，而是存储于比特币网络的每一个节点里。 问题来了，如果一段时间存在节点的记账数据不一致，那么将以谁的为准呢？ 这就涉及到比特币的原理 比特币的原理？ 一、账本如何验证？ 方案一，少数服从多数（每次验证都与千百万量的账本数据核对，这个效率是非常低下，实际上是不可行的。） 方案二，Hash函数(原始信息）=摘要信息 特点：1.同样的原始信息用同一个哈希函数总能得到同样的摘要信息 2.原始信息发生微小的变化都会导致摘要信息改变 3.摘要信息不可能推导出原始信息 对一个账本原始数据进行hash得到一个hash值，与序号、时间戳构成区块的头部，加上交易记录，就是一个区块，每10分钟更新，链接一个新区块，形成时间上的区块链。 注意：在对第二个账本进行Hash时，会传入第一个账本的Hash值，和第二个账本的原始数据一起进行Hash（就是通过这种方式将块与块相连接！）。 只要区块链中最后一个区块的hash值与其他用户储存账本均一致则是正确的，则账本是正确的。 二、账户所有权问题？ 现实生活中，银行账户和密码与银行存储系统匹配，就可以进行交易。如果你的银行卡和密码都给盗了，盗贼使用你的卡进行消费。我们还可以通过银行和警察叔叔的协助，确定是盗贼使用了你的卡。 但是，在比特币系统中，交易是点到点的，没有第三方 在比特币系统中，比特币账户是一个地址，谁能用这个地址进行交易，谁就拥有这个账户的所有权。密码—&gt;私钥 注意：地址和私钥是非对称的关系，私钥经过一系列Hash运算后得到地址（付款方地址（公钥））。 由上可知，私钥和账户有着绝对确定的直接对应关系，而不能像银行卡那样再修改密码了。谁拥有了私钥，就相当于谁就拥有了这个账户，谁就可以用这个地址进行交易。所以私钥超重要，如果私钥泄露了，比特币就可能丢失。 所以所有权的问题就变成了在不泄露私钥的情况下，证明自己拥有某个地址的私钥。 （也就是验证私钥的正确性就行了）。 （这里我是这样理解的：要想证明自己拥有私钥，就要得到别人的验证，一种方法就是：你直接把密码告诉别人，就好像你把银行密码直接告诉别人，然后说：“你看吧，这个是正确的密码，不信你输入看看，可以取款的，没骗你吧。” 当然，这是傻子才会做的事。有没有不告诉别人密码，然后又可以验证的方法呢？） 这里就用到了非对称加密技术（交易签名）： 1.交易进行Hash得到交易摘要 2.用私钥对摘要进行签名 签名过程： 首先对原始交易过程进行Hash生成交易摘要，然后再用交易摘要和私钥进行一个签名运算。 然后，在签名运算之后，该节点会在整个网络进行广播——内容为原始的交易信息（包含付款方地址【公钥】）和签名信息 而最后接收到的节点又会以同样的方法进行广播，以致传递到所有节点。 验证过程： 用签名和**付款方的地址【公钥】**进行一个验证的运算，如果结果是原始交易信息的摘要（hash值），那么说明这笔交易就是私钥所有者发出的，验证通过。这时候就会把交易的信息写入到账本。然后再次进行广播‘ 签名和验证是个相反的运算，签名是个加密的过程，验证是个解密的过程。而这个付款方地址就是公钥！ 总之，签名过程即 sign{（hash（原始交易信息【包括付款方地址（公钥）】）+私钥} = 签名信息 验证过程即 verify{签名信息+付款方地址（公钥）} == 交易摘要 True（是私钥所有者发出，写入本用户账本并广播） BTC系统中没有银行机制，也就是没有除私钥外对BTC所有者进行验证的方法，只有你拥有使用该地址（账户）上的BTC的私钥，才可以证明这些BTC是你的。如果没有回收机制，会有一些BTC变成幽灵币，不再参与市场，只是维持BTC总数不变。… 三、为什么记账（挖矿）？ 记账：Hash打包过程。在比特币的设计中，完成记账是可以获得一定比特币奖励的，所以大家将记账形象的叫做——挖矿，这个奖励其实就是比特币发行的过程。 记账规则： 一段时间内只有一人可以记账成功（通常是10分钟） 通过解决密码学难题（工作量证明）竞争获得唯一记账权 其他节点则只复制结果 如果只是上述的 hash打包过程，那么每个人都可以轻松完成，而要保证一段时间内只能有一个人记账成功，就必须要故意大大提高计算的难度。 比特币规定这个计算结果要满足以若干个0开头的要求。 这时在计算hash时，就要引入一个随机数变量，不断的去改变随机数，每个都可以得到一个新的hash值，直到找一个符合以若干个0开头的hash值。我们现在的电脑要找出4个0开头的hash，一般需要1、2分钟的时间。 比特币因为现在很多人参与挖矿，算力很强大，所以将挖矿的难度设为以18个0开头。第一找到这个hash的，就可以获得唯一记帐权，这个交易记录集得到的途径： 收集广播中还没有被记录账本的交易，然后交易的有效性验证，（挖矿成功的情况下）添加一笔给自己转账的交易（挖矿奖励） 区块Hash值是16进制字符串，得到18个0的，理论上需要16的18次方次哈希运算。 18个0的计算量是非常巨大的，要非常强大的设备与消耗巨大的电力 所以现在已经没有独立的矿工进行挖矿了，因为几十年也可能挖不出一个。 因此矿工结合起来变成一个矿池，如果挖掘到比特币，按照算力来分成。 而且随着越来越多的人投入挖矿，那么计算难度必然又将加大。成本也将越来越高。最终这样作用下去，成本甚至是接近收益的。 四、共识机制 问题：如果两个节点同时(规定时间段内)完成工作量证明，使用谁的区块？ 为什么要遵守协议：节点工作量只有在其他的节点认同的情况下，其是有效的。 节点独立选择出累计工作量最大（/最长）的区块链，再以此区块链通过不断挖矿来继续延长该区块链，共识机制就是来保证此要求 由于网络的原因，出现以下情况： 有些节点收到#3458A 有些先收到#3458B 还有些同时收到#3458A和#3458B。 先收到#3458A（或B）区块的节点，以#3458A（或B）为父链，继续挖矿，但是总会收到#3458B（或A），则将3458B（或A）作为备用链，待下一工作量证明优先由哪一方完成，则这一方的区块链为累计工作量最大（最长的链 ），舍弃短链。 注意：节点有可能先收到#3479B，随后才收到#3458B，则先将前者作为孤块放入孤块池中，待收到其父块后再接收。 入门核心概念与原理 就到这告一段落","@type":"BlogPosting","url":"https://mlh.app/2019/04/08/727943.html","headline":"区块链技术入门——核心概念与原理","dateModified":"2019-04-08T00:00:00+08:00","datePublished":"2019-04-08T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/08/727943.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链技术入门——核心概念与原理</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-dracula"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h2><a id="_0"></a>区块链的前世今生</h2> 
  <p><strong>密码朋克（Cypherpunk）</strong>：是一个邮件组，里面有许多大牛。</p> 
  <p>比特币的底层技术：</p> 
  <p><strong>点对点网络</strong> <strong>时间戳</strong> <strong>加密技术</strong> <strong>工作量证明</strong></p> 
  <p>可以应用到其他领域。<br> 将这些技术提炼出来，就提出了<strong>区块链概念</strong></p> 
  <p>区块链不是单一的技术，而是一系列技术的集合。</p> 
  <p><strong>为何叫区块链？</strong>：因为比特币系统里的数据是用一个个区块存储的，然后通过hash的方式将一个一个区块连接，形成一个区块的链条，所以叫做区块链。</p> 
  <p><strong>应用场景：</strong></p> 
  <p><strong>资产</strong>：数字资产发行、支付（跨境支付）、交易、结算<br> <strong>记账</strong>：股权交易、供应链金融、商业积分<br> <strong>不可篡改</strong>：溯源、众筹、医疗证明、存在性证明<br> <strong>点对点</strong>：共享经济、物联网<br> <strong>隐私</strong>：匿名交易</p> 
  <h2><a id="_23"></a>比特币是什么？</h2> 
  <p>比特币是数字货币，即虚拟货币（价值共识——信任），其总量是不变的，是两千一百万个，流通性好，全球无缝点到点流通直接到账</p> 
  <p><strong>其信任从何而来？</strong><br> 1.财产只受自己控制<br> 2.无通货膨胀<br> 3.没有假钞<br> 4.流通性好</p> 
  <p><strong>去中心化记账系统</strong></p> 
  <p>在中心化的系统里，通常有个中央的服务器，来存储所有的数据，可以理解为就是一个数据库。</p> 
  <p>而去中心化的系统，数据不再是存储在一个服务器，而是存储于比特币网络的每一个节点里。</p> 
  <p><em>问题来了，如果一段时间存在节点的记账数据不一致，那么将以谁的为准呢？</em></p> 
  <p>这就涉及到<strong>比特币的原理</strong></p> 
  <h2><a id="_43"></a>比特币的原理？</h2> 
  <p><strong>一、账本如何验证？</strong></p> 
  <p>方案一，少数服从多数（每次验证都与千百万量的账本数据核对，这个效率是非常低下，实际上是不可行的。）</p> 
  <p>方案二，Hash函数(原始信息）=摘要信息</p> 
  <p>特点：1.同样的原始信息用同一个哈希函数总能得到同样的摘要信息<br> 2.原始信息发生微小的变化都会导致摘要信息改变<br> 3.摘要信息不可能推导出原始信息</p> 
  <p>对一个账本原始数据进行hash得到一个hash值，与序号、时间戳构成区块的头部，加上交易记录，就是一个区块，每10分钟更新，链接一个新区块，形成时间上的区块链。</p> 
  <p>注意：在对第二个账本进行Hash时，会传入第一个账本的Hash值，和第二个账本的原始数据一起进行Hash（就是通过这种方式将块与块相连接！）。<br> <strong>只要区块链中最后一个区块的hash值与其他用户储存账本均一致则是正确的，则账本是正确的</strong>。</p> 
  <p><strong>二、账户所有权问题？</strong></p> 
  <p>现实生活中，银行账户和密码与银行存储系统匹配，就可以进行交易。如果你的银行卡和密码都给盗了，盗贼使用你的卡进行消费。我们还可以通过银行和警察叔叔的协助，确定是盗贼使用了你的卡。</p> 
  <p>但是，在比特币系统中，交易是点到点的，没有第三方</p> 
  <p>在比特币系统中，比特币账户是一个地址，谁能用这个地址进行交易，谁就拥有这个账户的所有权。<strong>密码—&gt;私钥</strong></p> 
  <p><strong>注意：地址和私钥是非对称的关系，私钥经过一系列Hash运算后得到地址（付款方地址（公钥））。</strong></p> 
  <p>由上可知，私钥和账户有着绝对确定的直接对应关系，而不能像银行卡那样再修改密码了。谁拥有了私钥，就相当于谁就拥有了这个账户，谁就可以用这个地址进行交易。所以私钥超重要，如果私钥泄露了，比特币就可能丢失。</p> 
  <p><strong>所以所有权的问题就变成了在不泄露私钥的情况下，证明自己拥有某个地址的私钥。</strong><br> （也就是验证私钥的正确性就行了）。</p> 
  <p>（这里我是这样理解的：要想证明自己拥有私钥，就要得到别人的验证，一种方法就是：你直接把密码告诉别人，就好像你把银行密码直接告诉别人，然后说：“你看吧，这个是正确的密码，不信你输入看看，可以取款的，没骗你吧。”<br> 当然，这是傻子才会做的事。有没有不告诉别人密码，然后又可以验证的方法呢？）</p> 
  <p>这里就用到了<strong>非对称加密技术（交易签名）：</strong></p> 
  <p>1.交易进行Hash得到交易摘要<br> 2.用私钥对摘要进行签名</p> 
  <p><strong>签名过程：</strong></p> 
  <p><strong>首先</strong>对原始交易过程进行Hash生成交易摘要，然后再用交易摘要和私钥进行一个签名运算。</p> 
  <p><strong>然后</strong>，在签名运算之后，该节点会在整个网络进行广播——内容为原始的交易信息（包含付款方地址【公钥】）和签名信息</p> 
  <p><strong>而最后</strong>接收到的节点又会以同样的方法进行广播，以致传递到所有节点。</p> 
  <p><img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190408132610553.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE1MzI2,size_16,color_FFFFFF,t_70" alt="签名过程"></p> 
  <p><strong>验证过程：</strong></p> 
  <p>用<strong>签名</strong>和**付款方的地址【公钥】**进行一个验证的运算，如果结果是原始交易信息的摘要（hash值），那么说明这笔交易就是私钥所有者发出的，验证通过。这时候就会把交易的信息写入到账本。然后再次进行广播‘<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190408132734847.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE1MzI2,size_16,color_FFFFFF,t_70" alt="验证过程"></p> 
  <p>签名和验证是个相反的运算，<strong>签名是个加密的过程，验证是个解密的过程</strong>。<strong>而这个付款方地址就是公钥！</strong></p> 
  <p>总之，<strong>签名过程</strong>即 <strong>sign{（hash（原始交易信息【包括付款方地址（公钥）】）+私钥} = 签名信息</strong><br> <strong>验证过程</strong>即 <strong>verify{签名信息+付款方地址（公钥）} == 交易摘要</strong> True（是私钥所有者发出，写入本用户账本并广播）</p> 
  <p>BTC系统中没有银行机制，也就是没有除私钥外对BTC所有者进行验证的方法，只有你拥有使用该地址（账户）上的BTC的私钥，才可以证明这些BTC是你的。如果没有回收机制，会有一些BTC变成幽灵币，不再参与市场，只是维持BTC总数不变。…</p> 
  <p>三、为什么记账（挖矿）？</p> 
  <p>记账：Hash打包过程。在比特币的设计中，完成记账是可以获得一定比特币奖励的，所以大家将记账形象的叫做——挖矿，这个奖励其实就是比特币发行的过程。</p> 
  <p><strong>记账规则：</strong></p> 
  <ol> 
   <li>一段时间内只有一人可以记账成功（通常是10分钟）</li> 
   <li>通过解决密码学难题（工作量证明）竞争获得唯一记账权</li> 
   <li>其他节点则只复制结果</li> 
  </ol> 
  <p>如果只是上述的 hash打包过程，那么每个人都可以轻松完成，而要保证一段时间内只能有一个人记账成功，就必须要故意大大提高计算的难度。</p> 
  <p><img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190408144416227." alt="简单打包过程"></p> 
  <p>比特币规定这个计算结果要满足以若干个0开头的要求。<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190408144451838." alt="引入随机数后Hash打包"><br> 这时在计算hash时，就要引入一个随机数变量，不断的去改变随机数，每个都可以得到一个新的hash值，直到找一个符合以若干个0开头的hash值。<strong>我们现在的电脑要找出4个0开头的hash，一般需要1、2分钟的时间。</strong></p> 
  <p>比特币因为现在很多人参与挖矿，算力很强大，所以将<strong>挖矿的难度设为以18个0开头</strong>。第一找到这个hash的，就可以获得唯一记帐权，这个交易记录集得到的途径：</p> 
  <p><strong>收集广播中还没有被记录账本的交易，然后交易的有效性验证，（挖矿成功的情况下）添加一笔给自己转账的交易（挖矿奖励）</strong></p> 
  <p>区块Hash值是16进制字符串，得到18个0的，理论上需要16的18次方次哈希运算。</p> 
  <p>18个0的计算量是非常巨大的，要非常强大的设备与消耗巨大的电力</p> 
  <p>所以现在已经没有独立的矿工进行挖矿了，因为几十年也可能挖不出一个。<br> 因此矿工结合起来变成一个矿池，如果挖掘到比特币，按照算力来分成。<br> 而且随着越来越多的人投入挖矿，那么计算难度必然又将加大。成本也将越来越高。最终这样作用下去，成本甚至是接近收益的。</p> 
  <p><strong>四、共识机制</strong></p> 
  <p>问题：如果两个节点同时(规定时间段内)完成工作量证明，使用谁的区块？</p> 
  <p>为什么要遵守协议：<strong>节点工作量只有在其他的节点认同的情况下，其是有效的。</strong></p> 
  <p><strong>节点独立选择出累计工作量最大（/最长）的区块链，再以此区块链通过不断挖矿来继续延长该区块链，共识机制就是来保证此要求</strong><br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190408161109881.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE1MzI2,size_16,color_FFFFFF,t_70" alt="分叉解决"><br> 由于网络的原因，出现以下情况：</p> 
  <ol> 
   <li>有些节点收到#3458A</li> 
   <li>有些先收到#3458B</li> 
   <li>还有些同时收到#3458A和#3458B。</li> 
  </ol> 
  <p>先收到#3458A（或B）区块的节点，以#3458A（或B）为父链，继续挖矿，但是总会收到#3458B（或A），则将3458B（或A）作为备用链，待下一工作量证明优先由哪一方完成，则这一方的区块链为累计工作量最大（最长的链 ），舍弃短链。</p> 
  <p>注意：节点有可能先收到#3479B，随后才收到#3458B，则先将前者作为孤块放入孤块池中，待收到其父块后再接收。</p> 
  <p><em>入门核心概念与原理 就到这告一段落</em></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
