<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Keras框架下输出模型中间层学习到的表示的两种常用方式 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Keras框架下输出模型中间层学习到的表示的两种常用方式" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：转载请注明出处，谢谢！！！ https://blog.csdn.net/tszupup/article/details/89192737 &nbsp; &nbsp; &nbsp; &nbsp; 深度学习本质上是表示学习，它通过多层非线性神经网络模型从底层特征中学习出对具体任务而言更有效的高级抽象特征。针对一个具体的任务，我们往往会遇到这种情况：需要用一个模型学习出特征表示，然后将学习出的特征表示作为另一个模型的输入。这就要求我们会获取模型中间层的输出，下面以具体代码形式介绍两种具体方法。 &nbsp; 目录 1 通过K.function()函数打印模型中间层的输出 2 通过函数API打印模型中间层的输出 &nbsp; &nbsp; &nbsp; &nbsp; 这里的任务是使用多层全连接神经网络预测Mnist图像数据集的标签，模型相对简单，结构图如下： &nbsp; &nbsp; &nbsp; &nbsp; 可以看到模型是一个三层的全连接神经网络。针对该任务的代码及训练效果如下： #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:24 @email:tsz1216@sina.com &quot;&quot;&quot; import numpy as np from keras.datasets import mnist from keras.models import Sequential from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils # 设定随机数种子 np.random.seed(1) # 设定超参数 # 迭代次数 NB_EPOCH = 20 # 批大小 BATCH_SIZE = 128 # 日志模式 VERBOSE = 1 # 类别数 NB_CLASSES = 10 # 优化器 OPTIMIZER = SGD() # 训练集中用于验证的划分比例 VALIDATION_SPLIT = 0.2 # 数据：混合并划分训练集和测试集数据 (X_train, Y_train), (X_test, Y_test) = mnist.load_data() # X_train是60000行28*28的数据，变形为60000*784 RESHAPE = 784 X_train = X_train.reshape(60000, RESHAPE) # 变换形状 X_test = X_test.reshape(10000, RESHAPE) X_train = X_train.astype(&#39;float32&#39;) # 转换类型 X_test = X_test.astype(&#39;float32&#39;) X_train /= 255 # 归一化 X_test /= 255 print(X_train.shape[0], &#39;train samples&#39;) print(X_test.shape[0], &#39;test samples&#39;) # 将类向量转换为二值类别矩阵 Y_train = np_utils.to_categorical(Y_train, NB_CLASSES) Y_test = np_utils.to_categorical(Y_test, NB_CLASSES) # 构建模型 model = Sequential() # 创建序贯模型实例 model.add(Dense(units=128, input_shape=(RESHAPE, ))) # 输入为784维数组 model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=64)) model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=NB_CLASSES)) model.add(Activation(&#39;softmax&#39;)) # 打印模型概述信息 model.summary() # 编译模型 model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=OPTIMIZER, metrics=[&#39;accuracy&#39;]) # 训练模型 history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) score = model.evaluate(X_test, Y_test, verbose=VERBOSE) print(&#39;Test score:&#39;, score[0]) print(&#39;Test accuracy:&#39;, score[1]) &nbsp; &nbsp; &nbsp; &nbsp; 模型的训练效果如下： 以最后一代为例： Epoch 20/20 128/48000 [..............................] - ETA: 3s - loss: 0.2236 - acc: 0.9453 4352/48000 [=&gt;............................] - ETA: 0s - loss: 0.1976 - acc: 0.9426 8192/48000 [====&gt;.........................] - ETA: 0s - loss: 0.1939 - acc: 0.9454 12800/48000 [=======&gt;......................] - ETA: 0s - loss: 0.1935 - acc: 0.9449 16512/48000 [=========&gt;....................] - ETA: 0s - loss: 0.1919 - acc: 0.9450 20864/48000 [============&gt;.................] - ETA: 0s - loss: 0.1952 - acc: 0.9446 24704/48000 [==============&gt;...............] - ETA: 0s - loss: 0.1947 - acc: 0.9447 28672/48000 [================&gt;.............] - ETA: 0s - loss: 0.1933 - acc: 0.9449 32384/48000 [===================&gt;..........] - ETA: 0s - loss: 0.1932 - acc: 0.9450 35968/48000 [=====================&gt;........] - ETA: 0s - loss: 0.1919 - acc: 0.9456 39808/48000 [=======================&gt;......] - ETA: 0s - loss: 0.1930 - acc: 0.9455 43904/48000 [==========================&gt;...] - ETA: 0s - loss: 0.1921 - acc: 0.9457 47232/48000 [============================&gt;.] - ETA: 0s - loss: 0.1927 - acc: 0.9456 48000/48000 [==============================] - 1s 15us/step - loss: 0.1928 - acc: 0.9455 - val_loss: 0.1900 - val_acc: 0.9473 32/10000 [..............................] - ETA: 0s 2976/10000 [=======&gt;......................] - ETA: 0s 6432/10000 [==================&gt;...........] - ETA: 0s 10000/10000 [==============================] - 0s 15us/step Test score: 0.1925726256787777 Test accuracy: 0.9442 &nbsp; &nbsp; &nbsp; &nbsp; 现在我们要获取第三个全连接层dense_3的输出，有以下两种常用的方式： 1 通过K.function()函数打印模型中间层的输出 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;思路是通过K.function()函数创建Keras函数，然后再将数据输入到函数中即可。 # 实例化keras函数 representation_layer = K.function(inputs=[model.layers[0].input], outputs=[model.get_layer(&#39;dense_3&#39;).output]) # 调用实例化后的keras函数获取学习到的特征 representation = representation_layer([X_train]) &nbsp; &nbsp; &nbsp; &nbsp; 完整代码及运行效果如下： #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:24 @email:tsz1216@sina.com &quot;&quot;&quot; import numpy as np from keras.datasets import mnist from keras.models import Sequential from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils from keras import backend as K # 设定随机数种子 np.random.seed(1) # 设定超参数 # 迭代次数 NB_EPOCH = 20 # 批大小 BATCH_SIZE = 128 # 日志模式 VERBOSE = 1 # 类别数 NB_CLASSES = 10 # 优化器 OPTIMIZER = SGD() # 训练集中用于验证的划分比例 VALIDATION_SPLIT = 0.2 # 数据：混合并划分训练集和测试集数据 (X_train, Y_train), (X_test, Y_test) = mnist.load_data() # X_train是60000行28*28的数据，变形为60000*784 RESHAPE = 784 X_train = X_train.reshape(60000, RESHAPE) # 变换形状 X_test = X_test.reshape(10000, RESHAPE) X_train = X_train.astype(&#39;float32&#39;) # 转换类型 X_test = X_test.astype(&#39;float32&#39;) X_train /= 255 # 归一化 X_test /= 255 print(X_train.shape[0], &#39;train samples&#39;) print(X_test.shape[0], &#39;test samples&#39;) # 将类向量转换为二值类别矩阵 Y_train = np_utils.to_categorical(Y_train, NB_CLASSES) Y_test = np_utils.to_categorical(Y_test, NB_CLASSES) # 构建模型 model = Sequential() # 创建序贯模型实例 model.add(Dense(units=128, input_shape=(RESHAPE, ))) # 输入为784维数组 model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=64)) model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=NB_CLASSES)) model.add(Activation(&#39;softmax&#39;)) # 打印模型概述信息 model.summary() # 编译模型 model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=OPTIMIZER, metrics=[&#39;accuracy&#39;]) # 训练模型 history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) score = model.evaluate(X_test, Y_test, verbose=VERBOSE) print(&#39;Test score:&#39;, score[0]) print(&#39;Test accuracy:&#39;, score[1]) # 实例化keras函数 # 注意这里的inputs和outputs应该为list或者tuple对象！！！ representation_layer = K.function(inputs=[model.layers[0].input], outputs=[model.get_layer(&#39;dense_3&#39;).output]) # 调用实例化后的keras函数获取学习到的特征 representation = representation_layer([X_train]) representation = np.array(representation)[0] print(representation.shape) print(type(representation)) print(representation) 2 通过函数API打印模型中间层的输出 &nbsp; &nbsp; &nbsp; &nbsp; 与K.function()函数类似，根据输入输出关系通过Model()构建一个新的模型，然后在新的模型上对输入数据做预测。 # 通过函数模型API representation_model = Model(inputs=model.inputs, outputs=model.get_layer(&#39;dense_3&#39;).output) # 这个模型的预测值即为学习到的特征 dense_3_output = representation_model.predict(X_train) &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;完整代码及运行效果如下： #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:25 @email:tsz1216@sina.com &quot;&quot;&quot; #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:24 @email:tsz1216@sina.com &quot;&quot;&quot; import numpy as np from keras.datasets import mnist from keras.models import Sequential, Model from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils # 设定随机数种子 np.random.seed(1) # 设定超参数 # 迭代次数 NB_EPOCH = 20 # 批大小 BATCH_SIZE = 128 # 日志模式 VERBOSE = 1 # 类别数 NB_CLASSES = 10 # 优化器 OPTIMIZER = SGD() # 训练集中用于验证的划分比例 VALIDATION_SPLIT = 0.2 # 数据：混合并划分训练集和测试集数据 (X_train, Y_train_1), (X_test, Y_test) = mnist.load_data() # X_train是60000行28*28的数据，变形为60000*784 RESHAPE = 784 X_train = X_train.reshape(60000, RESHAPE) # 变换形状 X_test = X_test.reshape(10000, RESHAPE) X_train = X_train.astype(&#39;float32&#39;) # 转换类型 X_test = X_test.astype(&#39;float32&#39;) X_train /= 255 # 归一化 X_test /= 255 print(X_train.shape[0], &#39;train samples&#39;) print(X_test.shape[0], &#39;test samples&#39;) # 将类向量转换为二值类别矩阵 Y_train = np_utils.to_categorical(Y_train_1, NB_CLASSES) Y_test = np_utils.to_categorical(Y_test, NB_CLASSES) # 构建模型 model = Sequential() # 创建序贯模型实例 model.add(Dense(units=128, input_shape=(RESHAPE, ))) # 输入为784维数组 model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=64)) model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=NB_CLASSES)) model.add(Activation(&#39;softmax&#39;)) # 打印模型概述信息 model.summary() # 编译模型 model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=OPTIMIZER, metrics=[&#39;accuracy&#39;]) # 训练模型 history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) score = model.evaluate(X_test, Y_test, verbose=VERBOSE) print(&#39;Test score:&#39;, score[0]) print(&#39;Test accuracy:&#39;, score[1]) # 通过函数模型API representation_model = Model(inputs=model.inputs, outputs=model.get_layer(&#39;dense_3&#39;).output) # 这个模型的预测值即为学习到的特征 dense_3_output = representation_model.predict(X_train) print(dense_3_output.shape) print(type(dense_3_output)) print(dense_3_output) &nbsp; &nbsp; &nbsp; &nbsp; 参考了这篇博客： &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Keras中间层输出的两种方式，及特征图可视化 &nbsp; &nbsp; &nbsp; &nbsp; 谢谢！" />
<meta property="og:description" content="版权声明：转载请注明出处，谢谢！！！ https://blog.csdn.net/tszupup/article/details/89192737 &nbsp; &nbsp; &nbsp; &nbsp; 深度学习本质上是表示学习，它通过多层非线性神经网络模型从底层特征中学习出对具体任务而言更有效的高级抽象特征。针对一个具体的任务，我们往往会遇到这种情况：需要用一个模型学习出特征表示，然后将学习出的特征表示作为另一个模型的输入。这就要求我们会获取模型中间层的输出，下面以具体代码形式介绍两种具体方法。 &nbsp; 目录 1 通过K.function()函数打印模型中间层的输出 2 通过函数API打印模型中间层的输出 &nbsp; &nbsp; &nbsp; &nbsp; 这里的任务是使用多层全连接神经网络预测Mnist图像数据集的标签，模型相对简单，结构图如下： &nbsp; &nbsp; &nbsp; &nbsp; 可以看到模型是一个三层的全连接神经网络。针对该任务的代码及训练效果如下： #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:24 @email:tsz1216@sina.com &quot;&quot;&quot; import numpy as np from keras.datasets import mnist from keras.models import Sequential from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils # 设定随机数种子 np.random.seed(1) # 设定超参数 # 迭代次数 NB_EPOCH = 20 # 批大小 BATCH_SIZE = 128 # 日志模式 VERBOSE = 1 # 类别数 NB_CLASSES = 10 # 优化器 OPTIMIZER = SGD() # 训练集中用于验证的划分比例 VALIDATION_SPLIT = 0.2 # 数据：混合并划分训练集和测试集数据 (X_train, Y_train), (X_test, Y_test) = mnist.load_data() # X_train是60000行28*28的数据，变形为60000*784 RESHAPE = 784 X_train = X_train.reshape(60000, RESHAPE) # 变换形状 X_test = X_test.reshape(10000, RESHAPE) X_train = X_train.astype(&#39;float32&#39;) # 转换类型 X_test = X_test.astype(&#39;float32&#39;) X_train /= 255 # 归一化 X_test /= 255 print(X_train.shape[0], &#39;train samples&#39;) print(X_test.shape[0], &#39;test samples&#39;) # 将类向量转换为二值类别矩阵 Y_train = np_utils.to_categorical(Y_train, NB_CLASSES) Y_test = np_utils.to_categorical(Y_test, NB_CLASSES) # 构建模型 model = Sequential() # 创建序贯模型实例 model.add(Dense(units=128, input_shape=(RESHAPE, ))) # 输入为784维数组 model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=64)) model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=NB_CLASSES)) model.add(Activation(&#39;softmax&#39;)) # 打印模型概述信息 model.summary() # 编译模型 model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=OPTIMIZER, metrics=[&#39;accuracy&#39;]) # 训练模型 history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) score = model.evaluate(X_test, Y_test, verbose=VERBOSE) print(&#39;Test score:&#39;, score[0]) print(&#39;Test accuracy:&#39;, score[1]) &nbsp; &nbsp; &nbsp; &nbsp; 模型的训练效果如下： 以最后一代为例： Epoch 20/20 128/48000 [..............................] - ETA: 3s - loss: 0.2236 - acc: 0.9453 4352/48000 [=&gt;............................] - ETA: 0s - loss: 0.1976 - acc: 0.9426 8192/48000 [====&gt;.........................] - ETA: 0s - loss: 0.1939 - acc: 0.9454 12800/48000 [=======&gt;......................] - ETA: 0s - loss: 0.1935 - acc: 0.9449 16512/48000 [=========&gt;....................] - ETA: 0s - loss: 0.1919 - acc: 0.9450 20864/48000 [============&gt;.................] - ETA: 0s - loss: 0.1952 - acc: 0.9446 24704/48000 [==============&gt;...............] - ETA: 0s - loss: 0.1947 - acc: 0.9447 28672/48000 [================&gt;.............] - ETA: 0s - loss: 0.1933 - acc: 0.9449 32384/48000 [===================&gt;..........] - ETA: 0s - loss: 0.1932 - acc: 0.9450 35968/48000 [=====================&gt;........] - ETA: 0s - loss: 0.1919 - acc: 0.9456 39808/48000 [=======================&gt;......] - ETA: 0s - loss: 0.1930 - acc: 0.9455 43904/48000 [==========================&gt;...] - ETA: 0s - loss: 0.1921 - acc: 0.9457 47232/48000 [============================&gt;.] - ETA: 0s - loss: 0.1927 - acc: 0.9456 48000/48000 [==============================] - 1s 15us/step - loss: 0.1928 - acc: 0.9455 - val_loss: 0.1900 - val_acc: 0.9473 32/10000 [..............................] - ETA: 0s 2976/10000 [=======&gt;......................] - ETA: 0s 6432/10000 [==================&gt;...........] - ETA: 0s 10000/10000 [==============================] - 0s 15us/step Test score: 0.1925726256787777 Test accuracy: 0.9442 &nbsp; &nbsp; &nbsp; &nbsp; 现在我们要获取第三个全连接层dense_3的输出，有以下两种常用的方式： 1 通过K.function()函数打印模型中间层的输出 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;思路是通过K.function()函数创建Keras函数，然后再将数据输入到函数中即可。 # 实例化keras函数 representation_layer = K.function(inputs=[model.layers[0].input], outputs=[model.get_layer(&#39;dense_3&#39;).output]) # 调用实例化后的keras函数获取学习到的特征 representation = representation_layer([X_train]) &nbsp; &nbsp; &nbsp; &nbsp; 完整代码及运行效果如下： #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:24 @email:tsz1216@sina.com &quot;&quot;&quot; import numpy as np from keras.datasets import mnist from keras.models import Sequential from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils from keras import backend as K # 设定随机数种子 np.random.seed(1) # 设定超参数 # 迭代次数 NB_EPOCH = 20 # 批大小 BATCH_SIZE = 128 # 日志模式 VERBOSE = 1 # 类别数 NB_CLASSES = 10 # 优化器 OPTIMIZER = SGD() # 训练集中用于验证的划分比例 VALIDATION_SPLIT = 0.2 # 数据：混合并划分训练集和测试集数据 (X_train, Y_train), (X_test, Y_test) = mnist.load_data() # X_train是60000行28*28的数据，变形为60000*784 RESHAPE = 784 X_train = X_train.reshape(60000, RESHAPE) # 变换形状 X_test = X_test.reshape(10000, RESHAPE) X_train = X_train.astype(&#39;float32&#39;) # 转换类型 X_test = X_test.astype(&#39;float32&#39;) X_train /= 255 # 归一化 X_test /= 255 print(X_train.shape[0], &#39;train samples&#39;) print(X_test.shape[0], &#39;test samples&#39;) # 将类向量转换为二值类别矩阵 Y_train = np_utils.to_categorical(Y_train, NB_CLASSES) Y_test = np_utils.to_categorical(Y_test, NB_CLASSES) # 构建模型 model = Sequential() # 创建序贯模型实例 model.add(Dense(units=128, input_shape=(RESHAPE, ))) # 输入为784维数组 model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=64)) model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=NB_CLASSES)) model.add(Activation(&#39;softmax&#39;)) # 打印模型概述信息 model.summary() # 编译模型 model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=OPTIMIZER, metrics=[&#39;accuracy&#39;]) # 训练模型 history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) score = model.evaluate(X_test, Y_test, verbose=VERBOSE) print(&#39;Test score:&#39;, score[0]) print(&#39;Test accuracy:&#39;, score[1]) # 实例化keras函数 # 注意这里的inputs和outputs应该为list或者tuple对象！！！ representation_layer = K.function(inputs=[model.layers[0].input], outputs=[model.get_layer(&#39;dense_3&#39;).output]) # 调用实例化后的keras函数获取学习到的特征 representation = representation_layer([X_train]) representation = np.array(representation)[0] print(representation.shape) print(type(representation)) print(representation) 2 通过函数API打印模型中间层的输出 &nbsp; &nbsp; &nbsp; &nbsp; 与K.function()函数类似，根据输入输出关系通过Model()构建一个新的模型，然后在新的模型上对输入数据做预测。 # 通过函数模型API representation_model = Model(inputs=model.inputs, outputs=model.get_layer(&#39;dense_3&#39;).output) # 这个模型的预测值即为学习到的特征 dense_3_output = representation_model.predict(X_train) &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;完整代码及运行效果如下： #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:25 @email:tsz1216@sina.com &quot;&quot;&quot; #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:24 @email:tsz1216@sina.com &quot;&quot;&quot; import numpy as np from keras.datasets import mnist from keras.models import Sequential, Model from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils # 设定随机数种子 np.random.seed(1) # 设定超参数 # 迭代次数 NB_EPOCH = 20 # 批大小 BATCH_SIZE = 128 # 日志模式 VERBOSE = 1 # 类别数 NB_CLASSES = 10 # 优化器 OPTIMIZER = SGD() # 训练集中用于验证的划分比例 VALIDATION_SPLIT = 0.2 # 数据：混合并划分训练集和测试集数据 (X_train, Y_train_1), (X_test, Y_test) = mnist.load_data() # X_train是60000行28*28的数据，变形为60000*784 RESHAPE = 784 X_train = X_train.reshape(60000, RESHAPE) # 变换形状 X_test = X_test.reshape(10000, RESHAPE) X_train = X_train.astype(&#39;float32&#39;) # 转换类型 X_test = X_test.astype(&#39;float32&#39;) X_train /= 255 # 归一化 X_test /= 255 print(X_train.shape[0], &#39;train samples&#39;) print(X_test.shape[0], &#39;test samples&#39;) # 将类向量转换为二值类别矩阵 Y_train = np_utils.to_categorical(Y_train_1, NB_CLASSES) Y_test = np_utils.to_categorical(Y_test, NB_CLASSES) # 构建模型 model = Sequential() # 创建序贯模型实例 model.add(Dense(units=128, input_shape=(RESHAPE, ))) # 输入为784维数组 model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=64)) model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=NB_CLASSES)) model.add(Activation(&#39;softmax&#39;)) # 打印模型概述信息 model.summary() # 编译模型 model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=OPTIMIZER, metrics=[&#39;accuracy&#39;]) # 训练模型 history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) score = model.evaluate(X_test, Y_test, verbose=VERBOSE) print(&#39;Test score:&#39;, score[0]) print(&#39;Test accuracy:&#39;, score[1]) # 通过函数模型API representation_model = Model(inputs=model.inputs, outputs=model.get_layer(&#39;dense_3&#39;).output) # 这个模型的预测值即为学习到的特征 dense_3_output = representation_model.predict(X_train) print(dense_3_output.shape) print(type(dense_3_output)) print(dense_3_output) &nbsp; &nbsp; &nbsp; &nbsp; 参考了这篇博客： &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Keras中间层输出的两种方式，及特征图可视化 &nbsp; &nbsp; &nbsp; &nbsp; 谢谢！" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-10T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：转载请注明出处，谢谢！！！ https://blog.csdn.net/tszupup/article/details/89192737 &nbsp; &nbsp; &nbsp; &nbsp; 深度学习本质上是表示学习，它通过多层非线性神经网络模型从底层特征中学习出对具体任务而言更有效的高级抽象特征。针对一个具体的任务，我们往往会遇到这种情况：需要用一个模型学习出特征表示，然后将学习出的特征表示作为另一个模型的输入。这就要求我们会获取模型中间层的输出，下面以具体代码形式介绍两种具体方法。 &nbsp; 目录 1 通过K.function()函数打印模型中间层的输出 2 通过函数API打印模型中间层的输出 &nbsp; &nbsp; &nbsp; &nbsp; 这里的任务是使用多层全连接神经网络预测Mnist图像数据集的标签，模型相对简单，结构图如下： &nbsp; &nbsp; &nbsp; &nbsp; 可以看到模型是一个三层的全连接神经网络。针对该任务的代码及训练效果如下： #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:24 @email:tsz1216@sina.com &quot;&quot;&quot; import numpy as np from keras.datasets import mnist from keras.models import Sequential from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils # 设定随机数种子 np.random.seed(1) # 设定超参数 # 迭代次数 NB_EPOCH = 20 # 批大小 BATCH_SIZE = 128 # 日志模式 VERBOSE = 1 # 类别数 NB_CLASSES = 10 # 优化器 OPTIMIZER = SGD() # 训练集中用于验证的划分比例 VALIDATION_SPLIT = 0.2 # 数据：混合并划分训练集和测试集数据 (X_train, Y_train), (X_test, Y_test) = mnist.load_data() # X_train是60000行28*28的数据，变形为60000*784 RESHAPE = 784 X_train = X_train.reshape(60000, RESHAPE) # 变换形状 X_test = X_test.reshape(10000, RESHAPE) X_train = X_train.astype(&#39;float32&#39;) # 转换类型 X_test = X_test.astype(&#39;float32&#39;) X_train /= 255 # 归一化 X_test /= 255 print(X_train.shape[0], &#39;train samples&#39;) print(X_test.shape[0], &#39;test samples&#39;) # 将类向量转换为二值类别矩阵 Y_train = np_utils.to_categorical(Y_train, NB_CLASSES) Y_test = np_utils.to_categorical(Y_test, NB_CLASSES) # 构建模型 model = Sequential() # 创建序贯模型实例 model.add(Dense(units=128, input_shape=(RESHAPE, ))) # 输入为784维数组 model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=64)) model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=NB_CLASSES)) model.add(Activation(&#39;softmax&#39;)) # 打印模型概述信息 model.summary() # 编译模型 model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=OPTIMIZER, metrics=[&#39;accuracy&#39;]) # 训练模型 history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) score = model.evaluate(X_test, Y_test, verbose=VERBOSE) print(&#39;Test score:&#39;, score[0]) print(&#39;Test accuracy:&#39;, score[1]) &nbsp; &nbsp; &nbsp; &nbsp; 模型的训练效果如下： 以最后一代为例： Epoch 20/20 128/48000 [..............................] - ETA: 3s - loss: 0.2236 - acc: 0.9453 4352/48000 [=&gt;............................] - ETA: 0s - loss: 0.1976 - acc: 0.9426 8192/48000 [====&gt;.........................] - ETA: 0s - loss: 0.1939 - acc: 0.9454 12800/48000 [=======&gt;......................] - ETA: 0s - loss: 0.1935 - acc: 0.9449 16512/48000 [=========&gt;....................] - ETA: 0s - loss: 0.1919 - acc: 0.9450 20864/48000 [============&gt;.................] - ETA: 0s - loss: 0.1952 - acc: 0.9446 24704/48000 [==============&gt;...............] - ETA: 0s - loss: 0.1947 - acc: 0.9447 28672/48000 [================&gt;.............] - ETA: 0s - loss: 0.1933 - acc: 0.9449 32384/48000 [===================&gt;..........] - ETA: 0s - loss: 0.1932 - acc: 0.9450 35968/48000 [=====================&gt;........] - ETA: 0s - loss: 0.1919 - acc: 0.9456 39808/48000 [=======================&gt;......] - ETA: 0s - loss: 0.1930 - acc: 0.9455 43904/48000 [==========================&gt;...] - ETA: 0s - loss: 0.1921 - acc: 0.9457 47232/48000 [============================&gt;.] - ETA: 0s - loss: 0.1927 - acc: 0.9456 48000/48000 [==============================] - 1s 15us/step - loss: 0.1928 - acc: 0.9455 - val_loss: 0.1900 - val_acc: 0.9473 32/10000 [..............................] - ETA: 0s 2976/10000 [=======&gt;......................] - ETA: 0s 6432/10000 [==================&gt;...........] - ETA: 0s 10000/10000 [==============================] - 0s 15us/step Test score: 0.1925726256787777 Test accuracy: 0.9442 &nbsp; &nbsp; &nbsp; &nbsp; 现在我们要获取第三个全连接层dense_3的输出，有以下两种常用的方式： 1 通过K.function()函数打印模型中间层的输出 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;思路是通过K.function()函数创建Keras函数，然后再将数据输入到函数中即可。 # 实例化keras函数 representation_layer = K.function(inputs=[model.layers[0].input], outputs=[model.get_layer(&#39;dense_3&#39;).output]) # 调用实例化后的keras函数获取学习到的特征 representation = representation_layer([X_train]) &nbsp; &nbsp; &nbsp; &nbsp; 完整代码及运行效果如下： #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:24 @email:tsz1216@sina.com &quot;&quot;&quot; import numpy as np from keras.datasets import mnist from keras.models import Sequential from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils from keras import backend as K # 设定随机数种子 np.random.seed(1) # 设定超参数 # 迭代次数 NB_EPOCH = 20 # 批大小 BATCH_SIZE = 128 # 日志模式 VERBOSE = 1 # 类别数 NB_CLASSES = 10 # 优化器 OPTIMIZER = SGD() # 训练集中用于验证的划分比例 VALIDATION_SPLIT = 0.2 # 数据：混合并划分训练集和测试集数据 (X_train, Y_train), (X_test, Y_test) = mnist.load_data() # X_train是60000行28*28的数据，变形为60000*784 RESHAPE = 784 X_train = X_train.reshape(60000, RESHAPE) # 变换形状 X_test = X_test.reshape(10000, RESHAPE) X_train = X_train.astype(&#39;float32&#39;) # 转换类型 X_test = X_test.astype(&#39;float32&#39;) X_train /= 255 # 归一化 X_test /= 255 print(X_train.shape[0], &#39;train samples&#39;) print(X_test.shape[0], &#39;test samples&#39;) # 将类向量转换为二值类别矩阵 Y_train = np_utils.to_categorical(Y_train, NB_CLASSES) Y_test = np_utils.to_categorical(Y_test, NB_CLASSES) # 构建模型 model = Sequential() # 创建序贯模型实例 model.add(Dense(units=128, input_shape=(RESHAPE, ))) # 输入为784维数组 model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=64)) model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=NB_CLASSES)) model.add(Activation(&#39;softmax&#39;)) # 打印模型概述信息 model.summary() # 编译模型 model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=OPTIMIZER, metrics=[&#39;accuracy&#39;]) # 训练模型 history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) score = model.evaluate(X_test, Y_test, verbose=VERBOSE) print(&#39;Test score:&#39;, score[0]) print(&#39;Test accuracy:&#39;, score[1]) # 实例化keras函数 # 注意这里的inputs和outputs应该为list或者tuple对象！！！ representation_layer = K.function(inputs=[model.layers[0].input], outputs=[model.get_layer(&#39;dense_3&#39;).output]) # 调用实例化后的keras函数获取学习到的特征 representation = representation_layer([X_train]) representation = np.array(representation)[0] print(representation.shape) print(type(representation)) print(representation) 2 通过函数API打印模型中间层的输出 &nbsp; &nbsp; &nbsp; &nbsp; 与K.function()函数类似，根据输入输出关系通过Model()构建一个新的模型，然后在新的模型上对输入数据做预测。 # 通过函数模型API representation_model = Model(inputs=model.inputs, outputs=model.get_layer(&#39;dense_3&#39;).output) # 这个模型的预测值即为学习到的特征 dense_3_output = representation_model.predict(X_train) &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;完整代码及运行效果如下： #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:25 @email:tsz1216@sina.com &quot;&quot;&quot; #-*-coding:utf-8-*- &quot;&quot;&quot; @author:taoshouzheng @time:2019/4/10 19:24 @email:tsz1216@sina.com &quot;&quot;&quot; import numpy as np from keras.datasets import mnist from keras.models import Sequential, Model from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils # 设定随机数种子 np.random.seed(1) # 设定超参数 # 迭代次数 NB_EPOCH = 20 # 批大小 BATCH_SIZE = 128 # 日志模式 VERBOSE = 1 # 类别数 NB_CLASSES = 10 # 优化器 OPTIMIZER = SGD() # 训练集中用于验证的划分比例 VALIDATION_SPLIT = 0.2 # 数据：混合并划分训练集和测试集数据 (X_train, Y_train_1), (X_test, Y_test) = mnist.load_data() # X_train是60000行28*28的数据，变形为60000*784 RESHAPE = 784 X_train = X_train.reshape(60000, RESHAPE) # 变换形状 X_test = X_test.reshape(10000, RESHAPE) X_train = X_train.astype(&#39;float32&#39;) # 转换类型 X_test = X_test.astype(&#39;float32&#39;) X_train /= 255 # 归一化 X_test /= 255 print(X_train.shape[0], &#39;train samples&#39;) print(X_test.shape[0], &#39;test samples&#39;) # 将类向量转换为二值类别矩阵 Y_train = np_utils.to_categorical(Y_train_1, NB_CLASSES) Y_test = np_utils.to_categorical(Y_test, NB_CLASSES) # 构建模型 model = Sequential() # 创建序贯模型实例 model.add(Dense(units=128, input_shape=(RESHAPE, ))) # 输入为784维数组 model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=64)) model.add(Activation(&#39;relu&#39;)) model.add(Dense(units=NB_CLASSES)) model.add(Activation(&#39;softmax&#39;)) # 打印模型概述信息 model.summary() # 编译模型 model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=OPTIMIZER, metrics=[&#39;accuracy&#39;]) # 训练模型 history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) score = model.evaluate(X_test, Y_test, verbose=VERBOSE) print(&#39;Test score:&#39;, score[0]) print(&#39;Test accuracy:&#39;, score[1]) # 通过函数模型API representation_model = Model(inputs=model.inputs, outputs=model.get_layer(&#39;dense_3&#39;).output) # 这个模型的预测值即为学习到的特征 dense_3_output = representation_model.predict(X_train) print(dense_3_output.shape) print(type(dense_3_output)) print(dense_3_output) &nbsp; &nbsp; &nbsp; &nbsp; 参考了这篇博客： &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Keras中间层输出的两种方式，及特征图可视化 &nbsp; &nbsp; &nbsp; &nbsp; 谢谢！","@type":"BlogPosting","url":"/2019/04/10/727820.html","headline":"Keras框架下输出模型中间层学习到的表示的两种常用方式","dateModified":"2019-04-10T00:00:00+08:00","datePublished":"2019-04-10T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/10/727820.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Keras框架下输出模型中间层学习到的表示的两种常用方式</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：转载请注明出处，谢谢！！！ https://blog.csdn.net/tszupup/article/details/89192737 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 深度学习本质上是表示学习，它通过多层非线性神经网络模型从底层特征中学习出对具体任务而言更有效的高级抽象特征。针对一个具体的任务，我们往往会遇到这种情况：<span style="color:#f33b45;">需要用一个模型学习出特征表示，然后将学习出的特征表示作为另一个模型的输入</span>。这就要求我们会获取模型中间层的输出，下面以具体代码形式介绍两种具体方法。</p> 
  <p>&nbsp;</p> 
  <p id="main-toc"><strong>目录</strong></p> 
  <p id="1%20%E9%80%9A%E8%BF%87K.function()%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E5%B1%82%E7%9A%84%E8%BE%93%E5%87%BA-toc" style="margin-left:80px;"><a href="#1%20%E9%80%9A%E8%BF%87K.function()%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E5%B1%82%E7%9A%84%E8%BE%93%E5%87%BA" rel="nofollow">1 通过K.function()函数打印模型中间层的输出</a></p> 
  <p id="2%20%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0API%E6%89%93%E5%8D%B0%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E5%B1%82%E7%9A%84%E8%BE%93%E5%87%BA-toc" style="margin-left:80px;"><a href="#2%20%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0API%E6%89%93%E5%8D%B0%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E5%B1%82%E7%9A%84%E8%BE%93%E5%87%BA" rel="nofollow">2 通过函数API打印模型中间层的输出</a></p> 
  <hr id="hr-toc">
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 这里的任务是使用多层全连接神经网络预测Mnist图像数据集的标签，模型相对简单，结构图如下：</p> 
  <p style="text-align:center;"><img alt="" class="has" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190410200432232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzenVwdXA=,size_16,color_FFFFFF,t_70"></p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 可以看到模型是一个三层的全连接神经网络。针对该任务的代码及训练效果如下：</p> 
  <pre class="has">
<code class="language-python">#-*-coding:utf-8-*-
"""
@author:taoshouzheng
@time:2019/4/10 19:24
@email:tsz1216@sina.com
"""

import numpy as np
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers.core import Dense, Activation
from keras.optimizers import SGD
from keras.utils import np_utils


# 设定随机数种子
np.random.seed(1)

# 设定超参数
# 迭代次数
NB_EPOCH = 20
# 批大小
BATCH_SIZE = 128
# 日志模式
VERBOSE = 1
# 类别数
NB_CLASSES = 10
# 优化器
OPTIMIZER = SGD()
# 训练集中用于验证的划分比例
VALIDATION_SPLIT = 0.2

# 数据：混合并划分训练集和测试集数据
(X_train, Y_train), (X_test, Y_test) = mnist.load_data()		# X_train是60000行28*28的数据，变形为60000*784
RESHAPE = 784
X_train = X_train.reshape(60000, RESHAPE)		# 变换形状
X_test = X_test.reshape(10000, RESHAPE)
X_train = X_train.astype('float32')		# 转换类型
X_test = X_test.astype('float32')
X_train /= 255		# 归一化
X_test /= 255

print(X_train.shape[0], 'train samples')
print(X_test.shape[0], 'test samples')

# 将类向量转换为二值类别矩阵
Y_train = np_utils.to_categorical(Y_train, NB_CLASSES)
Y_test = np_utils.to_categorical(Y_test, NB_CLASSES)

# 构建模型
model = Sequential()		# 创建序贯模型实例
model.add(Dense(units=128, input_shape=(RESHAPE, )))		# 输入为784维数组
model.add(Activation('relu'))
model.add(Dense(units=64))
model.add(Activation('relu'))
model.add(Dense(units=NB_CLASSES))
model.add(Activation('softmax'))

# 打印模型概述信息
model.summary()

# 编译模型
model.compile(loss='categorical_crossentropy', optimizer=OPTIMIZER, metrics=['accuracy'])

# 训练模型
history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT)

score = model.evaluate(X_test, Y_test, verbose=VERBOSE)
print('Test score:', score[0])
print('Test accuracy:', score[1])</code></pre> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 模型的训练效果如下：</p> 
  <pre class="has">
<code class="language-python">以最后一代为例：
Epoch 20/20

  128/48000 [..............................] - ETA: 3s - loss: 0.2236 - acc: 0.9453
 4352/48000 [=&gt;............................] - ETA: 0s - loss: 0.1976 - acc: 0.9426
 8192/48000 [====&gt;.........................] - ETA: 0s - loss: 0.1939 - acc: 0.9454
12800/48000 [=======&gt;......................] - ETA: 0s - loss: 0.1935 - acc: 0.9449
16512/48000 [=========&gt;....................] - ETA: 0s - loss: 0.1919 - acc: 0.9450
20864/48000 [============&gt;.................] - ETA: 0s - loss: 0.1952 - acc: 0.9446
24704/48000 [==============&gt;...............] - ETA: 0s - loss: 0.1947 - acc: 0.9447
28672/48000 [================&gt;.............] - ETA: 0s - loss: 0.1933 - acc: 0.9449
32384/48000 [===================&gt;..........] - ETA: 0s - loss: 0.1932 - acc: 0.9450
35968/48000 [=====================&gt;........] - ETA: 0s - loss: 0.1919 - acc: 0.9456
39808/48000 [=======================&gt;......] - ETA: 0s - loss: 0.1930 - acc: 0.9455
43904/48000 [==========================&gt;...] - ETA: 0s - loss: 0.1921 - acc: 0.9457
47232/48000 [============================&gt;.] - ETA: 0s - loss: 0.1927 - acc: 0.9456
48000/48000 [==============================] - 1s 15us/step - loss: 0.1928 - acc: 0.9455 - val_loss: 0.1900 - val_acc: 0.9473

   32/10000 [..............................] - ETA: 0s
 2976/10000 [=======&gt;......................] - ETA: 0s
 6432/10000 [==================&gt;...........] - ETA: 0s
10000/10000 [==============================] - 0s 15us/step
Test score: 0.1925726256787777
Test accuracy: 0.9442</code></pre> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 现在我们要<strong><span style="color:#f33b45;">获取第三个全连接层dense_3的输出</span></strong>，有以下两种常用的方式：</p> 
  <h3 id="1%20%E9%80%9A%E8%BF%87K.function()%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E5%B1%82%E7%9A%84%E8%BE%93%E5%87%BA">1 通过K.function()函数打印模型中间层的输出</h3> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;思路是<span style="color:#f33b45;">通过K.function()函数创建Keras函数</span>，然后再将数据输入到函数中即可。</p> 
  <pre class="has">
<code class="language-python"># 实例化keras函数
representation_layer = K.function(inputs=[model.layers[0].input], outputs=[model.get_layer('dense_3').output])
# 调用实例化后的keras函数获取学习到的特征
representation = representation_layer([X_train])</code></pre> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 完整代码及运行效果如下：</p> 
  <pre class="has">
<code class="language-python">#-*-coding:utf-8-*-
"""
@author:taoshouzheng
@time:2019/4/10 19:24
@email:tsz1216@sina.com
"""

import numpy as np
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers.core import Dense, Activation
from keras.optimizers import SGD
from keras.utils import np_utils
from keras import backend as K


# 设定随机数种子
np.random.seed(1)

# 设定超参数
# 迭代次数
NB_EPOCH = 20
# 批大小
BATCH_SIZE = 128
# 日志模式
VERBOSE = 1
# 类别数
NB_CLASSES = 10
# 优化器
OPTIMIZER = SGD()
# 训练集中用于验证的划分比例
VALIDATION_SPLIT = 0.2

# 数据：混合并划分训练集和测试集数据
(X_train, Y_train), (X_test, Y_test) = mnist.load_data()		# X_train是60000行28*28的数据，变形为60000*784
RESHAPE = 784
X_train = X_train.reshape(60000, RESHAPE)		# 变换形状
X_test = X_test.reshape(10000, RESHAPE)
X_train = X_train.astype('float32')		# 转换类型
X_test = X_test.astype('float32')
X_train /= 255		# 归一化
X_test /= 255

print(X_train.shape[0], 'train samples')
print(X_test.shape[0], 'test samples')

# 将类向量转换为二值类别矩阵
Y_train = np_utils.to_categorical(Y_train, NB_CLASSES)
Y_test = np_utils.to_categorical(Y_test, NB_CLASSES)

# 构建模型
model = Sequential()		# 创建序贯模型实例
model.add(Dense(units=128, input_shape=(RESHAPE, )))		# 输入为784维数组
model.add(Activation('relu'))
model.add(Dense(units=64))
model.add(Activation('relu'))
model.add(Dense(units=NB_CLASSES))
model.add(Activation('softmax'))

# 打印模型概述信息
model.summary()

# 编译模型
model.compile(loss='categorical_crossentropy', optimizer=OPTIMIZER, metrics=['accuracy'])

# 训练模型
history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT)

score = model.evaluate(X_test, Y_test, verbose=VERBOSE)
print('Test score:', score[0])
print('Test accuracy:', score[1])

# 实例化keras函数
# 注意这里的inputs和outputs应该为list或者tuple对象！！！
representation_layer = K.function(inputs=[model.layers[0].input], outputs=[model.get_layer('dense_3').output])

# 调用实例化后的keras函数获取学习到的特征
representation = representation_layer([X_train])

representation = np.array(representation)[0]

print(representation.shape)
print(type(representation))
print(representation)</code></pre> 
  <p style="text-align:center;"><img alt="" class="has" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190410201424569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzenVwdXA=,size_16,color_FFFFFF,t_70"></p> 
  <h3 id="2%20%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0API%E6%89%93%E5%8D%B0%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E5%B1%82%E7%9A%84%E8%BE%93%E5%87%BA">2 通过函数API打印模型中间层的输出</h3> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 与K.function()函数类似，根据输入输出关系通过Model()构建一个新的模型，然后在新的模型上对输入数据做预测。</p> 
  <pre class="has">
<code class="language-python"># 通过函数模型API
representation_model = Model(inputs=model.inputs, outputs=model.get_layer('dense_3').output)
# 这个模型的预测值即为学习到的特征
dense_3_output = representation_model.predict(X_train)</code></pre> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;完整代码及运行效果如下：</p> 
  <pre class="has">
<code class="language-python">#-*-coding:utf-8-*-
"""
@author:taoshouzheng
@time:2019/4/10 19:25
@email:tsz1216@sina.com
"""

#-*-coding:utf-8-*-
"""
@author:taoshouzheng
@time:2019/4/10 19:24
@email:tsz1216@sina.com
"""

import numpy as np
from keras.datasets import mnist
from keras.models import Sequential, Model
from keras.layers.core import Dense, Activation
from keras.optimizers import SGD
from keras.utils import np_utils


# 设定随机数种子
np.random.seed(1)

# 设定超参数
# 迭代次数
NB_EPOCH = 20
# 批大小
BATCH_SIZE = 128
# 日志模式
VERBOSE = 1
# 类别数
NB_CLASSES = 10
# 优化器
OPTIMIZER = SGD()
# 训练集中用于验证的划分比例
VALIDATION_SPLIT = 0.2

# 数据：混合并划分训练集和测试集数据
(X_train, Y_train_1), (X_test, Y_test) = mnist.load_data()		# X_train是60000行28*28的数据，变形为60000*784
RESHAPE = 784
X_train = X_train.reshape(60000, RESHAPE)		# 变换形状
X_test = X_test.reshape(10000, RESHAPE)
X_train = X_train.astype('float32')		# 转换类型
X_test = X_test.astype('float32')
X_train /= 255		# 归一化
X_test /= 255

print(X_train.shape[0], 'train samples')
print(X_test.shape[0], 'test samples')

# 将类向量转换为二值类别矩阵
Y_train = np_utils.to_categorical(Y_train_1, NB_CLASSES)
Y_test = np_utils.to_categorical(Y_test, NB_CLASSES)

# 构建模型
model = Sequential()		# 创建序贯模型实例
model.add(Dense(units=128, input_shape=(RESHAPE, )))		# 输入为784维数组
model.add(Activation('relu'))
model.add(Dense(units=64))
model.add(Activation('relu'))
model.add(Dense(units=NB_CLASSES))
model.add(Activation('softmax'))

# 打印模型概述信息
model.summary()

# 编译模型
model.compile(loss='categorical_crossentropy', optimizer=OPTIMIZER, metrics=['accuracy'])

# 训练模型
history = model.fit(X_train, Y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT)

score = model.evaluate(X_test, Y_test, verbose=VERBOSE)
print('Test score:', score[0])
print('Test accuracy:', score[1])

# 通过函数模型API
representation_model = Model(inputs=model.inputs, outputs=model.get_layer('dense_3').output)

# 这个模型的预测值即为学习到的特征
dense_3_output = representation_model.predict(X_train)

print(dense_3_output.shape)
print(type(dense_3_output))
print(dense_3_output)</code></pre> 
  <p style="text-align:center;"><img alt="" class="has" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190410201842269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzenVwdXA=,size_16,color_FFFFFF,t_70"></p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 参考了这篇博客：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="https://blog.csdn.net/u010420283/article/details/80303231" rel="nofollow">Keras中间层输出的两种方式，及特征图可视化</a></p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 谢谢！</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
