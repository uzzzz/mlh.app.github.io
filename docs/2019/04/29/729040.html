<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>一文读懂NoSQL的模式 时光机 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="一文读懂NoSQL的模式 时光机" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="戳蓝字“CSDN云计算”关注我们哦！ 时光机：搭载这部时光机，带您回顾《程序员》大量优秀文章，重温经典技术干货，我们发现硬核技术永不过时，对于get要点、solve难题、提高自我，仍有非凡意义。 作者：Richy&nbsp;Ho，一名软件架构师，热衷于分布式及并行计算、机器学习和数据挖掘、SaaS和云计算。先后在Cisco、eBay、Adobe等公司工作。博客为horicky.blogspot.com。 &nbsp; 导读 过去，一些用于存储大规模数据的数据存储机制逐渐成形，它们与RDBMS模型相去甚远，被统称为NoSQL。提炼出各种NoSQL方案背后共通的技术原理，有助于更深刻地理解它们对应用程序设计的内在影响。 过去，&nbsp;一 些 用 于 存 储大规模数据的数据存储机制逐渐成形。这些存储方案与RDBMS模型相去甚远，被统称为NoSQL。其中引人注目的主要角色有： ●&nbsp;Google BigTable, HBase, Hypertable ● Amazon Dynamo, Voldemort, Cassendra, Riak ● Redis ● CouchDB, MongoDB 上面列举的方案具有这样一些共同的特点： ●&nbsp;键/值存储； ●&nbsp;系统运行在数量巨大的普通机器上； ●&nbsp;数经过分区和复制，散布在大量的机器上； 放松了对数据一致性的约束。（因为CAP理论证明，一致性、可用性和分布不可能三者兼得。）本文意在提炼出以上方案背后共通的技术原理，以图更深刻地理解它们对应用程序设计的内在影响。 &nbsp; API模型 &nbsp; 底层的数据模型可以看作一个巨大的Hashtable（键/值存储）。访问Hashtable的API基本形式如下：get（key）：给定一个键，取得对应的值。put（key,&nbsp;value）：新建一个键/值对，或者更新给定的键对应的值。delete（key）：移除一个键及其对应的值。 &nbsp; 通过更高级的API，还可以在服务器环境中执行用户定义的函数。execute（key,&nbsp;operation,&nbsp;parameters）：（通过给定的键）对特定的值调用某操作，该值可以具有特殊的数据结构（如List、Set、Map……）。mapreduce（keyList,&nbsp;mapFunc,&nbsp;reduceFunc）：对给定范围的键调用Map/Reduce函数。 &nbsp; 机器布局 &nbsp; 整套硬件设施由大量（数百台、数千台……）便宜的、普通的、不可靠的机器通过网络连接而成。每台机器称为一个物理节点（PN）。每个PN上的软件配置是相同的，但CPU数量、内存、磁盘等硬件能力可能不同。在每个PN上，依据其硬件能力，运行着数量不等的虚拟节点（VN）。 &nbsp; 数据分区 &nbsp; （一致性散列）由于整个散列表分散在许多VN上，我们需要找一种方法将每个键映射到相应的VN。其中一种办法是用以下式子确定分区位置：分区&nbsp;=&nbsp;键&nbsp;mod总VN数量。这种方案的劣势在于当VN数量变化的时候，现有键的所有权（即位于哪个VN上）会发生极大的变化，全部数据都要重新分配到所有VN。因此多数大规模的存储都采用一种“一致性散列”的技巧去最小化所有权变更的数量。 &nbsp; 在&nbsp;一&nbsp;致&nbsp;性&nbsp;散&nbsp;列&nbsp;方&nbsp;案&nbsp;中&nbsp;，&nbsp;键&nbsp;空间是有限的，且落在一个圆周上。虚拟节点的ID也从同一个键空间中分配。对于任意键，如果从该键开始，沿着圆周顺时针走，遇到的第一个虚拟节点就是它所属的节点。 如果某个节点崩溃了，它所属的所有键都被移交到顺时针方向的相邻节点。因此，键的重新分配只发生在崩溃节点的邻居身上，其他节点仍然保留原有键不变。 &nbsp; 数据复制 &nbsp; 为了用单个来说并不可靠的资源提供更高的可靠性，我们需要复制数据分区。 复制（Replication）不仅提高了数据的整体可靠性，还由于将工作负载分散到多个副本（Replica）而对性能有所帮助。 只&nbsp;读&nbsp;请&nbsp;求&nbsp;可&nbsp;以&nbsp;分&nbsp;发&nbsp;到&nbsp;任&nbsp;意&nbsp;的副本，而更新请求的处理则较为困难，我们必须小心地协调各副本的更新。 &nbsp; 成员变更 &nbsp; 请注意虚拟节点可在任意时刻加入或离开网络，而不影响这个环的运作。 当新节点加入到网络 1．新加入的节点公告自身存在，将ID告知若干重要节点（或者简单地广播到所有节点）。 2．左右两侧的相邻节点调整键的所有权以及副本成员信息。这步骤通常是同步完成的。 3．新加入的节点开始从它的相邻节点并行、异步地批量复制数据。 4．副本成员的变更信息异步地传播到其他节点。 注意其他节点可能尚未更新其副本成员信息，因而继续向旧的节点转发请求。而因为旧节点（即新加入节点的邻居）已经掌握新节点的信息（第2步），它们会将请求转发给新加节点。 &nbsp; 另一方面，新加节点可能还处于下载数据的状态，尚不能提供服务。我们用“矢量时钟”（见后文）去确定新加节点是否已准备好处理请求，否则客户可以联系其他副本成员。 &nbsp; 当现有节点离开网络（比如当节点崩溃的时候） &nbsp; 1．崩溃的节点不再响应Gossip消息，因此它的邻居发现这一情况。 2．邻居更新成员信息，并异步地复制数据。 &nbsp; &nbsp;节点崩溃 我们尚未提及虚拟节点如何映射到物理节点。实际的方案有很多，主要目标是不让相同副本的各个虚拟节点落在同一个物理节点上。其中一种简单的方案是随机地将虚拟节点分配到物理节点，但增加一重检查，保证物理节点上不存在拥有相同键范围的副本。 &nbsp; 请注意，由于机器崩溃发生在物理节点的层次，意味着上面运行的许多虚拟节点一同崩溃。当这种情况发生的时候，（多个虚拟节点的）负载由很多台物理机器分担。因此由于物理节点崩溃而增加的负载被均匀地均衡掉了。 &nbsp; 客户端的一致性 &nbsp; 当我们拥有同一数据的多份副本，就有必要操心如何同步它们，才能使得在客户端看来，数据是一致的。有很多种客户端一致性模型： 1．严格一致性：语义上相当于只存在一份数据副本。任何更新看上去 都是即时发生的。 2．“读己之所写”一致性：客户端可立即看到自己所作的更新（且客户端可在不同请求之间切换服务器），但不能立即看到其他客户端所作的更新。 3．会话（Session）一致性：对于客户端在同一会话作用域中发起的请求（通常绑定到同一台服务器），提供“读己之所写”一致性。 4．单调读一致性：保证时间上的单调性，保证客户端在未来的请求中，只会读到比当前更为新的数据。 5．最终一致性：这是最弱的一种保证。在更新的过程中，客户端将看到一幅不一致的视图。当并发访问同一数据几率非常小的时候，此模型效果良好。 &nbsp; 客户端需要等待一段时间才能看到自己先前所作的更新。取决于采用何种一致性模型，需要安排两种机制：客户端请求如何分发到副本。副本如何传播及执行更新。围绕着如何实现这两方面，出现了许多模型，各有不同的权衡取舍。 &nbsp; 主从（或单主）模型 &nbsp; 在此模型下，每个数据分区都有一个主节点和多个从节点。所有更新请求都必须发给主节点，主节点执行更新后再异步地传播给从节点。如果主节点在将更新传播给任何从节点之前发生崩溃，就会出现一个丢失数据的时间窗口。因此有的系统会选择同步等待，到更新传播到至少一个从节点为止。 &nbsp; 如果客户端能容忍某种程度的旧数据，读请求可以分发到任何副本。负载因此可以分散到多个副本上。如果对于某些数据，客户端不能容忍取得非最新的数据，那就必须向主节点请求。 请注意此模型并不意味着某个物理节点扮演主节点的角色。主从关系发生在虚拟节点的层次。每个物理节点上，既有充当某分区主节点的虚拟节点，也有扮演其他分区从节点的虚拟节点。因此，写负载也被分散到不同的物理节点上，只不过这是由于分区的结果而非复制的结果。当一个物理节点崩溃时，将会失去特定分区的主节点。此时一般将更新最及时的从节点选为新的主节点。当应用的读/写比很高的时候，主从模型效果显著；当更新涉及的键范围分布均匀的时候，它的效果也很好。因为这些因素，大多数数据复制方案都选择了主从模型。 &nbsp; 更新由主节点传播到从节点有两种方式：传状态和传操作。如果是传状态，主节点将它的最新状态传递给从节点，然后从节点用得到的最新状态替换掉自己的当前状态。如果是传操作，主节点传递一系列操作给从节点，然后从节点对自己的本地状态执行操作。传状态模型更能抵御消息丢失的情况，因为只要后续的更新消息能正确抵达，副本仍然能成功更新到最新的状态。 &nbsp; 即使在传状态模型里，我们也不希望发送完整的对象给其他副本，因为通常修改的只是对象的一小部分。发送对象未变的部分等于浪费带宽。我们需要一种机制去检查并发送更新的部分。常见的做法是将对象打散成小块，并且计算出对象中各小块的一棵散列树。于是副本通过比较各自的散列树，就能知道对象中的哪些小块改动过了，只发送改动过的小块即可。 &nbsp; 一般来说，传操作模型需要通过网络发送的数据量较少。然而传操作模型需要一种可靠的消息机制去保证消息的传递顺序。 &nbsp; 多主（或无主）模型 如果某些键范围存在热点，写请求比较密集，主从模型没办法很好地将负载均匀地分散掉。多主模型允许将更新请求发送给任何副本（可能称之为无主模型更合适）。如果任意客户端可向任意服务器发出任意请求，那么我们如何同步状态，才能保持客户端的一致性，同时使所有副本最终都能达到相同的状态？下文将介绍几种办法。 &nbsp; 基于多数决的两段式提交 &nbsp; 为了实现“严格一致性”，我们可以采用传统的两段式提交（2PC）协议。假设某数据有N个副本。当更新数据的时候，有一个“预备”阶段，由协调者询问所有副本，是否已准备好执行各个更新。然后每个副本将数据写入日志文件，成功后通知协调者。收到所有副本的成功消息之后，协调者发起第二阶段——“提交”阶段，要求所有副本都完成提交，此时每个副本写入另一条日志条目确认更新。请注意这里存在一些可伸缩性的问题，因为协调者需要“同步地”等待很多轮网络消息来回，还要等待磁盘I/O完成。 &nbsp; 另一方面，如果某个副本崩溃了，更新将会失败。当副本的数量越多，其中之一发生问题的几率也越大。因此，数据复制反而损害了系统的可用性。所以传统的2PC在高吞吐量的事务系统中间并不流行。基&nbsp;于&nbsp;q&nbsp;u&nbsp;o&nbsp;r&nbsp;u&nbsp;m&nbsp;的&nbsp;2&nbsp;P&nbsp;C&nbsp;（&nbsp;如PAXOS）效率更高一些。在此模型中，协调者只需要同步更新W个副本（而非全部N个副本）。 &nbsp; 协调者仍旧写入全部N个副本，但只等待其中任意W个副本确认写入成功。站在概率的角度看，这种做法具有更高的效率。然而，由于并非全部副本都完成了更新，我们在读取数据的时候需要小心地保证读到的节点中至少有一个是成功更新过的。 &nbsp; 当读取数据的时候，我们需要读取R个副本，并返回其中时间戳最新的一个结果。为了保证“严格一致性”，只要保证读的集合与写的集合有重叠即可，也就是W&nbsp;+&nbsp;R&nbsp;&gt;&nbsp;N。你可能也想到了，基于多数决的2PC可以看作是2PC协议的一般化推广，传统的2PC是当W&nbsp;=&nbsp;N和R&nbsp;=&nbsp;1时的特例。一般化之后的模型使我们可以根据读写负载的比率，权衡选择不同的W和R。如果用户不能承受选取足够大的W和R，即当W&nbsp;+&nbsp;R&nbsp;&lt;=&nbsp;N的时候，那么客户端的一致性模型就要放宽到较弱的类型。 &nbsp; 如果客户端可以容忍较宽松的一致性模型，那么我们没必要采用上述的2PC提交或者基于多数决的协议。后文将介绍一种传言（Gossip）模型，通过异步的传言消息交换传播更新，使所有副本最终都达到最新的状态。 &nbsp; 矢量时钟 &nbsp; 矢量时钟是一种时间戳机制，透过它我们可以推导更新之间的因果关系。首先，每个副本都持有矢量时钟。假设副本i的时钟是Vi。Vi[i]是副本根据特定规则更新其矢量时钟之后的逻辑时钟。 当副本i执行了一则内部操作，副本i的时钟加一。当副本i向副本j发送一则消息，副本i首先把自己的时钟Vi[i]加一，并将自己的矢量时钟Vi附加到消息中发送出去。当副本j收到来自副本i的消息，它首先自增其时钟Vj[j]，然后合并其时钟及消息所附的时钟Vm。即Vj[k]&nbsp;=&nbsp;max（Vj[k],&nbsp;Vm[k]）。 &nbsp; 于是可定义偏序关系，Vi&nbsp;&gt;&nbsp;Vj，当且仅当对于所有的k，V&nbsp;i&nbsp;[&nbsp;k&nbsp;]&nbsp;&gt;&nbsp;=&nbsp;Vj[k]。根据这样的偏序关系，我们就可以推导出更新之间的因果关系。背后的原理是这样的：内部操作的效果可在同一节点上立即看到。 &nbsp; 接收到消息之后，接收节点得知发送节点在消息发送之时的情况。情况不仅包括了发送节点上发生的事情，还包括了发送节点所知的所有其他节点上发生的事情。换言之，Vi[i]反映了节点i上发生最后一次内部操作的时间。Vi[k]&nbsp;=&nbsp;6意味着副本i已经知道副本k在它的逻辑时钟6的时刻的情况。请注意这里是在一种抽象的意义上使用“情况（situation）”一词。取决于消息中传递何种信息，“情况”有不同的具体含义。情况的具体含义会影响如何增加矢量时钟。下文介绍的“传状态模型”和“传操作模型”在消息中传递的信息不一样，它们矢量时钟如何增加，也因此不同。 &nbsp; 由于状态总是从副本流向客户端，绝不会反过来，所以客户端不占矢量时钟的条目。矢量时钟里每个副本占一条。不过，客户端可以持有它最后联系的副本的矢量时钟，这对于实现我们先前讨论的客户端一致性甚为关键。例如，为了支持单调读一致性，副本可以保证附在数据上的矢量时钟大于客户端在查询时提交的矢量时钟。 &nbsp; 传言（传状态模型） &nbsp; 在传状态模型里，每个副本都维护着一个矢量时钟和一个状态的版本树，版本树中的状态无法（通过比较矢量时钟）得出状态之间的“大于”或“小于”关系。换言之，状态版本树包含了所有存在冲突的更新。 在查询的时候，客户端将它的矢量时钟一并提交，副本将状态树中早于客户端时钟的子集发回给客户端（这就实现了单调读一致性）。然后客户端通过合并所有的版本，增加其时钟。这意味着客户端要负责解决所有的版本冲突，因为当客户端稍后发送更新的时候，它的矢量时钟会早于所有的版本。 &nbsp; 在更新的时候，客户端发送它的矢量时钟，副本检查客户端的状态是否早于任意现有版本，如果是，副本将丢弃客户端的更新。各个副本还可以在后台互相传言，尝试将各自的版本树合并起来。 &nbsp; 在传操作方式下，执行操作的次序非常重要，至少需要保证因果序（causal&nbsp;order）。因为次序的关系，只要之前的操作还没执行完，副本就不得不推迟任何新的操作。因此副本需要将操作请求保存到一个日志文件，并彼此交换日志，通过统一合并日志推导出正确的操作序列，才能相应地更新各自的本地存储。 &nbsp; “ 因 果 序 ” 意 味 着 每 个 副 本要 先 完 成 对 “ 因 ” 的 修 改 才 能 执 行对“果”的修改。“全序（totalorder）”则要求每个副本都执行同一个序列中的操作。在此模型中，每个副本持有一个矢量时钟列表。Vi为副本自身的矢量时钟，Vj为副本i接收到副本j传言消息时的矢量时钟。V-state代表最后更新状态的矢量时钟。 &nbsp; 当客户端提交查询的时候，它会一并发送客户端的矢量时钟，这个时钟代表了客户端的视图。副本检查自己所知的状态是否迟于客户端所知的状态。 &nbsp; 当收到更新操作，副本会将操作缓冲起来，直到可以将之应用到本地状态。每个提交的操作都会带上两个时间戳，V-client标明客户端在其发出更新请求时的视图。V-@receive标明副本在收到请求时的视图。 &nbsp; 更新操作的请求会留在队列里，直到副本收到该请求所依赖的所有其他请求。这个条件反映在矢量时钟Vi上，即当Vi大于V-client时条件满足。 更新（传操作模型） &nbsp; 在后台，各个副本交换它们记录的更新队列日志并更新彼此的矢量时钟。在日志交换之后，副本检查特定的操作是否可以执行（当所有依赖操作都已收到），然后完成操作。请注意在同一时刻，有可能存在多个操作准备好执行，此时副本将按照因果序（通过比较矢量时钟）排列各操作，依次执行。还有可能发生不同副本上的并发更新问题。也就是说可能存在多个合法的操作序列，为了使不同副本以相同次序执行并发的更新，我们需要一种“全序”机制。 &nbsp; 其中一种方法是设立一个单调增加的序列号，不管哪个更新先执行都好，序列号先到先得。另一方面，如果操作本身是可以互换的，那么操作的执行次序也就无关紧要了。执行更新之后，更新操作还不能立即从队列中删除，因为更新可能还没有交换到到所有的副本。我们继续检查每次日志交换后每个副本的矢量时钟，直到确认所有副本都已收到更新，才可以将它从队列中删除。 &nbsp; Map Reduce的执行过程 &nbsp; 分布式的存储架构也适合分布式的处理。例如对一个键列表执行Map/Reduce操作的情况。 系统将Map和Reduce函数推送给所有的节点（即将处理逻辑向数据靠拢）。Map函数分布到键所属的各个副本上去处理，然后Map函数的输出被转交给Reduce函数去执行聚合操作。 &nbsp; 对删除的处理 在多主复制系统中，我们用矢量时钟时间戳去判定因果序，我们需要非常小心地处理“删除”的情况，以免丢失掉删除对象关联的时间戳信息，否则我们根本无法推导何时执行删除。 &nbsp; 因此，我们通常将删除当作一种特殊的更新来处理，把对象标记为删除，但仍然保留其元数据、时间戳信息。当经过足够长的时间，我们确信所有节点都已经将该对象标记为删除之后，我们才通过垃圾收集回收已删除对象的空间。 &nbsp; 福利 扫描添加小编微信，备注“姓名+公司职位”，加入【云计算学习交流群】，和志同道合的朋友们共同打卡学习！ 推荐阅读： VMware竟然出了一款防火墙 OpenStack网络的下一步原来这么走 | 技术头条 你的 AI 老师已上岗 要成为年薪百万的技术大牛必经历这5个阶段, 收好这份超实用的技术进阶指南 | 技术头条 助力&nbsp;Android&nbsp;抗衡&nbsp;iOS，华为发布方舟编译器！ 程序员的黑砖窑，东南亚博彩骗局详解 售价910元！周志华等人英文新书《演化学习》出炉！ 真香，朕在看了！" />
<meta property="og:description" content="戳蓝字“CSDN云计算”关注我们哦！ 时光机：搭载这部时光机，带您回顾《程序员》大量优秀文章，重温经典技术干货，我们发现硬核技术永不过时，对于get要点、solve难题、提高自我，仍有非凡意义。 作者：Richy&nbsp;Ho，一名软件架构师，热衷于分布式及并行计算、机器学习和数据挖掘、SaaS和云计算。先后在Cisco、eBay、Adobe等公司工作。博客为horicky.blogspot.com。 &nbsp; 导读 过去，一些用于存储大规模数据的数据存储机制逐渐成形，它们与RDBMS模型相去甚远，被统称为NoSQL。提炼出各种NoSQL方案背后共通的技术原理，有助于更深刻地理解它们对应用程序设计的内在影响。 过去，&nbsp;一 些 用 于 存 储大规模数据的数据存储机制逐渐成形。这些存储方案与RDBMS模型相去甚远，被统称为NoSQL。其中引人注目的主要角色有： ●&nbsp;Google BigTable, HBase, Hypertable ● Amazon Dynamo, Voldemort, Cassendra, Riak ● Redis ● CouchDB, MongoDB 上面列举的方案具有这样一些共同的特点： ●&nbsp;键/值存储； ●&nbsp;系统运行在数量巨大的普通机器上； ●&nbsp;数经过分区和复制，散布在大量的机器上； 放松了对数据一致性的约束。（因为CAP理论证明，一致性、可用性和分布不可能三者兼得。）本文意在提炼出以上方案背后共通的技术原理，以图更深刻地理解它们对应用程序设计的内在影响。 &nbsp; API模型 &nbsp; 底层的数据模型可以看作一个巨大的Hashtable（键/值存储）。访问Hashtable的API基本形式如下：get（key）：给定一个键，取得对应的值。put（key,&nbsp;value）：新建一个键/值对，或者更新给定的键对应的值。delete（key）：移除一个键及其对应的值。 &nbsp; 通过更高级的API，还可以在服务器环境中执行用户定义的函数。execute（key,&nbsp;operation,&nbsp;parameters）：（通过给定的键）对特定的值调用某操作，该值可以具有特殊的数据结构（如List、Set、Map……）。mapreduce（keyList,&nbsp;mapFunc,&nbsp;reduceFunc）：对给定范围的键调用Map/Reduce函数。 &nbsp; 机器布局 &nbsp; 整套硬件设施由大量（数百台、数千台……）便宜的、普通的、不可靠的机器通过网络连接而成。每台机器称为一个物理节点（PN）。每个PN上的软件配置是相同的，但CPU数量、内存、磁盘等硬件能力可能不同。在每个PN上，依据其硬件能力，运行着数量不等的虚拟节点（VN）。 &nbsp; 数据分区 &nbsp; （一致性散列）由于整个散列表分散在许多VN上，我们需要找一种方法将每个键映射到相应的VN。其中一种办法是用以下式子确定分区位置：分区&nbsp;=&nbsp;键&nbsp;mod总VN数量。这种方案的劣势在于当VN数量变化的时候，现有键的所有权（即位于哪个VN上）会发生极大的变化，全部数据都要重新分配到所有VN。因此多数大规模的存储都采用一种“一致性散列”的技巧去最小化所有权变更的数量。 &nbsp; 在&nbsp;一&nbsp;致&nbsp;性&nbsp;散&nbsp;列&nbsp;方&nbsp;案&nbsp;中&nbsp;，&nbsp;键&nbsp;空间是有限的，且落在一个圆周上。虚拟节点的ID也从同一个键空间中分配。对于任意键，如果从该键开始，沿着圆周顺时针走，遇到的第一个虚拟节点就是它所属的节点。 如果某个节点崩溃了，它所属的所有键都被移交到顺时针方向的相邻节点。因此，键的重新分配只发生在崩溃节点的邻居身上，其他节点仍然保留原有键不变。 &nbsp; 数据复制 &nbsp; 为了用单个来说并不可靠的资源提供更高的可靠性，我们需要复制数据分区。 复制（Replication）不仅提高了数据的整体可靠性，还由于将工作负载分散到多个副本（Replica）而对性能有所帮助。 只&nbsp;读&nbsp;请&nbsp;求&nbsp;可&nbsp;以&nbsp;分&nbsp;发&nbsp;到&nbsp;任&nbsp;意&nbsp;的副本，而更新请求的处理则较为困难，我们必须小心地协调各副本的更新。 &nbsp; 成员变更 &nbsp; 请注意虚拟节点可在任意时刻加入或离开网络，而不影响这个环的运作。 当新节点加入到网络 1．新加入的节点公告自身存在，将ID告知若干重要节点（或者简单地广播到所有节点）。 2．左右两侧的相邻节点调整键的所有权以及副本成员信息。这步骤通常是同步完成的。 3．新加入的节点开始从它的相邻节点并行、异步地批量复制数据。 4．副本成员的变更信息异步地传播到其他节点。 注意其他节点可能尚未更新其副本成员信息，因而继续向旧的节点转发请求。而因为旧节点（即新加入节点的邻居）已经掌握新节点的信息（第2步），它们会将请求转发给新加节点。 &nbsp; 另一方面，新加节点可能还处于下载数据的状态，尚不能提供服务。我们用“矢量时钟”（见后文）去确定新加节点是否已准备好处理请求，否则客户可以联系其他副本成员。 &nbsp; 当现有节点离开网络（比如当节点崩溃的时候） &nbsp; 1．崩溃的节点不再响应Gossip消息，因此它的邻居发现这一情况。 2．邻居更新成员信息，并异步地复制数据。 &nbsp; &nbsp;节点崩溃 我们尚未提及虚拟节点如何映射到物理节点。实际的方案有很多，主要目标是不让相同副本的各个虚拟节点落在同一个物理节点上。其中一种简单的方案是随机地将虚拟节点分配到物理节点，但增加一重检查，保证物理节点上不存在拥有相同键范围的副本。 &nbsp; 请注意，由于机器崩溃发生在物理节点的层次，意味着上面运行的许多虚拟节点一同崩溃。当这种情况发生的时候，（多个虚拟节点的）负载由很多台物理机器分担。因此由于物理节点崩溃而增加的负载被均匀地均衡掉了。 &nbsp; 客户端的一致性 &nbsp; 当我们拥有同一数据的多份副本，就有必要操心如何同步它们，才能使得在客户端看来，数据是一致的。有很多种客户端一致性模型： 1．严格一致性：语义上相当于只存在一份数据副本。任何更新看上去 都是即时发生的。 2．“读己之所写”一致性：客户端可立即看到自己所作的更新（且客户端可在不同请求之间切换服务器），但不能立即看到其他客户端所作的更新。 3．会话（Session）一致性：对于客户端在同一会话作用域中发起的请求（通常绑定到同一台服务器），提供“读己之所写”一致性。 4．单调读一致性：保证时间上的单调性，保证客户端在未来的请求中，只会读到比当前更为新的数据。 5．最终一致性：这是最弱的一种保证。在更新的过程中，客户端将看到一幅不一致的视图。当并发访问同一数据几率非常小的时候，此模型效果良好。 &nbsp; 客户端需要等待一段时间才能看到自己先前所作的更新。取决于采用何种一致性模型，需要安排两种机制：客户端请求如何分发到副本。副本如何传播及执行更新。围绕着如何实现这两方面，出现了许多模型，各有不同的权衡取舍。 &nbsp; 主从（或单主）模型 &nbsp; 在此模型下，每个数据分区都有一个主节点和多个从节点。所有更新请求都必须发给主节点，主节点执行更新后再异步地传播给从节点。如果主节点在将更新传播给任何从节点之前发生崩溃，就会出现一个丢失数据的时间窗口。因此有的系统会选择同步等待，到更新传播到至少一个从节点为止。 &nbsp; 如果客户端能容忍某种程度的旧数据，读请求可以分发到任何副本。负载因此可以分散到多个副本上。如果对于某些数据，客户端不能容忍取得非最新的数据，那就必须向主节点请求。 请注意此模型并不意味着某个物理节点扮演主节点的角色。主从关系发生在虚拟节点的层次。每个物理节点上，既有充当某分区主节点的虚拟节点，也有扮演其他分区从节点的虚拟节点。因此，写负载也被分散到不同的物理节点上，只不过这是由于分区的结果而非复制的结果。当一个物理节点崩溃时，将会失去特定分区的主节点。此时一般将更新最及时的从节点选为新的主节点。当应用的读/写比很高的时候，主从模型效果显著；当更新涉及的键范围分布均匀的时候，它的效果也很好。因为这些因素，大多数数据复制方案都选择了主从模型。 &nbsp; 更新由主节点传播到从节点有两种方式：传状态和传操作。如果是传状态，主节点将它的最新状态传递给从节点，然后从节点用得到的最新状态替换掉自己的当前状态。如果是传操作，主节点传递一系列操作给从节点，然后从节点对自己的本地状态执行操作。传状态模型更能抵御消息丢失的情况，因为只要后续的更新消息能正确抵达，副本仍然能成功更新到最新的状态。 &nbsp; 即使在传状态模型里，我们也不希望发送完整的对象给其他副本，因为通常修改的只是对象的一小部分。发送对象未变的部分等于浪费带宽。我们需要一种机制去检查并发送更新的部分。常见的做法是将对象打散成小块，并且计算出对象中各小块的一棵散列树。于是副本通过比较各自的散列树，就能知道对象中的哪些小块改动过了，只发送改动过的小块即可。 &nbsp; 一般来说，传操作模型需要通过网络发送的数据量较少。然而传操作模型需要一种可靠的消息机制去保证消息的传递顺序。 &nbsp; 多主（或无主）模型 如果某些键范围存在热点，写请求比较密集，主从模型没办法很好地将负载均匀地分散掉。多主模型允许将更新请求发送给任何副本（可能称之为无主模型更合适）。如果任意客户端可向任意服务器发出任意请求，那么我们如何同步状态，才能保持客户端的一致性，同时使所有副本最终都能达到相同的状态？下文将介绍几种办法。 &nbsp; 基于多数决的两段式提交 &nbsp; 为了实现“严格一致性”，我们可以采用传统的两段式提交（2PC）协议。假设某数据有N个副本。当更新数据的时候，有一个“预备”阶段，由协调者询问所有副本，是否已准备好执行各个更新。然后每个副本将数据写入日志文件，成功后通知协调者。收到所有副本的成功消息之后，协调者发起第二阶段——“提交”阶段，要求所有副本都完成提交，此时每个副本写入另一条日志条目确认更新。请注意这里存在一些可伸缩性的问题，因为协调者需要“同步地”等待很多轮网络消息来回，还要等待磁盘I/O完成。 &nbsp; 另一方面，如果某个副本崩溃了，更新将会失败。当副本的数量越多，其中之一发生问题的几率也越大。因此，数据复制反而损害了系统的可用性。所以传统的2PC在高吞吐量的事务系统中间并不流行。基&nbsp;于&nbsp;q&nbsp;u&nbsp;o&nbsp;r&nbsp;u&nbsp;m&nbsp;的&nbsp;2&nbsp;P&nbsp;C&nbsp;（&nbsp;如PAXOS）效率更高一些。在此模型中，协调者只需要同步更新W个副本（而非全部N个副本）。 &nbsp; 协调者仍旧写入全部N个副本，但只等待其中任意W个副本确认写入成功。站在概率的角度看，这种做法具有更高的效率。然而，由于并非全部副本都完成了更新，我们在读取数据的时候需要小心地保证读到的节点中至少有一个是成功更新过的。 &nbsp; 当读取数据的时候，我们需要读取R个副本，并返回其中时间戳最新的一个结果。为了保证“严格一致性”，只要保证读的集合与写的集合有重叠即可，也就是W&nbsp;+&nbsp;R&nbsp;&gt;&nbsp;N。你可能也想到了，基于多数决的2PC可以看作是2PC协议的一般化推广，传统的2PC是当W&nbsp;=&nbsp;N和R&nbsp;=&nbsp;1时的特例。一般化之后的模型使我们可以根据读写负载的比率，权衡选择不同的W和R。如果用户不能承受选取足够大的W和R，即当W&nbsp;+&nbsp;R&nbsp;&lt;=&nbsp;N的时候，那么客户端的一致性模型就要放宽到较弱的类型。 &nbsp; 如果客户端可以容忍较宽松的一致性模型，那么我们没必要采用上述的2PC提交或者基于多数决的协议。后文将介绍一种传言（Gossip）模型，通过异步的传言消息交换传播更新，使所有副本最终都达到最新的状态。 &nbsp; 矢量时钟 &nbsp; 矢量时钟是一种时间戳机制，透过它我们可以推导更新之间的因果关系。首先，每个副本都持有矢量时钟。假设副本i的时钟是Vi。Vi[i]是副本根据特定规则更新其矢量时钟之后的逻辑时钟。 当副本i执行了一则内部操作，副本i的时钟加一。当副本i向副本j发送一则消息，副本i首先把自己的时钟Vi[i]加一，并将自己的矢量时钟Vi附加到消息中发送出去。当副本j收到来自副本i的消息，它首先自增其时钟Vj[j]，然后合并其时钟及消息所附的时钟Vm。即Vj[k]&nbsp;=&nbsp;max（Vj[k],&nbsp;Vm[k]）。 &nbsp; 于是可定义偏序关系，Vi&nbsp;&gt;&nbsp;Vj，当且仅当对于所有的k，V&nbsp;i&nbsp;[&nbsp;k&nbsp;]&nbsp;&gt;&nbsp;=&nbsp;Vj[k]。根据这样的偏序关系，我们就可以推导出更新之间的因果关系。背后的原理是这样的：内部操作的效果可在同一节点上立即看到。 &nbsp; 接收到消息之后，接收节点得知发送节点在消息发送之时的情况。情况不仅包括了发送节点上发生的事情，还包括了发送节点所知的所有其他节点上发生的事情。换言之，Vi[i]反映了节点i上发生最后一次内部操作的时间。Vi[k]&nbsp;=&nbsp;6意味着副本i已经知道副本k在它的逻辑时钟6的时刻的情况。请注意这里是在一种抽象的意义上使用“情况（situation）”一词。取决于消息中传递何种信息，“情况”有不同的具体含义。情况的具体含义会影响如何增加矢量时钟。下文介绍的“传状态模型”和“传操作模型”在消息中传递的信息不一样，它们矢量时钟如何增加，也因此不同。 &nbsp; 由于状态总是从副本流向客户端，绝不会反过来，所以客户端不占矢量时钟的条目。矢量时钟里每个副本占一条。不过，客户端可以持有它最后联系的副本的矢量时钟，这对于实现我们先前讨论的客户端一致性甚为关键。例如，为了支持单调读一致性，副本可以保证附在数据上的矢量时钟大于客户端在查询时提交的矢量时钟。 &nbsp; 传言（传状态模型） &nbsp; 在传状态模型里，每个副本都维护着一个矢量时钟和一个状态的版本树，版本树中的状态无法（通过比较矢量时钟）得出状态之间的“大于”或“小于”关系。换言之，状态版本树包含了所有存在冲突的更新。 在查询的时候，客户端将它的矢量时钟一并提交，副本将状态树中早于客户端时钟的子集发回给客户端（这就实现了单调读一致性）。然后客户端通过合并所有的版本，增加其时钟。这意味着客户端要负责解决所有的版本冲突，因为当客户端稍后发送更新的时候，它的矢量时钟会早于所有的版本。 &nbsp; 在更新的时候，客户端发送它的矢量时钟，副本检查客户端的状态是否早于任意现有版本，如果是，副本将丢弃客户端的更新。各个副本还可以在后台互相传言，尝试将各自的版本树合并起来。 &nbsp; 在传操作方式下，执行操作的次序非常重要，至少需要保证因果序（causal&nbsp;order）。因为次序的关系，只要之前的操作还没执行完，副本就不得不推迟任何新的操作。因此副本需要将操作请求保存到一个日志文件，并彼此交换日志，通过统一合并日志推导出正确的操作序列，才能相应地更新各自的本地存储。 &nbsp; “ 因 果 序 ” 意 味 着 每 个 副 本要 先 完 成 对 “ 因 ” 的 修 改 才 能 执 行对“果”的修改。“全序（totalorder）”则要求每个副本都执行同一个序列中的操作。在此模型中，每个副本持有一个矢量时钟列表。Vi为副本自身的矢量时钟，Vj为副本i接收到副本j传言消息时的矢量时钟。V-state代表最后更新状态的矢量时钟。 &nbsp; 当客户端提交查询的时候，它会一并发送客户端的矢量时钟，这个时钟代表了客户端的视图。副本检查自己所知的状态是否迟于客户端所知的状态。 &nbsp; 当收到更新操作，副本会将操作缓冲起来，直到可以将之应用到本地状态。每个提交的操作都会带上两个时间戳，V-client标明客户端在其发出更新请求时的视图。V-@receive标明副本在收到请求时的视图。 &nbsp; 更新操作的请求会留在队列里，直到副本收到该请求所依赖的所有其他请求。这个条件反映在矢量时钟Vi上，即当Vi大于V-client时条件满足。 更新（传操作模型） &nbsp; 在后台，各个副本交换它们记录的更新队列日志并更新彼此的矢量时钟。在日志交换之后，副本检查特定的操作是否可以执行（当所有依赖操作都已收到），然后完成操作。请注意在同一时刻，有可能存在多个操作准备好执行，此时副本将按照因果序（通过比较矢量时钟）排列各操作，依次执行。还有可能发生不同副本上的并发更新问题。也就是说可能存在多个合法的操作序列，为了使不同副本以相同次序执行并发的更新，我们需要一种“全序”机制。 &nbsp; 其中一种方法是设立一个单调增加的序列号，不管哪个更新先执行都好，序列号先到先得。另一方面，如果操作本身是可以互换的，那么操作的执行次序也就无关紧要了。执行更新之后，更新操作还不能立即从队列中删除，因为更新可能还没有交换到到所有的副本。我们继续检查每次日志交换后每个副本的矢量时钟，直到确认所有副本都已收到更新，才可以将它从队列中删除。 &nbsp; Map Reduce的执行过程 &nbsp; 分布式的存储架构也适合分布式的处理。例如对一个键列表执行Map/Reduce操作的情况。 系统将Map和Reduce函数推送给所有的节点（即将处理逻辑向数据靠拢）。Map函数分布到键所属的各个副本上去处理，然后Map函数的输出被转交给Reduce函数去执行聚合操作。 &nbsp; 对删除的处理 在多主复制系统中，我们用矢量时钟时间戳去判定因果序，我们需要非常小心地处理“删除”的情况，以免丢失掉删除对象关联的时间戳信息，否则我们根本无法推导何时执行删除。 &nbsp; 因此，我们通常将删除当作一种特殊的更新来处理，把对象标记为删除，但仍然保留其元数据、时间戳信息。当经过足够长的时间，我们确信所有节点都已经将该对象标记为删除之后，我们才通过垃圾收集回收已删除对象的空间。 &nbsp; 福利 扫描添加小编微信，备注“姓名+公司职位”，加入【云计算学习交流群】，和志同道合的朋友们共同打卡学习！ 推荐阅读： VMware竟然出了一款防火墙 OpenStack网络的下一步原来这么走 | 技术头条 你的 AI 老师已上岗 要成为年薪百万的技术大牛必经历这5个阶段, 收好这份超实用的技术进阶指南 | 技术头条 助力&nbsp;Android&nbsp;抗衡&nbsp;iOS，华为发布方舟编译器！ 程序员的黑砖窑，东南亚博彩骗局详解 售价910元！周志华等人英文新书《演化学习》出炉！ 真香，朕在看了！" />
<link rel="canonical" href="https://mlh.app/2019/04/29/729040.html" />
<meta property="og:url" content="https://mlh.app/2019/04/29/729040.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"戳蓝字“CSDN云计算”关注我们哦！ 时光机：搭载这部时光机，带您回顾《程序员》大量优秀文章，重温经典技术干货，我们发现硬核技术永不过时，对于get要点、solve难题、提高自我，仍有非凡意义。 作者：Richy&nbsp;Ho，一名软件架构师，热衷于分布式及并行计算、机器学习和数据挖掘、SaaS和云计算。先后在Cisco、eBay、Adobe等公司工作。博客为horicky.blogspot.com。 &nbsp; 导读 过去，一些用于存储大规模数据的数据存储机制逐渐成形，它们与RDBMS模型相去甚远，被统称为NoSQL。提炼出各种NoSQL方案背后共通的技术原理，有助于更深刻地理解它们对应用程序设计的内在影响。 过去，&nbsp;一 些 用 于 存 储大规模数据的数据存储机制逐渐成形。这些存储方案与RDBMS模型相去甚远，被统称为NoSQL。其中引人注目的主要角色有： ●&nbsp;Google BigTable, HBase, Hypertable ● Amazon Dynamo, Voldemort, Cassendra, Riak ● Redis ● CouchDB, MongoDB 上面列举的方案具有这样一些共同的特点： ●&nbsp;键/值存储； ●&nbsp;系统运行在数量巨大的普通机器上； ●&nbsp;数经过分区和复制，散布在大量的机器上； 放松了对数据一致性的约束。（因为CAP理论证明，一致性、可用性和分布不可能三者兼得。）本文意在提炼出以上方案背后共通的技术原理，以图更深刻地理解它们对应用程序设计的内在影响。 &nbsp; API模型 &nbsp; 底层的数据模型可以看作一个巨大的Hashtable（键/值存储）。访问Hashtable的API基本形式如下：get（key）：给定一个键，取得对应的值。put（key,&nbsp;value）：新建一个键/值对，或者更新给定的键对应的值。delete（key）：移除一个键及其对应的值。 &nbsp; 通过更高级的API，还可以在服务器环境中执行用户定义的函数。execute（key,&nbsp;operation,&nbsp;parameters）：（通过给定的键）对特定的值调用某操作，该值可以具有特殊的数据结构（如List、Set、Map……）。mapreduce（keyList,&nbsp;mapFunc,&nbsp;reduceFunc）：对给定范围的键调用Map/Reduce函数。 &nbsp; 机器布局 &nbsp; 整套硬件设施由大量（数百台、数千台……）便宜的、普通的、不可靠的机器通过网络连接而成。每台机器称为一个物理节点（PN）。每个PN上的软件配置是相同的，但CPU数量、内存、磁盘等硬件能力可能不同。在每个PN上，依据其硬件能力，运行着数量不等的虚拟节点（VN）。 &nbsp; 数据分区 &nbsp; （一致性散列）由于整个散列表分散在许多VN上，我们需要找一种方法将每个键映射到相应的VN。其中一种办法是用以下式子确定分区位置：分区&nbsp;=&nbsp;键&nbsp;mod总VN数量。这种方案的劣势在于当VN数量变化的时候，现有键的所有权（即位于哪个VN上）会发生极大的变化，全部数据都要重新分配到所有VN。因此多数大规模的存储都采用一种“一致性散列”的技巧去最小化所有权变更的数量。 &nbsp; 在&nbsp;一&nbsp;致&nbsp;性&nbsp;散&nbsp;列&nbsp;方&nbsp;案&nbsp;中&nbsp;，&nbsp;键&nbsp;空间是有限的，且落在一个圆周上。虚拟节点的ID也从同一个键空间中分配。对于任意键，如果从该键开始，沿着圆周顺时针走，遇到的第一个虚拟节点就是它所属的节点。 如果某个节点崩溃了，它所属的所有键都被移交到顺时针方向的相邻节点。因此，键的重新分配只发生在崩溃节点的邻居身上，其他节点仍然保留原有键不变。 &nbsp; 数据复制 &nbsp; 为了用单个来说并不可靠的资源提供更高的可靠性，我们需要复制数据分区。 复制（Replication）不仅提高了数据的整体可靠性，还由于将工作负载分散到多个副本（Replica）而对性能有所帮助。 只&nbsp;读&nbsp;请&nbsp;求&nbsp;可&nbsp;以&nbsp;分&nbsp;发&nbsp;到&nbsp;任&nbsp;意&nbsp;的副本，而更新请求的处理则较为困难，我们必须小心地协调各副本的更新。 &nbsp; 成员变更 &nbsp; 请注意虚拟节点可在任意时刻加入或离开网络，而不影响这个环的运作。 当新节点加入到网络 1．新加入的节点公告自身存在，将ID告知若干重要节点（或者简单地广播到所有节点）。 2．左右两侧的相邻节点调整键的所有权以及副本成员信息。这步骤通常是同步完成的。 3．新加入的节点开始从它的相邻节点并行、异步地批量复制数据。 4．副本成员的变更信息异步地传播到其他节点。 注意其他节点可能尚未更新其副本成员信息，因而继续向旧的节点转发请求。而因为旧节点（即新加入节点的邻居）已经掌握新节点的信息（第2步），它们会将请求转发给新加节点。 &nbsp; 另一方面，新加节点可能还处于下载数据的状态，尚不能提供服务。我们用“矢量时钟”（见后文）去确定新加节点是否已准备好处理请求，否则客户可以联系其他副本成员。 &nbsp; 当现有节点离开网络（比如当节点崩溃的时候） &nbsp; 1．崩溃的节点不再响应Gossip消息，因此它的邻居发现这一情况。 2．邻居更新成员信息，并异步地复制数据。 &nbsp; &nbsp;节点崩溃 我们尚未提及虚拟节点如何映射到物理节点。实际的方案有很多，主要目标是不让相同副本的各个虚拟节点落在同一个物理节点上。其中一种简单的方案是随机地将虚拟节点分配到物理节点，但增加一重检查，保证物理节点上不存在拥有相同键范围的副本。 &nbsp; 请注意，由于机器崩溃发生在物理节点的层次，意味着上面运行的许多虚拟节点一同崩溃。当这种情况发生的时候，（多个虚拟节点的）负载由很多台物理机器分担。因此由于物理节点崩溃而增加的负载被均匀地均衡掉了。 &nbsp; 客户端的一致性 &nbsp; 当我们拥有同一数据的多份副本，就有必要操心如何同步它们，才能使得在客户端看来，数据是一致的。有很多种客户端一致性模型： 1．严格一致性：语义上相当于只存在一份数据副本。任何更新看上去 都是即时发生的。 2．“读己之所写”一致性：客户端可立即看到自己所作的更新（且客户端可在不同请求之间切换服务器），但不能立即看到其他客户端所作的更新。 3．会话（Session）一致性：对于客户端在同一会话作用域中发起的请求（通常绑定到同一台服务器），提供“读己之所写”一致性。 4．单调读一致性：保证时间上的单调性，保证客户端在未来的请求中，只会读到比当前更为新的数据。 5．最终一致性：这是最弱的一种保证。在更新的过程中，客户端将看到一幅不一致的视图。当并发访问同一数据几率非常小的时候，此模型效果良好。 &nbsp; 客户端需要等待一段时间才能看到自己先前所作的更新。取决于采用何种一致性模型，需要安排两种机制：客户端请求如何分发到副本。副本如何传播及执行更新。围绕着如何实现这两方面，出现了许多模型，各有不同的权衡取舍。 &nbsp; 主从（或单主）模型 &nbsp; 在此模型下，每个数据分区都有一个主节点和多个从节点。所有更新请求都必须发给主节点，主节点执行更新后再异步地传播给从节点。如果主节点在将更新传播给任何从节点之前发生崩溃，就会出现一个丢失数据的时间窗口。因此有的系统会选择同步等待，到更新传播到至少一个从节点为止。 &nbsp; 如果客户端能容忍某种程度的旧数据，读请求可以分发到任何副本。负载因此可以分散到多个副本上。如果对于某些数据，客户端不能容忍取得非最新的数据，那就必须向主节点请求。 请注意此模型并不意味着某个物理节点扮演主节点的角色。主从关系发生在虚拟节点的层次。每个物理节点上，既有充当某分区主节点的虚拟节点，也有扮演其他分区从节点的虚拟节点。因此，写负载也被分散到不同的物理节点上，只不过这是由于分区的结果而非复制的结果。当一个物理节点崩溃时，将会失去特定分区的主节点。此时一般将更新最及时的从节点选为新的主节点。当应用的读/写比很高的时候，主从模型效果显著；当更新涉及的键范围分布均匀的时候，它的效果也很好。因为这些因素，大多数数据复制方案都选择了主从模型。 &nbsp; 更新由主节点传播到从节点有两种方式：传状态和传操作。如果是传状态，主节点将它的最新状态传递给从节点，然后从节点用得到的最新状态替换掉自己的当前状态。如果是传操作，主节点传递一系列操作给从节点，然后从节点对自己的本地状态执行操作。传状态模型更能抵御消息丢失的情况，因为只要后续的更新消息能正确抵达，副本仍然能成功更新到最新的状态。 &nbsp; 即使在传状态模型里，我们也不希望发送完整的对象给其他副本，因为通常修改的只是对象的一小部分。发送对象未变的部分等于浪费带宽。我们需要一种机制去检查并发送更新的部分。常见的做法是将对象打散成小块，并且计算出对象中各小块的一棵散列树。于是副本通过比较各自的散列树，就能知道对象中的哪些小块改动过了，只发送改动过的小块即可。 &nbsp; 一般来说，传操作模型需要通过网络发送的数据量较少。然而传操作模型需要一种可靠的消息机制去保证消息的传递顺序。 &nbsp; 多主（或无主）模型 如果某些键范围存在热点，写请求比较密集，主从模型没办法很好地将负载均匀地分散掉。多主模型允许将更新请求发送给任何副本（可能称之为无主模型更合适）。如果任意客户端可向任意服务器发出任意请求，那么我们如何同步状态，才能保持客户端的一致性，同时使所有副本最终都能达到相同的状态？下文将介绍几种办法。 &nbsp; 基于多数决的两段式提交 &nbsp; 为了实现“严格一致性”，我们可以采用传统的两段式提交（2PC）协议。假设某数据有N个副本。当更新数据的时候，有一个“预备”阶段，由协调者询问所有副本，是否已准备好执行各个更新。然后每个副本将数据写入日志文件，成功后通知协调者。收到所有副本的成功消息之后，协调者发起第二阶段——“提交”阶段，要求所有副本都完成提交，此时每个副本写入另一条日志条目确认更新。请注意这里存在一些可伸缩性的问题，因为协调者需要“同步地”等待很多轮网络消息来回，还要等待磁盘I/O完成。 &nbsp; 另一方面，如果某个副本崩溃了，更新将会失败。当副本的数量越多，其中之一发生问题的几率也越大。因此，数据复制反而损害了系统的可用性。所以传统的2PC在高吞吐量的事务系统中间并不流行。基&nbsp;于&nbsp;q&nbsp;u&nbsp;o&nbsp;r&nbsp;u&nbsp;m&nbsp;的&nbsp;2&nbsp;P&nbsp;C&nbsp;（&nbsp;如PAXOS）效率更高一些。在此模型中，协调者只需要同步更新W个副本（而非全部N个副本）。 &nbsp; 协调者仍旧写入全部N个副本，但只等待其中任意W个副本确认写入成功。站在概率的角度看，这种做法具有更高的效率。然而，由于并非全部副本都完成了更新，我们在读取数据的时候需要小心地保证读到的节点中至少有一个是成功更新过的。 &nbsp; 当读取数据的时候，我们需要读取R个副本，并返回其中时间戳最新的一个结果。为了保证“严格一致性”，只要保证读的集合与写的集合有重叠即可，也就是W&nbsp;+&nbsp;R&nbsp;&gt;&nbsp;N。你可能也想到了，基于多数决的2PC可以看作是2PC协议的一般化推广，传统的2PC是当W&nbsp;=&nbsp;N和R&nbsp;=&nbsp;1时的特例。一般化之后的模型使我们可以根据读写负载的比率，权衡选择不同的W和R。如果用户不能承受选取足够大的W和R，即当W&nbsp;+&nbsp;R&nbsp;&lt;=&nbsp;N的时候，那么客户端的一致性模型就要放宽到较弱的类型。 &nbsp; 如果客户端可以容忍较宽松的一致性模型，那么我们没必要采用上述的2PC提交或者基于多数决的协议。后文将介绍一种传言（Gossip）模型，通过异步的传言消息交换传播更新，使所有副本最终都达到最新的状态。 &nbsp; 矢量时钟 &nbsp; 矢量时钟是一种时间戳机制，透过它我们可以推导更新之间的因果关系。首先，每个副本都持有矢量时钟。假设副本i的时钟是Vi。Vi[i]是副本根据特定规则更新其矢量时钟之后的逻辑时钟。 当副本i执行了一则内部操作，副本i的时钟加一。当副本i向副本j发送一则消息，副本i首先把自己的时钟Vi[i]加一，并将自己的矢量时钟Vi附加到消息中发送出去。当副本j收到来自副本i的消息，它首先自增其时钟Vj[j]，然后合并其时钟及消息所附的时钟Vm。即Vj[k]&nbsp;=&nbsp;max（Vj[k],&nbsp;Vm[k]）。 &nbsp; 于是可定义偏序关系，Vi&nbsp;&gt;&nbsp;Vj，当且仅当对于所有的k，V&nbsp;i&nbsp;[&nbsp;k&nbsp;]&nbsp;&gt;&nbsp;=&nbsp;Vj[k]。根据这样的偏序关系，我们就可以推导出更新之间的因果关系。背后的原理是这样的：内部操作的效果可在同一节点上立即看到。 &nbsp; 接收到消息之后，接收节点得知发送节点在消息发送之时的情况。情况不仅包括了发送节点上发生的事情，还包括了发送节点所知的所有其他节点上发生的事情。换言之，Vi[i]反映了节点i上发生最后一次内部操作的时间。Vi[k]&nbsp;=&nbsp;6意味着副本i已经知道副本k在它的逻辑时钟6的时刻的情况。请注意这里是在一种抽象的意义上使用“情况（situation）”一词。取决于消息中传递何种信息，“情况”有不同的具体含义。情况的具体含义会影响如何增加矢量时钟。下文介绍的“传状态模型”和“传操作模型”在消息中传递的信息不一样，它们矢量时钟如何增加，也因此不同。 &nbsp; 由于状态总是从副本流向客户端，绝不会反过来，所以客户端不占矢量时钟的条目。矢量时钟里每个副本占一条。不过，客户端可以持有它最后联系的副本的矢量时钟，这对于实现我们先前讨论的客户端一致性甚为关键。例如，为了支持单调读一致性，副本可以保证附在数据上的矢量时钟大于客户端在查询时提交的矢量时钟。 &nbsp; 传言（传状态模型） &nbsp; 在传状态模型里，每个副本都维护着一个矢量时钟和一个状态的版本树，版本树中的状态无法（通过比较矢量时钟）得出状态之间的“大于”或“小于”关系。换言之，状态版本树包含了所有存在冲突的更新。 在查询的时候，客户端将它的矢量时钟一并提交，副本将状态树中早于客户端时钟的子集发回给客户端（这就实现了单调读一致性）。然后客户端通过合并所有的版本，增加其时钟。这意味着客户端要负责解决所有的版本冲突，因为当客户端稍后发送更新的时候，它的矢量时钟会早于所有的版本。 &nbsp; 在更新的时候，客户端发送它的矢量时钟，副本检查客户端的状态是否早于任意现有版本，如果是，副本将丢弃客户端的更新。各个副本还可以在后台互相传言，尝试将各自的版本树合并起来。 &nbsp; 在传操作方式下，执行操作的次序非常重要，至少需要保证因果序（causal&nbsp;order）。因为次序的关系，只要之前的操作还没执行完，副本就不得不推迟任何新的操作。因此副本需要将操作请求保存到一个日志文件，并彼此交换日志，通过统一合并日志推导出正确的操作序列，才能相应地更新各自的本地存储。 &nbsp; “ 因 果 序 ” 意 味 着 每 个 副 本要 先 完 成 对 “ 因 ” 的 修 改 才 能 执 行对“果”的修改。“全序（totalorder）”则要求每个副本都执行同一个序列中的操作。在此模型中，每个副本持有一个矢量时钟列表。Vi为副本自身的矢量时钟，Vj为副本i接收到副本j传言消息时的矢量时钟。V-state代表最后更新状态的矢量时钟。 &nbsp; 当客户端提交查询的时候，它会一并发送客户端的矢量时钟，这个时钟代表了客户端的视图。副本检查自己所知的状态是否迟于客户端所知的状态。 &nbsp; 当收到更新操作，副本会将操作缓冲起来，直到可以将之应用到本地状态。每个提交的操作都会带上两个时间戳，V-client标明客户端在其发出更新请求时的视图。V-@receive标明副本在收到请求时的视图。 &nbsp; 更新操作的请求会留在队列里，直到副本收到该请求所依赖的所有其他请求。这个条件反映在矢量时钟Vi上，即当Vi大于V-client时条件满足。 更新（传操作模型） &nbsp; 在后台，各个副本交换它们记录的更新队列日志并更新彼此的矢量时钟。在日志交换之后，副本检查特定的操作是否可以执行（当所有依赖操作都已收到），然后完成操作。请注意在同一时刻，有可能存在多个操作准备好执行，此时副本将按照因果序（通过比较矢量时钟）排列各操作，依次执行。还有可能发生不同副本上的并发更新问题。也就是说可能存在多个合法的操作序列，为了使不同副本以相同次序执行并发的更新，我们需要一种“全序”机制。 &nbsp; 其中一种方法是设立一个单调增加的序列号，不管哪个更新先执行都好，序列号先到先得。另一方面，如果操作本身是可以互换的，那么操作的执行次序也就无关紧要了。执行更新之后，更新操作还不能立即从队列中删除，因为更新可能还没有交换到到所有的副本。我们继续检查每次日志交换后每个副本的矢量时钟，直到确认所有副本都已收到更新，才可以将它从队列中删除。 &nbsp; Map Reduce的执行过程 &nbsp; 分布式的存储架构也适合分布式的处理。例如对一个键列表执行Map/Reduce操作的情况。 系统将Map和Reduce函数推送给所有的节点（即将处理逻辑向数据靠拢）。Map函数分布到键所属的各个副本上去处理，然后Map函数的输出被转交给Reduce函数去执行聚合操作。 &nbsp; 对删除的处理 在多主复制系统中，我们用矢量时钟时间戳去判定因果序，我们需要非常小心地处理“删除”的情况，以免丢失掉删除对象关联的时间戳信息，否则我们根本无法推导何时执行删除。 &nbsp; 因此，我们通常将删除当作一种特殊的更新来处理，把对象标记为删除，但仍然保留其元数据、时间戳信息。当经过足够长的时间，我们确信所有节点都已经将该对象标记为删除之后，我们才通过垃圾收集回收已删除对象的空间。 &nbsp; 福利 扫描添加小编微信，备注“姓名+公司职位”，加入【云计算学习交流群】，和志同道合的朋友们共同打卡学习！ 推荐阅读： VMware竟然出了一款防火墙 OpenStack网络的下一步原来这么走 | 技术头条 你的 AI 老师已上岗 要成为年薪百万的技术大牛必经历这5个阶段, 收好这份超实用的技术进阶指南 | 技术头条 助力&nbsp;Android&nbsp;抗衡&nbsp;iOS，华为发布方舟编译器！ 程序员的黑砖窑，东南亚博彩骗局详解 售价910元！周志华等人英文新书《演化学习》出炉！ 真香，朕在看了！","@type":"BlogPosting","url":"https://mlh.app/2019/04/29/729040.html","headline":"一文读懂NoSQL的模式 时光机","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/29/729040.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>一文读懂NoSQL的模式 | 时光机</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <h2 style="white-space: normal;max-width: 100%;letter-spacing: 0.544px;widows: 1;text-align: right;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;" data-mpa-powered-by="yiban.io"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(171, 25, 66);"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;letter-spacing: 0.544px;color: rgb(121, 121, 121);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">戳蓝字“</span></strong></span><span style="max-width: 100%;color: rgb(0, 128, 255);"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;letter-spacing: 0.544px;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">CSDN云计算</span></strong></span><span style="max-width: 100%;color: rgb(171, 25, 66);"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;letter-spacing: 0.544px;color: rgb(121, 121, 121);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">”关注我们哦！</span></strong></span></span><br></h2> 
<p style="text-align: center;"><img class="rich_pages" data-copyright="0" data-ratio="0.5910493827160493" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJbPBhJsCEnbzmiaRTriaVTW0jRJM8iaibCzCEk4Y4z9icc9Rq6smvEHwa0pg/640?wx_fmt=jpeg" data-type="jpeg" data-w="648" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJbPBhJsCEnbzmiaRTriaVTW0jRJM8iaibCzCEk4Y4z9icc9Rq6smvEHwa0pg/640?wx_fmt=jpeg"></p> 
<section powered-by="xiumi.us" style="white-space: normal;box-sizing: border-box;line-height: 30px;widows: 1;background-color: rgb(255, 255, 255);max-width: 100%;letter-spacing: 0.54px;font-size: 15px;word-wrap: break-word !important;"> 
 <section style="box-sizing: border-box;max-width: 100%;word-wrap: break-word !important;"> 
  <section> 
   <section powered-by="xiumi.us" style="box-sizing: border-box;line-height: 30px;max-width: 100%;letter-spacing: 0.54px;word-wrap: break-word !important;"> 
    <section style="box-sizing: border-box;max-width: 100%;word-wrap: break-word !important;"> 
     <section> 
      <section powered-by="xiumi.us" style="box-sizing: border-box;line-height: 30px;max-width: 100%;letter-spacing: 0.54px;word-wrap: break-word !important;"> 
       <section style="box-sizing: border-box;max-width: 100%;word-wrap: break-word !important;"> 
        <section> 
         <blockquote style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
          <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;line-height: 1.75em;min-height: 1em;max-width: 100%;letter-spacing: 1px;box-sizing: border-box !important;word-wrap: break-word !important;"><strong><span style="letter-spacing: 0.54px;color: rgb(0, 82, 255);">时光机：搭载这部时光机，带您回顾《程序员》大量优秀文章，重温经典技术干货，我们发现硬核技术永不过时，对于get要点、solve难题、提高自我，仍有非凡意义。</span></strong></p> 
         </blockquote> 
        </section> 
       </section> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section> 
<p style="max-width: 100%;min-height: 1em;letter-spacing: 0.544px;line-height: 27.2px;white-space: normal;widows: 1;background-color: rgb(255, 255, 255);margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 14px;box-sizing: border-box !important;word-wrap: break-word !important;">作者：Richy&nbsp;Ho，一名软件架构师，热衷于分布式及并行计算、机器学习和数据挖掘、SaaS和云计算。先后在Cisco、eBay、Adobe等公司工作。博客为horicky.blogspot.com。</span></p> 
<p><span style="color: rgb(35, 31, 32);font-size: 13px;font-family: 微软雅黑;"></span></p> 
<p><span style="font-family:Calibri;font-size:14px;">&nbsp;</span></p> 
<p style="margin-right: 8px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 0.544px;line-height: 27.2px;widows: 1;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><br></p> 
<section powered-by="xiumi.us" style="white-space: normal;max-width: 100%;box-sizing: border-box;color: rgb(63, 63, 63);font-size: 15px;letter-spacing: 0.544px;line-height: 30px;widows: 1;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"> 
 <section style="margin-top: -24px;margin-bottom: 10px;max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"> 
  <section style="padding: 0.1em 0.3em;max-width: 100%;box-sizing: border-box;display: inline-block;border-width: 2px;border-style: solid;border-color: rgba(255, 255, 255, 0);color: rgb(255, 255, 255);font-size: 14px;line-height: 1.8;background-color: rgb(83, 122, 195);word-wrap: break-word !important;"> 
   <p style="max-width: 100%;box-sizing: border-box;min-height: 1em;word-wrap: break-word !important;">导读</p> 
  </section> 
 </section> 
</section> 
<section powered-by="xiumi.us" style="white-space: normal;max-width: 100%;box-sizing: border-box;color: rgb(63, 63, 63);font-size: 15px;letter-spacing: 0.544px;line-height: 30px;widows: 1;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"> 
 <section style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"> 
  <section style="max-width: 100%;box-sizing: border-box;color: rgb(62, 62, 62);line-height: 1.8;word-wrap: break-word !important;"> 
   <p style="max-width: 100%;box-sizing: border-box;min-height: 1em;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(136, 136, 136);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-family: 微软雅黑;font-size: 14px;">过去，一些用于存储大规模数据的数据存储机制逐渐成形，它们与RDBMS模型相去甚远，被统称为NoSQL。提炼出各种NoSQL方案背后共通的技术原理，有助于更深刻地理解它们对应用程序设计的内在影响。</span><strong style="white-space: normal;"><span style="font-family: 微软雅黑;font-size: 14px;"></span></strong></span></p> 
  </section> 
 </section> 
</section> 
<section powered-by="xiumi.us" style="white-space: normal;max-width: 100%;box-sizing: border-box;color: rgb(63, 63, 63);font-size: 15px;letter-spacing: 0.544px;line-height: 30px;widows: 1;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"> 
 <section style="margin-top: 8px;margin-bottom: 10px;max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"> 
  <section style="max-width: 100%;box-sizing: border-box;height: 1px;background-color: rgb(105, 143, 187);word-wrap: break-word !important;"></section> 
 </section> 
</section> 
<p style="max-width: 100%;min-height: 1em;letter-spacing: 0.544px;line-height: 27.2px;white-space: normal;widows: 1;background-color: rgb(255, 255, 255);margin-left: 8px;margin-right: 8px;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;"></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;font-family: 微软雅黑;"><span style="font-family: 微软雅黑;">过去，</span>&nbsp;<span style="font-family: 微软雅黑;">一</span> <span style="font-family: 微软雅黑;">些</span> <span style="font-family: 微软雅黑;">用</span> <span style="font-family: 微软雅黑;">于</span> <span style="font-family: 微软雅黑;">存</span> <span style="font-family: 微软雅黑;">储大规模数据的数据存储机制逐渐成形。这些存储方案与</span>RDBMS模型相去甚远，被统称为NoSQL。其中引人注目的主要角色有：</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><span style="font-size: 15px;font-family: arial;text-align: start;background-color: rgb(255, 255, 255);">●&nbsp;</span>Google BigTable, HBase, Hypertable</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><span style="font-size: 15px;font-family: arial;text-align: start;background-color: rgb(255, 255, 255);">●</span> Amazon Dynamo, Voldemort, Cassendra, Riak</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><span style="font-size: 15px;font-family: arial;text-align: start;background-color: rgb(255, 255, 255);">●</span> Redis</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><span style="font-size: 15px;font-family: arial;text-align: start;background-color: rgb(255, 255, 255);">●</span> CouchDB, MongoDB</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">上面列举的方案具有这样一些共同的特点：</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><span style="font-size: 15px;font-family: arial;text-align: start;background-color: rgb(255, 255, 255);">●</span>&nbsp;键/值存储；</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><span style="font-size: 15px;font-family: arial;text-align: start;background-color: rgb(255, 255, 255);">●</span>&nbsp;系统运行在数量巨大的普通机器上；</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><span style="font-size: 15px;font-family: arial;text-align: start;background-color: rgb(255, 255, 255);">●</span>&nbsp;数经过分区和复制，散布在大量的机器上；</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">放松了对数据一致性的约束。（因为CAP理论证明，一致性、可用性和分布不可能三者兼得。）本文意在提炼出以上方案背后共通的技术原理，以图更深刻地理解它们对应用程序设计的内在影响。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">API模型</span></strong></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">底层的数据模型可以看作一个巨大的Hashtable（键/值存储）。访问Hashtable的API基本形式如下：get（key）：给定一个键，取得对应的值。put（key,&nbsp;value）：新建一个键/值对，或者更新给定的键对应的值。delete（key）：移除一个键及其对应的值。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">通过更高级的API，还可以在服务器环境中执行用户定义的函数。execute（key,&nbsp;operation,&nbsp;parameters）：（通过给定的键）对特定的值调用某操作，该值可以具有特殊的数据结构（如List、Set、Map……）。mapreduce（keyList,&nbsp;mapFunc,&nbsp;reduceFunc）：对给定范围的键调用Map/Reduce函数。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">机器布局</span></strong><span style="font-family: 微软雅黑;font-size: 15px;"></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">整套硬件设施由大量（数百台、数千台……）便宜的、普通的、不可靠的机器通过网络连接而成。每台机器称为一个物理节点（PN）。每个PN上的软件配置是相同的，但CPU数量、内存、磁盘等硬件能力可能不同。在每个PN上，依据其硬件能力，运行着数量不等的虚拟节点（VN）。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">数据分区</span></strong><span style="font-family: 微软雅黑;font-size: 15px;"></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">（一致性散列）由于整个散列表分散在许多VN上，我们需要找一种方法将每个键映射到相应的VN。其中一种办法是用以下式子确定分区位置：分区&nbsp;=&nbsp;键&nbsp;mod总VN数量。这种方案的劣势在于当VN数量变化的时候，现有键的所有权（即位于哪个VN上）会发生极大的变化，全部数据都要重新分配到所有VN。因此多数大规模的存储都采用一种“一致性散列”的技巧去最小化所有权变更的数量。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">在&nbsp;一&nbsp;致&nbsp;性&nbsp;散&nbsp;列&nbsp;方&nbsp;案&nbsp;中&nbsp;，&nbsp;键&nbsp;空间是有限的，且落在一个圆周上。虚拟节点的ID也从同一个键空间中分配。对于任意键，如果从该键开始，沿着圆周顺时针走，遇到的第一个虚拟节点就是它所属的节点。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">如果某个节点崩溃了，它所属的所有键都被移交到顺时针方向的相邻节点。因此，键的重新分配只发生在崩溃节点的邻居身上，其他节点仍然保留原有键不变。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.6125" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/zxoLaeCI28Sk6bGVHsN927otJaTocQsJT7icrtHJVn39eR4Yd3E1SsRm5B7hAEU8gJ0HkM6BC8amE6MxaGj37SQ/640?wx_fmt=png" data-type="png" data-w="320" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/zxoLaeCI28Sk6bGVHsN927otJaTocQsJT7icrtHJVn39eR4Yd3E1SsRm5B7hAEU8gJ0HkM6BC8amE6MxaGj37SQ/640?wx_fmt=png"></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);"><strong>数据复制</strong></span><span style="font-family: 微软雅黑;font-size: 15px;"></span><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">为了用单个来说并不可靠的资源提供更高的可靠性，我们需要复制数据分区。</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.775" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJC8yVibdaXkMYglxkoNX22Fbia1p0W7fhPibsRsoAfl8rMGPKgG8sGlClg/640?wx_fmt=jpeg" data-type="jpeg" data-w="320" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJC8yVibdaXkMYglxkoNX22Fbia1p0W7fhPibsRsoAfl8rMGPKgG8sGlClg/640?wx_fmt=jpeg"></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">复制（Replication）不仅提高了数据的整体可靠性，还由于将工作负载分散到多个副本（Replica）而对性能有所帮助。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">只&nbsp;读&nbsp;请&nbsp;求&nbsp;可&nbsp;以&nbsp;分&nbsp;发&nbsp;到&nbsp;任&nbsp;意&nbsp;的副本，而更新请求的处理则较为困难，我们必须小心地协调各副本的更新。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">成员变更</span></strong><span style="font-family: 微软雅黑;font-size: 15px;"></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">请注意虚拟节点可在任意时刻加入或离开网络，而不影响这个环的运作。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;">当新节点加入到网络</span></strong></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">1．新加入的节点公告自身存在，将ID告知若干重要节点（或者简单地广播到所有节点）。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">2．左右两侧的相邻节点调整键的所有权以及副本成员信息。这步骤通常是同步完成的。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">3．新加入的节点开始从它的相邻节点并行、异步地批量复制数据。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">4．副本成员的变更信息异步地传播到其他节点。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">注意其他节点可能尚未更新其副本成员信息，因而继续向旧的节点转发请求。而因为旧节点（即新加入节点的邻居）已经掌握新节点的信息（第2步），它们会将请求转发给新加节点。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">另一方面，新加节点可能还处于下载数据的状态，尚不能提供服务。我们用“矢量时钟”（见后文）去确定新加节点是否已准备好处理请求，否则客户可以联系其他副本成员。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;">当现有节点离开网络（比如当节点崩溃的时候）</span></strong></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">1．崩溃的节点不再响应Gossip消息，因此它的邻居发现这一情况。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">2．邻居更新成员信息，并异步地复制数据。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.728125" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJx1aD8DEiapa1XyBnibzG0UlXPiadfYAuNVTP5QMROn9SJ8PN7KMUl0MFQ/640?wx_fmt=jpeg" data-type="jpeg" data-w="320" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJx1aD8DEiapa1XyBnibzG0UlXPiadfYAuNVTP5QMROn9SJ8PN7KMUl0MFQ/640?wx_fmt=jpeg"><br><span style="font-family: 微软雅黑;font-size: 15px;text-align: justify;">&nbsp;节点崩溃</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">我们尚未提及虚拟节点如何映射到物理节点。实际的方案有很多，主要目标是不让相同副本的各个虚拟节点落在同一个物理节点上。其中一种简单的方案是随机地将虚拟节点分配到物理节点，但增加一重检查，保证物理节点上不存在拥有相同键范围的副本。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">请注意，由于机器崩溃发生在物理节点的层次，意味着上面运行的许多虚拟节点一同崩溃。当这种情况发生的时候，（多个虚拟节点的）负载由很多台物理机器分担。因此由于物理节点崩溃而增加的负载被均匀地均衡掉了。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">客户端的一致性</span></strong></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">当我们拥有同一数据的多份副本，就有必要操心如何同步它们，才能使得在客户端看来，数据是一致的。有很多种客户端一致性模型：</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">1．严格一致性：语义上相当于只存在一份数据副本。任何更新看上去</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">都是即时发生的。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">2．“读己之所写”一致性：客户端可立即看到自己所作的更新（且客户端可在不同请求之间切换服务器），但不能立即看到其他客户端所作的更新。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">3．会话（Session）一致性：对于客户端在同一会话作用域中发起的请求（通常绑定到同一台服务器），提供“读己之所写”一致性。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">4．单调读一致性：保证时间上的单调性，保证客户端在未来的请求中，只会读到比当前更为新的数据。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">5．最终一致性：这是最弱的一种保证。在更新的过程中，客户端将看到一幅不一致的视图。当并发访问同一数据几率非常小的时候，此模型效果良好。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">客户端需要等待一段时间才能看到自己先前所作的更新。取决于采用何种一致性模型，需要安排两种机制：客户端请求如何分发到副本。副本如何传播及执行更新。围绕着如何实现这两方面，出现了许多模型，各有不同的权衡取舍。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">主从（或单主）模型</span></strong></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">在此模型下，每个数据分区都有一个主节点和多个从节点。所有更新请求都必须发给主节点，主节点执行更新后再异步地传播给从节点。如果主节点在将更新传播给任何从节点之前发生崩溃，就会出现一个丢失数据的时间窗口。因此有的系统会选择同步等待，到更新传播到至少一个从节点为止。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">如果客户端能容忍某种程度的旧数据，读请求可以分发到任何副本。负载因此可以分散到多个副本上。如果对于某些数据，客户端不能容忍取得非最新的数据，那就必须向主节点请求。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">请注意此模型并不意味着某个物理节点扮演主节点的角色。主从关系发生在虚拟节点的层次。每个物理节点上，既有充当某分区主节点的虚拟节点，也有扮演其他分区从节点的虚拟节点。因此，写负载也被分散到不同的物理节点上，只不过这是由于分区的结果而非复制的结果。当一个物理节点崩溃时，将会失去特定分区的主节点。此时一般将更新最及时的从节点选为新的主节点。当应用的读/写比很高的时候，主从模型效果显著；当更新涉及的键范围分布均匀的时候，它的效果也很好。因为这些因素，大多数数据复制方案都选择了主从模型。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">更新由主节点传播到从节点有两种方式：传状态和传操作。如果是传状态，主节点将它的最新状态传递给从节点，然后从节点用得到的最新状态替换掉自己的当前状态。如果是传操作，主节点传递一系列操作给从节点，然后从节点对自己的本地状态执行操作。传状态模型更能抵御消息丢失的情况，因为只要后续的更新消息能正确抵达，副本仍然能成功更新到最新的状态。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">即使在传状态模型里，我们也不希望发送完整的对象给其他副本，因为通常修改的只是对象的一小部分。发送对象未变的部分等于浪费带宽。我们需要一种机制去检查并发送更新的部分。常见的做法是将对象打散成小块，并且计算出对象中各小块的一棵散列树。于是副本通过比较各自的散列树，就能知道对象中的哪些小块改动过了，只发送改动过的小块即可。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">一般来说，传操作模型需要通过网络发送的数据量较少。然而传操作模型需要一种可靠的消息机制去保证消息的传递顺序。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="color: rgb(0, 82, 255);"><strong><span style="font-family: 微软雅黑;font-size: 15px;">多主（或无主）模型</span></strong></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">如果某些键范围存在热点，写请求比较密集，主从模型没办法很好地将负载均匀地分散掉。多主模型允许将更新请求发送给任何副本（可能称之为无主模型更合适）。如果任意客户端可向任意服务器发出任意请求，那么我们如何同步状态，才能保持客户端的一致性，同时使所有副本最终都能达到相同的状态？下文将介绍几种办法。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">基于多数决的两段式提交</span></strong></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">为了实现“严格一致性”，我们可以采用传统的两段式提交（2PC）协议。假设某数据有N个副本。当更新数据的时候，有一个“预备”阶段，由协调者询问所有副本，是否已准备好执行各个更新。然后每个副本将数据写入日志文件，成功后通知协调者。收到所有副本的成功消息之后，协调者发起第二阶段——“提交”阶段，要求所有副本都完成提交，此时每个副本写入另一条日志条目确认更新。请注意这里存在一些可伸缩性的问题，因为协调者需要“同步地”等待很多轮网络消息来回，还要等待磁盘I/O完成。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">另一方面，如果某个副本崩溃了，更新将会失败。当副本的数量越多，其中之一发生问题的几率也越大。因此，数据复制反而损害了系统的可用性。所以传统的2PC在高吞吐量的事务系统中间并不流行。基&nbsp;于&nbsp;q&nbsp;u&nbsp;o&nbsp;r&nbsp;u&nbsp;m&nbsp;的&nbsp;2&nbsp;P&nbsp;C&nbsp;（&nbsp;如PAXOS）效率更高一些。在此模型中，协调者只需要同步更新W个副本（而非全部N个副本）。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">协调者仍旧写入全部N个副本，但只等待其中任意W个副本确认写入成功。站在概率的角度看，这种做法具有更高的效率。然而，由于并非全部副本都完成了更新，我们在读取数据的时候需要小心地保证读到的节点中至少有一个是成功更新过的。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">当读取数据的时候，我们需要读取R个副本，并返回其中时间戳最新的一个结果。为了保证“严格一致性”，只要保证读的集合与写的集合有重叠即可，也就是W&nbsp;+&nbsp;R&nbsp;&gt;&nbsp;N。你可能也想到了，基于多数决的2PC可以看作是2PC协议的一般化推广，传统的2PC是当W&nbsp;=&nbsp;N和R&nbsp;=&nbsp;1时的特例。一般化之后的模型使我们可以根据读写负载的比率，权衡选择不同的W和R。</span><span style="font-size: 15px;font-family: 微软雅黑;">如果用户不能承受选取足够大的W和R，即当W&nbsp;+&nbsp;R&nbsp;&lt;=&nbsp;N的时候，那么客户端的一致性模型就要放宽到较弱的类型。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">如果客户端可以容忍较宽松的一致性模型，那么我们没必要采用上述的2PC提交或者基于多数决的协议。后文将介绍一种传言（Gossip）模型，通过异步的传言消息交换传播更新，使所有副本最终都达到最新的状态。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">矢量时钟</span></strong></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">矢量时钟是一种时间戳机制，透过它我们可以推导更新之间的因果关系。首先，每个副本都持有矢量时钟。假设副本i的时钟是Vi。Vi[i]是副本根据特定规则更新其矢量时钟之后的逻辑时钟。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">当副本i执行了一则内部操作，副本i的时钟加一。当副本i向副本j发送一则消息，副本i首先把自己的时钟Vi[i]加一，并将自己的矢量时钟Vi附加到消息中发送出去。当副本j收到来自副本i的消息，它首先自增其时钟Vj[j]，然后合并其时钟及消息所附的时钟Vm。即Vj[k]&nbsp;=&nbsp;max（Vj[k],&nbsp;Vm[k]）。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.684375" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJ9BD9uAY4ia6dcqUMW3tLhXjJEyJMquBEb0H0EypRmQm5HdHDYbYGDrQ/640?wx_fmt=jpeg" data-type="jpeg" data-w="320" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJ9BD9uAY4ia6dcqUMW3tLhXjJEyJMquBEb0H0EypRmQm5HdHDYbYGDrQ/640?wx_fmt=jpeg"></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">于是可定义偏序关系，Vi&nbsp;&gt;&nbsp;Vj，当且仅当对于所有的k，V&nbsp;i&nbsp;[&nbsp;k&nbsp;]&nbsp;&gt;&nbsp;=&nbsp;Vj[k]。根据这样的偏序关系，我们就可以推导出更新之间的因果关系。背后的原理是这样的：内部操作的效果可在同一节点上立即看到。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">接收到消息之后，接收节点得知发送节点在消息发送之时的情况。情况不仅包括了发送节点上发生的事情，还包括了发送节点所知的所有其他节点上发生的事情。换言之，Vi[i]反映了节点i上发生最后一次内部操作的时间。Vi[k]&nbsp;=&nbsp;6意味着副本i已经知道副本k在它的逻辑时钟6的时刻的情况。请注意这里是在一种抽象的意义上使用“情况（situation）”一词。取决于消息中传递何种信息，“情况”有不同的具体含义。情况的具体含义会影响如何增加矢量时钟。下文介绍的“传状态模型”和“传操作模型”在消息中传递的信息不一样，它们矢量时钟如何增加，也因此不同。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">由于状态总是从副本流向客户端，绝不会反过来，所以客户端不占矢量时钟的条目。矢量时钟里每个副本占一条。不过，客户端可以持有它最后联系的副本的矢量时钟，这对于实现我们先前讨论的客户端一致性甚为关键。例如，为了支持单调读一致性，副本可以保证附在数据上的矢量时钟大于客户端在查询时提交的矢量时钟。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">传言（传状态模型）</span></strong></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">在传状态模型里，每个副本都维护着一个矢量时钟和一个状态的版本树，版本树中的状态无法（通过比较矢量时钟）得出状态之间的“大于”或“小于”关系。换言之，状态版本树包含了所有存在冲突的更新。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">在查询的时候，客户端将它的矢量时钟一并提交，副本将状态树中早于客户端时钟的子集发回给客户端（这就实现了单调读一致性）。然后客户端通过合并所有的版本，增加其时钟。这意味着客户端要负责解决所有的版本冲突，因为当客户端稍后发送更新的时候，它的矢量时钟会早于所有的版本。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="1.0230179028132993" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJcmHhOVqNpPQiclTtWDdjWzYNibDxaxCRDXKaP2BamEhFITs5ySTAMKEw/640?wx_fmt=jpeg" data-type="jpeg" data-w="391" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJcmHhOVqNpPQiclTtWDdjWzYNibDxaxCRDXKaP2BamEhFITs5ySTAMKEw/640?wx_fmt=jpeg"></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">在更新的时候，客户端发送它的矢量时钟，副本检查客户端的状态是否早于任意现有版本，如果是，副本将丢弃客户端的更新。各个副本还可以在后台互相传言，尝试将各自的版本树合并起来。</span><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.9375" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJRIiaGNMNc7tQxWBkjH2bMic7RzGaDjdjf1UV4ia4vXdNYjrY2HmQsJhJQ/640?wx_fmt=jpeg" data-type="jpeg" data-w="400" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJRIiaGNMNc7tQxWBkjH2bMic7RzGaDjdjf1UV4ia4vXdNYjrY2HmQsJhJQ/640?wx_fmt=jpeg"></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="1.103448275862069" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJuDIHnAZ0icGiaaWY5GV8gCTQRWDxKTN2vEzPjMryGkicCY9Ne3IBEu5Wg/640?wx_fmt=jpeg" data-type="jpeg" data-w="290" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJuDIHnAZ0icGiaaWY5GV8gCTQRWDxKTN2vEzPjMryGkicCY9Ne3IBEu5Wg/640?wx_fmt=jpeg"></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">在传操作方式下，执行操作的次序非常重要，至少需要保证因果序（causal&nbsp;order）。因为次序的关系，只要之前的操作还没执行完，副本就不得不推迟任何新的操作。因此副本需要将操作请求保存到一个日志文件，并彼此交换日志，通过统一合并日志推导出正确的操作序列，才能相应地更新各自的本地存储。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">“ 因 果 序 ” 意 味 着 每 个 副 本要 先 完 成 对 “ 因 ” 的 修 改 才 能 执</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">行对“果”的修改。“全序（totalorder）”则要求每个副本都执行同一个序列中的操作。在此模型中，每个副本持有一个矢量时钟列表。Vi为副本自身的矢量时钟，Vj为副本i接收到副本j传言消息时的矢量时钟。V-state代表最后更新状态的矢量时钟。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">当客户端提交查询的时候，它会一并发送客户端的矢量时钟，这个时钟代表了客户端的视图。副本检查自己所知的状态是否迟于客户端所知的状态。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">当收到更新操作，副本会将操作缓冲起来，直到可以将之应用到本地状态。每个提交的操作都会带上两个时间戳，V-client标明客户端在其发出更新请求时的视图。V-@receive标明副本在收到请求时的视图。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="1.0638297872340425" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJYeKctKzn5UryP2D4dSlknLoXGfCxibfxibI1g5reEIcbibQmXQPXvozDQ/640?wx_fmt=jpeg" data-type="jpeg" data-w="376" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJYeKctKzn5UryP2D4dSlknLoXGfCxibfxibI1g5reEIcbibQmXQPXvozDQ/640?wx_fmt=jpeg"></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">更新操作的请求会留在队列里，直到副本收到该请求所依赖的所有其他请求。这个条件反映在矢量时钟Vi上，即当Vi大于V-client时条件满足。</span><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.8825" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJiao6iaTL4m7U1PDH2GonicJYkT5NroPBkaIibib7jb4OHPXRMR2BDJylnkA/640?wx_fmt=jpeg" data-type="jpeg" data-w="400" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJiao6iaTL4m7U1PDH2GonicJYkT5NroPBkaIibib7jb4OHPXRMR2BDJylnkA/640?wx_fmt=jpeg"></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">更新（传操作模型）</span></strong><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">在后台，各个副本交换它们记录的更新队列日志并更新彼此的矢量时钟。在日志交换之后，副本检查特定的操作是否可以执行（当所有依赖操作都已收到），然后完成操作。请注意在同一时刻，有可能存在多个操作准备好执行，此时副本将按照因果序（通过比较矢量时钟）排列各操作，依次执行。还有可能发生不同副本上的并发更新问题。也就是说可能存在多个合法的操作序列，为了使不同副本以相同次序执行并发的更新，我们需要一种“全序”机制。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.8975" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJaoORlC7Sib37u2SZLJSh6sb2opXWNNSHMvKY3dALcXhlCuI1Oos7now/640?wx_fmt=jpeg" data-type="jpeg" data-w="400" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJaoORlC7Sib37u2SZLJSh6sb2opXWNNSHMvKY3dALcXhlCuI1Oos7now/640?wx_fmt=jpeg"></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">其中一种方法是设立一个单调增加的序列号，不管哪个更新先执行都好，序列号先到先得。另一方面，如果操作本身是可以互换的，那么操作的执行次序也就无关紧要了。执行更新之后，更新操作还不能立即从队列中删除，因为更新可能还没有交换到到所有的副本。我们继续检查每次日志交换后每个副本的矢量时钟，直到确认所有副本都已收到更新，才可以将它从队列中删除。</span><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">Map Reduce的执行过程</span></strong></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">分布式的存储架构也适合分布式的处理。例如对一个键列表执行Map/Reduce操作的情况。</span></p> 
<p><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">系统将Map和Reduce函数推送给所有的节点（即将处理逻辑向数据靠拢）。Map函数分布到键所属的各个副本上去处理，然后Map函数的输出被转交给Reduce函数去执行聚合操作。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.83125" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJmSdgEIspOyllsoibf2xkME61Vm6bziaSWVbVVibDVgtGy231qVGrcj9icw/640?wx_fmt=jpeg" data-type="jpeg" data-w="320" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28Sk6bGVHsN927otJaTocQsJmSdgEIspOyllsoibf2xkME61Vm6bziaSWVbVVibDVgtGy231qVGrcj9icw/640?wx_fmt=jpeg"></p> 
<p style="text-align: center;"><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><strong><span style="font-family: 微软雅黑;font-size: 15px;color: rgb(0, 82, 255);">对删除的处理</span></strong></p> 
<p><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">在多主复制系统中，我们用矢量时钟时间戳去判定因果序，我们需要非常小心地处理“删除”的情况，以免丢失掉删除对象关联的时间戳信息，否则我们根本无法推导何时执行删除。</span><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">因此，我们通常将删除当作一种特殊的更新来处理，把对象标记为删除，但仍然保留其元数据、时间戳信息。当经过足够长的时间，我们确信所有节点都已经将该对象标记为删除之后，我们才通过垃圾收集回收已删除对象的空间。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="margin-right: 8px;margin-left: 8px;white-space: normal;font-size: 15px;letter-spacing: 0.544px;widows: 1;max-width: 100%;min-height: 1em;line-height: 27.2px;text-align: center;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><br></p> 
<p style="margin-right: 8px;margin-left: 8px;white-space: normal;font-size: 15px;letter-spacing: 0.544px;widows: 1;max-width: 100%;min-height: 1em;line-height: 27.2px;text-align: center;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.04523809523809524" data-s="300,640" data-type="png" data-w="420" data-src="https://mmbiz.qpic.cn/mmbiz_png/1hReHaqafafJYoFH7OAhmUdTjo35vvJTy1lRVjG2CzFP3arfVRDqI7a8PSS6Sx5LialaFTE1HFu2N4OIhL8jP9g/640?wx_fmt=png" style="letter-spacing: 0.544px;line-height: 29.75px;box-sizing: border-box !important;word-wrap: break-word !important;width: 420px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/1hReHaqafafJYoFH7OAhmUdTjo35vvJTy1lRVjG2CzFP3arfVRDqI7a8PSS6Sx5LialaFTE1HFu2N4OIhL8jP9g/640?wx_fmt=png"><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-left: 8px;white-space: normal;font-size: 15px;letter-spacing: 0.544px;widows: 1;max-width: 100%;min-height: 1em;line-height: 27.2px;text-align: center;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><br></p> 
<p style="margin-right: 8px;margin-left: 8px;white-space: normal;font-size: 15px;letter-spacing: 0.544px;widows: 1;max-width: 100%;min-height: 1em;line-height: 1.4;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="padding: 0.2em 0.5em;max-width: 100%;border-radius: 0.3em;color: white;font-size: 1em;font-family: inherit;font-weight: inherit;text-align: inherit;text-decoration: inherit;background-color: rgb(255, 105, 31);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">福利</span></strong></p> 
<section class="" style="margin-top: -0.7em;font-size: 1em;white-space: normal;letter-spacing: 0.544px;widows: 1;max-width: 100%;line-height: 27.2px;border-width: 1px;border-style: solid;border-color: rgb(255, 105, 31);border-radius: 0.4em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
 <section style="padding: 1.4em 1em 1em;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
  <section style="max-width: 100%;font-size: 1em;font-family: inherit;text-align: inherit;text-decoration: inherit;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
   <p style="margin-right: 8px;margin-left: 8px;max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">扫描添加小编微信，备注“</span></strong><span style="max-width: 100%;color: rgb(255, 104, 39);box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">姓名+公司职位</span></strong></span><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">”，加入【</span></strong><span style="max-width: 100%;color: rgb(255, 104, 39);box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">云计算学习交流群</span></strong></span><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">】，和志同道合的朋友们共同打卡学习！</span></strong></p> 
   <p style="margin-right: 8px;margin-left: 8px;max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
   <p style="text-align: center;"><img class="rich_pages" data-copyright="0" data-ratio="1.005813953488372" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28QDZW3ZeMemRs5PPyI20qxP8zicUCD67ia0kT4tk9BTQ6OaiaGTrvMQzl6sfmlRmFhKBcuibvRsxg3ktA/640?wx_fmt=jpeg" data-type="jpeg" data-w="516" style="height: 156px;width: 155px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28QDZW3ZeMemRs5PPyI20qxP8zicUCD67ia0kT4tk9BTQ6OaiaGTrvMQzl6sfmlRmFhKBcuibvRsxg3ktA/640?wx_fmt=jpeg"></p> 
  </section> 
 </section> 
</section> 
<p style="margin-right: 8px;margin-left: 8px;white-space: normal;font-size: 15px;letter-spacing: 0.544px;widows: 1;max-width: 100%;min-height: 1em;line-height: 1.75em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><br></p> 
<p style="margin-right: 8px;margin-left: 8px;white-space: normal;font-size: 15px;letter-spacing: 0.544px;widows: 1;max-width: 100%;min-height: 1em;line-height: 1.75em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;text-indent: 28px;font-family: arial, 宋体, sans-serif;letter-spacing: 1px;overflow-wrap: break-word;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;letter-spacing: 0.5px;overflow-wrap: break-word;box-sizing: border-box !important;word-wrap: break-word !important;">推荐阅读：</span></strong></p> 
<ul class=" list-paddingleft-2" style="margin-left: 8px;margin-right: 8px;"> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MzA3MjY1MTQwNQ==&amp;mid=2649827174&amp;idx=2&amp;sn=4f88b8e74b46cba88417d428a67240af&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">VMware竟然出了一款防火墙</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MzA3MjY1MTQwNQ==&amp;mid=2649827174&amp;idx=1&amp;sn=c9e9045a7d8bfb547ee08424e64ea073&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">OpenStack网络的下一步原来这么走 | 技术头条</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MDA4NDkxMQ==&amp;mid=2247483862&amp;idx=1&amp;sn=17a6e29b14b3a32ee54745ffb1526b4f&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">你的 AI 老师已上岗</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247494382&amp;idx=1&amp;sn=c52199e337caaf1c8d2ac8f6e47ffd40&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">要成为年薪百万的技术大牛必经历这5个阶段, 收好这份超实用的技术进阶指南 | 技术头条</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650718298&amp;idx=1&amp;sn=e1d6e4ac62ffb6ba1b3699126ed1114a&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">助力&nbsp;Android&nbsp;抗衡&nbsp;iOS，华为发布方舟编译器！</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&amp;mid=2651010270&amp;idx=1&amp;sn=8eaff3374818df60301b9a792579b49b&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">程序员的黑砖窑，东南亚博彩骗局详解</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&amp;mid=2247504435&amp;idx=1&amp;sn=0786d6ddcaa81d2076217ec6561d32fa&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;font-size: 15px;" data-linktype="2">售价910元！周志华等人英文新书《演化学习》出炉！</a><br></h2></li> 
</ul> 
<section data-role="outer" label="Powered by 135editor.com" style="white-space: normal;font-size: 15px;letter-spacing: 0.544px;widows: 1;max-width: 100%;line-height: 27.2px;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"> 
 <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
  <section class="" data-tools="135编辑器" data-id="94174" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
   <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
    <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;letter-spacing: 0.544px;line-height: 27.2px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
     <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
      <section class="" data-tools="135编辑器" data-id="94174" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
       <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
        <section style="max-width: 100%;text-align: right;box-sizing: border-box !important;word-wrap: break-word !important;"> 
         <br> 
        </section> 
        <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;letter-spacing: 0.544px;line-height: 27.2px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
         <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
          <section class="" data-tools="135编辑器" data-id="94174" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
           <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
            <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;letter-spacing: 0.544px;line-height: 27.2px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
             <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
              <section class="" data-tools="135编辑器" data-id="94174" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
               <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                <section style="max-width: 100%;text-align: right;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                 <section style="margin-top: -6.4px;margin-left: -16px;max-width: 197px;font-family: 微软雅黑;font-size: 16px;letter-spacing: 0.544px;line-height: 25.6px;float: right;transform: matrix(1, 0, 0, 1, 0, 0);width: 16px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                  <img class="" data-ratio="1" data-type="png" data-w="23" data-width="100%" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAujO0pvtNCLzZCiaWxGBfq2xaPwze1NRLTSQZYbzWNnTJwDwsReHiam91Wojzvw3RLibjicWkLWJjicgsvw/640?wx_fmt=png" style="max-width: 16px;display: block;box-sizing: border-box !important;word-wrap: break-word !important;visibility: visible !important;width: 15.99px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAujO0pvtNCLzZCiaWxGBfq2xaPwze1NRLTSQZYbzWNnTJwDwsReHiam91Wojzvw3RLibjicWkLWJjicgsvw/640?wx_fmt=png"> 
                 </section> 
                 <section data-brushtype="text" style="padding: 10px 16px;max-width: 197px;font-family: 微软雅黑;font-size: 16px;line-height: 25.6px;border-radius: 10px;color: rgb(73, 73, 72);display: inline-block;font-weight: 700;letter-spacing: 1.5px;text-align: center;background: none 0% 0% / auto repeat scroll padding-box border-box rgb(253, 245, 13);box-sizing: border-box !important;word-wrap: break-word !important;"> 
                  <span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">真香，朕在看了！</span> 
                 </section> 
                </section> 
               </section> 
              </section> 
             </section> 
            </section> 
           </section> 
          </section> 
         </section> 
        </section> 
       </section> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
