<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>iOS App冷启动治理：来自美团外卖的实践 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="iOS App冷启动治理：来自美团外卖的实践" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="总第309篇 2018年 第101篇 本文主要分享美团外卖iOS客户端针对App冷启动性能进行治理的一些经验。 招聘：美团外卖长期招聘Android、iOS、FE高级/资深工程师和技术专家，Base北京、上海、成都，欢迎有兴趣的同学扫描并识别下方二维码查看岗位详情。 扫码查看职位详情，一键投递简历 一、背景 冷启动时长是App性能的重要指标，作为用户体验的第一道“门”，直接决定着用户对App的第一印象。美团外卖iOS客户端从2013年11月开始，历经几十个版本的迭代开发，产品形态不断完善，业务功能日趋复杂；同时外卖App也已经由原来的独立业务App演进成为一个平台App，陆续接入了闪购、跑腿等其他新业务。因此，更多更复杂的工作需要在App冷启动的时候被完成，这给App的冷启动性能带来了挑战。对此，我们团队基于业务形态的变化和外卖App的特点，对冷启动进行了持续且有针对性的优化工作，目的就是为了呈现更加流畅的用户体验。 二、冷启动定义 一般而言，大家把iOS冷启动的过程定义为：从用户点击App图标开始到appDelegate didFinishLaunching方法执行完成为止。这个过程主要分为两个阶段： T1：main()函数之前，即操作系统加载App可执行文件到内存，然后执行一系列的加载&amp;链接等工作，最后执行至App的main()函数。 T2：main()函数之后，即从main()开始，到appDelegate的didFinishLaunchingWithOptions方法执行完毕。 然而，当didFinishLaunchingWithOptions执行完成时，用户还没有看到App的主界面，也不能开始使用App。例如在外卖App中，App还需要做一些初始化工作，然后经历定位、首页请求、首页渲染等过程后，用户才能真正看到数据内容并开始使用，我们认为这个时候冷启动才算完成。我们把这个过程定义为T3。 综上，外卖App把冷启动过程定义为：从用户点击App图标开始到用户能看到App主界面内容为止这个过程，即T1+T2+T3。在App冷启动过程当中，这三个阶段中的每个阶段都存在很多可以被优化的点。 三、问题现状 性能存量问题 美团外卖iOS客户端经过几十个版本的迭代开发后，在冷启动过程中已经积累了若干性能问题，解决这些性能瓶颈是冷启动优化工作的首要目标，这些问题主要包括： 注：启动项的定义，在App启动过程中需要被完成的某项工作，我们称之为一个启动项。例如某个SDK的初始化、某个功能的预加载等。 性能增量问题 一般情况下，在App早期阶段，冷启动不会有明显的性能问题。冷启动性能问题也不是在某个版本突然出现的，而是随着版本迭代，App功能越来越复杂，启动任务越来越多，冷启动时间也一点点延长。最后当我们注意到，并想要优化它的时候，这个问题已经变得很棘手了。外卖App的性能问题增量主要来自启动项的增加，随着版本迭代，启动项任务简单粗暴地堆积在启动流程中。如果每个版本冷启动时间增加0.1s，那么几个版本下来，冷启动时长就会明显增加很多。 四、治理思路 冷启动性能问题的治理目标主要有三个： 解决存量问题：优化当前性能瓶颈点，优化启动流程，缩短冷启动时间。 管控增量问题：冷启动流程规范化，通过代码范式和文档指导后续冷启动过程代码的维护，控制时间增量。 完善监控：完善冷启动性能指标监控，收集更详细的数据，及时发现性能问题。 五、规范启动流程 截止至2017年底，美团外卖用户数已达2.5亿，而美团外卖App也已完成了从支撑单一业务的App到支持多业务的平台型App的演进（美团外卖iOS多端复用的推动、支撑与思考），公司的一些新兴业务也陆续集成到外卖App当中。下面是外卖App的架构图，外卖的架构主要分为三层，底层是基础组件层，中层是外卖平台层，平台层向下管理基础组件，向上为业务组件提供统一的适配接口，上层是基础组件层，包括外卖业务拆分的子业务组件（外卖App和美团App中的外卖频道可以复用子业务组件）和接入的其他非外卖业务。 App的平台化为业务方提供了高效、标准的统一平台，但与此同时，平台化和业务的快速迭代也给冷启动带来了问题： 现有的启动项堆积严重，拖慢启动速度。 新的启动项缺乏添加范式，杂乱无章，修改风险大，难以阅读和维护。 面对这个问题，我们首先梳理了目前启动流程中所有的启动项，然后针对App平台化设计了新的启动项管理方式：分阶段启动和启动项自注册。 分阶段启动 早期由于业务比较简单，所有启动项都是不加以区分，简单地堆积到didFinishLaunchingWithOptions方法中，但随着业务的增加，越来越多的启动项代码堆积在一起，性能较差，代码臃肿而混乱。 通过对SDK的梳理和分析，我们发现启动项也需要根据所完成的任务被分类，有些启动项是需要刚启动就执行的操作，如Crash监控、统计上报等，否则会导致信息收集的缺失；有些启动项需要在较早的时间节点完成，例如一些提供用户信息的SDK、定位功能的初始化、网络初始化等；有些启动项则可以被延迟执行，如一些自定义配置，一些业务服务的调用、支付SDK、地图SDK等。我们所做的分阶段启动，首先就是把启动流程合理地划分为若干个启动阶段，然后依据每个启动项所做的事情的优先级把它们分配到相应的启动阶段，优先级高的放在靠前的阶段，优先级低的放在靠后的阶段。 下面是我们对美团外卖App启动阶段进行的重新定义，对所有启动项进行的梳理和重新分类，把它们对应到合理的启动阶段。这样做一方面可以推迟执行那些不必过早执行的启动项，缩短启动时间；另一方面，把启动项进行归类，方便后续的阅读和维护。然后把这些规则落地为启动项的维护文档，指导后续启动项的新增和维护。 通过上面的工作，我们梳理出了十几个可以推迟执行的启动项，占所有启动项的30%左右，有效地优化了启动项所占的这部分冷启动时间。 启动项自注册 确定了启动项分阶段启动的方案后，我们面对的问题就是如何执行这些启动项。比较容易想到的方案是：在启动时创建一个启动管理器，然后读取所有启动项，然后当时间节点到来时由启动器触发启动项执行。这种方式存在两个问题： 所有启动项都要预先写到一个文件中（在.m文件import，或用.plist文件组织），这种中心化的写法会导致臃肿的代码，难以阅读维护。 启动项代码无法复用：启动项无法收敛到子业务库内部，在外卖App和美团App中要重复实现，和外卖App平台化的方向不符。 而我们希望的方式是，启动项维护方式可插拔，启动项之间、业务模块之间不耦合，且一次实现可在两端复用。下图是我们采用的启动项管理方式，我们称之为启动项的自注册：一个启动项定义在子业务模块内部，被封装成一个方法，并且自声明启动阶段（例如一个启动项A，在独立App中可以声明为在willFinishLaunch阶段被执行，在美团App中则声明在resignActive阶段被执行）。这种方式下，启动项即实现了两端复用，不相关的启动项互相隔离，添加/删除启动项都更加方便。 那么如何给一个启动项声明启动阶段？又如何在正确的时机触发启动项的执行呢？在代码上，一个启动项最终都会对应到一个函数的执行，所以在运行时只要能获取到函数的指针，就可以触发启动项。美团平台开发的组件启动治理基建Kylin正是这样做的：Kylin的核心思想就是在编译时把数据（如函数指针）写入到可执行文件的__DATA段中，运行时再从__DATA段取出数据进行相应的操作（调用函数）。 为什么要用借用__DATA段呢？原因就是为了能够覆盖所有的启动阶段，例如main()之前的阶段。 Kylin实现原理简述：Clang 提供了很多的编译器函数，它们可以完成不同的功能。其中一种就是 section() 函数，section()函数提供了二进制段的读写能力，它可以将一些编译期就可以确定的常量写入数据段。 在具体的实现中，主要分为编译期和运行时两个部分。在编译期，编译器会将标记了 attribute((section())) 的数据写到指定的数据段中，例如写一个{key(key代表不同的启动阶段), *pointer}对到数据段。到运行时，在合适的时间节点，在根据key读取出函数指针，完成函数的调用。 上述方式，可以封装成一个宏，来达到代码的简化，以调用宏 KLN_STRINGS_EXPORT(&quot;Key&quot;, &quot;Value&quot;)为例，最终会被展开为： __attribute__((used,&nbsp;section(&quot;__DATA&quot;&nbsp;&quot;,&quot;&nbsp;&quot;__kylin__&quot;)))&nbsp;static&nbsp;const&nbsp;KLN_DATA&nbsp;__kylin__0&nbsp;=&nbsp;(KLN_DATA){(KLN_DATA_HEADER){&quot;Key&quot;,&nbsp;KLN_STRING,&nbsp;KLN_IS_ARRAY},&nbsp;&quot;Value&quot;}; 使用示例，编译器把启动项函数注册到启动阶段A： KLN_FUNCTIONS_EXPORT(STAGE_KEY_A)()&nbsp;{&nbsp;//&nbsp;在a.m文件中，通过注册宏，把启动项A声明为在STAGE_KEY_A阶段执行&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;启动项代码A} KLN_FUNCTIONS_EXPORT(STAGE_KEY_A)()&nbsp;{&nbsp;//&nbsp;在b.m文件中，把启动项B声明为在STAGE_KEY_A阶段执行&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;启动项代码B} 在启动流程中，在启动阶段STAGE_KEY_A触发所有注册到STAGE_KEY_A时间节点的启动项，通过对这种方式，几乎没有任何额外的辅助代码，我们用一种很简洁的方式完成了启动项的自注册。 -&nbsp;(BOOL)application:(UIApplication&nbsp;*)application&nbsp;didFinishLaunchingWithOptions:(NSDictionary&nbsp;*)launchOptions&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其他逻辑&nbsp;&nbsp;&nbsp;&nbsp;[[KLNKylin&nbsp;sharedInstance]&nbsp;executeArrayForKey:STAGE_KEY_A];&nbsp;&nbsp;//&nbsp;在此触发所有注册到STAGE_KEY_A时间节点的启动项&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其他逻辑&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;YES;} 完成对现有的启动项的梳理和优化后，我们也输出了后续启动项的添加&amp;维护规范，规范后续启动项的分类原则，优先级和启动阶段。目的是管控性能问题增量，保证优化成果。 六、优化main()之前 在调用main()函数之前，基本所有的工作都是由操作系统完成的，开发者能够插手的地方不多，所以如果想要优化这段时间，就必须先了解一下，操作系统在main()之前做了什么。main()之前操作系统所做的工作就是把可执行文件（Mach-O格式）加载到内存空间，然后加载动态链接库dyld，再执行一系列动态链接操作和初始化操作的过程（加载、绑定、及初始化方法）。这方面的资料网上比较多，但重复性较高，此处附上一篇WWDC的Topic：Optimizing App Startup Time。 加载过程—从exec()到main() 真正的加载过程从exec()函数开始，exec()是一个系统调用。操作系统首先为进程分配一段内存空间，然后执行如下操作： 把App对应的可执行文件加载到内存。 把Dyld加载到内存。 Dyld进行动态链接。 下面我们简要分析一下Dyld在各阶段所做的事情： 最后 dyld 会调用 main() 函数，main() 会调用 UIApplicationMain()，before main()的过程也就此完成。 了解完main()之前的加载过程后，我们可以分析出一些影响T1时间的因素： 动态库加载越多，启动越慢。 ObjC类，方法越多，启动越慢。 ObjC的+load越多，启动越慢。 C的constructor函数越多，启动越慢。 C++静态对象越多，启动越慢。 针对以上几点，我们做了如下一些优化工作： 代码瘦身 随着业务的迭代，不断有新的代码加入，同时也会废弃掉无用的代码和资源文件，但是工程中经常有无用的代码和文件被遗弃在角落里，没有及时被清理掉。这些无用的部分一方面增大了App的包体积，另一方便也拖慢了App的冷启动速度，所以及时清理掉这些无用的代码和资源十分有必要。 通过对Mach-O文件的了解，可以知道__TEXT:__objc_methname:中包含了代码中的所有方法，而__DATA__objc_selrefs中则包含了所有被使用的方法的引用，通过取两个集合的差集就可以得到所有未被使用的代码。核心方法如下，具体可以参考：objc_cover: def&nbsp;referenced_selectors(path):&nbsp;&nbsp;&nbsp;&nbsp;re_sel&nbsp;=&nbsp;re.compile(&quot;__TEXT:__objc_methname:(.+)&quot;)&nbsp;//获取所有方法&nbsp;&nbsp;&nbsp;&nbsp;refs&nbsp;=&nbsp;set()&nbsp;&nbsp;&nbsp;&nbsp;lines&nbsp;=&nbsp;os.popen(&quot;/usr/bin/otool&nbsp;-v&nbsp;-s&nbsp;__DATA&nbsp;__objc_selrefs&nbsp;%s&quot;&nbsp;%&nbsp;path).readlines()&nbsp;#&nbsp;ios&nbsp;&amp;&nbsp;mac&nbsp;//真正被使用的方法&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;line&nbsp;in&nbsp;lines:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results&nbsp;=&nbsp;re_sel.findall(line)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;results:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refs.add(results[0])&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;refs} 通过这种方法，我们排查了十几个无用类和250+无用的方法。 +load优化 目前iOS App中或多或少的都会写一些+load方法，用于在App启动执行一些操作，+load方法在Initializers阶段被执行，但过多+load方法则会拖慢启动速度，对于大中型的App更是如此。通过对App中+load的方法分析，发现很多代码虽然需要在App启动时较早的时机进行初始化，但并不需要在+load这样非常靠前的位置，完全是可以延迟到App冷启动后的某个时间节点，例如一些路由操作。其实+load也可以被当做一种启动项来处理，所以在替换+load方法的具体实现上，我们仍然采用了上面的Kylin方式。 使用示例： //&nbsp;用WMAPP_BUSINESS_INIT_AFTER_HOMELOADING声明替换+load声明即可，不需其他改动WMAPP_BUSINESS_INIT_AFTER_HOMELOADING()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;原+load方法中的代码} //&nbsp;在某个合适的时机触发注册到该阶段的所有方法，如冷启动结束后[[KLNKylin&nbsp;sharedInstance]&nbsp;executeArrayForKey:@kWMAPP_BUSINESS_INITIALIZATION_AFTER_HOMELOADING_KEY]&nbsp;} 七、优化耗时操作 在main()之后主要工作是各种启动项的执行（上面已经叙述），主界面的构建，例如TabBarVC，HomeVC等等。资源的加载，如图片I/O、图片解码、archive文档等。这些操作中可能会隐含着一些耗时操作，靠单纯阅读非常难以发现，如何发现这些耗时点呢？找到合适的工具就会事半功倍。 Time Profiler Time Profiler是Xcode自带的时间性能分析工具，它按照固定的时间间隔来跟踪每一个线程的堆栈信息，通过统计比较时间间隔之间的堆栈状态，来推算某个方法执行了多久，并获得一个近似值。Time Profiler的使用方法网上有很多使用教程，这里我们也不过多介绍，附上一篇使用文档：Instruments Tutorial with Swift: Getting Started。 火焰图 除了Time Profiler，火焰图也是一个分析CPU耗时的利器，相比于Time Profiler，火焰图更加清晰。火焰图分析的产物是一张调用栈耗时图片，之所以称为火焰图，是因为整个图形看起来就像一团跳动的火焰，火焰尖部是调用栈的栈顶，底部是栈底，纵向表示调用栈的深度，横向表示消耗的时间。一个格子的宽度越大，越说明其可能是瓶颈。分析火焰图主要就是看那些比较宽大的火苗，特别留意那些类似“平顶山”的火苗。下面是美团平台开发的性能分析工具-Caesium的分析效果图： 通过对火焰图的分析，我们发现了冷启动过程中存在着不少问题，并成功优化了0.3S+的时间。优化内容总结如下： 八、优化串行操作 在冷启动过程中，有很多操作是串行执行的，若干个任务串行执行，时间必然比较长。如果能变串行为并行，那么冷启动时间就能够大大缩短。 闪屏页的使用 现在许多App在启动时并不直接进入首页，而是会向用户展示一个持续一小段时间的闪屏页，如果使用恰当，这个闪屏页就能帮我们节省一些启动时间。因为当一个App比较复杂的时候，启动时首次构建App的UI就是一个比较耗时的过程，假定这个时间是0.2秒，如果我们是先构建首页UI，然后再在Window上加上这个闪屏页，那么冷启动时，App就会实实在在地卡住0.2秒，但是如果我们是先把闪屏页作为App的RootViewController，那么这个构建过程就会很快。因为闪屏页只有一个简单的ImageView，而这个ImageView则会向用户展示一小段时间，这时我们就可以利用这一段时间来构建首页UI了，一举两得。 缓存定位&amp;首页预请求 美团外卖App冷启动过程中一个重要的串行流程就是：首页定位--&gt;首页请求--&gt;首页渲染过程，这三个操作占了整个首页加载时间的77%左右，所以想要缩短冷启动时间，就一定要从这三点出发进行优化。 之前串行操作流程如下： 优化后的设计，在发起定位的同时，使用客户端缓存定位，进行首页数据的预请求，使定位和请求并行进行。然后当用户真实定位成功后，判断真实定位是否命中缓存定位，如果命中，则刚才的预请求数据有效，这样可以节省大概40%的时间首页加载时间，效果非常明显；如果未命中，则弃用预请求数据，重新请求。 九、数据监控 Time Profiler和Caesium火焰图都只能在线下分析App在单台设备中的耗时操作，局限性比较大，无法在线上监控App在用户设备上的表现。外卖App使用公司内部自研的Metrics性能监控系统，长期监控App的性能指标，帮助我们掌握App在线上各种环境下的真实表现，并为技术优化项目提供可靠的数据支持。Metrics监控的核心指标之一，就是冷启动时间。 冷启动开始&amp;结束时间节点 结束时间点：结束时间比较好确定，我们可以将首页某些视图元素的展示作为首页加载完成的标志。 开始时间点：一般情况下，我们都是在main()之后才开始接管App，但以main()函数作为冷启动起始点显然不合适，因为这样无法统计到T1时间段。那么，起始时间如何确定呢？目前业界常见的有两种方法，一是以可执行文件中任意一个类的+load方法的执行时间作为起始点；二是分析dylib的依赖关系，找到叶子节点的dylib，然后以其中某个类的+load方法的执行时间作为起始点。根据Dyld对dylib的加载顺序，后者的时机更早。但是这两种方法获取的起始点都只在Initializers阶段，而Initializers之前的时长都没有被计入。Metrics则另辟蹊径，以App的进程创建时间（即exec函数执行时间）作为冷启动的起始时间。因为系统允许我们通过sysctl函数获得进程的有关信息，其中就包括进程创建的时间戳。 #import&nbsp;&lt;sys/sysctl.h&gt;#import&nbsp;&lt;mach/mach.h&gt;+&nbsp;(BOOL)processInfoForPID:(int)pid&nbsp;procInfo:(struct&nbsp;kinfo_proc*)procInfo{&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;cmd[4]&nbsp;=&nbsp;{CTL_KERN,&nbsp;KERN_PROC,&nbsp;KERN_PROC_PID,&nbsp;pid};&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;size&nbsp;=&nbsp;sizeof(*procInfo);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sysctl(cmd,&nbsp;sizeof(cmd)/sizeof(*cmd),&nbsp;procInfo,&nbsp;&amp;size,&nbsp;NULL,&nbsp;0)&nbsp;==&nbsp;0;}+&nbsp;(NSTimeInterval)processStartTime{&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;kinfo_proc&nbsp;kProcInfo;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;([self&nbsp;processInfoForPID:[[NSProcessInfo&nbsp;processInfo]&nbsp;processIdentifier]&nbsp;procInfo:&amp;kProcInfo])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;kProcInfo.kp_proc.p_un.__p_starttime.tv_sec&nbsp;*&nbsp;1000.0&nbsp;+&nbsp;kProcInfo.kp_proc.p_un.__p_starttime.tv_usec&nbsp;/&nbsp;1000.0;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSAssert(NO,&nbsp;@&quot;无法取得进程的信息&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;}} 进程创建的时机非常早。经过实验，在一个新建的空白App中，进程创建时间比叶子节点dylib中的+load方法执行时间早12ms，比main函数的执行时间早13ms（实验设备：iPhone 7 Plus （iOS 12.0）、Xcode 10.0、Release 模式）。外卖App线上的数据则更加明显，同样的机型（iPhone 7 Plus）和系统版本（iOS 12.0），进程创建时间比叶子节点dylib中的+load方法执行时间早688ms。而在全部机型和系统版本中，这一数据则是878ms。 冷启动过程时间节点 我们也在App冷启动过程中的所有关键节点打上一连串测速点，Metrics会记录下测速点的名称，及其距离进程创建时间的时长。我们没有采用自动打点的方式，是因为外卖App的冷启动过程十分复杂，而自动打点无法做到如此细致，并不实用。另外，Metrics记录的是时间轴上以进程创建时间为原点的一组顺序的时间点，而不是一组时间段，是因为顺序的时间点可以计算任意两个时间点之间的距离，即可以将时间点处理成时间段。但是，一组时间段可能无法还原为顺序的时间点，因为时间段之间可能并不是首尾相接的，特别是对于异步执行或者多线程的情况。 在测速完毕后，Metrics会统一将所有测速点上报到后台。下图是美团外卖App 6.10版本的部分过程节点监控数据截图： Metrics还会由后台对数据做聚合计算，得到冷启动总时长和各个测速点时长的50分位数、90分位数和95分位数的统计数据，这样我们就能从宏观上对冷启动时长分布情况有所了解。下图中横轴为时长，纵轴为上报的样本数。 十、总结 对于快速迭代的App，随着业务复杂度的增加，冷启动时长会不可避免的增加。冷启动流程也是一个比较复杂的过程，当遇到冷启动性能瓶颈时，我们可以根据App自身的特点，配合工具的使用，从多方面、多角度进行优化。同时，优化冷启动存量问题只是冷启动治理的第一步，因为冷启动性能问题并不是一日造成的，也不能简单的通过一次优化工作就能解决，我们需要通过合理的设计、规范的约束，来有效地管控性能问题的增量，并通过持续的线上监控来及时发现并修正性能问题，这样才能够长期保证良好的App冷启动体验。 作者简介 郭赛，美团点评资深工程师。2015年加入美团，目前作为外卖iOS团队主力开发，负责移动端业务开发，业务类基础设施的建设与维护。 徐宏，美团点评资深工程师。2016年加入美团，目前作为外卖iOS团队主力开发，负责移动端APM性能监控，高可用基础设施支撑相关推进工作。 欢迎加入美团iOS技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 美团外卖iOS多端复用的推动、支撑与思考 Category 特性在 iOS 组件化中的应用与管控 iOS系统中导航栏的转场解决方案与最佳实践" />
<meta property="og:description" content="总第309篇 2018年 第101篇 本文主要分享美团外卖iOS客户端针对App冷启动性能进行治理的一些经验。 招聘：美团外卖长期招聘Android、iOS、FE高级/资深工程师和技术专家，Base北京、上海、成都，欢迎有兴趣的同学扫描并识别下方二维码查看岗位详情。 扫码查看职位详情，一键投递简历 一、背景 冷启动时长是App性能的重要指标，作为用户体验的第一道“门”，直接决定着用户对App的第一印象。美团外卖iOS客户端从2013年11月开始，历经几十个版本的迭代开发，产品形态不断完善，业务功能日趋复杂；同时外卖App也已经由原来的独立业务App演进成为一个平台App，陆续接入了闪购、跑腿等其他新业务。因此，更多更复杂的工作需要在App冷启动的时候被完成，这给App的冷启动性能带来了挑战。对此，我们团队基于业务形态的变化和外卖App的特点，对冷启动进行了持续且有针对性的优化工作，目的就是为了呈现更加流畅的用户体验。 二、冷启动定义 一般而言，大家把iOS冷启动的过程定义为：从用户点击App图标开始到appDelegate didFinishLaunching方法执行完成为止。这个过程主要分为两个阶段： T1：main()函数之前，即操作系统加载App可执行文件到内存，然后执行一系列的加载&amp;链接等工作，最后执行至App的main()函数。 T2：main()函数之后，即从main()开始，到appDelegate的didFinishLaunchingWithOptions方法执行完毕。 然而，当didFinishLaunchingWithOptions执行完成时，用户还没有看到App的主界面，也不能开始使用App。例如在外卖App中，App还需要做一些初始化工作，然后经历定位、首页请求、首页渲染等过程后，用户才能真正看到数据内容并开始使用，我们认为这个时候冷启动才算完成。我们把这个过程定义为T3。 综上，外卖App把冷启动过程定义为：从用户点击App图标开始到用户能看到App主界面内容为止这个过程，即T1+T2+T3。在App冷启动过程当中，这三个阶段中的每个阶段都存在很多可以被优化的点。 三、问题现状 性能存量问题 美团外卖iOS客户端经过几十个版本的迭代开发后，在冷启动过程中已经积累了若干性能问题，解决这些性能瓶颈是冷启动优化工作的首要目标，这些问题主要包括： 注：启动项的定义，在App启动过程中需要被完成的某项工作，我们称之为一个启动项。例如某个SDK的初始化、某个功能的预加载等。 性能增量问题 一般情况下，在App早期阶段，冷启动不会有明显的性能问题。冷启动性能问题也不是在某个版本突然出现的，而是随着版本迭代，App功能越来越复杂，启动任务越来越多，冷启动时间也一点点延长。最后当我们注意到，并想要优化它的时候，这个问题已经变得很棘手了。外卖App的性能问题增量主要来自启动项的增加，随着版本迭代，启动项任务简单粗暴地堆积在启动流程中。如果每个版本冷启动时间增加0.1s，那么几个版本下来，冷启动时长就会明显增加很多。 四、治理思路 冷启动性能问题的治理目标主要有三个： 解决存量问题：优化当前性能瓶颈点，优化启动流程，缩短冷启动时间。 管控增量问题：冷启动流程规范化，通过代码范式和文档指导后续冷启动过程代码的维护，控制时间增量。 完善监控：完善冷启动性能指标监控，收集更详细的数据，及时发现性能问题。 五、规范启动流程 截止至2017年底，美团外卖用户数已达2.5亿，而美团外卖App也已完成了从支撑单一业务的App到支持多业务的平台型App的演进（美团外卖iOS多端复用的推动、支撑与思考），公司的一些新兴业务也陆续集成到外卖App当中。下面是外卖App的架构图，外卖的架构主要分为三层，底层是基础组件层，中层是外卖平台层，平台层向下管理基础组件，向上为业务组件提供统一的适配接口，上层是基础组件层，包括外卖业务拆分的子业务组件（外卖App和美团App中的外卖频道可以复用子业务组件）和接入的其他非外卖业务。 App的平台化为业务方提供了高效、标准的统一平台，但与此同时，平台化和业务的快速迭代也给冷启动带来了问题： 现有的启动项堆积严重，拖慢启动速度。 新的启动项缺乏添加范式，杂乱无章，修改风险大，难以阅读和维护。 面对这个问题，我们首先梳理了目前启动流程中所有的启动项，然后针对App平台化设计了新的启动项管理方式：分阶段启动和启动项自注册。 分阶段启动 早期由于业务比较简单，所有启动项都是不加以区分，简单地堆积到didFinishLaunchingWithOptions方法中，但随着业务的增加，越来越多的启动项代码堆积在一起，性能较差，代码臃肿而混乱。 通过对SDK的梳理和分析，我们发现启动项也需要根据所完成的任务被分类，有些启动项是需要刚启动就执行的操作，如Crash监控、统计上报等，否则会导致信息收集的缺失；有些启动项需要在较早的时间节点完成，例如一些提供用户信息的SDK、定位功能的初始化、网络初始化等；有些启动项则可以被延迟执行，如一些自定义配置，一些业务服务的调用、支付SDK、地图SDK等。我们所做的分阶段启动，首先就是把启动流程合理地划分为若干个启动阶段，然后依据每个启动项所做的事情的优先级把它们分配到相应的启动阶段，优先级高的放在靠前的阶段，优先级低的放在靠后的阶段。 下面是我们对美团外卖App启动阶段进行的重新定义，对所有启动项进行的梳理和重新分类，把它们对应到合理的启动阶段。这样做一方面可以推迟执行那些不必过早执行的启动项，缩短启动时间；另一方面，把启动项进行归类，方便后续的阅读和维护。然后把这些规则落地为启动项的维护文档，指导后续启动项的新增和维护。 通过上面的工作，我们梳理出了十几个可以推迟执行的启动项，占所有启动项的30%左右，有效地优化了启动项所占的这部分冷启动时间。 启动项自注册 确定了启动项分阶段启动的方案后，我们面对的问题就是如何执行这些启动项。比较容易想到的方案是：在启动时创建一个启动管理器，然后读取所有启动项，然后当时间节点到来时由启动器触发启动项执行。这种方式存在两个问题： 所有启动项都要预先写到一个文件中（在.m文件import，或用.plist文件组织），这种中心化的写法会导致臃肿的代码，难以阅读维护。 启动项代码无法复用：启动项无法收敛到子业务库内部，在外卖App和美团App中要重复实现，和外卖App平台化的方向不符。 而我们希望的方式是，启动项维护方式可插拔，启动项之间、业务模块之间不耦合，且一次实现可在两端复用。下图是我们采用的启动项管理方式，我们称之为启动项的自注册：一个启动项定义在子业务模块内部，被封装成一个方法，并且自声明启动阶段（例如一个启动项A，在独立App中可以声明为在willFinishLaunch阶段被执行，在美团App中则声明在resignActive阶段被执行）。这种方式下，启动项即实现了两端复用，不相关的启动项互相隔离，添加/删除启动项都更加方便。 那么如何给一个启动项声明启动阶段？又如何在正确的时机触发启动项的执行呢？在代码上，一个启动项最终都会对应到一个函数的执行，所以在运行时只要能获取到函数的指针，就可以触发启动项。美团平台开发的组件启动治理基建Kylin正是这样做的：Kylin的核心思想就是在编译时把数据（如函数指针）写入到可执行文件的__DATA段中，运行时再从__DATA段取出数据进行相应的操作（调用函数）。 为什么要用借用__DATA段呢？原因就是为了能够覆盖所有的启动阶段，例如main()之前的阶段。 Kylin实现原理简述：Clang 提供了很多的编译器函数，它们可以完成不同的功能。其中一种就是 section() 函数，section()函数提供了二进制段的读写能力，它可以将一些编译期就可以确定的常量写入数据段。 在具体的实现中，主要分为编译期和运行时两个部分。在编译期，编译器会将标记了 attribute((section())) 的数据写到指定的数据段中，例如写一个{key(key代表不同的启动阶段), *pointer}对到数据段。到运行时，在合适的时间节点，在根据key读取出函数指针，完成函数的调用。 上述方式，可以封装成一个宏，来达到代码的简化，以调用宏 KLN_STRINGS_EXPORT(&quot;Key&quot;, &quot;Value&quot;)为例，最终会被展开为： __attribute__((used,&nbsp;section(&quot;__DATA&quot;&nbsp;&quot;,&quot;&nbsp;&quot;__kylin__&quot;)))&nbsp;static&nbsp;const&nbsp;KLN_DATA&nbsp;__kylin__0&nbsp;=&nbsp;(KLN_DATA){(KLN_DATA_HEADER){&quot;Key&quot;,&nbsp;KLN_STRING,&nbsp;KLN_IS_ARRAY},&nbsp;&quot;Value&quot;}; 使用示例，编译器把启动项函数注册到启动阶段A： KLN_FUNCTIONS_EXPORT(STAGE_KEY_A)()&nbsp;{&nbsp;//&nbsp;在a.m文件中，通过注册宏，把启动项A声明为在STAGE_KEY_A阶段执行&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;启动项代码A} KLN_FUNCTIONS_EXPORT(STAGE_KEY_A)()&nbsp;{&nbsp;//&nbsp;在b.m文件中，把启动项B声明为在STAGE_KEY_A阶段执行&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;启动项代码B} 在启动流程中，在启动阶段STAGE_KEY_A触发所有注册到STAGE_KEY_A时间节点的启动项，通过对这种方式，几乎没有任何额外的辅助代码，我们用一种很简洁的方式完成了启动项的自注册。 -&nbsp;(BOOL)application:(UIApplication&nbsp;*)application&nbsp;didFinishLaunchingWithOptions:(NSDictionary&nbsp;*)launchOptions&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其他逻辑&nbsp;&nbsp;&nbsp;&nbsp;[[KLNKylin&nbsp;sharedInstance]&nbsp;executeArrayForKey:STAGE_KEY_A];&nbsp;&nbsp;//&nbsp;在此触发所有注册到STAGE_KEY_A时间节点的启动项&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其他逻辑&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;YES;} 完成对现有的启动项的梳理和优化后，我们也输出了后续启动项的添加&amp;维护规范，规范后续启动项的分类原则，优先级和启动阶段。目的是管控性能问题增量，保证优化成果。 六、优化main()之前 在调用main()函数之前，基本所有的工作都是由操作系统完成的，开发者能够插手的地方不多，所以如果想要优化这段时间，就必须先了解一下，操作系统在main()之前做了什么。main()之前操作系统所做的工作就是把可执行文件（Mach-O格式）加载到内存空间，然后加载动态链接库dyld，再执行一系列动态链接操作和初始化操作的过程（加载、绑定、及初始化方法）。这方面的资料网上比较多，但重复性较高，此处附上一篇WWDC的Topic：Optimizing App Startup Time。 加载过程—从exec()到main() 真正的加载过程从exec()函数开始，exec()是一个系统调用。操作系统首先为进程分配一段内存空间，然后执行如下操作： 把App对应的可执行文件加载到内存。 把Dyld加载到内存。 Dyld进行动态链接。 下面我们简要分析一下Dyld在各阶段所做的事情： 最后 dyld 会调用 main() 函数，main() 会调用 UIApplicationMain()，before main()的过程也就此完成。 了解完main()之前的加载过程后，我们可以分析出一些影响T1时间的因素： 动态库加载越多，启动越慢。 ObjC类，方法越多，启动越慢。 ObjC的+load越多，启动越慢。 C的constructor函数越多，启动越慢。 C++静态对象越多，启动越慢。 针对以上几点，我们做了如下一些优化工作： 代码瘦身 随着业务的迭代，不断有新的代码加入，同时也会废弃掉无用的代码和资源文件，但是工程中经常有无用的代码和文件被遗弃在角落里，没有及时被清理掉。这些无用的部分一方面增大了App的包体积，另一方便也拖慢了App的冷启动速度，所以及时清理掉这些无用的代码和资源十分有必要。 通过对Mach-O文件的了解，可以知道__TEXT:__objc_methname:中包含了代码中的所有方法，而__DATA__objc_selrefs中则包含了所有被使用的方法的引用，通过取两个集合的差集就可以得到所有未被使用的代码。核心方法如下，具体可以参考：objc_cover: def&nbsp;referenced_selectors(path):&nbsp;&nbsp;&nbsp;&nbsp;re_sel&nbsp;=&nbsp;re.compile(&quot;__TEXT:__objc_methname:(.+)&quot;)&nbsp;//获取所有方法&nbsp;&nbsp;&nbsp;&nbsp;refs&nbsp;=&nbsp;set()&nbsp;&nbsp;&nbsp;&nbsp;lines&nbsp;=&nbsp;os.popen(&quot;/usr/bin/otool&nbsp;-v&nbsp;-s&nbsp;__DATA&nbsp;__objc_selrefs&nbsp;%s&quot;&nbsp;%&nbsp;path).readlines()&nbsp;#&nbsp;ios&nbsp;&amp;&nbsp;mac&nbsp;//真正被使用的方法&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;line&nbsp;in&nbsp;lines:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results&nbsp;=&nbsp;re_sel.findall(line)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;results:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refs.add(results[0])&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;refs} 通过这种方法，我们排查了十几个无用类和250+无用的方法。 +load优化 目前iOS App中或多或少的都会写一些+load方法，用于在App启动执行一些操作，+load方法在Initializers阶段被执行，但过多+load方法则会拖慢启动速度，对于大中型的App更是如此。通过对App中+load的方法分析，发现很多代码虽然需要在App启动时较早的时机进行初始化，但并不需要在+load这样非常靠前的位置，完全是可以延迟到App冷启动后的某个时间节点，例如一些路由操作。其实+load也可以被当做一种启动项来处理，所以在替换+load方法的具体实现上，我们仍然采用了上面的Kylin方式。 使用示例： //&nbsp;用WMAPP_BUSINESS_INIT_AFTER_HOMELOADING声明替换+load声明即可，不需其他改动WMAPP_BUSINESS_INIT_AFTER_HOMELOADING()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;原+load方法中的代码} //&nbsp;在某个合适的时机触发注册到该阶段的所有方法，如冷启动结束后[[KLNKylin&nbsp;sharedInstance]&nbsp;executeArrayForKey:@kWMAPP_BUSINESS_INITIALIZATION_AFTER_HOMELOADING_KEY]&nbsp;} 七、优化耗时操作 在main()之后主要工作是各种启动项的执行（上面已经叙述），主界面的构建，例如TabBarVC，HomeVC等等。资源的加载，如图片I/O、图片解码、archive文档等。这些操作中可能会隐含着一些耗时操作，靠单纯阅读非常难以发现，如何发现这些耗时点呢？找到合适的工具就会事半功倍。 Time Profiler Time Profiler是Xcode自带的时间性能分析工具，它按照固定的时间间隔来跟踪每一个线程的堆栈信息，通过统计比较时间间隔之间的堆栈状态，来推算某个方法执行了多久，并获得一个近似值。Time Profiler的使用方法网上有很多使用教程，这里我们也不过多介绍，附上一篇使用文档：Instruments Tutorial with Swift: Getting Started。 火焰图 除了Time Profiler，火焰图也是一个分析CPU耗时的利器，相比于Time Profiler，火焰图更加清晰。火焰图分析的产物是一张调用栈耗时图片，之所以称为火焰图，是因为整个图形看起来就像一团跳动的火焰，火焰尖部是调用栈的栈顶，底部是栈底，纵向表示调用栈的深度，横向表示消耗的时间。一个格子的宽度越大，越说明其可能是瓶颈。分析火焰图主要就是看那些比较宽大的火苗，特别留意那些类似“平顶山”的火苗。下面是美团平台开发的性能分析工具-Caesium的分析效果图： 通过对火焰图的分析，我们发现了冷启动过程中存在着不少问题，并成功优化了0.3S+的时间。优化内容总结如下： 八、优化串行操作 在冷启动过程中，有很多操作是串行执行的，若干个任务串行执行，时间必然比较长。如果能变串行为并行，那么冷启动时间就能够大大缩短。 闪屏页的使用 现在许多App在启动时并不直接进入首页，而是会向用户展示一个持续一小段时间的闪屏页，如果使用恰当，这个闪屏页就能帮我们节省一些启动时间。因为当一个App比较复杂的时候，启动时首次构建App的UI就是一个比较耗时的过程，假定这个时间是0.2秒，如果我们是先构建首页UI，然后再在Window上加上这个闪屏页，那么冷启动时，App就会实实在在地卡住0.2秒，但是如果我们是先把闪屏页作为App的RootViewController，那么这个构建过程就会很快。因为闪屏页只有一个简单的ImageView，而这个ImageView则会向用户展示一小段时间，这时我们就可以利用这一段时间来构建首页UI了，一举两得。 缓存定位&amp;首页预请求 美团外卖App冷启动过程中一个重要的串行流程就是：首页定位--&gt;首页请求--&gt;首页渲染过程，这三个操作占了整个首页加载时间的77%左右，所以想要缩短冷启动时间，就一定要从这三点出发进行优化。 之前串行操作流程如下： 优化后的设计，在发起定位的同时，使用客户端缓存定位，进行首页数据的预请求，使定位和请求并行进行。然后当用户真实定位成功后，判断真实定位是否命中缓存定位，如果命中，则刚才的预请求数据有效，这样可以节省大概40%的时间首页加载时间，效果非常明显；如果未命中，则弃用预请求数据，重新请求。 九、数据监控 Time Profiler和Caesium火焰图都只能在线下分析App在单台设备中的耗时操作，局限性比较大，无法在线上监控App在用户设备上的表现。外卖App使用公司内部自研的Metrics性能监控系统，长期监控App的性能指标，帮助我们掌握App在线上各种环境下的真实表现，并为技术优化项目提供可靠的数据支持。Metrics监控的核心指标之一，就是冷启动时间。 冷启动开始&amp;结束时间节点 结束时间点：结束时间比较好确定，我们可以将首页某些视图元素的展示作为首页加载完成的标志。 开始时间点：一般情况下，我们都是在main()之后才开始接管App，但以main()函数作为冷启动起始点显然不合适，因为这样无法统计到T1时间段。那么，起始时间如何确定呢？目前业界常见的有两种方法，一是以可执行文件中任意一个类的+load方法的执行时间作为起始点；二是分析dylib的依赖关系，找到叶子节点的dylib，然后以其中某个类的+load方法的执行时间作为起始点。根据Dyld对dylib的加载顺序，后者的时机更早。但是这两种方法获取的起始点都只在Initializers阶段，而Initializers之前的时长都没有被计入。Metrics则另辟蹊径，以App的进程创建时间（即exec函数执行时间）作为冷启动的起始时间。因为系统允许我们通过sysctl函数获得进程的有关信息，其中就包括进程创建的时间戳。 #import&nbsp;&lt;sys/sysctl.h&gt;#import&nbsp;&lt;mach/mach.h&gt;+&nbsp;(BOOL)processInfoForPID:(int)pid&nbsp;procInfo:(struct&nbsp;kinfo_proc*)procInfo{&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;cmd[4]&nbsp;=&nbsp;{CTL_KERN,&nbsp;KERN_PROC,&nbsp;KERN_PROC_PID,&nbsp;pid};&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;size&nbsp;=&nbsp;sizeof(*procInfo);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sysctl(cmd,&nbsp;sizeof(cmd)/sizeof(*cmd),&nbsp;procInfo,&nbsp;&amp;size,&nbsp;NULL,&nbsp;0)&nbsp;==&nbsp;0;}+&nbsp;(NSTimeInterval)processStartTime{&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;kinfo_proc&nbsp;kProcInfo;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;([self&nbsp;processInfoForPID:[[NSProcessInfo&nbsp;processInfo]&nbsp;processIdentifier]&nbsp;procInfo:&amp;kProcInfo])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;kProcInfo.kp_proc.p_un.__p_starttime.tv_sec&nbsp;*&nbsp;1000.0&nbsp;+&nbsp;kProcInfo.kp_proc.p_un.__p_starttime.tv_usec&nbsp;/&nbsp;1000.0;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSAssert(NO,&nbsp;@&quot;无法取得进程的信息&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;}} 进程创建的时机非常早。经过实验，在一个新建的空白App中，进程创建时间比叶子节点dylib中的+load方法执行时间早12ms，比main函数的执行时间早13ms（实验设备：iPhone 7 Plus （iOS 12.0）、Xcode 10.0、Release 模式）。外卖App线上的数据则更加明显，同样的机型（iPhone 7 Plus）和系统版本（iOS 12.0），进程创建时间比叶子节点dylib中的+load方法执行时间早688ms。而在全部机型和系统版本中，这一数据则是878ms。 冷启动过程时间节点 我们也在App冷启动过程中的所有关键节点打上一连串测速点，Metrics会记录下测速点的名称，及其距离进程创建时间的时长。我们没有采用自动打点的方式，是因为外卖App的冷启动过程十分复杂，而自动打点无法做到如此细致，并不实用。另外，Metrics记录的是时间轴上以进程创建时间为原点的一组顺序的时间点，而不是一组时间段，是因为顺序的时间点可以计算任意两个时间点之间的距离，即可以将时间点处理成时间段。但是，一组时间段可能无法还原为顺序的时间点，因为时间段之间可能并不是首尾相接的，特别是对于异步执行或者多线程的情况。 在测速完毕后，Metrics会统一将所有测速点上报到后台。下图是美团外卖App 6.10版本的部分过程节点监控数据截图： Metrics还会由后台对数据做聚合计算，得到冷启动总时长和各个测速点时长的50分位数、90分位数和95分位数的统计数据，这样我们就能从宏观上对冷启动时长分布情况有所了解。下图中横轴为时长，纵轴为上报的样本数。 十、总结 对于快速迭代的App，随着业务复杂度的增加，冷启动时长会不可避免的增加。冷启动流程也是一个比较复杂的过程，当遇到冷启动性能瓶颈时，我们可以根据App自身的特点，配合工具的使用，从多方面、多角度进行优化。同时，优化冷启动存量问题只是冷启动治理的第一步，因为冷启动性能问题并不是一日造成的，也不能简单的通过一次优化工作就能解决，我们需要通过合理的设计、规范的约束，来有效地管控性能问题的增量，并通过持续的线上监控来及时发现并修正性能问题，这样才能够长期保证良好的App冷启动体验。 作者简介 郭赛，美团点评资深工程师。2015年加入美团，目前作为外卖iOS团队主力开发，负责移动端业务开发，业务类基础设施的建设与维护。 徐宏，美团点评资深工程师。2016年加入美团，目前作为外卖iOS团队主力开发，负责移动端APM性能监控，高可用基础设施支撑相关推进工作。 欢迎加入美团iOS技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 美团外卖iOS多端复用的推动、支撑与思考 Category 特性在 iOS 组件化中的应用与管控 iOS系统中导航栏的转场解决方案与最佳实践" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"总第309篇 2018年 第101篇 本文主要分享美团外卖iOS客户端针对App冷启动性能进行治理的一些经验。 招聘：美团外卖长期招聘Android、iOS、FE高级/资深工程师和技术专家，Base北京、上海、成都，欢迎有兴趣的同学扫描并识别下方二维码查看岗位详情。 扫码查看职位详情，一键投递简历 一、背景 冷启动时长是App性能的重要指标，作为用户体验的第一道“门”，直接决定着用户对App的第一印象。美团外卖iOS客户端从2013年11月开始，历经几十个版本的迭代开发，产品形态不断完善，业务功能日趋复杂；同时外卖App也已经由原来的独立业务App演进成为一个平台App，陆续接入了闪购、跑腿等其他新业务。因此，更多更复杂的工作需要在App冷启动的时候被完成，这给App的冷启动性能带来了挑战。对此，我们团队基于业务形态的变化和外卖App的特点，对冷启动进行了持续且有针对性的优化工作，目的就是为了呈现更加流畅的用户体验。 二、冷启动定义 一般而言，大家把iOS冷启动的过程定义为：从用户点击App图标开始到appDelegate didFinishLaunching方法执行完成为止。这个过程主要分为两个阶段： T1：main()函数之前，即操作系统加载App可执行文件到内存，然后执行一系列的加载&amp;链接等工作，最后执行至App的main()函数。 T2：main()函数之后，即从main()开始，到appDelegate的didFinishLaunchingWithOptions方法执行完毕。 然而，当didFinishLaunchingWithOptions执行完成时，用户还没有看到App的主界面，也不能开始使用App。例如在外卖App中，App还需要做一些初始化工作，然后经历定位、首页请求、首页渲染等过程后，用户才能真正看到数据内容并开始使用，我们认为这个时候冷启动才算完成。我们把这个过程定义为T3。 综上，外卖App把冷启动过程定义为：从用户点击App图标开始到用户能看到App主界面内容为止这个过程，即T1+T2+T3。在App冷启动过程当中，这三个阶段中的每个阶段都存在很多可以被优化的点。 三、问题现状 性能存量问题 美团外卖iOS客户端经过几十个版本的迭代开发后，在冷启动过程中已经积累了若干性能问题，解决这些性能瓶颈是冷启动优化工作的首要目标，这些问题主要包括： 注：启动项的定义，在App启动过程中需要被完成的某项工作，我们称之为一个启动项。例如某个SDK的初始化、某个功能的预加载等。 性能增量问题 一般情况下，在App早期阶段，冷启动不会有明显的性能问题。冷启动性能问题也不是在某个版本突然出现的，而是随着版本迭代，App功能越来越复杂，启动任务越来越多，冷启动时间也一点点延长。最后当我们注意到，并想要优化它的时候，这个问题已经变得很棘手了。外卖App的性能问题增量主要来自启动项的增加，随着版本迭代，启动项任务简单粗暴地堆积在启动流程中。如果每个版本冷启动时间增加0.1s，那么几个版本下来，冷启动时长就会明显增加很多。 四、治理思路 冷启动性能问题的治理目标主要有三个： 解决存量问题：优化当前性能瓶颈点，优化启动流程，缩短冷启动时间。 管控增量问题：冷启动流程规范化，通过代码范式和文档指导后续冷启动过程代码的维护，控制时间增量。 完善监控：完善冷启动性能指标监控，收集更详细的数据，及时发现性能问题。 五、规范启动流程 截止至2017年底，美团外卖用户数已达2.5亿，而美团外卖App也已完成了从支撑单一业务的App到支持多业务的平台型App的演进（美团外卖iOS多端复用的推动、支撑与思考），公司的一些新兴业务也陆续集成到外卖App当中。下面是外卖App的架构图，外卖的架构主要分为三层，底层是基础组件层，中层是外卖平台层，平台层向下管理基础组件，向上为业务组件提供统一的适配接口，上层是基础组件层，包括外卖业务拆分的子业务组件（外卖App和美团App中的外卖频道可以复用子业务组件）和接入的其他非外卖业务。 App的平台化为业务方提供了高效、标准的统一平台，但与此同时，平台化和业务的快速迭代也给冷启动带来了问题： 现有的启动项堆积严重，拖慢启动速度。 新的启动项缺乏添加范式，杂乱无章，修改风险大，难以阅读和维护。 面对这个问题，我们首先梳理了目前启动流程中所有的启动项，然后针对App平台化设计了新的启动项管理方式：分阶段启动和启动项自注册。 分阶段启动 早期由于业务比较简单，所有启动项都是不加以区分，简单地堆积到didFinishLaunchingWithOptions方法中，但随着业务的增加，越来越多的启动项代码堆积在一起，性能较差，代码臃肿而混乱。 通过对SDK的梳理和分析，我们发现启动项也需要根据所完成的任务被分类，有些启动项是需要刚启动就执行的操作，如Crash监控、统计上报等，否则会导致信息收集的缺失；有些启动项需要在较早的时间节点完成，例如一些提供用户信息的SDK、定位功能的初始化、网络初始化等；有些启动项则可以被延迟执行，如一些自定义配置，一些业务服务的调用、支付SDK、地图SDK等。我们所做的分阶段启动，首先就是把启动流程合理地划分为若干个启动阶段，然后依据每个启动项所做的事情的优先级把它们分配到相应的启动阶段，优先级高的放在靠前的阶段，优先级低的放在靠后的阶段。 下面是我们对美团外卖App启动阶段进行的重新定义，对所有启动项进行的梳理和重新分类，把它们对应到合理的启动阶段。这样做一方面可以推迟执行那些不必过早执行的启动项，缩短启动时间；另一方面，把启动项进行归类，方便后续的阅读和维护。然后把这些规则落地为启动项的维护文档，指导后续启动项的新增和维护。 通过上面的工作，我们梳理出了十几个可以推迟执行的启动项，占所有启动项的30%左右，有效地优化了启动项所占的这部分冷启动时间。 启动项自注册 确定了启动项分阶段启动的方案后，我们面对的问题就是如何执行这些启动项。比较容易想到的方案是：在启动时创建一个启动管理器，然后读取所有启动项，然后当时间节点到来时由启动器触发启动项执行。这种方式存在两个问题： 所有启动项都要预先写到一个文件中（在.m文件import，或用.plist文件组织），这种中心化的写法会导致臃肿的代码，难以阅读维护。 启动项代码无法复用：启动项无法收敛到子业务库内部，在外卖App和美团App中要重复实现，和外卖App平台化的方向不符。 而我们希望的方式是，启动项维护方式可插拔，启动项之间、业务模块之间不耦合，且一次实现可在两端复用。下图是我们采用的启动项管理方式，我们称之为启动项的自注册：一个启动项定义在子业务模块内部，被封装成一个方法，并且自声明启动阶段（例如一个启动项A，在独立App中可以声明为在willFinishLaunch阶段被执行，在美团App中则声明在resignActive阶段被执行）。这种方式下，启动项即实现了两端复用，不相关的启动项互相隔离，添加/删除启动项都更加方便。 那么如何给一个启动项声明启动阶段？又如何在正确的时机触发启动项的执行呢？在代码上，一个启动项最终都会对应到一个函数的执行，所以在运行时只要能获取到函数的指针，就可以触发启动项。美团平台开发的组件启动治理基建Kylin正是这样做的：Kylin的核心思想就是在编译时把数据（如函数指针）写入到可执行文件的__DATA段中，运行时再从__DATA段取出数据进行相应的操作（调用函数）。 为什么要用借用__DATA段呢？原因就是为了能够覆盖所有的启动阶段，例如main()之前的阶段。 Kylin实现原理简述：Clang 提供了很多的编译器函数，它们可以完成不同的功能。其中一种就是 section() 函数，section()函数提供了二进制段的读写能力，它可以将一些编译期就可以确定的常量写入数据段。 在具体的实现中，主要分为编译期和运行时两个部分。在编译期，编译器会将标记了 attribute((section())) 的数据写到指定的数据段中，例如写一个{key(key代表不同的启动阶段), *pointer}对到数据段。到运行时，在合适的时间节点，在根据key读取出函数指针，完成函数的调用。 上述方式，可以封装成一个宏，来达到代码的简化，以调用宏 KLN_STRINGS_EXPORT(&quot;Key&quot;, &quot;Value&quot;)为例，最终会被展开为： __attribute__((used,&nbsp;section(&quot;__DATA&quot;&nbsp;&quot;,&quot;&nbsp;&quot;__kylin__&quot;)))&nbsp;static&nbsp;const&nbsp;KLN_DATA&nbsp;__kylin__0&nbsp;=&nbsp;(KLN_DATA){(KLN_DATA_HEADER){&quot;Key&quot;,&nbsp;KLN_STRING,&nbsp;KLN_IS_ARRAY},&nbsp;&quot;Value&quot;}; 使用示例，编译器把启动项函数注册到启动阶段A： KLN_FUNCTIONS_EXPORT(STAGE_KEY_A)()&nbsp;{&nbsp;//&nbsp;在a.m文件中，通过注册宏，把启动项A声明为在STAGE_KEY_A阶段执行&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;启动项代码A} KLN_FUNCTIONS_EXPORT(STAGE_KEY_A)()&nbsp;{&nbsp;//&nbsp;在b.m文件中，把启动项B声明为在STAGE_KEY_A阶段执行&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;启动项代码B} 在启动流程中，在启动阶段STAGE_KEY_A触发所有注册到STAGE_KEY_A时间节点的启动项，通过对这种方式，几乎没有任何额外的辅助代码，我们用一种很简洁的方式完成了启动项的自注册。 -&nbsp;(BOOL)application:(UIApplication&nbsp;*)application&nbsp;didFinishLaunchingWithOptions:(NSDictionary&nbsp;*)launchOptions&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其他逻辑&nbsp;&nbsp;&nbsp;&nbsp;[[KLNKylin&nbsp;sharedInstance]&nbsp;executeArrayForKey:STAGE_KEY_A];&nbsp;&nbsp;//&nbsp;在此触发所有注册到STAGE_KEY_A时间节点的启动项&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其他逻辑&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;YES;} 完成对现有的启动项的梳理和优化后，我们也输出了后续启动项的添加&amp;维护规范，规范后续启动项的分类原则，优先级和启动阶段。目的是管控性能问题增量，保证优化成果。 六、优化main()之前 在调用main()函数之前，基本所有的工作都是由操作系统完成的，开发者能够插手的地方不多，所以如果想要优化这段时间，就必须先了解一下，操作系统在main()之前做了什么。main()之前操作系统所做的工作就是把可执行文件（Mach-O格式）加载到内存空间，然后加载动态链接库dyld，再执行一系列动态链接操作和初始化操作的过程（加载、绑定、及初始化方法）。这方面的资料网上比较多，但重复性较高，此处附上一篇WWDC的Topic：Optimizing App Startup Time。 加载过程—从exec()到main() 真正的加载过程从exec()函数开始，exec()是一个系统调用。操作系统首先为进程分配一段内存空间，然后执行如下操作： 把App对应的可执行文件加载到内存。 把Dyld加载到内存。 Dyld进行动态链接。 下面我们简要分析一下Dyld在各阶段所做的事情： 最后 dyld 会调用 main() 函数，main() 会调用 UIApplicationMain()，before main()的过程也就此完成。 了解完main()之前的加载过程后，我们可以分析出一些影响T1时间的因素： 动态库加载越多，启动越慢。 ObjC类，方法越多，启动越慢。 ObjC的+load越多，启动越慢。 C的constructor函数越多，启动越慢。 C++静态对象越多，启动越慢。 针对以上几点，我们做了如下一些优化工作： 代码瘦身 随着业务的迭代，不断有新的代码加入，同时也会废弃掉无用的代码和资源文件，但是工程中经常有无用的代码和文件被遗弃在角落里，没有及时被清理掉。这些无用的部分一方面增大了App的包体积，另一方便也拖慢了App的冷启动速度，所以及时清理掉这些无用的代码和资源十分有必要。 通过对Mach-O文件的了解，可以知道__TEXT:__objc_methname:中包含了代码中的所有方法，而__DATA__objc_selrefs中则包含了所有被使用的方法的引用，通过取两个集合的差集就可以得到所有未被使用的代码。核心方法如下，具体可以参考：objc_cover: def&nbsp;referenced_selectors(path):&nbsp;&nbsp;&nbsp;&nbsp;re_sel&nbsp;=&nbsp;re.compile(&quot;__TEXT:__objc_methname:(.+)&quot;)&nbsp;//获取所有方法&nbsp;&nbsp;&nbsp;&nbsp;refs&nbsp;=&nbsp;set()&nbsp;&nbsp;&nbsp;&nbsp;lines&nbsp;=&nbsp;os.popen(&quot;/usr/bin/otool&nbsp;-v&nbsp;-s&nbsp;__DATA&nbsp;__objc_selrefs&nbsp;%s&quot;&nbsp;%&nbsp;path).readlines()&nbsp;#&nbsp;ios&nbsp;&amp;&nbsp;mac&nbsp;//真正被使用的方法&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;line&nbsp;in&nbsp;lines:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results&nbsp;=&nbsp;re_sel.findall(line)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;results:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refs.add(results[0])&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;refs} 通过这种方法，我们排查了十几个无用类和250+无用的方法。 +load优化 目前iOS App中或多或少的都会写一些+load方法，用于在App启动执行一些操作，+load方法在Initializers阶段被执行，但过多+load方法则会拖慢启动速度，对于大中型的App更是如此。通过对App中+load的方法分析，发现很多代码虽然需要在App启动时较早的时机进行初始化，但并不需要在+load这样非常靠前的位置，完全是可以延迟到App冷启动后的某个时间节点，例如一些路由操作。其实+load也可以被当做一种启动项来处理，所以在替换+load方法的具体实现上，我们仍然采用了上面的Kylin方式。 使用示例： //&nbsp;用WMAPP_BUSINESS_INIT_AFTER_HOMELOADING声明替换+load声明即可，不需其他改动WMAPP_BUSINESS_INIT_AFTER_HOMELOADING()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;原+load方法中的代码} //&nbsp;在某个合适的时机触发注册到该阶段的所有方法，如冷启动结束后[[KLNKylin&nbsp;sharedInstance]&nbsp;executeArrayForKey:@kWMAPP_BUSINESS_INITIALIZATION_AFTER_HOMELOADING_KEY]&nbsp;} 七、优化耗时操作 在main()之后主要工作是各种启动项的执行（上面已经叙述），主界面的构建，例如TabBarVC，HomeVC等等。资源的加载，如图片I/O、图片解码、archive文档等。这些操作中可能会隐含着一些耗时操作，靠单纯阅读非常难以发现，如何发现这些耗时点呢？找到合适的工具就会事半功倍。 Time Profiler Time Profiler是Xcode自带的时间性能分析工具，它按照固定的时间间隔来跟踪每一个线程的堆栈信息，通过统计比较时间间隔之间的堆栈状态，来推算某个方法执行了多久，并获得一个近似值。Time Profiler的使用方法网上有很多使用教程，这里我们也不过多介绍，附上一篇使用文档：Instruments Tutorial with Swift: Getting Started。 火焰图 除了Time Profiler，火焰图也是一个分析CPU耗时的利器，相比于Time Profiler，火焰图更加清晰。火焰图分析的产物是一张调用栈耗时图片，之所以称为火焰图，是因为整个图形看起来就像一团跳动的火焰，火焰尖部是调用栈的栈顶，底部是栈底，纵向表示调用栈的深度，横向表示消耗的时间。一个格子的宽度越大，越说明其可能是瓶颈。分析火焰图主要就是看那些比较宽大的火苗，特别留意那些类似“平顶山”的火苗。下面是美团平台开发的性能分析工具-Caesium的分析效果图： 通过对火焰图的分析，我们发现了冷启动过程中存在着不少问题，并成功优化了0.3S+的时间。优化内容总结如下： 八、优化串行操作 在冷启动过程中，有很多操作是串行执行的，若干个任务串行执行，时间必然比较长。如果能变串行为并行，那么冷启动时间就能够大大缩短。 闪屏页的使用 现在许多App在启动时并不直接进入首页，而是会向用户展示一个持续一小段时间的闪屏页，如果使用恰当，这个闪屏页就能帮我们节省一些启动时间。因为当一个App比较复杂的时候，启动时首次构建App的UI就是一个比较耗时的过程，假定这个时间是0.2秒，如果我们是先构建首页UI，然后再在Window上加上这个闪屏页，那么冷启动时，App就会实实在在地卡住0.2秒，但是如果我们是先把闪屏页作为App的RootViewController，那么这个构建过程就会很快。因为闪屏页只有一个简单的ImageView，而这个ImageView则会向用户展示一小段时间，这时我们就可以利用这一段时间来构建首页UI了，一举两得。 缓存定位&amp;首页预请求 美团外卖App冷启动过程中一个重要的串行流程就是：首页定位--&gt;首页请求--&gt;首页渲染过程，这三个操作占了整个首页加载时间的77%左右，所以想要缩短冷启动时间，就一定要从这三点出发进行优化。 之前串行操作流程如下： 优化后的设计，在发起定位的同时，使用客户端缓存定位，进行首页数据的预请求，使定位和请求并行进行。然后当用户真实定位成功后，判断真实定位是否命中缓存定位，如果命中，则刚才的预请求数据有效，这样可以节省大概40%的时间首页加载时间，效果非常明显；如果未命中，则弃用预请求数据，重新请求。 九、数据监控 Time Profiler和Caesium火焰图都只能在线下分析App在单台设备中的耗时操作，局限性比较大，无法在线上监控App在用户设备上的表现。外卖App使用公司内部自研的Metrics性能监控系统，长期监控App的性能指标，帮助我们掌握App在线上各种环境下的真实表现，并为技术优化项目提供可靠的数据支持。Metrics监控的核心指标之一，就是冷启动时间。 冷启动开始&amp;结束时间节点 结束时间点：结束时间比较好确定，我们可以将首页某些视图元素的展示作为首页加载完成的标志。 开始时间点：一般情况下，我们都是在main()之后才开始接管App，但以main()函数作为冷启动起始点显然不合适，因为这样无法统计到T1时间段。那么，起始时间如何确定呢？目前业界常见的有两种方法，一是以可执行文件中任意一个类的+load方法的执行时间作为起始点；二是分析dylib的依赖关系，找到叶子节点的dylib，然后以其中某个类的+load方法的执行时间作为起始点。根据Dyld对dylib的加载顺序，后者的时机更早。但是这两种方法获取的起始点都只在Initializers阶段，而Initializers之前的时长都没有被计入。Metrics则另辟蹊径，以App的进程创建时间（即exec函数执行时间）作为冷启动的起始时间。因为系统允许我们通过sysctl函数获得进程的有关信息，其中就包括进程创建的时间戳。 #import&nbsp;&lt;sys/sysctl.h&gt;#import&nbsp;&lt;mach/mach.h&gt;+&nbsp;(BOOL)processInfoForPID:(int)pid&nbsp;procInfo:(struct&nbsp;kinfo_proc*)procInfo{&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;cmd[4]&nbsp;=&nbsp;{CTL_KERN,&nbsp;KERN_PROC,&nbsp;KERN_PROC_PID,&nbsp;pid};&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;size&nbsp;=&nbsp;sizeof(*procInfo);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sysctl(cmd,&nbsp;sizeof(cmd)/sizeof(*cmd),&nbsp;procInfo,&nbsp;&amp;size,&nbsp;NULL,&nbsp;0)&nbsp;==&nbsp;0;}+&nbsp;(NSTimeInterval)processStartTime{&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;kinfo_proc&nbsp;kProcInfo;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;([self&nbsp;processInfoForPID:[[NSProcessInfo&nbsp;processInfo]&nbsp;processIdentifier]&nbsp;procInfo:&amp;kProcInfo])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;kProcInfo.kp_proc.p_un.__p_starttime.tv_sec&nbsp;*&nbsp;1000.0&nbsp;+&nbsp;kProcInfo.kp_proc.p_un.__p_starttime.tv_usec&nbsp;/&nbsp;1000.0;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSAssert(NO,&nbsp;@&quot;无法取得进程的信息&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;}} 进程创建的时机非常早。经过实验，在一个新建的空白App中，进程创建时间比叶子节点dylib中的+load方法执行时间早12ms，比main函数的执行时间早13ms（实验设备：iPhone 7 Plus （iOS 12.0）、Xcode 10.0、Release 模式）。外卖App线上的数据则更加明显，同样的机型（iPhone 7 Plus）和系统版本（iOS 12.0），进程创建时间比叶子节点dylib中的+load方法执行时间早688ms。而在全部机型和系统版本中，这一数据则是878ms。 冷启动过程时间节点 我们也在App冷启动过程中的所有关键节点打上一连串测速点，Metrics会记录下测速点的名称，及其距离进程创建时间的时长。我们没有采用自动打点的方式，是因为外卖App的冷启动过程十分复杂，而自动打点无法做到如此细致，并不实用。另外，Metrics记录的是时间轴上以进程创建时间为原点的一组顺序的时间点，而不是一组时间段，是因为顺序的时间点可以计算任意两个时间点之间的距离，即可以将时间点处理成时间段。但是，一组时间段可能无法还原为顺序的时间点，因为时间段之间可能并不是首尾相接的，特别是对于异步执行或者多线程的情况。 在测速完毕后，Metrics会统一将所有测速点上报到后台。下图是美团外卖App 6.10版本的部分过程节点监控数据截图： Metrics还会由后台对数据做聚合计算，得到冷启动总时长和各个测速点时长的50分位数、90分位数和95分位数的统计数据，这样我们就能从宏观上对冷启动时长分布情况有所了解。下图中横轴为时长，纵轴为上报的样本数。 十、总结 对于快速迭代的App，随着业务复杂度的增加，冷启动时长会不可避免的增加。冷启动流程也是一个比较复杂的过程，当遇到冷启动性能瓶颈时，我们可以根据App自身的特点，配合工具的使用，从多方面、多角度进行优化。同时，优化冷启动存量问题只是冷启动治理的第一步，因为冷启动性能问题并不是一日造成的，也不能简单的通过一次优化工作就能解决，我们需要通过合理的设计、规范的约束，来有效地管控性能问题的增量，并通过持续的线上监控来及时发现并修正性能问题，这样才能够长期保证良好的App冷启动体验。 作者简介 郭赛，美团点评资深工程师。2015年加入美团，目前作为外卖iOS团队主力开发，负责移动端业务开发，业务类基础设施的建设与维护。 徐宏，美团点评资深工程师。2016年加入美团，目前作为外卖iOS团队主力开发，负责移动端APM性能监控，高可用基础设施支撑相关推进工作。 欢迎加入美团iOS技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 美团外卖iOS多端复用的推动、支撑与思考 Category 特性在 iOS 组件化中的应用与管控 iOS系统中导航栏的转场解决方案与最佳实践","@type":"BlogPosting","url":"/2019/04/29/729111.html","headline":"iOS App冷启动治理：来自美团外卖的实践","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/29/729111.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>iOS App冷启动治理：来自美团外卖的实践</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;" data-mpa-powered-by="yiban.io"><img class="" data-copyright="0" data-ratio="0.10546875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png" data-type="png" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">总第309篇</span></strong></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">2018年 第101篇</span></strong></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;"><br></span></strong></p> 
<section data-role="outer" label="Powered by 135editor.com" style="font-size:16px;font-family:微软雅黑;"> 
 <section data-role="outer" label="Powered by 135editor.com"> 
  <section class="_135editor" data-tools="135编辑器" data-id="127" style="border-width: 0px;border-style: none;border-color: initial;"> 
   <section class="_135editor" data-tools="135编辑器" data-id="127" style="border-width: 0px;border-style: none;border-color: initial;"> 
    <section style="margin: 60px 16px 16px;border-width: 1px;border-style: solid;border-color: rgb(235, 234, 225);text-align: center;border-radius: 8px;font-weight: inherit;text-decoration: inherit;"> 
     <section style="font-size: 18px;margin-top: -3.3em;margin-right: 5px;margin-left: 5px;color: inherit;"> 
      <section style="border-width: 2px;border-style: solid;border-color: rgb(235, 234, 225);width: 108px;clear: both;margin-right: auto;margin-left: auto;height: 108px;border-radius: 50%;box-shadow: rgb(201, 201, 201) 0px 2px 2px 2px;background-color: rgb(254, 254, 254);"> 
       <img border="0" class="" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGpLQfCPYP5xPHgGAG5TqXoXCCanURVtuReGYV3hKwOcVicnkrGaUeLrA/640?wx_fmt=jpeg" data-type="jpeg" data-w="800" data-width="100%" height="84" opacity="" style="border-radius: 50%;color: inherit;display: inline-block;height: 84px;width: 84px;" title="undefined" width="84" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGpLQfCPYP5xPHgGAG5TqXoXCCanURVtuReGYV3hKwOcVicnkrGaUeLrA/640?wx_fmt=jpeg"> 
      </section> 
     </section> 
     <section class="135brush" data-brushtype="text" data-style="text-align: left; font-size: 14px; color: inherit;" style="font-size: 18px;margin: 8px 15px;line-height: 1.4;color: inherit;"> 
      <p style="text-align: left;"><span style="font-family: Helvetica, Arial, sans-serif;font-size: 13px;color: rgb(127, 127, 127);">本文主要分享美团外卖iOS客户端针对App冷启动性能进行治理的一些经验。</span></p> 
      <p style="margin-top: 10px;text-align: left;"><span style="font-family: Helvetica, Arial, sans-serif;font-size: 13px;color: rgb(127, 127, 127);">招聘：美团外卖长期招聘Android、iOS、FE高级/资深工程师和技术专家，Base北京、上海、成都，欢迎有兴趣的同学扫描并识别下方二维码查看岗位详情。</span></p> 
     </section> 
     <section style="margin: 10px 15px;border-top: 1px solid rgb(235, 234, 225);border-right-color: rgb(235, 234, 225);border-bottom-color: rgb(235, 234, 225);border-left-color: rgb(235, 234, 225);color: inherit;"> 
      <p style="color: inherit;"><strong><span style="font-size: 12.6px;letter-spacing: 1.5px;color: #25b7a7;">扫码查看职位详情，一键投递简历</span></strong></p> 
     </section> 
     <span style="font-size: 18px;margin-bottom: 5.4px;"><img class="" data-ratio="1.003787878787879" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGMDDNOw9QG6xGiasL6bR7MvW0L6eQI0SZv6aXVI46kP7jg6WCyFqXnyw/640?wx_fmt=jpeg" data-type="jpeg" data-w="264" height="89" style="color: inherit;margin-bottom: 5.4px;height: 89px;visibility: visible !important;" title="郭赛.jpeg" width="92" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGMDDNOw9QG6xGiasL6bR7MvW0L6eQI0SZv6aXVI46kP7jg6WCyFqXnyw/640?wx_fmt=jpeg"></span> 
    </section> 
   </section> 
  </section> 
 </section> 
</section> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;margin-left: 0.5em;margin-right: 0.5em;"> 
 <h1><span style="color: rgb(37, 183, 167);font-size: 20px;"><strong>一、背景</strong></span></h1> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;letter-spacing: 1px;">冷启动时长是App性能的重要指标，作为用户体验的第一道“门”，直接决定着用户对App的第一印象。美团外卖iOS客户端从2013年11月开始，历经几十个版本的迭代开发，产品形态不断完善，业务功能日趋复杂；同时外卖App也已经由原来的独立业务App演进成为一个平台App，陆续接入了闪购、跑腿等其他新业务。因此，更多更复杂的工作需要在App冷启动的时候被完成，这给App的冷启动性能带来了挑战。对此，我们团队基于业务形态的变化和外卖App的特点，对冷启动进行了持续且有针对性的优化工作，目的就是为了呈现更加流畅的用户体验。</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <h1><span style="color: rgb(37, 183, 167);font-size: 20px;"><strong>二、冷启动定义</strong></span></h1> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">一般而言，大家把iOS冷启动的过程定义为：从用户点击App图标开始到appDelegate didFinishLaunching方法执行完成为止。这个过程主要分为两个阶段：</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">T1：main()函数之前，即操作系统加载App可执行文件到内存，然后执行一系列的加载&amp;链接等工作，最后执行至App的main()函数。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">T2：main()函数之后，即从main()开始，到appDelegate的didFinishLaunchingWithOptions方法执行完毕。</span></p></li> 
 </ul> 
 <p style="text-align: center;"><br></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.0893169877408056" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEG2MBBicJkoBvLuiareBtdD8778sdkpsFAGXn075ibNj1jWfukSSxTAJW7w/640?wx_fmt=png" data-type="png" data-w="1142" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEG2MBBicJkoBvLuiareBtdD8778sdkpsFAGXn075ibNj1jWfukSSxTAJW7w/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">然而，当didFinishLaunchingWithOptions执行完成时，用户还没有看到App的主界面，也不能开始使用App。例如在外卖App中，App还需要做一些初始化工作，然后经历定位、首页请求、首页渲染等过程后，用户才能真正看到数据内容并开始使用，我们认为这个时候冷启动才算完成。我们把这个过程定义为T3。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.06272401433691756" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGrleFv2H2CSXd2hc5PVBTCx5FaZxfibRLiczQvxsBoIBgcPXs4rNictIMg/640?wx_fmt=png" data-type="png" data-w="2232" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGrleFv2H2CSXd2hc5PVBTCx5FaZxfibRLiczQvxsBoIBgcPXs4rNictIMg/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">综上，外卖App把冷启动过程定义为：<strong>从用户点击App图标开始到用户能看到App主界面内容为止这个过程，即T1+T2+T3</strong><strong style="font-size: inherit;color: inherit;line-height: inherit;">。</strong>在App冷启动过程当中，这三个阶段中的每个阶段都存在很多可以被优化的点。</span></p> 
 <h1><span style="font-size: 20px;"><strong><span style="color: rgb(37, 183, 167);">三、问题现状</span></strong></span></h1> 
 <h3 style="margin-top: 15px;"><span style="font-size: 18px;"><strong>性能存量问题</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">美团外卖iOS客户端经过几十个版本的迭代开发后，在冷启动过程中已经积累了若干性能问题，解决这些性能瓶颈是冷启动优化工作的首要目标，这些问题主要包括：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.5537918871252204" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEG3kESXQ1w3qwVfBSibuVMickwDrvoBZr4INOkcMtJQMLQmN8oyR5dmEow/640?wx_fmt=png" data-type="png" data-w="1134" style="width: 387px;height: 214px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEG3kESXQ1w3qwVfBSibuVMickwDrvoBZr4INOkcMtJQMLQmN8oyR5dmEow/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">注：启动项的定义，在App启动过程中需要被完成的某项工作，我们称之为一个启动项。例如某个SDK的初始化、某个功能的预加载等。</span></p> 
 <h3><span style="font-size: 18px;"><strong>性能增量问题</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">一般情况下，在App早期阶段，冷启动不会有明显的性能问题。冷启动性能问题也不是在某个版本突然出现的，而是随着版本迭代，App功能越来越复杂，启动任务越来越多，冷启动时间也一点点延长。最后当我们注意到，并想要优化它的时候，这个问题已经变得很棘手了。外卖App的性能问题增量主要来自启动项的增加，随着版本迭代，启动项任务简单粗暴地堆积在启动流程中。如果每个版本冷启动时间增加0.1s，那么几个版本下来，冷启动时长就会明显增加很多。</span></p> 
 <h1><span style="color: rgb(37, 183, 167);font-size: 20px;"><strong>四、治理思路</strong></span></h1> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">冷启动性能问题的治理目标主要有三个：</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">解决存量问题：优化当前性能瓶颈点，优化启动流程，缩短冷启动时间。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">管控增量问题：冷启动流程规范化，通过代码范式和文档指导后续冷启动过程代码的维护，控制时间增量。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">完善监控：完善冷启动性能指标监控，收集更详细的数据，及时发现性能问题。</span></p></li> 
 </ol> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.6172161172161172" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGKMnGLqMhLasicwSqEBm8cexH5u40IxEDX5ojMXOFL7DbmDvjoejvAbQ/640?wx_fmt=png" data-type="png" data-w="1092" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGKMnGLqMhLasicwSqEBm8cexH5u40IxEDX5ojMXOFL7DbmDvjoejvAbQ/640?wx_fmt=png"></p> 
 <h1><span style="color: rgb(37, 183, 167);font-size: 20px;"><strong>五、规范启动流程</strong></span></h1> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">截止至2017年底，美团外卖用户数已达2.5亿，而美团外卖App也已完成了从支撑单一业务的App到支持多业务的平台型App的演进</span><a href="https://tech.meituan.com/iOS_multiterminal_reuse.html" style="line-height: inherit;font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">（<span style="line-height: inherit;text-decoration: underline;font-size: 15px;color: rgb(136, 136, 136);">美团外卖iOS多端复用的推动、支撑与思考</span>）</span></a><span style="font-size: 15px;">，公司的一些新兴业务也陆续集成到外卖App当中。下面是外卖App的架构图，外卖的架构主要分为三层，底层是基础组件层，中层是外卖平台层，平台层向下管理基础组件，向上为业务组件提供统一的适配接口，上层是基础组件层，包括外卖业务拆分的子业务组件（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">外卖App和美团App中的外卖频道可以复用子业务组件</span><span style="font-size: 15px;">）和接入的其他非外卖业务。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.6012793176972282" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGHqcibHpPD7cu400LnWKeuQy4eheJib2ANqibRK9uZWibS5keNkNMhtYnWg/640?wx_fmt=png" data-type="png" data-w="938" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGHqcibHpPD7cu400LnWKeuQy4eheJib2ANqibRK9uZWibS5keNkNMhtYnWg/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">App的平台化为业务方提供了高效、标准的统一平台，但与此同时，平台化和业务的快速迭代也给冷启动带来了问题：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">现有的启动项堆积严重，拖慢启动速度。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">新的启动项缺乏添加范式，杂乱无章，修改风险大，难以阅读和维护。</span></p></li> 
 </ol> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">面对这个问题，我们首先梳理了目前启动流程中所有的启动项，然后针对App平台化设计了新的启动项管理方式：分阶段启动和启动项自注册<strong style="font-size: inherit;color: inherit;line-height: inherit;">。</strong></span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.4192495921696574" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGAia2hAiag9kWIToBM36FTYEZY518jzRMyvYu5YTbA8uz9ZeM1Z0839Sw/640?wx_fmt=png" data-type="png" data-w="1226" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGAia2hAiag9kWIToBM36FTYEZY518jzRMyvYu5YTbA8uz9ZeM1Z0839Sw/640?wx_fmt=png"></p> 
 <h3><span style="font-size: 18px;"><strong>分阶段启动</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">早期由于业务比较简单，所有启动项都是不加以区分，简单地堆积到didFinishLaunchingWithOptions方法中，但随着业务的增加，越来越多的启动项代码堆积在一起，性能较差，代码臃肿而混乱。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1.1858190709046454" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGb2icGchTqnAr0VicpfsfW1BAcfGiadjPzkbZvawokdJVzTDIx48nhI17A/640?wx_fmt=png" data-type="png" data-w="818" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGb2icGchTqnAr0VicpfsfW1BAcfGiadjPzkbZvawokdJVzTDIx48nhI17A/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过对SDK的梳理和分析，我们发现启动项也需要根据所完成的任务被分类，有些启动项是需要刚启动就执行的操作，如Crash监控、统计上报等，否则会导致信息收集的缺失；有些启动项需要在较早的时间节点完成，例如一些提供用户信息的SDK、定位功能的初始化、网络初始化等；有些启动项则可以被延迟执行，如一些自定义配置，一些业务服务的调用、支付SDK、地图SDK等。我们所做的分阶段启动，首先就是把启动流程合理地划分为若干个启动阶段，然后依据每个启动项所做的事情的优先级把它们分配到相应的启动阶段，优先级高的放在靠前的阶段，优先级低的放在靠后的阶段。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1.0886699507389161" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGpmLddhykz86Cx15ibwx1g4EfksshtwrMCO0HJqf5UoW9gUgxm3bicMBg/640?wx_fmt=png" data-type="png" data-w="812" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGpmLddhykz86Cx15ibwx1g4EfksshtwrMCO0HJqf5UoW9gUgxm3bicMBg/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">下面是我们对美团外卖App启动阶段进行的重新定义，对所有启动项进行的梳理和重新分类，把它们对应到合理的启动阶段。这样做一方面可以推迟执行那些不必过早执行的启动项，缩短启动时间；另一方面，把启动项进行归类，方便后续的阅读和维护。然后把这些规则落地为启动项的维护文档，指导后续启动项的新增和维护。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1.074468085106383" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGDht8tZhFhyEzViaY4u6VFlsHribcr6Y9YcbEtsILcczAf5ibLb8vv3t5Q/640?wx_fmt=png" data-type="png" data-w="658" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGDht8tZhFhyEzViaY4u6VFlsHribcr6Y9YcbEtsILcczAf5ibLb8vv3t5Q/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过上面的工作，我们梳理出了十几个可以推迟执行的启动项，占所有启动项的30%左右，有效地优化了启动项所占的这部分冷启动时间。</span></p> 
 <h3><span style="font-size: 18px;"><strong>启动项自注册</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">确定了启动项分阶段启动的方案后，我们面对的问题就是如何执行这些启动项。比较容易想到的方案是：在启动时创建一个启动管理器，然后读取所有启动项，然后当时间节点到来时由启动器触发启动项执行。这种方式存在两个问题：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">所有启动项都要预先写到一个文件中（</span><span style="line-height: inherit;font-size: 15px;color: rgb(136, 136, 136);">在.m文件import，或用.plist文件组织</span><span style="color: inherit;line-height: inherit;font-size: 15px;">），这种中心化的写法会导致臃肿的代码，难以阅读维护。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">启动项代码无法复用：启动项无法收敛到子业务库内部，在外卖App和美团App中要重复实现，和外卖App平台化的方向不符。</span></p></li> 
 </ol> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.7908496732026143" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEG3TJTVS7Vaw6IOFtgNlm79ZgAE3RcTMROgDLnYjwb1FMOzOrysAd20Q/640?wx_fmt=png" data-type="png" data-w="918" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEG3TJTVS7Vaw6IOFtgNlm79ZgAE3RcTMROgDLnYjwb1FMOzOrysAd20Q/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">而我们希望的方式是，启动项维护方式可插拔，启动项之间、业务模块之间不耦合，且一次实现可在两端复用。下图是我们采用的启动项管理方式，我们称之为启动项的自注册：一个启动项定义在子业务模块内部，被封装成一个方法，并且自声明启动阶段（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">例如一个启动项A，在独立App中可以声明为在willFinishLaunch阶段被执行，在美团App中则声明在resignActive阶段被执行</span><span style="font-size: 15px;">）。这种方式下，启动项即实现了两端复用，不相关的启动项互相隔离，添加/删除启动项都更加方便。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.8406113537117904" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGnQbvbcvsaIUKVDUjBhD4M3SyeMt35DA4xFfENtcvkcMb8Y3ovkCjzw/640?wx_fmt=png" data-type="png" data-w="916" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGnQbvbcvsaIUKVDUjBhD4M3SyeMt35DA4xFfENtcvkcMb8Y3ovkCjzw/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">那么如何给一个启动项声明启动阶段？又如何在正确的时机触发启动项的执行呢？在代码上，一个启动项最终都会对应到一个函数的执行，所以在运行时只要能获取到函数的指针，就可以触发启动项。美团平台开发的组件启动治理基建Kylin正是这样做的：Kylin的核心思想就是在编译时把数据（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">如函数指针</span><span style="font-size: 15px;">）写入到可执行文件的__DATA段中，运行时再从__DATA段取出数据进行相应的操作（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">调用函数</span><span style="font-size: 15px;">）。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">为什么要用借用__DATA段呢？原因就是为了能够覆盖所有的启动阶段，例如main()之前的阶段。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.448210922787194" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEG7VLyfTj26LMTL0UVOry005qEZa1oeh5SYosaJmpuUyP5ruPhAcI1DA/640?wx_fmt=png" data-type="png" data-w="1062" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEG7VLyfTj26LMTL0UVOry005qEZa1oeh5SYosaJmpuUyP5ruPhAcI1DA/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Kylin实现原理简述：Clang 提供了很多的编译器函数，它们可以完成不同的功能。其中一种就是 section() 函数，section()函数提供了二进制段的读写能力，它可以将一些编译期就可以确定的常量写入数据段。 在具体的实现中，主要分为编译期和运行时两个部分。在编译期，编译器会将标记了 attribute((section())) 的数据写到指定的数据段中，例如写一个{key(key代表不同的启动阶段), *pointer}对到数据段。到运行时，在合适的时间节点，在根据key读取出函数指针，完成函数的调用。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">上述方式，可以封装成一个宏，来达到代码的简化，以调用宏 KLN_STRINGS_EXPORT("Key", "Value")为例，最终会被展开为：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs cpp" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">__attribute__((used,&nbsp;section(<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"__DATA"</span>&nbsp;<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">","</span>&nbsp;<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"__kylin__"</span>)))&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">static</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;KLN_DATA&nbsp;__kylin__0&nbsp;=&nbsp;(KLN_DATA){(KLN_DATA_HEADER){<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Key"</span>,&nbsp;KLN_STRING,&nbsp;KLN_IS_ARRAY},&nbsp;<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Value"</span>};<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">使用示例，编译器把启动项函数注册到启动阶段A：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs php" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">KLN_FUNCTIONS_EXPORT(STAGE_KEY_A)()&nbsp;{&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;在a.m文件中，通过注册宏，把启动项A声明为在STAGE_KEY_A阶段执行</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;启动项代码A</span><br>}<br></span></code></pre> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs cpp" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">KLN_FUNCTIONS_EXPORT(STAGE_KEY_A)()&nbsp;{&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;在b.m文件中，把启动项B声明为在STAGE_KEY_A阶段执行</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;启动项代码B</span><br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在启动流程中，在启动阶段STAGE_KEY_A触发所有注册到STAGE_KEY_A时间节点的启动项，通过对这种方式，几乎没有任何额外的辅助代码，我们用一种很简洁的方式完成了启动项的自注册。</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">-&nbsp;(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">BOOL</span>)application:(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">UIApplication</span>&nbsp;*)application&nbsp;didFinishLaunchingWithOptions:(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSDictionary</span>&nbsp;*)launchOptions&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;其他逻辑</span><br>&nbsp;&nbsp;&nbsp;&nbsp;[[KLNKylin&nbsp;sharedInstance]&nbsp;executeArrayForKey:STAGE_KEY_A];&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;在此触发所有注册到STAGE_KEY_A时间节点的启动项</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;其他逻辑</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">YES</span>;<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">完成对现有的启动项的梳理和优化后，我们也输出了后续启动项的添加&amp;维护规范，规范后续启动项的分类原则，优先级和启动阶段。目的是管控性能问题增量，保证优化成果。</span></p> 
 <section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;"> 
  <h1><span style="color: rgb(37, 183, 167);font-size: 20px;"><strong>六、优化main()之前</strong></span></h1> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在调用main()函数之前，基本所有的工作都是由操作系统完成的，开发者能够插手的地方不多，所以如果想要优化这段时间，就必须先了解一下，操作系统在main()之前做了什么。main()之前操作系统所做的工作就是把可执行文件（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">Mach-O格式</span><span style="font-size: 15px;">）加载到内存空间，然后加载动态链接库dyld，再执行一系列动态链接操作和初始化操作的过程（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">加载、绑定、及初始化方法</span><span style="font-size: 15px;">）。这方面的资料网上比较多，但重复性较高，此处附上一篇WWDC的Topic：</span><span style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><a href="https://asciiwwdc.com/2016/sessions/406" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;">Optimizing App Startup Time</a>。</span></p> 
  <h2><span style="font-size: 18px;"><strong>加载过程—从exec()到main()</strong></span></h2> 
  <p><span style="font-size: 15px;"><br></span></p> 
  <p><span style="font-size: 15px;">真正的加载过程从exec()函数开始，exec()是一个系统调用。操作系统首先为进程分配一段内存空间，然后执行如下操作：</span></p> 
  <p><span style="font-size: 15px;"><br></span></p> 
 </section> 
 <section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;"> 
  <ol style="" class=" list-paddingleft-2"> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">把App对应的可执行文件加载到内存。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">把Dyld加载到内存。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">Dyld进行动态链接。</span></p></li> 
  </ol> 
  <p style="text-align: center;"><br></p> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.04772902232486528" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGiarMjXpOC9oBowzaNSomztIRHzAzayIekmP18xvl26mMXKnBnmD9fYQ/640?wx_fmt=png" data-type="png" data-w="2598" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGiarMjXpOC9oBowzaNSomztIRHzAzayIekmP18xvl26mMXKnBnmD9fYQ/640?wx_fmt=png"></p> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">下面我们简要分析一下Dyld在各阶段所做的事情：</span></p> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.48671875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGjh4RFY3wuc2JoaLwDZZarnxUU0VQMYZICI9lIStE3IoBPtV6jdxNGg/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGjh4RFY3wuc2JoaLwDZZarnxUU0VQMYZICI9lIStE3IoBPtV6jdxNGg/640?wx_fmt=jpeg"></p> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">最后 dyld 会调用 main() 函数，main() 会调用 UIApplicationMain()，before main()的过程也就此完成。</span></p> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">了解完main()之前的加载过程后，我们可以分析出一些影响T1时间的因素：</span></p> 
 </section> 
 <section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;"> 
  <ol style="" class=" list-paddingleft-2"> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">动态库加载越多，启动越慢。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">ObjC类，方法越多，启动越慢。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">ObjC的+load越多，启动越慢。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">C的constructor函数越多，启动越慢。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">C++静态对象越多，启动越慢。</span></p></li> 
  </ol> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">针对以上几点，我们做了如下一些优化工作：</span></p> 
  <h3><span style="font-size: 18px;"><strong>代码瘦身</strong></span></h3> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">随着业务的迭代，不断有新的代码加入，同时也会废弃掉无用的代码和资源文件，但是工程中经常有无用的代码和文件被遗弃在角落里，没有及时被清理掉。这些无用的部分一方面增大了App的包体积，另一方便也拖慢了App的冷启动速度，所以及时清理掉这些无用的代码和资源十分有必要。</span></p> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过对Mach-O文件的了解，可以知道__TEXT:__objc_methname:中包含了代码中的所有方法，而__DATA__objc_selrefs中则包含了所有被使用的方法的引用，通过取两个集合的差集就可以得到所有未被使用的代码。核心方法如下，具体可以参考：</span><a href="https://github.com/nst/objc_cover" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">objc_cover</span></a><span style="font-size: 15px;">:</span></p> 
  <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs lua" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">def&nbsp;referenced_selectors(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">path</span>):<br>&nbsp;&nbsp;&nbsp;&nbsp;re_sel&nbsp;=&nbsp;re.compile(<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"__TEXT:__objc_methname:(.+)"</span>)&nbsp;//获取所有方法<br>&nbsp;&nbsp;&nbsp;&nbsp;refs&nbsp;=&nbsp;set()<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">lines</span>&nbsp;=&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">os</span>.<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">popen</span>(<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"/usr/bin/otool&nbsp;-v&nbsp;-s&nbsp;__DATA&nbsp;__objc_selrefs&nbsp;%s"</span>&nbsp;%&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">path</span>).readlines()&nbsp;#&nbsp;ios&nbsp;&amp;&nbsp;mac&nbsp;//真正被使用的方法<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">for</span>&nbsp;line&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">in</span>&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">lines</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results&nbsp;=&nbsp;re_sel.findall(line)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;results:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refs.add(results[<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>])<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;refs<br>}<br></span></code></pre> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过这种方法，我们排查了十几个无用类和250+无用的方法。</span></p> 
  <h3><span style="font-size: 18px;"><strong>+load优化</strong></span></h3> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">目前iOS App中或多或少的都会写一些+load方法，用于在App启动执行一些操作，+load方法在Initializers阶段被执行，但过多+load方法则会拖慢启动速度，对于大中型的App更是如此。通过对App中+load的方法分析，发现很多代码虽然需要在App启动时较早的时机进行初始化，但并不需要在+load这样非常靠前的位置，完全是可以延迟到App冷启动后的某个时间节点，例如一些路由操作。其实+load也可以被当做一种启动项来处理，所以在替换+load方法的具体实现上，我们仍然采用了上面的Kylin方式。</span></p> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">使用示例：</span></p> 
  <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs cpp" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;用WMAPP_BUSINESS_INIT_AFTER_HOMELOADING声明替换+load声明即可，不需其他改动</span><br>WMAPP_BUSINESS_INIT_AFTER_HOMELOADING()&nbsp;{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;原+load方法中的代码</span><br>}<br></span></code></pre> 
  <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs cs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;在某个合适的时机触发注册到该阶段的所有方法，如冷启动结束后</span><br>[<span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">[KLNKylin&nbsp;sharedInstance</span>]&nbsp;executeArrayForKey:@kWMAPP_BUSINESS_INITIALIZATION_AFTER_HOMELOADING_KEY]&nbsp;<br>}</span></code></pre> 
 </section> 
</section> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;margin-left: 0.5em;margin-right: 0.5em;"> 
 <h1><br></h1> 
 <h1><span style="color: rgb(37, 183, 167);font-size: 20px;"><strong>七、优化耗时操作</strong></span></h1> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">在main()之后主要工作是各种启动项的执行（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">上面已经叙述</span><span style="font-size: 15px;">），主界面的构建，例如TabBarVC，HomeVC等等。资源的加载，如图片I/O、图片解码、archive文档等。这些操作中可能会隐含着一些耗时操作，靠单纯阅读非常难以发现，如何发现这些耗时点呢？找到合适的工具就会事半功倍。</span></p> 
 <h3><br></h3> 
 <h3><span style="font-size: 18px;"><strong>Time Profiler</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Time Profiler是Xcode自带的时间性能分析工具，它按照固定的时间间隔来跟踪每一个线程的堆栈信息，通过统计比较时间间隔之间的堆栈状态，来推算某个方法执行了多久，并获得一个近似值。Time Profiler的使用方法网上有很多使用教程，这里我们也不过多介绍，附上一篇使用文档：</span><span style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><a href="https://www.raywenderlich.com/397-instruments-tutorial-with-swift-getting-started" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;">Instruments Tutorial with Swift: Getting Started</a>。</span></p> 
 <h3><span style="font-size: 18px;"><strong>火焰图</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">除了Time Profiler，火焰图也是一个分析CPU耗时的利器，相比于Time Profiler，火焰图更加清晰。火焰图分析的产物是一张调用栈耗时图片，之所以称为火焰图，是因为整个图形看起来就像一团跳动的火焰，火焰尖部是调用栈的栈顶，底部是栈底，纵向表示调用栈的深度，横向表示消耗的时间。一个格子的宽度越大，越说明其可能是瓶颈。分析火焰图主要就是看那些比较宽大的火苗，特别留意那些类似“平顶山”的火苗。下面是美团平台开发的性能分析工具-Caesium的分析效果图：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.6148867313915858" data-src="https://mmbiz.qpic.cn/mmbiz_gif/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGT5TwwVDLwkZFWIJjibYAHAdJNJcxLPaSqROyDAzxevtdj1owKiaESzmQ/640?wx_fmt=gif" data-type="gif" data-w="927" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGT5TwwVDLwkZFWIJjibYAHAdJNJcxLPaSqROyDAzxevtdj1owKiaESzmQ/640?wx_fmt=gif"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过对火焰图的分析，我们发现了冷启动过程中存在着不少问题，并成功优化了0.3S+的时间。优化内容总结如下：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.203125" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGOCCWEQSNLiczDF6dQH59logOAoxJO003ZPicj0lNk6G2DR9G7XUNJr1w/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGOCCWEQSNLiczDF6dQH59logOAoxJO003ZPicj0lNk6G2DR9G7XUNJr1w/640?wx_fmt=jpeg"></p> 
 <p><br></p> 
 <h1><span style="color: rgb(37, 183, 167);font-size: 20px;"><strong>八、优化串行操作</strong></span></h1> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">在冷启动过程中，有很多操作是串行执行的，若干个任务串行执行，时间必然比较长。如果能变串行为并行，那么冷启动时间就能够大大缩短。</span></p> 
 <h3><br></h3> 
 <h3><span style="font-size: 18px;"><strong>闪屏页的使用</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">现在许多App在启动时并不直接进入首页，而是会向用户展示一个持续一小段时间的闪屏页，如果使用恰当，这个闪屏页就能帮我们节省一些启动时间。因为当一个App比较复杂的时候，启动时首次构建App的UI就是一个比较耗时的过程，假定这个时间是0.2秒，如果我们是先构建首页UI，然后再在Window上加上这个闪屏页，那么冷启动时，App就会实实在在地卡住0.2秒，但是如果我们是先把闪屏页作为App的RootViewController，那么这个构建过程就会很快。因为闪屏页只有一个简单的ImageView，而这个ImageView则会向用户展示一小段时间，这时我们就可以利用这一段时间来构建首页UI了，一举两得。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.4060529634300126" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGLHMbbEj7e1az9TADqgsyEpVkySwB6UUxYdTfiaal5lLJbicI84kJNmDA/640?wx_fmt=png" data-type="png" data-w="1586" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGLHMbbEj7e1az9TADqgsyEpVkySwB6UUxYdTfiaal5lLJbicI84kJNmDA/640?wx_fmt=png"></p> 
 <h3><span style="font-size: 18px;"><strong>缓存定位&amp;首页预请求</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">美团外卖App冷启动过程中一个重要的串行流程就是：首页定位--&gt;首页请求--&gt;首页渲染过程，这三个操作占了整个首页加载时间的77%左右，所以想要缩短冷启动时间，就一定要从这三点出发进行优化。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">之前串行操作流程如下：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.2442455242966752" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGRW85ibwswosTB28LSBq3b10kM2TXhjrVTSt1IHBOBYVWNcwu4ib2OI2w/640?wx_fmt=png" data-type="png" data-w="1564" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGRW85ibwswosTB28LSBq3b10kM2TXhjrVTSt1IHBOBYVWNcwu4ib2OI2w/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">优化后的设计，在发起定位的同时，使用客户端缓存定位，进行首页数据的预请求，使定位和请求并行进行。然后当用户真实定位成功后，判断真实定位是否命中缓存定位，如果命中，则刚才的预请求数据有效，这样可以节省大概40%的时间首页加载时间，效果非常明显；如果未命中，则弃用预请求数据，重新请求。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.2267515923566879" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGQ2nsheIXj3fcBGxWFjwkHzVPsvJGwjTH4JiaUVUCUmqZEyRkw2wXt5w/640?wx_fmt=png" data-type="png" data-w="1570" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGQ2nsheIXj3fcBGxWFjwkHzVPsvJGwjTH4JiaUVUCUmqZEyRkw2wXt5w/640?wx_fmt=png"></p> 
 <h1><span style="font-size: 20px;color: rgb(37, 183, 167);"><strong>九、数据监控</strong></span></h1> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">Time Profiler和Caesium火焰图都只能在线下分析App在单台设备中的耗时操作，局限性比较大，无法在线上监控App在用户设备上的表现。外卖App使用公司内部自研的Metrics性能监控系统，长期监控App的性能指标，帮助我们掌握App在线上各种环境下的真实表现，并为技术优化项目提供可靠的数据支持。Metrics监控的核心指标之一，就是冷启动时间。</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <h3><span style="font-size: 18px;"><strong>冷启动开始&amp;结束时间节点</strong></span></h3> 
 <p><span style="font-size: 18px;"><strong><br></strong></span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">结束时间点：结束时间比较好确定，我们可以将首页某些视图元素的展示作为首页加载完成的标志。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">开始时间点：一般情况下，我们都是在main()之后才开始接管App，但以main()函数作为冷启动起始点显然不合适，因为这样无法统计到T1时间段。那么，起始时间如何确定呢？目前业界常见的有两种方法，一是以可执行文件中任意一个类的+load方法的执行时间作为起始点；二是分析dylib的依赖关系，找到叶子节点的dylib，然后以其中某个类的+load方法的执行时间作为起始点。根据Dyld对dylib的加载顺序，后者的时机更早。但是这两种方法获取的起始点都只在Initializers阶段，而Initializers之前的时长都没有被计入。Metrics则另辟蹊径，以App的进程创建时间（</span><span style="line-height: inherit;font-size: 15px;color: rgb(136, 136, 136);">即exec函数执行时间</span><span style="color: inherit;line-height: inherit;font-size: 15px;">）作为冷启动的起始时间。因为系统允许我们通过sysctl函数获得进程的有关信息，其中就包括进程创建的时间戳。</span></p><p><span style="color: inherit;line-height: inherit;font-size: 15px;"></span></p></li> 
 </ol> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">&lt;sys/sysctl.h&gt;</span></span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">&lt;mach/mach.h&gt;</span></span><br><br>+&nbsp;(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">BOOL</span>)processInfoForPID:(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>)pid&nbsp;procInfo:(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;kinfo_proc*)procInfo<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>&nbsp;cmd[<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">4</span>]&nbsp;=&nbsp;{<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">CTL_KERN</span>,&nbsp;KERN_PROC,&nbsp;KERN_PROC_PID,&nbsp;pid};<br>&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;size&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">sizeof</span>(*procInfo);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;sysctl(cmd,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">sizeof</span>(cmd)/<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">sizeof</span>(*cmd),&nbsp;procInfo,&nbsp;&amp;size,&nbsp;<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">NULL</span>,&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>)&nbsp;==&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>;<br>}<br><br>+&nbsp;(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSTimeInterval</span>)processStartTime<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;kinfo_proc&nbsp;kProcInfo;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;([<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>&nbsp;processInfoForPID:[[<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSProcessInfo</span>&nbsp;processInfo]&nbsp;processIdentifier]&nbsp;procInfo:&amp;kProcInfo])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;kProcInfo.kp_proc.p_un.__p_starttime.tv_sec&nbsp;*&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1000.0</span>&nbsp;+&nbsp;kProcInfo.kp_proc.p_un.__p_starttime.tv_usec&nbsp;/&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1000.0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSAssert</span>(<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">NO</span>,&nbsp;<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">@"无法取得进程的信息"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">进程创建的时机非常早。经过实验，在一个新建的空白App中，进程创建时间比叶子节点dylib中的+load方法执行时间早12ms，比main函数的执行时间早13ms（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">实验设备：iPhone 7 Plus （iOS 12.0）、Xcode 10.0、Release 模式</span><span style="font-size: 15px;">）。外卖App线上的数据则更加明显，同样的机型（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">iPhone 7 Plus</span><span style="font-size: 15px;">）和系统版本（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">iOS 12.0</span><span style="font-size: 15px;">），进程创建时间比叶子节点dylib中的+load方法执行时间早688ms。而在全部机型和系统版本中，这一数据则是878ms。</span></p> 
 <h3><span style="font-size: 18px;"><strong>冷启动过程时间节点</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们也在App冷启动过程中的所有关键节点打上一连串测速点，Metrics会记录下测速点的名称，及其距离进程创建时间的时长。我们没有采用自动打点的方式，是因为外卖App的冷启动过程十分复杂，而自动打点无法做到如此细致，并不实用。另外，Metrics记录的是时间轴上以进程创建时间为原点的一组顺序的时间点，而不是一组时间段，是因为顺序的时间点可以计算任意两个时间点之间的距离，即可以将时间点处理成时间段。但是，一组时间段可能无法还原为顺序的时间点，因为时间段之间可能并不是首尾相接的，特别是对于异步执行或者多线程的情况。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在测速完毕后，Metrics会统一将所有测速点上报到后台。下图是美团外卖App 6.10版本的部分过程节点监控数据截图：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.6376963350785341" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGuJ7aKSk9KJ4vic4rBfRPcmbUcFuPG9vkGKS98OJyhQPYPdlJ10znQcg/640?wx_fmt=png" data-type="png" data-w="1910" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGuJ7aKSk9KJ4vic4rBfRPcmbUcFuPG9vkGKS98OJyhQPYPdlJ10znQcg/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Metrics还会由后台对数据做聚合计算，得到冷启动总时长和各个测速点时长的50分位数、90分位数和95分位数的统计数据，这样我们就能从宏观上对冷启动时长分布情况有所了解。下图中横轴为时长，纵轴为上报的样本数。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.3492682926829268" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGzaLc0NniaicDLnBH8QRl20D98Y5l4rqXRGLuNQLkMXQVBicDXC1P5icQZw/640?wx_fmt=png" data-type="png" data-w="2050" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnTI7oawW8yYMfCd5oyEEGzaLc0NniaicDLnBH8QRl20D98Y5l4rqXRGLuNQLkMXQVBicDXC1P5icQZw/640?wx_fmt=png"></p> 
 <br> 
 <h1><span style="color: rgb(37, 183, 167);font-size: 20px;"><strong>十、总结</strong></span></h1> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">对于快速迭代的App，随着业务复杂度的增加，冷启动时长会不可避免的增加。冷启动流程也是一个比较复杂的过程，当遇到冷启动性能瓶颈时，我们可以根据App自身的特点，配合工具的使用，从多方面、多角度进行优化。同时，优化冷启动存量问题只是冷启动治理的第一步，因为冷启动性能问题并不是一日造成的，也不能简单的通过一次优化工作就能解决，我们需要通过合理的设计、规范的约束，来有效地管控性能问题的增量，并通过持续的线上监控来及时发现并修正性能问题，这样才能够长期保证良好的App冷启动体验。</span></p> 
 <h1><br></h1> 
 <h1><strong style="color: rgb(51, 51, 51);font-size: 16px;white-space: normal;"><span style="color: rgb(49, 188, 173);">作者简介</span></strong></h1> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;color: rgb(136, 136, 136);">郭赛，美团点评资深工程师。2015年加入美团，目前作为外卖iOS团队主力开发，负责移动端业务开发，业务类基础设施的建设与维护。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;color: rgb(136, 136, 136);">徐宏，美团点评资深工程师。2016年加入美团，目前作为外卖iOS团队主力开发，负责移动端APM性能监控，高可用基础设施支撑相关推进工作。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;color: rgb(136, 136, 136);"><span style="font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);font-size: 15px;color: rgb(136, 136, 136);">欢迎加入<strong style="color: rgb(51, 51, 51);"><span style="color: rgb(0, 0, 0);">美团iOS技术交流群</span></strong>，跟作者零距离交流。进群方式：请加美美同学<span style="letter-spacing: 0px;">微信（微信号：</span></span><span style="font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;text-align: justify;background-color: rgb(255, 255, 255);font-size: 15px;color: rgb(136, 136, 136);"><strong>MTDPtech02</strong><strong>）</strong>，回复：</span></span><span style="font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;text-align: justify;background-color: rgb(255, 255, 255);font-size: 15px;color: rgb(0, 0, 0);"><strong>iOS</strong></span><span style="font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;text-align: justify;font-size: 15px;color: rgb(136, 136, 136);background-color: rgb(255, 255, 255);">，美美会自动拉你进群。</span></p> 
</section> 
<p style="white-space: normal;color: rgb(51, 51, 51);text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 15px;color: rgb(136, 136, 136);">----------&nbsp; END&nbsp; ----------</span></p> 
<p data-source-line="194" style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 16px;"><strong><span style="color: rgb(49, 188, 173);">也许你还想看</span></strong></span></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748259&amp;idx=1&amp;sn=a7ef0d515e94631c8d86bdbbf81da143&amp;chksm=bd12aeee8a6527f8a297d0dc797b81492837019c821898ae21c3e158831aaa7a383d5155ec9b&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">美团外卖iOS多端复用的推动、支撑与思考</span></a></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651749345&amp;idx=3&amp;sn=786ba70e62c3db966e26df4a4fd5869d&amp;chksm=bd12a2ac8a652bbac2d253948c30d6a2d52d5f4bca1f8fd30607949586ac5f9628c45eca2f81&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">Category 特性在 iOS 组件化中的应用与管控</span></a><br></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651749161&amp;idx=2&amp;sn=d58aeae3d6b124794f412707190ea022&amp;chksm=bd12a2648a652b72ea65324a6b89bdd2bf5dd2f74d470063e3f83a5e44ef4f7b4fceb4e961c4&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">iOS系统中导航栏的转场解决方案与最佳实践</span></a><br></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.44533333333333336" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png" data-type="png" data-w="1875" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png"></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
