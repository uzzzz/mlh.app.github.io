<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>前端代码的整洁之道   技术头条 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="前端代码的整洁之道   技术头条" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="在前端开发过程中，你有没有遇到过由于代码交互太多太重时，想改动一行代码“牵一发而动全身”；使用框架很爽，可框架绑定应用却很麻烦？那么如何解决呢？ 你需要“前端整洁”。 作者 |&nbsp;Phodal 责编 | 伍杏玲 前端的恶梦 在我最近的一个项目里，我使用了 Angular 和混合应用技术编写了一个实时聊天应用。为了方便这个应用直接修改，无缝地嵌入到其它应用程序中。我尽量减少了 Component 和 Service 的数量。 然而，由于交互复杂 Component 的数量也不能减少。随后，当我们完成了这个项目的时候，主要的组件代码差不多有 1000 行。这差不多是一个复杂的应用的代码数。在我试图多次去重构代码时，我发现这并不是一件容易的事：太多的交互。 导致了 UI 层的代码，很难被抽取出去。我还能做的事情是将一些业务逻辑抽取出来，只是怎么去抽取了？这成了我的一个疑惑。 MVP 嘛，逻辑不都是放到 Presenter 里，还有其它的招吗？ AVR is Evil Angular、Vue 和 React 都是一些不错的框架，但是它们都是恶魔，因为我们绑定了框架。我们可以很快地从一个 React 的框架，迁移应用到其它类 React 框架，诸如 Preact；我们可以从一个类似于 Vue 的框架，迁移应用到其它类 Vue 的应用。但是我们很难从 React 迁移到 Angular，又或者是 Vue 迁移到 Angular。 万一有一天某个框架的核心维护人员健康状况不好，那么我们可能就得重写整个应用。这对于一个技术人员/Tech Lead/项目经验/业务人员来说，这种情况是不可接受的。 所以，为了应对这些框架带来的问题，我们选择 Web Components 技术，又或者是微前端技术，从架构上切开我们的业务。但是它们并不是银弹，它们反而是一个累赘，限定了高版本的浏览器，制定了更多的规范。 与此同时，不论是微前端技术还是 Web Components，它们都没有解决一个问题：框架绑定应用。 框架绑定应用，就是一种灾害。没有人希望哪一天因为 Java 需要高额的付费，而导致我们选择重写整个应用。 组件化及 Presenter 过重 应对页面逻辑过于重的问题，我们选择了组件化。将一个页面拆分成一系列的业务组件，再进一步地对这些业务组件进行地次细分，形成更小的业务组件，最后它们都依赖于组件库。 可是呢，细化存在一个问题是：更难以摆脱的框架绑定。与此同时，我们大量的业务逻辑仍然放置在 Presenter 里。我们的 Presenter 充满了大量的业务逻辑和非业务逻辑： 页面展示相应的逻辑。诸如点击事件、提交表单等等。 状态管理。诸如是否展示，用户登录状态等等。 业务逻辑。诸如某个字符串，要用怎样的形式展示。 数据持续化。哪些数据需要存储在 LocalStorage，哪些数据存储在 IndexedDB 里？ 为了应对 Presenter 过重的问题，我们使用了 Service 来处理某一块具体的业务，我们使用了 Utils、Helper 来处理一些公共的逻辑。哪怕是如此，我们使用 A 框架编写的业务逻辑，到了 B 框架中无法复用。 直到我最近重新接触了 Clean Architectrue，我发现 Presenter 还是可以进一步拆分的。 整洁的前端架构 Clean Architecture 是由 Robert C. Martin 在 2012 年提出的。最早，我只看到在 Android 应用上的使用，一来 Android 开发使用的是 Java，二来 Android 应用有很重的 View 层。 与此同时，在 7 年的时间里，由于前后端的分离，UI 层已经从后端的部分消失了。当然了，你也可以说 JSON 也是一种 View（至少它是可见的）。尽管，还存在一定数量的后端渲染 Web 应用，但是新的应用几乎不采用这样的模式。 但是，在 9012 年的今天，前端应用走向了 MV* 的架构方案，也有了一层很重的 View 层。类似于过去的后端应用，或者后端应用。相似的架构，也可以在前端项目中使用。 整洁架构 Robert C. Martin 总结了六边形架构（即端口与适配器架构）：DCI （Data-Context-Interactions，数据-场景-交互）架构、BCI（Boundary Control Entity，Boundary Control Entity）架构等多种架构，归纳出了这些架构的基本特点： 框架无关性。系统不依赖于框架中的某个函数，框架只是一个工具，系统不能适应于框架。 可被测试。业务逻辑脱离于 UI、数据库等外部元素进行测试。 UI&nbsp;无关性。不需要修改系统的其它部分，就可以变更 UI，诸如由 Web 界面替换成 CLI。 数据库无关性。业务逻辑与数据库之间需要进行解耦，我们可以随意切换 LocalStroage、IndexedDB、Web SQL。 外部机构（agency）无关性。系统的业务逻辑，不需要知道其它外部接口，诸如安全、调度、代理等。 如你所见，作为一个普通（不分前后端）的开发人员，我们关注于业务逻辑的抽离，让业务逻辑独立于框架。 而在前端的实化，则是让前端的业务逻辑，可以独立于框架，只让 UI（即表现层）与框架绑定。一旦，我们更换框架的时候，只需要替换这部分的业务逻辑即可。 为此，基于这个概念 Robert C. Martin 绘制出了整洁架构的架构图： Clean Architecture 如图所示，Clean Architecture 一共分为四个环，四个层级。环与环之间，存在一个依赖关系原则：源代码中的依赖关系，必须只指向同心圆的内层，即由低层机制指向高级策略。其类似于 SOLID 中的依赖倒置原则： 高层模块不应该依赖低层模块，两者都应该依赖其抽象。 抽象不应该依赖细节，细节应该依赖抽象。 与此同时，四个环都存在各自核心的概念： 实体（Entities），又称领域对象或业务对象，实体用于封装企业范围的业务规则。 用例（Use Cases），交互器，用例是特定于应用的业务逻辑。 接口适配器（Interface Adapters），接口适配器层的主要作用是转换数据。 框架和驱动（Frameworks and Drivers），最外层由各种框架和工具组成，比如 Web 框架、数据库访问工具等。 这个介绍可能有些简单，让我更详细的解释： 实体（Entities），实体用于封装企业范围的业务规则。实体可以是拥有方法的对象，也可以是数据结构和函数的集合。如果没有企业，只是单个应用，那么实体就是应用里的业务对象。这些对象封装了最通用和高层的业务规则，极少会受到外部变化的影响。任何操作层面的改动都不会影响到这一层。 用例（Use Cases），用例是特定于应用的业务逻辑，一般用来完成用户的某个操作。用例协调数据流向或者流出实体层，并且在此过程中通过执行实体的业务规则来达成用例的目标。用例层的改动不会影响到内部的实体层，同时也不会受外层的改动影响，比如数据库、UI 和框架的变动。只有而且应当应用的操作发生变化的时候，用例层的代码才随之修改。 接口适配器（Interface Adapters）。接口适配器层的主要作用是转换数据，数据从最适合内部用例层和实体层的结构转换成适合外层（比如数据持久化框架）的结构。反之，来自于外部服务的数据也会在这层转换为内层需要的结构。 框架和驱动（Frameworks and Drivers）。最外层由各种框架和工具组成，比如 Web 框架、数据库访问工具等。通常在这层不需要写太多代码，大多是一些用来跟内层通信的胶水代码。这一层包含了所有实现细节，把实现细节锁定在这一层能够减少它们的改动对整个系统造成的伤害。 概念就这么扯到这里吧，然后看看相应的实现。 Clean Architecture 数据流 上图中的右侧部分表示的是相应的数据流，数据从 Controller 流出，经过 Use Case（用例）的输入端口，然后通过 Use Case 本身，最后通过 Use Case 输出端口返回给 Presenter。 让我们来看一个较为直观的例子： Clean Architecture 数据流 上图（来源，见参考文章）是一个 Android 应用的数据流示意图。 对于只懂得前端的开发大致说明一下，Android 的 View 和 Presenter 的关系。在前端应用中，我们假设以使用 Component 来表示一个组件，如 Angular 中的 HomepageComponent。而这个 HomepageComponent 中，它必然充满了一些无关于页面显示的逻辑，比如从后端获取显示数据之类的。 而 Java 的写法本身是比较臃肿的，所以在 Android 的 Activity 中就会充斥大量的代码。为此，Android 的开发人员们，采用了 MVP 架构，通过 Presenter 来将与显示无关的行为，从 View 中抽离出来。 优缺点 优点： 框架无关性 可被测试 UI 无关性 数据库无关性 外部机构无关性 定义了特定功能的代码放在何处 可以在多个项目共享业务逻辑 相应的它还有大量的缺点： 过于复杂。数据需要经过多层处理，Repository 转为 Entity，经过 Usecase 转为 Model，再交由 Presenter 处理，最后交由 View 显示。一个示例如下所示（源自Android-Clean-Boilerplate）：MainActivity-&gt;MainPresenter-&gt;WelcomingInteractor-&gt; WelcomeMessageRepository-&gt;WelcomingInteractor-&gt;MainPresenter-&gt;MainActivity 过度设计。事到如今，我们做了大量的设计，对于一个简单的工程来说，这样的模式可能是过度式的设计。 大量的模板式代码。Usecase、Model 等一系列重复的模板式代码。 陡峭的学习曲线。不用我多说，看这篇文章的长度。 所以，在采用之前，请再次考虑一下，你的应用是否足够的复杂：业务上的复杂度，代码上的复杂度等等。 前端 Clean 架构 说了，这么多，让我们来结合一下前端，设计一下新的前端架构。 客户端 Clean 架构 + MVP 与后端架构相比， Android 的 MVP 架构 + Clean 架构更与前端相似，为此我们再说看看它们结合的一个示例： Android Clean Architecture 与上一个数据流的相比，这个数据流图更容易落地。其与传统的 MVP（Model-View-Presenter）架构相比： MVP 基于 Clean Architecture 方案时，则多了一个领域层（图中的 Domain Layer，即业务层），在这一层领域层里，放置的是系统相关的用例（Usecase），而用例所包含的则是相应的业务逻辑。 Clean Architecture + MVP + 组件化 上述的 MVP + Clean Architecture 的架构方式，对于前端应用的架构设计来说，也是相当合适的。稍有不同的是，我们是否有必要将一个组件分为 Presenter + View。以我的角度来说，对于大部分前端应用来说，并没有这么复杂的情况，因为前端有组件化架构。 所以，最后对于我们的前端应用而言，架构如下图所示： Clean MVP 组件化 这里，只是对于 Presenter 进行更细一步的细化，以真实的模式取代了 MVP 中的 Presenter。 实践 值得注意的是，我们在这里违反了依赖倒置原则。原因是，这里的注入带来了一定的前端复杂度，而这个注入并非是必须的——对于大部分的前端应用而言，只会有单一的数据源，那便是后端数据。 单体式分层架构 在我起初设计的版本里，参照的 Clean Angular 工程（Angular Clean Architecture）里，其采用的是单体式的 Clean Architecture 分层结构： ├──&nbsp;core│&nbsp;&nbsp;&nbsp;├──&nbsp;base&nbsp;//&nbsp;基础函数，如&nbsp;mapper&nbsp;等│&nbsp;&nbsp;&nbsp;├──&nbsp;domain&nbsp;//&nbsp;业务实体│&nbsp;&nbsp;&nbsp;├──&nbsp;repositories&nbsp;//&nbsp;repositories&nbsp;模型│&nbsp;&nbsp;&nbsp;└──&nbsp;usecases&nbsp;//&nbsp;业务逻辑├──&nbsp;data&nbsp;//&nbsp;数据层│&nbsp;&nbsp;&nbsp;└──&nbsp;repository&nbsp;//&nbsp;数据源实现└──&nbsp;presentation&nbsp;//&nbsp;表现层 这个实现还是相当不错的，就是过于重视理论——抽象相当的繁琐，导致有点不接地气。我的意思说，没有多少前端人员，愿意按照这个模式来写。 微服务式分层架构 考虑到 usecase 的业务相关性，及会存在大师的 usecase，我便将 usecase 移到了 data 目录，也存在一定的不合理性。后来，我的同事泽杭，一个有丰富的 React 经验前端开发，他提出了 Redux 中的相关结构。最后，我们探讨出了最后的目录结构： ├──&nbsp;core&nbsp;//&nbsp;核心代码，包含基本服务和基础代码├──&nbsp;domain&nbsp;//&nbsp;业务层代码，包含每个业务的单独&nbsp;Clean&nbsp;架构内容│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant&nbsp;//&nbsp;某一具体的业务├──&nbsp;features&nbsp;//&nbsp;公共页面组件├──&nbsp;protected&nbsp;//&nbsp;有权限的页面├──&nbsp;public&nbsp;//&nbsp;公共页面└──&nbsp;shared&nbsp;//&nbsp;共享目录 对应的 elephant 是某一个具体的业务，在该目录下包含了一个完整的 Clean Architecture，相应的目录和文件如下所示： ├──&nbsp;model│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant.model.ts&nbsp;//&nbsp;核心业务模型├──&nbsp;repository│&nbsp;&nbsp;&nbsp;├──&nbsp;elephant-web-entity.ts&nbsp;//&nbsp;数据实体，简单的数据模型，用来表示核心的业务逻辑│&nbsp;&nbsp;&nbsp;├──&nbsp;elephant-web-repository-mapper.ts&nbsp;//&nbsp;映射层，用于核心实体层映射，或映射到核心实体层。│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant-web.repository.ts&nbsp;//&nbsp;Repository，用于读取和存储数据。└──&nbsp;usecases&nbsp;└──&nbsp;get-elephant-by-id-usecase.usecase.ts&nbsp;//&nbsp;用例，构建在核心实体之 之上，并实现应用程序的整个业务逻辑。 我一直思考这样的模式是否有问题，直到我看到我司大佬 Martin Folwer 写下的一篇文章《PresentationDomainDataLayering》，终于有人背锅了。文章中提到了这图： 分层 这个分层类似于微服务的概念，在我所熟悉的 Django 框架中也是这样的结构。也因此从理论和实践上不看，并不存在任何的问题。 它不是一颗银弹。使用 MVP 并不妨碍开发人员将 UI 逻辑放在 View 中，使用 Clean Architecture 不会阻止业务逻辑泄漏到表示层。 作者简介：黄峰达（Phodal），ThoughtWorks Senior Consultant，CSDN 博客专家。长期活跃于 GitHub、CSDN，专注于物联网和前端领域。出版著作《自己动手设计物联网》，以及《Growth：全栈增长工程师指南》等六本电子书，并译有《物联网实战指南》。 本文经授权转自作者公众号「Phodal」。 相关资料：《整洁架构之道》 源码：https://github.com/phodal/clean-angular 【END】 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞&nbsp;京东 60 天哗变！CTO 成优化第一人 | 畅言 ☞&nbsp;硬核黑科技告诉你，漫威十年到底有多少个角色？ ☞&nbsp;全方位测评Hive、SparkSQL、Presto 等七个大数据查询引擎，最快的竟是……| 程序员硬核测评 ☞厉害了！超越 Google，16 岁少女发明眼疾诊断 AI 模型！ ☞&nbsp;和 996 对着干的百亿巨头：不打卡，不设 KPI，福利好到爆，却称霸行业 20 年！ ☞&nbsp;回报率29%! 大神用情感分析创建一个比特币交易算法, 原来交易玩的是心理战 ☞&nbsp;开发者如何写好技术简历？ ☞&nbsp;写代码这条路，能走多远？阿里算法专家告诉你 ☞ 她说：为啥程序员都特想要机械键盘？这答案我服！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 你点的每个“在看”，我都认真当成了喜欢" />
<meta property="og:description" content="在前端开发过程中，你有没有遇到过由于代码交互太多太重时，想改动一行代码“牵一发而动全身”；使用框架很爽，可框架绑定应用却很麻烦？那么如何解决呢？ 你需要“前端整洁”。 作者 |&nbsp;Phodal 责编 | 伍杏玲 前端的恶梦 在我最近的一个项目里，我使用了 Angular 和混合应用技术编写了一个实时聊天应用。为了方便这个应用直接修改，无缝地嵌入到其它应用程序中。我尽量减少了 Component 和 Service 的数量。 然而，由于交互复杂 Component 的数量也不能减少。随后，当我们完成了这个项目的时候，主要的组件代码差不多有 1000 行。这差不多是一个复杂的应用的代码数。在我试图多次去重构代码时，我发现这并不是一件容易的事：太多的交互。 导致了 UI 层的代码，很难被抽取出去。我还能做的事情是将一些业务逻辑抽取出来，只是怎么去抽取了？这成了我的一个疑惑。 MVP 嘛，逻辑不都是放到 Presenter 里，还有其它的招吗？ AVR is Evil Angular、Vue 和 React 都是一些不错的框架，但是它们都是恶魔，因为我们绑定了框架。我们可以很快地从一个 React 的框架，迁移应用到其它类 React 框架，诸如 Preact；我们可以从一个类似于 Vue 的框架，迁移应用到其它类 Vue 的应用。但是我们很难从 React 迁移到 Angular，又或者是 Vue 迁移到 Angular。 万一有一天某个框架的核心维护人员健康状况不好，那么我们可能就得重写整个应用。这对于一个技术人员/Tech Lead/项目经验/业务人员来说，这种情况是不可接受的。 所以，为了应对这些框架带来的问题，我们选择 Web Components 技术，又或者是微前端技术，从架构上切开我们的业务。但是它们并不是银弹，它们反而是一个累赘，限定了高版本的浏览器，制定了更多的规范。 与此同时，不论是微前端技术还是 Web Components，它们都没有解决一个问题：框架绑定应用。 框架绑定应用，就是一种灾害。没有人希望哪一天因为 Java 需要高额的付费，而导致我们选择重写整个应用。 组件化及 Presenter 过重 应对页面逻辑过于重的问题，我们选择了组件化。将一个页面拆分成一系列的业务组件，再进一步地对这些业务组件进行地次细分，形成更小的业务组件，最后它们都依赖于组件库。 可是呢，细化存在一个问题是：更难以摆脱的框架绑定。与此同时，我们大量的业务逻辑仍然放置在 Presenter 里。我们的 Presenter 充满了大量的业务逻辑和非业务逻辑： 页面展示相应的逻辑。诸如点击事件、提交表单等等。 状态管理。诸如是否展示，用户登录状态等等。 业务逻辑。诸如某个字符串，要用怎样的形式展示。 数据持续化。哪些数据需要存储在 LocalStorage，哪些数据存储在 IndexedDB 里？ 为了应对 Presenter 过重的问题，我们使用了 Service 来处理某一块具体的业务，我们使用了 Utils、Helper 来处理一些公共的逻辑。哪怕是如此，我们使用 A 框架编写的业务逻辑，到了 B 框架中无法复用。 直到我最近重新接触了 Clean Architectrue，我发现 Presenter 还是可以进一步拆分的。 整洁的前端架构 Clean Architecture 是由 Robert C. Martin 在 2012 年提出的。最早，我只看到在 Android 应用上的使用，一来 Android 开发使用的是 Java，二来 Android 应用有很重的 View 层。 与此同时，在 7 年的时间里，由于前后端的分离，UI 层已经从后端的部分消失了。当然了，你也可以说 JSON 也是一种 View（至少它是可见的）。尽管，还存在一定数量的后端渲染 Web 应用，但是新的应用几乎不采用这样的模式。 但是，在 9012 年的今天，前端应用走向了 MV* 的架构方案，也有了一层很重的 View 层。类似于过去的后端应用，或者后端应用。相似的架构，也可以在前端项目中使用。 整洁架构 Robert C. Martin 总结了六边形架构（即端口与适配器架构）：DCI （Data-Context-Interactions，数据-场景-交互）架构、BCI（Boundary Control Entity，Boundary Control Entity）架构等多种架构，归纳出了这些架构的基本特点： 框架无关性。系统不依赖于框架中的某个函数，框架只是一个工具，系统不能适应于框架。 可被测试。业务逻辑脱离于 UI、数据库等外部元素进行测试。 UI&nbsp;无关性。不需要修改系统的其它部分，就可以变更 UI，诸如由 Web 界面替换成 CLI。 数据库无关性。业务逻辑与数据库之间需要进行解耦，我们可以随意切换 LocalStroage、IndexedDB、Web SQL。 外部机构（agency）无关性。系统的业务逻辑，不需要知道其它外部接口，诸如安全、调度、代理等。 如你所见，作为一个普通（不分前后端）的开发人员，我们关注于业务逻辑的抽离，让业务逻辑独立于框架。 而在前端的实化，则是让前端的业务逻辑，可以独立于框架，只让 UI（即表现层）与框架绑定。一旦，我们更换框架的时候，只需要替换这部分的业务逻辑即可。 为此，基于这个概念 Robert C. Martin 绘制出了整洁架构的架构图： Clean Architecture 如图所示，Clean Architecture 一共分为四个环，四个层级。环与环之间，存在一个依赖关系原则：源代码中的依赖关系，必须只指向同心圆的内层，即由低层机制指向高级策略。其类似于 SOLID 中的依赖倒置原则： 高层模块不应该依赖低层模块，两者都应该依赖其抽象。 抽象不应该依赖细节，细节应该依赖抽象。 与此同时，四个环都存在各自核心的概念： 实体（Entities），又称领域对象或业务对象，实体用于封装企业范围的业务规则。 用例（Use Cases），交互器，用例是特定于应用的业务逻辑。 接口适配器（Interface Adapters），接口适配器层的主要作用是转换数据。 框架和驱动（Frameworks and Drivers），最外层由各种框架和工具组成，比如 Web 框架、数据库访问工具等。 这个介绍可能有些简单，让我更详细的解释： 实体（Entities），实体用于封装企业范围的业务规则。实体可以是拥有方法的对象，也可以是数据结构和函数的集合。如果没有企业，只是单个应用，那么实体就是应用里的业务对象。这些对象封装了最通用和高层的业务规则，极少会受到外部变化的影响。任何操作层面的改动都不会影响到这一层。 用例（Use Cases），用例是特定于应用的业务逻辑，一般用来完成用户的某个操作。用例协调数据流向或者流出实体层，并且在此过程中通过执行实体的业务规则来达成用例的目标。用例层的改动不会影响到内部的实体层，同时也不会受外层的改动影响，比如数据库、UI 和框架的变动。只有而且应当应用的操作发生变化的时候，用例层的代码才随之修改。 接口适配器（Interface Adapters）。接口适配器层的主要作用是转换数据，数据从最适合内部用例层和实体层的结构转换成适合外层（比如数据持久化框架）的结构。反之，来自于外部服务的数据也会在这层转换为内层需要的结构。 框架和驱动（Frameworks and Drivers）。最外层由各种框架和工具组成，比如 Web 框架、数据库访问工具等。通常在这层不需要写太多代码，大多是一些用来跟内层通信的胶水代码。这一层包含了所有实现细节，把实现细节锁定在这一层能够减少它们的改动对整个系统造成的伤害。 概念就这么扯到这里吧，然后看看相应的实现。 Clean Architecture 数据流 上图中的右侧部分表示的是相应的数据流，数据从 Controller 流出，经过 Use Case（用例）的输入端口，然后通过 Use Case 本身，最后通过 Use Case 输出端口返回给 Presenter。 让我们来看一个较为直观的例子： Clean Architecture 数据流 上图（来源，见参考文章）是一个 Android 应用的数据流示意图。 对于只懂得前端的开发大致说明一下，Android 的 View 和 Presenter 的关系。在前端应用中，我们假设以使用 Component 来表示一个组件，如 Angular 中的 HomepageComponent。而这个 HomepageComponent 中，它必然充满了一些无关于页面显示的逻辑，比如从后端获取显示数据之类的。 而 Java 的写法本身是比较臃肿的，所以在 Android 的 Activity 中就会充斥大量的代码。为此，Android 的开发人员们，采用了 MVP 架构，通过 Presenter 来将与显示无关的行为，从 View 中抽离出来。 优缺点 优点： 框架无关性 可被测试 UI 无关性 数据库无关性 外部机构无关性 定义了特定功能的代码放在何处 可以在多个项目共享业务逻辑 相应的它还有大量的缺点： 过于复杂。数据需要经过多层处理，Repository 转为 Entity，经过 Usecase 转为 Model，再交由 Presenter 处理，最后交由 View 显示。一个示例如下所示（源自Android-Clean-Boilerplate）：MainActivity-&gt;MainPresenter-&gt;WelcomingInteractor-&gt; WelcomeMessageRepository-&gt;WelcomingInteractor-&gt;MainPresenter-&gt;MainActivity 过度设计。事到如今，我们做了大量的设计，对于一个简单的工程来说，这样的模式可能是过度式的设计。 大量的模板式代码。Usecase、Model 等一系列重复的模板式代码。 陡峭的学习曲线。不用我多说，看这篇文章的长度。 所以，在采用之前，请再次考虑一下，你的应用是否足够的复杂：业务上的复杂度，代码上的复杂度等等。 前端 Clean 架构 说了，这么多，让我们来结合一下前端，设计一下新的前端架构。 客户端 Clean 架构 + MVP 与后端架构相比， Android 的 MVP 架构 + Clean 架构更与前端相似，为此我们再说看看它们结合的一个示例： Android Clean Architecture 与上一个数据流的相比，这个数据流图更容易落地。其与传统的 MVP（Model-View-Presenter）架构相比： MVP 基于 Clean Architecture 方案时，则多了一个领域层（图中的 Domain Layer，即业务层），在这一层领域层里，放置的是系统相关的用例（Usecase），而用例所包含的则是相应的业务逻辑。 Clean Architecture + MVP + 组件化 上述的 MVP + Clean Architecture 的架构方式，对于前端应用的架构设计来说，也是相当合适的。稍有不同的是，我们是否有必要将一个组件分为 Presenter + View。以我的角度来说，对于大部分前端应用来说，并没有这么复杂的情况，因为前端有组件化架构。 所以，最后对于我们的前端应用而言，架构如下图所示： Clean MVP 组件化 这里，只是对于 Presenter 进行更细一步的细化，以真实的模式取代了 MVP 中的 Presenter。 实践 值得注意的是，我们在这里违反了依赖倒置原则。原因是，这里的注入带来了一定的前端复杂度，而这个注入并非是必须的——对于大部分的前端应用而言，只会有单一的数据源，那便是后端数据。 单体式分层架构 在我起初设计的版本里，参照的 Clean Angular 工程（Angular Clean Architecture）里，其采用的是单体式的 Clean Architecture 分层结构： ├──&nbsp;core│&nbsp;&nbsp;&nbsp;├──&nbsp;base&nbsp;//&nbsp;基础函数，如&nbsp;mapper&nbsp;等│&nbsp;&nbsp;&nbsp;├──&nbsp;domain&nbsp;//&nbsp;业务实体│&nbsp;&nbsp;&nbsp;├──&nbsp;repositories&nbsp;//&nbsp;repositories&nbsp;模型│&nbsp;&nbsp;&nbsp;└──&nbsp;usecases&nbsp;//&nbsp;业务逻辑├──&nbsp;data&nbsp;//&nbsp;数据层│&nbsp;&nbsp;&nbsp;└──&nbsp;repository&nbsp;//&nbsp;数据源实现└──&nbsp;presentation&nbsp;//&nbsp;表现层 这个实现还是相当不错的，就是过于重视理论——抽象相当的繁琐，导致有点不接地气。我的意思说，没有多少前端人员，愿意按照这个模式来写。 微服务式分层架构 考虑到 usecase 的业务相关性，及会存在大师的 usecase，我便将 usecase 移到了 data 目录，也存在一定的不合理性。后来，我的同事泽杭，一个有丰富的 React 经验前端开发，他提出了 Redux 中的相关结构。最后，我们探讨出了最后的目录结构： ├──&nbsp;core&nbsp;//&nbsp;核心代码，包含基本服务和基础代码├──&nbsp;domain&nbsp;//&nbsp;业务层代码，包含每个业务的单独&nbsp;Clean&nbsp;架构内容│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant&nbsp;//&nbsp;某一具体的业务├──&nbsp;features&nbsp;//&nbsp;公共页面组件├──&nbsp;protected&nbsp;//&nbsp;有权限的页面├──&nbsp;public&nbsp;//&nbsp;公共页面└──&nbsp;shared&nbsp;//&nbsp;共享目录 对应的 elephant 是某一个具体的业务，在该目录下包含了一个完整的 Clean Architecture，相应的目录和文件如下所示： ├──&nbsp;model│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant.model.ts&nbsp;//&nbsp;核心业务模型├──&nbsp;repository│&nbsp;&nbsp;&nbsp;├──&nbsp;elephant-web-entity.ts&nbsp;//&nbsp;数据实体，简单的数据模型，用来表示核心的业务逻辑│&nbsp;&nbsp;&nbsp;├──&nbsp;elephant-web-repository-mapper.ts&nbsp;//&nbsp;映射层，用于核心实体层映射，或映射到核心实体层。│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant-web.repository.ts&nbsp;//&nbsp;Repository，用于读取和存储数据。└──&nbsp;usecases&nbsp;└──&nbsp;get-elephant-by-id-usecase.usecase.ts&nbsp;//&nbsp;用例，构建在核心实体之 之上，并实现应用程序的整个业务逻辑。 我一直思考这样的模式是否有问题，直到我看到我司大佬 Martin Folwer 写下的一篇文章《PresentationDomainDataLayering》，终于有人背锅了。文章中提到了这图： 分层 这个分层类似于微服务的概念，在我所熟悉的 Django 框架中也是这样的结构。也因此从理论和实践上不看，并不存在任何的问题。 它不是一颗银弹。使用 MVP 并不妨碍开发人员将 UI 逻辑放在 View 中，使用 Clean Architecture 不会阻止业务逻辑泄漏到表示层。 作者简介：黄峰达（Phodal），ThoughtWorks Senior Consultant，CSDN 博客专家。长期活跃于 GitHub、CSDN，专注于物联网和前端领域。出版著作《自己动手设计物联网》，以及《Growth：全栈增长工程师指南》等六本电子书，并译有《物联网实战指南》。 本文经授权转自作者公众号「Phodal」。 相关资料：《整洁架构之道》 源码：https://github.com/phodal/clean-angular 【END】 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞&nbsp;京东 60 天哗变！CTO 成优化第一人 | 畅言 ☞&nbsp;硬核黑科技告诉你，漫威十年到底有多少个角色？ ☞&nbsp;全方位测评Hive、SparkSQL、Presto 等七个大数据查询引擎，最快的竟是……| 程序员硬核测评 ☞厉害了！超越 Google，16 岁少女发明眼疾诊断 AI 模型！ ☞&nbsp;和 996 对着干的百亿巨头：不打卡，不设 KPI，福利好到爆，却称霸行业 20 年！ ☞&nbsp;回报率29%! 大神用情感分析创建一个比特币交易算法, 原来交易玩的是心理战 ☞&nbsp;开发者如何写好技术简历？ ☞&nbsp;写代码这条路，能走多远？阿里算法专家告诉你 ☞ 她说：为啥程序员都特想要机械键盘？这答案我服！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 你点的每个“在看”，我都认真当成了喜欢" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"在前端开发过程中，你有没有遇到过由于代码交互太多太重时，想改动一行代码“牵一发而动全身”；使用框架很爽，可框架绑定应用却很麻烦？那么如何解决呢？ 你需要“前端整洁”。 作者 |&nbsp;Phodal 责编 | 伍杏玲 前端的恶梦 在我最近的一个项目里，我使用了 Angular 和混合应用技术编写了一个实时聊天应用。为了方便这个应用直接修改，无缝地嵌入到其它应用程序中。我尽量减少了 Component 和 Service 的数量。 然而，由于交互复杂 Component 的数量也不能减少。随后，当我们完成了这个项目的时候，主要的组件代码差不多有 1000 行。这差不多是一个复杂的应用的代码数。在我试图多次去重构代码时，我发现这并不是一件容易的事：太多的交互。 导致了 UI 层的代码，很难被抽取出去。我还能做的事情是将一些业务逻辑抽取出来，只是怎么去抽取了？这成了我的一个疑惑。 MVP 嘛，逻辑不都是放到 Presenter 里，还有其它的招吗？ AVR is Evil Angular、Vue 和 React 都是一些不错的框架，但是它们都是恶魔，因为我们绑定了框架。我们可以很快地从一个 React 的框架，迁移应用到其它类 React 框架，诸如 Preact；我们可以从一个类似于 Vue 的框架，迁移应用到其它类 Vue 的应用。但是我们很难从 React 迁移到 Angular，又或者是 Vue 迁移到 Angular。 万一有一天某个框架的核心维护人员健康状况不好，那么我们可能就得重写整个应用。这对于一个技术人员/Tech Lead/项目经验/业务人员来说，这种情况是不可接受的。 所以，为了应对这些框架带来的问题，我们选择 Web Components 技术，又或者是微前端技术，从架构上切开我们的业务。但是它们并不是银弹，它们反而是一个累赘，限定了高版本的浏览器，制定了更多的规范。 与此同时，不论是微前端技术还是 Web Components，它们都没有解决一个问题：框架绑定应用。 框架绑定应用，就是一种灾害。没有人希望哪一天因为 Java 需要高额的付费，而导致我们选择重写整个应用。 组件化及 Presenter 过重 应对页面逻辑过于重的问题，我们选择了组件化。将一个页面拆分成一系列的业务组件，再进一步地对这些业务组件进行地次细分，形成更小的业务组件，最后它们都依赖于组件库。 可是呢，细化存在一个问题是：更难以摆脱的框架绑定。与此同时，我们大量的业务逻辑仍然放置在 Presenter 里。我们的 Presenter 充满了大量的业务逻辑和非业务逻辑： 页面展示相应的逻辑。诸如点击事件、提交表单等等。 状态管理。诸如是否展示，用户登录状态等等。 业务逻辑。诸如某个字符串，要用怎样的形式展示。 数据持续化。哪些数据需要存储在 LocalStorage，哪些数据存储在 IndexedDB 里？ 为了应对 Presenter 过重的问题，我们使用了 Service 来处理某一块具体的业务，我们使用了 Utils、Helper 来处理一些公共的逻辑。哪怕是如此，我们使用 A 框架编写的业务逻辑，到了 B 框架中无法复用。 直到我最近重新接触了 Clean Architectrue，我发现 Presenter 还是可以进一步拆分的。 整洁的前端架构 Clean Architecture 是由 Robert C. Martin 在 2012 年提出的。最早，我只看到在 Android 应用上的使用，一来 Android 开发使用的是 Java，二来 Android 应用有很重的 View 层。 与此同时，在 7 年的时间里，由于前后端的分离，UI 层已经从后端的部分消失了。当然了，你也可以说 JSON 也是一种 View（至少它是可见的）。尽管，还存在一定数量的后端渲染 Web 应用，但是新的应用几乎不采用这样的模式。 但是，在 9012 年的今天，前端应用走向了 MV* 的架构方案，也有了一层很重的 View 层。类似于过去的后端应用，或者后端应用。相似的架构，也可以在前端项目中使用。 整洁架构 Robert C. Martin 总结了六边形架构（即端口与适配器架构）：DCI （Data-Context-Interactions，数据-场景-交互）架构、BCI（Boundary Control Entity，Boundary Control Entity）架构等多种架构，归纳出了这些架构的基本特点： 框架无关性。系统不依赖于框架中的某个函数，框架只是一个工具，系统不能适应于框架。 可被测试。业务逻辑脱离于 UI、数据库等外部元素进行测试。 UI&nbsp;无关性。不需要修改系统的其它部分，就可以变更 UI，诸如由 Web 界面替换成 CLI。 数据库无关性。业务逻辑与数据库之间需要进行解耦，我们可以随意切换 LocalStroage、IndexedDB、Web SQL。 外部机构（agency）无关性。系统的业务逻辑，不需要知道其它外部接口，诸如安全、调度、代理等。 如你所见，作为一个普通（不分前后端）的开发人员，我们关注于业务逻辑的抽离，让业务逻辑独立于框架。 而在前端的实化，则是让前端的业务逻辑，可以独立于框架，只让 UI（即表现层）与框架绑定。一旦，我们更换框架的时候，只需要替换这部分的业务逻辑即可。 为此，基于这个概念 Robert C. Martin 绘制出了整洁架构的架构图： Clean Architecture 如图所示，Clean Architecture 一共分为四个环，四个层级。环与环之间，存在一个依赖关系原则：源代码中的依赖关系，必须只指向同心圆的内层，即由低层机制指向高级策略。其类似于 SOLID 中的依赖倒置原则： 高层模块不应该依赖低层模块，两者都应该依赖其抽象。 抽象不应该依赖细节，细节应该依赖抽象。 与此同时，四个环都存在各自核心的概念： 实体（Entities），又称领域对象或业务对象，实体用于封装企业范围的业务规则。 用例（Use Cases），交互器，用例是特定于应用的业务逻辑。 接口适配器（Interface Adapters），接口适配器层的主要作用是转换数据。 框架和驱动（Frameworks and Drivers），最外层由各种框架和工具组成，比如 Web 框架、数据库访问工具等。 这个介绍可能有些简单，让我更详细的解释： 实体（Entities），实体用于封装企业范围的业务规则。实体可以是拥有方法的对象，也可以是数据结构和函数的集合。如果没有企业，只是单个应用，那么实体就是应用里的业务对象。这些对象封装了最通用和高层的业务规则，极少会受到外部变化的影响。任何操作层面的改动都不会影响到这一层。 用例（Use Cases），用例是特定于应用的业务逻辑，一般用来完成用户的某个操作。用例协调数据流向或者流出实体层，并且在此过程中通过执行实体的业务规则来达成用例的目标。用例层的改动不会影响到内部的实体层，同时也不会受外层的改动影响，比如数据库、UI 和框架的变动。只有而且应当应用的操作发生变化的时候，用例层的代码才随之修改。 接口适配器（Interface Adapters）。接口适配器层的主要作用是转换数据，数据从最适合内部用例层和实体层的结构转换成适合外层（比如数据持久化框架）的结构。反之，来自于外部服务的数据也会在这层转换为内层需要的结构。 框架和驱动（Frameworks and Drivers）。最外层由各种框架和工具组成，比如 Web 框架、数据库访问工具等。通常在这层不需要写太多代码，大多是一些用来跟内层通信的胶水代码。这一层包含了所有实现细节，把实现细节锁定在这一层能够减少它们的改动对整个系统造成的伤害。 概念就这么扯到这里吧，然后看看相应的实现。 Clean Architecture 数据流 上图中的右侧部分表示的是相应的数据流，数据从 Controller 流出，经过 Use Case（用例）的输入端口，然后通过 Use Case 本身，最后通过 Use Case 输出端口返回给 Presenter。 让我们来看一个较为直观的例子： Clean Architecture 数据流 上图（来源，见参考文章）是一个 Android 应用的数据流示意图。 对于只懂得前端的开发大致说明一下，Android 的 View 和 Presenter 的关系。在前端应用中，我们假设以使用 Component 来表示一个组件，如 Angular 中的 HomepageComponent。而这个 HomepageComponent 中，它必然充满了一些无关于页面显示的逻辑，比如从后端获取显示数据之类的。 而 Java 的写法本身是比较臃肿的，所以在 Android 的 Activity 中就会充斥大量的代码。为此，Android 的开发人员们，采用了 MVP 架构，通过 Presenter 来将与显示无关的行为，从 View 中抽离出来。 优缺点 优点： 框架无关性 可被测试 UI 无关性 数据库无关性 外部机构无关性 定义了特定功能的代码放在何处 可以在多个项目共享业务逻辑 相应的它还有大量的缺点： 过于复杂。数据需要经过多层处理，Repository 转为 Entity，经过 Usecase 转为 Model，再交由 Presenter 处理，最后交由 View 显示。一个示例如下所示（源自Android-Clean-Boilerplate）：MainActivity-&gt;MainPresenter-&gt;WelcomingInteractor-&gt; WelcomeMessageRepository-&gt;WelcomingInteractor-&gt;MainPresenter-&gt;MainActivity 过度设计。事到如今，我们做了大量的设计，对于一个简单的工程来说，这样的模式可能是过度式的设计。 大量的模板式代码。Usecase、Model 等一系列重复的模板式代码。 陡峭的学习曲线。不用我多说，看这篇文章的长度。 所以，在采用之前，请再次考虑一下，你的应用是否足够的复杂：业务上的复杂度，代码上的复杂度等等。 前端 Clean 架构 说了，这么多，让我们来结合一下前端，设计一下新的前端架构。 客户端 Clean 架构 + MVP 与后端架构相比， Android 的 MVP 架构 + Clean 架构更与前端相似，为此我们再说看看它们结合的一个示例： Android Clean Architecture 与上一个数据流的相比，这个数据流图更容易落地。其与传统的 MVP（Model-View-Presenter）架构相比： MVP 基于 Clean Architecture 方案时，则多了一个领域层（图中的 Domain Layer，即业务层），在这一层领域层里，放置的是系统相关的用例（Usecase），而用例所包含的则是相应的业务逻辑。 Clean Architecture + MVP + 组件化 上述的 MVP + Clean Architecture 的架构方式，对于前端应用的架构设计来说，也是相当合适的。稍有不同的是，我们是否有必要将一个组件分为 Presenter + View。以我的角度来说，对于大部分前端应用来说，并没有这么复杂的情况，因为前端有组件化架构。 所以，最后对于我们的前端应用而言，架构如下图所示： Clean MVP 组件化 这里，只是对于 Presenter 进行更细一步的细化，以真实的模式取代了 MVP 中的 Presenter。 实践 值得注意的是，我们在这里违反了依赖倒置原则。原因是，这里的注入带来了一定的前端复杂度，而这个注入并非是必须的——对于大部分的前端应用而言，只会有单一的数据源，那便是后端数据。 单体式分层架构 在我起初设计的版本里，参照的 Clean Angular 工程（Angular Clean Architecture）里，其采用的是单体式的 Clean Architecture 分层结构： ├──&nbsp;core│&nbsp;&nbsp;&nbsp;├──&nbsp;base&nbsp;//&nbsp;基础函数，如&nbsp;mapper&nbsp;等│&nbsp;&nbsp;&nbsp;├──&nbsp;domain&nbsp;//&nbsp;业务实体│&nbsp;&nbsp;&nbsp;├──&nbsp;repositories&nbsp;//&nbsp;repositories&nbsp;模型│&nbsp;&nbsp;&nbsp;└──&nbsp;usecases&nbsp;//&nbsp;业务逻辑├──&nbsp;data&nbsp;//&nbsp;数据层│&nbsp;&nbsp;&nbsp;└──&nbsp;repository&nbsp;//&nbsp;数据源实现└──&nbsp;presentation&nbsp;//&nbsp;表现层 这个实现还是相当不错的，就是过于重视理论——抽象相当的繁琐，导致有点不接地气。我的意思说，没有多少前端人员，愿意按照这个模式来写。 微服务式分层架构 考虑到 usecase 的业务相关性，及会存在大师的 usecase，我便将 usecase 移到了 data 目录，也存在一定的不合理性。后来，我的同事泽杭，一个有丰富的 React 经验前端开发，他提出了 Redux 中的相关结构。最后，我们探讨出了最后的目录结构： ├──&nbsp;core&nbsp;//&nbsp;核心代码，包含基本服务和基础代码├──&nbsp;domain&nbsp;//&nbsp;业务层代码，包含每个业务的单独&nbsp;Clean&nbsp;架构内容│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant&nbsp;//&nbsp;某一具体的业务├──&nbsp;features&nbsp;//&nbsp;公共页面组件├──&nbsp;protected&nbsp;//&nbsp;有权限的页面├──&nbsp;public&nbsp;//&nbsp;公共页面└──&nbsp;shared&nbsp;//&nbsp;共享目录 对应的 elephant 是某一个具体的业务，在该目录下包含了一个完整的 Clean Architecture，相应的目录和文件如下所示： ├──&nbsp;model│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant.model.ts&nbsp;//&nbsp;核心业务模型├──&nbsp;repository│&nbsp;&nbsp;&nbsp;├──&nbsp;elephant-web-entity.ts&nbsp;//&nbsp;数据实体，简单的数据模型，用来表示核心的业务逻辑│&nbsp;&nbsp;&nbsp;├──&nbsp;elephant-web-repository-mapper.ts&nbsp;//&nbsp;映射层，用于核心实体层映射，或映射到核心实体层。│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant-web.repository.ts&nbsp;//&nbsp;Repository，用于读取和存储数据。└──&nbsp;usecases&nbsp;└──&nbsp;get-elephant-by-id-usecase.usecase.ts&nbsp;//&nbsp;用例，构建在核心实体之 之上，并实现应用程序的整个业务逻辑。 我一直思考这样的模式是否有问题，直到我看到我司大佬 Martin Folwer 写下的一篇文章《PresentationDomainDataLayering》，终于有人背锅了。文章中提到了这图： 分层 这个分层类似于微服务的概念，在我所熟悉的 Django 框架中也是这样的结构。也因此从理论和实践上不看，并不存在任何的问题。 它不是一颗银弹。使用 MVP 并不妨碍开发人员将 UI 逻辑放在 View 中，使用 Clean Architecture 不会阻止业务逻辑泄漏到表示层。 作者简介：黄峰达（Phodal），ThoughtWorks Senior Consultant，CSDN 博客专家。长期活跃于 GitHub、CSDN，专注于物联网和前端领域。出版著作《自己动手设计物联网》，以及《Growth：全栈增长工程师指南》等六本电子书，并译有《物联网实战指南》。 本文经授权转自作者公众号「Phodal」。 相关资料：《整洁架构之道》 源码：https://github.com/phodal/clean-angular 【END】 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞&nbsp;京东 60 天哗变！CTO 成优化第一人 | 畅言 ☞&nbsp;硬核黑科技告诉你，漫威十年到底有多少个角色？ ☞&nbsp;全方位测评Hive、SparkSQL、Presto 等七个大数据查询引擎，最快的竟是……| 程序员硬核测评 ☞厉害了！超越 Google，16 岁少女发明眼疾诊断 AI 模型！ ☞&nbsp;和 996 对着干的百亿巨头：不打卡，不设 KPI，福利好到爆，却称霸行业 20 年！ ☞&nbsp;回报率29%! 大神用情感分析创建一个比特币交易算法, 原来交易玩的是心理战 ☞&nbsp;开发者如何写好技术简历？ ☞&nbsp;写代码这条路，能走多远？阿里算法专家告诉你 ☞ 她说：为啥程序员都特想要机械键盘？这答案我服！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 你点的每个“在看”，我都认真当成了喜欢","@type":"BlogPosting","url":"/2019/04/29/728819.html","headline":"前端代码的整洁之道   技术头条","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/29/728819.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>前端代码的整洁之道&nbsp;|&nbsp;技术头条</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <section class="xmteditor" style="display:none;" data-tools="新媒体管家" data-label="powered by xmt.cn"></section> 
<p style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: normal;"><img class="rich_pages" data-copyright="0" data-ratio="0.15644171779141106" data-src="https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAujHRSdcX3IznHduusnhVrSgibxlHEaKkBO8A7UcDdDzAnMIA2ZLfuoUKKJrwSA8HPTejcSLotzprZw/640?wx_fmt=gif" data-type="gif" data-w="652" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAujHRSdcX3IznHduusnhVrSgibxlHEaKkBO8A7UcDdDzAnMIA2ZLfuoUKKJrwSA8HPTejcSLotzprZw/640?wx_fmt=gif"></p> 
<p style="text-align: justify;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: normal;"><span style="font-size: 15px;letter-spacing: 1px;"></span></p> 
<blockquote class="js_blockquote_wrap" data-type="2" data-url="" data-author-name="" data-content-utf8-length="82" data-source-title=""> 
 <section class="js_blockquote_digest"> 
  <section> 
   <p style="text-align: justify;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: normal;"><span style="font-size: 15px;letter-spacing: 1px;">在前端开发过程中，你有没有遇到过由于代码交互太多太重时，想改动一行代码“牵一发而动全身”；使用框架很爽，可框架绑定应用却很麻烦？那么如何解决呢？</span></p> 
   <p style="text-align: justify;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: normal;"><span style="font-size: 15px;letter-spacing: 1px;">你需要“前端整洁<span style="font-size: 15px;letter-spacing: 1px;text-align: center;">”</span>。</span></p> 
  </section> 
 </section> 
</blockquote> 
<p style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: normal;"><img class="rich_pages" data-copyright="0" data-ratio="0.66640625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhP0W8cvXIj7XxmpmfMYLYnaC5U7Le7lWClty0TIN4zy31UnmVjxHXiadicibWKic3C3Rq7K60yz3OTUQ/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhP0W8cvXIj7XxmpmfMYLYnaC5U7Le7lWClty0TIN4zy31UnmVjxHXiadicibWKic3C3Rq7K60yz3OTUQ/640?wx_fmt=jpeg"></p> 
<p style="letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: normal;text-align: right;"><span style="color: rgb(136, 136, 136);font-size: 14px;">作者 |&nbsp;Phodal</span></p> 
<p style="letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: normal;text-align: right;"><span style="color: rgb(136, 136, 136);font-size: 14px;">责编 | 伍杏玲</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LXSAriayI15u06ibNNlXzIcor2tTtgJBKFxkIicJ8tiaRKRaictbrQEssdSg/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LXSAriayI15u06ibNNlXzIcor2tTtgJBKFxkIicJ8tiaRKRaictbrQEssdSg/640?wx_fmt=png"></strong></p> 
<h2 style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 18px;">前端的恶梦</span></strong><span style="font-size: 15px;"></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<h2 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">在我最近的一个项目里，我使用了 Angular 和混合应用技术编写了一个实时聊天应用。为了方便这个应用直接修改，无缝地嵌入到其它应用程序中。我尽量减少了 Component 和 Service 的数量。</span></h2> 
<h2 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">然而，由于交互复杂 Component 的数量也不能减少。随后，当我们完成了这个项目的时候，主要的组件代码差不多有 1000 行。这差不多是一个复杂的应用的代码数。<strong>在我试图多次去重构代码时，我发现这并不是一件容易的事：</strong><strong>太多的交互。</strong></span></h2> 
<h2 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">导致了 UI 层的代码，很难被抽取出去。我还能做的事情是将一些业务逻辑抽取出来，只是怎么去抽取了？这成了我的一个疑惑。</span></h2> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">MVP 嘛，逻辑不都是放到 Presenter 里，还有其它的招吗？</span></p> 
<h3 style="margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></h3> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LwYnW1VvkaHWiaL6W1Mr1yiaNLQpxwhyqice9F1yJzMHticssPX515qyvog/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LwYnW1VvkaHWiaL6W1Mr1yiaNLQpxwhyqice9F1yJzMHticssPX515qyvog/640?wx_fmt=png"></strong></p> 
<h3 style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 18px;">AVR is Evil</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">Angular、Vue 和 React 都是一些不错的框架，但是它们都是恶魔，因为我们绑定了框架。我们可以很快地从一个 React 的框架，迁移应用到其它类 React 框架，诸如 Preact；我们可以从一个类似于 Vue 的框架，迁移应用到其它类 Vue 的应用。但是我们很难从 React 迁移到 Angular，又或者是 Vue 迁移到 Angular。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">万一有一天某个框架的核心维护人员健康状况不好，那么我们可能就得重写整个应用。这对于一个技术人员/Tech Lead/项目经验/业务人员来说，这种情况是不可接受的。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">所以，为了应对这些框架带来的问题，我们选择 Web Components 技术，又或者是微前端技术，从架构上切开我们的业务。但是它们并不是银弹，它们反而是一个累赘，限定了高版本的浏览器，制定了更多的规范。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">与此同时，<strong>不论是微前端技术还是 Web Components，它们都没有解决一个问题：</strong><strong>框架绑定应用。</strong></span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">框架绑定应用，就是一种灾害。没有人希望哪一天因为 Java 需要高额的付费，而导致我们选择重写整个应用。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lb4ybNEVGnaAvEDwENKzW27LUKFDGZPKcBneWwTaTpaJyG2C3em7libQ/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lb4ybNEVGnaAvEDwENKzW27LUKFDGZPKcBneWwTaTpaJyG2C3em7libQ/640?wx_fmt=png"></strong></span></p> 
<h3 style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 18px;"><strong>组件化及 Presenter 过重</strong></span><span style="font-size: 15px;"></span></h3> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<h3 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">应对页面逻辑过于重的问题，我们选择了组件化。将一个页面拆分成一系列的业务组件，再进一步地对这些业务组件进行地次细分，形成更小的业务组件，最后它们都依赖于组件库。</span></h3> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">可是呢，细化存在一个问题是：更难以摆脱的框架绑定。与此同时，我们大量的业务逻辑仍然放置在 Presenter 里。我们的 Presenter 充满了大量的业务逻辑和非业务逻辑：</span></p> 
<ul style="list-style-type: circle;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">页面展示相应的逻辑。诸如点击事件、提交表单等等。</span></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">状态管理。诸如是否展示，用户登录状态等等。</span></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">业务逻辑。诸如某个字符串，要用怎样的形式展示。</span></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">数据持续化。哪些数据需要存储在 LocalStorage，哪些数据存储在 IndexedDB 里？</span></p></li> 
</ul> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">为了应对 Presenter 过重的问题，我们使用了 Service 来处理某一块具体的业务，我们使用了 Utils、Helper 来处理一些公共的逻辑。哪怕是如此，我们使用 A 框架编写的业务逻辑，到了 B 框架中无法复用。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">直到我最近重新接触了 Clean Architectrue，我发现 Presenter 还是可以进一步拆分的。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><img class="rich_pages" data-copyright="0" data-cropselx1="0" data-cropselx2="160" data-cropsely1="0" data-cropsely2="26" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LLqyf6BY4rMfY2LsU81MibFjicKDLjMjib5R23h8uo6GtGDY8OufWJfpEw/640?wx_fmt=png" data-type="png" data-w="160" style="width: 160px;height: 26px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LLqyf6BY4rMfY2LsU81MibFjicKDLjMjib5R23h8uo6GtGDY8OufWJfpEw/640?wx_fmt=png"></strong></p> 
<h2 style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 18px;">整洁的前端架构</span></strong><span style="font-size: 15px;"></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<h2 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">Clean Architecture 是由 Robert C. Martin 在 2012 年提出的。最早，我只看到在 Android 应用上的使用，一来 Android 开发使用的是 Java，二来 Android 应用有很重的 View 层。</span></h2> 
<h2 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">与此同时，在 7 年的时间里，由于前后端的分离，UI 层已经从后端的部分消失了。当然了，你也可以说 JSON 也是一种 View（至少它是可见的）。尽管，还存在一定数量的后端渲染 Web 应用，但是新的应用几乎不采用这样的模式。</span></h2> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">但是，在 9012 年的今天，前端应用走向了 MV* 的架构方案，也有了一层很重的 View 层。类似于过去的后端应用，或者后端应用。相似的架构，也可以在前端项目中使用。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><br></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1.5px;"><span style="font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-cropselx1="0" data-cropselx2="160" data-cropsely1="0" data-cropsely2="26" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LzUzfol6q1COlZYpeYXqe0aia45DXyhcTQW8voWvibFJvEjfmkhPvCrEg/640?wx_fmt=png" data-type="png" data-w="160" style="width: 160px;height: 26px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LzUzfol6q1COlZYpeYXqe0aia45DXyhcTQW8voWvibFJvEjfmkhPvCrEg/640?wx_fmt=png"></strong></span></p> 
<h3 style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1.5px;"><span style="font-size: 18px;"><strong>整洁架构</strong></span><span style="font-size: 15px;"></span></h3> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">Robert C. Martin 总结了六边形架构（即端口与适配器架构）：DCI （Data-Context-Interactions，数据-场景-交互）架构、BCI（Boundary Control Entity，Boundary Control Entity）架构等多种架构，归纳出了这些架构的基本特点：</span></p> 
<ul style="list-style-type: circle;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">框架无关性</span></strong><span style="font-size: 15px;">。系统不依赖于框架中的某个函数，框架只是一个工具，系统不能适应于框架。</span></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">可被测试。</span></strong><span style="font-size: 15px;">业务逻辑脱离于 UI、数据库等外部元素进行测试。</span></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">UI&nbsp;无关性。</span></strong><span style="font-size: 15px;">不需要修改系统的其它部分，就可以变更 UI，诸如由 Web 界面替换成 CLI。</span></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">数据库无关性。</span></strong><span style="font-size: 15px;">业务逻辑与数据库之间需要进行解耦，我们可以随意切换 LocalStroage、IndexedDB、Web SQL。</span></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">外部机构（agency）无关性</span></strong><span style="font-size: 15px;">。系统的业务逻辑，不需要知道其它外部接口，诸如安全、调度、代理等。</span></p></li> 
</ul> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">如你所见，作为一个普通（不分前后端）的开发人员，我们关注于业务逻辑的抽离，让业务逻辑独立于框架。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">而在前端的实化，则是让前端的业务逻辑，可以独立于框架，只让 UI（即表现层）与框架绑定。一旦，我们更换框架的时候，只需要替换这部分的业务逻辑即可。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">为此，基于这个概念 Robert C. Martin 绘制出了整洁架构的架构图：</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;letter-spacing: 1px;text-align: center;line-height: normal;"><img class="rich_pages" data-backh="291" data-backw="556" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVY4Z0iaibCSWZn2wQyrRIzx6FOWMcsfY8yolrIOT4yBYpoH6O6mIE9aRw/0?wx_fmt=png" data-copyright="0" data-ratio="0.5233118971061094" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVY4Z0iaibCSWZn2wQyrRIzx6FOWMcsfY8yolrIOT4yBYpoH6O6mIE9aRw/640?wx_fmt=png" data-type="png" data-w="2488" style="width: 100%;height: auto;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVY4Z0iaibCSWZn2wQyrRIzx6FOWMcsfY8yolrIOT4yBYpoH6O6mIE9aRw/640?wx_fmt=png"></p> 
<figure> 
 <p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;letter-spacing: 1px;text-align: center;line-height: normal;"><span style="font-size: 14px;color: rgb(136, 136, 136);">Clean Architecture</span></p> 
</figure> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">如图所示，Clean Architecture 一共分为四个环，四个层级。环与环之间，存在一个依赖关系原则：<strong>源代码中的依赖关系，必须只指向同心圆的内层，即由低层机制指向高级策略。</strong>其类似于 SOLID 中的依赖倒置原则：</span></p> 
<ul style="list-style-type: circle;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">高层模块不应该依赖低层模块，两者都应该依赖其抽象。</span></strong></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">抽象不应该依赖细节，细节应该依赖抽象。</span></strong><span style="font-size: 15px;"></span></p></li> 
</ul> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">与此同时，四个环都存在各自核心的概念：</span></p> 
<ul style="list-style-type: circle;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">实体（Entities<span style="font-size: 15px;letter-spacing: 1px;">）</span>，又称领域对象或业务对象，实体用于封装企业范围的业务规则。</span></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">用例（Use Cases<span style="font-size: 15px;letter-spacing: 1px;">）</span>，交互器，用例是特定于应用的业务逻辑。</span></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">接口适配器（Interface Adapters<span style="font-size: 15px;letter-spacing: 1px;">）</span>，接口适配器层的主要作用是转换数据。</span></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">框架和驱动（Frameworks and Drivers），最外层由各种框架和工具组成，比如 Web 框架、数据库访问工具等。</span></p></li> 
</ul> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这个介绍可能有些简单，让我更详细的解释：</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">实体（Entities），实体用于封装企业范围的业务规则。实体可以是拥有方法的对象，也可以是数据结构和函数的集合。如果没有企业，只是单个应用，那么实体就是应用里的业务对象。这些对象封装了最通用和高层的业务规则，极少会受到外部变化的影响。任何操作层面的改动都不会影响到这一层。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">用例（Use Cases），用例是特定于应用的业务逻辑，一般用来完成用户的某个操作。用例协调数据流向或者流出实体层，并且在此过程中通过执行实体的业务规则来达成用例的目标。用例层的改动不会影响到内部的实体层，同时也不会受外层的改动影响，比如数据库、UI 和框架的变动。只有而且应当应用的操作发生变化的时候，用例层的代码才随之修改。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">接口适配器（Interface Adapters）。接口适配器层的主要作用是转换数据，数据从最适合内部用例层和实体层的结构转换成适合外层（比如数据持久化框架）的结构。反之，来自于外部服务的数据也会在这层转换为内层需要的结构。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">框架和驱动（Frameworks and Drivers）。最外层由各种框架和工具组成，比如 Web 框架、数据库访问工具等。通常在这层不需要写太多代码，大多是一些用来跟内层通信的胶水代码。这一层包含了所有实现细节，把实现细节锁定在这一层能够减少它们的改动对整个系统造成的伤害。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">概念就这么扯到这里吧，然后看看相应的实现。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"> 
  <mpcpc js_editor_cpcad="" class="js_cpc_area res_iframe cpc_iframe" src="/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1556447959004" data-category_id_list="1|15|16|17|36|37|41|42|43|48|7|8" data-id="1556447959004"></mpcpc></span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L8DRknQu3FB9eZicibvOSlVrgnllB3XcGnsrw4zCk19ic0QjZkTPoqFMWw/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L8DRknQu3FB9eZicibvOSlVrgnllB3XcGnsrw4zCk19ic0QjZkTPoqFMWw/640?wx_fmt=png"></strong></span></p> 
<h3 style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 18px;"><strong>Clean Architecture 数据流</strong></span><span style="font-size: 15px;"></span></h3> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">上图中的右侧部分表示的是相应的数据流，数据从 Controller 流出，经过 Use Case（用例）的输入端口，然后通过 Use Case 本身，最后通过 Use Case 输出端口返回给 Presenter。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">让我们来看一个较为直观的例子：</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><img class="rich_pages" data-backh="291" data-backw="556" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVh9kPbItf0eUQI4ouK2ykIia8bbm7gqwsTwZYoQAZNZAIN4q0Ch4C3dw/0?wx_fmt=png" data-copyright="0" data-ratio="0.5233118971061094" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVh9kPbItf0eUQI4ouK2ykIia8bbm7gqwsTwZYoQAZNZAIN4q0Ch4C3dw/640?wx_fmt=png" data-type="png" data-w="2488" style="width: 100%;height: auto;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVh9kPbItf0eUQI4ouK2ykIia8bbm7gqwsTwZYoQAZNZAIN4q0Ch4C3dw/640?wx_fmt=png"></p> 
<figure> 
 <p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="font-size: 14px;color: rgb(136, 136, 136);">Clean Architecture 数据流</span></p> 
</figure> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">上图（来源，见参考文章）是一个 Android 应用的数据流示意图。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">对于只懂得前端的开发大致说明一下，Android 的 View 和 Presenter 的关系。在前端应用中，我们假设以使用 Component 来表示一个组件，如 Angular 中的 HomepageComponent。而这个 HomepageComponent 中，它必然充满了一些无关于页面显示的逻辑，比如从后端获取显示数据之类的。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">而 Java 的写法本身是比较臃肿的，所以在 Android 的 Activity 中就会充斥大量的代码。为此，Android 的开发人员们，采用了 MVP 架构，通过 Presenter 来将与显示无关的行为，从 View 中抽离出来。</span></p> 
<h3 style="margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></h3> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LFV97HltQYlNPKDzX97K1Ll0EicLrBIuWQtgLtQYdFKkkLcWKGUeMTfg/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LFV97HltQYlNPKDzX97K1Ll0EicLrBIuWQtgLtQYdFKkkLcWKGUeMTfg/640?wx_fmt=png"></strong></p> 
<h3 style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 18px;">优缺点</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">优点：</span></strong><span style="font-size: 15px;"></span><br></p> 
<ul style="list-style-type: circle;margin-left: 8px;margin-right: 8px;" class=" list-paddingleft-2"> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">框架无关性</span></strong></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">可被测试</span></strong></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">UI 无关性</span></strong></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">数据库无关性</span></strong></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">外部机构无关性</span></strong></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">定义了特定功能的代码放在何处</span></strong></p></li> 
 <li><p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">可以在多个项目共享业务逻辑</span></strong><span style="font-size: 15px;"></span></p></li> 
</ul> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">相应的它还有大量的<strong>缺点</strong>：</span></p> 
<ul class=" list-paddingleft-2" style="list-style-type: circle;"> 
 <li><p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">过于复杂</span></strong><span style="font-size: 15px;">。</span></p><p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">数据需要经过多层处理，Repository 转为 Entity，经过 Usecase 转为 Model，再交由 Presenter 处理，最后交由 View 显示。一个示例如下所示（源自Android-Clean-Boilerplate）：</span></p><p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="color: rgb(136, 136, 136);font-size: 15px;">MainActivity-&gt;MainPresenter-&gt;WelcomingInteractor-&gt; WelcomeMessageRepository-&gt;WelcomingInteractor-&gt;MainPresenter-&gt;MainActivity</span><span style="font-size: 15px;"></span></p></li> 
 <li><p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">过度设计。</span></strong></p><p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;"></span></strong><span style="font-size: 15px;">事到如今，我们做了大量的设计，对于一个简单的工程来说，这样的模式可能是过度式的设计。</span></p></li> 
 <li><p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">大量的模板式代码。</span></strong></p><p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;"></span></strong><span style="font-size: 15px;">Usecase、Model 等一系列重复的模板式代码。</span></p></li> 
 <li><p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">陡峭的学习曲线。</span></strong></p><p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">不用我多说，看这篇文章的长度。</span></p></li> 
</ul> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">所以，在采用之前，请再次考虑一下，你的应用是否足够的复杂：业务上的复杂度，代码上的复杂度等等。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lf6AGBpotDb1DGltQgly1vKzgCCOtT3OQn43luu8r1JxUV1PmiaSAViaw/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lf6AGBpotDb1DGltQgly1vKzgCCOtT3OQn43luu8r1JxUV1PmiaSAViaw/640?wx_fmt=png"></strong></p> 
<h2 style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 18px;">前端 Clean 架构</span></strong><span style="font-size: 15px;"></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">说了，这么多，让我们来结合一下前端，设计一下新的前端架构。</span></p> 
<h3 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">客户端 Clean 架构 + MVP</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">与后端架构相比， Android 的 MVP 架构 + Clean 架构更与前端相似，为此我们再说看看它们结合的一个示例：</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><img class="rich_pages" data-backh="248" data-backw="556" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LV0LKgD7vjUytMnzFU6JXubovKuGEnLB0RticeIiaTsKDu43OgDH6IBwQA/0?wx_fmt=png" data-copyright="0" data-ratio="0.4452709883103082" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LV0LKgD7vjUytMnzFU6JXubovKuGEnLB0RticeIiaTsKDu43OgDH6IBwQA/640?wx_fmt=png" data-type="png" data-w="941" style="width: 100%;height: auto;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LV0LKgD7vjUytMnzFU6JXubovKuGEnLB0RticeIiaTsKDu43OgDH6IBwQA/640?wx_fmt=png"></p> 
<figure> 
 <p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">Android Clean Architecture</span></p> 
</figure> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">与上一个数据流的相比，这个数据流图更容易落地。其与传统的 MVP（Model-View-Presenter）架构相比：</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><img class="rich_pages" data-copyright="0" data-ratio="0.628992628992629" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVtAyQ51Xdz5xoKAouTDr3Vsddf2y1RqIOZwibmyvDIOnib7lubwHXE1jA/640?wx_fmt=png" data-type="png" data-w="407" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVtAyQ51Xdz5xoKAouTDr3Vsddf2y1RqIOZwibmyvDIOnib7lubwHXE1jA/640?wx_fmt=png"></p> 
<figure> 
 <p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">MVP</span></p> 
</figure> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">基于 Clean Architecture 方案时，则多了一个领域层（图中的 Domain Layer，即业务层），在这一层领域层里，放置的是系统相关的用例（Usecase），而用例所包含的则是相应的业务逻辑。</span></p> 
<h3 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">Clean Architecture + MVP + 组件化</span></strong></h3> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">上述的 MVP + Clean Architecture 的架构方式，对于前端应用的架构设计来说，也是相当合适的。稍有不同的是，我们是否有必要将一个组件分为 Presenter + View。以我的角度来说，对于大部分前端应用来说，并没有这么复杂的情况，因为前端有组件化架构。</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">所以，最后对于我们的前端应用而言，架构如下图所示：</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><img class="rich_pages" data-backh="151" data-backw="556" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_jpg/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVZonzUj4Qv3eY2m6yOIggJyfarEarsAvxG6vN4QUqL8b4K3sCXAKy0A/0?wx_fmt=jpeg" data-copyright="0" data-ratio="0.27109375" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVZonzUj4Qv3eY2m6yOIggJyfarEarsAvxG6vN4QUqL8b4K3sCXAKy0A/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" style="width: 100%;height: auto;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVZonzUj4Qv3eY2m6yOIggJyfarEarsAvxG6vN4QUqL8b4K3sCXAKy0A/640?wx_fmt=jpeg"></p> 
<figure> 
 <p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">Clean MVP 组件化</span></p> 
</figure> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这里，只是对于 Presenter 进行更细一步的细化，以真实的模式取代了 MVP 中的 Presenter。</span></p> 
<h2 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><br></h2> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L7H0ibIdQobyzuicxzGicfibXUugu11UNG7jA3g0M1ibp02QOr8UTuTDiaDwA/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L7H0ibIdQobyzuicxzGicfibXUugu11UNG7jA3g0M1ibp02QOr8UTuTDiaDwA/640?wx_fmt=png"></strong></p> 
<h2 style="letter-spacing: 1px;text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><strong><span style="font-size: 18px;">实践</span></strong><span style="font-size: 15px;"></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">值得注意的是，我们在这里违反了依赖倒置原则。原因是，这里的注入带来了一定的前端复杂度，而这个注入并非是必须的——对于大部分的前端应用而言，只会有单一的数据源，那便是后端数据。</span></p> 
<h3 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">单体式分层架构</span></strong><span style="font-size: 15px;"></span></h3> 
<p style="line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">在我起初设计的版本里，参照的 Clean Angular 工程（Angular Clean Architecture）里，其采用的是单体式的 Clean Architecture 分层结构：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 15px;font-size: 11px;word-spacing: -3px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">├──&nbsp;core<br><br>│&nbsp;&nbsp;&nbsp;├──&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">base</span>&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;基础函数，如&nbsp;mapper&nbsp;等</span><br><br>│&nbsp;&nbsp;&nbsp;├──&nbsp;domain&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;业务实体</span><br><br>│&nbsp;&nbsp;&nbsp;├──&nbsp;repositories&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;repositories&nbsp;模型</span><br><br>│&nbsp;&nbsp;&nbsp;└──&nbsp;usecases&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;业务逻辑</span><br><br>├──&nbsp;data&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;数据层</span><br><br>│&nbsp;&nbsp;&nbsp;└──&nbsp;repository&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;数据源实现</span><br><br>└──&nbsp;presentation&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;表现层</span><br></p></pre> 
</section> 
<p style="line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">这个实现还是相当不错的，就是过于重视理论——抽象相当的繁琐，导致有点不接地气。我的意思说，没有多少前端人员，愿意按照这个模式来写。</span><br><span style="font-size: 15px;"></span></p> 
<h3 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">微服务式分层架构</span></strong></h3> 
<p style="margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">考虑到 usecase 的业务相关性，及会存在大师的 usecase，我便将 usecase 移到了 data 目录，也存在一定的不合理性。后来，我的同事泽杭，一个有丰富的 React 经验前端开发，他提出了 Redux 中的相关结构。最后，我们探讨出了最后的目录结构：</span></p> 
<div class="prettyprint linenums prettyprinted"> 
 <section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
  <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 15px;font-size: 11px;word-spacing: -3px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">├──&nbsp;core&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;核心代码，包含基本服务和基础代码</span><br><br>├──&nbsp;domain&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;业务层代码，包含每个业务的单独&nbsp;Clean&nbsp;架构内容</span><br><br>│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;某一具体的业务</span><br><br>├──&nbsp;features&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;公共页面组件</span><br><br>├──&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">protected</span>&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;有权限的页面</span><br><br>├──&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;公共页面</span><br><br>└──&nbsp;shared&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;共享目录</span></p></pre> 
 </section>
</div> 
<p style="line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">对应的 elephant 是某一个具体的业务，在该目录下包含了一个完整的 Clean Architecture，相应的目录和文件如下所示：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 15px;font-size: 11px;word-spacing: -3px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">├──&nbsp;model<br><br>│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant.model.ts&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;核心业务模型</span><br><br>├──&nbsp;repository<br><br>│&nbsp;&nbsp;&nbsp;├──&nbsp;elephant-web-entity.ts&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;数据实体，简单的数据模型，用来表示核心的业务逻辑</span><br><br>│&nbsp;&nbsp;&nbsp;├──&nbsp;elephant-web-repository-mapper.ts&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;映射层，用于核心实体层映射，或映射到核心实体层。</span><br><br>│&nbsp;&nbsp;&nbsp;└──&nbsp;elephant-web.repository.ts&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Repository，用于读取和存储数据。</span><br><br>└──&nbsp;usecases<br><br>&nbsp;└──&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">get</span>-elephant-<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">by</span>-id-usecase.usecase.ts&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;用例，构建在核心实体之</span></p></pre> 
</section> 
<div class="prettyprint linenums prettyprinted">
 <p style="line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">之上，并实现应用程序的整个业务逻辑。</span><br></p>
</div> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">我一直思考这样的模式是否有问题，直到我看到我司大佬 Martin Folwer 写下的一篇文章《PresentationDomainDataLayering》，终于有人背锅了。文章中提到了这图：</span></p> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;text-align: center;"><img class="rich_pages" data-backh="501" data-backw="541" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVe63gfTiacfJHBjzf7GyShoG0vNYWF8ICE8qkhiaQVSa8WKlKxkfm6Fsg/0?wx_fmt=png" data-copyright="0" data-ratio="0.9260628465804066" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVe63gfTiacfJHBjzf7GyShoG0vNYWF8ICE8qkhiaQVSa8WKlKxkfm6Fsg/640?wx_fmt=png" data-type="png" data-w="541" style="width: 100%;height: auto;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/aG1vFUMgRBAI9PrU2VLUb7mJHXa7P6LVe63gfTiacfJHBjzf7GyShoG0vNYWF8ICE8qkhiaQVSa8WKlKxkfm6Fsg/640?wx_fmt=png"></p> 
<figure> 
 <p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">分层</span></strong></p> 
</figure> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这个分层类似于微服务的概念，在我所熟悉的 Django 框架中也是这样的结构。也因此从理论和实践上不看，并不存在任何的问题。</span></p> 
<h2 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">它不是一颗银弹。使用 MVP 并不妨碍开发人员将 UI 逻辑放在 View 中，使用 Clean Architecture 不会阻止业务逻辑泄漏到表示层。</span></h2> 
<p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"></span></p> 
<blockquote class="js_blockquote_wrap" data-type="2" data-url="" data-author-name="" data-content-utf8-length="161" data-source-title=""> 
 <section class="js_blockquote_digest"> 
  <section> 
   <p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">作者简介：黄峰达（Phodal），ThoughtWorks Senior Consultant，CSDN 博客专家。长期活跃于 GitHub、CSDN，专注于物联网和前端领域。出版著作《自己动手设计物联网》，以及《Growth：全栈增长工程师指南》等六本电子书，并译有《物联网实战指南》。</span></p> 
   <p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">本文经授权转自作者公众号「Phodal」。</span></p> 
  </section> 
 </section> 
</blockquote> 
<h2 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"></span></h2> 
<blockquote class="js_blockquote_wrap" data-type="2" data-url="" data-author-name="" data-content-utf8-length="55" data-source-title=""> 
 <section class="js_blockquote_digest"> 
  <section> 
   <h2 style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">相关资料：</span>《整洁架构之道》</h2> 
   <p style="margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">源码：https://github.com/phodal/clean-angular</span></p> 
  </section> 
 </section> 
</blockquote> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);text-align: center;line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;">【END】</span><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);text-align: center;line-height: 1.75em;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="rich_pages" data-copyright="0" data-cropselx1="0" data-cropselx2="591" data-cropsely1="0" data-cropsely2="324" data-ratio="0.5482233502538071" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAug39yByOmcISc1L0Exsb7CNugP5wV0jXZJO3A5phGZmodPk0Kic8270crj5QPOpzthxcuiaa8EhX8vg/640?wx_fmt=jpeg" data-type="jpeg" data-w="591" style="height: 324px;width: 591px;box-sizing: border-box !important;overflow-wrap: break-word !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAug39yByOmcISc1L0Exsb7CNugP5wV0jXZJO3A5phGZmodPk0Kic8270crj5QPOpzthxcuiaa8EhX8vg/640?wx_fmt=jpeg"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;text-align: center;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">作为码一代，想教码二代却无从下手：</span><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;text-align: center;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">听说少儿编程很火，可它有哪些好处呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;text-align: center;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">孩子多大开始学习比较好呢？又该如何学习呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;text-align: center;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">最新的编程教育政策又有哪些呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;text-align: center;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">下面给大家介绍CSDN新成员：<strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">极客宝宝（ID：</strong><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">geek_baby）</strong></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);text-align: center;letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">戳他了解更多↓↓↓</span></strong><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);text-align: center;line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="rich_pages" data-copyright="0" data-cropselx1="180" data-cropselx2="438" data-cropsely1="0" data-cropsely2="258" data-ratio="0.3697916666666667" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vbbgCLnCbTPs0mGuVrLHntraYT5MIPrhkqQCmnqobLOf7nkWPh5j6vw/640?wx_fmt=jpeg" data-type="jpeg" data-w="960" style="box-sizing: border-box !important;overflow-wrap: break-word !important;visibility: visible !important;width: 618px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vbbgCLnCbTPs0mGuVrLHntraYT5MIPrhkqQCmnqobLOf7nkWPh5j6vw/640?wx_fmt=jpeg"></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);text-align: center;letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;background-color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">&nbsp;热 文</strong>&nbsp;推 荐&nbsp;</strong></span></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;">☞</span><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">&nbsp;</span></span><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650719196&amp;idx=1&amp;sn=08ddf7ad2a591aa70ab21940ad7ed46f&amp;chksm=bea6b20f89d13b190c34711bb6705ff5f8a52a0e3ffc0fabbe399c01360e5a48861b25a101a0&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2"><span style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;color: rgb(0, 82, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">京东 60 天哗变！CTO 成优化第一人 | 畅言</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650719074&amp;idx=3&amp;sn=fd56d2f3379ff706f68359ad5d76a1e2&amp;chksm=bea6b2b189d13ba7cb43bba91d380dbadce5839f4a54af56922d5e2ec1256c7415db72067d57&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="color: rgb(0, 82, 255);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">☞</a></span>&nbsp;<a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650719196&amp;idx=2&amp;sn=a831241ddf717b6ba37154bfb6ba7fde&amp;chksm=bea6b20f89d13b198e7572e24020cd9c29496f2dbe6d62f006db6165b31f31011cc5c9f93be5&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2"><span style="color: rgb(0, 82, 255);font-size: 14px;">硬核黑科技告诉你，漫威十年到底有多少个角色？</span></a><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650719074&amp;idx=3&amp;sn=fd56d2f3379ff706f68359ad5d76a1e2&amp;chksm=bea6b2b189d13ba7cb43bba91d380dbadce5839f4a54af56922d5e2ec1256c7415db72067d57&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="color: rgb(0, 82, 255);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">☞</a></span>&nbsp;<a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650719196&amp;idx=3&amp;sn=6022e006b3aa0380baf7a90de908b81e&amp;chksm=bea6b20f89d13b19d99855f04330a982f8df0548938721496ec843dffec3c2e56cffd2eadd31&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2"><span style="color: rgb(0, 82, 255);font-size: 14px;">全方位测评Hive、SparkSQL、Presto 等七个大数据查询引擎，最快的竟是……| 程序员硬核测评</span></a><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞</span><a href="http://mp.weixin.qq.com/s?__biz=Mzg3MDA4NDkxMQ==&amp;mid=2247483898&amp;idx=1&amp;sn=393249c9415cd68ad0419916b58eeb11&amp;chksm=ce9279baf9e5f0aceccf2d68fc34859293629b4789dfaeb80471dd778a2fd0e091f02c9b2e06&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(0, 82, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">厉害了！超越 Google，16 岁少女发明眼疾诊断 AI 模型！</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞&nbsp;</span><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&amp;mid=2651010564&amp;idx=1&amp;sn=bd6a56282c0c4962d8f382bbfbc29f39&amp;chksm=8bad85f3bcda0ce5bcd6226e8885846de94816406d953b52293f5f5fe0b492ff46a42ded67b8&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(0, 82, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">和 996 对着干的百亿巨头：不打卡，不设 KPI，福利好到爆，却称霸行业 20 年！</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞&nbsp;</span><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247494769&amp;idx=1&amp;sn=abb7bfed45ee3f260bbf1ef3bd3076f1&amp;chksm=fc7fb28ccb083b9a75bef05479cf2f00a63de95a28c488d373e2e48745d3d5bc8bb1a1fed836&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">回报率29%! 大神用情感分析创建一个比特币交易算法, 原来交易玩的是心理战</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞&nbsp;</span><a href="http://mp.weixin.qq.com/s?__biz=MzA3MjY1MTQwNQ==&amp;mid=2649827450&amp;idx=2&amp;sn=c7c65dc21d36bd75c73b63960df9354b&amp;chksm=871e8f98b069068e39c0c6e70886466bd5edad9105a748e18fcca6d86adc5c829ed671842567&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">开发者如何写好技术简历？</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(0, 82, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">☞&nbsp;</span><a href="http://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&amp;mid=2247504685&amp;idx=1&amp;sn=809459a58b1aed8a085e6f9ef547ce36&amp;chksm=e99ee0d4dee969c2fa6edc341c0a6deadcb2d03ad76add56c1425c2f40642274e56ec4751f1e&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">写代码这条路，能走多远？阿里算法专家告诉你</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞ 她说：为啥程序员都特想要机械键盘？这答案我服！</span></p> 
<section style="white-space: normal;max-width: 100%;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
 <section class="" style="max-width: 100%;font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
  <pre style="max-width: 100%;font-size: inherit;color: inherit;line-height: inherit;box-sizing: border-box !important;overflow-wrap: break-word !important;"><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;padding: 0.5em;max-width: 100%;min-height: 1em;font-size: 14px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;background: rgb(34, 34, 34);color: rgb(170, 170, 170);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">System.out.println(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个在看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">console.log(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(50, 170, 238);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">print</span>(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(50, 170, 238);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">printf</span>(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">在</span>看吧！\n"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">cout&nbsp;&lt;&lt;&nbsp;<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">在</span>看吧！"</span>&nbsp;&lt;&lt;&nbsp;endl;<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">Console.WriteLine(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">Response.Write(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;overflow-wrap: break-word !important;">alert(</span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: break-word !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">在</span>看吧！"</span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;overflow-wrap: break-word !important;">)</span><br style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;font-variant-numeric: normal;line-height: inherit;widows: 1;color: rgb(50, 170, 238);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">echo </span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: break-word !important;">"点个<span style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">在</span>看吧！"</span></p></pre> 
 </section> 
</section> 
<section class="" data-tools="135编辑器" data-id="94250" style="white-space: normal;max-width: 100%;box-sizing: border-box;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);border-width: 0px;border-style: none;border-color: initial;overflow-wrap: break-word !important;"> 
 <section class="" data-tools="135编辑器" data-id="91842" style="max-width: 100%;box-sizing: border-box;border-width: 0px;border-style: none;border-color: initial;text-align: right;overflow-wrap: break-word !important;"> 
  <section style="max-width: 100%;display: inline-block;clear: both;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
   <section class="" data-brushtype="text" style="padding: 18px 15px 20px 10px;max-width: 100%;box-sizing: border-box;color: rgb(86, 146, 214);background-image: url(&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdy66AHd7QqL7A2s5icSBE0aw4iaKOKPnXGYxQPhG7VMpbbYV6VJprSh7w/640?wx_fmt=png&quot;);background-repeat: no-repeat;text-align: center;background-size: 100% 100%;font-size: 16px;letter-spacing: 1.5px;overflow-wrap: break-word !important;"> 
    <section style="max-width: 100%;display: flex;justify-content: center;align-items: center;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
     <section style="margin-left: 2px;max-width: 100%;width: 20px;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
      <img class="" data-ratio="0.8936170212765957" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdvAd0o9e1LlUGA2k0Yib222agOxzweXhahA9GuzJcGBg0dA4DzlibxRqw/640?wx_fmt=png" data-type="png" data-w="47" style="margin-bottom: -6px;box-sizing: border-box !important;overflow-wrap: break-word !important;visibility: visible !important;width: 20px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdvAd0o9e1LlUGA2k0Yib222agOxzweXhahA9GuzJcGBg0dA4DzlibxRqw/640?wx_fmt=png"> 
     </section> 
     <section class="" data-brushtype="text" style="max-width: 100%;font-size: 14px;color: rgb(51, 51, 51);text-align: right;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
      <span style="max-width: 100%;font-family: 楷体, 楷体_GB2312, SimKai;box-sizing: border-box !important;overflow-wrap: break-word !important;">你点的每个“在看”，我都认真当成了喜欢</span> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
