<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【基本功】Litho的使用及原理剖析 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【基本功】Litho的使用及原理剖析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="总第344篇 2019年 第22篇 美美导读：【基本功】专栏又上新了，本期介绍一套高效构建Android UI的声明式框架——Litho。作者将带领大家深入剖析它的原理和用法。 1. 什么是Litho？ Litho是Facebook推出的一套高效构建Android UI的声明式框架，主要目的是提升RecyclerView复杂列表的滑动性能和降低内存占用。下面是Litho官网的介绍： Litho is a declarative framework for building efficient user interfaces (UI) on Android. It allows you to write highly-optimized Android views through a simple functional API based on Java annotations. It was primarily built to implement complex scrollable UIs based on RecyclerView.With Litho, you build your UI in terms of components instead of interacting directly with traditional Android views. A component is essentially a function that takes immutable inputs, called props, and returns a component hierarchy describing your user interface. Litho是高效构建Android UI的声明式框架，通过注解API创建高优的Android视图，非常适用于基于Recyclerview的复杂滚动列表。Litho使用一系列组件构建视图，代替了Android传统视图交互方式。组件本质上是一个函数，它接受名为Props的不可变输入，并返回描述用户界面的组件层次结构。 Litho是一套完全不同于传统Android的UI框架，它继承了Facebook一向大胆创新的风格，突破性地在Android上实现了React风格的UI框架。架构图如下： 应用层：上层Android应用接入层。 规范层（API）：允许用户使用声明式的API（注解）来构建符合Flexbox规范的布局。 布局层：Litho使用可挂载组件、布局组件和Flexbox组件来构建布局，其中可挂载组件和布局组件允许用户使用规范来定义，各个组件的具体用法下面的组件规范中会详细介绍。在Litho中每一个组件都是一个独立的功能模块。Litho的组件和React的组件相类似，也具有属性和状态的概念，通过状态的变更来控制组件的展示样式。 布局测量：Litho使用Yoga来完成组件布局的异步或同步（可根据场景定制）测量和计算，实现了布局的扁平化。 布局渲染：Litho不仅支持使用View来渲染视图，还可以使用更轻量的Drawable来渲染视图。Litho实现了大量使用Drawable来渲染的基础组件，可以进一步拍平布局。 除了上面提到的扁平化布局，Litho还实现了布局的细粒度复用和异步计算布局的能力，对于这些功能的实现在Litho的特性及原理剖析中详细介绍。下面先介绍一下大家比较关心的Litho使用方法。 2. Litho的使用 Litho的使用方式相比于传统的Android来说有些另类，它抛弃了通过XML定义布局的方式，采用声明式的组件在Java中构建布局。 2.1 Litho和原生Android在使用上的区别 Android传统布局：首先在资源文件res/layout目录下定义布局文件xx.xml，然后在Activity或Fragment中引用布局文件生成视图，示例如下： 2.2 Litho自定义视图 Litho中的视图单元叫做Component，可以直观的翻译为“组件”，它的设计理念来自于React组件化的思想。每个组件持有描述一个视图单元所必须的属性和状态，用于视图布局的计算工作。视图最终的绘制工作是由组件指定的绘制单元（View或者Drawable）来完成的。 Litho组件的创建方式也和原生View的创建方式有着很大的区别。Litho使用注解定义了一系列的规范，我们需要使用Litho的注解来定义自己的组件生成规则，最终由Litho在编译期自动编译生成真正的组件。 2.2.1 组件规范 Litho提供了两种类型的组件规范，分别是Layout Spec规范和Mount Spec规范。下面分别介绍两种规范的使用方式： Layout Spec规范：用于生成布局类型组件的规范，布局组件在逻辑上等同于Android中的ViewGroup，用于组织其他组件构成一个布局。它要求我们必须使用@LayoutSpec注解来注明，并实现一个标注了@OnCreateLayout注解的方法。示例如下： 最终Litho会在编译时生成一个名为HelloComponent的组件。 Mount Spec规范：用来生成可挂载类型组件的规范，用来生成渲染具体View或者Drawable的组件。同样，它必须使用@MountSpec注解来标注，并至少实现一个标注了@onCreateMountContent的方法。Mount Spec相比于Layout Spec更复杂一些，它拥有自己的生命周期： @OnPrepare，准备阶段，进行一些初始化操作。 @OnMeasure，负责布局的计算。 @OnBoundsDefined，在布局计算完成后挂载视图前做一些操作。 @OnCreateMountContent，创建需要挂载的视图。 @OnMount，挂载视图，完成布局相关的设置。 @OnBind，绑定视图，完成数据和视图的绑定。 @OnUnBind，解绑视图，主要用于重置视图的数据相关的属性，防止出现复用问题。 @OnUnmount，卸载视图，主要用于重置视图的布局相关的属性，防止出现复用问题。 除了上述两种组件类型，Litho中还有一种特殊的组件——Layout，它不能使用规范来生成。Layout是Litho中的容器组件，类似于Android中的ViewGroup，但是只能使用Flexbox的规范。它可以包含子组件节点，是Litho各组件连接的纽带。Layout组件只是Yoga在Litho中的代理，组件的所有布局相关的属性都会直接设置给Yoga，并由Yoga完成布局的计算。Litho实现了两个Layout组件Row和Column，分别对应Flexbox中的行和列。 2.2.2 Litho的属性 在Litho中属性分为两种，不可变属性称为Props，可变属性称为State，下面分别介绍一下两种属性。 Props属性：组件中使用@Prop注解标注的参数集合，具有单向性和不可变性。下面通过一个简单的例子了解一下如何在组件中定义和使用Props属性： 在上面的代码中，共使用了三次Prop注解，分别标注prop1和prop2两个变量，即定义了prop1和prop2两个属性。Litho会在自动编译生成的MyComponent类的Builder类中生成这两个属性的同名方法。按照如下代码，便可以去使用上面定义的属性： State属性：意为“状态”属性，State属性虽然可变，但是其变化由组件内部控制，例如：输入框、Checkbox等都是由组件内部去感知用户行为，并更新组件的State属性。所以一个组件一旦创建，我们便无法通过任何外部设置去更改它的属性。组件的State属性虽然不允许像Props属性那样去显式设置，但是我们可以定义一个单独的Props属性来当做某个State属性的初始值。 3. Litho的特性及原理剖析 Litho官网首页通过4个段落重点介绍了Litho的4个特性。 3.1 声明式组件 Litho采用声明式的API来定义UI组件，组件通过一组不可变的属性来描述UI。这种组件化的思想灵感来源于React，关于声明式组件的用法上面已经详细介绍过了。 传统Android布局因为UI与逻辑分离，所以开发工具都有强大的预览功能，方便开发者调整布局。而Litho采用React组件化的思想，通过组件连接了逻辑与布局UI，虽然Litho也提供了对Stetho的支持，借助于Chrome开发者工具对界面进行调试，不过使用起来并没有那么方便。 3.2 异步布局 Android系统在绘制时为了防止页面错乱，页面所有View的测量（Measure）、布局（Layout）以及绘制（Draw）都是在UI线程中完成的。当页面UI非常复杂、视图层级较深时，难免Measure和Layout的时间会过长，从而导致页面渲染时候丢帧出现卡顿情况。Litho为解决该问题，提出了异步布局的思想，利用CPU的闲置时间提前在异步线程中完成Measure和Layout的过程，仅在UI线程中完成绘制工作。当然，Litho只是提供了异步布局的能力，它主要使用在RecyclerView等可以提前知道下一个视图长什么样子的场景。 3.2.1 异步布局原理剖析 针对RecyclerView等滑动列表，由于可以提前知道接下来要展示的一个甚至多个条目的视图样式，所以只要提前创建好下一个或多个条目的视图，就可以提前完成视图的布局工作。 那么Android原生为什么不支持异步布局呢？主要有以下两个原因： View的属性是可变的，只要属性发生变化就可能导致布局变化，因此需要重新计算布局，那么提前计算布局的意义就不大了。而Litho组件的属性是不可变的，所以对于一个组件来说，它的布局计算结果是唯一且不变的。 提前异步布局就意味着要提前创建好接下来要用到的一个或者多个条目的视图，而Android原生的View作为视图单元，不仅包含一个视图的所有属性，而且还负责视图的绘制工作。如果要在绘制前提前去计算布局，就需要预先去持有大量未展示的View实例，大大增加内存占用。反观Litho的组件则没有这个问题，Litho的组件只是视图属性的一个集合，仅负责计算布局，绘制工作由指定的绘制单元来完成，相比与传统的View显然Litho的组件要轻量的多。所以在Litho中，提前创建好接下来要用到的多个条目的组件，并不会带来性能问题，甚至还可以直接把组件当成滑动列表的数据源。如下图所示： 3.3 扁平化的视图 使用Litho布局，我们可以得到一个极致扁平的视图效果。它可以减少渲染时的递归调用，加快渲染速度。 下面是同一个视图在Android和Litho实现下的视图层级效果对比。可以看到，同样的样式，使用Litho实现的布局要比使用Android原生实现的布局更加扁平。 3.3.1 扁平化视图原理剖析 Litho使用Flexbox来创建布局，最终生成带有层级结构的组件树。然后Litho对布局层级进行了两次优化。 使用了Yoga来进行布局计算，Yoga会将Flexbox的相对布局转成绝对布局。经过Yoga处理后的布局没有了原来的布局层级，变成了只有一层。虽然不能解决过度绘制的问题，但是可以有效地减少渲染时的递归调用。 前面介绍过Litho的视图渲染由绘制单元来完成，绘制单元可以是View或者更加轻量的Drawable，Litho自己实现了一系列挂载Drawable的基本视图组件。通过使用Drawable可以减少内存占用，同时相比于View，Android无法检查出Drawable的视图层级，这样可以使视图效果看起来更加扁平。 原理如下图所示，Litho会先把组件树拍平成没有层级的列表，然后使用Drawable来绘制对应的视图单元。 Litho使用Drawable代替View能带来多少好处呢？Drawable和View的区别在于前者不能和用户交互，只能展示，因此Drawable不会像View那样持有很多变量和引用，所以Drawable比View从内存上看要轻量很多。举个例子：50个同样展示“Hello world”的TextView和TextDrawable在内存占比上，前者几乎是后者的8倍。对比图如下，Shallow Size表示对象自身占用的内存大小。 3.3.2 绘制单元的降级策略 由于Drawable不具有交互能力，所以对于使用Drawable无法实现的交互场景，Litho会自动降级成View。主要有以下几种场景： 有监听点击事件。 限制子视图绘出父布局。 有监听焦点变化。 有设置Tag。 有监听触摸事件。 有光影效果。 对于以上场景的使用请仔细考虑，过多的使用会导致Litho的层级优化效果变差。 3.3.3 对比Android的约束布局 为了解决布局嵌套问题，Android推出了约束布局（ConstraintLayout），使用约束布局也可以达到扁平化视图的目的，那么使用Litho的好处是什么呢？ Litho可以更好地实现复杂布局。约束布局虽然可以实现扁平效果，但是它使用了大量的约束来固定视图的位置。随着布局复杂程度的增加，约束条件变得越来越多，可读性也变得越来越差。而Litho则是对Flexbox布局进行的扁平化处理，所以实际使用的还是Flexbox布局，对于复杂的布局Flexbox布局可读性更高。 3.4 细粒度的复用 Litho中的所有组件都可以被回收，并在任何位置进行复用。这种细粒度的复用方式可以极大地提高内存使用率，尤其适用于复杂滑动列表，内存优化非常明显。 3.4.1 原生RecyclerView复用原理剖析 原生的RecyclerView视图按模板类型进行存储并复用，也就是说模板类型越多，所需存储的模板种类也就越多，导致内存占用越来越大。原理如下图。滑出屏幕的itemType1和itemType2都会在Recycler缓存池保存，等待后面滑进屏幕的条目的复用。 3.4.2 细粒度复用优化内存原理剖析 在Litho中，item在回收前，会把LithoView中挂载的各个绘制单元拆分出来（解绑），由Litho自己的缓存池去分类回收，在展示前由LithoView按照组件树的样式组装（挂载）各个绘制单元，这样就达到了细粒度复用的目的。原理如下图。滑出屏幕的itemType1会被拆分成一个个的视图单元。LithoView容器由Recycler缓存池回收，其他视图单元由Litho的缓存池分类回收。 使用细粒度复用的RecyclerView的缓存池不再需要区分模板类型来缓存大量的视图模板，只需要缓存LithoView容器。细粒度回收的视图单元数量要远远小于原来缓存在各个视图模板中的视图单元数量。 4. 实践 美团对Litho进行了二次开发，在美团的MTFlexbox动态化实现方案（简称动态布局）中把Litho作为底层UI渲染引擎来使用。通过动态布局的预览工具，为Litho提供实时预览能力，同时可以有效发挥Litho的性能优化效果。 目前Litho+动态布局的实现方案已经应用在了美团App中，给美团App带来了不错的性能提升。后续，我们还会另外写一篇文章详细介绍Litho+动态布局在美团性能优化的实践方案。 使用Litho+动态布局实现的部分卡片 4.1 内存数据 由于Litho中使用了大量Drawable替换View，并且实现了视图单元的细粒度复用，因此复杂列表滑动时内存优化比较明显。美团首页内存占用随滑动页数变化走势图如下。随着一页一页地滑动，内存优化了30M以上。（数据采集自Vivo x20手机内存占用情况） 4.2 FPS数据 FPS的提升主要得益于Litho的异步布局能力，提前计算布局可以减少滑动时的帧率波动，所以滑动过程较平稳，不会有高低起伏的卡顿感。（数据采集自魅蓝2手机一段时间内连续fps的波动情况） 5. 总结 Litho相对于传统Android是颠覆式的，它采用了React的思路，使用声明式的API来编写UI。相比于传统Android，确实在性能优化上有很大的进步，但是如果完全使用Litho开发一款应用，需要自己实现很多组件，而Litho的组件需要在编译时生成，实时预览方面也有所欠缺。相对于直接使用Litho的高成本，把Litho封装成Flexbox布局的底层渲染引擎是个不错的选择。 6. 参考资料 Litho官网 说一说 Facebook 开源的 Litho React官网 Yoga官网 7. 作者简介 少宽，美团Android开发工程师，2015年加入美团，负责美团平台终端业务研发工作。 张颖，美团Android开发工程师，2017年加入美团，负责美团平台终端业务研发工作。 欢迎加入美团前端技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：Litho，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 Android组件化方案及组件消息总线modular-event实战 WMRouter：美团外卖Android开源路由框架 美团外卖Android平台化架构演进实践" />
<meta property="og:description" content="总第344篇 2019年 第22篇 美美导读：【基本功】专栏又上新了，本期介绍一套高效构建Android UI的声明式框架——Litho。作者将带领大家深入剖析它的原理和用法。 1. 什么是Litho？ Litho是Facebook推出的一套高效构建Android UI的声明式框架，主要目的是提升RecyclerView复杂列表的滑动性能和降低内存占用。下面是Litho官网的介绍： Litho is a declarative framework for building efficient user interfaces (UI) on Android. It allows you to write highly-optimized Android views through a simple functional API based on Java annotations. It was primarily built to implement complex scrollable UIs based on RecyclerView.With Litho, you build your UI in terms of components instead of interacting directly with traditional Android views. A component is essentially a function that takes immutable inputs, called props, and returns a component hierarchy describing your user interface. Litho是高效构建Android UI的声明式框架，通过注解API创建高优的Android视图，非常适用于基于Recyclerview的复杂滚动列表。Litho使用一系列组件构建视图，代替了Android传统视图交互方式。组件本质上是一个函数，它接受名为Props的不可变输入，并返回描述用户界面的组件层次结构。 Litho是一套完全不同于传统Android的UI框架，它继承了Facebook一向大胆创新的风格，突破性地在Android上实现了React风格的UI框架。架构图如下： 应用层：上层Android应用接入层。 规范层（API）：允许用户使用声明式的API（注解）来构建符合Flexbox规范的布局。 布局层：Litho使用可挂载组件、布局组件和Flexbox组件来构建布局，其中可挂载组件和布局组件允许用户使用规范来定义，各个组件的具体用法下面的组件规范中会详细介绍。在Litho中每一个组件都是一个独立的功能模块。Litho的组件和React的组件相类似，也具有属性和状态的概念，通过状态的变更来控制组件的展示样式。 布局测量：Litho使用Yoga来完成组件布局的异步或同步（可根据场景定制）测量和计算，实现了布局的扁平化。 布局渲染：Litho不仅支持使用View来渲染视图，还可以使用更轻量的Drawable来渲染视图。Litho实现了大量使用Drawable来渲染的基础组件，可以进一步拍平布局。 除了上面提到的扁平化布局，Litho还实现了布局的细粒度复用和异步计算布局的能力，对于这些功能的实现在Litho的特性及原理剖析中详细介绍。下面先介绍一下大家比较关心的Litho使用方法。 2. Litho的使用 Litho的使用方式相比于传统的Android来说有些另类，它抛弃了通过XML定义布局的方式，采用声明式的组件在Java中构建布局。 2.1 Litho和原生Android在使用上的区别 Android传统布局：首先在资源文件res/layout目录下定义布局文件xx.xml，然后在Activity或Fragment中引用布局文件生成视图，示例如下： 2.2 Litho自定义视图 Litho中的视图单元叫做Component，可以直观的翻译为“组件”，它的设计理念来自于React组件化的思想。每个组件持有描述一个视图单元所必须的属性和状态，用于视图布局的计算工作。视图最终的绘制工作是由组件指定的绘制单元（View或者Drawable）来完成的。 Litho组件的创建方式也和原生View的创建方式有着很大的区别。Litho使用注解定义了一系列的规范，我们需要使用Litho的注解来定义自己的组件生成规则，最终由Litho在编译期自动编译生成真正的组件。 2.2.1 组件规范 Litho提供了两种类型的组件规范，分别是Layout Spec规范和Mount Spec规范。下面分别介绍两种规范的使用方式： Layout Spec规范：用于生成布局类型组件的规范，布局组件在逻辑上等同于Android中的ViewGroup，用于组织其他组件构成一个布局。它要求我们必须使用@LayoutSpec注解来注明，并实现一个标注了@OnCreateLayout注解的方法。示例如下： 最终Litho会在编译时生成一个名为HelloComponent的组件。 Mount Spec规范：用来生成可挂载类型组件的规范，用来生成渲染具体View或者Drawable的组件。同样，它必须使用@MountSpec注解来标注，并至少实现一个标注了@onCreateMountContent的方法。Mount Spec相比于Layout Spec更复杂一些，它拥有自己的生命周期： @OnPrepare，准备阶段，进行一些初始化操作。 @OnMeasure，负责布局的计算。 @OnBoundsDefined，在布局计算完成后挂载视图前做一些操作。 @OnCreateMountContent，创建需要挂载的视图。 @OnMount，挂载视图，完成布局相关的设置。 @OnBind，绑定视图，完成数据和视图的绑定。 @OnUnBind，解绑视图，主要用于重置视图的数据相关的属性，防止出现复用问题。 @OnUnmount，卸载视图，主要用于重置视图的布局相关的属性，防止出现复用问题。 除了上述两种组件类型，Litho中还有一种特殊的组件——Layout，它不能使用规范来生成。Layout是Litho中的容器组件，类似于Android中的ViewGroup，但是只能使用Flexbox的规范。它可以包含子组件节点，是Litho各组件连接的纽带。Layout组件只是Yoga在Litho中的代理，组件的所有布局相关的属性都会直接设置给Yoga，并由Yoga完成布局的计算。Litho实现了两个Layout组件Row和Column，分别对应Flexbox中的行和列。 2.2.2 Litho的属性 在Litho中属性分为两种，不可变属性称为Props，可变属性称为State，下面分别介绍一下两种属性。 Props属性：组件中使用@Prop注解标注的参数集合，具有单向性和不可变性。下面通过一个简单的例子了解一下如何在组件中定义和使用Props属性： 在上面的代码中，共使用了三次Prop注解，分别标注prop1和prop2两个变量，即定义了prop1和prop2两个属性。Litho会在自动编译生成的MyComponent类的Builder类中生成这两个属性的同名方法。按照如下代码，便可以去使用上面定义的属性： State属性：意为“状态”属性，State属性虽然可变，但是其变化由组件内部控制，例如：输入框、Checkbox等都是由组件内部去感知用户行为，并更新组件的State属性。所以一个组件一旦创建，我们便无法通过任何外部设置去更改它的属性。组件的State属性虽然不允许像Props属性那样去显式设置，但是我们可以定义一个单独的Props属性来当做某个State属性的初始值。 3. Litho的特性及原理剖析 Litho官网首页通过4个段落重点介绍了Litho的4个特性。 3.1 声明式组件 Litho采用声明式的API来定义UI组件，组件通过一组不可变的属性来描述UI。这种组件化的思想灵感来源于React，关于声明式组件的用法上面已经详细介绍过了。 传统Android布局因为UI与逻辑分离，所以开发工具都有强大的预览功能，方便开发者调整布局。而Litho采用React组件化的思想，通过组件连接了逻辑与布局UI，虽然Litho也提供了对Stetho的支持，借助于Chrome开发者工具对界面进行调试，不过使用起来并没有那么方便。 3.2 异步布局 Android系统在绘制时为了防止页面错乱，页面所有View的测量（Measure）、布局（Layout）以及绘制（Draw）都是在UI线程中完成的。当页面UI非常复杂、视图层级较深时，难免Measure和Layout的时间会过长，从而导致页面渲染时候丢帧出现卡顿情况。Litho为解决该问题，提出了异步布局的思想，利用CPU的闲置时间提前在异步线程中完成Measure和Layout的过程，仅在UI线程中完成绘制工作。当然，Litho只是提供了异步布局的能力，它主要使用在RecyclerView等可以提前知道下一个视图长什么样子的场景。 3.2.1 异步布局原理剖析 针对RecyclerView等滑动列表，由于可以提前知道接下来要展示的一个甚至多个条目的视图样式，所以只要提前创建好下一个或多个条目的视图，就可以提前完成视图的布局工作。 那么Android原生为什么不支持异步布局呢？主要有以下两个原因： View的属性是可变的，只要属性发生变化就可能导致布局变化，因此需要重新计算布局，那么提前计算布局的意义就不大了。而Litho组件的属性是不可变的，所以对于一个组件来说，它的布局计算结果是唯一且不变的。 提前异步布局就意味着要提前创建好接下来要用到的一个或者多个条目的视图，而Android原生的View作为视图单元，不仅包含一个视图的所有属性，而且还负责视图的绘制工作。如果要在绘制前提前去计算布局，就需要预先去持有大量未展示的View实例，大大增加内存占用。反观Litho的组件则没有这个问题，Litho的组件只是视图属性的一个集合，仅负责计算布局，绘制工作由指定的绘制单元来完成，相比与传统的View显然Litho的组件要轻量的多。所以在Litho中，提前创建好接下来要用到的多个条目的组件，并不会带来性能问题，甚至还可以直接把组件当成滑动列表的数据源。如下图所示： 3.3 扁平化的视图 使用Litho布局，我们可以得到一个极致扁平的视图效果。它可以减少渲染时的递归调用，加快渲染速度。 下面是同一个视图在Android和Litho实现下的视图层级效果对比。可以看到，同样的样式，使用Litho实现的布局要比使用Android原生实现的布局更加扁平。 3.3.1 扁平化视图原理剖析 Litho使用Flexbox来创建布局，最终生成带有层级结构的组件树。然后Litho对布局层级进行了两次优化。 使用了Yoga来进行布局计算，Yoga会将Flexbox的相对布局转成绝对布局。经过Yoga处理后的布局没有了原来的布局层级，变成了只有一层。虽然不能解决过度绘制的问题，但是可以有效地减少渲染时的递归调用。 前面介绍过Litho的视图渲染由绘制单元来完成，绘制单元可以是View或者更加轻量的Drawable，Litho自己实现了一系列挂载Drawable的基本视图组件。通过使用Drawable可以减少内存占用，同时相比于View，Android无法检查出Drawable的视图层级，这样可以使视图效果看起来更加扁平。 原理如下图所示，Litho会先把组件树拍平成没有层级的列表，然后使用Drawable来绘制对应的视图单元。 Litho使用Drawable代替View能带来多少好处呢？Drawable和View的区别在于前者不能和用户交互，只能展示，因此Drawable不会像View那样持有很多变量和引用，所以Drawable比View从内存上看要轻量很多。举个例子：50个同样展示“Hello world”的TextView和TextDrawable在内存占比上，前者几乎是后者的8倍。对比图如下，Shallow Size表示对象自身占用的内存大小。 3.3.2 绘制单元的降级策略 由于Drawable不具有交互能力，所以对于使用Drawable无法实现的交互场景，Litho会自动降级成View。主要有以下几种场景： 有监听点击事件。 限制子视图绘出父布局。 有监听焦点变化。 有设置Tag。 有监听触摸事件。 有光影效果。 对于以上场景的使用请仔细考虑，过多的使用会导致Litho的层级优化效果变差。 3.3.3 对比Android的约束布局 为了解决布局嵌套问题，Android推出了约束布局（ConstraintLayout），使用约束布局也可以达到扁平化视图的目的，那么使用Litho的好处是什么呢？ Litho可以更好地实现复杂布局。约束布局虽然可以实现扁平效果，但是它使用了大量的约束来固定视图的位置。随着布局复杂程度的增加，约束条件变得越来越多，可读性也变得越来越差。而Litho则是对Flexbox布局进行的扁平化处理，所以实际使用的还是Flexbox布局，对于复杂的布局Flexbox布局可读性更高。 3.4 细粒度的复用 Litho中的所有组件都可以被回收，并在任何位置进行复用。这种细粒度的复用方式可以极大地提高内存使用率，尤其适用于复杂滑动列表，内存优化非常明显。 3.4.1 原生RecyclerView复用原理剖析 原生的RecyclerView视图按模板类型进行存储并复用，也就是说模板类型越多，所需存储的模板种类也就越多，导致内存占用越来越大。原理如下图。滑出屏幕的itemType1和itemType2都会在Recycler缓存池保存，等待后面滑进屏幕的条目的复用。 3.4.2 细粒度复用优化内存原理剖析 在Litho中，item在回收前，会把LithoView中挂载的各个绘制单元拆分出来（解绑），由Litho自己的缓存池去分类回收，在展示前由LithoView按照组件树的样式组装（挂载）各个绘制单元，这样就达到了细粒度复用的目的。原理如下图。滑出屏幕的itemType1会被拆分成一个个的视图单元。LithoView容器由Recycler缓存池回收，其他视图单元由Litho的缓存池分类回收。 使用细粒度复用的RecyclerView的缓存池不再需要区分模板类型来缓存大量的视图模板，只需要缓存LithoView容器。细粒度回收的视图单元数量要远远小于原来缓存在各个视图模板中的视图单元数量。 4. 实践 美团对Litho进行了二次开发，在美团的MTFlexbox动态化实现方案（简称动态布局）中把Litho作为底层UI渲染引擎来使用。通过动态布局的预览工具，为Litho提供实时预览能力，同时可以有效发挥Litho的性能优化效果。 目前Litho+动态布局的实现方案已经应用在了美团App中，给美团App带来了不错的性能提升。后续，我们还会另外写一篇文章详细介绍Litho+动态布局在美团性能优化的实践方案。 使用Litho+动态布局实现的部分卡片 4.1 内存数据 由于Litho中使用了大量Drawable替换View，并且实现了视图单元的细粒度复用，因此复杂列表滑动时内存优化比较明显。美团首页内存占用随滑动页数变化走势图如下。随着一页一页地滑动，内存优化了30M以上。（数据采集自Vivo x20手机内存占用情况） 4.2 FPS数据 FPS的提升主要得益于Litho的异步布局能力，提前计算布局可以减少滑动时的帧率波动，所以滑动过程较平稳，不会有高低起伏的卡顿感。（数据采集自魅蓝2手机一段时间内连续fps的波动情况） 5. 总结 Litho相对于传统Android是颠覆式的，它采用了React的思路，使用声明式的API来编写UI。相比于传统Android，确实在性能优化上有很大的进步，但是如果完全使用Litho开发一款应用，需要自己实现很多组件，而Litho的组件需要在编译时生成，实时预览方面也有所欠缺。相对于直接使用Litho的高成本，把Litho封装成Flexbox布局的底层渲染引擎是个不错的选择。 6. 参考资料 Litho官网 说一说 Facebook 开源的 Litho React官网 Yoga官网 7. 作者简介 少宽，美团Android开发工程师，2015年加入美团，负责美团平台终端业务研发工作。 张颖，美团Android开发工程师，2017年加入美团，负责美团平台终端业务研发工作。 欢迎加入美团前端技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：Litho，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 Android组件化方案及组件消息总线modular-event实战 WMRouter：美团外卖Android开源路由框架 美团外卖Android平台化架构演进实践" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"总第344篇 2019年 第22篇 美美导读：【基本功】专栏又上新了，本期介绍一套高效构建Android UI的声明式框架——Litho。作者将带领大家深入剖析它的原理和用法。 1. 什么是Litho？ Litho是Facebook推出的一套高效构建Android UI的声明式框架，主要目的是提升RecyclerView复杂列表的滑动性能和降低内存占用。下面是Litho官网的介绍： Litho is a declarative framework for building efficient user interfaces (UI) on Android. It allows you to write highly-optimized Android views through a simple functional API based on Java annotations. It was primarily built to implement complex scrollable UIs based on RecyclerView.With Litho, you build your UI in terms of components instead of interacting directly with traditional Android views. A component is essentially a function that takes immutable inputs, called props, and returns a component hierarchy describing your user interface. Litho是高效构建Android UI的声明式框架，通过注解API创建高优的Android视图，非常适用于基于Recyclerview的复杂滚动列表。Litho使用一系列组件构建视图，代替了Android传统视图交互方式。组件本质上是一个函数，它接受名为Props的不可变输入，并返回描述用户界面的组件层次结构。 Litho是一套完全不同于传统Android的UI框架，它继承了Facebook一向大胆创新的风格，突破性地在Android上实现了React风格的UI框架。架构图如下： 应用层：上层Android应用接入层。 规范层（API）：允许用户使用声明式的API（注解）来构建符合Flexbox规范的布局。 布局层：Litho使用可挂载组件、布局组件和Flexbox组件来构建布局，其中可挂载组件和布局组件允许用户使用规范来定义，各个组件的具体用法下面的组件规范中会详细介绍。在Litho中每一个组件都是一个独立的功能模块。Litho的组件和React的组件相类似，也具有属性和状态的概念，通过状态的变更来控制组件的展示样式。 布局测量：Litho使用Yoga来完成组件布局的异步或同步（可根据场景定制）测量和计算，实现了布局的扁平化。 布局渲染：Litho不仅支持使用View来渲染视图，还可以使用更轻量的Drawable来渲染视图。Litho实现了大量使用Drawable来渲染的基础组件，可以进一步拍平布局。 除了上面提到的扁平化布局，Litho还实现了布局的细粒度复用和异步计算布局的能力，对于这些功能的实现在Litho的特性及原理剖析中详细介绍。下面先介绍一下大家比较关心的Litho使用方法。 2. Litho的使用 Litho的使用方式相比于传统的Android来说有些另类，它抛弃了通过XML定义布局的方式，采用声明式的组件在Java中构建布局。 2.1 Litho和原生Android在使用上的区别 Android传统布局：首先在资源文件res/layout目录下定义布局文件xx.xml，然后在Activity或Fragment中引用布局文件生成视图，示例如下： 2.2 Litho自定义视图 Litho中的视图单元叫做Component，可以直观的翻译为“组件”，它的设计理念来自于React组件化的思想。每个组件持有描述一个视图单元所必须的属性和状态，用于视图布局的计算工作。视图最终的绘制工作是由组件指定的绘制单元（View或者Drawable）来完成的。 Litho组件的创建方式也和原生View的创建方式有着很大的区别。Litho使用注解定义了一系列的规范，我们需要使用Litho的注解来定义自己的组件生成规则，最终由Litho在编译期自动编译生成真正的组件。 2.2.1 组件规范 Litho提供了两种类型的组件规范，分别是Layout Spec规范和Mount Spec规范。下面分别介绍两种规范的使用方式： Layout Spec规范：用于生成布局类型组件的规范，布局组件在逻辑上等同于Android中的ViewGroup，用于组织其他组件构成一个布局。它要求我们必须使用@LayoutSpec注解来注明，并实现一个标注了@OnCreateLayout注解的方法。示例如下： 最终Litho会在编译时生成一个名为HelloComponent的组件。 Mount Spec规范：用来生成可挂载类型组件的规范，用来生成渲染具体View或者Drawable的组件。同样，它必须使用@MountSpec注解来标注，并至少实现一个标注了@onCreateMountContent的方法。Mount Spec相比于Layout Spec更复杂一些，它拥有自己的生命周期： @OnPrepare，准备阶段，进行一些初始化操作。 @OnMeasure，负责布局的计算。 @OnBoundsDefined，在布局计算完成后挂载视图前做一些操作。 @OnCreateMountContent，创建需要挂载的视图。 @OnMount，挂载视图，完成布局相关的设置。 @OnBind，绑定视图，完成数据和视图的绑定。 @OnUnBind，解绑视图，主要用于重置视图的数据相关的属性，防止出现复用问题。 @OnUnmount，卸载视图，主要用于重置视图的布局相关的属性，防止出现复用问题。 除了上述两种组件类型，Litho中还有一种特殊的组件——Layout，它不能使用规范来生成。Layout是Litho中的容器组件，类似于Android中的ViewGroup，但是只能使用Flexbox的规范。它可以包含子组件节点，是Litho各组件连接的纽带。Layout组件只是Yoga在Litho中的代理，组件的所有布局相关的属性都会直接设置给Yoga，并由Yoga完成布局的计算。Litho实现了两个Layout组件Row和Column，分别对应Flexbox中的行和列。 2.2.2 Litho的属性 在Litho中属性分为两种，不可变属性称为Props，可变属性称为State，下面分别介绍一下两种属性。 Props属性：组件中使用@Prop注解标注的参数集合，具有单向性和不可变性。下面通过一个简单的例子了解一下如何在组件中定义和使用Props属性： 在上面的代码中，共使用了三次Prop注解，分别标注prop1和prop2两个变量，即定义了prop1和prop2两个属性。Litho会在自动编译生成的MyComponent类的Builder类中生成这两个属性的同名方法。按照如下代码，便可以去使用上面定义的属性： State属性：意为“状态”属性，State属性虽然可变，但是其变化由组件内部控制，例如：输入框、Checkbox等都是由组件内部去感知用户行为，并更新组件的State属性。所以一个组件一旦创建，我们便无法通过任何外部设置去更改它的属性。组件的State属性虽然不允许像Props属性那样去显式设置，但是我们可以定义一个单独的Props属性来当做某个State属性的初始值。 3. Litho的特性及原理剖析 Litho官网首页通过4个段落重点介绍了Litho的4个特性。 3.1 声明式组件 Litho采用声明式的API来定义UI组件，组件通过一组不可变的属性来描述UI。这种组件化的思想灵感来源于React，关于声明式组件的用法上面已经详细介绍过了。 传统Android布局因为UI与逻辑分离，所以开发工具都有强大的预览功能，方便开发者调整布局。而Litho采用React组件化的思想，通过组件连接了逻辑与布局UI，虽然Litho也提供了对Stetho的支持，借助于Chrome开发者工具对界面进行调试，不过使用起来并没有那么方便。 3.2 异步布局 Android系统在绘制时为了防止页面错乱，页面所有View的测量（Measure）、布局（Layout）以及绘制（Draw）都是在UI线程中完成的。当页面UI非常复杂、视图层级较深时，难免Measure和Layout的时间会过长，从而导致页面渲染时候丢帧出现卡顿情况。Litho为解决该问题，提出了异步布局的思想，利用CPU的闲置时间提前在异步线程中完成Measure和Layout的过程，仅在UI线程中完成绘制工作。当然，Litho只是提供了异步布局的能力，它主要使用在RecyclerView等可以提前知道下一个视图长什么样子的场景。 3.2.1 异步布局原理剖析 针对RecyclerView等滑动列表，由于可以提前知道接下来要展示的一个甚至多个条目的视图样式，所以只要提前创建好下一个或多个条目的视图，就可以提前完成视图的布局工作。 那么Android原生为什么不支持异步布局呢？主要有以下两个原因： View的属性是可变的，只要属性发生变化就可能导致布局变化，因此需要重新计算布局，那么提前计算布局的意义就不大了。而Litho组件的属性是不可变的，所以对于一个组件来说，它的布局计算结果是唯一且不变的。 提前异步布局就意味着要提前创建好接下来要用到的一个或者多个条目的视图，而Android原生的View作为视图单元，不仅包含一个视图的所有属性，而且还负责视图的绘制工作。如果要在绘制前提前去计算布局，就需要预先去持有大量未展示的View实例，大大增加内存占用。反观Litho的组件则没有这个问题，Litho的组件只是视图属性的一个集合，仅负责计算布局，绘制工作由指定的绘制单元来完成，相比与传统的View显然Litho的组件要轻量的多。所以在Litho中，提前创建好接下来要用到的多个条目的组件，并不会带来性能问题，甚至还可以直接把组件当成滑动列表的数据源。如下图所示： 3.3 扁平化的视图 使用Litho布局，我们可以得到一个极致扁平的视图效果。它可以减少渲染时的递归调用，加快渲染速度。 下面是同一个视图在Android和Litho实现下的视图层级效果对比。可以看到，同样的样式，使用Litho实现的布局要比使用Android原生实现的布局更加扁平。 3.3.1 扁平化视图原理剖析 Litho使用Flexbox来创建布局，最终生成带有层级结构的组件树。然后Litho对布局层级进行了两次优化。 使用了Yoga来进行布局计算，Yoga会将Flexbox的相对布局转成绝对布局。经过Yoga处理后的布局没有了原来的布局层级，变成了只有一层。虽然不能解决过度绘制的问题，但是可以有效地减少渲染时的递归调用。 前面介绍过Litho的视图渲染由绘制单元来完成，绘制单元可以是View或者更加轻量的Drawable，Litho自己实现了一系列挂载Drawable的基本视图组件。通过使用Drawable可以减少内存占用，同时相比于View，Android无法检查出Drawable的视图层级，这样可以使视图效果看起来更加扁平。 原理如下图所示，Litho会先把组件树拍平成没有层级的列表，然后使用Drawable来绘制对应的视图单元。 Litho使用Drawable代替View能带来多少好处呢？Drawable和View的区别在于前者不能和用户交互，只能展示，因此Drawable不会像View那样持有很多变量和引用，所以Drawable比View从内存上看要轻量很多。举个例子：50个同样展示“Hello world”的TextView和TextDrawable在内存占比上，前者几乎是后者的8倍。对比图如下，Shallow Size表示对象自身占用的内存大小。 3.3.2 绘制单元的降级策略 由于Drawable不具有交互能力，所以对于使用Drawable无法实现的交互场景，Litho会自动降级成View。主要有以下几种场景： 有监听点击事件。 限制子视图绘出父布局。 有监听焦点变化。 有设置Tag。 有监听触摸事件。 有光影效果。 对于以上场景的使用请仔细考虑，过多的使用会导致Litho的层级优化效果变差。 3.3.3 对比Android的约束布局 为了解决布局嵌套问题，Android推出了约束布局（ConstraintLayout），使用约束布局也可以达到扁平化视图的目的，那么使用Litho的好处是什么呢？ Litho可以更好地实现复杂布局。约束布局虽然可以实现扁平效果，但是它使用了大量的约束来固定视图的位置。随着布局复杂程度的增加，约束条件变得越来越多，可读性也变得越来越差。而Litho则是对Flexbox布局进行的扁平化处理，所以实际使用的还是Flexbox布局，对于复杂的布局Flexbox布局可读性更高。 3.4 细粒度的复用 Litho中的所有组件都可以被回收，并在任何位置进行复用。这种细粒度的复用方式可以极大地提高内存使用率，尤其适用于复杂滑动列表，内存优化非常明显。 3.4.1 原生RecyclerView复用原理剖析 原生的RecyclerView视图按模板类型进行存储并复用，也就是说模板类型越多，所需存储的模板种类也就越多，导致内存占用越来越大。原理如下图。滑出屏幕的itemType1和itemType2都会在Recycler缓存池保存，等待后面滑进屏幕的条目的复用。 3.4.2 细粒度复用优化内存原理剖析 在Litho中，item在回收前，会把LithoView中挂载的各个绘制单元拆分出来（解绑），由Litho自己的缓存池去分类回收，在展示前由LithoView按照组件树的样式组装（挂载）各个绘制单元，这样就达到了细粒度复用的目的。原理如下图。滑出屏幕的itemType1会被拆分成一个个的视图单元。LithoView容器由Recycler缓存池回收，其他视图单元由Litho的缓存池分类回收。 使用细粒度复用的RecyclerView的缓存池不再需要区分模板类型来缓存大量的视图模板，只需要缓存LithoView容器。细粒度回收的视图单元数量要远远小于原来缓存在各个视图模板中的视图单元数量。 4. 实践 美团对Litho进行了二次开发，在美团的MTFlexbox动态化实现方案（简称动态布局）中把Litho作为底层UI渲染引擎来使用。通过动态布局的预览工具，为Litho提供实时预览能力，同时可以有效发挥Litho的性能优化效果。 目前Litho+动态布局的实现方案已经应用在了美团App中，给美团App带来了不错的性能提升。后续，我们还会另外写一篇文章详细介绍Litho+动态布局在美团性能优化的实践方案。 使用Litho+动态布局实现的部分卡片 4.1 内存数据 由于Litho中使用了大量Drawable替换View，并且实现了视图单元的细粒度复用，因此复杂列表滑动时内存优化比较明显。美团首页内存占用随滑动页数变化走势图如下。随着一页一页地滑动，内存优化了30M以上。（数据采集自Vivo x20手机内存占用情况） 4.2 FPS数据 FPS的提升主要得益于Litho的异步布局能力，提前计算布局可以减少滑动时的帧率波动，所以滑动过程较平稳，不会有高低起伏的卡顿感。（数据采集自魅蓝2手机一段时间内连续fps的波动情况） 5. 总结 Litho相对于传统Android是颠覆式的，它采用了React的思路，使用声明式的API来编写UI。相比于传统Android，确实在性能优化上有很大的进步，但是如果完全使用Litho开发一款应用，需要自己实现很多组件，而Litho的组件需要在编译时生成，实时预览方面也有所欠缺。相对于直接使用Litho的高成本，把Litho封装成Flexbox布局的底层渲染引擎是个不错的选择。 6. 参考资料 Litho官网 说一说 Facebook 开源的 Litho React官网 Yoga官网 7. 作者简介 少宽，美团Android开发工程师，2015年加入美团，负责美团平台终端业务研发工作。 张颖，美团Android开发工程师，2017年加入美团，负责美团平台终端业务研发工作。 欢迎加入美团前端技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：Litho，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 Android组件化方案及组件消息总线modular-event实战 WMRouter：美团外卖Android开源路由框架 美团外卖Android平台化架构演进实践","@type":"BlogPosting","url":"/2019/04/29/729092.html","headline":"【基本功】Litho的使用及原理剖析","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/29/729092.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【基本功】Litho的使用及原理剖析</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;" data-mpa-powered-by="yiban.io"><img class="" data-copyright="0" data-ratio="0.10546875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png" data-type="png" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png"></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;text-align: center;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">总第344篇</span></strong></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;text-align: center;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">2019年 第22篇</span></strong></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;text-align: center;"><br></p> 
<section data-role="outer" label="Powered by 135editor.com" style="font-size:16px;"> 
 <section data-role="outer" label="Powered by 135editor.com"> 
  <section class="_135editor" data-tools="135编辑器" data-id="127" style="border-width: 0px;border-style: none;border-color: initial;"> 
   <section class="_135editor" data-tools="135编辑器" data-id="127" style="border-width: 0px;border-style: none;border-color: initial;"> 
    <section style="margin: 60px 16px 16px;border-width: 1px;border-style: solid;border-color: rgb(235, 234, 225);text-align: center;border-radius: 8px;font-size: 18px;font-weight: inherit;text-decoration: inherit;"> 
     <section style="margin-top: -3.3em;margin-right: 5px;margin-left: 5px;color: inherit;"> 
      <section style="border-width: 2px;border-style: solid;border-color: rgb(235, 234, 225);width: 108px;clear: both;margin-right: auto;margin-left: auto;height: 108px;border-radius: 50%;box-shadow: rgb(201, 201, 201) 0px 2px 2px 2px;background-color: rgb(254, 254, 254);"> 
       <img border="0" class="" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXSfff7GYE4gG7EMIvpwibMGHDh691Cuibz0g0C04Jibu2Dd3uxAPeibVbAb3WDpmXvic549wIFNJLDj0Q/640?wx_fmt=jpeg" data-type="jpeg" data-w="800" data-width="100%" height="98" opacity="" style="border-radius: 50%;color: inherit;display: inline-block;height: 98px;width: 98px;" title="undefined" width="98" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXSfff7GYE4gG7EMIvpwibMGHDh691Cuibz0g0C04Jibu2Dd3uxAPeibVbAb3WDpmXvic549wIFNJLDj0Q/640?wx_fmt=jpeg"> 
      </section> 
     </section> 
     <section class="135brush" data-brushtype="text" data-style="text-align: left; font-size: 14px; color: inherit;" style="margin: 8px 15px;line-height: 1.4;"> 
      <p style="color: inherit;text-align: left;font-size: 14px;letter-spacing: 1.5px;"><span style="color: rgb(0, 0, 0);"><strong>美美导读：</strong></span><span style="font-weight: inherit;text-decoration: inherit;font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;color: rgb(127, 127, 127);font-size: 14px;">【基本功】专栏又上新了，本期介绍一套高效构建Android UI的声明式框架——Litho。作者将带领大家深入剖析它的原理和用法。</span></p> 
      <p style="color: inherit;text-align: left;font-size: 14px;letter-spacing: 1.5px;"><br></p> 
     </section> 
    </section> 
   </section> 
  </section> 
  <p><br></p> 
 </section> 
</section> 
<section class="output_wrapper" style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;"> 
 <h2 style="margin-bottom: 15px;"><span style="font-size: 20px;color: rgb(37, 183, 167);"><strong>1. 什么是Litho？</strong></span></h2> 
 <p><span style="font-size: 15px;">Litho是Facebook推出的一套高效构建Android UI的声明式框架，主要目的是提升RecyclerView复杂列表的滑动性能和降低内存占用。下面是</span><a href="https://fblitho.com/" data-linktype="2" style="color: rgb(30, 107, 184);text-decoration: underline;line-height: inherit;font-size: 15px;">Litho官网</a><span style="font-size: 15px;">的介绍：</span></p> 
 <blockquote style="margin-top: 1em;margin-bottom: 1em;padding: 15px 15px 15px 1rem;border-left-width: 6px;border-left-color: rgb(220, 230, 240);overflow-wrap: normal;line-height: inherit;font-size: 0.9em;color: rgb(129, 145, 152);background: rgb(242, 247, 251);overflow: auto;word-break: normal;"> 
  <p style="margin-bottom: 15px;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 14px;">Litho is a declarative framework for building efficient user interfaces (UI) on Android. It allows you to write highly-optimized Android views through a simple functional API based on Java annotations. It was primarily built to implement complex scrollable UIs based on RecyclerView.<br>With Litho, you build your UI in terms of components instead of interacting directly with traditional Android views. A component is essentially a function that takes immutable inputs, called props, and returns a component hierarchy describing your user interface.</span></p> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 14px;">Litho是高效构建Android UI的声明式框架，通过注解API创建高优的Android视图，非常适用于基于Recyclerview的复杂滚动列表。Litho使用一系列组件构建视图，代替了Android传统视图交互方式。组件本质上是一个函数，它接受名为Props的不可变输入，并返回描述用户界面的组件层次结构。</span></p> 
 </blockquote> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">Litho是一套完全不同于传统Android的UI框架，它继承了Facebook一向大胆创新的风格，突破性地在Android上实现了</span><a href="https://reactjs.org/" data-linktype="2" style="color: rgb(30, 107, 184);text-decoration: underline;line-height: inherit;font-size: 15px;">React</a><span style="font-size: 15px;">风格的UI框架。架构图如下：</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.6359119943222143" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJvkS3JDibpeiaA9PbNHKs9yOVbW8XNOcxcvIbS901Pn20HgKDgLe9R0KA/640?wx_fmt=png" data-type="png" data-w="1409" title="" style="margin-right: auto;margin-left: auto;height: 254px;font-size: inherit;color: inherit;line-height: inherit;display: block;width: 400px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJvkS3JDibpeiaA9PbNHKs9yOVbW8XNOcxcvIbS901Pn20HgKDgLe9R0KA/640?wx_fmt=png"> 
 </figure> 
 <p style="margin-top: 15px;"><strong><span style="font-size: 15px;">应用层：</span></strong><span style="font-size: 15px;">上层Android应用接入层。</span></p> 
 <p><strong><span style="font-size: 15px;">规范层（API）：</span></strong><span style="font-size: 15px;">允许用户使用声明式的API（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">注解</span><span style="font-size: 15px;">）来构建符合Flexbox规范的布局。</span></p> 
 <p><strong><span style="font-size: 15px;">布局层：</span></strong><span style="font-size: 15px;">Litho使用可挂载组件、布局组件和Flexbox组件来构建布局，其中可挂载组件和布局组件允许用户使用规范来定义，各个组件的具体用法下面的组件规范中会详细介绍。在Litho中每一个组件都是一个独立的功能模块。Litho的组件和</span><a href="https://reactjs.org/" data-linktype="2" style="text-decoration: underline;font-size: 15px;">React</a><span style="font-size: 15px;">的组件相类似，也具有属性和状态的概念，通过状态的变更来控制组件的展示样式。</span></p> 
 <p><strong><span style="font-size: 15px;">布局测量：</span></strong><span style="font-size: 15px;">Litho使用</span><a href="https://yogalayout.com/" data-linktype="2" style="text-decoration: underline;font-size: 15px;">Yoga</a><span style="font-size: 15px;">来完成组件布局的异步或同步（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">可根据场景定制</span><span style="font-size: 15px;">）测量和计算，实现了布局的扁平化。</span></p> 
 <p><strong><span style="font-size: 15px;">布局渲染：</span></strong><span style="font-size: 15px;">Litho不仅支持使用View来渲染视图，还可以使用更轻量的Drawable来渲染视图。Litho实现了大量使用Drawable来渲染的基础组件，可以进一步拍平布局。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">除了上面提到的扁平化布局，Litho还实现了布局的细粒度复用和异步计算布局的能力，对于这些功能的实现在Litho的特性及原理剖析中详细介绍。下面先介绍一下大家比较关心的Litho使用方法。</span></p> 
 <h2 style="margin-bottom: 15px;"><span style="color: rgb(37, 183, 167);font-size: 20px;"><strong>2. Litho的使用</strong></span></h2> 
 <p><span style="font-size: 15px;">Litho的使用方式相比于传统的Android来说有些另类，它抛弃了通过XML定义布局的方式，采用声明式的组件在Java中构建布局。</span></p> 
 <h3 style="margin-top: 15px;margin-bottom: 15px;"><span style="font-size: 18px;"><strong>2.1 Litho和原生Android在使用上的区别</strong></span></h3> 
 <p style="margin-bottom: 15px;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">Android传统布局</strong>：首先在资源文件res/layout目录下定义布局文件xx.xml，然后在Activity或Fragment中引用布局文件生成视图，示例如下：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.2703125" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJhKmwNppnsE1QrPQu8mnfBvRvadLrXby3qxrVoFTCKKwOHyzO0HefXg/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJhKmwNppnsE1QrPQu8mnfBvRvadLrXby3qxrVoFTCKKwOHyzO0HefXg/640?wx_fmt=jpeg"></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.2390625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJmA5IZGTsBeflZYBTbVA5mrHCMjP1O0oib02834lN2MULY3FLaiaZD6ZA/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJmA5IZGTsBeflZYBTbVA5mrHCMjP1O0oib02834lN2MULY3FLaiaZD6ZA/640?wx_fmt=jpeg"></p> 
 <h3 style="margin-top: 15px;margin-bottom: 15px;"><span style="font-size: 18px;"><strong>2.2 Litho自定义视图</strong></span></h3> 
 <p><span style="font-size: 15px;">Litho中的视图单元叫做Component，可以直观的翻译为“组件”，它的设计理念来自于React组件化的思想。每个组件持有描述一个视图单元所必须的属性和状态，用于视图布局的计算工作。视图最终的绘制工作是由组件指定的绘制单元（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">View或者Drawable</span><span style="font-size: 15px;">）来完成的。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">Litho组件的创建方式也和原生View的创建方式有着很大的区别。Litho使用注解定义了一系列的规范，我们需要使用Litho的注解来定义自己的组件生成规则，最终由Litho在编译期自动编译生成真正的组件。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 16px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">2.2.1 组件规范</strong></span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">Litho提供了两种类型的组件规范，分别是Layout Spec规范和Mount Spec规范。下面分别介绍两种规范的使用方式：</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">Layout Spec规范</strong>：用于生成布局类型组件的规范，布局组件在逻辑上等同于Android中的ViewGroup，用于组织其他组件构成一个布局。它要求我们必须使用@LayoutSpec注解来注明，并实现一个标注了@OnCreateLayout注解的方法。示例如下：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.48359375" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJ8arC3DQvuPPhcXBjC9t9Zsgl8XQmlEFMFz3qLFfP42txxaMRia3Iic3g/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJ8arC3DQvuPPhcXBjC9t9Zsgl8XQmlEFMFz3qLFfP42txxaMRia3Iic3g/640?wx_fmt=jpeg"></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">最终Litho会在编译时生成一个名为HelloComponent的组件。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.71328125" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJI2yg0zzfiahc41HW2fm9ZoACx7pJBeQtJod5Vic31DicD4ciaBvzkFQapQ/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJI2yg0zzfiahc41HW2fm9ZoACx7pJBeQtJod5Vic31DicD4ciaBvzkFQapQ/640?wx_fmt=jpeg"></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.2203125" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJPnnKLaPtgA1dVVcGqx1ibhN26KrDRKHktHSuHs04WJnrILA3iavETpbw/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJPnnKLaPtgA1dVVcGqx1ibhN26KrDRKHktHSuHs04WJnrILA3iavETpbw/640?wx_fmt=jpeg"></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">Mount Spec规范</strong>：用来生成可挂载类型组件的规范，用来生成渲染具体View或者Drawable的组件。同样，它必须使用@MountSpec注解来标注，并至少实现一个标注了@onCreateMountContent的方法。Mount Spec相比于Layout Spec更复杂一些，它拥有自己的生命周期：</span></p> 
 <ul class=" list-paddingleft-2" style=""> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">@OnPrepare，准备阶段，进行一些初始化操作。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">@OnMeasure，负责布局的计算。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">@OnBoundsDefined，在布局计算完成后挂载视图前做一些操作。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">@OnCreateMountContent，创建需要挂载的视图。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">@OnMount，挂载视图，完成布局相关的设置。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">@OnBind，绑定视图，完成数据和视图的绑定。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">@OnUnBind，解绑视图，主要用于重置视图的数据相关的属性，防止出现复用问题。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">@OnUnmount，卸载视图，主要用于重置视图的布局相关的属性，防止出现复用问题。</span></p></li> 
 </ul> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <img class="" data-croporisrc="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJEo3BNm82LxTl2Cibv1P3ibb0RyOdClu60IMN6q4kcI65GyPbQMZvCnOQ/640?wx_fmt=png" data-cropx1="112.2077922077922" data-cropx2="955.7699443413728" data-cropy1="0" data-cropy2="981.8181818181818" data-ratio="1.1648873072360617" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVPU1Kq4qv6QbCaJrKsbGWWvckklmBfomfBfS4uPNm7Tycva6TrPXIh5RoSXyZpkSJ5aZIGjfgTVg/640?wx_fmt=jpeg" data-type="jpeg" data-w="843" style="margin-right: auto;margin-left: auto;font-size: inherit;color: inherit;line-height: inherit;display: block;width: 421px;height: 490px;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVPU1Kq4qv6QbCaJrKsbGWWvckklmBfomfBfS4uPNm7Tycva6TrPXIh5RoSXyZpkSJ5aZIGjfgTVg/640?wx_fmt=jpeg"> 
 </figure> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">除了上述两种组件类型，Litho中还有一种特殊的组件——Layout，它不能使用规范来生成。Layout是Litho中的容器组件，类似于Android中的ViewGroup，但是只能使用Flexbox的规范。它可以包含子组件节点，是Litho各组件连接的纽带。Layout组件只是Yoga在Litho中的代理，组件的所有布局相关的属性都会直接设置给Yoga，并由Yoga完成布局的计算。Litho实现了两个Layout组件Row和Column，分别对应Flexbox中的行和列。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 16px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">2.2.2 Litho的属性</strong></span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">在Litho中属性分为两种，不可变属性称为Props，可变属性称为State，下面分别介绍一下两种属性。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">Props属性</strong>：组件中使用@Prop注解标注的参数集合，具有单向性和不可变性。下面通过一个简单的例子了解一下如何在组件中定义和使用Props属性：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.50234375" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJjlp9u8C5MPV6fXic6VsnApJdH8esf3OHW5H1dlHWZCDCWWEu9jiag6eA/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJjlp9u8C5MPV6fXic6VsnApJdH8esf3OHW5H1dlHWZCDCWWEu9jiag6eA/640?wx_fmt=jpeg"></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">在上面的代码中，共使用了三次Prop注解，分别标注prop1和prop2两个变量，即定义了prop1和prop2两个属性。Litho会在自动编译生成的MyComponent类的Builder类中生成这两个属性的同名方法。按照如下代码，便可以去使用上面定义的属性：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.11640625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJz3LbewEd2KHxeWariafCzzNPkyjYnibUFIw7FODHOM6suSQTfV1QXjQg/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJz3LbewEd2KHxeWariafCzzNPkyjYnibUFIw7FODHOM6suSQTfV1QXjQg/640?wx_fmt=jpeg"></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">State属性</strong>：意为“状态”属性，State属性虽然可变，但是其变化由组件内部控制，例如：输入框、Checkbox等都是由组件内部去感知用户行为，并更新组件的State属性。所以一个组件一旦创建，我们便无法通过任何外部设置去更改它的属性。组件的State属性虽然不允许像Props属性那样去显式设置，但是我们可以定义一个单独的Props属性来当做某个State属性的初始值。</span></p> 
 <h2 style="margin-bottom: 15px;"><span style="color: rgb(37, 183, 167);font-size: 20px;"><strong>3. Litho的特性及原理剖析</strong></span></h2> 
 <p><span style="font-size: 15px;">Litho官网首页通过4个段落重点介绍了Litho的4个特性。</span></p> 
 <h3 style="margin-top: 15px;margin-bottom: 15px;"><span style="font-size: 18px;"><strong>3.1 声明式组件</strong></span></h3> 
 <p><span style="font-size: 15px;">Litho采用声明式的API来定义UI组件，组件通过一组不可变的属性来描述UI。这种组件化的思想灵感来源于</span><a href="https://reactjs.org/" data-linktype="2" style="color: rgb(30, 107, 184);text-decoration: underline;line-height: inherit;font-size: 15px;">React</a><span style="font-size: 15px;">，关于声明式组件的用法上面已经详细介绍过了。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">传统Android布局因为UI与逻辑分离，所以开发工具都有强大的预览功能，方便开发者调整布局。而Litho采用</span><a href="https://reactjs.org/" data-linktype="2" style="color: rgb(30, 107, 184);text-decoration: underline;line-height: inherit;font-size: 15px;">React</a><span style="font-size: 15px;">组件化的思想，通过组件连接了逻辑与布局UI，虽然Litho也提供了对</span><a href="http://facebook.github.io/stetho/" data-linktype="2" style="color: rgb(30, 107, 184);text-decoration: underline;line-height: inherit;font-size: 15px;">Stetho</a><span style="font-size: 15px;">的支持，借助于Chrome开发者工具对界面进行调试，不过使用起来并没有那么方便。</span></p> 
 <h3 style="margin-bottom: 15px;"><span style="font-size: 18px;"><strong>3.2 异步布局</strong></span></h3> 
 <p><span style="font-size: 15px;">Android系统在绘制时为了防止页面错乱，页面所有View的测量（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">Measure</span><span style="font-size: 15px;color: rgb(0, 0, 0);">）</span><span style="font-size: 15px;">、布局（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">Layout</span><span style="font-size: 15px;">）以及绘制（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">Draw</span><span style="font-size: 15px;">）都是在UI线程中完成的。当页面UI非常复杂、视图层级较深时，难免Measure和Layout的时间会过长，从而导致页面渲染时候丢帧出现卡顿情况。Litho为解决该问题，提出了异步布局的思想，利用CPU的闲置时间提前在异步线程中完成Measure和Layout的过程，仅在UI线程中完成绘制工作。当然，Litho只是提供了异步布局的能力，它主要使用在RecyclerView等可以提前知道下一个视图长什么样子的场景。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 16px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">3.2.1 异步布局原理剖析</strong></span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">针对RecyclerView等滑动列表，由于可以提前知道接下来要展示的一个甚至多个条目的视图样式，所以只要提前创建好下一个或多个条目的视图，就可以提前完成视图的布局工作。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">那么Android原生为什么不支持异步布局呢？主要有以下两个原因：</span></p> 
 <ul class=" list-paddingleft-2" style=""> 
  <li><p><span style="font-size: 14px;">View的属性是可变的，只要属性发生变化就可能导致布局变化，因此需要重新计算布局，那么提前计算布局的意义就不大了。而Litho组件的属性是不可变的，所以对于一个组件来说，它的布局计算结果是唯一且不变的。</span></p></li> 
  <li><p><span style="font-size: 14px;">提前异步布局就意味着要提前创建好接下来要用到的一个或者多个条目的视图，而Android原生的View作为视图单元，不仅包含一个视图的所有属性，而且还负责视图的绘制工作。如果要在绘制前提前去计算布局，就需要预先去持有大量未展示的View实例，大大增加内存占用。反观Litho的组件则没有这个问题，Litho的组件只是视图属性的一个集合，仅负责计算布局，绘制工作由指定的绘制单元来完成，相比与传统的View显然Litho的组件要轻量的多。所以在Litho中，提前创建好接下来要用到的多个条目的组件，并不会带来性能问题，甚至还可以直接把组件当成滑动列表的数据源。如下图所示：</span></p></li> 
 </ul> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <img class="" data-croporisrc="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJwXVhNyEjxrC5RkecXqblHok44rImTWBp7Z4XkjFqcwKdXwcMOcVuQQ/640?wx_fmt=png" data-cropx1="50.09276437847866" data-cropx2="1029.9072356215213" data-cropy1="0" data-cropy2="454.84230055658634" data-ratio="0.4647599591419816" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVPU1Kq4qv6QbCaJrKsbGWW6mZPchvaOG0SCSX7Db5YAyAwV5mpYJa6vibWFcG7fhPkrmam2ZwUialg/640?wx_fmt=jpeg" data-type="jpeg" data-w="979" style="margin-right: auto;margin-left: auto;height: 227px;font-size: inherit;color: inherit;line-height: inherit;display: block;width: 489px;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVPU1Kq4qv6QbCaJrKsbGWW6mZPchvaOG0SCSX7Db5YAyAwV5mpYJa6vibWFcG7fhPkrmam2ZwUialg/640?wx_fmt=jpeg"> 
 </figure> 
 <h3 style="margin-bottom: 15px;"><strong><span style="font-size: 18px;">3.3 扁平化的视图</span></strong></h3> 
 <p><span style="font-size: 15px;">使用Litho布局，我们可以得到一个极致扁平的视图效果。它可以减少渲染时的递归调用，加快渲染速度。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">下面是同一个视图在Android和Litho实现下的视图层级效果对比。可以看到，同样的样式，使用Litho实现的布局要比使用Android原生实现的布局更加扁平。</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.48216833095577744" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJyjw4OIIbVcJvEHhDwOymnzOXfXhTyFohChODYw9H2zy64S7YPg7unw/640?wx_fmt=png" data-type="png" data-w="1402" title="" style="margin-right: auto;margin-left: auto;height: 223px;font-size: inherit;color: inherit;line-height: inherit;display: block;width: 463px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJyjw4OIIbVcJvEHhDwOymnzOXfXhTyFohChODYw9H2zy64S7YPg7unw/640?wx_fmt=png"> 
 </figure> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 16px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">3.3.1 扁平化视图原理剖析</strong></span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">Litho使用Flexbox来创建布局，最终生成带有层级结构的组件树。然后Litho对布局层级进行了两次优化。</span></p> 
 <ul class=" list-paddingleft-2" style=""> 
  <li><p><span style="font-size: 14px;">使用了</span><a href="https://yogalayout.com/" data-linktype="2" style="text-decoration: underline;font-size: 14px;">Yoga</a><span style="font-size: 14px;">来进行布局计算，Yoga会将Flexbox的相对布局转成绝对布局。经过Yoga处理后的布局没有了原来的布局层级，变成了只有一层。虽然不能解决过度绘制的问题，但是可以有效地减少渲染时的递归调用。</span></p></li> 
  <li><p><span style="font-size: 14px;">前面介绍过Litho的视图渲染由绘制单元来完成，绘制单元可以是View或者更加轻量的Drawable，Litho自己实现了一系列挂载Drawable的基本视图组件。通过使用Drawable可以减少内存占用，同时相比于View，Android无法检查出Drawable的视图层级，这样可以使视图效果看起来更加扁平。</span></p></li> 
 </ul> 
 <p><span style="font-size: 14px;"></span></p> 
 <p><span style="font-size: 15px;">原理如下图所示，Litho会先把组件树拍平成没有层级的列表，然后使用Drawable来绘制对应的视图单元。</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.32645089285714285" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJKNbib3GpzXWTGfjQxqJdNum11lTMzG1ux1FLbhiawbEK1JLEouwxLZOQ/640?wx_fmt=png" data-type="png" data-w="1792" title="" style="margin-right: auto;margin-left: auto;font-size: inherit;color: inherit;line-height: inherit;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJKNbib3GpzXWTGfjQxqJdNum11lTMzG1ux1FLbhiawbEK1JLEouwxLZOQ/640?wx_fmt=png"> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 15px;"><span style="font-size: 15px;">Litho使用Drawable代替View能带来多少好处呢？Drawable和View的区别在于前者不能和用户交互，只能展示，因此Drawable不会像View那样持有很多变量和引用，所以Drawable比View从内存上看要轻量很多。举个例子：50个同样展示“Hello world”的TextView和TextDrawable在内存占比上，前者几乎是后者的8倍。对比图如下，Shallow Size表示对象自身占用的内存大小。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.2897930049964311" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXSfff7GYE4gG7EMIvpwibMGvTe4R14sQDf9jus5Y7ibXqhheNKrsHlCib8TGL031CRT3uDC7n1clbEA/640?wx_fmt=png" data-type="png" data-w="1401" style="width: 453px;height: 131px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXSfff7GYE4gG7EMIvpwibMGvTe4R14sQDf9jus5Y7ibXqhheNKrsHlCib8TGL031CRT3uDC7n1clbEA/640?wx_fmt=png"></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 16px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">3.3.2 绘制单元的降级策略</strong></span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">由于Drawable不具有交互能力，所以对于使用Drawable无法实现的交互场景，Litho会自动降级成View。主要有以下几种场景：</span></p> 
 <ul class=" list-paddingleft-2" style=""> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">有监听点击事件。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">限制子视图绘出父布局。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">有监听焦点变化。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">有设置Tag。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">有监听触摸事件。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 14px;">有光影效果。</span></p></li> 
 </ul> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">对于以上场景的使用请仔细考虑，过多的使用会导致Litho的层级优化效果变差。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 16px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">3.3.3 对比Android的约束布局</strong></span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">为了解决布局嵌套问题，Android推出了约束布局（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">ConstraintLayout</span><span style="font-size: 15px;">），使用约束布局也可以达到扁平化视图的目的，那么使用Litho的好处是什么呢？</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">Litho可以更好地实现复杂布局。约束布局虽然可以实现扁平效果，但是它使用了大量的约束来固定视图的位置。随着布局复杂程度的增加，约束条件变得越来越多，可读性也变得越来越差。而Litho则是对Flexbox布局进行的扁平化处理，所以实际使用的还是Flexbox布局，对于复杂的布局Flexbox布局可读性更高。</span></p> 
 <h3 style="margin-bottom: 15px;"><strong><span style="font-size: 18px;">3.4 细粒度的复用</span></strong></h3> 
 <p><span style="font-size: 15px;">Litho中的所有组件都可以被回收，并在任何位置进行复用。这种细粒度的复用方式可以极大地提高内存使用率，尤其适用于复杂滑动列表，内存优化非常明显。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 16px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">3.4.1 原生RecyclerView复用原理剖析</strong></span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">原生的RecyclerView视图按模板类型进行存储并复用，也就是说模板类型越多，所需存储的模板种类也就越多，导致内存占用越来越大。原理如下图。滑出屏幕的itemType1和itemType2都会在Recycler缓存池保存，等待后面滑进屏幕的条目的复用。</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <img class="" data-croporisrc="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJksdiadUzQtnq1ArCB3FuKWcHgtznyPhicj9LMDwJxtmOUPhRqduUMAKw/640?wx_fmt=png" data-cropx1="162.30055658627086" data-cropx2="925.7142857142857" data-cropy1="0" data-cropy2="492.9128014842301" data-ratio="0.6448230668414154" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVPU1Kq4qv6QbCaJrKsbGWWnE7Y7uiamibp0gDLedd20EyjqVpiczwhpMZLdUszzRuUwQql9RAv9ibiasA/640?wx_fmt=jpeg" data-type="jpeg" data-w="763" style="margin-right: auto;margin-left: auto;font-size: inherit;color: inherit;line-height: inherit;display: block;width: 381px;height: 246px;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVPU1Kq4qv6QbCaJrKsbGWWnE7Y7uiamibp0gDLedd20EyjqVpiczwhpMZLdUszzRuUwQql9RAv9ibiasA/640?wx_fmt=jpeg"> 
 </figure> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 16px;"><strong>3.4.2 细粒度复用优化内存原理剖析</strong></span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">在Litho中，item在回收前，会把LithoView中挂载的各个绘制单元拆分出来（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">解绑</span><span style="font-size: 15px;">），由Litho自己的缓存池去分类回收，在展示前由LithoView按照组件树的样式组装（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">挂载</span><span style="font-size: 15px;">）各个绘制单元，这样就达到了细粒度复用的目的。原理如下图。滑出屏幕的itemType1会被拆分成一个个的视图单元。LithoView容器由Recycler缓存池回收，其他视图单元由Litho的缓存池分类回收。</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.4644779332615716" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJJ5K1ydTAUcrHFIGiaVJLOPo3LrDSfsI1Sbo0PUX36zvE9bBfqkNibHhA/640?wx_fmt=png" data-type="png" data-w="1858" title="" style="margin-right: auto;margin-left: auto;font-size: inherit;color: inherit;line-height: inherit;display: block;width: 539px;height: 251px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJJ5K1ydTAUcrHFIGiaVJLOPo3LrDSfsI1Sbo0PUX36zvE9bBfqkNibHhA/640?wx_fmt=png"> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 15px;"><span style="font-size: 15px;">使用细粒度复用的RecyclerView的缓存池不再需要区分模板类型来缓存大量的视图模板，只需要缓存LithoView容器。细粒度回收的视图单元数量要远远小于原来缓存在各个视图模板中的视图单元数量。</span></p> 
 <h2 style="margin-top: 15px;margin-bottom: 15px;"><span style="color: rgb(37, 183, 167);font-size: 20px;"><strong>4. 实践</strong></span></h2> 
 <p><span style="font-size: 15px;">美团对Litho进行了二次开发，在美团的MTFlexbox动态化实现方案（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">简称动态布局</span><span style="font-size: 15px;">）中把Litho作为底层UI渲染引擎来使用。通过动态布局的预览工具，为Litho提供实时预览能力，同时可以有效发挥Litho的性能优化效果。</span></p> 
 <p style="margin-top: 1.5em;margin-bottom: 1.5em;font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">目前Litho+动态布局的实现方案已经应用在了美团App中，给美团App带来了不错的性能提升。后续，我们还会另外写一篇文章详细介绍Litho+动态布局在美团性能优化的实践方案。</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.45032451323015477" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJhJE5evo5urzXK6V2rcic3OMFrq9tF8AZ7TiadQrEe4j7f6bibB8GdQ3XA/640?wx_fmt=png" data-type="png" data-w="2003" title="使用Litho+动态布局实现的部分卡片" style="margin-right: auto;margin-left: auto;height: 220px;font-size: inherit;color: inherit;line-height: inherit;display: block;width: 488px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJhJE5evo5urzXK6V2rcic3OMFrq9tF8AZ7TiadQrEe4j7f6bibB8GdQ3XA/640?wx_fmt=png"> 
  <p style="margin-top: 10px;line-height: inherit;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;margin-bottom: 15px;"><span style="font-size: 13px;">使用Litho+动态布局实现的部分卡片</span></p> 
 </figure> 
 <h3 style="margin-bottom: 15px;"><span style="font-size: 18px;"><strong>4.1 内存数据</strong></span></h3> 
 <p><span style="font-size: 15px;">由于Litho中使用了大量Drawable替换View，并且实现了视图单元的细粒度复用，因此复杂列表滑动时内存优化比较明显。美团首页内存占用随滑动页数变化走势图如下。随着一页一页地滑动，内存优化了30M以上。（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">数据采集自Vivo x20手机内存占用情况</span><span style="font-size: 15px;">）</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.780040733197556" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJU7S96ONgsGK4RGv1VhezzTpc1YStREm0X53rnxS0ruW94OSqspwNiaQ/640?wx_fmt=jpeg" data-type="jpeg" data-w="491" title="" style="margin-right: auto;margin-left: auto;height: 254px;font-size: inherit;color: inherit;line-height: inherit;display: block;width: 325px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJU7S96ONgsGK4RGv1VhezzTpc1YStREm0X53rnxS0ruW94OSqspwNiaQ/640?wx_fmt=jpeg"> 
 </figure> 
 <h3 style="margin-bottom: 15px;"><span style="font-size: 18px;"><strong>4.2 FPS数据</strong></span></h3> 
 <p><span style="font-size: 15px;">FPS的提升主要得益于Litho的异步布局能力，提前计算布局可以减少滑动时的帧率波动，所以滑动过程较平稳，不会有高低起伏的卡顿感。（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">数据采集自魅蓝2手机一段时间内连续fps的波动情况</span><span style="font-size: 15px;">）</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.5251168224299065" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJlC3ibibjSPt5njQIjoCTvvSKNkwUxqzUuwqRxTiciaL2I6Iibtu7mXT8mKg/640?wx_fmt=png" data-type="png" data-w="1712" title="" style="margin-right: auto;margin-left: auto;height: 222px;font-size: inherit;color: inherit;line-height: inherit;display: block;width: 423px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVvEhceg7x1mqJicwoQMWjDJlC3ibibjSPt5njQIjoCTvvSKNkwUxqzUuwqRxTiciaL2I6Iibtu7mXT8mKg/640?wx_fmt=png"> 
 </figure> 
 <h2 style="margin-bottom: 15px;"><span style="font-size: 20px;"><strong><span style="color: rgb(37, 183, 167);">5. 总结</span></strong></span></h2> 
 <p><span style="font-size: 15px;">Litho相对于传统Android是颠覆式的，它采用了React的思路，使用声明式的API来编写UI。相比于传统Android，确实在性能优化上有很大的进步，但是如果完全使用Litho开发一款应用，需要自己实现很多组件，而Litho的组件需要在编译时生成，实时预览方面也有所欠缺。相对于直接使用Litho的高成本，把Litho封装成Flexbox布局的底层渲染引擎是个不错的选择。</span></p> 
 <h2 style="margin-top: 15px;margin-bottom: 15px;"><span style="font-size: 18px;"><strong><span style="color: rgb(37, 183, 167);">6. 参考资料</span></strong></span></h2> 
 <ol class=" list-paddingleft-2" style=""> 
  <li><p><a href="https://fblitho.com/" data-linktype="2" style="color: rgb(30, 107, 184);text-decoration: underline;line-height: inherit;font-size: 13px;">Litho官网</a></p></li> 
  <li><p><a href="https://juejin.im/post/5922359944d904006cd0355a" data-linktype="2" style="color: rgb(30, 107, 184);text-decoration: underline;line-height: inherit;font-size: 13px;">说一说 Facebook 开源的 Litho</a></p></li> 
  <li><p><a href="https://reactjs.org/" data-linktype="2" style="color: rgb(30, 107, 184);text-decoration: underline;line-height: inherit;font-size: 13px;">React官网</a></p></li> 
  <li><p><a href="https://yogalayout.com/" data-linktype="2" style="color: rgb(30, 107, 184);text-decoration: underline;line-height: inherit;font-size: 13px;">Yoga官网</a></p></li> 
 </ol> 
 <h2 style="margin-top: 15px;margin-bottom: 15px;"><span style="color: rgb(37, 183, 167);font-size: 18px;"><strong>7. 作者简介</strong></span></h2> 
 <p><strong><span style="color: inherit;line-height: inherit;font-size: 15px;">少宽，</span></strong><span style="color: inherit;line-height: inherit;font-size: 15px;">美团Android开发工程师，2015年加入美团，负责美团平台终端业务研发工作。</span></p> 
 <p style="margin-bottom: 15px;"><strong><span style="color: inherit;line-height: inherit;font-size: 15px;">张颖，</span></strong><span style="color: inherit;line-height: inherit;font-size: 15px;">美团Android开发工程师，2017年加入美团，负责美团平台终端业务研发工作。</span></p> 
 <p style="margin-bottom: 15px;"><span style="line-height: inherit;font-size: 15px;"><span style="font-size: 15px;letter-spacing: 0.544px;text-align: left;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;white-space: pre-wrap;background-color: rgb(255, 255, 255);"><span style="color: rgb(136, 136, 136);letter-spacing: 0.544px;">欢迎加入</span><strong style="color: inherit;letter-spacing: 0.544px;"><span style="color: rgb(0, 0, 0);">美团前端技术交流群</span></strong><span style="color: rgb(136, 136, 136);letter-spacing: 0.544px;">，跟作者零距离交流。进群方式：请加美美同学</span><span style="color: rgb(136, 136, 136);letter-spacing: 0px;">微信（微信号：<strong>MTDPtech02</strong><strong>）</strong>，回复：</span><span style="letter-spacing: 0px;"><span style="color:#000000;"><strong>Litho</strong></span></span></span><span style="color: rgb(136, 136, 136);font-size: 15px;text-align: left;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;white-space: pre-wrap;background-color: rgb(255, 255, 255);">，美美会自动拉你进群。</span></span></p> 
</section> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;text-align: center;"><span style="font-size: 15px;color: rgb(136, 136, 136);">----------&nbsp; END&nbsp; ----------</span></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;"><span style="font-size: 16px;"><strong><span style="color: rgb(49, 188, 173);">也许你还想看</span></strong></span></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;"><br></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651749883&amp;idx=4&amp;sn=ac65f1f3dde234f8c54404c64899db74&amp;chksm=bd12a4b68a652da09d2fb073c1b4a5799188417911a678ab92f0a9e67556607871cdc6d8d9f4&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" style="font-size: 14px;text-decoration: underline;" data-linktype="2"><span style="font-size: 14px;">Android组件化方案及组件消息总线modular-event实战</span></a><br></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748649&amp;idx=1&amp;sn=0a2724141fb8b2a16ad88c614db9209d&amp;chksm=bd12a0648a652972649fd3defec48bd205b26b6ab4f5be107895ebde9533677c3cabe704cc3e&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" style="font-size: 14px;text-decoration: underline;" data-linktype="2"><span style="font-size: 14px;">WMRouter：美团外卖Android开源路由框架</span></a><br></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651747704&amp;idx=1&amp;sn=93c4a5c76b78bc998fa0dab1fdd4547d&amp;chksm=bd12ac358a652523fdf541a5e04d7aad9fb849e5c460aa7dd2c5cbb4c821ccaedde0be147b7c&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" style="font-size: 14px;text-decoration: underline;" data-linktype="2"><span style="font-size: 14px;">美团外卖Android平台化架构演进实践</span></a><br></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;"><br></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;text-align: center;"><img class="" data-copyright="0" data-ratio="0.44533333333333336" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png" data-type="png" data-w="1875" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png"></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
