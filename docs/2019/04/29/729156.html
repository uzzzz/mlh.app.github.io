<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【基本功】深入剖析Swift性能优化 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【基本功】深入剖析Swift性能优化" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="总第297篇 2018年 第89篇 美美今天请来了我们技术团队很厉害的iOS女神亚男小姐姐深度剖析Swift，她特别讲解了如何才能开发出高性能的Swift程序。希望对你有所帮助哦～Enjoy Reading！ 简介 2014年，苹果公司在WWDC上发布Swift这一新的编程语言。经过几年的发展，Swift已经成为iOS开发语言的“中流砥柱”，Swift提供了非常灵活的高级别特性，例如协议、闭包、泛型等，并且Swift还进一步开发了强大的SIL（Swift Intermediate Language）用于对编译器进行优化，使得Swift相比Objective-C运行更快性能更优，Swift内部如何实现性能的优化，我们本文就进行一下解读，希望能对大家有所启发和帮助。 针对Swift性能提升这一问题，我们可以从概念上拆分为两个部分： 编译器：Swift编译器进行的性能优化，从阶段分为编译期和运行期，内容分为时间优化和空间优化。 开发者：通过使用合适的数据结构和关键字，帮助编译器获取更多信息，进行优化。 下面我们将从这两个角度切入，对Swift性能优化进行分析。通过了解编译器对不同数据结构处理的内部实现，来选择最合适的算法机制，并利用编译器的优化特性，编写高性能的程序。 理解Swift的性能 理解Swift的性能，首先要清楚Swift的数据结构，组件关系和编译运行方式。 数据结构Swift的数据结构可以大体拆分为：Class，Struct，Enum。 组件关系组件关系可以分为：inheritance，protocols，generics。 方法分派方式方法分派方式可以分为Static dispatch和Dynamic dispatch。 要在开发中提高Swift性能，需要开发者去了解这几种数据结构和组件关系以及它们的内部实现，从而通过选择最合适的抽象机制来提升性能。 首先我们对于性能标准进行一个概念陈述，性能标准涵盖三个标准： Allocation Reference counting Method dispatch 接下来，我们会分别对这几个指标进行说明。 Allocation 内存分配可以分为堆区栈区，在栈的内存分配速度要高于堆，结构体和类在堆栈分配是不同的。 Stack 基本数据类型和结构体默认在栈区，栈区内存是连续的，通过出栈入栈进行分配和销毁，速度很快，高于堆区。 我们通过一些例子进行说明： //示例&nbsp;1//&nbsp;Allocation//&nbsp;Structstruct&nbsp;Point&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}let&nbsp;point1&nbsp;=&nbsp;Point(x:0,&nbsp;y:0)&nbsp;//进行point1初始化，开辟栈内存var&nbsp;point2&nbsp;=&nbsp;point1&nbsp;//初始化point2，拷贝point1内容，开辟新内存point2.x&nbsp;=&nbsp;5&nbsp;//对point2的操作不会影响point1//&nbsp;use&nbsp;`point1`//&nbsp;use&nbsp;`point2` 以上结构体的内存是在栈区分配的，内部的变量也是内联在栈区。将point1赋值给point2实际操作是在栈区进行了一份拷贝，产生了新的内存消耗point2，这使得point1和point2是完全独立的两个实例，它们之间的操作互不影响。在使用point1和point2之后，会进行销毁。 Heap 高级的数据结构，比如类，分配在堆区。初始化时查找没有使用的内存块，销毁时再从内存块中清除。因为堆区可能存在多线程的操作问题，为了保证线程安全，需要进行加锁操作，因此也是一种性能消耗。 //&nbsp;Allocation//&nbsp;Classclass&nbsp;Point&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}let&nbsp;point1&nbsp;=&nbsp;Point(x:0,&nbsp;y:0)&nbsp;//在堆区分配内存，栈区只是存储地址指针let&nbsp;point2&nbsp;=&nbsp;point1&nbsp;//不产生新的实例，而是对point2增加对堆区内存引用的指针point2.x&nbsp;=&nbsp;5&nbsp;//因为point1和point2是一个实例，所以point1的值也会被修改//&nbsp;use&nbsp;`point1`//&nbsp;use&nbsp;`point2` 以上我们初始化了一个Class类型，在栈区分配一块内存，但是和结构体直接在栈内存储数值不同，我们只在栈区存储了对象的指针，指针指向的对象的内存是分配在堆区的。需要注意的是，为了管理对象内存，在堆区初始化时，除了分配属性内存（这里是Double类型的x，y），还会有额外的两个字段，分别是type和refCount，这个包含了type，refCount和实际属性的结构被称为blue box。 内存分配总结 从初始化角度，Class相比Struct需要在堆区分配内存，进行内存管理，使用了指针，有更强大的特性，但是性能较低。 优化方式： 对于频繁操作（比如通信软件的内容气泡展示），尽量使用Struct替代Class，因为栈内存分配更快，更安全，操作更快。 Reference counting Swift通过引用计数管理堆对象内存，当引用计数为0时，Swift确认没有对象再引用该内存，所以将内存释放。 对于引用计数的管理是一个非常高频的间接操作，并且需要考虑线程安全，使得引用计数的操作需要较高的性能消耗。 对于基本数据类型的Struct来说，没有堆内存分配和引用计数的管理，性能更高更安全，但是对于复杂的结构体，如： //&nbsp;Reference&nbsp;Counting//&nbsp;Struct&nbsp;containing&nbsp;referencesstruct&nbsp;Label&nbsp;{&nbsp;var&nbsp;text:String&nbsp;var&nbsp;font:UIFont&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}let&nbsp;label1&nbsp;=&nbsp;Label(text:&quot;Hi&quot;,&nbsp;font:font)&nbsp;&nbsp;//栈区包含了存储在堆区的指针let&nbsp;label2&nbsp;=&nbsp;label1&nbsp;//label2产生新的指针，和label1一样指向同样的string和font地址//&nbsp;use&nbsp;`label1`//&nbsp;use&nbsp;`label2` 这里看到，包含了引用的结构体相比Class，需要管理双倍的引用计数。每次将结构体作为参数传递给方法或者进行直接拷贝时，都会出现多份引用计数。下图可以比较直观的理解： 备注：包含引用类型的结构体出现Copy的处理方式 Class在拷贝时的处理方式： 引用计数总结 Class在堆区分配内存，需要使用引用计数器进行内存管理。 基本类型的Struct在栈区分配内存，无引用计数管理。 包含强类型的Struct通过指针管理在堆区的属性，对结构体的拷贝会创建新的栈内存，创建多份引用的指针，Class只会有一份。 优化方式 在使用结构体时： 通过使用精确类型，例如UUID替代String（UUID字节长度固定128字节，而不是String任意长度），这样就可以进行内存内联，在栈内存储UUID，我们知道，栈内存管理更快更安全，并且不需要引用计数。 Enum替代String，在栈内管理内存，无引用计数，并且从语法上对于开发者更友好。 Method Dispatch 我们之前在Static dispatch VS Dynamic dispatch中提到过，能够在编译期确定执行方法的方式叫做静态分派Static dispatch，无法在编译期确定，只能在运行时去确定执行方法的分派方式叫做动态分派Dynamic dispatch。 Static dispatch更快，而且静态分派可以进行内联等进一步的优化，使得执行更快速，性能更高。 但是对于多态的情况，我们不能在编译期确定最终的类型，这里就用到了Dynamic dispatch动态分派。动态分派的实现是，每种类型都会创建一张表，表内是一个包含了方法指针的数组。动态分派更灵活，但是因为有查表和跳转的操作，并且因为很多特点对于编译器来说并不明确，所以相当于block了编译器的一些后期优化。所以速度慢于Static dispatch。 下面看一段多态代码，以及分析实现方式： //引用语义实现的多态class&nbsp;Drawable&nbsp;{&nbsp;func&nbsp;draw()&nbsp;{}&nbsp;}class&nbsp;Point&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;override&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}class&nbsp;Line&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:Double&nbsp;override&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}var&nbsp;drawables:[Drawable]for&nbsp;d&nbsp;in&nbsp;drawables&nbsp;{&nbsp;d.draw（）} Method Dispatch总结 Class默认使用Dynamic dispatch，因为在编译期几乎每个环节的信息都无法确定，所以阻碍了编译器的优化，比如inline和whole module inline。 使用Static dispatch代替Dynamic dispatch提升性能 我们知道Static dispatch快于Dynamic dispatch，如何在开发中去尽可能使用Static dispatch。 inheritance constraints继承约束我们可以使用final关键字去修饰Class，以此生成的Final class，使用Static dispatch。 access control访问控制private关键字修饰，使得方法或属性只对当前类可见。编译器会对方法进行Static dispatch。 编译器可以通过whole module optimization检查继承关系，对某些没有标记final的类通过计算，如果能在编译期确定执行的方法，则使用Static dispatch。Struct默认使用Static dispatch。 Swift快于OC的一个关键是可以消解动态分派。 总结 Swift提供了更灵活的Struct，用以在内存、引用计数、方法分派等角度去进行性能的优化，在正确的时机选择正确的数据结构，可以使我们的代码性能更快更安全。 延伸 你可能会问Struct如何实现多态呢?答案是protocol oriented programming。 以上分析了影响性能的几个标准，那么不同的算法机制Class，Protocol Types和Generic code，它们在这三方面的表现如何，Protocol Type和Generic code分别是怎么实现的呢？我们带着这个问题看下去。 Protocol Type 这里我们会讨论Protocol Type如何存储和拷贝变量，以及方法分派是如何实现的。不通过继承或者引用语义的多态： protocol&nbsp;Drawable&nbsp;{&nbsp;func&nbsp;draw()&nbsp;}struct&nbsp;Point&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}struct&nbsp;Line&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}var&nbsp;drawables:[Drawable]&nbsp;//遵守了Drawable协议的类型集合，可能是point或者linefor&nbsp;d&nbsp;in&nbsp;drawables&nbsp;{&nbsp;d.draw（）} 以上通过Protocol Type实现多态，几个类之间没有继承关系，故不能按照惯例借助V-Table实现动态分派。 如果想了解Vtable和Witness table实现，可以进行点击查看，这里不做细节说明。因为Point和Line的尺寸不同，数组存储数据实现一致性存储，使用了Existential Container。查找正确的执行方法则使用了 Protoloc Witness Table。 Existential Container Existential Container是一种特殊的内存布局方式，用于管理遵守了相同协议的数据类型Protocol Type，这些数据类型因为不共享同一继承关系（这是V-Table实现的前提），并且内存空间尺寸不同，使用Existential Container进行管理，使其具有存储的一致性。 结构如下： 三个词大小的valueBuffer这里介绍一下valueBuffer结构，valueBuffer有三个词，每个词包含8个字节，存储的可能是值，也可能是对象的指针。对于small value（空间小于valueBuffer），直接存储在valueBuffer的地址内， inline valueBuffer，无额外堆内存初始化。当值的数量大于3个属性即large value，或者总尺寸超过valueBuffer的占位，就会在堆区开辟内存，将其存储在堆区，valueBuffer存储内存指针。 value witness table的引用因为Protocol Type的类型不同，内存空间，初始化方法等都不相同，为了对Protocol Type生命周期进行专项管理，用到了Value Witness Table。 protocol witness table的引用管理Protocol Type的方法分派。 内存分布如下： 1.&nbsp;payload_data_0&nbsp;=&nbsp;0x0000000000000004,2.&nbsp;payload_data_1&nbsp;=&nbsp;0x0000000000000000,3.&nbsp;payload_data_2&nbsp;=&nbsp;0x0000000000000000,4.&nbsp;instance_type&nbsp;=&nbsp;0x000000010d6dc408&nbsp;ExistentialContainers`type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metadata&nbsp;for&nbsp;ExistentialContainers.Car,5.&nbsp;protocol_witness_0&nbsp;=&nbsp;0x000000010d6dc1c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExistentialContainers&nbsp;protocol&nbsp;witness&nbsp;table&nbsp;for&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExistentialContainers.Car:ExistentialContainers.Drivable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;ExistentialContainers Protocol Witness Table（PWT） 为了实现Class多态也就是引用语义多态，需要V-Table来实现，但是V-Table的前提是具有同一个父类即共享相同的继承关系，但是对于Protocol Type来说，并不具备此特征，故为了支持Struct的多态，需要用到protocol oriented programming机制，也就是借助Protocol Witness Table来实现（细节可以点击Vtable和witness table实现，每个结构体会创造PWT表，内部包含指针，指向方法具体实现）。 Value Witness Table（VWT） 用于管理任意值的初始化、拷贝、销毁。 Value Witness Table的结构如上，是用于管理遵守了协议的Protocol Type实例的初始化，拷贝，内存消减和销毁的。 Value Witness Table在SIL中还可以拆分为%relative_vwtable和%absolute_vwtable，我们这里先不做展开。 Value Witness Table和Protocol Witness Table通过分工，去管理Protocol Type实例的内存管理（初始化，拷贝，销毁）和方法调用。 我们来借助具体的示例进行进一步了解： //&nbsp;Protocol&nbsp;Types//&nbsp;The&nbsp;Existential&nbsp;Container&nbsp;in&nbsp;actionfunc&nbsp;drawACopy(local&nbsp;：Drawable)&nbsp;{&nbsp;local.draw()}let&nbsp;val&nbsp;:Drawable&nbsp;=&nbsp;Point()drawACopy(val) 在Swift编译器中，通过Existential Container实现的伪代码如下： //&nbsp;Protocol&nbsp;Types//&nbsp;The&nbsp;Existential&nbsp;Container&nbsp;in&nbsp;actionfunc&nbsp;drawACopy(local&nbsp;:Drawable)&nbsp;{&nbsp;local.draw()}let&nbsp;val&nbsp;:Drawable&nbsp;=&nbsp;Point()drawACopy(val)//existential&nbsp;container的伪代码结构struct&nbsp;ExistContDrawable&nbsp;{&nbsp;var&nbsp;valueBuffer:(Int,&nbsp;Int,&nbsp;Int)&nbsp;var&nbsp;vwt:ValueWitnessTable&nbsp;var&nbsp;pwt:DrawableProtocolWitnessTable}//&nbsp;drawACopy方法生成的伪代码func&nbsp;drawACopy(val:ExistContDrawable)&nbsp;{&nbsp;//将existential&nbsp;container传入&nbsp;var&nbsp;local&nbsp;=&nbsp;ExistContDrawable()&nbsp;&nbsp;//初始化container&nbsp;let&nbsp;vwt&nbsp;=&nbsp;val.vwt&nbsp;//获取value&nbsp;witness&nbsp;table，用于管理生命周期&nbsp;let&nbsp;pwt&nbsp;=&nbsp;val.pwt&nbsp;//获取protocol&nbsp;witness&nbsp;table，用于进行方法分派&nbsp;local.type&nbsp;=&nbsp;type&nbsp;&nbsp;local.pwt&nbsp;=&nbsp;pwt&nbsp;vwt.allocateBufferAndCopyValue(&amp;local,&nbsp;val)&nbsp;&nbsp;//vwt进行生命周期管理，初始化或者拷贝&nbsp;pwt.draw(vwt.projectBuffer(&amp;local))&nbsp;//pwt查找方法，这里说一下projectBuffer，因为不同类型在内存中是不同的（small&nbsp;value内联在栈内，large&nbsp;value初始化在堆内，栈持有指针），所以方法的确定也是和类型相关的，我们知道，查找方法时是通过当前对象的地址，通过一定的位移去查找方法地址。&nbsp;vwt.destructAndDeallocateBuffer(temp)&nbsp;//vwt进行生命周期管理，销毁内存} Protocol Type 存储属性 我们知道，Swift中Class的实例和属性都存储在堆区，Struct实例在栈区，如果包含指针属性则存储在堆区，Protocol Type如何存储属性？Small Number通过Existential Container内联实现，大数存在堆区。如何处理Copy呢? Protocol大数的Copy优化 在出现Copy情况时： let&nbsp;aLine&nbsp;=&nbsp;Line(1.0,&nbsp;1.0,&nbsp;1.0,&nbsp;3.0)let&nbsp;pair&nbsp;=&nbsp;Pair(aLine,&nbsp;aLine)let&nbsp;copy&nbsp;=&nbsp;pair 会将新的Exsitential Container的valueBuffer指向同一个value即创建指针引用，但是如果要改变值怎么办?我们知道Struct值的修改和Class不同，Copy是不应该影响原实例的值的。 这里用到了一个技术叫做Indirect Storage With Copy-On-Write，即优先使用内存指针。通过提高内存指针的使用，来降低堆区内存的初始化。降低内存消耗。在需要修改值的时候，会先检测引用计数检测，如果有大于1的引用计数，则开辟新内存，创建新的实例。在对内容进行变更的时候，会开启一块新的内存，伪代码如下： class&nbsp;LineStorage&nbsp;{&nbsp;var&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:Double&nbsp;}struct&nbsp;Line&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;storage&nbsp;:LineStorage&nbsp;init()&nbsp;{&nbsp;storage&nbsp;=&nbsp;LineStorage(Point(),&nbsp;Point())&nbsp;}&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}&nbsp;mutating&nbsp;func&nbsp;move()&nbsp;{&nbsp;&nbsp;&nbsp;if&nbsp;!isUniquelyReferencedNonObjc(&amp;storage)&nbsp;{&nbsp;//如何存在多份引用，则开启新内存，否则直接修改&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage&nbsp;=&nbsp;LineStorage(storage)&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;storage。start&nbsp;=&nbsp;...&nbsp;&nbsp;&nbsp;}} 这样实现的目的：通过多份指针去引用同一份地址的成本远远低于开辟多份堆内存。以下对比图： Protocol Type多态总结 支持Protocol Type的动态多态（Dynamic Polymorphism）行为。 通过使用Witness Table和Existential Container来实现。 对于大数的拷贝可以通过Indirect Storage间接存储来进行优化。 说到动态多态Dynamic Polymorphism，我们就要问了，什么是静态多态Static Polymorphism，看看下面示例： //&nbsp;Drawing&nbsp;a&nbsp;copyprotocol&nbsp;Drawable&nbsp;{&nbsp;func&nbsp;draw()}func&nbsp;drawACopy(local&nbsp;:Drawable)&nbsp;{&nbsp;local.draw()}let&nbsp;line&nbsp;=&nbsp;Line()drawACopy(line)//&nbsp;...let&nbsp;point&nbsp;=&nbsp;Point()drawACopy(point) 这种情况我们就可以用到泛型Generic code来实现，进行进一步优化。 泛型 我们接下来会讨论泛型属性的存储方式和泛型方法是如何分派的。泛型和Protocol Type的区别在于： 泛型支持的是静态多态。 每个调用上下文只有一种类型。查看下面的示例，foo和bar方法是同一种类型。 在调用链中会通过类型降级进行类型取代。 对于以下示例： func&nbsp;foo&lt;T:Drawable&gt;(local&nbsp;:T)&nbsp;{&nbsp;bar(local)}func&nbsp;bar&lt;T:Drawable&gt;(local:T)&nbsp;{&nbsp;…&nbsp;}let&nbsp;point&nbsp;=&nbsp;Point()foo(point) 分析方法foo和bar的调用过程： //调用过程foo(point)--&gt;foo&lt;T&nbsp;=&nbsp;Point&gt;(point)&nbsp;&nbsp;&nbsp;//在方法执行时，Swift将泛型T绑定为调用方使用的具体类型，这里为Point&nbsp;bar(local)&nbsp;--&gt;bar&lt;T&nbsp;=&nbsp;Point&gt;(local)&nbsp;//在调用内部bar方法时，会使用foo已经绑定的变量类型Point，可以看到，泛型T在这里已经被降级，通过类型Point进行取代 泛型方法调用的具体实现为： 同一种类型的任何实例，都共享同样的实现，即使用同一个Protocol Witness Table。 使用Protocol/Value Witness Table。 每个调用上下文只有一种类型：这里没有使用Existential Container， 而是将Protocol/Value Witness Table作为调用方的额外参数进行传递。 变量初始化和方法调用，都使用传入的VWT和PWT来执行。 看到这里，我们并不觉得泛型比Protocol Type有什么更快的特性，泛型如何更快呢?静态多态前提下可以进行进一步的优化，称为特定泛型优化。 泛型特化 静态多态：在调用站中只有一种类型Swift使用只有一种类型的特点，来进行类型降级取代。 类型降级后，产生特定类型的方法 为泛型的每个类型创造对应的方法这时候你可能会问，那每一种类型都产生一个新的方法，代码空间岂不爆炸? 静态多态下进行特定优化specialization因为是静态多态。所以可以进行很强大的优化，比如进行内联实现，并且通过获取上下文来进行更进一步的优化。从而降低方法数量。优化后可以更精确和具体。 例如： func&nbsp;min&lt;T:Comparable&gt;(x:T,&nbsp;y:T)&nbsp;-&gt;&nbsp;T&nbsp;{&nbsp;&nbsp;return&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;?&nbsp;y&nbsp;:&nbsp;x} 从普通的泛型展开如下，因为要支持所有类型的min方法，所以需要对泛型类型进行计算，包括初始化地址、内存分配、生命周期管理等。除了对value的操作，还要对方法进行操作。这是一个非常的的工程。 func&nbsp;min&lt;T:Comparable&gt;(x:T,&nbsp;y:T,&nbsp;FTable:FunctionTable)&nbsp;-&gt;&nbsp;T&nbsp;{&nbsp;&nbsp;let&nbsp;xCopy&nbsp;=&nbsp;FTable.copy(x)&nbsp;&nbsp;let&nbsp;yCopy&nbsp;=&nbsp;FTable.copy(y)&nbsp;&nbsp;let&nbsp;m&nbsp;=&nbsp;FTable.lessThan(yCopy，&nbsp;xCopy)&nbsp;?&nbsp;y&nbsp;:x&nbsp;&nbsp;FTable.release(x)&nbsp;&nbsp;FTable.release(y)&nbsp;&nbsp;return&nbsp;m} 在确定入参类型时，比如Int，编译器可以通过泛型特化，进行类型取代（Type Substitute），优化为： func&nbsp;min&lt;Int&gt;(x:Int,&nbsp;y:Int)&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;return&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;?&nbsp;y&nbsp;:x} 泛型特化specilization是何时发生的? 在使用特定优化时，调用方需要进行类型推断，这里需要知晓类型的上下文，例如类型的定义和内部方法实现。如果调用方和类型是单独编译的，就无法在调用方推断类型的内部实行，就无法使用特定优化，保证这些代码一起进行编译，这里就用到了whole module optimization。而whole module optimization是对于调用方和被调用方的方法在不同文件时，对其进行泛型特化优化的前提。 泛型进一步优化 特定泛型的进一步优化： //&nbsp;Pairs&nbsp;in&nbsp;our&nbsp;program&nbsp;using&nbsp;generic&nbsp;typesstruct&nbsp;Pair&lt;T&nbsp;:Drawable&gt;&nbsp;{&nbsp;init(_&nbsp;f:T，&nbsp;_&nbsp;s:T)&nbsp;{&nbsp;first&nbsp;=&nbsp;f&nbsp;;&nbsp;second&nbsp;=&nbsp;s&nbsp;}&nbsp;var&nbsp;first:T&nbsp;var&nbsp;second:T}let&nbsp;pairOfLines&nbsp;=&nbsp;Pair(Line(),&nbsp;Line())//&nbsp;...let&nbsp;pairOfPoint&nbsp;=&nbsp;Pair(Point(),&nbsp;Point()) 在用到多种泛型，且确定泛型类型不会在运行时修改时，就可以对成对泛型的使用进行进一步优化。 优化的方式是将泛型的内存分配由指针指定，变为内存内联，不再有额外的堆初始化消耗。请注意，因为进行了存储内联，已经确定了泛型特定类型的内存分布，泛型的内存内联不能存储不同类型。所以再次强调此种优化只适用于在运行时不会修改泛型类型，即不能同时支持一个方法中包含line和point两种类型。 whole module optimization whole module optimization是用于Swift编译器的优化机制。可以通过-whole-module-optimization （或 -wmo）进行打开。在XCode 8之后默认打开。 Swift Package Manager在release模式默认使用whole module optimization。 module是多个文件集合。 编译器在对源文件进行语法分析之后，会对其进行优化，生成机器码并输出目标文件，之后链接器联合所有的目标文件生成共享库或可执行文件。 whole module optimization通过跨函数优化，可以进行内联等优化操作，对于泛型，可以通过获取类型的具体实现来进行推断优化，进行类型降级方法内联，删除多余方法等操作。 全模块优化的优势 编译器掌握所有方法的实现，可以进行内联和泛型特化等优化，通过计算所有方法的引用，移除多余的引用计数操作。 通过知晓所有的非公共方法，如果这写方法没有被使用，就可以对其进行消除。 如何降低编译时间 和全模块优化相反的是文件优化，即对单个文件进行编译。这样的好处在于可以并行执行，并且对于没有修改的文件不会再次编译。缺点在于编译器无法获知全貌，无法进行深度优化，全模块优化如何避免没修改的文件再次编译。 编译器内部运行过程分为：语法分析，类型检查，SIL优化，LLVM后端处理。 语法分析和类型检查一般很快，SIL优化执行了重要的Swift特定优化，例如泛型特化和方法内联等，该过程大概占用真个编译时间的三分之一。LLVM后端执行占用了大部分的编译时间，用于运行降级优化和生成代码。 进行全模块优化后，SIL优化会将模块再次拆分为多个部分，LLVM后端通过多线程对这些拆分模块进行处理，对于没有修改的部分，不会进行再处理。这样就避免了修改一小部分，整个大模块进行LLVM后端执行，并且多线程并行操作也会缩短处理时间。 扩展：Swift的隐藏“Bug” Swift因为方法分派机制问题，所以在设计和优化后，会产生和我们常规理解不太一致的结果，这当然不能算Bug。但是还是要单独进行说明，避免在开发过程中，因为对机制的掌握不足，造成预期和执行出入导致的问题。 Message dispatch 我们通过上面说明结合Static dispatch VS Dynamic dispatch对方法分派方式有了了解。这里需要对Objective-C的方法分派方式进行说明。 熟悉OC的人都知道，OC采用了运行时机制使用obj_msgSend发送消息，runtime非常的灵活，我们不仅可以对方法调用采用swizzling，对于对象也可以通过isa-swizzling来扩展功能，应用场景有我们常用的hook和大家熟知的KVO。 大家在使用Swift进行开发时都会问，Swift是否可以使用OC的运行时和消息转发机制呢？答案是可以。 Swift可以通过关键字dynamic对方法进行标记，这样就会告诉编译器，此方法使用的是OC的运行时机制。 注意：我们常见的关键字@ObjC并不会改变Swift原有的方法分派机制，关键字@ObjC的作用只是告诉编译器，该段代码对于OC可见。 总结来说，Swift通过dynamic关键字的扩展后，一共包含三种方法分派方式：Static dispatch，Table dispatch和Message dispatch。下表为不同的数据结构在不同情况下采取的分派方式： 如果在开发过程中，错误的混合了这几种分派方式，就可能出现Bug，以下我们对这些Bug进行分析： SR-584 此情况是在子类的extension中重载父类方法时，出现和预期不同的行为。 class&nbsp;Base:NSObject&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;directProperty:String&nbsp;{&nbsp;return&nbsp;&quot;This&nbsp;is&nbsp;Base&quot;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;indirectProperty:String&nbsp;{&nbsp;return&nbsp;directProperty&nbsp;}}class&nbsp;Sub:Base&nbsp;{&nbsp;}extension&nbsp;Sub&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;var&nbsp;directProperty:String&nbsp;{&nbsp;return&nbsp;&quot;This&nbsp;is&nbsp;Sub&quot;&nbsp;}} 执行以下代码，直接调用没有问题： Base().directProperty&nbsp;//&nbsp;“This&nbsp;is&nbsp;Base”Sub().directProperty&nbsp;//&nbsp;“This&nbsp;is&nbsp;Sub” 间接调用结果和预期不同： Base（）。indirectProperty&nbsp;//&nbsp;“This&nbsp;is&nbsp;Base”Sub（）。indirectProperty&nbsp;//&nbsp;expected&nbsp;&quot;this&nbsp;is&nbsp;Sub&quot;，but&nbsp;is&nbsp;“This&nbsp;is&nbsp;Base”&nbsp;&lt;-&nbsp;Unexpected! 在Base.directProperty前添加dynamic关键字就可以获得&quot;this is Sub&quot;的结果。Swift在extension 文档中说明，不能在extension中重载已经存在的方法。 “Extensions can add new functionality to a type, but they cannot override existing functionality.” 会出现警告：Cannot override a non-dynamic class declaration from an extension。 出现这个问题的原因是，NSObject的extension是使用的Message dispatch，而Initial Declaration使用的是Table dispath（查看上图 Swift Dispatch Method）。extension重载的方法添加在了Message dispatch内，没有修改虚函数表，虚函数表内还是父类的方法，故会执行父类方法。想在extension重载方法，需要标明dynamic来使用Message dispatch。 SR-103 协议的扩展内实现的方法，无法被遵守类的子类重载： protocol&nbsp;Greetable&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;sayHi()}extension&nbsp;Greetable&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;sayHi()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Hello&quot;）&nbsp;&nbsp;&nbsp;&nbsp;}}func&nbsp;greetings(greeter：Greetable)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;greeter.sayHi()} 现在定义一个遵守了协议的类Person。遵守协议类的子类LoudPerson： class&nbsp;Person:Greetable&nbsp;{}class&nbsp;LoudPerson:Person&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;sayHi()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;sub&quot;)&nbsp;&nbsp;&nbsp;&nbsp;}} 执行下面代码结果为： var&nbsp;sub:LoudPerson&nbsp;=&nbsp;LoudPerson()sub.sayHi()&nbsp;&nbsp;//sub 不符合预期的代码： var&nbsp;sub:Person&nbsp;=&nbsp;LoudPerson()sub.sayHi()&nbsp;&nbsp;//HellO&nbsp;&nbsp;&lt;-使用了protocol的默认实现 注意，在子类LoudPerson中没有出现override关键字。可以理解为LoudPerson并没有成功注册Greetable在Witness table的方法。所以对于声明为Person实际为LoudPerson的实例，会在编译器通过Person去查找，Person没有实现协议方法，则不产生Witness table，sayHi方法是直接调用的。解决办法是在base类内实现协议方法，无需实现也要提供默认方法。或者将基类标记为final来避免继承。 进一步通过示例去理解： //&nbsp;Defined&nbsp;protocol。protocol&nbsp;A&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int}extension&nbsp;A&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;A&nbsp;class&nbsp;doesn&#39;t&nbsp;have&nbsp;implement&nbsp;of&nbsp;the&nbsp;function。class&nbsp;B：A&nbsp;{}class&nbsp;C：B&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;A&nbsp;class&nbsp;has&nbsp;implement&nbsp;of&nbsp;the&nbsp;function。class&nbsp;D：A&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;}}class&nbsp;E：D&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;Failure&nbsp;cases。B().a()&nbsp;//&nbsp;0C().a()&nbsp;//&nbsp;1(C()&nbsp;as&nbsp;A).a()&nbsp;//&nbsp;0&nbsp;#&nbsp;We&nbsp;thought&nbsp;return&nbsp;1。&nbsp;//&nbsp;Success&nbsp;cases。D().a()&nbsp;//&nbsp;1(D()&nbsp;as&nbsp;A).a()&nbsp;//&nbsp;1E().a()&nbsp;//&nbsp;2(E()&nbsp;as&nbsp;A).a()&nbsp;//&nbsp;2 其他 我们知道Class extension使用的是Static dispatch： class&nbsp;MyClass&nbsp;{}extension&nbsp;MyClass&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;extensionMethod()&nbsp;{}}class&nbsp;SubClass：MyClass&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;extensionMethod()&nbsp;{}} 以上代码会出现错误，提示Declarations in extensions can not be overridden yet。 总结 影响程序的性能标准有三种：初始化方式， 引用指针和方法分派。 文中对比了两种数据结构：Struct和Class的在不同标准下的性能表现。Swift相比OC和其它语言强化了结构体的能力，所以在了解以上性能表现的前提下，通过利用结构体可以有效提升性能。 在此基础上，我们还介绍了功能强大的结构体的类：Protocol Type和Generic。并且介绍了它们如何支持多态以及通过使用有条件限制的泛型如何让程序更快。 参考资料 swift memorylayout witness table video protocol types pdf protocol and value oriented programming in UIKit apps &nbsp;video optimizing swift performance whole module optimizaiton increasing performance by reducing dynamic dispatch protocols generics existential container protocols and generics why swift is swift swift method dispatch swift extension universal dynamic dispatch for method calls compiler performance.md structures and classes 作者简介 亚男，美团点评iOS工程师。2017年加入美团点评，负责美团管家开发，研究编译器原理。目前正积极推动Swift组件化建设。 欢迎加入美团iOS技术交流群，跟作者零距离交流。进群方式：请加美美同学的微信（微信号：MTDPtech01），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 我们餐饮生态技术部是一个技术氛围活跃，大牛聚集的地方。新到店紧握真正的大规模SaaS实战机会，多租户、数据、安全、开放平台等全方位的挑战。业务领域复杂技术挑战多，技术和业务能力迅速提升，最重要的是，加入我们，你将实现真正通过代码来改变行业的梦想。我们欢迎各端人才加入，Java优先。感兴趣的同学赶紧发送简历至 zhaoyanan02@meituan.com，我们期待你的到来。 也许你还想看 iOS系统中导航栏的转场解决方案与最佳实践 美团外卖iOS多端复用的推动、支撑与思考 ARKit：增强现实技术在美团到餐业务的实践" />
<meta property="og:description" content="总第297篇 2018年 第89篇 美美今天请来了我们技术团队很厉害的iOS女神亚男小姐姐深度剖析Swift，她特别讲解了如何才能开发出高性能的Swift程序。希望对你有所帮助哦～Enjoy Reading！ 简介 2014年，苹果公司在WWDC上发布Swift这一新的编程语言。经过几年的发展，Swift已经成为iOS开发语言的“中流砥柱”，Swift提供了非常灵活的高级别特性，例如协议、闭包、泛型等，并且Swift还进一步开发了强大的SIL（Swift Intermediate Language）用于对编译器进行优化，使得Swift相比Objective-C运行更快性能更优，Swift内部如何实现性能的优化，我们本文就进行一下解读，希望能对大家有所启发和帮助。 针对Swift性能提升这一问题，我们可以从概念上拆分为两个部分： 编译器：Swift编译器进行的性能优化，从阶段分为编译期和运行期，内容分为时间优化和空间优化。 开发者：通过使用合适的数据结构和关键字，帮助编译器获取更多信息，进行优化。 下面我们将从这两个角度切入，对Swift性能优化进行分析。通过了解编译器对不同数据结构处理的内部实现，来选择最合适的算法机制，并利用编译器的优化特性，编写高性能的程序。 理解Swift的性能 理解Swift的性能，首先要清楚Swift的数据结构，组件关系和编译运行方式。 数据结构Swift的数据结构可以大体拆分为：Class，Struct，Enum。 组件关系组件关系可以分为：inheritance，protocols，generics。 方法分派方式方法分派方式可以分为Static dispatch和Dynamic dispatch。 要在开发中提高Swift性能，需要开发者去了解这几种数据结构和组件关系以及它们的内部实现，从而通过选择最合适的抽象机制来提升性能。 首先我们对于性能标准进行一个概念陈述，性能标准涵盖三个标准： Allocation Reference counting Method dispatch 接下来，我们会分别对这几个指标进行说明。 Allocation 内存分配可以分为堆区栈区，在栈的内存分配速度要高于堆，结构体和类在堆栈分配是不同的。 Stack 基本数据类型和结构体默认在栈区，栈区内存是连续的，通过出栈入栈进行分配和销毁，速度很快，高于堆区。 我们通过一些例子进行说明： //示例&nbsp;1//&nbsp;Allocation//&nbsp;Structstruct&nbsp;Point&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}let&nbsp;point1&nbsp;=&nbsp;Point(x:0,&nbsp;y:0)&nbsp;//进行point1初始化，开辟栈内存var&nbsp;point2&nbsp;=&nbsp;point1&nbsp;//初始化point2，拷贝point1内容，开辟新内存point2.x&nbsp;=&nbsp;5&nbsp;//对point2的操作不会影响point1//&nbsp;use&nbsp;`point1`//&nbsp;use&nbsp;`point2` 以上结构体的内存是在栈区分配的，内部的变量也是内联在栈区。将point1赋值给point2实际操作是在栈区进行了一份拷贝，产生了新的内存消耗point2，这使得point1和point2是完全独立的两个实例，它们之间的操作互不影响。在使用point1和point2之后，会进行销毁。 Heap 高级的数据结构，比如类，分配在堆区。初始化时查找没有使用的内存块，销毁时再从内存块中清除。因为堆区可能存在多线程的操作问题，为了保证线程安全，需要进行加锁操作，因此也是一种性能消耗。 //&nbsp;Allocation//&nbsp;Classclass&nbsp;Point&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}let&nbsp;point1&nbsp;=&nbsp;Point(x:0,&nbsp;y:0)&nbsp;//在堆区分配内存，栈区只是存储地址指针let&nbsp;point2&nbsp;=&nbsp;point1&nbsp;//不产生新的实例，而是对point2增加对堆区内存引用的指针point2.x&nbsp;=&nbsp;5&nbsp;//因为point1和point2是一个实例，所以point1的值也会被修改//&nbsp;use&nbsp;`point1`//&nbsp;use&nbsp;`point2` 以上我们初始化了一个Class类型，在栈区分配一块内存，但是和结构体直接在栈内存储数值不同，我们只在栈区存储了对象的指针，指针指向的对象的内存是分配在堆区的。需要注意的是，为了管理对象内存，在堆区初始化时，除了分配属性内存（这里是Double类型的x，y），还会有额外的两个字段，分别是type和refCount，这个包含了type，refCount和实际属性的结构被称为blue box。 内存分配总结 从初始化角度，Class相比Struct需要在堆区分配内存，进行内存管理，使用了指针，有更强大的特性，但是性能较低。 优化方式： 对于频繁操作（比如通信软件的内容气泡展示），尽量使用Struct替代Class，因为栈内存分配更快，更安全，操作更快。 Reference counting Swift通过引用计数管理堆对象内存，当引用计数为0时，Swift确认没有对象再引用该内存，所以将内存释放。 对于引用计数的管理是一个非常高频的间接操作，并且需要考虑线程安全，使得引用计数的操作需要较高的性能消耗。 对于基本数据类型的Struct来说，没有堆内存分配和引用计数的管理，性能更高更安全，但是对于复杂的结构体，如： //&nbsp;Reference&nbsp;Counting//&nbsp;Struct&nbsp;containing&nbsp;referencesstruct&nbsp;Label&nbsp;{&nbsp;var&nbsp;text:String&nbsp;var&nbsp;font:UIFont&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}let&nbsp;label1&nbsp;=&nbsp;Label(text:&quot;Hi&quot;,&nbsp;font:font)&nbsp;&nbsp;//栈区包含了存储在堆区的指针let&nbsp;label2&nbsp;=&nbsp;label1&nbsp;//label2产生新的指针，和label1一样指向同样的string和font地址//&nbsp;use&nbsp;`label1`//&nbsp;use&nbsp;`label2` 这里看到，包含了引用的结构体相比Class，需要管理双倍的引用计数。每次将结构体作为参数传递给方法或者进行直接拷贝时，都会出现多份引用计数。下图可以比较直观的理解： 备注：包含引用类型的结构体出现Copy的处理方式 Class在拷贝时的处理方式： 引用计数总结 Class在堆区分配内存，需要使用引用计数器进行内存管理。 基本类型的Struct在栈区分配内存，无引用计数管理。 包含强类型的Struct通过指针管理在堆区的属性，对结构体的拷贝会创建新的栈内存，创建多份引用的指针，Class只会有一份。 优化方式 在使用结构体时： 通过使用精确类型，例如UUID替代String（UUID字节长度固定128字节，而不是String任意长度），这样就可以进行内存内联，在栈内存储UUID，我们知道，栈内存管理更快更安全，并且不需要引用计数。 Enum替代String，在栈内管理内存，无引用计数，并且从语法上对于开发者更友好。 Method Dispatch 我们之前在Static dispatch VS Dynamic dispatch中提到过，能够在编译期确定执行方法的方式叫做静态分派Static dispatch，无法在编译期确定，只能在运行时去确定执行方法的分派方式叫做动态分派Dynamic dispatch。 Static dispatch更快，而且静态分派可以进行内联等进一步的优化，使得执行更快速，性能更高。 但是对于多态的情况，我们不能在编译期确定最终的类型，这里就用到了Dynamic dispatch动态分派。动态分派的实现是，每种类型都会创建一张表，表内是一个包含了方法指针的数组。动态分派更灵活，但是因为有查表和跳转的操作，并且因为很多特点对于编译器来说并不明确，所以相当于block了编译器的一些后期优化。所以速度慢于Static dispatch。 下面看一段多态代码，以及分析实现方式： //引用语义实现的多态class&nbsp;Drawable&nbsp;{&nbsp;func&nbsp;draw()&nbsp;{}&nbsp;}class&nbsp;Point&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;override&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}class&nbsp;Line&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:Double&nbsp;override&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}var&nbsp;drawables:[Drawable]for&nbsp;d&nbsp;in&nbsp;drawables&nbsp;{&nbsp;d.draw（）} Method Dispatch总结 Class默认使用Dynamic dispatch，因为在编译期几乎每个环节的信息都无法确定，所以阻碍了编译器的优化，比如inline和whole module inline。 使用Static dispatch代替Dynamic dispatch提升性能 我们知道Static dispatch快于Dynamic dispatch，如何在开发中去尽可能使用Static dispatch。 inheritance constraints继承约束我们可以使用final关键字去修饰Class，以此生成的Final class，使用Static dispatch。 access control访问控制private关键字修饰，使得方法或属性只对当前类可见。编译器会对方法进行Static dispatch。 编译器可以通过whole module optimization检查继承关系，对某些没有标记final的类通过计算，如果能在编译期确定执行的方法，则使用Static dispatch。Struct默认使用Static dispatch。 Swift快于OC的一个关键是可以消解动态分派。 总结 Swift提供了更灵活的Struct，用以在内存、引用计数、方法分派等角度去进行性能的优化，在正确的时机选择正确的数据结构，可以使我们的代码性能更快更安全。 延伸 你可能会问Struct如何实现多态呢?答案是protocol oriented programming。 以上分析了影响性能的几个标准，那么不同的算法机制Class，Protocol Types和Generic code，它们在这三方面的表现如何，Protocol Type和Generic code分别是怎么实现的呢？我们带着这个问题看下去。 Protocol Type 这里我们会讨论Protocol Type如何存储和拷贝变量，以及方法分派是如何实现的。不通过继承或者引用语义的多态： protocol&nbsp;Drawable&nbsp;{&nbsp;func&nbsp;draw()&nbsp;}struct&nbsp;Point&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}struct&nbsp;Line&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}var&nbsp;drawables:[Drawable]&nbsp;//遵守了Drawable协议的类型集合，可能是point或者linefor&nbsp;d&nbsp;in&nbsp;drawables&nbsp;{&nbsp;d.draw（）} 以上通过Protocol Type实现多态，几个类之间没有继承关系，故不能按照惯例借助V-Table实现动态分派。 如果想了解Vtable和Witness table实现，可以进行点击查看，这里不做细节说明。因为Point和Line的尺寸不同，数组存储数据实现一致性存储，使用了Existential Container。查找正确的执行方法则使用了 Protoloc Witness Table。 Existential Container Existential Container是一种特殊的内存布局方式，用于管理遵守了相同协议的数据类型Protocol Type，这些数据类型因为不共享同一继承关系（这是V-Table实现的前提），并且内存空间尺寸不同，使用Existential Container进行管理，使其具有存储的一致性。 结构如下： 三个词大小的valueBuffer这里介绍一下valueBuffer结构，valueBuffer有三个词，每个词包含8个字节，存储的可能是值，也可能是对象的指针。对于small value（空间小于valueBuffer），直接存储在valueBuffer的地址内， inline valueBuffer，无额外堆内存初始化。当值的数量大于3个属性即large value，或者总尺寸超过valueBuffer的占位，就会在堆区开辟内存，将其存储在堆区，valueBuffer存储内存指针。 value witness table的引用因为Protocol Type的类型不同，内存空间，初始化方法等都不相同，为了对Protocol Type生命周期进行专项管理，用到了Value Witness Table。 protocol witness table的引用管理Protocol Type的方法分派。 内存分布如下： 1.&nbsp;payload_data_0&nbsp;=&nbsp;0x0000000000000004,2.&nbsp;payload_data_1&nbsp;=&nbsp;0x0000000000000000,3.&nbsp;payload_data_2&nbsp;=&nbsp;0x0000000000000000,4.&nbsp;instance_type&nbsp;=&nbsp;0x000000010d6dc408&nbsp;ExistentialContainers`type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metadata&nbsp;for&nbsp;ExistentialContainers.Car,5.&nbsp;protocol_witness_0&nbsp;=&nbsp;0x000000010d6dc1c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExistentialContainers&nbsp;protocol&nbsp;witness&nbsp;table&nbsp;for&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExistentialContainers.Car:ExistentialContainers.Drivable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;ExistentialContainers Protocol Witness Table（PWT） 为了实现Class多态也就是引用语义多态，需要V-Table来实现，但是V-Table的前提是具有同一个父类即共享相同的继承关系，但是对于Protocol Type来说，并不具备此特征，故为了支持Struct的多态，需要用到protocol oriented programming机制，也就是借助Protocol Witness Table来实现（细节可以点击Vtable和witness table实现，每个结构体会创造PWT表，内部包含指针，指向方法具体实现）。 Value Witness Table（VWT） 用于管理任意值的初始化、拷贝、销毁。 Value Witness Table的结构如上，是用于管理遵守了协议的Protocol Type实例的初始化，拷贝，内存消减和销毁的。 Value Witness Table在SIL中还可以拆分为%relative_vwtable和%absolute_vwtable，我们这里先不做展开。 Value Witness Table和Protocol Witness Table通过分工，去管理Protocol Type实例的内存管理（初始化，拷贝，销毁）和方法调用。 我们来借助具体的示例进行进一步了解： //&nbsp;Protocol&nbsp;Types//&nbsp;The&nbsp;Existential&nbsp;Container&nbsp;in&nbsp;actionfunc&nbsp;drawACopy(local&nbsp;：Drawable)&nbsp;{&nbsp;local.draw()}let&nbsp;val&nbsp;:Drawable&nbsp;=&nbsp;Point()drawACopy(val) 在Swift编译器中，通过Existential Container实现的伪代码如下： //&nbsp;Protocol&nbsp;Types//&nbsp;The&nbsp;Existential&nbsp;Container&nbsp;in&nbsp;actionfunc&nbsp;drawACopy(local&nbsp;:Drawable)&nbsp;{&nbsp;local.draw()}let&nbsp;val&nbsp;:Drawable&nbsp;=&nbsp;Point()drawACopy(val)//existential&nbsp;container的伪代码结构struct&nbsp;ExistContDrawable&nbsp;{&nbsp;var&nbsp;valueBuffer:(Int,&nbsp;Int,&nbsp;Int)&nbsp;var&nbsp;vwt:ValueWitnessTable&nbsp;var&nbsp;pwt:DrawableProtocolWitnessTable}//&nbsp;drawACopy方法生成的伪代码func&nbsp;drawACopy(val:ExistContDrawable)&nbsp;{&nbsp;//将existential&nbsp;container传入&nbsp;var&nbsp;local&nbsp;=&nbsp;ExistContDrawable()&nbsp;&nbsp;//初始化container&nbsp;let&nbsp;vwt&nbsp;=&nbsp;val.vwt&nbsp;//获取value&nbsp;witness&nbsp;table，用于管理生命周期&nbsp;let&nbsp;pwt&nbsp;=&nbsp;val.pwt&nbsp;//获取protocol&nbsp;witness&nbsp;table，用于进行方法分派&nbsp;local.type&nbsp;=&nbsp;type&nbsp;&nbsp;local.pwt&nbsp;=&nbsp;pwt&nbsp;vwt.allocateBufferAndCopyValue(&amp;local,&nbsp;val)&nbsp;&nbsp;//vwt进行生命周期管理，初始化或者拷贝&nbsp;pwt.draw(vwt.projectBuffer(&amp;local))&nbsp;//pwt查找方法，这里说一下projectBuffer，因为不同类型在内存中是不同的（small&nbsp;value内联在栈内，large&nbsp;value初始化在堆内，栈持有指针），所以方法的确定也是和类型相关的，我们知道，查找方法时是通过当前对象的地址，通过一定的位移去查找方法地址。&nbsp;vwt.destructAndDeallocateBuffer(temp)&nbsp;//vwt进行生命周期管理，销毁内存} Protocol Type 存储属性 我们知道，Swift中Class的实例和属性都存储在堆区，Struct实例在栈区，如果包含指针属性则存储在堆区，Protocol Type如何存储属性？Small Number通过Existential Container内联实现，大数存在堆区。如何处理Copy呢? Protocol大数的Copy优化 在出现Copy情况时： let&nbsp;aLine&nbsp;=&nbsp;Line(1.0,&nbsp;1.0,&nbsp;1.0,&nbsp;3.0)let&nbsp;pair&nbsp;=&nbsp;Pair(aLine,&nbsp;aLine)let&nbsp;copy&nbsp;=&nbsp;pair 会将新的Exsitential Container的valueBuffer指向同一个value即创建指针引用，但是如果要改变值怎么办?我们知道Struct值的修改和Class不同，Copy是不应该影响原实例的值的。 这里用到了一个技术叫做Indirect Storage With Copy-On-Write，即优先使用内存指针。通过提高内存指针的使用，来降低堆区内存的初始化。降低内存消耗。在需要修改值的时候，会先检测引用计数检测，如果有大于1的引用计数，则开辟新内存，创建新的实例。在对内容进行变更的时候，会开启一块新的内存，伪代码如下： class&nbsp;LineStorage&nbsp;{&nbsp;var&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:Double&nbsp;}struct&nbsp;Line&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;storage&nbsp;:LineStorage&nbsp;init()&nbsp;{&nbsp;storage&nbsp;=&nbsp;LineStorage(Point(),&nbsp;Point())&nbsp;}&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}&nbsp;mutating&nbsp;func&nbsp;move()&nbsp;{&nbsp;&nbsp;&nbsp;if&nbsp;!isUniquelyReferencedNonObjc(&amp;storage)&nbsp;{&nbsp;//如何存在多份引用，则开启新内存，否则直接修改&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage&nbsp;=&nbsp;LineStorage(storage)&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;storage。start&nbsp;=&nbsp;...&nbsp;&nbsp;&nbsp;}} 这样实现的目的：通过多份指针去引用同一份地址的成本远远低于开辟多份堆内存。以下对比图： Protocol Type多态总结 支持Protocol Type的动态多态（Dynamic Polymorphism）行为。 通过使用Witness Table和Existential Container来实现。 对于大数的拷贝可以通过Indirect Storage间接存储来进行优化。 说到动态多态Dynamic Polymorphism，我们就要问了，什么是静态多态Static Polymorphism，看看下面示例： //&nbsp;Drawing&nbsp;a&nbsp;copyprotocol&nbsp;Drawable&nbsp;{&nbsp;func&nbsp;draw()}func&nbsp;drawACopy(local&nbsp;:Drawable)&nbsp;{&nbsp;local.draw()}let&nbsp;line&nbsp;=&nbsp;Line()drawACopy(line)//&nbsp;...let&nbsp;point&nbsp;=&nbsp;Point()drawACopy(point) 这种情况我们就可以用到泛型Generic code来实现，进行进一步优化。 泛型 我们接下来会讨论泛型属性的存储方式和泛型方法是如何分派的。泛型和Protocol Type的区别在于： 泛型支持的是静态多态。 每个调用上下文只有一种类型。查看下面的示例，foo和bar方法是同一种类型。 在调用链中会通过类型降级进行类型取代。 对于以下示例： func&nbsp;foo&lt;T:Drawable&gt;(local&nbsp;:T)&nbsp;{&nbsp;bar(local)}func&nbsp;bar&lt;T:Drawable&gt;(local:T)&nbsp;{&nbsp;…&nbsp;}let&nbsp;point&nbsp;=&nbsp;Point()foo(point) 分析方法foo和bar的调用过程： //调用过程foo(point)--&gt;foo&lt;T&nbsp;=&nbsp;Point&gt;(point)&nbsp;&nbsp;&nbsp;//在方法执行时，Swift将泛型T绑定为调用方使用的具体类型，这里为Point&nbsp;bar(local)&nbsp;--&gt;bar&lt;T&nbsp;=&nbsp;Point&gt;(local)&nbsp;//在调用内部bar方法时，会使用foo已经绑定的变量类型Point，可以看到，泛型T在这里已经被降级，通过类型Point进行取代 泛型方法调用的具体实现为： 同一种类型的任何实例，都共享同样的实现，即使用同一个Protocol Witness Table。 使用Protocol/Value Witness Table。 每个调用上下文只有一种类型：这里没有使用Existential Container， 而是将Protocol/Value Witness Table作为调用方的额外参数进行传递。 变量初始化和方法调用，都使用传入的VWT和PWT来执行。 看到这里，我们并不觉得泛型比Protocol Type有什么更快的特性，泛型如何更快呢?静态多态前提下可以进行进一步的优化，称为特定泛型优化。 泛型特化 静态多态：在调用站中只有一种类型Swift使用只有一种类型的特点，来进行类型降级取代。 类型降级后，产生特定类型的方法 为泛型的每个类型创造对应的方法这时候你可能会问，那每一种类型都产生一个新的方法，代码空间岂不爆炸? 静态多态下进行特定优化specialization因为是静态多态。所以可以进行很强大的优化，比如进行内联实现，并且通过获取上下文来进行更进一步的优化。从而降低方法数量。优化后可以更精确和具体。 例如： func&nbsp;min&lt;T:Comparable&gt;(x:T,&nbsp;y:T)&nbsp;-&gt;&nbsp;T&nbsp;{&nbsp;&nbsp;return&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;?&nbsp;y&nbsp;:&nbsp;x} 从普通的泛型展开如下，因为要支持所有类型的min方法，所以需要对泛型类型进行计算，包括初始化地址、内存分配、生命周期管理等。除了对value的操作，还要对方法进行操作。这是一个非常的的工程。 func&nbsp;min&lt;T:Comparable&gt;(x:T,&nbsp;y:T,&nbsp;FTable:FunctionTable)&nbsp;-&gt;&nbsp;T&nbsp;{&nbsp;&nbsp;let&nbsp;xCopy&nbsp;=&nbsp;FTable.copy(x)&nbsp;&nbsp;let&nbsp;yCopy&nbsp;=&nbsp;FTable.copy(y)&nbsp;&nbsp;let&nbsp;m&nbsp;=&nbsp;FTable.lessThan(yCopy，&nbsp;xCopy)&nbsp;?&nbsp;y&nbsp;:x&nbsp;&nbsp;FTable.release(x)&nbsp;&nbsp;FTable.release(y)&nbsp;&nbsp;return&nbsp;m} 在确定入参类型时，比如Int，编译器可以通过泛型特化，进行类型取代（Type Substitute），优化为： func&nbsp;min&lt;Int&gt;(x:Int,&nbsp;y:Int)&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;return&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;?&nbsp;y&nbsp;:x} 泛型特化specilization是何时发生的? 在使用特定优化时，调用方需要进行类型推断，这里需要知晓类型的上下文，例如类型的定义和内部方法实现。如果调用方和类型是单独编译的，就无法在调用方推断类型的内部实行，就无法使用特定优化，保证这些代码一起进行编译，这里就用到了whole module optimization。而whole module optimization是对于调用方和被调用方的方法在不同文件时，对其进行泛型特化优化的前提。 泛型进一步优化 特定泛型的进一步优化： //&nbsp;Pairs&nbsp;in&nbsp;our&nbsp;program&nbsp;using&nbsp;generic&nbsp;typesstruct&nbsp;Pair&lt;T&nbsp;:Drawable&gt;&nbsp;{&nbsp;init(_&nbsp;f:T，&nbsp;_&nbsp;s:T)&nbsp;{&nbsp;first&nbsp;=&nbsp;f&nbsp;;&nbsp;second&nbsp;=&nbsp;s&nbsp;}&nbsp;var&nbsp;first:T&nbsp;var&nbsp;second:T}let&nbsp;pairOfLines&nbsp;=&nbsp;Pair(Line(),&nbsp;Line())//&nbsp;...let&nbsp;pairOfPoint&nbsp;=&nbsp;Pair(Point(),&nbsp;Point()) 在用到多种泛型，且确定泛型类型不会在运行时修改时，就可以对成对泛型的使用进行进一步优化。 优化的方式是将泛型的内存分配由指针指定，变为内存内联，不再有额外的堆初始化消耗。请注意，因为进行了存储内联，已经确定了泛型特定类型的内存分布，泛型的内存内联不能存储不同类型。所以再次强调此种优化只适用于在运行时不会修改泛型类型，即不能同时支持一个方法中包含line和point两种类型。 whole module optimization whole module optimization是用于Swift编译器的优化机制。可以通过-whole-module-optimization （或 -wmo）进行打开。在XCode 8之后默认打开。 Swift Package Manager在release模式默认使用whole module optimization。 module是多个文件集合。 编译器在对源文件进行语法分析之后，会对其进行优化，生成机器码并输出目标文件，之后链接器联合所有的目标文件生成共享库或可执行文件。 whole module optimization通过跨函数优化，可以进行内联等优化操作，对于泛型，可以通过获取类型的具体实现来进行推断优化，进行类型降级方法内联，删除多余方法等操作。 全模块优化的优势 编译器掌握所有方法的实现，可以进行内联和泛型特化等优化，通过计算所有方法的引用，移除多余的引用计数操作。 通过知晓所有的非公共方法，如果这写方法没有被使用，就可以对其进行消除。 如何降低编译时间 和全模块优化相反的是文件优化，即对单个文件进行编译。这样的好处在于可以并行执行，并且对于没有修改的文件不会再次编译。缺点在于编译器无法获知全貌，无法进行深度优化，全模块优化如何避免没修改的文件再次编译。 编译器内部运行过程分为：语法分析，类型检查，SIL优化，LLVM后端处理。 语法分析和类型检查一般很快，SIL优化执行了重要的Swift特定优化，例如泛型特化和方法内联等，该过程大概占用真个编译时间的三分之一。LLVM后端执行占用了大部分的编译时间，用于运行降级优化和生成代码。 进行全模块优化后，SIL优化会将模块再次拆分为多个部分，LLVM后端通过多线程对这些拆分模块进行处理，对于没有修改的部分，不会进行再处理。这样就避免了修改一小部分，整个大模块进行LLVM后端执行，并且多线程并行操作也会缩短处理时间。 扩展：Swift的隐藏“Bug” Swift因为方法分派机制问题，所以在设计和优化后，会产生和我们常规理解不太一致的结果，这当然不能算Bug。但是还是要单独进行说明，避免在开发过程中，因为对机制的掌握不足，造成预期和执行出入导致的问题。 Message dispatch 我们通过上面说明结合Static dispatch VS Dynamic dispatch对方法分派方式有了了解。这里需要对Objective-C的方法分派方式进行说明。 熟悉OC的人都知道，OC采用了运行时机制使用obj_msgSend发送消息，runtime非常的灵活，我们不仅可以对方法调用采用swizzling，对于对象也可以通过isa-swizzling来扩展功能，应用场景有我们常用的hook和大家熟知的KVO。 大家在使用Swift进行开发时都会问，Swift是否可以使用OC的运行时和消息转发机制呢？答案是可以。 Swift可以通过关键字dynamic对方法进行标记，这样就会告诉编译器，此方法使用的是OC的运行时机制。 注意：我们常见的关键字@ObjC并不会改变Swift原有的方法分派机制，关键字@ObjC的作用只是告诉编译器，该段代码对于OC可见。 总结来说，Swift通过dynamic关键字的扩展后，一共包含三种方法分派方式：Static dispatch，Table dispatch和Message dispatch。下表为不同的数据结构在不同情况下采取的分派方式： 如果在开发过程中，错误的混合了这几种分派方式，就可能出现Bug，以下我们对这些Bug进行分析： SR-584 此情况是在子类的extension中重载父类方法时，出现和预期不同的行为。 class&nbsp;Base:NSObject&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;directProperty:String&nbsp;{&nbsp;return&nbsp;&quot;This&nbsp;is&nbsp;Base&quot;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;indirectProperty:String&nbsp;{&nbsp;return&nbsp;directProperty&nbsp;}}class&nbsp;Sub:Base&nbsp;{&nbsp;}extension&nbsp;Sub&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;var&nbsp;directProperty:String&nbsp;{&nbsp;return&nbsp;&quot;This&nbsp;is&nbsp;Sub&quot;&nbsp;}} 执行以下代码，直接调用没有问题： Base().directProperty&nbsp;//&nbsp;“This&nbsp;is&nbsp;Base”Sub().directProperty&nbsp;//&nbsp;“This&nbsp;is&nbsp;Sub” 间接调用结果和预期不同： Base（）。indirectProperty&nbsp;//&nbsp;“This&nbsp;is&nbsp;Base”Sub（）。indirectProperty&nbsp;//&nbsp;expected&nbsp;&quot;this&nbsp;is&nbsp;Sub&quot;，but&nbsp;is&nbsp;“This&nbsp;is&nbsp;Base”&nbsp;&lt;-&nbsp;Unexpected! 在Base.directProperty前添加dynamic关键字就可以获得&quot;this is Sub&quot;的结果。Swift在extension 文档中说明，不能在extension中重载已经存在的方法。 “Extensions can add new functionality to a type, but they cannot override existing functionality.” 会出现警告：Cannot override a non-dynamic class declaration from an extension。 出现这个问题的原因是，NSObject的extension是使用的Message dispatch，而Initial Declaration使用的是Table dispath（查看上图 Swift Dispatch Method）。extension重载的方法添加在了Message dispatch内，没有修改虚函数表，虚函数表内还是父类的方法，故会执行父类方法。想在extension重载方法，需要标明dynamic来使用Message dispatch。 SR-103 协议的扩展内实现的方法，无法被遵守类的子类重载： protocol&nbsp;Greetable&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;sayHi()}extension&nbsp;Greetable&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;sayHi()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Hello&quot;）&nbsp;&nbsp;&nbsp;&nbsp;}}func&nbsp;greetings(greeter：Greetable)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;greeter.sayHi()} 现在定义一个遵守了协议的类Person。遵守协议类的子类LoudPerson： class&nbsp;Person:Greetable&nbsp;{}class&nbsp;LoudPerson:Person&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;sayHi()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;sub&quot;)&nbsp;&nbsp;&nbsp;&nbsp;}} 执行下面代码结果为： var&nbsp;sub:LoudPerson&nbsp;=&nbsp;LoudPerson()sub.sayHi()&nbsp;&nbsp;//sub 不符合预期的代码： var&nbsp;sub:Person&nbsp;=&nbsp;LoudPerson()sub.sayHi()&nbsp;&nbsp;//HellO&nbsp;&nbsp;&lt;-使用了protocol的默认实现 注意，在子类LoudPerson中没有出现override关键字。可以理解为LoudPerson并没有成功注册Greetable在Witness table的方法。所以对于声明为Person实际为LoudPerson的实例，会在编译器通过Person去查找，Person没有实现协议方法，则不产生Witness table，sayHi方法是直接调用的。解决办法是在base类内实现协议方法，无需实现也要提供默认方法。或者将基类标记为final来避免继承。 进一步通过示例去理解： //&nbsp;Defined&nbsp;protocol。protocol&nbsp;A&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int}extension&nbsp;A&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;A&nbsp;class&nbsp;doesn&#39;t&nbsp;have&nbsp;implement&nbsp;of&nbsp;the&nbsp;function。class&nbsp;B：A&nbsp;{}class&nbsp;C：B&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;A&nbsp;class&nbsp;has&nbsp;implement&nbsp;of&nbsp;the&nbsp;function。class&nbsp;D：A&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;}}class&nbsp;E：D&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;Failure&nbsp;cases。B().a()&nbsp;//&nbsp;0C().a()&nbsp;//&nbsp;1(C()&nbsp;as&nbsp;A).a()&nbsp;//&nbsp;0&nbsp;#&nbsp;We&nbsp;thought&nbsp;return&nbsp;1。&nbsp;//&nbsp;Success&nbsp;cases。D().a()&nbsp;//&nbsp;1(D()&nbsp;as&nbsp;A).a()&nbsp;//&nbsp;1E().a()&nbsp;//&nbsp;2(E()&nbsp;as&nbsp;A).a()&nbsp;//&nbsp;2 其他 我们知道Class extension使用的是Static dispatch： class&nbsp;MyClass&nbsp;{}extension&nbsp;MyClass&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;extensionMethod()&nbsp;{}}class&nbsp;SubClass：MyClass&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;extensionMethod()&nbsp;{}} 以上代码会出现错误，提示Declarations in extensions can not be overridden yet。 总结 影响程序的性能标准有三种：初始化方式， 引用指针和方法分派。 文中对比了两种数据结构：Struct和Class的在不同标准下的性能表现。Swift相比OC和其它语言强化了结构体的能力，所以在了解以上性能表现的前提下，通过利用结构体可以有效提升性能。 在此基础上，我们还介绍了功能强大的结构体的类：Protocol Type和Generic。并且介绍了它们如何支持多态以及通过使用有条件限制的泛型如何让程序更快。 参考资料 swift memorylayout witness table video protocol types pdf protocol and value oriented programming in UIKit apps &nbsp;video optimizing swift performance whole module optimizaiton increasing performance by reducing dynamic dispatch protocols generics existential container protocols and generics why swift is swift swift method dispatch swift extension universal dynamic dispatch for method calls compiler performance.md structures and classes 作者简介 亚男，美团点评iOS工程师。2017年加入美团点评，负责美团管家开发，研究编译器原理。目前正积极推动Swift组件化建设。 欢迎加入美团iOS技术交流群，跟作者零距离交流。进群方式：请加美美同学的微信（微信号：MTDPtech01），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 我们餐饮生态技术部是一个技术氛围活跃，大牛聚集的地方。新到店紧握真正的大规模SaaS实战机会，多租户、数据、安全、开放平台等全方位的挑战。业务领域复杂技术挑战多，技术和业务能力迅速提升，最重要的是，加入我们，你将实现真正通过代码来改变行业的梦想。我们欢迎各端人才加入，Java优先。感兴趣的同学赶紧发送简历至 zhaoyanan02@meituan.com，我们期待你的到来。 也许你还想看 iOS系统中导航栏的转场解决方案与最佳实践 美团外卖iOS多端复用的推动、支撑与思考 ARKit：增强现实技术在美团到餐业务的实践" />
<link rel="canonical" href="https://mlh.app/2019/04/29/729156.html" />
<meta property="og:url" content="https://mlh.app/2019/04/29/729156.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"总第297篇 2018年 第89篇 美美今天请来了我们技术团队很厉害的iOS女神亚男小姐姐深度剖析Swift，她特别讲解了如何才能开发出高性能的Swift程序。希望对你有所帮助哦～Enjoy Reading！ 简介 2014年，苹果公司在WWDC上发布Swift这一新的编程语言。经过几年的发展，Swift已经成为iOS开发语言的“中流砥柱”，Swift提供了非常灵活的高级别特性，例如协议、闭包、泛型等，并且Swift还进一步开发了强大的SIL（Swift Intermediate Language）用于对编译器进行优化，使得Swift相比Objective-C运行更快性能更优，Swift内部如何实现性能的优化，我们本文就进行一下解读，希望能对大家有所启发和帮助。 针对Swift性能提升这一问题，我们可以从概念上拆分为两个部分： 编译器：Swift编译器进行的性能优化，从阶段分为编译期和运行期，内容分为时间优化和空间优化。 开发者：通过使用合适的数据结构和关键字，帮助编译器获取更多信息，进行优化。 下面我们将从这两个角度切入，对Swift性能优化进行分析。通过了解编译器对不同数据结构处理的内部实现，来选择最合适的算法机制，并利用编译器的优化特性，编写高性能的程序。 理解Swift的性能 理解Swift的性能，首先要清楚Swift的数据结构，组件关系和编译运行方式。 数据结构Swift的数据结构可以大体拆分为：Class，Struct，Enum。 组件关系组件关系可以分为：inheritance，protocols，generics。 方法分派方式方法分派方式可以分为Static dispatch和Dynamic dispatch。 要在开发中提高Swift性能，需要开发者去了解这几种数据结构和组件关系以及它们的内部实现，从而通过选择最合适的抽象机制来提升性能。 首先我们对于性能标准进行一个概念陈述，性能标准涵盖三个标准： Allocation Reference counting Method dispatch 接下来，我们会分别对这几个指标进行说明。 Allocation 内存分配可以分为堆区栈区，在栈的内存分配速度要高于堆，结构体和类在堆栈分配是不同的。 Stack 基本数据类型和结构体默认在栈区，栈区内存是连续的，通过出栈入栈进行分配和销毁，速度很快，高于堆区。 我们通过一些例子进行说明： //示例&nbsp;1//&nbsp;Allocation//&nbsp;Structstruct&nbsp;Point&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}let&nbsp;point1&nbsp;=&nbsp;Point(x:0,&nbsp;y:0)&nbsp;//进行point1初始化，开辟栈内存var&nbsp;point2&nbsp;=&nbsp;point1&nbsp;//初始化point2，拷贝point1内容，开辟新内存point2.x&nbsp;=&nbsp;5&nbsp;//对point2的操作不会影响point1//&nbsp;use&nbsp;`point1`//&nbsp;use&nbsp;`point2` 以上结构体的内存是在栈区分配的，内部的变量也是内联在栈区。将point1赋值给point2实际操作是在栈区进行了一份拷贝，产生了新的内存消耗point2，这使得point1和point2是完全独立的两个实例，它们之间的操作互不影响。在使用point1和point2之后，会进行销毁。 Heap 高级的数据结构，比如类，分配在堆区。初始化时查找没有使用的内存块，销毁时再从内存块中清除。因为堆区可能存在多线程的操作问题，为了保证线程安全，需要进行加锁操作，因此也是一种性能消耗。 //&nbsp;Allocation//&nbsp;Classclass&nbsp;Point&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}let&nbsp;point1&nbsp;=&nbsp;Point(x:0,&nbsp;y:0)&nbsp;//在堆区分配内存，栈区只是存储地址指针let&nbsp;point2&nbsp;=&nbsp;point1&nbsp;//不产生新的实例，而是对point2增加对堆区内存引用的指针point2.x&nbsp;=&nbsp;5&nbsp;//因为point1和point2是一个实例，所以point1的值也会被修改//&nbsp;use&nbsp;`point1`//&nbsp;use&nbsp;`point2` 以上我们初始化了一个Class类型，在栈区分配一块内存，但是和结构体直接在栈内存储数值不同，我们只在栈区存储了对象的指针，指针指向的对象的内存是分配在堆区的。需要注意的是，为了管理对象内存，在堆区初始化时，除了分配属性内存（这里是Double类型的x，y），还会有额外的两个字段，分别是type和refCount，这个包含了type，refCount和实际属性的结构被称为blue box。 内存分配总结 从初始化角度，Class相比Struct需要在堆区分配内存，进行内存管理，使用了指针，有更强大的特性，但是性能较低。 优化方式： 对于频繁操作（比如通信软件的内容气泡展示），尽量使用Struct替代Class，因为栈内存分配更快，更安全，操作更快。 Reference counting Swift通过引用计数管理堆对象内存，当引用计数为0时，Swift确认没有对象再引用该内存，所以将内存释放。 对于引用计数的管理是一个非常高频的间接操作，并且需要考虑线程安全，使得引用计数的操作需要较高的性能消耗。 对于基本数据类型的Struct来说，没有堆内存分配和引用计数的管理，性能更高更安全，但是对于复杂的结构体，如： //&nbsp;Reference&nbsp;Counting//&nbsp;Struct&nbsp;containing&nbsp;referencesstruct&nbsp;Label&nbsp;{&nbsp;var&nbsp;text:String&nbsp;var&nbsp;font:UIFont&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}let&nbsp;label1&nbsp;=&nbsp;Label(text:&quot;Hi&quot;,&nbsp;font:font)&nbsp;&nbsp;//栈区包含了存储在堆区的指针let&nbsp;label2&nbsp;=&nbsp;label1&nbsp;//label2产生新的指针，和label1一样指向同样的string和font地址//&nbsp;use&nbsp;`label1`//&nbsp;use&nbsp;`label2` 这里看到，包含了引用的结构体相比Class，需要管理双倍的引用计数。每次将结构体作为参数传递给方法或者进行直接拷贝时，都会出现多份引用计数。下图可以比较直观的理解： 备注：包含引用类型的结构体出现Copy的处理方式 Class在拷贝时的处理方式： 引用计数总结 Class在堆区分配内存，需要使用引用计数器进行内存管理。 基本类型的Struct在栈区分配内存，无引用计数管理。 包含强类型的Struct通过指针管理在堆区的属性，对结构体的拷贝会创建新的栈内存，创建多份引用的指针，Class只会有一份。 优化方式 在使用结构体时： 通过使用精确类型，例如UUID替代String（UUID字节长度固定128字节，而不是String任意长度），这样就可以进行内存内联，在栈内存储UUID，我们知道，栈内存管理更快更安全，并且不需要引用计数。 Enum替代String，在栈内管理内存，无引用计数，并且从语法上对于开发者更友好。 Method Dispatch 我们之前在Static dispatch VS Dynamic dispatch中提到过，能够在编译期确定执行方法的方式叫做静态分派Static dispatch，无法在编译期确定，只能在运行时去确定执行方法的分派方式叫做动态分派Dynamic dispatch。 Static dispatch更快，而且静态分派可以进行内联等进一步的优化，使得执行更快速，性能更高。 但是对于多态的情况，我们不能在编译期确定最终的类型，这里就用到了Dynamic dispatch动态分派。动态分派的实现是，每种类型都会创建一张表，表内是一个包含了方法指针的数组。动态分派更灵活，但是因为有查表和跳转的操作，并且因为很多特点对于编译器来说并不明确，所以相当于block了编译器的一些后期优化。所以速度慢于Static dispatch。 下面看一段多态代码，以及分析实现方式： //引用语义实现的多态class&nbsp;Drawable&nbsp;{&nbsp;func&nbsp;draw()&nbsp;{}&nbsp;}class&nbsp;Point&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;override&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}class&nbsp;Line&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:Double&nbsp;override&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}var&nbsp;drawables:[Drawable]for&nbsp;d&nbsp;in&nbsp;drawables&nbsp;{&nbsp;d.draw（）} Method Dispatch总结 Class默认使用Dynamic dispatch，因为在编译期几乎每个环节的信息都无法确定，所以阻碍了编译器的优化，比如inline和whole module inline。 使用Static dispatch代替Dynamic dispatch提升性能 我们知道Static dispatch快于Dynamic dispatch，如何在开发中去尽可能使用Static dispatch。 inheritance constraints继承约束我们可以使用final关键字去修饰Class，以此生成的Final class，使用Static dispatch。 access control访问控制private关键字修饰，使得方法或属性只对当前类可见。编译器会对方法进行Static dispatch。 编译器可以通过whole module optimization检查继承关系，对某些没有标记final的类通过计算，如果能在编译期确定执行的方法，则使用Static dispatch。Struct默认使用Static dispatch。 Swift快于OC的一个关键是可以消解动态分派。 总结 Swift提供了更灵活的Struct，用以在内存、引用计数、方法分派等角度去进行性能的优化，在正确的时机选择正确的数据结构，可以使我们的代码性能更快更安全。 延伸 你可能会问Struct如何实现多态呢?答案是protocol oriented programming。 以上分析了影响性能的几个标准，那么不同的算法机制Class，Protocol Types和Generic code，它们在这三方面的表现如何，Protocol Type和Generic code分别是怎么实现的呢？我们带着这个问题看下去。 Protocol Type 这里我们会讨论Protocol Type如何存储和拷贝变量，以及方法分派是如何实现的。不通过继承或者引用语义的多态： protocol&nbsp;Drawable&nbsp;{&nbsp;func&nbsp;draw()&nbsp;}struct&nbsp;Point&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x,&nbsp;y:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}struct&nbsp;Line&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:Double&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}}var&nbsp;drawables:[Drawable]&nbsp;//遵守了Drawable协议的类型集合，可能是point或者linefor&nbsp;d&nbsp;in&nbsp;drawables&nbsp;{&nbsp;d.draw（）} 以上通过Protocol Type实现多态，几个类之间没有继承关系，故不能按照惯例借助V-Table实现动态分派。 如果想了解Vtable和Witness table实现，可以进行点击查看，这里不做细节说明。因为Point和Line的尺寸不同，数组存储数据实现一致性存储，使用了Existential Container。查找正确的执行方法则使用了 Protoloc Witness Table。 Existential Container Existential Container是一种特殊的内存布局方式，用于管理遵守了相同协议的数据类型Protocol Type，这些数据类型因为不共享同一继承关系（这是V-Table实现的前提），并且内存空间尺寸不同，使用Existential Container进行管理，使其具有存储的一致性。 结构如下： 三个词大小的valueBuffer这里介绍一下valueBuffer结构，valueBuffer有三个词，每个词包含8个字节，存储的可能是值，也可能是对象的指针。对于small value（空间小于valueBuffer），直接存储在valueBuffer的地址内， inline valueBuffer，无额外堆内存初始化。当值的数量大于3个属性即large value，或者总尺寸超过valueBuffer的占位，就会在堆区开辟内存，将其存储在堆区，valueBuffer存储内存指针。 value witness table的引用因为Protocol Type的类型不同，内存空间，初始化方法等都不相同，为了对Protocol Type生命周期进行专项管理，用到了Value Witness Table。 protocol witness table的引用管理Protocol Type的方法分派。 内存分布如下： 1.&nbsp;payload_data_0&nbsp;=&nbsp;0x0000000000000004,2.&nbsp;payload_data_1&nbsp;=&nbsp;0x0000000000000000,3.&nbsp;payload_data_2&nbsp;=&nbsp;0x0000000000000000,4.&nbsp;instance_type&nbsp;=&nbsp;0x000000010d6dc408&nbsp;ExistentialContainers`type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metadata&nbsp;for&nbsp;ExistentialContainers.Car,5.&nbsp;protocol_witness_0&nbsp;=&nbsp;0x000000010d6dc1c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExistentialContainers&nbsp;protocol&nbsp;witness&nbsp;table&nbsp;for&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExistentialContainers.Car:ExistentialContainers.Drivable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;ExistentialContainers Protocol Witness Table（PWT） 为了实现Class多态也就是引用语义多态，需要V-Table来实现，但是V-Table的前提是具有同一个父类即共享相同的继承关系，但是对于Protocol Type来说，并不具备此特征，故为了支持Struct的多态，需要用到protocol oriented programming机制，也就是借助Protocol Witness Table来实现（细节可以点击Vtable和witness table实现，每个结构体会创造PWT表，内部包含指针，指向方法具体实现）。 Value Witness Table（VWT） 用于管理任意值的初始化、拷贝、销毁。 Value Witness Table的结构如上，是用于管理遵守了协议的Protocol Type实例的初始化，拷贝，内存消减和销毁的。 Value Witness Table在SIL中还可以拆分为%relative_vwtable和%absolute_vwtable，我们这里先不做展开。 Value Witness Table和Protocol Witness Table通过分工，去管理Protocol Type实例的内存管理（初始化，拷贝，销毁）和方法调用。 我们来借助具体的示例进行进一步了解： //&nbsp;Protocol&nbsp;Types//&nbsp;The&nbsp;Existential&nbsp;Container&nbsp;in&nbsp;actionfunc&nbsp;drawACopy(local&nbsp;：Drawable)&nbsp;{&nbsp;local.draw()}let&nbsp;val&nbsp;:Drawable&nbsp;=&nbsp;Point()drawACopy(val) 在Swift编译器中，通过Existential Container实现的伪代码如下： //&nbsp;Protocol&nbsp;Types//&nbsp;The&nbsp;Existential&nbsp;Container&nbsp;in&nbsp;actionfunc&nbsp;drawACopy(local&nbsp;:Drawable)&nbsp;{&nbsp;local.draw()}let&nbsp;val&nbsp;:Drawable&nbsp;=&nbsp;Point()drawACopy(val)//existential&nbsp;container的伪代码结构struct&nbsp;ExistContDrawable&nbsp;{&nbsp;var&nbsp;valueBuffer:(Int,&nbsp;Int,&nbsp;Int)&nbsp;var&nbsp;vwt:ValueWitnessTable&nbsp;var&nbsp;pwt:DrawableProtocolWitnessTable}//&nbsp;drawACopy方法生成的伪代码func&nbsp;drawACopy(val:ExistContDrawable)&nbsp;{&nbsp;//将existential&nbsp;container传入&nbsp;var&nbsp;local&nbsp;=&nbsp;ExistContDrawable()&nbsp;&nbsp;//初始化container&nbsp;let&nbsp;vwt&nbsp;=&nbsp;val.vwt&nbsp;//获取value&nbsp;witness&nbsp;table，用于管理生命周期&nbsp;let&nbsp;pwt&nbsp;=&nbsp;val.pwt&nbsp;//获取protocol&nbsp;witness&nbsp;table，用于进行方法分派&nbsp;local.type&nbsp;=&nbsp;type&nbsp;&nbsp;local.pwt&nbsp;=&nbsp;pwt&nbsp;vwt.allocateBufferAndCopyValue(&amp;local,&nbsp;val)&nbsp;&nbsp;//vwt进行生命周期管理，初始化或者拷贝&nbsp;pwt.draw(vwt.projectBuffer(&amp;local))&nbsp;//pwt查找方法，这里说一下projectBuffer，因为不同类型在内存中是不同的（small&nbsp;value内联在栈内，large&nbsp;value初始化在堆内，栈持有指针），所以方法的确定也是和类型相关的，我们知道，查找方法时是通过当前对象的地址，通过一定的位移去查找方法地址。&nbsp;vwt.destructAndDeallocateBuffer(temp)&nbsp;//vwt进行生命周期管理，销毁内存} Protocol Type 存储属性 我们知道，Swift中Class的实例和属性都存储在堆区，Struct实例在栈区，如果包含指针属性则存储在堆区，Protocol Type如何存储属性？Small Number通过Existential Container内联实现，大数存在堆区。如何处理Copy呢? Protocol大数的Copy优化 在出现Copy情况时： let&nbsp;aLine&nbsp;=&nbsp;Line(1.0,&nbsp;1.0,&nbsp;1.0,&nbsp;3.0)let&nbsp;pair&nbsp;=&nbsp;Pair(aLine,&nbsp;aLine)let&nbsp;copy&nbsp;=&nbsp;pair 会将新的Exsitential Container的valueBuffer指向同一个value即创建指针引用，但是如果要改变值怎么办?我们知道Struct值的修改和Class不同，Copy是不应该影响原实例的值的。 这里用到了一个技术叫做Indirect Storage With Copy-On-Write，即优先使用内存指针。通过提高内存指针的使用，来降低堆区内存的初始化。降低内存消耗。在需要修改值的时候，会先检测引用计数检测，如果有大于1的引用计数，则开辟新内存，创建新的实例。在对内容进行变更的时候，会开启一块新的内存，伪代码如下： class&nbsp;LineStorage&nbsp;{&nbsp;var&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:Double&nbsp;}struct&nbsp;Line&nbsp;:Drawable&nbsp;{&nbsp;var&nbsp;storage&nbsp;:LineStorage&nbsp;init()&nbsp;{&nbsp;storage&nbsp;=&nbsp;LineStorage(Point(),&nbsp;Point())&nbsp;}&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}&nbsp;mutating&nbsp;func&nbsp;move()&nbsp;{&nbsp;&nbsp;&nbsp;if&nbsp;!isUniquelyReferencedNonObjc(&amp;storage)&nbsp;{&nbsp;//如何存在多份引用，则开启新内存，否则直接修改&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage&nbsp;=&nbsp;LineStorage(storage)&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;storage。start&nbsp;=&nbsp;...&nbsp;&nbsp;&nbsp;}} 这样实现的目的：通过多份指针去引用同一份地址的成本远远低于开辟多份堆内存。以下对比图： Protocol Type多态总结 支持Protocol Type的动态多态（Dynamic Polymorphism）行为。 通过使用Witness Table和Existential Container来实现。 对于大数的拷贝可以通过Indirect Storage间接存储来进行优化。 说到动态多态Dynamic Polymorphism，我们就要问了，什么是静态多态Static Polymorphism，看看下面示例： //&nbsp;Drawing&nbsp;a&nbsp;copyprotocol&nbsp;Drawable&nbsp;{&nbsp;func&nbsp;draw()}func&nbsp;drawACopy(local&nbsp;:Drawable)&nbsp;{&nbsp;local.draw()}let&nbsp;line&nbsp;=&nbsp;Line()drawACopy(line)//&nbsp;...let&nbsp;point&nbsp;=&nbsp;Point()drawACopy(point) 这种情况我们就可以用到泛型Generic code来实现，进行进一步优化。 泛型 我们接下来会讨论泛型属性的存储方式和泛型方法是如何分派的。泛型和Protocol Type的区别在于： 泛型支持的是静态多态。 每个调用上下文只有一种类型。查看下面的示例，foo和bar方法是同一种类型。 在调用链中会通过类型降级进行类型取代。 对于以下示例： func&nbsp;foo&lt;T:Drawable&gt;(local&nbsp;:T)&nbsp;{&nbsp;bar(local)}func&nbsp;bar&lt;T:Drawable&gt;(local:T)&nbsp;{&nbsp;…&nbsp;}let&nbsp;point&nbsp;=&nbsp;Point()foo(point) 分析方法foo和bar的调用过程： //调用过程foo(point)--&gt;foo&lt;T&nbsp;=&nbsp;Point&gt;(point)&nbsp;&nbsp;&nbsp;//在方法执行时，Swift将泛型T绑定为调用方使用的具体类型，这里为Point&nbsp;bar(local)&nbsp;--&gt;bar&lt;T&nbsp;=&nbsp;Point&gt;(local)&nbsp;//在调用内部bar方法时，会使用foo已经绑定的变量类型Point，可以看到，泛型T在这里已经被降级，通过类型Point进行取代 泛型方法调用的具体实现为： 同一种类型的任何实例，都共享同样的实现，即使用同一个Protocol Witness Table。 使用Protocol/Value Witness Table。 每个调用上下文只有一种类型：这里没有使用Existential Container， 而是将Protocol/Value Witness Table作为调用方的额外参数进行传递。 变量初始化和方法调用，都使用传入的VWT和PWT来执行。 看到这里，我们并不觉得泛型比Protocol Type有什么更快的特性，泛型如何更快呢?静态多态前提下可以进行进一步的优化，称为特定泛型优化。 泛型特化 静态多态：在调用站中只有一种类型Swift使用只有一种类型的特点，来进行类型降级取代。 类型降级后，产生特定类型的方法 为泛型的每个类型创造对应的方法这时候你可能会问，那每一种类型都产生一个新的方法，代码空间岂不爆炸? 静态多态下进行特定优化specialization因为是静态多态。所以可以进行很强大的优化，比如进行内联实现，并且通过获取上下文来进行更进一步的优化。从而降低方法数量。优化后可以更精确和具体。 例如： func&nbsp;min&lt;T:Comparable&gt;(x:T,&nbsp;y:T)&nbsp;-&gt;&nbsp;T&nbsp;{&nbsp;&nbsp;return&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;?&nbsp;y&nbsp;:&nbsp;x} 从普通的泛型展开如下，因为要支持所有类型的min方法，所以需要对泛型类型进行计算，包括初始化地址、内存分配、生命周期管理等。除了对value的操作，还要对方法进行操作。这是一个非常的的工程。 func&nbsp;min&lt;T:Comparable&gt;(x:T,&nbsp;y:T,&nbsp;FTable:FunctionTable)&nbsp;-&gt;&nbsp;T&nbsp;{&nbsp;&nbsp;let&nbsp;xCopy&nbsp;=&nbsp;FTable.copy(x)&nbsp;&nbsp;let&nbsp;yCopy&nbsp;=&nbsp;FTable.copy(y)&nbsp;&nbsp;let&nbsp;m&nbsp;=&nbsp;FTable.lessThan(yCopy，&nbsp;xCopy)&nbsp;?&nbsp;y&nbsp;:x&nbsp;&nbsp;FTable.release(x)&nbsp;&nbsp;FTable.release(y)&nbsp;&nbsp;return&nbsp;m} 在确定入参类型时，比如Int，编译器可以通过泛型特化，进行类型取代（Type Substitute），优化为： func&nbsp;min&lt;Int&gt;(x:Int,&nbsp;y:Int)&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;return&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;?&nbsp;y&nbsp;:x} 泛型特化specilization是何时发生的? 在使用特定优化时，调用方需要进行类型推断，这里需要知晓类型的上下文，例如类型的定义和内部方法实现。如果调用方和类型是单独编译的，就无法在调用方推断类型的内部实行，就无法使用特定优化，保证这些代码一起进行编译，这里就用到了whole module optimization。而whole module optimization是对于调用方和被调用方的方法在不同文件时，对其进行泛型特化优化的前提。 泛型进一步优化 特定泛型的进一步优化： //&nbsp;Pairs&nbsp;in&nbsp;our&nbsp;program&nbsp;using&nbsp;generic&nbsp;typesstruct&nbsp;Pair&lt;T&nbsp;:Drawable&gt;&nbsp;{&nbsp;init(_&nbsp;f:T，&nbsp;_&nbsp;s:T)&nbsp;{&nbsp;first&nbsp;=&nbsp;f&nbsp;;&nbsp;second&nbsp;=&nbsp;s&nbsp;}&nbsp;var&nbsp;first:T&nbsp;var&nbsp;second:T}let&nbsp;pairOfLines&nbsp;=&nbsp;Pair(Line(),&nbsp;Line())//&nbsp;...let&nbsp;pairOfPoint&nbsp;=&nbsp;Pair(Point(),&nbsp;Point()) 在用到多种泛型，且确定泛型类型不会在运行时修改时，就可以对成对泛型的使用进行进一步优化。 优化的方式是将泛型的内存分配由指针指定，变为内存内联，不再有额外的堆初始化消耗。请注意，因为进行了存储内联，已经确定了泛型特定类型的内存分布，泛型的内存内联不能存储不同类型。所以再次强调此种优化只适用于在运行时不会修改泛型类型，即不能同时支持一个方法中包含line和point两种类型。 whole module optimization whole module optimization是用于Swift编译器的优化机制。可以通过-whole-module-optimization （或 -wmo）进行打开。在XCode 8之后默认打开。 Swift Package Manager在release模式默认使用whole module optimization。 module是多个文件集合。 编译器在对源文件进行语法分析之后，会对其进行优化，生成机器码并输出目标文件，之后链接器联合所有的目标文件生成共享库或可执行文件。 whole module optimization通过跨函数优化，可以进行内联等优化操作，对于泛型，可以通过获取类型的具体实现来进行推断优化，进行类型降级方法内联，删除多余方法等操作。 全模块优化的优势 编译器掌握所有方法的实现，可以进行内联和泛型特化等优化，通过计算所有方法的引用，移除多余的引用计数操作。 通过知晓所有的非公共方法，如果这写方法没有被使用，就可以对其进行消除。 如何降低编译时间 和全模块优化相反的是文件优化，即对单个文件进行编译。这样的好处在于可以并行执行，并且对于没有修改的文件不会再次编译。缺点在于编译器无法获知全貌，无法进行深度优化，全模块优化如何避免没修改的文件再次编译。 编译器内部运行过程分为：语法分析，类型检查，SIL优化，LLVM后端处理。 语法分析和类型检查一般很快，SIL优化执行了重要的Swift特定优化，例如泛型特化和方法内联等，该过程大概占用真个编译时间的三分之一。LLVM后端执行占用了大部分的编译时间，用于运行降级优化和生成代码。 进行全模块优化后，SIL优化会将模块再次拆分为多个部分，LLVM后端通过多线程对这些拆分模块进行处理，对于没有修改的部分，不会进行再处理。这样就避免了修改一小部分，整个大模块进行LLVM后端执行，并且多线程并行操作也会缩短处理时间。 扩展：Swift的隐藏“Bug” Swift因为方法分派机制问题，所以在设计和优化后，会产生和我们常规理解不太一致的结果，这当然不能算Bug。但是还是要单独进行说明，避免在开发过程中，因为对机制的掌握不足，造成预期和执行出入导致的问题。 Message dispatch 我们通过上面说明结合Static dispatch VS Dynamic dispatch对方法分派方式有了了解。这里需要对Objective-C的方法分派方式进行说明。 熟悉OC的人都知道，OC采用了运行时机制使用obj_msgSend发送消息，runtime非常的灵活，我们不仅可以对方法调用采用swizzling，对于对象也可以通过isa-swizzling来扩展功能，应用场景有我们常用的hook和大家熟知的KVO。 大家在使用Swift进行开发时都会问，Swift是否可以使用OC的运行时和消息转发机制呢？答案是可以。 Swift可以通过关键字dynamic对方法进行标记，这样就会告诉编译器，此方法使用的是OC的运行时机制。 注意：我们常见的关键字@ObjC并不会改变Swift原有的方法分派机制，关键字@ObjC的作用只是告诉编译器，该段代码对于OC可见。 总结来说，Swift通过dynamic关键字的扩展后，一共包含三种方法分派方式：Static dispatch，Table dispatch和Message dispatch。下表为不同的数据结构在不同情况下采取的分派方式： 如果在开发过程中，错误的混合了这几种分派方式，就可能出现Bug，以下我们对这些Bug进行分析： SR-584 此情况是在子类的extension中重载父类方法时，出现和预期不同的行为。 class&nbsp;Base:NSObject&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;directProperty:String&nbsp;{&nbsp;return&nbsp;&quot;This&nbsp;is&nbsp;Base&quot;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;indirectProperty:String&nbsp;{&nbsp;return&nbsp;directProperty&nbsp;}}class&nbsp;Sub:Base&nbsp;{&nbsp;}extension&nbsp;Sub&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;var&nbsp;directProperty:String&nbsp;{&nbsp;return&nbsp;&quot;This&nbsp;is&nbsp;Sub&quot;&nbsp;}} 执行以下代码，直接调用没有问题： Base().directProperty&nbsp;//&nbsp;“This&nbsp;is&nbsp;Base”Sub().directProperty&nbsp;//&nbsp;“This&nbsp;is&nbsp;Sub” 间接调用结果和预期不同： Base（）。indirectProperty&nbsp;//&nbsp;“This&nbsp;is&nbsp;Base”Sub（）。indirectProperty&nbsp;//&nbsp;expected&nbsp;&quot;this&nbsp;is&nbsp;Sub&quot;，but&nbsp;is&nbsp;“This&nbsp;is&nbsp;Base”&nbsp;&lt;-&nbsp;Unexpected! 在Base.directProperty前添加dynamic关键字就可以获得&quot;this is Sub&quot;的结果。Swift在extension 文档中说明，不能在extension中重载已经存在的方法。 “Extensions can add new functionality to a type, but they cannot override existing functionality.” 会出现警告：Cannot override a non-dynamic class declaration from an extension。 出现这个问题的原因是，NSObject的extension是使用的Message dispatch，而Initial Declaration使用的是Table dispath（查看上图 Swift Dispatch Method）。extension重载的方法添加在了Message dispatch内，没有修改虚函数表，虚函数表内还是父类的方法，故会执行父类方法。想在extension重载方法，需要标明dynamic来使用Message dispatch。 SR-103 协议的扩展内实现的方法，无法被遵守类的子类重载： protocol&nbsp;Greetable&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;sayHi()}extension&nbsp;Greetable&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;sayHi()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Hello&quot;）&nbsp;&nbsp;&nbsp;&nbsp;}}func&nbsp;greetings(greeter：Greetable)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;greeter.sayHi()} 现在定义一个遵守了协议的类Person。遵守协议类的子类LoudPerson： class&nbsp;Person:Greetable&nbsp;{}class&nbsp;LoudPerson:Person&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;sayHi()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;sub&quot;)&nbsp;&nbsp;&nbsp;&nbsp;}} 执行下面代码结果为： var&nbsp;sub:LoudPerson&nbsp;=&nbsp;LoudPerson()sub.sayHi()&nbsp;&nbsp;//sub 不符合预期的代码： var&nbsp;sub:Person&nbsp;=&nbsp;LoudPerson()sub.sayHi()&nbsp;&nbsp;//HellO&nbsp;&nbsp;&lt;-使用了protocol的默认实现 注意，在子类LoudPerson中没有出现override关键字。可以理解为LoudPerson并没有成功注册Greetable在Witness table的方法。所以对于声明为Person实际为LoudPerson的实例，会在编译器通过Person去查找，Person没有实现协议方法，则不产生Witness table，sayHi方法是直接调用的。解决办法是在base类内实现协议方法，无需实现也要提供默认方法。或者将基类标记为final来避免继承。 进一步通过示例去理解： //&nbsp;Defined&nbsp;protocol。protocol&nbsp;A&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int}extension&nbsp;A&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;A&nbsp;class&nbsp;doesn&#39;t&nbsp;have&nbsp;implement&nbsp;of&nbsp;the&nbsp;function。class&nbsp;B：A&nbsp;{}class&nbsp;C：B&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;A&nbsp;class&nbsp;has&nbsp;implement&nbsp;of&nbsp;the&nbsp;function。class&nbsp;D：A&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;}}class&nbsp;E：D&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;Int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;Failure&nbsp;cases。B().a()&nbsp;//&nbsp;0C().a()&nbsp;//&nbsp;1(C()&nbsp;as&nbsp;A).a()&nbsp;//&nbsp;0&nbsp;#&nbsp;We&nbsp;thought&nbsp;return&nbsp;1。&nbsp;//&nbsp;Success&nbsp;cases。D().a()&nbsp;//&nbsp;1(D()&nbsp;as&nbsp;A).a()&nbsp;//&nbsp;1E().a()&nbsp;//&nbsp;2(E()&nbsp;as&nbsp;A).a()&nbsp;//&nbsp;2 其他 我们知道Class extension使用的是Static dispatch： class&nbsp;MyClass&nbsp;{}extension&nbsp;MyClass&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;extensionMethod()&nbsp;{}}class&nbsp;SubClass：MyClass&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;extensionMethod()&nbsp;{}} 以上代码会出现错误，提示Declarations in extensions can not be overridden yet。 总结 影响程序的性能标准有三种：初始化方式， 引用指针和方法分派。 文中对比了两种数据结构：Struct和Class的在不同标准下的性能表现。Swift相比OC和其它语言强化了结构体的能力，所以在了解以上性能表现的前提下，通过利用结构体可以有效提升性能。 在此基础上，我们还介绍了功能强大的结构体的类：Protocol Type和Generic。并且介绍了它们如何支持多态以及通过使用有条件限制的泛型如何让程序更快。 参考资料 swift memorylayout witness table video protocol types pdf protocol and value oriented programming in UIKit apps &nbsp;video optimizing swift performance whole module optimizaiton increasing performance by reducing dynamic dispatch protocols generics existential container protocols and generics why swift is swift swift method dispatch swift extension universal dynamic dispatch for method calls compiler performance.md structures and classes 作者简介 亚男，美团点评iOS工程师。2017年加入美团点评，负责美团管家开发，研究编译器原理。目前正积极推动Swift组件化建设。 欢迎加入美团iOS技术交流群，跟作者零距离交流。进群方式：请加美美同学的微信（微信号：MTDPtech01），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 我们餐饮生态技术部是一个技术氛围活跃，大牛聚集的地方。新到店紧握真正的大规模SaaS实战机会，多租户、数据、安全、开放平台等全方位的挑战。业务领域复杂技术挑战多，技术和业务能力迅速提升，最重要的是，加入我们，你将实现真正通过代码来改变行业的梦想。我们欢迎各端人才加入，Java优先。感兴趣的同学赶紧发送简历至 zhaoyanan02@meituan.com，我们期待你的到来。 也许你还想看 iOS系统中导航栏的转场解决方案与最佳实践 美团外卖iOS多端复用的推动、支撑与思考 ARKit：增强现实技术在美团到餐业务的实践","@type":"BlogPosting","url":"https://mlh.app/2019/04/29/729156.html","headline":"【基本功】深入剖析Swift性能优化","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/29/729156.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【基本功】深入剖析Swift性能优化</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;" data-mpa-powered-by="yiban.io"><img class="" data-copyright="0" data-ratio="0.10546875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png" data-type="png" data-w="1280" style="box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png"></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;text-align: center;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;">总第297篇</span></strong></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;text-align: center;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;">2018年 第89篇</span></strong></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;text-align: center;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><br></span></strong></p> 
<section data-role="outer" label="Powered by 135editor.com" style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);font-family: 微软雅黑;"> 
 <section data-role="outer" label="Powered by 135editor.com"> 
  <section class="_135editor" data-tools="135编辑器" data-id="45730" style="border-width: 0px;border-style: none;border-color: initial;"> 
   <section data-width="100%" style="width: 558px;border-width: 1px;border-style: solid;border-color: rgb(198, 198, 199);border-radius: 10px;"> 
    <section class="135brush" style="margin: 15px 10px;text-align: center;"> 
     <img border="0" class="" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsW2Kx42GFhBJtImE58e0nhia18icicD9my85q5ibGzak1SnPxR1S0y8CIeibZThqQEgJYm5hf7YqgHIwLA/640?wx_fmt=jpeg" data-type="jpeg" data-w="800" data-width="100%" height="" opacity="" style="margin-top: 5px;height: 160px;caret-color: red;width: 160px;" title="undefined" width="100%" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsW2Kx42GFhBJtImE58e0nhia18icicD9my85q5ibGzak1SnPxR1S0y8CIeibZThqQEgJYm5hf7YqgHIwLA/640?wx_fmt=jpeg"> 
     <br> 
    </section> 
    <section class="135brush" data-style="margin: 5px 0px; font-size: 14px; padding:5px; color: rgb(198,198,199); text-align: left; line-height: 1.5;" style="margin: 15px;"> 
     <p style="margin-top: 5px;margin-bottom: 5px;padding: 5px;font-size: 14px;color: rgb(198, 198, 199);line-height: 1.5;"><span style="color: rgb(136, 136, 136);"><span style="font-family: Helvetica, Arial, sans-serif;font-size: 14px;"><span style="">美美今天请来了我们技术团队很厉害的iOS女神亚男小姐姐深度剖析Swift，她特别讲解了如何才能开发出高性能的</span>Swift程序。希望对你有所帮助哦～</span><span style="font-family: Helvetica, Arial, sans-serif;letter-spacing: 0px;">Enjoy Reading！</span></span></p> 
    </section> 
   </section> 
  </section> 
 </section> 
</section> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;color: rgb(51, 51, 51);box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><span style="max-width: 100%;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"></strong></span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;margin-left: 0.5em;margin-right: 0.5em;"> 
 <h2 style="color: rgb(62, 62, 62);white-space: normal;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">简介</span></strong></h2> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">2014年，苹果公司在WWDC上发布Swift这一新的编程语言。经过几年的发展，Swift已经成为iOS开发语言的“中流砥柱”，Swift提供了非常灵活的高级别特性，例如协议、闭包、泛型等，并且Swift还进一步开发了强大的SIL（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">Swift Intermediate Language）</span><span style="font-size: 15px;">用于对编译器进行优化，使得Swift相比Objective-C运行更快性能更优，Swift内部如何实现性能的优化，我们本文就进行一下解读，希望能对大家有所启发和帮助。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">针对Swift性能提升这一问题，我们可以从概念上拆分为两个部分：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">编译器</strong>：Swift编译器进行的性能优化，从阶段分为编译期和运行期，内容分为时间优化和空间优化。</span></p></li> 
  <li><p><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">开发者</strong>：通过使用合适的数据结构和关键字，帮助编译器获取更多信息，进行优化。</span></p></li> 
 </ol> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">下面我们将从这两个角度切入，对Swift性能优化进行分析。通过了解编译器对不同数据结构处理的内部实现，来选择最合适的算法机制，并利用编译器的优化特性，编写高性能的程序。</span></p> 
 <h2 style="color: rgb(62, 62, 62);white-space: normal;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">理解Swift的性能</span></strong></h2> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">理解Swift的性能，首先要清楚Swift的数据结构，组件关系和编译运行方式。</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;"><strong>数据结构</strong></span></p><p><span style="font-size: 15px;">Swift的数据结构可以大体拆分为：Class，Struct，Enum。</span></p></li> 
  <li><p><span style="font-size: 15px;"><strong>组件关系</strong></span></p><p><span style="font-size: 15px;">组件关系可以分为：inheritance，protocols，generics。</span></p></li> 
  <li><p><span style="font-size: 15px;"><strong>方法分派方式</strong></span></p><p><span style="font-size: 15px;">方法分派方式可以分为Static dispatch和Dynamic dispatch。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">要在开发中提高Swift性能，需要开发者去了解这几种数据结构和组件关系以及它们的内部实现，从而通过选择最合适的抽象机制来提升性能。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">首先我们对于性能标准进行一个概念陈述，性能标准涵盖三个标准：</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.3145833333333333" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42Qyibm6RCPjDsWLtYOFQNUaLIV4nopMneia5oJU2ojbRlWwKM5vlEwydos1Q/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42Qyibm6RCPjDsWLtYOFQNUaLIV4nopMneia5oJU2ojbRlWwKM5vlEwydos1Q/640?wx_fmt=png"></p> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"> 
   <br> 
  </figcaption> 
 </figure> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">Allocation</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">Reference counting</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">Method dispatch</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">接下来，我们会分别对这几个指标进行说明。</span></p> 
 <h3><span style="font-size: 18px;"><strong>Allocation</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">内存分配可以分为堆区栈区，在栈的内存分配速度要高于堆，结构体和类在堆栈分配是不同的。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">Stack</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">基本数据类型和结构体默认在栈区，栈区内存是连续的，通过出栈入栈进行分配和销毁，速度很快，高于堆区。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们通过一些例子进行说明：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//示例&nbsp;1</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Allocation</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Struct</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;Point&nbsp;{<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;x,&nbsp;y:Double<br>&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">draw</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{&nbsp;…&nbsp;}<br>}<br>let&nbsp;point1&nbsp;=&nbsp;Point(x:<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>,&nbsp;y:<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>)&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//进行point1初始化，开辟栈内存</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;point2&nbsp;=&nbsp;point1&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//初始化point2，拷贝point1内容，开辟新内存</span><br>point2.x&nbsp;=&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">5</span>&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//对point2的操作不会影响point1</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;use&nbsp;`point1`</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;use&nbsp;`point2`</span><br></span></code></pre> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"> 
   <span style="font-size: 15px;"><br></span> 
  </figcaption> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.6958333333333333" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42Qyib8jKgLVK89UhzyjZoGEXX7N5BibnouSTSibchb8ib2xz2mXibEwsxuK8sdA/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42Qyib8jKgLVK89UhzyjZoGEXX7N5BibnouSTSibchb8ib2xz2mXibEwsxuK8sdA/640?wx_fmt=png"></p> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"> 
   <span style="font-size: 15px;"></span> 
  </figcaption> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">以上结构体的内存是在栈区分配的，内部的变量也是内联在栈区。将</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">point1</span></code><span style="font-size: 15px;">赋值给</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">point2</span></code><span style="font-size: 15px;">实际操作是在栈区进行了一份拷贝，产生了新的内存消耗</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">point2</span></code><span style="font-size: 15px;">，这使得</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">point1</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">point2</span></code><span style="font-size: 15px;">是完全独立的两个实例，它们之间的操作互不影响。在使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">point1</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">point2</span></code><span style="font-size: 15px;">之后，会进行销毁。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">Heap</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">高级的数据结构，比如类，分配在堆区。初始化时查找没有使用的内存块，销毁时再从内存块中清除。因为堆区可能存在多线程的操作问题，为了保证线程安全，需要进行加锁操作，因此也是一种性能消耗。</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs cs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Allocation</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Class</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Point</span>&nbsp;{<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;x,&nbsp;y:<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Double<br>&nbsp;func&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">draw</span>(<span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;"></span>)&nbsp;</span>{&nbsp;…&nbsp;}<br>}<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;point1&nbsp;=&nbsp;Point(x:<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>,&nbsp;y:<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>)&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//在堆区分配内存，栈区只是存储地址指针</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;point2&nbsp;=&nbsp;point1&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//不产生新的实例，而是对point2增加对堆区内存引用的指针</span><br>point2.x&nbsp;=&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">5</span>&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//因为point1和point2是一个实例，所以point1的值也会被修改</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;use&nbsp;`point1`</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;use&nbsp;`point2`</span><br></span></code></pre> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"> 
   <br> 
  </figcaption> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.43333333333333335" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibUYIrnT7mibhnEWCvWEbILK42xwmiacKuw03TibHqxJBFmAjIM3JeWkASA/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibUYIrnT7mibhnEWCvWEbILK42xwmiacKuw03TibHqxJBFmAjIM3JeWkASA/640?wx_fmt=png"></p> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">以上我们初始化了一个</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">类型，在栈区分配一块内存，但是和结构体直接在栈内存储数值不同，我们只在栈区存储了对象的指针，指针指向的对象的内存是分配在堆区的。需要注意的是，为了管理对象内存，在堆区初始化时，除了分配属性内存（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">这里是Double类型的x，y</span><span style="font-size: 15px;">），还会有额外的两个字段，分别是</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">type</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">refCount</span></code><span style="font-size: 15px;">，这个包含了</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">type</span></code><span style="font-size: 15px;">，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">refCount</span></code><span style="font-size: 15px;">和实际属性的结构被称为</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">blue box</span></code><span style="font-size: 15px;">。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">内存分配总结</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">从初始化角度，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">相比</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">需要在堆区分配内存，进行内存管理，使用了指针，有更强大的特性，但是性能较低。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">优化方式：</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于频繁操作（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">比如通信软件的内容气泡展示</span><span style="font-size: 15px;">），尽量使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">替代</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">，因为栈内存分配更快，更安全，操作更快。</span></p> 
 <h3><span style="font-size: 18px;"><strong>Reference counting</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Swift通过引用计数管理堆对象内存，当引用计数为0时，Swift确认没有对象再引用该内存，所以将内存释放。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于引用计数的管理是一个非常高频的间接操作，并且需要考虑线程安全，使得引用计数的操作需要较高的性能消耗。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于基本数据类型的</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">来说，没有堆内存分配和引用计数的管理，性能更高更安全，但是对于复杂的结构体，如：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs cs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Reference&nbsp;Counting</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Struct&nbsp;containing&nbsp;references</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;Label&nbsp;{<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;text:String<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;font:<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">UIFont<br>&nbsp;func&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">draw</span>(<span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;"></span>)&nbsp;</span>{&nbsp;…&nbsp;}<br>}<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;label1&nbsp;=&nbsp;Label(text:<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Hi"</span>,&nbsp;font:font)&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//栈区包含了存储在堆区的指针</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;label2&nbsp;=&nbsp;label1&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//label2产生新的指针，和label1一样指向同样的string和font地址</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;use&nbsp;`label1`</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;use&nbsp;`label2`</span><br></span></code></pre> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"> 
   <br> 
  </figcaption> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1.1" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibrzdA3EvZkrKPJOWCIwhCvD12c3Vqc9yMTkukvvSXsjEMxx6I82bN6A/640?wx_fmt=png" data-type="png" data-w="240" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibrzdA3EvZkrKPJOWCIwhCvD12c3Vqc9yMTkukvvSXsjEMxx6I82bN6A/640?wx_fmt=png"></p> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这里看到，包含了引用的结构体相比</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">，需要管理双倍的引用计数。每次将结构体作为参数传递给方法或者进行直接拷贝时，都会出现多份引用计数。下图可以比较直观的理解：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.4979166666666667" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyiblDKYppmoAggeQCSPy5DzhPEjhJ3PqM7Rzljwew5AmHd8xcleItjyBQ/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyiblDKYppmoAggeQCSPy5DzhPEjhJ3PqM7Rzljwew5AmHd8xcleItjyBQ/640?wx_fmt=png"></p> 
 <center style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <span style="font-size: 14px;color: rgb(136, 136, 136);">备注：包含引用类型的结构体出现Copy的处理方式</span> 
 </center> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Class在拷贝时的处理方式：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.5020833333333333" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibWuz9dj5gxXTMQIbtcnX4DLGLX2CFZJ9KLu2GnZsDhNRjYHn9BoiaxlA/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibWuz9dj5gxXTMQIbtcnX4DLGLX2CFZJ9KLu2GnZsDhNRjYHn9BoiaxlA/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">引用计数总结</strong></span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">在堆区分配内存，需要使用引用计数器进行内存管理。</span></p></li> 
  <li><p><span style="font-size: 15px;">基本类型的</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">在栈区分配内存，无引用计数管理。</span></p></li> 
  <li><p><span style="font-size: 15px;">包含强类型的</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">通过指针管理在堆区的属性，对结构体的拷贝会创建新的栈内存，创建多份引用的指针，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">只会有一份。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">优化方式</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在使用结构体时：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">通过使用精确类型，例如UUID替代String（</span><span style="line-height: inherit;font-size: 15px;color: rgb(136, 136, 136);">UUID字节长度固定128字节，而不是String任意长度</span><span style="color: inherit;line-height: inherit;font-size: 15px;">），这样就可以进行内存内联，在栈内存储UUID，我们知道，栈内存管理更快更安全，并且不需要引用计数。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">Enum替代String，在栈内管理内存，无引用计数，并且从语法上对于开发者更友好。</span></p></li> 
 </ol> 
 <h3><span style="font-size: 18px;"><strong><br></strong></span></h3> 
 <h3><span style="font-size: 18px;"><strong>Method Dispatch</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们之前在</span><a href="https://www.jianshu.com/p/e0659093eaac" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">Static dispatch VS Dynamic dispatch</span></a><span style="font-size: 15px;">中提到过，能够在编译期确定执行方法的方式叫做静态分派Static dispatch，无法在编译期确定，只能在运行时去确定执行方法的分派方式叫做动态分派Dynamic dispatch。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Static dispatch</span></code><span style="font-size: 15px;">更快，而且静态分派可以进行<strong style="font-size: inherit;color: inherit;line-height: inherit;">内联</strong>等进一步的优化，使得执行更快速，性能更高。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">但是对于多态的情况，我们不能在编译期确定最终的类型，这里就用到了</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Dynamic dispatch</span></code><span style="font-size: 15px;">动态分派。动态分派的实现是，每种类型都会创建一张表，表内是一个包含了方法指针的数组。动态分派更灵活，但是因为有查表和跳转的操作，并且因为很多特点对于编译器来说并不明确，所以相当于block了编译器的一些后期优化。所以速度慢于</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Static dispatch</span></code><span style="font-size: 15px;">。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">下面看一段多态代码，以及分析实现方式：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs kotlin" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//引用语义实现的多态</span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Drawable</span>&nbsp;</span>{&nbsp;func&nbsp;draw()&nbsp;{}&nbsp;}<br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Point</span>&nbsp;:<span class="hljs-type" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Drawable&nbsp;{</span></span><br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;x,&nbsp;y:<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Double</span><br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">override</span>&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}<br>}<br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Line</span>&nbsp;:<span class="hljs-type" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Drawable&nbsp;{</span></span><br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Double</span><br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">override</span>&nbsp;func&nbsp;draw()&nbsp;{&nbsp;…&nbsp;}<br>}<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;drawables:[Drawable]<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">for</span>&nbsp;d&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">in</span>&nbsp;drawables&nbsp;{<br>&nbsp;d.draw（）<br>}<br></span></code></pre> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"> 
   <br> 
  </figcaption> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1.05" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42Qyibt6XibuVuoRmxiaPPUxPBekxFxdNSZCXYnS93Lf85NZFqp0vYbPuDwWoA/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42Qyibt6XibuVuoRmxiaPPUxPBekxFxdNSZCXYnS93Lf85NZFqp0vYbPuDwWoA/640?wx_fmt=png"></p> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">Method Dispatch总结</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">默认使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Dynamic dispatch</span></code><span style="font-size: 15px;">，因为在编译期几乎每个环节的信息都无法确定，所以阻碍了编译器的优化，比如</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">inline</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">whole module inline</span></code><span style="font-size: 15px;">。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">使用Static dispatch代替Dynamic dispatch提升性能</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们知道</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Static dispatch</span></code><span style="font-size: 15px;">快于</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Dynamic dispatch</span></code><span style="font-size: 15px;">，如何在开发中去尽可能使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Static dispatch</span></code><span style="font-size: 15px;">。</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">inheritance constraints</span></code><span style="font-size: 15px;">继承约束<br>我们可以使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">final</span></code><span style="font-size: 15px;">关键字去修饰</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">，以此生成的</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Final class</span></code><span style="font-size: 15px;">，使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Static dispatch</span></code><span style="font-size: 15px;">。</span></p></li> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">access control</span></code><span style="font-size: 15px;">访问控制<br></span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">private</span></code><span style="font-size: 15px;">关键字修饰，使得方法或属性只对当前类可见。编译器会对方法进行</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Static dispatch</span></code><span style="color: inherit;letter-spacing: 0px;font-size: 15px;">。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">编译器可以通过</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">whole module optimization</span></code><span style="font-size: 15px;">检查继承关系，对某些没有标记</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">final</span></code><span style="font-size: 15px;">的类通过计算，如果能在编译期确定执行的方法，则使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Static dispatch</span></code><span style="font-size: 15px;">。</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">默认使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Static dispatch</span></code><span style="font-size: 15px;">。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Swift快于OC的一个关键是可以消解动态分派。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">总结</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Swift提供了更灵活的</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">，用以在内存、引用计数、方法分派等角度去进行性能的优化，在正确的时机选择正确的数据结构，可以使我们的代码性能更快更安全。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">延伸</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">你可能会问</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">如何实现多态呢?答案是</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">protocol oriented programming</span></code><span style="font-size: 15px;">。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">以上分析了影响性能的几个标准，那么不同的算法机制</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Types</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Generic code</span></code><span style="font-size: 15px;">，它们在这三方面的表现如何，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Generic code</span></code><span style="font-size: 15px;">分别是怎么实现的呢？我们带着这个问题看下去。</span></p> 
 <h2 style="color: rgb(62, 62, 62);white-space: normal;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">Protocol Type</span></strong></h2> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这里我们会讨论Protocol Type如何存储和拷贝变量，以及方法分派是如何实现的。不通过继承或者引用语义的多态：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">protocol&nbsp;Drawable&nbsp;{&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">draw</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;}<br><span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Point</span>&nbsp;:<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Drawable</span></span>&nbsp;{<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;x,&nbsp;y:Double<br>&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">draw</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{&nbsp;…&nbsp;}<br>}<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;Line&nbsp;:Drawable&nbsp;{<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:Double<br>&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">draw</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{&nbsp;…&nbsp;}<br>}<br><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;drawables:[Drawable]&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//遵守了Drawable协议的类型集合，可能是point或者line</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">for</span>&nbsp;d&nbsp;in&nbsp;drawables&nbsp;{<br>&nbsp;d.draw（）<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">以上通过</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">实现多态，几个类之间没有继承关系，故不能按照惯例借助</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">V-Table</span></code><span style="font-size: 15px;">实现动态分派。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如果想了解</span><a href="https://www.jianshu.com/p/c93d7a7d6771" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">Vtable和Witness table实现</span></a><span style="font-size: 15px;">，可以进行点击查看，这里不做细节说明。<br>因为Point和Line的尺寸不同，数组存储数据实现一致性存储，使用了</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Existential Container</span></code><span style="font-size: 15px;">。查找正确的执行方法则使用了 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protoloc Witness Table</span></code><span style="text-align: center;letter-spacing: 0px;font-size: 15px;">。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.5520833333333334" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibUr9ZWQNUowfE6GicU24k0mtX781j4Mfze2iaogwx93tGic6H6WA2tJ3CQ/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibUr9ZWQNUowfE6GicU24k0mtX781j4Mfze2iaogwx93tGic6H6WA2tJ3CQ/640?wx_fmt=png"></p> 
 <p style="text-align: center;"><br></p> 
 <h3><span style="font-size: 18px;"><strong>Existential Container</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Existential Container</span></code><span style="font-size: 15px;">是一种特殊的内存布局方式，用于管理遵守了相同协议的数据类型</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">，这些数据类型因为不共享同一继承关系（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">这是</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">V-Table</span></code><span style="font-size: 15px;color: rgb(136, 136, 136);">实现的前提</span><span style="font-size: 15px;">），并且内存空间尺寸不同，使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Existential Container</span></code><span style="font-size: 15px;">进行管理，使其具有存储的一致性。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.5041666666666667" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42Qyib8kIt3cPfXxKmBC0iaOgqcI53p2by9pPhbwgVg7YFev18IJ0Hbpsib48Q/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42Qyib8kIt3cPfXxKmBC0iaOgqcI53p2by9pPhbwgVg7YFev18IJ0Hbpsib48Q/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">结构如下：</strong></span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;">三个词大小的valueBuffer<br>这里介绍一下valueBuffer结构，valueBuffer有三个词，每个词包含8个字节，存储的可能是值，也可能是对象的指针。对于small value（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">空间小于valueBuffer</span><span style="font-size: 15px;">），直接存储在valueBuffer的地址内， inline valueBuffer，无额外堆内存初始化。当值的数量大于3个属性即large value，或者总尺寸超过valueBuffer的占位，就会在堆区开辟内存，将其存储在堆区，valueBuffer存储内存指针。</span></p></li> 
  <li><p><span style="font-size: 15px;">value witness table的引用<br>因为</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">的类型不同，内存空间，初始化方法等都不相同，为了对</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">生命周期进行专项管理，用到了</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Value Witness Table</span></code><span style="font-size: 15px;">。</span></p></li> 
  <li><p><span style="font-size: 15px;">protocol witness table的引用<br>管理</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">的方法分派。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">内存分布如下：</strong></span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs markdown" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-bullet" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1.&nbsp;</span>payload<span class="hljs-emphasis" style="font-size: 15px;color: inherit;line-height: inherit;font-style: italic;overflow-wrap: inherit !important;word-break: inherit !important;">_data_</span>0&nbsp;=&nbsp;0x0000000000000004,<br><span class="hljs-bullet" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">2.&nbsp;</span>payload<span class="hljs-emphasis" style="font-size: 15px;color: inherit;line-height: inherit;font-style: italic;overflow-wrap: inherit !important;word-break: inherit !important;">_data_</span>1&nbsp;=&nbsp;0x0000000000000000,<br><span class="hljs-bullet" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">3.&nbsp;</span>payload<span class="hljs-emphasis" style="font-size: 15px;color: inherit;line-height: inherit;font-style: italic;overflow-wrap: inherit !important;word-break: inherit !important;">_data_</span>2&nbsp;=&nbsp;0x0000000000000000,<br><span class="hljs-bullet" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">4.&nbsp;</span>instance_type&nbsp;=&nbsp;0x000000010d6dc408&nbsp;ExistentialContainers`type&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metadata&nbsp;for&nbsp;ExistentialContainers.Car,<br><span class="hljs-bullet" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">5.&nbsp;</span>protocol<span class="hljs-emphasis" style="font-size: 15px;color: inherit;line-height: inherit;font-style: italic;overflow-wrap: inherit !important;word-break: inherit !important;">_witness_</span>0&nbsp;=&nbsp;0x000000010d6dc1c0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExistentialContainers&nbsp;protocol&nbsp;witness&nbsp;table&nbsp;for&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExistentialContainers.Car:ExistentialContainers.Drivable&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;ExistentialContainers<br></span></code></pre> 
 <h3><strong><span style="font-size: 18px;"><br></span></strong></h3> 
 <h3><strong><span style="font-size: 18px;">Protocol Witness Table（PWT）</span></strong></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">为了实现</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">多态也就是引用语义多态，需要</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">V-Table</span></code><span style="font-size: 15px;">来实现，但是</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">V-Table</span></code><span style="font-size: 15px;">的前提是具有同一个父类即共享相同的继承关系，但是对于</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">来说，并不具备此特征，故为了支持</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">的多态，需要用到</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">protocol oriented programming</span></code><span style="font-size: 15px;">机制，也就是借助</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Witness Table</span></code><span style="font-size: 15px;">来实现（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">细节可以点击</span><a href="https://www.jianshu.com/p/c93d7a7d6771" target="_blank" style="font-size: 15px;color: rgb(0, 128, 255);text-decoration: underline;"><span style="font-size: 15px;color: rgb(0, 128, 255);">Vtable和witness table实现</span></a><span style="font-size: 15px;color: rgb(136, 136, 136);">，每个结构体会创造</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;color: rgb(136, 136, 136);">PWT</span></code><span style="font-size: 15px;color: rgb(136, 136, 136);">表，内部包含指针，指向方法具体实现）</span><span style="font-size: 15px;">。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.35208333333333336" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibfPicnVOV8UB7YgdfoNwjYrdH6CbXmMh3qlD6D1ErRVTjko6cLKfFKVg/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibfPicnVOV8UB7YgdfoNwjYrdH6CbXmMh3qlD6D1ErRVTjko6cLKfFKVg/640?wx_fmt=png"></p> 
 <p style="text-align: center;"><br></p> 
 <h3><span style="font-size: 18px;"><strong>Value Witness Table（VWT）</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">用于管理任意值的初始化、拷贝、销毁。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.34791666666666665" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibHP7TSTRrxsQXJMibSVs92C3bPbmCbCbhX0BMNTcXRzQcLpJTRN2kMGw/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibHP7TSTRrxsQXJMibSVs92C3bPbmCbCbhX0BMNTcXRzQcLpJTRN2kMGw/640?wx_fmt=png"></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Value Witness Table</span></code><span style="font-size: 15px;">的结构如上，是用于管理遵守了协议的</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">实例的初始化，拷贝，内存消减和销毁的。</span></p></li> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Value Witness Table</span></code><span style="font-size: 15px;">在</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">SIL</span></code><span style="font-size: 15px;">中还可以拆分为</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">%relative_vwtable</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">%absolute_vwtable</span></code><span style="font-size: 15px;">，我们这里先不做展开。</span></p></li> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Value Witness Table</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Witness Table</span></code><span style="font-size: 15px;">通过分工，去管理</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">实例的内存管理（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">初始化，拷贝，销毁</span><span style="font-size: 15px;">）和方法调用。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们来借助具体的示例进行进一步了解：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Protocol&nbsp;Types</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;The&nbsp;Existential&nbsp;Container&nbsp;in&nbsp;action</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">drawACopy</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(local&nbsp;：Drawable)</span></span>&nbsp;{<br>&nbsp;local.draw()<br>}<br>let&nbsp;val&nbsp;:Drawable&nbsp;=&nbsp;Point()<br>drawACopy(val)<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在Swift编译器中，通过</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Existential Container</span></code><span style="font-size: 15px;">实现的伪代码如下：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Protocol&nbsp;Types</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;The&nbsp;Existential&nbsp;Container&nbsp;in&nbsp;action</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">drawACopy</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(local&nbsp;:Drawable)</span></span>&nbsp;{<br>&nbsp;local.draw()<br>}<br>let&nbsp;val&nbsp;:Drawable&nbsp;=&nbsp;Point()<br>drawACopy(val)<br><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//existential&nbsp;container的伪代码结构</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;ExistContDrawable&nbsp;{<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;valueBuffer:(Int,&nbsp;Int,&nbsp;Int)<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;vwt:ValueWitnessTable<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;pwt:DrawableProtocolWitnessTable<br>}<br><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;drawACopy方法生成的伪代码</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">drawACopy</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(val:ExistContDrawable)</span></span>&nbsp;{&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//将existential&nbsp;container传入</span><br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;local&nbsp;=&nbsp;ExistContDrawable()&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//初始化container</span><br>&nbsp;let&nbsp;vwt&nbsp;=&nbsp;val.vwt&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//获取value&nbsp;witness&nbsp;table，用于管理生命周期</span><br>&nbsp;let&nbsp;pwt&nbsp;=&nbsp;val.pwt&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//获取protocol&nbsp;witness&nbsp;table，用于进行方法分派</span><br>&nbsp;local.<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;<br>&nbsp;local.pwt&nbsp;=&nbsp;pwt<br>&nbsp;vwt.allocateBufferAndCopyValue(&amp;local,&nbsp;val)&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//vwt进行生命周期管理，初始化或者拷贝</span><br>&nbsp;pwt.draw(vwt.projectBuffer(&amp;local))&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//pwt查找方法，这里说一下projectBuffer，因为不同类型在内存中是不同的（small&nbsp;value内联在栈内，large&nbsp;value初始化在堆内，栈持有指针），所以方法的确定也是和类型相关的，我们知道，查找方法时是通过当前对象的地址，通过一定的位移去查找方法地址。</span><br>&nbsp;vwt.destructAndDeallocateBuffer(temp)&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//vwt进行生命周期管理，销毁内存</span><br>}<br></span></code></pre> 
 <h3><span style="font-size: 18px;"><strong><br></strong></span></h3> 
 <h3><span style="font-size: 18px;"><strong>Protocol Type 存储属性</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们知道，Swift中</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">的实例和属性都存储在堆区，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">实例在栈区，如果包含指针属性则存储在堆区，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">如何存储属性？Small Number通过</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Existential Container</span></code><span style="font-size: 15px;">内联实现，大数存在堆区。如何处理Copy呢?</span></p> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">Protocol大数的Copy优化</span></h4> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在出现Copy情况时：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs bash" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;aLine&nbsp;=&nbsp;Line(1.0,&nbsp;1.0,&nbsp;1.0,&nbsp;3.0)<br><span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;pair&nbsp;=&nbsp;Pair(aLine,&nbsp;aLine)<br><span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;copy&nbsp;=&nbsp;pair<br></span></code></pre> 
 <p style="text-align: center;"><br></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.9583333333333334" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibwteyQhkW4o2cd0yFZELbnKoEM1G7MLfAicDRkoAduOHwR3XKGgf7vtg/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibwteyQhkW4o2cd0yFZELbnKoEM1G7MLfAicDRkoAduOHwR3XKGgf7vtg/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">会将新的</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Exsitential Container</span></code><span style="font-size: 15px;">的valueBuffer指向同一个value即创建指针引用，但是如果要改变值怎么办?我们知道</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">值的修改和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">不同，Copy是不应该影响原实例的值的。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这里用到了一个技术叫做</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Indirect Storage With Copy-On-Write</span></code><span style="font-size: 15px;">，即优先使用内存指针。通过提高内存指针的使用，来降低堆区内存的初始化。降低内存消耗。在需要修改值的时候，会先检测引用计数检测，如果有大于1的引用计数，则开辟新内存，创建新的实例。在对内容进行变更的时候，会开启一块新的内存，伪代码如下：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">class&nbsp;LineStorage&nbsp;{&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;x1,&nbsp;y1,&nbsp;x2,&nbsp;y2:Double&nbsp;}<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;Line&nbsp;:Drawable&nbsp;{<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;storage&nbsp;:LineStorage<br>&nbsp;init()&nbsp;{&nbsp;storage&nbsp;=&nbsp;LineStorage(Point(),&nbsp;Point())&nbsp;}<br>&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">draw</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{&nbsp;…&nbsp;}<br>&nbsp;mutating&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">move</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;!isUniquelyReferencedNonObjc(&amp;storage)&nbsp;{&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//如何存在多份引用，则开启新内存，否则直接修改</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage&nbsp;=&nbsp;LineStorage(storage)<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;storage。start&nbsp;=&nbsp;...<br>&nbsp;&nbsp;&nbsp;}<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这样实现的目的：通过多份指针去引用同一份地址的成本远远低于开辟多份堆内存。以下对比图：<br></span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.45208333333333334" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibkxzbCnMZ3PpjY4CD2bSsWu7pxJrlh7OMhHVn5H5yvuPNLniaQ3qAw0A/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibkxzbCnMZ3PpjY4CD2bSsWu7pxJrlh7OMhHVn5H5yvuPNLniaQ3qAw0A/640?wx_fmt=png"></p> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.45416666666666666" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibKFFumKIBO2WiabHnCkLiavOvfVAcu1ywN3Hf378eTLnEDQ7qVsXD9RNQ/640?wx_fmt=png" data-type="png" data-w="480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibKFFumKIBO2WiabHnCkLiavOvfVAcu1ywN3Hf378eTLnEDQ7qVsXD9RNQ/640?wx_fmt=png"></p> 
 </figure> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">Protocol Type多态总结</span></h4> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;">支持Protocol Type的动态多态（Dynamic Polymorphism）行为。</span></p></li> 
  <li><p><span style="font-size: 15px;">通过使用Witness Table和Existential Container来实现。</span></p></li> 
  <li><p><span style="font-size: 15px;">对于大数的拷贝可以通过Indirect Storage间接存储来进行优化。</span></p></li> 
 </ol> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">说到动态多态</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Dynamic Polymorphism</span></code><span style="font-size: 15px;">，我们就要问了，什么是静态多态</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Static Polymorphism</span></code><span style="font-size: 15px;">，看看下面示例：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Drawing&nbsp;a&nbsp;copy</span><br>protocol&nbsp;Drawable&nbsp;{<br>&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">draw</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span><br>}<br><span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">drawACopy</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(local&nbsp;:Drawable)</span></span>&nbsp;{<br>&nbsp;local.draw()<br>}<br><br>let&nbsp;line&nbsp;=&nbsp;Line()<br>drawACopy(line)<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;...</span><br>let&nbsp;point&nbsp;=&nbsp;Point()<br>drawACopy(point)<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这种情况我们就可以用到<strong style="font-size: inherit;color: inherit;line-height: inherit;">泛型</strong></span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Generic code</span></code><span style="font-size: 15px;">来实现，进行进一步优化。</span></p> 
 <h2 style="color: rgb(62, 62, 62);white-space: normal;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">泛型</span></strong></h2> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们接下来会讨论泛型属性的存储方式和泛型方法是如何分派的。泛型和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">的区别在于：</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">泛型支持的是静态多态。</span></p></li> 
  <li><p><span style="font-size: 15px;">每个调用上下文只有一种类型。<br>查看下面的示例，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">foo</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">bar</span></code><span style="font-size: 15px;">方法是同一种类型。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">在调用链中会通过类型降级进行类型取代。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于以下示例：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">foo</span>&lt;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">T</span>:<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Drawable</span>&gt;<span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(local&nbsp;:T)</span></span>&nbsp;{<br>&nbsp;bar(local)<br>}<br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">bar</span>&lt;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">T</span>:<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Drawable</span>&gt;<span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(local:T)</span></span>&nbsp;{&nbsp;…&nbsp;}<br>let&nbsp;point&nbsp;=&nbsp;Point()<br>foo(point)<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">分析方法</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">foo</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">bar</span></code><span style="font-size: 15px;">的调用过程：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs php" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//调用过程</span><br>foo(point)--&gt;foo&lt;T&nbsp;=&nbsp;Point&gt;(point)&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//在方法执行时，Swift将泛型T绑定为调用方使用的具体类型，这里为Point</span><br>&nbsp;bar(local)&nbsp;--&gt;bar&lt;T&nbsp;=&nbsp;Point&gt;(local)&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//在调用内部bar方法时，会使用foo已经绑定的变量类型Point，可以看到，泛型T在这里已经被降级，通过类型Point进行取代</span><br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">泛型方法调用的具体实现为：</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">同一种类型的任何实例，都共享同样的实现，即使用同一个Protocol Witness Table。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">使用Protocol/Value Witness Table。</span></p></li> 
  <li><p><span style="font-size: 15px;">每个调用上下文只有一种类型：这里没有使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Existential Container</span></code><span style="font-size: 15px;">， 而是将</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol/Value Witness Table</span></code><span style="font-size: 15px;">作为调用方的额外参数进行传递。</span></p></li> 
  <li><p><span style="font-size: 15px;">变量初始化和方法调用，都使用传入的</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">VWT</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">PWT</span></code><span style="font-size: 15px;">来执行。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">看到这里，我们并不觉得泛型比</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">有什么更快的特性，泛型如何更快呢?静态多态前提下可以进行进一步的优化，称为<strong style="font-size: inherit;color: inherit;line-height: inherit;">特定泛型</strong>优化。</span></p> 
 <h3><span style="font-size: 18px;"><strong>泛型特化</strong></span></h3> 
 <p><span style="font-size: 18px;"><strong><br></strong></span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;">静态多态：在调用站中只有一种类型<br>Swift使用只有一种类型的特点，来进行类型降级取代。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">类型降级后，产生特定类型的方法</span></p></li> 
  <li><p><span style="font-size: 15px;">为泛型的每个类型创造对应的方法<br>这时候你可能会问，那每一种类型都产生一个新的方法，代码空间岂不爆炸?</span></p></li> 
  <li><p><span style="font-size: 15px;">静态多态下进行<strong style="font-size: inherit;color: inherit;line-height: inherit;">特定优化</strong></span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">specialization</span></code><br><span style="font-size: 15px;">因为是静态多态。所以可以进行很强大的优化，比如进行内联实现，并且通过获取上下文来进行更进一步的优化。从而降低方法数量。优化后可以更精确和具体。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">例如：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs r" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">func&nbsp;min&lt;<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">T</span>:Comparable&gt;(x:<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">T</span>,&nbsp;y:<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">T</span>)&nbsp;-&gt;&nbsp;<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">T</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;?&nbsp;y&nbsp;:&nbsp;x<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">从普通的泛型展开如下，因为要支持所有类型的</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">min</span></code><span style="font-size: 15px;">方法，所以需要对泛型类型进行计算，包括初始化地址、内存分配、生命周期管理等。除了对value的操作，还要对方法进行操作。这是一个非常的的工程。</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">min</span>&lt;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">T</span>:<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Comparable</span>&gt;<span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(x:T,&nbsp;y:T,&nbsp;FTable:FunctionTable)</span>&nbsp;-&gt;&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">T</span></span>&nbsp;{<br>&nbsp;&nbsp;let&nbsp;xCopy&nbsp;=&nbsp;FTable.<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">copy</span>(x)<br>&nbsp;&nbsp;let&nbsp;yCopy&nbsp;=&nbsp;FTable.<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">copy</span>(y)<br>&nbsp;&nbsp;let&nbsp;m&nbsp;=&nbsp;FTable.lessThan(yCopy，&nbsp;xCopy)&nbsp;?&nbsp;y&nbsp;:x<br>&nbsp;&nbsp;FTable.release(x)<br>&nbsp;&nbsp;FTable.release(y)<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;m<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在确定入参类型时，比如Int，编译器可以通过泛型特化，进行类型取代（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">Type Substitute</span><span style="font-size: 15px;">），优化为：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs kotlin" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">func&nbsp;min&lt;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Int</span>&gt;(x:<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Int</span>,&nbsp;y:<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Int</span>)&nbsp;-&gt;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Int</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;?&nbsp;y&nbsp;:x<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">泛型特化</strong></span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">specilization</span></code><span style="font-size: 15px;">是何时发生的?</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在使用特定优化时，调用方需要进行类型推断，这里需要知晓类型的上下文，例如类型的定义和内部方法实现。如果调用方和类型是单独编译的，就无法在调用方推断类型的内部实行，就无法使用特定优化，保证这些代码一起进行编译，这里就用到了</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">whole module optimization</span></code><span style="font-size: 15px;">。而</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">whole module optimization</span></code><span style="font-size: 15px;">是对于调用方和被调用方的方法在不同文件时，对其进行泛型特化优化的前提。</span></p> 
 <h3><span style="font-size: 18px;"><strong>泛型进一步优化</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">特定泛型的进一步优化：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs cs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Pairs&nbsp;in&nbsp;our&nbsp;program&nbsp;using&nbsp;generic&nbsp;types</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;Pair&lt;T&nbsp;:Drawable&gt;&nbsp;{<br>&nbsp;init(_&nbsp;f:T，&nbsp;_&nbsp;s:T)&nbsp;{<br>&nbsp;first&nbsp;=&nbsp;f&nbsp;;&nbsp;second&nbsp;=&nbsp;s<br>&nbsp;}<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;first:T<br>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;second:T<br>}<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;pairOfLines&nbsp;=&nbsp;Pair(Line(),&nbsp;Line())<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;...</span><br><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;pairOfPoint&nbsp;=&nbsp;Pair(Point(),&nbsp;Point())<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在用到多种泛型，且确定<strong style="font-size: inherit;color: inherit;line-height: inherit;">泛型类型不会在运行时修改</strong>时，就可以对成对泛型的使用进行进一步优化。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">优化的方式是将泛型的内存分配由指针指定，变为内存内联，不再有额外的堆初始化消耗。请注意，因为进行了存储内联，已经确定了泛型特定类型的内存分布，泛型的内存内联不能存储不同类型。所以再次强调<strong style="font-size: inherit;color: inherit;line-height: inherit;">此种优化只适用于在运行时不会修改泛型类型</strong>，即不能同时支持一个方法中包含</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">line</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">point</span></code><span style="font-size: 15px;">两种类型。</span></p> 
 <h3><span style="font-size: 18px;"><strong>whole module optimization</strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">whole module optimization</span></code><span style="font-size: 15px;">是用于Swift编译器的优化机制。可以通过</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">-whole-module-optimization</span></code><span style="font-size: 15px;"> （</span><span style="font-size: 15px;color: rgb(136, 136, 136);">或 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">-wmo</span></code><span style="font-size: 15px;">）进行打开。在XCode 8之后默认打开。 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Swift Package Manager</span></code><span style="font-size: 15px;">在release模式默认使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">whole module optimization</span></code><span style="font-size: 15px;">。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">module是多个文件集合。</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1.040625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibBJl6SbSRf6XBqXFicdbAVuouIeQFgXJDCLcQAwu2L4QcKCzUkgicVJXg/640?wx_fmt=png" data-type="png" data-w="320" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibBJl6SbSRf6XBqXFicdbAVuouIeQFgXJDCLcQAwu2L4QcKCzUkgicVJXg/640?wx_fmt=png"></p> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">编译器在对源文件进行语法分析之后，会对其进行优化，生成机器码并输出目标文件，之后链接器联合所有的目标文件生成共享库或可执行文件。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">whole module optimization</span></code><span style="font-size: 15px;">通过跨函数优化，可以进行内联等优化操作，对于泛型，可以通过获取类型的具体实现来进行推断优化，进行类型降级方法内联，删除多余方法等操作。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.675" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibVuDpkic2wgavl6OdMynibYrJdHicFPmHHZa95mfDUQxQUgjkibReOecMFg/640?wx_fmt=png" data-type="png" data-w="320" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibVuDpkic2wgavl6OdMynibYrJdHicFPmHHZa95mfDUQxQUgjkibReOecMFg/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">全模块优化的优势</strong></span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;">编译器掌握所有方法的实现，可以进行<strong style="font-size: inherit;color: inherit;line-height: inherit;">内联</strong>和<strong style="font-size: inherit;color: inherit;line-height: inherit;">泛型特化</strong>等优化，通过计算所有方法的引用，移除多余的引用计数操作。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">通过知晓所有的非公共方法，如果这写方法没有被使用，就可以对其进行消除。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">如何降低编译时间</strong><br></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">和全模块优化相反的是文件优化，即对单个文件进行编译。这样的好处在于可以并行执行，并且对于没有修改的文件不会再次编译。缺点在于编译器无法获知全貌，无法进行深度优化，全模块优化如何避免没修改的文件再次编译。</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1.228021978021978" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42Qyib2S4iaicbkr4CDZ7IAB2hEFJicJYEnRk2FV00mn7FE6WZwZGa44HsuZoHQ/640?wx_fmt=png" data-type="png" data-w="364" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42Qyib2S4iaicbkr4CDZ7IAB2hEFJicJYEnRk2FV00mn7FE6WZwZGa44HsuZoHQ/640?wx_fmt=png"></p> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">编译器内部运行过程分为：语法分析，类型检查，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">SIL</span></code><span style="font-size: 15px;">优化，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">LLVM</span></code><span style="font-size: 15px;">后端处理。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">语法分析和类型检查一般很快，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">SIL</span></code><span style="font-size: 15px;">优化执行了重要的Swift特定优化，例如泛型特化和方法内联等，该过程大概占用真个编译时间的三分之一。</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">LLVM</span></code><span style="font-size: 15px;">后端执行占用了大部分的编译时间，用于运行降级优化和生成代码。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">进行全模块优化后，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">SIL</span></code><span style="font-size: 15px;">优化会将模块再次拆分为多个部分，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">LLVM</span></code><span style="font-size: 15px;">后端通过多线程对这些拆分模块进行处理，对于没有修改的部分，不会进行再处理。这样就避免了修改一小部分，整个大模块进行</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">LLVM</span></code><span style="font-size: 15px;">后端执行，并且多线程并行操作也会缩短处理时间。</span></p> 
 <h2 style="color: rgb(62, 62, 62);white-space: normal;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">扩展：Swift的隐藏“Bug”</span></strong></h2> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Swift因为方法分派机制问题，所以在设计和优化后，会产生和我们常规理解不太一致的结果，这当然不能算Bug。但是还是要单独进行说明，避免在开发过程中，因为对机制的掌握不足，造成预期和执行出入导致的问题。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">Message dispatch</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们通过上面说明结合</span><a href="https://www.jianshu.com/p/e0659093eaac" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">Static dispatch VS Dynamic dispatch</span></a><span style="font-size: 15px;">对方法分派方式有了了解。这里需要对</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Objective-C</span></code><span style="font-size: 15px;">的方法分派方式进行说明。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">熟悉OC的人都知道，OC采用了运行时机制使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">obj_msgSend</span></code><span style="font-size: 15px;">发送消息，runtime非常的灵活，我们不仅可以对方法调用采用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">swizzling</span></code><span style="font-size: 15px;">，对于对象也可以通过</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">isa-swizzling</span></code><span style="font-size: 15px;">来扩展功能，应用场景有我们常用的hook和大家熟知的</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">KVO</span></code><span style="font-size: 15px;">。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">大家在使用Swift进行开发时都会问，Swift是否可以使用OC的运行时和消息转发机制呢？答案是可以。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Swift可以通过关键字</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">dynamic</span></code><span style="font-size: 15px;">对方法进行标记，这样就会告诉编译器，此方法使用的是OC的运行时机制。</span></p> 
 <blockquote> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">注意：我们常见的关键字</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">@ObjC</span></code><span style="font-size: 15px;">并不会改变Swift原有的方法分派机制，关键字</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">@ObjC</span></code><span style="font-size: 15px;">的作用只是告诉编译器，该段代码对于OC可见。</span></p> 
 </blockquote> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">总结来说，Swift通过</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">dynamic</span></code><span style="font-size: 15px;">关键字的扩展后，一共包含三种方法分派方式：</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Static dispatch</span></code><span style="font-size: 15px;">，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Table dispatch</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Message dispatch</span></code><span style="font-size: 15px;">。下表为不同的数据结构在不同情况下采取的分派方式：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.44479166666666664" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibGjOZGJprw32ysX8VlK6ouSe6tPOPhbFfPDooLD7drtian3J5SiaDian3g/640?wx_fmt=png" data-type="png" data-w="960" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibGjOZGJprw32ysX8VlK6ouSe6tPOPhbFfPDooLD7drtian3J5SiaDian3g/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如果在开发过程中，错误的混合了这几种分派方式，就可能出现Bug，以下我们对这些Bug进行分析：</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://bugs.Swift.org/browse/SR-584" style="line-height: inherit;color: rgb(30, 107, 184);">SR-584</a></strong><br></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">此情况是在子类的extension中重载父类方法时，出现和预期不同的行为。</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs kotlin" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Base</span>:<span class="hljs-type" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">NSObject&nbsp;{</span></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;directProperty:String&nbsp;{&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"This&nbsp;is&nbsp;Base"</span>&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;indirectProperty:String&nbsp;{&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;directProperty&nbsp;}<br>}<br><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Sub</span>:<span class="hljs-type" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Base&nbsp;{&nbsp;}</span></span><br><br>extension&nbsp;Sub&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">override</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;directProperty:String&nbsp;{&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"This&nbsp;is&nbsp;Sub"</span>&nbsp;}<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">执行以下代码，直接调用没有问题：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs coffeescript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">Base().directProperty&nbsp;<span class="hljs-regexp" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">//</span>&nbsp;“This&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">is</span>&nbsp;Base”<br>Sub().directProperty&nbsp;<span class="hljs-regexp" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">//</span>&nbsp;“This&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">is</span>&nbsp;Sub”<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">间接调用结果和预期不同：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs coffeescript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">Base（）。indirectProperty&nbsp;<span class="hljs-regexp" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">//</span>&nbsp;“This&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">is</span>&nbsp;Base”<br>Sub（）。indirectProperty&nbsp;<span class="hljs-regexp" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">//</span>&nbsp;expected&nbsp;<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"this&nbsp;is&nbsp;Sub"</span>，but&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">is</span>&nbsp;“This&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">is</span>&nbsp;Base”&nbsp;&lt;-&nbsp;Unexpected!<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Base.directProperty</span></code><span style="font-size: 15px;">前添加</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">dynamic</span></code><span style="font-size: 15px;">关键字就可以获得"this is Sub"的结果。</span><span style="color: inherit;letter-spacing: 0px;font-size: 15px;">Swift在</span><a href="https://docs.Swift.org/Swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" style="letter-spacing: 0px;line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;">extension 文档</a><span style="color: inherit;letter-spacing: 0px;font-size: 15px;">中说明，不能在extension中重载已经存在的方法。</span></p> 
 <blockquote style="line-height: inherit;padding: 15px 15px 15px 1rem;font-size: 0.9em;margin-top: 1em;margin-bottom: 1em;color: rgb(129, 145, 152);border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);overflow: auto;overflow-wrap: normal;"> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">“Extensions can add new functionality to a type, but they cannot override existing functionality.”</span></p> 
 </blockquote> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">会出现警告：</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Cannot override a non-dynamic class declaration from an extension</span></code><span style="text-align: center;color: inherit;letter-spacing: 0px;font-size: 15px;">。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><img class="" data-copyright="0" data-ratio="0.37386363636363634" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibricQSYScOcKQjNcjian9ragiaDRibJgLHUO4ciaIBooeRRHFF03sSL8E7Ew/640?wx_fmt=png" data-type="png" data-w="1760" style="text-align: center;color: inherit;font-size: inherit;letter-spacing: 0px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV2Jf5MASk9IrMGYFn42QyibricQSYScOcKQjNcjian9ragiaDRibJgLHUO4ciaIBooeRRHFF03sSL8E7Ew/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">出现这个问题的原因是，NSObject的extension是使用的</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Message dispatch</span></code><span style="font-size: 15px;">，而</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Initial Declaration</span></code><span style="font-size: 15px;">使用的是</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Table dispath</span></code><span style="font-size: 15px;">（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">查看上图 Swift Dispatch Method</span><span style="font-size: 15px;">）。extension重载的方法添加在了</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Message dispatch</span></code><span style="font-size: 15px;">内，没有修改虚函数表，虚函数表内还是父类的方法，故会执行父类方法。想在extension重载方法，需要标明</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">dynamic</span></code><span style="font-size: 15px;">来使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Message dispatch</span></code><span style="font-size: 15px;">。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://bugs.Swift.org/browse/SR-103" style="line-height: inherit;color: rgb(30, 107, 184);">SR-103</a></strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;color: inherit;letter-spacing: 0px;">协议的扩展内实现的方法，无法被遵守类的子类重载：</span><br></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">protocol&nbsp;Greetable&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">sayHi</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span><br>}<br><span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">extension</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Greetable</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">sayHi</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">print</span>(<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Hello"</span>）<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">greetings</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(greeter：Greetable)</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;greeter.sayHi()<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">现在定义一个遵守了协议的类</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Person</span></code><span style="font-size: 15px;">。遵守协议类的子类</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">LoudPerson</span></code><span style="font-size: 15px;">：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs kotlin" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Person</span>:<span class="hljs-type" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Greetable&nbsp;{</span></span><br>}<br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">LoudPerson</span>:<span class="hljs-type" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Person&nbsp;{</span></span><br>&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;sayHi()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"sub"</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">执行下面代码结果为：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs lua" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">var&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">sub</span>:LoudPerson&nbsp;=&nbsp;LoudPerson()<br><span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">sub</span>.sayHi()&nbsp;&nbsp;//<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">sub</span><br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">不符合预期的代码：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs cs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;sub:Person&nbsp;=&nbsp;LoudPerson()<br>sub.sayHi()&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//HellO&nbsp;&nbsp;&lt;-使用了protocol的默认实现</span><br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">注意，在子类</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">LoudPerson</span></code><span style="font-size: 15px;">中没有出现</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">override</span></code><span style="font-size: 15px;">关键字。可以理解为</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">LoudPerson</span></code><span style="font-size: 15px;">并没有成功注册</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Greetable</span></code><span style="font-size: 15px;">在</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Witness table</span></code><span style="font-size: 15px;">的方法。所以对于声明为</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Person</span></code><span style="font-size: 15px;">实际为</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">LoudPerson</span></code><span style="font-size: 15px;">的实例，会在编译器通过</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Person</span></code><span style="font-size: 15px;">去查找，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Person</span></code><span style="font-size: 15px;">没有实现协议方法，则不产生</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Witness table</span></code><span style="font-size: 15px;">，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">sayHi</span></code><span style="font-size: 15px;">方法是直接调用的。解决办法是在base类内实现协议方法，无需实现也要提供默认方法。或者将基类标记为</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">final</span></code><span style="font-size: 15px;">来避免继承。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">进一步通过示例去理解：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs kotlin" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Defined&nbsp;protocol。</span><br>protocol&nbsp;A&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Int</span><br>}<br>extension&nbsp;A&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Int</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;A&nbsp;class&nbsp;doesn't&nbsp;have&nbsp;implement&nbsp;of&nbsp;the&nbsp;function。</span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">B</span>：<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">A</span>&nbsp;</span>{}<br><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">C</span>：<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">B</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Int</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;A&nbsp;class&nbsp;has&nbsp;implement&nbsp;of&nbsp;the&nbsp;function。</span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">D</span>：<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">A</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Int</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">E</span>：<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">D</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">override</span>&nbsp;func&nbsp;a()&nbsp;-&gt;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Int</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">2</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Failure&nbsp;cases。</span><br>B().a()&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;0</span><br>C().a()&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;1</span><br>(C()&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">as</span>&nbsp;A).a()&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;0&nbsp;#&nbsp;We&nbsp;thought&nbsp;return&nbsp;1。&nbsp;</span><br><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;Success&nbsp;cases。</span><br>D().a()&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;1</span><br>(D()&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">as</span>&nbsp;A).a()&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;1</span><br>E().a()&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;2</span><br>(E()&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">as</span>&nbsp;A).a()&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;2</span><br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">其他</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们知道Class extension使用的是Static dispatch：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs cpp" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">MyClass</span>&nbsp;{</span><br>}<br>extension&nbsp;MyClass&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">func&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">extensionMethod</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;</span>{}<br>}<br><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">SubClass</span>：<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">MyClass</span>&nbsp;{</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">override&nbsp;func&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">extensionMethod</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;</span>{}<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">以上代码会出现错误，提示</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Declarations in extensions can not be overridden yet</span></code><span style="font-size: 15px;">。</span></p> 
 <h2 style="color: rgb(62, 62, 62);white-space: normal;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">总结</span></strong></h2> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">影响程序的性能标准有三种：<strong style="font-size: inherit;color: inherit;line-height: inherit;">初始化方式</strong>， <strong style="font-size: inherit;color: inherit;line-height: inherit;">引用指针</strong>和<strong style="font-size: inherit;color: inherit;line-height: inherit;">方法分派</strong>。</span></p></li> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">文中对比了两种数据结构：</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Struct</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Class</span></code><span style="font-size: 15px;">的在不同标准下的性能表现。Swift相比OC和其它语言强化了结构体的能力，所以在了解以上性能表现的前提下，通过利用结构体可以有效提升性能。</span></p></li> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在此基础上，我们还介绍了功能强大的结构体的类：</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Protocol Type</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Generic</span></code><span style="font-size: 15px;">。并且介绍了它们如何支持多态以及通过使用有条件限制的泛型如何让程序更快。</span></p></li> 
 </ul> 
 <h2><strong style="color: rgb(51, 51, 51);font-size: 16px;white-space: normal;"><span style="color: rgb(49, 188, 173);">参考资料</span></strong></h2> 
 <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
  <li><p><a href="https://developer.apple.com/documentation/swift/memorylayout" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">swift memorylayout</span></a></p></li> 
  <li><p><a href="https://developer.apple.com/videos/play/wwdc2016/416/" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">witness table video</span></a></p></li> 
  <li><p><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2016/416k7f0xkmz28rvlvwb/416/416_understanding_swift_performance.pdf?dl=1" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">protocol types pdf</span></a></p></li> 
  <li><p><a href="https://developer.apple.com/videos/play/wwdc2016/419" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">protocol and value oriented programming in UIKit apps &nbsp;video</span></a></p></li> 
  <li><p><a href="https://developer.apple.com/videos/play/wwdc2015/409/" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">optimizing swift performance</span></a></p></li> 
  <li><p><a href="https://swift.org/blog/whole-module-optimizations/" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">whole module optimizaiton</span></a></p></li> 
  <li><p><a href="https://developer.apple.com/swift/blog/?id=27" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">increasing performance by reducing dynamic dispatch</span></a></p></li> 
  <li><p><a href="https://medium.com/@vhart/protocols-generics-and-existential-containers-wait-what-e2e698262ab1" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">protocols generics existential container</span></a></p></li> 
  <li><p><a href="https://airspeedvelocity.net/2015/03/26/protocols-and-generics-2/" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">protocols and generics</span></a></p></li> 
  <li><p><a href="https://www.skilled.io/u/purpleyay/why-swift-is-swift" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">why swift is swift</span></a></p></li> 
  <li><p><a href="http://raizlabs.wpengine.com/dev/2016/12/swift-method-dispatch/" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">swift method dispatch</span></a></p></li> 
  <li><p><a href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">swift extension</span></a></p></li> 
  <li><p><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">universal dynamic dispatch for method calls</span></a></p></li> 
  <li><p><a href="https://github.com/apple/swift/blob/master/docs/CompilerPerformance.md" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">compiler performance.md</span></a></p></li> 
  <li><p><a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">structures and classes</span></a></p></li> 
 </ul> 
 <p><br></p> 
 <h2><span style="color: inherit;line-height: inherit;font-size: 15px;"><strong style="color: rgb(51, 51, 51);font-size: 16px;white-space: normal;"><span style="color: rgb(49, 188, 173);">作者简介</span></strong></span></h2> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;color: rgb(136, 136, 136);">亚男，美团点评iOS工程师。2017年加入美团点评，负责美团管家开发，研究编译器原理。目前正积极推动Swift组件化建设。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;color: rgb(136, 136, 136);"><span style="font-size: 15px;color: rgb(136, 136, 136);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);">欢迎加入</span><strong style="font-size: 15px;white-space: normal;color: rgb(51, 51, 51);"><span style="font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);color: rgb(0, 0, 0);">美团iOS技术交流群</span></strong><span style="font-size: 15px;color: rgb(136, 136, 136);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);">，跟作者零距离交流。进群方式：请加美美同学的微信（微信号：<strong>MTDPtech01</strong>），回复：</span><span style="color: rgb(62, 62, 62);font-size: 15px;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);"><strong>iOS</strong></span><span style="font-size: 15px;color: rgb(136, 136, 136);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);">，美美会自动拉你进群。</span></span></p> 
</section> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;color: rgb(51, 51, 51);text-align: center;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;">----------&nbsp; END&nbsp; ----------</span></p> 
<p data-source-line="194" style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;color: rgb(51, 51, 51);"><span style="font-size: 16px;"><strong><span style="color: rgb(49, 188, 173);">招聘信息</span></strong></span></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;color: rgb(51, 51, 51);"><br></p> 
<section data-source="bj.96weixin.com" style="margin-right: 0.5em;margin-left: 0.5em;font-size: 16px;white-space: normal;"> 
 <section style="padding: 20px 20px 15px;width: 670px;text-decoration: inherit;background-color: rgb(245, 245, 245);"> 
  <p style="line-height: normal;"><span style="font-size: 14px;">我们餐饮生态技术部是一个技术氛围活跃，大牛聚集的地方。新到店紧握真正的大规模SaaS实战机会，多租户、数据、安全、开放平台等全方位的挑战。业务领域复杂技术挑战多，技术和业务能力迅速提升，最重要的是，加入我们，你将实现真正通过代码来改变行业的梦想。我们欢迎各端人才加入，Java优先。感兴趣的同学赶紧发送简历至 zhaoyanan02@meituan.com，我们期待你的到来。</span></p> 
 </section> 
</section> 
<p data-source-line="194" style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><span style="max-width: 100%;font-size: 16px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><span style="max-width: 100%;color: rgb(49, 188, 173);box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;">也许你还想看</span></strong></span></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651749161&amp;idx=2&amp;sn=d58aeae3d6b124794f412707190ea022&amp;chksm=bd12a2648a652b72ea65324a6b89bdd2bf5dd2f74d470063e3f83a5e44ef4f7b4fceb4e961c4&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">iOS系统中导航栏的转场解决方案与最佳实践</span></a><br></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748259&amp;idx=1&amp;sn=a7ef0d515e94631c8d86bdbbf81da143&amp;chksm=bd12aeee8a6527f8a297d0dc797b81492837019c821898ae21c3e158831aaa7a383d5155ec9b&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">美团外卖iOS多端复用的推动、支撑与思考</span></a></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748776&amp;idx=3&amp;sn=25684a8d5e561b10c450436bb1f9d35c&amp;chksm=bd12a0e58a6529f3aad3ecd891bd2274aabfd19c82711298c88b96a6bd136c5522e9def3476a&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">ARKit：增强现实技术在美团到餐业务的实践</span></a><br></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"></span></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;margin-left: 0.5em;margin-right: 0.5em;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><img class="" data-copyright="0" data-ratio="0.44533333333333336" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png" data-type="png" data-w="1875" style="box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png"></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
