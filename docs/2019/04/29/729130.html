<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>前端黑科技：美团网页首帧优化实践 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="前端黑科技：美团网页首帧优化实践" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="总第304篇 2018年 第96篇 本文根据美团资深研发工程师寒阳在美团技术沙龙第40期《前端遇上黑科技，打造全新界面体验与效率》的演讲内容整理而成。本文介绍了如何使用构建时预渲染技术，对移动端首帧白屏问题进行优化。 导读 美团支付前端团队支持着美团钱包及支付业务，涉及项目众多，并且项目迭代很快，挑战巨大。在总结经验之后，我们举办了第40期美团技术沙龙（点击查看PPT及视频资料），与大家分享我们的实战经验。 11月24日下午，《美团技术沙龙第45期：如何构建高性能、稳定的后端服务系统》将在北京朝阳区望京恒电大厦C座美团点评北京总部1层恒基咖啡举办，我们结合美团大流量应用的典型业务场景，从后台系统架构的演进、高性能的服务计算、以及稳定性保障等方面的实践应用展开分享。更多活动详情请戳&gt;&gt;活动报名链接。 （图片来自寒阳分享现场） 自JavaScript诞生以来，前端技术发展非常迅速。移动端白屏优化是前端界面体验的一个重要优化方向，Web 前端诞生了 SSR 、CSR、预渲染等技术。在美团支付的前端技术体系里，通过预渲染提升网页首帧优化，从而优化了白屏问题，提升用户体验，并形成了最佳实践。 在前端渲染领域，主要有以下几种方式可供选择： 通过对比，同构方案集合 CSR 与 SSR 的优点，可以适用于大部分业务场景。但由于在同构的系统架构中，连接前后端的 Node 中间层处于核心链路，系统可用性的瓶颈就依赖于 Node ，一旦作为短板的 Node 挂了，整个服务都不可用。 结合到我们团队负责的支付业务场景里，由于支付业务追求极致的系统稳定性，服务不可用直接影响到客诉和资损，因此我们采用浏览器端渲染的架构。在保证系统稳定性的前提下，还需要保障用户体验，所以采用了预渲染的方式。 那么究竟什么是预渲染呢？什么是 FCP/FMP 呢？我们先从最常见的 CSR 开始说起。 以 Vue 举例，常见的 CSR 形式如下： 一切看似很美好。然而，作为以用户体验为首要目标的我们发现了一个体验问题：首屏白屏问题。 为什么会首屏白屏 浏览器渲染包含 HTML 解析、DOM 树构建、CSSOM 构建、JavaScript 解析、布局、绘制等等，大致如下图所示： 要搞清楚为什么会有白屏，就需要利用这个理论基础来对实际项目进行具体分析。通过 DevTools 进行分析： 等待 HTML 文档返回，此时处于白屏状态。 对 HTML 文档解析完成后进行首屏渲染，因为项目中对加了灰色的背景色，因此呈现出灰屏。 进行文件加载、JS 解析等过程，导致界面长时间出于灰屏中。 当 Vue 实例触发了 mounted 后，界面显示出大体框架。 调用 API 获取到时机业务数据后才能展示出最终的页面内容。 由此得出结论，因为要等待文件加载、CSSOM 构建、JS 解析等过程，而这些过程比较耗时，导致用户会长时间出于不可交互的首屏灰白屏状态，从而给用户一种网页很“慢”的感觉。那么一个网页太“慢”，会造成什么影响呢？ “慢”的影响 Global Web Performance Matters for ecommerce的报告中指出： 57%的用户更在乎网页在3秒内是否完成加载。 52%的在线用户认为网页打开速度影响到他们对网站的忠实度。 每慢1秒造成页面 PV 降低11%，用户满意度也随之降低降低16%。 近半数移动用户因为在10秒内仍未打开页面从而放弃。 我们团队主要负责美团支付相关的业务，如果网站太慢会影响用户的支付体验，会造成客诉或资损。既然网站太“慢”会造成如此重要的影响，那要如何优化呢？ 优化思路 在User-centric Performance Metrics一文中，共提到了4个页面渲染的关键指标： 基于这个理论基础，再回过头来看看之前项目的实际表现： 可见在 FP 的灰白屏界面停留了很长时间，用户不清楚网站是否有在正常加载，用户体验很差。 试想：如果我们可以将 FCP 或 FMP 完整的 HTML 文档提前到 FP 时机预渲染，用户看到页面框架，能感受到页面正在加载而不是冷冰冰的灰白屏，那么用户更愿意等待页面加载完成，从而降低了流失率。并且这种改观在弱网环境下更明显。 通过对比 FP、FCP、FMP 这三个时期 DOM 的差异，发现区别在于： FP：仅有一个 div 根节点。 FCP：包含页面的基本框架，但没有数据内容。 FMP：包含页面所有元素及数据。 仍然以 Vue 为例， 在其生命周期中，mounted 对应的是 FCP，updated 对应的是 FMP。那么具体应该使用哪个生命周期的 HTML 结构呢？ 通过以上的对比，最终选择在 mounted 时触发构建时预渲染。由于我们采用的是 CSR 的架构，没有 Node 作为中间层，因此要实现 DOM 内容的预渲染，就需要在项目构建编译时完成对原始模板的更新替换。 至此，我们明确了构建时预渲染的大体方案。 构建时预渲染方案 构建时预渲染流程： 配置读取 由于 SPA 可以由多个路由构成，需要根据业务场景决定哪些路由需要用到预渲染。因此这里的配置文件主要是用于告知编译器需要进行预渲染的路由。 在我们的系统架构里，脚手架是基于 Webpack 自研的，在此基础上可以自定义自动化构建任务和配置。 触发构建 项目中主要是使用 TypeScript，利用 TS 的装饰器，我们封装了统一的预渲染构建的钩子方法，从而只用一行代码即可完成构建时预渲染的触发。 装饰器： 使用： 构建编译 从流程图上，需要在发布机上启动模拟的浏览器环境，并通过预渲染的事件钩子获取当前的页面内容，生成最终的 HTML 文件。 由于我们在预渲染上的尝试比较早，当时还没有 Headless Chrome 、 Puppeteer、Prerender SPA Plugin等，因此在选型上使用的是 phantomjs-prebuilt（Prerender SPA Plugin 早期版本也是基于 phantomjs-prebuilt 实现的）。 通过 phantom 提供的 API 可获得当前 HTML，示例如下： 为了提高构建效率，并行对配置的多个页面或路由进行预渲染构建，保证在 5S 内即可完成构建，流程图如下： 方案优化 理想很丰满，现实很骨感。在实际投产中，构建时预渲染方案遇到了一个问题。 我们梳理一下简化后的项目上线过程： 开发 -&gt; 编译 -&gt; 上线 假设本次修改了静态文件中的一个 JS 文件，这个文件会通过 CDN 方式在 HTML 里引用，那么最终在 HTML 文档中的引用方式是 &lt;script src=&quot;http://cdn.com/index.js&quot;&gt;&lt;/script&gt;。然而由于项目还没有上线，所以其实通过完整 URL 的方式是获取不到这个文件的；而预渲染的构建又是在上线动作之前，所以问题就产生了： 构建时预渲染无法正常获取文件，导致编译报错 怎么办？ 请求劫持 因为在做预渲染时，我们使用启动了一个模拟的浏览器环境，根据 phantom 提供的 API，可以对发出的请求加以劫持，将获取 CDN 文件的请求劫持到本地，从而在根本上解决了这个问题。示例代码如下： 构建时预渲染研发流程及效果 最终，构建时预渲染研发流程如下： 开发阶段： 通过 TypeScript 的装饰器单行引入预渲染构建触发的方法。 发布前修改编译构建的配置文件。 发布阶段： 先进行常规的项目构建。 若有预渲染相关配置，则触发预渲染构建。 通过预渲染得到最终的文件，并完成发布上线动作。 完整的用户请求路径如下： 通过构建时预渲染在项目中的使用，FCP 的时间相比之前减少了 75%。 作者简介 寒阳，美团资深研发工程师，多年前端研发经历，负责美团支付钱包团队和美团支付前端基础技术。 欢迎加入美团前端技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech01），回复：前端，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 我们美团金融服务平台大前端研发组在高速成长中，我们欢迎更多优秀的 Web 前端研发工程师加入，感兴趣的朋友可以将简历发送到邮箱：shanghanyang@meituan.com。 也许你还想看 前端渲染引擎doT.js解析 前端遇上Go: 静态资源增量更新的新实践 美团点评金融平台Web前端技术体系" />
<meta property="og:description" content="总第304篇 2018年 第96篇 本文根据美团资深研发工程师寒阳在美团技术沙龙第40期《前端遇上黑科技，打造全新界面体验与效率》的演讲内容整理而成。本文介绍了如何使用构建时预渲染技术，对移动端首帧白屏问题进行优化。 导读 美团支付前端团队支持着美团钱包及支付业务，涉及项目众多，并且项目迭代很快，挑战巨大。在总结经验之后，我们举办了第40期美团技术沙龙（点击查看PPT及视频资料），与大家分享我们的实战经验。 11月24日下午，《美团技术沙龙第45期：如何构建高性能、稳定的后端服务系统》将在北京朝阳区望京恒电大厦C座美团点评北京总部1层恒基咖啡举办，我们结合美团大流量应用的典型业务场景，从后台系统架构的演进、高性能的服务计算、以及稳定性保障等方面的实践应用展开分享。更多活动详情请戳&gt;&gt;活动报名链接。 （图片来自寒阳分享现场） 自JavaScript诞生以来，前端技术发展非常迅速。移动端白屏优化是前端界面体验的一个重要优化方向，Web 前端诞生了 SSR 、CSR、预渲染等技术。在美团支付的前端技术体系里，通过预渲染提升网页首帧优化，从而优化了白屏问题，提升用户体验，并形成了最佳实践。 在前端渲染领域，主要有以下几种方式可供选择： 通过对比，同构方案集合 CSR 与 SSR 的优点，可以适用于大部分业务场景。但由于在同构的系统架构中，连接前后端的 Node 中间层处于核心链路，系统可用性的瓶颈就依赖于 Node ，一旦作为短板的 Node 挂了，整个服务都不可用。 结合到我们团队负责的支付业务场景里，由于支付业务追求极致的系统稳定性，服务不可用直接影响到客诉和资损，因此我们采用浏览器端渲染的架构。在保证系统稳定性的前提下，还需要保障用户体验，所以采用了预渲染的方式。 那么究竟什么是预渲染呢？什么是 FCP/FMP 呢？我们先从最常见的 CSR 开始说起。 以 Vue 举例，常见的 CSR 形式如下： 一切看似很美好。然而，作为以用户体验为首要目标的我们发现了一个体验问题：首屏白屏问题。 为什么会首屏白屏 浏览器渲染包含 HTML 解析、DOM 树构建、CSSOM 构建、JavaScript 解析、布局、绘制等等，大致如下图所示： 要搞清楚为什么会有白屏，就需要利用这个理论基础来对实际项目进行具体分析。通过 DevTools 进行分析： 等待 HTML 文档返回，此时处于白屏状态。 对 HTML 文档解析完成后进行首屏渲染，因为项目中对加了灰色的背景色，因此呈现出灰屏。 进行文件加载、JS 解析等过程，导致界面长时间出于灰屏中。 当 Vue 实例触发了 mounted 后，界面显示出大体框架。 调用 API 获取到时机业务数据后才能展示出最终的页面内容。 由此得出结论，因为要等待文件加载、CSSOM 构建、JS 解析等过程，而这些过程比较耗时，导致用户会长时间出于不可交互的首屏灰白屏状态，从而给用户一种网页很“慢”的感觉。那么一个网页太“慢”，会造成什么影响呢？ “慢”的影响 Global Web Performance Matters for ecommerce的报告中指出： 57%的用户更在乎网页在3秒内是否完成加载。 52%的在线用户认为网页打开速度影响到他们对网站的忠实度。 每慢1秒造成页面 PV 降低11%，用户满意度也随之降低降低16%。 近半数移动用户因为在10秒内仍未打开页面从而放弃。 我们团队主要负责美团支付相关的业务，如果网站太慢会影响用户的支付体验，会造成客诉或资损。既然网站太“慢”会造成如此重要的影响，那要如何优化呢？ 优化思路 在User-centric Performance Metrics一文中，共提到了4个页面渲染的关键指标： 基于这个理论基础，再回过头来看看之前项目的实际表现： 可见在 FP 的灰白屏界面停留了很长时间，用户不清楚网站是否有在正常加载，用户体验很差。 试想：如果我们可以将 FCP 或 FMP 完整的 HTML 文档提前到 FP 时机预渲染，用户看到页面框架，能感受到页面正在加载而不是冷冰冰的灰白屏，那么用户更愿意等待页面加载完成，从而降低了流失率。并且这种改观在弱网环境下更明显。 通过对比 FP、FCP、FMP 这三个时期 DOM 的差异，发现区别在于： FP：仅有一个 div 根节点。 FCP：包含页面的基本框架，但没有数据内容。 FMP：包含页面所有元素及数据。 仍然以 Vue 为例， 在其生命周期中，mounted 对应的是 FCP，updated 对应的是 FMP。那么具体应该使用哪个生命周期的 HTML 结构呢？ 通过以上的对比，最终选择在 mounted 时触发构建时预渲染。由于我们采用的是 CSR 的架构，没有 Node 作为中间层，因此要实现 DOM 内容的预渲染，就需要在项目构建编译时完成对原始模板的更新替换。 至此，我们明确了构建时预渲染的大体方案。 构建时预渲染方案 构建时预渲染流程： 配置读取 由于 SPA 可以由多个路由构成，需要根据业务场景决定哪些路由需要用到预渲染。因此这里的配置文件主要是用于告知编译器需要进行预渲染的路由。 在我们的系统架构里，脚手架是基于 Webpack 自研的，在此基础上可以自定义自动化构建任务和配置。 触发构建 项目中主要是使用 TypeScript，利用 TS 的装饰器，我们封装了统一的预渲染构建的钩子方法，从而只用一行代码即可完成构建时预渲染的触发。 装饰器： 使用： 构建编译 从流程图上，需要在发布机上启动模拟的浏览器环境，并通过预渲染的事件钩子获取当前的页面内容，生成最终的 HTML 文件。 由于我们在预渲染上的尝试比较早，当时还没有 Headless Chrome 、 Puppeteer、Prerender SPA Plugin等，因此在选型上使用的是 phantomjs-prebuilt（Prerender SPA Plugin 早期版本也是基于 phantomjs-prebuilt 实现的）。 通过 phantom 提供的 API 可获得当前 HTML，示例如下： 为了提高构建效率，并行对配置的多个页面或路由进行预渲染构建，保证在 5S 内即可完成构建，流程图如下： 方案优化 理想很丰满，现实很骨感。在实际投产中，构建时预渲染方案遇到了一个问题。 我们梳理一下简化后的项目上线过程： 开发 -&gt; 编译 -&gt; 上线 假设本次修改了静态文件中的一个 JS 文件，这个文件会通过 CDN 方式在 HTML 里引用，那么最终在 HTML 文档中的引用方式是 &lt;script src=&quot;http://cdn.com/index.js&quot;&gt;&lt;/script&gt;。然而由于项目还没有上线，所以其实通过完整 URL 的方式是获取不到这个文件的；而预渲染的构建又是在上线动作之前，所以问题就产生了： 构建时预渲染无法正常获取文件，导致编译报错 怎么办？ 请求劫持 因为在做预渲染时，我们使用启动了一个模拟的浏览器环境，根据 phantom 提供的 API，可以对发出的请求加以劫持，将获取 CDN 文件的请求劫持到本地，从而在根本上解决了这个问题。示例代码如下： 构建时预渲染研发流程及效果 最终，构建时预渲染研发流程如下： 开发阶段： 通过 TypeScript 的装饰器单行引入预渲染构建触发的方法。 发布前修改编译构建的配置文件。 发布阶段： 先进行常规的项目构建。 若有预渲染相关配置，则触发预渲染构建。 通过预渲染得到最终的文件，并完成发布上线动作。 完整的用户请求路径如下： 通过构建时预渲染在项目中的使用，FCP 的时间相比之前减少了 75%。 作者简介 寒阳，美团资深研发工程师，多年前端研发经历，负责美团支付钱包团队和美团支付前端基础技术。 欢迎加入美团前端技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech01），回复：前端，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 我们美团金融服务平台大前端研发组在高速成长中，我们欢迎更多优秀的 Web 前端研发工程师加入，感兴趣的朋友可以将简历发送到邮箱：shanghanyang@meituan.com。 也许你还想看 前端渲染引擎doT.js解析 前端遇上Go: 静态资源增量更新的新实践 美团点评金融平台Web前端技术体系" />
<link rel="canonical" href="https://mlh.app/2019/04/29/729130.html" />
<meta property="og:url" content="https://mlh.app/2019/04/29/729130.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"总第304篇 2018年 第96篇 本文根据美团资深研发工程师寒阳在美团技术沙龙第40期《前端遇上黑科技，打造全新界面体验与效率》的演讲内容整理而成。本文介绍了如何使用构建时预渲染技术，对移动端首帧白屏问题进行优化。 导读 美团支付前端团队支持着美团钱包及支付业务，涉及项目众多，并且项目迭代很快，挑战巨大。在总结经验之后，我们举办了第40期美团技术沙龙（点击查看PPT及视频资料），与大家分享我们的实战经验。 11月24日下午，《美团技术沙龙第45期：如何构建高性能、稳定的后端服务系统》将在北京朝阳区望京恒电大厦C座美团点评北京总部1层恒基咖啡举办，我们结合美团大流量应用的典型业务场景，从后台系统架构的演进、高性能的服务计算、以及稳定性保障等方面的实践应用展开分享。更多活动详情请戳&gt;&gt;活动报名链接。 （图片来自寒阳分享现场） 自JavaScript诞生以来，前端技术发展非常迅速。移动端白屏优化是前端界面体验的一个重要优化方向，Web 前端诞生了 SSR 、CSR、预渲染等技术。在美团支付的前端技术体系里，通过预渲染提升网页首帧优化，从而优化了白屏问题，提升用户体验，并形成了最佳实践。 在前端渲染领域，主要有以下几种方式可供选择： 通过对比，同构方案集合 CSR 与 SSR 的优点，可以适用于大部分业务场景。但由于在同构的系统架构中，连接前后端的 Node 中间层处于核心链路，系统可用性的瓶颈就依赖于 Node ，一旦作为短板的 Node 挂了，整个服务都不可用。 结合到我们团队负责的支付业务场景里，由于支付业务追求极致的系统稳定性，服务不可用直接影响到客诉和资损，因此我们采用浏览器端渲染的架构。在保证系统稳定性的前提下，还需要保障用户体验，所以采用了预渲染的方式。 那么究竟什么是预渲染呢？什么是 FCP/FMP 呢？我们先从最常见的 CSR 开始说起。 以 Vue 举例，常见的 CSR 形式如下： 一切看似很美好。然而，作为以用户体验为首要目标的我们发现了一个体验问题：首屏白屏问题。 为什么会首屏白屏 浏览器渲染包含 HTML 解析、DOM 树构建、CSSOM 构建、JavaScript 解析、布局、绘制等等，大致如下图所示： 要搞清楚为什么会有白屏，就需要利用这个理论基础来对实际项目进行具体分析。通过 DevTools 进行分析： 等待 HTML 文档返回，此时处于白屏状态。 对 HTML 文档解析完成后进行首屏渲染，因为项目中对加了灰色的背景色，因此呈现出灰屏。 进行文件加载、JS 解析等过程，导致界面长时间出于灰屏中。 当 Vue 实例触发了 mounted 后，界面显示出大体框架。 调用 API 获取到时机业务数据后才能展示出最终的页面内容。 由此得出结论，因为要等待文件加载、CSSOM 构建、JS 解析等过程，而这些过程比较耗时，导致用户会长时间出于不可交互的首屏灰白屏状态，从而给用户一种网页很“慢”的感觉。那么一个网页太“慢”，会造成什么影响呢？ “慢”的影响 Global Web Performance Matters for ecommerce的报告中指出： 57%的用户更在乎网页在3秒内是否完成加载。 52%的在线用户认为网页打开速度影响到他们对网站的忠实度。 每慢1秒造成页面 PV 降低11%，用户满意度也随之降低降低16%。 近半数移动用户因为在10秒内仍未打开页面从而放弃。 我们团队主要负责美团支付相关的业务，如果网站太慢会影响用户的支付体验，会造成客诉或资损。既然网站太“慢”会造成如此重要的影响，那要如何优化呢？ 优化思路 在User-centric Performance Metrics一文中，共提到了4个页面渲染的关键指标： 基于这个理论基础，再回过头来看看之前项目的实际表现： 可见在 FP 的灰白屏界面停留了很长时间，用户不清楚网站是否有在正常加载，用户体验很差。 试想：如果我们可以将 FCP 或 FMP 完整的 HTML 文档提前到 FP 时机预渲染，用户看到页面框架，能感受到页面正在加载而不是冷冰冰的灰白屏，那么用户更愿意等待页面加载完成，从而降低了流失率。并且这种改观在弱网环境下更明显。 通过对比 FP、FCP、FMP 这三个时期 DOM 的差异，发现区别在于： FP：仅有一个 div 根节点。 FCP：包含页面的基本框架，但没有数据内容。 FMP：包含页面所有元素及数据。 仍然以 Vue 为例， 在其生命周期中，mounted 对应的是 FCP，updated 对应的是 FMP。那么具体应该使用哪个生命周期的 HTML 结构呢？ 通过以上的对比，最终选择在 mounted 时触发构建时预渲染。由于我们采用的是 CSR 的架构，没有 Node 作为中间层，因此要实现 DOM 内容的预渲染，就需要在项目构建编译时完成对原始模板的更新替换。 至此，我们明确了构建时预渲染的大体方案。 构建时预渲染方案 构建时预渲染流程： 配置读取 由于 SPA 可以由多个路由构成，需要根据业务场景决定哪些路由需要用到预渲染。因此这里的配置文件主要是用于告知编译器需要进行预渲染的路由。 在我们的系统架构里，脚手架是基于 Webpack 自研的，在此基础上可以自定义自动化构建任务和配置。 触发构建 项目中主要是使用 TypeScript，利用 TS 的装饰器，我们封装了统一的预渲染构建的钩子方法，从而只用一行代码即可完成构建时预渲染的触发。 装饰器： 使用： 构建编译 从流程图上，需要在发布机上启动模拟的浏览器环境，并通过预渲染的事件钩子获取当前的页面内容，生成最终的 HTML 文件。 由于我们在预渲染上的尝试比较早，当时还没有 Headless Chrome 、 Puppeteer、Prerender SPA Plugin等，因此在选型上使用的是 phantomjs-prebuilt（Prerender SPA Plugin 早期版本也是基于 phantomjs-prebuilt 实现的）。 通过 phantom 提供的 API 可获得当前 HTML，示例如下： 为了提高构建效率，并行对配置的多个页面或路由进行预渲染构建，保证在 5S 内即可完成构建，流程图如下： 方案优化 理想很丰满，现实很骨感。在实际投产中，构建时预渲染方案遇到了一个问题。 我们梳理一下简化后的项目上线过程： 开发 -&gt; 编译 -&gt; 上线 假设本次修改了静态文件中的一个 JS 文件，这个文件会通过 CDN 方式在 HTML 里引用，那么最终在 HTML 文档中的引用方式是 &lt;script src=&quot;http://cdn.com/index.js&quot;&gt;&lt;/script&gt;。然而由于项目还没有上线，所以其实通过完整 URL 的方式是获取不到这个文件的；而预渲染的构建又是在上线动作之前，所以问题就产生了： 构建时预渲染无法正常获取文件，导致编译报错 怎么办？ 请求劫持 因为在做预渲染时，我们使用启动了一个模拟的浏览器环境，根据 phantom 提供的 API，可以对发出的请求加以劫持，将获取 CDN 文件的请求劫持到本地，从而在根本上解决了这个问题。示例代码如下： 构建时预渲染研发流程及效果 最终，构建时预渲染研发流程如下： 开发阶段： 通过 TypeScript 的装饰器单行引入预渲染构建触发的方法。 发布前修改编译构建的配置文件。 发布阶段： 先进行常规的项目构建。 若有预渲染相关配置，则触发预渲染构建。 通过预渲染得到最终的文件，并完成发布上线动作。 完整的用户请求路径如下： 通过构建时预渲染在项目中的使用，FCP 的时间相比之前减少了 75%。 作者简介 寒阳，美团资深研发工程师，多年前端研发经历，负责美团支付钱包团队和美团支付前端基础技术。 欢迎加入美团前端技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech01），回复：前端，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 我们美团金融服务平台大前端研发组在高速成长中，我们欢迎更多优秀的 Web 前端研发工程师加入，感兴趣的朋友可以将简历发送到邮箱：shanghanyang@meituan.com。 也许你还想看 前端渲染引擎doT.js解析 前端遇上Go: 静态资源增量更新的新实践 美团点评金融平台Web前端技术体系","@type":"BlogPosting","url":"https://mlh.app/2019/04/29/729130.html","headline":"前端黑科技：美团网页首帧优化实践","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/29/729130.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>前端黑科技：美团网页首帧优化实践</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;" data-mpa-powered-by="yiban.io"><img class="" data-copyright="0" data-ratio="0.10546875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png" data-type="png" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">总第304篇</span></strong></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">2018年 第96篇</span></strong></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<section data-role="outer" label="Powered by 135editor.com" style="font-size: 16px;white-space: normal;font-family: 微软雅黑;"> 
 <section data-role="outer" label="Powered by 135editor.com"> 
  <section class="_135editor" data-tools="135编辑器" data-id="85960" style="border-width: 0px;border-style: none;border-color: initial;"> 
   <section style="margin: 1.5em 10px;"> 
    <section style="padding: 8px;width: 4em;height: 4em;border-width: 1px;border-style: solid;border-color: rgb(200, 200, 200);box-shadow: rgb(220, 220, 220) 0px 0px 6px;background-color: rgb(254, 254, 254);border-radius: 50%;display: inline-block;"> 
     <img border="0" class="" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWTbHLTfHwY2I9BHC0WS5jXeGxTFkn48ib9yXKnxlA3Ag91D73v9YEpHL3oh74wp9EAImmFNnk57vQ/640?wx_fmt=jpeg" data-type="jpeg" data-w="800" height="" opacity="" style="padding: 2px;border-radius: 50%;border-width: 1px;border-style: solid;border-color: rgb(198, 198, 198);" title="undefined" width="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWTbHLTfHwY2I9BHC0WS5jXeGxTFkn48ib9yXKnxlA3Ag91D73v9YEpHL3oh74wp9EAImmFNnk57vQ/640?wx_fmt=jpeg"> 
    </section> 
    <section class="135brush" style="margin-top: -5em;margin-left: 2.5em;padding: 15px 15px 15px 35px;background-color: rgb(254, 254, 255);box-shadow: rgb(198, 198, 198) 0px 0px 6px;"> 
     <p><span style="font-size: 14px;color: rgb(136, 136, 136);">本文根据美团资深研发工程师寒阳在美团技术沙龙第40期《前端遇上黑科技，打造全新界面体验与效率》的演讲内容整理而成。本文介绍了如何<span style="">使用构建时预渲染技术，对移动端首帧白屏问题进行优化。</span></span></p> 
    </section> 
   </section> 
  </section> 
 </section> 
</section> 
<h1 style="color: rgb(62, 62, 62);white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">导读</span></strong></h1> 
<p style="margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<p style="margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 15px;">美团支付前端团队支持着美团钱包及支付业务，涉及项目众多，并且项目迭代很快，挑战巨大。在总结经验之后，我们举办了<a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxe730920d465a6732&amp;redirect_uri=https%3A%2F%2Ftech.meituan.com%2Fsalon%2F%23%2F41406%2Fresource&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=wx&amp;connect_redirect=1#wechat_redirect" target="_blank">第40期美团技术沙龙（<span style="color: rgb(136, 136, 136);">点击查看PPT及视频资料</span>）</a>，与大家分享我们的实战经验。</span></p> 
<p style="margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 15px;"><br></span></p> 
<p><span style="font-size: 15px;">11月24日下午，《美团技术沙龙第45期：如何构建高性能、稳定的后端服务系统》将在北京朝阳区望京恒电大厦C座美团点评北京总部1层恒基咖啡举办，我们结合美团大流量应用的典型业务场景，从后台系统架构的演进、高性能的服务计算、以及稳定性保障等方面的实践应用展开分享。更多活动详情请戳&gt;&gt;</span><a href="http://www.huodongxing.com/event/4465518704511?qd=weixin" target="_blank" style="font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">活动报名链接</span></a><span style="font-size: 15px;">。</span></p> 
<p style="margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.44453125" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWTbHLTfHwY2I9BHC0WS5jXhqNWyds9Lw2HICzPnjJ5gIyKewbQoHgALzibFOmicwBtRicuvzPjiasyKQ/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWTbHLTfHwY2I9BHC0WS5jXhqNWyds9Lw2HICzPnjJ5gIyKewbQoHgALzibFOmicwBtRicuvzPjiasyKQ/640?wx_fmt=jpeg"></p> 
<p style="white-space: normal;color: rgb(51, 51, 51);margin-left: 0.5em;margin-right: 0.5em;text-align: center;"><span style="font-size: 13px;">（</span><span style="font-size: 13px;color: rgb(136, 136, 136);">图片来自寒阳分享现场</span><span style="font-size: 13px;">）</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;margin-left: 0.5em;margin-right: 0.5em;"> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">自JavaScript诞生以来，前端技术发展非常迅速。移动端白屏优化是前端界面体验的一个重要优化方向，Web 前端诞生了 SSR 、CSR、预渲染等技术。在美团支付的前端技术体系里，通过预渲染提升网页首帧优化，从而优化了白屏问题，提升用户体验，并形成了最佳实践。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在前端渲染领域，主要有以下几种方式可供选择：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.41073446327683616" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPyH27LlGPG1YjqtzibEY8T6P6oHN0C9FjUc5Oc0VciczqQZBjRg4pzEcQ/640?wx_fmt=png" data-type="png" data-w="1770" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPyH27LlGPG1YjqtzibEY8T6P6oHN0C9FjUc5Oc0VciczqQZBjRg4pzEcQ/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过对比，同构方案集合 CSR 与 SSR 的优点，可以适用于大部分业务场景。但由于在同构的系统架构中，连接前后端的 Node 中间层处于核心链路，系统可用性的瓶颈就依赖于 Node ，一旦作为短板的 Node 挂了，整个服务都不可用。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">结合到我们团队负责的支付业务场景里，由于支付业务追求极致的系统稳定性，服务不可用直接影响到客诉和资损，因此我们采用浏览器端渲染的架构。在保证系统稳定性的前提下，还需要保障用户体验，所以采用了预渲染的方式。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">那么究竟什么是预渲染呢？什么是 FCP/FMP 呢？我们先从最常见的 CSR 开始说起。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">以 Vue 举例，常见的 CSR 形式如下：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.6123778501628665" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPysUnBOF8Aodia0CAXvuI4M8bEwF4TQPgXDHIZeo0sjaG5K0D3gBNu8w/640?wx_fmt=png" data-type="png" data-w="1228" style="width: 435px;height: 266px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPysUnBOF8Aodia0CAXvuI4M8bEwF4TQPgXDHIZeo0sjaG5K0D3gBNu8w/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">一切看似很美好。然而，作为以用户体验为首要目标的我们发现了一个体验问题：<strong style="font-size: inherit;color: inherit;line-height: inherit;">首屏白屏问题</strong>。</span></p> 
 <h1><strong style="color: rgb(51, 51, 51);font-size: 20px;white-space: normal;"><span style="color: rgb(49, 188, 173);">为什么会首屏白屏</span></strong></h1> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">浏览器渲染包含 HTML 解析、DOM 树构建、CSSOM 构建、JavaScript 解析、布局、绘制等等，大致如下图所示：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.324905183312263" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPaRYA8P9tdmUFSMfnmUUo1WbGxaAntiaXr4s4VJicszIKQJcEjgzLS6wg/640?wx_fmt=jpeg" data-type="jpeg" data-w="791" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPaRYA8P9tdmUFSMfnmUUo1WbGxaAntiaXr4s4VJicszIKQJcEjgzLS6wg/640?wx_fmt=jpeg"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">要搞清楚为什么会有白屏，就需要利用这个理论基础来对实际项目进行具体分析。通过 DevTools 进行分析：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.449671772428884" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPcBuOZwuibQPno7SCz1DPSYCbRjFXMuBNJMbt0ibmApAFAicebxOoASPlQ/640?wx_fmt=png" data-type="png" data-w="1828" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPcBuOZwuibQPno7SCz1DPSYCbRjFXMuBNJMbt0ibmApAFAicebxOoASPlQ/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">等待 HTML 文档返回，此时处于白屏状态。</span></p></li> 
  <li><p><span style="font-size: 15px;">对 HTML 文档解析完成后进行首屏渲染，因为项目中对加了灰色的背景色，因此呈现出灰屏。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">进行文件加载、JS 解析等过程，导致界面长时间出于灰屏中。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">当 Vue 实例触发了 mounted 后，界面显示出大体框架。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">调用 API 获取到时机业务数据后才能展示出最终的页面内容。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">由此得出结论，因为要等待文件加载、CSSOM 构建、JS 解析等过程，而这些过程比较耗时，导致用户会长时间出于不可交互的首屏灰白屏状态，从而给用户一种网页很“慢”的感觉。那么一个网页太“慢”，会造成什么影响呢？</span></p> 
 <h1><strong style="color: rgb(51, 51, 51);font-size: 20px;white-space: normal;"><span style="color: rgb(49, 188, 173);">“慢”的影响</span></strong></h1> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><a href="https://www.cdnetworks.com/resources/whitepapers/us/Global%20Web%20Performance%20Matters.pdf" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">Global Web Performance Matters for ecommerce</span></a><span style="font-size: 15px;">的报告中指出：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.5732758620689655" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPPibn6OEfcaibMaA4icdgjg9pnDXnbPFVTR9lGfghxT9juGibEYaYoANWBQ/640?wx_fmt=png" data-type="png" data-w="1392" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPPibn6OEfcaibMaA4icdgjg9pnDXnbPFVTR9lGfghxT9juGibEYaYoANWBQ/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">57%的用户更在乎网页在3秒内是否完成加载。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">52%的在线用户认为网页打开速度影响到他们对网站的忠实度。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">每慢1秒造成页面 PV 降低11%，用户满意度也随之降低降低16%。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">近半数移动用户因为在10秒内仍未打开页面从而放弃。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们团队主要负责美团支付相关的业务，如果网站太慢会影响用户的支付体验，会造成客诉或资损。既然网站太“慢”会造成如此重要的影响，那要如何优化呢？</span></p> 
 <h1><strong style="color: rgb(51, 51, 51);font-size: 20px;white-space: normal;"><span style="color: rgb(49, 188, 173);">优化思路</span></strong></h1> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在</span><a href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">User-centric Performance Metrics</span></a><span style="font-size: 15px;">一文中，共提到了4个页面渲染的关键指标：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.3485714285714286" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayP2oJmgC3oboqgdEEx0lEN6yOM3gcDmLucIS9Aibca7CKZibPmxF0Mx26w/640?wx_fmt=png" data-type="png" data-w="1400" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayP2oJmgC3oboqgdEEx0lEN6yOM3gcDmLucIS9Aibca7CKZibPmxF0Mx26w/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">基于这个理论基础，再回过头来看看之前项目的实际表现：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.4385026737967914" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPtq0T6kThAEBh1zeIvmqdQHvyQ5cWnibm31Jo4iaFIaydia2EaotpvA0aQ/640?wx_fmt=png" data-type="png" data-w="1870" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPtq0T6kThAEBh1zeIvmqdQHvyQ5cWnibm31Jo4iaFIaydia2EaotpvA0aQ/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">可见在 FP 的灰白屏界面停留了很长时间，用户不清楚网站是否有在正常加载，用户体验很差。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">试想：如果我们可以将 FCP 或 FMP 完整的 HTML 文档提前到 FP 时机预渲染，用户看到页面框架，能感受到页面正在加载而不是冷冰冰的灰白屏，那么用户更愿意等待页面加载完成，从而降低了流失率。并且这种改观在弱网环境下更明显。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过对比 FP、FCP、FMP 这三个时期 DOM 的差异，发现区别在于：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.8028503562945368" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPg4lsgmBu0aMNpicAvmSqD7ib10r37JRFp2XuyAoHkwFgjULWFmpkOCWg/640?wx_fmt=png" data-type="png" data-w="842" style="width: 558px;height: 448px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPg4lsgmBu0aMNpicAvmSqD7ib10r37JRFp2XuyAoHkwFgjULWFmpkOCWg/640?wx_fmt=png"></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1.1374045801526718" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPYKGzMCDwUtROhnfguTtMgIoMXKibIwkoKJCD22pzNGudbsPRG87z88A/640?wx_fmt=png" data-type="png" data-w="786" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPYKGzMCDwUtROhnfguTtMgIoMXKibIwkoKJCD22pzNGudbsPRG87z88A/640?wx_fmt=png"></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1.3183098591549296" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPE1UeSwn36KyrjpA2D8xc8HRcCG3pmYDj56HQP6PWY590EjHUtTL1Vg/640?wx_fmt=png" data-type="png" data-w="710" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPE1UeSwn36KyrjpA2D8xc8HRcCG3pmYDj56HQP6PWY590EjHUtTL1Vg/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">FP：仅有一个 div 根节点。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">FCP：包含页面的基本框架，但没有数据内容。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">FMP：包含页面所有元素及数据。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">仍然以 Vue 为例， 在其生命周期中，mounted 对应的是 FCP，updated 对应的是 FMP。那么具体应该使用哪个生命周期的 HTML 结构呢？</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.25125628140703515" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPkXxcjvt2F8Dictql9cjq7A09BftqjtZmkKIib2pSZhdrWOqU51y4QoKw/640?wx_fmt=png" data-type="png" data-w="1393" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPkXxcjvt2F8Dictql9cjq7A09BftqjtZmkKIib2pSZhdrWOqU51y4QoKw/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过以上的对比，最终选择在 mounted 时触发构建时预渲染。由于我们采用的是 CSR 的架构，没有 Node 作为中间层，因此要实现 DOM 内容的预渲染，就需要在项目构建编译时完成对原始模板的更新替换。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">至此，我们明确了构建时预渲染的大体方案。</span></p> 
 <h1><strong style="color: rgb(51, 51, 51);font-size: 20px;white-space: normal;"><span style="color: rgb(49, 188, 173);">构建时预渲染方案</span></strong></h1> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">构建时预渲染流程：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.3175182481751825" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPcMy8dq5nDSIgeXLibb0O8rffQFwjyXzPB28cNBOOO2tc6VTOTxAARFQ/640?wx_fmt=png" data-type="png" data-w="1644" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPcMy8dq5nDSIgeXLibb0O8rffQFwjyXzPB28cNBOOO2tc6VTOTxAARFQ/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <h2><span style="font-size: 18px;"><strong>配置读取</strong></span></h2> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">由于 SPA 可以由多个路由构成，需要根据业务场景决定哪些路由需要用到预渲染。因此这里的配置文件主要是用于告知编译器需要进行预渲染的路由。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在我们的系统架构里，脚手架是基于 Webpack 自研的，在此基础上可以自定义自动化构建任务和配置。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.5317919075144508" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPsC5WT5w520k2kJclogasGgFXFib4T2VOKCmYyDXSHtGf7V3aCY0rqug/640?wx_fmt=png" data-type="png" data-w="1038" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPsC5WT5w520k2kJclogasGgFXFib4T2VOKCmYyDXSHtGf7V3aCY0rqug/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <h2><span style="font-size: 18px;"><strong>触发构建</strong></span></h2> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">项目中主要是使用 TypeScript，利用 TS 的</span><a href="https://www.typescriptlang.org/docs/handbook/decorators.html" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">装饰器</span></a><span style="font-size: 15px;">，我们封装了统一的预渲染构建的钩子方法，从而只用一行代码即可完成构建时预渲染的触发。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">装饰器：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.3389830508474576" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPF8W5yZic9fsenwUZCY3ibzfP6wHUWpYPPpiaSrBsN3Mlgd5daUjFiazLow/640?wx_fmt=png" data-type="png" data-w="944" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPF8W5yZic9fsenwUZCY3ibzfP6wHUWpYPPpiaSrBsN3Mlgd5daUjFiazLow/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">使用：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.8610526315789474" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPrdW3YbxRHQ84PyRsYpLImgicMS7GmvsHtBAnGp94G6e0xq9Tia9SEPrQ/640?wx_fmt=png" data-type="png" data-w="950" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPrdW3YbxRHQ84PyRsYpLImgicMS7GmvsHtBAnGp94G6e0xq9Tia9SEPrQ/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <h2><span style="font-size: 18px;"><strong>构建编译</strong></span></h2> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">从流程图上，需要在发布机上启动模拟的浏览器环境，并通过预渲染的事件钩子获取当前的页面内容，生成最终的 HTML 文件。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">由于我们在预渲染上的尝试比较早，当时还没有 </span><a href="https://developers.google.com/web/updates/2017/04/headless-chrome" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">Headless Chrome</span></a><span style="font-size: 15px;"> 、 </span><a href="https://github.com/GoogleChrome/puppeteer" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">Puppeteer</span></a><span style="font-size: 15px;">、</span><a href="https://www.npmjs.com/package/prerender-spa-plugin" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">Prerender SPA Plugin</span></a><span style="font-size: 15px;">等，因此在选型上使用的是 </span><a href="https://www.npmjs.com/package/phantomjs-prebuilt" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">phantomjs-prebuilt</span></a><span style="font-size: 15px;">（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">Prerender SPA Plugin 早期版本也是基于 phantomjs-prebuilt 实现的</span><span style="font-size: 15px;">）。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过 phantom 提供的 API 可获得当前 HTML，示例如下：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.710267229254571" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPtZIhTibn15gS5whmxzQKuhPsmC4KwfQOKRLE9rRbKic5YIGKtk7wMyQw/640?wx_fmt=png" data-type="png" data-w="1422" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPtZIhTibn15gS5whmxzQKuhPsmC4KwfQOKRLE9rRbKic5YIGKtk7wMyQw/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">为了提高构建效率，并行对配置的多个页面或路由进行预渲染构建，保证在 5S 内即可完成构建，流程图如下：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.6161879895561357" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPNfNcr046EiaVmRh6zSDG3VInGGwibsV6dU7FWXUWPV6rzoDFhGFmrRBA/640?wx_fmt=png" data-type="png" data-w="1532" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPNfNcr046EiaVmRh6zSDG3VInGGwibsV6dU7FWXUWPV6rzoDFhGFmrRBA/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <h1><strong style="color: rgb(51, 51, 51);font-size: 20px;white-space: normal;"><span style="color: rgb(49, 188, 173);">方案优化</span></strong></h1> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">理想很丰满，现实很骨感。在实际投产中，构建时预渲染方案遇到了一个问题。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们梳理一下简化后的项目上线过程：</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">开发 -&gt; 编译 -&gt; 上线</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">假设本次修改了静态文件中的一个 JS 文件，这个文件会通过 CDN 方式在 HTML 里引用，那么最终在 HTML 文档中的引用方式是 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">&lt;script src="http://cdn.com/index.js"&gt;&lt;/script&gt;</span></code><span style="font-size: 15px;">。然而由于项目还没有上线，所以其实通过完整 URL 的方式是获取不到这个文件的；而预渲染的构建又是在上线动作之前，所以问题就产生了：</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">构建时预渲染无法正常获取文件，导致编译报错</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">怎么办？</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">请求劫持</strong></span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">因为在做预渲染时，我们使用启动了一个模拟的浏览器环境，根据 phantom 提供的 API，可以对发出的请求加以劫持，将获取 CDN 文件的请求劫持到本地，从而在根本上解决了这个问题。示例代码如下：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.2622739018087855" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPfJibia2cfWfgSCy24sj3m2Ugeons9HvVfWicwVqALBAyOxFvanOtpD0rA/640?wx_fmt=png" data-type="png" data-w="1548" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPfJibia2cfWfgSCy24sj3m2Ugeons9HvVfWicwVqALBAyOxFvanOtpD0rA/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <h1><strong style="color: rgb(51, 51, 51);font-size: 20px;white-space: normal;"><span style="color: rgb(49, 188, 173);">构建时预渲染研发流程及效果</span></strong></h1> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">最终，构建时预渲染研发流程如下：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.3516609392898053" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPKhsU6eTgXs3UZmEP77XUIGbBiaPlBH3VnibvnODdkqGEMw5M4Zlwke4w/640?wx_fmt=png" data-type="png" data-w="1746" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPKhsU6eTgXs3UZmEP77XUIGbBiaPlBH3VnibvnODdkqGEMw5M4Zlwke4w/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">开发阶段：</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">通过 TypeScript 的装饰器单行引入预渲染构建触发的方法。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">发布前修改编译构建的配置文件。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">发布阶段：</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">先进行常规的项目构建。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">若有预渲染相关配置，则触发预渲染构建。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">通过预渲染得到最终的文件，并完成发布上线动作。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">完整的用户请求路径如下：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.5423514538558787" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPqL4lEkNO2UImrJdjnLj58xZf8S7NWjcMXbuzORlPJwiaCkVibVFPo5Rg/640?wx_fmt=png" data-type="png" data-w="1582" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPqL4lEkNO2UImrJdjnLj58xZf8S7NWjcMXbuzORlPJwiaCkVibVFPo5Rg/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过构建时预渲染在项目中的使用，FCP 的时间相比之前减少了 75%。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.5293367346938775" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPTrQOLrBh5fGMEfwNmOlUwSP21B3dnkEwb4dWbXQL3u2mJhW5xqMXqQ/640?wx_fmt=png" data-type="png" data-w="1568" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWB3KocbKmHI6gmJ1YbfayPTrQOLrBh5fGMEfwNmOlUwSP21B3dnkEwb4dWbXQL3u2mJhW5xqMXqQ/640?wx_fmt=png"></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption> 
 </figure> 
 <h2><strong style="color: rgb(51, 51, 51);font-size: 16px;white-space: normal;"><span style="color: rgb(49, 188, 173);">作者简介</span></strong></h2> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;color: rgb(136, 136, 136);">寒阳，美团资深研发工程师，多年前端研发经历，负责美团支付钱包团队和美团支付前端基础技术。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;color: rgb(136, 136, 136);"><span style="font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);">欢迎加入</span><strong style="color: rgb(51, 51, 51);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);"><span style="color: rgb(0, 0, 0);">美团前端技术交流群</span></strong><span style="font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);">，跟作者零距离交流。进群方式：请加美美同学</span><span style="letter-spacing: 0px;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);">微信（微信号：<strong>MTDPtech01）</strong>，回复：</span></span><span style="letter-spacing: 0px;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);font-size: 15px;color: rgb(0, 0, 0);"><strong>前端</strong></span><span style="letter-spacing: 0px;color: rgb(136, 136, 136);font-size: 15px;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);">，美美会自动拉你进群。</span></p> 
</section> 
<p style="white-space: normal;color: rgb(51, 51, 51);text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 15px;color: rgb(136, 136, 136);">----------&nbsp; END&nbsp; ----------</span></p> 
<p data-source-line="194" style="white-space: normal;color: rgb(51, 51, 51);margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 16px;"><strong><span style="color: rgb(49, 188, 173);">招聘信息</span></strong></span></p> 
<p style="white-space: normal;color: rgb(51, 51, 51);margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<section data-source="bj.96weixin.com" style="font-size: 16px;white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"> 
 <section style="padding: 20px 20px 15px;width: 670px;text-decoration: inherit;background-color: rgb(245, 245, 245);"> 
  <p style="line-height: normal;"><span style="font-size: 15px;"><span style="font-family: Arial, sans-serif;font-weight: bold;text-decoration: inherit;color: rgb(128, 128, 128);"></span><span style="color: rgb(136, 136, 136);"></span></span><span style="color: rgb(62, 62, 62);font-size: 14px;">我们美团金融服务平台大前端研发组在高速成长中，我们欢迎更多优秀的 Web 前端研发工程师加入，感兴趣的朋友可以将简历发送到邮箱：shanghanyang@meituan.com。</span></p> 
 </section> 
</section> 
<p data-source-line="194" style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 16px;"><strong><span style="color: rgb(49, 188, 173);">也许你还想看</span></strong></span></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 16px;"><strong><span style="color: rgb(49, 188, 173);"><br></span></strong></span></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 14px;text-decoration: underline;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651746195&amp;idx=2&amp;sn=28a658cdfd9b4c5bdb0129285aed945a&amp;chksm=bd12b6de8a653fc848a64aacd8bec01c4a49a5a7ee1d9401f7e389734d277b7bbd120c6f6c06&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;">前端渲染引擎doT.js解析</a></span></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748310&amp;idx=2&amp;sn=4fd53ebffe6a87b29fcb87ef48808ffd&amp;chksm=bd12ae9b8a65278d803400b3faa547df7a86656f6008540f6209d3fa194078873e615da552e8&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">前端遇上Go: 静态资源增量更新的新实践</span></a><br></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651747704&amp;idx=2&amp;sn=f2c216c1ca8f364827226f8742eb3a57&amp;chksm=bd12ac358a652523bd7504a339e5c075aa627ec2c3cea1fb458f5d42909e81e12c50b0f1d473&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">美团点评金融平台Web前端技术体系</span></a><br></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 15px;"></span></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.44533333333333336" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png" data-type="png" data-w="1875" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png"></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
