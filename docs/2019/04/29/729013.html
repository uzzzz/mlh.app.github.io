<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>使用云原生buildpacks将你的代码转换成Docker Image   技术头条 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="使用云原生buildpacks将你的代码转换成Docker Image   技术头条" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="戳蓝字“CSDN云计算”关注我们哦！ 技术头条：干货、简洁、多维全面。更多云计算精华知识尽在眼前，get要点、solve难题，统统不在话下！ 当我们在大概七年前将buildpack技术开源的时候，我们就知道这项技术将大大简化应用的发布过程。当一个开发人员要跑一个：git push heroku master的时候，一个buildpack就可以保证所有的依赖以及编译工作都会作为发布的一部分被全权打理好。 一如之前所宣布，我们正在将buildpacks之所以如此成功的哲学理论运用到创立云原生buildpacks(CNB)，一种再也不需要dockerfile并将源代码转换为Docker Image的标准。在这篇文档里，我们会简单地看一下CNB 是如何工作的，它是如何旨在解决许多现存于dockerfile上的问题， 以及你如何可以将它和最近发布的 buildpacks.io 项目 beta版本一起使用。作为这次发布的一部分，我们已经给 Ruby, Node.js, Java, Python, PHP, 以及Go建立好了可以使用CNB&nbsp;工具的Heroku buildpacks builder image。 &nbsp; 我们先从创造一个稻草人（假设模型）开始。我们会通过一些比较冗长无聊但却很根本且必须的步骤来创建一个Ruby on Rails 应用的Dockerfile。 &nbsp; 抽象泄露：递增地来写一个Dockerfile &nbsp; 大多开发者以写一个dockerfile 来使用Docker，这个file会定义整个生成Docker image的build流程。比如说， 你手里有一个的Rails 项目，并且你希望将它以一个Docker Container来发布。你会需要从一个基本的Ruby Image 开始， 将其他额外需要的包加入进来，以此来让你的应用跑起来。如果你从未用过Docker，你可能要先学几样东西才能到这一步。 FROM ruby RUN apt-get update -qq \ &nbsp;&nbsp;&amp;&amp; apt-get install -y nodejs libpq-dev build-essential COPY . /app WORKDIR /app RUN bundle install RUN bundle exec rake assets:precompile EXPOSE 5000 CMD bin/rails s &nbsp; 除了Ruby以外，一个Rails应用的Docker&nbsp;image&nbsp;也将会需要几个额外的 Apt包。要想跑用来预编译assets的必须要的工具， node js &nbsp;的runtime一定要被包含在其中；为了要和PostgreSQL 交流， libpq-dev也是需要的；以及为了让gcc能够给Ruby&nbsp;gems&nbsp;们build原生的插件（一个Ruby包管理器，类似Python的 pip），我们还会需要到build-essential。 &nbsp; 一个Dockerfile&nbsp;已经足够用来在生产环境跑一个简单的Rails应用，但是整个image会充满很多非相关的缓存文件夹。你或许会想去掉那些文件，以缩减整个image大小，但这只会对本地有序性build有用。 RUN apt-get update -qq \ &nbsp;&nbsp;&amp;&amp; apt-get install -y nodejs libpq-dev build-essential \ &nbsp;&nbsp;&amp;&amp; apt-get clean autoclean &amp;&amp; apt-get autoremove -y \ &nbsp;&nbsp;&amp;&amp; rm -rf /var/lib/apt /var/lib/dpkg /var/lib/cache /var/lib/log # .. RUN bundle exec rake assets:precompile &nbsp;&nbsp;&amp;&amp; rm -rf /app/tmp/cache/assets/ &nbsp; 这便突出了使用Dockerfile在速度上的短板。它并不能适当利用那些缓存目录，只因为一次rebuild就会要把整个image从头build。然而，我们可以利用些聪明的小技巧来缓存依赖（dependency）的信息来加速builds。相比较每次复制整个应用，你可以如下选择性地加入文件。 ADD Gemfile /app/ ADD Gemfile.lock &nbsp;/app/ RUN bundle install &nbsp; 复制加入Gemfile 和Gemfile.lock 可以用来取代dockerfile的缓存机制，以此来防止因为仅你更改了一行代码而导致所有的缓存失效。 &nbsp; 这些例子仅强调出了“几个” 当使用Dockerfile构建应用时的挑战和难点。而且你会在每次使用Dockerfile构建应用时都会重复遇见这些困难。多数情况下，最后你都会复制粘贴某个应用Dockerfile 的一部分到另外一个应用的Dockerfile，而这种行为会潜在地造成维护人员噩梦。 &nbsp; 维护，是Dockerfile最大的短板。除了复制粘贴代码，它给你带来了一些如果你不使用Dockerfile是绝对不会关心的低等级问题。举例来说，和很多其他编程语言一样，Ruby有很多基本image 可以给你用来继承使用，而且每个image都有自己的大小和安全性考量。如果有一天，Rails的生态系统系要一个新的依赖（dependency），而这个新的依赖并不存在于你现有的Dockerfile，那你就要负责根据需要更新相关的设置。如果你把你的项目分拆成多个“微服务”（microservices），同时也意味着你需要在多个位置更新你的文件。 最终来说，Dockerfile是个具有漏洞性的抽象概念。它强制开发者们要小心运作上，以及平台的需要注意点，而在这之前这些需要注意点都已经被平台抽象打理了。要想写出一个好的Dockerfile，你就必须理解底层机制，以及产生image的每一步是如何工作的并以此来打理未来的更新。 所有的这些问题都源于Dockerfile缺少对应用的相对了解。如果没有你的应用相关或所使用架构的上下文相关信息，开发者如何开发和他们使用的工具就会产生巨大的不匹配现象。 像这样将运行和应用的关注点混合在一起就相当于给了一个希望尽量容易去写代码以及运输代码的开发者一个非常差的工具。基于此类不足之处，我们接下来看一下另外一种可以减少此类复杂度的替代办法。 向Buildpacks学习 如果你曾经使用Heroku来发布你的应用你就会知道，这就像在本地跑一个 git push heroku master 一样容易。而在幕后，一个 buildpack 就会收集依赖（retrieve dependencies），运行数据信息，打理缓存，并且给你的应用语言编译代码。举例来说，有一个Rails 应用。Ruby的buildpack就会安装Ruby和 bundler（一个Ruby的依赖管理应用）。你的gem（一系列包和文件的总称）依赖会被提取出来，你的资源代码会被编译，而且缓存也会被清理干净： git push heroku master remote: Compressing source files... done. remote: Building source: remote: -----&gt; Ruby app detected remote: -----&gt; Compiling Ruby/Rails remote: -----&gt; Using Ruby version: ruby-2.6.0 remote: -----&gt; Installing dependencies using bundler 1.15.2 remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment ... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundle complete! 18 Gemfile dependencies, 61 gems now installed. remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gems in the groups development and test were not installed. remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundled gems are installed into `./vendor/bundle` remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removing bundler (1.15.2) remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundle completed (42.62s) remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleaning up the bundler cache. ... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asset precompilation completed (3.72s) remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleaning assets remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running: rake assets:clean remote: -----&gt; Detecting rails configuration remote: -----&gt; Compressing... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Done: 41.3M remote: -----&gt; Launching... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Released v6 remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://myapp.herokuapp.com/ deployed to Heroku remote: remote: Verifying deploy... done. &nbsp; 一个Buildpack以识别你应用代码语言的行为惯例帮你自动处理了这些步骤。Builpacks的设计原则就是就是安装并设置所有需要的设置以帮你达到运行你的应用的目的。站在云原生Buildpacks的角度来说，我们希望利用Docker和现代container标准，有一个相似的系统来让我们的开发者更加注重于他们的应用，而不是拼凑一个build管道。 &nbsp; 运行云原生Buildpacks 因为希望能够将 Buildpacks&nbsp;的简洁性和可用性与container的优势结合起来，我们开发了云原生Buildpacks（CNB），它可以产出一个 “开放容器计划”兼容（OCI-Compliant）image, 并且这个image可以使用现存 的Docker 工具，以及更广阔的现存容器生态系统。 Buildpacks.io项目是一个让我们愿景成可能的开源工具之家。其中，第一个工具便是 pack build，其行为和git push heroku master非常相似。你可以在任意资源库下产生一个Docker image。以下便是一个在Rails应用上跑的Heroku云原生buildpack的例子。 &nbsp; 和buildpack产生可执行的压缩文件（slug）很相似， 一个CNB会根据你现有项目的文件识别什么东西需要被安装。你不需要进行任何配置来识别确认你的应用的需求。因为buildpack 是应用感知的（app-aware），它能够精准地捕捉到你所使用的编程语言以及你应用的所需依赖，在build阶段也同样会有着合理的系统默认值来处理内存的使用和处理并发。 &nbsp; CNB 进程在产生最后image的进行的步骤和现存Heroku Buildpacks运作的不同阶段非常相似： ·&nbsp;CLI 侦测到你的项目使用的主要语言。比如说，如果你的源代码目录下有一个Gemfile，那么CNB就会将它识别为一个Ruby项目；如果有个pom.xml那么它就会被识别为一个Java项目，以此类推。 ·&nbsp;之后，执行环境会分析之前的build来确认其中是否有任何步骤可以在接下来build中使用。 ·&nbsp;CNB开始跑build，下载所需的依赖以及将应用准备好可以在production当中运行。 ·&nbsp;最后，它会将以上build的结果以Docker image的形式导出。 &nbsp; 产出一个image的底层幕后进程全权被buildpack所打理。如果这个进程需要被更新-比如有个漏洞被检测到-你可以很轻松地获取一个新的工具链并且用 pack rebase重新build一个image来更新你的image而不用从头开始build一个image， 整个过程花费不到一秒钟。和用Dockerfile在你每一个应用上rebuild相比（一个可能耗费几个小时的过程），这会节省大量的时间。 &nbsp; 现在就来试一下云原生Buildpacks吧！ &nbsp; 再也没有比现在更好的时机来尝试一下云原生Buildpacks（CNB）了。这个项目刚刚出了它第一个beta 版本， 它已经准备好被你使用，也希望到你的反馈！ 如何开始呢？先下载 pack CLI&nbsp;并且在你的应用源代码目录下使用我们任一buildpack（Ruby,&nbsp;&nbsp;Node.js, Java, Python, PHP, Go）。 &nbsp; $ pack build --builder heroku/buildpacks &lt;docker image name&gt; 来Slack上加入我们！如果你还想生成你自己的OCI Images，我们还有定义了使用细则的buildpack API文档 。 Heroku 一直以来都认为切合开发者的关注和需求是非常重要的：即他们应用的源代码。我们相信云原生Buildpacks 会因为以建立了基于容器的应用而帮助减少在运行维护上的复杂度，从而解放了开发者双手来专注于给他们的用户创作更多优秀的的功能和特性。 &nbsp; 福利 扫描添加小编微信，备注“姓名+公司职位”，加入【云计算学习交流群】，和志同道合的朋友们共同打卡学习！ 推荐阅读： Elastic Jeff Yoshimura：开源正在开启新一轮的创新 | 人物志 深入浅出Docker 镜像 | 技术头条 19岁当老板, 20岁ICO失败, 21岁将项目挂到了eBay, 为何初创公司如此艰难? 码二代的出路是什么？ 机器学习萌新必备的三种优化算法 | 选型指南 小程序的侵权“生死局” @996 程序员，ICU 你真的去不起！ 真香，朕在看了！" />
<meta property="og:description" content="戳蓝字“CSDN云计算”关注我们哦！ 技术头条：干货、简洁、多维全面。更多云计算精华知识尽在眼前，get要点、solve难题，统统不在话下！ 当我们在大概七年前将buildpack技术开源的时候，我们就知道这项技术将大大简化应用的发布过程。当一个开发人员要跑一个：git push heroku master的时候，一个buildpack就可以保证所有的依赖以及编译工作都会作为发布的一部分被全权打理好。 一如之前所宣布，我们正在将buildpacks之所以如此成功的哲学理论运用到创立云原生buildpacks(CNB)，一种再也不需要dockerfile并将源代码转换为Docker Image的标准。在这篇文档里，我们会简单地看一下CNB 是如何工作的，它是如何旨在解决许多现存于dockerfile上的问题， 以及你如何可以将它和最近发布的 buildpacks.io 项目 beta版本一起使用。作为这次发布的一部分，我们已经给 Ruby, Node.js, Java, Python, PHP, 以及Go建立好了可以使用CNB&nbsp;工具的Heroku buildpacks builder image。 &nbsp; 我们先从创造一个稻草人（假设模型）开始。我们会通过一些比较冗长无聊但却很根本且必须的步骤来创建一个Ruby on Rails 应用的Dockerfile。 &nbsp; 抽象泄露：递增地来写一个Dockerfile &nbsp; 大多开发者以写一个dockerfile 来使用Docker，这个file会定义整个生成Docker image的build流程。比如说， 你手里有一个的Rails 项目，并且你希望将它以一个Docker Container来发布。你会需要从一个基本的Ruby Image 开始， 将其他额外需要的包加入进来，以此来让你的应用跑起来。如果你从未用过Docker，你可能要先学几样东西才能到这一步。 FROM ruby RUN apt-get update -qq \ &nbsp;&nbsp;&amp;&amp; apt-get install -y nodejs libpq-dev build-essential COPY . /app WORKDIR /app RUN bundle install RUN bundle exec rake assets:precompile EXPOSE 5000 CMD bin/rails s &nbsp; 除了Ruby以外，一个Rails应用的Docker&nbsp;image&nbsp;也将会需要几个额外的 Apt包。要想跑用来预编译assets的必须要的工具， node js &nbsp;的runtime一定要被包含在其中；为了要和PostgreSQL 交流， libpq-dev也是需要的；以及为了让gcc能够给Ruby&nbsp;gems&nbsp;们build原生的插件（一个Ruby包管理器，类似Python的 pip），我们还会需要到build-essential。 &nbsp; 一个Dockerfile&nbsp;已经足够用来在生产环境跑一个简单的Rails应用，但是整个image会充满很多非相关的缓存文件夹。你或许会想去掉那些文件，以缩减整个image大小，但这只会对本地有序性build有用。 RUN apt-get update -qq \ &nbsp;&nbsp;&amp;&amp; apt-get install -y nodejs libpq-dev build-essential \ &nbsp;&nbsp;&amp;&amp; apt-get clean autoclean &amp;&amp; apt-get autoremove -y \ &nbsp;&nbsp;&amp;&amp; rm -rf /var/lib/apt /var/lib/dpkg /var/lib/cache /var/lib/log # .. RUN bundle exec rake assets:precompile &nbsp;&nbsp;&amp;&amp; rm -rf /app/tmp/cache/assets/ &nbsp; 这便突出了使用Dockerfile在速度上的短板。它并不能适当利用那些缓存目录，只因为一次rebuild就会要把整个image从头build。然而，我们可以利用些聪明的小技巧来缓存依赖（dependency）的信息来加速builds。相比较每次复制整个应用，你可以如下选择性地加入文件。 ADD Gemfile /app/ ADD Gemfile.lock &nbsp;/app/ RUN bundle install &nbsp; 复制加入Gemfile 和Gemfile.lock 可以用来取代dockerfile的缓存机制，以此来防止因为仅你更改了一行代码而导致所有的缓存失效。 &nbsp; 这些例子仅强调出了“几个” 当使用Dockerfile构建应用时的挑战和难点。而且你会在每次使用Dockerfile构建应用时都会重复遇见这些困难。多数情况下，最后你都会复制粘贴某个应用Dockerfile 的一部分到另外一个应用的Dockerfile，而这种行为会潜在地造成维护人员噩梦。 &nbsp; 维护，是Dockerfile最大的短板。除了复制粘贴代码，它给你带来了一些如果你不使用Dockerfile是绝对不会关心的低等级问题。举例来说，和很多其他编程语言一样，Ruby有很多基本image 可以给你用来继承使用，而且每个image都有自己的大小和安全性考量。如果有一天，Rails的生态系统系要一个新的依赖（dependency），而这个新的依赖并不存在于你现有的Dockerfile，那你就要负责根据需要更新相关的设置。如果你把你的项目分拆成多个“微服务”（microservices），同时也意味着你需要在多个位置更新你的文件。 最终来说，Dockerfile是个具有漏洞性的抽象概念。它强制开发者们要小心运作上，以及平台的需要注意点，而在这之前这些需要注意点都已经被平台抽象打理了。要想写出一个好的Dockerfile，你就必须理解底层机制，以及产生image的每一步是如何工作的并以此来打理未来的更新。 所有的这些问题都源于Dockerfile缺少对应用的相对了解。如果没有你的应用相关或所使用架构的上下文相关信息，开发者如何开发和他们使用的工具就会产生巨大的不匹配现象。 像这样将运行和应用的关注点混合在一起就相当于给了一个希望尽量容易去写代码以及运输代码的开发者一个非常差的工具。基于此类不足之处，我们接下来看一下另外一种可以减少此类复杂度的替代办法。 向Buildpacks学习 如果你曾经使用Heroku来发布你的应用你就会知道，这就像在本地跑一个 git push heroku master 一样容易。而在幕后，一个 buildpack 就会收集依赖（retrieve dependencies），运行数据信息，打理缓存，并且给你的应用语言编译代码。举例来说，有一个Rails 应用。Ruby的buildpack就会安装Ruby和 bundler（一个Ruby的依赖管理应用）。你的gem（一系列包和文件的总称）依赖会被提取出来，你的资源代码会被编译，而且缓存也会被清理干净： git push heroku master remote: Compressing source files... done. remote: Building source: remote: -----&gt; Ruby app detected remote: -----&gt; Compiling Ruby/Rails remote: -----&gt; Using Ruby version: ruby-2.6.0 remote: -----&gt; Installing dependencies using bundler 1.15.2 remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment ... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundle complete! 18 Gemfile dependencies, 61 gems now installed. remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gems in the groups development and test were not installed. remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundled gems are installed into `./vendor/bundle` remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removing bundler (1.15.2) remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundle completed (42.62s) remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleaning up the bundler cache. ... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asset precompilation completed (3.72s) remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleaning assets remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running: rake assets:clean remote: -----&gt; Detecting rails configuration remote: -----&gt; Compressing... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Done: 41.3M remote: -----&gt; Launching... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Released v6 remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://myapp.herokuapp.com/ deployed to Heroku remote: remote: Verifying deploy... done. &nbsp; 一个Buildpack以识别你应用代码语言的行为惯例帮你自动处理了这些步骤。Builpacks的设计原则就是就是安装并设置所有需要的设置以帮你达到运行你的应用的目的。站在云原生Buildpacks的角度来说，我们希望利用Docker和现代container标准，有一个相似的系统来让我们的开发者更加注重于他们的应用，而不是拼凑一个build管道。 &nbsp; 运行云原生Buildpacks 因为希望能够将 Buildpacks&nbsp;的简洁性和可用性与container的优势结合起来，我们开发了云原生Buildpacks（CNB），它可以产出一个 “开放容器计划”兼容（OCI-Compliant）image, 并且这个image可以使用现存 的Docker 工具，以及更广阔的现存容器生态系统。 Buildpacks.io项目是一个让我们愿景成可能的开源工具之家。其中，第一个工具便是 pack build，其行为和git push heroku master非常相似。你可以在任意资源库下产生一个Docker image。以下便是一个在Rails应用上跑的Heroku云原生buildpack的例子。 &nbsp; 和buildpack产生可执行的压缩文件（slug）很相似， 一个CNB会根据你现有项目的文件识别什么东西需要被安装。你不需要进行任何配置来识别确认你的应用的需求。因为buildpack 是应用感知的（app-aware），它能够精准地捕捉到你所使用的编程语言以及你应用的所需依赖，在build阶段也同样会有着合理的系统默认值来处理内存的使用和处理并发。 &nbsp; CNB 进程在产生最后image的进行的步骤和现存Heroku Buildpacks运作的不同阶段非常相似： ·&nbsp;CLI 侦测到你的项目使用的主要语言。比如说，如果你的源代码目录下有一个Gemfile，那么CNB就会将它识别为一个Ruby项目；如果有个pom.xml那么它就会被识别为一个Java项目，以此类推。 ·&nbsp;之后，执行环境会分析之前的build来确认其中是否有任何步骤可以在接下来build中使用。 ·&nbsp;CNB开始跑build，下载所需的依赖以及将应用准备好可以在production当中运行。 ·&nbsp;最后，它会将以上build的结果以Docker image的形式导出。 &nbsp; 产出一个image的底层幕后进程全权被buildpack所打理。如果这个进程需要被更新-比如有个漏洞被检测到-你可以很轻松地获取一个新的工具链并且用 pack rebase重新build一个image来更新你的image而不用从头开始build一个image， 整个过程花费不到一秒钟。和用Dockerfile在你每一个应用上rebuild相比（一个可能耗费几个小时的过程），这会节省大量的时间。 &nbsp; 现在就来试一下云原生Buildpacks吧！ &nbsp; 再也没有比现在更好的时机来尝试一下云原生Buildpacks（CNB）了。这个项目刚刚出了它第一个beta 版本， 它已经准备好被你使用，也希望到你的反馈！ 如何开始呢？先下载 pack CLI&nbsp;并且在你的应用源代码目录下使用我们任一buildpack（Ruby,&nbsp;&nbsp;Node.js, Java, Python, PHP, Go）。 &nbsp; $ pack build --builder heroku/buildpacks &lt;docker image name&gt; 来Slack上加入我们！如果你还想生成你自己的OCI Images，我们还有定义了使用细则的buildpack API文档 。 Heroku 一直以来都认为切合开发者的关注和需求是非常重要的：即他们应用的源代码。我们相信云原生Buildpacks 会因为以建立了基于容器的应用而帮助减少在运行维护上的复杂度，从而解放了开发者双手来专注于给他们的用户创作更多优秀的的功能和特性。 &nbsp; 福利 扫描添加小编微信，备注“姓名+公司职位”，加入【云计算学习交流群】，和志同道合的朋友们共同打卡学习！ 推荐阅读： Elastic Jeff Yoshimura：开源正在开启新一轮的创新 | 人物志 深入浅出Docker 镜像 | 技术头条 19岁当老板, 20岁ICO失败, 21岁将项目挂到了eBay, 为何初创公司如此艰难? 码二代的出路是什么？ 机器学习萌新必备的三种优化算法 | 选型指南 小程序的侵权“生死局” @996 程序员，ICU 你真的去不起！ 真香，朕在看了！" />
<link rel="canonical" href="https://mlh.app/2019/04/29/729013.html" />
<meta property="og:url" content="https://mlh.app/2019/04/29/729013.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"戳蓝字“CSDN云计算”关注我们哦！ 技术头条：干货、简洁、多维全面。更多云计算精华知识尽在眼前，get要点、solve难题，统统不在话下！ 当我们在大概七年前将buildpack技术开源的时候，我们就知道这项技术将大大简化应用的发布过程。当一个开发人员要跑一个：git push heroku master的时候，一个buildpack就可以保证所有的依赖以及编译工作都会作为发布的一部分被全权打理好。 一如之前所宣布，我们正在将buildpacks之所以如此成功的哲学理论运用到创立云原生buildpacks(CNB)，一种再也不需要dockerfile并将源代码转换为Docker Image的标准。在这篇文档里，我们会简单地看一下CNB 是如何工作的，它是如何旨在解决许多现存于dockerfile上的问题， 以及你如何可以将它和最近发布的 buildpacks.io 项目 beta版本一起使用。作为这次发布的一部分，我们已经给 Ruby, Node.js, Java, Python, PHP, 以及Go建立好了可以使用CNB&nbsp;工具的Heroku buildpacks builder image。 &nbsp; 我们先从创造一个稻草人（假设模型）开始。我们会通过一些比较冗长无聊但却很根本且必须的步骤来创建一个Ruby on Rails 应用的Dockerfile。 &nbsp; 抽象泄露：递增地来写一个Dockerfile &nbsp; 大多开发者以写一个dockerfile 来使用Docker，这个file会定义整个生成Docker image的build流程。比如说， 你手里有一个的Rails 项目，并且你希望将它以一个Docker Container来发布。你会需要从一个基本的Ruby Image 开始， 将其他额外需要的包加入进来，以此来让你的应用跑起来。如果你从未用过Docker，你可能要先学几样东西才能到这一步。 FROM ruby RUN apt-get update -qq \\ &nbsp;&nbsp;&amp;&amp; apt-get install -y nodejs libpq-dev build-essential COPY . /app WORKDIR /app RUN bundle install RUN bundle exec rake assets:precompile EXPOSE 5000 CMD bin/rails s &nbsp; 除了Ruby以外，一个Rails应用的Docker&nbsp;image&nbsp;也将会需要几个额外的 Apt包。要想跑用来预编译assets的必须要的工具， node js &nbsp;的runtime一定要被包含在其中；为了要和PostgreSQL 交流， libpq-dev也是需要的；以及为了让gcc能够给Ruby&nbsp;gems&nbsp;们build原生的插件（一个Ruby包管理器，类似Python的 pip），我们还会需要到build-essential。 &nbsp; 一个Dockerfile&nbsp;已经足够用来在生产环境跑一个简单的Rails应用，但是整个image会充满很多非相关的缓存文件夹。你或许会想去掉那些文件，以缩减整个image大小，但这只会对本地有序性build有用。 RUN apt-get update -qq \\ &nbsp;&nbsp;&amp;&amp; apt-get install -y nodejs libpq-dev build-essential \\ &nbsp;&nbsp;&amp;&amp; apt-get clean autoclean &amp;&amp; apt-get autoremove -y \\ &nbsp;&nbsp;&amp;&amp; rm -rf /var/lib/apt /var/lib/dpkg /var/lib/cache /var/lib/log # .. RUN bundle exec rake assets:precompile &nbsp;&nbsp;&amp;&amp; rm -rf /app/tmp/cache/assets/ &nbsp; 这便突出了使用Dockerfile在速度上的短板。它并不能适当利用那些缓存目录，只因为一次rebuild就会要把整个image从头build。然而，我们可以利用些聪明的小技巧来缓存依赖（dependency）的信息来加速builds。相比较每次复制整个应用，你可以如下选择性地加入文件。 ADD Gemfile /app/ ADD Gemfile.lock &nbsp;/app/ RUN bundle install &nbsp; 复制加入Gemfile 和Gemfile.lock 可以用来取代dockerfile的缓存机制，以此来防止因为仅你更改了一行代码而导致所有的缓存失效。 &nbsp; 这些例子仅强调出了“几个” 当使用Dockerfile构建应用时的挑战和难点。而且你会在每次使用Dockerfile构建应用时都会重复遇见这些困难。多数情况下，最后你都会复制粘贴某个应用Dockerfile 的一部分到另外一个应用的Dockerfile，而这种行为会潜在地造成维护人员噩梦。 &nbsp; 维护，是Dockerfile最大的短板。除了复制粘贴代码，它给你带来了一些如果你不使用Dockerfile是绝对不会关心的低等级问题。举例来说，和很多其他编程语言一样，Ruby有很多基本image 可以给你用来继承使用，而且每个image都有自己的大小和安全性考量。如果有一天，Rails的生态系统系要一个新的依赖（dependency），而这个新的依赖并不存在于你现有的Dockerfile，那你就要负责根据需要更新相关的设置。如果你把你的项目分拆成多个“微服务”（microservices），同时也意味着你需要在多个位置更新你的文件。 最终来说，Dockerfile是个具有漏洞性的抽象概念。它强制开发者们要小心运作上，以及平台的需要注意点，而在这之前这些需要注意点都已经被平台抽象打理了。要想写出一个好的Dockerfile，你就必须理解底层机制，以及产生image的每一步是如何工作的并以此来打理未来的更新。 所有的这些问题都源于Dockerfile缺少对应用的相对了解。如果没有你的应用相关或所使用架构的上下文相关信息，开发者如何开发和他们使用的工具就会产生巨大的不匹配现象。 像这样将运行和应用的关注点混合在一起就相当于给了一个希望尽量容易去写代码以及运输代码的开发者一个非常差的工具。基于此类不足之处，我们接下来看一下另外一种可以减少此类复杂度的替代办法。 向Buildpacks学习 如果你曾经使用Heroku来发布你的应用你就会知道，这就像在本地跑一个 git push heroku master 一样容易。而在幕后，一个 buildpack 就会收集依赖（retrieve dependencies），运行数据信息，打理缓存，并且给你的应用语言编译代码。举例来说，有一个Rails 应用。Ruby的buildpack就会安装Ruby和 bundler（一个Ruby的依赖管理应用）。你的gem（一系列包和文件的总称）依赖会被提取出来，你的资源代码会被编译，而且缓存也会被清理干净： git push heroku master remote: Compressing source files... done. remote: Building source: remote: -----&gt; Ruby app detected remote: -----&gt; Compiling Ruby/Rails remote: -----&gt; Using Ruby version: ruby-2.6.0 remote: -----&gt; Installing dependencies using bundler 1.15.2 remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment ... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundle complete! 18 Gemfile dependencies, 61 gems now installed. remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gems in the groups development and test were not installed. remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundled gems are installed into `./vendor/bundle` remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removing bundler (1.15.2) remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundle completed (42.62s) remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleaning up the bundler cache. ... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asset precompilation completed (3.72s) remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleaning assets remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running: rake assets:clean remote: -----&gt; Detecting rails configuration remote: -----&gt; Compressing... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Done: 41.3M remote: -----&gt; Launching... remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Released v6 remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://myapp.herokuapp.com/ deployed to Heroku remote: remote: Verifying deploy... done. &nbsp; 一个Buildpack以识别你应用代码语言的行为惯例帮你自动处理了这些步骤。Builpacks的设计原则就是就是安装并设置所有需要的设置以帮你达到运行你的应用的目的。站在云原生Buildpacks的角度来说，我们希望利用Docker和现代container标准，有一个相似的系统来让我们的开发者更加注重于他们的应用，而不是拼凑一个build管道。 &nbsp; 运行云原生Buildpacks 因为希望能够将 Buildpacks&nbsp;的简洁性和可用性与container的优势结合起来，我们开发了云原生Buildpacks（CNB），它可以产出一个 “开放容器计划”兼容（OCI-Compliant）image, 并且这个image可以使用现存 的Docker 工具，以及更广阔的现存容器生态系统。 Buildpacks.io项目是一个让我们愿景成可能的开源工具之家。其中，第一个工具便是 pack build，其行为和git push heroku master非常相似。你可以在任意资源库下产生一个Docker image。以下便是一个在Rails应用上跑的Heroku云原生buildpack的例子。 &nbsp; 和buildpack产生可执行的压缩文件（slug）很相似， 一个CNB会根据你现有项目的文件识别什么东西需要被安装。你不需要进行任何配置来识别确认你的应用的需求。因为buildpack 是应用感知的（app-aware），它能够精准地捕捉到你所使用的编程语言以及你应用的所需依赖，在build阶段也同样会有着合理的系统默认值来处理内存的使用和处理并发。 &nbsp; CNB 进程在产生最后image的进行的步骤和现存Heroku Buildpacks运作的不同阶段非常相似： ·&nbsp;CLI 侦测到你的项目使用的主要语言。比如说，如果你的源代码目录下有一个Gemfile，那么CNB就会将它识别为一个Ruby项目；如果有个pom.xml那么它就会被识别为一个Java项目，以此类推。 ·&nbsp;之后，执行环境会分析之前的build来确认其中是否有任何步骤可以在接下来build中使用。 ·&nbsp;CNB开始跑build，下载所需的依赖以及将应用准备好可以在production当中运行。 ·&nbsp;最后，它会将以上build的结果以Docker image的形式导出。 &nbsp; 产出一个image的底层幕后进程全权被buildpack所打理。如果这个进程需要被更新-比如有个漏洞被检测到-你可以很轻松地获取一个新的工具链并且用 pack rebase重新build一个image来更新你的image而不用从头开始build一个image， 整个过程花费不到一秒钟。和用Dockerfile在你每一个应用上rebuild相比（一个可能耗费几个小时的过程），这会节省大量的时间。 &nbsp; 现在就来试一下云原生Buildpacks吧！ &nbsp; 再也没有比现在更好的时机来尝试一下云原生Buildpacks（CNB）了。这个项目刚刚出了它第一个beta 版本， 它已经准备好被你使用，也希望到你的反馈！ 如何开始呢？先下载 pack CLI&nbsp;并且在你的应用源代码目录下使用我们任一buildpack（Ruby,&nbsp;&nbsp;Node.js, Java, Python, PHP, Go）。 &nbsp; $ pack build --builder heroku/buildpacks &lt;docker image name&gt; 来Slack上加入我们！如果你还想生成你自己的OCI Images，我们还有定义了使用细则的buildpack API文档 。 Heroku 一直以来都认为切合开发者的关注和需求是非常重要的：即他们应用的源代码。我们相信云原生Buildpacks 会因为以建立了基于容器的应用而帮助减少在运行维护上的复杂度，从而解放了开发者双手来专注于给他们的用户创作更多优秀的的功能和特性。 &nbsp; 福利 扫描添加小编微信，备注“姓名+公司职位”，加入【云计算学习交流群】，和志同道合的朋友们共同打卡学习！ 推荐阅读： Elastic Jeff Yoshimura：开源正在开启新一轮的创新 | 人物志 深入浅出Docker 镜像 | 技术头条 19岁当老板, 20岁ICO失败, 21岁将项目挂到了eBay, 为何初创公司如此艰难? 码二代的出路是什么？ 机器学习萌新必备的三种优化算法 | 选型指南 小程序的侵权“生死局” @996 程序员，ICU 你真的去不起！ 真香，朕在看了！","@type":"BlogPosting","url":"https://mlh.app/2019/04/29/729013.html","headline":"使用云原生buildpacks将你的代码转换成Docker Image   技术头条","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/29/729013.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>使用云原生buildpacks将你的代码转换成Docker&nbsp;Image&nbsp;|&nbsp;技术头条</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <section class="xmteditor" style="display:none;" data-tools="新媒体管家" data-label="powered by xmt.cn"> 
 <br> 
</section> 
<p style="text-align: right;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">戳蓝字“</span><span style="color: rgb(0, 82, 255);font-size: 15px;">CSDN云</span><span style="font-size: 15px;color: rgb(0, 82, 255);">计算</span><span style="font-size: 15px;">”关注我们哦！</span></strong></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.66640625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28QpUDcJzjic8SUaLpwCia6YSYrSrNzRjlhb6ED1kUCkZl3L9GQNt30aeeosUDkrfiaE8ICxH9ziaNNgKQ/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28QpUDcJzjic8SUaLpwCia6YSYrSrNzRjlhb6ED1kUCkZl3L9GQNt30aeeosUDkrfiaE8ICxH9ziaNNgKQ/640?wx_fmt=jpeg"></p> 
<section powered-by="xiumi.us" style="white-space: normal;max-width: 100%;box-sizing: border-box;font-size: 15px;letter-spacing: 0.544px;line-height: 30px;widows: 1;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"> 
 <section style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"> 
  <section> 
   <section powered-by="xiumi.us" style="box-sizing: border-box;line-height: 30px;max-width: 100%;letter-spacing: 0.54px;word-wrap: break-word !important;"> 
    <section style="box-sizing: border-box;max-width: 100%;word-wrap: break-word !important;"> 
     <section> 
      <section powered-by="xiumi.us" style="box-sizing: border-box;line-height: 30px;max-width: 100%;letter-spacing: 0.54px;word-wrap: break-word !important;"> 
       <section style="box-sizing: border-box;max-width: 100%;word-wrap: break-word !important;"> 
        <section> 
         <blockquote> 
          <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;line-height: 1.75em;min-height: 1em;max-width: 100%;letter-spacing: 1px;text-indent: 0em;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="letter-spacing: 0.54px;color: rgb(0, 82, 255);"></span><strong style="color: rgb(0, 82, 255);font-size: 15px;letter-spacing: 0.54px;white-space: normal;widows: 1;background-color: rgb(255, 255, 255);"><strong style="max-width: 100%;color: rgba(0, 0, 0, 0.5);font-size: 15px;letter-spacing: 1px;white-space: normal;widows: 1;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;letter-spacing: 0.54px;color: rgb(0, 82, 255);box-sizing: border-box !important;word-wrap: break-word !important;">技术头条：干货、简洁、多维全面。更多云计算精华知识尽在眼前，get要点、solve难题，统统不在话下！</span></strong></strong></p> 
         </blockquote> 
        </section> 
       </section> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">当我们在大概七年前将buildpack技术开源的时候，我们就知道这项技术将大大简化应用的发布过程。当一个开发人员要跑一个：</span><span style="font-size: 15px;"><span style="font-size: 15px;font-family: 微软雅黑;">g</span>it push heroku mast<span style="font-size: 15px;font-family: 微软雅黑;">er的时候，一个buildpack就<span style="font-size: 15px;font-family: 微软雅黑;">可以保证所有的依赖以及编译工作都会作为发布的一部分被全权打理好。</span></span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><span style="font-size: 15px;font-family: 微软雅黑;">一</span>如之前所宣布，我们正在将buildpacks之所以如此成功的哲学理论运用到创立云原生buildpacks(CNB)，一种再也不需要dockerfile并将源代码转换为Docker Image的标准。在这篇文档里，我们会简单地看一下CNB 是如何工作的，它是如何旨在解决许多现存<span style="font-size: 15px;font-family: 微软雅黑;"><span style="font-size: 15px;font-family: 微软雅黑;">于</span>dockerfile上的问题， 以及你如何可以将它和最近发布的 buildpacks.io <span style="font-size: 15px;font-family: 微软雅黑;">项目</span> beta版本一起使用。作为这次发布的一部分，我们已经给 Ruby, Node.js, Java, Python, PHP, <span style="font-size: 15px;font-family: 微软雅黑;">以及</span>Go建立好了可以使用CNB&nbsp;<span style="font-size: 15px;font-family: 微软雅黑;">工具的</span>Heroku buildpacks builder image<span style="font-size: 15px;font-family: 微软雅黑;">。</span></span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">我们先从创造一个稻草人（假设模型）开始。我们会通过一些比较冗长无聊但却很根本且必须的步骤来创建一个Ruby on Rails 应用的Dockerfile。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="color: rgb(0, 82, 255);"><strong><span style="font-family: 微软雅黑;font-size: 15px;">抽象泄露：</span></strong><strong><span style="font-family: 微软雅黑;font-size: 15px;">递增地来写一个Dockerfile</span></strong></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">大多开发者以写一个dockerfile 来使用Docker，这个file会定义整个生成Docker image的build流程。比如说， 你手里有一个的Rails 项目，并且你希望将它以一个Docker Container来发布。你会需要从一个基本的Ruby Image 开始， 将其他额外需要的包加入进来，以此来让你的应用跑起来。如果你从未用过Docker，你可能要先学几样东西才能到这一步。</span><span style="font-family:微软雅黑;font-size:14px;"></span></p> 
<p><span style="font-family:微软雅黑;font-size:14px;"><br></span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">FROM ruby</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">RUN apt-get update -qq \</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">&nbsp;&nbsp;&amp;&amp; apt-get install -y nodejs libpq-dev build-essential</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">COPY . /app</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">WORKDIR /app</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">RUN bundle install</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">RUN bundle exec rake assets:precompile</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">EXPOSE 5000</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">CMD bin/rails s</span></p> 
<p><span style="font-family:微软雅黑;font-size:14px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;font-size:14px;"><span style="font-family:微软雅黑;">除了</span>Ruby以外，一个Rails应用的Docker&nbsp;image&nbsp;<span style="font-family:微软雅黑;">也将会需要几个额外的</span> Apt包。要想跑用来预编译assets的必须要的工具， node js &nbsp;<span style="font-family:微软雅黑;">的</span>runtime一定要被包含在其中；为了要和PostgreSQL <span style="font-family:微软雅黑;">交流，</span> libpq-dev<span style="font-family:微软雅黑;">也是需要的；以及为了让</span>gcc能够给Ruby&nbsp;gems&nbsp;<span style="font-family:微软雅黑;">们</span>build原生的插件（一个Ruby包管理器，类似Python的 pip），我们还会需要到build-essential<span style="font-family:微软雅黑;">。</span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;font-size:14px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;font-size:14px;"><span style="font-family:微软雅黑;">一个</span>Dockerfile&nbsp;<span style="font-family:微软雅黑;">已经足够用来在生产环境跑一个简单的</span>Rails应用，但是整个image会充满很多非相关的缓存文件夹。你或许会想去掉那些文件，以缩减整个image大小，但这只会对本地有序性build有用。</span></p> 
<p><span style="font-family:微软雅黑;font-size:14px;"><br></span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">RUN apt-get update -qq \</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">&nbsp;&nbsp;&amp;&amp; apt-get install -y nodejs libpq-dev build-essential \</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">&nbsp;&nbsp;&amp;&amp; apt-get clean autoclean &amp;&amp; apt-get autoremove -y \</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">&nbsp;&nbsp;&amp;&amp; rm -rf /var/lib/apt /var/lib/dpkg /var/lib/cache /var/lib/log</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;"># ..</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">RUN bundle exec rake assets:precompile</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">&nbsp;&nbsp;&amp;&amp; rm -rf /app/tmp/cache/assets/</span></p> 
<p><span style="font-family:微软雅黑;font-size:14px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">这便突出了使用Dockerfile在速度上的短板。它并不能适当利用那些缓存目录，只因为一次rebuild就会要把整个image从头build。然而，我们可以利用些聪明的小技巧来缓存依赖（dependency）的信息来加速builds。相比较每次复制整个应用，你可以如下选择性地加入文件。</span><span style="font-family:微软雅黑;font-size:14px;"></span></p> 
<p style="margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;font-size:14px;"><br></span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">ADD Gemfile /app/</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">ADD Gemfile.lock &nbsp;/app/</span></p> 
<p style="line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">RUN bundle install</span></p> 
<p><span style="font-family:微软雅黑;font-size:14px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">复制加入Gemfile 和Gemfile.lock 可以用来取代dockerfile的缓存机制，以此来防止因为仅你更改了一行代码而导致所有的缓存失效。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">这些例子仅强调出了“几个” 当使用Dockerfile构建应用时的挑战和难点。而且你会在每次使用Dockerfile构建应用时都会重复遇见这些困难。多数情况下，最后你都会复制粘贴某个应用Dockerfile 的一部分到另外一个应用的Dockerfile，而这种行为会潜在地造成维护人员噩梦。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">维护，是Dockerfile最大的短板。除了复制粘贴代码，它给你带来了一些如果你不使用Dockerfile是绝对不会关心的低等级问题。举例来说，和很多其他编程语言一样</span><span style="font-size: 15px;">，Ruby有很多基本image 可以给你用来继承使用，而且每个image都有自己的大小和安全性考量。如果有一天，Rails的生态系<span style="font-size: 15px;font-family: 微软雅黑;">统系要一个新的依赖（dependency），而这个新的依赖并不存在于你现有的Dockerfile，那你就要负责根据需要更新相关的设置。如果你把你的项目分拆成多个“微服务”（microservices<span style="font-size: 15px;font-family: 微软雅黑;">），同时也意味着你需要在多个位置更新你的文件。</span></span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">最终来说，Dockerfile是个具有漏洞性的抽象概念。它强制开发者们要小心运作上，以及平台的需要注意点，而在这之前这些需要注意点都已经被平台抽象打理了。要想写出一个好的Dockerfile，你就必须理解底层机制，以及产生image的每一步是如何工作的并以此来打理未来的更新。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">所有的这些问题都源于Dockerfile缺少对应用的相对了解。如果没有你的应用相关或所使用架构的上下文相关信息，开发者如何开发和他们使用的工具就会产生巨大的不匹配现象。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">像这样将运行和应用的关注点混合在一起就相当于给了一个希望尽量容易去写代码以及运输代码的开发者一个非常差的工具。基于此类不足之处，我们接下来看一下另外一种可以减少此类复杂度的替代办法。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;color: rgb(0, 82, 255);"><strong><span style="font-size: 15px;font-family: 微软雅黑;"><span style="font-size: 15px;font-family: 微软雅黑;">向</span>Buildpacks学习</span></strong><strong><span style="font-size: 15px;font-family: 微软雅黑;"></span></strong></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><strong><span style="font-size: 15px;font-family: 微软雅黑;"><br></span></strong></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><span style="font-size: 15px;font-family: 微软雅黑;"><span style="font-size: 15px;font-family: 微软雅黑;">如果你曾经使用</span>H</span>eroku来发布你的应用你就会知道，这就像在本地跑一个 git push heroku master 一样容易。而在幕后，一个 buildpack 就会收集依赖（retrieve dependencies），运行数据信息，打理缓存，并且给你的应用语言编译代码。举例来说，有一个Rails 应用。Ruby的buildpack就会安装Ruby和 bundler（一个Ruby的依赖管理应用）。你的gem（一系列包和文件的总称）依赖<span style="font-size: 15px;font-family: 微软雅黑;">会被提取出来，你的资源代码会被编译，而且缓存也会被清理干净：</span></span><span style="font-size: 14px;font-family: 微软雅黑;"></span></p> 
<p><span style="font-size: 14px;font-family: 微软雅黑;"><br></span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(255,255,255);font-size:14px;color:rgb(255,255,255);">git push heroku master</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: Compressing source files... done.</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: Building source:</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: -----&gt; Ruby app detected</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: -----&gt; Compiling Ruby/Rails</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: -----&gt; Using Ruby version: ruby-2.6.0</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: -----&gt; Installing dependencies using bundler 1.15.2</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">...</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundle complete! 18 Gemfile dependencies, 61 gems now installed.</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gems in the groups development and test were not installed.</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundled gems are installed into `./vendor/bundle`</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removing bundler (1.15.2)</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundle completed (42.62s)</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleaning up the bundler cache.</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">...</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asset precompilation completed (3.72s)</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleaning assets</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running: rake assets:clean</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: -----&gt; Detecting rails configuration</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: -----&gt; Compressing...</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Done: 41.3M</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: -----&gt; Launching...</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Released v6</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://myapp.herokuapp.com/ deployed to Heroku</span></p> 
<p style="background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote:</span></p> 
<p style="line-height: 18px;background: rgb(42, 42, 42);margin-left: 8px;margin-right: 8px;"><span style="font-family:微软雅黑;color:rgb(190,190,197);font-size:14px;color:rgb(255,255,255);">remote: Verifying deploy... done.</span></p> 
<p><span style="font-family:微软雅黑;font-size:14px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">一个Buildpack以识别你应用代码语言的行为惯例帮你自动处理了这些步骤。Builpacks的设计原则就是就是安装并设置所有需要的设置以帮你达到运行你的应用的目的。站在云原生Buildpacks的角度来说，我们希望利用Docker和现代container标准，有一个相似的系统来让我们的开发者更加注重于他们的应用，而不是拼凑一个build管道。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;color: rgb(0, 82, 255);"><strong><span style="font-size: 15px;font-family: 微软雅黑;"><span style="font-size: 15px;font-family: 微软雅黑;">运行云原生</span>Buildpacks</span></strong><strong><span style="font-size: 15px;font-family: 微软雅黑;"></span></strong></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><strong><span style="font-size: 15px;font-family: 微软雅黑;"><br></span></strong></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><span style="font-size: 15px;font-family: 微软雅黑;"><span style="font-size: 15px;font-family: 微软雅黑;">因为希望能够将</span> Buildpacks&nbsp;<span style="font-size: 15px;font-family: 微软雅黑;">的简洁性和可用性与</span>contai</span>ner的优势结合起来，我们开发了云原生Buildpacks（CNB），它可以产出一个 “开放容器计划”兼容（OCI-Compliant）image, 并且这个image可以使用现存 的Docker 工具，以及更广阔的现存容器生态系统。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Buildpacks.io项目是一个让我们愿景成可能的开源工具之家。其中，第一个工具便是 pack build，其行为和git push heroku master非常相似。你可以在任意资源<span style="font-size: 15px;font-family: 微软雅黑;"><span style="font-size: 15px;font-family: 微软雅黑;">库下产生一个</span>Docker image。以下便是一个在Rails应用上跑的Heroku云原生buildpack的例子。</span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">和buildpack产生可执行的压缩文件（slug）很相似， 一个CNB会根据你现有项目的文件识别什么东西需要被安装。你不需要进行任何配置来识别确认你的应用的需求。因为buildpack 是应用感知的（app-aware），它能够精准地捕捉到你所使用的编程语言以及你应用的所需依赖，在build阶段也同样会有着合理的系统默认值来处理内存的使用和处理并发。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">CNB 进程在产生最后image的进行的步骤和现存Heroku Buildpacks运作的不同阶段非常相似：</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><span style="font-size: 15px;font-family: Symbol;">·&nbsp;</span><span style="font-size: 15px;font-family: 微软雅黑;">CLI <span style="font-size: 15px;font-family: 微软雅黑;">侦测到你的项目使用的主要语言。比如说，如果你的源代码目录下有一个</span>Gemfile，那么CNB就会将它识别为一个Ruby项目；如果有个pom.xml<span style="font-size: 15px;font-family: 微软雅黑;">那么它就会被识别为一个</span>Java项目，以此类推。</span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><span style="font-size: 15px;font-family: 微软雅黑;"><br></span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><span style="font-size: 15px;font-family: Symbol;">·&nbsp;</span><span style="font-size: 15px;font-family: 微软雅黑;"><span style="font-size: 15px;font-family: 微软雅黑;">之后，执行环境会分析之前的</span>build来确认其中是否有任何步骤可以在接下来build中使用。</span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><span style="font-size: 15px;font-family: 微软雅黑;"><br></span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><span style="font-size: 15px;font-family: Symbol;">·&nbsp;</span><span style="font-size: 15px;font-family: 微软雅黑;">CNB开始跑build，下载所需的依赖以及将应用准备好可以在production当中运行。</span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><span style="font-size: 15px;font-family: 微软雅黑;"><br></span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><span style="font-size: 15px;font-family: Symbol;">·&nbsp;</span><span style="font-size: 15px;font-family: 微软雅黑;"><span style="font-size: 15px;font-family: 微软雅黑;">最后，它会将以上</span>build的结果以Docker image的形式导出。</span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">产出一个image的底层幕后进程全权被buildpack所打理。如果这个进程需要被更新-比如有个漏洞被检测到-你可以很轻松地获取一个新的工具链并且用 pack rebase重新build一个image来更新你的image而不用从头开始build一个image， 整个过程花费不到一秒钟。和用Dockerfile在你每一个应用上rebuild相比（一个可能耗费几个小时的过程），这会节省大量的时间。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">&nbsp;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;color: rgb(0, 82, 255);"><strong><span style="font-size: 15px;font-family: 微软雅黑;"><span style="font-size: 15px;font-family: 微软雅黑;">现在就来试一下云原生</span>Buildpacks吧！</span></strong><strong><span style="font-size: 15px;font-family: 微软雅黑;"></span></strong></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;"><strong><span style="font-size: 15px;font-family: 微软雅黑;">&nbsp;</span></strong></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">再也没有比现在更好的时机来尝试一下云原生Buildpacks（CNB）了。这个项目刚刚出了它第一个beta 版本， 它已经准备好被你使用，也希望到你的反馈！</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">如何开始呢？先下</span><span style="font-size: 15px;">载 pack CLI&nbsp;并且在<span style="font-size: 15px;font-family: 微软雅黑;"><span style="font-size: 15px;font-family: 微软雅黑;">你的应用源代码目录下使用我们任一</span>buildpack（Ruby,&nbsp;&nbsp;Node.js, Java, Python, PHP, Go<span style="font-size: 15px;font-family: 微软雅黑;">）。</span></span></span><span style="font-size: 14px;font-family: 微软雅黑;"></span></p> 
<p><span style="font-family:微软雅黑;font-size:14px;">&nbsp;</span></p> 
<p style="margin-bottom: 30px;line-height: 18px;background: rgb(238, 241, 246);margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;color: rgb(56, 62, 64);font-size: 14px;">$ pack build --builder heroku/buildpacks &lt;docker image name&gt;</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">来Slack上加入我们！如果你还想生成你自己的OCI Images，我们还有定义了使用细则的buildpack API文档 。<span style="font-size: 15px;font-family: 微软雅黑;"></span></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;"><span style="font-family: 微软雅黑;font-size: 15px;">Heroku 一直以来都认为切合开发者的关注和需求是非常重要的：即他们应用的源代码。我们相信云原生Buildpacks 会因为以建立了基于容器的应用而帮助减少在运行维护上的复杂度，从而解放了开发者双手来专注于给他们的用户创作更多优秀的的功能和特性。</span></p> 
<p style="text-indent:32px;text-align:center;"><span style="font-family:微软雅黑;color:rgb(0,0,0);font-size:16px;">&nbsp;</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="" data-copyright="0" data-ratio="0.04523809523809524" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/1hReHaqafafJYoFH7OAhmUdTjo35vvJTy1lRVjG2CzFP3arfVRDqI7a8PSS6Sx5LialaFTE1HFu2N4OIhL8jP9g/640?wx_fmt=png" data-type="png" data-w="420" style="letter-spacing: 0.544px;line-height: 29.75px;box-sizing: border-box !important;word-wrap: break-word !important;width: 420px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/1hReHaqafafJYoFH7OAhmUdTjo35vvJTy1lRVjG2CzFP3arfVRDqI7a8PSS6Sx5LialaFTE1HFu2N4OIhL8jP9g/640?wx_fmt=png"><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><br></p> 
<p style="margin-right: 8px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 0.544px;widows: 1;line-height: 1.4;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><span style="padding: 0.2em 0.5em;max-width: 100%;border-radius: 0.3em;color: white;font-size: 1em;font-family: inherit;font-weight: inherit;text-align: inherit;text-decoration: inherit;background-color: rgb(255, 105, 31);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;">福利</span></strong></p> 
<section class="" style="margin-top: -0.7em;font-size: 1em;white-space: normal;max-width: 100%;letter-spacing: 0.544px;line-height: 27.2px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(255, 105, 31);border-radius: 0.4em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
 <section style="padding: 1.4em 1em 1em;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
  <section style="max-width: 100%;font-size: 1em;font-family: inherit;text-align: inherit;text-decoration: inherit;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"> 
   <p style="margin-right: 8px;margin-left: 8px;max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">扫描添加小编微信，备注“</span></strong><span style="max-width: 100%;color: rgb(255, 104, 39);box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">姓名+公司职位</span></strong></span><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">”，加入【</span></strong><span style="max-width: 100%;color: rgb(255, 104, 39);box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">云计算学习交流群</span></strong></span><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">】，和志同道合的朋友们共同打卡学习！</span></strong></p> 
   <p style="margin-right: 8px;margin-left: 8px;max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
   <p style="text-align: center;"><img class="rich_pages" data-copyright="0" data-ratio="1.005813953488372" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28QDZW3ZeMemRs5PPyI20qxP8zicUCD67ia0kT4tk9BTQ6OaiaGTrvMQzl6sfmlRmFhKBcuibvRsxg3ktA/640?wx_fmt=jpeg" data-type="jpeg" data-w="516" style="height: 156px;width: 155px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/zxoLaeCI28QDZW3ZeMemRs5PPyI20qxP8zicUCD67ia0kT4tk9BTQ6OaiaGTrvMQzl6sfmlRmFhKBcuibvRsxg3ktA/640?wx_fmt=jpeg"></p> 
  </section> 
 </section> 
</section> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><br></p> 
<p style="margin-right: 8px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;font-size: 15px;letter-spacing: 0.544px;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;text-indent: 28px;font-family: arial, 宋体, sans-serif;letter-spacing: 1px;overflow-wrap: break-word;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;letter-spacing: 0.5px;overflow-wrap: break-word;box-sizing: border-box !important;word-wrap: break-word !important;">推荐阅读：</span></strong></p> 
<ul class=" list-paddingleft-2" style="margin-left: 8px;margin-right: 8px;"> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MzA3MjY1MTQwNQ==&amp;mid=2649827390&amp;idx=1&amp;sn=b46af38886f0f18a8f9e612e1b4568ba&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">Elastic Jeff Yoshimura：开源正在开启新一轮的创新 | 人物志</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MzA3MjY1MTQwNQ==&amp;mid=2649827337&amp;idx=1&amp;sn=5c580f242966f000500251077ebaf9e4&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">深入浅出Docker 镜像 | 技术头条</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247494653&amp;idx=1&amp;sn=f8a0e8961bf7bc2a219bb4d2d65f88fd&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">19岁当老板, 20岁ICO失败, 21岁将项目挂到了eBay, 为何初创公司如此艰难?</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MDA4NDkxMQ==&amp;mid=2247483894&amp;idx=1&amp;sn=65c6f6d62f2f3b8ef44dd01de9c72867&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">码二代的出路是什么？</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&amp;mid=2247504645&amp;idx=4&amp;sn=bd7644e3897019715ad78214ffe95c29&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">机器学习萌新必备的三种优化算法 | 选型指南</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&amp;mid=2651010496&amp;idx=3&amp;sn=1a45d882bbd6b067c939f43cfd34d6d4&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">小程序的侵权“生死局”</span></a></h2></li> 
 <li><h2 style="max-width: 100%;letter-spacing: 0.54px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650718955&amp;idx=1&amp;sn=7dc3b3f93c529ae4ffbace0b5e40f3e2&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 15px;text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">@996 程序员，ICU 你真的去不起！</span></a><br></h2></li> 
</ul> 
<section data-role="outer" label="Powered by 135editor.com" style="white-space: normal;max-width: 100%;font-size: 15px;letter-spacing: 0.544px;line-height: 27.2px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
 <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
  <section class="" data-tools="135编辑器" data-id="94174" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
   <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
    <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;letter-spacing: 0.544px;line-height: 27.2px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
     <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
      <section class="" data-tools="135编辑器" data-id="94174" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
       <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
        <section style="max-width: 100%;text-align: right;box-sizing: border-box !important;word-wrap: break-word !important;"> 
         <br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
        </section> 
        <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;letter-spacing: 0.544px;line-height: 27.2px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
         <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
          <section class="" data-tools="135编辑器" data-id="94174" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
           <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
            <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;letter-spacing: 0.544px;line-height: 27.2px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
             <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
              <section class="" data-tools="135编辑器" data-id="94174" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
               <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                <section style="max-width: 100%;text-align: right;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                 <section style="margin-top: -6.4px;margin-left: -16px;max-width: 197px;font-family: 微软雅黑;font-size: 16px;letter-spacing: 0.544px;line-height: 25.6px;float: right;transform: matrix(1, 0, 0, 1, 0, 0);width: 16px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                  <img class="" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAujO0pvtNCLzZCiaWxGBfq2xaPwze1NRLTSQZYbzWNnTJwDwsReHiam91Wojzvw3RLibjicWkLWJjicgsvw/640?wx_fmt=png" data-type="png" data-w="23" data-width="100%" style="max-width: 16px;display: block;box-sizing: border-box !important;word-wrap: break-word !important;visibility: visible !important;width: 15.99px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAujO0pvtNCLzZCiaWxGBfq2xaPwze1NRLTSQZYbzWNnTJwDwsReHiam91Wojzvw3RLibjicWkLWJjicgsvw/640?wx_fmt=png"> 
                 </section> 
                 <section data-brushtype="text" style="padding: 10px 16px;max-width: 197px;font-family: 微软雅黑;font-size: 16px;line-height: 25.6px;border-radius: 10px;color: rgb(73, 73, 72);display: inline-block;font-weight: 700;letter-spacing: 1.5px;text-align: center;background: none 0% 0% / auto repeat scroll padding-box border-box rgb(253, 245, 13);box-sizing: border-box !important;word-wrap: break-word !important;"> 
                  <span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">真香，朕在看了！</span> 
                 </section> 
                </section> 
               </section> 
              </section> 
             </section> 
            </section> 
           </section> 
          </section> 
         </section> 
        </section> 
       </section> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
