<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Kubernetes 如何打赢容器之战？ | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Kubernetes 如何打赢容器之战？" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="阿里妹导读：Kubernetes 近几年很热门，在各大技术论坛上被炒的很火。它提供了强大的容器编排能力，与此同时 DevOps 的概念也来到大家身边，广大的开发同学也能简单地运维复杂的商业化分布式系统，打破了传统开发和运维之间的界限。 本文会以初学者的视角，希望能让读者更好地理解 Kubernetes 出现的背景、超前的设计理念和优秀的技术架构。 背景 PaaS PaaS 技术，一句话概括就是：它提供了“应用托管”的能力。 早期的主流做法基本上是租 AWS 或者 OpenStack 的虚拟机，然后把这些虚拟机当作物理机一样，用脚本或者手工的方式在上面部署应用。这个过程中如何保证本地环境和云端环境的一致性是一个很大的课题，而提供云计算服务的公司的核心竞争力就是比拼谁做的更好。从某种意义上来说 PaaS 的出现，算是一个比较好的解决方案。 以 Cloud Foundry 为例，在虚拟机上部署上 Cloud Foundry 项目后，用户可以很方便地把自己的应用上云。以上帝视角来看这个过程：Cloud Foundry 最核心的是提供了一套应用的打包和分发机制，它为不同的编程语言定义了不同的打包格式，它能把可执行文件、启动参数等等一起打包成压缩包然后上传至 Cloud Foundry 存储中心，最后由调度器选择虚拟机，由虚拟机上的 Agent 下载并启动应用。 分布式系统 随着软件的规模越来越大，业务模式越来越复杂，用户量的上升、地区的分布、系统性能的苛刻要求都促成服务架构从最初的单体变成 SOA 再到如今的微服务，未来还可能演变为 Service Mesh ，Serverless 等等。 如今，一个完整的后端系统不再是单体应用架构了，多年前的 DDD 概念重新回到大家的视线中。现在的系统被不同的职责和功能拆成多个服务，服务之间复杂的关系以及单机的单点性能瓶颈让部署和运维变得很复杂，所以部署和运维大型分布式系统的需求急迫待解决。 容器技术 前面提到诸如 Cloud Foundry 的 PaaS，用户必须为不同语言、不同框架区分不同的打包方式，这个打包过程是非常具有灾难性的。而现实往往更糟糕，当在本地跑的好好的应用，由于和远端环境的不一致，在打包后却需要在云端各种调试，最终才能让应用“平稳”运行。 而 Docker 的出现改变了一切，它凭借镜像解决了这个问题。Docker 一不做二不休，干脆把完整的操作系统目录也打包进去，如此高的集成度，保证了云端和本地环境的高度一致，并且随时随地轻易地移植。 谁也不知道就因为“镜像”这个简单的功能，Docker 完成了对 PaaS 的降维打击，占有了市场。此时，一些聪明的技术公司纷纷跟进 Docker，推出了自家的容器集群管理项目，并且称之为 CaaS。 容器技术利用 Namespace 实现隔离，利用 Cgroups 实现限制；在 Docker 实现上，通过镜像，为容器提供完整的系统执行环境，并且通过 UnionFS 实现 Layer 的设计。 Docker 容器是完全使用沙箱机制，相互之间不会有任何接口。通过 Docker，实现进程、网络、挂载点和文件隔离，更好地利用宿主机资源。Docker 强大到不需要关心宿主机的依赖，所有的一切都可以在镜像构建时完成，这也是 Docker 目前成为容器技术标准的原因。所以我们能看到在 Kubernetes 中默认使用 Docker 作为容器（也支持 rkt）。 Kubernetes 铺垫了这么多，终于说到本文的主角了。说 Kubernetes 之前，不得不提 Compose、Swarm、Machine 三剑客，其实在 Kubernetes 还未一统江湖之前，它们已经能实现大部分容器编排的能力了。但是在真正的大型系统上，它们却远远不如 Mesosphere 公司出品的大型集群管理系统，更别说之后的 Kubernetes 了。 在容器化和微服务时代，服务越来越多，容器个数也越来越多。Docker 如它 Logo 所示一样，一只只鲸鱼在大海里自由地游荡，而 Kubernetes 就像一个掌舵的船长，带着它们，有序的管理它们，这个过程其实就是容器编排。 Kubernetes 起源于 Google，很多设计都是源自于 Borg，是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效，并且提供了应用部署，规划，更新，维护的一种机制。 小结 至此，读者了解了 Kubernetes 的前世今生，由 PaaS 的火热，引爆了容器技术的战争，而赢得这场战争中最关键的即是拥有强大的容器编排的能力，而 Kubernetes 无疑是这场战争的胜利者。 设计理念 这一部分，我们会围绕 Kubernetes 的四个设计理念看看这些做法能给我们带来什么。 声明式 VS 命令式&nbsp; 声明式和命令式是截然不同的两种编程方式，在命令式 API 中，我们可以直接发出服务器要执行的命令，例如： “运行容器”、“停止容器”等；在声明式 API 中，我们声明系统要执行的操作，系统将不断向该状态驱动。 我们常用的 SQL 就是一种声明式语言，告诉数据库想要的结果集，数据库会帮我们设计获取这个结果集的执行路径，并返回结果集。众所周知，使用 SQL 语言获取数据，要比自行编写处理过程去获取数据容易的多。 apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: etcd-operatorspec: replicas: 1 template: metadata: labels: name: etcd-operator spec: containers: - name: etcd-operator image: quay.io/coreos/etcd-operator:v0.2.1 env: - name: MY_POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: MY_POD_NAME valueFrom: fieldRef: fieldPath: metadata.name 我们来看看相同设计的 YAML，利用它，我们可以告诉 Kubernetes 最终想要的是什么，然后 Kubernetes 会完成目标。 声明式 API 使系统更加健壮，在分布式系统中，任何组件都可能随时出现故障。当组件恢复时，需要弄清楚要做什么，使用命令式 API 时，处理起来就很棘手。但是使用声明式 API ，组件只需查看 API 服务器的当前状态，即可确定它需要执行的操作。 显式的 API Kubernetes 是透明的，它没有隐藏的内部 API。换句话说 Kubernetes 系统内部用来交互的 API 和我们用来与 Kubernetes 交互的 API 相同。 这样做的好处是，当 Kubernetes 默认的组件无法满足我们的需求时，我们可以利用已有的 API 实现我们自定义的特性。 无侵入性 感谢 Docker 容器技术的流行，使得 Kubernetes 为大家提供了无缝的使用方式。在容器化的时代，我们的应用达到镜像后，不需要改动就可以遨游在 Kubernetes 集群中。 Kubernetes 还提供存储 Secret、Configuration 等包含但不局限于密码、证书、容器镜像信息、应用启动参数能力。如此，Kubernetes 以一种友好的方式将这些东西注入 Pod，减少了大家的工作量，而无需重写或者很大幅度改变原有的应用代码。 有状态的移植 在有状态的存储场景下，Kubernetes 如何做到对于服务和存储的分离呢？假设一个大型分布式系统使用了多家云厂商的存储方案，如何做到开发者无感于底层的存储技术体系，并且做到方便的移植？ 为了实现这一目标，Kubernetes 引入了 PersistentVolumeClaim（PVC）和 PersistentVolume（PV）API 对象。这些对象将存储实现与存储使用分离。 PersistentVolumeClaim 对象用作用户以与实现无关的方式请求存储的方法，通过它来抹除对底层 PersistentVolume 的差异性。这样就使 Kubernetes 拥有了跨集群的移植能力。 架构 首先要提及的是 Kubernetes 使用很具代表性的 C/S 架构方式，Client 可以使用 kubectl 命令行或者 RESTful 接口与 Kubernetes 集群进行交互。下面这张图是从宏观上看 Kubernetes 的整体架构，每一个 Kubernetes 集群都由 Master 节点 和 很多的 Node 节点组成。 Master Master 是 Kubernetes 集群的管理节点，负责管理集群，提供集群的资源数据访问入口。拥有 Etcd 存储服务，运行 API Server 进程，Controller Manager 服务进程及 Scheduler 服务进程，关联工作节点 Node。 Kubernetes API Server 提供 HTTP Rest 接口的关键服务进程，是 Kubernetes 里所有资源的增、删、改、查等操作的唯一入口。也是集群控制的入口进程；&nbsp;Kubernetes Controller Manager 是 Kubernetes 所有资源对象的自动化控制中心，它驱使集群向着我们所需要的最终目的状态； Kubernetes Schedule 是负责 Pod 调度的进程。 Node Node 是 Kubernetes 集群架构中运行 Pod 的服务节点。Node 是 Kubernetes 集群操作的单元，用来承载被分配 Pod 的运行，是 Pod 运行的宿主机。关联 Master 管理节点，拥有名称和 IP、系统资源信息。运行 Docker Runtime、kubelet 和 kube-proxy。 kubelet 负责对 Pod 对于的容器的创建、启停等任务，发送宿主机当前状态； kube-proxy 实现 Kubernetes Service 的通信与负载均衡机制的重要组件； Docker Runtime 负责本机容器的创建和管理工作。 实现原理 为了尽可能地让读者能明白 Kubernetes 是如何运作的，这里不会涉及到具体的细节实现，如有读者感兴趣可以自行参阅官网文档。这里以一个简单的应用部署示例来阐述一些概念和原理。 创建 Kubernetes 集群 介绍架构的时候我们知道，Kubernetes 集群由 Master 和 Node 组成。 Master 管理集群的所有行为例如：应用调度、改变应用的状态，扩缩容，更新/降级应用等。 Node 可以是是一个虚拟机或者物理机，它是应用的“逻辑主机”，每一个 Node 拥有一个 Kubelet，Kubelet 负责管理 Node 节点与 Master 节点的交互，同时 Node 还需要有容器操作的能力，比如 Docker 或者 rkt。理论上来说，一个 Kubernetes 为了应对生产环境的流量，最少部署3个 Node 节点。 当我们需要在 Kubernetes 上部署应用时，我们告诉 Master 节点，Master 会调度容器跑在合适的 Node 节点上。 我们可以使用 Minikube 在本地搭一个单 Node 的 Kubernetes 集群。 部署应用 当创建好一个 Kubernetes 集群后，就可以把容器化的应用跑在上面了。我们需要创建一个 Deployment，它会告诉 Kubernetes Master 如何去创建应用，也可以来更新应用。 当应用实例创建后，Deployment 会不断地观察这些实例，如果 Node 上的 Pod 挂了，Deployment 会自动创建新的实例并且替换它。相比传统脚本运维的方式，这种方式更加优雅。 我们能通过 kubectl 命令或者 YAML 文件来创建 Deployment，在创建的时候需要指定应用镜像和要跑的实例个数，之后 Kubernetes 会自动帮我们处理。 查看 Pods 和 Nodes 下面来介绍下 Pod 和 Node：&nbsp; 当我们创建好 Deployment 的时候，Kubernetes 会自动创建 Pod 来承载应用实例。Pod 是一个抽象的概念，像一个“逻辑主机”，它代表一组应用容器的集合，这些应用容器共享资源，包括存储，网络和相同的内部集群 IP。 &nbsp; 任何一个 Pod 都需要跑在一个 Node 节点上。Node 是一个“虚拟机器”，它可以是虚拟机也可以是物理机，一个 Node 可以有多个 Pods，Kubernetes 会自动调度 Pod 到合适的 Node 上。 Service 与 LabelSelector Pods 终有一死，也就是说 Pods 也有自己的生命周期，当一个 Pod 挂了的时候，ReplicaSet 会创建新的，并且调度到合适的 Node 节点上。考虑下访问的问题，Pod 替换伴随着 IP 的变化，对于访问者来说，变化的 IP 是合理的；并且当有多个 Pod 节点时，如何 SLB 访问也是个问题，Service 就是为了解决这些问题的。 Service 是一个抽象的概念，它定义了一组逻辑 Pods，并且提供访问它们的策略。和其他对象一样，Service 也能通过 kubectl 或者 YAML 创建。Service 定义的 Pod 可以写在 LabelSelector 选项中（下文会介绍），也存在不指定 Pods 的情况，这种比较复杂，感兴趣的读者可以自行查阅资料。 Service 有以下几种类型： ClusterIP（默认）：在集群中内部IP上暴露服务，此类型使Service只能从群集中访问； NodePort：通过每个 Node 上的 IP 和静态端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求&nbsp;: ，可以从集群的外部访问一个 NodePort 服务； LoadBalancer：使用云提供商的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务； ExternalName：通过返回 CNAME 和它的值，（适用于外部 DNS 的场景） &nbsp; Labels 和 Selectors 能够让 Kubernetes 拥有逻辑运算的能力，有点像 SQL。举个例子：可以查找 app=hello_word 的所有对象，也可以查找 app in (a,b,c) abc的所有对象。 Labels是一个绑定在对象上的 K/V 结构，它可以在创建或者之后的时候的定义，在任何时候都可以改变。 扩容应用 前文提到我们可以使用 Deployment 增加实例个数，下图是原始的集群状态：&nbsp; 我们可以随意的更改 replicas （实例个数）来扩容，当我们更改了 Deployment 中的 replicas 值时，Kubernetes 会自动帮我们达到想要的目标实例个数，如下图：&nbsp; 更新应用 更新应用和扩容类似，我们可以更改 Deployment 中的容器镜像，然后 Kubernetes 会帮住我们应用更新（蓝绿、金丝雀等方式），通过此功能，我们还可以实现切换应用环境、回滚、不停机 CI/CD。下面是部署的过程，需要注意的是我们可以指定新创建的 Pod 最大个数和不可用 Pod 最大个数： &nbsp; 总结 到了最后，大家对 Kubernetes 有个大概的了解了，但 Kubernetes 远远不止本文所介绍的这些内容。在云原生概念逐渐清晰的今天，Kubernetes 作为 CNCF 中一个接地气的落地项目，其重要性不言而喻。 最后，阿里云智能事业群，招聘2020年毕业的实习生和社招技术同学。团队主要聚焦在 Kubernetes、集群管理、自动化和云原生相关技术方向，负责阿里集团的监控和运维。有意者可以发简历到 jianmin.hjm@alibaba-inc.com。 你可能还喜欢 点击下方图片即可阅读 阿里开源 OpenJDK 长期支持版本 Alibaba Dragonwell 为拯救爸妈朋友圈，达摩院造了“谣言粉碎机” 阿里巴巴2019实习生招聘正式启动！" />
<meta property="og:description" content="阿里妹导读：Kubernetes 近几年很热门，在各大技术论坛上被炒的很火。它提供了强大的容器编排能力，与此同时 DevOps 的概念也来到大家身边，广大的开发同学也能简单地运维复杂的商业化分布式系统，打破了传统开发和运维之间的界限。 本文会以初学者的视角，希望能让读者更好地理解 Kubernetes 出现的背景、超前的设计理念和优秀的技术架构。 背景 PaaS PaaS 技术，一句话概括就是：它提供了“应用托管”的能力。 早期的主流做法基本上是租 AWS 或者 OpenStack 的虚拟机，然后把这些虚拟机当作物理机一样，用脚本或者手工的方式在上面部署应用。这个过程中如何保证本地环境和云端环境的一致性是一个很大的课题，而提供云计算服务的公司的核心竞争力就是比拼谁做的更好。从某种意义上来说 PaaS 的出现，算是一个比较好的解决方案。 以 Cloud Foundry 为例，在虚拟机上部署上 Cloud Foundry 项目后，用户可以很方便地把自己的应用上云。以上帝视角来看这个过程：Cloud Foundry 最核心的是提供了一套应用的打包和分发机制，它为不同的编程语言定义了不同的打包格式，它能把可执行文件、启动参数等等一起打包成压缩包然后上传至 Cloud Foundry 存储中心，最后由调度器选择虚拟机，由虚拟机上的 Agent 下载并启动应用。 分布式系统 随着软件的规模越来越大，业务模式越来越复杂，用户量的上升、地区的分布、系统性能的苛刻要求都促成服务架构从最初的单体变成 SOA 再到如今的微服务，未来还可能演变为 Service Mesh ，Serverless 等等。 如今，一个完整的后端系统不再是单体应用架构了，多年前的 DDD 概念重新回到大家的视线中。现在的系统被不同的职责和功能拆成多个服务，服务之间复杂的关系以及单机的单点性能瓶颈让部署和运维变得很复杂，所以部署和运维大型分布式系统的需求急迫待解决。 容器技术 前面提到诸如 Cloud Foundry 的 PaaS，用户必须为不同语言、不同框架区分不同的打包方式，这个打包过程是非常具有灾难性的。而现实往往更糟糕，当在本地跑的好好的应用，由于和远端环境的不一致，在打包后却需要在云端各种调试，最终才能让应用“平稳”运行。 而 Docker 的出现改变了一切，它凭借镜像解决了这个问题。Docker 一不做二不休，干脆把完整的操作系统目录也打包进去，如此高的集成度，保证了云端和本地环境的高度一致，并且随时随地轻易地移植。 谁也不知道就因为“镜像”这个简单的功能，Docker 完成了对 PaaS 的降维打击，占有了市场。此时，一些聪明的技术公司纷纷跟进 Docker，推出了自家的容器集群管理项目，并且称之为 CaaS。 容器技术利用 Namespace 实现隔离，利用 Cgroups 实现限制；在 Docker 实现上，通过镜像，为容器提供完整的系统执行环境，并且通过 UnionFS 实现 Layer 的设计。 Docker 容器是完全使用沙箱机制，相互之间不会有任何接口。通过 Docker，实现进程、网络、挂载点和文件隔离，更好地利用宿主机资源。Docker 强大到不需要关心宿主机的依赖，所有的一切都可以在镜像构建时完成，这也是 Docker 目前成为容器技术标准的原因。所以我们能看到在 Kubernetes 中默认使用 Docker 作为容器（也支持 rkt）。 Kubernetes 铺垫了这么多，终于说到本文的主角了。说 Kubernetes 之前，不得不提 Compose、Swarm、Machine 三剑客，其实在 Kubernetes 还未一统江湖之前，它们已经能实现大部分容器编排的能力了。但是在真正的大型系统上，它们却远远不如 Mesosphere 公司出品的大型集群管理系统，更别说之后的 Kubernetes 了。 在容器化和微服务时代，服务越来越多，容器个数也越来越多。Docker 如它 Logo 所示一样，一只只鲸鱼在大海里自由地游荡，而 Kubernetes 就像一个掌舵的船长，带着它们，有序的管理它们，这个过程其实就是容器编排。 Kubernetes 起源于 Google，很多设计都是源自于 Borg，是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效，并且提供了应用部署，规划，更新，维护的一种机制。 小结 至此，读者了解了 Kubernetes 的前世今生，由 PaaS 的火热，引爆了容器技术的战争，而赢得这场战争中最关键的即是拥有强大的容器编排的能力，而 Kubernetes 无疑是这场战争的胜利者。 设计理念 这一部分，我们会围绕 Kubernetes 的四个设计理念看看这些做法能给我们带来什么。 声明式 VS 命令式&nbsp; 声明式和命令式是截然不同的两种编程方式，在命令式 API 中，我们可以直接发出服务器要执行的命令，例如： “运行容器”、“停止容器”等；在声明式 API 中，我们声明系统要执行的操作，系统将不断向该状态驱动。 我们常用的 SQL 就是一种声明式语言，告诉数据库想要的结果集，数据库会帮我们设计获取这个结果集的执行路径，并返回结果集。众所周知，使用 SQL 语言获取数据，要比自行编写处理过程去获取数据容易的多。 apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: etcd-operatorspec: replicas: 1 template: metadata: labels: name: etcd-operator spec: containers: - name: etcd-operator image: quay.io/coreos/etcd-operator:v0.2.1 env: - name: MY_POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: MY_POD_NAME valueFrom: fieldRef: fieldPath: metadata.name 我们来看看相同设计的 YAML，利用它，我们可以告诉 Kubernetes 最终想要的是什么，然后 Kubernetes 会完成目标。 声明式 API 使系统更加健壮，在分布式系统中，任何组件都可能随时出现故障。当组件恢复时，需要弄清楚要做什么，使用命令式 API 时，处理起来就很棘手。但是使用声明式 API ，组件只需查看 API 服务器的当前状态，即可确定它需要执行的操作。 显式的 API Kubernetes 是透明的，它没有隐藏的内部 API。换句话说 Kubernetes 系统内部用来交互的 API 和我们用来与 Kubernetes 交互的 API 相同。 这样做的好处是，当 Kubernetes 默认的组件无法满足我们的需求时，我们可以利用已有的 API 实现我们自定义的特性。 无侵入性 感谢 Docker 容器技术的流行，使得 Kubernetes 为大家提供了无缝的使用方式。在容器化的时代，我们的应用达到镜像后，不需要改动就可以遨游在 Kubernetes 集群中。 Kubernetes 还提供存储 Secret、Configuration 等包含但不局限于密码、证书、容器镜像信息、应用启动参数能力。如此，Kubernetes 以一种友好的方式将这些东西注入 Pod，减少了大家的工作量，而无需重写或者很大幅度改变原有的应用代码。 有状态的移植 在有状态的存储场景下，Kubernetes 如何做到对于服务和存储的分离呢？假设一个大型分布式系统使用了多家云厂商的存储方案，如何做到开发者无感于底层的存储技术体系，并且做到方便的移植？ 为了实现这一目标，Kubernetes 引入了 PersistentVolumeClaim（PVC）和 PersistentVolume（PV）API 对象。这些对象将存储实现与存储使用分离。 PersistentVolumeClaim 对象用作用户以与实现无关的方式请求存储的方法，通过它来抹除对底层 PersistentVolume 的差异性。这样就使 Kubernetes 拥有了跨集群的移植能力。 架构 首先要提及的是 Kubernetes 使用很具代表性的 C/S 架构方式，Client 可以使用 kubectl 命令行或者 RESTful 接口与 Kubernetes 集群进行交互。下面这张图是从宏观上看 Kubernetes 的整体架构，每一个 Kubernetes 集群都由 Master 节点 和 很多的 Node 节点组成。 Master Master 是 Kubernetes 集群的管理节点，负责管理集群，提供集群的资源数据访问入口。拥有 Etcd 存储服务，运行 API Server 进程，Controller Manager 服务进程及 Scheduler 服务进程，关联工作节点 Node。 Kubernetes API Server 提供 HTTP Rest 接口的关键服务进程，是 Kubernetes 里所有资源的增、删、改、查等操作的唯一入口。也是集群控制的入口进程；&nbsp;Kubernetes Controller Manager 是 Kubernetes 所有资源对象的自动化控制中心，它驱使集群向着我们所需要的最终目的状态； Kubernetes Schedule 是负责 Pod 调度的进程。 Node Node 是 Kubernetes 集群架构中运行 Pod 的服务节点。Node 是 Kubernetes 集群操作的单元，用来承载被分配 Pod 的运行，是 Pod 运行的宿主机。关联 Master 管理节点，拥有名称和 IP、系统资源信息。运行 Docker Runtime、kubelet 和 kube-proxy。 kubelet 负责对 Pod 对于的容器的创建、启停等任务，发送宿主机当前状态； kube-proxy 实现 Kubernetes Service 的通信与负载均衡机制的重要组件； Docker Runtime 负责本机容器的创建和管理工作。 实现原理 为了尽可能地让读者能明白 Kubernetes 是如何运作的，这里不会涉及到具体的细节实现，如有读者感兴趣可以自行参阅官网文档。这里以一个简单的应用部署示例来阐述一些概念和原理。 创建 Kubernetes 集群 介绍架构的时候我们知道，Kubernetes 集群由 Master 和 Node 组成。 Master 管理集群的所有行为例如：应用调度、改变应用的状态，扩缩容，更新/降级应用等。 Node 可以是是一个虚拟机或者物理机，它是应用的“逻辑主机”，每一个 Node 拥有一个 Kubelet，Kubelet 负责管理 Node 节点与 Master 节点的交互，同时 Node 还需要有容器操作的能力，比如 Docker 或者 rkt。理论上来说，一个 Kubernetes 为了应对生产环境的流量，最少部署3个 Node 节点。 当我们需要在 Kubernetes 上部署应用时，我们告诉 Master 节点，Master 会调度容器跑在合适的 Node 节点上。 我们可以使用 Minikube 在本地搭一个单 Node 的 Kubernetes 集群。 部署应用 当创建好一个 Kubernetes 集群后，就可以把容器化的应用跑在上面了。我们需要创建一个 Deployment，它会告诉 Kubernetes Master 如何去创建应用，也可以来更新应用。 当应用实例创建后，Deployment 会不断地观察这些实例，如果 Node 上的 Pod 挂了，Deployment 会自动创建新的实例并且替换它。相比传统脚本运维的方式，这种方式更加优雅。 我们能通过 kubectl 命令或者 YAML 文件来创建 Deployment，在创建的时候需要指定应用镜像和要跑的实例个数，之后 Kubernetes 会自动帮我们处理。 查看 Pods 和 Nodes 下面来介绍下 Pod 和 Node：&nbsp; 当我们创建好 Deployment 的时候，Kubernetes 会自动创建 Pod 来承载应用实例。Pod 是一个抽象的概念，像一个“逻辑主机”，它代表一组应用容器的集合，这些应用容器共享资源，包括存储，网络和相同的内部集群 IP。 &nbsp; 任何一个 Pod 都需要跑在一个 Node 节点上。Node 是一个“虚拟机器”，它可以是虚拟机也可以是物理机，一个 Node 可以有多个 Pods，Kubernetes 会自动调度 Pod 到合适的 Node 上。 Service 与 LabelSelector Pods 终有一死，也就是说 Pods 也有自己的生命周期，当一个 Pod 挂了的时候，ReplicaSet 会创建新的，并且调度到合适的 Node 节点上。考虑下访问的问题，Pod 替换伴随着 IP 的变化，对于访问者来说，变化的 IP 是合理的；并且当有多个 Pod 节点时，如何 SLB 访问也是个问题，Service 就是为了解决这些问题的。 Service 是一个抽象的概念，它定义了一组逻辑 Pods，并且提供访问它们的策略。和其他对象一样，Service 也能通过 kubectl 或者 YAML 创建。Service 定义的 Pod 可以写在 LabelSelector 选项中（下文会介绍），也存在不指定 Pods 的情况，这种比较复杂，感兴趣的读者可以自行查阅资料。 Service 有以下几种类型： ClusterIP（默认）：在集群中内部IP上暴露服务，此类型使Service只能从群集中访问； NodePort：通过每个 Node 上的 IP 和静态端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求&nbsp;: ，可以从集群的外部访问一个 NodePort 服务； LoadBalancer：使用云提供商的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务； ExternalName：通过返回 CNAME 和它的值，（适用于外部 DNS 的场景） &nbsp; Labels 和 Selectors 能够让 Kubernetes 拥有逻辑运算的能力，有点像 SQL。举个例子：可以查找 app=hello_word 的所有对象，也可以查找 app in (a,b,c) abc的所有对象。 Labels是一个绑定在对象上的 K/V 结构，它可以在创建或者之后的时候的定义，在任何时候都可以改变。 扩容应用 前文提到我们可以使用 Deployment 增加实例个数，下图是原始的集群状态：&nbsp; 我们可以随意的更改 replicas （实例个数）来扩容，当我们更改了 Deployment 中的 replicas 值时，Kubernetes 会自动帮我们达到想要的目标实例个数，如下图：&nbsp; 更新应用 更新应用和扩容类似，我们可以更改 Deployment 中的容器镜像，然后 Kubernetes 会帮住我们应用更新（蓝绿、金丝雀等方式），通过此功能，我们还可以实现切换应用环境、回滚、不停机 CI/CD。下面是部署的过程，需要注意的是我们可以指定新创建的 Pod 最大个数和不可用 Pod 最大个数： &nbsp; 总结 到了最后，大家对 Kubernetes 有个大概的了解了，但 Kubernetes 远远不止本文所介绍的这些内容。在云原生概念逐渐清晰的今天，Kubernetes 作为 CNCF 中一个接地气的落地项目，其重要性不言而喻。 最后，阿里云智能事业群，招聘2020年毕业的实习生和社招技术同学。团队主要聚焦在 Kubernetes、集群管理、自动化和云原生相关技术方向，负责阿里集团的监控和运维。有意者可以发简历到 jianmin.hjm@alibaba-inc.com。 你可能还喜欢 点击下方图片即可阅读 阿里开源 OpenJDK 长期支持版本 Alibaba Dragonwell 为拯救爸妈朋友圈，达摩院造了“谣言粉碎机” 阿里巴巴2019实习生招聘正式启动！" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"阿里妹导读：Kubernetes 近几年很热门，在各大技术论坛上被炒的很火。它提供了强大的容器编排能力，与此同时 DevOps 的概念也来到大家身边，广大的开发同学也能简单地运维复杂的商业化分布式系统，打破了传统开发和运维之间的界限。 本文会以初学者的视角，希望能让读者更好地理解 Kubernetes 出现的背景、超前的设计理念和优秀的技术架构。 背景 PaaS PaaS 技术，一句话概括就是：它提供了“应用托管”的能力。 早期的主流做法基本上是租 AWS 或者 OpenStack 的虚拟机，然后把这些虚拟机当作物理机一样，用脚本或者手工的方式在上面部署应用。这个过程中如何保证本地环境和云端环境的一致性是一个很大的课题，而提供云计算服务的公司的核心竞争力就是比拼谁做的更好。从某种意义上来说 PaaS 的出现，算是一个比较好的解决方案。 以 Cloud Foundry 为例，在虚拟机上部署上 Cloud Foundry 项目后，用户可以很方便地把自己的应用上云。以上帝视角来看这个过程：Cloud Foundry 最核心的是提供了一套应用的打包和分发机制，它为不同的编程语言定义了不同的打包格式，它能把可执行文件、启动参数等等一起打包成压缩包然后上传至 Cloud Foundry 存储中心，最后由调度器选择虚拟机，由虚拟机上的 Agent 下载并启动应用。 分布式系统 随着软件的规模越来越大，业务模式越来越复杂，用户量的上升、地区的分布、系统性能的苛刻要求都促成服务架构从最初的单体变成 SOA 再到如今的微服务，未来还可能演变为 Service Mesh ，Serverless 等等。 如今，一个完整的后端系统不再是单体应用架构了，多年前的 DDD 概念重新回到大家的视线中。现在的系统被不同的职责和功能拆成多个服务，服务之间复杂的关系以及单机的单点性能瓶颈让部署和运维变得很复杂，所以部署和运维大型分布式系统的需求急迫待解决。 容器技术 前面提到诸如 Cloud Foundry 的 PaaS，用户必须为不同语言、不同框架区分不同的打包方式，这个打包过程是非常具有灾难性的。而现实往往更糟糕，当在本地跑的好好的应用，由于和远端环境的不一致，在打包后却需要在云端各种调试，最终才能让应用“平稳”运行。 而 Docker 的出现改变了一切，它凭借镜像解决了这个问题。Docker 一不做二不休，干脆把完整的操作系统目录也打包进去，如此高的集成度，保证了云端和本地环境的高度一致，并且随时随地轻易地移植。 谁也不知道就因为“镜像”这个简单的功能，Docker 完成了对 PaaS 的降维打击，占有了市场。此时，一些聪明的技术公司纷纷跟进 Docker，推出了自家的容器集群管理项目，并且称之为 CaaS。 容器技术利用 Namespace 实现隔离，利用 Cgroups 实现限制；在 Docker 实现上，通过镜像，为容器提供完整的系统执行环境，并且通过 UnionFS 实现 Layer 的设计。 Docker 容器是完全使用沙箱机制，相互之间不会有任何接口。通过 Docker，实现进程、网络、挂载点和文件隔离，更好地利用宿主机资源。Docker 强大到不需要关心宿主机的依赖，所有的一切都可以在镜像构建时完成，这也是 Docker 目前成为容器技术标准的原因。所以我们能看到在 Kubernetes 中默认使用 Docker 作为容器（也支持 rkt）。 Kubernetes 铺垫了这么多，终于说到本文的主角了。说 Kubernetes 之前，不得不提 Compose、Swarm、Machine 三剑客，其实在 Kubernetes 还未一统江湖之前，它们已经能实现大部分容器编排的能力了。但是在真正的大型系统上，它们却远远不如 Mesosphere 公司出品的大型集群管理系统，更别说之后的 Kubernetes 了。 在容器化和微服务时代，服务越来越多，容器个数也越来越多。Docker 如它 Logo 所示一样，一只只鲸鱼在大海里自由地游荡，而 Kubernetes 就像一个掌舵的船长，带着它们，有序的管理它们，这个过程其实就是容器编排。 Kubernetes 起源于 Google，很多设计都是源自于 Borg，是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效，并且提供了应用部署，规划，更新，维护的一种机制。 小结 至此，读者了解了 Kubernetes 的前世今生，由 PaaS 的火热，引爆了容器技术的战争，而赢得这场战争中最关键的即是拥有强大的容器编排的能力，而 Kubernetes 无疑是这场战争的胜利者。 设计理念 这一部分，我们会围绕 Kubernetes 的四个设计理念看看这些做法能给我们带来什么。 声明式 VS 命令式&nbsp; 声明式和命令式是截然不同的两种编程方式，在命令式 API 中，我们可以直接发出服务器要执行的命令，例如： “运行容器”、“停止容器”等；在声明式 API 中，我们声明系统要执行的操作，系统将不断向该状态驱动。 我们常用的 SQL 就是一种声明式语言，告诉数据库想要的结果集，数据库会帮我们设计获取这个结果集的执行路径，并返回结果集。众所周知，使用 SQL 语言获取数据，要比自行编写处理过程去获取数据容易的多。 apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: etcd-operatorspec: replicas: 1 template: metadata: labels: name: etcd-operator spec: containers: - name: etcd-operator image: quay.io/coreos/etcd-operator:v0.2.1 env: - name: MY_POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: MY_POD_NAME valueFrom: fieldRef: fieldPath: metadata.name 我们来看看相同设计的 YAML，利用它，我们可以告诉 Kubernetes 最终想要的是什么，然后 Kubernetes 会完成目标。 声明式 API 使系统更加健壮，在分布式系统中，任何组件都可能随时出现故障。当组件恢复时，需要弄清楚要做什么，使用命令式 API 时，处理起来就很棘手。但是使用声明式 API ，组件只需查看 API 服务器的当前状态，即可确定它需要执行的操作。 显式的 API Kubernetes 是透明的，它没有隐藏的内部 API。换句话说 Kubernetes 系统内部用来交互的 API 和我们用来与 Kubernetes 交互的 API 相同。 这样做的好处是，当 Kubernetes 默认的组件无法满足我们的需求时，我们可以利用已有的 API 实现我们自定义的特性。 无侵入性 感谢 Docker 容器技术的流行，使得 Kubernetes 为大家提供了无缝的使用方式。在容器化的时代，我们的应用达到镜像后，不需要改动就可以遨游在 Kubernetes 集群中。 Kubernetes 还提供存储 Secret、Configuration 等包含但不局限于密码、证书、容器镜像信息、应用启动参数能力。如此，Kubernetes 以一种友好的方式将这些东西注入 Pod，减少了大家的工作量，而无需重写或者很大幅度改变原有的应用代码。 有状态的移植 在有状态的存储场景下，Kubernetes 如何做到对于服务和存储的分离呢？假设一个大型分布式系统使用了多家云厂商的存储方案，如何做到开发者无感于底层的存储技术体系，并且做到方便的移植？ 为了实现这一目标，Kubernetes 引入了 PersistentVolumeClaim（PVC）和 PersistentVolume（PV）API 对象。这些对象将存储实现与存储使用分离。 PersistentVolumeClaim 对象用作用户以与实现无关的方式请求存储的方法，通过它来抹除对底层 PersistentVolume 的差异性。这样就使 Kubernetes 拥有了跨集群的移植能力。 架构 首先要提及的是 Kubernetes 使用很具代表性的 C/S 架构方式，Client 可以使用 kubectl 命令行或者 RESTful 接口与 Kubernetes 集群进行交互。下面这张图是从宏观上看 Kubernetes 的整体架构，每一个 Kubernetes 集群都由 Master 节点 和 很多的 Node 节点组成。 Master Master 是 Kubernetes 集群的管理节点，负责管理集群，提供集群的资源数据访问入口。拥有 Etcd 存储服务，运行 API Server 进程，Controller Manager 服务进程及 Scheduler 服务进程，关联工作节点 Node。 Kubernetes API Server 提供 HTTP Rest 接口的关键服务进程，是 Kubernetes 里所有资源的增、删、改、查等操作的唯一入口。也是集群控制的入口进程；&nbsp;Kubernetes Controller Manager 是 Kubernetes 所有资源对象的自动化控制中心，它驱使集群向着我们所需要的最终目的状态； Kubernetes Schedule 是负责 Pod 调度的进程。 Node Node 是 Kubernetes 集群架构中运行 Pod 的服务节点。Node 是 Kubernetes 集群操作的单元，用来承载被分配 Pod 的运行，是 Pod 运行的宿主机。关联 Master 管理节点，拥有名称和 IP、系统资源信息。运行 Docker Runtime、kubelet 和 kube-proxy。 kubelet 负责对 Pod 对于的容器的创建、启停等任务，发送宿主机当前状态； kube-proxy 实现 Kubernetes Service 的通信与负载均衡机制的重要组件； Docker Runtime 负责本机容器的创建和管理工作。 实现原理 为了尽可能地让读者能明白 Kubernetes 是如何运作的，这里不会涉及到具体的细节实现，如有读者感兴趣可以自行参阅官网文档。这里以一个简单的应用部署示例来阐述一些概念和原理。 创建 Kubernetes 集群 介绍架构的时候我们知道，Kubernetes 集群由 Master 和 Node 组成。 Master 管理集群的所有行为例如：应用调度、改变应用的状态，扩缩容，更新/降级应用等。 Node 可以是是一个虚拟机或者物理机，它是应用的“逻辑主机”，每一个 Node 拥有一个 Kubelet，Kubelet 负责管理 Node 节点与 Master 节点的交互，同时 Node 还需要有容器操作的能力，比如 Docker 或者 rkt。理论上来说，一个 Kubernetes 为了应对生产环境的流量，最少部署3个 Node 节点。 当我们需要在 Kubernetes 上部署应用时，我们告诉 Master 节点，Master 会调度容器跑在合适的 Node 节点上。 我们可以使用 Minikube 在本地搭一个单 Node 的 Kubernetes 集群。 部署应用 当创建好一个 Kubernetes 集群后，就可以把容器化的应用跑在上面了。我们需要创建一个 Deployment，它会告诉 Kubernetes Master 如何去创建应用，也可以来更新应用。 当应用实例创建后，Deployment 会不断地观察这些实例，如果 Node 上的 Pod 挂了，Deployment 会自动创建新的实例并且替换它。相比传统脚本运维的方式，这种方式更加优雅。 我们能通过 kubectl 命令或者 YAML 文件来创建 Deployment，在创建的时候需要指定应用镜像和要跑的实例个数，之后 Kubernetes 会自动帮我们处理。 查看 Pods 和 Nodes 下面来介绍下 Pod 和 Node：&nbsp; 当我们创建好 Deployment 的时候，Kubernetes 会自动创建 Pod 来承载应用实例。Pod 是一个抽象的概念，像一个“逻辑主机”，它代表一组应用容器的集合，这些应用容器共享资源，包括存储，网络和相同的内部集群 IP。 &nbsp; 任何一个 Pod 都需要跑在一个 Node 节点上。Node 是一个“虚拟机器”，它可以是虚拟机也可以是物理机，一个 Node 可以有多个 Pods，Kubernetes 会自动调度 Pod 到合适的 Node 上。 Service 与 LabelSelector Pods 终有一死，也就是说 Pods 也有自己的生命周期，当一个 Pod 挂了的时候，ReplicaSet 会创建新的，并且调度到合适的 Node 节点上。考虑下访问的问题，Pod 替换伴随着 IP 的变化，对于访问者来说，变化的 IP 是合理的；并且当有多个 Pod 节点时，如何 SLB 访问也是个问题，Service 就是为了解决这些问题的。 Service 是一个抽象的概念，它定义了一组逻辑 Pods，并且提供访问它们的策略。和其他对象一样，Service 也能通过 kubectl 或者 YAML 创建。Service 定义的 Pod 可以写在 LabelSelector 选项中（下文会介绍），也存在不指定 Pods 的情况，这种比较复杂，感兴趣的读者可以自行查阅资料。 Service 有以下几种类型： ClusterIP（默认）：在集群中内部IP上暴露服务，此类型使Service只能从群集中访问； NodePort：通过每个 Node 上的 IP 和静态端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求&nbsp;: ，可以从集群的外部访问一个 NodePort 服务； LoadBalancer：使用云提供商的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务； ExternalName：通过返回 CNAME 和它的值，（适用于外部 DNS 的场景） &nbsp; Labels 和 Selectors 能够让 Kubernetes 拥有逻辑运算的能力，有点像 SQL。举个例子：可以查找 app=hello_word 的所有对象，也可以查找 app in (a,b,c) abc的所有对象。 Labels是一个绑定在对象上的 K/V 结构，它可以在创建或者之后的时候的定义，在任何时候都可以改变。 扩容应用 前文提到我们可以使用 Deployment 增加实例个数，下图是原始的集群状态：&nbsp; 我们可以随意的更改 replicas （实例个数）来扩容，当我们更改了 Deployment 中的 replicas 值时，Kubernetes 会自动帮我们达到想要的目标实例个数，如下图：&nbsp; 更新应用 更新应用和扩容类似，我们可以更改 Deployment 中的容器镜像，然后 Kubernetes 会帮住我们应用更新（蓝绿、金丝雀等方式），通过此功能，我们还可以实现切换应用环境、回滚、不停机 CI/CD。下面是部署的过程，需要注意的是我们可以指定新创建的 Pod 最大个数和不可用 Pod 最大个数： &nbsp; 总结 到了最后，大家对 Kubernetes 有个大概的了解了，但 Kubernetes 远远不止本文所介绍的这些内容。在云原生概念逐渐清晰的今天，Kubernetes 作为 CNCF 中一个接地气的落地项目，其重要性不言而喻。 最后，阿里云智能事业群，招聘2020年毕业的实习生和社招技术同学。团队主要聚焦在 Kubernetes、集群管理、自动化和云原生相关技术方向，负责阿里集团的监控和运维。有意者可以发简历到 jianmin.hjm@alibaba-inc.com。 你可能还喜欢 点击下方图片即可阅读 阿里开源 OpenJDK 长期支持版本 Alibaba Dragonwell 为拯救爸妈朋友圈，达摩院造了“谣言粉碎机” 阿里巴巴2019实习生招聘正式启动！","@type":"BlogPosting","url":"/2019/04/29/729093.html","headline":"Kubernetes 如何打赢容器之战？","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/29/729093.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Kubernetes 如何打赢容器之战？</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);text-align: center;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="" data-ratio="0.47888888888888886" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxqOC1ehicb0nhNjJjYte6Rr2Biav1rWupIfn3DxfmtQUWkadj4cF7ka2w/640?wx_fmt=png" data-type="png" data-w="900" data-backw="556" data-backh="266" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxqOC1ehicb0nhNjJjYte6Rr2Biav1rWupIfn3DxfmtQUWkadj4cF7ka2w/640?wx_fmt=png" style="letter-spacing: 0.5440000295639038px;text-align: center;white-space: normal;background-color: rgb(255, 255, 255);color: rgb(62, 62, 62);font-size: 15px;width: 556px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxqOC1ehicb0nhNjJjYte6Rr2Biav1rWupIfn3DxfmtQUWkadj4cF7ka2w/640?wx_fmt=png"></p> 
<section class="" powered-by="xiumi.us" style="white-space: normal;max-width: 100%;letter-spacing: 0.544px;line-height: 27.2px;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"> 
 <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
  <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
   <section class="" powered-by="xiumi.us" style="max-width: 100%;letter-spacing: 0.544px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
    <section class="" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
     <section label="Copyright Reserved by PLAYHUDONG." donone="shifuMouseDownCard('shifu_c_008')" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
      <section class="" powered-by="xiumi.us" style="max-width: 100%;letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
       <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
        <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
         <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
          <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
           <section label="Copyright Reserved by PLAYHUDONG." donone="shifuMouseDownCard('shifu_c_008')" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
            <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
             <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
              <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
               <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                 <section label="Copyright Reserved by PLAYHUDONG." donone="shifuMouseDownCard('shifu_c_008')" style="margin-right: 0em;margin-left: 0em;padding: 0.5em 1em;max-width: 100%;border-style: none;background-color: rgb(235, 235, 235);box-sizing: border-box !important;word-wrap: break-word !important;"> 
                  <p style="max-width: 100%;min-height: 1em;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 15px;letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">阿里妹导读</span><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 15px;letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">：Kubernetes 近几年很热门，在各大技术论坛上被炒的很火。它提供了强大的容器编排能力，与此同时 DevOps 的概念也来到大家身边，广大的开发同学也能简单地运维复杂的商业化分布式系统，打破了传统开发和运维之间的界限。</span></p> 
                  <p style="max-width: 100%;min-height: 1em;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><br></p> 
                  <p style="text-align: left;line-height: 1.75em;"><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 15px;letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">本文会以初学者的视角，希望能让读者更好地理解 Kubernetes 出现的背景、超前的设计理念和优秀的技术架构。</span></p> 
                 </section> 
                </section> 
               </section> 
              </section> 
             </section> 
            </section> 
           </section> 
          </section> 
         </section> 
        </section> 
       </section> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><br></p> 
<h2 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">背景</span></strong></h2> 
<p style="white-space: normal;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">PaaS</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">PaaS 技术，一句话概括就是：它提供了“应用托管”的能力。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.5164433617539586" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxibIh6xPuVUFeuLRGoiavjIIrZUQguORNgYmDuwHnCqPGkCialFW8cFOJw/640?wx_fmt=png" data-type="png" data-w="1642" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;width: 100%;height: auto;" data-backw="556" data-backh="287" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxibIh6xPuVUFeuLRGoiavjIIrZUQguORNgYmDuwHnCqPGkCialFW8cFOJw/640?wx_fmt=png" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxibIh6xPuVUFeuLRGoiavjIIrZUQguORNgYmDuwHnCqPGkCialFW8cFOJw/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">早期的主流做法基本上是租 AWS 或者 OpenStack 的虚拟机，然后把这些虚拟机当作物理机一样，用脚本或者手工的方式在上面部署应用。这个过程中如何保证本地环境和云端环境的一致性是一个很大的课题，而提供云计算服务的公司的核心竞争力就是比拼谁做的更好。从某种意义上来说 PaaS 的出现，算是一个比较好的解决方案。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">以 Cloud Foundry 为例，在虚拟机上部署上 Cloud Foundry 项目后，用户可以很方便地把自己的应用上云。以上帝视角来看这个过程：Cloud Foundry 最核心的是提供了一套应用的打包和分发机制，它为不同的编程语言定义了不同的打包格式，它能把可执行文件、启动参数等等一起打包成压缩包然后上传至 Cloud Foundry 存储中心，最后由调度器选择虚拟机，由虚拟机上的 Agent 下载并启动应用。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">分布式系统</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">随着软件的规模越来越大，业务模式越来越复杂，用户量的上升、地区的分布、系统性能的苛刻要求都促成服务架构从最初的单体变成 SOA 再到如今的微服务，未来还可能演变为 Service Mesh ，Serverless 等等。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.4335347432024169" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFx9udlkicsf6UW4uibBmV00GhVyZibmH6fvgcxEpV8eSr4mMxtaEuQVnHKA/640?wx_fmt=png" data-type="png" data-w="1324" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFx9udlkicsf6UW4uibBmV00GhVyZibmH6fvgcxEpV8eSr4mMxtaEuQVnHKA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">如今，一个完整的后端系统不再是单体应用架构了，多年前的 DDD 概念重新回到大家的视线中。现在的系统被不同的职责和功能拆成多个服务，服务之间复杂的关系以及单机的单点性能瓶颈让部署和运维变得很复杂，所以部署和运维大型分布式系统的需求急迫待解决。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">容器技术</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">前面提到诸如 Cloud Foundry 的 PaaS，用户必须为不同语言、不同框架区分不同的打包方式，这个打包过程是非常具有灾难性的。而现实往往更糟糕，当在本地跑的好好的应用，由于和远端环境的不一致，在打包后却需要在云端各种调试，最终才能让应用“平稳”运行。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">而 Docker 的出现改变了一切，它凭借镜像解决了这个问题。Docker 一不做二不休，干脆把完整的操作系统目录也打包进去，如此高的集成度，保证了云端和本地环境的高度一致，并且随时随地轻易地移植。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-backh="130" data-backw="556" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFx8AapUjY7LvicxibzMj92DiaTzaCcIibNlIEIByqBe9JxC6hCibibNKibhKH2A/640?wx_fmt=png" data-oversubscription-url="http://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLq4eJMAiaq7fOP9jsDnMOPzY8RkUzLglTHLNQGV7vdvY00VXtibzricBx3UqZMsYfHwWuaicicMj0lTAA/0?wx_fmt=jpeg" data-ratio="0.23439340400471143" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLq4eJMAiaq7fOP9jsDnMOPzY8RkUzLglTHLNQGV7vdvY00VXtibzricBx3UqZMsYfHwWuaicicMj0lTAA/640?wx_fmt=jpeg" data-type="jpeg" data-w="849" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;width: 100%;height: auto;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLq4eJMAiaq7fOP9jsDnMOPzY8RkUzLglTHLNQGV7vdvY00VXtibzricBx3UqZMsYfHwWuaicicMj0lTAA/640?wx_fmt=jpeg"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">谁也不知道就因为“镜像”这个简单的功能，Docker 完成了对 PaaS 的降维打击，占有了市场。此时，一些聪明的技术公司纷纷跟进 Docker，推出了自家的容器集群管理项目，并且称之为 CaaS。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">容器技术利用 Namespace 实现隔离，利用 Cgroups 实现限制；在 Docker 实现上，通过镜像，为容器提供完整的系统执行环境，并且通过 UnionFS 实现 Layer 的设计。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Docker 容器是完全使用沙箱机制，相互之间不会有任何接口。通过 Docker，实现进程、网络、挂载点和文件隔离，更好地利用宿主机资源。Docker 强大到不需要关心宿主机的依赖，所有的一切都可以在镜像构建时完成，这也是 Docker 目前成为容器技术标准的原因。所以我们能看到在 Kubernetes 中默认使用 Docker 作为容器（也支持 rkt）。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">Kubernetes</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">铺垫了这么多，终于说到本文的主角了。说 Kubernetes 之前，不得不提 Compose、Swarm、Machine 三剑客，其实在 Kubernetes 还未一统江湖之前，它们已经能实现大部分容器编排的能力了。但是在真正的大型系统上，它们却远远不如 Mesosphere 公司出品的大型集群管理系统，更别说之后的 Kubernetes 了。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.6538461538461539" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxAdpcasQ4Yia1X5XU5U70icpicwtb0KmSnadhSuz2Dubq2RvsDuzpfcchA/640?wx_fmt=png" data-type="png" data-w="260" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxAdpcasQ4Yia1X5XU5U70icpicwtb0KmSnadhSuz2Dubq2RvsDuzpfcchA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">在容器化和微服务时代，服务越来越多，容器个数也越来越多。Docker 如它 Logo 所示一样，一只只鲸鱼在大海里自由地游荡，而 Kubernetes 就像一个掌舵的船长，带着它们，有序的管理它们，这个过程其实就是容器编排。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Kubernetes 起源于 Google，很多设计都是源自于 Borg，是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效，并且提供了应用部署，规划，更新，维护的一种机制。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">小结</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">至此，读者了解了 Kubernetes 的前世今生，由 PaaS 的火热，引爆了容器技术的战争，而赢得这场战争中最关键的即是拥有强大的容器编排的能力，而 Kubernetes 无疑是这场战争的胜利者。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h2 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">设计理念</span></strong></h2> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">这一部分，我们会围绕 Kubernetes 的四个设计理念看看这些做法能给我们带来什么。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">声明式 VS 命令式&nbsp;</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">声明式和命令式是截然不同的两种编程方式，在命令式 API 中，我们可以直接发出服务器要执行的命令，例如： “运行容器”、“停止容器”等；在声明式 API 中，我们声明系统要执行的操作，系统将不断向该状态驱动。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.5388888888888889" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxiaKEb5uel9vsPdGAElYicLa5stmBia6fCKzua2kMNgrictUCDlDbSuRvtQ/640?wx_fmt=png" data-type="png" data-w="540" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxiaKEb5uel9vsPdGAElYicLa5stmBia6fCKzua2kMNgrictUCDlDbSuRvtQ/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">我们常用的 SQL 就是一种声明式语言，告诉数据库想要的结果集，数据库会帮我们设计获取这个结果集的执行路径，并返回结果集。众所周知，使用 SQL 语言获取数据，要比自行编写处理过程去获取数据容易的多。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<pre style="text-align: left;">
         
 <section class="code-snippet__fix code-snippet__js">
          
  <ul class="code-snippet__line-index code-snippet__js"> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
   <li></li> 
  </ul>
          
  <pre class="code-snippet__js" data-lang="properties"><code><span class="code-snippet_outer"><span class="code-snippet__attr">apiVersion</span>: <span class="code-snippet__string">extensions/v1beta1</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">kind</span>: <span class="code-snippet__string">Deployment</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">metadata</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">name</span>: <span class="code-snippet__string">etcd-operator</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">spec</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">replicas</span>: <span class="code-snippet__string">1</span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">template</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">metadata</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">labels</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">name</span>: <span class="code-snippet__string">etcd-operator</span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">spec</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">containers</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__meta">-</span> <span class="code-snippet__string">name: etcd-operator</span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">image</span>: <span class="code-snippet__string">quay.io/coreos/etcd-operator:v0.2.1</span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">env</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__meta">-</span> <span class="code-snippet__string">name: MY_POD_NAMESPACE</span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">valueFrom</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">fieldRef</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">fieldPath</span>: <span class="code-snippet__string">metadata.namespace</span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__meta">-</span> <span class="code-snippet__string">name: MY_POD_NAME</span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">valueFrom</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">fieldRef</span>:<span class="code-snippet__string"></span></span></code><code><span class="code-snippet_outer"> <span class="code-snippet__attr">fieldPath</span>: <span class="code-snippet__string">metadata.name</span></span></code></pre>
         
 </section></pre> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">我们来看看相同设计的 YAML，利用它，我们可以告诉 Kubernetes 最终想要的是什么，然后 Kubernetes 会完成目标。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">声明式 API 使系统更加健壮，在分布式系统中，任何组件都可能随时出现故障。当组件恢复时，需要弄清楚要做什么，使用命令式 API 时，处理起来就很棘手。但是使用声明式 API ，组件只需查看 API 服务器的当前状态，即可确定它需要执行的操作。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">显式的 API</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Kubernetes 是透明的，它没有隐藏的内部 API。换句话说 Kubernetes 系统内部用来交互的 API 和我们用来与 Kubernetes 交互的 API 相同。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);"><br></span></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.48717948717948717" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxkC4DmzibBytBCf3pkTUpYX9nOQ0SmjCHsZibfzXDPxwoBUXyT0lFx5fQ/640?wx_fmt=png" data-type="png" data-w="1638" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxkC4DmzibBytBCf3pkTUpYX9nOQ0SmjCHsZibfzXDPxwoBUXyT0lFx5fQ/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">这样做的好处是，当 Kubernetes 默认的组件无法满足我们的需求时，我们可以利用已有的 API 实现我们自定义的特性。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">无侵入性</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">感谢 Docker 容器技术的流行，使得 Kubernetes 为大家提供了无缝的使用方式。在容器化的时代，我们的应用达到镜像后，不需要改动就可以遨游在 Kubernetes 集群中。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.8153846153846154" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxCjqKU5HrKUuFtCiaciauWylxINWfFcPLL3iagsvtJ3eQx0corAHhonQpg/640?wx_fmt=png" data-type="png" data-w="650" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxCjqKU5HrKUuFtCiaciauWylxINWfFcPLL3iagsvtJ3eQx0corAHhonQpg/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Kubernetes 还提供存储 Secret、Configuration 等包含但不局限于密码、证书、容器镜像信息、应用启动参数能力。如此，Kubernetes 以一种友好的方式将这些东西注入 Pod，减少了大家的工作量，而无需重写或者很大幅度改变原有的应用代码。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">有状态的移植</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">在有状态的存储场景下，Kubernetes 如何做到对于服务和存储的分离呢？假设一个大型分布式系统使用了多家云厂商的存储方案，如何做到开发者无感于底层的存储技术体系，并且做到方便的移植？</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.5052386495925495" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxvnSWqadqZfGSZiae6d5FoC9yoAvRgJlR9JwoP2D4lKz9hahvQctBu6w/640?wx_fmt=png" data-type="png" data-w="859" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxvnSWqadqZfGSZiae6d5FoC9yoAvRgJlR9JwoP2D4lKz9hahvQctBu6w/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">为了实现这一目标，Kubernetes 引入了 PersistentVolumeClaim（PVC）和 PersistentVolume（PV）API 对象。这些对象将存储实现与存储使用分离。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">PersistentVolumeClaim 对象用作用户以与实现无关的方式请求存储的方法，通过它来抹除对底层 PersistentVolume 的差异性。这样就使 Kubernetes 拥有了跨集群的移植能力。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h2 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">架构</span></strong></h2> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">首先要提及的是 Kubernetes 使用很具代表性的 C/S 架构方式，Client 可以使用 kubectl 命令行或者 RESTful 接口与 Kubernetes 集群进行交互。下面这张图是从宏观上看 Kubernetes 的整体架构，每一个 Kubernetes 集群都由 Master 节点 和 很多的 Node 节点组成。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.6060279870828849" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxic3KWb577UaBcOiavSbx02FML9B7FdU88fBuibtzPrPCfvbg4yQkibdz4w/640?wx_fmt=png" data-type="png" data-w="1858" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxic3KWb577UaBcOiavSbx02FML9B7FdU88fBuibtzPrPCfvbg4yQkibdz4w/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">Master</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.666875" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxZHYEqoxsficKqfLmoicWKaqUhCQHxY4Wm4Jo8m3mne7TszEMxT4ibRxPQ/640?wx_fmt=png" data-type="png" data-w="1600" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxZHYEqoxsficKqfLmoicWKaqUhCQHxY4Wm4Jo8m3mne7TszEMxT4ibRxPQ/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Master 是 Kubernetes 集群的管理节点，负责管理集群，提供集群的资源数据访问入口。拥有 Etcd 存储服务，运行 API Server 进程，Controller Manager 服务进程及 Scheduler 服务进程，关联工作节点 Node。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Kubernetes API Server 提供 HTTP Rest 接口的关键服务进程，是 Kubernetes 里所有资源的增、删、改、查等操作的唯一入口。也是集群控制的入口进程；&nbsp;</span><span style="color: rgb(62, 62, 62);font-size: 15px;">Kubernetes Controller Manager 是 Kubernetes 所有资源对象的自动化控制中心，它驱使集群向着我们所需要的最终目的状态； Kubernetes Schedule 是负责 Pod 调度的进程。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">Node</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.666875" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxlXzkWicvEwfrQZCNek4XOnxONicIF2FibvibC1aHus0GQ3cF7QweJ9eP5g/640?wx_fmt=png" data-type="png" data-w="1600" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxlXzkWicvEwfrQZCNek4XOnxONicIF2FibvibC1aHus0GQ3cF7QweJ9eP5g/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Node 是 Kubernetes 集群架构中运行 Pod 的服务节点。Node 是 Kubernetes 集群操作的单元，用来承载被分配 Pod 的运行，是 Pod 运行的宿主机。关联 Master 管理节点，拥有名称和 IP、系统资源信息。运行 Docker Runtime、kubelet 和 kube-proxy。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">kubelet 负责对 Pod 对于的容器的创建、启停等任务，发送宿主机当前状态； kube-proxy 实现 Kubernetes Service 的通信与负载均衡机制的重要组件； Docker Runtime 负责本机容器的创建和管理工作。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h2 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">实现原理</span></strong></h2> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">为了尽可能地让读者能明白 Kubernetes 是如何运作的，这里不会涉及到具体的细节实现，如有读者感兴趣可以自行参阅官网文档。这里以一个简单的应用部署示例来阐述一些概念和原理。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">创建 Kubernetes 集群</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.7575150300601202" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxKFahyic5bEgeZnibhY6qouvLGtEKZ6QMPW588ibjYpIQ366Kic6FxQ80uA/640?wx_fmt=png" data-type="png" data-w="998" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxKFahyic5bEgeZnibhY6qouvLGtEKZ6QMPW588ibjYpIQ366Kic6FxQ80uA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="color: rgb(62, 62, 62);font-size: 15px;">介绍架构的时候我们知道，Kubernetes 集群由 Master 和 Node 组成。</span><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Master 管理集群的所有行为例如：应用调度、改变应用的状态，扩缩容，更新/降级应用等。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Node 可以是是一个虚拟机或者物理机，它是应用的“逻辑主机”，每一个 Node 拥有一个 Kubelet，Kubelet 负责管理 Node 节点与 Master 节点的交互，同时 Node 还需要有容器操作的能力，比如 Docker 或者 rkt。理论上来说，一个 Kubernetes 为了应对生产环境的流量，最少部署3个 Node 节点。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">当我们需要在 Kubernetes 上部署应用时，我们告诉 Master 节点，Master 会调度容器跑在合适的 Node 节点上。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">我们可以使用 Minikube 在本地搭一个单 Node 的 Kubernetes 集群。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">部署应用</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.7431906614785992" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxnZicgNJ6lhrDVBMJnGrFeStDDj9Ka8icRialqkGmH0jwABibXe02vedMdA/640?wx_fmt=png" data-type="png" data-w="1028" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxnZicgNJ6lhrDVBMJnGrFeStDDj9Ka8icRialqkGmH0jwABibXe02vedMdA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">当创建好一个 Kubernetes 集群后，就可以把容器化的应用跑在上面了。我们需要创建一个 Deployment，它会告诉 Kubernetes Master 如何去创建应用，也可以来更新应用。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">当应用实例创建后，Deployment 会不断地观察这些实例，如果 Node 上的 Pod 挂了，Deployment 会自动创建新的实例并且替换它。相比传统脚本运维的方式，这种方式更加优雅。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">我们能通过 kubectl 命令或者 YAML 文件来创建 Deployment，在创建的时候需要指定应用镜像和要跑的实例个数，之后 Kubernetes 会自动帮我们处理。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">查看 Pods 和 Nodes</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">下面来介绍下 Pod 和 Node：&nbsp;</span><img class="" data-ratio="0.38170347003154576" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxa42OKjWOf3ha04k5OW13rmMur9hXqBTJE1hanxlRJDSNr9jBClST2w/640?wx_fmt=png" data-type="png" data-w="1268" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxa42OKjWOf3ha04k5OW13rmMur9hXqBTJE1hanxlRJDSNr9jBClST2w/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">当我们创建好 Deployment 的时候，Kubernetes 会自动创建 Pod 来承载应用实例。Pod 是一个抽象的概念，像一个“逻辑主机”，它代表一组应用容器的集合，这些应用容器共享资源，包括存储，网络和相同的内部集群 IP。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.8503649635036497" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxxZa89N5iaNWAhpbYdKJ38diazoE3h9QMWZaP4P9HDMLMr8KaPLNNQXQA/640?wx_fmt=png" data-type="png" data-w="1096" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxxZa89N5iaNWAhpbYdKJ38diazoE3h9QMWZaP4P9HDMLMr8KaPLNNQXQA/640?wx_fmt=png"><span style="font-size: 15px;color: rgb(62, 62, 62);">&nbsp;</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">任何一个 Pod 都需要跑在一个 Node 节点上。Node 是一个“虚拟机器”，它可以是虚拟机也可以是物理机，一个 Node 可以有多个 Pods，Kubernetes 会自动调度 Pod 到合适的 Node 上。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">Service 与 LabelSelector</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Pods 终有一死，也就是说 Pods 也有自己的生命周期，当一个 Pod 挂了的时候，ReplicaSet 会创建新的，并且调度到合适的 Node 节点上。考虑下访问的问题，Pod 替换伴随着 IP 的变化，对于访问者来说，变化的 IP 是合理的；并且当有多个 Pod 节点时，如何 SLB 访问也是个问题，Service 就是为了解决这些问题的。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.9149659863945578" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxZqXcPdWWicFRXoOAUmm7EKKPicPdzFug6C14duoslFAUg4z91xYltC6g/640?wx_fmt=png" data-type="png" data-w="1176" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxZqXcPdWWicFRXoOAUmm7EKKPicPdzFug6C14duoslFAUg4z91xYltC6g/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Service 是一个抽象的概念，它定义了一组逻辑 Pods，并且提供访问它们的策略。和其他对象一样，Service 也能通过 kubectl 或者 YAML 创建。Service 定义的 Pod 可以写在 LabelSelector 选项中（下文会介绍），也存在不指定 Pods 的情况，这种比较复杂，感兴趣的读者可以自行查阅资料。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Service 有以下几种类型：</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<ul class=" list-paddingleft-2" style=""> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">ClusterIP（默认）：在集群中内部IP上暴露服务，此类型使Service只能从群集中访问；</span></p></li> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">NodePort：通过每个 Node 上的 IP 和静态端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求&nbsp;</span><span style="text-align: justify;font-size: 15px;color: rgb(62, 62, 62);">:</span> 
   <nodeport style="text-align: justify;"> 
    <span style="font-size: 15px;color: rgb(62, 62, 62);">，可以从集群的外部访问一个 NodePort 服务；</span> 
   </nodeport></p></li> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">LoadBalancer：使用云提供商的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务；</span></p></li> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">ExternalName：通过返回 CNAME 和它的值，（适用于外部 DNS 的场景）</span></p></li> 
</ul> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-ratio="0.9887218045112782" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxIpNoHVfC7oZFvWZyX4O4eefKMRibUC5Y8iaPqhT0KV5KOIy43lx6hang/640?wx_fmt=png" data-type="png" data-w="1064" style="border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxIpNoHVfC7oZFvWZyX4O4eefKMRibUC5Y8iaPqhT0KV5KOIy43lx6hang/640?wx_fmt=png"><span style="font-size: 15px;color: rgb(62, 62, 62);">&nbsp;</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Labels 和 Selectors 能够让 Kubernetes 拥有逻辑运算的能力，有点像 SQL。举个例子：可以查找 app=hello_word 的所有对象，也可以查找 app in (a,b,c) abc的所有对象。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Labels是一个绑定在对象上的 K/V 结构，它可以在创建或者之后的时候的定义，在任何时候都可以改变。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">扩容应用</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">前文提到我们可以使用 Deployment 增加实例个数，下图是原始的集群状态：&nbsp;</span></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-croporisrc="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxx9UU0KVFgJEcFic6dNXOhOA6vX7hXFSXiaGE5ZOLVzlmbTz0jSDUUvYw/640?wx_fmt=png" data-cropx1="78.82014388489209" data-cropx2="861.6474820143885" data-cropy1="75.23741007194245" data-cropy2="904.6402877697843" data-ratio="1.0587484035759898" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFx0wVSUibIPJJquVrtp1VXvAciblXGibuIdgKMuneZk2frLmKrmofriaPPlw/640?wx_fmt=jpeg" data-type="jpeg" data-w="783" style="height: 463px;border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;width: 437px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFx0wVSUibIPJJquVrtp1VXvAciblXGibuIdgKMuneZk2frLmKrmofriaPPlw/640?wx_fmt=jpeg"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">我们可以随意的更改 replicas （实例个数）来扩容，当我们更改了 Deployment 中的 replicas 值时，Kubernetes 会自动帮我们达到想要的目标实例个数，如下图：&nbsp;</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="" data-croporisrc="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxZxLZLZbJXabRO8YOnvy0allKOB5W4hEcKY416gYdsK3SWkYN8P212w/640?wx_fmt=png" data-cropx1="64.2841726618705" data-cropx2="840.9064748201439" data-cropy1="53.85971223021582" data-cropy2="882.6043165467626" data-ratio="1.068298969072165" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxQTOYibQqI7gsm8SXVTkvPCqkCkIRRCnQqiaRqgH1p16cTpyys0ZYSt8w/640?wx_fmt=jpeg" data-type="jpeg" data-w="776" style="height: 477px;border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;width: 447px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxQTOYibQqI7gsm8SXVTkvPCqkCkIRRCnQqiaRqgH1p16cTpyys0ZYSt8w/640?wx_fmt=jpeg"></p> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"></h3> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);"><br></span></strong></h3> 
<h3 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">更新应用</span></strong></h3> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">更新应用和扩容类似，我们可以更改 Deployment 中的容器镜像，然后 Kubernetes 会帮住我们应用更新（蓝绿、金丝雀等方式），通过此功能，我们还可以实现切换应用环境、回滚、不停机 CI/CD。下面是部署的过程，需要注意的是我们可以指定新创建的 Pod 最大个数和不可用 Pod 最大个数：</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">&nbsp;</span><img class="" data-croporisrc="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxGrsGDoAvcXgIjYnUWlicPLgHmBYHibnWgTxlDwrBqj8j6FviaqFdFcYFg/640?wx_fmt=png" data-cropx1="0" data-cropx2="1080" data-cropy1="69.92805755395683" data-cropy2="897.410071942446" data-ratio="0.7675925925925926" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxNsoPuRlswFqREMvcibCjxh6k99ArJKCebdKhvibZtCgw8ic2nAfqiasBbw/640?wx_fmt=jpeg" data-type="jpeg" data-w="1080" style="height: 426px;text-align: center;border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;width: 556px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxNsoPuRlswFqREMvcibCjxh6k99ArJKCebdKhvibZtCgw8ic2nAfqiasBbw/640?wx_fmt=jpeg"><img class="" data-ratio="0.783303730017762" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxpjUwWTnzrpBqWErJH9cF4fic6m0kl3icXfraRaU7tUF4yGvUWPZJL80g/640?wx_fmt=png" data-type="png" data-w="1126" style="text-align: center;border-width: 0px;border-style: initial;border-color: initial;vertical-align: middle;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4Ww02cPiccAOxNTUVgeUIhGFxpjUwWTnzrpBqWErJH9cF4fic6m0kl3icXfraRaU7tUF4yGvUWPZJL80g/640?wx_fmt=png"></p> 
<h2 style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="color: rgb(255, 129, 36);"><strong><span style="font-size: 15px;"><br></span></strong></span></h2> 
<h2 style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="color: rgb(255, 129, 36);"><strong><span style="font-size: 15px;">总结</span></strong></span></h2> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">到了最后，大家对 Kubernetes 有个大概的了解了，但 Kubernetes 远远不止本文所介绍的这些内容。在云原生概念逐渐清晰的今天，Kubernetes 作为 CNCF 中一个接地气的落地项目，其重要性不言而喻。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">最后，阿里云智能事业群，招聘2020年毕业的实习生和社招技术同学。团队主要聚焦在 Kubernetes、集群管理、自动化和云原生相关技术方向，负责阿里集团的监控和运维。有意者可以发简历到<strong> jianmin.hjm@alibaba-inc.com</strong>。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);"><br></span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);"><br></span></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.04907481898632341" data-type="gif" data-w="1243" width="auto" data-src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKLzTlj0XiaExO7CCIZrf95viarmPTV7zRp58LaaLlESZlOxNwA4nWbpTXfwnOmRWkeBVWcVU2r2pRg/640?wx_fmt=gif" style="box-sizing: border-box !important;word-wrap: break-word !important;visibility: visible !important;width: auto !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKLzTlj0XiaExO7CCIZrf95viarmPTV7zRp58LaaLlESZlOxNwA4nWbpTXfwnOmRWkeBVWcVU2r2pRg/640?wx_fmt=gif"></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);font-size: 14px;font-family: monospace;white-space: pre;text-align: center;line-height: 1.75em;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="color: rgb(136, 136, 136);font-size: 15px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">你可能还喜欢</strong></span></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);font-size: 14px;font-family: monospace;white-space: pre;text-align: center;line-height: 1.75em;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="color: rgb(136, 136, 136);font-size: 12px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">点击下方图片即可阅读</span></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247489919&amp;idx=2&amp;sn=d6d10acf20f31901df500de25443e74c&amp;chksm=e9292470de5ead665b0958f3e3f5d21a35c48d4ac1f5736bc3844a8f761741f195e4d7a3f831&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="1" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span class="js_jump_icon h5_image_link" data-positionback="static" style="line-height: 0;top: auto;left: auto;right: auto;bottom: auto;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="" data-croporisrc="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJQ235APPDhcrfz17HOCwiczDiaFNt18R5zicCkCLMiaw7V7MQ7REgvMkQpw2KdSMGqchXcLGU1ev9lbQ/0?wx_fmt=jpeg" data-cropx1="0" data-cropx2="1024" data-cropy1="40.517985611510795" data-cropy2="443.8561151079137" data-ratio="0.3935546875" data-s="300,640" data-type="jpeg" data-w="1024" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJQ235APPDhcrfz17HOCwiczjU9U9jKYF4RsNwdic5ZCBwpNDK1csT63xxGyWjQ0Uy4Q7PLjLB0gv4A/640?wx_fmt=jpeg" style="box-sizing: border-box !important;word-wrap: break-word !important;width: 556px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJQ235APPDhcrfz17HOCwiczjU9U9jKYF4RsNwdic5ZCBwpNDK1csT63xxGyWjQ0Uy4Q7PLjLB0gv4A/640?wx_fmt=jpeg"></span></a></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247489919&amp;idx=2&amp;sn=d6d10acf20f31901df500de25443e74c&amp;chksm=e9292470de5ead665b0958f3e3f5d21a35c48d4ac1f5736bc3844a8f761741f195e4d7a3f831&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="font-size: 14px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">阿里开源 OpenJDK 长期支持版本 Alibaba Dragonwell</span></a><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247489740&amp;idx=1&amp;sn=f72d222f3bfddeca551850b2e1b046a0&amp;chksm=e92925c3de5eacd518748221c2a7d2aae91ae8472701b610f7288c73eafae785a50c9f8b2d3a&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="1" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span class="js_jump_icon h5_image_link" data-positionback="static" style="line-height: 0;top: auto;left: auto;right: auto;bottom: auto;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="" data-croporisrc="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naI754NfnjAt7Sz8stkCZpicNsltSicHT9s1Wyvfe4HDBOT3X4fUmtqiaV8G05lmz3nS8fjU0QyTHjFGA/0?wx_fmt=jpeg" data-cropx1="0" data-cropx2="1072" data-cropy1="32.776978417266186" data-cropy2="495.51079136690646" data-ratio="0.43283582089552236" data-s="300,640" data-type="jpeg" data-w="1072" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naIKsOGV4BOoB2LiaOrsPxoe74rSKAyHQqibs0rCVAz4dMFmztBK1P9dsRVJ2B53kc2IR4nEViascg98w/640?wx_fmt=jpeg" style="top: auto;left: auto;right: auto;bottom: auto;box-sizing: border-box !important;word-wrap: break-word !important;width: 556px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naIKsOGV4BOoB2LiaOrsPxoe74rSKAyHQqibs0rCVAz4dMFmztBK1P9dsRVJ2B53kc2IR4nEViascg98w/640?wx_fmt=jpeg"></span></a></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);font-size: 14px;font-family: monospace;white-space: pre;text-align: center;line-height: 1.75em;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247489740&amp;idx=1&amp;sn=f72d222f3bfddeca551850b2e1b046a0&amp;chksm=e92925c3de5eacd518748221c2a7d2aae91ae8472701b610f7288c73eafae785a50c9f8b2d3a&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">为拯救爸妈朋友圈，达摩院造了“谣言粉碎机”</a></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);font-size: 14px;font-family: monospace;white-space: pre;text-align: center;line-height: 1.75em;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247489852&amp;idx=1&amp;sn=6b94d16927eb89fdda103cbae991a50d&amp;chksm=e9292433de5ead2530474a236a02b5d66741e20def6d95e89bede2a3a2d23181ad0243f63d59&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="1" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span class="js_jump_icon h5_image_link" data-positionback="static" style="line-height: 0;top: auto;left: auto;right: auto;bottom: auto;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="" data-backh="255" data-backw="556" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLKic1egJxjceV3fxYy7SsKWffsRy23sYQU26XGWBiaLHwOnEicbxa1C77bsvWenQI1KHiccEJQDGRlEA/640?wx_fmt=jpeg" data-copyright="0" data-ratio="0.4582463465553236" data-s="300,640" data-type="jpeg" data-w="958" width="100%" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLKic1egJxjceV3fxYy7SsKWffsRy23sYQU26XGWBiaLHwOnEicbxa1C77bsvWenQI1KHiccEJQDGRlEA/640?wx_fmt=jpeg" style="box-sizing: border-box !important;word-wrap: break-word !important;width: 100% !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLKic1egJxjceV3fxYy7SsKWffsRy23sYQU26XGWBiaLHwOnEicbxa1C77bsvWenQI1KHiccEJQDGRlEA/640?wx_fmt=jpeg"></span></a></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247489852&amp;idx=1&amp;sn=6b94d16927eb89fdda103cbae991a50d&amp;chksm=e9292433de5ead2530474a236a02b5d66741e20def6d95e89bede2a3a2d23181ad0243f63d59&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="font-size: 14px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">阿里巴巴2019实习生招聘正式启动！</span></a><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="__bg_gif " data-copyright="0" data-ratio="1.0616740088105727" data-type="gif" data-w="454" width="253px" data-src="https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naKcJeVLrERoBcjILPJtnWgOAsnKJ8RVuvGo7DPusIGvV4iauQEEAUlh9GyGu7ZZX9XqOCPOGiaUdXVg/640?wx_fmt=gif" style="box-sizing: border-box !important;word-wrap: break-word !important;width: 253px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naKcJeVLrERoBcjILPJtnWgOAsnKJ8RVuvGo7DPusIGvV4iauQEEAUlh9GyGu7ZZX9XqOCPOGiaUdXVg/640?wx_fmt=gif"></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
