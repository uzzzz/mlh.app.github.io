<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>【基本功】Java魔法类：Unsafe应用解析 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="【基本功】Java魔法类：Unsafe应用解析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="总第334篇 2019年 第12篇 大家好，我是程序员鼓励师美美～ 《基本功》专栏又上新了：Java中的Unsafe类在提升运行效率、增强底层资源操作能力方面有很大的用处。但如果在开发过程中使用不当，就会出现各种“莫名其妙”的问题。 本篇文章将会带领你重新认识它，绕过“开发雷区”，猪事大吉。 Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。 本文对sun.misc.Unsafe公共API功能及相关应用场景进行介绍。 基本介绍 如下Unsafe源码所示，Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常。 public&nbsp;final&nbsp;class&nbsp;Unsafe&nbsp;{&nbsp;&nbsp;//&nbsp;单例对象&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;Unsafe&nbsp;theUnsafe;&nbsp;&nbsp;private&nbsp;Unsafe()&nbsp;{&nbsp;&nbsp;}&nbsp;&nbsp;@CallerSensitive&nbsp;&nbsp;public&nbsp;static&nbsp;Unsafe&nbsp;getUnsafe()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Class&nbsp;var0&nbsp;=&nbsp;Reflection.getCallerClass();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;仅在引导类加载器`BootstrapClassLoader`加载时才合法&nbsp;&nbsp;&nbsp;&nbsp;if(!VM.isSystemDomainLoader(var0.getClassLoader()))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;SecurityException(&quot;Unsafe&quot;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;theUnsafe;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 那如若想使用这个类，该如何获取其实例？有如下两个可行方案。 其一，从getUnsafe方法的使用限制条件出发，通过Java命令行命令-Xbootclasspath/a把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例。 java&nbsp;-Xbootclasspath/a:&nbsp;${path}&nbsp;&nbsp;&nbsp;//&nbsp;其中path为调用Unsafe相关方法的类所在jar包路径&nbsp; 其二，通过反射获取单例对象theUnsafe。 private&nbsp;static&nbsp;Unsafe&nbsp;reflectGetUnsafe()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Field&nbsp;field&nbsp;=&nbsp;Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field.setAccessible(true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(Unsafe)&nbsp;field.get(null);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error(e.getMessage(),&nbsp;e);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;}} 功能介绍 如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。 内存操作 这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。 //分配内存,&nbsp;相当于C++的malloc函数public&nbsp;native&nbsp;long&nbsp;allocateMemory(long&nbsp;bytes);//扩充内存public&nbsp;native&nbsp;long&nbsp;reallocateMemory(long&nbsp;address,&nbsp;long&nbsp;bytes);//释放内存public&nbsp;native&nbsp;void&nbsp;freeMemory(long&nbsp;address);//在给定的内存块中设置值public&nbsp;native&nbsp;void&nbsp;setMemory(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;long&nbsp;bytes,&nbsp;byte&nbsp;value);//内存拷贝public&nbsp;native&nbsp;void&nbsp;copyMemory(Object&nbsp;srcBase,&nbsp;long&nbsp;srcOffset,&nbsp;Object&nbsp;destBase,&nbsp;long&nbsp;destOffset,&nbsp;long&nbsp;bytes);//获取给定地址值，忽略修饰限定符的限制访问限制。与此类似操作还有:&nbsp;getInt，getDouble，getLong，getChar等public&nbsp;native&nbsp;Object&nbsp;getObject(Object&nbsp;o,&nbsp;long&nbsp;offset);//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有:&nbsp;putInt,putDouble，putLong，putChar等public&nbsp;native&nbsp;void&nbsp;putObject(Object&nbsp;o,&nbsp;long&nbsp;offset, Object x);//获取给定地址的byte类型的值(当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的)public&nbsp;native&nbsp;byte&nbsp;getByte(long&nbsp;address);//为给定地址设置byte类型的值(当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的)public&nbsp;native&nbsp;void&nbsp;putByte(long&nbsp;address,&nbsp;byte&nbsp;x); 通常，我们在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。 使用堆外内存的原因 对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模，从而在GC时减少回收停顿对于应用的影响。 提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。 典型应用 DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。 下图为DirectByteBuffer构造函数，创建DirectByteBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放。 那么如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？ Cleaner继承自Java四大引用类型之一的虚引用PhantomReference（众所周知，无法通过虚引用获取与之关联的对象实例，且当对象仅被虚引用引用时，在任何发生GC的时候，其均可被回收），通常PhantomReference与引用队列ReferenceQueue结合使用，可以实现虚引用关联对象被垃圾回收时能够进行系统通知、资源清理等功能。如下图所示，当某个被Cleaner引用的对象将被回收时，JVM垃圾收集器会将此对象的引用放入到对象引用中的pending链表中，等待Reference-Handler进行相关处理。其中，Reference-Handler为一个拥有最高优先级的守护线程，会循环不断的处理pending链表中的对象引用，执行Cleaner的clean方法进行相关清理工作。 所以当DirectByteBuffer仅被Cleaner引用（即为虚引用）时，其可以在任意GC时段被回收。当DirectByteBuffer实例对象被回收时，在Reference-Handler线程操作中，会调用Cleaner的clean方法根据创建Cleaner时传入的Deallocator来进行堆外内存的释放。 CAS相关 如下源代码释义所示，这部分主要为CAS相关操作的方法。 /**&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;CAS&nbsp;&nbsp;*&nbsp;@param&nbsp;o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含要修改field的对象&nbsp;&nbsp;*&nbsp;@param&nbsp;offset&nbsp;&nbsp;&nbsp;&nbsp;对象中某field的偏移量&nbsp;&nbsp;*&nbsp;@param&nbsp;expected&nbsp;&nbsp;期望值&nbsp;&nbsp;*&nbsp;@param&nbsp;update&nbsp;&nbsp;&nbsp;&nbsp;更新值&nbsp;&nbsp;*&nbsp;@return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true&nbsp;|&nbsp;false&nbsp;&nbsp;*/public&nbsp;final&nbsp;native&nbsp;boolean&nbsp;compareAndSwapObject(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;&nbsp;Object&nbsp;expected,&nbsp;Object&nbsp;update);public&nbsp;final&nbsp;native&nbsp;boolean&nbsp;compareAndSwapInt(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;int&nbsp;expected,int&nbsp;update);public&nbsp;final&nbsp;native&nbsp;boolean&nbsp;compareAndSwapLong(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;long&nbsp;expected,&nbsp;long&nbsp;update); 什么是CAS? 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。 典型应用 CAS在java.util.concurrent.atomic相关类、Java AQS、CurrentHashMap等实现上有非常广泛的应用。如下图所示，AtomicInteger的实现中，静态字段valueOffset即为字段value的内存偏移地址，valueOffset的值在AtomicInteger初始化时，在静态代码块中通过Unsafe的objectFieldOffset方法获取。在AtomicInteger中提供的线程安全方法中，通过字段valueOffset的值可以定位到AtomicInteger对象中value的内存地址，从而可以根据CAS实现对value字段的原子操作。 下图为某个AtomicInteger对象自增操作前后的内存示意图，对象的基地址baseAddress=&quot;0x110000&quot;，通过baseAddress+valueOffset得到value的内存地址valueAddress=&quot;0x11000c&quot;；然后通过CAS进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功为止。 线程调度 这部分，包括线程挂起、恢复、锁机制等方法。 //取消阻塞线程public&nbsp;native&nbsp;void&nbsp;unpark(Object&nbsp;thread);//阻塞线程public&nbsp;native&nbsp;void&nbsp;park(boolean&nbsp;isAbsolute,&nbsp;long&nbsp;time);//获得对象锁（可重入锁）@Deprecatedpublic&nbsp;native&nbsp;void&nbsp;monitorEnter(Object&nbsp;o);//释放对象锁@Deprecatedpublic&nbsp;native&nbsp;void&nbsp;monitorExit(Object&nbsp;o);//尝试获取对象锁@Deprecatedpublic&nbsp;native&nbsp;boolean&nbsp;tryMonitorEnter(Object&nbsp;o); 如上源码说明中，方法park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark可以终止一个挂起的线程，使其恢复正常。 典型应用 Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。 Class相关 此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等。 //获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的public&nbsp;native&nbsp;long&nbsp;staticFieldOffset(Field&nbsp;f);//获取一个静态类中给定字段的对象指针public&nbsp;native&nbsp;Object&nbsp;staticFieldBase(Field&nbsp;f);//判断是否需要初始化一个类，通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。&nbsp;此方法当且仅当ensureClassInitialized方法不生效的时候才返回false。public&nbsp;native&nbsp;boolean&nbsp;shouldBeInitialized(Class&lt;?&gt;&nbsp;c);//检测给定的类是否已经初始化。通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。public&nbsp;native&nbsp;void&nbsp;ensureClassInitialized(Class&lt;?&gt;&nbsp;c);//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader(类加载器)和ProtectionDomain(保护域)实例来源于调用者public&nbsp;native&nbsp;Class&lt;?&gt;&nbsp;defineClass(String&nbsp;name,&nbsp;byte[]&nbsp;b,&nbsp;int&nbsp;off,&nbsp;int&nbsp;len,&nbsp;ClassLoader&nbsp;loader,&nbsp;ProtectionDomain&nbsp;protectionDomain);//定义一个匿名类public&nbsp;native&nbsp;Class&lt;?&gt;&nbsp;defineAnonymousClass(Class&lt;?&gt;&nbsp;hostClass,&nbsp;byte[]&nbsp;data,&nbsp;Object[]&nbsp;cpPatches); 典型应用 从Java 8开始，JDK使用invokedynamic及VM Anonymous Class结合来实现Java语言层面上的Lambda表达式。 invokedynamic： invokedynamic是Java 7为了实现在JVM上运行动态语言而引入的一条新的虚拟机指令，它可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic指令的分派逻辑是由用户设定的引导方法决定。 VM Anonymous Class：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过Unsafe.defineAnonymousClass方法定义具体类时填充模板的占位符生成具体的匿名类。生成的匿名类不显式挂在任何ClassLoader下面，只要当该类没有存在的实例对象、且没有强引用来引用该类的Class对象时，该类就会被GC回收。故而VM Anonymous Class相比于Java语言层面的匿名内部类无需通过ClassClassLoader进行类加载且更易回收。 在Lambda表达式实现中，通过invokedynamic指令调用引导方法生成调用点，在此过程中，会通过ASM动态生成字节码，而后利用Unsafe的defineAnonymousClass方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应Lambda表达式定义逻辑的功能。下面以如下图所示的Test类来举例说明。 Test类编译后的class文件反编译后的结果如下图一所示（删除了对本文说明无意义的部分），我们可以从中看到main方法的指令实现、invokedynamic指令调用的引导方法BootstrapMethods、及静态方法lambda$main$0（实现了Lambda表达式中字符串打印逻辑）等。在引导方法执行过程中，会通过Unsafe.defineAnonymousClass生成如下图二所示的实现Consumer接口的匿名类。其中，accept方法通过调用Test类中的静态方法lambda$main$0来实现Lambda表达式中定义的逻辑。而后执行语句consumer.accept（&quot;lambda&quot;）其实就是调用下图二所示的匿名类的accept方法。 对象操作 此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。 //返回对象成员属性在内存地址相对于此对象的内存地址的偏移量public&nbsp;native&nbsp;long&nbsp;objectFieldOffset(Field&nbsp;f);//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等public&nbsp;native&nbsp;Object&nbsp;getObject(Object&nbsp;o,&nbsp;long&nbsp;offset);//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等public&nbsp;native&nbsp;void&nbsp;putObject(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;Object&nbsp;x);//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义public&nbsp;native&nbsp;Object&nbsp;getObjectVolatile(Object&nbsp;o,&nbsp;long&nbsp;offset);//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义public&nbsp;native&nbsp;void&nbsp;putObjectVolatile(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;Object&nbsp;x);//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效public&nbsp;native&nbsp;void&nbsp;putOrderedObject(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;Object&nbsp;x);//绕过构造方法、初始化代码来创建对象public&nbsp;native&nbsp;Object&nbsp;allocateInstance(Class&lt;?&gt;&nbsp;cls)&nbsp;throws&nbsp;InstantiationException; 典型应用 常规对象实例化方式：我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。 非常规的实例化方式：而Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。 如下图所示，在Gson反序列化时，如果类有默认构造函数，则通过反射调用默认构造函数创建实例，否则通过UnsafeAllocator来实现对象实例的构造，UnsafeAllocator通过调用Unsafe的allocateInstance实现对象的实例化，保证在目标类无默认构造函数时，反序列化不够影响。 数组相关 这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。 //返回数组中第一个元素的偏移地址public&nbsp;native&nbsp;int&nbsp;arrayBaseOffset(Class&lt;?&gt;&nbsp;arrayClass);//返回数组中一个元素占用的大小public&nbsp;native&nbsp;int&nbsp;arrayIndexScale(Class&lt;?&gt;&nbsp;arrayClass); 典型应用 这两个与数据操作相关的方法，在java.util.concurrent.atomic 包下的AtomicIntegerArray（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用，如下图AtomicIntegerArray源码所示，通过Unsafe的arrayBaseOffset、arrayIndexScale分别获取数组首元素的偏移地址base及单个元素大小因子scale。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的getAndAdd方法即通过checkedByteOffset方法获取某数组元素的偏移地址，而后通过CAS实现原子性操作。 内存屏障 在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。 //内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前public&nbsp;native&nbsp;void&nbsp;loadFence();//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前public&nbsp;native&nbsp;void&nbsp;storeFence();//内存屏障，禁止load、store操作重排序public&nbsp;native&nbsp;void&nbsp;fullFence(); 典型应用 在Java 8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性。 如上图用例所示计算坐标点Point对象，包含点移动方法move及计算此点到原点的距离的方法distanceFromOrigin。在方法distanceFromOrigin中，首先，通过tryOptimisticRead方法获取乐观读标记；然后从主内存中加载点的坐标值 (x,y)；而后通过StampedLock的validate方法校验锁状态，判断坐标点(x,y)从主内存加载到线程工作内存过程中，主内存的值是否已被其他线程通过move方法修改，如果validate返回值为true，证明(x, y)的值未被修改，可参与后续计算；否则，需加悲观读锁，再次从主内存加载(x,y)的最新值，然后再进行距离计算。其中，校验锁状态这步操作至关重要，需要判断锁状态是否发生改变，从而判断之前copy到线程工作内存中的值是否与主内存的值存在不一致。 下图为StampedLock.validate方法的源码实现，通过锁标记与相关常量进行位运算、比较来校验锁状态，在校验逻辑之前，会通过Unsafe的loadFence方法加入一个load内存屏障，目的是避免上图用例中步骤②和StampedLock.validate中锁状态校验运算发生重排序导致锁状态校验不准确的问题。 系统相关 这部分包含两个获取系统相关信息的方法。 //返回系统指针的大小。返回值为4（32位系统）或8（64位系统）。public&nbsp;native&nbsp;int&nbsp;addressSize();&nbsp;&nbsp;//内存页的大小，此值为2的幂次方。public&nbsp;native&nbsp;int&nbsp;pageSize(); 典型应用 如下图所示的代码片段，为java.nio下的工具类Bits中计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑。 结语 本文对Java中的sun.misc.Unsafe的用法及应用场景进行了基本介绍，我们可以看到Unsafe提供了很多便捷、有趣的API方法。即便如此，由于Unsafe中包含大量自主操作内存的方法，如若使用不当，会对程序带来许多不可控的灾难。因此对它的使用我们需要慎之又慎。 参考资料 OpenJDK Unsafe source Java Magic. Part 4: sun.misc.Unsafe JVM crashes at libjvm.so Java中神奇的双刃剑--Unsafe JVM源码分析之堆外内存完全解读 堆外内存 之 DirectByteBuffer 详解 《深入理解Java虚拟机（第2版）》 作者简介 璐璐，美团点评Java开发工程师。2017年加入美团点评，负责美团点评境内度假的后端开发。 欢迎加入美团Java技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：Java，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 不可不说的Java“锁”事 红黑树深入剖析及Java实现 从实际案例聊聊Java应用的GC优化" />
<meta property="og:description" content="总第334篇 2019年 第12篇 大家好，我是程序员鼓励师美美～ 《基本功》专栏又上新了：Java中的Unsafe类在提升运行效率、增强底层资源操作能力方面有很大的用处。但如果在开发过程中使用不当，就会出现各种“莫名其妙”的问题。 本篇文章将会带领你重新认识它，绕过“开发雷区”，猪事大吉。 Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。 本文对sun.misc.Unsafe公共API功能及相关应用场景进行介绍。 基本介绍 如下Unsafe源码所示，Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常。 public&nbsp;final&nbsp;class&nbsp;Unsafe&nbsp;{&nbsp;&nbsp;//&nbsp;单例对象&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;Unsafe&nbsp;theUnsafe;&nbsp;&nbsp;private&nbsp;Unsafe()&nbsp;{&nbsp;&nbsp;}&nbsp;&nbsp;@CallerSensitive&nbsp;&nbsp;public&nbsp;static&nbsp;Unsafe&nbsp;getUnsafe()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Class&nbsp;var0&nbsp;=&nbsp;Reflection.getCallerClass();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;仅在引导类加载器`BootstrapClassLoader`加载时才合法&nbsp;&nbsp;&nbsp;&nbsp;if(!VM.isSystemDomainLoader(var0.getClassLoader()))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;SecurityException(&quot;Unsafe&quot;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;theUnsafe;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 那如若想使用这个类，该如何获取其实例？有如下两个可行方案。 其一，从getUnsafe方法的使用限制条件出发，通过Java命令行命令-Xbootclasspath/a把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例。 java&nbsp;-Xbootclasspath/a:&nbsp;${path}&nbsp;&nbsp;&nbsp;//&nbsp;其中path为调用Unsafe相关方法的类所在jar包路径&nbsp; 其二，通过反射获取单例对象theUnsafe。 private&nbsp;static&nbsp;Unsafe&nbsp;reflectGetUnsafe()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Field&nbsp;field&nbsp;=&nbsp;Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field.setAccessible(true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(Unsafe)&nbsp;field.get(null);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error(e.getMessage(),&nbsp;e);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;}} 功能介绍 如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。 内存操作 这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。 //分配内存,&nbsp;相当于C++的malloc函数public&nbsp;native&nbsp;long&nbsp;allocateMemory(long&nbsp;bytes);//扩充内存public&nbsp;native&nbsp;long&nbsp;reallocateMemory(long&nbsp;address,&nbsp;long&nbsp;bytes);//释放内存public&nbsp;native&nbsp;void&nbsp;freeMemory(long&nbsp;address);//在给定的内存块中设置值public&nbsp;native&nbsp;void&nbsp;setMemory(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;long&nbsp;bytes,&nbsp;byte&nbsp;value);//内存拷贝public&nbsp;native&nbsp;void&nbsp;copyMemory(Object&nbsp;srcBase,&nbsp;long&nbsp;srcOffset,&nbsp;Object&nbsp;destBase,&nbsp;long&nbsp;destOffset,&nbsp;long&nbsp;bytes);//获取给定地址值，忽略修饰限定符的限制访问限制。与此类似操作还有:&nbsp;getInt，getDouble，getLong，getChar等public&nbsp;native&nbsp;Object&nbsp;getObject(Object&nbsp;o,&nbsp;long&nbsp;offset);//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有:&nbsp;putInt,putDouble，putLong，putChar等public&nbsp;native&nbsp;void&nbsp;putObject(Object&nbsp;o,&nbsp;long&nbsp;offset, Object x);//获取给定地址的byte类型的值(当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的)public&nbsp;native&nbsp;byte&nbsp;getByte(long&nbsp;address);//为给定地址设置byte类型的值(当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的)public&nbsp;native&nbsp;void&nbsp;putByte(long&nbsp;address,&nbsp;byte&nbsp;x); 通常，我们在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。 使用堆外内存的原因 对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模，从而在GC时减少回收停顿对于应用的影响。 提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。 典型应用 DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。 下图为DirectByteBuffer构造函数，创建DirectByteBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放。 那么如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？ Cleaner继承自Java四大引用类型之一的虚引用PhantomReference（众所周知，无法通过虚引用获取与之关联的对象实例，且当对象仅被虚引用引用时，在任何发生GC的时候，其均可被回收），通常PhantomReference与引用队列ReferenceQueue结合使用，可以实现虚引用关联对象被垃圾回收时能够进行系统通知、资源清理等功能。如下图所示，当某个被Cleaner引用的对象将被回收时，JVM垃圾收集器会将此对象的引用放入到对象引用中的pending链表中，等待Reference-Handler进行相关处理。其中，Reference-Handler为一个拥有最高优先级的守护线程，会循环不断的处理pending链表中的对象引用，执行Cleaner的clean方法进行相关清理工作。 所以当DirectByteBuffer仅被Cleaner引用（即为虚引用）时，其可以在任意GC时段被回收。当DirectByteBuffer实例对象被回收时，在Reference-Handler线程操作中，会调用Cleaner的clean方法根据创建Cleaner时传入的Deallocator来进行堆外内存的释放。 CAS相关 如下源代码释义所示，这部分主要为CAS相关操作的方法。 /**&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;CAS&nbsp;&nbsp;*&nbsp;@param&nbsp;o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含要修改field的对象&nbsp;&nbsp;*&nbsp;@param&nbsp;offset&nbsp;&nbsp;&nbsp;&nbsp;对象中某field的偏移量&nbsp;&nbsp;*&nbsp;@param&nbsp;expected&nbsp;&nbsp;期望值&nbsp;&nbsp;*&nbsp;@param&nbsp;update&nbsp;&nbsp;&nbsp;&nbsp;更新值&nbsp;&nbsp;*&nbsp;@return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true&nbsp;|&nbsp;false&nbsp;&nbsp;*/public&nbsp;final&nbsp;native&nbsp;boolean&nbsp;compareAndSwapObject(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;&nbsp;Object&nbsp;expected,&nbsp;Object&nbsp;update);public&nbsp;final&nbsp;native&nbsp;boolean&nbsp;compareAndSwapInt(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;int&nbsp;expected,int&nbsp;update);public&nbsp;final&nbsp;native&nbsp;boolean&nbsp;compareAndSwapLong(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;long&nbsp;expected,&nbsp;long&nbsp;update); 什么是CAS? 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。 典型应用 CAS在java.util.concurrent.atomic相关类、Java AQS、CurrentHashMap等实现上有非常广泛的应用。如下图所示，AtomicInteger的实现中，静态字段valueOffset即为字段value的内存偏移地址，valueOffset的值在AtomicInteger初始化时，在静态代码块中通过Unsafe的objectFieldOffset方法获取。在AtomicInteger中提供的线程安全方法中，通过字段valueOffset的值可以定位到AtomicInteger对象中value的内存地址，从而可以根据CAS实现对value字段的原子操作。 下图为某个AtomicInteger对象自增操作前后的内存示意图，对象的基地址baseAddress=&quot;0x110000&quot;，通过baseAddress+valueOffset得到value的内存地址valueAddress=&quot;0x11000c&quot;；然后通过CAS进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功为止。 线程调度 这部分，包括线程挂起、恢复、锁机制等方法。 //取消阻塞线程public&nbsp;native&nbsp;void&nbsp;unpark(Object&nbsp;thread);//阻塞线程public&nbsp;native&nbsp;void&nbsp;park(boolean&nbsp;isAbsolute,&nbsp;long&nbsp;time);//获得对象锁（可重入锁）@Deprecatedpublic&nbsp;native&nbsp;void&nbsp;monitorEnter(Object&nbsp;o);//释放对象锁@Deprecatedpublic&nbsp;native&nbsp;void&nbsp;monitorExit(Object&nbsp;o);//尝试获取对象锁@Deprecatedpublic&nbsp;native&nbsp;boolean&nbsp;tryMonitorEnter(Object&nbsp;o); 如上源码说明中，方法park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark可以终止一个挂起的线程，使其恢复正常。 典型应用 Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。 Class相关 此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等。 //获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的public&nbsp;native&nbsp;long&nbsp;staticFieldOffset(Field&nbsp;f);//获取一个静态类中给定字段的对象指针public&nbsp;native&nbsp;Object&nbsp;staticFieldBase(Field&nbsp;f);//判断是否需要初始化一个类，通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。&nbsp;此方法当且仅当ensureClassInitialized方法不生效的时候才返回false。public&nbsp;native&nbsp;boolean&nbsp;shouldBeInitialized(Class&lt;?&gt;&nbsp;c);//检测给定的类是否已经初始化。通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。public&nbsp;native&nbsp;void&nbsp;ensureClassInitialized(Class&lt;?&gt;&nbsp;c);//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader(类加载器)和ProtectionDomain(保护域)实例来源于调用者public&nbsp;native&nbsp;Class&lt;?&gt;&nbsp;defineClass(String&nbsp;name,&nbsp;byte[]&nbsp;b,&nbsp;int&nbsp;off,&nbsp;int&nbsp;len,&nbsp;ClassLoader&nbsp;loader,&nbsp;ProtectionDomain&nbsp;protectionDomain);//定义一个匿名类public&nbsp;native&nbsp;Class&lt;?&gt;&nbsp;defineAnonymousClass(Class&lt;?&gt;&nbsp;hostClass,&nbsp;byte[]&nbsp;data,&nbsp;Object[]&nbsp;cpPatches); 典型应用 从Java 8开始，JDK使用invokedynamic及VM Anonymous Class结合来实现Java语言层面上的Lambda表达式。 invokedynamic： invokedynamic是Java 7为了实现在JVM上运行动态语言而引入的一条新的虚拟机指令，它可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic指令的分派逻辑是由用户设定的引导方法决定。 VM Anonymous Class：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过Unsafe.defineAnonymousClass方法定义具体类时填充模板的占位符生成具体的匿名类。生成的匿名类不显式挂在任何ClassLoader下面，只要当该类没有存在的实例对象、且没有强引用来引用该类的Class对象时，该类就会被GC回收。故而VM Anonymous Class相比于Java语言层面的匿名内部类无需通过ClassClassLoader进行类加载且更易回收。 在Lambda表达式实现中，通过invokedynamic指令调用引导方法生成调用点，在此过程中，会通过ASM动态生成字节码，而后利用Unsafe的defineAnonymousClass方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应Lambda表达式定义逻辑的功能。下面以如下图所示的Test类来举例说明。 Test类编译后的class文件反编译后的结果如下图一所示（删除了对本文说明无意义的部分），我们可以从中看到main方法的指令实现、invokedynamic指令调用的引导方法BootstrapMethods、及静态方法lambda$main$0（实现了Lambda表达式中字符串打印逻辑）等。在引导方法执行过程中，会通过Unsafe.defineAnonymousClass生成如下图二所示的实现Consumer接口的匿名类。其中，accept方法通过调用Test类中的静态方法lambda$main$0来实现Lambda表达式中定义的逻辑。而后执行语句consumer.accept（&quot;lambda&quot;）其实就是调用下图二所示的匿名类的accept方法。 对象操作 此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。 //返回对象成员属性在内存地址相对于此对象的内存地址的偏移量public&nbsp;native&nbsp;long&nbsp;objectFieldOffset(Field&nbsp;f);//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等public&nbsp;native&nbsp;Object&nbsp;getObject(Object&nbsp;o,&nbsp;long&nbsp;offset);//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等public&nbsp;native&nbsp;void&nbsp;putObject(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;Object&nbsp;x);//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义public&nbsp;native&nbsp;Object&nbsp;getObjectVolatile(Object&nbsp;o,&nbsp;long&nbsp;offset);//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义public&nbsp;native&nbsp;void&nbsp;putObjectVolatile(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;Object&nbsp;x);//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效public&nbsp;native&nbsp;void&nbsp;putOrderedObject(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;Object&nbsp;x);//绕过构造方法、初始化代码来创建对象public&nbsp;native&nbsp;Object&nbsp;allocateInstance(Class&lt;?&gt;&nbsp;cls)&nbsp;throws&nbsp;InstantiationException; 典型应用 常规对象实例化方式：我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。 非常规的实例化方式：而Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。 如下图所示，在Gson反序列化时，如果类有默认构造函数，则通过反射调用默认构造函数创建实例，否则通过UnsafeAllocator来实现对象实例的构造，UnsafeAllocator通过调用Unsafe的allocateInstance实现对象的实例化，保证在目标类无默认构造函数时，反序列化不够影响。 数组相关 这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。 //返回数组中第一个元素的偏移地址public&nbsp;native&nbsp;int&nbsp;arrayBaseOffset(Class&lt;?&gt;&nbsp;arrayClass);//返回数组中一个元素占用的大小public&nbsp;native&nbsp;int&nbsp;arrayIndexScale(Class&lt;?&gt;&nbsp;arrayClass); 典型应用 这两个与数据操作相关的方法，在java.util.concurrent.atomic 包下的AtomicIntegerArray（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用，如下图AtomicIntegerArray源码所示，通过Unsafe的arrayBaseOffset、arrayIndexScale分别获取数组首元素的偏移地址base及单个元素大小因子scale。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的getAndAdd方法即通过checkedByteOffset方法获取某数组元素的偏移地址，而后通过CAS实现原子性操作。 内存屏障 在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。 //内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前public&nbsp;native&nbsp;void&nbsp;loadFence();//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前public&nbsp;native&nbsp;void&nbsp;storeFence();//内存屏障，禁止load、store操作重排序public&nbsp;native&nbsp;void&nbsp;fullFence(); 典型应用 在Java 8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性。 如上图用例所示计算坐标点Point对象，包含点移动方法move及计算此点到原点的距离的方法distanceFromOrigin。在方法distanceFromOrigin中，首先，通过tryOptimisticRead方法获取乐观读标记；然后从主内存中加载点的坐标值 (x,y)；而后通过StampedLock的validate方法校验锁状态，判断坐标点(x,y)从主内存加载到线程工作内存过程中，主内存的值是否已被其他线程通过move方法修改，如果validate返回值为true，证明(x, y)的值未被修改，可参与后续计算；否则，需加悲观读锁，再次从主内存加载(x,y)的最新值，然后再进行距离计算。其中，校验锁状态这步操作至关重要，需要判断锁状态是否发生改变，从而判断之前copy到线程工作内存中的值是否与主内存的值存在不一致。 下图为StampedLock.validate方法的源码实现，通过锁标记与相关常量进行位运算、比较来校验锁状态，在校验逻辑之前，会通过Unsafe的loadFence方法加入一个load内存屏障，目的是避免上图用例中步骤②和StampedLock.validate中锁状态校验运算发生重排序导致锁状态校验不准确的问题。 系统相关 这部分包含两个获取系统相关信息的方法。 //返回系统指针的大小。返回值为4（32位系统）或8（64位系统）。public&nbsp;native&nbsp;int&nbsp;addressSize();&nbsp;&nbsp;//内存页的大小，此值为2的幂次方。public&nbsp;native&nbsp;int&nbsp;pageSize(); 典型应用 如下图所示的代码片段，为java.nio下的工具类Bits中计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑。 结语 本文对Java中的sun.misc.Unsafe的用法及应用场景进行了基本介绍，我们可以看到Unsafe提供了很多便捷、有趣的API方法。即便如此，由于Unsafe中包含大量自主操作内存的方法，如若使用不当，会对程序带来许多不可控的灾难。因此对它的使用我们需要慎之又慎。 参考资料 OpenJDK Unsafe source Java Magic. Part 4: sun.misc.Unsafe JVM crashes at libjvm.so Java中神奇的双刃剑--Unsafe JVM源码分析之堆外内存完全解读 堆外内存 之 DirectByteBuffer 详解 《深入理解Java虚拟机（第2版）》 作者简介 璐璐，美团点评Java开发工程师。2017年加入美团点评，负责美团点评境内度假的后端开发。 欢迎加入美团Java技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：Java，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 不可不说的Java“锁”事 红黑树深入剖析及Java实现 从实际案例聊聊Java应用的GC优化" />
<link rel="canonical" href="https://mlh.app/2019/04/29/729120.html" />
<meta property="og:url" content="https://mlh.app/2019/04/29/729120.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"总第334篇 2019年 第12篇 大家好，我是程序员鼓励师美美～ 《基本功》专栏又上新了：Java中的Unsafe类在提升运行效率、增强底层资源操作能力方面有很大的用处。但如果在开发过程中使用不当，就会出现各种“莫名其妙”的问题。 本篇文章将会带领你重新认识它，绕过“开发雷区”，猪事大吉。 Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。 本文对sun.misc.Unsafe公共API功能及相关应用场景进行介绍。 基本介绍 如下Unsafe源码所示，Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常。 public&nbsp;final&nbsp;class&nbsp;Unsafe&nbsp;{&nbsp;&nbsp;//&nbsp;单例对象&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;Unsafe&nbsp;theUnsafe;&nbsp;&nbsp;private&nbsp;Unsafe()&nbsp;{&nbsp;&nbsp;}&nbsp;&nbsp;@CallerSensitive&nbsp;&nbsp;public&nbsp;static&nbsp;Unsafe&nbsp;getUnsafe()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Class&nbsp;var0&nbsp;=&nbsp;Reflection.getCallerClass();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;仅在引导类加载器`BootstrapClassLoader`加载时才合法&nbsp;&nbsp;&nbsp;&nbsp;if(!VM.isSystemDomainLoader(var0.getClassLoader()))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;SecurityException(&quot;Unsafe&quot;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;theUnsafe;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 那如若想使用这个类，该如何获取其实例？有如下两个可行方案。 其一，从getUnsafe方法的使用限制条件出发，通过Java命令行命令-Xbootclasspath/a把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例。 java&nbsp;-Xbootclasspath/a:&nbsp;${path}&nbsp;&nbsp;&nbsp;//&nbsp;其中path为调用Unsafe相关方法的类所在jar包路径&nbsp; 其二，通过反射获取单例对象theUnsafe。 private&nbsp;static&nbsp;Unsafe&nbsp;reflectGetUnsafe()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Field&nbsp;field&nbsp;=&nbsp;Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field.setAccessible(true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(Unsafe)&nbsp;field.get(null);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error(e.getMessage(),&nbsp;e);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;}} 功能介绍 如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。 内存操作 这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。 //分配内存,&nbsp;相当于C++的malloc函数public&nbsp;native&nbsp;long&nbsp;allocateMemory(long&nbsp;bytes);//扩充内存public&nbsp;native&nbsp;long&nbsp;reallocateMemory(long&nbsp;address,&nbsp;long&nbsp;bytes);//释放内存public&nbsp;native&nbsp;void&nbsp;freeMemory(long&nbsp;address);//在给定的内存块中设置值public&nbsp;native&nbsp;void&nbsp;setMemory(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;long&nbsp;bytes,&nbsp;byte&nbsp;value);//内存拷贝public&nbsp;native&nbsp;void&nbsp;copyMemory(Object&nbsp;srcBase,&nbsp;long&nbsp;srcOffset,&nbsp;Object&nbsp;destBase,&nbsp;long&nbsp;destOffset,&nbsp;long&nbsp;bytes);//获取给定地址值，忽略修饰限定符的限制访问限制。与此类似操作还有:&nbsp;getInt，getDouble，getLong，getChar等public&nbsp;native&nbsp;Object&nbsp;getObject(Object&nbsp;o,&nbsp;long&nbsp;offset);//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有:&nbsp;putInt,putDouble，putLong，putChar等public&nbsp;native&nbsp;void&nbsp;putObject(Object&nbsp;o,&nbsp;long&nbsp;offset, Object x);//获取给定地址的byte类型的值(当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的)public&nbsp;native&nbsp;byte&nbsp;getByte(long&nbsp;address);//为给定地址设置byte类型的值(当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的)public&nbsp;native&nbsp;void&nbsp;putByte(long&nbsp;address,&nbsp;byte&nbsp;x); 通常，我们在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。 使用堆外内存的原因 对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模，从而在GC时减少回收停顿对于应用的影响。 提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。 典型应用 DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。 下图为DirectByteBuffer构造函数，创建DirectByteBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放。 那么如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？ Cleaner继承自Java四大引用类型之一的虚引用PhantomReference（众所周知，无法通过虚引用获取与之关联的对象实例，且当对象仅被虚引用引用时，在任何发生GC的时候，其均可被回收），通常PhantomReference与引用队列ReferenceQueue结合使用，可以实现虚引用关联对象被垃圾回收时能够进行系统通知、资源清理等功能。如下图所示，当某个被Cleaner引用的对象将被回收时，JVM垃圾收集器会将此对象的引用放入到对象引用中的pending链表中，等待Reference-Handler进行相关处理。其中，Reference-Handler为一个拥有最高优先级的守护线程，会循环不断的处理pending链表中的对象引用，执行Cleaner的clean方法进行相关清理工作。 所以当DirectByteBuffer仅被Cleaner引用（即为虚引用）时，其可以在任意GC时段被回收。当DirectByteBuffer实例对象被回收时，在Reference-Handler线程操作中，会调用Cleaner的clean方法根据创建Cleaner时传入的Deallocator来进行堆外内存的释放。 CAS相关 如下源代码释义所示，这部分主要为CAS相关操作的方法。 /**&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;CAS&nbsp;&nbsp;*&nbsp;@param&nbsp;o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含要修改field的对象&nbsp;&nbsp;*&nbsp;@param&nbsp;offset&nbsp;&nbsp;&nbsp;&nbsp;对象中某field的偏移量&nbsp;&nbsp;*&nbsp;@param&nbsp;expected&nbsp;&nbsp;期望值&nbsp;&nbsp;*&nbsp;@param&nbsp;update&nbsp;&nbsp;&nbsp;&nbsp;更新值&nbsp;&nbsp;*&nbsp;@return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true&nbsp;|&nbsp;false&nbsp;&nbsp;*/public&nbsp;final&nbsp;native&nbsp;boolean&nbsp;compareAndSwapObject(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;&nbsp;Object&nbsp;expected,&nbsp;Object&nbsp;update);public&nbsp;final&nbsp;native&nbsp;boolean&nbsp;compareAndSwapInt(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;int&nbsp;expected,int&nbsp;update);public&nbsp;final&nbsp;native&nbsp;boolean&nbsp;compareAndSwapLong(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;long&nbsp;expected,&nbsp;long&nbsp;update); 什么是CAS? 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。 典型应用 CAS在java.util.concurrent.atomic相关类、Java AQS、CurrentHashMap等实现上有非常广泛的应用。如下图所示，AtomicInteger的实现中，静态字段valueOffset即为字段value的内存偏移地址，valueOffset的值在AtomicInteger初始化时，在静态代码块中通过Unsafe的objectFieldOffset方法获取。在AtomicInteger中提供的线程安全方法中，通过字段valueOffset的值可以定位到AtomicInteger对象中value的内存地址，从而可以根据CAS实现对value字段的原子操作。 下图为某个AtomicInteger对象自增操作前后的内存示意图，对象的基地址baseAddress=&quot;0x110000&quot;，通过baseAddress+valueOffset得到value的内存地址valueAddress=&quot;0x11000c&quot;；然后通过CAS进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功为止。 线程调度 这部分，包括线程挂起、恢复、锁机制等方法。 //取消阻塞线程public&nbsp;native&nbsp;void&nbsp;unpark(Object&nbsp;thread);//阻塞线程public&nbsp;native&nbsp;void&nbsp;park(boolean&nbsp;isAbsolute,&nbsp;long&nbsp;time);//获得对象锁（可重入锁）@Deprecatedpublic&nbsp;native&nbsp;void&nbsp;monitorEnter(Object&nbsp;o);//释放对象锁@Deprecatedpublic&nbsp;native&nbsp;void&nbsp;monitorExit(Object&nbsp;o);//尝试获取对象锁@Deprecatedpublic&nbsp;native&nbsp;boolean&nbsp;tryMonitorEnter(Object&nbsp;o); 如上源码说明中，方法park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark可以终止一个挂起的线程，使其恢复正常。 典型应用 Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。 Class相关 此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等。 //获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的public&nbsp;native&nbsp;long&nbsp;staticFieldOffset(Field&nbsp;f);//获取一个静态类中给定字段的对象指针public&nbsp;native&nbsp;Object&nbsp;staticFieldBase(Field&nbsp;f);//判断是否需要初始化一个类，通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。&nbsp;此方法当且仅当ensureClassInitialized方法不生效的时候才返回false。public&nbsp;native&nbsp;boolean&nbsp;shouldBeInitialized(Class&lt;?&gt;&nbsp;c);//检测给定的类是否已经初始化。通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。public&nbsp;native&nbsp;void&nbsp;ensureClassInitialized(Class&lt;?&gt;&nbsp;c);//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader(类加载器)和ProtectionDomain(保护域)实例来源于调用者public&nbsp;native&nbsp;Class&lt;?&gt;&nbsp;defineClass(String&nbsp;name,&nbsp;byte[]&nbsp;b,&nbsp;int&nbsp;off,&nbsp;int&nbsp;len,&nbsp;ClassLoader&nbsp;loader,&nbsp;ProtectionDomain&nbsp;protectionDomain);//定义一个匿名类public&nbsp;native&nbsp;Class&lt;?&gt;&nbsp;defineAnonymousClass(Class&lt;?&gt;&nbsp;hostClass,&nbsp;byte[]&nbsp;data,&nbsp;Object[]&nbsp;cpPatches); 典型应用 从Java 8开始，JDK使用invokedynamic及VM Anonymous Class结合来实现Java语言层面上的Lambda表达式。 invokedynamic： invokedynamic是Java 7为了实现在JVM上运行动态语言而引入的一条新的虚拟机指令，它可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic指令的分派逻辑是由用户设定的引导方法决定。 VM Anonymous Class：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过Unsafe.defineAnonymousClass方法定义具体类时填充模板的占位符生成具体的匿名类。生成的匿名类不显式挂在任何ClassLoader下面，只要当该类没有存在的实例对象、且没有强引用来引用该类的Class对象时，该类就会被GC回收。故而VM Anonymous Class相比于Java语言层面的匿名内部类无需通过ClassClassLoader进行类加载且更易回收。 在Lambda表达式实现中，通过invokedynamic指令调用引导方法生成调用点，在此过程中，会通过ASM动态生成字节码，而后利用Unsafe的defineAnonymousClass方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应Lambda表达式定义逻辑的功能。下面以如下图所示的Test类来举例说明。 Test类编译后的class文件反编译后的结果如下图一所示（删除了对本文说明无意义的部分），我们可以从中看到main方法的指令实现、invokedynamic指令调用的引导方法BootstrapMethods、及静态方法lambda$main$0（实现了Lambda表达式中字符串打印逻辑）等。在引导方法执行过程中，会通过Unsafe.defineAnonymousClass生成如下图二所示的实现Consumer接口的匿名类。其中，accept方法通过调用Test类中的静态方法lambda$main$0来实现Lambda表达式中定义的逻辑。而后执行语句consumer.accept（&quot;lambda&quot;）其实就是调用下图二所示的匿名类的accept方法。 对象操作 此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。 //返回对象成员属性在内存地址相对于此对象的内存地址的偏移量public&nbsp;native&nbsp;long&nbsp;objectFieldOffset(Field&nbsp;f);//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等public&nbsp;native&nbsp;Object&nbsp;getObject(Object&nbsp;o,&nbsp;long&nbsp;offset);//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等public&nbsp;native&nbsp;void&nbsp;putObject(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;Object&nbsp;x);//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义public&nbsp;native&nbsp;Object&nbsp;getObjectVolatile(Object&nbsp;o,&nbsp;long&nbsp;offset);//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义public&nbsp;native&nbsp;void&nbsp;putObjectVolatile(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;Object&nbsp;x);//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效public&nbsp;native&nbsp;void&nbsp;putOrderedObject(Object&nbsp;o,&nbsp;long&nbsp;offset,&nbsp;Object&nbsp;x);//绕过构造方法、初始化代码来创建对象public&nbsp;native&nbsp;Object&nbsp;allocateInstance(Class&lt;?&gt;&nbsp;cls)&nbsp;throws&nbsp;InstantiationException; 典型应用 常规对象实例化方式：我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。 非常规的实例化方式：而Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。 如下图所示，在Gson反序列化时，如果类有默认构造函数，则通过反射调用默认构造函数创建实例，否则通过UnsafeAllocator来实现对象实例的构造，UnsafeAllocator通过调用Unsafe的allocateInstance实现对象的实例化，保证在目标类无默认构造函数时，反序列化不够影响。 数组相关 这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。 //返回数组中第一个元素的偏移地址public&nbsp;native&nbsp;int&nbsp;arrayBaseOffset(Class&lt;?&gt;&nbsp;arrayClass);//返回数组中一个元素占用的大小public&nbsp;native&nbsp;int&nbsp;arrayIndexScale(Class&lt;?&gt;&nbsp;arrayClass); 典型应用 这两个与数据操作相关的方法，在java.util.concurrent.atomic 包下的AtomicIntegerArray（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用，如下图AtomicIntegerArray源码所示，通过Unsafe的arrayBaseOffset、arrayIndexScale分别获取数组首元素的偏移地址base及单个元素大小因子scale。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的getAndAdd方法即通过checkedByteOffset方法获取某数组元素的偏移地址，而后通过CAS实现原子性操作。 内存屏障 在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。 //内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前public&nbsp;native&nbsp;void&nbsp;loadFence();//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前public&nbsp;native&nbsp;void&nbsp;storeFence();//内存屏障，禁止load、store操作重排序public&nbsp;native&nbsp;void&nbsp;fullFence(); 典型应用 在Java 8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性。 如上图用例所示计算坐标点Point对象，包含点移动方法move及计算此点到原点的距离的方法distanceFromOrigin。在方法distanceFromOrigin中，首先，通过tryOptimisticRead方法获取乐观读标记；然后从主内存中加载点的坐标值 (x,y)；而后通过StampedLock的validate方法校验锁状态，判断坐标点(x,y)从主内存加载到线程工作内存过程中，主内存的值是否已被其他线程通过move方法修改，如果validate返回值为true，证明(x, y)的值未被修改，可参与后续计算；否则，需加悲观读锁，再次从主内存加载(x,y)的最新值，然后再进行距离计算。其中，校验锁状态这步操作至关重要，需要判断锁状态是否发生改变，从而判断之前copy到线程工作内存中的值是否与主内存的值存在不一致。 下图为StampedLock.validate方法的源码实现，通过锁标记与相关常量进行位运算、比较来校验锁状态，在校验逻辑之前，会通过Unsafe的loadFence方法加入一个load内存屏障，目的是避免上图用例中步骤②和StampedLock.validate中锁状态校验运算发生重排序导致锁状态校验不准确的问题。 系统相关 这部分包含两个获取系统相关信息的方法。 //返回系统指针的大小。返回值为4（32位系统）或8（64位系统）。public&nbsp;native&nbsp;int&nbsp;addressSize();&nbsp;&nbsp;//内存页的大小，此值为2的幂次方。public&nbsp;native&nbsp;int&nbsp;pageSize(); 典型应用 如下图所示的代码片段，为java.nio下的工具类Bits中计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑。 结语 本文对Java中的sun.misc.Unsafe的用法及应用场景进行了基本介绍，我们可以看到Unsafe提供了很多便捷、有趣的API方法。即便如此，由于Unsafe中包含大量自主操作内存的方法，如若使用不当，会对程序带来许多不可控的灾难。因此对它的使用我们需要慎之又慎。 参考资料 OpenJDK Unsafe source Java Magic. Part 4: sun.misc.Unsafe JVM crashes at libjvm.so Java中神奇的双刃剑--Unsafe JVM源码分析之堆外内存完全解读 堆外内存 之 DirectByteBuffer 详解 《深入理解Java虚拟机（第2版）》 作者简介 璐璐，美团点评Java开发工程师。2017年加入美团点评，负责美团点评境内度假的后端开发。 欢迎加入美团Java技术交流群，跟作者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：Java，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 不可不说的Java“锁”事 红黑树深入剖析及Java实现 从实际案例聊聊Java应用的GC优化","@type":"BlogPosting","url":"https://mlh.app/2019/04/29/729120.html","headline":"【基本功】Java魔法类：Unsafe应用解析","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/29/729120.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>【基本功】Java魔法类：Unsafe应用解析</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p data-mpa-powered-by="yiban.io" style="white-space: normal;"><img class="" data-copyright="0" data-ratio="0.10546875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png" data-type="png" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: center;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">总第334篇</span></strong></p> 
<p style="white-space: normal;text-align: center;margin-bottom: 10px;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">2019年 第12篇</span></strong></p> 
<section class="output_wrapper" style="margin-right: 0.5em;margin-left: 0.5em;letter-spacing: 0px;white-space: normal;font-size: 16px;line-height: 1.6;"> 
 <section data-role="outer" label="Powered by 135editor.com" style="color: rgb(62, 62, 62);font-family: 微软雅黑;"> 
  <section data-role="outer" label="Powered by 135editor.com"> 
   <section class="_135editor" data-tools="135编辑器" data-id="45730" style="border-width: 0px;border-style: none;border-color: initial;"> 
    <section data-width="100%" style="width: 558px;border-width: 1px;border-style: solid;border-color: rgb(198, 198, 199);border-radius: 10px;"> 
     <section class="135brush" style="margin: 15px 10px;text-align: center;"> 
      <img border="0" class="" data-copyright="0" data-cropselx1="0" data-cropselx2="160" data-cropsely1="0" data-cropsely2="160" data-ratio="1.163" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXOIL2IqKUp6aTY7n0WYha7YPpYFvibwiaLJhaWljiaxQDfXLLnURucZr7KJTDl7uV1TzKQuTUdIQ6kw/640?wx_fmt=png" data-type="png" data-w="1000" data-width="100%" opacity="" style="margin-top: 5px;height: 186px;caret-color: red;width: 160px;" title="undefined" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXOIL2IqKUp6aTY7n0WYha7YPpYFvibwiaLJhaWljiaxQDfXLLnURucZr7KJTDl7uV1TzKQuTUdIQ6kw/640?wx_fmt=png"> 
     </section> 
     <section class="135brush" data-style="margin: 5px 0px; font-size: 14px; padding:5px; color: rgb(198,198,199); text-align: left; line-height: 1.5;" style="margin: 15px;"> 
      <p class="p1" style="color: rgb(62, 62, 62);font-family: 微软雅黑;font-size: 16px;white-space: normal;"><span style="color: rgb(136, 136, 136);font-size: 14px;">大家好，我是程序员鼓励师美美～</span></p> 
      <p class="p2" style="color: rgb(62, 62, 62);font-family: 微软雅黑;font-size: 16px;white-space: normal;"><br></p> 
      <p class="p1" style="color: rgb(62, 62, 62);font-family: 微软雅黑;font-size: 16px;white-space: normal;"><span style="color: rgb(136, 136, 136);font-size: 14px;">《基本功》专栏又上新了：Java中的Unsafe类在提升运行效率、增强底层资源操作能力方面有很大的用处。但如果在开发过程中使用不当，就会出现各种“莫名其妙”的问题。</span></p> 
      <p class="p2" style="color: rgb(62, 62, 62);font-family: 微软雅黑;font-size: 16px;white-space: normal;"><br></p> 
      <p class="p1" style="color: rgb(62, 62, 62);font-family: 微软雅黑;font-size: 16px;white-space: normal;"><span style="color: rgb(136, 136, 136);font-size: 14px;">本篇文章将会带领你重新认识它，绕过“开发雷区”，猪事大吉。</span></p> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section> 
<section class="output_wrapper" style="font-size: 16px;line-height: 1.6;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</span></p> 
 <p>本文对sun.misc.Unsafe公共API功能及相关应用场景进行介绍。</p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong style="font-size: 20px;font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(49, 188, 173);box-sizing: border-box !important;overflow-wrap: break-word !important;">基本介绍</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">如下Unsafe源码所示，Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常。</span></p> 
 <pre style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="java language-java hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">final</span>&nbsp;<span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Unsafe</span>&nbsp;</span>{<br>&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;单例对象</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">private</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">static</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">final</span>&nbsp;Unsafe&nbsp;theUnsafe;<br><br>&nbsp;&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">private</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Unsafe</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;</span>{<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">@CallerSensitive</span><br>&nbsp;&nbsp;<span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">static</span>&nbsp;Unsafe&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">getUnsafe</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Class&nbsp;var0&nbsp;=&nbsp;Reflection.getCallerClass();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;仅在引导类加载器`BootstrapClassLoader`加载时才合法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader()))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">throw</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">new</span>&nbsp;SecurityException(<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Unsafe"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;theUnsafe;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}<br></span></code></pre> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">那如若想使用这个类，该如何获取其实例？有如下两个可行方案。</span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">其一，从</span><code style="font-size: inherit;line-height: inherit;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">getUnsafe</span></code><span style="font-size: 15px;">方法的使用限制条件出发，通过Java命令行命令</span><code style="font-size: inherit;line-height: inherit;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">-Xbootclasspath/a</span></code><span style="font-size: 15px;">把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过</span><code style="font-size: inherit;line-height: inherit;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Unsafe.getUnsafe</span></code><span style="font-size: 15px;">方法安全的获取Unsafe实例。</span></p> 
 <pre style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="bash language-bash hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span style="font-size: 15px;">java&nbsp;-Xbootclasspath/a:&nbsp;<span class="hljs-variable" style="font-size: 15px;line-height: inherit;color: rgb(98, 151, 85);overflow-wrap: inherit !important;word-break: inherit !important;">${path}</span>&nbsp;&nbsp;&nbsp;//&nbsp;其中path为调用Unsafe相关方法的类所在jar包路径&nbsp;<br></span></code></pre> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">其二，通过反射获取单例对象theUnsafe。</span></p> 
 <pre style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="java language-java hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">private</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">static</span>&nbsp;Unsafe&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">reflectGetUnsafe</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">try</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Field&nbsp;field&nbsp;=&nbsp;Unsafe.class.getDeclaredField(<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"theUnsafe"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field.setAccessible(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">true</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;(Unsafe)&nbsp;field.get(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">null</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">catch</span>&nbsp;(Exception&nbsp;e)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error(e.getMessage(),&nbsp;e);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></span></code></pre> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><strong style="font-size: 20px;font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(49, 188, 173);box-sizing: border-box !important;overflow-wrap: break-word !important;">功能介绍</span></strong></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.44752818733738076" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3BnCAIiajKypwdRQkWdFoicF4dcj1CARMnyiaQQySe3BcCO8V0OQKHcHsg/640?wx_fmt=png" data-type="png" data-w="2306" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3BnCAIiajKypwdRQkWdFoicF4dcj1CARMnyiaQQySe3BcCO8V0OQKHcHsg/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。</span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong><span style="font-size: 18px;">内存操作</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。</span></p> 
 <pre style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="java language-java hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//分配内存,&nbsp;相当于C++的malloc函数</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">allocateMemory</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;bytes)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//扩充内存</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">reallocateMemory</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;address,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;bytes)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//释放内存</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">freeMemory</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;address)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//在给定的内存块中设置值</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">setMemory</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;offset,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;bytes,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">byte</span>&nbsp;value)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//内存拷贝</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">copyMemory</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;srcBase,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;srcOffset,&nbsp;Object&nbsp;destBase,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;destOffset,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;bytes)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//获取给定地址值，忽略修饰限定符的限制访问限制。与此类似操作还有:&nbsp;getInt，getDouble，getLong，getChar等</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;Object&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">getObject</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;offset)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有:&nbsp;putInt,putDouble，putLong，putChar等</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">putObject</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;offset, Object x)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//获取给定地址的byte类型的值(当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的)</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">byte</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">getByte</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;address)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//为给定地址设置byte类型的值(当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的)</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">putByte</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;address,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">byte</span>&nbsp;x)</span></span>;<br></span></code></pre> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通常，我们在Java中创建的对象都处于堆内内存（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">heap</span><span style="font-size: 15px;">）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理<span style="color: rgb(62, 62, 62);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;">堆</span>内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。</span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong><span style="font-size: 16px;">使用堆外内存的原因</span></strong></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模，从而在GC时减少回收停顿对于应用的影响。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</span></p></li> 
 </ul> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong><span style="font-size: 16px;">典型应用</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。</span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">下图为DirectByteBuffer构造函数，创建DirectByteBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放。</span></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.5451295799821269" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3ibymSp9zV3jEOCL7fTK6uicqGIBw8cPH8gumx7SPnVKAUdEWXxydS0wA/640?wx_fmt=png" data-type="png" data-w="2238" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3ibymSp9zV3jEOCL7fTK6uicqGIBw8cPH8gumx7SPnVKAUdEWXxydS0wA/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">那么如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？</span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 5px;"><span style="font-size: 15px;">Cleaner继承自Java四大引用类型之一的虚引用PhantomReference（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">众所周知，无法通过虚引用获取与之关联的对象实例，且当对象仅被虚引用引用时，在任何发生GC的时候，其均可被回收</span><span style="font-size: 15px;">），通常PhantomReference与引用队列ReferenceQueue结合使用，可以实现虚引用关联对象被垃圾回收时能够进行系统通知、资源清理等功能。如下图所示，当某个被Cleaner引用的对象将被回收时，JVM垃圾收集器会将此对象的引用放入到对象引用中的pending链表中，等待Reference-Handler进行相关处理。其中，Reference-Handler为一个拥有最高优先级的守护线程，会循环不断的处理pending链表中的对象引用，执行Cleaner的clean方法进行相关清理工作。</span></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.5212765957446809" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3KXib6zaibtiazNKibHIywZQf859YU5sFHs1mLN2cJWoHYiaSmJrLn9vCfjQ/640?wx_fmt=png" data-type="png" data-w="1786" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3KXib6zaibtiazNKibHIywZQf859YU5sFHs1mLN2cJWoHYiaSmJrLn9vCfjQ/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 5px;margin-bottom: 5px;"><span style="font-size: 15px;">所以当DirectByteBuffer仅被Cleaner引用（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">即为虚引用</span><span style="font-size: 15px;">）时，其可以在任意GC时段被回收。当DirectByteBuffer实例对象被回收时，在Reference-Handler线程操作中，会调用Cleaner的clean方法根据创建Cleaner时传入的Deallocator来进行堆外内存的释放。</span></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.39861523244312563" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3rT3ZFpykicQQLBwVPc5NB2ibdZEe5libqC3EjVFjpqDiabAe7fTQltpaRw/640?wx_fmt=png" data-type="png" data-w="2022" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3rT3ZFpykicQQLBwVPc5NB2ibdZEe5libqC3EjVFjpqDiabAe7fTQltpaRw/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-bottom: 1.5em;margin-top: 5px;"><strong><span style="font-size: 18px;">CAS相关</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">如下源代码释义所示，这部分主要为CAS相关操作的方法。</span></p> 
 <pre style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="java language-java hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;CAS<br>&nbsp;&nbsp;*&nbsp;<span class="hljs-doctag" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">@param</span>&nbsp;o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含要修改field的对象<br>&nbsp;&nbsp;*&nbsp;<span class="hljs-doctag" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">@param</span>&nbsp;offset&nbsp;&nbsp;&nbsp;&nbsp;对象中某field的偏移量<br>&nbsp;&nbsp;*&nbsp;<span class="hljs-doctag" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">@param</span>&nbsp;expected&nbsp;&nbsp;期望值<br>&nbsp;&nbsp;*&nbsp;<span class="hljs-doctag" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">@param</span>&nbsp;update&nbsp;&nbsp;&nbsp;&nbsp;更新值<br>&nbsp;&nbsp;*&nbsp;<span class="hljs-doctag" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">@return</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true&nbsp;|&nbsp;false<br>&nbsp;&nbsp;*/</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">final</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">boolean</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">compareAndSwapObject</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;offset,&nbsp;&nbsp;Object&nbsp;expected,&nbsp;Object&nbsp;update)</span></span>;<br><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">final</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">boolean</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">compareAndSwapInt</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;offset,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>&nbsp;expected,<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>&nbsp;update)</span></span>;<br><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">final</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">boolean</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">compareAndSwapLong</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;offset,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;expected,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;update)</span></span>;<br></span></code></pre> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-bottom: 1.5em;margin-top: 10px;"><span style="font-size: 15px;">什么是CAS? 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS是一条CPU的原子指令（</span><span style="color: rgb(136, 136, 136);font-size: 15px;">cmpxchg指令</span><span style="font-size: 15px;">），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">如compareAndSwapXXX</span><span style="font-size: 15px;">）底层实现即为CPU指令cmpxchg。</span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong><span style="font-size: 16px;">典型应用</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">CAS在java.util.concurrent.atomic相关类、Java AQS、CurrentHashMap等实现上有非常广泛的应用。如下图所示，AtomicInteger的实现中，静态字段valueOffset即为字段value的内存偏移地址，valueOffset的值在AtomicInteger初始化时，在静态代码块中通过Unsafe的objectFieldOffset方法获取。在AtomicInteger中提供的线程安全方法中，通过字段valueOffset的值可以定位到AtomicInteger对象中value的内存地址，从而可以根据CAS实现对value字段的原子操作。</span></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.32916666666666666" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3eI6DnUK443zzlJF6lM4YvZ28iaNx6RrKSneto7S9aDYCaMNENFFg1Dg/640?wx_fmt=png" data-type="png" data-w="1920" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3eI6DnUK443zzlJF6lM4YvZ28iaNx6RrKSneto7S9aDYCaMNENFFg1Dg/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 5px;"><span style="font-size: 15px;">下图为某个AtomicInteger对象自增操作前后的内存示意图，对象的基地址baseAddress="0x110000"，通过baseAddress+valueOffset得到value的内存地址valueAddress="0x11000c"；然后通过CAS进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功为止。</span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><img class="" data-copyright="0" data-ratio="0.6475155279503105" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3BPFL8YzX2FxnO1TPNWYbRFIB9bwmpsVb7iaz1V0fQE6pQH0rkicraDxg/640?wx_fmt=png" data-type="png" data-w="1288" style="letter-spacing: 0px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3BPFL8YzX2FxnO1TPNWYbRFIB9bwmpsVb7iaz1V0fQE6pQH0rkicraDxg/640?wx_fmt=png"></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-bottom: 1.5em;margin-top: 5px;"><strong style="color: inherit;font-size: inherit;letter-spacing: 0px;"><span style="font-size: 18px;">线程调度</span></strong><br></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">这部分，包括线程挂起、恢复、锁机制等方法。</span></p> 
 <pre style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="java language-java hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//取消阻塞线程</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">unpark</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;thread)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//阻塞线程</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">park</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">boolean</span>&nbsp;isAbsolute,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;time)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//获得对象锁（可重入锁）</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">@Deprecated</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">monitorEnter</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//释放对象锁</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">@Deprecated</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">monitorExit</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//尝试获取对象锁</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">@Deprecated</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">boolean</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">tryMonitorEnter</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o)</span></span>;<br></span></code></pre> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-bottom: 1.5em;margin-top: 10px;"><span style="font-size: 15px;">如上源码说明中，方法park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark可以终止一个挂起的线程，使其恢复正常。</span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong><span style="font-size: 16px;">典型应用</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用</span><code style="font-size: inherit;line-height: inherit;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">LockSupport.park()</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">LockSupport.unpark()</span></code><span style="font-size: 15px;">实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。</span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong><span style="font-size: 18px;">Class相关</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等。</span></p> 
 <pre style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="java language-java hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">staticFieldOffset</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Field&nbsp;f)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//获取一个静态类中给定字段的对象指针</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;Object&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">staticFieldBase</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Field&nbsp;f)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//判断是否需要初始化一个类，通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。&nbsp;此方法当且仅当ensureClassInitialized方法不生效的时候才返回false。</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">boolean</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">shouldBeInitialized</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Class&lt;?&gt;&nbsp;c)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//检测给定的类是否已经初始化。通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">ensureClassInitialized</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Class&lt;?&gt;&nbsp;c)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader(类加载器)和ProtectionDomain(保护域)实例来源于调用者</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;Class&lt;?&gt;&nbsp;defineClass(String&nbsp;name,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">byte</span>[]&nbsp;b,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>&nbsp;off,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>&nbsp;len,&nbsp;ClassLoader&nbsp;loader,&nbsp;ProtectionDomain&nbsp;protectionDomain);<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//定义一个匿名类</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;Class&lt;?&gt;&nbsp;defineAnonymousClass(Class&lt;?&gt;&nbsp;hostClass,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">byte</span>[]&nbsp;data,&nbsp;Object[]&nbsp;cpPatches);<br></span></code></pre> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong><span style="font-size: 16px;">典型应用</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">从Java 8开始，JDK使用invokedynamic及VM Anonymous Class结合来实现Java语言层面上的Lambda表达式。</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">invokedynamic</strong>： invokedynamic是Java 7为了实现在JVM上运行动态语言而引入的一条新的虚拟机指令，它可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic指令的分派逻辑是由用户设定的引导方法决定。</span></p></li> 
  <li><p><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">VM Anonymous Class</strong>：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过Unsafe.defineAnonymousClass方法定义具体类时填充模板的占位符生成具体的匿名类。生成的匿名类不显式挂在任何ClassLoader下面，只要当该类没有存在的实例对象、且没有强引用来引用该类的Class对象时，该类就会被GC回收。故而VM Anonymous Class相比于Java语言层面的匿名内部类无需通过ClassClassLoader进行类加载且更易回收。</span></p></li> 
 </ul> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">在Lambda表达式实现中，通过invokedynamic指令调用引导方法生成调用点，在此过程中，会通过ASM动态生成字节码，而后利用Unsafe的defineAnonymousClass方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应Lambda表达式定义逻辑的功能。下面以如下图所示的Test类来举例说明。</span></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.4557165861513688" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3KP5VMQFgWibBjEqvmenORLZqkJBuwjSbJp6AiawicmyfV9VvcQIlSiaAuw/640?wx_fmt=png" data-type="png" data-w="1242" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3KP5VMQFgWibBjEqvmenORLZqkJBuwjSbJp6AiawicmyfV9VvcQIlSiaAuw/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 5px;"><span style="color: rgb(62, 62, 62);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: start;background-color: rgb(255, 255, 255);font-size: 15px;">Test类编译后的class文件反编译后的结果如下图一所示（</span><span style="font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: start;background-color: rgb(255, 255, 255);font-size: 15px;color: rgb(136, 136, 136);">删除了对本文说明无意义的部分</span><span style="color: rgb(62, 62, 62);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: start;background-color: rgb(255, 255, 255);font-size: 15px;">），我们可以从中看到main方法的指令实现、invokedynamic指令调用的引导方法BootstrapMethods、及静态方法</span><code style="box-sizing: border-box;margin-right: 2px;margin-left: 2px;padding: 2px 4px;font-size: 16px;color: rgb(233, 105, 0);line-height: inherit;overflow-wrap: break-word;border-radius: 4px;background: rgb(248, 248, 248);text-align: start;white-space: normal;"><span style="font-size: 15px;">lambda$main$0</span></code><span style="color: rgb(62, 62, 62);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: start;background-color: rgb(255, 255, 255);font-size: 15px;">（</span><span style="font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: start;background-color: rgb(255, 255, 255);font-size: 15px;color: rgb(136, 136, 136);">实现了Lambda表达式中字符串打印逻辑</span><span style="color: rgb(62, 62, 62);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: start;background-color: rgb(255, 255, 255);font-size: 15px;">）等。在引导方法执行过程中，会通过Unsafe.defineAnonymousClass生成如下图二所示的实现Consumer接口的匿名类。其中，accept方法通过调用Test类中的静态方法</span><code style="box-sizing: border-box;margin-right: 2px;margin-left: 2px;padding: 2px 4px;font-size: 16px;color: rgb(233, 105, 0);line-height: inherit;overflow-wrap: break-word;border-radius: 4px;background: rgb(248, 248, 248);text-align: start;white-space: normal;"><span style="font-size: 15px;">lambda$main$0</span></code><span style="color: rgb(62, 62, 62);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: start;background-color: rgb(255, 255, 255);font-size: 15px;">来实现Lambda表达式中定义的逻辑。而后执行语句</span><code style="box-sizing: border-box;margin-right: 2px;margin-left: 2px;padding: 2px 4px;font-size: 16px;color: rgb(233, 105, 0);line-height: inherit;overflow-wrap: break-word;border-radius: 4px;background: rgb(248, 248, 248);text-align: start;white-space: normal;"><span style="font-size: 15px;">consumer.accept（"lambda"）</span></code><span style="color: rgb(62, 62, 62);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: start;background-color: rgb(255, 255, 255);font-size: 15px;">其实就是调用下图二所示的匿名类的accept方法。</span></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.42433234421364985" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3t8fdaibYOicZuXPkDP39ibiclniaQVDSBATPujok2aXxsuDFRZTQOVEfkiaA/640?wx_fmt=png" data-type="png" data-w="2022" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3t8fdaibYOicZuXPkDP39ibiclniaQVDSBATPujok2aXxsuDFRZTQOVEfkiaA/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-bottom: 1.5em;margin-top: 5px;"><strong><span style="font-size: 18px;">对象操作</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。</span></p> 
 <pre style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="java language-java hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//返回对象成员属性在内存地址相对于此对象的内存地址的偏移量</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">objectFieldOffset</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Field&nbsp;f)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;Object&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">getObject</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;offset)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">putObject</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;offset,&nbsp;Object&nbsp;x)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;Object&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">getObjectVolatile</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;offset)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">putObjectVolatile</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;offset,&nbsp;Object&nbsp;x)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">putOrderedObject</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Object&nbsp;o,&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">long</span>&nbsp;offset,&nbsp;Object&nbsp;x)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//绕过构造方法、初始化代码来创建对象</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;Object&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">allocateInstance</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Class&lt;?&gt;&nbsp;cls)</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">throws</span>&nbsp;InstantiationException</span>;<br></span></code></pre> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong><span style="font-size: 16px;">典型应用</span></strong></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">常规对象实例化方式</strong>：我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</span></p></li> 
  <li><p><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">非常规的实例化方式</strong>：而Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">提供绕过类构造器的对象生成方式</span><span style="font-size: 15px;">）、Gson（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">反序列化时用到</span><span style="font-size: 15px;">）中都有相应的应用。</span></p></li> 
 </ul> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 5px;"><span style="font-size: 15px;">如下图所示，在Gson反序列化时，如果类有默认构造函数，则通过反射调用默认构造函数创建实例，否则通过UnsafeAllocator来实现对象实例的构造，UnsafeAllocator通过调用Unsafe的allocateInstance实现对象的实例化，保证在目标类无默认构造函数时，反序列化不够影响。</span></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.40336967294350845" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3OfjjEh9pMKcnIq0uroSYoAzkadlmjTniahBVQamUBQwAYcyXvibyiaibibg/640?wx_fmt=png" data-type="png" data-w="2018" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3OfjjEh9pMKcnIq0uroSYoAzkadlmjTniahBVQamUBQwAYcyXvibyiaibibg/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-bottom: 1.5em;margin-top: 5px;"><strong><span style="font-size: 18px;">数组相关</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。</span></p> 
 <pre style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="java language-java hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//返回数组中第一个元素的偏移地址</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">int</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">arrayBaseOffset</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Class&lt;?&gt;&nbsp;arrayClass)</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//返回数组中一个元素占用的大小</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">int</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">arrayIndexScale</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(Class&lt;?&gt;&nbsp;arrayClass)</span></span>;<br></span></code></pre> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong><span style="font-size: 16px;">典型应用</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">这两个与数据操作相关的方法，在java.util.concurrent.atomic 包下的AtomicIntegerArray（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">可以实现对Integer数组中每个元素的原子性操作</span><span style="font-size: 15px;">）中有典型的应用，如下图AtomicIntegerArray源码所示，通过Unsafe的arrayBaseOffset、arrayIndexScale分别获取数组首元素的偏移地址base及单个元素大小因子scale。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的getAndAdd方法即通过checkedByteOffset方法获取某数组元素的偏移地址，而后通过CAS实现原子性操作。</span></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.406496062992126" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3DyxFRDzaG4aVicHyCdcILaPoGLs8pUbialCu4Me738AH568X0tPEVLjg/640?wx_fmt=png" data-type="png" data-w="2032" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3DyxFRDzaG4aVicHyCdcILaPoGLs8pUbialCu4Me738AH568X0tPEVLjg/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-bottom: 1.5em;margin-top: 5px;"><strong><span style="font-size: 18px;">内存屏障</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">在Java 8中引入，用于定义内存屏障（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作</span><span style="font-size: 15px;">），避免代码重排序。</span></p> 
 <pre style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="java language-java hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">loadFence</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">storeFence</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//内存屏障，禁止load、store操作重排序</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">fullFence</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>;<br></span></code></pre> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 16px;"><strong>典型应用</strong></span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 5px;"><span style="font-size: 15px;">在Java 8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性。</span></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.7265625" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ31sjgSNO16ZCicjia4icIPk9icssRkWTnWwKLqvX4HGqMuGDCes37QX7kBQ/640?wx_fmt=png" data-type="png" data-w="1792" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ31sjgSNO16ZCicjia4icIPk9icssRkWTnWwKLqvX4HGqMuGDCes37QX7kBQ/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-bottom: 1.5em;margin-top: 5px;"><span style="font-size: 15px;">如上图用例所示计算坐标点Point对象，包含点移动方法move及计算此点到原点的距离的方法distanceFromOrigin。在方法distanceFromOrigin中，首先，通过tryOptimisticRead方法获取乐观读标记；然后从主内存中加载点的坐标值 (x,y)；而后通过StampedLock的validate方法校验锁状态，判断坐标点(x,y)从主内存加载到线程工作内存过程中，主内存的值是否已被其他线程通过move方法修改，如果validate返回值为true，证明(x, y)的值未被修改，可参与后续计算；否则，需加悲观读锁，再次从主内存加载(x,y)的最新值，然后再进行距离计算。其中，校验锁状态这步操作至关重要，需要判断锁状态是否发生改变，从而判断之前copy到线程工作内存中的值是否与主内存的值存在不一致。</span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">下图为StampedLock.validate方法的源码实现，通过锁标记与相关常量进行位运算、比较来校验锁状态，在校验逻辑之前，会通过Unsafe的loadFence方法加入一个load内存屏障，目的是避免上图用例中步骤②和StampedLock.validate中锁状态校验运算发生重排序导致锁状态校验不准确的问题。</span></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.5730659025787965" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3Z9VRxlNmMUcxibQwHtCmNTmZxiagcYx53dfSzjOq5EibFuRqicsYgQvQhw/640?wx_fmt=png" data-type="png" data-w="1396" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3Z9VRxlNmMUcxibQwHtCmNTmZxiagcYx53dfSzjOq5EibFuRqicsYgQvQhw/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong><span style="font-size: 18px;">系统相关</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">这部分包含两个获取系统相关信息的方法。</span></p> 
 <pre style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="java language-java hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//返回系统指针的大小。返回值为4（32位系统）或8（64位系统）。</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">int</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">addressSize</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>;&nbsp;&nbsp;<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//内存页的大小，此值为2的幂次方。</span><br><span class="hljs-function" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">native</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">int</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">pageSize</span><span class="hljs-params" style="font-size: 15px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>;<br></span></code></pre> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong><span style="font-size: 16px;">典型应用</span></strong></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 10px;"><span style="font-size: 15px;">如下图所示的代码片段，为java.nio下的工具类Bits中计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑。</span></p> 
 <figure style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;"> 
  <img class="" data-ratio="0.4098883572567783" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3hk9Nia1aHa3WCcqs0Ufumm5pichTvYaaV5ChG0PZdOXuibM7V08bAUd1w/640?wx_fmt=png" data-type="png" data-w="1254" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVupC6iakLITQ1csaa7rdkZ3hk9Nia1aHa3WCcqs0Ufumm5pichTvYaaV5ChG0PZdOXuibM7V08bAUd1w/640?wx_fmt=png"> 
 </figure> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;white-space: normal;font-size: 20px;max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(49, 188, 173);box-sizing: border-box !important;overflow-wrap: break-word !important;">结语</span></strong></span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">本文对Java中的sun.misc.Unsafe的用法及应用场景进行了基本介绍，我们可以看到Unsafe提供了很多便捷、有趣的API方法。即便如此，由于Unsafe中包含大量自主操作内存的方法，如若使用不当，会对程序带来许多不可控的灾难。因此对它的使用我们需要慎之又慎。</span></p> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;white-space: normal;font-size: 20px;max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(49, 188, 173);box-sizing: border-box !important;overflow-wrap: break-word !important;">参考资料</span></strong></span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/sun/misc/Unsafe.java" style="line-height: inherit;color: rgb(30, 107, 184);overflow-wrap: break-word;font-size: 15px;text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">OpenJDK Unsafe source</span></a></p></li> 
  <li><p><a href="http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe" style="line-height: inherit;color: rgb(30, 107, 184);overflow-wrap: break-word;font-size: 15px;text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">Java Magic. Part 4: sun.misc.Unsafe</span></a></p></li> 
  <li><p><a href="https://www.zhihu.com/question/51132462" style="line-height: inherit;color: rgb(30, 107, 184);overflow-wrap: break-word;font-size: 15px;text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">JVM crashes at libjvm.so</span></a></p></li> 
  <li><p><a href="https://www.cnblogs.com/throwable/p/9139947.html" style="line-height: inherit;color: rgb(30, 107, 184);overflow-wrap: break-word;font-size: 15px;text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">Java中神奇的双刃剑--Unsafe</span></a></p></li> 
  <li><p><a href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/" style="line-height: inherit;color: rgb(30, 107, 184);overflow-wrap: break-word;font-size: 15px;text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">JVM源码分析之堆外内存完全解读</span></a></p></li> 
  <li><p><a href="https://www.jianshu.com/p/007052ee3773" style="line-height: inherit;color: rgb(30, 107, 184);overflow-wrap: break-word;font-size: 15px;text-decoration: underline;" data-linktype="2"><span style="font-size: 15px;">堆外内存 之 DirectByteBuffer 详解</span></a></p></li> 
  <li><p><span style="font-size: 15px;">《深入理解Java虚拟机（第2版）》</span></p></li> 
 </ul> 
 <p style="color: inherit;letter-spacing: 0px;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;white-space: normal;font-size: 20px;max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(49, 188, 173);box-sizing: border-box !important;overflow-wrap: break-word !important;">作者简介</span></strong></span></p> 
 <p style="color: rgb(62, 62, 62);letter-spacing: 0px;"><span style="line-height: inherit;font-size: 15px;color: rgb(136, 136, 136);">璐璐，美团点评Java开发工程师。2017年加入美团点评，负责美团点评境内度假的后端开发。</span></p> 
 <p style="color: rgb(62, 62, 62);letter-spacing: 0px;"><span style="line-height: inherit;font-size: 15px;color: rgb(136, 136, 136);"><br></span></p> 
 <p style=""><span style="line-height: inherit;font-size: 15px;"><span style="font-size: 15px;white-space: pre-wrap;max-width: 100%;background-color: rgb(255, 255, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="color: rgb(136, 136, 136);letter-spacing: 0.544px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;max-width: 100%;">欢迎加入<strong style="max-width: 100%;color: rgb(51, 51, 51);box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(0, 0, 0);box-sizing: border-box !important;overflow-wrap: break-word !important;">美团Java技术交流群</span></strong>，跟作者零距离交流。进群方式：请加美美同学<span style="max-width: 100%;letter-spacing: 0px;box-sizing: border-box !important;overflow-wrap: break-word !important;">微信（微信号：</span></span><span style="max-width: 100%;"><strong style="color: rgb(136, 136, 136);letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">MTDPtech02</strong><strong style="color: rgb(136, 136, 136);letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">）</strong><span style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><span style="color: rgb(136, 136, 136);letter-spacing: 0px;">，回复：</span><span style="color:#000000;"><span style="letter-spacing: 0.544px;"><strong>Java</strong></span></span></span></span></span></span><span style="color: rgb(136, 136, 136);letter-spacing: 0px;font-size: 15px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;white-space: pre-wrap;max-width: 100%;background-color: rgb(255, 255, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">，美美会自动拉你进群。</span></span></p> 
</section> 
<p style="white-space: normal;max-width: 100%;min-height: 1em;"><br></p> 
<p style="white-space: normal;max-width: 100%;min-height: 1em;text-align: center;margin-bottom: 10px;"><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;">----------&nbsp; END&nbsp; ----------</span></p> 
<p data-source-line="194" style="white-space: normal;"><br></p> 
<p style="white-space: normal;"><span style="font-size: 16px;"><strong><span style="color: rgb(49, 188, 173);">也许你还想看</span></strong></span></p> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651749434&amp;idx=3&amp;sn=5ffa63ad47fe166f2f1a9f604ed10091&amp;chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;" data-linktype="2"><span style="font-size: 14px;">不可不说的Java“锁”事</span></a><br></p> 
<p style="white-space: normal;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651745738&amp;idx=2&amp;sn=dc7570dfb3b652ec26a9b90d5e965149&amp;chksm=bd12b4878a653d91346b06f2870242708e667725dbbaf273a3eb7cea9c8193115f80463db65f&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;" data-linktype="2"><span style="font-size: 14px;">红黑树深入剖析及Java实现</span></a></p> 
<p style="white-space: normal;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651747273&amp;idx=1&amp;sn=7f947064a41eeecb6816a5d0838581ae&amp;chksm=bd12aa848a65239289d5c39264e89bd175f377f6554bfe93b37ad6498cf13deff356333c5398&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;" data-linktype="2"><span style="font-size: 14px;">从实际案例聊聊Java应用的GC优化</span></a><br></p> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;"><img class="" data-copyright="0" data-ratio="0.44533333333333336" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png" data-type="png" data-w="1875" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png"></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
