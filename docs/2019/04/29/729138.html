<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>React Native工程中TSLint静态检查工具的探索之路 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="React Native工程中TSLint静态检查工具的探索之路" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="总第329篇 2019年 第007篇 TSLint为TypeScript提供了代码检查能力，对使用TypeScript的React Native工程，在规范性、安全性、可靠性、可维护性等方面起到重要作用。本文主要对TSLint相关知识进行分享，并对自定义TSLint规则进行介绍。 建立的代码规范没人遵守，项目中遍地风格迥异的代码，你会不会抓狂？ 通过测试用例的程序还会出现Bug，而原因仅仅是自己犯下的低级错误，你会不会抓狂？ 某种代码写法存在问题导致崩溃时，只能全工程检查代码，这需要人工花费大量时间Review代码，你会不会抓狂？ 以上这些问题，可以通过静态检查有效地缓解！ 静态检查（Static Program Analysis）主要是以不运行程序的方式对于程序源代码进行检查分析的技术，而与之相反的就是动态检查（Dynamic Program Analysis），通过实际运行程序输入测试数据产生预期结果的技术。通过代码静态检查，我们可以快速定位代码的错误与缺陷，可以减少逐行阅读代码浪费的时间，可以（根据需要）快速扫描代码中可能存在的漏洞等。代码静态检查可以在代码的规范性、安全性、可靠性、可维护性等方面起到重要作用。 在客户端中，Android可以使用CheckStyle、Lint、Findbugs、PMD等工具，iOS可以使用Clang Static Analyzer、OCLint等工具。而在React Native的开发过程中，针对于JavaScript的ESLint，与TypeScript的TSLint，则成为了主要代码静态检查的工具。本文将按照使用TSLint的原因、使用TSLint的方法、自定义TSLint的步骤进行探究分析。 一、使用TSLint的原因 在客户端团队进入React Native项目的开发过程中，面临着如下问题： 由于大家从客户端转入到React Native开发过程中，容易出现低级语法错误； 开发者之前从事Android、iOS、前端等工作，因此代码风格不同，导致项目代码风格不统一； 客户端效果不一致，有可能Android端显示正常、iOS端显示异常，或者相反的情况出现。 虽然以上问题可以通过多次不断将雷点标记出，并不断地分享经验与强化代码Review过程等方式来进行缓解，但是仍面临着React Native开发者掌握的技术水平千差万别，知识分享传播的速度缓慢等问题，既导致了开发成本的不断增加和开发效率持续低下的问题，还难以避免一个坑被踩了多次的情况出现。这时急需一款可以满足以下目标的工具： 可检测代码低级语法错误； 规范项目代码风格； 根据需要可自定义检查代码的逻辑； 工具使用者可以“傻瓜式”的接入部署到开发IDE环境； 可以快速高效地将检查工具最新检查逻辑同步到开发IDE环境中； 对于检查出的问题可以快速定位。 根据上述要求的描述，静态检查工具TSLint可以较为有效地达成目标。 二、TSLint介绍 TSLint是硅谷企业Palantir的一个项目，它是一款可以检查TypeScript代码可读性、可维护性以及功能性错误的静态检查工具，当前许多编辑器（Editors）和构建系统（Build Systems）支持这一工具，同时支持自定义编写Lint规则、配置、格式化等。 当前TSLint已经包含了上百条规则，这些规则构筑了当前TSLint检查的基础。在代码开发阶段中，通过这些配置好的规则可以给工程一个完整的检查，并随时可以提示出可能存在的问题。本文内容参考了TSLint官方文档https://palantir.github.io/tslint/。 2.1 TSLint常见规则 以下规则主要来源于TSLint规则，是某些规则的简单介绍。 2.2 常用TSLint规则包 上述2.1所列出的规则来源于Palantir官方TSLint规则。实际还有多种，可能会用到的有以下： 我们在项目的规则配置过程中，一般采用上述规则包其中一种或者若干种同时配置，那如何配置呢？请看下文。 三、如何进行TSLint规则配置与检查 首先，在工程package.json文件中配置TSLint包： 在根目录中的tslint.json文件中可以根据需要配置已有规则，例如： 其中extends数组内放置继承的TSLint规则包，上图包括了airbnb配置的规则包、tslint-react的规则包，而rules用于配置规则的开关。 TSLint规则目前只有true和false的选项，这导致了结果要么正常，要么报错ERROR，而不会出现WARNING等警告。 有些时候，虽然配置某些规则开启，但是某个文件内可能会关闭某些甚至全部规则检查，这时候可以通过规则注释来配置，如： /* tslint:disable */ 上述注释表示本文件自此注释所在行开始，以下的所有区域关闭TSLint规则检查。 /* tslint:enable */ 上述注释表示本文件自此注释所在行开始，以下的所有区域开启TSLint规则检查。 /* tslint:disable:rule1 rule2 rule3... */ 上述注释表示本文件自此注释所在行开始，以下的所有区域关闭规则rule1 rule2 rule3...的检查。 /* tslint:enable:rule1 rule2 rule3... */ 上述注释表示本文件自此注释所在行开始，以下的所有区域开启规则rule1 rule2 rule3...的检查。 // tslint:disable-next-line 上述注释表示此注释所在行的下一行关闭TSLint规则检查。 someCode(); // tslint:disable-line 上述注释表示此注释所在行关闭TSLint规则检查。 // tslint:disable-next-line:rule1 rule2 rule3... 上述注释表示此注释所在行的下一行关闭规则rule1 rule2 rule3...的检查检查。 以上配置信息，这里具体参考了https://palantir.github.io/tslint/usage/rule-flags/。 3.1 本地检查 在完成工程配置后，需要下载所需要依赖包，要在工程所在根目录使用npm install命令完成下载依赖包。 IDE环境提示 在完成下载依赖包后，IDE环境可以根据对应配置文件进行提示，可以实时地提示出存在问题代码的错误信息，以VSCode为例： 本地命令检查 VSCode目前还有继续完善的空间，如果部分文件未在窗口打开的情况下，可能存在其中错误未提示出的情况，这时候，我们可以通过本地命令进行全工程的检查，在React Native工程的根目录下，通过以下命令行执行： tslint --project tsconfig.json --config tslint.json （此命令如果不正确运行，可在之前加入./node_modules/.bin/）即为： ./node_modules/.bin/tslint --project tsconfig.json --config tslint.json 从而会提示出类似以下错误的信息： src/Components/test.ts[1, 7]: Class name must be in pascal case 3.2 在线CI检查 本地进行代码检查的过程也会存在被人遗忘的可能性，通过技术的保障，可以避免人为遗忘，作为代码提交的标准流程，通过CI检查后再合并代码，可以有效避免代码错误的问题。CI系统可以为理解为一个云端的环境，环境配置与本地一致，在这种情况下，可以生成与本地一致的报告，在美团内部可以使用基于Jenkins的Castle CI系统， 生成结果与本地结果一致： 3.3 其他方式 代码检查不止局限上述阶段，在代码commit、pull request、打包等阶段均可触发。 代码commit阶段，通过Hook方式可以触发代码检查，可以有效地将在线CI检查阶段强制提前，基本保证了在线CI检查的完全正确性。 代码pull request阶段，通过在线CI检查可以触发代码检查，可以有效保证合入分支尤其是主分支的正确性。 代码打包阶段，通过在线CI检查可以触发代码检查，可以有效保证打包代码的正确性。 四、自定义编写TSLint规则 4.1 为什么要自定义TSLint规则 当前的TSLint规则虽然涵盖了比较普遍问题的一些代码检查，但是实践中还是存在一些问题的： 团队中的个性化需求难以满足。例如，saga中的异步函数需要在最外层加try-catch，且catch块中需要加异常上报，这个明显在官方的TSLint规则无法实现，为此需要自定义的开发。 官方规则的开启与配置不符合当前团队情况。 基于以上原因其他团队也有自定义TSLint的先例，例如上文提到的tslint-microsoft-contrib、tslint-eslint-rules等。 4.2 自定义规则步骤 那自定义TSLint大概需要什么步骤呢，首先规则文件根据规范进行按部就班的编写规则信息，然后根据代码检查逻辑对语法树进行分析并编写逻辑代码，这也是自定义规则的核心部分了，最后就是自定义规则的使用了。 自定义规则的示例直接参考官方的规则是最直接的，我们能这里参考一个比较简单的规则&quot;class-name&quot;。 &quot;class-name&quot;规则上文已经提到，它的意思是对类命名进行规范，当团队中类相关的命名不规范，会导致项目代码风格不统一甚至其他出现的问题，而&quot;class-name&quot;规则可以有效解决这个问题。我们可以看下具体的源码文件：https://github.com/palantir/tslint/blob/master/src/rules/classNameRule.ts。 然后将分步对此自定义规则进行讲解。 第一步，文件命名 规则命名必须是符合以下2个规则： 驼峰命名。 以&#39;Rule&#39;为后缀。 第二步，类命名 规则的类名是Rule，并且要继承Lint.Rules.AbstractRule这个类型，当然也可能有继承TypedRule这个类的时候，但是我们通过阅读源码发现，其实它也是继承自Lint.Rules.AbstractRule这个类。 第三步，填写metadata信息 metadata包含了配置参数，定义了规则的信息以及配置规则的定义。 ruleName 是规则名，使用烤串命名法，一般是将类名转为烤串命名格式。 description 一个简短的规则说明。 descriptionDetails 详细的规则说明。 rationale 理论基础。 options 配置参数形式，如果没有可以配置为null。 optionExamples 参数范例 ，如没有参数无需配置。 typescriptOnly true/false 是否只适用于TypeScript。 hasFix true/false 是否带有修复方式。 requiresTypeInfo 是否需要类型信息。 optionsDescrition options的介绍。 type 规则的类型。 规则类型有四种，分别为：&quot;functionality&quot;、&quot;maintainability&quot;、&quot;style&quot;、&quot;typescript&quot;。 functionality ： 针对于语句问题以及功能问题。 maintainability：主要以代码简洁、可读、可维护为目标的规则。 style：以维护代码风格基本统一的规则。 typescript：针对于TypeScript进行提示。 第四步，定义错误提示信息 这个主要是在检查出问题的时候进行提示的文字，并不局限于使用一个静态变量的形式，但是大部分官方规则都是这么编写，这里对此进行介绍，防止引起歧义。 第五步，实现apply方法 apply主要是进行静态检查的核心方法，通过返回applyWithFunction方法或者返回applyWithWalker来进行代码检查，其实applyWithFunction方法与applyWithWalker方法的主要区别在于applyWithWalker可以通过IWalker实现一个自定义的IWalker类，区别如下： 其中实现IWalker的抽象类AbstractWalker里面也继承了WalkContext， 而这个WalkContext就是上面提到的applyWithFunction的内部实现类。 第六步，语法树解析 无论是applyWithFunction方法还是applyWithWalker方法中的IWalker实现都传入了sourceFile这个参数，这个相当于文件的根节点，然后通过ts.forEachChild方法遍历整个语法树节点。 这里有两个查看AST语法树的工具： AST Explorer：&nbsp;https://astexplorer.net/对应源码：https://github.com/fkling/astexplorer TypeScript AST Viewer：&nbsp;https://ts-ast-viewer.com/对应源码：https://github.com/dsherret/ts-ast-viewer AST Explorer 优点： 在AST Explorer可以高亮显示所选中代码对应的AST语法树信息。 缺点： 1. 不能选择对应版本的解析器，导致显示的语法树代码版本固定。 2. 语法树显示的信息相对较少。 TypeScript AST Viewer 优点： 1. 解析器对应版本可以动态选择： 2. 语法树显示的信息不仅显示对应的数字代码，还可为对应的实际信息： 每个版本对应对kind信息数值可能会变动，但是对应的枚举名字是固定的，如下图： 从而这个工具可以避免频繁根据其数值查找对应信息。 缺点：不能高亮显示代码对应的AST语法树区域，定位效率较低。 综上，通过同时使用上述两个工具定位分析，可以有效地提高分析效率。 第七步，规则代码编写 通过ts.forEachChild方法对于语法树所有的节点进行遍历，在遍历的方法里可以实现自己的逻辑，其中节点的类为ts.Node： 其中kind为当前节点的类型，当然Node是所有节点的基类，它的实现还包括Statement、Expression、Declaration等，回到开头这个&quot;class-name&quot;规则，我们的所有声明类主要是class与interface关键字，分别对应ClassExpression、ClassDeclaration、InterfaceDeclaration， 我们可以通过上步提到的AST语法树工具，在语法树中看到其为一一对应的。 在规则代码中主要通过isClassLikeDeclaration、isInterfaceDeclaration这两个方法进行判断的。 其中isClassLikeDeclaration、isInterfaceDeclaration对应的方法我们可以在node.js文件中找到： 判断是对应的类型时，调用addFailureAtNode方法把错误信息和节点传入，当然还可以调用addFailureAt、addFailure方法。 最终这个规则编写结束了，有一点再次强调下，因为每个版本所对应的类型代码可能不相同，当判断kind的时候，一定不要直接使用各个类型对应的数字。 第八步，规则配置使用 完成规则代码后，是ts后缀的文件，而ts规则文件实际还是要用js文件，这时候我们需要用命令将ts转化为js文件： tsc ./src/*.ts --outDir dist 将ts规则生成到dist文件夹（这个文件夹命名用户自定），然后在tslint.json文件中配置生成的规则文件即可。 之后在项目的根目录里面，使用以下命令既可进行检查： tslint --project tsconfig.json --config tslint.json 同时为了未来新增规则以及规则配置的更好的操作性，建议可以封装到自己的规则包，以便与规则的管理与传播。 总结 TSLint的优点： 速度快。相对于动态代码检查，检查速度较快，现有项目无论是在本地检查，还是在CI检查，对于由十余个页面组成的React Native工程，可以在1到2分钟内完成； 灵活。通过配置规则，可以有效地避免常见代码错误与潜在的Bug； 易扩展。通过编写配置自定义规则，可以及时准确快速查找出代码中特定风险点。 TSLint缺点： 规则的结果只有对与错两种等级结果，没有警告等级的的提示结果； 无法直接报告规则报错数量，只能依赖其他手段统计； TSLint规则针对于当前单一文件可以有效地通过语法树进行分析判定，但对于引用到的其他文件中的变量、类、方法等，则难以通过AST语法树进行判定。 使用结果及分析 在美团，有十余个页面的单个工程首次接入TSLint后，检查出的问题有近百条。但是由于开启的规则不同，配置规则包的差异，检查后的数量可能为几十条到几千条甚至更多。现在已开发十余条自定义规则，在单个工程内，处理优化了数百处可能存在问题的代码。最终TSLint接入了相关React Native开发团队，成为了代码提交阶段的必要步骤。 通过团队内部的验证，文章开头遇到的问题得到了有效地缓解，目标基本达到预期。TSLint在React Native开发过程中既保证了代码风格的统一，又保证了React Native开发人员的开发质量，避免了许多低级错误，有效地节省了问题排查和人员沟通的成本。 同时利用自定义规则，能够将一些兼容性问题在内的个性化问题进行总结与预防，提高了开发效率，不用花费大量时间查找问题代码，又避免了在一个问题上跌倒多次的情况出现。对于不同经验的开发者而言，不仅可以进行友好的提示，也可以帮助快速地定位问题，将一个人遇到的经验教训，用极低的成本扩散到其他团队之中，将开发状态从“亡羊补牢”进化到“防患未然”。 作者简介 家正，美团点评Android高级工程师。2017 年加入美团点评，负责美团大交通的业务开发。 欢迎加入美团Web前端技术交流群，跟项目维护者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：前端，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 客户端单周发版下的多分支自动化管理与实践 beeshell：开源的React Native组件库 函数式编程在Redux/React中的应用" />
<meta property="og:description" content="总第329篇 2019年 第007篇 TSLint为TypeScript提供了代码检查能力，对使用TypeScript的React Native工程，在规范性、安全性、可靠性、可维护性等方面起到重要作用。本文主要对TSLint相关知识进行分享，并对自定义TSLint规则进行介绍。 建立的代码规范没人遵守，项目中遍地风格迥异的代码，你会不会抓狂？ 通过测试用例的程序还会出现Bug，而原因仅仅是自己犯下的低级错误，你会不会抓狂？ 某种代码写法存在问题导致崩溃时，只能全工程检查代码，这需要人工花费大量时间Review代码，你会不会抓狂？ 以上这些问题，可以通过静态检查有效地缓解！ 静态检查（Static Program Analysis）主要是以不运行程序的方式对于程序源代码进行检查分析的技术，而与之相反的就是动态检查（Dynamic Program Analysis），通过实际运行程序输入测试数据产生预期结果的技术。通过代码静态检查，我们可以快速定位代码的错误与缺陷，可以减少逐行阅读代码浪费的时间，可以（根据需要）快速扫描代码中可能存在的漏洞等。代码静态检查可以在代码的规范性、安全性、可靠性、可维护性等方面起到重要作用。 在客户端中，Android可以使用CheckStyle、Lint、Findbugs、PMD等工具，iOS可以使用Clang Static Analyzer、OCLint等工具。而在React Native的开发过程中，针对于JavaScript的ESLint，与TypeScript的TSLint，则成为了主要代码静态检查的工具。本文将按照使用TSLint的原因、使用TSLint的方法、自定义TSLint的步骤进行探究分析。 一、使用TSLint的原因 在客户端团队进入React Native项目的开发过程中，面临着如下问题： 由于大家从客户端转入到React Native开发过程中，容易出现低级语法错误； 开发者之前从事Android、iOS、前端等工作，因此代码风格不同，导致项目代码风格不统一； 客户端效果不一致，有可能Android端显示正常、iOS端显示异常，或者相反的情况出现。 虽然以上问题可以通过多次不断将雷点标记出，并不断地分享经验与强化代码Review过程等方式来进行缓解，但是仍面临着React Native开发者掌握的技术水平千差万别，知识分享传播的速度缓慢等问题，既导致了开发成本的不断增加和开发效率持续低下的问题，还难以避免一个坑被踩了多次的情况出现。这时急需一款可以满足以下目标的工具： 可检测代码低级语法错误； 规范项目代码风格； 根据需要可自定义检查代码的逻辑； 工具使用者可以“傻瓜式”的接入部署到开发IDE环境； 可以快速高效地将检查工具最新检查逻辑同步到开发IDE环境中； 对于检查出的问题可以快速定位。 根据上述要求的描述，静态检查工具TSLint可以较为有效地达成目标。 二、TSLint介绍 TSLint是硅谷企业Palantir的一个项目，它是一款可以检查TypeScript代码可读性、可维护性以及功能性错误的静态检查工具，当前许多编辑器（Editors）和构建系统（Build Systems）支持这一工具，同时支持自定义编写Lint规则、配置、格式化等。 当前TSLint已经包含了上百条规则，这些规则构筑了当前TSLint检查的基础。在代码开发阶段中，通过这些配置好的规则可以给工程一个完整的检查，并随时可以提示出可能存在的问题。本文内容参考了TSLint官方文档https://palantir.github.io/tslint/。 2.1 TSLint常见规则 以下规则主要来源于TSLint规则，是某些规则的简单介绍。 2.2 常用TSLint规则包 上述2.1所列出的规则来源于Palantir官方TSLint规则。实际还有多种，可能会用到的有以下： 我们在项目的规则配置过程中，一般采用上述规则包其中一种或者若干种同时配置，那如何配置呢？请看下文。 三、如何进行TSLint规则配置与检查 首先，在工程package.json文件中配置TSLint包： 在根目录中的tslint.json文件中可以根据需要配置已有规则，例如： 其中extends数组内放置继承的TSLint规则包，上图包括了airbnb配置的规则包、tslint-react的规则包，而rules用于配置规则的开关。 TSLint规则目前只有true和false的选项，这导致了结果要么正常，要么报错ERROR，而不会出现WARNING等警告。 有些时候，虽然配置某些规则开启，但是某个文件内可能会关闭某些甚至全部规则检查，这时候可以通过规则注释来配置，如： /* tslint:disable */ 上述注释表示本文件自此注释所在行开始，以下的所有区域关闭TSLint规则检查。 /* tslint:enable */ 上述注释表示本文件自此注释所在行开始，以下的所有区域开启TSLint规则检查。 /* tslint:disable:rule1 rule2 rule3... */ 上述注释表示本文件自此注释所在行开始，以下的所有区域关闭规则rule1 rule2 rule3...的检查。 /* tslint:enable:rule1 rule2 rule3... */ 上述注释表示本文件自此注释所在行开始，以下的所有区域开启规则rule1 rule2 rule3...的检查。 // tslint:disable-next-line 上述注释表示此注释所在行的下一行关闭TSLint规则检查。 someCode(); // tslint:disable-line 上述注释表示此注释所在行关闭TSLint规则检查。 // tslint:disable-next-line:rule1 rule2 rule3... 上述注释表示此注释所在行的下一行关闭规则rule1 rule2 rule3...的检查检查。 以上配置信息，这里具体参考了https://palantir.github.io/tslint/usage/rule-flags/。 3.1 本地检查 在完成工程配置后，需要下载所需要依赖包，要在工程所在根目录使用npm install命令完成下载依赖包。 IDE环境提示 在完成下载依赖包后，IDE环境可以根据对应配置文件进行提示，可以实时地提示出存在问题代码的错误信息，以VSCode为例： 本地命令检查 VSCode目前还有继续完善的空间，如果部分文件未在窗口打开的情况下，可能存在其中错误未提示出的情况，这时候，我们可以通过本地命令进行全工程的检查，在React Native工程的根目录下，通过以下命令行执行： tslint --project tsconfig.json --config tslint.json （此命令如果不正确运行，可在之前加入./node_modules/.bin/）即为： ./node_modules/.bin/tslint --project tsconfig.json --config tslint.json 从而会提示出类似以下错误的信息： src/Components/test.ts[1, 7]: Class name must be in pascal case 3.2 在线CI检查 本地进行代码检查的过程也会存在被人遗忘的可能性，通过技术的保障，可以避免人为遗忘，作为代码提交的标准流程，通过CI检查后再合并代码，可以有效避免代码错误的问题。CI系统可以为理解为一个云端的环境，环境配置与本地一致，在这种情况下，可以生成与本地一致的报告，在美团内部可以使用基于Jenkins的Castle CI系统， 生成结果与本地结果一致： 3.3 其他方式 代码检查不止局限上述阶段，在代码commit、pull request、打包等阶段均可触发。 代码commit阶段，通过Hook方式可以触发代码检查，可以有效地将在线CI检查阶段强制提前，基本保证了在线CI检查的完全正确性。 代码pull request阶段，通过在线CI检查可以触发代码检查，可以有效保证合入分支尤其是主分支的正确性。 代码打包阶段，通过在线CI检查可以触发代码检查，可以有效保证打包代码的正确性。 四、自定义编写TSLint规则 4.1 为什么要自定义TSLint规则 当前的TSLint规则虽然涵盖了比较普遍问题的一些代码检查，但是实践中还是存在一些问题的： 团队中的个性化需求难以满足。例如，saga中的异步函数需要在最外层加try-catch，且catch块中需要加异常上报，这个明显在官方的TSLint规则无法实现，为此需要自定义的开发。 官方规则的开启与配置不符合当前团队情况。 基于以上原因其他团队也有自定义TSLint的先例，例如上文提到的tslint-microsoft-contrib、tslint-eslint-rules等。 4.2 自定义规则步骤 那自定义TSLint大概需要什么步骤呢，首先规则文件根据规范进行按部就班的编写规则信息，然后根据代码检查逻辑对语法树进行分析并编写逻辑代码，这也是自定义规则的核心部分了，最后就是自定义规则的使用了。 自定义规则的示例直接参考官方的规则是最直接的，我们能这里参考一个比较简单的规则&quot;class-name&quot;。 &quot;class-name&quot;规则上文已经提到，它的意思是对类命名进行规范，当团队中类相关的命名不规范，会导致项目代码风格不统一甚至其他出现的问题，而&quot;class-name&quot;规则可以有效解决这个问题。我们可以看下具体的源码文件：https://github.com/palantir/tslint/blob/master/src/rules/classNameRule.ts。 然后将分步对此自定义规则进行讲解。 第一步，文件命名 规则命名必须是符合以下2个规则： 驼峰命名。 以&#39;Rule&#39;为后缀。 第二步，类命名 规则的类名是Rule，并且要继承Lint.Rules.AbstractRule这个类型，当然也可能有继承TypedRule这个类的时候，但是我们通过阅读源码发现，其实它也是继承自Lint.Rules.AbstractRule这个类。 第三步，填写metadata信息 metadata包含了配置参数，定义了规则的信息以及配置规则的定义。 ruleName 是规则名，使用烤串命名法，一般是将类名转为烤串命名格式。 description 一个简短的规则说明。 descriptionDetails 详细的规则说明。 rationale 理论基础。 options 配置参数形式，如果没有可以配置为null。 optionExamples 参数范例 ，如没有参数无需配置。 typescriptOnly true/false 是否只适用于TypeScript。 hasFix true/false 是否带有修复方式。 requiresTypeInfo 是否需要类型信息。 optionsDescrition options的介绍。 type 规则的类型。 规则类型有四种，分别为：&quot;functionality&quot;、&quot;maintainability&quot;、&quot;style&quot;、&quot;typescript&quot;。 functionality ： 针对于语句问题以及功能问题。 maintainability：主要以代码简洁、可读、可维护为目标的规则。 style：以维护代码风格基本统一的规则。 typescript：针对于TypeScript进行提示。 第四步，定义错误提示信息 这个主要是在检查出问题的时候进行提示的文字，并不局限于使用一个静态变量的形式，但是大部分官方规则都是这么编写，这里对此进行介绍，防止引起歧义。 第五步，实现apply方法 apply主要是进行静态检查的核心方法，通过返回applyWithFunction方法或者返回applyWithWalker来进行代码检查，其实applyWithFunction方法与applyWithWalker方法的主要区别在于applyWithWalker可以通过IWalker实现一个自定义的IWalker类，区别如下： 其中实现IWalker的抽象类AbstractWalker里面也继承了WalkContext， 而这个WalkContext就是上面提到的applyWithFunction的内部实现类。 第六步，语法树解析 无论是applyWithFunction方法还是applyWithWalker方法中的IWalker实现都传入了sourceFile这个参数，这个相当于文件的根节点，然后通过ts.forEachChild方法遍历整个语法树节点。 这里有两个查看AST语法树的工具： AST Explorer：&nbsp;https://astexplorer.net/对应源码：https://github.com/fkling/astexplorer TypeScript AST Viewer：&nbsp;https://ts-ast-viewer.com/对应源码：https://github.com/dsherret/ts-ast-viewer AST Explorer 优点： 在AST Explorer可以高亮显示所选中代码对应的AST语法树信息。 缺点： 1. 不能选择对应版本的解析器，导致显示的语法树代码版本固定。 2. 语法树显示的信息相对较少。 TypeScript AST Viewer 优点： 1. 解析器对应版本可以动态选择： 2. 语法树显示的信息不仅显示对应的数字代码，还可为对应的实际信息： 每个版本对应对kind信息数值可能会变动，但是对应的枚举名字是固定的，如下图： 从而这个工具可以避免频繁根据其数值查找对应信息。 缺点：不能高亮显示代码对应的AST语法树区域，定位效率较低。 综上，通过同时使用上述两个工具定位分析，可以有效地提高分析效率。 第七步，规则代码编写 通过ts.forEachChild方法对于语法树所有的节点进行遍历，在遍历的方法里可以实现自己的逻辑，其中节点的类为ts.Node： 其中kind为当前节点的类型，当然Node是所有节点的基类，它的实现还包括Statement、Expression、Declaration等，回到开头这个&quot;class-name&quot;规则，我们的所有声明类主要是class与interface关键字，分别对应ClassExpression、ClassDeclaration、InterfaceDeclaration， 我们可以通过上步提到的AST语法树工具，在语法树中看到其为一一对应的。 在规则代码中主要通过isClassLikeDeclaration、isInterfaceDeclaration这两个方法进行判断的。 其中isClassLikeDeclaration、isInterfaceDeclaration对应的方法我们可以在node.js文件中找到： 判断是对应的类型时，调用addFailureAtNode方法把错误信息和节点传入，当然还可以调用addFailureAt、addFailure方法。 最终这个规则编写结束了，有一点再次强调下，因为每个版本所对应的类型代码可能不相同，当判断kind的时候，一定不要直接使用各个类型对应的数字。 第八步，规则配置使用 完成规则代码后，是ts后缀的文件，而ts规则文件实际还是要用js文件，这时候我们需要用命令将ts转化为js文件： tsc ./src/*.ts --outDir dist 将ts规则生成到dist文件夹（这个文件夹命名用户自定），然后在tslint.json文件中配置生成的规则文件即可。 之后在项目的根目录里面，使用以下命令既可进行检查： tslint --project tsconfig.json --config tslint.json 同时为了未来新增规则以及规则配置的更好的操作性，建议可以封装到自己的规则包，以便与规则的管理与传播。 总结 TSLint的优点： 速度快。相对于动态代码检查，检查速度较快，现有项目无论是在本地检查，还是在CI检查，对于由十余个页面组成的React Native工程，可以在1到2分钟内完成； 灵活。通过配置规则，可以有效地避免常见代码错误与潜在的Bug； 易扩展。通过编写配置自定义规则，可以及时准确快速查找出代码中特定风险点。 TSLint缺点： 规则的结果只有对与错两种等级结果，没有警告等级的的提示结果； 无法直接报告规则报错数量，只能依赖其他手段统计； TSLint规则针对于当前单一文件可以有效地通过语法树进行分析判定，但对于引用到的其他文件中的变量、类、方法等，则难以通过AST语法树进行判定。 使用结果及分析 在美团，有十余个页面的单个工程首次接入TSLint后，检查出的问题有近百条。但是由于开启的规则不同，配置规则包的差异，检查后的数量可能为几十条到几千条甚至更多。现在已开发十余条自定义规则，在单个工程内，处理优化了数百处可能存在问题的代码。最终TSLint接入了相关React Native开发团队，成为了代码提交阶段的必要步骤。 通过团队内部的验证，文章开头遇到的问题得到了有效地缓解，目标基本达到预期。TSLint在React Native开发过程中既保证了代码风格的统一，又保证了React Native开发人员的开发质量，避免了许多低级错误，有效地节省了问题排查和人员沟通的成本。 同时利用自定义规则，能够将一些兼容性问题在内的个性化问题进行总结与预防，提高了开发效率，不用花费大量时间查找问题代码，又避免了在一个问题上跌倒多次的情况出现。对于不同经验的开发者而言，不仅可以进行友好的提示，也可以帮助快速地定位问题，将一个人遇到的经验教训，用极低的成本扩散到其他团队之中，将开发状态从“亡羊补牢”进化到“防患未然”。 作者简介 家正，美团点评Android高级工程师。2017 年加入美团点评，负责美团大交通的业务开发。 欢迎加入美团Web前端技术交流群，跟项目维护者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：前端，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 客户端单周发版下的多分支自动化管理与实践 beeshell：开源的React Native组件库 函数式编程在Redux/React中的应用" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"总第329篇 2019年 第007篇 TSLint为TypeScript提供了代码检查能力，对使用TypeScript的React Native工程，在规范性、安全性、可靠性、可维护性等方面起到重要作用。本文主要对TSLint相关知识进行分享，并对自定义TSLint规则进行介绍。 建立的代码规范没人遵守，项目中遍地风格迥异的代码，你会不会抓狂？ 通过测试用例的程序还会出现Bug，而原因仅仅是自己犯下的低级错误，你会不会抓狂？ 某种代码写法存在问题导致崩溃时，只能全工程检查代码，这需要人工花费大量时间Review代码，你会不会抓狂？ 以上这些问题，可以通过静态检查有效地缓解！ 静态检查（Static Program Analysis）主要是以不运行程序的方式对于程序源代码进行检查分析的技术，而与之相反的就是动态检查（Dynamic Program Analysis），通过实际运行程序输入测试数据产生预期结果的技术。通过代码静态检查，我们可以快速定位代码的错误与缺陷，可以减少逐行阅读代码浪费的时间，可以（根据需要）快速扫描代码中可能存在的漏洞等。代码静态检查可以在代码的规范性、安全性、可靠性、可维护性等方面起到重要作用。 在客户端中，Android可以使用CheckStyle、Lint、Findbugs、PMD等工具，iOS可以使用Clang Static Analyzer、OCLint等工具。而在React Native的开发过程中，针对于JavaScript的ESLint，与TypeScript的TSLint，则成为了主要代码静态检查的工具。本文将按照使用TSLint的原因、使用TSLint的方法、自定义TSLint的步骤进行探究分析。 一、使用TSLint的原因 在客户端团队进入React Native项目的开发过程中，面临着如下问题： 由于大家从客户端转入到React Native开发过程中，容易出现低级语法错误； 开发者之前从事Android、iOS、前端等工作，因此代码风格不同，导致项目代码风格不统一； 客户端效果不一致，有可能Android端显示正常、iOS端显示异常，或者相反的情况出现。 虽然以上问题可以通过多次不断将雷点标记出，并不断地分享经验与强化代码Review过程等方式来进行缓解，但是仍面临着React Native开发者掌握的技术水平千差万别，知识分享传播的速度缓慢等问题，既导致了开发成本的不断增加和开发效率持续低下的问题，还难以避免一个坑被踩了多次的情况出现。这时急需一款可以满足以下目标的工具： 可检测代码低级语法错误； 规范项目代码风格； 根据需要可自定义检查代码的逻辑； 工具使用者可以“傻瓜式”的接入部署到开发IDE环境； 可以快速高效地将检查工具最新检查逻辑同步到开发IDE环境中； 对于检查出的问题可以快速定位。 根据上述要求的描述，静态检查工具TSLint可以较为有效地达成目标。 二、TSLint介绍 TSLint是硅谷企业Palantir的一个项目，它是一款可以检查TypeScript代码可读性、可维护性以及功能性错误的静态检查工具，当前许多编辑器（Editors）和构建系统（Build Systems）支持这一工具，同时支持自定义编写Lint规则、配置、格式化等。 当前TSLint已经包含了上百条规则，这些规则构筑了当前TSLint检查的基础。在代码开发阶段中，通过这些配置好的规则可以给工程一个完整的检查，并随时可以提示出可能存在的问题。本文内容参考了TSLint官方文档https://palantir.github.io/tslint/。 2.1 TSLint常见规则 以下规则主要来源于TSLint规则，是某些规则的简单介绍。 2.2 常用TSLint规则包 上述2.1所列出的规则来源于Palantir官方TSLint规则。实际还有多种，可能会用到的有以下： 我们在项目的规则配置过程中，一般采用上述规则包其中一种或者若干种同时配置，那如何配置呢？请看下文。 三、如何进行TSLint规则配置与检查 首先，在工程package.json文件中配置TSLint包： 在根目录中的tslint.json文件中可以根据需要配置已有规则，例如： 其中extends数组内放置继承的TSLint规则包，上图包括了airbnb配置的规则包、tslint-react的规则包，而rules用于配置规则的开关。 TSLint规则目前只有true和false的选项，这导致了结果要么正常，要么报错ERROR，而不会出现WARNING等警告。 有些时候，虽然配置某些规则开启，但是某个文件内可能会关闭某些甚至全部规则检查，这时候可以通过规则注释来配置，如： /* tslint:disable */ 上述注释表示本文件自此注释所在行开始，以下的所有区域关闭TSLint规则检查。 /* tslint:enable */ 上述注释表示本文件自此注释所在行开始，以下的所有区域开启TSLint规则检查。 /* tslint:disable:rule1 rule2 rule3... */ 上述注释表示本文件自此注释所在行开始，以下的所有区域关闭规则rule1 rule2 rule3...的检查。 /* tslint:enable:rule1 rule2 rule3... */ 上述注释表示本文件自此注释所在行开始，以下的所有区域开启规则rule1 rule2 rule3...的检查。 // tslint:disable-next-line 上述注释表示此注释所在行的下一行关闭TSLint规则检查。 someCode(); // tslint:disable-line 上述注释表示此注释所在行关闭TSLint规则检查。 // tslint:disable-next-line:rule1 rule2 rule3... 上述注释表示此注释所在行的下一行关闭规则rule1 rule2 rule3...的检查检查。 以上配置信息，这里具体参考了https://palantir.github.io/tslint/usage/rule-flags/。 3.1 本地检查 在完成工程配置后，需要下载所需要依赖包，要在工程所在根目录使用npm install命令完成下载依赖包。 IDE环境提示 在完成下载依赖包后，IDE环境可以根据对应配置文件进行提示，可以实时地提示出存在问题代码的错误信息，以VSCode为例： 本地命令检查 VSCode目前还有继续完善的空间，如果部分文件未在窗口打开的情况下，可能存在其中错误未提示出的情况，这时候，我们可以通过本地命令进行全工程的检查，在React Native工程的根目录下，通过以下命令行执行： tslint --project tsconfig.json --config tslint.json （此命令如果不正确运行，可在之前加入./node_modules/.bin/）即为： ./node_modules/.bin/tslint --project tsconfig.json --config tslint.json 从而会提示出类似以下错误的信息： src/Components/test.ts[1, 7]: Class name must be in pascal case 3.2 在线CI检查 本地进行代码检查的过程也会存在被人遗忘的可能性，通过技术的保障，可以避免人为遗忘，作为代码提交的标准流程，通过CI检查后再合并代码，可以有效避免代码错误的问题。CI系统可以为理解为一个云端的环境，环境配置与本地一致，在这种情况下，可以生成与本地一致的报告，在美团内部可以使用基于Jenkins的Castle CI系统， 生成结果与本地结果一致： 3.3 其他方式 代码检查不止局限上述阶段，在代码commit、pull request、打包等阶段均可触发。 代码commit阶段，通过Hook方式可以触发代码检查，可以有效地将在线CI检查阶段强制提前，基本保证了在线CI检查的完全正确性。 代码pull request阶段，通过在线CI检查可以触发代码检查，可以有效保证合入分支尤其是主分支的正确性。 代码打包阶段，通过在线CI检查可以触发代码检查，可以有效保证打包代码的正确性。 四、自定义编写TSLint规则 4.1 为什么要自定义TSLint规则 当前的TSLint规则虽然涵盖了比较普遍问题的一些代码检查，但是实践中还是存在一些问题的： 团队中的个性化需求难以满足。例如，saga中的异步函数需要在最外层加try-catch，且catch块中需要加异常上报，这个明显在官方的TSLint规则无法实现，为此需要自定义的开发。 官方规则的开启与配置不符合当前团队情况。 基于以上原因其他团队也有自定义TSLint的先例，例如上文提到的tslint-microsoft-contrib、tslint-eslint-rules等。 4.2 自定义规则步骤 那自定义TSLint大概需要什么步骤呢，首先规则文件根据规范进行按部就班的编写规则信息，然后根据代码检查逻辑对语法树进行分析并编写逻辑代码，这也是自定义规则的核心部分了，最后就是自定义规则的使用了。 自定义规则的示例直接参考官方的规则是最直接的，我们能这里参考一个比较简单的规则&quot;class-name&quot;。 &quot;class-name&quot;规则上文已经提到，它的意思是对类命名进行规范，当团队中类相关的命名不规范，会导致项目代码风格不统一甚至其他出现的问题，而&quot;class-name&quot;规则可以有效解决这个问题。我们可以看下具体的源码文件：https://github.com/palantir/tslint/blob/master/src/rules/classNameRule.ts。 然后将分步对此自定义规则进行讲解。 第一步，文件命名 规则命名必须是符合以下2个规则： 驼峰命名。 以&#39;Rule&#39;为后缀。 第二步，类命名 规则的类名是Rule，并且要继承Lint.Rules.AbstractRule这个类型，当然也可能有继承TypedRule这个类的时候，但是我们通过阅读源码发现，其实它也是继承自Lint.Rules.AbstractRule这个类。 第三步，填写metadata信息 metadata包含了配置参数，定义了规则的信息以及配置规则的定义。 ruleName 是规则名，使用烤串命名法，一般是将类名转为烤串命名格式。 description 一个简短的规则说明。 descriptionDetails 详细的规则说明。 rationale 理论基础。 options 配置参数形式，如果没有可以配置为null。 optionExamples 参数范例 ，如没有参数无需配置。 typescriptOnly true/false 是否只适用于TypeScript。 hasFix true/false 是否带有修复方式。 requiresTypeInfo 是否需要类型信息。 optionsDescrition options的介绍。 type 规则的类型。 规则类型有四种，分别为：&quot;functionality&quot;、&quot;maintainability&quot;、&quot;style&quot;、&quot;typescript&quot;。 functionality ： 针对于语句问题以及功能问题。 maintainability：主要以代码简洁、可读、可维护为目标的规则。 style：以维护代码风格基本统一的规则。 typescript：针对于TypeScript进行提示。 第四步，定义错误提示信息 这个主要是在检查出问题的时候进行提示的文字，并不局限于使用一个静态变量的形式，但是大部分官方规则都是这么编写，这里对此进行介绍，防止引起歧义。 第五步，实现apply方法 apply主要是进行静态检查的核心方法，通过返回applyWithFunction方法或者返回applyWithWalker来进行代码检查，其实applyWithFunction方法与applyWithWalker方法的主要区别在于applyWithWalker可以通过IWalker实现一个自定义的IWalker类，区别如下： 其中实现IWalker的抽象类AbstractWalker里面也继承了WalkContext， 而这个WalkContext就是上面提到的applyWithFunction的内部实现类。 第六步，语法树解析 无论是applyWithFunction方法还是applyWithWalker方法中的IWalker实现都传入了sourceFile这个参数，这个相当于文件的根节点，然后通过ts.forEachChild方法遍历整个语法树节点。 这里有两个查看AST语法树的工具： AST Explorer：&nbsp;https://astexplorer.net/对应源码：https://github.com/fkling/astexplorer TypeScript AST Viewer：&nbsp;https://ts-ast-viewer.com/对应源码：https://github.com/dsherret/ts-ast-viewer AST Explorer 优点： 在AST Explorer可以高亮显示所选中代码对应的AST语法树信息。 缺点： 1. 不能选择对应版本的解析器，导致显示的语法树代码版本固定。 2. 语法树显示的信息相对较少。 TypeScript AST Viewer 优点： 1. 解析器对应版本可以动态选择： 2. 语法树显示的信息不仅显示对应的数字代码，还可为对应的实际信息： 每个版本对应对kind信息数值可能会变动，但是对应的枚举名字是固定的，如下图： 从而这个工具可以避免频繁根据其数值查找对应信息。 缺点：不能高亮显示代码对应的AST语法树区域，定位效率较低。 综上，通过同时使用上述两个工具定位分析，可以有效地提高分析效率。 第七步，规则代码编写 通过ts.forEachChild方法对于语法树所有的节点进行遍历，在遍历的方法里可以实现自己的逻辑，其中节点的类为ts.Node： 其中kind为当前节点的类型，当然Node是所有节点的基类，它的实现还包括Statement、Expression、Declaration等，回到开头这个&quot;class-name&quot;规则，我们的所有声明类主要是class与interface关键字，分别对应ClassExpression、ClassDeclaration、InterfaceDeclaration， 我们可以通过上步提到的AST语法树工具，在语法树中看到其为一一对应的。 在规则代码中主要通过isClassLikeDeclaration、isInterfaceDeclaration这两个方法进行判断的。 其中isClassLikeDeclaration、isInterfaceDeclaration对应的方法我们可以在node.js文件中找到： 判断是对应的类型时，调用addFailureAtNode方法把错误信息和节点传入，当然还可以调用addFailureAt、addFailure方法。 最终这个规则编写结束了，有一点再次强调下，因为每个版本所对应的类型代码可能不相同，当判断kind的时候，一定不要直接使用各个类型对应的数字。 第八步，规则配置使用 完成规则代码后，是ts后缀的文件，而ts规则文件实际还是要用js文件，这时候我们需要用命令将ts转化为js文件： tsc ./src/*.ts --outDir dist 将ts规则生成到dist文件夹（这个文件夹命名用户自定），然后在tslint.json文件中配置生成的规则文件即可。 之后在项目的根目录里面，使用以下命令既可进行检查： tslint --project tsconfig.json --config tslint.json 同时为了未来新增规则以及规则配置的更好的操作性，建议可以封装到自己的规则包，以便与规则的管理与传播。 总结 TSLint的优点： 速度快。相对于动态代码检查，检查速度较快，现有项目无论是在本地检查，还是在CI检查，对于由十余个页面组成的React Native工程，可以在1到2分钟内完成； 灵活。通过配置规则，可以有效地避免常见代码错误与潜在的Bug； 易扩展。通过编写配置自定义规则，可以及时准确快速查找出代码中特定风险点。 TSLint缺点： 规则的结果只有对与错两种等级结果，没有警告等级的的提示结果； 无法直接报告规则报错数量，只能依赖其他手段统计； TSLint规则针对于当前单一文件可以有效地通过语法树进行分析判定，但对于引用到的其他文件中的变量、类、方法等，则难以通过AST语法树进行判定。 使用结果及分析 在美团，有十余个页面的单个工程首次接入TSLint后，检查出的问题有近百条。但是由于开启的规则不同，配置规则包的差异，检查后的数量可能为几十条到几千条甚至更多。现在已开发十余条自定义规则，在单个工程内，处理优化了数百处可能存在问题的代码。最终TSLint接入了相关React Native开发团队，成为了代码提交阶段的必要步骤。 通过团队内部的验证，文章开头遇到的问题得到了有效地缓解，目标基本达到预期。TSLint在React Native开发过程中既保证了代码风格的统一，又保证了React Native开发人员的开发质量，避免了许多低级错误，有效地节省了问题排查和人员沟通的成本。 同时利用自定义规则，能够将一些兼容性问题在内的个性化问题进行总结与预防，提高了开发效率，不用花费大量时间查找问题代码，又避免了在一个问题上跌倒多次的情况出现。对于不同经验的开发者而言，不仅可以进行友好的提示，也可以帮助快速地定位问题，将一个人遇到的经验教训，用极低的成本扩散到其他团队之中，将开发状态从“亡羊补牢”进化到“防患未然”。 作者简介 家正，美团点评Android高级工程师。2017 年加入美团点评，负责美团大交通的业务开发。 欢迎加入美团Web前端技术交流群，跟项目维护者零距离交流。进群方式：请加美美同学微信（微信号：MTDPtech02），回复：前端，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 也许你还想看 客户端单周发版下的多分支自动化管理与实践 beeshell：开源的React Native组件库 函数式编程在Redux/React中的应用","@type":"BlogPosting","url":"/2019/04/29/729138.html","headline":"React Native工程中TSLint静态检查工具的探索之路","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/29/729138.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>React&nbsp;Native工程中TSLint静态检查工具的探索之路</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;" data-mpa-powered-by="yiban.io"><img class="" data-copyright="0" data-ratio="0.10546875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png" data-type="png" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">总第329篇</span></strong></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">2019年 第007篇</span></strong></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;"><br></span></strong></p> 
<section data-role="outer" label="Powered by 135editor.com" style="font-size:16px;font-family:微软雅黑;"> 
 <section data-role="outer" label="Powered by 135editor.com"> 
  <section class="_135editor" data-tools="135编辑器" data-id="127" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
   <section class="_135editor" data-tools="135编辑器" data-id="127" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"> 
    <section style="margin: 60px 16px 16px;border-width: 1px;border-style: solid;border-color: rgb(235, 234, 225);text-align: center;border-radius: 8px;font-size: 18px;font-weight: inherit;text-decoration: inherit;box-sizing: border-box;"> 
     <section style="margin-top: -3.3em;margin-right: 5px;margin-left: 5px;color: inherit;"> 
      <section style="border-width: 2px;border-style: solid;border-color: rgb(235, 234, 225);box-sizing: border-box;width: 108px;clear: both;margin-right: auto;margin-left: auto;height: 108px;border-radius: 50%;box-shadow: rgb(201, 201, 201) 0px 2px 2px 2px;background-color: rgb(254, 254, 254);"> 
       <img border="0" class="" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXPiabnOCOibwq6W3OrlOJk0bticmbLiaNRY2EuaP6xLf175nvxAnroN0ycZTycP17hWOdLVy4eZylBMg/640?wx_fmt=jpeg" data-type="jpeg" data-w="800" data-width="100%" height="auto" opacity="" style="border-radius: 50%;box-sizing: border-box;color: inherit;display: inline-block;" title="undefined" width="100%" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXPiabnOCOibwq6W3OrlOJk0bticmbLiaNRY2EuaP6xLf175nvxAnroN0ycZTycP17hWOdLVy4eZylBMg/640?wx_fmt=jpeg"> 
      </section> 
     </section> 
     <section class="135brush" data-brushtype="text" data-style="text-align: left; font-size: 14px; color: inherit;" style="margin: 8px 15px;line-height: 1.4;box-sizing: border-box;color: inherit;"> 
      <p style="text-align: left;"><span style="color: #a5a5a5;font-size: 13px;">TSLint为TypeScript提供了代码检查能力，对使用TypeScript的React Native工程，在规范性、安全性、可靠性、可维护性等方面起到重要作用。本文主要对TSLint相关知识进行分享，并对自定义TSLint规则进行介绍。</span></p> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section> 
<p style="margin: 15px 0.5em;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">建立的代码规范没人遵守，项目中遍地风格迥异的代码，你会不会抓狂？</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">通过测试用例的程序还会出现Bug，而原因仅仅是自己犯下的低级错误，你会不会抓狂？</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">某种代码写法存在问题导致崩溃时，只能全工程检查代码，这需要人工花费大量时间Review代码，你会不会抓狂？</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">以上这些问题，可以通过静态检查有效地缓解！</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">静态检查（<span style="color: rgb(136, 136, 136);">Static Program Analysis</span>）主要是以不运行程序的方式对于程序源代码进行检查分析的技术，而与之相反的就是动态检查（<span style="color: rgb(136, 136, 136);">Dynamic Program Analysis</span>），通过实际运行程序输入测试数据产生预期结果的技术。通过代码静态检查，我们可以快速定位代码的错误与缺陷，可以减少逐行阅读代码浪费的时间，可以（<span style="color: rgb(136, 136, 136);">根据需要</span>）快速扫描代码中可能存在的漏洞等。代码静态检查可以在代码的规范性、安全性、可靠性、可维护性等方面起到重要作用。</p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">在客户端中，Android可以使用CheckStyle、Lint、Findbugs、PMD等工具，iOS可以使用Clang Static Analyzer、OCLint等工具。而在React Native的开发过程中，针对于JavaScript的ESLint，与TypeScript的TSLint，则成为了主要代码静态检查的工具。本文将按照使用TSLint的原因、使用TSLint的方法、自定义TSLint的步骤进行探究分析。</p> 
<h2 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-size: 18px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="color: rgb(37, 183, 167);font-size: 20px;">一、使用TSLint的原因</span></h2> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">在客户端团队进入React Native项目的开发过程中，面临着如下问题：</p> 
<ol style="margin-left: 0.5em;margin-right: 0.5em;" class=" list-paddingleft-2"> 
 <li><p><span style="font-size: 14px;">由于大家从客户端转入到React Native开发过程中，容易出现低级语法错误；</span></p></li> 
 <li><p><span style="font-size: 14px;">开发者之前从事Android、iOS、前端等工作，因此代码风格不同，导致项目代码风格不统一；</span></p></li> 
 <li><p><span style="font-size: 14px;">客户端效果不一致，有可能Android端显示正常、iOS端显示异常，或者相反的情况出现。</span></p></li> 
</ol> 
<p style="font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin: 15px 0.5em;">虽然以上问题可以通过多次不断将雷点标记出，并不断地分享经验与强化代码Review过程等方式来进行缓解，但是仍面临着React Native开发者掌握的技术水平千差万别，知识分享传播的速度缓慢等问题，既导致了开发成本的不断增加和开发效率持续低下的问题，还难以避免一个坑被踩了多次的情况出现。这时急需一款可以满足以下目标的工具：</p> 
<ol style="margin-left: 0.5em;margin-right: 0.5em;" class=" list-paddingleft-2"> 
 <li><p><span style="font-size: 14px;">可检测代码低级语法错误；</span></p></li> 
 <li><p><span style="font-size: 14px;">规范项目代码风格；</span></p></li> 
 <li><p><span style="font-size: 14px;">根据需要可自定义检查代码的逻辑；</span></p></li> 
 <li><p><span style="font-size: 14px;">工具使用者可以“傻瓜式”的接入部署到开发IDE环境；</span></p></li> 
 <li><p><span style="font-size: 14px;">可以快速高效地将检查工具最新检查逻辑同步到开发IDE环境中；</span></p></li> 
 <li><p><span style="font-size: 14px;">对于检查出的问题可以快速定位。</span></p></li> 
</ol> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">根据上述要求的描述，静态检查工具TSLint可以较为有效地达成目标。</p> 
<h2 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-size: 18px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="color: rgb(37, 183, 167);font-size: 20px;">二、TSLint介绍</span></h2> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">TSLint是硅谷企业Palantir的一个项目，它是一款可以检查TypeScript代码可读性、可维护性以及功能性错误的静态检查工具，当前许多编辑器（<span style="color: rgb(136, 136, 136);">Editors</span>）和构建系统（<span style="color: rgb(136, 136, 136);">Build Systems</span>）支持这一工具，同时支持自定义编写Lint规则、配置、格式化等。</p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">当前TSLint已经包含了上百条规则，这些规则构筑了当前TSLint检查的基础。在代码开发阶段中，通过这些配置好的规则可以给工程一个完整的检查，并随时可以提示出可能存在的问题。本文内容参考了TSLint官方文档<a href="https://palantir.github.io/tslint/" style="color: rgb(53, 114, 176);" data-linktype="2">https://palantir.github.io/tslint/</a>。</p> 
<h3 style="margin-top: 30px;color: rgb(0, 0, 0);font-weight: bold;line-height: 1.5;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 18px;">2.1 TSLint常见规则</span></h3> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">以下规则主要来源于TSLint规则，是某些规则的简单介绍。</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="1.1874180865006554" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATTnUDEiaBT2q9D7icsw8Y7p9k85hQo7570ytmhNah7RPgLicp4gTqVWqqQ/640?wx_fmt=png" data-type="png" data-w="1526" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATTnUDEiaBT2q9D7icsw8Y7p9k85hQo7570ytmhNah7RPgLicp4gTqVWqqQ/640?wx_fmt=png"></p> 
<h3 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-weight: bold;line-height: 1.5;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="font-size: 18px;">2.2 常用TSLint规则包</span></h3> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">上述2.1所列出的规则来源于Palantir官方TSLint规则。实际还有多种，可能会用到的有以下：</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.6563814866760168" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATaIaFsx6WtZwibpG540QSc0dFNGSkJWQ9ovWp7wh3iaicIO9xPrMdY2xGQ/640?wx_fmt=png" data-type="png" data-w="1426" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATaIaFsx6WtZwibpG540QSc0dFNGSkJWQ9ovWp7wh3iaicIO9xPrMdY2xGQ/640?wx_fmt=png"></p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">我们在项目的规则配置过程中，一般采用上述规则包其中一种或者若干种同时配置，那如何配置呢？请看下文。</p> 
<h2 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-size: 18px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="color: rgb(37, 183, 167);font-size: 20px;">三、如何进行TSLint规则配置与检查</span></h2> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">首先，在工程package.json文件中配置TSLint包：</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.31134352373290425" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATkVysTFDyeq2nkqLSQ6O6jXsDXC6ZicIhOvZsg9F6Y3DTYq3rUenxtmQ/640?wx_fmt=png" data-type="png" data-w="1243" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATkVysTFDyeq2nkqLSQ6O6jXsDXC6ZicIhOvZsg9F6Y3DTYq3rUenxtmQ/640?wx_fmt=png"></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">在根目录中的tslint.json文件中可以根据需要配置已有规则，例如：</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.36599020293911827" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATM4Yh9Kb7hk4ZiaK5echsxsBecZgibeKOuXFm1qaRyDrKq2kI5mAWRzuQ/640?wx_fmt=png" data-type="png" data-w="1429" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATM4Yh9Kb7hk4ZiaK5echsxsBecZgibeKOuXFm1qaRyDrKq2kI5mAWRzuQ/640?wx_fmt=png"></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">其中extends数组内放置继承的TSLint规则包，上图包括了airbnb配置的规则包、tslint-react的规则包，而rules用于配置规则的开关。</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">TSLint规则目前只有true和false的选项，这导致了结果要么正常，要么报错ERROR，而不会出现WARNING等警告。</p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">有些时候，虽然配置某些规则开启，但是某个文件内可能会关闭某些甚至全部规则检查，这时候可以通过规则注释来配置，如：</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="hljs bash" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;">/* tslint:<span class="hljs-built_in" style="color: rgb(222, 147, 95) !important;">disable</span> */</code></pre> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">上述注释表示本文件自此注释所在行开始，以下的所有区域关闭TSLint规则检查。</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="hljs bash" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;">/* tslint:<span class="hljs-built_in" style="color: rgb(222, 147, 95) !important;">enable</span> */</code></pre> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">上述注释表示本文件自此注释所在行开始，以下的所有区域开启TSLint规则检查。</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="hljs bash" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;">/* tslint:<span class="hljs-built_in" style="color: rgb(222, 147, 95) !important;">disable</span>:rule1 rule2 rule3... */</code></pre> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">上述注释表示本文件自此注释所在行开始，以下的所有区域关闭规则rule1 rule2 rule3...的检查。</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="hljs bash" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;">/* tslint:<span class="hljs-built_in" style="color: rgb(222, 147, 95) !important;">enable</span>:rule1 rule2 rule3... */</code></pre> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">上述注释表示本文件自此注释所在行开始，以下的所有区域开启规则rule1 rule2 rule3...的检查。</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="hljs bash" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;">// tslint:<span class="hljs-built_in" style="color: rgb(222, 147, 95) !important;">disable</span>-next-line</code></pre> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">上述注释表示此注释所在行的下一行关闭TSLint规则检查。</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="hljs bash" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;">someCode(); // tslint:<span class="hljs-built_in" style="color: rgb(222, 147, 95) !important;">disable</span>-line</code></pre> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">上述注释表示此注释所在行关闭TSLint规则检查。</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="hljs bash" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;">// tslint:<span class="hljs-built_in" style="color: rgb(222, 147, 95) !important;">disable</span>-next-line:rule1 rule2 rule3...</code></pre> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">上述注释表示此注释所在行的下一行关闭规则rule1 rule2 rule3...的检查检查。</p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">以上配置信息，这里具体参考了<a href="https://palantir.github.io/tslint/usage/rule-flags/" style="color: rgb(53, 114, 176);" data-linktype="2">https://palantir.github.io/tslint/usage/rule-flags/</a>。</p> 
<h3 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-weight: bold;line-height: 1.5;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="font-size: 18px;">3.1 本地检查</span></h3> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">在完成工程配置后，需要下载所需要依赖包，要在工程所在根目录使用<code>npm install</code>命令完成下载依赖包。</p> 
<h4 style="margin: 20px 0.5em 15px;color: rgb(0, 0, 0);font-size: 14px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">IDE环境提示</h4> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">在完成下载依赖包后，IDE环境可以根据对应配置文件进行提示，可以实时地提示出存在问题代码的错误信息，以VSCode为例：</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.2896174863387978" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT3ss9bb3iabvjaTyGxqaKwrCpwFOH06c5GhE4gSZ1vQWMGBc4IW3mS7g/640?wx_fmt=png" data-type="png" data-w="1464" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT3ss9bb3iabvjaTyGxqaKwrCpwFOH06c5GhE4gSZ1vQWMGBc4IW3mS7g/640?wx_fmt=png"></p> 
<h4 style="margin: 20px 0.5em 15px;color: rgb(0, 0, 0);font-size: 14px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">本地命令检查</h4> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">VSCode目前还有继续完善的空间，如果部分文件未在窗口打开的情况下，可能存在其中错误未提示出的情况，这时候，我们可以通过本地命令进行全工程的检查，在React Native工程的根目录下，通过以下命令行执行：</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="hljs css" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;"><span class="hljs-selector-tag" style="color: rgb(129, 162, 190) !important;">tslint</span> <span class="hljs-selector-tag" style="color: rgb(129, 162, 190) !important;">--project</span> <span class="hljs-selector-tag" style="color: rgb(129, 162, 190) !important;">tsconfig</span><span class="hljs-selector-class" style="color: rgb(222, 147, 95) !important;">.json</span> <span class="hljs-selector-tag" style="color: rgb(129, 162, 190) !important;">--config</span> <span class="hljs-selector-tag" style="color: rgb(129, 162, 190) !important;">tslint</span><span class="hljs-selector-class" style="color: rgb(222, 147, 95) !important;">.json</span></code></pre> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">（<span style="color: rgb(136, 136, 136);">此命令如果不正确运行，可在之前加入./node_modules/.bin/</span>）即为：</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="hljs coffeescript" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;">.<span class="hljs-regexp" style="color: rgb(181, 189, 104) !important;">/node_modules/</span>.bin/tslint --project tsconfig.json --config tslint.json</code></pre> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">从而会提示出类似以下错误的信息：</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="lang-javascript hljs" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;">src/Components/test.ts[<span class="hljs-number" style="color: rgb(204, 102, 102) !important;">1</span>, <span class="hljs-number" style="color: rgb(204, 102, 102) !important;">7</span>]: Class name must be <span class="hljs-keyword" style="color: rgb(129, 162, 190) !important;">in</span> pascal <span class="hljs-keyword" style="color: rgb(129, 162, 190) !important;">case</span></code></pre> 
<h3 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-weight: bold;line-height: 1.5;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="font-size: 18px;">3.2 在线CI检查</span></h3> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">本地进行代码检查的过程也会存在被人遗忘的可能性，通过技术的保障，可以避免人为遗忘，作为代码提交的标准流程，通过CI检查后再合并代码，可以有效避免代码错误的问题。CI系统可以为理解为一个云端的环境，环境配置与本地一致，在这种情况下，可以生成与本地一致的报告，在美团内部可以使用基于Jenkins的Castle CI系统， 生成结果与本地结果一致：</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.13953488372093023" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATicYLN5Aj6tiaFthhMM14HSSuibuiaia8ORywgickUmV622pw8Sj2u3YcA09w/640?wx_fmt=png" data-type="png" data-w="1892" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATicYLN5Aj6tiaFthhMM14HSSuibuiaia8ORywgickUmV622pw8Sj2u3YcA09w/640?wx_fmt=png"></p> 
<h3 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-weight: bold;line-height: 1.5;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="font-size: 18px;">3.3 其他方式</span></h3> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">代码检查不止局限上述阶段，在代码commit、pull request、打包等阶段均可触发。</p> 
<ul style="margin-left: 0.5em;margin-right: 0.5em;" class=" list-paddingleft-2"> 
 <li><p><span style="font-size: 14px;">代码commit阶段，通过Hook方式可以触发代码检查，可以有效地将在线CI检查阶段强制提前，基本保证了在线CI检查的完全正确性。</span></p></li> 
 <li><p><span style="font-size: 14px;">代码pull request阶段，通过在线CI检查可以触发代码检查，可以有效保证合入分支尤其是主分支的正确性。</span></p></li> 
 <li><p><span style="font-size: 14px;">代码打包阶段，通过在线CI检查可以触发代码检查，可以有效保证打包代码的正确性。</span></p></li> 
</ul> 
<h2 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-size: 18px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="color: rgb(37, 183, 167);font-size: 20px;">四、自定义编写TSLint规则</span></h2> 
<h3 style="margin: 10px 0.5em 15px;color: rgb(0, 0, 0);font-weight: bold;line-height: 1.5;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="font-size: 18px;">4.1 为什么要自定义TSLint规则</span></h3> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">当前的TSLint规则虽然涵盖了比较普遍问题的一些代码检查，但是实践中还是存在一些问题的：</p> 
<ol style="margin-left: 0.5em;margin-right: 0.5em;" class=" list-paddingleft-2"> 
 <li><p><span style="font-size: 14px;">团队中的个性化需求难以满足。例如，saga中的异步函数需要在最外层加try-catch，且catch块中需要加异常上报，这个明显在官方的TSLint规则无法实现，为此需要自定义的开发。</span></p></li> 
 <li><p><span style="font-size: 14px;">官方规则的开启与配置不符合当前团队情况。</span></p></li> 
</ol> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">基于以上原因其他团队也有自定义TSLint的先例，例如上文提到的tslint-microsoft-contrib、tslint-eslint-rules等。</p> 
<h3 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-weight: bold;line-height: 1.5;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="font-size: 18px;">4.2 自定义规则步骤</span></h3> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">那自定义TSLint大概需要什么步骤呢，首先规则文件根据规范进行按部就班的编写规则信息，然后根据代码检查逻辑对语法树进行分析并编写逻辑代码，这也是自定义规则的核心部分了，最后就是自定义规则的使用了。</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.9463820926600729" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATMmSP5yKd8XOQXAGMwrMy2CicKmNbTGbWgE7yGS9lCuaTAKkJiaUdDFWA/640?wx_fmt=png" data-type="png" data-w="1921" style="width: 338px;height: 320px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATMmSP5yKd8XOQXAGMwrMy2CicKmNbTGbWgE7yGS9lCuaTAKkJiaUdDFWA/640?wx_fmt=png"></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">自定义规则的示例直接参考官方的规则是最直接的，我们能这里参考一个比较简单的规则"class-name"。</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">"class-name"规则上文已经提到，它的意思是对类命名进行规范，当团队中类相关的命名不规范，会导致项目代码风格不统一甚至其他出现的问题，而"class-name"规则可以有效解决这个问题。我们可以看下具体的源码文件：<a href="https://github.com/palantir/tslint/blob/master/src/rules/classNameRule.ts" style="color: rgb(53, 114, 176);" data-linktype="2">https://github.com/palantir/tslint/blob/master/src/rules/classNameRule.ts</a>。</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">然后将分步对此自定义规则进行讲解。</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="1.064110622250157" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATq5bSjibUB7NktDMxrvPyx5qxqtdclQntb1t8iaj37zxoVdQ2bLMQlyDQ/640?wx_fmt=png" data-type="png" data-w="1591" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATq5bSjibUB7NktDMxrvPyx5qxqtdclQntb1t8iaj37zxoVdQ2bLMQlyDQ/640?wx_fmt=png"></p> 
<h4 style="margin: 20px 0.5em 15px;color: rgb(0, 0, 0);font-size: 14px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">第一步，文件命名</h4> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.30465116279069765" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATE0iaFE9uicIZNPw6SFRDTDgV8qvs7XwntWzETCIUDvymbtLY2FtD3yWg/640?wx_fmt=png" data-type="png" data-w="1290" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATE0iaFE9uicIZNPw6SFRDTDgV8qvs7XwntWzETCIUDvymbtLY2FtD3yWg/640?wx_fmt=png"></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">规则命名必须是符合以下2个规则：</p> 
<ol style="margin-left: 0.5em;margin-right: 0.5em;" class=" list-paddingleft-2"> 
 <li><p><span style="font-size: 14px;">驼峰命名。</span></p></li> 
 <li><p><span style="font-size: 14px;">以'Rule'为后缀。</span></p></li> 
</ol> 
<h4 style="margin: 20px 0.5em 15px;color: rgb(0, 0, 0);font-size: 14px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">第二步，类命名</h4> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">规则的类名是<code>Rule</code>，并且要继承<code>Lint.Rules.AbstractRule</code>这个类型，当然也可能有继承<code>TypedRule</code>这个类的时候，但是我们通过阅读源码发现，其实它也是继承自<code>Lint.Rules.AbstractRule</code>这个类。</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.33066502463054187" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT3gSoDx5pSeMkYiaNjsRibyl377QhmBo8zf7PxVX5LibHWp32nrgyEYNew/640?wx_fmt=png" data-type="png" data-w="1624" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT3gSoDx5pSeMkYiaNjsRibyl377QhmBo8zf7PxVX5LibHWp32nrgyEYNew/640?wx_fmt=png"></p> 
<h4 style="margin: 20px 0.5em 15px;color: rgb(0, 0, 0);font-size: 14px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">第三步，填写metadata信息</h4> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">metadata包含了配置参数，定义了规则的信息以及配置规则的定义。</p> 
<ul style="margin-left: 0.5em;margin-right: 0.5em;" class=" list-paddingleft-2"> 
 <li><p><span style="font-size: 14px;">ruleName 是规则名，使用烤串命名法，一般是将类名转为烤串命名格式。</span></p></li> 
 <li><p><span style="font-size: 14px;">description 一个简短的规则说明。</span></p></li> 
 <li><p><span style="font-size: 14px;">descriptionDetails 详细的规则说明。</span></p></li> 
 <li><p><span style="font-size: 14px;">rationale 理论基础。</span></p></li> 
 <li><p><span style="font-size: 14px;">options 配置参数形式，如果没有可以配置为null。</span></p></li> 
 <li><p><span style="font-size: 14px;">optionExamples 参数范例 ，如没有参数无需配置。</span></p></li> 
 <li><p><span style="font-size: 14px;">typescriptOnly true/false 是否只适用于TypeScript。</span></p></li> 
 <li><p><span style="font-size: 14px;">hasFix true/false 是否带有修复方式。</span></p></li> 
 <li><p><span style="font-size: 14px;">requiresTypeInfo 是否需要类型信息。</span></p></li> 
 <li><p><span style="font-size: 14px;">optionsDescrition options的介绍。</span></p></li> 
 <li><p><span style="font-size: 14px;">type 规则的类型。</span></p></li> 
</ul> 
<p style="font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin: 15px 0.5em;">规则类型有四种，分别为："functionality"、"maintainability"、"style"、"typescript"。</p> 
<ul style="margin-left: 0.5em;margin-right: 0.5em;" class=" list-paddingleft-2"> 
 <li><p><span style="font-size: 14px;">functionality ： 针对于语句问题以及功能问题。</span></p></li> 
 <li><p><span style="font-size: 14px;">maintainability：主要以代码简洁、可读、可维护为目标的规则。</span></p></li> 
 <li><p><span style="font-size: 14px;">style：以维护代码风格基本统一的规则。</span></p></li> 
 <li><p><span style="font-size: 14px;">typescript：针对于TypeScript进行提示。</span></p></li> 
</ul> 
<h4 style="margin: 20px 0.5em 15px;color: rgb(0, 0, 0);font-size: 14px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">第四步，定义错误提示信息</h4> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.053784860557768925" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATEBD12STOqm2XJzNiaDoSul9wG2kXWHtSSPNw4hzSfNe9Y8xPlg4AUGw/640?wx_fmt=png" data-type="png" data-w="1506" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATEBD12STOqm2XJzNiaDoSul9wG2kXWHtSSPNw4hzSfNe9Y8xPlg4AUGw/640?wx_fmt=png"></p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">这个主要是在检查出问题的时候进行提示的文字，并不局限于使用一个静态变量的形式，但是大部分官方规则都是这么编写，这里对此进行介绍，防止引起歧义。</p> 
<h4 style="margin: 20px 0.5em 15px;color: rgb(0, 0, 0);font-size: 14px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">第五步，实现apply方法</h4> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><code>apply</code>主要是进行静态检查的核心方法，通过返回<code>applyWithFunction</code>方法或者返回<code>applyWithWalker</code>来进行代码检查，其实<code>applyWithFunction</code>方法与<code>applyWithWalker</code>方法的主要区别在于<code>applyWithWalker</code>可以通过<code>IWalker</code>实现一个自定义的<code>IWalker</code>类，区别如下：</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.5155778894472361" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATQmY3Ut5pmHHMkeMmWvMyEm6ps7eibxmIX64ftwVYz61K3HTdtSvnykg/640?wx_fmt=png" data-type="png" data-w="1990" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATQmY3Ut5pmHHMkeMmWvMyEm6ps7eibxmIX64ftwVYz61K3HTdtSvnykg/640?wx_fmt=png"></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">其中实现<code>IWalker</code>的抽象类<code>AbstractWalker</code>里面也继承了<code>WalkContext</code>，</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.536014405762305" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATTmrpKDxhic7We2V8JNHbNsAPaDxco1G0qMxFPCnCTVVQ4RsBrWAqbGw/640?wx_fmt=png" data-type="png" data-w="1666" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATTmrpKDxhic7We2V8JNHbNsAPaDxco1G0qMxFPCnCTVVQ4RsBrWAqbGw/640?wx_fmt=png"></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">而这个<code>WalkContext</code>就是上面提到的<code>applyWithFunction</code>的内部实现类。</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.34565434565434566" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATevJXwSLicyAIE1icw1vw5ATFqNKtJuXCPyibco6SialtgXuaFeq1hibDjog/640?wx_fmt=png" data-type="png" data-w="2002" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATevJXwSLicyAIE1icw1vw5ATFqNKtJuXCPyibco6SialtgXuaFeq1hibDjog/640?wx_fmt=png"></p> 
<h4 style="margin: 20px 0.5em 15px;color: rgb(0, 0, 0);font-size: 14px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">第六步，语法树解析</h4> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">无论是<code>applyWithFunction</code>方法还是<code>applyWithWalker</code>方法中的<code>IWalker</code>实现都传入了<code>sourceFile</code>这个参数，这个相当于文件的根节点，然后通过<code>ts.forEachChild</code>方法遍历整个语法树节点。</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">这里有两个查看AST语法树的工具：</p> 
<ul style="margin-left: 0.5em;margin-right: 0.5em;" class=" list-paddingleft-2"> 
 <li><p><span style="font-size: 14px;">AST Explorer：</span></p><p><span style="font-size: 14px;">&nbsp;</span><span style="color: rgb(53, 114, 176);font-size: 14px;text-decoration: underline;"><a href="https://astexplorer.net/" style="color: rgb(53, 114, 176);font-size: 14px;text-decoration: underline;" data-linktype="2">https://astexplorer.net/</a></span></p><p><span style="color: rgb(53, 114, 176);font-size: 14px;text-decoration: underline;"></span><span style="font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 14px;">对应源码：</span></p><p><span style="font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 14px;"></span><a href="https://github.com/fkling/astexplorer" data-linktype="2" style="font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;color: rgb(53, 114, 176);font-size: 14px;text-decoration: underline;">https://github.com/fkling/astexplorer</a></p></li> 
 <li><p><span style="font-size: 14px;">TypeScript AST Viewer：</span></p><p><span style="font-size: 14px;">&nbsp;</span><a href="https://ts-ast-viewer.com/" style="color: rgb(53, 114, 176);font-size: 14px;text-decoration: underline;" data-linktype="2"><span style="font-size: 14px;">https://ts-ast-viewer.com/</span></a></p><p><span style="font-size: 14px;">对应源码：</span></p><p><span style="font-size: 14px;"></span><a href="https://github.com/dsherret/ts-ast-viewer" style="color: rgb(53, 114, 176);font-size: 14px;text-decoration: underline;" data-linktype="2"><span style="font-size: 14px;">https://github.com/dsherret/ts-ast-viewer</span></a></p></li> 
</ul> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;"><strong>AST Explorer</strong></p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;"><strong>优点：</strong></p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 15px;">在AST Explorer可以高亮显示所选中代码对应的AST语法树信息。</span></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><strong>缺点：</strong></p> 
<p style="margin-bottom: 15px;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 14px;">1. 不能选择对应版本的解析器，导致显示的语法树代码版本固定。</span></p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.2318840579710145" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATWVPwvwNJTDl7hJ9cicQku1vV5lNqTPO7NK04sUiajaywN8X7gj7qNnEg/640?wx_fmt=png" data-type="png" data-w="414" style="width: 276px;height: 64px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATWVPwvwNJTDl7hJ9cicQku1vV5lNqTPO7NK04sUiajaywN8X7gj7qNnEg/640?wx_fmt=png"></p> 
<p style="margin-bottom: 15px;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 14px;">2. 语法树显示的信息相对较少。</span></p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.4298181818181818" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT5gPB0Esd7s8sOPmKlXP5PzJm239DhRjR3ibpibrhNnX1ZqzY67iawX4Rw/640?wx_fmt=png" data-type="png" data-w="1375" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT5gPB0Esd7s8sOPmKlXP5PzJm239DhRjR3ibpibrhNnX1ZqzY67iawX4Rw/640?wx_fmt=png"></p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;"><strong>TypeScript AST Viewer</strong></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><strong>优点：</strong></p> 
<p style="margin-bottom: 15px;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 14px;">1. 解析器对应版本可以动态选择：</span></p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.47218045112781953" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT9TcsftBbOP0jP2wWD79wZmZWnZTVWS9mszugPfTwwGJKVjS9SHjlGA/640?wx_fmt=png" data-type="png" data-w="1330" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT9TcsftBbOP0jP2wWD79wZmZWnZTVWS9mszugPfTwwGJKVjS9SHjlGA/640?wx_fmt=png"></p> 
<p style="margin-bottom: 15px;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 14px;">2. 语法树显示的信息不仅显示对应的数字代码，还可为对应的实际信息：</span></p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.4183046683046683" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT0KJSx8Pq5YSfpLrOZrksfiaLpe0z9F8pW8CLXcD5JdzutiabK1vSRpRQ/640?wx_fmt=png" data-type="png" data-w="1628" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT0KJSx8Pq5YSfpLrOZrksfiaLpe0z9F8pW8CLXcD5JdzutiabK1vSRpRQ/640?wx_fmt=png"></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">每个版本对应对kind信息数值可能会变动，但是对应的枚举名字是固定的，如下图：</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.8841927303465765" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATjgcWNou49FsHEuWerOEdtQ2Q0CAaibcicUVofpATV6zdvGzGpVkheGdQ/640?wx_fmt=png" data-type="png" data-w="1183" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATjgcWNou49FsHEuWerOEdtQ2Q0CAaibcicUVofpATV6zdvGzGpVkheGdQ/640?wx_fmt=png"></p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">从而这个工具可以避免频繁根据其数值查找对应信息。</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><strong>缺点：</strong>不能高亮显示代码对应的AST语法树区域，定位效率较低。</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">综上，通过同时使用上述两个工具定位分析，可以有效地提高分析效率。</p> 
<h4 style="margin: 20px 0.5em 15px;color: rgb(0, 0, 0);font-size: 14px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">第七步，规则代码编写</h4> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">通过<code>ts.forEachChild</code>方法对于语法树所有的节点进行遍历，在遍历的方法里可以实现自己的逻辑，其中节点的类为<code>ts.Node</code>：</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.21099554234769688" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATJjxhhtV3nG8yTxQeGickQuWIB18SWwibKiaJ4Z0OWpbuRjziaxMOpQJ4rQ/640?wx_fmt=png" data-type="png" data-w="1346" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATJjxhhtV3nG8yTxQeGickQuWIB18SWwibKiaJ4Z0OWpbuRjziaxMOpQJ4rQ/640?wx_fmt=png"></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">其中kind为当前节点的类型，当然<code>Node</code>是所有节点的基类，它的实现还包括<code>Statement</code>、<code>Expression</code>、<code>Declaration</code>等，回到开头这个"class-name"规则，我们的所有声明类主要是class与interface关键字，分别对应<code>ClassExpression</code>、<code>ClassDeclaration</code>、<code>InterfaceDeclaration</code>， 我们可以通过上步提到的AST语法树工具，在语法树中看到其为一一对应的。</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.4880382775119617" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT1FCuKoAkzl73VEyBV3MsTMoRBf1I8tY9uR2dz7Ecl45YpEkYtlSnNg/640?wx_fmt=png" data-type="png" data-w="1672" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT1FCuKoAkzl73VEyBV3MsTMoRBf1I8tY9uR2dz7Ecl45YpEkYtlSnNg/640?wx_fmt=png"></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">在规则代码中主要通过<code>isClassLikeDeclaration</code>、<code>isInterfaceDeclaration</code>这两个方法进行判断的。</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.33671875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT7jGpINYyB92uKFqzrblFtwJg6BRX8IR5umZicf35uANzZIAA9AmO1QA/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT7jGpINYyB92uKFqzrblFtwJg6BRX8IR5umZicf35uANzZIAA9AmO1QA/640?wx_fmt=jpeg"></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">其中<code>isClassLikeDeclaration</code>、<code>isInterfaceDeclaration</code>对应的方法我们可以在node.js文件中找到：</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.13472858077174624" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT9xPz61OfRbGYeVTLU22SRKmUwF4v0UHn8dzmFYYNs8z3jibslkDWakA/640?wx_fmt=png" data-type="png" data-w="1529" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmAT9xPz61OfRbGYeVTLU22SRKmUwF4v0UHn8dzmFYYNs8z3jibslkDWakA/640?wx_fmt=png"></p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.10553745928338762" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATwtLtvdhlEHLoGwkw7CljTofjGENvVXEZA4f69akYVIsKBqG3FCPmfQ/640?wx_fmt=png" data-type="png" data-w="1535" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATwtLtvdhlEHLoGwkw7CljTofjGENvVXEZA4f69akYVIsKBqG3FCPmfQ/640?wx_fmt=png"></p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">判断是对应的类型时，调用<code>addFailureAtNode</code>方法把错误信息和节点传入，当然还可以调用<code>addFailureAt</code>、<code>addFailure</code>方法。</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.3989769820971867" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATJzGz7YNYzHuyibHzIY72jd0e6d1uBJmx3WfTiaGGjAYuWKwskV11sO4A/640?wx_fmt=png" data-type="png" data-w="1955" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATJzGz7YNYzHuyibHzIY72jd0e6d1uBJmx3WfTiaGGjAYuWKwskV11sO4A/640?wx_fmt=png"></p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">最终这个规则编写结束了，有一点再次强调下，因为每个版本所对应的类型代码可能不相同，当判断kind的时候，一定不要直接使用各个类型对应的数字。</p> 
<h4 style="margin: 20px 0.5em 15px;color: rgb(0, 0, 0);font-size: 14px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">第八步，规则配置使用</h4> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">完成规则代码后，是ts后缀的文件，而ts规则文件实际还是要用js文件，这时候我们需要用命令将ts转化为js文件：</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="hljs nginx" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;"><span class="hljs-attribute" style="color: rgb(178, 148, 187) !important;">tsc</span> ./src/<span class="hljs-regexp" style="color: rgb(181, 189, 104) !important;">*.ts</span> --outDir dist</code></pre> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">将ts规则生成到dist文件夹（<span style="color: rgb(136, 136, 136);">这个文件夹命名用户自定</span>），然后在tslint.json文件中配置生成的规则文件即可。</p> 
<p style="text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.3098464317976513" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATJJHic10v6sxX7DlrLZ3CdAPfCYFUibD495oHH432KuOgeCmzmMe3QO7Q/640?wx_fmt=png" data-type="png" data-w="1107" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVibYCcXoiaDJx1fDHcgEKmATJJHic10v6sxX7DlrLZ3CdAPfCYFUibD495oHH432KuOgeCmzmMe3QO7Q/640?wx_fmt=png"></p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">之后在项目的根目录里面，使用以下命令既可进行检查：</p> 
<pre style="margin: 10px 0.5em 0px;padding: 0px;font-size: 14px;text-align: start;"><code class="hljs css" style="display: block !important;overflow-x: auto !important;padding: 0.5em !important;background: rgb(29, 31, 33) !important;color: rgb(197, 200, 198) !important;"><span class="hljs-selector-tag" style="color: rgb(129, 162, 190) !important;">tslint</span> <span class="hljs-selector-tag" style="color: rgb(129, 162, 190) !important;">--project</span> <span class="hljs-selector-tag" style="color: rgb(129, 162, 190) !important;">tsconfig</span><span class="hljs-selector-class" style="color: rgb(222, 147, 95) !important;">.json</span> <span class="hljs-selector-tag" style="color: rgb(129, 162, 190) !important;">--config</span> <span class="hljs-selector-tag" style="color: rgb(129, 162, 190) !important;">tslint</span><span class="hljs-selector-class" style="color: rgb(222, 147, 95) !important;">.json</span></code></pre> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">同时为了未来新增规则以及规则配置的更好的操作性，建议可以封装到自己的规则包，以便与规则的管理与传播。</p> 
<h2 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-size: 18px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="color: rgb(37, 183, 167);font-size: 20px;">总结</span></h2> 
<h3 style="margin: 10px 0.5em 15px;color: rgb(0, 0, 0);font-weight: bold;line-height: 1.5;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="font-size: 18px;">TSLint的优点：</span></h3> 
<ol style="margin-left: 0.5em;margin-right: 0.5em;" class=" list-paddingleft-2"> 
 <li><p><span style="font-size: 14px;">速度快。相对于动态代码检查，检查速度较快，现有项目无论是在本地检查，还是在CI检查，对于由十余个页面组成的React Native工程，可以在1到2分钟内完成；</span></p></li> 
 <li><p><span style="font-size: 14px;">灵活。通过配置规则，可以有效地避免常见代码错误与潜在的Bug；</span></p></li> 
 <li><p><span style="font-size: 14px;">易扩展。通过编写配置自定义规则，可以及时准确快速查找出代码中特定风险点。</span></p></li> 
</ol> 
<h3 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-weight: bold;line-height: 1.5;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="font-size: 18px;">TSLint缺点：</span></h3> 
<ol style="margin-left: 0.5em;margin-right: 0.5em;" class=" list-paddingleft-2"> 
 <li><p><span style="font-size: 14px;">规则的结果只有对与错两种等级结果，没有警告等级的的提示结果；</span></p></li> 
 <li><p><span style="font-size: 14px;">无法直接报告规则报错数量，只能依赖其他手段统计；</span></p></li> 
 <li><p><span style="font-size: 14px;">TSLint规则针对于当前单一文件可以有效地通过语法树进行分析判定，但对于引用到的其他文件中的变量、类、方法等，则难以通过AST语法树进行判定。</span></p></li> 
</ol> 
<h3 style="margin-top: 30px;color: rgb(0, 0, 0);font-weight: bold;line-height: 1.5;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 18px;">使用结果及分析</span></h3> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">在美团，有十余个页面的单个工程首次接入TSLint后，检查出的问题有近百条。但是由于开启的规则不同，配置规则包的差异，检查后的数量可能为几十条到几千条甚至更多。现在已开发十余条自定义规则，在单个工程内，处理优化了数百处可能存在问题的代码。最终TSLint接入了相关React Native开发团队，成为了代码提交阶段的必要步骤。</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;">通过团队内部的验证，文章开头遇到的问题得到了有效地缓解，目标基本达到预期。TSLint在React Native开发过程中既保证了代码风格的统一，又保证了React Native开发人员的开发质量，避免了许多低级错误，有效地节省了问题排查和人员沟通的成本。</p> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">同时利用自定义规则，能够将一些兼容性问题在内的个性化问题进行总结与预防，提高了开发效率，不用花费大量时间查找问题代码，又避免了在一个问题上跌倒多次的情况出现。对于不同经验的开发者而言，不仅可以进行友好的提示，也可以帮助快速地定位问题，将一个人遇到的经验教训，用极低的成本扩散到其他团队之中，将开发状态从“亡羊补牢”进化到“防患未然”。</p> 
<h2 style="margin: 30px 0.5em 15px;color: rgb(0, 0, 0);font-size: 18px;font-weight: bold;line-height: 1.25;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="color: rgb(37, 183, 167);">作者简介</span></h2> 
<p style="margin-top: 10px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;margin-left: 0.5em;margin-right: 0.5em;">家正，美团点评Android高级工程师。2017 年加入美团点评，负责美团大交通的业务开发。</p> 
<p style="margin: 10px 0.5em 15px;font-size: 15px;font-family: Arial, sans-serif;text-align: start;white-space: pre-wrap;"><span style="letter-spacing: 0.544px;background-color: rgb(255, 255, 255);color: rgb(136, 136, 136);font-size: 15px;box-sizing: border-box !important;">欢迎加入</span><strong style="letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);box-sizing: border-box !important;"><span style="font-size: 15px;color: rgb(0, 0, 0);box-sizing: border-box !important;">美团Web前端技术交流群</span></strong><span style="letter-spacing: 0.544px;background-color: rgb(255, 255, 255);color: rgb(136, 136, 136);font-size: 15px;box-sizing: border-box !important;">，跟项目维护者零距离交流。进群方式：请加美美同学微信（<strong style="box-sizing: border-box !important;">微信号：MTDPtech02</strong>），回复：</span><span style="letter-spacing: 0.544px;background-color: rgb(255, 255, 255);font-size: 15px;box-sizing: border-box !important;"><span style="color:#000000;"><strong>前端</strong></span></span><span style="letter-spacing: 0.544px;background-color: rgb(255, 255, 255);color: rgb(136, 136, 136);font-size: 15px;box-sizing: border-box !important;">，美美会自动拉你进群。</span></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 15px;color: rgb(136, 136, 136);box-sizing: border-box !important;">----------&nbsp; END&nbsp; ----------</span></p> 
<p data-source-line="194" style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;margin-bottom: 15px;"><span style="font-size: 16px;"><strong><span style="color: rgb(49, 188, 173);">也许你还想看</span></strong></span></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651750121&amp;idx=2&amp;sn=cf41b9ed4a5ef3cefd007a18ce7139f6&amp;chksm=bd12a7a48a652eb218e8f6ae472a54513823d590eb053b6c228cb9482d93c82e8068a770451f&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;" data-linktype="2"><span style="font-size: 14px;">客户端单周发版下的多分支自动化管理与实践</span></a></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748921&amp;idx=1&amp;sn=af5e8bad47c203b32d206949e52cd1cd&amp;chksm=bd12a3748a652a62037d2d2bf402b70f954c6a2da8ca54303eb8c98d160a99f186c5c260b2be&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;" data-linktype="2"><span style="font-size: 14px;">beeshell：开源的React Native组件库</span></a></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651746860&amp;idx=2&amp;sn=9d691894135d5363b1fcd94e2f7b889b&amp;chksm=bd12ab618a6522771f636be8f8bb87c2a403b55b1336d2cc8a15f5cff3c352d338a1f29961b4&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;" data-linktype="2"><span style="font-size: 14px;">函数式编程在Redux/React中的应用</span></a><br></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.44533333333333336" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png" data-type="png" data-w="1875" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png"></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
