<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>K8S 从懵圈到熟练：读懂此文，集群节点不下线！ | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="K8S 从懵圈到熟练：读懂此文，集群节点不下线！" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="阿里妹导读：排查完全陌生的问题、不熟悉的系统组件，对许多工程师来说是无与伦比的工作乐趣，当然也是一大挑战。今天，阿里巴巴售后技术专家声东跟大家分享一例 Kubernetes 集群上的问题。这个问题影响范围较广，或许某天你也会遇到。更重要的是，作者在问题排查过程中的思路和方法，也会让你有所启发。 关于问题 I am Not Ready 阿里云有自己的 Kubernetes 容器集群产品。随着 Kubernetes 集群出货量剧增，线上用户零星地发现，集群会非常低概率地出现节点 NotReady 情况。据我们观察，这个问题差不多每个月，都会有一两个用户遇到。在节点 NotReady 之后，集群 Master 没有办法对这个节点做任何控制，比如下发新的 Pod，再比如抓取节点上正在运行 Pod 的实时信息。 需要知道的Kubernetes知识 这里我稍微补充一点 Kubernetes 集群的基本知识。Kubernetes 集群的“硬件基础”，是以单机形态存在的集群节点。这些节点可以是物理机，也可以是虚拟机。集群节点分为 Master 节点和 Worker 节点。Master 节点主要用来承载集群管控组件，比如调度器和控制器。而 Worker 节点主要用来跑业务。Kubelet 是跑在各个节点上的代理，它负责与管控组件沟通，并按照管控组件的指示，直接管理 Worker节点。 当集群节点进入 NotReady 状态的时候，我们需要做的第一件事情，是检查运行在节点上的 kubelet 是否正常。在这个问题出现的时候，使用 systemctl 命令查看的kubelet 状态（kubelet 是 systemd 管理的一个 daemon ）发现它是正常运行的。当我们用 journalctl 查看 kubelet 日志的时候，发现以下错误。 什么是PLEG？ 这个报错清楚地告诉我们，容器 runtime 是不工作的，且 PLEG 是不健康的。这里容器 runtime 指的就是 docker daemon 。Kubelet 通过操作 docker daemon 来控制容器的生命周期。而这里的 PLEG，指的是 pod lifecycle event generator。PLEG 是 kubelet 用来检查 runtime 的健康检查机制。这件事情本来可以由 kubelet 使用 polling 的方式来做。但是 polling 有其高成本的缺陷，所以 PLEG 应用而生。PLEG 尝试以一种“中断”的形式，来实现对容器 runtime 的健康检查，虽然实际上，它同时用了 polling 和”中断”这样折中的方案。 基本上，根据上边的报错，我们可以确认容器 runtime 出了问题。在有问题的节点上，通过 docker 命令尝试运行新的容器，命令会没有响应，这说明上边的报错是准确的。 Docker Stack Docker Daemon调用栈分析 Docker 作为阿里云 Kubernetes 集群使用的容器 runtime ，在1.11之后，被拆分成了多个组件以适应 OCI 标准。拆分之后，其包括 docker daemon，containerd，containerd-shim 以及 runC。组件 containerd 负责集群节点上容器的生命周期管理，并向上为 docker daemon 提供 gRPC 接口。 在这个问题中，既然 PLEG 认为容器 runtime 出了问题，我们需要从 docker daemon 进程看起。我们可以使用 kill -USR1 &lt;pid&gt; 命令发送 USR1 信号给docker daemon，而 docker daemon 收到信号之后，会把所有线程调用栈输出到 /var/run/docker 文件夹里。 Docker daemon 进程的调用栈是比较容易分析的。稍加留意，我们会发现大多数的调用栈都长成下图中的样子。通过观察栈上每个函数的名字，以及函数所在的文件（模块）名称，我们可以了解到，这个调用栈的下半部分，是进程接到 http 请求，做请求路由的过程；而上半部分则是具体的处理函数。最终处理函数进入等待状态，等待一个mutex实例。 到这里，我们需要稍微看一下 ContainerInspectCurrent 这个函数的实现。从实现可以看到，这个函数的第一个参数，就是这个线程正在操作的容器名指针。使用这个指针搜索整个调用栈文件，我们会找出所有等在这个容器上的线程。同时，我们可以看到下边这个线程。 这个线程调用栈上的函数 ContainerExecStart 也是在处理相同容器。但不同的是，ContainerExecStart 并没有在等这个容器，而是已经拿到了这个容器的操作权（mutex），并把执行逻辑转向了 containerd 调用。关于这一点，我们也可以使用代码来验证。前边我提到过，containerd 通过 gRPC 向上对 docker daemon 提供接口。此调用栈上半部分内容，正是 docker daemon 在通过 gRPC 请求来呼叫containerd。 Containerd调用栈分析 与 docker daemon 类似，我们可以通过 kill -SIGUSR1 &lt;pid&gt; 命令来输出containerd 的调用栈。不同的是，这次调用栈会直接输出到 messages 日志。 Containerd 作为一个 gRPC 的服务器，会在接到 docker daemon 的远程调用之后，新建一个线程去处理这次请求。关于 gRPC 的细节，我们这里其实不用太多关注。在这次请求的客户端调用栈上，可以看到这次调用的核心函数在 Start 一个Process 。我们在 containerd 的调用栈里搜索 Start，Process 以及 process.go 等字段，很容易发现下边这个线程。 这个线程的核心任务，就是依靠 runC 去创建容器进程。而在容器启动之后，runC 进程会退出。所以下一步，我们自然而然会想到，runC 是不是有顺利完成自己的任务。查看进程列表，我们会发现，系统中有个别 runC 进程还在执行，这不是预期的行为。容器的启动，跟进程的启动，耗时应该是差不多数量级的，系统里有正在运行的 runC 进程，则说明 runC 不能正常启动容器。 什么是D-Bus？ RunC请求D-Bus 容器 runtime 的 runC 命令，是 libcontainer 的一个简单的封装。这个工具可以用来管理单个容器，比如容器创建和容器删除。在上节的最后，我们发现 runC 不能完成创建容器的任务。我们可以把对应的进程杀掉，然后在命令行用同样的命令启动容器，同时用 strace 追踪整个过程。 分析发现，runC 停在了向带有 org.free 字段的 dbus socket 写数据的地方。那什么是 dbus 呢？在 Linux 上，dbus 是一种进程间进行消息通信的机制。 原因并不在 D-Bus 我们可以使用 busctl 命令列出系统现有的所有 bus 。如下图，在问题发生的时候，我看到问题节点 bus name 编号非常大。所以我倾向于认为，dbus 某些相关的数据结构，比如 name，耗尽了引起了这个问题。 Dbus 机制的实现，依赖于一个组件叫做 dbus daemon。如果真的是 dbus 相关数据结构耗尽，那么重启这个 daemon，应该可以解决这个问题。但不幸的是，问题并没有这么直接。重启 dbus daemon 之后，问题依然存在。 在上边 strace 追踪 runC 的截图中，runC 停在向带有 org.free 字段的 bus 写数据的地方。在 busctl 输出的 bus 列表里，显然带有这个字段的 bus，都在被 systemd使用。这时，我们用 systemctl daemon-reexec 来重启 systemd，问题消失了。所以基本上我们可以判断一个方向，问题可能跟 systemd 有关。 Systemd是硬骨头 Systemd 是相当复杂的一个组件，尤其对没有做过相关开发工作的同学来说，比如我自己。基本上，排查 systemd 的问题，我用到了四个方法，（调试级别）日志，core dump，代码分析，以及 live debugging。其中第一个，第三个和第四个结合起来使用，让我在经过几天的鏖战之后，找到了问题的原因。但是这里我们先从“没用”的 core dump 说起。 “没用的”Core Dump 因为重启 systemd 解决了问题，而这个问题本身，是 runC 在使用 dbus 和systemd 通信的时候没有了响应，所以我们需要验证的第一件事情，就是 systemd不是有关键线程被锁住了。查看 core dump 里所有线程，只有以下一个线程，此线程并没有被锁住，它在等待 dbus 事件，以便做出响应。 零散的信息 因为无计可施，所以只能做各种测试、尝试。使用 busctl tree 命令，可以输出所有bus 上对外暴露的接口。从输出结果看来，org.freedesktop.systemd1 这个 bus 是不能响应接口查询请求的。 使用下边的命令，观察 org.freedesktop.systemd1 上接受到的所以请求，可以看到，在正常系统里，有大量 Unit 创建删除的消息，但是有问题的系统里，这个 bus 上完全没有任何消息。 gdbus monitor --system --dest org.freedesktop.systemd1 --object-path /org/freedesktop/systemd1 分析问题发生前后的系统日志，runC在重复的跑一个libcontainer_%d_systemd_test_default.slice 测试，这个测试非常频繁，但是当问题发生的时候，这个测试就停止了。所以直觉告诉我，这个问题，可能和这个测试有很大的关系。 另外，我使用 systemd-analyze 命令，打开了 systemd 的调试级别日志，发现 systemd 有 Operation not supported 的报错。 根据以上零散的知识，可以给出一个大概的结论：org.freedesktop.systemd1 这个 bus 在经过大量 unit 创建删除之后，没有了响应。而这些频繁的 unit 创建删除测试，是 runC 某一个改动引入的。这个改动使得 UseSystemd 函数通过创建 unit 来测试 systemd 的功能。UseSystemd 在很多地方被调用，比如创建容器，或者查看容器性能等操作。 代码分析 这个问题在线上所有 Kubernetes 集群中，发生的频率大概是一个月两例。问题一直在发生，且只能在问题发生之后，通过重启 systemd 来处理，这风险极大。 我们分别给 systemd 和 runC 社区提交了 bug，但是一个很现实的问题是，他们并没有像阿里云这样的线上环境，他们重现这个问题的概率几乎是零，所以这个问题没有办法指望社区来解决。硬骨头还得我们自己啃。 在上一节最后，我们看到了，问题出现的时候，systemd 会输出一些 Operation not supported 报错。这个报错看起来和问题本身风马牛不相及，但是直觉告诉我，这，或许是离问题最近的一个地方，所以我决定，先搞清楚这个报错因何而来。 Systemd 代码量比较大，而报这个错误的地方非常多。通过大量的代码分析（这里略去一千字），我发现有几处比较可疑地方，有了这些可疑的地方，接下来需要做的事情，就是等待。在等了三周以后，终于有线上集群，再次重现了这个问题。 Live Debugging 在征求用户同意之后，下载 systemd 调试符号，挂载 gdb 到 systemd 上，在可疑的函数下断点，continue 继续执行。经过多次验证，发现 systemd 最终踩到了sd_bus_message_seal 这个函数里的 EOPNOTSUPP 报错。 这个报错背后的道理是，systemd 使用了一个变量 cookie，来追踪自己处理的 dbus message 。每次在加封一个新的 message 的时候，systemd 会先给 cookie的值加一，然后再把这个值复制给这个新的 message。 我们使用 gdb 打印出 dbus-&gt;cookie 这个值，可以很清楚看到，这个值超过了0xffffffff 。所以看起来，问题是 systemd 在加封过大量 message 之后，cookie 这个值32位溢出了，导致新的消息不能被加封，从而使得 systemd 对 runC 没有了响应。 另外，在一个正常的系统上，使用 gdb 把 bus-&gt;cookie 这个值改到接近 0xffffffff，然后观察到，问题在 cookie 溢出的时候立刻出现，则证明了我们的结论。 怎么判断集群节点NotReady是这个问题导致的 首先我们需要在有问题的节点上安装 gdb 和 systemd debuginfo，然后用命令 gdb /usr/lib/systemd/systemd1 把 gdb attach 到 systemd ，在函数sd_bus_send 设置断点，然后继续执行。等 systemd 踩到断点之后，用 p /x bus-&gt;cookie 查看对应的cookie值，如果此值超过了 0xffffffff，那么 cookie 就溢出了，则必然导致节点 NotReady 的问题。确认完之后，可以使用 quit 来 detach 调试器。 问题修复 这个问题的修复，并没有那么直截了当。原因之一，是 systemd 使用了同一个 cookie 变量，来兼容 dbus1 和 dbus2 。对于 dbus1 来说， cookie 是32位的，这个值在经过 systemd 三五个月频繁创建删除 unit 之后，是肯定会溢出的；而 dbus2 的 cookie 是64位的，可能到了时间的尽头，它也不会溢出。 另外一个原因是，我们并不能简单的让 cookie 折返，来解决溢出问题。因为这有可能导致 systemd 使用同一个 cookie 来加封不同的消息，这样的结果将是灾难性的。 最终的修复方法是，使用32位 cookie 来同样处理 dbus1 和 dbus2 两种情形。同时在 cookie 达到 0xfffffff 的之后，下一个 cookie 则变成 0x80000000，即用最高位来标记 cookie 已经处于溢出状态。检查到 cookie 处于这种状态时，我们需要检查是否下一个 cookie 正在被其他 message 使用，来避免 cookie 冲突。 后记 这个问题根本原因肯定在 systemd，但是 runC 的函数 UseSystemd 使用不那么美丽的方法，去测试 systemd 的功能，而这个函数在整个容器生命周期管理过程中，被频繁的调用，让这个低概率问题的发生成为了可能。systemd 的修复已经被红帽接受，预期不久的将来，我们可以通过升级 systemd，从根本上解决这个问题。 你可能还喜欢 点击下方图片即可阅读 贾扬清：我对人工智能方向的一点浅见 如何搞定技术面试？阿里大牛为你选了8本必备好书 在阿里做了五年技术主管，我有话想说" />
<meta property="og:description" content="阿里妹导读：排查完全陌生的问题、不熟悉的系统组件，对许多工程师来说是无与伦比的工作乐趣，当然也是一大挑战。今天，阿里巴巴售后技术专家声东跟大家分享一例 Kubernetes 集群上的问题。这个问题影响范围较广，或许某天你也会遇到。更重要的是，作者在问题排查过程中的思路和方法，也会让你有所启发。 关于问题 I am Not Ready 阿里云有自己的 Kubernetes 容器集群产品。随着 Kubernetes 集群出货量剧增，线上用户零星地发现，集群会非常低概率地出现节点 NotReady 情况。据我们观察，这个问题差不多每个月，都会有一两个用户遇到。在节点 NotReady 之后，集群 Master 没有办法对这个节点做任何控制，比如下发新的 Pod，再比如抓取节点上正在运行 Pod 的实时信息。 需要知道的Kubernetes知识 这里我稍微补充一点 Kubernetes 集群的基本知识。Kubernetes 集群的“硬件基础”，是以单机形态存在的集群节点。这些节点可以是物理机，也可以是虚拟机。集群节点分为 Master 节点和 Worker 节点。Master 节点主要用来承载集群管控组件，比如调度器和控制器。而 Worker 节点主要用来跑业务。Kubelet 是跑在各个节点上的代理，它负责与管控组件沟通，并按照管控组件的指示，直接管理 Worker节点。 当集群节点进入 NotReady 状态的时候，我们需要做的第一件事情，是检查运行在节点上的 kubelet 是否正常。在这个问题出现的时候，使用 systemctl 命令查看的kubelet 状态（kubelet 是 systemd 管理的一个 daemon ）发现它是正常运行的。当我们用 journalctl 查看 kubelet 日志的时候，发现以下错误。 什么是PLEG？ 这个报错清楚地告诉我们，容器 runtime 是不工作的，且 PLEG 是不健康的。这里容器 runtime 指的就是 docker daemon 。Kubelet 通过操作 docker daemon 来控制容器的生命周期。而这里的 PLEG，指的是 pod lifecycle event generator。PLEG 是 kubelet 用来检查 runtime 的健康检查机制。这件事情本来可以由 kubelet 使用 polling 的方式来做。但是 polling 有其高成本的缺陷，所以 PLEG 应用而生。PLEG 尝试以一种“中断”的形式，来实现对容器 runtime 的健康检查，虽然实际上，它同时用了 polling 和”中断”这样折中的方案。 基本上，根据上边的报错，我们可以确认容器 runtime 出了问题。在有问题的节点上，通过 docker 命令尝试运行新的容器，命令会没有响应，这说明上边的报错是准确的。 Docker Stack Docker Daemon调用栈分析 Docker 作为阿里云 Kubernetes 集群使用的容器 runtime ，在1.11之后，被拆分成了多个组件以适应 OCI 标准。拆分之后，其包括 docker daemon，containerd，containerd-shim 以及 runC。组件 containerd 负责集群节点上容器的生命周期管理，并向上为 docker daemon 提供 gRPC 接口。 在这个问题中，既然 PLEG 认为容器 runtime 出了问题，我们需要从 docker daemon 进程看起。我们可以使用 kill -USR1 &lt;pid&gt; 命令发送 USR1 信号给docker daemon，而 docker daemon 收到信号之后，会把所有线程调用栈输出到 /var/run/docker 文件夹里。 Docker daemon 进程的调用栈是比较容易分析的。稍加留意，我们会发现大多数的调用栈都长成下图中的样子。通过观察栈上每个函数的名字，以及函数所在的文件（模块）名称，我们可以了解到，这个调用栈的下半部分，是进程接到 http 请求，做请求路由的过程；而上半部分则是具体的处理函数。最终处理函数进入等待状态，等待一个mutex实例。 到这里，我们需要稍微看一下 ContainerInspectCurrent 这个函数的实现。从实现可以看到，这个函数的第一个参数，就是这个线程正在操作的容器名指针。使用这个指针搜索整个调用栈文件，我们会找出所有等在这个容器上的线程。同时，我们可以看到下边这个线程。 这个线程调用栈上的函数 ContainerExecStart 也是在处理相同容器。但不同的是，ContainerExecStart 并没有在等这个容器，而是已经拿到了这个容器的操作权（mutex），并把执行逻辑转向了 containerd 调用。关于这一点，我们也可以使用代码来验证。前边我提到过，containerd 通过 gRPC 向上对 docker daemon 提供接口。此调用栈上半部分内容，正是 docker daemon 在通过 gRPC 请求来呼叫containerd。 Containerd调用栈分析 与 docker daemon 类似，我们可以通过 kill -SIGUSR1 &lt;pid&gt; 命令来输出containerd 的调用栈。不同的是，这次调用栈会直接输出到 messages 日志。 Containerd 作为一个 gRPC 的服务器，会在接到 docker daemon 的远程调用之后，新建一个线程去处理这次请求。关于 gRPC 的细节，我们这里其实不用太多关注。在这次请求的客户端调用栈上，可以看到这次调用的核心函数在 Start 一个Process 。我们在 containerd 的调用栈里搜索 Start，Process 以及 process.go 等字段，很容易发现下边这个线程。 这个线程的核心任务，就是依靠 runC 去创建容器进程。而在容器启动之后，runC 进程会退出。所以下一步，我们自然而然会想到，runC 是不是有顺利完成自己的任务。查看进程列表，我们会发现，系统中有个别 runC 进程还在执行，这不是预期的行为。容器的启动，跟进程的启动，耗时应该是差不多数量级的，系统里有正在运行的 runC 进程，则说明 runC 不能正常启动容器。 什么是D-Bus？ RunC请求D-Bus 容器 runtime 的 runC 命令，是 libcontainer 的一个简单的封装。这个工具可以用来管理单个容器，比如容器创建和容器删除。在上节的最后，我们发现 runC 不能完成创建容器的任务。我们可以把对应的进程杀掉，然后在命令行用同样的命令启动容器，同时用 strace 追踪整个过程。 分析发现，runC 停在了向带有 org.free 字段的 dbus socket 写数据的地方。那什么是 dbus 呢？在 Linux 上，dbus 是一种进程间进行消息通信的机制。 原因并不在 D-Bus 我们可以使用 busctl 命令列出系统现有的所有 bus 。如下图，在问题发生的时候，我看到问题节点 bus name 编号非常大。所以我倾向于认为，dbus 某些相关的数据结构，比如 name，耗尽了引起了这个问题。 Dbus 机制的实现，依赖于一个组件叫做 dbus daemon。如果真的是 dbus 相关数据结构耗尽，那么重启这个 daemon，应该可以解决这个问题。但不幸的是，问题并没有这么直接。重启 dbus daemon 之后，问题依然存在。 在上边 strace 追踪 runC 的截图中，runC 停在向带有 org.free 字段的 bus 写数据的地方。在 busctl 输出的 bus 列表里，显然带有这个字段的 bus，都在被 systemd使用。这时，我们用 systemctl daemon-reexec 来重启 systemd，问题消失了。所以基本上我们可以判断一个方向，问题可能跟 systemd 有关。 Systemd是硬骨头 Systemd 是相当复杂的一个组件，尤其对没有做过相关开发工作的同学来说，比如我自己。基本上，排查 systemd 的问题，我用到了四个方法，（调试级别）日志，core dump，代码分析，以及 live debugging。其中第一个，第三个和第四个结合起来使用，让我在经过几天的鏖战之后，找到了问题的原因。但是这里我们先从“没用”的 core dump 说起。 “没用的”Core Dump 因为重启 systemd 解决了问题，而这个问题本身，是 runC 在使用 dbus 和systemd 通信的时候没有了响应，所以我们需要验证的第一件事情，就是 systemd不是有关键线程被锁住了。查看 core dump 里所有线程，只有以下一个线程，此线程并没有被锁住，它在等待 dbus 事件，以便做出响应。 零散的信息 因为无计可施，所以只能做各种测试、尝试。使用 busctl tree 命令，可以输出所有bus 上对外暴露的接口。从输出结果看来，org.freedesktop.systemd1 这个 bus 是不能响应接口查询请求的。 使用下边的命令，观察 org.freedesktop.systemd1 上接受到的所以请求，可以看到，在正常系统里，有大量 Unit 创建删除的消息，但是有问题的系统里，这个 bus 上完全没有任何消息。 gdbus monitor --system --dest org.freedesktop.systemd1 --object-path /org/freedesktop/systemd1 分析问题发生前后的系统日志，runC在重复的跑一个libcontainer_%d_systemd_test_default.slice 测试，这个测试非常频繁，但是当问题发生的时候，这个测试就停止了。所以直觉告诉我，这个问题，可能和这个测试有很大的关系。 另外，我使用 systemd-analyze 命令，打开了 systemd 的调试级别日志，发现 systemd 有 Operation not supported 的报错。 根据以上零散的知识，可以给出一个大概的结论：org.freedesktop.systemd1 这个 bus 在经过大量 unit 创建删除之后，没有了响应。而这些频繁的 unit 创建删除测试，是 runC 某一个改动引入的。这个改动使得 UseSystemd 函数通过创建 unit 来测试 systemd 的功能。UseSystemd 在很多地方被调用，比如创建容器，或者查看容器性能等操作。 代码分析 这个问题在线上所有 Kubernetes 集群中，发生的频率大概是一个月两例。问题一直在发生，且只能在问题发生之后，通过重启 systemd 来处理，这风险极大。 我们分别给 systemd 和 runC 社区提交了 bug，但是一个很现实的问题是，他们并没有像阿里云这样的线上环境，他们重现这个问题的概率几乎是零，所以这个问题没有办法指望社区来解决。硬骨头还得我们自己啃。 在上一节最后，我们看到了，问题出现的时候，systemd 会输出一些 Operation not supported 报错。这个报错看起来和问题本身风马牛不相及，但是直觉告诉我，这，或许是离问题最近的一个地方，所以我决定，先搞清楚这个报错因何而来。 Systemd 代码量比较大，而报这个错误的地方非常多。通过大量的代码分析（这里略去一千字），我发现有几处比较可疑地方，有了这些可疑的地方，接下来需要做的事情，就是等待。在等了三周以后，终于有线上集群，再次重现了这个问题。 Live Debugging 在征求用户同意之后，下载 systemd 调试符号，挂载 gdb 到 systemd 上，在可疑的函数下断点，continue 继续执行。经过多次验证，发现 systemd 最终踩到了sd_bus_message_seal 这个函数里的 EOPNOTSUPP 报错。 这个报错背后的道理是，systemd 使用了一个变量 cookie，来追踪自己处理的 dbus message 。每次在加封一个新的 message 的时候，systemd 会先给 cookie的值加一，然后再把这个值复制给这个新的 message。 我们使用 gdb 打印出 dbus-&gt;cookie 这个值，可以很清楚看到，这个值超过了0xffffffff 。所以看起来，问题是 systemd 在加封过大量 message 之后，cookie 这个值32位溢出了，导致新的消息不能被加封，从而使得 systemd 对 runC 没有了响应。 另外，在一个正常的系统上，使用 gdb 把 bus-&gt;cookie 这个值改到接近 0xffffffff，然后观察到，问题在 cookie 溢出的时候立刻出现，则证明了我们的结论。 怎么判断集群节点NotReady是这个问题导致的 首先我们需要在有问题的节点上安装 gdb 和 systemd debuginfo，然后用命令 gdb /usr/lib/systemd/systemd1 把 gdb attach 到 systemd ，在函数sd_bus_send 设置断点，然后继续执行。等 systemd 踩到断点之后，用 p /x bus-&gt;cookie 查看对应的cookie值，如果此值超过了 0xffffffff，那么 cookie 就溢出了，则必然导致节点 NotReady 的问题。确认完之后，可以使用 quit 来 detach 调试器。 问题修复 这个问题的修复，并没有那么直截了当。原因之一，是 systemd 使用了同一个 cookie 变量，来兼容 dbus1 和 dbus2 。对于 dbus1 来说， cookie 是32位的，这个值在经过 systemd 三五个月频繁创建删除 unit 之后，是肯定会溢出的；而 dbus2 的 cookie 是64位的，可能到了时间的尽头，它也不会溢出。 另外一个原因是，我们并不能简单的让 cookie 折返，来解决溢出问题。因为这有可能导致 systemd 使用同一个 cookie 来加封不同的消息，这样的结果将是灾难性的。 最终的修复方法是，使用32位 cookie 来同样处理 dbus1 和 dbus2 两种情形。同时在 cookie 达到 0xfffffff 的之后，下一个 cookie 则变成 0x80000000，即用最高位来标记 cookie 已经处于溢出状态。检查到 cookie 处于这种状态时，我们需要检查是否下一个 cookie 正在被其他 message 使用，来避免 cookie 冲突。 后记 这个问题根本原因肯定在 systemd，但是 runC 的函数 UseSystemd 使用不那么美丽的方法，去测试 systemd 的功能，而这个函数在整个容器生命周期管理过程中，被频繁的调用，让这个低概率问题的发生成为了可能。systemd 的修复已经被红帽接受，预期不久的将来，我们可以通过升级 systemd，从根本上解决这个问题。 你可能还喜欢 点击下方图片即可阅读 贾扬清：我对人工智能方向的一点浅见 如何搞定技术面试？阿里大牛为你选了8本必备好书 在阿里做了五年技术主管，我有话想说" />
<link rel="canonical" href="https://mlh.app/2019/04/29/729077.html" />
<meta property="og:url" content="https://mlh.app/2019/04/29/729077.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"阿里妹导读：排查完全陌生的问题、不熟悉的系统组件，对许多工程师来说是无与伦比的工作乐趣，当然也是一大挑战。今天，阿里巴巴售后技术专家声东跟大家分享一例 Kubernetes 集群上的问题。这个问题影响范围较广，或许某天你也会遇到。更重要的是，作者在问题排查过程中的思路和方法，也会让你有所启发。 关于问题 I am Not Ready 阿里云有自己的 Kubernetes 容器集群产品。随着 Kubernetes 集群出货量剧增，线上用户零星地发现，集群会非常低概率地出现节点 NotReady 情况。据我们观察，这个问题差不多每个月，都会有一两个用户遇到。在节点 NotReady 之后，集群 Master 没有办法对这个节点做任何控制，比如下发新的 Pod，再比如抓取节点上正在运行 Pod 的实时信息。 需要知道的Kubernetes知识 这里我稍微补充一点 Kubernetes 集群的基本知识。Kubernetes 集群的“硬件基础”，是以单机形态存在的集群节点。这些节点可以是物理机，也可以是虚拟机。集群节点分为 Master 节点和 Worker 节点。Master 节点主要用来承载集群管控组件，比如调度器和控制器。而 Worker 节点主要用来跑业务。Kubelet 是跑在各个节点上的代理，它负责与管控组件沟通，并按照管控组件的指示，直接管理 Worker节点。 当集群节点进入 NotReady 状态的时候，我们需要做的第一件事情，是检查运行在节点上的 kubelet 是否正常。在这个问题出现的时候，使用 systemctl 命令查看的kubelet 状态（kubelet 是 systemd 管理的一个 daemon ）发现它是正常运行的。当我们用 journalctl 查看 kubelet 日志的时候，发现以下错误。 什么是PLEG？ 这个报错清楚地告诉我们，容器 runtime 是不工作的，且 PLEG 是不健康的。这里容器 runtime 指的就是 docker daemon 。Kubelet 通过操作 docker daemon 来控制容器的生命周期。而这里的 PLEG，指的是 pod lifecycle event generator。PLEG 是 kubelet 用来检查 runtime 的健康检查机制。这件事情本来可以由 kubelet 使用 polling 的方式来做。但是 polling 有其高成本的缺陷，所以 PLEG 应用而生。PLEG 尝试以一种“中断”的形式，来实现对容器 runtime 的健康检查，虽然实际上，它同时用了 polling 和”中断”这样折中的方案。 基本上，根据上边的报错，我们可以确认容器 runtime 出了问题。在有问题的节点上，通过 docker 命令尝试运行新的容器，命令会没有响应，这说明上边的报错是准确的。 Docker Stack Docker Daemon调用栈分析 Docker 作为阿里云 Kubernetes 集群使用的容器 runtime ，在1.11之后，被拆分成了多个组件以适应 OCI 标准。拆分之后，其包括 docker daemon，containerd，containerd-shim 以及 runC。组件 containerd 负责集群节点上容器的生命周期管理，并向上为 docker daemon 提供 gRPC 接口。 在这个问题中，既然 PLEG 认为容器 runtime 出了问题，我们需要从 docker daemon 进程看起。我们可以使用 kill -USR1 &lt;pid&gt; 命令发送 USR1 信号给docker daemon，而 docker daemon 收到信号之后，会把所有线程调用栈输出到 /var/run/docker 文件夹里。 Docker daemon 进程的调用栈是比较容易分析的。稍加留意，我们会发现大多数的调用栈都长成下图中的样子。通过观察栈上每个函数的名字，以及函数所在的文件（模块）名称，我们可以了解到，这个调用栈的下半部分，是进程接到 http 请求，做请求路由的过程；而上半部分则是具体的处理函数。最终处理函数进入等待状态，等待一个mutex实例。 到这里，我们需要稍微看一下 ContainerInspectCurrent 这个函数的实现。从实现可以看到，这个函数的第一个参数，就是这个线程正在操作的容器名指针。使用这个指针搜索整个调用栈文件，我们会找出所有等在这个容器上的线程。同时，我们可以看到下边这个线程。 这个线程调用栈上的函数 ContainerExecStart 也是在处理相同容器。但不同的是，ContainerExecStart 并没有在等这个容器，而是已经拿到了这个容器的操作权（mutex），并把执行逻辑转向了 containerd 调用。关于这一点，我们也可以使用代码来验证。前边我提到过，containerd 通过 gRPC 向上对 docker daemon 提供接口。此调用栈上半部分内容，正是 docker daemon 在通过 gRPC 请求来呼叫containerd。 Containerd调用栈分析 与 docker daemon 类似，我们可以通过 kill -SIGUSR1 &lt;pid&gt; 命令来输出containerd 的调用栈。不同的是，这次调用栈会直接输出到 messages 日志。 Containerd 作为一个 gRPC 的服务器，会在接到 docker daemon 的远程调用之后，新建一个线程去处理这次请求。关于 gRPC 的细节，我们这里其实不用太多关注。在这次请求的客户端调用栈上，可以看到这次调用的核心函数在 Start 一个Process 。我们在 containerd 的调用栈里搜索 Start，Process 以及 process.go 等字段，很容易发现下边这个线程。 这个线程的核心任务，就是依靠 runC 去创建容器进程。而在容器启动之后，runC 进程会退出。所以下一步，我们自然而然会想到，runC 是不是有顺利完成自己的任务。查看进程列表，我们会发现，系统中有个别 runC 进程还在执行，这不是预期的行为。容器的启动，跟进程的启动，耗时应该是差不多数量级的，系统里有正在运行的 runC 进程，则说明 runC 不能正常启动容器。 什么是D-Bus？ RunC请求D-Bus 容器 runtime 的 runC 命令，是 libcontainer 的一个简单的封装。这个工具可以用来管理单个容器，比如容器创建和容器删除。在上节的最后，我们发现 runC 不能完成创建容器的任务。我们可以把对应的进程杀掉，然后在命令行用同样的命令启动容器，同时用 strace 追踪整个过程。 分析发现，runC 停在了向带有 org.free 字段的 dbus socket 写数据的地方。那什么是 dbus 呢？在 Linux 上，dbus 是一种进程间进行消息通信的机制。 原因并不在 D-Bus 我们可以使用 busctl 命令列出系统现有的所有 bus 。如下图，在问题发生的时候，我看到问题节点 bus name 编号非常大。所以我倾向于认为，dbus 某些相关的数据结构，比如 name，耗尽了引起了这个问题。 Dbus 机制的实现，依赖于一个组件叫做 dbus daemon。如果真的是 dbus 相关数据结构耗尽，那么重启这个 daemon，应该可以解决这个问题。但不幸的是，问题并没有这么直接。重启 dbus daemon 之后，问题依然存在。 在上边 strace 追踪 runC 的截图中，runC 停在向带有 org.free 字段的 bus 写数据的地方。在 busctl 输出的 bus 列表里，显然带有这个字段的 bus，都在被 systemd使用。这时，我们用 systemctl daemon-reexec 来重启 systemd，问题消失了。所以基本上我们可以判断一个方向，问题可能跟 systemd 有关。 Systemd是硬骨头 Systemd 是相当复杂的一个组件，尤其对没有做过相关开发工作的同学来说，比如我自己。基本上，排查 systemd 的问题，我用到了四个方法，（调试级别）日志，core dump，代码分析，以及 live debugging。其中第一个，第三个和第四个结合起来使用，让我在经过几天的鏖战之后，找到了问题的原因。但是这里我们先从“没用”的 core dump 说起。 “没用的”Core Dump 因为重启 systemd 解决了问题，而这个问题本身，是 runC 在使用 dbus 和systemd 通信的时候没有了响应，所以我们需要验证的第一件事情，就是 systemd不是有关键线程被锁住了。查看 core dump 里所有线程，只有以下一个线程，此线程并没有被锁住，它在等待 dbus 事件，以便做出响应。 零散的信息 因为无计可施，所以只能做各种测试、尝试。使用 busctl tree 命令，可以输出所有bus 上对外暴露的接口。从输出结果看来，org.freedesktop.systemd1 这个 bus 是不能响应接口查询请求的。 使用下边的命令，观察 org.freedesktop.systemd1 上接受到的所以请求，可以看到，在正常系统里，有大量 Unit 创建删除的消息，但是有问题的系统里，这个 bus 上完全没有任何消息。 gdbus monitor --system --dest org.freedesktop.systemd1 --object-path /org/freedesktop/systemd1 分析问题发生前后的系统日志，runC在重复的跑一个libcontainer_%d_systemd_test_default.slice 测试，这个测试非常频繁，但是当问题发生的时候，这个测试就停止了。所以直觉告诉我，这个问题，可能和这个测试有很大的关系。 另外，我使用 systemd-analyze 命令，打开了 systemd 的调试级别日志，发现 systemd 有 Operation not supported 的报错。 根据以上零散的知识，可以给出一个大概的结论：org.freedesktop.systemd1 这个 bus 在经过大量 unit 创建删除之后，没有了响应。而这些频繁的 unit 创建删除测试，是 runC 某一个改动引入的。这个改动使得 UseSystemd 函数通过创建 unit 来测试 systemd 的功能。UseSystemd 在很多地方被调用，比如创建容器，或者查看容器性能等操作。 代码分析 这个问题在线上所有 Kubernetes 集群中，发生的频率大概是一个月两例。问题一直在发生，且只能在问题发生之后，通过重启 systemd 来处理，这风险极大。 我们分别给 systemd 和 runC 社区提交了 bug，但是一个很现实的问题是，他们并没有像阿里云这样的线上环境，他们重现这个问题的概率几乎是零，所以这个问题没有办法指望社区来解决。硬骨头还得我们自己啃。 在上一节最后，我们看到了，问题出现的时候，systemd 会输出一些 Operation not supported 报错。这个报错看起来和问题本身风马牛不相及，但是直觉告诉我，这，或许是离问题最近的一个地方，所以我决定，先搞清楚这个报错因何而来。 Systemd 代码量比较大，而报这个错误的地方非常多。通过大量的代码分析（这里略去一千字），我发现有几处比较可疑地方，有了这些可疑的地方，接下来需要做的事情，就是等待。在等了三周以后，终于有线上集群，再次重现了这个问题。 Live Debugging 在征求用户同意之后，下载 systemd 调试符号，挂载 gdb 到 systemd 上，在可疑的函数下断点，continue 继续执行。经过多次验证，发现 systemd 最终踩到了sd_bus_message_seal 这个函数里的 EOPNOTSUPP 报错。 这个报错背后的道理是，systemd 使用了一个变量 cookie，来追踪自己处理的 dbus message 。每次在加封一个新的 message 的时候，systemd 会先给 cookie的值加一，然后再把这个值复制给这个新的 message。 我们使用 gdb 打印出 dbus-&gt;cookie 这个值，可以很清楚看到，这个值超过了0xffffffff 。所以看起来，问题是 systemd 在加封过大量 message 之后，cookie 这个值32位溢出了，导致新的消息不能被加封，从而使得 systemd 对 runC 没有了响应。 另外，在一个正常的系统上，使用 gdb 把 bus-&gt;cookie 这个值改到接近 0xffffffff，然后观察到，问题在 cookie 溢出的时候立刻出现，则证明了我们的结论。 怎么判断集群节点NotReady是这个问题导致的 首先我们需要在有问题的节点上安装 gdb 和 systemd debuginfo，然后用命令 gdb /usr/lib/systemd/systemd1 把 gdb attach 到 systemd ，在函数sd_bus_send 设置断点，然后继续执行。等 systemd 踩到断点之后，用 p /x bus-&gt;cookie 查看对应的cookie值，如果此值超过了 0xffffffff，那么 cookie 就溢出了，则必然导致节点 NotReady 的问题。确认完之后，可以使用 quit 来 detach 调试器。 问题修复 这个问题的修复，并没有那么直截了当。原因之一，是 systemd 使用了同一个 cookie 变量，来兼容 dbus1 和 dbus2 。对于 dbus1 来说， cookie 是32位的，这个值在经过 systemd 三五个月频繁创建删除 unit 之后，是肯定会溢出的；而 dbus2 的 cookie 是64位的，可能到了时间的尽头，它也不会溢出。 另外一个原因是，我们并不能简单的让 cookie 折返，来解决溢出问题。因为这有可能导致 systemd 使用同一个 cookie 来加封不同的消息，这样的结果将是灾难性的。 最终的修复方法是，使用32位 cookie 来同样处理 dbus1 和 dbus2 两种情形。同时在 cookie 达到 0xfffffff 的之后，下一个 cookie 则变成 0x80000000，即用最高位来标记 cookie 已经处于溢出状态。检查到 cookie 处于这种状态时，我们需要检查是否下一个 cookie 正在被其他 message 使用，来避免 cookie 冲突。 后记 这个问题根本原因肯定在 systemd，但是 runC 的函数 UseSystemd 使用不那么美丽的方法，去测试 systemd 的功能，而这个函数在整个容器生命周期管理过程中，被频繁的调用，让这个低概率问题的发生成为了可能。systemd 的修复已经被红帽接受，预期不久的将来，我们可以通过升级 systemd，从根本上解决这个问题。 你可能还喜欢 点击下方图片即可阅读 贾扬清：我对人工智能方向的一点浅见 如何搞定技术面试？阿里大牛为你选了8本必备好书 在阿里做了五年技术主管，我有话想说","@type":"BlogPosting","url":"https://mlh.app/2019/04/29/729077.html","headline":"K8S 从懵圈到熟练：读懂此文，集群节点不下线！","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/29/729077.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>K8S&nbsp;从懵圈到熟练：读懂此文，集群节点不下线！</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="white-space: normal;text-align: center;"><img class="rich_pages" data-backh="371" data-backw="556" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzNztgBK07icJxDMwEibIXAOa2ITTaaOHcm0SX2cR14ibI8QORCXI33o1DA/640?wx_fmt=jpeg" data-copyright="0" data-ratio="0.6669921875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzNztgBK07icJxDMwEibIXAOa2ITTaaOHcm0SX2cR14ibI8QORCXI33o1DA/640?wx_fmt=jpeg" data-type="jpeg" data-w="1024" style="color: rgb(136, 136, 136);font-size: 15px;letter-spacing: 0.612px;white-space: normal;background-color: rgb(235, 235, 235);text-align: center;width: 100%;height: auto;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzNztgBK07icJxDMwEibIXAOa2ITTaaOHcm0SX2cR14ibI8QORCXI33o1DA/640?wx_fmt=jpeg"></p> 
<section class="" powered-by="xiumi.us" style="white-space: normal;max-width: 100%;letter-spacing: 0.544px;line-height: 27.2px;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"> 
 <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
  <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
   <section class="" powered-by="xiumi.us" style="max-width: 100%;letter-spacing: 0.544px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
    <section class="" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
     <section label="Copyright Reserved by PLAYHUDONG." donone="shifuMouseDownCard('shifu_c_008')" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
      <section class="" powered-by="xiumi.us" style="max-width: 100%;letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
       <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
        <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
         <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
          <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
           <section label="Copyright Reserved by PLAYHUDONG." donone="shifuMouseDownCard('shifu_c_008')" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
            <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
             <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
              <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
               <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                 <section label="Copyright Reserved by PLAYHUDONG." donone="shifuMouseDownCard('shifu_c_008')" style="margin-right: 0em;margin-left: 0em;padding: 0.5em 1em;max-width: 100%;border-style: none;background-color: rgb(235, 235, 235);box-sizing: border-box !important;word-wrap: break-word !important;"> 
                  <p style="max-width: 100%;min-height: 1em;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">阿里妹导读：</span><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">排查完全陌生的问题、不熟悉的系统组件，对许多工程师来说是无与伦比的工作乐趣，当然也是一大挑战。</span><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">今天，阿里巴巴售后技术专家声东跟大家分享一例 Kubernetes 集群上的问题。这个问题影响范围较广，或许某天你也会遇到。更重要的是，作者在</span><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">问题排查过程中的</span><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">思路和方法，也会让你有所启发。</span></p> 
                 </section> 
                </section> 
               </section> 
              </section> 
             </section> 
            </section> 
           </section> 
          </section> 
         </section> 
        </section> 
       </section> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section> 
<p style="white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);text-align: left;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">关于问题</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">I am Not Ready</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">阿里云有自己的 Kubernetes 容器集群产品。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">随着 Kubernetes 集群出货量剧增，线上用户零星地发现，集群会非常低概率地出现节点 NotReady 情况。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">据我们观察，这个问题差不多每个月，都会有一两个用户遇到。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">在节点 NotReady 之后，集群 Master 没有办法对这个节点做任何控制，比如下发新的 Pod，再比如抓取节点上正在运行 Pod 的实时信息。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;"><img class="" data-ratio="0.1958128078817734" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzNYwia0oVianOEkAy1OwiaWwtuAicugSGSw8WDpVmjicDFH8v9pLS7IEh6Tw/640?wx_fmt=png" data-type="png" data-w="812" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzNYwia0oVianOEkAy1OwiaWwtuAicugSGSw8WDpVmjicDFH8v9pLS7IEh6Tw/640?wx_fmt=png"></p> 
<p style="white-space: normal;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;text-align: left;"><br></span></strong></p> 
<p style="white-space: normal;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;text-align: left;">需要知道的Kubernetes知识</span></strong></p> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">这里我稍微补充一点 Kubernetes 集群的基本知识。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">Kubernetes 集群的“硬件基础”，是以单机形态存在的集群节点。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">这些节点可以是物理机，也可以是虚拟机。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">集群节点分为 Master 节点和 Worker 节点。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">Master 节点主要用来承载集群管控组件，比如调度器和控制器。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">而 Worker 节点主要用来跑业务。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">Kubelet 是跑在各个节点上的代理，它负责与管控组件沟通，并按照管控组件的指示，直接管理 Worker节点。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.3153526970954357" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzjfZkuHgSMicNI5E2RUOshojMXFeVqx4UE925VFsz27zc7lsicV7icib9vw/640?wx_fmt=png" data-type="png" data-w="1446" height="227" width="718" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzjfZkuHgSMicNI5E2RUOshojMXFeVqx4UE925VFsz27zc7lsicV7icib9vw/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">当集群节点进入 NotReady 状态的时候，我们需要做的第一件事情，是检查运行在节点上的 kubelet 是否正常。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">在这个问题出现的时候，使用 systemctl 命令查看的kubelet 状态（kubelet 是 systemd 管理的一个 daemon ）发现它是正常运行的。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">当我们用 journalctl 查看 kubelet 日志的时候，发现以下错误。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);"><img class="" data-ratio="0.1622340425531915" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzY2Y7PDO51D4FtziaRYrA24EFEEUuVG7zicSrdGYf9KnypEiaUKmIAEgmA/640?wx_fmt=jpeg" data-type="jpeg" data-w="1128" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzY2Y7PDO51D4FtziaRYrA24EFEEUuVG7zicSrdGYf9KnypEiaUKmIAEgmA/640?wx_fmt=jpeg"></span></p> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;text-align: left;">什么是PLEG？</span></strong></p> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">这个报错清楚地告诉我们，容器 runtime 是不工作的，且 PLEG 是不健康的。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">这里容器 runtime 指的就是 docker daemon 。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">Kubelet 通过操作 docker daemon 来控制容器的生命周期。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">而这里的 PLEG，指的是 pod lifecycle event generator。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">PLEG 是 kubelet 用来检查 runtime 的健康检查机制。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">这件事情本来可以由 kubelet 使用 polling 的方式来做。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">但是 polling 有其高成本的缺陷，所以 PLEG 应用而生。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">PLEG 尝试以一种“中断”的形式，来实现对容器 runtime 的健康检查，虽然实际上，它同时用了 polling 和”中断”这样折中的方案。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.561141304347826" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltztnVBRmoxGVYc7og5QV2WPLTbfaicOqFSfmnqYh8W0J9kE2ZIJImQ7qw/640?wx_fmt=png" data-type="png" data-w="736" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltztnVBRmoxGVYc7og5QV2WPLTbfaicOqFSfmnqYh8W0J9kE2ZIJImQ7qw/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">基本上，根据上边的报错，我们可以确认容器 runtime 出了问题。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">在有问题的节点上，通过 docker 命令尝试运行新的容器，命令会没有响应，这说明上边的报错是准确的。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">Docker Stack</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">Docker Daemon调用栈分析</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Docker 作为阿里云 Kubernetes 集群使用的容器 runtime ，在1.11之后，被拆分成了多个组件以适应 OCI 标准。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">拆分之后，其包括 docker daemon，containerd，containerd-shim 以及 runC。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">组件 containerd 负责集群节点上容器的生命周期管理，并向上为 docker daemon 提供 gRPC 接口。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.5704989154013015" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzH941kcjcibBqLiamfgSV2lZ9SebOSstTLKClQ1WscPo6jaWMR2IqhTmA/640?wx_fmt=png" data-type="png" data-w="1383" height="373" width="653" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzH941kcjcibBqLiamfgSV2lZ9SebOSstTLKClQ1WscPo6jaWMR2IqhTmA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">在这个问题中，既然 PLEG 认为容器 runtime 出了问题，我们需要从 docker daemon 进程看起。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">我们可以使用 kill -USR1 &lt;pid&gt; 命令发送 USR1 信号给docker daemon，而 docker daemon 收到信号之后，会把所有线程调用栈输出到 /var/run/docker 文件夹里。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Docker daemon 进程的调用栈是比较容易分析的。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">稍加留意，我们会发现大多数的调用栈都长成下图中的样子。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">通过观察栈上每个函数的名字，以及函数所在的文件（模块）名称，我们可以了解到，这个调用栈的下半部分，是进程接到 http 请求，做请求路由的过程；</span><span style="font-size: 15px;color: rgb(62, 62, 62);">而上半部分则是具体的处理函数。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">最终处理函数进入等待状态，等待一个mutex实例。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);"><img class="" data-ratio="0.5206117021276596" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzFM94paVc9F1w5gYmyb17LHZFMicLMtlmcc9cn5QZXhJ5nABc22alMGw/640?wx_fmt=png" data-type="png" data-w="1504" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzFM94paVc9F1w5gYmyb17LHZFMicLMtlmcc9cn5QZXhJ5nABc22alMGw/640?wx_fmt=png"></span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">到这里，我们需要稍微看一下 ContainerInspectCurrent 这个函数的实现。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">从实现可以看到，这个函数的第一个参数，就是这个线程正在操作的容器名指针。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">使用这个指针搜索整个调用栈文件，我们会找出所有等在这个容器上的线程。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">同时，我们可以看到下边这个线程。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.5325797872340425" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzGDxALX4E1xtPia31D7aR2AA2FWvOFa9FkA9FbRTL0P7iaMRYSPhlD2Hg/640?wx_fmt=png" data-type="png" data-w="1504" height="675" width="1267" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzGDxALX4E1xtPia31D7aR2AA2FWvOFa9FkA9FbRTL0P7iaMRYSPhlD2Hg/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">这个线程调用栈上的函数 ContainerExecStart 也是在处理相同容器。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">但不同的是，ContainerExecStart 并没有在等这个容器，而是已经拿到了这个容器的操作权（mutex），并把执行逻辑转向了 containerd 调用。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">关于这一点，我们也可以使用代码来验证。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">前边我提到过，containerd 通过 gRPC 向上对 docker daemon 提供接口。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">此调用栈上半部分内容，正是 docker daemon 在通过 gRPC 请求来呼叫containerd。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">Containerd调用栈分析</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">与 docker daemon 类似，我们可以通过 kill -SIGUSR1 &lt;pid&gt; 命令来输出containerd 的调用栈。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">不同的是，这次调用栈会直接输出到 messages 日志。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);"><br></span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Containerd 作为一个 gRPC 的服务器，会在接到 docker daemon 的远程调用之后，新建一个线程去处理这次请求。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">关于 gRPC 的细节，我们这里其实不用太多关注。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">在这次请求的客户端调用栈上，可以看到这次调用的核心函数在 Start 一个Process 。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">我们在 containerd 的调用栈里搜索 Start，Process 以及 process.go 等字段，很容易发现下边这个线程。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.5292942743009321" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzeQ9HNHzKeKGbdiaibh7sbg76DsdTGsxkU5LbXeN1EtneaX1BlITUF5gA/640?wx_fmt=png" data-type="png" data-w="1502" height="638" width="1205" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzeQ9HNHzKeKGbdiaibh7sbg76DsdTGsxkU5LbXeN1EtneaX1BlITUF5gA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">这个线程的核心任务，就是依靠 runC 去创建容器进程。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">而在容器启动之后，runC 进程会退出。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">所以下一步，我们自然而然会想到，runC 是不是有顺利完成自己的任务。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">查看进程列表，我们会发现，系统中有个别 runC 进程还在执行，这不是预期的行为。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">容器的启动，跟进程的启动，耗时应该是差不多数量级的，系统里有正在运行的 runC 进程，则说明 runC 不能正常启动容器。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">什么是D-Bus？</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">RunC请求D-Bus</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">容器 runtime 的 runC 命令，是 libcontainer 的一个简单的封装。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">这个工具可以用来管理单个容器，比如容器创建和容器删除。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">在上节的最后，我们发现 runC 不能完成创建容器的任务。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">我们可以把对应的进程杀掉，然后在命令行用同样的命令启动容器，同时用 strace 追踪整个过程。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.33489304812834225" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzwp5vXl6uDp0Lgibr8Libia3vqw1IicFCsclbXvVmvpVjMvhGacJgwFpicrA/640?wx_fmt=png" data-type="png" data-w="1496" height="389" width="1162" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzwp5vXl6uDp0Lgibr8Libia3vqw1IicFCsclbXvVmvpVjMvhGacJgwFpicrA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">分析发现，runC 停在了向带有 org.free 字段的 dbus socket 写数据的地方。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">那什么是 dbus 呢？</span><span style="font-size: 15px;color: rgb(62, 62, 62);">在 Linux 上，dbus 是一种进程间进行消息通信的机制。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">原因并不在 D-Bus</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.4411177644710579" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzQTENP1M7LOn0wMOtSTtvkE1hNllic2mmL5TYO0W6VUzTKmd45STrzQg/640?wx_fmt=png" data-type="png" data-w="1503" height="291" width="660" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzQTENP1M7LOn0wMOtSTtvkE1hNllic2mmL5TYO0W6VUzTKmd45STrzQg/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">我们可以使用 busctl 命令列出系统现有的所有 bus 。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">如下图，在问题发生的时候，我看到问题节点 bus name 编号非常大。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">所以我倾向于认为，dbus 某些相关的数据结构，比如 name，耗尽了引起了这个问题。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.4538087520259319" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzl4dRgHpXbIGPZsPBmjCbF5LibgGBKWo13xB54ianc1njqUvAZJd3KeCw/640?wx_fmt=png" data-type="png" data-w="1234" height="477" width="1051" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzl4dRgHpXbIGPZsPBmjCbF5LibgGBKWo13xB54ianc1njqUvAZJd3KeCw/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Dbus 机制的实现，依赖于一个组件叫做 dbus daemon。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">如果真的是 dbus 相关数据结构耗尽，那么重启这个 daemon，应该可以解决这个问题。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">但不幸的是，问题并没有这么直接。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">重启 dbus daemon 之后，问题依然存在。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">在上边 strace 追踪 runC 的截图中，runC 停在向带有 org.free 字段的 bus 写数据的地方。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">在 busctl 输出的 bus 列表里，显然带有这个字段的 bus，都在被 systemd使用。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">这时，我们用 systemctl daemon-reexec 来重启 systemd，问题消失了。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">所以基本上我们可以判断一个方向，问题可能跟 systemd 有关。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">Systemd是硬骨头</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Systemd 是相当复杂的一个组件，尤其对没有做过相关开发工作的同学来说，比如我自己。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">基本上，排查 systemd 的问题，我用到了四个方法，（调试级别）日志，core dump，代码分析，以及 live debugging。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">其中第一个，第三个和第四个结合起来使用，让我在经过几天的鏖战之后，找到了问题的原因。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">但是这里我们先从“没用”的 core dump 说起。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">“没用的”Core Dump</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">因为重启 systemd 解决了问题，而这个问题本身，是 runC 在使用 dbus 和systemd 通信的时候没有了响应，所以我们需要验证的第一件事情，就是 systemd不是有关键线程被锁住了。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">查看 core dump 里所有线程，只有以下一个线程，此线程并没有被锁住，它在等待 dbus 事件，以便做出响应。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;"><img class="" data-ratio="0.13859111791730475" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzrsDJvrrEoBOdXR0KmEJtdiaU9kMJQVm6eC7vufaJ5xQUZNHzyI7UoVA/640?wx_fmt=png" data-type="png" data-w="1306" height="152" width="1097" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzrsDJvrrEoBOdXR0KmEJtdiaU9kMJQVm6eC7vufaJ5xQUZNHzyI7UoVA/640?wx_fmt=png"></p> 
<p style="white-space: normal;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;text-align: left;"><br></span></strong></p> 
<p style="white-space: normal;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;text-align: left;">零散的信息</span></strong></p> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">因为无计可施，所以只能做各种测试、尝试。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">使用 busctl tree 命令，可以输出所有bus 上对外暴露的接口。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">从输出结果看来，org.freedesktop.systemd1 这个 bus 是不能响应接口查询请求的。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.48759439050701187" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltz5bObJ7LOO4exjdPkuGGZY7VR5h5r2LwADrgW1u5Lqp1iaOyagqPAVCQ/640?wx_fmt=png" data-type="png" data-w="927" height="380" width="779" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltz5bObJ7LOO4exjdPkuGGZY7VR5h5r2LwADrgW1u5Lqp1iaOyagqPAVCQ/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">使用下边的命令，观察 org.freedesktop.systemd1 上接受到的所以请求，可以看到，在正常系统里，有大量 Unit 创建删除的消息，但是有问题的系统里，这个 bus 上完全没有任何消息。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">gdbus monitor --system --dest org.freedesktop.systemd1 --object-path /org/freedesktop/systemd1</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.293218085106383" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzH30oyIBu07AkUY4DvsPHXjFiaiaygP4gd1xdlozJrXchZ8pvIicvbQrZA/640?wx_fmt=png" data-type="png" data-w="1504" height="355" width="1211" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzH30oyIBu07AkUY4DvsPHXjFiaiaygP4gd1xdlozJrXchZ8pvIicvbQrZA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">分析问题发生前后的系统日志，runC在重复的跑一个libcontainer_%d_systemd_test_default.slice 测试，这个测试非常频繁，但是当问题发生的时候，这个测试就停止了。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">所以直觉告诉我，这个问题，可能和这个测试有很大的关系。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.375590020229265" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzWAmUM2ib93Cjrukq4l9ia05lrYbzdKpXvo9UcfBEVdBK97TTpZ33Nfpg/640?wx_fmt=jpeg" data-type="jpeg" data-w="1483" height="406" width="1081" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzWAmUM2ib93Cjrukq4l9ia05lrYbzdKpXvo9UcfBEVdBK97TTpZ33Nfpg/640?wx_fmt=jpeg"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">另外，我使用 systemd-analyze 命令，打开了 systemd 的调试级别日志，发现 systemd 有 Operation not supported 的报错。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.42884739214423695" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzqExsBPPrPW9laibicEWV2kZBHwAib7jUmY7r204UufyFKCQM9MIsSVIAA/640?wx_fmt=jpeg" data-type="jpeg" data-w="1553" height="488" width="1138" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzqExsBPPrPW9laibicEWV2kZBHwAib7jUmY7r204UufyFKCQM9MIsSVIAA/640?wx_fmt=jpeg"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">根据以上零散的知识，可以给出一个大概的结论：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">org.freedesktop.systemd1 这个 bus 在经过大量 unit 创建删除之后，没有了响应。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">而这些频繁的 unit 创建删除测试，是 runC 某一个改动引入的。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">这个改动使得 UseSystemd 函数通过创建 unit 来测试 systemd 的功能。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">UseSystemd 在很多地方被调用，比如创建容器，或者查看容器性能等操作。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">代码分析</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">这个问题在线上所有 Kubernetes 集群中，发生的频率大概是一个月两例。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">问题一直在发生，且只能在问题发生之后，通过重启 systemd 来处理，这风险极大。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">我们分别给 systemd 和 runC 社区提交了 bug，但是一个很现实的问题是，他们并没有像阿里云这样的线上环境，他们重现这个问题的概率几乎是零，所以这个问题没有办法指望社区来解决。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">硬骨头还得我们自己啃。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">在上一节最后，我们看到了，问题出现的时候，systemd 会输出一些 Operation not supported 报错。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">这个报错看起来和问题本身风马牛不相及，但是直觉告诉我，这，或许是离问题最近的一个地方，所以我决定，先搞清楚这个报错因何而来。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Systemd 代码量比较大，而报这个错误的地方非常多。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">通过大量的代码分析（这里略去一千字），我发现有几处比较可疑地方，有了这些可疑的地方，接下来需要做的事情，就是等待。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">在等了三周以后，终于有线上集群，再次重现了这个问题。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">Live Debugging</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">在征求用户同意之后，下载 systemd 调试符号，挂载 gdb 到 systemd 上，在可疑的函数下断点，continue 继续执行。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">经过多次验证，发现 systemd 最终踩到了sd_bus_message_seal 这个函数里的 EOPNOTSUPP 报错。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.6035834266517357" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzNfOKFymFFk8Md78Vsq6ic2A7qV5Kroo3AM7HlnJ3mLadxkUp71sicv1Q/640?wx_fmt=png" data-type="png" data-w="893" height="515" width="853" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzNfOKFymFFk8Md78Vsq6ic2A7qV5Kroo3AM7HlnJ3mLadxkUp71sicv1Q/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">这个报错背后的道理是，systemd 使用了一个变量 cookie，来追踪自己处理的 dbus message 。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">每次在加封一个新的 message 的时候，systemd 会先给 cookie的值加一，然后再把这个值复制给这个新的 message。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">我们使用 gdb 打印出 dbus<span style="color: rgb(25, 31, 37);font-family: -apple-system, system-ui, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Segoe UI&quot;, system-ui, Roboto, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif;font-size: 14px;text-align: left;white-space: pre-wrap;background-color: rgb(255, 255, 255);">-&gt;</span>cookie 这个值，可以很清楚看到，这个值超过了0xffffffff 。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">所以看起来，问题是 systemd 在加封过大量 message 之后，cookie 这个值32位溢出了，导致新的消息不能被加封，从而使得 systemd 对 runC 没有了响应。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;"><img class="" data-ratio="0.16549295774647887" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzGjN3dicbRYgIgbCREEvqnkDfaOvRpqibqhxEhMvhiaxZbCMpYA763yib6g/640?wx_fmt=jpeg" data-type="jpeg" data-w="1420" height="188" width="1136" style="margin-right: auto;margin-left: auto;box-sizing: content-box;border-width: 0px;border-style: none;border-color: initial;vertical-align: middle;display: block;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WyWBJbWL6Pf6mp5ZTF7pltzGjN3dicbRYgIgbCREEvqnkDfaOvRpqibqhxEhMvhiaxZbCMpYA763yib6g/640?wx_fmt=jpeg"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">另外，在一个正常的系统上，使用 gdb 把 bus<span style="color: rgb(25, 31, 37);font-family: -apple-system, system-ui, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Segoe UI&quot;, system-ui, Roboto, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif;font-size: 14px;text-align: left;white-space: pre-wrap;background-color: rgb(255, 255, 255);">-&gt;</span>cookie 这个值改到接近 0xffffffff，然后观察到，问题在 cookie 溢出的时候立刻出现，则证明了我们的结论。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">怎么判断集群节点NotReady是这个问题导致的</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">首先我们需要在有问题的节点上安装 gdb 和 systemd debuginfo，然后用命令 gdb /usr/lib/systemd/systemd1 把 gdb attach 到 systemd ，在函数sd_bus_send 设置断点，然后继续执行。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">等 systemd 踩到断点之后，用 p /x bus<span style="color: rgb(25, 31, 37);font-family: -apple-system, system-ui, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Segoe UI&quot;, system-ui, Roboto, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif;font-size: 14px;text-align: left;white-space: pre-wrap;background-color: rgb(255, 255, 255);">-&gt;</span>cookie 查看对应的cookie值，如果此值超过了 0xffffffff，那么 cookie 就溢出了，则必然导致节点 NotReady 的问题。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">确认完之后，可以使用 quit 来 detach 调试器。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">问题修复</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">这个问题的修复，并没有那么直截了当。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">原因之一，是 systemd 使用了同一个 cookie 变量，来兼容 dbus1 和 dbus2 。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">对于 dbus1 来说， cookie 是32位的，这个值在经过 systemd 三五个月频繁创建删除 unit 之后，是肯定会溢出的；</span><span style="font-size: 15px;color: rgb(62, 62, 62);">而 dbus2 的 cookie 是64位的，可能到了时间的尽头，它也不会溢出。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">另外一个原因是，我们并不能简单的让 cookie 折返，来解决溢出问题。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">因为这有可能导致 systemd 使用同一个 cookie 来加封不同的消息，这样的结果将是灾难性的。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">最终的修复方法是，使用32位 cookie 来同样处理 dbus1 和 dbus2 两种情形。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">同时在 cookie 达到 0xfffffff 的之后，下一个 cookie 则变成 0x80000000，即用最高位来标记 cookie 已经处于溢出状态。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">检查到 cookie 处于这种状态时，我们需要检查是否下一个 cookie 正在被其他 message 使用，来避免 cookie 冲突。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="color: rgb(255, 129, 36);"><strong><span style="font-size: 15px;">后记</span></strong></span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">这个问题根本原因肯定在 systemd，但是 runC 的函数 UseSystemd 使用不那么美丽的方法，去测试 systemd 的功能，而这个函数在整个容器生命周期管理过程中，被频繁的调用，让这个低概率问题的发生成为了可能。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">systemd 的修复已经被红帽接受，预期不久的将来，我们可以通过升级 systemd，从根本上解决这个问题。</span></p> 
<p><br></p> 
<p><br></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.04907481898632341" data-type="gif" data-w="1243" width="auto" data-src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKLzTlj0XiaExO7CCIZrf95viarmPTV7zRp58LaaLlESZlOxNwA4nWbpTXfwnOmRWkeBVWcVU2r2pRg/640?wx_fmt=gif" style="box-sizing: border-box !important;word-wrap: break-word !important;visibility: visible !important;width: auto !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKLzTlj0XiaExO7CCIZrf95viarmPTV7zRp58LaaLlESZlOxNwA4nWbpTXfwnOmRWkeBVWcVU2r2pRg/640?wx_fmt=gif"></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);font-size: 14px;font-family: monospace;white-space: pre;text-align: center;line-height: 1.75em;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="color: rgb(136, 136, 136);font-size: 15px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">你可能还喜欢</strong></span></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);font-size: 14px;font-family: monospace;white-space: pre;text-align: center;line-height: 1.75em;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="color: rgb(136, 136, 136);font-size: 12px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">点击下方图片即可阅读</span></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);font-size: 14px;font-family: monospace;white-space: pre;text-align: center;line-height: 1.75em;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490092&amp;idx=1&amp;sn=e8fa9b319e3ba36c3c8b0a3cce73dc90&amp;chksm=e9292723de5eae35462361046e687a605323c4519642b46bf82d2d9450a8dbdd851c2a853e54&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="1" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span class="js_jump_icon h5_image_link" data-positionback="static" style="line-height: 0;top: auto;left: auto;right: auto;bottom: auto;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="rich_pages " data-croporisrc="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJmOicicAiaIUNc5zXb0ZG3A8ajujYuxvMCzvxcAbta3VmjC4MiaysqmwgMwhSd6U25oxWlNhydiat8ISA/0?wx_fmt=jpeg" data-cropx1="0" data-cropx2="1280" data-cropy1="82.87769784172662" data-cropy2="688.3453237410072" data-ratio="0.4734375" data-s="300,640" data-type="jpeg" data-w="1280" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLia0vyfftXZfEaGQTzaqklW4bF2DEicbqiaev9nI9UGBcmmyRjwnMkxqJ1vfrbdG2SvmO4JtkpxEApw/640?wx_fmt=jpeg" style="box-sizing: border-box !important;word-wrap: break-word !important;width: 556px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLia0vyfftXZfEaGQTzaqklW4bF2DEicbqiaev9nI9UGBcmmyRjwnMkxqJ1vfrbdG2SvmO4JtkpxEApw/640?wx_fmt=jpeg"></span></a></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490092&amp;idx=1&amp;sn=e8fa9b319e3ba36c3c8b0a3cce73dc90&amp;chksm=e9292723de5eae35462361046e687a605323c4519642b46bf82d2d9450a8dbdd851c2a853e54&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="font-size: 14px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">贾扬清：我对人工智能方向的一点浅见</span></a><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490104&amp;idx=1&amp;sn=c4d92b922388e2dab74574951ba8ad3f&amp;chksm=e9292737de5eae212e8016f492b6e160b2f08be9445b043e088899d024c81179def428ff5840&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="1" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span class="js_jump_icon h5_image_link" data-positionback="static" style="line-height: 0;top: auto;left: auto;right: auto;bottom: auto;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="rich_pages " data-croporisrc="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLOe3wac5pKDuiaI1akeibsibyMHPPcatvB8iaNGy3btfPMlarJXjPEeLn6ibThL4hib4PtZJHXukRnESlw/0?wx_fmt=jpeg" data-cropx1="0" data-cropx2="1080" data-cropy1="248.63309352517985" data-cropy2="687.6258992805755" data-ratio="0.4064814814814815" data-s="300,640" data-type="jpeg" data-w="1080" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLia0vyfftXZfEaGQTzaqklWicMgdRF4VoIgQFU13xicyDTXh0CLjZn2l0nH0a00HAtiaLBxjAb5KScuQ/640?wx_fmt=jpeg" style="box-sizing: border-box !important;word-wrap: break-word !important;width: 556px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLia0vyfftXZfEaGQTzaqklWicMgdRF4VoIgQFU13xicyDTXh0CLjZn2l0nH0a00HAtiaLBxjAb5KScuQ/640?wx_fmt=jpeg"></span></a></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490104&amp;idx=1&amp;sn=c4d92b922388e2dab74574951ba8ad3f&amp;chksm=e9292737de5eae212e8016f492b6e160b2f08be9445b043e088899d024c81179def428ff5840&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="font-size: 14px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">如何搞定技术面试？阿里大牛为你选了8本必备好书</span></a><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490113&amp;idx=1&amp;sn=c25c6f392d4a6e780b18b61a6c858af1&amp;chksm=e929274ede5eae5898fcf4d45a803b4407a30557b6013c0a512650433181cd27ca99de296c74&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="1" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span class="js_jump_icon h5_image_link" data-positionback="static" style="line-height: 0;top: auto;left: auto;right: auto;bottom: auto;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="rich_pages " data-croporisrc="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLOe3wac5pKDuiaI1akeibsibyBgmaGtvyTha2WibDLT3deGMUJkwolibsoygHsbo6De1DiajC6ZqlxadVg/0?wx_fmt=jpeg" data-cropx1="0" data-cropx2="1280" data-cropy1="168.0575539568345" data-cropy2="785.0359712230215" data-ratio="0.48203125" data-s="300,640" data-type="jpeg" data-w="1280" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJzyjoXqDKTCTpYYHOjXWXIQeZTAzbiatZeSTqxPjgiaCJbHA3Crwd0icmIicgltkjJ7FODkepDwHmIFA/640?wx_fmt=jpeg" style="box-sizing: border-box !important;word-wrap: break-word !important;width: 556px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJzyjoXqDKTCTpYYHOjXWXIQeZTAzbiatZeSTqxPjgiaCJbHA3Crwd0icmIicgltkjJ7FODkepDwHmIFA/640?wx_fmt=jpeg"></span></a></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 14px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490113&amp;idx=1&amp;sn=c25c6f392d4a6e780b18b61a6c858af1&amp;chksm=e929274ede5eae5898fcf4d45a803b4407a30557b6013c0a512650433181cd27ca99de296c74&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">在阿里做了五年技术主管，我有话想说</a></span></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="__bg_gif " data-copyright="0" data-ratio="1.0616740088105727" data-type="gif" data-w="454" width="253px" data-src="https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naKcJeVLrERoBcjILPJtnWgOAsnKJ8RVuvGo7DPusIGvV4iauQEEAUlh9GyGu7ZZX9XqOCPOGiaUdXVg/640?wx_fmt=gif" style="box-sizing: border-box !important;word-wrap: break-word !important;width: 253px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naKcJeVLrERoBcjILPJtnWgOAsnKJ8RVuvGo7DPusIGvV4iauQEEAUlh9GyGu7ZZX9XqOCPOGiaUdXVg/640?wx_fmt=gif"></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
