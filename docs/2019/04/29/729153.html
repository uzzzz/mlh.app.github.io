<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>iOS系统中导航栏的转场解决方案与最佳实践 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="iOS系统中导航栏的转场解决方案与最佳实践" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="总第294篇 2018年 第86篇 前言 目前，开源社区和业界内已经存在一些 iOS 导航栏转场的解决方案，但对于历史包袱沉重的美团 App 而言，这些解决方案并不完美。有的方案不能满足复杂的页面跳转场景，有的方案迁移成本较大，为此我们提出了一套解决方案并开发了相应的转场库，目前该转场库已经成为美团点评多个 App 的基础组件之一。 在美团 App 开发的早期，涉及到导航栏样式改变的需求时，经常会遇到转场效果不佳或者与预期样式不符的“小问题”。在业务体量较小的情况下，为了满足快速的业务迭代，通常会使用硬编码的方式来解决这一类“小问题”。但随着美团 App 业务的高速发展，这种硬编码的方式遇到了以下的挑战： 业务模块的不断增加，导致使用硬编码方式编写的代码维护成本增加，代码质量迅速下降。 大型 App 的路由系统使得页面间的跳转变得更加自由和灵活，也使得导航栏相关的问题激增，不但增加了问题的排查难度，还降低了整体的开发效率。 App 中的导航栏属于各个业务方的公用资源，由于缺乏相应的约束机制和最佳实践，导致业务方之间的代码耦合程度不断增加。 从各个角度来看，硬编码的方式已经不能很好的解决此类问题，美团 App 需要一个更加合理、更加持久、更加简单易行的解决方案来处理导航栏转场问题。 本文将从导航栏的概念入手，通过讲解转场过程中的状态管理、转换时机和样式变化等内容，引出了在大型应用中导航栏转场的三种常见解决方案，并对美团的解决方案进行剖析，同时介绍了我们总结的最佳实践。 重新认识导航栏 导航栏里的 MVC 在 iOS 系统中， 苹果公司不仅建议开发者遵循 MVC 开发框架，在他们的代码里也可以看到 MVC 的影子，导航栏组件的构成就是一个类似 MVC 的结构，让我们先看看下面这张图： 在这张图里，我们可以将 UINavigationController 看做是 C，UINavigationBar 看做是 V，而 UIViewController 和 UINavigationItem 组成的 Stack 可以看做是 M。这里要说明的是，每个 UIViewController 都有一个属于自己的 UINavigationItem，也就是说它们是一一对应的。 UINavigationController 通过驱动 Stack 中的 UIViewController 的变化来实现 View 层级的变化，也就是 UINavigationBar 的改变。而 UINavigationBar 样式的数据就存储在 UIViewController 的 UINavigationItem 中。这也就是为什么我们在代码里只要设置 self.navigationItem 的相关属性就可以改变 UINavigationBar 的样式。 很多时候，国内的开发者会将 UINavigationBar 和 UINavigationController 混在一起叫导航栏，这样的做法不仅增加了开发者之间的沟通成本，也容易导致误解。毕竟它们是两个完全不一样的东西。 所以本文为了更好的阐明问题，会采用英文区分不同的概念，当需要描述笼统的导航栏概念时，会使用导航栏组件一词。 通过这一节的回顾，我们应该明确了 NavigationItem、ViewController、NavigationBar 和 NavigationController 在 MVC 框架下的角色。下面我们会重新梳理一下导航栏的生命周期和各个相关方法的调用顺序。 导航栏组件的生命周期 大家可以通过下图获得更为直观的感受，进而了解到导航栏组件在 push 过程中各个方法的调用顺序。 值得注意的地方有两点： 第一个是 UINavigationController 作为 UINavigationBar 的代理，在没有特殊需求的情况下，不应该修改其代理方法，这里是通过符号断点获取它们的调用顺序。如果我们创建了一个自定义的导航栏组件系统，它的调用顺序可能会与此不同。 第二个是用虚线圈起来的方法，它们也有可能不被调用，这与 ViewController 里的布局代码相关，假设跳转到新页面后，新旧页面中的控件位置会发生变化，或者由于数据改变驱动了控件之间的约束关系发生变化，这就会带来新一轮的布局，进而触发 viewWillLayoutSubview 和 viewDidLayoutSubview 这两个方法。当然，具体的调用顺序会与业务代码紧密相关，如果我们发现顺序有所不同，也不必惊慌。 下面这张图展示了导航栏在 pop 过程中各个方法的调用顺序： 除了上面说到的两点，pop 过程中还需要注意一点，那就是从 B 返回到 A 的过程中，A 视图控制器的 viewDidLoad 方法并不会被调用。关于这个问题，只要提醒一下，大多数人都会反应过来是为什么。不过在实际开发过程中，总会有人忘记这一点。 通过这两个图，我们已经基本了解了导航栏组件的生命周期和相关方法的调用顺序，这也是后面章节的理论基础。 导航栏组件的改变与革新 导航栏组件在 iOS 11 发布时，获得了重大更新，这个更新可不是增加了一个大标题样式（Large Title Display Mode）那么简单，需要注意的地方大概有两点： 导航栏全面支持 Auto Layout 且 NavigationBar 的层级发生了明显的改变，关于这一点可以阅读 UIBarButtonItem 在 iOS 11 上的改变及应对方案 。 由于引进了 Safe Area 等概念，topLayoutGuide 和 bottomLayoutGuide 等属性会逐渐废弃，虽然变化不大，但如果我们的导航栏在转场过程中总是出现视图上下移动的现象，不妨从这个方面思考一下，如果想深究可以查看 WWDC 2017 Session 412。 导航栏组件到底怎么了？ 经常有人说 iOS 的原生导航栏组件不好使用，抱怨主要集中在导航栏组件的状态管理和控件的布局问题上。 控件的布局问题随着 iOS 11 的到来已经变得相对容易处理了不少，但导航栏组件的状态管理仍然让开发者头疼不已。 可能已经有朋友在思考导航栏组件的状态管理到底是什么东西？不要着急，下面的章节就会做相关的介绍。 导航栏的状态管理 虽然导航栏组件的 push 和 pop 动画给人一种每次操作后都会创建一遍导航栏组件的错觉，但实际上这些 ViewController 都是由一个 NavigationController 所管理，所以你看到的 NavigationBar 是唯一的。 在 NavigationController 的 Stack 存储结构下，每当 Stack 中的 ViewController 修改了导航栏，势必会影响其他 ViewController 展示的效果。 例如下图所示的场景，如果 NavigationBar 原先的颜色是绿色，但之后进入 Stack 里的 ViewController 将 NavigationBar 颜色修改为紫色后，在此之后 push 的 ViewController 会从默认的绿色变为紫色，直到有新的 ViewController 修改导航栏颜色才会发生变化。 虽然在 push 过程中，NavigationBar 的变化听起来合情合理，但如果你在 NavigationBar 为绿色的 ViewController 里设置不当的话，那么当你 pop 回这个 ViewController 时，NavigationBar 可就不一定是绿色了，它还会保持为紫色的状态。 通过这个例子，我们大概会意识到在导航栏里的 Stack 中，每个 ViewController 都可以永久的影响导航栏样式，这种全局性的变化要求我们在实际开发中必须坚持“谁修改，谁复原”的原则，否则就会造成导航栏状态的混乱。这不仅仅是样式上的混乱，在一些极端状况下，还有可能会引起 Stack 混乱，进而造成 Crash 的情况。 导航栏样式转换的时机 我们刚才提到了“谁修改，谁复原”的原则，但何时修改，何时复原呢？ 对于那些存储在 Stack 中的 ViewController 而言，它其实就是在不断的经历 appear 和 disappear 的过程，结合 ViewController 的生命周期来看，viewWillAppear: 和 viewWillDisappear: 是两个完美的时间节点，但很多人却对这两个方法的调用存在疑惑。 苹果公司在它的 API 文档中专门用了一段文字来解答大家的疑惑，这段文字的标题为《Handling View-Related Notifications》，在这里我们直接引用原文： When the visibility of its views changes, a view controller automatically calls its own methods so that subclasses can respond to the change. Use a method like viewWillAppear: to prepare your views to appear onscreen, and use the viewWillDisappear: to save changes or other state information. Use other methods to make appropriate changes.Figure 1 shows the possible visible states for a view controller’s views and the state transitions that can occur. Not all ‘will’ callback methods are paired with only a ‘did’ callback method. You need to ensure that if you start a process in a ‘will’ callback method, you end the process in both the corresponding ‘did’ and the opposite ‘will’ callback method. 这里很好的解释了所有的 will 系列方法和 did 系列方法的对应关系，同时也给我们吃了一个定心丸，那就是在 appearing 和 disappearing 状态之间会由 will 系列方法进行衔接，避免了状态中断。这对于连续 push 或者连续 pop 的情况是及其重要的，否则我们无法做到 “谁修改，谁复原”的原则。 通常来说，如果只是一个简单的导航栏样式变化，我们的代码结构大体会如下所示： -&nbsp;(void)viewWillAppear:(BOOL)animated{&nbsp;&nbsp;&nbsp;&nbsp;[super&nbsp;viewWillAppear:animated];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;MARK:&nbsp;change&nbsp;the&nbsp;navigationbar&nbsp;style&nbsp;}-&nbsp;(void)viewWillDisappear:(BOOL)animated{&nbsp;&nbsp;&nbsp;&nbsp;[super&nbsp;viewWillDisappear:animated];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;MARK:&nbsp;restore&nbsp;the&nbsp;navigationbar&nbsp;style} 现在，我们明确了修改时机，接下来要明确的就是导航栏的样式会进行怎样的变化。 导航栏的样式变化 对于不同 ViewController 之间的导航栏样式变化，大多可以总结为两种情况： 导航栏的显示与否 导航栏的颜色变化 导航栏的显示与否 对于显示与否的问题，可以在上一节提到的两个方法里调用 setNavigationBarHidden:animated: 方法，这里需要提醒的有两点： 在导航栏转场的过程中，不要天真的以为 setNavigationBarHidden: 和 setNavigationBarHidden:animated: 的效果是一样的，直接使用 setNavigationBarHidden: 会造成导航栏转场过程中的闪现、背景错乱等问题，这一现象在使用手势驱动转场的场景中十分常见，所以正确的方式是使用带有 animated 参数的 API。 在 push 和 pop 的方法里也会带有 animated 参数，尽量保证与 setNavigationBarHidden:animated: 中的 animated 参数一致。 导航栏的颜色变化 颜色变化的问题就稍微复杂一些，在 iOS 7 后，导航栏增加了 translucent 效果，这使得导航栏背景色的变化出现了两种情况： translucent 属性值为 YES 的前提下，更改导航栏的背景色。 translucent 属性值为 NO 的前提下，更改导航栏的背景色。 对于第一种情况，我们需要调用 UINavigationBar 的 setBackgroundColor: 方法。 对于第二种情况我们需要调用 UINavigationBar 的 setBackgroundImage:forBarMetrics: 方法。 对于第二种情况，这里有三点需要提示： 在设置透明效果时，我们通常可以直接设置一个 [UIImage new] 创建的对象，无须创建一个颜色为透明色的图片。 在使用 setBackgroundImage:forBarMetrics: 方法的过程中，如果图像里存在 alpha 值小于 1.0 的像素点，则 translucent 的值为 YES，反之为 NO。也就是说，如果我们真的想让导航栏变成纯色且没有 translucent 效果，请保证所有像素点的 alpha 值等于 1。 如果设置了一个完全不透明的图片且强行将 NavigationBar 的 translucent 属性设置为 YES 的话，系统会自动修正这个图片并为它添加一个透明度，用于模拟 translucent 效果。 如果我们使用了一个带有透明效果的图片且导航栏的 translucent 效果为 NO 的话，那么系统会在这个带有透明效果的图片背后，添加一个不透明的纯色图片用于整体效果的合成。这个纯色图片的颜色取决于 barStyle 属性，当属性为 UIBarStyleBlack 时为黑色，当属性为 UIBarStyleDefault 时为白色，如果我们设置了 barTintColor，则以设置的颜色为基准。 分清楚 transparent，translucent，opaque，alpha 和 opacity 也挺重要 在刚接触导航栏 API 时，许多人经常会把文档里的这些英文词搞混，也不太明白带有这些词的变量为什么有的是布尔型，有的是浮点型，总之一切都让人很困惑。 在这里将做了一个总结，这对于理解 Apple 的 API 设计原则十分有帮助。 transparent， translucent， opaque 三个词经常会用在一起，它用于描述物体的透光强度，为了让大家更好的理解这三个词，这里做了三个比喻： transparent 是指透明，就好比我们可以透过一面干净的玻璃清楚的看到外面的风景。 translucent 是指半透明，就好比我们可以透过一面有点磨砂效果的塑料墙看外面的风景，不能说看不见，但我们肯定看不清。 opaque 是指不透明，就好比我们透过一个堵石墙是看不见任何外面的东西，眼前看到的只有这面墙。 这三个词更多的是用来表述一种状态，不需要量化，所以这与这三个词相关的属性，一般都是 BOOL 类型。 alpha 和 opacity 经常会在一起使用，它要表示的就是透明度，在 Web 端这两个属性有着明显的区别。 在 Web 端里，opacity 是设定整个元素的透明值，而 alpha 一般是放在颜色设置里面，所以我们可以做到对特定对元素的某个属性设定 alpha，比如背景、边框、文字等。 div&nbsp;{&nbsp;&nbsp;width:&nbsp;100px;&nbsp;&nbsp;height:&nbsp;100px;&nbsp;&nbsp;background:&nbsp;rgba(0,0,0,0.5);&nbsp;&nbsp;border:&nbsp;1px&nbsp;solid&nbsp;#000000;&nbsp;&nbsp;opacity:&nbsp;0.5;} 这一概念同样适用于 iOS 里的概念，比如我们可以通过 alpha 通道单独的去设置 backgroudColor、borderColor，它们互不影响，且有着独立的 alpha 通道，我们也可以通过 opacity 统一设置整个 view 的透明度。 但与 Web 端不一致的是，iOS 里面的 view 不光拥有独立的 alpha 属性，同时也是基于 CALayer，所以我们可以看到任意 UIView 对象下面都会有一个 layer 的属性，用于表明 CALayer 对象。view 的 alpha 属性与 layer 里面的 opacity 属性是一个相等的关系，需要注意的是 view 上的 alpha 属性是 Web 端并不具备的一个能力，所以笔者认为：在 iOS 中去说 alpha 时，要区分是在说 view 上的属性，还是在说颜色通道里的 alpha。 由于这两个词都是在描述程度，所以我们看到它们都是 CGFloat 类型： 转场过程中需要注意的问题和细节 说完了导航栏的转场时机和转场方式，其实大体上你已经能处理好不同样式间的转换，但还有一些细节需要你去考虑，下面我们来说说其中需要你关注的两点。 translucent 属性带来的布局改变 translucent 会影响导航栏组件里 ViewController 的 View 布局，这里需要大家理清 5 个 API 的使用场景： edgesForExtendedLayout extendedLayoutIncluedsOpaqueBars automaticallyAdjustScrollViewInsets contentInsetAdjustmentBehavior additionalSafeAreaInsets 前三个 API 是 iOS 11 之前的 API，它们之间的区别和联系在 Stack Overflow 上有一个比较精彩的回答 - Explaining difference between automaticallyAdjustsScrollViewInsets, extendedLayoutIncludesOpaqueBars, edgesForExtendedLayout in iOS7，我在这里就不做详细阐述，总结一下它的观点就是: 如果我们先定义一个 UINavigationController，它里面包含了多个 UIViewController，每个 UIViewController 里面包含一个 UIView 对象： 那么 edgesForExtendedLayout 是为了解决 UIViewController 与 UINavigationController 的对齐问题，它会影响 UIViewController 的实际大小，例如 edgesForExtendedLayout 的值为 UIRectEdgeAll 时，UIViewController 会占据整个屏幕的大小。 当 UIView 是一个 UIScrollView 类或者子类时，automaticallyAdjustsScrollViewInsets 是为了调整这个 UIScrollView 与 UINavigationController 的对齐问题，这个属性并不会调整 &nbsp;UIViewController 的大小。 对于 UIView 是一个 UIScrollView 类或者子类且导航栏的背景色是不透明的状态时，我们会发现使用 edgesForExtendedLayout 来调整 UIViewController 的大小是无效的，这时候你必须使用 extendedLayoutIncludesOpaqueBars 来调整 UIViewController 的大小，可以认为 extendedLayoutIncludesOpaqueBars 是基于 automaticallyAdjustsScrollViewInsets 诞生的，这也是为什么经常会看到这两个 API 会同时使用。 这些调整布局的 API 背后是一套基于 topLayoutGuide 和 bottomLayoutGuide 的计算而已，在 iOS 11 后，Apple 提出了 Safe Area 的概念，将原先分裂开来的 topLayoutGuide 和 bottomLayoutGuide 整合到一个统一的 LayoutGuide 中，也就是所谓的 Safe Area，这个改变看起来似乎不是很大，但它的出现确实方便了开发者。 如果想对 Safe Area 带来的改变有更全面的认识，十分推荐阅读 Rosberry 的工程师 Evgeny Mikhaylov 在 Medium 上的文章 iOS Safe Area，这篇文章基本涵盖了 iOS 11 中所有与 Safe Area 相关的 API 并给出了真正合理的解释。 这里只说一下 contentInsetAdjustmentBehavior 和 additionalSafeAreaInsets 两个 API。 对于 contentInsetAdjustmentBehavior 属性而言，它的诞生也意味着 automaticallyAdjustsScrollViewInsets 属性的失效，所以我们在那些已经适配了 iOS 11 的工程里能看到如下类似的代码： if&nbsp;(@available(iOS&nbsp;11.0,&nbsp;*))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;self.tableView.contentInsetAdjustmentBehavior&nbsp;=&nbsp;UIScrollViewContentInsetAdjustmentNever;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;self.automaticallyAdjustsScrollViewInsets&nbsp;=&nbsp;NO;} 此处的代码片段只是一个示例，并不适用所有的业务场景，这里需要着重说明几个问题： 关于 contentInsetAdjustmentBehavior 中的 UIScrollViewContentInsetAdjustmentAutomatic 的说明一直很“模糊”，通过 Evgeny Mikhaylov 的文章，我们可以了解到它在大多数情况下会与 UIScrollViewContentInsetAdjustmentScrollableAxes 一致，当且仅当满足以下所有条件时才会与 UIScrollViewContentInsetAdjustmentAlways 相似： UIScroller 类型的视图在水平轴方向是可滚动的，垂直轴是不可滚动的。 ViewController 视图里的第一个子控件是 UIScrollView 类型的视图。 ViewController 是 navigation 或者 tab 类型控制器的子视图控制器。 启用 automaticallyAdjustsScrollViewInsets。 iOS 11 后，通过 contentInset 属性获取的偏移量与 iOS 10 之前的表现形式并不一致，需要获取 adjustedContentInset 属性才能保证与之前的 contentInset 属性一致，这样的改变需要我们在代码里对不同的版本进行适配。 对于 additionalSafeAreaInsets 而言，如果系统提供的这几种行为并不能满足我们的布局要求，开发者还可以考虑使用 additionalSafeAreaInsets 属性做调整，这样的设定使得开发者可以更加灵活，更加自由的调整视图的布局。 backIndicator 上的动画 苹果提供了许多修改导航栏组件样式的 API，有关于布局的，有关于样式的，也有关于动画的。backIndicatorImage 和 backIndicatorTransitionMaskImage 就是其中的两个 API。 backIndicatorImage 和 backIndicatorTransitionMaskImage 操作的是 NavigationBar 里返回按钮的图片，也就是下图红色圆圈所标注的区域。 想要成功的自定义返回按钮的图标样式，我们需要同时设置这两个 API ，从字面上来看，它们一个是返回图片本身，另一个是返回图片在转场时用到的 mask 图片，看起来不怎么难，我们写一段代码试试效果： self.navigationController.navigationBar.backIndicatorImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrow&quot;];self.navigationController.navigationBar.backIndicatorTransitionMaskImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrowMask&quot;]; 代码里的图片如下所示： 也许大多数人在这里会都认为，mask 图片会遮挡住文字使其在遇到返回按钮右边缘的时候就消失。但实际的运行效果是怎么样子的呢？我们来看一下： 在上面的图片中，我们可以看到返回按钮的文字从返回按钮的图片下面穿过并且文字被图片所遮挡，这种动画看起来十分奇怪，这是无法接受的。我们需要做点修改： self.navigationController.navigationBar.backIndicatorImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrow&quot;];self.navigationController.navigationBar.backIndicatorTransitionMaskImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrow&quot;]; 这一次我们将 backIndicatorTransitionMaskImage 改为 indicatorImage 所用的图片。 到这里，可能大多数人都会好奇，这代码也能行？让我们看下它实际的效果： 在上面的图中，我们看到文字在到达图片的右边缘时就从下方穿过并被完全遮盖住了，这种动画效果虽然比上面好一些，但仍然有改进的空间，不过这里我们先不继续优化了，我们先来讨论一下它们背后的运作原理。 iOS 系统会将 indicatorImage 中不透明的颜色绘制成返回按钮的图标， indicatorTransitionMaskImage 与 indicatorImage 的作用不同。indicatorTransitionMaskImage 将自身不透明的区域像 mask 一样作用在 indicatorImage 上，这样就保证了返回按钮中的文字像左移动时，文字只出现在被 mask 的区域，也就是 indicatorTransitionMaskImage 中不透明的区域。 掌握了原理，我们来解释下刚才的两种现象： 在第一种实现中，我们提供的 indicatorTransitionMaskImage 覆盖了整个返回按钮的图标，所以我们在转场过程中可以清晰的看到返回按钮的文字。 在第二种实现中，我们使用 indicatorImage 作为 indicatorTransitionMaskImage，记住文字是只能出现在 indicatorTransitionMaskImage 里不透明的区域，所以显然返回按钮中的文字会在图标的最右边就已经被遮挡住了，因为那片区域是透明的。 那么前面提到的进一步优化指的是什么呢？ 让我们来看一下下面这个示例图，为了更好的区分，我们将 indicatorTransitionMaskImage 用红色进行标注。黑色仍然是 indicatorImage。 按照刚才介绍的原理，我们应该可以理解，现在文字只会出现在红色区域，那么它的实际效果是什么样子的呢，我们可以看下图： 现在，一个完美的返回动画，诞生啦！ 此节所用的部分效果图出自 Ray Wenderlich 的文章 UIAppearance Tutorial: Getting Started 导航栏的跳转或许可以这么玩儿…… 前两章的铺垫就是为了这一章的内容，所以现在让我们开始今天的大餐吧。 这样真的好么？ 刚才我们说了两个页面间 NavigationBar 的样式变化需要在各自的 viewWillAppear: 和 viewWillDisappear: 中进行设置。那么问题就来了：这样的设置会带来什么问题呢？ 试想一下，当我们的页面会跳到不同的地方时，我们是不是要在 viewWillAppear: 和 viewWillDisappear: 方法里面写上一堆的判断呢？如果应用里还有 router 系统的话，那么页面间的跳转将变得更加不可预知，这时候又该如何在 viewWillAppear: 和 viewWillDisappear: 里做判断呢？ 现在我们的问题就来了，如何让导航栏的转场更加灵活且相互独立呢？ 常见的解决方案如下所示： 重新实现一个类似 UINavigationController 的容器类视图管理器，这个容器类视图管理器做好不同 ViewController 间的导航栏样式转换工作，而每个 ViewController 只需要关心自身的样式即可。 将系统原有导航栏的背景设置为透明色，同时在每个 ViewController 上添加一个 View 或者 NavigationBar 来充当我们实际看到的导航栏，每个 ViewController 同样只需要关心自身的样式即可。 在转场的过程中隐藏原有的导航栏并添加假的 NavigationBar，当转场结束后删除假的 NavigationBar 并恢复原有的导航栏，这一过程可以通过 Swizzle 的方式完成，而每个 ViewController 只需要关心自身的样式即可。 这三种方案各有优劣，我们在网上也可以看到很多关于它们的讨论。 例如方案一，虽然看起来工作量大且难度高，但是这个工作一旦完成，我们就会将处理导航栏转场的主动权牢牢抓在手里。但这个方案的一个弊端就是，如果苹果修改了导航栏的整体风格，就好比 iOS 11 的大标题特效，那么工作量就来了。 对于方案二而言，虽然看起来简单易用，但这需要一个良好的继承关系，如果整个工程里的继承关系混乱或者是历史包袱比较重，后续的维护就像“打补丁”一样，另外这个方案也需要良好的团队代码规范和完善的技术文档来做辅助。 对于方案三而言，它不需要所谓的继承关系，使用起来也相对简单，这对于那些继承关系和历史包袱比较重的工程而言，这一个不错的解决方案，但在解决 Bug 的时候，Swizzle 这种方式无疑会增加解决问题的时间成本和学习成本。 我们的解决方案 在美团 App 的早期，各个业务方都想充分利用导航栏的能力，但对于导航栏的状态维护缺乏理解与关注，随着业务方的增加和代码量的上升，与导航栏相关的问题逐渐暴露出来，此时我们才意识到这个问题的严重性。 大型 App 的导航栏问题就像一个典型的“公地悲剧”问题。在软件行业，公用代码的所有权可以被视作“公地”，因为不注重长期需求而容易遭到消耗。如果开发人员倾向于交付“价值”，而以可维护性和可理解性为代价，那么这个问题就特别普遍了。如果是这种情况，每次代码修改将大大减少其总体质量，最终导致软件的不可维护。 所以解决这个问题的核心在于：明确公用代码的所有权，并在开发期施加约束。 明确公用代码的所有权，可以理解为将导航栏相关的组件抽离成一个单独的组件，并交由特定的团队维护。而在开发期施加约束，则意味着我们要提供一套完整的解决方案让各个业务方遵守。 这一节我们会以美团内部的解决方案为例，讲解如何实现一个流畅的导航栏跳转过程和相关使用方法。 设计理念 使用者只用关心当前 ViewController 的 NavigationBar 样式，而不用在 push 或者 pop 的时候去处理 NavigationBar 样式。 举个例子来说，当从 A 页面 push 到 B 页面的时候，转场库会保存 A 页面的导航栏样式，当 pop 回去后就会还原成以前的样式，因此我们不用考虑 pop 后导航栏样式会改变的情况，同时我们也不必考虑 push 后的情况，因为这个是页面 B 本身需要考虑的。 使用方法 转场库的使用十分简单，我们不需要 import 任何头文件，因为它在底层通过 Method Swizzling 进行了处理，只需要在使用的时候遵循下面 4 点即可： 当需要改变导航栏样式的时候，在视图控制器的 viewDidLoad 或者 viewWillAppear: 方法里去设置导航栏样式。 用 setBackgroundImage:forBarMetrics: 方法和 shadowImage 属性去修改导航栏的背景样式。 不要在 viewWillDisappear: 里添加针对导航栏样式修改的代码。 不要随意修改 translucent 属性，包括隐式的修改和显示的修改。 隐式修改是指使用 setBackgroundImage:forBarMetrics: 方法时，如果 image 里的像素点没有 alpha 通道或者 alpha 全部等于 1 会使得 translucent 变为 NO 或者 nil。 基本原理 以上，我们讲完了设计理念和使用方法，那么我们来看看美团的转场库到底做了什么？ 从大方向上来看，美团使用的是前面所说的第三种方案，不过它也有一些自己独特的地方，为了更好的让大家理解整个过程，我们设计这样一个场景，从页面 A push 到页面 B，结合之前探讨过的方法调用顺序，我们可以知道几个核心方法的调用顺序大致如下： 页面 A 的 pushViewController:animated: 页面 B 的 viewDidLoad or viewWillAppear: 页面 B 的 viewWillLayoutSubviews 页面 B 的 viewDidAppear: 在 push 过程的开始，转场库会在页面 A 自身的 view 上添加一个与导航栏一模一样的 NavigationBar 并将真的导航栏隐藏。之后这个假的导航栏会一直存在页面 A 上，用于保留 A 离开时的导航栏样式。 等到页面 B 调用 viewDidLoad 或者 viewWillAppear: 的时候，开发者在这里自行设置真的导航栏样式。转场库在这里会对页面布局做一些修正和辅助操作，但不会影响导航栏的样式。 等到页面 B 调用 viewWillLayoutSubviews 的时候，转场库会在页面 B 自身的 view 上添加一个与真的导航栏一模一样的 NavigationBar，同时将真的导航栏隐藏。此时不论真的导航栏，还是假的导航栏都已经与 viewDidLoad 或者 viewWillAppear: 里设置的一样的。 当然，这一步也可以放在 viewWillDisappear: 里并在 dispatch main queue 的下一个 runloop 中处理。 等到页面 B 调用 viewDidAppear: 的时候，转场库会将假的导航栏样式设置到真的导航栏中，并将假的导航栏从视图层级中移除，最终将真的导航栏显示出来。 为了让大家更好地理解上面的内容，请参考下图： 说完了 push 过程，我们再来说一下从页面 B pop 回页面 A 的过程，几个核心方法的调用顺序如下： 页面 B 的 popViewControllerAnimated: 页面 A 的 viewWillAppear: 页面 A 的 viewDidAppear: 在 pop 过程的开始，转场库会在页面 B 自身的 view 上添加一个与导航栏一模一样的 NavigationBar 并将真的导航栏隐藏，虽然这个假的导航栏会一直存在于页面 B 上，但它自身会随着页面 B 的 dealloc 而消亡。 等到页面 A 调用 viewWillAppear: 的时候，开发者在这里自行设置真的导航栏样式。当然我们也可以不设置，因为这时候页面 A 还持有一个假的导航栏，这里还保留着我们之前在 viewDidLoad 里写的导航栏样式。 等到页面 A 调用 viewDidAppear: 的时候，转场库会将假的导航栏样式设置到真的导航栏中，并将假的导航栏从视图层级中移除，最终将真的导航栏显示出来。 同样，我们可以参考下面的图来理解上面所说的内容： 现在，大家应该对我们美团的解决方案有了一定的认识，但在实际开发过程中，还需要考虑一些布局和适配的问题。 最佳实践 在维护这套转场方案的时间里，我们总结了一些此类方案的最佳实践。 判断导航栏问题的基本准则 如果发现导航栏在转场过程中出现了样式错乱，可以遵循以下几点基本原则： 检查相应 ViewController 里是否有修改其他 ViewController 导航栏样式的行为，如果有，请做调整。 保证所有对导航栏样式变化的操作出现在 viewDidLoad 和 viewWillAppear: 中，如果在 viewWillDisappear: 等方法里出现了对导航栏的样式修改的操作，如果有，请做调整。 检查是否有改动 translucent 属性，包括显示修改和隐式修改，如果有，请做调整。 只关心当前页面的样式 永远记住每个 ViewController 只用关心自己的样式，设置的时机点在 viewWillAppear: 或者 viewDidLoad 里。 透明样式导航栏的正确设置方法 如果需要一个透明效果的导航栏，可以使用如下代码实现： [self.navigationController.navigationBar&nbsp;setBackgroundImage:[UIImage&nbsp;new]&nbsp;forBarMetrics:UIBarMetricsDefault];self.navigationController.navigationBar.shadowImage&nbsp;=&nbsp;[UIImage&nbsp;new];&nbsp; 导航栏的颜色渐变效果 如果需要导航栏实现随滚动改变整体 alpha 值的效果，可以通过改变 setBackgroundImage:forBarMetrics: 方法里 image 的 alpha 值来达到目标，这里一般是使用监听 scrollView.contentOffset 的手段来做。请避免直接修改 NavigationBar 的 alpha 值。 如果发现这种方式会引起严重的性能问题，可以尝试使用如下的方式进行修改，但不推荐，主要原因是通过读取数组内容的方式来获取视图实例既不优雅，也不安全。 UIView&nbsp;*background&nbsp;=&nbsp;self.navigationController.navigationBar.subviews.firstObject;background.alpha&nbsp;=&nbsp;MIN(self.contentOffsetY&nbsp;/&nbsp;100.0,&nbsp;1); 还有一点需要注意的是，在页面转场的过程中，也会触发 contentOffset 的变化，所以请尽量在 disappear 的时候取消监听。否则会容易出现导航栏透明度的变化。 导航栏背景图片的规范 请避免背景图里的像素点没有 alpha 通道或者 alpha 全部等于 1，容易触发 translucent 的隐式改变。 如果真的要隐藏导航栏 如果我们需要隐藏导航栏，请保证所有的 ViewController 能坚持如下原则： 每个 ViewController 只需要关心当前页面下的导航栏是否被隐藏。 在 viewWillAppear: 中，统一设置导航栏的隐藏状态。 使用 setNavigationBarHidden:animated: 方法，而不是 setNavigationBarHidden:。 转场动画与导航栏隐藏动画的一致性 如果在转场的过程中还会显示或者隐藏导航栏的话，请保证两个方法的动画参数一致。 -&nbsp;(void)viewWillAppear:(BOOL)animated{&nbsp;&nbsp;&nbsp;&nbsp;[self.navigationController&nbsp;setNavigationBarHidden:YES&nbsp;animated:animated];} viewWillAppear: 里的 animated 参数是受 push 和 pop 方法里 animated 参数影响。 导航栏固有的系统问题 目前已知的有两个系统问题如下： 当前后两个 ViewController 的导航栏都处于隐藏状态，然后在后一个 ViewController 中使用返回手势 pop 到一半时取消，再连续 push 多个页面时会造成导航栏的 Stack 混乱或者 Crash。 当页面的层级结构大体如下所示时，在红色导航栏的 Stack 中，返回手势会大概率的出现跨层级的跳转，多次后会导致整个导航栏的 Stack 错乱或者 Crash。 导航栏内置组件的布局规范 导航栏里的组件布局在 iOS 11 后发生了改变，原有的一些解决方案已经失效，这些内容不在本篇文章的讨论范围之内，推荐阅读UIBarButtonItem 在 iOS 11 上的改变及应对方案，这篇文章详细的解释了 iOS 11 里的变化和可行的应对方案。 总结 本文涉及内容较多，从 iOS 系统下的导航栏概念到大型应用里的最佳实践，这里我们总结一下整篇文章的核心内容： 理解导航栏组件的结构和相关方法的生命周期。 导航栏组件的结构留有 MVC 架构的影子，在解决问题时，要去相应的层级处理。 转场问题的关键点是方法的调用顺序，所以了解生命周期是解决此类问题的基础。 状态管理，转换时机和样式变化是导航栏里常见问题的三种表现形式，遇到实际问题时需要区分清楚。 状态管理要坚持“谁修改，谁复原”的原则。 转换时机的设定要做到连续可执行。 样式变化的核心点是导航栏的显示与否与颜色变化。 为了更好的配合大型应用里的路由系统，导航栏转场的常见解决方案有三种，各有利弊，需要根据自身的业务场景和历史包袱做取舍。 解决方案1：自定义导航栏组件。 解决方案2：在原有导航栏组件里添加 Fake Bar。 解决方案3：在导航栏转场过程中添加 Fake Bar。 美团在实际开发过程中采用了第三种方案，并给出了适合美团 App 的最佳实践。 参考链接 UIAppearance Tutorial: Getting Started KMNavigationBarTransition 特别感谢莫洲骐在此项目中做出的贡献与付出。 作者简介 思琦，美团点评 iOS 工程师。2016 年加入美团，负责美团平台的业务开发及 UI 组件的维护工作。 扫码加入美团iOS技术交流群，跟作者零距离交流。如群已满，请加美美同学的微信（微信号：MTDPtech01），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 美团平台诚招 iOS、Android、FE 高级/资深工程师和技术专家，Base 北京、上海、成都，欢迎有兴趣的同学投递简历到zhangsiqi04@meituan.com。&nbsp; 也许你还想看 美团外卖iOS多端复用的推动、支撑与思考 基于 KIF 的 iOS UI 自动化测试和持续集成 ARKit：增强现实技术在美团到餐业务的实践" />
<meta property="og:description" content="总第294篇 2018年 第86篇 前言 目前，开源社区和业界内已经存在一些 iOS 导航栏转场的解决方案，但对于历史包袱沉重的美团 App 而言，这些解决方案并不完美。有的方案不能满足复杂的页面跳转场景，有的方案迁移成本较大，为此我们提出了一套解决方案并开发了相应的转场库，目前该转场库已经成为美团点评多个 App 的基础组件之一。 在美团 App 开发的早期，涉及到导航栏样式改变的需求时，经常会遇到转场效果不佳或者与预期样式不符的“小问题”。在业务体量较小的情况下，为了满足快速的业务迭代，通常会使用硬编码的方式来解决这一类“小问题”。但随着美团 App 业务的高速发展，这种硬编码的方式遇到了以下的挑战： 业务模块的不断增加，导致使用硬编码方式编写的代码维护成本增加，代码质量迅速下降。 大型 App 的路由系统使得页面间的跳转变得更加自由和灵活，也使得导航栏相关的问题激增，不但增加了问题的排查难度，还降低了整体的开发效率。 App 中的导航栏属于各个业务方的公用资源，由于缺乏相应的约束机制和最佳实践，导致业务方之间的代码耦合程度不断增加。 从各个角度来看，硬编码的方式已经不能很好的解决此类问题，美团 App 需要一个更加合理、更加持久、更加简单易行的解决方案来处理导航栏转场问题。 本文将从导航栏的概念入手，通过讲解转场过程中的状态管理、转换时机和样式变化等内容，引出了在大型应用中导航栏转场的三种常见解决方案，并对美团的解决方案进行剖析，同时介绍了我们总结的最佳实践。 重新认识导航栏 导航栏里的 MVC 在 iOS 系统中， 苹果公司不仅建议开发者遵循 MVC 开发框架，在他们的代码里也可以看到 MVC 的影子，导航栏组件的构成就是一个类似 MVC 的结构，让我们先看看下面这张图： 在这张图里，我们可以将 UINavigationController 看做是 C，UINavigationBar 看做是 V，而 UIViewController 和 UINavigationItem 组成的 Stack 可以看做是 M。这里要说明的是，每个 UIViewController 都有一个属于自己的 UINavigationItem，也就是说它们是一一对应的。 UINavigationController 通过驱动 Stack 中的 UIViewController 的变化来实现 View 层级的变化，也就是 UINavigationBar 的改变。而 UINavigationBar 样式的数据就存储在 UIViewController 的 UINavigationItem 中。这也就是为什么我们在代码里只要设置 self.navigationItem 的相关属性就可以改变 UINavigationBar 的样式。 很多时候，国内的开发者会将 UINavigationBar 和 UINavigationController 混在一起叫导航栏，这样的做法不仅增加了开发者之间的沟通成本，也容易导致误解。毕竟它们是两个完全不一样的东西。 所以本文为了更好的阐明问题，会采用英文区分不同的概念，当需要描述笼统的导航栏概念时，会使用导航栏组件一词。 通过这一节的回顾，我们应该明确了 NavigationItem、ViewController、NavigationBar 和 NavigationController 在 MVC 框架下的角色。下面我们会重新梳理一下导航栏的生命周期和各个相关方法的调用顺序。 导航栏组件的生命周期 大家可以通过下图获得更为直观的感受，进而了解到导航栏组件在 push 过程中各个方法的调用顺序。 值得注意的地方有两点： 第一个是 UINavigationController 作为 UINavigationBar 的代理，在没有特殊需求的情况下，不应该修改其代理方法，这里是通过符号断点获取它们的调用顺序。如果我们创建了一个自定义的导航栏组件系统，它的调用顺序可能会与此不同。 第二个是用虚线圈起来的方法，它们也有可能不被调用，这与 ViewController 里的布局代码相关，假设跳转到新页面后，新旧页面中的控件位置会发生变化，或者由于数据改变驱动了控件之间的约束关系发生变化，这就会带来新一轮的布局，进而触发 viewWillLayoutSubview 和 viewDidLayoutSubview 这两个方法。当然，具体的调用顺序会与业务代码紧密相关，如果我们发现顺序有所不同，也不必惊慌。 下面这张图展示了导航栏在 pop 过程中各个方法的调用顺序： 除了上面说到的两点，pop 过程中还需要注意一点，那就是从 B 返回到 A 的过程中，A 视图控制器的 viewDidLoad 方法并不会被调用。关于这个问题，只要提醒一下，大多数人都会反应过来是为什么。不过在实际开发过程中，总会有人忘记这一点。 通过这两个图，我们已经基本了解了导航栏组件的生命周期和相关方法的调用顺序，这也是后面章节的理论基础。 导航栏组件的改变与革新 导航栏组件在 iOS 11 发布时，获得了重大更新，这个更新可不是增加了一个大标题样式（Large Title Display Mode）那么简单，需要注意的地方大概有两点： 导航栏全面支持 Auto Layout 且 NavigationBar 的层级发生了明显的改变，关于这一点可以阅读 UIBarButtonItem 在 iOS 11 上的改变及应对方案 。 由于引进了 Safe Area 等概念，topLayoutGuide 和 bottomLayoutGuide 等属性会逐渐废弃，虽然变化不大，但如果我们的导航栏在转场过程中总是出现视图上下移动的现象，不妨从这个方面思考一下，如果想深究可以查看 WWDC 2017 Session 412。 导航栏组件到底怎么了？ 经常有人说 iOS 的原生导航栏组件不好使用，抱怨主要集中在导航栏组件的状态管理和控件的布局问题上。 控件的布局问题随着 iOS 11 的到来已经变得相对容易处理了不少，但导航栏组件的状态管理仍然让开发者头疼不已。 可能已经有朋友在思考导航栏组件的状态管理到底是什么东西？不要着急，下面的章节就会做相关的介绍。 导航栏的状态管理 虽然导航栏组件的 push 和 pop 动画给人一种每次操作后都会创建一遍导航栏组件的错觉，但实际上这些 ViewController 都是由一个 NavigationController 所管理，所以你看到的 NavigationBar 是唯一的。 在 NavigationController 的 Stack 存储结构下，每当 Stack 中的 ViewController 修改了导航栏，势必会影响其他 ViewController 展示的效果。 例如下图所示的场景，如果 NavigationBar 原先的颜色是绿色，但之后进入 Stack 里的 ViewController 将 NavigationBar 颜色修改为紫色后，在此之后 push 的 ViewController 会从默认的绿色变为紫色，直到有新的 ViewController 修改导航栏颜色才会发生变化。 虽然在 push 过程中，NavigationBar 的变化听起来合情合理，但如果你在 NavigationBar 为绿色的 ViewController 里设置不当的话，那么当你 pop 回这个 ViewController 时，NavigationBar 可就不一定是绿色了，它还会保持为紫色的状态。 通过这个例子，我们大概会意识到在导航栏里的 Stack 中，每个 ViewController 都可以永久的影响导航栏样式，这种全局性的变化要求我们在实际开发中必须坚持“谁修改，谁复原”的原则，否则就会造成导航栏状态的混乱。这不仅仅是样式上的混乱，在一些极端状况下，还有可能会引起 Stack 混乱，进而造成 Crash 的情况。 导航栏样式转换的时机 我们刚才提到了“谁修改，谁复原”的原则，但何时修改，何时复原呢？ 对于那些存储在 Stack 中的 ViewController 而言，它其实就是在不断的经历 appear 和 disappear 的过程，结合 ViewController 的生命周期来看，viewWillAppear: 和 viewWillDisappear: 是两个完美的时间节点，但很多人却对这两个方法的调用存在疑惑。 苹果公司在它的 API 文档中专门用了一段文字来解答大家的疑惑，这段文字的标题为《Handling View-Related Notifications》，在这里我们直接引用原文： When the visibility of its views changes, a view controller automatically calls its own methods so that subclasses can respond to the change. Use a method like viewWillAppear: to prepare your views to appear onscreen, and use the viewWillDisappear: to save changes or other state information. Use other methods to make appropriate changes.Figure 1 shows the possible visible states for a view controller’s views and the state transitions that can occur. Not all ‘will’ callback methods are paired with only a ‘did’ callback method. You need to ensure that if you start a process in a ‘will’ callback method, you end the process in both the corresponding ‘did’ and the opposite ‘will’ callback method. 这里很好的解释了所有的 will 系列方法和 did 系列方法的对应关系，同时也给我们吃了一个定心丸，那就是在 appearing 和 disappearing 状态之间会由 will 系列方法进行衔接，避免了状态中断。这对于连续 push 或者连续 pop 的情况是及其重要的，否则我们无法做到 “谁修改，谁复原”的原则。 通常来说，如果只是一个简单的导航栏样式变化，我们的代码结构大体会如下所示： -&nbsp;(void)viewWillAppear:(BOOL)animated{&nbsp;&nbsp;&nbsp;&nbsp;[super&nbsp;viewWillAppear:animated];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;MARK:&nbsp;change&nbsp;the&nbsp;navigationbar&nbsp;style&nbsp;}-&nbsp;(void)viewWillDisappear:(BOOL)animated{&nbsp;&nbsp;&nbsp;&nbsp;[super&nbsp;viewWillDisappear:animated];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;MARK:&nbsp;restore&nbsp;the&nbsp;navigationbar&nbsp;style} 现在，我们明确了修改时机，接下来要明确的就是导航栏的样式会进行怎样的变化。 导航栏的样式变化 对于不同 ViewController 之间的导航栏样式变化，大多可以总结为两种情况： 导航栏的显示与否 导航栏的颜色变化 导航栏的显示与否 对于显示与否的问题，可以在上一节提到的两个方法里调用 setNavigationBarHidden:animated: 方法，这里需要提醒的有两点： 在导航栏转场的过程中，不要天真的以为 setNavigationBarHidden: 和 setNavigationBarHidden:animated: 的效果是一样的，直接使用 setNavigationBarHidden: 会造成导航栏转场过程中的闪现、背景错乱等问题，这一现象在使用手势驱动转场的场景中十分常见，所以正确的方式是使用带有 animated 参数的 API。 在 push 和 pop 的方法里也会带有 animated 参数，尽量保证与 setNavigationBarHidden:animated: 中的 animated 参数一致。 导航栏的颜色变化 颜色变化的问题就稍微复杂一些，在 iOS 7 后，导航栏增加了 translucent 效果，这使得导航栏背景色的变化出现了两种情况： translucent 属性值为 YES 的前提下，更改导航栏的背景色。 translucent 属性值为 NO 的前提下，更改导航栏的背景色。 对于第一种情况，我们需要调用 UINavigationBar 的 setBackgroundColor: 方法。 对于第二种情况我们需要调用 UINavigationBar 的 setBackgroundImage:forBarMetrics: 方法。 对于第二种情况，这里有三点需要提示： 在设置透明效果时，我们通常可以直接设置一个 [UIImage new] 创建的对象，无须创建一个颜色为透明色的图片。 在使用 setBackgroundImage:forBarMetrics: 方法的过程中，如果图像里存在 alpha 值小于 1.0 的像素点，则 translucent 的值为 YES，反之为 NO。也就是说，如果我们真的想让导航栏变成纯色且没有 translucent 效果，请保证所有像素点的 alpha 值等于 1。 如果设置了一个完全不透明的图片且强行将 NavigationBar 的 translucent 属性设置为 YES 的话，系统会自动修正这个图片并为它添加一个透明度，用于模拟 translucent 效果。 如果我们使用了一个带有透明效果的图片且导航栏的 translucent 效果为 NO 的话，那么系统会在这个带有透明效果的图片背后，添加一个不透明的纯色图片用于整体效果的合成。这个纯色图片的颜色取决于 barStyle 属性，当属性为 UIBarStyleBlack 时为黑色，当属性为 UIBarStyleDefault 时为白色，如果我们设置了 barTintColor，则以设置的颜色为基准。 分清楚 transparent，translucent，opaque，alpha 和 opacity 也挺重要 在刚接触导航栏 API 时，许多人经常会把文档里的这些英文词搞混，也不太明白带有这些词的变量为什么有的是布尔型，有的是浮点型，总之一切都让人很困惑。 在这里将做了一个总结，这对于理解 Apple 的 API 设计原则十分有帮助。 transparent， translucent， opaque 三个词经常会用在一起，它用于描述物体的透光强度，为了让大家更好的理解这三个词，这里做了三个比喻： transparent 是指透明，就好比我们可以透过一面干净的玻璃清楚的看到外面的风景。 translucent 是指半透明，就好比我们可以透过一面有点磨砂效果的塑料墙看外面的风景，不能说看不见，但我们肯定看不清。 opaque 是指不透明，就好比我们透过一个堵石墙是看不见任何外面的东西，眼前看到的只有这面墙。 这三个词更多的是用来表述一种状态，不需要量化，所以这与这三个词相关的属性，一般都是 BOOL 类型。 alpha 和 opacity 经常会在一起使用，它要表示的就是透明度，在 Web 端这两个属性有着明显的区别。 在 Web 端里，opacity 是设定整个元素的透明值，而 alpha 一般是放在颜色设置里面，所以我们可以做到对特定对元素的某个属性设定 alpha，比如背景、边框、文字等。 div&nbsp;{&nbsp;&nbsp;width:&nbsp;100px;&nbsp;&nbsp;height:&nbsp;100px;&nbsp;&nbsp;background:&nbsp;rgba(0,0,0,0.5);&nbsp;&nbsp;border:&nbsp;1px&nbsp;solid&nbsp;#000000;&nbsp;&nbsp;opacity:&nbsp;0.5;} 这一概念同样适用于 iOS 里的概念，比如我们可以通过 alpha 通道单独的去设置 backgroudColor、borderColor，它们互不影响，且有着独立的 alpha 通道，我们也可以通过 opacity 统一设置整个 view 的透明度。 但与 Web 端不一致的是，iOS 里面的 view 不光拥有独立的 alpha 属性，同时也是基于 CALayer，所以我们可以看到任意 UIView 对象下面都会有一个 layer 的属性，用于表明 CALayer 对象。view 的 alpha 属性与 layer 里面的 opacity 属性是一个相等的关系，需要注意的是 view 上的 alpha 属性是 Web 端并不具备的一个能力，所以笔者认为：在 iOS 中去说 alpha 时，要区分是在说 view 上的属性，还是在说颜色通道里的 alpha。 由于这两个词都是在描述程度，所以我们看到它们都是 CGFloat 类型： 转场过程中需要注意的问题和细节 说完了导航栏的转场时机和转场方式，其实大体上你已经能处理好不同样式间的转换，但还有一些细节需要你去考虑，下面我们来说说其中需要你关注的两点。 translucent 属性带来的布局改变 translucent 会影响导航栏组件里 ViewController 的 View 布局，这里需要大家理清 5 个 API 的使用场景： edgesForExtendedLayout extendedLayoutIncluedsOpaqueBars automaticallyAdjustScrollViewInsets contentInsetAdjustmentBehavior additionalSafeAreaInsets 前三个 API 是 iOS 11 之前的 API，它们之间的区别和联系在 Stack Overflow 上有一个比较精彩的回答 - Explaining difference between automaticallyAdjustsScrollViewInsets, extendedLayoutIncludesOpaqueBars, edgesForExtendedLayout in iOS7，我在这里就不做详细阐述，总结一下它的观点就是: 如果我们先定义一个 UINavigationController，它里面包含了多个 UIViewController，每个 UIViewController 里面包含一个 UIView 对象： 那么 edgesForExtendedLayout 是为了解决 UIViewController 与 UINavigationController 的对齐问题，它会影响 UIViewController 的实际大小，例如 edgesForExtendedLayout 的值为 UIRectEdgeAll 时，UIViewController 会占据整个屏幕的大小。 当 UIView 是一个 UIScrollView 类或者子类时，automaticallyAdjustsScrollViewInsets 是为了调整这个 UIScrollView 与 UINavigationController 的对齐问题，这个属性并不会调整 &nbsp;UIViewController 的大小。 对于 UIView 是一个 UIScrollView 类或者子类且导航栏的背景色是不透明的状态时，我们会发现使用 edgesForExtendedLayout 来调整 UIViewController 的大小是无效的，这时候你必须使用 extendedLayoutIncludesOpaqueBars 来调整 UIViewController 的大小，可以认为 extendedLayoutIncludesOpaqueBars 是基于 automaticallyAdjustsScrollViewInsets 诞生的，这也是为什么经常会看到这两个 API 会同时使用。 这些调整布局的 API 背后是一套基于 topLayoutGuide 和 bottomLayoutGuide 的计算而已，在 iOS 11 后，Apple 提出了 Safe Area 的概念，将原先分裂开来的 topLayoutGuide 和 bottomLayoutGuide 整合到一个统一的 LayoutGuide 中，也就是所谓的 Safe Area，这个改变看起来似乎不是很大，但它的出现确实方便了开发者。 如果想对 Safe Area 带来的改变有更全面的认识，十分推荐阅读 Rosberry 的工程师 Evgeny Mikhaylov 在 Medium 上的文章 iOS Safe Area，这篇文章基本涵盖了 iOS 11 中所有与 Safe Area 相关的 API 并给出了真正合理的解释。 这里只说一下 contentInsetAdjustmentBehavior 和 additionalSafeAreaInsets 两个 API。 对于 contentInsetAdjustmentBehavior 属性而言，它的诞生也意味着 automaticallyAdjustsScrollViewInsets 属性的失效，所以我们在那些已经适配了 iOS 11 的工程里能看到如下类似的代码： if&nbsp;(@available(iOS&nbsp;11.0,&nbsp;*))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;self.tableView.contentInsetAdjustmentBehavior&nbsp;=&nbsp;UIScrollViewContentInsetAdjustmentNever;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;self.automaticallyAdjustsScrollViewInsets&nbsp;=&nbsp;NO;} 此处的代码片段只是一个示例，并不适用所有的业务场景，这里需要着重说明几个问题： 关于 contentInsetAdjustmentBehavior 中的 UIScrollViewContentInsetAdjustmentAutomatic 的说明一直很“模糊”，通过 Evgeny Mikhaylov 的文章，我们可以了解到它在大多数情况下会与 UIScrollViewContentInsetAdjustmentScrollableAxes 一致，当且仅当满足以下所有条件时才会与 UIScrollViewContentInsetAdjustmentAlways 相似： UIScroller 类型的视图在水平轴方向是可滚动的，垂直轴是不可滚动的。 ViewController 视图里的第一个子控件是 UIScrollView 类型的视图。 ViewController 是 navigation 或者 tab 类型控制器的子视图控制器。 启用 automaticallyAdjustsScrollViewInsets。 iOS 11 后，通过 contentInset 属性获取的偏移量与 iOS 10 之前的表现形式并不一致，需要获取 adjustedContentInset 属性才能保证与之前的 contentInset 属性一致，这样的改变需要我们在代码里对不同的版本进行适配。 对于 additionalSafeAreaInsets 而言，如果系统提供的这几种行为并不能满足我们的布局要求，开发者还可以考虑使用 additionalSafeAreaInsets 属性做调整，这样的设定使得开发者可以更加灵活，更加自由的调整视图的布局。 backIndicator 上的动画 苹果提供了许多修改导航栏组件样式的 API，有关于布局的，有关于样式的，也有关于动画的。backIndicatorImage 和 backIndicatorTransitionMaskImage 就是其中的两个 API。 backIndicatorImage 和 backIndicatorTransitionMaskImage 操作的是 NavigationBar 里返回按钮的图片，也就是下图红色圆圈所标注的区域。 想要成功的自定义返回按钮的图标样式，我们需要同时设置这两个 API ，从字面上来看，它们一个是返回图片本身，另一个是返回图片在转场时用到的 mask 图片，看起来不怎么难，我们写一段代码试试效果： self.navigationController.navigationBar.backIndicatorImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrow&quot;];self.navigationController.navigationBar.backIndicatorTransitionMaskImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrowMask&quot;]; 代码里的图片如下所示： 也许大多数人在这里会都认为，mask 图片会遮挡住文字使其在遇到返回按钮右边缘的时候就消失。但实际的运行效果是怎么样子的呢？我们来看一下： 在上面的图片中，我们可以看到返回按钮的文字从返回按钮的图片下面穿过并且文字被图片所遮挡，这种动画看起来十分奇怪，这是无法接受的。我们需要做点修改： self.navigationController.navigationBar.backIndicatorImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrow&quot;];self.navigationController.navigationBar.backIndicatorTransitionMaskImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrow&quot;]; 这一次我们将 backIndicatorTransitionMaskImage 改为 indicatorImage 所用的图片。 到这里，可能大多数人都会好奇，这代码也能行？让我们看下它实际的效果： 在上面的图中，我们看到文字在到达图片的右边缘时就从下方穿过并被完全遮盖住了，这种动画效果虽然比上面好一些，但仍然有改进的空间，不过这里我们先不继续优化了，我们先来讨论一下它们背后的运作原理。 iOS 系统会将 indicatorImage 中不透明的颜色绘制成返回按钮的图标， indicatorTransitionMaskImage 与 indicatorImage 的作用不同。indicatorTransitionMaskImage 将自身不透明的区域像 mask 一样作用在 indicatorImage 上，这样就保证了返回按钮中的文字像左移动时，文字只出现在被 mask 的区域，也就是 indicatorTransitionMaskImage 中不透明的区域。 掌握了原理，我们来解释下刚才的两种现象： 在第一种实现中，我们提供的 indicatorTransitionMaskImage 覆盖了整个返回按钮的图标，所以我们在转场过程中可以清晰的看到返回按钮的文字。 在第二种实现中，我们使用 indicatorImage 作为 indicatorTransitionMaskImage，记住文字是只能出现在 indicatorTransitionMaskImage 里不透明的区域，所以显然返回按钮中的文字会在图标的最右边就已经被遮挡住了，因为那片区域是透明的。 那么前面提到的进一步优化指的是什么呢？ 让我们来看一下下面这个示例图，为了更好的区分，我们将 indicatorTransitionMaskImage 用红色进行标注。黑色仍然是 indicatorImage。 按照刚才介绍的原理，我们应该可以理解，现在文字只会出现在红色区域，那么它的实际效果是什么样子的呢，我们可以看下图： 现在，一个完美的返回动画，诞生啦！ 此节所用的部分效果图出自 Ray Wenderlich 的文章 UIAppearance Tutorial: Getting Started 导航栏的跳转或许可以这么玩儿…… 前两章的铺垫就是为了这一章的内容，所以现在让我们开始今天的大餐吧。 这样真的好么？ 刚才我们说了两个页面间 NavigationBar 的样式变化需要在各自的 viewWillAppear: 和 viewWillDisappear: 中进行设置。那么问题就来了：这样的设置会带来什么问题呢？ 试想一下，当我们的页面会跳到不同的地方时，我们是不是要在 viewWillAppear: 和 viewWillDisappear: 方法里面写上一堆的判断呢？如果应用里还有 router 系统的话，那么页面间的跳转将变得更加不可预知，这时候又该如何在 viewWillAppear: 和 viewWillDisappear: 里做判断呢？ 现在我们的问题就来了，如何让导航栏的转场更加灵活且相互独立呢？ 常见的解决方案如下所示： 重新实现一个类似 UINavigationController 的容器类视图管理器，这个容器类视图管理器做好不同 ViewController 间的导航栏样式转换工作，而每个 ViewController 只需要关心自身的样式即可。 将系统原有导航栏的背景设置为透明色，同时在每个 ViewController 上添加一个 View 或者 NavigationBar 来充当我们实际看到的导航栏，每个 ViewController 同样只需要关心自身的样式即可。 在转场的过程中隐藏原有的导航栏并添加假的 NavigationBar，当转场结束后删除假的 NavigationBar 并恢复原有的导航栏，这一过程可以通过 Swizzle 的方式完成，而每个 ViewController 只需要关心自身的样式即可。 这三种方案各有优劣，我们在网上也可以看到很多关于它们的讨论。 例如方案一，虽然看起来工作量大且难度高，但是这个工作一旦完成，我们就会将处理导航栏转场的主动权牢牢抓在手里。但这个方案的一个弊端就是，如果苹果修改了导航栏的整体风格，就好比 iOS 11 的大标题特效，那么工作量就来了。 对于方案二而言，虽然看起来简单易用，但这需要一个良好的继承关系，如果整个工程里的继承关系混乱或者是历史包袱比较重，后续的维护就像“打补丁”一样，另外这个方案也需要良好的团队代码规范和完善的技术文档来做辅助。 对于方案三而言，它不需要所谓的继承关系，使用起来也相对简单，这对于那些继承关系和历史包袱比较重的工程而言，这一个不错的解决方案，但在解决 Bug 的时候，Swizzle 这种方式无疑会增加解决问题的时间成本和学习成本。 我们的解决方案 在美团 App 的早期，各个业务方都想充分利用导航栏的能力，但对于导航栏的状态维护缺乏理解与关注，随着业务方的增加和代码量的上升，与导航栏相关的问题逐渐暴露出来，此时我们才意识到这个问题的严重性。 大型 App 的导航栏问题就像一个典型的“公地悲剧”问题。在软件行业，公用代码的所有权可以被视作“公地”，因为不注重长期需求而容易遭到消耗。如果开发人员倾向于交付“价值”，而以可维护性和可理解性为代价，那么这个问题就特别普遍了。如果是这种情况，每次代码修改将大大减少其总体质量，最终导致软件的不可维护。 所以解决这个问题的核心在于：明确公用代码的所有权，并在开发期施加约束。 明确公用代码的所有权，可以理解为将导航栏相关的组件抽离成一个单独的组件，并交由特定的团队维护。而在开发期施加约束，则意味着我们要提供一套完整的解决方案让各个业务方遵守。 这一节我们会以美团内部的解决方案为例，讲解如何实现一个流畅的导航栏跳转过程和相关使用方法。 设计理念 使用者只用关心当前 ViewController 的 NavigationBar 样式，而不用在 push 或者 pop 的时候去处理 NavigationBar 样式。 举个例子来说，当从 A 页面 push 到 B 页面的时候，转场库会保存 A 页面的导航栏样式，当 pop 回去后就会还原成以前的样式，因此我们不用考虑 pop 后导航栏样式会改变的情况，同时我们也不必考虑 push 后的情况，因为这个是页面 B 本身需要考虑的。 使用方法 转场库的使用十分简单，我们不需要 import 任何头文件，因为它在底层通过 Method Swizzling 进行了处理，只需要在使用的时候遵循下面 4 点即可： 当需要改变导航栏样式的时候，在视图控制器的 viewDidLoad 或者 viewWillAppear: 方法里去设置导航栏样式。 用 setBackgroundImage:forBarMetrics: 方法和 shadowImage 属性去修改导航栏的背景样式。 不要在 viewWillDisappear: 里添加针对导航栏样式修改的代码。 不要随意修改 translucent 属性，包括隐式的修改和显示的修改。 隐式修改是指使用 setBackgroundImage:forBarMetrics: 方法时，如果 image 里的像素点没有 alpha 通道或者 alpha 全部等于 1 会使得 translucent 变为 NO 或者 nil。 基本原理 以上，我们讲完了设计理念和使用方法，那么我们来看看美团的转场库到底做了什么？ 从大方向上来看，美团使用的是前面所说的第三种方案，不过它也有一些自己独特的地方，为了更好的让大家理解整个过程，我们设计这样一个场景，从页面 A push 到页面 B，结合之前探讨过的方法调用顺序，我们可以知道几个核心方法的调用顺序大致如下： 页面 A 的 pushViewController:animated: 页面 B 的 viewDidLoad or viewWillAppear: 页面 B 的 viewWillLayoutSubviews 页面 B 的 viewDidAppear: 在 push 过程的开始，转场库会在页面 A 自身的 view 上添加一个与导航栏一模一样的 NavigationBar 并将真的导航栏隐藏。之后这个假的导航栏会一直存在页面 A 上，用于保留 A 离开时的导航栏样式。 等到页面 B 调用 viewDidLoad 或者 viewWillAppear: 的时候，开发者在这里自行设置真的导航栏样式。转场库在这里会对页面布局做一些修正和辅助操作，但不会影响导航栏的样式。 等到页面 B 调用 viewWillLayoutSubviews 的时候，转场库会在页面 B 自身的 view 上添加一个与真的导航栏一模一样的 NavigationBar，同时将真的导航栏隐藏。此时不论真的导航栏，还是假的导航栏都已经与 viewDidLoad 或者 viewWillAppear: 里设置的一样的。 当然，这一步也可以放在 viewWillDisappear: 里并在 dispatch main queue 的下一个 runloop 中处理。 等到页面 B 调用 viewDidAppear: 的时候，转场库会将假的导航栏样式设置到真的导航栏中，并将假的导航栏从视图层级中移除，最终将真的导航栏显示出来。 为了让大家更好地理解上面的内容，请参考下图： 说完了 push 过程，我们再来说一下从页面 B pop 回页面 A 的过程，几个核心方法的调用顺序如下： 页面 B 的 popViewControllerAnimated: 页面 A 的 viewWillAppear: 页面 A 的 viewDidAppear: 在 pop 过程的开始，转场库会在页面 B 自身的 view 上添加一个与导航栏一模一样的 NavigationBar 并将真的导航栏隐藏，虽然这个假的导航栏会一直存在于页面 B 上，但它自身会随着页面 B 的 dealloc 而消亡。 等到页面 A 调用 viewWillAppear: 的时候，开发者在这里自行设置真的导航栏样式。当然我们也可以不设置，因为这时候页面 A 还持有一个假的导航栏，这里还保留着我们之前在 viewDidLoad 里写的导航栏样式。 等到页面 A 调用 viewDidAppear: 的时候，转场库会将假的导航栏样式设置到真的导航栏中，并将假的导航栏从视图层级中移除，最终将真的导航栏显示出来。 同样，我们可以参考下面的图来理解上面所说的内容： 现在，大家应该对我们美团的解决方案有了一定的认识，但在实际开发过程中，还需要考虑一些布局和适配的问题。 最佳实践 在维护这套转场方案的时间里，我们总结了一些此类方案的最佳实践。 判断导航栏问题的基本准则 如果发现导航栏在转场过程中出现了样式错乱，可以遵循以下几点基本原则： 检查相应 ViewController 里是否有修改其他 ViewController 导航栏样式的行为，如果有，请做调整。 保证所有对导航栏样式变化的操作出现在 viewDidLoad 和 viewWillAppear: 中，如果在 viewWillDisappear: 等方法里出现了对导航栏的样式修改的操作，如果有，请做调整。 检查是否有改动 translucent 属性，包括显示修改和隐式修改，如果有，请做调整。 只关心当前页面的样式 永远记住每个 ViewController 只用关心自己的样式，设置的时机点在 viewWillAppear: 或者 viewDidLoad 里。 透明样式导航栏的正确设置方法 如果需要一个透明效果的导航栏，可以使用如下代码实现： [self.navigationController.navigationBar&nbsp;setBackgroundImage:[UIImage&nbsp;new]&nbsp;forBarMetrics:UIBarMetricsDefault];self.navigationController.navigationBar.shadowImage&nbsp;=&nbsp;[UIImage&nbsp;new];&nbsp; 导航栏的颜色渐变效果 如果需要导航栏实现随滚动改变整体 alpha 值的效果，可以通过改变 setBackgroundImage:forBarMetrics: 方法里 image 的 alpha 值来达到目标，这里一般是使用监听 scrollView.contentOffset 的手段来做。请避免直接修改 NavigationBar 的 alpha 值。 如果发现这种方式会引起严重的性能问题，可以尝试使用如下的方式进行修改，但不推荐，主要原因是通过读取数组内容的方式来获取视图实例既不优雅，也不安全。 UIView&nbsp;*background&nbsp;=&nbsp;self.navigationController.navigationBar.subviews.firstObject;background.alpha&nbsp;=&nbsp;MIN(self.contentOffsetY&nbsp;/&nbsp;100.0,&nbsp;1); 还有一点需要注意的是，在页面转场的过程中，也会触发 contentOffset 的变化，所以请尽量在 disappear 的时候取消监听。否则会容易出现导航栏透明度的变化。 导航栏背景图片的规范 请避免背景图里的像素点没有 alpha 通道或者 alpha 全部等于 1，容易触发 translucent 的隐式改变。 如果真的要隐藏导航栏 如果我们需要隐藏导航栏，请保证所有的 ViewController 能坚持如下原则： 每个 ViewController 只需要关心当前页面下的导航栏是否被隐藏。 在 viewWillAppear: 中，统一设置导航栏的隐藏状态。 使用 setNavigationBarHidden:animated: 方法，而不是 setNavigationBarHidden:。 转场动画与导航栏隐藏动画的一致性 如果在转场的过程中还会显示或者隐藏导航栏的话，请保证两个方法的动画参数一致。 -&nbsp;(void)viewWillAppear:(BOOL)animated{&nbsp;&nbsp;&nbsp;&nbsp;[self.navigationController&nbsp;setNavigationBarHidden:YES&nbsp;animated:animated];} viewWillAppear: 里的 animated 参数是受 push 和 pop 方法里 animated 参数影响。 导航栏固有的系统问题 目前已知的有两个系统问题如下： 当前后两个 ViewController 的导航栏都处于隐藏状态，然后在后一个 ViewController 中使用返回手势 pop 到一半时取消，再连续 push 多个页面时会造成导航栏的 Stack 混乱或者 Crash。 当页面的层级结构大体如下所示时，在红色导航栏的 Stack 中，返回手势会大概率的出现跨层级的跳转，多次后会导致整个导航栏的 Stack 错乱或者 Crash。 导航栏内置组件的布局规范 导航栏里的组件布局在 iOS 11 后发生了改变，原有的一些解决方案已经失效，这些内容不在本篇文章的讨论范围之内，推荐阅读UIBarButtonItem 在 iOS 11 上的改变及应对方案，这篇文章详细的解释了 iOS 11 里的变化和可行的应对方案。 总结 本文涉及内容较多，从 iOS 系统下的导航栏概念到大型应用里的最佳实践，这里我们总结一下整篇文章的核心内容： 理解导航栏组件的结构和相关方法的生命周期。 导航栏组件的结构留有 MVC 架构的影子，在解决问题时，要去相应的层级处理。 转场问题的关键点是方法的调用顺序，所以了解生命周期是解决此类问题的基础。 状态管理，转换时机和样式变化是导航栏里常见问题的三种表现形式，遇到实际问题时需要区分清楚。 状态管理要坚持“谁修改，谁复原”的原则。 转换时机的设定要做到连续可执行。 样式变化的核心点是导航栏的显示与否与颜色变化。 为了更好的配合大型应用里的路由系统，导航栏转场的常见解决方案有三种，各有利弊，需要根据自身的业务场景和历史包袱做取舍。 解决方案1：自定义导航栏组件。 解决方案2：在原有导航栏组件里添加 Fake Bar。 解决方案3：在导航栏转场过程中添加 Fake Bar。 美团在实际开发过程中采用了第三种方案，并给出了适合美团 App 的最佳实践。 参考链接 UIAppearance Tutorial: Getting Started KMNavigationBarTransition 特别感谢莫洲骐在此项目中做出的贡献与付出。 作者简介 思琦，美团点评 iOS 工程师。2016 年加入美团，负责美团平台的业务开发及 UI 组件的维护工作。 扫码加入美团iOS技术交流群，跟作者零距离交流。如群已满，请加美美同学的微信（微信号：MTDPtech01），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 美团平台诚招 iOS、Android、FE 高级/资深工程师和技术专家，Base 北京、上海、成都，欢迎有兴趣的同学投递简历到zhangsiqi04@meituan.com。&nbsp; 也许你还想看 美团外卖iOS多端复用的推动、支撑与思考 基于 KIF 的 iOS UI 自动化测试和持续集成 ARKit：增强现实技术在美团到餐业务的实践" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"总第294篇 2018年 第86篇 前言 目前，开源社区和业界内已经存在一些 iOS 导航栏转场的解决方案，但对于历史包袱沉重的美团 App 而言，这些解决方案并不完美。有的方案不能满足复杂的页面跳转场景，有的方案迁移成本较大，为此我们提出了一套解决方案并开发了相应的转场库，目前该转场库已经成为美团点评多个 App 的基础组件之一。 在美团 App 开发的早期，涉及到导航栏样式改变的需求时，经常会遇到转场效果不佳或者与预期样式不符的“小问题”。在业务体量较小的情况下，为了满足快速的业务迭代，通常会使用硬编码的方式来解决这一类“小问题”。但随着美团 App 业务的高速发展，这种硬编码的方式遇到了以下的挑战： 业务模块的不断增加，导致使用硬编码方式编写的代码维护成本增加，代码质量迅速下降。 大型 App 的路由系统使得页面间的跳转变得更加自由和灵活，也使得导航栏相关的问题激增，不但增加了问题的排查难度，还降低了整体的开发效率。 App 中的导航栏属于各个业务方的公用资源，由于缺乏相应的约束机制和最佳实践，导致业务方之间的代码耦合程度不断增加。 从各个角度来看，硬编码的方式已经不能很好的解决此类问题，美团 App 需要一个更加合理、更加持久、更加简单易行的解决方案来处理导航栏转场问题。 本文将从导航栏的概念入手，通过讲解转场过程中的状态管理、转换时机和样式变化等内容，引出了在大型应用中导航栏转场的三种常见解决方案，并对美团的解决方案进行剖析，同时介绍了我们总结的最佳实践。 重新认识导航栏 导航栏里的 MVC 在 iOS 系统中， 苹果公司不仅建议开发者遵循 MVC 开发框架，在他们的代码里也可以看到 MVC 的影子，导航栏组件的构成就是一个类似 MVC 的结构，让我们先看看下面这张图： 在这张图里，我们可以将 UINavigationController 看做是 C，UINavigationBar 看做是 V，而 UIViewController 和 UINavigationItem 组成的 Stack 可以看做是 M。这里要说明的是，每个 UIViewController 都有一个属于自己的 UINavigationItem，也就是说它们是一一对应的。 UINavigationController 通过驱动 Stack 中的 UIViewController 的变化来实现 View 层级的变化，也就是 UINavigationBar 的改变。而 UINavigationBar 样式的数据就存储在 UIViewController 的 UINavigationItem 中。这也就是为什么我们在代码里只要设置 self.navigationItem 的相关属性就可以改变 UINavigationBar 的样式。 很多时候，国内的开发者会将 UINavigationBar 和 UINavigationController 混在一起叫导航栏，这样的做法不仅增加了开发者之间的沟通成本，也容易导致误解。毕竟它们是两个完全不一样的东西。 所以本文为了更好的阐明问题，会采用英文区分不同的概念，当需要描述笼统的导航栏概念时，会使用导航栏组件一词。 通过这一节的回顾，我们应该明确了 NavigationItem、ViewController、NavigationBar 和 NavigationController 在 MVC 框架下的角色。下面我们会重新梳理一下导航栏的生命周期和各个相关方法的调用顺序。 导航栏组件的生命周期 大家可以通过下图获得更为直观的感受，进而了解到导航栏组件在 push 过程中各个方法的调用顺序。 值得注意的地方有两点： 第一个是 UINavigationController 作为 UINavigationBar 的代理，在没有特殊需求的情况下，不应该修改其代理方法，这里是通过符号断点获取它们的调用顺序。如果我们创建了一个自定义的导航栏组件系统，它的调用顺序可能会与此不同。 第二个是用虚线圈起来的方法，它们也有可能不被调用，这与 ViewController 里的布局代码相关，假设跳转到新页面后，新旧页面中的控件位置会发生变化，或者由于数据改变驱动了控件之间的约束关系发生变化，这就会带来新一轮的布局，进而触发 viewWillLayoutSubview 和 viewDidLayoutSubview 这两个方法。当然，具体的调用顺序会与业务代码紧密相关，如果我们发现顺序有所不同，也不必惊慌。 下面这张图展示了导航栏在 pop 过程中各个方法的调用顺序： 除了上面说到的两点，pop 过程中还需要注意一点，那就是从 B 返回到 A 的过程中，A 视图控制器的 viewDidLoad 方法并不会被调用。关于这个问题，只要提醒一下，大多数人都会反应过来是为什么。不过在实际开发过程中，总会有人忘记这一点。 通过这两个图，我们已经基本了解了导航栏组件的生命周期和相关方法的调用顺序，这也是后面章节的理论基础。 导航栏组件的改变与革新 导航栏组件在 iOS 11 发布时，获得了重大更新，这个更新可不是增加了一个大标题样式（Large Title Display Mode）那么简单，需要注意的地方大概有两点： 导航栏全面支持 Auto Layout 且 NavigationBar 的层级发生了明显的改变，关于这一点可以阅读 UIBarButtonItem 在 iOS 11 上的改变及应对方案 。 由于引进了 Safe Area 等概念，topLayoutGuide 和 bottomLayoutGuide 等属性会逐渐废弃，虽然变化不大，但如果我们的导航栏在转场过程中总是出现视图上下移动的现象，不妨从这个方面思考一下，如果想深究可以查看 WWDC 2017 Session 412。 导航栏组件到底怎么了？ 经常有人说 iOS 的原生导航栏组件不好使用，抱怨主要集中在导航栏组件的状态管理和控件的布局问题上。 控件的布局问题随着 iOS 11 的到来已经变得相对容易处理了不少，但导航栏组件的状态管理仍然让开发者头疼不已。 可能已经有朋友在思考导航栏组件的状态管理到底是什么东西？不要着急，下面的章节就会做相关的介绍。 导航栏的状态管理 虽然导航栏组件的 push 和 pop 动画给人一种每次操作后都会创建一遍导航栏组件的错觉，但实际上这些 ViewController 都是由一个 NavigationController 所管理，所以你看到的 NavigationBar 是唯一的。 在 NavigationController 的 Stack 存储结构下，每当 Stack 中的 ViewController 修改了导航栏，势必会影响其他 ViewController 展示的效果。 例如下图所示的场景，如果 NavigationBar 原先的颜色是绿色，但之后进入 Stack 里的 ViewController 将 NavigationBar 颜色修改为紫色后，在此之后 push 的 ViewController 会从默认的绿色变为紫色，直到有新的 ViewController 修改导航栏颜色才会发生变化。 虽然在 push 过程中，NavigationBar 的变化听起来合情合理，但如果你在 NavigationBar 为绿色的 ViewController 里设置不当的话，那么当你 pop 回这个 ViewController 时，NavigationBar 可就不一定是绿色了，它还会保持为紫色的状态。 通过这个例子，我们大概会意识到在导航栏里的 Stack 中，每个 ViewController 都可以永久的影响导航栏样式，这种全局性的变化要求我们在实际开发中必须坚持“谁修改，谁复原”的原则，否则就会造成导航栏状态的混乱。这不仅仅是样式上的混乱，在一些极端状况下，还有可能会引起 Stack 混乱，进而造成 Crash 的情况。 导航栏样式转换的时机 我们刚才提到了“谁修改，谁复原”的原则，但何时修改，何时复原呢？ 对于那些存储在 Stack 中的 ViewController 而言，它其实就是在不断的经历 appear 和 disappear 的过程，结合 ViewController 的生命周期来看，viewWillAppear: 和 viewWillDisappear: 是两个完美的时间节点，但很多人却对这两个方法的调用存在疑惑。 苹果公司在它的 API 文档中专门用了一段文字来解答大家的疑惑，这段文字的标题为《Handling View-Related Notifications》，在这里我们直接引用原文： When the visibility of its views changes, a view controller automatically calls its own methods so that subclasses can respond to the change. Use a method like viewWillAppear: to prepare your views to appear onscreen, and use the viewWillDisappear: to save changes or other state information. Use other methods to make appropriate changes.Figure 1 shows the possible visible states for a view controller’s views and the state transitions that can occur. Not all ‘will’ callback methods are paired with only a ‘did’ callback method. You need to ensure that if you start a process in a ‘will’ callback method, you end the process in both the corresponding ‘did’ and the opposite ‘will’ callback method. 这里很好的解释了所有的 will 系列方法和 did 系列方法的对应关系，同时也给我们吃了一个定心丸，那就是在 appearing 和 disappearing 状态之间会由 will 系列方法进行衔接，避免了状态中断。这对于连续 push 或者连续 pop 的情况是及其重要的，否则我们无法做到 “谁修改，谁复原”的原则。 通常来说，如果只是一个简单的导航栏样式变化，我们的代码结构大体会如下所示： -&nbsp;(void)viewWillAppear:(BOOL)animated{&nbsp;&nbsp;&nbsp;&nbsp;[super&nbsp;viewWillAppear:animated];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;MARK:&nbsp;change&nbsp;the&nbsp;navigationbar&nbsp;style&nbsp;}-&nbsp;(void)viewWillDisappear:(BOOL)animated{&nbsp;&nbsp;&nbsp;&nbsp;[super&nbsp;viewWillDisappear:animated];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;MARK:&nbsp;restore&nbsp;the&nbsp;navigationbar&nbsp;style} 现在，我们明确了修改时机，接下来要明确的就是导航栏的样式会进行怎样的变化。 导航栏的样式变化 对于不同 ViewController 之间的导航栏样式变化，大多可以总结为两种情况： 导航栏的显示与否 导航栏的颜色变化 导航栏的显示与否 对于显示与否的问题，可以在上一节提到的两个方法里调用 setNavigationBarHidden:animated: 方法，这里需要提醒的有两点： 在导航栏转场的过程中，不要天真的以为 setNavigationBarHidden: 和 setNavigationBarHidden:animated: 的效果是一样的，直接使用 setNavigationBarHidden: 会造成导航栏转场过程中的闪现、背景错乱等问题，这一现象在使用手势驱动转场的场景中十分常见，所以正确的方式是使用带有 animated 参数的 API。 在 push 和 pop 的方法里也会带有 animated 参数，尽量保证与 setNavigationBarHidden:animated: 中的 animated 参数一致。 导航栏的颜色变化 颜色变化的问题就稍微复杂一些，在 iOS 7 后，导航栏增加了 translucent 效果，这使得导航栏背景色的变化出现了两种情况： translucent 属性值为 YES 的前提下，更改导航栏的背景色。 translucent 属性值为 NO 的前提下，更改导航栏的背景色。 对于第一种情况，我们需要调用 UINavigationBar 的 setBackgroundColor: 方法。 对于第二种情况我们需要调用 UINavigationBar 的 setBackgroundImage:forBarMetrics: 方法。 对于第二种情况，这里有三点需要提示： 在设置透明效果时，我们通常可以直接设置一个 [UIImage new] 创建的对象，无须创建一个颜色为透明色的图片。 在使用 setBackgroundImage:forBarMetrics: 方法的过程中，如果图像里存在 alpha 值小于 1.0 的像素点，则 translucent 的值为 YES，反之为 NO。也就是说，如果我们真的想让导航栏变成纯色且没有 translucent 效果，请保证所有像素点的 alpha 值等于 1。 如果设置了一个完全不透明的图片且强行将 NavigationBar 的 translucent 属性设置为 YES 的话，系统会自动修正这个图片并为它添加一个透明度，用于模拟 translucent 效果。 如果我们使用了一个带有透明效果的图片且导航栏的 translucent 效果为 NO 的话，那么系统会在这个带有透明效果的图片背后，添加一个不透明的纯色图片用于整体效果的合成。这个纯色图片的颜色取决于 barStyle 属性，当属性为 UIBarStyleBlack 时为黑色，当属性为 UIBarStyleDefault 时为白色，如果我们设置了 barTintColor，则以设置的颜色为基准。 分清楚 transparent，translucent，opaque，alpha 和 opacity 也挺重要 在刚接触导航栏 API 时，许多人经常会把文档里的这些英文词搞混，也不太明白带有这些词的变量为什么有的是布尔型，有的是浮点型，总之一切都让人很困惑。 在这里将做了一个总结，这对于理解 Apple 的 API 设计原则十分有帮助。 transparent， translucent， opaque 三个词经常会用在一起，它用于描述物体的透光强度，为了让大家更好的理解这三个词，这里做了三个比喻： transparent 是指透明，就好比我们可以透过一面干净的玻璃清楚的看到外面的风景。 translucent 是指半透明，就好比我们可以透过一面有点磨砂效果的塑料墙看外面的风景，不能说看不见，但我们肯定看不清。 opaque 是指不透明，就好比我们透过一个堵石墙是看不见任何外面的东西，眼前看到的只有这面墙。 这三个词更多的是用来表述一种状态，不需要量化，所以这与这三个词相关的属性，一般都是 BOOL 类型。 alpha 和 opacity 经常会在一起使用，它要表示的就是透明度，在 Web 端这两个属性有着明显的区别。 在 Web 端里，opacity 是设定整个元素的透明值，而 alpha 一般是放在颜色设置里面，所以我们可以做到对特定对元素的某个属性设定 alpha，比如背景、边框、文字等。 div&nbsp;{&nbsp;&nbsp;width:&nbsp;100px;&nbsp;&nbsp;height:&nbsp;100px;&nbsp;&nbsp;background:&nbsp;rgba(0,0,0,0.5);&nbsp;&nbsp;border:&nbsp;1px&nbsp;solid&nbsp;#000000;&nbsp;&nbsp;opacity:&nbsp;0.5;} 这一概念同样适用于 iOS 里的概念，比如我们可以通过 alpha 通道单独的去设置 backgroudColor、borderColor，它们互不影响，且有着独立的 alpha 通道，我们也可以通过 opacity 统一设置整个 view 的透明度。 但与 Web 端不一致的是，iOS 里面的 view 不光拥有独立的 alpha 属性，同时也是基于 CALayer，所以我们可以看到任意 UIView 对象下面都会有一个 layer 的属性，用于表明 CALayer 对象。view 的 alpha 属性与 layer 里面的 opacity 属性是一个相等的关系，需要注意的是 view 上的 alpha 属性是 Web 端并不具备的一个能力，所以笔者认为：在 iOS 中去说 alpha 时，要区分是在说 view 上的属性，还是在说颜色通道里的 alpha。 由于这两个词都是在描述程度，所以我们看到它们都是 CGFloat 类型： 转场过程中需要注意的问题和细节 说完了导航栏的转场时机和转场方式，其实大体上你已经能处理好不同样式间的转换，但还有一些细节需要你去考虑，下面我们来说说其中需要你关注的两点。 translucent 属性带来的布局改变 translucent 会影响导航栏组件里 ViewController 的 View 布局，这里需要大家理清 5 个 API 的使用场景： edgesForExtendedLayout extendedLayoutIncluedsOpaqueBars automaticallyAdjustScrollViewInsets contentInsetAdjustmentBehavior additionalSafeAreaInsets 前三个 API 是 iOS 11 之前的 API，它们之间的区别和联系在 Stack Overflow 上有一个比较精彩的回答 - Explaining difference between automaticallyAdjustsScrollViewInsets, extendedLayoutIncludesOpaqueBars, edgesForExtendedLayout in iOS7，我在这里就不做详细阐述，总结一下它的观点就是: 如果我们先定义一个 UINavigationController，它里面包含了多个 UIViewController，每个 UIViewController 里面包含一个 UIView 对象： 那么 edgesForExtendedLayout 是为了解决 UIViewController 与 UINavigationController 的对齐问题，它会影响 UIViewController 的实际大小，例如 edgesForExtendedLayout 的值为 UIRectEdgeAll 时，UIViewController 会占据整个屏幕的大小。 当 UIView 是一个 UIScrollView 类或者子类时，automaticallyAdjustsScrollViewInsets 是为了调整这个 UIScrollView 与 UINavigationController 的对齐问题，这个属性并不会调整 &nbsp;UIViewController 的大小。 对于 UIView 是一个 UIScrollView 类或者子类且导航栏的背景色是不透明的状态时，我们会发现使用 edgesForExtendedLayout 来调整 UIViewController 的大小是无效的，这时候你必须使用 extendedLayoutIncludesOpaqueBars 来调整 UIViewController 的大小，可以认为 extendedLayoutIncludesOpaqueBars 是基于 automaticallyAdjustsScrollViewInsets 诞生的，这也是为什么经常会看到这两个 API 会同时使用。 这些调整布局的 API 背后是一套基于 topLayoutGuide 和 bottomLayoutGuide 的计算而已，在 iOS 11 后，Apple 提出了 Safe Area 的概念，将原先分裂开来的 topLayoutGuide 和 bottomLayoutGuide 整合到一个统一的 LayoutGuide 中，也就是所谓的 Safe Area，这个改变看起来似乎不是很大，但它的出现确实方便了开发者。 如果想对 Safe Area 带来的改变有更全面的认识，十分推荐阅读 Rosberry 的工程师 Evgeny Mikhaylov 在 Medium 上的文章 iOS Safe Area，这篇文章基本涵盖了 iOS 11 中所有与 Safe Area 相关的 API 并给出了真正合理的解释。 这里只说一下 contentInsetAdjustmentBehavior 和 additionalSafeAreaInsets 两个 API。 对于 contentInsetAdjustmentBehavior 属性而言，它的诞生也意味着 automaticallyAdjustsScrollViewInsets 属性的失效，所以我们在那些已经适配了 iOS 11 的工程里能看到如下类似的代码： if&nbsp;(@available(iOS&nbsp;11.0,&nbsp;*))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;self.tableView.contentInsetAdjustmentBehavior&nbsp;=&nbsp;UIScrollViewContentInsetAdjustmentNever;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;self.automaticallyAdjustsScrollViewInsets&nbsp;=&nbsp;NO;} 此处的代码片段只是一个示例，并不适用所有的业务场景，这里需要着重说明几个问题： 关于 contentInsetAdjustmentBehavior 中的 UIScrollViewContentInsetAdjustmentAutomatic 的说明一直很“模糊”，通过 Evgeny Mikhaylov 的文章，我们可以了解到它在大多数情况下会与 UIScrollViewContentInsetAdjustmentScrollableAxes 一致，当且仅当满足以下所有条件时才会与 UIScrollViewContentInsetAdjustmentAlways 相似： UIScroller 类型的视图在水平轴方向是可滚动的，垂直轴是不可滚动的。 ViewController 视图里的第一个子控件是 UIScrollView 类型的视图。 ViewController 是 navigation 或者 tab 类型控制器的子视图控制器。 启用 automaticallyAdjustsScrollViewInsets。 iOS 11 后，通过 contentInset 属性获取的偏移量与 iOS 10 之前的表现形式并不一致，需要获取 adjustedContentInset 属性才能保证与之前的 contentInset 属性一致，这样的改变需要我们在代码里对不同的版本进行适配。 对于 additionalSafeAreaInsets 而言，如果系统提供的这几种行为并不能满足我们的布局要求，开发者还可以考虑使用 additionalSafeAreaInsets 属性做调整，这样的设定使得开发者可以更加灵活，更加自由的调整视图的布局。 backIndicator 上的动画 苹果提供了许多修改导航栏组件样式的 API，有关于布局的，有关于样式的，也有关于动画的。backIndicatorImage 和 backIndicatorTransitionMaskImage 就是其中的两个 API。 backIndicatorImage 和 backIndicatorTransitionMaskImage 操作的是 NavigationBar 里返回按钮的图片，也就是下图红色圆圈所标注的区域。 想要成功的自定义返回按钮的图标样式，我们需要同时设置这两个 API ，从字面上来看，它们一个是返回图片本身，另一个是返回图片在转场时用到的 mask 图片，看起来不怎么难，我们写一段代码试试效果： self.navigationController.navigationBar.backIndicatorImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrow&quot;];self.navigationController.navigationBar.backIndicatorTransitionMaskImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrowMask&quot;]; 代码里的图片如下所示： 也许大多数人在这里会都认为，mask 图片会遮挡住文字使其在遇到返回按钮右边缘的时候就消失。但实际的运行效果是怎么样子的呢？我们来看一下： 在上面的图片中，我们可以看到返回按钮的文字从返回按钮的图片下面穿过并且文字被图片所遮挡，这种动画看起来十分奇怪，这是无法接受的。我们需要做点修改： self.navigationController.navigationBar.backIndicatorImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrow&quot;];self.navigationController.navigationBar.backIndicatorTransitionMaskImage&nbsp;=&nbsp;[UIImage&nbsp;imageNamed:@&quot;backArrow&quot;]; 这一次我们将 backIndicatorTransitionMaskImage 改为 indicatorImage 所用的图片。 到这里，可能大多数人都会好奇，这代码也能行？让我们看下它实际的效果： 在上面的图中，我们看到文字在到达图片的右边缘时就从下方穿过并被完全遮盖住了，这种动画效果虽然比上面好一些，但仍然有改进的空间，不过这里我们先不继续优化了，我们先来讨论一下它们背后的运作原理。 iOS 系统会将 indicatorImage 中不透明的颜色绘制成返回按钮的图标， indicatorTransitionMaskImage 与 indicatorImage 的作用不同。indicatorTransitionMaskImage 将自身不透明的区域像 mask 一样作用在 indicatorImage 上，这样就保证了返回按钮中的文字像左移动时，文字只出现在被 mask 的区域，也就是 indicatorTransitionMaskImage 中不透明的区域。 掌握了原理，我们来解释下刚才的两种现象： 在第一种实现中，我们提供的 indicatorTransitionMaskImage 覆盖了整个返回按钮的图标，所以我们在转场过程中可以清晰的看到返回按钮的文字。 在第二种实现中，我们使用 indicatorImage 作为 indicatorTransitionMaskImage，记住文字是只能出现在 indicatorTransitionMaskImage 里不透明的区域，所以显然返回按钮中的文字会在图标的最右边就已经被遮挡住了，因为那片区域是透明的。 那么前面提到的进一步优化指的是什么呢？ 让我们来看一下下面这个示例图，为了更好的区分，我们将 indicatorTransitionMaskImage 用红色进行标注。黑色仍然是 indicatorImage。 按照刚才介绍的原理，我们应该可以理解，现在文字只会出现在红色区域，那么它的实际效果是什么样子的呢，我们可以看下图： 现在，一个完美的返回动画，诞生啦！ 此节所用的部分效果图出自 Ray Wenderlich 的文章 UIAppearance Tutorial: Getting Started 导航栏的跳转或许可以这么玩儿…… 前两章的铺垫就是为了这一章的内容，所以现在让我们开始今天的大餐吧。 这样真的好么？ 刚才我们说了两个页面间 NavigationBar 的样式变化需要在各自的 viewWillAppear: 和 viewWillDisappear: 中进行设置。那么问题就来了：这样的设置会带来什么问题呢？ 试想一下，当我们的页面会跳到不同的地方时，我们是不是要在 viewWillAppear: 和 viewWillDisappear: 方法里面写上一堆的判断呢？如果应用里还有 router 系统的话，那么页面间的跳转将变得更加不可预知，这时候又该如何在 viewWillAppear: 和 viewWillDisappear: 里做判断呢？ 现在我们的问题就来了，如何让导航栏的转场更加灵活且相互独立呢？ 常见的解决方案如下所示： 重新实现一个类似 UINavigationController 的容器类视图管理器，这个容器类视图管理器做好不同 ViewController 间的导航栏样式转换工作，而每个 ViewController 只需要关心自身的样式即可。 将系统原有导航栏的背景设置为透明色，同时在每个 ViewController 上添加一个 View 或者 NavigationBar 来充当我们实际看到的导航栏，每个 ViewController 同样只需要关心自身的样式即可。 在转场的过程中隐藏原有的导航栏并添加假的 NavigationBar，当转场结束后删除假的 NavigationBar 并恢复原有的导航栏，这一过程可以通过 Swizzle 的方式完成，而每个 ViewController 只需要关心自身的样式即可。 这三种方案各有优劣，我们在网上也可以看到很多关于它们的讨论。 例如方案一，虽然看起来工作量大且难度高，但是这个工作一旦完成，我们就会将处理导航栏转场的主动权牢牢抓在手里。但这个方案的一个弊端就是，如果苹果修改了导航栏的整体风格，就好比 iOS 11 的大标题特效，那么工作量就来了。 对于方案二而言，虽然看起来简单易用，但这需要一个良好的继承关系，如果整个工程里的继承关系混乱或者是历史包袱比较重，后续的维护就像“打补丁”一样，另外这个方案也需要良好的团队代码规范和完善的技术文档来做辅助。 对于方案三而言，它不需要所谓的继承关系，使用起来也相对简单，这对于那些继承关系和历史包袱比较重的工程而言，这一个不错的解决方案，但在解决 Bug 的时候，Swizzle 这种方式无疑会增加解决问题的时间成本和学习成本。 我们的解决方案 在美团 App 的早期，各个业务方都想充分利用导航栏的能力，但对于导航栏的状态维护缺乏理解与关注，随着业务方的增加和代码量的上升，与导航栏相关的问题逐渐暴露出来，此时我们才意识到这个问题的严重性。 大型 App 的导航栏问题就像一个典型的“公地悲剧”问题。在软件行业，公用代码的所有权可以被视作“公地”，因为不注重长期需求而容易遭到消耗。如果开发人员倾向于交付“价值”，而以可维护性和可理解性为代价，那么这个问题就特别普遍了。如果是这种情况，每次代码修改将大大减少其总体质量，最终导致软件的不可维护。 所以解决这个问题的核心在于：明确公用代码的所有权，并在开发期施加约束。 明确公用代码的所有权，可以理解为将导航栏相关的组件抽离成一个单独的组件，并交由特定的团队维护。而在开发期施加约束，则意味着我们要提供一套完整的解决方案让各个业务方遵守。 这一节我们会以美团内部的解决方案为例，讲解如何实现一个流畅的导航栏跳转过程和相关使用方法。 设计理念 使用者只用关心当前 ViewController 的 NavigationBar 样式，而不用在 push 或者 pop 的时候去处理 NavigationBar 样式。 举个例子来说，当从 A 页面 push 到 B 页面的时候，转场库会保存 A 页面的导航栏样式，当 pop 回去后就会还原成以前的样式，因此我们不用考虑 pop 后导航栏样式会改变的情况，同时我们也不必考虑 push 后的情况，因为这个是页面 B 本身需要考虑的。 使用方法 转场库的使用十分简单，我们不需要 import 任何头文件，因为它在底层通过 Method Swizzling 进行了处理，只需要在使用的时候遵循下面 4 点即可： 当需要改变导航栏样式的时候，在视图控制器的 viewDidLoad 或者 viewWillAppear: 方法里去设置导航栏样式。 用 setBackgroundImage:forBarMetrics: 方法和 shadowImage 属性去修改导航栏的背景样式。 不要在 viewWillDisappear: 里添加针对导航栏样式修改的代码。 不要随意修改 translucent 属性，包括隐式的修改和显示的修改。 隐式修改是指使用 setBackgroundImage:forBarMetrics: 方法时，如果 image 里的像素点没有 alpha 通道或者 alpha 全部等于 1 会使得 translucent 变为 NO 或者 nil。 基本原理 以上，我们讲完了设计理念和使用方法，那么我们来看看美团的转场库到底做了什么？ 从大方向上来看，美团使用的是前面所说的第三种方案，不过它也有一些自己独特的地方，为了更好的让大家理解整个过程，我们设计这样一个场景，从页面 A push 到页面 B，结合之前探讨过的方法调用顺序，我们可以知道几个核心方法的调用顺序大致如下： 页面 A 的 pushViewController:animated: 页面 B 的 viewDidLoad or viewWillAppear: 页面 B 的 viewWillLayoutSubviews 页面 B 的 viewDidAppear: 在 push 过程的开始，转场库会在页面 A 自身的 view 上添加一个与导航栏一模一样的 NavigationBar 并将真的导航栏隐藏。之后这个假的导航栏会一直存在页面 A 上，用于保留 A 离开时的导航栏样式。 等到页面 B 调用 viewDidLoad 或者 viewWillAppear: 的时候，开发者在这里自行设置真的导航栏样式。转场库在这里会对页面布局做一些修正和辅助操作，但不会影响导航栏的样式。 等到页面 B 调用 viewWillLayoutSubviews 的时候，转场库会在页面 B 自身的 view 上添加一个与真的导航栏一模一样的 NavigationBar，同时将真的导航栏隐藏。此时不论真的导航栏，还是假的导航栏都已经与 viewDidLoad 或者 viewWillAppear: 里设置的一样的。 当然，这一步也可以放在 viewWillDisappear: 里并在 dispatch main queue 的下一个 runloop 中处理。 等到页面 B 调用 viewDidAppear: 的时候，转场库会将假的导航栏样式设置到真的导航栏中，并将假的导航栏从视图层级中移除，最终将真的导航栏显示出来。 为了让大家更好地理解上面的内容，请参考下图： 说完了 push 过程，我们再来说一下从页面 B pop 回页面 A 的过程，几个核心方法的调用顺序如下： 页面 B 的 popViewControllerAnimated: 页面 A 的 viewWillAppear: 页面 A 的 viewDidAppear: 在 pop 过程的开始，转场库会在页面 B 自身的 view 上添加一个与导航栏一模一样的 NavigationBar 并将真的导航栏隐藏，虽然这个假的导航栏会一直存在于页面 B 上，但它自身会随着页面 B 的 dealloc 而消亡。 等到页面 A 调用 viewWillAppear: 的时候，开发者在这里自行设置真的导航栏样式。当然我们也可以不设置，因为这时候页面 A 还持有一个假的导航栏，这里还保留着我们之前在 viewDidLoad 里写的导航栏样式。 等到页面 A 调用 viewDidAppear: 的时候，转场库会将假的导航栏样式设置到真的导航栏中，并将假的导航栏从视图层级中移除，最终将真的导航栏显示出来。 同样，我们可以参考下面的图来理解上面所说的内容： 现在，大家应该对我们美团的解决方案有了一定的认识，但在实际开发过程中，还需要考虑一些布局和适配的问题。 最佳实践 在维护这套转场方案的时间里，我们总结了一些此类方案的最佳实践。 判断导航栏问题的基本准则 如果发现导航栏在转场过程中出现了样式错乱，可以遵循以下几点基本原则： 检查相应 ViewController 里是否有修改其他 ViewController 导航栏样式的行为，如果有，请做调整。 保证所有对导航栏样式变化的操作出现在 viewDidLoad 和 viewWillAppear: 中，如果在 viewWillDisappear: 等方法里出现了对导航栏的样式修改的操作，如果有，请做调整。 检查是否有改动 translucent 属性，包括显示修改和隐式修改，如果有，请做调整。 只关心当前页面的样式 永远记住每个 ViewController 只用关心自己的样式，设置的时机点在 viewWillAppear: 或者 viewDidLoad 里。 透明样式导航栏的正确设置方法 如果需要一个透明效果的导航栏，可以使用如下代码实现： [self.navigationController.navigationBar&nbsp;setBackgroundImage:[UIImage&nbsp;new]&nbsp;forBarMetrics:UIBarMetricsDefault];self.navigationController.navigationBar.shadowImage&nbsp;=&nbsp;[UIImage&nbsp;new];&nbsp; 导航栏的颜色渐变效果 如果需要导航栏实现随滚动改变整体 alpha 值的效果，可以通过改变 setBackgroundImage:forBarMetrics: 方法里 image 的 alpha 值来达到目标，这里一般是使用监听 scrollView.contentOffset 的手段来做。请避免直接修改 NavigationBar 的 alpha 值。 如果发现这种方式会引起严重的性能问题，可以尝试使用如下的方式进行修改，但不推荐，主要原因是通过读取数组内容的方式来获取视图实例既不优雅，也不安全。 UIView&nbsp;*background&nbsp;=&nbsp;self.navigationController.navigationBar.subviews.firstObject;background.alpha&nbsp;=&nbsp;MIN(self.contentOffsetY&nbsp;/&nbsp;100.0,&nbsp;1); 还有一点需要注意的是，在页面转场的过程中，也会触发 contentOffset 的变化，所以请尽量在 disappear 的时候取消监听。否则会容易出现导航栏透明度的变化。 导航栏背景图片的规范 请避免背景图里的像素点没有 alpha 通道或者 alpha 全部等于 1，容易触发 translucent 的隐式改变。 如果真的要隐藏导航栏 如果我们需要隐藏导航栏，请保证所有的 ViewController 能坚持如下原则： 每个 ViewController 只需要关心当前页面下的导航栏是否被隐藏。 在 viewWillAppear: 中，统一设置导航栏的隐藏状态。 使用 setNavigationBarHidden:animated: 方法，而不是 setNavigationBarHidden:。 转场动画与导航栏隐藏动画的一致性 如果在转场的过程中还会显示或者隐藏导航栏的话，请保证两个方法的动画参数一致。 -&nbsp;(void)viewWillAppear:(BOOL)animated{&nbsp;&nbsp;&nbsp;&nbsp;[self.navigationController&nbsp;setNavigationBarHidden:YES&nbsp;animated:animated];} viewWillAppear: 里的 animated 参数是受 push 和 pop 方法里 animated 参数影响。 导航栏固有的系统问题 目前已知的有两个系统问题如下： 当前后两个 ViewController 的导航栏都处于隐藏状态，然后在后一个 ViewController 中使用返回手势 pop 到一半时取消，再连续 push 多个页面时会造成导航栏的 Stack 混乱或者 Crash。 当页面的层级结构大体如下所示时，在红色导航栏的 Stack 中，返回手势会大概率的出现跨层级的跳转，多次后会导致整个导航栏的 Stack 错乱或者 Crash。 导航栏内置组件的布局规范 导航栏里的组件布局在 iOS 11 后发生了改变，原有的一些解决方案已经失效，这些内容不在本篇文章的讨论范围之内，推荐阅读UIBarButtonItem 在 iOS 11 上的改变及应对方案，这篇文章详细的解释了 iOS 11 里的变化和可行的应对方案。 总结 本文涉及内容较多，从 iOS 系统下的导航栏概念到大型应用里的最佳实践，这里我们总结一下整篇文章的核心内容： 理解导航栏组件的结构和相关方法的生命周期。 导航栏组件的结构留有 MVC 架构的影子，在解决问题时，要去相应的层级处理。 转场问题的关键点是方法的调用顺序，所以了解生命周期是解决此类问题的基础。 状态管理，转换时机和样式变化是导航栏里常见问题的三种表现形式，遇到实际问题时需要区分清楚。 状态管理要坚持“谁修改，谁复原”的原则。 转换时机的设定要做到连续可执行。 样式变化的核心点是导航栏的显示与否与颜色变化。 为了更好的配合大型应用里的路由系统，导航栏转场的常见解决方案有三种，各有利弊，需要根据自身的业务场景和历史包袱做取舍。 解决方案1：自定义导航栏组件。 解决方案2：在原有导航栏组件里添加 Fake Bar。 解决方案3：在导航栏转场过程中添加 Fake Bar。 美团在实际开发过程中采用了第三种方案，并给出了适合美团 App 的最佳实践。 参考链接 UIAppearance Tutorial: Getting Started KMNavigationBarTransition 特别感谢莫洲骐在此项目中做出的贡献与付出。 作者简介 思琦，美团点评 iOS 工程师。2016 年加入美团，负责美团平台的业务开发及 UI 组件的维护工作。 扫码加入美团iOS技术交流群，跟作者零距离交流。如群已满，请加美美同学的微信（微信号：MTDPtech01），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 美团平台诚招 iOS、Android、FE 高级/资深工程师和技术专家，Base 北京、上海、成都，欢迎有兴趣的同学投递简历到zhangsiqi04@meituan.com。&nbsp; 也许你还想看 美团外卖iOS多端复用的推动、支撑与思考 基于 KIF 的 iOS UI 自动化测试和持续集成 ARKit：增强现实技术在美团到餐业务的实践","@type":"BlogPosting","url":"/2019/04/29/729153.html","headline":"iOS系统中导航栏的转场解决方案与最佳实践","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/29/729153.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>iOS系统中导航栏的转场解决方案与最佳实践</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;" data-mpa-powered-by="yiban.io"><img class="" data-copyright="0" data-ratio="0.10546875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png" data-type="png" data-w="1280" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">总第294篇</span></strong></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><strong><span style="color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;">2018年 第86篇</span></strong></p> 
<p style="white-space: normal;text-align: left;margin-left: 0.5em;margin-right: 0.5em;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">前言</span></strong><br></p> 
<section class="output_wrapper" style="margin-left: 0.5em;margin-right: 0.5em;"> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">目前，开源社区和业界内已经存在一些 iOS 导航栏转场的解决方案，但对于历史包袱沉重的美团 App 而言，这些解决方案并不完美。有的方案不能满足复杂的页面跳转场景，有的方案迁移成本较大，为此我们提出了一套解决方案并开发了相应的转场库，目前该转场库已经成为美团点评多个 App 的基础组件之一。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在美团 App 开发的早期，涉及到导航栏样式改变的需求时，经常会遇到转场效果不佳或者与预期样式不符的“小问题”。在业务体量较小的情况下，为了满足快速的业务迭代，通常会使用硬编码的方式来解决这一类“小问题”。但随着美团 App 业务的高速发展，这种硬编码的方式遇到了以下的挑战：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">业务模块的不断增加，导致使用硬编码方式编写的代码维护成本增加，代码质量迅速下降。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">大型 App 的路由系统使得页面间的跳转变得更加自由和灵活，也使得导航栏相关的问题激增，不但增加了问题的排查难度，还降低了整体的开发效率。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">App 中的导航栏属于各个业务方的公用资源，由于缺乏相应的约束机制和最佳实践，导致业务方之间的代码耦合程度不断增加。</span></p></li> 
 </ol> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">从各个角度来看，硬编码的方式已经不能很好的解决此类问题，美团 App 需要一个更加合理、更加持久、更加简单易行的解决方案来处理导航栏转场问题。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">本文将从导航栏的概念入手，通过讲解转场过程中的状态管理、转换时机和样式变化等内容，引出了在大型应用中导航栏转场的三种常见解决方案，并对美团的解决方案进行剖析，</span><span style="">同时介绍了我们总结的最佳实践。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">重新认识导航栏</span></strong></p> 
 <h3><span style="font-size: 18px;"><strong><span style="color: inherit;line-height: inherit;">导航栏里的 MVC</span></strong></span></h3> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在 iOS 系统中， 苹果公司不仅建议开发者遵循 MVC 开发框架，在他们的代码里也可以看到 MVC 的影子，导航栏组件的构成就是一个类似 MVC 的结构，让我们先看看下面这张图：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.7256894049346879" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpkzxNRZS3icMASdqtEmZ3qYUz07F3CthUtaV4ibqCHO8pC4IqrlCmBSag/640?wx_fmt=png" data-type="png" data-w="1378" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpkzxNRZS3icMASdqtEmZ3qYUz07F3CthUtaV4ibqCHO8pC4IqrlCmBSag/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在这张图里，我们可以将 UINavigationController 看做是 C，UINavigationBar 看做是 V，而 UIViewController 和 UINavigationItem 组成的 Stack 可以看做是 M。这里要说明的是，每个 UIViewController 都有一个属于自己的 UINavigationItem，也就是说它们是一一对应的。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">UINavigationController 通过驱动 Stack 中的 UIViewController 的变化来实现 View 层级的变化，也就是 UINavigationBar 的改变。而 UINavigationBar 样式的数据就存储在 UIViewController 的 UINavigationItem 中。这也就是为什么我们在代码里只要设置 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">self.navigationItem</span></code><span style="font-size: 15px;"> 的相关属性就可以改变 UINavigationBar 的样式。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">很多时候，国内的开发者会将 UINavigationBar 和 UINavigationController 混在一起叫导航栏，这样的做法不仅增加了开发者之间的沟通成本，也容易导致误解。毕竟它们是两个完全不一样的东西。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">所以本文为了更好的阐明问题，会采用英文区分不同的概念，当需要描述笼统的导航栏概念时，会使用导航栏组件一词。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过这一节的回顾，我们应该明确了 NavigationItem、ViewController、NavigationBar 和 NavigationController 在 MVC 框架下的角色。下面我们会重新梳理一下导航栏的生命周期和各个相关方法的调用顺序。</span></p> 
 <h3><span style="font-size: 18px;"><strong>导航栏组件的生命周期</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">大家可以通过下图获得更为直观的感受，进而了解到导航栏组件在 push 过程中各个方法的调用顺序。</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.7091212458286985" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpdkIF8zg1OJXv8POtiaBESwicYXExN8P3oNvJLksv8OwvDT6tXMX03MkA/640?wx_fmt=png" data-type="png" data-w="1798" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpdkIF8zg1OJXv8POtiaBESwicYXExN8P3oNvJLksv8OwvDT6tXMX03MkA/640?wx_fmt=png"></p> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">值得注意的地方有两点：</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">第一个是 UINavigationController 作为 UINavigationBar 的代理，在没有特殊需求的情况下，不应该修改其代理方法，这里是通过符号断点获取它们的调用顺序。如果我们创建了一个自定义的导航栏组件系统，它的调用顺序可能会与此不同。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">第二个是用虚线圈起来的方法，它们也有可能不被调用，这与 ViewController 里的布局代码相关，假设跳转到新页面后，新旧页面中的控件位置会发生变化，或者由于数据改变驱动了控件之间的约束关系发生变化，这就会带来新一轮的布局，进而触发 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillLayoutSubview</span></code><span style="font-size: 15px;"> 和 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidLayoutSubview</span></code><span style="font-size: 15px;"> 这两个方法。当然，具体的调用顺序会与业务代码紧密相关，如果我们发现顺序有所不同，也不必惊慌。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">下面这张图展示了导航栏在 pop 过程中各个方法的调用顺序：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.71796875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpfichic7nqYfkdibWgKoqYfsxFL3ibqugqGGjicD5HYCnGz5fBPibgH1D6WicA/640?wx_fmt=png" data-type="png" data-w="1280" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpfichic7nqYfkdibWgKoqYfsxFL3ibqugqGGjicD5HYCnGz5fBPibgH1D6WicA/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">除了上面说到的两点，pop 过程中还需要注意一点，那就是从 B 返回到 A 的过程中，A 视图控制器的 viewDidLoad 方法并不会被调用。关于这个问题，只要提醒一下，大多数人都会反应过来是为什么。不过在实际开发过程中，总会有人忘记这一点。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过这两个图，我们已经基本了解了导航栏组件的生命周期和相关方法的调用顺序，这也是后面章节的理论基础。</span></p> 
 <h3><span style="font-size: 18px;"><strong>导航栏组件的改变与革新</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">导航栏组件在 iOS 11 发布时，获得了重大更新，这个更新可不是增加了一个大标题样式（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">Large Title Display Mode</span><span style="font-size: 15px;">）那么简单，需要注意的地方大概有两点：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">导航栏全面支持 Auto Layout 且 NavigationBar 的层级发生了明显的改变，关于这一点可以阅读 </span><a href="http://sketchk.xyz/2018/02/23/How-to-make-your-UIBarButtonItem-perfect-match-in-iOS/" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">UIBarButtonItem 在 iOS 11 上的改变及应对方案</span></a><span style="font-size: 15px;"> 。</span></p></li> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">由于引进了 Safe Area 等概念，topLayoutGuide 和 bottomLayoutGuide 等属性会逐渐废弃，虽然变化不大，但如果我们的导航栏在转场过程中总是出现视图上下移动的现象，不妨从这个方面思考一下，如果想深究可以查看 </span><a href="https://developer.apple.com/videos/play/wwdc2017/412/" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">WWDC 2017 Session 412</span></a><span style="font-size: 15px;">。</span></p></li> 
 </ol> 
 <h2><strong style="color: rgb(51, 51, 51);font-size: 20px;white-space: normal;"><span style="color: rgb(49, 188, 173);">导航栏组件到底怎么了？</span></strong></h2> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">经常有人说 iOS 的原生导航栏组件不好使用，抱怨主要集中在导航栏组件的状态管理和控件的布局问题上。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">控件的布局问题随着 iOS 11 的到来已经变得相对容易处理了不少，但导航栏组件的状态管理仍然让开发者头疼不已。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">可能已经有朋友在思考导航栏组件的状态管理到底是什么东西？不要着急，下面的章节就会做相关的介绍。</span></p> 
 <h3><span style="font-size: 18px;"><strong>导航栏的状态管理</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">虽然导航栏组件的 push 和 pop 动画给人一种每次操作后都会创建一遍导航栏组件的错觉，但实际上这些 ViewController 都是由一个 NavigationController 所管理，所以你看到的 NavigationBar 是唯一的。</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.5578876100203114" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpk06WUcnvbyTC2NZADnbH9T6vlpnAUJ2dTnhMmMg2fpF6mnRvuCV5cQ/640?wx_fmt=png" data-type="png" data-w="1477" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpk06WUcnvbyTC2NZADnbH9T6vlpnAUJ2dTnhMmMg2fpF6mnRvuCV5cQ/640?wx_fmt=png"></p> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在 NavigationController 的 Stack 存储结构下，每当 Stack 中的 ViewController 修改了导航栏，势必会影响其他 ViewController 展示的效果。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">例如下图所示的场景，如果 NavigationBar 原先的颜色是绿色，但之后进入 Stack 里的 ViewController 将 NavigationBar 颜色修改为紫色后，在此之后 push 的 ViewController 会从默认的绿色变为紫色，直到有新的 ViewController 修改导航栏颜色才会发生变化。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.2687574434299325" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficp5ibB6fwvMrFNGAB20LbaacJHzcPRq2kmYYTk56L8HibibgsH0tbjmeP3Q/640?wx_fmt=png" data-type="png" data-w="2519" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficp5ibB6fwvMrFNGAB20LbaacJHzcPRq2kmYYTk56L8HibibgsH0tbjmeP3Q/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">虽然在 push 过程中，NavigationBar 的变化听起来合情合理，但如果你在 NavigationBar 为绿色的 ViewController 里设置不当的话，那么当你 pop 回这个 ViewController 时，NavigationBar 可就不一定是绿色了，它还会保持为紫色的状态。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.2687574434299325" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficphy8Mfs3d691fWKjDqgia4Fhm7Za7QicJC8hrd5y2eiamsCV4QKo10eicUQ/640?wx_fmt=png" data-type="png" data-w="2519" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficphy8Mfs3d691fWKjDqgia4Fhm7Za7QicJC8hrd5y2eiamsCV4QKo10eicUQ/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通过这个例子，我们大概会意识到在导航栏里的 Stack 中，每个 ViewController 都可以永久的影响导航栏样式，这种全局性的变化要求我们在实际开发中必须坚持“谁修改，谁复原”的原则，否则就会造成导航栏状态的混乱。这不仅仅是样式上的混乱，在一些极端状况下，还有可能会引起 Stack 混乱，进而造成 Crash 的情况。</span></p> 
 <h3><span style="font-size: 18px;"><strong>导航栏样式转换的时机</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">我们刚才提到了“谁修改，谁复原”的原则，但何时修改，何时复原呢？</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于那些存储在 Stack 中的 ViewController 而言，它其实就是在不断的经历 appear 和 disappear 的过程，结合 ViewController 的生命周期来看，</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 和 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillDisappear:</span></code><span style="font-size: 15px;"> 是两个完美的时间节点，但很多人却对这两个方法的调用存在疑惑。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">苹果公司在它的 API 文档中专门用了一段文字来解答大家的疑惑，这段文字的标题为《Handling View-Related Notifications》，在这里我们直接引用原文：</span></p> 
 <blockquote style="line-height: inherit;padding: 15px 15px 15px 1rem;font-size: 0.9em;margin-top: 1em;margin-bottom: 1em;color: rgb(129, 145, 152);border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);overflow: auto;overflow-wrap: normal;"> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">When the visibility of its views changes, a view controller automatically calls its own methods so that subclasses can respond to the change. Use a method like viewWillAppear: to prepare your views to appear onscreen, and use the viewWillDisappear: to save changes or other state information. Use other methods to make appropriate changes.<br>Figure 1 shows the possible visible states for a view controller’s views and the state transitions that can occur. Not all ‘will’ callback methods are paired with only a ‘did’ callback method. You need to ensure that if you start a process in a ‘will’ callback method, you end the process in both the corresponding ‘did’ and the opposite ‘will’ callback method.</span></p> 
 </blockquote> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.947027027027027" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpBDrPZWWSBQ5890EzkYDCicVT9TOqicJaBqeArp8A8KwSICk7K3sZeCbA/640?wx_fmt=jpeg" data-type="jpeg" data-w="925" style="width: 406px;height: 384px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpBDrPZWWSBQ5890EzkYDCicVT9TOqicJaBqeArp8A8KwSICk7K3sZeCbA/640?wx_fmt=jpeg"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这里很好的解释了所有的 will 系列方法和 did 系列方法的对应关系，同时也给我们吃了一个定心丸，那就是在 appearing 和 disappearing 状态之间会由 will 系列方法进行衔接，避免了状态中断。这对于连续 push 或者连续 pop 的情况是及其重要的，否则我们无法做到 “谁修改，谁复原”的原则。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通常来说，如果只是一个简单的导航栏样式变化，我们的代码结构大体会如下所示：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">-&nbsp;(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">void</span>)viewWillAppear:(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">BOOL</span>)animated{<br>&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">super</span>&nbsp;viewWillAppear:animated];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;MARK:&nbsp;change&nbsp;the&nbsp;navigationbar&nbsp;style&nbsp;</span><br>}<br><br>-&nbsp;(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">void</span>)viewWillDisappear:(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">BOOL</span>)animated{<br>&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">super</span>&nbsp;viewWillDisappear:animated];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;MARK:&nbsp;restore&nbsp;the&nbsp;navigationbar&nbsp;style</span><br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">现在，我们明确了修改时机，接下来要明确的就是导航栏的样式会进行怎样的变化。</span></p> 
 <h3><span style="font-size: 18px;"><strong>导航栏的样式变化</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">对于不同 ViewController 之间的导航栏样式变化，大多可以总结为两种情况：</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">导航栏的显示与否</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">导航栏的颜色变化</span></p></li> 
 </ol> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">导航栏的显示与否</span></h4> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于显示与否的问题，可以在上一节提到的两个方法里调用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setNavigationBarHidden:animated:</span></code><span style="font-size: 15px;"> 方法，这里需要提醒的有两点：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;">在导航栏转场的过程中，不要天真的以为 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setNavigationBarHidden:</span></code><span style="font-size: 15px;"> 和 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setNavigationBarHidden:animated:</span></code><span style="font-size: 15px;"> 的效果是一样的，直接使用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setNavigationBarHidden:</span></code><span style="font-size: 15px;"> 会造成导航栏转场过程中的闪现、背景错乱等问题，这一现象在使用手势驱动转场的场景中十分常见，所以正确的方式是使用带有 animated 参数的 API。</span></p></li> 
  <li><p><span style="font-size: 15px;">在 push 和 pop 的方法里也会带有 animated 参数，尽量保证与 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setNavigationBarHidden:animated:</span></code><span style="font-size: 15px;"> 中的 animated 参数一致。</span></p></li> 
 </ol> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">导航栏的颜色变化</span></h4> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">颜色变化的问题就稍微复杂一些，在 iOS 7 后，导航栏增加了 translucent 效果，这使得导航栏背景色的变化出现了两种情况：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">translucent 属性值为 YES 的前提下，更改导航栏的背景色。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">translucent 属性值为 NO 的前提下，更改导航栏的背景色。</span></p></li> 
 </ol> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于第一种情况，我们需要调用 UINavigationBar 的 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setBackgroundColor:</span></code><span style="font-size: 15px;"> 方法。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于第二种情况我们需要调用 UINavigationBar 的 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setBackgroundImage:forBarMetrics:</span></code><span style="font-size: 15px;"> 方法。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于第二种情况，这里有三点需要提示：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;">在设置透明效果时，我们通常可以直接设置一个 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">[UIImage new]</span></code><span style="font-size: 15px;"> 创建的对象，无须创建一个颜色为透明色的图片。</span></p></li> 
  <li><p><span style="font-size: 15px;">在使用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setBackgroundImage:forBarMetrics:</span></code><span style="font-size: 15px;"> 方法的过程中，如果图像里存在 alpha 值小于 1.0 的像素点，则 translucent 的值为 YES，反之为 NO。也就是说，如果我们真的想让导航栏变成纯色且没有 translucent 效果，请保证所有像素点的 alpha 值等于 1。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">如果设置了一个完全不透明的图片且强行将 NavigationBar 的 translucent 属性设置为 YES 的话，系统会自动修正这个图片并为它添加一个透明度，用于模拟 translucent 效果。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">如果我们使用了一个带有透明效果的图片且导航栏的 translucent 效果为 NO 的话，那么系统会在这个带有透明效果的图片背后，添加一个不透明的纯色图片用于整体效果的合成。这个纯色图片的颜色取决于 barStyle 属性，当属性为 UIBarStyleBlack 时为黑色，当属性为 UIBarStyleDefault 时为白色，如果我们设置了 barTintColor，则以设置的颜色为基准。</span></p></li> 
 </ol> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">分清楚 transparent，translucent，opaque，alpha 和 opacity 也挺重要</span></h4> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在刚接触导航栏 API 时，许多人经常会把文档里的这些英文词搞混，也不太明白带有这些词的变量为什么有的是布尔型，有的是浮点型，总之一切都让人很困惑。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在这里将做了一个总结，这对于理解 Apple 的 API 设计原则十分有帮助。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">transparent， translucent， opaque 三个词经常会用在一起，它用于描述物体的透光强度，为了让大家更好的理解这三个词，这里做了三个比喻：</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">transparent 是指透明，就好比我们可以透过一面干净的玻璃清楚的看到外面的风景。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">translucent 是指半透明，就好比我们可以透过一面有点磨砂效果的塑料墙看外面的风景，不能说看不见，但我们肯定看不清。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">opaque 是指不透明，就好比我们透过一个堵石墙是看不见任何外面的东西，眼前看到的只有这面墙。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这三个词更多的是用来表述一种状态，不需要量化，所以这与这三个词相关的属性，一般都是 BOOL 类型。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.26278069756330624" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpaPHiczqjrMLeqXjQ47Mj55AXsgJMPKZzxhic3icNX3AcVzKDZhh5tL3cQ/640?wx_fmt=png" data-type="png" data-w="2093" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpaPHiczqjrMLeqXjQ47Mj55AXsgJMPKZzxhic3icNX3AcVzKDZhh5tL3cQ/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">alpha 和 opacity 经常会在一起使用，它要表示的就是透明度，在 Web 端这两个属性有着明显的区别。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在 Web 端里，opacity 是设定整个元素的透明值，而 alpha 一般是放在颜色设置里面，所以我们可以做到对特定对元素的某个属性设定 alpha，比如背景、边框、文字等。</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="css language-css hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">div</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">width</span>:&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">100px</span>;<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">height</span>:&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">100px</span>;<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">background</span>:&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">rgba</span>(0,0,0,0.5);<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">border</span>:&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1px</span>&nbsp;solid&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">#000000</span>;<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">opacity</span>:&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0.5</span>;<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这一概念同样适用于 iOS 里的概念，比如我们可以通过 alpha 通道单独的去设置 backgroudColor、borderColor，它们互不影响，且有着独立的 alpha 通道，我们也可以通过 opacity 统一设置整个 view 的透明度。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">但与 Web 端不一致的是，iOS 里面的 view 不光拥有独立的 alpha 属性，同时也是基于 CALayer，所以我们可以看到任意 UIView 对象下面都会有一个 layer 的属性，用于表明 CALayer 对象。view 的 alpha 属性与 layer 里面的 opacity 属性是一个相等的关系，需要注意的是 view 上的 alpha 属性是 Web 端并不具备的一个能力，所以笔者认为：在 iOS 中去说 alpha 时，要区分是在说 view 上的属性，还是在说颜色通道里的 alpha。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">由于这两个词都是在描述程度，所以我们看到它们都是 CGFloat 类型：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.3047819232790331" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpxx190oz9pFyBtj9F5ib6GQCjweAWGJ8mpDU1jUUgmSF8jeBYj3aJzibQ/640?wx_fmt=png" data-type="png" data-w="1903" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpxx190oz9pFyBtj9F5ib6GQCjweAWGJ8mpDU1jUUgmSF8jeBYj3aJzibQ/640?wx_fmt=png"></p> 
 <p style="text-align: center;"><br></p> 
 <h3><span style="font-size: 18px;"><strong>转场过程中需要注意的问题和细节</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">说完了导航栏的转场时机和转场方式，其实大体上你已经能处理好不同样式间的转换，但还有一些细节需要你去考虑，下面我们来说说其中需要你关注的两点。</span></p> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">translucent 属性带来的布局改变</span></h4> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">translucent 会影响导航栏组件里 ViewController 的 View 布局，这里需要大家理清 5 个 API 的使用场景：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">edgesForExtendedLayout</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">extendedLayoutIncluedsOpaqueBars</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">automaticallyAdjustScrollViewInsets</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">contentInsetAdjustmentBehavior</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">additionalSafeAreaInsets</span></p></li> 
 </ol> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">前三个 API 是 iOS 11 之前的 API，它们之间的区别和联系在 Stack Overflow 上有一个比较精彩的回答 - </span><a href="https://stackoverflow.com/questions/18798792/explaining-difference-between-automaticallyadjustsscrollviewinsets-extendedlayo" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">Explaining difference between automaticallyAdjustsScrollViewInsets, extendedLayoutIncludesOpaqueBars, edgesForExtendedLayout in iOS7</span></a><span style="font-size: 15px;">，我在这里就不做详细阐述，总结一下它的观点就是:</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如果我们先定义一个 UINavigationController，它里面包含了多个 UIViewController，每个 UIViewController 里面包含一个 UIView 对象：</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">那么 edgesForExtendedLayout 是为了解决 UIViewController 与 UINavigationController 的对齐问题，它会影响 UIViewController 的实际大小，例如 edgesForExtendedLayout 的值为 UIRectEdgeAll 时，UIViewController 会占据整个屏幕的大小。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">当 UIView 是一个 UIScrollView 类或者子类时，automaticallyAdjustsScrollViewInsets 是为了调整这个 UIScrollView 与 UINavigationController 的对齐问题，这个属性并不会调整 &nbsp;UIViewController 的大小。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">对于 UIView 是一个 UIScrollView 类或者子类且导航栏的背景色是不透明的状态时，我们会发现使用 edgesForExtendedLayout 来调整 UIViewController 的大小是无效的，这时候你必须使用 extendedLayoutIncludesOpaqueBars 来调整 UIViewController 的大小，可以认为 extendedLayoutIncludesOpaqueBars 是基于 automaticallyAdjustsScrollViewInsets 诞生的，这也是为什么经常会看到这两个 API 会同时使用。</span></p></li> 
 </ul> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这些调整布局的 API 背后是一套基于 topLayoutGuide 和 bottomLayoutGuide 的计算而已，在 iOS 11 后，Apple 提出了 Safe Area 的概念，将原先分裂开来的 topLayoutGuide 和 bottomLayoutGuide 整合到一个统一的 LayoutGuide 中，也就是所谓的 Safe Area，这个改变看起来似乎不是很大，但它的出现确实方便了开发者。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.6903114186851211" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpP4eeaFyib9BkY6FcWxspUPod1CukJFPRic2G0uQ11zrTkNsfBK4RlvtA/640?wx_fmt=jpeg" data-type="jpeg" data-w="1156" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpP4eeaFyib9BkY6FcWxspUPod1CukJFPRic2G0uQ11zrTkNsfBK4RlvtA/640?wx_fmt=jpeg"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如果想对 Safe Area 带来的改变有更全面的认识，十分推荐阅读 Rosberry 的工程师 Evgeny Mikhaylov 在 Medium 上的文章 </span><a href="https://medium.com/rosberryapps/ios-safe-area-ca10e919526f" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">iOS Safe Area</span></a><span style="font-size: 15px;">，这篇文章基本涵盖了 iOS 11 中所有与 Safe Area 相关的 API 并给出了真正合理的解释。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这里只说一下 contentInsetAdjustmentBehavior 和 additionalSafeAreaInsets 两个 API。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于 contentInsetAdjustmentBehavior 属性而言，它的诞生也意味着 automaticallyAdjustsScrollViewInsets 属性的失效，所以我们在那些已经适配了 iOS 11 的工程里能看到如下类似的代码：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;(@available(iOS&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">11.0</span>,&nbsp;*))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>.tableView.contentInsetAdjustmentBehavior&nbsp;=&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">UIScrollViewContentInsetAdjustmentNever</span>;<br>}&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>.automaticallyAdjustsScrollViewInsets&nbsp;=&nbsp;<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">NO</span>;<br>}<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">此处的代码片段只是一个示例，并不适用所有的业务场景，这里需要着重说明几个问题：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">关于 contentInsetAdjustmentBehavior 中的 UIScrollViewContentInsetAdjustmentAutomatic 的说明一直很“模糊”，通过 Evgeny Mikhaylov 的文章，我们可以了解到它在大多数情况下会与 UIScrollViewContentInsetAdjustmentScrollableAxes 一致，当且仅当满足以下所有条件时才会与 UIScrollViewContentInsetAdjustmentAlways 相似：</span></p></li> 
  <ul style="list-style-type: disc;" class=" list-paddingleft-2"> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">UIScroller 类型的视图在水平轴方向是可滚动的，垂直轴是不可滚动的。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">ViewController 视图里的第一个子控件是 UIScrollView 类型的视图。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">ViewController 是 navigation 或者 tab 类型控制器的子视图控制器。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">启用 automaticallyAdjustsScrollViewInsets。 </span></p></li> 
  </ul> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">iOS 11 后，通过 contentInset 属性获取的偏移量与 iOS 10 之前的表现形式并不一致，需要获取 adjustedContentInset 属性才能保证与之前的 contentInset 属性一致，这样的改变需要我们在代码里对不同的版本进行适配。</span></p></li> 
 </ol> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于 additionalSafeAreaInsets 而言，如果系统提供的这几种行为并不能满足我们的布局要求，开发者还可以考虑使用 additionalSafeAreaInsets 属性做调整，这样的设定使得开发者可以更加灵活，更加自由的调整视图的布局。</span></p> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">backIndicator 上的动画</span></h4> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">苹果提供了许多修改导航栏组件样式的 API，有关于布局的，有关于样式的，也有关于动画的。backIndicatorImage 和 backIndicatorTransitionMaskImage 就是其中的两个 API。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">backIndicatorImage 和 backIndicatorTransitionMaskImage 操作的是 NavigationBar 里返回按钮的图片，也就是下图红色圆圈所标注的区域。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.6906077348066298" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpYk1b0bkJChov6NdFytup0MzGgvQCENKswojLIMI3sOKb0zaNl4oSSw/640?wx_fmt=png" data-type="png" data-w="724" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpYk1b0bkJChov6NdFytup0MzGgvQCENKswojLIMI3sOKb0zaNl4oSSw/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">想要成功的自定义返回按钮的图标样式，我们需要同时设置这两个 API ，从字面上来看，它们一个是返回图片本身，另一个是返回图片在转场时用到的 mask 图片，看起来不怎么难，我们写一段代码试试效果：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>.navigationController.navigationBar.backIndicatorImage&nbsp;=&nbsp;[<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">UIImage</span>&nbsp;imageNamed:<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">@"backArrow"</span>];<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>.navigationController.navigationBar.backIndicatorTransitionMaskImage&nbsp;=&nbsp;[<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">UIImage</span>&nbsp;imageNamed:<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">@"backArrowMask"</span>];<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">代码里的图片如下所示：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.384375" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpCVK7QMkFpleMiaKc1V64YqpEgbInjNicYF1fNlibkCx7BhQA5aNTBrJQg/640?wx_fmt=png" data-type="png" data-w="320" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpCVK7QMkFpleMiaKc1V64YqpEgbInjNicYF1fNlibkCx7BhQA5aNTBrJQg/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">也许大多数人在这里会都认为，mask 图片会遮挡住文字使其在遇到返回按钮右边缘的时候就消失。但实际的运行效果是怎么样子的呢？我们来看一下：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_gif/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpicXFuQZvdydMibccpuFicE8gTbtaomR4kfcCOmkC65AjbMvqatXpRKwyA/640?wx_fmt=gif" data-type="gif" data-w="100" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpicXFuQZvdydMibccpuFicE8gTbtaomR4kfcCOmkC65AjbMvqatXpRKwyA/640?wx_fmt=gif"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在上面的图片中，我们可以看到返回按钮的文字从返回按钮的图片下面穿过并且文字被图片所遮挡，这种动画看起来十分奇怪，这是无法接受的。我们需要做点修改：</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>.navigationController.navigationBar.backIndicatorImage&nbsp;=&nbsp;[<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">UIImage</span>&nbsp;imageNamed:<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">@"backArrow"</span>];<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>.navigationController.navigationBar.backIndicatorTransitionMaskImage&nbsp;=&nbsp;[<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">UIImage</span>&nbsp;imageNamed:<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">@"backArrow"</span>];<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这一次我们将 backIndicatorTransitionMaskImage 改为 indicatorImage 所用的图片。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1.0081967213114753" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpcx3P6Gnn055fRMtVnYHgMdibicrxPQbKfAVC9fqweDRHw3G4ug0r6mDA/640?wx_fmt=png" data-type="png" data-w="122" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpcx3P6Gnn055fRMtVnYHgMdibicrxPQbKfAVC9fqweDRHw3G4ug0r6mDA/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">到这里，可能大多数人都会好奇，这代码也能行？让我们看下它实际的效果：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_gif/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpZzFb9HfZprqtnIWOp3RibyvRf6l22OwjFCJKNFjedc7XZXmTztKKYZA/640?wx_fmt=gif" data-type="gif" data-w="100" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpZzFb9HfZprqtnIWOp3RibyvRf6l22OwjFCJKNFjedc7XZXmTztKKYZA/640?wx_fmt=gif"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在上面的图中，我们看到文字在到达图片的右边缘时就从下方穿过并被完全遮盖住了，这种动画效果虽然比上面好一些，但仍然有改进的空间，不过这里我们先不继续优化了，我们先来讨论一下它们背后的运作原理。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">iOS 系统会将 indicatorImage 中不透明的颜色绘制成返回按钮的图标， indicatorTransitionMaskImage 与 indicatorImage 的作用不同。indicatorTransitionMaskImage 将自身不透明的区域像 mask 一样作用在 indicatorImage 上，这样就保证了返回按钮中的文字像左移动时，文字只出现在被 mask 的区域，也就是 indicatorTransitionMaskImage 中不透明的区域。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">掌握了原理，我们来解释下刚才的两种现象：</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在第一种实现中，我们提供的 indicatorTransitionMaskImage 覆盖了整个返回按钮的图标，所以我们在转场过程中可以清晰的看到返回按钮的文字。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在第二种实现中，我们使用 indicatorImage 作为 indicatorTransitionMaskImage，记住文字是只能出现在 indicatorTransitionMaskImage 里不透明的区域，所以显然返回按钮中的文字会在图标的最右边就已经被遮挡住了，因为那片区域是透明的。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">那么前面提到的进一步优化指的是什么呢？</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">让我们来看一下下面这个示例图，为了更好的区分，我们将 indicatorTransitionMaskImage 用红色进行标注。黑色仍然是 indicatorImage。</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpSn5U96yNMlOYJkeBUMRKiaI2fP6T9fCr8Ryvugibbib5ibYibXElyodtsmg/640?wx_fmt=jpeg" data-type="jpeg" data-w="105" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpSn5U96yNMlOYJkeBUMRKiaI2fP6T9fCr8Ryvugibbib5ibYibXElyodtsmg/640?wx_fmt=jpeg"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">按照刚才介绍的原理，我们应该可以理解，现在文字只会出现在红色区域，那么它的实际效果是什么样子的呢，我们可以看下图：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_gif/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpPD748tgfh6ccQkkrMd0vAbQiaePmgFVXAc7iayXl7Zaia9ibRMGakzEqFw/640?wx_fmt=gif" data-type="gif" data-w="100" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpPD748tgfh6ccQkkrMd0vAbQiaePmgFVXAc7iayXl7Zaia9ibRMGakzEqFw/640?wx_fmt=gif"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">现在，一个完美的返回动画，诞生啦！</span></p> 
 <blockquote style="line-height: inherit;padding: 15px 15px 15px 1rem;font-size: 0.9em;margin-top: 1em;margin-bottom: 1em;color: rgb(129, 145, 152);border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);overflow: auto;overflow-wrap: normal;"> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">此节所用的部分效果图出自 Ray Wenderlich 的文章 </span><a href="https://www.raywenderlich.com/1625-uiappearance-tutorial-getting-started" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">UIAppearance Tutorial: Getting Started</span></a></p> 
 </blockquote> 
 <h2><br></h2> 
 <h2><strong style="color: rgb(51, 51, 51);font-size: 20px;white-space: normal;"><span style="color: rgb(49, 188, 173);">导航栏的跳转或许可以这么玩儿……</span></strong></h2> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">前两章的铺垫就是为了这一章的内容，所以现在让我们开始今天的大餐吧。</span></p> 
 <h3><span style="font-size: 18px;"><strong>这样真的好么？</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">刚才我们说了两个页面间 NavigationBar 的样式变化需要在各自的 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 和 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillDisappear:</span></code><span style="font-size: 15px;"> 中进行设置。那么问题就来了：这样的设置会带来什么问题呢？</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">试想一下，当我们的页面会跳到不同的地方时，我们是不是要在 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 和 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillDisappear:</span></code><span style="font-size: 15px;"> 方法里面写上一堆的判断呢？如果应用里还有 router 系统的话，那么页面间的跳转将变得更加不可预知，这时候又该如何在 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 和 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillDisappear:</span></code><span style="font-size: 15px;"> 里做判断呢？</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">现在我们的问题就来了，如何让导航栏的转场更加灵活且相互独立呢？</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">常见的解决方案如下所示：</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">重新实现一个类似 UINavigationController 的容器类视图管理器，这个容器类视图管理器做好不同 ViewController 间的导航栏样式转换工作，而每个 ViewController 只需要关心自身的样式即可。</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.946969696969697" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpfRfLY5nBVd7WGFh5NTbIbw6IbPKK47HYsOMLWRoGWX4KYkc9hicKLZA/640?wx_fmt=png" data-type="png" data-w="528" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpfRfLY5nBVd7WGFh5NTbIbw6IbPKK47HYsOMLWRoGWX4KYkc9hicKLZA/640?wx_fmt=png"></p> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">将系统原有导航栏的背景设置为透明色，同时在每个 ViewController 上添加一个 View 或者 NavigationBar 来充当我们实际看到的导航栏，每个 ViewController 同样只需要关心自身的样式即可。</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.6142506142506142" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpXEbLIpSe18Maw7iaWlpk2HZfVgCUhgSgTztcIJMGqibialRwm6lAywJpA/640?wx_fmt=png" data-type="png" data-w="814" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpXEbLIpSe18Maw7iaWlpk2HZfVgCUhgSgTztcIJMGqibialRwm6lAywJpA/640?wx_fmt=png"></p> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在转场的过程中隐藏原有的导航栏并添加假的 NavigationBar，当转场结束后删除假的 NavigationBar 并恢复原有的导航栏，这一过程可以通过 Swizzle 的方式完成，而每个 ViewController 只需要关心自身的样式即可。</span></p> 
 <figure style="font-size: inherit;color: inherit;line-height: inherit;"> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.30952380952380953" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpl5IxbkuwIUuiboVkK3gw2EFlGXDZTlicCficwTfyib5iayFtJAGpFibAnXKg/640?wx_fmt=png" data-type="png" data-w="1554" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpl5IxbkuwIUuiboVkK3gw2EFlGXDZTlicCficwTfyib5iayFtJAGpFibAnXKg/640?wx_fmt=png"></p> 
 </figure> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这三种方案各有优劣，我们在网上也可以看到很多关于它们的讨论。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">例如方案一，虽然看起来工作量大且难度高，但是这个工作一旦完成，我们就会将处理导航栏转场的主动权牢牢抓在手里。但这个方案的一个弊端就是，如果苹果修改了导航栏的整体风格，就好比 iOS 11 的大标题特效，那么工作量就来了。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于方案二而言，虽然看起来简单易用，但这需要一个良好的继承关系，如果整个工程里的继承关系混乱或者是历史包袱比较重，后续的维护就像“打补丁”一样，另外这个方案也需要良好的团队代码规范和完善的技术文档来做辅助。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于方案三而言，它不需要所谓的继承关系，使用起来也相对简单，这对于那些继承关系和历史包袱比较重的工程而言，这一个不错的解决方案，但在解决 Bug 的时候，Swizzle 这种方式无疑会增加解决问题的时间成本和学习成本。</span></p> 
 <h3><span style="font-size: 18px;"><strong>我们的解决方案</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">在美团 App 的早期，各个业务方都想充分利用导航栏的能力，但对于导航栏的状态维护缺乏理解与关注，随着业务方的增加和代码量的上升，与导航栏相关的问题逐渐暴露出来，此时我们才意识到这个问题的严重性。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">大型 App 的导航栏问题就像一个典型的“公地悲剧”问题。在软件行业，公用代码的所有权可以被视作“公地”，因为不注重长期需求而容易遭到消耗。如果开发人员倾向于交付“价值”，而以可维护性和可理解性为代价，那么这个问题就特别普遍了。如果是这种情况，每次代码修改将大大减少其总体质量，最终导致软件的不可维护。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">所以解决这个问题的核心在于：明确公用代码的所有权，并在开发期施加约束。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">明确公用代码的所有权，可以理解为将导航栏相关的组件抽离成一个单独的组件，并交由特定的团队维护。而在开发期施加约束，则意味着我们要提供一套完整的解决方案让各个业务方遵守。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这一节我们会以美团内部的解决方案为例，讲解如何实现一个流畅的导航栏跳转过程和相关使用方法。</span></p> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">设计理念</span></h4> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">使用者只用关心当前 ViewController 的 NavigationBar 样式，而不用在 push 或者 pop 的时候去处理 NavigationBar 样式。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">举个例子来说，当从 A 页面 push 到 B 页面的时候，转场库会保存 A 页面的导航栏样式，当 pop 回去后就会还原成以前的样式，因此我们不用考虑 pop 后导航栏样式会改变的情况，同时我们也不必考虑 push 后的情况，因为这个是页面 B 本身需要考虑的。</span></p> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">使用方法</span></h4> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">转场库的使用十分简单，我们不需要 import 任何头文件，因为它在底层通过 Method Swizzling 进行了处理，只需要在使用的时候遵循下面 4 点即可：</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;">当需要改变导航栏样式的时候，在视图控制器的 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidLoad</span></code><span style="font-size: 15px;"> 或者 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 方法里去设置导航栏样式。</span></p></li> 
  <li><p><span style="font-size: 15px;">用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setBackgroundImage:forBarMetrics:</span></code><span style="font-size: 15px;"> 方法和 shadowImage 属性去修改导航栏的背景样式。</span></p></li> 
  <li><p><span style="font-size: 15px;">不要在 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillDisappear:</span></code><span style="font-size: 15px;"> 里添加针对导航栏样式修改的代码。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">不要随意修改 translucent 属性，包括隐式的修改和显示的修改。</span></p></li> 
 </ul> 
 <blockquote style="line-height: inherit;padding: 15px 15px 15px 1rem;font-size: 0.9em;margin-top: 1em;margin-bottom: 1em;color: rgb(129, 145, 152);border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);overflow: auto;overflow-wrap: normal;"> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">隐式修改是指使用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setBackgroundImage:forBarMetrics:</span></code><span style="font-size: 15px;"> 方法时，如果 image 里的像素点没有 alpha 通道或者 alpha 全部等于 1 会使得 translucent 变为 NO 或者 nil。</span></p> 
 </blockquote> 
 <h3><strong><span style="font-size: 18px;">基本原理</span></strong></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">以上，我们讲完了设计理念和使用方法，那么我们来看看美团的转场库到底做了什么？</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">从大方向上来看，美团使用的是前面所说的第三种方案，不过它也有一些自己独特的地方，为了更好的让大家理解整个过程，我们设计这样一个场景，从页面 A push 到页面 B，结合之前探讨过的方法调用顺序，我们可以知道几个核心方法的调用顺序大致如下：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;">页面 A 的 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">pushViewController:animated:</span></code></p></li> 
  <li><p><span style="font-size: 15px;">页面 B 的 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidLoad</span></code><span style="font-size: 15px;"> or </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code></p></li> 
  <li><p><span style="font-size: 15px;">页面 B 的 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillLayoutSubviews</span></code></p></li> 
  <li><p><span style="font-size: 15px;">页面 B 的 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidAppear:</span></code></p></li> 
 </ol> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在 push 过程的开始，转场库会在页面 A 自身的 view 上添加一个与导航栏一模一样的 NavigationBar 并将真的导航栏隐藏。之后这个假的导航栏会一直存在页面 A 上，用于保留 A 离开时的导航栏样式。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">等到页面 B 调用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidLoad</span></code><span style="font-size: 15px;"> 或者 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 的时候，开发者在这里自行设置真的导航栏样式。转场库在这里会对页面布局做一些修正和辅助操作，但不会影响导航栏的样式。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">等到页面 B 调用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillLayoutSubviews</span></code><span style="font-size: 15px;"> 的时候，转场库会在页面 B 自身的 view 上添加一个与真的导航栏一模一样的 NavigationBar，同时将真的导航栏隐藏。此时不论真的导航栏，还是假的导航栏都已经与 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidLoad</span></code><span style="font-size: 15px;"> 或者 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 里设置的一样的。</span></p> 
 <blockquote style="line-height: inherit;padding: 15px 15px 15px 1rem;font-size: 0.9em;margin-top: 1em;margin-bottom: 1em;color: rgb(129, 145, 152);border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);overflow: auto;overflow-wrap: normal;"> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">当然，这一步也可以放在 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillDisappear:</span></code><span style="font-size: 15px;"> 里并在 dispatch main queue 的下一个 runloop 中处理。</span></p> 
 </blockquote> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">等到页面 B 调用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidAppear:</span></code><span style="font-size: 15px;"> 的时候，转场库会将假的导航栏样式设置到真的导航栏中，并将假的导航栏从视图层级中移除，最终将真的导航栏显示出来。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">为了让大家更好地理解上面的内容，请参考下图：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.7091212458286985" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpdkIF8zg1OJXv8POtiaBESwicYXExN8P3oNvJLksv8OwvDT6tXMX03MkA/640?wx_fmt=png" data-type="png" data-w="1798" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpdkIF8zg1OJXv8POtiaBESwicYXExN8P3oNvJLksv8OwvDT6tXMX03MkA/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">说完了 push 过程，我们再来说一下从页面 B pop 回页面 A 的过程，几个核心方法的调用顺序如下：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;">页面 B 的 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">popViewControllerAnimated:</span></code></p></li> 
  <li><p><span style="font-size: 15px;">页面 A 的 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code></p></li> 
  <li><p><span style="font-size: 15px;">页面 A 的 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidAppear:</span></code></p></li> 
 </ol> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在 pop 过程的开始，转场库会在页面 B 自身的 view 上添加一个与导航栏一模一样的 NavigationBar 并将真的导航栏隐藏，虽然这个假的导航栏会一直存在于页面 B 上，但它自身会随着页面 B 的 dealloc 而消亡。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">等到页面 A 调用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 的时候，开发者在这里自行设置真的导航栏样式。当然我们也可以不设置，因为这时候页面 A 还持有一个假的导航栏，这里还保留着我们之前在 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidLoad</span></code><span style="font-size: 15px;"> 里写的导航栏样式。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">等到页面 A 调用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidAppear:</span></code><span style="font-size: 15px;"> 的时候，转场库会将假的导航栏样式设置到真的导航栏中，并将假的导航栏从视图层级中移除，最终将真的导航栏显示出来。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">同样，我们可以参考下面的图来理解上面所说的内容：</span></p> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.7183098591549296" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpPKkVic0PpibFicJgzRgsJVlxAOmrgLVorR3AqaCWhaibqJxrUO5VHykTUQ/640?wx_fmt=png" data-type="png" data-w="1775" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpPKkVic0PpibFicJgzRgsJVlxAOmrgLVorR3AqaCWhaibqJxrUO5VHykTUQ/640?wx_fmt=png"></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">现在，大家应该对我们美团的解决方案有了一定的认识，但在实际开发过程中，还需要考虑一些布局和适配的问题。</span></p> 
 <h2><strong style="color: rgb(51, 51, 51);font-size: 20px;white-space: normal;"><span style="color: rgb(49, 188, 173);">最佳实践</span></strong></h2> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">在维护这套转场方案的时间里，我们总结了一些此类方案的最佳实践。</span></p> 
 <h3><span style="font-size: 18px;"><strong><br></strong></span></h3> 
 <h3><span style="font-size: 18px;"><strong>判断导航栏问题的基本准则</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">如果发现导航栏在转场过程中出现了样式错乱，可以遵循以下几点基本原则：</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">检查相应 ViewController 里是否有修改其他 ViewController 导航栏样式的行为，如果有，请做调整。</span></p></li> 
  <li><p><span style="font-size: 15px;">保证所有对导航栏样式变化的操作出现在 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidLoad</span></code><span style="font-size: 15px;"> 和 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 中，如果在 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillDisappear:</span></code><span style="font-size: 15px;"> 等方法里出现了对导航栏的样式修改的操作，如果有，请做调整。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">检查是否有改动 translucent 属性，包括显示修改和隐式修改，如果有，请做调整。</span></p></li> 
 </ul> 
 <h3><span style="font-size: 18px;"><strong><br></strong></span></h3> 
 <h3><span style="font-size: 18px;"><strong>只关心当前页面的样式</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">永远记住每个 ViewController 只用关心自己的样式，设置的时机点在 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 或者 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewDidLoad 里</span></code><span style="font-size: 15px;">。</span></p> 
 <h3><span style="font-size: 18px;"><strong><br></strong></span></h3> 
 <h3><span style="font-size: 18px;"><strong>透明样式导航栏的正确设置方法</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">如果需要一个透明效果的导航栏，可以使用如下代码实现：</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">[<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>.navigationController.navigationBar&nbsp;setBackgroundImage:[<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">UIImage</span>&nbsp;new]&nbsp;forBarMetrics:<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">UIBarMetricsDefault</span>];<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>.navigationController.navigationBar.shadowImage&nbsp;=&nbsp;[<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">UIImage</span>&nbsp;new];&nbsp;<br></span></code></pre> 
 <h3><span style="font-size: 18px;"><strong><br></strong></span></h3> 
 <h3><span style="font-size: 18px;"><strong>导航栏的颜色渐变效果</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">如果需要导航栏实现随滚动改变整体 alpha 值的效果，可以通过改变 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setBackgroundImage:forBarMetrics:</span></code><span style="font-size: 15px;"> 方法里 image 的 alpha 值来达到目标，这里一般是使用监听 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">scrollView.contentOffset</span></code><span style="font-size: 15px;"> 的手段来做。请避免直接修改 NavigationBar 的 alpha 值。</span></p> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如果发现这种方式会引起严重的性能问题，可以尝试使用如下的方式进行修改，但不推荐，主要原因是通过读取数组内容的方式来获取视图实例既不优雅，也不安全。</span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">UIView</span>&nbsp;*background&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>.navigationController.navigationBar.subviews.firstObject;<br>background.alpha&nbsp;=&nbsp;MIN(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>.contentOffsetY&nbsp;/&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">100.0</span>,&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>);<br></span></code></pre> 
 <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">还有一点需要注意的是，在页面转场的过程中，也会触发 contentOffset 的变化，所以请尽量在 disappear 的时候取消监听。否则会容易出现导航栏透明度的变化。</span></p> 
 <h3><span style="font-size: 18px;"><strong>导航栏背景图片的规范</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">请避免背景图里的像素点没有 alpha 通道或者 alpha 全部等于 1，容易触发 translucent 的隐式改变。</span></p> 
 <h3><span style="font-size: 18px;"><strong><br></strong></span></h3> 
 <h3><span style="font-size: 18px;"><strong>如果真的要隐藏导航栏</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">如果我们需要隐藏导航栏，请保证所有的 ViewController 能坚持如下原则：</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">每个 ViewController 只需要关心当前页面下的导航栏是否被隐藏。</span></p></li> 
  <li><p><span style="font-size: 15px;">在 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 中，统一设置导航栏的隐藏状态。</span></p></li> 
  <li><p><span style="font-size: 15px;">使用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setNavigationBarHidden:animated:</span></code><span style="font-size: 15px;"> 方法，而不是 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">setNavigationBarHidden:</span></code><span style="font-size: 15px;">。</span></p></li> 
 </ol> 
 <h3><span style="font-size: 18px;"><strong><br></strong></span></h3> 
 <h3><span style="font-size: 18px;"><strong>转场动画与导航栏隐藏动画的一致性</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">如果在转场的过程中还会显示或者隐藏导航栏的话，请保证两个方法的动画参数一致。</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">-&nbsp;(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">void</span>)viewWillAppear:(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">BOOL</span>)animated{<br>&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">self</span>.navigationController&nbsp;setNavigationBarHidden:<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">YES</span>&nbsp;animated:animated];<br>}<br></span></code></pre> 
 <blockquote style="line-height: inherit;padding: 15px 15px 15px 1rem;font-size: 0.9em;margin-top: 1em;margin-bottom: 1em;color: rgb(129, 145, 152);border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);overflow: auto;overflow-wrap: normal;"> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">viewWillAppear:</span></code><span style="font-size: 15px;"> 里的 animated 参数是受 push 和 pop 方法里 animated 参数影响。</span></p> 
 </blockquote> 
 <h3><span style="font-size: 18px;"><strong><br></strong></span></h3> 
 <h3><span style="font-size: 18px;"><strong>导航栏固有的系统问题</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">目前已知的有两个系统问题如下：</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">当前后两个 ViewController 的导航栏都处于隐藏状态，然后在后一个 ViewController 中使用返回手势 pop 到一半时取消，再连续 push 多个页面时会造成导航栏的 Stack 混乱或者 Crash。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">当页面的层级结构大体如下所示时，在红色导航栏的 Stack 中，返回手势会大概率的出现跨层级的跳转，多次后会导致整个导航栏的 Stack 错乱或者 Crash。</span></p></li> 
 </ol> 
 <h3><br></h3> 
 <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.8146067415730337" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpRLhEUxsJyyAMT0pazibxTUOzgH2Wib75fYyJiaP6FvxauMVEuStjP4Diaw/640?wx_fmt=png" data-type="png" data-w="712" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpRLhEUxsJyyAMT0pazibxTUOzgH2Wib75fYyJiaP6FvxauMVEuStjP4Diaw/640?wx_fmt=png"></p> 
 <h3><span style="font-size: 18px;"><strong><br></strong></span></h3> 
 <h3><span style="font-size: 18px;"><strong>导航栏内置组件的布局规范</strong></span></h3> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">导航栏里的组件布局在 iOS 11 后发生了改变，原有的一些解决方案已经失效，这些内容不在本篇文章的讨论范围之内，推荐阅读</span><a href="http://sketchk.xyz/2018/02/23/How-to-make-your-UIBarButtonItem-perfect-match-in-iOS/" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">UIBarButtonItem 在 iOS 11 上的改变及应对方案</span></a><span style="font-size: 15px;">，这篇文章详细的解释了 iOS 11 里的变化和可行的应对方案。</span></p> 
 <h2><br></h2> 
 <h2><strong style="color: rgb(51, 51, 51);font-size: 20px;white-space: normal;"><span style="color: rgb(49, 188, 173);">总结</span></strong></h2> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;">本文涉及内容较多，从 iOS 系统下的导航栏概念到大型应用里的最佳实践，这里我们总结一下整篇文章的核心内容：</span></p> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><span style="font-size: 15px;">理解导航栏组件的结构和相关方法的生命周期。</span></p></li> 
  <ul style="list-style-type: square;" class=" list-paddingleft-2"> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">导航栏组件的结构留有 MVC 架构的影子，在解决问题时，要去相应的层级处理。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">转场问题的关键点是方法的调用顺序，所以了解生命周期是解决此类问题的基础。</span></p></li> 
  </ul> 
  <li><p><span style="font-size: 15px;">状态管理，转换时机和样式变化是导航栏里常见问题的三种表现形式，遇到实际问题时需要区分清楚。</span></p></li> 
  <ul style="list-style-type: square;" class=" list-paddingleft-2"> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">状态管理要坚持“谁修改，谁复原”的原则。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">转换时机的设定要做到连续可执行。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">样式变化的核心点是导航栏的显示与否与颜色变化。</span></p></li> 
  </ul> 
  <li><p><span style="font-size: 15px;">为了更好的配合大型应用里的路由系统，导航栏转场的常见解决方案有三种，各有利弊，需要根据自身的业务场景和历史包袱做取舍。</span></p></li> 
  <ul style="list-style-type: square;" class=" list-paddingleft-2"> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">解决方案1：自定义导航栏组件。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">解决方案2：在原有导航栏组件里添加 Fake Bar。</span></p></li> 
   <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">解决方案3：在导航栏转场过程中添加 Fake Bar。</span></p></li> 
  </ul> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">美团在实际开发过程中采用了第三种方案，并给出了适合美团 App 的最佳实践。</span></p></li> 
 </ul> 
 <h2><br></h2> 
 <h2><strong style="color: rgb(51, 51, 51);font-size: 16px;white-space: normal;"><span style="color: rgb(49, 188, 173);">参考链接</span></strong></h2> 
 <p><br></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p><a href="https://www.raywenderlich.com/1625-uiappearance-tutorial-getting-started" style="line-height: inherit;text-decoration: underline;color: rgb(136, 136, 136);font-size: 14px;"><span style="color: rgb(136, 136, 136);font-size: 14px;">UIAppearance Tutorial: Getting Started</span></a></p></li> 
  <li><p><span style="line-height: inherit;text-decoration: underline;color: rgb(136, 136, 136);font-size: 14px;"><a href="https://github.com/MoZhouqi/KMNavigationBarTransition" style="line-height: inherit;text-decoration: underline;color: rgb(136, 136, 136);font-size: 14px;">KMNavigationBarTransition</a></span></p></li> 
 </ul> 
 <h2><span style=""><br></span></h2> 
 <h2><span style="">特别感谢<a href="https://github.com/MoZhouqi" target="_blank">莫洲骐</a>在此项目中做出的贡献与付出。</span></h2> 
 <h2><strong style="color: rgb(51, 51, 51);font-size: 16px;white-space: normal;"><span style="color: rgb(49, 188, 173);"><br></span></strong></h2> 
 <h2><strong style="color: rgb(51, 51, 51);font-size: 16px;white-space: normal;"><span style="color: rgb(49, 188, 173);">作者简介</span></strong></h2> 
 <p><span style="font-size: 15px;"><br></span></p> 
 <p><span style="font-size: 15px;color: rgb(136, 136, 136);">思琦，美团点评 iOS 工程师。2016 年加入美团，负责美团平台的业务开发及 UI 组件的维护工作。</span></p> 
</section> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;color: rgb(51, 51, 51);"><span style="color: rgb(0, 0, 0);font-size: 15px;"><br></span></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;color: rgb(51, 51, 51);"><span style="color: rgb(0, 0, 0);font-size: 15px;"><span style="color: rgb(136, 136, 136);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);">扫码加入</span><strong style="color: rgb(51, 51, 51);"><span style="font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);color: rgb(0, 0, 0);">美团iOS技术交流群</span></strong><span style="color: rgb(136, 136, 136);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);">，跟作者零距离交流。如群已满，请加美美同学的微信（微信号：<strong>MTDPtech01</strong>），回复：</span><span style="font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);color: rgb(62, 62, 62);"><strong>iOS</strong></span><span style="color: rgb(136, 136, 136);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);">，美美会自动拉你进群。</span></span></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;color: rgb(51, 51, 51);"><span style="color: rgb(0, 0, 0);font-size: 15px;"><span style="color: rgb(136, 136, 136);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);"><br></span></span></p> 
<p style="text-align: center;"><img class="" data-copyright="0" data-ratio="1.117472852912142" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpoNaibxzmCwXrpnWRicM5zW3fZ1J0Cic9vcBYqcUzFsESz1RnGOQT2Kricw/640?wx_fmt=jpeg" data-type="jpeg" data-w="1013" style="width: 206px;height: 230px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXFj8vy1UTFvicPG7piaUrficpoNaibxzmCwXrpnWRicM5zW3fZ1J0Cic9vcBYqcUzFsESz1RnGOQT2Kricw/640?wx_fmt=jpeg"></p> 
<p style="margin-right: 0.5em;margin-left: 0.5em;white-space: normal;color: rgb(51, 51, 51);"><span style="color: rgb(0, 0, 0);font-size: 15px;"><span style="color: rgb(136, 136, 136);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: justify;background-color: rgb(255, 255, 255);"></span></span><br></p> 
<p style="white-space: normal;color: rgb(51, 51, 51);text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 15px;color: rgb(136, 136, 136);">----------&nbsp; END&nbsp; ----------</span></p> 
<p data-source-line="194" style="white-space: normal;color: rgb(51, 51, 51);margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 16px;"><strong><span style="color: rgb(49, 188, 173);">招聘信息</span></strong></span></p> 
<p style="white-space: normal;color: rgb(51, 51, 51);margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<section data-source="bj.96weixin.com" style="font-size: 16px;white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"> 
 <section style="padding: 20px 20px 15px;width: 670px;text-decoration: inherit;background-color: rgb(245, 245, 245);"> 
  <p style="line-height: normal;"><span style="font-size: 15px;"><span style="font-family: Arial, sans-serif;font-weight: bold;text-decoration: inherit;color: rgb(128, 128, 128);"></span><span style="color: rgb(136, 136, 136);"></span></span><span style="font-size: 14px;">美团平台诚招 iOS、Android、FE 高级/资深工程师和技术专家，Base 北京、上海、成都，欢迎有兴趣的同学投递简历到zhangsiqi04@meituan.com。&nbsp;</span></p> 
 </section> 
</section> 
<p data-source-line="194" style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><br></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 16px;"><strong><span style="color: rgb(49, 188, 173);">也许你还想看</span></strong></span></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 16px;"><strong><span style="color: rgb(49, 188, 173);"><br></span></strong></span></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748259&amp;idx=1&amp;sn=a7ef0d515e94631c8d86bdbbf81da143&amp;chksm=bd12aeee8a6527f8a297d0dc797b81492837019c821898ae21c3e158831aaa7a383d5155ec9b&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">美团外卖iOS多端复用的推动、支撑与思考</span></a></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651745398&amp;idx=1&amp;sn=12086c7f3bdd05ef996ba140813bb7c5&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">基于 KIF 的 iOS UI 自动化测试和持续集成</span></a></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748776&amp;idx=3&amp;sn=25684a8d5e561b10c450436bb1f9d35c&amp;chksm=bd12a0e58a6529f3aad3ecd891bd2274aabfd19c82711298c88b96a6bd136c5522e9def3476a&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">ARKit：增强现实技术在美团到餐业务的实践</span></a><br><br></p> 
<p style="white-space: normal;margin-left: 0.5em;margin-right: 0.5em;"><span style="font-size: 15px;"></span></p> 
<p style="white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;"><img class="" data-copyright="0" data-ratio="0.44533333333333336" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png" data-type="png" data-w="1875" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png"></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
