<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Category 特性在 iOS 组件化中的应用与管控 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Category 特性在 iOS 组件化中的应用与管控" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="总第300篇 2018年 第92篇 背景 iOS Category功能简介 Category 是 Objective-C 2.0之后添加的语言特性。 Category 就是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。在 Objective-C（iOS 的开发语言，下文用 OC 代替）中的具体体现为：实例（类）方法、属性和协议。 除了引用中提到的添加方法，Category 还有很多优势，比如将一个类的实现拆分开放在不同的文件内，以及可以声明私有方法，甚至可以模拟多继承等操作，具体可参考官方文档Category。 若 Category 添加的方法是基类已经存在的，则会覆盖基类的同名方法。本文将要提到的组件间通信都是基于这个特性实现的，在本文的最后则会提到对覆盖风险的管控。 组件通信的背景 随着移动互联网的快速发展，不断迭代的移动端工程往往面临着耦合严重、维护效率低、开发不够敏捷等常见问题，因此越来越多的公司开始推行“组件化”，通过解耦重组组件来提高并行开发效率。 但是大多数团队口中的“组件化”就是把代码分库，主工程使用 CocoaPods 工具把各个子库的版本号聚合起来。但能合理的把组件分层，并且有一整套工具链支撑发版与集成的公司较少，导致开发效率很难有明显地提升。 处理好各个组件之间的通信与解耦一直都是组件化的难点。诸如组件之间的 Podfile 相互显式依赖，以及各种联合发版等问题，若处理不当可能会引发“灾难”性的后果。 目前做到 ViewController （指iOS中的页面，下文用VC代替）级别解耦的团队较多，维护一套 mapping 关系并使用 scheme 进行跳转，但是目前仍然无法做到更细粒度的解耦通信，依然满足不了部分业务的需求。 实际业务案例 例1：外卖的首页的商家列表（WMPageKit），在进入一个商家（WMRestaurantKit）选择5件商品返回到首页的时候，对应的商家cell需要显示已选商品“5”。 例2：搜索结果（WMSearchKit）跳转到商超的容器页（WMSupermarketKit），需要传递一个通用Domain（也有的说法叫模型、Model、Entity、Object等等，下文统一用Domain表示）。 例3：做一键下单需求（WMPageKit），需要调用下单功能的一个方法（WMOrderKit）入参是一个订单相关 Domain 和一个 VC，不需要返回值。 这几种场景基本涵盖了组件通信所需的基本功能，那么怎样才可以实现最优雅的解决方案？ 组件通信的探索 模型分析 对于上文提到的实际业务案例，很容易想到的应对方案有三种，第一是拷贝共同依赖代码，第二是直接依赖，第三是下沉公共依赖。 对于方案一，会维护多份冗余代码，逻辑更新后代码不同步，显然是不可取的。对于方案二，对于调用方来说，会引入较多无用依赖，且可能造成组件间的循环依赖问题，导致组件无法发布。对于方案三，其实是可行解，但是开发成本较大。对于下沉出来的组件来说，其实很难找到一个明确的定位，最终沦为多个组件的“大杂烩”依赖，从而导致严重的维护性问题。 那如何解决这个问题呢？根据面向对象设计的五大原则之一的“依赖倒置原则”（Dependency Inversion Principle），高层次的模块不应该依赖于低层次的模块，两者（的实现）都应该依赖于抽象接口。推广到组件间的关系处理，对于组件间的调用和被调用方，从本质上来说，我们也需要尽量避免它们的直接依赖，而希望它们依赖一个公共的抽象层，通过架构工具来管理和使用这个抽象层。这样我们就可以在解除组件间在构建时不必要的依赖，从而优雅地实现组件间的通讯。 图1-1 模型设计 业界现有方案的几大方向 实践倒置原则的方案有很多，在 iOS 侧，OC 语言和 Foundation 库给我们提供了数个可用于抽象的语言工具。在这一节我们将对其中部分实践进行分析。 1. 使用依赖注入 代表作品有 Objection 和 Typhoon，两者都是 OC 中的依赖注入框架，前者轻量级，后者较重并支持 Swift。 比较具有通用性的方法是使用「协议」 &lt;-&gt; 「类」绑定的方式，对于要注入的对象会有对应的 Protocol 进行约束，会经常看到一些RegisterClass:ForProtocol：和classFromProtocol的代码。在需要使用注入对象时，用框架提供的接口以协议作为入参从容器中获得初始化后的所需对象。也可以在 Register 的时候直接注册一段 Block-Code，这个代码块用来初始化自己，作为id类型的返回值返回，可以支持一些编译检查来确保对应代码被编译。 美团内推行将一些运行时加载的操作前移至编译时，比如将各项注册从 +load 改为在编译期使用__attribute((used,section(&quot;__DATA,key&quot;))) 写入 mach-O 文件 Data 的 Segment 中来减少冷启动的时间消耗。 因此，该方案的局限性在于：代码块存取的性能消耗较大，并且协议与类的绑定关系的维护需要花费更多的时间成本。 2. 基于SPI机制 全称是 Service Provider Interfaces，代表作品是 ServiceLoader。 实现过程大致是：A库与B库之间无依赖，但都依赖于P平台。把B库内的一个接口I下沉到平台层（“平台层”也叫做“通用能力层”，下文统一用平台层表示），入参和返回值的类型需要平台层包含，接口I的实现放在B库里（因为实现在B库，所以实现里可以正常引用B库的元素）。然后A库通过P平台的这个接口I来实现功能。A可以调用的到接口I，但是在B的库中进行实现。 在A库需要通过一个接口I实例化出一个对象，使用ServiceLoader.load（接口，key），通过注册过的key使用反射找到这个接口imp的文件路径然后得到这个实例对象调用对应接口。 这个操作在安卓中使用较为广泛，大致相当于用反射操作来替代一次了 import 这样的耦合引用。但实际上iOS中若使用反射来实现功能则完全不必这么麻烦。 关于反射，Java可以实现类似于ClassFromString的功能，但是无法直接使用 MethodFromString的功能。并且ClassFromString也是通过字符串map到这个类的文件路径，类似于 com.waimai.home.searchImp，从而可以获得类型然后实例化，而OC的反射是通过消息机制实现。 3. 基于通知中心 之前和一个做读书类App的同学交流，发现行业内有些公司的团队在使用 NotificationCenter 进行一些解耦的通信，因为通知中心本身支持传递对象，并且通知中心的功能也原生支持同步执行，所以也可以达到目的。 通知中心在iOS 9之后有一次比较大的升级，将通知支持了 request 和 response 的处理逻辑，并支持获取到通知的发送者。比以往的通知群发但不感知发送者和是否收到，进步了很多。 字符串的约定也可以理解为一个简化的协议，可设置成宏或常量放在平台层进行统一的维护。 比较明显的缺陷是开发的统一范式难以约束，风格迥异，且字符串相较于接口而言还是难以管理。 4. 使用objc_msgSend 这是iOS原生消息机制中最万能的方法，编写时会有一些硬编码。核心代码如下： id&nbsp;s&nbsp;=&nbsp;((id(*)(id,&nbsp;SEL))objc_msgSend)(ClassName,@selector(methodName));&nbsp; 这种方法的特点是即插即用，在开发者能100%确定整条调用链没问题的时候，可以快速实现功能。 此方案的缺陷在于编写十分随意，检查和校验的逻辑还不够，满屏的强转。对于 int、Integer、NSNumber 这样的很容易发生类型转换错误，结果虽然不报错，但数字会有错误。 方案对比 接下来，我们对这几个大方向进行一些性能对比。 考虑到在公司内的实际用法与限制，可能比常规方法增加了若干步骤，结果也可能会与常规裸测存在一定的偏差。 例如依赖注入常用做法是存在单例（内存）里，但是我们为了优化冷启动时间都写入 mach-O 文件 Data 的 Segment 里了，所以在我们的统计口径下存取时间会相对较长。 //&nbsp;为了不暴露类名将业务属性用“some”代替，并隐藏初始化、循环100W次、差值计算等代码，关键操作代码如下//&nbsp;存取注入对象xxConfig&nbsp;=&nbsp;[[WMSomeGlueCore&nbsp;sharedInstance]&nbsp;createObjectForProtocol:@protocol(WMSomeProtocol)];//&nbsp;通知发送[[NSNotificationCenter&nbsp;defaultCenter]postNotificationName:@&quot;nixx&quot;&nbsp;object:nil];//&nbsp;原生接口调用a&nbsp;=&nbsp;[WMSomeClass&nbsp;class];//&nbsp;反射调用b&nbsp;=&nbsp;objc_getClass(&quot;WMSomeClass&quot;); 运行结果显示如下： 图1-2 性能消耗检测 可以看出原生的接口调用明显是最高效的用法，反射的时长比原生要多一个数量级，不过100W次也就是多了几十毫秒，还在可以接受的范围之内。通知发送相比之下性能就很低了，存取注入对象更低。 当然除了性能消耗外，还有很多不好量化的维度，包括规范约束、功能性、代码量、可读性等，笔者按照实际场景客观评价给出对比的分值。 下面，我们用五种维度的能力值图来对比每一种方案优缺点： 各维度的的评分考虑到了一定的实际场景，可能和常规结果稍有偏差。 已经做了转化，看图面积越大越优。可读性的维度越长代表可读性越高，代码量的维度越长代表代码成本越少。 图2-1 各方案优缺点对比 如图2所示，可以看出上图的四种方式或多或少都存在一些缺点： 依赖注入是因为美团的实际场景问题，所以在性能消耗上存在明显的短板，并且代码量和可读性都不突出，规范约束这里是亮点。 SPI机制的范围图很大，但使用了反射，并且代码开发成本较高，实践上来看，对协议管理有一定要求。 通知中心除了代码少一些，其他维度都是短板。 而msgsend功能强大，代码量也少，但是在规范约束和可读性上几乎为零。 综合看来 SPI 和 objc_msgSend 两者的特点比较明显，很有潜力，如果针对这两种方案分别进行一定程度的完善，应该可以实现一个综合评分更高的方案。 从现有方案中完善或衍生出的方案 5. 使用Category+NSInvocation 此方案从 objc_msgSend 演化而来。NSInvocation 的调用方式的底层还是会使用到 objc_msgSend，但是通过一些方法签名和返回值类型校验，可以解决很多类型规范相关的问题，并且这种方式没有繁琐的注册步骤，任何一次新接口的添加，都可以直接在低层的库中进行完成。 为了更进一步限制调用者能够调用的接口，创建一些 Category 来提供接口，内部包装下层接口，把返回值和入参都限制实际的类型。业界比较接近的例子有 casatwy 的 CTMediator。 6. 原生CategoryCoverOrigin方式 此方案从 SPI 方式演化而来。两个的共同点是都在平台层提供接口供业务方调用，不同点是此方式完全规避了各种硬编码。而且 CategoryCoverOrigin 是一个思想，没有任何框架代码，可以说 OC 的 Runtime 就是这个方案的框架支撑。此方案的核心操作是在基类里汇总所有业务接口，在上层的业务库中创建基类的 Category 中对声明的接口进行覆盖。整个过程没有任何硬编码与反射。 演化出的这两种方案能力评估如下（绿色部分），图中也贴了和演化前方案（桔色部分）的对比： 图2-2 两种演化方案对比 上文对这两种方案描述的非常概括，可能有同学会对能力评估存在质疑。接下来会分别进行详解的介绍，并描述在实际操作值得注意的细节。这两种方案组合成了外卖内部的组件通信框架 WMScheduler。 WMScheduler组件通信 外卖的 WMScheduler 主要是通过对 Category 特性的运用来实现组件间通信，实际操作中有两种的应用方案：Category+NSInvocation 和 CategoryCoverOrigin。 1. Category+NSInvocation方案 方案简介 这个方案将其对 NSInvocation 功能容错封装、参数判断、类型转换的代码写在下层，提供简易万能的接口。并在上层创建通信调度器类提供常用接口，在调度器的 Category 里扩展特定业务的专用接口。所有的上层接口均有规范约束，这些规范接口的内部会调用下层的简易万能接口即可通过NSInvocation 相关的硬编码操作调用任何方法。 UML图 图3-1 Category+NSInvocation的UML图 如图3-1所示，代码的核心在 WMSchedulerCore 类，其包含了基于 NSInvocation 对 target 与 method 的操作、对参数的处理（包括对象，基本数据类型，NULL类型）、对异常的处理等等，最终开放了简洁的万能接口，接口参数有 target、method、parameters等等，然后内部帮我们完成调用。但这个接口并不是让上层业务直接进行调用，而是需要创建一个 WMSchedule r的 Category，在这个 Category 中编写规范的接口（前缀、入参类型、返回值类型都是确定的）。 值得一提的是，提供业务专用接口的 Category 没有以 WMSchedulerCore 为基类，而是以 WMScheduler 为基类。看似多此一举，实际上是为了做权限的隔离。上层业务只能访问到 WMScheduler.h 及其 Category 的规范接口。并不能访问到 WMSchedulerCore.h 提供的“万能但不规范”接口。 例如：在UML图中可以看到 外界只可以调用到wms_getOrderCountWithPoiid（规范接口），并不能使用wm_excuteInstance Method（万能接口）。 为了更好地理解实际使用，笔者贴一个组件调用周期的完整代码： 图3-2 Category+NSInvocation的示例图 如图3-2，在这种方案下，“B库调用A库方法”的需求只需要改两个仓库的代码，需要改动的文件标了下划线，请仔细看下示例代码。 示例代码 平台（通用功能）库三个文件： ① //&nbsp;WMScheduler+AKit.h#import&nbsp;&quot;WMScheduler.h&quot;@interface&nbsp;WMScheduler(AKit)/**&nbsp;*&nbsp;通过商家id查到当前购物车已选e的小红点数量&nbsp;*&nbsp;@param&nbsp;poiid&nbsp;&nbsp;商家id&nbsp;*&nbsp;@return&nbsp;实际的小红点数量&nbsp;*/+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID;@end ② //&nbsp;WMScheduler+AKit.m#import&nbsp;&quot;WMSchedulerCore.h&quot;#import&nbsp;&quot;WMScheduler+AKit.h&quot;#import&nbsp;&quot;NSObject+WMScheduler.h&quot;@implementation&nbsp;WMScheduler&nbsp;(AKit)+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID{&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nil&nbsp;==&nbsp;poiid)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;}#pragma&nbsp;clang&nbsp;diagnostic&nbsp;push#pragma&nbsp;clang&nbsp;diagnostic&nbsp;ignored&nbsp;&quot;-Wundeclared-selector&quot;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;singleton&nbsp;=&nbsp;[wm_scheduler_getClass(&quot;WMXXXSingleton&quot;)&nbsp;wm_executeMethod:@selector(sharedInstance)];&nbsp;&nbsp;&nbsp;&nbsp;NSNumber*&nbsp;orderFoodCount&nbsp;=&nbsp;[singleton&nbsp;wm_executeMethod:@selector(calculateOrderedFoodCountWithPoiID:)&nbsp;params:@[poiID]];&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;orderFoodCount&nbsp;==&nbsp;nil&nbsp;?&nbsp;0&nbsp;:&nbsp;[orderFoodCount&nbsp;integerValue];#pragma&nbsp;clang&nbsp;diagnostic&nbsp;pop}@end ③ //&nbsp;WMSchedulerInterfaceList.h#ifndef&nbsp;WMSchedulerInterfaceList_h#define&nbsp;WMSchedulerInterfaceList_h//&nbsp;这个文件会被加到上层业务的pch里，所以下文不用import本文件#import&nbsp;&quot;WMScheduler.h&quot;#import&nbsp;&quot;WMScheduler+AKit.h&quot;#endif&nbsp;/*&nbsp;WMSchedulerInterfaceList_h&nbsp;*/ BKit （调用方）一个文件： //&nbsp;WMHomeVC.m@interface&nbsp;WMHomeVC&nbsp;()&nbsp;&lt;UITableViewDataSource,&nbsp;UITableViewDelegate&gt;@end@implementation&nbsp;WMHomeVC...&nbsp;&nbsp;&nbsp;&nbsp;NSUInteger&nbsp;*foodCount&nbsp;=&nbsp;[WMScheduler&nbsp;wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%ld&quot;,foodCount);...@end 代码分析 上文四个文件完成了一次跨组件的调用，在 WMScheduler+AKit.m 中的第30、31行，调用的都是AKit（提供方）的现有方法，因为 WMSchedulerCore 提供了 NSInvocation 的调用方式，所以可以直接向上调用。WMScheduler+AKit 中提供的接口就是上文说的“规范接口”，这个接口在WMHomeVC（调用方）调用时和调用本仓库内的OC方法，并没有区别。 延伸思考 上文的例子中入参和返回值都是基本数据类型，Domain 也是支持的，前提是这个 Domain 是放在平台库的。我们可以将工程中的 Domain 分为BO（Business Object）、VO（View Object）与TO（Transfer Object），VO 经常出现在 view 和 cell，BO一般仅在各业务子库内部使用，这个TO则是需要放在平台库是用于各个组件间的通信的通用模型。例如：通用 PoiDomain，通用 OrderDomain，通用 AddressDomain 等等。这些称为 TO 的 Domain 可以作为规范接口的入参类型或返回值类型。 在实际业务场景中，跳转页面时传递 Domain 的需求也是一个老生常谈的问题，大多数页面级跳转框架仅支持传递基本数据类型（也有 trick 的方式传 Domain 内存地址但很不优雅）。在有了上文支持的能力，我们可以在规范接口内通过万能接口获取目标页面的VC，并调用其某个属性的 set 方法将我们想传递的Domain赋值过去，然后将这个 VC 对象作为返回值返回。调用方获得这个 VC 后在当前的导航栈内push即可。 上文代码中我们用 WMScheduler 调用了 Akit 的一个名为calculateOrderedFoodCount WithPoiID：的方法。那么有个争议点：在组件通信需要调用某方法时，是允许直接调用现有方法，还是复制一份加上前缀标注此方法专门用于提供组件通信？ 阶段总结 Category+NSInvocation 方案的优点是便捷，因为 Category 的专用接口放在平台库，以后有除了 BKit 以外的其他调用方也可以直接调用，还有更多强大的功能。 但是，不优雅的地方我们也列举一下： 当这个跨组件方法内部的代码行数比较多时，会写很多硬编码。 硬编码method字符串，在现有方法被修改时，编译检测不报错（只能靠断言约束）。 下层库向上调用的设计会被诟病。 接下来介绍的 CategoryCoverOrigin 的方案，可以解决这三个问题。 2. CategoryCoverOrigin方案 方案简介 首先说明下这个方案和 NSInvocation 没有任何关系，此方案与上一方案也是完全不同的两个概念，不要将上一个方案的思维带到这里。 此方案的思路是在平台层的 WMScheduler.h 提供接口方法，接口的实现只写空实现或者兜底实现（兜底实现中可根据业务场景在 Debug 环境下增加 toast 提示或断言），上层库的提供方实现接口方法并通过 Category 的特性，在运行时进行对基类同名方法的替换。调用方则正常调用平台层提供的接口。在 CategoryCoverOrigin 的方案中 WMScheduler 的 Category 在提供方仓库内部，因此业务逻辑的依赖可以在仓库内部使用常规的OC调用。 UML图 图4-1 CategoryCover 的 UML 图 从图4-1可以看出，WMScheduler 的 Category 被移到了业务仓库，并且 WMScheduler 中有所有接口的全集。 为了更好地理解 CategoryCover 实际应用，笔者再贴一个此方案下的完整代码： 图4-2 CategoryCover的示例图 如图4-2，在这种方案下，“B库调用A库方法”的需求需要修改三个仓库的代码，但除了这四个编辑的文件，没有其他任何的依赖了，请仔细看下代码示例。 示例代码 平台（通用功能库）两个文件： ① //&nbsp;&nbsp;WMScheduler.h@interface&nbsp;WMScheduler&nbsp;:&nbsp;NSObject//&nbsp;&nbsp;这个文件是所有组件通信方法的汇总#pragma&nbsp;mark&nbsp;-&nbsp;AKit&nbsp;&nbsp;/**&nbsp;*&nbsp;通过商家id查到当前购物车已选e的小红点数量&nbsp;*&nbsp;@param&nbsp;poiid&nbsp;&nbsp;商家id&nbsp;*&nbsp;@return&nbsp;实际的小红点数量&nbsp;*/+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID;#pragma&nbsp;mark&nbsp;-&nbsp;CKit//&nbsp;...#pragma&nbsp;mark&nbsp;-&nbsp;DKit//&nbsp;...@end ② //&nbsp;WMScheduler.m#import&nbsp;&quot;WMScheduler.h&quot;@implementation&nbsp;WMScheduler#pragma&nbsp;mark&nbsp;-&nbsp;Akit+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;//&nbsp;这个.m里只要求一个空实现&nbsp;作为兜底方案。}#pragma&nbsp;mark&nbsp;-&nbsp;Ckit//&nbsp;...#pragma&nbsp;mark&nbsp;-&nbsp;Dkit//&nbsp;...@end AKit（提供方）一个 Category 文件： //&nbsp;WMScheduler+AKit.m#import&nbsp;&quot;WMScheduler.h&quot;#import&nbsp;&quot;WMAKitBusinessManager.h&quot;#import&nbsp;&quot;WMXXXSingleton.h&quot;&nbsp;&nbsp;//&nbsp;直接导入了很多AKit相关的业务文件，因为本身就在AKit仓库内@implementation&nbsp;WMScheduler&nbsp;(AKit)//&nbsp;这个宏可以屏蔽分类覆盖基类方法的警告#pragma&nbsp;clang&nbsp;diagnostic&nbsp;push#pragma&nbsp;clang&nbsp;diagnostic&nbsp;ignored&nbsp;&quot;-Wobjc-protocol-method-implementation&quot;//&nbsp;在平台层写过的方法，这边是是自动补全的+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nil&nbsp;==&nbsp;poiid)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;所有AKIT相关的类都能直接接口调用，不需要任何硬编码，可以和之前的写法对比下。&nbsp;&nbsp;&nbsp;&nbsp;WMXXXSingleton&nbsp;*singleton&nbsp;=&nbsp;[WMXXXSingleton&nbsp;sharedInstance];&nbsp;&nbsp;&nbsp;&nbsp;NSNumber&nbsp;*orderFoodCount&nbsp;=&nbsp;[singleton&nbsp;calculateOrderedFoodCountWithPoiID:poiID];&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;orderFoodCount&nbsp;==&nbsp;nil&nbsp;?&nbsp;0&nbsp;:&nbsp;[orderFoodCount&nbsp;integerValue];}#pragma&nbsp;clang&nbsp;diagnostic&nbsp;pop@end BKit（调用方） 一个文件写法不变： //&nbsp;WMHomeVC.m@interface&nbsp;WMHomeVC&nbsp;()&nbsp;&lt;UITableViewDataSource,&nbsp;UITableViewDelegate&gt;@end@implementation&nbsp;WMHomeVC...&nbsp;&nbsp;&nbsp;&nbsp;NSUInteger&nbsp;*foodCount&nbsp;=&nbsp;[WMScheduler&nbsp;wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%ld&quot;,foodCount);...@end 代码分析 CategoryCoverOrigin 的方式，平台库用 WMScheduler.h 文件存放所有的组件通信接口的汇总，各个仓库用注释隔开，并在.m文件中编写了空实现。功能代码编写在服务提供方仓库的 WMScheduler+AKit.m，看这个文件的17、18行业务逻辑是使用常规 OC 接口调用。在运行时此Category的方法会覆盖 WMScheduler.h 基类中的同名方法，从而达到目的。CategoryCoverOrigin 方式不需要其他功能类的支撑。 延伸思考 如果业务库很多，方法很多，会不会出现 WMScheduler.h 爆炸？ &nbsp;目前我们的工程跨组件调用的实际场景不是很多，所以汇总在一个文件了，如果满屏都是跨组件调用的工程，则需要思考业务架构与模块划分是否合理这一问题。当然，如果真出现 WMScheduler.h 爆炸的情况，完全可以将各个业务的接口移至自己Category 的.h文件中，然后创建一个 WMSchedulerInterfaceList 文件统一 import 这些 Category。 两种方案的选择 刚才我们对于 Category+NSInvocation 和 CategoryCoverOrigin 两种方式都做了详细的介绍，我们再整理一下两者的优缺点对比： 笔者更建议使用 CategoryCoverOrigin 的无硬编码的方案，当然具体也要看项目的实际场景，从而做出最优的选择。 更多建议 关于组件对外提供的接口，我们更倾向于借鉴 SPI 的思想，作为一个 Kit 哪些功能是需要对外公开的？提供哪些服务给其他方解耦调用？建议主动开放核心方法，尽量减少“用到才补”的场景。例如全局购物车就需要“提供获取小红点数量的方法”，商家中心就需要提供“根据字符串 id 得到整个 Poi 的 Domain”的接口服务。 需要考虑到抽象能力，提供更有泛用性的接口。比如“获取到了最低满减价格后拼接成一个文案返回字符串” 这个方法，就没有“获取到了最低满减价格” 这个方法具备泛用性。 Category风险管控 先举两个发生过的案例 1. 2017年10月 一个关于NSDate重复覆盖的问题 当时美团平台有 NSDate+MTAddition 类，在外卖侧有 NSDate+WMAddition 类。前者 NSDate+MTAddition 之前就有方法 getCurrentTimestamp，返回的时间戳是秒。后者 NSDate+WMAddition 在一次需求中也增加了 getCurrentTimestamp 方法，但是为了和其他平台统一口径返回值使用了毫秒。在正常的加载顺序中外卖类比平台类要晚，因此在外卖的测试中没有发现问题。但集成到 imeituan 主项目之后，原先其他业务方调用这个返回“秒”的方法，就被外卖测的返回“毫秒”的同名方法给覆盖了，出现接口错误和UI错乱等问题。 2. 2018年3月 一个WMScheduler组件通信遇到的问题 在外卖侧有订单组件和商家容器组件，这两个组件的联系是十分紧密的，有的功能放在两个仓库任意一个中都说的通。因此出现了了两个仓库写了同名方法的场景。在 WMScheduler+Restaurant 和 WMScheduler+Order 两个仓库都添加了方法 -(void)wms_enterGlobalCartPageFromPage:，在运行中这两处有一处被覆盖。在有一次 Bug 解决中，给其中一处增加了异常处理的代码，恰巧增加的这处先加载，就被后加载的同名方法覆盖了，这就导致了异常处理代码不生效的问题。 那么使用 CategoryCover 的方式是不是很不安全？ NO！只要弄清其中的规律，风险点都是完全可以管控的，接下来，我们来分析 Category 的覆盖原理。 Category 方法覆盖原理 1) Category 的方法没有“完全替换掉”原来类已经有的方法，也就是说如果 Category 和原来类都有methodA，那么 Category 附加完成之后，类的方法列表里会有两个 methodA。 2) Category 方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的 Category 的方法会“覆盖”掉原来类的同名方法，这是因为运行过程中，我们在查找方法的时候会顺着方法列表的顺序去查找，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。 Category 在运行期进行决议，而基类的类是在编译期进行决议，因此分类中，方法的加载顺序一定在基类之后。 美团曾经有一篇技术博客深入分析了 Category，并且从编译器和源码的角度对分类覆盖操作进行详细解析：《深入理解Objective-C：Category》 根据方法覆盖的原理，我们可以分析出哪些操作比较安全，哪些存在风险，并针对性地进行管理。接下来，我们就介绍美团 Category 管理相关的一些工作。 Category 方法管理 由于历史原因，不管是什么样的管理规则，都无法直接“一刀切”。所以针对现状，我们将整个管理环节先拆分为“数据”、“场景”、 “策略”三部分。 其中数据层负责发现异常数据，所有策略公用一个数据层。针对 Category 方法的数据获取，我们有如下几种方式： 根据优缺点的分析，再考虑到美团已经彻底实现了“组件化”的工程，所以对 Category 的管控最好放在集成阶段以后进行。我们最终选择了使用 linkmap 进行数据获取，具体方法我们将在下文进行介绍。 策略部分则针对不同的场景异常进行控制，主要的开发工作位于我们的组件化 CI 系统上，即之前介绍过的 《Hyperloop，让发布简洁高效》系统。 Hyperloop 本身即提供了包括白名单，发布集成流程管理等一系列策略功能，我们只需要将工具进行关联开发即可。我们开发的数据层作为一个独立组件，最终也是运行在 Hyperloop 上。 图5-2 方法管理环节 根据场景细分的策略如下表所示（需要注意的是，表中有的场景实际不存在，只是为了思考的严谨列出）： 我们在前文描述的 CategoryCoverOrigin 的组件通信方案的管控体现在第2点。风险管控中提到的两个案例的管控主要体现在第4点。 Category 数据获取原理 上一章节，我们提到了采用 linkmap 分析的方式进行 Category 数据获取。在这一章节内，我们详细介绍下做法。 启用 linkmap 首先，linkmap 生成功能是默认关闭的，我们需要在 build settings 内手动打开开关并配置存储路径。对于美团工程和美团外卖工程来说，每次正式构建后产生的 linkmap，我们还会通过内部的美团云存储工具进行持久化的存储，保证后续的可追溯。 图6 启用 linkmap 的设置 linkmap 组成 若要解析 linkmap，首先需要了解 linkmap 的组成。 如名称所示，linkmap 文件生成于代码链接之后，主要由4个部分组成：基本信息、Object files 表、Sections 表和 Symbols 表。 前两行是基本信息，包括链接完成的二进制路径和架构。如果一个工程内有多个最终产物（如 Watch App 或 Extension），则经过配置后，每一个产物的每一种架构都会生成一份 linkmap。 #&nbsp;Path:&nbsp;/var/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828-59923-v4pjhg/output-sandbox/DerivedData/Build/Intermediates.noindex/ArchiveIntermediates/imeituan/InstallationBuildProductsLocation/Applications/imeituan.app/imeituan#&nbsp;Arch:&nbsp;arm64 第二部分的 Object files，列举了链接所用到的所有的目标文件，包括代码编译出来的，静态链接库内的和动态链接库（如系统库），并且给每一个目标文件分配了一个 file id。 #&nbsp;Object&nbsp;files:[&nbsp;&nbsp;0]&nbsp;linker&nbsp;synthesized[&nbsp;&nbsp;1]&nbsp;dtrace[&nbsp;&nbsp;2]&nbsp;/var/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828-59923-v4pjhg/output-sandbox/DerivedData/Build/Intermediates.noindex/ArchiveIntermediates/imeituan/IntermediateBuildFilesPath/imeituan.build/DailyBuild-iphoneos/imeituan.build/Objects-normal/arm64/main.o……[&nbsp;26]&nbsp;/private/var/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828-59923-v4pjhg/repo-sandbox/imeituan/Pods/AFNetworking/bin/libAFNetworking.a(AFHTTPRequestOperation.o)……[25919]&nbsp;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/usr/lib/libobjc.tbd[25920]&nbsp;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/usr/lib/libSystem.tbd 第三部分的 Sections，记录了所有的 Section，以及它们所属的 Segment 和大小等信息。 #&nbsp;Sections:#&nbsp;Address&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Segment&nbsp;Section0x100004450&nbsp;&nbsp;&nbsp;&nbsp;0x07A8A8D0&nbsp;&nbsp;__TEXT&nbsp;&nbsp;__text……0x109EA52C0&nbsp;&nbsp;&nbsp;&nbsp;0x002580A0&nbsp;&nbsp;__DATA&nbsp;&nbsp;__objc_data0x10A0FD360&nbsp;&nbsp;&nbsp;&nbsp;0x001D8570&nbsp;&nbsp;__DATA&nbsp;&nbsp;__data0x10A2D58D0&nbsp;&nbsp;&nbsp;&nbsp;0x0000B960&nbsp;&nbsp;__DATA&nbsp;&nbsp;__objc_k_kylin……0x10BFE4E5D&nbsp;&nbsp;&nbsp;&nbsp;0x004CBE63&nbsp;&nbsp;__RODATA&nbsp;&nbsp;&nbsp;&nbsp;__objc_methname0x10C4B0CC0&nbsp;&nbsp;&nbsp;&nbsp;0x000D560B&nbsp;&nbsp;__RODATA&nbsp;&nbsp;&nbsp;&nbsp;__objc_classname 第四部分的 Symbols 是重头戏，列举了所有符号的信息，包括所属的 object file、大小等。符号除了我们关注的 OC 的方法、类名、协议名等，也包含 block、literal string 等，可以供其他需求分析进行使用。 #&nbsp;Symbols:#&nbsp;Address&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;&nbsp;Name0x1000045B8&nbsp;&nbsp;&nbsp;&nbsp;0x00000060&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_writeout0x100004618&nbsp;&nbsp;&nbsp;&nbsp;0x00000028&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_flush0x100004640&nbsp;&nbsp;&nbsp;&nbsp;0x00000014&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_init0x100004654&nbsp;&nbsp;&nbsp;&nbsp;0x00000014&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_init.40x100004668&nbsp;&nbsp;&nbsp;&nbsp;0x00000014&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_init.60x10000467C&nbsp;&nbsp;&nbsp;&nbsp;0x0000015C&nbsp;&nbsp;[&nbsp;&nbsp;3]&nbsp;_main……0x10002F56C&nbsp;&nbsp;&nbsp;&nbsp;0x00000028&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_imageRequestOperationForState:]0x10002F594&nbsp;&nbsp;&nbsp;&nbsp;0x0000002C&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_setImageRequestOperation:forState:]0x10002F5C0&nbsp;&nbsp;&nbsp;&nbsp;0x00000028&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_backgroundImageRequestOperationForState:]0x10002F5E8&nbsp;&nbsp;&nbsp;&nbsp;0x0000002C&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_setBackgroundImageRequestOperation:forState:]0x10002F614&nbsp;&nbsp;&nbsp;&nbsp;0x0000006C&nbsp;&nbsp;[&nbsp;38]&nbsp;+[UIButton(AFNetworking)&nbsp;sharedImageCache]0x10002F680&nbsp;&nbsp;&nbsp;&nbsp;0x00000010&nbsp;&nbsp;[&nbsp;38]&nbsp;+[UIButton(AFNetworking)&nbsp;setSharedImageCache:]0x10002F690&nbsp;&nbsp;&nbsp;&nbsp;0x00000084&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(AFNetworking)&nbsp;imageResponseSerializer]…… linkmap 数据化 根据上文的分析，在理解了 linkmap 的格式后，通过简单的文本分析即可提取数据。由于美团内部 iOS 开发工具链统一采用 Ruby，所以 linkmap 分析也采用 Ruby 开发，整个解析器被封装成一个 Ruby Gem。 具体实施上，处于通用性考虑，我们的 linkmap 解析工具分为解析、模型、解析器三层，每一层都可以单独进行扩展。 图7 linkmap解析工具 对于 Category 分析器来说，link map parser 解析指定 linkmap，生成通用模型的实例。从实例中获取 symbol 类，将名字中有“()”的符号过滤出来，即为 Category 方法。 接下来只要按照方法名聚合，如果超过1个则肯定有 Category 方法冲突的情况。按照上一节中分析的场景，分析其具体冲突类型，提供结论输出给 Hyperloop。 具体对外接口可以直接参考我们的工具测试用例。最后该 Gem 会直接被 Hyperloop 使用。 &nbsp;it&nbsp;&#39;should&nbsp;return&nbsp;a&nbsp;map&nbsp;with&nbsp;keys&nbsp;for&nbsp;method&nbsp;name&nbsp;and&nbsp;classify&#39;&nbsp;do&nbsp;&nbsp;&nbsp;&nbsp;@parser&nbsp;=&nbsp;LinkmapParser::Parser.new&nbsp;&nbsp;&nbsp;&nbsp;@file_path&nbsp;=&nbsp;&#39;spec/fixtures/imeituan-LinkMap-normal-arm64.txt&#39;&nbsp;&nbsp;&nbsp;&nbsp;@analyze_result_with_classification&nbsp;=&nbsp;@parser.parse&nbsp;@file_path&nbsp;&nbsp;&nbsp;&nbsp;expect(@analyze_result_with_classification.class).to&nbsp;eq(Hash)&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Category&nbsp;方法互相冲突&nbsp;&nbsp;&nbsp;&nbsp;symbol&nbsp;=&nbsp;@analyze_result_with_classification[&quot;-[NSDate&nbsp;isEqualToDateDay:]&quot;]&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol.class).to&nbsp;eq(Hash)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:type]).to&nbsp;eq([LinkmapParser::CategoryConflictType::CONFLICT])&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].class).to&nbsp;eq(Array)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].count).to&nbsp;eq(3)&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Category&nbsp;方法覆盖原方法&nbsp;&nbsp;&nbsp;&nbsp;symbol&nbsp;=&nbsp;@analyze_result_with_classification[&quot;-[UGCReviewManager&nbsp;setCommonConfig:]&quot;]&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol.class).to&nbsp;eq(Hash)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:type]).to&nbsp;eq([LinkmapParser::CategoryConflictType::REPLACE])&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].class).to&nbsp;eq(Array)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].count).to&nbsp;eq(2)&nbsp;&nbsp;end Category 方法管理总结 1. 风险管理 对于任何语法工具，都是有利有弊的。所以除了发掘它们在实际场景中的应用，也要时刻对它们可能带来的风险保持警惕，并选择合适的工具和时机来管理风险。 而 Xcode 本身提供了不少的工具和时机，可以供我们分析构建过程和产物。若是在日常工作中遇到一些坑，不妨从构建期工具的角度去考虑管理。比如本文内提到的 linkmap，不仅可以用于 Category 分析，还可以用于二进制大小分析、组件信息管理等。投入一定资源在相关工具开发上，往往可以获得事半功倍的效果。 2. 代码规范 回到 Category 的使用，除了工具上的管控，我们也有相应的代码规范，从源头管理风险。如我们在规范中要求所有的 Category 方法都使用前缀，降低无意冲突的可能。并且我们也计划把“使用前缀”做成管控之一。 3. 后续规划 （1）覆盖系统方法检查&nbsp;&nbsp; 由于目前在管控体系内暂时没有引入系统符号表，所以无法对覆盖系统方法的行为进行分析和拦截。我们计划后续和 Crash 分析系统打通符号表体系，提早发现对系统库的不当覆盖。 （2）工具复用&nbsp;&nbsp; 当前的管控系统仅针对美团外卖和美团 App，未来计划推广到其他 App。由于有 Hyperloop，事情在技术上并没有太大的难度。&nbsp;&nbsp; 从工具本身的角度看，我们有计划在合适的时机对数据层代码进行开源，希望能对更多的开发有所帮助。 总结 在这篇文章中，我们从具体的业务场景入手，总结了组件间调用的通用模型，并对常用的解耦方案进行了分析对比，最终选择了目前最适合我们业务场景的方案。即通过 Category 覆盖的方式实现了依赖倒置，将构建时依赖延后到了运行时，达到我们预期的解耦目标。同时针对该方案潜在的问题，通过 linkmap 工具管控的方式进行规避。 另外，我们在模型设计时也提到，组件间解耦其实在 iOS 侧有多种方案选择。对于其他的方案实践，我们也会陆续和大家分享。希望我们的工作能对大家的 iOS 开发组件间解耦工作有所启发。 作者简介 尚先，美团资深工程师。2015年加入美团，目前作为美团外卖 iOS 端平台化虚拟小组组长，主要负责业务架构、持续集成和工程化相关工作。同时也是移动端领域新技术的爱好者，负责多项新技术在外卖业务落地中的难点攻关，目前个人拥有七项国家发明专利。 泽响，美团技术专家，2014年加入美团，先后负责过公司 iOS 持续集成体系建设，美团 iOS 端平台业务，美团 iOS 端基础业务等工作。目前作为美团移动平台架构平台组 Team Leader，主要负责美团 App 平台架构、组件化、研发流程优化和部分基础设施建设，致力于提升平台上全业务的研发效率与质量。 欢迎加入美团iOS技术交流群，跟作者零距离交流。进群方式：请加美美同学的微信（微信号：MTDPtech01），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 美团外卖长期招聘 iOS、Android、FE 高级/资深工程师和技术专家，Base 北京、上海、成都，欢迎有兴趣的同学投递简历到 chenhang03@meituan.com。&nbsp; 也许你还想看 【美团技术团队博客】前端组件化开发实践 用微前端的方式搭建类单页应用 美团扫码付的前端可用性保障实践" />
<meta property="og:description" content="总第300篇 2018年 第92篇 背景 iOS Category功能简介 Category 是 Objective-C 2.0之后添加的语言特性。 Category 就是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。在 Objective-C（iOS 的开发语言，下文用 OC 代替）中的具体体现为：实例（类）方法、属性和协议。 除了引用中提到的添加方法，Category 还有很多优势，比如将一个类的实现拆分开放在不同的文件内，以及可以声明私有方法，甚至可以模拟多继承等操作，具体可参考官方文档Category。 若 Category 添加的方法是基类已经存在的，则会覆盖基类的同名方法。本文将要提到的组件间通信都是基于这个特性实现的，在本文的最后则会提到对覆盖风险的管控。 组件通信的背景 随着移动互联网的快速发展，不断迭代的移动端工程往往面临着耦合严重、维护效率低、开发不够敏捷等常见问题，因此越来越多的公司开始推行“组件化”，通过解耦重组组件来提高并行开发效率。 但是大多数团队口中的“组件化”就是把代码分库，主工程使用 CocoaPods 工具把各个子库的版本号聚合起来。但能合理的把组件分层，并且有一整套工具链支撑发版与集成的公司较少，导致开发效率很难有明显地提升。 处理好各个组件之间的通信与解耦一直都是组件化的难点。诸如组件之间的 Podfile 相互显式依赖，以及各种联合发版等问题，若处理不当可能会引发“灾难”性的后果。 目前做到 ViewController （指iOS中的页面，下文用VC代替）级别解耦的团队较多，维护一套 mapping 关系并使用 scheme 进行跳转，但是目前仍然无法做到更细粒度的解耦通信，依然满足不了部分业务的需求。 实际业务案例 例1：外卖的首页的商家列表（WMPageKit），在进入一个商家（WMRestaurantKit）选择5件商品返回到首页的时候，对应的商家cell需要显示已选商品“5”。 例2：搜索结果（WMSearchKit）跳转到商超的容器页（WMSupermarketKit），需要传递一个通用Domain（也有的说法叫模型、Model、Entity、Object等等，下文统一用Domain表示）。 例3：做一键下单需求（WMPageKit），需要调用下单功能的一个方法（WMOrderKit）入参是一个订单相关 Domain 和一个 VC，不需要返回值。 这几种场景基本涵盖了组件通信所需的基本功能，那么怎样才可以实现最优雅的解决方案？ 组件通信的探索 模型分析 对于上文提到的实际业务案例，很容易想到的应对方案有三种，第一是拷贝共同依赖代码，第二是直接依赖，第三是下沉公共依赖。 对于方案一，会维护多份冗余代码，逻辑更新后代码不同步，显然是不可取的。对于方案二，对于调用方来说，会引入较多无用依赖，且可能造成组件间的循环依赖问题，导致组件无法发布。对于方案三，其实是可行解，但是开发成本较大。对于下沉出来的组件来说，其实很难找到一个明确的定位，最终沦为多个组件的“大杂烩”依赖，从而导致严重的维护性问题。 那如何解决这个问题呢？根据面向对象设计的五大原则之一的“依赖倒置原则”（Dependency Inversion Principle），高层次的模块不应该依赖于低层次的模块，两者（的实现）都应该依赖于抽象接口。推广到组件间的关系处理，对于组件间的调用和被调用方，从本质上来说，我们也需要尽量避免它们的直接依赖，而希望它们依赖一个公共的抽象层，通过架构工具来管理和使用这个抽象层。这样我们就可以在解除组件间在构建时不必要的依赖，从而优雅地实现组件间的通讯。 图1-1 模型设计 业界现有方案的几大方向 实践倒置原则的方案有很多，在 iOS 侧，OC 语言和 Foundation 库给我们提供了数个可用于抽象的语言工具。在这一节我们将对其中部分实践进行分析。 1. 使用依赖注入 代表作品有 Objection 和 Typhoon，两者都是 OC 中的依赖注入框架，前者轻量级，后者较重并支持 Swift。 比较具有通用性的方法是使用「协议」 &lt;-&gt; 「类」绑定的方式，对于要注入的对象会有对应的 Protocol 进行约束，会经常看到一些RegisterClass:ForProtocol：和classFromProtocol的代码。在需要使用注入对象时，用框架提供的接口以协议作为入参从容器中获得初始化后的所需对象。也可以在 Register 的时候直接注册一段 Block-Code，这个代码块用来初始化自己，作为id类型的返回值返回，可以支持一些编译检查来确保对应代码被编译。 美团内推行将一些运行时加载的操作前移至编译时，比如将各项注册从 +load 改为在编译期使用__attribute((used,section(&quot;__DATA,key&quot;))) 写入 mach-O 文件 Data 的 Segment 中来减少冷启动的时间消耗。 因此，该方案的局限性在于：代码块存取的性能消耗较大，并且协议与类的绑定关系的维护需要花费更多的时间成本。 2. 基于SPI机制 全称是 Service Provider Interfaces，代表作品是 ServiceLoader。 实现过程大致是：A库与B库之间无依赖，但都依赖于P平台。把B库内的一个接口I下沉到平台层（“平台层”也叫做“通用能力层”，下文统一用平台层表示），入参和返回值的类型需要平台层包含，接口I的实现放在B库里（因为实现在B库，所以实现里可以正常引用B库的元素）。然后A库通过P平台的这个接口I来实现功能。A可以调用的到接口I，但是在B的库中进行实现。 在A库需要通过一个接口I实例化出一个对象，使用ServiceLoader.load（接口，key），通过注册过的key使用反射找到这个接口imp的文件路径然后得到这个实例对象调用对应接口。 这个操作在安卓中使用较为广泛，大致相当于用反射操作来替代一次了 import 这样的耦合引用。但实际上iOS中若使用反射来实现功能则完全不必这么麻烦。 关于反射，Java可以实现类似于ClassFromString的功能，但是无法直接使用 MethodFromString的功能。并且ClassFromString也是通过字符串map到这个类的文件路径，类似于 com.waimai.home.searchImp，从而可以获得类型然后实例化，而OC的反射是通过消息机制实现。 3. 基于通知中心 之前和一个做读书类App的同学交流，发现行业内有些公司的团队在使用 NotificationCenter 进行一些解耦的通信，因为通知中心本身支持传递对象，并且通知中心的功能也原生支持同步执行，所以也可以达到目的。 通知中心在iOS 9之后有一次比较大的升级，将通知支持了 request 和 response 的处理逻辑，并支持获取到通知的发送者。比以往的通知群发但不感知发送者和是否收到，进步了很多。 字符串的约定也可以理解为一个简化的协议，可设置成宏或常量放在平台层进行统一的维护。 比较明显的缺陷是开发的统一范式难以约束，风格迥异，且字符串相较于接口而言还是难以管理。 4. 使用objc_msgSend 这是iOS原生消息机制中最万能的方法，编写时会有一些硬编码。核心代码如下： id&nbsp;s&nbsp;=&nbsp;((id(*)(id,&nbsp;SEL))objc_msgSend)(ClassName,@selector(methodName));&nbsp; 这种方法的特点是即插即用，在开发者能100%确定整条调用链没问题的时候，可以快速实现功能。 此方案的缺陷在于编写十分随意，检查和校验的逻辑还不够，满屏的强转。对于 int、Integer、NSNumber 这样的很容易发生类型转换错误，结果虽然不报错，但数字会有错误。 方案对比 接下来，我们对这几个大方向进行一些性能对比。 考虑到在公司内的实际用法与限制，可能比常规方法增加了若干步骤，结果也可能会与常规裸测存在一定的偏差。 例如依赖注入常用做法是存在单例（内存）里，但是我们为了优化冷启动时间都写入 mach-O 文件 Data 的 Segment 里了，所以在我们的统计口径下存取时间会相对较长。 //&nbsp;为了不暴露类名将业务属性用“some”代替，并隐藏初始化、循环100W次、差值计算等代码，关键操作代码如下//&nbsp;存取注入对象xxConfig&nbsp;=&nbsp;[[WMSomeGlueCore&nbsp;sharedInstance]&nbsp;createObjectForProtocol:@protocol(WMSomeProtocol)];//&nbsp;通知发送[[NSNotificationCenter&nbsp;defaultCenter]postNotificationName:@&quot;nixx&quot;&nbsp;object:nil];//&nbsp;原生接口调用a&nbsp;=&nbsp;[WMSomeClass&nbsp;class];//&nbsp;反射调用b&nbsp;=&nbsp;objc_getClass(&quot;WMSomeClass&quot;); 运行结果显示如下： 图1-2 性能消耗检测 可以看出原生的接口调用明显是最高效的用法，反射的时长比原生要多一个数量级，不过100W次也就是多了几十毫秒，还在可以接受的范围之内。通知发送相比之下性能就很低了，存取注入对象更低。 当然除了性能消耗外，还有很多不好量化的维度，包括规范约束、功能性、代码量、可读性等，笔者按照实际场景客观评价给出对比的分值。 下面，我们用五种维度的能力值图来对比每一种方案优缺点： 各维度的的评分考虑到了一定的实际场景，可能和常规结果稍有偏差。 已经做了转化，看图面积越大越优。可读性的维度越长代表可读性越高，代码量的维度越长代表代码成本越少。 图2-1 各方案优缺点对比 如图2所示，可以看出上图的四种方式或多或少都存在一些缺点： 依赖注入是因为美团的实际场景问题，所以在性能消耗上存在明显的短板，并且代码量和可读性都不突出，规范约束这里是亮点。 SPI机制的范围图很大，但使用了反射，并且代码开发成本较高，实践上来看，对协议管理有一定要求。 通知中心除了代码少一些，其他维度都是短板。 而msgsend功能强大，代码量也少，但是在规范约束和可读性上几乎为零。 综合看来 SPI 和 objc_msgSend 两者的特点比较明显，很有潜力，如果针对这两种方案分别进行一定程度的完善，应该可以实现一个综合评分更高的方案。 从现有方案中完善或衍生出的方案 5. 使用Category+NSInvocation 此方案从 objc_msgSend 演化而来。NSInvocation 的调用方式的底层还是会使用到 objc_msgSend，但是通过一些方法签名和返回值类型校验，可以解决很多类型规范相关的问题，并且这种方式没有繁琐的注册步骤，任何一次新接口的添加，都可以直接在低层的库中进行完成。 为了更进一步限制调用者能够调用的接口，创建一些 Category 来提供接口，内部包装下层接口，把返回值和入参都限制实际的类型。业界比较接近的例子有 casatwy 的 CTMediator。 6. 原生CategoryCoverOrigin方式 此方案从 SPI 方式演化而来。两个的共同点是都在平台层提供接口供业务方调用，不同点是此方式完全规避了各种硬编码。而且 CategoryCoverOrigin 是一个思想，没有任何框架代码，可以说 OC 的 Runtime 就是这个方案的框架支撑。此方案的核心操作是在基类里汇总所有业务接口，在上层的业务库中创建基类的 Category 中对声明的接口进行覆盖。整个过程没有任何硬编码与反射。 演化出的这两种方案能力评估如下（绿色部分），图中也贴了和演化前方案（桔色部分）的对比： 图2-2 两种演化方案对比 上文对这两种方案描述的非常概括，可能有同学会对能力评估存在质疑。接下来会分别进行详解的介绍，并描述在实际操作值得注意的细节。这两种方案组合成了外卖内部的组件通信框架 WMScheduler。 WMScheduler组件通信 外卖的 WMScheduler 主要是通过对 Category 特性的运用来实现组件间通信，实际操作中有两种的应用方案：Category+NSInvocation 和 CategoryCoverOrigin。 1. Category+NSInvocation方案 方案简介 这个方案将其对 NSInvocation 功能容错封装、参数判断、类型转换的代码写在下层，提供简易万能的接口。并在上层创建通信调度器类提供常用接口，在调度器的 Category 里扩展特定业务的专用接口。所有的上层接口均有规范约束，这些规范接口的内部会调用下层的简易万能接口即可通过NSInvocation 相关的硬编码操作调用任何方法。 UML图 图3-1 Category+NSInvocation的UML图 如图3-1所示，代码的核心在 WMSchedulerCore 类，其包含了基于 NSInvocation 对 target 与 method 的操作、对参数的处理（包括对象，基本数据类型，NULL类型）、对异常的处理等等，最终开放了简洁的万能接口，接口参数有 target、method、parameters等等，然后内部帮我们完成调用。但这个接口并不是让上层业务直接进行调用，而是需要创建一个 WMSchedule r的 Category，在这个 Category 中编写规范的接口（前缀、入参类型、返回值类型都是确定的）。 值得一提的是，提供业务专用接口的 Category 没有以 WMSchedulerCore 为基类，而是以 WMScheduler 为基类。看似多此一举，实际上是为了做权限的隔离。上层业务只能访问到 WMScheduler.h 及其 Category 的规范接口。并不能访问到 WMSchedulerCore.h 提供的“万能但不规范”接口。 例如：在UML图中可以看到 外界只可以调用到wms_getOrderCountWithPoiid（规范接口），并不能使用wm_excuteInstance Method（万能接口）。 为了更好地理解实际使用，笔者贴一个组件调用周期的完整代码： 图3-2 Category+NSInvocation的示例图 如图3-2，在这种方案下，“B库调用A库方法”的需求只需要改两个仓库的代码，需要改动的文件标了下划线，请仔细看下示例代码。 示例代码 平台（通用功能）库三个文件： ① //&nbsp;WMScheduler+AKit.h#import&nbsp;&quot;WMScheduler.h&quot;@interface&nbsp;WMScheduler(AKit)/**&nbsp;*&nbsp;通过商家id查到当前购物车已选e的小红点数量&nbsp;*&nbsp;@param&nbsp;poiid&nbsp;&nbsp;商家id&nbsp;*&nbsp;@return&nbsp;实际的小红点数量&nbsp;*/+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID;@end ② //&nbsp;WMScheduler+AKit.m#import&nbsp;&quot;WMSchedulerCore.h&quot;#import&nbsp;&quot;WMScheduler+AKit.h&quot;#import&nbsp;&quot;NSObject+WMScheduler.h&quot;@implementation&nbsp;WMScheduler&nbsp;(AKit)+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID{&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nil&nbsp;==&nbsp;poiid)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;}#pragma&nbsp;clang&nbsp;diagnostic&nbsp;push#pragma&nbsp;clang&nbsp;diagnostic&nbsp;ignored&nbsp;&quot;-Wundeclared-selector&quot;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;singleton&nbsp;=&nbsp;[wm_scheduler_getClass(&quot;WMXXXSingleton&quot;)&nbsp;wm_executeMethod:@selector(sharedInstance)];&nbsp;&nbsp;&nbsp;&nbsp;NSNumber*&nbsp;orderFoodCount&nbsp;=&nbsp;[singleton&nbsp;wm_executeMethod:@selector(calculateOrderedFoodCountWithPoiID:)&nbsp;params:@[poiID]];&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;orderFoodCount&nbsp;==&nbsp;nil&nbsp;?&nbsp;0&nbsp;:&nbsp;[orderFoodCount&nbsp;integerValue];#pragma&nbsp;clang&nbsp;diagnostic&nbsp;pop}@end ③ //&nbsp;WMSchedulerInterfaceList.h#ifndef&nbsp;WMSchedulerInterfaceList_h#define&nbsp;WMSchedulerInterfaceList_h//&nbsp;这个文件会被加到上层业务的pch里，所以下文不用import本文件#import&nbsp;&quot;WMScheduler.h&quot;#import&nbsp;&quot;WMScheduler+AKit.h&quot;#endif&nbsp;/*&nbsp;WMSchedulerInterfaceList_h&nbsp;*/ BKit （调用方）一个文件： //&nbsp;WMHomeVC.m@interface&nbsp;WMHomeVC&nbsp;()&nbsp;&lt;UITableViewDataSource,&nbsp;UITableViewDelegate&gt;@end@implementation&nbsp;WMHomeVC...&nbsp;&nbsp;&nbsp;&nbsp;NSUInteger&nbsp;*foodCount&nbsp;=&nbsp;[WMScheduler&nbsp;wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%ld&quot;,foodCount);...@end 代码分析 上文四个文件完成了一次跨组件的调用，在 WMScheduler+AKit.m 中的第30、31行，调用的都是AKit（提供方）的现有方法，因为 WMSchedulerCore 提供了 NSInvocation 的调用方式，所以可以直接向上调用。WMScheduler+AKit 中提供的接口就是上文说的“规范接口”，这个接口在WMHomeVC（调用方）调用时和调用本仓库内的OC方法，并没有区别。 延伸思考 上文的例子中入参和返回值都是基本数据类型，Domain 也是支持的，前提是这个 Domain 是放在平台库的。我们可以将工程中的 Domain 分为BO（Business Object）、VO（View Object）与TO（Transfer Object），VO 经常出现在 view 和 cell，BO一般仅在各业务子库内部使用，这个TO则是需要放在平台库是用于各个组件间的通信的通用模型。例如：通用 PoiDomain，通用 OrderDomain，通用 AddressDomain 等等。这些称为 TO 的 Domain 可以作为规范接口的入参类型或返回值类型。 在实际业务场景中，跳转页面时传递 Domain 的需求也是一个老生常谈的问题，大多数页面级跳转框架仅支持传递基本数据类型（也有 trick 的方式传 Domain 内存地址但很不优雅）。在有了上文支持的能力，我们可以在规范接口内通过万能接口获取目标页面的VC，并调用其某个属性的 set 方法将我们想传递的Domain赋值过去，然后将这个 VC 对象作为返回值返回。调用方获得这个 VC 后在当前的导航栈内push即可。 上文代码中我们用 WMScheduler 调用了 Akit 的一个名为calculateOrderedFoodCount WithPoiID：的方法。那么有个争议点：在组件通信需要调用某方法时，是允许直接调用现有方法，还是复制一份加上前缀标注此方法专门用于提供组件通信？ 阶段总结 Category+NSInvocation 方案的优点是便捷，因为 Category 的专用接口放在平台库，以后有除了 BKit 以外的其他调用方也可以直接调用，还有更多强大的功能。 但是，不优雅的地方我们也列举一下： 当这个跨组件方法内部的代码行数比较多时，会写很多硬编码。 硬编码method字符串，在现有方法被修改时，编译检测不报错（只能靠断言约束）。 下层库向上调用的设计会被诟病。 接下来介绍的 CategoryCoverOrigin 的方案，可以解决这三个问题。 2. CategoryCoverOrigin方案 方案简介 首先说明下这个方案和 NSInvocation 没有任何关系，此方案与上一方案也是完全不同的两个概念，不要将上一个方案的思维带到这里。 此方案的思路是在平台层的 WMScheduler.h 提供接口方法，接口的实现只写空实现或者兜底实现（兜底实现中可根据业务场景在 Debug 环境下增加 toast 提示或断言），上层库的提供方实现接口方法并通过 Category 的特性，在运行时进行对基类同名方法的替换。调用方则正常调用平台层提供的接口。在 CategoryCoverOrigin 的方案中 WMScheduler 的 Category 在提供方仓库内部，因此业务逻辑的依赖可以在仓库内部使用常规的OC调用。 UML图 图4-1 CategoryCover 的 UML 图 从图4-1可以看出，WMScheduler 的 Category 被移到了业务仓库，并且 WMScheduler 中有所有接口的全集。 为了更好地理解 CategoryCover 实际应用，笔者再贴一个此方案下的完整代码： 图4-2 CategoryCover的示例图 如图4-2，在这种方案下，“B库调用A库方法”的需求需要修改三个仓库的代码，但除了这四个编辑的文件，没有其他任何的依赖了，请仔细看下代码示例。 示例代码 平台（通用功能库）两个文件： ① //&nbsp;&nbsp;WMScheduler.h@interface&nbsp;WMScheduler&nbsp;:&nbsp;NSObject//&nbsp;&nbsp;这个文件是所有组件通信方法的汇总#pragma&nbsp;mark&nbsp;-&nbsp;AKit&nbsp;&nbsp;/**&nbsp;*&nbsp;通过商家id查到当前购物车已选e的小红点数量&nbsp;*&nbsp;@param&nbsp;poiid&nbsp;&nbsp;商家id&nbsp;*&nbsp;@return&nbsp;实际的小红点数量&nbsp;*/+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID;#pragma&nbsp;mark&nbsp;-&nbsp;CKit//&nbsp;...#pragma&nbsp;mark&nbsp;-&nbsp;DKit//&nbsp;...@end ② //&nbsp;WMScheduler.m#import&nbsp;&quot;WMScheduler.h&quot;@implementation&nbsp;WMScheduler#pragma&nbsp;mark&nbsp;-&nbsp;Akit+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;//&nbsp;这个.m里只要求一个空实现&nbsp;作为兜底方案。}#pragma&nbsp;mark&nbsp;-&nbsp;Ckit//&nbsp;...#pragma&nbsp;mark&nbsp;-&nbsp;Dkit//&nbsp;...@end AKit（提供方）一个 Category 文件： //&nbsp;WMScheduler+AKit.m#import&nbsp;&quot;WMScheduler.h&quot;#import&nbsp;&quot;WMAKitBusinessManager.h&quot;#import&nbsp;&quot;WMXXXSingleton.h&quot;&nbsp;&nbsp;//&nbsp;直接导入了很多AKit相关的业务文件，因为本身就在AKit仓库内@implementation&nbsp;WMScheduler&nbsp;(AKit)//&nbsp;这个宏可以屏蔽分类覆盖基类方法的警告#pragma&nbsp;clang&nbsp;diagnostic&nbsp;push#pragma&nbsp;clang&nbsp;diagnostic&nbsp;ignored&nbsp;&quot;-Wobjc-protocol-method-implementation&quot;//&nbsp;在平台层写过的方法，这边是是自动补全的+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nil&nbsp;==&nbsp;poiid)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;所有AKIT相关的类都能直接接口调用，不需要任何硬编码，可以和之前的写法对比下。&nbsp;&nbsp;&nbsp;&nbsp;WMXXXSingleton&nbsp;*singleton&nbsp;=&nbsp;[WMXXXSingleton&nbsp;sharedInstance];&nbsp;&nbsp;&nbsp;&nbsp;NSNumber&nbsp;*orderFoodCount&nbsp;=&nbsp;[singleton&nbsp;calculateOrderedFoodCountWithPoiID:poiID];&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;orderFoodCount&nbsp;==&nbsp;nil&nbsp;?&nbsp;0&nbsp;:&nbsp;[orderFoodCount&nbsp;integerValue];}#pragma&nbsp;clang&nbsp;diagnostic&nbsp;pop@end BKit（调用方） 一个文件写法不变： //&nbsp;WMHomeVC.m@interface&nbsp;WMHomeVC&nbsp;()&nbsp;&lt;UITableViewDataSource,&nbsp;UITableViewDelegate&gt;@end@implementation&nbsp;WMHomeVC...&nbsp;&nbsp;&nbsp;&nbsp;NSUInteger&nbsp;*foodCount&nbsp;=&nbsp;[WMScheduler&nbsp;wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%ld&quot;,foodCount);...@end 代码分析 CategoryCoverOrigin 的方式，平台库用 WMScheduler.h 文件存放所有的组件通信接口的汇总，各个仓库用注释隔开，并在.m文件中编写了空实现。功能代码编写在服务提供方仓库的 WMScheduler+AKit.m，看这个文件的17、18行业务逻辑是使用常规 OC 接口调用。在运行时此Category的方法会覆盖 WMScheduler.h 基类中的同名方法，从而达到目的。CategoryCoverOrigin 方式不需要其他功能类的支撑。 延伸思考 如果业务库很多，方法很多，会不会出现 WMScheduler.h 爆炸？ &nbsp;目前我们的工程跨组件调用的实际场景不是很多，所以汇总在一个文件了，如果满屏都是跨组件调用的工程，则需要思考业务架构与模块划分是否合理这一问题。当然，如果真出现 WMScheduler.h 爆炸的情况，完全可以将各个业务的接口移至自己Category 的.h文件中，然后创建一个 WMSchedulerInterfaceList 文件统一 import 这些 Category。 两种方案的选择 刚才我们对于 Category+NSInvocation 和 CategoryCoverOrigin 两种方式都做了详细的介绍，我们再整理一下两者的优缺点对比： 笔者更建议使用 CategoryCoverOrigin 的无硬编码的方案，当然具体也要看项目的实际场景，从而做出最优的选择。 更多建议 关于组件对外提供的接口，我们更倾向于借鉴 SPI 的思想，作为一个 Kit 哪些功能是需要对外公开的？提供哪些服务给其他方解耦调用？建议主动开放核心方法，尽量减少“用到才补”的场景。例如全局购物车就需要“提供获取小红点数量的方法”，商家中心就需要提供“根据字符串 id 得到整个 Poi 的 Domain”的接口服务。 需要考虑到抽象能力，提供更有泛用性的接口。比如“获取到了最低满减价格后拼接成一个文案返回字符串” 这个方法，就没有“获取到了最低满减价格” 这个方法具备泛用性。 Category风险管控 先举两个发生过的案例 1. 2017年10月 一个关于NSDate重复覆盖的问题 当时美团平台有 NSDate+MTAddition 类，在外卖侧有 NSDate+WMAddition 类。前者 NSDate+MTAddition 之前就有方法 getCurrentTimestamp，返回的时间戳是秒。后者 NSDate+WMAddition 在一次需求中也增加了 getCurrentTimestamp 方法，但是为了和其他平台统一口径返回值使用了毫秒。在正常的加载顺序中外卖类比平台类要晚，因此在外卖的测试中没有发现问题。但集成到 imeituan 主项目之后，原先其他业务方调用这个返回“秒”的方法，就被外卖测的返回“毫秒”的同名方法给覆盖了，出现接口错误和UI错乱等问题。 2. 2018年3月 一个WMScheduler组件通信遇到的问题 在外卖侧有订单组件和商家容器组件，这两个组件的联系是十分紧密的，有的功能放在两个仓库任意一个中都说的通。因此出现了了两个仓库写了同名方法的场景。在 WMScheduler+Restaurant 和 WMScheduler+Order 两个仓库都添加了方法 -(void)wms_enterGlobalCartPageFromPage:，在运行中这两处有一处被覆盖。在有一次 Bug 解决中，给其中一处增加了异常处理的代码，恰巧增加的这处先加载，就被后加载的同名方法覆盖了，这就导致了异常处理代码不生效的问题。 那么使用 CategoryCover 的方式是不是很不安全？ NO！只要弄清其中的规律，风险点都是完全可以管控的，接下来，我们来分析 Category 的覆盖原理。 Category 方法覆盖原理 1) Category 的方法没有“完全替换掉”原来类已经有的方法，也就是说如果 Category 和原来类都有methodA，那么 Category 附加完成之后，类的方法列表里会有两个 methodA。 2) Category 方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的 Category 的方法会“覆盖”掉原来类的同名方法，这是因为运行过程中，我们在查找方法的时候会顺着方法列表的顺序去查找，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。 Category 在运行期进行决议，而基类的类是在编译期进行决议，因此分类中，方法的加载顺序一定在基类之后。 美团曾经有一篇技术博客深入分析了 Category，并且从编译器和源码的角度对分类覆盖操作进行详细解析：《深入理解Objective-C：Category》 根据方法覆盖的原理，我们可以分析出哪些操作比较安全，哪些存在风险，并针对性地进行管理。接下来，我们就介绍美团 Category 管理相关的一些工作。 Category 方法管理 由于历史原因，不管是什么样的管理规则，都无法直接“一刀切”。所以针对现状，我们将整个管理环节先拆分为“数据”、“场景”、 “策略”三部分。 其中数据层负责发现异常数据，所有策略公用一个数据层。针对 Category 方法的数据获取，我们有如下几种方式： 根据优缺点的分析，再考虑到美团已经彻底实现了“组件化”的工程，所以对 Category 的管控最好放在集成阶段以后进行。我们最终选择了使用 linkmap 进行数据获取，具体方法我们将在下文进行介绍。 策略部分则针对不同的场景异常进行控制，主要的开发工作位于我们的组件化 CI 系统上，即之前介绍过的 《Hyperloop，让发布简洁高效》系统。 Hyperloop 本身即提供了包括白名单，发布集成流程管理等一系列策略功能，我们只需要将工具进行关联开发即可。我们开发的数据层作为一个独立组件，最终也是运行在 Hyperloop 上。 图5-2 方法管理环节 根据场景细分的策略如下表所示（需要注意的是，表中有的场景实际不存在，只是为了思考的严谨列出）： 我们在前文描述的 CategoryCoverOrigin 的组件通信方案的管控体现在第2点。风险管控中提到的两个案例的管控主要体现在第4点。 Category 数据获取原理 上一章节，我们提到了采用 linkmap 分析的方式进行 Category 数据获取。在这一章节内，我们详细介绍下做法。 启用 linkmap 首先，linkmap 生成功能是默认关闭的，我们需要在 build settings 内手动打开开关并配置存储路径。对于美团工程和美团外卖工程来说，每次正式构建后产生的 linkmap，我们还会通过内部的美团云存储工具进行持久化的存储，保证后续的可追溯。 图6 启用 linkmap 的设置 linkmap 组成 若要解析 linkmap，首先需要了解 linkmap 的组成。 如名称所示，linkmap 文件生成于代码链接之后，主要由4个部分组成：基本信息、Object files 表、Sections 表和 Symbols 表。 前两行是基本信息，包括链接完成的二进制路径和架构。如果一个工程内有多个最终产物（如 Watch App 或 Extension），则经过配置后，每一个产物的每一种架构都会生成一份 linkmap。 #&nbsp;Path:&nbsp;/var/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828-59923-v4pjhg/output-sandbox/DerivedData/Build/Intermediates.noindex/ArchiveIntermediates/imeituan/InstallationBuildProductsLocation/Applications/imeituan.app/imeituan#&nbsp;Arch:&nbsp;arm64 第二部分的 Object files，列举了链接所用到的所有的目标文件，包括代码编译出来的，静态链接库内的和动态链接库（如系统库），并且给每一个目标文件分配了一个 file id。 #&nbsp;Object&nbsp;files:[&nbsp;&nbsp;0]&nbsp;linker&nbsp;synthesized[&nbsp;&nbsp;1]&nbsp;dtrace[&nbsp;&nbsp;2]&nbsp;/var/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828-59923-v4pjhg/output-sandbox/DerivedData/Build/Intermediates.noindex/ArchiveIntermediates/imeituan/IntermediateBuildFilesPath/imeituan.build/DailyBuild-iphoneos/imeituan.build/Objects-normal/arm64/main.o……[&nbsp;26]&nbsp;/private/var/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828-59923-v4pjhg/repo-sandbox/imeituan/Pods/AFNetworking/bin/libAFNetworking.a(AFHTTPRequestOperation.o)……[25919]&nbsp;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/usr/lib/libobjc.tbd[25920]&nbsp;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/usr/lib/libSystem.tbd 第三部分的 Sections，记录了所有的 Section，以及它们所属的 Segment 和大小等信息。 #&nbsp;Sections:#&nbsp;Address&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Segment&nbsp;Section0x100004450&nbsp;&nbsp;&nbsp;&nbsp;0x07A8A8D0&nbsp;&nbsp;__TEXT&nbsp;&nbsp;__text……0x109EA52C0&nbsp;&nbsp;&nbsp;&nbsp;0x002580A0&nbsp;&nbsp;__DATA&nbsp;&nbsp;__objc_data0x10A0FD360&nbsp;&nbsp;&nbsp;&nbsp;0x001D8570&nbsp;&nbsp;__DATA&nbsp;&nbsp;__data0x10A2D58D0&nbsp;&nbsp;&nbsp;&nbsp;0x0000B960&nbsp;&nbsp;__DATA&nbsp;&nbsp;__objc_k_kylin……0x10BFE4E5D&nbsp;&nbsp;&nbsp;&nbsp;0x004CBE63&nbsp;&nbsp;__RODATA&nbsp;&nbsp;&nbsp;&nbsp;__objc_methname0x10C4B0CC0&nbsp;&nbsp;&nbsp;&nbsp;0x000D560B&nbsp;&nbsp;__RODATA&nbsp;&nbsp;&nbsp;&nbsp;__objc_classname 第四部分的 Symbols 是重头戏，列举了所有符号的信息，包括所属的 object file、大小等。符号除了我们关注的 OC 的方法、类名、协议名等，也包含 block、literal string 等，可以供其他需求分析进行使用。 #&nbsp;Symbols:#&nbsp;Address&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;&nbsp;Name0x1000045B8&nbsp;&nbsp;&nbsp;&nbsp;0x00000060&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_writeout0x100004618&nbsp;&nbsp;&nbsp;&nbsp;0x00000028&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_flush0x100004640&nbsp;&nbsp;&nbsp;&nbsp;0x00000014&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_init0x100004654&nbsp;&nbsp;&nbsp;&nbsp;0x00000014&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_init.40x100004668&nbsp;&nbsp;&nbsp;&nbsp;0x00000014&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_init.60x10000467C&nbsp;&nbsp;&nbsp;&nbsp;0x0000015C&nbsp;&nbsp;[&nbsp;&nbsp;3]&nbsp;_main……0x10002F56C&nbsp;&nbsp;&nbsp;&nbsp;0x00000028&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_imageRequestOperationForState:]0x10002F594&nbsp;&nbsp;&nbsp;&nbsp;0x0000002C&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_setImageRequestOperation:forState:]0x10002F5C0&nbsp;&nbsp;&nbsp;&nbsp;0x00000028&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_backgroundImageRequestOperationForState:]0x10002F5E8&nbsp;&nbsp;&nbsp;&nbsp;0x0000002C&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_setBackgroundImageRequestOperation:forState:]0x10002F614&nbsp;&nbsp;&nbsp;&nbsp;0x0000006C&nbsp;&nbsp;[&nbsp;38]&nbsp;+[UIButton(AFNetworking)&nbsp;sharedImageCache]0x10002F680&nbsp;&nbsp;&nbsp;&nbsp;0x00000010&nbsp;&nbsp;[&nbsp;38]&nbsp;+[UIButton(AFNetworking)&nbsp;setSharedImageCache:]0x10002F690&nbsp;&nbsp;&nbsp;&nbsp;0x00000084&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(AFNetworking)&nbsp;imageResponseSerializer]…… linkmap 数据化 根据上文的分析，在理解了 linkmap 的格式后，通过简单的文本分析即可提取数据。由于美团内部 iOS 开发工具链统一采用 Ruby，所以 linkmap 分析也采用 Ruby 开发，整个解析器被封装成一个 Ruby Gem。 具体实施上，处于通用性考虑，我们的 linkmap 解析工具分为解析、模型、解析器三层，每一层都可以单独进行扩展。 图7 linkmap解析工具 对于 Category 分析器来说，link map parser 解析指定 linkmap，生成通用模型的实例。从实例中获取 symbol 类，将名字中有“()”的符号过滤出来，即为 Category 方法。 接下来只要按照方法名聚合，如果超过1个则肯定有 Category 方法冲突的情况。按照上一节中分析的场景，分析其具体冲突类型，提供结论输出给 Hyperloop。 具体对外接口可以直接参考我们的工具测试用例。最后该 Gem 会直接被 Hyperloop 使用。 &nbsp;it&nbsp;&#39;should&nbsp;return&nbsp;a&nbsp;map&nbsp;with&nbsp;keys&nbsp;for&nbsp;method&nbsp;name&nbsp;and&nbsp;classify&#39;&nbsp;do&nbsp;&nbsp;&nbsp;&nbsp;@parser&nbsp;=&nbsp;LinkmapParser::Parser.new&nbsp;&nbsp;&nbsp;&nbsp;@file_path&nbsp;=&nbsp;&#39;spec/fixtures/imeituan-LinkMap-normal-arm64.txt&#39;&nbsp;&nbsp;&nbsp;&nbsp;@analyze_result_with_classification&nbsp;=&nbsp;@parser.parse&nbsp;@file_path&nbsp;&nbsp;&nbsp;&nbsp;expect(@analyze_result_with_classification.class).to&nbsp;eq(Hash)&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Category&nbsp;方法互相冲突&nbsp;&nbsp;&nbsp;&nbsp;symbol&nbsp;=&nbsp;@analyze_result_with_classification[&quot;-[NSDate&nbsp;isEqualToDateDay:]&quot;]&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol.class).to&nbsp;eq(Hash)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:type]).to&nbsp;eq([LinkmapParser::CategoryConflictType::CONFLICT])&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].class).to&nbsp;eq(Array)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].count).to&nbsp;eq(3)&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Category&nbsp;方法覆盖原方法&nbsp;&nbsp;&nbsp;&nbsp;symbol&nbsp;=&nbsp;@analyze_result_with_classification[&quot;-[UGCReviewManager&nbsp;setCommonConfig:]&quot;]&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol.class).to&nbsp;eq(Hash)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:type]).to&nbsp;eq([LinkmapParser::CategoryConflictType::REPLACE])&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].class).to&nbsp;eq(Array)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].count).to&nbsp;eq(2)&nbsp;&nbsp;end Category 方法管理总结 1. 风险管理 对于任何语法工具，都是有利有弊的。所以除了发掘它们在实际场景中的应用，也要时刻对它们可能带来的风险保持警惕，并选择合适的工具和时机来管理风险。 而 Xcode 本身提供了不少的工具和时机，可以供我们分析构建过程和产物。若是在日常工作中遇到一些坑，不妨从构建期工具的角度去考虑管理。比如本文内提到的 linkmap，不仅可以用于 Category 分析，还可以用于二进制大小分析、组件信息管理等。投入一定资源在相关工具开发上，往往可以获得事半功倍的效果。 2. 代码规范 回到 Category 的使用，除了工具上的管控，我们也有相应的代码规范，从源头管理风险。如我们在规范中要求所有的 Category 方法都使用前缀，降低无意冲突的可能。并且我们也计划把“使用前缀”做成管控之一。 3. 后续规划 （1）覆盖系统方法检查&nbsp;&nbsp; 由于目前在管控体系内暂时没有引入系统符号表，所以无法对覆盖系统方法的行为进行分析和拦截。我们计划后续和 Crash 分析系统打通符号表体系，提早发现对系统库的不当覆盖。 （2）工具复用&nbsp;&nbsp; 当前的管控系统仅针对美团外卖和美团 App，未来计划推广到其他 App。由于有 Hyperloop，事情在技术上并没有太大的难度。&nbsp;&nbsp; 从工具本身的角度看，我们有计划在合适的时机对数据层代码进行开源，希望能对更多的开发有所帮助。 总结 在这篇文章中，我们从具体的业务场景入手，总结了组件间调用的通用模型，并对常用的解耦方案进行了分析对比，最终选择了目前最适合我们业务场景的方案。即通过 Category 覆盖的方式实现了依赖倒置，将构建时依赖延后到了运行时，达到我们预期的解耦目标。同时针对该方案潜在的问题，通过 linkmap 工具管控的方式进行规避。 另外，我们在模型设计时也提到，组件间解耦其实在 iOS 侧有多种方案选择。对于其他的方案实践，我们也会陆续和大家分享。希望我们的工作能对大家的 iOS 开发组件间解耦工作有所启发。 作者简介 尚先，美团资深工程师。2015年加入美团，目前作为美团外卖 iOS 端平台化虚拟小组组长，主要负责业务架构、持续集成和工程化相关工作。同时也是移动端领域新技术的爱好者，负责多项新技术在外卖业务落地中的难点攻关，目前个人拥有七项国家发明专利。 泽响，美团技术专家，2014年加入美团，先后负责过公司 iOS 持续集成体系建设，美团 iOS 端平台业务，美团 iOS 端基础业务等工作。目前作为美团移动平台架构平台组 Team Leader，主要负责美团 App 平台架构、组件化、研发流程优化和部分基础设施建设，致力于提升平台上全业务的研发效率与质量。 欢迎加入美团iOS技术交流群，跟作者零距离交流。进群方式：请加美美同学的微信（微信号：MTDPtech01），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 美团外卖长期招聘 iOS、Android、FE 高级/资深工程师和技术专家，Base 北京、上海、成都，欢迎有兴趣的同学投递简历到 chenhang03@meituan.com。&nbsp; 也许你还想看 【美团技术团队博客】前端组件化开发实践 用微前端的方式搭建类单页应用 美团扫码付的前端可用性保障实践" />
<link rel="canonical" href="https://mlh.app/2019/04/29/729143.html" />
<meta property="og:url" content="https://mlh.app/2019/04/29/729143.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"总第300篇 2018年 第92篇 背景 iOS Category功能简介 Category 是 Objective-C 2.0之后添加的语言特性。 Category 就是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。在 Objective-C（iOS 的开发语言，下文用 OC 代替）中的具体体现为：实例（类）方法、属性和协议。 除了引用中提到的添加方法，Category 还有很多优势，比如将一个类的实现拆分开放在不同的文件内，以及可以声明私有方法，甚至可以模拟多继承等操作，具体可参考官方文档Category。 若 Category 添加的方法是基类已经存在的，则会覆盖基类的同名方法。本文将要提到的组件间通信都是基于这个特性实现的，在本文的最后则会提到对覆盖风险的管控。 组件通信的背景 随着移动互联网的快速发展，不断迭代的移动端工程往往面临着耦合严重、维护效率低、开发不够敏捷等常见问题，因此越来越多的公司开始推行“组件化”，通过解耦重组组件来提高并行开发效率。 但是大多数团队口中的“组件化”就是把代码分库，主工程使用 CocoaPods 工具把各个子库的版本号聚合起来。但能合理的把组件分层，并且有一整套工具链支撑发版与集成的公司较少，导致开发效率很难有明显地提升。 处理好各个组件之间的通信与解耦一直都是组件化的难点。诸如组件之间的 Podfile 相互显式依赖，以及各种联合发版等问题，若处理不当可能会引发“灾难”性的后果。 目前做到 ViewController （指iOS中的页面，下文用VC代替）级别解耦的团队较多，维护一套 mapping 关系并使用 scheme 进行跳转，但是目前仍然无法做到更细粒度的解耦通信，依然满足不了部分业务的需求。 实际业务案例 例1：外卖的首页的商家列表（WMPageKit），在进入一个商家（WMRestaurantKit）选择5件商品返回到首页的时候，对应的商家cell需要显示已选商品“5”。 例2：搜索结果（WMSearchKit）跳转到商超的容器页（WMSupermarketKit），需要传递一个通用Domain（也有的说法叫模型、Model、Entity、Object等等，下文统一用Domain表示）。 例3：做一键下单需求（WMPageKit），需要调用下单功能的一个方法（WMOrderKit）入参是一个订单相关 Domain 和一个 VC，不需要返回值。 这几种场景基本涵盖了组件通信所需的基本功能，那么怎样才可以实现最优雅的解决方案？ 组件通信的探索 模型分析 对于上文提到的实际业务案例，很容易想到的应对方案有三种，第一是拷贝共同依赖代码，第二是直接依赖，第三是下沉公共依赖。 对于方案一，会维护多份冗余代码，逻辑更新后代码不同步，显然是不可取的。对于方案二，对于调用方来说，会引入较多无用依赖，且可能造成组件间的循环依赖问题，导致组件无法发布。对于方案三，其实是可行解，但是开发成本较大。对于下沉出来的组件来说，其实很难找到一个明确的定位，最终沦为多个组件的“大杂烩”依赖，从而导致严重的维护性问题。 那如何解决这个问题呢？根据面向对象设计的五大原则之一的“依赖倒置原则”（Dependency Inversion Principle），高层次的模块不应该依赖于低层次的模块，两者（的实现）都应该依赖于抽象接口。推广到组件间的关系处理，对于组件间的调用和被调用方，从本质上来说，我们也需要尽量避免它们的直接依赖，而希望它们依赖一个公共的抽象层，通过架构工具来管理和使用这个抽象层。这样我们就可以在解除组件间在构建时不必要的依赖，从而优雅地实现组件间的通讯。 图1-1 模型设计 业界现有方案的几大方向 实践倒置原则的方案有很多，在 iOS 侧，OC 语言和 Foundation 库给我们提供了数个可用于抽象的语言工具。在这一节我们将对其中部分实践进行分析。 1. 使用依赖注入 代表作品有 Objection 和 Typhoon，两者都是 OC 中的依赖注入框架，前者轻量级，后者较重并支持 Swift。 比较具有通用性的方法是使用「协议」 &lt;-&gt; 「类」绑定的方式，对于要注入的对象会有对应的 Protocol 进行约束，会经常看到一些RegisterClass:ForProtocol：和classFromProtocol的代码。在需要使用注入对象时，用框架提供的接口以协议作为入参从容器中获得初始化后的所需对象。也可以在 Register 的时候直接注册一段 Block-Code，这个代码块用来初始化自己，作为id类型的返回值返回，可以支持一些编译检查来确保对应代码被编译。 美团内推行将一些运行时加载的操作前移至编译时，比如将各项注册从 +load 改为在编译期使用__attribute((used,section(&quot;__DATA,key&quot;))) 写入 mach-O 文件 Data 的 Segment 中来减少冷启动的时间消耗。 因此，该方案的局限性在于：代码块存取的性能消耗较大，并且协议与类的绑定关系的维护需要花费更多的时间成本。 2. 基于SPI机制 全称是 Service Provider Interfaces，代表作品是 ServiceLoader。 实现过程大致是：A库与B库之间无依赖，但都依赖于P平台。把B库内的一个接口I下沉到平台层（“平台层”也叫做“通用能力层”，下文统一用平台层表示），入参和返回值的类型需要平台层包含，接口I的实现放在B库里（因为实现在B库，所以实现里可以正常引用B库的元素）。然后A库通过P平台的这个接口I来实现功能。A可以调用的到接口I，但是在B的库中进行实现。 在A库需要通过一个接口I实例化出一个对象，使用ServiceLoader.load（接口，key），通过注册过的key使用反射找到这个接口imp的文件路径然后得到这个实例对象调用对应接口。 这个操作在安卓中使用较为广泛，大致相当于用反射操作来替代一次了 import 这样的耦合引用。但实际上iOS中若使用反射来实现功能则完全不必这么麻烦。 关于反射，Java可以实现类似于ClassFromString的功能，但是无法直接使用 MethodFromString的功能。并且ClassFromString也是通过字符串map到这个类的文件路径，类似于 com.waimai.home.searchImp，从而可以获得类型然后实例化，而OC的反射是通过消息机制实现。 3. 基于通知中心 之前和一个做读书类App的同学交流，发现行业内有些公司的团队在使用 NotificationCenter 进行一些解耦的通信，因为通知中心本身支持传递对象，并且通知中心的功能也原生支持同步执行，所以也可以达到目的。 通知中心在iOS 9之后有一次比较大的升级，将通知支持了 request 和 response 的处理逻辑，并支持获取到通知的发送者。比以往的通知群发但不感知发送者和是否收到，进步了很多。 字符串的约定也可以理解为一个简化的协议，可设置成宏或常量放在平台层进行统一的维护。 比较明显的缺陷是开发的统一范式难以约束，风格迥异，且字符串相较于接口而言还是难以管理。 4. 使用objc_msgSend 这是iOS原生消息机制中最万能的方法，编写时会有一些硬编码。核心代码如下： id&nbsp;s&nbsp;=&nbsp;((id(*)(id,&nbsp;SEL))objc_msgSend)(ClassName,@selector(methodName));&nbsp; 这种方法的特点是即插即用，在开发者能100%确定整条调用链没问题的时候，可以快速实现功能。 此方案的缺陷在于编写十分随意，检查和校验的逻辑还不够，满屏的强转。对于 int、Integer、NSNumber 这样的很容易发生类型转换错误，结果虽然不报错，但数字会有错误。 方案对比 接下来，我们对这几个大方向进行一些性能对比。 考虑到在公司内的实际用法与限制，可能比常规方法增加了若干步骤，结果也可能会与常规裸测存在一定的偏差。 例如依赖注入常用做法是存在单例（内存）里，但是我们为了优化冷启动时间都写入 mach-O 文件 Data 的 Segment 里了，所以在我们的统计口径下存取时间会相对较长。 //&nbsp;为了不暴露类名将业务属性用“some”代替，并隐藏初始化、循环100W次、差值计算等代码，关键操作代码如下//&nbsp;存取注入对象xxConfig&nbsp;=&nbsp;[[WMSomeGlueCore&nbsp;sharedInstance]&nbsp;createObjectForProtocol:@protocol(WMSomeProtocol)];//&nbsp;通知发送[[NSNotificationCenter&nbsp;defaultCenter]postNotificationName:@&quot;nixx&quot;&nbsp;object:nil];//&nbsp;原生接口调用a&nbsp;=&nbsp;[WMSomeClass&nbsp;class];//&nbsp;反射调用b&nbsp;=&nbsp;objc_getClass(&quot;WMSomeClass&quot;); 运行结果显示如下： 图1-2 性能消耗检测 可以看出原生的接口调用明显是最高效的用法，反射的时长比原生要多一个数量级，不过100W次也就是多了几十毫秒，还在可以接受的范围之内。通知发送相比之下性能就很低了，存取注入对象更低。 当然除了性能消耗外，还有很多不好量化的维度，包括规范约束、功能性、代码量、可读性等，笔者按照实际场景客观评价给出对比的分值。 下面，我们用五种维度的能力值图来对比每一种方案优缺点： 各维度的的评分考虑到了一定的实际场景，可能和常规结果稍有偏差。 已经做了转化，看图面积越大越优。可读性的维度越长代表可读性越高，代码量的维度越长代表代码成本越少。 图2-1 各方案优缺点对比 如图2所示，可以看出上图的四种方式或多或少都存在一些缺点： 依赖注入是因为美团的实际场景问题，所以在性能消耗上存在明显的短板，并且代码量和可读性都不突出，规范约束这里是亮点。 SPI机制的范围图很大，但使用了反射，并且代码开发成本较高，实践上来看，对协议管理有一定要求。 通知中心除了代码少一些，其他维度都是短板。 而msgsend功能强大，代码量也少，但是在规范约束和可读性上几乎为零。 综合看来 SPI 和 objc_msgSend 两者的特点比较明显，很有潜力，如果针对这两种方案分别进行一定程度的完善，应该可以实现一个综合评分更高的方案。 从现有方案中完善或衍生出的方案 5. 使用Category+NSInvocation 此方案从 objc_msgSend 演化而来。NSInvocation 的调用方式的底层还是会使用到 objc_msgSend，但是通过一些方法签名和返回值类型校验，可以解决很多类型规范相关的问题，并且这种方式没有繁琐的注册步骤，任何一次新接口的添加，都可以直接在低层的库中进行完成。 为了更进一步限制调用者能够调用的接口，创建一些 Category 来提供接口，内部包装下层接口，把返回值和入参都限制实际的类型。业界比较接近的例子有 casatwy 的 CTMediator。 6. 原生CategoryCoverOrigin方式 此方案从 SPI 方式演化而来。两个的共同点是都在平台层提供接口供业务方调用，不同点是此方式完全规避了各种硬编码。而且 CategoryCoverOrigin 是一个思想，没有任何框架代码，可以说 OC 的 Runtime 就是这个方案的框架支撑。此方案的核心操作是在基类里汇总所有业务接口，在上层的业务库中创建基类的 Category 中对声明的接口进行覆盖。整个过程没有任何硬编码与反射。 演化出的这两种方案能力评估如下（绿色部分），图中也贴了和演化前方案（桔色部分）的对比： 图2-2 两种演化方案对比 上文对这两种方案描述的非常概括，可能有同学会对能力评估存在质疑。接下来会分别进行详解的介绍，并描述在实际操作值得注意的细节。这两种方案组合成了外卖内部的组件通信框架 WMScheduler。 WMScheduler组件通信 外卖的 WMScheduler 主要是通过对 Category 特性的运用来实现组件间通信，实际操作中有两种的应用方案：Category+NSInvocation 和 CategoryCoverOrigin。 1. Category+NSInvocation方案 方案简介 这个方案将其对 NSInvocation 功能容错封装、参数判断、类型转换的代码写在下层，提供简易万能的接口。并在上层创建通信调度器类提供常用接口，在调度器的 Category 里扩展特定业务的专用接口。所有的上层接口均有规范约束，这些规范接口的内部会调用下层的简易万能接口即可通过NSInvocation 相关的硬编码操作调用任何方法。 UML图 图3-1 Category+NSInvocation的UML图 如图3-1所示，代码的核心在 WMSchedulerCore 类，其包含了基于 NSInvocation 对 target 与 method 的操作、对参数的处理（包括对象，基本数据类型，NULL类型）、对异常的处理等等，最终开放了简洁的万能接口，接口参数有 target、method、parameters等等，然后内部帮我们完成调用。但这个接口并不是让上层业务直接进行调用，而是需要创建一个 WMSchedule r的 Category，在这个 Category 中编写规范的接口（前缀、入参类型、返回值类型都是确定的）。 值得一提的是，提供业务专用接口的 Category 没有以 WMSchedulerCore 为基类，而是以 WMScheduler 为基类。看似多此一举，实际上是为了做权限的隔离。上层业务只能访问到 WMScheduler.h 及其 Category 的规范接口。并不能访问到 WMSchedulerCore.h 提供的“万能但不规范”接口。 例如：在UML图中可以看到 外界只可以调用到wms_getOrderCountWithPoiid（规范接口），并不能使用wm_excuteInstance Method（万能接口）。 为了更好地理解实际使用，笔者贴一个组件调用周期的完整代码： 图3-2 Category+NSInvocation的示例图 如图3-2，在这种方案下，“B库调用A库方法”的需求只需要改两个仓库的代码，需要改动的文件标了下划线，请仔细看下示例代码。 示例代码 平台（通用功能）库三个文件： ① //&nbsp;WMScheduler+AKit.h#import&nbsp;&quot;WMScheduler.h&quot;@interface&nbsp;WMScheduler(AKit)/**&nbsp;*&nbsp;通过商家id查到当前购物车已选e的小红点数量&nbsp;*&nbsp;@param&nbsp;poiid&nbsp;&nbsp;商家id&nbsp;*&nbsp;@return&nbsp;实际的小红点数量&nbsp;*/+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID;@end ② //&nbsp;WMScheduler+AKit.m#import&nbsp;&quot;WMSchedulerCore.h&quot;#import&nbsp;&quot;WMScheduler+AKit.h&quot;#import&nbsp;&quot;NSObject+WMScheduler.h&quot;@implementation&nbsp;WMScheduler&nbsp;(AKit)+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID{&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nil&nbsp;==&nbsp;poiid)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;}#pragma&nbsp;clang&nbsp;diagnostic&nbsp;push#pragma&nbsp;clang&nbsp;diagnostic&nbsp;ignored&nbsp;&quot;-Wundeclared-selector&quot;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;singleton&nbsp;=&nbsp;[wm_scheduler_getClass(&quot;WMXXXSingleton&quot;)&nbsp;wm_executeMethod:@selector(sharedInstance)];&nbsp;&nbsp;&nbsp;&nbsp;NSNumber*&nbsp;orderFoodCount&nbsp;=&nbsp;[singleton&nbsp;wm_executeMethod:@selector(calculateOrderedFoodCountWithPoiID:)&nbsp;params:@[poiID]];&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;orderFoodCount&nbsp;==&nbsp;nil&nbsp;?&nbsp;0&nbsp;:&nbsp;[orderFoodCount&nbsp;integerValue];#pragma&nbsp;clang&nbsp;diagnostic&nbsp;pop}@end ③ //&nbsp;WMSchedulerInterfaceList.h#ifndef&nbsp;WMSchedulerInterfaceList_h#define&nbsp;WMSchedulerInterfaceList_h//&nbsp;这个文件会被加到上层业务的pch里，所以下文不用import本文件#import&nbsp;&quot;WMScheduler.h&quot;#import&nbsp;&quot;WMScheduler+AKit.h&quot;#endif&nbsp;/*&nbsp;WMSchedulerInterfaceList_h&nbsp;*/ BKit （调用方）一个文件： //&nbsp;WMHomeVC.m@interface&nbsp;WMHomeVC&nbsp;()&nbsp;&lt;UITableViewDataSource,&nbsp;UITableViewDelegate&gt;@end@implementation&nbsp;WMHomeVC...&nbsp;&nbsp;&nbsp;&nbsp;NSUInteger&nbsp;*foodCount&nbsp;=&nbsp;[WMScheduler&nbsp;wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%ld&quot;,foodCount);...@end 代码分析 上文四个文件完成了一次跨组件的调用，在 WMScheduler+AKit.m 中的第30、31行，调用的都是AKit（提供方）的现有方法，因为 WMSchedulerCore 提供了 NSInvocation 的调用方式，所以可以直接向上调用。WMScheduler+AKit 中提供的接口就是上文说的“规范接口”，这个接口在WMHomeVC（调用方）调用时和调用本仓库内的OC方法，并没有区别。 延伸思考 上文的例子中入参和返回值都是基本数据类型，Domain 也是支持的，前提是这个 Domain 是放在平台库的。我们可以将工程中的 Domain 分为BO（Business Object）、VO（View Object）与TO（Transfer Object），VO 经常出现在 view 和 cell，BO一般仅在各业务子库内部使用，这个TO则是需要放在平台库是用于各个组件间的通信的通用模型。例如：通用 PoiDomain，通用 OrderDomain，通用 AddressDomain 等等。这些称为 TO 的 Domain 可以作为规范接口的入参类型或返回值类型。 在实际业务场景中，跳转页面时传递 Domain 的需求也是一个老生常谈的问题，大多数页面级跳转框架仅支持传递基本数据类型（也有 trick 的方式传 Domain 内存地址但很不优雅）。在有了上文支持的能力，我们可以在规范接口内通过万能接口获取目标页面的VC，并调用其某个属性的 set 方法将我们想传递的Domain赋值过去，然后将这个 VC 对象作为返回值返回。调用方获得这个 VC 后在当前的导航栈内push即可。 上文代码中我们用 WMScheduler 调用了 Akit 的一个名为calculateOrderedFoodCount WithPoiID：的方法。那么有个争议点：在组件通信需要调用某方法时，是允许直接调用现有方法，还是复制一份加上前缀标注此方法专门用于提供组件通信？ 阶段总结 Category+NSInvocation 方案的优点是便捷，因为 Category 的专用接口放在平台库，以后有除了 BKit 以外的其他调用方也可以直接调用，还有更多强大的功能。 但是，不优雅的地方我们也列举一下： 当这个跨组件方法内部的代码行数比较多时，会写很多硬编码。 硬编码method字符串，在现有方法被修改时，编译检测不报错（只能靠断言约束）。 下层库向上调用的设计会被诟病。 接下来介绍的 CategoryCoverOrigin 的方案，可以解决这三个问题。 2. CategoryCoverOrigin方案 方案简介 首先说明下这个方案和 NSInvocation 没有任何关系，此方案与上一方案也是完全不同的两个概念，不要将上一个方案的思维带到这里。 此方案的思路是在平台层的 WMScheduler.h 提供接口方法，接口的实现只写空实现或者兜底实现（兜底实现中可根据业务场景在 Debug 环境下增加 toast 提示或断言），上层库的提供方实现接口方法并通过 Category 的特性，在运行时进行对基类同名方法的替换。调用方则正常调用平台层提供的接口。在 CategoryCoverOrigin 的方案中 WMScheduler 的 Category 在提供方仓库内部，因此业务逻辑的依赖可以在仓库内部使用常规的OC调用。 UML图 图4-1 CategoryCover 的 UML 图 从图4-1可以看出，WMScheduler 的 Category 被移到了业务仓库，并且 WMScheduler 中有所有接口的全集。 为了更好地理解 CategoryCover 实际应用，笔者再贴一个此方案下的完整代码： 图4-2 CategoryCover的示例图 如图4-2，在这种方案下，“B库调用A库方法”的需求需要修改三个仓库的代码，但除了这四个编辑的文件，没有其他任何的依赖了，请仔细看下代码示例。 示例代码 平台（通用功能库）两个文件： ① //&nbsp;&nbsp;WMScheduler.h@interface&nbsp;WMScheduler&nbsp;:&nbsp;NSObject//&nbsp;&nbsp;这个文件是所有组件通信方法的汇总#pragma&nbsp;mark&nbsp;-&nbsp;AKit&nbsp;&nbsp;/**&nbsp;*&nbsp;通过商家id查到当前购物车已选e的小红点数量&nbsp;*&nbsp;@param&nbsp;poiid&nbsp;&nbsp;商家id&nbsp;*&nbsp;@return&nbsp;实际的小红点数量&nbsp;*/+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID;#pragma&nbsp;mark&nbsp;-&nbsp;CKit//&nbsp;...#pragma&nbsp;mark&nbsp;-&nbsp;DKit//&nbsp;...@end ② //&nbsp;WMScheduler.m#import&nbsp;&quot;WMScheduler.h&quot;@implementation&nbsp;WMScheduler#pragma&nbsp;mark&nbsp;-&nbsp;Akit+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;//&nbsp;这个.m里只要求一个空实现&nbsp;作为兜底方案。}#pragma&nbsp;mark&nbsp;-&nbsp;Ckit//&nbsp;...#pragma&nbsp;mark&nbsp;-&nbsp;Dkit//&nbsp;...@end AKit（提供方）一个 Category 文件： //&nbsp;WMScheduler+AKit.m#import&nbsp;&quot;WMScheduler.h&quot;#import&nbsp;&quot;WMAKitBusinessManager.h&quot;#import&nbsp;&quot;WMXXXSingleton.h&quot;&nbsp;&nbsp;//&nbsp;直接导入了很多AKit相关的业务文件，因为本身就在AKit仓库内@implementation&nbsp;WMScheduler&nbsp;(AKit)//&nbsp;这个宏可以屏蔽分类覆盖基类方法的警告#pragma&nbsp;clang&nbsp;diagnostic&nbsp;push#pragma&nbsp;clang&nbsp;diagnostic&nbsp;ignored&nbsp;&quot;-Wobjc-protocol-method-implementation&quot;//&nbsp;在平台层写过的方法，这边是是自动补全的+&nbsp;(NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber&nbsp;*)poiID{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nil&nbsp;==&nbsp;poiid)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;所有AKIT相关的类都能直接接口调用，不需要任何硬编码，可以和之前的写法对比下。&nbsp;&nbsp;&nbsp;&nbsp;WMXXXSingleton&nbsp;*singleton&nbsp;=&nbsp;[WMXXXSingleton&nbsp;sharedInstance];&nbsp;&nbsp;&nbsp;&nbsp;NSNumber&nbsp;*orderFoodCount&nbsp;=&nbsp;[singleton&nbsp;calculateOrderedFoodCountWithPoiID:poiID];&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;orderFoodCount&nbsp;==&nbsp;nil&nbsp;?&nbsp;0&nbsp;:&nbsp;[orderFoodCount&nbsp;integerValue];}#pragma&nbsp;clang&nbsp;diagnostic&nbsp;pop@end BKit（调用方） 一个文件写法不变： //&nbsp;WMHomeVC.m@interface&nbsp;WMHomeVC&nbsp;()&nbsp;&lt;UITableViewDataSource,&nbsp;UITableViewDelegate&gt;@end@implementation&nbsp;WMHomeVC...&nbsp;&nbsp;&nbsp;&nbsp;NSUInteger&nbsp;*foodCount&nbsp;=&nbsp;[WMScheduler&nbsp;wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%ld&quot;,foodCount);...@end 代码分析 CategoryCoverOrigin 的方式，平台库用 WMScheduler.h 文件存放所有的组件通信接口的汇总，各个仓库用注释隔开，并在.m文件中编写了空实现。功能代码编写在服务提供方仓库的 WMScheduler+AKit.m，看这个文件的17、18行业务逻辑是使用常规 OC 接口调用。在运行时此Category的方法会覆盖 WMScheduler.h 基类中的同名方法，从而达到目的。CategoryCoverOrigin 方式不需要其他功能类的支撑。 延伸思考 如果业务库很多，方法很多，会不会出现 WMScheduler.h 爆炸？ &nbsp;目前我们的工程跨组件调用的实际场景不是很多，所以汇总在一个文件了，如果满屏都是跨组件调用的工程，则需要思考业务架构与模块划分是否合理这一问题。当然，如果真出现 WMScheduler.h 爆炸的情况，完全可以将各个业务的接口移至自己Category 的.h文件中，然后创建一个 WMSchedulerInterfaceList 文件统一 import 这些 Category。 两种方案的选择 刚才我们对于 Category+NSInvocation 和 CategoryCoverOrigin 两种方式都做了详细的介绍，我们再整理一下两者的优缺点对比： 笔者更建议使用 CategoryCoverOrigin 的无硬编码的方案，当然具体也要看项目的实际场景，从而做出最优的选择。 更多建议 关于组件对外提供的接口，我们更倾向于借鉴 SPI 的思想，作为一个 Kit 哪些功能是需要对外公开的？提供哪些服务给其他方解耦调用？建议主动开放核心方法，尽量减少“用到才补”的场景。例如全局购物车就需要“提供获取小红点数量的方法”，商家中心就需要提供“根据字符串 id 得到整个 Poi 的 Domain”的接口服务。 需要考虑到抽象能力，提供更有泛用性的接口。比如“获取到了最低满减价格后拼接成一个文案返回字符串” 这个方法，就没有“获取到了最低满减价格” 这个方法具备泛用性。 Category风险管控 先举两个发生过的案例 1. 2017年10月 一个关于NSDate重复覆盖的问题 当时美团平台有 NSDate+MTAddition 类，在外卖侧有 NSDate+WMAddition 类。前者 NSDate+MTAddition 之前就有方法 getCurrentTimestamp，返回的时间戳是秒。后者 NSDate+WMAddition 在一次需求中也增加了 getCurrentTimestamp 方法，但是为了和其他平台统一口径返回值使用了毫秒。在正常的加载顺序中外卖类比平台类要晚，因此在外卖的测试中没有发现问题。但集成到 imeituan 主项目之后，原先其他业务方调用这个返回“秒”的方法，就被外卖测的返回“毫秒”的同名方法给覆盖了，出现接口错误和UI错乱等问题。 2. 2018年3月 一个WMScheduler组件通信遇到的问题 在外卖侧有订单组件和商家容器组件，这两个组件的联系是十分紧密的，有的功能放在两个仓库任意一个中都说的通。因此出现了了两个仓库写了同名方法的场景。在 WMScheduler+Restaurant 和 WMScheduler+Order 两个仓库都添加了方法 -(void)wms_enterGlobalCartPageFromPage:，在运行中这两处有一处被覆盖。在有一次 Bug 解决中，给其中一处增加了异常处理的代码，恰巧增加的这处先加载，就被后加载的同名方法覆盖了，这就导致了异常处理代码不生效的问题。 那么使用 CategoryCover 的方式是不是很不安全？ NO！只要弄清其中的规律，风险点都是完全可以管控的，接下来，我们来分析 Category 的覆盖原理。 Category 方法覆盖原理 1) Category 的方法没有“完全替换掉”原来类已经有的方法，也就是说如果 Category 和原来类都有methodA，那么 Category 附加完成之后，类的方法列表里会有两个 methodA。 2) Category 方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的 Category 的方法会“覆盖”掉原来类的同名方法，这是因为运行过程中，我们在查找方法的时候会顺着方法列表的顺序去查找，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。 Category 在运行期进行决议，而基类的类是在编译期进行决议，因此分类中，方法的加载顺序一定在基类之后。 美团曾经有一篇技术博客深入分析了 Category，并且从编译器和源码的角度对分类覆盖操作进行详细解析：《深入理解Objective-C：Category》 根据方法覆盖的原理，我们可以分析出哪些操作比较安全，哪些存在风险，并针对性地进行管理。接下来，我们就介绍美团 Category 管理相关的一些工作。 Category 方法管理 由于历史原因，不管是什么样的管理规则，都无法直接“一刀切”。所以针对现状，我们将整个管理环节先拆分为“数据”、“场景”、 “策略”三部分。 其中数据层负责发现异常数据，所有策略公用一个数据层。针对 Category 方法的数据获取，我们有如下几种方式： 根据优缺点的分析，再考虑到美团已经彻底实现了“组件化”的工程，所以对 Category 的管控最好放在集成阶段以后进行。我们最终选择了使用 linkmap 进行数据获取，具体方法我们将在下文进行介绍。 策略部分则针对不同的场景异常进行控制，主要的开发工作位于我们的组件化 CI 系统上，即之前介绍过的 《Hyperloop，让发布简洁高效》系统。 Hyperloop 本身即提供了包括白名单，发布集成流程管理等一系列策略功能，我们只需要将工具进行关联开发即可。我们开发的数据层作为一个独立组件，最终也是运行在 Hyperloop 上。 图5-2 方法管理环节 根据场景细分的策略如下表所示（需要注意的是，表中有的场景实际不存在，只是为了思考的严谨列出）： 我们在前文描述的 CategoryCoverOrigin 的组件通信方案的管控体现在第2点。风险管控中提到的两个案例的管控主要体现在第4点。 Category 数据获取原理 上一章节，我们提到了采用 linkmap 分析的方式进行 Category 数据获取。在这一章节内，我们详细介绍下做法。 启用 linkmap 首先，linkmap 生成功能是默认关闭的，我们需要在 build settings 内手动打开开关并配置存储路径。对于美团工程和美团外卖工程来说，每次正式构建后产生的 linkmap，我们还会通过内部的美团云存储工具进行持久化的存储，保证后续的可追溯。 图6 启用 linkmap 的设置 linkmap 组成 若要解析 linkmap，首先需要了解 linkmap 的组成。 如名称所示，linkmap 文件生成于代码链接之后，主要由4个部分组成：基本信息、Object files 表、Sections 表和 Symbols 表。 前两行是基本信息，包括链接完成的二进制路径和架构。如果一个工程内有多个最终产物（如 Watch App 或 Extension），则经过配置后，每一个产物的每一种架构都会生成一份 linkmap。 #&nbsp;Path:&nbsp;/var/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828-59923-v4pjhg/output-sandbox/DerivedData/Build/Intermediates.noindex/ArchiveIntermediates/imeituan/InstallationBuildProductsLocation/Applications/imeituan.app/imeituan#&nbsp;Arch:&nbsp;arm64 第二部分的 Object files，列举了链接所用到的所有的目标文件，包括代码编译出来的，静态链接库内的和动态链接库（如系统库），并且给每一个目标文件分配了一个 file id。 #&nbsp;Object&nbsp;files:[&nbsp;&nbsp;0]&nbsp;linker&nbsp;synthesized[&nbsp;&nbsp;1]&nbsp;dtrace[&nbsp;&nbsp;2]&nbsp;/var/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828-59923-v4pjhg/output-sandbox/DerivedData/Build/Intermediates.noindex/ArchiveIntermediates/imeituan/IntermediateBuildFilesPath/imeituan.build/DailyBuild-iphoneos/imeituan.build/Objects-normal/arm64/main.o……[&nbsp;26]&nbsp;/private/var/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828-59923-v4pjhg/repo-sandbox/imeituan/Pods/AFNetworking/bin/libAFNetworking.a(AFHTTPRequestOperation.o)……[25919]&nbsp;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/usr/lib/libobjc.tbd[25920]&nbsp;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk/usr/lib/libSystem.tbd 第三部分的 Sections，记录了所有的 Section，以及它们所属的 Segment 和大小等信息。 #&nbsp;Sections:#&nbsp;Address&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Segment&nbsp;Section0x100004450&nbsp;&nbsp;&nbsp;&nbsp;0x07A8A8D0&nbsp;&nbsp;__TEXT&nbsp;&nbsp;__text……0x109EA52C0&nbsp;&nbsp;&nbsp;&nbsp;0x002580A0&nbsp;&nbsp;__DATA&nbsp;&nbsp;__objc_data0x10A0FD360&nbsp;&nbsp;&nbsp;&nbsp;0x001D8570&nbsp;&nbsp;__DATA&nbsp;&nbsp;__data0x10A2D58D0&nbsp;&nbsp;&nbsp;&nbsp;0x0000B960&nbsp;&nbsp;__DATA&nbsp;&nbsp;__objc_k_kylin……0x10BFE4E5D&nbsp;&nbsp;&nbsp;&nbsp;0x004CBE63&nbsp;&nbsp;__RODATA&nbsp;&nbsp;&nbsp;&nbsp;__objc_methname0x10C4B0CC0&nbsp;&nbsp;&nbsp;&nbsp;0x000D560B&nbsp;&nbsp;__RODATA&nbsp;&nbsp;&nbsp;&nbsp;__objc_classname 第四部分的 Symbols 是重头戏，列举了所有符号的信息，包括所属的 object file、大小等。符号除了我们关注的 OC 的方法、类名、协议名等，也包含 block、literal string 等，可以供其他需求分析进行使用。 #&nbsp;Symbols:#&nbsp;Address&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;&nbsp;Name0x1000045B8&nbsp;&nbsp;&nbsp;&nbsp;0x00000060&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_writeout0x100004618&nbsp;&nbsp;&nbsp;&nbsp;0x00000028&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_flush0x100004640&nbsp;&nbsp;&nbsp;&nbsp;0x00000014&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_init0x100004654&nbsp;&nbsp;&nbsp;&nbsp;0x00000014&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_init.40x100004668&nbsp;&nbsp;&nbsp;&nbsp;0x00000014&nbsp;&nbsp;[&nbsp;&nbsp;2]&nbsp;___llvm_gcov_init.60x10000467C&nbsp;&nbsp;&nbsp;&nbsp;0x0000015C&nbsp;&nbsp;[&nbsp;&nbsp;3]&nbsp;_main……0x10002F56C&nbsp;&nbsp;&nbsp;&nbsp;0x00000028&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_imageRequestOperationForState:]0x10002F594&nbsp;&nbsp;&nbsp;&nbsp;0x0000002C&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_setImageRequestOperation:forState:]0x10002F5C0&nbsp;&nbsp;&nbsp;&nbsp;0x00000028&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_backgroundImageRequestOperationForState:]0x10002F5E8&nbsp;&nbsp;&nbsp;&nbsp;0x0000002C&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(_AFNetworking)&nbsp;af_setBackgroundImageRequestOperation:forState:]0x10002F614&nbsp;&nbsp;&nbsp;&nbsp;0x0000006C&nbsp;&nbsp;[&nbsp;38]&nbsp;+[UIButton(AFNetworking)&nbsp;sharedImageCache]0x10002F680&nbsp;&nbsp;&nbsp;&nbsp;0x00000010&nbsp;&nbsp;[&nbsp;38]&nbsp;+[UIButton(AFNetworking)&nbsp;setSharedImageCache:]0x10002F690&nbsp;&nbsp;&nbsp;&nbsp;0x00000084&nbsp;&nbsp;[&nbsp;38]&nbsp;-[UIButton(AFNetworking)&nbsp;imageResponseSerializer]…… linkmap 数据化 根据上文的分析，在理解了 linkmap 的格式后，通过简单的文本分析即可提取数据。由于美团内部 iOS 开发工具链统一采用 Ruby，所以 linkmap 分析也采用 Ruby 开发，整个解析器被封装成一个 Ruby Gem。 具体实施上，处于通用性考虑，我们的 linkmap 解析工具分为解析、模型、解析器三层，每一层都可以单独进行扩展。 图7 linkmap解析工具 对于 Category 分析器来说，link map parser 解析指定 linkmap，生成通用模型的实例。从实例中获取 symbol 类，将名字中有“()”的符号过滤出来，即为 Category 方法。 接下来只要按照方法名聚合，如果超过1个则肯定有 Category 方法冲突的情况。按照上一节中分析的场景，分析其具体冲突类型，提供结论输出给 Hyperloop。 具体对外接口可以直接参考我们的工具测试用例。最后该 Gem 会直接被 Hyperloop 使用。 &nbsp;it&nbsp;&#39;should&nbsp;return&nbsp;a&nbsp;map&nbsp;with&nbsp;keys&nbsp;for&nbsp;method&nbsp;name&nbsp;and&nbsp;classify&#39;&nbsp;do&nbsp;&nbsp;&nbsp;&nbsp;@parser&nbsp;=&nbsp;LinkmapParser::Parser.new&nbsp;&nbsp;&nbsp;&nbsp;@file_path&nbsp;=&nbsp;&#39;spec/fixtures/imeituan-LinkMap-normal-arm64.txt&#39;&nbsp;&nbsp;&nbsp;&nbsp;@analyze_result_with_classification&nbsp;=&nbsp;@parser.parse&nbsp;@file_path&nbsp;&nbsp;&nbsp;&nbsp;expect(@analyze_result_with_classification.class).to&nbsp;eq(Hash)&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Category&nbsp;方法互相冲突&nbsp;&nbsp;&nbsp;&nbsp;symbol&nbsp;=&nbsp;@analyze_result_with_classification[&quot;-[NSDate&nbsp;isEqualToDateDay:]&quot;]&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol.class).to&nbsp;eq(Hash)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:type]).to&nbsp;eq([LinkmapParser::CategoryConflictType::CONFLICT])&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].class).to&nbsp;eq(Array)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].count).to&nbsp;eq(3)&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Category&nbsp;方法覆盖原方法&nbsp;&nbsp;&nbsp;&nbsp;symbol&nbsp;=&nbsp;@analyze_result_with_classification[&quot;-[UGCReviewManager&nbsp;setCommonConfig:]&quot;]&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol.class).to&nbsp;eq(Hash)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:type]).to&nbsp;eq([LinkmapParser::CategoryConflictType::REPLACE])&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].class).to&nbsp;eq(Array)&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[:detail].count).to&nbsp;eq(2)&nbsp;&nbsp;end Category 方法管理总结 1. 风险管理 对于任何语法工具，都是有利有弊的。所以除了发掘它们在实际场景中的应用，也要时刻对它们可能带来的风险保持警惕，并选择合适的工具和时机来管理风险。 而 Xcode 本身提供了不少的工具和时机，可以供我们分析构建过程和产物。若是在日常工作中遇到一些坑，不妨从构建期工具的角度去考虑管理。比如本文内提到的 linkmap，不仅可以用于 Category 分析，还可以用于二进制大小分析、组件信息管理等。投入一定资源在相关工具开发上，往往可以获得事半功倍的效果。 2. 代码规范 回到 Category 的使用，除了工具上的管控，我们也有相应的代码规范，从源头管理风险。如我们在规范中要求所有的 Category 方法都使用前缀，降低无意冲突的可能。并且我们也计划把“使用前缀”做成管控之一。 3. 后续规划 （1）覆盖系统方法检查&nbsp;&nbsp; 由于目前在管控体系内暂时没有引入系统符号表，所以无法对覆盖系统方法的行为进行分析和拦截。我们计划后续和 Crash 分析系统打通符号表体系，提早发现对系统库的不当覆盖。 （2）工具复用&nbsp;&nbsp; 当前的管控系统仅针对美团外卖和美团 App，未来计划推广到其他 App。由于有 Hyperloop，事情在技术上并没有太大的难度。&nbsp;&nbsp; 从工具本身的角度看，我们有计划在合适的时机对数据层代码进行开源，希望能对更多的开发有所帮助。 总结 在这篇文章中，我们从具体的业务场景入手，总结了组件间调用的通用模型，并对常用的解耦方案进行了分析对比，最终选择了目前最适合我们业务场景的方案。即通过 Category 覆盖的方式实现了依赖倒置，将构建时依赖延后到了运行时，达到我们预期的解耦目标。同时针对该方案潜在的问题，通过 linkmap 工具管控的方式进行规避。 另外，我们在模型设计时也提到，组件间解耦其实在 iOS 侧有多种方案选择。对于其他的方案实践，我们也会陆续和大家分享。希望我们的工作能对大家的 iOS 开发组件间解耦工作有所启发。 作者简介 尚先，美团资深工程师。2015年加入美团，目前作为美团外卖 iOS 端平台化虚拟小组组长，主要负责业务架构、持续集成和工程化相关工作。同时也是移动端领域新技术的爱好者，负责多项新技术在外卖业务落地中的难点攻关，目前个人拥有七项国家发明专利。 泽响，美团技术专家，2014年加入美团，先后负责过公司 iOS 持续集成体系建设，美团 iOS 端平台业务，美团 iOS 端基础业务等工作。目前作为美团移动平台架构平台组 Team Leader，主要负责美团 App 平台架构、组件化、研发流程优化和部分基础设施建设，致力于提升平台上全业务的研发效率与质量。 欢迎加入美团iOS技术交流群，跟作者零距离交流。进群方式：请加美美同学的微信（微信号：MTDPtech01），回复：iOS，美美会自动拉你进群。 ----------&nbsp; END&nbsp; ---------- 招聘信息 美团外卖长期招聘 iOS、Android、FE 高级/资深工程师和技术专家，Base 北京、上海、成都，欢迎有兴趣的同学投递简历到 chenhang03@meituan.com。&nbsp; 也许你还想看 【美团技术团队博客】前端组件化开发实践 用微前端的方式搭建类单页应用 美团扫码付的前端可用性保障实践","@type":"BlogPosting","url":"https://mlh.app/2019/04/29/729143.html","headline":"Category 特性在 iOS 组件化中的应用与管控","dateModified":"2019-04-29T00:00:00+08:00","datePublished":"2019-04-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/29/729143.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Category 特性在 iOS 组件化中的应用与管控</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;" data-mpa-powered-by="yiban.io"><img class="" data-copyright="0" data-ratio="0.10546875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png" data-type="png" data-w="1280" style="box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4zA3FUoOfW6b1icLsE77CELpkNLzriajHTdibqkqVFYoldIoffibgkOslZA/640?wx_fmt=png"></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;text-align: center;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;">总第300篇</span></strong></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;text-align: center;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 12px;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;">2018年 第92篇</span></strong></p> 
<section class="output_wrapper" style="font-size: 16px;line-height: 1.6;letter-spacing: 0px;margin-left: 0.5em;margin-right: 0.5em;"> 
 <h2 style="color: rgb(62, 62, 62);white-space: normal;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">背景</span></strong></h2> 
 <p style="color: rgb(62, 62, 62);"><br></p> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>iOS Category功能简介</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Category 是 Objective-C 2.0之后添加的语言特性。</span></p> 
 <blockquote style="color: rgb(129, 145, 152);line-height: inherit;padding: 15px 15px 15px 1rem;font-size: 0.9em;margin-top: 1em;margin-bottom: 1em;border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);overflow: auto;overflow-wrap: normal;"> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">Category 就是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。在 Objective-C（iOS 的开发语言，下文用 OC 代替）中的具体体现为：实例（类）方法、属性和协议。</span></p> 
 </blockquote> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">除了引用中提到的添加方法，Category 还有很多优势，比如将一个类的实现拆分开放在不同的文件内，以及可以声明私有方法，甚至可以模拟多继承等操作，具体可参考官方文档</span><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">Category</span></a><span style="font-size: 15px;">。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">若 Category 添加的方法是基类已经存在的，则会覆盖基类的同名方法。本文将要提到的组件间通信都是基于这个特性实现的，在本文的最后则会提到对覆盖风险的管控。</span></p> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>组件通信的背景</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">随着移动互联网的快速发展，不断迭代的移动端工程往往面临着耦合严重、维护效率低、开发不够敏捷等常见问题，因此越来越多的公司开始推行“组件化”，通过解耦重组组件来提高并行开发效率。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">但是大多数团队口中的“组件化”就是把代码分库，主工程使用 CocoaPods 工具把各个子库的版本号聚合起来。但能合理的把组件分层，并且有一整套工具链支撑发版与集成的公司较少，导致开发效率很难有明显地提升。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">处理好各个组件之间的通信与解耦一直都是组件化的难点。诸如组件之间的 Podfile 相互显式依赖，以及各种联合发版等问题，若处理不当可能会引发“灾难”性的后果。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">目前做到 ViewController （</span><span style="font-size: 15px;color: rgb(136, 136, 136);">指iOS中的页面，下文用VC代替</span><span style="font-size: 15px;">）级别解耦的团队较多，维护一套 mapping 关系并使用 scheme 进行跳转，但是目前仍然无法做到更细粒度的解耦通信，依然满足不了部分业务的需求。</span></p> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>实际业务案例</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">例1：外卖的首页的商家列表（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">WMPageKit</span><span style="font-size: 15px;">），在进入一个商家（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">WMRestaurantKit</span><span style="font-size: 15px;">）选择5件商品返回到首页的时候，对应的商家cell需要显示已选商品“5”。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">例2：搜索结果（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">WMSearchKit</span><span style="font-size: 15px;">）跳转到商超的容器页（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">WMSupermarketKit</span><span style="font-size: 15px;">），需要传递一个通用Domain（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">也有的说法叫模型、Model、Entity、Object等等，下文统一用Domain表示</span><span style="font-size: 15px;">）。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">例3：做一键下单需求（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">WMPageKit</span><span style="font-size: 15px;">），需要调用下单功能的一个方法（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">WMOrderKit</span><span style="font-size: 15px;">）入参是一个订单相关 Domain 和一个 VC，不需要返回值。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这几种场景基本涵盖了组件通信所需的基本功能，那么怎样才可以实现最优雅的解决方案？</span></p> 
 <h2 style="color: rgb(62, 62, 62);white-space: normal;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">组件通信的探索</span></strong></h2> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong><br></strong></span></h3> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>模型分析</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于上文提到的实际业务案例，很容易想到的应对方案有三种，第一是拷贝共同依赖代码，第二是直接依赖，第三是下沉公共依赖。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于方案一，会维护多份冗余代码，逻辑更新后代码不同步，显然是不可取的。对于方案二，对于调用方来说，会引入较多无用依赖，且可能造成组件间的循环依赖问题，导致组件无法发布。对于方案三，其实是可行解，但是开发成本较大。对于下沉出来的组件来说，其实很难找到一个明确的定位，最终沦为多个组件的“大杂烩”依赖，从而导致严重的维护性问题。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">那如何解决这个问题呢？根据面向对象设计的五大原则之一的“依赖倒置原则”（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">Dependency Inversion Principle</span><span style="font-size: 15px;">），高层次的模块不应该依赖于低层次的模块，两者（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">的实现</span><span style="font-size: 15px;">）都应该依赖于抽象接口。推广到组件间的关系处理，对于组件间的调用和被调用方，从本质上来说，我们也需要尽量避免它们的直接依赖，而希望它们依赖一个公共的抽象层，通过架构工具来管理和使用这个抽象层。这样我们就可以在解除组件间在构建时不必要的依赖，从而优雅地实现组件间的通讯。</span></p> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.27313769751693" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aibq8eLKP8S2hibibMpVfjs9PpfqHCCVl6HKIWpXYyLsicS3Diad4kGhu37w/640?wx_fmt=png" data-type="png" data-w="1772" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aibq8eLKP8S2hibibMpVfjs9PpfqHCCVl6HKIWpXYyLsicS3Diad4kGhu37w/640?wx_fmt=png"></p> 
  <span style="font-size: 15px;"></span> 
 </center> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <span style="font-size: 14px;color: rgb(136, 136, 136);">图1-1 模型设计</span> 
 </center> 
 <h3 style="color: rgb(62, 62, 62);"><br></h3> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>业界现有方案的几大方向</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">实践倒置原则的方案有很多，在 iOS 侧，OC 语言和 Foundation 库给我们提供了数个可用于抽象的语言工具。在这一节我们将对其中部分实践进行分析。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">1. 使用依赖注入</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">代表作品有 Objection 和 Typhoon，两者都是 OC 中的依赖注入框架，前者轻量级，后者较重并支持 Swift。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">比较具有通用性的方法是使用「协议」 &lt;-&gt; 「类」绑定的方式，对于要注入的对象会有对应的 Protocol 进行约束，会经常看到一些</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">RegisterClass:ForProtocol：</span></code><span style="font-size: 15px;">和</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">classFromProtocol</span></code><span style="font-size: 15px;">的代码。在需要使用注入对象时，用框架提供的接口以协议作为入参从容器中获得初始化后的所需对象。也可以在 Register 的时候直接注册一段 Block-Code，这个代码块用来初始化自己，作为id类型的返回值返回，可以支持一些编译检查来确保对应代码被编译。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">美团内推行将一些运行时加载的操作前移至编译时，比如将各项注册从 +load 改为在编译期使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">__attribute((used,section("__DATA,key")))</span></code><span style="font-size: 15px;"> 写入 mach-O 文件 Data 的 Segment 中来减少冷启动的时间消耗。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">因此，该方案的局限性在于：代码块存取的性能消耗较大，并且协议与类的绑定关系的维护需要花费更多的时间成本。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">2. 基于SPI机制</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">全称是 Service Provider Interfaces，代表作品是 ServiceLoader。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">实现过程大致是：A库与B库之间无依赖，但都依赖于P平台。把B库内的一个接口I下沉到平台层（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">“平台层”也叫做“通用能力层”，下文统一用平台层表示</span><span style="font-size: 15px;">），入参和返回值的类型需要平台层包含，接口I的实现放在B库里（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">因为实现在B库，所以实现里可以正常引用B库的元素</span><span style="font-size: 15px;">）。然后A库通过P平台的这个接口I来实现功能。A可以调用的到接口I，但是在B的库中进行实现。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在A库需要通过一个接口I实例化出一个对象，使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">ServiceLoader.load</span></code><span style="font-size: 15px;">（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">接口，key</span><span style="font-size: 15px;">），通过注册过的key使用反射找到这个接口imp的文件路径然后得到这个实例对象调用对应接口。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这个操作在安卓中使用较为广泛，大致相当于用反射操作来替代一次了 import 这样的耦合引用。但实际上iOS中若使用反射来实现功能则完全不必这么麻烦。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">关于反射，Java可以实现类似于</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">ClassFromString</span></code><span style="font-size: 15px;">的功能，但是无法直接使用 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">MethodFromString</span></code><span style="font-size: 15px;">的功能。并且</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">ClassFromString</span></code><span style="font-size: 15px;">也是通过字符串map到这个类的文件路径，类似于 com.waimai.home.searchImp，从而可以获得类型然后实例化，而OC的反射是通过消息机制实现。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">3. 基于通知中心</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">之前和一个做读书类App的同学交流，发现行业内有些公司的团队在使用 NotificationCenter 进行一些解耦的通信，因为通知中心本身支持传递对象，并且通知中心的功能也原生支持同步执行，所以也可以达到目的。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">通知中心在iOS 9之后有一次比较大的升级，将通知支持了 request 和 response 的处理逻辑，并支持获取到通知的发送者。比以往的通知群发但不感知发送者和是否收到，进步了很多。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">字符串的约定也可以理解为一个简化的协议，可设置成宏或常量放在平台层进行统一的维护。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">比较明显的缺陷是开发的统一范式难以约束，风格迥异，且字符串相较于接口而言还是难以管理。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">4. 使用objc_msgSend</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这是iOS原生消息机制中最万能的方法，编写时会有一些硬编码。核心代码如下：</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">id</span>&nbsp;s&nbsp;=&nbsp;((<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">id</span>(*)(<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">id</span>,&nbsp;SEL))objc_msgSend)(ClassName,<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@selector</span>(methodName));&nbsp;<br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这种方法的特点是即插即用，在开发者能100%确定整条调用链没问题的时候，可以快速实现功能。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">此方案的缺陷在于编写十分随意，检查和校验的逻辑还不够，满屏的强转。对于 int、Integer、NSNumber 这样的很容易发生类型转换错误，结果虽然不报错，但数字会有错误。</span></p> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>方案对比</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">接下来，我们对这几个大方向进行一些性能对比。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">考虑到在公司内的实际用法与限制，可能比常规方法增加了若干步骤，结果也可能会与常规裸测存在一定的偏差。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">例如依赖注入常用做法是存在单例（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">内存</span><span style="font-size: 15px;">）里，但是我们为了优化冷启动时间都写入 mach-O 文件 Data 的 Segment 里了，所以在我们的统计口径下存取时间会相对较长。</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;为了不暴露类名将业务属性用“some”代替，并隐藏初始化、循环100W次、差值计算等代码，关键操作代码如下</span><br><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;存取注入对象</span><br>xxConfig&nbsp;=&nbsp;[[WMSomeGlueCore&nbsp;sharedInstance]&nbsp;createObjectForProtocol:<span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@protocol</span>(<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">WMSomeProtocol</span>)];</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;通知发送</span><br>[[<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSNotificationCenter</span>&nbsp;defaultCenter]postNotificationName:<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">@"nixx"</span>&nbsp;object:<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>];<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;原生接口调用</span><br>a&nbsp;=&nbsp;[WMSomeClass&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>];<br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;反射调用</span><br>b&nbsp;=&nbsp;objc_getClass(<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"WMSomeClass"</span>);<br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">运行结果显示如下：</span></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.20875912408759123" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7avkKevSrLdicQjzjJ0MHlIDlrJDcmbYJCian5mCB7vcpNgNTiaChhv8BvA/640?wx_fmt=png" data-type="png" data-w="1370" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7avkKevSrLdicQjzjJ0MHlIDlrJDcmbYJCian5mCB7vcpNgNTiaChhv8BvA/640?wx_fmt=png"></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.20190779014308427" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aqNfzv2KRMQXQyfLsxrrTNxXyHJOeDbw6iclfKZsd3QES8CuRZh7wJrQ/640?wx_fmt=png" data-type="png" data-w="1258" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aqNfzv2KRMQXQyfLsxrrTNxXyHJOeDbw6iclfKZsd3QES8CuRZh7wJrQ/640?wx_fmt=png"></p> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"></center> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <span style="color: rgb(136, 136, 136);font-size: 14px;">图1-2 性能消耗检测</span> 
 </center> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">可以看出原生的接口调用明显是最高效的用法，反射的时长比原生要多一个数量级，不过100W次也就是多了几十毫秒，还在可以接受的范围之内。通知发送相比之下性能就很低了，存取注入对象更低。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">当然除了性能消耗外，还有很多不好量化的维度，包括规范约束、功能性、代码量、可读性等，笔者按照实际场景客观评价给出对比的分值。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">下面，我们用五种维度的能力值图来对比每一种方案优缺点：</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">各维度的的评分考虑到了一定的实际场景，可能和常规结果稍有偏差。</span></p></li> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">已经做了转化，看图面积越大越优。可读性的维度越长代表可读性越高，代码量的维度越长代表代码成本越少。</span></p></li> 
 </ul> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.25592885375494073" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aJqe4ic3NXBswhX8I5XPAP8xA8Rasic0ks3Smp1ibjCe9Od4StZzbtzLfw/640?wx_fmt=png" data-type="png" data-w="2024" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aJqe4ic3NXBswhX8I5XPAP8xA8Rasic0ks3Smp1ibjCe9Od4StZzbtzLfw/640?wx_fmt=png"></p> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <span style="color: rgb(136, 136, 136);font-size: 14px;">图2-1 各方案优缺点对比</span> 
 </center> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如图2所示，可以看出上图的四种方式或多或少都存在一些缺点：</span></p> 
 <ol style="" class=" list-paddingleft-2"> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">依赖注入是因为美团的实际场景问题，所以在性能消耗上存在明显的短板，并且代码量和可读性都不突出，规范约束这里是亮点。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">SPI机制的范围图很大，但使用了反射，并且代码开发成本较高，实践上来看，对协议管理有一定要求。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">通知中心除了代码少一些，其他维度都是短板。</span></p></li> 
  <li><p><span style="color: inherit;line-height: inherit;font-size: 15px;">而msgsend功能强大，代码量也少，但是在规范约束和可读性上几乎为零。</span></p></li> 
 </ol> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">综合看来 SPI 和 objc_msgSend 两者的特点比较明显，很有潜力，如果针对这两种方案分别进行一定程度的完善，应该可以实现一个综合评分更高的方案。</span></p> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>从现有方案中完善或衍生出的方案</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">5. 使用Category+NSInvocation</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">此方案从 <strong style="font-size: inherit;color: inherit;line-height: inherit;">objc_msgSend</strong> 演化而来。NSInvocation 的调用方式的底层还是会使用到 <strong style="font-size: inherit;color: inherit;line-height: inherit;">objc_msgSend</strong>，但是通过一些方法签名和返回值类型校验，可以解决很多类型规范相关的问题，并且这种方式没有繁琐的注册步骤，任何一次新接口的添加，都可以直接在低层的库中进行完成。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">为了更进一步限制调用者能够调用的接口，创建一些 Category 来提供接口，内部包装下层接口，把返回值和入参都限制实际的类型。业界比较接近的例子有 casatwy 的 CTMediator。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">6. 原生CategoryCoverOrigin方式</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">此方案从 SPI 方式演化而来。两个的共同点是都在平台层提供接口供业务方调用，不同点是此方式完全规避了各种硬编码。而且 CategoryCoverOrigin 是一个思想，没有任何框架代码，可以说 OC 的 Runtime 就是这个方案的框架支撑。此方案的核心操作是在基类里汇总所有业务接口，在上层的业务库中创建基类的 Category 中对声明的接口进行覆盖。整个过程没有任何硬编码与反射。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">演化出的这两种方案能力评估如下（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">绿色部分</span><span style="font-size: 15px;">），图中也贴了和演化前方案（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">桔色部分</span><span style="font-size: 15px;">）的对比：</span></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.2751269035532995" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7a3iaxPeSqqIb23icPpMoSSkeRyGLP3k4zJXrGDJFDp4H3ZHAw9ruKH8iaw/640?wx_fmt=png" data-type="png" data-w="1970" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7a3iaxPeSqqIb23icPpMoSSkeRyGLP3k4zJXrGDJFDp4H3ZHAw9ruKH8iaw/640?wx_fmt=png"></p> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <span style="color: rgb(136, 136, 136);font-size: 14px;">图2-2 两种演化方案对比</span> 
 </center> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">上文对这两种方案描述的非常概括，可能有同学会对能力评估存在质疑。接下来会分别进行详解的介绍，并描述在实际操作值得注意的细节。这两种方案组合成了外卖内部的组件通信框架 WMScheduler。</span></p> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>WMScheduler组件通信</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">外卖的 WMScheduler 主要是通过对 Category 特性的运用来实现组件间通信，实际操作中有两种的应用方案：Category+NSInvocation 和 CategoryCoverOrigin。</span></p> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">1. Category+NSInvocation方案</span></h4> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">方案简介</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">这个方案将其对 NSInvocation 功能容错封装、参数判断、类型转换的代码写在下层，提供简易万能的接口。并在上层创建通信调度器类提供常用接口，在调度器的 Category 里扩展特定业务的专用接口。所有的上层接口均有规范约束，这些规范接口的内部会调用下层的简易万能接口即可通过NSInvocation 相关的硬编码操作调用任何方法。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">UML图</strong></span></p> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.7315340909090909" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7a29EcnqQXE5tW5ocfooXXPYQh7b0AF9kKptLnKCaiabdyHJwHkicBO6qA/640?wx_fmt=png" data-type="png" data-w="1408" style="width: 434px;height: 317px;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7a29EcnqQXE5tW5ocfooXXPYQh7b0AF9kKptLnKCaiabdyHJwHkicBO6qA/640?wx_fmt=png"></p> 
  <span style="font-size: 15px;"></span> 
 </center> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <span style="color: rgb(136, 136, 136);font-size: 14px;">图3-1 Category+NSInvocation的UML图</span> 
 </center> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如图3-1所示，代码的核心在 </span><a href="https://github.com/dsxNiubility/WMScheduler/blob/master/CategoryInvocation/Pods/WMPlatformPKit/Classes/WMSchedulerCore/WMSchedulerCore.m" style="line-height: inherit;color: rgb(30, 107, 184);font-size: 15px;text-decoration: underline;"><span style="font-size: 15px;">WMSchedulerCore 类</span></a><span style="font-size: 15px;">，其包含了基于 NSInvocation 对 target 与 method 的操作、对参数的处理（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">包括对象，基本数据类型，NULL类型</span><span style="font-size: 15px;">）、对异常的处理等等，最终开放了简洁的万能接口，接口参数有 target、method、parameters等等，然后内部帮我们完成调用。但这个接口并不是让上层业务直接进行调用，而是需要创建一个 WMSchedule r的 Category，在这个 Category 中编写规范的接口（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">前缀、入参类型、返回值类型都是确定的</span><span style="font-size: 15px;">）。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">值得一提的是，提供业务专用接口的 Category 没有以 WMSchedulerCore 为基类，而是以 WMScheduler 为基类。看似多此一举，实际上是为了做权限的隔离。<br>上层业务只能访问到 WMScheduler.h 及其 Category 的规范接口。并不能访问到 WMSchedulerCore.h 提供的“万能但不规范”接口。</span></p> 
 <section class="output_wrapper" style="color: rgb(62, 62, 62);font-size: 16px;line-height: 1.6;letter-spacing: 0px;"> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">例如：在UML图中可以看到 外界只可以调用到</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">wms_getOrderCountWithPoiid</span></code><span style="font-size: 15px;">（规范接口），并不能使用</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">wm_excuteInstance</span></code> <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">Method</span></code><span style="font-size: 15px;">（万能接口）。</span></p> 
 </section> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">为了更好地理解实际使用，笔者贴一个组件调用周期的完整代码：</span></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.36486486486486486" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aNAsoU2uPHTxn9m6vhI7rMuMkrLib8QRdubn2O0L505nGWhMhZjia98ibA/640?wx_fmt=png" data-type="png" data-w="1480" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aNAsoU2uPHTxn9m6vhI7rMuMkrLib8QRdubn2O0L505nGWhMhZjia98ibA/640?wx_fmt=png"></p> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <span style="color: rgb(136, 136, 136);font-size: 14px;">图3-2 Category+NSInvocation的示例图</span> 
 </center> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如图3-2，在这种方案下，“B库调用A库方法”的需求只需要改两个仓库的代码，需要改动的文件标了下划线，请仔细看下示例代码。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">示例代码</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">平台（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">通用功能</span><span style="font-size: 15px;">）库三个文件：</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">①</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;WMScheduler+AKit.h</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"WMScheduler.h"</span></span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@interface</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">WMScheduler</span>(<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">AKit</span>)</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">/**<br>&nbsp;*&nbsp;通过商家id查到当前购物车已选e的小红点数量<br>&nbsp;*&nbsp;@param&nbsp;poiid&nbsp;&nbsp;商家id<br>&nbsp;*&nbsp;@return&nbsp;实际的小红点数量<br>&nbsp;*/</span><br>+&nbsp;(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSUInteger</span>)wms_getOrderedFoodCountWithPoiID:(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSNumber</span>&nbsp;*)poiID;<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@end</span><br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">②</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;WMScheduler+AKit.m</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"WMSchedulerCore.h"</span></span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"WMScheduler+AKit.h"</span></span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"NSObject+WMScheduler.h"</span></span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@implementation</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">WMScheduler</span>&nbsp;(<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">AKit</span>)</span><br>+&nbsp;(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSUInteger</span>)wms_getOrderedFoodCountWithPoiID:(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSNumber</span>&nbsp;*)poiID{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;(<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&nbsp;==&nbsp;poiid)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;clang&nbsp;diagnostic&nbsp;push</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;clang&nbsp;diagnostic&nbsp;ignored&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"-Wundeclared-selector"</span></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">id</span>&nbsp;singleton&nbsp;=&nbsp;[wm_scheduler_getClass(<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"WMXXXSingleton"</span>)&nbsp;wm_executeMethod:<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@selector</span>(sharedInstance)];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSNumber</span>*&nbsp;orderFoodCount&nbsp;=&nbsp;[singleton&nbsp;wm_executeMethod:<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@selector</span>(calculateOrderedFoodCountWithPoiID:)&nbsp;params:@[poiID]];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;orderFoodCount&nbsp;==&nbsp;<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&nbsp;?&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>&nbsp;:&nbsp;[orderFoodCount&nbsp;integerValue];<br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;clang&nbsp;diagnostic&nbsp;pop</span><br>}<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@end</span><br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">③</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;WMSchedulerInterfaceList.h</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#ifndef&nbsp;WMSchedulerInterfaceList_h</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#define&nbsp;WMSchedulerInterfaceList_h</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;这个文件会被加到上层业务的pch里，所以下文不用import本文件</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"WMScheduler.h"</span></span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"WMScheduler+AKit.h"</span></span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#endif&nbsp;/*&nbsp;WMSchedulerInterfaceList_h&nbsp;*/</span><br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">BKit （</span><span style="font-size: 15px;color: rgb(136, 136, 136);">调用方</span><span style="font-size: 15px;">）一个文件：</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;WMHomeVC.m</span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@interface</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">WMHomeVC</span>&nbsp;()&nbsp;&lt;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">UITableViewDataSource</span>,&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">UITableViewDelegate</span>&gt;</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@end</span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@implementation</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">WMHomeVC</span></span><br>...<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSUInteger</span>&nbsp;*foodCount&nbsp;=&nbsp;[WMScheduler&nbsp;wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSLog</span>(<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">@"%ld"</span>,foodCount);<br>...<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@end</span><br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">代码分析</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">上文四个文件完成了一次跨组件的调用，在 WMScheduler+AKit.m 中的第30、31行，调用的都是AKit（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">提供方</span><span style="font-size: 15px;">）的现有方法，因为 WMSchedulerCore 提供了 NSInvocation 的调用方式，所以可以直接向上调用。WMScheduler+AKit 中提供的接口就是上文说的“规范接口”，这个接口在WMHomeVC（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">调用方</span><span style="font-size: 15px;">）调用时和调用本仓库内的OC方法，并没有区别。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">延伸思考</strong></span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">上文的例子中入参和返回值都是基本数据类型，Domain 也是支持的，前提是这个 Domain 是放在平台库的。我们可以将工程中的 Domain 分为BO（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">Business Object</span><span style="font-size: 15px;">）、VO（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">View Object</span><span style="font-size: 15px;">）与TO（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">Transfer Object</span><span style="font-size: 15px;">），VO 经常出现在 view 和 cell，BO一般仅在各业务子库内部使用，这个TO则是需要放在平台库是用于各个组件间的通信的通用模型。例如：通用 PoiDomain，通用 OrderDomain，通用 AddressDomain 等等。这些称为 TO 的 Domain 可以作为规范接口的入参类型或返回值类型。</span></p></li> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在实际业务场景中，跳转页面时传递 Domain 的需求也是一个老生常谈的问题，大多数页面级跳转框架仅支持传递基本数据类型（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">也有 trick 的方式传 Domain 内存地址但很不优雅</span><span style="font-size: 15px;">）。在有了上文支持的能力，我们可以在规范接口内通过万能接口获取目标页面的VC，并调用其某个属性的 set 方法将我们想传递的Domain赋值过去，然后将这个 VC 对象作为返回值返回。调用方获得这个 VC 后在当前的导航栈内push即可。</span></p></li> 
 </ul> 
 <section class="output_wrapper" style="color: rgb(62, 62, 62);font-size: 16px;line-height: 1.6;letter-spacing: 0px;"> 
  <section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;"> 
   <ul style="" class=" list-paddingleft-2"> 
    <li><p><span style="font-size: 15px;">上文代码中我们用 WMScheduler 调用了 Akit 的一个名为</span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">calculateOrderedFoodCount</span></code> <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">WithPoiID：</span></code><span style="font-size: 15px;">的方法。那么有个争议点：在组件通信需要调用某方法时，是允许直接调用现有方法，还是复制一份加上前缀标注此方法专门用于提供组件通信？</span></p></li> 
   </ul> 
  </section> 
 </section> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">阶段总结</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Category+NSInvocation 方案的优点是便捷，因为 Category 的专用接口放在平台库，以后有除了 BKit 以外的其他调用方也可以直接调用，还有更多强大的功能。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">但是，不优雅的地方我们也列举一下：</span></p> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">当这个跨组件方法内部的代码行数比较多时，会写很多硬编码。</span></p></li> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">硬编码method字符串，在现有方法被修改时，编译检测不报错（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">只能靠断言约束</span><span style="font-size: 15px;">）。</span></p></li> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">下层库向上调用的设计会被诟病。</span></p></li> 
 </ul> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">接下来介绍的 CategoryCoverOrigin 的方案，可以解决这三个问题。</span></p> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">2. CategoryCoverOrigin方案</span></h4> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">方案简介</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">首先说明下这个方案和 NSInvocation 没有任何关系，此方案与上一方案也是完全不同的两个概念，不要将上一个方案的思维带到这里。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">此方案的思路是在平台层的 WMScheduler.h 提供接口方法，接口的实现只写空实现或者兜底实现（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">兜底实现中可根据业务场景在 Debug 环境下增加 toast 提示或断言</span><span style="font-size: 15px;">），上层库的提供方实现接口方法并通过 Category 的特性，在运行时进行对基类同名方法的替换。调用方则正常调用平台层提供的接口。在 CategoryCoverOrigin 的方案中 WMScheduler 的 Category 在提供方仓库内部，因此业务逻辑的依赖可以在仓库内部使用常规的OC调用。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">UML图</strong></span></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.5959252971137521" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aYx5Bya6Yxtia9K7T2s8PSJUcj8SyYic2GvsL4nrmia5zUlwlEtHzMJhMQ/640?wx_fmt=png" data-type="png" data-w="1178" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aYx5Bya6Yxtia9K7T2s8PSJUcj8SyYic2GvsL4nrmia5zUlwlEtHzMJhMQ/640?wx_fmt=png"></p> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <span style="color: rgb(136, 136, 136);font-size: 14px;">图4-1 CategoryCover 的 UML 图</span> 
 </center> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">从图4-1可以看出，WMScheduler 的 Category 被移到了业务仓库，并且 WMScheduler 中有所有接口的全集。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">为了更好地理解 CategoryCover 实际应用，笔者再贴一个此方案下的完整代码：</span></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.31125827814569534" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7ajeL4QmSej38jQ2kzQjribYx77nhedz9bhia8nMoC4nEM9k8ibYeWr78Dg/640?wx_fmt=png" data-type="png" data-w="1510" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7ajeL4QmSej38jQ2kzQjribYx77nhedz9bhia8nMoC4nEM9k8ibYeWr78Dg/640?wx_fmt=png"></p> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <span style="color: rgb(136, 136, 136);font-size: 14px;">图4-2 CategoryCover的示例图</span> 
 </center> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如图4-2，在这种方案下，“B库调用A库方法”的需求需要修改三个仓库的代码，但除了这四个编辑的文件，没有其他任何的依赖了，请仔细看下代码示例。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">示例代码</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">平台（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">通用功能库</span><span style="font-size: 15px;">）两个文件：</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">①</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;&nbsp;WMScheduler.h</span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@interface</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">WMScheduler</span>&nbsp;:&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">NSObject</span></span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;&nbsp;这个文件是所有组件通信方法的汇总</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;mark&nbsp;-&nbsp;AKit&nbsp;&nbsp;</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">/**<br>&nbsp;*&nbsp;通过商家id查到当前购物车已选e的小红点数量<br>&nbsp;*&nbsp;@param&nbsp;poiid&nbsp;&nbsp;商家id<br>&nbsp;*&nbsp;@return&nbsp;实际的小红点数量<br>&nbsp;*/</span><br>+&nbsp;(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSUInteger</span>)wms_getOrderedFoodCountWithPoiID:(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSNumber</span>&nbsp;*)poiID;<br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;mark&nbsp;-&nbsp;CKit</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;...</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;mark&nbsp;-&nbsp;DKit</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;...</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@end</span><br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">②</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;WMScheduler.m</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"WMScheduler.h"</span></span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@implementation</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">WMScheduler</span></span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;mark&nbsp;-&nbsp;Akit</span><br>+&nbsp;(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSUInteger</span>)wms_getOrderedFoodCountWithPoiID:(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSNumber</span>&nbsp;*)poiID<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;这个.m里只要求一个空实现&nbsp;作为兜底方案。</span><br>}<br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;mark&nbsp;-&nbsp;Ckit</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;...</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;mark&nbsp;-&nbsp;Dkit</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;...</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@end</span><br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">AKit（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">提供方</span><span style="font-size: 15px;">）一个 Category 文件：</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;WMScheduler+AKit.m</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"WMScheduler.h"</span></span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"WMAKitBusinessManager.h"</span></span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#import&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"WMXXXSingleton.h"</span>&nbsp;&nbsp;</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;直接导入了很多AKit相关的业务文件，因为本身就在AKit仓库内</span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@implementation</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">WMScheduler</span>&nbsp;(<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">AKit</span>)</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;这个宏可以屏蔽分类覆盖基类方法的警告</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;clang&nbsp;diagnostic&nbsp;push</span><br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;clang&nbsp;diagnostic&nbsp;ignored&nbsp;<span class="hljs-meta-string" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">"-Wobjc-protocol-method-implementation"</span></span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;在平台层写过的方法，这边是是自动补全的</span><br>+&nbsp;(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSUInteger</span>)wms_getOrderedFoodCountWithPoiID:(<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSNumber</span>&nbsp;*)poiID<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;(<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&nbsp;==&nbsp;poiid)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;所有AKIT相关的类都能直接接口调用，不需要任何硬编码，可以和之前的写法对比下。</span><br>&nbsp;&nbsp;&nbsp;&nbsp;WMXXXSingleton&nbsp;*singleton&nbsp;=&nbsp;[WMXXXSingleton&nbsp;sharedInstance];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSNumber</span>&nbsp;*orderFoodCount&nbsp;=&nbsp;[singleton&nbsp;calculateOrderedFoodCountWithPoiID:poiID];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;orderFoodCount&nbsp;==&nbsp;<span class="hljs-literal" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&nbsp;?&nbsp;<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>&nbsp;:&nbsp;[orderFoodCount&nbsp;integerValue];<br>}<br><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#pragma&nbsp;clang&nbsp;diagnostic&nbsp;pop</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@end</span><br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">BKit（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">调用方</span><span style="font-size: 15px;">） 一个文件写法不变：</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="objc language-objc hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;WMHomeVC.m</span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@interface</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">WMHomeVC</span>&nbsp;()&nbsp;&lt;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">UITableViewDataSource</span>,&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">UITableViewDelegate</span>&gt;</span><br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@end</span><br><span class="hljs-class" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@implementation</span>&nbsp;<span class="hljs-title" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">WMHomeVC</span></span><br>...<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSUInteger</span>&nbsp;*foodCount&nbsp;=&nbsp;[WMScheduler&nbsp;wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">NSLog</span>(<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">@"%ld"</span>,foodCount);<br>...<br><span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">@end</span><br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">代码分析</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">CategoryCoverOrigin 的方式，平台库用 WMScheduler.h 文件存放所有的组件通信接口的汇总，各个仓库用注释隔开，并在.m文件中编写了空实现。功能代码编写在服务提供方仓库的 WMScheduler+AKit.m，看这个文件的17、18行业务逻辑是使用常规 OC 接口调用。在运行时此Category的方法会覆盖 WMScheduler.h 基类中的同名方法，从而达到目的。CategoryCoverOrigin 方式不需要其他功能类的支撑。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">延伸思考</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如果业务库很多，方法很多，会不会出现 WMScheduler.h 爆炸？ &nbsp;目前我们的工程跨组件调用的实际场景不是很多，所以汇总在一个文件了，如果满屏都是跨组件调用的工程，则需要思考业务架构与模块划分是否合理这一问题。当然，如果真出现 WMScheduler.h 爆炸的情况，完全可以将各个业务的接口移至自己Category 的.h文件中，然后创建一个 WMSchedulerInterfaceList 文件统一 import 这些 Category。</span></p> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>两种方案的选择</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">刚才我们对于 Category+NSInvocation 和 CategoryCoverOrigin 两种方式都做了详细的介绍，我们再整理一下两者的优缺点对比：</span></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.3355761143818335" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aH8zYZr95KXawXKrePoQhaNpa31d6RZDTfcwVFgUZCibE7lKJDlzhwXw/640?wx_fmt=png" data-type="png" data-w="1189" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aH8zYZr95KXawXKrePoQhaNpa31d6RZDTfcwVFgUZCibE7lKJDlzhwXw/640?wx_fmt=png"></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">笔者更建议使用 CategoryCoverOrigin 的无硬编码的方案，当然具体也要看项目的实际场景，从而做出最优的选择。</span></p> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>更多建议</strong></span></h3> 
 <ul style="" class=" list-paddingleft-2"> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">关于组件对外提供的接口，我们更倾向于借鉴 SPI 的思想，作为一个 Kit 哪些功能是需要对外公开的？提供哪些服务给其他方解耦调用？建议主动开放核心方法，尽量减少“用到才补”的场景。例如全局购物车就需要“提供获取小红点数量的方法”，商家中心就需要提供“根据字符串 id 得到整个 Poi 的 Domain”的接口服务。</span></p></li> 
  <li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">需要考虑到抽象能力，提供更有泛用性的接口。比如“获取到了最低满减价格后拼接成一个文案返回字符串” 这个方法，就没有“获取到了最低满减价格” 这个方法具备泛用性。</span></p></li> 
 </ul> 
 <h2 style="color: rgb(62, 62, 62);"><br></h2> 
 <h2 style="color: rgb(62, 62, 62);white-space: normal;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">Category风险管控</span></strong></h2> 
 <h3 style="color: rgb(62, 62, 62);"><br></h3> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>先举两个发生过的案例</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">1. 2017年10月 一个关于NSDate重复覆盖的问题</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">当时美团平台有 NSDate+MTAddition 类，在外卖侧有 NSDate+WMAddition 类。前者 NSDate+MTAddition 之前就有方法 getCurrentTimestamp，返回的时间戳是秒。后者 NSDate+WMAddition 在一次需求中也增加了 getCurrentTimestamp 方法，但是为了和其他平台统一口径返回值使用了毫秒。在正常的加载顺序中外卖类比平台类要晚，因此在外卖的测试中没有发现问题。但集成到 imeituan 主项目之后，原先其他业务方调用这个返回“秒”的方法，就被外卖测的返回“毫秒”的同名方法给覆盖了，出现接口错误和UI错乱等问题。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">2. 2018年3月 一个WMScheduler组件通信遇到的问题</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在外卖侧有订单组件和商家容器组件，这两个组件的联系是十分紧密的，有的功能放在两个仓库任意一个中都说的通。因此出现了了两个仓库写了同名方法的场景。在 WMScheduler+Restaurant 和 WMScheduler+Order 两个仓库都添加了方法 </span><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(233, 105, 0);background: rgb(248, 248, 248);"><span style="font-size: 15px;">-(void)wms_enterGlobalCartPageFromPage:</span></code><span style="font-size: 15px;">，在运行中这两处有一处被覆盖。在有一次 Bug 解决中，给其中一处增加了异常处理的代码，恰巧增加的这处先加载，就被后加载的同名方法覆盖了，这就导致了异常处理代码不生效的问题。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">那么使用 CategoryCover 的方式是不是很不安全？ NO！只要弄清其中的规律，风险点都是完全可以管控的，接下来，我们来分析 Category 的覆盖原理。</span></p> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>Category 方法覆盖原理</strong></span></h3> 
 <blockquote style="color: rgb(129, 145, 152);line-height: inherit;padding: 15px 15px 15px 1rem;font-size: 0.9em;margin-top: 1em;margin-bottom: 1em;border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);overflow: auto;overflow-wrap: normal;"> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">1) Category 的方法没有“完全替换掉”原来类已经有的方法，也就是说如果 Category 和原来类都有methodA，那么 Category 附加完成之后，类的方法列表里会有两个 methodA。</span></p> 
  <p style="font-size: inherit;color: inherit;line-height: inherit;"><span style="font-size: 15px;">2) Category 方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的 Category 的方法会“覆盖”掉原来类的同名方法，这是因为运行过程中，我们在查找方法的时候会顺着方法列表的顺序去查找，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</span></p> 
 </blockquote> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Category 在运行期进行决议，而基类的类是在编译期进行决议，因此分类中，方法的加载顺序一定在基类之后。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">美团曾经有一篇技术博客深入分析了 Category，并且从编译器和源码的角度对分类覆盖操作进行详细解析：《</span><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=204581622&amp;idx=1&amp;sn=167708e3baad013729143e0ec40c3565&amp;scene=21#wechat_redirect" target="_blank"><span style="font-size: 15px;">深入理解Objective-C：Category</span></a><span style="font-size: 15px;">》</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">根据方法覆盖的原理，我们可以分析出哪些操作比较安全，哪些存在风险，并针对性地进行管理。接下来，我们就介绍美团 Category 管理相关的一些工作。</span></p> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>Category 方法管理</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">由于历史原因，不管是什么样的管理规则，都无法直接“一刀切”。所以针对现状，我们将整个管理环节先拆分为“数据”、“场景”、 “策略”三部分。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">其中数据层负责发现异常数据，所有策略公用一个数据层。针对 Category 方法的数据获取，我们有如下几种方式：</span></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.2788697788697789" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7auuurDBoiaVO8rX2vxgARF3JiaCGHlNaqkrsfEQC3Jv6MMicZvCRc6zfLA/640?wx_fmt=png" data-type="png" data-w="1628" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7auuurDBoiaVO8rX2vxgARF3JiaCGHlNaqkrsfEQC3Jv6MMicZvCRc6zfLA/640?wx_fmt=png"></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">根据优缺点的分析，再考虑到美团已经彻底实现了“组件化”的工程，所以对 Category 的管控最好放在集成阶段以后进行。我们最终选择了使用 linkmap 进行数据获取，具体方法我们将在下文进行介绍。</span></p> 
 <p><span style="font-size: 15px;">策略部分则针对不同的场景异常进行控制，主要的开发工作位于我们的组件化 CI 系统上，即之前介绍过的 </span><span style="font-size: 15px;">《<a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651746367&amp;idx=1&amp;sn=816ddaa4dba78a795621c3f5a9d1ea07&amp;chksm=bd12a9728a6520641df6bcf90558da89e4e60d4f1c7c318740e1f4eb04eca403b722d9e73e34&amp;scene=21#wechat_redirect" target="_blank"><span style="letter-spacing: 0px;">Hyperloop，让发布简洁高效</span></a></span><span style="letter-spacing: 0px;font-size: 15px;">》系统。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">Hyperloop 本身即提供了包括白名单，发布集成流程管理等一系列策略功能，我们只需要将工具进行关联开发即可。我们开发的数据层作为一个独立组件，最终也是运行在 Hyperloop 上。</span></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.4538152610441767" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7am8iafYQPUAm7bJEgGCiaTgqorzLG3wGUBt1NScPLlLVFkJ5ibaBkuaGAQ/640?wx_fmt=png" data-type="png" data-w="1494" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7am8iafYQPUAm7bJEgGCiaTgqorzLG3wGUBt1NScPLlLVFkJ5ibaBkuaGAQ/640?wx_fmt=png"></p> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <span style="color: rgb(136, 136, 136);font-size: 14px;">图5-2 方法管理环节</span> 
 </center> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">根据场景细分的策略如下表所示（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">需要注意的是，表中有的场景实际不存在，只是为了思考的严谨列出</span><span style="font-size: 15px;">）：</span></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.45691609977324266" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aoNLDkc5v2MyK6kSmpjoKz6WNtibMnZdHiaMicObicwbry6F38oMBIwLGVA/640?wx_fmt=png" data-type="png" data-w="1764" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aoNLDkc5v2MyK6kSmpjoKz6WNtibMnZdHiaMicObicwbry6F38oMBIwLGVA/640?wx_fmt=png"></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">我们在前文描述的 CategoryCoverOrigin 的组件通信方案的管控体现在第2点。风险管控中提到的两个案例的管控主要体现在第4点。</span></p> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>Category 数据获取原理</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">上一章节，我们提到了采用 linkmap 分析的方式进行 Category 数据获取。在这一章节内，我们详细介绍下做法。</span></p> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">启用 linkmap</span></h4> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">首先，linkmap 生成功能是默认关闭的，我们需要在 build settings 内手动打开开关并配置存储路径。对于美团工程和美团外卖工程来说，每次正式构建后产生的 linkmap，我们还会通过内部的美团云存储工具进行持久化的存储，保证后续的可追溯。</span></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.4532940019665683" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aYKJ7TapfsungoJr6ic0nF9TUFRcAWeL22MT4rLQgHfhczvRBmPr7Yvw/640?wx_fmt=png" data-type="png" data-w="2034" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7aYKJ7TapfsungoJr6ic0nF9TUFRcAWeL22MT4rLQgHfhczvRBmPr7Yvw/640?wx_fmt=png"></p> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <span style="color: rgb(136, 136, 136);font-size: 14px;">图6 启用 linkmap 的设置</span> 
 </center> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">linkmap 组成</span></h4> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">若要解析 linkmap，首先需要了解 linkmap 的组成。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">如名称所示，linkmap 文件生成于代码链接之后，主要由4个部分组成：基本信息、Object files 表、Sections 表和 Symbols 表。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">前两行是基本信息，包括链接完成的二进制路径和架构。如果一个工程内有多个最终产物（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">如 Watch App 或 Extension</span><span style="font-size: 15px;">），则经过配置后，每一个产物的每一种架构都会生成一份 linkmap。</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs apache" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">#&nbsp;Path:&nbsp;/var/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828-59923-v4pjhg/output-sandbox/DerivedData/Build/Intermediates.noindex/ArchiveIntermediates/imeituan/InstallationBuildProductsLocation/Applications/imeituan.app/imeituan</span><br><span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">#&nbsp;Arch:&nbsp;arm64</span><br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">第二部分的 Object files，列举了链接所用到的所有的目标文件，包括代码编译出来的，静态链接库内的和动态链接库（</span><span style="font-size: 15px;color: rgb(136, 136, 136);">如系统库</span><span style="font-size: 15px;">），并且给每一个目标文件分配了一个 file id。</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs cs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">#&nbsp;Object&nbsp;files:</span><br>[<span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">&nbsp;&nbsp;0</span>]&nbsp;linker&nbsp;synthesized<br>[<span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">&nbsp;&nbsp;1</span>]&nbsp;dtrace<br>[<span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">&nbsp;&nbsp;2</span>]&nbsp;/<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">-59923</span>-v4pjhg/output-sandbox/DerivedData/Build/Intermediates.noindex/ArchiveIntermediates/imeituan/IntermediateBuildFilesPath/imeituan.build/DailyBuild-iphoneos/imeituan.build/Objects-normal/arm64/main.o<br>……<br>[<span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">&nbsp;26</span>]&nbsp;/<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">private</span>/<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>/folders/tk/xmlx38_x605127f0fhhp_n1r0000gn/T/d20180828<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">-59923</span>-v4pjhg/repo-sandbox/imeituan/Pods/AFNetworking/bin/libAFNetworking.a(AFHTTPRequestOperation.o)<br>……<br>[<span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">25919</span>]&nbsp;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">.3</span>.sdk/usr/lib/libobjc.tbd<br>[<span class="hljs-meta" style="font-size: 15px;line-height: inherit;color: rgb(91, 218, 237);overflow-wrap: inherit !important;word-break: inherit !important;">25920</span>]&nbsp;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">.3</span>.sdk/usr/lib/libSystem.tbd<br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">第三部分的 Sections，记录了所有的 Section，以及它们所属的 Segment 和大小等信息。</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs markdown" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;"><span class="hljs-section" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">#&nbsp;Sections:</span><br><span class="hljs-section" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">#&nbsp;Address&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Segment&nbsp;Section</span><br>0x100004450&nbsp;&nbsp;&nbsp;&nbsp;0x07A8A8D0&nbsp;&nbsp;<span class="hljs-strong" style="font-size: 15px;color: inherit;line-height: inherit;font-weight: bold;overflow-wrap: inherit !important;word-break: inherit !important;">__TEXT&nbsp;&nbsp;__</span>text<br>……<br>0x109EA52C0&nbsp;&nbsp;&nbsp;&nbsp;0x002580A0&nbsp;&nbsp;<span class="hljs-strong" style="font-size: 15px;color: inherit;line-height: inherit;font-weight: bold;overflow-wrap: inherit !important;word-break: inherit !important;">__DATA&nbsp;&nbsp;__</span>objc_data<br>0x10A0FD360&nbsp;&nbsp;&nbsp;&nbsp;0x001D8570&nbsp;&nbsp;<span class="hljs-strong" style="font-size: 15px;color: inherit;line-height: inherit;font-weight: bold;overflow-wrap: inherit !important;word-break: inherit !important;">__DATA&nbsp;&nbsp;__</span>data<br>0x10A2D58D0&nbsp;&nbsp;&nbsp;&nbsp;0x0000B960&nbsp;&nbsp;<span class="hljs-strong" style="font-size: 15px;color: inherit;line-height: inherit;font-weight: bold;overflow-wrap: inherit !important;word-break: inherit !important;">__DATA&nbsp;&nbsp;__</span>objc<span class="hljs-emphasis" style="font-size: 15px;color: inherit;line-height: inherit;font-style: italic;overflow-wrap: inherit !important;word-break: inherit !important;">_k_</span>kylin<br>……<br>0x10BFE4E5D&nbsp;&nbsp;&nbsp;&nbsp;0x004CBE63&nbsp;&nbsp;<span class="hljs-strong" style="font-size: 15px;color: inherit;line-height: inherit;font-weight: bold;overflow-wrap: inherit !important;word-break: inherit !important;">__RODATA&nbsp;&nbsp;&nbsp;&nbsp;__</span>objc_methname<br>0x10C4B0CC0&nbsp;&nbsp;&nbsp;&nbsp;0x000D560B&nbsp;&nbsp;<span class="hljs-strong" style="font-size: 15px;color: inherit;line-height: inherit;font-weight: bold;overflow-wrap: inherit !important;word-break: inherit !important;">__RODATA&nbsp;&nbsp;&nbsp;&nbsp;__</span>objc_classname<br></span></code></pre> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">第四部分的 Symbols 是重头戏，列举了所有符号的信息，包括所属的 object file、大小等。符号除了我们关注的 OC 的方法、类名、协议名等，也包含 block、literal string 等，可以供其他需求分析进行使用。</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="hljs css" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">#&nbsp;<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Symbols</span>:<br>#&nbsp;<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Address</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Size</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">File</span>&nbsp;&nbsp;<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">Name</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x1000045B8</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x00000060</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;&nbsp;2]</span>&nbsp;___<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">llvm_gcov_writeout</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x100004618</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x00000028</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;&nbsp;2]</span>&nbsp;___<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">llvm_gcov_flush</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x100004640</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x00000014</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;&nbsp;2]</span>&nbsp;___<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">llvm_gcov_init</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x100004654</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x00000014</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;&nbsp;2]</span>&nbsp;___<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">llvm_gcov_init</span><span class="hljs-selector-class" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">.4</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x100004668</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x00000014</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;&nbsp;2]</span>&nbsp;___<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">llvm_gcov_init</span><span class="hljs-selector-class" style="font-size: 15px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">.6</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x10000467C</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x0000015C</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;&nbsp;3]</span>&nbsp;_<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><br>……<br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x10002F56C</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x00000028</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;38]</span>&nbsp;<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">-</span><span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[UIButton(_AFNetworking)&nbsp;af_imageRequestOperationForState:]</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x10002F594</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x0000002C</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;38]</span>&nbsp;<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">-</span><span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[UIButton(_AFNetworking)&nbsp;af_setImageRequestOperation:forState:]</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x10002F5C0</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x00000028</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;38]</span>&nbsp;<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">-</span><span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[UIButton(_AFNetworking)&nbsp;af_backgroundImageRequestOperationForState:]</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x10002F5E8</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x0000002C</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;38]</span>&nbsp;<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">-</span><span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[UIButton(_AFNetworking)&nbsp;af_setBackgroundImageRequestOperation:forState:]</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x10002F614</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x0000006C</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;38]</span>&nbsp;+<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[UIButton(AFNetworking)&nbsp;sharedImageCache]</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x10002F680</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x00000010</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;38]</span>&nbsp;+<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[UIButton(AFNetworking)&nbsp;setSharedImageCache:]</span><br>0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x10002F690</span>&nbsp;&nbsp;&nbsp;&nbsp;0<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">x00000084</span>&nbsp;&nbsp;<span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[&nbsp;38]</span>&nbsp;<span class="hljs-selector-tag" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">-</span><span class="hljs-selector-attr" style="font-size: 15px;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[UIButton(AFNetworking)&nbsp;imageResponseSerializer]</span><br>……<br></span></code></pre> 
 <h4 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.2em;"><span style="color: inherit;line-height: inherit;font-size: 15px;">linkmap 数据化</span></h4> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">根据上文的分析，在理解了 linkmap 的格式后，通过简单的文本分析即可提取数据。由于美团内部 iOS 开发工具链统一采用 Ruby，所以 linkmap 分析也采用 Ruby 开发，整个解析器被封装成一个 Ruby Gem。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">具体实施上，处于通用性考虑，我们的 linkmap 解析工具分为解析、模型、解析器三层，每一层都可以单独进行扩展。</span></p> 
 <p style="color: rgb(62, 62, 62);text-align: center;"><img class="" data-copyright="0" data-ratio="0.19533169533169534" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7a8NfbIIver2DUncee0UjppoVv5XcKW8uxYfGOE7SFsGTGRvd3QjTJtA/640?wx_fmt=png" data-type="png" data-w="1628" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXibicYtRt824nicRjKGTibicl7a8NfbIIver2DUncee0UjppoVv5XcKW8uxYfGOE7SFsGTGRvd3QjTJtA/640?wx_fmt=png"></p> 
 <center style="color: inherit;font-size: inherit;line-height: inherit;"> 
  <span style="color: rgb(136, 136, 136);font-size: 14px;">图7 linkmap解析工具</span> 
 </center> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于 Category 分析器来说，link map parser 解析指定 linkmap，生成通用模型的实例。从实例中获取 symbol 类，将名字中有“()”的符号过滤出来，即为 Category 方法。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">接下来只要按照方法名聚合，如果超过1个则肯定有 Category 方法冲突的情况。按照上一节中分析的场景，分析其具体冲突类型，提供结论输出给 Hyperloop。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">具体对外接口可以直接参考我们的工具测试用例。最后该 Gem 会直接被 Hyperloop 使用。</span></p> 
 <pre style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 0px;margin-bottom: 0px;padding: 0px;"><code class="ruby language-ruby hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;overflow: auto !important;"><span style="font-size: 15px;">&nbsp;it&nbsp;<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">'should&nbsp;return&nbsp;a&nbsp;map&nbsp;with&nbsp;keys&nbsp;for&nbsp;method&nbsp;name&nbsp;and&nbsp;classify'</span>&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">do</span><br>&nbsp;&nbsp;&nbsp;&nbsp;@parser&nbsp;=&nbsp;LinkmapParser::Parser.new<br>&nbsp;&nbsp;&nbsp;&nbsp;@file_path&nbsp;=&nbsp;<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">'spec/fixtures/imeituan-LinkMap-normal-arm64.txt'</span><br>&nbsp;&nbsp;&nbsp;&nbsp;@analyze_result_with_classification&nbsp;=&nbsp;@parser.parse&nbsp;@file_path<br><br>&nbsp;&nbsp;&nbsp;&nbsp;expect(@analyze_result_with_classification.<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>).to&nbsp;eq(Hash)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">#&nbsp;Category&nbsp;方法互相冲突</span><br>&nbsp;&nbsp;&nbsp;&nbsp;symbol&nbsp;=&nbsp;@analyze_result_with_classification[<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"-[NSDate&nbsp;isEqualToDateDay:]"</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol.<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>).to&nbsp;eq(Hash)<br>&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[<span class="hljs-symbol" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">:type</span>]).to&nbsp;eq([LinkmapParser::CategoryConflictType::CONFLICT])<br>&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[<span class="hljs-symbol" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">:detail</span>].<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>).to&nbsp;eq(Array)<br>&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[<span class="hljs-symbol" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">:detail</span>].count).to&nbsp;eq(<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">3</span>)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: 15px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">#&nbsp;Category&nbsp;方法覆盖原方法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;symbol&nbsp;=&nbsp;@analyze_result_with_classification[<span class="hljs-string" style="font-size: 15px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"-[UGCReviewManager&nbsp;setCommonConfig:]"</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol.<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>).to&nbsp;eq(Hash)<br>&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[<span class="hljs-symbol" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">:type</span>]).to&nbsp;eq([LinkmapParser::CategoryConflictType::REPLACE])<br>&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[<span class="hljs-symbol" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">:detail</span>].<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>).to&nbsp;eq(Array)<br>&nbsp;&nbsp;&nbsp;&nbsp;expect(symbol[<span class="hljs-symbol" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">:detail</span>].count).to&nbsp;eq(<span class="hljs-number" style="font-size: 15px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">2</span>)<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: 15px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">end</span><br></span></code></pre> 
 <h3 style="color: rgb(62, 62, 62);"><br></h3> 
 <h3 style="color: rgb(62, 62, 62);"><span style="font-size: 18px;"><strong>Category 方法管理总结</strong></span></h3> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">1. 风险管理</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">对于任何语法工具，都是有利有弊的。所以除了发掘它们在实际场景中的应用，也要时刻对它们可能带来的风险保持警惕，并选择合适的工具和时机来管理风险。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">而 Xcode 本身提供了不少的工具和时机，可以供我们分析构建过程和产物。若是在日常工作中遇到一些坑，不妨从构建期工具的角度去考虑管理。比如本文内提到的 linkmap，不仅可以用于 Category 分析，还可以用于二进制大小分析、组件信息管理等。投入一定资源在相关工具开发上，往往可以获得事半功倍的效果。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">2. 代码规范</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">回到 Category 的使用，除了工具上的管控，我们也有相应的代码规范，从源头管理风险。如我们在规范中要求所有的 Category 方法都使用前缀，降低无意冲突的可能。并且我们也计划把“使用前缀”做成管控之一。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><strong style="font-size: inherit;color: inherit;line-height: inherit;">3. 后续规划</strong></span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">（1）覆盖系统方法检查&nbsp;&nbsp;</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">由于目前在管控体系内暂时没有引入系统符号表，所以无法对覆盖系统方法的行为进行分析和拦截。我们计划后续和 Crash 分析系统打通符号表体系，提早发现对系统库的不当覆盖。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">（2）工具复用&nbsp;&nbsp;</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">当前的管控系统仅针对美团外卖和美团 App，未来计划推广到其他 App。由于有 Hyperloop，事情在技术上并没有太大的难度。&nbsp;&nbsp;</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;color: inherit;letter-spacing: 0px;">从工具本身的角度看，我们有计划在合适的时机对数据层代码进行开源，希望能对更多的开发有所帮助。</span><span style="font-size: 15px;"><br></span></p> 
 <h2 style="color: rgb(62, 62, 62);white-space: normal;"><strong style="color: rgb(51, 51, 51);font-size: 20px;"><span style="color: rgb(49, 188, 173);">总结</span></strong></h2> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">在这篇文章中，我们从具体的业务场景入手，总结了组件间调用的通用模型，并对常用的解耦方案进行了分析对比，最终选择了目前最适合我们业务场景的方案。即通过 Category 覆盖的方式实现了依赖倒置，将构建时依赖延后到了运行时，达到我们预期的解耦目标。同时针对该方案潜在的问题，通过 linkmap 工具管控的方式进行规避。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;">另外，我们在模型设计时也提到，组件间解耦其实在 iOS 侧有多种方案选择。对于其他的方案实践，我们也会陆续和大家分享。希望我们的工作能对大家的 iOS 开发组件间解耦工作有所启发。</span></p> 
 <h2 style="color: rgb(62, 62, 62);"><strong style="color: rgb(51, 51, 51);font-size: 16px;white-space: normal;"><span style="color: rgb(49, 188, 173);">作者简介</span></strong></h2> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="color: rgb(136, 136, 136);font-size: 15px;">尚先，美团资深工程师。2015年加入美团，目前作为美团外卖 iOS 端平台化虚拟小组组长，主要负责业务架构、持续集成和工程化相关工作。同时也是移动端领域新技术的爱好者，负责多项新技术在外卖业务落地中的难点攻关，目前个人拥有七项国家发明专利。</span></p> 
 <p style="color: inherit;font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="color: rgb(136, 136, 136);font-size: 15px;">泽响，美团技术专家，2014年加入美团，先后负责过公司 iOS 持续集成体系建设，美团 iOS 端平台业务，美团 iOS 端基础业务等工作。目前作为美团移动平台架构平台组 Team Leader，主要负责美团 App 平台架构、组件化、研发流程优化和部分基础设施建设，致力于提升平台上全业务的研发效率与质量。</span></p> 
 <p style="font-size: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: 15px;"><span style="color: rgb(136, 136, 136);font-size: 15px;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-align: justify;background-color: rgb(255, 255, 255);">欢迎加入</span><strong style="color: rgb(51, 51, 51);font-size: 15px;white-space: normal;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-align: justify;background-color: rgb(255, 255, 255);"><span style="color: rgb(0, 0, 0);">美团iOS技术交流群</span></strong><span style="color: rgb(136, 136, 136);font-size: 15px;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-align: justify;background-color: rgb(255, 255, 255);">，跟作者零距离交流。进群方式：请加美美同学的微信（微信号：<strong>MTDPtech01</strong>），回复：</span><span style="font-size: 15px;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-align: justify;background-color: rgb(255, 255, 255);"><span style="color:#3e3e3e;"><strong>iOS</strong></span></span><span style="color: rgb(136, 136, 136);font-size: 15px;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-align: justify;background-color: rgb(255, 255, 255);">，美美会自动拉你进群。</span></span></p> 
</section> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;color: rgb(51, 51, 51);text-align: center;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;">----------&nbsp; END&nbsp; ----------</span></p> 
<p data-source-line="194" style="max-width: 100%;min-height: 1em;white-space: normal;color: rgb(51, 51, 51);box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><span style="max-width: 100%;font-size: 16px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><span style="max-width: 100%;color: rgb(49, 188, 173);box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;">招聘信息</span></strong></span></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;color: rgb(51, 51, 51);box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"></p> 
<section data-source="bj.96weixin.com" style="max-width: 100%;font-size: 16px;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"> 
 <section style="padding: 20px 20px 15px;max-width: 100%;box-sizing: border-box;width: 670px;text-decoration: inherit;background-color: rgb(245, 245, 245);overflow-wrap: break-word !important;word-break: normal !important;"> 
  <p><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><span style="max-width: 100%;font-family: Arial, sans-serif;font-weight: bold;text-decoration: inherit;color: rgb(128, 128, 128);"></span><span style="max-width: 100%;color: rgb(136, 136, 136);"></span></span><span style="font-size: 14px;">美团外卖长期招聘 iOS、Android、FE 高级/资深工程师和技术专家，Base 北京、上海、成都，欢迎有兴趣的同学投递简历到 chenhang03@meituan.com。&nbsp;</span></p> 
 </section> 
</section> 
<p data-source-line="194" style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><span style="max-width: 100%;font-size: 16px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><span style="max-width: 100%;color: rgb(49, 188, 173);box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;">也许你还想看</span></strong></span></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><span style="max-width: 100%;font-size: 16px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><span style="max-width: 100%;color: rgb(49, 188, 173);box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"></span></strong></span></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=209859240&amp;idx=2&amp;sn=5cdcfd520086cb6b33d3dcaa8c74b80e&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">【美团技术团队博客】前端组件化开发实践</span></a></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748728&amp;idx=2&amp;sn=c187f143a152bd084ff71332744b6758&amp;chksm=bd12a0358a6529238f66c6b24a1364a1c155f7d08f189e8363a5e982c445bdcca85e6829167a&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">用微前端的方式搭建类单页应用</span></a></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748565&amp;idx=2&amp;sn=5a88f074128946c34512477fcb0c90e5&amp;chksm=bd12a1988a65288e2d89cfa18adbdb921024deae3a491d3fc544b3f1aca1646e87883ee8b0f8&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 14px;text-decoration: underline;"><span style="font-size: 14px;">美团扫码付的前端可用性保障实践</span></a><br></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;margin-left: 0.5em;margin-right: 0.5em;"><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"></span></p> 
<p style="max-width: 100%;min-height: 1em;white-space: normal;text-align: center;margin-left: 0.5em;margin-right: 0.5em;box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;"><img class="" data-copyright="0" data-ratio="0.44533333333333336" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png" data-type="png" data-w="1875" style="box-sizing: border-box !important;overflow-wrap: break-word !important;word-break: normal !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsV6LYkM3uK5TAnl8DxXwdR4YOAKWmYSpAtzV3P359bDG3cn3Vr4T6HMkvDSI8icUYsejmDnfa5CdpQ/640?wx_fmt=png"></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
