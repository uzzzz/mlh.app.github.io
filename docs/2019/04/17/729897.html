<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>万字详解Oracle架构、原理、进程，学会世间再无复杂架构 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="万字详解Oracle架构、原理、进程，学会世间再无复杂架构" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="学习是一个循序渐进的过程，从面到点、从宏观到微观，逐步渗透,各个击破，对于Oracle,&nbsp;怎么样从宏观上来理解呢？先来看一个图，这个图取自于教材，这个图对于从整体上理解ORACLE&nbsp;的体系结构组件，非常关键。 首先看张图： 对于一个数据库系统来说，假设这个系统没有运行，我们所能看到的和这个数据库相关的无非就是几个基于操作系统的物理文件，这是从静态的角度来看,如果从动态的角度来看呢,也就是说这个数据库系统运行起来了，能够对外提供服务了，那就意外着数据库系统启动了自己的一个实例，综合以上2个角度，Oracle如何定义上述描述呢？ 我们来引入第一个概念，Oracle服务器，所谓Oracle服务器是一个数据库管理系统，它包括一个Oracle实例（动态）和一个Oracle数据库（静态）。Oracle实例是一个运行的概念（如操作系统的进程），提供了一种访问，Oracle数据库的方式，始终打开一个，并且只能打开一个Oracle数据库，Oracle实例有SGA和一些后台服务进程组成，在后台服务进程当中，DBWn&nbsp;PMON&nbsp;CKPT&nbsp;LGWR&nbsp;SMON是必备的后台进程，而ad&nbsp;queue、rac、shared&nbsp;server、ad&nbsp;replication则是可选的，之所以可选，要们是因为离开它Oracle也能正常运行，要么是一些高级的功能才可以用得到。 Oracle数据库是一个被统一处理的的数据的集合，从物理角度来看包括三类文件数据文件，控制文件，重做日志文件。从逻辑角度来看，Oracle数据库至少包含一个表空间，表空间至少包含一个段，段由区做成，区有块组成。需要注意的是表空间可以包含若干个数据文件，段可以跨同一个表空间的多个数据文件，区只能在同一个数据文件内。 Oracle还设计了其他的关键文件用来为整个系统服务，如配置文件、密码文件、归档日志文件，还有还有用户进程和服务进程，现在可以简单理解下执行SQL语句就要用到这2个进程。 &nbsp; SGA SHARE POOL（共享池）用如下命令可以调整ALTER SYSTEM SETSHARED_POOL_SIZE=64M LIBRARY CACHE（库高速缓存）1存储最近使用的SQL和PL/SQL语句信息2包括SHARED SQL和SHARED PL/SQL3用LRU算法管理4大小由SHARE POOL大小决定 DATA DICTIONARY CACHE（数据字典高速缓存）1数据库中最近使用的定义的集合2包含数据库文件，表，索引，列，用户，权限和其他的数据库对象相关信息3在语法分析阶段，服务器进程会在数据字典中查找用于对象解析和验证访问的信息4将数据字典信息高速缓存到内存中，可缩短查询和DML的响应时间5大小由共享池的大小决定 DATABASE BUFFER CACHE（数据缓冲区高速缓存） 1存储已从数据文件检索到的数据的复本2大幅提高读取和更新数据的性能3使用LRU算法管理4主块的大小由DB_BLOCK_SIZE确定 REDO LOG BUFFER（重做日志缓冲区） 1记录对数据库数据块作的全部更改2主要用来恢复3其中记录的更改被称作重做条目4重做条目包含用于重新构建或重做更改的信息5大小由LOG_BUFFER定义 LARGE POOL（大型池） 1 SGA可选的内存区2分担了共享池的一部分工作3用于共享服务器的UGA4用于I/O服务器进程5备份和恢复操作或RMAN6并行执行消息缓冲区（前提PARALLEL_POOL_SIZE=TRUE）7不使用LRU列表8大小由LARGE_POOL_SIZE确定 JAVA POOL（JAVA池） 1存储JAVA命令服务分析要求2安装和使用JAVA时必须的3大小有JAVA_POOL_SIZE确定 PGA PRIVATE SQL AREA（专用SQL区）&nbsp;专用SQL&nbsp;区的位置取决于为会话建立的连接类型。在专用服务器环境中，专用SQL&nbsp;区位于各自服务器进程的PGA中。在共享服务器环境中，专用SQL&nbsp;区位于SGA&nbsp;中。管理专用SQL&nbsp;区是用户进程的职责。用户进程可以分配的专用SQL&nbsp;区的数目始终由初始化参数OPEN_CURSORS&nbsp;来限制。该参数的缺省值是50。 PERSISTEN AREA（永久区）包含绑定信息，并且只在关闭游标时释放 RUNTIME AREA（运行时区）在执行请求时的第一步创建。对于INSERT、UPDATE&nbsp;和DELETE命令，该区在执行语句后释放，对于查询操作，该区只在提取所有行或取消查询后释放。 SESSION MEMORY（会话内存） 包含为保留会话变量以及与该会话相关的其它信息而分配的内存。对于共享服务器环境，该会话是共享的而不是专用的。 SQL WORK AREAS（SQL工作区） 用于大量占用内存的操作，如排序、散列联接、位图合并和位图创建。工作区的大小可进行控制和调整 下表是后台进程总结 DBWn DBWn&nbsp;延迟写入数据文件,直到发生下列事件之一：•&nbsp;增量或正常检查点•&nbsp;灰数据缓冲区的数量达到阈值•&nbsp;进程扫描指定数量的块而无法找到任何空闲缓冲区时•&nbsp;出现超时•&nbsp;实时应用集群(Real Application Clusters, RAC)&nbsp;环境中出现ping&nbsp;请求•&nbsp;使一般表空间或临时表空间处于脱机状态•&nbsp;使表空间处于只读模式•&nbsp;删除或截断表•&nbsp;执行ALTER TABLESPACE&nbsp;表空间名BEGIN BACKUP&nbsp;操作 LGWR LGWR&nbsp;在下列情况下执行从重做日志缓冲区到重做日志文件的连续写入：•&nbsp;当提交事务时•&nbsp;当重做日志缓冲区的三分之一填满时•&nbsp;当重做日志缓冲区中记录了超过1 MB&nbsp;的更改时•&nbsp;在DBWn&nbsp;将数据库缓冲区高速缓存中修改的块写入数据文件以前•&nbsp;每隔三秒 SMON 例程恢复–&nbsp;前滚重做日志中的更改–&nbsp;打开数据库供用户访问–&nbsp;回退未提交的事务处理•&nbsp;合并空闲空间•&nbsp;回收临时段 PMON 进程失败后，后台进程PMON&nbsp;通过下面的方法进行清理：•&nbsp;回退用户的当前事务处理•&nbsp;释放当前保留的所有表锁或行锁•&nbsp;释放用户当前保留的其它资源•&nbsp;重新启动已失效的调度程序 CKPT •&nbsp;在检查点发信号给DBWn•&nbsp;使用检查点信息更新数据文件的标头•&nbsp;使用检查点信息更新控制启动检查点的原因如下：•&nbsp;确保定期向磁盘写入内存中发生修改的数据块，以便在系统或数据库失败时不会丢失数据•&nbsp;缩短例程恢复所需的时间。只需处理最后一个检查点后面的重做日志条目以启动恢复操作•&nbsp;确保提交的所有数据在关闭期间均已写入数据文件由CKPT&nbsp;写入的检查点信息包括检查点位置、系统更改号、重做日志中恢复操作的起始位置以及有关日志的信息等等。注：CKPT&nbsp;并不将数据块写入磁盘，或将重做块写入联机重做日志。 ARCn •&nbsp;可选的后台进程•&nbsp;设置ARCHIVELOG&nbsp;模式时自动归档联机重做日志•&nbsp;保留数据库的全部更改记录 最后，举一个用户提交SQL语句的的例子来结束本文，如果用户想提交SQL语句，那么首先你必须要连接到Oracle实例，连接到Oracle实例有三种途径：如果用户登陆到运行Oracle实例的操作系统上，则通过进程间通信进行访问2C/S结构访问3三层结构。发起连接的应用程序或工具通常称为用户进程，连接发起后，Oracle服务器就会创建一个进程来接受连接，这个进程就成为服务进程，服务器进程代表用户进程与Oracle实例进行通信，在专用服务器连接模式下，用户进程和服务进程是1对1的关系，在共享服务器模式下，多个用户进程可能共享一个服务进程。当服务器进程开始和Oracle实例进行通信时，一个会话就被创建了。显然处理一个查询要经过语法分析、绑定、执行、提取等阶段。 Oracle的基础架构知识 笔者在学习Oracle之前，特地先去了解了OracleDB的框架。这样对Oracle数据库有一个整体的认知，有由高屋建领地的作用。磨刀不误砍菜功吧。Oracle数据库主要由一下5部分组成： 1. 物理结构 Oracle物理结构由控制文件、数据文件、重做日志文件、参数文件、归档文件、口令文件组成 一个数据库中的数据存储在磁盘上物理文件，被使用时，调入内存。其中控制文件、数据文件、重做日志文件、跟踪文件及警告日志（trace&nbsp;files、alert&nbsp;files）属于数据库文件；参数文件（parameter&nbsp;file）口令文件（password&nbsp;file）是非数据库文件。 数据文件：存储数据的文件.数据文件典型地代表了根据他们使用的磁盘空间和数量所决定的一个Oracle数据库的容积。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于此我们需要知道的是，一个数据库中的数据是存储在磁盘上的物理文件，被使用时才被调入内存中的。其中控制文件、数据文件、重做日志文件、跟踪文件、警告文件属于数据库文件。参数文件、口令文件属于非数据库文件。 控制文件：包含维护和验证数据库完整性的必要信息、例如，控制文件用于识别数据文件和重做日志文件，一个数据库至少需要一个控制文件。控制文件内容有： 数据库名 表空间信息 所有数据文件的名字和位置 所有redo日志文件的名字和位置 当前的日志序列号 检查点信息 关于redo日志和归档的当前状态信息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;控制文件的使用过程是控制文件把Oracle引导到数据库文件的其它部分。启动一个实例时，Oracle从参数文件中读取控制文件的名字和位置。安装数据库时，Oracle打开控制文件。最终打开数据库时，Oracle从控制文件中读取数据文件的列表并打开其中的每个文件。 重做日志文件，含对数据库所做的更改记录，这样万一出现故障可以启用数据恢复。一个数据库至少需要两个重做日志文件。 跟踪文件及警告日志(Trace Files and Alert Files)， 跟踪文件是在instance&nbsp;中运行的每一个后台进程都有一个跟踪文件（trace&nbsp;file）与之相连。Trace&nbsp;file记载后台进程所遇到的重大事件的信息。 警告日志（&nbsp;Alert&nbsp;Log）是一种特殊的跟踪文件，每个数据库都有一个跟踪文件，同步记载数据库的消息和错误。 参数文件：包括大量影响Oracle数据库实例功能的设定，如以下设定： 数据库控制文件的定位 Oracle用来缓存从磁盘上读取的数据的内存数量 默认的优化程序的选择 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和数据库文件相关，执行两个重要的功能，为数据库指出控制文件和为数据库指出归档日志的目标。 归档文件：是重做日志文件的脱机副本，这些副本可能对于从介质失败中进行恢复很必要。 口令文件：认证哪些用户有权限启动和关闭Oracle例程. 2. 逻辑结构（表空间、段、区、块） 表空间：是数据库中的基本逻辑结构，一系列数据文件的集合。 段：是对象在数据库中占用的空间. 区：是为数据一次性预留的一个较大的存储空间. 块：ORACLE最基本的存储单位，在建立数据库的时候指定. 3. 内存分配（SGA和PGA） SGA：是用于存储数据库信息的内存区，该信息为数据库进程所共享。它包含Oracle服务器的数据和控制信息,它是在Oracle服务器所驻留的计算机的实际内存中得以分配，如果实际内存不够再往虚拟内存中写。 PGA：包含单个服务器进程或单个后台进程的数据和控制信息，与几个进程共享的SGA正相反，PGA&nbsp;是只被一个进程使用的区域，PGA在创建进程时分配,在终止进程时回收. 4. 后台进程 包括数据写进程（Database&nbsp;Writer,DBWR）、日志写进程（Log&nbsp;Writer,LGWR）、系统监控（System&nbsp;Monitor、SMON）、进程监控（Process&nbsp;Monitor、PMON）、检查点进程（Checkpoint&nbsp;&nbsp;Process、CKPT）、归档进程、服务进程、用户进程。 数据写进程：负责将更改的数据从数据库缓冲区高速缓存写入数据文件 日志写进程：将重做日志缓冲区中的更改写入在线重做日志文件 系统监控：检查数据库的一致性如有必要还会在数据库打开时启动数据库的恢复 进程监控：负责在一个Oracle&nbsp;进程失败时清理资源 检查点进程：负责在每当缓冲区高速缓存中的更改永久地记录在数据库中时,更新控制文件和数据文件中的数据库状态信息。该进程在检查点出现时，对全部数据文件的标题进行修改，指示该检查点。在通常的情况下，该任务由LGWR执行。然而，如果检查点明显地降低系统性能时，可使CKPT进程运行，将原来由LGWR进程执行的检查点的工作分离出来，由CKPT进程实现。对于许多应用情况，CKPT进程是不必要的。只有当数据库有许多数据文件，LGWR在检查点时明显地降低性能才使CKPT运行。CKPT进程不将块写入磁盘，该工作是由DBWR完成的。&nbsp; init.ora文件中CHECKPOINT_PROCESS参数控制CKPT进程的使能或使不能。缺省时为FALSE，即为使不能。 归档进程：在每次日志切换时把已满的日志组进行备份或归档 服务进程：用户进程服务。 用户进程：在客户端，负责将用户的SQL语句传递给服务进程，并从服务器段拿回查询数据。 5.&nbsp;SCN（System&nbsp;ChangeNumber）： 系统改变号，一个由系统内部维护的序列号。当系统需要更新的时候自动增加，他是系统中维持数据的一致性和顺序恢复的重要标志。 Oracle架构实现原理、含五大进程解析 Oracle架构，讲述了Oracle&nbsp;RDBMS的底层实现原理，是Oracle&nbsp;DBA性能调优和排错的基础理论。深入理解Oracle架构，能够让我们在Oracle的路上走的更远。本章节主要是在对RDBMS的底层组件功能和实现原理有一定的了解的情况下，结合自身的工作经验提出了对Oracle调优和排错的思路。当然，对Oracle体系结构的理解是一个深远的过程，需要不断的更新修改。 Oracle RDBMS架构图 一般我们所说的Oracle指的是Oracle&nbsp;RDBMS（Relational&nbsp;databases&nbsp;Management&nbsp;system），一套Oracle数据库管理系统，也称之为Oracle&nbsp;Server。而Oracle&nbsp;Server主要有两大部分：Oracle&nbsp;Server&nbsp;=&nbsp;实例&nbsp;+&nbsp;数据库（Instance和Database是相互独立的）。 数据库 = 数据文件 + 控制文件 +日志文件 实例 = 内存池 + 后台进程 所以可以细分为：Oracle&nbsp;Server&nbsp;=&nbsp;内存池&nbsp;+&nbsp;后台进程&nbsp;+&nbsp;数据文件&nbsp;+&nbsp;控制文件 +&nbsp;日志文件 一台Oracle&nbsp; Server支持创建多个Database，而且每个Datacase是互相隔离而独立的。不同的Database拥有属于自己的全套相关文件，例如：有各自的密码文件，参数文件，数据文件，控制文件和日志文件。 Database由一些物理文件（如：存放在存储设备中的二维表文件）组成。二维表存储在Database中，但Database的内容不能被用户直接读取，用户必须通过Oracle&nbsp;instance才能够访问Database，一个Instance只能连接一个Database，但是一个Database可以被多个Instance连接。 将上面的Oracle&nbsp;RDBMS架构图进行抽象分类，可以将Oracle架构抽象为：Oracle体系&nbsp;=&nbsp;内存结构&nbsp;+&nbsp;进程结构&nbsp;+&nbsp;存储结构 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 内存结构 Oracle&nbsp;Instance是Oracle&nbsp;RDBMS的核心之一，负责RDBMS的管理功能。Oracle&nbsp;Instance主要由内存池SGA和后台进程组成。 系统全局区SGA Oracle的架构不是很难也不是很容易，认真学肯定能学会。 内存池SGA的默认Size，会在安装Oracle的时候会根据LinuxOS的sysctl.conf参数文件来决定： kernel.shmall&nbsp;=&nbsp;2097152kernel.shmmax&nbsp;=&nbsp;2147483648kernel.shmmni&nbsp;=&nbsp;4096kernel.sem&nbsp;=&nbsp;250&nbsp;32000&nbsp;100&nbsp;128net.ipv4.ip_local_port_range&nbsp;=&nbsp;1024&nbsp;65000net.core.rmem_default&nbsp;=&nbsp;1048576net.core.rmem_max&nbsp;=&nbsp;1048576net.core.wmem_default&nbsp;=&nbsp;262144net.core.wmem_max = 262144 查看SGA的Size： SQL&gt; conn /as sysdbaConnected.SQL&gt; show user;USER is &quot;SYS&quot;SQL&gt; select * from v$sga;NAME VALUE-------------------- ----------Fixed Size 2022144Variable Size 503317760Database Buffers 1627389952Redo Buffers 14753792SQL&gt; show sgaTotal System Global Area 2147483648 bytes #对应kernel.shmmax = 2147483648Fixed Size 2022144 bytesVariable Size 503317760 bytesDatabase Buffers 1627389952 bytesRedo Buffers 14753792 bytes SGA（System&nbsp;Global&nbsp;Area）是与Oracle性能关系最大的核心部分，也是对Oracle进行调优的主要考量。SGA内存池会在Instance启动时被分配，在Instance关闭时被释放。在一定范围内，SGA可以在Instance运行时通过自动方式响应DBA的指令。如果想对SGA进行调优还必须理解SGA所包含如下几种数据结构： 高速缓存缓冲区（数据库缓冲区）——oracle执行SQL语句的区域。 例如在更新数据时，用户执行的SQL语句不会直接对磁盘上的数据文件进行更改操作，而是首先将数据文件复制到数据库缓冲区缓存（就是说数据库缓冲区里会存放着SQL相关数据文件副本），再更改应用于数据库缓冲区缓存中这些数据块的副本。而且数据块副本将在缓存中保留一段时间，直至其占用的缓冲区被另一个数据库覆盖为止（缓冲区Size有限）。在查询数据时，为了提高执行效率，查询的数据也要经过缓存。建立的Session会计算出那些数据块包含关键的行，并将它们复制到数据库缓冲区中进行缓存。此后，相关关键行会传输到Session的PGA作进一步处理。这些数据块也会在数据库缓存区缓存中保留一段时间。一般情况下，被频繁访问的数据块会存在于数据库缓冲区缓存中，从而最大程度地减少对磁盘I/O的需要。那什么时候会将被更新的数据块副本写入到磁盘中的数据文件呢？ 答案：如果在缓冲区缓存中存储的数据块与磁盘上的数据块不同时，那么这样的缓冲区常称为”脏缓冲区”，脏缓冲区中的数据块副本就必须写回到磁盘的数据文件中。调优：数据库缓冲区缓存的大小会对性能产生至关重要的影响，具体需要多大的Size才能成为最佳配比还要结合实际的生产环境而言。总体而言可以依据以下两点基本要求来判断： 1.&nbsp;缓存应足够大，以便能缓存所有被频繁访问的数据块。如果缓存过小，那么将导致磁盘I/0活动过多，因为频繁访问的数据块持续从磁盘读取，并由其他数据块使用和重写，然后再从磁盘读取。2.&nbsp;但也不能太大，以至于它会将极少被访问的块也一并加入到缓存中，这样会增长在缓存中搜索的时间。数据库缓冲区缓存在Instance启动时被分配。从数据库9i开始，可以随时将其调大或调小。可以采用手动方式重调，也可以根据工作负荷自动重调大小（事务）。修改缓冲区DB_CACHE_SIZE地方法： #Step1.&nbsp;查看SGA的大小：因为DB_CACHE_SIZE的size受SGA的影响SQL&gt; show parameter sga_max_size;NAME TYPE VALUE------------------------------------ ----------- ------------------------------sga_max_size big integer 2G#Step2. 查看show parameter shared_pool_size的大小SQL&gt; show parameter shared_pool_size; NAME TYPE VALUE------------------------------------ ----------- ------------------------------shared_pool_size big integer 0#Step3.&nbsp;计算DB_CACHE_SIZE的大小：shared_pool_size&nbsp;+&nbsp;db_cache_size&nbsp;=&nbsp;SGA_MAX_SIZE&nbsp;*&nbsp;70%#Step4. 修改DB_CACHE_SIZE的大小SQL&gt; alter system set db_cache_size=1433M scope=spfile sid=&#39;demo&#39;;System altered.SQL&gt; conn sys /as sysdbaEnter password:&nbsp;********Connected.SQL&gt; shutdown immediateDatabase closed.Database dismounted.ORACLE instance shut down.SQL&gt; startupORACLE instance started.Total System Global Area 2147483648 bytesFixed Size 2022144 bytesVariable Size 503317760 bytesDatabase Buffers 1627389952 bytesRedo Buffers 14753792 bytesDatabase mounted.Database opened.SQL&gt; show parameter db_cache_size 日志缓冲区日志缓冲区是小型的、用于短期存储将写入到磁盘上的重做日志的变更向量的临时区域。主要作用是提供更加快的日志处理效率。 共享池共享池的大小也对性能产生重要影响: 1.&nbsp;它应该足够大，以便缓存所有频繁执行的代码和频繁访问的对象定义。如果共享池过小，则性能下降，因为服务器会话将反复抢夺其中的空间来分析语句，此后，这些语句会被其他语句重写，在重新执行时，将不得不再次分析。如果共享池小于最优容量，则性能将下降。但有一个最小容量，如果低于此限度，则语句将失败。2.&nbsp;但也不能过大，以至于连仅执行一次的语句也要缓存。过大的共享池也会对性能产生不良影响，因为搜索需要的时间过长。确定最优容量是一个性能调整问题，大多数数据库都需要一个数百MB的共享池。有些应用程序需要1GB以上的共享池，但很少有应用程序能够在共享池小于100MB时充分运行。共享池内有下列三种数据结构： 库缓冲：存储最近执行的代码 数据字典缓存：存储最近使用的对象定义 PL/SQL缓冲区：存储的PL/SQL对象是过程、函数、打包的过程、打包的函数、对象类型定义和触发器。 手动的调整共享池的大小： select COMPONENT,CURRENT_SIZE,MIN_SIZE,MAX_SIZE from v$sga_dynamic_components; //显示可以动态重设大小的SGA组件的当前最大和最小容量ALTER SYSTEM SET SHARED_POOL_SIZE = 110M; 其他结构大型池——主要用途是供共享的服务器进程使用。JAVA池——只有当应用程序需要在数据库中运行java存储程序时，才需要java池。 进程结构进程结构主要有后台进程和用户连接进程两大类。 用户连接进程 用户连接进程是连接用户和Oracle&nbsp;Instance的桥梁。只有在User与Instance建立了连接以后，User才能够对Oracle&nbsp;Server进行操作。用户连接进程 = 用户进程 + 服务进程 + PGA 用户进程User Process当一个Database&nbsp;User请求连接到Oracle&nbsp;Server时，Oracle&nbsp;Server会创建User&nbsp;Process。 User&nbsp;Process的作用： 为Database User与Server Process建立连接 并不会直接与Oracle Server交互 connect连接：是User和Server&nbsp;Process之间的通信通道。 Server Process服务进程用于处理Database&nbsp;User和Oracle&nbsp;Server之间的连接。 当一个User与User&nbsp;Process建立了一个connect后，Oracle&nbsp;Server会创建一个Server&nbsp;Process。然后再由User&nbsp;Process与Server&nbsp;Process建立了连接之后，Server&nbsp;Process会通过用户提交的请求信息来确定与oracle&nbsp;instance建立一个会话。 Server&nbsp;Process的作用： 与Oracle Server直接交互 复制执行和返回结果 Session会话：一个用户通过User&nbsp;Process(本质是通过Server&nbsp;Process)与Oracle&nbsp;Instance建立连接后称之为一个会话，一个用户可以建立多个会话，即同时使用同一个用户可以多次的连接到同一个实例，也就是说多个session可以使用同一个connect。 程序全局区PGA PGA：Oracle&nbsp;Server&nbsp;Process分配来专门用于当前User&nbsp;Session的内存区。该区域是私有的，不同的用户拥有不同的PGA。PGA包含了Server&nbsp;Process数据和控制信息的内存区域。，由下列3个部分组成： 1.&nbsp;栈空间：存储Session的变量、数组等的内存空间。2.&nbsp;Session&nbsp;Info：如果运行的不是多线程服务器，会话信息将保存在PGA中，如果是多线程服务器，则保存在SGA中。3.&nbsp;私有SQL区：用来保存绑定变量(binding&nbsp;variables)和运行时缓冲区(runtime&nbsp;buffers)等信息。 Oracle的connect连接和session会话与User Process紧密相关注意：在RDBMS中由db\_name和instance\_name共同确定一个Database，所以Instance_name被用于Oracle与OS之间的联系同时也被用于Oracle&nbsp;Server与外部连接时使用。所以在User提交连接请求的时候，User&nbsp;Process首先会与Server&nbsp;Process建立Connect，然后Server&nbsp;Process会通过请求中所包含的db\_name和Instance\_name来确定需要且可以被连接的数据库(RDBMS可以存在多个数据库)，这样就确保了RDBMS在拥有多个数据库的情况下，还能够保证每一个Database的独立性。而且同一个Database可以被多个属于这个Databse的不同用户发起的Instance连接。这一个功能是非常有必要的，因为每一个不同的数据库中都包含有同名的sys、system等系统用户。 后台进程后台进程主要是完成数据库管理任务&nbsp;，后台进程是Oracle&nbsp;Instance和Oracle&nbsp;Database的联系纽带，分为核心进程和非核心进程。 1.&nbsp;核心进程：核心进程，必须存在，有一个终止，所有数据库进程全部终止，实例崩溃！其中五大进程全都是核心进程。2.&nbsp;非核心进程：完成数据库的额外功能，非核心进程死亡数据库不会崩溃！常用的核心进程： 在用户访问数据库时，首先会提交请求，再分配SGA内存，创建并启动后台进程和实例，最后建立连接和会话。Oracle&nbsp;Server运行过程中必须启动上面的前五个进程。否则实例无法创建。查看后台进程： SQL&gt; select name,description from v$bgprocess where paddr&lt;&gt;&#39;00&#39;;NAME DESCRIPTION----- ----------------------------------------------------------------PMON process cleanupPSP0 process spawner 0MMAN Memory ManagerDBW0 db writer process 0LGWR Redo etc.CKPT checkpointSMON System Monitor ProcessRECO distributed recoveryCJQ0 Job Queue CoordinatorQMNC AQ CoordinatorMMON Manageability Monitor ProcessNAME DESCRIPTION----- ----------------------------------------------------------------MMNL Manageability Monitor Process 2 数据库写入进程（DBWn） Server process连接Oracle后，通过数据库写进程(DBWn)将数据缓冲区中的“脏缓冲区”的数据块写入到存储结构（数据文件、磁盘文件）Database&nbsp;writer&nbsp;(DBWn)数据库写进程： 只做一件事，将数据写到磁盘。就是将数据库的变化写入到数据文件。 该进程最多20&nbsp;个，即使你有36&nbsp;个CPU&nbsp;也只能最多有20&nbsp;个数据库写进程。进程名称DBW0-DBW9 DBWa-DBWj 注意：数据库写进程越多，写数据的效率越高。该进程的个数应该和cpu的个数对应，如果设置的数据库写进程数大于CPU&nbsp;的个数也不会有太明显的效果，因为CPU&nbsp;是分时的。 检查点(CKPT) Checkpoint&nbsp;(CKPT)检查点进程： 主要用户更新数据文件头，更新控制文件和触发DBWn数据库写进程。 Ckpt&nbsp;进程会降低数据库性能，但是提高数据库崩溃时，自我恢复的性能。我们可以理解为阶段性的保存数据，一定的条件满足就触发，执行DBWn存盘操作。 进程监视进程（PMON） Process&nbsp;monitor（PMON）进程监测进程： PMON在后台进程执行失败后负责清理数据库缓存和闲置资源，是Oracle的自动维护机制。 清除死进程 重新启动部分进程（如调度进程） 监听的自动注册 回滚事务 释放锁 释放其他资 系统监视进程（SMON） System&nbsp;monitor&nbsp;(SMON)系统监测进程： SMON启动后会自动的用于在实例崩溃时进行数据库实例自动恢复。 清除作废的排序临时段，回收整理碎片，合并空闲空间，释放临时段，维护闪回的时间点。 在老数据库版本中，当我们大量删除表的时候，会观测到SMON进程很忙，直到把所有的碎片空间都整理完毕。 重做日志文件和日志写入进程 主要用于记录数据库的改变和记录数据库被改变之前的原始状态，所以应当对其作多重备份，用于恢复和排错。激活LGWR的情况： 提交指令 日志缓冲区超过1/3 每三秒 每次DBWn执行之前 归档进程（ARCn）——是非核心进程。 存储结构Oracle&nbsp;RDBMS存储结构主要由Database组成。 又能够将Database分为物理结构和逻辑结构来理解。 物理结构Database物理结构：是Database在操作系统中的文件集合，即：磁盘上的物理文件，主要由数据文件、控制文件、重做日志文件、归档日志文件、参数文件、口令文件组成。 Data Files数据文件是数据的存储仓库： • 包括所有的数据库数据• 只能属于一个数据库• 来自于被称为”表空间”的数据库存储逻辑单元•&nbsp;可以直接被读进内存，在执行SQL语句的时候，会将相关的数据文件副本加载如数据缓冲区。• 通过备份策略可以使数据文件得到保护 Redo Log Files重做日志文件包含对数据库所做的更改操作记录，在Oracle发生故障时能够恢复数据。能够恢复数据的原理：重做日志文件会按时间的顺序，将应用于数据库的一连串的变更向量(做了什么操作)存储起来(即将变更的地方标记起来)。其中包含了所有已经完成操作的信息和完成操作之前的数据库状态。如果数据文件受损，就可以将这些变更向量应用于数据文件备份来进行重做(重建)工作，将它恢复到发生故障的那一刻前的状态。重做日志文件又分为下面两种类型： 联机重做日志文件：记录连续的数据库操作 归档日志文件Archived&nbsp;Log&nbsp;Files：用于时间点恢复，当RedoLogFiles存满时，会对这些日志进行归档备份，以便以后还原数据时使用。 查看redo&nbsp;log&nbsp;info： SQL&gt; select member from v$logfile; # v$logfile数据字典，记录了redolog文件的列表 MEMBER-------------------------------------------------------------------------------- /u01/oradata/demo/redo03.log /u01/oradata/demo/redo02.log /u01/oradata/demo/redo01.log Control Files 控制文件包含维护和验证数据库完整性的必要的信息。 它记录了联机重做日志文件、数据文件的位置、更新的归档日志文件的位置。它还存储着维护数据库完整性所需的信息，如数据库名。控制文件是以二进制型式存储的，用户无法修改控制文件的内容。控制文件不过数MB，却起着至关重要的作用。 Parameter File实例参数文件，当启动oracle实例时，SGA结构会根据此参数文件的设置内存，后台进程会据此启动。 Password File用户通过提交username/password来建立会话，Oracle根据存储在数据字典的用户定义对用户名和口令进行验证。 逻辑结构表空间就是典型的Oracle逻辑结构类型&nbsp;——&nbsp;里面存放着若干的数据文件。 表空间：用于存储数据库对象的逻辑空间，表空间是在数据库中开辟的一个空间，用于存放数据库的对象，它是信息存储的最大逻辑单位，是存放数据库文件的地方，其中数据又被存放在表空间中的数据文件中。一个数据库可以由多个表空间组成，Oracle的调优就是通过表空间来实现的。（Oracle数据库独特的高级应用）表空间的作用：分类管理、批量处理；&nbsp;将琐碎的磁盘文件整合、抽象处理成为逻辑结构。这样更加便于我们去管理数据库。 逻辑空间到物理空间的映射段、区和块： 执行一条写入的SQL语句时在RDBMS中都发生了什么 1. 将SQL语句加载入数据库缓冲区2. 将SQL语句要操作的数据文件副本加载入数据库缓冲区3. 执行SQL语句，修改数据文件副本，形成“脏缓冲区”4. CKPT检测到“脏缓冲区”，调用DBWn5. 在DBWn运行之前，先运行了LGWR，将数据文件的原始状态和数据库的改变记录到Redo Log Files6. 运行DBWn，将“脏缓冲区的内容写入到数据文件”7. 同时CKPT修改控制文件和数据文件头8. SMON回收不必要的空闲资源 最后最后我们举个例子来看看Oracle RDBMS是怎么运作的 User访问Oracle&nbsp;Server之前提交一个请求(包含了db_name、instance_name、username、password等信息)，Oracle&nbsp;Server接收到请求并通过Password&nbsp;File的验证后，分配SGA内存池，启动后台进程同时创建并启动实例。 在启动实例之后User&nbsp;Process与Server&nbsp;Process建立Connect。 再通过Server&nbsp;process和Oracle&nbsp;Instance完成建立Sesscion。 用户执行SQL语句，由server&nbsp;process接收到并直接与Oracle交互。 SQL语句通过Server&nbsp;Process到达Oracle&nbsp;Instance，再将SQL载入数据库缓冲区。 Server&nbsp;Process通知Oracle&nbsp;Database将与SQL语句相关的数据块副本加载到缓冲区中。 在数据库缓存区执行SQL语句，并产生”脏缓冲区”。 由CKPT检查点进程检查到”脏缓冲区”，并调用DBWn数据库写进程，但在DBWn执行之前，应该由LGWR先将数据文件的原始状态、数据库的改变等信息记录到Redo&nbsp;Log&nbsp;Files。 将更新的内容写入到磁盘中的数据文件。 返回结果给用户 资源下载 关注公众号：数据和云（OraNews）回复关键字获取 2018DTCC ，数据库大会PPT 2018DTC，2018 DTC 大会 PPT ENMOBK，《Oracle性能优化与诊断案例》 DBALIFE&nbsp;，“DBA 的一天”海报 DBA04&nbsp;，DBA 手记4 电子书 122ARCH&nbsp;，Oracle 12.2体系结构图 2018OOW&nbsp;，Oracle OpenWorld 资料 云和恩墨大讲堂 |&nbsp;一个分享交流的地方 长按，识别二维码，加入万人交流社群 请备注：云和恩墨大讲堂" />
<meta property="og:description" content="学习是一个循序渐进的过程，从面到点、从宏观到微观，逐步渗透,各个击破，对于Oracle,&nbsp;怎么样从宏观上来理解呢？先来看一个图，这个图取自于教材，这个图对于从整体上理解ORACLE&nbsp;的体系结构组件，非常关键。 首先看张图： 对于一个数据库系统来说，假设这个系统没有运行，我们所能看到的和这个数据库相关的无非就是几个基于操作系统的物理文件，这是从静态的角度来看,如果从动态的角度来看呢,也就是说这个数据库系统运行起来了，能够对外提供服务了，那就意外着数据库系统启动了自己的一个实例，综合以上2个角度，Oracle如何定义上述描述呢？ 我们来引入第一个概念，Oracle服务器，所谓Oracle服务器是一个数据库管理系统，它包括一个Oracle实例（动态）和一个Oracle数据库（静态）。Oracle实例是一个运行的概念（如操作系统的进程），提供了一种访问，Oracle数据库的方式，始终打开一个，并且只能打开一个Oracle数据库，Oracle实例有SGA和一些后台服务进程组成，在后台服务进程当中，DBWn&nbsp;PMON&nbsp;CKPT&nbsp;LGWR&nbsp;SMON是必备的后台进程，而ad&nbsp;queue、rac、shared&nbsp;server、ad&nbsp;replication则是可选的，之所以可选，要们是因为离开它Oracle也能正常运行，要么是一些高级的功能才可以用得到。 Oracle数据库是一个被统一处理的的数据的集合，从物理角度来看包括三类文件数据文件，控制文件，重做日志文件。从逻辑角度来看，Oracle数据库至少包含一个表空间，表空间至少包含一个段，段由区做成，区有块组成。需要注意的是表空间可以包含若干个数据文件，段可以跨同一个表空间的多个数据文件，区只能在同一个数据文件内。 Oracle还设计了其他的关键文件用来为整个系统服务，如配置文件、密码文件、归档日志文件，还有还有用户进程和服务进程，现在可以简单理解下执行SQL语句就要用到这2个进程。 &nbsp; SGA SHARE POOL（共享池）用如下命令可以调整ALTER SYSTEM SETSHARED_POOL_SIZE=64M LIBRARY CACHE（库高速缓存）1存储最近使用的SQL和PL/SQL语句信息2包括SHARED SQL和SHARED PL/SQL3用LRU算法管理4大小由SHARE POOL大小决定 DATA DICTIONARY CACHE（数据字典高速缓存）1数据库中最近使用的定义的集合2包含数据库文件，表，索引，列，用户，权限和其他的数据库对象相关信息3在语法分析阶段，服务器进程会在数据字典中查找用于对象解析和验证访问的信息4将数据字典信息高速缓存到内存中，可缩短查询和DML的响应时间5大小由共享池的大小决定 DATABASE BUFFER CACHE（数据缓冲区高速缓存） 1存储已从数据文件检索到的数据的复本2大幅提高读取和更新数据的性能3使用LRU算法管理4主块的大小由DB_BLOCK_SIZE确定 REDO LOG BUFFER（重做日志缓冲区） 1记录对数据库数据块作的全部更改2主要用来恢复3其中记录的更改被称作重做条目4重做条目包含用于重新构建或重做更改的信息5大小由LOG_BUFFER定义 LARGE POOL（大型池） 1 SGA可选的内存区2分担了共享池的一部分工作3用于共享服务器的UGA4用于I/O服务器进程5备份和恢复操作或RMAN6并行执行消息缓冲区（前提PARALLEL_POOL_SIZE=TRUE）7不使用LRU列表8大小由LARGE_POOL_SIZE确定 JAVA POOL（JAVA池） 1存储JAVA命令服务分析要求2安装和使用JAVA时必须的3大小有JAVA_POOL_SIZE确定 PGA PRIVATE SQL AREA（专用SQL区）&nbsp;专用SQL&nbsp;区的位置取决于为会话建立的连接类型。在专用服务器环境中，专用SQL&nbsp;区位于各自服务器进程的PGA中。在共享服务器环境中，专用SQL&nbsp;区位于SGA&nbsp;中。管理专用SQL&nbsp;区是用户进程的职责。用户进程可以分配的专用SQL&nbsp;区的数目始终由初始化参数OPEN_CURSORS&nbsp;来限制。该参数的缺省值是50。 PERSISTEN AREA（永久区）包含绑定信息，并且只在关闭游标时释放 RUNTIME AREA（运行时区）在执行请求时的第一步创建。对于INSERT、UPDATE&nbsp;和DELETE命令，该区在执行语句后释放，对于查询操作，该区只在提取所有行或取消查询后释放。 SESSION MEMORY（会话内存） 包含为保留会话变量以及与该会话相关的其它信息而分配的内存。对于共享服务器环境，该会话是共享的而不是专用的。 SQL WORK AREAS（SQL工作区） 用于大量占用内存的操作，如排序、散列联接、位图合并和位图创建。工作区的大小可进行控制和调整 下表是后台进程总结 DBWn DBWn&nbsp;延迟写入数据文件,直到发生下列事件之一：•&nbsp;增量或正常检查点•&nbsp;灰数据缓冲区的数量达到阈值•&nbsp;进程扫描指定数量的块而无法找到任何空闲缓冲区时•&nbsp;出现超时•&nbsp;实时应用集群(Real Application Clusters, RAC)&nbsp;环境中出现ping&nbsp;请求•&nbsp;使一般表空间或临时表空间处于脱机状态•&nbsp;使表空间处于只读模式•&nbsp;删除或截断表•&nbsp;执行ALTER TABLESPACE&nbsp;表空间名BEGIN BACKUP&nbsp;操作 LGWR LGWR&nbsp;在下列情况下执行从重做日志缓冲区到重做日志文件的连续写入：•&nbsp;当提交事务时•&nbsp;当重做日志缓冲区的三分之一填满时•&nbsp;当重做日志缓冲区中记录了超过1 MB&nbsp;的更改时•&nbsp;在DBWn&nbsp;将数据库缓冲区高速缓存中修改的块写入数据文件以前•&nbsp;每隔三秒 SMON 例程恢复–&nbsp;前滚重做日志中的更改–&nbsp;打开数据库供用户访问–&nbsp;回退未提交的事务处理•&nbsp;合并空闲空间•&nbsp;回收临时段 PMON 进程失败后，后台进程PMON&nbsp;通过下面的方法进行清理：•&nbsp;回退用户的当前事务处理•&nbsp;释放当前保留的所有表锁或行锁•&nbsp;释放用户当前保留的其它资源•&nbsp;重新启动已失效的调度程序 CKPT •&nbsp;在检查点发信号给DBWn•&nbsp;使用检查点信息更新数据文件的标头•&nbsp;使用检查点信息更新控制启动检查点的原因如下：•&nbsp;确保定期向磁盘写入内存中发生修改的数据块，以便在系统或数据库失败时不会丢失数据•&nbsp;缩短例程恢复所需的时间。只需处理最后一个检查点后面的重做日志条目以启动恢复操作•&nbsp;确保提交的所有数据在关闭期间均已写入数据文件由CKPT&nbsp;写入的检查点信息包括检查点位置、系统更改号、重做日志中恢复操作的起始位置以及有关日志的信息等等。注：CKPT&nbsp;并不将数据块写入磁盘，或将重做块写入联机重做日志。 ARCn •&nbsp;可选的后台进程•&nbsp;设置ARCHIVELOG&nbsp;模式时自动归档联机重做日志•&nbsp;保留数据库的全部更改记录 最后，举一个用户提交SQL语句的的例子来结束本文，如果用户想提交SQL语句，那么首先你必须要连接到Oracle实例，连接到Oracle实例有三种途径：如果用户登陆到运行Oracle实例的操作系统上，则通过进程间通信进行访问2C/S结构访问3三层结构。发起连接的应用程序或工具通常称为用户进程，连接发起后，Oracle服务器就会创建一个进程来接受连接，这个进程就成为服务进程，服务器进程代表用户进程与Oracle实例进行通信，在专用服务器连接模式下，用户进程和服务进程是1对1的关系，在共享服务器模式下，多个用户进程可能共享一个服务进程。当服务器进程开始和Oracle实例进行通信时，一个会话就被创建了。显然处理一个查询要经过语法分析、绑定、执行、提取等阶段。 Oracle的基础架构知识 笔者在学习Oracle之前，特地先去了解了OracleDB的框架。这样对Oracle数据库有一个整体的认知，有由高屋建领地的作用。磨刀不误砍菜功吧。Oracle数据库主要由一下5部分组成： 1. 物理结构 Oracle物理结构由控制文件、数据文件、重做日志文件、参数文件、归档文件、口令文件组成 一个数据库中的数据存储在磁盘上物理文件，被使用时，调入内存。其中控制文件、数据文件、重做日志文件、跟踪文件及警告日志（trace&nbsp;files、alert&nbsp;files）属于数据库文件；参数文件（parameter&nbsp;file）口令文件（password&nbsp;file）是非数据库文件。 数据文件：存储数据的文件.数据文件典型地代表了根据他们使用的磁盘空间和数量所决定的一个Oracle数据库的容积。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于此我们需要知道的是，一个数据库中的数据是存储在磁盘上的物理文件，被使用时才被调入内存中的。其中控制文件、数据文件、重做日志文件、跟踪文件、警告文件属于数据库文件。参数文件、口令文件属于非数据库文件。 控制文件：包含维护和验证数据库完整性的必要信息、例如，控制文件用于识别数据文件和重做日志文件，一个数据库至少需要一个控制文件。控制文件内容有： 数据库名 表空间信息 所有数据文件的名字和位置 所有redo日志文件的名字和位置 当前的日志序列号 检查点信息 关于redo日志和归档的当前状态信息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;控制文件的使用过程是控制文件把Oracle引导到数据库文件的其它部分。启动一个实例时，Oracle从参数文件中读取控制文件的名字和位置。安装数据库时，Oracle打开控制文件。最终打开数据库时，Oracle从控制文件中读取数据文件的列表并打开其中的每个文件。 重做日志文件，含对数据库所做的更改记录，这样万一出现故障可以启用数据恢复。一个数据库至少需要两个重做日志文件。 跟踪文件及警告日志(Trace Files and Alert Files)， 跟踪文件是在instance&nbsp;中运行的每一个后台进程都有一个跟踪文件（trace&nbsp;file）与之相连。Trace&nbsp;file记载后台进程所遇到的重大事件的信息。 警告日志（&nbsp;Alert&nbsp;Log）是一种特殊的跟踪文件，每个数据库都有一个跟踪文件，同步记载数据库的消息和错误。 参数文件：包括大量影响Oracle数据库实例功能的设定，如以下设定： 数据库控制文件的定位 Oracle用来缓存从磁盘上读取的数据的内存数量 默认的优化程序的选择 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和数据库文件相关，执行两个重要的功能，为数据库指出控制文件和为数据库指出归档日志的目标。 归档文件：是重做日志文件的脱机副本，这些副本可能对于从介质失败中进行恢复很必要。 口令文件：认证哪些用户有权限启动和关闭Oracle例程. 2. 逻辑结构（表空间、段、区、块） 表空间：是数据库中的基本逻辑结构，一系列数据文件的集合。 段：是对象在数据库中占用的空间. 区：是为数据一次性预留的一个较大的存储空间. 块：ORACLE最基本的存储单位，在建立数据库的时候指定. 3. 内存分配（SGA和PGA） SGA：是用于存储数据库信息的内存区，该信息为数据库进程所共享。它包含Oracle服务器的数据和控制信息,它是在Oracle服务器所驻留的计算机的实际内存中得以分配，如果实际内存不够再往虚拟内存中写。 PGA：包含单个服务器进程或单个后台进程的数据和控制信息，与几个进程共享的SGA正相反，PGA&nbsp;是只被一个进程使用的区域，PGA在创建进程时分配,在终止进程时回收. 4. 后台进程 包括数据写进程（Database&nbsp;Writer,DBWR）、日志写进程（Log&nbsp;Writer,LGWR）、系统监控（System&nbsp;Monitor、SMON）、进程监控（Process&nbsp;Monitor、PMON）、检查点进程（Checkpoint&nbsp;&nbsp;Process、CKPT）、归档进程、服务进程、用户进程。 数据写进程：负责将更改的数据从数据库缓冲区高速缓存写入数据文件 日志写进程：将重做日志缓冲区中的更改写入在线重做日志文件 系统监控：检查数据库的一致性如有必要还会在数据库打开时启动数据库的恢复 进程监控：负责在一个Oracle&nbsp;进程失败时清理资源 检查点进程：负责在每当缓冲区高速缓存中的更改永久地记录在数据库中时,更新控制文件和数据文件中的数据库状态信息。该进程在检查点出现时，对全部数据文件的标题进行修改，指示该检查点。在通常的情况下，该任务由LGWR执行。然而，如果检查点明显地降低系统性能时，可使CKPT进程运行，将原来由LGWR进程执行的检查点的工作分离出来，由CKPT进程实现。对于许多应用情况，CKPT进程是不必要的。只有当数据库有许多数据文件，LGWR在检查点时明显地降低性能才使CKPT运行。CKPT进程不将块写入磁盘，该工作是由DBWR完成的。&nbsp; init.ora文件中CHECKPOINT_PROCESS参数控制CKPT进程的使能或使不能。缺省时为FALSE，即为使不能。 归档进程：在每次日志切换时把已满的日志组进行备份或归档 服务进程：用户进程服务。 用户进程：在客户端，负责将用户的SQL语句传递给服务进程，并从服务器段拿回查询数据。 5.&nbsp;SCN（System&nbsp;ChangeNumber）： 系统改变号，一个由系统内部维护的序列号。当系统需要更新的时候自动增加，他是系统中维持数据的一致性和顺序恢复的重要标志。 Oracle架构实现原理、含五大进程解析 Oracle架构，讲述了Oracle&nbsp;RDBMS的底层实现原理，是Oracle&nbsp;DBA性能调优和排错的基础理论。深入理解Oracle架构，能够让我们在Oracle的路上走的更远。本章节主要是在对RDBMS的底层组件功能和实现原理有一定的了解的情况下，结合自身的工作经验提出了对Oracle调优和排错的思路。当然，对Oracle体系结构的理解是一个深远的过程，需要不断的更新修改。 Oracle RDBMS架构图 一般我们所说的Oracle指的是Oracle&nbsp;RDBMS（Relational&nbsp;databases&nbsp;Management&nbsp;system），一套Oracle数据库管理系统，也称之为Oracle&nbsp;Server。而Oracle&nbsp;Server主要有两大部分：Oracle&nbsp;Server&nbsp;=&nbsp;实例&nbsp;+&nbsp;数据库（Instance和Database是相互独立的）。 数据库 = 数据文件 + 控制文件 +日志文件 实例 = 内存池 + 后台进程 所以可以细分为：Oracle&nbsp;Server&nbsp;=&nbsp;内存池&nbsp;+&nbsp;后台进程&nbsp;+&nbsp;数据文件&nbsp;+&nbsp;控制文件 +&nbsp;日志文件 一台Oracle&nbsp; Server支持创建多个Database，而且每个Datacase是互相隔离而独立的。不同的Database拥有属于自己的全套相关文件，例如：有各自的密码文件，参数文件，数据文件，控制文件和日志文件。 Database由一些物理文件（如：存放在存储设备中的二维表文件）组成。二维表存储在Database中，但Database的内容不能被用户直接读取，用户必须通过Oracle&nbsp;instance才能够访问Database，一个Instance只能连接一个Database，但是一个Database可以被多个Instance连接。 将上面的Oracle&nbsp;RDBMS架构图进行抽象分类，可以将Oracle架构抽象为：Oracle体系&nbsp;=&nbsp;内存结构&nbsp;+&nbsp;进程结构&nbsp;+&nbsp;存储结构 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 内存结构 Oracle&nbsp;Instance是Oracle&nbsp;RDBMS的核心之一，负责RDBMS的管理功能。Oracle&nbsp;Instance主要由内存池SGA和后台进程组成。 系统全局区SGA Oracle的架构不是很难也不是很容易，认真学肯定能学会。 内存池SGA的默认Size，会在安装Oracle的时候会根据LinuxOS的sysctl.conf参数文件来决定： kernel.shmall&nbsp;=&nbsp;2097152kernel.shmmax&nbsp;=&nbsp;2147483648kernel.shmmni&nbsp;=&nbsp;4096kernel.sem&nbsp;=&nbsp;250&nbsp;32000&nbsp;100&nbsp;128net.ipv4.ip_local_port_range&nbsp;=&nbsp;1024&nbsp;65000net.core.rmem_default&nbsp;=&nbsp;1048576net.core.rmem_max&nbsp;=&nbsp;1048576net.core.wmem_default&nbsp;=&nbsp;262144net.core.wmem_max = 262144 查看SGA的Size： SQL&gt; conn /as sysdbaConnected.SQL&gt; show user;USER is &quot;SYS&quot;SQL&gt; select * from v$sga;NAME VALUE-------------------- ----------Fixed Size 2022144Variable Size 503317760Database Buffers 1627389952Redo Buffers 14753792SQL&gt; show sgaTotal System Global Area 2147483648 bytes #对应kernel.shmmax = 2147483648Fixed Size 2022144 bytesVariable Size 503317760 bytesDatabase Buffers 1627389952 bytesRedo Buffers 14753792 bytes SGA（System&nbsp;Global&nbsp;Area）是与Oracle性能关系最大的核心部分，也是对Oracle进行调优的主要考量。SGA内存池会在Instance启动时被分配，在Instance关闭时被释放。在一定范围内，SGA可以在Instance运行时通过自动方式响应DBA的指令。如果想对SGA进行调优还必须理解SGA所包含如下几种数据结构： 高速缓存缓冲区（数据库缓冲区）——oracle执行SQL语句的区域。 例如在更新数据时，用户执行的SQL语句不会直接对磁盘上的数据文件进行更改操作，而是首先将数据文件复制到数据库缓冲区缓存（就是说数据库缓冲区里会存放着SQL相关数据文件副本），再更改应用于数据库缓冲区缓存中这些数据块的副本。而且数据块副本将在缓存中保留一段时间，直至其占用的缓冲区被另一个数据库覆盖为止（缓冲区Size有限）。在查询数据时，为了提高执行效率，查询的数据也要经过缓存。建立的Session会计算出那些数据块包含关键的行，并将它们复制到数据库缓冲区中进行缓存。此后，相关关键行会传输到Session的PGA作进一步处理。这些数据块也会在数据库缓存区缓存中保留一段时间。一般情况下，被频繁访问的数据块会存在于数据库缓冲区缓存中，从而最大程度地减少对磁盘I/O的需要。那什么时候会将被更新的数据块副本写入到磁盘中的数据文件呢？ 答案：如果在缓冲区缓存中存储的数据块与磁盘上的数据块不同时，那么这样的缓冲区常称为”脏缓冲区”，脏缓冲区中的数据块副本就必须写回到磁盘的数据文件中。调优：数据库缓冲区缓存的大小会对性能产生至关重要的影响，具体需要多大的Size才能成为最佳配比还要结合实际的生产环境而言。总体而言可以依据以下两点基本要求来判断： 1.&nbsp;缓存应足够大，以便能缓存所有被频繁访问的数据块。如果缓存过小，那么将导致磁盘I/0活动过多，因为频繁访问的数据块持续从磁盘读取，并由其他数据块使用和重写，然后再从磁盘读取。2.&nbsp;但也不能太大，以至于它会将极少被访问的块也一并加入到缓存中，这样会增长在缓存中搜索的时间。数据库缓冲区缓存在Instance启动时被分配。从数据库9i开始，可以随时将其调大或调小。可以采用手动方式重调，也可以根据工作负荷自动重调大小（事务）。修改缓冲区DB_CACHE_SIZE地方法： #Step1.&nbsp;查看SGA的大小：因为DB_CACHE_SIZE的size受SGA的影响SQL&gt; show parameter sga_max_size;NAME TYPE VALUE------------------------------------ ----------- ------------------------------sga_max_size big integer 2G#Step2. 查看show parameter shared_pool_size的大小SQL&gt; show parameter shared_pool_size; NAME TYPE VALUE------------------------------------ ----------- ------------------------------shared_pool_size big integer 0#Step3.&nbsp;计算DB_CACHE_SIZE的大小：shared_pool_size&nbsp;+&nbsp;db_cache_size&nbsp;=&nbsp;SGA_MAX_SIZE&nbsp;*&nbsp;70%#Step4. 修改DB_CACHE_SIZE的大小SQL&gt; alter system set db_cache_size=1433M scope=spfile sid=&#39;demo&#39;;System altered.SQL&gt; conn sys /as sysdbaEnter password:&nbsp;********Connected.SQL&gt; shutdown immediateDatabase closed.Database dismounted.ORACLE instance shut down.SQL&gt; startupORACLE instance started.Total System Global Area 2147483648 bytesFixed Size 2022144 bytesVariable Size 503317760 bytesDatabase Buffers 1627389952 bytesRedo Buffers 14753792 bytesDatabase mounted.Database opened.SQL&gt; show parameter db_cache_size 日志缓冲区日志缓冲区是小型的、用于短期存储将写入到磁盘上的重做日志的变更向量的临时区域。主要作用是提供更加快的日志处理效率。 共享池共享池的大小也对性能产生重要影响: 1.&nbsp;它应该足够大，以便缓存所有频繁执行的代码和频繁访问的对象定义。如果共享池过小，则性能下降，因为服务器会话将反复抢夺其中的空间来分析语句，此后，这些语句会被其他语句重写，在重新执行时，将不得不再次分析。如果共享池小于最优容量，则性能将下降。但有一个最小容量，如果低于此限度，则语句将失败。2.&nbsp;但也不能过大，以至于连仅执行一次的语句也要缓存。过大的共享池也会对性能产生不良影响，因为搜索需要的时间过长。确定最优容量是一个性能调整问题，大多数数据库都需要一个数百MB的共享池。有些应用程序需要1GB以上的共享池，但很少有应用程序能够在共享池小于100MB时充分运行。共享池内有下列三种数据结构： 库缓冲：存储最近执行的代码 数据字典缓存：存储最近使用的对象定义 PL/SQL缓冲区：存储的PL/SQL对象是过程、函数、打包的过程、打包的函数、对象类型定义和触发器。 手动的调整共享池的大小： select COMPONENT,CURRENT_SIZE,MIN_SIZE,MAX_SIZE from v$sga_dynamic_components; //显示可以动态重设大小的SGA组件的当前最大和最小容量ALTER SYSTEM SET SHARED_POOL_SIZE = 110M; 其他结构大型池——主要用途是供共享的服务器进程使用。JAVA池——只有当应用程序需要在数据库中运行java存储程序时，才需要java池。 进程结构进程结构主要有后台进程和用户连接进程两大类。 用户连接进程 用户连接进程是连接用户和Oracle&nbsp;Instance的桥梁。只有在User与Instance建立了连接以后，User才能够对Oracle&nbsp;Server进行操作。用户连接进程 = 用户进程 + 服务进程 + PGA 用户进程User Process当一个Database&nbsp;User请求连接到Oracle&nbsp;Server时，Oracle&nbsp;Server会创建User&nbsp;Process。 User&nbsp;Process的作用： 为Database User与Server Process建立连接 并不会直接与Oracle Server交互 connect连接：是User和Server&nbsp;Process之间的通信通道。 Server Process服务进程用于处理Database&nbsp;User和Oracle&nbsp;Server之间的连接。 当一个User与User&nbsp;Process建立了一个connect后，Oracle&nbsp;Server会创建一个Server&nbsp;Process。然后再由User&nbsp;Process与Server&nbsp;Process建立了连接之后，Server&nbsp;Process会通过用户提交的请求信息来确定与oracle&nbsp;instance建立一个会话。 Server&nbsp;Process的作用： 与Oracle Server直接交互 复制执行和返回结果 Session会话：一个用户通过User&nbsp;Process(本质是通过Server&nbsp;Process)与Oracle&nbsp;Instance建立连接后称之为一个会话，一个用户可以建立多个会话，即同时使用同一个用户可以多次的连接到同一个实例，也就是说多个session可以使用同一个connect。 程序全局区PGA PGA：Oracle&nbsp;Server&nbsp;Process分配来专门用于当前User&nbsp;Session的内存区。该区域是私有的，不同的用户拥有不同的PGA。PGA包含了Server&nbsp;Process数据和控制信息的内存区域。，由下列3个部分组成： 1.&nbsp;栈空间：存储Session的变量、数组等的内存空间。2.&nbsp;Session&nbsp;Info：如果运行的不是多线程服务器，会话信息将保存在PGA中，如果是多线程服务器，则保存在SGA中。3.&nbsp;私有SQL区：用来保存绑定变量(binding&nbsp;variables)和运行时缓冲区(runtime&nbsp;buffers)等信息。 Oracle的connect连接和session会话与User Process紧密相关注意：在RDBMS中由db\_name和instance\_name共同确定一个Database，所以Instance_name被用于Oracle与OS之间的联系同时也被用于Oracle&nbsp;Server与外部连接时使用。所以在User提交连接请求的时候，User&nbsp;Process首先会与Server&nbsp;Process建立Connect，然后Server&nbsp;Process会通过请求中所包含的db\_name和Instance\_name来确定需要且可以被连接的数据库(RDBMS可以存在多个数据库)，这样就确保了RDBMS在拥有多个数据库的情况下，还能够保证每一个Database的独立性。而且同一个Database可以被多个属于这个Databse的不同用户发起的Instance连接。这一个功能是非常有必要的，因为每一个不同的数据库中都包含有同名的sys、system等系统用户。 后台进程后台进程主要是完成数据库管理任务&nbsp;，后台进程是Oracle&nbsp;Instance和Oracle&nbsp;Database的联系纽带，分为核心进程和非核心进程。 1.&nbsp;核心进程：核心进程，必须存在，有一个终止，所有数据库进程全部终止，实例崩溃！其中五大进程全都是核心进程。2.&nbsp;非核心进程：完成数据库的额外功能，非核心进程死亡数据库不会崩溃！常用的核心进程： 在用户访问数据库时，首先会提交请求，再分配SGA内存，创建并启动后台进程和实例，最后建立连接和会话。Oracle&nbsp;Server运行过程中必须启动上面的前五个进程。否则实例无法创建。查看后台进程： SQL&gt; select name,description from v$bgprocess where paddr&lt;&gt;&#39;00&#39;;NAME DESCRIPTION----- ----------------------------------------------------------------PMON process cleanupPSP0 process spawner 0MMAN Memory ManagerDBW0 db writer process 0LGWR Redo etc.CKPT checkpointSMON System Monitor ProcessRECO distributed recoveryCJQ0 Job Queue CoordinatorQMNC AQ CoordinatorMMON Manageability Monitor ProcessNAME DESCRIPTION----- ----------------------------------------------------------------MMNL Manageability Monitor Process 2 数据库写入进程（DBWn） Server process连接Oracle后，通过数据库写进程(DBWn)将数据缓冲区中的“脏缓冲区”的数据块写入到存储结构（数据文件、磁盘文件）Database&nbsp;writer&nbsp;(DBWn)数据库写进程： 只做一件事，将数据写到磁盘。就是将数据库的变化写入到数据文件。 该进程最多20&nbsp;个，即使你有36&nbsp;个CPU&nbsp;也只能最多有20&nbsp;个数据库写进程。进程名称DBW0-DBW9 DBWa-DBWj 注意：数据库写进程越多，写数据的效率越高。该进程的个数应该和cpu的个数对应，如果设置的数据库写进程数大于CPU&nbsp;的个数也不会有太明显的效果，因为CPU&nbsp;是分时的。 检查点(CKPT) Checkpoint&nbsp;(CKPT)检查点进程： 主要用户更新数据文件头，更新控制文件和触发DBWn数据库写进程。 Ckpt&nbsp;进程会降低数据库性能，但是提高数据库崩溃时，自我恢复的性能。我们可以理解为阶段性的保存数据，一定的条件满足就触发，执行DBWn存盘操作。 进程监视进程（PMON） Process&nbsp;monitor（PMON）进程监测进程： PMON在后台进程执行失败后负责清理数据库缓存和闲置资源，是Oracle的自动维护机制。 清除死进程 重新启动部分进程（如调度进程） 监听的自动注册 回滚事务 释放锁 释放其他资 系统监视进程（SMON） System&nbsp;monitor&nbsp;(SMON)系统监测进程： SMON启动后会自动的用于在实例崩溃时进行数据库实例自动恢复。 清除作废的排序临时段，回收整理碎片，合并空闲空间，释放临时段，维护闪回的时间点。 在老数据库版本中，当我们大量删除表的时候，会观测到SMON进程很忙，直到把所有的碎片空间都整理完毕。 重做日志文件和日志写入进程 主要用于记录数据库的改变和记录数据库被改变之前的原始状态，所以应当对其作多重备份，用于恢复和排错。激活LGWR的情况： 提交指令 日志缓冲区超过1/3 每三秒 每次DBWn执行之前 归档进程（ARCn）——是非核心进程。 存储结构Oracle&nbsp;RDBMS存储结构主要由Database组成。 又能够将Database分为物理结构和逻辑结构来理解。 物理结构Database物理结构：是Database在操作系统中的文件集合，即：磁盘上的物理文件，主要由数据文件、控制文件、重做日志文件、归档日志文件、参数文件、口令文件组成。 Data Files数据文件是数据的存储仓库： • 包括所有的数据库数据• 只能属于一个数据库• 来自于被称为”表空间”的数据库存储逻辑单元•&nbsp;可以直接被读进内存，在执行SQL语句的时候，会将相关的数据文件副本加载如数据缓冲区。• 通过备份策略可以使数据文件得到保护 Redo Log Files重做日志文件包含对数据库所做的更改操作记录，在Oracle发生故障时能够恢复数据。能够恢复数据的原理：重做日志文件会按时间的顺序，将应用于数据库的一连串的变更向量(做了什么操作)存储起来(即将变更的地方标记起来)。其中包含了所有已经完成操作的信息和完成操作之前的数据库状态。如果数据文件受损，就可以将这些变更向量应用于数据文件备份来进行重做(重建)工作，将它恢复到发生故障的那一刻前的状态。重做日志文件又分为下面两种类型： 联机重做日志文件：记录连续的数据库操作 归档日志文件Archived&nbsp;Log&nbsp;Files：用于时间点恢复，当RedoLogFiles存满时，会对这些日志进行归档备份，以便以后还原数据时使用。 查看redo&nbsp;log&nbsp;info： SQL&gt; select member from v$logfile; # v$logfile数据字典，记录了redolog文件的列表 MEMBER-------------------------------------------------------------------------------- /u01/oradata/demo/redo03.log /u01/oradata/demo/redo02.log /u01/oradata/demo/redo01.log Control Files 控制文件包含维护和验证数据库完整性的必要的信息。 它记录了联机重做日志文件、数据文件的位置、更新的归档日志文件的位置。它还存储着维护数据库完整性所需的信息，如数据库名。控制文件是以二进制型式存储的，用户无法修改控制文件的内容。控制文件不过数MB，却起着至关重要的作用。 Parameter File实例参数文件，当启动oracle实例时，SGA结构会根据此参数文件的设置内存，后台进程会据此启动。 Password File用户通过提交username/password来建立会话，Oracle根据存储在数据字典的用户定义对用户名和口令进行验证。 逻辑结构表空间就是典型的Oracle逻辑结构类型&nbsp;——&nbsp;里面存放着若干的数据文件。 表空间：用于存储数据库对象的逻辑空间，表空间是在数据库中开辟的一个空间，用于存放数据库的对象，它是信息存储的最大逻辑单位，是存放数据库文件的地方，其中数据又被存放在表空间中的数据文件中。一个数据库可以由多个表空间组成，Oracle的调优就是通过表空间来实现的。（Oracle数据库独特的高级应用）表空间的作用：分类管理、批量处理；&nbsp;将琐碎的磁盘文件整合、抽象处理成为逻辑结构。这样更加便于我们去管理数据库。 逻辑空间到物理空间的映射段、区和块： 执行一条写入的SQL语句时在RDBMS中都发生了什么 1. 将SQL语句加载入数据库缓冲区2. 将SQL语句要操作的数据文件副本加载入数据库缓冲区3. 执行SQL语句，修改数据文件副本，形成“脏缓冲区”4. CKPT检测到“脏缓冲区”，调用DBWn5. 在DBWn运行之前，先运行了LGWR，将数据文件的原始状态和数据库的改变记录到Redo Log Files6. 运行DBWn，将“脏缓冲区的内容写入到数据文件”7. 同时CKPT修改控制文件和数据文件头8. SMON回收不必要的空闲资源 最后最后我们举个例子来看看Oracle RDBMS是怎么运作的 User访问Oracle&nbsp;Server之前提交一个请求(包含了db_name、instance_name、username、password等信息)，Oracle&nbsp;Server接收到请求并通过Password&nbsp;File的验证后，分配SGA内存池，启动后台进程同时创建并启动实例。 在启动实例之后User&nbsp;Process与Server&nbsp;Process建立Connect。 再通过Server&nbsp;process和Oracle&nbsp;Instance完成建立Sesscion。 用户执行SQL语句，由server&nbsp;process接收到并直接与Oracle交互。 SQL语句通过Server&nbsp;Process到达Oracle&nbsp;Instance，再将SQL载入数据库缓冲区。 Server&nbsp;Process通知Oracle&nbsp;Database将与SQL语句相关的数据块副本加载到缓冲区中。 在数据库缓存区执行SQL语句，并产生”脏缓冲区”。 由CKPT检查点进程检查到”脏缓冲区”，并调用DBWn数据库写进程，但在DBWn执行之前，应该由LGWR先将数据文件的原始状态、数据库的改变等信息记录到Redo&nbsp;Log&nbsp;Files。 将更新的内容写入到磁盘中的数据文件。 返回结果给用户 资源下载 关注公众号：数据和云（OraNews）回复关键字获取 2018DTCC ，数据库大会PPT 2018DTC，2018 DTC 大会 PPT ENMOBK，《Oracle性能优化与诊断案例》 DBALIFE&nbsp;，“DBA 的一天”海报 DBA04&nbsp;，DBA 手记4 电子书 122ARCH&nbsp;，Oracle 12.2体系结构图 2018OOW&nbsp;，Oracle OpenWorld 资料 云和恩墨大讲堂 |&nbsp;一个分享交流的地方 长按，识别二维码，加入万人交流社群 请备注：云和恩墨大讲堂" />
<link rel="canonical" href="https://mlh.app/2019/04/17/729897.html" />
<meta property="og:url" content="https://mlh.app/2019/04/17/729897.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-17T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"学习是一个循序渐进的过程，从面到点、从宏观到微观，逐步渗透,各个击破，对于Oracle,&nbsp;怎么样从宏观上来理解呢？先来看一个图，这个图取自于教材，这个图对于从整体上理解ORACLE&nbsp;的体系结构组件，非常关键。 首先看张图： 对于一个数据库系统来说，假设这个系统没有运行，我们所能看到的和这个数据库相关的无非就是几个基于操作系统的物理文件，这是从静态的角度来看,如果从动态的角度来看呢,也就是说这个数据库系统运行起来了，能够对外提供服务了，那就意外着数据库系统启动了自己的一个实例，综合以上2个角度，Oracle如何定义上述描述呢？ 我们来引入第一个概念，Oracle服务器，所谓Oracle服务器是一个数据库管理系统，它包括一个Oracle实例（动态）和一个Oracle数据库（静态）。Oracle实例是一个运行的概念（如操作系统的进程），提供了一种访问，Oracle数据库的方式，始终打开一个，并且只能打开一个Oracle数据库，Oracle实例有SGA和一些后台服务进程组成，在后台服务进程当中，DBWn&nbsp;PMON&nbsp;CKPT&nbsp;LGWR&nbsp;SMON是必备的后台进程，而ad&nbsp;queue、rac、shared&nbsp;server、ad&nbsp;replication则是可选的，之所以可选，要们是因为离开它Oracle也能正常运行，要么是一些高级的功能才可以用得到。 Oracle数据库是一个被统一处理的的数据的集合，从物理角度来看包括三类文件数据文件，控制文件，重做日志文件。从逻辑角度来看，Oracle数据库至少包含一个表空间，表空间至少包含一个段，段由区做成，区有块组成。需要注意的是表空间可以包含若干个数据文件，段可以跨同一个表空间的多个数据文件，区只能在同一个数据文件内。 Oracle还设计了其他的关键文件用来为整个系统服务，如配置文件、密码文件、归档日志文件，还有还有用户进程和服务进程，现在可以简单理解下执行SQL语句就要用到这2个进程。 &nbsp; SGA SHARE POOL（共享池）用如下命令可以调整ALTER SYSTEM SETSHARED_POOL_SIZE=64M LIBRARY CACHE（库高速缓存）1存储最近使用的SQL和PL/SQL语句信息2包括SHARED SQL和SHARED PL/SQL3用LRU算法管理4大小由SHARE POOL大小决定 DATA DICTIONARY CACHE（数据字典高速缓存）1数据库中最近使用的定义的集合2包含数据库文件，表，索引，列，用户，权限和其他的数据库对象相关信息3在语法分析阶段，服务器进程会在数据字典中查找用于对象解析和验证访问的信息4将数据字典信息高速缓存到内存中，可缩短查询和DML的响应时间5大小由共享池的大小决定 DATABASE BUFFER CACHE（数据缓冲区高速缓存） 1存储已从数据文件检索到的数据的复本2大幅提高读取和更新数据的性能3使用LRU算法管理4主块的大小由DB_BLOCK_SIZE确定 REDO LOG BUFFER（重做日志缓冲区） 1记录对数据库数据块作的全部更改2主要用来恢复3其中记录的更改被称作重做条目4重做条目包含用于重新构建或重做更改的信息5大小由LOG_BUFFER定义 LARGE POOL（大型池） 1 SGA可选的内存区2分担了共享池的一部分工作3用于共享服务器的UGA4用于I/O服务器进程5备份和恢复操作或RMAN6并行执行消息缓冲区（前提PARALLEL_POOL_SIZE=TRUE）7不使用LRU列表8大小由LARGE_POOL_SIZE确定 JAVA POOL（JAVA池） 1存储JAVA命令服务分析要求2安装和使用JAVA时必须的3大小有JAVA_POOL_SIZE确定 PGA PRIVATE SQL AREA（专用SQL区）&nbsp;专用SQL&nbsp;区的位置取决于为会话建立的连接类型。在专用服务器环境中，专用SQL&nbsp;区位于各自服务器进程的PGA中。在共享服务器环境中，专用SQL&nbsp;区位于SGA&nbsp;中。管理专用SQL&nbsp;区是用户进程的职责。用户进程可以分配的专用SQL&nbsp;区的数目始终由初始化参数OPEN_CURSORS&nbsp;来限制。该参数的缺省值是50。 PERSISTEN AREA（永久区）包含绑定信息，并且只在关闭游标时释放 RUNTIME AREA（运行时区）在执行请求时的第一步创建。对于INSERT、UPDATE&nbsp;和DELETE命令，该区在执行语句后释放，对于查询操作，该区只在提取所有行或取消查询后释放。 SESSION MEMORY（会话内存） 包含为保留会话变量以及与该会话相关的其它信息而分配的内存。对于共享服务器环境，该会话是共享的而不是专用的。 SQL WORK AREAS（SQL工作区） 用于大量占用内存的操作，如排序、散列联接、位图合并和位图创建。工作区的大小可进行控制和调整 下表是后台进程总结 DBWn DBWn&nbsp;延迟写入数据文件,直到发生下列事件之一：•&nbsp;增量或正常检查点•&nbsp;灰数据缓冲区的数量达到阈值•&nbsp;进程扫描指定数量的块而无法找到任何空闲缓冲区时•&nbsp;出现超时•&nbsp;实时应用集群(Real Application Clusters, RAC)&nbsp;环境中出现ping&nbsp;请求•&nbsp;使一般表空间或临时表空间处于脱机状态•&nbsp;使表空间处于只读模式•&nbsp;删除或截断表•&nbsp;执行ALTER TABLESPACE&nbsp;表空间名BEGIN BACKUP&nbsp;操作 LGWR LGWR&nbsp;在下列情况下执行从重做日志缓冲区到重做日志文件的连续写入：•&nbsp;当提交事务时•&nbsp;当重做日志缓冲区的三分之一填满时•&nbsp;当重做日志缓冲区中记录了超过1 MB&nbsp;的更改时•&nbsp;在DBWn&nbsp;将数据库缓冲区高速缓存中修改的块写入数据文件以前•&nbsp;每隔三秒 SMON 例程恢复–&nbsp;前滚重做日志中的更改–&nbsp;打开数据库供用户访问–&nbsp;回退未提交的事务处理•&nbsp;合并空闲空间•&nbsp;回收临时段 PMON 进程失败后，后台进程PMON&nbsp;通过下面的方法进行清理：•&nbsp;回退用户的当前事务处理•&nbsp;释放当前保留的所有表锁或行锁•&nbsp;释放用户当前保留的其它资源•&nbsp;重新启动已失效的调度程序 CKPT •&nbsp;在检查点发信号给DBWn•&nbsp;使用检查点信息更新数据文件的标头•&nbsp;使用检查点信息更新控制启动检查点的原因如下：•&nbsp;确保定期向磁盘写入内存中发生修改的数据块，以便在系统或数据库失败时不会丢失数据•&nbsp;缩短例程恢复所需的时间。只需处理最后一个检查点后面的重做日志条目以启动恢复操作•&nbsp;确保提交的所有数据在关闭期间均已写入数据文件由CKPT&nbsp;写入的检查点信息包括检查点位置、系统更改号、重做日志中恢复操作的起始位置以及有关日志的信息等等。注：CKPT&nbsp;并不将数据块写入磁盘，或将重做块写入联机重做日志。 ARCn •&nbsp;可选的后台进程•&nbsp;设置ARCHIVELOG&nbsp;模式时自动归档联机重做日志•&nbsp;保留数据库的全部更改记录 最后，举一个用户提交SQL语句的的例子来结束本文，如果用户想提交SQL语句，那么首先你必须要连接到Oracle实例，连接到Oracle实例有三种途径：如果用户登陆到运行Oracle实例的操作系统上，则通过进程间通信进行访问2C/S结构访问3三层结构。发起连接的应用程序或工具通常称为用户进程，连接发起后，Oracle服务器就会创建一个进程来接受连接，这个进程就成为服务进程，服务器进程代表用户进程与Oracle实例进行通信，在专用服务器连接模式下，用户进程和服务进程是1对1的关系，在共享服务器模式下，多个用户进程可能共享一个服务进程。当服务器进程开始和Oracle实例进行通信时，一个会话就被创建了。显然处理一个查询要经过语法分析、绑定、执行、提取等阶段。 Oracle的基础架构知识 笔者在学习Oracle之前，特地先去了解了OracleDB的框架。这样对Oracle数据库有一个整体的认知，有由高屋建领地的作用。磨刀不误砍菜功吧。Oracle数据库主要由一下5部分组成： 1. 物理结构 Oracle物理结构由控制文件、数据文件、重做日志文件、参数文件、归档文件、口令文件组成 一个数据库中的数据存储在磁盘上物理文件，被使用时，调入内存。其中控制文件、数据文件、重做日志文件、跟踪文件及警告日志（trace&nbsp;files、alert&nbsp;files）属于数据库文件；参数文件（parameter&nbsp;file）口令文件（password&nbsp;file）是非数据库文件。 数据文件：存储数据的文件.数据文件典型地代表了根据他们使用的磁盘空间和数量所决定的一个Oracle数据库的容积。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于此我们需要知道的是，一个数据库中的数据是存储在磁盘上的物理文件，被使用时才被调入内存中的。其中控制文件、数据文件、重做日志文件、跟踪文件、警告文件属于数据库文件。参数文件、口令文件属于非数据库文件。 控制文件：包含维护和验证数据库完整性的必要信息、例如，控制文件用于识别数据文件和重做日志文件，一个数据库至少需要一个控制文件。控制文件内容有： 数据库名 表空间信息 所有数据文件的名字和位置 所有redo日志文件的名字和位置 当前的日志序列号 检查点信息 关于redo日志和归档的当前状态信息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;控制文件的使用过程是控制文件把Oracle引导到数据库文件的其它部分。启动一个实例时，Oracle从参数文件中读取控制文件的名字和位置。安装数据库时，Oracle打开控制文件。最终打开数据库时，Oracle从控制文件中读取数据文件的列表并打开其中的每个文件。 重做日志文件，含对数据库所做的更改记录，这样万一出现故障可以启用数据恢复。一个数据库至少需要两个重做日志文件。 跟踪文件及警告日志(Trace Files and Alert Files)， 跟踪文件是在instance&nbsp;中运行的每一个后台进程都有一个跟踪文件（trace&nbsp;file）与之相连。Trace&nbsp;file记载后台进程所遇到的重大事件的信息。 警告日志（&nbsp;Alert&nbsp;Log）是一种特殊的跟踪文件，每个数据库都有一个跟踪文件，同步记载数据库的消息和错误。 参数文件：包括大量影响Oracle数据库实例功能的设定，如以下设定： 数据库控制文件的定位 Oracle用来缓存从磁盘上读取的数据的内存数量 默认的优化程序的选择 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和数据库文件相关，执行两个重要的功能，为数据库指出控制文件和为数据库指出归档日志的目标。 归档文件：是重做日志文件的脱机副本，这些副本可能对于从介质失败中进行恢复很必要。 口令文件：认证哪些用户有权限启动和关闭Oracle例程. 2. 逻辑结构（表空间、段、区、块） 表空间：是数据库中的基本逻辑结构，一系列数据文件的集合。 段：是对象在数据库中占用的空间. 区：是为数据一次性预留的一个较大的存储空间. 块：ORACLE最基本的存储单位，在建立数据库的时候指定. 3. 内存分配（SGA和PGA） SGA：是用于存储数据库信息的内存区，该信息为数据库进程所共享。它包含Oracle服务器的数据和控制信息,它是在Oracle服务器所驻留的计算机的实际内存中得以分配，如果实际内存不够再往虚拟内存中写。 PGA：包含单个服务器进程或单个后台进程的数据和控制信息，与几个进程共享的SGA正相反，PGA&nbsp;是只被一个进程使用的区域，PGA在创建进程时分配,在终止进程时回收. 4. 后台进程 包括数据写进程（Database&nbsp;Writer,DBWR）、日志写进程（Log&nbsp;Writer,LGWR）、系统监控（System&nbsp;Monitor、SMON）、进程监控（Process&nbsp;Monitor、PMON）、检查点进程（Checkpoint&nbsp;&nbsp;Process、CKPT）、归档进程、服务进程、用户进程。 数据写进程：负责将更改的数据从数据库缓冲区高速缓存写入数据文件 日志写进程：将重做日志缓冲区中的更改写入在线重做日志文件 系统监控：检查数据库的一致性如有必要还会在数据库打开时启动数据库的恢复 进程监控：负责在一个Oracle&nbsp;进程失败时清理资源 检查点进程：负责在每当缓冲区高速缓存中的更改永久地记录在数据库中时,更新控制文件和数据文件中的数据库状态信息。该进程在检查点出现时，对全部数据文件的标题进行修改，指示该检查点。在通常的情况下，该任务由LGWR执行。然而，如果检查点明显地降低系统性能时，可使CKPT进程运行，将原来由LGWR进程执行的检查点的工作分离出来，由CKPT进程实现。对于许多应用情况，CKPT进程是不必要的。只有当数据库有许多数据文件，LGWR在检查点时明显地降低性能才使CKPT运行。CKPT进程不将块写入磁盘，该工作是由DBWR完成的。&nbsp; init.ora文件中CHECKPOINT_PROCESS参数控制CKPT进程的使能或使不能。缺省时为FALSE，即为使不能。 归档进程：在每次日志切换时把已满的日志组进行备份或归档 服务进程：用户进程服务。 用户进程：在客户端，负责将用户的SQL语句传递给服务进程，并从服务器段拿回查询数据。 5.&nbsp;SCN（System&nbsp;ChangeNumber）： 系统改变号，一个由系统内部维护的序列号。当系统需要更新的时候自动增加，他是系统中维持数据的一致性和顺序恢复的重要标志。 Oracle架构实现原理、含五大进程解析 Oracle架构，讲述了Oracle&nbsp;RDBMS的底层实现原理，是Oracle&nbsp;DBA性能调优和排错的基础理论。深入理解Oracle架构，能够让我们在Oracle的路上走的更远。本章节主要是在对RDBMS的底层组件功能和实现原理有一定的了解的情况下，结合自身的工作经验提出了对Oracle调优和排错的思路。当然，对Oracle体系结构的理解是一个深远的过程，需要不断的更新修改。 Oracle RDBMS架构图 一般我们所说的Oracle指的是Oracle&nbsp;RDBMS（Relational&nbsp;databases&nbsp;Management&nbsp;system），一套Oracle数据库管理系统，也称之为Oracle&nbsp;Server。而Oracle&nbsp;Server主要有两大部分：Oracle&nbsp;Server&nbsp;=&nbsp;实例&nbsp;+&nbsp;数据库（Instance和Database是相互独立的）。 数据库 = 数据文件 + 控制文件 +日志文件 实例 = 内存池 + 后台进程 所以可以细分为：Oracle&nbsp;Server&nbsp;=&nbsp;内存池&nbsp;+&nbsp;后台进程&nbsp;+&nbsp;数据文件&nbsp;+&nbsp;控制文件 +&nbsp;日志文件 一台Oracle&nbsp; Server支持创建多个Database，而且每个Datacase是互相隔离而独立的。不同的Database拥有属于自己的全套相关文件，例如：有各自的密码文件，参数文件，数据文件，控制文件和日志文件。 Database由一些物理文件（如：存放在存储设备中的二维表文件）组成。二维表存储在Database中，但Database的内容不能被用户直接读取，用户必须通过Oracle&nbsp;instance才能够访问Database，一个Instance只能连接一个Database，但是一个Database可以被多个Instance连接。 将上面的Oracle&nbsp;RDBMS架构图进行抽象分类，可以将Oracle架构抽象为：Oracle体系&nbsp;=&nbsp;内存结构&nbsp;+&nbsp;进程结构&nbsp;+&nbsp;存储结构 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 内存结构 Oracle&nbsp;Instance是Oracle&nbsp;RDBMS的核心之一，负责RDBMS的管理功能。Oracle&nbsp;Instance主要由内存池SGA和后台进程组成。 系统全局区SGA Oracle的架构不是很难也不是很容易，认真学肯定能学会。 内存池SGA的默认Size，会在安装Oracle的时候会根据LinuxOS的sysctl.conf参数文件来决定： kernel.shmall&nbsp;=&nbsp;2097152kernel.shmmax&nbsp;=&nbsp;2147483648kernel.shmmni&nbsp;=&nbsp;4096kernel.sem&nbsp;=&nbsp;250&nbsp;32000&nbsp;100&nbsp;128net.ipv4.ip_local_port_range&nbsp;=&nbsp;1024&nbsp;65000net.core.rmem_default&nbsp;=&nbsp;1048576net.core.rmem_max&nbsp;=&nbsp;1048576net.core.wmem_default&nbsp;=&nbsp;262144net.core.wmem_max = 262144 查看SGA的Size： SQL&gt; conn /as sysdbaConnected.SQL&gt; show user;USER is &quot;SYS&quot;SQL&gt; select * from v$sga;NAME VALUE-------------------- ----------Fixed Size 2022144Variable Size 503317760Database Buffers 1627389952Redo Buffers 14753792SQL&gt; show sgaTotal System Global Area 2147483648 bytes #对应kernel.shmmax = 2147483648Fixed Size 2022144 bytesVariable Size 503317760 bytesDatabase Buffers 1627389952 bytesRedo Buffers 14753792 bytes SGA（System&nbsp;Global&nbsp;Area）是与Oracle性能关系最大的核心部分，也是对Oracle进行调优的主要考量。SGA内存池会在Instance启动时被分配，在Instance关闭时被释放。在一定范围内，SGA可以在Instance运行时通过自动方式响应DBA的指令。如果想对SGA进行调优还必须理解SGA所包含如下几种数据结构： 高速缓存缓冲区（数据库缓冲区）——oracle执行SQL语句的区域。 例如在更新数据时，用户执行的SQL语句不会直接对磁盘上的数据文件进行更改操作，而是首先将数据文件复制到数据库缓冲区缓存（就是说数据库缓冲区里会存放着SQL相关数据文件副本），再更改应用于数据库缓冲区缓存中这些数据块的副本。而且数据块副本将在缓存中保留一段时间，直至其占用的缓冲区被另一个数据库覆盖为止（缓冲区Size有限）。在查询数据时，为了提高执行效率，查询的数据也要经过缓存。建立的Session会计算出那些数据块包含关键的行，并将它们复制到数据库缓冲区中进行缓存。此后，相关关键行会传输到Session的PGA作进一步处理。这些数据块也会在数据库缓存区缓存中保留一段时间。一般情况下，被频繁访问的数据块会存在于数据库缓冲区缓存中，从而最大程度地减少对磁盘I/O的需要。那什么时候会将被更新的数据块副本写入到磁盘中的数据文件呢？ 答案：如果在缓冲区缓存中存储的数据块与磁盘上的数据块不同时，那么这样的缓冲区常称为”脏缓冲区”，脏缓冲区中的数据块副本就必须写回到磁盘的数据文件中。调优：数据库缓冲区缓存的大小会对性能产生至关重要的影响，具体需要多大的Size才能成为最佳配比还要结合实际的生产环境而言。总体而言可以依据以下两点基本要求来判断： 1.&nbsp;缓存应足够大，以便能缓存所有被频繁访问的数据块。如果缓存过小，那么将导致磁盘I/0活动过多，因为频繁访问的数据块持续从磁盘读取，并由其他数据块使用和重写，然后再从磁盘读取。2.&nbsp;但也不能太大，以至于它会将极少被访问的块也一并加入到缓存中，这样会增长在缓存中搜索的时间。数据库缓冲区缓存在Instance启动时被分配。从数据库9i开始，可以随时将其调大或调小。可以采用手动方式重调，也可以根据工作负荷自动重调大小（事务）。修改缓冲区DB_CACHE_SIZE地方法： #Step1.&nbsp;查看SGA的大小：因为DB_CACHE_SIZE的size受SGA的影响SQL&gt; show parameter sga_max_size;NAME TYPE VALUE------------------------------------ ----------- ------------------------------sga_max_size big integer 2G#Step2. 查看show parameter shared_pool_size的大小SQL&gt; show parameter shared_pool_size; NAME TYPE VALUE------------------------------------ ----------- ------------------------------shared_pool_size big integer 0#Step3.&nbsp;计算DB_CACHE_SIZE的大小：shared_pool_size&nbsp;+&nbsp;db_cache_size&nbsp;=&nbsp;SGA_MAX_SIZE&nbsp;*&nbsp;70%#Step4. 修改DB_CACHE_SIZE的大小SQL&gt; alter system set db_cache_size=1433M scope=spfile sid=&#39;demo&#39;;System altered.SQL&gt; conn sys /as sysdbaEnter password:&nbsp;********Connected.SQL&gt; shutdown immediateDatabase closed.Database dismounted.ORACLE instance shut down.SQL&gt; startupORACLE instance started.Total System Global Area 2147483648 bytesFixed Size 2022144 bytesVariable Size 503317760 bytesDatabase Buffers 1627389952 bytesRedo Buffers 14753792 bytesDatabase mounted.Database opened.SQL&gt; show parameter db_cache_size 日志缓冲区日志缓冲区是小型的、用于短期存储将写入到磁盘上的重做日志的变更向量的临时区域。主要作用是提供更加快的日志处理效率。 共享池共享池的大小也对性能产生重要影响: 1.&nbsp;它应该足够大，以便缓存所有频繁执行的代码和频繁访问的对象定义。如果共享池过小，则性能下降，因为服务器会话将反复抢夺其中的空间来分析语句，此后，这些语句会被其他语句重写，在重新执行时，将不得不再次分析。如果共享池小于最优容量，则性能将下降。但有一个最小容量，如果低于此限度，则语句将失败。2.&nbsp;但也不能过大，以至于连仅执行一次的语句也要缓存。过大的共享池也会对性能产生不良影响，因为搜索需要的时间过长。确定最优容量是一个性能调整问题，大多数数据库都需要一个数百MB的共享池。有些应用程序需要1GB以上的共享池，但很少有应用程序能够在共享池小于100MB时充分运行。共享池内有下列三种数据结构： 库缓冲：存储最近执行的代码 数据字典缓存：存储最近使用的对象定义 PL/SQL缓冲区：存储的PL/SQL对象是过程、函数、打包的过程、打包的函数、对象类型定义和触发器。 手动的调整共享池的大小： select COMPONENT,CURRENT_SIZE,MIN_SIZE,MAX_SIZE from v$sga_dynamic_components; //显示可以动态重设大小的SGA组件的当前最大和最小容量ALTER SYSTEM SET SHARED_POOL_SIZE = 110M; 其他结构大型池——主要用途是供共享的服务器进程使用。JAVA池——只有当应用程序需要在数据库中运行java存储程序时，才需要java池。 进程结构进程结构主要有后台进程和用户连接进程两大类。 用户连接进程 用户连接进程是连接用户和Oracle&nbsp;Instance的桥梁。只有在User与Instance建立了连接以后，User才能够对Oracle&nbsp;Server进行操作。用户连接进程 = 用户进程 + 服务进程 + PGA 用户进程User Process当一个Database&nbsp;User请求连接到Oracle&nbsp;Server时，Oracle&nbsp;Server会创建User&nbsp;Process。 User&nbsp;Process的作用： 为Database User与Server Process建立连接 并不会直接与Oracle Server交互 connect连接：是User和Server&nbsp;Process之间的通信通道。 Server Process服务进程用于处理Database&nbsp;User和Oracle&nbsp;Server之间的连接。 当一个User与User&nbsp;Process建立了一个connect后，Oracle&nbsp;Server会创建一个Server&nbsp;Process。然后再由User&nbsp;Process与Server&nbsp;Process建立了连接之后，Server&nbsp;Process会通过用户提交的请求信息来确定与oracle&nbsp;instance建立一个会话。 Server&nbsp;Process的作用： 与Oracle Server直接交互 复制执行和返回结果 Session会话：一个用户通过User&nbsp;Process(本质是通过Server&nbsp;Process)与Oracle&nbsp;Instance建立连接后称之为一个会话，一个用户可以建立多个会话，即同时使用同一个用户可以多次的连接到同一个实例，也就是说多个session可以使用同一个connect。 程序全局区PGA PGA：Oracle&nbsp;Server&nbsp;Process分配来专门用于当前User&nbsp;Session的内存区。该区域是私有的，不同的用户拥有不同的PGA。PGA包含了Server&nbsp;Process数据和控制信息的内存区域。，由下列3个部分组成： 1.&nbsp;栈空间：存储Session的变量、数组等的内存空间。2.&nbsp;Session&nbsp;Info：如果运行的不是多线程服务器，会话信息将保存在PGA中，如果是多线程服务器，则保存在SGA中。3.&nbsp;私有SQL区：用来保存绑定变量(binding&nbsp;variables)和运行时缓冲区(runtime&nbsp;buffers)等信息。 Oracle的connect连接和session会话与User Process紧密相关注意：在RDBMS中由db\\_name和instance\\_name共同确定一个Database，所以Instance_name被用于Oracle与OS之间的联系同时也被用于Oracle&nbsp;Server与外部连接时使用。所以在User提交连接请求的时候，User&nbsp;Process首先会与Server&nbsp;Process建立Connect，然后Server&nbsp;Process会通过请求中所包含的db\\_name和Instance\\_name来确定需要且可以被连接的数据库(RDBMS可以存在多个数据库)，这样就确保了RDBMS在拥有多个数据库的情况下，还能够保证每一个Database的独立性。而且同一个Database可以被多个属于这个Databse的不同用户发起的Instance连接。这一个功能是非常有必要的，因为每一个不同的数据库中都包含有同名的sys、system等系统用户。 后台进程后台进程主要是完成数据库管理任务&nbsp;，后台进程是Oracle&nbsp;Instance和Oracle&nbsp;Database的联系纽带，分为核心进程和非核心进程。 1.&nbsp;核心进程：核心进程，必须存在，有一个终止，所有数据库进程全部终止，实例崩溃！其中五大进程全都是核心进程。2.&nbsp;非核心进程：完成数据库的额外功能，非核心进程死亡数据库不会崩溃！常用的核心进程： 在用户访问数据库时，首先会提交请求，再分配SGA内存，创建并启动后台进程和实例，最后建立连接和会话。Oracle&nbsp;Server运行过程中必须启动上面的前五个进程。否则实例无法创建。查看后台进程： SQL&gt; select name,description from v$bgprocess where paddr&lt;&gt;&#39;00&#39;;NAME DESCRIPTION----- ----------------------------------------------------------------PMON process cleanupPSP0 process spawner 0MMAN Memory ManagerDBW0 db writer process 0LGWR Redo etc.CKPT checkpointSMON System Monitor ProcessRECO distributed recoveryCJQ0 Job Queue CoordinatorQMNC AQ CoordinatorMMON Manageability Monitor ProcessNAME DESCRIPTION----- ----------------------------------------------------------------MMNL Manageability Monitor Process 2 数据库写入进程（DBWn） Server process连接Oracle后，通过数据库写进程(DBWn)将数据缓冲区中的“脏缓冲区”的数据块写入到存储结构（数据文件、磁盘文件）Database&nbsp;writer&nbsp;(DBWn)数据库写进程： 只做一件事，将数据写到磁盘。就是将数据库的变化写入到数据文件。 该进程最多20&nbsp;个，即使你有36&nbsp;个CPU&nbsp;也只能最多有20&nbsp;个数据库写进程。进程名称DBW0-DBW9 DBWa-DBWj 注意：数据库写进程越多，写数据的效率越高。该进程的个数应该和cpu的个数对应，如果设置的数据库写进程数大于CPU&nbsp;的个数也不会有太明显的效果，因为CPU&nbsp;是分时的。 检查点(CKPT) Checkpoint&nbsp;(CKPT)检查点进程： 主要用户更新数据文件头，更新控制文件和触发DBWn数据库写进程。 Ckpt&nbsp;进程会降低数据库性能，但是提高数据库崩溃时，自我恢复的性能。我们可以理解为阶段性的保存数据，一定的条件满足就触发，执行DBWn存盘操作。 进程监视进程（PMON） Process&nbsp;monitor（PMON）进程监测进程： PMON在后台进程执行失败后负责清理数据库缓存和闲置资源，是Oracle的自动维护机制。 清除死进程 重新启动部分进程（如调度进程） 监听的自动注册 回滚事务 释放锁 释放其他资 系统监视进程（SMON） System&nbsp;monitor&nbsp;(SMON)系统监测进程： SMON启动后会自动的用于在实例崩溃时进行数据库实例自动恢复。 清除作废的排序临时段，回收整理碎片，合并空闲空间，释放临时段，维护闪回的时间点。 在老数据库版本中，当我们大量删除表的时候，会观测到SMON进程很忙，直到把所有的碎片空间都整理完毕。 重做日志文件和日志写入进程 主要用于记录数据库的改变和记录数据库被改变之前的原始状态，所以应当对其作多重备份，用于恢复和排错。激活LGWR的情况： 提交指令 日志缓冲区超过1/3 每三秒 每次DBWn执行之前 归档进程（ARCn）——是非核心进程。 存储结构Oracle&nbsp;RDBMS存储结构主要由Database组成。 又能够将Database分为物理结构和逻辑结构来理解。 物理结构Database物理结构：是Database在操作系统中的文件集合，即：磁盘上的物理文件，主要由数据文件、控制文件、重做日志文件、归档日志文件、参数文件、口令文件组成。 Data Files数据文件是数据的存储仓库： • 包括所有的数据库数据• 只能属于一个数据库• 来自于被称为”表空间”的数据库存储逻辑单元•&nbsp;可以直接被读进内存，在执行SQL语句的时候，会将相关的数据文件副本加载如数据缓冲区。• 通过备份策略可以使数据文件得到保护 Redo Log Files重做日志文件包含对数据库所做的更改操作记录，在Oracle发生故障时能够恢复数据。能够恢复数据的原理：重做日志文件会按时间的顺序，将应用于数据库的一连串的变更向量(做了什么操作)存储起来(即将变更的地方标记起来)。其中包含了所有已经完成操作的信息和完成操作之前的数据库状态。如果数据文件受损，就可以将这些变更向量应用于数据文件备份来进行重做(重建)工作，将它恢复到发生故障的那一刻前的状态。重做日志文件又分为下面两种类型： 联机重做日志文件：记录连续的数据库操作 归档日志文件Archived&nbsp;Log&nbsp;Files：用于时间点恢复，当RedoLogFiles存满时，会对这些日志进行归档备份，以便以后还原数据时使用。 查看redo&nbsp;log&nbsp;info： SQL&gt; select member from v$logfile; # v$logfile数据字典，记录了redolog文件的列表 MEMBER-------------------------------------------------------------------------------- /u01/oradata/demo/redo03.log /u01/oradata/demo/redo02.log /u01/oradata/demo/redo01.log Control Files 控制文件包含维护和验证数据库完整性的必要的信息。 它记录了联机重做日志文件、数据文件的位置、更新的归档日志文件的位置。它还存储着维护数据库完整性所需的信息，如数据库名。控制文件是以二进制型式存储的，用户无法修改控制文件的内容。控制文件不过数MB，却起着至关重要的作用。 Parameter File实例参数文件，当启动oracle实例时，SGA结构会根据此参数文件的设置内存，后台进程会据此启动。 Password File用户通过提交username/password来建立会话，Oracle根据存储在数据字典的用户定义对用户名和口令进行验证。 逻辑结构表空间就是典型的Oracle逻辑结构类型&nbsp;——&nbsp;里面存放着若干的数据文件。 表空间：用于存储数据库对象的逻辑空间，表空间是在数据库中开辟的一个空间，用于存放数据库的对象，它是信息存储的最大逻辑单位，是存放数据库文件的地方，其中数据又被存放在表空间中的数据文件中。一个数据库可以由多个表空间组成，Oracle的调优就是通过表空间来实现的。（Oracle数据库独特的高级应用）表空间的作用：分类管理、批量处理；&nbsp;将琐碎的磁盘文件整合、抽象处理成为逻辑结构。这样更加便于我们去管理数据库。 逻辑空间到物理空间的映射段、区和块： 执行一条写入的SQL语句时在RDBMS中都发生了什么 1. 将SQL语句加载入数据库缓冲区2. 将SQL语句要操作的数据文件副本加载入数据库缓冲区3. 执行SQL语句，修改数据文件副本，形成“脏缓冲区”4. CKPT检测到“脏缓冲区”，调用DBWn5. 在DBWn运行之前，先运行了LGWR，将数据文件的原始状态和数据库的改变记录到Redo Log Files6. 运行DBWn，将“脏缓冲区的内容写入到数据文件”7. 同时CKPT修改控制文件和数据文件头8. SMON回收不必要的空闲资源 最后最后我们举个例子来看看Oracle RDBMS是怎么运作的 User访问Oracle&nbsp;Server之前提交一个请求(包含了db_name、instance_name、username、password等信息)，Oracle&nbsp;Server接收到请求并通过Password&nbsp;File的验证后，分配SGA内存池，启动后台进程同时创建并启动实例。 在启动实例之后User&nbsp;Process与Server&nbsp;Process建立Connect。 再通过Server&nbsp;process和Oracle&nbsp;Instance完成建立Sesscion。 用户执行SQL语句，由server&nbsp;process接收到并直接与Oracle交互。 SQL语句通过Server&nbsp;Process到达Oracle&nbsp;Instance，再将SQL载入数据库缓冲区。 Server&nbsp;Process通知Oracle&nbsp;Database将与SQL语句相关的数据块副本加载到缓冲区中。 在数据库缓存区执行SQL语句，并产生”脏缓冲区”。 由CKPT检查点进程检查到”脏缓冲区”，并调用DBWn数据库写进程，但在DBWn执行之前，应该由LGWR先将数据文件的原始状态、数据库的改变等信息记录到Redo&nbsp;Log&nbsp;Files。 将更新的内容写入到磁盘中的数据文件。 返回结果给用户 资源下载 关注公众号：数据和云（OraNews）回复关键字获取 2018DTCC ，数据库大会PPT 2018DTC，2018 DTC 大会 PPT ENMOBK，《Oracle性能优化与诊断案例》 DBALIFE&nbsp;，“DBA 的一天”海报 DBA04&nbsp;，DBA 手记4 电子书 122ARCH&nbsp;，Oracle 12.2体系结构图 2018OOW&nbsp;，Oracle OpenWorld 资料 云和恩墨大讲堂 |&nbsp;一个分享交流的地方 长按，识别二维码，加入万人交流社群 请备注：云和恩墨大讲堂","@type":"BlogPosting","url":"https://mlh.app/2019/04/17/729897.html","headline":"万字详解Oracle架构、原理、进程，学会世间再无复杂架构","dateModified":"2019-04-17T00:00:00+08:00","datePublished":"2019-04-17T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/17/729897.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>万字详解Oracle架构、原理、进程，学会世间再无复杂架构</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="rich_media_content" id="js_content"> 
   <p style="margin-left:8px;"><span style="font-size:14px;">学习是一个循序渐进的过程，从面到点、从宏观到微观，逐步渗透,各个击破，对于Oracle,&nbsp;怎么样从宏观上来理解呢？先来看一个图，这个图取自于教材，这个图对于从整体上理解ORACLE&nbsp;的体系结构组件，非常关键。</span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">首先看张图：</span></p>
   <p style="margin-left:8px;"><br><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;text-align:center;"><span style="font-size:14px;"><img style="width:420px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSdldcUpMwnCD0N5EJiaJNFfRqlsMVUa5QsSMVkplSibS5EooEnNfRa5XQ/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">对于一个数据库系统来说，假设这个系统没有运行，我们所能看到的和这个数据库相关的无非就是几个基于操作系统的物理文件，这是从静态的角度来看,如果从动态的角度来看呢,也就是说这个数据库系统运行起来了，能够对外提供服务了，那就意外着数据库系统启动了自己的一个实例，综合以上2个角度，Oracle如何定义上述描述呢？<br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span><br></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">我们来引入第一个概念，Oracle服务器，所谓Oracle服务器是一个数据库管理系统，它包括一个Oracle实例（动态）和一个Oracle数据库（静态）。Oracle实例是一个运行的概念（如操作系统的进程），提供了一种访问，Oracle数据库的方式，始终打开一个，并且只能打开一个<span style="font-size:14px;">O</span>racle数据库，<span style="font-size:14px;">O</span>racle实例有SGA和一些后台服务进程组成，在后台服务进程当中，DBWn&nbsp;PMON&nbsp;CKPT&nbsp;LGWR&nbsp;SMON是必备的后台进程，而ad&nbsp;queue、rac、shared&nbsp;server、ad&nbsp;replication则是可选的，之所以可选，要们是因为离开它Oracle也能正常运行，要么是一些高级的功能才可以用得到。</span></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><span style="font-size:14px;">O</span>racle数据库是一个被统一处理的的数据的集合，从物理角度来看包括三类文件数据文件，控制文件，重做日志文件。从逻辑角度来看，<span style="font-size:14px;">O</span>racle数据库至少包含一个表空间，表空间至少包含一个段，段由区做成，区有块组成。需要注意的是表空间可以包含若干个数据文件，段可以跨同一个表空间的多个数据文件，区只能在同一个数据文件内。<br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><span style="font-size:14px;">O</span>racle还设计了其他的关键文件用来为整个系统服务，如配置文件、密码文件、归档日志文件，还有还有用户进程和服务进程，现在可以简单理解下执行SQL语句就要用到这2个进程。</span></p>
   <p style="margin-left:8px;"><span style="font-size:12px;">&nbsp;</span></p>
   <table cellspacing="0" cellpadding="0">
    <tbody>
     <tr>
      <td rowspan="6" width="43"><p style="text-align:center;margin-left:8px;"><span style="font-size:12px;">SGA</span></p></td>
      <td rowspan="2" width="216" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">SHARE POOL</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（共享池）</span></p><p style="margin-left:8px;"><span style="font-size:12px;">用如下命令可以调整</span></p><p style="margin-left:8px;"><span style="font-size:12px;">ALTER SYSTEM SET</span></p><p style="margin-left:8px;"><span style="font-size:12px;">SHARED_POOL_SIZE=64M</span></p></td>
      <td width="300" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">LIBRARY CACHE</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（库高速缓存）</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">1</span>存储最近使用的<span style="font-size:12px;font-family:'Times New Roman';">SQL</span>和<span style="font-size:12px;font-family:'Times New Roman';">PL/SQL</span>语句信息</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">2</span>包括<span style="font-size:12px;font-family:'Times New Roman';">SHARED SQL</span>和<span style="font-size:12px;font-family:'Times New Roman';">SHARED PL/SQL</span></span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">3</span>用<span style="font-size:12px;font-family:'Times New Roman';">LRU</span>算法管理</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">4</span>大小由<span style="font-size:12px;font-family:'Times New Roman';">SHARE POOL</span>大小决定</span></p></td>
     </tr>
     <tr>
      <td width="300" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">DATA DICTIONARY CACHE</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（数据字典高速缓存）</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">1</span>数据库中最近使用的定义的集合</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">2</span>包含数据库文件，表，索引，列，用户，权限和其他的数据库对象相关信息</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">3</span>在语法分析阶段，服务器进程会在数据字典中查找用于对象解析和验证访问的信息</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">4</span>将数据字典信息高速缓存到内存中，可缩短查询和<span style="font-size:12px;font-family:'Times New Roman';">DML</span>的响应时间</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">5</span>大小由共享池的大小决定</span></p></td>
     </tr>
     <tr>
      <td width="216" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">DATABASE BUFFER CACHE</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（数据缓冲区高速缓存）</span></p></td>
      <td width="300" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">1</span>存储已从数据文件检索到的数据的复本</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">2</span>大幅提高读取和更新数据的性能</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">3</span>使用<span style="font-size:12px;font-family:'Times New Roman';">LRU</span>算法管理</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">4</span>主块的大小由<span style="font-size:12px;font-family:'Times New Roman';">DB_BLOCK_SIZE</span>确定</span></p></td>
     </tr>
     <tr>
      <td width="216" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">REDO LOG BUFFER</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（重做日志缓冲区）</span></p></td>
      <td width="300" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">1</span>记录对数据库数据块作的全部更改</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">2</span>主要用来恢复</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">3</span>其中记录的更改被称作重做条目</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">4</span>重做条目包含用于重新构建或重做更改的信息</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">5</span>大小由<span style="font-size:12px;font-family:'Times New Roman';">LOG_BUFFER</span>定义</span></p></td>
     </tr>
     <tr>
      <td width="216" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">LARGE POOL</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（大型池）</span></p></td>
      <td width="300" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">1 SGA</span>可选的内存区</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">2</span>分担了共享池的一部分工作</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">3</span>用于共享服务器的<span style="font-size:12px;font-family:'Times New Roman';">UGA</span></span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">4</span>用于<span style="font-size:12px;font-family:'Times New Roman';">I/O</span>服务器进程</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">5</span>备份和恢复操作或<span style="font-size:12px;font-family:'Times New Roman';">RMAN</span></span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">6</span>并行执行消息缓冲区（前提<span style="font-size:12px;font-family:'Times New Roman';">PARALLEL_POOL_SIZE=TRUE</span>）</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">7</span>不使用<span style="font-size:12px;font-family:'Times New Roman';">LRU</span>列表</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">8</span>大小由<span style="font-size:12px;font-family:'Times New Roman';">LARGE_POOL_SIZE</span>确定</span></p></td>
     </tr>
     <tr>
      <td width="216" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">JAVA POOL</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（<span style="font-size:12px;font-family:'Times New Roman';">JAVA</span>池）</span></p></td>
      <td width="300" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">1</span>存储<span style="font-size:12px;font-family:'Times New Roman';">JAVA</span>命令服务分析要求</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">2</span>安装和使用<span style="font-size:12px;font-family:'Times New Roman';">JAVA</span>时必须的</span></p><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">3</span>大小有<span style="font-size:12px;font-family:'Times New Roman';">JAVA_POOL_SIZE</span>确定</span></p></td>
     </tr>
     <tr>
      <td rowspan="4" width="43"><p style="text-align:center;margin-left:8px;"><span style="font-size:12px;">PGA</span></p></td>
      <td rowspan="2" width="216" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">PRIVATE SQL AREA</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（专用<span style="font-size:12px;font-family:'Times New Roman';">SQL</span>区）</span></p><p style="margin-left:8px;"><span style="font-size:12px;">&nbsp;</span></p><p style="margin-left:8px;"><span style="font-size:12px;">专用<span style="font-size:12px;font-family:'Times New Roman';">SQL&nbsp;</span>区的位置取决于为会话建立的连接类型。在专用服务器环境中，专用<span style="font-size:12px;font-family:'Times New Roman';">SQL&nbsp;</span>区位于各自服务器进程的<span style="font-size:12px;font-family:'Times New Roman';">PGA</span>中。在共享服务器环境中，专用<span style="font-size:12px;font-family:'Times New Roman';">SQL&nbsp;</span>区位于<span style="font-size:12px;font-family:'Times New Roman';">SGA&nbsp;</span>中。</span></p><p style="margin-left:8px;"><span style="font-size:12px;">管理专用<span style="font-size:12px;font-family:'Times New Roman';">SQL&nbsp;</span>区是用户进程的职责。用户进程可以分配的专用<span style="font-size:12px;font-family:'Times New Roman';">SQL&nbsp;</span>区的数目始终由</span></p><p style="margin-left:8px;"><span style="font-size:12px;">初始化参数<span style="font-size:12px;font-family:'Times New Roman';">OPEN_CURSORS&nbsp;</span>来限制。该参数的缺省值是<span style="font-size:12px;font-family:'Times New Roman';">50</span>。</span></p></td>
      <td width="300" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">PERSISTEN AREA</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（永久区）</span></p><p style="margin-left:8px;"><span style="font-size:12px;">包含绑定信息，并且只在关闭游标时释放</span></p></td>
     </tr>
     <tr>
      <td width="300" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">RUNTIME AREA</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（运行时区）</span></p><p style="margin-left:8px;"><span style="font-size:12px;">在执行请求时的第一步创建。对于<span style="font-size:12px;font-family:'Times New Roman';">INSERT</span>、<span style="font-size:12px;font-family:'Times New Roman';">UPDATE&nbsp;</span>和<span style="font-size:12px;font-family:'Times New Roman';">DELETE</span>命令，该区在执行语句后释放，对于查询操作，该区只在提取所有行或取消查询后释放。</span></p></td>
     </tr>
     <tr>
      <td width="216" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">SESSION MEMORY</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（会话内存）</span></p></td>
      <td width="300" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">包含为保留会话变量以及与该会话相关的其它信息而分配的内存。对于共享服务器环境，该会话是共享的而不是专用的。</span></p></td>
     </tr>
     <tr>
      <td width="216" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">SQL WORK AREAS</span></p><p style="margin-left:8px;"><span style="font-size:12px;">（<span style="font-size:12px;font-family:'Times New Roman';">SQL</span>工作区）</span></p></td>
      <td width="300" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">用于大量占用内存的操作，如排序、散列联接、位图合并和位图创建。</span></p><p style="margin-left:8px;"><span style="font-size:12px;">工作区的大小可进行控制和调整</span></p></td>
     </tr>
    </tbody>
   </table>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">下表是后台进程总结</span></p>
   <p style="margin-left:8px;"><br><span style="font-size:14px;"></span></p>
   <table cellspacing="0" cellpadding="0">
    <tbody>
     <tr>
      <td width="56"><p style="text-align:center;margin-left:8px;"><span style="font-size:12px;">DBWn</span></p></td>
      <td width="505" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">DBWn&nbsp;</span>延迟写入数据文件<span style="font-size:12px;font-family:'Times New Roman';">,</span>直到发生下列事件之一：</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>增量或正常检查点</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>灰数据缓冲区的数量达到阈值</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>进程扫描指定数量的块而无法找到任何空闲缓冲区时</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>出现超时</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>实时应用集群<span style="font-size:12px;font-family:'Times New Roman';">(Real Application Clusters, RAC)&nbsp;</span>环境中出现<span style="font-size:12px;font-family:'Times New Roman';">ping&nbsp;</span>请求</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>使一般表空间或临时表空间处于脱机状态</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>使表空间处于只读模式</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>删除或截断表</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>执行<span style="font-size:12px;font-family:'Times New Roman';">ALTER TABLESPACE&nbsp;</span>表空间名<span style="font-size:12px;font-family:'Times New Roman';">BEGIN BACKUP&nbsp;</span>操作</span></p></td>
     </tr>
     <tr>
      <td width="56" valign="top"><p style="text-align:center;margin-left:8px;"><span style="font-size:12px;">LGWR</span></p></td>
      <td width="505" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;"><span style="font-size:12px;font-family:'Times New Roman';">LGWR&nbsp;</span>在下列情况下执行从重做日志缓冲区到重做日志文件的连续写入：</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>当提交事务时</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>当重做日志缓冲区的三分之一填满时</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>当重做日志缓冲区中记录了超过<span style="font-size:12px;font-family:'Times New Roman';">1 MB&nbsp;</span>的更改时</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>在<span style="font-size:12px;font-family:'Times New Roman';">DBWn&nbsp;</span>将数据库缓冲区高速缓存中修改的块写入数据文件以前</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>每隔三秒</span></p></td>
     </tr>
     <tr>
      <td width="56" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">SMON</span></p></td>
      <td width="505" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">例程恢复</span></p><p style="margin-left:8px;"><span style="font-size:12px;">–<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>前滚重做日志中的更改</span></p><p style="margin-left:8px;"><span style="font-size:12px;">–<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>打开数据库供用户访问</span></p><p style="margin-left:8px;"><span style="font-size:12px;">–<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>回退未提交的事务处理</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>合并空闲空间</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>回收临时段</span></p></td>
     </tr>
     <tr>
      <td width="56" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">PMON</span></p></td>
      <td width="505" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">进程失败后，后台进程<span style="font-size:12px;font-family:'Times New Roman';">PMON&nbsp;</span>通过下面的方法进行清理：</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>回退用户的当前事务处理</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>释放当前保留的所有表锁或行锁</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>释放用户当前保留的其它资源</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>重新启动已失效的调度程序</span></p></td>
     </tr>
     <tr>
      <td width="56" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">CKPT</span></p></td>
      <td width="505" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>在检查点发信号给<span style="font-size:12px;font-family:'Times New Roman';">DBWn</span></span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>使用检查点信息更新数据文件的标头</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>使用检查点信息更新控制</span></p><p style="margin-left:8px;"><span style="font-size:12px;">启动检查点的原因如下：</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>确保定期向磁盘写入内存中发生修改的数据块，以便在系统或数据库失败时不会丢失数据</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>缩短例程恢复所需的时间。只需处理最后一个检查点后面的重做日志条目以启动恢复操作</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>确保提交的所有数据在关闭期间均已写入数据文件</span></p><p style="margin-left:8px;"><span style="font-size:12px;">由<span style="font-size:12px;font-family:'Times New Roman';">CKPT&nbsp;</span>写入的检查点信息包括检查点位置、系统更改号、重做日志中恢复操作的起始位置以及有关日志的信息等等。</span></p><p style="margin-left:8px;"><span style="font-size:12px;">注：<span style="font-size:12px;font-family:'Times New Roman';">CKPT&nbsp;</span>并不将数据块写入磁盘，或将重做块写入联机重做日志。</span></p></td>
     </tr>
     <tr>
      <td width="56"><p style="text-align:center;margin-left:8px;"><span style="font-size:12px;">ARCn</span></p></td>
      <td width="505" valign="top"><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>可选的后台进程</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>设置<span style="font-size:12px;font-family:'Times New Roman';">ARCHIVELOG&nbsp;</span>模式时自动归档联机重做日志</span></p><p style="margin-left:8px;"><span style="font-size:12px;">•<span style="font-size:12px;font-family:'Times New Roman';">&nbsp;</span>保留数据库的全部更改记录</span></p></td>
     </tr>
    </tbody>
   </table>
   <p><br></p>
   <p> </p>
   <p style="margin-left:8px;"><span style="font-size:14px;">最后，举一个用户提交SQL语句的的例子来结束本文，如果用户想提交SQL语句，那么首先你必须要连接到Oracle实例，连接到<span style="font-size:14px;">Oracle</span>实例有三种途径：如果用户登陆到运行<span style="font-size:14px;">Oracle</span>实例的操作系统上，则通过进程间通信进行访问2C/S结构访问3三层结构。发起连接的应用程序或工具通常称为用户进程，连接发起后，Oracle服务器就会创建一个进程来接受连接，这个进程就成为服务进程，服务器进程代表用户进程与Oracle实例进行通信，在专用服务器连接模式下，用户进程和服务进程是1对1的关系，在共享服务器模式下，多个用户进程可能共享一个服务进程。当服务器进程开始和Oracle实例进行通信时，一个会话就被创建了。显然处理一个查询要经过语法分析、绑定、执行、提取等阶段。</span></p>
   <p style="margin-left:8px;"><br></p>
   <p style="margin-left:8px;"><strong>Oracle的基础架构知识<br></strong></p>
   <p style="margin-left:8px;"><br></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">笔者在学习Oracle之前，特地先去了解了OracleDB的框架。这样对Oracle数据库有一个整体的认知，有由高屋建领地的作用。磨刀不误砍菜功吧。Oracle数据库主要由一下5部分组成：</span></p>
   <p style="margin-left:8px;"><br></p>
   <p style="margin-left:8px;text-align:center;"><img width="562" height="305" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSicp1YroeVnPibS7ibvFpXk1vPoV9llhvAYgiaqfUS69kF0nLjcPuDBzQRw/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="margin-left:8px;"><br></p>
   <p style="margin-left:8px;"><strong><span style="font-size:14px;">1. 物理结构<br></span></strong></p>
   <p style="margin-left:8px;"><span style="font-size:14px;color:rgb(136,136,136);"><br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;color:rgb(136,136,136);">Oracle物理结构由控制文件、数据文件、重做日志文件、参数文件、归档文件、口令文件组成<br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">一个数据库中的数据存储在磁盘上物理文件，被使用时，调入内存。其中控制文件、数据文件、重做日志文件、跟踪文件及警告日志（trace&nbsp;files、alert&nbsp;files）属于数据库文件；参数文件（parameter&nbsp;file）口令文件（password&nbsp;file）是非数据库文件。<br></span></p>
   <p style="margin-left:8px;"><br><span style="font-size:14px;"></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;"><span style="font-size:14px;">数据文件：存储数据的文件.数据文件典型地代表了根据他们使用的磁盘空间和数量所决定的一个Oracle数据库的容积。</span></p></li>
   </ul>
   <p style="margin-left:8px;"><span style="font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于此我们需要知道的是，一个数据库中的数据是存储在磁盘上的物理文件，被使用时才被调入内存中的。其中控制文件、数据文件、重做日志文件、跟踪文件、警告文件属于数据库文件。参数文件、口令文件属于非数据库文件。</span></p>
   <p><span style="font-size:14px;"></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;"><span style="font-size:14px;">控制文件：包含维护和验证数据库完整性的必要信息、例如，控制文件用于识别数据文件和重做日志文件，一个数据库至少需要一个控制文件。<span style="font-size:14px;">控制文件内容</span>有：</span></p>
     <ul style="list-style-type:disc;" class="list-paddingleft-2">
      <li><p style="margin-left:8px;"><span style="font-size:14px;">数据库名</span></p></li>
      <li><p style="margin-left:8px;"><span style="font-size:14px;">表空间信息</span></p></li>
      <li><p style="margin-left:8px;"><span style="font-size:14px;">所有数据文件的名字和位置</span></p></li>
      <li><p style="margin-left:8px;"><span style="font-size:14px;">所有redo日志文件的名字和位置</span></p></li>
      <li><p style="margin-left:8px;"><span style="font-size:14px;">当前的日志序列号</span></p></li>
      <li><p style="margin-left:8px;"><span style="font-size:14px;">检查点信息</span></p></li>
      <li><p style="margin-left:8px;"><span style="font-size:14px;">关于redo日志和归档的当前状态信息</span></p></li>
     </ul></li>
   </ul>
   <p style="margin-left:8px;"><span style="font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;控制文件的使用过程是控制文件把Oracle引导到数据库文件的其它部分。启动一个实例时，Oracle从参数文件中读取控制文件的名字和位置。安装数据库时，Oracle打开控制文件。最终打开数据库时，Oracle从控制文件中读取数据文件的列表并打开其中的每个文件。</span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;"><span style="font-size:14px;">重做日志文件，含对数据库所做的更改记录，这样万一出现故障可以启用数据恢复。一个数据库至少需要两个重做日志文件。</span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">跟踪文件及警告日志(Trace Files and Alert Files)，</span></p>
     <ul style="list-style-type:disc;" class="list-paddingleft-2">
      <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"><span style="font-size:14px;">跟踪文件</span>是在instance&nbsp;中运行的每一个后台进程都有一个跟踪文件（trace&nbsp;file）与之相连。Trace&nbsp;file记载后台进程所遇到的重大事件的信息。</span></p></li>
      <li><p style="margin-left:8px;"><span style="font-size:14px;">警告日志（&nbsp;Alert&nbsp;Log）是一种特殊的跟踪文件，每个数据库都有一个跟踪文件，同步记载数据库的消息和错误。</span></p></li>
     </ul></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">参数文件：包括大量影响Oracle数据库实例功能的设定，如以下设定：</span></p>
     <ul style="list-style-type:disc;" class="list-paddingleft-2">
      <li><p style="margin-left:8px;"><span style="font-size:14px;">数据库控制文件的定位</span></p></li>
      <li><p style="margin-left:8px;"><span style="font-size:14px;">Oracle用来缓存从磁盘上读取的数据的内存数量</span></p></li>
      <li><p style="margin-left:8px;"><span style="font-size:14px;">默认的优化程序的选择</span></p></li>
     </ul></li>
   </ul>
   <p style="margin-left:8px;"><span style="font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和数据库文件相关，执行两个重要的功能，为数据库指出控制文件和为数据库指出归档日志的目标。<br></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;"><span style="font-size:14px;">归档文件：是重做日志文件的脱机副本，这些副本可能对于从介质失败中进行恢复很必要。</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">口令文件：认证哪些用户有权限启动和关闭Oracle例程.</span></p></li>
   </ul>
   <p style="margin-left:8px;"><strong><span style="font-size:14px;">2. 逻辑结构（表空间、段、区、块）</span></strong></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;"><span style="font-size:14px;">表空间：是数据库中的基本逻辑结构，一系列数据文件的集合。</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">段：是对象在数据库中占用的空间.</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">区：是为数据一次性预留的一个较大的存储空间.</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">块：ORACLE最基本的存储单位，在建立数据库的时候指定.</span></p></li>
   </ul>
   <p style="margin-left:8px;"><strong><span style="font-size:14px;">3. 内存分配（SGA和PGA）</span></strong><span style="font-size:14px;"></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;"><span style="font-size:14px;">SGA：是用于存储数据库信息的内存区，该信息为数据库进程所共享。它包含<span style="font-size:14px;">Oracle</span>服务器的数据和控制信息,它是在Oracle服务器所驻留的计算机的实际内存中得以分配，如果实际内存不够再往虚拟内存中写。</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">PGA：包含单个服务器进程或单个后台进程的数据和控制信息，与几个进程共享的SGA正相反，PGA&nbsp;是只被一个进程使用的区域，PGA在创建进程时分配,在终止进程时回收.</span></p></li>
   </ul>
   <p style="margin-left:8px;"><strong><span style="font-size:14px;">4. 后台进程</span></strong></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">包括数据写进程（Database&nbsp;Writer,DBWR）、日志写进程（Log&nbsp;Writer,LGWR）、系统监控（System&nbsp;Monitor、SMON）、进程监控（Process&nbsp;Monitor、PMON）、检查点进程（Checkpoint&nbsp;&nbsp;Process、CKPT）、归档进程、服务进程、用户进程。</span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;"><span style="font-size:14px;">数据写进程：负责将更改的数据从数据库缓冲区高速缓存写入数据文件</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">日志写进程：将重做日志缓冲区中的更改写入在线重做日志文件</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">系统监控：检查数据库的一致性如有必要还会在数据库打开时启动数据库的恢复</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">进程监控：负责在一个Oracle&nbsp;进程失败时清理资源</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">检查点进程：负责在每当缓冲区高速缓存中的更改永久地记录在数据库中时,更新控制文件和数据文件中的数据库状态信息。该进程在检查点出现时，对全部数据文件的标题进行修改，指示该检查点。在通常的情况下，该任务由LGWR执行。然而，如果检查点明显地降低系统性能时，可使CKPT进程运行，将原来由LGWR进程执行的检查点的工作分离出来，由CKPT进程实现。对于许多应用情况，CKPT进程是不必要的。只有当数据库有许多数据文件，LGWR在检查点时明显地降低性能才使CKPT运行。CKPT进程不将块写入磁盘，该工作是由DBWR完成的。&nbsp; init.ora文件中CHECKPOINT_PROCESS参数控制CKPT进程的使能或使不能。缺省时为FALSE，即为使不能。</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">归档进程：在每次日志切换时把已满的日志组进行备份或归档</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">服务进程：用户进程服务。</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">用户进程：在客户端，负责将用户的SQL语句传递给服务进程，并从服务器段拿回查询数据。</span></p></li>
   </ul>
   <p style="margin-left:8px;"><strong><span style="font-size:14px;">5.&nbsp;SCN（System&nbsp;ChangeNumber）：</span></strong><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;"><span style="font-size:14px;">系统改变号，一个由系统内部维护的序列号。当系统需要更新的时候自动增加，他是系统中维持数据的一致性和顺序恢复的重要标志。</span></p></li>
   </ul>
   <p style="margin-left:8px;"><br></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><span style="font-size:17px;"><strong>Oracle架构实现原理、含五大进程解析</strong></span></p>
   <p style="margin-left:8px;"><br></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">Oracle架构，讲述了Oracle&nbsp;RDBMS的底层实现原理，是Oracle&nbsp;DBA性能调优和排错的基础理论。深入理解Oracle架构，能够让我们在Oracle的路上走的更远。本章节主要是在对RDBMS的底层组件功能和实现原理有一定的了解的情况下，结合自身的工作经验提出了对Oracle调优和排错的思路。当然，对Oracle体系结构的理解是一个深远的过程，需要不断的更新修改。</span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="text-align:center;margin-left:8px;"><img style="width:363px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSrA6SBo4HEywIOs9A7IMBgp2wvPKrib3ia5E1J3Ac7qHNwVO3pU28fqIg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="text-align:center;margin-left:8px;"><span style="font-size:12px;color:rgb(136,136,136);">Oracle RDBMS架构图</span><br></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">一般我们所说的Oracle指的是Oracle&nbsp;RDBMS（Relational&nbsp;databases&nbsp;Management&nbsp;system），一套Oracle数据库管理系统，也称之为Oracle&nbsp;Server。而Oracle&nbsp;Server主要有两大部分：Oracle&nbsp;Server&nbsp;=&nbsp;实例&nbsp;+&nbsp;数据库（Instance和Database是相互独立的）。</span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;"><span style="font-size:14px;">数据库 = 数据文件 + 控制文件 +日志文件</span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">实例 = 内存池 + 后台进程</span></p></li>
   </ul>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">所以可以细分为：<strong>Oracle&nbsp;Server&nbsp;=&nbsp;内存池&nbsp;+&nbsp;后台进程&nbsp;+&nbsp;数据文件&nbsp;+&nbsp;控制文件 +&nbsp;日志文件</strong></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">一台Oracle&nbsp; Server支持创建多个Database，而且每个Datacase是互相隔离而独立的。不同的Database拥有属于自己的全套相关文件，例如：有各自的密码文件，参数文件，数据文件，控制文件和日志文件。</span></p>
   <p style="margin-left:8px;"><br><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">Database由一些物理文件（如：存放在存储设备中的二维表文件）组成。二维表存储在Database中，但Database的内容不能被用户直接读取，用户必须通过Oracle&nbsp;instance才能够访问Database，一个Instance只能连接一个Database，但是一个Database可以被多个Instance连接。</span></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">将上面的Oracle&nbsp;RDBMS架构图进行抽象分类，可以将Oracle架构抽象为：Oracle体系&nbsp;=&nbsp;内存结构&nbsp;+&nbsp;进程结构&nbsp;+&nbsp;存储结构</span></p>
   <p style="margin-left:8px;"><br><span style="font-size:14px;"></span></p>
   <p style="text-align:center;margin-left:8px;"><img style="width:311px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSwcdibguEOEia6WTnCKRDsicmOoHDPzcicVJyJVrD3Dkk8vjWW5fiaYxp6mQ/640?wx_fmt=png" alt="640?wx_fmt=png"><span style="font-size:14px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><strong><span style="font-size:14px;">内存结构</span></strong><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;"><br><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">Oracle&nbsp;Instance是Oracle&nbsp;RDBMS的核心之一，负责RDBMS的管理功能。Oracle&nbsp;Instance主要由内存池SGA和后台进程组成。</span></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;"></span></p>
   <p style="text-align:center;margin-left:8px;"><img style="width:347px;" width="700" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSYcW4jy0g3Mlqx1DlkOmxGWUDNWpYk9R4pjqxwQpDDvzY8NZlNnvrow/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><strong><span style="font-size:14px;">系统全局区SGA</span></strong><strong><span style="font-size:14px;"></span></strong><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;"><br></p>
   <p style="margin-left:8px;text-align:center;"><img style="width:340px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSPfNvINXT1tl7JH3lvticls952ovp8R1buAV4NX99BdydUGH8xG6nPaw/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="margin-left:8px;"><br><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">Oracle的架构不是很难也不是很容易，认真学肯定能学会。<br></span></p>
   <p style="margin-left:8px;"><br></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">内存池SGA的默认Size，会在安装Oracle的时候会根据LinuxOS的sysctl.conf参数文件来决定：</span></p>
   <p style="margin-left:8px;"><br></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span></p>
   <ul class="code-snippet__line-index code-snippet__js">
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
   </ul>
   <pre class="code-snippet__js"><code><span class="code-snippet_outer">kernel.shmall&nbsp;=&nbsp;2097152</span></code><code><span class="code-snippet_outer">kernel.shmmax&nbsp;=&nbsp;2147483648</span></code><code><span class="code-snippet_outer">kernel.shmmni&nbsp;=&nbsp;4096</span></code><code><span class="code-snippet_outer">kernel.sem&nbsp;=&nbsp;250&nbsp;32000&nbsp;100&nbsp;128</span></code><code><span class="code-snippet_outer">net.ipv4.ip_local_port_range&nbsp;=&nbsp;1024&nbsp;65000</span></code><code><span class="code-snippet_outer">net.core.rmem_default&nbsp;=&nbsp;1048576</span></code><code><span class="code-snippet_outer">net.core.rmem_max&nbsp;=&nbsp;1048576</span></code><code><span class="code-snippet_outer">net.core.wmem_default&nbsp;=&nbsp;262144</span></code><code><span class="code-snippet_outer">net.core.wmem_max = 262144</span></code></pre>
   <p><br></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><strong>查看SGA的Size：</strong></span><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;"><br></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span></p>
   <ul class="code-snippet__line-index code-snippet__js">
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
   </ul>
   <pre class="code-snippet__js"><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">conn /as sysdba</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Connected.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">show user;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">USER</span> <span class="code-snippet__string">is "SYS"</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">select * from v$sga;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">NAME</span> <span class="code-snippet__string">VALUE</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">--------------------</span> <span class="code-snippet__string">----------</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Fixed</span> <span class="code-snippet__string">Size 2022144</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Variable</span> <span class="code-snippet__string">Size 503317760</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Database</span> <span class="code-snippet__string">Buffers 1627389952</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Redo</span> <span class="code-snippet__string">Buffers 14753792</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">show sga</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Total</span> <span class="code-snippet__string">System Global Area 2147483648 bytes #对应kernel.shmmax = 2147483648</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Fixed</span> <span class="code-snippet__string">Size 2022144 bytes</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Variable</span> <span class="code-snippet__string">Size 503317760 bytes</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Database</span> <span class="code-snippet__string">Buffers 1627389952 bytes</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Redo</span> <span class="code-snippet__string">Buffers 14753792 bytes</span></span></code></pre>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span><br><span style="font-size:14px;">SGA（System&nbsp;Global&nbsp;Area）是与Oracle性能关系最大的核心部分，也是对Oracle进行调优的主要考量。</span><span style="font-size:14px;">SGA内存池会在Instance启动时被分配，在Instance关闭时被释放。</span><span style="font-size:14px;">在一定范围内，SGA可以在Instance运行时通过自动方式响应DBA的指令。</span><span style="font-size:14px;">如果想对SGA进行调优还必须理解SGA所包含如下几种数据结构：</span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">高速缓存缓冲区（数据库缓冲区）——</span></strong><span style="font-size:14px;">oracle执行SQL语句的区域。</span><br><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;">例如在更新数据时，用户执行的SQL语句不会直接对磁盘上的数据文件进行更改操作，而是首先将数据文件复制到数据库缓冲区缓存（就是说数据库缓冲区里会存放着SQL相关数据文件副本），再更改应用于数据库缓冲区缓存中这些数据块的副本。</span><span style="font-size:14px;">而且数据块副本将在缓存中保留一段时间，直至其占用的缓冲区被另一个数据库覆盖为止（缓冲区Size有限）。</span><br><br><span style="font-size:14px;">在查询数据时，为了提高执行效率，查询的数据也要经过缓存。</span><span style="font-size:14px;">建立的Session会计算出那些数据块包含关键的行，并将它们复制到数据库缓冲区中进行缓存。</span><span style="font-size:14px;">此后，相关关键行会传输到Session的PGA作进一步处理。</span><span style="font-size:14px;">这些数据块也会在数据库缓存区缓存中保留一段时间。</span><br><br><span style="font-size:14px;">一般情况下，被频繁访问的数据块会存在于数据库缓冲区缓存中，从而最大程度地减少对磁盘I/O的需要。</span><br><br><span style="font-size:14px;">那什么时候会将被更新的数据块副本写入到磁盘中的数据文件呢？</span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span><br><span style="font-size:14px;">答案：</span><span style="font-size:14px;">如果在缓冲区缓存中存储的数据块与磁盘上的数据块不同时，那么这样的缓冲区常称为”脏缓冲区”，脏缓冲区中的数据块副本就必须写回到磁盘的数据文件中。</span><br><br><strong><span style="font-size:14px;">调优：</span><span style="font-size:14px;"></span></strong><span style="font-size:14px;">数据库缓冲区缓存的大小会对性能产生至关重要的影响，具体需要多大的Size才能成为最佳配比还要结合实际的生产环境而言。</span><span style="font-size:14px;">总体而言可以依据以下两点基本要求来判断：</span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span><br><span style="font-size:14px;">1.&nbsp;缓存应足够大，以便能缓存所有被频繁访问的数据块。</span><span style="font-size:14px;">如果缓存过小，那么将导致磁盘I/0活动过多，因为频繁访问的数据块持续从磁盘读取，并由其他数据块使用和重写，然后再从磁盘读取。</span><br><span style="font-size:14px;">2.&nbsp;但也不能太大，以至于它会将极少被访问的块也一并加入到缓存中，这样会增长在缓存中搜索的时间。</span><br><br><span style="font-size:14px;">数据库缓冲区缓存在Instance启动时被分配。</span><span style="font-size:14px;">从数据库9i开始，可以随时将其调大或调小。</span><span style="font-size:14px;">可以采用手动方式重调，也可以根据工作负荷自动重调大小（事务）。</span><br><span style="font-size:14px;">修改缓冲区DB_CACHE_SIZE地方法：</span><br><br><span style="font-size:14px;"></span></p>
   <ul class="code-snippet__line-index code-snippet__js">
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
   </ul>
   <pre class="code-snippet__js"><code><span class="code-snippet_outer"><span class="code-snippet__comment">#Step1.&nbsp;查看SGA的大小：因为DB_CACHE_SIZE的size受SGA的影响</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">show parameter sga_max_size;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">NAME</span> <span class="code-snippet__string">TYPE VALUE</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">------------------------------------</span> <span class="code-snippet__string">----------- ------------------------------</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">sga_max_size</span> <span class="code-snippet__string">big integer 2G</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">#Step2. 查看show parameter shared_pool_size的大小</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">show parameter shared_pool_size; NAME TYPE VALUE</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">------------------------------------</span> <span class="code-snippet__string">----------- ------------------------------</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">shared_pool_size</span> <span class="code-snippet__string">big integer 0</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">#Step3.&nbsp;计算DB_CACHE_SIZE的大小：shared_pool_size&nbsp;+&nbsp;db_cache_size&nbsp;=&nbsp;SGA_MAX_SIZE&nbsp;*&nbsp;70%</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">#Step4. 修改DB_CACHE_SIZE的大小</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">alter system set db_cache_size=1433M scope=spfile sid='demo';</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">System</span> <span class="code-snippet__string">altered.</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">conn sys /as sysdba</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Enter</span> <span class="code-snippet__string">password:&nbsp;********</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Connected.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">shutdown immediate</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Database</span> <span class="code-snippet__string">closed.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Database</span> <span class="code-snippet__string">dismounted.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">ORACLE</span> <span class="code-snippet__string">instance shut down.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">startup</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">ORACLE</span> <span class="code-snippet__string">instance started.</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Total</span> <span class="code-snippet__string">System Global Area 2147483648 bytes</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Fixed</span> <span class="code-snippet__string">Size 2022144 bytes</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Variable</span> <span class="code-snippet__string">Size 503317760 bytes</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Database</span> <span class="code-snippet__string">Buffers 1627389952 bytes</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Redo</span> <span class="code-snippet__string">Buffers 14753792 bytes</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Database</span> <span class="code-snippet__string">mounted.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">Database</span> <span class="code-snippet__string">opened.</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">show parameter db_cache_size</span></span></code></pre>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">日志缓冲区</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">日志缓冲区是小型的、用于短期存储将写入到磁盘上的重做日志的变更向量的临时区域。</span><span style="font-size:14px;">主要作用是提供更加快的日志处理效率。</span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">共享池</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">共享池的大小也对性能产生重要影响:<br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span><br><span style="font-size:14px;">1.&nbsp;它应该足够大，以便缓存所有频繁执行的代码和频繁访问的对象定义。</span><span style="font-size:14px;">如果共享池过小，则性能下降，因为服务器会话将反复抢夺其中的空间来分析语句，此后，这些语句会被其他语句重写，在重新执行时，将不得不再次分析。</span><span style="font-size:14px;">如果共享池小于最优容量，则性能将下降。</span><span style="font-size:14px;">但有一个最小容量，如果低于此限度，则语句将失败。</span><br><span style="font-size:14px;">2.&nbsp;但也不能过大，以至于连仅执行一次的语句也要缓存。</span><span style="font-size:14px;">过大的共享池也会对性能产生不良影响，因为搜索需要的时间过长。</span><br><br><span style="font-size:14px;">确定最优容量是一个性能调整问题，大多数数据库都需要一个数百MB的共享池。</span><span style="font-size:14px;">有些应用程序需要1GB以上的共享池，但很少有应用程序能够在共享池小于100MB时充分运行。</span><span style="font-size:14px;">共享池内有下列三种数据结构：</span><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><span style="font-size:14px;"><br></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;"><span style="font-size:14px;">库缓冲：</span><span style="font-size:14px;">存储最近执行的代码</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">数据字典缓存：</span><span style="font-size:14px;">存储最近使用的对象定义</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;"><span style="font-size:14px;">PL/SQL缓冲区：</span><span style="font-size:14px;">存储的PL/SQL对象是过程、函数、打包的过程、打包的函数、对象类型定义和触发器。</span><br></p></li>
   </ul>
   <p style="margin-left:8px;"><br><span style="font-size:14px;">手动的调整共享池的大小：</span><br><br><span style="font-size:14px;"></span></p>
   <ul class="code-snippet__line-index code-snippet__js">
    <li></li>
    <li></li>
    <li></li>
   </ul>
   <pre class="code-snippet__js"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">select</span> COMPONENT,CURRENT_SIZE,MIN_SIZE,MAX_SIZE <span class="code-snippet__keyword">from</span> v$sga_dynamic_components; //显示可以动态重设大小的SGA组件的当前最大和最小容量</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">ALTER</span> <span class="code-snippet__keyword">SYSTEM</span> <span class="code-snippet__keyword">SET</span> SHARED_POOL_SIZE = <span class="code-snippet__number">110</span>M;</span></code></pre>
   <p style="margin-left:8px;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">其他结构</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">大型池——</span><span style="font-size:14px;">主要用途是供共享的服务器进程使用。</span><br><span style="font-size:14px;">JAVA池——</span><span style="font-size:14px;">只有当应用程序需要在数据库中运行java存储程序时，才需要java池。</span><br><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;"><strong><span style="font-size:14px;">进程结构</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">进程结构主要有后台进程和用户连接进程两大类。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">用户连接进程</span></strong><span style="font-size:14px;"></span><br></p>
   <p style="margin-left:8px;text-align:center;"><br><span style="font-size:14px;"><img style="width:443px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSicaaZ4icVAOrtSUlicf4K0EkGLVziaZTXewwicFaSKu6Cicen8NUKbjffPYg/640?wx_fmt=png" alt="640?wx_fmt=png"></span><br></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">用户连接进程是连接用户和Oracle&nbsp;Instance的桥梁。</span><span style="font-size:14px;">只有在User与Instance建立了连接以后，User才能够对Oracle&nbsp;Server进行操作。</span><br><br><span style="font-size:14px;">用户连接进程 = 用户进程 + 服务进程 + PGA</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">用户进程User Process</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">当一个Database&nbsp;User请求连接到Oracle&nbsp;Server时，Oracle&nbsp;Server会创建User&nbsp;Process。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><span style="font-size:14px;">User&nbsp;Process的作用：</span></p>
   <p style="margin-left:8px;text-align:left;"><br></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">为Database User与Server Process建立连接</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">并不会直接与Oracle Server交互</span><br></p></li>
   </ul>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">connect连接：</span><span style="font-size:14px;">是User和Server&nbsp;Process之间的通信通道。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><span style="font-size:14px;"><br></span></p>
   <p style="text-align:center;"><img class="rich_pages" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgS5fgULUibSb6YLfZ22IeXPd5notaZ1adiazWknnsiclOXwbey1w9dV21vQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><strong><span style="font-size:14px;">Server Process服务进程</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">用于处理Database&nbsp;User和Oracle&nbsp;Server之间的连接。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><span style="font-size:14px;">当一个User与User&nbsp;Process建立了一个connect后，Oracle&nbsp;Server会创建一个Server&nbsp;Process。</span><span style="font-size:14px;">然后再由User&nbsp;Process与Server&nbsp;Process建立了连接之后，Server&nbsp;Process会通过用户提交的请求信息来确定与oracle&nbsp;instance建立一个会话。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><span style="font-size:14px;">Server&nbsp;Process的作用：</span><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"><br></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">与Oracle Server直接交互</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">复制执行和返回结果</span><br></p></li>
   </ul>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">Session会话：</span><span style="font-size:14px;">一个用户通过User&nbsp;Process(本质是通过Server&nbsp;Process)与Oracle&nbsp;Instance建立连接后称之为一个会话，一个用户可以建立多个会话，即同时使用同一个用户可以多次的连接到同一个实例，也就是说多个session可以使用同一个connect。</span><br><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;text-align:center;"><img style="width:389px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgS5aVb553E6gZIpOAQfJU2iccfaapvoHQjh4TDgRt544nDVE9RY8YJxSA/640?wx_fmt=png" alt="640?wx_fmt=png"><br></p>
   <p style="margin-left:8px;text-align:left;"><br><strong><span style="font-size:14px;">程序全局区PGA</span></strong></p>
   <p style="margin-left:8px;text-align:center;"><strong><span style="font-size:14px;"></span></strong><span style="font-size:14px;"></span><br><span style="font-size:14px;"><img style="width:353px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSHSokGeEkRfMQCmiaoGl2syOs0rpzxic9J3jDONtResNySDHiacfXzHl1Q/640?wx_fmt=png" alt="640?wx_fmt=png"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><span style="font-size:14px;">PGA：</span><span style="font-size:14px;">Oracle&nbsp;Server&nbsp;Process分配来专门用于当前User&nbsp;Session的内存区。</span><span style="font-size:14px;">该区域是私有的，不同的用户拥有不同的PGA。</span><br><br><span style="font-size:14px;">PGA包含了Server&nbsp;Process数据和控制信息的内存区域。</span><span style="font-size:14px;">，由下列3个部分组成：</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><span style="font-size:14px;">1.&nbsp;栈空间：</span><span style="font-size:14px;">存储Session的变量、数组等的内存空间。</span><br><span style="font-size:14px;">2.&nbsp;Session&nbsp;Info：</span><span style="font-size:14px;">如果运行的不是多线程服务器，会话信息将保存在PGA中，如果是多线程服务器，则保存在SGA中。</span><br><span style="font-size:14px;">3.&nbsp;私有SQL区：</span><span style="font-size:14px;">用来保存绑定变量(binding&nbsp;variables)和运行时缓冲区(runtime&nbsp;buffers)等信息。</span><br><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><strong><span style="font-size:14px;">Oracle的connect连接和session会话与User Process紧密相关</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">注意：</span><span style="font-size:14px;">在RDBMS中由db\_name和instance\_name共同确定一个Database，所以Instance_name被用于Oracle与OS之间的联系同时也被用于Oracle&nbsp;Server与外部连接时使用。</span><br><br><span style="font-size:14px;">所以在User提交连接请求的时候，User&nbsp;Process首先会与Server&nbsp;Process建立Connect，然后Server&nbsp;Process会通过请求中所包含的db\_name和Instance\_name来确定需要且可以被连接的数据库(RDBMS可以存在多个数据库)，这样就确保了RDBMS在拥有多个数据库的情况下，还能够保证每一个Database的独立性。</span><span style="font-size:14px;">而且同一个Database可以被多个属于这个Databse的不同用户发起的Instance连接。</span><span style="font-size:14px;">这一个功能是非常有必要的，因为每一个不同的数据库中都包含有同名的sys、system等系统用户。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">后台进程</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">后台进程主要是完成数据库管理任务&nbsp;，后台进程是Oracle&nbsp;Instance和Oracle&nbsp;Database的联系纽带，分为核心进程和非核心进程。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><span style="font-size:14px;">1.&nbsp;核心进程：</span><span style="font-size:14px;">核心进程，必须存在，有一个终止，所有数据库进程全部终止，实例崩溃！</span><span style="font-size:14px;">其中五大进程全都是核心进程。</span><br><span style="font-size:14px;">2.&nbsp;非核心进程：</span><span style="font-size:14px;">完成数据库的额外功能，非核心进程死亡数据库不会崩溃！</span><br><br><strong><span style="font-size:14px;">常用的核心进程：</span></strong></p>
   <p style="margin-left:8px;text-align:left;"><strong><span style="font-size:14px;"></span></strong><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:center;"><span style="font-size:14px;"><img style="width:440px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgShuGhUwwrkqC3IGiaeH3f4NicVjvho0mxPJzyrTcx23Po0qEa290LP3Ew/640?wx_fmt=png" alt="640?wx_fmt=png"></span><br></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">在用户访问数据库时，首先会提交请求，再分配SGA内存，创建并启动后台进程和实例，最后建立连接和会话。</span><strong><span style="font-size:14px;">Oracle&nbsp;Server运行过程中必须启动上面的前五个进程。</span><span style="font-size:14px;"></span><span style="font-size:14px;">否则实例无法创建。</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">查看后台进程：</span><span style="font-size:14px;"></span><br><br><span style="font-size:14px;"></span></p>
   <ul class="code-snippet__line-index code-snippet__js">
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
   </ul>
   <pre class="code-snippet__js"><code><span class="code-snippet_outer"><span class="code-snippet__meta">SQL&gt;</span> <span class="code-snippet__string">select name,description from v$bgprocess where paddr&lt;&gt;'00';</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">NAME</span> <span class="code-snippet__string">DESCRIPTION</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">-----</span> <span class="code-snippet__string">----------------------------------------------------------------</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">PMON</span> <span class="code-snippet__string">process cleanup</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">PSP0</span> <span class="code-snippet__string">process spawner 0</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">MMAN</span> <span class="code-snippet__string">Memory Manager</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">DBW0</span> <span class="code-snippet__string">db writer process 0</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">LGWR</span> <span class="code-snippet__string">Redo etc.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">CKPT</span> <span class="code-snippet__string">checkpoint</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">SMON</span> <span class="code-snippet__string">System Monitor Process</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">RECO</span> <span class="code-snippet__string">distributed recovery</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">CJQ0</span> <span class="code-snippet__string">Job Queue Coordinator</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">QMNC</span> <span class="code-snippet__string">AQ Coordinator</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">MMON</span> <span class="code-snippet__string">Manageability Monitor Process</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">NAME</span> <span class="code-snippet__string">DESCRIPTION</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">-----</span> <span class="code-snippet__string">----------------------------------------------------------------</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__attr">MMNL</span> <span class="code-snippet__string">Manageability Monitor Process 2</span></span></code></pre>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">数据库写入进程（DBWn）</span></strong><span style="font-size:14px;"></span><br></p>
   <p style="margin-left:8px;text-align:center;"><br><strong><span style="font-size:14px;"><img style="width:181px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgS5Onyx47PicUF9mjxjOB1opdbHFpeHDs3TDlokUY1QYAUNtdmm6KDSug/640?wx_fmt=png" alt="640?wx_fmt=png"></span></strong><span style="font-size:14px;"></span><br></p>
   <p style="margin-left:8px;text-align:left;"><br></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">Server process连接Oracle后，通过数据库写进程(DBWn)将数据缓冲区中的“脏缓冲区”的数据块写入到存储结构（数据文件、磁盘文件）</span><br><br><span style="font-size:14px;">Database&nbsp;writer&nbsp;(DBWn)数据库写进程：<br></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"><br></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">只做一件事，将数据写到磁盘。</span><span style="font-size:14px;">就是将数据库的变化写入到数据文件。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">该进程最多20&nbsp;个，即使你有36&nbsp;个CPU&nbsp;也只能最多有20&nbsp;个数据库写进程。</span><br><span style="font-size:14px;">进程名称DBW0-DBW9 DBWa-DBWj</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">注意：</span><span style="font-size:14px;">数据库写进程越多，写数据的效率越高。</span><span style="font-size:14px;">该进程的个数应该和cpu的个数对应，如果设置的数据库写进程数大于CPU&nbsp;的个数也不会有太明显的效果，因为CPU&nbsp;是分时的。</span><br></p></li>
   </ul>
   <p style="margin-left:8px;text-align:left;"><br><strong><span style="font-size:14px;">检查点(CKPT)</span></strong><span style="font-size:14px;"></span><br></p>
   <p style="margin-left:8px;text-align:center;"><br><span style="font-size:14px;"><img style="width:347px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSXPQ3A9Lj3rjT8tVUVbDV011xVcX5fYLTaEuokljiboRwUibKqTUVn5iaQ/640?wx_fmt=png" alt="640?wx_fmt=png"></span><br></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">Checkpoint&nbsp;(CKPT)检查点进程：</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">主要用户更新数据文件头，更新控制文件和触发DBWn数据库写进程。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">Ckpt&nbsp;进程会降低数据库性能，但是提高数据库崩溃时，自我恢复的性能。</span><span style="font-size:14px;">我们可以理解为阶段性的保存数据，一定的条件满足就触发，执行DBWn存盘操作。<br></span></p></li>
   </ul>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">进程监视进程（PMON）</span></strong></p>
   <p style="margin-left:8px;text-align:left;"><br><strong><span style="font-size:14px;"></span></strong><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;text-align:center;"><span style="font-size:14px;"><img style="width:403px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSORh7iaYvNbzon6PXia2t9sIegAHIibGII19BmMukosQKib8kZCXcpZEIsQ/640?wx_fmt=png" alt="640?wx_fmt=png"></span><br></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">Process&nbsp;monitor（PMON）进程监测进程：</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><span style="font-size:14px;">PMON在后台进程执行失败后负责清理数据库缓存和闲置资源，是Oracle的自动维护机制。</span><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"><br></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">清除死进程</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">重新启动部分进程（如调度进程）</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">监听的自动注册</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">回滚事务</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">释放锁</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">释放其他资</span><br></p></li>
   </ul>
   <p style="margin-left:8px;text-align:left;"><br><strong><span style="font-size:14px;">系统监视进程（SMON）</span></strong><span style="font-size:14px;"></span><br></p>
   <p style="margin-left:8px;text-align:center;"><br><span style="font-size:14px;"><img style="width:203px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSgHHKQqGAfABrrib1Smnxiarm16nw59wwzibVnYuTtAwHP3CgX8cmhJbjw/640?wx_fmt=png" alt="640?wx_fmt=png"></span><br></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">System&nbsp;monitor&nbsp;(SMON)系统监测进程：</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">SMON启动后会自动的用于在实例崩溃时进行数据库实例自动恢复。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">清除作废的排序临时段，回收整理碎片，合并空闲空间，释放临时段，维护闪回的时间点。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">在老数据库版本中，当我们大量删除表的时候，会观测到SMON进程很忙，直到把所有的碎片空间都整理完毕。</span><br></p></li>
   </ul>
   <p style="margin-left:8px;text-align:left;"><br><strong><span style="font-size:14px;">重做日志文件和日志写入进程</span></strong><span style="font-size:14px;"></span><br></p>
   <p style="margin-left:8px;text-align:center;"><br><span style="font-size:14px;"><img style="width:240px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSpgl6Qfa1L0SPiaUtmFgDf8NKdbiarPZcN1Dv0W3y3ZGr3ibb8YTEHvs6g/640?wx_fmt=png" alt="640?wx_fmt=png"></span><br></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">主要用于记录数据库的改变和记录数据库被改变之前的原始状态，所以应当对其作多重备份，用于恢复和排错。</span><br><br><span style="font-size:14px;">激活LGWR的情况：</span><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"><br></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">提交指令</span><span style="font-size:14px;"><br></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">日志缓冲区超过1/3</span><span style="font-size:14px;"><br></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">每三秒</span><span style="font-size:14px;"><br></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">每次DBWn执行之前</span><br></p></li>
   </ul>
   <p style="margin-left:8px;text-align:left;"><br><strong><span style="font-size:14px;">归档进程（ARCn）</span></strong><span style="font-size:14px;">——是非核心进程。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br></p>
   <p style="margin-left:8px;text-align:center;"><img title="" style="width:348px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSWw3asAXUnSnyZhJicqmHhuPq2QRhWyda7JtFeUIGqyGmka38n4fvJcA/640?wx_fmt=png" alt="640?wx_fmt=png"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><br><strong><span style="font-size:14px;">存储结构</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">Oracle&nbsp;RDBMS存储结构主要由Database组成。</span><br></p>
   <p style="margin-left:8px;text-align:center;"><br><span style="font-size:14px;"><img style="width:377px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSatV4dmGT8hudMTAm4TCSa5Wbo4OX7Ibcmujz6LBO6zibeJWJ7NE1KxQ/640?wx_fmt=png" alt="640?wx_fmt=png"></span><br></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">又能够将Database分为物理结构和逻辑结构来理解。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">物理结构</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">Database物理结构：</span><span style="font-size:14px;">是Database在操作系统中的文件集合，即：</span><span style="font-size:14px;">磁盘上的物理文件，主要由数据文件、控制文件、重做日志文件、归档日志文件、参数文件、口令文件组成。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">Data Files</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">数据文件是数据的存储仓库：<br></span></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">• 包括所有的数据库数据</span><br><span style="font-size:14px;">• 只能属于一个数据库</span><br><span style="font-size:14px;">• 来自于被称为”表空间”的数据库存储逻辑单元</span><br><span style="font-size:14px;">•&nbsp;可以直接被读进内存，在执行SQL语句的时候，会将相关的数据文件副本加载如数据缓冲区。</span><br><span style="font-size:14px;">• 通过备份策略可以使数据文件得到保护</span><br><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><strong><span style="font-size:14px;">Redo Log Files</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">重做日志文件包含对数据库所做的更改操作记录，在Oracle发生故障时能够恢复数据。</span><br><span style="font-size:14px;">能够恢复数据的原理：</span><span style="font-size:14px;">重做日志文件会按时间的顺序，将应用于数据库的一连串的变更向量(做了什么操作)存储起来(即将变更的地方标记起来)。</span><span style="font-size:14px;">其中包含了所有已经完成操作的信息和完成操作之前的数据库状态。</span><span style="font-size:14px;">如果数据文件受损，就可以将这些变更向量应用于数据文件备份来进行重做(重建)工作，将它恢复到发生故障的那一刻前的状态。</span><span style="font-size:14px;">重做日志文件又分为下面两种类型：</span><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"><br></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">联机重做日志文件：</span><span style="font-size:14px;">记录连续的数据库操作</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">归档日志文件Archived&nbsp;Log&nbsp;Files：</span><span style="font-size:14px;">用于时间点恢复，当RedoLogFiles存满时，会对这些日志进行归档备份，以便以后还原数据时使用。</span><span style="font-size:14px;"></span></p>
     <ul style="list-style-type:disc;" class="list-paddingleft-2">
      <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">查看redo&nbsp;log&nbsp;info：</span><br></p></li>
     </ul></li>
   </ul>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;"></span></p>
   <ul class="code-snippet__line-index code-snippet__js">
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
   </ul>
   <pre class="code-snippet__js"><code><span class="code-snippet_outer">SQL&gt; select member from v$logfile; <span class="code-snippet__meta"># v$logfile数据字典，记录了redolog文件的列表</span></span></code><code><span class="code-snippet_outer"> MEMBER</span></code><code><span class="code-snippet_outer">--------------------------------------------------------------------------------</span></code><code><span class="code-snippet_outer"> /u01/oradata/demo/redo03.<span class="code-snippet__built_in">log</span></span></code><code><span class="code-snippet_outer"> /u01/oradata/demo/redo02.<span class="code-snippet__built_in">log</span></span></code><code><span class="code-snippet_outer"> /u01/oradata/demo/redo01.<span class="code-snippet__built_in">log</span></span></code></pre>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">Control Files</span></strong></p>
   <p style="margin-left:8px;text-align:left;"><strong><span style="font-size:14px;"><br></span></strong></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">控制文件包含维护和验证数据库完整性的必要的信息。</span><br><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">它记录了联机重做日志文件、数据文件的位置、更新的归档日志文件的位置。</span><span style="font-size:14px;">它还存储着维护数据库完整性所需的信息，如数据库名。</span><span style="font-size:14px;">控制文件是以二进制型式存储的，用户无法修改控制文件的内容。</span><span style="font-size:14px;">控制文件不过数MB，却起着至关重要的作用。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">Parameter File</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">实例参数文件，当启动oracle实例时，SGA结构会根据此参数文件的设置内存，后台进程会据此启动。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">Password File</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">用户通过提交username/password来建立会话，Oracle根据存储在数据字典的用户定义对用户名和口令进行验证。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">逻辑结构</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">表空间就是典型的Oracle逻辑结构类型&nbsp;——&nbsp;里面存放着若干的数据文件。<br></span></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">表空间：</span><span style="font-size:14px;">用于存储数据库对象的逻辑空间，表空间是在数据库中开辟的一个空间，用于存放数据库的对象，它是信息存储的最大逻辑单位，是存放数据库文件的地方，其中数据又被存放在表空间中的数据文件中。</span><span style="font-size:14px;">一个数据库可以由多个表空间组成，Oracle的调优就是通过表空间来实现的。</span><span style="font-size:14px;">（Oracle数据库独特的高级应用）</span><br><br><strong><span style="font-size:14px;">表空间的作用：</span></strong><span style="font-size:14px;"></span><span style="font-size:14px;">分类管理、批量处理；</span><span style="font-size:14px;">&nbsp;将琐碎的磁盘文件整合、抽象处理成为逻辑结构。</span><span style="font-size:14px;">这样更加便于我们去管理数据库。</span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br><strong><span style="font-size:14px;">逻辑空间到物理空间的映射</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">段、区和块：</span><br></p>
   <p style="margin-left:8px;text-align:center;"><br><span style="font-size:14px;"><img style="width:364px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSyXsPS1uyZBxcreMHoT9x7oZTFwcATwZwIInvSzAzCAxn2XAFQjG19A/640?wx_fmt=png" alt="640?wx_fmt=png"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">执行一条写入的SQL语句时在RDBMS中都发生了什么</span><br></p>
   <p style="margin-left:8px;text-align:left;"><br></p>
   <p style="margin-left:8px;text-align:center;"><img style="width:342px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSIC40DtNvLyy5MeicNcqs3zHlZVFEncic2pDzialk3UM5ozfYXFiawU8c5A/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="margin-left:8px;text-align:left;"><br><span style="font-size:14px;">1. 将SQL语句加载入数据库缓冲区</span><br><span style="font-size:14px;">2. 将SQL语句要操作的数据文件副本加载入数据库缓冲区</span><br><span style="font-size:14px;">3. 执行SQL语句，修改数据文件副本，形成“脏缓冲区”</span><br><span style="font-size:14px;">4. CKPT检测到“脏缓冲区”，调用DBWn</span><br><span style="font-size:14px;">5. 在DBWn运行之前，先运行了LGWR，将数据文件的原始状态和数据库的改变记录到Redo Log Files</span><br><span style="font-size:14px;">6. 运行DBWn，将“脏缓冲区的内容写入到数据文件”</span><br><span style="font-size:14px;">7. 同时CKPT修改控制文件和数据文件头</span><br><span style="font-size:14px;">8. SMON回收不必要的空闲资源</span><br><span style="font-size:14px;"><br></span></p>
   <p style="margin-left:8px;text-align:left;"><strong><span style="font-size:14px;">最后</span></strong><span style="font-size:14px;"></span><br><br><span style="font-size:14px;">最后我们举个例子来看看Oracle RDBMS是怎么运作的</span><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;text-align:left;"><span style="font-size:14px;"></span><br></p>
   <p style="margin-left:8px;text-align:center;"><img style="width:366px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSiadfSNTFtCnxlnrpggIjrZDVd5Rkg6BHDx2ZLWD4ibX6ricAK6meodSrw/640?wx_fmt=png" alt="640?wx_fmt=png"><span style="font-size:14px;"></span></p>
   <p style="margin-left:8px;text-align:center;"><span style="font-size:14px;"></span><img style="width:364px;" title="" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/bURPjgFpGMTJIU8McCiakuxWGXakp3xgSMXKghY88VBxF3rWnSeJRUjKBVz6XuGoYMovxVg0bpia1NBsFkNS0dWQ/640?wx_fmt=png" alt="640?wx_fmt=png"><br><span style="font-size:14px;"><br></span></p>
   <ul style="list-style-type:circle;" class="list-paddingleft-2">
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">User访问Oracle&nbsp;Server之前提交一个请求(包含了db_name、instance_name、username、password等信息)，Oracle&nbsp;Server接收到请求并通过Password&nbsp;File的验证后，分配SGA内存池，启动后台进程同时创建并启动实例。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">在启动实例之后User&nbsp;Process与Server&nbsp;Process建立Connect。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">再通过Server&nbsp;process和Oracle&nbsp;Instance完成建立Sesscion。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">用户执行SQL语句，由server&nbsp;process接收到并直接与Oracle交互。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">SQL语句通过Server&nbsp;Process到达Oracle&nbsp;Instance，再将SQL载入数据库缓冲区。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">Server&nbsp;Process通知Oracle&nbsp;Database将与SQL语句相关的数据块副本加载到缓冲区中。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">在数据库缓存区执行SQL语句，并产生”脏缓冲区”。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">由CKPT检查点进程检查到”脏缓冲区”，并调用DBWn数据库写进程，但在DBWn执行之前，应该由LGWR先将数据文件的原始状态、数据库的改变等信息记录到Redo&nbsp;Log&nbsp;Files。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">将更新的内容写入到磁盘中的数据文件。</span><span style="font-size:14px;"></span></p></li>
    <li><p style="margin-left:8px;text-align:left;"><span style="font-size:14px;">返回结果给用户</span><br></p></li>
   </ul>
   <p><br></p>
   <hr style="border-style:solid;border-right-width:0px;border-bottom-width:0px;border-left-width:0px;border-color:rgba(0,0,0,.1);">
   <p><span style="font-size:15px;">资源下载</span></p>
   <p style="margin-left:8px;font-size:1em;line-height:1.75em;"><span style="font-size:15px;letter-spacing:.5px;">关注公众号：数据和云（</span><span style="font-size:15px;letter-spacing:.5px;color:rgb(255,0,0);">OraNews</span><span style="font-size:15px;letter-spacing:.5px;">）回复关键字获取</span></p>
   <p style="margin-left:8px;font-size:1em;line-height:normal;"><span style="font-size:12px;color:rgb(255,0,0);"><strong><span style="letter-spacing:.5px;"><strong style="color:rgb(62,62,62);"><span>2018DTCC ，</span></strong><span style="color:rgb(62,62,62);">数据库大会PPT</span></span></strong></span></p>
   <p style="margin-left:8px;font-size:1em;line-height:normal;"><span style="font-size:12px;color:rgb(0,0,0);"><strong><span style="letter-spacing:.5px;">2018DTC</span></strong></span><span style="font-size:12px;letter-spacing:.5px;">，2018 DTC 大会 PPT<br></span></p>
   <p style="margin-left:8px;font-size:1em;line-height:normal;"><span style="font-size:12px;color:rgb(255,76,65);"><strong><span style="letter-spacing:.5px;">ENMOBK</span></strong></span><span style="color:rgb(0,0,0);font-size:12px;letter-spacing:.5px;">，</span><span style="letter-spacing:.5px;font-size:12px;">《Oracle性能优化与诊断案例》</span></p>
   <p style="margin-left:8px;font-size:1em;line-height:normal;"><span style="font-size:12px;"><strong><span style="letter-spacing:.5px;">DBALIFE&nbsp;</span></strong><span style="letter-spacing:.5px;">，“DBA 的一天”海报</span></span><br></p>
   <p style="margin-left:8px;line-height:normal;"><span style="font-size:12px;"><strong><span style="letter-spacing:.5px;">DBA04&nbsp;</span></strong><span style="letter-spacing:.5px;">，DBA 手记4 电子书</span></span></p>
   <p style="margin-left:8px;font-size:1em;line-height:normal;"><span style="font-size:14px;"><strong><span style="font-size:12px;letter-spacing:.5px;">122ARCH&nbsp;</span></strong><span style="font-size:12px;letter-spacing:.5px;">，Oracle 12.2体系结构图</span><br></span></p>
   <p style="margin-left:8px;font-size:1em;line-height:normal;"><span style="font-size:12px;"><strong><span style="letter-spacing:.5px;">2018OOW&nbsp;</span></strong><span style="letter-spacing:.5px;">，Oracle OpenWorld 资料</span></span></p>
   <p><strong><span style="font-size:16px;color:rgb(141,203,191);">云和恩墨大讲堂 |&nbsp;</span></strong><span style="font-size:16px;color:rgb(141,203,191);">一个分享交流的地方</span></p>
   <p style="min-height:1em;"><span style="font-size:14px;color:rgb(141,203,191);">长按，识别二维码，加入<strong>万人</strong>交流社群</span></p>
   <p style="min-height:1em;"><br></p>
   <strong><img title="1554967458100199.jpg" style="border-width:1px;border-style:dashed;border-color:rgb(168,164,171);" border="0" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/bURPjgFpGMRH6Oo80K5RMZlLa2na8UwTWAWf37k1ln6kHpZ1lr6KnchTRric4Z3LgbpUic92MlsIka5p0LhG63icg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></strong>
   <p style="color:rgb(35,21,10);font-size:medium;min-height:1em;"><span style="font-size:12px;"><strong><span style="color:rgb(141,203,191);">请备注：云和恩墨大讲堂</span></strong></span></p>
  </div> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
