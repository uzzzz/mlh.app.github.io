<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>AMCL中似然场模型相关代码 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="AMCL中似然场模型相关代码" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="首先，我们要先了解四类测量误差：小的测量噪声、意外对象引起的误差，以及由于未检测到对象引起的误差和随机意外噪声。 a.小的测量噪声 即使传感器正确测量了最近对象的距离，它返回的值也受到误差的影响。该误差由测距传感器的有限分辨率、大气 对测量信号的影响等引起，呈高斯分布 b.意外对象引起的误差这种情况下测量距离的概率用指数分布来描述，这里不多讲解，因为似然域未用到。 c.由于未检测到对象引起的误差（检测失败）。 声呐传感器遇到镜面反射/激光测距时检测到黑色吸光对象/激光系统在强光下测量时会发生检测失败，但最典型的是最大距离测量问题：传感器返回它的最大允许值Z_max。 d.随机意外噪声 LikelihoodFieldModel 该模型的作用是：遍历粒子更新概率，计算所有粒子概率的总和。 double AMCLLaser::LikelihoodFieldModel(AMCLLaserData *data, pf_sample_set_t* set) { AMCLLaser *self; int i, j, step; double z, pz; double p; double obs_range, obs_bearing; double total_weight; pf_sample_t *sample; pf_vector_t pose; pf_vector_t hit; self = (AMCLLaser*) data-&gt;sensor; total_weight = 0.0; // Compute the sample weights for (j = 0; j &lt; set-&gt;sample_count; j++) { sample = set-&gt;samples + j; pose = sample-&gt;pose; // Take account of the laser pose relative to the robot pose = pf_vector_coord_add(self-&gt;laser_pose, pose);//激光雷达的位姿转换到世界坐标系 p = 1.0; // Pre-compute a couple of things double z_hit_denom = 2 * self-&gt;sigma_hit * self-&gt;sigma_hit;//测量噪声的方差 double z_rand_mult = 1.0/data-&gt;range_max;//无法解释的随机测量的分母 step = (data-&gt;range_count - 1) / (self-&gt;max_beams - 1);//计算步长 只取一组数据中的max_beams个点 // Step size must be at least 1 if(step &lt; 1) step = 1; for (i = 0; i &lt; data-&gt;range_count; i += step) { obs_range = data-&gt;ranges[i][0];//观测到的距离 Z(k,t） obs_bearing = data-&gt;ranges[i][1];//θ_k,sense // This model ignores max range readings //如果obs_range &gt; data-&gt;range_max 则结束跳过以下更新（即：如果测距传感器输出了最大值z(k,t)= Z_max，则这些坐标在物理世界没有任何意义 //似然域测量模型简单地将大于最大距离的读数丢弃） if(obs_range &gt;= data-&gt;range_max) continue; // Check for NaN if(obs_range != obs_range) continue; pz = 0.0; // Compute the endpoint of the beam计算激光雷达点最远端的世界坐标 hit.v[0] = pose.v[0] + obs_range * cos(pose.v[2] + obs_bearing); hit.v[1] = pose.v[1] + obs_range * sin(pose.v[2] + obs_bearing); // Convert to map grid coords.转换到栅格坐标 int mi, mj; mi = MAP_GXWX(self-&gt;map, hit.v[0]); mj = MAP_GYWY(self-&gt;map, hit.v[1]); // Part 1: Get distance from the hit to closest obstacle. // Off-map penalized as max distance if(!MAP_VALID(self-&gt;map, mi, mj)) //Test to see if the given map coords lie within the absolute map bounds. z = self-&gt;map-&gt;max_occ_dist; else z = self-&gt;map-&gt;cells[MAP_INDEX(self-&gt;map,mi,mj)].occ_dist; // Gaussian model // NOTE: this should have a normalization of 1/(sqrt(2pi)*sigma) pz += self-&gt;z_hit * exp(-(z * z) / z_hit_denom); // Part 2: random measurements pz += self-&gt;z_rand * z_rand_mult; // TODO: outlier rejection for short readings assert(pz &lt;= 1.0); assert(pz &gt;= 0.0); // p *= pz; // here we have an ad-hoc weighting scheme for combining beam probs // works well, though... p += pz*pz*pz; } sample-&gt;weight *= p; total_weight += sample-&gt;weight; } return(total_weight); } 对于最后的几行代码，在程序6.3中第7行 q 即p p += pz*pz*pz; sample-&gt;weight *= p; total_weight += sample-&gt;weight; 也有人在ros wiki上提了问 并未得到回答 以及在开源项目下也有人提出对应的是否经过成熟测试的质疑 laser model 质疑 LikelihoodFieldModelProb double AMCLLaser::LikelihoodFieldModelProb(AMCLLaserData *data, pf_sample_set_t* set) { AMCLLaser *self; int i, j, step; double z, pz; double log_p; double obs_range, obs_bearing; double total_weight; pf_sample_t *sample; pf_vector_t pose; pf_vector_t hit; self = (AMCLLaser*) data-&gt;sensor; total_weight = 0.0; step = ceil((data-&gt;range_count) / static_cast&lt;double&gt;(self-&gt;max_beams)); // Step size must be at least 1 if(step &lt; 1) step = 1; // Pre-compute a couple of things double z_hit_denom = 2 * self-&gt;sigma_hit * self-&gt;sigma_hit; double z_rand_mult = 1.0/data-&gt;range_max; double max_dist_prob = exp(-(self-&gt;map-&gt;max_occ_dist * self-&gt;map-&gt;max_occ_dist) / z_hit_denom);//指数项 //Beam skipping - ignores beams for which a majoirty of particles do not agree with the map //prevents correct particles from getting down weighted because of unexpected obstacles //such as humans bool do_beamskip = self-&gt;do_beamskip; double beam_skip_distance = self-&gt;beam_skip_distance; double beam_skip_threshold = self-&gt;beam_skip_threshold; //we only do beam skipping if the filter has converged 只有当滤波器收敛时，我们才跳过光束 if(do_beamskip &amp;&amp; !set-&gt;converged){ do_beamskip = false; } //we need a count the no of particles for which the beam agreed with the map 我们需要计算测量数据与地图一致的粒子的数目 int *obs_count = new int[self-&gt;max_beams](); //we also need a mask of which observations to integrate (to decide which beams to integrate to all particles) //我们还需要一个obs_mask来合并观测结果(以决定哪些测量数据要整合到所有粒子中)。 bool *obs_mask = new bool[self-&gt;max_beams](); int beam_ind = 0; //realloc indicates if we need to reallocate the temp data structure needed to do beamskipping //realloc表示是否需要重新分配需要被跳过的临时数据。 bool realloc = false; if(do_beamskip){ if(self-&gt;max_obs &lt; self-&gt;max_beams){ realloc = true; } if(self-&gt;max_samples &lt; set-&gt;sample_count){ realloc = true; } if(realloc){ self-&gt;reallocTempData(set-&gt;sample_count, self-&gt;max_beams); fprintf(stderr, &quot;Reallocing temp weights %d - %d\n&quot;, self-&gt;max_samples, self-&gt;max_obs); } } // Compute the sample weights for (j = 0; j &lt; set-&gt;sample_count; j++) { sample = set-&gt;samples + j; pose = sample-&gt;pose; // Take account of the laser pose relative to the robot pose = pf_vector_coord_add(self-&gt;laser_pose, pose); log_p = 0; beam_ind = 0; for (i = 0; i &lt; data-&gt;range_count; i += step, beam_ind++) { obs_range = data-&gt;ranges[i][0]; obs_bearing = data-&gt;ranges[i][1]; // This model ignores max range readings if(obs_range &gt;= data-&gt;range_max){ continue; } // Check for NaN if(obs_range != obs_range){ continue; } pz = 0.0; // Compute the endpoint of the beam hit.v[0] = pose.v[0] + obs_range * cos(pose.v[2] + obs_bearing); hit.v[1] = pose.v[1] + obs_range * sin(pose.v[2] + obs_bearing); // Convert to map grid coords. int mi, mj; mi = MAP_GXWX(self-&gt;map, hit.v[0]); mj = MAP_GYWY(self-&gt;map, hit.v[1]); // Part 1: Get distance from the hit to closest obstacle. // Off-map penalized as max distance if(!MAP_VALID(self-&gt;map, mi, mj)){ pz += self-&gt;z_hit * max_dist_prob; } else{ z = self-&gt;map-&gt;cells[MAP_INDEX(self-&gt;map,mi,mj)].occ_dist; if(z &lt; beam_skip_distance){ obs_count[beam_ind] += 1;//用于判断这个方向的点是否用来计算概率和 } pz += self-&gt;z_hit * exp(-(z * z) / z_hit_denom); } // Gaussian model // NOTE: this should have a normalization of 1/(sqrt(2pi)*sigma) // Part 2: random measurements pz += self-&gt;z_rand * z_rand_mult; assert(pz &lt;= 1.0); assert(pz &gt;= 0.0); 到此为止计算基本一样，只是加了部分的beamskip和reallocate。 其中reallocTempData函数用于： void AMCLLaser::reallocTempData(int new_max_samples, int new_max_obs){ if(temp_obs){ for(int k=0; k &lt; max_samples; k++){ delete [] temp_obs[k]; } delete []temp_obs; } max_obs = new_max_obs; max_samples = fmax(max_samples, new_max_samples); temp_obs = new double*[max_samples](); for(int k=0; k &lt; max_samples; k++){ temp_obs[k] = new double[max_obs](); } } 如果do_beamskip的话，用self-&gt;temp_obs[j][beam_ind] 保存概率。 // TODO: outlier rejection for short readings if(!do_beamskip){ log_p += log(pz); } else{ self-&gt;temp_obs[j][beam_ind] = pz; } } if(!do_beamskip){ sample-&gt;weight *= exp(log_p); total_weight += sample-&gt;weight; } } if(!do_beamskip) 则计算的 sample-&gt;weight total_weight 和书上一样 注意此部分计算还是在j &lt; set-&gt;sample_count的循环中。而do_beamskip的话，概率的计算如下： if(do_beamskip) { int skipped_beam_count = 0; //某个角度下z &lt; beam_skip_distance的点的个数/帧数&gt;beam_skip_threshold时obs_mask[beam_ind] = true; //某个角度下z &lt; beam_skip_distance的点的个数/帧数&lt;beam_skip_threshold时obs_mask[beam_ind] = false，该点不用于计算概率和，但是如果这样的点多了，说明收敛到了一个错误的位姿，则所有的点都用来计算概率和 for (beam_ind = 0; beam_ind &lt; self-&gt;max_beams; beam_ind++) { if((obs_count[beam_ind] / static_cast&lt;double&gt;(set-&gt;sample_count)) &gt; beam_skip_threshold) { obs_mask[beam_ind] = true; } else { obs_mask[beam_ind] = false; skipped_beam_count++; } } //we check if there is at least a critical number of beams that agreed with the map //otherwise it probably indicates that the filter converged to a wrong solution //if that&#39;s the case we integrate all the beams and hope the filter might converge to //the right solution bool error = false; //如果skipped_beam_count/beam_ind &gt;= beam_skip_error_threshold 则收敛到一个错误的位姿 //beam_ind为一振数据中采样个数 if(skipped_beam_count &gt;= (beam_ind * self-&gt;beam_skip_error_threshold)){ fprintf(stderr, &quot;Over %f%% of the observations were not in the map - pf may have converged to wrong pose - integrating all observations\n&quot;, (100 * self-&gt;beam_skip_error_threshold)); error = true; } for (j = 0; j &lt; set-&gt;sample_count; j++) { sample = set-&gt;samples + j; pose = sample-&gt;pose; log_p = 0; //如果z &lt; beam_skip_distance或者收敛到一个错误位姿 则被用于计算概率和 for (beam_ind = 0; beam_ind &lt; self-&gt;max_beams; beam_ind++){ if(error || obs_mask[beam_ind]){ log_p += log(self-&gt;temp_obs[j][beam_ind]); } } sample-&gt;weight *= exp(log_p); total_weight += sample-&gt;weight; } } delete [] obs_count; delete [] obs_mask; return(total_weight); } 待解决的问题： prob模型是检查某一个的角度的异常值，那么速度快/转弯时的检测应该是有问题的吧 另外对以下代码也有疑惑 // Update the cspace distance values void map_update_cspace(map_t *map, double max_occ_dist) { unsigned char* marked; std::priority_queue&lt;CellData&gt; Q; marked = new unsigned char[map-&gt;size_x*map-&gt;size_y]; memset(marked, 0, sizeof(unsigned char) * map-&gt;size_x*map-&gt;size_y); map-&gt;max_occ_dist = max_occ_dist; CachedDistanceMap* cdm = get_distance_map(map-&gt;scale, map-&gt;max_occ_dist); // Enqueue all the obstacle cells CellData cell; cell.map_ = map; for(int i=0; i&lt;map-&gt;size_x; i++) { cell.src_i_ = cell.i_ = i; for(int j=0; j&lt;map-&gt;size_y; j++) { if(map-&gt;cells[MAP_INDEX(map, i, j)].occ_state == +1) { map-&gt;cells[MAP_INDEX(map, i, j)].occ_dist = 0.0; cell.src_j_ = cell.j_ = j; marked[MAP_INDEX(map, i, j)] = 1; Q.push(cell); } else map-&gt;cells[MAP_INDEX(map, i, j)].occ_dist = max_occ_dist; } } while(!Q.empty()) { CellData current_cell = Q.top(); if(current_cell.i_ &gt; 0) enqueue(map, current_cell.i_-1, current_cell.j_, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); if(current_cell.j_ &gt; 0) enqueue(map, current_cell.i_, current_cell.j_-1, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); if((int)current_cell.i_ &lt; map-&gt;size_x - 1) enqueue(map, current_cell.i_+1, current_cell.j_, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); if((int)current_cell.j_ &lt; map-&gt;size_y - 1) enqueue(map, current_cell.i_, current_cell.j_+1, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); Q.pop(); } delete[] marked; }" />
<meta property="og:description" content="首先，我们要先了解四类测量误差：小的测量噪声、意外对象引起的误差，以及由于未检测到对象引起的误差和随机意外噪声。 a.小的测量噪声 即使传感器正确测量了最近对象的距离，它返回的值也受到误差的影响。该误差由测距传感器的有限分辨率、大气 对测量信号的影响等引起，呈高斯分布 b.意外对象引起的误差这种情况下测量距离的概率用指数分布来描述，这里不多讲解，因为似然域未用到。 c.由于未检测到对象引起的误差（检测失败）。 声呐传感器遇到镜面反射/激光测距时检测到黑色吸光对象/激光系统在强光下测量时会发生检测失败，但最典型的是最大距离测量问题：传感器返回它的最大允许值Z_max。 d.随机意外噪声 LikelihoodFieldModel 该模型的作用是：遍历粒子更新概率，计算所有粒子概率的总和。 double AMCLLaser::LikelihoodFieldModel(AMCLLaserData *data, pf_sample_set_t* set) { AMCLLaser *self; int i, j, step; double z, pz; double p; double obs_range, obs_bearing; double total_weight; pf_sample_t *sample; pf_vector_t pose; pf_vector_t hit; self = (AMCLLaser*) data-&gt;sensor; total_weight = 0.0; // Compute the sample weights for (j = 0; j &lt; set-&gt;sample_count; j++) { sample = set-&gt;samples + j; pose = sample-&gt;pose; // Take account of the laser pose relative to the robot pose = pf_vector_coord_add(self-&gt;laser_pose, pose);//激光雷达的位姿转换到世界坐标系 p = 1.0; // Pre-compute a couple of things double z_hit_denom = 2 * self-&gt;sigma_hit * self-&gt;sigma_hit;//测量噪声的方差 double z_rand_mult = 1.0/data-&gt;range_max;//无法解释的随机测量的分母 step = (data-&gt;range_count - 1) / (self-&gt;max_beams - 1);//计算步长 只取一组数据中的max_beams个点 // Step size must be at least 1 if(step &lt; 1) step = 1; for (i = 0; i &lt; data-&gt;range_count; i += step) { obs_range = data-&gt;ranges[i][0];//观测到的距离 Z(k,t） obs_bearing = data-&gt;ranges[i][1];//θ_k,sense // This model ignores max range readings //如果obs_range &gt; data-&gt;range_max 则结束跳过以下更新（即：如果测距传感器输出了最大值z(k,t)= Z_max，则这些坐标在物理世界没有任何意义 //似然域测量模型简单地将大于最大距离的读数丢弃） if(obs_range &gt;= data-&gt;range_max) continue; // Check for NaN if(obs_range != obs_range) continue; pz = 0.0; // Compute the endpoint of the beam计算激光雷达点最远端的世界坐标 hit.v[0] = pose.v[0] + obs_range * cos(pose.v[2] + obs_bearing); hit.v[1] = pose.v[1] + obs_range * sin(pose.v[2] + obs_bearing); // Convert to map grid coords.转换到栅格坐标 int mi, mj; mi = MAP_GXWX(self-&gt;map, hit.v[0]); mj = MAP_GYWY(self-&gt;map, hit.v[1]); // Part 1: Get distance from the hit to closest obstacle. // Off-map penalized as max distance if(!MAP_VALID(self-&gt;map, mi, mj)) //Test to see if the given map coords lie within the absolute map bounds. z = self-&gt;map-&gt;max_occ_dist; else z = self-&gt;map-&gt;cells[MAP_INDEX(self-&gt;map,mi,mj)].occ_dist; // Gaussian model // NOTE: this should have a normalization of 1/(sqrt(2pi)*sigma) pz += self-&gt;z_hit * exp(-(z * z) / z_hit_denom); // Part 2: random measurements pz += self-&gt;z_rand * z_rand_mult; // TODO: outlier rejection for short readings assert(pz &lt;= 1.0); assert(pz &gt;= 0.0); // p *= pz; // here we have an ad-hoc weighting scheme for combining beam probs // works well, though... p += pz*pz*pz; } sample-&gt;weight *= p; total_weight += sample-&gt;weight; } return(total_weight); } 对于最后的几行代码，在程序6.3中第7行 q 即p p += pz*pz*pz; sample-&gt;weight *= p; total_weight += sample-&gt;weight; 也有人在ros wiki上提了问 并未得到回答 以及在开源项目下也有人提出对应的是否经过成熟测试的质疑 laser model 质疑 LikelihoodFieldModelProb double AMCLLaser::LikelihoodFieldModelProb(AMCLLaserData *data, pf_sample_set_t* set) { AMCLLaser *self; int i, j, step; double z, pz; double log_p; double obs_range, obs_bearing; double total_weight; pf_sample_t *sample; pf_vector_t pose; pf_vector_t hit; self = (AMCLLaser*) data-&gt;sensor; total_weight = 0.0; step = ceil((data-&gt;range_count) / static_cast&lt;double&gt;(self-&gt;max_beams)); // Step size must be at least 1 if(step &lt; 1) step = 1; // Pre-compute a couple of things double z_hit_denom = 2 * self-&gt;sigma_hit * self-&gt;sigma_hit; double z_rand_mult = 1.0/data-&gt;range_max; double max_dist_prob = exp(-(self-&gt;map-&gt;max_occ_dist * self-&gt;map-&gt;max_occ_dist) / z_hit_denom);//指数项 //Beam skipping - ignores beams for which a majoirty of particles do not agree with the map //prevents correct particles from getting down weighted because of unexpected obstacles //such as humans bool do_beamskip = self-&gt;do_beamskip; double beam_skip_distance = self-&gt;beam_skip_distance; double beam_skip_threshold = self-&gt;beam_skip_threshold; //we only do beam skipping if the filter has converged 只有当滤波器收敛时，我们才跳过光束 if(do_beamskip &amp;&amp; !set-&gt;converged){ do_beamskip = false; } //we need a count the no of particles for which the beam agreed with the map 我们需要计算测量数据与地图一致的粒子的数目 int *obs_count = new int[self-&gt;max_beams](); //we also need a mask of which observations to integrate (to decide which beams to integrate to all particles) //我们还需要一个obs_mask来合并观测结果(以决定哪些测量数据要整合到所有粒子中)。 bool *obs_mask = new bool[self-&gt;max_beams](); int beam_ind = 0; //realloc indicates if we need to reallocate the temp data structure needed to do beamskipping //realloc表示是否需要重新分配需要被跳过的临时数据。 bool realloc = false; if(do_beamskip){ if(self-&gt;max_obs &lt; self-&gt;max_beams){ realloc = true; } if(self-&gt;max_samples &lt; set-&gt;sample_count){ realloc = true; } if(realloc){ self-&gt;reallocTempData(set-&gt;sample_count, self-&gt;max_beams); fprintf(stderr, &quot;Reallocing temp weights %d - %d\n&quot;, self-&gt;max_samples, self-&gt;max_obs); } } // Compute the sample weights for (j = 0; j &lt; set-&gt;sample_count; j++) { sample = set-&gt;samples + j; pose = sample-&gt;pose; // Take account of the laser pose relative to the robot pose = pf_vector_coord_add(self-&gt;laser_pose, pose); log_p = 0; beam_ind = 0; for (i = 0; i &lt; data-&gt;range_count; i += step, beam_ind++) { obs_range = data-&gt;ranges[i][0]; obs_bearing = data-&gt;ranges[i][1]; // This model ignores max range readings if(obs_range &gt;= data-&gt;range_max){ continue; } // Check for NaN if(obs_range != obs_range){ continue; } pz = 0.0; // Compute the endpoint of the beam hit.v[0] = pose.v[0] + obs_range * cos(pose.v[2] + obs_bearing); hit.v[1] = pose.v[1] + obs_range * sin(pose.v[2] + obs_bearing); // Convert to map grid coords. int mi, mj; mi = MAP_GXWX(self-&gt;map, hit.v[0]); mj = MAP_GYWY(self-&gt;map, hit.v[1]); // Part 1: Get distance from the hit to closest obstacle. // Off-map penalized as max distance if(!MAP_VALID(self-&gt;map, mi, mj)){ pz += self-&gt;z_hit * max_dist_prob; } else{ z = self-&gt;map-&gt;cells[MAP_INDEX(self-&gt;map,mi,mj)].occ_dist; if(z &lt; beam_skip_distance){ obs_count[beam_ind] += 1;//用于判断这个方向的点是否用来计算概率和 } pz += self-&gt;z_hit * exp(-(z * z) / z_hit_denom); } // Gaussian model // NOTE: this should have a normalization of 1/(sqrt(2pi)*sigma) // Part 2: random measurements pz += self-&gt;z_rand * z_rand_mult; assert(pz &lt;= 1.0); assert(pz &gt;= 0.0); 到此为止计算基本一样，只是加了部分的beamskip和reallocate。 其中reallocTempData函数用于： void AMCLLaser::reallocTempData(int new_max_samples, int new_max_obs){ if(temp_obs){ for(int k=0; k &lt; max_samples; k++){ delete [] temp_obs[k]; } delete []temp_obs; } max_obs = new_max_obs; max_samples = fmax(max_samples, new_max_samples); temp_obs = new double*[max_samples](); for(int k=0; k &lt; max_samples; k++){ temp_obs[k] = new double[max_obs](); } } 如果do_beamskip的话，用self-&gt;temp_obs[j][beam_ind] 保存概率。 // TODO: outlier rejection for short readings if(!do_beamskip){ log_p += log(pz); } else{ self-&gt;temp_obs[j][beam_ind] = pz; } } if(!do_beamskip){ sample-&gt;weight *= exp(log_p); total_weight += sample-&gt;weight; } } if(!do_beamskip) 则计算的 sample-&gt;weight total_weight 和书上一样 注意此部分计算还是在j &lt; set-&gt;sample_count的循环中。而do_beamskip的话，概率的计算如下： if(do_beamskip) { int skipped_beam_count = 0; //某个角度下z &lt; beam_skip_distance的点的个数/帧数&gt;beam_skip_threshold时obs_mask[beam_ind] = true; //某个角度下z &lt; beam_skip_distance的点的个数/帧数&lt;beam_skip_threshold时obs_mask[beam_ind] = false，该点不用于计算概率和，但是如果这样的点多了，说明收敛到了一个错误的位姿，则所有的点都用来计算概率和 for (beam_ind = 0; beam_ind &lt; self-&gt;max_beams; beam_ind++) { if((obs_count[beam_ind] / static_cast&lt;double&gt;(set-&gt;sample_count)) &gt; beam_skip_threshold) { obs_mask[beam_ind] = true; } else { obs_mask[beam_ind] = false; skipped_beam_count++; } } //we check if there is at least a critical number of beams that agreed with the map //otherwise it probably indicates that the filter converged to a wrong solution //if that&#39;s the case we integrate all the beams and hope the filter might converge to //the right solution bool error = false; //如果skipped_beam_count/beam_ind &gt;= beam_skip_error_threshold 则收敛到一个错误的位姿 //beam_ind为一振数据中采样个数 if(skipped_beam_count &gt;= (beam_ind * self-&gt;beam_skip_error_threshold)){ fprintf(stderr, &quot;Over %f%% of the observations were not in the map - pf may have converged to wrong pose - integrating all observations\n&quot;, (100 * self-&gt;beam_skip_error_threshold)); error = true; } for (j = 0; j &lt; set-&gt;sample_count; j++) { sample = set-&gt;samples + j; pose = sample-&gt;pose; log_p = 0; //如果z &lt; beam_skip_distance或者收敛到一个错误位姿 则被用于计算概率和 for (beam_ind = 0; beam_ind &lt; self-&gt;max_beams; beam_ind++){ if(error || obs_mask[beam_ind]){ log_p += log(self-&gt;temp_obs[j][beam_ind]); } } sample-&gt;weight *= exp(log_p); total_weight += sample-&gt;weight; } } delete [] obs_count; delete [] obs_mask; return(total_weight); } 待解决的问题： prob模型是检查某一个的角度的异常值，那么速度快/转弯时的检测应该是有问题的吧 另外对以下代码也有疑惑 // Update the cspace distance values void map_update_cspace(map_t *map, double max_occ_dist) { unsigned char* marked; std::priority_queue&lt;CellData&gt; Q; marked = new unsigned char[map-&gt;size_x*map-&gt;size_y]; memset(marked, 0, sizeof(unsigned char) * map-&gt;size_x*map-&gt;size_y); map-&gt;max_occ_dist = max_occ_dist; CachedDistanceMap* cdm = get_distance_map(map-&gt;scale, map-&gt;max_occ_dist); // Enqueue all the obstacle cells CellData cell; cell.map_ = map; for(int i=0; i&lt;map-&gt;size_x; i++) { cell.src_i_ = cell.i_ = i; for(int j=0; j&lt;map-&gt;size_y; j++) { if(map-&gt;cells[MAP_INDEX(map, i, j)].occ_state == +1) { map-&gt;cells[MAP_INDEX(map, i, j)].occ_dist = 0.0; cell.src_j_ = cell.j_ = j; marked[MAP_INDEX(map, i, j)] = 1; Q.push(cell); } else map-&gt;cells[MAP_INDEX(map, i, j)].occ_dist = max_occ_dist; } } while(!Q.empty()) { CellData current_cell = Q.top(); if(current_cell.i_ &gt; 0) enqueue(map, current_cell.i_-1, current_cell.j_, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); if(current_cell.j_ &gt; 0) enqueue(map, current_cell.i_, current_cell.j_-1, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); if((int)current_cell.i_ &lt; map-&gt;size_x - 1) enqueue(map, current_cell.i_+1, current_cell.j_, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); if((int)current_cell.j_ &lt; map-&gt;size_y - 1) enqueue(map, current_cell.i_, current_cell.j_+1, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); Q.pop(); } delete[] marked; }" />
<link rel="canonical" href="https://mlh.app/2019/04/07/728719.html" />
<meta property="og:url" content="https://mlh.app/2019/04/07/728719.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-07T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"首先，我们要先了解四类测量误差：小的测量噪声、意外对象引起的误差，以及由于未检测到对象引起的误差和随机意外噪声。 a.小的测量噪声 即使传感器正确测量了最近对象的距离，它返回的值也受到误差的影响。该误差由测距传感器的有限分辨率、大气 对测量信号的影响等引起，呈高斯分布 b.意外对象引起的误差这种情况下测量距离的概率用指数分布来描述，这里不多讲解，因为似然域未用到。 c.由于未检测到对象引起的误差（检测失败）。 声呐传感器遇到镜面反射/激光测距时检测到黑色吸光对象/激光系统在强光下测量时会发生检测失败，但最典型的是最大距离测量问题：传感器返回它的最大允许值Z_max。 d.随机意外噪声 LikelihoodFieldModel 该模型的作用是：遍历粒子更新概率，计算所有粒子概率的总和。 double AMCLLaser::LikelihoodFieldModel(AMCLLaserData *data, pf_sample_set_t* set) { AMCLLaser *self; int i, j, step; double z, pz; double p; double obs_range, obs_bearing; double total_weight; pf_sample_t *sample; pf_vector_t pose; pf_vector_t hit; self = (AMCLLaser*) data-&gt;sensor; total_weight = 0.0; // Compute the sample weights for (j = 0; j &lt; set-&gt;sample_count; j++) { sample = set-&gt;samples + j; pose = sample-&gt;pose; // Take account of the laser pose relative to the robot pose = pf_vector_coord_add(self-&gt;laser_pose, pose);//激光雷达的位姿转换到世界坐标系 p = 1.0; // Pre-compute a couple of things double z_hit_denom = 2 * self-&gt;sigma_hit * self-&gt;sigma_hit;//测量噪声的方差 double z_rand_mult = 1.0/data-&gt;range_max;//无法解释的随机测量的分母 step = (data-&gt;range_count - 1) / (self-&gt;max_beams - 1);//计算步长 只取一组数据中的max_beams个点 // Step size must be at least 1 if(step &lt; 1) step = 1; for (i = 0; i &lt; data-&gt;range_count; i += step) { obs_range = data-&gt;ranges[i][0];//观测到的距离 Z(k,t） obs_bearing = data-&gt;ranges[i][1];//θ_k,sense // This model ignores max range readings //如果obs_range &gt; data-&gt;range_max 则结束跳过以下更新（即：如果测距传感器输出了最大值z(k,t)= Z_max，则这些坐标在物理世界没有任何意义 //似然域测量模型简单地将大于最大距离的读数丢弃） if(obs_range &gt;= data-&gt;range_max) continue; // Check for NaN if(obs_range != obs_range) continue; pz = 0.0; // Compute the endpoint of the beam计算激光雷达点最远端的世界坐标 hit.v[0] = pose.v[0] + obs_range * cos(pose.v[2] + obs_bearing); hit.v[1] = pose.v[1] + obs_range * sin(pose.v[2] + obs_bearing); // Convert to map grid coords.转换到栅格坐标 int mi, mj; mi = MAP_GXWX(self-&gt;map, hit.v[0]); mj = MAP_GYWY(self-&gt;map, hit.v[1]); // Part 1: Get distance from the hit to closest obstacle. // Off-map penalized as max distance if(!MAP_VALID(self-&gt;map, mi, mj)) //Test to see if the given map coords lie within the absolute map bounds. z = self-&gt;map-&gt;max_occ_dist; else z = self-&gt;map-&gt;cells[MAP_INDEX(self-&gt;map,mi,mj)].occ_dist; // Gaussian model // NOTE: this should have a normalization of 1/(sqrt(2pi)*sigma) pz += self-&gt;z_hit * exp(-(z * z) / z_hit_denom); // Part 2: random measurements pz += self-&gt;z_rand * z_rand_mult; // TODO: outlier rejection for short readings assert(pz &lt;= 1.0); assert(pz &gt;= 0.0); // p *= pz; // here we have an ad-hoc weighting scheme for combining beam probs // works well, though... p += pz*pz*pz; } sample-&gt;weight *= p; total_weight += sample-&gt;weight; } return(total_weight); } 对于最后的几行代码，在程序6.3中第7行 q 即p p += pz*pz*pz; sample-&gt;weight *= p; total_weight += sample-&gt;weight; 也有人在ros wiki上提了问 并未得到回答 以及在开源项目下也有人提出对应的是否经过成熟测试的质疑 laser model 质疑 LikelihoodFieldModelProb double AMCLLaser::LikelihoodFieldModelProb(AMCLLaserData *data, pf_sample_set_t* set) { AMCLLaser *self; int i, j, step; double z, pz; double log_p; double obs_range, obs_bearing; double total_weight; pf_sample_t *sample; pf_vector_t pose; pf_vector_t hit; self = (AMCLLaser*) data-&gt;sensor; total_weight = 0.0; step = ceil((data-&gt;range_count) / static_cast&lt;double&gt;(self-&gt;max_beams)); // Step size must be at least 1 if(step &lt; 1) step = 1; // Pre-compute a couple of things double z_hit_denom = 2 * self-&gt;sigma_hit * self-&gt;sigma_hit; double z_rand_mult = 1.0/data-&gt;range_max; double max_dist_prob = exp(-(self-&gt;map-&gt;max_occ_dist * self-&gt;map-&gt;max_occ_dist) / z_hit_denom);//指数项 //Beam skipping - ignores beams for which a majoirty of particles do not agree with the map //prevents correct particles from getting down weighted because of unexpected obstacles //such as humans bool do_beamskip = self-&gt;do_beamskip; double beam_skip_distance = self-&gt;beam_skip_distance; double beam_skip_threshold = self-&gt;beam_skip_threshold; //we only do beam skipping if the filter has converged 只有当滤波器收敛时，我们才跳过光束 if(do_beamskip &amp;&amp; !set-&gt;converged){ do_beamskip = false; } //we need a count the no of particles for which the beam agreed with the map 我们需要计算测量数据与地图一致的粒子的数目 int *obs_count = new int[self-&gt;max_beams](); //we also need a mask of which observations to integrate (to decide which beams to integrate to all particles) //我们还需要一个obs_mask来合并观测结果(以决定哪些测量数据要整合到所有粒子中)。 bool *obs_mask = new bool[self-&gt;max_beams](); int beam_ind = 0; //realloc indicates if we need to reallocate the temp data structure needed to do beamskipping //realloc表示是否需要重新分配需要被跳过的临时数据。 bool realloc = false; if(do_beamskip){ if(self-&gt;max_obs &lt; self-&gt;max_beams){ realloc = true; } if(self-&gt;max_samples &lt; set-&gt;sample_count){ realloc = true; } if(realloc){ self-&gt;reallocTempData(set-&gt;sample_count, self-&gt;max_beams); fprintf(stderr, &quot;Reallocing temp weights %d - %d\\n&quot;, self-&gt;max_samples, self-&gt;max_obs); } } // Compute the sample weights for (j = 0; j &lt; set-&gt;sample_count; j++) { sample = set-&gt;samples + j; pose = sample-&gt;pose; // Take account of the laser pose relative to the robot pose = pf_vector_coord_add(self-&gt;laser_pose, pose); log_p = 0; beam_ind = 0; for (i = 0; i &lt; data-&gt;range_count; i += step, beam_ind++) { obs_range = data-&gt;ranges[i][0]; obs_bearing = data-&gt;ranges[i][1]; // This model ignores max range readings if(obs_range &gt;= data-&gt;range_max){ continue; } // Check for NaN if(obs_range != obs_range){ continue; } pz = 0.0; // Compute the endpoint of the beam hit.v[0] = pose.v[0] + obs_range * cos(pose.v[2] + obs_bearing); hit.v[1] = pose.v[1] + obs_range * sin(pose.v[2] + obs_bearing); // Convert to map grid coords. int mi, mj; mi = MAP_GXWX(self-&gt;map, hit.v[0]); mj = MAP_GYWY(self-&gt;map, hit.v[1]); // Part 1: Get distance from the hit to closest obstacle. // Off-map penalized as max distance if(!MAP_VALID(self-&gt;map, mi, mj)){ pz += self-&gt;z_hit * max_dist_prob; } else{ z = self-&gt;map-&gt;cells[MAP_INDEX(self-&gt;map,mi,mj)].occ_dist; if(z &lt; beam_skip_distance){ obs_count[beam_ind] += 1;//用于判断这个方向的点是否用来计算概率和 } pz += self-&gt;z_hit * exp(-(z * z) / z_hit_denom); } // Gaussian model // NOTE: this should have a normalization of 1/(sqrt(2pi)*sigma) // Part 2: random measurements pz += self-&gt;z_rand * z_rand_mult; assert(pz &lt;= 1.0); assert(pz &gt;= 0.0); 到此为止计算基本一样，只是加了部分的beamskip和reallocate。 其中reallocTempData函数用于： void AMCLLaser::reallocTempData(int new_max_samples, int new_max_obs){ if(temp_obs){ for(int k=0; k &lt; max_samples; k++){ delete [] temp_obs[k]; } delete []temp_obs; } max_obs = new_max_obs; max_samples = fmax(max_samples, new_max_samples); temp_obs = new double*[max_samples](); for(int k=0; k &lt; max_samples; k++){ temp_obs[k] = new double[max_obs](); } } 如果do_beamskip的话，用self-&gt;temp_obs[j][beam_ind] 保存概率。 // TODO: outlier rejection for short readings if(!do_beamskip){ log_p += log(pz); } else{ self-&gt;temp_obs[j][beam_ind] = pz; } } if(!do_beamskip){ sample-&gt;weight *= exp(log_p); total_weight += sample-&gt;weight; } } if(!do_beamskip) 则计算的 sample-&gt;weight total_weight 和书上一样 注意此部分计算还是在j &lt; set-&gt;sample_count的循环中。而do_beamskip的话，概率的计算如下： if(do_beamskip) { int skipped_beam_count = 0; //某个角度下z &lt; beam_skip_distance的点的个数/帧数&gt;beam_skip_threshold时obs_mask[beam_ind] = true; //某个角度下z &lt; beam_skip_distance的点的个数/帧数&lt;beam_skip_threshold时obs_mask[beam_ind] = false，该点不用于计算概率和，但是如果这样的点多了，说明收敛到了一个错误的位姿，则所有的点都用来计算概率和 for (beam_ind = 0; beam_ind &lt; self-&gt;max_beams; beam_ind++) { if((obs_count[beam_ind] / static_cast&lt;double&gt;(set-&gt;sample_count)) &gt; beam_skip_threshold) { obs_mask[beam_ind] = true; } else { obs_mask[beam_ind] = false; skipped_beam_count++; } } //we check if there is at least a critical number of beams that agreed with the map //otherwise it probably indicates that the filter converged to a wrong solution //if that&#39;s the case we integrate all the beams and hope the filter might converge to //the right solution bool error = false; //如果skipped_beam_count/beam_ind &gt;= beam_skip_error_threshold 则收敛到一个错误的位姿 //beam_ind为一振数据中采样个数 if(skipped_beam_count &gt;= (beam_ind * self-&gt;beam_skip_error_threshold)){ fprintf(stderr, &quot;Over %f%% of the observations were not in the map - pf may have converged to wrong pose - integrating all observations\\n&quot;, (100 * self-&gt;beam_skip_error_threshold)); error = true; } for (j = 0; j &lt; set-&gt;sample_count; j++) { sample = set-&gt;samples + j; pose = sample-&gt;pose; log_p = 0; //如果z &lt; beam_skip_distance或者收敛到一个错误位姿 则被用于计算概率和 for (beam_ind = 0; beam_ind &lt; self-&gt;max_beams; beam_ind++){ if(error || obs_mask[beam_ind]){ log_p += log(self-&gt;temp_obs[j][beam_ind]); } } sample-&gt;weight *= exp(log_p); total_weight += sample-&gt;weight; } } delete [] obs_count; delete [] obs_mask; return(total_weight); } 待解决的问题： prob模型是检查某一个的角度的异常值，那么速度快/转弯时的检测应该是有问题的吧 另外对以下代码也有疑惑 // Update the cspace distance values void map_update_cspace(map_t *map, double max_occ_dist) { unsigned char* marked; std::priority_queue&lt;CellData&gt; Q; marked = new unsigned char[map-&gt;size_x*map-&gt;size_y]; memset(marked, 0, sizeof(unsigned char) * map-&gt;size_x*map-&gt;size_y); map-&gt;max_occ_dist = max_occ_dist; CachedDistanceMap* cdm = get_distance_map(map-&gt;scale, map-&gt;max_occ_dist); // Enqueue all the obstacle cells CellData cell; cell.map_ = map; for(int i=0; i&lt;map-&gt;size_x; i++) { cell.src_i_ = cell.i_ = i; for(int j=0; j&lt;map-&gt;size_y; j++) { if(map-&gt;cells[MAP_INDEX(map, i, j)].occ_state == +1) { map-&gt;cells[MAP_INDEX(map, i, j)].occ_dist = 0.0; cell.src_j_ = cell.j_ = j; marked[MAP_INDEX(map, i, j)] = 1; Q.push(cell); } else map-&gt;cells[MAP_INDEX(map, i, j)].occ_dist = max_occ_dist; } } while(!Q.empty()) { CellData current_cell = Q.top(); if(current_cell.i_ &gt; 0) enqueue(map, current_cell.i_-1, current_cell.j_, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); if(current_cell.j_ &gt; 0) enqueue(map, current_cell.i_, current_cell.j_-1, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); if((int)current_cell.i_ &lt; map-&gt;size_x - 1) enqueue(map, current_cell.i_+1, current_cell.j_, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); if((int)current_cell.j_ &lt; map-&gt;size_y - 1) enqueue(map, current_cell.i_, current_cell.j_+1, current_cell.src_i_, current_cell.src_j_, Q, cdm, marked); Q.pop(); } delete[] marked; }","@type":"BlogPosting","url":"https://mlh.app/2019/04/07/728719.html","headline":"AMCL中似然场模型相关代码","dateModified":"2019-04-07T00:00:00+08:00","datePublished":"2019-04-07T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/07/728719.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>AMCL中似然场模型相关代码</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>首先，我们要先了解四类测量误差：小的测量噪声、意外对象引起的误差，以及由于未检测到对象引起的误差和随机意外噪声。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190407202527314.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTIzNDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> a.小的测量噪声<br> 即使传感器正确测量了最近对象的距离，它返回的值也受到误差的影响。该误差由测距传感器的有限分辨率、大气 对测量信号的影响等引起，呈高斯分布<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190407203008962.PNG" alt="在这里插入图片描述"><br> b.意外对象引起的误差这种情况下测量距离的概率用指数分布来描述，这里不多讲解，因为似然域未用到。<br> c.由于未检测到对象引起的误差（检测失败）。<br> 声呐传感器遇到镜面反射/激光测距时检测到黑色吸光对象/激光系统在强光下测量时会发生检测失败，但最典型的是最大距离测量问题：传感器返回它的最大允许值Z_max。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190407203513429.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTIzNDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> d.随机意外噪声<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019040720363588.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTIzNDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/201904072102227.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTIzNDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>LikelihoodFieldModel</strong><br> 该模型的作用是：遍历粒子更新概率，计算所有粒子概率的总和。</p> 
  <pre><code>double AMCLLaser::LikelihoodFieldModel(AMCLLaserData *data, pf_sample_set_t* set)
{
  AMCLLaser *self;
  int i, j, step;
  double z, pz;
  double p;
  double obs_range, obs_bearing;
  double total_weight;
  pf_sample_t *sample;
  pf_vector_t pose;
  pf_vector_t hit;

  self = (AMCLLaser*) data-&gt;sensor;

  total_weight = 0.0;

  // Compute the sample weights
  for (j = 0; j &lt; set-&gt;sample_count; j++)
  {
    sample = set-&gt;samples + j;
    pose = sample-&gt;pose;

    // Take account of the laser pose relative to the robot
    pose = pf_vector_coord_add(self-&gt;laser_pose, pose);//激光雷达的位姿转换到世界坐标系 

    p = 1.0;

    // Pre-compute a couple of things
    double z_hit_denom = 2 * self-&gt;sigma_hit * self-&gt;sigma_hit;//测量噪声的方差
    double z_rand_mult = 1.0/data-&gt;range_max;//无法解释的随机测量的分母

    step = (data-&gt;range_count - 1) / (self-&gt;max_beams - 1);//计算步长 只取一组数据中的max_beams个点

    // Step size must be at least 1
    if(step &lt; 1)
      step = 1;

    for (i = 0; i &lt; data-&gt;range_count; i += step)
    {
      obs_range = data-&gt;ranges[i][0];//观测到的距离 Z(k,t）
      obs_bearing = data-&gt;ranges[i][1];//θ_k,sense

      // This model ignores max range readings
	  //如果obs_range &gt; data-&gt;range_max 则结束跳过以下更新（即：如果测距传感器输出了最大值z(k,t)= Z_max，则这些坐标在物理世界没有任何意义
	  //似然域测量模型简单地将大于最大距离的读数丢弃）
      if(obs_range &gt;= data-&gt;range_max)
        continue;

      // Check for NaN
      if(obs_range != obs_range)
        continue;

      pz = 0.0;

      // Compute the endpoint of the beam计算激光雷达点最远端的世界坐标
      hit.v[0] = pose.v[0] + obs_range * cos(pose.v[2] + obs_bearing);
      hit.v[1] = pose.v[1] + obs_range * sin(pose.v[2] + obs_bearing);

      // Convert to map grid coords.转换到栅格坐标
      int mi, mj;
      mi = MAP_GXWX(self-&gt;map, hit.v[0]);
      mj = MAP_GYWY(self-&gt;map, hit.v[1]);
      
      // Part 1: Get distance from the hit to closest obstacle.
      // Off-map penalized as max distance
      if(!MAP_VALID(self-&gt;map, mi, mj)) //Test to see if the given map coords lie within the absolute map bounds.
        z = self-&gt;map-&gt;max_occ_dist;
      else
        z = self-&gt;map-&gt;cells[MAP_INDEX(self-&gt;map,mi,mj)].occ_dist;
      // Gaussian model
      // NOTE: this should have a normalization of 1/(sqrt(2pi)*sigma)
      pz += self-&gt;z_hit * exp(-(z * z) / z_hit_denom);
      // Part 2: random measurements
      pz += self-&gt;z_rand * z_rand_mult;

      // TODO: outlier rejection for short readings

      assert(pz &lt;= 1.0);
      assert(pz &gt;= 0.0);
      //      p *= pz;
      // here we have an ad-hoc weighting scheme for combining beam probs
      // works well, though...
      p += pz*pz*pz;
    } 

    sample-&gt;weight *= p;
    total_weight += sample-&gt;weight;
  }

  return(total_weight);
}

</code></pre> 
  <p>对于最后的几行代码，在程序6.3中第7行 q 即p</p> 
  <pre><code> p += pz*pz*pz;

 sample-&gt;weight *= p;
 total_weight += sample-&gt;weight;
</code></pre> 
  <p>也有人在ros wiki上提了问 并未得到回答 以及在开源项目下也有人提出对应的是否经过成熟测试的质疑<br> <a href="https://answers.ros.org/question/30711/amcl-observation-model/" rel="nofollow">laser model</a><br> <a href="https://github.com/ros-planning/navigation/pull/462" rel="nofollow">质疑</a><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190407210144110.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTIzNDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <p><strong>LikelihoodFieldModelProb</strong></p> 
  <pre><code>double AMCLLaser::LikelihoodFieldModelProb(AMCLLaserData *data, pf_sample_set_t* set)
{
  AMCLLaser *self;
  int i, j, step;
  double z, pz;
  double log_p;
  double obs_range, obs_bearing;
  double total_weight;
  pf_sample_t *sample;
  pf_vector_t pose;
  pf_vector_t hit;

  self = (AMCLLaser*) data-&gt;sensor;

  total_weight = 0.0;

  step = ceil((data-&gt;range_count) / static_cast&lt;double&gt;(self-&gt;max_beams)); 
  
  // Step size must be at least 1
  if(step &lt; 1)
    step = 1;

  // Pre-compute a couple of things
  double z_hit_denom = 2 * self-&gt;sigma_hit * self-&gt;sigma_hit;
  double z_rand_mult = 1.0/data-&gt;range_max;

  double max_dist_prob = exp(-(self-&gt;map-&gt;max_occ_dist * self-&gt;map-&gt;max_occ_dist) / z_hit_denom);//指数项

  //Beam skipping - ignores beams for which a majoirty of particles do not agree with the map
  //prevents correct particles from getting down weighted because of unexpected obstacles 
  //such as humans 

  bool do_beamskip = self-&gt;do_beamskip;
  double beam_skip_distance = self-&gt;beam_skip_distance;
  double beam_skip_threshold = self-&gt;beam_skip_threshold;
  
  //we only do beam skipping if the filter has converged 只有当滤波器收敛时，我们才跳过光束
  if(do_beamskip &amp;&amp; !set-&gt;converged){
    do_beamskip = false;
  }

  //we need a count the no of particles for which the beam agreed with the map 我们需要计算测量数据与地图一致的粒子的数目
  int *obs_count = new int[self-&gt;max_beams]();

  //we also need a mask of which observations to integrate (to decide which beams to integrate to all particles) 
  //我们还需要一个obs_mask来合并观测结果(以决定哪些测量数据要整合到所有粒子中)。
  bool *obs_mask = new bool[self-&gt;max_beams]();
  
  int beam_ind = 0;
  
  //realloc indicates if we need to reallocate the temp data structure needed to do beamskipping 
  //realloc表示是否需要重新分配需要被跳过的临时数据。
  bool realloc = false; 

  if(do_beamskip){
    if(self-&gt;max_obs &lt; self-&gt;max_beams){
      realloc = true;
    }

    if(self-&gt;max_samples &lt; set-&gt;sample_count){
      realloc = true;
    }

    if(realloc){
      self-&gt;reallocTempData(set-&gt;sample_count, self-&gt;max_beams);     
      fprintf(stderr, "Reallocing temp weights %d - %d\n", self-&gt;max_samples, self-&gt;max_obs);
    }
  }

  // Compute the sample weights
  for (j = 0; j &lt; set-&gt;sample_count; j++)
  {
    sample = set-&gt;samples + j;
    pose = sample-&gt;pose;

    // Take account of the laser pose relative to the robot
    pose = pf_vector_coord_add(self-&gt;laser_pose, pose);

    log_p = 0;
    
    beam_ind = 0;
    
    for (i = 0; i &lt; data-&gt;range_count; i += step, beam_ind++)
    {
      obs_range = data-&gt;ranges[i][0];
      obs_bearing = data-&gt;ranges[i][1];

      // This model ignores max range readings
      if(obs_range &gt;= data-&gt;range_max){
        continue;
      }

      // Check for NaN
      if(obs_range != obs_range){
        continue;
      }

      pz = 0.0;

      // Compute the endpoint of the beam
      hit.v[0] = pose.v[0] + obs_range * cos(pose.v[2] + obs_bearing);
      hit.v[1] = pose.v[1] + obs_range * sin(pose.v[2] + obs_bearing);

      // Convert to map grid coords.
      int mi, mj;
      mi = MAP_GXWX(self-&gt;map, hit.v[0]);
      mj = MAP_GYWY(self-&gt;map, hit.v[1]);
      
      // Part 1: Get distance from the hit to closest obstacle.
      // Off-map penalized as max distance
      
      if(!MAP_VALID(self-&gt;map, mi, mj)){
	pz += self-&gt;z_hit * max_dist_prob;
      }
      else{
	z = self-&gt;map-&gt;cells[MAP_INDEX(self-&gt;map,mi,mj)].occ_dist;
	if(z &lt; beam_skip_distance){
	  obs_count[beam_ind] += 1;//用于判断这个方向的点是否用来计算概率和
	}
	pz += self-&gt;z_hit * exp(-(z * z) / z_hit_denom);
      }
       
      // Gaussian model
      // NOTE: this should have a normalization of 1/(sqrt(2pi)*sigma)
      
      // Part 2: random measurements
      pz += self-&gt;z_rand * z_rand_mult;

      assert(pz &lt;= 1.0); 
      assert(pz &gt;= 0.0);
</code></pre> 
  <p>到此为止计算基本一样，只是加了部分的beamskip和reallocate。<br> 其中reallocTempData函数用于：</p> 
  <pre><code>void AMCLLaser::reallocTempData(int new_max_samples, int new_max_obs){
  if(temp_obs){
    for(int k=0; k &lt; max_samples; k++){
      delete [] temp_obs[k];
    }
    delete []temp_obs; 
  }
  max_obs = new_max_obs; 
  max_samples = fmax(max_samples, new_max_samples); 

  temp_obs = new double*[max_samples]();
  for(int k=0; k &lt; max_samples; k++){
    temp_obs[k] = new double[max_obs]();
  }
}

</code></pre> 
  <p>如果do_beamskip的话，用self-&gt;temp_obs[j][beam_ind] 保存概率。</p> 
  <pre><code>      // TODO: outlier rejection for short readings
            
      if(!do_beamskip){
	log_p += log(pz);
      }
      else{
	self-&gt;temp_obs[j][beam_ind] = pz; 
      }
    }
    if(!do_beamskip){
      sample-&gt;weight *= exp(log_p);
      total_weight += sample-&gt;weight;
    }
  }
  

</code></pre> 
  <p>if(!do_beamskip) 则计算的 sample-&gt;weight total_weight 和书上一样 注意此部分计算还是在j &lt; set-&gt;sample_count的循环中。而do_beamskip的话，概率的计算如下：</p> 
  <pre><code>
  if(do_beamskip)
  {
    int skipped_beam_count = 0; 
 //某个角度下z &lt; beam_skip_distance的点的个数/帧数&gt;beam_skip_threshold时obs_mask[beam_ind] = true;
 //某个角度下z &lt; beam_skip_distance的点的个数/帧数&lt;beam_skip_threshold时obs_mask[beam_ind] = false，该点不用于计算概率和，但是如果这样的点多了，说明收敛到了一个错误的位姿，则所有的点都用来计算概率和
    for (beam_ind = 0; beam_ind &lt; self-&gt;max_beams; beam_ind++) 
    {
      if((obs_count[beam_ind] / static_cast&lt;double&gt;(set-&gt;sample_count)) &gt; beam_skip_threshold)
      {
	     obs_mask[beam_ind] = true;
      }
      else
      {
	     obs_mask[beam_ind] = false;
	     skipped_beam_count++; 
      }
    }

    //we check if there is at least a critical number of beams that agreed with the map 
    //otherwise it probably indicates that the filter converged to a wrong solution
    //if that's the case we integrate all the beams and hope the filter might converge to 
    //the right solution
    bool error = false; 
    
    //如果skipped_beam_count/beam_ind &gt;= beam_skip_error_threshold 则收敛到一个错误的位姿
	//beam_ind为一振数据中采样个数
    if(skipped_beam_count &gt;= (beam_ind * self-&gt;beam_skip_error_threshold)){
      fprintf(stderr, "Over %f%% of the observations were not in the map - pf may have converged to wrong pose - integrating all observations\n", (100 * self-&gt;beam_skip_error_threshold));
      error = true; 
    }
</code></pre> 
  <pre><code>    for (j = 0; j &lt; set-&gt;sample_count; j++)
      {
	sample = set-&gt;samples + j;
	pose = sample-&gt;pose;

	log_p = 0;

   //如果z &lt; beam_skip_distance或者收敛到一个错误位姿 则被用于计算概率和
	for (beam_ind = 0; beam_ind &lt; self-&gt;max_beams; beam_ind++){
	  if(error || obs_mask[beam_ind]){
	    log_p += log(self-&gt;temp_obs[j][beam_ind]);
	  }
	}
	
	sample-&gt;weight *= exp(log_p);
	
	total_weight += sample-&gt;weight;
      }      
  }
  delete [] obs_count; 
  delete [] obs_mask;
  return(total_weight);
} 
</code></pre> 
  <p>待解决的问题：<br> prob模型是检查某一个的角度的异常值，那么速度快/转弯时的检测应该是有问题的吧<br> 另外对以下代码也有疑惑</p> 
  <pre><code>// Update the cspace distance values
void map_update_cspace(map_t *map, double max_occ_dist)
{
  unsigned char* marked;
  std::priority_queue&lt;CellData&gt; Q;

  marked = new unsigned char[map-&gt;size_x*map-&gt;size_y];
  memset(marked, 0, sizeof(unsigned char) * map-&gt;size_x*map-&gt;size_y);

  map-&gt;max_occ_dist = max_occ_dist;

  CachedDistanceMap* cdm = get_distance_map(map-&gt;scale, map-&gt;max_occ_dist);

  // Enqueue all the obstacle cells
  CellData cell;
  cell.map_ = map;
  for(int i=0; i&lt;map-&gt;size_x; i++)
  {
    cell.src_i_ = cell.i_ = i;
    for(int j=0; j&lt;map-&gt;size_y; j++)
    {
      if(map-&gt;cells[MAP_INDEX(map, i, j)].occ_state == +1)
      {
	map-&gt;cells[MAP_INDEX(map, i, j)].occ_dist = 0.0;
	cell.src_j_ = cell.j_ = j;
	marked[MAP_INDEX(map, i, j)] = 1;
	Q.push(cell);
      }
      else
	map-&gt;cells[MAP_INDEX(map, i, j)].occ_dist = max_occ_dist;
    }
  }

  while(!Q.empty())
  {
    CellData current_cell = Q.top();
    if(current_cell.i_ &gt; 0)
      enqueue(map, current_cell.i_-1, current_cell.j_, 
	      current_cell.src_i_, current_cell.src_j_,
	      Q, cdm, marked);
    if(current_cell.j_ &gt; 0)
      enqueue(map, current_cell.i_, current_cell.j_-1, 
	      current_cell.src_i_, current_cell.src_j_,
	      Q, cdm, marked);
    if((int)current_cell.i_ &lt; map-&gt;size_x - 1)
      enqueue(map, current_cell.i_+1, current_cell.j_, 
	      current_cell.src_i_, current_cell.src_j_,
	      Q, cdm, marked);
    if((int)current_cell.j_ &lt; map-&gt;size_y - 1)
      enqueue(map, current_cell.i_, current_cell.j_+1, 
	      current_cell.src_i_, current_cell.src_j_,
	      Q, cdm, marked);

    Q.pop();
  }

  delete[] marked;
}
</code></pre> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
