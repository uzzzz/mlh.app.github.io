<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>SciKit-learn轻松使用机器学习（2）数据预处理 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="SciKit-learn轻松使用机器学习（2）数据预处理" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="参考官方文档：https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing 4.3. Preprocessing data The&nbsp;sklearn.preprocessing&nbsp;package provides several common utility functions and transformer classes to change raw feature vectors into a representation that is more suitable for the downstream estimators. In general, learning algorithms benefit from standardization of the data set. If some outliers are present in the set, robust scalers or transformers are more appropriate. The behaviors of the different scalers, transformers, and normalizers on a dataset containing marginal outliers is highlighted in&nbsp;Compare the effect of different scalers on data with outliers. 4.3.1. Standardization, or mean removal and variance scaling Standardization&nbsp;of datasets is a&nbsp;common requirement for many machine learning estimators&nbsp;implemented in scikit-learn; they might behave badly if the individual features do not more or less look like standard normally distributed data: Gaussian with&nbsp;zero mean and unit variance. In practice we often ignore the shape of the distribution and just transform the data to center it by removing the mean value of each feature, then scale it by dividing non-constant features by their standard deviation. For instance, many elements used in the objective function of a learning algorithm (such as the RBF kernel of Support Vector Machines or the l1 and l2 regularizers of linear models) assume that all features are centered around zero and have variance in the same order. If a feature has a variance that is orders of magnitude larger than others, it might dominate the objective function and make the estimator unable to learn from other features correctly as expected. The function&nbsp;scale&nbsp;provides a quick and easy way to perform this operation on a single array-like dataset: &gt;&gt;&gt; &gt;&gt;&gt; from sklearn import preprocessing &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; X_train = np.array([[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]]) &gt;&gt;&gt; X_scaled = preprocessing.scale(X_train) &gt;&gt;&gt; X_scaled array([[ 0. ..., -1.22..., 1.33...], [ 1.22..., 0. ..., -0.26...], [-1.22..., 1.22..., -1.06...]]) Scaled data has zero mean and unit variance: &gt;&gt;&gt; &gt;&gt;&gt; X_scaled.mean(axis=0) array([0., 0., 0.]) &gt;&gt;&gt; X_scaled.std(axis=0) array([1., 1., 1.]) The&nbsp;preprocessing&nbsp;module further provides a utility class&nbsp;StandardScaler&nbsp;that implements the&nbsp;Transformer&nbsp;API to compute the mean and standard deviation on a training set so as to be able to later reapply the same transformation on the testing set. This class is hence suitable for use in the early steps of a&nbsp;sklearn.pipeline.Pipeline: &gt;&gt;&gt; &gt;&gt;&gt; scaler = preprocessing.StandardScaler().fit(X_train) &gt;&gt;&gt; scaler StandardScaler(copy=True, with_mean=True, with_std=True) &gt;&gt;&gt; scaler.mean_ array([1. ..., 0. ..., 0.33...]) &gt;&gt;&gt; scaler.scale_ array([0.81..., 0.81..., 1.24...]) &gt;&gt;&gt; scaler.transform(X_train) array([[ 0. ..., -1.22..., 1.33...], [ 1.22..., 0. ..., -0.26...], [-1.22..., 1.22..., -1.06...]]) The scaler instance can then be used on new data to transform it the same way it did on the training set: &gt;&gt;&gt; &gt;&gt;&gt; X_test = [[-1., 1., 0.]] &gt;&gt;&gt; scaler.transform(X_test) array([[-2.44..., 1.22..., -0.26...]]) It is possible to disable either centering or scaling by either passing&nbsp;with_mean=False&nbsp;or&nbsp;with_std=False&nbsp;to the constructor of&nbsp;StandardScaler. 4.3.1.1. Scaling features to a range An alternative standardization is scaling features to lie between a given minimum and maximum value, often between zero and one, or so that the maximum absolute value of each feature is scaled to unit size. This can be achieved using&nbsp;MinMaxScaler&nbsp;or&nbsp;MaxAbsScaler, respectively. The motivation to use this scaling include robustness to very small standard deviations of features and preserving zero entries in sparse data. Here is an example to scale a toy data matrix to the&nbsp;[0,&nbsp;1]&nbsp;range: &gt;&gt;&gt; &gt;&gt;&gt; X_train = np.array([[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]]) ... &gt;&gt;&gt; min_max_scaler = preprocessing.MinMaxScaler() &gt;&gt;&gt; X_train_minmax = min_max_scaler.fit_transform(X_train) &gt;&gt;&gt; X_train_minmax array([[0.5 , 0. , 1. ], [1. , 0.5 , 0.33333333], [0. , 1. , 0. ]]) The same instance of the transformer can then be applied to some new test data unseen during the fit call: the same scaling and shifting operations will be applied to be consistent with the transformation performed on the train data: &gt;&gt;&gt; &gt;&gt;&gt; X_test = np.array([[-3., -1., 4.]]) &gt;&gt;&gt; X_test_minmax = min_max_scaler.transform(X_test) &gt;&gt;&gt; X_test_minmax array([[-1.5 , 0. , 1.66666667]]) It is possible to introspect the scaler attributes to find about the exact nature of the transformation learned on the training data: &gt;&gt;&gt; &gt;&gt;&gt; min_max_scaler.scale_ array([0.5 , 0.5 , 0.33...]) &gt;&gt;&gt; min_max_scaler.min_ array([0. , 0.5 , 0.33...]) If&nbsp;MinMaxScaler&nbsp;is given an explicit&nbsp;feature_range=(min,&nbsp;max)&nbsp;the full formula is: X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0)) X_scaled = X_std * (max - min) + min MaxAbsScaler&nbsp;works in a very similar fashion, but scales in a way that the training data lies within the range&nbsp;[-1,&nbsp;1]&nbsp;by dividing through the largest maximum value in each feature. It is meant for data that is already centered at zero or sparse data. Here is how to use the toy data from the previous example with this scaler: &gt;&gt;&gt; &gt;&gt;&gt; X_train = np.array([[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]]) ... &gt;&gt;&gt; max_abs_scaler = preprocessing.MaxAbsScaler() &gt;&gt;&gt; X_train_maxabs = max_abs_scaler.fit_transform(X_train) &gt;&gt;&gt; X_train_maxabs # doctest +NORMALIZE_WHITESPACE^ array([[ 0.5, -1. , 1. ], [ 1. , 0. , 0. ], [ 0. , 1. , -0.5]]) &gt;&gt;&gt; X_test = np.array([[ -3., -1., 4.]]) &gt;&gt;&gt; X_test_maxabs = max_abs_scaler.transform(X_test) &gt;&gt;&gt; X_test_maxabs array([[-1.5, -1. , 2. ]]) &gt;&gt;&gt; max_abs_scaler.scale_ array([2., 1., 2.]) As with&nbsp;scale, the module further provides convenience functions&nbsp;minmax_scale&nbsp;and&nbsp;maxabs_scale&nbsp;if you don’t want to create an object. 4.3.1.2. Scaling sparse data Centering sparse data would destroy the sparseness structure in the data, and thus rarely is a sensible thing to do. However, it can make sense to scale sparse inputs, especially if features are on different scales. MaxAbsScaler&nbsp;and&nbsp;maxabs_scale&nbsp;were specifically designed for scaling sparse data, and are the recommended way to go about this. However,&nbsp;scale&nbsp;and&nbsp;StandardScaler&nbsp;can accept&nbsp;scipy.sparse&nbsp;matrices as input, as long as&nbsp;with_mean=False&nbsp;is explicitly passed to the constructor. Otherwise a&nbsp;ValueError&nbsp;will be raised as silently centering would break the sparsity and would often crash the execution by allocating excessive amounts of memory unintentionally.RobustScaler&nbsp;cannot be fitted to sparse inputs, but you can use the&nbsp;transform&nbsp;method on sparse inputs. Note that the scalers accept both Compressed Sparse Rows and Compressed Sparse Columns format (see&nbsp;scipy.sparse.csr_matrix&nbsp;and&nbsp;scipy.sparse.csc_matrix). Any other sparse input will be&nbsp;converted to the Compressed Sparse Rows representation. To avoid unnecessary memory copies, it is recommended to choose the CSR or CSC representation upstream. Finally, if the centered data is expected to be small enough, explicitly converting the input to an array using the&nbsp;toarraymethod of sparse matrices is another option. 4.3.1.3. Scaling data with outliers If your data contains many outliers, scaling using the mean and variance of the data is likely to not work very well. In these cases, you can use&nbsp;robust_scale&nbsp;and&nbsp;RobustScaler&nbsp;as drop-in replacements instead. They use more robust estimates for the center and range of your data. References: Further discussion on the importance of centering and scaling data is available on this FAQ:&nbsp;Should I normalize/standardize/rescale the data? Scaling vs Whitening It is sometimes not enough to center and scale the features independently, since a downstream model can further make some assumption on the linear independence of the features. To address this issue you can use&nbsp;sklearn.decomposition.PCA&nbsp;with&nbsp;whiten=True&nbsp;to further remove the linear correlation across features. Scaling a 1D array All above functions (i.e.&nbsp;scale,&nbsp;minmax_scale,&nbsp;maxabs_scale, and&nbsp;robust_scale) accept 1D array which can be useful in some specific case. 4.3.1.4. Centering kernel matrices If you have a kernel matrix of a kernel&nbsp;K&nbsp;that computes a dot product in a feature space defined by function&nbsp;phi, a&nbsp;KernelCenterer&nbsp;can transform the kernel matrix so that it contains inner products in the feature space defined by&nbsp;phifollowed by removal of the mean in that space. 4.3.2. Non-linear transformation 4.3.2.1. Mapping to a Uniform distribution Like scalers,&nbsp;QuantileTransformer&nbsp;puts all features into the same, known range or distribution. However, by performing a rank transformation, it smooths out unusual distributions and is less influenced by outliers than scaling methods. It does, however, distort correlations and distances within and across features. QuantileTransformer&nbsp;and&nbsp;quantile_transform&nbsp;provide a non-parametric transformation based on the quantile function to map the data to a uniform distribution with values between 0 and 1: &gt;&gt;&gt; &gt;&gt;&gt; from sklearn.datasets import load_iris &gt;&gt;&gt; from sklearn.model_selection import train_test_split &gt;&gt;&gt; iris = load_iris() &gt;&gt;&gt; X, y = iris.data, iris.target &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0) &gt;&gt;&gt; quantile_transformer = preprocessing.QuantileTransformer(random_state=0) &gt;&gt;&gt; X_train_trans = quantile_transformer.fit_transform(X_train) &gt;&gt;&gt; X_test_trans = quantile_transformer.transform(X_test) &gt;&gt;&gt; np.percentile(X_train[:, 0], [0, 25, 50, 75, 100]) array([ 4.3, 5.1, 5.8, 6.5, 7.9]) This feature corresponds to the sepal length in cm. Once the quantile transformation applied, those landmarks approach closely the percentiles previously defined: &gt;&gt;&gt; &gt;&gt;&gt; np.percentile(X_train_trans[:, 0], [0, 25, 50, 75, 100]) ... array([ 0.00... , 0.24..., 0.49..., 0.73..., 0.99... ]) This can be confirmed on a independent testing set with similar remarks: &gt;&gt;&gt; &gt;&gt;&gt; np.percentile(X_test[:, 0], [0, 25, 50, 75, 100]) ... array([ 4.4 , 5.125, 5.75 , 6.175, 7.3 ]) &gt;&gt;&gt; np.percentile(X_test_trans[:, 0], [0, 25, 50, 75, 100]) ... array([ 0.01..., 0.25..., 0.46..., 0.60... , 0.94...]) 4.3.2.2. Mapping to a Gaussian distribution In many modeling scenarios, normality of the features in a dataset is desirable. Power transforms are a family of parametric, monotonic transformations that aim to map data from any distribution to as close to a Gaussian distribution as possible in order to stabilize variance and minimize skewness. PowerTransformer&nbsp;currently provides two such power transformations, the Yeo-Johnson transform and the Box-Cox transform. The Yeo-Johnson transform is given by: xi(λ)={[(xi+1)λ−1]/λif&nbsp;λ≠0,xi≥0,ln⁡(xi)+1if&nbsp;λ=0,xi≥0−[(−xi+1)2−λ−1]/(2−λ)if&nbsp;λ≠2,xi&lt;0,−ln⁡(−xi+1)if&nbsp;λ=2,xi&lt;0 while the Box-Cox transform is given by: xi(λ)={xiλ−1λif&nbsp;λ≠0,ln⁡(xi)if&nbsp;λ=0, Box-Cox can only be applied to strictly positive data. In both methods, the transformation is parameterized by&nbsp;λ, which is determined through maximum likelihood estimation. Here is an example of using Box-Cox to map samples drawn from a lognormal distribution to a normal distribution: &gt;&gt;&gt; &gt;&gt;&gt; pt = preprocessing.PowerTransformer(method=&#39;box-cox&#39;, standardize=False) &gt;&gt;&gt; X_lognormal = np.random.RandomState(616).lognormal(size=(3, 3)) &gt;&gt;&gt; X_lognormal array([[1.28..., 1.18..., 0.84...], [0.94..., 1.60..., 0.38...], [1.35..., 0.21..., 1.09...]]) &gt;&gt;&gt; pt.fit_transform(X_lognormal) array([[ 0.49..., 0.17..., -0.15...], [-0.05..., 0.58..., -0.57...], [ 0.69..., -0.84..., 0.10...]]) While the above example sets the&nbsp;standardize&nbsp;option to&nbsp;False,&nbsp;PowerTransformer&nbsp;will apply zero-mean, unit-variance normalization to the transformed output by default. Below are examples of Box-Cox and Yeo-Johnson applied to various probability distributions. Note that when applied to certain distributions, the power transforms achieve very Gaussian-like results, but with others, they are ineffective. This highlights the importance of visualizing the data before and after transformation. It is also possible to map data to a normal distribution using&nbsp;QuantileTransformer&nbsp;by setting&nbsp;output_distribution=&#39;normal&#39;. Using the earlier example with the iris dataset: &gt;&gt;&gt; &gt;&gt;&gt; quantile_transformer = preprocessing.QuantileTransformer( ... output_distribution=&#39;normal&#39;, random_state=0) &gt;&gt;&gt; X_trans = quantile_transformer.fit_transform(X) &gt;&gt;&gt; quantile_transformer.quantiles_ array([[4.3..., 2..., 1..., 0.1...], [4.31..., 2.02..., 1.01..., 0.1...], [4.32..., 2.05..., 1.02..., 0.1...], ..., [7.84..., 4.34..., 6.84..., 2.5...], [7.87..., 4.37..., 6.87..., 2.5...], [7.9..., 4.4..., 6.9..., 2.5...]]) Thus the median of the input becomes the mean of the output, centered at 0. The normal output is clipped so that the input’s minimum and maximum — corresponding to the 1e-7 and 1 - 1e-7 quantiles respectively — do not become infinite under the transformation. 4.3.3. Normalization Normalization&nbsp;is the process of&nbsp;scaling individual samples to have unit norm. This process can be useful if you plan to use a quadratic form such as the dot-product or any other kernel to quantify the similarity of any pair of samples. This assumption is the base of the&nbsp;Vector Space Model&nbsp;often used in text classification and clustering contexts. The function&nbsp;normalize&nbsp;provides a quick and easy way to perform this operation on a single array-like dataset, either using the&nbsp;l1&nbsp;or&nbsp;l2&nbsp;norms: &gt;&gt;&gt; &gt;&gt;&gt; X = [[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]] &gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm=&#39;l2&#39;) &gt;&gt;&gt; X_normalized array([[ 0.40..., -0.40..., 0.81...], [ 1. ..., 0. ..., 0. ...], [ 0. ..., 0.70..., -0.70...]]) The&nbsp;preprocessing&nbsp;module further provides a utility class&nbsp;Normalizer&nbsp;that implements the same operation using theTransformer&nbsp;API (even though the&nbsp;fit&nbsp;method is useless in this case: the class is stateless as this operation treats samples independently). This class is hence suitable for use in the early steps of a&nbsp;sklearn.pipeline.Pipeline: &gt;&gt;&gt; &gt;&gt;&gt; normalizer = preprocessing.Normalizer().fit(X) # fit does nothing &gt;&gt;&gt; normalizer Normalizer(copy=True, norm=&#39;l2&#39;) The normalizer instance can then be used on sample vectors as any transformer: &gt;&gt;&gt; &gt;&gt;&gt; normalizer.transform(X) array([[ 0.40..., -0.40..., 0.81...], [ 1. ..., 0. ..., 0. ...], [ 0. ..., 0.70..., -0.70...]]) &gt;&gt;&gt; normalizer.transform([[-1., 1., 0.]]) array([[-0.70..., 0.70..., 0. ...]]) Sparse input normalize&nbsp;and&nbsp;Normalizer&nbsp;accept&nbsp;both dense array-like and sparse matrices from scipy.sparse as input. For sparse input the data is&nbsp;converted to the Compressed Sparse Rows representation&nbsp;(see&nbsp;scipy.sparse.csr_matrix) before being fed to efficient Cython routines. To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream. 4.3.4. Encoding categorical features Often features are not given as continuous values but categorical. For example a person could have features&nbsp;[&quot;male&quot;,&nbsp;&quot;female&quot;],&nbsp;[&quot;from&nbsp;Europe&quot;,&nbsp;&quot;from&nbsp;US&quot;,&nbsp;&quot;from&nbsp;Asia&quot;],[&quot;uses&nbsp;Firefox&quot;,&nbsp;&quot;uses&nbsp;Chrome&quot;,&nbsp;&quot;uses&nbsp;Safari&quot;,&nbsp;&quot;uses&nbsp;Internet&nbsp;Explorer&quot;]. Such features can be efficiently coded as integers, for instance&nbsp;[&quot;male&quot;,&nbsp;&quot;from&nbsp;US&quot;,&nbsp;&quot;uses&nbsp;Internet&nbsp;Explorer&quot;]&nbsp;could be expressed as&nbsp;[0,&nbsp;1,&nbsp;3]while&nbsp;[&quot;female&quot;,&nbsp;&quot;from&nbsp;Asia&quot;,&nbsp;&quot;uses&nbsp;Chrome&quot;]&nbsp;would be&nbsp;[1,&nbsp;2,&nbsp;1]. To convert categorical features to such integer codes, we can use the&nbsp;OrdinalEncoder. This estimator transforms each categorical feature to one new feature of integers (0 to n_categories - 1): &gt;&gt;&gt; &gt;&gt;&gt; enc = preprocessing.OrdinalEncoder() &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OrdinalEncoder(categories=&#39;auto&#39;, dtype=&lt;... &#39;numpy.float64&#39;&gt;) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from US&#39;, &#39;uses Safari&#39;]]) array([[0., 1., 1.]]) Such integer representation can, however, not be used directly with all scikit-learn estimators, as these expect continuous input, and would interpret the categories as being ordered, which is often not desired (i.e. the set of browsers was ordered arbitrarily). Another possibility to convert categorical features to features that can be used with scikit-learn estimators is to use a one-of-K, also known as one-hot or dummy encoding. This type of encoding can be obtained with the&nbsp;OneHotEncoder, which transforms each categorical feature with&nbsp;n_categories&nbsp;possible values into&nbsp;n_categories&nbsp;binary features, with one of them 1, and all others 0. Continuing the example above: &gt;&gt;&gt; &gt;&gt;&gt; enc = preprocessing.OneHotEncoder() &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OneHotEncoder(categorical_features=None, categories=None, dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;error&#39;, n_values=None, sparse=True) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], ... [&#39;male&#39;, &#39;from Europe&#39;, &#39;uses Safari&#39;]]).toarray() array([[1., 0., 0., 1., 0., 1.], [0., 1., 1., 0., 0., 1.]]) By default, the values each feature can take is inferred automatically from the dataset and can be found in the&nbsp;categories_&nbsp;attribute: &gt;&gt;&gt; &gt;&gt;&gt; enc.categories_ [array([&#39;female&#39;, &#39;male&#39;], dtype=object), array([&#39;from Europe&#39;, &#39;from US&#39;], dtype=object), array([&#39;uses Firefox&#39;, &#39;uses Safari&#39;], dtype=object)] It is possible to specify this explicitly using the parameter&nbsp;categories. There are two genders, four possible continents and four web browsers in our dataset: &gt;&gt;&gt; &gt;&gt;&gt; genders = [&#39;female&#39;, &#39;male&#39;] &gt;&gt;&gt; locations = [&#39;from Africa&#39;, &#39;from Asia&#39;, &#39;from Europe&#39;, &#39;from US&#39;] &gt;&gt;&gt; browsers = [&#39;uses Chrome&#39;, &#39;uses Firefox&#39;, &#39;uses IE&#39;, &#39;uses Safari&#39;] &gt;&gt;&gt; enc = preprocessing.OneHotEncoder(categories=[genders, locations, browsers]) &gt;&gt;&gt; # Note that for there are missing categorical values for the 2nd and 3rd &gt;&gt;&gt; # feature &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OneHotEncoder(categorical_features=None, categories=[...], dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;error&#39;, n_values=None, sparse=True) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from Asia&#39;, &#39;uses Chrome&#39;]]).toarray() array([[1., 0., 0., 1., 0., 0., 1., 0., 0., 0.]]) If there is a possibility that the training data might have missing categorical features, it can often be better to specify&nbsp;handle_unknown=&#39;ignore&#39;&nbsp;instead of setting the&nbsp;categories&nbsp;manually as above. When&nbsp;handle_unknown=&#39;ignore&#39;&nbsp;is specified and unknown categories are encountered during transform, no error will be raised but the resulting one-hot encoded columns for this feature will be all zeros (handle_unknown=&#39;ignore&#39;&nbsp;is only supported for one-hot encoding): &gt;&gt;&gt; &gt;&gt;&gt; enc = preprocessing.OneHotEncoder(handle_unknown=&#39;ignore&#39;) &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OneHotEncoder(categorical_features=None, categories=None, dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;ignore&#39;, n_values=None, sparse=True) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from Asia&#39;, &#39;uses Chrome&#39;]]).toarray() array([[1., 0., 0., 0., 0., 0.]]) See&nbsp;Loading features from dicts&nbsp;for categorical features that are represented as a dict, not as scalars. 4.3.5. Discretization Discretization&nbsp;(otherwise known as quantization or binning) provides a way to partition continuous features into discrete values. Certain datasets with continuous features may benefit from discretization, because discretization can transform the dataset of continuous attributes to one with only nominal attributes. One-hot encoded discretized features can make a model more expressive, while maintaining interpretability. For instance, pre-processing with a discretizer can introduce nonlinearity to linear models. 4.3.5.1. K-bins discretization KBinsDiscretizer&nbsp;discretizers features into&nbsp;k&nbsp;equal width bins: &gt;&gt;&gt; &gt;&gt;&gt; X = np.array([[ -3., 5., 15 ], ... [ 0., 6., 14 ], ... [ 6., 3., 11 ]]) &gt;&gt;&gt; est = preprocessing.KBinsDiscretizer(n_bins=[3, 2, 2], encode=&#39;ordinal&#39;).fit(X) By default the output is one-hot encoded into a sparse matrix (See&nbsp;Encoding categorical features) and this can be configured with the&nbsp;encode&nbsp;parameter. For each feature, the bin edges are computed during&nbsp;fit&nbsp;and together with the number of bins, they will define the intervals. Therefore, for the current example, these intervals are defined as: feature 1:&nbsp;[−∞,−1),[−1,2),[2,∞) feature 2:&nbsp;[−∞,5),[5,∞) feature 3:&nbsp;[−∞,14),[14,∞) Based on these bin intervals,&nbsp;X&nbsp;is transformed as follows: &gt;&gt;&gt; &gt;&gt;&gt; est.transform(X) array([[ 0., 1., 1.], [ 1., 1., 1.], [ 2., 0., 0.]]) The resulting dataset contains ordinal attributes which can be further used in a&nbsp;sklearn.pipeline.Pipeline. Discretization is similar to constructing histograms for continuous data. However, histograms focus on counting features which fall into particular bins, whereas discretization focuses on assigning feature values to these bins. KBinsDiscretizer&nbsp;implements different binning strategies, which can be selected with the&nbsp;strategy&nbsp;parameter. The ‘uniform’ strategy uses constant-width bins. The ‘quantile’ strategy uses the quantiles values to have equally populated bins in each feature. The ‘kmeans’ strategy defines bins based on a k-means clustering procedure performed on each feature independently. Examples: Using KBinsDiscretizer to discretize continuous features Feature discretization Demonstrating the different strategies of KBinsDiscretizer 4.3.5.2. Feature binarization Feature binarization&nbsp;is the process of&nbsp;thresholding numerical features to get boolean values. This can be useful for downstream probabilistic estimators that make assumption that the input data is distributed according to a multi-variate&nbsp;Bernoulli distribution. For instance, this is the case for the&nbsp;sklearn.neural_network.BernoulliRBM. It is also common among the text processing community to use binary feature values (probably to simplify the probabilistic reasoning) even if normalized counts (a.k.a. term frequencies) or TF-IDF valued features often perform slightly better in practice. As for the&nbsp;Normalizer, the utility class&nbsp;Binarizer&nbsp;is meant to be used in the early stages ofsklearn.pipeline.Pipeline. The&nbsp;fit&nbsp;method does nothing as each sample is treated independently of others: &gt;&gt;&gt; &gt;&gt;&gt; X = [[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]] &gt;&gt;&gt; binarizer = preprocessing.Binarizer().fit(X) # fit does nothing &gt;&gt;&gt; binarizer Binarizer(copy=True, threshold=0.0) &gt;&gt;&gt; binarizer.transform(X) array([[1., 0., 1.], [1., 0., 0.], [0., 1., 0.]]) It is possible to adjust the threshold of the binarizer: &gt;&gt;&gt; &gt;&gt;&gt; binarizer = preprocessing.Binarizer(threshold=1.1) &gt;&gt;&gt; binarizer.transform(X) array([[0., 0., 1.], [1., 0., 0.], [0., 0., 0.]]) As for the&nbsp;StandardScaler&nbsp;and&nbsp;Normalizer&nbsp;classes, the preprocessing module provides a companion function&nbsp;binarize&nbsp;to be used when the transformer API is not necessary. Note that the&nbsp;Binarizer&nbsp;is similar to the&nbsp;KBinsDiscretizer&nbsp;when&nbsp;k&nbsp;=&nbsp;2, and when the bin edge is at the value&nbsp;threshold. Sparse input binarize&nbsp;and&nbsp;Binarizer&nbsp;accept&nbsp;both dense array-like and sparse matrices from scipy.sparse as input. For sparse input the data is&nbsp;converted to the Compressed Sparse Rows representation&nbsp;(see&nbsp;scipy.sparse.csr_matrix). To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream. 4.3.6. Imputation of missing values Tools for imputing missing values are discussed at&nbsp;Imputation of missing values. 4.3.7. Generating polynomial features Often it’s useful to add complexity to the model by considering nonlinear features of the input data. A simple and common method to use is polynomial features, which can get features’ high-order and interaction terms. It is implemented in&nbsp;PolynomialFeatures: &gt;&gt;&gt; &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; from sklearn.preprocessing import PolynomialFeatures &gt;&gt;&gt; X = np.arange(6).reshape(3, 2) &gt;&gt;&gt; X array([[0, 1], [2, 3], [4, 5]]) &gt;&gt;&gt; poly = PolynomialFeatures(2) &gt;&gt;&gt; poly.fit_transform(X) array([[ 1., 0., 1., 0., 0., 1.], [ 1., 2., 3., 4., 6., 9.], [ 1., 4., 5., 16., 20., 25.]]) The features of X have been transformed from&nbsp;(X1,X2)&nbsp;to&nbsp;(1,X1,X2,X12,X1X2,X22). In some cases, only interaction terms among features are required, and it can be gotten with the setting&nbsp;interaction_only=True: &gt;&gt;&gt; &gt;&gt;&gt; X = np.arange(9).reshape(3, 3) &gt;&gt;&gt; X array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) &gt;&gt;&gt; poly = PolynomialFeatures(degree=3, interaction_only=True) &gt;&gt;&gt; poly.fit_transform(X) array([[ 1., 0., 1., 2., 0., 0., 2., 0.], [ 1., 3., 4., 5., 12., 15., 20., 60.], [ 1., 6., 7., 8., 42., 48., 56., 336.]]) The features of X have been transformed from&nbsp;(X1,X2,X3)&nbsp;to&nbsp;(1,X1,X2,X3,X1X2,X1X3,X2X3,X1X2X3). Note that polynomial features are used implicitly in&nbsp;kernel methods&nbsp;(e.g.,&nbsp;sklearn.svm.SVC,&nbsp;sklearn.decomposition.KernelPCA) when using polynomial&nbsp;Kernel functions. See&nbsp;Polynomial interpolation&nbsp;for Ridge regression using created polynomial features. 4.3.8. Custom transformers Often, you will want to convert an existing Python function into a transformer to assist in data cleaning or processing. You can implement a transformer from an arbitrary function with&nbsp;FunctionTransformer. For example, to build a transformer that applies a log transformation in a pipeline, do: &gt;&gt;&gt; &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; from sklearn.preprocessing import FunctionTransformer &gt;&gt;&gt; transformer = FunctionTransformer(np.log1p, validate=True) &gt;&gt;&gt; X = np.array([[0, 1], [2, 3]]) &gt;&gt;&gt; transformer.transform(X) array([[0. , 0.69314718], [1.09861229, 1.38629436]]) You can ensure that&nbsp;func&nbsp;and&nbsp;inverse_func&nbsp;are the inverse of each other by setting&nbsp;check_inverse=True&nbsp;and calling&nbsp;fit&nbsp;before&nbsp;transform. Please note that a warning is raised and can be turned into an error with a&nbsp;filterwarnings: &gt;&gt;&gt; &gt;&gt;&gt; import warnings &gt;&gt;&gt; warnings.filterwarnings(&quot;error&quot;, message=&quot;.*check_inverse*.&quot;, ... category=UserWarning, append=False)" />
<meta property="og:description" content="参考官方文档：https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing 4.3. Preprocessing data The&nbsp;sklearn.preprocessing&nbsp;package provides several common utility functions and transformer classes to change raw feature vectors into a representation that is more suitable for the downstream estimators. In general, learning algorithms benefit from standardization of the data set. If some outliers are present in the set, robust scalers or transformers are more appropriate. The behaviors of the different scalers, transformers, and normalizers on a dataset containing marginal outliers is highlighted in&nbsp;Compare the effect of different scalers on data with outliers. 4.3.1. Standardization, or mean removal and variance scaling Standardization&nbsp;of datasets is a&nbsp;common requirement for many machine learning estimators&nbsp;implemented in scikit-learn; they might behave badly if the individual features do not more or less look like standard normally distributed data: Gaussian with&nbsp;zero mean and unit variance. In practice we often ignore the shape of the distribution and just transform the data to center it by removing the mean value of each feature, then scale it by dividing non-constant features by their standard deviation. For instance, many elements used in the objective function of a learning algorithm (such as the RBF kernel of Support Vector Machines or the l1 and l2 regularizers of linear models) assume that all features are centered around zero and have variance in the same order. If a feature has a variance that is orders of magnitude larger than others, it might dominate the objective function and make the estimator unable to learn from other features correctly as expected. The function&nbsp;scale&nbsp;provides a quick and easy way to perform this operation on a single array-like dataset: &gt;&gt;&gt; &gt;&gt;&gt; from sklearn import preprocessing &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; X_train = np.array([[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]]) &gt;&gt;&gt; X_scaled = preprocessing.scale(X_train) &gt;&gt;&gt; X_scaled array([[ 0. ..., -1.22..., 1.33...], [ 1.22..., 0. ..., -0.26...], [-1.22..., 1.22..., -1.06...]]) Scaled data has zero mean and unit variance: &gt;&gt;&gt; &gt;&gt;&gt; X_scaled.mean(axis=0) array([0., 0., 0.]) &gt;&gt;&gt; X_scaled.std(axis=0) array([1., 1., 1.]) The&nbsp;preprocessing&nbsp;module further provides a utility class&nbsp;StandardScaler&nbsp;that implements the&nbsp;Transformer&nbsp;API to compute the mean and standard deviation on a training set so as to be able to later reapply the same transformation on the testing set. This class is hence suitable for use in the early steps of a&nbsp;sklearn.pipeline.Pipeline: &gt;&gt;&gt; &gt;&gt;&gt; scaler = preprocessing.StandardScaler().fit(X_train) &gt;&gt;&gt; scaler StandardScaler(copy=True, with_mean=True, with_std=True) &gt;&gt;&gt; scaler.mean_ array([1. ..., 0. ..., 0.33...]) &gt;&gt;&gt; scaler.scale_ array([0.81..., 0.81..., 1.24...]) &gt;&gt;&gt; scaler.transform(X_train) array([[ 0. ..., -1.22..., 1.33...], [ 1.22..., 0. ..., -0.26...], [-1.22..., 1.22..., -1.06...]]) The scaler instance can then be used on new data to transform it the same way it did on the training set: &gt;&gt;&gt; &gt;&gt;&gt; X_test = [[-1., 1., 0.]] &gt;&gt;&gt; scaler.transform(X_test) array([[-2.44..., 1.22..., -0.26...]]) It is possible to disable either centering or scaling by either passing&nbsp;with_mean=False&nbsp;or&nbsp;with_std=False&nbsp;to the constructor of&nbsp;StandardScaler. 4.3.1.1. Scaling features to a range An alternative standardization is scaling features to lie between a given minimum and maximum value, often between zero and one, or so that the maximum absolute value of each feature is scaled to unit size. This can be achieved using&nbsp;MinMaxScaler&nbsp;or&nbsp;MaxAbsScaler, respectively. The motivation to use this scaling include robustness to very small standard deviations of features and preserving zero entries in sparse data. Here is an example to scale a toy data matrix to the&nbsp;[0,&nbsp;1]&nbsp;range: &gt;&gt;&gt; &gt;&gt;&gt; X_train = np.array([[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]]) ... &gt;&gt;&gt; min_max_scaler = preprocessing.MinMaxScaler() &gt;&gt;&gt; X_train_minmax = min_max_scaler.fit_transform(X_train) &gt;&gt;&gt; X_train_minmax array([[0.5 , 0. , 1. ], [1. , 0.5 , 0.33333333], [0. , 1. , 0. ]]) The same instance of the transformer can then be applied to some new test data unseen during the fit call: the same scaling and shifting operations will be applied to be consistent with the transformation performed on the train data: &gt;&gt;&gt; &gt;&gt;&gt; X_test = np.array([[-3., -1., 4.]]) &gt;&gt;&gt; X_test_minmax = min_max_scaler.transform(X_test) &gt;&gt;&gt; X_test_minmax array([[-1.5 , 0. , 1.66666667]]) It is possible to introspect the scaler attributes to find about the exact nature of the transformation learned on the training data: &gt;&gt;&gt; &gt;&gt;&gt; min_max_scaler.scale_ array([0.5 , 0.5 , 0.33...]) &gt;&gt;&gt; min_max_scaler.min_ array([0. , 0.5 , 0.33...]) If&nbsp;MinMaxScaler&nbsp;is given an explicit&nbsp;feature_range=(min,&nbsp;max)&nbsp;the full formula is: X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0)) X_scaled = X_std * (max - min) + min MaxAbsScaler&nbsp;works in a very similar fashion, but scales in a way that the training data lies within the range&nbsp;[-1,&nbsp;1]&nbsp;by dividing through the largest maximum value in each feature. It is meant for data that is already centered at zero or sparse data. Here is how to use the toy data from the previous example with this scaler: &gt;&gt;&gt; &gt;&gt;&gt; X_train = np.array([[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]]) ... &gt;&gt;&gt; max_abs_scaler = preprocessing.MaxAbsScaler() &gt;&gt;&gt; X_train_maxabs = max_abs_scaler.fit_transform(X_train) &gt;&gt;&gt; X_train_maxabs # doctest +NORMALIZE_WHITESPACE^ array([[ 0.5, -1. , 1. ], [ 1. , 0. , 0. ], [ 0. , 1. , -0.5]]) &gt;&gt;&gt; X_test = np.array([[ -3., -1., 4.]]) &gt;&gt;&gt; X_test_maxabs = max_abs_scaler.transform(X_test) &gt;&gt;&gt; X_test_maxabs array([[-1.5, -1. , 2. ]]) &gt;&gt;&gt; max_abs_scaler.scale_ array([2., 1., 2.]) As with&nbsp;scale, the module further provides convenience functions&nbsp;minmax_scale&nbsp;and&nbsp;maxabs_scale&nbsp;if you don’t want to create an object. 4.3.1.2. Scaling sparse data Centering sparse data would destroy the sparseness structure in the data, and thus rarely is a sensible thing to do. However, it can make sense to scale sparse inputs, especially if features are on different scales. MaxAbsScaler&nbsp;and&nbsp;maxabs_scale&nbsp;were specifically designed for scaling sparse data, and are the recommended way to go about this. However,&nbsp;scale&nbsp;and&nbsp;StandardScaler&nbsp;can accept&nbsp;scipy.sparse&nbsp;matrices as input, as long as&nbsp;with_mean=False&nbsp;is explicitly passed to the constructor. Otherwise a&nbsp;ValueError&nbsp;will be raised as silently centering would break the sparsity and would often crash the execution by allocating excessive amounts of memory unintentionally.RobustScaler&nbsp;cannot be fitted to sparse inputs, but you can use the&nbsp;transform&nbsp;method on sparse inputs. Note that the scalers accept both Compressed Sparse Rows and Compressed Sparse Columns format (see&nbsp;scipy.sparse.csr_matrix&nbsp;and&nbsp;scipy.sparse.csc_matrix). Any other sparse input will be&nbsp;converted to the Compressed Sparse Rows representation. To avoid unnecessary memory copies, it is recommended to choose the CSR or CSC representation upstream. Finally, if the centered data is expected to be small enough, explicitly converting the input to an array using the&nbsp;toarraymethod of sparse matrices is another option. 4.3.1.3. Scaling data with outliers If your data contains many outliers, scaling using the mean and variance of the data is likely to not work very well. In these cases, you can use&nbsp;robust_scale&nbsp;and&nbsp;RobustScaler&nbsp;as drop-in replacements instead. They use more robust estimates for the center and range of your data. References: Further discussion on the importance of centering and scaling data is available on this FAQ:&nbsp;Should I normalize/standardize/rescale the data? Scaling vs Whitening It is sometimes not enough to center and scale the features independently, since a downstream model can further make some assumption on the linear independence of the features. To address this issue you can use&nbsp;sklearn.decomposition.PCA&nbsp;with&nbsp;whiten=True&nbsp;to further remove the linear correlation across features. Scaling a 1D array All above functions (i.e.&nbsp;scale,&nbsp;minmax_scale,&nbsp;maxabs_scale, and&nbsp;robust_scale) accept 1D array which can be useful in some specific case. 4.3.1.4. Centering kernel matrices If you have a kernel matrix of a kernel&nbsp;K&nbsp;that computes a dot product in a feature space defined by function&nbsp;phi, a&nbsp;KernelCenterer&nbsp;can transform the kernel matrix so that it contains inner products in the feature space defined by&nbsp;phifollowed by removal of the mean in that space. 4.3.2. Non-linear transformation 4.3.2.1. Mapping to a Uniform distribution Like scalers,&nbsp;QuantileTransformer&nbsp;puts all features into the same, known range or distribution. However, by performing a rank transformation, it smooths out unusual distributions and is less influenced by outliers than scaling methods. It does, however, distort correlations and distances within and across features. QuantileTransformer&nbsp;and&nbsp;quantile_transform&nbsp;provide a non-parametric transformation based on the quantile function to map the data to a uniform distribution with values between 0 and 1: &gt;&gt;&gt; &gt;&gt;&gt; from sklearn.datasets import load_iris &gt;&gt;&gt; from sklearn.model_selection import train_test_split &gt;&gt;&gt; iris = load_iris() &gt;&gt;&gt; X, y = iris.data, iris.target &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0) &gt;&gt;&gt; quantile_transformer = preprocessing.QuantileTransformer(random_state=0) &gt;&gt;&gt; X_train_trans = quantile_transformer.fit_transform(X_train) &gt;&gt;&gt; X_test_trans = quantile_transformer.transform(X_test) &gt;&gt;&gt; np.percentile(X_train[:, 0], [0, 25, 50, 75, 100]) array([ 4.3, 5.1, 5.8, 6.5, 7.9]) This feature corresponds to the sepal length in cm. Once the quantile transformation applied, those landmarks approach closely the percentiles previously defined: &gt;&gt;&gt; &gt;&gt;&gt; np.percentile(X_train_trans[:, 0], [0, 25, 50, 75, 100]) ... array([ 0.00... , 0.24..., 0.49..., 0.73..., 0.99... ]) This can be confirmed on a independent testing set with similar remarks: &gt;&gt;&gt; &gt;&gt;&gt; np.percentile(X_test[:, 0], [0, 25, 50, 75, 100]) ... array([ 4.4 , 5.125, 5.75 , 6.175, 7.3 ]) &gt;&gt;&gt; np.percentile(X_test_trans[:, 0], [0, 25, 50, 75, 100]) ... array([ 0.01..., 0.25..., 0.46..., 0.60... , 0.94...]) 4.3.2.2. Mapping to a Gaussian distribution In many modeling scenarios, normality of the features in a dataset is desirable. Power transforms are a family of parametric, monotonic transformations that aim to map data from any distribution to as close to a Gaussian distribution as possible in order to stabilize variance and minimize skewness. PowerTransformer&nbsp;currently provides two such power transformations, the Yeo-Johnson transform and the Box-Cox transform. The Yeo-Johnson transform is given by: xi(λ)={[(xi+1)λ−1]/λif&nbsp;λ≠0,xi≥0,ln⁡(xi)+1if&nbsp;λ=0,xi≥0−[(−xi+1)2−λ−1]/(2−λ)if&nbsp;λ≠2,xi&lt;0,−ln⁡(−xi+1)if&nbsp;λ=2,xi&lt;0 while the Box-Cox transform is given by: xi(λ)={xiλ−1λif&nbsp;λ≠0,ln⁡(xi)if&nbsp;λ=0, Box-Cox can only be applied to strictly positive data. In both methods, the transformation is parameterized by&nbsp;λ, which is determined through maximum likelihood estimation. Here is an example of using Box-Cox to map samples drawn from a lognormal distribution to a normal distribution: &gt;&gt;&gt; &gt;&gt;&gt; pt = preprocessing.PowerTransformer(method=&#39;box-cox&#39;, standardize=False) &gt;&gt;&gt; X_lognormal = np.random.RandomState(616).lognormal(size=(3, 3)) &gt;&gt;&gt; X_lognormal array([[1.28..., 1.18..., 0.84...], [0.94..., 1.60..., 0.38...], [1.35..., 0.21..., 1.09...]]) &gt;&gt;&gt; pt.fit_transform(X_lognormal) array([[ 0.49..., 0.17..., -0.15...], [-0.05..., 0.58..., -0.57...], [ 0.69..., -0.84..., 0.10...]]) While the above example sets the&nbsp;standardize&nbsp;option to&nbsp;False,&nbsp;PowerTransformer&nbsp;will apply zero-mean, unit-variance normalization to the transformed output by default. Below are examples of Box-Cox and Yeo-Johnson applied to various probability distributions. Note that when applied to certain distributions, the power transforms achieve very Gaussian-like results, but with others, they are ineffective. This highlights the importance of visualizing the data before and after transformation. It is also possible to map data to a normal distribution using&nbsp;QuantileTransformer&nbsp;by setting&nbsp;output_distribution=&#39;normal&#39;. Using the earlier example with the iris dataset: &gt;&gt;&gt; &gt;&gt;&gt; quantile_transformer = preprocessing.QuantileTransformer( ... output_distribution=&#39;normal&#39;, random_state=0) &gt;&gt;&gt; X_trans = quantile_transformer.fit_transform(X) &gt;&gt;&gt; quantile_transformer.quantiles_ array([[4.3..., 2..., 1..., 0.1...], [4.31..., 2.02..., 1.01..., 0.1...], [4.32..., 2.05..., 1.02..., 0.1...], ..., [7.84..., 4.34..., 6.84..., 2.5...], [7.87..., 4.37..., 6.87..., 2.5...], [7.9..., 4.4..., 6.9..., 2.5...]]) Thus the median of the input becomes the mean of the output, centered at 0. The normal output is clipped so that the input’s minimum and maximum — corresponding to the 1e-7 and 1 - 1e-7 quantiles respectively — do not become infinite under the transformation. 4.3.3. Normalization Normalization&nbsp;is the process of&nbsp;scaling individual samples to have unit norm. This process can be useful if you plan to use a quadratic form such as the dot-product or any other kernel to quantify the similarity of any pair of samples. This assumption is the base of the&nbsp;Vector Space Model&nbsp;often used in text classification and clustering contexts. The function&nbsp;normalize&nbsp;provides a quick and easy way to perform this operation on a single array-like dataset, either using the&nbsp;l1&nbsp;or&nbsp;l2&nbsp;norms: &gt;&gt;&gt; &gt;&gt;&gt; X = [[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]] &gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm=&#39;l2&#39;) &gt;&gt;&gt; X_normalized array([[ 0.40..., -0.40..., 0.81...], [ 1. ..., 0. ..., 0. ...], [ 0. ..., 0.70..., -0.70...]]) The&nbsp;preprocessing&nbsp;module further provides a utility class&nbsp;Normalizer&nbsp;that implements the same operation using theTransformer&nbsp;API (even though the&nbsp;fit&nbsp;method is useless in this case: the class is stateless as this operation treats samples independently). This class is hence suitable for use in the early steps of a&nbsp;sklearn.pipeline.Pipeline: &gt;&gt;&gt; &gt;&gt;&gt; normalizer = preprocessing.Normalizer().fit(X) # fit does nothing &gt;&gt;&gt; normalizer Normalizer(copy=True, norm=&#39;l2&#39;) The normalizer instance can then be used on sample vectors as any transformer: &gt;&gt;&gt; &gt;&gt;&gt; normalizer.transform(X) array([[ 0.40..., -0.40..., 0.81...], [ 1. ..., 0. ..., 0. ...], [ 0. ..., 0.70..., -0.70...]]) &gt;&gt;&gt; normalizer.transform([[-1., 1., 0.]]) array([[-0.70..., 0.70..., 0. ...]]) Sparse input normalize&nbsp;and&nbsp;Normalizer&nbsp;accept&nbsp;both dense array-like and sparse matrices from scipy.sparse as input. For sparse input the data is&nbsp;converted to the Compressed Sparse Rows representation&nbsp;(see&nbsp;scipy.sparse.csr_matrix) before being fed to efficient Cython routines. To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream. 4.3.4. Encoding categorical features Often features are not given as continuous values but categorical. For example a person could have features&nbsp;[&quot;male&quot;,&nbsp;&quot;female&quot;],&nbsp;[&quot;from&nbsp;Europe&quot;,&nbsp;&quot;from&nbsp;US&quot;,&nbsp;&quot;from&nbsp;Asia&quot;],[&quot;uses&nbsp;Firefox&quot;,&nbsp;&quot;uses&nbsp;Chrome&quot;,&nbsp;&quot;uses&nbsp;Safari&quot;,&nbsp;&quot;uses&nbsp;Internet&nbsp;Explorer&quot;]. Such features can be efficiently coded as integers, for instance&nbsp;[&quot;male&quot;,&nbsp;&quot;from&nbsp;US&quot;,&nbsp;&quot;uses&nbsp;Internet&nbsp;Explorer&quot;]&nbsp;could be expressed as&nbsp;[0,&nbsp;1,&nbsp;3]while&nbsp;[&quot;female&quot;,&nbsp;&quot;from&nbsp;Asia&quot;,&nbsp;&quot;uses&nbsp;Chrome&quot;]&nbsp;would be&nbsp;[1,&nbsp;2,&nbsp;1]. To convert categorical features to such integer codes, we can use the&nbsp;OrdinalEncoder. This estimator transforms each categorical feature to one new feature of integers (0 to n_categories - 1): &gt;&gt;&gt; &gt;&gt;&gt; enc = preprocessing.OrdinalEncoder() &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OrdinalEncoder(categories=&#39;auto&#39;, dtype=&lt;... &#39;numpy.float64&#39;&gt;) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from US&#39;, &#39;uses Safari&#39;]]) array([[0., 1., 1.]]) Such integer representation can, however, not be used directly with all scikit-learn estimators, as these expect continuous input, and would interpret the categories as being ordered, which is often not desired (i.e. the set of browsers was ordered arbitrarily). Another possibility to convert categorical features to features that can be used with scikit-learn estimators is to use a one-of-K, also known as one-hot or dummy encoding. This type of encoding can be obtained with the&nbsp;OneHotEncoder, which transforms each categorical feature with&nbsp;n_categories&nbsp;possible values into&nbsp;n_categories&nbsp;binary features, with one of them 1, and all others 0. Continuing the example above: &gt;&gt;&gt; &gt;&gt;&gt; enc = preprocessing.OneHotEncoder() &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OneHotEncoder(categorical_features=None, categories=None, dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;error&#39;, n_values=None, sparse=True) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], ... [&#39;male&#39;, &#39;from Europe&#39;, &#39;uses Safari&#39;]]).toarray() array([[1., 0., 0., 1., 0., 1.], [0., 1., 1., 0., 0., 1.]]) By default, the values each feature can take is inferred automatically from the dataset and can be found in the&nbsp;categories_&nbsp;attribute: &gt;&gt;&gt; &gt;&gt;&gt; enc.categories_ [array([&#39;female&#39;, &#39;male&#39;], dtype=object), array([&#39;from Europe&#39;, &#39;from US&#39;], dtype=object), array([&#39;uses Firefox&#39;, &#39;uses Safari&#39;], dtype=object)] It is possible to specify this explicitly using the parameter&nbsp;categories. There are two genders, four possible continents and four web browsers in our dataset: &gt;&gt;&gt; &gt;&gt;&gt; genders = [&#39;female&#39;, &#39;male&#39;] &gt;&gt;&gt; locations = [&#39;from Africa&#39;, &#39;from Asia&#39;, &#39;from Europe&#39;, &#39;from US&#39;] &gt;&gt;&gt; browsers = [&#39;uses Chrome&#39;, &#39;uses Firefox&#39;, &#39;uses IE&#39;, &#39;uses Safari&#39;] &gt;&gt;&gt; enc = preprocessing.OneHotEncoder(categories=[genders, locations, browsers]) &gt;&gt;&gt; # Note that for there are missing categorical values for the 2nd and 3rd &gt;&gt;&gt; # feature &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OneHotEncoder(categorical_features=None, categories=[...], dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;error&#39;, n_values=None, sparse=True) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from Asia&#39;, &#39;uses Chrome&#39;]]).toarray() array([[1., 0., 0., 1., 0., 0., 1., 0., 0., 0.]]) If there is a possibility that the training data might have missing categorical features, it can often be better to specify&nbsp;handle_unknown=&#39;ignore&#39;&nbsp;instead of setting the&nbsp;categories&nbsp;manually as above. When&nbsp;handle_unknown=&#39;ignore&#39;&nbsp;is specified and unknown categories are encountered during transform, no error will be raised but the resulting one-hot encoded columns for this feature will be all zeros (handle_unknown=&#39;ignore&#39;&nbsp;is only supported for one-hot encoding): &gt;&gt;&gt; &gt;&gt;&gt; enc = preprocessing.OneHotEncoder(handle_unknown=&#39;ignore&#39;) &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OneHotEncoder(categorical_features=None, categories=None, dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;ignore&#39;, n_values=None, sparse=True) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from Asia&#39;, &#39;uses Chrome&#39;]]).toarray() array([[1., 0., 0., 0., 0., 0.]]) See&nbsp;Loading features from dicts&nbsp;for categorical features that are represented as a dict, not as scalars. 4.3.5. Discretization Discretization&nbsp;(otherwise known as quantization or binning) provides a way to partition continuous features into discrete values. Certain datasets with continuous features may benefit from discretization, because discretization can transform the dataset of continuous attributes to one with only nominal attributes. One-hot encoded discretized features can make a model more expressive, while maintaining interpretability. For instance, pre-processing with a discretizer can introduce nonlinearity to linear models. 4.3.5.1. K-bins discretization KBinsDiscretizer&nbsp;discretizers features into&nbsp;k&nbsp;equal width bins: &gt;&gt;&gt; &gt;&gt;&gt; X = np.array([[ -3., 5., 15 ], ... [ 0., 6., 14 ], ... [ 6., 3., 11 ]]) &gt;&gt;&gt; est = preprocessing.KBinsDiscretizer(n_bins=[3, 2, 2], encode=&#39;ordinal&#39;).fit(X) By default the output is one-hot encoded into a sparse matrix (See&nbsp;Encoding categorical features) and this can be configured with the&nbsp;encode&nbsp;parameter. For each feature, the bin edges are computed during&nbsp;fit&nbsp;and together with the number of bins, they will define the intervals. Therefore, for the current example, these intervals are defined as: feature 1:&nbsp;[−∞,−1),[−1,2),[2,∞) feature 2:&nbsp;[−∞,5),[5,∞) feature 3:&nbsp;[−∞,14),[14,∞) Based on these bin intervals,&nbsp;X&nbsp;is transformed as follows: &gt;&gt;&gt; &gt;&gt;&gt; est.transform(X) array([[ 0., 1., 1.], [ 1., 1., 1.], [ 2., 0., 0.]]) The resulting dataset contains ordinal attributes which can be further used in a&nbsp;sklearn.pipeline.Pipeline. Discretization is similar to constructing histograms for continuous data. However, histograms focus on counting features which fall into particular bins, whereas discretization focuses on assigning feature values to these bins. KBinsDiscretizer&nbsp;implements different binning strategies, which can be selected with the&nbsp;strategy&nbsp;parameter. The ‘uniform’ strategy uses constant-width bins. The ‘quantile’ strategy uses the quantiles values to have equally populated bins in each feature. The ‘kmeans’ strategy defines bins based on a k-means clustering procedure performed on each feature independently. Examples: Using KBinsDiscretizer to discretize continuous features Feature discretization Demonstrating the different strategies of KBinsDiscretizer 4.3.5.2. Feature binarization Feature binarization&nbsp;is the process of&nbsp;thresholding numerical features to get boolean values. This can be useful for downstream probabilistic estimators that make assumption that the input data is distributed according to a multi-variate&nbsp;Bernoulli distribution. For instance, this is the case for the&nbsp;sklearn.neural_network.BernoulliRBM. It is also common among the text processing community to use binary feature values (probably to simplify the probabilistic reasoning) even if normalized counts (a.k.a. term frequencies) or TF-IDF valued features often perform slightly better in practice. As for the&nbsp;Normalizer, the utility class&nbsp;Binarizer&nbsp;is meant to be used in the early stages ofsklearn.pipeline.Pipeline. The&nbsp;fit&nbsp;method does nothing as each sample is treated independently of others: &gt;&gt;&gt; &gt;&gt;&gt; X = [[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]] &gt;&gt;&gt; binarizer = preprocessing.Binarizer().fit(X) # fit does nothing &gt;&gt;&gt; binarizer Binarizer(copy=True, threshold=0.0) &gt;&gt;&gt; binarizer.transform(X) array([[1., 0., 1.], [1., 0., 0.], [0., 1., 0.]]) It is possible to adjust the threshold of the binarizer: &gt;&gt;&gt; &gt;&gt;&gt; binarizer = preprocessing.Binarizer(threshold=1.1) &gt;&gt;&gt; binarizer.transform(X) array([[0., 0., 1.], [1., 0., 0.], [0., 0., 0.]]) As for the&nbsp;StandardScaler&nbsp;and&nbsp;Normalizer&nbsp;classes, the preprocessing module provides a companion function&nbsp;binarize&nbsp;to be used when the transformer API is not necessary. Note that the&nbsp;Binarizer&nbsp;is similar to the&nbsp;KBinsDiscretizer&nbsp;when&nbsp;k&nbsp;=&nbsp;2, and when the bin edge is at the value&nbsp;threshold. Sparse input binarize&nbsp;and&nbsp;Binarizer&nbsp;accept&nbsp;both dense array-like and sparse matrices from scipy.sparse as input. For sparse input the data is&nbsp;converted to the Compressed Sparse Rows representation&nbsp;(see&nbsp;scipy.sparse.csr_matrix). To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream. 4.3.6. Imputation of missing values Tools for imputing missing values are discussed at&nbsp;Imputation of missing values. 4.3.7. Generating polynomial features Often it’s useful to add complexity to the model by considering nonlinear features of the input data. A simple and common method to use is polynomial features, which can get features’ high-order and interaction terms. It is implemented in&nbsp;PolynomialFeatures: &gt;&gt;&gt; &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; from sklearn.preprocessing import PolynomialFeatures &gt;&gt;&gt; X = np.arange(6).reshape(3, 2) &gt;&gt;&gt; X array([[0, 1], [2, 3], [4, 5]]) &gt;&gt;&gt; poly = PolynomialFeatures(2) &gt;&gt;&gt; poly.fit_transform(X) array([[ 1., 0., 1., 0., 0., 1.], [ 1., 2., 3., 4., 6., 9.], [ 1., 4., 5., 16., 20., 25.]]) The features of X have been transformed from&nbsp;(X1,X2)&nbsp;to&nbsp;(1,X1,X2,X12,X1X2,X22). In some cases, only interaction terms among features are required, and it can be gotten with the setting&nbsp;interaction_only=True: &gt;&gt;&gt; &gt;&gt;&gt; X = np.arange(9).reshape(3, 3) &gt;&gt;&gt; X array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) &gt;&gt;&gt; poly = PolynomialFeatures(degree=3, interaction_only=True) &gt;&gt;&gt; poly.fit_transform(X) array([[ 1., 0., 1., 2., 0., 0., 2., 0.], [ 1., 3., 4., 5., 12., 15., 20., 60.], [ 1., 6., 7., 8., 42., 48., 56., 336.]]) The features of X have been transformed from&nbsp;(X1,X2,X3)&nbsp;to&nbsp;(1,X1,X2,X3,X1X2,X1X3,X2X3,X1X2X3). Note that polynomial features are used implicitly in&nbsp;kernel methods&nbsp;(e.g.,&nbsp;sklearn.svm.SVC,&nbsp;sklearn.decomposition.KernelPCA) when using polynomial&nbsp;Kernel functions. See&nbsp;Polynomial interpolation&nbsp;for Ridge regression using created polynomial features. 4.3.8. Custom transformers Often, you will want to convert an existing Python function into a transformer to assist in data cleaning or processing. You can implement a transformer from an arbitrary function with&nbsp;FunctionTransformer. For example, to build a transformer that applies a log transformation in a pipeline, do: &gt;&gt;&gt; &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; from sklearn.preprocessing import FunctionTransformer &gt;&gt;&gt; transformer = FunctionTransformer(np.log1p, validate=True) &gt;&gt;&gt; X = np.array([[0, 1], [2, 3]]) &gt;&gt;&gt; transformer.transform(X) array([[0. , 0.69314718], [1.09861229, 1.38629436]]) You can ensure that&nbsp;func&nbsp;and&nbsp;inverse_func&nbsp;are the inverse of each other by setting&nbsp;check_inverse=True&nbsp;and calling&nbsp;fit&nbsp;before&nbsp;transform. Please note that a warning is raised and can be turned into an error with a&nbsp;filterwarnings: &gt;&gt;&gt; &gt;&gt;&gt; import warnings &gt;&gt;&gt; warnings.filterwarnings(&quot;error&quot;, message=&quot;.*check_inverse*.&quot;, ... category=UserWarning, append=False)" />
<link rel="canonical" href="https://mlh.app/2019/04/07/727268.html" />
<meta property="og:url" content="https://mlh.app/2019/04/07/727268.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-07T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"参考官方文档：https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing 4.3. Preprocessing data The&nbsp;sklearn.preprocessing&nbsp;package provides several common utility functions and transformer classes to change raw feature vectors into a representation that is more suitable for the downstream estimators. In general, learning algorithms benefit from standardization of the data set. If some outliers are present in the set, robust scalers or transformers are more appropriate. The behaviors of the different scalers, transformers, and normalizers on a dataset containing marginal outliers is highlighted in&nbsp;Compare the effect of different scalers on data with outliers. 4.3.1. Standardization, or mean removal and variance scaling Standardization&nbsp;of datasets is a&nbsp;common requirement for many machine learning estimators&nbsp;implemented in scikit-learn; they might behave badly if the individual features do not more or less look like standard normally distributed data: Gaussian with&nbsp;zero mean and unit variance. In practice we often ignore the shape of the distribution and just transform the data to center it by removing the mean value of each feature, then scale it by dividing non-constant features by their standard deviation. For instance, many elements used in the objective function of a learning algorithm (such as the RBF kernel of Support Vector Machines or the l1 and l2 regularizers of linear models) assume that all features are centered around zero and have variance in the same order. If a feature has a variance that is orders of magnitude larger than others, it might dominate the objective function and make the estimator unable to learn from other features correctly as expected. The function&nbsp;scale&nbsp;provides a quick and easy way to perform this operation on a single array-like dataset: &gt;&gt;&gt; &gt;&gt;&gt; from sklearn import preprocessing &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; X_train = np.array([[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]]) &gt;&gt;&gt; X_scaled = preprocessing.scale(X_train) &gt;&gt;&gt; X_scaled array([[ 0. ..., -1.22..., 1.33...], [ 1.22..., 0. ..., -0.26...], [-1.22..., 1.22..., -1.06...]]) Scaled data has zero mean and unit variance: &gt;&gt;&gt; &gt;&gt;&gt; X_scaled.mean(axis=0) array([0., 0., 0.]) &gt;&gt;&gt; X_scaled.std(axis=0) array([1., 1., 1.]) The&nbsp;preprocessing&nbsp;module further provides a utility class&nbsp;StandardScaler&nbsp;that implements the&nbsp;Transformer&nbsp;API to compute the mean and standard deviation on a training set so as to be able to later reapply the same transformation on the testing set. This class is hence suitable for use in the early steps of a&nbsp;sklearn.pipeline.Pipeline: &gt;&gt;&gt; &gt;&gt;&gt; scaler = preprocessing.StandardScaler().fit(X_train) &gt;&gt;&gt; scaler StandardScaler(copy=True, with_mean=True, with_std=True) &gt;&gt;&gt; scaler.mean_ array([1. ..., 0. ..., 0.33...]) &gt;&gt;&gt; scaler.scale_ array([0.81..., 0.81..., 1.24...]) &gt;&gt;&gt; scaler.transform(X_train) array([[ 0. ..., -1.22..., 1.33...], [ 1.22..., 0. ..., -0.26...], [-1.22..., 1.22..., -1.06...]]) The scaler instance can then be used on new data to transform it the same way it did on the training set: &gt;&gt;&gt; &gt;&gt;&gt; X_test = [[-1., 1., 0.]] &gt;&gt;&gt; scaler.transform(X_test) array([[-2.44..., 1.22..., -0.26...]]) It is possible to disable either centering or scaling by either passing&nbsp;with_mean=False&nbsp;or&nbsp;with_std=False&nbsp;to the constructor of&nbsp;StandardScaler. 4.3.1.1. Scaling features to a range An alternative standardization is scaling features to lie between a given minimum and maximum value, often between zero and one, or so that the maximum absolute value of each feature is scaled to unit size. This can be achieved using&nbsp;MinMaxScaler&nbsp;or&nbsp;MaxAbsScaler, respectively. The motivation to use this scaling include robustness to very small standard deviations of features and preserving zero entries in sparse data. Here is an example to scale a toy data matrix to the&nbsp;[0,&nbsp;1]&nbsp;range: &gt;&gt;&gt; &gt;&gt;&gt; X_train = np.array([[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]]) ... &gt;&gt;&gt; min_max_scaler = preprocessing.MinMaxScaler() &gt;&gt;&gt; X_train_minmax = min_max_scaler.fit_transform(X_train) &gt;&gt;&gt; X_train_minmax array([[0.5 , 0. , 1. ], [1. , 0.5 , 0.33333333], [0. , 1. , 0. ]]) The same instance of the transformer can then be applied to some new test data unseen during the fit call: the same scaling and shifting operations will be applied to be consistent with the transformation performed on the train data: &gt;&gt;&gt; &gt;&gt;&gt; X_test = np.array([[-3., -1., 4.]]) &gt;&gt;&gt; X_test_minmax = min_max_scaler.transform(X_test) &gt;&gt;&gt; X_test_minmax array([[-1.5 , 0. , 1.66666667]]) It is possible to introspect the scaler attributes to find about the exact nature of the transformation learned on the training data: &gt;&gt;&gt; &gt;&gt;&gt; min_max_scaler.scale_ array([0.5 , 0.5 , 0.33...]) &gt;&gt;&gt; min_max_scaler.min_ array([0. , 0.5 , 0.33...]) If&nbsp;MinMaxScaler&nbsp;is given an explicit&nbsp;feature_range=(min,&nbsp;max)&nbsp;the full formula is: X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0)) X_scaled = X_std * (max - min) + min MaxAbsScaler&nbsp;works in a very similar fashion, but scales in a way that the training data lies within the range&nbsp;[-1,&nbsp;1]&nbsp;by dividing through the largest maximum value in each feature. It is meant for data that is already centered at zero or sparse data. Here is how to use the toy data from the previous example with this scaler: &gt;&gt;&gt; &gt;&gt;&gt; X_train = np.array([[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]]) ... &gt;&gt;&gt; max_abs_scaler = preprocessing.MaxAbsScaler() &gt;&gt;&gt; X_train_maxabs = max_abs_scaler.fit_transform(X_train) &gt;&gt;&gt; X_train_maxabs # doctest +NORMALIZE_WHITESPACE^ array([[ 0.5, -1. , 1. ], [ 1. , 0. , 0. ], [ 0. , 1. , -0.5]]) &gt;&gt;&gt; X_test = np.array([[ -3., -1., 4.]]) &gt;&gt;&gt; X_test_maxabs = max_abs_scaler.transform(X_test) &gt;&gt;&gt; X_test_maxabs array([[-1.5, -1. , 2. ]]) &gt;&gt;&gt; max_abs_scaler.scale_ array([2., 1., 2.]) As with&nbsp;scale, the module further provides convenience functions&nbsp;minmax_scale&nbsp;and&nbsp;maxabs_scale&nbsp;if you don’t want to create an object. 4.3.1.2. Scaling sparse data Centering sparse data would destroy the sparseness structure in the data, and thus rarely is a sensible thing to do. However, it can make sense to scale sparse inputs, especially if features are on different scales. MaxAbsScaler&nbsp;and&nbsp;maxabs_scale&nbsp;were specifically designed for scaling sparse data, and are the recommended way to go about this. However,&nbsp;scale&nbsp;and&nbsp;StandardScaler&nbsp;can accept&nbsp;scipy.sparse&nbsp;matrices as input, as long as&nbsp;with_mean=False&nbsp;is explicitly passed to the constructor. Otherwise a&nbsp;ValueError&nbsp;will be raised as silently centering would break the sparsity and would often crash the execution by allocating excessive amounts of memory unintentionally.RobustScaler&nbsp;cannot be fitted to sparse inputs, but you can use the&nbsp;transform&nbsp;method on sparse inputs. Note that the scalers accept both Compressed Sparse Rows and Compressed Sparse Columns format (see&nbsp;scipy.sparse.csr_matrix&nbsp;and&nbsp;scipy.sparse.csc_matrix). Any other sparse input will be&nbsp;converted to the Compressed Sparse Rows representation. To avoid unnecessary memory copies, it is recommended to choose the CSR or CSC representation upstream. Finally, if the centered data is expected to be small enough, explicitly converting the input to an array using the&nbsp;toarraymethod of sparse matrices is another option. 4.3.1.3. Scaling data with outliers If your data contains many outliers, scaling using the mean and variance of the data is likely to not work very well. In these cases, you can use&nbsp;robust_scale&nbsp;and&nbsp;RobustScaler&nbsp;as drop-in replacements instead. They use more robust estimates for the center and range of your data. References: Further discussion on the importance of centering and scaling data is available on this FAQ:&nbsp;Should I normalize/standardize/rescale the data? Scaling vs Whitening It is sometimes not enough to center and scale the features independently, since a downstream model can further make some assumption on the linear independence of the features. To address this issue you can use&nbsp;sklearn.decomposition.PCA&nbsp;with&nbsp;whiten=True&nbsp;to further remove the linear correlation across features. Scaling a 1D array All above functions (i.e.&nbsp;scale,&nbsp;minmax_scale,&nbsp;maxabs_scale, and&nbsp;robust_scale) accept 1D array which can be useful in some specific case. 4.3.1.4. Centering kernel matrices If you have a kernel matrix of a kernel&nbsp;K&nbsp;that computes a dot product in a feature space defined by function&nbsp;phi, a&nbsp;KernelCenterer&nbsp;can transform the kernel matrix so that it contains inner products in the feature space defined by&nbsp;phifollowed by removal of the mean in that space. 4.3.2. Non-linear transformation 4.3.2.1. Mapping to a Uniform distribution Like scalers,&nbsp;QuantileTransformer&nbsp;puts all features into the same, known range or distribution. However, by performing a rank transformation, it smooths out unusual distributions and is less influenced by outliers than scaling methods. It does, however, distort correlations and distances within and across features. QuantileTransformer&nbsp;and&nbsp;quantile_transform&nbsp;provide a non-parametric transformation based on the quantile function to map the data to a uniform distribution with values between 0 and 1: &gt;&gt;&gt; &gt;&gt;&gt; from sklearn.datasets import load_iris &gt;&gt;&gt; from sklearn.model_selection import train_test_split &gt;&gt;&gt; iris = load_iris() &gt;&gt;&gt; X, y = iris.data, iris.target &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0) &gt;&gt;&gt; quantile_transformer = preprocessing.QuantileTransformer(random_state=0) &gt;&gt;&gt; X_train_trans = quantile_transformer.fit_transform(X_train) &gt;&gt;&gt; X_test_trans = quantile_transformer.transform(X_test) &gt;&gt;&gt; np.percentile(X_train[:, 0], [0, 25, 50, 75, 100]) array([ 4.3, 5.1, 5.8, 6.5, 7.9]) This feature corresponds to the sepal length in cm. Once the quantile transformation applied, those landmarks approach closely the percentiles previously defined: &gt;&gt;&gt; &gt;&gt;&gt; np.percentile(X_train_trans[:, 0], [0, 25, 50, 75, 100]) ... array([ 0.00... , 0.24..., 0.49..., 0.73..., 0.99... ]) This can be confirmed on a independent testing set with similar remarks: &gt;&gt;&gt; &gt;&gt;&gt; np.percentile(X_test[:, 0], [0, 25, 50, 75, 100]) ... array([ 4.4 , 5.125, 5.75 , 6.175, 7.3 ]) &gt;&gt;&gt; np.percentile(X_test_trans[:, 0], [0, 25, 50, 75, 100]) ... array([ 0.01..., 0.25..., 0.46..., 0.60... , 0.94...]) 4.3.2.2. Mapping to a Gaussian distribution In many modeling scenarios, normality of the features in a dataset is desirable. Power transforms are a family of parametric, monotonic transformations that aim to map data from any distribution to as close to a Gaussian distribution as possible in order to stabilize variance and minimize skewness. PowerTransformer&nbsp;currently provides two such power transformations, the Yeo-Johnson transform and the Box-Cox transform. The Yeo-Johnson transform is given by: xi(λ)={[(xi+1)λ−1]/λif&nbsp;λ≠0,xi≥0,ln⁡(xi)+1if&nbsp;λ=0,xi≥0−[(−xi+1)2−λ−1]/(2−λ)if&nbsp;λ≠2,xi&lt;0,−ln⁡(−xi+1)if&nbsp;λ=2,xi&lt;0 while the Box-Cox transform is given by: xi(λ)={xiλ−1λif&nbsp;λ≠0,ln⁡(xi)if&nbsp;λ=0, Box-Cox can only be applied to strictly positive data. In both methods, the transformation is parameterized by&nbsp;λ, which is determined through maximum likelihood estimation. Here is an example of using Box-Cox to map samples drawn from a lognormal distribution to a normal distribution: &gt;&gt;&gt; &gt;&gt;&gt; pt = preprocessing.PowerTransformer(method=&#39;box-cox&#39;, standardize=False) &gt;&gt;&gt; X_lognormal = np.random.RandomState(616).lognormal(size=(3, 3)) &gt;&gt;&gt; X_lognormal array([[1.28..., 1.18..., 0.84...], [0.94..., 1.60..., 0.38...], [1.35..., 0.21..., 1.09...]]) &gt;&gt;&gt; pt.fit_transform(X_lognormal) array([[ 0.49..., 0.17..., -0.15...], [-0.05..., 0.58..., -0.57...], [ 0.69..., -0.84..., 0.10...]]) While the above example sets the&nbsp;standardize&nbsp;option to&nbsp;False,&nbsp;PowerTransformer&nbsp;will apply zero-mean, unit-variance normalization to the transformed output by default. Below are examples of Box-Cox and Yeo-Johnson applied to various probability distributions. Note that when applied to certain distributions, the power transforms achieve very Gaussian-like results, but with others, they are ineffective. This highlights the importance of visualizing the data before and after transformation. It is also possible to map data to a normal distribution using&nbsp;QuantileTransformer&nbsp;by setting&nbsp;output_distribution=&#39;normal&#39;. Using the earlier example with the iris dataset: &gt;&gt;&gt; &gt;&gt;&gt; quantile_transformer = preprocessing.QuantileTransformer( ... output_distribution=&#39;normal&#39;, random_state=0) &gt;&gt;&gt; X_trans = quantile_transformer.fit_transform(X) &gt;&gt;&gt; quantile_transformer.quantiles_ array([[4.3..., 2..., 1..., 0.1...], [4.31..., 2.02..., 1.01..., 0.1...], [4.32..., 2.05..., 1.02..., 0.1...], ..., [7.84..., 4.34..., 6.84..., 2.5...], [7.87..., 4.37..., 6.87..., 2.5...], [7.9..., 4.4..., 6.9..., 2.5...]]) Thus the median of the input becomes the mean of the output, centered at 0. The normal output is clipped so that the input’s minimum and maximum — corresponding to the 1e-7 and 1 - 1e-7 quantiles respectively — do not become infinite under the transformation. 4.3.3. Normalization Normalization&nbsp;is the process of&nbsp;scaling individual samples to have unit norm. This process can be useful if you plan to use a quadratic form such as the dot-product or any other kernel to quantify the similarity of any pair of samples. This assumption is the base of the&nbsp;Vector Space Model&nbsp;often used in text classification and clustering contexts. The function&nbsp;normalize&nbsp;provides a quick and easy way to perform this operation on a single array-like dataset, either using the&nbsp;l1&nbsp;or&nbsp;l2&nbsp;norms: &gt;&gt;&gt; &gt;&gt;&gt; X = [[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]] &gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm=&#39;l2&#39;) &gt;&gt;&gt; X_normalized array([[ 0.40..., -0.40..., 0.81...], [ 1. ..., 0. ..., 0. ...], [ 0. ..., 0.70..., -0.70...]]) The&nbsp;preprocessing&nbsp;module further provides a utility class&nbsp;Normalizer&nbsp;that implements the same operation using theTransformer&nbsp;API (even though the&nbsp;fit&nbsp;method is useless in this case: the class is stateless as this operation treats samples independently). This class is hence suitable for use in the early steps of a&nbsp;sklearn.pipeline.Pipeline: &gt;&gt;&gt; &gt;&gt;&gt; normalizer = preprocessing.Normalizer().fit(X) # fit does nothing &gt;&gt;&gt; normalizer Normalizer(copy=True, norm=&#39;l2&#39;) The normalizer instance can then be used on sample vectors as any transformer: &gt;&gt;&gt; &gt;&gt;&gt; normalizer.transform(X) array([[ 0.40..., -0.40..., 0.81...], [ 1. ..., 0. ..., 0. ...], [ 0. ..., 0.70..., -0.70...]]) &gt;&gt;&gt; normalizer.transform([[-1., 1., 0.]]) array([[-0.70..., 0.70..., 0. ...]]) Sparse input normalize&nbsp;and&nbsp;Normalizer&nbsp;accept&nbsp;both dense array-like and sparse matrices from scipy.sparse as input. For sparse input the data is&nbsp;converted to the Compressed Sparse Rows representation&nbsp;(see&nbsp;scipy.sparse.csr_matrix) before being fed to efficient Cython routines. To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream. 4.3.4. Encoding categorical features Often features are not given as continuous values but categorical. For example a person could have features&nbsp;[&quot;male&quot;,&nbsp;&quot;female&quot;],&nbsp;[&quot;from&nbsp;Europe&quot;,&nbsp;&quot;from&nbsp;US&quot;,&nbsp;&quot;from&nbsp;Asia&quot;],[&quot;uses&nbsp;Firefox&quot;,&nbsp;&quot;uses&nbsp;Chrome&quot;,&nbsp;&quot;uses&nbsp;Safari&quot;,&nbsp;&quot;uses&nbsp;Internet&nbsp;Explorer&quot;]. Such features can be efficiently coded as integers, for instance&nbsp;[&quot;male&quot;,&nbsp;&quot;from&nbsp;US&quot;,&nbsp;&quot;uses&nbsp;Internet&nbsp;Explorer&quot;]&nbsp;could be expressed as&nbsp;[0,&nbsp;1,&nbsp;3]while&nbsp;[&quot;female&quot;,&nbsp;&quot;from&nbsp;Asia&quot;,&nbsp;&quot;uses&nbsp;Chrome&quot;]&nbsp;would be&nbsp;[1,&nbsp;2,&nbsp;1]. To convert categorical features to such integer codes, we can use the&nbsp;OrdinalEncoder. This estimator transforms each categorical feature to one new feature of integers (0 to n_categories - 1): &gt;&gt;&gt; &gt;&gt;&gt; enc = preprocessing.OrdinalEncoder() &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OrdinalEncoder(categories=&#39;auto&#39;, dtype=&lt;... &#39;numpy.float64&#39;&gt;) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from US&#39;, &#39;uses Safari&#39;]]) array([[0., 1., 1.]]) Such integer representation can, however, not be used directly with all scikit-learn estimators, as these expect continuous input, and would interpret the categories as being ordered, which is often not desired (i.e. the set of browsers was ordered arbitrarily). Another possibility to convert categorical features to features that can be used with scikit-learn estimators is to use a one-of-K, also known as one-hot or dummy encoding. This type of encoding can be obtained with the&nbsp;OneHotEncoder, which transforms each categorical feature with&nbsp;n_categories&nbsp;possible values into&nbsp;n_categories&nbsp;binary features, with one of them 1, and all others 0. Continuing the example above: &gt;&gt;&gt; &gt;&gt;&gt; enc = preprocessing.OneHotEncoder() &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OneHotEncoder(categorical_features=None, categories=None, dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;error&#39;, n_values=None, sparse=True) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], ... [&#39;male&#39;, &#39;from Europe&#39;, &#39;uses Safari&#39;]]).toarray() array([[1., 0., 0., 1., 0., 1.], [0., 1., 1., 0., 0., 1.]]) By default, the values each feature can take is inferred automatically from the dataset and can be found in the&nbsp;categories_&nbsp;attribute: &gt;&gt;&gt; &gt;&gt;&gt; enc.categories_ [array([&#39;female&#39;, &#39;male&#39;], dtype=object), array([&#39;from Europe&#39;, &#39;from US&#39;], dtype=object), array([&#39;uses Firefox&#39;, &#39;uses Safari&#39;], dtype=object)] It is possible to specify this explicitly using the parameter&nbsp;categories. There are two genders, four possible continents and four web browsers in our dataset: &gt;&gt;&gt; &gt;&gt;&gt; genders = [&#39;female&#39;, &#39;male&#39;] &gt;&gt;&gt; locations = [&#39;from Africa&#39;, &#39;from Asia&#39;, &#39;from Europe&#39;, &#39;from US&#39;] &gt;&gt;&gt; browsers = [&#39;uses Chrome&#39;, &#39;uses Firefox&#39;, &#39;uses IE&#39;, &#39;uses Safari&#39;] &gt;&gt;&gt; enc = preprocessing.OneHotEncoder(categories=[genders, locations, browsers]) &gt;&gt;&gt; # Note that for there are missing categorical values for the 2nd and 3rd &gt;&gt;&gt; # feature &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OneHotEncoder(categorical_features=None, categories=[...], dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;error&#39;, n_values=None, sparse=True) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from Asia&#39;, &#39;uses Chrome&#39;]]).toarray() array([[1., 0., 0., 1., 0., 0., 1., 0., 0., 0.]]) If there is a possibility that the training data might have missing categorical features, it can often be better to specify&nbsp;handle_unknown=&#39;ignore&#39;&nbsp;instead of setting the&nbsp;categories&nbsp;manually as above. When&nbsp;handle_unknown=&#39;ignore&#39;&nbsp;is specified and unknown categories are encountered during transform, no error will be raised but the resulting one-hot encoded columns for this feature will be all zeros (handle_unknown=&#39;ignore&#39;&nbsp;is only supported for one-hot encoding): &gt;&gt;&gt; &gt;&gt;&gt; enc = preprocessing.OneHotEncoder(handle_unknown=&#39;ignore&#39;) &gt;&gt;&gt; X = [[&#39;male&#39;, &#39;from US&#39;, &#39;uses Safari&#39;], [&#39;female&#39;, &#39;from Europe&#39;, &#39;uses Firefox&#39;]] &gt;&gt;&gt; enc.fit(X) OneHotEncoder(categorical_features=None, categories=None, dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;ignore&#39;, n_values=None, sparse=True) &gt;&gt;&gt; enc.transform([[&#39;female&#39;, &#39;from Asia&#39;, &#39;uses Chrome&#39;]]).toarray() array([[1., 0., 0., 0., 0., 0.]]) See&nbsp;Loading features from dicts&nbsp;for categorical features that are represented as a dict, not as scalars. 4.3.5. Discretization Discretization&nbsp;(otherwise known as quantization or binning) provides a way to partition continuous features into discrete values. Certain datasets with continuous features may benefit from discretization, because discretization can transform the dataset of continuous attributes to one with only nominal attributes. One-hot encoded discretized features can make a model more expressive, while maintaining interpretability. For instance, pre-processing with a discretizer can introduce nonlinearity to linear models. 4.3.5.1. K-bins discretization KBinsDiscretizer&nbsp;discretizers features into&nbsp;k&nbsp;equal width bins: &gt;&gt;&gt; &gt;&gt;&gt; X = np.array([[ -3., 5., 15 ], ... [ 0., 6., 14 ], ... [ 6., 3., 11 ]]) &gt;&gt;&gt; est = preprocessing.KBinsDiscretizer(n_bins=[3, 2, 2], encode=&#39;ordinal&#39;).fit(X) By default the output is one-hot encoded into a sparse matrix (See&nbsp;Encoding categorical features) and this can be configured with the&nbsp;encode&nbsp;parameter. For each feature, the bin edges are computed during&nbsp;fit&nbsp;and together with the number of bins, they will define the intervals. Therefore, for the current example, these intervals are defined as: feature 1:&nbsp;[−∞,−1),[−1,2),[2,∞) feature 2:&nbsp;[−∞,5),[5,∞) feature 3:&nbsp;[−∞,14),[14,∞) Based on these bin intervals,&nbsp;X&nbsp;is transformed as follows: &gt;&gt;&gt; &gt;&gt;&gt; est.transform(X) array([[ 0., 1., 1.], [ 1., 1., 1.], [ 2., 0., 0.]]) The resulting dataset contains ordinal attributes which can be further used in a&nbsp;sklearn.pipeline.Pipeline. Discretization is similar to constructing histograms for continuous data. However, histograms focus on counting features which fall into particular bins, whereas discretization focuses on assigning feature values to these bins. KBinsDiscretizer&nbsp;implements different binning strategies, which can be selected with the&nbsp;strategy&nbsp;parameter. The ‘uniform’ strategy uses constant-width bins. The ‘quantile’ strategy uses the quantiles values to have equally populated bins in each feature. The ‘kmeans’ strategy defines bins based on a k-means clustering procedure performed on each feature independently. Examples: Using KBinsDiscretizer to discretize continuous features Feature discretization Demonstrating the different strategies of KBinsDiscretizer 4.3.5.2. Feature binarization Feature binarization&nbsp;is the process of&nbsp;thresholding numerical features to get boolean values. This can be useful for downstream probabilistic estimators that make assumption that the input data is distributed according to a multi-variate&nbsp;Bernoulli distribution. For instance, this is the case for the&nbsp;sklearn.neural_network.BernoulliRBM. It is also common among the text processing community to use binary feature values (probably to simplify the probabilistic reasoning) even if normalized counts (a.k.a. term frequencies) or TF-IDF valued features often perform slightly better in practice. As for the&nbsp;Normalizer, the utility class&nbsp;Binarizer&nbsp;is meant to be used in the early stages ofsklearn.pipeline.Pipeline. The&nbsp;fit&nbsp;method does nothing as each sample is treated independently of others: &gt;&gt;&gt; &gt;&gt;&gt; X = [[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]] &gt;&gt;&gt; binarizer = preprocessing.Binarizer().fit(X) # fit does nothing &gt;&gt;&gt; binarizer Binarizer(copy=True, threshold=0.0) &gt;&gt;&gt; binarizer.transform(X) array([[1., 0., 1.], [1., 0., 0.], [0., 1., 0.]]) It is possible to adjust the threshold of the binarizer: &gt;&gt;&gt; &gt;&gt;&gt; binarizer = preprocessing.Binarizer(threshold=1.1) &gt;&gt;&gt; binarizer.transform(X) array([[0., 0., 1.], [1., 0., 0.], [0., 0., 0.]]) As for the&nbsp;StandardScaler&nbsp;and&nbsp;Normalizer&nbsp;classes, the preprocessing module provides a companion function&nbsp;binarize&nbsp;to be used when the transformer API is not necessary. Note that the&nbsp;Binarizer&nbsp;is similar to the&nbsp;KBinsDiscretizer&nbsp;when&nbsp;k&nbsp;=&nbsp;2, and when the bin edge is at the value&nbsp;threshold. Sparse input binarize&nbsp;and&nbsp;Binarizer&nbsp;accept&nbsp;both dense array-like and sparse matrices from scipy.sparse as input. For sparse input the data is&nbsp;converted to the Compressed Sparse Rows representation&nbsp;(see&nbsp;scipy.sparse.csr_matrix). To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream. 4.3.6. Imputation of missing values Tools for imputing missing values are discussed at&nbsp;Imputation of missing values. 4.3.7. Generating polynomial features Often it’s useful to add complexity to the model by considering nonlinear features of the input data. A simple and common method to use is polynomial features, which can get features’ high-order and interaction terms. It is implemented in&nbsp;PolynomialFeatures: &gt;&gt;&gt; &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; from sklearn.preprocessing import PolynomialFeatures &gt;&gt;&gt; X = np.arange(6).reshape(3, 2) &gt;&gt;&gt; X array([[0, 1], [2, 3], [4, 5]]) &gt;&gt;&gt; poly = PolynomialFeatures(2) &gt;&gt;&gt; poly.fit_transform(X) array([[ 1., 0., 1., 0., 0., 1.], [ 1., 2., 3., 4., 6., 9.], [ 1., 4., 5., 16., 20., 25.]]) The features of X have been transformed from&nbsp;(X1,X2)&nbsp;to&nbsp;(1,X1,X2,X12,X1X2,X22). In some cases, only interaction terms among features are required, and it can be gotten with the setting&nbsp;interaction_only=True: &gt;&gt;&gt; &gt;&gt;&gt; X = np.arange(9).reshape(3, 3) &gt;&gt;&gt; X array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) &gt;&gt;&gt; poly = PolynomialFeatures(degree=3, interaction_only=True) &gt;&gt;&gt; poly.fit_transform(X) array([[ 1., 0., 1., 2., 0., 0., 2., 0.], [ 1., 3., 4., 5., 12., 15., 20., 60.], [ 1., 6., 7., 8., 42., 48., 56., 336.]]) The features of X have been transformed from&nbsp;(X1,X2,X3)&nbsp;to&nbsp;(1,X1,X2,X3,X1X2,X1X3,X2X3,X1X2X3). Note that polynomial features are used implicitly in&nbsp;kernel methods&nbsp;(e.g.,&nbsp;sklearn.svm.SVC,&nbsp;sklearn.decomposition.KernelPCA) when using polynomial&nbsp;Kernel functions. See&nbsp;Polynomial interpolation&nbsp;for Ridge regression using created polynomial features. 4.3.8. Custom transformers Often, you will want to convert an existing Python function into a transformer to assist in data cleaning or processing. You can implement a transformer from an arbitrary function with&nbsp;FunctionTransformer. For example, to build a transformer that applies a log transformation in a pipeline, do: &gt;&gt;&gt; &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; from sklearn.preprocessing import FunctionTransformer &gt;&gt;&gt; transformer = FunctionTransformer(np.log1p, validate=True) &gt;&gt;&gt; X = np.array([[0, 1], [2, 3]]) &gt;&gt;&gt; transformer.transform(X) array([[0. , 0.69314718], [1.09861229, 1.38629436]]) You can ensure that&nbsp;func&nbsp;and&nbsp;inverse_func&nbsp;are the inverse of each other by setting&nbsp;check_inverse=True&nbsp;and calling&nbsp;fit&nbsp;before&nbsp;transform. Please note that a warning is raised and can be turned into an error with a&nbsp;filterwarnings: &gt;&gt;&gt; &gt;&gt;&gt; import warnings &gt;&gt;&gt; warnings.filterwarnings(&quot;error&quot;, message=&quot;.*check_inverse*.&quot;, ... category=UserWarning, append=False)","@type":"BlogPosting","url":"https://mlh.app/2019/04/07/727268.html","headline":"SciKit-learn轻松使用机器学习（2）数据预处理","dateModified":"2019-04-07T00:00:00+08:00","datePublished":"2019-04-07T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/07/727268.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>SciKit-learn轻松使用机器学习（2）数据预处理</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>参考官方文档：<a href="https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing" rel="nofollow">https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing</a></p> 
  <hr>
  <h2>4.3. Preprocessing data</h2> 
  <p>The&nbsp;<span style="color:#7c79e5;"><strong><code>sklearn.preprocessing</code>&nbsp;</strong></span>package provides several common utility functions and transformer classes to change raw feature vectors into a representation that is more suitable for the downstream estimators.</p> 
  <p>In general, learning algorithms benefit from standardization of the data set. If some outliers are present in the set, robust scalers or transformers are more appropriate. The behaviors of the different scalers, transformers, and normalizers on a dataset containing marginal outliers is highlighted in&nbsp;<a href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py" rel="nofollow">Compare the effect of different scalers on data with outliers</a>.</p> 
  <h2>4.3.1. Standardization, or mean removal and variance scaling</h2> 
  <p><strong>Standardization</strong>&nbsp;of datasets is a&nbsp;<strong>common requirement for many machine learning estimators</strong>&nbsp;implemented in scikit-learn; they might behave badly if the individual features do not more or less look like standard normally distributed data: Gaussian with&nbsp;<strong>zero mean and unit variance</strong>.</p> 
  <p>In practice we often ignore the shape of the distribution and just transform the data to center it by removing the mean value of each feature, then scale it by dividing non-constant features by their standard deviation.</p> 
  <p>For instance, many elements used in the objective function of a learning algorithm (such as the RBF kernel of Support Vector Machines or the l1 and l2 regularizers of linear models) assume that all features are centered around zero and have variance in the same order. If a feature has a variance that is orders of magnitude larger than others, it might dominate the objective function and make the estimator unable to learn from other features correctly as expected.</p> 
  <p>The function&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html#sklearn.preprocessing.scale" rel="nofollow"><code>scale</code></a>&nbsp;provides a quick and easy way to perform this operation on a single array-like dataset:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; from sklearn import preprocessing
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; X_train = np.array([[ 1., -1.,  2.],
...                     [ 2.,  0.,  0.],
...                     [ 0.,  1., -1.]])
&gt;&gt;&gt; X_scaled = preprocessing.scale(X_train)

&gt;&gt;&gt; X_scaled                                          
array([[ 0.  ..., -1.22...,  1.33...],
       [ 1.22...,  0.  ..., -0.26...],
       [-1.22...,  1.22..., -1.06...]])
</code></pre> 
  <p>Scaled data has zero mean and unit variance:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; X_scaled.mean(axis=0)
array([0., 0., 0.])

&gt;&gt;&gt; X_scaled.std(axis=0)
array([1., 1., 1.])
</code></pre> 
  <p>The&nbsp;<code>preprocessing</code>&nbsp;module further provides a utility class&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler" rel="nofollow"><code>StandardScaler</code></a>&nbsp;that implements the&nbsp;<code>Transformer</code>&nbsp;API to compute the mean and standard deviation on a training set so as to be able to later reapply the same transformation on the testing set. This class is hence suitable for use in the early steps of a&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" rel="nofollow"><code>sklearn.pipeline.Pipeline</code></a>:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; scaler = preprocessing.StandardScaler().fit(X_train)
&gt;&gt;&gt; scaler
StandardScaler(copy=True, with_mean=True, with_std=True)

&gt;&gt;&gt; scaler.mean_                                      
array([1. ..., 0. ..., 0.33...])

&gt;&gt;&gt; scaler.scale_                                       
array([0.81..., 0.81..., 1.24...])

&gt;&gt;&gt; scaler.transform(X_train)                           
array([[ 0.  ..., -1.22...,  1.33...],
       [ 1.22...,  0.  ..., -0.26...],
       [-1.22...,  1.22..., -1.06...]])
</code></pre> 
  <p>The scaler instance can then be used on new data to transform it the same way it did on the training set:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; X_test = [[-1., 1., 0.]]
&gt;&gt;&gt; scaler.transform(X_test)                
array([[-2.44...,  1.22..., -0.26...]])
</code></pre> 
  <p>It is possible to disable either centering or scaling by either passing&nbsp;<code>with_mean=False</code>&nbsp;or&nbsp;<code>with_std=False</code>&nbsp;to the constructor of&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler" rel="nofollow"><code>StandardScaler</code></a>.</p> 
  <h3>4.3.1.1. Scaling features to a range</h3> 
  <p>An alternative standardization is scaling features to lie between a given minimum and maximum value, often between zero and one, or so that the maximum absolute value of each feature is scaled to unit size. This can be achieved using&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler" rel="nofollow"><code>MinMaxScaler</code></a>&nbsp;or&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MaxAbsScaler.html#sklearn.preprocessing.MaxAbsScaler" rel="nofollow"><code>MaxAbsScaler</code></a>, respectively.</p> 
  <p>The motivation to use this scaling include robustness to very small standard deviations of features and preserving zero entries in sparse data.</p> 
  <p>Here is an example to scale a toy data matrix to the&nbsp;<code>[0,&nbsp;1]</code>&nbsp;range:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; X_train = np.array([[ 1., -1.,  2.],
...                     [ 2.,  0.,  0.],
...                     [ 0.,  1., -1.]])
...
&gt;&gt;&gt; min_max_scaler = preprocessing.MinMaxScaler()
&gt;&gt;&gt; X_train_minmax = min_max_scaler.fit_transform(X_train)
&gt;&gt;&gt; X_train_minmax
array([[0.5       , 0.        , 1.        ],
       [1.        , 0.5       , 0.33333333],
       [0.        , 1.        , 0.        ]])
</code></pre> 
  <p>The same instance of the transformer can then be applied to some new test data unseen during the fit call: the same scaling and shifting operations will be applied to be consistent with the transformation performed on the train data:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; X_test = np.array([[-3., -1.,  4.]])
&gt;&gt;&gt; X_test_minmax = min_max_scaler.transform(X_test)
&gt;&gt;&gt; X_test_minmax
array([[-1.5       ,  0.        ,  1.66666667]])
</code></pre> 
  <p>It is possible to introspect the scaler attributes to find about the exact nature of the transformation learned on the training data:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; min_max_scaler.scale_                             
array([0.5       , 0.5       , 0.33...])

&gt;&gt;&gt; min_max_scaler.min_                               
array([0.        , 0.5       , 0.33...])
</code></pre> 
  <p>If&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler" rel="nofollow"><code>MinMaxScaler</code></a>&nbsp;is given an explicit&nbsp;<code>feature_range=(min,&nbsp;max)</code>&nbsp;the full formula is:</p> 
  <pre class="has">
<code class="language-html">X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))

X_scaled = X_std * (max - min) + min
</code></pre> 
  <p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MaxAbsScaler.html#sklearn.preprocessing.MaxAbsScaler" rel="nofollow"><code>MaxAbsScaler</code></a>&nbsp;works in a very similar fashion, but scales in a way that the training data lies within the range&nbsp;<code>[-1,&nbsp;1]</code>&nbsp;by dividing through the largest maximum value in each feature. It is meant for data that is already centered at zero or sparse data.</p> 
  <p>Here is how to use the toy data from the previous example with this scaler:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; X_train = np.array([[ 1., -1.,  2.],
...                     [ 2.,  0.,  0.],
...                     [ 0.,  1., -1.]])
...
&gt;&gt;&gt; max_abs_scaler = preprocessing.MaxAbsScaler()
&gt;&gt;&gt; X_train_maxabs = max_abs_scaler.fit_transform(X_train)
&gt;&gt;&gt; X_train_maxabs                # doctest +NORMALIZE_WHITESPACE^
array([[ 0.5, -1. ,  1. ],
       [ 1. ,  0. ,  0. ],
       [ 0. ,  1. , -0.5]])
&gt;&gt;&gt; X_test = np.array([[ -3., -1.,  4.]])
&gt;&gt;&gt; X_test_maxabs = max_abs_scaler.transform(X_test)
&gt;&gt;&gt; X_test_maxabs                 
array([[-1.5, -1. ,  2. ]])
&gt;&gt;&gt; max_abs_scaler.scale_         
array([2.,  1.,  2.])
</code></pre> 
  <p>As with&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html#sklearn.preprocessing.scale" rel="nofollow"><code>scale</code></a>, the module further provides convenience functions&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.minmax_scale.html#sklearn.preprocessing.minmax_scale" rel="nofollow"><code>minmax_scale</code></a>&nbsp;and&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.maxabs_scale.html#sklearn.preprocessing.maxabs_scale" rel="nofollow"><code>maxabs_scale</code></a>&nbsp;if you don’t want to create an object.</p> 
  <h3>4.3.1.2. Scaling sparse data</h3> 
  <p>Centering sparse data would destroy the sparseness structure in the data, and thus rarely is a sensible thing to do. However, it can make sense to scale sparse inputs, especially if features are on different scales.</p> 
  <p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MaxAbsScaler.html#sklearn.preprocessing.MaxAbsScaler" rel="nofollow"><code>MaxAbsScaler</code></a>&nbsp;and&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.maxabs_scale.html#sklearn.preprocessing.maxabs_scale" rel="nofollow"><code>maxabs_scale</code></a>&nbsp;were specifically designed for scaling sparse data, and are the recommended way to go about this. However,&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html#sklearn.preprocessing.scale" rel="nofollow"><code>scale</code></a>&nbsp;and&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler" rel="nofollow"><code>StandardScaler</code></a>&nbsp;can accept&nbsp;<code>scipy.sparse</code>&nbsp;matrices as input, as long as&nbsp;<code>with_mean=False</code>&nbsp;is explicitly passed to the constructor. Otherwise a&nbsp;<code>ValueError</code>&nbsp;will be raised as silently centering would break the sparsity and would often crash the execution by allocating excessive amounts of memory unintentionally.<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html#sklearn.preprocessing.RobustScaler" rel="nofollow"><code>RobustScaler</code></a>&nbsp;cannot be fitted to sparse inputs, but you can use the&nbsp;<code>transform</code>&nbsp;method on sparse inputs.</p> 
  <p>Note that the scalers accept both Compressed Sparse Rows and Compressed Sparse Columns format (see&nbsp;<code>scipy.sparse.csr_matrix</code>&nbsp;and&nbsp;<code>scipy.sparse.csc_matrix</code>). Any other sparse input will be&nbsp;<strong>converted to the Compressed Sparse Rows representation</strong>. To avoid unnecessary memory copies, it is recommended to choose the CSR or CSC representation upstream.</p> 
  <p>Finally, if the centered data is expected to be small enough, explicitly converting the input to an array using the&nbsp;<code>toarray</code>method of sparse matrices is another option.</p> 
  <h3>4.3.1.3. Scaling data with outliers</h3> 
  <p>If your data contains many outliers, scaling using the mean and variance of the data is likely to not work very well. In these cases, you can use&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.robust_scale.html#sklearn.preprocessing.robust_scale" rel="nofollow"><code>robust_scale</code></a>&nbsp;and&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html#sklearn.preprocessing.RobustScaler" rel="nofollow"><code>RobustScaler</code></a>&nbsp;as drop-in replacements instead. They use more robust estimates for the center and range of your data.</p> 
  <p>References:</p> 
  <p>Further discussion on the importance of centering and scaling data is available on this FAQ:&nbsp;<a href="http://www.faqs.org/faqs/ai-faq/neural-nets/part2/section-16.html" rel="nofollow">Should I normalize/standardize/rescale the data?</a></p> 
  <p>Scaling vs Whitening</p> 
  <p>It is sometimes not enough to center and scale the features independently, since a downstream model can further make some assumption on the linear independence of the features.</p> 
  <p>To address this issue you can use&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA" rel="nofollow"><code>sklearn.decomposition.PCA</code></a>&nbsp;with&nbsp;<code>whiten=True</code>&nbsp;to further remove the linear correlation across features.</p> 
  <p>Scaling a 1D array</p> 
  <p>All above functions (i.e.&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html#sklearn.preprocessing.scale" rel="nofollow"><code>scale</code></a>,&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.minmax_scale.html#sklearn.preprocessing.minmax_scale" rel="nofollow"><code>minmax_scale</code></a>,&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.maxabs_scale.html#sklearn.preprocessing.maxabs_scale" rel="nofollow"><code>maxabs_scale</code></a>, and&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.robust_scale.html#sklearn.preprocessing.robust_scale" rel="nofollow"><code>robust_scale</code></a>) accept 1D array which can be useful in some specific case.</p> 
  <h3>4.3.1.4. Centering kernel matrices</h3> 
  <p>If you have a kernel matrix of a kernel&nbsp;K&nbsp;that computes a dot product in a feature space defined by function&nbsp;phi, a&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.KernelCenterer.html#sklearn.preprocessing.KernelCenterer" rel="nofollow"><code>KernelCenterer</code></a>&nbsp;can transform the kernel matrix so that it contains inner products in the feature space defined by&nbsp;phifollowed by removal of the mean in that space.</p> 
  <h2>4.3.2. Non-linear transformation</h2> 
  <h3>4.3.2.1. Mapping to a Uniform distribution</h3> 
  <p>Like scalers,&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.QuantileTransformer.html#sklearn.preprocessing.QuantileTransformer" rel="nofollow"><code>QuantileTransformer</code></a>&nbsp;puts all features into the same, known range or distribution. However, by performing a rank transformation, it smooths out unusual distributions and is less influenced by outliers than scaling methods. It does, however, distort correlations and distances within and across features.</p> 
  <p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.QuantileTransformer.html#sklearn.preprocessing.QuantileTransformer" rel="nofollow"><code>QuantileTransformer</code></a>&nbsp;and&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.quantile_transform.html#sklearn.preprocessing.quantile_transform" rel="nofollow"><code>quantile_transform</code></a>&nbsp;provide a non-parametric transformation based on the quantile function to map the data to a uniform distribution with values between 0 and 1:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; from sklearn.datasets import load_iris
&gt;&gt;&gt; from sklearn.model_selection import train_test_split
&gt;&gt;&gt; iris = load_iris()
&gt;&gt;&gt; X, y = iris.data, iris.target
&gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)
&gt;&gt;&gt; quantile_transformer = preprocessing.QuantileTransformer(random_state=0)
&gt;&gt;&gt; X_train_trans = quantile_transformer.fit_transform(X_train)
&gt;&gt;&gt; X_test_trans = quantile_transformer.transform(X_test)
&gt;&gt;&gt; np.percentile(X_train[:, 0], [0, 25, 50, 75, 100]) 
array([ 4.3,  5.1,  5.8,  6.5,  7.9])
</code></pre> 
  <p>This feature corresponds to the sepal length in cm. Once the quantile transformation applied, those landmarks approach closely the percentiles previously defined:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; np.percentile(X_train_trans[:, 0], [0, 25, 50, 75, 100])
... 
array([ 0.00... ,  0.24...,  0.49...,  0.73...,  0.99... ])
</code></pre> 
  <p>This can be confirmed on a independent testing set with similar remarks:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; np.percentile(X_test[:, 0], [0, 25, 50, 75, 100])
... 
array([ 4.4  ,  5.125,  5.75 ,  6.175,  7.3  ])
&gt;&gt;&gt; np.percentile(X_test_trans[:, 0], [0, 25, 50, 75, 100])
... 
array([ 0.01...,  0.25...,  0.46...,  0.60... ,  0.94...])
</code></pre> 
  <h3>4.3.2.2. Mapping to a Gaussian distribution</h3> 
  <p>In many modeling scenarios, normality of the features in a dataset is desirable. Power transforms are a family of parametric, monotonic transformations that aim to map data from any distribution to as close to a Gaussian distribution as possible in order to stabilize variance and minimize skewness.</p> 
  <p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PowerTransformer.html#sklearn.preprocessing.PowerTransformer" rel="nofollow"><code>PowerTransformer</code></a>&nbsp;currently provides two such power transformations, the Yeo-Johnson transform and the Box-Cox transform.</p> 
  <p>The Yeo-Johnson transform is given by:</p> 
  <p>xi(λ)={[(xi+1)λ−1]/λif&nbsp;λ≠0,xi≥0,ln⁡(xi)+1if&nbsp;λ=0,xi≥0−[(−xi+1)2−λ−1]/(2−λ)if&nbsp;λ≠2,xi&lt;0,−ln⁡(−xi+1)if&nbsp;λ=2,xi&lt;0</p> 
  <p>while the Box-Cox transform is given by:</p> 
  <p>xi(λ)={xiλ−1λif&nbsp;λ≠0,ln⁡(xi)if&nbsp;λ=0,</p> 
  <p>Box-Cox can only be applied to strictly positive data. In both methods, the transformation is parameterized by&nbsp;λ, which is determined through maximum likelihood estimation. Here is an example of using Box-Cox to map samples drawn from a lognormal distribution to a normal distribution:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; pt = preprocessing.PowerTransformer(method='box-cox', standardize=False)
&gt;&gt;&gt; X_lognormal = np.random.RandomState(616).lognormal(size=(3, 3))
&gt;&gt;&gt; X_lognormal                                         
array([[1.28..., 1.18..., 0.84...],
       [0.94..., 1.60..., 0.38...],
       [1.35..., 0.21..., 1.09...]])
&gt;&gt;&gt; pt.fit_transform(X_lognormal)                   
array([[ 0.49...,  0.17..., -0.15...],
       [-0.05...,  0.58..., -0.57...],
       [ 0.69..., -0.84...,  0.10...]])
</code></pre> 
  <p>While the above example sets the&nbsp;standardize&nbsp;option to&nbsp;False,&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PowerTransformer.html#sklearn.preprocessing.PowerTransformer" rel="nofollow"><code>PowerTransformer</code></a>&nbsp;will apply zero-mean, unit-variance normalization to the transformed output by default.</p> 
  <p>Below are examples of Box-Cox and Yeo-Johnson applied to various probability distributions. Note that when applied to certain distributions, the power transforms achieve very Gaussian-like results, but with others, they are ineffective. This highlights the importance of visualizing the data before and after transformation.</p> 
  <p><a href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_map_data_to_normal.html" rel="nofollow"><img alt="../_images/sphx_glr_plot_map_data_to_normal_0011.png" class="has" src="https://scikit-learn.org/stable/_images/sphx_glr_plot_map_data_to_normal_0011.png"></a></p> 
  <p>It is also possible to map data to a normal distribution using&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.QuantileTransformer.html#sklearn.preprocessing.QuantileTransformer" rel="nofollow"><code>QuantileTransformer</code></a>&nbsp;by setting&nbsp;<code>output_distribution='normal'</code>. Using the earlier example with the iris dataset:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; quantile_transformer = preprocessing.QuantileTransformer(
...     output_distribution='normal', random_state=0)
&gt;&gt;&gt; X_trans = quantile_transformer.fit_transform(X)
&gt;&gt;&gt; quantile_transformer.quantiles_ 
array([[4.3...,   2...,     1...,     0.1...],
       [4.31...,  2.02...,  1.01...,  0.1...],
       [4.32...,  2.05...,  1.02...,  0.1...],
       ...,
       [7.84...,  4.34...,  6.84...,  2.5...],
       [7.87...,  4.37...,  6.87...,  2.5...],
       [7.9...,   4.4...,   6.9...,   2.5...]])
</code></pre> 
  <p>Thus the median of the input becomes the mean of the output, centered at 0. The normal output is clipped so that the input’s minimum and maximum — corresponding to the 1e-7 and 1 - 1e-7 quantiles respectively — do not become infinite under the transformation.</p> 
  <h2>4.3.3. Normalization</h2> 
  <p><strong>Normalization</strong>&nbsp;is the process of&nbsp;<strong>scaling individual samples to have unit norm</strong>. This process can be useful if you plan to use a quadratic form such as the dot-product or any other kernel to quantify the similarity of any pair of samples.</p> 
  <p>This assumption is the base of the&nbsp;<a href="https://en.wikipedia.org/wiki/Vector_Space_Model" rel="nofollow">Vector Space Model</a>&nbsp;often used in text classification and clustering contexts.</p> 
  <p>The function&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" rel="nofollow"><code>normalize</code></a>&nbsp;provides a quick and easy way to perform this operation on a single array-like dataset, either using the&nbsp;<code>l1</code>&nbsp;or&nbsp;<code>l2</code>&nbsp;norms:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; X = [[ 1., -1.,  2.],
...      [ 2.,  0.,  0.],
...      [ 0.,  1., -1.]]
&gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm='l2')

&gt;&gt;&gt; X_normalized                                      
array([[ 0.40..., -0.40...,  0.81...],
       [ 1.  ...,  0.  ...,  0.  ...],
       [ 0.  ...,  0.70..., -0.70...]])
</code></pre> 
  <p>The&nbsp;<code>preprocessing</code>&nbsp;module further provides a utility class&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Normalizer.html#sklearn.preprocessing.Normalizer" rel="nofollow"><code>Normalizer</code></a>&nbsp;that implements the same operation using the<code>Transformer</code>&nbsp;API (even though the&nbsp;<code>fit</code>&nbsp;method is useless in this case: the class is stateless as this operation treats samples independently).</p> 
  <p>This class is hence suitable for use in the early steps of a&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" rel="nofollow"><code>sklearn.pipeline.Pipeline</code></a>:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; normalizer = preprocessing.Normalizer().fit(X)  # fit does nothing
&gt;&gt;&gt; normalizer
Normalizer(copy=True, norm='l2')
</code></pre> 
  <p>The normalizer instance can then be used on sample vectors as any transformer:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; normalizer.transform(X)                            
array([[ 0.40..., -0.40...,  0.81...],
       [ 1.  ...,  0.  ...,  0.  ...],
       [ 0.  ...,  0.70..., -0.70...]])

&gt;&gt;&gt; normalizer.transform([[-1.,  1., 0.]])             
array([[-0.70...,  0.70...,  0.  ...]])
</code></pre> 
  <p>Sparse input</p> 
  <p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" rel="nofollow"><code>normalize</code></a>&nbsp;and&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Normalizer.html#sklearn.preprocessing.Normalizer" rel="nofollow"><code>Normalizer</code></a>&nbsp;accept&nbsp;<strong>both dense array-like and sparse matrices from scipy.sparse as input</strong>.</p> 
  <p>For sparse input the data is&nbsp;<strong>converted to the Compressed Sparse Rows representation</strong>&nbsp;(see&nbsp;<code>scipy.sparse.csr_matrix</code>) before being fed to efficient Cython routines. To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream.</p> 
  <h2>4.3.4. Encoding categorical features</h2> 
  <p>Often features are not given as continuous values but categorical. For example a person could have features&nbsp;<code>["male",&nbsp;"female"]</code>,&nbsp;<code>["from&nbsp;Europe",&nbsp;"from&nbsp;US",&nbsp;"from&nbsp;Asia"]</code>,<code>["uses&nbsp;Firefox",&nbsp;"uses&nbsp;Chrome",&nbsp;"uses&nbsp;Safari",&nbsp;"uses&nbsp;Internet&nbsp;Explorer"]</code>. Such features can be efficiently coded as integers, for instance&nbsp;<code>["male",&nbsp;"from&nbsp;US",&nbsp;"uses&nbsp;Internet&nbsp;Explorer"]</code>&nbsp;could be expressed as&nbsp;<code>[0,&nbsp;1,&nbsp;3]</code>while&nbsp;<code>["female",&nbsp;"from&nbsp;Asia",&nbsp;"uses&nbsp;Chrome"]</code>&nbsp;would be&nbsp;<code>[1,&nbsp;2,&nbsp;1]</code>.</p> 
  <p>To convert categorical features to such integer codes, we can use the&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OrdinalEncoder.html#sklearn.preprocessing.OrdinalEncoder" rel="nofollow"><code>OrdinalEncoder</code></a>. This estimator transforms each categorical feature to one new feature of integers (0 to n_categories - 1):</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; enc = preprocessing.OrdinalEncoder()
&gt;&gt;&gt; X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
&gt;&gt;&gt; enc.fit(X)  
OrdinalEncoder(categories='auto', dtype=&lt;... 'numpy.float64'&gt;)
&gt;&gt;&gt; enc.transform([['female', 'from US', 'uses Safari']])
array([[0., 1., 1.]])
</code></pre> 
  <p>Such integer representation can, however, not be used directly with all scikit-learn estimators, as these expect continuous input, and would interpret the categories as being ordered, which is often not desired (i.e. the set of browsers was ordered arbitrarily).</p> 
  <p>Another possibility to convert categorical features to features that can be used with scikit-learn estimators is to use a one-of-K, also known as one-hot or dummy encoding. This type of encoding can be obtained with the&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html#sklearn.preprocessing.OneHotEncoder" rel="nofollow"><code>OneHotEncoder</code></a>, which transforms each categorical feature with&nbsp;<code>n_categories</code>&nbsp;possible values into&nbsp;<code>n_categories</code>&nbsp;binary features, with one of them 1, and all others 0.</p> 
  <p>Continuing the example above:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; enc = preprocessing.OneHotEncoder()
&gt;&gt;&gt; X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
&gt;&gt;&gt; enc.fit(X)  
OneHotEncoder(categorical_features=None, categories=None,
       dtype=&lt;... 'numpy.float64'&gt;, handle_unknown='error',
       n_values=None, sparse=True)
&gt;&gt;&gt; enc.transform([['female', 'from US', 'uses Safari'],
...                ['male', 'from Europe', 'uses Safari']]).toarray()
array([[1., 0., 0., 1., 0., 1.],
       [0., 1., 1., 0., 0., 1.]])
</code></pre> 
  <p>By default, the values each feature can take is inferred automatically from the dataset and can be found in the&nbsp;<code>categories_</code>&nbsp;attribute:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; enc.categories_
[array(['female', 'male'], dtype=object), array(['from Europe', 'from US'], dtype=object), array(['uses Firefox', 'uses Safari'], dtype=object)]
</code></pre> 
  <p>It is possible to specify this explicitly using the parameter&nbsp;<code>categories</code>. There are two genders, four possible continents and four web browsers in our dataset:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; genders = ['female', 'male']
&gt;&gt;&gt; locations = ['from Africa', 'from Asia', 'from Europe', 'from US']
&gt;&gt;&gt; browsers = ['uses Chrome', 'uses Firefox', 'uses IE', 'uses Safari']
&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(categories=[genders, locations, browsers])
&gt;&gt;&gt; # Note that for there are missing categorical values for the 2nd and 3rd
&gt;&gt;&gt; # feature
&gt;&gt;&gt; X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
&gt;&gt;&gt; enc.fit(X) 
OneHotEncoder(categorical_features=None,
       categories=[...],
       dtype=&lt;... 'numpy.float64'&gt;, handle_unknown='error',
       n_values=None, sparse=True)
&gt;&gt;&gt; enc.transform([['female', 'from Asia', 'uses Chrome']]).toarray()
array([[1., 0., 0., 1., 0., 0., 1., 0., 0., 0.]])
</code></pre> 
  <p>If there is a possibility that the training data might have missing categorical features, it can often be better to specify&nbsp;<code>handle_unknown='ignore'</code>&nbsp;instead of setting the&nbsp;<code>categories</code>&nbsp;manually as above. When&nbsp;<code>handle_unknown='ignore'</code>&nbsp;is specified and unknown categories are encountered during transform, no error will be raised but the resulting one-hot encoded columns for this feature will be all zeros (<code>handle_unknown='ignore'</code>&nbsp;is only supported for one-hot encoding):</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(handle_unknown='ignore')
&gt;&gt;&gt; X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
&gt;&gt;&gt; enc.fit(X) 
OneHotEncoder(categorical_features=None, categories=None,
       dtype=&lt;... 'numpy.float64'&gt;, handle_unknown='ignore',
       n_values=None, sparse=True)
&gt;&gt;&gt; enc.transform([['female', 'from Asia', 'uses Chrome']]).toarray()
array([[1., 0., 0., 0., 0., 0.]])
</code></pre> 
  <p>See&nbsp;<a href="https://scikit-learn.org/stable/modules/feature_extraction.html#dict-feature-extraction" rel="nofollow">Loading features from dicts</a>&nbsp;for categorical features that are represented as a dict, not as scalars.</p> 
  <h2>4.3.5. Discretization</h2> 
  <p><a href="https://en.wikipedia.org/wiki/Discretization_of_continuous_features" rel="nofollow">Discretization</a>&nbsp;(otherwise known as quantization or binning) provides a way to partition continuous features into discrete values. Certain datasets with continuous features may benefit from discretization, because discretization can transform the dataset of continuous attributes to one with only nominal attributes.</p> 
  <p>One-hot encoded discretized features can make a model more expressive, while maintaining interpretability. For instance, pre-processing with a discretizer can introduce nonlinearity to linear models.</p> 
  <h3>4.3.5.1. K-bins discretization</h3> 
  <p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.KBinsDiscretizer.html#sklearn.preprocessing.KBinsDiscretizer" rel="nofollow"><code>KBinsDiscretizer</code></a>&nbsp;discretizers features into&nbsp;<code>k</code>&nbsp;equal width bins:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; X = np.array([[ -3., 5., 15 ],
...               [  0., 6., 14 ],
...               [  6., 3., 11 ]])
&gt;&gt;&gt; est = preprocessing.KBinsDiscretizer(n_bins=[3, 2, 2], encode='ordinal').fit(X)
</code></pre> 
  <p>By default the output is one-hot encoded into a sparse matrix (See&nbsp;<a href="https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-categorical-features" rel="nofollow">Encoding categorical features</a>) and this can be configured with the&nbsp;<code>encode</code>&nbsp;parameter. For each feature, the bin edges are computed during&nbsp;<code>fit</code>&nbsp;and together with the number of bins, they will define the intervals. Therefore, for the current example, these intervals are defined as:</p> 
  <blockquote> 
   <ul>
    <li>feature 1:&nbsp;[−∞,−1),[−1,2),[2,∞)</li> 
    <li>feature 2:&nbsp;[−∞,5),[5,∞)</li> 
    <li>feature 3:&nbsp;[−∞,14),[14,∞)</li> 
   </ul>
   <p>Based on these bin intervals,&nbsp;<code>X</code>&nbsp;is transformed as follows:</p> &gt;&gt;&gt; 
   <pre class="has">
<code class="language-html">&gt;&gt;&gt; est.transform(X)                      
array([[ 0., 1., 1.],
       [ 1., 1., 1.],
       [ 2., 0., 0.]])
</code></pre> 
  </blockquote> 
  <p>The resulting dataset contains ordinal attributes which can be further used in a&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" rel="nofollow"><code>sklearn.pipeline.Pipeline</code></a>.</p> 
  <p>Discretization is similar to constructing histograms for continuous data. However, histograms focus on counting features which fall into particular bins, whereas discretization focuses on assigning feature values to these bins.</p> 
  <p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.KBinsDiscretizer.html#sklearn.preprocessing.KBinsDiscretizer" rel="nofollow"><code>KBinsDiscretizer</code></a>&nbsp;implements different binning strategies, which can be selected with the&nbsp;<code>strategy</code>&nbsp;parameter. The ‘uniform’ strategy uses constant-width bins. The ‘quantile’ strategy uses the quantiles values to have equally populated bins in each feature. The ‘kmeans’ strategy defines bins based on a k-means clustering procedure performed on each feature independently.</p> 
  <p>Examples:</p> 
  <ul>
   <li><a href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_discretization.html#sphx-glr-auto-examples-preprocessing-plot-discretization-py" rel="nofollow">Using KBinsDiscretizer to discretize continuous features</a></li> 
   <li><a href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_discretization_classification.html#sphx-glr-auto-examples-preprocessing-plot-discretization-classification-py" rel="nofollow">Feature discretization</a></li> 
   <li><a href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_discretization_strategies.html#sphx-glr-auto-examples-preprocessing-plot-discretization-strategies-py" rel="nofollow">Demonstrating the different strategies of KBinsDiscretizer</a></li> 
  </ul>
  <h3>4.3.5.2. Feature binarization</h3> 
  <p><strong>Feature binarization</strong>&nbsp;is the process of&nbsp;<strong>thresholding numerical features to get boolean values</strong>. This can be useful for downstream probabilistic estimators that make assumption that the input data is distributed according to a multi-variate&nbsp;<a href="https://en.wikipedia.org/wiki/Bernoulli_distribution" rel="nofollow">Bernoulli distribution</a>. For instance, this is the case for the&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.neural_network.BernoulliRBM.html#sklearn.neural_network.BernoulliRBM" rel="nofollow"><code>sklearn.neural_network.BernoulliRBM</code></a>.</p> 
  <p>It is also common among the text processing community to use binary feature values (probably to simplify the probabilistic reasoning) even if normalized counts (a.k.a. term frequencies) or TF-IDF valued features often perform slightly better in practice.</p> 
  <p>As for the&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Normalizer.html#sklearn.preprocessing.Normalizer" rel="nofollow"><code>Normalizer</code></a>, the utility class&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Binarizer.html#sklearn.preprocessing.Binarizer" rel="nofollow"><code>Binarizer</code></a>&nbsp;is meant to be used in the early stages of<a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" rel="nofollow"><code>sklearn.pipeline.Pipeline</code></a>. The&nbsp;<code>fit</code>&nbsp;method does nothing as each sample is treated independently of others:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; X = [[ 1., -1.,  2.],
...      [ 2.,  0.,  0.],
...      [ 0.,  1., -1.]]

&gt;&gt;&gt; binarizer = preprocessing.Binarizer().fit(X)  # fit does nothing
&gt;&gt;&gt; binarizer
Binarizer(copy=True, threshold=0.0)

&gt;&gt;&gt; binarizer.transform(X)
array([[1., 0., 1.],
       [1., 0., 0.],
       [0., 1., 0.]])
</code></pre> 
  <p>It is possible to adjust the threshold of the binarizer:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; binarizer = preprocessing.Binarizer(threshold=1.1)
&gt;&gt;&gt; binarizer.transform(X)
array([[0., 0., 1.],
       [1., 0., 0.],
       [0., 0., 0.]])
</code></pre> 
  <p>As for the&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler" rel="nofollow"><code>StandardScaler</code></a>&nbsp;and&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Normalizer.html#sklearn.preprocessing.Normalizer" rel="nofollow"><code>Normalizer</code></a>&nbsp;classes, the preprocessing module provides a companion function&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.binarize.html#sklearn.preprocessing.binarize" rel="nofollow"><code>binarize</code></a>&nbsp;to be used when the transformer API is not necessary.</p> 
  <p>Note that the&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Binarizer.html#sklearn.preprocessing.Binarizer" rel="nofollow"><code>Binarizer</code></a>&nbsp;is similar to the&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.KBinsDiscretizer.html#sklearn.preprocessing.KBinsDiscretizer" rel="nofollow"><code>KBinsDiscretizer</code></a>&nbsp;when&nbsp;<code>k&nbsp;=&nbsp;2</code>, and when the bin edge is at the value&nbsp;<code>threshold</code>.</p> 
  <p>Sparse input</p> 
  <p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.binarize.html#sklearn.preprocessing.binarize" rel="nofollow"><code>binarize</code></a>&nbsp;and&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Binarizer.html#sklearn.preprocessing.Binarizer" rel="nofollow"><code>Binarizer</code></a>&nbsp;accept&nbsp;<strong>both dense array-like and sparse matrices from scipy.sparse as input</strong>.</p> 
  <p>For sparse input the data is&nbsp;<strong>converted to the Compressed Sparse Rows representation</strong>&nbsp;(see&nbsp;<code>scipy.sparse.csr_matrix</code>). To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream.</p> 
  <h2>4.3.6. Imputation of missing values</h2> 
  <p>Tools for imputing missing values are discussed at&nbsp;<a href="https://scikit-learn.org/stable/modules/impute.html#impute" rel="nofollow">Imputation of missing values</a>.</p> 
  <h2>4.3.7. Generating polynomial features</h2> 
  <p>Often it’s useful to add complexity to the model by considering nonlinear features of the input data. A simple and common method to use is polynomial features, which can get features’ high-order and interaction terms. It is implemented in&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html#sklearn.preprocessing.PolynomialFeatures" rel="nofollow"><code>PolynomialFeatures</code></a>:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.preprocessing import PolynomialFeatures
&gt;&gt;&gt; X = np.arange(6).reshape(3, 2)
&gt;&gt;&gt; X                                                 
array([[0, 1],
       [2, 3],
       [4, 5]])
&gt;&gt;&gt; poly = PolynomialFeatures(2)
&gt;&gt;&gt; poly.fit_transform(X)                             
array([[ 1.,  0.,  1.,  0.,  0.,  1.],
       [ 1.,  2.,  3.,  4.,  6.,  9.],
       [ 1.,  4.,  5., 16., 20., 25.]])
</code></pre> 
  <p>The features of X have been transformed from&nbsp;(X1,X2)&nbsp;to&nbsp;(1,X1,X2,X12,X1X2,X22).</p> 
  <p>In some cases, only interaction terms among features are required, and it can be gotten with the setting&nbsp;<code>interaction_only=True</code>:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; X = np.arange(9).reshape(3, 3)
&gt;&gt;&gt; X                                                 
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
&gt;&gt;&gt; poly = PolynomialFeatures(degree=3, interaction_only=True)
&gt;&gt;&gt; poly.fit_transform(X)                             
array([[  1.,   0.,   1.,   2.,   0.,   0.,   2.,   0.],
       [  1.,   3.,   4.,   5.,  12.,  15.,  20.,  60.],
       [  1.,   6.,   7.,   8.,  42.,  48.,  56., 336.]])
</code></pre> 
  <p>The features of X have been transformed from&nbsp;(X1,X2,X3)&nbsp;to&nbsp;(1,X1,X2,X3,X1X2,X1X3,X2X3,X1X2X3).</p> 
  <p>Note that polynomial features are used implicitly in&nbsp;<a href="https://en.wikipedia.org/wiki/Kernel_method" rel="nofollow">kernel methods</a>&nbsp;(e.g.,&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html#sklearn.svm.SVC" rel="nofollow"><code>sklearn.svm.SVC</code></a>,&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.KernelPCA.html#sklearn.decomposition.KernelPCA" rel="nofollow"><code>sklearn.decomposition.KernelPCA</code></a>) when using polynomial&nbsp;<a href="https://scikit-learn.org/stable/modules/svm.html#svm-kernels" rel="nofollow">Kernel functions</a>.</p> 
  <p>See&nbsp;<a href="https://scikit-learn.org/stable/auto_examples/linear_model/plot_polynomial_interpolation.html#sphx-glr-auto-examples-linear-model-plot-polynomial-interpolation-py" rel="nofollow">Polynomial interpolation</a>&nbsp;for Ridge regression using created polynomial features.</p> 
  <h2>4.3.8. Custom transformers</h2> 
  <p>Often, you will want to convert an existing Python function into a transformer to assist in data cleaning or processing. You can implement a transformer from an arbitrary function with&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.FunctionTransformer.html#sklearn.preprocessing.FunctionTransformer" rel="nofollow"><code>FunctionTransformer</code></a>. For example, to build a transformer that applies a log transformation in a pipeline, do:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.preprocessing import FunctionTransformer
&gt;&gt;&gt; transformer = FunctionTransformer(np.log1p, validate=True)
&gt;&gt;&gt; X = np.array([[0, 1], [2, 3]])
&gt;&gt;&gt; transformer.transform(X)
array([[0.        , 0.69314718],
       [1.09861229, 1.38629436]])
</code></pre> 
  <p>You can ensure that&nbsp;<code>func</code>&nbsp;and&nbsp;<code>inverse_func</code>&nbsp;are the inverse of each other by setting&nbsp;<code>check_inverse=True</code>&nbsp;and calling&nbsp;<code>fit</code>&nbsp;before&nbsp;<code>transform</code>. Please note that a warning is raised and can be turned into an error with a&nbsp;<code>filterwarnings</code>:</p> 
  <p>&gt;&gt;&gt;</p> 
  <pre class="has">
<code class="language-html">&gt;&gt;&gt; import warnings
&gt;&gt;&gt; warnings.filterwarnings("error", message=".*check_inverse*.",
...                         category=UserWarning, append=False)</code></pre> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
