<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>AIC、BIC、QAIC及HQ准则 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="AIC、BIC、QAIC及HQ准则" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="很多参数估计问题均采用似然函数作为目标函数，当训练数据足够多时，可以不断提高模型精度，但是以提高模型复杂度为代价的，同时带来一个机器学习中非常普遍的问题——过拟合。所以，模型选择问题在模型复杂度与模型对数据集描述能力（即似然函数）之间寻求最佳平衡。 人们提出许多信息准则，通过加入模型复杂度的惩罚项来避免过拟合问题，此处我们介绍一下常用的两个模型选择方法——赤池信息准则 （Akaike Information Criterion，AIC）和贝叶斯信息准则 （Bayesian Information Criterion，BIC）。 1.AIC准则(Akaike Information Criterion) AIC是衡量统计模型拟合优良性的一种标准，由日本统计学家赤池弘次在1974年提出，它建立在熵的概念上，提供了权衡估计模型复杂度和拟合数据优良性的标准。 通常情况下，它是拟合精度和参数未知个数的加权函数，AIC定义为： A I C = 2 k − 2 l n ( L ) AIC=2k-2ln(L) AIC=2k−2ln(L) 当在两个模型之间存在着相当大的差异时，这个差异出现于上式第二项，而当第二项不出现显著性差异时，第一项起作用，从而参数个数少的模型是好的模型。 让 n n n为观察数， R S S RSS RSS为剩余平方和，那么AIC变为： A I C = 2 k + n l n ( R S S / n ) AIC=2k+nln(RSS/n) AIC=2k+nln(RSS/n) 其中 k k k是模型中未知参数个数， L L L是模型中极大似然函数值似然函数。从一组可供选择的模型中选择最佳模型时，通常选择AIC最小的模型。 当两个模型之间存在较大差异时，差异主要体现在似然函数项， 当似然函数差异不显著时，上式第一项，即模型复杂度则起作用，从而参数个数少的模型是较好的选择。 一般而言，当模型复杂度提高（ k k k增大）时，似然函数L也会增大，从而使AIC变小，但是k过大时，似然函数增速减缓，导致AIC增大，模型过于复杂容易造成过拟合现象。目标是选取AIC最小的模型，AIC不仅要提高模型拟合度（极大似然），而且引入了惩罚项，使模型参数尽可能少，有助于降低过拟合的可能性。可见AIC准则有效且合理地控制了参数的维数k。显然AIC准则追求似然函数尽可能大的同时，k要尽可能的小。 举例： 设 y 1 , y 2 , ⋯ &amp;ThinSpace; , y n y_1,y_2,\cdots,y_n y1​,y2​,⋯,yn​是来自未知总体 g ( y ) g(y) g(y)的样本。总体的概率密度为 f ( y ; θ ) f(y;θ) f(y;θ), θ θ θ是 r ∗ 1 r*1 r∗1未知参数向量。若 θ θ θ的极大似然估计是 θ ∗ θ^* θ∗，则 L ( θ ∗ ) = ∑ i = 1 n ( l n f ( y i ; θ ∗ ) 〗 L(θ^*)=\sum_{i=1}^n(lnf(y_i;θ^*)〗 L(θ∗)=∑i=1n​(lnf(yi​;θ∗)〗就是对数似然函数，由此， A I C = − 2 L ( θ ∗ ) + 2 r AIC=-2L(θ^*)+2r AIC=−2L(θ∗)+2r 可以度量 f ( y ; θ ) f(y;θ) f(y;θ)与 g ( y ) g(y) g(y)之间的差异。 2.BIC准则(Bayesian InformationCriterion) BIC（Bayesian InformationCriterion）贝叶斯信息准则与AIC相似，用于模型选择，1978年由Schwarz提出。训练模型时，增加参数数量，也就是增加模型复杂度，会增大似然函数，但是也会导致过拟合现象，针对该问题，AIC和BIC均引入了与模型参数个数相关的惩罚项，BIC的惩罚项比AIC的大，考虑了样本数量，样本数量过多时，可有效防止模型精度过高造成的模型复杂度过高。 B I C = k l n ( n ) − 2 l n ( L ) BIC=kln(n)-2ln(L) BIC=kln(n)−2ln(L) 其中， k k k为模型参数个数， n n n为样本数量， L L L为似然函数。 k l n ( n ) kln(n) kln(n)惩罚项在维数过大且训练样本数据相对较少的情况下，可以有效避免出现维度灾难现象。 3.QAIC准则 为了使用过度离散（或缺乏拟合），提出了改进的AIC准则QAIC： Q A I C = − 2 l n ( L ) / c + 2 k QAIC=-2ln(L)/c+2k QAIC=−2ln(L)/c+2k 其中，c是方差膨胀因子。 4.QH准则(hannan-quinn criterion) H Q = − 2 l n ( L ) + l n ( l n ( n ) ) ∗ k HQ=-2 ln(L) + ln(ln(n))*k HQ=−2ln(L)+ln(ln(n))∗k 其中 L L L是在该模型下的最大似然， n n n是数据数量， k k k是模型的变量个数。 注意这些规则只是刻画了用某个模型之后相对“真实模型”的信息损失【因为不知道真正的模型是什么样子，所以训练得到的所有模型都只是真实模型的一个近似模型】，所以用这些规则不能说明某个模型的精确度。 这些规则理论上是比较漂亮的，但是实际在模型选择中应用比较困难的，如若有 5个变量则有32个变量组合，若为10个变量呢？2的10次方，故不可能对所有这些模型进行一一验证AIC, BIC，QAIC，HQ规则来选择模型，工作量太大。 转载自：博客一：https://blog.csdn.net/yinyu19950811/article/details/60964782 博客二：https://blog.csdn.net/xianlingmao/article/details/7891277" />
<meta property="og:description" content="很多参数估计问题均采用似然函数作为目标函数，当训练数据足够多时，可以不断提高模型精度，但是以提高模型复杂度为代价的，同时带来一个机器学习中非常普遍的问题——过拟合。所以，模型选择问题在模型复杂度与模型对数据集描述能力（即似然函数）之间寻求最佳平衡。 人们提出许多信息准则，通过加入模型复杂度的惩罚项来避免过拟合问题，此处我们介绍一下常用的两个模型选择方法——赤池信息准则 （Akaike Information Criterion，AIC）和贝叶斯信息准则 （Bayesian Information Criterion，BIC）。 1.AIC准则(Akaike Information Criterion) AIC是衡量统计模型拟合优良性的一种标准，由日本统计学家赤池弘次在1974年提出，它建立在熵的概念上，提供了权衡估计模型复杂度和拟合数据优良性的标准。 通常情况下，它是拟合精度和参数未知个数的加权函数，AIC定义为： A I C = 2 k − 2 l n ( L ) AIC=2k-2ln(L) AIC=2k−2ln(L) 当在两个模型之间存在着相当大的差异时，这个差异出现于上式第二项，而当第二项不出现显著性差异时，第一项起作用，从而参数个数少的模型是好的模型。 让 n n n为观察数， R S S RSS RSS为剩余平方和，那么AIC变为： A I C = 2 k + n l n ( R S S / n ) AIC=2k+nln(RSS/n) AIC=2k+nln(RSS/n) 其中 k k k是模型中未知参数个数， L L L是模型中极大似然函数值似然函数。从一组可供选择的模型中选择最佳模型时，通常选择AIC最小的模型。 当两个模型之间存在较大差异时，差异主要体现在似然函数项， 当似然函数差异不显著时，上式第一项，即模型复杂度则起作用，从而参数个数少的模型是较好的选择。 一般而言，当模型复杂度提高（ k k k增大）时，似然函数L也会增大，从而使AIC变小，但是k过大时，似然函数增速减缓，导致AIC增大，模型过于复杂容易造成过拟合现象。目标是选取AIC最小的模型，AIC不仅要提高模型拟合度（极大似然），而且引入了惩罚项，使模型参数尽可能少，有助于降低过拟合的可能性。可见AIC准则有效且合理地控制了参数的维数k。显然AIC准则追求似然函数尽可能大的同时，k要尽可能的小。 举例： 设 y 1 , y 2 , ⋯ &amp;ThinSpace; , y n y_1,y_2,\cdots,y_n y1​,y2​,⋯,yn​是来自未知总体 g ( y ) g(y) g(y)的样本。总体的概率密度为 f ( y ; θ ) f(y;θ) f(y;θ), θ θ θ是 r ∗ 1 r*1 r∗1未知参数向量。若 θ θ θ的极大似然估计是 θ ∗ θ^* θ∗，则 L ( θ ∗ ) = ∑ i = 1 n ( l n f ( y i ; θ ∗ ) 〗 L(θ^*)=\sum_{i=1}^n(lnf(y_i;θ^*)〗 L(θ∗)=∑i=1n​(lnf(yi​;θ∗)〗就是对数似然函数，由此， A I C = − 2 L ( θ ∗ ) + 2 r AIC=-2L(θ^*)+2r AIC=−2L(θ∗)+2r 可以度量 f ( y ; θ ) f(y;θ) f(y;θ)与 g ( y ) g(y) g(y)之间的差异。 2.BIC准则(Bayesian InformationCriterion) BIC（Bayesian InformationCriterion）贝叶斯信息准则与AIC相似，用于模型选择，1978年由Schwarz提出。训练模型时，增加参数数量，也就是增加模型复杂度，会增大似然函数，但是也会导致过拟合现象，针对该问题，AIC和BIC均引入了与模型参数个数相关的惩罚项，BIC的惩罚项比AIC的大，考虑了样本数量，样本数量过多时，可有效防止模型精度过高造成的模型复杂度过高。 B I C = k l n ( n ) − 2 l n ( L ) BIC=kln(n)-2ln(L) BIC=kln(n)−2ln(L) 其中， k k k为模型参数个数， n n n为样本数量， L L L为似然函数。 k l n ( n ) kln(n) kln(n)惩罚项在维数过大且训练样本数据相对较少的情况下，可以有效避免出现维度灾难现象。 3.QAIC准则 为了使用过度离散（或缺乏拟合），提出了改进的AIC准则QAIC： Q A I C = − 2 l n ( L ) / c + 2 k QAIC=-2ln(L)/c+2k QAIC=−2ln(L)/c+2k 其中，c是方差膨胀因子。 4.QH准则(hannan-quinn criterion) H Q = − 2 l n ( L ) + l n ( l n ( n ) ) ∗ k HQ=-2 ln(L) + ln(ln(n))*k HQ=−2ln(L)+ln(ln(n))∗k 其中 L L L是在该模型下的最大似然， n n n是数据数量， k k k是模型的变量个数。 注意这些规则只是刻画了用某个模型之后相对“真实模型”的信息损失【因为不知道真正的模型是什么样子，所以训练得到的所有模型都只是真实模型的一个近似模型】，所以用这些规则不能说明某个模型的精确度。 这些规则理论上是比较漂亮的，但是实际在模型选择中应用比较困难的，如若有 5个变量则有32个变量组合，若为10个变量呢？2的10次方，故不可能对所有这些模型进行一一验证AIC, BIC，QAIC，HQ规则来选择模型，工作量太大。 转载自：博客一：https://blog.csdn.net/yinyu19950811/article/details/60964782 博客二：https://blog.csdn.net/xianlingmao/article/details/7891277" />
<link rel="canonical" href="https://mlh.app/2019/04/07/728715.html" />
<meta property="og:url" content="https://mlh.app/2019/04/07/728715.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-07T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"很多参数估计问题均采用似然函数作为目标函数，当训练数据足够多时，可以不断提高模型精度，但是以提高模型复杂度为代价的，同时带来一个机器学习中非常普遍的问题——过拟合。所以，模型选择问题在模型复杂度与模型对数据集描述能力（即似然函数）之间寻求最佳平衡。 人们提出许多信息准则，通过加入模型复杂度的惩罚项来避免过拟合问题，此处我们介绍一下常用的两个模型选择方法——赤池信息准则 （Akaike Information Criterion，AIC）和贝叶斯信息准则 （Bayesian Information Criterion，BIC）。 1.AIC准则(Akaike Information Criterion) AIC是衡量统计模型拟合优良性的一种标准，由日本统计学家赤池弘次在1974年提出，它建立在熵的概念上，提供了权衡估计模型复杂度和拟合数据优良性的标准。 通常情况下，它是拟合精度和参数未知个数的加权函数，AIC定义为： A I C = 2 k − 2 l n ( L ) AIC=2k-2ln(L) AIC=2k−2ln(L) 当在两个模型之间存在着相当大的差异时，这个差异出现于上式第二项，而当第二项不出现显著性差异时，第一项起作用，从而参数个数少的模型是好的模型。 让 n n n为观察数， R S S RSS RSS为剩余平方和，那么AIC变为： A I C = 2 k + n l n ( R S S / n ) AIC=2k+nln(RSS/n) AIC=2k+nln(RSS/n) 其中 k k k是模型中未知参数个数， L L L是模型中极大似然函数值似然函数。从一组可供选择的模型中选择最佳模型时，通常选择AIC最小的模型。 当两个模型之间存在较大差异时，差异主要体现在似然函数项， 当似然函数差异不显著时，上式第一项，即模型复杂度则起作用，从而参数个数少的模型是较好的选择。 一般而言，当模型复杂度提高（ k k k增大）时，似然函数L也会增大，从而使AIC变小，但是k过大时，似然函数增速减缓，导致AIC增大，模型过于复杂容易造成过拟合现象。目标是选取AIC最小的模型，AIC不仅要提高模型拟合度（极大似然），而且引入了惩罚项，使模型参数尽可能少，有助于降低过拟合的可能性。可见AIC准则有效且合理地控制了参数的维数k。显然AIC准则追求似然函数尽可能大的同时，k要尽可能的小。 举例： 设 y 1 , y 2 , ⋯ &amp;ThinSpace; , y n y_1,y_2,\\cdots,y_n y1​,y2​,⋯,yn​是来自未知总体 g ( y ) g(y) g(y)的样本。总体的概率密度为 f ( y ; θ ) f(y;θ) f(y;θ), θ θ θ是 r ∗ 1 r*1 r∗1未知参数向量。若 θ θ θ的极大似然估计是 θ ∗ θ^* θ∗，则 L ( θ ∗ ) = ∑ i = 1 n ( l n f ( y i ; θ ∗ ) 〗 L(θ^*)=\\sum_{i=1}^n(lnf(y_i;θ^*)〗 L(θ∗)=∑i=1n​(lnf(yi​;θ∗)〗就是对数似然函数，由此， A I C = − 2 L ( θ ∗ ) + 2 r AIC=-2L(θ^*)+2r AIC=−2L(θ∗)+2r 可以度量 f ( y ; θ ) f(y;θ) f(y;θ)与 g ( y ) g(y) g(y)之间的差异。 2.BIC准则(Bayesian InformationCriterion) BIC（Bayesian InformationCriterion）贝叶斯信息准则与AIC相似，用于模型选择，1978年由Schwarz提出。训练模型时，增加参数数量，也就是增加模型复杂度，会增大似然函数，但是也会导致过拟合现象，针对该问题，AIC和BIC均引入了与模型参数个数相关的惩罚项，BIC的惩罚项比AIC的大，考虑了样本数量，样本数量过多时，可有效防止模型精度过高造成的模型复杂度过高。 B I C = k l n ( n ) − 2 l n ( L ) BIC=kln(n)-2ln(L) BIC=kln(n)−2ln(L) 其中， k k k为模型参数个数， n n n为样本数量， L L L为似然函数。 k l n ( n ) kln(n) kln(n)惩罚项在维数过大且训练样本数据相对较少的情况下，可以有效避免出现维度灾难现象。 3.QAIC准则 为了使用过度离散（或缺乏拟合），提出了改进的AIC准则QAIC： Q A I C = − 2 l n ( L ) / c + 2 k QAIC=-2ln(L)/c+2k QAIC=−2ln(L)/c+2k 其中，c是方差膨胀因子。 4.QH准则(hannan-quinn criterion) H Q = − 2 l n ( L ) + l n ( l n ( n ) ) ∗ k HQ=-2 ln(L) + ln(ln(n))*k HQ=−2ln(L)+ln(ln(n))∗k 其中 L L L是在该模型下的最大似然， n n n是数据数量， k k k是模型的变量个数。 注意这些规则只是刻画了用某个模型之后相对“真实模型”的信息损失【因为不知道真正的模型是什么样子，所以训练得到的所有模型都只是真实模型的一个近似模型】，所以用这些规则不能说明某个模型的精确度。 这些规则理论上是比较漂亮的，但是实际在模型选择中应用比较困难的，如若有 5个变量则有32个变量组合，若为10个变量呢？2的10次方，故不可能对所有这些模型进行一一验证AIC, BIC，QAIC，HQ规则来选择模型，工作量太大。 转载自：博客一：https://blog.csdn.net/yinyu19950811/article/details/60964782 博客二：https://blog.csdn.net/xianlingmao/article/details/7891277","@type":"BlogPosting","url":"https://mlh.app/2019/04/07/728715.html","headline":"AIC、BIC、QAIC及HQ准则","dateModified":"2019-04-07T00:00:00+08:00","datePublished":"2019-04-07T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/04/07/728715.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>AIC、BIC、QAIC及HQ准则</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-light"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>很多参数估计问题均采用似然函数作为目标函数，当训练数据足够多时，可以不断提高模型精度，但是以提高模型复杂度为代价的，同时带来一个机器学习中非常普遍的问题——过拟合。所以，模型选择问题在模型复杂度与模型对数据集描述能力（即似然函数）之间寻求最佳平衡。</p> 
  <p>人们提出许多信息准则，通过加入模型复杂度的惩罚项来避免过拟合问题，此处我们介绍一下常用的两个模型选择方法——<strong>赤池信息准则</strong> （Akaike Information Criterion，AIC）和<strong>贝叶斯信息准则</strong> （Bayesian Information Criterion，BIC）。</p> 
  <p><strong>1.AIC准则(Akaike Information Criterion)</strong></p> 
  <p>AIC是衡量统计模型拟合优良性的一种标准，由日本统计学家赤池弘次在1974年提出，它建立在熵的概念上，提供了权衡估计模型复杂度和拟合数据优良性的标准。</p> 
  <p>通常情况下，它是拟合精度和参数未知个数的加权函数，AIC定义为：</p> 
  <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <mi>
           A
          </mi>
          <mi>
           I
          </mi>
          <mi>
           C
          </mi>
          <mo>
           =
          </mo>
          <mn>
           2
          </mn>
          <mi>
           k
          </mi>
          <mo>
           −
          </mo>
          <mn>
           2
          </mn>
          <mi>
           l
          </mi>
          <mi>
           n
          </mi>
          <mo>
           (
          </mo>
          <mi>
           L
          </mi>
          <mo>
           )
          </mo>
         </mrow>
         <annotation encoding="application/x-tex">
           AIC=2k-2ln(L) 
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right: 0.07847em;">I</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">L</span><span class="mclose">)</span></span></span></span></span></span></p> 
  <p>当在两个模型之间存在着相当大的差异时，这个差异出现于上式第二项，而当第二项不出现显著性差异时，第一项起作用，从而参数个数少的模型是好的模型。</p> 
  <p>让<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          n
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         n
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">n</span></span></span></span></span>为观察数，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          R
         </mi>
         <mi>
          S
         </mi>
         <mi>
          S
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         RSS
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.00773em;">R</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span>为剩余平方和，那么AIC变为：</p> 
  <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <mi>
           A
          </mi>
          <mi>
           I
          </mi>
          <mi>
           C
          </mi>
          <mo>
           =
          </mo>
          <mn>
           2
          </mn>
          <mi>
           k
          </mi>
          <mo>
           +
          </mo>
          <mi>
           n
          </mi>
          <mi>
           l
          </mi>
          <mi>
           n
          </mi>
          <mo>
           (
          </mo>
          <mi>
           R
          </mi>
          <mi>
           S
          </mi>
          <mi>
           S
          </mi>
          <mi mathvariant="normal">
           /
          </mi>
          <mi>
           n
          </mi>
          <mo>
           )
          </mo>
         </mrow>
         <annotation encoding="application/x-tex">
           AIC=2k+nln(RSS/n) 
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right: 0.07847em;">I</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.00773em;">R</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="mord">/</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></span></span></p> 
  <p>其中<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          k
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         k
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>是模型中未知参数个数，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          L
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         L
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit">L</span></span></span></span></span>是模型中极大似然函数值似然函数。从一组可供选择的模型中选择最佳模型时，通常选择AIC最小的模型。</p> 
  <p>当两个模型之间存在较大差异时，差异主要体现在似然函数项，</p> 
  <p>当似然函数差异不显著时，上式第一项，即模型复杂度则起作用，从而参数个数少的模型是较好的选择。</p> 
  <p>一般而言，当模型复杂度提高（<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          k
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         k
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>增大）时，似然函数L也会增大，从而使AIC变小，但是k过大时，似然函数增速减缓，导致AIC增大，模型过于复杂容易造成过拟合现象。目标是选取AIC最小的模型，AIC不仅要提高模型拟合度（极大似然），而且引入了惩罚项，使模型参数尽可能少，有助于降低过拟合的可能性。可见AIC准则有效且合理地控制了参数的维数k。显然AIC准则追求似然函数尽可能大的同时，k要尽可能的小。</p> 
  <p>举例：</p> 
  <p>设<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <msub>
          <mi>
           y
          </mi>
          <mn>
           1
          </mn>
         </msub>
         <mo separator="true">
          ,
         </mo>
         <msub>
          <mi>
           y
          </mi>
          <mn>
           2
          </mn>
         </msub>
         <mo separator="true">
          ,
         </mo>
         <mo>
          ⋯
         </mo>&amp;ThinSpace;
         <mo separator="true">
          ,
         </mo>
         <msub>
          <mi>
           y
          </mi>
          <mi>
           n
          </mi>
         </msub>
        </mrow>
        <annotation encoding="application/x-tex">
         y_1,y_2,\cdots,y_n
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是来自未知总体<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          g
         </mi>
         <mo>
          (
         </mo>
         <mi>
          y
         </mi>
         <mo>
          )
         </mo>
        </mrow>
        <annotation encoding="application/x-tex">
         g(y)
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="mclose">)</span></span></span></span></span>的样本。总体的概率密度为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          f
         </mi>
         <mo>
          (
         </mo>
         <mi>
          y
         </mi>
         <mo separator="true">
          ;
         </mo>
         <mi>
          θ
         </mi>
         <mo>
          )
         </mo>
        </mrow>
        <annotation encoding="application/x-tex">
         f(y;θ)
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="mpunct">;</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathit" style="margin-right: 0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span>,<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          θ
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         θ
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.02778em;">θ</span></span></span></span></span>是<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          r
         </mi>
         <mo>
          ∗
         </mo>
         <mn>
          1
         </mn>
        </mrow>
        <annotation encoding="application/x-tex">
         r*1
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.46528em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>未知参数向量。若<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          θ
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         θ
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.02778em;">θ</span></span></span></span></span>的极大似然估计是<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <msup>
          <mi>
           θ
          </mi>
          <mo>
           ∗
          </mo>
         </msup>
        </mrow>
        <annotation encoding="application/x-tex">
         θ^*
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.688696em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>，则<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          L
         </mi>
         <mo>
          (
         </mo>
         <msup>
          <mi>
           θ
          </mi>
          <mo>
           ∗
          </mo>
         </msup>
         <mo>
          )
         </mo>
         <mo>
          =
         </mo>
         <msubsup>
          <mo>
           ∑
          </mo>
          <mrow>
           <mi>
            i
           </mi>
           <mo>
            =
           </mo>
           <mn>
            1
           </mn>
          </mrow>
          <mi>
           n
          </mi>
         </msubsup>
         <mo>
          (
         </mo>
         <mi>
          l
         </mi>
         <mi>
          n
         </mi>
         <mi>
          f
         </mi>
         <mo>
          (
         </mo>
         <msub>
          <mi>
           y
          </mi>
          <mi>
           i
          </mi>
         </msub>
         <mo separator="true">
          ;
         </mo>
         <msup>
          <mi>
           θ
          </mi>
          <mo>
           ∗
          </mo>
         </msup>
         <mo>
          )
         </mo>
         <mi mathvariant="normal">
          〗
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         L(θ^*)=\sum_{i=1}^n(lnf(y_i;θ^*)〗
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right: 0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.688696em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.104em; vertical-align: -0.29971em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.804292em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.29971em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.688696em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">〗</span></span></span></span></span>就是对数似然函数，由此，</p> 
  <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <mi>
           A
          </mi>
          <mi>
           I
          </mi>
          <mi>
           C
          </mi>
          <mo>
           =
          </mo>
          <mo>
           −
          </mo>
          <mn>
           2
          </mn>
          <mi>
           L
          </mi>
          <mo>
           (
          </mo>
          <msup>
           <mi>
            θ
           </mi>
           <mo>
            ∗
           </mo>
          </msup>
          <mo>
           )
          </mo>
          <mo>
           +
          </mo>
          <mn>
           2
          </mn>
          <mi>
           r
          </mi>
         </mrow>
         <annotation encoding="application/x-tex">
           AIC=-2L(θ^*)+2r 
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right: 0.07847em;">I</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord mathit">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right: 0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.738696em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span></span></p> 
  <p>可以度量<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          f
         </mi>
         <mo>
          (
         </mo>
         <mi>
          y
         </mi>
         <mo separator="true">
          ;
         </mo>
         <mi>
          θ
         </mi>
         <mo>
          )
         </mo>
        </mrow>
        <annotation encoding="application/x-tex">
         f(y;θ)
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="mpunct">;</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathit" style="margin-right: 0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span>与<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          g
         </mi>
         <mo>
          (
         </mo>
         <mi>
          y
         </mi>
         <mo>
          )
         </mo>
        </mrow>
        <annotation encoding="application/x-tex">
         g(y)
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="mclose">)</span></span></span></span></span>之间的差异。</p> 
  <p><strong>2.BIC准则(Bayesian InformationCriterion)</strong></p> 
  <p>BIC（Bayesian InformationCriterion）贝叶斯信息准则与AIC相似，用于模型选择，1978年由Schwarz提出。训练模型时，增加参数数量，也就是增加模型复杂度，会增大似然函数，但是也会导致过拟合现象，针对该问题，AIC和BIC均引入了与模型参数个数相关的惩罚项，BIC的惩罚项比AIC的大，考虑了样本数量，样本数量过多时，可有效防止模型精度过高造成的模型复杂度过高。</p> 
  <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <mi>
           B
          </mi>
          <mi>
           I
          </mi>
          <mi>
           C
          </mi>
          <mo>
           =
          </mo>
          <mi>
           k
          </mi>
          <mi>
           l
          </mi>
          <mi>
           n
          </mi>
          <mo>
           (
          </mo>
          <mi>
           n
          </mi>
          <mo>
           )
          </mo>
          <mo>
           −
          </mo>
          <mn>
           2
          </mn>
          <mi>
           l
          </mi>
          <mi>
           n
          </mi>
          <mo>
           (
          </mo>
          <mi>
           L
          </mi>
          <mo>
           )
          </mo>
         </mrow>
         <annotation encoding="application/x-tex">
           BIC=kln(n)-2ln(L) 
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.05017em;">B</span><span class="mord mathit" style="margin-right: 0.07847em;">I</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">L</span><span class="mclose">)</span></span></span></span></span></span></p> 
  <p>其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          k
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         k
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>为模型参数个数，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          n
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         n
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">n</span></span></span></span></span>为样本数量，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          L
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         L
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit">L</span></span></span></span></span>为似然函数。<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          k
         </mi>
         <mi>
          l
         </mi>
         <mi>
          n
         </mi>
         <mo>
          (
         </mo>
         <mi>
          n
         </mi>
         <mo>
          )
         </mo>
        </mrow>
        <annotation encoding="application/x-tex">
         kln(n)
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></span>惩罚项在维数过大且训练样本数据相对较少的情况下，可以有效避免出现维度灾难现象。</p> 
  <p><strong>3.QAIC准则</strong></p> 
  <p>为了使用过度离散（或缺乏拟合），提出了改进的AIC准则QAIC：</p> 
  <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <mi>
           Q
          </mi>
          <mi>
           A
          </mi>
          <mi>
           I
          </mi>
          <mi>
           C
          </mi>
          <mo>
           =
          </mo>
          <mo>
           −
          </mo>
          <mn>
           2
          </mn>
          <mi>
           l
          </mi>
          <mi>
           n
          </mi>
          <mo>
           (
          </mo>
          <mi>
           L
          </mi>
          <mo>
           )
          </mo>
          <mi mathvariant="normal">
           /
          </mi>
          <mi>
           c
          </mi>
          <mo>
           +
          </mo>
          <mn>
           2
          </mn>
          <mi>
           k
          </mi>
         </mrow>
         <annotation encoding="application/x-tex">
           QAIC=-2ln(L)/c+2k 
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathit">Q</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right: 0.07847em;">I</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathit">c</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span></span><br> 其中，c是方差膨胀因子。</p> 
  <p><strong>4.QH准则(hannan-quinn criterion)</strong></p> 
  <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <mi>
           H
          </mi>
          <mi>
           Q
          </mi>
          <mo>
           =
          </mo>
          <mo>
           −
          </mo>
          <mn>
           2
          </mn>
          <mi>
           l
          </mi>
          <mi>
           n
          </mi>
          <mo>
           (
          </mo>
          <mi>
           L
          </mi>
          <mo>
           )
          </mo>
          <mo>
           +
          </mo>
          <mi>
           l
          </mi>
          <mi>
           n
          </mi>
          <mo>
           (
          </mo>
          <mi>
           l
          </mi>
          <mi>
           n
          </mi>
          <mo>
           (
          </mo>
          <mi>
           n
          </mi>
          <mo>
           )
          </mo>
          <mo>
           )
          </mo>
          <mo>
           ∗
          </mo>
          <mi>
           k
          </mi>
         </mrow>
         <annotation encoding="application/x-tex">
          HQ=-2 ln(L) + ln(ln(n))*k
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathit" style="margin-right: 0.08125em;">H</span><span class="mord mathit">Q</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">L</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></p> 
  <p>其中<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          L
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         L
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit">L</span></span></span></span></span>是在该模型下的最大似然，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          n
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         n
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">n</span></span></span></span></span>是数据数量，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          k
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         k
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>是模型的变量个数。</p> 
  <p>注意这些规则只是刻画了用某个模型之后相对“真实模型”的信息损失【因为不知道真正的模型是什么样子，所以训练得到的所有模型都只是真实模型的一个近似模型】，所以用这些规则不能说明某个模型的精确度。</p> 
  <p>这些规则理论上是比较漂亮的，但是实际在模型选择中应用比较困难的，如若有 5个变量则有32个变量组合，若为10个变量呢？2的10次方，故不可能对所有这些模型进行一一验证AIC, BIC，QAIC，HQ规则来选择模型，工作量太大。</p> 
  <p>转载自：<br>博客一：<a href="https://blog.csdn.net/yinyu19950811/article/details/60964782" rel="nofollow" target="_blank">https://blog.csdn.net/yinyu19950811/article/details/60964782</a></p> 
  <p>博客二：<a href="https://blog.csdn.net/xianlingmao/article/details/7891277" rel="nofollow" target="_blank">https://blog.csdn.net/xianlingmao/article/details/7891277</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
