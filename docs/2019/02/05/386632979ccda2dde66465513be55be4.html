<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>iOS窥探KVO底层实现原理篇 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="iOS窥探KVO底层实现原理篇" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Linux编程 点击右侧关注，免费入门到精通！ 作者丨大兵布莱恩特https://www.jianshu.com/p/0aa83ac521ba 最近小编公司招聘 iOS, 于是小编从网上找了几道面试题,来考察候选人iOS 开发方面的技术水平,其中有一道面试题便是 KVO 底层实现是什么? 如何手动出发 KVO? 修改成员变量的值会出发 KVO 吗? KVC 赋值会出发 KVO 吗? 当你了解 KVO 实现原理后,这几道面试题自然不在话下.接下来我将通过代码和讲解来窥探 KVO 背后的奥秘. 首先创建一个 Person 类 内部有个 name 属性,然后 创建p1 和 p2两个实例对象,其中p1添加了kvo监听,p2没有添加 kvo 监听,然后重写了 observeValueForKeyPath 方法 监听Person.name 属性发生改变时候的通知. 从本质上来看 Person 给name赋值的时候 调用的是 setName 方法 ,无论 p1还是p2 调用的 setter 方法都是一样的,为什么 p1改变 name 属性值就能有通知, p2确没有,调用的 都是同一个 setName:(NSString *)name 方法,区别怎么那么大? 小编窥探尝试1 接下来小编打印下p1和p2的内存地址 看看p1和p2内存地址能不能一探究竟. 从 p1和 p2内存地址上也看不出来什么东东. 小编窥探尝试2 打印 p1和 p2 的 class 信息 what 什么 输出的 class 都是 Person 类 ,既然同一个类 同一个 setter 方法,为什么我们不一样呢? 小编窥探尝试3 打印 object_getClass 试试看 我们都知道object_getClass(id) 才会返回这个实例对象的真实 class 类型 什么 , 添加 KVO 之后说好的 Person 类跑哪去了, NSKVONotifying_Person是什么东东? 为了进一步窥探 KVO 添加前后的变化 小编窥探尝试4 打印 setName 方法实现IMP指针有没有发生改变,我们知道同一个方法的实现 IMP 地址是不变的. 连 setName方法都不一样了 , 为了一探究竟 小编绝对对上边的 NSKVONotifying_Person 和 添加 KVO 之后的 imp 指针进行进一步研究. 首先 在 lldb 上输入 imp1和 imp2 发生了 imp1 方法实现在 Foundation 框架里的 _NSSetObjectValueAndNotify 函数中 ,而 imp2 则调用了 Person setName 方法 也就是说添加了 KVO 之后 p1 修改 name 值之后 不再调用 Person 的 setName方法 ,而 p2没有添加 kvo 监听 依然正常调用 setName:方法 ,由此可以得出 p1 添加完 KVO 监听后 系统修改了默认方法实现,那么既然没有调用 setName: 方法 为什么 p1.name 的值也发生了改变? 接下来我们准备对刚才 NSKVONotifying_Person 类进行下一步研究, NSKVONotifying_Person 和 Person 有没有内在的联系呢? 小编窥探尝试5 NSKVONotifying_Person和 Person 之间的联系时什么 通过打印 NSKVONotifying_Person 的 superclass &nbsp;和 Person 的 superclass 可以得出, NSKVONotifying_Person是一个 Person 子类,那么为什么苹果会动态创建这么一个 子类呢? NSKVONotifying_Person 这个子类 跟 Person 内部有哪些不同呢 ? 这个时候 我们去输出下 Person 和 NSKVONotifying_Person 内部的方法列表 和 属性列表 ,看看NSKVONotifying_Person 子类都添加了那些方法和属性. -&nbsp;(void)viewDidLoad&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;[super&nbsp;viewDidLoad];&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;*p1&nbsp;=&nbsp;[[Person&nbsp;alloc]&nbsp;init];&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;*p2&nbsp;=&nbsp;[[Person&nbsp;alloc]&nbsp;init];&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;cls1&nbsp;=&nbsp;object_getClass(p1);&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;cls2&nbsp;=&nbsp;object_getClass(p2);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;添加&nbsp;KVO&nbsp;之前:&nbsp;cls1&nbsp;=&nbsp;%@&nbsp;&nbsp;cls2&nbsp;=&nbsp;%@&nbsp;&quot;,cls1,cls2);&nbsp;&nbsp;&nbsp;&nbsp;[p1&nbsp;addObserver:self&nbsp;forKeyPath:@&quot;name&quot;&nbsp;options:NSKeyValueObservingOptionNew&nbsp;context:NULL];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls1&nbsp;=&nbsp;object_getClass(p1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls2&nbsp;=&nbsp;object_getClass(p2);&nbsp;&nbsp;&nbsp;&nbsp;NSString&nbsp;*methodList1&nbsp;=&nbsp;[self&nbsp;printPersonMethods:cls1];&nbsp;&nbsp;&nbsp;&nbsp;NSString&nbsp;*methodList2&nbsp;=&nbsp;[self&nbsp;printPersonMethods:cls2];&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%@&quot;,methodList1);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%@&quot;,methodList2);//&nbsp;&nbsp;NSLog(@&quot;添加&nbsp;KVO&nbsp;之后:&nbsp;cls1&nbsp;=&nbsp;%@&nbsp;&nbsp;cls2&nbsp;=&nbsp;%@&nbsp;&quot;,cls1,cls2);//&nbsp;&nbsp;id&nbsp;super_cls1&nbsp;=&nbsp;class_getSuperclass(cls1);//&nbsp;&nbsp;id&nbsp;super_cls2&nbsp;=&nbsp;class_getSuperclass(cls2);////&nbsp;&nbsp;NSLog(@&quot;super_cls1&nbsp;=&nbsp;%@&nbsp;,super_cls2&nbsp;=&nbsp;%@&quot;,super_cls1,super_cls2);////&nbsp;&nbsp;p1.name&nbsp;=&nbsp;@&quot;dzb&quot;;//&nbsp;&nbsp;p2.name&nbsp;=&nbsp;@&quot;123&quot;;}-&nbsp;(NSString&nbsp;*)&nbsp;printPersonMethods:(id)obj&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;*methods&nbsp;=&nbsp;class_copyMethodList([obj&nbsp;class],&amp;count);&nbsp;&nbsp;&nbsp;&nbsp;NSMutableString&nbsp;*methodList&nbsp;=&nbsp;[NSMutableString&nbsp;string];&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendString:@&quot;[ &quot;];&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&lt;count;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;method&nbsp;=&nbsp;methods[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SEL&nbsp;sel&nbsp;=&nbsp;method_getName(method);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendFormat:@&quot;%@&quot;,NSStringFromSelector(sel)];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendString:@&quot; &quot;];&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendFormat:@&quot;]&quot;];&nbsp;&nbsp;&nbsp;&nbsp;free(methods);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;methodList;} 从输出结果可以看出来 &nbsp;NSKVONotifying_Person 内部也有一个 setName:方法 &nbsp;还重写了 class 和 dealloc 方法 , _isKVOA, 那么我们可以大致的得出, p1添加 kVO 后 runtime 动态的生成了一个 &nbsp;NSKVONotifying_Person子类 并重写了 setName 方法 ,那么 setName 内部一定是做了一些事情,才会触发 &nbsp;observeValueForKeyPath 监听方法. 继续探究 NSKVONotifying_Person 子类 重写 setName 都做了什么? 其实 setName 方法内部 是调用了 Foundation 的 _NSSetObjectValueAndNotify 函数 ,在 _NSSetObjectValueAndNotify 内部 1首先会调用 willChangeValueForKey 2然后给 name 属性赋值 3 最后调用 didChangeValueForKey 4最后调用 observer 的 observeValueForKeyPath 去告诉监听器属性值发生了改变 . 由于苹果 Foundation 框架是不开源的 ,所以我们依然可以通过重写Person 的 &nbsp;willChangeValueForKey &nbsp;和 &nbsp;didChangeValueForKey 验证我们的猜想 . 首先当我们改变p1.name 的值时 并不是首先执行的 setName: 这个方法 ,而是先调用了 &nbsp;willChangeValueForKey &nbsp;其次 调用父类的 setter 方法 对属性赋值 ,然后再调用 &nbsp;didChangeValueForKey 方法 ,并在 didChangeValueForKey 内部 调用监听器的 &nbsp;observeValueForKeyPath方法 告诉外界 属性值发生了改变. 至于重写了 dealloc 和 class 方法 是为了做一些 KVO 释放内存 和 隐藏外界对于 NSKVONotifying_Person 子类的存在 这就是我们调用 [p1 class] 和 [p2 class]结果都显示 Person 类 ,让我们误以为 Person 没有发生变化 补充说明 ,KVC 对属性赋值时候 是会在这个类里边 去查找 _age &nbsp;isAge setAge setIsAge 等方法的 ,最终会调用属性的 setter 方法 ,那么如果添加了 KVO 还是会被触发的 . 相反 设置成员变量 &nbsp;_age 由于不会触发 setter 方法 ,因此不会去触发 KVO 相关的代码 . &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行" />
<meta property="og:description" content="Linux编程 点击右侧关注，免费入门到精通！ 作者丨大兵布莱恩特https://www.jianshu.com/p/0aa83ac521ba 最近小编公司招聘 iOS, 于是小编从网上找了几道面试题,来考察候选人iOS 开发方面的技术水平,其中有一道面试题便是 KVO 底层实现是什么? 如何手动出发 KVO? 修改成员变量的值会出发 KVO 吗? KVC 赋值会出发 KVO 吗? 当你了解 KVO 实现原理后,这几道面试题自然不在话下.接下来我将通过代码和讲解来窥探 KVO 背后的奥秘. 首先创建一个 Person 类 内部有个 name 属性,然后 创建p1 和 p2两个实例对象,其中p1添加了kvo监听,p2没有添加 kvo 监听,然后重写了 observeValueForKeyPath 方法 监听Person.name 属性发生改变时候的通知. 从本质上来看 Person 给name赋值的时候 调用的是 setName 方法 ,无论 p1还是p2 调用的 setter 方法都是一样的,为什么 p1改变 name 属性值就能有通知, p2确没有,调用的 都是同一个 setName:(NSString *)name 方法,区别怎么那么大? 小编窥探尝试1 接下来小编打印下p1和p2的内存地址 看看p1和p2内存地址能不能一探究竟. 从 p1和 p2内存地址上也看不出来什么东东. 小编窥探尝试2 打印 p1和 p2 的 class 信息 what 什么 输出的 class 都是 Person 类 ,既然同一个类 同一个 setter 方法,为什么我们不一样呢? 小编窥探尝试3 打印 object_getClass 试试看 我们都知道object_getClass(id) 才会返回这个实例对象的真实 class 类型 什么 , 添加 KVO 之后说好的 Person 类跑哪去了, NSKVONotifying_Person是什么东东? 为了进一步窥探 KVO 添加前后的变化 小编窥探尝试4 打印 setName 方法实现IMP指针有没有发生改变,我们知道同一个方法的实现 IMP 地址是不变的. 连 setName方法都不一样了 , 为了一探究竟 小编绝对对上边的 NSKVONotifying_Person 和 添加 KVO 之后的 imp 指针进行进一步研究. 首先 在 lldb 上输入 imp1和 imp2 发生了 imp1 方法实现在 Foundation 框架里的 _NSSetObjectValueAndNotify 函数中 ,而 imp2 则调用了 Person setName 方法 也就是说添加了 KVO 之后 p1 修改 name 值之后 不再调用 Person 的 setName方法 ,而 p2没有添加 kvo 监听 依然正常调用 setName:方法 ,由此可以得出 p1 添加完 KVO 监听后 系统修改了默认方法实现,那么既然没有调用 setName: 方法 为什么 p1.name 的值也发生了改变? 接下来我们准备对刚才 NSKVONotifying_Person 类进行下一步研究, NSKVONotifying_Person 和 Person 有没有内在的联系呢? 小编窥探尝试5 NSKVONotifying_Person和 Person 之间的联系时什么 通过打印 NSKVONotifying_Person 的 superclass &nbsp;和 Person 的 superclass 可以得出, NSKVONotifying_Person是一个 Person 子类,那么为什么苹果会动态创建这么一个 子类呢? NSKVONotifying_Person 这个子类 跟 Person 内部有哪些不同呢 ? 这个时候 我们去输出下 Person 和 NSKVONotifying_Person 内部的方法列表 和 属性列表 ,看看NSKVONotifying_Person 子类都添加了那些方法和属性. -&nbsp;(void)viewDidLoad&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;[super&nbsp;viewDidLoad];&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;*p1&nbsp;=&nbsp;[[Person&nbsp;alloc]&nbsp;init];&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;*p2&nbsp;=&nbsp;[[Person&nbsp;alloc]&nbsp;init];&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;cls1&nbsp;=&nbsp;object_getClass(p1);&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;cls2&nbsp;=&nbsp;object_getClass(p2);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;添加&nbsp;KVO&nbsp;之前:&nbsp;cls1&nbsp;=&nbsp;%@&nbsp;&nbsp;cls2&nbsp;=&nbsp;%@&nbsp;&quot;,cls1,cls2);&nbsp;&nbsp;&nbsp;&nbsp;[p1&nbsp;addObserver:self&nbsp;forKeyPath:@&quot;name&quot;&nbsp;options:NSKeyValueObservingOptionNew&nbsp;context:NULL];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls1&nbsp;=&nbsp;object_getClass(p1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls2&nbsp;=&nbsp;object_getClass(p2);&nbsp;&nbsp;&nbsp;&nbsp;NSString&nbsp;*methodList1&nbsp;=&nbsp;[self&nbsp;printPersonMethods:cls1];&nbsp;&nbsp;&nbsp;&nbsp;NSString&nbsp;*methodList2&nbsp;=&nbsp;[self&nbsp;printPersonMethods:cls2];&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%@&quot;,methodList1);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%@&quot;,methodList2);//&nbsp;&nbsp;NSLog(@&quot;添加&nbsp;KVO&nbsp;之后:&nbsp;cls1&nbsp;=&nbsp;%@&nbsp;&nbsp;cls2&nbsp;=&nbsp;%@&nbsp;&quot;,cls1,cls2);//&nbsp;&nbsp;id&nbsp;super_cls1&nbsp;=&nbsp;class_getSuperclass(cls1);//&nbsp;&nbsp;id&nbsp;super_cls2&nbsp;=&nbsp;class_getSuperclass(cls2);////&nbsp;&nbsp;NSLog(@&quot;super_cls1&nbsp;=&nbsp;%@&nbsp;,super_cls2&nbsp;=&nbsp;%@&quot;,super_cls1,super_cls2);////&nbsp;&nbsp;p1.name&nbsp;=&nbsp;@&quot;dzb&quot;;//&nbsp;&nbsp;p2.name&nbsp;=&nbsp;@&quot;123&quot;;}-&nbsp;(NSString&nbsp;*)&nbsp;printPersonMethods:(id)obj&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;*methods&nbsp;=&nbsp;class_copyMethodList([obj&nbsp;class],&amp;count);&nbsp;&nbsp;&nbsp;&nbsp;NSMutableString&nbsp;*methodList&nbsp;=&nbsp;[NSMutableString&nbsp;string];&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendString:@&quot;[ &quot;];&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&lt;count;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;method&nbsp;=&nbsp;methods[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SEL&nbsp;sel&nbsp;=&nbsp;method_getName(method);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendFormat:@&quot;%@&quot;,NSStringFromSelector(sel)];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendString:@&quot; &quot;];&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendFormat:@&quot;]&quot;];&nbsp;&nbsp;&nbsp;&nbsp;free(methods);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;methodList;} 从输出结果可以看出来 &nbsp;NSKVONotifying_Person 内部也有一个 setName:方法 &nbsp;还重写了 class 和 dealloc 方法 , _isKVOA, 那么我们可以大致的得出, p1添加 kVO 后 runtime 动态的生成了一个 &nbsp;NSKVONotifying_Person子类 并重写了 setName 方法 ,那么 setName 内部一定是做了一些事情,才会触发 &nbsp;observeValueForKeyPath 监听方法. 继续探究 NSKVONotifying_Person 子类 重写 setName 都做了什么? 其实 setName 方法内部 是调用了 Foundation 的 _NSSetObjectValueAndNotify 函数 ,在 _NSSetObjectValueAndNotify 内部 1首先会调用 willChangeValueForKey 2然后给 name 属性赋值 3 最后调用 didChangeValueForKey 4最后调用 observer 的 observeValueForKeyPath 去告诉监听器属性值发生了改变 . 由于苹果 Foundation 框架是不开源的 ,所以我们依然可以通过重写Person 的 &nbsp;willChangeValueForKey &nbsp;和 &nbsp;didChangeValueForKey 验证我们的猜想 . 首先当我们改变p1.name 的值时 并不是首先执行的 setName: 这个方法 ,而是先调用了 &nbsp;willChangeValueForKey &nbsp;其次 调用父类的 setter 方法 对属性赋值 ,然后再调用 &nbsp;didChangeValueForKey 方法 ,并在 didChangeValueForKey 内部 调用监听器的 &nbsp;observeValueForKeyPath方法 告诉外界 属性值发生了改变. 至于重写了 dealloc 和 class 方法 是为了做一些 KVO 释放内存 和 隐藏外界对于 NSKVONotifying_Person 子类的存在 这就是我们调用 [p1 class] 和 [p2 class]结果都显示 Person 类 ,让我们误以为 Person 没有发生变化 补充说明 ,KVC 对属性赋值时候 是会在这个类里边 去查找 _age &nbsp;isAge setAge setIsAge 等方法的 ,最终会调用属性的 setter 方法 ,那么如果添加了 KVO 还是会被触发的 . 相反 设置成员变量 &nbsp;_age 由于不会触发 setter 方法 ,因此不会去触发 KVO 相关的代码 . &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行" />
<link rel="canonical" href="https://mlh.app/2019/02/05/386632979ccda2dde66465513be55be4.html" />
<meta property="og:url" content="https://mlh.app/2019/02/05/386632979ccda2dde66465513be55be4.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-02-05T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Linux编程 点击右侧关注，免费入门到精通！ 作者丨大兵布莱恩特https://www.jianshu.com/p/0aa83ac521ba 最近小编公司招聘 iOS, 于是小编从网上找了几道面试题,来考察候选人iOS 开发方面的技术水平,其中有一道面试题便是 KVO 底层实现是什么? 如何手动出发 KVO? 修改成员变量的值会出发 KVO 吗? KVC 赋值会出发 KVO 吗? 当你了解 KVO 实现原理后,这几道面试题自然不在话下.接下来我将通过代码和讲解来窥探 KVO 背后的奥秘. 首先创建一个 Person 类 内部有个 name 属性,然后 创建p1 和 p2两个实例对象,其中p1添加了kvo监听,p2没有添加 kvo 监听,然后重写了 observeValueForKeyPath 方法 监听Person.name 属性发生改变时候的通知. 从本质上来看 Person 给name赋值的时候 调用的是 setName 方法 ,无论 p1还是p2 调用的 setter 方法都是一样的,为什么 p1改变 name 属性值就能有通知, p2确没有,调用的 都是同一个 setName:(NSString *)name 方法,区别怎么那么大? 小编窥探尝试1 接下来小编打印下p1和p2的内存地址 看看p1和p2内存地址能不能一探究竟. 从 p1和 p2内存地址上也看不出来什么东东. 小编窥探尝试2 打印 p1和 p2 的 class 信息 what 什么 输出的 class 都是 Person 类 ,既然同一个类 同一个 setter 方法,为什么我们不一样呢? 小编窥探尝试3 打印 object_getClass 试试看 我们都知道object_getClass(id) 才会返回这个实例对象的真实 class 类型 什么 , 添加 KVO 之后说好的 Person 类跑哪去了, NSKVONotifying_Person是什么东东? 为了进一步窥探 KVO 添加前后的变化 小编窥探尝试4 打印 setName 方法实现IMP指针有没有发生改变,我们知道同一个方法的实现 IMP 地址是不变的. 连 setName方法都不一样了 , 为了一探究竟 小编绝对对上边的 NSKVONotifying_Person 和 添加 KVO 之后的 imp 指针进行进一步研究. 首先 在 lldb 上输入 imp1和 imp2 发生了 imp1 方法实现在 Foundation 框架里的 _NSSetObjectValueAndNotify 函数中 ,而 imp2 则调用了 Person setName 方法 也就是说添加了 KVO 之后 p1 修改 name 值之后 不再调用 Person 的 setName方法 ,而 p2没有添加 kvo 监听 依然正常调用 setName:方法 ,由此可以得出 p1 添加完 KVO 监听后 系统修改了默认方法实现,那么既然没有调用 setName: 方法 为什么 p1.name 的值也发生了改变? 接下来我们准备对刚才 NSKVONotifying_Person 类进行下一步研究, NSKVONotifying_Person 和 Person 有没有内在的联系呢? 小编窥探尝试5 NSKVONotifying_Person和 Person 之间的联系时什么 通过打印 NSKVONotifying_Person 的 superclass &nbsp;和 Person 的 superclass 可以得出, NSKVONotifying_Person是一个 Person 子类,那么为什么苹果会动态创建这么一个 子类呢? NSKVONotifying_Person 这个子类 跟 Person 内部有哪些不同呢 ? 这个时候 我们去输出下 Person 和 NSKVONotifying_Person 内部的方法列表 和 属性列表 ,看看NSKVONotifying_Person 子类都添加了那些方法和属性. -&nbsp;(void)viewDidLoad&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;[super&nbsp;viewDidLoad];&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;*p1&nbsp;=&nbsp;[[Person&nbsp;alloc]&nbsp;init];&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;*p2&nbsp;=&nbsp;[[Person&nbsp;alloc]&nbsp;init];&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;cls1&nbsp;=&nbsp;object_getClass(p1);&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;cls2&nbsp;=&nbsp;object_getClass(p2);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;添加&nbsp;KVO&nbsp;之前:&nbsp;cls1&nbsp;=&nbsp;%@&nbsp;&nbsp;cls2&nbsp;=&nbsp;%@&nbsp;&quot;,cls1,cls2);&nbsp;&nbsp;&nbsp;&nbsp;[p1&nbsp;addObserver:self&nbsp;forKeyPath:@&quot;name&quot;&nbsp;options:NSKeyValueObservingOptionNew&nbsp;context:NULL];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls1&nbsp;=&nbsp;object_getClass(p1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls2&nbsp;=&nbsp;object_getClass(p2);&nbsp;&nbsp;&nbsp;&nbsp;NSString&nbsp;*methodList1&nbsp;=&nbsp;[self&nbsp;printPersonMethods:cls1];&nbsp;&nbsp;&nbsp;&nbsp;NSString&nbsp;*methodList2&nbsp;=&nbsp;[self&nbsp;printPersonMethods:cls2];&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%@&quot;,methodList1);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@&quot;%@&quot;,methodList2);//&nbsp;&nbsp;NSLog(@&quot;添加&nbsp;KVO&nbsp;之后:&nbsp;cls1&nbsp;=&nbsp;%@&nbsp;&nbsp;cls2&nbsp;=&nbsp;%@&nbsp;&quot;,cls1,cls2);//&nbsp;&nbsp;id&nbsp;super_cls1&nbsp;=&nbsp;class_getSuperclass(cls1);//&nbsp;&nbsp;id&nbsp;super_cls2&nbsp;=&nbsp;class_getSuperclass(cls2);////&nbsp;&nbsp;NSLog(@&quot;super_cls1&nbsp;=&nbsp;%@&nbsp;,super_cls2&nbsp;=&nbsp;%@&quot;,super_cls1,super_cls2);////&nbsp;&nbsp;p1.name&nbsp;=&nbsp;@&quot;dzb&quot;;//&nbsp;&nbsp;p2.name&nbsp;=&nbsp;@&quot;123&quot;;}-&nbsp;(NSString&nbsp;*)&nbsp;printPersonMethods:(id)obj&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;*methods&nbsp;=&nbsp;class_copyMethodList([obj&nbsp;class],&amp;count);&nbsp;&nbsp;&nbsp;&nbsp;NSMutableString&nbsp;*methodList&nbsp;=&nbsp;[NSMutableString&nbsp;string];&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendString:@&quot;[ &quot;];&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&lt;count;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;method&nbsp;=&nbsp;methods[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SEL&nbsp;sel&nbsp;=&nbsp;method_getName(method);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendFormat:@&quot;%@&quot;,NSStringFromSelector(sel)];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendString:@&quot; &quot;];&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendFormat:@&quot;]&quot;];&nbsp;&nbsp;&nbsp;&nbsp;free(methods);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;methodList;} 从输出结果可以看出来 &nbsp;NSKVONotifying_Person 内部也有一个 setName:方法 &nbsp;还重写了 class 和 dealloc 方法 , _isKVOA, 那么我们可以大致的得出, p1添加 kVO 后 runtime 动态的生成了一个 &nbsp;NSKVONotifying_Person子类 并重写了 setName 方法 ,那么 setName 内部一定是做了一些事情,才会触发 &nbsp;observeValueForKeyPath 监听方法. 继续探究 NSKVONotifying_Person 子类 重写 setName 都做了什么? 其实 setName 方法内部 是调用了 Foundation 的 _NSSetObjectValueAndNotify 函数 ,在 _NSSetObjectValueAndNotify 内部 1首先会调用 willChangeValueForKey 2然后给 name 属性赋值 3 最后调用 didChangeValueForKey 4最后调用 observer 的 observeValueForKeyPath 去告诉监听器属性值发生了改变 . 由于苹果 Foundation 框架是不开源的 ,所以我们依然可以通过重写Person 的 &nbsp;willChangeValueForKey &nbsp;和 &nbsp;didChangeValueForKey 验证我们的猜想 . 首先当我们改变p1.name 的值时 并不是首先执行的 setName: 这个方法 ,而是先调用了 &nbsp;willChangeValueForKey &nbsp;其次 调用父类的 setter 方法 对属性赋值 ,然后再调用 &nbsp;didChangeValueForKey 方法 ,并在 didChangeValueForKey 内部 调用监听器的 &nbsp;observeValueForKeyPath方法 告诉外界 属性值发生了改变. 至于重写了 dealloc 和 class 方法 是为了做一些 KVO 释放内存 和 隐藏外界对于 NSKVONotifying_Person 子类的存在 这就是我们调用 [p1 class] 和 [p2 class]结果都显示 Person 类 ,让我们误以为 Person 没有发生变化 补充说明 ,KVC 对属性赋值时候 是会在这个类里边 去查找 _age &nbsp;isAge setAge setIsAge 等方法的 ,最终会调用属性的 setter 方法 ,那么如果添加了 KVO 还是会被触发的 . 相反 设置成员变量 &nbsp;_age 由于不会触发 setter 方法 ,因此不会去触发 KVO 相关的代码 . &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行","@type":"BlogPosting","url":"https://mlh.app/2019/02/05/386632979ccda2dde66465513be55be4.html","headline":"iOS窥探KVO底层实现原理篇","dateModified":"2019-02-05T00:00:00+08:00","datePublished":"2019-02-05T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/02/05/386632979ccda2dde66465513be55be4.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>iOS窥探KVO底层实现原理篇</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="rich_media_content" id="js_content"> 
   <p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/XUfq62QbuNhyG8Y9IxZUNMLyjv7k7dsq3bia9CRMmdkOM1WyLYEHlib4MFfrqRE97iaUqJ7NwhZEoHu0U8NCXWzsA/640?wx_fmt=gif" alt="640?wx_fmt=gif"></p>
   <p style="min-height:1em;text-align:center;"><a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span class="js_jump_icon h5_image_link"><img style="letter-spacing:.544px;text-align:justify;color:rgb(62,62,62);width:76px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/XUfq62QbuNiaFZIbV1icByYIGKRlUcFt6IBMGhWJcyxibORgs6MEmSnJlA3ibibR7ibpudwZAbFZdqISttPaQTBkPPtQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></span></a></p>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span style="font-family:'宋体', SimSun;"><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"><strong>Linux编程</strong></span></strong></span></a>
   <span style="font-family:'黑体', SimHei;"><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong></span>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span style="letter-spacing:.544px;color:rgb(165,165,165);font-family:'黑体', SimHei;"><span>点击右侧关注，免费入门到精通！</span></span></a>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span class="js_jump_icon h5_image_link"><img style="width:56px;" title="1081255447.jpg" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/XUfq62QbuNiaFZIbV1icByYIGKRlUcFt6IldAicZsKdD8KXBZkWQz1eHWULt7Sy2XUdKWbFt8oY6f6nL5deCuF9yg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></span></a>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:14px;color:rgb(136,136,136);"><span style="font-size:14px;letter-spacing:1px;line-height:34.1333px;">作者丨大兵布莱恩特</span><br style="color:rgb(74,74,74);font-size:16px;letter-spacing:1px;line-height:34.1333px;"><span style="font-size:14px;letter-spacing:1px;line-height:34.1333px;">https://www.jianshu.com/p/0aa83ac521ba</span></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><span style="color:rgb(74,74,74);font-size:16px;letter-spacing:1px;line-height:34.1333px;"><br></span></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">最近小编公司招聘 iOS, 于是小编从网上找了几道面试题,来考察候选人iOS 开发方面的技术水平,其中有一道面试题便是</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br><strong>KVO 底层实现是什么?</strong></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br><strong>如何手动出发 KVO?</strong></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br><strong>修改成员变量的值会出发 KVO 吗?</strong></span></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);"><br>KVC 赋值会出发 KVO 吗?</span></strong></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>当你了解 KVO 实现原理后,这几道面试题自然不在话下.接下来我将通过代码和讲解来窥探 KVO 背后的奥秘.</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCAp1O5jt3gDcCib7TjMXovsqVFBAFmGyBdsNiaJ0Ly6oqADNXXJ4Lh0icB2w/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">首先创建一个 Person 类 内部有个 name 属性,然后 创建p1 和 p2两个实例对象,其中p1添加了kvo监听,p2没有添加 kvo 监听,然后重写了 observeValueForKeyPath 方法 监听Person.name 属性发生改变时候的通知.</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApeib0HHYPgsBFnlvRjicz6R51jGE7FSk7Nzrv6awOXNF4uXEvKCYCbibNA/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">从本质上来看 Person 给name赋值的时候 调用的是 setName 方法 ,无论 p1还是p2 调用的 setter 方法都是一样的,为什么 p1改变 name 属性值就能有通知, p2确没有,调用的 都是同一个 setName:(NSString *)name 方法,区别怎么那么大?</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif"></span><span style="font-size:16px;color:rgb(0,82,255);">小编窥探尝试1</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">接下来小编打印下p1和p2的内存地址 看看p1和p2内存地址能不能一探究竟.</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApJu5jsK08eVUMKXviaACCfR382Bk1oqNWpG9dFIfXN3zibwuJQVrg1u5g/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">从 p1和 p2内存地址上也看不出来什么东东.</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">小编窥探尝试2 打印 p1和 p2 的 class 信息</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApsqhscSbsicJhicrIgadicMcwiaC9wsNmrlRiclav19BT32tlnnse4ST3yMw/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">what 什么 输出的 class 都是 Person 类 ,既然同一个类 同一个 setter 方法,为什么我们不一样呢?</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">小编窥探尝试3 打印 object_getClass 试试看</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>我们都知道object_getClass(id) 才会返回这个实例对象的真实 class 类型</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApDEcHDdwP958WjOrVnloH6yw7FA0IWY57QnJn9e5HIKfMicgoGHzeaIw/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">什么 , 添加 KVO 之后说好的 Person 类跑哪去了, NSKVONotifying_Person是什么东东?</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">为了进一步窥探 KVO 添加前后的变化</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>小编窥探尝试4 打印 setName 方法实现IMP指针有没有发生改变,我们知道同一个方法的实现 IMP 地址是不变的.</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApiajWzjgRwMy3FgzUOXHcajzbmoOeIx0e2Up9mpfQHCkHtpIvkmkTkRw/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">连 setName方法都不一样了 , 为了一探究竟 小编绝对对上边的 NSKVONotifying_Person 和 添加 KVO 之后的 imp 指针进行进一步研究.</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">首先 在 lldb 上输入 imp1和 imp2</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApiasOhx0K9WJPlquqPhBns8ZUH5ibJNLaKOym7Auibe4Q93ibozYAMmtpNA/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">发生了 imp1 方法实现在 Foundation 框架里的 _NSSetObjectValueAndNotify 函数中 ,而 imp2 则调用了 Person setName 方法</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApX6B2icld0PYy2ibdfia1cE9SedJYdmqQ1vfMS8tpPyWJb3huTfpCzXA0w/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">也就是说添加了 KVO 之后 p1 修改 name 值之后 不再调用 Person 的 setName方法 ,而 p2没有添加 kvo 监听 依然正常调用 setName:方法 ,由此可以得出 p1 添加完 KVO 监听后 系统修改了默认方法实现,那么既然没有调用 setName: 方法 为什么 p1.name 的值也发生了改变?</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">接下来我们准备对刚才 NSKVONotifying_Person 类进行下一步研究, NSKVONotifying_Person 和 Person 有没有内在的联系呢?</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">小编窥探尝试5 NSKVONotifying_Person和 Person 之间的联系时什么</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCAp9ZibHKLc998eicicd5TwAyhlJ4S25Zw06SKkGh3GglN4SibYqoXbkJIicKw/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">通过打印 NSKVONotifying_Person 的 superclass &nbsp;和 Person 的 superclass 可以得出, NSKVONotifying_Person是一个 Person 子类,那么为什么苹果会动态创建这么一个 子类呢? NSKVONotifying_Person 这个子类 跟 Person 内部有哪些不同呢 ?</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">这个时候 我们去输出下 Person 和 NSKVONotifying_Person 内部的方法列表 和 属性列表 ,看看NSKVONotifying_Person 子类都添加了那些方法和属性.</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs objectivec" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">-&nbsp;(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">void</span>)viewDidLoad&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">super</span>&nbsp;viewDidLoad];<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;*p1&nbsp;=&nbsp;[[Person&nbsp;alloc]&nbsp;init];<br>&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;*p2&nbsp;=&nbsp;[[Person&nbsp;alloc]&nbsp;init];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">id</span>&nbsp;cls1&nbsp;=&nbsp;object_getClass(p1);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">id</span>&nbsp;cls2&nbsp;=&nbsp;object_getClass(p2);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">NSLog</span>(<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">@"添加&nbsp;KVO&nbsp;之前:&nbsp;cls1&nbsp;=&nbsp;%@&nbsp;&nbsp;cls2&nbsp;=&nbsp;%@&nbsp;"</span>,cls1,cls2);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;[p1&nbsp;addObserver:<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">self</span>&nbsp;forKeyPath:<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">@"name"</span>&nbsp;options:<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">NSKeyValueObservingOptionNew</span>&nbsp;context:<span class="hljs-literal" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">NULL</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls1&nbsp;=&nbsp;object_getClass(p1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls2&nbsp;=&nbsp;object_getClass(p2);<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">NSString</span>&nbsp;*methodList1&nbsp;=&nbsp;[<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">self</span>&nbsp;printPersonMethods:cls1];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">NSString</span>&nbsp;*methodList2&nbsp;=&nbsp;[<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">self</span>&nbsp;printPersonMethods:cls2];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">NSLog</span>(<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">@"%@"</span>,methodList1);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">NSLog</span>(<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">@"%@"</span>,methodList2);<br><br><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;&nbsp;NSLog(@"添加&nbsp;KVO&nbsp;之后:&nbsp;cls1&nbsp;=&nbsp;%@&nbsp;&nbsp;cls2&nbsp;=&nbsp;%@&nbsp;",cls1,cls2);</span><br><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;&nbsp;id&nbsp;super_cls1&nbsp;=&nbsp;class_getSuperclass(cls1);</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;&nbsp;id&nbsp;super_cls2&nbsp;=&nbsp;class_getSuperclass(cls2);</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;&nbsp;NSLog(@"super_cls1&nbsp;=&nbsp;%@&nbsp;,super_cls2&nbsp;=&nbsp;%@",super_cls1,super_cls2);</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;&nbsp;p1.name&nbsp;=&nbsp;@"dzb";</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;&nbsp;p2.name&nbsp;=&nbsp;@"123";</span><br><br>}<br><br>-&nbsp;(<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">NSString</span>&nbsp;*)&nbsp;printPersonMethods:(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">id</span>)obj&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">unsigned</span>&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;count&nbsp;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;*methods&nbsp;=&nbsp;class_copyMethodList([obj&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">class</span>],&amp;count);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">NSMutableString</span>&nbsp;*methodList&nbsp;=&nbsp;[<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">NSMutableString</span>&nbsp;string];<br>&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendString:<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">@"[ "</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>;&nbsp;i&lt;count;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;method&nbsp;=&nbsp;methods[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SEL&nbsp;sel&nbsp;=&nbsp;method_getName(method);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendFormat:<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">@"%@"</span>,<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">NSStringFromSelector</span>(sel)];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendString:<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">@" "</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;[methodList&nbsp;appendFormat:<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">@"]"</span>];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;free(methods);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">return</span>&nbsp;methodList;<br>}<br></code></pre>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApvPjg85gibXkOib930mgHKvU4nGVUxoHKMqWklKqloT9ZPS2qhs430wOQ/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">从输出结果可以看出来 &nbsp;NSKVONotifying_Person 内部也有一个 setName:方法 &nbsp;还重写了 class 和 dealloc 方法 , _isKVOA, 那么我们可以大致的得出, p1添加 kVO 后 runtime 动态的生成了一个 &nbsp;NSKVONotifying_Person子类 并重写了 setName 方法 ,那么 setName 内部一定是做了一些事情,才会触发 &nbsp;observeValueForKeyPath 监听方法.</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">继续探究 NSKVONotifying_Person 子类 重写 setName 都做了什么?</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>其实 setName 方法内部 是调用了 Foundation 的 _NSSetObjectValueAndNotify 函数 ,在 _NSSetObjectValueAndNotify 内部</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">1首先会调用 willChangeValueForKey</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>2然后给 name 属性赋值</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>3 最后调用 didChangeValueForKey</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>4最后调用 observer 的 observeValueForKeyPath 去告诉监听器属性值发生了改变 .</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApqMsohjX0jf4gD7M2sP1RJtAx8mkdCHtIAQj8PId5zXpEMic48WYiaYYQ/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">由于苹果 Foundation 框架是不开源的 ,所以我们依然可以通过重写Person 的 &nbsp;willChangeValueForKey &nbsp;和 &nbsp;didChangeValueForKey 验证我们的猜想 .</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCAp5pnAIhlA8hZicKQXCEfE1t6jn6pMKeFCYfibibbficXDHPCLwUac4ficjSg/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">首先当我们改变p1.name 的值时 并不是首先执行的 setName: 这个方法 ,而是先调用了 &nbsp;willChangeValueForKey &nbsp;其次 调用父类的 setter 方法 对属性赋值 ,然后再调用 &nbsp;didChangeValueForKey 方法 ,并在 didChangeValueForKey 内部 调用监听器的 &nbsp;observeValueForKeyPath方法 告诉外界 属性值发生了改变.</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApriaDNnXnhEm91PTyXnjGIYyRiadLocKN8Wic9Y19zug4AKPXr6LcgPURw/640?wx_fmt=other" alt="640?wx_fmt=other"></span></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApibQsiahwFdWLg4bycVejQZf4VkHTMcqsnjcibckgvVib04mUzq1aawibfVA/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">至于重写了 dealloc 和 class 方法 是为了做一些 KVO 释放内存 和 隐藏外界对于 NSKVONotifying_Person 子类的存在</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApcrXxCmpnNwlSJACc5ZLbohkjYG7EyfAmeSURHtic6uVHVHJtByu7JaA/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">这就是我们调用 [p1 class] 和 [p2 class]结果都显示 Person 类 ,让我们误以为 Person 没有发生变化</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>补充说明 ,KVC 对属性赋值时候 是会在这个类里边 去查找 _age &nbsp;isAge setAge setIsAge 等方法的 ,最终会调用属性的 setter 方法 ,那么如果添加了 KVO 还是会被触发的 .</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>相反 设置成员变量 &nbsp;_age 由于不会触发 setter 方法 ,因此不会去触发 KVO 相关的代码 .</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykolCEiahuWvHr1fxKvmSCApEeibW5LSP3jvVrOiahLPUZrBsiajKZ0JNd6DIGUnTN7lIysWbKWtgVOOg/640?wx_fmt=other" alt="640?wx_fmt=other"></p>
   <p><br></p>
   <p style="text-align:center;letter-spacing:1.5px;"><span style="color:rgb(255,255,255);"><strong><span style="font-size:20px;">&nbsp;推荐↓↓↓&nbsp;</span></strong></span></p>
   <img style="vertical-align:middle;width:313px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/IwiaNBuWUDUzX3vMCt57DzWD1FUkicYK3C3VObzhyt4YU3rXujLwMXHoHqpB6B72h44DNib9J9jbQHk3giaxAeABWg/640?wx_fmt=png" alt="640?wx_fmt=png">
   <p><strong>长</strong></p>
   <p><strong>按</strong></p>
   <p><strong>关</strong></p>
   <p><strong>注</strong></p>
   <p style="letter-spacing:0px;"><strong><span style="font-size:18px;">👉</span></strong><span style="font-size:17px;"><strong>【</strong></span><a href="https://mp.weixin.qq.com/s?__biz=MzUzMDc0NzU4Nw==&amp;mid=2247483768&amp;idx=1&amp;sn=4ef4f1510616baa395c507e32bb439d7&amp;scene=21#wechat_redirect" rel="nofollow" style="text-decoration:underline;color:rgb(255,79,121);font-size:17px;"><span style="color:rgb(255,79,121);font-size:17px;"><strong>16个技术公众号</strong></span></a><span style="font-size:17px;"><strong>】都在这里！</strong></span></p>
   <p><span style="color:rgb(136,136,136);font-size:15px;">涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。</span></p>
   <img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/ol72Wnba7fLkfGhCjKwHfZOmHMkVTIomtmHARHGo86u52ZIGicxfPPFBQ85dBUWf3trqDHPUuN7E2e26DpvfJdQ/640?wx_fmt=png" alt="640?wx_fmt=png">万水千山总是情，点个 “
   <strong><span style="color:rgb(0,112,192);">好看</span></strong>” 行不行
  </div> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
