<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>PEP 255 ：简单的生成器 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="PEP 255 ：简单的生成器" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="（给Python开发者加星标，提升Python技能） 作者：豌豆花下猫 （本文来自作者投稿） 摘要 这个 PEP 想在 Python 中引入生成器的概念，以及一个新的表达式，即 yield 表达式。 动机 当一个生产者函数在处理某些艰难的任务时，它可能需要维持住生产完某个值时的状态，大多数编程语言都提供不了既舒服又高效的方案，除了往参数列表中添加回调函数，然后每生产一个值时就去调用一下。 例如，标准库中的tokenize.py采用这种方法：调用者必须传一个 tokeneater 函数给 tokenize() ，当 tokenize() 找到下一个 token 时再调用。这使得 tokenize 能以自然的方式编码，但程序调用 tokenize 会变得极其复杂，因为它需要记住每次回调前最后出现的是哪个 token(s)。tabnanny.py中的 tokeneater 函数是处理得比较好的例子，它在全局变量中维护了一个状态机，用于记录已出现的 token 和预期会出现的 token 。这很难正确地工作，而且也挺难让人理解。不幸的是，它已经是最标准的解决方法了。 有一个替代方案是一次性生成 Python 程序的全部解析，并存入超大列表中。这样 tokenize 客户端可以用自然的方式，即使用局部变量和局部控制流（例如循环和嵌套的 if 语句），来跟踪其状态。然而这并不实用：程序会变得臃肿，因此不能在实现整个解析所需的内存上放置先验限制；而有些 tokenize 客户端仅仅想要查看某个特定的东西是否曾出现（例如，future 声明，或者像 IDLE 做的那样，只是首个缩进的声明），因此解析整个程序就是严重地浪费时间。 另一个替代方案是把 tokenize 变为一个迭代器【注释1】，每次调用它的 next() 方法时再传递下一个 token。这对调用者来说很便利，就像前一方案把结果存入大列表一样，同时没有内存与“想要早点退出怎么办”的缺点。然而，这个方案也把 tokenize 的负担转化成记住 next() 的调用状态，读者只要瞄一眼 tokenize.tokenize_loop() ，就会意识到这是一件多么可怕的苦差事。或者想象一下，用递归算法来生成普通树结构的节点：若把它投射成一个迭代器框架实现，就需要手动地移除递归状态并维护遍历的状态。 第四种选择是在不同的线程中运行生产者和消费者。这允许两者以自然的方式维护其状态，所以都会很舒服。实际上，Python 源代码发行版中的 Demo/threads/Generator.py 就提供了一个可用的同步通信（synchronized-communication）类，来完成一般的任务。但是，这在没有线程的平台上无法运用，而且就算可用也会很慢（与不用线程取得的成就比）。 最后一个选择是使用 Python 的变种 Stackless 【注释2-3】来实现，它支持轻量级的协程。它与前述的线程方案有相同的编程优势，效率还更高。然而，Stackless 在 Python 核心层存在争议，Jython 也可能不会实现相同的语义。这个 PEP 不是讨论这些问题的地方，但完全可以说生成器是 Stackless 相关功能的子集在当前 CPython 中的一种简单实现，而且可以说，其它 Python 实现起来也相对简单。 以上分析完了已有的方案。其它一些高级语言也提供了不错的解决方案，特别是 Sather 的迭代器，它受到 CLU 的迭代器启发【注释4】；Icon 的生成器，一种新颖的语言，其中每个表达式都是生成器【注释5】。它们虽有差异，但基本的思路是一致的：提供一种函数，它可以返回中间结果（“下一个值”）给它的调用者，同时还保存了函数的局部状态，以便在停止的位置恢复（译注：resum，下文也译作激活）调用。一个非常简单的例子： def&nbsp;fib():&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b&nbsp;=&nbsp;0,&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b&nbsp;=&nbsp;b,&nbsp;a+b 当 fib() 首次被调用时，它将 a 设为 0，将 b 设为 1，然后生成 b 给其调用者。调用者得到 1。当 fib 恢复时，从它的角度来看，yield 语句实际上跟 print 语句相同：fib 继续执行，且所有局部状态完好无损。然后，a 和 b 的值变为 1，并且 fib 再次循环到 yield，生成 1 给它的调用者。以此类推。 从 fib 的角度来看，它只是提供一系列结果，就像用了回调一样。但是从调用者的角度来看，fib 的调用就是一个可随时恢复的可迭代对象。跟线程一样，这允许两边以最自然的方式进行编码；但与线程方法不同，这可以在所有平台上高效完成。事实上，恢复生成器应该不比函数调用昂贵。 同样的方法适用于许多生产者/消费者函数。例如，tokenize.py 可以生成下一个 token 而不是用它作为参数调用回调函数，而且 tokenize 客户端可以以自然的方式迭代 tokens：Python 生成器是一种迭代器，但是特别强大。 设计规格：yield 引入了一种新的表达式： yield_stmt：“yield”expression_list yield 是一个新的关键字，因此需要一个&nbsp;future&nbsp;声明【注释8】来进行引入：在早期版本中，若想使用生成器的模块，必须在接近头部处包含以下行（详见 PEP 236）： from&nbsp;__future__&nbsp;import&nbsp;generators 没有引入 future 模块就使用 yield 关键字，将会告警。 在后续的版本中，yield 将是一个语言关键字，不再需要 future 语句。 yield 语句只能在函数内部使用。包含 yield 语句的函数被称为生成器函数。从各方面来看，生成器函数都只是个普通函数，但在它的代码对象的 co_flags 中设置了新的“CO_GENERATOR”标志。 当调用生成器函数时，实际参数还是绑定到函数的局部变量空间，但不会执行代码。得到的是一个 generator-iterator 对象；这符合迭代器协议【注释6】，因此可用于 for 循环。注意，在上下文无歧义的情况下，非限定名称 “generator” 既可以指生成器函数，又可以指生成器-迭代器（generator-iterator）。 每次调用 generator-iterator 的 next() 方法时，才会执行 generator-function 体中的代码，直至遇到 yield 或 return 语句（见下文），或者直接迭代到尽头。 如果执行到 yield 语句，则函数的状态会被冻结，并将 expression_list 的值返回给 next() 的调用者。“冻结”是指挂起所有本地状态，包括局部变量、指令指针和内部堆栈：保存足够信息，以便在下次调用 next() 时，函数可以继续执行，仿佛 yield 语句只是一次普通的外部调用。 限制：yield 语句不能用于 try-finally 结构的 try 子句中。困难的是不能保证生成器会被再次激活（resum），因此无法保证 finally 语句块会被执行；这就太违背 finally 的用处了。 限制：生成器在活跃状态时无法被再次激活： &gt;&gt;&gt;&nbsp;def&nbsp;g():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;me.next()...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;i&gt;&gt;&gt;&nbsp;me&nbsp;=&nbsp;g()&gt;&gt;&gt;&nbsp;me.next()Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):&nbsp;...&nbsp;File&nbsp;&quot;&lt;string&gt;&quot;,&nbsp;line&nbsp;2,&nbsp;in&nbsp;gValueError:&nbsp;generator&nbsp;already&nbsp;executing 设计规格：return 生成器函数可以包含以下形式的return语句： return 注意，生成器主体中的 return 语句不允许使用 expression_list （然而当然，它们可以嵌套地使用在生成器里的非生成器函数中）。 当执行到 return 语句时，程序会正常 return，继续执行恰当的 finally 子句（如果存在）。然后引发一个 StopIteration 异常，表明迭代器已经耗尽。如果程序没有显式 return 而执行到生成器的末尾，也会引发 StopIteration 异常。 请注意，对于生成器函数和非生成器函数，return 意味着“我已经完成，并且没有任何有趣的东西可以返回”。 注意，return 并不一定会引发 StopIteration ：关键在如何处理封闭的 try-except 结构。 如： &gt;&gt;&gt;&nbsp;def&nbsp;f1():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;1&gt;&gt;&gt;&nbsp;print&nbsp;list(f1())[] 因为，就像在任何函数中一样，return 只是退出，但是： &gt;&gt;&gt;&nbsp;def&nbsp;f2():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;StopIteration...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;42&gt;&gt;&gt;&nbsp;print&nbsp;list(f2())[42] 因为 StopIteration 被一个简单的 except 捕获，就像任意异常一样。 设计规格：生成器和异常传播 如果一个未捕获的异常——包括但不限于 StopIteration——由生成器函数引发或传递，则异常会以通常的方式传递给调用者，若试图重新激活生成器函数的话，则会引发 StopIteration 。 换句话说，未捕获的异常终结了生成器的使用寿命。 示例（不合语言习惯，仅作举例）： &gt;&gt;&gt;&nbsp;def&nbsp;f():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1/0&gt;&gt;&gt;&nbsp;def&nbsp;g():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;f()&nbsp;&nbsp;#&nbsp;the&nbsp;zero&nbsp;division&nbsp;exception&nbsp;propagates...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;42&nbsp;&nbsp;&nbsp;#&nbsp;and&nbsp;we&#39;ll&nbsp;never&nbsp;get&nbsp;here&gt;&gt;&gt;&nbsp;k&nbsp;=&nbsp;g()&gt;&gt;&gt;&nbsp;k.next()Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;1,&nbsp;in&nbsp;?&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;2,&nbsp;in&nbsp;g&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;2,&nbsp;in&nbsp;fZeroDivisionError:&nbsp;integer&nbsp;division&nbsp;or&nbsp;modulo&nbsp;by&nbsp;zero&gt;&gt;&gt;&nbsp;k.next()&nbsp;&nbsp;#&nbsp;and&nbsp;the&nbsp;generator&nbsp;cannot&nbsp;be&nbsp;resumedTraceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;1,&nbsp;in&nbsp;?StopIteration&gt;&gt;&gt; 设计规格：Try/Exception/Finally 前面提过，yield 语句不能用于 try-finally 结构的 try 子句中。这带来的结果是生成器要非常谨慎地分配关键的资源。但是在其它地方，yield 语句并无限制，例如 finally 子句、except 子句、或者 try-except 结构的 try 子句： &gt;&gt;&gt;&nbsp;def&nbsp;f():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;1...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;2...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1/0...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;3&nbsp;&nbsp;#&nbsp;never&nbsp;get&nbsp;here...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;ZeroDivisionError:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;4...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;5...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;6...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;&quot;raise&quot;&nbsp;above&nbsp;stops&nbsp;this...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;8...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;9...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;12...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;10...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;11&gt;&gt;&gt;&nbsp;print&nbsp;list(f())[1,&nbsp;2,&nbsp;4,&nbsp;5,&nbsp;8,&nbsp;9,&nbsp;10,&nbsp;11]&gt;&gt;&gt; 示例 #&nbsp;二叉树类class&nbsp;Tree:&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;label,&nbsp;left=None,&nbsp;right=None):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.label&nbsp;=&nbsp;label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.left&nbsp;=&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.right&nbsp;=&nbsp;right&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__repr__(self,&nbsp;level=0,&nbsp;indent=&quot;&nbsp;&nbsp;&nbsp;&nbsp;&quot;):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;level*indent&nbsp;+&nbsp;`self.label`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.left:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;s&nbsp;+&nbsp;&quot;\n&quot;&nbsp;+&nbsp;self.left.__repr__(level+1,&nbsp;indent)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.right:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;s&nbsp;+&nbsp;&quot;\n&quot;&nbsp;+&nbsp;self.right.__repr__(level+1,&nbsp;indent)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__iter__(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;inorder(self)#&nbsp;从列表中创建&nbsp;Treedef&nbsp;tree(list):&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(list)&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;n&nbsp;==&nbsp;0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;n&nbsp;/&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Tree(list[i],&nbsp;tree(list[:i]),&nbsp;tree(list[i+1:]))#&nbsp;递归生成器，按顺序生成树标签def&nbsp;inorder(t):&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;t:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;inorder(t.left):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;t.label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;inorder(t.right):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;x#&nbsp;展示：创建一棵树t&nbsp;=&nbsp;tree(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;)#&nbsp;按顺序打印树的节点for&nbsp;x&nbsp;in&nbsp;t:&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;x,print#&nbsp;非递归生成器def&nbsp;inorder(node):&nbsp;&nbsp;&nbsp;&nbsp;stack&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;node:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;node.left:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.append(node)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;node.label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;not&nbsp;node.right:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;stack.pop()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;IndexError:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;node.label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.right#&nbsp;练习非递归生成器for&nbsp;x&nbsp;in&nbsp;t:&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;x,printBoth&nbsp;output&nbsp;blocks&nbsp;display:A&nbsp;B&nbsp;C&nbsp;D&nbsp;E&nbsp;F&nbsp;G&nbsp;H&nbsp;I&nbsp;J&nbsp;K&nbsp;L&nbsp;M&nbsp;N&nbsp;O&nbsp;P&nbsp;Q&nbsp;R&nbsp;S&nbsp;T&nbsp;U&nbsp;V&nbsp;W&nbsp;X&nbsp;Y&nbsp;Z 问答 为什么重用 def 而不用新的关键字？ 请参阅下面的 BDFL 声明部分。 为什么用新的关键字yield而非内置函数？ Python 中通过关键字能更好地表达控制流，即 yield 是一个控制结构。而且为了 Jython 的高效实现，编译器需要在编译时就确定潜在的挂起点，新的关键字会使这一点变得简单。CPython 的实现也大量利用它来检测哪些函数是生成器函数（尽管一个新的关键字替代 def 就能解决 CPython 的问题，但人们问“为什么要新的关键字”问题时，并不想要新的关键字）。 为什么不是其它不带新关键字的特殊语法？ 例如，为何不用下面用法而用 yield 3： return&nbsp;3&nbsp;and&nbsp;continuereturn&nbsp;and&nbsp;continue&nbsp;3return&nbsp;generating&nbsp;3continue&nbsp;return&nbsp;3return&nbsp;&gt;&gt;&nbsp;,&nbsp;3from&nbsp;generator&nbsp;return&nbsp;3return&nbsp;&gt;&gt;&nbsp;3return&nbsp;&lt;&lt;&nbsp;3&gt;&gt;&nbsp;3&lt;&lt;&nbsp;3*&nbsp;3 我没有错过一个“眼色”吧？在数百条消息中，我算了每种替代方案有三条建议，然后总结出上面这些。不需要用新的关键字会很好，但使用 yield 会更好——我个人认为，在一堆无意义的关键字或运算符序列中，yield 更具表现力。尽管如此，如果这引起足够的兴趣，支持者应该发起一个提案，交给 Guido 裁断。 为什么允许用return，而不强制用StopIteration？ “StopIteration”的机制是底层细节，就像 Python 2.1 中的“IndexError”的机制一样：实现时需要做一些预先定义好的东西，而 Python 为高级用户开放了这些机制。尽管不强制要求每个人都在这个层级工作。 “return”在任何一种函数中都意味着“我已经完成”，这很容易解读和使用。注意，return&nbsp;并不总是等同于 try-except 结构中的&nbsp;raise StopIteration（参见“设计规格：Return”部分）。 那为什么不允许return一个表达式？ 也许有一天会允许。 在 Icon 中，return expr&nbsp;意味着“我已经完成”和“但我还有最后一个有用的值可以返回，这就是它”。 在初始阶段，不强制使用return expr的情况下，使用 yield 仅仅传递值，这很简单明了。 BDFL声明 Issue 引入另一个新的关键字（比如，gen 或 generator ）来代替 def ，或以其它方式改变语法，以区分生成器函数和非生成器函数。 Con 实际上（你如何看待它们），生成器是函数，但它们具有可恢复性。使它们建立起来的机制是一个相对较小的技术问题，引入新的关键字无助于强调生成器是如何启动的机制（生成器生命中至关重要却很小的部分）。 Pro 实际上（你如何看待它们），生成器函数实际上是工厂函数，它们就像施了魔法一样地生产生成器-迭代器。 在这方面，它们与非生成器函数完全不同，更像是构造函数而不是函数，因此重用 def 无疑是令人困惑的。藏在内部的 yield 语句不足以警示它们的语义是如此不同。 BDFL def 留了下来。任何一方都没有任何争论是完全令人信服的，所以我咨询了我的语言设计师的直觉。它告诉我 PEP 中提出的语法是完全正确的——不是太热，也不是太冷。但是，就像希腊神话中的 Delphi（译注：特尔斐，希腊古都） 的甲骨文一样，它并没有告诉我原因，所以我没有对反对此 PEP 语法的论点进行反驳。 我能想出的最好的（除了已经同意做出的反驳）是“FUD”（译注：缩写自 fear、uncertainty 和 doubt）。 如果这从第一天开始就是语言的一部分，我非常怀疑这早已让安德鲁·库奇林（Andrew Kuchling）的“Python Warts”页面成为可能。（译注：wart 是疣，一种难看的皮肤病。这是一个 wiki 页面，列举了对 Python 吹毛求疵的建议）。 参考实现 当前的实现（译注：2001年），处于初步状态（没有文档，但经过充分测试，可靠），是Python 的 CVS 开发树【注释9】的一部分。 使用它需要您从源代码中构建 Python。 这是衍生自 Neil Schemenauer【注释7】的早期补丁。 脚注和参考文献 [1] PEP-234, Iterators, Yee, Van Rossum http://www.python.org/dev/peps/pep-0234/ [2] http://www.stackless.com/ [3] PEP-219, Stackless Python, McMillan http://www.python.org/dev/peps/pep-0219/ [4] &quot;Iteration Abstraction in Sather&quot; Murer, Omohundro, Stoutamire and Szyperski&nbsp; http://www.icsi.berkeley.edu/~sather/Publications/toplas.html [5] http://www.cs.arizona.edu/icon/ [6] The&nbsp; concept&nbsp; of&nbsp; iterators&nbsp; is&nbsp; described&nbsp; in PEP 234.&nbsp; [7] http://python.ca/nas/python/generator.diff [8] PEP 236, Back to the&nbsp;future, Peters http://www.python.org/dev/peps/pep-0236/ [9] To experiment with this implementation, check out Python from CVS according to the instructions at http://sf.net/cvs/?group_id=5470 ，Note that the std test Lib/test/test_generators.py contains many examples, including all those in this PEP. 版权信息 本文档已经放置在公共领域。源文档： https://github.com/python/peps/blob/master/pep-0255.txt 【本文作者】 豌豆花下猫：某985高校毕业生， 兼具极客思维与人文情怀 。个人公众号Python猫， 专注python技术、数据科学和深度学习。 推荐阅读 （点击标题可跳转阅读） 完全理解 Python 迭代对象、迭代器、生成器 Python 生成器原理详解 Python 迭代器和生成器 觉得本文对你有帮助？请分享给更多人 关注「Python开发者」加星标，提升Python技能 喜欢就点一下「好看」呗~" />
<meta property="og:description" content="（给Python开发者加星标，提升Python技能） 作者：豌豆花下猫 （本文来自作者投稿） 摘要 这个 PEP 想在 Python 中引入生成器的概念，以及一个新的表达式，即 yield 表达式。 动机 当一个生产者函数在处理某些艰难的任务时，它可能需要维持住生产完某个值时的状态，大多数编程语言都提供不了既舒服又高效的方案，除了往参数列表中添加回调函数，然后每生产一个值时就去调用一下。 例如，标准库中的tokenize.py采用这种方法：调用者必须传一个 tokeneater 函数给 tokenize() ，当 tokenize() 找到下一个 token 时再调用。这使得 tokenize 能以自然的方式编码，但程序调用 tokenize 会变得极其复杂，因为它需要记住每次回调前最后出现的是哪个 token(s)。tabnanny.py中的 tokeneater 函数是处理得比较好的例子，它在全局变量中维护了一个状态机，用于记录已出现的 token 和预期会出现的 token 。这很难正确地工作，而且也挺难让人理解。不幸的是，它已经是最标准的解决方法了。 有一个替代方案是一次性生成 Python 程序的全部解析，并存入超大列表中。这样 tokenize 客户端可以用自然的方式，即使用局部变量和局部控制流（例如循环和嵌套的 if 语句），来跟踪其状态。然而这并不实用：程序会变得臃肿，因此不能在实现整个解析所需的内存上放置先验限制；而有些 tokenize 客户端仅仅想要查看某个特定的东西是否曾出现（例如，future 声明，或者像 IDLE 做的那样，只是首个缩进的声明），因此解析整个程序就是严重地浪费时间。 另一个替代方案是把 tokenize 变为一个迭代器【注释1】，每次调用它的 next() 方法时再传递下一个 token。这对调用者来说很便利，就像前一方案把结果存入大列表一样，同时没有内存与“想要早点退出怎么办”的缺点。然而，这个方案也把 tokenize 的负担转化成记住 next() 的调用状态，读者只要瞄一眼 tokenize.tokenize_loop() ，就会意识到这是一件多么可怕的苦差事。或者想象一下，用递归算法来生成普通树结构的节点：若把它投射成一个迭代器框架实现，就需要手动地移除递归状态并维护遍历的状态。 第四种选择是在不同的线程中运行生产者和消费者。这允许两者以自然的方式维护其状态，所以都会很舒服。实际上，Python 源代码发行版中的 Demo/threads/Generator.py 就提供了一个可用的同步通信（synchronized-communication）类，来完成一般的任务。但是，这在没有线程的平台上无法运用，而且就算可用也会很慢（与不用线程取得的成就比）。 最后一个选择是使用 Python 的变种 Stackless 【注释2-3】来实现，它支持轻量级的协程。它与前述的线程方案有相同的编程优势，效率还更高。然而，Stackless 在 Python 核心层存在争议，Jython 也可能不会实现相同的语义。这个 PEP 不是讨论这些问题的地方，但完全可以说生成器是 Stackless 相关功能的子集在当前 CPython 中的一种简单实现，而且可以说，其它 Python 实现起来也相对简单。 以上分析完了已有的方案。其它一些高级语言也提供了不错的解决方案，特别是 Sather 的迭代器，它受到 CLU 的迭代器启发【注释4】；Icon 的生成器，一种新颖的语言，其中每个表达式都是生成器【注释5】。它们虽有差异，但基本的思路是一致的：提供一种函数，它可以返回中间结果（“下一个值”）给它的调用者，同时还保存了函数的局部状态，以便在停止的位置恢复（译注：resum，下文也译作激活）调用。一个非常简单的例子： def&nbsp;fib():&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b&nbsp;=&nbsp;0,&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b&nbsp;=&nbsp;b,&nbsp;a+b 当 fib() 首次被调用时，它将 a 设为 0，将 b 设为 1，然后生成 b 给其调用者。调用者得到 1。当 fib 恢复时，从它的角度来看，yield 语句实际上跟 print 语句相同：fib 继续执行，且所有局部状态完好无损。然后，a 和 b 的值变为 1，并且 fib 再次循环到 yield，生成 1 给它的调用者。以此类推。 从 fib 的角度来看，它只是提供一系列结果，就像用了回调一样。但是从调用者的角度来看，fib 的调用就是一个可随时恢复的可迭代对象。跟线程一样，这允许两边以最自然的方式进行编码；但与线程方法不同，这可以在所有平台上高效完成。事实上，恢复生成器应该不比函数调用昂贵。 同样的方法适用于许多生产者/消费者函数。例如，tokenize.py 可以生成下一个 token 而不是用它作为参数调用回调函数，而且 tokenize 客户端可以以自然的方式迭代 tokens：Python 生成器是一种迭代器，但是特别强大。 设计规格：yield 引入了一种新的表达式： yield_stmt：“yield”expression_list yield 是一个新的关键字，因此需要一个&nbsp;future&nbsp;声明【注释8】来进行引入：在早期版本中，若想使用生成器的模块，必须在接近头部处包含以下行（详见 PEP 236）： from&nbsp;__future__&nbsp;import&nbsp;generators 没有引入 future 模块就使用 yield 关键字，将会告警。 在后续的版本中，yield 将是一个语言关键字，不再需要 future 语句。 yield 语句只能在函数内部使用。包含 yield 语句的函数被称为生成器函数。从各方面来看，生成器函数都只是个普通函数，但在它的代码对象的 co_flags 中设置了新的“CO_GENERATOR”标志。 当调用生成器函数时，实际参数还是绑定到函数的局部变量空间，但不会执行代码。得到的是一个 generator-iterator 对象；这符合迭代器协议【注释6】，因此可用于 for 循环。注意，在上下文无歧义的情况下，非限定名称 “generator” 既可以指生成器函数，又可以指生成器-迭代器（generator-iterator）。 每次调用 generator-iterator 的 next() 方法时，才会执行 generator-function 体中的代码，直至遇到 yield 或 return 语句（见下文），或者直接迭代到尽头。 如果执行到 yield 语句，则函数的状态会被冻结，并将 expression_list 的值返回给 next() 的调用者。“冻结”是指挂起所有本地状态，包括局部变量、指令指针和内部堆栈：保存足够信息，以便在下次调用 next() 时，函数可以继续执行，仿佛 yield 语句只是一次普通的外部调用。 限制：yield 语句不能用于 try-finally 结构的 try 子句中。困难的是不能保证生成器会被再次激活（resum），因此无法保证 finally 语句块会被执行；这就太违背 finally 的用处了。 限制：生成器在活跃状态时无法被再次激活： &gt;&gt;&gt;&nbsp;def&nbsp;g():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;me.next()...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;i&gt;&gt;&gt;&nbsp;me&nbsp;=&nbsp;g()&gt;&gt;&gt;&nbsp;me.next()Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):&nbsp;...&nbsp;File&nbsp;&quot;&lt;string&gt;&quot;,&nbsp;line&nbsp;2,&nbsp;in&nbsp;gValueError:&nbsp;generator&nbsp;already&nbsp;executing 设计规格：return 生成器函数可以包含以下形式的return语句： return 注意，生成器主体中的 return 语句不允许使用 expression_list （然而当然，它们可以嵌套地使用在生成器里的非生成器函数中）。 当执行到 return 语句时，程序会正常 return，继续执行恰当的 finally 子句（如果存在）。然后引发一个 StopIteration 异常，表明迭代器已经耗尽。如果程序没有显式 return 而执行到生成器的末尾，也会引发 StopIteration 异常。 请注意，对于生成器函数和非生成器函数，return 意味着“我已经完成，并且没有任何有趣的东西可以返回”。 注意，return 并不一定会引发 StopIteration ：关键在如何处理封闭的 try-except 结构。 如： &gt;&gt;&gt;&nbsp;def&nbsp;f1():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;1&gt;&gt;&gt;&nbsp;print&nbsp;list(f1())[] 因为，就像在任何函数中一样，return 只是退出，但是： &gt;&gt;&gt;&nbsp;def&nbsp;f2():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;StopIteration...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;42&gt;&gt;&gt;&nbsp;print&nbsp;list(f2())[42] 因为 StopIteration 被一个简单的 except 捕获，就像任意异常一样。 设计规格：生成器和异常传播 如果一个未捕获的异常——包括但不限于 StopIteration——由生成器函数引发或传递，则异常会以通常的方式传递给调用者，若试图重新激活生成器函数的话，则会引发 StopIteration 。 换句话说，未捕获的异常终结了生成器的使用寿命。 示例（不合语言习惯，仅作举例）： &gt;&gt;&gt;&nbsp;def&nbsp;f():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1/0&gt;&gt;&gt;&nbsp;def&nbsp;g():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;f()&nbsp;&nbsp;#&nbsp;the&nbsp;zero&nbsp;division&nbsp;exception&nbsp;propagates...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;42&nbsp;&nbsp;&nbsp;#&nbsp;and&nbsp;we&#39;ll&nbsp;never&nbsp;get&nbsp;here&gt;&gt;&gt;&nbsp;k&nbsp;=&nbsp;g()&gt;&gt;&gt;&nbsp;k.next()Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;1,&nbsp;in&nbsp;?&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;2,&nbsp;in&nbsp;g&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;2,&nbsp;in&nbsp;fZeroDivisionError:&nbsp;integer&nbsp;division&nbsp;or&nbsp;modulo&nbsp;by&nbsp;zero&gt;&gt;&gt;&nbsp;k.next()&nbsp;&nbsp;#&nbsp;and&nbsp;the&nbsp;generator&nbsp;cannot&nbsp;be&nbsp;resumedTraceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;1,&nbsp;in&nbsp;?StopIteration&gt;&gt;&gt; 设计规格：Try/Exception/Finally 前面提过，yield 语句不能用于 try-finally 结构的 try 子句中。这带来的结果是生成器要非常谨慎地分配关键的资源。但是在其它地方，yield 语句并无限制，例如 finally 子句、except 子句、或者 try-except 结构的 try 子句： &gt;&gt;&gt;&nbsp;def&nbsp;f():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;1...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;2...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1/0...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;3&nbsp;&nbsp;#&nbsp;never&nbsp;get&nbsp;here...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;ZeroDivisionError:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;4...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;5...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;6...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;&quot;raise&quot;&nbsp;above&nbsp;stops&nbsp;this...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;8...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;9...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;12...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;10...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;11&gt;&gt;&gt;&nbsp;print&nbsp;list(f())[1,&nbsp;2,&nbsp;4,&nbsp;5,&nbsp;8,&nbsp;9,&nbsp;10,&nbsp;11]&gt;&gt;&gt; 示例 #&nbsp;二叉树类class&nbsp;Tree:&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;label,&nbsp;left=None,&nbsp;right=None):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.label&nbsp;=&nbsp;label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.left&nbsp;=&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.right&nbsp;=&nbsp;right&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__repr__(self,&nbsp;level=0,&nbsp;indent=&quot;&nbsp;&nbsp;&nbsp;&nbsp;&quot;):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;level*indent&nbsp;+&nbsp;`self.label`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.left:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;s&nbsp;+&nbsp;&quot;\n&quot;&nbsp;+&nbsp;self.left.__repr__(level+1,&nbsp;indent)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.right:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;s&nbsp;+&nbsp;&quot;\n&quot;&nbsp;+&nbsp;self.right.__repr__(level+1,&nbsp;indent)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__iter__(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;inorder(self)#&nbsp;从列表中创建&nbsp;Treedef&nbsp;tree(list):&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(list)&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;n&nbsp;==&nbsp;0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;n&nbsp;/&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Tree(list[i],&nbsp;tree(list[:i]),&nbsp;tree(list[i+1:]))#&nbsp;递归生成器，按顺序生成树标签def&nbsp;inorder(t):&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;t:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;inorder(t.left):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;t.label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;inorder(t.right):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;x#&nbsp;展示：创建一棵树t&nbsp;=&nbsp;tree(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;)#&nbsp;按顺序打印树的节点for&nbsp;x&nbsp;in&nbsp;t:&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;x,print#&nbsp;非递归生成器def&nbsp;inorder(node):&nbsp;&nbsp;&nbsp;&nbsp;stack&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;node:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;node.left:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.append(node)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;node.label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;not&nbsp;node.right:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;stack.pop()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;IndexError:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;node.label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.right#&nbsp;练习非递归生成器for&nbsp;x&nbsp;in&nbsp;t:&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;x,printBoth&nbsp;output&nbsp;blocks&nbsp;display:A&nbsp;B&nbsp;C&nbsp;D&nbsp;E&nbsp;F&nbsp;G&nbsp;H&nbsp;I&nbsp;J&nbsp;K&nbsp;L&nbsp;M&nbsp;N&nbsp;O&nbsp;P&nbsp;Q&nbsp;R&nbsp;S&nbsp;T&nbsp;U&nbsp;V&nbsp;W&nbsp;X&nbsp;Y&nbsp;Z 问答 为什么重用 def 而不用新的关键字？ 请参阅下面的 BDFL 声明部分。 为什么用新的关键字yield而非内置函数？ Python 中通过关键字能更好地表达控制流，即 yield 是一个控制结构。而且为了 Jython 的高效实现，编译器需要在编译时就确定潜在的挂起点，新的关键字会使这一点变得简单。CPython 的实现也大量利用它来检测哪些函数是生成器函数（尽管一个新的关键字替代 def 就能解决 CPython 的问题，但人们问“为什么要新的关键字”问题时，并不想要新的关键字）。 为什么不是其它不带新关键字的特殊语法？ 例如，为何不用下面用法而用 yield 3： return&nbsp;3&nbsp;and&nbsp;continuereturn&nbsp;and&nbsp;continue&nbsp;3return&nbsp;generating&nbsp;3continue&nbsp;return&nbsp;3return&nbsp;&gt;&gt;&nbsp;,&nbsp;3from&nbsp;generator&nbsp;return&nbsp;3return&nbsp;&gt;&gt;&nbsp;3return&nbsp;&lt;&lt;&nbsp;3&gt;&gt;&nbsp;3&lt;&lt;&nbsp;3*&nbsp;3 我没有错过一个“眼色”吧？在数百条消息中，我算了每种替代方案有三条建议，然后总结出上面这些。不需要用新的关键字会很好，但使用 yield 会更好——我个人认为，在一堆无意义的关键字或运算符序列中，yield 更具表现力。尽管如此，如果这引起足够的兴趣，支持者应该发起一个提案，交给 Guido 裁断。 为什么允许用return，而不强制用StopIteration？ “StopIteration”的机制是底层细节，就像 Python 2.1 中的“IndexError”的机制一样：实现时需要做一些预先定义好的东西，而 Python 为高级用户开放了这些机制。尽管不强制要求每个人都在这个层级工作。 “return”在任何一种函数中都意味着“我已经完成”，这很容易解读和使用。注意，return&nbsp;并不总是等同于 try-except 结构中的&nbsp;raise StopIteration（参见“设计规格：Return”部分）。 那为什么不允许return一个表达式？ 也许有一天会允许。 在 Icon 中，return expr&nbsp;意味着“我已经完成”和“但我还有最后一个有用的值可以返回，这就是它”。 在初始阶段，不强制使用return expr的情况下，使用 yield 仅仅传递值，这很简单明了。 BDFL声明 Issue 引入另一个新的关键字（比如，gen 或 generator ）来代替 def ，或以其它方式改变语法，以区分生成器函数和非生成器函数。 Con 实际上（你如何看待它们），生成器是函数，但它们具有可恢复性。使它们建立起来的机制是一个相对较小的技术问题，引入新的关键字无助于强调生成器是如何启动的机制（生成器生命中至关重要却很小的部分）。 Pro 实际上（你如何看待它们），生成器函数实际上是工厂函数，它们就像施了魔法一样地生产生成器-迭代器。 在这方面，它们与非生成器函数完全不同，更像是构造函数而不是函数，因此重用 def 无疑是令人困惑的。藏在内部的 yield 语句不足以警示它们的语义是如此不同。 BDFL def 留了下来。任何一方都没有任何争论是完全令人信服的，所以我咨询了我的语言设计师的直觉。它告诉我 PEP 中提出的语法是完全正确的——不是太热，也不是太冷。但是，就像希腊神话中的 Delphi（译注：特尔斐，希腊古都） 的甲骨文一样，它并没有告诉我原因，所以我没有对反对此 PEP 语法的论点进行反驳。 我能想出的最好的（除了已经同意做出的反驳）是“FUD”（译注：缩写自 fear、uncertainty 和 doubt）。 如果这从第一天开始就是语言的一部分，我非常怀疑这早已让安德鲁·库奇林（Andrew Kuchling）的“Python Warts”页面成为可能。（译注：wart 是疣，一种难看的皮肤病。这是一个 wiki 页面，列举了对 Python 吹毛求疵的建议）。 参考实现 当前的实现（译注：2001年），处于初步状态（没有文档，但经过充分测试，可靠），是Python 的 CVS 开发树【注释9】的一部分。 使用它需要您从源代码中构建 Python。 这是衍生自 Neil Schemenauer【注释7】的早期补丁。 脚注和参考文献 [1] PEP-234, Iterators, Yee, Van Rossum http://www.python.org/dev/peps/pep-0234/ [2] http://www.stackless.com/ [3] PEP-219, Stackless Python, McMillan http://www.python.org/dev/peps/pep-0219/ [4] &quot;Iteration Abstraction in Sather&quot; Murer, Omohundro, Stoutamire and Szyperski&nbsp; http://www.icsi.berkeley.edu/~sather/Publications/toplas.html [5] http://www.cs.arizona.edu/icon/ [6] The&nbsp; concept&nbsp; of&nbsp; iterators&nbsp; is&nbsp; described&nbsp; in PEP 234.&nbsp; [7] http://python.ca/nas/python/generator.diff [8] PEP 236, Back to the&nbsp;future, Peters http://www.python.org/dev/peps/pep-0236/ [9] To experiment with this implementation, check out Python from CVS according to the instructions at http://sf.net/cvs/?group_id=5470 ，Note that the std test Lib/test/test_generators.py contains many examples, including all those in this PEP. 版权信息 本文档已经放置在公共领域。源文档： https://github.com/python/peps/blob/master/pep-0255.txt 【本文作者】 豌豆花下猫：某985高校毕业生， 兼具极客思维与人文情怀 。个人公众号Python猫， 专注python技术、数据科学和深度学习。 推荐阅读 （点击标题可跳转阅读） 完全理解 Python 迭代对象、迭代器、生成器 Python 生成器原理详解 Python 迭代器和生成器 觉得本文对你有帮助？请分享给更多人 关注「Python开发者」加星标，提升Python技能 喜欢就点一下「好看」呗~" />
<link rel="canonical" href="https://mlh.app/2019/02/04/b3cd4a541225e82f86d5a662adc0aa29.html" />
<meta property="og:url" content="https://mlh.app/2019/02/04/b3cd4a541225e82f86d5a662adc0aa29.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-02-04T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"（给Python开发者加星标，提升Python技能） 作者：豌豆花下猫 （本文来自作者投稿） 摘要 这个 PEP 想在 Python 中引入生成器的概念，以及一个新的表达式，即 yield 表达式。 动机 当一个生产者函数在处理某些艰难的任务时，它可能需要维持住生产完某个值时的状态，大多数编程语言都提供不了既舒服又高效的方案，除了往参数列表中添加回调函数，然后每生产一个值时就去调用一下。 例如，标准库中的tokenize.py采用这种方法：调用者必须传一个 tokeneater 函数给 tokenize() ，当 tokenize() 找到下一个 token 时再调用。这使得 tokenize 能以自然的方式编码，但程序调用 tokenize 会变得极其复杂，因为它需要记住每次回调前最后出现的是哪个 token(s)。tabnanny.py中的 tokeneater 函数是处理得比较好的例子，它在全局变量中维护了一个状态机，用于记录已出现的 token 和预期会出现的 token 。这很难正确地工作，而且也挺难让人理解。不幸的是，它已经是最标准的解决方法了。 有一个替代方案是一次性生成 Python 程序的全部解析，并存入超大列表中。这样 tokenize 客户端可以用自然的方式，即使用局部变量和局部控制流（例如循环和嵌套的 if 语句），来跟踪其状态。然而这并不实用：程序会变得臃肿，因此不能在实现整个解析所需的内存上放置先验限制；而有些 tokenize 客户端仅仅想要查看某个特定的东西是否曾出现（例如，future 声明，或者像 IDLE 做的那样，只是首个缩进的声明），因此解析整个程序就是严重地浪费时间。 另一个替代方案是把 tokenize 变为一个迭代器【注释1】，每次调用它的 next() 方法时再传递下一个 token。这对调用者来说很便利，就像前一方案把结果存入大列表一样，同时没有内存与“想要早点退出怎么办”的缺点。然而，这个方案也把 tokenize 的负担转化成记住 next() 的调用状态，读者只要瞄一眼 tokenize.tokenize_loop() ，就会意识到这是一件多么可怕的苦差事。或者想象一下，用递归算法来生成普通树结构的节点：若把它投射成一个迭代器框架实现，就需要手动地移除递归状态并维护遍历的状态。 第四种选择是在不同的线程中运行生产者和消费者。这允许两者以自然的方式维护其状态，所以都会很舒服。实际上，Python 源代码发行版中的 Demo/threads/Generator.py 就提供了一个可用的同步通信（synchronized-communication）类，来完成一般的任务。但是，这在没有线程的平台上无法运用，而且就算可用也会很慢（与不用线程取得的成就比）。 最后一个选择是使用 Python 的变种 Stackless 【注释2-3】来实现，它支持轻量级的协程。它与前述的线程方案有相同的编程优势，效率还更高。然而，Stackless 在 Python 核心层存在争议，Jython 也可能不会实现相同的语义。这个 PEP 不是讨论这些问题的地方，但完全可以说生成器是 Stackless 相关功能的子集在当前 CPython 中的一种简单实现，而且可以说，其它 Python 实现起来也相对简单。 以上分析完了已有的方案。其它一些高级语言也提供了不错的解决方案，特别是 Sather 的迭代器，它受到 CLU 的迭代器启发【注释4】；Icon 的生成器，一种新颖的语言，其中每个表达式都是生成器【注释5】。它们虽有差异，但基本的思路是一致的：提供一种函数，它可以返回中间结果（“下一个值”）给它的调用者，同时还保存了函数的局部状态，以便在停止的位置恢复（译注：resum，下文也译作激活）调用。一个非常简单的例子： def&nbsp;fib():&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b&nbsp;=&nbsp;0,&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b&nbsp;=&nbsp;b,&nbsp;a+b 当 fib() 首次被调用时，它将 a 设为 0，将 b 设为 1，然后生成 b 给其调用者。调用者得到 1。当 fib 恢复时，从它的角度来看，yield 语句实际上跟 print 语句相同：fib 继续执行，且所有局部状态完好无损。然后，a 和 b 的值变为 1，并且 fib 再次循环到 yield，生成 1 给它的调用者。以此类推。 从 fib 的角度来看，它只是提供一系列结果，就像用了回调一样。但是从调用者的角度来看，fib 的调用就是一个可随时恢复的可迭代对象。跟线程一样，这允许两边以最自然的方式进行编码；但与线程方法不同，这可以在所有平台上高效完成。事实上，恢复生成器应该不比函数调用昂贵。 同样的方法适用于许多生产者/消费者函数。例如，tokenize.py 可以生成下一个 token 而不是用它作为参数调用回调函数，而且 tokenize 客户端可以以自然的方式迭代 tokens：Python 生成器是一种迭代器，但是特别强大。 设计规格：yield 引入了一种新的表达式： yield_stmt：“yield”expression_list yield 是一个新的关键字，因此需要一个&nbsp;future&nbsp;声明【注释8】来进行引入：在早期版本中，若想使用生成器的模块，必须在接近头部处包含以下行（详见 PEP 236）： from&nbsp;__future__&nbsp;import&nbsp;generators 没有引入 future 模块就使用 yield 关键字，将会告警。 在后续的版本中，yield 将是一个语言关键字，不再需要 future 语句。 yield 语句只能在函数内部使用。包含 yield 语句的函数被称为生成器函数。从各方面来看，生成器函数都只是个普通函数，但在它的代码对象的 co_flags 中设置了新的“CO_GENERATOR”标志。 当调用生成器函数时，实际参数还是绑定到函数的局部变量空间，但不会执行代码。得到的是一个 generator-iterator 对象；这符合迭代器协议【注释6】，因此可用于 for 循环。注意，在上下文无歧义的情况下，非限定名称 “generator” 既可以指生成器函数，又可以指生成器-迭代器（generator-iterator）。 每次调用 generator-iterator 的 next() 方法时，才会执行 generator-function 体中的代码，直至遇到 yield 或 return 语句（见下文），或者直接迭代到尽头。 如果执行到 yield 语句，则函数的状态会被冻结，并将 expression_list 的值返回给 next() 的调用者。“冻结”是指挂起所有本地状态，包括局部变量、指令指针和内部堆栈：保存足够信息，以便在下次调用 next() 时，函数可以继续执行，仿佛 yield 语句只是一次普通的外部调用。 限制：yield 语句不能用于 try-finally 结构的 try 子句中。困难的是不能保证生成器会被再次激活（resum），因此无法保证 finally 语句块会被执行；这就太违背 finally 的用处了。 限制：生成器在活跃状态时无法被再次激活： &gt;&gt;&gt;&nbsp;def&nbsp;g():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;me.next()...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;i&gt;&gt;&gt;&nbsp;me&nbsp;=&nbsp;g()&gt;&gt;&gt;&nbsp;me.next()Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):&nbsp;...&nbsp;File&nbsp;&quot;&lt;string&gt;&quot;,&nbsp;line&nbsp;2,&nbsp;in&nbsp;gValueError:&nbsp;generator&nbsp;already&nbsp;executing 设计规格：return 生成器函数可以包含以下形式的return语句： return 注意，生成器主体中的 return 语句不允许使用 expression_list （然而当然，它们可以嵌套地使用在生成器里的非生成器函数中）。 当执行到 return 语句时，程序会正常 return，继续执行恰当的 finally 子句（如果存在）。然后引发一个 StopIteration 异常，表明迭代器已经耗尽。如果程序没有显式 return 而执行到生成器的末尾，也会引发 StopIteration 异常。 请注意，对于生成器函数和非生成器函数，return 意味着“我已经完成，并且没有任何有趣的东西可以返回”。 注意，return 并不一定会引发 StopIteration ：关键在如何处理封闭的 try-except 结构。 如： &gt;&gt;&gt;&nbsp;def&nbsp;f1():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;1&gt;&gt;&gt;&nbsp;print&nbsp;list(f1())[] 因为，就像在任何函数中一样，return 只是退出，但是： &gt;&gt;&gt;&nbsp;def&nbsp;f2():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;StopIteration...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;42&gt;&gt;&gt;&nbsp;print&nbsp;list(f2())[42] 因为 StopIteration 被一个简单的 except 捕获，就像任意异常一样。 设计规格：生成器和异常传播 如果一个未捕获的异常——包括但不限于 StopIteration——由生成器函数引发或传递，则异常会以通常的方式传递给调用者，若试图重新激活生成器函数的话，则会引发 StopIteration 。 换句话说，未捕获的异常终结了生成器的使用寿命。 示例（不合语言习惯，仅作举例）： &gt;&gt;&gt;&nbsp;def&nbsp;f():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1/0&gt;&gt;&gt;&nbsp;def&nbsp;g():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;f()&nbsp;&nbsp;#&nbsp;the&nbsp;zero&nbsp;division&nbsp;exception&nbsp;propagates...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;42&nbsp;&nbsp;&nbsp;#&nbsp;and&nbsp;we&#39;ll&nbsp;never&nbsp;get&nbsp;here&gt;&gt;&gt;&nbsp;k&nbsp;=&nbsp;g()&gt;&gt;&gt;&nbsp;k.next()Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;1,&nbsp;in&nbsp;?&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;2,&nbsp;in&nbsp;g&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;2,&nbsp;in&nbsp;fZeroDivisionError:&nbsp;integer&nbsp;division&nbsp;or&nbsp;modulo&nbsp;by&nbsp;zero&gt;&gt;&gt;&nbsp;k.next()&nbsp;&nbsp;#&nbsp;and&nbsp;the&nbsp;generator&nbsp;cannot&nbsp;be&nbsp;resumedTraceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;1,&nbsp;in&nbsp;?StopIteration&gt;&gt;&gt; 设计规格：Try/Exception/Finally 前面提过，yield 语句不能用于 try-finally 结构的 try 子句中。这带来的结果是生成器要非常谨慎地分配关键的资源。但是在其它地方，yield 语句并无限制，例如 finally 子句、except 子句、或者 try-except 结构的 try 子句： &gt;&gt;&gt;&nbsp;def&nbsp;f():...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;1...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;2...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1/0...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;3&nbsp;&nbsp;#&nbsp;never&nbsp;get&nbsp;here...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;ZeroDivisionError:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;4...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;5...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;6...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;&quot;raise&quot;&nbsp;above&nbsp;stops&nbsp;this...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;8...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;9...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;12...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;10...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;11&gt;&gt;&gt;&nbsp;print&nbsp;list(f())[1,&nbsp;2,&nbsp;4,&nbsp;5,&nbsp;8,&nbsp;9,&nbsp;10,&nbsp;11]&gt;&gt;&gt; 示例 #&nbsp;二叉树类class&nbsp;Tree:&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;label,&nbsp;left=None,&nbsp;right=None):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.label&nbsp;=&nbsp;label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.left&nbsp;=&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.right&nbsp;=&nbsp;right&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__repr__(self,&nbsp;level=0,&nbsp;indent=&quot;&nbsp;&nbsp;&nbsp;&nbsp;&quot;):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;level*indent&nbsp;+&nbsp;`self.label`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.left:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;s&nbsp;+&nbsp;&quot;\\n&quot;&nbsp;+&nbsp;self.left.__repr__(level+1,&nbsp;indent)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.right:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;s&nbsp;+&nbsp;&quot;\\n&quot;&nbsp;+&nbsp;self.right.__repr__(level+1,&nbsp;indent)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__iter__(self):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;inorder(self)#&nbsp;从列表中创建&nbsp;Treedef&nbsp;tree(list):&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(list)&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;n&nbsp;==&nbsp;0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;n&nbsp;/&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Tree(list[i],&nbsp;tree(list[:i]),&nbsp;tree(list[i+1:]))#&nbsp;递归生成器，按顺序生成树标签def&nbsp;inorder(t):&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;t:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;inorder(t.left):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;t.label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;inorder(t.right):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;x#&nbsp;展示：创建一棵树t&nbsp;=&nbsp;tree(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;)#&nbsp;按顺序打印树的节点for&nbsp;x&nbsp;in&nbsp;t:&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;x,print#&nbsp;非递归生成器def&nbsp;inorder(node):&nbsp;&nbsp;&nbsp;&nbsp;stack&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;node:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;node.left:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.append(node)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;node.label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;not&nbsp;node.right:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;stack.pop()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;IndexError:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;node.label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.right#&nbsp;练习非递归生成器for&nbsp;x&nbsp;in&nbsp;t:&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;x,printBoth&nbsp;output&nbsp;blocks&nbsp;display:A&nbsp;B&nbsp;C&nbsp;D&nbsp;E&nbsp;F&nbsp;G&nbsp;H&nbsp;I&nbsp;J&nbsp;K&nbsp;L&nbsp;M&nbsp;N&nbsp;O&nbsp;P&nbsp;Q&nbsp;R&nbsp;S&nbsp;T&nbsp;U&nbsp;V&nbsp;W&nbsp;X&nbsp;Y&nbsp;Z 问答 为什么重用 def 而不用新的关键字？ 请参阅下面的 BDFL 声明部分。 为什么用新的关键字yield而非内置函数？ Python 中通过关键字能更好地表达控制流，即 yield 是一个控制结构。而且为了 Jython 的高效实现，编译器需要在编译时就确定潜在的挂起点，新的关键字会使这一点变得简单。CPython 的实现也大量利用它来检测哪些函数是生成器函数（尽管一个新的关键字替代 def 就能解决 CPython 的问题，但人们问“为什么要新的关键字”问题时，并不想要新的关键字）。 为什么不是其它不带新关键字的特殊语法？ 例如，为何不用下面用法而用 yield 3： return&nbsp;3&nbsp;and&nbsp;continuereturn&nbsp;and&nbsp;continue&nbsp;3return&nbsp;generating&nbsp;3continue&nbsp;return&nbsp;3return&nbsp;&gt;&gt;&nbsp;,&nbsp;3from&nbsp;generator&nbsp;return&nbsp;3return&nbsp;&gt;&gt;&nbsp;3return&nbsp;&lt;&lt;&nbsp;3&gt;&gt;&nbsp;3&lt;&lt;&nbsp;3*&nbsp;3 我没有错过一个“眼色”吧？在数百条消息中，我算了每种替代方案有三条建议，然后总结出上面这些。不需要用新的关键字会很好，但使用 yield 会更好——我个人认为，在一堆无意义的关键字或运算符序列中，yield 更具表现力。尽管如此，如果这引起足够的兴趣，支持者应该发起一个提案，交给 Guido 裁断。 为什么允许用return，而不强制用StopIteration？ “StopIteration”的机制是底层细节，就像 Python 2.1 中的“IndexError”的机制一样：实现时需要做一些预先定义好的东西，而 Python 为高级用户开放了这些机制。尽管不强制要求每个人都在这个层级工作。 “return”在任何一种函数中都意味着“我已经完成”，这很容易解读和使用。注意，return&nbsp;并不总是等同于 try-except 结构中的&nbsp;raise StopIteration（参见“设计规格：Return”部分）。 那为什么不允许return一个表达式？ 也许有一天会允许。 在 Icon 中，return expr&nbsp;意味着“我已经完成”和“但我还有最后一个有用的值可以返回，这就是它”。 在初始阶段，不强制使用return expr的情况下，使用 yield 仅仅传递值，这很简单明了。 BDFL声明 Issue 引入另一个新的关键字（比如，gen 或 generator ）来代替 def ，或以其它方式改变语法，以区分生成器函数和非生成器函数。 Con 实际上（你如何看待它们），生成器是函数，但它们具有可恢复性。使它们建立起来的机制是一个相对较小的技术问题，引入新的关键字无助于强调生成器是如何启动的机制（生成器生命中至关重要却很小的部分）。 Pro 实际上（你如何看待它们），生成器函数实际上是工厂函数，它们就像施了魔法一样地生产生成器-迭代器。 在这方面，它们与非生成器函数完全不同，更像是构造函数而不是函数，因此重用 def 无疑是令人困惑的。藏在内部的 yield 语句不足以警示它们的语义是如此不同。 BDFL def 留了下来。任何一方都没有任何争论是完全令人信服的，所以我咨询了我的语言设计师的直觉。它告诉我 PEP 中提出的语法是完全正确的——不是太热，也不是太冷。但是，就像希腊神话中的 Delphi（译注：特尔斐，希腊古都） 的甲骨文一样，它并没有告诉我原因，所以我没有对反对此 PEP 语法的论点进行反驳。 我能想出的最好的（除了已经同意做出的反驳）是“FUD”（译注：缩写自 fear、uncertainty 和 doubt）。 如果这从第一天开始就是语言的一部分，我非常怀疑这早已让安德鲁·库奇林（Andrew Kuchling）的“Python Warts”页面成为可能。（译注：wart 是疣，一种难看的皮肤病。这是一个 wiki 页面，列举了对 Python 吹毛求疵的建议）。 参考实现 当前的实现（译注：2001年），处于初步状态（没有文档，但经过充分测试，可靠），是Python 的 CVS 开发树【注释9】的一部分。 使用它需要您从源代码中构建 Python。 这是衍生自 Neil Schemenauer【注释7】的早期补丁。 脚注和参考文献 [1] PEP-234, Iterators, Yee, Van Rossum http://www.python.org/dev/peps/pep-0234/ [2] http://www.stackless.com/ [3] PEP-219, Stackless Python, McMillan http://www.python.org/dev/peps/pep-0219/ [4] &quot;Iteration Abstraction in Sather&quot; Murer, Omohundro, Stoutamire and Szyperski&nbsp; http://www.icsi.berkeley.edu/~sather/Publications/toplas.html [5] http://www.cs.arizona.edu/icon/ [6] The&nbsp; concept&nbsp; of&nbsp; iterators&nbsp; is&nbsp; described&nbsp; in PEP 234.&nbsp; [7] http://python.ca/nas/python/generator.diff [8] PEP 236, Back to the&nbsp;future, Peters http://www.python.org/dev/peps/pep-0236/ [9] To experiment with this implementation, check out Python from CVS according to the instructions at http://sf.net/cvs/?group_id=5470 ，Note that the std test Lib/test/test_generators.py contains many examples, including all those in this PEP. 版权信息 本文档已经放置在公共领域。源文档： https://github.com/python/peps/blob/master/pep-0255.txt 【本文作者】 豌豆花下猫：某985高校毕业生， 兼具极客思维与人文情怀 。个人公众号Python猫， 专注python技术、数据科学和深度学习。 推荐阅读 （点击标题可跳转阅读） 完全理解 Python 迭代对象、迭代器、生成器 Python 生成器原理详解 Python 迭代器和生成器 觉得本文对你有帮助？请分享给更多人 关注「Python开发者」加星标，提升Python技能 喜欢就点一下「好看」呗~","@type":"BlogPosting","url":"https://mlh.app/2019/02/04/b3cd4a541225e82f86d5a662adc0aa29.html","headline":"PEP 255 ：简单的生成器","dateModified":"2019-02-04T00:00:00+08:00","datePublished":"2019-02-04T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/02/04/b3cd4a541225e82f86d5a662adc0aa29.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>PEP 255 ：简单的生成器</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="rich_media_content" id="js_content"> 
   <p style="min-height:1em;color:rgb(51,51,51);text-align:center;"><span style="font-family:'-apple-system-font', 'system-ui', 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;letter-spacing:.544px;font-size:14px;color:rgb(255,41,65);line-height:22.4px;">（给</span><span style="font-family:'-apple-system-font', 'system-ui', 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;letter-spacing:.544px;font-size:14px;line-height:22.4px;color:rgb(0,128,255);">Python开发者</span><span style="font-family:'-apple-system-font', 'system-ui', 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;letter-spacing:.544px;font-size:14px;color:rgb(255,41,65);line-height:22.4px;">加星标，提升Python技能</span><span style="font-family:'-apple-system-font', 'system-ui', 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;letter-spacing:.544px;color:rgb(255,41,65);font-size:14px;line-height:22.4px;">）</span><span style="color:rgb(255,41,65);font-size:14px;line-height:22.4px;"></span></p>
   <p style="min-height:1em;color:rgb(51,51,51);"><br></p>
   <blockquote>
    <p><span style="font-size:14px;">作者：<span style="font-size:14px;color:rgb(62,62,62);letter-spacing:1px;word-spacing:-2px;">豌豆花下猫</span> （本文来自作者投稿）</span></p>
   </blockquote>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">摘要</span></h2>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">这个 PEP 想在 Python 中引入生成器的概念，以及一个新的表达式，即 yield 表达式。</span></p>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">动机</span></h2>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">当一个生产者函数在处理某些艰难的任务时，它可能需要维持住生产完某个值时的状态，大多数编程语言都提供不了既舒服又高效的方案，除了往参数列表中添加回调函数，然后每生产一个值时就去调用一下。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">例如，标准库中的</span><code style="margin-left:2px;font-size:inherit;line-height:inherit;color:rgb(248,35,117);background:rgb(248,248,248);"><span style="font-size:15px;">tokenize.py</span></code><span style="font-size:15px;">采用这种方法：调用者必须传一个 tokeneater 函数给 tokenize() ，当 tokenize() 找到下一个 token 时再调用。这使得 tokenize 能以自然的方式编码，但程序调用 tokenize 会变得极其复杂，因为它需要记住每次回调前最后出现的是哪个 token(s)。</span><code style="margin-left:2px;font-size:inherit;line-height:inherit;color:rgb(248,35,117);background:rgb(248,248,248);"><span style="font-size:15px;">tabnanny.py</span></code><span style="font-size:15px;">中的 tokeneater 函数是处理得比较好的例子，它在全局变量中维护了一个状态机，用于记录已出现的 token 和预期会出现的 token 。这很难正确地工作，而且也挺难让人理解。不幸的是，它已经是最标准的解决方法了。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">有一个替代方案是一次性生成 Python 程序的全部解析，并存入超大列表中。这样 tokenize 客户端可以用自然的方式，即使用局部变量和局部控制流（例如循环和嵌套的 if 语句），来跟踪其状态。然而这并不实用：程序会变得臃肿，因此不能在实现整个解析所需的内存上放置先验限制；而有些 tokenize 客户端仅仅想要查看某个特定的东西是否曾出现（例如，future 声明，或者像 IDLE 做的那样，只是首个缩进的声明），因此解析整个程序就是严重地浪费时间。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">另一个替代方案是把 tokenize 变为一个迭代器【注释1】，每次调用它的 next() 方法时再传递下一个 token。这对调用者来说很便利，就像前一方案把结果存入大列表一样，同时没有内存与“想要早点退出怎么办”的缺点。然而，这个方案也把 tokenize 的负担转化成记住 next() 的调用状态，读者只要瞄一眼 tokenize.tokenize_loop() ，就会意识到这是一件多么可怕的苦差事。或者想象一下，用递归算法来生成普通树结构的节点：若把它投射成一个迭代器框架实现，就需要手动地移除递归状态并维护遍历的状态。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">第四种选择是在不同的线程中运行生产者和消费者。这允许两者以自然的方式维护其状态，所以都会很舒服。实际上，Python 源代码发行版中的 Demo/threads/Generator.py 就提供了一个可用的同步通信（synchronized-communication）类，来完成一般的任务。但是，这在没有线程的平台上无法运用，而且就算可用也会很慢（与不用线程取得的成就比）。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">最后一个选择是使用 Python 的变种 Stackless 【注释2-3】来实现，它支持轻量级的协程。它与前述的线程方案有相同的编程优势，效率还更高。然而，Stackless 在 Python 核心层存在争议，Jython 也可能不会实现相同的语义。这个 PEP 不是讨论这些问题的地方，但完全可以说生成器是 Stackless 相关功能的子集在当前 CPython 中的一种简单实现，而且可以说，其它 Python 实现起来也相对简单。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">以上分析完了已有的方案。其它一些高级语言也提供了不错的解决方案，特别是 Sather 的迭代器，它受到 CLU 的迭代器启发【注释4】；Icon 的生成器，一种新颖的语言，其中每个表达式都是生成器【注释5】。它们虽有差异，但基本的思路是一致的：提供一种函数，它可以返回中间结果（“下一个值”）给它的调用者，同时还保存了函数的局部状态，以便在停止的位置恢复（译注：resum，下文也译作激活）调用。一个非常简单的例子：</span></p>
   <pre style="color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:inherit;"><code style="margin-left:2px;line-height:18px;font-size:13px;word-spacing:0px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(171,178,191);background:rgb(40,44,52);"><span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">fib</span><span style="font-size:inherit;color:inherit;line-height:inherit;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b&nbsp;=&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">0</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">while</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">yield</span>&nbsp;b<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,&nbsp;b&nbsp;=&nbsp;b,&nbsp;a+b<br></code></pre>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">当 fib() 首次被调用时，它将 a 设为 0，将 b 设为 1，然后生成 b 给其调用者。调用者得到 1。当 fib 恢复时，从它的角度来看，yield 语句实际上跟 print 语句相同：fib 继续执行，且所有局部状态完好无损。然后，a 和 b 的值变为 1，并且 fib 再次循环到 yield，生成 1 给它的调用者。以此类推。 从 fib 的角度来看，它只是提供一系列结果，就像用了回调一样。但是从调用者的角度来看，fib 的调用就是一个可随时恢复的可迭代对象。跟线程一样，这允许两边以最自然的方式进行编码；但与线程方法不同，这可以在所有平台上高效完成。事实上，恢复生成器应该不比函数调用昂贵。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">同样的方法适用于许多生产者/消费者函数。例如，tokenize.py 可以生成下一个 token 而不是用它作为参数调用回调函数，而且 tokenize 客户端可以以自然的方式迭代 tokens：Python 生成器是一种迭代器，但是特别强大。</span></p>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">设计规格：yield</span></h2>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">引入了一种新的表达式：</span></p>
   <blockquote style="border-left-width:5px;border-left-color:rgb(239,112,96);letter-spacing:1px;word-spacing:-2px;line-height:inherit;font-size:.9em;color:rgb(0,0,0);background:rgb(239,235,233);">
    <p style="min-height:1em;font-size:inherit;color:inherit;line-height:1.75em;">yield_stmt：“yield”expression_list</p>
   </blockquote>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">yield 是一个新的关键字，因此需要一个&nbsp;</span><code style="margin-left:2px;font-size:inherit;line-height:inherit;color:rgb(248,35,117);background:rgb(248,248,248);"><span style="font-size:15px;">future</span></code><span style="font-size:15px;">&nbsp;声明【注释8】来进行引入：在早期版本中，若想使用生成器的模块，必须在接近头部处包含以下行（详见 PEP 236）：</span></p>
   <pre style="color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:inherit;"><code style="margin-left:2px;line-height:18px;font-size:13px;word-spacing:0px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(171,178,191);background:rgb(40,44,52);"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">from</span>&nbsp;__future__&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">import</span>&nbsp;generators<br></code></pre>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">没有引入 future 模块就使用 yield 关键字，将会告警。 在后续的版本中，yield 将是一个语言关键字，不再需要 future 语句。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">yield 语句只能在函数内部使用。包含 yield 语句的函数被称为生成器函数。从各方面来看，生成器函数都只是个普通函数，但在它的代码对象的 co_flags 中设置了新的“CO_GENERATOR”标志。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">当调用生成器函数时，实际参数还是绑定到函数的局部变量空间，但不会执行代码。得到的是一个 generator-iterator 对象；这符合迭代器协议【注释6】，因此可用于 for 循环。注意，在上下文无歧义的情况下，非限定名称 “generator” 既可以指生成器函数，又可以指生成器-迭代器（generator-iterator）。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">每次调用 generator-iterator 的 next() 方法时，才会执行 generator-function 体中的代码，直至遇到 yield 或 return 语句（见下文），或者直接迭代到尽头。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">如果执行到 yield 语句，则函数的状态会被冻结，并将 expression_list 的值返回给 next() 的调用者。“冻结”是指挂起所有本地状态，包括局部变量、指令指针和内部堆栈：保存足够信息，以便在下次调用 next() 时，函数可以继续执行，仿佛 yield 语句只是一次普通的外部调用。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">限制：yield 语句不能用于 try-finally 结构的 try 子句中。困难的是不能保证生成器会被再次激活（resum），因此无法保证 finally 语句块会被执行；这就太违背 finally 的用处了。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">限制：生成器在活跃状态时无法被再次激活：</span></p>
   <pre style="color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:inherit;"><code style="margin-left:2px;line-height:18px;font-size:13px;word-spacing:0px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(171,178,191);background:rgb(40,44,52);"><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">&gt;&gt;</span>&gt;&nbsp;<span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">g</span><span style="font-size:inherit;color:inherit;line-height:inherit;">()</span></span>:<br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;me.next()<br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">yield</span>&nbsp;i<br><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">&gt;&gt;</span>&gt;&nbsp;me&nbsp;=&nbsp;g()<br><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">&gt;&gt;</span>&gt;&nbsp;me.next()<br>Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):<br>&nbsp;...<br>&nbsp;File&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(152,195,121);">"&lt;string&gt;"</span>,&nbsp;line&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">2</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">in</span>&nbsp;g<br><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">ValueError:</span>&nbsp;generator&nbsp;already&nbsp;executing<br></code></pre>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">设计规格：return</span></h2>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">生成器函数可以包含以下形式的return语句：</span></p>
   <pre style="color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:inherit;"><code style="margin-left:2px;line-height:18px;font-size:13px;word-spacing:0px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(171,178,191);background:rgb(40,44,52);"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span><br></code></pre>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">注意，生成器主体中的 return 语句不允许使用 expression_list （然而当然，它们可以嵌套地使用在生成器里的非生成器函数中）。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">当执行到 return 语句时，程序会正常 return，继续执行恰当的 finally 子句（如果存在）。然后引发一个 StopIteration 异常，表明迭代器已经耗尽。如果程序没有显式 return 而执行到生成器的末尾，也会引发 StopIteration 异常。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">请注意，对于生成器函数和非生成器函数，return 意味着“我已经完成，并且没有任何有趣的东西可以返回”。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">注意，return 并不一定会引发 StopIteration ：关键在如何处理封闭的 try-except 结构。 如：</span></p>
   <pre style="color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:inherit;"><code style="margin-left:2px;line-height:18px;font-size:13px;word-spacing:0px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(171,178,191);background:rgb(40,44,52);"><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">&gt;&gt;</span>&gt;&nbsp;<span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">f1</span><span style="font-size:inherit;color:inherit;line-height:inherit;">()</span></span>:<br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">try:</span><br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span><br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">except:</span><br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">yield</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">&gt;&gt;</span>&gt;&nbsp;print&nbsp;list(f1())<br>[]<br></code></pre>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">因为，就像在任何函数中一样，return 只是退出，但是：</span></p>
   <pre style="color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:inherit;"><code style="margin-left:2px;line-height:18px;font-size:13px;word-spacing:0px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(171,178,191);background:rgb(40,44,52);">&gt;&gt;&gt;&nbsp;<span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">f2</span><span style="font-size:inherit;color:inherit;line-height:inherit;">()</span>:</span><br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">try</span>:<br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">raise</span>&nbsp;StopIteration<br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">except</span>:<br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">yield</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">42</span><br>&gt;&gt;&gt;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">print</span>&nbsp;list(f2())<br>[<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">42</span>]<br></code></pre>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">因为 StopIteration 被一个简单的 except 捕获，就像任意异常一样。</span></p>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">设计规格：生成器和异常传播</span></h2>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">如果一个未捕获的异常——包括但不限于 StopIteration——由生成器函数引发或传递，则异常会以通常的方式传递给调用者，若试图重新激活生成器函数的话，则会引发 StopIteration 。 换句话说，未捕获的异常终结了生成器的使用寿命。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">示例（不合语言习惯，仅作举例）：</span></p>
   <pre style="color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:inherit;"><code style="margin-left:2px;line-height:18px;font-size:13px;word-spacing:0px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(171,178,191);background:rgb(40,44,52);"><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">&gt;&gt;</span>&gt;&nbsp;<span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">f</span><span style="font-size:inherit;color:inherit;line-height:inherit;">()</span></span>:<br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span>/<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">0</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">&gt;&gt;</span>&gt;&nbsp;<span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">g</span><span style="font-size:inherit;color:inherit;line-height:inherit;">()</span></span>:<br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;f()&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;the&nbsp;zero&nbsp;division&nbsp;exception&nbsp;propagates</span><br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">yield</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">42</span>&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;and&nbsp;we'll&nbsp;never&nbsp;get&nbsp;here</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">&gt;&gt;</span>&gt;&nbsp;k&nbsp;=&nbsp;g()<br><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">&gt;&gt;</span>&gt;&nbsp;k.next()<br>Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):<br>&nbsp;&nbsp;File&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(152,195,121);">"&lt;stdin&gt;"</span>,&nbsp;line&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">in</span>&nbsp;?<br>&nbsp;&nbsp;File&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(152,195,121);">"&lt;stdin&gt;"</span>,&nbsp;line&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">2</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">in</span>&nbsp;g<br>&nbsp;&nbsp;File&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(152,195,121);">"&lt;stdin&gt;"</span>,&nbsp;line&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">2</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">in</span>&nbsp;f<br><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">ZeroDivisionError:</span>&nbsp;integer&nbsp;division&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">or</span>&nbsp;modulo&nbsp;by&nbsp;zero<br><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">&gt;&gt;</span>&gt;&nbsp;k.next()&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;and&nbsp;the&nbsp;generator&nbsp;cannot&nbsp;be&nbsp;resumed</span><br>Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):<br>&nbsp;&nbsp;File&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(152,195,121);">"&lt;stdin&gt;"</span>,&nbsp;line&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">in</span>&nbsp;?<br>StopIteration<br><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">&gt;&gt;</span>&gt;<br></code></pre>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">设计规格：Try/Exception/Finally</span></h2>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">前面提过，yield 语句不能用于 try-finally 结构的 try 子句中。这带来的结果是生成器要非常谨慎地分配关键的资源。但是在其它地方，yield 语句并无限制，例如 finally 子句、except 子句、或者 try-except 结构的 try 子句：</span></p>
   <pre style="color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:inherit;"><code style="margin-left:2px;line-height:18px;font-size:13px;word-spacing:0px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(171,178,191);background:rgb(40,44,52);">&gt;&gt;&gt;&nbsp;def&nbsp;f():<br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">try</span>:<br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">try</span>:<br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">2</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span>/<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">0</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span>&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;never&nbsp;get&nbsp;here</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;ZeroDivisionError:<br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">4</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">5</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise<br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:<br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">6</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">7</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;the&nbsp;"raise"&nbsp;above&nbsp;stops&nbsp;this</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:<br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">8</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">9</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">try</span>:<br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">12</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally:<br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">10</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">...</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">11</span><br>&gt;&gt;&gt;&nbsp;print&nbsp;list(f())<br>[<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">2</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">4</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">5</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">8</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">9</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">10</span>,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">11</span>]<br>&gt;&gt;&gt;<br></code></pre>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">示例</span></h2>
   <pre style="color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:inherit;"><code style="margin-left:2px;line-height:18px;font-size:13px;word-spacing:0px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(171,178,191);background:rgb(40,44,52);"><span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;二叉树类</span><br><span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">class</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(230,192,123);">Tree</span>:</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">__init__</span><span style="font-size:inherit;color:inherit;line-height:inherit;">(<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">self</span>,&nbsp;label,&nbsp;left=None,&nbsp;right=None)</span></span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">self</span>.label&nbsp;=&nbsp;label<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">self</span>.left&nbsp;=&nbsp;left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">self</span>.right&nbsp;=&nbsp;right<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">__repr__</span><span style="font-size:inherit;color:inherit;line-height:inherit;">(<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">self</span>,&nbsp;level=<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">0</span>,&nbsp;indent=<span style="font-size:inherit;line-height:inherit;color:rgb(152,195,121);">"&nbsp;&nbsp;&nbsp;&nbsp;"</span>)</span></span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;level*indent&nbsp;+&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(152,195,121);">`self.label`</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">if</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">self</span>.<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">left:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;s&nbsp;+&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(152,195,121);">"\n"</span>&nbsp;+&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">self</span>.left.__repr_<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">_</span>(level+<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span>,&nbsp;indent)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">if</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">self</span>.<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">right:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;s&nbsp;+&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(152,195,121);">"\n"</span>&nbsp;+&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">self</span>.right.__repr_<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">_</span>(level+<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span>,&nbsp;indent)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;s<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">__iter__</span><span style="font-size:inherit;color:inherit;line-height:inherit;">(<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">self</span>)</span></span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;inorder(<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">self</span>)<br><br><span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;从列表中创建&nbsp;Tree</span><br><span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">tree</span><span style="font-size:inherit;color:inherit;line-height:inherit;">(list)</span></span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;len(list)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">if</span>&nbsp;n&nbsp;==&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">0</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;[]<br>&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;n&nbsp;/&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">2</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;Tree(list[i],&nbsp;tree(list[<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">:i</span>]),&nbsp;tree(list[i+<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">1</span><span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">:</span>]))<br><br><span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;递归生成器，按顺序生成树标签</span><br><span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">inorder</span><span style="font-size:inherit;color:inherit;line-height:inherit;">(t)</span></span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">if</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">t:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">for</span>&nbsp;x&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">in</span>&nbsp;inorder(t.left):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">yield</span>&nbsp;x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">yield</span>&nbsp;t.label<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">for</span>&nbsp;x&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">in</span>&nbsp;inorder(t.right):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">yield</span>&nbsp;x<br><br><span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;展示：创建一棵树</span><br>t&nbsp;=&nbsp;tree(<span style="font-size:inherit;line-height:inherit;color:rgb(152,195,121);">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>)<br><span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;按顺序打印树的节点</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">for</span>&nbsp;x&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">in</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">t:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;x,<br>print<br><br><span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;非递归生成器</span><br><span style="font-size:inherit;color:inherit;line-height:inherit;"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">def</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">inorder</span><span style="font-size:inherit;color:inherit;line-height:inherit;">(node)</span></span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;stack&nbsp;=&nbsp;[]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">while</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">node:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">while</span>&nbsp;node.<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">left:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.append(node)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">yield</span>&nbsp;node.label<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">while</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">not</span>&nbsp;node.<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">right:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">try:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;stack.pop()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">IndexError:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">yield</span>&nbsp;node.label<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.right<br><br><span style="font-size:inherit;line-height:inherit;color:rgb(92,99,112);font-style:italic;">#&nbsp;练习非递归生成器</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">for</span>&nbsp;x&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">in</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">t:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;x,<br>print<br>Both&nbsp;output&nbsp;blocks&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(97,174,238);">display:</span><br><br>A&nbsp;B&nbsp;C&nbsp;D&nbsp;E&nbsp;F&nbsp;G&nbsp;H&nbsp;I&nbsp;J&nbsp;K&nbsp;L&nbsp;M&nbsp;N&nbsp;O&nbsp;P&nbsp;Q&nbsp;R&nbsp;S&nbsp;T&nbsp;U&nbsp;V&nbsp;W&nbsp;X&nbsp;Y&nbsp;Z<br></code></pre>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">问答</span></h2>
   <h3 style="font-weight:bold;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">为什么重用 def 而不用新的关键字？</span></h3>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">请参阅下面的 BDFL 声明部分。</span></p>
   <h3 style="font-weight:bold;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">为什么用新的关键字yield而非内置函数？</span></h3>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">Python 中通过关键字能更好地表达控制流，即 yield 是一个控制结构。而且为了 Jython 的高效实现，编译器需要在编译时就确定潜在的挂起点，新的关键字会使这一点变得简单。CPython 的实现也大量利用它来检测哪些函数是生成器函数（尽管一个新的关键字替代 def 就能解决 CPython 的问题，但人们问“为什么要新的关键字”问题时，并不想要新的关键字）。</span></p>
   <h3 style="font-weight:bold;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">为什么不是其它不带新关键字的特殊语法？</span></h3>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">例如，为何不用下面用法而用 yield 3：</span></p>
   <pre style="color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:inherit;"><code style="margin-left:2px;line-height:18px;font-size:13px;word-spacing:0px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(171,178,191);background:rgb(40,44,52);"><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span>&nbsp;and&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">continue</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;and&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">continue</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;generating&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">continue</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;&gt;&gt;&nbsp;,&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span><br>from&nbsp;generator&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;&gt;&gt;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span><br><span style="font-size:inherit;line-height:inherit;color:rgb(198,120,221);">return</span>&nbsp;&lt;&lt;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span><br>&gt;&gt;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span><br>&lt;&lt;&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span><br>*&nbsp;<span style="font-size:inherit;line-height:inherit;color:rgb(209,154,102);">3</span><br></code></pre>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;">我没有错过一个“眼色”吧？在数百条消息中，我算了每种替代方案有三条建议，然后总结出上面这些。不需要用新的关键字会很好，但使用 yield 会更好——我个人认为，在一堆无意义的关键字或运算符序列中，yield 更具表现力。尽管如此，如果这引起足够的兴趣，支持者应该发起一个提案，交给 Guido 裁断。</p>
   <h3 style="font-weight:bold;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="font-size:inherit;color:inherit;line-height:inherit;">为什么允许用return，而不强制用StopIteration？</span></h3>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;">“StopIteration”的机制是底层细节，就像 Python 2.1 中的“IndexError”的机制一样：实现时需要做一些预先定义好的东西，而 Python 为高级用户开放了这些机制。尽管不强制要求每个人都在这个层级工作。 “return”在任何一种函数中都意味着“我已经完成”，这很容易解读和使用。注意，<code style="margin-left:2px;font-size:inherit;line-height:inherit;color:rgb(248,35,117);background:rgb(248,248,248);">return</code>&nbsp;并不总是等同于 <span style="font-size:15px;">try-except 结构中的&nbsp;</span><code style="margin-left:2px;font-size:inherit;line-height:inherit;color:rgb(248,35,117);background:rgb(248,248,248);"><span style="font-size:15px;">raise StopIteration</span></code><span style="font-size:15px;">（参见“设计规格：Return”部分）。</span></p>
   <h3 style="font-weight:bold;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">那为什么不允许return一个表达式？</span></h3>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">也许有一天会允许。 在 Icon 中，</span><code style="margin-left:2px;font-size:inherit;line-height:inherit;color:rgb(248,35,117);background:rgb(248,248,248);"><span style="font-size:15px;">return expr</span></code><span style="font-size:15px;">&nbsp;意味着“我已经完成”和“但我还有最后一个有用的值可以返回，这就是它”。 在初始阶段，不强制使用</span><code style="margin-left:2px;font-size:inherit;line-height:inherit;color:rgb(248,35,117);background:rgb(248,248,248);"><span style="font-size:15px;">return expr</span></code><span style="font-size:15px;">的情况下，使用 yield 仅仅传递值，这很简单明了。</span></p>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">BDFL声明</span></h2>
   <h3 style="font-weight:bold;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">Issue</span></h3>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">引入另一个新的关键字（比如，gen 或 generator ）来代替 def ，或以其它方式改变语法，以区分生成器函数和非生成器函数。</span></p>
   <h3 style="font-weight:bold;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">Con</span></h3>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">实际上（你如何看待它们），生成器<em style="font-size:inherit;color:inherit;line-height:inherit;">是</em>函数，但它们具有可恢复性。使它们建立起来的机制是一个相对较小的技术问题，引入新的关键字无助于强调生成器是如何启动的机制（生成器生命中至关重要却很小的部分）。</span></p>
   <h3 style="font-weight:bold;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">Pro</span></h3>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">实际上（你如何看待它们），生成器函数实际上是工厂函数，它们就像施了魔法一样地生产生成器-迭代器。 在这方面，它们与非生成器函数完全不同，更像是构造函数而不是函数，因此重用 def 无疑是令人困惑的。藏在内部的 yield 语句不足以警示它们的语义是如此不同。</span></p>
   <h3 style="font-weight:bold;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">BDFL</span></h3>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">def 留了下来。任何一方都没有任何争论是完全令人信服的，所以我咨询了我的语言设计师的直觉。它告诉我 PEP 中提出的语法是完全正确的——不是太热，也不是太冷。但是，就像希腊神话中的 Delphi（译注：特尔斐，希腊古都） 的甲骨文一样，它并没有告诉我原因，所以我没有对反对此 PEP 语法的论点进行反驳。 我能想出的最好的（除了已经同意做出的反驳）是“FUD”（译注：缩写自 fear、uncertainty 和 doubt）。 如果这从第一天开始就是语言的一部分，我非常怀疑这早已让安德鲁·库奇林（Andrew Kuchling）的“Python Warts”页面成为可能。（译注：wart 是疣，一种难看的皮肤病。这是一个 wiki 页面，列举了对 Python 吹毛求疵的建议）。</span></p>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">参考实现</span></h2>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">当前的实现（译注：2001年），处于初步状态（没有文档，但经过充分测试，可靠），是Python 的 CVS 开发树【注释9】的一部分。 使用它需要您从源代码中构建 Python。</span></p>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">这是衍生自 Neil Schemenauer【注释7】的早期补丁。</span></p>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">脚注和参考文献</span></h2>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">[1] PEP-234, Iterators, Yee, Van Rossum</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">http://www.python.org/dev/peps/pep-0234/</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">[2] http://www.stackless.com/</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">[3] PEP-219, Stackless Python, McMillan</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">http://www.python.org/dev/peps/pep-0219/</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">[4] "Iteration Abstraction in Sather" Murer, Omohundro, Stoutamire and Szyperski&nbsp;</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">http://www.icsi.berkeley.edu/~sather/Publications/toplas.html</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">[5] http://www.cs.arizona.edu/icon/</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">[6] The&nbsp; concept&nbsp; of&nbsp; iterators&nbsp; is&nbsp; described&nbsp; in PEP 234.&nbsp;</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">[7] http://python.ca/nas/python/generator.diff</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">[8] PEP 236, Back to the&nbsp;<strong style="font-size:inherit;color:inherit;line-height:inherit;">future</strong>, Peters</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">http://www.python.org/dev/peps/pep-0236/</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:normal;"><span style="letter-spacing:normal;font-size:15px;">[9] To experiment with this implementation, check out Python from CVS according to the instructions at http://sf.net/cvs/?group_id=5470 ，Note that the std test Lib/test/test_generators.py contains many examples, including all those in this PEP.</span></p>
   <h2 style="font-weight:bold;font-size:20px;letter-spacing:1px;word-spacing:-2px;line-height:inherit;color:rgb(255,127,36);"><span style="color:inherit;line-height:inherit;font-size:15px;">版权信息</span></h2>
   <p style="margin-left:16px;min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="font-size:15px;">本文档已经放置在公共领域。源文档：</span></p>
   <p style="min-height:1em;color:inherit;font-size:inherit;letter-spacing:1px;word-spacing:-2px;line-height:1.75em;"><span style="letter-spacing:normal;font-size:15px;">https://github.com/python/peps/blob/master/pep-0255.txt</span></p>
   <p><br></p>
   <p><br></p>
   <p style="min-height:1em;"><span style="font-size:13px;">【本文作者】</span></p>
   <p style="min-height:1em;"><br></p>
   <p style="min-height:1em;"><span style="font-size:13px;"><span style="color:rgb(93,93,93);font-family:'-apple-system-font', 'system-ui', 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;font-size:13px;letter-spacing:.544px;">豌豆花下猫：某985高校毕业生， 兼具极客思维与人文情怀 。个人公众号Python猫， 专注python技术、数据科学和深度学习。</span></span></p>
   <p><span style="font-size:13px;"><br></span></p>
   <p><br></p>
   <p style="min-height:1em;"><strong>推荐阅读</strong></p>
   <p style="min-height:1em;">（点击标题可跳转阅读）</p>
   <p><a href="http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;mid=2652565507&amp;idx=1&amp;sn=c64a558b7e84d4ec6c53752fc5e6527d&amp;chksm=8464d849b313515fb02e0af960022b5eb66fbfdf6ea59d62ebec7a63f4c9bc659688b108d48a&amp;scene=21#wechat_redirect" rel="nofollow"><span style="font-size:12px;">完全理解 Python 迭代对象、迭代器、生成器</span></a></p>
   <p><span style="font-size:12px;"><a href="http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;mid=2652566598&amp;idx=2&amp;sn=06c43487fea9153443e681ff0c7b7220&amp;chksm=8464dc0cb313551a04ba380e02e1a34bd2ea12cf67419e609c7a667c36bc1421e14620df009f&amp;scene=21#wechat_redirect" rel="nofollow">Python 生成器原理详解</a></span></p>
   <p><a href="http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;mid=2652567129&amp;idx=2&amp;sn=e8bad8aef2cab1e90731e3ffbd8fa23b&amp;chksm=8464de13b3135705d083806b86eea4d21d5463f7075c8207ceaa039fdac3574b217057034a98&amp;scene=21#wechat_redirect" rel="nofollow"><span style="font-size:12px;">Python 迭代器和生成器</span></a></p>
   <p><br></p>
   <p style="min-height:1em;"><br></p>
   <p style="min-height:1em;text-align:center;"><span style="font-size:14px;color:rgb(255,169,0);">觉得本文对你有帮助？请分享给更多人</span></p>
   <p style="min-height:1em;text-align:center;"><span style="font-size:15px;color:rgb(255,169,0);">关注「Python开发者」加星标，提升Python技能</span></p>
   <p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TqaKV3Wx5icAqicxpjNXaM1RqHFEMaVvrjOzibrxJpicHO98FArbqID3f2MXsCq5aZtFN2BCx2UgIHUwQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="text-align:right;"><span style="color:rgb(255,41,65);font-size:14px;">喜欢就点一下「好看」呗~</span></p> 
  </div> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
