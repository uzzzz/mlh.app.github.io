<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>（电子支付系统）手机银行对账失败缺陷排查 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="（电子支付系统）手机银行对账失败缺陷排查" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="系统之间的关联 手机银行--电子支付--ys 问题 手机银行无法对账 原因： 电子支付没有提供完整的对账文件，原因是电子支付数据库中当天有可疑的交易。 排查： ys提供给电子支付的对账文件是否完整 电子支付提供给手机银行的对账文件是否完整 排查二 场景：提供电子支付和ys购卡成功的交易信息生成对账文件给手机银行，如果购卡交易，ys成功，电子支付可疑或失败，对账信息中不会提供这笔交易给手机银行。 电子支付交易是否可疑（通过查询数据库可以发现这笔交易是否可疑） 排查三 场景：电子支付的可疑交易，会通过定时任务更新状态 定时任务是否正常运行 定时任务是否报错 排查四 场景：手机银行会针对可疑的交易定时发送查询接口去电子支付查询状态。 通过查看日志发现定时任务报错，手机银行实时查询却返回成功。手机银行调用电子支付查询接口，电子支付不是查询的本地库，而是发送查询接口去ys查询状态，返回的是成功，接口也是正常。电子支付的APP服务器有135和136两台，定时任务只在135执行，而实时交易在135，136两台。但是通过日志发现购卡查询交易都在136上，且都是成功的。 定时任务的代码和实时交易的代码是否一致 135APP服务器连接web服务器131是否正常，端口是否正常 136APP服务器连接web服务器131是否正常，端口是否正常 排查五 测试环境是否可以重现生成缺陷 结论： 目前未排查出任何问题，但实时交易正常，定时任务异常 解决方案 修改实时查询交易，如果电子支付是可疑的，请求ys查询接口，修改本地状态，返回手机银行成功。 添加定时任务的日志，在可能出现异常的地方加上日志打印，等待下一个版本修改。 修改生成对账文件代码，无论电子支付成功与否，都把ys的对账文件发送给手机银行，电子支付不校验。 实际采用方案 修改实时查询交易，添加修改状态；添加定时任务日志打印，定位错误代码（对应解决方案的1和2） 后续 通讯类代码如下： package base; import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.io.UnsupportedEncodingException; import java.net.HttpURLConnection; import java.net.InetSocketAddress; import java.net.MalformedURLException; import java.net.ProtocolException; import java.net.Proxy; import java.net.URISyntaxException; import java.net.URL; import java.net.URLConnection; import java.net.URLEncoder; import java.security.KeyManagementException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.Map; import java.util.Map.Entry; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSession; import javax.net.ssl.SSLSocketFactory; import javax.net.ssl.TrustManager; import com.crbank.crbankPay.util.TLSSocketConnectionFactory; import com.ecc.liana.base.LianaDBAccess; import com.ecc.liana.base.LianaStandard; import com.ecc.liana.base.Trace; import com.ecc.liana.exception.TranFailException; import org.apache.commons.io.IOUtils; public class HttpClient { /** * 目标地址 */ private URL url; /** * 通信连接超时时间 */ private int connectionTimeout; /** * 通信读超时时间 */ private int readTimeOut; /** * 通信结果 */ private String result; /** * 获取通信结果 * @return */ public String getResult() { return result; } /** * 设置通信结果 * @param result */ public void setResult(String result) { this.result = result; } /** * 构造函数 * @param url 目标地址 * @param connectionTimeout HTTP连接超时时间 * @param readTimeOut HTTP读写超时时间 */ public HttpClient(String url, int connectionTimeout, int readTimeOut) { try { if (url.startsWith(&quot;https&quot;)||url.startsWith(&quot;HTTPS&quot;)) { this.url = new URL(null,url,new sun.net.www.protocol.https.Handler()); }else{ this.url = new URL(url); } this.connectionTimeout = connectionTimeout; this.readTimeOut = readTimeOut; } catch (MalformedURLException e) { e.printStackTrace(); } } /** * 发送HTTP信息到服务端 * @param data * @param encoding * @return * @throws Exception */ public int sendHttp(Map&lt;String, String&gt; data, String encoding) throws Exception { try { HttpURLConnection httpURLConnection = createHttpConnection(encoding); if(null == httpURLConnection){ throw new Exception(&quot;创建联接失败&quot;); } String p = this.getRequestParamString(data, encoding); Trace.logInfo(&quot;upcard&quot;, &quot;发送请求：&quot; + getFullUrl(httpURLConnection.getURL(), p)); this.requestServer(httpURLConnection, p,encoding); this.result = this.response(httpURLConnection, encoding); return httpURLConnection.getResponseCode(); } catch (Exception e) { throw e; } } /** * 发送HTTPS信息到服务端 * @param data * @param encoding * @return * @throws Exception */ public int sendHttps(Map&lt;String, String&gt; data, String encoding) throws Exception { try { HttpsURLConnection httpsURLConnection = createHttpsConnection(encoding); if(null == httpsURLConnection){ throw new Exception(&quot;创建联接失败&quot;); } String p = this.getRequestParamString(data, encoding); Trace.logInfo(&quot;upcard&quot;, &quot;发送请求：&quot; + getFullUrl(httpsURLConnection.getURL(), p)); this.requestServer(httpsURLConnection, p,encoding); this.result = this.response(httpsURLConnection, encoding); return httpsURLConnection.getResponseCode(); } catch (Exception e) { throw e; } } private String getFullUrl(URL url, String params) { return url.getProtocol() + &quot;://&quot; + url.getHost() + &quot;:&quot; + url.getPort() + url.getPath() + &quot;?&quot; + params; } /** * HTTP Post发送消息 * * @param connection * @param message * @throws java.io.IOException */ private void requestServer(final URLConnection connection, String message, String encoder) throws Exception { PrintStream out = null; try { connection.connect(); out = new PrintStream(connection.getOutputStream(), false, encoder); out.print(message); out.flush(); } catch (Exception e) { throw e; } finally { if (null != out) { out.close(); } } } /** * 显示Response消息 * * @param connection * @param encoding * @return * @throws java.net.URISyntaxException * @throws java.io.IOException */ private String response(final HttpURLConnection connection, String encoding) throws URISyntaxException, IOException, Exception { InputStream in = null; StringBuilder sb = new StringBuilder(1024); try { if (200 == connection.getResponseCode()) { in = connection.getInputStream(); sb.append(IOUtils.toString(in,encoding)); } else { in = connection.getErrorStream(); sb.append(IOUtils.toString(in,encoding)); } return sb.toString(); } catch (Exception e) { throw e; } finally { if (null != in) { in.close(); } if (null != connection) { connection.disconnect(); } } } /** * 创建连接 * * @return * @throws java.net.ProtocolException */ private String proxy_addr = LianaStandard.getBankSettingsValue(&quot;proxy_addr&quot;); private int proxy_port = Integer.parseInt(LianaStandard.getBankSettingsValue(&quot;proxy_port&quot;)); private HttpsURLConnection createHttpsConnection(String encoding) throws ProtocolException, NoSuchAlgorithmException, NoSuchProviderException, KeyManagementException { HttpsURLConnection httpsURLConnection = null; String key = &quot;&quot;; try { Proxy proxy = new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxy_addr,proxy_port)); httpsURLConnection = (HttpsURLConnection) url.openConnection(proxy); key = getSysparValue(&quot;UPCARD_SSL_PROTOCOL&quot;); } catch (Exception e) { e.printStackTrace(); return null; } httpsURLConnection.setConnectTimeout(this.connectionTimeout);// 连接超时时间 httpsURLConnection.setReadTimeout(this.readTimeOut);// 读取结果超时时间 httpsURLConnection.setDoInput(true); // 可读 httpsURLConnection.setDoOutput(true); // 可写 httpsURLConnection.setUseCaches(false);// 取消缓存 httpsURLConnection.setRequestProperty(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded;charset=&quot; + encoding); httpsURLConnection.setRequestMethod(&quot;POST&quot;); if(&quot;https&quot;.equalsIgnoreCase(url.getProtocol())){ Trace.logInfo(&quot;wjgwk理论发送协议为HTTPS, &quot;, &quot;实际发送请求的协议为：&quot; + url.getProtocol()); if(&quot;TLS&quot;.equalsIgnoreCase(key)){ HttpsURLConnection husn = (HttpsURLConnection)httpsURLConnection; husn.setSSLSocketFactory(new TLSSocketConnectionFactory()); husn.setDoInput(true); husn.setDoOutput(true); return husn;} else { HttpsURLConnection husn = (HttpsURLConnection)httpsURLConnection; TrustManager[] tm = {new BaseHttpSSLSocketFactory.MyX509TrustManager()}; SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;,&quot;SunJSSE&quot;); sslContext.init(null, tm, new java.security.SecureRandom()); SSLSocketFactory ssf = sslContext.getSocketFactory(); // husn.setSSLSocketFactory(new BaseHttpSSLSocketFactory()); husn.setSSLSocketFactory(ssf); husn.setHostnameVerifier(new TrustAnyHostnameVerifier());//解决由于服务器证书问题导致HTTPS无法访问的情况 return husn; } } return httpsURLConnection; } private HttpURLConnection createHttpConnection(String encoding) throws ProtocolException, NoSuchAlgorithmException, NoSuchProviderException, KeyManagementException { HttpURLConnection httpURLConnection = null; try { Proxy proxy = new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxy_addr,proxy_port)); httpURLConnection = (HttpURLConnection) url.openConnection(proxy); } catch (Exception e) { e.printStackTrace(); return null; } httpURLConnection.setConnectTimeout(this.connectionTimeout);// 连接超时时间 httpURLConnection.setReadTimeout(this.readTimeOut);// 读取结果超时时间 httpURLConnection.setDoInput(true); // 可读 httpURLConnection.setDoOutput(true); // 可写 httpURLConnection.setUseCaches(false);// 取消缓存 httpURLConnection.setRequestProperty(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded;charset=&quot; + encoding); httpURLConnection.setRequestMethod(&quot;POST&quot;); return httpURLConnection; } /** * 将Map存储的对象，转换为key=value&amp;key=value的字符 * * @param requestParam * @param coder * @return */ private String getRequestParamString(Map&lt;String, String&gt; requestParam, String coder) { if (null == coder || &quot;&quot;.equals(coder)) { coder = &quot;UTF-8&quot;; } StringBuffer sf = new StringBuffer(&quot;&quot;); String reqstr = &quot;&quot;; if (null != requestParam &amp;&amp; 0 != requestParam.size()) { for (Entry&lt;String, String&gt; en : requestParam.entrySet()) { try { sf.append(en.getKey() + &quot;=&quot; + (null == en.getValue() || &quot;&quot;.equals(en.getValue()) ? &quot;&quot; : URLEncoder .encode(en.getValue(), coder)) + &quot;&amp;&quot;); } catch (UnsupportedEncodingException e) { e.printStackTrace(); return &quot;&quot;; } } reqstr = sf.substring(0, sf.length() - 1); } return reqstr; } /** * 解决由于服务器证书问题导致HTTPS无法访问的情况 PS:HTTPS hostname wrong: should be &lt;localhost&gt; */ private static class TrustAnyHostnameVerifier implements HostnameVerifier { public boolean verify(String hostname, SSLSession session) { // 直接返回true return true; } } public String getSysparValue(String parameter) throws TranFailException{ Connection connection = null; PreparedStatement stm = null; String str = &quot;&quot;; ResultSet rs = null; try{ String sql = &quot;&quot;; connection = LianaDBAccess.getConnection(); sql = &quot;select spr_value from pub_syspar where spr_code=?&quot;; stm = connection.prepareStatement(sql); stm.setString(1, parameter); rs = stm.executeQuery(); rs.next(); str=rs.getString(&quot;spr_value&quot;); }catch(Exception e) { Trace.logError(&quot;wjgwk&quot;, &quot;查询wjgwk功能开关失败&quot;, e); } finally{ rs = null; LianaDBAccess.cleanResources(stm); LianaDBAccess.releaseConnection(connection); } return str; } } 报错的代码为：httpsURLConnection = (HttpsURLConnection) url.openConnection(proxy); 在创建HttpsURLConnection对象的时候报错的，报错原因如下代码： private String proxy_addr = LianaStandard.getBankSettingsValue(&quot;proxy_addr&quot;); private int proxy_port = Integer.parseInt(LianaStandard.getBankSettingsValue(&quot;proxy_port&quot;)); 没有获取到代理服务器的" />
<meta property="og:description" content="系统之间的关联 手机银行--电子支付--ys 问题 手机银行无法对账 原因： 电子支付没有提供完整的对账文件，原因是电子支付数据库中当天有可疑的交易。 排查： ys提供给电子支付的对账文件是否完整 电子支付提供给手机银行的对账文件是否完整 排查二 场景：提供电子支付和ys购卡成功的交易信息生成对账文件给手机银行，如果购卡交易，ys成功，电子支付可疑或失败，对账信息中不会提供这笔交易给手机银行。 电子支付交易是否可疑（通过查询数据库可以发现这笔交易是否可疑） 排查三 场景：电子支付的可疑交易，会通过定时任务更新状态 定时任务是否正常运行 定时任务是否报错 排查四 场景：手机银行会针对可疑的交易定时发送查询接口去电子支付查询状态。 通过查看日志发现定时任务报错，手机银行实时查询却返回成功。手机银行调用电子支付查询接口，电子支付不是查询的本地库，而是发送查询接口去ys查询状态，返回的是成功，接口也是正常。电子支付的APP服务器有135和136两台，定时任务只在135执行，而实时交易在135，136两台。但是通过日志发现购卡查询交易都在136上，且都是成功的。 定时任务的代码和实时交易的代码是否一致 135APP服务器连接web服务器131是否正常，端口是否正常 136APP服务器连接web服务器131是否正常，端口是否正常 排查五 测试环境是否可以重现生成缺陷 结论： 目前未排查出任何问题，但实时交易正常，定时任务异常 解决方案 修改实时查询交易，如果电子支付是可疑的，请求ys查询接口，修改本地状态，返回手机银行成功。 添加定时任务的日志，在可能出现异常的地方加上日志打印，等待下一个版本修改。 修改生成对账文件代码，无论电子支付成功与否，都把ys的对账文件发送给手机银行，电子支付不校验。 实际采用方案 修改实时查询交易，添加修改状态；添加定时任务日志打印，定位错误代码（对应解决方案的1和2） 后续 通讯类代码如下： package base; import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.io.UnsupportedEncodingException; import java.net.HttpURLConnection; import java.net.InetSocketAddress; import java.net.MalformedURLException; import java.net.ProtocolException; import java.net.Proxy; import java.net.URISyntaxException; import java.net.URL; import java.net.URLConnection; import java.net.URLEncoder; import java.security.KeyManagementException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.Map; import java.util.Map.Entry; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSession; import javax.net.ssl.SSLSocketFactory; import javax.net.ssl.TrustManager; import com.crbank.crbankPay.util.TLSSocketConnectionFactory; import com.ecc.liana.base.LianaDBAccess; import com.ecc.liana.base.LianaStandard; import com.ecc.liana.base.Trace; import com.ecc.liana.exception.TranFailException; import org.apache.commons.io.IOUtils; public class HttpClient { /** * 目标地址 */ private URL url; /** * 通信连接超时时间 */ private int connectionTimeout; /** * 通信读超时时间 */ private int readTimeOut; /** * 通信结果 */ private String result; /** * 获取通信结果 * @return */ public String getResult() { return result; } /** * 设置通信结果 * @param result */ public void setResult(String result) { this.result = result; } /** * 构造函数 * @param url 目标地址 * @param connectionTimeout HTTP连接超时时间 * @param readTimeOut HTTP读写超时时间 */ public HttpClient(String url, int connectionTimeout, int readTimeOut) { try { if (url.startsWith(&quot;https&quot;)||url.startsWith(&quot;HTTPS&quot;)) { this.url = new URL(null,url,new sun.net.www.protocol.https.Handler()); }else{ this.url = new URL(url); } this.connectionTimeout = connectionTimeout; this.readTimeOut = readTimeOut; } catch (MalformedURLException e) { e.printStackTrace(); } } /** * 发送HTTP信息到服务端 * @param data * @param encoding * @return * @throws Exception */ public int sendHttp(Map&lt;String, String&gt; data, String encoding) throws Exception { try { HttpURLConnection httpURLConnection = createHttpConnection(encoding); if(null == httpURLConnection){ throw new Exception(&quot;创建联接失败&quot;); } String p = this.getRequestParamString(data, encoding); Trace.logInfo(&quot;upcard&quot;, &quot;发送请求：&quot; + getFullUrl(httpURLConnection.getURL(), p)); this.requestServer(httpURLConnection, p,encoding); this.result = this.response(httpURLConnection, encoding); return httpURLConnection.getResponseCode(); } catch (Exception e) { throw e; } } /** * 发送HTTPS信息到服务端 * @param data * @param encoding * @return * @throws Exception */ public int sendHttps(Map&lt;String, String&gt; data, String encoding) throws Exception { try { HttpsURLConnection httpsURLConnection = createHttpsConnection(encoding); if(null == httpsURLConnection){ throw new Exception(&quot;创建联接失败&quot;); } String p = this.getRequestParamString(data, encoding); Trace.logInfo(&quot;upcard&quot;, &quot;发送请求：&quot; + getFullUrl(httpsURLConnection.getURL(), p)); this.requestServer(httpsURLConnection, p,encoding); this.result = this.response(httpsURLConnection, encoding); return httpsURLConnection.getResponseCode(); } catch (Exception e) { throw e; } } private String getFullUrl(URL url, String params) { return url.getProtocol() + &quot;://&quot; + url.getHost() + &quot;:&quot; + url.getPort() + url.getPath() + &quot;?&quot; + params; } /** * HTTP Post发送消息 * * @param connection * @param message * @throws java.io.IOException */ private void requestServer(final URLConnection connection, String message, String encoder) throws Exception { PrintStream out = null; try { connection.connect(); out = new PrintStream(connection.getOutputStream(), false, encoder); out.print(message); out.flush(); } catch (Exception e) { throw e; } finally { if (null != out) { out.close(); } } } /** * 显示Response消息 * * @param connection * @param encoding * @return * @throws java.net.URISyntaxException * @throws java.io.IOException */ private String response(final HttpURLConnection connection, String encoding) throws URISyntaxException, IOException, Exception { InputStream in = null; StringBuilder sb = new StringBuilder(1024); try { if (200 == connection.getResponseCode()) { in = connection.getInputStream(); sb.append(IOUtils.toString(in,encoding)); } else { in = connection.getErrorStream(); sb.append(IOUtils.toString(in,encoding)); } return sb.toString(); } catch (Exception e) { throw e; } finally { if (null != in) { in.close(); } if (null != connection) { connection.disconnect(); } } } /** * 创建连接 * * @return * @throws java.net.ProtocolException */ private String proxy_addr = LianaStandard.getBankSettingsValue(&quot;proxy_addr&quot;); private int proxy_port = Integer.parseInt(LianaStandard.getBankSettingsValue(&quot;proxy_port&quot;)); private HttpsURLConnection createHttpsConnection(String encoding) throws ProtocolException, NoSuchAlgorithmException, NoSuchProviderException, KeyManagementException { HttpsURLConnection httpsURLConnection = null; String key = &quot;&quot;; try { Proxy proxy = new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxy_addr,proxy_port)); httpsURLConnection = (HttpsURLConnection) url.openConnection(proxy); key = getSysparValue(&quot;UPCARD_SSL_PROTOCOL&quot;); } catch (Exception e) { e.printStackTrace(); return null; } httpsURLConnection.setConnectTimeout(this.connectionTimeout);// 连接超时时间 httpsURLConnection.setReadTimeout(this.readTimeOut);// 读取结果超时时间 httpsURLConnection.setDoInput(true); // 可读 httpsURLConnection.setDoOutput(true); // 可写 httpsURLConnection.setUseCaches(false);// 取消缓存 httpsURLConnection.setRequestProperty(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded;charset=&quot; + encoding); httpsURLConnection.setRequestMethod(&quot;POST&quot;); if(&quot;https&quot;.equalsIgnoreCase(url.getProtocol())){ Trace.logInfo(&quot;wjgwk理论发送协议为HTTPS, &quot;, &quot;实际发送请求的协议为：&quot; + url.getProtocol()); if(&quot;TLS&quot;.equalsIgnoreCase(key)){ HttpsURLConnection husn = (HttpsURLConnection)httpsURLConnection; husn.setSSLSocketFactory(new TLSSocketConnectionFactory()); husn.setDoInput(true); husn.setDoOutput(true); return husn;} else { HttpsURLConnection husn = (HttpsURLConnection)httpsURLConnection; TrustManager[] tm = {new BaseHttpSSLSocketFactory.MyX509TrustManager()}; SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;,&quot;SunJSSE&quot;); sslContext.init(null, tm, new java.security.SecureRandom()); SSLSocketFactory ssf = sslContext.getSocketFactory(); // husn.setSSLSocketFactory(new BaseHttpSSLSocketFactory()); husn.setSSLSocketFactory(ssf); husn.setHostnameVerifier(new TrustAnyHostnameVerifier());//解决由于服务器证书问题导致HTTPS无法访问的情况 return husn; } } return httpsURLConnection; } private HttpURLConnection createHttpConnection(String encoding) throws ProtocolException, NoSuchAlgorithmException, NoSuchProviderException, KeyManagementException { HttpURLConnection httpURLConnection = null; try { Proxy proxy = new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxy_addr,proxy_port)); httpURLConnection = (HttpURLConnection) url.openConnection(proxy); } catch (Exception e) { e.printStackTrace(); return null; } httpURLConnection.setConnectTimeout(this.connectionTimeout);// 连接超时时间 httpURLConnection.setReadTimeout(this.readTimeOut);// 读取结果超时时间 httpURLConnection.setDoInput(true); // 可读 httpURLConnection.setDoOutput(true); // 可写 httpURLConnection.setUseCaches(false);// 取消缓存 httpURLConnection.setRequestProperty(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded;charset=&quot; + encoding); httpURLConnection.setRequestMethod(&quot;POST&quot;); return httpURLConnection; } /** * 将Map存储的对象，转换为key=value&amp;key=value的字符 * * @param requestParam * @param coder * @return */ private String getRequestParamString(Map&lt;String, String&gt; requestParam, String coder) { if (null == coder || &quot;&quot;.equals(coder)) { coder = &quot;UTF-8&quot;; } StringBuffer sf = new StringBuffer(&quot;&quot;); String reqstr = &quot;&quot;; if (null != requestParam &amp;&amp; 0 != requestParam.size()) { for (Entry&lt;String, String&gt; en : requestParam.entrySet()) { try { sf.append(en.getKey() + &quot;=&quot; + (null == en.getValue() || &quot;&quot;.equals(en.getValue()) ? &quot;&quot; : URLEncoder .encode(en.getValue(), coder)) + &quot;&amp;&quot;); } catch (UnsupportedEncodingException e) { e.printStackTrace(); return &quot;&quot;; } } reqstr = sf.substring(0, sf.length() - 1); } return reqstr; } /** * 解决由于服务器证书问题导致HTTPS无法访问的情况 PS:HTTPS hostname wrong: should be &lt;localhost&gt; */ private static class TrustAnyHostnameVerifier implements HostnameVerifier { public boolean verify(String hostname, SSLSession session) { // 直接返回true return true; } } public String getSysparValue(String parameter) throws TranFailException{ Connection connection = null; PreparedStatement stm = null; String str = &quot;&quot;; ResultSet rs = null; try{ String sql = &quot;&quot;; connection = LianaDBAccess.getConnection(); sql = &quot;select spr_value from pub_syspar where spr_code=?&quot;; stm = connection.prepareStatement(sql); stm.setString(1, parameter); rs = stm.executeQuery(); rs.next(); str=rs.getString(&quot;spr_value&quot;); }catch(Exception e) { Trace.logError(&quot;wjgwk&quot;, &quot;查询wjgwk功能开关失败&quot;, e); } finally{ rs = null; LianaDBAccess.cleanResources(stm); LianaDBAccess.releaseConnection(connection); } return str; } } 报错的代码为：httpsURLConnection = (HttpsURLConnection) url.openConnection(proxy); 在创建HttpsURLConnection对象的时候报错的，报错原因如下代码： private String proxy_addr = LianaStandard.getBankSettingsValue(&quot;proxy_addr&quot;); private int proxy_port = Integer.parseInt(LianaStandard.getBankSettingsValue(&quot;proxy_port&quot;)); 没有获取到代理服务器的" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-19T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"系统之间的关联 手机银行--电子支付--ys 问题 手机银行无法对账 原因： 电子支付没有提供完整的对账文件，原因是电子支付数据库中当天有可疑的交易。 排查： ys提供给电子支付的对账文件是否完整 电子支付提供给手机银行的对账文件是否完整 排查二 场景：提供电子支付和ys购卡成功的交易信息生成对账文件给手机银行，如果购卡交易，ys成功，电子支付可疑或失败，对账信息中不会提供这笔交易给手机银行。 电子支付交易是否可疑（通过查询数据库可以发现这笔交易是否可疑） 排查三 场景：电子支付的可疑交易，会通过定时任务更新状态 定时任务是否正常运行 定时任务是否报错 排查四 场景：手机银行会针对可疑的交易定时发送查询接口去电子支付查询状态。 通过查看日志发现定时任务报错，手机银行实时查询却返回成功。手机银行调用电子支付查询接口，电子支付不是查询的本地库，而是发送查询接口去ys查询状态，返回的是成功，接口也是正常。电子支付的APP服务器有135和136两台，定时任务只在135执行，而实时交易在135，136两台。但是通过日志发现购卡查询交易都在136上，且都是成功的。 定时任务的代码和实时交易的代码是否一致 135APP服务器连接web服务器131是否正常，端口是否正常 136APP服务器连接web服务器131是否正常，端口是否正常 排查五 测试环境是否可以重现生成缺陷 结论： 目前未排查出任何问题，但实时交易正常，定时任务异常 解决方案 修改实时查询交易，如果电子支付是可疑的，请求ys查询接口，修改本地状态，返回手机银行成功。 添加定时任务的日志，在可能出现异常的地方加上日志打印，等待下一个版本修改。 修改生成对账文件代码，无论电子支付成功与否，都把ys的对账文件发送给手机银行，电子支付不校验。 实际采用方案 修改实时查询交易，添加修改状态；添加定时任务日志打印，定位错误代码（对应解决方案的1和2） 后续 通讯类代码如下： package base; import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.io.UnsupportedEncodingException; import java.net.HttpURLConnection; import java.net.InetSocketAddress; import java.net.MalformedURLException; import java.net.ProtocolException; import java.net.Proxy; import java.net.URISyntaxException; import java.net.URL; import java.net.URLConnection; import java.net.URLEncoder; import java.security.KeyManagementException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.Map; import java.util.Map.Entry; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSession; import javax.net.ssl.SSLSocketFactory; import javax.net.ssl.TrustManager; import com.crbank.crbankPay.util.TLSSocketConnectionFactory; import com.ecc.liana.base.LianaDBAccess; import com.ecc.liana.base.LianaStandard; import com.ecc.liana.base.Trace; import com.ecc.liana.exception.TranFailException; import org.apache.commons.io.IOUtils; public class HttpClient { /** * 目标地址 */ private URL url; /** * 通信连接超时时间 */ private int connectionTimeout; /** * 通信读超时时间 */ private int readTimeOut; /** * 通信结果 */ private String result; /** * 获取通信结果 * @return */ public String getResult() { return result; } /** * 设置通信结果 * @param result */ public void setResult(String result) { this.result = result; } /** * 构造函数 * @param url 目标地址 * @param connectionTimeout HTTP连接超时时间 * @param readTimeOut HTTP读写超时时间 */ public HttpClient(String url, int connectionTimeout, int readTimeOut) { try { if (url.startsWith(&quot;https&quot;)||url.startsWith(&quot;HTTPS&quot;)) { this.url = new URL(null,url,new sun.net.www.protocol.https.Handler()); }else{ this.url = new URL(url); } this.connectionTimeout = connectionTimeout; this.readTimeOut = readTimeOut; } catch (MalformedURLException e) { e.printStackTrace(); } } /** * 发送HTTP信息到服务端 * @param data * @param encoding * @return * @throws Exception */ public int sendHttp(Map&lt;String, String&gt; data, String encoding) throws Exception { try { HttpURLConnection httpURLConnection = createHttpConnection(encoding); if(null == httpURLConnection){ throw new Exception(&quot;创建联接失败&quot;); } String p = this.getRequestParamString(data, encoding); Trace.logInfo(&quot;upcard&quot;, &quot;发送请求：&quot; + getFullUrl(httpURLConnection.getURL(), p)); this.requestServer(httpURLConnection, p,encoding); this.result = this.response(httpURLConnection, encoding); return httpURLConnection.getResponseCode(); } catch (Exception e) { throw e; } } /** * 发送HTTPS信息到服务端 * @param data * @param encoding * @return * @throws Exception */ public int sendHttps(Map&lt;String, String&gt; data, String encoding) throws Exception { try { HttpsURLConnection httpsURLConnection = createHttpsConnection(encoding); if(null == httpsURLConnection){ throw new Exception(&quot;创建联接失败&quot;); } String p = this.getRequestParamString(data, encoding); Trace.logInfo(&quot;upcard&quot;, &quot;发送请求：&quot; + getFullUrl(httpsURLConnection.getURL(), p)); this.requestServer(httpsURLConnection, p,encoding); this.result = this.response(httpsURLConnection, encoding); return httpsURLConnection.getResponseCode(); } catch (Exception e) { throw e; } } private String getFullUrl(URL url, String params) { return url.getProtocol() + &quot;://&quot; + url.getHost() + &quot;:&quot; + url.getPort() + url.getPath() + &quot;?&quot; + params; } /** * HTTP Post发送消息 * * @param connection * @param message * @throws java.io.IOException */ private void requestServer(final URLConnection connection, String message, String encoder) throws Exception { PrintStream out = null; try { connection.connect(); out = new PrintStream(connection.getOutputStream(), false, encoder); out.print(message); out.flush(); } catch (Exception e) { throw e; } finally { if (null != out) { out.close(); } } } /** * 显示Response消息 * * @param connection * @param encoding * @return * @throws java.net.URISyntaxException * @throws java.io.IOException */ private String response(final HttpURLConnection connection, String encoding) throws URISyntaxException, IOException, Exception { InputStream in = null; StringBuilder sb = new StringBuilder(1024); try { if (200 == connection.getResponseCode()) { in = connection.getInputStream(); sb.append(IOUtils.toString(in,encoding)); } else { in = connection.getErrorStream(); sb.append(IOUtils.toString(in,encoding)); } return sb.toString(); } catch (Exception e) { throw e; } finally { if (null != in) { in.close(); } if (null != connection) { connection.disconnect(); } } } /** * 创建连接 * * @return * @throws java.net.ProtocolException */ private String proxy_addr = LianaStandard.getBankSettingsValue(&quot;proxy_addr&quot;); private int proxy_port = Integer.parseInt(LianaStandard.getBankSettingsValue(&quot;proxy_port&quot;)); private HttpsURLConnection createHttpsConnection(String encoding) throws ProtocolException, NoSuchAlgorithmException, NoSuchProviderException, KeyManagementException { HttpsURLConnection httpsURLConnection = null; String key = &quot;&quot;; try { Proxy proxy = new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxy_addr,proxy_port)); httpsURLConnection = (HttpsURLConnection) url.openConnection(proxy); key = getSysparValue(&quot;UPCARD_SSL_PROTOCOL&quot;); } catch (Exception e) { e.printStackTrace(); return null; } httpsURLConnection.setConnectTimeout(this.connectionTimeout);// 连接超时时间 httpsURLConnection.setReadTimeout(this.readTimeOut);// 读取结果超时时间 httpsURLConnection.setDoInput(true); // 可读 httpsURLConnection.setDoOutput(true); // 可写 httpsURLConnection.setUseCaches(false);// 取消缓存 httpsURLConnection.setRequestProperty(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded;charset=&quot; + encoding); httpsURLConnection.setRequestMethod(&quot;POST&quot;); if(&quot;https&quot;.equalsIgnoreCase(url.getProtocol())){ Trace.logInfo(&quot;wjgwk理论发送协议为HTTPS, &quot;, &quot;实际发送请求的协议为：&quot; + url.getProtocol()); if(&quot;TLS&quot;.equalsIgnoreCase(key)){ HttpsURLConnection husn = (HttpsURLConnection)httpsURLConnection; husn.setSSLSocketFactory(new TLSSocketConnectionFactory()); husn.setDoInput(true); husn.setDoOutput(true); return husn;} else { HttpsURLConnection husn = (HttpsURLConnection)httpsURLConnection; TrustManager[] tm = {new BaseHttpSSLSocketFactory.MyX509TrustManager()}; SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;,&quot;SunJSSE&quot;); sslContext.init(null, tm, new java.security.SecureRandom()); SSLSocketFactory ssf = sslContext.getSocketFactory(); // husn.setSSLSocketFactory(new BaseHttpSSLSocketFactory()); husn.setSSLSocketFactory(ssf); husn.setHostnameVerifier(new TrustAnyHostnameVerifier());//解决由于服务器证书问题导致HTTPS无法访问的情况 return husn; } } return httpsURLConnection; } private HttpURLConnection createHttpConnection(String encoding) throws ProtocolException, NoSuchAlgorithmException, NoSuchProviderException, KeyManagementException { HttpURLConnection httpURLConnection = null; try { Proxy proxy = new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxy_addr,proxy_port)); httpURLConnection = (HttpURLConnection) url.openConnection(proxy); } catch (Exception e) { e.printStackTrace(); return null; } httpURLConnection.setConnectTimeout(this.connectionTimeout);// 连接超时时间 httpURLConnection.setReadTimeout(this.readTimeOut);// 读取结果超时时间 httpURLConnection.setDoInput(true); // 可读 httpURLConnection.setDoOutput(true); // 可写 httpURLConnection.setUseCaches(false);// 取消缓存 httpURLConnection.setRequestProperty(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded;charset=&quot; + encoding); httpURLConnection.setRequestMethod(&quot;POST&quot;); return httpURLConnection; } /** * 将Map存储的对象，转换为key=value&amp;key=value的字符 * * @param requestParam * @param coder * @return */ private String getRequestParamString(Map&lt;String, String&gt; requestParam, String coder) { if (null == coder || &quot;&quot;.equals(coder)) { coder = &quot;UTF-8&quot;; } StringBuffer sf = new StringBuffer(&quot;&quot;); String reqstr = &quot;&quot;; if (null != requestParam &amp;&amp; 0 != requestParam.size()) { for (Entry&lt;String, String&gt; en : requestParam.entrySet()) { try { sf.append(en.getKey() + &quot;=&quot; + (null == en.getValue() || &quot;&quot;.equals(en.getValue()) ? &quot;&quot; : URLEncoder .encode(en.getValue(), coder)) + &quot;&amp;&quot;); } catch (UnsupportedEncodingException e) { e.printStackTrace(); return &quot;&quot;; } } reqstr = sf.substring(0, sf.length() - 1); } return reqstr; } /** * 解决由于服务器证书问题导致HTTPS无法访问的情况 PS:HTTPS hostname wrong: should be &lt;localhost&gt; */ private static class TrustAnyHostnameVerifier implements HostnameVerifier { public boolean verify(String hostname, SSLSession session) { // 直接返回true return true; } } public String getSysparValue(String parameter) throws TranFailException{ Connection connection = null; PreparedStatement stm = null; String str = &quot;&quot;; ResultSet rs = null; try{ String sql = &quot;&quot;; connection = LianaDBAccess.getConnection(); sql = &quot;select spr_value from pub_syspar where spr_code=?&quot;; stm = connection.prepareStatement(sql); stm.setString(1, parameter); rs = stm.executeQuery(); rs.next(); str=rs.getString(&quot;spr_value&quot;); }catch(Exception e) { Trace.logError(&quot;wjgwk&quot;, &quot;查询wjgwk功能开关失败&quot;, e); } finally{ rs = null; LianaDBAccess.cleanResources(stm); LianaDBAccess.releaseConnection(connection); } return str; } } 报错的代码为：httpsURLConnection = (HttpsURLConnection) url.openConnection(proxy); 在创建HttpsURLConnection对象的时候报错的，报错原因如下代码： private String proxy_addr = LianaStandard.getBankSettingsValue(&quot;proxy_addr&quot;); private int proxy_port = Integer.parseInt(LianaStandard.getBankSettingsValue(&quot;proxy_port&quot;)); 没有获取到代理服务器的","@type":"BlogPosting","url":"/2019/03/19/728591.html","headline":"（电子支付系统）手机银行对账失败缺陷排查","dateModified":"2019-03-19T00:00:00+08:00","datePublished":"2019-03-19T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/03/19/728591.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>（电子支付系统）手机银行对账失败缺陷排查</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h2><a id="_0"></a>系统之间的关联</h2> 
  <pre><code>手机银行--电子支付--ys
</code></pre> 
  <h2><a id="_4"></a>问题</h2> 
  <pre><code>手机银行无法对账
</code></pre> 
  <h2><a id="_6"></a>原因：</h2> 
  <pre><code>电子支付没有提供完整的对账文件，原因是电子支付数据库中当天有可疑的交易。
</code></pre> 
  <h2><a id="_8"></a>排查：</h2> 
  <ul> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> ys提供给电子支付的对账文件是否完整</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 电子支付提供给手机银行的对账文件是否完整</li> 
  </ul> 
  <h2><a id="_12"></a>排查二</h2> 
  <p>场景：提供电子支付和ys购卡成功的交易信息生成对账文件给手机银行，如果购卡交易，ys成功，电子支付可疑或失败，对账信息中不会提供这笔交易给手机银行。</p> 
  <ul> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> 电子支付交易是否可疑（通过查询数据库可以发现这笔交易是否可疑）</li> 
  </ul> 
  <h2><a id="_16"></a>排查三</h2> 
  <p>场景：电子支付的可疑交易，会通过定时任务更新状态</p> 
  <ul> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> 定时任务是否正常运行</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> 定时任务是否报错</li> 
  </ul> 
  <h2><a id="_21"></a>排查四</h2> 
  <p>场景：手机银行会针对可疑的交易定时发送查询接口去电子支付查询状态。<br> 通过查看日志发现定时任务报错，手机银行实时查询却返回成功。手机银行调用电子支付查询接口，电子支付不是查询的本地库，而是发送查询接口去ys查询状态，返回的是成功，接口也是正常。电子支付的APP服务器有135和136两台，定时任务只在135执行，而实时交易在135，136两台。但是通过日志发现购卡查询交易都在136上，且都是成功的。</p> 
  <ul> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> 定时任务的代码和实时交易的代码是否一致</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> 135APP服务器连接web服务器131是否正常，端口是否正常</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> 136APP服务器连接web服务器131是否正常，端口是否正常</li> 
  </ul> 
  <h2><a id="_28"></a>排查五</h2> 
  <ul> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 测试环境是否可以重现生成缺陷</li> 
  </ul> 
  <h2><a id="_32"></a>结论：</h2> 
  <p>目前未排查出任何问题，但实时交易正常，定时任务异常</p> 
  <h2><a id="_35"></a>解决方案</h2> 
  <ol> 
   <li>修改实时查询交易，如果电子支付是可疑的，请求ys查询接口，修改本地状态，返回手机银行成功。</li> 
   <li>添加定时任务的日志，在可能出现异常的地方加上日志打印，等待下一个版本修改。</li> 
   <li>修改生成对账文件代码，无论电子支付成功与否，都把ys的对账文件发送给手机银行，电子支付不校验。</li> 
  </ol> 
  <h2><a id="_41"></a>实际采用方案</h2> 
  <p>修改实时查询交易，添加修改状态；添加定时任务日志打印，定位错误代码（对应解决方案的1和2）</p> 
  <h2><a id="_45"></a>后续</h2> 
  <p>通讯类代码如下：</p> 
  <pre><code>package base;

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.InetSocketAddress;
import java.net.MalformedURLException;
import java.net.ProtocolException;
import java.net.Proxy;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.Map;
import java.util.Map.Entry;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;

import com.crbank.crbankPay.util.TLSSocketConnectionFactory;
import com.ecc.liana.base.LianaDBAccess;
import com.ecc.liana.base.LianaStandard;
import com.ecc.liana.base.Trace;
import com.ecc.liana.exception.TranFailException;

import org.apache.commons.io.IOUtils;

public class HttpClient {
	/**
	 * 目标地址
	 */
	private URL url;

	/**
	 * 通信连接超时时间
	 */
	private int connectionTimeout;

	/**
	 * 通信读超时时间
	 */
	private int readTimeOut;

	/**
	 * 通信结果
	 */
	private String result;

	/**
	 * 获取通信结果
	 * @return
	 */
	public String getResult() {
		return result;
	}

	/**
	 * 设置通信结果
	 * @param result
	 */
	public void setResult(String result) {
		this.result = result;
	}

	/**
	 * 构造函数
	 * @param url 目标地址
	 * @param connectionTimeout HTTP连接超时时间
	 * @param readTimeOut HTTP读写超时时间
	 */
	public HttpClient(String url, int connectionTimeout, int readTimeOut) {
		try {
			if (url.startsWith("https")||url.startsWith("HTTPS")) {
				this.url = new URL(null,url,new sun.net.www.protocol.https.Handler());
			}else{
				this.url = new URL(url);
			}
			this.connectionTimeout = connectionTimeout;
			this.readTimeOut = readTimeOut;
		} catch (MalformedURLException e) {
			e.printStackTrace();
		}
	}

	/**
	 * 发送HTTP信息到服务端
	 * @param data
	 * @param encoding
	 * @return
	 * @throws Exception
	 */
	public int sendHttp(Map&lt;String, String&gt; data, String encoding) throws Exception {
		try {
			HttpURLConnection httpURLConnection = createHttpConnection(encoding);
			if(null == httpURLConnection){
				throw new Exception("创建联接失败");
			}
			String p = this.getRequestParamString(data, encoding);
			Trace.logInfo("upcard", "发送请求：" + getFullUrl(httpURLConnection.getURL(), p));
			this.requestServer(httpURLConnection, p,encoding);
			this.result = this.response(httpURLConnection, encoding);
			return httpURLConnection.getResponseCode();
		} catch (Exception e) {
			throw e;
		}
	}
	
	/**
	 * 发送HTTPS信息到服务端
	 * @param data
	 * @param encoding
	 * @return
	 * @throws Exception
	 */
	public int sendHttps(Map&lt;String, String&gt; data, String encoding) throws Exception {
		try {
			HttpsURLConnection httpsURLConnection = createHttpsConnection(encoding);
			if(null == httpsURLConnection){
				throw new Exception("创建联接失败");
			}
			String p = this.getRequestParamString(data, encoding);
			Trace.logInfo("upcard", "发送请求：" + getFullUrl(httpsURLConnection.getURL(), p));
			this.requestServer(httpsURLConnection, p,encoding);
			this.result = this.response(httpsURLConnection, encoding);
			return httpsURLConnection.getResponseCode();
		} catch (Exception e) {
			throw e;
		}
	}

	private String getFullUrl(URL url, String params) {
		return url.getProtocol() + "://" + url.getHost() + ":" + url.getPort() + url.getPath() + "?" + params;
	}

	/**
	 * HTTP Post发送消息
	 *
	 * @param connection
	 * @param message
	 * @throws java.io.IOException
	 */
	private void requestServer(final URLConnection connection, String message, String encoder)
			throws Exception {
		PrintStream out = null;
		try {
			connection.connect();
			out = new PrintStream(connection.getOutputStream(), false, encoder);
			out.print(message);
			out.flush();
		} catch (Exception e) {
			throw e;
		} finally {
			if (null != out) {
				out.close();
			}
		}
	}

	/**
	 * 显示Response消息
	 *
	 * @param connection
	 * @param encoding
	 * @return
	 * @throws java.net.URISyntaxException
	 * @throws java.io.IOException
	 */
	private String response(final HttpURLConnection connection, String encoding)
			throws URISyntaxException, IOException, Exception {
		InputStream in = null;
		StringBuilder sb = new StringBuilder(1024);
		try {
			if (200 == connection.getResponseCode()) {
				in = connection.getInputStream();
				sb.append(IOUtils.toString(in,encoding));
			} else {
				in = connection.getErrorStream();
				sb.append(IOUtils.toString(in,encoding));
			}
			return sb.toString();
		} catch (Exception e) {
			throw e;
		} finally {
			
			if (null != in) {
				in.close();
			}
			if (null != connection) {
				connection.disconnect();
			}
		}
	}

	/**
	 * 创建连接
	 *
	 * @return
	 * @throws java.net.ProtocolException
	 */
	private String proxy_addr = LianaStandard.getBankSettingsValue("proxy_addr");
	private int proxy_port = Integer.parseInt(LianaStandard.getBankSettingsValue("proxy_port"));
	private HttpsURLConnection createHttpsConnection(String encoding) throws ProtocolException, NoSuchAlgorithmException, NoSuchProviderException, KeyManagementException {
		HttpsURLConnection httpsURLConnection = null;
		String key = "";
		try {
			Proxy proxy = new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxy_addr,proxy_port));
			httpsURLConnection = (HttpsURLConnection) url.openConnection(proxy);
			key = getSysparValue("UPCARD_SSL_PROTOCOL");
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
		httpsURLConnection.setConnectTimeout(this.connectionTimeout);// 连接超时时间
		httpsURLConnection.setReadTimeout(this.readTimeOut);// 读取结果超时时间
		httpsURLConnection.setDoInput(true); // 可读
		httpsURLConnection.setDoOutput(true); // 可写
		httpsURLConnection.setUseCaches(false);// 取消缓存
		httpsURLConnection.setRequestProperty("Content-type",
				"application/x-www-form-urlencoded;charset=" + encoding);
		httpsURLConnection.setRequestMethod("POST");
		if("https".equalsIgnoreCase(url.getProtocol())){
			Trace.logInfo("wjgwk理论发送协议为HTTPS, ", "实际发送请求的协议为：" + url.getProtocol());
			if("TLS".equalsIgnoreCase(key)){
				HttpsURLConnection husn = (HttpsURLConnection)httpsURLConnection;
				husn.setSSLSocketFactory(new TLSSocketConnectionFactory());
				husn.setDoInput(true);
				husn.setDoOutput(true);	
				return husn;}
			else {
				HttpsURLConnection husn = (HttpsURLConnection)httpsURLConnection;
				TrustManager[] tm = {new BaseHttpSSLSocketFactory.MyX509TrustManager()};
				SSLContext sslContext = SSLContext.getInstance("SSL","SunJSSE");
				sslContext.init(null, tm, new java.security.SecureRandom());
				SSLSocketFactory ssf = sslContext.getSocketFactory();
//				husn.setSSLSocketFactory(new BaseHttpSSLSocketFactory());
				husn.setSSLSocketFactory(ssf);
				husn.setHostnameVerifier(new TrustAnyHostnameVerifier());//解决由于服务器证书问题导致HTTPS无法访问的情况
				return husn;
			}
		}
		return httpsURLConnection;
	}
	
	private HttpURLConnection createHttpConnection(String encoding) throws ProtocolException, NoSuchAlgorithmException, NoSuchProviderException, KeyManagementException {
		HttpURLConnection httpURLConnection = null;
		try {
			Proxy proxy = new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxy_addr,proxy_port));
			httpURLConnection = (HttpURLConnection) url.openConnection(proxy);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
		httpURLConnection.setConnectTimeout(this.connectionTimeout);// 连接超时时间
		httpURLConnection.setReadTimeout(this.readTimeOut);// 读取结果超时时间
		httpURLConnection.setDoInput(true); // 可读
		httpURLConnection.setDoOutput(true); // 可写
		httpURLConnection.setUseCaches(false);// 取消缓存
		httpURLConnection.setRequestProperty("Content-type",
				"application/x-www-form-urlencoded;charset=" + encoding);
		httpURLConnection.setRequestMethod("POST");
		return httpURLConnection;
	}
	
	/**
	 * 将Map存储的对象，转换为key=value&amp;key=value的字符
	 *
	 * @param requestParam
	 * @param coder
	 * @return
	 */
	private String getRequestParamString(Map&lt;String, String&gt; requestParam, String coder) {
		if (null == coder || "".equals(coder)) {
			coder = "UTF-8";
		}
		StringBuffer sf = new StringBuffer("");
		String reqstr = "";
		if (null != requestParam &amp;&amp; 0 != requestParam.size()) {
			for (Entry&lt;String, String&gt; en : requestParam.entrySet()) {
				try {
					sf.append(en.getKey()
							+ "="
							+ (null == en.getValue() || "".equals(en.getValue()) ? "" : URLEncoder
									.encode(en.getValue(), coder)) + "&amp;");
				} catch (UnsupportedEncodingException e) {
					e.printStackTrace();
					return "";
				}
			}
			reqstr = sf.substring(0, sf.length() - 1);
		}
		return reqstr;
	}
	
	/**
	 * 解决由于服务器证书问题导致HTTPS无法访问的情况 PS:HTTPS hostname wrong: should be &lt;localhost&gt;
	 */
	private static class TrustAnyHostnameVerifier implements HostnameVerifier {
		public boolean verify(String hostname, SSLSession session) {
			// 直接返回true
			return true;
		}
	}
	
	public String getSysparValue(String parameter) throws TranFailException{
		Connection connection = null;
		PreparedStatement stm = null;
		String str = "";
		ResultSet rs = null;
		try{
	        String sql = "";
            connection = LianaDBAccess.getConnection();
            sql = "select spr_value from pub_syspar where spr_code=?";
            stm = connection.prepareStatement(sql);
            stm.setString(1, parameter);
            rs = stm.executeQuery();
            rs.next();
            str=rs.getString("spr_value");
        }catch(Exception e) {
            Trace.logError("wjgwk", "查询wjgwk功能开关失败", e);
        }
        finally{
            rs = null;
            LianaDBAccess.cleanResources(stm);
            LianaDBAccess.releaseConnection(connection);
        }
		return str;
	}

}

</code></pre> 
  <p>报错的代码为：httpsURLConnection = (HttpsURLConnection) url.openConnection(proxy);<br> 在创建HttpsURLConnection对象的时候报错的，报错原因如下代码：</p> 
  <pre><code>private String proxy_addr = LianaStandard.getBankSettingsValue("proxy_addr");
private int proxy_port = Integer.parseInt(LianaStandard.getBankSettingsValue("proxy_port"));
	
</code></pre> 
  <p>没有获取到代理服务器的</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
