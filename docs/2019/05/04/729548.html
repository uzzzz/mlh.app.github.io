<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>用Python做量化交易策略 画图并导出csv | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="用Python做量化交易策略 画图并导出csv" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="查看B站视频 目标 从上交所抓取近2000天的上证指数 整理成为一个矩阵，方便加工 量化分析数据并生成一个交易策略 回归测试，计算出策略对应的收益 画出价格与资产曲线 详细结果导出到csv文件 先看一下最终结果，赚了不少钱，哈哈 从上交所抓取近2000天的上证指数 分析 我们先在上交所 http://www.sse.com.cn/market/price/trends/ 的页面上查看 通过打开控制台，刷新页面后，注意到了真实的数据地址， 如下所示 http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881 这里面重要数据在kline里面，简单列一些如下(去掉了外层的jQuery，只保留json数据) { begin: 6525, code: &quot;000001&quot;, end: 6824, kline: [ [20170823, 3283.796, 3299.457, 3274.44, 3287.704, 179832208], [20170824, 3287.959, 3297.988, 3266.358, 3271.511, 163468937], ... ] } 每一项对应的意义分别是 20170823 第一项表示交易日期 3283.796 第二项表示开盘价 3299.457 第三项表示收盘价 3274.440 第四项表示最高价 3287.704 第五项表示最低价 179832208 最后是成交量 爬虫代码 # 引入相关的包 import json # 处理json格式的数据 import requests # 发起网络请求 def run(): &#39;&#39;&#39; 主程序, 用来调度各个重要流程 &#39;&#39;&#39; kline = load_sse() print(kline) def load_sse(): &#39;&#39;&#39; 获取上交所的上证指数K线, 最近2000个交易日数据 &#39;&#39;&#39; response = requests.get( &#39;http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881&#39;, headers={&#39;Referer&#39;: &#39;http://www.sse.com.cn/market/price/trends/&#39;} ) # 针对结果进行格式处理 json_str = response.text[42:-1] data = json.loads(json_str) return data[&#39;kline&#39;] if __name__ == &#39;__main__&#39;: run() 有好几点需要注意 这里只是贴的代码片段，只是方便大家理解，如果要执行，需要使用最后的完整程序 这里面的 def 是用来定义函数的，因为我们的程序比较复杂，所以按函数分成不同功能，方便阅读与维护 上面这些函数只是定义，不执行，在最后两行，才是真正执行的，先理解到这一层 每个函数里面的第一行，可以通过三个单引号来说明函数的作用，也是一种注释 网络请求的知识，前几节已经讲的比较多了，如果有问题可以翻看一下前面的内容 整理成为一个矩阵，方便加工 import pandas as pd # 优秀的分析数据工具 def init_df(kline): &#39;&#39;&#39; 根据K线数据，创建含有日期与收盘价的矩阵 &#39;&#39;&#39; df = pd.DataFrame({}) df[&#39;date&#39;] = [x[0] for x in kline] df[&#39;close&#39;] = [x[2] for x in kline] return df 我们引入了pandas库，他非常强大，用于处理数据 我们先看&nbsp;[x[0] for x in kline]&nbsp;的作用 这是快速提取数据某些元素的方式， kline里面有很多条数据，我们把每条数据的第一项，也就是交易日期提取出来，成为列表 第三项是收盘价，也是我们这次分析最重要的数据 这样创建的data_frame简称df就是一个矩阵，可以理解成如下内容 date close 0 20170101 777 1 20170102 888 通过df，我们可以很方便操作里面的数据 量化分析数据并生成一个交易策略 def strategy(df): &#39;&#39;&#39; 根据价格计算平均值，然后把策略记录下来 &#39;&#39;&#39; # 连续15天数据，计算平均值，作为当天的平均价格指标 window_size = 15 df[&#39;avg&#39;] = df[&#39;close&#39;].rolling(window_size).apply(lambda x: sum(x) / len(x), raw=True) def avg_buy(x): &#39;&#39;&#39; 做多策略 &#39;&#39;&#39; # 这里应该是追涨杀跌的策略，我在视频里说的类似低建高平策略，视频说的是错的 # 写代码的时候改过几次，后来没改注释，导致视频说错了 # 不过具体策略不影响我们程序的学习，大家注意到就好了 min_percent = 0.995 max_percent = 1.005 # 追涨，当我们的价格超过了均线一定程度时 if (x[1] / x[0]) &lt; min_percent: return &#39;open buy&#39; # 杀跌，当我们的价格低于均线一定程度时 if (x[1] / x[0]) &gt; max_percent: return &#39;close buy&#39; # 其他情况不操作 return &#39;wait&#39; df[&#39;action&#39;] = df[[&#39;close&#39;, &#39;avg&#39;]].apply(avg_buy, axis=1) return df rolling那一行的整体意思是计算最近15天的平均收盘价，我们拆分来看 lambda x: sum(x) / len(x)是一个简写的函数，这里的x是指一系列数字，这个函数用于计算平均值， sum是求和，len是求总数 df[&#39;close&#39;].rolling(window_size)&nbsp;是把收盘价按连续15个的方式，依次进行处理，类似很多人排队从一个大窗口走过， 这个窗口同时可以看到15个人，每走一个人我们就拍一下照片，得到了一个相册 apply(求平均函数, raw=True)&nbsp;的意思是把每张照片交给求平均函数，每次产生一个平均数，最终产生一组结果 这样就得到了每天对应的15日平均收盘价，保存到&nbsp;df[&#39;avg&#39;]&nbsp;方便后面使用 avg_buy(x)也是一个函数，根据传入的数据进行处理，而df[[&#39;close&#39;, &#39;avg&#39;]].apply(avg_buy, axis=1)正是把每天的收盘价与平均价传入了函数中， 这里的axis=1的原理非常复杂，我们只要知道，写上这个就能按照一天一天的交易日处理就行。 如果你对axis详细原理很感兴趣，可以单独找我，涉及到高级维度方面的数学知识，我已经弄明白了，愿意讨论分析 在avg_buy里面，x[0]表示当天收盘价，&nbsp;x[1]表示当天平均价 策略 我们把他们进行比较，如果收盘价超过均线一定比例，我们就买股票，追涨 如果收盘价跌过均线一定比例，就卖掉股票，杀跌 请注意视频中的说明是错误的，文字版这里的解释才是正确的 真实的交易细节相关 理论上是不可能收盘时买股票的，所以我们这里的收盘价可以认为是接近收盘的5分钟内的价格，这时候买入跟收盘价比较接近。我们所有统计也基于这样的收盘价，并不影响策略与收益 我在代码注释里用的术语是&nbsp;开多仓 开空仓 平多仓 平空仓&nbsp;这样更接近通用的表达，因为A股虽然不能做空，但其他金融产品是可以的，策略也是类似 风险提示 股市有风险 投资需谨慎 这个策略其实是非常简单的，只是用来演示，请不要根据这个进行投资，无法保证任何收益，切记 回归测试，计算出策略对应的收益 def backtest(df): &#39;&#39;&#39; 回归测试 &#39;&#39;&#39; global shares, cash amount = 1000000 shares = 0 cash = amount def run_strategy(row): &#39;&#39;&#39; 把每天的数据执行策略 &#39;&#39;&#39; global shares, cash action = row[&#39;action&#39;] close = row[&#39;close&#39;] # 资产 = 现金 + 股票价值 liquidate = cash + shares * close message = &#39;nothing&#39; # 策略要求开仓做多，而且当前空仓时，做多 if action == &#39;open buy&#39; and shares == 0: shares = int(cash / close) cash -= shares * close message = &#39;open buy &#39; + str(shares) # 策略要求平仓，而且当前有仓时，平掉 if action == &#39;close buy&#39; and shares &gt; 0: message = &#39;close buy &#39; + str(shares) cash += shares * close shares = 0 return [message, shares, cash, liquidate] rows = df[[&#39;close&#39;, &#39;action&#39;]].apply(run_strategy, axis=1) df[&#39;message&#39;], df[&#39;shares&#39;], df[&#39;cash&#39;], df[&#39;liquidate&#39;] = zip(*rows) return df 这里的作用，就是执行策略，计算持股，资产，现金等数据 流程介绍(不含复杂语法) 先定义了share：持股数量&nbsp;cash：当前现金&nbsp;amount：初始资金100万 run_strategy接收一天的数据， 根据收盘价与持股数量及现金，计算最新的资产，因为买入或者卖出都不影响当天的资产了，所以可以先计算好 策略要求做多而且没有持股的时候，就用现金买入股票，这里为了方便，相当于上证指数也是一个股票，而且我们可以不按整手买入 平仓就是卖掉股票，所以持股减少而现金增加 最终把几条信息整理返回 外层使用&nbsp;apply后得到了多行数据 然后记录到不同地方，形成了message：交易信息&nbsp;及其他几项数据 复杂点解释，可以不用深究 因为这里是在函数内，backtest 与 run_strategy 都需要使用global标识才能修改shares cash, 以后我们详细讲闭包与作用域就能了解更多 因为我们的df是一列一列的，所以通过zip(*rows)进行一次转置，如果你学过线性代数的话，应该比较容易想象到，就是行与列的转换 axis=1也是按行处理的意思，跟上一个函数类似 画出价格与资产曲线 import numpy as np # 处理数字的工具 import matplotlib.pyplot as plt # 强大的画图工具 def draw(df): &#39;&#39;&#39; 画图 &#39;&#39;&#39; # 创建画板 fig = plt.figure(figsize=(10, 5)) # 准备横坐标 count = df.count()[&#39;close&#39;] index = np.arange(count) # 设置横坐标的刻度与显示标签 limit = 200 plt.xticks(index[::limit], df[&#39;date&#39;][::limit]) # 收盘价与资产的两套坐标系 ax_close = plt.gca() ax_liquidate = ax_close.twinx() # 画收盘价曲线 ax_close.set(xlabel=&#39;Date&#39;, ylabel=&#39;close&#39;) l_close, = ax_close.plot(index, df[&#39;close&#39;], &#39;black&#39;, label=&#39;close&#39;) # 画资产曲线 ax_liquidate.set(ylabel = &#39;liquidate&#39;) l_liquidate, = ax_liquidate.plot(index, df[&#39;liquidate&#39;], &#39;blue&#39;, label=&#39;liquidate&#39;) # 给两条线都提供一个图例说明 plt.legend(handles=[l_close, l_liquidate]) plt.show() 其实不用画图，我们的量化交易也做完了，画出图可以让我们更好地分析 本课不详细介绍画图流程了，希望大家把重点放在数据处理上，后面我们会详细讲画图 注意， 我在视频教程中用的是旧版，最新的我已经加入了均线与买入点，卖出点，请注意 详细结果导出到csv文件 df.to_csv(&#39;./result.csv&#39;, index = False) pandas用来处理数据很方便，导出到csv也就是这一行代码 可以在你的python文件同目录下找到csv 量化交易补充 股市有风险 投资需谨慎 虽然这个示例程序的演示效果赚了不少钱，但一定不要用于真正的投资，这一点再次强调 另外，我们做量化交易的时候，其实需要经常调整参数，好的策略也要配合好的参数，本例中的15天均值，0.995 1.005等策略用到的比例，都是很重要的参数，需要不断调试才能确定 至此，我们的最简单版本量化交易程序就实现了 还有很多功能可以加进来， 也算是策略的优化 当然，具体策略取决于你对证券的理解，我列一些思路 支持做空 把现金分成多份来投资，不要全仓操作 一天内的短线策略 多个股票组合 将交易量加入策略考虑因素 配合消息面的文本分析 如果你有好的建议，我们可以讨论更多策略 完整代码 # lesson5.py # 最简单的量化交易及可视化图 # 引入相关的包 # 如果本地环境没有，需要先安装 # pip install pandas # pip install numpy # pip install matplotlib import json # 处理json格式的数据 import requests # 发起网络请求 import pandas as pd # 优秀的分析数据工具 import numpy as np # 处理数字的工具 import matplotlib.pyplot as plt # 强大的画图工具 def run(): &#39;&#39;&#39; 主程序, 用来调度各个重要流程 &#39;&#39;&#39; kline = load_sse() df = init_df(kline) df = strategy(df) df = backtest(df) draw(df) df.to_csv(&#39;./result.csv&#39;, index = False) def load_sse(): &#39;&#39;&#39; 获取上交所的上证指数K线, 最近2000个交易日数据 &#39;&#39;&#39; response = requests.get( &#39;http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881&#39;, headers={&#39;Referer&#39;: &#39;http://www.sse.com.cn/market/price/trends/&#39;} ) # 针对结果进行格式处理 json_str = response.text[42:-1] data = json.loads(json_str) return data[&#39;kline&#39;] def init_df(kline): &#39;&#39;&#39; 根据K线数据，创建含有日期与收盘价的矩阵 &#39;&#39;&#39; df = pd.DataFrame({}) df[&#39;date&#39;] = [x[0] for x in kline] df[&#39;close&#39;] = [x[2] for x in kline] return df def strategy(df): &#39;&#39;&#39; 根据价格计算平均值，然后把策略记录下来 &#39;&#39;&#39; # 连续15天数据，计算平均值，作为当天的平均价格指标 window_size = 15 df[&#39;avg&#39;] = df[&#39;close&#39;].rolling(window_size).apply(lambda x: sum(x) / len(x), raw=True) def avg_buy(x): &#39;&#39;&#39; 做多策略 &#39;&#39;&#39; # 这里应该是追涨杀跌的策略，我在视频里说的类似低建高平策略，视频说的是错的 # 写代码的时候改过几次，后来没改注释，导致视频说错了 # 不过具体策略不影响我们程序的学习，大家注意到就好了 min_percent = 0.995 max_percent = 1.005 # 追涨，当我们的价格超过了均线一定程度时 if (x[1] / x[0]) &lt; min_percent: return &#39;open buy&#39; # 杀跌，当我们的价格低于均线一定程度时 if (x[1] / x[0]) &gt; max_percent: return &#39;close buy&#39; # 其他情况不操作 return &#39;wait&#39; df[&#39;action&#39;] = df[[&#39;close&#39;, &#39;avg&#39;]].apply(avg_buy, axis=1) return df def backtest(df): &#39;&#39;&#39; 回归测试 &#39;&#39;&#39; global shares, cash amount = 1000000 shares = 0 cash = amount def run_strategy(row): &#39;&#39;&#39; 把每天的数据执行策略 &#39;&#39;&#39; global shares, cash action = row[&#39;action&#39;] close = row[&#39;close&#39;] # 资产 = 现金 + 股票价值 liquidate = cash + shares * close message = &#39;nothing&#39; # 策略要求开仓做多，而且当前空仓时，做多 if action == &#39;open buy&#39; and shares == 0: shares = int(cash / close) cash -= shares * close message = &#39;open buy &#39; + str(shares) # 策略要求平仓，而且当前有仓时，平掉 if action == &#39;close buy&#39; and shares &gt; 0: message = &#39;close buy &#39; + str(shares) cash += shares * close shares = 0 return [message, shares, cash, liquidate] rows = df[[&#39;close&#39;, &#39;action&#39;]].apply(run_strategy, axis=1) df[&#39;message&#39;], df[&#39;shares&#39;], df[&#39;cash&#39;], df[&#39;liquidate&#39;] = zip(*rows) return df def draw(df): &#39;&#39;&#39; 画图 &#39;&#39;&#39; # 创建画板 fig = plt.figure(figsize=(10, 5)) # 准备横坐标 count = df.count()[&#39;close&#39;] index = np.arange(count) df[&#39;index&#39;] = index # 设置横坐标的刻度与显示标签 limit = 200 plt.xticks(index[::limit], df[&#39;date&#39;][::limit]) # 收盘价与资产的两套坐标系 ax_close = plt.gca() ax_liquidate = ax_close.twinx() # 画收盘价曲线 ax_close.set(xlabel=&#39;Date&#39;, ylabel=&#39;close&#39;) l_close, = ax_close.plot(index, df[&#39;close&#39;], &#39;black&#39;, label=&#39;close&#39;) l_avg, = ax_close.plot(index, df[&#39;avg&#39;], &#39;pink&#39;, label=&#39;avg&#39;) # 画资产曲线 ax_liquidate.set(ylabel = &#39;liquidate&#39;) l_liquidate, = ax_liquidate.plot(index, df[&#39;liquidate&#39;], &#39;blue&#39;, label=&#39;liquidate&#39;) def drawAction(row): if row[&#39;message&#39;] == &#39;nothing&#39;: return color = &#39;&#39; marker = &#39;o&#39; size = 12 if row[&#39;action&#39;] == &#39;open buy&#39;: color=&#39;r&#39; if row[&#39;action&#39;] == &#39;close buy&#39;: color=&#39;g&#39; ax_close.scatter(row[&#39;index&#39;], row[&#39;close&#39;], s=size, color=color, zorder=2, marker=marker) df[[&#39;index&#39;, &#39;action&#39;, &#39;message&#39;, &#39;close&#39;]].apply(drawAction, axis=1) # 给两条线都提供一个图例说明 plt.legend(handles=[l_close, l_avg, l_liquidate]) plt.show() if __name__ == &#39;__main__&#39;: run() &nbsp;转载自：conybcc的博客" />
<meta property="og:description" content="查看B站视频 目标 从上交所抓取近2000天的上证指数 整理成为一个矩阵，方便加工 量化分析数据并生成一个交易策略 回归测试，计算出策略对应的收益 画出价格与资产曲线 详细结果导出到csv文件 先看一下最终结果，赚了不少钱，哈哈 从上交所抓取近2000天的上证指数 分析 我们先在上交所 http://www.sse.com.cn/market/price/trends/ 的页面上查看 通过打开控制台，刷新页面后，注意到了真实的数据地址， 如下所示 http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881 这里面重要数据在kline里面，简单列一些如下(去掉了外层的jQuery，只保留json数据) { begin: 6525, code: &quot;000001&quot;, end: 6824, kline: [ [20170823, 3283.796, 3299.457, 3274.44, 3287.704, 179832208], [20170824, 3287.959, 3297.988, 3266.358, 3271.511, 163468937], ... ] } 每一项对应的意义分别是 20170823 第一项表示交易日期 3283.796 第二项表示开盘价 3299.457 第三项表示收盘价 3274.440 第四项表示最高价 3287.704 第五项表示最低价 179832208 最后是成交量 爬虫代码 # 引入相关的包 import json # 处理json格式的数据 import requests # 发起网络请求 def run(): &#39;&#39;&#39; 主程序, 用来调度各个重要流程 &#39;&#39;&#39; kline = load_sse() print(kline) def load_sse(): &#39;&#39;&#39; 获取上交所的上证指数K线, 最近2000个交易日数据 &#39;&#39;&#39; response = requests.get( &#39;http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881&#39;, headers={&#39;Referer&#39;: &#39;http://www.sse.com.cn/market/price/trends/&#39;} ) # 针对结果进行格式处理 json_str = response.text[42:-1] data = json.loads(json_str) return data[&#39;kline&#39;] if __name__ == &#39;__main__&#39;: run() 有好几点需要注意 这里只是贴的代码片段，只是方便大家理解，如果要执行，需要使用最后的完整程序 这里面的 def 是用来定义函数的，因为我们的程序比较复杂，所以按函数分成不同功能，方便阅读与维护 上面这些函数只是定义，不执行，在最后两行，才是真正执行的，先理解到这一层 每个函数里面的第一行，可以通过三个单引号来说明函数的作用，也是一种注释 网络请求的知识，前几节已经讲的比较多了，如果有问题可以翻看一下前面的内容 整理成为一个矩阵，方便加工 import pandas as pd # 优秀的分析数据工具 def init_df(kline): &#39;&#39;&#39; 根据K线数据，创建含有日期与收盘价的矩阵 &#39;&#39;&#39; df = pd.DataFrame({}) df[&#39;date&#39;] = [x[0] for x in kline] df[&#39;close&#39;] = [x[2] for x in kline] return df 我们引入了pandas库，他非常强大，用于处理数据 我们先看&nbsp;[x[0] for x in kline]&nbsp;的作用 这是快速提取数据某些元素的方式， kline里面有很多条数据，我们把每条数据的第一项，也就是交易日期提取出来，成为列表 第三项是收盘价，也是我们这次分析最重要的数据 这样创建的data_frame简称df就是一个矩阵，可以理解成如下内容 date close 0 20170101 777 1 20170102 888 通过df，我们可以很方便操作里面的数据 量化分析数据并生成一个交易策略 def strategy(df): &#39;&#39;&#39; 根据价格计算平均值，然后把策略记录下来 &#39;&#39;&#39; # 连续15天数据，计算平均值，作为当天的平均价格指标 window_size = 15 df[&#39;avg&#39;] = df[&#39;close&#39;].rolling(window_size).apply(lambda x: sum(x) / len(x), raw=True) def avg_buy(x): &#39;&#39;&#39; 做多策略 &#39;&#39;&#39; # 这里应该是追涨杀跌的策略，我在视频里说的类似低建高平策略，视频说的是错的 # 写代码的时候改过几次，后来没改注释，导致视频说错了 # 不过具体策略不影响我们程序的学习，大家注意到就好了 min_percent = 0.995 max_percent = 1.005 # 追涨，当我们的价格超过了均线一定程度时 if (x[1] / x[0]) &lt; min_percent: return &#39;open buy&#39; # 杀跌，当我们的价格低于均线一定程度时 if (x[1] / x[0]) &gt; max_percent: return &#39;close buy&#39; # 其他情况不操作 return &#39;wait&#39; df[&#39;action&#39;] = df[[&#39;close&#39;, &#39;avg&#39;]].apply(avg_buy, axis=1) return df rolling那一行的整体意思是计算最近15天的平均收盘价，我们拆分来看 lambda x: sum(x) / len(x)是一个简写的函数，这里的x是指一系列数字，这个函数用于计算平均值， sum是求和，len是求总数 df[&#39;close&#39;].rolling(window_size)&nbsp;是把收盘价按连续15个的方式，依次进行处理，类似很多人排队从一个大窗口走过， 这个窗口同时可以看到15个人，每走一个人我们就拍一下照片，得到了一个相册 apply(求平均函数, raw=True)&nbsp;的意思是把每张照片交给求平均函数，每次产生一个平均数，最终产生一组结果 这样就得到了每天对应的15日平均收盘价，保存到&nbsp;df[&#39;avg&#39;]&nbsp;方便后面使用 avg_buy(x)也是一个函数，根据传入的数据进行处理，而df[[&#39;close&#39;, &#39;avg&#39;]].apply(avg_buy, axis=1)正是把每天的收盘价与平均价传入了函数中， 这里的axis=1的原理非常复杂，我们只要知道，写上这个就能按照一天一天的交易日处理就行。 如果你对axis详细原理很感兴趣，可以单独找我，涉及到高级维度方面的数学知识，我已经弄明白了，愿意讨论分析 在avg_buy里面，x[0]表示当天收盘价，&nbsp;x[1]表示当天平均价 策略 我们把他们进行比较，如果收盘价超过均线一定比例，我们就买股票，追涨 如果收盘价跌过均线一定比例，就卖掉股票，杀跌 请注意视频中的说明是错误的，文字版这里的解释才是正确的 真实的交易细节相关 理论上是不可能收盘时买股票的，所以我们这里的收盘价可以认为是接近收盘的5分钟内的价格，这时候买入跟收盘价比较接近。我们所有统计也基于这样的收盘价，并不影响策略与收益 我在代码注释里用的术语是&nbsp;开多仓 开空仓 平多仓 平空仓&nbsp;这样更接近通用的表达，因为A股虽然不能做空，但其他金融产品是可以的，策略也是类似 风险提示 股市有风险 投资需谨慎 这个策略其实是非常简单的，只是用来演示，请不要根据这个进行投资，无法保证任何收益，切记 回归测试，计算出策略对应的收益 def backtest(df): &#39;&#39;&#39; 回归测试 &#39;&#39;&#39; global shares, cash amount = 1000000 shares = 0 cash = amount def run_strategy(row): &#39;&#39;&#39; 把每天的数据执行策略 &#39;&#39;&#39; global shares, cash action = row[&#39;action&#39;] close = row[&#39;close&#39;] # 资产 = 现金 + 股票价值 liquidate = cash + shares * close message = &#39;nothing&#39; # 策略要求开仓做多，而且当前空仓时，做多 if action == &#39;open buy&#39; and shares == 0: shares = int(cash / close) cash -= shares * close message = &#39;open buy &#39; + str(shares) # 策略要求平仓，而且当前有仓时，平掉 if action == &#39;close buy&#39; and shares &gt; 0: message = &#39;close buy &#39; + str(shares) cash += shares * close shares = 0 return [message, shares, cash, liquidate] rows = df[[&#39;close&#39;, &#39;action&#39;]].apply(run_strategy, axis=1) df[&#39;message&#39;], df[&#39;shares&#39;], df[&#39;cash&#39;], df[&#39;liquidate&#39;] = zip(*rows) return df 这里的作用，就是执行策略，计算持股，资产，现金等数据 流程介绍(不含复杂语法) 先定义了share：持股数量&nbsp;cash：当前现金&nbsp;amount：初始资金100万 run_strategy接收一天的数据， 根据收盘价与持股数量及现金，计算最新的资产，因为买入或者卖出都不影响当天的资产了，所以可以先计算好 策略要求做多而且没有持股的时候，就用现金买入股票，这里为了方便，相当于上证指数也是一个股票，而且我们可以不按整手买入 平仓就是卖掉股票，所以持股减少而现金增加 最终把几条信息整理返回 外层使用&nbsp;apply后得到了多行数据 然后记录到不同地方，形成了message：交易信息&nbsp;及其他几项数据 复杂点解释，可以不用深究 因为这里是在函数内，backtest 与 run_strategy 都需要使用global标识才能修改shares cash, 以后我们详细讲闭包与作用域就能了解更多 因为我们的df是一列一列的，所以通过zip(*rows)进行一次转置，如果你学过线性代数的话，应该比较容易想象到，就是行与列的转换 axis=1也是按行处理的意思，跟上一个函数类似 画出价格与资产曲线 import numpy as np # 处理数字的工具 import matplotlib.pyplot as plt # 强大的画图工具 def draw(df): &#39;&#39;&#39; 画图 &#39;&#39;&#39; # 创建画板 fig = plt.figure(figsize=(10, 5)) # 准备横坐标 count = df.count()[&#39;close&#39;] index = np.arange(count) # 设置横坐标的刻度与显示标签 limit = 200 plt.xticks(index[::limit], df[&#39;date&#39;][::limit]) # 收盘价与资产的两套坐标系 ax_close = plt.gca() ax_liquidate = ax_close.twinx() # 画收盘价曲线 ax_close.set(xlabel=&#39;Date&#39;, ylabel=&#39;close&#39;) l_close, = ax_close.plot(index, df[&#39;close&#39;], &#39;black&#39;, label=&#39;close&#39;) # 画资产曲线 ax_liquidate.set(ylabel = &#39;liquidate&#39;) l_liquidate, = ax_liquidate.plot(index, df[&#39;liquidate&#39;], &#39;blue&#39;, label=&#39;liquidate&#39;) # 给两条线都提供一个图例说明 plt.legend(handles=[l_close, l_liquidate]) plt.show() 其实不用画图，我们的量化交易也做完了，画出图可以让我们更好地分析 本课不详细介绍画图流程了，希望大家把重点放在数据处理上，后面我们会详细讲画图 注意， 我在视频教程中用的是旧版，最新的我已经加入了均线与买入点，卖出点，请注意 详细结果导出到csv文件 df.to_csv(&#39;./result.csv&#39;, index = False) pandas用来处理数据很方便，导出到csv也就是这一行代码 可以在你的python文件同目录下找到csv 量化交易补充 股市有风险 投资需谨慎 虽然这个示例程序的演示效果赚了不少钱，但一定不要用于真正的投资，这一点再次强调 另外，我们做量化交易的时候，其实需要经常调整参数，好的策略也要配合好的参数，本例中的15天均值，0.995 1.005等策略用到的比例，都是很重要的参数，需要不断调试才能确定 至此，我们的最简单版本量化交易程序就实现了 还有很多功能可以加进来， 也算是策略的优化 当然，具体策略取决于你对证券的理解，我列一些思路 支持做空 把现金分成多份来投资，不要全仓操作 一天内的短线策略 多个股票组合 将交易量加入策略考虑因素 配合消息面的文本分析 如果你有好的建议，我们可以讨论更多策略 完整代码 # lesson5.py # 最简单的量化交易及可视化图 # 引入相关的包 # 如果本地环境没有，需要先安装 # pip install pandas # pip install numpy # pip install matplotlib import json # 处理json格式的数据 import requests # 发起网络请求 import pandas as pd # 优秀的分析数据工具 import numpy as np # 处理数字的工具 import matplotlib.pyplot as plt # 强大的画图工具 def run(): &#39;&#39;&#39; 主程序, 用来调度各个重要流程 &#39;&#39;&#39; kline = load_sse() df = init_df(kline) df = strategy(df) df = backtest(df) draw(df) df.to_csv(&#39;./result.csv&#39;, index = False) def load_sse(): &#39;&#39;&#39; 获取上交所的上证指数K线, 最近2000个交易日数据 &#39;&#39;&#39; response = requests.get( &#39;http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881&#39;, headers={&#39;Referer&#39;: &#39;http://www.sse.com.cn/market/price/trends/&#39;} ) # 针对结果进行格式处理 json_str = response.text[42:-1] data = json.loads(json_str) return data[&#39;kline&#39;] def init_df(kline): &#39;&#39;&#39; 根据K线数据，创建含有日期与收盘价的矩阵 &#39;&#39;&#39; df = pd.DataFrame({}) df[&#39;date&#39;] = [x[0] for x in kline] df[&#39;close&#39;] = [x[2] for x in kline] return df def strategy(df): &#39;&#39;&#39; 根据价格计算平均值，然后把策略记录下来 &#39;&#39;&#39; # 连续15天数据，计算平均值，作为当天的平均价格指标 window_size = 15 df[&#39;avg&#39;] = df[&#39;close&#39;].rolling(window_size).apply(lambda x: sum(x) / len(x), raw=True) def avg_buy(x): &#39;&#39;&#39; 做多策略 &#39;&#39;&#39; # 这里应该是追涨杀跌的策略，我在视频里说的类似低建高平策略，视频说的是错的 # 写代码的时候改过几次，后来没改注释，导致视频说错了 # 不过具体策略不影响我们程序的学习，大家注意到就好了 min_percent = 0.995 max_percent = 1.005 # 追涨，当我们的价格超过了均线一定程度时 if (x[1] / x[0]) &lt; min_percent: return &#39;open buy&#39; # 杀跌，当我们的价格低于均线一定程度时 if (x[1] / x[0]) &gt; max_percent: return &#39;close buy&#39; # 其他情况不操作 return &#39;wait&#39; df[&#39;action&#39;] = df[[&#39;close&#39;, &#39;avg&#39;]].apply(avg_buy, axis=1) return df def backtest(df): &#39;&#39;&#39; 回归测试 &#39;&#39;&#39; global shares, cash amount = 1000000 shares = 0 cash = amount def run_strategy(row): &#39;&#39;&#39; 把每天的数据执行策略 &#39;&#39;&#39; global shares, cash action = row[&#39;action&#39;] close = row[&#39;close&#39;] # 资产 = 现金 + 股票价值 liquidate = cash + shares * close message = &#39;nothing&#39; # 策略要求开仓做多，而且当前空仓时，做多 if action == &#39;open buy&#39; and shares == 0: shares = int(cash / close) cash -= shares * close message = &#39;open buy &#39; + str(shares) # 策略要求平仓，而且当前有仓时，平掉 if action == &#39;close buy&#39; and shares &gt; 0: message = &#39;close buy &#39; + str(shares) cash += shares * close shares = 0 return [message, shares, cash, liquidate] rows = df[[&#39;close&#39;, &#39;action&#39;]].apply(run_strategy, axis=1) df[&#39;message&#39;], df[&#39;shares&#39;], df[&#39;cash&#39;], df[&#39;liquidate&#39;] = zip(*rows) return df def draw(df): &#39;&#39;&#39; 画图 &#39;&#39;&#39; # 创建画板 fig = plt.figure(figsize=(10, 5)) # 准备横坐标 count = df.count()[&#39;close&#39;] index = np.arange(count) df[&#39;index&#39;] = index # 设置横坐标的刻度与显示标签 limit = 200 plt.xticks(index[::limit], df[&#39;date&#39;][::limit]) # 收盘价与资产的两套坐标系 ax_close = plt.gca() ax_liquidate = ax_close.twinx() # 画收盘价曲线 ax_close.set(xlabel=&#39;Date&#39;, ylabel=&#39;close&#39;) l_close, = ax_close.plot(index, df[&#39;close&#39;], &#39;black&#39;, label=&#39;close&#39;) l_avg, = ax_close.plot(index, df[&#39;avg&#39;], &#39;pink&#39;, label=&#39;avg&#39;) # 画资产曲线 ax_liquidate.set(ylabel = &#39;liquidate&#39;) l_liquidate, = ax_liquidate.plot(index, df[&#39;liquidate&#39;], &#39;blue&#39;, label=&#39;liquidate&#39;) def drawAction(row): if row[&#39;message&#39;] == &#39;nothing&#39;: return color = &#39;&#39; marker = &#39;o&#39; size = 12 if row[&#39;action&#39;] == &#39;open buy&#39;: color=&#39;r&#39; if row[&#39;action&#39;] == &#39;close buy&#39;: color=&#39;g&#39; ax_close.scatter(row[&#39;index&#39;], row[&#39;close&#39;], s=size, color=color, zorder=2, marker=marker) df[[&#39;index&#39;, &#39;action&#39;, &#39;message&#39;, &#39;close&#39;]].apply(drawAction, axis=1) # 给两条线都提供一个图例说明 plt.legend(handles=[l_close, l_avg, l_liquidate]) plt.show() if __name__ == &#39;__main__&#39;: run() &nbsp;转载自：conybcc的博客" />
<link rel="canonical" href="https://mlh.app/2019/05/04/729548.html" />
<meta property="og:url" content="https://mlh.app/2019/05/04/729548.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-04T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"查看B站视频 目标 从上交所抓取近2000天的上证指数 整理成为一个矩阵，方便加工 量化分析数据并生成一个交易策略 回归测试，计算出策略对应的收益 画出价格与资产曲线 详细结果导出到csv文件 先看一下最终结果，赚了不少钱，哈哈 从上交所抓取近2000天的上证指数 分析 我们先在上交所 http://www.sse.com.cn/market/price/trends/ 的页面上查看 通过打开控制台，刷新页面后，注意到了真实的数据地址， 如下所示 http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881 这里面重要数据在kline里面，简单列一些如下(去掉了外层的jQuery，只保留json数据) { begin: 6525, code: &quot;000001&quot;, end: 6824, kline: [ [20170823, 3283.796, 3299.457, 3274.44, 3287.704, 179832208], [20170824, 3287.959, 3297.988, 3266.358, 3271.511, 163468937], ... ] } 每一项对应的意义分别是 20170823 第一项表示交易日期 3283.796 第二项表示开盘价 3299.457 第三项表示收盘价 3274.440 第四项表示最高价 3287.704 第五项表示最低价 179832208 最后是成交量 爬虫代码 # 引入相关的包 import json # 处理json格式的数据 import requests # 发起网络请求 def run(): &#39;&#39;&#39; 主程序, 用来调度各个重要流程 &#39;&#39;&#39; kline = load_sse() print(kline) def load_sse(): &#39;&#39;&#39; 获取上交所的上证指数K线, 最近2000个交易日数据 &#39;&#39;&#39; response = requests.get( &#39;http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881&#39;, headers={&#39;Referer&#39;: &#39;http://www.sse.com.cn/market/price/trends/&#39;} ) # 针对结果进行格式处理 json_str = response.text[42:-1] data = json.loads(json_str) return data[&#39;kline&#39;] if __name__ == &#39;__main__&#39;: run() 有好几点需要注意 这里只是贴的代码片段，只是方便大家理解，如果要执行，需要使用最后的完整程序 这里面的 def 是用来定义函数的，因为我们的程序比较复杂，所以按函数分成不同功能，方便阅读与维护 上面这些函数只是定义，不执行，在最后两行，才是真正执行的，先理解到这一层 每个函数里面的第一行，可以通过三个单引号来说明函数的作用，也是一种注释 网络请求的知识，前几节已经讲的比较多了，如果有问题可以翻看一下前面的内容 整理成为一个矩阵，方便加工 import pandas as pd # 优秀的分析数据工具 def init_df(kline): &#39;&#39;&#39; 根据K线数据，创建含有日期与收盘价的矩阵 &#39;&#39;&#39; df = pd.DataFrame({}) df[&#39;date&#39;] = [x[0] for x in kline] df[&#39;close&#39;] = [x[2] for x in kline] return df 我们引入了pandas库，他非常强大，用于处理数据 我们先看&nbsp;[x[0] for x in kline]&nbsp;的作用 这是快速提取数据某些元素的方式， kline里面有很多条数据，我们把每条数据的第一项，也就是交易日期提取出来，成为列表 第三项是收盘价，也是我们这次分析最重要的数据 这样创建的data_frame简称df就是一个矩阵，可以理解成如下内容 date close 0 20170101 777 1 20170102 888 通过df，我们可以很方便操作里面的数据 量化分析数据并生成一个交易策略 def strategy(df): &#39;&#39;&#39; 根据价格计算平均值，然后把策略记录下来 &#39;&#39;&#39; # 连续15天数据，计算平均值，作为当天的平均价格指标 window_size = 15 df[&#39;avg&#39;] = df[&#39;close&#39;].rolling(window_size).apply(lambda x: sum(x) / len(x), raw=True) def avg_buy(x): &#39;&#39;&#39; 做多策略 &#39;&#39;&#39; # 这里应该是追涨杀跌的策略，我在视频里说的类似低建高平策略，视频说的是错的 # 写代码的时候改过几次，后来没改注释，导致视频说错了 # 不过具体策略不影响我们程序的学习，大家注意到就好了 min_percent = 0.995 max_percent = 1.005 # 追涨，当我们的价格超过了均线一定程度时 if (x[1] / x[0]) &lt; min_percent: return &#39;open buy&#39; # 杀跌，当我们的价格低于均线一定程度时 if (x[1] / x[0]) &gt; max_percent: return &#39;close buy&#39; # 其他情况不操作 return &#39;wait&#39; df[&#39;action&#39;] = df[[&#39;close&#39;, &#39;avg&#39;]].apply(avg_buy, axis=1) return df rolling那一行的整体意思是计算最近15天的平均收盘价，我们拆分来看 lambda x: sum(x) / len(x)是一个简写的函数，这里的x是指一系列数字，这个函数用于计算平均值， sum是求和，len是求总数 df[&#39;close&#39;].rolling(window_size)&nbsp;是把收盘价按连续15个的方式，依次进行处理，类似很多人排队从一个大窗口走过， 这个窗口同时可以看到15个人，每走一个人我们就拍一下照片，得到了一个相册 apply(求平均函数, raw=True)&nbsp;的意思是把每张照片交给求平均函数，每次产生一个平均数，最终产生一组结果 这样就得到了每天对应的15日平均收盘价，保存到&nbsp;df[&#39;avg&#39;]&nbsp;方便后面使用 avg_buy(x)也是一个函数，根据传入的数据进行处理，而df[[&#39;close&#39;, &#39;avg&#39;]].apply(avg_buy, axis=1)正是把每天的收盘价与平均价传入了函数中， 这里的axis=1的原理非常复杂，我们只要知道，写上这个就能按照一天一天的交易日处理就行。 如果你对axis详细原理很感兴趣，可以单独找我，涉及到高级维度方面的数学知识，我已经弄明白了，愿意讨论分析 在avg_buy里面，x[0]表示当天收盘价，&nbsp;x[1]表示当天平均价 策略 我们把他们进行比较，如果收盘价超过均线一定比例，我们就买股票，追涨 如果收盘价跌过均线一定比例，就卖掉股票，杀跌 请注意视频中的说明是错误的，文字版这里的解释才是正确的 真实的交易细节相关 理论上是不可能收盘时买股票的，所以我们这里的收盘价可以认为是接近收盘的5分钟内的价格，这时候买入跟收盘价比较接近。我们所有统计也基于这样的收盘价，并不影响策略与收益 我在代码注释里用的术语是&nbsp;开多仓 开空仓 平多仓 平空仓&nbsp;这样更接近通用的表达，因为A股虽然不能做空，但其他金融产品是可以的，策略也是类似 风险提示 股市有风险 投资需谨慎 这个策略其实是非常简单的，只是用来演示，请不要根据这个进行投资，无法保证任何收益，切记 回归测试，计算出策略对应的收益 def backtest(df): &#39;&#39;&#39; 回归测试 &#39;&#39;&#39; global shares, cash amount = 1000000 shares = 0 cash = amount def run_strategy(row): &#39;&#39;&#39; 把每天的数据执行策略 &#39;&#39;&#39; global shares, cash action = row[&#39;action&#39;] close = row[&#39;close&#39;] # 资产 = 现金 + 股票价值 liquidate = cash + shares * close message = &#39;nothing&#39; # 策略要求开仓做多，而且当前空仓时，做多 if action == &#39;open buy&#39; and shares == 0: shares = int(cash / close) cash -= shares * close message = &#39;open buy &#39; + str(shares) # 策略要求平仓，而且当前有仓时，平掉 if action == &#39;close buy&#39; and shares &gt; 0: message = &#39;close buy &#39; + str(shares) cash += shares * close shares = 0 return [message, shares, cash, liquidate] rows = df[[&#39;close&#39;, &#39;action&#39;]].apply(run_strategy, axis=1) df[&#39;message&#39;], df[&#39;shares&#39;], df[&#39;cash&#39;], df[&#39;liquidate&#39;] = zip(*rows) return df 这里的作用，就是执行策略，计算持股，资产，现金等数据 流程介绍(不含复杂语法) 先定义了share：持股数量&nbsp;cash：当前现金&nbsp;amount：初始资金100万 run_strategy接收一天的数据， 根据收盘价与持股数量及现金，计算最新的资产，因为买入或者卖出都不影响当天的资产了，所以可以先计算好 策略要求做多而且没有持股的时候，就用现金买入股票，这里为了方便，相当于上证指数也是一个股票，而且我们可以不按整手买入 平仓就是卖掉股票，所以持股减少而现金增加 最终把几条信息整理返回 外层使用&nbsp;apply后得到了多行数据 然后记录到不同地方，形成了message：交易信息&nbsp;及其他几项数据 复杂点解释，可以不用深究 因为这里是在函数内，backtest 与 run_strategy 都需要使用global标识才能修改shares cash, 以后我们详细讲闭包与作用域就能了解更多 因为我们的df是一列一列的，所以通过zip(*rows)进行一次转置，如果你学过线性代数的话，应该比较容易想象到，就是行与列的转换 axis=1也是按行处理的意思，跟上一个函数类似 画出价格与资产曲线 import numpy as np # 处理数字的工具 import matplotlib.pyplot as plt # 强大的画图工具 def draw(df): &#39;&#39;&#39; 画图 &#39;&#39;&#39; # 创建画板 fig = plt.figure(figsize=(10, 5)) # 准备横坐标 count = df.count()[&#39;close&#39;] index = np.arange(count) # 设置横坐标的刻度与显示标签 limit = 200 plt.xticks(index[::limit], df[&#39;date&#39;][::limit]) # 收盘价与资产的两套坐标系 ax_close = plt.gca() ax_liquidate = ax_close.twinx() # 画收盘价曲线 ax_close.set(xlabel=&#39;Date&#39;, ylabel=&#39;close&#39;) l_close, = ax_close.plot(index, df[&#39;close&#39;], &#39;black&#39;, label=&#39;close&#39;) # 画资产曲线 ax_liquidate.set(ylabel = &#39;liquidate&#39;) l_liquidate, = ax_liquidate.plot(index, df[&#39;liquidate&#39;], &#39;blue&#39;, label=&#39;liquidate&#39;) # 给两条线都提供一个图例说明 plt.legend(handles=[l_close, l_liquidate]) plt.show() 其实不用画图，我们的量化交易也做完了，画出图可以让我们更好地分析 本课不详细介绍画图流程了，希望大家把重点放在数据处理上，后面我们会详细讲画图 注意， 我在视频教程中用的是旧版，最新的我已经加入了均线与买入点，卖出点，请注意 详细结果导出到csv文件 df.to_csv(&#39;./result.csv&#39;, index = False) pandas用来处理数据很方便，导出到csv也就是这一行代码 可以在你的python文件同目录下找到csv 量化交易补充 股市有风险 投资需谨慎 虽然这个示例程序的演示效果赚了不少钱，但一定不要用于真正的投资，这一点再次强调 另外，我们做量化交易的时候，其实需要经常调整参数，好的策略也要配合好的参数，本例中的15天均值，0.995 1.005等策略用到的比例，都是很重要的参数，需要不断调试才能确定 至此，我们的最简单版本量化交易程序就实现了 还有很多功能可以加进来， 也算是策略的优化 当然，具体策略取决于你对证券的理解，我列一些思路 支持做空 把现金分成多份来投资，不要全仓操作 一天内的短线策略 多个股票组合 将交易量加入策略考虑因素 配合消息面的文本分析 如果你有好的建议，我们可以讨论更多策略 完整代码 # lesson5.py # 最简单的量化交易及可视化图 # 引入相关的包 # 如果本地环境没有，需要先安装 # pip install pandas # pip install numpy # pip install matplotlib import json # 处理json格式的数据 import requests # 发起网络请求 import pandas as pd # 优秀的分析数据工具 import numpy as np # 处理数字的工具 import matplotlib.pyplot as plt # 强大的画图工具 def run(): &#39;&#39;&#39; 主程序, 用来调度各个重要流程 &#39;&#39;&#39; kline = load_sse() df = init_df(kline) df = strategy(df) df = backtest(df) draw(df) df.to_csv(&#39;./result.csv&#39;, index = False) def load_sse(): &#39;&#39;&#39; 获取上交所的上证指数K线, 最近2000个交易日数据 &#39;&#39;&#39; response = requests.get( &#39;http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881&#39;, headers={&#39;Referer&#39;: &#39;http://www.sse.com.cn/market/price/trends/&#39;} ) # 针对结果进行格式处理 json_str = response.text[42:-1] data = json.loads(json_str) return data[&#39;kline&#39;] def init_df(kline): &#39;&#39;&#39; 根据K线数据，创建含有日期与收盘价的矩阵 &#39;&#39;&#39; df = pd.DataFrame({}) df[&#39;date&#39;] = [x[0] for x in kline] df[&#39;close&#39;] = [x[2] for x in kline] return df def strategy(df): &#39;&#39;&#39; 根据价格计算平均值，然后把策略记录下来 &#39;&#39;&#39; # 连续15天数据，计算平均值，作为当天的平均价格指标 window_size = 15 df[&#39;avg&#39;] = df[&#39;close&#39;].rolling(window_size).apply(lambda x: sum(x) / len(x), raw=True) def avg_buy(x): &#39;&#39;&#39; 做多策略 &#39;&#39;&#39; # 这里应该是追涨杀跌的策略，我在视频里说的类似低建高平策略，视频说的是错的 # 写代码的时候改过几次，后来没改注释，导致视频说错了 # 不过具体策略不影响我们程序的学习，大家注意到就好了 min_percent = 0.995 max_percent = 1.005 # 追涨，当我们的价格超过了均线一定程度时 if (x[1] / x[0]) &lt; min_percent: return &#39;open buy&#39; # 杀跌，当我们的价格低于均线一定程度时 if (x[1] / x[0]) &gt; max_percent: return &#39;close buy&#39; # 其他情况不操作 return &#39;wait&#39; df[&#39;action&#39;] = df[[&#39;close&#39;, &#39;avg&#39;]].apply(avg_buy, axis=1) return df def backtest(df): &#39;&#39;&#39; 回归测试 &#39;&#39;&#39; global shares, cash amount = 1000000 shares = 0 cash = amount def run_strategy(row): &#39;&#39;&#39; 把每天的数据执行策略 &#39;&#39;&#39; global shares, cash action = row[&#39;action&#39;] close = row[&#39;close&#39;] # 资产 = 现金 + 股票价值 liquidate = cash + shares * close message = &#39;nothing&#39; # 策略要求开仓做多，而且当前空仓时，做多 if action == &#39;open buy&#39; and shares == 0: shares = int(cash / close) cash -= shares * close message = &#39;open buy &#39; + str(shares) # 策略要求平仓，而且当前有仓时，平掉 if action == &#39;close buy&#39; and shares &gt; 0: message = &#39;close buy &#39; + str(shares) cash += shares * close shares = 0 return [message, shares, cash, liquidate] rows = df[[&#39;close&#39;, &#39;action&#39;]].apply(run_strategy, axis=1) df[&#39;message&#39;], df[&#39;shares&#39;], df[&#39;cash&#39;], df[&#39;liquidate&#39;] = zip(*rows) return df def draw(df): &#39;&#39;&#39; 画图 &#39;&#39;&#39; # 创建画板 fig = plt.figure(figsize=(10, 5)) # 准备横坐标 count = df.count()[&#39;close&#39;] index = np.arange(count) df[&#39;index&#39;] = index # 设置横坐标的刻度与显示标签 limit = 200 plt.xticks(index[::limit], df[&#39;date&#39;][::limit]) # 收盘价与资产的两套坐标系 ax_close = plt.gca() ax_liquidate = ax_close.twinx() # 画收盘价曲线 ax_close.set(xlabel=&#39;Date&#39;, ylabel=&#39;close&#39;) l_close, = ax_close.plot(index, df[&#39;close&#39;], &#39;black&#39;, label=&#39;close&#39;) l_avg, = ax_close.plot(index, df[&#39;avg&#39;], &#39;pink&#39;, label=&#39;avg&#39;) # 画资产曲线 ax_liquidate.set(ylabel = &#39;liquidate&#39;) l_liquidate, = ax_liquidate.plot(index, df[&#39;liquidate&#39;], &#39;blue&#39;, label=&#39;liquidate&#39;) def drawAction(row): if row[&#39;message&#39;] == &#39;nothing&#39;: return color = &#39;&#39; marker = &#39;o&#39; size = 12 if row[&#39;action&#39;] == &#39;open buy&#39;: color=&#39;r&#39; if row[&#39;action&#39;] == &#39;close buy&#39;: color=&#39;g&#39; ax_close.scatter(row[&#39;index&#39;], row[&#39;close&#39;], s=size, color=color, zorder=2, marker=marker) df[[&#39;index&#39;, &#39;action&#39;, &#39;message&#39;, &#39;close&#39;]].apply(drawAction, axis=1) # 给两条线都提供一个图例说明 plt.legend(handles=[l_close, l_avg, l_liquidate]) plt.show() if __name__ == &#39;__main__&#39;: run() &nbsp;转载自：conybcc的博客","@type":"BlogPosting","url":"https://mlh.app/2019/05/04/729548.html","headline":"用Python做量化交易策略 画图并导出csv","dateModified":"2019-05-04T00:00:00+08:00","datePublished":"2019-05-04T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/05/04/729548.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>用Python做量化交易策略 画图并导出csv</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p><a href="https://www.bilibili.com/video/av35982906/" rel="nofollow">查看B站视频</a></p> 
  <h2 id="目标">目标</h2> 
  <ul>
   <li>从上交所抓取近2000天的上证指数</li> 
   <li>整理成为一个矩阵，方便加工</li> 
   <li>量化分析数据并生成一个交易策略</li> 
   <li>回归测试，计算出策略对应的收益</li> 
   <li>画出价格与资产曲线</li> 
   <li>详细结果导出到csv文件</li> 
  </ul>
  <p>先看一下最终结果，赚了不少钱，哈哈</p> 
  <p><img alt="image" class="has" src="https://conybcc.github.io/topic/images/lesson5_result.png"></p> 
  <h2 id="从上交所抓取近2000天的上证指数">从上交所抓取近2000天的上证指数</h2> 
  <h3 id="分析">分析</h3> 
  <p>我们先在上交所 http://www.sse.com.cn/market/price/trends/ 的页面上查看</p> 
  <p>通过打开控制台，刷新页面后，注意到了真实的数据地址， 如下所示</p> 
  <pre class="has">
<code class="language-python">http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881
</code></pre> 
  <p>这里面重要数据在<code>kline</code>里面，简单列一些如下(去掉了外层的jQuery，只保留json数据)</p> 
  <pre class="has">
<code class="language-python">{
    begin: 6525,
    code: "000001",
    end: 6824,
    kline: [
        [20170823, 3283.796, 3299.457, 3274.44, 3287.704, 179832208],
        [20170824, 3287.959, 3297.988, 3266.358, 3271.511, 163468937],
        ...
    ]
}
</code></pre> 
  <p>每一项对应的意义分别是</p> 
  <ul>
   <li>20170823 第一项表示交易日期</li> 
   <li>3283.796 第二项表示开盘价</li> 
   <li>3299.457 第三项表示收盘价</li> 
   <li>3274.440 第四项表示最高价</li> 
   <li>3287.704 第五项表示最低价</li> 
   <li>179832208 最后是成交量</li> 
  </ul>
  <h3 id="爬虫代码">爬虫代码</h3> 
  <pre class="has">
<code class="language-python"># 引入相关的包
import json # 处理json格式的数据
import requests # 发起网络请求

def run():
    ''' 主程序, 用来调度各个重要流程 '''
    kline = load_sse()
    print(kline)

def load_sse():
    ''' 获取上交所的上证指数K线, 最近2000个交易日数据 '''
    response = requests.get(
        'http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881',
        headers={'Referer': 'http://www.sse.com.cn/market/price/trends/'}
    )

    # 针对结果进行格式处理
    json_str = response.text[42:-1]
    data = json.loads(json_str)
    return data['kline']

if __name__ == '__main__':
    run()
</code></pre> 
  <p>有好几点需要注意</p> 
  <ul>
   <li>这里只是贴的代码片段，只是方便大家理解，如果要执行，需要使用最后的完整程序</li> 
   <li>这里面的 def 是用来定义函数的，因为我们的程序比较复杂，所以按函数分成不同功能，方便阅读与维护</li> 
   <li>上面这些函数只是定义，不执行，在最后两行，才是真正执行的，先理解到这一层</li> 
   <li>每个函数里面的第一行，可以通过三个单引号来说明函数的作用，也是一种注释</li> 
  </ul>
  <p>网络请求的知识，前几节已经讲的比较多了，如果有问题可以翻看一下前面的内容</p> 
  <h2 id="整理成为一个矩阵方便加工">整理成为一个矩阵，方便加工</h2> 
  <pre class="has">
<code class="language-python">import pandas as pd # 优秀的分析数据工具

def init_df(kline):
    ''' 根据K线数据，创建含有日期与收盘价的矩阵 '''
    df = pd.DataFrame({})
    df['date'] =  [x[0] for x in kline]
    df['close'] = [x[2] for x in kline]

    return df
</code></pre> 
  <p>我们引入了pandas库，他非常强大，用于处理数据</p> 
  <p>我们先看&nbsp;<code>[x[0] for x in kline]</code>&nbsp;的作用</p> 
  <p>这是快速提取数据某些元素的方式， kline里面有很多条数据，我们把每条数据的第一项，也就是交易日期提取出来，成为列表</p> 
  <p>第三项是收盘价，也是我们这次分析最重要的数据</p> 
  <p>这样创建的<code>data_frame</code>简称<code>df</code>就是一个矩阵，可以理解成如下内容</p> 
  <pre class="has">
<code class="language-python">       date  close
0  20170101    777
1  20170102    888
</code></pre> 
  <p>通过df，我们可以很方便操作里面的数据</p> 
  <h2 id="量化分析数据并生成一个交易策略">量化分析数据并生成一个交易策略</h2> 
  <pre class="has">
<code class="language-python">def strategy(df):
    ''' 根据价格计算平均值，然后把策略记录下来 '''

    # 连续15天数据，计算平均值，作为当天的平均价格指标
    window_size = 15
    df['avg'] = df['close'].rolling(window_size).apply(lambda x: sum(x) / len(x), raw=True)

    def avg_buy(x):
        ''' 做多策略 '''
        # 这里应该是追涨杀跌的策略，我在视频里说的类似低建高平策略，视频说的是错的
        # 写代码的时候改过几次，后来没改注释，导致视频说错了
        # 不过具体策略不影响我们程序的学习，大家注意到就好了
        min_percent = 0.995
        max_percent = 1.005
        # 追涨，当我们的价格超过了均线一定程度时
        if (x[1] / x[0]) &lt; min_percent:
            return 'open buy'
        # 杀跌，当我们的价格低于均线一定程度时
        if (x[1] / x[0]) &gt; max_percent:
            return 'close buy'
        # 其他情况不操作
        return 'wait'

    df['action'] = df[['close', 'avg']].apply(avg_buy, axis=1)
    return df
</code></pre> 
  <p>rolling那一行的整体意思是计算最近15天的平均收盘价，我们拆分来看</p> 
  <ul>
   <li><code>lambda x: sum(x) / len(x)</code>是一个简写的函数，这里的x是指一系列数字，这个函数用于计算平均值， sum是求和，len是求总数</li> 
   <li><code>df['close'].rolling(window_size)</code>&nbsp;是把收盘价按连续15个的方式，依次进行处理，类似很多人排队从一个大窗口走过， 这个窗口同时可以看到15个人，每走一个人我们就拍一下照片，得到了一个相册</li> 
   <li><code>apply(求平均函数, raw=True)</code>&nbsp;的意思是把每张照片交给求平均函数，每次产生一个平均数，最终产生一组结果</li> 
  </ul>
  <p>这样就得到了每天对应的15日平均收盘价，保存到&nbsp;<code>df['avg']</code>&nbsp;方便后面使用</p> 
  <p><code>avg_buy(x)</code>也是一个函数，根据传入的数据进行处理，而<code>df[['close', 'avg']].apply(avg_buy, axis=1)</code>正是把每天的收盘价与平均价传入了函数中， 这里的<code>axis=1</code>的原理非常复杂，我们只要知道，写上这个就能按照一天一天的交易日处理就行。</p> 
  <p>如果你对axis详细原理很感兴趣，可以单独找我，涉及到高级维度方面的数学知识，我已经弄明白了，愿意讨论分析</p> 
  <p>在<code>avg_buy</code>里面，<code>x[0]</code>表示当天收盘价，&nbsp;<code>x[1]</code>表示当天平均价</p> 
  <h3 id="策略">策略</h3> 
  <p>我们把他们进行比较，如果收盘价超过均线一定比例，我们就买股票，追涨</p> 
  <p>如果收盘价跌过均线一定比例，就卖掉股票，杀跌</p> 
  <p>请注意视频中的说明是错误的，文字版这里的解释才是正确的</p> 
  <h3 id="真实的交易细节相关">真实的交易细节相关</h3> 
  <p>理论上是不可能收盘时买股票的，所以我们这里的收盘价可以认为是接近收盘的5分钟内的价格，这时候买入跟收盘价比较接近。我们所有统计也基于这样的收盘价，并不影响策略与收益</p> 
  <p>我在代码注释里用的术语是&nbsp;<code>开多仓 开空仓 平多仓 平空仓</code>&nbsp;这样更接近通用的表达，因为A股虽然不能做空，但其他金融产品是可以的，策略也是类似</p> 
  <h3 id="风险提示">风险提示</h3> 
  <blockquote> 
   <p>股市有风险 投资需谨慎</p> 
  </blockquote> 
  <p>这个策略其实是非常简单的，只是用来演示，请不要根据这个进行投资，无法保证任何收益，切记</p> 
  <h2 id="回归测试计算出策略对应的收益">回归测试，计算出策略对应的收益</h2> 
  <pre class="has">
<code class="language-python">def backtest(df):
    ''' 回归测试 '''
    global shares, cash
    amount = 1000000
    shares = 0
    cash = amount

    def run_strategy(row):
        ''' 把每天的数据执行策略 '''
        global shares, cash
        action = row['action']
        close = row['close']

        # 资产 = 现金 + 股票价值
        liquidate = cash + shares * close
        message = 'nothing'

        # 策略要求开仓做多，而且当前空仓时，做多
        if action == 'open buy' and shares == 0:
            shares = int(cash / close)
            cash -= shares * close
            message = 'open buy ' + str(shares)

        # 策略要求平仓，而且当前有仓时，平掉
        if action == 'close buy' and shares &gt; 0:
            message = 'close buy ' + str(shares)
            cash += shares * close
            shares = 0

        return [message, shares, cash, liquidate]

    rows = df[['close', 'action']].apply(run_strategy, axis=1)
    df['message'], df['shares'], df['cash'], df['liquidate'] = zip(*rows)
    return df
</code></pre> 
  <p>这里的作用，就是执行策略，计算持股，资产，现金等数据</p> 
  <p>流程介绍(不含复杂语法)</p> 
  <ul>
   <li>先定义了<code>share：持股数量</code>&nbsp;<code>cash：当前现金</code>&nbsp;<code>amount：初始资金100万</code></li> 
   <li><code>run_strategy</code>接收一天的数据， 根据收盘价与持股数量及现金，计算最新的资产，因为买入或者卖出都不影响当天的资产了，所以可以先计算好</li> 
   <li>策略要求做多而且没有持股的时候，就用现金买入股票，这里为了方便，相当于上证指数也是一个股票，而且我们可以不按整手买入</li> 
   <li>平仓就是卖掉股票，所以持股减少而现金增加</li> 
   <li>最终把几条信息整理返回</li> 
   <li>外层使用&nbsp;<code>apply</code>后得到了多行数据</li> 
   <li>然后记录到不同地方，形成了<code>message：交易信息</code>&nbsp;及其他几项数据</li> 
  </ul>
  <p>复杂点解释，可以不用深究</p> 
  <ul>
   <li>因为这里是在函数内，backtest 与 run_strategy 都需要使用global标识才能修改shares cash, 以后我们详细讲闭包与作用域就能了解更多</li> 
   <li>因为我们的<code>df</code>是一列一列的，所以通过<code>zip(*rows)</code>进行一次转置，如果你学过线性代数的话，应该比较容易想象到，就是行与列的转换</li> 
   <li><code>axis=1</code>也是按行处理的意思，跟上一个函数类似</li> 
  </ul>
  <h2 id="画出价格与资产曲线">画出价格与资产曲线</h2> 
  <pre class="has">
<code class="language-python">import numpy as np # 处理数字的工具
import matplotlib.pyplot as plt # 强大的画图工具

def draw(df):
    ''' 画图 '''
    # 创建画板
    fig = plt.figure(figsize=(10, 5))

    # 准备横坐标
    count = df.count()['close']
    index = np.arange(count)

    # 设置横坐标的刻度与显示标签
    limit = 200
    plt.xticks(index[::limit], df['date'][::limit])

    # 收盘价与资产的两套坐标系
    ax_close = plt.gca()
    ax_liquidate = ax_close.twinx()

    # 画收盘价曲线
    ax_close.set(xlabel='Date', ylabel='close')
    l_close, = ax_close.plot(index, df['close'], 'black', label='close')

    # 画资产曲线
    ax_liquidate.set(ylabel = 'liquidate')
    l_liquidate, = ax_liquidate.plot(index, df['liquidate'], 'blue', label='liquidate')

    # 给两条线都提供一个图例说明
    plt.legend(handles=[l_close, l_liquidate])
    plt.show()
</code></pre> 
  <p>其实不用画图，我们的量化交易也做完了，画出图可以让我们更好地分析</p> 
  <p>本课不详细介绍画图流程了，希望大家把重点放在数据处理上，后面我们会详细讲画图</p> 
  <p>注意， 我在视频教程中用的是旧版，最新的我已经加入了均线与买入点，卖出点，请注意</p> 
  <h2 id="详细结果导出到csv文件">详细结果导出到csv文件</h2> 
  <pre class="has">
<code class="language-python">df.to_csv('./result.csv', index = False)
</code></pre> 
  <p>pandas用来处理数据很方便，导出到csv也就是这一行代码</p> 
  <p>可以在你的python文件同目录下找到csv</p> 
  <h2 id="量化交易补充">量化交易补充</h2> 
  <blockquote> 
   <p>股市有风险 投资需谨慎</p> 
  </blockquote> 
  <p>虽然这个示例程序的演示效果赚了不少钱，但一定不要用于真正的投资，这一点再次强调</p> 
  <p>另外，我们做量化交易的时候，其实需要经常调整参数，好的策略也要配合好的参数，本例中的15天均值，<code>0.995 1.005</code>等策略用到的比例，都是很重要的参数，需要不断调试才能确定</p> 
  <p>至此，我们的最简单版本量化交易程序就实现了</p> 
  <p>还有很多功能可以加进来， 也算是策略的优化</p> 
  <p>当然，具体策略取决于你对证券的理解，我列一些思路</p> 
  <ul>
   <li>支持做空</li> 
   <li>把现金分成多份来投资，不要全仓操作</li> 
   <li>一天内的短线策略</li> 
   <li>多个股票组合</li> 
   <li>将交易量加入策略考虑因素</li> 
   <li>配合消息面的文本分析</li> 
  </ul>
  <p>如果你有好的建议，我们可以讨论更多策略</p> 
  <h2 id="完整代码">完整代码</h2> 
  <pre class="has">
<code class="language-python"># lesson5.py
# 最简单的量化交易及可视化图

# 引入相关的包
# 如果本地环境没有，需要先安装
# pip install pandas
# pip install numpy
# pip install matplotlib
import json # 处理json格式的数据
import requests # 发起网络请求
import pandas as pd # 优秀的分析数据工具
import numpy as np # 处理数字的工具
import matplotlib.pyplot as plt # 强大的画图工具

def run():
    ''' 主程序, 用来调度各个重要流程 '''
    kline = load_sse()
    df = init_df(kline)
    df = strategy(df)
    df = backtest(df)
    draw(df)
    df.to_csv('./result.csv', index = False)

def load_sse():
    ''' 获取上交所的上证指数K线, 最近2000个交易日数据 '''
    response = requests.get(
        'http://yunhq.sse.com.cn:32041/v1/sh1/dayk/000001?callback=jQuery111205234775875526079_1542185571865&amp;select=date%2Copen%2Chigh%2Clow%2Cclose%2Cvolume&amp;begin=-2000&amp;end=-1&amp;_=1542185571881',
        headers={'Referer': 'http://www.sse.com.cn/market/price/trends/'}
    )

    # 针对结果进行格式处理
    json_str = response.text[42:-1]
    data = json.loads(json_str)
    return data['kline']

def init_df(kline):
    ''' 根据K线数据，创建含有日期与收盘价的矩阵 '''
    df = pd.DataFrame({})
    df['date'] =  [x[0] for x in kline]
    df['close'] = [x[2] for x in kline]

    return df

def strategy(df):
    ''' 根据价格计算平均值，然后把策略记录下来 '''

    # 连续15天数据，计算平均值，作为当天的平均价格指标
    window_size = 15
    df['avg'] = df['close'].rolling(window_size).apply(lambda x: sum(x) / len(x), raw=True)

    def avg_buy(x):
        ''' 做多策略 '''
        # 这里应该是追涨杀跌的策略，我在视频里说的类似低建高平策略，视频说的是错的
        # 写代码的时候改过几次，后来没改注释，导致视频说错了
        # 不过具体策略不影响我们程序的学习，大家注意到就好了
        min_percent = 0.995
        max_percent = 1.005
        # 追涨，当我们的价格超过了均线一定程度时
        if (x[1] / x[0]) &lt; min_percent:
            return 'open buy'
        # 杀跌，当我们的价格低于均线一定程度时
        if (x[1] / x[0]) &gt; max_percent:
            return 'close buy'
        # 其他情况不操作
        return 'wait'

    df['action'] = df[['close', 'avg']].apply(avg_buy, axis=1)
    return df

def backtest(df):
    ''' 回归测试 '''
    global shares, cash
    amount = 1000000
    shares = 0
    cash = amount

    def run_strategy(row):
        ''' 把每天的数据执行策略 '''
        global shares, cash
        action = row['action']
        close = row['close']

        # 资产 = 现金 + 股票价值
        liquidate = cash + shares * close
        message = 'nothing'

        # 策略要求开仓做多，而且当前空仓时，做多
        if action == 'open buy' and shares == 0:
            shares = int(cash / close)
            cash -= shares * close
            message = 'open buy ' + str(shares)

        # 策略要求平仓，而且当前有仓时，平掉
        if action == 'close buy' and shares &gt; 0:
            message = 'close buy ' + str(shares)
            cash += shares * close
            shares = 0

        return [message, shares, cash, liquidate]

    rows = df[['close', 'action']].apply(run_strategy, axis=1)
    df['message'], df['shares'], df['cash'], df['liquidate'] = zip(*rows)
    return df

def draw(df):
    ''' 画图 '''
    # 创建画板
    fig = plt.figure(figsize=(10, 5))

    # 准备横坐标
    count = df.count()['close']
    index = np.arange(count)
    df['index'] = index

    # 设置横坐标的刻度与显示标签
    limit = 200
    plt.xticks(index[::limit], df['date'][::limit])

    # 收盘价与资产的两套坐标系
    ax_close = plt.gca()
    ax_liquidate = ax_close.twinx()

    # 画收盘价曲线
    ax_close.set(xlabel='Date', ylabel='close')
    l_close, = ax_close.plot(index, df['close'], 'black', label='close')
    l_avg, = ax_close.plot(index, df['avg'], 'pink', label='avg')

    # 画资产曲线
    ax_liquidate.set(ylabel = 'liquidate')
    l_liquidate, = ax_liquidate.plot(index, df['liquidate'], 'blue', label='liquidate')

    def drawAction(row):
        if row['message'] == 'nothing':
            return

        color = ''
        marker = 'o'
        size = 12

        if row['action'] == 'open buy':
            color='r'
        if row['action'] == 'close buy':
            color='g'

        ax_close.scatter(row['index'], row['close'], s=size, color=color, zorder=2, marker=marker)

    df[['index', 'action', 'message', 'close']].apply(drawAction, axis=1)

    # 给两条线都提供一个图例说明
    plt.legend(handles=[l_close, l_avg, l_liquidate])
    plt.show()

if __name__ == '__main__':
    run()</code></pre> 
  <p>&nbsp;转载自：<a href="https://conybcc.github.io/" rel="nofollow">conybcc的博客</a></p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
