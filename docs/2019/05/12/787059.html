<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>MapReduce 论文中文翻译 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="MapReduce 论文中文翻译" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="目录 1&nbsp;介绍 2&nbsp;编程模型 3&nbsp;实现 4&nbsp;技巧 5&nbsp;性能 6&nbsp;经验 7&nbsp;相关工作 8&nbsp;结束语 附录A、单词频率统计 原文下载链接：https://pan.baidu.com/s/1L9hclpiqQ-NVjmbqSz3mMQ&nbsp; 提取码：xhwn&nbsp; 摘要 MapReduce是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一个Map函数处理一个基于key/value pair的数据集合，输出中间的基于key/value pair的数据集合；然后再创建一个Reduce函数用来合并所有具有相同中间key值的中间value值。现实世界中有很多满足上述 处理模型的例子，本论文将详细描述这个模型。 MapReduce架构的程序能够在大量的配置普通的计算机上实现并行化处理。这个系统在运行时只关心：如何分割输入数据，在大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间必要的通信。采用MapReduce架构可以使那些没有并行计算和分布式处理系统开发经验的程序员有效利用分布式系统的丰富资源。 我们的MapReduce实现运行在规模可以灵活调整的由普通机器组成的集群上：一个典型的MapReduce计算往往由几千台机器组成、处理以TB计算的数据。程序员发现这个系统非常好用：已经实现了数以百计的MapReduce程序，在Google的集群上，每天都有1000多个MapReduce程序在执行。 &nbsp; 1&nbsp;介绍 在过去的5年里，包括本文作者在内的Google的很多程序员，为了处理海量的原始数据，已经实现了数以百计的、专用的计算方法。这些计算方法用来处理大量的原始数据，比如，文档抓取（类似网络爬虫的程序）、Web请求日志等；也为了计算处理各种类型的衍生数据，比如倒排索引、Web文档的图结构的各种表示形势、每台主机上网络爬虫抓取的页面数量的汇总、每天被请求的最多的查询的集合等。大多数这样的数据处理运算在概念上很容易理解。然而由于输入的数据量巨大，因此要想在可接受的时间内完成运算，只有将这些计算分布在成百上千的主机上。如何处理并行计算、如何分发数据、如何处理错误？所有这些问题综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。 为了解决上述复杂的问题，我们设计一个新的抽象模型，使用这个抽象模型，我们只要表述我们想要执行的简单运算即可，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，这些问题都被封装在一个库里面。设计这个抽象模型的灵感来自Lisp和许多其它函数式语言的Map和Reduce的原语。我们意识到我们大多数的运算都包含这样的操作：在输入数据的&quot;逻辑&quot;记录上应用Map操作得出一个中间key/value pair集合，然后在所有具有相同key值的value值上应用Reduce操作，从而达到合并中间的数据，得到一个想要的结果的目的。使用MapReduce模型，再结合用户实现的Map和Reduce函数，我们就可以非常容易的实现大规模并行化计算；通过MapReduce模型自带的&quot;再次执行&quot;功能，也提供了初级的容灾实现方案。 这个工作(实现一个MapReduce框架模型)的主要贡献是通过简单的接口来实现自动的、并行化和大规模的分布式计算，通过使用MapReduce模型接口实现在大量普通的PC机上高性能计算。 第二部分描述基本的编程模型和一些使用案例。第三部分描述了一个基于我们集群的计算环境所定制的MapReduce接口的实现。第四部分描述我们认为在MapReduce编程模型中一些实用的技巧。第五部分对于各种不同的任务，测量我们MapReduce实现的性能。第六部分揭示了在Google内部如何使用MapReduce作为基础重写我们的索引系统产品，包括其它一些使用MapReduce的经验。第七部分讨论相关的和未来的工作。 &nbsp; 2&nbsp;编程模型 MapReduce编程模型的原理是：利用一个输入key/value pair集合来产生一个输出的key/value pair集合。MapReduce库的用户用两个函数表达这个计算：Map和Reduce。 用户自定义的Map函数接受一个输入的key/value pair值，然后产生一个中间key/value pair值的集合(takes an input pair and produces a set of intermediate key/value pairs.)。MapReduce库把所有具有相同intermediate key值I的intermediate value值集合在一起后传递给Reduce函数。 用户自定义的Reduce函数接受一个中间key的值(假设此值为I)和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小的value值的集合。一般每次Reduce函数调用只产生0或1个输出的value值。通常，我们通过一个迭代器把中间value值提供给Reduce函数，这样我们就可以处理无法全部放入内存中的大量的value值的集合。 &nbsp; 2.1 例子 例如，计算一个大的文档集合中每个单词出现的次数，下面是伪代码段： map(String key, String value): // key: document name // value: document contents for each word w in value: EmitIntermediate(w, &quot;1&quot;); reduce(String key, Iterator values): // key: a word // values: a list of counts int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result)); Map函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是1)。Reduce函数把Map函数产生的每一个特定的词的计数累加起来。 另外，用户编写代码，使用输入和输出文件的名字、可选的调节参数来完成一个符合MapReduce模型规范的对象，然后调用MapReduce函数，并把这个规范对象传递给它。用户的代码和MapReduce库链接在一起(用C++实现)。附录A包含了这个实例的全部程序代码。 &nbsp; 2.2&nbsp;类型 尽管在前面例子的伪代码中使用了以字符串表示的输入输出值，但是在概念上，用户定义的Map和Reduce函数都有相关联的类型： map(k1,v1) -&gt;list(k2,v2) reduce(k2,list(v2)) -&gt;list(v2) 比如，输入的key和value值与输出的key和value值在类型上推导的域不同。此外，中间key和value值与输出key和value值在类型上推导的域相同。（注：参考Hadoop、KFS等实现，map和reduce都使用了泛型，因此，domain理解成类型推导的域）。我们的C++中使用字符串类型作为用户自定义函数的输入输出，用户在自己的代码中对字符串进行适当的类型转换。 &nbsp; 2.3&nbsp;更多的例子 这里还有一些有趣的简单例子，可以很容易的使用MapReduce模型来表示： 分布式的Grep：Map函数输出匹配某个模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。(Grep是Globally search a Regular Expression and Print的缩写，它是一种强大的文本搜索工具，能使用特定模式匹配（包括正则表达式）搜索文本，并默认输出匹配行。) 计算URL访问频率：Map函数处理日志中Web页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。(最好理解的一个例子) 倒转网络链接图：Map函数在源页面（source）中搜索所有的链接目标（target）并输出为(target,source)。Reduce函数把给定链接目标（target）的链接组合成一个列表，输出(target,list(source))。 每个主机的检索词向量：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。Map函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的URL。Reduce函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主机名,检索词向量)。 倒排索引：Map函数分析每个文档输出一个(词,文档号)的列表，Reduce函数的输入是一个给定词的所有（词，文档号），排序所有的文档号，输出(词,list（文档号）)。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。 分布式排序：Map函数从每个记录提取key，输出(key,record)。Reduce函数不改变任何的值。这个运算依赖分区机制(在4.1描述)和排序属性(在4.2描述)。 &nbsp; 3&nbsp;实现 MapReduce模型可以有多种不同的实现方式。如何正确选择取决于具体的环境。例如，一种实现方式适用于小型的共享内存方式的机器，另外一种实现方式则适用于大型NUMA架构的多处理器的主机，而有的实现方式更适合大型的网络连接集群。 本章节描述一个适用于Google内部广泛使用的运算环境的实现：用以太网交换机连接、由普通PC机组成的大型集群。在我们的环境里包括： 1.x86架构、运行Linux操作系统、双处理器、2-4GB内存的机器。 2.普通的网络硬件设备，每个机器的带宽为百兆或者千兆，但是远小于网络的平均带宽的一半。 3.集群中包含成百上千的机器，因此，机器故障是常态。 4.存储为廉价的内置IDE硬盘。一个内部分布式文件系统用来管理存储在这些磁盘上的数据。文件系统通过数据复制来在不可靠的硬件上保证数据的可靠性和有效性。 5.用户提交工作（job）给调度系统。每个工作（job）都包含一系列的任务（task），调度系统将这些任务调度到集群中多台可用的机器上。 &nbsp; 3.1&nbsp;执行概括 通过将Map调用的输入数据自动分割为M个数据片段的集合，Map调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使用分区函数将Map调用产生的中间key值分成R个不同分区（例如，hash(key) mod R），Reduce调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。 图1展示了我们的MapReduce实现中操作的全部流程。当用户调用MapReduce函数时，将发生下面的一系列动作（下面的序号和图1中的序号一一对应）： 1.用户程序首先调用的MapReduce库将输入文件分成M个数据片段，每个数据片段的大小一般从 16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在集群中创建大量的程序副本。 2.这些程序副本中的有一个特殊的程序——Master。副本中其它的程序都是worker程序，由Master分配任务。有M个Map任务和R个Reduce任务将被分配，Master将一个Map任务或Reduce任务分配给一个空闲的worker。 3.被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key/value&nbsp;pair，然后把key/value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key/value&nbsp;pair，并缓存在内存中。 4.缓存中的key/value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key/value pair在本地磁盘上的存储位置将被回传给Master，由Master负责把这些存储位置再传送给Reduce worker。 5.当Reduce worker程序接收到Master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。 6.Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。 7.当所有的Map和Reduce任务都完成之后，Master唤醒用户程序。在这个时候，在用户程序里对MapReduce的调用才返回。 在成功完成任务之后，MapReduce的输出存放在R个输出文件中（对应每个Reduce任务产生一个输出文件，文件名由用户指定）。一般情况下，用户不需要将这R个输出文件合并成一个文件——它们经常把这些文件作为另外一个MapReduce的输入，或者在另外一个可以处理多个分割文件的分布式应用中使用。 &nbsp; 3.2&nbsp;Master数据结构 Master持有一些数据结构，它存储每一个Map和Reduce任务的状态（空闲、工作中或完成)，以及Worker机器(非空闲任务的机器)的标识。 Master就像一个数据管道，中间文件存储区域的位置信息通过这个管道从Map传递到Reduce。因此，对于每个已经完成的Map任务，Master存储了Map任务产生的R个中间文件存储区域的大小和位置。当Map任务完成时，Master接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的Reduce任务。 &nbsp; 3.3&nbsp;容错 因为MapReduce库的设计初衷是使用由成百上千的机器组成的集群来处理超大规模的数据，所以，这个库必须要能很好的处理机器故障。 Worker故障 Master周期性的ping每个worker。如果在一个约定的时间范围内没有收到worker返回的信息，Master将把这个worker标记为失效。所有由这个失效的worker完成的Map任务被重置为初始的空闲状态，之后这些任务就可以被安排给其它的worker。同样的，worker失效时正在运行的Map或Reduce任务也将被重新置为空闲状态，等待重新调度。 当worker故障时，由于已经完成的Map任务的输出存储在本地，Map任务的输出已不可访问了，因此必须重新执行。而已经完成的Reduce任务的输出存储在全局文件系统上，因此不需要再次执行。 当一个Map任务首先被worker A执行，之后由于worker A失效了又被调度到worker B执行，这个&quot;重新执行&quot;的动作会被通知给所有执行Reduce任务的worker。任何还没有从worker A读取数据的Reduce任务将从worker B读取数据。 MapReduce可以处理大规模worker失效的情况。比如，在一个MapReduce操作执行期间，在正在运行的集群上进行网络维护引起80台机器在几分钟内不可访问了，MapReduce Master只需要简单的再次执行那些不可访问的worker完成的工作，之后继续执行未完成的任务，直到最终完成这个MapReduce操作。 &nbsp; Master失败 一个简单的解决办法是让Master周期性的将上面描述的数据结构的写入磁盘，即检查点（checkpoint）。如果这个Master任务失效了，可以从最后一个检查点（checkpoint）开始启动另一个Master进程。然而，由于只有一个Master进程，Master失效后再恢复是比较麻烦的，因此我们现在的实现是如果Master失效，就中止MapReduce运算。客户可以检查到这个状态，并且可以根据需要重新执行MapReduce操作。 &nbsp; 在失效方面的处理机制 当用户提供的Map和Reduce操作是输入确定性函数（即相同的输入产生相同的输出）时，我们的分布式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。 我们依赖对Map和Reduce任务的输出是原子提交的来完成这个特性。每个工作中的任务把它的输出写到私有的临时文件中。每个Reduce任务生成一个这样的文件，而每个Map任务则生成R个这样的文件（一个Reduce任务对应一个文件）。当一个Map任务完成的时，worker发送一个包含R个临时文件名的完成消息给Master。如果Master从一个已经完成的Map任务再次接收到到一个完成消息，Master将忽略这个消息；否则，Master将这R个文件的名字记录在数据结构里。 当Reduce任务完成时，Reduce worker进程以原子的方式把临时文件重命名为最终的输出文件。如果同一个Reduce任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名操作执行。我们依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个Reduce任务产生的数据。 使用MapReduce模型的程序员可以很容易的理解它们程序的行为，因为我们绝大多数的Map和Reduce操作是确定的，而且存在这样的一个事实：我们的失效处理机制等价于一个顺序的执行的操作。当Map和/或Reduce操作是不确定性的时候，我们提供虽然较弱但是依然合理的处理机制。当使用非确定操作的时候，一个Reduce任务R1的输出等价于一个非确定性程序的顺序执行产生的输出(In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output for R1 produced by a sequential execution of the non-deterministic program.)。但是，另一个不同的Reduce任务R2的输出也许符合一个非确定程序的非顺序执行产生的R2的输出(However, the output for a different reduce task R2 may correspond to the output for R2 produced by a different sequential execution of the non-deterministic program.)。 考虑Map任务M和Reduce任务R1、R2的情况。我们设定e(Ri)是Ri已经提交的执行过程（有且仅有一个这样的执行过程）。语义较弱是因为e（R1）可能读取了M的一次执行产生的输出，e（R2）可能读取了M的另一次执行产生的输出。 &nbsp; 3.4&nbsp;存储位置 在我们的计算运行环境中，网络带宽是一个相当匮乏的资源。我们通过尽量把输入数据(由GFS管理)存储在集群中机器的本地磁盘上来节省网络带宽。GFS把每个文件按64MB一个Block分割，每个Block保存在多台机器上，环境中存放了多份拷贝(一般是3个拷贝)。MapReduce的Master在调度Map任务时会考虑输入文件的位置信息，尽量将一个Map任务调度在包含相关输入数据拷贝的机器上执行；如果上述努力失败了，Master将尝试在保存有输入数据拷贝的机器附近的机器上执行Map任务(例如，分配到一个和包含输入数据的机器在一个switch里的worker机器上执行)。当在一个足够大的cluster集群上运行大型MapReduce操作的时候，大部分的输入数据都能从本地机器读取，因此消耗非常少的网络带宽。 &nbsp; 3.5&nbsp;任务粒度 我们将Map阶段细分为M个片段，Reduce阶段细分为R个片段，如上所述。理想情况下，M和R应该远大于worker机器的数量。让每个worker执行许多不同任务改善了动态负载平衡，并在worker失败时加快了恢复速度：它完成的许多映射任务可以分布在所有其它worker机器上。 在我们的实现中，M和R的大小有实际的界限，因为Master必须做出O（M+R）调度决策，并在内存中保持O（M*R）状态，如上文所述。（但是，内存使用的常量因素很小：状态的O（M*R）部分由每个映射任务/减少任务对大约1个字节的数据组成。）更进一步，R值通常是由用户指定的，因为每个Reduce任务最终都会生成一个独立的输出文件。实际使用时我们也倾向于选择合适的M值，以使得每一个独立任务都是处理大约16M到64M的输入数据（这样，上面描写的输入数据本地存储优化策略才最有效），另外，我们把R值设置为我们想使用的worker机器数量的几倍(small multiple)。我们通常会用这样的比例来执行MapReduce：M=200000，R=5000，使用2000台worker机器。 &nbsp; 3.6&nbsp;备用任务(Backup Tasks) 影响一个MapReduce的总执行时间最通常的因素是&quot;落伍者&quot;：在运算过程中，如果有一台机器花了很长的时间才完成最后几个Map或Reduce任务，导致MapReduce操作总的执行时间超过预期。出现&quot;落伍者&quot;的原因非常多。比如：如果一个机器的硬盘出了问题，在读取的时候要经常的进行读取纠错操作，导致读取数据的速度从30M/s降低到1M/s。如果cluster的调度系统在这台机器上又调度了其它的任务，由于CPU、内存、本地硬盘和网络带宽等竞争因素的存在，导致执行MapReduce代码的执行效率更加缓慢。我们最近遇到的一个问题是由于机器的初始化代码有bug，导致关闭了的处理器的缓存：在这些机器上执行任务的性能和正常情况相差上百倍。 我们有一个通用的机制来减少&quot;落伍者&quot;出现的情况。当一个MapReduce操作接近完成的时候，Master调度备用（backup）任务进程来执行剩下的、处于运行中状态（in-progress）的任务。无论是最初的执行进程、还是备用（backup）任务进程完成了任务，我们都把这个任务标记成为已经完成。我们调优了这个机制，通常只会占用比正常操作多几个百分点的计算资源。我们发现采用这样的机制对于减少超大MapReduce操作的总处理时间效果显著。例如，在5.3节描述的排序任务，在关闭掉备用任务的情况下要多花44%的时间完成排序任务。 &nbsp; 4&nbsp;技巧 虽然简单的Map和Reduce函数提供的基本功能已经能够满足大部分的计算需要，我们还是发掘出了一些有价值的扩展功能。本节将描述这些扩展功能。 &nbsp; 4.1&nbsp;分区函数&nbsp;&nbsp; MapReduce的使用者通常会指定Reduce任务和Reduce任务输出文件的数量（R）。我们在中间key上使用分区函数来对数据进行分区，之后再输入到后续任务执行进程。一个缺省的分区函数是使用hash方法(比如，hash(key) mod R)进行分区。hash方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对key值进行的分区将非常有用。比如，输出的key值是URLs，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce库的使用者需要提供专门的分区函数。例如，使用&quot;hash(Hostname(urlkey)) mod R&quot;作为分区函数就可以把所有来自同一个主机的URLs保存在同一个输出文件中。 &nbsp; 4.2&nbsp;顺序保证 我们确保在给定的分区中，中间key/value pair数据的处理顺序是按照key值增量顺序处理的。这样的顺序保证对每个分区生成一个有序的输出文件，这对于需要对输出文件按key值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。 &nbsp; 4.3&nbsp;Combiner函数 在某些情况下，Map函数产生的中间key值的重复数据会占很大的比重，并且，用户自定义的Reduce函数满足结合律和交换律。在2.1节的词数统计程序是个很好的例子。由于词频率倾向于一个zipf分布(齐夫分布)，每个Map任务将产生成千上万个这样的记录&lt;the,1&gt;。所有的这些记录将通过网络被发送到一个单独的Reduce任务，然后由这个Reduce任务把所有这些记录累加起来产生一个数字。我们允许用户指定一个可选的Combiner函数，Combiner函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。 Combiner函数在每台执行Map任务的机器上都会被执行一次。一般情况下，Combiner和Reduce函数是一样的。Combiner函数和Reduce函数之间唯一的区别是MapReduce库怎样控制函数的输出。Reduce函数的输出被保存在最终的输出文件里，而Combiner函数的输出被写到中间文件里，然后被发送给Reduce任务。 合并中间结果可以显著的提高一些MapReduce操作的速度。附录A包含一个使用Combiner函数的例子。 &nbsp; 4.4&nbsp;输入和输出的类型 MapReduce库支持几种不同格式的输入数据。比如，文本模式的输入数据的每一行被视为是一个key/value pair。key是文件的偏移量，value是那一行的内容。另外一种常见的格式是以key进行排序来存储的key/value pair的序列。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单独的Map任务来进行后续处理(例如，文本模式的范围分割必须确保仅仅在每行的边界进行范围分割)。虽然大多数MapReduce的使用者仅仅使用很少的预定义输入类型就满足要求了，但是使用者依然可以通过提供一个简单的Reader接口就能够支持一个新的输入类型。 Reader并非一定要从文件中读取数据，比如，我们可以很容易的实现一个从数据库里读记录的Reader，或者从内存中的数据结构读取数据的Reader。 类似的，我们提供了一些预定义的输出数据类型，通过这些预定义类型能够产生不同格式的数据。用户采用类似添加新的输入数据类型的方式增加新的输出类型。 &nbsp; 4.5&nbsp;副作用 在某些情况下，MapReduce的使用者发现，如果在Map和/或Reduce操作(map and/or reduce operators.)过程中增加辅助的输出文件会比较省事。我们依靠程序writer把这种&quot;副作用&quot;变成原子的以及幂等的。通常应用程序首先把输出结果写到一个临时文件中，在输出全部数据之后，在使用系统级的原子操作rename重新命名这个临时文件。 我们不支持由单个任务生成的多个输出文件的原子两阶段提交，因此，生成具有跨文件一致性要求的多个输出文件的任务应该是确定性的。这种限制在实践中从未成为一个问题。 &nbsp; 4.6&nbsp;跳过损坏的记录 有时候，用户程序中的bug导致Map或者Reduce函数在处理某些记录的时候crash掉，MapReduce操作无法顺利完成。惯常的做法是修复bug后再次执行MapReduce操作，但是，有时候找出这些bug并修复它们不是一件容易的事情；这些bug也许是在第三方库里，而我们手头没有这些库的源代码。而且在很多时候，忽略一些有问题的记录也是可以接受的，比如在一个巨大的数据集上进行统计分析的时候。我们提供了一种可选的执行模式，其中MapReduce库检测哪些记录会导致确定性crash，并跳过这些记录以向前推进。 每个worker进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus&nbsp;error）。在执行Map或者Reduce操作之前，MapReduce库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，消息处理函数将用&quot;最后一口气&quot;通过UDP包向Master发送处理的最后一条记录的序号。当Master看到在处理某条特定记录不止失败一次时，Master就标志这条记录需要被跳过，并且在下次重新执行相关的Map或者Reduce任务的时候跳过这条记录。 &nbsp; 4.7&nbsp;本地执行 调试Map和Reduce函数的bug是非常困难的，因为实际执行操作时不但是分布在系统中执行的，而且通常是在好几千台计算机上执行，具体的执行位置是由Master进行动态调度的，这又大大增加了调试的难度。为了简化调试、性能分析和小规模测试，我们开发了一套MapReduce库的本地实现版本，通过使用本地版本的MapReduce库，MapReduce操作在本地计算机上顺序执行。用户可以控制MapReduce操作的执行，可以把操作限制到特定的Map任务上。用户通过设定特别的标志来在本地执行它们的程序，之后就可以很容易的使用本地调试和测试工具（比如gdb）。 &nbsp; 4.8&nbsp;状态信息 主服务器运行内部HTTP服务器并导出一组状态页供人使用。状态页显示计算的进度，例如已完成的任务数、正在进行的任务数、输入字节数、中间数据字节数、输出字节数、处理速率等。这些页还包含指向每个任务生成的标准错误和标准输出文件的链接。用户可以使用这些数据来预测计算将花费多长时间，以及是否应向计算中添加更多的资源。这些页面还可用于确定计算速度比预期慢得多的时间。 此外，顶级状态页面显示哪些worker失败，以及哪些失效的时候正在运行的Map和Reduce任务。当试图调试用户代码中的错误时，此信息非常有用。 &nbsp; 4.9&nbsp;计数器 MapReduce库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇German文档等等。 为了使用这个特性，用户在程序中创建一个命名的计数器对象，在Map和Reduce函数中相应的增加计数器的值。例如： Counter* uppercase; uppercase = GetCounter(&quot;uppercase&quot;); map(String name, String contents): for each word w in contents: if (IsCapitalized(w)): uppercase-&gt;Increment(); EmitIntermediate(w, &quot;1&quot;); 这些计数器的值周期性的从各个单独的worker机器上传递给Master（附加在ping的应答包中传递）。Master把执行成功的Map和Reduce任务的计数器值进行累计，当MapReduce操作完成之后，返回给用户代码。 计数器当前的值也会显示在Master的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器的值的时候，Master要检查重复运行的Map或者Reduce任务，避免重复累加（之前提到的备用任务和失效后重新执行任务这两种情况会导致相同的任务被多次执行）。有些计数器的值是由MapReduce库自动维持的，比如已经处理的输入的key/value pair的数量、输出的key/value pair的数量等等。 计数器机制对于MapReduce操作的完整性检查非常有用。比如，在某些MapReduce操作中，用户需要确保产生的output pairs精确的等于处理的input pairs，或者处理的German文档数量在被处理的整个文档数量中属于合理范围。 &nbsp; 5&nbsp;性能 本节我们分析在一个大型集群上运行的两个计算来衡量MapReduce的性能。一个计算是在大约1TB的数据中进行特定的模式匹配，另一个计算对大约1TB的数据进行排序。 这两个程序在大量使用的MapReduce应用中是非常具有代表性的——一类是对数据格式进行转换，从一种表现形式转换为另外一种表现形式；另一类是从海量数据中抽取少部分用户感兴趣的数据。 &nbsp; 5.1&nbsp;集群配置 所有这些程序都运行在一个由大约1800台机器构成的集群上。每台机器配置2个2G主频、支持超线程的Intel Xeon处理器，4GB的物理内存，两个160GB的IDE硬盘和一个千兆以太网卡。这些机器部署在一个两层的树形交换网络中，在root节点大概有100-200GBPS的传输带宽。所有这些机器都采用相同的部署（对等部署），因此任意两点之间的网络往返时延小于1毫秒。 在4GB内存里，大概有1-1.5G用于运行集群上的其它任务。测试程序在周末下午开始执行，这时主机的CPU、磁盘和网络基本上处于空闲状态。 &nbsp; 5.2&nbsp;Grep(一种强大的文本搜索工具) 这个分布式的Grep程序需要扫描大概10的10次方个由100个字节组成的记录，查找出现概率较小的3个字符的模式（这个模式在92337个记录中出现）。输入数据被拆分成大约64M的Block（M=15000），整个输出数据存放在一个文件中（R=1）。 图2显示了这个运算随时间的处理过程。其中Y轴表示输入数据的处理速度。处理速度随着参与MapReduce计算的机器数量的增加而增加，当1764台worker参与计算的时，处理速度达到了30GB/s。当Map任务结束的时候，即在计算开始后80秒，输入的处理速度降到0。整个计算过程从开始到结束一共花了大概150秒。这包括了大约一分钟的初始启动阶段。初始启动阶段消耗的时间包括了把这个程序传送到各个worker机器上的时间、等待GFS文件系统打开1000个输入文件集合的时间、获取相关的文件本地位置优化信息的时间。 &nbsp; 5.3&nbsp;排序 排序程序处理10的10次方个100个字节组成的记录（大约1TB的数据）。这个程序模仿TeraSort&nbsp;benchmark。 排序程序由不到50行代码组成。只有三行的Map函数从文本行中解析出10个字节的key值作为排序的key，并且把这个key和原始文本行作为中间的key/value pair值输出。我们使用了一个内置的恒等函数(Identity function)作为Reduce操作函数，这个函数把中间key/value pair不作任何改变输出。最终排序的输出被写入一组双路复制的GFS文件中（也就是说，程序输出2TB的数据）。 如前所述，输入数据被分成64MB的Block（M=15000）。我们把排序后的输出结果分区后存储到4000个文件（R=4000）。分区函数使用key的原始字节来把数据分区到R个片段中。 在这个benchmark测试中，我们使用的分区函数知道key的分区情况。通常对于排序程序来说，我们会增加一个预处理的MapReduce操作用于采样key值的分布情况，通过采样的数据来计算对最终排序处理的分区点。(从上到下分别是Input、Shuffle和Output) 图三（a）显示了这个排序程序的正常执行过程。左上的图显示了Input数据读取的速度。数据读取速度峰值会达到13GB/s，并且所有Map任务在大约200秒之前完成，然后迅速滑落至0。值得注意的是，排序程序输入数据读取速度小于分布式Grep程序。这是因为排序程序的Map任务花了大约一半的处理时间和I/O带宽把中间输出结果写到本地硬盘。相应的分布式Grep程序的中间结果输出几乎可以忽略不计。 左边中间的图显示了中间数据从Map任务发送到Reduce任务的网络速度。这个过程从第一个Map任务完成之后就开始缓慢启动(shuffling)了。图示的第一个高峰是启动了第一批约1700个Reduce任务（整个MapReduce分布到大概1700台机器上，每台机器1次最多执行1个Reduce任务）。排序程序运行大约300秒后，第一批启动的Reduce任务只有部分完成，我们开始执行剩下的Reduce任务。所有的处理在大约600秒后结束。 左下图表示Reduce任务把排序后的数据写到最终的输出文件的速度。在第一个shuffling阶段结束和数据开始写入磁盘之间有延时，这是因为worker机器正在忙于排序中间数据。磁盘写入速度在2-4GB/s持续一段时间。输出数据写入磁盘大约持续850秒。计入初始启动部分的时间，整个运算消耗了891秒。这个速度和TeraSort benchmark的最高纪录1057秒相差不多。 需要注意的一点是：由于我们的本地化输入数据优化策略，Input速率高于Shuffle速率和Output速率——大多数数据是从本地磁盘读取的，并绕过我们相对受限的网络带宽。Shuffle速率高于Output速率，因为输出阶段会写入两份已排序数据的副本（我们写两份输出的副本的原因是为了可靠性和可用性）。我们编写两个副本，因为这是底层文件系统提供的可靠性和可用性机制。如果底层文件系统使用纠删码(erasure coding)而不是复制，则写入数据的网络带宽需求将减少。 &nbsp; 5.4&nbsp;高效的backup任务 图三（b）展示关闭备用任务后排序程序执行情况。执行的过程和图3（a）很相似，除了有一条非常长的尾巴，几乎没有任何写操作发生。在960秒后，只有5个Reduce任务没有完成。这些拖后腿的任务又执行了300秒才完成。整个计算消耗了1283秒，多了44%的执行时间。 &nbsp; 5.5&nbsp;失效的机器 在图三（c）演示在排序程序执行的过程中，我们在程序开始后几分钟有意的kill了1746个worker中的200个。集群底层的调度立刻在这些机器上重新开始新的worker处理进程（因为只是worker机器上的处理进程被kill了，机器本身还在工作）。 图三（c）显示出了一个&quot;负&quot;的输入数据读取速度，这是因为一些已经完成的Map任务丢失了（由于相应的执行Map任务的worker进程被kill了），需要重新执行这些任务。相关Map任务很快就被重新执行了。整个运算在933秒内完成，包括了初始启动时间（只比正常执行多消耗了5%的时间）。 &nbsp; 6&nbsp;经验 我们在2003年1月完成了第一个版本的MapReduce库，2003年8月的版本有了显著的增强，这包括了输入数据本地优化、worker机器之间的动态负载均衡等等。从那以后，我们惊喜的发现，MapReduce库能广泛应用于我们日常工作中遇到的各类问题。它现在在Google内部各个领域得到广泛应用，包括： 大规模机器学习问题 Google News和Froogle产品的集群问题 从公众查询产品（比如Google的Zeitgeist）的报告中抽取数据。 从大量的新应用和新产品的网页中提取有用信息（比如，从大量的位置搜索网页中抽取地理位置信息）。 大规模的图形计算。 图四显示了在我们的源代码管理系统中，随着时间推移，独立的MapReduce程序数量的显著增加。从2003年早些时候的0个增长到2004年9月份的差不多900个不同的程序。MapReduce的成功取决于采用MapReduce库能够在不到半个小时内写出一个简单的程序，这个简单的程序能够在上千台机器组成的集群上做大规模并行处理，这极大的加快了开发和原形设计(prototyping cycle)的周期。另外，采用MapReduce库，可以让完全没有分布式和/或并行系统开发经验的程序员很容易的利用大量的资源，开发出分布式和/或并行处理的应用。 在每个任务结束的时候，MapReduce库统计计算资源的使用状况。在表1，我们列出了2004年8月份MapReduce运行的任务所占用的相关资源。 &nbsp; 6.1&nbsp;大规模索引 到目前为止，MapReduce最成功的应用就是重写了Google网络搜索服务所使用到的index系统。索引系统的输入数据是网络爬虫抓取回来的海量的文档，这些文档数据都保存在GFS文件系统里。这些文档的原始内容的大小超过了20TB。索引程序是通过一系列的MapReduce操作（大约5到10次）来建立索引。使用MapReduce（替换上一个特别设计的、分布式处理的索引程序）带来这些好处： 实现索引部分的代码简单、小巧、容易理解，因为对于容错、分布式以及并行计算的处理都是MapReduce库提供的。比如，使用MapReduce库，计算的代码行数从原来的3800行C++代码减少到大约700行代码。 MapReduce库的性能已经足够好了，因此我们可以把在概念上不相关的计算步骤分开处理，而不是混在一起以减少数据传递的额外消耗。概念上不相关的计算步骤的隔离也使得我们可以很容易改变索引处理方式。比如，对之前的索引系统的一个小更改可能要耗费好几个月的时间，但是在使用MapReduce的新系统上，这样的更改只需要花几天时间就可以了。 索引系统的操作管理更容易了。因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝大部分问题都已经由MapReduce库解决了，不再需要操作人员的介入。另外，我们可以通过在索引系统集群中增加机器的简单方法提高整体处理性能。 &nbsp; 7&nbsp;相关工作 很多系统都提供了严格的编程模式，并且通过对编程的严格限制来实现并行计算。例如，一个结合函数可以通过把N个元素的数组的前缀在N个处理器上使用并行前缀算法，在log N的时间内计算完。根据我们对大型实际环境计算的经验，可以将MapReduce视为对其中一些模型的简化和提炼。(MapReduce can be considered a simplification and distillation of some of these models based on our experience with large real-world computations.)。更加值得骄傲的是，我们还实现了基于上千台处理器的集群的容错处理。相比而言，大部分并发处理系统都只在小规模的集群上实现，并且把容错处理交给了程序员。 Bulk Synchronous Programming和一些MPI原语提供了更高级别的并行处理抽象，可以更容易的写出并行处理的程序。MapReduce和这些系统的主要不同之处在于，MapReduce利用限制性编程模式实现了用户程序的自动并发处理，并且提供了透明的容错处理。 我们数据本地优化策略的灵感来源于active disks等技术，在active disks中，计算任务是尽量推送到数据所存储的节点处理，这样就减少了网络和IO子系统的吞吐量。我们在挂载几个硬盘的普通机器上执行我们的运算，而不是在磁盘处理器上执行我们的工作，但是达到的目的一样的。 我们的备用任务机制和Charlotte System提出的eager调度机制比较类似。Eager调度机制的一个缺点是如果一个任务反复失效，那么整个计算就不能完成。我们通过忽略引起故障的记录的方式在某种程度上解决了这个问题。 MapReduce的实现依赖于一个内部的集群管理系统，这个集群管理系统负责在一个超大的、共享机器的集群上分布和运行用户任务。虽然这个不是本论文的重点，但是有必要提一下，这个集群管理系统在理念上和其它系统，如Condor是一样。 MapReduce库的排序机制和NOW-Sort的操作很类似。读取输入源的机器（map workers）把待排序的数据进行分区后，发送到R个Reduce worker中的一个进行处理。每个Reduce worker在本地对数据进行排序（尽可能在内存中排序）。当然，NOW-Sort没有给用户自定义的Map和Reduce函数的机会，因此不具备MapReduce库广泛的实用性。River提供了一个编程模型：处理进程通过分布式队列传送数据的方式进行互相通讯。和MapReduce类似，River系统尝试在不对等的硬件环境下，或者在系统颠簸的情况下也能提供近似平均的性能。River是通过精心调度硬盘和网络的通讯来平衡任务的完成时间。MapReduce库采用了其它的方法。通过对编程模型进行限制，MapReduce框架把问题分解成为大量的&quot;小&quot;任务。这些任务在可用的worker集群上动态的调度，这样更快的worker就可以执行更多的任务。通过对编程模型进行限制，我们可在工作接近完成的时候调度备用任务，在硬件配置不均衡的情况下减少完成的时间（比如有的worker慢、或者worker被某些操作阻塞了）。 BAD-FS采用了和MapReduce完全不同的编程模式，它是面向广域网的。不过，这两个系统有两个基础功能很类似。（1）两个系统采用重新执行的方式来防止由于失效导致的数据丢失。（2）两个都使用数据本地化调度策略，减少网络通讯的数据量。 TACC是一个高可用网络服务的简化构造系统。和MapReduce一样，它也依靠重新执行机制来实现容错处理。 &nbsp; 8&nbsp;结束语 MapReduce编程模型在Google内部成功应用于多个领域。我们把这种成功归结为几个方面：首先，这种编程模式使得MapReduce库易于使用，即便对于完全没有并行或者分布式系统开发经验的程序员而言也很容易。这是因为MapReduce封装了并行处理、容错处理、数据本地化优化、负载均衡等等技术难点的细节；其次，大量不同类型的问题都可以通过MapReduce简单的解决。比如，MapReduce用于生成Google的网络搜索服务所需要的数据、用来排序、用来数据挖掘、用于机器学习，以及很多其它的系统；第三，我们实现了一个在数千台计算机组成的大型集群上灵活部署并运行的MapReduce。这个实现使得有效利用这些丰富的计算资源变得非常简单，因此也适合用于解决Google遇到的其它很多需要大量计算的问题。 我们也从MapReduce开发过程中学到了不少东西。首先，限制性编程模式使得并行和分布式计算非常容易，也易于构造容错的计算环境；其次，网络带宽是稀有资源。大量的系统优化以针对减少网络传输量为目的：本地优化策略使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节约了网络带宽；第三，多次执行相同的任务可以减少性能缓慢的机器带来的负面影响，同时解决了由于机器失效导致的数据丢失问题。 &nbsp; 附录A、单词频率统计 本节包含了一个完整的程序，用于统计在一组命令行指定的输入文件中，每一个不同的单词出现频率。 #include &quot;mapreduce/mapreduce.h&quot; // User’s map function class WordCounter : public Mapper { public: virtual void Map(const MapInput&amp; input) { const string&amp; text = input.value(); const int n = text.size(); for (int i = 0; i &lt; n; ) { // Skip past leading whitespace while((i &lt; n) &amp;&amp; isspace(text[i])) i++; // Find word end int start = i; while ((i &lt; n) &amp;&amp; !isspace(text[i])) i++; if (start &lt; i) Emit(text.substr(start,i-start),&quot;1&quot;); } } }; REGISTER_MAPPER(WordCounter); // User’s reduce function class Adder : public Reducer { virtual void Reduce(ReduceInput* input) { // Iterate over all entries with the // same key and add the values int64 value = 0; while (!input-&gt;done()) { value += StringToInt(input-&gt;value()); input-&gt;NextValue(); } // Emit sum for input-&gt;key() Emit(IntToString(value)); } }; REGISTER_REDUCER(Adder); int main(int argc, char** argv) { ParseCommandLineFlags(argc, argv); MapReduceSpecification spec; // Store list of input fifiles into &quot;spec&quot; for (int i = 1; i &lt; argc; i++) { MapReduceInput* input = spec.add_input(); input-&gt;set_format(&quot;text&quot;); input-&gt;set_filepattern(argv[i]); input-&gt;set_mapper_class(&quot;WordCounter&quot;); } // Specify the output files: // /gfs/test/freq-00000-of-00100 // /gfs/test/freq-00001-of-00100 // … MapReduceOutput* out = spec.output(); out-&gt;set_fifilebase(&quot;/gfs/test/freq&quot;); out-&gt;set_num_tasks(100); out-&gt;set_format(&quot;text&quot;); out-&gt;set_reducer_class(&quot;Adder&quot;); // Optional: do partial sums within map // tasks to save network bandwidth out-&gt;set_combiner_class(&quot;Adder&quot;); //Tuning parameters: use at most 2000 //machines and 100 MB of memory per task spec.set_machines(2000); spec.set_map_megabytes(100); spec.set_reduce_megabytes(100); //Now run it MapReduceResult result; if (!MapReduce(spec, &amp;result)) abort(); // Done: ‘result’ structure contains info // about counters, time taken, number of // machines used, etc. return 0; } &nbsp;" />
<meta property="og:description" content="目录 1&nbsp;介绍 2&nbsp;编程模型 3&nbsp;实现 4&nbsp;技巧 5&nbsp;性能 6&nbsp;经验 7&nbsp;相关工作 8&nbsp;结束语 附录A、单词频率统计 原文下载链接：https://pan.baidu.com/s/1L9hclpiqQ-NVjmbqSz3mMQ&nbsp; 提取码：xhwn&nbsp; 摘要 MapReduce是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一个Map函数处理一个基于key/value pair的数据集合，输出中间的基于key/value pair的数据集合；然后再创建一个Reduce函数用来合并所有具有相同中间key值的中间value值。现实世界中有很多满足上述 处理模型的例子，本论文将详细描述这个模型。 MapReduce架构的程序能够在大量的配置普通的计算机上实现并行化处理。这个系统在运行时只关心：如何分割输入数据，在大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间必要的通信。采用MapReduce架构可以使那些没有并行计算和分布式处理系统开发经验的程序员有效利用分布式系统的丰富资源。 我们的MapReduce实现运行在规模可以灵活调整的由普通机器组成的集群上：一个典型的MapReduce计算往往由几千台机器组成、处理以TB计算的数据。程序员发现这个系统非常好用：已经实现了数以百计的MapReduce程序，在Google的集群上，每天都有1000多个MapReduce程序在执行。 &nbsp; 1&nbsp;介绍 在过去的5年里，包括本文作者在内的Google的很多程序员，为了处理海量的原始数据，已经实现了数以百计的、专用的计算方法。这些计算方法用来处理大量的原始数据，比如，文档抓取（类似网络爬虫的程序）、Web请求日志等；也为了计算处理各种类型的衍生数据，比如倒排索引、Web文档的图结构的各种表示形势、每台主机上网络爬虫抓取的页面数量的汇总、每天被请求的最多的查询的集合等。大多数这样的数据处理运算在概念上很容易理解。然而由于输入的数据量巨大，因此要想在可接受的时间内完成运算，只有将这些计算分布在成百上千的主机上。如何处理并行计算、如何分发数据、如何处理错误？所有这些问题综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。 为了解决上述复杂的问题，我们设计一个新的抽象模型，使用这个抽象模型，我们只要表述我们想要执行的简单运算即可，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，这些问题都被封装在一个库里面。设计这个抽象模型的灵感来自Lisp和许多其它函数式语言的Map和Reduce的原语。我们意识到我们大多数的运算都包含这样的操作：在输入数据的&quot;逻辑&quot;记录上应用Map操作得出一个中间key/value pair集合，然后在所有具有相同key值的value值上应用Reduce操作，从而达到合并中间的数据，得到一个想要的结果的目的。使用MapReduce模型，再结合用户实现的Map和Reduce函数，我们就可以非常容易的实现大规模并行化计算；通过MapReduce模型自带的&quot;再次执行&quot;功能，也提供了初级的容灾实现方案。 这个工作(实现一个MapReduce框架模型)的主要贡献是通过简单的接口来实现自动的、并行化和大规模的分布式计算，通过使用MapReduce模型接口实现在大量普通的PC机上高性能计算。 第二部分描述基本的编程模型和一些使用案例。第三部分描述了一个基于我们集群的计算环境所定制的MapReduce接口的实现。第四部分描述我们认为在MapReduce编程模型中一些实用的技巧。第五部分对于各种不同的任务，测量我们MapReduce实现的性能。第六部分揭示了在Google内部如何使用MapReduce作为基础重写我们的索引系统产品，包括其它一些使用MapReduce的经验。第七部分讨论相关的和未来的工作。 &nbsp; 2&nbsp;编程模型 MapReduce编程模型的原理是：利用一个输入key/value pair集合来产生一个输出的key/value pair集合。MapReduce库的用户用两个函数表达这个计算：Map和Reduce。 用户自定义的Map函数接受一个输入的key/value pair值，然后产生一个中间key/value pair值的集合(takes an input pair and produces a set of intermediate key/value pairs.)。MapReduce库把所有具有相同intermediate key值I的intermediate value值集合在一起后传递给Reduce函数。 用户自定义的Reduce函数接受一个中间key的值(假设此值为I)和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小的value值的集合。一般每次Reduce函数调用只产生0或1个输出的value值。通常，我们通过一个迭代器把中间value值提供给Reduce函数，这样我们就可以处理无法全部放入内存中的大量的value值的集合。 &nbsp; 2.1 例子 例如，计算一个大的文档集合中每个单词出现的次数，下面是伪代码段： map(String key, String value): // key: document name // value: document contents for each word w in value: EmitIntermediate(w, &quot;1&quot;); reduce(String key, Iterator values): // key: a word // values: a list of counts int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result)); Map函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是1)。Reduce函数把Map函数产生的每一个特定的词的计数累加起来。 另外，用户编写代码，使用输入和输出文件的名字、可选的调节参数来完成一个符合MapReduce模型规范的对象，然后调用MapReduce函数，并把这个规范对象传递给它。用户的代码和MapReduce库链接在一起(用C++实现)。附录A包含了这个实例的全部程序代码。 &nbsp; 2.2&nbsp;类型 尽管在前面例子的伪代码中使用了以字符串表示的输入输出值，但是在概念上，用户定义的Map和Reduce函数都有相关联的类型： map(k1,v1) -&gt;list(k2,v2) reduce(k2,list(v2)) -&gt;list(v2) 比如，输入的key和value值与输出的key和value值在类型上推导的域不同。此外，中间key和value值与输出key和value值在类型上推导的域相同。（注：参考Hadoop、KFS等实现，map和reduce都使用了泛型，因此，domain理解成类型推导的域）。我们的C++中使用字符串类型作为用户自定义函数的输入输出，用户在自己的代码中对字符串进行适当的类型转换。 &nbsp; 2.3&nbsp;更多的例子 这里还有一些有趣的简单例子，可以很容易的使用MapReduce模型来表示： 分布式的Grep：Map函数输出匹配某个模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。(Grep是Globally search a Regular Expression and Print的缩写，它是一种强大的文本搜索工具，能使用特定模式匹配（包括正则表达式）搜索文本，并默认输出匹配行。) 计算URL访问频率：Map函数处理日志中Web页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。(最好理解的一个例子) 倒转网络链接图：Map函数在源页面（source）中搜索所有的链接目标（target）并输出为(target,source)。Reduce函数把给定链接目标（target）的链接组合成一个列表，输出(target,list(source))。 每个主机的检索词向量：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。Map函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的URL。Reduce函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主机名,检索词向量)。 倒排索引：Map函数分析每个文档输出一个(词,文档号)的列表，Reduce函数的输入是一个给定词的所有（词，文档号），排序所有的文档号，输出(词,list（文档号）)。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。 分布式排序：Map函数从每个记录提取key，输出(key,record)。Reduce函数不改变任何的值。这个运算依赖分区机制(在4.1描述)和排序属性(在4.2描述)。 &nbsp; 3&nbsp;实现 MapReduce模型可以有多种不同的实现方式。如何正确选择取决于具体的环境。例如，一种实现方式适用于小型的共享内存方式的机器，另外一种实现方式则适用于大型NUMA架构的多处理器的主机，而有的实现方式更适合大型的网络连接集群。 本章节描述一个适用于Google内部广泛使用的运算环境的实现：用以太网交换机连接、由普通PC机组成的大型集群。在我们的环境里包括： 1.x86架构、运行Linux操作系统、双处理器、2-4GB内存的机器。 2.普通的网络硬件设备，每个机器的带宽为百兆或者千兆，但是远小于网络的平均带宽的一半。 3.集群中包含成百上千的机器，因此，机器故障是常态。 4.存储为廉价的内置IDE硬盘。一个内部分布式文件系统用来管理存储在这些磁盘上的数据。文件系统通过数据复制来在不可靠的硬件上保证数据的可靠性和有效性。 5.用户提交工作（job）给调度系统。每个工作（job）都包含一系列的任务（task），调度系统将这些任务调度到集群中多台可用的机器上。 &nbsp; 3.1&nbsp;执行概括 通过将Map调用的输入数据自动分割为M个数据片段的集合，Map调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使用分区函数将Map调用产生的中间key值分成R个不同分区（例如，hash(key) mod R），Reduce调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。 图1展示了我们的MapReduce实现中操作的全部流程。当用户调用MapReduce函数时，将发生下面的一系列动作（下面的序号和图1中的序号一一对应）： 1.用户程序首先调用的MapReduce库将输入文件分成M个数据片段，每个数据片段的大小一般从 16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在集群中创建大量的程序副本。 2.这些程序副本中的有一个特殊的程序——Master。副本中其它的程序都是worker程序，由Master分配任务。有M个Map任务和R个Reduce任务将被分配，Master将一个Map任务或Reduce任务分配给一个空闲的worker。 3.被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key/value&nbsp;pair，然后把key/value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key/value&nbsp;pair，并缓存在内存中。 4.缓存中的key/value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key/value pair在本地磁盘上的存储位置将被回传给Master，由Master负责把这些存储位置再传送给Reduce worker。 5.当Reduce worker程序接收到Master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。 6.Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。 7.当所有的Map和Reduce任务都完成之后，Master唤醒用户程序。在这个时候，在用户程序里对MapReduce的调用才返回。 在成功完成任务之后，MapReduce的输出存放在R个输出文件中（对应每个Reduce任务产生一个输出文件，文件名由用户指定）。一般情况下，用户不需要将这R个输出文件合并成一个文件——它们经常把这些文件作为另外一个MapReduce的输入，或者在另外一个可以处理多个分割文件的分布式应用中使用。 &nbsp; 3.2&nbsp;Master数据结构 Master持有一些数据结构，它存储每一个Map和Reduce任务的状态（空闲、工作中或完成)，以及Worker机器(非空闲任务的机器)的标识。 Master就像一个数据管道，中间文件存储区域的位置信息通过这个管道从Map传递到Reduce。因此，对于每个已经完成的Map任务，Master存储了Map任务产生的R个中间文件存储区域的大小和位置。当Map任务完成时，Master接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的Reduce任务。 &nbsp; 3.3&nbsp;容错 因为MapReduce库的设计初衷是使用由成百上千的机器组成的集群来处理超大规模的数据，所以，这个库必须要能很好的处理机器故障。 Worker故障 Master周期性的ping每个worker。如果在一个约定的时间范围内没有收到worker返回的信息，Master将把这个worker标记为失效。所有由这个失效的worker完成的Map任务被重置为初始的空闲状态，之后这些任务就可以被安排给其它的worker。同样的，worker失效时正在运行的Map或Reduce任务也将被重新置为空闲状态，等待重新调度。 当worker故障时，由于已经完成的Map任务的输出存储在本地，Map任务的输出已不可访问了，因此必须重新执行。而已经完成的Reduce任务的输出存储在全局文件系统上，因此不需要再次执行。 当一个Map任务首先被worker A执行，之后由于worker A失效了又被调度到worker B执行，这个&quot;重新执行&quot;的动作会被通知给所有执行Reduce任务的worker。任何还没有从worker A读取数据的Reduce任务将从worker B读取数据。 MapReduce可以处理大规模worker失效的情况。比如，在一个MapReduce操作执行期间，在正在运行的集群上进行网络维护引起80台机器在几分钟内不可访问了，MapReduce Master只需要简单的再次执行那些不可访问的worker完成的工作，之后继续执行未完成的任务，直到最终完成这个MapReduce操作。 &nbsp; Master失败 一个简单的解决办法是让Master周期性的将上面描述的数据结构的写入磁盘，即检查点（checkpoint）。如果这个Master任务失效了，可以从最后一个检查点（checkpoint）开始启动另一个Master进程。然而，由于只有一个Master进程，Master失效后再恢复是比较麻烦的，因此我们现在的实现是如果Master失效，就中止MapReduce运算。客户可以检查到这个状态，并且可以根据需要重新执行MapReduce操作。 &nbsp; 在失效方面的处理机制 当用户提供的Map和Reduce操作是输入确定性函数（即相同的输入产生相同的输出）时，我们的分布式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。 我们依赖对Map和Reduce任务的输出是原子提交的来完成这个特性。每个工作中的任务把它的输出写到私有的临时文件中。每个Reduce任务生成一个这样的文件，而每个Map任务则生成R个这样的文件（一个Reduce任务对应一个文件）。当一个Map任务完成的时，worker发送一个包含R个临时文件名的完成消息给Master。如果Master从一个已经完成的Map任务再次接收到到一个完成消息，Master将忽略这个消息；否则，Master将这R个文件的名字记录在数据结构里。 当Reduce任务完成时，Reduce worker进程以原子的方式把临时文件重命名为最终的输出文件。如果同一个Reduce任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名操作执行。我们依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个Reduce任务产生的数据。 使用MapReduce模型的程序员可以很容易的理解它们程序的行为，因为我们绝大多数的Map和Reduce操作是确定的，而且存在这样的一个事实：我们的失效处理机制等价于一个顺序的执行的操作。当Map和/或Reduce操作是不确定性的时候，我们提供虽然较弱但是依然合理的处理机制。当使用非确定操作的时候，一个Reduce任务R1的输出等价于一个非确定性程序的顺序执行产生的输出(In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output for R1 produced by a sequential execution of the non-deterministic program.)。但是，另一个不同的Reduce任务R2的输出也许符合一个非确定程序的非顺序执行产生的R2的输出(However, the output for a different reduce task R2 may correspond to the output for R2 produced by a different sequential execution of the non-deterministic program.)。 考虑Map任务M和Reduce任务R1、R2的情况。我们设定e(Ri)是Ri已经提交的执行过程（有且仅有一个这样的执行过程）。语义较弱是因为e（R1）可能读取了M的一次执行产生的输出，e（R2）可能读取了M的另一次执行产生的输出。 &nbsp; 3.4&nbsp;存储位置 在我们的计算运行环境中，网络带宽是一个相当匮乏的资源。我们通过尽量把输入数据(由GFS管理)存储在集群中机器的本地磁盘上来节省网络带宽。GFS把每个文件按64MB一个Block分割，每个Block保存在多台机器上，环境中存放了多份拷贝(一般是3个拷贝)。MapReduce的Master在调度Map任务时会考虑输入文件的位置信息，尽量将一个Map任务调度在包含相关输入数据拷贝的机器上执行；如果上述努力失败了，Master将尝试在保存有输入数据拷贝的机器附近的机器上执行Map任务(例如，分配到一个和包含输入数据的机器在一个switch里的worker机器上执行)。当在一个足够大的cluster集群上运行大型MapReduce操作的时候，大部分的输入数据都能从本地机器读取，因此消耗非常少的网络带宽。 &nbsp; 3.5&nbsp;任务粒度 我们将Map阶段细分为M个片段，Reduce阶段细分为R个片段，如上所述。理想情况下，M和R应该远大于worker机器的数量。让每个worker执行许多不同任务改善了动态负载平衡，并在worker失败时加快了恢复速度：它完成的许多映射任务可以分布在所有其它worker机器上。 在我们的实现中，M和R的大小有实际的界限，因为Master必须做出O（M+R）调度决策，并在内存中保持O（M*R）状态，如上文所述。（但是，内存使用的常量因素很小：状态的O（M*R）部分由每个映射任务/减少任务对大约1个字节的数据组成。）更进一步，R值通常是由用户指定的，因为每个Reduce任务最终都会生成一个独立的输出文件。实际使用时我们也倾向于选择合适的M值，以使得每一个独立任务都是处理大约16M到64M的输入数据（这样，上面描写的输入数据本地存储优化策略才最有效），另外，我们把R值设置为我们想使用的worker机器数量的几倍(small multiple)。我们通常会用这样的比例来执行MapReduce：M=200000，R=5000，使用2000台worker机器。 &nbsp; 3.6&nbsp;备用任务(Backup Tasks) 影响一个MapReduce的总执行时间最通常的因素是&quot;落伍者&quot;：在运算过程中，如果有一台机器花了很长的时间才完成最后几个Map或Reduce任务，导致MapReduce操作总的执行时间超过预期。出现&quot;落伍者&quot;的原因非常多。比如：如果一个机器的硬盘出了问题，在读取的时候要经常的进行读取纠错操作，导致读取数据的速度从30M/s降低到1M/s。如果cluster的调度系统在这台机器上又调度了其它的任务，由于CPU、内存、本地硬盘和网络带宽等竞争因素的存在，导致执行MapReduce代码的执行效率更加缓慢。我们最近遇到的一个问题是由于机器的初始化代码有bug，导致关闭了的处理器的缓存：在这些机器上执行任务的性能和正常情况相差上百倍。 我们有一个通用的机制来减少&quot;落伍者&quot;出现的情况。当一个MapReduce操作接近完成的时候，Master调度备用（backup）任务进程来执行剩下的、处于运行中状态（in-progress）的任务。无论是最初的执行进程、还是备用（backup）任务进程完成了任务，我们都把这个任务标记成为已经完成。我们调优了这个机制，通常只会占用比正常操作多几个百分点的计算资源。我们发现采用这样的机制对于减少超大MapReduce操作的总处理时间效果显著。例如，在5.3节描述的排序任务，在关闭掉备用任务的情况下要多花44%的时间完成排序任务。 &nbsp; 4&nbsp;技巧 虽然简单的Map和Reduce函数提供的基本功能已经能够满足大部分的计算需要，我们还是发掘出了一些有价值的扩展功能。本节将描述这些扩展功能。 &nbsp; 4.1&nbsp;分区函数&nbsp;&nbsp; MapReduce的使用者通常会指定Reduce任务和Reduce任务输出文件的数量（R）。我们在中间key上使用分区函数来对数据进行分区，之后再输入到后续任务执行进程。一个缺省的分区函数是使用hash方法(比如，hash(key) mod R)进行分区。hash方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对key值进行的分区将非常有用。比如，输出的key值是URLs，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce库的使用者需要提供专门的分区函数。例如，使用&quot;hash(Hostname(urlkey)) mod R&quot;作为分区函数就可以把所有来自同一个主机的URLs保存在同一个输出文件中。 &nbsp; 4.2&nbsp;顺序保证 我们确保在给定的分区中，中间key/value pair数据的处理顺序是按照key值增量顺序处理的。这样的顺序保证对每个分区生成一个有序的输出文件，这对于需要对输出文件按key值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。 &nbsp; 4.3&nbsp;Combiner函数 在某些情况下，Map函数产生的中间key值的重复数据会占很大的比重，并且，用户自定义的Reduce函数满足结合律和交换律。在2.1节的词数统计程序是个很好的例子。由于词频率倾向于一个zipf分布(齐夫分布)，每个Map任务将产生成千上万个这样的记录&lt;the,1&gt;。所有的这些记录将通过网络被发送到一个单独的Reduce任务，然后由这个Reduce任务把所有这些记录累加起来产生一个数字。我们允许用户指定一个可选的Combiner函数，Combiner函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。 Combiner函数在每台执行Map任务的机器上都会被执行一次。一般情况下，Combiner和Reduce函数是一样的。Combiner函数和Reduce函数之间唯一的区别是MapReduce库怎样控制函数的输出。Reduce函数的输出被保存在最终的输出文件里，而Combiner函数的输出被写到中间文件里，然后被发送给Reduce任务。 合并中间结果可以显著的提高一些MapReduce操作的速度。附录A包含一个使用Combiner函数的例子。 &nbsp; 4.4&nbsp;输入和输出的类型 MapReduce库支持几种不同格式的输入数据。比如，文本模式的输入数据的每一行被视为是一个key/value pair。key是文件的偏移量，value是那一行的内容。另外一种常见的格式是以key进行排序来存储的key/value pair的序列。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单独的Map任务来进行后续处理(例如，文本模式的范围分割必须确保仅仅在每行的边界进行范围分割)。虽然大多数MapReduce的使用者仅仅使用很少的预定义输入类型就满足要求了，但是使用者依然可以通过提供一个简单的Reader接口就能够支持一个新的输入类型。 Reader并非一定要从文件中读取数据，比如，我们可以很容易的实现一个从数据库里读记录的Reader，或者从内存中的数据结构读取数据的Reader。 类似的，我们提供了一些预定义的输出数据类型，通过这些预定义类型能够产生不同格式的数据。用户采用类似添加新的输入数据类型的方式增加新的输出类型。 &nbsp; 4.5&nbsp;副作用 在某些情况下，MapReduce的使用者发现，如果在Map和/或Reduce操作(map and/or reduce operators.)过程中增加辅助的输出文件会比较省事。我们依靠程序writer把这种&quot;副作用&quot;变成原子的以及幂等的。通常应用程序首先把输出结果写到一个临时文件中，在输出全部数据之后，在使用系统级的原子操作rename重新命名这个临时文件。 我们不支持由单个任务生成的多个输出文件的原子两阶段提交，因此，生成具有跨文件一致性要求的多个输出文件的任务应该是确定性的。这种限制在实践中从未成为一个问题。 &nbsp; 4.6&nbsp;跳过损坏的记录 有时候，用户程序中的bug导致Map或者Reduce函数在处理某些记录的时候crash掉，MapReduce操作无法顺利完成。惯常的做法是修复bug后再次执行MapReduce操作，但是，有时候找出这些bug并修复它们不是一件容易的事情；这些bug也许是在第三方库里，而我们手头没有这些库的源代码。而且在很多时候，忽略一些有问题的记录也是可以接受的，比如在一个巨大的数据集上进行统计分析的时候。我们提供了一种可选的执行模式，其中MapReduce库检测哪些记录会导致确定性crash，并跳过这些记录以向前推进。 每个worker进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus&nbsp;error）。在执行Map或者Reduce操作之前，MapReduce库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，消息处理函数将用&quot;最后一口气&quot;通过UDP包向Master发送处理的最后一条记录的序号。当Master看到在处理某条特定记录不止失败一次时，Master就标志这条记录需要被跳过，并且在下次重新执行相关的Map或者Reduce任务的时候跳过这条记录。 &nbsp; 4.7&nbsp;本地执行 调试Map和Reduce函数的bug是非常困难的，因为实际执行操作时不但是分布在系统中执行的，而且通常是在好几千台计算机上执行，具体的执行位置是由Master进行动态调度的，这又大大增加了调试的难度。为了简化调试、性能分析和小规模测试，我们开发了一套MapReduce库的本地实现版本，通过使用本地版本的MapReduce库，MapReduce操作在本地计算机上顺序执行。用户可以控制MapReduce操作的执行，可以把操作限制到特定的Map任务上。用户通过设定特别的标志来在本地执行它们的程序，之后就可以很容易的使用本地调试和测试工具（比如gdb）。 &nbsp; 4.8&nbsp;状态信息 主服务器运行内部HTTP服务器并导出一组状态页供人使用。状态页显示计算的进度，例如已完成的任务数、正在进行的任务数、输入字节数、中间数据字节数、输出字节数、处理速率等。这些页还包含指向每个任务生成的标准错误和标准输出文件的链接。用户可以使用这些数据来预测计算将花费多长时间，以及是否应向计算中添加更多的资源。这些页面还可用于确定计算速度比预期慢得多的时间。 此外，顶级状态页面显示哪些worker失败，以及哪些失效的时候正在运行的Map和Reduce任务。当试图调试用户代码中的错误时，此信息非常有用。 &nbsp; 4.9&nbsp;计数器 MapReduce库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇German文档等等。 为了使用这个特性，用户在程序中创建一个命名的计数器对象，在Map和Reduce函数中相应的增加计数器的值。例如： Counter* uppercase; uppercase = GetCounter(&quot;uppercase&quot;); map(String name, String contents): for each word w in contents: if (IsCapitalized(w)): uppercase-&gt;Increment(); EmitIntermediate(w, &quot;1&quot;); 这些计数器的值周期性的从各个单独的worker机器上传递给Master（附加在ping的应答包中传递）。Master把执行成功的Map和Reduce任务的计数器值进行累计，当MapReduce操作完成之后，返回给用户代码。 计数器当前的值也会显示在Master的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器的值的时候，Master要检查重复运行的Map或者Reduce任务，避免重复累加（之前提到的备用任务和失效后重新执行任务这两种情况会导致相同的任务被多次执行）。有些计数器的值是由MapReduce库自动维持的，比如已经处理的输入的key/value pair的数量、输出的key/value pair的数量等等。 计数器机制对于MapReduce操作的完整性检查非常有用。比如，在某些MapReduce操作中，用户需要确保产生的output pairs精确的等于处理的input pairs，或者处理的German文档数量在被处理的整个文档数量中属于合理范围。 &nbsp; 5&nbsp;性能 本节我们分析在一个大型集群上运行的两个计算来衡量MapReduce的性能。一个计算是在大约1TB的数据中进行特定的模式匹配，另一个计算对大约1TB的数据进行排序。 这两个程序在大量使用的MapReduce应用中是非常具有代表性的——一类是对数据格式进行转换，从一种表现形式转换为另外一种表现形式；另一类是从海量数据中抽取少部分用户感兴趣的数据。 &nbsp; 5.1&nbsp;集群配置 所有这些程序都运行在一个由大约1800台机器构成的集群上。每台机器配置2个2G主频、支持超线程的Intel Xeon处理器，4GB的物理内存，两个160GB的IDE硬盘和一个千兆以太网卡。这些机器部署在一个两层的树形交换网络中，在root节点大概有100-200GBPS的传输带宽。所有这些机器都采用相同的部署（对等部署），因此任意两点之间的网络往返时延小于1毫秒。 在4GB内存里，大概有1-1.5G用于运行集群上的其它任务。测试程序在周末下午开始执行，这时主机的CPU、磁盘和网络基本上处于空闲状态。 &nbsp; 5.2&nbsp;Grep(一种强大的文本搜索工具) 这个分布式的Grep程序需要扫描大概10的10次方个由100个字节组成的记录，查找出现概率较小的3个字符的模式（这个模式在92337个记录中出现）。输入数据被拆分成大约64M的Block（M=15000），整个输出数据存放在一个文件中（R=1）。 图2显示了这个运算随时间的处理过程。其中Y轴表示输入数据的处理速度。处理速度随着参与MapReduce计算的机器数量的增加而增加，当1764台worker参与计算的时，处理速度达到了30GB/s。当Map任务结束的时候，即在计算开始后80秒，输入的处理速度降到0。整个计算过程从开始到结束一共花了大概150秒。这包括了大约一分钟的初始启动阶段。初始启动阶段消耗的时间包括了把这个程序传送到各个worker机器上的时间、等待GFS文件系统打开1000个输入文件集合的时间、获取相关的文件本地位置优化信息的时间。 &nbsp; 5.3&nbsp;排序 排序程序处理10的10次方个100个字节组成的记录（大约1TB的数据）。这个程序模仿TeraSort&nbsp;benchmark。 排序程序由不到50行代码组成。只有三行的Map函数从文本行中解析出10个字节的key值作为排序的key，并且把这个key和原始文本行作为中间的key/value pair值输出。我们使用了一个内置的恒等函数(Identity function)作为Reduce操作函数，这个函数把中间key/value pair不作任何改变输出。最终排序的输出被写入一组双路复制的GFS文件中（也就是说，程序输出2TB的数据）。 如前所述，输入数据被分成64MB的Block（M=15000）。我们把排序后的输出结果分区后存储到4000个文件（R=4000）。分区函数使用key的原始字节来把数据分区到R个片段中。 在这个benchmark测试中，我们使用的分区函数知道key的分区情况。通常对于排序程序来说，我们会增加一个预处理的MapReduce操作用于采样key值的分布情况，通过采样的数据来计算对最终排序处理的分区点。(从上到下分别是Input、Shuffle和Output) 图三（a）显示了这个排序程序的正常执行过程。左上的图显示了Input数据读取的速度。数据读取速度峰值会达到13GB/s，并且所有Map任务在大约200秒之前完成，然后迅速滑落至0。值得注意的是，排序程序输入数据读取速度小于分布式Grep程序。这是因为排序程序的Map任务花了大约一半的处理时间和I/O带宽把中间输出结果写到本地硬盘。相应的分布式Grep程序的中间结果输出几乎可以忽略不计。 左边中间的图显示了中间数据从Map任务发送到Reduce任务的网络速度。这个过程从第一个Map任务完成之后就开始缓慢启动(shuffling)了。图示的第一个高峰是启动了第一批约1700个Reduce任务（整个MapReduce分布到大概1700台机器上，每台机器1次最多执行1个Reduce任务）。排序程序运行大约300秒后，第一批启动的Reduce任务只有部分完成，我们开始执行剩下的Reduce任务。所有的处理在大约600秒后结束。 左下图表示Reduce任务把排序后的数据写到最终的输出文件的速度。在第一个shuffling阶段结束和数据开始写入磁盘之间有延时，这是因为worker机器正在忙于排序中间数据。磁盘写入速度在2-4GB/s持续一段时间。输出数据写入磁盘大约持续850秒。计入初始启动部分的时间，整个运算消耗了891秒。这个速度和TeraSort benchmark的最高纪录1057秒相差不多。 需要注意的一点是：由于我们的本地化输入数据优化策略，Input速率高于Shuffle速率和Output速率——大多数数据是从本地磁盘读取的，并绕过我们相对受限的网络带宽。Shuffle速率高于Output速率，因为输出阶段会写入两份已排序数据的副本（我们写两份输出的副本的原因是为了可靠性和可用性）。我们编写两个副本，因为这是底层文件系统提供的可靠性和可用性机制。如果底层文件系统使用纠删码(erasure coding)而不是复制，则写入数据的网络带宽需求将减少。 &nbsp; 5.4&nbsp;高效的backup任务 图三（b）展示关闭备用任务后排序程序执行情况。执行的过程和图3（a）很相似，除了有一条非常长的尾巴，几乎没有任何写操作发生。在960秒后，只有5个Reduce任务没有完成。这些拖后腿的任务又执行了300秒才完成。整个计算消耗了1283秒，多了44%的执行时间。 &nbsp; 5.5&nbsp;失效的机器 在图三（c）演示在排序程序执行的过程中，我们在程序开始后几分钟有意的kill了1746个worker中的200个。集群底层的调度立刻在这些机器上重新开始新的worker处理进程（因为只是worker机器上的处理进程被kill了，机器本身还在工作）。 图三（c）显示出了一个&quot;负&quot;的输入数据读取速度，这是因为一些已经完成的Map任务丢失了（由于相应的执行Map任务的worker进程被kill了），需要重新执行这些任务。相关Map任务很快就被重新执行了。整个运算在933秒内完成，包括了初始启动时间（只比正常执行多消耗了5%的时间）。 &nbsp; 6&nbsp;经验 我们在2003年1月完成了第一个版本的MapReduce库，2003年8月的版本有了显著的增强，这包括了输入数据本地优化、worker机器之间的动态负载均衡等等。从那以后，我们惊喜的发现，MapReduce库能广泛应用于我们日常工作中遇到的各类问题。它现在在Google内部各个领域得到广泛应用，包括： 大规模机器学习问题 Google News和Froogle产品的集群问题 从公众查询产品（比如Google的Zeitgeist）的报告中抽取数据。 从大量的新应用和新产品的网页中提取有用信息（比如，从大量的位置搜索网页中抽取地理位置信息）。 大规模的图形计算。 图四显示了在我们的源代码管理系统中，随着时间推移，独立的MapReduce程序数量的显著增加。从2003年早些时候的0个增长到2004年9月份的差不多900个不同的程序。MapReduce的成功取决于采用MapReduce库能够在不到半个小时内写出一个简单的程序，这个简单的程序能够在上千台机器组成的集群上做大规模并行处理，这极大的加快了开发和原形设计(prototyping cycle)的周期。另外，采用MapReduce库，可以让完全没有分布式和/或并行系统开发经验的程序员很容易的利用大量的资源，开发出分布式和/或并行处理的应用。 在每个任务结束的时候，MapReduce库统计计算资源的使用状况。在表1，我们列出了2004年8月份MapReduce运行的任务所占用的相关资源。 &nbsp; 6.1&nbsp;大规模索引 到目前为止，MapReduce最成功的应用就是重写了Google网络搜索服务所使用到的index系统。索引系统的输入数据是网络爬虫抓取回来的海量的文档，这些文档数据都保存在GFS文件系统里。这些文档的原始内容的大小超过了20TB。索引程序是通过一系列的MapReduce操作（大约5到10次）来建立索引。使用MapReduce（替换上一个特别设计的、分布式处理的索引程序）带来这些好处： 实现索引部分的代码简单、小巧、容易理解，因为对于容错、分布式以及并行计算的处理都是MapReduce库提供的。比如，使用MapReduce库，计算的代码行数从原来的3800行C++代码减少到大约700行代码。 MapReduce库的性能已经足够好了，因此我们可以把在概念上不相关的计算步骤分开处理，而不是混在一起以减少数据传递的额外消耗。概念上不相关的计算步骤的隔离也使得我们可以很容易改变索引处理方式。比如，对之前的索引系统的一个小更改可能要耗费好几个月的时间，但是在使用MapReduce的新系统上，这样的更改只需要花几天时间就可以了。 索引系统的操作管理更容易了。因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝大部分问题都已经由MapReduce库解决了，不再需要操作人员的介入。另外，我们可以通过在索引系统集群中增加机器的简单方法提高整体处理性能。 &nbsp; 7&nbsp;相关工作 很多系统都提供了严格的编程模式，并且通过对编程的严格限制来实现并行计算。例如，一个结合函数可以通过把N个元素的数组的前缀在N个处理器上使用并行前缀算法，在log N的时间内计算完。根据我们对大型实际环境计算的经验，可以将MapReduce视为对其中一些模型的简化和提炼。(MapReduce can be considered a simplification and distillation of some of these models based on our experience with large real-world computations.)。更加值得骄傲的是，我们还实现了基于上千台处理器的集群的容错处理。相比而言，大部分并发处理系统都只在小规模的集群上实现，并且把容错处理交给了程序员。 Bulk Synchronous Programming和一些MPI原语提供了更高级别的并行处理抽象，可以更容易的写出并行处理的程序。MapReduce和这些系统的主要不同之处在于，MapReduce利用限制性编程模式实现了用户程序的自动并发处理，并且提供了透明的容错处理。 我们数据本地优化策略的灵感来源于active disks等技术，在active disks中，计算任务是尽量推送到数据所存储的节点处理，这样就减少了网络和IO子系统的吞吐量。我们在挂载几个硬盘的普通机器上执行我们的运算，而不是在磁盘处理器上执行我们的工作，但是达到的目的一样的。 我们的备用任务机制和Charlotte System提出的eager调度机制比较类似。Eager调度机制的一个缺点是如果一个任务反复失效，那么整个计算就不能完成。我们通过忽略引起故障的记录的方式在某种程度上解决了这个问题。 MapReduce的实现依赖于一个内部的集群管理系统，这个集群管理系统负责在一个超大的、共享机器的集群上分布和运行用户任务。虽然这个不是本论文的重点，但是有必要提一下，这个集群管理系统在理念上和其它系统，如Condor是一样。 MapReduce库的排序机制和NOW-Sort的操作很类似。读取输入源的机器（map workers）把待排序的数据进行分区后，发送到R个Reduce worker中的一个进行处理。每个Reduce worker在本地对数据进行排序（尽可能在内存中排序）。当然，NOW-Sort没有给用户自定义的Map和Reduce函数的机会，因此不具备MapReduce库广泛的实用性。River提供了一个编程模型：处理进程通过分布式队列传送数据的方式进行互相通讯。和MapReduce类似，River系统尝试在不对等的硬件环境下，或者在系统颠簸的情况下也能提供近似平均的性能。River是通过精心调度硬盘和网络的通讯来平衡任务的完成时间。MapReduce库采用了其它的方法。通过对编程模型进行限制，MapReduce框架把问题分解成为大量的&quot;小&quot;任务。这些任务在可用的worker集群上动态的调度，这样更快的worker就可以执行更多的任务。通过对编程模型进行限制，我们可在工作接近完成的时候调度备用任务，在硬件配置不均衡的情况下减少完成的时间（比如有的worker慢、或者worker被某些操作阻塞了）。 BAD-FS采用了和MapReduce完全不同的编程模式，它是面向广域网的。不过，这两个系统有两个基础功能很类似。（1）两个系统采用重新执行的方式来防止由于失效导致的数据丢失。（2）两个都使用数据本地化调度策略，减少网络通讯的数据量。 TACC是一个高可用网络服务的简化构造系统。和MapReduce一样，它也依靠重新执行机制来实现容错处理。 &nbsp; 8&nbsp;结束语 MapReduce编程模型在Google内部成功应用于多个领域。我们把这种成功归结为几个方面：首先，这种编程模式使得MapReduce库易于使用，即便对于完全没有并行或者分布式系统开发经验的程序员而言也很容易。这是因为MapReduce封装了并行处理、容错处理、数据本地化优化、负载均衡等等技术难点的细节；其次，大量不同类型的问题都可以通过MapReduce简单的解决。比如，MapReduce用于生成Google的网络搜索服务所需要的数据、用来排序、用来数据挖掘、用于机器学习，以及很多其它的系统；第三，我们实现了一个在数千台计算机组成的大型集群上灵活部署并运行的MapReduce。这个实现使得有效利用这些丰富的计算资源变得非常简单，因此也适合用于解决Google遇到的其它很多需要大量计算的问题。 我们也从MapReduce开发过程中学到了不少东西。首先，限制性编程模式使得并行和分布式计算非常容易，也易于构造容错的计算环境；其次，网络带宽是稀有资源。大量的系统优化以针对减少网络传输量为目的：本地优化策略使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节约了网络带宽；第三，多次执行相同的任务可以减少性能缓慢的机器带来的负面影响，同时解决了由于机器失效导致的数据丢失问题。 &nbsp; 附录A、单词频率统计 本节包含了一个完整的程序，用于统计在一组命令行指定的输入文件中，每一个不同的单词出现频率。 #include &quot;mapreduce/mapreduce.h&quot; // User’s map function class WordCounter : public Mapper { public: virtual void Map(const MapInput&amp; input) { const string&amp; text = input.value(); const int n = text.size(); for (int i = 0; i &lt; n; ) { // Skip past leading whitespace while((i &lt; n) &amp;&amp; isspace(text[i])) i++; // Find word end int start = i; while ((i &lt; n) &amp;&amp; !isspace(text[i])) i++; if (start &lt; i) Emit(text.substr(start,i-start),&quot;1&quot;); } } }; REGISTER_MAPPER(WordCounter); // User’s reduce function class Adder : public Reducer { virtual void Reduce(ReduceInput* input) { // Iterate over all entries with the // same key and add the values int64 value = 0; while (!input-&gt;done()) { value += StringToInt(input-&gt;value()); input-&gt;NextValue(); } // Emit sum for input-&gt;key() Emit(IntToString(value)); } }; REGISTER_REDUCER(Adder); int main(int argc, char** argv) { ParseCommandLineFlags(argc, argv); MapReduceSpecification spec; // Store list of input fifiles into &quot;spec&quot; for (int i = 1; i &lt; argc; i++) { MapReduceInput* input = spec.add_input(); input-&gt;set_format(&quot;text&quot;); input-&gt;set_filepattern(argv[i]); input-&gt;set_mapper_class(&quot;WordCounter&quot;); } // Specify the output files: // /gfs/test/freq-00000-of-00100 // /gfs/test/freq-00001-of-00100 // … MapReduceOutput* out = spec.output(); out-&gt;set_fifilebase(&quot;/gfs/test/freq&quot;); out-&gt;set_num_tasks(100); out-&gt;set_format(&quot;text&quot;); out-&gt;set_reducer_class(&quot;Adder&quot;); // Optional: do partial sums within map // tasks to save network bandwidth out-&gt;set_combiner_class(&quot;Adder&quot;); //Tuning parameters: use at most 2000 //machines and 100 MB of memory per task spec.set_machines(2000); spec.set_map_megabytes(100); spec.set_reduce_megabytes(100); //Now run it MapReduceResult result; if (!MapReduce(spec, &amp;result)) abort(); // Done: ‘result’ structure contains info // about counters, time taken, number of // machines used, etc. return 0; } &nbsp;" />
<link rel="canonical" href="https://mlh.app/2019/05/12/787059.html" />
<meta property="og:url" content="https://mlh.app/2019/05/12/787059.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-12T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"目录 1&nbsp;介绍 2&nbsp;编程模型 3&nbsp;实现 4&nbsp;技巧 5&nbsp;性能 6&nbsp;经验 7&nbsp;相关工作 8&nbsp;结束语 附录A、单词频率统计 原文下载链接：https://pan.baidu.com/s/1L9hclpiqQ-NVjmbqSz3mMQ&nbsp; 提取码：xhwn&nbsp; 摘要 MapReduce是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一个Map函数处理一个基于key/value pair的数据集合，输出中间的基于key/value pair的数据集合；然后再创建一个Reduce函数用来合并所有具有相同中间key值的中间value值。现实世界中有很多满足上述 处理模型的例子，本论文将详细描述这个模型。 MapReduce架构的程序能够在大量的配置普通的计算机上实现并行化处理。这个系统在运行时只关心：如何分割输入数据，在大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间必要的通信。采用MapReduce架构可以使那些没有并行计算和分布式处理系统开发经验的程序员有效利用分布式系统的丰富资源。 我们的MapReduce实现运行在规模可以灵活调整的由普通机器组成的集群上：一个典型的MapReduce计算往往由几千台机器组成、处理以TB计算的数据。程序员发现这个系统非常好用：已经实现了数以百计的MapReduce程序，在Google的集群上，每天都有1000多个MapReduce程序在执行。 &nbsp; 1&nbsp;介绍 在过去的5年里，包括本文作者在内的Google的很多程序员，为了处理海量的原始数据，已经实现了数以百计的、专用的计算方法。这些计算方法用来处理大量的原始数据，比如，文档抓取（类似网络爬虫的程序）、Web请求日志等；也为了计算处理各种类型的衍生数据，比如倒排索引、Web文档的图结构的各种表示形势、每台主机上网络爬虫抓取的页面数量的汇总、每天被请求的最多的查询的集合等。大多数这样的数据处理运算在概念上很容易理解。然而由于输入的数据量巨大，因此要想在可接受的时间内完成运算，只有将这些计算分布在成百上千的主机上。如何处理并行计算、如何分发数据、如何处理错误？所有这些问题综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。 为了解决上述复杂的问题，我们设计一个新的抽象模型，使用这个抽象模型，我们只要表述我们想要执行的简单运算即可，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，这些问题都被封装在一个库里面。设计这个抽象模型的灵感来自Lisp和许多其它函数式语言的Map和Reduce的原语。我们意识到我们大多数的运算都包含这样的操作：在输入数据的&quot;逻辑&quot;记录上应用Map操作得出一个中间key/value pair集合，然后在所有具有相同key值的value值上应用Reduce操作，从而达到合并中间的数据，得到一个想要的结果的目的。使用MapReduce模型，再结合用户实现的Map和Reduce函数，我们就可以非常容易的实现大规模并行化计算；通过MapReduce模型自带的&quot;再次执行&quot;功能，也提供了初级的容灾实现方案。 这个工作(实现一个MapReduce框架模型)的主要贡献是通过简单的接口来实现自动的、并行化和大规模的分布式计算，通过使用MapReduce模型接口实现在大量普通的PC机上高性能计算。 第二部分描述基本的编程模型和一些使用案例。第三部分描述了一个基于我们集群的计算环境所定制的MapReduce接口的实现。第四部分描述我们认为在MapReduce编程模型中一些实用的技巧。第五部分对于各种不同的任务，测量我们MapReduce实现的性能。第六部分揭示了在Google内部如何使用MapReduce作为基础重写我们的索引系统产品，包括其它一些使用MapReduce的经验。第七部分讨论相关的和未来的工作。 &nbsp; 2&nbsp;编程模型 MapReduce编程模型的原理是：利用一个输入key/value pair集合来产生一个输出的key/value pair集合。MapReduce库的用户用两个函数表达这个计算：Map和Reduce。 用户自定义的Map函数接受一个输入的key/value pair值，然后产生一个中间key/value pair值的集合(takes an input pair and produces a set of intermediate key/value pairs.)。MapReduce库把所有具有相同intermediate key值I的intermediate value值集合在一起后传递给Reduce函数。 用户自定义的Reduce函数接受一个中间key的值(假设此值为I)和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小的value值的集合。一般每次Reduce函数调用只产生0或1个输出的value值。通常，我们通过一个迭代器把中间value值提供给Reduce函数，这样我们就可以处理无法全部放入内存中的大量的value值的集合。 &nbsp; 2.1 例子 例如，计算一个大的文档集合中每个单词出现的次数，下面是伪代码段： map(String key, String value): // key: document name // value: document contents for each word w in value: EmitIntermediate(w, &quot;1&quot;); reduce(String key, Iterator values): // key: a word // values: a list of counts int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result)); Map函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是1)。Reduce函数把Map函数产生的每一个特定的词的计数累加起来。 另外，用户编写代码，使用输入和输出文件的名字、可选的调节参数来完成一个符合MapReduce模型规范的对象，然后调用MapReduce函数，并把这个规范对象传递给它。用户的代码和MapReduce库链接在一起(用C++实现)。附录A包含了这个实例的全部程序代码。 &nbsp; 2.2&nbsp;类型 尽管在前面例子的伪代码中使用了以字符串表示的输入输出值，但是在概念上，用户定义的Map和Reduce函数都有相关联的类型： map(k1,v1) -&gt;list(k2,v2) reduce(k2,list(v2)) -&gt;list(v2) 比如，输入的key和value值与输出的key和value值在类型上推导的域不同。此外，中间key和value值与输出key和value值在类型上推导的域相同。（注：参考Hadoop、KFS等实现，map和reduce都使用了泛型，因此，domain理解成类型推导的域）。我们的C++中使用字符串类型作为用户自定义函数的输入输出，用户在自己的代码中对字符串进行适当的类型转换。 &nbsp; 2.3&nbsp;更多的例子 这里还有一些有趣的简单例子，可以很容易的使用MapReduce模型来表示： 分布式的Grep：Map函数输出匹配某个模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。(Grep是Globally search a Regular Expression and Print的缩写，它是一种强大的文本搜索工具，能使用特定模式匹配（包括正则表达式）搜索文本，并默认输出匹配行。) 计算URL访问频率：Map函数处理日志中Web页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。(最好理解的一个例子) 倒转网络链接图：Map函数在源页面（source）中搜索所有的链接目标（target）并输出为(target,source)。Reduce函数把给定链接目标（target）的链接组合成一个列表，输出(target,list(source))。 每个主机的检索词向量：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。Map函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的URL。Reduce函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主机名,检索词向量)。 倒排索引：Map函数分析每个文档输出一个(词,文档号)的列表，Reduce函数的输入是一个给定词的所有（词，文档号），排序所有的文档号，输出(词,list（文档号）)。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。 分布式排序：Map函数从每个记录提取key，输出(key,record)。Reduce函数不改变任何的值。这个运算依赖分区机制(在4.1描述)和排序属性(在4.2描述)。 &nbsp; 3&nbsp;实现 MapReduce模型可以有多种不同的实现方式。如何正确选择取决于具体的环境。例如，一种实现方式适用于小型的共享内存方式的机器，另外一种实现方式则适用于大型NUMA架构的多处理器的主机，而有的实现方式更适合大型的网络连接集群。 本章节描述一个适用于Google内部广泛使用的运算环境的实现：用以太网交换机连接、由普通PC机组成的大型集群。在我们的环境里包括： 1.x86架构、运行Linux操作系统、双处理器、2-4GB内存的机器。 2.普通的网络硬件设备，每个机器的带宽为百兆或者千兆，但是远小于网络的平均带宽的一半。 3.集群中包含成百上千的机器，因此，机器故障是常态。 4.存储为廉价的内置IDE硬盘。一个内部分布式文件系统用来管理存储在这些磁盘上的数据。文件系统通过数据复制来在不可靠的硬件上保证数据的可靠性和有效性。 5.用户提交工作（job）给调度系统。每个工作（job）都包含一系列的任务（task），调度系统将这些任务调度到集群中多台可用的机器上。 &nbsp; 3.1&nbsp;执行概括 通过将Map调用的输入数据自动分割为M个数据片段的集合，Map调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使用分区函数将Map调用产生的中间key值分成R个不同分区（例如，hash(key) mod R），Reduce调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。 图1展示了我们的MapReduce实现中操作的全部流程。当用户调用MapReduce函数时，将发生下面的一系列动作（下面的序号和图1中的序号一一对应）： 1.用户程序首先调用的MapReduce库将输入文件分成M个数据片段，每个数据片段的大小一般从 16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在集群中创建大量的程序副本。 2.这些程序副本中的有一个特殊的程序——Master。副本中其它的程序都是worker程序，由Master分配任务。有M个Map任务和R个Reduce任务将被分配，Master将一个Map任务或Reduce任务分配给一个空闲的worker。 3.被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key/value&nbsp;pair，然后把key/value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key/value&nbsp;pair，并缓存在内存中。 4.缓存中的key/value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key/value pair在本地磁盘上的存储位置将被回传给Master，由Master负责把这些存储位置再传送给Reduce worker。 5.当Reduce worker程序接收到Master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。 6.Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。 7.当所有的Map和Reduce任务都完成之后，Master唤醒用户程序。在这个时候，在用户程序里对MapReduce的调用才返回。 在成功完成任务之后，MapReduce的输出存放在R个输出文件中（对应每个Reduce任务产生一个输出文件，文件名由用户指定）。一般情况下，用户不需要将这R个输出文件合并成一个文件——它们经常把这些文件作为另外一个MapReduce的输入，或者在另外一个可以处理多个分割文件的分布式应用中使用。 &nbsp; 3.2&nbsp;Master数据结构 Master持有一些数据结构，它存储每一个Map和Reduce任务的状态（空闲、工作中或完成)，以及Worker机器(非空闲任务的机器)的标识。 Master就像一个数据管道，中间文件存储区域的位置信息通过这个管道从Map传递到Reduce。因此，对于每个已经完成的Map任务，Master存储了Map任务产生的R个中间文件存储区域的大小和位置。当Map任务完成时，Master接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的Reduce任务。 &nbsp; 3.3&nbsp;容错 因为MapReduce库的设计初衷是使用由成百上千的机器组成的集群来处理超大规模的数据，所以，这个库必须要能很好的处理机器故障。 Worker故障 Master周期性的ping每个worker。如果在一个约定的时间范围内没有收到worker返回的信息，Master将把这个worker标记为失效。所有由这个失效的worker完成的Map任务被重置为初始的空闲状态，之后这些任务就可以被安排给其它的worker。同样的，worker失效时正在运行的Map或Reduce任务也将被重新置为空闲状态，等待重新调度。 当worker故障时，由于已经完成的Map任务的输出存储在本地，Map任务的输出已不可访问了，因此必须重新执行。而已经完成的Reduce任务的输出存储在全局文件系统上，因此不需要再次执行。 当一个Map任务首先被worker A执行，之后由于worker A失效了又被调度到worker B执行，这个&quot;重新执行&quot;的动作会被通知给所有执行Reduce任务的worker。任何还没有从worker A读取数据的Reduce任务将从worker B读取数据。 MapReduce可以处理大规模worker失效的情况。比如，在一个MapReduce操作执行期间，在正在运行的集群上进行网络维护引起80台机器在几分钟内不可访问了，MapReduce Master只需要简单的再次执行那些不可访问的worker完成的工作，之后继续执行未完成的任务，直到最终完成这个MapReduce操作。 &nbsp; Master失败 一个简单的解决办法是让Master周期性的将上面描述的数据结构的写入磁盘，即检查点（checkpoint）。如果这个Master任务失效了，可以从最后一个检查点（checkpoint）开始启动另一个Master进程。然而，由于只有一个Master进程，Master失效后再恢复是比较麻烦的，因此我们现在的实现是如果Master失效，就中止MapReduce运算。客户可以检查到这个状态，并且可以根据需要重新执行MapReduce操作。 &nbsp; 在失效方面的处理机制 当用户提供的Map和Reduce操作是输入确定性函数（即相同的输入产生相同的输出）时，我们的分布式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。 我们依赖对Map和Reduce任务的输出是原子提交的来完成这个特性。每个工作中的任务把它的输出写到私有的临时文件中。每个Reduce任务生成一个这样的文件，而每个Map任务则生成R个这样的文件（一个Reduce任务对应一个文件）。当一个Map任务完成的时，worker发送一个包含R个临时文件名的完成消息给Master。如果Master从一个已经完成的Map任务再次接收到到一个完成消息，Master将忽略这个消息；否则，Master将这R个文件的名字记录在数据结构里。 当Reduce任务完成时，Reduce worker进程以原子的方式把临时文件重命名为最终的输出文件。如果同一个Reduce任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名操作执行。我们依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个Reduce任务产生的数据。 使用MapReduce模型的程序员可以很容易的理解它们程序的行为，因为我们绝大多数的Map和Reduce操作是确定的，而且存在这样的一个事实：我们的失效处理机制等价于一个顺序的执行的操作。当Map和/或Reduce操作是不确定性的时候，我们提供虽然较弱但是依然合理的处理机制。当使用非确定操作的时候，一个Reduce任务R1的输出等价于一个非确定性程序的顺序执行产生的输出(In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output for R1 produced by a sequential execution of the non-deterministic program.)。但是，另一个不同的Reduce任务R2的输出也许符合一个非确定程序的非顺序执行产生的R2的输出(However, the output for a different reduce task R2 may correspond to the output for R2 produced by a different sequential execution of the non-deterministic program.)。 考虑Map任务M和Reduce任务R1、R2的情况。我们设定e(Ri)是Ri已经提交的执行过程（有且仅有一个这样的执行过程）。语义较弱是因为e（R1）可能读取了M的一次执行产生的输出，e（R2）可能读取了M的另一次执行产生的输出。 &nbsp; 3.4&nbsp;存储位置 在我们的计算运行环境中，网络带宽是一个相当匮乏的资源。我们通过尽量把输入数据(由GFS管理)存储在集群中机器的本地磁盘上来节省网络带宽。GFS把每个文件按64MB一个Block分割，每个Block保存在多台机器上，环境中存放了多份拷贝(一般是3个拷贝)。MapReduce的Master在调度Map任务时会考虑输入文件的位置信息，尽量将一个Map任务调度在包含相关输入数据拷贝的机器上执行；如果上述努力失败了，Master将尝试在保存有输入数据拷贝的机器附近的机器上执行Map任务(例如，分配到一个和包含输入数据的机器在一个switch里的worker机器上执行)。当在一个足够大的cluster集群上运行大型MapReduce操作的时候，大部分的输入数据都能从本地机器读取，因此消耗非常少的网络带宽。 &nbsp; 3.5&nbsp;任务粒度 我们将Map阶段细分为M个片段，Reduce阶段细分为R个片段，如上所述。理想情况下，M和R应该远大于worker机器的数量。让每个worker执行许多不同任务改善了动态负载平衡，并在worker失败时加快了恢复速度：它完成的许多映射任务可以分布在所有其它worker机器上。 在我们的实现中，M和R的大小有实际的界限，因为Master必须做出O（M+R）调度决策，并在内存中保持O（M*R）状态，如上文所述。（但是，内存使用的常量因素很小：状态的O（M*R）部分由每个映射任务/减少任务对大约1个字节的数据组成。）更进一步，R值通常是由用户指定的，因为每个Reduce任务最终都会生成一个独立的输出文件。实际使用时我们也倾向于选择合适的M值，以使得每一个独立任务都是处理大约16M到64M的输入数据（这样，上面描写的输入数据本地存储优化策略才最有效），另外，我们把R值设置为我们想使用的worker机器数量的几倍(small multiple)。我们通常会用这样的比例来执行MapReduce：M=200000，R=5000，使用2000台worker机器。 &nbsp; 3.6&nbsp;备用任务(Backup Tasks) 影响一个MapReduce的总执行时间最通常的因素是&quot;落伍者&quot;：在运算过程中，如果有一台机器花了很长的时间才完成最后几个Map或Reduce任务，导致MapReduce操作总的执行时间超过预期。出现&quot;落伍者&quot;的原因非常多。比如：如果一个机器的硬盘出了问题，在读取的时候要经常的进行读取纠错操作，导致读取数据的速度从30M/s降低到1M/s。如果cluster的调度系统在这台机器上又调度了其它的任务，由于CPU、内存、本地硬盘和网络带宽等竞争因素的存在，导致执行MapReduce代码的执行效率更加缓慢。我们最近遇到的一个问题是由于机器的初始化代码有bug，导致关闭了的处理器的缓存：在这些机器上执行任务的性能和正常情况相差上百倍。 我们有一个通用的机制来减少&quot;落伍者&quot;出现的情况。当一个MapReduce操作接近完成的时候，Master调度备用（backup）任务进程来执行剩下的、处于运行中状态（in-progress）的任务。无论是最初的执行进程、还是备用（backup）任务进程完成了任务，我们都把这个任务标记成为已经完成。我们调优了这个机制，通常只会占用比正常操作多几个百分点的计算资源。我们发现采用这样的机制对于减少超大MapReduce操作的总处理时间效果显著。例如，在5.3节描述的排序任务，在关闭掉备用任务的情况下要多花44%的时间完成排序任务。 &nbsp; 4&nbsp;技巧 虽然简单的Map和Reduce函数提供的基本功能已经能够满足大部分的计算需要，我们还是发掘出了一些有价值的扩展功能。本节将描述这些扩展功能。 &nbsp; 4.1&nbsp;分区函数&nbsp;&nbsp; MapReduce的使用者通常会指定Reduce任务和Reduce任务输出文件的数量（R）。我们在中间key上使用分区函数来对数据进行分区，之后再输入到后续任务执行进程。一个缺省的分区函数是使用hash方法(比如，hash(key) mod R)进行分区。hash方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对key值进行的分区将非常有用。比如，输出的key值是URLs，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce库的使用者需要提供专门的分区函数。例如，使用&quot;hash(Hostname(urlkey)) mod R&quot;作为分区函数就可以把所有来自同一个主机的URLs保存在同一个输出文件中。 &nbsp; 4.2&nbsp;顺序保证 我们确保在给定的分区中，中间key/value pair数据的处理顺序是按照key值增量顺序处理的。这样的顺序保证对每个分区生成一个有序的输出文件，这对于需要对输出文件按key值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。 &nbsp; 4.3&nbsp;Combiner函数 在某些情况下，Map函数产生的中间key值的重复数据会占很大的比重，并且，用户自定义的Reduce函数满足结合律和交换律。在2.1节的词数统计程序是个很好的例子。由于词频率倾向于一个zipf分布(齐夫分布)，每个Map任务将产生成千上万个这样的记录&lt;the,1&gt;。所有的这些记录将通过网络被发送到一个单独的Reduce任务，然后由这个Reduce任务把所有这些记录累加起来产生一个数字。我们允许用户指定一个可选的Combiner函数，Combiner函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。 Combiner函数在每台执行Map任务的机器上都会被执行一次。一般情况下，Combiner和Reduce函数是一样的。Combiner函数和Reduce函数之间唯一的区别是MapReduce库怎样控制函数的输出。Reduce函数的输出被保存在最终的输出文件里，而Combiner函数的输出被写到中间文件里，然后被发送给Reduce任务。 合并中间结果可以显著的提高一些MapReduce操作的速度。附录A包含一个使用Combiner函数的例子。 &nbsp; 4.4&nbsp;输入和输出的类型 MapReduce库支持几种不同格式的输入数据。比如，文本模式的输入数据的每一行被视为是一个key/value pair。key是文件的偏移量，value是那一行的内容。另外一种常见的格式是以key进行排序来存储的key/value pair的序列。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单独的Map任务来进行后续处理(例如，文本模式的范围分割必须确保仅仅在每行的边界进行范围分割)。虽然大多数MapReduce的使用者仅仅使用很少的预定义输入类型就满足要求了，但是使用者依然可以通过提供一个简单的Reader接口就能够支持一个新的输入类型。 Reader并非一定要从文件中读取数据，比如，我们可以很容易的实现一个从数据库里读记录的Reader，或者从内存中的数据结构读取数据的Reader。 类似的，我们提供了一些预定义的输出数据类型，通过这些预定义类型能够产生不同格式的数据。用户采用类似添加新的输入数据类型的方式增加新的输出类型。 &nbsp; 4.5&nbsp;副作用 在某些情况下，MapReduce的使用者发现，如果在Map和/或Reduce操作(map and/or reduce operators.)过程中增加辅助的输出文件会比较省事。我们依靠程序writer把这种&quot;副作用&quot;变成原子的以及幂等的。通常应用程序首先把输出结果写到一个临时文件中，在输出全部数据之后，在使用系统级的原子操作rename重新命名这个临时文件。 我们不支持由单个任务生成的多个输出文件的原子两阶段提交，因此，生成具有跨文件一致性要求的多个输出文件的任务应该是确定性的。这种限制在实践中从未成为一个问题。 &nbsp; 4.6&nbsp;跳过损坏的记录 有时候，用户程序中的bug导致Map或者Reduce函数在处理某些记录的时候crash掉，MapReduce操作无法顺利完成。惯常的做法是修复bug后再次执行MapReduce操作，但是，有时候找出这些bug并修复它们不是一件容易的事情；这些bug也许是在第三方库里，而我们手头没有这些库的源代码。而且在很多时候，忽略一些有问题的记录也是可以接受的，比如在一个巨大的数据集上进行统计分析的时候。我们提供了一种可选的执行模式，其中MapReduce库检测哪些记录会导致确定性crash，并跳过这些记录以向前推进。 每个worker进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus&nbsp;error）。在执行Map或者Reduce操作之前，MapReduce库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，消息处理函数将用&quot;最后一口气&quot;通过UDP包向Master发送处理的最后一条记录的序号。当Master看到在处理某条特定记录不止失败一次时，Master就标志这条记录需要被跳过，并且在下次重新执行相关的Map或者Reduce任务的时候跳过这条记录。 &nbsp; 4.7&nbsp;本地执行 调试Map和Reduce函数的bug是非常困难的，因为实际执行操作时不但是分布在系统中执行的，而且通常是在好几千台计算机上执行，具体的执行位置是由Master进行动态调度的，这又大大增加了调试的难度。为了简化调试、性能分析和小规模测试，我们开发了一套MapReduce库的本地实现版本，通过使用本地版本的MapReduce库，MapReduce操作在本地计算机上顺序执行。用户可以控制MapReduce操作的执行，可以把操作限制到特定的Map任务上。用户通过设定特别的标志来在本地执行它们的程序，之后就可以很容易的使用本地调试和测试工具（比如gdb）。 &nbsp; 4.8&nbsp;状态信息 主服务器运行内部HTTP服务器并导出一组状态页供人使用。状态页显示计算的进度，例如已完成的任务数、正在进行的任务数、输入字节数、中间数据字节数、输出字节数、处理速率等。这些页还包含指向每个任务生成的标准错误和标准输出文件的链接。用户可以使用这些数据来预测计算将花费多长时间，以及是否应向计算中添加更多的资源。这些页面还可用于确定计算速度比预期慢得多的时间。 此外，顶级状态页面显示哪些worker失败，以及哪些失效的时候正在运行的Map和Reduce任务。当试图调试用户代码中的错误时，此信息非常有用。 &nbsp; 4.9&nbsp;计数器 MapReduce库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇German文档等等。 为了使用这个特性，用户在程序中创建一个命名的计数器对象，在Map和Reduce函数中相应的增加计数器的值。例如： Counter* uppercase; uppercase = GetCounter(&quot;uppercase&quot;); map(String name, String contents): for each word w in contents: if (IsCapitalized(w)): uppercase-&gt;Increment(); EmitIntermediate(w, &quot;1&quot;); 这些计数器的值周期性的从各个单独的worker机器上传递给Master（附加在ping的应答包中传递）。Master把执行成功的Map和Reduce任务的计数器值进行累计，当MapReduce操作完成之后，返回给用户代码。 计数器当前的值也会显示在Master的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器的值的时候，Master要检查重复运行的Map或者Reduce任务，避免重复累加（之前提到的备用任务和失效后重新执行任务这两种情况会导致相同的任务被多次执行）。有些计数器的值是由MapReduce库自动维持的，比如已经处理的输入的key/value pair的数量、输出的key/value pair的数量等等。 计数器机制对于MapReduce操作的完整性检查非常有用。比如，在某些MapReduce操作中，用户需要确保产生的output pairs精确的等于处理的input pairs，或者处理的German文档数量在被处理的整个文档数量中属于合理范围。 &nbsp; 5&nbsp;性能 本节我们分析在一个大型集群上运行的两个计算来衡量MapReduce的性能。一个计算是在大约1TB的数据中进行特定的模式匹配，另一个计算对大约1TB的数据进行排序。 这两个程序在大量使用的MapReduce应用中是非常具有代表性的——一类是对数据格式进行转换，从一种表现形式转换为另外一种表现形式；另一类是从海量数据中抽取少部分用户感兴趣的数据。 &nbsp; 5.1&nbsp;集群配置 所有这些程序都运行在一个由大约1800台机器构成的集群上。每台机器配置2个2G主频、支持超线程的Intel Xeon处理器，4GB的物理内存，两个160GB的IDE硬盘和一个千兆以太网卡。这些机器部署在一个两层的树形交换网络中，在root节点大概有100-200GBPS的传输带宽。所有这些机器都采用相同的部署（对等部署），因此任意两点之间的网络往返时延小于1毫秒。 在4GB内存里，大概有1-1.5G用于运行集群上的其它任务。测试程序在周末下午开始执行，这时主机的CPU、磁盘和网络基本上处于空闲状态。 &nbsp; 5.2&nbsp;Grep(一种强大的文本搜索工具) 这个分布式的Grep程序需要扫描大概10的10次方个由100个字节组成的记录，查找出现概率较小的3个字符的模式（这个模式在92337个记录中出现）。输入数据被拆分成大约64M的Block（M=15000），整个输出数据存放在一个文件中（R=1）。 图2显示了这个运算随时间的处理过程。其中Y轴表示输入数据的处理速度。处理速度随着参与MapReduce计算的机器数量的增加而增加，当1764台worker参与计算的时，处理速度达到了30GB/s。当Map任务结束的时候，即在计算开始后80秒，输入的处理速度降到0。整个计算过程从开始到结束一共花了大概150秒。这包括了大约一分钟的初始启动阶段。初始启动阶段消耗的时间包括了把这个程序传送到各个worker机器上的时间、等待GFS文件系统打开1000个输入文件集合的时间、获取相关的文件本地位置优化信息的时间。 &nbsp; 5.3&nbsp;排序 排序程序处理10的10次方个100个字节组成的记录（大约1TB的数据）。这个程序模仿TeraSort&nbsp;benchmark。 排序程序由不到50行代码组成。只有三行的Map函数从文本行中解析出10个字节的key值作为排序的key，并且把这个key和原始文本行作为中间的key/value pair值输出。我们使用了一个内置的恒等函数(Identity function)作为Reduce操作函数，这个函数把中间key/value pair不作任何改变输出。最终排序的输出被写入一组双路复制的GFS文件中（也就是说，程序输出2TB的数据）。 如前所述，输入数据被分成64MB的Block（M=15000）。我们把排序后的输出结果分区后存储到4000个文件（R=4000）。分区函数使用key的原始字节来把数据分区到R个片段中。 在这个benchmark测试中，我们使用的分区函数知道key的分区情况。通常对于排序程序来说，我们会增加一个预处理的MapReduce操作用于采样key值的分布情况，通过采样的数据来计算对最终排序处理的分区点。(从上到下分别是Input、Shuffle和Output) 图三（a）显示了这个排序程序的正常执行过程。左上的图显示了Input数据读取的速度。数据读取速度峰值会达到13GB/s，并且所有Map任务在大约200秒之前完成，然后迅速滑落至0。值得注意的是，排序程序输入数据读取速度小于分布式Grep程序。这是因为排序程序的Map任务花了大约一半的处理时间和I/O带宽把中间输出结果写到本地硬盘。相应的分布式Grep程序的中间结果输出几乎可以忽略不计。 左边中间的图显示了中间数据从Map任务发送到Reduce任务的网络速度。这个过程从第一个Map任务完成之后就开始缓慢启动(shuffling)了。图示的第一个高峰是启动了第一批约1700个Reduce任务（整个MapReduce分布到大概1700台机器上，每台机器1次最多执行1个Reduce任务）。排序程序运行大约300秒后，第一批启动的Reduce任务只有部分完成，我们开始执行剩下的Reduce任务。所有的处理在大约600秒后结束。 左下图表示Reduce任务把排序后的数据写到最终的输出文件的速度。在第一个shuffling阶段结束和数据开始写入磁盘之间有延时，这是因为worker机器正在忙于排序中间数据。磁盘写入速度在2-4GB/s持续一段时间。输出数据写入磁盘大约持续850秒。计入初始启动部分的时间，整个运算消耗了891秒。这个速度和TeraSort benchmark的最高纪录1057秒相差不多。 需要注意的一点是：由于我们的本地化输入数据优化策略，Input速率高于Shuffle速率和Output速率——大多数数据是从本地磁盘读取的，并绕过我们相对受限的网络带宽。Shuffle速率高于Output速率，因为输出阶段会写入两份已排序数据的副本（我们写两份输出的副本的原因是为了可靠性和可用性）。我们编写两个副本，因为这是底层文件系统提供的可靠性和可用性机制。如果底层文件系统使用纠删码(erasure coding)而不是复制，则写入数据的网络带宽需求将减少。 &nbsp; 5.4&nbsp;高效的backup任务 图三（b）展示关闭备用任务后排序程序执行情况。执行的过程和图3（a）很相似，除了有一条非常长的尾巴，几乎没有任何写操作发生。在960秒后，只有5个Reduce任务没有完成。这些拖后腿的任务又执行了300秒才完成。整个计算消耗了1283秒，多了44%的执行时间。 &nbsp; 5.5&nbsp;失效的机器 在图三（c）演示在排序程序执行的过程中，我们在程序开始后几分钟有意的kill了1746个worker中的200个。集群底层的调度立刻在这些机器上重新开始新的worker处理进程（因为只是worker机器上的处理进程被kill了，机器本身还在工作）。 图三（c）显示出了一个&quot;负&quot;的输入数据读取速度，这是因为一些已经完成的Map任务丢失了（由于相应的执行Map任务的worker进程被kill了），需要重新执行这些任务。相关Map任务很快就被重新执行了。整个运算在933秒内完成，包括了初始启动时间（只比正常执行多消耗了5%的时间）。 &nbsp; 6&nbsp;经验 我们在2003年1月完成了第一个版本的MapReduce库，2003年8月的版本有了显著的增强，这包括了输入数据本地优化、worker机器之间的动态负载均衡等等。从那以后，我们惊喜的发现，MapReduce库能广泛应用于我们日常工作中遇到的各类问题。它现在在Google内部各个领域得到广泛应用，包括： 大规模机器学习问题 Google News和Froogle产品的集群问题 从公众查询产品（比如Google的Zeitgeist）的报告中抽取数据。 从大量的新应用和新产品的网页中提取有用信息（比如，从大量的位置搜索网页中抽取地理位置信息）。 大规模的图形计算。 图四显示了在我们的源代码管理系统中，随着时间推移，独立的MapReduce程序数量的显著增加。从2003年早些时候的0个增长到2004年9月份的差不多900个不同的程序。MapReduce的成功取决于采用MapReduce库能够在不到半个小时内写出一个简单的程序，这个简单的程序能够在上千台机器组成的集群上做大规模并行处理，这极大的加快了开发和原形设计(prototyping cycle)的周期。另外，采用MapReduce库，可以让完全没有分布式和/或并行系统开发经验的程序员很容易的利用大量的资源，开发出分布式和/或并行处理的应用。 在每个任务结束的时候，MapReduce库统计计算资源的使用状况。在表1，我们列出了2004年8月份MapReduce运行的任务所占用的相关资源。 &nbsp; 6.1&nbsp;大规模索引 到目前为止，MapReduce最成功的应用就是重写了Google网络搜索服务所使用到的index系统。索引系统的输入数据是网络爬虫抓取回来的海量的文档，这些文档数据都保存在GFS文件系统里。这些文档的原始内容的大小超过了20TB。索引程序是通过一系列的MapReduce操作（大约5到10次）来建立索引。使用MapReduce（替换上一个特别设计的、分布式处理的索引程序）带来这些好处： 实现索引部分的代码简单、小巧、容易理解，因为对于容错、分布式以及并行计算的处理都是MapReduce库提供的。比如，使用MapReduce库，计算的代码行数从原来的3800行C++代码减少到大约700行代码。 MapReduce库的性能已经足够好了，因此我们可以把在概念上不相关的计算步骤分开处理，而不是混在一起以减少数据传递的额外消耗。概念上不相关的计算步骤的隔离也使得我们可以很容易改变索引处理方式。比如，对之前的索引系统的一个小更改可能要耗费好几个月的时间，但是在使用MapReduce的新系统上，这样的更改只需要花几天时间就可以了。 索引系统的操作管理更容易了。因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝大部分问题都已经由MapReduce库解决了，不再需要操作人员的介入。另外，我们可以通过在索引系统集群中增加机器的简单方法提高整体处理性能。 &nbsp; 7&nbsp;相关工作 很多系统都提供了严格的编程模式，并且通过对编程的严格限制来实现并行计算。例如，一个结合函数可以通过把N个元素的数组的前缀在N个处理器上使用并行前缀算法，在log N的时间内计算完。根据我们对大型实际环境计算的经验，可以将MapReduce视为对其中一些模型的简化和提炼。(MapReduce can be considered a simplification and distillation of some of these models based on our experience with large real-world computations.)。更加值得骄傲的是，我们还实现了基于上千台处理器的集群的容错处理。相比而言，大部分并发处理系统都只在小规模的集群上实现，并且把容错处理交给了程序员。 Bulk Synchronous Programming和一些MPI原语提供了更高级别的并行处理抽象，可以更容易的写出并行处理的程序。MapReduce和这些系统的主要不同之处在于，MapReduce利用限制性编程模式实现了用户程序的自动并发处理，并且提供了透明的容错处理。 我们数据本地优化策略的灵感来源于active disks等技术，在active disks中，计算任务是尽量推送到数据所存储的节点处理，这样就减少了网络和IO子系统的吞吐量。我们在挂载几个硬盘的普通机器上执行我们的运算，而不是在磁盘处理器上执行我们的工作，但是达到的目的一样的。 我们的备用任务机制和Charlotte System提出的eager调度机制比较类似。Eager调度机制的一个缺点是如果一个任务反复失效，那么整个计算就不能完成。我们通过忽略引起故障的记录的方式在某种程度上解决了这个问题。 MapReduce的实现依赖于一个内部的集群管理系统，这个集群管理系统负责在一个超大的、共享机器的集群上分布和运行用户任务。虽然这个不是本论文的重点，但是有必要提一下，这个集群管理系统在理念上和其它系统，如Condor是一样。 MapReduce库的排序机制和NOW-Sort的操作很类似。读取输入源的机器（map workers）把待排序的数据进行分区后，发送到R个Reduce worker中的一个进行处理。每个Reduce worker在本地对数据进行排序（尽可能在内存中排序）。当然，NOW-Sort没有给用户自定义的Map和Reduce函数的机会，因此不具备MapReduce库广泛的实用性。River提供了一个编程模型：处理进程通过分布式队列传送数据的方式进行互相通讯。和MapReduce类似，River系统尝试在不对等的硬件环境下，或者在系统颠簸的情况下也能提供近似平均的性能。River是通过精心调度硬盘和网络的通讯来平衡任务的完成时间。MapReduce库采用了其它的方法。通过对编程模型进行限制，MapReduce框架把问题分解成为大量的&quot;小&quot;任务。这些任务在可用的worker集群上动态的调度，这样更快的worker就可以执行更多的任务。通过对编程模型进行限制，我们可在工作接近完成的时候调度备用任务，在硬件配置不均衡的情况下减少完成的时间（比如有的worker慢、或者worker被某些操作阻塞了）。 BAD-FS采用了和MapReduce完全不同的编程模式，它是面向广域网的。不过，这两个系统有两个基础功能很类似。（1）两个系统采用重新执行的方式来防止由于失效导致的数据丢失。（2）两个都使用数据本地化调度策略，减少网络通讯的数据量。 TACC是一个高可用网络服务的简化构造系统。和MapReduce一样，它也依靠重新执行机制来实现容错处理。 &nbsp; 8&nbsp;结束语 MapReduce编程模型在Google内部成功应用于多个领域。我们把这种成功归结为几个方面：首先，这种编程模式使得MapReduce库易于使用，即便对于完全没有并行或者分布式系统开发经验的程序员而言也很容易。这是因为MapReduce封装了并行处理、容错处理、数据本地化优化、负载均衡等等技术难点的细节；其次，大量不同类型的问题都可以通过MapReduce简单的解决。比如，MapReduce用于生成Google的网络搜索服务所需要的数据、用来排序、用来数据挖掘、用于机器学习，以及很多其它的系统；第三，我们实现了一个在数千台计算机组成的大型集群上灵活部署并运行的MapReduce。这个实现使得有效利用这些丰富的计算资源变得非常简单，因此也适合用于解决Google遇到的其它很多需要大量计算的问题。 我们也从MapReduce开发过程中学到了不少东西。首先，限制性编程模式使得并行和分布式计算非常容易，也易于构造容错的计算环境；其次，网络带宽是稀有资源。大量的系统优化以针对减少网络传输量为目的：本地优化策略使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节约了网络带宽；第三，多次执行相同的任务可以减少性能缓慢的机器带来的负面影响，同时解决了由于机器失效导致的数据丢失问题。 &nbsp; 附录A、单词频率统计 本节包含了一个完整的程序，用于统计在一组命令行指定的输入文件中，每一个不同的单词出现频率。 #include &quot;mapreduce/mapreduce.h&quot; // User’s map function class WordCounter : public Mapper { public: virtual void Map(const MapInput&amp; input) { const string&amp; text = input.value(); const int n = text.size(); for (int i = 0; i &lt; n; ) { // Skip past leading whitespace while((i &lt; n) &amp;&amp; isspace(text[i])) i++; // Find word end int start = i; while ((i &lt; n) &amp;&amp; !isspace(text[i])) i++; if (start &lt; i) Emit(text.substr(start,i-start),&quot;1&quot;); } } }; REGISTER_MAPPER(WordCounter); // User’s reduce function class Adder : public Reducer { virtual void Reduce(ReduceInput* input) { // Iterate over all entries with the // same key and add the values int64 value = 0; while (!input-&gt;done()) { value += StringToInt(input-&gt;value()); input-&gt;NextValue(); } // Emit sum for input-&gt;key() Emit(IntToString(value)); } }; REGISTER_REDUCER(Adder); int main(int argc, char** argv) { ParseCommandLineFlags(argc, argv); MapReduceSpecification spec; // Store list of input fifiles into &quot;spec&quot; for (int i = 1; i &lt; argc; i++) { MapReduceInput* input = spec.add_input(); input-&gt;set_format(&quot;text&quot;); input-&gt;set_filepattern(argv[i]); input-&gt;set_mapper_class(&quot;WordCounter&quot;); } // Specify the output files: // /gfs/test/freq-00000-of-00100 // /gfs/test/freq-00001-of-00100 // … MapReduceOutput* out = spec.output(); out-&gt;set_fifilebase(&quot;/gfs/test/freq&quot;); out-&gt;set_num_tasks(100); out-&gt;set_format(&quot;text&quot;); out-&gt;set_reducer_class(&quot;Adder&quot;); // Optional: do partial sums within map // tasks to save network bandwidth out-&gt;set_combiner_class(&quot;Adder&quot;); //Tuning parameters: use at most 2000 //machines and 100 MB of memory per task spec.set_machines(2000); spec.set_map_megabytes(100); spec.set_reduce_megabytes(100); //Now run it MapReduceResult result; if (!MapReduce(spec, &amp;result)) abort(); // Done: ‘result’ structure contains info // about counters, time taken, number of // machines used, etc. return 0; } &nbsp;","@type":"BlogPosting","url":"https://mlh.app/2019/05/12/787059.html","headline":"MapReduce 论文中文翻译","dateModified":"2019-05-12T00:00:00+08:00","datePublished":"2019-05-12T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/05/12/787059.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>MapReduce 论文中文翻译</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1 id="main-toc"><strong>目录</strong></h1> 
  <p id="1%C2%A0%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#1%C2%A0%E4%BB%8B%E7%BB%8D" rel="nofollow">1&nbsp;介绍</a></p> 
  <p id="2%C2%A0%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px;"><a href="#2%C2%A0%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B" rel="nofollow">2&nbsp;编程模型</a></p> 
  <p id="3%C2%A0%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#3%C2%A0%E5%AE%9E%E7%8E%B0" rel="nofollow">3&nbsp;实现</a></p> 
  <p id="4%C2%A0%E6%8A%80%E5%B7%A7-toc" style="margin-left:0px;"><a href="#4%C2%A0%E6%8A%80%E5%B7%A7" rel="nofollow">4&nbsp;技巧</a></p> 
  <p id="5%C2%A0%E6%80%A7%E8%83%BD-toc" style="margin-left:0px;"><a href="#5%C2%A0%E6%80%A7%E8%83%BD" rel="nofollow">5&nbsp;性能</a></p> 
  <p id="6%C2%A0%E7%BB%8F%E9%AA%8C-toc" style="margin-left:0px;"><a href="#6%C2%A0%E7%BB%8F%E9%AA%8C" rel="nofollow">6&nbsp;经验</a></p> 
  <p id="7%C2%A0%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C-toc" style="margin-left:0px;"><a href="#7%C2%A0%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" rel="nofollow">7&nbsp;相关工作</a></p> 
  <p id="8%C2%A0%E7%BB%93%E6%9D%9F%E8%AF%AD-toc" style="margin-left:0px;"><a href="#8%C2%A0%E7%BB%93%E6%9D%9F%E8%AF%AD" rel="nofollow">8&nbsp;结束语</a></p> 
  <p id="%E9%99%84%E5%BD%95A%E3%80%81%E5%8D%95%E8%AF%8D%E9%A2%91%E7%8E%87%E7%BB%9F%E8%AE%A1-toc" style="margin-left:0px;"><a href="#%E9%99%84%E5%BD%95A%E3%80%81%E5%8D%95%E8%AF%8D%E9%A2%91%E7%8E%87%E7%BB%9F%E8%AE%A1" rel="nofollow">附录A、单词频率统计</a></p> 
  <hr id="hr-toc">
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">原文下载链接：<a href="https://pan.baidu.com/s/1L9hclpiqQ-NVjmbqSz3mMQ" rel="nofollow">https://pan.baidu.com/s/1L9hclpiqQ-NVjmbqSz3mMQ</a>&nbsp; 提取码：xhwn&nbsp;</span></p> 
  <h1 id="%E6%91%98%E8%A6%81" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">摘要</span></strong></h1> 
  <p style="margin-left:0pt;"><span style="color:#c00000;">MapReduce是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一个Map函数处理一个基于key/value pair的数据集合，输出中间的基于key/value pair的数据集合；然后再创建一个Reduce函数用来合并所有具有相同中间key值的中间value值。</span><span style="color:#0c0c0c;">现实世界中有很多满足上述</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">处理模型的例子，本论文将详细描述这个模型。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">MapReduce架构的程序能够在大量的配置普通的计算机上实现并行化处理。这个系统在运行时只关心：</span><span style="color:#c00000;">如何分割输入数据，在大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间必要的通信。</span><span style="color:#0c0c0c;">采用MapReduce架构可以使那些没有并行计算和分布式处理系统开发经验的程序员有效利用分布式系统的丰富资源。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">我们的MapReduce实现运行在规模可以灵活调整的由普通机器组成的集群上：一个典型的MapReduce计算往往由几千台机器组成、处理以TB计算的数据。程序员发现这个系统非常好用：已经实现了数以百计的MapReduce程序，在Google的集群上，每天都有1000多个MapReduce程序在执行。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h1 id="1%C2%A0%E4%BB%8B%E7%BB%8D" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">1</span>&nbsp;<span style="color:#0c0c0c;">介绍</span></strong></h1> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">在过去的5年里，包括本文作者在内的Google的很多程序员，为了处理海量的原始数据，已经实现了数以百计的、专用的计算方法。这些计算方法用来处理大量的原始数据，比如，文档抓取（类似网络爬虫的程序）、Web请求日志等；也为了计算处理各种类型的衍生数据，比如倒排索引、Web文档的图结构的各种表示形势、每台主机上网络爬虫抓取的页面数量的汇总、每天被请求的最多的查询的集合等。大多数这样的数据处理运算在概念上很容易理解。然而由于输入的数据量巨大，因此要想在可接受的时间内完成运算，只有将这些计算分布在成百上千的主机上。如何处理并行计算、如何分发数据、如何处理错误？所有这些问题综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">为了解决上述复杂的问题，我们设计一个新的抽象模型，使用这个抽象模型，我们只要表述我们想要执行的简单运算即可，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，这些问题都被封装在一个库里面。设计这个抽象模型的灵感来自Lisp和许多</span><span style="color:#0c0c0c;">其它</span><span style="color:#0c0c0c;">函数式语言的Map和Reduce的原语。</span><span style="color:#c00000;">我们意识到我们大多数的运算都包含这样的操作：在输入数据的</span><span style="color:#c00000;">"</span><span style="color:#c00000;">逻辑</span><span style="color:#c00000;">"</span><span style="color:#c00000;">记录上应用Map操作得出一个中间key/value pair集合，然后在所有具有相同key值的value值上应用Reduce操作，从而达到合并中间的数据，得到一个想要的结果的目的。</span><span style="color:#0c0c0c;">使用MapReduce模型，再结合用户实现的Map和Reduce函数，我们就可以非常容易的实现大规模并行化计算；通过MapReduce模型自带的</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">再次执行</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">功能，也提供了初级的容灾实现方案。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">这个工作(实现一个MapReduce框架模型)的主要贡献是通过简单的接口来实现自动的</span><span style="color:#0c0c0c;">、</span><span style="color:#0c0c0c;">并行化和大规模的分布式计算，通过使用MapReduce模型接口实现在大量普通的PC机上高性能计算。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">第二部分描述基本的编程模型和一些使用案例。第三部分描述了一个基于</span><span style="color:#0c0c0c;">我们</span><span style="color:#0c0c0c;">集群的计算环境</span><span style="color:#0c0c0c;">所定制的</span><span style="color:#0c0c0c;">MapReduce</span><span style="color:#0c0c0c;">接口的</span><span style="color:#0c0c0c;">实现。第四部分描述我们认为在MapReduce编程模型中一些实用的技巧。第五部分对于各种不同的任务，测量我们MapReduce实现的性能。第六部分揭示了在Google内部如何使用MapReduce作为基础重写我们的索引系统产品，包括其它一些使用MapReduce的经验。第七部分讨论相关的和未来的工作。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h1 id="2%C2%A0%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">2</span>&nbsp;<span style="color:#0c0c0c;">编程模型</span></strong></h1> 
  <p style="margin-left:0pt;"><span style="color:#c00000;">MapReduce编程模型的原理是：利用一个输入key/value pair集合来产生一个输出的key/value pair集合。MapReduce库的用户用两个函数表达这个计算：Map和Reduce。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">用户自定义的Map函数接受一个输入的key/value pair值，然后产生一个中间key/value pair值的集合</span><span style="color:#0c0c0c;">(takes an input pair and produces a set of intermediate key/value pairs.)</span><span style="color:#0c0c0c;">。MapReduce库把所有具有相同</span><span style="color:#0c0c0c;">intermediate </span><span style="color:#0c0c0c;">key值I的</span><span style="color:#0c0c0c;">intermediate </span><span style="color:#0c0c0c;">value值集合在一起后传递给</span><span style="color:#0c0c0c;">R</span><span style="color:#0c0c0c;">educe函数。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">用户自定义的Reduce函数接受一个中间key的值</span><span style="color:#0c0c0c;">(假设此值为</span><span style="color:#0c0c0c;">I</span><span style="color:#0c0c0c;">)</span><span style="color:#0c0c0c;">和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小的value值的集合。一般每次Reduce函数调用只产生0或1个输出</span><span style="color:#0c0c0c;">的</span><span style="color:#0c0c0c;">value值。通常</span><span style="color:#0c0c0c;">，</span><span style="color:#0c0c0c;">我们通过一个迭代器把中间value值提供给Reduce函数，这样我们就可以处理无法全部放入内存中的大量的value值的集合。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="2.1%20%E4%BE%8B%E5%AD%90" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">2.1 例子</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">例如，计算一个大的文档集合中每个单词出现的次数，下面是伪代码段：</span></p> 
  <pre class="has">
<code>map(String key, String value):
// key: document name
// value: document contents
    for each word w in value:
        EmitIntermediate(w, "1");

reduce(String key, Iterator values):
// key: a word
// values: a list of counts
    int result = 0;
    for each v in values:
        result += ParseInt(v);
    Emit(AsString(result));</code></pre> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">Map函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是1)。Reduce函数把Map函数产生的每一个特定的词的计数累加起来。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">另外，用户编写代码，使用输入和输出文件的名字、可选的调节参数来完成一个符合MapReduce模型规范的对象，然后调用MapReduce函数，并把这个规范对象传递给它。用户的代码和MapReduce库链接在一起(用C++实现)。附录A包含了这个实例的全部程序代码。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="2.2%C2%A0%E7%B1%BB%E5%9E%8B" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">2.2</span>&nbsp;<span style="color:#0c0c0c;">类型</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">尽管在前面例子的伪代码中使用了以字符串表示的输入输出值，但是在概念上，用户定义的Map和Reduce函数都有相关联的类型：</span></p> 
  <blockquote> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">map(k1,v1) </span><span style="color:#0c0c0c;">-&gt;</span><span style="color:#0c0c0c;">list(k2,v2)</span></p> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">reduce(k2,list(v2)) -&gt;list(v2) </span></p> 
  </blockquote> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">比如，输入的key和value值与输出的key和value值在类型上推导的域不同。此外，中间key和value值与输出key和value值在类型上推导的域相同。（注：参考Hadoop、KFS等实现，map和reduce都使用了泛型，因此，domain理解</span><span style="color:#0c0c0c;">成类型推导的域）。我们的C++中使用字符串类型作为用户自定义函数的输入输出，用户在自己的代码中对字符串进行适当的类型转换。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="2.3%C2%A0%E6%9B%B4%E5%A4%9A%E7%9A%84%E4%BE%8B%E5%AD%90" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">2.3</span>&nbsp;<span style="color:#0c0c0c;">更多的例子</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">这里还有一些有趣的简单例子，可以很容易的使用MapReduce模型来表示：</span></p> 
  <ol>
   <li><span style="color:#0c0c0c;">分布式的</span><span style="color:#0c0c0c;">Grep</span><span style="color:#0c0c0c;">：Map函数输出匹配某个模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。</span><span style="color:#0c0c0c;">(Grep是Globally search a Regular Expression and Print的缩写，它是一种强大的文本搜索工具，能使用特定模式匹配（包括正则表达式）搜索文本，并默认输出匹配行。)</span></li> 
   <li><span style="color:#c00000;">计算URL访问频率：Map函数处理日志中</span><span style="color:#c00000;">W</span><span style="color:#c00000;">eb页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。</span><span style="color:#c00000;">(最好理解的一个例子)</span></li> 
   <li><span style="color:#0c0c0c;">倒转网络链接图：Map函数在源页面（source）中搜索所有的链接目标（target）并输出为(target,source)。Reduce函数把给定链接目标（target）的链接组合成一个列表，输出(target,list(source))。</span></li> 
   <li><span style="color:#0c0c0c;">每个主机的检索词向量：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。Map函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的URL。Reduce函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主机名,检索词向量)。</span></li> 
   <li><span style="color:#c00000;">倒排索引：Map函数分析每个文档输出一个(词,文档号)的列表，Reduce函数的输入是一个给定词的所有（词，文档号），排序所有的文档号，输出(词,list（文档号）)。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。</span></li> 
   <li><span style="color:#0c0c0c;">分布式排序：Map函数从每个记录提取key，输出(key,record)。Reduce函数不改变任何的值。这个运算依赖分区机制(在4.1描述)和排序属性(在4.2描述)。</span></li> 
  </ol>
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h1 id="3%C2%A0%E5%AE%9E%E7%8E%B0" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">3</span>&nbsp;<span style="color:#0c0c0c;">实现</span></strong></h1> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">MapReduce模型可以有多种不同的实现方式。如何正确选择取决于具体的环境。例如，一种实现方式适用于小型的共享内存方式的机器，另外一种实现方式则适用于大型NUMA架构的多处理器的主机，而有的实现方式更适合大型的网络连接集群。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">本章节描述一个适用于Google内部广泛使用的运算环境的实现：用以太网交换机连接、由普通PC机组成的大型集群。在我们的环境里包括：</span></p> 
  <blockquote> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">1.x86架构、运行Linux操作系统、双处理器、2-4GB内存的机器。</span></p> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">2.普通的网络硬件设备，每个机器的带宽为百兆或者千兆，但是远小于网络的平均带宽的一半。</span></p> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">3.集群中包含成百上千的机器，因此，机器故障是常态。</span></p> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">4.存储为廉价的内置IDE硬盘。一个内部分布式文件系统用来管理存储在这些磁盘上的数据。文件系统通过数据复制来在不可靠的硬件上保证数据的可靠性和有效性。</span></p> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">5.用户提交工作（job）给调度系统。每个工作（job）都包含一系列的任务（task），调度系统将这些任务调度到集群中多台可用的机器上。</span></p> 
  </blockquote> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="3.1%C2%A0%E6%89%A7%E8%A1%8C%E6%A6%82%E6%8B%AC" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">3.1</span>&nbsp;<span style="color:#0c0c0c;">执行概括</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#c00000;">通过将Map调用的输入数据自动分割为M个数据片段的集合，Map调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使用分区函数将Map调用产生的中间key值分成R个不同分区（例如，hash(key) mod R），Reduce调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512220537605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70"></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">图1展示了我们的MapReduce实现中操作的全部流程。当用户调用MapReduce函数时，将发生下面的一系列动作（下面的序号和图1中的序号一一对应）：</span></p> 
  <blockquote> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">1.用户程序首先调用的MapReduce库</span><span style="color:#c00000;">将输入文件分成M个数据片</span><span style="color:#c00000;">段</span><span style="color:#0c0c0c;">，每个数据片段的大小一般从 16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在</span><span style="color:#0c0c0c;">集</span><span style="color:#0c0c0c;">群中创建大量的程序副本。</span></p> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">2.这些程序副本中的有一个特殊的程序</span><span style="color:#0c0c0c;">——Master</span><span style="color:#0c0c0c;">。副本中其它的程序都是worker程序，由</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">分配任务。有M个Map任务和R个Reduce任务将被分配，</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">将一个Map任务或Reduce任务分配给一个空闲的worker。</span></p> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">3.被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key/value</span>&nbsp;<span style="color:#0c0c0c;">pair，然后把key/value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key/value</span>&nbsp;<span style="color:#0c0c0c;">pair，并缓存在内存中。</span></p> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">4.缓存中的key/value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key/value pair在本地磁盘上的存储位置将被回传给</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">，由</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">负责把这些存储位置再传送给Reduce worker。</span></p> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">5.当Reduce worker程序接收到</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。</span><span style="color:#c00000;">当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。</span><span style="color:#c00000;">由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。</span><span style="color:#0c0c0c;">如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</span></p> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">6.Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。</span></p> 
   <p style="margin-left:0pt;"><span style="color:#0c0c0c;">7.当所有的Map和Reduce任务都完成之后，</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">唤醒用户程序。在这个时候，在用户程序里对MapReduce</span><span style="color:#0c0c0c;">的</span><span style="color:#0c0c0c;">调用才返回。</span></p> 
  </blockquote> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">在成功完成任务之后，MapReduce的输出存放在R个输出文件中（对应每个Reduce任务产生一个输出文件，文件名由用户指定）。一般情况下，用户不需要将这R个输出文件合并成一个文件</span><span style="color:#0c0c0c;">——它们</span><span style="color:#0c0c0c;">经常把这些文件作为另外一个MapReduce的输入，或者在另外一个可以处理多个分割文件的分布式应用中使用。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="3.2%C2%A0Master%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">3.2</span>&nbsp;<span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">数据结构</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">持有一些数据结构，它存储每一个Map和Reduce任务的状态（空闲、工作中或完成)，以及Worker机器(非空闲任务的机器)的标识。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">就像一个数据管道，中间文件存储区域的位置信息通过这个管道从Map传递到Reduce。因此，对于每个已经完成的Map任务，</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">存储了Map任务产生的R个中间文件存储区域的大小和位置。当Map任务完成时，</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的Reduce任务。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="3.3%C2%A0%E5%AE%B9%E9%94%99" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">3.3</span>&nbsp;<span style="color:#0c0c0c;">容错</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">因为MapReduce库的设计初衷是使用由成百上千的机器组成的集群来处理超大规模的数据，所以，这个库必须要能很好的处理机器故障。</span></p> 
  <p style="margin-left:0pt;"><strong><span style="color:#0c0c0c;"><strong>W</strong></span></strong><strong><span style="color:#0c0c0c;"><strong>orker故障</strong></span></strong></p> 
  <p style="margin-left:0pt;"><span style="color:#c00000;">Master</span><span style="color:#c00000;">周期性的ping每个worker。如果在一个约定的时间范围内没有收到worker返回的信息，</span><span style="color:#c00000;">Master</span><span style="color:#c00000;">将把这个worker标记为失效。</span><span style="color:#0c0c0c;">所有由这个失效的worker完成的Map任务被重</span><span style="color:#0c0c0c;">置</span><span style="color:#0c0c0c;">为初始的空闲状态，之后这些任务就可以被安排给其</span><span style="color:#0c0c0c;">它</span><span style="color:#0c0c0c;">的worker。同样的，worker失效时正在运行的Map或Reduce任务也将被重新置为空闲状态，等待重新调度。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#c00000;">当worker故障时，由于已经完成的</span><span style="color:#c00000;">Map任务的输出存储在</span><span style="color:#c00000;">本地</span><span style="color:#c00000;">，Map任务的输出已不可访问了，因此必须重新执行。而已经完成的Reduce任务的输出存储在全局文件系统上，因此不需要再次执行。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">当一个Map任务首先被worker A执行，之后由于worker A失效了又被调度到worker B执行，这个</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">重新执行</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">的动作会被通知给所有执行Reduce任务的worker。任何还没有从worker A读取数据的Reduce任务将从worker B读取数据。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">MapReduce可以处理大规模worker失效的情况。比如，在一个MapReduce操作执行期间，在正在运行的集群上进行网络维护引起80台机器在几分钟内不可访问了，MapReduce </span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">只需要简单的再次执行那些不可访问的worker完成的工作，之后继续执行未完成的任务，直到最终完成这个MapReduce操作。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;"><strong><span style="color:#0c0c0c;"><strong>Master</strong></span></strong><strong><span style="color:#0c0c0c;"><strong>失败</strong></span></strong></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">一个简单的解决办法是让</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">周期性的将上面描述的数据结构的写入磁盘，即检查点（checkpoint）。如果这个</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">任务失效了，可以从最后一个检查点（checkpoint）开始启动另一个</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">进程。</span><span style="color:#c00000;">然而，</span><span style="color:#c00000;">由于只有一个</span><span style="color:#c00000;">Master</span><span style="color:#c00000;">进程，</span><span style="color:#c00000;">Master</span><span style="color:#c00000;">失效后再恢复是比较麻烦的，因此我们现在的实现是如果</span><span style="color:#c00000;">Master</span><span style="color:#c00000;">失效，就中止MapReduce运算。</span><span style="color:#0c0c0c;">客户可以检查到这个状态，并且可以根据需要重新执行MapReduce操作。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <p style="margin-left:0pt;"><strong><span style="color:#0c0c0c;"><strong>在失效方面的处理机制</strong></span></strong></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">当用户提供的Map和Reduce操作是输入确定性函数（即相同的输入产生相同的输出）时，</span><span style="color:#c00000;">我们的分布式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#c00000;">我们依赖对Map和Reduce任务的输出是原子提交的来完成这个特性。</span><span style="color:#0c0c0c;">每个工作中的任务把它的输出写到私有的临时文件中。每个Reduce任务生成一个这样的文件，而每个Map任务则生成R个这样的文件（一个Reduce任务对应一个文件）。当一个Map任务完成的时，worker发送一个包含R个临时文件名的完成消息给</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">。如果</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">从一个已经完成的Map任务再次接收到到一个完成消息，</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">将忽略这个消息；否则，</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">将这R个文件的名字记录在数据结构里。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">当Reduce任务完成时，Reduce worker进程以原子的方式把临时文件重命名为最终的输出文件。如果同一个Reduce任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名操作执行。</span><span style="color:#c00000;">我们依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个Reduce任务产生的数据。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">使用MapReduce模型的程序员可以很容易的理解</span><span style="color:#0c0c0c;">它们</span><span style="color:#0c0c0c;">程序的行为，因为我们绝大多数的Map和Reduce操作是确定的，而且存在这样的一个事实：我们的失效处理机制等价于一个顺序的执行的操作。</span><span style="color:#c00000;">当Map和</span><span style="color:#c00000;">/或</span><span style="color:#c00000;">Reduce操作是不确定性的时候，我们提供虽然较弱但是依然合理的处理机制。当使用非确定操作的时候，一个Reduce任务R1的输出等价于一个非确定性程序</span><span style="color:#c00000;">的</span><span style="color:#c00000;">顺序执行产生的输出</span><span style="color:#0c0c0c;">(In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output for R1 produced by a sequential execution of the non-deterministic program.)</span><span style="color:#0c0c0c;">。</span><span style="color:#c00000;">但是，另一个不同的Reduce任务R2的输出也许符合一个非确定</span><span style="color:#c00000;">程序的非</span><span style="color:#c00000;">顺序执行产生的R2的输出</span><span style="color:#0c0c0c;">(However, the output for a different reduce task R2 may correspond to the output for R2 produced by a different sequential execution of the non-deterministic program.)</span><span style="color:#0c0c0c;">。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">考虑Map任务M和Reduce任务R1、R2的情况。我们设定e(Ri)是Ri已经提交的执行过程（有且仅有一个这样的执行过程）。语义较弱是因为e（</span><span style="color:#0c0c0c;">R</span><span style="color:#0c0c0c;">1）可能读取了</span><span style="color:#0c0c0c;">M</span><span style="color:#0c0c0c;">的一次执行产生的输出，e（</span><span style="color:#0c0c0c;">R</span><span style="color:#0c0c0c;">2）可能读取了</span><span style="color:#0c0c0c;">M</span><span style="color:#0c0c0c;">的另一次执行产生的输出。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="3.4%C2%A0%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">3.4</span>&nbsp;<span style="color:#0c0c0c;">存储位置</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#c00000;">在我们的计算运行环境中，网络带宽是一个相当匮乏的资源。我们通过尽量把输入数据(由GFS管理)存储在集群中机器的本地磁盘上来节省网络带宽。</span><span style="color:#0c0c0c;">GFS把每个文件按64MB一个Block分</span><span style="color:#0c0c0c;">割</span><span style="color:#0c0c0c;">，每个Block保存在多台机器上，环境中存放了多份拷贝(一般是3个拷贝)。</span><span style="color:#c00000;">MapReduce的</span><span style="color:#c00000;">Master</span><span style="color:#c00000;">在调度Map任务时会考虑输入文件的位置信息，尽量将一个Map任务调度在包含相关输入数据拷贝的机器上执行；如果上述努力失败了，</span><span style="color:#c00000;">Master</span><span style="color:#c00000;">将尝试在保存有输入数据拷贝的机器附近的机器上执行Map任务</span><span style="color:#0c0c0c;">(例如，分配到一个和包含输入数据的机器在一个switch里的worker机器上执行)。当在一个足够大的cluster集群上运行大型MapReduce操作的时候，大部分的输入数据都能从本地机器读取，因此消耗非常少的网络带宽。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="3.5%C2%A0%E4%BB%BB%E5%8A%A1%E7%B2%92%E5%BA%A6" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">3.5</span>&nbsp;<span style="color:#0c0c0c;">任务粒度</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">我们将</span><span style="color:#0c0c0c;">M</span><span style="color:#0c0c0c;">ap阶段细分为</span><span style="color:#0c0c0c;">M</span><span style="color:#0c0c0c;">个片段，</span><span style="color:#0c0c0c;">R</span><span style="color:#0c0c0c;">educe阶段细分为</span><span style="color:#0c0c0c;">R</span><span style="color:#0c0c0c;">个片段，如上所述。理想情况下，M和R应该远大于worker机器的数量。让每个worker</span><span style="color:#0c0c0c;">执行</span><span style="color:#0c0c0c;">许多不同任务改善了动态负载平衡，并在worker失败时加快了恢复速度：它完成的许多映射任务可以分布在所有其</span><span style="color:#0c0c0c;">它</span><span style="color:#0c0c0c;">worker机器上。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">在我们的实现中，M和R的大小有实际的界限，因为</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">必须做出O（M+R）调度决策，并在内存中保持O（M</span><span style="color:#0c0c0c;">*</span><span style="color:#0c0c0c;">R）状态，如上文所述。（但是，内存使用的常量因素很小：状态的O（M*R）部分由每个映射任务/减少任务对大约</span><span style="color:#0c0c0c;">1</span><span style="color:#0c0c0c;">个字节的数据组成。）更进一步，R值通常是由用户指定的，因为每个Reduce任务最终都会生成一个独立的输出文件。实际使用时我们也倾向于选择合适的M值，以使得每一个独立任务都是处理大约16M到64M的输入数据（这样，上面描写的输入数据本地存储优化策略才最有效），另外，我们把R值设置为我们想使用的worker机器数量的几</span><span style="color:#0c0c0c;">倍</span><span style="color:#0c0c0c;">(small multiple)</span><span style="color:#0c0c0c;">。我们通常会用这样的比例来执行MapReduce：M=200000，R=5000，使用2000台worker机器。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="3.6%C2%A0%E5%A4%87%E7%94%A8%E4%BB%BB%E5%8A%A1(Backup%20Tasks)" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">3.6</span>&nbsp;<span style="color:#0c0c0c;">备用任务</span><span style="color:#0c0c0c;">(Backup Tasks)</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">影响一个MapReduce的总执行时间最通常的因素是</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">落伍者</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">：</span><span style="color:#c00000;">在运算过程中，如果有一台机器花了很长的时间才完成最后几个Map或Reduce任务，导致MapReduce操作总的执行时间超过预期。</span><span style="color:#0c0c0c;">出现</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">落伍者</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">的原因非常多。比如：如果一个机器的硬盘出了问题，在读取的时候要经常的进行读取纠错操作，导致读取数据的速度从30M/s降低到1M/s。如果cluster的调度系统在这台机器上又调度了</span><span style="color:#0c0c0c;">其它</span><span style="color:#0c0c0c;">的任务，由于CPU、内存、本地硬盘和网络带宽等竞争因素的存在，导致执行MapReduce代码的执行效率更加缓慢。我们最近遇到的一个问题是由于机器的初始化代码有bug，导致关闭了的处理器的缓存：在这些机器上执行任务的性能和正常情况相差上百倍。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">我们有一个通用的机制来减少</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">落伍者</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">出现的情况。</span><span style="color:#c00000;">当一个MapReduce操作接近完成的时候，</span><span style="color:#c00000;">Master</span><span style="color:#c00000;">调度备用（backup）任务进程来执行剩下的、处于</span><span style="color:#c00000;">运行</span><span style="color:#c00000;">中状态（in-progress）的任务。无论是最初的执行进程、还是备用（backup）任务进程完成了任务，我们都把这个任务标记成为已经完成。</span><span style="color:#0c0c0c;">我们调优了这个机制，通常只会占用比正常操作多几个百分点的计算资源。我们发现采用这样的机制对于减少超大MapReduce操作的总处理时间效果显著。例如，在5.3节描述的排序任务，在关闭掉备用任务的情况下要多花44%的时间完成排序任务。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h1 id="4%C2%A0%E6%8A%80%E5%B7%A7" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">4</span>&nbsp;<span style="color:#0c0c0c;">技巧</span></strong></h1> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">虽然简单的Map和Reduce函数提供的基本功能已经能够满足大部分的计算需要，我们还是发掘出了一些有价值的扩展功能。本节将描述这些扩展功能。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="4.1%C2%A0%E5%88%86%E5%8C%BA%E5%87%BD%E6%95%B0%C2%A0%C2%A0" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">4.1</span>&nbsp;<span style="color:#0c0c0c;">分区函数</span>&nbsp;&nbsp;</strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">MapReduce的使用者通常会指定Reduce任务和Reduce任务输出文件的数量（R）。</span><span style="color:#c00000;">我们在中间key上使用分区函数来对数据进行分区，之后再输入到后续任务执行进程。一个缺省的分区函数是使用hash方法(比如，hash(key) mod R)进行分区。</span><span style="color:#0c0c0c;">hash方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对key值进行的分区将非常有用。比如，输出的key值是URLs，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce库的</span><span style="color:#0c0c0c;">使用者</span><span style="color:#0c0c0c;">需要提供专门的分区函数。例如，使用</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">hash(Hostname(urlkey)) mod R</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">作为分区函数就可以把所有来自同一个主机的URLs保存在同一个输出文件中。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="4.2%C2%A0%E9%A1%BA%E5%BA%8F%E4%BF%9D%E8%AF%81" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">4.2</span>&nbsp;<span style="color:#0c0c0c;">顺序保证</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">我们确保在给定的分区中，中间key/value pair数据的处理顺序是按照key值增量顺序处理的。这样的顺序保证对每个分</span><span style="color:#0c0c0c;">区</span><span style="color:#0c0c0c;">生成一个有序的输出文件，这对于需要对输出文件按key值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="4.3%C2%A0Combiner%E5%87%BD%E6%95%B0" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">4.3</span>&nbsp;<span style="color:#0c0c0c;">Combiner</span><span style="color:#0c0c0c;">函数</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">在某些情况下，Map函数产生的中间key值的重复数据会占很大的比重，并且，用户自定义的Reduce函数满足结合律和交换律。在2.1节的词数统计程序是个很好的例子。由于词频率倾向于一个zipf分布(齐夫分布)，每个Map任务将产生成千上万个这样的记录&lt;the,1&gt;。所有的这些记录将通过网络被发送到一个单独的Reduce任务，然后由这个Reduce任务把所有这些记录累加起来产生一个数字。</span><span style="color:#c00000;">我们允许用户指定一个可选的</span><span style="color:#c00000;">Combiner</span><span style="color:#c00000;">函数，</span><span style="color:#c00000;">Combiner</span><span style="color:#c00000;">函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">Combiner</span><span style="color:#0c0c0c;">函数在每台执行Map任务的机器上都会被执行一次。一般情况下，</span><span style="color:#0c0c0c;">Combiner</span><span style="color:#0c0c0c;">和Reduce函数是一样的。</span><span style="color:#c00000;">Combiner</span><span style="color:#c00000;">函数和Reduce函数之间唯一的区别是MapReduce库怎样控制函数的输出。Reduce函数的输出被保存在最终的输出文件里，而</span><span style="color:#c00000;">Combiner</span><span style="color:#c00000;">函数的输出被写到中间文件里，然后被发送给Reduce任务。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">合并中间结果可以显著的提高一些MapReduce操作的速度。附录A包含一个使用</span><span style="color:#0c0c0c;">Combiner</span><span style="color:#0c0c0c;">函数的例子。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="4.4%C2%A0%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E7%9A%84%E7%B1%BB%E5%9E%8B" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">4.4</span>&nbsp;<span style="color:#0c0c0c;">输入和输出的类型</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">MapReduce库支持几种不同格式的输入数据。比如，文本模式的输入数据的每一行被视为是一个key/value pair。key是文件的偏移量，value是那一行的内容。另外一种常见的格式是以key进行排序来存储的key/value pair的序列。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单独的Map任务来进行后续处理(例如，文本模式的范围分割必须确保仅仅在每行的边界进行范围分割)。虽然大多数MapReduce的使用者仅仅使用很少的预定义输入类型就满足要求了，但是使用者依然可以通过提供一个简单的Reader接口就能够支持一个新的输入类型。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">Reader并非一定要从文件中读取数据，比如，我们可以很容易的实现一个从数据库里读记录的Reader，或者从内存中的数据结构读取数据的Reader。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">类似的，我们提供了一些预定义的输出数据类型，通过这些预定义类型能够产生不同格式的数据。用户采用类似添加新的输入数据类型的方式增加新的输出类型。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="4.5%C2%A0%E5%89%AF%E4%BD%9C%E7%94%A8" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">4.5</span>&nbsp;<span style="color:#0c0c0c;">副作用</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#c00000;">在某些情况下，MapReduce的使用者发现，如果在Map和/或Reduce操作</span><span style="color:#c00000;">(map and/or reduce operators.)</span><span style="color:#c00000;">过程中增加辅助的输出文件会比较省事。</span><span style="color:#0c0c0c;">我们依靠程序writer把这种</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">副作用</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">变成原子的</span><span style="color:#0c0c0c;">以及</span><span style="color:#0c0c0c;">幂等的。通常应用程序首先把输出结果写到一个临时文件中，在输出全部数据之后，在使用系统级的原子操作rename重新命名这个临时文件。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">我们不支持由单个任务生成的多个输出文件的原子两阶段提交，因此，生成具有跨文件一致性要求的多个输出文件的任务应该是确定性的。这种限制在实践中从未成为一个问题。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="4.6%C2%A0%E8%B7%B3%E8%BF%87%E6%8D%9F%E5%9D%8F%E7%9A%84%E8%AE%B0%E5%BD%95" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">4.6</span>&nbsp;<span style="color:#0c0c0c;">跳过损坏的记录</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">有时候，用户程序中的bug导致Map或者Reduce函数在处理某些记录的时候crash掉，MapReduce操作无法顺利完成。惯常的做法是修复bug后再次执行MapReduce操作，但是，有时候找出这些bug并修复它们不是一件容易的事情；这些bug也许是在第三方库里，而我们手头没有这些库的源代码。而且在很多时候，忽略一些有问题的记录也是可以接受的，比如在一个巨大的数据集上进行统计分析的时候。我们提供了一种可选的执行模式，其中MapReduce库检测哪些记录会导致确定性crash，并跳过这些记录以向前推进。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">每个worker进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus</span>&nbsp;<span style="color:#0c0c0c;">error）。在执行Map或者Reduce操作之前，MapReduce库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，消息处理函数将用</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">最后一口气</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">通过UDP包向</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">发送处理的最后一条记录的序号。当</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">看到在处理某条特定记录不止失败一次时，</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">就标志</span><span style="color:#0c0c0c;">这</span><span style="color:#0c0c0c;">条记录需要被跳过，并且在下次重新执行相关的Map或者Reduce任务的时候跳过这条记录。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="4.7%C2%A0%E6%9C%AC%E5%9C%B0%E6%89%A7%E8%A1%8C" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">4.7</span>&nbsp;<span style="color:#0c0c0c;">本地执行</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">调试Map和Reduce函数的bug是非常困难的，因为实际执行操作时不但是分布在系统中执行的，而且通常是在好几千台计算机上执行，具体的执行位置是由</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">进行动态调度的，这又大大增加了调试的难度。为了简化调试、</span><span style="color:#333333;">性能分析</span><span style="color:#0c0c0c;">和小规模测试，我们开发了一套MapReduce库的本地实现版本，通过使用本地版本的MapReduce库，MapReduce操作在本地计算机上顺序执行。用户可以控制MapReduce操作的执行，可以把操作限制到特定的Map任务上。用户通过设定特别的标志来在本地执行</span><span style="color:#0c0c0c;">它们</span><span style="color:#0c0c0c;">的程序，之后就可以很容易的使用本地调试和测试工具（比如gdb）。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="4.8%C2%A0%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">4.8</span>&nbsp;<span style="color:#0c0c0c;">状态信息</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">主服务器运行内部HTTP服务器并导出一组状态页供人使用。状态页显示计算的进度，例如已完成的任务数、正在进行的任务数、输入字节数、中间数据字节数、输出字节数、处理速率等。这些页还包含指向每个任务生成的标准错误和标准输出文件的链接。用户可以使用这些数据来预测计算将花费多长时间，以及是否应向计算中添加更多的资源。这些页面还可用于确定计算速度比预期慢得多的时间。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">此外，顶级状态页面显示哪些worker失败，以及哪些失效的时候正在运行的Map和Reduce任务。当试图</span><span style="color:#0c0c0c;">调试</span><span style="color:#0c0c0c;">用户代码中的错误时，此信息非常有用。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="4.9%C2%A0%E8%AE%A1%E6%95%B0%E5%99%A8" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">4.9</span>&nbsp;<span style="color:#0c0c0c;">计数器</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">MapReduce库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇German文档等等。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">为了使用这个特性，用户在程序中创建一个命名的计数器对象，在Map和Reduce函数中相应的增加计数器的值。例如：</span></p> 
  <pre class="has">
<code>Counter* uppercase;
uppercase = GetCounter("uppercase");

map(String name, String contents):
    for each word w in contents: 
        if (IsCapitalized(w)): 
            uppercase-&gt;Increment(); 
        EmitIntermediate(w, "1"); </code></pre> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">这些计数器的值周期性的从各个单独的worker机器上传递给</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">（附加在ping的应答包中传递）。</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">把执行成功的Map和Reduce任务的计数器值进行累计，当MapReduce操作完成之后，返回给用户代码。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">计数器当前的值也会显示在</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器的值的时候，</span><span style="color:#0c0c0c;">Master</span><span style="color:#0c0c0c;">要检查重复运行的Map或者Reduce任务，避免重复累加（之前提到的备用任务和失效后重新执行任务这两种情况会导致相同的任务被多次执行）。有些计数器的值是由MapReduce库自动维持的，比如已经处理的输入的key/value pair的数量、输出的key/value pair的数量等等。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">计数器机制对于MapReduce操作的完整性检查非常有用。比如，在某些MapReduce操作中，用户需要确保</span><span style="color:#0c0c0c;">产生的</span><span style="color:#0c0c0c;">output pairs精确的等于</span><span style="color:#0c0c0c;">处理的</span><span style="color:#0c0c0c;">input pairs，或者处理的German文档数量在</span><span style="color:#0c0c0c;">被</span><span style="color:#0c0c0c;">处理的整个文档数量中属于合理范围。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h1 id="5%C2%A0%E6%80%A7%E8%83%BD" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">5</span>&nbsp;<span style="color:#0c0c0c;">性能</span></strong></h1> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">本节我们</span><span style="color:#0c0c0c;">分析</span><span style="color:#0c0c0c;">在一个大型集群上运行的两个计算来衡量MapReduce的性能。一个计算</span><span style="color:#0c0c0c;">是</span><span style="color:#0c0c0c;">在大约1TB的数据中进行特定的模式匹配，另一个计算对大约1TB的数据进行排序。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">这两个程序在大量</span><span style="color:#0c0c0c;">使用</span><span style="color:#0c0c0c;">的MapReduce应用中是非常</span><span style="color:#0c0c0c;">具有代表性</span><span style="color:#0c0c0c;">的</span><span style="color:#0c0c0c;">——</span><span style="color:#c00000;">一类是对数据格式进行转换，从一种表现形式转换为另外一种表现形式；另一类是从海量数据中抽取少部分用户感兴趣的数据。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="5.1%C2%A0%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">5.1</span>&nbsp;<span style="color:#0c0c0c;">集群配置</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">所有这些程序都运行在一个由大约1800台机器构成的集群上。每台机器配置2个2G主频、支持超线程的Intel Xeon处理器，4GB的物理内存，两个160GB的IDE硬盘和一个千兆以太网卡。这些机器部署在一个两层的树形交换网络中，在root节点大概有100-200GBPS的传输带宽。所有这些机器都采用相同的部署（对等部署），因此任意两点之间的网络往返时延</span><span style="color:#0c0c0c;">小于1毫秒。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">在4GB内存里，大概有1-1.5G用于运行集群上的</span><span style="color:#0c0c0c;">其它</span><span style="color:#0c0c0c;">任务。测试程序在周末下午开始执行，这时主机的CPU、磁盘和网络基本上处于空闲状态。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="5.2%C2%A0Grep(%E4%B8%80%E7%A7%8D%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7)" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">5.2</span>&nbsp;<span style="color:#0c0c0c;">Grep</span><span style="color:#0c0c0c;">(</span><span style="color:#333333;">一种强大的文本搜索工具</span><span style="color:#0c0c0c;">)</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">这个分布式的</span><span style="color:#0c0c0c;">Grep</span><span style="color:#0c0c0c;">程序需要扫描大概10的10次方个由100个字节组成的记录，查找出现概率较小的3个字符的模式（这个模式在92337个记录中出现）。输入数据被拆分成大约64M的Block（M=15000），整个输出数据存放在一个文件中（R=1）。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512221207772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70"></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">图2显示了这个运算随时间的处理过程。其中Y轴表示输入数据的处理速度。处理速度随着参与MapReduce计算的机器数量的增加而增加，当1764台worker参与计算的时，处理速度达到了30GB/s。当Map任务结束的时候，即在计算开始后80秒，输入的处理速度降到0。整个计算过程从开始到结束一共花了大概150秒。这包括了大约一分钟的初始启动阶段。初始启动阶段消耗的时间包括了把这个程序传送到各个worker机器上的时间、等待GFS文件系统打开1000个输入文件集合的时间、获取相关的文件本地位置优化信息的时间。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="5.3%C2%A0%E6%8E%92%E5%BA%8F" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">5.3</span>&nbsp;<span style="color:#0c0c0c;">排序</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">排序程序处理10的10次方个100个字节组成的记录（大</span><span style="color:#0c0c0c;">约</span><span style="color:#0c0c0c;">1TB的数据）。这个程序模仿TeraSort</span>&nbsp;<span style="color:#0c0c0c;">benchmark。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">排序程序由不到50行代码组成。只有三行的Map函数从文本行中解析出10个字节的key值作为排序的key，并且把这个key和原始文本行作为中间的key/value pair值输出。我们使用了一个内置的恒等函数</span><span style="color:#0c0c0c;">(Identity function)</span><span style="color:#0c0c0c;">作为</span><span style="color:#0c0c0c;">R</span><span style="color:#0c0c0c;">educe操作函数，这个函数把中间key/value pair不作任何改变输出。最终排序的输出被写入一组双</span><span style="color:#0c0c0c;">路</span><span style="color:#0c0c0c;">复制的</span><span style="color:#0c0c0c;">GFS</span><span style="color:#0c0c0c;">文件中（也就是说，程序输出2TB的数据）。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">如前所述，输入数据被分成64MB的Block（M=15000）。我们把排序后的输出结果分区后存储到4000个文件（R=4000）。分区函数使用key的原始字节来把数据分区到R个片段中。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">在这个benchmark测试中，我们使用的分区函数知道key的分区情况。通常对于排序程序来说，我们会增加一个预处理的MapReduce操作用于采样key值的分布情况，通过采样的数据来计算对最终排序处理的分区</span><span style="color:#0c0c0c;">点。</span><span style="color:#0c0c0c;">(从上到下分别是Input、Shuffle和Output)</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512221230819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70"></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">图三（a）显示了这个排序程序的正常执行过程。左上的图显示了</span><span style="color:#0c0c0c;">Input</span><span style="color:#0c0c0c;">数据读取的速度。数据读取速度峰值会达到13GB/s，并且所有Map任务</span><span style="color:#0c0c0c;">在</span><span style="color:#0c0c0c;">大约200秒</span><span style="color:#0c0c0c;">之前</span><span style="color:#0c0c0c;">完成，</span><span style="color:#0c0c0c;">然</span><span style="color:#0c0c0c;">后迅速滑落</span><span style="color:#0c0c0c;">至</span><span style="color:#0c0c0c;">0。值得注意的是，排序程序输入数据读取速度小于分布式</span><span style="color:#0c0c0c;">Grep</span><span style="color:#0c0c0c;">程序。这是因为排序程序的Map任务花了大约一半的处理时间和I/O带宽把中间输出结果写到本地硬盘。相应的分布式</span><span style="color:#0c0c0c;">Grep</span><span style="color:#0c0c0c;">程序的中间结果输出几乎可以忽略不计。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">左边中间的图显示了中间数据从Map任务发送到Reduce任务的网络速度。这个过程从第一个Map任务完成之后就开始缓慢启动</span><span style="color:#0c0c0c;">(shuffling)</span><span style="color:#0c0c0c;">了。图示的第一个高峰是启动了第一批</span><span style="color:#0c0c0c;">约</span><span style="color:#0c0c0c;">1700个Reduce任务（整个MapReduce分布到大概1700台机器上，每台机器1次最多执行1个Reduce任务）。排序程序运行大约300秒后，第一批启动的Reduce任务</span><span style="color:#0c0c0c;">只有部分</span><span style="color:#0c0c0c;">完成，我们开始执行剩下的Reduce任务。所有的处理在大约600秒后结束。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">左下图表示Reduce任务把排序后的数据写到最终的输出文件的速度。在第一个</span><span style="color:#0c0c0c;">shuffling</span><span style="color:#0c0c0c;">阶段结束和数据开始写入磁盘之间有延时，这是因为worker机器正在忙于排序中间数据。磁盘写入速度在2-4GB/s持续一段时间。输出数据写入磁盘大约持续850秒。计入初始启动部分的时间，整个运算消耗了891秒。这个速度和TeraSort benchmark的最高纪录1057秒相差不多。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">需要注意的一点是：由于我们的</span><span style="color:#0c0c0c;">本地化输入数据优化策略</span><span style="color:#0c0c0c;">，</span><span style="color:#0c0c0c;">Input</span><span style="color:#0c0c0c;">速率高于</span><span style="color:#0c0c0c;">Shuffle</span><span style="color:#0c0c0c;">速率和</span><span style="color:#0c0c0c;">Output</span><span style="color:#0c0c0c;">速率——大多数数据是从本地磁盘读取的，并绕过我们相对受限的网络带宽。</span><span style="color:#0c0c0c;">Shuffle</span><span style="color:#0c0c0c;">速率高于</span><span style="color:#0c0c0c;">Output</span><span style="color:#0c0c0c;">速率，因为输出阶段会写入两份已排序数据的副本（我们</span><span style="color:#0c0c0c;">写</span><span style="color:#0c0c0c;">两份输出的副本</span><span style="color:#0c0c0c;">的原因是为了</span><span style="color:#0c0c0c;">可靠性和可用性）。我们编写两个副本，因为这是底层文件系统提供的可靠性和可用性机制。如果底层文件系统使用</span><span style="color:#0c0c0c;">纠删码</span><span style="color:#0c0c0c;">(erasure coding)</span><span style="color:#0c0c0c;">而不是复制，则写入数据的网络带宽需求将减少。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="5.4%C2%A0%E9%AB%98%E6%95%88%E7%9A%84backup%E4%BB%BB%E5%8A%A1" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">5.4</span>&nbsp;<span style="color:#0c0c0c;">高效的backup任务</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">图三（b）</span><span style="color:#0c0c0c;">展示</span><span style="color:#0c0c0c;">关闭备用任务后排序程序执行情况。执行的过程和图3（a）很相似，除了有一条非常长的尾巴，几乎没有任何写操作发生。在960秒后，只有5个Reduce任务没有完成。这些拖后腿的任务又执行了300秒才完成。整个计算消耗了1283秒，多了44%的执行时间。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="5.5%C2%A0%E5%A4%B1%E6%95%88%E7%9A%84%E6%9C%BA%E5%99%A8" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">5.5</span>&nbsp;<span style="color:#0c0c0c;">失效的机器</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">在图三（c）演示</span><span style="color:#0c0c0c;">在</span><span style="color:#0c0c0c;">排序程序执行的过程中，我们在程序开始后几分钟有意的kill了1746个worker中的200个。集群底层的调度立刻在这些机器上重新开始新的worker处理进程（因为只是worker机器上的处理进程被kill了，机器本身还在工作）。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">图三（c）显示出了一个</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">负</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">的输入数据读取速度，这是因为一些已经完成的Map任务丢失了（由于相应的执行Map任务的worker进程被kill了），需要重新执行这些任务。相关Map任务很快就被重新执行了。整个运算在933秒内完成，包括了初始启动时间（只比正常执行多消耗了5%的时间）。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h1 id="6%C2%A0%E7%BB%8F%E9%AA%8C" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">6</span>&nbsp;<span style="color:#0c0c0c;">经验</span></strong></h1> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">我们在2003年1月完成了第一个版本的MapReduce库，2003年8月的版本有了显著的增强，这包括了输入数据本地优化、worker机器之间的动态负载均衡等等。从那以后，我们惊喜的发现，MapReduce库能广泛应用于我们日常工作中遇到的各类问题。它现在在Google内部各个领域得到广泛应用，包括：</span></p> 
  <blockquote> 
   <ol>
    <li><span style="color:#0c0c0c;">大规模机器学习问题</span></li> 
    <li><span style="color:#0c0c0c;">Google News和Froogle产品的集群问题</span></li> 
    <li><span style="color:#0c0c0c;">从公众查询产品（比如Google的Zeitgeist）的报告中抽取数据。</span></li> 
    <li><span style="color:#0c0c0c;">从大量的新应用和新产品的网页中提取有用信息（比如，从大量的位置搜索网页中抽取地理位置信息）。</span></li> 
    <li><span style="color:#0c0c0c;">大规模的图形计算。</span></li> 
   </ol>
  </blockquote> 
  <p style="margin-left:0pt;"><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051222135899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70"></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">图四显示了在我们的源代码管理系统中，随着时间推移，独立的MapReduce程序数量的显著增加。从2003年早些时候的0个增长到2004年9月份的差不多900个不同的程序。MapReduce的成功取决于采用MapReduce库能够在不到半个小时内写出一个简单的程序，这个简单的程序能够在上千台机器组成的集群上做大规模并</span><span style="color:#0c0c0c;">行</span><span style="color:#0c0c0c;">处理，这极大的加快了开发和原形设计</span><span style="color:#0c0c0c;">(prototyping cycle)</span><span style="color:#0c0c0c;">的周期。另外，采用MapReduce库，可以让完全没有分布式和/或并行系统开发经验的程序员很容易的利用大量的资源，开发出分布式和/或并行处理的应用。</span></p> 
  <p style="margin-left:0pt;"><img alt="" class="has" height="292" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190517093941507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70" width="678"></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">在每个任务结束的时候，MapReduce库统计计算资源的使用状况。在表1，我们列出了2004年8月份MapReduce运行的任务所占用的相关资源。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h2 id="6.1%C2%A0%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%B4%A2%E5%BC%95" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">6.1</span>&nbsp;<span style="color:#0c0c0c;">大规模索引</span></strong></h2> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">到目前为止，MapReduce最成功的应用就是重写了Google网络搜索服务所使用到的index系统。索引系统的输入数据是网络爬虫抓取回来的海量的文档，这些文档数据都保存在GFS文件系统里。这些文档</span><span style="color:#0c0c0c;">的</span><span style="color:#0c0c0c;">原始内容的大小超过了20TB。索引程序是通过一系列的MapReduce操作（大约5到10次）来建立索引。使用MapReduce（替换上一个特别设计的、分布式处理的索引程序）带来这些好处：</span></p> 
  <blockquote> 
   <ol>
    <li><span style="color:#0c0c0c;">实现索引部分的代码简单、小巧、容易理解，因为对于容错、分布式以及并行计算的处理都是MapReduce库提供的。比如，使用MapReduce库，计算的代码行数从原来的3800行C++代码减少到大</span><span style="color:#0c0c0c;">约</span><span style="color:#0c0c0c;">700行代码。</span></li> 
    <li><span style="color:#0c0c0c;">MapReduce库的性能已经足够好了，因此我们可以把在概念上不相关的计算步骤分开处理，而不是混在一起以减少数据传递的额外消耗。概念上不相关的计算步骤的隔离也使得我们可以很容易改变索引处理方式。比如，对之前的索引系统的一个小更改可能要耗费好几个月的时间，但是在使用MapReduce的新系统上，这样的更改只需要花几天时间就可以了。</span></li> 
    <li><span style="color:#0c0c0c;">索引系统的操作管理更容易了。因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝大部分问题都已经由MapReduce库解决了，不再需要操作人员的介入。另外，我们可以通过在索引系统集群中增加机器的简单方法提高整体处理性能。</span></li> 
   </ol>
  </blockquote> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h1 id="7%C2%A0%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">7</span>&nbsp;<span style="color:#0c0c0c;">相关工作</span></strong></h1> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">很多系统都提供了严格的编程模式，并且通过对编程的严格限制来实现并行计算。例如，一个结合函数可以通过把N个元素的数组的前缀在N个处理器上使用并行前缀算法，在log N的时间内计算完。根据我们对大型实际</span><span style="color:#0c0c0c;">环境</span><span style="color:#0c0c0c;">计算的经验，可以将MapReduce视为对其中一些模型的简化和提炼。</span><span style="color:#0c0c0c;">(MapReduce can be considered a simplification and distillation of some of these models based on our experience with large real-world computations.)</span><span style="color:#0c0c0c;">。更加值得骄傲的是，我们还实现了基于上千台处理器的集群的容错处理。相比而言，大部分并发处理系统都只在小规模的集群上实现，并且把容错处理交给了程序员。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">Bulk Synchronous Programming和一些MPI原语提供了更高级别的并行处理抽象，可以更容易</span><span style="color:#0c0c0c;">的</span><span style="color:#0c0c0c;">写出并行处理的程序。MapReduce和这些系统的</span><span style="color:#0c0c0c;">主要</span><span style="color:#0c0c0c;">不同之处在于，MapReduce利用限制性编程模式实现了用户程序的自动并发处理，并且提供了透明的容错处理。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">我们数据本地优化策略的灵感来源于active disks等技术，</span><span style="color:#c00000;">在active disks中，计算任务是尽量推送到数据</span><span style="color:#c00000;">所</span><span style="color:#c00000;">存储的节点处理，这样就减少了网络和IO子系统的吞吐量。</span><span style="color:#0c0c0c;">我们在挂载几个硬盘的普通机器上执行我们的运算，而不是在磁盘处理器上执行我们的工作，但是达到的目的一样的。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">我们的备用任务机制和Charlotte System提出的eager调度机制比较类似。</span><span style="color:#c00000;">Eager调度机制的一个缺点是如果一个任务反复失效，那么整个计算就不能完成。我们通过忽略引起故障的记录的方式在某种程度上解决了这个问题。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">MapReduce的实现依赖于一个内部的集群管理系统，这个集群管理系统负责在一个超大的、共享机器的集群上分布和运行用户任务。虽然这个不是本论文的重点，但是有必要提一下，这个集群管理系统在理念上和其它系统，如Condor是一样。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">MapReduce库的排序机制和NOW-Sort的操作很类似。读取输入源的机器（map workers）把待排序的数据进行分区后，发送到R个Reduce worker中的一个进行处理。每个Reduce worker在本地对数据进行排序（尽可能在内存中排序）。当然，NOW-Sort没有给用户自定义的Map和Reduce函数的机会，因此不具备MapReduce库广泛的实用性。River提供了一个编程模型：处理进程通过分布式队列传送数据的方式进行互相通讯。和MapReduce类似，River系统尝试在不对等的硬件环境下，或者在系统颠簸的情况下也能提供近似平均的性能。River是通过精心调度硬盘和网络的通讯来平衡任务的完成时间。MapReduce库采用了其它的方法。通过对编程模型进行限制，MapReduce框架把问题分解成为大量的</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">小</span><span style="color:#0c0c0c;">"</span><span style="color:#0c0c0c;">任务。这些任务在可用的worker集群上动态的调度，这样</span><span style="color:#0c0c0c;">更快的</span><span style="color:#0c0c0c;">worker就可以执行更多的任务。通过对编程模型进行限制，我们可在工作接近完成的时候调度备用任务，在硬件配置不均衡的情况下</span><span style="color:#0c0c0c;">减少</span><span style="color:#0c0c0c;">完成的时间（比如有的worker</span><span style="color:#0c0c0c;">慢</span><span style="color:#0c0c0c;">、或者worker被某些操作阻塞了）。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">BAD-FS采用了和MapReduce完全不同的编程模式，它是面向广域网的。不过，这两个系统有两个基础功能很类似。（1）两个系统采用重新执行的方式来防止由于失效导致的数据丢失。（2）两个都使用数据本地化调度策略，减少网络通讯的数据量。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">TACC是一个高可用网络服务的简化构造系统。和MapReduce一样，它也依靠重新执行机制来实现容错处理。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h1 id="8%C2%A0%E7%BB%93%E6%9D%9F%E8%AF%AD" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">8</span>&nbsp;<span style="color:#0c0c0c;">结束语</span></strong></h1> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">MapReduce编程模型在Google内部成功应用于多个领域。我们把这种成功归结为几个方面：首先，这</span><span style="color:#0c0c0c;">种编程模式</span><span style="color:#0c0c0c;">使得MapReduce库易于使用</span><span style="color:#0c0c0c;">，</span><span style="color:#0c0c0c;">即便对于完全没有并行或者分布式系统开发经验的程序员而言</span><span style="color:#0c0c0c;">也很容易</span><span style="color:#0c0c0c;">。</span><span style="color:#0c0c0c;">这是因为</span><span style="color:#0c0c0c;">MapReduce封装了并行处理、容错处理、数据本地化优化、负载均衡等等技术难点的细节；其次，大量不同类型的问题都可以通过MapReduce简单的解决。比如，MapReduce用于生成Google的网络搜索服务所需要的数据、用来排序、用来数据挖掘、用于机器学习，以及很多其它的系统；第三，我们实现了一个在数千台计算机组成的大型集群上灵活部署</span><span style="color:#0c0c0c;">并</span><span style="color:#0c0c0c;">运行的MapReduce。这个实现使得有效利用这些丰富的计算资源变得非常简单，因此也适合用</span><span style="color:#0c0c0c;">于</span><span style="color:#0c0c0c;">解决Google遇到的</span><span style="color:#0c0c0c;">其它</span><span style="color:#0c0c0c;">很多需要大量计算的问题。</span></p> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">我们也从MapReduce开发过程中学到了不少东西。首先，限制性编程模式使得并行和分布式计算非常容易，也易于构造容错的计算环境；其次，网络带宽是稀有资源。大量的系统优化</span><span style="color:#0c0c0c;">以</span><span style="color:#0c0c0c;">针对减少网络传输量为目的：本地优化策略使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节约了网络带宽；第三，多次执行相同的任务可以减少性能缓慢的机器带来的负面影响，同时解决了由于机器失效导致的数据丢失问题。</span></p> 
  <p style="margin-left:0pt;">&nbsp;</p> 
  <h1 id="%E9%99%84%E5%BD%95A%E3%80%81%E5%8D%95%E8%AF%8D%E9%A2%91%E7%8E%87%E7%BB%9F%E8%AE%A1" style="margin-left:0pt;"><strong><span style="color:#0c0c0c;">附录A、单词频率统计</span></strong></h1> 
  <p style="margin-left:0pt;"><span style="color:#0c0c0c;">本节包含了一个完整的程序，用于统计在一组命令行指定的输入文件中，每一个不同的单词出现频率。</span></p> 
  <pre class="has">
<code>#include "mapreduce/mapreduce.h"
// User’s map function
class WordCounter : public Mapper {
public: 
    virtual void Map(const MapInput&amp; input) 
    { 
        const string&amp; text = input.value(); 
        const int n = text.size();
        for (int i = 0; i &lt; n; ) 
        { // Skip past leading whitespace 
            while((i &lt; n) &amp;&amp; isspace(text[i]))
                i++; 
            // Find word end 
            int start = i;
            while ((i &lt; n) &amp;&amp; !isspace(text[i]))
                i++; 
            if (start &lt; i) 
                Emit(text.substr(start,i-start),"1");
        }
    } 
};

REGISTER_MAPPER(WordCounter);
// User’s reduce function
class Adder : public Reducer {
    virtual void Reduce(ReduceInput* input) { 
    // Iterate over all entries with the
    // same key and add the values 
    int64 value = 0; 
    while (!input-&gt;done()) 
    { 
        value += StringToInt(input-&gt;value()); 
        input-&gt;NextValue(); 
    } // Emit sum for input-&gt;key()
    Emit(IntToString(value)); 
} 
};

REGISTER_REDUCER(Adder);
int main(int argc, char** argv) {
    ParseCommandLineFlags(argc, argv);
    MapReduceSpecification spec; 
    // Store list of input fifiles into "spec" 
    for (int i = 1; i &lt; argc; i++) 
    {
        MapReduceInput* input = spec.add_input();
        input-&gt;set_format("text"); 
        input-&gt;set_filepattern(argv[i]); 	
        input-&gt;set_mapper_class("WordCounter");
    } 
    // Specify the output files: 
    // /gfs/test/freq-00000-of-00100 
    // /gfs/test/freq-00001-of-00100 
    // … 
    MapReduceOutput* out = spec.output(); 	
    out-&gt;set_fifilebase("/gfs/test/freq"); 
    out-&gt;set_num_tasks(100); 	
    out-&gt;set_format("text"); 
    out-&gt;set_reducer_class("Adder"); 
    // Optional: do partial sums within map 
    // tasks to save network bandwidth 
    out-&gt;set_combiner_class("Adder"); 

    //Tuning parameters: use at most 2000 
    //machines and 100 MB of memory per task 
    spec.set_machines(2000); 
    spec.set_map_megabytes(100); 
    spec.set_reduce_megabytes(100);
    //Now run it 
    MapReduceResult result; 
    if (!MapReduce(spec, &amp;result)) abort(); 
    // Done: ‘result’ structure contains info 
    // about counters, time taken, number of 
    // machines used, etc. 
    return 0; 
}</code></pre> 
  <p>&nbsp;</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
