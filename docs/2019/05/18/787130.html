<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>自然语言处理之word2vec | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="自然语言处理之word2vec" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="一、背景 语言模型 &nbsp;- 在统计自然语言处理中，语言模型指的是计算一个句子的概率模型。 &nbsp; &nbsp; 传统的语言模型中词的表示是原始的、面向字符串的。两个语义相似的词的字符串可能完全不同，比如“番茄”和“西红柿”。这给所有NLP任务都带来了挑战——字符串本身无法储存语义信息。该挑战突出表现在模型的平滑问题上：标注语料是有限的，而语言整体是无限的，传统模型无法借力未标注的海量语料，只能靠人工设计平滑算法，而这些算法往往效果甚微。 &nbsp; &nbsp; &nbsp; &nbsp;神经概率语言模型（Neural Probabilistic Language&nbsp;Model）中词的表示是向量形式、面向语义的。两个语义相似的词对应的向量也是相似的，具体反映在夹角或距离上。甚至一些语义相似的二元词组中的词语对应的向量做线性减法之后得到的向量依然是相似的。词的向量表示可以显著提高传统NLP任务的性能，例如《基于神经网络的高性能依存句法分析器》中介绍的词、词性、依存关系的向量化对正确率的提升等。 &nbsp; &nbsp; &nbsp; &nbsp;NLP（自然语言处理）里面，最细粒度的是 词语，词语组成句子，句子再组成段落、篇章、文档。所以处理 NLP 的问题，首先就要拿词语开刀。词语，是人类的抽象总结，是符号形式的（比如中文、英文、拉丁文等等），所以需要**把他们转换成数值形式，或者说——嵌入到一个数学空间里，这种嵌入方式，就叫词嵌入（word embedding)**，而 Word2vec，就是词嵌入（ word embedding) 的一种。简单点来说就是把一个词语转换成对应向量的表达形式，来让机器读取数据。 &nbsp; &nbsp;**从向量的角度来看，字符串形式的词语其实是更高维、更稀疏的向量。** 若词汇表大小为N，每个字符串形式的词语字典序为i，则其被表示为一个N维向量，该向量的第i维为1，其他维都为0。汉语的词汇量大约在十万这个量级，十万维的向量对计算来讲绝对是个维度灾难。**而word2vec得到的词的向量形式（下文简称“词向量”，更学术化的翻译是“词嵌入”）则可以自由控制维度，一般是100左右。** &nbsp;- word2vec作为神经概率语言模型的输入，其本身其实是神经概率模型的副产品，是为了通过神经网络学习某个语言模型而产生的中间结果。具体来说，“某个语言模型”指的是“CBOW”和“Skip-gram”。具体学习过程会用到两个降低复杂度的近似方法——Hierarchical Softmax或Negative Sampling。两个模型乘以两种方法，一共有四种实现。这些内容就是本文理论部分要详细阐明的全部了。 二、理论 1、神经网络语言模型 &nbsp;- 基于神经网络的分布表示又称为词向量或者词嵌入。 2001年， Bengio 等人正式提出神经网络语言模型（ Neural Network Language Model &nbsp; ，NNLM），该模型在学习语言模型的同时，也得到了词向量。所以请注意一点：词向量可以认为是神经网络训练语言模型的副产品。 &nbsp;- 上面说，通过神经网络训练语言模型可以得到词向量，那么，究竟有哪些类型的神经网络语言模型呢？个人所知，大致有这么些：&nbsp; a) Neural Network Language Model ，NNLM&nbsp; b) Log-Bilinear Language Model， LBL&nbsp; c) Recurrent Neural Network based Language Model，RNNLM&nbsp; d) Collobert 和 Weston 在2008 年提出的 C&amp;W 模型&nbsp; e) Mikolov 等人提出了 CBOW（ Continuous Bagof-Words）和 Skip-gram 模型&nbsp; 如今我们主要用到的是CBOW和Skip-gram模型。 我们来梳理一下思路，**要想得到一个词的向量表达方法，并且这个向量的维度很小，而且任意两个词之间是有联系的，可以表示出在语义层面上词语词之间的相关信息。** 我们就需要训练神经网络语言模型，即CBOW和Skip-gram模型。**这个模型的输出我们不关心，我们关心的是模型中第一个隐含层中的参数权重，这个参数矩阵就是我们需要的词向量**。**它的每一行就是词典中对应词的词向量，行数就是词典的大小。**&nbsp; 1.1 模型输入： &nbsp; &nbsp; &nbsp; &nbsp;首先从语料库中搜集一系列长度为n的文本序列 ，然后组成训练集D，我这里的理解是语料库就是我们在特定领域搜集的文本语料，同时还要有一个词典。有了训练数据和词典，下面就来看下模型是怎样进行前向传播的。 这里先对单个语句序列进行计算，也可以说是单个样本，比如：其中&nbsp;,这里的V是所有单词的集合（即词典），&nbsp;表示词典中的第 i 个单词。 NNLM的目标是训练如下模型： 其中表示词序列中第t个单词，表示从第1个词到第t个词组成的子序列。模型需要满足的约束条件是： 上面模型的意思是当给定一段序列时，由其前面的(t-1)个词预测第n个词的概率。 限制条件一：即是通过网络得到的每个概率值都要大于0。 而对于第二个限制条件：因为我们的神经网络模型最终得到的输出是针对每t-1个词的输入来预测下一个，也即是第t个词是什么。因此模型的实际输出是一个向量，该向量的每一个分量依次对应下一个词为词典中某个词的概率。所以|v|维的概率值中必定有一个最大的概率，而其他的概率较小。 （以上参考：https://blog.csdn.net/lilong117194/article/details/82018008 ） &nbsp; NNLM参考代码： import numpy as np import torch import torch.nn as nn import torch.optim as optim from torch.autograd import Variable dtype = torch.FloatTensor sentences = [ &quot;i like dog&quot;, &quot;i love coffee&quot;, &quot;i hate milk&quot;] #使用空格去分词 word_list = &quot; &quot;.join(sentences).split() word_list = list(set(word_list)) #获取字典 word_dict = {w: i for i, w in enumerate(word_list)} number_dict = {i: w for i, w in enumerate(word_list)} n_class = len(word_dict) # number of Vocabulary print(&quot;word_dict is:&quot;, word_dict) print(&quot;number_dict is:&quot;, number_dict) # NNLM Parameter n_step = 2 # n-1 in paper n_hidden = 2 # h in paper m = 2 # m in paper def make_batch(sentences): input_batch = [] target_batch = [] #选择前两个词预测后一个词 for sen in sentences: word = sen.split() input = [word_dict[n] for n in word[:-1]] target = word_dict[word[-1]] input_batch.append(input) target_batch.append(target) return input_batch, target_batch # Model class NNLM(nn.Module): def __init__(self): super(NNLM, self).__init__() self.C = nn.Embedding(n_class, m) self.H = nn.Parameter(torch.randn(n_step * m, n_hidden).type(dtype)) self.W = nn.Parameter(torch.randn(n_step * m, n_class).type(dtype)) self.d = nn.Parameter(torch.randn(n_hidden).type(dtype)) self.U = nn.Parameter(torch.randn(n_hidden, n_class).type(dtype)) self.b = nn.Parameter(torch.randn(n_class).type(dtype)) def forward(self, X): X = self.C(X) X = X.view(-1, n_step * m) # [batch_size, n_step * n_class] tanh = torch.tanh(self.d + torch.mm(X, self.H)) # [batch_size, n_hidden] output = self.b + torch.mm(X, self.W) + torch.mm(tanh, self.U) # [batch_size, n_class] return output model = NNLM() criterion = nn.CrossEntropyLoss() optimizer = optim.Adam(model.parameters(), lr=0.001) input_batch, target_batch = make_batch(sentences) input_batch = Variable(torch.LongTensor(input_batch)) target_batch = Variable(torch.LongTensor(target_batch)) # Training for epoch in range(5000): optimizer.zero_grad() output = model(input_batch) # output : [batch_size, n_class], target_batch : [batch_size] (LongTensor, not one-hot) loss = criterion(output, target_batch) if (epoch + 1)%1000 == 0: print(&#39;Epoch:&#39;, &#39;%04d&#39; % (epoch + 1), &#39;cost =&#39;, &#39;{:.6f}&#39;.format(loss)) #反向传播，参数寻优 loss.backward() optimizer.step() # Predict predict = model(input_batch).data.max(1, keepdim=True)[1] # Test print([sen.split()[:2] for sen in sentences], &#39;-&gt;&#39;, [number_dict[n.item()] for n in predict.squeeze()]) &nbsp; 2、Hierarchical Softmax &nbsp; 无论是哪种模型，其基本网络结构都是在下图的基础上，省略掉hidden layer：&nbsp; &nbsp; 模型基本结构 &nbsp; 为什么要去掉这一层呢？据说是因为word2vec的作者嫌从hidden layer到output layer的矩阵运算太多了。于是两种模型的网络结构是： &nbsp; 其中w(t)代表当前词语位于句子的位置t，同理定义其他记号。在窗口内（上图为窗口大小为5），除了当前词语之外的其他词语共同构成上下文。 2.1、CBOW 原理 &nbsp; &nbsp; &nbsp; &nbsp; CBOW 是 Continuous Bag-of-Words Model 的缩写，是一种根据上下文的词语预测当前词语的出现概率的模型。其图示如上图左。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CBOW是已知上下文，估算当前词语的语言模型。其学习目标是最大化对数似然函数： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 其中，w表示语料库C中任意一个词。从上图可以看出，对于CBOW， 输入层是上下文的词语的词向量（什么！我们不是在训练词向量吗？不不不，我们是在训练CBOW模型，词向量只是个副产品，确切来说，是CBOW模型的一个参数。训练开始的时候，词向量是个随机值，随着训练的进行不断被更新）。 投影层对其求和，所谓求和，就是简单的向量加法。 输出层输出最可能的w。由于语料库中词汇量是固定的|C|个，所以上述过程其实可以看做一个多分类问题。给定特征，从|C|个分类中挑一个 对于神经网络模型多分类，最朴素的做法是softmax回归： &nbsp; softmax回归需要对语料库中每个词语（类）都计算一遍输出概率并进行归一化，在几十万词汇量的语料上无疑是令人头疼的。 不用softmax怎么样？比如SVM中的多分类，我们都知道其多分类是由二分类组合而来的： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这是一种二叉树结构，应用到word2vec中被作者称为Hierarchical Softmax： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 上图输出层的树形结构即为Hierarchical Softmax。 &nbsp; &nbsp; 2.2、Skip-gram 原理 Skip-gram只是逆转了CBOW的因果关系而已，即已知当前词语，预测上下文。 其网络结构如下图所示： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 上图与CBOW的两个不同在于 输入层不再是多个词向量，而是一个词向量 投影层其实什么事情都没干，直接将输入层的词向量传递给输出层 （以上参考：http://www.hankcs.com/nlp/word2vec.html） 代码示例（skip gram）： #skip gram import numpy as np import torch import torch.nn as nn import torch.optim as optim from torch.autograd import Variable import matplotlib.pyplot as plt dtype = torch.FloatTensor # 3 Words Sentence sentences = [ &quot;i like dog&quot;, &quot;i like cat&quot;, &quot;i like animal&quot;, &quot;dog cat animal&quot;, &quot;apple cat dog like&quot;, &quot;dog fish milk like&quot;, &quot;dog cat eyes like&quot;, &quot;i like apple&quot;, &quot;apple i hate&quot;, &quot;apple i movie book music like&quot;, &quot;cat dog hate&quot;, &quot;cat dog like&quot;] word_sequence = &quot; &quot;.join(sentences).split() word_list = &quot; &quot;.join(sentences).split() word_list = list(set(word_list)) word_dict = {w: i for i, w in enumerate(word_list)} # Word2Vec Parameter batch_size = 20 # To show 2 dim embedding graph embedding_size = 2 # To show 2 dim embedding graph voc_size = len(word_list) def random_batch(data, size): random_inputs = [] random_labels = [] random_index = np.random.choice(range(len(data)), size, replace=False) for i in random_index: random_inputs.append(np.eye(voc_size)[data[i][0]]) # target random_labels.append(data[i][1]) # context word return random_inputs, random_labels # Make skip gram of one size window skip_grams = [] for i in range(1, len(word_sequence) - 1): target = word_dict[word_sequence[i]] context = [word_dict[word_sequence[i - 1]], word_dict[word_sequence[i + 1]]] for w in context: skip_grams.append([target, w]) # Model class Word2Vec(nn.Module): def __init__(self): super(Word2Vec, self).__init__() # W and WT is not Traspose relationship self.W = nn.Parameter(-2 * torch.rand(voc_size, embedding_size) + 1).type(dtype) # voc_size &gt; embedding_size Weight self.WT = nn.Parameter(-2 * torch.rand(embedding_size, voc_size) + 1).type(dtype) # embedding_size &gt; voc_size Weight def forward(self, X): # X : [batch_size, voc_size] hidden_layer = torch.matmul(X, self.W) # hidden_layer : [batch_size, embedding_size] output_layer = torch.matmul(hidden_layer, self.WT) # output_layer : [batch_size, voc_size] return output_layer model = Word2Vec() criterion = nn.CrossEntropyLoss() optimizer = optim.Adam(model.parameters(), lr=0.001) # Training for epoch in range(5000): input_batch, target_batch = random_batch(skip_grams, batch_size) input_batch = Variable(torch.Tensor(input_batch)) target_batch = Variable(torch.LongTensor(target_batch)) optimizer.zero_grad() output = model(input_batch) # output : [batch_size, voc_size], target_batch : [batch_size] (LongTensor, not one-hot) loss = criterion(output, target_batch) if (epoch + 1)%1000 == 0: print(&#39;Epoch:&#39;, &#39;%04d&#39; % (epoch + 1), &#39;cost =&#39;, &#39;{:.6f}&#39;.format(loss)) loss.backward() optimizer.step() for i, label in enumerate(word_list): W, WT = model.parameters() x,y = float(W[i][0]), float(W[i][1]) plt.scatter(x, y) plt.annotate(label, xy=(x, y), xytext=(5, 2), textcoords=&#39;offset points&#39;, ha=&#39;right&#39;, va=&#39;bottom&#39;) plt.show() &nbsp;" />
<meta property="og:description" content="一、背景 语言模型 &nbsp;- 在统计自然语言处理中，语言模型指的是计算一个句子的概率模型。 &nbsp; &nbsp; 传统的语言模型中词的表示是原始的、面向字符串的。两个语义相似的词的字符串可能完全不同，比如“番茄”和“西红柿”。这给所有NLP任务都带来了挑战——字符串本身无法储存语义信息。该挑战突出表现在模型的平滑问题上：标注语料是有限的，而语言整体是无限的，传统模型无法借力未标注的海量语料，只能靠人工设计平滑算法，而这些算法往往效果甚微。 &nbsp; &nbsp; &nbsp; &nbsp;神经概率语言模型（Neural Probabilistic Language&nbsp;Model）中词的表示是向量形式、面向语义的。两个语义相似的词对应的向量也是相似的，具体反映在夹角或距离上。甚至一些语义相似的二元词组中的词语对应的向量做线性减法之后得到的向量依然是相似的。词的向量表示可以显著提高传统NLP任务的性能，例如《基于神经网络的高性能依存句法分析器》中介绍的词、词性、依存关系的向量化对正确率的提升等。 &nbsp; &nbsp; &nbsp; &nbsp;NLP（自然语言处理）里面，最细粒度的是 词语，词语组成句子，句子再组成段落、篇章、文档。所以处理 NLP 的问题，首先就要拿词语开刀。词语，是人类的抽象总结，是符号形式的（比如中文、英文、拉丁文等等），所以需要**把他们转换成数值形式，或者说——嵌入到一个数学空间里，这种嵌入方式，就叫词嵌入（word embedding)**，而 Word2vec，就是词嵌入（ word embedding) 的一种。简单点来说就是把一个词语转换成对应向量的表达形式，来让机器读取数据。 &nbsp; &nbsp;**从向量的角度来看，字符串形式的词语其实是更高维、更稀疏的向量。** 若词汇表大小为N，每个字符串形式的词语字典序为i，则其被表示为一个N维向量，该向量的第i维为1，其他维都为0。汉语的词汇量大约在十万这个量级，十万维的向量对计算来讲绝对是个维度灾难。**而word2vec得到的词的向量形式（下文简称“词向量”，更学术化的翻译是“词嵌入”）则可以自由控制维度，一般是100左右。** &nbsp;- word2vec作为神经概率语言模型的输入，其本身其实是神经概率模型的副产品，是为了通过神经网络学习某个语言模型而产生的中间结果。具体来说，“某个语言模型”指的是“CBOW”和“Skip-gram”。具体学习过程会用到两个降低复杂度的近似方法——Hierarchical Softmax或Negative Sampling。两个模型乘以两种方法，一共有四种实现。这些内容就是本文理论部分要详细阐明的全部了。 二、理论 1、神经网络语言模型 &nbsp;- 基于神经网络的分布表示又称为词向量或者词嵌入。 2001年， Bengio 等人正式提出神经网络语言模型（ Neural Network Language Model &nbsp; ，NNLM），该模型在学习语言模型的同时，也得到了词向量。所以请注意一点：词向量可以认为是神经网络训练语言模型的副产品。 &nbsp;- 上面说，通过神经网络训练语言模型可以得到词向量，那么，究竟有哪些类型的神经网络语言模型呢？个人所知，大致有这么些：&nbsp; a) Neural Network Language Model ，NNLM&nbsp; b) Log-Bilinear Language Model， LBL&nbsp; c) Recurrent Neural Network based Language Model，RNNLM&nbsp; d) Collobert 和 Weston 在2008 年提出的 C&amp;W 模型&nbsp; e) Mikolov 等人提出了 CBOW（ Continuous Bagof-Words）和 Skip-gram 模型&nbsp; 如今我们主要用到的是CBOW和Skip-gram模型。 我们来梳理一下思路，**要想得到一个词的向量表达方法，并且这个向量的维度很小，而且任意两个词之间是有联系的，可以表示出在语义层面上词语词之间的相关信息。** 我们就需要训练神经网络语言模型，即CBOW和Skip-gram模型。**这个模型的输出我们不关心，我们关心的是模型中第一个隐含层中的参数权重，这个参数矩阵就是我们需要的词向量**。**它的每一行就是词典中对应词的词向量，行数就是词典的大小。**&nbsp; 1.1 模型输入： &nbsp; &nbsp; &nbsp; &nbsp;首先从语料库中搜集一系列长度为n的文本序列 ，然后组成训练集D，我这里的理解是语料库就是我们在特定领域搜集的文本语料，同时还要有一个词典。有了训练数据和词典，下面就来看下模型是怎样进行前向传播的。 这里先对单个语句序列进行计算，也可以说是单个样本，比如：其中&nbsp;,这里的V是所有单词的集合（即词典），&nbsp;表示词典中的第 i 个单词。 NNLM的目标是训练如下模型： 其中表示词序列中第t个单词，表示从第1个词到第t个词组成的子序列。模型需要满足的约束条件是： 上面模型的意思是当给定一段序列时，由其前面的(t-1)个词预测第n个词的概率。 限制条件一：即是通过网络得到的每个概率值都要大于0。 而对于第二个限制条件：因为我们的神经网络模型最终得到的输出是针对每t-1个词的输入来预测下一个，也即是第t个词是什么。因此模型的实际输出是一个向量，该向量的每一个分量依次对应下一个词为词典中某个词的概率。所以|v|维的概率值中必定有一个最大的概率，而其他的概率较小。 （以上参考：https://blog.csdn.net/lilong117194/article/details/82018008 ） &nbsp; NNLM参考代码： import numpy as np import torch import torch.nn as nn import torch.optim as optim from torch.autograd import Variable dtype = torch.FloatTensor sentences = [ &quot;i like dog&quot;, &quot;i love coffee&quot;, &quot;i hate milk&quot;] #使用空格去分词 word_list = &quot; &quot;.join(sentences).split() word_list = list(set(word_list)) #获取字典 word_dict = {w: i for i, w in enumerate(word_list)} number_dict = {i: w for i, w in enumerate(word_list)} n_class = len(word_dict) # number of Vocabulary print(&quot;word_dict is:&quot;, word_dict) print(&quot;number_dict is:&quot;, number_dict) # NNLM Parameter n_step = 2 # n-1 in paper n_hidden = 2 # h in paper m = 2 # m in paper def make_batch(sentences): input_batch = [] target_batch = [] #选择前两个词预测后一个词 for sen in sentences: word = sen.split() input = [word_dict[n] for n in word[:-1]] target = word_dict[word[-1]] input_batch.append(input) target_batch.append(target) return input_batch, target_batch # Model class NNLM(nn.Module): def __init__(self): super(NNLM, self).__init__() self.C = nn.Embedding(n_class, m) self.H = nn.Parameter(torch.randn(n_step * m, n_hidden).type(dtype)) self.W = nn.Parameter(torch.randn(n_step * m, n_class).type(dtype)) self.d = nn.Parameter(torch.randn(n_hidden).type(dtype)) self.U = nn.Parameter(torch.randn(n_hidden, n_class).type(dtype)) self.b = nn.Parameter(torch.randn(n_class).type(dtype)) def forward(self, X): X = self.C(X) X = X.view(-1, n_step * m) # [batch_size, n_step * n_class] tanh = torch.tanh(self.d + torch.mm(X, self.H)) # [batch_size, n_hidden] output = self.b + torch.mm(X, self.W) + torch.mm(tanh, self.U) # [batch_size, n_class] return output model = NNLM() criterion = nn.CrossEntropyLoss() optimizer = optim.Adam(model.parameters(), lr=0.001) input_batch, target_batch = make_batch(sentences) input_batch = Variable(torch.LongTensor(input_batch)) target_batch = Variable(torch.LongTensor(target_batch)) # Training for epoch in range(5000): optimizer.zero_grad() output = model(input_batch) # output : [batch_size, n_class], target_batch : [batch_size] (LongTensor, not one-hot) loss = criterion(output, target_batch) if (epoch + 1)%1000 == 0: print(&#39;Epoch:&#39;, &#39;%04d&#39; % (epoch + 1), &#39;cost =&#39;, &#39;{:.6f}&#39;.format(loss)) #反向传播，参数寻优 loss.backward() optimizer.step() # Predict predict = model(input_batch).data.max(1, keepdim=True)[1] # Test print([sen.split()[:2] for sen in sentences], &#39;-&gt;&#39;, [number_dict[n.item()] for n in predict.squeeze()]) &nbsp; 2、Hierarchical Softmax &nbsp; 无论是哪种模型，其基本网络结构都是在下图的基础上，省略掉hidden layer：&nbsp; &nbsp; 模型基本结构 &nbsp; 为什么要去掉这一层呢？据说是因为word2vec的作者嫌从hidden layer到output layer的矩阵运算太多了。于是两种模型的网络结构是： &nbsp; 其中w(t)代表当前词语位于句子的位置t，同理定义其他记号。在窗口内（上图为窗口大小为5），除了当前词语之外的其他词语共同构成上下文。 2.1、CBOW 原理 &nbsp; &nbsp; &nbsp; &nbsp; CBOW 是 Continuous Bag-of-Words Model 的缩写，是一种根据上下文的词语预测当前词语的出现概率的模型。其图示如上图左。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CBOW是已知上下文，估算当前词语的语言模型。其学习目标是最大化对数似然函数： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 其中，w表示语料库C中任意一个词。从上图可以看出，对于CBOW， 输入层是上下文的词语的词向量（什么！我们不是在训练词向量吗？不不不，我们是在训练CBOW模型，词向量只是个副产品，确切来说，是CBOW模型的一个参数。训练开始的时候，词向量是个随机值，随着训练的进行不断被更新）。 投影层对其求和，所谓求和，就是简单的向量加法。 输出层输出最可能的w。由于语料库中词汇量是固定的|C|个，所以上述过程其实可以看做一个多分类问题。给定特征，从|C|个分类中挑一个 对于神经网络模型多分类，最朴素的做法是softmax回归： &nbsp; softmax回归需要对语料库中每个词语（类）都计算一遍输出概率并进行归一化，在几十万词汇量的语料上无疑是令人头疼的。 不用softmax怎么样？比如SVM中的多分类，我们都知道其多分类是由二分类组合而来的： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这是一种二叉树结构，应用到word2vec中被作者称为Hierarchical Softmax： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 上图输出层的树形结构即为Hierarchical Softmax。 &nbsp; &nbsp; 2.2、Skip-gram 原理 Skip-gram只是逆转了CBOW的因果关系而已，即已知当前词语，预测上下文。 其网络结构如下图所示： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 上图与CBOW的两个不同在于 输入层不再是多个词向量，而是一个词向量 投影层其实什么事情都没干，直接将输入层的词向量传递给输出层 （以上参考：http://www.hankcs.com/nlp/word2vec.html） 代码示例（skip gram）： #skip gram import numpy as np import torch import torch.nn as nn import torch.optim as optim from torch.autograd import Variable import matplotlib.pyplot as plt dtype = torch.FloatTensor # 3 Words Sentence sentences = [ &quot;i like dog&quot;, &quot;i like cat&quot;, &quot;i like animal&quot;, &quot;dog cat animal&quot;, &quot;apple cat dog like&quot;, &quot;dog fish milk like&quot;, &quot;dog cat eyes like&quot;, &quot;i like apple&quot;, &quot;apple i hate&quot;, &quot;apple i movie book music like&quot;, &quot;cat dog hate&quot;, &quot;cat dog like&quot;] word_sequence = &quot; &quot;.join(sentences).split() word_list = &quot; &quot;.join(sentences).split() word_list = list(set(word_list)) word_dict = {w: i for i, w in enumerate(word_list)} # Word2Vec Parameter batch_size = 20 # To show 2 dim embedding graph embedding_size = 2 # To show 2 dim embedding graph voc_size = len(word_list) def random_batch(data, size): random_inputs = [] random_labels = [] random_index = np.random.choice(range(len(data)), size, replace=False) for i in random_index: random_inputs.append(np.eye(voc_size)[data[i][0]]) # target random_labels.append(data[i][1]) # context word return random_inputs, random_labels # Make skip gram of one size window skip_grams = [] for i in range(1, len(word_sequence) - 1): target = word_dict[word_sequence[i]] context = [word_dict[word_sequence[i - 1]], word_dict[word_sequence[i + 1]]] for w in context: skip_grams.append([target, w]) # Model class Word2Vec(nn.Module): def __init__(self): super(Word2Vec, self).__init__() # W and WT is not Traspose relationship self.W = nn.Parameter(-2 * torch.rand(voc_size, embedding_size) + 1).type(dtype) # voc_size &gt; embedding_size Weight self.WT = nn.Parameter(-2 * torch.rand(embedding_size, voc_size) + 1).type(dtype) # embedding_size &gt; voc_size Weight def forward(self, X): # X : [batch_size, voc_size] hidden_layer = torch.matmul(X, self.W) # hidden_layer : [batch_size, embedding_size] output_layer = torch.matmul(hidden_layer, self.WT) # output_layer : [batch_size, voc_size] return output_layer model = Word2Vec() criterion = nn.CrossEntropyLoss() optimizer = optim.Adam(model.parameters(), lr=0.001) # Training for epoch in range(5000): input_batch, target_batch = random_batch(skip_grams, batch_size) input_batch = Variable(torch.Tensor(input_batch)) target_batch = Variable(torch.LongTensor(target_batch)) optimizer.zero_grad() output = model(input_batch) # output : [batch_size, voc_size], target_batch : [batch_size] (LongTensor, not one-hot) loss = criterion(output, target_batch) if (epoch + 1)%1000 == 0: print(&#39;Epoch:&#39;, &#39;%04d&#39; % (epoch + 1), &#39;cost =&#39;, &#39;{:.6f}&#39;.format(loss)) loss.backward() optimizer.step() for i, label in enumerate(word_list): W, WT = model.parameters() x,y = float(W[i][0]), float(W[i][1]) plt.scatter(x, y) plt.annotate(label, xy=(x, y), xytext=(5, 2), textcoords=&#39;offset points&#39;, ha=&#39;right&#39;, va=&#39;bottom&#39;) plt.show() &nbsp;" />
<link rel="canonical" href="https://mlh.app/2019/05/18/787130.html" />
<meta property="og:url" content="https://mlh.app/2019/05/18/787130.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-18T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"一、背景 语言模型 &nbsp;- 在统计自然语言处理中，语言模型指的是计算一个句子的概率模型。 &nbsp; &nbsp; 传统的语言模型中词的表示是原始的、面向字符串的。两个语义相似的词的字符串可能完全不同，比如“番茄”和“西红柿”。这给所有NLP任务都带来了挑战——字符串本身无法储存语义信息。该挑战突出表现在模型的平滑问题上：标注语料是有限的，而语言整体是无限的，传统模型无法借力未标注的海量语料，只能靠人工设计平滑算法，而这些算法往往效果甚微。 &nbsp; &nbsp; &nbsp; &nbsp;神经概率语言模型（Neural Probabilistic Language&nbsp;Model）中词的表示是向量形式、面向语义的。两个语义相似的词对应的向量也是相似的，具体反映在夹角或距离上。甚至一些语义相似的二元词组中的词语对应的向量做线性减法之后得到的向量依然是相似的。词的向量表示可以显著提高传统NLP任务的性能，例如《基于神经网络的高性能依存句法分析器》中介绍的词、词性、依存关系的向量化对正确率的提升等。 &nbsp; &nbsp; &nbsp; &nbsp;NLP（自然语言处理）里面，最细粒度的是 词语，词语组成句子，句子再组成段落、篇章、文档。所以处理 NLP 的问题，首先就要拿词语开刀。词语，是人类的抽象总结，是符号形式的（比如中文、英文、拉丁文等等），所以需要**把他们转换成数值形式，或者说——嵌入到一个数学空间里，这种嵌入方式，就叫词嵌入（word embedding)**，而 Word2vec，就是词嵌入（ word embedding) 的一种。简单点来说就是把一个词语转换成对应向量的表达形式，来让机器读取数据。 &nbsp; &nbsp;**从向量的角度来看，字符串形式的词语其实是更高维、更稀疏的向量。** 若词汇表大小为N，每个字符串形式的词语字典序为i，则其被表示为一个N维向量，该向量的第i维为1，其他维都为0。汉语的词汇量大约在十万这个量级，十万维的向量对计算来讲绝对是个维度灾难。**而word2vec得到的词的向量形式（下文简称“词向量”，更学术化的翻译是“词嵌入”）则可以自由控制维度，一般是100左右。** &nbsp;- word2vec作为神经概率语言模型的输入，其本身其实是神经概率模型的副产品，是为了通过神经网络学习某个语言模型而产生的中间结果。具体来说，“某个语言模型”指的是“CBOW”和“Skip-gram”。具体学习过程会用到两个降低复杂度的近似方法——Hierarchical Softmax或Negative Sampling。两个模型乘以两种方法，一共有四种实现。这些内容就是本文理论部分要详细阐明的全部了。 二、理论 1、神经网络语言模型 &nbsp;- 基于神经网络的分布表示又称为词向量或者词嵌入。 2001年， Bengio 等人正式提出神经网络语言模型（ Neural Network Language Model &nbsp; ，NNLM），该模型在学习语言模型的同时，也得到了词向量。所以请注意一点：词向量可以认为是神经网络训练语言模型的副产品。 &nbsp;- 上面说，通过神经网络训练语言模型可以得到词向量，那么，究竟有哪些类型的神经网络语言模型呢？个人所知，大致有这么些：&nbsp; a) Neural Network Language Model ，NNLM&nbsp; b) Log-Bilinear Language Model， LBL&nbsp; c) Recurrent Neural Network based Language Model，RNNLM&nbsp; d) Collobert 和 Weston 在2008 年提出的 C&amp;W 模型&nbsp; e) Mikolov 等人提出了 CBOW（ Continuous Bagof-Words）和 Skip-gram 模型&nbsp; 如今我们主要用到的是CBOW和Skip-gram模型。 我们来梳理一下思路，**要想得到一个词的向量表达方法，并且这个向量的维度很小，而且任意两个词之间是有联系的，可以表示出在语义层面上词语词之间的相关信息。** 我们就需要训练神经网络语言模型，即CBOW和Skip-gram模型。**这个模型的输出我们不关心，我们关心的是模型中第一个隐含层中的参数权重，这个参数矩阵就是我们需要的词向量**。**它的每一行就是词典中对应词的词向量，行数就是词典的大小。**&nbsp; 1.1 模型输入： &nbsp; &nbsp; &nbsp; &nbsp;首先从语料库中搜集一系列长度为n的文本序列 ，然后组成训练集D，我这里的理解是语料库就是我们在特定领域搜集的文本语料，同时还要有一个词典。有了训练数据和词典，下面就来看下模型是怎样进行前向传播的。 这里先对单个语句序列进行计算，也可以说是单个样本，比如：其中&nbsp;,这里的V是所有单词的集合（即词典），&nbsp;表示词典中的第 i 个单词。 NNLM的目标是训练如下模型： 其中表示词序列中第t个单词，表示从第1个词到第t个词组成的子序列。模型需要满足的约束条件是： 上面模型的意思是当给定一段序列时，由其前面的(t-1)个词预测第n个词的概率。 限制条件一：即是通过网络得到的每个概率值都要大于0。 而对于第二个限制条件：因为我们的神经网络模型最终得到的输出是针对每t-1个词的输入来预测下一个，也即是第t个词是什么。因此模型的实际输出是一个向量，该向量的每一个分量依次对应下一个词为词典中某个词的概率。所以|v|维的概率值中必定有一个最大的概率，而其他的概率较小。 （以上参考：https://blog.csdn.net/lilong117194/article/details/82018008 ） &nbsp; NNLM参考代码： import numpy as np import torch import torch.nn as nn import torch.optim as optim from torch.autograd import Variable dtype = torch.FloatTensor sentences = [ &quot;i like dog&quot;, &quot;i love coffee&quot;, &quot;i hate milk&quot;] #使用空格去分词 word_list = &quot; &quot;.join(sentences).split() word_list = list(set(word_list)) #获取字典 word_dict = {w: i for i, w in enumerate(word_list)} number_dict = {i: w for i, w in enumerate(word_list)} n_class = len(word_dict) # number of Vocabulary print(&quot;word_dict is:&quot;, word_dict) print(&quot;number_dict is:&quot;, number_dict) # NNLM Parameter n_step = 2 # n-1 in paper n_hidden = 2 # h in paper m = 2 # m in paper def make_batch(sentences): input_batch = [] target_batch = [] #选择前两个词预测后一个词 for sen in sentences: word = sen.split() input = [word_dict[n] for n in word[:-1]] target = word_dict[word[-1]] input_batch.append(input) target_batch.append(target) return input_batch, target_batch # Model class NNLM(nn.Module): def __init__(self): super(NNLM, self).__init__() self.C = nn.Embedding(n_class, m) self.H = nn.Parameter(torch.randn(n_step * m, n_hidden).type(dtype)) self.W = nn.Parameter(torch.randn(n_step * m, n_class).type(dtype)) self.d = nn.Parameter(torch.randn(n_hidden).type(dtype)) self.U = nn.Parameter(torch.randn(n_hidden, n_class).type(dtype)) self.b = nn.Parameter(torch.randn(n_class).type(dtype)) def forward(self, X): X = self.C(X) X = X.view(-1, n_step * m) # [batch_size, n_step * n_class] tanh = torch.tanh(self.d + torch.mm(X, self.H)) # [batch_size, n_hidden] output = self.b + torch.mm(X, self.W) + torch.mm(tanh, self.U) # [batch_size, n_class] return output model = NNLM() criterion = nn.CrossEntropyLoss() optimizer = optim.Adam(model.parameters(), lr=0.001) input_batch, target_batch = make_batch(sentences) input_batch = Variable(torch.LongTensor(input_batch)) target_batch = Variable(torch.LongTensor(target_batch)) # Training for epoch in range(5000): optimizer.zero_grad() output = model(input_batch) # output : [batch_size, n_class], target_batch : [batch_size] (LongTensor, not one-hot) loss = criterion(output, target_batch) if (epoch + 1)%1000 == 0: print(&#39;Epoch:&#39;, &#39;%04d&#39; % (epoch + 1), &#39;cost =&#39;, &#39;{:.6f}&#39;.format(loss)) #反向传播，参数寻优 loss.backward() optimizer.step() # Predict predict = model(input_batch).data.max(1, keepdim=True)[1] # Test print([sen.split()[:2] for sen in sentences], &#39;-&gt;&#39;, [number_dict[n.item()] for n in predict.squeeze()]) &nbsp; 2、Hierarchical Softmax &nbsp; 无论是哪种模型，其基本网络结构都是在下图的基础上，省略掉hidden layer：&nbsp; &nbsp; 模型基本结构 &nbsp; 为什么要去掉这一层呢？据说是因为word2vec的作者嫌从hidden layer到output layer的矩阵运算太多了。于是两种模型的网络结构是： &nbsp; 其中w(t)代表当前词语位于句子的位置t，同理定义其他记号。在窗口内（上图为窗口大小为5），除了当前词语之外的其他词语共同构成上下文。 2.1、CBOW 原理 &nbsp; &nbsp; &nbsp; &nbsp; CBOW 是 Continuous Bag-of-Words Model 的缩写，是一种根据上下文的词语预测当前词语的出现概率的模型。其图示如上图左。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CBOW是已知上下文，估算当前词语的语言模型。其学习目标是最大化对数似然函数： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 其中，w表示语料库C中任意一个词。从上图可以看出，对于CBOW， 输入层是上下文的词语的词向量（什么！我们不是在训练词向量吗？不不不，我们是在训练CBOW模型，词向量只是个副产品，确切来说，是CBOW模型的一个参数。训练开始的时候，词向量是个随机值，随着训练的进行不断被更新）。 投影层对其求和，所谓求和，就是简单的向量加法。 输出层输出最可能的w。由于语料库中词汇量是固定的|C|个，所以上述过程其实可以看做一个多分类问题。给定特征，从|C|个分类中挑一个 对于神经网络模型多分类，最朴素的做法是softmax回归： &nbsp; softmax回归需要对语料库中每个词语（类）都计算一遍输出概率并进行归一化，在几十万词汇量的语料上无疑是令人头疼的。 不用softmax怎么样？比如SVM中的多分类，我们都知道其多分类是由二分类组合而来的： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这是一种二叉树结构，应用到word2vec中被作者称为Hierarchical Softmax： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 上图输出层的树形结构即为Hierarchical Softmax。 &nbsp; &nbsp; 2.2、Skip-gram 原理 Skip-gram只是逆转了CBOW的因果关系而已，即已知当前词语，预测上下文。 其网络结构如下图所示： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 上图与CBOW的两个不同在于 输入层不再是多个词向量，而是一个词向量 投影层其实什么事情都没干，直接将输入层的词向量传递给输出层 （以上参考：http://www.hankcs.com/nlp/word2vec.html） 代码示例（skip gram）： #skip gram import numpy as np import torch import torch.nn as nn import torch.optim as optim from torch.autograd import Variable import matplotlib.pyplot as plt dtype = torch.FloatTensor # 3 Words Sentence sentences = [ &quot;i like dog&quot;, &quot;i like cat&quot;, &quot;i like animal&quot;, &quot;dog cat animal&quot;, &quot;apple cat dog like&quot;, &quot;dog fish milk like&quot;, &quot;dog cat eyes like&quot;, &quot;i like apple&quot;, &quot;apple i hate&quot;, &quot;apple i movie book music like&quot;, &quot;cat dog hate&quot;, &quot;cat dog like&quot;] word_sequence = &quot; &quot;.join(sentences).split() word_list = &quot; &quot;.join(sentences).split() word_list = list(set(word_list)) word_dict = {w: i for i, w in enumerate(word_list)} # Word2Vec Parameter batch_size = 20 # To show 2 dim embedding graph embedding_size = 2 # To show 2 dim embedding graph voc_size = len(word_list) def random_batch(data, size): random_inputs = [] random_labels = [] random_index = np.random.choice(range(len(data)), size, replace=False) for i in random_index: random_inputs.append(np.eye(voc_size)[data[i][0]]) # target random_labels.append(data[i][1]) # context word return random_inputs, random_labels # Make skip gram of one size window skip_grams = [] for i in range(1, len(word_sequence) - 1): target = word_dict[word_sequence[i]] context = [word_dict[word_sequence[i - 1]], word_dict[word_sequence[i + 1]]] for w in context: skip_grams.append([target, w]) # Model class Word2Vec(nn.Module): def __init__(self): super(Word2Vec, self).__init__() # W and WT is not Traspose relationship self.W = nn.Parameter(-2 * torch.rand(voc_size, embedding_size) + 1).type(dtype) # voc_size &gt; embedding_size Weight self.WT = nn.Parameter(-2 * torch.rand(embedding_size, voc_size) + 1).type(dtype) # embedding_size &gt; voc_size Weight def forward(self, X): # X : [batch_size, voc_size] hidden_layer = torch.matmul(X, self.W) # hidden_layer : [batch_size, embedding_size] output_layer = torch.matmul(hidden_layer, self.WT) # output_layer : [batch_size, voc_size] return output_layer model = Word2Vec() criterion = nn.CrossEntropyLoss() optimizer = optim.Adam(model.parameters(), lr=0.001) # Training for epoch in range(5000): input_batch, target_batch = random_batch(skip_grams, batch_size) input_batch = Variable(torch.Tensor(input_batch)) target_batch = Variable(torch.LongTensor(target_batch)) optimizer.zero_grad() output = model(input_batch) # output : [batch_size, voc_size], target_batch : [batch_size] (LongTensor, not one-hot) loss = criterion(output, target_batch) if (epoch + 1)%1000 == 0: print(&#39;Epoch:&#39;, &#39;%04d&#39; % (epoch + 1), &#39;cost =&#39;, &#39;{:.6f}&#39;.format(loss)) loss.backward() optimizer.step() for i, label in enumerate(word_list): W, WT = model.parameters() x,y = float(W[i][0]), float(W[i][1]) plt.scatter(x, y) plt.annotate(label, xy=(x, y), xytext=(5, 2), textcoords=&#39;offset points&#39;, ha=&#39;right&#39;, va=&#39;bottom&#39;) plt.show() &nbsp;","@type":"BlogPosting","url":"https://mlh.app/2019/05/18/787130.html","headline":"自然语言处理之word2vec","dateModified":"2019-05-18T00:00:00+08:00","datePublished":"2019-05-18T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/05/18/787130.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>自然语言处理之word2vec</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1><strong>一、背景</strong></h1> 
  <h2>语言模型</h2> 
  <p>&nbsp;- 在统计自然语言处理中，语言模型指的是计算一个句子的概率模型。</p> 
  <p>&nbsp; &nbsp; 传统的语言模型中词的表示是原始的、面向字符串的。两个语义相似的词的字符串可能完全不同，比如“番茄”和“西红柿”。这给所有NLP任务都带来了挑战——字符串本身无法储存语义信息。该挑战突出表现在模型的平滑问题上：标注语料是有限的，而语言整体是无限的，传统模型无法借力未标注的海量语料，只能靠人工设计平滑算法，而这些算法往往效果甚微。<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;神经概率语言模型（Neural Probabilistic Language&nbsp;Model）中词的表示是向量形式、面向语义的。两个语义相似的词对应的向量也是相似的，具体反映在夹角或距离上。甚至一些语义相似的二元词组中的词语对应的向量做线性减法之后得到的向量依然是相似的。词的向量表示可以显著提高传统NLP任务的性能，例如《基于神经网络的高性能依存句法分析器》中介绍的词、词性、依存关系的向量化对正确率的提升等。<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;NLP（自然语言处理）里面，最细粒度的是 词语，词语组成句子，句子再组成段落、篇章、文档。所以处理 NLP 的问题，首先就要拿词语开刀。词语，是人类的抽象总结，是符号形式的（比如中文、英文、拉丁文等等），所以需要**把他们转换成数值形式，或者说——嵌入到一个数学空间里，这种嵌入方式，就叫词嵌入（word embedding)**，而 Word2vec，就是词嵌入（ word embedding) 的一种。简单点来说就是把一个词语转换成对应向量的表达形式，来让机器读取数据。</p> 
  <p>&nbsp; &nbsp;**从向量的角度来看，字符串形式的词语其实是更高维、更稀疏的向量。** 若词汇表大小为N，每个字符串形式的词语字典序为i，则其被表示为一个N维向量，该向量的第i维为1，其他维都为0。汉语的词汇量大约在十万这个量级，十万维的向量对计算来讲绝对是个维度灾难。**而word2vec得到的词的向量形式（下文简称“词向量”，更学术化的翻译是“词嵌入”）则可以自由控制维度，一般是100左右。**</p> 
  <p>&nbsp;- word2vec作为神经概率语言模型的输入，其本身其实是神经概率模型的副产品，是为了通过神经网络学习某个语言模型而产生的中间结果。具体来说，“某个语言模型”指的是“CBOW”和“Skip-gram”。具体学习过程会用到两个降低复杂度的近似方法——Hierarchical Softmax或Negative Sampling。两个模型乘以两种方法，一共有四种实现。这些内容就是本文理论部分要详细阐明的全部了。</p> 
  <h1>二、理论</h1> 
  <h2>1、神经网络语言模型</h2> 
  <p>&nbsp;- 基于神经网络的分布表示又称为词向量或者词嵌入。 2001年， Bengio 等人正式提出神经网络语言模型（ Neural Network Language Model &nbsp; ，NNLM），该模型在学习语言模型的同时，也得到了词向量。所以请注意一点：词向量可以认为是神经网络训练语言模型的副产品。<br> &nbsp;- 上面说，通过神经网络训练语言模型可以得到词向量，那么，究竟有哪些类型的神经网络语言模型呢？个人所知，大致有这么些：&nbsp;<br> a) Neural Network Language Model ，NNLM&nbsp;<br> b) Log-Bilinear Language Model， LBL&nbsp;<br> c) Recurrent Neural Network based Language Model，RNNLM&nbsp;<br> d) Collobert 和 Weston 在2008 年提出的 C&amp;W 模型&nbsp;<br> e) Mikolov 等人提出了 CBOW（ Continuous Bagof-Words）和 Skip-gram 模型&nbsp;<br> 如今我们主要用到的是CBOW和Skip-gram模型。</p> 
  <p>我们来梳理一下思路，**要想得到一个词的向量表达方法，并且这个向量的维度很小，而且任意两个词之间是有联系的，可以表示出在语义层面上词语词之间的相关信息。** 我们就需要训练神经网络语言模型，即CBOW和Skip-gram模型。**这个模型的输出我们不关心，我们关心的是模型中第一个隐含层中的参数权重，这个参数矩阵就是我们需要的词向量**。**它的每一行就是词典中对应词的词向量，行数就是词典的大小。**&nbsp;</p> 
  <h3>1.1 模型输入：</h3> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp;首先从语料库中搜集一系列长度为n的文本序列 <img alt="(w_{t},w_{t-1},...,w_{t}-(n-1)))" class="mathcode" src="https://private.codecogs.com/gif.latex?%28w_%7Bt%7D%2Cw_%7Bt-1%7D%2C...%2Cw_%7Bt%7D-%28n-1%29%29%29">，然后组成训练集D，我这里的理解是语料库就是我们在特定领域搜集的文本语料，同时还要有一个词典。有了训练数据和词典，下面就来看下模型是怎样进行前向传播的。</p> 
  <p>这里先对单个语句序列进行计算，也可以说是单个样本，比如：<img alt="w_{1}.....w_{T}" class="mathcode" src="https://private.codecogs.com/gif.latex?w_%7B1%7D.....w_%7BT%7D">其中&nbsp;<img alt="w_{t}\in V" class="mathcode" src="https://private.codecogs.com/gif.latex?w_%7Bt%7D%5Cin%20V">,这里的V是所有单词的集合（即词典），<img alt="V_{i}" class="mathcode" src="https://private.codecogs.com/gif.latex?V_%7Bi%7D">&nbsp;表示词典中的第 i 个单词。</p> 
  <p>NNLM的目标是训练如下模型：</p> 
  <p><img alt="" class="has" height="32" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190517214759200.png" width="463"></p> 
  <p>其中<img alt="w{_{t}}" class="mathcode" src="https://private.codecogs.com/gif.latex?w%7B_%7Bt%7D%7D">表示词序列中第t个单词，<img alt="w_{1}^{t-1}" class="mathcode" src="https://private.codecogs.com/gif.latex?w_%7B1%7D%5E%7Bt-1%7D">表示从第1个词到第t个词组成的子序列。模型需要满足的约束条件是：</p> 
  <p><img alt="" class="has" height="92" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190517215010262.png" width="477"></p> 
  <p>上面模型的意思是当给定一段序列时，由其前面的(t-1)个词预测第n个词的概率。<br> 限制条件一：即是通过网络得到的每个概率值都要大于0。<br> 而对于第二个限制条件：因为我们的神经网络模型最终得到的输出是针对每t-1个词的输入来预测下一个，也即是第t个词是什么。因此模型的实际输出是一个向量，该向量的每一个分量依次对应下一个词为词典中某个词的概率。所以|v|维的概率值中必定有一个最大的概率，而其他的概率较小。<br> （以上参考：https://blog.csdn.net/lilong117194/article/details/82018008 ）<br> &nbsp;</p> 
  <p><strong>NNLM参考代码：</strong></p> 
  <pre class="has">
<code class="language-python">import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.autograd import Variable

dtype = torch.FloatTensor

sentences = [ "i like dog", "i love coffee", "i hate milk"]

#使用空格去分词
word_list = " ".join(sentences).split()
word_list = list(set(word_list))
#获取字典
word_dict = {w: i for i, w in enumerate(word_list)}
number_dict = {i: w for i, w in enumerate(word_list)}
n_class = len(word_dict) # number of Vocabulary
print("word_dict is:", word_dict)
print("number_dict is:", number_dict)
# NNLM Parameter
n_step = 2 # n-1 in paper
n_hidden = 2 # h in paper
m = 2 # m in paper

def make_batch(sentences):
    input_batch = []
    target_batch = []
#选择前两个词预测后一个词
    for sen in sentences:
        word = sen.split()
        input = [word_dict[n] for n in word[:-1]]
        target = word_dict[word[-1]]

        input_batch.append(input)
        target_batch.append(target)

    return input_batch, target_batch

# Model
class NNLM(nn.Module):
    def __init__(self):
        super(NNLM, self).__init__()
        self.C = nn.Embedding(n_class, m)
        self.H = nn.Parameter(torch.randn(n_step * m, n_hidden).type(dtype))
        self.W = nn.Parameter(torch.randn(n_step * m, n_class).type(dtype))
        self.d = nn.Parameter(torch.randn(n_hidden).type(dtype))
        self.U = nn.Parameter(torch.randn(n_hidden, n_class).type(dtype))
        self.b = nn.Parameter(torch.randn(n_class).type(dtype))

    def forward(self, X):
        X = self.C(X)
        X = X.view(-1, n_step * m) # [batch_size, n_step * n_class]
        tanh = torch.tanh(self.d + torch.mm(X, self.H)) # [batch_size, n_hidden]
        output = self.b + torch.mm(X, self.W) + torch.mm(tanh, self.U) # [batch_size, n_class]
        return output

model = NNLM()

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

input_batch, target_batch = make_batch(sentences)
input_batch = Variable(torch.LongTensor(input_batch))
target_batch = Variable(torch.LongTensor(target_batch))

# Training
for epoch in range(5000):

    optimizer.zero_grad()
    output = model(input_batch)

    # output : [batch_size, n_class], target_batch : [batch_size] (LongTensor, not one-hot)
    loss = criterion(output, target_batch)
    if (epoch + 1)%1000 == 0:
        print('Epoch:', '%04d' % (epoch + 1), 'cost =', '{:.6f}'.format(loss))
#反向传播，参数寻优
    loss.backward()
    optimizer.step()

# Predict
predict = model(input_batch).data.max(1, keepdim=True)[1]

# Test
print([sen.split()[:2] for sen in sentences], '-&gt;', [number_dict[n.item()] for n in predict.squeeze()])</code></pre> 
  <p>&nbsp;</p> 
  <h2 id="h2-3">2、Hierarchical Softmax</h2> 
  <p>&nbsp;</p> 
  <p>无论是哪种模型，其基本网络结构都是在下图的基础上，省略掉hidden layer：&nbsp; &nbsp;</p> 
  <figure class="image">
   <img alt="" height="319" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190517215729128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlbndlbm8wbw==,size_16,color_FFFFFF,t_70" width="802">
   <figcaption>
    模型基本结构
   </figcaption>
  </figure>
  <p>&nbsp;</p> 
  <p>为什么要去掉这一层呢？据说是因为word2vec的作者嫌从hidden layer到output layer的矩阵运算太多了。于是两种模型的网络结构是：</p> 
  <p><img alt="" class="has" height="513" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190517215929469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlbndlbm8wbw==,size_16,color_FFFFFF,t_70" width="891"></p> 
  <p>&nbsp;</p> 
  <p>其中w(t)代表当前词语位于句子的位置t，同理定义其他记号。在窗口内（上图为窗口大小为5），除了当前词语之外的其他词语共同构成上下文。</p> 
  <h3 id="h3-5">2.1、CBOW</h3> 
  <p><strong>原理</strong></p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; CBOW 是 Continuous Bag-of-Words Model 的缩写，是一种根据上下文的词语预测当前词语的出现概率的模型。其图示如上图左。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CBOW是已知上下文，估算当前词语的语言模型。其学习目标是最大化对数似然函数：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" height="79" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190517220115997.png" width="310"></p> 
  <p>其中，w表示语料库C中任意一个词。从上图可以看出，对于CBOW，</p> 
  <p><strong>输入层</strong>是上下文的词语的词向量（什么！我们不是在训练词向量吗？不不不，我们是在训练CBOW模型，词向量只是个副产品，确切来说，是CBOW模型的一个参数。训练开始的时候，词向量是个随机值，随着训练的进行不断被更新）。</p> 
  <p><strong>投影层</strong>对其求和，所谓求和，就是简单的向量加法。</p> 
  <p><strong>输出层</strong>输出最可能的w。由于语料库中词汇量是固定的|C|个，所以上述过程其实可以看做一个多分类问题。给定特征，从|C|个分类中挑一个</p> 
  <p>对于神经网络模型多分类，最朴素的做法是softmax回归：</p> 
  <p>&nbsp;<img alt="" class="has" height="163" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190517220338553.png" width="622"></p> 
  <p>softmax回归需要对语料库中每个词语（类）都计算一遍输出概率并进行归一化，在几十万词汇量的语料上无疑是令人头疼的。</p> 
  <p>不用softmax怎么样？比如SVM中的多分类，我们都知道其多分类是由二分类组合而来的：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" class="has" height="378" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051722072691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlbndlbm8wbw==,size_16,color_FFFFFF,t_70" width="510"></p> 
  <p>这是一种二叉树结构，应用到word2vec中被作者称为Hierarchical Softmax：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" height="535" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190517220818391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlbndlbm8wbw==,size_16,color_FFFFFF,t_70" width="643"></p> 
  <p>上图输出层的树形结构即为Hierarchical Softmax。</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h3 id="h3-6">2.2、Skip-gram</h3> 
  <p><strong>原理</strong></p> 
  <p>Skip-gram只是逆转了CBOW的因果关系而已，即已知当前词语，预测上下文。</p> 
  <p>其网络结构如下图所示：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" height="457" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190518145523854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlbndlbm8wbw==,size_16,color_FFFFFF,t_70" width="658"></p> 
  <p>上图与CBOW的两个不同在于</p> 
  <ol>
   <li> <p>输入层不再是多个词向量，而是一个词向量</p> </li> 
   <li> <p>投影层其实什么事情都没干，直接将输入层的词向量传递给输出层</p> </li> 
  </ol>
  <p>（以上参考：<a href="http://www.hankcs.com/nlp/word2vec.html" rel="nofollow">http://www.hankcs.com/nlp/word2vec.html</a>）</p> 
  <p>代码示例（skip gram）：</p> 
  <pre class="has">
<code>#skip gram
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.autograd import Variable
import matplotlib.pyplot as plt

dtype = torch.FloatTensor

# 3 Words Sentence
sentences = [ "i like dog", "i like cat", "i like animal",
              "dog cat animal", "apple cat dog like", "dog fish milk like",
              "dog cat eyes like", "i like apple", "apple i hate",
              "apple i movie book music like", "cat dog hate", "cat dog like"]

word_sequence = " ".join(sentences).split()
word_list = " ".join(sentences).split()
word_list = list(set(word_list))
word_dict = {w: i for i, w in enumerate(word_list)}

# Word2Vec Parameter
batch_size = 20  # To show 2 dim embedding graph
embedding_size = 2  # To show 2 dim embedding graph
voc_size = len(word_list)

def random_batch(data, size):
    random_inputs = []
    random_labels = []
    random_index = np.random.choice(range(len(data)), size, replace=False)

    for i in random_index:
        random_inputs.append(np.eye(voc_size)[data[i][0]])  # target
        random_labels.append(data[i][1])  # context word

    return random_inputs, random_labels

# Make skip gram of one size window
skip_grams = []
for i in range(1, len(word_sequence) - 1):
    target = word_dict[word_sequence[i]]
    context = [word_dict[word_sequence[i - 1]], word_dict[word_sequence[i + 1]]]

    for w in context:
        skip_grams.append([target, w])

# Model
class Word2Vec(nn.Module):
    def __init__(self):
        super(Word2Vec, self).__init__()

        # W and WT is not Traspose relationship
        self.W = nn.Parameter(-2 * torch.rand(voc_size, embedding_size) + 1).type(dtype) # voc_size &gt; embedding_size Weight
        self.WT = nn.Parameter(-2 * torch.rand(embedding_size, voc_size) + 1).type(dtype) # embedding_size &gt; voc_size Weight

    def forward(self, X):
        # X : [batch_size, voc_size]
        hidden_layer = torch.matmul(X, self.W) # hidden_layer : [batch_size, embedding_size]
        output_layer = torch.matmul(hidden_layer, self.WT) # output_layer : [batch_size, voc_size]
        return output_layer

model = Word2Vec()

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training
for epoch in range(5000):

    input_batch, target_batch = random_batch(skip_grams, batch_size)

    input_batch = Variable(torch.Tensor(input_batch))
    target_batch = Variable(torch.LongTensor(target_batch))

    optimizer.zero_grad()
    output = model(input_batch)

    # output : [batch_size, voc_size], target_batch : [batch_size] (LongTensor, not one-hot)
    loss = criterion(output, target_batch)
    if (epoch + 1)%1000 == 0:
        print('Epoch:', '%04d' % (epoch + 1), 'cost =', '{:.6f}'.format(loss))

    loss.backward()
    optimizer.step()

for i, label in enumerate(word_list):
    W, WT = model.parameters()
    x,y = float(W[i][0]), float(W[i][1])
    plt.scatter(x, y)
    plt.annotate(label, xy=(x, y), xytext=(5, 2), textcoords='offset points', ha='right', va='bottom')
plt.show()</code></pre> 
  <p>&nbsp;</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
