<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>揭秘！现代IM系统的消息架构如何设计？ | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="揭秘！现代IM系统的消息架构如何设计？" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="阿里妹导读：IM全称是『Instant Messaging』，中文名是即时通讯。在高度信息化的移动互联网时代，生活中IM类产品已经成为必备品，像“钉钉”以IM为核心功能的产品。还有一些非以IM系统为核心的应用，最典型的如一些在线游戏、社交应用，IM也是其重要的功能模块。可以说，IM系统已经是任何一个带有社交属性的应用需要具备的基础功能，网络上对于这类系统的设计与实现的讨论也越来越多。今天，阿里巴巴高级技术专家木洛，就为你揭秘现代 IM 系统中的消息系统架构。 前言 IM系统在互联网初期即存在，其基础技术架构在这十几年的发展中更新迭代多次，从早期的CS、P2P架构，到现在后台已经演变为一个复杂的分布式系统，涉及移动端、网络通信、协议、安全、存储和搜索等技术的方方面面。IM系统中最核心的部分是消息系统，消息系统中最核心的功能是消息的同步、存储和检索： 消息的同步：将消息完整、快速地从发送方传递到接收方，就是消息的同步。消息同步系统最重要的衡量指标就是消息传递的实时性、完整性以及能支撑的消息规模。从功能上来说，一般至少要支持在线和离线推送，高级的IM系统还支持『多端同步』。 消息的存储：消息存储即消息的持久化保存，传统消息系统通常只能支持消息在接收端的本地存储，数据基本不具备可靠性。现代消息系统能支持消息在服务端的在线存储，功能上对应的就是『消息漫游』，消息漫游的好处是可以实现账号在任意端登陆查看所有历史消息。 消息的检索：消息一般是文本，所以支持全文检索也是必备的能力之一。传统消息系统通常来说也是只能支持消息的本地检索，基于本地存储的消息数据来构建。而现在消息系统在能支持消息的在线存储后，也具备了消息的『在线检索』能力。 本篇文章内容主要涉及IM系统中的消息系统架构，会介绍一种基于阿里云表格存储&nbsp;Tablestore&nbsp;的 Timeline 模型构建的消息系统。基于 Tablestore Timeline 构建的现代消息系统，能够同时支持消息系统的众多高级特性，包括『多端同步』、『消息漫游』和『在线检索』。在性能和规模上，能够做到全量消息云端存储和索引，百万 TPS 写入以及毫秒级延迟的消息同步和检索能力。 之后我们会继续发表两篇文章，来更详细介绍 Tablestore Timeline 模型概念及使用： 模型篇：详细介绍 Tablestore Timeline 模型的基本概念和基础数据结构，并结合 IM 系统进行基本的建模。 实现篇：会基于 Tablestore Timeline 实现一个具备『多端同步』、『消息漫游』和『在线检索』这些高级功能的简易IM系统，并共享我们的源代码。 传统架构 vs 现代架构 传统架构下，消息是先同步后存储。对于在线的用户，消息会直接实时同步到在线的接收方，消息同步成功后，并不会在服务端持久化。而对于离线的用户或者消息无法实时同步成功时，消息会持久化到离线库，当接收方重新连接后，会从离线库拉取所有未读消息。当离线库中的消息成功同步到接收方后，消息会从离线库中删除。传统的消息系统，服务端的主要工作是维护发送方和接收方的连接状态，并提供在线消息同步和离线消息缓存的能力，保证消息一定能够从发送方传递到接收方。服务端不会对消息进行持久化，所以也无法支持消息漫游。消息的持久化存储及索引同样只能在接收端本地实现，数据可靠性极低。 现代架构下，消息是先存储后同步。先存储后同步的好处是，如果接收方确认接收到了消息，那这条消息一定是已经在云端保存了。并且消息会有两个库来保存，一个是消息存储库，用于全量保存所有会话的消息，主要用于支持消息漫游。另一个是消息同步库，主要用于接收方的多端同步。消息从发送方发出后，经过服务端转发，服务端会先将消息保存到消息存储库，后保存到消息同步库。 完成消息的持久化保存后，对于在线的接收方，会直接选择在线推送。但在线推送并不是一个必须路径，只是一个更优的消息传递路径。对于在线推送失败或者离线的接收方，会有另外一个统一的消息同步方式。接收方会主动的向服务端拉取所有未同步消息，但接收方何时来同步以及会在哪些端来同步消息对服务端来说是未知的，所以要求服务端必须保存所有需要同步到接收方的消息，这是消息同步库的主要作用。 对于新的同步设备，会有消息漫游的需求，这是消息存储库的主要作用，在消息存储库中，可以拉取任意会话的全量历史消息。消息检索的实现依赖于对消息存储库内消息的索引，通常是一个近实时（NRT，near real time）的索引构建过程，这个索引同样是在线的。 以上就是传统架构和现代架构的一个简单的对比，现代架构上整个消息的同步、存储和索引流程，并没有变复杂太多。现代架构的实现本质上是把传统架构内本地存储和索引都搬到云上，最大挑战是需要集中管理全量消息的存储和索引，带来的好处是能实现多端同步、消息漫游以及在线检索。可以看到现代架构中最核心的就是两个消息库『消息同步库』和『消息存储库』，以及对『消息存储库』的『消息索引』的实现，接下来我们逐步拆解这几个核心的设计和实现。 基础模型 在深入讲解消息系统的设计和实现之前，需要对消息系统内的几个基本概念和基础模型有一个理解。网上分析的很多的不同类型的消息系统实现，实现差异上主要在消息同步和存储的方案上，在消息的数据模型上其实有很大的共性。围绕数据同步模型的讨论主要在『读扩散』、『写扩散』和『混合模式』这三种方案，目前还没有更多的选择。而对于数据模型的抽象，还没有一个标准的定义。 本章节会介绍下表格存储 Tablestore 提出的 Timeline 模型，这是一个对消息系统内消息模型的一个抽象，能简化和更好地让开发者理解消息系统内的消息同步和存储模型，基于此模型我们会再深入探讨消息的同步和存储的选择和实现。 Timeline模型 Timeline是一个对消息抽象的逻辑模型，该模型会帮助我们简化对消息同步和存储模型的理解，而消息同步库和存储库的设计和实现也是围绕Timeline的特性和需求来展开。 如图是 Timeline 模型的一个抽象表述，Timeline 可以简单理解为是一个消息队列，但这个消息队列有如下特性： 每条消息对应一个顺序ID：每个消息拥有一个唯一的顺序ID（SequenceId），队列消息按 SequenceId 排序。 新消息写入能自动分配递增的顺序 ID，保证永远插入队尾：Timeline 中是根据同步位点也就是顺序 ID 来同步消息，所以需要保证新写入的消息数据的顺序 ID 绝对不能比已同步的消息的顺序 ID 还小，否则会导致数据漏同步，所以需要支持对新写入的数据自动分配比当前已存储的所有消息的顺序 ID 更大的顺序 ID 。 新消息写入也能自定义顺序 ID，满足自定义排序需求：上面提到的自动分配顺序 ID，主要是为了满足消息同步的需求，消息同步要求消息是根据『已同步』或是『已写入』的顺序来排序。而消息的存储，通常要求消息能根据会话顺序来排序，会话顺序通常由端的会话来决定，而不是服务端的同步顺序来定，这是两种顺序要求。 支持根据顺序 ID 的随机定位：可根据 SequenceId 随机定位到 Timeline 中的某个位置，从这个位置开始正序或逆序的读取消息，也可支持读取指定顺序ID的某条消息。 支持对消息的自定义索引：消息体内数据根据业务不同会包含不同的字段， Timeline 需要支持对不同字段的自定义索引，来支持对消息内容的全文索引，或者是任意字段的灵活条件组合查询。 消息同步可以基于 Timeline 很简单的实现，图中的例子中，消息发送方是A，消息接收方是B，同时B存在多个接收端，分别是B1、B2和B3。A向B发送消息，消息需要同步到B的多个端，待同步的消息通过一个 Timeline 来进行交换。A向B发送的所有消息，都会保存在这个 Timeline 中，B的每个接收端都是独立的从这个 Timeline中拉取消息。每个接收端同步完毕后，都会在本地记录下最新同步到的消息的SequenceId，即最新的一个位点，作为下次消息同步的起始位点。服务端不会保存各个端的同步状态，各个端均可以在任意时间从任意点开始拉取消息。 消息存储也是基于 Timeline 实现，和消息同步唯一的区别是，消息存储要求服务端能够对 Timeline 内的所有数据进行持久化，并且消息采用会话顺序来保存，需要自定义顺序 ID。 消息检索基于 Timeline 提供的消息索引来实现，能支持比较灵活的多字段索引，根据业务的不同可有自由度较高的定制。 消息存储模型 如图是基于 Timeline 的消息存储模型，消息存储要求每个会话都对应一个独立的 Timeline 。如图例子所示，A与B/C/D/E/F均发生了会话，每个会话对应一个独立的 Timeline，每个 Timeline 内存有这个会话中的所有消息，消息根据会话顺序排序，服务端会对每个 Timeline 进行持久化存储，也就拥有了消息漫游的能力。 消息同步模型 消息同步模型会比消息存储模型稍复杂一些，消息的同步一般有读扩散（也叫拉模式）和写扩散（也叫推模式）两种不同的方式，分别对应不同的 Timeline 物理模型。 如图是读扩散和写扩散两种不同同步模式下对应的不同的 Timeline 模型，按图中的示例，A作为消息接收者，其与B/C/D/E/F发生了会话，每个会话中的新的消息都需要同步到A的某个端，看下读扩散和写扩散两种模式下消息如何做同步。 读扩散：消息存储模型中，每个会话的 Timeline 中保存了这个会话的全量消息。读扩散的消息同步模式下，每个会话中产生的新的消息，只需要写一次到其用于存储的 Timeline 中，接收端从这个 Timeline 中拉取新的消息。优点是消息只需要写一次，相比写扩散的模式，能够大大降低消息写入次数，特别是在群消息这种场景下。但其缺点也比较明显，接收端去同步消息的逻辑会相对复杂和低效。接收端需要对每个会话都拉取一次才能获取全部消息，读被大大的放大，并且会产生很多无效的读，因为并不是每个会话都会有新消息产生。 写扩散：写扩散的消息同步模式，需要有一个额外的 Timeline 来专门用于消息同步，通常是每个接收端都会拥有一个独立的同步 Timeline（或者叫收件箱），用于存放需要向这个接收端同步的所有消息。每个会话中的消息，会产生多次写，除了写入用于消息存储的会话 Timeline，还需要写入需要同步到的接收端的同步 Timeline。在个人与个人的会话中，消息会被额外写两次，除了写入这个会话的存储 Timeline，还需要写入参与这个会话的两个接收者的同步 Timeline。而在群这个场景下，写入会被更加的放大，如果这个群拥有N个参与者，那每条消息都需要额外地写N次。写扩散同步模式的优点是，在接收端消息同步逻辑会非常简单，只需要从其同步 Timeline 中读取一次即可，大大降低了消息同步所需的读的压力。其缺点就是消息写入会被放大，特别是针对群这种场景。 Timeline 模型不会对选择读扩散还是写扩散做约束，而是能同时支持两种模式，因为本质上两种模式的逻辑数据模型并无差别，只是消息数据是用一个 Timeline 来支持多端读还是复制到多个 Timeline 来支持多端读的问题。 针对 IM 这种应用场景，消息系统通常会选择写扩散这种消息同步模式。IM 场景下，一条消息只会产生一次，但是会被读取多次，是典型的读多写少的场景，消息的读写比例大概是10:1。若使用读扩散同步模式，整个系统的读写比例会被放大到100:1。一个优化的好的系统，必须从设计上去平衡这种读写压力，避免读或写任意一维触碰到天花板。所以 IM 系统这类场景下，通常会应用写扩散这种同步模式，来平衡读和写，将100:1的读写比例平衡到30:30。当然写扩散这种同步模式，还需要处理一些极端场景，例如万人大群。 针对这种极端写扩散的场景，会退化到使用读扩散。一个简单的IM系统，通常会在产品层面限制这种大群的存在，而对于一个高级的IM系统，会采用读写扩散混合的同步模式，来满足这类产品的需求。采用混合模式，会根据数据的不同类型和不同的读写负载，来决定用写扩散还是读扩散。 典型架构设计 如图是一个典型的消息系统架构，架构中包含几个重要组件： 端：作为消息的发送和接收端，通过连接消息服务器来发送和接收消息。 消息服务器：一组无状态的服务器，可水平扩展，处理消息的发送和接收请求，连接后端消息系统。 消息队列：新写入消息的缓冲队列，消息系统的前置消息存储，用于削峰填谷以及异步消费。 消息处理：一组无状态的消费处理服务器，用于异步消费消息队列中的消息数据，处理消息的持久化和写扩散同步。 消息存储和索引库：持久化存储消息，每个会话对应一个 Timeline 进行消息存储，存储的消息建立索引来实现消息检索。 消息同步库：写扩散形式同步消息，每个用户的收件箱对应一个 Timeline，同步库内消息不需要永久保存，通常对消息设定一个生命周期。 新消息会由端发出，通常消息体中会携带消息ID（用于去重）、逻辑时间戳（用于排序）、消息类型（控制消息、图片消息或者文本消息等）、消息体等内容。消息会先写入消息队列，作为底层存储的一个临时缓冲区。消息队列中的消息会由消息处理服务器消费，可以允许乱序消费。消息处理服务器对消息先存储后同步，先写入发件箱 Timeline （存储库），后写扩散至各个接收端的收件箱（同步库）。消息数据写入存储库后，会被近实时的构建索引，索引包括文本消息的全文索引以及多字段索引（发送方、消息类型等）。 对于在线的设备，可以由消息服务器主动推送至在线设备端。对于离线设备，登录后会主动向服务端同步消息。每个设备会在本地保留有最新一条消息的顺序ID，向服务端同步该顺序ID后的所有消息。 总结 本篇文章主要介绍了现代 IM 系统中消息系统所需要具备的能力，对比了传统架构和现代架构。为方便接下来的深入探讨，介绍了表格存储 Tablestore 推出的 Timeline 模型，以及在 IM 系统中消息存储和消息同步模型的基本概念和策略，最后介绍了一个典型的架构设计。希望和同仁共同探讨、交流。 你可能还喜欢 点击下方图片即可阅读 贾扬清：我对人工智能方向的一点浅见 如何搞定技术面试？阿里大牛为你选了8本必备好书 在阿里做了五年技术主管，我有话想说" />
<meta property="og:description" content="阿里妹导读：IM全称是『Instant Messaging』，中文名是即时通讯。在高度信息化的移动互联网时代，生活中IM类产品已经成为必备品，像“钉钉”以IM为核心功能的产品。还有一些非以IM系统为核心的应用，最典型的如一些在线游戏、社交应用，IM也是其重要的功能模块。可以说，IM系统已经是任何一个带有社交属性的应用需要具备的基础功能，网络上对于这类系统的设计与实现的讨论也越来越多。今天，阿里巴巴高级技术专家木洛，就为你揭秘现代 IM 系统中的消息系统架构。 前言 IM系统在互联网初期即存在，其基础技术架构在这十几年的发展中更新迭代多次，从早期的CS、P2P架构，到现在后台已经演变为一个复杂的分布式系统，涉及移动端、网络通信、协议、安全、存储和搜索等技术的方方面面。IM系统中最核心的部分是消息系统，消息系统中最核心的功能是消息的同步、存储和检索： 消息的同步：将消息完整、快速地从发送方传递到接收方，就是消息的同步。消息同步系统最重要的衡量指标就是消息传递的实时性、完整性以及能支撑的消息规模。从功能上来说，一般至少要支持在线和离线推送，高级的IM系统还支持『多端同步』。 消息的存储：消息存储即消息的持久化保存，传统消息系统通常只能支持消息在接收端的本地存储，数据基本不具备可靠性。现代消息系统能支持消息在服务端的在线存储，功能上对应的就是『消息漫游』，消息漫游的好处是可以实现账号在任意端登陆查看所有历史消息。 消息的检索：消息一般是文本，所以支持全文检索也是必备的能力之一。传统消息系统通常来说也是只能支持消息的本地检索，基于本地存储的消息数据来构建。而现在消息系统在能支持消息的在线存储后，也具备了消息的『在线检索』能力。 本篇文章内容主要涉及IM系统中的消息系统架构，会介绍一种基于阿里云表格存储&nbsp;Tablestore&nbsp;的 Timeline 模型构建的消息系统。基于 Tablestore Timeline 构建的现代消息系统，能够同时支持消息系统的众多高级特性，包括『多端同步』、『消息漫游』和『在线检索』。在性能和规模上，能够做到全量消息云端存储和索引，百万 TPS 写入以及毫秒级延迟的消息同步和检索能力。 之后我们会继续发表两篇文章，来更详细介绍 Tablestore Timeline 模型概念及使用： 模型篇：详细介绍 Tablestore Timeline 模型的基本概念和基础数据结构，并结合 IM 系统进行基本的建模。 实现篇：会基于 Tablestore Timeline 实现一个具备『多端同步』、『消息漫游』和『在线检索』这些高级功能的简易IM系统，并共享我们的源代码。 传统架构 vs 现代架构 传统架构下，消息是先同步后存储。对于在线的用户，消息会直接实时同步到在线的接收方，消息同步成功后，并不会在服务端持久化。而对于离线的用户或者消息无法实时同步成功时，消息会持久化到离线库，当接收方重新连接后，会从离线库拉取所有未读消息。当离线库中的消息成功同步到接收方后，消息会从离线库中删除。传统的消息系统，服务端的主要工作是维护发送方和接收方的连接状态，并提供在线消息同步和离线消息缓存的能力，保证消息一定能够从发送方传递到接收方。服务端不会对消息进行持久化，所以也无法支持消息漫游。消息的持久化存储及索引同样只能在接收端本地实现，数据可靠性极低。 现代架构下，消息是先存储后同步。先存储后同步的好处是，如果接收方确认接收到了消息，那这条消息一定是已经在云端保存了。并且消息会有两个库来保存，一个是消息存储库，用于全量保存所有会话的消息，主要用于支持消息漫游。另一个是消息同步库，主要用于接收方的多端同步。消息从发送方发出后，经过服务端转发，服务端会先将消息保存到消息存储库，后保存到消息同步库。 完成消息的持久化保存后，对于在线的接收方，会直接选择在线推送。但在线推送并不是一个必须路径，只是一个更优的消息传递路径。对于在线推送失败或者离线的接收方，会有另外一个统一的消息同步方式。接收方会主动的向服务端拉取所有未同步消息，但接收方何时来同步以及会在哪些端来同步消息对服务端来说是未知的，所以要求服务端必须保存所有需要同步到接收方的消息，这是消息同步库的主要作用。 对于新的同步设备，会有消息漫游的需求，这是消息存储库的主要作用，在消息存储库中，可以拉取任意会话的全量历史消息。消息检索的实现依赖于对消息存储库内消息的索引，通常是一个近实时（NRT，near real time）的索引构建过程，这个索引同样是在线的。 以上就是传统架构和现代架构的一个简单的对比，现代架构上整个消息的同步、存储和索引流程，并没有变复杂太多。现代架构的实现本质上是把传统架构内本地存储和索引都搬到云上，最大挑战是需要集中管理全量消息的存储和索引，带来的好处是能实现多端同步、消息漫游以及在线检索。可以看到现代架构中最核心的就是两个消息库『消息同步库』和『消息存储库』，以及对『消息存储库』的『消息索引』的实现，接下来我们逐步拆解这几个核心的设计和实现。 基础模型 在深入讲解消息系统的设计和实现之前，需要对消息系统内的几个基本概念和基础模型有一个理解。网上分析的很多的不同类型的消息系统实现，实现差异上主要在消息同步和存储的方案上，在消息的数据模型上其实有很大的共性。围绕数据同步模型的讨论主要在『读扩散』、『写扩散』和『混合模式』这三种方案，目前还没有更多的选择。而对于数据模型的抽象，还没有一个标准的定义。 本章节会介绍下表格存储 Tablestore 提出的 Timeline 模型，这是一个对消息系统内消息模型的一个抽象，能简化和更好地让开发者理解消息系统内的消息同步和存储模型，基于此模型我们会再深入探讨消息的同步和存储的选择和实现。 Timeline模型 Timeline是一个对消息抽象的逻辑模型，该模型会帮助我们简化对消息同步和存储模型的理解，而消息同步库和存储库的设计和实现也是围绕Timeline的特性和需求来展开。 如图是 Timeline 模型的一个抽象表述，Timeline 可以简单理解为是一个消息队列，但这个消息队列有如下特性： 每条消息对应一个顺序ID：每个消息拥有一个唯一的顺序ID（SequenceId），队列消息按 SequenceId 排序。 新消息写入能自动分配递增的顺序 ID，保证永远插入队尾：Timeline 中是根据同步位点也就是顺序 ID 来同步消息，所以需要保证新写入的消息数据的顺序 ID 绝对不能比已同步的消息的顺序 ID 还小，否则会导致数据漏同步，所以需要支持对新写入的数据自动分配比当前已存储的所有消息的顺序 ID 更大的顺序 ID 。 新消息写入也能自定义顺序 ID，满足自定义排序需求：上面提到的自动分配顺序 ID，主要是为了满足消息同步的需求，消息同步要求消息是根据『已同步』或是『已写入』的顺序来排序。而消息的存储，通常要求消息能根据会话顺序来排序，会话顺序通常由端的会话来决定，而不是服务端的同步顺序来定，这是两种顺序要求。 支持根据顺序 ID 的随机定位：可根据 SequenceId 随机定位到 Timeline 中的某个位置，从这个位置开始正序或逆序的读取消息，也可支持读取指定顺序ID的某条消息。 支持对消息的自定义索引：消息体内数据根据业务不同会包含不同的字段， Timeline 需要支持对不同字段的自定义索引，来支持对消息内容的全文索引，或者是任意字段的灵活条件组合查询。 消息同步可以基于 Timeline 很简单的实现，图中的例子中，消息发送方是A，消息接收方是B，同时B存在多个接收端，分别是B1、B2和B3。A向B发送消息，消息需要同步到B的多个端，待同步的消息通过一个 Timeline 来进行交换。A向B发送的所有消息，都会保存在这个 Timeline 中，B的每个接收端都是独立的从这个 Timeline中拉取消息。每个接收端同步完毕后，都会在本地记录下最新同步到的消息的SequenceId，即最新的一个位点，作为下次消息同步的起始位点。服务端不会保存各个端的同步状态，各个端均可以在任意时间从任意点开始拉取消息。 消息存储也是基于 Timeline 实现，和消息同步唯一的区别是，消息存储要求服务端能够对 Timeline 内的所有数据进行持久化，并且消息采用会话顺序来保存，需要自定义顺序 ID。 消息检索基于 Timeline 提供的消息索引来实现，能支持比较灵活的多字段索引，根据业务的不同可有自由度较高的定制。 消息存储模型 如图是基于 Timeline 的消息存储模型，消息存储要求每个会话都对应一个独立的 Timeline 。如图例子所示，A与B/C/D/E/F均发生了会话，每个会话对应一个独立的 Timeline，每个 Timeline 内存有这个会话中的所有消息，消息根据会话顺序排序，服务端会对每个 Timeline 进行持久化存储，也就拥有了消息漫游的能力。 消息同步模型 消息同步模型会比消息存储模型稍复杂一些，消息的同步一般有读扩散（也叫拉模式）和写扩散（也叫推模式）两种不同的方式，分别对应不同的 Timeline 物理模型。 如图是读扩散和写扩散两种不同同步模式下对应的不同的 Timeline 模型，按图中的示例，A作为消息接收者，其与B/C/D/E/F发生了会话，每个会话中的新的消息都需要同步到A的某个端，看下读扩散和写扩散两种模式下消息如何做同步。 读扩散：消息存储模型中，每个会话的 Timeline 中保存了这个会话的全量消息。读扩散的消息同步模式下，每个会话中产生的新的消息，只需要写一次到其用于存储的 Timeline 中，接收端从这个 Timeline 中拉取新的消息。优点是消息只需要写一次，相比写扩散的模式，能够大大降低消息写入次数，特别是在群消息这种场景下。但其缺点也比较明显，接收端去同步消息的逻辑会相对复杂和低效。接收端需要对每个会话都拉取一次才能获取全部消息，读被大大的放大，并且会产生很多无效的读，因为并不是每个会话都会有新消息产生。 写扩散：写扩散的消息同步模式，需要有一个额外的 Timeline 来专门用于消息同步，通常是每个接收端都会拥有一个独立的同步 Timeline（或者叫收件箱），用于存放需要向这个接收端同步的所有消息。每个会话中的消息，会产生多次写，除了写入用于消息存储的会话 Timeline，还需要写入需要同步到的接收端的同步 Timeline。在个人与个人的会话中，消息会被额外写两次，除了写入这个会话的存储 Timeline，还需要写入参与这个会话的两个接收者的同步 Timeline。而在群这个场景下，写入会被更加的放大，如果这个群拥有N个参与者，那每条消息都需要额外地写N次。写扩散同步模式的优点是，在接收端消息同步逻辑会非常简单，只需要从其同步 Timeline 中读取一次即可，大大降低了消息同步所需的读的压力。其缺点就是消息写入会被放大，特别是针对群这种场景。 Timeline 模型不会对选择读扩散还是写扩散做约束，而是能同时支持两种模式，因为本质上两种模式的逻辑数据模型并无差别，只是消息数据是用一个 Timeline 来支持多端读还是复制到多个 Timeline 来支持多端读的问题。 针对 IM 这种应用场景，消息系统通常会选择写扩散这种消息同步模式。IM 场景下，一条消息只会产生一次，但是会被读取多次，是典型的读多写少的场景，消息的读写比例大概是10:1。若使用读扩散同步模式，整个系统的读写比例会被放大到100:1。一个优化的好的系统，必须从设计上去平衡这种读写压力，避免读或写任意一维触碰到天花板。所以 IM 系统这类场景下，通常会应用写扩散这种同步模式，来平衡读和写，将100:1的读写比例平衡到30:30。当然写扩散这种同步模式，还需要处理一些极端场景，例如万人大群。 针对这种极端写扩散的场景，会退化到使用读扩散。一个简单的IM系统，通常会在产品层面限制这种大群的存在，而对于一个高级的IM系统，会采用读写扩散混合的同步模式，来满足这类产品的需求。采用混合模式，会根据数据的不同类型和不同的读写负载，来决定用写扩散还是读扩散。 典型架构设计 如图是一个典型的消息系统架构，架构中包含几个重要组件： 端：作为消息的发送和接收端，通过连接消息服务器来发送和接收消息。 消息服务器：一组无状态的服务器，可水平扩展，处理消息的发送和接收请求，连接后端消息系统。 消息队列：新写入消息的缓冲队列，消息系统的前置消息存储，用于削峰填谷以及异步消费。 消息处理：一组无状态的消费处理服务器，用于异步消费消息队列中的消息数据，处理消息的持久化和写扩散同步。 消息存储和索引库：持久化存储消息，每个会话对应一个 Timeline 进行消息存储，存储的消息建立索引来实现消息检索。 消息同步库：写扩散形式同步消息，每个用户的收件箱对应一个 Timeline，同步库内消息不需要永久保存，通常对消息设定一个生命周期。 新消息会由端发出，通常消息体中会携带消息ID（用于去重）、逻辑时间戳（用于排序）、消息类型（控制消息、图片消息或者文本消息等）、消息体等内容。消息会先写入消息队列，作为底层存储的一个临时缓冲区。消息队列中的消息会由消息处理服务器消费，可以允许乱序消费。消息处理服务器对消息先存储后同步，先写入发件箱 Timeline （存储库），后写扩散至各个接收端的收件箱（同步库）。消息数据写入存储库后，会被近实时的构建索引，索引包括文本消息的全文索引以及多字段索引（发送方、消息类型等）。 对于在线的设备，可以由消息服务器主动推送至在线设备端。对于离线设备，登录后会主动向服务端同步消息。每个设备会在本地保留有最新一条消息的顺序ID，向服务端同步该顺序ID后的所有消息。 总结 本篇文章主要介绍了现代 IM 系统中消息系统所需要具备的能力，对比了传统架构和现代架构。为方便接下来的深入探讨，介绍了表格存储 Tablestore 推出的 Timeline 模型，以及在 IM 系统中消息存储和消息同步模型的基本概念和策略，最后介绍了一个典型的架构设计。希望和同仁共同探讨、交流。 你可能还喜欢 点击下方图片即可阅读 贾扬清：我对人工智能方向的一点浅见 如何搞定技术面试？阿里大牛为你选了8本必备好书 在阿里做了五年技术主管，我有话想说" />
<link rel="canonical" href="https://mlh.app/2019/05/08/729987.html" />
<meta property="og:url" content="https://mlh.app/2019/05/08/729987.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-08T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"阿里妹导读：IM全称是『Instant Messaging』，中文名是即时通讯。在高度信息化的移动互联网时代，生活中IM类产品已经成为必备品，像“钉钉”以IM为核心功能的产品。还有一些非以IM系统为核心的应用，最典型的如一些在线游戏、社交应用，IM也是其重要的功能模块。可以说，IM系统已经是任何一个带有社交属性的应用需要具备的基础功能，网络上对于这类系统的设计与实现的讨论也越来越多。今天，阿里巴巴高级技术专家木洛，就为你揭秘现代 IM 系统中的消息系统架构。 前言 IM系统在互联网初期即存在，其基础技术架构在这十几年的发展中更新迭代多次，从早期的CS、P2P架构，到现在后台已经演变为一个复杂的分布式系统，涉及移动端、网络通信、协议、安全、存储和搜索等技术的方方面面。IM系统中最核心的部分是消息系统，消息系统中最核心的功能是消息的同步、存储和检索： 消息的同步：将消息完整、快速地从发送方传递到接收方，就是消息的同步。消息同步系统最重要的衡量指标就是消息传递的实时性、完整性以及能支撑的消息规模。从功能上来说，一般至少要支持在线和离线推送，高级的IM系统还支持『多端同步』。 消息的存储：消息存储即消息的持久化保存，传统消息系统通常只能支持消息在接收端的本地存储，数据基本不具备可靠性。现代消息系统能支持消息在服务端的在线存储，功能上对应的就是『消息漫游』，消息漫游的好处是可以实现账号在任意端登陆查看所有历史消息。 消息的检索：消息一般是文本，所以支持全文检索也是必备的能力之一。传统消息系统通常来说也是只能支持消息的本地检索，基于本地存储的消息数据来构建。而现在消息系统在能支持消息的在线存储后，也具备了消息的『在线检索』能力。 本篇文章内容主要涉及IM系统中的消息系统架构，会介绍一种基于阿里云表格存储&nbsp;Tablestore&nbsp;的 Timeline 模型构建的消息系统。基于 Tablestore Timeline 构建的现代消息系统，能够同时支持消息系统的众多高级特性，包括『多端同步』、『消息漫游』和『在线检索』。在性能和规模上，能够做到全量消息云端存储和索引，百万 TPS 写入以及毫秒级延迟的消息同步和检索能力。 之后我们会继续发表两篇文章，来更详细介绍 Tablestore Timeline 模型概念及使用： 模型篇：详细介绍 Tablestore Timeline 模型的基本概念和基础数据结构，并结合 IM 系统进行基本的建模。 实现篇：会基于 Tablestore Timeline 实现一个具备『多端同步』、『消息漫游』和『在线检索』这些高级功能的简易IM系统，并共享我们的源代码。 传统架构 vs 现代架构 传统架构下，消息是先同步后存储。对于在线的用户，消息会直接实时同步到在线的接收方，消息同步成功后，并不会在服务端持久化。而对于离线的用户或者消息无法实时同步成功时，消息会持久化到离线库，当接收方重新连接后，会从离线库拉取所有未读消息。当离线库中的消息成功同步到接收方后，消息会从离线库中删除。传统的消息系统，服务端的主要工作是维护发送方和接收方的连接状态，并提供在线消息同步和离线消息缓存的能力，保证消息一定能够从发送方传递到接收方。服务端不会对消息进行持久化，所以也无法支持消息漫游。消息的持久化存储及索引同样只能在接收端本地实现，数据可靠性极低。 现代架构下，消息是先存储后同步。先存储后同步的好处是，如果接收方确认接收到了消息，那这条消息一定是已经在云端保存了。并且消息会有两个库来保存，一个是消息存储库，用于全量保存所有会话的消息，主要用于支持消息漫游。另一个是消息同步库，主要用于接收方的多端同步。消息从发送方发出后，经过服务端转发，服务端会先将消息保存到消息存储库，后保存到消息同步库。 完成消息的持久化保存后，对于在线的接收方，会直接选择在线推送。但在线推送并不是一个必须路径，只是一个更优的消息传递路径。对于在线推送失败或者离线的接收方，会有另外一个统一的消息同步方式。接收方会主动的向服务端拉取所有未同步消息，但接收方何时来同步以及会在哪些端来同步消息对服务端来说是未知的，所以要求服务端必须保存所有需要同步到接收方的消息，这是消息同步库的主要作用。 对于新的同步设备，会有消息漫游的需求，这是消息存储库的主要作用，在消息存储库中，可以拉取任意会话的全量历史消息。消息检索的实现依赖于对消息存储库内消息的索引，通常是一个近实时（NRT，near real time）的索引构建过程，这个索引同样是在线的。 以上就是传统架构和现代架构的一个简单的对比，现代架构上整个消息的同步、存储和索引流程，并没有变复杂太多。现代架构的实现本质上是把传统架构内本地存储和索引都搬到云上，最大挑战是需要集中管理全量消息的存储和索引，带来的好处是能实现多端同步、消息漫游以及在线检索。可以看到现代架构中最核心的就是两个消息库『消息同步库』和『消息存储库』，以及对『消息存储库』的『消息索引』的实现，接下来我们逐步拆解这几个核心的设计和实现。 基础模型 在深入讲解消息系统的设计和实现之前，需要对消息系统内的几个基本概念和基础模型有一个理解。网上分析的很多的不同类型的消息系统实现，实现差异上主要在消息同步和存储的方案上，在消息的数据模型上其实有很大的共性。围绕数据同步模型的讨论主要在『读扩散』、『写扩散』和『混合模式』这三种方案，目前还没有更多的选择。而对于数据模型的抽象，还没有一个标准的定义。 本章节会介绍下表格存储 Tablestore 提出的 Timeline 模型，这是一个对消息系统内消息模型的一个抽象，能简化和更好地让开发者理解消息系统内的消息同步和存储模型，基于此模型我们会再深入探讨消息的同步和存储的选择和实现。 Timeline模型 Timeline是一个对消息抽象的逻辑模型，该模型会帮助我们简化对消息同步和存储模型的理解，而消息同步库和存储库的设计和实现也是围绕Timeline的特性和需求来展开。 如图是 Timeline 模型的一个抽象表述，Timeline 可以简单理解为是一个消息队列，但这个消息队列有如下特性： 每条消息对应一个顺序ID：每个消息拥有一个唯一的顺序ID（SequenceId），队列消息按 SequenceId 排序。 新消息写入能自动分配递增的顺序 ID，保证永远插入队尾：Timeline 中是根据同步位点也就是顺序 ID 来同步消息，所以需要保证新写入的消息数据的顺序 ID 绝对不能比已同步的消息的顺序 ID 还小，否则会导致数据漏同步，所以需要支持对新写入的数据自动分配比当前已存储的所有消息的顺序 ID 更大的顺序 ID 。 新消息写入也能自定义顺序 ID，满足自定义排序需求：上面提到的自动分配顺序 ID，主要是为了满足消息同步的需求，消息同步要求消息是根据『已同步』或是『已写入』的顺序来排序。而消息的存储，通常要求消息能根据会话顺序来排序，会话顺序通常由端的会话来决定，而不是服务端的同步顺序来定，这是两种顺序要求。 支持根据顺序 ID 的随机定位：可根据 SequenceId 随机定位到 Timeline 中的某个位置，从这个位置开始正序或逆序的读取消息，也可支持读取指定顺序ID的某条消息。 支持对消息的自定义索引：消息体内数据根据业务不同会包含不同的字段， Timeline 需要支持对不同字段的自定义索引，来支持对消息内容的全文索引，或者是任意字段的灵活条件组合查询。 消息同步可以基于 Timeline 很简单的实现，图中的例子中，消息发送方是A，消息接收方是B，同时B存在多个接收端，分别是B1、B2和B3。A向B发送消息，消息需要同步到B的多个端，待同步的消息通过一个 Timeline 来进行交换。A向B发送的所有消息，都会保存在这个 Timeline 中，B的每个接收端都是独立的从这个 Timeline中拉取消息。每个接收端同步完毕后，都会在本地记录下最新同步到的消息的SequenceId，即最新的一个位点，作为下次消息同步的起始位点。服务端不会保存各个端的同步状态，各个端均可以在任意时间从任意点开始拉取消息。 消息存储也是基于 Timeline 实现，和消息同步唯一的区别是，消息存储要求服务端能够对 Timeline 内的所有数据进行持久化，并且消息采用会话顺序来保存，需要自定义顺序 ID。 消息检索基于 Timeline 提供的消息索引来实现，能支持比较灵活的多字段索引，根据业务的不同可有自由度较高的定制。 消息存储模型 如图是基于 Timeline 的消息存储模型，消息存储要求每个会话都对应一个独立的 Timeline 。如图例子所示，A与B/C/D/E/F均发生了会话，每个会话对应一个独立的 Timeline，每个 Timeline 内存有这个会话中的所有消息，消息根据会话顺序排序，服务端会对每个 Timeline 进行持久化存储，也就拥有了消息漫游的能力。 消息同步模型 消息同步模型会比消息存储模型稍复杂一些，消息的同步一般有读扩散（也叫拉模式）和写扩散（也叫推模式）两种不同的方式，分别对应不同的 Timeline 物理模型。 如图是读扩散和写扩散两种不同同步模式下对应的不同的 Timeline 模型，按图中的示例，A作为消息接收者，其与B/C/D/E/F发生了会话，每个会话中的新的消息都需要同步到A的某个端，看下读扩散和写扩散两种模式下消息如何做同步。 读扩散：消息存储模型中，每个会话的 Timeline 中保存了这个会话的全量消息。读扩散的消息同步模式下，每个会话中产生的新的消息，只需要写一次到其用于存储的 Timeline 中，接收端从这个 Timeline 中拉取新的消息。优点是消息只需要写一次，相比写扩散的模式，能够大大降低消息写入次数，特别是在群消息这种场景下。但其缺点也比较明显，接收端去同步消息的逻辑会相对复杂和低效。接收端需要对每个会话都拉取一次才能获取全部消息，读被大大的放大，并且会产生很多无效的读，因为并不是每个会话都会有新消息产生。 写扩散：写扩散的消息同步模式，需要有一个额外的 Timeline 来专门用于消息同步，通常是每个接收端都会拥有一个独立的同步 Timeline（或者叫收件箱），用于存放需要向这个接收端同步的所有消息。每个会话中的消息，会产生多次写，除了写入用于消息存储的会话 Timeline，还需要写入需要同步到的接收端的同步 Timeline。在个人与个人的会话中，消息会被额外写两次，除了写入这个会话的存储 Timeline，还需要写入参与这个会话的两个接收者的同步 Timeline。而在群这个场景下，写入会被更加的放大，如果这个群拥有N个参与者，那每条消息都需要额外地写N次。写扩散同步模式的优点是，在接收端消息同步逻辑会非常简单，只需要从其同步 Timeline 中读取一次即可，大大降低了消息同步所需的读的压力。其缺点就是消息写入会被放大，特别是针对群这种场景。 Timeline 模型不会对选择读扩散还是写扩散做约束，而是能同时支持两种模式，因为本质上两种模式的逻辑数据模型并无差别，只是消息数据是用一个 Timeline 来支持多端读还是复制到多个 Timeline 来支持多端读的问题。 针对 IM 这种应用场景，消息系统通常会选择写扩散这种消息同步模式。IM 场景下，一条消息只会产生一次，但是会被读取多次，是典型的读多写少的场景，消息的读写比例大概是10:1。若使用读扩散同步模式，整个系统的读写比例会被放大到100:1。一个优化的好的系统，必须从设计上去平衡这种读写压力，避免读或写任意一维触碰到天花板。所以 IM 系统这类场景下，通常会应用写扩散这种同步模式，来平衡读和写，将100:1的读写比例平衡到30:30。当然写扩散这种同步模式，还需要处理一些极端场景，例如万人大群。 针对这种极端写扩散的场景，会退化到使用读扩散。一个简单的IM系统，通常会在产品层面限制这种大群的存在，而对于一个高级的IM系统，会采用读写扩散混合的同步模式，来满足这类产品的需求。采用混合模式，会根据数据的不同类型和不同的读写负载，来决定用写扩散还是读扩散。 典型架构设计 如图是一个典型的消息系统架构，架构中包含几个重要组件： 端：作为消息的发送和接收端，通过连接消息服务器来发送和接收消息。 消息服务器：一组无状态的服务器，可水平扩展，处理消息的发送和接收请求，连接后端消息系统。 消息队列：新写入消息的缓冲队列，消息系统的前置消息存储，用于削峰填谷以及异步消费。 消息处理：一组无状态的消费处理服务器，用于异步消费消息队列中的消息数据，处理消息的持久化和写扩散同步。 消息存储和索引库：持久化存储消息，每个会话对应一个 Timeline 进行消息存储，存储的消息建立索引来实现消息检索。 消息同步库：写扩散形式同步消息，每个用户的收件箱对应一个 Timeline，同步库内消息不需要永久保存，通常对消息设定一个生命周期。 新消息会由端发出，通常消息体中会携带消息ID（用于去重）、逻辑时间戳（用于排序）、消息类型（控制消息、图片消息或者文本消息等）、消息体等内容。消息会先写入消息队列，作为底层存储的一个临时缓冲区。消息队列中的消息会由消息处理服务器消费，可以允许乱序消费。消息处理服务器对消息先存储后同步，先写入发件箱 Timeline （存储库），后写扩散至各个接收端的收件箱（同步库）。消息数据写入存储库后，会被近实时的构建索引，索引包括文本消息的全文索引以及多字段索引（发送方、消息类型等）。 对于在线的设备，可以由消息服务器主动推送至在线设备端。对于离线设备，登录后会主动向服务端同步消息。每个设备会在本地保留有最新一条消息的顺序ID，向服务端同步该顺序ID后的所有消息。 总结 本篇文章主要介绍了现代 IM 系统中消息系统所需要具备的能力，对比了传统架构和现代架构。为方便接下来的深入探讨，介绍了表格存储 Tablestore 推出的 Timeline 模型，以及在 IM 系统中消息存储和消息同步模型的基本概念和策略，最后介绍了一个典型的架构设计。希望和同仁共同探讨、交流。 你可能还喜欢 点击下方图片即可阅读 贾扬清：我对人工智能方向的一点浅见 如何搞定技术面试？阿里大牛为你选了8本必备好书 在阿里做了五年技术主管，我有话想说","@type":"BlogPosting","url":"https://mlh.app/2019/05/08/729987.html","headline":"揭秘！现代IM系统的消息架构如何设计？","dateModified":"2019-05-08T00:00:00+08:00","datePublished":"2019-05-08T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/05/08/729987.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>揭秘！现代IM系统的消息架构如何设计？</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);text-align: left;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="rich_pages" data-backh="277" data-backw="556" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WycQyI3xWoermPm6FGUkJadvRLvKWZ67gWrOZx2EM0DHOMjoepPkcXv261xXE5YoFIElcJ4GddZSQ/640?wx_fmt=jpeg" data-copyright="0" data-cropselx1="0" data-cropselx2="556" data-cropsely1="0" data-cropsely2="371" data-ratio="0.498046875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WycQyI3xWoermPm6FGUkJadvRLvKWZ67gWrOZx2EM0DHOMjoepPkcXv261xXE5YoFIElcJ4GddZSQ/640?wx_fmt=jpeg" data-type="jpeg" data-w="1024" style="letter-spacing: 0.544px;text-align: center;width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/LwZPmXjm4WycQyI3xWoermPm6FGUkJadvRLvKWZ67gWrOZx2EM0DHOMjoepPkcXv261xXE5YoFIElcJ4GddZSQ/640?wx_fmt=jpeg"><br></p> 
<section class="" powered-by="xiumi.us" style="white-space: normal;max-width: 100%;letter-spacing: 0.544px;line-height: 27.2px;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"> 
 <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
  <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
   <section class="" powered-by="xiumi.us" style="max-width: 100%;letter-spacing: 0.544px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
    <section class="" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
     <section label="Copyright Reserved by PLAYHUDONG." donone="shifuMouseDownCard('shifu_c_008')" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
      <section class="" powered-by="xiumi.us" style="max-width: 100%;letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;"> 
       <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
        <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
         <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
          <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
           <section label="Copyright Reserved by PLAYHUDONG." donone="shifuMouseDownCard('shifu_c_008')" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
            <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
             <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
              <section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
               <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                <section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"> 
                 <section label="Copyright Reserved by PLAYHUDONG." donone="shifuMouseDownCard('shifu_c_008')" style="margin-right: 0em;margin-left: 0em;padding: 0.5em 1em;max-width: 100%;border-style: none;background-color: rgb(235, 235, 235);box-sizing: border-box !important;word-wrap: break-word !important;"> 
                  <p style="max-width: 100%;min-height: 1em;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">阿里妹导读</span><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">：</span><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">IM全称是『Instant Messaging』，中文名是即时通讯。</span><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">在高度信息化的移动互联网时代，生活中IM类产品已经成为必备品，像“钉钉”以IM为核心功能的产品。</span><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">还有一些非以IM系统为核心的应用，最典型的如一些在线游戏、社交应用，IM也是其重要的功能模块。</span><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">可以说，IM系统已经是任何一个带有社交属性的应用需要具备的基础功能，网络上对于这类系统的设计与实现的讨论也越来越多。</span><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);letter-spacing: 0.612px;box-sizing: border-box !important;word-wrap: break-word !important;">今天，阿里巴巴高级技术专家木洛，就为你揭秘现代 IM 系统中的消息系统架构。</span></p> 
                 </section> 
                </section> 
               </section> 
              </section> 
             </section> 
            </section> 
           </section> 
          </section> 
         </section> 
        </section> 
       </section> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section> 
<p style="white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);text-align: left;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><br></p> 
<h1 style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">前言</span></strong></h1> 
<p style="white-space: normal;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">IM系统在互联网初期即存在，其基础技术架构在这十几年的发展中更新迭代多次，从早期的CS、P2P架构，到现在后台已经演变为一个复杂的分布式系统，涉及移动端、网络通信、协议、安全、存储和搜索等技术的方方面面。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">IM系统中最核心的部分是消息系统，消息系统中最核心的功能是消息的同步、存储和检索：</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<ul class=" list-paddingleft-2" style=""> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息的同步：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">将消息完整、快速地从发送方传递到接收方，就是消息的同步。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">消息同步系统最重要的衡量指标就是消息传递的实时性、完整性以及能支撑的消息规模。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">从功能上来说，一般至少要支持在线和离线推送，高级的IM系统还支持『多端同步』。</span></p></li> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息的存储：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">消息存储即消息的持久化保存，传统消息系统通常只能支持消息在接收端的本地存储，数据基本不具备可靠性。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">现代消息系统能支持消息在服务端的在线存储，功能上对应的就是『消息漫游』，消息漫游的好处是可以实现账号在任意端登陆查看所有历史消息。</span></p></li> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息的检索：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">消息一般是文本，所以支持全文检索也是必备的能力之一。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">传统消息系统通常来说也是只能支持消息的本地检索，基于本地存储的消息数据来构建。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">而现在消息系统在能支持消息的在线存储后，也具备了消息的『在线检索』能力。</span></p></li> 
</ul> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">本篇文章内容主要涉及IM系统中的消息系统架构，会介绍一种基于阿里云表格存储&nbsp;</span><span style="font-size: 15px;color: rgb(62, 62, 62);">Tablestore&nbsp;</span><span style="font-size: 15px;color: rgb(62, 62, 62);">的 Timeline 模型构建的消息系统。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">基于 Tablestore Timeline 构建的现代消息系统，能够同时支持消息系统的众多高级特性，包括『多端同步』、『消息漫游』和『在线检索』。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">在性能和规模上，能够做到全量消息云端存储和索引，百万 TPS 写入以及毫秒级延迟的消息同步和检索能力。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">之后我们会继续发表两篇文章，来更详细介绍 Tablestore Timeline 模型概念及使用：</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<ul class=" list-paddingleft-2" style=""> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">模型篇：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">详细介绍 Tablestore Timeline 模型的基本概念和基础数据结构，并结合 IM 系统进行基本的建模。</span></p></li> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">实现篇：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">会基于 Tablestore Timeline 实现一个具备『多端同步』、『消息漫游』和『在线检索』这些高级功能的简易IM系统，并共享我们的源代码。</span></p></li> 
</ul> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">传统架构 vs 现代架构</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="rich_pages" data-copyright="0" data-ratio="0.4200477326968974" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WycQyI3xWoermPm6FGUkJadKc4QIfZfkhb6NMWw1rNRLSkquj2cmREvxcwumBqwnY6MSvxCU9796w/640?wx_fmt=png" data-type="png" data-w="1676" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WycQyI3xWoermPm6FGUkJadKc4QIfZfkhb6NMWw1rNRLSkquj2cmREvxcwumBqwnY6MSvxCU9796w/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">传统架构下，</span></strong><span style="font-size: 15px;color: rgb(62, 62, 62);">消息是先同步后存储。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">对于在线的用户，消息会直接实时同步到在线的接收方，消息同步成功后，并不会在服务端持久化。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">而对于离线的用户或者消息无法实时同步成功时，消息会持久化到离线库，当接收方重新连接后，会从离线库拉取所有未读消息。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">当离线库中的消息成功同步到接收方后，消息会从离线库中删除。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">传统的消息系统，服务端的主要工作是维护发送方和接收方的连接状态，并提供在线消息同步和离线消息缓存的能力，保证消息一定能够从发送方传递到接收方。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">服务端不会对消息进行持久化，所以也无法支持消息漫游。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">消息的持久化存储及索引同样只能在接收端本地实现，数据可靠性极低。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">现代架构下，</span></strong><span style="font-size: 15px;color: rgb(62, 62, 62);">消息是先存储后同步。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">先存储后同步的好处是，如果接收方确认接收到了消息，那这条消息一定是已经在云端保存了。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">并且消息会有两个库来保存，一个是消息存储库，用于全量保存所有会话的消息，主要用于支持消息漫游。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">另一个是消息同步库，主要用于接收方的多端同步。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">消息从发送方发出后，经过服务端转发，服务端会先将消息保存到消息存储库，后保存到消息同步库。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">完成消息的持久化保存后，对于在线的接收方，会直接选择在线推送。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">但在线推送并不是一个必须路径，只是一个更优的消息传递路径。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">对于在线推送失败或者离线的接收方，会有另外一个统一的消息同步方式。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">接收方会主动的向服务端拉取所有未同步消息，但接收方何时来同步以及会在哪些端来同步消息对服务端来说是未知的，所以要求服务端必须保存所有需要同步到接收方的消息，这是消息同步库的主要作用。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">对于新的同步设备，会有消息漫游的需求，这是消息存储库的主要作用，在消息存储库中，可以拉取任意会话的全量历史消息。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">消息检索的实现依赖于对消息存储库内消息的索引，通常是一个近实时（NRT，near real time）的索引构建过程，这个索引同样是在线的。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">以上就是传统架构和现代架构的一个简单的对比，现代架构上整个消息的同步、存储和索引流程，并没有变复杂太多。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">现代架构的实现本质上是把传统架构内本地存储和索引都搬到云上，最大挑战是需要集中管理全量消息的存储和索引，带来的好处是能实现多端同步、消息漫游以及在线检索。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">可以看到现代架构中最核心的就是两个消息库『消息同步库』和『消息存储库』，以及对『消息存储库』的『消息索引』的实现，接下来我们逐步拆解这几个核心的设计和实现。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">基础模型</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">在深入讲解消息系统的设计和实现之前，需要对消息系统内的几个基本概念和基础模型有一个理解。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">网上分析的很多的不同类型的消息系统实现，实现差异上主要在消息同步和存储的方案上，在消息的数据模型上其实有很大的共性。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">围绕数据同步模型的讨论主要在『读扩散』、『写扩散』和『混合模式』这三种方案，目前还没有更多的选择。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">而对于数据模型的抽象，还没有一个标准的定义。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">本章节会介绍下表格存储 Tablestore 提出的 Timeline 模型，这是一个对消息系统内消息模型的一个抽象，能简化和更好地让开发者理解消息系统内的消息同步和存储模型，基于此模型我们会再深入探讨消息的同步和存储的选择和实现。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">Timeline模型</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Timeline是一个对消息抽象的逻辑模型，该模型会帮助我们简化对消息同步和存储模型的理解，而消息同步库和存储库的设计和实现也是围绕Timeline的特性和需求来展开。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="rich_pages" data-copyright="0" data-ratio="0.44672131147540983" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WycQyI3xWoermPm6FGUkJad5kb4iazOkhkqxvibicib9QBBTIPiaGEJ8sbibN8CdZPsxva5h0VS7UyolwgA/640?wx_fmt=png" data-type="png" data-w="976" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WycQyI3xWoermPm6FGUkJad5kb4iazOkhkqxvibicib9QBBTIPiaGEJ8sbibN8CdZPsxva5h0VS7UyolwgA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="color: rgb(62, 62, 62);font-size: 15px;">如图是 Timeline 模型的一个抽象表述，Timeline 可以简单理解为是一个消息队列，但这个消息队列有如下特性：</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<ul class=" list-paddingleft-2" style=""> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">每条消息对应一个顺序ID：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">每个消息拥有一个唯一的顺序ID（SequenceId），队列消息按 SequenceId 排序。</span></p></li> 
</ul> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<ul class=" list-paddingleft-2" style=""> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">新消息写入能自动分配递增的顺序 ID，保证永远插入队尾：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">Timeline 中是根据同步位点也就是顺序 ID 来同步消息，所以需要保证新写入的消息数据的顺序 ID 绝对不能比已同步的消息的顺序 ID 还小，否则会导致数据漏同步，所以需要支持对新写入的数据自动分配比当前已存储的所有消息的顺序 ID 更大的顺序 ID 。</span></p></li> 
</ul> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<ul class=" list-paddingleft-2" style=""> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">新消息写入也能自定义顺序 ID，满足自定义排序需求：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">上面提到的自动分配顺序 ID，主要是为了满足消息同步的需求，消息同步要求消息是根据『已同步』或是『已写入』的顺序来排序。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">而消息的存储，通常要求消息能根据会话顺序来排序，会话顺序通常由端的会话来决定，而不是服务端的同步顺序来定，这是两种顺序要求。</span></p></li> 
</ul> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<ul class=" list-paddingleft-2" style=""> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">支持根据顺序 ID 的随机定位：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">可根据 SequenceId 随机定位到 Timeline 中的某个位置，从这个位置开始正序或逆序的读取消息，也可支持读取指定顺序ID的某条消息。</span></p></li> 
</ul> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">支持对消息的自定义索引：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">消息体内数据根据业务不同会包含不同的字段， Timeline 需要支持对不同字段的自定义索引，来支持对消息内容的全文索引，或者是任意字段的灵活条件组合查询。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息同步可以基于 Timeline 很简单的实现，图中的例子中，消息发送方是A，消息接收方是B，同时B存在多个接收端，分别是B1、B2和B3。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">A向B发送消息，消息需要同步到B的多个端，待同步的消息通过一个 Timeline 来进行交换。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">A向B发送的所有消息，都会保存在这个 Timeline 中，B的每个接收端都是独立的从这个 Timeline中拉取消息。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">每个接收端同步完毕后，都会在本地记录下最新同步到的消息的SequenceId，即最新的一个位点，作为下次消息同步的起始位点。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">服务端不会保存各个端的同步状态，各个端均可以在任意时间从任意点开始拉取消息。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息存储也是基于 Timeline 实现，和消息同步唯一的区别是，消息存储要求服务端能够对 Timeline 内的所有数据进行持久化，并且消息采用会话顺序来保存，需要自定义顺序 ID。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息检索基于 Timeline 提供的消息索引来实现，能支持比较灵活的多字段索引，根据业务的不同可有自由度较高的定制。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">消息存储模型</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="rich_pages" data-copyright="0" data-ratio="0.7198067632850241" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WycQyI3xWoermPm6FGUkJadlGMCJ3RAPDSMibo2PccwA94LXCf2modooia1dgaRDFHPzOtmwhlQxt4A/640?wx_fmt=png" data-type="png" data-w="828" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WycQyI3xWoermPm6FGUkJadlGMCJ3RAPDSMibo2PccwA94LXCf2modooia1dgaRDFHPzOtmwhlQxt4A/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: center;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">如图是基于 Timeline 的消息存储模型，消息存储要求每个会话都对应一个独立的 Timeline 。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">如图例子所示，A与B/C/D/E/F均发生了会话，每个会话对应一个独立的 Timeline，每个 Timeline 内存有这个会话中的所有消息，消息根据会话顺序排序，服务端会对每个 Timeline 进行持久化存储，也就拥有了消息漫游的能力。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="color: rgb(62, 62, 62);font-size: 15px;">消息同步模型</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息同步模型会比消息存储模型稍复杂一些，消息的同步一般有读扩散（也叫拉模式）和写扩散（也叫推模式）两种不同的方式，分别对应不同的 Timeline 物理模型。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="rich_pages" data-copyright="0" data-ratio="0.36674528301886794" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WycQyI3xWoermPm6FGUkJadZcBTwBMSAkIpKDNIpTk3rwMDOGokbY4Jw2HaVUwkpf03NGNbT5lZTQ/640?wx_fmt=png" data-type="png" data-w="1696" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WycQyI3xWoermPm6FGUkJadZcBTwBMSAkIpKDNIpTk3rwMDOGokbY4Jw2HaVUwkpf03NGNbT5lZTQ/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="color: rgb(62, 62, 62);font-size: 15px;">如图是读扩散和写扩散两种不同同步模式下对应的不同的 Timeline 模型，按图中的示例，A作为消息接收者，其与B/C/D/E/F发生了会话，每个会话中的新的消息都需要同步到A的某个端，看下读扩散和写扩散两种模式下消息如何做同步。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">读扩散：</span></strong><span style="font-size: 15px;color: rgb(62, 62, 62);">消息存储模型中，每个会话的 Timeline 中保存了这个会话的全量消息。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">读扩散的消息同步模式下，每个会话中产生的新的消息，只需要写一次到其用于存储的 Timeline 中，接收端从这个 Timeline 中拉取新的消息。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">优点是消息只需要写一次，相比写扩散的模式，能够大大降低消息写入次数，特别是在群消息这种场景下。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">但其缺点也比较明显，接收端去同步消息的逻辑会相对复杂和低效。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">接收端需要对每个会话都拉取一次才能获取全部消息，读被大大的放大，并且会产生很多无效的读，因为并不是每个会话都会有新消息产生。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(62, 62, 62);">写扩散：</span></strong><span style="font-size: 15px;color: rgb(62, 62, 62);">写扩散的消息同步模式，需要有一个额外的 Timeline 来专门用于消息同步，通常是每个接收端都会拥有一个独立的同步 Timeline（或者叫收件箱），用于存放需要向这个接收端同步的所有消息。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">每个会话中的消息，会产生多次写，除了写入用于消息存储的会话 Timeline，还需要写入需要同步到的接收端的同步 Timeline。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">在个人与个人的会话中，消息会被额外写两次，除了写入这个会话的存储 Timeline，还需要写入参与这个会话的两个接收者的同步 Timeline。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">而在群这个场景下，写入会被更加的放大，如果这个群拥有N个参与者，那每条消息都需要额外地写N次。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">写扩散同步模式的优点是，在接收端消息同步逻辑会非常简单，只需要从其同步 Timeline 中读取一次即可，大大降低了消息同步所需的读的压力。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">其缺点就是消息写入会被放大，特别是针对群这种场景。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">Timeline 模型不会对选择读扩散还是写扩散做约束，而是能同时支持两种模式，因为本质上两种模式的逻辑数据模型并无差别，只是消息数据是用一个 Timeline 来支持多端读还是复制到多个 Timeline 来支持多端读的问题。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">针对 IM 这种应用场景，消息系统通常会选择写扩散这种消息同步模式。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">IM 场景下，一条消息只会产生一次，但是会被读取多次，是典型的读多写少的场景，消息的读写比例大概是10:1。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">若使用读扩散同步模式，整个系统的读写比例会被放大到100:1。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">一个优化的好的系统，必须从设计上去平衡这种读写压力，避免读或写任意一维触碰到天花板。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">所以 IM 系统这类场景下，通常会应用写扩散这种同步模式，来平衡读和写，将100:1的读写比例平衡到30:30。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">当然写扩散这种同步模式，还需要处理一些极端场景，例如万人大群。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">针对这种极端写扩散的场景，会退化到使用读扩散。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">一个简单的IM系统，通常会在产品层面限制这种大群的存在，而对于一个高级的IM系统，会采用读写扩散混合的同步模式，来满足这类产品的需求。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">采用混合模式，会根据数据的不同类型和不同的读写负载，来决定用写扩散还是读扩散。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">典型架构设计</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: center;line-height: 1.75em;"><img class="rich_pages" data-copyright="0" data-ratio="0.46217494089834515" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WycQyI3xWoermPm6FGUkJad9V1zQuJB3VFvFQBtk5PO3R1RGq3ok6L7nfPPiabN9NkHofCicsD9EqXA/640?wx_fmt=png" data-type="png" data-w="1692" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/LwZPmXjm4WycQyI3xWoermPm6FGUkJad9V1zQuJB3VFvFQBtk5PO3R1RGq3ok6L7nfPPiabN9NkHofCicsD9EqXA/640?wx_fmt=png"></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">如图是一个典型的消息系统架构，架构中包含几个重要组件：</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<ul class=" list-paddingleft-2" style=""> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">端：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">作为消息的发送和接收端，通过连接消息服务器来发送和接收消息。</span></p></li> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息服务器：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">一组无状态的服务器，可水平扩展，处理消息的发送和接收请求，连接后端消息系统。</span></p></li> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息队列：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">新写入消息的缓冲队列，消息系统的前置消息存储，用于削峰填谷以及异步消费。</span></p></li> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息处理：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">一组无状态的消费处理服务器，用于异步消费消息队列中的消息数据，处理消息的持久化和写扩散同步。</span></p></li> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息存储和索引库：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">持久化存储消息，每个会话对应一个 Timeline 进行消息存储，存储的消息建立索引来实现消息检索。</span></p></li> 
 <li><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">消息同步库：</span><span style="font-size: 15px;color: rgb(62, 62, 62);">写扩散形式同步消息，每个用户的收件箱对应一个 Timeline，同步库内消息不需要永久保存，通常对消息设定一个生命周期。</span></p></li> 
</ul> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">新消息会由端发出，通常消息体中会携带消息ID（用于去重）、逻辑时间戳（用于排序）、消息类型（控制消息、图片消息或者文本消息等）、消息体等内容。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">消息会先写入消息队列，作为底层存储的一个临时缓冲区。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">消息队列中的消息会由消息处理服务器消费，可以允许乱序消费。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">消息处理服务器对消息先存储后同步，先写入发件箱 Timeline （存储库），后写扩散至各个接收端的收件箱（同步库）。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">消息数据写入存储库后，会被近实时的构建索引，索引包括文本消息的全文索引以及多字段索引（发送方、消息类型等）。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">对于在线的设备，可以由消息服务器主动推送至在线设备端。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">对于离线设备，登录后会主动向服务端同步消息。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">每个设备会在本地保留有最新一条消息的顺序ID，向服务端同步该顺序ID后的所有消息。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><strong><span style="font-size: 15px;color: rgb(255, 129, 36);">总结</span></strong></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><br></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);">本篇文章主要介绍了现代 IM 系统中消息系统所需要具备的能力，对比了传统架构和现代架构。</span><span style="font-size: 15px;color: rgb(62, 62, 62);">为方便接下来的深入探讨，介绍了表格存储 Tablestore 推出的 Timeline 模型，以及在 IM 系统中消息存储和消息同步模型的基本概念和策略，最后介绍了一个典型的架构设计。希望和同仁共同探讨、交流。</span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);"><br></span></p> 
<p style="white-space: normal;text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(62, 62, 62);"><br></span></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.04907481898632341" data-type="gif" data-w="1243" width="auto" data-src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKLzTlj0XiaExO7CCIZrf95viarmPTV7zRp58LaaLlESZlOxNwA4nWbpTXfwnOmRWkeBVWcVU2r2pRg/640?wx_fmt=gif" style="box-sizing: border-box !important;word-wrap: break-word !important;visibility: visible !important;width: auto !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKLzTlj0XiaExO7CCIZrf95viarmPTV7zRp58LaaLlESZlOxNwA4nWbpTXfwnOmRWkeBVWcVU2r2pRg/640?wx_fmt=gif"></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);font-size: 14px;font-family: monospace;white-space: pre;text-align: center;line-height: 1.75em;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="color: rgb(136, 136, 136);font-size: 15px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">你可能还喜欢</strong></span></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);font-size: 14px;font-family: monospace;white-space: pre;text-align: center;line-height: 1.75em;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="color: rgb(136, 136, 136);font-size: 12px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">点击下方图片即可阅读</span></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);font-size: 14px;font-family: monospace;white-space: pre;text-align: center;line-height: 1.75em;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490092&amp;idx=1&amp;sn=e8fa9b319e3ba36c3c8b0a3cce73dc90&amp;chksm=e9292723de5eae35462361046e687a605323c4519642b46bf82d2d9450a8dbdd851c2a853e54&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="1" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span class="js_jump_icon h5_image_link" data-positionback="static" style="line-height: 0;top: auto;left: auto;right: auto;bottom: auto;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="rich_pages " data-croporisrc="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJmOicicAiaIUNc5zXb0ZG3A8ajujYuxvMCzvxcAbta3VmjC4MiaysqmwgMwhSd6U25oxWlNhydiat8ISA/0?wx_fmt=jpeg" data-cropx1="0" data-cropx2="1280" data-cropy1="82.87769784172662" data-cropy2="688.3453237410072" data-ratio="0.4734375" data-s="300,640" data-type="jpeg" data-w="1280" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLia0vyfftXZfEaGQTzaqklW4bF2DEicbqiaev9nI9UGBcmmyRjwnMkxqJ1vfrbdG2SvmO4JtkpxEApw/640?wx_fmt=jpeg" style="box-sizing: border-box !important;word-wrap: break-word !important;width: 556px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLia0vyfftXZfEaGQTzaqklW4bF2DEicbqiaev9nI9UGBcmmyRjwnMkxqJ1vfrbdG2SvmO4JtkpxEApw/640?wx_fmt=jpeg"></span></a></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490092&amp;idx=1&amp;sn=e8fa9b319e3ba36c3c8b0a3cce73dc90&amp;chksm=e9292723de5eae35462361046e687a605323c4519642b46bf82d2d9450a8dbdd851c2a853e54&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="font-size: 14px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">贾扬清：我对人工智能方向的一点浅见</span></a><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490104&amp;idx=1&amp;sn=c4d92b922388e2dab74574951ba8ad3f&amp;chksm=e9292737de5eae212e8016f492b6e160b2f08be9445b043e088899d024c81179def428ff5840&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="1" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span class="js_jump_icon h5_image_link" data-positionback="static" style="line-height: 0;top: auto;left: auto;right: auto;bottom: auto;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="rich_pages " data-croporisrc="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLOe3wac5pKDuiaI1akeibsibyMHPPcatvB8iaNGy3btfPMlarJXjPEeLn6ibThL4hib4PtZJHXukRnESlw/0?wx_fmt=jpeg" data-cropx1="0" data-cropx2="1080" data-cropy1="248.63309352517985" data-cropy2="687.6258992805755" data-ratio="0.4064814814814815" data-s="300,640" data-type="jpeg" data-w="1080" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLia0vyfftXZfEaGQTzaqklWicMgdRF4VoIgQFU13xicyDTXh0CLjZn2l0nH0a00HAtiaLBxjAb5KScuQ/640?wx_fmt=jpeg" style="box-sizing: border-box !important;word-wrap: break-word !important;width: 556px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLia0vyfftXZfEaGQTzaqklWicMgdRF4VoIgQFU13xicyDTXh0CLjZn2l0nH0a00HAtiaLBxjAb5KScuQ/640?wx_fmt=jpeg"></span></a></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490104&amp;idx=1&amp;sn=c4d92b922388e2dab74574951ba8ad3f&amp;chksm=e9292737de5eae212e8016f492b6e160b2f08be9445b043e088899d024c81179def428ff5840&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="font-size: 14px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">如何搞定技术面试？阿里大牛为你选了8本必备好书</span></a><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490113&amp;idx=1&amp;sn=c25c6f392d4a6e780b18b61a6c858af1&amp;chksm=e929274ede5eae5898fcf4d45a803b4407a30557b6013c0a512650433181cd27ca99de296c74&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="1" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span class="js_jump_icon h5_image_link" data-positionback="static" style="line-height: 0;top: auto;left: auto;right: auto;bottom: auto;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="rich_pages " data-croporisrc="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLOe3wac5pKDuiaI1akeibsibyBgmaGtvyTha2WibDLT3deGMUJkwolibsoygHsbo6De1DiajC6ZqlxadVg/0?wx_fmt=jpeg" data-cropx1="0" data-cropx2="1280" data-cropy1="168.0575539568345" data-cropy2="785.0359712230215" data-ratio="0.48203125" data-s="300,640" data-type="jpeg" data-w="1280" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJzyjoXqDKTCTpYYHOjXWXIQeZTAzbiatZeSTqxPjgiaCJbHA3Crwd0icmIicgltkjJ7FODkepDwHmIFA/640?wx_fmt=jpeg" style="box-sizing: border-box !important;word-wrap: break-word !important;width: 556px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJzyjoXqDKTCTpYYHOjXWXIQeZTAzbiatZeSTqxPjgiaCJbHA3Crwd0icmIicgltkjJ7FODkepDwHmIFA/640?wx_fmt=jpeg"></span></a></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 14px;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247490113&amp;idx=1&amp;sn=c25c6f392d4a6e780b18b61a6c858af1&amp;chksm=e929274ede5eae5898fcf4d45a803b4407a30557b6013c0a512650433181cd27ca99de296c74&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;">在阿里做了五年技术主管，我有话想说</a></span></p> 
<p style="min-height: 1em;letter-spacing: 0.5440000295639038px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"></p> 
<p style="min-height: 1em;letter-spacing: 0.544px;white-space: normal;text-align: center;max-width: 100% !important;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="__bg_gif " data-copyright="0" data-ratio="1.0616740088105727" data-type="gif" data-w="454" width="253px" data-src="https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naKcJeVLrERoBcjILPJtnWgOAsnKJ8RVuvGo7DPusIGvV4iauQEEAUlh9GyGu7ZZX9XqOCPOGiaUdXVg/640?wx_fmt=gif" style="box-sizing: border-box !important;word-wrap: break-word !important;width: 253px !important;visibility: visible !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naKcJeVLrERoBcjILPJtnWgOAsnKJ8RVuvGo7DPusIGvV4iauQEEAUlh9GyGu7ZZX9XqOCPOGiaUdXVg/640?wx_fmt=gif"></p>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
