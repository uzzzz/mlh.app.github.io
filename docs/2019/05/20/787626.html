<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Ingress 定义以及Ingress控制器 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Ingress 定义以及Ingress控制器" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="编辑/etc/sysconfig/kubelet&nbsp;&nbsp; 使用 KUBE_PROXY_NODE=ipvs 指定service的模式&nbsp; 那么ipvs使用的算法包括 ： ip_vs ip_vs_rr ip_vs_sh 如果一个主机没有Cluster IP 那么我们就称为 Headless --&gt;&nbsp; 将serveicename&nbsp; 解析到后端的pod上 k8s 的三个核心资源：&nbsp;&nbsp; pod&nbsp;&nbsp;&nbsp; 控制器&nbsp;&nbsp;&nbsp; service 那么service是四层的负载均衡 ，不是七层的，只能是基于 iptables 或者是 ipvs ,如果用户访问的是https 的请求 ，那么对四层来说无法惊醒负载，&nbsp; 如果pod中的应用是HTTP的想要增强成HTTPS的，那么我们可以想一下其中的证书呀，私钥配置在什么地方，如果我们的调度器是lvs ,那么我们想提供HTTP 的服务 ，那么这个HTTP应该配置在那里？ 注： 应该配置在后端主机上，不能配置在lvs上，所以我们必须在后端的每个服务器上配置 HTTPS ，配置证书，私钥 ，，等等&nbsp; ， 无论是ipvs 还是 iptables ，都无法调度七层的应用，因此我们要使用http 或者 https 我们就必须使用七层的调度 ，将客户 -&gt; 调度器 （使用七层） -&gt; 后端&nbsp; ，&nbsp; 那么现在我们就只能换调度器 ， k8s 采用（可以理解为加一层），后端配置的是不加https ,就是明文的htp, 那么我们使用一个独特的调度器，当用户试图访问的时候，我们不让他们到达后端的服务器，而是先到达调度器 （可以定义一个pod资源） ， 然后在访问后端的服务器 ，这样原来的明文就可以被https访问到了 。 那么在K8s中我们有特定的方法来解决这个七层的负载的方法： 我们使用一个新的控制器称为 Ingress Controller ，这个和之前说的 DaemonSet ReplicaSet 都不太一样，----&gt; 他们是作为manager来存在的 ，是master上的核心组件之一，而Ingress 是自己独立存在的一组组件pod资源，通常就是一组应用程序，这个应用程序就是拥有七层调度功能的一组应用程序，k8s上的选择有四种： 最不受待见的是HAproxy 默认的是 Nginx&nbsp; 现在服务网格当中Envoy&nbsp; 当前还有其他的，Traefik 所以我们在配置应用的是有三种选择 ： Nginx Envoy traefik（为微服务设计而生） ， 但是它们最为调度器而言不止要调度一个后端服务，那么在后端的web服务有多种时（电商、api、..)，使用调度器调度的时候我们怎么可以判断调度的究竟是我们想要的服务？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ： 1.我们可以考虑在Nginx上怎么调度，首先我们有四组upstream ，然后对客户端而言我们可以做四个虚拟主机 来进行以域名的形式访问。 &nbsp; 在k8s 上有一类特殊的资源，Ingress资源，Ingress 和 Ingress Controller是两个概念 ，我们定义Ingres&nbsp; 的意义就是说定义我们期望Ingress Controller 如何给我们建一个前端（可能是虚拟主机也可能是url映射）而又给我们定义一个后端（有几个主机 Ingress 是通过srevice得到的），首先我们由一个service对后端的pod进行分类，而后Ingress基于这个分类识别出这几个pod的ip地址 ，然后生成配置信息注入到（以Nginx为例，那就是upstream 中） &nbsp; 那么在Igress实现的七层负载的过程是：&nbsp;&nbsp; 最外面的对节点的均衡 Externalname&nbsp; ---&gt;&nbsp; 具体的某一节点上 NodePort ----&gt;&nbsp; 节点上的 Ingresss Controller&nbsp; ---&gt;&nbsp; 调度到具体的Ingress 上 ，因为Ingress 分别管理着一组pod资源 ----&gt;&nbsp;&nbsp; 通过service 对这些pod进行分组传给Ingress 引用 那么下来我们要使用Ingress这个功能，我们要去创建一个Ingress Controller Pod&nbsp; 而后我们要定义后端的service 在将他们之间建立联系。我们下来看一个Ingress怎么定义 ？&nbsp; Ingress 也是标准的K8s资源 。我们一样使用explain的文档去查看类似的参数的定义，同样在包含的资源的清单中也会有： apiVersion kind metadata spec status [root@server1 ~]# kubectl explain ingress KIND:&nbsp;&nbsp;&nbsp;&nbsp; Ingress VERSION:&nbsp; extensions/v1beta1 DESCRIPTION: &nbsp;&nbsp;&nbsp;&nbsp; Ingress is a collection of rules that allow inbound connections to reach &nbsp;&nbsp;&nbsp;&nbsp; the endpoints defined by a backend. An Ingress can be configured to give &nbsp;&nbsp;&nbsp;&nbsp; services externally-reachable urls, load balance traffic, terminate SSL, &nbsp;&nbsp;&nbsp;&nbsp; offer name based virtual hosting etc. FIELDS: &nbsp;&nbsp; apiVersion&nbsp;&nbsp; &nbsp;&lt;string&gt; &nbsp;&nbsp;&nbsp;&nbsp; APIVersion defines the versioned schema of this representation of an &nbsp;&nbsp;&nbsp;&nbsp; object. Servers should convert recognized schemas to the latest internal &nbsp;&nbsp;&nbsp;&nbsp; value, and may reject unrecognized values. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#resources &nbsp;&nbsp; kind&nbsp;&nbsp; &nbsp;&lt;string&gt; &nbsp;&nbsp;&nbsp;&nbsp; Kind is a string value representing the REST resource this object &nbsp;&nbsp;&nbsp;&nbsp; represents. Servers may infer this from the endpoint the client submits &nbsp;&nbsp;&nbsp;&nbsp; requests to. Cannot be updated. In CamelCase. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds &nbsp;&nbsp; metadata&nbsp;&nbsp; &nbsp;&lt;Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; Standard object&#39;s metadata. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata &nbsp;&nbsp; spec&nbsp;&nbsp; &nbsp;&lt;Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; Spec is the desired state of the Ingress. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status &nbsp;&nbsp; status&nbsp;&nbsp; &nbsp;&lt;Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; Status is the current state of the Ingress. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status spec字段的定义： [root@server1 ~]# kubectl explain ingress.spec &nbsp; KIND:&nbsp;&nbsp;&nbsp;&nbsp; Ingress VERSION:&nbsp; extensions/v1beta1 RESOURCE: spec &lt;Object&gt; DESCRIPTION: &nbsp;&nbsp;&nbsp;&nbsp; Spec is the desired state of the Ingress. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status &nbsp;&nbsp;&nbsp;&nbsp; IngressSpec describes the Ingress the user wishes to exist. FIELDS: &nbsp;&nbsp; backend&nbsp;&nbsp; &nbsp;&lt;Object&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义调度的后端的主机 ，正是靠service的定义，找到相关的一组pod资源 &nbsp;&nbsp;&nbsp;&nbsp; A default backend capable of servicing requests that don&#39;t match any rule. &nbsp;&nbsp;&nbsp;&nbsp; At least one of &#39;backend&#39; or &#39;rules&#39; must be specified. This field is &nbsp;&nbsp;&nbsp;&nbsp; optional to allow the loadbalancer controller or defaulting logic to &nbsp;&nbsp;&nbsp;&nbsp; specify a global default. &nbsp;&nbsp; rules&nbsp;&nbsp; &nbsp;&lt;[]Object&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义http的规则 &nbsp;&nbsp;&nbsp;&nbsp; A list of host rules used to configure the Ingress. If unspecified, or no &nbsp;&nbsp;&nbsp;&nbsp; rule matches, all traffic is sent to the default backend. &nbsp;&nbsp; tls&nbsp;&nbsp; &nbsp;&lt;[]Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; TLS configuration. Currently the Ingress only supports a single TLS port, &nbsp;&nbsp;&nbsp;&nbsp; 443. If multiple members of this list specify different hosts, they will be &nbsp;&nbsp;&nbsp;&nbsp; multiplexed on the same port according to the hostname specified through &nbsp;&nbsp;&nbsp;&nbsp; the SNI TLS extension, if the ingress controller fulfilling the ingress &nbsp;&nbsp;&nbsp;&nbsp; supports SNI. Ingress 有很多种类型，要么是映射的，要么是虚拟主机的，那么下来我们要看一下怎么部署一个Ingress Controller ,对k8s而言Ingress是作为附件存在的 ，整个K8s集群由： master node + 附件组成的。 附件： coredns +&nbsp; .. + Dashborad + Ingress 那么Ingress是一个集群的核心附件之一，下来我们实际的部署一个Ingress + nginx 第一步：&nbsp; 创建名称空间&nbsp; 示例：&nbsp; 使用命令创建名称空间： [root@server1 ~]# kubectl create namespace dev namespace/dev created [root@server1 ~]# kubectl get ns NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp; AGE default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d dev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 18s kube-public&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d kube-system&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d 删除一个名称空间 ：&nbsp;&nbsp; 名称空间/名称空间的名字 [root@server1 ~]# kubectl delete ns/dev namespace &quot;dev&quot; deleted 第二步：&nbsp; 创建一个configmap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 作用： 为Nginx 从外部注入配置 第三步：&nbsp; rbac&nbsp; 我们集群用到了 rbac&nbsp;&nbsp;&nbsp; 作用： 它是用来定义一些 cluster 角色、 授权 （必要的授予一个pod到达不了它本来访问的名称空间的权限） 第四步：&nbsp; rbac 启用以后，要创建 with-rbac 包括： 使用的镜像 第五步：&nbsp; 我们有可能要为其配置一个tcp-service-configmap 的资源 &nbsp; 那么git 到本地可能会很慢，我们直接将其配置文件复制到本地 ： 1. 创建名称空间 ：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方法一： [root@server1 ~]# kubectl create namespace ingress-nginx namespace/ingress-nginx created &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方法二： 注意： 在git 上将文件托下来的时候，一定要使用 raw 格式的数据，这样下载下来的才是一个原始的代码数据，要不然只能是一个html的页面。 那么我们复制连接的地址：https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/namespace.yaml [root@server1 ~]# mkdir ingress-nginx [root@server1 ~]# cd ingress-nginx/ [root@server1 ingress-nginx]# ls [root@server1 ingress-nginx]# for file in namespace.yaml configmap.yaml&nbsp; rbac.yaml with-rbac.yaml ; do wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/$file; done [root@server1 ingress-nginx]# ls configmap.yaml&nbsp; namespace.yaml&nbsp; rbac.yaml&nbsp; with-rbac.yaml 下载完成以后我们要先执行namespace [root@server1 ingress-nginx]# kubectl apply -f namespace.yaml namespace/ingress-nginx created 后面的文件的先后关系没有那么重要&nbsp;&nbsp; 我们期望去按照某种顺序的时候，可以使用for循环 apply是针对目录的，它会自动的引用目录下的所有文件 [root@server1 ingress-nginx]# kubectl apply -f ./ configmap/nginx-configuration created configmap/tcp-services created configmap/udp-services created namespace/ingress-nginx configured serviceaccount/nginx-ingress-serviceaccount created clusterrole.rbac.authorization.k8s.io/nginx-ingress-clusterrole created role.rbac.authorization.k8s.io/nginx-ingress-role created rolebinding.rbac.authorization.k8s.io/nginx-ingress-role-nisa-binding created clusterrolebinding.rbac.authorization.k8s.io/nginx-ingress-clusterrole-nisa-binding created deployment.apps/nginx-ingress-controller created 在查看的时候这个镜像正在下载，那么我们不用直接等待，因为我最初在搭建的时候没有使用代理，所以可能k8s.io上的镜像会托不下来，我们等会来检查一下 [root@server1 ingress-nginx]# kubectl get pods -n ingress-nginx NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READY&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RESTARTS&nbsp;&nbsp; AGE nginx-ingress-controller-769d8b56b7-scqh6&nbsp;&nbsp; 0/1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContainerCreating&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1m 经过后期的检查发现这个镜像位于github上，完全可以托下来，是严重不用担心 [root@server1 ingress-nginx]# kubectl get pods -n ingress-nginx NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READY&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp; RESTARTS&nbsp;&nbsp; AGE nginx-ingress-controller-769d8b56b7-scqh6&nbsp;&nbsp; 1/1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Running&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7m 那么我们试着去创建 Ingress ，&nbsp; 为了 ingress 可以显示出来效果，那么我们可以部署一下后端的服务 ，自定义一个配置清单的Ingress Controller的控制器 那么因为资源清单会随着需求创建得越来越多，因此我们在创建资源得清单得时候，我们要做好把我们得配置文件归类得准备 [root@server1 ingress]# pwd /root/mainfests/ingress 在部署控制器之前，我们得部署一个后端得service 或者pod&nbsp; 为ingress控制器做准备 ，那么在使用Pod控制器创建pod得使用我们要在控制器之上创建一个service ,那么Service得定义我们在官方的文档中查看发现必须是Headlist ，否则无法解析到pod的节点的ip地址。 apiVersion: v1 kind: Service metadata: &nbsp; name: myapp &nbsp; namespace: default spec: &nbsp; selector: &nbsp;&nbsp;&nbsp; app: myapp &nbsp;&nbsp;&nbsp; release: canary &nbsp; ports: &nbsp; - name: http &nbsp;&nbsp;&nbsp; targetPort: 80 &nbsp;&nbsp;&nbsp; port: 80 --- apiVersion: apps/v1 kind: Deployment metadata: &nbsp; name: myapp-deploy &nbsp; namespace: default spec: &nbsp; replicas: 3 &nbsp; selector: &nbsp;&nbsp;&nbsp; matchLabels: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app: myapp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release: canary &nbsp;&nbsp;&nbsp; spec: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; containers: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name: myapp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image: ikubernetes/myapp:v2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ports: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name: http &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; containerPort: 80 [root@server1 ingress]# kubectl apply&nbsp; -f deploy-demo.yaml service/myapp created deployment.apps/myapp-deploy unchanged [root@server1 ingress]# kubectl get svc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看 svc的ClusterIP的类型，那么在现在的我们看到的是并不是无头的，那么使用这个我们来测试一下（我记得之前没有指定就是ClusterIP ) NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLUSTER-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL-IP&nbsp;&nbsp; PORT(S)&nbsp;&nbsp;&nbsp; AGE kubernetes&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.96.0.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 443/TCP&nbsp;&nbsp;&nbsp; 17d myapp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.105.120.214&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP&nbsp;&nbsp;&nbsp;&nbsp; 29s myapp-svc&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; None&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP&nbsp;&nbsp;&nbsp;&nbsp; 10d redis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.97.97.97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6379/TCP&nbsp;&nbsp; 10d [root@server1 ingress]# &nbsp; 那么我们来回顾一下刚才的github上面的文件，里面有一个叫作： mandatory.yaml&nbsp; 这个文件是将所有的文件拼在一mandatory.yaml个文件当中，使用这一个文件我们就可以创建ingress的全部的事情。比手动的拼凑要更简单一些 &nbsp; 下来我们要为我们的Ingress Controller创建一个 service NodePort ，否则 Ingress Controller是无法被集群外部的客户访问的 ： 但是网上有现成的NodePort的资源配置清单，因此我们直接下载下来就可以了 [root@server1 ingress]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/provider/baremetal/service-nodeport.yaml apiVersion: v1 kind: Service metadata: &nbsp; name: ingress-nginx &nbsp; namespace: ingress-nginx spec: &nbsp; type: NodePort &nbsp; ports: &nbsp;&nbsp;&nbsp; - name: http &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port: 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetPort: 80 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protocol: TCP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nodePort: 30080 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们指定的节点暴露的端口 &nbsp;&nbsp;&nbsp; - name: https &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port: 443 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetPort: 443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 后端的nginx的端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protocol: TCP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nodePort: 30443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定Nginx暴露的端口 &nbsp; selector: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app: ingress-nginx --- [root@server1 ingress]# kubectl apply -f ./ service/myapp unchanged deployment.apps/myapp-deploy unchanged service/ingress-nginx created [root@server1 ingress]# kubectl get svc -n ingress-nginx NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLUSTER-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL-IP&nbsp;&nbsp; PORT(S)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AGE ingress-nginx&nbsp;&nbsp; NodePort&nbsp;&nbsp; 10.105.174.166&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80:30080/TCP,443:30443/TCP&nbsp;&nbsp; 4m 现在我们就可以在集群的外部尝试访问一下我们的Ingress 的服务 ： 但是按理来说应该出现正常的调度：&nbsp; 出现的应该是&nbsp; default&nbsp; backed - 404&nbsp;&nbsp; 但是却出现的是根本就访问不了这个30080的端口 ，提示：端口不能正常的访问，&nbsp; 那 继续向下&nbsp; ，看看这个问题到后面能不能解决 ？ &nbsp; 下来我们将我们的myapp关联到nginx上 ： [root@server1 ingress-nginx]# kubectl describe svc myapp Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myapp Namespace:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default Labels:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt; Annotations:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kubectl.kubernetes.io/last-applied-configuration={&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{},&quot;name&quot;:&quot;myapp&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;spec&quot;:{&quot;ports&quot;:[{&quot;name&quot;:&quot;http&quot;,&quot;port&quot;:80,&quot;targe... Selector:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app=myapp,release=canary Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP IP:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.105.120.214 Port:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http&nbsp; 80/TCP TargetPort:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP Endpoints:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.244.1.102:80,10.244.1.103:80,10.244.2.99:80 Session Affinity:&nbsp; None Events:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt; &nbsp; [root@server1 ingress]# vim ingress-myapp.yaml apiVersion: extensions/v1beta1 kind: Ingress metadata: &nbsp; name: ingress-myapp &nbsp; namespace: default &nbsp; annotations: &nbsp;&nbsp;&nbsp; kubernetes.io/ingress.class: &quot;nginx&quot; spec: &nbsp; rules: &nbsp; - host: myapp.magedu.com &nbsp;&nbsp;&nbsp; http: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paths: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - path: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backend: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serviceName: myapp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; servicePort: 80 [root@server1 ingress]# kubectl apply -f ingress-myapp.yaml ingress.extensions/ingress-myapp created [root@server1 ingress]# kubectl get ingress NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HOSTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDRESS&nbsp;&nbsp; PORTS&nbsp;&nbsp;&nbsp;&nbsp; AGE ingress-myapp&nbsp;&nbsp; myapp.magedu.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13s [root@server1 ingress]# kubectl describe ingress ingress-myapp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个ingress一旦创建了以后会自动的注入到 ingress Controller中去， 会自动的转换成nginx的配置文件 Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ingress-myapp Namespace:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default Address:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; Default backend:&nbsp; default-http-backend:80 (&lt;none&gt;) Rules: &nbsp; Host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Path&nbsp; Backends &nbsp; ----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----&nbsp; -------- &nbsp; myapp.magedu.com &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myapp:80 (&lt;none&gt;) Annotations: &nbsp; kubectl.kubernetes.io/last-applied-configuration:&nbsp; {&quot;apiVersion&quot;:&quot;extensions/v1beta1&quot;,&quot;kind&quot;:&quot;Ingress&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{&quot;kubernetes.io/ingress.class&quot;:&quot;nginx&quot;},&quot;name&quot;:&quot;ingress-myapp&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;spec&quot;:{&quot;rules&quot;:[{&quot;host&quot;:&quot;myapp.magedu.com&quot;,&quot;http&quot;:{&quot;paths&quot;:[{&quot;backend&quot;:{&quot;serviceName&quot;:&quot;myapp&quot;,&quot;servicePort&quot;:80},&quot;path&quot;:null}]}}]}} &nbsp; kubernetes.io/ingress.class:&nbsp; nginx Events: &nbsp; Type&nbsp;&nbsp;&nbsp; Reason&nbsp; Age&nbsp;&nbsp; From&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message &nbsp; ----&nbsp;&nbsp;&nbsp; ------&nbsp; ----&nbsp; ----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------- &nbsp; Normal&nbsp; CREATE&nbsp; 49s&nbsp;&nbsp; nginx-ingress-controller&nbsp; Ingress default/ingress-myapp [root@server1 ingress]# [root@server1 ingress]# kubectl exec&nbsp; -n ingress-nginx -it&nbsp; nginx-ingress-controller-769d8b56b7-scqh6 -- /bin/sh $ cat nginx.conf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用交互式的命令进入到pod内部去，查看nginx的配置文件中有没有我们定义的 # Configuration checksum: 3855965695233399109 &nbsp;&nbsp;&nbsp; server { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server_name myapp.magedu.com ; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;listen 80; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 注意：nginx的负载是以域名进行负载的，因此我们必须要注意解析到本地的节点， &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;" />
<meta property="og:description" content="编辑/etc/sysconfig/kubelet&nbsp;&nbsp; 使用 KUBE_PROXY_NODE=ipvs 指定service的模式&nbsp; 那么ipvs使用的算法包括 ： ip_vs ip_vs_rr ip_vs_sh 如果一个主机没有Cluster IP 那么我们就称为 Headless --&gt;&nbsp; 将serveicename&nbsp; 解析到后端的pod上 k8s 的三个核心资源：&nbsp;&nbsp; pod&nbsp;&nbsp;&nbsp; 控制器&nbsp;&nbsp;&nbsp; service 那么service是四层的负载均衡 ，不是七层的，只能是基于 iptables 或者是 ipvs ,如果用户访问的是https 的请求 ，那么对四层来说无法惊醒负载，&nbsp; 如果pod中的应用是HTTP的想要增强成HTTPS的，那么我们可以想一下其中的证书呀，私钥配置在什么地方，如果我们的调度器是lvs ,那么我们想提供HTTP 的服务 ，那么这个HTTP应该配置在那里？ 注： 应该配置在后端主机上，不能配置在lvs上，所以我们必须在后端的每个服务器上配置 HTTPS ，配置证书，私钥 ，，等等&nbsp; ， 无论是ipvs 还是 iptables ，都无法调度七层的应用，因此我们要使用http 或者 https 我们就必须使用七层的调度 ，将客户 -&gt; 调度器 （使用七层） -&gt; 后端&nbsp; ，&nbsp; 那么现在我们就只能换调度器 ， k8s 采用（可以理解为加一层），后端配置的是不加https ,就是明文的htp, 那么我们使用一个独特的调度器，当用户试图访问的时候，我们不让他们到达后端的服务器，而是先到达调度器 （可以定义一个pod资源） ， 然后在访问后端的服务器 ，这样原来的明文就可以被https访问到了 。 那么在K8s中我们有特定的方法来解决这个七层的负载的方法： 我们使用一个新的控制器称为 Ingress Controller ，这个和之前说的 DaemonSet ReplicaSet 都不太一样，----&gt; 他们是作为manager来存在的 ，是master上的核心组件之一，而Ingress 是自己独立存在的一组组件pod资源，通常就是一组应用程序，这个应用程序就是拥有七层调度功能的一组应用程序，k8s上的选择有四种： 最不受待见的是HAproxy 默认的是 Nginx&nbsp; 现在服务网格当中Envoy&nbsp; 当前还有其他的，Traefik 所以我们在配置应用的是有三种选择 ： Nginx Envoy traefik（为微服务设计而生） ， 但是它们最为调度器而言不止要调度一个后端服务，那么在后端的web服务有多种时（电商、api、..)，使用调度器调度的时候我们怎么可以判断调度的究竟是我们想要的服务？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ： 1.我们可以考虑在Nginx上怎么调度，首先我们有四组upstream ，然后对客户端而言我们可以做四个虚拟主机 来进行以域名的形式访问。 &nbsp; 在k8s 上有一类特殊的资源，Ingress资源，Ingress 和 Ingress Controller是两个概念 ，我们定义Ingres&nbsp; 的意义就是说定义我们期望Ingress Controller 如何给我们建一个前端（可能是虚拟主机也可能是url映射）而又给我们定义一个后端（有几个主机 Ingress 是通过srevice得到的），首先我们由一个service对后端的pod进行分类，而后Ingress基于这个分类识别出这几个pod的ip地址 ，然后生成配置信息注入到（以Nginx为例，那就是upstream 中） &nbsp; 那么在Igress实现的七层负载的过程是：&nbsp;&nbsp; 最外面的对节点的均衡 Externalname&nbsp; ---&gt;&nbsp; 具体的某一节点上 NodePort ----&gt;&nbsp; 节点上的 Ingresss Controller&nbsp; ---&gt;&nbsp; 调度到具体的Ingress 上 ，因为Ingress 分别管理着一组pod资源 ----&gt;&nbsp;&nbsp; 通过service 对这些pod进行分组传给Ingress 引用 那么下来我们要使用Ingress这个功能，我们要去创建一个Ingress Controller Pod&nbsp; 而后我们要定义后端的service 在将他们之间建立联系。我们下来看一个Ingress怎么定义 ？&nbsp; Ingress 也是标准的K8s资源 。我们一样使用explain的文档去查看类似的参数的定义，同样在包含的资源的清单中也会有： apiVersion kind metadata spec status [root@server1 ~]# kubectl explain ingress KIND:&nbsp;&nbsp;&nbsp;&nbsp; Ingress VERSION:&nbsp; extensions/v1beta1 DESCRIPTION: &nbsp;&nbsp;&nbsp;&nbsp; Ingress is a collection of rules that allow inbound connections to reach &nbsp;&nbsp;&nbsp;&nbsp; the endpoints defined by a backend. An Ingress can be configured to give &nbsp;&nbsp;&nbsp;&nbsp; services externally-reachable urls, load balance traffic, terminate SSL, &nbsp;&nbsp;&nbsp;&nbsp; offer name based virtual hosting etc. FIELDS: &nbsp;&nbsp; apiVersion&nbsp;&nbsp; &nbsp;&lt;string&gt; &nbsp;&nbsp;&nbsp;&nbsp; APIVersion defines the versioned schema of this representation of an &nbsp;&nbsp;&nbsp;&nbsp; object. Servers should convert recognized schemas to the latest internal &nbsp;&nbsp;&nbsp;&nbsp; value, and may reject unrecognized values. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#resources &nbsp;&nbsp; kind&nbsp;&nbsp; &nbsp;&lt;string&gt; &nbsp;&nbsp;&nbsp;&nbsp; Kind is a string value representing the REST resource this object &nbsp;&nbsp;&nbsp;&nbsp; represents. Servers may infer this from the endpoint the client submits &nbsp;&nbsp;&nbsp;&nbsp; requests to. Cannot be updated. In CamelCase. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds &nbsp;&nbsp; metadata&nbsp;&nbsp; &nbsp;&lt;Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; Standard object&#39;s metadata. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata &nbsp;&nbsp; spec&nbsp;&nbsp; &nbsp;&lt;Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; Spec is the desired state of the Ingress. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status &nbsp;&nbsp; status&nbsp;&nbsp; &nbsp;&lt;Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; Status is the current state of the Ingress. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status spec字段的定义： [root@server1 ~]# kubectl explain ingress.spec &nbsp; KIND:&nbsp;&nbsp;&nbsp;&nbsp; Ingress VERSION:&nbsp; extensions/v1beta1 RESOURCE: spec &lt;Object&gt; DESCRIPTION: &nbsp;&nbsp;&nbsp;&nbsp; Spec is the desired state of the Ingress. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status &nbsp;&nbsp;&nbsp;&nbsp; IngressSpec describes the Ingress the user wishes to exist. FIELDS: &nbsp;&nbsp; backend&nbsp;&nbsp; &nbsp;&lt;Object&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义调度的后端的主机 ，正是靠service的定义，找到相关的一组pod资源 &nbsp;&nbsp;&nbsp;&nbsp; A default backend capable of servicing requests that don&#39;t match any rule. &nbsp;&nbsp;&nbsp;&nbsp; At least one of &#39;backend&#39; or &#39;rules&#39; must be specified. This field is &nbsp;&nbsp;&nbsp;&nbsp; optional to allow the loadbalancer controller or defaulting logic to &nbsp;&nbsp;&nbsp;&nbsp; specify a global default. &nbsp;&nbsp; rules&nbsp;&nbsp; &nbsp;&lt;[]Object&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义http的规则 &nbsp;&nbsp;&nbsp;&nbsp; A list of host rules used to configure the Ingress. If unspecified, or no &nbsp;&nbsp;&nbsp;&nbsp; rule matches, all traffic is sent to the default backend. &nbsp;&nbsp; tls&nbsp;&nbsp; &nbsp;&lt;[]Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; TLS configuration. Currently the Ingress only supports a single TLS port, &nbsp;&nbsp;&nbsp;&nbsp; 443. If multiple members of this list specify different hosts, they will be &nbsp;&nbsp;&nbsp;&nbsp; multiplexed on the same port according to the hostname specified through &nbsp;&nbsp;&nbsp;&nbsp; the SNI TLS extension, if the ingress controller fulfilling the ingress &nbsp;&nbsp;&nbsp;&nbsp; supports SNI. Ingress 有很多种类型，要么是映射的，要么是虚拟主机的，那么下来我们要看一下怎么部署一个Ingress Controller ,对k8s而言Ingress是作为附件存在的 ，整个K8s集群由： master node + 附件组成的。 附件： coredns +&nbsp; .. + Dashborad + Ingress 那么Ingress是一个集群的核心附件之一，下来我们实际的部署一个Ingress + nginx 第一步：&nbsp; 创建名称空间&nbsp; 示例：&nbsp; 使用命令创建名称空间： [root@server1 ~]# kubectl create namespace dev namespace/dev created [root@server1 ~]# kubectl get ns NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp; AGE default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d dev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 18s kube-public&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d kube-system&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d 删除一个名称空间 ：&nbsp;&nbsp; 名称空间/名称空间的名字 [root@server1 ~]# kubectl delete ns/dev namespace &quot;dev&quot; deleted 第二步：&nbsp; 创建一个configmap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 作用： 为Nginx 从外部注入配置 第三步：&nbsp; rbac&nbsp; 我们集群用到了 rbac&nbsp;&nbsp;&nbsp; 作用： 它是用来定义一些 cluster 角色、 授权 （必要的授予一个pod到达不了它本来访问的名称空间的权限） 第四步：&nbsp; rbac 启用以后，要创建 with-rbac 包括： 使用的镜像 第五步：&nbsp; 我们有可能要为其配置一个tcp-service-configmap 的资源 &nbsp; 那么git 到本地可能会很慢，我们直接将其配置文件复制到本地 ： 1. 创建名称空间 ：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方法一： [root@server1 ~]# kubectl create namespace ingress-nginx namespace/ingress-nginx created &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方法二： 注意： 在git 上将文件托下来的时候，一定要使用 raw 格式的数据，这样下载下来的才是一个原始的代码数据，要不然只能是一个html的页面。 那么我们复制连接的地址：https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/namespace.yaml [root@server1 ~]# mkdir ingress-nginx [root@server1 ~]# cd ingress-nginx/ [root@server1 ingress-nginx]# ls [root@server1 ingress-nginx]# for file in namespace.yaml configmap.yaml&nbsp; rbac.yaml with-rbac.yaml ; do wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/$file; done [root@server1 ingress-nginx]# ls configmap.yaml&nbsp; namespace.yaml&nbsp; rbac.yaml&nbsp; with-rbac.yaml 下载完成以后我们要先执行namespace [root@server1 ingress-nginx]# kubectl apply -f namespace.yaml namespace/ingress-nginx created 后面的文件的先后关系没有那么重要&nbsp;&nbsp; 我们期望去按照某种顺序的时候，可以使用for循环 apply是针对目录的，它会自动的引用目录下的所有文件 [root@server1 ingress-nginx]# kubectl apply -f ./ configmap/nginx-configuration created configmap/tcp-services created configmap/udp-services created namespace/ingress-nginx configured serviceaccount/nginx-ingress-serviceaccount created clusterrole.rbac.authorization.k8s.io/nginx-ingress-clusterrole created role.rbac.authorization.k8s.io/nginx-ingress-role created rolebinding.rbac.authorization.k8s.io/nginx-ingress-role-nisa-binding created clusterrolebinding.rbac.authorization.k8s.io/nginx-ingress-clusterrole-nisa-binding created deployment.apps/nginx-ingress-controller created 在查看的时候这个镜像正在下载，那么我们不用直接等待，因为我最初在搭建的时候没有使用代理，所以可能k8s.io上的镜像会托不下来，我们等会来检查一下 [root@server1 ingress-nginx]# kubectl get pods -n ingress-nginx NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READY&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RESTARTS&nbsp;&nbsp; AGE nginx-ingress-controller-769d8b56b7-scqh6&nbsp;&nbsp; 0/1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContainerCreating&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1m 经过后期的检查发现这个镜像位于github上，完全可以托下来，是严重不用担心 [root@server1 ingress-nginx]# kubectl get pods -n ingress-nginx NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READY&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp; RESTARTS&nbsp;&nbsp; AGE nginx-ingress-controller-769d8b56b7-scqh6&nbsp;&nbsp; 1/1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Running&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7m 那么我们试着去创建 Ingress ，&nbsp; 为了 ingress 可以显示出来效果，那么我们可以部署一下后端的服务 ，自定义一个配置清单的Ingress Controller的控制器 那么因为资源清单会随着需求创建得越来越多，因此我们在创建资源得清单得时候，我们要做好把我们得配置文件归类得准备 [root@server1 ingress]# pwd /root/mainfests/ingress 在部署控制器之前，我们得部署一个后端得service 或者pod&nbsp; 为ingress控制器做准备 ，那么在使用Pod控制器创建pod得使用我们要在控制器之上创建一个service ,那么Service得定义我们在官方的文档中查看发现必须是Headlist ，否则无法解析到pod的节点的ip地址。 apiVersion: v1 kind: Service metadata: &nbsp; name: myapp &nbsp; namespace: default spec: &nbsp; selector: &nbsp;&nbsp;&nbsp; app: myapp &nbsp;&nbsp;&nbsp; release: canary &nbsp; ports: &nbsp; - name: http &nbsp;&nbsp;&nbsp; targetPort: 80 &nbsp;&nbsp;&nbsp; port: 80 --- apiVersion: apps/v1 kind: Deployment metadata: &nbsp; name: myapp-deploy &nbsp; namespace: default spec: &nbsp; replicas: 3 &nbsp; selector: &nbsp;&nbsp;&nbsp; matchLabels: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app: myapp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release: canary &nbsp;&nbsp;&nbsp; spec: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; containers: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name: myapp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image: ikubernetes/myapp:v2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ports: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name: http &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; containerPort: 80 [root@server1 ingress]# kubectl apply&nbsp; -f deploy-demo.yaml service/myapp created deployment.apps/myapp-deploy unchanged [root@server1 ingress]# kubectl get svc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看 svc的ClusterIP的类型，那么在现在的我们看到的是并不是无头的，那么使用这个我们来测试一下（我记得之前没有指定就是ClusterIP ) NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLUSTER-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL-IP&nbsp;&nbsp; PORT(S)&nbsp;&nbsp;&nbsp; AGE kubernetes&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.96.0.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 443/TCP&nbsp;&nbsp;&nbsp; 17d myapp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.105.120.214&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP&nbsp;&nbsp;&nbsp;&nbsp; 29s myapp-svc&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; None&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP&nbsp;&nbsp;&nbsp;&nbsp; 10d redis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.97.97.97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6379/TCP&nbsp;&nbsp; 10d [root@server1 ingress]# &nbsp; 那么我们来回顾一下刚才的github上面的文件，里面有一个叫作： mandatory.yaml&nbsp; 这个文件是将所有的文件拼在一mandatory.yaml个文件当中，使用这一个文件我们就可以创建ingress的全部的事情。比手动的拼凑要更简单一些 &nbsp; 下来我们要为我们的Ingress Controller创建一个 service NodePort ，否则 Ingress Controller是无法被集群外部的客户访问的 ： 但是网上有现成的NodePort的资源配置清单，因此我们直接下载下来就可以了 [root@server1 ingress]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/provider/baremetal/service-nodeport.yaml apiVersion: v1 kind: Service metadata: &nbsp; name: ingress-nginx &nbsp; namespace: ingress-nginx spec: &nbsp; type: NodePort &nbsp; ports: &nbsp;&nbsp;&nbsp; - name: http &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port: 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetPort: 80 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protocol: TCP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nodePort: 30080 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们指定的节点暴露的端口 &nbsp;&nbsp;&nbsp; - name: https &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port: 443 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetPort: 443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 后端的nginx的端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protocol: TCP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nodePort: 30443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定Nginx暴露的端口 &nbsp; selector: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app: ingress-nginx --- [root@server1 ingress]# kubectl apply -f ./ service/myapp unchanged deployment.apps/myapp-deploy unchanged service/ingress-nginx created [root@server1 ingress]# kubectl get svc -n ingress-nginx NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLUSTER-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL-IP&nbsp;&nbsp; PORT(S)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AGE ingress-nginx&nbsp;&nbsp; NodePort&nbsp;&nbsp; 10.105.174.166&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80:30080/TCP,443:30443/TCP&nbsp;&nbsp; 4m 现在我们就可以在集群的外部尝试访问一下我们的Ingress 的服务 ： 但是按理来说应该出现正常的调度：&nbsp; 出现的应该是&nbsp; default&nbsp; backed - 404&nbsp;&nbsp; 但是却出现的是根本就访问不了这个30080的端口 ，提示：端口不能正常的访问，&nbsp; 那 继续向下&nbsp; ，看看这个问题到后面能不能解决 ？ &nbsp; 下来我们将我们的myapp关联到nginx上 ： [root@server1 ingress-nginx]# kubectl describe svc myapp Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myapp Namespace:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default Labels:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt; Annotations:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kubectl.kubernetes.io/last-applied-configuration={&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{},&quot;name&quot;:&quot;myapp&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;spec&quot;:{&quot;ports&quot;:[{&quot;name&quot;:&quot;http&quot;,&quot;port&quot;:80,&quot;targe... Selector:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app=myapp,release=canary Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP IP:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.105.120.214 Port:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http&nbsp; 80/TCP TargetPort:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP Endpoints:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.244.1.102:80,10.244.1.103:80,10.244.2.99:80 Session Affinity:&nbsp; None Events:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt; &nbsp; [root@server1 ingress]# vim ingress-myapp.yaml apiVersion: extensions/v1beta1 kind: Ingress metadata: &nbsp; name: ingress-myapp &nbsp; namespace: default &nbsp; annotations: &nbsp;&nbsp;&nbsp; kubernetes.io/ingress.class: &quot;nginx&quot; spec: &nbsp; rules: &nbsp; - host: myapp.magedu.com &nbsp;&nbsp;&nbsp; http: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paths: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - path: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backend: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serviceName: myapp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; servicePort: 80 [root@server1 ingress]# kubectl apply -f ingress-myapp.yaml ingress.extensions/ingress-myapp created [root@server1 ingress]# kubectl get ingress NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HOSTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDRESS&nbsp;&nbsp; PORTS&nbsp;&nbsp;&nbsp;&nbsp; AGE ingress-myapp&nbsp;&nbsp; myapp.magedu.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13s [root@server1 ingress]# kubectl describe ingress ingress-myapp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个ingress一旦创建了以后会自动的注入到 ingress Controller中去， 会自动的转换成nginx的配置文件 Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ingress-myapp Namespace:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default Address:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; Default backend:&nbsp; default-http-backend:80 (&lt;none&gt;) Rules: &nbsp; Host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Path&nbsp; Backends &nbsp; ----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----&nbsp; -------- &nbsp; myapp.magedu.com &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myapp:80 (&lt;none&gt;) Annotations: &nbsp; kubectl.kubernetes.io/last-applied-configuration:&nbsp; {&quot;apiVersion&quot;:&quot;extensions/v1beta1&quot;,&quot;kind&quot;:&quot;Ingress&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{&quot;kubernetes.io/ingress.class&quot;:&quot;nginx&quot;},&quot;name&quot;:&quot;ingress-myapp&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;spec&quot;:{&quot;rules&quot;:[{&quot;host&quot;:&quot;myapp.magedu.com&quot;,&quot;http&quot;:{&quot;paths&quot;:[{&quot;backend&quot;:{&quot;serviceName&quot;:&quot;myapp&quot;,&quot;servicePort&quot;:80},&quot;path&quot;:null}]}}]}} &nbsp; kubernetes.io/ingress.class:&nbsp; nginx Events: &nbsp; Type&nbsp;&nbsp;&nbsp; Reason&nbsp; Age&nbsp;&nbsp; From&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message &nbsp; ----&nbsp;&nbsp;&nbsp; ------&nbsp; ----&nbsp; ----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------- &nbsp; Normal&nbsp; CREATE&nbsp; 49s&nbsp;&nbsp; nginx-ingress-controller&nbsp; Ingress default/ingress-myapp [root@server1 ingress]# [root@server1 ingress]# kubectl exec&nbsp; -n ingress-nginx -it&nbsp; nginx-ingress-controller-769d8b56b7-scqh6 -- /bin/sh $ cat nginx.conf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用交互式的命令进入到pod内部去，查看nginx的配置文件中有没有我们定义的 # Configuration checksum: 3855965695233399109 &nbsp;&nbsp;&nbsp; server { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server_name myapp.magedu.com ; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;listen 80; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 注意：nginx的负载是以域名进行负载的，因此我们必须要注意解析到本地的节点， &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;" />
<link rel="canonical" href="https://mlh.app/2019/05/20/787626.html" />
<meta property="og:url" content="https://mlh.app/2019/05/20/787626.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"编辑/etc/sysconfig/kubelet&nbsp;&nbsp; 使用 KUBE_PROXY_NODE=ipvs 指定service的模式&nbsp; 那么ipvs使用的算法包括 ： ip_vs ip_vs_rr ip_vs_sh 如果一个主机没有Cluster IP 那么我们就称为 Headless --&gt;&nbsp; 将serveicename&nbsp; 解析到后端的pod上 k8s 的三个核心资源：&nbsp;&nbsp; pod&nbsp;&nbsp;&nbsp; 控制器&nbsp;&nbsp;&nbsp; service 那么service是四层的负载均衡 ，不是七层的，只能是基于 iptables 或者是 ipvs ,如果用户访问的是https 的请求 ，那么对四层来说无法惊醒负载，&nbsp; 如果pod中的应用是HTTP的想要增强成HTTPS的，那么我们可以想一下其中的证书呀，私钥配置在什么地方，如果我们的调度器是lvs ,那么我们想提供HTTP 的服务 ，那么这个HTTP应该配置在那里？ 注： 应该配置在后端主机上，不能配置在lvs上，所以我们必须在后端的每个服务器上配置 HTTPS ，配置证书，私钥 ，，等等&nbsp; ， 无论是ipvs 还是 iptables ，都无法调度七层的应用，因此我们要使用http 或者 https 我们就必须使用七层的调度 ，将客户 -&gt; 调度器 （使用七层） -&gt; 后端&nbsp; ，&nbsp; 那么现在我们就只能换调度器 ， k8s 采用（可以理解为加一层），后端配置的是不加https ,就是明文的htp, 那么我们使用一个独特的调度器，当用户试图访问的时候，我们不让他们到达后端的服务器，而是先到达调度器 （可以定义一个pod资源） ， 然后在访问后端的服务器 ，这样原来的明文就可以被https访问到了 。 那么在K8s中我们有特定的方法来解决这个七层的负载的方法： 我们使用一个新的控制器称为 Ingress Controller ，这个和之前说的 DaemonSet ReplicaSet 都不太一样，----&gt; 他们是作为manager来存在的 ，是master上的核心组件之一，而Ingress 是自己独立存在的一组组件pod资源，通常就是一组应用程序，这个应用程序就是拥有七层调度功能的一组应用程序，k8s上的选择有四种： 最不受待见的是HAproxy 默认的是 Nginx&nbsp; 现在服务网格当中Envoy&nbsp; 当前还有其他的，Traefik 所以我们在配置应用的是有三种选择 ： Nginx Envoy traefik（为微服务设计而生） ， 但是它们最为调度器而言不止要调度一个后端服务，那么在后端的web服务有多种时（电商、api、..)，使用调度器调度的时候我们怎么可以判断调度的究竟是我们想要的服务？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ： 1.我们可以考虑在Nginx上怎么调度，首先我们有四组upstream ，然后对客户端而言我们可以做四个虚拟主机 来进行以域名的形式访问。 &nbsp; 在k8s 上有一类特殊的资源，Ingress资源，Ingress 和 Ingress Controller是两个概念 ，我们定义Ingres&nbsp; 的意义就是说定义我们期望Ingress Controller 如何给我们建一个前端（可能是虚拟主机也可能是url映射）而又给我们定义一个后端（有几个主机 Ingress 是通过srevice得到的），首先我们由一个service对后端的pod进行分类，而后Ingress基于这个分类识别出这几个pod的ip地址 ，然后生成配置信息注入到（以Nginx为例，那就是upstream 中） &nbsp; 那么在Igress实现的七层负载的过程是：&nbsp;&nbsp; 最外面的对节点的均衡 Externalname&nbsp; ---&gt;&nbsp; 具体的某一节点上 NodePort ----&gt;&nbsp; 节点上的 Ingresss Controller&nbsp; ---&gt;&nbsp; 调度到具体的Ingress 上 ，因为Ingress 分别管理着一组pod资源 ----&gt;&nbsp;&nbsp; 通过service 对这些pod进行分组传给Ingress 引用 那么下来我们要使用Ingress这个功能，我们要去创建一个Ingress Controller Pod&nbsp; 而后我们要定义后端的service 在将他们之间建立联系。我们下来看一个Ingress怎么定义 ？&nbsp; Ingress 也是标准的K8s资源 。我们一样使用explain的文档去查看类似的参数的定义，同样在包含的资源的清单中也会有： apiVersion kind metadata spec status [root@server1 ~]# kubectl explain ingress KIND:&nbsp;&nbsp;&nbsp;&nbsp; Ingress VERSION:&nbsp; extensions/v1beta1 DESCRIPTION: &nbsp;&nbsp;&nbsp;&nbsp; Ingress is a collection of rules that allow inbound connections to reach &nbsp;&nbsp;&nbsp;&nbsp; the endpoints defined by a backend. An Ingress can be configured to give &nbsp;&nbsp;&nbsp;&nbsp; services externally-reachable urls, load balance traffic, terminate SSL, &nbsp;&nbsp;&nbsp;&nbsp; offer name based virtual hosting etc. FIELDS: &nbsp;&nbsp; apiVersion&nbsp;&nbsp; &nbsp;&lt;string&gt; &nbsp;&nbsp;&nbsp;&nbsp; APIVersion defines the versioned schema of this representation of an &nbsp;&nbsp;&nbsp;&nbsp; object. Servers should convert recognized schemas to the latest internal &nbsp;&nbsp;&nbsp;&nbsp; value, and may reject unrecognized values. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#resources &nbsp;&nbsp; kind&nbsp;&nbsp; &nbsp;&lt;string&gt; &nbsp;&nbsp;&nbsp;&nbsp; Kind is a string value representing the REST resource this object &nbsp;&nbsp;&nbsp;&nbsp; represents. Servers may infer this from the endpoint the client submits &nbsp;&nbsp;&nbsp;&nbsp; requests to. Cannot be updated. In CamelCase. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds &nbsp;&nbsp; metadata&nbsp;&nbsp; &nbsp;&lt;Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; Standard object&#39;s metadata. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata &nbsp;&nbsp; spec&nbsp;&nbsp; &nbsp;&lt;Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; Spec is the desired state of the Ingress. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status &nbsp;&nbsp; status&nbsp;&nbsp; &nbsp;&lt;Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; Status is the current state of the Ingress. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status spec字段的定义： [root@server1 ~]# kubectl explain ingress.spec &nbsp; KIND:&nbsp;&nbsp;&nbsp;&nbsp; Ingress VERSION:&nbsp; extensions/v1beta1 RESOURCE: spec &lt;Object&gt; DESCRIPTION: &nbsp;&nbsp;&nbsp;&nbsp; Spec is the desired state of the Ingress. More info: &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status &nbsp;&nbsp;&nbsp;&nbsp; IngressSpec describes the Ingress the user wishes to exist. FIELDS: &nbsp;&nbsp; backend&nbsp;&nbsp; &nbsp;&lt;Object&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义调度的后端的主机 ，正是靠service的定义，找到相关的一组pod资源 &nbsp;&nbsp;&nbsp;&nbsp; A default backend capable of servicing requests that don&#39;t match any rule. &nbsp;&nbsp;&nbsp;&nbsp; At least one of &#39;backend&#39; or &#39;rules&#39; must be specified. This field is &nbsp;&nbsp;&nbsp;&nbsp; optional to allow the loadbalancer controller or defaulting logic to &nbsp;&nbsp;&nbsp;&nbsp; specify a global default. &nbsp;&nbsp; rules&nbsp;&nbsp; &nbsp;&lt;[]Object&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义http的规则 &nbsp;&nbsp;&nbsp;&nbsp; A list of host rules used to configure the Ingress. If unspecified, or no &nbsp;&nbsp;&nbsp;&nbsp; rule matches, all traffic is sent to the default backend. &nbsp;&nbsp; tls&nbsp;&nbsp; &nbsp;&lt;[]Object&gt; &nbsp;&nbsp;&nbsp;&nbsp; TLS configuration. Currently the Ingress only supports a single TLS port, &nbsp;&nbsp;&nbsp;&nbsp; 443. If multiple members of this list specify different hosts, they will be &nbsp;&nbsp;&nbsp;&nbsp; multiplexed on the same port according to the hostname specified through &nbsp;&nbsp;&nbsp;&nbsp; the SNI TLS extension, if the ingress controller fulfilling the ingress &nbsp;&nbsp;&nbsp;&nbsp; supports SNI. Ingress 有很多种类型，要么是映射的，要么是虚拟主机的，那么下来我们要看一下怎么部署一个Ingress Controller ,对k8s而言Ingress是作为附件存在的 ，整个K8s集群由： master node + 附件组成的。 附件： coredns +&nbsp; .. + Dashborad + Ingress 那么Ingress是一个集群的核心附件之一，下来我们实际的部署一个Ingress + nginx 第一步：&nbsp; 创建名称空间&nbsp; 示例：&nbsp; 使用命令创建名称空间： [root@server1 ~]# kubectl create namespace dev namespace/dev created [root@server1 ~]# kubectl get ns NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp; AGE default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d dev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 18s kube-public&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d kube-system&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d 删除一个名称空间 ：&nbsp;&nbsp; 名称空间/名称空间的名字 [root@server1 ~]# kubectl delete ns/dev namespace &quot;dev&quot; deleted 第二步：&nbsp; 创建一个configmap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 作用： 为Nginx 从外部注入配置 第三步：&nbsp; rbac&nbsp; 我们集群用到了 rbac&nbsp;&nbsp;&nbsp; 作用： 它是用来定义一些 cluster 角色、 授权 （必要的授予一个pod到达不了它本来访问的名称空间的权限） 第四步：&nbsp; rbac 启用以后，要创建 with-rbac 包括： 使用的镜像 第五步：&nbsp; 我们有可能要为其配置一个tcp-service-configmap 的资源 &nbsp; 那么git 到本地可能会很慢，我们直接将其配置文件复制到本地 ： 1. 创建名称空间 ：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方法一： [root@server1 ~]# kubectl create namespace ingress-nginx namespace/ingress-nginx created &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方法二： 注意： 在git 上将文件托下来的时候，一定要使用 raw 格式的数据，这样下载下来的才是一个原始的代码数据，要不然只能是一个html的页面。 那么我们复制连接的地址：https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/namespace.yaml [root@server1 ~]# mkdir ingress-nginx [root@server1 ~]# cd ingress-nginx/ [root@server1 ingress-nginx]# ls [root@server1 ingress-nginx]# for file in namespace.yaml configmap.yaml&nbsp; rbac.yaml with-rbac.yaml ; do wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/$file; done [root@server1 ingress-nginx]# ls configmap.yaml&nbsp; namespace.yaml&nbsp; rbac.yaml&nbsp; with-rbac.yaml 下载完成以后我们要先执行namespace [root@server1 ingress-nginx]# kubectl apply -f namespace.yaml namespace/ingress-nginx created 后面的文件的先后关系没有那么重要&nbsp;&nbsp; 我们期望去按照某种顺序的时候，可以使用for循环 apply是针对目录的，它会自动的引用目录下的所有文件 [root@server1 ingress-nginx]# kubectl apply -f ./ configmap/nginx-configuration created configmap/tcp-services created configmap/udp-services created namespace/ingress-nginx configured serviceaccount/nginx-ingress-serviceaccount created clusterrole.rbac.authorization.k8s.io/nginx-ingress-clusterrole created role.rbac.authorization.k8s.io/nginx-ingress-role created rolebinding.rbac.authorization.k8s.io/nginx-ingress-role-nisa-binding created clusterrolebinding.rbac.authorization.k8s.io/nginx-ingress-clusterrole-nisa-binding created deployment.apps/nginx-ingress-controller created 在查看的时候这个镜像正在下载，那么我们不用直接等待，因为我最初在搭建的时候没有使用代理，所以可能k8s.io上的镜像会托不下来，我们等会来检查一下 [root@server1 ingress-nginx]# kubectl get pods -n ingress-nginx NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READY&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RESTARTS&nbsp;&nbsp; AGE nginx-ingress-controller-769d8b56b7-scqh6&nbsp;&nbsp; 0/1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContainerCreating&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1m 经过后期的检查发现这个镜像位于github上，完全可以托下来，是严重不用担心 [root@server1 ingress-nginx]# kubectl get pods -n ingress-nginx NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READY&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp; RESTARTS&nbsp;&nbsp; AGE nginx-ingress-controller-769d8b56b7-scqh6&nbsp;&nbsp; 1/1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Running&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7m 那么我们试着去创建 Ingress ，&nbsp; 为了 ingress 可以显示出来效果，那么我们可以部署一下后端的服务 ，自定义一个配置清单的Ingress Controller的控制器 那么因为资源清单会随着需求创建得越来越多，因此我们在创建资源得清单得时候，我们要做好把我们得配置文件归类得准备 [root@server1 ingress]# pwd /root/mainfests/ingress 在部署控制器之前，我们得部署一个后端得service 或者pod&nbsp; 为ingress控制器做准备 ，那么在使用Pod控制器创建pod得使用我们要在控制器之上创建一个service ,那么Service得定义我们在官方的文档中查看发现必须是Headlist ，否则无法解析到pod的节点的ip地址。 apiVersion: v1 kind: Service metadata: &nbsp; name: myapp &nbsp; namespace: default spec: &nbsp; selector: &nbsp;&nbsp;&nbsp; app: myapp &nbsp;&nbsp;&nbsp; release: canary &nbsp; ports: &nbsp; - name: http &nbsp;&nbsp;&nbsp; targetPort: 80 &nbsp;&nbsp;&nbsp; port: 80 --- apiVersion: apps/v1 kind: Deployment metadata: &nbsp; name: myapp-deploy &nbsp; namespace: default spec: &nbsp; replicas: 3 &nbsp; selector: &nbsp;&nbsp;&nbsp; matchLabels: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app: myapp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release: canary &nbsp;&nbsp;&nbsp; spec: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; containers: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name: myapp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image: ikubernetes/myapp:v2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ports: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name: http &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; containerPort: 80 [root@server1 ingress]# kubectl apply&nbsp; -f deploy-demo.yaml service/myapp created deployment.apps/myapp-deploy unchanged [root@server1 ingress]# kubectl get svc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看 svc的ClusterIP的类型，那么在现在的我们看到的是并不是无头的，那么使用这个我们来测试一下（我记得之前没有指定就是ClusterIP ) NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLUSTER-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL-IP&nbsp;&nbsp; PORT(S)&nbsp;&nbsp;&nbsp; AGE kubernetes&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.96.0.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 443/TCP&nbsp;&nbsp;&nbsp; 17d myapp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.105.120.214&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP&nbsp;&nbsp;&nbsp;&nbsp; 29s myapp-svc&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; None&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP&nbsp;&nbsp;&nbsp;&nbsp; 10d redis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.97.97.97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6379/TCP&nbsp;&nbsp; 10d [root@server1 ingress]# &nbsp; 那么我们来回顾一下刚才的github上面的文件，里面有一个叫作： mandatory.yaml&nbsp; 这个文件是将所有的文件拼在一mandatory.yaml个文件当中，使用这一个文件我们就可以创建ingress的全部的事情。比手动的拼凑要更简单一些 &nbsp; 下来我们要为我们的Ingress Controller创建一个 service NodePort ，否则 Ingress Controller是无法被集群外部的客户访问的 ： 但是网上有现成的NodePort的资源配置清单，因此我们直接下载下来就可以了 [root@server1 ingress]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/provider/baremetal/service-nodeport.yaml apiVersion: v1 kind: Service metadata: &nbsp; name: ingress-nginx &nbsp; namespace: ingress-nginx spec: &nbsp; type: NodePort &nbsp; ports: &nbsp;&nbsp;&nbsp; - name: http &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port: 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetPort: 80 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protocol: TCP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nodePort: 30080 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们指定的节点暴露的端口 &nbsp;&nbsp;&nbsp; - name: https &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port: 443 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetPort: 443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 后端的nginx的端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protocol: TCP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nodePort: 30443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定Nginx暴露的端口 &nbsp; selector: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app: ingress-nginx --- [root@server1 ingress]# kubectl apply -f ./ service/myapp unchanged deployment.apps/myapp-deploy unchanged service/ingress-nginx created [root@server1 ingress]# kubectl get svc -n ingress-nginx NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLUSTER-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL-IP&nbsp;&nbsp; PORT(S)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AGE ingress-nginx&nbsp;&nbsp; NodePort&nbsp;&nbsp; 10.105.174.166&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80:30080/TCP,443:30443/TCP&nbsp;&nbsp; 4m 现在我们就可以在集群的外部尝试访问一下我们的Ingress 的服务 ： 但是按理来说应该出现正常的调度：&nbsp; 出现的应该是&nbsp; default&nbsp; backed - 404&nbsp;&nbsp; 但是却出现的是根本就访问不了这个30080的端口 ，提示：端口不能正常的访问，&nbsp; 那 继续向下&nbsp; ，看看这个问题到后面能不能解决 ？ &nbsp; 下来我们将我们的myapp关联到nginx上 ： [root@server1 ingress-nginx]# kubectl describe svc myapp Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myapp Namespace:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default Labels:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt; Annotations:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kubectl.kubernetes.io/last-applied-configuration={&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{},&quot;name&quot;:&quot;myapp&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;spec&quot;:{&quot;ports&quot;:[{&quot;name&quot;:&quot;http&quot;,&quot;port&quot;:80,&quot;targe... Selector:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app=myapp,release=canary Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP IP:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.105.120.214 Port:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http&nbsp; 80/TCP TargetPort:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP Endpoints:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.244.1.102:80,10.244.1.103:80,10.244.2.99:80 Session Affinity:&nbsp; None Events:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt; &nbsp; [root@server1 ingress]# vim ingress-myapp.yaml apiVersion: extensions/v1beta1 kind: Ingress metadata: &nbsp; name: ingress-myapp &nbsp; namespace: default &nbsp; annotations: &nbsp;&nbsp;&nbsp; kubernetes.io/ingress.class: &quot;nginx&quot; spec: &nbsp; rules: &nbsp; - host: myapp.magedu.com &nbsp;&nbsp;&nbsp; http: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paths: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - path: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backend: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serviceName: myapp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; servicePort: 80 [root@server1 ingress]# kubectl apply -f ingress-myapp.yaml ingress.extensions/ingress-myapp created [root@server1 ingress]# kubectl get ingress NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HOSTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDRESS&nbsp;&nbsp; PORTS&nbsp;&nbsp;&nbsp;&nbsp; AGE ingress-myapp&nbsp;&nbsp; myapp.magedu.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13s [root@server1 ingress]# kubectl describe ingress ingress-myapp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个ingress一旦创建了以后会自动的注入到 ingress Controller中去， 会自动的转换成nginx的配置文件 Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ingress-myapp Namespace:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default Address:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; Default backend:&nbsp; default-http-backend:80 (&lt;none&gt;) Rules: &nbsp; Host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Path&nbsp; Backends &nbsp; ----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----&nbsp; -------- &nbsp; myapp.magedu.com &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myapp:80 (&lt;none&gt;) Annotations: &nbsp; kubectl.kubernetes.io/last-applied-configuration:&nbsp; {&quot;apiVersion&quot;:&quot;extensions/v1beta1&quot;,&quot;kind&quot;:&quot;Ingress&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{&quot;kubernetes.io/ingress.class&quot;:&quot;nginx&quot;},&quot;name&quot;:&quot;ingress-myapp&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;spec&quot;:{&quot;rules&quot;:[{&quot;host&quot;:&quot;myapp.magedu.com&quot;,&quot;http&quot;:{&quot;paths&quot;:[{&quot;backend&quot;:{&quot;serviceName&quot;:&quot;myapp&quot;,&quot;servicePort&quot;:80},&quot;path&quot;:null}]}}]}} &nbsp; kubernetes.io/ingress.class:&nbsp; nginx Events: &nbsp; Type&nbsp;&nbsp;&nbsp; Reason&nbsp; Age&nbsp;&nbsp; From&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message &nbsp; ----&nbsp;&nbsp;&nbsp; ------&nbsp; ----&nbsp; ----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------- &nbsp; Normal&nbsp; CREATE&nbsp; 49s&nbsp;&nbsp; nginx-ingress-controller&nbsp; Ingress default/ingress-myapp [root@server1 ingress]# [root@server1 ingress]# kubectl exec&nbsp; -n ingress-nginx -it&nbsp; nginx-ingress-controller-769d8b56b7-scqh6 -- /bin/sh $ cat nginx.conf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用交互式的命令进入到pod内部去，查看nginx的配置文件中有没有我们定义的 # Configuration checksum: 3855965695233399109 &nbsp;&nbsp;&nbsp; server { &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server_name myapp.magedu.com ; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;listen 80; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 注意：nginx的负载是以域名进行负载的，因此我们必须要注意解析到本地的节点， &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;","@type":"BlogPosting","url":"https://mlh.app/2019/05/20/787626.html","headline":"Ingress 定义以及Ingress控制器","dateModified":"2019-05-20T00:00:00+08:00","datePublished":"2019-05-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/05/20/787626.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Ingress 定义以及Ingress控制器</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>编辑/etc/sysconfig/kubelet&nbsp;&nbsp; 使用 KUBE_PROXY_NODE=ipvs 指定service的模式&nbsp; 那么ipvs使用的算法包括 ： ip_vs ip_vs_rr ip_vs_sh</p> 
  <p>如果一个主机没有Cluster IP 那么我们就称为 Headless --&gt;&nbsp; 将serveicename&nbsp; 解析到后端的pod上</p> 
  <p>k8s 的三个核心资源：&nbsp;&nbsp; pod&nbsp;&nbsp;&nbsp; 控制器&nbsp;&nbsp;&nbsp; service</p> 
  <p>那么service是四层的负载均衡 ，不是七层的，只能是基于 iptables 或者是 ipvs ,如果用户访问的是https 的请求 ，那么对四层来说无法惊醒负载，&nbsp; 如果pod中的应用是HTTP的想要增强成HTTPS的，那么我们可以想一下其中的证书呀，私钥配置在什么地方，如果我们的调度器是lvs ,那么我们想提供HTTP 的服务 ，那么这个HTTP应该配置在那里？ 注： 应该配置在后端主机上，不能配置在lvs上，所以我们必须在后端的每个服务器上配置 HTTPS ，配置证书，私钥 ，，等等&nbsp; ，</p> 
  <p>无论是ipvs 还是 iptables ，都无法调度七层的应用，因此我们要使用http 或者 https 我们就必须使用七层的调度 ，将客户 -&gt; 调度器 （使用七层） -&gt; 后端&nbsp; ，&nbsp; 那么现在我们就只能换调度器 ， k8s 采用（可以理解为加一层），后端配置的是不加https ,就是明文的htp, 那么我们使用一个独特的调度器，当用户试图访问的时候，我们不让他们到达后端的服务器，而是先到达调度器 （可以定义一个pod资源） ， 然后在访问后端的服务器 ，这样原来的明文就可以被https访问到了 。</p> 
  <p>那么在K8s中我们有特定的方法来解决这个七层的负载的方法：</p> 
  <p>我们使用一个新的控制器称为 Ingress Controller ，这个和之前说的 DaemonSet ReplicaSet 都不太一样，----&gt; 他们是作为manager来存在的 ，是master上的核心组件之一，而Ingress 是自己独立存在的一组组件pod资源，通常就是一组应用程序，这个应用程序就是拥有七层调度功能的一组应用程序，k8s上的选择有四种： 最不受待见的是HAproxy 默认的是 Nginx&nbsp; 现在服务网格当中Envoy&nbsp; 当前还有其他的，Traefik 所以我们在配置应用的是有三种选择 ： Nginx Envoy traefik（为微服务设计而生） ，</p> 
  <p>但是它们最为调度器而言不止要调度一个后端服务，那么在后端的web服务有多种时（电商、api、..)，使用调度器调度的时候我们怎么可以判断调度的究竟是我们想要的服务？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ： 1.我们可以考虑在Nginx上怎么调度，首先我们有四组upstream ，然后对客户端而言我们可以做四个虚拟主机 来进行以域名的形式访问。</p> 
  <p>&nbsp;</p> 
  <p>在k8s 上有一类特殊的资源，Ingress资源，Ingress 和 Ingress Controller是两个概念 ，我们定义Ingres&nbsp; 的意义就是说定义我们期望Ingress Controller 如何给我们建一个前端（可能是虚拟主机也可能是url映射）而又给我们定义一个后端（有几个主机 Ingress 是通过srevice得到的），首先我们由一个service对后端的pod进行分类，而后Ingress基于这个分类识别出这几个pod的ip地址 ，然后生成配置信息注入到（以Nginx为例，那就是upstream 中）</p> 
  <p>&nbsp;</p> 
  <p>那么在Igress实现的七层负载的过程是：&nbsp;&nbsp; 最外面的对节点的均衡 Externalname&nbsp; ---&gt;&nbsp; 具体的某一节点上 NodePort ----&gt;&nbsp; 节点上的 Ingresss Controller&nbsp; ---&gt;&nbsp; 调度到具体的Ingress 上 ，因为Ingress 分别管理着一组pod资源 ----&gt;&nbsp;&nbsp; 通过service 对这些pod进行分组传给Ingress 引用</p> 
  <p>那么下来我们要使用Ingress这个功能，我们要去创建一个Ingress Controller Pod&nbsp; 而后我们要定义后端的service 在将他们之间建立联系。我们下来看一个Ingress怎么定义 ？&nbsp; Ingress 也是标准的K8s资源 。我们一样使用explain的文档去查看类似的参数的定义，同样在包含的资源的清单中也会有： apiVersion kind metadata spec status</p> 
  <p>[root@server1 ~]# kubectl explain ingress<br> KIND:&nbsp;&nbsp;&nbsp;&nbsp; Ingress<br> VERSION:&nbsp; extensions/v1beta1</p> 
  <p>DESCRIPTION:<br> &nbsp;&nbsp;&nbsp;&nbsp; Ingress is a collection of rules that allow inbound connections to reach<br> &nbsp;&nbsp;&nbsp;&nbsp; the endpoints defined by a backend. An Ingress can be configured to give<br> &nbsp;&nbsp;&nbsp;&nbsp; services externally-reachable urls, load balance traffic, terminate SSL,<br> &nbsp;&nbsp;&nbsp;&nbsp; offer name based virtual hosting etc.</p> 
  <p>FIELDS:<br> &nbsp;&nbsp; apiVersion&nbsp;&nbsp; &nbsp;&lt;string&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp; APIVersion defines the versioned schema of this representation of an<br> &nbsp;&nbsp;&nbsp;&nbsp; object. Servers should convert recognized schemas to the latest internal<br> &nbsp;&nbsp;&nbsp;&nbsp; value, and may reject unrecognized values. More info:<br> &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#resources</p> 
  <p>&nbsp;&nbsp; kind&nbsp;&nbsp; &nbsp;&lt;string&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp; Kind is a string value representing the REST resource this object<br> &nbsp;&nbsp;&nbsp;&nbsp; represents. Servers may infer this from the endpoint the client submits<br> &nbsp;&nbsp;&nbsp;&nbsp; requests to. Cannot be updated. In CamelCase. More info:<br> &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds</p> 
  <p>&nbsp;&nbsp; metadata&nbsp;&nbsp; &nbsp;&lt;Object&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp; Standard object's metadata. More info:<br> &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata</p> 
  <p>&nbsp;&nbsp; spec&nbsp;&nbsp; &nbsp;&lt;Object&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp; Spec is the desired state of the Ingress. More info:<br> &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status</p> 
  <p>&nbsp;&nbsp; status&nbsp;&nbsp; &nbsp;&lt;Object&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp; Status is the current state of the Ingress. More info:<br> &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status</p> 
  <p><br> spec字段的定义：</p> 
  <p>[root@server1 ~]# kubectl explain ingress.spec &nbsp;<br> KIND:&nbsp;&nbsp;&nbsp;&nbsp; Ingress<br> VERSION:&nbsp; extensions/v1beta1</p> 
  <p>RESOURCE: spec &lt;Object&gt;</p> 
  <p>DESCRIPTION:<br> &nbsp;&nbsp;&nbsp;&nbsp; Spec is the desired state of the Ingress. More info:<br> &nbsp;&nbsp;&nbsp;&nbsp; https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp; IngressSpec describes the Ingress the user wishes to exist.</p> 
  <p>FIELDS:<br> &nbsp;&nbsp; backend&nbsp;&nbsp; &nbsp;&lt;Object&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义调度的后端的主机 ，正是靠service的定义，找到相关的一组pod资源<br> &nbsp;&nbsp;&nbsp;&nbsp; A default backend capable of servicing requests that don't match any rule.<br> &nbsp;&nbsp;&nbsp;&nbsp; At least one of 'backend' or 'rules' must be specified. This field is<br> &nbsp;&nbsp;&nbsp;&nbsp; optional to allow the loadbalancer controller or defaulting logic to<br> &nbsp;&nbsp;&nbsp;&nbsp; specify a global default.</p> 
  <p>&nbsp;&nbsp; rules&nbsp;&nbsp; &nbsp;&lt;[]Object&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义http的规则<br> &nbsp;&nbsp;&nbsp;&nbsp; A list of host rules used to configure the Ingress. If unspecified, or no<br> &nbsp;&nbsp;&nbsp;&nbsp; rule matches, all traffic is sent to the default backend.</p> 
  <p>&nbsp;&nbsp; tls&nbsp;&nbsp; &nbsp;&lt;[]Object&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp; TLS configuration. Currently the Ingress only supports a single TLS port,<br> &nbsp;&nbsp;&nbsp;&nbsp; 443. If multiple members of this list specify different hosts, they will be<br> &nbsp;&nbsp;&nbsp;&nbsp; multiplexed on the same port according to the hostname specified through<br> &nbsp;&nbsp;&nbsp;&nbsp; the SNI TLS extension, if the ingress controller fulfilling the ingress<br> &nbsp;&nbsp;&nbsp;&nbsp; supports SNI.</p> 
  <p>Ingress 有很多种类型，要么是映射的，要么是虚拟主机的，那么下来我们要看一下怎么部署一个Ingress Controller ,对k8s而言Ingress是作为附件存在的 ，整个K8s集群由： master node + 附件组成的。 附件： coredns +&nbsp; .. + Dashborad + Ingress</p> 
  <p>那么Ingress是一个集群的核心附件之一，下来我们实际的部署一个Ingress + nginx</p> 
  <p>第一步：&nbsp; 创建名称空间&nbsp;</p> 
  <p>示例：&nbsp; 使用命令创建名称空间：</p> 
  <p>[root@server1 ~]# kubectl create namespace dev<br> namespace/dev created</p> 
  <p>[root@server1 ~]# kubectl get ns<br> NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp; AGE<br> default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d<br> dev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 18s<br> kube-public&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d<br> kube-system&nbsp;&nbsp; Active&nbsp;&nbsp;&nbsp; 17d</p> 
  <p>删除一个名称空间 ：&nbsp;&nbsp; 名称空间/名称空间的名字</p> 
  <p>[root@server1 ~]# kubectl delete ns/dev<br> namespace "dev" deleted</p> 
  <p>第二步：&nbsp; 创建一个configmap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 作用： 为Nginx 从外部注入配置</p> 
  <p>第三步：&nbsp; rbac&nbsp; 我们集群用到了 rbac&nbsp;&nbsp;&nbsp; 作用： 它是用来定义一些 cluster 角色、 授权 （必要的授予一个pod到达不了它本来访问的名称空间的权限）</p> 
  <p>第四步：&nbsp; rbac 启用以后，要创建 with-rbac 包括： 使用的镜像</p> 
  <p>第五步：&nbsp; 我们有可能要为其配置一个tcp-service-configmap 的资源</p> 
  <p>&nbsp;</p> 
  <p>那么git 到本地可能会很慢，我们直接将其配置文件复制到本地 ：</p> 
  <p>1. 创建名称空间 ：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方法一：</p> 
  <p>[root@server1 ~]# kubectl create namespace ingress-nginx<br> namespace/ingress-nginx created</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方法二：</p> 
  <p>注意： 在git 上将文件托下来的时候，一定要使用 <strong>raw </strong>格式的数据，这样下载下来的才是一个原始的代码数据，要不然只能是一个html的页面。</p> 
  <p>那么我们复制连接的地址：<a href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/namespace.yaml" rel="nofollow">https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/namespace.yaml</a></p> 
  <p>[root@server1 ~]# mkdir ingress-nginx<br> [root@server1 ~]# cd ingress-nginx/<br> [root@server1 ingress-nginx]# ls</p> 
  <p>[root@server1 ingress-nginx]# for file in namespace.yaml configmap.yaml&nbsp; rbac.yaml with-rbac.yaml ; do wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/$file; done</p> 
  <p>[root@server1 ingress-nginx]# ls<br> configmap.yaml&nbsp; namespace.yaml&nbsp; rbac.yaml&nbsp; with-rbac.yaml</p> 
  <p>下载完成以后我们要先执行namespace</p> 
  <p>[root@server1 ingress-nginx]# kubectl apply -f namespace.yaml<br> namespace/ingress-nginx created</p> 
  <p>后面的文件的先后关系没有那么重要&nbsp;&nbsp; 我们期望去按照某种顺序的时候，可以使用for循环</p> 
  <p>apply是针对目录的，它会自动的引用目录下的所有文件</p> 
  <p>[root@server1 ingress-nginx]# kubectl apply -f ./<br> configmap/nginx-configuration created<br> configmap/tcp-services created<br> configmap/udp-services created<br> namespace/ingress-nginx configured<br> serviceaccount/nginx-ingress-serviceaccount created<br> clusterrole.rbac.authorization.k8s.io/nginx-ingress-clusterrole created<br> role.rbac.authorization.k8s.io/nginx-ingress-role created<br> rolebinding.rbac.authorization.k8s.io/nginx-ingress-role-nisa-binding created<br> clusterrolebinding.rbac.authorization.k8s.io/nginx-ingress-clusterrole-nisa-binding created<br> deployment.apps/nginx-ingress-controller created</p> 
  <p>在查看的时候这个镜像正在下载，那么我们不用直接等待，因为我最初在搭建的时候没有使用代理，所以可能k8s.io上的镜像会托不下来，我们等会来检查一下</p> 
  <p>[root@server1 ingress-nginx]# kubectl get pods -n ingress-nginx<br> NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READY&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RESTARTS&nbsp;&nbsp; AGE<br> nginx-ingress-controller-769d8b56b7-scqh6&nbsp;&nbsp; 0/1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContainerCreating&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1m</p> 
  <p>经过后期的检查发现这个镜像位于github上，完全可以托下来，是严重不用担心</p> 
  <p>[root@server1 ingress-nginx]# kubectl get pods -n ingress-nginx<br> NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READY&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp; RESTARTS&nbsp;&nbsp; AGE<br> nginx-ingress-controller-769d8b56b7-scqh6&nbsp;&nbsp; 1/1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Running&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7m</p> 
  <p>那么我们试着去创建 Ingress ，&nbsp; 为了 ingress 可以显示出来效果，那么我们可以部署一下后端的服务 ，自定义一个配置清单的Ingress Controller的控制器</p> 
  <p>那么因为资源清单会随着需求创建得越来越多，因此我们在创建资源得清单得时候，我们要做好把我们得配置文件归类得准备</p> 
  <p>[root@server1 ingress]# pwd<br> /root/mainfests/ingress</p> 
  <p>在部署控制器之前，我们得部署一个后端得service 或者pod&nbsp; 为ingress控制器做准备 ，那么在使用Pod控制器创建pod得使用我们要在控制器之上创建一个service ,那么Service得定义我们在官方的文档中查看发现必须是Headlist ，否则无法解析到pod的节点的ip地址。</p> 
  <p>apiVersion: v1<br> kind: Service<br> metadata:<br> &nbsp; name: myapp<br> &nbsp; namespace: default<br> spec:<br> &nbsp; selector:<br> &nbsp;&nbsp;&nbsp; app: myapp<br> &nbsp;&nbsp;&nbsp; release: canary<br> &nbsp; ports:<br> &nbsp; - name: http<br> &nbsp;&nbsp;&nbsp; targetPort: 80</p> 
  <p>&nbsp;&nbsp;&nbsp; port: 80</p> 
  <p>---<br> apiVersion: apps/v1<br> kind: Deployment<br> metadata:<br> &nbsp; name: myapp-deploy<br> &nbsp; namespace: default<br> spec:<br> &nbsp; replicas: 3<br> &nbsp; selector:<br> &nbsp;&nbsp;&nbsp; matchLabels:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app: myapp</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release: canary<br> &nbsp;&nbsp;&nbsp; spec:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; containers:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name: myapp<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image: ikubernetes/myapp:v2<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ports:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - name: http<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; containerPort: 80</p> 
  <p>[root@server1 ingress]# kubectl apply&nbsp; -f deploy-demo.yaml<br> service/myapp created<br> deployment.apps/myapp-deploy unchanged</p> 
  <p>[root@server1 ingress]# kubectl get svc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看 svc的ClusterIP的类型，那么在现在的我们看到的是并不是无头的，那么使用这个我们来测试一下（我记得之前没有指定就是ClusterIP )<br> NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLUSTER-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL-IP&nbsp;&nbsp; PORT(S)&nbsp;&nbsp;&nbsp; AGE<br> kubernetes&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.96.0.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 443/TCP&nbsp;&nbsp;&nbsp; 17d<br> myapp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.105.120.214&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP&nbsp;&nbsp;&nbsp;&nbsp; 29s<br> myapp-svc&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; None&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP&nbsp;&nbsp;&nbsp;&nbsp; 10d<br> redis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP&nbsp;&nbsp; 10.97.97.97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6379/TCP&nbsp;&nbsp; 10d<br> [root@server1 ingress]#</p> 
  <p>&nbsp;</p> 
  <p>那么我们来回顾一下刚才的github上面的文件，里面有一个叫作： <a href="https://github.com/kubernetes/ingress-nginx/blob/master/deploy/mandatory.yaml" rel="nofollow" id="37104149548219af3555d3d64d44b246-921bc482d7b0cac467816e377a19e1c1f5bc6c1d">mandatory.yaml&nbsp; 这个文件是将所有的文件拼在一mandatory.yaml</a><a href="https://github.com/kubernetes/ingress-nginx/blob/master/deploy/mandatory.yaml" rel="nofollow">个文件当中，使用这一个文件我们就可以创建ingress的全部的事情。</a>比手动的拼凑要更简单一些</p> 
  <p>&nbsp;</p> 
  <p>下来我们要为我们的Ingress Controller创建一个 service NodePort ，否则 Ingress Controller是无法被集群外部的客户访问的 ：</p> 
  <p>但是网上有现成的NodePort的资源配置清单，因此我们直接下载下来就可以了</p> 
  <p>[root@server1 ingress]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/provider/baremetal/service-nodeport.yaml</p> 
  <p>apiVersion: v1<br> kind: Service<br> metadata:<br> &nbsp; name: ingress-nginx<br> &nbsp; namespace: ingress-nginx<br> spec:<br> &nbsp; type: NodePort<br> &nbsp; ports:<br> &nbsp;&nbsp;&nbsp; - name: http<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port: 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetPort: 80<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protocol: TCP<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nodePort: 30080 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们指定的节点暴露的端口<br> &nbsp;&nbsp;&nbsp; - name: https<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port: 443<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetPort: 443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 后端的nginx的端口<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protocol: TCP<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nodePort: 30443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定Nginx暴露的端口<br> &nbsp; selector:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app: ingress-nginx<br> ---</p> 
  <p>[root@server1 ingress]# kubectl apply -f ./<br> service/myapp unchanged<br> deployment.apps/myapp-deploy unchanged<br> service/ingress-nginx created</p> 
  <p>[root@server1 ingress]# kubectl get svc -n ingress-nginx<br> NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLUSTER-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL-IP&nbsp;&nbsp; PORT(S)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AGE<br> ingress-nginx&nbsp;&nbsp; NodePort&nbsp;&nbsp; 10.105.174.166&nbsp;&nbsp; &lt;none&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80:30080/TCP,443:30443/TCP&nbsp;&nbsp; 4m</p> 
  <p>现在我们就可以在集群的外部尝试访问一下我们的Ingress 的服务 ：</p> 
  <p>但是按理来说应该出现正常的调度：&nbsp; 出现的应该是&nbsp; default&nbsp; backed - 404&nbsp;&nbsp; 但是却出现的是根本就访问不了这个30080的端口 ，提示：端口不能正常的访问，&nbsp; 那 继续向下&nbsp; ，看看这个问题到后面能不能解决 ？</p> 
  <p>&nbsp;</p> 
  <p>下来我们将我们的myapp关联到nginx上 ：</p> 
  <p>[root@server1 ingress-nginx]# kubectl describe svc myapp<br> Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myapp<br> Namespace:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default<br> Labels:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;<br> Annotations:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"v1","kind":"Service","metadata":{"annotations":{},"name":"myapp","namespace":"default"},"spec":{"ports":[{"name":"http","port":80,"targe...<br> Selector:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app=myapp,release=canary<br> Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClusterIP<br> IP:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.105.120.214<br> Port:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http&nbsp; 80/TCP<br> TargetPort:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80/TCP<br> Endpoints:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.244.1.102:80,10.244.1.103:80,10.244.2.99:80<br> Session Affinity:&nbsp; None<br> Events:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;none&gt;</p> 
  <p>&nbsp;</p> 
  <p>[root@server1 ingress]# vim ingress-myapp.yaml</p> 
  <p>apiVersion: extensions/v1beta1<br> kind: Ingress<br> metadata:<br> &nbsp; name: ingress-myapp<br> &nbsp; namespace: default<br> &nbsp; annotations:<br> &nbsp;&nbsp;&nbsp; kubernetes.io/ingress.class: "nginx"<br> spec:<br> &nbsp; rules:<br> &nbsp; - host: myapp.magedu.com<br> &nbsp;&nbsp;&nbsp; http:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paths:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - path:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backend:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serviceName: myapp<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; servicePort: 80</p> 
  <p>[root@server1 ingress]# kubectl apply -f ingress-myapp.yaml<br> ingress.extensions/ingress-myapp created</p> 
  <p>[root@server1 ingress]# kubectl get ingress<br> NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HOSTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDRESS&nbsp;&nbsp; PORTS&nbsp;&nbsp;&nbsp;&nbsp; AGE<br> ingress-myapp&nbsp;&nbsp; myapp.magedu.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13s</p> 
  <p>[root@server1 ingress]# kubectl describe ingress ingress-myapp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个ingress一旦创建了以后会自动的注入到 ingress Controller中去， 会自动的转换成nginx的配置文件<br> Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ingress-myapp<br> Namespace:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default<br> Address:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br> Default backend:&nbsp; default-http-backend:80 (&lt;none&gt;)<br> Rules:<br> &nbsp; Host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Path&nbsp; Backends<br> &nbsp; ----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----&nbsp; --------<br> &nbsp; myapp.magedu.com &nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myapp:80 (&lt;none&gt;)<br> Annotations:<br> &nbsp; kubectl.kubernetes.io/last-applied-configuration:&nbsp; {"apiVersion":"extensions/v1beta1","kind":"Ingress","metadata":{"annotations":{"kubernetes.io/ingress.class":"nginx"},"name":"ingress-myapp","namespace":"default"},"spec":{"rules":[{"host":"myapp.magedu.com","http":{"paths":[{"backend":{"serviceName":"myapp","servicePort":80},"path":null}]}}]}}</p> 
  <p>&nbsp; kubernetes.io/ingress.class:&nbsp; nginx<br> Events:<br> &nbsp; Type&nbsp;&nbsp;&nbsp; Reason&nbsp; Age&nbsp;&nbsp; From&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message<br> &nbsp; ----&nbsp;&nbsp;&nbsp; ------&nbsp; ----&nbsp; ----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------<br> &nbsp; Normal&nbsp; CREATE&nbsp; 49s&nbsp;&nbsp; nginx-ingress-controller&nbsp; Ingress default/ingress-myapp<br> [root@server1 ingress]#</p> 
  <p>[root@server1 ingress]# kubectl exec&nbsp; -n ingress-nginx -it&nbsp; nginx-ingress-controller-769d8b56b7-scqh6 -- /bin/sh<br> $ cat nginx.conf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用交互式的命令进入到pod内部去，查看nginx的配置文件中有没有我们定义的</p> 
  <p># Configuration checksum: 3855965695233399109</p> 
  <p>&nbsp;&nbsp;&nbsp; server {<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server_name myapp.magedu.com ;<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;listen 80;<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p> 
  <p><br> 注意：nginx的负载是以域名进行负载的，因此我们必须要注意解析到本地的节点，</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
