<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Java面试 32个核心必考点完全解析 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Java面试 32个核心必考点完全解析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="//点关注，不迷路；持续更新Java架构相关技术及资讯！！！ 课程预习 课程内容分为三个模块 基础模块： 技术岗位与面试 计算机基础 JVM原理 多线程 设计模式 数据结构与算法 应用模块： 常用工具集 常用框架 缓存 队列 数据库 综合模块： 系统架构设计 微服务架构 容器化 换工作面临问题 能力不错，却总被忽略 不知道简历怎么准备 工作年限 美观度 多分简历 不知道面试官考什么 社交门户侧重于大规模并发场景的应用和架构能力 OTO行业侧重于综合能力考察 金融更喜欢逻辑缜密，对高可用安全领域有经验的候选人 校招更多对基础知识和逻辑思维方面的考察，以培养潜力考察为主 初中级工程师则需要多关注知识的广度，基础知识的应用 高级资深工程师需要深入理解基本原理，以综合能力考察为主 没有get到面试官的考察意图。如：问到是否使用某框架，实际是是问该框架的使用场景，有什么特点，和同类可框架对比一系列的问题。 不知道如何提升晋级？ 学习首先有个框架 课程特色 全盘汇总：Java知识体现精细梳理 特近实战：面试官亲自教你拿Offer 潜规则：揭秘技术面试加分&amp;潜规则 权威性：拉勾40W技术岗位大数据支持 课时1：技术人职业发展路径 1.1 工程师发展路径 技术序列：技术攻坚、架构知识、专业知识 工程师 高级工程师 资深工程师 技术专家 高级技术专家 1~3年内从工程师到高级工程师发展，夯实基础，重点提高工作基础能力，培养技术的深度和广度，对不同方向的新技术保持强烈的好奇心和学习心 3年以上资深工程师需要重点配音技术攻坚能力，疑难问题的排查，大型项目的工程拆分，技术品牌的塑造。具体工作包括，原理实现，注重框架能力的培养，大规模高并发场景，高可用可扩展措施和方案，业务的抽象和架构能力 管理序列：团队管理、项目管理、沟通协作 工程师 高级工程师 技术经理 技术总监 高级技术总监 偏向于团队把控，需要让团队形成技术战斗力，利用一切资源让团队完成作战目标，做好团队内和跨团队沟通工作，在实际工作中这两种并没有明显的边界，例如做管理不表示远离架构设计，技术专家也不是单兵作战。这两个方向的区分点在于工作方向的侧重点不同。 面试诀窍示例：同过往的经验来看，我对项目的整体规划、管理、推进比较感兴趣，在任务协调沟通方面也有过比较突出的表现，所以我的职业规划是成为一名职业的技术经理，以管理方向为发展目标。 1.2 常见技术岗位划分 1.3 面试岗位选择 公司&amp;团队 大公司核心业务（首选） 小公司核心业务（1~3年） 大公司边缘业务（镀金） 小公司边缘业务（尽量不选） 岗位匹配度 匹配度与发展方向相吻合 1.4 常见面试流程 前置面试 电话面试 笔试 上机编程 技术一面 纯技术面（首选算法，例如排序、） 偏重于基础与实战能力 面试官是未来的同组同事 技术二面 纯技术面（项目能力、架构能力） 偏重算法、技术深度 面试官是未来直属leader 技术三面 半技术面（架构能力、技术敏感度、职业规划） 架构能力与发展潜力 面试官是部门技术leader HR面 非技术面 个人发展规划 价值观与薪资 各级领导 一般非技术面 没有原则性问题能都通过 1.5 面试前的准备工作 能力、心态、沟通 了解应试公司及岗位信息 系统复习基础知识 对原公司负责的项目进行梳理总结 学习典型架构案例 阅读常考考点源码 针对性准备加分项 提前准备一份自我介绍，自己的技术特长和职业优势 避免冷场，对于回答不上来的问题，提供解题思路，或者询问面试官是否可以换一个问题 注意细节，坐姿、表情、观察面试官反应 1.6 面试考察点 硬技能 基础知识 项目经验 架构能力 应用能力 软实力 逻辑思维 沟通协作 管理推进 学习思考 培养潜力 1.7 四类硬技能 基础知识 计算机基础 网络 操作系统 数据结构 算法 Java JVM 语言特性 多线程 项目经验 项目描述 项目难点 项目问题 项目改进 应用知识 常用工具 排查类 协作类 保障类 系统类 常用框架 Spring Netty Dubbo Motan Mybatis 队列 数据库 缓存 架构能力 微服务架构 Docker ZK SC KBs 课时2：计算机与网络基础 2.1 知识点汇总 2.1.1操作系统（加粗为重点） 进程与线程 区别联系：进程是资源分配的最小单位，线程是程序执行的最小单位；进程使用独立的数据空间，线程共享进程的数据空间 线程调度：时间片轮转调度、先来先服务调度、优先级调度、多级反馈队列调度、高响应比优先调度 线程切换步骤：线程的上下文切换、线程切换的代价 Linux下的IPC（进程间通讯） Pipe MessageQueue 共享内存 UnixSocket Signal Semaphore 协程 Linux常用命令 awk top netstat grep less tail 死锁 内存分页管理于Swap 任务队列于CPU Load 扩展知识点 内存屏障 指令乱序 分支预测 CPU亲和性（affinity） Netfilter于iptables 2.1.2 网络知识（加粗为重点） 4/7层网络模型 TCP协议 建立链接三次握手 关闭链接四次握手 报文状态标志与链接状态 Nagel算法与ACK延迟 Keepalive 滑动窗口与流量控制 UDP 非链接 非可靠传输 效率高 HTTP 协议 Method Header Cookie UrlEncode 状态码 HTTPS HTTP2 多路复用 Stream 流量控制 服务端推送 头部压缩 QUIC（基于UDP，但是提供了基于UDP的可靠性保障） 避免前序抱阻塞（HOL阻塞） 零RTT建联 FEC前向纠错 2.2 TCP详解 TCP特点 基于链接（点对点） 双工通信 可靠传输 拥塞控制 基于字节流而非报文（保证数据的可靠性和完整性） TCP实现细节 8种报文状态 滑动窗口机制 KeepAlive Bagel算法 2.3 设计模式详解 主要考察两点 设计模式的实现 设计模式的使用场景（用来解决什么问题） 单例模式 工厂模式 代理模式 构造者模式 责任链模式 适配器模式 观察者模式 其他模式 2.3.1 单例模式线程安全实现 静态初始化（饿汉式） 双重检查（懒汉式） 单例注册表 2.3.2 常用设计模式与应用场景 工厂模式：Spring如何创建Bean 代理模式：Motan服务的动态代理 责任链模式：Netty消息处理的方式 适配器模式：Slf4J如何支持Log4J 观察者模式：GRPC是如何支持流式请求的 构造者模式：PB序列化中的Builder 2.4 Java基础知识详解 JUC ConcurrentXXX AtomicXXX Executor Caller&amp;Future Queue Locks 版本差异新特性 动态代理与反射 数据类型 空间占用 基本数据结构 自动转型与强制转型 封箱与拆箱 常用集合 HashMap ConcurrentHashMap ArrayList&amp;LinkedList HashSet TreeMap 对象引用 强引用 弱引用 软引用 虚引用 异常机制 扩展知识点 SPI机制 注解处理机制 2.4.1 Map——知识点详解 HashMap 数组加链表的实现方式 容量大小是2的幂次方 并发读写会有什么风险 ConcurrentHashMap 并发控制与分段锁思想 1.8中的CAS自旋锁 红黑树的启用条件 2.4.1 Java版本特性 V 1.8 Lambda表达式 Stream API 方法引用 接口默认方法 Metaspace替换PermGen V 1.9-1.10 模块系统 默认G1回收器 接口私有方法 局部变量推断 Graal编译器 V 1.11 ZGC 字符串API增强 内建HTTP Client 2.5 考察点和加分项 面试考察点 基本概念和基本原理 实现方式与使用姿势 经常用到的知识点 实际应用中容易犯错的点 与面试方向相关的知识点 加分项 知识点与典型的业务场景关联 以反例来描述实际场景中误用的危害 与知识点相关的优化点（例如在介绍TCP的建联与断连时最好能够指出，出现timewait时可以调整系统参数加快链接的回收与复用） 与知识点相关的最新技术趋势 在了解的前提下，尽量增加回答内容深度 2.6 真题 真题汇总——1 线程与进程的区别与联系 从资源的占用，切换效率，通信方式回答 简单介绍一下进程的切换过程 主要考察线程上下文的切换代价，要回答切换会保持寄存器、栈等线程相关的现场，需要由用户态切换到内核态，最后知道可以通过vmstate命令查看上下文的切换状况 你经常使用哪些Linux命令，主要用来解决什么问题？ 为什么TCP建联需要3次握手而断连需要4次 为什么TCP关闭链接时需要TIME_WAIT状态，为什么要等2MSL？ 一次完整的HTTP请求过程是怎样的 DNS解析、TCP建联、HTTP请求、HTTP相应 真题汇总——2 HTTP2与HTTP的区别有哪些？ 在你的项目中你使用过哪些设计模式？主要用来解决什么问题？ Object中的equal和hashCode的作用分别是什么？ final、finally、finalize的区别与使用场景 简单描述一下java的异常机制 线上使用的哪个版本jdk，为什么使用这个版本（有什么特点）？ 课时3：深入浅出JVM 3.1 知识点汇总 内存模型 程序计数器 方法区 堆 栈 本地方法栈 类加载器 双亲委派机制 Boostrap类加载器 Extension类加载器 System类加载器 自定义类加载器 GC 分代回收 老年代 年轻代 持久代 回收器实现 穿行回收器 并行回收器 CMS G1 性能调优 JVM参数 性能分析工具 MAT JMC JStack JStat 执行模式 解释模式 编译模式 混合模式 编译器优化 公共子表达式的消除 指令重排 内联 逃逸分析 方法逃逸 线程逃逸 栈上分配 同步消除 3.2 JVM的内存模型 3.2.1 JVM内存模型 线程独占 栈（存储局部变量表、操作栈、动态链接、方法出口等信息） 本地方法栈（native方法） 程序计数器 线程共享 堆（堆所有线程共享，分代管理） 方法区（类信息、常量、静态变量，jdk1.7中的永久代和jdk1.8中的metaspace都是方法区的一种实现） 面试回答要点： 各部分功能 哪些是线程共享，哪些是线程独占 3.2.2 JMM与内存可见性 Java内存模型，定义程序中变量的访问规则。 在多线程进行数据交互时，例如线程A给一个共享变量赋值后由线程B来读取这个值，线程A修改变量只修改在自己的工作内存区中，线程B是不可见的，只有从A的工作内存区写回到工作主内存，B在从主内存读取到自己的工作内存区才能进行进一步的操作。 由于指令重排序的存在，写和读的顺序可能会被打乱，因此JMM需要提供原子性、可见性、有序性的保证。 3.3 Java类加载机制详解 3.3.1 类的生命周期 加载：是文件到内存的过程，通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个Class对象； 验证：验证是堆文件类内容验证，目的在于当前类文件是否符合虚拟机的要求，不会危害到虚拟机安全，主要包括四种：文件格式验证、元数据验证、字节码、符号引用； 准备：准备阶段是进行内存分配，为类变量，也就是类中由static修饰的变量分配内存并设置初始值，初始值是0或null，而不是代码中设置的具体值，代码中设置的值在初始化阶段完成，另外也不包括final修饰的静态变量，因为final变量在编译时就已经分配； 解析：解析主要是解析字段、接口、方法，主要是将常量值中的符号引用替换为直接引用的过程，直接引用就是直接指向目标的指针或相对偏移量等； 初始化：最后是初始化，主要是完成静态块执行与静态变量的赋值，这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。 只有对类使用是才会初始化，初始化的条件包括访问类的实例，访问类的静态方法和静态变量的时候，使用Class.forName()反射类的时候，或者某个子类被初始化的时候。 3.3.2 类加载器 BootStrap ClassLoader：启动类加载器加载JAVA_HOME/lib下的类 ExtClassLoader：扩展加载器加载JAVA_HOME/lib/ext下的类 AppClassLoader：应用加载器加载加载classpath指定目录下的类 除此之外，还可以自定义类加载器。 Java的类加载器使用双亲委派模式，双亲委派模型的工作过程是： 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。 每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。 只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。 很多人对“双亲”一词很困惑。这是翻译的锅，，，“双亲”只是“parents”的直译，实际上并不表示汉语中的父母双亲，而是一代一代很多parent，即parents。 双亲委派模式优势： 采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。 3.4 常用GC算法介绍 3.4.1 分代回收 分代管理主要是为了方便垃圾回收，这样做是基于两个事实： 大部分对象很快都不在使用 还有一部分不会立即无用，但也不会持续很长时间 大部分对象在Eden区中生成，Eden区满时，还存活的对象会在两个Suivivor区交替保存，达到一定次数后对象会晋升为老年代。 老年代用来存放从年轻代晋升而来的存活时间较长的对象。 永久代主要用来保存类信息等内容。 3.4.2 垃圾回收算法 着色指针 读屏障 并发处理 基于Region 内存压缩（整理） 3.5 考察点和加分项 考察点 深入理解JVM内存模型 了解类加载机制 了解内存可见性 了解常用的GC算法实现和使用场景 能够根据业务场景选择合适JVM参数与GC算法 加分项 编译器优化 问题排查经验与思路 JVM调优经验与调优思路 了解最新的技术趋势（例如：ZGC、Grraalvm） 3.6 真题 简述描述一下JVM的内存模型 生命情况下会触发FullGC Java类加载器由几种，关系是怎样的？ 双亲委派机制的加载流程是怎样的，有什么好处？ 1.8为什么用Metaspace替换掉PermGen？Metasapce保存在哪里？ 编译期会对指令做哪些优化？（简单描述编译器的指令重排） 简单描述一下volatile可以解决什么问题？如何做到的？ 强制主内存读写同步以及防止指令重排序两点 简单描述一下GC的分代回收 G1垃圾回收算法与CMS的区别有哪些？ 对象引用有哪几种方式，有什么特点？ 强弱软虚在四种引用以及在GC中的处理方式 使用过哪些JVM调试工具，主要分析哪些内容？ 课时4：并发与多线程 4.1 知识点汇总 死锁 竞争条件与临界区 死锁检测与防止死锁 残剩条件 互斥 请求并保持 不可剥夺 循环等待 线程通信 wait notify notifyAll 线程状态转换 NEW RUNNABLE BLOCKED WAITING TIMED_WAITING TERMINATED 常用工具类（JUC） ConcurrentXXX AtomicXXX Executor Caller&amp;Future Queue Locks 机制 ThreadLocal Fork/Join Volatile Interrupt 同步与互斥 Synchronized Lock 锁类型 锁实现 CAS Unsafe 原语 线程池 使用场景 原理与实现方式 线程池实现 4.2 线程池详解 线程池参数介绍 核心线程数，默认情况下，核心线程会一直存活 最大线程数，决定线程池最多可以创建多少线程 线程的空闲时间，空闲时间的单位，当线程闲置超过空闲时间时就会被销毁 线程缓存队列 有界队列 无界队列 同步队列 线程池工厂方法 线程池满时拒绝策略 抛出异常 丢弃 提交失败时，由提交任务的线程直接执行任务 丢弃最早提交的任务 4.3 JUC重点工具实现类 4.4 考察点和加分项 考察点 理解线程的同步与互斥的原理（临界资源、理解区、自旋锁、偏向锁 、冲入锁、读写锁概念） 掌握线程安全相关机制（CAS、Synchronized、ThreadLocal使用弱引用ThreadLocalMap） 了解JUC工具的使用场景与实现原理 熟悉线程池的原理、使用场景、常用配置 理解线程的同步与异步、阻塞与非阻塞（同步与异步的区别是任务是否在同一个线程中执行的 ，阻塞与非阻塞的区别是异步执行任务时线程是不是会阻塞等待结构还是会继续等待后面的逻辑） 加分项 结合实际项目经验或实际案例介绍原理 解决多线程问题的排查思路与经验 熟悉常用的线程分析工具与方法 了解Java8堆JUC的增强 了解Reactive异步编程思想 4.5 真题 如何实现一个生产者与消费者模型？（锁、信号量、线程通信、阻塞队列等） 如何理解线程的同步与异步、阻塞与非阻塞？ 线程池处理任务的流程是怎样的？ wait与sleep的由什么不同？ wait属于Object类，sleep属于Thread类； wait会释放对象锁，而sleep不会； wait需要在同步块中使用，sleep可以在任何地方使用； sleep需要捕获异常、wait不需要。 Synchronized和ReentranLock有什么不同？ 读写锁适用于什么场景？ReentrantReadWriteLock是如何实现的？ 读写锁适合读并发多，写并发少的场景 线程之间如何通信？ wait和notify机制、共享变量Synchronized 保证线程安全的方法由哪些？ CAS、Synchronized、Lock、ThreadLocal 如何尽可能提高多线程并发性能？ 尽量减少临界区范围、使用ThreadLocal、减少线程切换、使用读写锁或CopyOnWrite机制 ThreadLocal用来解决什么问题？ThreadLocal是如何实现的？ 重点回答ThreadLocak不是用来解决多线程共享变量的问题，而是线程数据隔离的问题 死锁产生的条件？如何分析是否由线程死锁？ 在实际工作中遇到过什么样的并发问题，如何发现（排查）并解决的？ 课时5：数据结构与算法 5.1 知识点汇总 5.1.1 数据结构 队列 栈 表 数组 单链表 双链表 循环链表 散列表 图 有向图 无向图 带权图 多叉树 B、B+树 字典树 二叉树 平衡二叉树 红黑树 哈夫曼树 堆 5.1.2 算法 常用算法思路 分治 动态规划 贪心 回溯 分支界定 复杂度 时间复杂度 空间复杂度 排序 插入 希尔 直插 交换 冒泡 快排 选择 简单选择 堆 归并 基数 查找 二分查找 二叉排序树 B树 BloomFilter 字符串匹配 BF算法 BM算法 Sundady算法 KMP算法 Tire树 5.2 字符串匹配 字符串匹配问题 判断给定字符串中的括号是否匹配 解体思路： 使用栈 遇左括号入栈 遇右括号出栈，判断出栈括号是否与右括号成对 5.3 考察点和加分项 考察点 了解基本数据结构与特点 表、栈、队列、树需要熟练掌握，深刻理解使用场景（例如红黑树适合搜索，B+树适合索引） 了解常用的搜索、排序算法，及复杂度和稳定性 了解常用的字符串处理算法 能够分析算法实现的复杂度 了解常用算法分类，解决问题的思路和解决哪类问题 加分项 能够将数据结构与实际使用场景结合（介绍红黑树时结合TreeMap的实现，介绍B+树时结合MySQL的索引） 不同算法在业务场景中的应用 面对模糊的题目能沟通确认条件和边界 书写算法代码前，先讲一下解题思路 能够发现解答中的一些问题，给出改进的思路 5.4 真题 题1、题2基础题，必须掌握 各种排序算法实现和复杂度、稳定性 二叉树的前、中、后序遍历 翻转句子中单词的顺序 用栈模拟队列（或用队列模拟栈） 堆10亿个数进行排序，限制内存位1G 去掉（或找出）两个数组中重复的数字 将一颗二叉树转换成其镜像 确定一个字符串中的括号是否匹配 给定一个开始词，一个结束词，一个字典，如何找到从开始词到结束词的最短单词接龙路径 如何查找两个二叉树节点的最近公共祖先 课时6：常用工具集 6.1 知识点汇总 团队协作 Ant Maven Gradle Git SVN 质量保证 Checkstyle FindBugs SonarQube 压测 JMeter JMH AB LoadRunner 容器与代理（随着微服务的盛行，Envoy、OpenResty、Kong等API网关的使用也越来越普遍） Tomcat Jetty Nginx Envoy OpenResty Kong CI/CD Gitlab-CI Jenkins Travis JVM相关 JMC（JFR） jstack、jmap、jstat 系统分析 vmstat iostat &amp; iotop ifstat &amp; iftop netstat dstat strace GDB lsof tcpdump traceroute 文档管理 JavaDoc Swagger 网络工具 PostMan WireShark（网络包分析工具） Fiddler（只针对HTTP进行抓捕） Charies 6.2 考察点和加分项 考察点 了解常用JVM分析工具 掌握Git的常用操作和工作流 了解Linux系统下常用的分析工具 加分项 能够主动出击体现知识广度（在描述项目问题主动引出工具） 能够体现实战能力 6.6 真题 排查JVM问题有哪些常用工具？ Git合并代码有那两种方法？有什么区别 Git与SVN有哪些差异？ 你所在的团队项目开发使用什么样工作流？有什么优点？ 课时7：必会框架（上）——Spring全家桶 7.1 知识点汇总 Spring Spring Framework Spring Boot Spring Data Spring Cloud Sleuth Netflix Config Bus Security Struts ORM Hibernate Mybatis Netty RPC Motan Bubbo Grpc 其他框架 Jersey RESTEasy Shiro 7.2 Spring框架 机制与实现 AOP 动态代理 静态代理 PlaceHolder动态替换 PropertyPlaceholderConfigure PropertySourcesPlaceholderConfigure 事务 隔离级别 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE 传播行为 PROPAGATION_REQUIRED PROPAGATION_SUPPORTS PROPAGATION_MANDATORY PROPAGATION_REQUIRED_NEW PROPAGATION_NOT_SUPPORTED PROPAGATION_NEVER PROPAGATION_NESTED 核心接口/类 ApplicationContext BeanFactory BeanWrapper FactoryBean scope Singleton Prototype Request Session Global-session Application Websocket 事件机制 ContextRefreshedEvent ContextStatedEvent ContextStoppedEvent ContextClosedEvent RequestHandledEvent Spring应用 类型类 @Controller @service @Repository @Component @Configuration @Bean 设置类 @Required @Autowired &amp;&amp; @Qualifier @Scope Web类 @RequestMapping &amp;&amp; @GetMapping @ PostMapping @PathVariable &amp;&amp; @RequestParam @RequestBody &amp;&amp; @ResponseBody 功能类 @ImportResource @ComponentScan @EnableCaching &amp;&amp; Cacheable @Transactional @Aspect &amp;&amp; Poincut @Scheduled 配置方式 XML 注解 API 自动装配 byType byName constructor autodetect 课时8：必会框架（下）——RPC与ORM 8.1 考察点与加分项 考察点 掌握Spring的IOC、AOP的概念与实现 掌握Spring的Context创建流程和Bean的生命周期 了解Spring常用注解的作用与使用方式 了解SpringBoot的相关知识点 掌握Netty的线程处理模型 知道常用RPC框架的特点 了解Mybatis、Hibernate的实现原理 加分项 阅读过框架源码，了解实现细节及思路 除了会应用，还能够理解理念 了解最新实现或方向 有实际优化经验，例如Nett有性能调优 8.2 真题 SSH和SSM框架组合的区别是生命？ 能描述一些Spring Context初始化的整个流程吗？ 简单介绍一些Bean的生命周期及作用域 Spring配置中的placeholder占位符是如何替换的？有什么办法可以实现自定义的配置替换？ 要答出通过beanFactoryPostProfessal后置处理器进行的替换，如果要自定义处理，可以扩展PropertyPlaceHolderConfigure或者PropertySourcePlaceHolderConfigure来实现 SpringMVC的工作流程是怎样的？ Spring如何解决循环依赖？ 从构造器循环依赖和setter循环依赖两方面来回答 Bean的构造方法、@PostConstruct注解、InitializingBean、init-method的执行顺序是怎样的？ 说说Netty中有哪些重要的对象，它们之间的关系是什么？ RPC与HTTP的区别是什么，什么场景适合选用RPC，什么场景适合使用HTTP？ 在使用方式方面，HTTP使用Client，RPC通过动态代理；从请求模型看，HTTP一般会经过DNS解析，4/7层代理等中间环节，而RPC是点对点直连；从服务治理能力来看，RPC提供丰富的服务治理功能，例如熔断 、负载均衡，HTTP对跨语言处理比较方便 RPC的交互流程是怎样的？ 请介绍一下Mybatis的缓存机制 Mybatis如何配置动态SQL？有哪些动态SQL标签？ 课时9：缓存 9.1 考察点和加分项 考察点 了解缓存的使用场景，不同类型缓存的使用方式 掌握MC和Redis的常用命令 了解MC的Redis在内存中的存储结构 了解MC和Redis的数据失效方式和剔除策略 了解Redis的持久化、主从同步与cluster部署的原理 加分项 结合使用场景来介绍缓存的使用 有过分布式缓存设计和应用经验 了解缓存使用中可能产生的问题 知道Redis的典型应用场景 知道Redis的新特性 9.2 真题 Redis和Memcache有什么区别？该如何选用 你用到过哪些Redis的数据结构？用在什么场景下？ Redis有哪些持久化方式，分别是什么？ Redis的过期机制是怎样的？Redis有哪些淘汰策略 如何保证Redis的高并发和高可用？ 如何使用Redis实现延时队列？如何使用Redis实现分布式锁？ 读者福利： 分享免费学习资料 针对于Java程序员，我这边准备免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料） 为什么某些人会一直比你优秀，是因为他本身就很优秀还一直在持续努力变得更优秀，而你是不是还在满足于现状内心在窃喜！希望读到这的您能点个小赞和关注下我，以后还会更新技术干货，谢谢您的支持！ 资料领取方式：加入Java技术交流群963944895，点击加入群聊，私信管理员即可免费领取 //点关注，不迷路；持续更新Java架构相关技术及资讯！！！" />
<meta property="og:description" content="//点关注，不迷路；持续更新Java架构相关技术及资讯！！！ 课程预习 课程内容分为三个模块 基础模块： 技术岗位与面试 计算机基础 JVM原理 多线程 设计模式 数据结构与算法 应用模块： 常用工具集 常用框架 缓存 队列 数据库 综合模块： 系统架构设计 微服务架构 容器化 换工作面临问题 能力不错，却总被忽略 不知道简历怎么准备 工作年限 美观度 多分简历 不知道面试官考什么 社交门户侧重于大规模并发场景的应用和架构能力 OTO行业侧重于综合能力考察 金融更喜欢逻辑缜密，对高可用安全领域有经验的候选人 校招更多对基础知识和逻辑思维方面的考察，以培养潜力考察为主 初中级工程师则需要多关注知识的广度，基础知识的应用 高级资深工程师需要深入理解基本原理，以综合能力考察为主 没有get到面试官的考察意图。如：问到是否使用某框架，实际是是问该框架的使用场景，有什么特点，和同类可框架对比一系列的问题。 不知道如何提升晋级？ 学习首先有个框架 课程特色 全盘汇总：Java知识体现精细梳理 特近实战：面试官亲自教你拿Offer 潜规则：揭秘技术面试加分&amp;潜规则 权威性：拉勾40W技术岗位大数据支持 课时1：技术人职业发展路径 1.1 工程师发展路径 技术序列：技术攻坚、架构知识、专业知识 工程师 高级工程师 资深工程师 技术专家 高级技术专家 1~3年内从工程师到高级工程师发展，夯实基础，重点提高工作基础能力，培养技术的深度和广度，对不同方向的新技术保持强烈的好奇心和学习心 3年以上资深工程师需要重点配音技术攻坚能力，疑难问题的排查，大型项目的工程拆分，技术品牌的塑造。具体工作包括，原理实现，注重框架能力的培养，大规模高并发场景，高可用可扩展措施和方案，业务的抽象和架构能力 管理序列：团队管理、项目管理、沟通协作 工程师 高级工程师 技术经理 技术总监 高级技术总监 偏向于团队把控，需要让团队形成技术战斗力，利用一切资源让团队完成作战目标，做好团队内和跨团队沟通工作，在实际工作中这两种并没有明显的边界，例如做管理不表示远离架构设计，技术专家也不是单兵作战。这两个方向的区分点在于工作方向的侧重点不同。 面试诀窍示例：同过往的经验来看，我对项目的整体规划、管理、推进比较感兴趣，在任务协调沟通方面也有过比较突出的表现，所以我的职业规划是成为一名职业的技术经理，以管理方向为发展目标。 1.2 常见技术岗位划分 1.3 面试岗位选择 公司&amp;团队 大公司核心业务（首选） 小公司核心业务（1~3年） 大公司边缘业务（镀金） 小公司边缘业务（尽量不选） 岗位匹配度 匹配度与发展方向相吻合 1.4 常见面试流程 前置面试 电话面试 笔试 上机编程 技术一面 纯技术面（首选算法，例如排序、） 偏重于基础与实战能力 面试官是未来的同组同事 技术二面 纯技术面（项目能力、架构能力） 偏重算法、技术深度 面试官是未来直属leader 技术三面 半技术面（架构能力、技术敏感度、职业规划） 架构能力与发展潜力 面试官是部门技术leader HR面 非技术面 个人发展规划 价值观与薪资 各级领导 一般非技术面 没有原则性问题能都通过 1.5 面试前的准备工作 能力、心态、沟通 了解应试公司及岗位信息 系统复习基础知识 对原公司负责的项目进行梳理总结 学习典型架构案例 阅读常考考点源码 针对性准备加分项 提前准备一份自我介绍，自己的技术特长和职业优势 避免冷场，对于回答不上来的问题，提供解题思路，或者询问面试官是否可以换一个问题 注意细节，坐姿、表情、观察面试官反应 1.6 面试考察点 硬技能 基础知识 项目经验 架构能力 应用能力 软实力 逻辑思维 沟通协作 管理推进 学习思考 培养潜力 1.7 四类硬技能 基础知识 计算机基础 网络 操作系统 数据结构 算法 Java JVM 语言特性 多线程 项目经验 项目描述 项目难点 项目问题 项目改进 应用知识 常用工具 排查类 协作类 保障类 系统类 常用框架 Spring Netty Dubbo Motan Mybatis 队列 数据库 缓存 架构能力 微服务架构 Docker ZK SC KBs 课时2：计算机与网络基础 2.1 知识点汇总 2.1.1操作系统（加粗为重点） 进程与线程 区别联系：进程是资源分配的最小单位，线程是程序执行的最小单位；进程使用独立的数据空间，线程共享进程的数据空间 线程调度：时间片轮转调度、先来先服务调度、优先级调度、多级反馈队列调度、高响应比优先调度 线程切换步骤：线程的上下文切换、线程切换的代价 Linux下的IPC（进程间通讯） Pipe MessageQueue 共享内存 UnixSocket Signal Semaphore 协程 Linux常用命令 awk top netstat grep less tail 死锁 内存分页管理于Swap 任务队列于CPU Load 扩展知识点 内存屏障 指令乱序 分支预测 CPU亲和性（affinity） Netfilter于iptables 2.1.2 网络知识（加粗为重点） 4/7层网络模型 TCP协议 建立链接三次握手 关闭链接四次握手 报文状态标志与链接状态 Nagel算法与ACK延迟 Keepalive 滑动窗口与流量控制 UDP 非链接 非可靠传输 效率高 HTTP 协议 Method Header Cookie UrlEncode 状态码 HTTPS HTTP2 多路复用 Stream 流量控制 服务端推送 头部压缩 QUIC（基于UDP，但是提供了基于UDP的可靠性保障） 避免前序抱阻塞（HOL阻塞） 零RTT建联 FEC前向纠错 2.2 TCP详解 TCP特点 基于链接（点对点） 双工通信 可靠传输 拥塞控制 基于字节流而非报文（保证数据的可靠性和完整性） TCP实现细节 8种报文状态 滑动窗口机制 KeepAlive Bagel算法 2.3 设计模式详解 主要考察两点 设计模式的实现 设计模式的使用场景（用来解决什么问题） 单例模式 工厂模式 代理模式 构造者模式 责任链模式 适配器模式 观察者模式 其他模式 2.3.1 单例模式线程安全实现 静态初始化（饿汉式） 双重检查（懒汉式） 单例注册表 2.3.2 常用设计模式与应用场景 工厂模式：Spring如何创建Bean 代理模式：Motan服务的动态代理 责任链模式：Netty消息处理的方式 适配器模式：Slf4J如何支持Log4J 观察者模式：GRPC是如何支持流式请求的 构造者模式：PB序列化中的Builder 2.4 Java基础知识详解 JUC ConcurrentXXX AtomicXXX Executor Caller&amp;Future Queue Locks 版本差异新特性 动态代理与反射 数据类型 空间占用 基本数据结构 自动转型与强制转型 封箱与拆箱 常用集合 HashMap ConcurrentHashMap ArrayList&amp;LinkedList HashSet TreeMap 对象引用 强引用 弱引用 软引用 虚引用 异常机制 扩展知识点 SPI机制 注解处理机制 2.4.1 Map——知识点详解 HashMap 数组加链表的实现方式 容量大小是2的幂次方 并发读写会有什么风险 ConcurrentHashMap 并发控制与分段锁思想 1.8中的CAS自旋锁 红黑树的启用条件 2.4.1 Java版本特性 V 1.8 Lambda表达式 Stream API 方法引用 接口默认方法 Metaspace替换PermGen V 1.9-1.10 模块系统 默认G1回收器 接口私有方法 局部变量推断 Graal编译器 V 1.11 ZGC 字符串API增强 内建HTTP Client 2.5 考察点和加分项 面试考察点 基本概念和基本原理 实现方式与使用姿势 经常用到的知识点 实际应用中容易犯错的点 与面试方向相关的知识点 加分项 知识点与典型的业务场景关联 以反例来描述实际场景中误用的危害 与知识点相关的优化点（例如在介绍TCP的建联与断连时最好能够指出，出现timewait时可以调整系统参数加快链接的回收与复用） 与知识点相关的最新技术趋势 在了解的前提下，尽量增加回答内容深度 2.6 真题 真题汇总——1 线程与进程的区别与联系 从资源的占用，切换效率，通信方式回答 简单介绍一下进程的切换过程 主要考察线程上下文的切换代价，要回答切换会保持寄存器、栈等线程相关的现场，需要由用户态切换到内核态，最后知道可以通过vmstate命令查看上下文的切换状况 你经常使用哪些Linux命令，主要用来解决什么问题？ 为什么TCP建联需要3次握手而断连需要4次 为什么TCP关闭链接时需要TIME_WAIT状态，为什么要等2MSL？ 一次完整的HTTP请求过程是怎样的 DNS解析、TCP建联、HTTP请求、HTTP相应 真题汇总——2 HTTP2与HTTP的区别有哪些？ 在你的项目中你使用过哪些设计模式？主要用来解决什么问题？ Object中的equal和hashCode的作用分别是什么？ final、finally、finalize的区别与使用场景 简单描述一下java的异常机制 线上使用的哪个版本jdk，为什么使用这个版本（有什么特点）？ 课时3：深入浅出JVM 3.1 知识点汇总 内存模型 程序计数器 方法区 堆 栈 本地方法栈 类加载器 双亲委派机制 Boostrap类加载器 Extension类加载器 System类加载器 自定义类加载器 GC 分代回收 老年代 年轻代 持久代 回收器实现 穿行回收器 并行回收器 CMS G1 性能调优 JVM参数 性能分析工具 MAT JMC JStack JStat 执行模式 解释模式 编译模式 混合模式 编译器优化 公共子表达式的消除 指令重排 内联 逃逸分析 方法逃逸 线程逃逸 栈上分配 同步消除 3.2 JVM的内存模型 3.2.1 JVM内存模型 线程独占 栈（存储局部变量表、操作栈、动态链接、方法出口等信息） 本地方法栈（native方法） 程序计数器 线程共享 堆（堆所有线程共享，分代管理） 方法区（类信息、常量、静态变量，jdk1.7中的永久代和jdk1.8中的metaspace都是方法区的一种实现） 面试回答要点： 各部分功能 哪些是线程共享，哪些是线程独占 3.2.2 JMM与内存可见性 Java内存模型，定义程序中变量的访问规则。 在多线程进行数据交互时，例如线程A给一个共享变量赋值后由线程B来读取这个值，线程A修改变量只修改在自己的工作内存区中，线程B是不可见的，只有从A的工作内存区写回到工作主内存，B在从主内存读取到自己的工作内存区才能进行进一步的操作。 由于指令重排序的存在，写和读的顺序可能会被打乱，因此JMM需要提供原子性、可见性、有序性的保证。 3.3 Java类加载机制详解 3.3.1 类的生命周期 加载：是文件到内存的过程，通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个Class对象； 验证：验证是堆文件类内容验证，目的在于当前类文件是否符合虚拟机的要求，不会危害到虚拟机安全，主要包括四种：文件格式验证、元数据验证、字节码、符号引用； 准备：准备阶段是进行内存分配，为类变量，也就是类中由static修饰的变量分配内存并设置初始值，初始值是0或null，而不是代码中设置的具体值，代码中设置的值在初始化阶段完成，另外也不包括final修饰的静态变量，因为final变量在编译时就已经分配； 解析：解析主要是解析字段、接口、方法，主要是将常量值中的符号引用替换为直接引用的过程，直接引用就是直接指向目标的指针或相对偏移量等； 初始化：最后是初始化，主要是完成静态块执行与静态变量的赋值，这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。 只有对类使用是才会初始化，初始化的条件包括访问类的实例，访问类的静态方法和静态变量的时候，使用Class.forName()反射类的时候，或者某个子类被初始化的时候。 3.3.2 类加载器 BootStrap ClassLoader：启动类加载器加载JAVA_HOME/lib下的类 ExtClassLoader：扩展加载器加载JAVA_HOME/lib/ext下的类 AppClassLoader：应用加载器加载加载classpath指定目录下的类 除此之外，还可以自定义类加载器。 Java的类加载器使用双亲委派模式，双亲委派模型的工作过程是： 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。 每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。 只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。 很多人对“双亲”一词很困惑。这是翻译的锅，，，“双亲”只是“parents”的直译，实际上并不表示汉语中的父母双亲，而是一代一代很多parent，即parents。 双亲委派模式优势： 采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。 3.4 常用GC算法介绍 3.4.1 分代回收 分代管理主要是为了方便垃圾回收，这样做是基于两个事实： 大部分对象很快都不在使用 还有一部分不会立即无用，但也不会持续很长时间 大部分对象在Eden区中生成，Eden区满时，还存活的对象会在两个Suivivor区交替保存，达到一定次数后对象会晋升为老年代。 老年代用来存放从年轻代晋升而来的存活时间较长的对象。 永久代主要用来保存类信息等内容。 3.4.2 垃圾回收算法 着色指针 读屏障 并发处理 基于Region 内存压缩（整理） 3.5 考察点和加分项 考察点 深入理解JVM内存模型 了解类加载机制 了解内存可见性 了解常用的GC算法实现和使用场景 能够根据业务场景选择合适JVM参数与GC算法 加分项 编译器优化 问题排查经验与思路 JVM调优经验与调优思路 了解最新的技术趋势（例如：ZGC、Grraalvm） 3.6 真题 简述描述一下JVM的内存模型 生命情况下会触发FullGC Java类加载器由几种，关系是怎样的？ 双亲委派机制的加载流程是怎样的，有什么好处？ 1.8为什么用Metaspace替换掉PermGen？Metasapce保存在哪里？ 编译期会对指令做哪些优化？（简单描述编译器的指令重排） 简单描述一下volatile可以解决什么问题？如何做到的？ 强制主内存读写同步以及防止指令重排序两点 简单描述一下GC的分代回收 G1垃圾回收算法与CMS的区别有哪些？ 对象引用有哪几种方式，有什么特点？ 强弱软虚在四种引用以及在GC中的处理方式 使用过哪些JVM调试工具，主要分析哪些内容？ 课时4：并发与多线程 4.1 知识点汇总 死锁 竞争条件与临界区 死锁检测与防止死锁 残剩条件 互斥 请求并保持 不可剥夺 循环等待 线程通信 wait notify notifyAll 线程状态转换 NEW RUNNABLE BLOCKED WAITING TIMED_WAITING TERMINATED 常用工具类（JUC） ConcurrentXXX AtomicXXX Executor Caller&amp;Future Queue Locks 机制 ThreadLocal Fork/Join Volatile Interrupt 同步与互斥 Synchronized Lock 锁类型 锁实现 CAS Unsafe 原语 线程池 使用场景 原理与实现方式 线程池实现 4.2 线程池详解 线程池参数介绍 核心线程数，默认情况下，核心线程会一直存活 最大线程数，决定线程池最多可以创建多少线程 线程的空闲时间，空闲时间的单位，当线程闲置超过空闲时间时就会被销毁 线程缓存队列 有界队列 无界队列 同步队列 线程池工厂方法 线程池满时拒绝策略 抛出异常 丢弃 提交失败时，由提交任务的线程直接执行任务 丢弃最早提交的任务 4.3 JUC重点工具实现类 4.4 考察点和加分项 考察点 理解线程的同步与互斥的原理（临界资源、理解区、自旋锁、偏向锁 、冲入锁、读写锁概念） 掌握线程安全相关机制（CAS、Synchronized、ThreadLocal使用弱引用ThreadLocalMap） 了解JUC工具的使用场景与实现原理 熟悉线程池的原理、使用场景、常用配置 理解线程的同步与异步、阻塞与非阻塞（同步与异步的区别是任务是否在同一个线程中执行的 ，阻塞与非阻塞的区别是异步执行任务时线程是不是会阻塞等待结构还是会继续等待后面的逻辑） 加分项 结合实际项目经验或实际案例介绍原理 解决多线程问题的排查思路与经验 熟悉常用的线程分析工具与方法 了解Java8堆JUC的增强 了解Reactive异步编程思想 4.5 真题 如何实现一个生产者与消费者模型？（锁、信号量、线程通信、阻塞队列等） 如何理解线程的同步与异步、阻塞与非阻塞？ 线程池处理任务的流程是怎样的？ wait与sleep的由什么不同？ wait属于Object类，sleep属于Thread类； wait会释放对象锁，而sleep不会； wait需要在同步块中使用，sleep可以在任何地方使用； sleep需要捕获异常、wait不需要。 Synchronized和ReentranLock有什么不同？ 读写锁适用于什么场景？ReentrantReadWriteLock是如何实现的？ 读写锁适合读并发多，写并发少的场景 线程之间如何通信？ wait和notify机制、共享变量Synchronized 保证线程安全的方法由哪些？ CAS、Synchronized、Lock、ThreadLocal 如何尽可能提高多线程并发性能？ 尽量减少临界区范围、使用ThreadLocal、减少线程切换、使用读写锁或CopyOnWrite机制 ThreadLocal用来解决什么问题？ThreadLocal是如何实现的？ 重点回答ThreadLocak不是用来解决多线程共享变量的问题，而是线程数据隔离的问题 死锁产生的条件？如何分析是否由线程死锁？ 在实际工作中遇到过什么样的并发问题，如何发现（排查）并解决的？ 课时5：数据结构与算法 5.1 知识点汇总 5.1.1 数据结构 队列 栈 表 数组 单链表 双链表 循环链表 散列表 图 有向图 无向图 带权图 多叉树 B、B+树 字典树 二叉树 平衡二叉树 红黑树 哈夫曼树 堆 5.1.2 算法 常用算法思路 分治 动态规划 贪心 回溯 分支界定 复杂度 时间复杂度 空间复杂度 排序 插入 希尔 直插 交换 冒泡 快排 选择 简单选择 堆 归并 基数 查找 二分查找 二叉排序树 B树 BloomFilter 字符串匹配 BF算法 BM算法 Sundady算法 KMP算法 Tire树 5.2 字符串匹配 字符串匹配问题 判断给定字符串中的括号是否匹配 解体思路： 使用栈 遇左括号入栈 遇右括号出栈，判断出栈括号是否与右括号成对 5.3 考察点和加分项 考察点 了解基本数据结构与特点 表、栈、队列、树需要熟练掌握，深刻理解使用场景（例如红黑树适合搜索，B+树适合索引） 了解常用的搜索、排序算法，及复杂度和稳定性 了解常用的字符串处理算法 能够分析算法实现的复杂度 了解常用算法分类，解决问题的思路和解决哪类问题 加分项 能够将数据结构与实际使用场景结合（介绍红黑树时结合TreeMap的实现，介绍B+树时结合MySQL的索引） 不同算法在业务场景中的应用 面对模糊的题目能沟通确认条件和边界 书写算法代码前，先讲一下解题思路 能够发现解答中的一些问题，给出改进的思路 5.4 真题 题1、题2基础题，必须掌握 各种排序算法实现和复杂度、稳定性 二叉树的前、中、后序遍历 翻转句子中单词的顺序 用栈模拟队列（或用队列模拟栈） 堆10亿个数进行排序，限制内存位1G 去掉（或找出）两个数组中重复的数字 将一颗二叉树转换成其镜像 确定一个字符串中的括号是否匹配 给定一个开始词，一个结束词，一个字典，如何找到从开始词到结束词的最短单词接龙路径 如何查找两个二叉树节点的最近公共祖先 课时6：常用工具集 6.1 知识点汇总 团队协作 Ant Maven Gradle Git SVN 质量保证 Checkstyle FindBugs SonarQube 压测 JMeter JMH AB LoadRunner 容器与代理（随着微服务的盛行，Envoy、OpenResty、Kong等API网关的使用也越来越普遍） Tomcat Jetty Nginx Envoy OpenResty Kong CI/CD Gitlab-CI Jenkins Travis JVM相关 JMC（JFR） jstack、jmap、jstat 系统分析 vmstat iostat &amp; iotop ifstat &amp; iftop netstat dstat strace GDB lsof tcpdump traceroute 文档管理 JavaDoc Swagger 网络工具 PostMan WireShark（网络包分析工具） Fiddler（只针对HTTP进行抓捕） Charies 6.2 考察点和加分项 考察点 了解常用JVM分析工具 掌握Git的常用操作和工作流 了解Linux系统下常用的分析工具 加分项 能够主动出击体现知识广度（在描述项目问题主动引出工具） 能够体现实战能力 6.6 真题 排查JVM问题有哪些常用工具？ Git合并代码有那两种方法？有什么区别 Git与SVN有哪些差异？ 你所在的团队项目开发使用什么样工作流？有什么优点？ 课时7：必会框架（上）——Spring全家桶 7.1 知识点汇总 Spring Spring Framework Spring Boot Spring Data Spring Cloud Sleuth Netflix Config Bus Security Struts ORM Hibernate Mybatis Netty RPC Motan Bubbo Grpc 其他框架 Jersey RESTEasy Shiro 7.2 Spring框架 机制与实现 AOP 动态代理 静态代理 PlaceHolder动态替换 PropertyPlaceholderConfigure PropertySourcesPlaceholderConfigure 事务 隔离级别 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE 传播行为 PROPAGATION_REQUIRED PROPAGATION_SUPPORTS PROPAGATION_MANDATORY PROPAGATION_REQUIRED_NEW PROPAGATION_NOT_SUPPORTED PROPAGATION_NEVER PROPAGATION_NESTED 核心接口/类 ApplicationContext BeanFactory BeanWrapper FactoryBean scope Singleton Prototype Request Session Global-session Application Websocket 事件机制 ContextRefreshedEvent ContextStatedEvent ContextStoppedEvent ContextClosedEvent RequestHandledEvent Spring应用 类型类 @Controller @service @Repository @Component @Configuration @Bean 设置类 @Required @Autowired &amp;&amp; @Qualifier @Scope Web类 @RequestMapping &amp;&amp; @GetMapping @ PostMapping @PathVariable &amp;&amp; @RequestParam @RequestBody &amp;&amp; @ResponseBody 功能类 @ImportResource @ComponentScan @EnableCaching &amp;&amp; Cacheable @Transactional @Aspect &amp;&amp; Poincut @Scheduled 配置方式 XML 注解 API 自动装配 byType byName constructor autodetect 课时8：必会框架（下）——RPC与ORM 8.1 考察点与加分项 考察点 掌握Spring的IOC、AOP的概念与实现 掌握Spring的Context创建流程和Bean的生命周期 了解Spring常用注解的作用与使用方式 了解SpringBoot的相关知识点 掌握Netty的线程处理模型 知道常用RPC框架的特点 了解Mybatis、Hibernate的实现原理 加分项 阅读过框架源码，了解实现细节及思路 除了会应用，还能够理解理念 了解最新实现或方向 有实际优化经验，例如Nett有性能调优 8.2 真题 SSH和SSM框架组合的区别是生命？ 能描述一些Spring Context初始化的整个流程吗？ 简单介绍一些Bean的生命周期及作用域 Spring配置中的placeholder占位符是如何替换的？有什么办法可以实现自定义的配置替换？ 要答出通过beanFactoryPostProfessal后置处理器进行的替换，如果要自定义处理，可以扩展PropertyPlaceHolderConfigure或者PropertySourcePlaceHolderConfigure来实现 SpringMVC的工作流程是怎样的？ Spring如何解决循环依赖？ 从构造器循环依赖和setter循环依赖两方面来回答 Bean的构造方法、@PostConstruct注解、InitializingBean、init-method的执行顺序是怎样的？ 说说Netty中有哪些重要的对象，它们之间的关系是什么？ RPC与HTTP的区别是什么，什么场景适合选用RPC，什么场景适合使用HTTP？ 在使用方式方面，HTTP使用Client，RPC通过动态代理；从请求模型看，HTTP一般会经过DNS解析，4/7层代理等中间环节，而RPC是点对点直连；从服务治理能力来看，RPC提供丰富的服务治理功能，例如熔断 、负载均衡，HTTP对跨语言处理比较方便 RPC的交互流程是怎样的？ 请介绍一下Mybatis的缓存机制 Mybatis如何配置动态SQL？有哪些动态SQL标签？ 课时9：缓存 9.1 考察点和加分项 考察点 了解缓存的使用场景，不同类型缓存的使用方式 掌握MC和Redis的常用命令 了解MC的Redis在内存中的存储结构 了解MC和Redis的数据失效方式和剔除策略 了解Redis的持久化、主从同步与cluster部署的原理 加分项 结合使用场景来介绍缓存的使用 有过分布式缓存设计和应用经验 了解缓存使用中可能产生的问题 知道Redis的典型应用场景 知道Redis的新特性 9.2 真题 Redis和Memcache有什么区别？该如何选用 你用到过哪些Redis的数据结构？用在什么场景下？ Redis有哪些持久化方式，分别是什么？ Redis的过期机制是怎样的？Redis有哪些淘汰策略 如何保证Redis的高并发和高可用？ 如何使用Redis实现延时队列？如何使用Redis实现分布式锁？ 读者福利： 分享免费学习资料 针对于Java程序员，我这边准备免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料） 为什么某些人会一直比你优秀，是因为他本身就很优秀还一直在持续努力变得更优秀，而你是不是还在满足于现状内心在窃喜！希望读到这的您能点个小赞和关注下我，以后还会更新技术干货，谢谢您的支持！ 资料领取方式：加入Java技术交流群963944895，点击加入群聊，私信管理员即可免费领取 //点关注，不迷路；持续更新Java架构相关技术及资讯！！！" />
<link rel="canonical" href="https://mlh.app/2019/05/17/787094.html" />
<meta property="og:url" content="https://mlh.app/2019/05/17/787094.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-17T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"//点关注，不迷路；持续更新Java架构相关技术及资讯！！！ 课程预习 课程内容分为三个模块 基础模块： 技术岗位与面试 计算机基础 JVM原理 多线程 设计模式 数据结构与算法 应用模块： 常用工具集 常用框架 缓存 队列 数据库 综合模块： 系统架构设计 微服务架构 容器化 换工作面临问题 能力不错，却总被忽略 不知道简历怎么准备 工作年限 美观度 多分简历 不知道面试官考什么 社交门户侧重于大规模并发场景的应用和架构能力 OTO行业侧重于综合能力考察 金融更喜欢逻辑缜密，对高可用安全领域有经验的候选人 校招更多对基础知识和逻辑思维方面的考察，以培养潜力考察为主 初中级工程师则需要多关注知识的广度，基础知识的应用 高级资深工程师需要深入理解基本原理，以综合能力考察为主 没有get到面试官的考察意图。如：问到是否使用某框架，实际是是问该框架的使用场景，有什么特点，和同类可框架对比一系列的问题。 不知道如何提升晋级？ 学习首先有个框架 课程特色 全盘汇总：Java知识体现精细梳理 特近实战：面试官亲自教你拿Offer 潜规则：揭秘技术面试加分&amp;潜规则 权威性：拉勾40W技术岗位大数据支持 课时1：技术人职业发展路径 1.1 工程师发展路径 技术序列：技术攻坚、架构知识、专业知识 工程师 高级工程师 资深工程师 技术专家 高级技术专家 1~3年内从工程师到高级工程师发展，夯实基础，重点提高工作基础能力，培养技术的深度和广度，对不同方向的新技术保持强烈的好奇心和学习心 3年以上资深工程师需要重点配音技术攻坚能力，疑难问题的排查，大型项目的工程拆分，技术品牌的塑造。具体工作包括，原理实现，注重框架能力的培养，大规模高并发场景，高可用可扩展措施和方案，业务的抽象和架构能力 管理序列：团队管理、项目管理、沟通协作 工程师 高级工程师 技术经理 技术总监 高级技术总监 偏向于团队把控，需要让团队形成技术战斗力，利用一切资源让团队完成作战目标，做好团队内和跨团队沟通工作，在实际工作中这两种并没有明显的边界，例如做管理不表示远离架构设计，技术专家也不是单兵作战。这两个方向的区分点在于工作方向的侧重点不同。 面试诀窍示例：同过往的经验来看，我对项目的整体规划、管理、推进比较感兴趣，在任务协调沟通方面也有过比较突出的表现，所以我的职业规划是成为一名职业的技术经理，以管理方向为发展目标。 1.2 常见技术岗位划分 1.3 面试岗位选择 公司&amp;团队 大公司核心业务（首选） 小公司核心业务（1~3年） 大公司边缘业务（镀金） 小公司边缘业务（尽量不选） 岗位匹配度 匹配度与发展方向相吻合 1.4 常见面试流程 前置面试 电话面试 笔试 上机编程 技术一面 纯技术面（首选算法，例如排序、） 偏重于基础与实战能力 面试官是未来的同组同事 技术二面 纯技术面（项目能力、架构能力） 偏重算法、技术深度 面试官是未来直属leader 技术三面 半技术面（架构能力、技术敏感度、职业规划） 架构能力与发展潜力 面试官是部门技术leader HR面 非技术面 个人发展规划 价值观与薪资 各级领导 一般非技术面 没有原则性问题能都通过 1.5 面试前的准备工作 能力、心态、沟通 了解应试公司及岗位信息 系统复习基础知识 对原公司负责的项目进行梳理总结 学习典型架构案例 阅读常考考点源码 针对性准备加分项 提前准备一份自我介绍，自己的技术特长和职业优势 避免冷场，对于回答不上来的问题，提供解题思路，或者询问面试官是否可以换一个问题 注意细节，坐姿、表情、观察面试官反应 1.6 面试考察点 硬技能 基础知识 项目经验 架构能力 应用能力 软实力 逻辑思维 沟通协作 管理推进 学习思考 培养潜力 1.7 四类硬技能 基础知识 计算机基础 网络 操作系统 数据结构 算法 Java JVM 语言特性 多线程 项目经验 项目描述 项目难点 项目问题 项目改进 应用知识 常用工具 排查类 协作类 保障类 系统类 常用框架 Spring Netty Dubbo Motan Mybatis 队列 数据库 缓存 架构能力 微服务架构 Docker ZK SC KBs 课时2：计算机与网络基础 2.1 知识点汇总 2.1.1操作系统（加粗为重点） 进程与线程 区别联系：进程是资源分配的最小单位，线程是程序执行的最小单位；进程使用独立的数据空间，线程共享进程的数据空间 线程调度：时间片轮转调度、先来先服务调度、优先级调度、多级反馈队列调度、高响应比优先调度 线程切换步骤：线程的上下文切换、线程切换的代价 Linux下的IPC（进程间通讯） Pipe MessageQueue 共享内存 UnixSocket Signal Semaphore 协程 Linux常用命令 awk top netstat grep less tail 死锁 内存分页管理于Swap 任务队列于CPU Load 扩展知识点 内存屏障 指令乱序 分支预测 CPU亲和性（affinity） Netfilter于iptables 2.1.2 网络知识（加粗为重点） 4/7层网络模型 TCP协议 建立链接三次握手 关闭链接四次握手 报文状态标志与链接状态 Nagel算法与ACK延迟 Keepalive 滑动窗口与流量控制 UDP 非链接 非可靠传输 效率高 HTTP 协议 Method Header Cookie UrlEncode 状态码 HTTPS HTTP2 多路复用 Stream 流量控制 服务端推送 头部压缩 QUIC（基于UDP，但是提供了基于UDP的可靠性保障） 避免前序抱阻塞（HOL阻塞） 零RTT建联 FEC前向纠错 2.2 TCP详解 TCP特点 基于链接（点对点） 双工通信 可靠传输 拥塞控制 基于字节流而非报文（保证数据的可靠性和完整性） TCP实现细节 8种报文状态 滑动窗口机制 KeepAlive Bagel算法 2.3 设计模式详解 主要考察两点 设计模式的实现 设计模式的使用场景（用来解决什么问题） 单例模式 工厂模式 代理模式 构造者模式 责任链模式 适配器模式 观察者模式 其他模式 2.3.1 单例模式线程安全实现 静态初始化（饿汉式） 双重检查（懒汉式） 单例注册表 2.3.2 常用设计模式与应用场景 工厂模式：Spring如何创建Bean 代理模式：Motan服务的动态代理 责任链模式：Netty消息处理的方式 适配器模式：Slf4J如何支持Log4J 观察者模式：GRPC是如何支持流式请求的 构造者模式：PB序列化中的Builder 2.4 Java基础知识详解 JUC ConcurrentXXX AtomicXXX Executor Caller&amp;Future Queue Locks 版本差异新特性 动态代理与反射 数据类型 空间占用 基本数据结构 自动转型与强制转型 封箱与拆箱 常用集合 HashMap ConcurrentHashMap ArrayList&amp;LinkedList HashSet TreeMap 对象引用 强引用 弱引用 软引用 虚引用 异常机制 扩展知识点 SPI机制 注解处理机制 2.4.1 Map——知识点详解 HashMap 数组加链表的实现方式 容量大小是2的幂次方 并发读写会有什么风险 ConcurrentHashMap 并发控制与分段锁思想 1.8中的CAS自旋锁 红黑树的启用条件 2.4.1 Java版本特性 V 1.8 Lambda表达式 Stream API 方法引用 接口默认方法 Metaspace替换PermGen V 1.9-1.10 模块系统 默认G1回收器 接口私有方法 局部变量推断 Graal编译器 V 1.11 ZGC 字符串API增强 内建HTTP Client 2.5 考察点和加分项 面试考察点 基本概念和基本原理 实现方式与使用姿势 经常用到的知识点 实际应用中容易犯错的点 与面试方向相关的知识点 加分项 知识点与典型的业务场景关联 以反例来描述实际场景中误用的危害 与知识点相关的优化点（例如在介绍TCP的建联与断连时最好能够指出，出现timewait时可以调整系统参数加快链接的回收与复用） 与知识点相关的最新技术趋势 在了解的前提下，尽量增加回答内容深度 2.6 真题 真题汇总——1 线程与进程的区别与联系 从资源的占用，切换效率，通信方式回答 简单介绍一下进程的切换过程 主要考察线程上下文的切换代价，要回答切换会保持寄存器、栈等线程相关的现场，需要由用户态切换到内核态，最后知道可以通过vmstate命令查看上下文的切换状况 你经常使用哪些Linux命令，主要用来解决什么问题？ 为什么TCP建联需要3次握手而断连需要4次 为什么TCP关闭链接时需要TIME_WAIT状态，为什么要等2MSL？ 一次完整的HTTP请求过程是怎样的 DNS解析、TCP建联、HTTP请求、HTTP相应 真题汇总——2 HTTP2与HTTP的区别有哪些？ 在你的项目中你使用过哪些设计模式？主要用来解决什么问题？ Object中的equal和hashCode的作用分别是什么？ final、finally、finalize的区别与使用场景 简单描述一下java的异常机制 线上使用的哪个版本jdk，为什么使用这个版本（有什么特点）？ 课时3：深入浅出JVM 3.1 知识点汇总 内存模型 程序计数器 方法区 堆 栈 本地方法栈 类加载器 双亲委派机制 Boostrap类加载器 Extension类加载器 System类加载器 自定义类加载器 GC 分代回收 老年代 年轻代 持久代 回收器实现 穿行回收器 并行回收器 CMS G1 性能调优 JVM参数 性能分析工具 MAT JMC JStack JStat 执行模式 解释模式 编译模式 混合模式 编译器优化 公共子表达式的消除 指令重排 内联 逃逸分析 方法逃逸 线程逃逸 栈上分配 同步消除 3.2 JVM的内存模型 3.2.1 JVM内存模型 线程独占 栈（存储局部变量表、操作栈、动态链接、方法出口等信息） 本地方法栈（native方法） 程序计数器 线程共享 堆（堆所有线程共享，分代管理） 方法区（类信息、常量、静态变量，jdk1.7中的永久代和jdk1.8中的metaspace都是方法区的一种实现） 面试回答要点： 各部分功能 哪些是线程共享，哪些是线程独占 3.2.2 JMM与内存可见性 Java内存模型，定义程序中变量的访问规则。 在多线程进行数据交互时，例如线程A给一个共享变量赋值后由线程B来读取这个值，线程A修改变量只修改在自己的工作内存区中，线程B是不可见的，只有从A的工作内存区写回到工作主内存，B在从主内存读取到自己的工作内存区才能进行进一步的操作。 由于指令重排序的存在，写和读的顺序可能会被打乱，因此JMM需要提供原子性、可见性、有序性的保证。 3.3 Java类加载机制详解 3.3.1 类的生命周期 加载：是文件到内存的过程，通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个Class对象； 验证：验证是堆文件类内容验证，目的在于当前类文件是否符合虚拟机的要求，不会危害到虚拟机安全，主要包括四种：文件格式验证、元数据验证、字节码、符号引用； 准备：准备阶段是进行内存分配，为类变量，也就是类中由static修饰的变量分配内存并设置初始值，初始值是0或null，而不是代码中设置的具体值，代码中设置的值在初始化阶段完成，另外也不包括final修饰的静态变量，因为final变量在编译时就已经分配； 解析：解析主要是解析字段、接口、方法，主要是将常量值中的符号引用替换为直接引用的过程，直接引用就是直接指向目标的指针或相对偏移量等； 初始化：最后是初始化，主要是完成静态块执行与静态变量的赋值，这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。 只有对类使用是才会初始化，初始化的条件包括访问类的实例，访问类的静态方法和静态变量的时候，使用Class.forName()反射类的时候，或者某个子类被初始化的时候。 3.3.2 类加载器 BootStrap ClassLoader：启动类加载器加载JAVA_HOME/lib下的类 ExtClassLoader：扩展加载器加载JAVA_HOME/lib/ext下的类 AppClassLoader：应用加载器加载加载classpath指定目录下的类 除此之外，还可以自定义类加载器。 Java的类加载器使用双亲委派模式，双亲委派模型的工作过程是： 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。 每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。 只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。 很多人对“双亲”一词很困惑。这是翻译的锅，，，“双亲”只是“parents”的直译，实际上并不表示汉语中的父母双亲，而是一代一代很多parent，即parents。 双亲委派模式优势： 采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。 3.4 常用GC算法介绍 3.4.1 分代回收 分代管理主要是为了方便垃圾回收，这样做是基于两个事实： 大部分对象很快都不在使用 还有一部分不会立即无用，但也不会持续很长时间 大部分对象在Eden区中生成，Eden区满时，还存活的对象会在两个Suivivor区交替保存，达到一定次数后对象会晋升为老年代。 老年代用来存放从年轻代晋升而来的存活时间较长的对象。 永久代主要用来保存类信息等内容。 3.4.2 垃圾回收算法 着色指针 读屏障 并发处理 基于Region 内存压缩（整理） 3.5 考察点和加分项 考察点 深入理解JVM内存模型 了解类加载机制 了解内存可见性 了解常用的GC算法实现和使用场景 能够根据业务场景选择合适JVM参数与GC算法 加分项 编译器优化 问题排查经验与思路 JVM调优经验与调优思路 了解最新的技术趋势（例如：ZGC、Grraalvm） 3.6 真题 简述描述一下JVM的内存模型 生命情况下会触发FullGC Java类加载器由几种，关系是怎样的？ 双亲委派机制的加载流程是怎样的，有什么好处？ 1.8为什么用Metaspace替换掉PermGen？Metasapce保存在哪里？ 编译期会对指令做哪些优化？（简单描述编译器的指令重排） 简单描述一下volatile可以解决什么问题？如何做到的？ 强制主内存读写同步以及防止指令重排序两点 简单描述一下GC的分代回收 G1垃圾回收算法与CMS的区别有哪些？ 对象引用有哪几种方式，有什么特点？ 强弱软虚在四种引用以及在GC中的处理方式 使用过哪些JVM调试工具，主要分析哪些内容？ 课时4：并发与多线程 4.1 知识点汇总 死锁 竞争条件与临界区 死锁检测与防止死锁 残剩条件 互斥 请求并保持 不可剥夺 循环等待 线程通信 wait notify notifyAll 线程状态转换 NEW RUNNABLE BLOCKED WAITING TIMED_WAITING TERMINATED 常用工具类（JUC） ConcurrentXXX AtomicXXX Executor Caller&amp;Future Queue Locks 机制 ThreadLocal Fork/Join Volatile Interrupt 同步与互斥 Synchronized Lock 锁类型 锁实现 CAS Unsafe 原语 线程池 使用场景 原理与实现方式 线程池实现 4.2 线程池详解 线程池参数介绍 核心线程数，默认情况下，核心线程会一直存活 最大线程数，决定线程池最多可以创建多少线程 线程的空闲时间，空闲时间的单位，当线程闲置超过空闲时间时就会被销毁 线程缓存队列 有界队列 无界队列 同步队列 线程池工厂方法 线程池满时拒绝策略 抛出异常 丢弃 提交失败时，由提交任务的线程直接执行任务 丢弃最早提交的任务 4.3 JUC重点工具实现类 4.4 考察点和加分项 考察点 理解线程的同步与互斥的原理（临界资源、理解区、自旋锁、偏向锁 、冲入锁、读写锁概念） 掌握线程安全相关机制（CAS、Synchronized、ThreadLocal使用弱引用ThreadLocalMap） 了解JUC工具的使用场景与实现原理 熟悉线程池的原理、使用场景、常用配置 理解线程的同步与异步、阻塞与非阻塞（同步与异步的区别是任务是否在同一个线程中执行的 ，阻塞与非阻塞的区别是异步执行任务时线程是不是会阻塞等待结构还是会继续等待后面的逻辑） 加分项 结合实际项目经验或实际案例介绍原理 解决多线程问题的排查思路与经验 熟悉常用的线程分析工具与方法 了解Java8堆JUC的增强 了解Reactive异步编程思想 4.5 真题 如何实现一个生产者与消费者模型？（锁、信号量、线程通信、阻塞队列等） 如何理解线程的同步与异步、阻塞与非阻塞？ 线程池处理任务的流程是怎样的？ wait与sleep的由什么不同？ wait属于Object类，sleep属于Thread类； wait会释放对象锁，而sleep不会； wait需要在同步块中使用，sleep可以在任何地方使用； sleep需要捕获异常、wait不需要。 Synchronized和ReentranLock有什么不同？ 读写锁适用于什么场景？ReentrantReadWriteLock是如何实现的？ 读写锁适合读并发多，写并发少的场景 线程之间如何通信？ wait和notify机制、共享变量Synchronized 保证线程安全的方法由哪些？ CAS、Synchronized、Lock、ThreadLocal 如何尽可能提高多线程并发性能？ 尽量减少临界区范围、使用ThreadLocal、减少线程切换、使用读写锁或CopyOnWrite机制 ThreadLocal用来解决什么问题？ThreadLocal是如何实现的？ 重点回答ThreadLocak不是用来解决多线程共享变量的问题，而是线程数据隔离的问题 死锁产生的条件？如何分析是否由线程死锁？ 在实际工作中遇到过什么样的并发问题，如何发现（排查）并解决的？ 课时5：数据结构与算法 5.1 知识点汇总 5.1.1 数据结构 队列 栈 表 数组 单链表 双链表 循环链表 散列表 图 有向图 无向图 带权图 多叉树 B、B+树 字典树 二叉树 平衡二叉树 红黑树 哈夫曼树 堆 5.1.2 算法 常用算法思路 分治 动态规划 贪心 回溯 分支界定 复杂度 时间复杂度 空间复杂度 排序 插入 希尔 直插 交换 冒泡 快排 选择 简单选择 堆 归并 基数 查找 二分查找 二叉排序树 B树 BloomFilter 字符串匹配 BF算法 BM算法 Sundady算法 KMP算法 Tire树 5.2 字符串匹配 字符串匹配问题 判断给定字符串中的括号是否匹配 解体思路： 使用栈 遇左括号入栈 遇右括号出栈，判断出栈括号是否与右括号成对 5.3 考察点和加分项 考察点 了解基本数据结构与特点 表、栈、队列、树需要熟练掌握，深刻理解使用场景（例如红黑树适合搜索，B+树适合索引） 了解常用的搜索、排序算法，及复杂度和稳定性 了解常用的字符串处理算法 能够分析算法实现的复杂度 了解常用算法分类，解决问题的思路和解决哪类问题 加分项 能够将数据结构与实际使用场景结合（介绍红黑树时结合TreeMap的实现，介绍B+树时结合MySQL的索引） 不同算法在业务场景中的应用 面对模糊的题目能沟通确认条件和边界 书写算法代码前，先讲一下解题思路 能够发现解答中的一些问题，给出改进的思路 5.4 真题 题1、题2基础题，必须掌握 各种排序算法实现和复杂度、稳定性 二叉树的前、中、后序遍历 翻转句子中单词的顺序 用栈模拟队列（或用队列模拟栈） 堆10亿个数进行排序，限制内存位1G 去掉（或找出）两个数组中重复的数字 将一颗二叉树转换成其镜像 确定一个字符串中的括号是否匹配 给定一个开始词，一个结束词，一个字典，如何找到从开始词到结束词的最短单词接龙路径 如何查找两个二叉树节点的最近公共祖先 课时6：常用工具集 6.1 知识点汇总 团队协作 Ant Maven Gradle Git SVN 质量保证 Checkstyle FindBugs SonarQube 压测 JMeter JMH AB LoadRunner 容器与代理（随着微服务的盛行，Envoy、OpenResty、Kong等API网关的使用也越来越普遍） Tomcat Jetty Nginx Envoy OpenResty Kong CI/CD Gitlab-CI Jenkins Travis JVM相关 JMC（JFR） jstack、jmap、jstat 系统分析 vmstat iostat &amp; iotop ifstat &amp; iftop netstat dstat strace GDB lsof tcpdump traceroute 文档管理 JavaDoc Swagger 网络工具 PostMan WireShark（网络包分析工具） Fiddler（只针对HTTP进行抓捕） Charies 6.2 考察点和加分项 考察点 了解常用JVM分析工具 掌握Git的常用操作和工作流 了解Linux系统下常用的分析工具 加分项 能够主动出击体现知识广度（在描述项目问题主动引出工具） 能够体现实战能力 6.6 真题 排查JVM问题有哪些常用工具？ Git合并代码有那两种方法？有什么区别 Git与SVN有哪些差异？ 你所在的团队项目开发使用什么样工作流？有什么优点？ 课时7：必会框架（上）——Spring全家桶 7.1 知识点汇总 Spring Spring Framework Spring Boot Spring Data Spring Cloud Sleuth Netflix Config Bus Security Struts ORM Hibernate Mybatis Netty RPC Motan Bubbo Grpc 其他框架 Jersey RESTEasy Shiro 7.2 Spring框架 机制与实现 AOP 动态代理 静态代理 PlaceHolder动态替换 PropertyPlaceholderConfigure PropertySourcesPlaceholderConfigure 事务 隔离级别 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE 传播行为 PROPAGATION_REQUIRED PROPAGATION_SUPPORTS PROPAGATION_MANDATORY PROPAGATION_REQUIRED_NEW PROPAGATION_NOT_SUPPORTED PROPAGATION_NEVER PROPAGATION_NESTED 核心接口/类 ApplicationContext BeanFactory BeanWrapper FactoryBean scope Singleton Prototype Request Session Global-session Application Websocket 事件机制 ContextRefreshedEvent ContextStatedEvent ContextStoppedEvent ContextClosedEvent RequestHandledEvent Spring应用 类型类 @Controller @service @Repository @Component @Configuration @Bean 设置类 @Required @Autowired &amp;&amp; @Qualifier @Scope Web类 @RequestMapping &amp;&amp; @GetMapping @ PostMapping @PathVariable &amp;&amp; @RequestParam @RequestBody &amp;&amp; @ResponseBody 功能类 @ImportResource @ComponentScan @EnableCaching &amp;&amp; Cacheable @Transactional @Aspect &amp;&amp; Poincut @Scheduled 配置方式 XML 注解 API 自动装配 byType byName constructor autodetect 课时8：必会框架（下）——RPC与ORM 8.1 考察点与加分项 考察点 掌握Spring的IOC、AOP的概念与实现 掌握Spring的Context创建流程和Bean的生命周期 了解Spring常用注解的作用与使用方式 了解SpringBoot的相关知识点 掌握Netty的线程处理模型 知道常用RPC框架的特点 了解Mybatis、Hibernate的实现原理 加分项 阅读过框架源码，了解实现细节及思路 除了会应用，还能够理解理念 了解最新实现或方向 有实际优化经验，例如Nett有性能调优 8.2 真题 SSH和SSM框架组合的区别是生命？ 能描述一些Spring Context初始化的整个流程吗？ 简单介绍一些Bean的生命周期及作用域 Spring配置中的placeholder占位符是如何替换的？有什么办法可以实现自定义的配置替换？ 要答出通过beanFactoryPostProfessal后置处理器进行的替换，如果要自定义处理，可以扩展PropertyPlaceHolderConfigure或者PropertySourcePlaceHolderConfigure来实现 SpringMVC的工作流程是怎样的？ Spring如何解决循环依赖？ 从构造器循环依赖和setter循环依赖两方面来回答 Bean的构造方法、@PostConstruct注解、InitializingBean、init-method的执行顺序是怎样的？ 说说Netty中有哪些重要的对象，它们之间的关系是什么？ RPC与HTTP的区别是什么，什么场景适合选用RPC，什么场景适合使用HTTP？ 在使用方式方面，HTTP使用Client，RPC通过动态代理；从请求模型看，HTTP一般会经过DNS解析，4/7层代理等中间环节，而RPC是点对点直连；从服务治理能力来看，RPC提供丰富的服务治理功能，例如熔断 、负载均衡，HTTP对跨语言处理比较方便 RPC的交互流程是怎样的？ 请介绍一下Mybatis的缓存机制 Mybatis如何配置动态SQL？有哪些动态SQL标签？ 课时9：缓存 9.1 考察点和加分项 考察点 了解缓存的使用场景，不同类型缓存的使用方式 掌握MC和Redis的常用命令 了解MC的Redis在内存中的存储结构 了解MC和Redis的数据失效方式和剔除策略 了解Redis的持久化、主从同步与cluster部署的原理 加分项 结合使用场景来介绍缓存的使用 有过分布式缓存设计和应用经验 了解缓存使用中可能产生的问题 知道Redis的典型应用场景 知道Redis的新特性 9.2 真题 Redis和Memcache有什么区别？该如何选用 你用到过哪些Redis的数据结构？用在什么场景下？ Redis有哪些持久化方式，分别是什么？ Redis的过期机制是怎样的？Redis有哪些淘汰策略 如何保证Redis的高并发和高可用？ 如何使用Redis实现延时队列？如何使用Redis实现分布式锁？ 读者福利： 分享免费学习资料 针对于Java程序员，我这边准备免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料） 为什么某些人会一直比你优秀，是因为他本身就很优秀还一直在持续努力变得更优秀，而你是不是还在满足于现状内心在窃喜！希望读到这的您能点个小赞和关注下我，以后还会更新技术干货，谢谢您的支持！ 资料领取方式：加入Java技术交流群963944895，点击加入群聊，私信管理员即可免费领取 //点关注，不迷路；持续更新Java架构相关技术及资讯！！！","@type":"BlogPosting","url":"https://mlh.app/2019/05/17/787094.html","headline":"Java面试 32个核心必考点完全解析","dateModified":"2019-05-17T00:00:00+08:00","datePublished":"2019-05-17T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/05/17/787094.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Java面试 32个核心必考点完全解析</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-light"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> 
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path> 
  </svg> 
  <blockquote> 
   <p><strong>//点关注，不迷路；持续更新Java架构相关技术及资讯！！！</strong></p> 
  </blockquote> 
  <h1><a id="_3"></a>课程预习</h1> 
  <h2><a id="_5"></a>课程内容分为三个模块</h2> 
  <p><strong>基础模块</strong>：</p> 
  <ul> 
   <li>技术岗位与面试</li> 
   <li>计算机基础</li> 
   <li>JVM原理</li> 
   <li>多线程</li> 
   <li>设计模式</li> 
   <li>数据结构与算法</li> 
  </ul> 
  <p><strong>应用模块</strong>：</p> 
  <ul> 
   <li>常用工具集</li> 
   <li>常用框架</li> 
   <li>缓存</li> 
   <li>队列</li> 
   <li>数据库</li> 
  </ul> 
  <p><strong>综合模块</strong>：</p> 
  <ul> 
   <li>系统架构设计</li> 
   <li>微服务架构</li> 
   <li>容器化</li> 
  </ul> 
  <h2><a id="_30"></a>换工作面临问题</h2> 
  <p><strong>能力不错，却总被忽略</strong></p> 
  <ul> 
   <li>不知道简历怎么准备 
    <ul> 
     <li>工作年限</li> 
     <li>美观度</li> 
     <li>多分简历</li> 
    </ul> </li> 
   <li>不知道面试官考什么 
    <ul> 
     <li>社交门户侧重于大规模并发场景的应用和架构能力</li> 
     <li>OTO行业侧重于综合能力考察</li> 
     <li>金融更喜欢逻辑缜密，对高可用安全领域有经验的候选人</li> 
     <li>校招更多对基础知识和逻辑思维方面的考察，以培养潜力考察为主</li> 
     <li>初中级工程师则需要多关注知识的广度，基础知识的应用</li> 
     <li>高级资深工程师需要深入理解基本原理，以综合能力考察为主</li> 
     <li>没有get到面试官的考察意图。如：问到是否使用某框架，实际是是问该框架的使用场景，有什么特点，和同类可框架对比一系列的问题。</li> 
    </ul> </li> 
   <li>不知道如何提升晋级？ 
    <ul> 
     <li>学习首先有个框架</li> 
    </ul> </li> 
  </ul> 
  <h2><a id="_49"></a>课程特色</h2> 
  <ul> 
   <li>全盘汇总：Java知识体现精细梳理</li> 
   <li>特近实战：面试官亲自教你拿Offer</li> 
   <li>潜规则：揭秘技术面试加分&amp;潜规则</li> 
   <li>权威性：拉勾40W技术岗位大数据支持</li> 
  </ul> 
  <h1><a id="1_56"></a>课时1：技术人职业发展路径</h1> 
  <h2><a id="11__58"></a>1.1 工程师发展路径</h2> 
  <p><strong>技术序列</strong>：技术攻坚、架构知识、专业知识</p> 
  <ul> 
   <li>工程师</li> 
   <li>高级工程师</li> 
   <li>资深工程师</li> 
   <li>技术专家</li> 
   <li>高级技术专家</li> 
  </ul> 
  <p>1~3年内从工程师到高级工程师发展，夯实基础，重点提高工作基础能力，培养技术的深度和广度，对不同方向的新技术保持强烈的好奇心和学习心</p> 
  <p>3年以上资深工程师需要重点配音技术攻坚能力，疑难问题的排查，大型项目的工程拆分，技术品牌的塑造。具体工作包括，原理实现，注重框架能力的培养，大规模高并发场景，高可用可扩展措施和方案，业务的抽象和架构能力</p> 
  <p><strong>管理序列</strong>：团队管理、项目管理、沟通协作</p> 
  <ul> 
   <li>工程师</li> 
   <li>高级工程师</li> 
   <li>技术经理</li> 
   <li>技术总监</li> 
   <li>高级技术总监</li> 
  </ul> 
  <p>偏向于团队把控，需要让团队形成技术战斗力，利用一切资源让团队完成作战目标，做好团队内和跨团队沟通工作，在实际工作中这两种并没有明显的边界，例如做管理不表示远离架构设计，技术专家也不是单兵作战。这两个方向的区分点在于工作方向的侧重点不同。</p> 
  <p>面试诀窍示例：同过往的经验来看，我对项目的整体规划、管理、推进比较感兴趣，在任务协调沟通方面也有过比较突出的表现，所以我的职业规划是成为一名职业的技术经理，以管理方向为发展目标。</p> 
  <h2><a id="12__84"></a>1.2 常见技术岗位划分</h2> 
  <p><img src="https://upload-images.jianshu.io/upload_images/15517885-f6c1365162e28823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> 
  <h2><a id="13__88"></a>1.3 面试岗位选择</h2> 
  <p><strong>公司&amp;团队</strong></p> 
  <ul> 
   <li>大公司核心业务（首选）</li> 
   <li>小公司核心业务（1~3年）</li> 
   <li>大公司边缘业务（镀金）</li> 
   <li>小公司边缘业务（尽量不选）</li> 
  </ul> 
  <p><strong>岗位匹配度</strong></p> 
  <p>匹配度与发展方向相吻合</p> 
  <h2><a id="14__101"></a>1.4 常见面试流程</h2> 
  <ul> 
   <li>前置面试 
    <ul> 
     <li>电话面试</li> 
     <li>笔试</li> 
     <li>上机编程</li> 
    </ul> </li> 
   <li>技术一面 
    <ul> 
     <li>纯技术面（首选算法，例如排序、）</li> 
     <li>偏重于基础与实战能力</li> 
     <li>面试官是未来的同组同事</li> 
    </ul> </li> 
   <li>技术二面 
    <ul> 
     <li>纯技术面（项目能力、架构能力）</li> 
     <li>偏重算法、技术深度</li> 
     <li>面试官是未来直属leader</li> 
    </ul> </li> 
   <li>技术三面 
    <ul> 
     <li>半技术面（架构能力、技术敏感度、职业规划）</li> 
     <li>架构能力与发展潜力</li> 
     <li>面试官是部门技术leader</li> 
    </ul> </li> 
   <li>HR面 
    <ul> 
     <li>非技术面</li> 
     <li>个人发展规划</li> 
     <li>价值观与薪资</li> 
    </ul> </li> 
   <li>各级领导 
    <ul> 
     <li>一般非技术面</li> 
     <li>没有原则性问题能都通过</li> 
    </ul> </li> 
  </ul> 
  <h2><a id="15__127"></a>1.5 面试前的准备工作</h2> 
  <p><strong>能力、心态、沟通</strong></p> 
  <ul> 
   <li>了解应试公司及岗位信息</li> 
   <li>系统复习基础知识</li> 
   <li>对原公司负责的项目进行梳理总结</li> 
   <li>学习典型架构案例</li> 
   <li>阅读常考考点源码</li> 
   <li>针对性准备加分项</li> 
  </ul> 
  <p>提前准备一份自我介绍，自己的技术特长和职业优势</p> 
  <p>避免冷场，对于回答不上来的问题，提供解题思路，或者询问面试官是否可以换一个问题</p> 
  <p>注意细节，坐姿、表情、观察面试官反应</p> 
  <h2><a id="16__144"></a>1.6 面试考察点</h2> 
  <p><strong>硬技能</strong></p> 
  <ul> 
   <li>基础知识</li> 
   <li>项目经验</li> 
   <li>架构能力</li> 
   <li>应用能力</li> 
  </ul> 
  <p><strong>软实力</strong></p> 
  <ul> 
   <li>逻辑思维</li> 
   <li>沟通协作</li> 
   <li>管理推进</li> 
   <li>学习思考</li> 
   <li>培养潜力</li> 
  </ul> 
  <h2><a id="17__161"></a>1.7 四类硬技能</h2> 
  <p><strong>基础知识</strong></p> 
  <ul> 
   <li>计算机基础 
    <ul> 
     <li>网络</li> 
     <li>操作系统</li> 
     <li>数据结构</li> 
     <li>算法</li> 
    </ul> </li> 
   <li>Java 
    <ul> 
     <li>JVM</li> 
     <li>语言特性</li> 
     <li>多线程</li> 
    </ul> </li> 
  </ul> 
  <p><strong>项目经验</strong></p> 
  <ul> 
   <li>项目描述</li> 
   <li>项目难点</li> 
   <li>项目问题</li> 
   <li>项目改进</li> 
  </ul> 
  <p><strong>应用知识</strong></p> 
  <ul> 
   <li>常用工具 
    <ul> 
     <li>排查类</li> 
     <li>协作类</li> 
     <li>保障类</li> 
     <li>系统类</li> 
    </ul> </li> 
   <li>常用框架 
    <ul> 
     <li>Spring</li> 
     <li>Netty</li> 
     <li>Dubbo</li> 
     <li>Motan</li> 
     <li>Mybatis</li> 
    </ul> </li> 
   <li>队列</li> 
   <li>数据库</li> 
   <li>缓存</li> 
  </ul> 
  <p><strong>架构能力</strong></p> 
  <p><strong>微服务架构</strong></p> 
  <ul> 
   <li>Docker</li> 
   <li>ZK</li> 
   <li>SC</li> 
   <li>KBs</li> 
  </ul> 
  <h1><a id="2_208"></a>课时2：计算机与网络基础</h1> 
  <h2><a id="21__210"></a>2.1 知识点汇总</h2> 
  <h3><a id="211_212"></a>2.1.1操作系统（加粗为重点）</h3> 
  <p><strong>进程与线程</strong></p> 
  <ul> 
   <li>区别联系：进程是资源分配的最小单位，线程是程序执行的最小单位；进程使用独立的数据空间，线程共享进程的数据空间</li> 
   <li>线程调度：时间片轮转调度、先来先服务调度、优先级调度、多级反馈队列调度、高响应比优先调度</li> 
   <li>线程切换步骤：线程的上下文切换、线程切换的代价</li> 
   <li>Linux下的IPC（进程间通讯） 
    <ul> 
     <li>Pipe</li> 
     <li>MessageQueue</li> 
     <li>共享内存</li> 
     <li>UnixSocket</li> 
     <li>Signal</li> 
     <li>Semaphore</li> 
    </ul> </li> 
   <li>协程</li> 
  </ul> 
  <p><strong>Linux常用命令</strong></p> 
  <ul> 
   <li>awk</li> 
   <li>top</li> 
   <li>netstat</li> 
   <li>grep</li> 
   <li>less</li> 
   <li>tail</li> 
  </ul> 
  <p><strong>死锁</strong></p> 
  <p><strong>内存分页管理于Swap</strong></p> 
  <p><strong>任务队列于CPU Load</strong></p> 
  <p><strong>扩展知识点</strong></p> 
  <ul> 
   <li>内存屏障</li> 
   <li>指令乱序</li> 
   <li>分支预测</li> 
   <li>CPU亲和性（affinity）</li> 
   <li>Netfilter于iptables</li> 
  </ul> 
  <h3><a id="212__251"></a>2.1.2 网络知识（加粗为重点）</h3> 
  <p><strong>4/7层网络模型</strong></p> 
  <p><strong>TCP协议</strong></p> 
  <ul> 
   <li>建立链接三次握手</li> 
   <li>关闭链接四次握手</li> 
   <li>报文状态标志与链接状态</li> 
   <li>Nagel算法与ACK延迟</li> 
   <li>Keepalive</li> 
   <li>滑动窗口与流量控制</li> 
  </ul> 
  <p><strong>UDP</strong></p> 
  <ul> 
   <li>非链接</li> 
   <li>非可靠传输</li> 
   <li>效率高</li> 
  </ul> 
  <p><strong>HTTP</strong></p> 
  <ul> 
   <li>协议 
    <ul> 
     <li>Method</li> 
     <li>Header</li> 
     <li>Cookie</li> 
    </ul> </li> 
   <li>UrlEncode</li> 
   <li>状态码</li> 
   <li>HTTPS</li> 
   <li>HTTP2</li> 
   <li>多路复用</li> 
   <li>Stream</li> 
   <li>流量控制</li> 
   <li>服务端推送</li> 
   <li>头部压缩</li> 
  </ul> 
  <p><strong>QUIC（基于UDP，但是提供了基于UDP的可靠性保障）</strong></p> 
  <ul> 
   <li>避免前序抱阻塞（HOL阻塞）</li> 
   <li>零RTT建联</li> 
   <li>FEC前向纠错</li> 
  </ul> 
  <h2><a id="22_TCP_292"></a>2.2 TCP详解</h2> 
  <p><strong>TCP特点</strong></p> 
  <ul> 
   <li>基于链接（点对点）</li> 
   <li>双工通信</li> 
   <li>可靠传输</li> 
   <li>拥塞控制</li> 
   <li>基于字节流而非报文（保证数据的可靠性和完整性）</li> 
  </ul> 
  <p><strong>TCP实现细节</strong></p> 
  <ul> 
   <li>8种报文状态</li> 
   <li>滑动窗口机制</li> 
   <li>KeepAlive</li> 
   <li>Bagel算法</li> 
  </ul> 
  <h2><a id="23__309"></a>2.3 设计模式详解</h2> 
  <p><strong>主要考察两点</strong></p> 
  <ul> 
   <li> <p>设计模式的实现</p> </li> 
   <li> <p>设计模式的使用场景（用来解决什么问题）</p> 
    <ul> 
     <li>单例模式</li> 
     <li>工厂模式</li> 
     <li>代理模式</li> 
     <li>构造者模式</li> 
     <li>责任链模式</li> 
     <li>适配器模式</li> 
     <li>观察者模式</li> 
     <li>其他模式</li> 
    </ul> </li> 
  </ul> 
  <h3><a id="231__325"></a>2.3.1 单例模式线程安全实现</h3> 
  <ul> 
   <li>静态初始化（饿汉式）</li> 
   <li>双重检查（懒汉式）</li> 
   <li>单例注册表</li> 
  </ul> 
  <h3><a id="232__331"></a>2.3.2 常用设计模式与应用场景</h3> 
  <ul> 
   <li>工厂模式：Spring如何创建Bean</li> 
   <li>代理模式：Motan服务的动态代理</li> 
   <li>责任链模式：Netty消息处理的方式</li> 
   <li>适配器模式：Slf4J如何支持Log4J</li> 
   <li>观察者模式：GRPC是如何支持流式请求的</li> 
   <li>构造者模式：PB序列化中的Builder</li> 
  </ul> 
  <h2><a id="24_Java_340"></a>2.4 Java基础知识详解</h2> 
  <p><strong>JUC</strong></p> 
  <ul> 
   <li>ConcurrentXXX</li> 
   <li>AtomicXXX</li> 
   <li>Executor</li> 
   <li>Caller&amp;Future</li> 
   <li>Queue</li> 
   <li>Locks</li> 
  </ul> 
  <p><strong>版本差异新特性</strong><br> <strong>动态代理与反射</strong><br> <strong>数据类型</strong></p> 
  <ul> 
   <li>空间占用</li> 
   <li>基本数据结构</li> 
   <li>自动转型与强制转型</li> 
   <li>封箱与拆箱</li> 
  </ul> 
  <p><strong>常用集合</strong></p> 
  <ul> 
   <li>HashMap</li> 
   <li>ConcurrentHashMap</li> 
   <li>ArrayList&amp;LinkedList</li> 
   <li>HashSet</li> 
   <li>TreeMap</li> 
  </ul> 
  <p><strong>对象引用</strong></p> 
  <ul> 
   <li>强引用</li> 
   <li>弱引用</li> 
   <li>软引用</li> 
   <li>虚引用</li> 
  </ul> 
  <p><strong>异常机制</strong><br> <strong>扩展知识点</strong></p> 
  <ul> 
   <li>SPI机制</li> 
   <li>注解处理机制</li> 
  </ul> 
  <h3><a id="241_Map_381"></a>2.4.1 Map——知识点详解</h3> 
  <p><strong>HashMap</strong></p> 
  <ul> 
   <li>数组加链表的实现方式</li> 
   <li>容量大小是2的幂次方</li> 
   <li>并发读写会有什么风险</li> 
  </ul> 
  <p><strong>ConcurrentHashMap</strong></p> 
  <ul> 
   <li>并发控制与分段锁思想</li> 
   <li>1.8中的CAS自旋锁</li> 
   <li>红黑树的启用条件</li> 
  </ul> 
  <h3><a id="241_Java_395"></a>2.4.1 Java版本特性</h3> 
  <p><strong>V 1.8</strong></p> 
  <ul> 
   <li>Lambda表达式</li> 
   <li>Stream API</li> 
   <li>方法引用</li> 
   <li>接口默认方法</li> 
   <li>Metaspace替换PermGen</li> 
  </ul> 
  <p><strong>V 1.9-1.10</strong></p> 
  <ul> 
   <li>模块系统</li> 
   <li>默认G1回收器</li> 
   <li>接口私有方法</li> 
   <li>局部变量推断</li> 
   <li>Graal编译器</li> 
  </ul> 
  <p><strong>V 1.11</strong></p> 
  <ul> 
   <li>ZGC</li> 
   <li>字符串API增强</li> 
   <li>内建HTTP Client</li> 
  </ul> 
  <h2><a id="25__419"></a>2.5 考察点和加分项</h2> 
  <p><strong>面试考察点</strong></p> 
  <ul> 
   <li>基本概念和基本原理</li> 
   <li>实现方式与使用姿势</li> 
   <li>经常用到的知识点</li> 
   <li>实际应用中容易犯错的点</li> 
   <li>与面试方向相关的知识点</li> 
  </ul> 
  <p><strong>加分项</strong></p> 
  <ul> 
   <li>知识点与典型的业务场景关联</li> 
   <li>以反例来描述实际场景中误用的危害</li> 
   <li>与知识点相关的优化点（例如在介绍TCP的建联与断连时最好能够指出，出现timewait时可以调整系统参数加快链接的回收与复用）</li> 
   <li>与知识点相关的最新技术趋势</li> 
   <li>在了解的前提下，尽量增加回答内容深度</li> 
  </ul> 
  <h2><a id="26__437"></a>2.6 真题</h2> 
  <p><strong>真题汇总——1</strong></p> 
  <ul> 
   <li>线程与进程的区别与联系</li> 
   <li>从资源的占用，切换效率，通信方式回答</li> 
   <li>简单介绍一下进程的切换过程</li> 
   <li>主要考察线程上下文的切换代价，要回答切换会保持寄存器、栈等线程相关的现场，需要由用户态切换到内核态，最后知道可以通过vmstate命令查看上下文的切换状况</li> 
   <li>你经常使用哪些Linux命令，主要用来解决什么问题？</li> 
   <li>为什么TCP建联需要3次握手而断连需要4次</li> 
   <li>为什么TCP关闭链接时需要TIME_WAIT状态，为什么要等2MSL？</li> 
   <li>一次完整的HTTP请求过程是怎样的</li> 
   <li>DNS解析、TCP建联、HTTP请求、HTTP相应</li> 
  </ul> 
  <p><strong>真题汇总——2</strong></p> 
  <ul> 
   <li>HTTP2与HTTP的区别有哪些？</li> 
   <li>在你的项目中你使用过哪些设计模式？主要用来解决什么问题？</li> 
   <li>Object中的equal和hashCode的作用分别是什么？</li> 
   <li>final、finally、finalize的区别与使用场景</li> 
   <li>简单描述一下java的异常机制</li> 
   <li>线上使用的哪个版本jdk，为什么使用这个版本（有什么特点）？</li> 
  </ul> 
  <h1><a id="3JVM_460"></a>课时3：深入浅出JVM</h1> 
  <h2><a id="31__462"></a>3.1 知识点汇总</h2> 
  <p><strong>内存模型</strong></p> 
  <ul> 
   <li>程序计数器</li> 
   <li>方法区</li> 
   <li>堆</li> 
   <li>栈</li> 
   <li>本地方法栈</li> 
  </ul> 
  <p><strong>类加载器</strong></p> 
  <ul> 
   <li>双亲委派机制</li> 
   <li>Boostrap类加载器</li> 
   <li>Extension类加载器</li> 
   <li>System类加载器</li> 
   <li>自定义类加载器</li> 
  </ul> 
  <p><strong>GC</strong></p> 
  <ul> 
   <li>分代回收 
    <ul> 
     <li>老年代</li> 
     <li>年轻代</li> 
     <li>持久代</li> 
    </ul> </li> 
   <li>回收器实现 
    <ul> 
     <li>穿行回收器</li> 
     <li>并行回收器</li> 
     <li>CMS</li> 
     <li>G1</li> 
    </ul> </li> 
  </ul> 
  <p><strong>性能调优</strong></p> 
  <ul> 
   <li>JVM参数</li> 
   <li>性能分析工具 
    <ul> 
     <li>MAT</li> 
     <li>JMC</li> 
     <li>JStack</li> 
     <li>JStat</li> 
    </ul> </li> 
  </ul> 
  <p><strong>执行模式</strong></p> 
  <ul> 
   <li>解释模式</li> 
   <li>编译模式</li> 
   <li>混合模式</li> 
  </ul> 
  <p><strong>编译器优化</strong></p> 
  <ul> 
   <li>公共子表达式的消除</li> 
   <li>指令重排</li> 
   <li>内联</li> 
   <li>逃逸分析</li> 
   <li>方法逃逸</li> 
   <li>线程逃逸</li> 
   <li>栈上分配</li> 
   <li>同步消除</li> 
  </ul> 
  <h2><a id="32_JVM_518"></a>3.2 JVM的内存模型</h2> 
  <h3><a id="321_JVM_520"></a>3.2.1 JVM内存模型</h3> 
  <p><strong>线程独占</strong></p> 
  <ul> 
   <li>栈（存储局部变量表、操作栈、动态链接、方法出口等信息）</li> 
   <li>本地方法栈（native方法）</li> 
   <li>程序计数器</li> 
  </ul> 
  <p><strong>线程共享</strong></p> 
  <ul> 
   <li>堆（堆所有线程共享，分代管理）</li> 
   <li>方法区（类信息、常量、静态变量，jdk1.7中的永久代和jdk1.8中的metaspace都是方法区的一种实现）</li> 
  </ul> 
  <p><strong>面试回答要点</strong>：</p> 
  <ul> 
   <li>各部分功能</li> 
   <li>哪些是线程共享，哪些是线程独占</li> 
  </ul> 
  <h3><a id="322_JMM_538"></a>3.2.2 JMM与内存可见性</h3> 
  <p>Java内存模型，定义程序中变量的访问规则。</p> 
  <p>在多线程进行数据交互时，例如线程A给一个共享变量赋值后由线程B来读取这个值，线程A修改变量只修改在自己的工作内存区中，线程B是不可见的，只有从A的工作内存区写回到工作主内存，B在从主内存读取到自己的工作内存区才能进行进一步的操作。</p> 
  <p>由于指令重排序的存在，写和读的顺序可能会被打乱，因此JMM需要提供原子性、可见性、有序性的保证。</p> 
  <h2><a id="33_Java_547"></a>3.3 Java类加载机制详解</h2> 
  <h3><a id="331__549"></a>3.3.1 类的生命周期</h3> 
  <p><strong>加载</strong>：是文件到内存的过程，通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个Class对象；</p> 
  <p><strong>验证</strong>：验证是堆文件类内容验证，目的在于当前类文件是否符合虚拟机的要求，不会危害到虚拟机安全，主要包括四种：文件格式验证、元数据验证、字节码、符号引用；</p> 
  <p><strong>准备</strong>：准备阶段是进行内存分配，为类变量，也就是类中由static修饰的变量分配内存并设置初始值，初始值是0或null，而不是代码中设置的具体值，代码中设置的值在初始化阶段完成，另外也不包括final修饰的静态变量，因为final变量在编译时就已经分配；</p> 
  <p><strong>解析</strong>：解析主要是解析字段、接口、方法，主要是将常量值中的符号引用替换为直接引用的过程，直接引用就是直接指向目标的指针或相对偏移量等；</p> 
  <p><strong>初始化</strong>：最后是初始化，主要是完成静态块执行与静态变量的赋值，这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。</p> 
  <p>只有对类使用是才会初始化，初始化的条件包括访问类的实例，访问类的静态方法和静态变量的时候，使用Class.forName()反射类的时候，或者某个子类被初始化的时候。</p> 
  <h3><a id="332__563"></a>3.3.2 类加载器</h3> 
  <p><code>BootStrap ClassLoader</code>：启动类加载器加载<code>JAVA_HOME/lib</code>下的类</p> 
  <p><code>ExtClassLoader</code>：扩展加载器加载<code>JAVA_HOME/lib/ext</code>下的类</p> 
  <p><code>AppClassLoader</code>：应用加载器加载加载<code>classpath</code>指定目录下的类</p> 
  <p>除此之外，还可以自定义类加载器。</p> 
  <p>Java的类加载器使用双亲委派模式，双亲委派模型的工作过程是：</p> 
  <ul> 
   <li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。</li> 
   <li>每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。</li> 
   <li>只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。</li> 
  </ul> 
  <blockquote> 
   <p>很多人对“双亲”一词很困惑。这是翻译的锅，，，“双亲”只是“parents”的直译，实际上并不表示汉语中的父母双亲，而是一代一代很多parent，即parents。</p> 
  </blockquote> 
  <p><strong>双亲委派模式优势</strong>：</p> 
  <p>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子<code>ClassLoader</code>再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p> 
  <h2><a id="34_GC_585"></a>3.4 常用GC算法介绍</h2> 
  <h3><a id="341__587"></a>3.4.1 分代回收</h3> 
  <p>分代管理主要是为了方便垃圾回收，这样做是基于两个事实：</p> 
  <ul> 
   <li>大部分对象很快都不在使用</li> 
   <li>还有一部分不会立即无用，但也不会持续很长时间</li> 
  </ul> 
  <p>大部分对象在Eden区中生成，Eden区满时，还存活的对象会在两个Suivivor区交替保存，达到一定次数后对象会晋升为老年代。</p> 
  <p>老年代用来存放从年轻代晋升而来的存活时间较长的对象。</p> 
  <p>永久代主要用来保存类信息等内容。</p> 
  <h3><a id="342__601"></a>3.4.2 垃圾回收算法</h3> 
  <ul> 
   <li>着色指针</li> 
   <li>读屏障</li> 
   <li>并发处理</li> 
   <li>基于Region</li> 
   <li>内存压缩（整理）</li> 
  </ul> 
  <h2><a id="35__609"></a>3.5 考察点和加分项</h2> 
  <p><strong>考察点</strong></p> 
  <ul> 
   <li>深入理解JVM内存模型</li> 
   <li>了解类加载机制</li> 
   <li>了解内存可见性</li> 
   <li>了解常用的GC算法实现和使用场景</li> 
   <li>能够根据业务场景选择合适JVM参数与GC算法</li> 
  </ul> 
  <p><strong>加分项</strong></p> 
  <ul> 
   <li>编译器优化</li> 
   <li>问题排查经验与思路</li> 
   <li>JVM调优经验与调优思路</li> 
   <li>了解最新的技术趋势（例如：ZGC、Grraalvm）</li> 
  </ul> 
  <h2><a id="36__626"></a>3.6 真题</h2> 
  <ul> 
   <li>简述描述一下JVM的内存模型</li> 
   <li>生命情况下会触发FullGC</li> 
   <li>Java类加载器由几种，关系是怎样的？</li> 
   <li>双亲委派机制的加载流程是怎样的，有什么好处？</li> 
   <li>1.8为什么用Metaspace替换掉PermGen？Metasapce保存在哪里？</li> 
   <li>编译期会对指令做哪些优化？（简单描述编译器的指令重排）</li> 
   <li>简单描述一下volatile可以解决什么问题？如何做到的？</li> 
   <li>强制主内存读写同步以及防止指令重排序两点</li> 
   <li>简单描述一下GC的分代回收</li> 
   <li>G1垃圾回收算法与CMS的区别有哪些？</li> 
   <li>对象引用有哪几种方式，有什么特点？</li> 
   <li>强弱软虚在四种引用以及在GC中的处理方式</li> 
   <li>使用过哪些JVM调试工具，主要分析哪些内容？</li> 
  </ul> 
  <h1><a id="4_642"></a>课时4：并发与多线程</h1> 
  <h2><a id="41__644"></a>4.1 知识点汇总</h2> 
  <p><strong>死锁</strong></p> 
  <ul> 
   <li>竞争条件与临界区</li> 
   <li>死锁检测与防止死锁</li> 
   <li>残剩条件 
    <ul> 
     <li>互斥</li> 
     <li>请求并保持</li> 
     <li>不可剥夺</li> 
     <li>循环等待</li> 
    </ul> </li> 
  </ul> 
  <p><strong>线程通信</strong></p> 
  <ul> 
   <li>wait</li> 
   <li>notify</li> 
   <li>notifyAll</li> 
  </ul> 
  <p><strong>线程状态转换</strong></p> 
  <ul> 
   <li>NEW</li> 
   <li>RUNNABLE</li> 
   <li>BLOCKED</li> 
   <li>WAITING</li> 
   <li>TIMED_WAITING</li> 
   <li>TERMINATED</li> 
  </ul> 
  <p><strong>常用工具类（JUC）</strong></p> 
  <ul> 
   <li>ConcurrentXXX</li> 
   <li>AtomicXXX</li> 
   <li>Executor</li> 
   <li>Caller&amp;Future</li> 
   <li>Queue</li> 
   <li>Locks</li> 
  </ul> 
  <p><strong>机制</strong></p> 
  <ul> 
   <li>ThreadLocal</li> 
   <li>Fork/Join</li> 
   <li>Volatile</li> 
   <li>Interrupt</li> 
  </ul> 
  <p><strong>同步与互斥</strong></p> 
  <ul> 
   <li>Synchronized</li> 
   <li>Lock 
    <ul> 
     <li>锁类型</li> 
     <li>锁实现</li> 
    </ul> </li> 
   <li>CAS 
    <ul> 
     <li>Unsafe</li> 
     <li>原语</li> 
    </ul> </li> 
  </ul> 
  <p><strong>线程池</strong></p> 
  <ul> 
   <li>使用场景</li> 
   <li>原理与实现方式</li> 
   <li>线程池实现</li> 
  </ul> 
  <h2><a id="42__704"></a>4.2 线程池详解</h2> 
  <p><strong>线程池参数介绍</strong></p> 
  <p>核心线程数，默认情况下，核心线程会一直存活</p> 
  <p>最大线程数，决定线程池最多可以创建多少线程</p> 
  <p>线程的空闲时间，空闲时间的单位，当线程闲置超过空闲时间时就会被销毁</p> 
  <p><strong>线程缓存队列</strong></p> 
  <ul> 
   <li>有界队列</li> 
   <li>无界队列</li> 
   <li>同步队列</li> 
  </ul> 
  <p><strong>线程池工厂方法</strong></p> 
  <p><strong>线程池满时拒绝策略</strong></p> 
  <ul> 
   <li>抛出异常</li> 
   <li>丢弃</li> 
   <li>提交失败时，由提交任务的线程直接执行任务</li> 
   <li>丢弃最早提交的任务</li> 
  </ul> 
  <h2><a id="43_JUC_729"></a>4.3 JUC重点工具实现类</h2> 
  <p><img src="https://upload-images.jianshu.io/upload_images/15517885-4bf789168a376209.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> 
  <h2><a id="44__733"></a>4.4 考察点和加分项</h2> 
  <p><strong>考察点</strong></p> 
  <ul> 
   <li>理解线程的同步与互斥的原理（临界资源、理解区、自旋锁、偏向锁 、冲入锁、读写锁概念）</li> 
   <li>掌握线程安全相关机制（CAS、Synchronized、ThreadLocal使用弱引用ThreadLocalMap）</li> 
   <li>了解JUC工具的使用场景与实现原理</li> 
   <li>熟悉线程池的原理、使用场景、常用配置</li> 
   <li>理解线程的同步与异步、阻塞与非阻塞（同步与异步的区别是任务是否在同一个线程中执行的 ，阻塞与非阻塞的区别是异步执行任务时线程是不是会阻塞等待结构还是会继续等待后面的逻辑）</li> 
  </ul> 
  <p><strong>加分项</strong></p> 
  <ul> 
   <li>结合实际项目经验或实际案例介绍原理</li> 
   <li>解决多线程问题的排查思路与经验</li> 
   <li>熟悉常用的线程分析工具与方法</li> 
   <li>了解Java8堆JUC的增强</li> 
   <li>了解Reactive异步编程思想</li> 
  </ul> 
  <h2><a id="45__751"></a>4.5 真题</h2> 
  <ul> 
   <li>如何实现一个生产者与消费者模型？（锁、信号量、线程通信、阻塞队列等）</li> 
   <li>如何理解线程的同步与异步、阻塞与非阻塞？</li> 
   <li>线程池处理任务的流程是怎样的？</li> 
   <li>wait与sleep的由什么不同？ 
    <ul> 
     <li>wait属于Object类，sleep属于Thread类；</li> 
     <li>wait会释放对象锁，而sleep不会；</li> 
     <li>wait需要在同步块中使用，sleep可以在任何地方使用；</li> 
     <li>sleep需要捕获异常、wait不需要。</li> 
    </ul> </li> 
   <li>Synchronized和ReentranLock有什么不同？</li> 
   <li>读写锁适用于什么场景？ReentrantReadWriteLock是如何实现的？</li> 
   <li>读写锁适合读并发多，写并发少的场景</li> 
   <li>线程之间如何通信？</li> 
   <li>wait和notify机制、共享变量Synchronized</li> 
   <li>保证线程安全的方法由哪些？</li> 
   <li>CAS、Synchronized、Lock、ThreadLocal</li> 
   <li>如何尽可能提高多线程并发性能？</li> 
   <li>尽量减少临界区范围、使用ThreadLocal、减少线程切换、使用读写锁或CopyOnWrite机制</li> 
   <li>ThreadLocal用来解决什么问题？ThreadLocal是如何实现的？</li> 
   <li>重点回答ThreadLocak不是用来解决多线程共享变量的问题，而是线程数据隔离的问题</li> 
   <li>死锁产生的条件？如何分析是否由线程死锁？</li> 
   <li>在实际工作中遇到过什么样的并发问题，如何发现（排查）并解决的？</li> 
  </ul> 
  <h1><a id="5_775"></a>课时5：数据结构与算法</h1> 
  <h2><a id="51__777"></a>5.1 知识点汇总</h2> 
  <h3><a id="511__779"></a>5.1.1 数据结构</h3> 
  <p>队列</p> 
  <p>栈</p> 
  <p>表</p> 
  <ul> 
   <li>数组</li> 
   <li>单链表</li> 
   <li>双链表</li> 
   <li>循环链表</li> 
   <li>散列表</li> 
  </ul> 
  <p>图</p> 
  <ul> 
   <li>有向图</li> 
   <li>无向图</li> 
   <li>带权图</li> 
  </ul> 
  <p>多叉树</p> 
  <ul> 
   <li>B、B+树</li> 
   <li>字典树</li> 
  </ul> 
  <p>二叉树</p> 
  <ul> 
   <li>平衡二叉树</li> 
   <li>红黑树</li> 
   <li>哈夫曼树</li> 
   <li>堆</li> 
  </ul> 
  <h3><a id="512__811"></a>5.1.2 算法</h3> 
  <p>常用算法思路</p> 
  <ul> 
   <li>分治</li> 
   <li>动态规划</li> 
   <li>贪心</li> 
   <li>回溯</li> 
   <li>分支界定</li> 
  </ul> 
  <p>复杂度</p> 
  <ul> 
   <li>时间复杂度</li> 
   <li>空间复杂度</li> 
  </ul> 
  <p>排序</p> 
  <ul> 
   <li>插入 
    <ul> 
     <li>希尔</li> 
     <li>直插</li> 
    </ul> </li> 
   <li>交换 
    <ul> 
     <li>冒泡</li> 
     <li>快排</li> 
    </ul> </li> 
   <li>选择 
    <ul> 
     <li>简单选择</li> 
     <li>堆</li> 
    </ul> </li> 
   <li>归并</li> 
   <li>基数</li> 
  </ul> 
  <p>查找</p> 
  <ul> 
   <li>二分查找</li> 
   <li>二叉排序树</li> 
   <li>B树</li> 
   <li>BloomFilter</li> 
  </ul> 
  <p>字符串匹配</p> 
  <ul> 
   <li>BF算法</li> 
   <li>BM算法</li> 
   <li>Sundady算法</li> 
   <li>KMP算法</li> 
   <li>Tire树</li> 
  </ul> 
  <h2><a id="52__855"></a>5.2 字符串匹配</h2> 
  <p>字符串匹配问题<br> 判断给定字符串中的括号是否匹配</p> 
  <p><strong>解体思路</strong>：</p> 
  <ul> 
   <li>使用栈</li> 
   <li>遇左括号入栈</li> 
   <li>遇右括号出栈，判断出栈括号是否与右括号成对</li> 
  </ul> 
  <h2><a id="53__866"></a>5.3 考察点和加分项</h2> 
  <p><strong>考察点</strong></p> 
  <ul> 
   <li>了解基本数据结构与特点</li> 
   <li>表、栈、队列、树需要熟练掌握，深刻理解使用场景（例如红黑树适合搜索，B+树适合索引）</li> 
   <li>了解常用的搜索、排序算法，及复杂度和稳定性</li> 
   <li>了解常用的字符串处理算法</li> 
   <li>能够分析算法实现的复杂度</li> 
   <li>了解常用算法分类，解决问题的思路和解决哪类问题</li> 
  </ul> 
  <p><strong>加分项</strong></p> 
  <ul> 
   <li>能够将数据结构与实际使用场景结合（介绍红黑树时结合TreeMap的实现，介绍B+树时结合MySQL的索引）</li> 
   <li>不同算法在业务场景中的应用</li> 
   <li>面对模糊的题目能沟通确认条件和边界</li> 
   <li>书写算法代码前，先讲一下解题思路</li> 
   <li>能够发现解答中的一些问题，给出改进的思路</li> 
  </ul> 
  <h2><a id="54__885"></a>5.4 真题</h2> 
  <p>题1、题2基础题，必须掌握</p> 
  <ul> 
   <li>各种排序算法实现和复杂度、稳定性</li> 
   <li>二叉树的前、中、后序遍历</li> 
   <li>翻转句子中单词的顺序</li> 
   <li>用栈模拟队列（或用队列模拟栈）</li> 
   <li>堆10亿个数进行排序，限制内存位1G</li> 
   <li>去掉（或找出）两个数组中重复的数字</li> 
   <li>将一颗二叉树转换成其镜像</li> 
   <li>确定一个字符串中的括号是否匹配</li> 
   <li>给定一个开始词，一个结束词，一个字典，如何找到从开始词到结束词的最短单词接龙路径</li> 
   <li>如何查找两个二叉树节点的最近公共祖先</li> 
  </ul> 
  <h1><a id="6_900"></a>课时6：常用工具集</h1> 
  <h2><a id="61__902"></a>6.1 知识点汇总</h2> 
  <p><strong>团队协作</strong></p> 
  <ul> 
   <li>Ant</li> 
   <li>Maven</li> 
   <li>Gradle</li> 
   <li>Git</li> 
   <li>SVN</li> 
  </ul> 
  <p><strong>质量保证</strong></p> 
  <ul> 
   <li>Checkstyle</li> 
   <li>FindBugs</li> 
   <li>SonarQube</li> 
  </ul> 
  <p><strong>压测</strong></p> 
  <ul> 
   <li>JMeter</li> 
   <li>JMH</li> 
   <li>AB</li> 
   <li>LoadRunner</li> 
  </ul> 
  <p><strong>容器与代理（随着微服务的盛行，Envoy、OpenResty、Kong等API网关的使用也越来越普遍）</strong></p> 
  <ul> 
   <li>Tomcat</li> 
   <li>Jetty</li> 
   <li>Nginx</li> 
   <li>Envoy</li> 
   <li>OpenResty</li> 
   <li>Kong</li> 
  </ul> 
  <p><strong>CI/CD</strong></p> 
  <ul> 
   <li>Gitlab-CI</li> 
   <li>Jenkins</li> 
   <li>Travis</li> 
  </ul> 
  <p><strong>JVM相关</strong></p> 
  <ul> 
   <li>JMC（JFR）</li> 
   <li>jstack、jmap、jstat</li> 
  </ul> 
  <p><strong>系统分析</strong></p> 
  <ul> 
   <li>vmstat</li> 
   <li>iostat &amp; iotop</li> 
   <li>ifstat &amp; iftop</li> 
   <li>netstat</li> 
   <li>dstat</li> 
   <li>strace</li> 
   <li>GDB</li> 
   <li>lsof</li> 
   <li>tcpdump</li> 
   <li>traceroute</li> 
  </ul> 
  <p><strong>文档管理</strong></p> 
  <ul> 
   <li>JavaDoc</li> 
   <li>Swagger</li> 
  </ul> 
  <p><strong>网络工具</strong></p> 
  <ul> 
   <li>PostMan</li> 
   <li>WireShark（网络包分析工具）</li> 
   <li>Fiddler（只针对HTTP进行抓捕）</li> 
   <li>Charies</li> 
  </ul> 
  <h2><a id="62__970"></a>6.2 考察点和加分项</h2> 
  <p><strong>考察点</strong></p> 
  <ul> 
   <li>了解常用JVM分析工具</li> 
   <li>掌握Git的常用操作和工作流</li> 
   <li>了解Linux系统下常用的分析工具</li> 
  </ul> 
  <p><strong>加分项</strong></p> 
  <ul> 
   <li>能够主动出击体现知识广度（在描述项目问题主动引出工具）</li> 
   <li>能够体现实战能力</li> 
  </ul> 
  <h2><a id="66__983"></a>6.6 真题</h2> 
  <ul> 
   <li>排查JVM问题有哪些常用工具？</li> 
   <li>Git合并代码有那两种方法？有什么区别</li> 
   <li>Git与SVN有哪些差异？</li> 
   <li>你所在的团队项目开发使用什么样工作流？有什么优点？</li> 
  </ul> 
  <h1><a id="7Spring_990"></a>课时7：必会框架（上）——Spring全家桶</h1> 
  <h2><a id="71__992"></a>7.1 知识点汇总</h2> 
  <p><strong>Spring</strong></p> 
  <ul> 
   <li>Spring Framework</li> 
   <li>Spring Boot</li> 
   <li>Spring Data</li> 
   <li>Spring Cloud 
    <ul> 
     <li>Sleuth</li> 
     <li>Netflix</li> 
     <li>Config</li> 
     <li>Bus</li> 
     <li>Security</li> 
     <li>Struts</li> 
    </ul> </li> 
  </ul> 
  <p><strong>ORM</strong></p> 
  <ul> 
   <li>Hibernate</li> 
   <li>Mybatis</li> 
   <li>Netty</li> 
  </ul> 
  <p><strong>RPC</strong></p> 
  <ul> 
   <li>Motan</li> 
   <li>Bubbo</li> 
   <li>Grpc</li> 
  </ul> 
  <p><strong>其他框架</strong></p> 
  <ul> 
   <li>Jersey</li> 
   <li>RESTEasy</li> 
   <li>Shiro</li> 
  </ul> 
  <h2><a id="72_Spring_1025"></a>7.2 Spring框架</h2> 
  <p><strong>机制与实现</strong><br> <strong>AOP</strong></p> 
  <ul> 
   <li>动态代理</li> 
   <li>静态代理</li> 
  </ul> 
  <p><strong>PlaceHolder动态替换</strong></p> 
  <ul> 
   <li>PropertyPlaceholderConfigure</li> 
   <li>PropertySourcesPlaceholderConfigure</li> 
  </ul> 
  <p><strong>事务</strong></p> 
  <ul> 
   <li> <p>隔离级别</p> 
    <ul> 
     <li>ISOLATION_DEFAULT</li> 
     <li>ISOLATION_READ_UNCOMMITTED</li> 
     <li>ISOLATION_READ_COMMITTED</li> 
     <li>ISOLATION_REPEATABLE_READ</li> 
     <li>ISOLATION_SERIALIZABLE</li> 
    </ul> </li> 
   <li> <p>传播行为</p> 
    <ul> 
     <li>PROPAGATION_REQUIRED</li> 
     <li>PROPAGATION_SUPPORTS</li> 
     <li>PROPAGATION_MANDATORY</li> 
     <li>PROPAGATION_REQUIRED_NEW</li> 
     <li>PROPAGATION_NOT_SUPPORTED</li> 
     <li>PROPAGATION_NEVER</li> 
     <li>PROPAGATION_NESTED</li> 
    </ul> </li> 
   <li> <p>核心接口/类</p> 
    <ul> 
     <li>ApplicationContext</li> 
     <li>BeanFactory</li> 
     <li>BeanWrapper</li> 
     <li>FactoryBean</li> 
    </ul> </li> 
   <li> <p>scope</p> 
    <ul> 
     <li>Singleton</li> 
     <li>Prototype</li> 
     <li>Request</li> 
     <li>Session</li> 
     <li>Global-session</li> 
     <li>Application</li> 
     <li>Websocket</li> 
    </ul> </li> 
   <li> <p>事件机制</p> 
    <ul> 
     <li>ContextRefreshedEvent</li> 
     <li>ContextStatedEvent</li> 
     <li>ContextStoppedEvent</li> 
     <li>ContextClosedEvent</li> 
     <li>RequestHandledEvent</li> 
    </ul> </li> 
  </ul> 
  <p>Spring应用</p> 
  <p><strong>类型类</strong></p> 
  <ul> 
   <li>@Controller</li> 
   <li>@service</li> 
   <li>@Repository</li> 
   <li>@Component</li> 
   <li>@Configuration</li> 
   <li>@Bean</li> 
  </ul> 
  <p><strong>设置类</strong></p> 
  <ul> 
   <li>@Required</li> 
   <li>@Autowired &amp;&amp; @Qualifier</li> 
   <li>@Scope</li> 
  </ul> 
  <p><strong>Web类</strong></p> 
  <ul> 
   <li>@RequestMapping &amp;&amp; @GetMapping @ PostMapping</li> 
   <li>@PathVariable &amp;&amp; @RequestParam</li> 
   <li>@RequestBody &amp;&amp; @ResponseBody</li> 
  </ul> 
  <p><strong>功能类</strong></p> 
  <ul> 
   <li>@ImportResource</li> 
   <li>@ComponentScan</li> 
   <li>@EnableCaching &amp;&amp; Cacheable</li> 
   <li>@Transactional</li> 
   <li>@Aspect &amp;&amp; Poincut</li> 
   <li>@Scheduled</li> 
  </ul> 
  <p><strong>配置方式</strong></p> 
  <ul> 
   <li>XML</li> 
   <li>注解</li> 
   <li>API</li> 
  </ul> 
  <p><strong>自动装配</strong></p> 
  <ul> 
   <li>byType</li> 
   <li>byName</li> 
   <li>constructor</li> 
   <li>autodetect</li> 
  </ul> 
  <h1><a id="8RPCORM_1127"></a>课时8：必会框架（下）——RPC与ORM</h1> 
  <h2><a id="81__1129"></a>8.1 考察点与加分项</h2> 
  <p><strong>考察点</strong></p> 
  <ul> 
   <li>掌握Spring的IOC、AOP的概念与实现</li> 
   <li>掌握Spring的Context创建流程和Bean的生命周期</li> 
   <li>了解Spring常用注解的作用与使用方式</li> 
   <li>了解SpringBoot的相关知识点</li> 
   <li>掌握Netty的线程处理模型</li> 
   <li>知道常用RPC框架的特点</li> 
   <li>了解Mybatis、Hibernate的实现原理</li> 
  </ul> 
  <p><strong>加分项</strong></p> 
  <ul> 
   <li>阅读过框架源码，了解实现细节及思路</li> 
   <li>除了会应用，还能够理解理念</li> 
   <li>了解最新实现或方向</li> 
   <li>有实际优化经验，例如Nett有性能调优</li> 
  </ul> 
  <h2><a id="82__1148"></a>8.2 真题</h2> 
  <ul> 
   <li>SSH和SSM框架组合的区别是生命？</li> 
   <li>能描述一些Spring Context初始化的整个流程吗？</li> 
   <li>简单介绍一些Bean的生命周期及作用域</li> 
   <li>Spring配置中的placeholder占位符是如何替换的？有什么办法可以实现自定义的配置替换？</li> 
   <li>要答出通过beanFactoryPostProfessal后置处理器进行的替换，如果要自定义处理，可以扩展PropertyPlaceHolderConfigure或者PropertySourcePlaceHolderConfigure来实现</li> 
   <li>SpringMVC的工作流程是怎样的？</li> 
   <li>Spring如何解决循环依赖？</li> 
   <li>从构造器循环依赖和setter循环依赖两方面来回答<br> Bean的构造方法、@PostConstruct注解、InitializingBean、init-method的执行顺序是怎样的？</li> 
   <li>说说Netty中有哪些重要的对象，它们之间的关系是什么？</li> 
   <li>RPC与HTTP的区别是什么，什么场景适合选用RPC，什么场景适合使用HTTP？</li> 
   <li>在使用方式方面，HTTP使用Client，RPC通过动态代理；从请求模型看，HTTP一般会经过DNS解析，4/7层代理等中间环节，而RPC是点对点直连；从服务治理能力来看，RPC提供丰富的服务治理功能，例如熔断 、负载均衡，HTTP对跨语言处理比较方便</li> 
   <li>RPC的交互流程是怎样的？</li> 
   <li>请介绍一下Mybatis的缓存机制</li> 
   <li>Mybatis如何配置动态SQL？有哪些动态SQL标签？</li> 
  </ul> 
  <h1><a id="9_1166"></a>课时9：缓存</h1> 
  <h2><a id="91__1168"></a>9.1 考察点和加分项</h2> 
  <p><strong>考察点</strong></p> 
  <ul> 
   <li>了解缓存的使用场景，不同类型缓存的使用方式</li> 
   <li>掌握MC和Redis的常用命令</li> 
   <li>了解MC的Redis在内存中的存储结构</li> 
   <li> 
    <ul> 
     <li>了解MC和Redis的数据失效方式和剔除策略</li> 
    </ul> </li> 
   <li>了解Redis的持久化、主从同步与cluster部署的原理</li> 
  </ul> 
  <p><strong>加分项</strong></p> 
  <ul> 
   <li>结合使用场景来介绍缓存的使用</li> 
   <li>有过分布式缓存设计和应用经验</li> 
   <li>了解缓存使用中可能产生的问题</li> 
   <li>知道Redis的典型应用场景</li> 
   <li>知道Redis的新特性</li> 
  </ul> 
  <h2><a id="92__1186"></a>9.2 真题</h2> 
  <ul> 
   <li>Redis和Memcache有什么区别？该如何选用</li> 
   <li>你用到过哪些Redis的数据结构？用在什么场景下？</li> 
   <li>Redis有哪些持久化方式，分别是什么？</li> 
   <li>Redis的过期机制是怎样的？Redis有哪些淘汰策略</li> 
   <li>如何保证Redis的高并发和高可用？</li> 
   <li>如何使用Redis实现延时队列？如何使用Redis实现分布式锁？</li> 
  </ul> 
  <h1><a id="_1196"></a>读者福利：</h1> 
  <p><strong>分享免费学习资料</strong></p> 
  <p><strong>针对于Java程序员，我这边准备免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料）</strong></p> 
  <p><strong>为什么某些人会一直比你优秀，是因为他本身就很优秀还一直在持续努力变得更优秀，而你是不是还在满足于现状内心在窃喜！希望读到这的您能点个小赞和关注下我，以后还会更新技术干货，谢谢您的支持！</strong></p> 
  <p><strong>资料领取方式：加入Java技术交流群<code>963944895</code>，<a href="https://jq.qq.com/?_wv=1027&amp;k=5S3Yy38" rel="nofollow">点击加入群聊</a>，私信管理员即可免费领取</strong></p> 
  <blockquote> 
   <p><strong>//点关注，不迷路；持续更新Java架构相关技术及资讯！！！</strong></p> 
  </blockquote> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
