<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>区块链核心技术演进之路－算法演进 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="区块链核心技术演进之路－算法演进" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="大多惊讶于这套系统的简洁和完美，甚至有人断言此物一出，开天辟地。如今近乎8年过去，当年看起来近乎完美的系统理念，在各个方面都有长足探索和发展。接下来我将写一系列文章，回顾区块链核心技术演进之路。包括算法演进，挖矿演进，共识机制演进，代币演进，隐私的演进，以及容量和速率的演进等。题目比较大，抛砖引玉，望读者指正和补充。 &nbsp; 算法演进 &nbsp; &nbsp; 关于“算法”一词，目前国内用户使用的比较模糊，有时指共识机制，比如POW算法，POS算法；有时指具体的Hash算法，比如SHA256，SCRYPT。应该说这是由于早期从外文资料翻译过来概念模糊导致的错误，后来人云亦云。共识机制（以前一般叫Proof，现在经常使用Consensus）和算法（Algorithm）在英文资料里语义清晰，不能混为一谈，两者都是区块链技术体系里的重要支柱。 因此当我们说“X币使用Y算法”的时候，其实具体指的是采用何种Hash算法，而且隐含的前提条件是这个币使用POW证明方式。只有在POW下讨论选取何种算法才有意义，算法的各种复杂设计才能体现其用处。为什么呢，中本聪在设计比特币的时候其实有很多地方用到Hash函数，比如计算区块ID，计算交易ID，构造代币地址等。我们说的算法具体是指用何种Hash函数计算区块ID，所谓算法创新也就是在这个地方下功夫。此外其他任何用到Hash函数的地方，对计算难度没有要求，而且应该选用可以快速运算的算法，尤其在计算交易ID时候，不然影响区块链同步速度。因此如果选用POS方式，计算区块ID也应该使用容易运算的算法。 &nbsp; Hash函数 &nbsp; &nbsp; 如上所言，我们经常说的POW算法本质是一个Hash函数。Hash函数是一个无比神奇的东西，说他替中本聪打下了半壁江山一点不为过，学习比特币应该从学习Hash函数入手，理解了Hash函数再去学比特币原理将事半功倍，不然将处处感觉混沌，难以开窍。而中本聪也将Hash函数的所有特性使用得淋漓尽致： 已经有很多Hash函数被设计出来并广泛应用，不过Hash函数一般安全寿命都不长，被认为安全的算法往往没能使用多久就被成功攻击，新的更安全的算法相继被设计出来，而每一个被公认为安全可靠的算法都有及其严格的审计过程。在币圈中我们经常说某某币发明了某种算法，其实主要都是使用那些被认证过的安全算法，或是单独使用，或是排列组合使用。 &nbsp; SHA256 &nbsp; &nbsp; SHA (Secure Hash Algorithm，译作安全散列算法) 是美国国家安全局 (NSA) 设计，美国国家标准与技术研究院 (NIST) 发布的一系列密码散列函数，经历了SHA-0，SHA-1，SHA-2，SHA-3系列发展。NSA于2007年正式宣布在全球范围内征集新新一代（SHA-3）算法设计，2012年公布评选结果， Keccak算法最终获胜成为唯一官方标准SHA-3算法，但还有四种算法同时进入了第三轮评选，分别是：BLAKE, GrøSTL, JH和SKEIN，这些算法其实也非常安全，而且经受审查，被各种竞争币频繁使用。 比特币采用SHA256算法，该算法属于SHA-2系列，在中本聪发明比特币时（2008）被公认为最安全最先进的算法之一。除了生成地址中有一个环节使用了REPID-160算法，比特币系统中但凡有需要做Hash运算的地方都是用SHA256。随着比特币被更多人了解，大家开始好奇中本聪为何选择了SHA256，同时对SHA256的安全性发表各种意见，SHA256妥妥经受了质疑，到目前为止，没有公开的证据表明SHA256有漏洞，SHA256依然牢牢抗住保卫比特币安全的大旗。当然大家心里都明白，没有永远安全的算法，SHA256被替代是早晚的事，中本聪自己也说明了算法升级的必要和过程。 &nbsp; SCRYPT &nbsp; &nbsp; 后来随着显卡挖矿以及矿池的出现，社区开始担心矿池会导致算力集中，违背中本聪“一CPU一票”的最初设计理念。在那段时间，中心化的焦虑非常严重，讨论很激烈，比特币一次又一次“被死亡”，直到现在，针对矿池是否违背去中心化原则的争论仍在继续。 无论如何，有人将矛头指向SHA256，认为是算法太容易导致矿机和矿池出现，并试图寻找更难的算法。 恰逢其时，使用SCRYPT算法的莱特币（Litecoin）横空出世。据说SCRYPT是由一位著名的黑客开发，由于没有得到诸如SHA系列的严格的安全审查和全面论证，一直没被广泛推广使用。与SHA256算法相比，SCRYPT占用的内存更多，计算时间更长，并行计算异常困难，对硬件要求很高。很显然，SCRYPT算法具有更强的抵御矿机性，莱特币还将区块时间改为2.5分钟，在那个山寨币还凤毛麟角年代，莱特币依靠这两点创新大获成功，长期稳坐山寨币第一宝座位置。 后来有人在SCRYPT的基础上稍作修改形成Scrypt –N算法，改进思路都一样，都是追求更大的内存消耗和计算时间，以有效阻止ASIC专用矿机。 很快，莱特币的成功催生了各种各样的算法创新，2012至2014年间，算法创新一直都是社区讨论的热门话题，每一个使用创新算法的币种出现，都能刮起一阵波澜。 &nbsp; 串联算法 &nbsp; &nbsp; 重新排列组合是人类一贯以来最常用的创新发明方法。很快，有人不满足于使用单一Hash函数，2013年7月，夸克币（Quark）发布，首创使用多轮Hash算法，看似高大上，其实很简单，就是对输入数据运算了9次hash函数，前一轮运算结果作为后一轮运算的输入。这9轮Hash共使用6种加密算法，分别为BLAKE, BMW, GROESTL, JH, KECCAK和SKEIN，这些都是公认的安全Hash算法，并且早已存在现成的实现代码。 这种多轮Hash一出现就给人造成直观上很安全很强大的感觉，追捧者无数。现今价格依然坚挺的达世币（DASH，前身是暗黑币，Darkcoin，）接过下一棒，率先使用11种加密算法（BLAKE, BMW, GROESTL, JH, KECCAK, SKEIN, LUFFA, CUBEHASH, SHAVITE, SIMD, ECHO），美其名曰X11，紧接着X13，X15这一系列就有人开发出来了。 S系列算法实际是一种串联思路，只要其中一种算法被破解，整个算法就被破解了，好比一根链条，环环相扣，只要其中一环断裂，整个链条就一分为二。 &nbsp; 并联算法 &nbsp; &nbsp; 有人串联，就有人并联，Heavycoin（HVC）率先做了尝试。HVC如今在国内名不见经传，当时还是名噪一时，首次实现链上游戏，作者是俄罗斯人，后来不幸英年早逝，在币圈引起一阵惋惜。 HVC算法细节： &nbsp; 对输入数据首先运行一次HEFTY1（一种Hash算法）运算，得到结果d1 &nbsp;以d1为输入，依次进行SHA256、KECCAK512、GROESTL512、BLAKE512运算，分别获得输出d2,d3,d4和d5 分别提取d2-d5前64位，混淆后形成最终的256位Hash结果，作为区块ID。 &nbsp; 之所以首先进行一轮HEFTY1 哈希，是因为HEFTY1 运算起来极其困难，其抵御矿机性能远超于SCRYPT。但与SCRYPT一样，安全性没有得到某个官方机构论证，于是加入后面的四种安全性已经得到公认的算法增强安全。 对比串联和并联的方法，Quark、X11，X13等虽使用了多种HASH函数，但这些算法都是简单的将多种HASH函数串联在一起，仔细思考，其实没有提高整体的抗碰撞性，其安全性更是因木桶效应而由其中安全最弱的算法支撑，其中任何一种Hash函数遭遇碰撞性攻击，都会危及货币系统的安全性。 HVC从以上每种算法提取64位，经过融合成为最后的结果，实际上是将四种算法并联在一起，其中一种算法被破解只会危及其中64位，四中算法同时被破解才会危及货币系统的安全性。 比特币只使用了一种Hash算法，假如未来某日SHA256被证明不再安全时，虽然可以更该算法，但考虑到如今“硬分叉猛于虎”的局面，届时引发动荡不可避免，但如果使用并联算法，就可以争取平静的硬分叉过渡时间。 &nbsp; PRIMECOIN &nbsp; &nbsp; 正当一部分人在算法探索之路上进行的如火如荼之时，另一部分人的声音也非常刺耳，那就是指责POW浪费能源（彼时POS机制已经实现）。POW党虽极力维护，但也承认耗费能源这一事实。这一指责打开了另一条探索之路，即如果能找到一种算法，既能维护区块链安全，这些Hash运算又能在其他方面产生价值，那简直更完美。 在这条探索之路上最让人振奋人心的成果来自于Sunny King（这大神之前已经开发了Peercoin，点点币）发明的素数币（Primecoin）。素数币算法的核心理念是：在做Hash运算的同时寻找大素数。素数如今已被广泛应用于各个领域，但人类对他的认识还是有限。素数在数轴上不但稀有（相对于偶数而言），而且分布不规律，在数轴上寻找素数只能盲目搜索探测，这正是POW的特征。 POW还有另一个要求是容易验证，这方面人类经过几百年探索已经获得一些成果。素数币使用两种方法测试，首先进行费马测试（Fermat Test），通过则再进行欧拉-拉格朗日-立夫习兹测试（Euler-Lagrange-Lifchitz Test），还通过测试则被视为是素数。需要指出的是，这种方法并不能保证通过测试的数百分百是素数，不过这并不影响系统运行，即便测试结果错误，只要每个节点都认为是素数就行。 素数币其实找的是素数链-坎氏链，存在三个特定类型的坎氏素数链：第一类坎氏链，第二类坎氏链和双坎氏链。 举第一类来说明，规则是：素数链中每个数都是前一个数的两倍减一，比如： 1531，3061，6121，12241，24481 数列的下一个数48961(24481*2-1)不是素数，因而这个坎氏链的长度是5，素数币的目标就是探索更长的坎氏链（以上三类都可以）。 &nbsp; 那么现在最重要的问题来了，如何用坎氏链来验证一个区块是否合格呢？素数币实现的细节是这样的： 计算中本聪区块头Hash，hashBlockHeader = SHA256(BlockHeader) 通过变换获得坎氏链的第一个数：originNum = hashBlockHeader * Multiplier 获取originNum之后就可以测试并计算素数链长度的整数部分，小数部分的计算与坎氏链最后一个非素数的跨度相关。 &nbsp; 每个区块的乘积因子Multiplier各不相同，计算过程和hashBlockHeader相关，素数币为此对区块头进行修改，专门增加一个字段（bnPrimeChainMultiplier）来存放这个乘积因子。但是以上第一步计算hashBlockHeader时输入数据并不包含这个乘积因子，这也是为啥特别指出中本聪区块头。 由于素数在数轴上分布不均匀，且根据目前掌握的知识来看，数越大，素数越稀有，寻找难度并不是线性递增，耗时也就不可预估，但是区块链要求稳定出块。正因为这点，素数币算法没有得到热捧，但这种探索并非没有意义，利用POW工作量的“幻想”并没有停止，探索还在继续。 &nbsp; ETHASH &nbsp; &nbsp; 以太坊（Ethereum）一开始就打算使用POS方式，但由于POS设计存在一些问题，开发团队决定在以太坊1.0阶段使用POW方式，预计在Serenity阶段转入POS。 以太坊POW算法叫Ethash，虽只是一个过渡算法，但开发团队一点也不含糊，一如既往发扬其“简单问题复杂化，繁琐细节秀智商”的设计风格。Ethash 是最新版本的 Dagger-Hashimoto改良算法，是Hashimoto算法结合Dagger算法产成的一个新变种。Ethash设计时就明确两大目标： 抵御矿机性能（ASIC-resistance），团队希望CPU也能参与挖矿获得收益。 轻客户端可快速验证（Light client verifiability）。 基于以上两个目标，开发团队最后倒腾出来的Ethash挖矿时基本与CPU性能无关，却和内存大小和内存带宽成正相关。不过在实现上还是借鉴了SHA3的设计思路，但是使用的”SHA3_256” ,”SHA3_512”与标准实现很不同。 &nbsp; Ethash基本流程是这样的：对于每一个块，首先计算一个种子（seed），该种子只和当前块的信息有关；然后根据种子生成一个32M的随机数据集（Cache）；紧接着根据Cache生成一个1GB大小的数据集合（DAG），DAG可以理解为一个完整的搜索空间，挖矿的过程就是从DAG中随机选择元素（类似于比特币挖矿中查找合适Nonce）再进行哈希运算。可以从Cache快速计算DAG指定位置的元素，进而哈希验证。此外还要求对Cache和DAG进行周期性更新，每1000个块更新一次，并且规定DAG的大小随着时间推移线性增长，从1G开始，每年大约增长7G左右。 &nbsp; EQUIHASH &nbsp; &nbsp; 最近在国内发展势头最猛的莫过于Zcash，该币种最大的特点是使用零知识证明实现隐私交易。距离发布还有几天，但从社区讨论来看，各方矿工都已在磨刀霍霍。Zcash对于算法的选择非常慎重，在先后考量了SHA256D，SCRYPT，CUCKOO HASH以及LYRA2等算法后，最终选择Equihash。 Equihash算法由Alex Biryukov 和 Dmitry Khovratovich联合发明，其理论依据是一个著名的计算法科学及密码学问题——广义生日悖论问题。Equihash是一个内存（ARM）依赖型算法，机器算力大小主要取决于拥有多少内存，根据两位发明者的论文描述，该算法执行至少需要700M内存，1.8 GHz CPU计算30秒，经Zcash项目优化后，目前每个挖矿线程需要1G内存，因此Zcash官方认为该算法在短时间内很难出现矿机（ASIC）。此外，Zcash官方还相信该算法比较公平，他们认为很难有人或者机构能够对算法偷偷进行优化，因为广义生日悖论是一个已经被广泛研究的问题。此外，Equihash算法非常容易验证，这对于未来在受限设备上实现Zcash轻客户端非常重要。 Zcash官方团队选择Equihash完全出于抵御矿机性能的需求，他们在官方博客中也承认并不敢确保Equihash一定是安全的，并表示如果发现Equihash存在问题，或者发现更优算法，Zcash会改变POW算法。 &nbsp; 总结 &nbsp; &nbsp; 随着比特币、莱特币矿机相继出现，大家已经认识到没有不能开发矿机的算法，想通过改进算法来彻底阻止矿机和矿池的出现是不可能的。另外，从近几年的发展来看，矿池也没有之前想的那么可怕，甚至已经有人论证了矿池并没有破坏去中心化。但除了安全性，POW往往伴随分发代币功能，从这个角度来说，CPU算法更具公平性，用户门槛更低，这也是算法创新的驱动，从Ethash以及Equihash设计来看，目前的算法创新仍然是以追求内存高消耗为主。以此同时，社区在共识机制的探索之路上也取得很多成果。纵观当前区块链核心技术发展全局，算法创新热潮已经有所消退，但也未停止，于比特币，于区块链，于算法探索而言，都还在路上。" />
<meta property="og:description" content="大多惊讶于这套系统的简洁和完美，甚至有人断言此物一出，开天辟地。如今近乎8年过去，当年看起来近乎完美的系统理念，在各个方面都有长足探索和发展。接下来我将写一系列文章，回顾区块链核心技术演进之路。包括算法演进，挖矿演进，共识机制演进，代币演进，隐私的演进，以及容量和速率的演进等。题目比较大，抛砖引玉，望读者指正和补充。 &nbsp; 算法演进 &nbsp; &nbsp; 关于“算法”一词，目前国内用户使用的比较模糊，有时指共识机制，比如POW算法，POS算法；有时指具体的Hash算法，比如SHA256，SCRYPT。应该说这是由于早期从外文资料翻译过来概念模糊导致的错误，后来人云亦云。共识机制（以前一般叫Proof，现在经常使用Consensus）和算法（Algorithm）在英文资料里语义清晰，不能混为一谈，两者都是区块链技术体系里的重要支柱。 因此当我们说“X币使用Y算法”的时候，其实具体指的是采用何种Hash算法，而且隐含的前提条件是这个币使用POW证明方式。只有在POW下讨论选取何种算法才有意义，算法的各种复杂设计才能体现其用处。为什么呢，中本聪在设计比特币的时候其实有很多地方用到Hash函数，比如计算区块ID，计算交易ID，构造代币地址等。我们说的算法具体是指用何种Hash函数计算区块ID，所谓算法创新也就是在这个地方下功夫。此外其他任何用到Hash函数的地方，对计算难度没有要求，而且应该选用可以快速运算的算法，尤其在计算交易ID时候，不然影响区块链同步速度。因此如果选用POS方式，计算区块ID也应该使用容易运算的算法。 &nbsp; Hash函数 &nbsp; &nbsp; 如上所言，我们经常说的POW算法本质是一个Hash函数。Hash函数是一个无比神奇的东西，说他替中本聪打下了半壁江山一点不为过，学习比特币应该从学习Hash函数入手，理解了Hash函数再去学比特币原理将事半功倍，不然将处处感觉混沌，难以开窍。而中本聪也将Hash函数的所有特性使用得淋漓尽致： 已经有很多Hash函数被设计出来并广泛应用，不过Hash函数一般安全寿命都不长，被认为安全的算法往往没能使用多久就被成功攻击，新的更安全的算法相继被设计出来，而每一个被公认为安全可靠的算法都有及其严格的审计过程。在币圈中我们经常说某某币发明了某种算法，其实主要都是使用那些被认证过的安全算法，或是单独使用，或是排列组合使用。 &nbsp; SHA256 &nbsp; &nbsp; SHA (Secure Hash Algorithm，译作安全散列算法) 是美国国家安全局 (NSA) 设计，美国国家标准与技术研究院 (NIST) 发布的一系列密码散列函数，经历了SHA-0，SHA-1，SHA-2，SHA-3系列发展。NSA于2007年正式宣布在全球范围内征集新新一代（SHA-3）算法设计，2012年公布评选结果， Keccak算法最终获胜成为唯一官方标准SHA-3算法，但还有四种算法同时进入了第三轮评选，分别是：BLAKE, GrøSTL, JH和SKEIN，这些算法其实也非常安全，而且经受审查，被各种竞争币频繁使用。 比特币采用SHA256算法，该算法属于SHA-2系列，在中本聪发明比特币时（2008）被公认为最安全最先进的算法之一。除了生成地址中有一个环节使用了REPID-160算法，比特币系统中但凡有需要做Hash运算的地方都是用SHA256。随着比特币被更多人了解，大家开始好奇中本聪为何选择了SHA256，同时对SHA256的安全性发表各种意见，SHA256妥妥经受了质疑，到目前为止，没有公开的证据表明SHA256有漏洞，SHA256依然牢牢抗住保卫比特币安全的大旗。当然大家心里都明白，没有永远安全的算法，SHA256被替代是早晚的事，中本聪自己也说明了算法升级的必要和过程。 &nbsp; SCRYPT &nbsp; &nbsp; 后来随着显卡挖矿以及矿池的出现，社区开始担心矿池会导致算力集中，违背中本聪“一CPU一票”的最初设计理念。在那段时间，中心化的焦虑非常严重，讨论很激烈，比特币一次又一次“被死亡”，直到现在，针对矿池是否违背去中心化原则的争论仍在继续。 无论如何，有人将矛头指向SHA256，认为是算法太容易导致矿机和矿池出现，并试图寻找更难的算法。 恰逢其时，使用SCRYPT算法的莱特币（Litecoin）横空出世。据说SCRYPT是由一位著名的黑客开发，由于没有得到诸如SHA系列的严格的安全审查和全面论证，一直没被广泛推广使用。与SHA256算法相比，SCRYPT占用的内存更多，计算时间更长，并行计算异常困难，对硬件要求很高。很显然，SCRYPT算法具有更强的抵御矿机性，莱特币还将区块时间改为2.5分钟，在那个山寨币还凤毛麟角年代，莱特币依靠这两点创新大获成功，长期稳坐山寨币第一宝座位置。 后来有人在SCRYPT的基础上稍作修改形成Scrypt –N算法，改进思路都一样，都是追求更大的内存消耗和计算时间，以有效阻止ASIC专用矿机。 很快，莱特币的成功催生了各种各样的算法创新，2012至2014年间，算法创新一直都是社区讨论的热门话题，每一个使用创新算法的币种出现，都能刮起一阵波澜。 &nbsp; 串联算法 &nbsp; &nbsp; 重新排列组合是人类一贯以来最常用的创新发明方法。很快，有人不满足于使用单一Hash函数，2013年7月，夸克币（Quark）发布，首创使用多轮Hash算法，看似高大上，其实很简单，就是对输入数据运算了9次hash函数，前一轮运算结果作为后一轮运算的输入。这9轮Hash共使用6种加密算法，分别为BLAKE, BMW, GROESTL, JH, KECCAK和SKEIN，这些都是公认的安全Hash算法，并且早已存在现成的实现代码。 这种多轮Hash一出现就给人造成直观上很安全很强大的感觉，追捧者无数。现今价格依然坚挺的达世币（DASH，前身是暗黑币，Darkcoin，）接过下一棒，率先使用11种加密算法（BLAKE, BMW, GROESTL, JH, KECCAK, SKEIN, LUFFA, CUBEHASH, SHAVITE, SIMD, ECHO），美其名曰X11，紧接着X13，X15这一系列就有人开发出来了。 S系列算法实际是一种串联思路，只要其中一种算法被破解，整个算法就被破解了，好比一根链条，环环相扣，只要其中一环断裂，整个链条就一分为二。 &nbsp; 并联算法 &nbsp; &nbsp; 有人串联，就有人并联，Heavycoin（HVC）率先做了尝试。HVC如今在国内名不见经传，当时还是名噪一时，首次实现链上游戏，作者是俄罗斯人，后来不幸英年早逝，在币圈引起一阵惋惜。 HVC算法细节： &nbsp; 对输入数据首先运行一次HEFTY1（一种Hash算法）运算，得到结果d1 &nbsp;以d1为输入，依次进行SHA256、KECCAK512、GROESTL512、BLAKE512运算，分别获得输出d2,d3,d4和d5 分别提取d2-d5前64位，混淆后形成最终的256位Hash结果，作为区块ID。 &nbsp; 之所以首先进行一轮HEFTY1 哈希，是因为HEFTY1 运算起来极其困难，其抵御矿机性能远超于SCRYPT。但与SCRYPT一样，安全性没有得到某个官方机构论证，于是加入后面的四种安全性已经得到公认的算法增强安全。 对比串联和并联的方法，Quark、X11，X13等虽使用了多种HASH函数，但这些算法都是简单的将多种HASH函数串联在一起，仔细思考，其实没有提高整体的抗碰撞性，其安全性更是因木桶效应而由其中安全最弱的算法支撑，其中任何一种Hash函数遭遇碰撞性攻击，都会危及货币系统的安全性。 HVC从以上每种算法提取64位，经过融合成为最后的结果，实际上是将四种算法并联在一起，其中一种算法被破解只会危及其中64位，四中算法同时被破解才会危及货币系统的安全性。 比特币只使用了一种Hash算法，假如未来某日SHA256被证明不再安全时，虽然可以更该算法，但考虑到如今“硬分叉猛于虎”的局面，届时引发动荡不可避免，但如果使用并联算法，就可以争取平静的硬分叉过渡时间。 &nbsp; PRIMECOIN &nbsp; &nbsp; 正当一部分人在算法探索之路上进行的如火如荼之时，另一部分人的声音也非常刺耳，那就是指责POW浪费能源（彼时POS机制已经实现）。POW党虽极力维护，但也承认耗费能源这一事实。这一指责打开了另一条探索之路，即如果能找到一种算法，既能维护区块链安全，这些Hash运算又能在其他方面产生价值，那简直更完美。 在这条探索之路上最让人振奋人心的成果来自于Sunny King（这大神之前已经开发了Peercoin，点点币）发明的素数币（Primecoin）。素数币算法的核心理念是：在做Hash运算的同时寻找大素数。素数如今已被广泛应用于各个领域，但人类对他的认识还是有限。素数在数轴上不但稀有（相对于偶数而言），而且分布不规律，在数轴上寻找素数只能盲目搜索探测，这正是POW的特征。 POW还有另一个要求是容易验证，这方面人类经过几百年探索已经获得一些成果。素数币使用两种方法测试，首先进行费马测试（Fermat Test），通过则再进行欧拉-拉格朗日-立夫习兹测试（Euler-Lagrange-Lifchitz Test），还通过测试则被视为是素数。需要指出的是，这种方法并不能保证通过测试的数百分百是素数，不过这并不影响系统运行，即便测试结果错误，只要每个节点都认为是素数就行。 素数币其实找的是素数链-坎氏链，存在三个特定类型的坎氏素数链：第一类坎氏链，第二类坎氏链和双坎氏链。 举第一类来说明，规则是：素数链中每个数都是前一个数的两倍减一，比如： 1531，3061，6121，12241，24481 数列的下一个数48961(24481*2-1)不是素数，因而这个坎氏链的长度是5，素数币的目标就是探索更长的坎氏链（以上三类都可以）。 &nbsp; 那么现在最重要的问题来了，如何用坎氏链来验证一个区块是否合格呢？素数币实现的细节是这样的： 计算中本聪区块头Hash，hashBlockHeader = SHA256(BlockHeader) 通过变换获得坎氏链的第一个数：originNum = hashBlockHeader * Multiplier 获取originNum之后就可以测试并计算素数链长度的整数部分，小数部分的计算与坎氏链最后一个非素数的跨度相关。 &nbsp; 每个区块的乘积因子Multiplier各不相同，计算过程和hashBlockHeader相关，素数币为此对区块头进行修改，专门增加一个字段（bnPrimeChainMultiplier）来存放这个乘积因子。但是以上第一步计算hashBlockHeader时输入数据并不包含这个乘积因子，这也是为啥特别指出中本聪区块头。 由于素数在数轴上分布不均匀，且根据目前掌握的知识来看，数越大，素数越稀有，寻找难度并不是线性递增，耗时也就不可预估，但是区块链要求稳定出块。正因为这点，素数币算法没有得到热捧，但这种探索并非没有意义，利用POW工作量的“幻想”并没有停止，探索还在继续。 &nbsp; ETHASH &nbsp; &nbsp; 以太坊（Ethereum）一开始就打算使用POS方式，但由于POS设计存在一些问题，开发团队决定在以太坊1.0阶段使用POW方式，预计在Serenity阶段转入POS。 以太坊POW算法叫Ethash，虽只是一个过渡算法，但开发团队一点也不含糊，一如既往发扬其“简单问题复杂化，繁琐细节秀智商”的设计风格。Ethash 是最新版本的 Dagger-Hashimoto改良算法，是Hashimoto算法结合Dagger算法产成的一个新变种。Ethash设计时就明确两大目标： 抵御矿机性能（ASIC-resistance），团队希望CPU也能参与挖矿获得收益。 轻客户端可快速验证（Light client verifiability）。 基于以上两个目标，开发团队最后倒腾出来的Ethash挖矿时基本与CPU性能无关，却和内存大小和内存带宽成正相关。不过在实现上还是借鉴了SHA3的设计思路，但是使用的”SHA3_256” ,”SHA3_512”与标准实现很不同。 &nbsp; Ethash基本流程是这样的：对于每一个块，首先计算一个种子（seed），该种子只和当前块的信息有关；然后根据种子生成一个32M的随机数据集（Cache）；紧接着根据Cache生成一个1GB大小的数据集合（DAG），DAG可以理解为一个完整的搜索空间，挖矿的过程就是从DAG中随机选择元素（类似于比特币挖矿中查找合适Nonce）再进行哈希运算。可以从Cache快速计算DAG指定位置的元素，进而哈希验证。此外还要求对Cache和DAG进行周期性更新，每1000个块更新一次，并且规定DAG的大小随着时间推移线性增长，从1G开始，每年大约增长7G左右。 &nbsp; EQUIHASH &nbsp; &nbsp; 最近在国内发展势头最猛的莫过于Zcash，该币种最大的特点是使用零知识证明实现隐私交易。距离发布还有几天，但从社区讨论来看，各方矿工都已在磨刀霍霍。Zcash对于算法的选择非常慎重，在先后考量了SHA256D，SCRYPT，CUCKOO HASH以及LYRA2等算法后，最终选择Equihash。 Equihash算法由Alex Biryukov 和 Dmitry Khovratovich联合发明，其理论依据是一个著名的计算法科学及密码学问题——广义生日悖论问题。Equihash是一个内存（ARM）依赖型算法，机器算力大小主要取决于拥有多少内存，根据两位发明者的论文描述，该算法执行至少需要700M内存，1.8 GHz CPU计算30秒，经Zcash项目优化后，目前每个挖矿线程需要1G内存，因此Zcash官方认为该算法在短时间内很难出现矿机（ASIC）。此外，Zcash官方还相信该算法比较公平，他们认为很难有人或者机构能够对算法偷偷进行优化，因为广义生日悖论是一个已经被广泛研究的问题。此外，Equihash算法非常容易验证，这对于未来在受限设备上实现Zcash轻客户端非常重要。 Zcash官方团队选择Equihash完全出于抵御矿机性能的需求，他们在官方博客中也承认并不敢确保Equihash一定是安全的，并表示如果发现Equihash存在问题，或者发现更优算法，Zcash会改变POW算法。 &nbsp; 总结 &nbsp; &nbsp; 随着比特币、莱特币矿机相继出现，大家已经认识到没有不能开发矿机的算法，想通过改进算法来彻底阻止矿机和矿池的出现是不可能的。另外，从近几年的发展来看，矿池也没有之前想的那么可怕，甚至已经有人论证了矿池并没有破坏去中心化。但除了安全性，POW往往伴随分发代币功能，从这个角度来说，CPU算法更具公平性，用户门槛更低，这也是算法创新的驱动，从Ethash以及Equihash设计来看，目前的算法创新仍然是以追求内存高消耗为主。以此同时，社区在共识机制的探索之路上也取得很多成果。纵观当前区块链核心技术发展全局，算法创新热潮已经有所消退，但也未停止，于比特币，于区块链，于算法探索而言，都还在路上。" />
<link rel="canonical" href="https://mlh.app/2019/05/17/787369.html" />
<meta property="og:url" content="https://mlh.app/2019/05/17/787369.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-17T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"大多惊讶于这套系统的简洁和完美，甚至有人断言此物一出，开天辟地。如今近乎8年过去，当年看起来近乎完美的系统理念，在各个方面都有长足探索和发展。接下来我将写一系列文章，回顾区块链核心技术演进之路。包括算法演进，挖矿演进，共识机制演进，代币演进，隐私的演进，以及容量和速率的演进等。题目比较大，抛砖引玉，望读者指正和补充。 &nbsp; 算法演进 &nbsp; &nbsp; 关于“算法”一词，目前国内用户使用的比较模糊，有时指共识机制，比如POW算法，POS算法；有时指具体的Hash算法，比如SHA256，SCRYPT。应该说这是由于早期从外文资料翻译过来概念模糊导致的错误，后来人云亦云。共识机制（以前一般叫Proof，现在经常使用Consensus）和算法（Algorithm）在英文资料里语义清晰，不能混为一谈，两者都是区块链技术体系里的重要支柱。 因此当我们说“X币使用Y算法”的时候，其实具体指的是采用何种Hash算法，而且隐含的前提条件是这个币使用POW证明方式。只有在POW下讨论选取何种算法才有意义，算法的各种复杂设计才能体现其用处。为什么呢，中本聪在设计比特币的时候其实有很多地方用到Hash函数，比如计算区块ID，计算交易ID，构造代币地址等。我们说的算法具体是指用何种Hash函数计算区块ID，所谓算法创新也就是在这个地方下功夫。此外其他任何用到Hash函数的地方，对计算难度没有要求，而且应该选用可以快速运算的算法，尤其在计算交易ID时候，不然影响区块链同步速度。因此如果选用POS方式，计算区块ID也应该使用容易运算的算法。 &nbsp; Hash函数 &nbsp; &nbsp; 如上所言，我们经常说的POW算法本质是一个Hash函数。Hash函数是一个无比神奇的东西，说他替中本聪打下了半壁江山一点不为过，学习比特币应该从学习Hash函数入手，理解了Hash函数再去学比特币原理将事半功倍，不然将处处感觉混沌，难以开窍。而中本聪也将Hash函数的所有特性使用得淋漓尽致： 已经有很多Hash函数被设计出来并广泛应用，不过Hash函数一般安全寿命都不长，被认为安全的算法往往没能使用多久就被成功攻击，新的更安全的算法相继被设计出来，而每一个被公认为安全可靠的算法都有及其严格的审计过程。在币圈中我们经常说某某币发明了某种算法，其实主要都是使用那些被认证过的安全算法，或是单独使用，或是排列组合使用。 &nbsp; SHA256 &nbsp; &nbsp; SHA (Secure Hash Algorithm，译作安全散列算法) 是美国国家安全局 (NSA) 设计，美国国家标准与技术研究院 (NIST) 发布的一系列密码散列函数，经历了SHA-0，SHA-1，SHA-2，SHA-3系列发展。NSA于2007年正式宣布在全球范围内征集新新一代（SHA-3）算法设计，2012年公布评选结果， Keccak算法最终获胜成为唯一官方标准SHA-3算法，但还有四种算法同时进入了第三轮评选，分别是：BLAKE, GrøSTL, JH和SKEIN，这些算法其实也非常安全，而且经受审查，被各种竞争币频繁使用。 比特币采用SHA256算法，该算法属于SHA-2系列，在中本聪发明比特币时（2008）被公认为最安全最先进的算法之一。除了生成地址中有一个环节使用了REPID-160算法，比特币系统中但凡有需要做Hash运算的地方都是用SHA256。随着比特币被更多人了解，大家开始好奇中本聪为何选择了SHA256，同时对SHA256的安全性发表各种意见，SHA256妥妥经受了质疑，到目前为止，没有公开的证据表明SHA256有漏洞，SHA256依然牢牢抗住保卫比特币安全的大旗。当然大家心里都明白，没有永远安全的算法，SHA256被替代是早晚的事，中本聪自己也说明了算法升级的必要和过程。 &nbsp; SCRYPT &nbsp; &nbsp; 后来随着显卡挖矿以及矿池的出现，社区开始担心矿池会导致算力集中，违背中本聪“一CPU一票”的最初设计理念。在那段时间，中心化的焦虑非常严重，讨论很激烈，比特币一次又一次“被死亡”，直到现在，针对矿池是否违背去中心化原则的争论仍在继续。 无论如何，有人将矛头指向SHA256，认为是算法太容易导致矿机和矿池出现，并试图寻找更难的算法。 恰逢其时，使用SCRYPT算法的莱特币（Litecoin）横空出世。据说SCRYPT是由一位著名的黑客开发，由于没有得到诸如SHA系列的严格的安全审查和全面论证，一直没被广泛推广使用。与SHA256算法相比，SCRYPT占用的内存更多，计算时间更长，并行计算异常困难，对硬件要求很高。很显然，SCRYPT算法具有更强的抵御矿机性，莱特币还将区块时间改为2.5分钟，在那个山寨币还凤毛麟角年代，莱特币依靠这两点创新大获成功，长期稳坐山寨币第一宝座位置。 后来有人在SCRYPT的基础上稍作修改形成Scrypt –N算法，改进思路都一样，都是追求更大的内存消耗和计算时间，以有效阻止ASIC专用矿机。 很快，莱特币的成功催生了各种各样的算法创新，2012至2014年间，算法创新一直都是社区讨论的热门话题，每一个使用创新算法的币种出现，都能刮起一阵波澜。 &nbsp; 串联算法 &nbsp; &nbsp; 重新排列组合是人类一贯以来最常用的创新发明方法。很快，有人不满足于使用单一Hash函数，2013年7月，夸克币（Quark）发布，首创使用多轮Hash算法，看似高大上，其实很简单，就是对输入数据运算了9次hash函数，前一轮运算结果作为后一轮运算的输入。这9轮Hash共使用6种加密算法，分别为BLAKE, BMW, GROESTL, JH, KECCAK和SKEIN，这些都是公认的安全Hash算法，并且早已存在现成的实现代码。 这种多轮Hash一出现就给人造成直观上很安全很强大的感觉，追捧者无数。现今价格依然坚挺的达世币（DASH，前身是暗黑币，Darkcoin，）接过下一棒，率先使用11种加密算法（BLAKE, BMW, GROESTL, JH, KECCAK, SKEIN, LUFFA, CUBEHASH, SHAVITE, SIMD, ECHO），美其名曰X11，紧接着X13，X15这一系列就有人开发出来了。 S系列算法实际是一种串联思路，只要其中一种算法被破解，整个算法就被破解了，好比一根链条，环环相扣，只要其中一环断裂，整个链条就一分为二。 &nbsp; 并联算法 &nbsp; &nbsp; 有人串联，就有人并联，Heavycoin（HVC）率先做了尝试。HVC如今在国内名不见经传，当时还是名噪一时，首次实现链上游戏，作者是俄罗斯人，后来不幸英年早逝，在币圈引起一阵惋惜。 HVC算法细节： &nbsp; 对输入数据首先运行一次HEFTY1（一种Hash算法）运算，得到结果d1 &nbsp;以d1为输入，依次进行SHA256、KECCAK512、GROESTL512、BLAKE512运算，分别获得输出d2,d3,d4和d5 分别提取d2-d5前64位，混淆后形成最终的256位Hash结果，作为区块ID。 &nbsp; 之所以首先进行一轮HEFTY1 哈希，是因为HEFTY1 运算起来极其困难，其抵御矿机性能远超于SCRYPT。但与SCRYPT一样，安全性没有得到某个官方机构论证，于是加入后面的四种安全性已经得到公认的算法增强安全。 对比串联和并联的方法，Quark、X11，X13等虽使用了多种HASH函数，但这些算法都是简单的将多种HASH函数串联在一起，仔细思考，其实没有提高整体的抗碰撞性，其安全性更是因木桶效应而由其中安全最弱的算法支撑，其中任何一种Hash函数遭遇碰撞性攻击，都会危及货币系统的安全性。 HVC从以上每种算法提取64位，经过融合成为最后的结果，实际上是将四种算法并联在一起，其中一种算法被破解只会危及其中64位，四中算法同时被破解才会危及货币系统的安全性。 比特币只使用了一种Hash算法，假如未来某日SHA256被证明不再安全时，虽然可以更该算法，但考虑到如今“硬分叉猛于虎”的局面，届时引发动荡不可避免，但如果使用并联算法，就可以争取平静的硬分叉过渡时间。 &nbsp; PRIMECOIN &nbsp; &nbsp; 正当一部分人在算法探索之路上进行的如火如荼之时，另一部分人的声音也非常刺耳，那就是指责POW浪费能源（彼时POS机制已经实现）。POW党虽极力维护，但也承认耗费能源这一事实。这一指责打开了另一条探索之路，即如果能找到一种算法，既能维护区块链安全，这些Hash运算又能在其他方面产生价值，那简直更完美。 在这条探索之路上最让人振奋人心的成果来自于Sunny King（这大神之前已经开发了Peercoin，点点币）发明的素数币（Primecoin）。素数币算法的核心理念是：在做Hash运算的同时寻找大素数。素数如今已被广泛应用于各个领域，但人类对他的认识还是有限。素数在数轴上不但稀有（相对于偶数而言），而且分布不规律，在数轴上寻找素数只能盲目搜索探测，这正是POW的特征。 POW还有另一个要求是容易验证，这方面人类经过几百年探索已经获得一些成果。素数币使用两种方法测试，首先进行费马测试（Fermat Test），通过则再进行欧拉-拉格朗日-立夫习兹测试（Euler-Lagrange-Lifchitz Test），还通过测试则被视为是素数。需要指出的是，这种方法并不能保证通过测试的数百分百是素数，不过这并不影响系统运行，即便测试结果错误，只要每个节点都认为是素数就行。 素数币其实找的是素数链-坎氏链，存在三个特定类型的坎氏素数链：第一类坎氏链，第二类坎氏链和双坎氏链。 举第一类来说明，规则是：素数链中每个数都是前一个数的两倍减一，比如： 1531，3061，6121，12241，24481 数列的下一个数48961(24481*2-1)不是素数，因而这个坎氏链的长度是5，素数币的目标就是探索更长的坎氏链（以上三类都可以）。 &nbsp; 那么现在最重要的问题来了，如何用坎氏链来验证一个区块是否合格呢？素数币实现的细节是这样的： 计算中本聪区块头Hash，hashBlockHeader = SHA256(BlockHeader) 通过变换获得坎氏链的第一个数：originNum = hashBlockHeader * Multiplier 获取originNum之后就可以测试并计算素数链长度的整数部分，小数部分的计算与坎氏链最后一个非素数的跨度相关。 &nbsp; 每个区块的乘积因子Multiplier各不相同，计算过程和hashBlockHeader相关，素数币为此对区块头进行修改，专门增加一个字段（bnPrimeChainMultiplier）来存放这个乘积因子。但是以上第一步计算hashBlockHeader时输入数据并不包含这个乘积因子，这也是为啥特别指出中本聪区块头。 由于素数在数轴上分布不均匀，且根据目前掌握的知识来看，数越大，素数越稀有，寻找难度并不是线性递增，耗时也就不可预估，但是区块链要求稳定出块。正因为这点，素数币算法没有得到热捧，但这种探索并非没有意义，利用POW工作量的“幻想”并没有停止，探索还在继续。 &nbsp; ETHASH &nbsp; &nbsp; 以太坊（Ethereum）一开始就打算使用POS方式，但由于POS设计存在一些问题，开发团队决定在以太坊1.0阶段使用POW方式，预计在Serenity阶段转入POS。 以太坊POW算法叫Ethash，虽只是一个过渡算法，但开发团队一点也不含糊，一如既往发扬其“简单问题复杂化，繁琐细节秀智商”的设计风格。Ethash 是最新版本的 Dagger-Hashimoto改良算法，是Hashimoto算法结合Dagger算法产成的一个新变种。Ethash设计时就明确两大目标： 抵御矿机性能（ASIC-resistance），团队希望CPU也能参与挖矿获得收益。 轻客户端可快速验证（Light client verifiability）。 基于以上两个目标，开发团队最后倒腾出来的Ethash挖矿时基本与CPU性能无关，却和内存大小和内存带宽成正相关。不过在实现上还是借鉴了SHA3的设计思路，但是使用的”SHA3_256” ,”SHA3_512”与标准实现很不同。 &nbsp; Ethash基本流程是这样的：对于每一个块，首先计算一个种子（seed），该种子只和当前块的信息有关；然后根据种子生成一个32M的随机数据集（Cache）；紧接着根据Cache生成一个1GB大小的数据集合（DAG），DAG可以理解为一个完整的搜索空间，挖矿的过程就是从DAG中随机选择元素（类似于比特币挖矿中查找合适Nonce）再进行哈希运算。可以从Cache快速计算DAG指定位置的元素，进而哈希验证。此外还要求对Cache和DAG进行周期性更新，每1000个块更新一次，并且规定DAG的大小随着时间推移线性增长，从1G开始，每年大约增长7G左右。 &nbsp; EQUIHASH &nbsp; &nbsp; 最近在国内发展势头最猛的莫过于Zcash，该币种最大的特点是使用零知识证明实现隐私交易。距离发布还有几天，但从社区讨论来看，各方矿工都已在磨刀霍霍。Zcash对于算法的选择非常慎重，在先后考量了SHA256D，SCRYPT，CUCKOO HASH以及LYRA2等算法后，最终选择Equihash。 Equihash算法由Alex Biryukov 和 Dmitry Khovratovich联合发明，其理论依据是一个著名的计算法科学及密码学问题——广义生日悖论问题。Equihash是一个内存（ARM）依赖型算法，机器算力大小主要取决于拥有多少内存，根据两位发明者的论文描述，该算法执行至少需要700M内存，1.8 GHz CPU计算30秒，经Zcash项目优化后，目前每个挖矿线程需要1G内存，因此Zcash官方认为该算法在短时间内很难出现矿机（ASIC）。此外，Zcash官方还相信该算法比较公平，他们认为很难有人或者机构能够对算法偷偷进行优化，因为广义生日悖论是一个已经被广泛研究的问题。此外，Equihash算法非常容易验证，这对于未来在受限设备上实现Zcash轻客户端非常重要。 Zcash官方团队选择Equihash完全出于抵御矿机性能的需求，他们在官方博客中也承认并不敢确保Equihash一定是安全的，并表示如果发现Equihash存在问题，或者发现更优算法，Zcash会改变POW算法。 &nbsp; 总结 &nbsp; &nbsp; 随着比特币、莱特币矿机相继出现，大家已经认识到没有不能开发矿机的算法，想通过改进算法来彻底阻止矿机和矿池的出现是不可能的。另外，从近几年的发展来看，矿池也没有之前想的那么可怕，甚至已经有人论证了矿池并没有破坏去中心化。但除了安全性，POW往往伴随分发代币功能，从这个角度来说，CPU算法更具公平性，用户门槛更低，这也是算法创新的驱动，从Ethash以及Equihash设计来看，目前的算法创新仍然是以追求内存高消耗为主。以此同时，社区在共识机制的探索之路上也取得很多成果。纵观当前区块链核心技术发展全局，算法创新热潮已经有所消退，但也未停止，于比特币，于区块链，于算法探索而言，都还在路上。","@type":"BlogPosting","url":"https://mlh.app/2019/05/17/787369.html","headline":"区块链核心技术演进之路－算法演进","dateModified":"2019-05-17T00:00:00+08:00","datePublished":"2019-05-17T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/05/17/787369.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>区块链核心技术演进之路－算法演进</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>大多惊讶于这套系统的简洁和完美，甚至有人断言此物一出，开天辟地。如今近乎8年过去，当年看起来近乎完美的系统理念，在各个方面都有长足探索和发展。接下来我将写一系列文章，回顾区块链核心技术演进之路。包括算法演进，挖矿演进，共识机制演进，代币演进，隐私的演进，以及容量和速率的演进等。题目比较大，抛砖引玉，望读者指正和补充。</p> 
  <p>&nbsp;</p> 
  <h2>算法演进</h2> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>关于“算法”一词，目前国内用户使用的比较模糊，有时指共识机制，比如POW算法，POS算法；有时指具体的Hash算法，比如SHA256，SCRYPT。应该说这是由于早期从外文资料翻译过来概念模糊导致的错误，后来人云亦云。共识机制（以前一般叫Proof，现在经常使用Consensus）和算法（Algorithm）在英文资料里语义清晰，不能混为一谈，两者都是区块链技术体系里的重要支柱。</p> 
  <p>因此当我们说“X币使用Y算法”的时候，其实具体指的是采用何种Hash算法，而且隐含的前提条件是这个币使用POW证明方式。只有在POW下讨论选取何种算法才有意义，算法的各种复杂设计才能体现其用处。为什么呢，中本聪在设计比特币的时候其实有很多地方用到Hash函数，比如计算区块ID，计算交易ID，构造代币地址等。我们说的算法具体是指用何种Hash函数计算区块ID，所谓算法创新也就是在这个地方下功夫。此外其他任何用到Hash函数的地方，对计算难度没有要求，而且应该选用可以快速运算的算法，尤其在计算交易ID时候，不然影响区块链同步速度。因此如果选用POS方式，计算区块ID也应该使用容易运算的算法。</p> 
  <p>&nbsp;</p> 
  <h2>Hash函数</h2> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>如上所言，我们经常说的POW算法本质是一个Hash函数。Hash函数是一个无比神奇的东西，说他替中本聪打下了半壁江山一点不为过，学习比特币应该从学习Hash函数入手，理解了Hash函数再去学比特币原理将事半功倍，不然将处处感觉混沌，难以开窍。而中本聪也将Hash函数的所有特性使用得淋漓尽致：</p> 
  <p><img alt="p1" class="has" height="505" src="https://cdn.8btc.com/wp-content/uploads/2016/10/p11.png" width="505"></p> 
  <p>已经有很多Hash函数被设计出来并广泛应用，不过Hash函数一般安全寿命都不长，被认为安全的算法往往没能使用多久就被成功攻击，新的更安全的算法相继被设计出来，而每一个被公认为安全可靠的算法都有及其严格的审计过程。在币圈中我们经常说某某币发明了某种算法，其实主要都是使用那些被认证过的安全算法，或是单独使用，或是排列组合使用。</p> 
  <p>&nbsp;</p> 
  <h2>SHA256</h2> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>SHA (Secure Hash Algorithm，译作安全散列算法) 是美国国家安全局 (NSA) 设计，美国国家标准与技术研究院 (NIST) 发布的一系列密码散列函数，经历了SHA-0，SHA-1，SHA-2，SHA-3系列发展。NSA于2007年正式宣布在全球范围内征集新新一代（SHA-3）算法设计，2012年公布评选结果， Keccak算法最终获胜成为唯一官方标准SHA-3算法，但还有四种算法同时进入了第三轮评选，分别是：BLAKE, GrøSTL, JH和SKEIN，这些算法其实也非常安全，而且经受审查，被各种竞争币频繁使用。 比特币采用SHA256算法，该算法属于SHA-2系列，在中本聪发明比特币时（2008）被公认为最安全最先进的算法之一。除了生成地址中有一个环节使用了REPID-160算法，比特币系统中但凡有需要做Hash运算的地方都是用SHA256。随着比特币被更多人了解，大家开始好奇中本聪为何选择了SHA256，同时对SHA256的安全性发表各种意见，SHA256妥妥经受了质疑，到目前为止，没有公开的证据表明SHA256有漏洞，SHA256依然牢牢抗住保卫比特币安全的大旗。当然大家心里都明白，没有永远安全的算法，SHA256被替代是早晚的事，中本聪自己也说明了算法升级的必要和过程。</p> 
  <p>&nbsp;</p> 
  <h2>SCRYPT</h2> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>后来随着显卡挖矿以及矿池的出现，社区开始担心矿池会导致算力集中，违背中本聪“一CPU一票”的最初设计理念。在那段时间，中心化的焦虑非常严重，讨论很激烈，比特币一次又一次“被死亡”，直到现在，针对矿池是否违背去中心化原则的争论仍在继续。</p> 
  <p>无论如何，有人将矛头指向SHA256，认为是算法太容易导致矿机和矿池出现，并试图寻找更难的算法。</p> 
  <p>恰逢其时，使用SCRYPT算法的莱特币（Litecoin）横空出世。据说SCRYPT是由一位著名的黑客开发，由于没有得到诸如SHA系列的严格的安全审查和全面论证，一直没被广泛推广使用。与SHA256算法相比，SCRYPT占用的内存更多，计算时间更长，并行计算异常困难，对硬件要求很高。很显然，SCRYPT算法具有更强的抵御矿机性，莱特币还将区块时间改为2.5分钟，在那个山寨币还凤毛麟角年代，莱特币依靠这两点创新大获成功，长期稳坐山寨币第一宝座位置。</p> 
  <p>后来有人在SCRYPT的基础上稍作修改形成Scrypt –N算法，改进思路都一样，都是追求更大的内存消耗和计算时间，以有效阻止ASIC专用矿机。</p> 
  <p>很快，莱特币的成功催生了各种各样的算法创新，2012至2014年间，算法创新一直都是社区讨论的热门话题，每一个使用创新算法的币种出现，都能刮起一阵波澜。</p> 
  <p>&nbsp;</p> 
  <h2>串联算法</h2> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>重新排列组合是人类一贯以来最常用的创新发明方法。很快，有人不满足于使用单一Hash函数，2013年7月，夸克币（Quark）发布，首创使用多轮Hash算法，看似高大上，其实很简单，就是对输入数据运算了9次hash函数，前一轮运算结果作为后一轮运算的输入。这9轮Hash共使用6种加密算法，分别为BLAKE, BMW, GROESTL, JH, KECCAK和SKEIN，这些都是公认的安全Hash算法，并且早已存在现成的实现代码。</p> 
  <p>这种多轮Hash一出现就给人造成直观上很安全很强大的感觉，追捧者无数。现今价格依然坚挺的达世币（DASH，前身是暗黑币，Darkcoin，）接过下一棒，率先使用11种加密算法（BLAKE, BMW, GROESTL, JH, KECCAK, SKEIN, LUFFA, CUBEHASH, SHAVITE, SIMD, ECHO），美其名曰X11，紧接着X13，X15这一系列就有人开发出来了。</p> 
  <p>S系列算法实际是一种串联思路，只要其中一种算法被破解，整个算法就被破解了，好比一根链条，环环相扣，只要其中一环断裂，整个链条就一分为二。</p> 
  <p>&nbsp;</p> 
  <h2>并联算法</h2> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>有人串联，就有人并联，Heavycoin（HVC）率先做了尝试。HVC如今在国内名不见经传，当时还是名噪一时，首次实现链上游戏，作者是俄罗斯人，后来不幸英年早逝，在币圈引起一阵惋惜。</p> 
  <p>HVC算法细节：</p> 
  <p>&nbsp;</p> 
  <ol>
   <li>对输入数据首先运行一次HEFTY1（一种Hash算法）运算，得到结果d1</li> 
   <li>&nbsp;以d1为输入，依次进行SHA256、KECCAK512、GROESTL512、BLAKE512运算，分别获得输出d2,d3,d4和d5</li> 
   <li>分别提取d2-d5前64位，混淆后形成最终的256位Hash结果，作为区块ID。</li> 
  </ol>
  <p><img alt="p2" class="has" height="319" src="https://cdn.8btc.com/wp-content/uploads/2016/10/p21.png" width="866"></p> 
  <p>&nbsp;</p> 
  <p>之所以首先进行一轮HEFTY1 哈希，是因为HEFTY1 运算起来极其困难，其抵御矿机性能远超于SCRYPT。但与SCRYPT一样，安全性没有得到某个官方机构论证，于是加入后面的四种安全性已经得到公认的算法增强安全。</p> 
  <p>对比串联和并联的方法，Quark、X11，X13等虽使用了多种HASH函数，但这些算法都是简单的将多种HASH函数串联在一起，仔细思考，其实没有提高整体的抗碰撞性，其安全性更是因木桶效应而由其中安全最弱的算法支撑，其中任何一种Hash函数遭遇碰撞性攻击，都会危及货币系统的安全性。</p> 
  <p>HVC从以上每种算法提取64位，经过融合成为最后的结果，实际上是将四种算法并联在一起，其中一种算法被破解只会危及其中64位，四中算法同时被破解才会危及货币系统的安全性。</p> 
  <p><img alt="p3" class="has" height="436" src="https://cdn.8btc.com/wp-content/uploads/2016/10/p31.png" width="436"></p> 
  <p>比特币只使用了一种Hash算法，假如未来某日SHA256被证明不再安全时，虽然可以更该算法，但考虑到如今“硬分叉猛于虎”的局面，届时引发动荡不可避免，但如果使用并联算法，就可以争取平静的硬分叉过渡时间。</p> 
  <p>&nbsp;</p> 
  <h1>PRIMECOIN</h1> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>正当一部分人在算法探索之路上进行的如火如荼之时，另一部分人的声音也非常刺耳，那就是指责POW浪费能源（彼时POS机制已经实现）。POW党虽极力维护，但也承认耗费能源这一事实。这一指责打开了另一条探索之路，即如果能找到一种算法，既能维护区块链安全，这些Hash运算又能在其他方面产生价值，那简直更完美。</p> 
  <p>在这条探索之路上最让人振奋人心的成果来自于Sunny King（这大神之前已经开发了Peercoin，点点币）发明的素数币（Primecoin）。素数币算法的核心理念是：在做Hash运算的同时寻找大素数。素数如今已被广泛应用于各个领域，但人类对他的认识还是有限。素数在数轴上不但稀有（相对于偶数而言），而且分布不规律，在数轴上寻找素数只能盲目搜索探测，这正是POW的特征。 POW还有另一个要求是容易验证，这方面人类经过几百年探索已经获得一些成果。素数币使用两种方法测试，首先进行费马测试（Fermat Test），通过则再进行欧拉-拉格朗日-立夫习兹测试（Euler-Lagrange-Lifchitz Test），还通过测试则被视为是素数。需要指出的是，这种方法并不能保证通过测试的数百分百是素数，不过这并不影响系统运行，即便测试结果错误，只要每个节点都认为是素数就行。</p> 
  <p>素数币其实找的是素数链-坎氏链，存在三个特定类型的坎氏素数链：第一类坎氏链，第二类坎氏链和双坎氏链。 举第一类来说明，规则是：素数链中每个数都是前一个数的两倍减一，比如：</p> 
  <p>1531，3061，6121，12241，24481</p> 
  <p>数列的下一个数48961(24481*2-1)不是素数，因而这个坎氏链的长度是5，素数币的目标就是探索更长的坎氏链（以上三类都可以）。</p> 
  <p>&nbsp;</p> 
  <p>那么现在最重要的问题来了，如何用坎氏链来验证一个区块是否合格呢？素数币实现的细节是这样的：</p> 
  <ol>
   <li>计算中本聪区块头Hash，hashBlockHeader = SHA256(BlockHeader)</li> 
   <li>通过变换获得坎氏链的第一个数：originNum = hashBlockHeader * Multiplier</li> 
  </ol>
  <p>获取originNum之后就可以测试并计算素数链长度的整数部分，小数部分的计算与坎氏链最后一个非素数的跨度相关。</p> 
  <p>&nbsp;</p> 
  <p>每个区块的乘积因子Multiplier各不相同，计算过程和hashBlockHeader相关，素数币为此对区块头进行修改，专门增加一个字段（bnPrimeChainMultiplier）来存放这个乘积因子。但是以上第一步计算hashBlockHeader时输入数据并不包含这个乘积因子，这也是为啥特别指出中本聪区块头。</p> 
  <p>由于素数在数轴上分布不均匀，且根据目前掌握的知识来看，数越大，素数越稀有，寻找难度并不是线性递增，耗时也就不可预估，但是区块链要求稳定出块。正因为这点，素数币算法没有得到热捧，但这种探索并非没有意义，利用POW工作量的“幻想”并没有停止，探索还在继续。</p> 
  <p>&nbsp;</p> 
  <h2>ETHASH</h2> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p><a href="http://www.8btc.com/ethereumfolk" rel="nofollow">以太坊</a>（Ethereum）一开始就打算使用POS方式，但由于POS设计存在一些问题，开发团队决定在以太坊1.0阶段使用POW方式，预计在Serenity阶段转入POS。 以太坊POW算法叫Ethash，虽只是一个过渡算法，但开发团队一点也不含糊，一如既往发扬其“简单问题复杂化，繁琐细节秀智商”的设计风格。Ethash 是最新版本的 Dagger-Hashimoto改良算法，是Hashimoto算法结合Dagger算法产成的一个新变种。Ethash设计时就明确两大目标：</p> 
  <ol>
   <li>抵御矿机性能（ASIC-resistance），团队希望CPU也能参与挖矿获得收益。</li> 
   <li>轻客户端可快速验证（Light client verifiability）。</li> 
  </ol>
  <p>基于以上两个目标，开发团队最后倒腾出来的Ethash挖矿时基本与CPU性能无关，却和内存大小和内存带宽成正相关。不过在实现上还是借鉴了SHA3的设计思路，但是使用的”SHA3_256” ,”SHA3_512”与标准实现很不同。</p> 
  <p>&nbsp;</p> 
  <p>Ethash基本流程是这样的：对于每一个块，首先计算一个种子（seed），该种子只和当前块的信息有关；然后根据种子生成一个32M的随机数据集（Cache）；紧接着根据Cache生成一个1GB大小的数据集合（DAG），DAG可以理解为一个完整的搜索空间，挖矿的过程就是从DAG中随机选择元素（类似于比特币挖矿中查找合适Nonce）再进行哈希运算。可以从Cache快速计算DAG指定位置的元素，进而哈希验证。此外还要求对Cache和DAG进行周期性更新，每1000个块更新一次，并且规定DAG的大小随着时间推移线性增长，从1G开始，每年大约增长7G左右。</p> 
  <p>&nbsp;</p> 
  <h2>EQUIHASH</h2> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>最近在国内发展势头最猛的莫过于<a href="http://www.8btc.com/upcoming-zcash-launch" rel="nofollow">Zcash</a>，该币种最大的特点是使用零知识证明实现隐私交易。距离发布还有几天，但从社区讨论来看，各方矿工都已在磨刀霍霍。Zcash对于算法的选择非常慎重，在先后考量了SHA256D，SCRYPT，CUCKOO HASH以及LYRA2等算法后，最终选择Equihash。</p> 
  <p>Equihash算法由Alex Biryukov 和 Dmitry Khovratovich联合发明，其理论依据是一个著名的计算法科学及密码学问题——广义生日悖论问题。Equihash是一个内存（ARM）依赖型算法，机器算力大小主要取决于拥有多少内存，根据两位发明者的论文描述，该算法执行至少需要700M内存，1.8 GHz CPU计算30秒，经Zcash项目优化后，目前每个挖矿线程需要1G内存，因此Zcash官方认为该算法在短时间内很难出现矿机（ASIC）。此外，Zcash官方还相信该算法比较公平，他们认为很难有人或者机构能够对算法偷偷进行优化，因为广义生日悖论是一个已经被广泛研究的问题。此外，Equihash算法非常容易验证，这对于未来在受限设备上实现Zcash轻客户端非常重要。</p> 
  <p>Zcash官方团队选择Equihash完全出于抵御矿机性能的需求，他们在官方博客中也承认并不敢确保Equihash一定是安全的，并表示如果发现Equihash存在问题，或者发现更优算法，Zcash会改变POW算法。</p> 
  <p>&nbsp;</p> 
  <h2>总结</h2> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>随着比特币、莱特币矿机相继出现，大家已经认识到没有不能开发矿机的算法，想通过改进算法来彻底阻止矿机和矿池的出现是不可能的。另外，从近几年的发展来看，矿池也没有之前想的那么可怕，甚至已经有人论证了矿池并没有破坏去中心化。但除了安全性，POW往往伴随分发代币功能，从这个角度来说，CPU算法更具公平性，用户门槛更低，这也是算法创新的驱动，从Ethash以及Equihash设计来看，目前的算法创新仍然是以追求内存高消耗为主。以此同时，社区在共识机制的探索之路上也取得很多成果。纵观当前区块链核心技术发展全局，算法创新热潮已经有所消退，但也未停止，于比特币，于区块链，于算法探索而言，都还在路上。</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
