<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Web 组件即将取代前端框架？！  技术头条 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Web 组件即将取代前端框架？！  技术头条" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="【CSDN 编者按】提起前端开发，不少开发者首先会对主流技术框架如 Vue、React、Angular 进行一番对比之后，选择相应的技术架构。 在此，随着前端框架的不断升级，其也变得越来越臃肿与复杂，那么，未来前端框架是否会被取而代之？ 作者 |&nbsp;Danny Moerkerke 译者 |&nbsp;谭开朗 责编 | 屠敏 出品 | CSDN（ID：CSDNnews） 以下为译文： 还记得吗？当时document.querySelector首次被浏览器广泛采用，就此终结了jQuery的通用时代。对于多年来一直沿用jQuery来实现的功能，document.querySelector提供了原生方法：轻松的选取DOM元素。我相信，类似的情况也将会发生在诸如Angular和React的前端框架上。 前端框架为我们一直想做却未能做到的事情提供了可能：创建可复用的自动化前端组件，但它复杂性较高，还有专属语法和较高的有效负载。 前端框架正渐渐被取代。 现代Web API发展至今，我们已无需依赖框架来创建可复用的前端组件。我们所需创建的自定义组件就是自定义元素和影子DOM，这可以在任意地方复用。 2011年开始推出的Web组件，它支持仅通过HTML、CSS和JavaScript就能创建出可复用组件。这意味着，我们无需使用诸如React或Angular的框架就能构建出组件。更锦上添花的是，这些组件可以无缝集成到框架中。 有史以来第一次，我们仅通过HTML，CSS和JavaScript就成功构建了可兼容任意浏览器的可复用组件。Web组件现在可以兼容桌面最新的Chrome、Safari、Firefox和Opera浏览器，还有iOS的Safari浏览器和Android的Chrome浏览器。 Edge浏览器即将发布的第19版中也将得到兼容。对于较老的浏览器，它将会通过polyfill将其引入到IE 11浏览器中。 这意味着，目前基本任一浏览器都可以使用Web组件，包括移动端浏览器。 只需简单的引入一个脚本，我们就可以创建自定义HTML标签，它不仅继承了HTML元素扩展出的所有属性，还能在其支持的任意浏览器中使用。组件中定义的所有HTML，CSS和JavaScript都完全限定在组件的作用域内。 组件在浏览器的开发工具中显示为单个HTML标签，样式和逻辑是完全封装好的，无需方法转换，框架或换位。 一起来学习Web组件的主要特性吧。 自定义元素 自定义元素单纯是用户定义的HTML元素。其可通过CustomElementRegistry来定义。要定义新元素，先通过window.customElements来获取注册实例，再调用它的define方法： window.customElements.define(&#39;my-element&#39;,&nbsp;MyElement); 上述define方法中的第一个参数是新建元素的标签名。可这样来实现简单的添加： &lt;my-element&gt;&lt;/my-element&gt;&nbsp; 名称中的破折号（-）是必不可少的，它可以避免与原生HTML元素发生重名。 MyElement构造函数必须是一个ES6类，因为Javascript类（暂时还）不像传统的OOP类，而且容易混淆。此外，如果它支持使用object，那么也可以使用Proxy为自定义元素启用简单的数据绑定。但是需要对此作出限制，以便启用原生HTML的拓展属性并确保元素继承了整个DOM API。 为自定义元素编写类: class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;super();&nbsp;&nbsp;}&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;here&nbsp;the&nbsp;element&nbsp;has&nbsp;been&nbsp;inserted&nbsp;into&nbsp;the&nbsp;DOM&nbsp;&nbsp;}} 自定义元素的类只是一个扩展了原生HTMLElement的常规JavaScript类。除了它的构造函数之外，还有一个名为connectedCallback的方法，当有元素插入到DOM中时，这个方法就会被调用。我们可以将其与React的componentDidMount方法进行比较。 通常情况下，组件的设置尽量放在connectedCallback中，因为connectedCallback是唯一能拿到稳定属性且子元素可用的地方。构造函数通常只用于初始化状态和设置影子DOM。 元素的constructor函数和connectedCallback函数之间的区别是，创建元素时调用构造函数（例如调用document.createElement），而connectedCallback函数是在元素已插入DOM后调用，比如声明文件被解析或已通过document.body.appendChild添加。 也可通过引用构造函数customElements.get(&#39;my-element&#39;)来创建元素，前提是它已经注册了customelelements.define()。然后用new element()方法实例化元素，而非document.createElement()方法： customElements.define(&#39;my-element&#39;,&nbsp;class&nbsp;extends&nbsp;HTMLElement&nbsp;{...});...const&nbsp;el&nbsp;=&nbsp;customElements.get(&#39;my-element&#39;);const&nbsp;myElement&nbsp;=&nbsp;new&nbsp;el();&nbsp;&nbsp;//&nbsp;same&nbsp;as&nbsp;document.createElement(&#39;my-element&#39;);document.body.appendChild(myElement); connectedCallback的对应函数是disconnectedCallback，当元素从DOM中删除时会调用它。此方法支持执行任何必要的清除工作，但请记住，用户关闭浏览器或关闭浏览器选项卡并不会调用此方法。 还有adoptedCallback函数，它是在通过调用document. adoptnode(element)来将元素引入到文档中时被调用。到目前为止，我还从未遇到过使用该回调的情况。 另一个有用的生命周期函数是attributeChangedCallback函数。它在observedAttributes数组的属性发生变更时被调用。调用时需传入属性名、旧值和新值： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;static&nbsp;get&nbsp;observedAttributes()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[&#39;foo&#39;,&nbsp;&#39;bar&#39;];&nbsp;&nbsp;}&nbsp;&nbsp;attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;switch(attr)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&#39;foo&#39;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;with&nbsp;&#39;foo&#39;&nbsp;attribute&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&#39;bar&#39;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;with&nbsp;&#39;bar&#39;&nbsp;attribute&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 这个回调只会在observedAttributes数组包含的属性中发生调用，在本例中是foo和bar。如果是其他任意的属性变化，此回调不会发生调用。 属性主要用于声明元素的初始配置/状态。理论上，可以通过序列化将复杂的值传递给属性，但这可能会影响性能，因为我们可以通过访问组件的方法来替代。但是，如果确实希望通过像React和Angular这样的框架提供的属性来绑定，那么可以试试Polymer。 生命周期方法的执行顺序 生命周期方法的执行顺序是： constructor&nbsp;-&gt;&nbsp;attributeChangedCallback&nbsp;-&gt;&nbsp;connectedCallback 为什么attributeChangedCallback方法会在connectedCallback方法之前执行？ 回想一下，web组件属性的主要用途是初始化配置。这意味着，当组件引入到DOM中时此配置必须是可用的，因此需要在connectedCallback方法之前调用attributeChangedCallback方法。 这也意味着，如果需要基于某特定属性在影子DOM中配置节点，我们需要在constructor函数中引入该节点，而非在connectedCallback中。 例如，组件中有一个id=”container”的元素，我们需要在其可见属性禁用的情况下给它添加一个灰色背景，我们可以在constructor函数中引入这个元素，以便在attributeChangedCallback函数中可以调用: constructor()&nbsp;{&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#container&#39;);}attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{&nbsp;&nbsp;if(attr&nbsp;===&nbsp;&#39;disabled&#39;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if(this.hasAttribute(&#39;disabled&#39;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.background&nbsp;=&nbsp;&#39;#808080&#39;;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.background&nbsp;=&nbsp;&#39;#ffffff&#39;;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 如果等到connectedCallback方法中才创建this.container，那么在首次调用attributeChangedCallback方法时，它还是不可用的。因此，尽管我们尽可能的将组件的设置放在connectedCallback中，但在这种情况下也是不可行的。 同样重要的是，在通过customelelements.define()注册之前，我们就可以使用该web组件。当该元素出现在DOM中或插入到DOM中，且尚未注册时，它将是HTMLUnknownElement的一个实例。浏览器将会处理这类它不认识的HTML元素，我们可以和其他元素一样为它设置交互逻辑，但除此之外，它没有任何方法或默认的样式。 当通过customelelements .define()注册它时，可通过定义类来增强它。这个过程称为升级。当使用customElements.whenDefined升级元素时，可以调用回调，它会返回元素升级后的Promise方法： customElements.whenDefined(&#39;my-element&#39;).then(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;//&nbsp;my-element&nbsp;is&nbsp;now&nbsp;defined}) Web组件的公共API 除了上述生命周期方法，我们可以给元素定义外部访问的方法，这是使用React或Angular等框架定义元素所实现不了的。例如，我们定义一个名为doSomething的方法： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;doSomething()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;in&nbsp;this&nbsp;method&nbsp;&nbsp;}} 并从组件外部来调用它： const&nbsp;element&nbsp;=&nbsp;document.querySelector(&#39;my-element&#39;);element.doSomething(); 在元素上定义的方法都将是其公共JavaScript API的一部分。通过这种方式，我们可以通过为元素的属性提供setter来实现数据绑定，例如，设置setter将在元素的HTML中呈现属性值。由于在本质上不可能向属性提供字符串以外的任何其他值，所以应该将像对象这样的复杂值作为属性传递给自定义元素。 除了声明web组件的初始状态外，属性还用于反映相应属性的值，以便将元素的JavaScript状态反映到它的DOM表示。input元素中的disabled属性就是其中一个例子: &lt;input&nbsp;name=&quot;name&quot;&gt;const&nbsp;input&nbsp;=&nbsp;document.querySelector(&#39;input&#39;);input.disabled&nbsp;=&nbsp;true; 将input的属性disabled设置为true后，此更改将映射到相应的disabled 属性中: &lt;input&nbsp;name=&quot;name&quot;&nbsp;disabled&gt; 通过setter可以很容易地实现属性到属性的反射: class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;set&nbsp;disabled(isDisabled)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if(isDisabled)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setAttribute(&#39;disabled&#39;,&nbsp;&#39;&#39;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.removeAttribute(&#39;disabled&#39;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;get&nbsp;disabled()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this.hasAttribute(&#39;disabled&#39;);&nbsp;&nbsp;}} 当属性发生改变而需要执行某些操作时，可将其添加到observedAttributes数组中。作为一种性能优化，只能监听该数组列出的属性。当属性的值发生变化时，attributeChangedCallback将通过传入属性名及其当前值和新值来调用： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;get&nbsp;observedAttributes()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[&#39;disabled&#39;];&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;shadowRoot&nbsp;=&nbsp;this.attachShadow({mode:&nbsp;&#39;open&#39;});&nbsp;&nbsp;&nbsp;&nbsp;shadowRoot.innerHTML&nbsp;=&nbsp;`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.disabled&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opacity:&nbsp;0.4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;container&quot;&gt;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`;&nbsp;&nbsp;&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot(&#39;#container&#39;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(attr&nbsp;===&nbsp;&#39;disabled&#39;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.disabled)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.classList.add(&#39;disabled&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.classList.remove(&#39;disabled&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 现在，disabled属性一旦发生改变，this.container中的“disabled”类就会发生来回切换，它是这个元素影子DOM的div元素。 下面详细探讨一下影子DOM。 影子DOM 影子DOM可以将自定义元素的HTML和CSS完全封装在组件中。这意味着，元素以单个HTML标签的形式呈现在文件的DOM结构树中，其内部HTML结构放在#shadow-root中。 实际上，一些本地HTML元素也使用了影子DOM。例如，网页的&lt;video&gt;元素，它显示为一个单独的标签，但它也是显示播放和暂停视频的控件，但在浏览器的开发工具中是找不到&lt;video&gt;元素的。 实际上，控件&lt;video&gt;元素是影子DOM的一部分，因此在默认情况下它们时不可见的。要在Chrome中显示出影子DOM，可进入开发工具设置中的“首选项”，选中“显示用户代理影子DOM”复选框。此时在开发工具中查找&lt;video&gt;元素，我们可以找到并检查该元素的影子DOM。 影子DOM还可看出CSS的真正作用域。所有在组件内部定义的CSS只作用于组件本身。元素将从组件外部定义的CSS中继承最小数量的属性，甚至可以将这些属性配置为不从外层的CSS中继承任何值。不过，我们可以露出CSS属性，以便用户对组件进行样式设置。这解决了当前许多CSS问题，同时仍然支持给组件自定义样式。 定义一个影子根： const&nbsp;shadowRoot&nbsp;=&nbsp;this.attachShadow({mode:&nbsp;&#39;open&#39;});shadowRoot.innerHTML&nbsp;=&nbsp;`&lt;p&gt;Hello&nbsp;world&lt;/p&gt;`; 这里用mode:’open’定义了一个影子根，这意味着，可以在开发工具检出它并做交互，也可以发请求、配置共用CSS属性或监听事件。也可以用mode:’close’来定义影子根，但不建议这样定义，因为它不支持任何方式的交互，甚至不能监听其抛出的事件。 要将HTM添加到影子根中，我们可以给innerHTML属性分配HTML字符串，或者使用&lt;template&gt;元素。HTML模板基本上算是一个惰性的HTML片段，我们可先定义以供后续使用。在实际插入DOM结构树之前，它是不可见或不被解析的，这意味着在它内部定义的任何外部资源都不会被获取，任何CSS和JavaScript也都不会被解析。当组件的HTML随着状态发生改变时，我们可以定义多个&lt;template&gt;元素以便根据不同状态来做引入。如此一来，我们可以轻松的对组件HTML进行更改，而无需修改单个DOM节点。 一旦创建了影子根，我们可以像通常作用于document对象的方法一样，对其应用所有的DOM方法，例如，通过this.shadowRoot.querySelector方法来查找元素。组件的CSS都定义在&lt;style&gt;标签中，但如果希望使用常规的&lt;link rel=”stylesheet”&gt;标签，也可以获取到外部样式表。除了常规CSS之外，还可以使用:host选择器对组件本身进行样式设置。例如，自定义元素默认使用display: inline而将组件显示为块元素，可以写为: :host&nbsp;{&nbsp;&nbsp;display:&nbsp;block;} 它也支持为上下文设置样式。例如，如果希望在组件定义了disabled属性后显示为灰色，写为： :host([disabled])&nbsp;{&nbsp;&nbsp;opacity:&nbsp;0.5;} 默认情况下，自定义元素会继承一些外层CSS样式，比如颜色和字体等。但如果希望清空样式，将组件中所有的CSS样式重置为默认状态，可以写为： :host&nbsp;{&nbsp;&nbsp;all:&nbsp;initial;} 值得注意的是，外部定义于组件本身上的样式优先于使用:host在影子DOM中定义的样式。因此，如果定义： my-element&nbsp;{&nbsp;&nbsp;display:&nbsp;inline-block;} 它将覆盖： :host&nbsp;{&nbsp;&nbsp;display:&nbsp;block;} 我们不能从外部对自定义元素内的任何节点设置样式。如果想要支持用户对组件样式（某部分）进行设置，我们可以通过露出CSS变量来实现。例如，为便于用户选择组件的背景颜色，我们可以露出background-color这一CSS变量。 假设组件中影子DOM的根节点是&lt;div id=&quot;container&quot;&gt;： #container&nbsp;{&nbsp;&nbsp;background-color:&nbsp;var(--background-color);} 现在用户从外部设置组件的背景颜色: my-element&nbsp;{&nbsp;&nbsp;--background-color:&nbsp;#ff0000;} 我们要在组件内部为它设置一个默认值以防用户不对其设置： :host&nbsp;{&nbsp;&nbsp;--background-color:&nbsp;#ffffff;}#container&nbsp;{&nbsp;&nbsp;background-color:&nbsp;var(--background-color);} 当然，CSS变量的名称可以是任意的。它的唯一限制是要以“--”开头。 通过限定CSS和HTML的作用域，影子DOM解决了CSS全局特性带来的问题，即通常是只添加样式表而其中包含越来越多的特定选择器和覆盖问题。影子DOM支持在自包含组件中捆绑标记和样式，而无需任何工具或命名约定。因此，我们不必担心新的类或id会与现有类发生冲突。 我们可以通过CSS变量来给web组件设置内部样式，除此之外，还可以将HTML注入到web组件中。 组成元素slot 组成是将影子DOM结构树和用户标记组合在一起的过程。它可以通过&lt;slot&gt;元素实现，&lt;slot&gt;元素是在影子DOM中用来呈现用户所做标记的基本占位符。用户所做的标记被称为自然DOM。组合将自然DOM和影子DOM合成为新的DOM结构树。 例如，我们可以创建一个&lt;image-gallery&gt;组件，并提供标准的&lt;image&gt;标签用以渲染呈现： &lt;image-gallery&gt;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;bar.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&lt;/image-gallery&gt; 组件将会获取这两个图像，并通过slot在组件的影子DOM中渲染出来。注意图像上的slot=&quot;image&quot;属性。该属性告诉组件应该在影子DOM中的哪个位置呈现，比如可以是这样的： &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&nbsp;name=&quot;image&quot;&gt;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 当自然DOM中的节点被分布到元素的影子DOM中时，得到的DOM树看起来是这样的： &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&nbsp;name=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;bar.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 正如我们看到的，用户提供的元素都具有slot属性，它们都将在slot元素中呈现，而slot元素具有name属性，其值与slot属性值一致。 &lt;select&gt;元素的运行方式与在Chrome开发工具中查看它时所看到的完全一致（用户代理拿到用户选择的影子DOM时，如图）： 它获取用户提供的&lt;option&gt;元素并将它们呈现到下拉菜单中。 带有name属性的slot元素被称为命名slot，但此属性不是必须的。它仅用于在特定位置呈现内容。当一个或多个slot没有name属性时，其中内容的渲染顺序将遵循用户提供的顺序。当用户提供的内容少于slot时，slot甚至可以提供回退内容。 假设&lt;image-gallery&gt;的影子DOM是这样的: &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;No&nbsp;image&nbsp;here!&lt;/strong&gt;&nbsp;&lt;--&nbsp;fallback&nbsp;content&nbsp;--&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 同样提供两个图像，得到的影子DOM树将是： &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;bar.jpg&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;No&nbsp;image&nbsp;here!&lt;/strong&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 通过slot在影子DOM中呈现的元素称为分布式节点。这些节点在组件的影子DOM (分布式)中呈现之前，应用于它们的所有样式也将在分布之后得到应用。在影子DOM中，分布式节点可以通过::sloated()选择器获得额外的样式： ::slotted(img)&nbsp;{&nbsp;&nbsp;float:&nbsp;left;} :: sloated()可以接受任何有效的CSS选择器，但是它只能选择最高级的节点。例如::sloated (section img)将无法处理以下内容: &lt;image-gallery&gt;&nbsp;&nbsp;&lt;section&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&gt;&nbsp;&nbsp;&lt;/section&gt;&lt;/image-gallery&gt; JavaScript作用于slot 我们可以通过JavaScript与slot进行交互，通过查看节点分配到哪个slot，该slot对应哪个元素以及slotchange事件。 调用slot.assignedNodes()方法可以找出该slot对应的元素。如果还需要检索回调内容，可以调用slot.assignedNodes({flatten: true})。 查找slot中是否包含某个特定元素可以使用element.assignedSlot。 当slot节点发生变更时，即添加或删除节点将会触发slotchange事件。这里要注意，该事件会触发仅针对slot节点本身，而非slot节点的子节点。 slot.addEventListener(&#39;slotchange&#39;,&nbsp;e&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;const&nbsp;changedSlot&nbsp;=&nbsp;e.target;&nbsp;&nbsp;console.log(changedSlot.assignedNodes());}); 当元素是首次初始化时，Chrome会触发slotchange事件，而Safari和Firefox则不会。 影子DOM事件 默认情况下，自定义元素中诸如鼠标事件和键盘事件等标准事件会从影子DOM中弹出。影子DOM节点触发的事件会被重定向，所以该事件看起来像是源自自定义元素本身。如果想找出是影子DOM中由哪个元素触发了此事件，我们可以调用event.composedPath()来检索事件经过的节点数组。事件的target属性始终指向自定义元素本身。 我们可以使用CustomEvent从自定义元素中抛出任意事件。 class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.dispatchEvent(new&nbsp;CustomEvent(&#39;custom&#39;,&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detail:&nbsp;{message:&nbsp;&#39;a&nbsp;custom&nbsp;event&#39;}&nbsp;&nbsp;&nbsp;&nbsp;}));&nbsp;&nbsp;}}//&nbsp;on&nbsp;the&nbsp;outsidedocument.querySelector(&#39;my-element&#39;).addEventListener(&#39;custom&#39;,&nbsp;e&nbsp;=&gt;&nbsp;console.log(&#39;message&nbsp;from&nbsp;event:&#39;,&nbsp;e.detail.message)); 但是，当事件是从影子DOM中的节点抛出而不是其自定义元素本身时，它不会从影子DOM中弹出，除非它是用composition: true创建的： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#container&#39;);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;dispatchEvent&nbsp;is&nbsp;now&nbsp;called&nbsp;on&nbsp;this.container&nbsp;instead&nbsp;of&nbsp;this&nbsp;&nbsp;&nbsp;&nbsp;this.container.dispatchEvent(new&nbsp;CustomEvent(&#39;custom&#39;,&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detail:&nbsp;{message:&nbsp;&#39;a&nbsp;custom&nbsp;event&#39;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;composed:&nbsp;true&nbsp;&nbsp;//&nbsp;without&nbsp;composed:&nbsp;true&nbsp;this&nbsp;event&nbsp;will&nbsp;not&nbsp;bubble&nbsp;out&nbsp;of&nbsp;Shadow&nbsp;DOM&nbsp;&nbsp;&nbsp;&nbsp;}));&nbsp;&nbsp;}} 模块元素 除了可以使用this.shadowRoot.innerHTML将HTML添加到影子根中，我们也可以用&lt;template&gt;元素。模板可保存HTML以供后续使用。它并未渲染出来，而最初的解析是为了确保其内容的有效性。模板中的JavaScript不执行，也不会获取任何外部资源。默认情况下它是隐性的。 当一个web组件需要根据不同的情况呈现完全不同的标记时，可以使用不同的模板来完成: class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;shadowRoot&nbsp;=&nbsp;this.attachShadow({mode:&nbsp;&#39;open&#39;});&nbsp;&nbsp;&nbsp;&nbsp;this.shadowRoot.innerHTML&nbsp;=&nbsp;`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;template&nbsp;id=&quot;view1&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;is&nbsp;view&nbsp;1&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/template&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;template&nbsp;id=&quot;view1&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;is&nbsp;view&nbsp;1&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/template&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;is&nbsp;the&nbsp;container&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;`;&nbsp;&nbsp;}&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;content&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#view1&#39;).content.clondeNode(true);&nbsp;&nbsp;&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#container&#39;);&nbsp;&nbsp;&nbsp;&nbsp;this.container.appendChild(content);&nbsp;&nbsp;}} 在这里，两个模板都通过innerHTML置于元素的影子根中。起初，这两个模板都是不可见的，只看得到容器。connectedCallback方法中，我们通过this.shadowRoot.querySelector(&#39;#view1&#39;).content.clondeNode(true)获取#view1的内容。模板的content属性以DocumentFragment返回模板的内容，可以使用appendChild将其添加到另一个元素中。当某元素已存在于DOM中时，使用appendChild将会移动它，所以我们要先使用cloneNode(true)克隆它。否则，模板的内容将会被移动而不是附加，这就意味着我们只能使用一次了。 模板对于快速更改大多数HTML或可复用的标签非常有用。它们不仅限于web组件，而且可以在DOM中的任何地方使用。 本地元素的扩展 到目前为止，我们一直在扩展HTMLElement来创建一个全新的HTML元素。自定义元素还支持扩展原生内置元素，支持增强已经存在的HTML元素，例如图像和按钮。在撰写本文时，此功能仅有Chrome和Firefox浏览器支持。 扩展现有HTML元素的好处是其继承了元素的所有属性和方法。这允许对现有元素进行逐步增强，这意味着即使在不支持自定义元素的浏览器中加载元素，它仍然是可用的。它只会退回到默认的内置行为，而如果它是一个全新的HTML标记，那么它根本就不能使用。 例如，我们希望增强HTML中的&lt;button&gt;元素： class&nbsp;MyButton&nbsp;extends&nbsp;HTMLButtonElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;super();&nbsp;&nbsp;//&nbsp;always&nbsp;call&nbsp;super()&nbsp;to&nbsp;run&nbsp;the&nbsp;parent&#39;s&nbsp;constructor&nbsp;as&nbsp;well&nbsp;&nbsp;}&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;}&nbsp;&nbsp;someMethod()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;}}customElements.define(&#39;my-button&#39;,&nbsp;MyButton,&nbsp;{extends:&nbsp;&#39;button&#39;}); 我们的web组件不再扩展更通用的HTMLElement，而是扩展HTMLButtonElement。对customElements.define的调用还需要一个额外的参数{extends: &#39;button&#39;}，以此表示我们的类扩展了&lt;button&gt;元素。这看起来可能有些多余，因为我们已经表明了我们想要扩展HTMLButtonElement，但是这是必要的，因为有一些元素共享相同的DOM接口。例如，&lt;q&gt;和&lt;blockquote&gt;共用HTMLQuoteElement接口。 增强后的按钮可以与is属性一起使用: &lt;button&nbsp;is=&quot;my-button&quot;&gt; 现在它将被我们的MyElement类增强，如果它加载在一个不兼容自定义元素的浏览器中，它将简单地退回到一个标准按钮，真正意义上的渐进增强！ 注意，在扩展现有元素时，不能使用影子DOM。这只是一种扩展原生HTML元素的方法，它继承了所有现有的属性、方法和事件，并提供了额外的功能。当然，可以在组件中修改元素的DOM和CSS，但是试图创建一个影子根的话，它将会抛出一个错误。 扩展内置元素的另一个好处是，这些元素也可以用于应用元素子元素限制的地方。例如，&lt;thead&gt;&nbsp;元素只允许将&lt;tr&gt;&nbsp;元素作为其子元素，因此&lt;awesome-tr&gt;元素将呈现无效的标记。在这种情况下，我们可以扩展内置的&lt;tr&gt;&nbsp;元素，并像这样使用它: &lt;table&gt;&nbsp;&nbsp;&lt;thead&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&nbsp;is=&quot;awesome-tr&quot;&gt;&lt;/tr&gt;&nbsp;&nbsp;&lt;/thead&gt;&lt;/table&gt; 这种创建web组件的方式带来了巨大的渐进式增强，但正如前面提到的，目前这仅有Chrome和Firefox支持实现。Edge也将能兼容它，但不幸的是，在Safari中不能支持实现。 测试web组件 与为Angular和React之类的框架编写测试用例相比，测试web组件既简单又直接，而且坦率地说，这是一件轻而易举的事情。这无需换位或进行复杂的设置。只需创建元素，将其附加到DOM中并运行测试。 下面是一个使用Mocha测试的例子: import&nbsp;&#39;path/to/my-element.js&#39;;describe(&#39;my-element&#39;,&nbsp;()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;let&nbsp;element;&nbsp;&nbsp;beforeEach(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;element&nbsp;=&nbsp;document.createElement(&#39;my-element&#39;);&nbsp;&nbsp;&nbsp;&nbsp;document.body.appendChild(element);&nbsp;&nbsp;});&nbsp;&nbsp;afterEach(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;document.body.removeChild(element);&nbsp;&nbsp;});&nbsp;&nbsp;it(&#39;should&nbsp;test&nbsp;my-element&#39;,&nbsp;()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;run&nbsp;your&nbsp;test&nbsp;here&nbsp;&nbsp;});}); 在这里，第一行导入my-element.js文件，该文件将我们的web组件露出为一个ES6模块。这意味着测试文件本身也需要作为一个ES6模块加载到浏览器中。这需要以下index.html能够在浏览器中运行测试。除了Mocha，这个设置还加载WebcomponentsJS &nbsp;polyfill和Chai用于测试判断，以及Sinon用来检测和模拟: &lt;!doctype&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;charset=&quot;utf-8&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;link&nbsp;rel=&quot;stylesheet&quot;&nbsp;href=&quot;../node_modules/mocha/mocha.css&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/sinon/pkg/sinon.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/chai/chai.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/mocha/mocha.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.assert&nbsp;=&nbsp;chai.assert;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mocha.setup(&#39;bdd&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;module&quot;&nbsp;src=&quot;path/to/my-element.test.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;module&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mocha.run();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;mocha&quot;&gt;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt; 加载所需的脚本后，我们将露出chai.assert作为一个全局变量，因此我们可以在测试中简单地使用assert()，并设置Mocha来使用BDD接口。然后加载测试文件(在本例中只有一个)，并通过调用mocha.run()运行测试。 请注意，在使用ES6模块时，还需要将mocha.run()放在type=&quot;module&quot;的脚本中。这是因为ES6模块在默认情况下是延迟的，如果mocha.run()放在一个正则脚本标记中，它将在加载my-element.test.js之前执行。 Polyfill老式浏览器 目前，Chrome、Firefox、Safari和Opera的最新版本都支持自定义元素，即将推出的Edge 19也将支持自定义元素。在iOS和Android上，Safari、Chrome和Firefox都能兼容它们。 旧版本浏览器的WebcomponentsJS polyfill可通过以下途径安装: npm&nbsp;install&nbsp;--save&nbsp;@webcomponents/webcomponentsjs 我们可以引入webcomponents-loader.js文件，该文件将进行特性检测，只加载必要的填充内容。使用此方法，我们可以使用自定义元素，而不需要向源代码添加任何东西。但是，它没有提供真正的CSS作用域，这意味着如果在不同的web组件中包含有相同的类名和id，并将它们加载到相同的文档中，它们将发生冲突。此外，影子DOM的 CSS选择器:host()和:sloated()可能无法正常工作。 为了使其正常运行，我们需要使用Shady CSS polyfill，这也意味着必须(稍微)修改源代码才能使用它。我个人认为这是不可取的，所以我创建了一个webpack加载器，它可以处理这个问题。这表明必须进行转置，但是我们可以保持代码不变。 webpack加载器会做这三件事:它在web组件的影子DOM中为所有CSS规则加上前缀，这些CSS规则不是以元素名加::host或::slotted&nbsp;开头的，他们提供适当的范围。然后，它解析所有::host和::slot规则，以确保它们也能正确工作。 工作示例1:lazy-img 我创建了一个web组件，当图像在浏览器的视图中完全可见时，它就会惰性地加载图像。具体请参考Github。 组件的主体将本地&lt;img&gt;&nbsp;标签封装在&lt;lazy-img&gt;&nbsp;自定义元素中: &lt;lazy-img&nbsp;&nbsp;src=&quot;path/to/image.jpg&quot;&nbsp;&nbsp;width=&quot;480&quot;&nbsp;&nbsp;height=&quot;320&quot;&nbsp;&nbsp;delay=&quot;500&quot;&nbsp;&nbsp;margin=&quot;0px&quot;&gt;&lt;/lazy-img&gt; 下例还包含了extend-native分支，其中包含lazy-img，它使用is属性扩展原生&lt;img&gt;标签: &lt;img&nbsp;&nbsp;is=&quot;lazy-img&quot;&nbsp;&nbsp;src=&quot;path/to/img.jpg&quot;&nbsp;&nbsp;width=&quot;480&quot;&nbsp;&nbsp;height=&quot;320&quot;&nbsp;&nbsp;delay=&quot;500&quot;&nbsp;&nbsp;margin=&quot;0px&quot;&gt; 这是一个说明原生web组件强大功能的很好的例子:只需导入JavaScript文件、添加HTML标签或使用is属性扩展原生web组件，大功告成! 工作示例2:material-webcomponents 我使用自定义元素实现了谷歌的材质设计，具体也请参考Github。 这个库还展示了CSS自定义属性的强大功能，其中包含大量的自定义属性。 那么，应该抛弃框架吗? 当然，这要视情况而定。 目前的前端框架因具有数据绑定、状态管理和相当标准化的代码库等功能而带来了额外的价值。但问题是你的应用程序是否真的需要它。 如果还需要问自己，我的应用程序是否真的需要Redux之类的状态管理，那么你可能就是不需要它的。你渐渐就明白了。 使用数据绑定可能有好处，但是对于数组和对象等非基本值，原生web组件已经支持用户直接设置属性。我们可以在属性上设置基本值，并且可以通过attributeChangedCallback观察这些属性的更改。 虽然这种方法看起来非常合理，但是与React和Angular的声明式方法相比，它会使得更新DOM的某一部分变得非常麻烦和冗长。这些框架支持定义一个视图，它包含当表达式变更时更新的表达式。 原生web组件(还)不提供这样的功能，尽管有人建议扩展&lt;template&gt;元素，使其可以用数据实例化和更新： &lt;template&nbsp;id=&quot;example&quot;&gt;&nbsp;&nbsp;&lt;h1&gt;{{title}}&lt;/h1&gt;&nbsp;&nbsp;&lt;p&gt;{{text}}&lt;/p&gt;&lt;/template&gt;const&nbsp;template&nbsp;=&nbsp;document.querySelector(&#39;#example&#39;);const&nbsp;instance&nbsp;=&nbsp;template.createInstance({title:&nbsp;&#39;The&nbsp;title&#39;,&nbsp;text:&nbsp;&#39;Hello&nbsp;world&#39;});shadowRoot.appendChild(instance.content);//updateinstance.update({title:&nbsp;&#39;A&nbsp;new&nbsp;title&#39;,&nbsp;text:&nbsp;&#39;Hi&nbsp;there&#39;}); 当前可以支持有效DOM更新的库是lit -html。 另一个经常提到前端框架的好处是，它们提供了一个标准的代码基，团队中的每个新开发人员都将从一开始就熟悉这个代码基。虽然我相信这是真的，但我也认为这种好处是相当有限的。 我曾经用Angular、React和Polymer做过很多项目，虽然大家对它们都很熟悉，但是尽管使用了相同的框架，这些代码库还是有很大的不同。清晰定义的工作方式和样式指南比简单地使用框架更有助于代码库的一致性。框架也带来了额外的复杂性，所以问问自己这是否真的值得 现在web组件得到了广泛的支持，我们可能会得出这样的结论:原生代码可以提供与框架相同的功能，但是性能更好、代码更少、复杂度更低。 本地web组件的好处很明显: 原生，不需要框架； 易于集成，不需要移位； CSS有真正的作用域； 规范，只有HTML, CSS和JavaScript。 jQuery及其尤为出色的资源将会继续存在一段时间，但是没有太多人会使用它构建的新项目，因为现在有了更好的选择。我不认为目前的框架会很快消失，但是以原生web组件形式出现的更优选择正在出现，并且迅速获得关注。我确实期望这些前端框架的角色会发生巨大变化，届时它们将仅给本地web组件提供一个薄外层。 原文：https://www.dannymoerkerke.com/blog/web-components-will-replace-your-frontend-framework 本文为 CSDN 翻译，转载请注明来源出处。 【END】 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞互联网出海十年 ☞面试一线互联网大厂？那这道题目你必须得会！ ☞华为在剑桥建芯片厂；小米公布出货量反驳调研机构； 中移动否认限制号 | 极客头条 ☞天才程序员：25 岁进贝尔实验室，32 岁创建信息论 ☞&nbsp;扎心！工作 10 年，月薪过万者不足三成，程序员却笑了 ☞6张图告诉你, 区块链的未来在哪里 ☞我们应聘BAT等互联网公司，关于Spring到底需要掌握什么？ ☞如何确定最佳训练数据集规模？6 大必备“锦囊”全给你了 | 技术头条 ☞&nbsp;她说：为啥程序员都特想要机械键盘？这答案我服！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 点击阅读原文，输入关键词，即可搜索您想要的 CSDN 文章。 你点的每个“在看”，我都认真当成了喜欢" />
<meta property="og:description" content="【CSDN 编者按】提起前端开发，不少开发者首先会对主流技术框架如 Vue、React、Angular 进行一番对比之后，选择相应的技术架构。 在此，随着前端框架的不断升级，其也变得越来越臃肿与复杂，那么，未来前端框架是否会被取而代之？ 作者 |&nbsp;Danny Moerkerke 译者 |&nbsp;谭开朗 责编 | 屠敏 出品 | CSDN（ID：CSDNnews） 以下为译文： 还记得吗？当时document.querySelector首次被浏览器广泛采用，就此终结了jQuery的通用时代。对于多年来一直沿用jQuery来实现的功能，document.querySelector提供了原生方法：轻松的选取DOM元素。我相信，类似的情况也将会发生在诸如Angular和React的前端框架上。 前端框架为我们一直想做却未能做到的事情提供了可能：创建可复用的自动化前端组件，但它复杂性较高，还有专属语法和较高的有效负载。 前端框架正渐渐被取代。 现代Web API发展至今，我们已无需依赖框架来创建可复用的前端组件。我们所需创建的自定义组件就是自定义元素和影子DOM，这可以在任意地方复用。 2011年开始推出的Web组件，它支持仅通过HTML、CSS和JavaScript就能创建出可复用组件。这意味着，我们无需使用诸如React或Angular的框架就能构建出组件。更锦上添花的是，这些组件可以无缝集成到框架中。 有史以来第一次，我们仅通过HTML，CSS和JavaScript就成功构建了可兼容任意浏览器的可复用组件。Web组件现在可以兼容桌面最新的Chrome、Safari、Firefox和Opera浏览器，还有iOS的Safari浏览器和Android的Chrome浏览器。 Edge浏览器即将发布的第19版中也将得到兼容。对于较老的浏览器，它将会通过polyfill将其引入到IE 11浏览器中。 这意味着，目前基本任一浏览器都可以使用Web组件，包括移动端浏览器。 只需简单的引入一个脚本，我们就可以创建自定义HTML标签，它不仅继承了HTML元素扩展出的所有属性，还能在其支持的任意浏览器中使用。组件中定义的所有HTML，CSS和JavaScript都完全限定在组件的作用域内。 组件在浏览器的开发工具中显示为单个HTML标签，样式和逻辑是完全封装好的，无需方法转换，框架或换位。 一起来学习Web组件的主要特性吧。 自定义元素 自定义元素单纯是用户定义的HTML元素。其可通过CustomElementRegistry来定义。要定义新元素，先通过window.customElements来获取注册实例，再调用它的define方法： window.customElements.define(&#39;my-element&#39;,&nbsp;MyElement); 上述define方法中的第一个参数是新建元素的标签名。可这样来实现简单的添加： &lt;my-element&gt;&lt;/my-element&gt;&nbsp; 名称中的破折号（-）是必不可少的，它可以避免与原生HTML元素发生重名。 MyElement构造函数必须是一个ES6类，因为Javascript类（暂时还）不像传统的OOP类，而且容易混淆。此外，如果它支持使用object，那么也可以使用Proxy为自定义元素启用简单的数据绑定。但是需要对此作出限制，以便启用原生HTML的拓展属性并确保元素继承了整个DOM API。 为自定义元素编写类: class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;super();&nbsp;&nbsp;}&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;here&nbsp;the&nbsp;element&nbsp;has&nbsp;been&nbsp;inserted&nbsp;into&nbsp;the&nbsp;DOM&nbsp;&nbsp;}} 自定义元素的类只是一个扩展了原生HTMLElement的常规JavaScript类。除了它的构造函数之外，还有一个名为connectedCallback的方法，当有元素插入到DOM中时，这个方法就会被调用。我们可以将其与React的componentDidMount方法进行比较。 通常情况下，组件的设置尽量放在connectedCallback中，因为connectedCallback是唯一能拿到稳定属性且子元素可用的地方。构造函数通常只用于初始化状态和设置影子DOM。 元素的constructor函数和connectedCallback函数之间的区别是，创建元素时调用构造函数（例如调用document.createElement），而connectedCallback函数是在元素已插入DOM后调用，比如声明文件被解析或已通过document.body.appendChild添加。 也可通过引用构造函数customElements.get(&#39;my-element&#39;)来创建元素，前提是它已经注册了customelelements.define()。然后用new element()方法实例化元素，而非document.createElement()方法： customElements.define(&#39;my-element&#39;,&nbsp;class&nbsp;extends&nbsp;HTMLElement&nbsp;{...});...const&nbsp;el&nbsp;=&nbsp;customElements.get(&#39;my-element&#39;);const&nbsp;myElement&nbsp;=&nbsp;new&nbsp;el();&nbsp;&nbsp;//&nbsp;same&nbsp;as&nbsp;document.createElement(&#39;my-element&#39;);document.body.appendChild(myElement); connectedCallback的对应函数是disconnectedCallback，当元素从DOM中删除时会调用它。此方法支持执行任何必要的清除工作，但请记住，用户关闭浏览器或关闭浏览器选项卡并不会调用此方法。 还有adoptedCallback函数，它是在通过调用document. adoptnode(element)来将元素引入到文档中时被调用。到目前为止，我还从未遇到过使用该回调的情况。 另一个有用的生命周期函数是attributeChangedCallback函数。它在observedAttributes数组的属性发生变更时被调用。调用时需传入属性名、旧值和新值： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;static&nbsp;get&nbsp;observedAttributes()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[&#39;foo&#39;,&nbsp;&#39;bar&#39;];&nbsp;&nbsp;}&nbsp;&nbsp;attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;switch(attr)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&#39;foo&#39;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;with&nbsp;&#39;foo&#39;&nbsp;attribute&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&#39;bar&#39;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;with&nbsp;&#39;bar&#39;&nbsp;attribute&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 这个回调只会在observedAttributes数组包含的属性中发生调用，在本例中是foo和bar。如果是其他任意的属性变化，此回调不会发生调用。 属性主要用于声明元素的初始配置/状态。理论上，可以通过序列化将复杂的值传递给属性，但这可能会影响性能，因为我们可以通过访问组件的方法来替代。但是，如果确实希望通过像React和Angular这样的框架提供的属性来绑定，那么可以试试Polymer。 生命周期方法的执行顺序 生命周期方法的执行顺序是： constructor&nbsp;-&gt;&nbsp;attributeChangedCallback&nbsp;-&gt;&nbsp;connectedCallback 为什么attributeChangedCallback方法会在connectedCallback方法之前执行？ 回想一下，web组件属性的主要用途是初始化配置。这意味着，当组件引入到DOM中时此配置必须是可用的，因此需要在connectedCallback方法之前调用attributeChangedCallback方法。 这也意味着，如果需要基于某特定属性在影子DOM中配置节点，我们需要在constructor函数中引入该节点，而非在connectedCallback中。 例如，组件中有一个id=”container”的元素，我们需要在其可见属性禁用的情况下给它添加一个灰色背景，我们可以在constructor函数中引入这个元素，以便在attributeChangedCallback函数中可以调用: constructor()&nbsp;{&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#container&#39;);}attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{&nbsp;&nbsp;if(attr&nbsp;===&nbsp;&#39;disabled&#39;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if(this.hasAttribute(&#39;disabled&#39;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.background&nbsp;=&nbsp;&#39;#808080&#39;;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.background&nbsp;=&nbsp;&#39;#ffffff&#39;;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 如果等到connectedCallback方法中才创建this.container，那么在首次调用attributeChangedCallback方法时，它还是不可用的。因此，尽管我们尽可能的将组件的设置放在connectedCallback中，但在这种情况下也是不可行的。 同样重要的是，在通过customelelements.define()注册之前，我们就可以使用该web组件。当该元素出现在DOM中或插入到DOM中，且尚未注册时，它将是HTMLUnknownElement的一个实例。浏览器将会处理这类它不认识的HTML元素，我们可以和其他元素一样为它设置交互逻辑，但除此之外，它没有任何方法或默认的样式。 当通过customelelements .define()注册它时，可通过定义类来增强它。这个过程称为升级。当使用customElements.whenDefined升级元素时，可以调用回调，它会返回元素升级后的Promise方法： customElements.whenDefined(&#39;my-element&#39;).then(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;//&nbsp;my-element&nbsp;is&nbsp;now&nbsp;defined}) Web组件的公共API 除了上述生命周期方法，我们可以给元素定义外部访问的方法，这是使用React或Angular等框架定义元素所实现不了的。例如，我们定义一个名为doSomething的方法： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;doSomething()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;in&nbsp;this&nbsp;method&nbsp;&nbsp;}} 并从组件外部来调用它： const&nbsp;element&nbsp;=&nbsp;document.querySelector(&#39;my-element&#39;);element.doSomething(); 在元素上定义的方法都将是其公共JavaScript API的一部分。通过这种方式，我们可以通过为元素的属性提供setter来实现数据绑定，例如，设置setter将在元素的HTML中呈现属性值。由于在本质上不可能向属性提供字符串以外的任何其他值，所以应该将像对象这样的复杂值作为属性传递给自定义元素。 除了声明web组件的初始状态外，属性还用于反映相应属性的值，以便将元素的JavaScript状态反映到它的DOM表示。input元素中的disabled属性就是其中一个例子: &lt;input&nbsp;name=&quot;name&quot;&gt;const&nbsp;input&nbsp;=&nbsp;document.querySelector(&#39;input&#39;);input.disabled&nbsp;=&nbsp;true; 将input的属性disabled设置为true后，此更改将映射到相应的disabled 属性中: &lt;input&nbsp;name=&quot;name&quot;&nbsp;disabled&gt; 通过setter可以很容易地实现属性到属性的反射: class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;set&nbsp;disabled(isDisabled)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if(isDisabled)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setAttribute(&#39;disabled&#39;,&nbsp;&#39;&#39;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.removeAttribute(&#39;disabled&#39;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;get&nbsp;disabled()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this.hasAttribute(&#39;disabled&#39;);&nbsp;&nbsp;}} 当属性发生改变而需要执行某些操作时，可将其添加到observedAttributes数组中。作为一种性能优化，只能监听该数组列出的属性。当属性的值发生变化时，attributeChangedCallback将通过传入属性名及其当前值和新值来调用： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;get&nbsp;observedAttributes()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[&#39;disabled&#39;];&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;shadowRoot&nbsp;=&nbsp;this.attachShadow({mode:&nbsp;&#39;open&#39;});&nbsp;&nbsp;&nbsp;&nbsp;shadowRoot.innerHTML&nbsp;=&nbsp;`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.disabled&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opacity:&nbsp;0.4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;container&quot;&gt;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`;&nbsp;&nbsp;&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot(&#39;#container&#39;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(attr&nbsp;===&nbsp;&#39;disabled&#39;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.disabled)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.classList.add(&#39;disabled&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.classList.remove(&#39;disabled&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 现在，disabled属性一旦发生改变，this.container中的“disabled”类就会发生来回切换，它是这个元素影子DOM的div元素。 下面详细探讨一下影子DOM。 影子DOM 影子DOM可以将自定义元素的HTML和CSS完全封装在组件中。这意味着，元素以单个HTML标签的形式呈现在文件的DOM结构树中，其内部HTML结构放在#shadow-root中。 实际上，一些本地HTML元素也使用了影子DOM。例如，网页的&lt;video&gt;元素，它显示为一个单独的标签，但它也是显示播放和暂停视频的控件，但在浏览器的开发工具中是找不到&lt;video&gt;元素的。 实际上，控件&lt;video&gt;元素是影子DOM的一部分，因此在默认情况下它们时不可见的。要在Chrome中显示出影子DOM，可进入开发工具设置中的“首选项”，选中“显示用户代理影子DOM”复选框。此时在开发工具中查找&lt;video&gt;元素，我们可以找到并检查该元素的影子DOM。 影子DOM还可看出CSS的真正作用域。所有在组件内部定义的CSS只作用于组件本身。元素将从组件外部定义的CSS中继承最小数量的属性，甚至可以将这些属性配置为不从外层的CSS中继承任何值。不过，我们可以露出CSS属性，以便用户对组件进行样式设置。这解决了当前许多CSS问题，同时仍然支持给组件自定义样式。 定义一个影子根： const&nbsp;shadowRoot&nbsp;=&nbsp;this.attachShadow({mode:&nbsp;&#39;open&#39;});shadowRoot.innerHTML&nbsp;=&nbsp;`&lt;p&gt;Hello&nbsp;world&lt;/p&gt;`; 这里用mode:’open’定义了一个影子根，这意味着，可以在开发工具检出它并做交互，也可以发请求、配置共用CSS属性或监听事件。也可以用mode:’close’来定义影子根，但不建议这样定义，因为它不支持任何方式的交互，甚至不能监听其抛出的事件。 要将HTM添加到影子根中，我们可以给innerHTML属性分配HTML字符串，或者使用&lt;template&gt;元素。HTML模板基本上算是一个惰性的HTML片段，我们可先定义以供后续使用。在实际插入DOM结构树之前，它是不可见或不被解析的，这意味着在它内部定义的任何外部资源都不会被获取，任何CSS和JavaScript也都不会被解析。当组件的HTML随着状态发生改变时，我们可以定义多个&lt;template&gt;元素以便根据不同状态来做引入。如此一来，我们可以轻松的对组件HTML进行更改，而无需修改单个DOM节点。 一旦创建了影子根，我们可以像通常作用于document对象的方法一样，对其应用所有的DOM方法，例如，通过this.shadowRoot.querySelector方法来查找元素。组件的CSS都定义在&lt;style&gt;标签中，但如果希望使用常规的&lt;link rel=”stylesheet”&gt;标签，也可以获取到外部样式表。除了常规CSS之外，还可以使用:host选择器对组件本身进行样式设置。例如，自定义元素默认使用display: inline而将组件显示为块元素，可以写为: :host&nbsp;{&nbsp;&nbsp;display:&nbsp;block;} 它也支持为上下文设置样式。例如，如果希望在组件定义了disabled属性后显示为灰色，写为： :host([disabled])&nbsp;{&nbsp;&nbsp;opacity:&nbsp;0.5;} 默认情况下，自定义元素会继承一些外层CSS样式，比如颜色和字体等。但如果希望清空样式，将组件中所有的CSS样式重置为默认状态，可以写为： :host&nbsp;{&nbsp;&nbsp;all:&nbsp;initial;} 值得注意的是，外部定义于组件本身上的样式优先于使用:host在影子DOM中定义的样式。因此，如果定义： my-element&nbsp;{&nbsp;&nbsp;display:&nbsp;inline-block;} 它将覆盖： :host&nbsp;{&nbsp;&nbsp;display:&nbsp;block;} 我们不能从外部对自定义元素内的任何节点设置样式。如果想要支持用户对组件样式（某部分）进行设置，我们可以通过露出CSS变量来实现。例如，为便于用户选择组件的背景颜色，我们可以露出background-color这一CSS变量。 假设组件中影子DOM的根节点是&lt;div id=&quot;container&quot;&gt;： #container&nbsp;{&nbsp;&nbsp;background-color:&nbsp;var(--background-color);} 现在用户从外部设置组件的背景颜色: my-element&nbsp;{&nbsp;&nbsp;--background-color:&nbsp;#ff0000;} 我们要在组件内部为它设置一个默认值以防用户不对其设置： :host&nbsp;{&nbsp;&nbsp;--background-color:&nbsp;#ffffff;}#container&nbsp;{&nbsp;&nbsp;background-color:&nbsp;var(--background-color);} 当然，CSS变量的名称可以是任意的。它的唯一限制是要以“--”开头。 通过限定CSS和HTML的作用域，影子DOM解决了CSS全局特性带来的问题，即通常是只添加样式表而其中包含越来越多的特定选择器和覆盖问题。影子DOM支持在自包含组件中捆绑标记和样式，而无需任何工具或命名约定。因此，我们不必担心新的类或id会与现有类发生冲突。 我们可以通过CSS变量来给web组件设置内部样式，除此之外，还可以将HTML注入到web组件中。 组成元素slot 组成是将影子DOM结构树和用户标记组合在一起的过程。它可以通过&lt;slot&gt;元素实现，&lt;slot&gt;元素是在影子DOM中用来呈现用户所做标记的基本占位符。用户所做的标记被称为自然DOM。组合将自然DOM和影子DOM合成为新的DOM结构树。 例如，我们可以创建一个&lt;image-gallery&gt;组件，并提供标准的&lt;image&gt;标签用以渲染呈现： &lt;image-gallery&gt;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;bar.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&lt;/image-gallery&gt; 组件将会获取这两个图像，并通过slot在组件的影子DOM中渲染出来。注意图像上的slot=&quot;image&quot;属性。该属性告诉组件应该在影子DOM中的哪个位置呈现，比如可以是这样的： &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&nbsp;name=&quot;image&quot;&gt;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 当自然DOM中的节点被分布到元素的影子DOM中时，得到的DOM树看起来是这样的： &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&nbsp;name=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;bar.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 正如我们看到的，用户提供的元素都具有slot属性，它们都将在slot元素中呈现，而slot元素具有name属性，其值与slot属性值一致。 &lt;select&gt;元素的运行方式与在Chrome开发工具中查看它时所看到的完全一致（用户代理拿到用户选择的影子DOM时，如图）： 它获取用户提供的&lt;option&gt;元素并将它们呈现到下拉菜单中。 带有name属性的slot元素被称为命名slot，但此属性不是必须的。它仅用于在特定位置呈现内容。当一个或多个slot没有name属性时，其中内容的渲染顺序将遵循用户提供的顺序。当用户提供的内容少于slot时，slot甚至可以提供回退内容。 假设&lt;image-gallery&gt;的影子DOM是这样的: &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;No&nbsp;image&nbsp;here!&lt;/strong&gt;&nbsp;&lt;--&nbsp;fallback&nbsp;content&nbsp;--&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 同样提供两个图像，得到的影子DOM树将是： &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;bar.jpg&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;No&nbsp;image&nbsp;here!&lt;/strong&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 通过slot在影子DOM中呈现的元素称为分布式节点。这些节点在组件的影子DOM (分布式)中呈现之前，应用于它们的所有样式也将在分布之后得到应用。在影子DOM中，分布式节点可以通过::sloated()选择器获得额外的样式： ::slotted(img)&nbsp;{&nbsp;&nbsp;float:&nbsp;left;} :: sloated()可以接受任何有效的CSS选择器，但是它只能选择最高级的节点。例如::sloated (section img)将无法处理以下内容: &lt;image-gallery&gt;&nbsp;&nbsp;&lt;section&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&gt;&nbsp;&nbsp;&lt;/section&gt;&lt;/image-gallery&gt; JavaScript作用于slot 我们可以通过JavaScript与slot进行交互，通过查看节点分配到哪个slot，该slot对应哪个元素以及slotchange事件。 调用slot.assignedNodes()方法可以找出该slot对应的元素。如果还需要检索回调内容，可以调用slot.assignedNodes({flatten: true})。 查找slot中是否包含某个特定元素可以使用element.assignedSlot。 当slot节点发生变更时，即添加或删除节点将会触发slotchange事件。这里要注意，该事件会触发仅针对slot节点本身，而非slot节点的子节点。 slot.addEventListener(&#39;slotchange&#39;,&nbsp;e&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;const&nbsp;changedSlot&nbsp;=&nbsp;e.target;&nbsp;&nbsp;console.log(changedSlot.assignedNodes());}); 当元素是首次初始化时，Chrome会触发slotchange事件，而Safari和Firefox则不会。 影子DOM事件 默认情况下，自定义元素中诸如鼠标事件和键盘事件等标准事件会从影子DOM中弹出。影子DOM节点触发的事件会被重定向，所以该事件看起来像是源自自定义元素本身。如果想找出是影子DOM中由哪个元素触发了此事件，我们可以调用event.composedPath()来检索事件经过的节点数组。事件的target属性始终指向自定义元素本身。 我们可以使用CustomEvent从自定义元素中抛出任意事件。 class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.dispatchEvent(new&nbsp;CustomEvent(&#39;custom&#39;,&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detail:&nbsp;{message:&nbsp;&#39;a&nbsp;custom&nbsp;event&#39;}&nbsp;&nbsp;&nbsp;&nbsp;}));&nbsp;&nbsp;}}//&nbsp;on&nbsp;the&nbsp;outsidedocument.querySelector(&#39;my-element&#39;).addEventListener(&#39;custom&#39;,&nbsp;e&nbsp;=&gt;&nbsp;console.log(&#39;message&nbsp;from&nbsp;event:&#39;,&nbsp;e.detail.message)); 但是，当事件是从影子DOM中的节点抛出而不是其自定义元素本身时，它不会从影子DOM中弹出，除非它是用composition: true创建的： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#container&#39;);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;dispatchEvent&nbsp;is&nbsp;now&nbsp;called&nbsp;on&nbsp;this.container&nbsp;instead&nbsp;of&nbsp;this&nbsp;&nbsp;&nbsp;&nbsp;this.container.dispatchEvent(new&nbsp;CustomEvent(&#39;custom&#39;,&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detail:&nbsp;{message:&nbsp;&#39;a&nbsp;custom&nbsp;event&#39;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;composed:&nbsp;true&nbsp;&nbsp;//&nbsp;without&nbsp;composed:&nbsp;true&nbsp;this&nbsp;event&nbsp;will&nbsp;not&nbsp;bubble&nbsp;out&nbsp;of&nbsp;Shadow&nbsp;DOM&nbsp;&nbsp;&nbsp;&nbsp;}));&nbsp;&nbsp;}} 模块元素 除了可以使用this.shadowRoot.innerHTML将HTML添加到影子根中，我们也可以用&lt;template&gt;元素。模板可保存HTML以供后续使用。它并未渲染出来，而最初的解析是为了确保其内容的有效性。模板中的JavaScript不执行，也不会获取任何外部资源。默认情况下它是隐性的。 当一个web组件需要根据不同的情况呈现完全不同的标记时，可以使用不同的模板来完成: class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;shadowRoot&nbsp;=&nbsp;this.attachShadow({mode:&nbsp;&#39;open&#39;});&nbsp;&nbsp;&nbsp;&nbsp;this.shadowRoot.innerHTML&nbsp;=&nbsp;`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;template&nbsp;id=&quot;view1&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;is&nbsp;view&nbsp;1&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/template&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;template&nbsp;id=&quot;view1&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;is&nbsp;view&nbsp;1&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/template&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;is&nbsp;the&nbsp;container&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;`;&nbsp;&nbsp;}&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;content&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#view1&#39;).content.clondeNode(true);&nbsp;&nbsp;&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#container&#39;);&nbsp;&nbsp;&nbsp;&nbsp;this.container.appendChild(content);&nbsp;&nbsp;}} 在这里，两个模板都通过innerHTML置于元素的影子根中。起初，这两个模板都是不可见的，只看得到容器。connectedCallback方法中，我们通过this.shadowRoot.querySelector(&#39;#view1&#39;).content.clondeNode(true)获取#view1的内容。模板的content属性以DocumentFragment返回模板的内容，可以使用appendChild将其添加到另一个元素中。当某元素已存在于DOM中时，使用appendChild将会移动它，所以我们要先使用cloneNode(true)克隆它。否则，模板的内容将会被移动而不是附加，这就意味着我们只能使用一次了。 模板对于快速更改大多数HTML或可复用的标签非常有用。它们不仅限于web组件，而且可以在DOM中的任何地方使用。 本地元素的扩展 到目前为止，我们一直在扩展HTMLElement来创建一个全新的HTML元素。自定义元素还支持扩展原生内置元素，支持增强已经存在的HTML元素，例如图像和按钮。在撰写本文时，此功能仅有Chrome和Firefox浏览器支持。 扩展现有HTML元素的好处是其继承了元素的所有属性和方法。这允许对现有元素进行逐步增强，这意味着即使在不支持自定义元素的浏览器中加载元素，它仍然是可用的。它只会退回到默认的内置行为，而如果它是一个全新的HTML标记，那么它根本就不能使用。 例如，我们希望增强HTML中的&lt;button&gt;元素： class&nbsp;MyButton&nbsp;extends&nbsp;HTMLButtonElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;super();&nbsp;&nbsp;//&nbsp;always&nbsp;call&nbsp;super()&nbsp;to&nbsp;run&nbsp;the&nbsp;parent&#39;s&nbsp;constructor&nbsp;as&nbsp;well&nbsp;&nbsp;}&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;}&nbsp;&nbsp;someMethod()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;}}customElements.define(&#39;my-button&#39;,&nbsp;MyButton,&nbsp;{extends:&nbsp;&#39;button&#39;}); 我们的web组件不再扩展更通用的HTMLElement，而是扩展HTMLButtonElement。对customElements.define的调用还需要一个额外的参数{extends: &#39;button&#39;}，以此表示我们的类扩展了&lt;button&gt;元素。这看起来可能有些多余，因为我们已经表明了我们想要扩展HTMLButtonElement，但是这是必要的，因为有一些元素共享相同的DOM接口。例如，&lt;q&gt;和&lt;blockquote&gt;共用HTMLQuoteElement接口。 增强后的按钮可以与is属性一起使用: &lt;button&nbsp;is=&quot;my-button&quot;&gt; 现在它将被我们的MyElement类增强，如果它加载在一个不兼容自定义元素的浏览器中，它将简单地退回到一个标准按钮，真正意义上的渐进增强！ 注意，在扩展现有元素时，不能使用影子DOM。这只是一种扩展原生HTML元素的方法，它继承了所有现有的属性、方法和事件，并提供了额外的功能。当然，可以在组件中修改元素的DOM和CSS，但是试图创建一个影子根的话，它将会抛出一个错误。 扩展内置元素的另一个好处是，这些元素也可以用于应用元素子元素限制的地方。例如，&lt;thead&gt;&nbsp;元素只允许将&lt;tr&gt;&nbsp;元素作为其子元素，因此&lt;awesome-tr&gt;元素将呈现无效的标记。在这种情况下，我们可以扩展内置的&lt;tr&gt;&nbsp;元素，并像这样使用它: &lt;table&gt;&nbsp;&nbsp;&lt;thead&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&nbsp;is=&quot;awesome-tr&quot;&gt;&lt;/tr&gt;&nbsp;&nbsp;&lt;/thead&gt;&lt;/table&gt; 这种创建web组件的方式带来了巨大的渐进式增强，但正如前面提到的，目前这仅有Chrome和Firefox支持实现。Edge也将能兼容它，但不幸的是，在Safari中不能支持实现。 测试web组件 与为Angular和React之类的框架编写测试用例相比，测试web组件既简单又直接，而且坦率地说，这是一件轻而易举的事情。这无需换位或进行复杂的设置。只需创建元素，将其附加到DOM中并运行测试。 下面是一个使用Mocha测试的例子: import&nbsp;&#39;path/to/my-element.js&#39;;describe(&#39;my-element&#39;,&nbsp;()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;let&nbsp;element;&nbsp;&nbsp;beforeEach(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;element&nbsp;=&nbsp;document.createElement(&#39;my-element&#39;);&nbsp;&nbsp;&nbsp;&nbsp;document.body.appendChild(element);&nbsp;&nbsp;});&nbsp;&nbsp;afterEach(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;document.body.removeChild(element);&nbsp;&nbsp;});&nbsp;&nbsp;it(&#39;should&nbsp;test&nbsp;my-element&#39;,&nbsp;()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;run&nbsp;your&nbsp;test&nbsp;here&nbsp;&nbsp;});}); 在这里，第一行导入my-element.js文件，该文件将我们的web组件露出为一个ES6模块。这意味着测试文件本身也需要作为一个ES6模块加载到浏览器中。这需要以下index.html能够在浏览器中运行测试。除了Mocha，这个设置还加载WebcomponentsJS &nbsp;polyfill和Chai用于测试判断，以及Sinon用来检测和模拟: &lt;!doctype&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;charset=&quot;utf-8&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;link&nbsp;rel=&quot;stylesheet&quot;&nbsp;href=&quot;../node_modules/mocha/mocha.css&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/sinon/pkg/sinon.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/chai/chai.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/mocha/mocha.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.assert&nbsp;=&nbsp;chai.assert;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mocha.setup(&#39;bdd&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;module&quot;&nbsp;src=&quot;path/to/my-element.test.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;module&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mocha.run();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;mocha&quot;&gt;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt; 加载所需的脚本后，我们将露出chai.assert作为一个全局变量，因此我们可以在测试中简单地使用assert()，并设置Mocha来使用BDD接口。然后加载测试文件(在本例中只有一个)，并通过调用mocha.run()运行测试。 请注意，在使用ES6模块时，还需要将mocha.run()放在type=&quot;module&quot;的脚本中。这是因为ES6模块在默认情况下是延迟的，如果mocha.run()放在一个正则脚本标记中，它将在加载my-element.test.js之前执行。 Polyfill老式浏览器 目前，Chrome、Firefox、Safari和Opera的最新版本都支持自定义元素，即将推出的Edge 19也将支持自定义元素。在iOS和Android上，Safari、Chrome和Firefox都能兼容它们。 旧版本浏览器的WebcomponentsJS polyfill可通过以下途径安装: npm&nbsp;install&nbsp;--save&nbsp;@webcomponents/webcomponentsjs 我们可以引入webcomponents-loader.js文件，该文件将进行特性检测，只加载必要的填充内容。使用此方法，我们可以使用自定义元素，而不需要向源代码添加任何东西。但是，它没有提供真正的CSS作用域，这意味着如果在不同的web组件中包含有相同的类名和id，并将它们加载到相同的文档中，它们将发生冲突。此外，影子DOM的 CSS选择器:host()和:sloated()可能无法正常工作。 为了使其正常运行，我们需要使用Shady CSS polyfill，这也意味着必须(稍微)修改源代码才能使用它。我个人认为这是不可取的，所以我创建了一个webpack加载器，它可以处理这个问题。这表明必须进行转置，但是我们可以保持代码不变。 webpack加载器会做这三件事:它在web组件的影子DOM中为所有CSS规则加上前缀，这些CSS规则不是以元素名加::host或::slotted&nbsp;开头的，他们提供适当的范围。然后，它解析所有::host和::slot规则，以确保它们也能正确工作。 工作示例1:lazy-img 我创建了一个web组件，当图像在浏览器的视图中完全可见时，它就会惰性地加载图像。具体请参考Github。 组件的主体将本地&lt;img&gt;&nbsp;标签封装在&lt;lazy-img&gt;&nbsp;自定义元素中: &lt;lazy-img&nbsp;&nbsp;src=&quot;path/to/image.jpg&quot;&nbsp;&nbsp;width=&quot;480&quot;&nbsp;&nbsp;height=&quot;320&quot;&nbsp;&nbsp;delay=&quot;500&quot;&nbsp;&nbsp;margin=&quot;0px&quot;&gt;&lt;/lazy-img&gt; 下例还包含了extend-native分支，其中包含lazy-img，它使用is属性扩展原生&lt;img&gt;标签: &lt;img&nbsp;&nbsp;is=&quot;lazy-img&quot;&nbsp;&nbsp;src=&quot;path/to/img.jpg&quot;&nbsp;&nbsp;width=&quot;480&quot;&nbsp;&nbsp;height=&quot;320&quot;&nbsp;&nbsp;delay=&quot;500&quot;&nbsp;&nbsp;margin=&quot;0px&quot;&gt; 这是一个说明原生web组件强大功能的很好的例子:只需导入JavaScript文件、添加HTML标签或使用is属性扩展原生web组件，大功告成! 工作示例2:material-webcomponents 我使用自定义元素实现了谷歌的材质设计，具体也请参考Github。 这个库还展示了CSS自定义属性的强大功能，其中包含大量的自定义属性。 那么，应该抛弃框架吗? 当然，这要视情况而定。 目前的前端框架因具有数据绑定、状态管理和相当标准化的代码库等功能而带来了额外的价值。但问题是你的应用程序是否真的需要它。 如果还需要问自己，我的应用程序是否真的需要Redux之类的状态管理，那么你可能就是不需要它的。你渐渐就明白了。 使用数据绑定可能有好处，但是对于数组和对象等非基本值，原生web组件已经支持用户直接设置属性。我们可以在属性上设置基本值，并且可以通过attributeChangedCallback观察这些属性的更改。 虽然这种方法看起来非常合理，但是与React和Angular的声明式方法相比，它会使得更新DOM的某一部分变得非常麻烦和冗长。这些框架支持定义一个视图，它包含当表达式变更时更新的表达式。 原生web组件(还)不提供这样的功能，尽管有人建议扩展&lt;template&gt;元素，使其可以用数据实例化和更新： &lt;template&nbsp;id=&quot;example&quot;&gt;&nbsp;&nbsp;&lt;h1&gt;{{title}}&lt;/h1&gt;&nbsp;&nbsp;&lt;p&gt;{{text}}&lt;/p&gt;&lt;/template&gt;const&nbsp;template&nbsp;=&nbsp;document.querySelector(&#39;#example&#39;);const&nbsp;instance&nbsp;=&nbsp;template.createInstance({title:&nbsp;&#39;The&nbsp;title&#39;,&nbsp;text:&nbsp;&#39;Hello&nbsp;world&#39;});shadowRoot.appendChild(instance.content);//updateinstance.update({title:&nbsp;&#39;A&nbsp;new&nbsp;title&#39;,&nbsp;text:&nbsp;&#39;Hi&nbsp;there&#39;}); 当前可以支持有效DOM更新的库是lit -html。 另一个经常提到前端框架的好处是，它们提供了一个标准的代码基，团队中的每个新开发人员都将从一开始就熟悉这个代码基。虽然我相信这是真的，但我也认为这种好处是相当有限的。 我曾经用Angular、React和Polymer做过很多项目，虽然大家对它们都很熟悉，但是尽管使用了相同的框架，这些代码库还是有很大的不同。清晰定义的工作方式和样式指南比简单地使用框架更有助于代码库的一致性。框架也带来了额外的复杂性，所以问问自己这是否真的值得 现在web组件得到了广泛的支持，我们可能会得出这样的结论:原生代码可以提供与框架相同的功能，但是性能更好、代码更少、复杂度更低。 本地web组件的好处很明显: 原生，不需要框架； 易于集成，不需要移位； CSS有真正的作用域； 规范，只有HTML, CSS和JavaScript。 jQuery及其尤为出色的资源将会继续存在一段时间，但是没有太多人会使用它构建的新项目，因为现在有了更好的选择。我不认为目前的框架会很快消失，但是以原生web组件形式出现的更优选择正在出现，并且迅速获得关注。我确实期望这些前端框架的角色会发生巨大变化，届时它们将仅给本地web组件提供一个薄外层。 原文：https://www.dannymoerkerke.com/blog/web-components-will-replace-your-frontend-framework 本文为 CSDN 翻译，转载请注明来源出处。 【END】 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞互联网出海十年 ☞面试一线互联网大厂？那这道题目你必须得会！ ☞华为在剑桥建芯片厂；小米公布出货量反驳调研机构； 中移动否认限制号 | 极客头条 ☞天才程序员：25 岁进贝尔实验室，32 岁创建信息论 ☞&nbsp;扎心！工作 10 年，月薪过万者不足三成，程序员却笑了 ☞6张图告诉你, 区块链的未来在哪里 ☞我们应聘BAT等互联网公司，关于Spring到底需要掌握什么？ ☞如何确定最佳训练数据集规模？6 大必备“锦囊”全给你了 | 技术头条 ☞&nbsp;她说：为啥程序员都特想要机械键盘？这答案我服！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 点击阅读原文，输入关键词，即可搜索您想要的 CSDN 文章。 你点的每个“在看”，我都认真当成了喜欢" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"【CSDN 编者按】提起前端开发，不少开发者首先会对主流技术框架如 Vue、React、Angular 进行一番对比之后，选择相应的技术架构。 在此，随着前端框架的不断升级，其也变得越来越臃肿与复杂，那么，未来前端框架是否会被取而代之？ 作者 |&nbsp;Danny Moerkerke 译者 |&nbsp;谭开朗 责编 | 屠敏 出品 | CSDN（ID：CSDNnews） 以下为译文： 还记得吗？当时document.querySelector首次被浏览器广泛采用，就此终结了jQuery的通用时代。对于多年来一直沿用jQuery来实现的功能，document.querySelector提供了原生方法：轻松的选取DOM元素。我相信，类似的情况也将会发生在诸如Angular和React的前端框架上。 前端框架为我们一直想做却未能做到的事情提供了可能：创建可复用的自动化前端组件，但它复杂性较高，还有专属语法和较高的有效负载。 前端框架正渐渐被取代。 现代Web API发展至今，我们已无需依赖框架来创建可复用的前端组件。我们所需创建的自定义组件就是自定义元素和影子DOM，这可以在任意地方复用。 2011年开始推出的Web组件，它支持仅通过HTML、CSS和JavaScript就能创建出可复用组件。这意味着，我们无需使用诸如React或Angular的框架就能构建出组件。更锦上添花的是，这些组件可以无缝集成到框架中。 有史以来第一次，我们仅通过HTML，CSS和JavaScript就成功构建了可兼容任意浏览器的可复用组件。Web组件现在可以兼容桌面最新的Chrome、Safari、Firefox和Opera浏览器，还有iOS的Safari浏览器和Android的Chrome浏览器。 Edge浏览器即将发布的第19版中也将得到兼容。对于较老的浏览器，它将会通过polyfill将其引入到IE 11浏览器中。 这意味着，目前基本任一浏览器都可以使用Web组件，包括移动端浏览器。 只需简单的引入一个脚本，我们就可以创建自定义HTML标签，它不仅继承了HTML元素扩展出的所有属性，还能在其支持的任意浏览器中使用。组件中定义的所有HTML，CSS和JavaScript都完全限定在组件的作用域内。 组件在浏览器的开发工具中显示为单个HTML标签，样式和逻辑是完全封装好的，无需方法转换，框架或换位。 一起来学习Web组件的主要特性吧。 自定义元素 自定义元素单纯是用户定义的HTML元素。其可通过CustomElementRegistry来定义。要定义新元素，先通过window.customElements来获取注册实例，再调用它的define方法： window.customElements.define(&#39;my-element&#39;,&nbsp;MyElement); 上述define方法中的第一个参数是新建元素的标签名。可这样来实现简单的添加： &lt;my-element&gt;&lt;/my-element&gt;&nbsp; 名称中的破折号（-）是必不可少的，它可以避免与原生HTML元素发生重名。 MyElement构造函数必须是一个ES6类，因为Javascript类（暂时还）不像传统的OOP类，而且容易混淆。此外，如果它支持使用object，那么也可以使用Proxy为自定义元素启用简单的数据绑定。但是需要对此作出限制，以便启用原生HTML的拓展属性并确保元素继承了整个DOM API。 为自定义元素编写类: class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;super();&nbsp;&nbsp;}&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;here&nbsp;the&nbsp;element&nbsp;has&nbsp;been&nbsp;inserted&nbsp;into&nbsp;the&nbsp;DOM&nbsp;&nbsp;}} 自定义元素的类只是一个扩展了原生HTMLElement的常规JavaScript类。除了它的构造函数之外，还有一个名为connectedCallback的方法，当有元素插入到DOM中时，这个方法就会被调用。我们可以将其与React的componentDidMount方法进行比较。 通常情况下，组件的设置尽量放在connectedCallback中，因为connectedCallback是唯一能拿到稳定属性且子元素可用的地方。构造函数通常只用于初始化状态和设置影子DOM。 元素的constructor函数和connectedCallback函数之间的区别是，创建元素时调用构造函数（例如调用document.createElement），而connectedCallback函数是在元素已插入DOM后调用，比如声明文件被解析或已通过document.body.appendChild添加。 也可通过引用构造函数customElements.get(&#39;my-element&#39;)来创建元素，前提是它已经注册了customelelements.define()。然后用new element()方法实例化元素，而非document.createElement()方法： customElements.define(&#39;my-element&#39;,&nbsp;class&nbsp;extends&nbsp;HTMLElement&nbsp;{...});...const&nbsp;el&nbsp;=&nbsp;customElements.get(&#39;my-element&#39;);const&nbsp;myElement&nbsp;=&nbsp;new&nbsp;el();&nbsp;&nbsp;//&nbsp;same&nbsp;as&nbsp;document.createElement(&#39;my-element&#39;);document.body.appendChild(myElement); connectedCallback的对应函数是disconnectedCallback，当元素从DOM中删除时会调用它。此方法支持执行任何必要的清除工作，但请记住，用户关闭浏览器或关闭浏览器选项卡并不会调用此方法。 还有adoptedCallback函数，它是在通过调用document. adoptnode(element)来将元素引入到文档中时被调用。到目前为止，我还从未遇到过使用该回调的情况。 另一个有用的生命周期函数是attributeChangedCallback函数。它在observedAttributes数组的属性发生变更时被调用。调用时需传入属性名、旧值和新值： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;static&nbsp;get&nbsp;observedAttributes()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[&#39;foo&#39;,&nbsp;&#39;bar&#39;];&nbsp;&nbsp;}&nbsp;&nbsp;attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;switch(attr)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&#39;foo&#39;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;with&nbsp;&#39;foo&#39;&nbsp;attribute&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&#39;bar&#39;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;with&nbsp;&#39;bar&#39;&nbsp;attribute&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 这个回调只会在observedAttributes数组包含的属性中发生调用，在本例中是foo和bar。如果是其他任意的属性变化，此回调不会发生调用。 属性主要用于声明元素的初始配置/状态。理论上，可以通过序列化将复杂的值传递给属性，但这可能会影响性能，因为我们可以通过访问组件的方法来替代。但是，如果确实希望通过像React和Angular这样的框架提供的属性来绑定，那么可以试试Polymer。 生命周期方法的执行顺序 生命周期方法的执行顺序是： constructor&nbsp;-&gt;&nbsp;attributeChangedCallback&nbsp;-&gt;&nbsp;connectedCallback 为什么attributeChangedCallback方法会在connectedCallback方法之前执行？ 回想一下，web组件属性的主要用途是初始化配置。这意味着，当组件引入到DOM中时此配置必须是可用的，因此需要在connectedCallback方法之前调用attributeChangedCallback方法。 这也意味着，如果需要基于某特定属性在影子DOM中配置节点，我们需要在constructor函数中引入该节点，而非在connectedCallback中。 例如，组件中有一个id=”container”的元素，我们需要在其可见属性禁用的情况下给它添加一个灰色背景，我们可以在constructor函数中引入这个元素，以便在attributeChangedCallback函数中可以调用: constructor()&nbsp;{&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#container&#39;);}attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{&nbsp;&nbsp;if(attr&nbsp;===&nbsp;&#39;disabled&#39;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if(this.hasAttribute(&#39;disabled&#39;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.background&nbsp;=&nbsp;&#39;#808080&#39;;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.style.background&nbsp;=&nbsp;&#39;#ffffff&#39;;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 如果等到connectedCallback方法中才创建this.container，那么在首次调用attributeChangedCallback方法时，它还是不可用的。因此，尽管我们尽可能的将组件的设置放在connectedCallback中，但在这种情况下也是不可行的。 同样重要的是，在通过customelelements.define()注册之前，我们就可以使用该web组件。当该元素出现在DOM中或插入到DOM中，且尚未注册时，它将是HTMLUnknownElement的一个实例。浏览器将会处理这类它不认识的HTML元素，我们可以和其他元素一样为它设置交互逻辑，但除此之外，它没有任何方法或默认的样式。 当通过customelelements .define()注册它时，可通过定义类来增强它。这个过程称为升级。当使用customElements.whenDefined升级元素时，可以调用回调，它会返回元素升级后的Promise方法： customElements.whenDefined(&#39;my-element&#39;).then(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;//&nbsp;my-element&nbsp;is&nbsp;now&nbsp;defined}) Web组件的公共API 除了上述生命周期方法，我们可以给元素定义外部访问的方法，这是使用React或Angular等框架定义元素所实现不了的。例如，我们定义一个名为doSomething的方法： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;doSomething()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;in&nbsp;this&nbsp;method&nbsp;&nbsp;}} 并从组件外部来调用它： const&nbsp;element&nbsp;=&nbsp;document.querySelector(&#39;my-element&#39;);element.doSomething(); 在元素上定义的方法都将是其公共JavaScript API的一部分。通过这种方式，我们可以通过为元素的属性提供setter来实现数据绑定，例如，设置setter将在元素的HTML中呈现属性值。由于在本质上不可能向属性提供字符串以外的任何其他值，所以应该将像对象这样的复杂值作为属性传递给自定义元素。 除了声明web组件的初始状态外，属性还用于反映相应属性的值，以便将元素的JavaScript状态反映到它的DOM表示。input元素中的disabled属性就是其中一个例子: &lt;input&nbsp;name=&quot;name&quot;&gt;const&nbsp;input&nbsp;=&nbsp;document.querySelector(&#39;input&#39;);input.disabled&nbsp;=&nbsp;true; 将input的属性disabled设置为true后，此更改将映射到相应的disabled 属性中: &lt;input&nbsp;name=&quot;name&quot;&nbsp;disabled&gt; 通过setter可以很容易地实现属性到属性的反射: class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;set&nbsp;disabled(isDisabled)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if(isDisabled)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setAttribute(&#39;disabled&#39;,&nbsp;&#39;&#39;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.removeAttribute(&#39;disabled&#39;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;get&nbsp;disabled()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this.hasAttribute(&#39;disabled&#39;);&nbsp;&nbsp;}} 当属性发生改变而需要执行某些操作时，可将其添加到observedAttributes数组中。作为一种性能优化，只能监听该数组列出的属性。当属性的值发生变化时，attributeChangedCallback将通过传入属性名及其当前值和新值来调用： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;get&nbsp;observedAttributes()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[&#39;disabled&#39;];&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;shadowRoot&nbsp;=&nbsp;this.attachShadow({mode:&nbsp;&#39;open&#39;});&nbsp;&nbsp;&nbsp;&nbsp;shadowRoot.innerHTML&nbsp;=&nbsp;`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.disabled&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opacity:&nbsp;0.4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;container&quot;&gt;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`;&nbsp;&nbsp;&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot(&#39;#container&#39;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(attr&nbsp;===&nbsp;&#39;disabled&#39;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.disabled)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.classList.add(&#39;disabled&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.container.classList.remove(&#39;disabled&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}} 现在，disabled属性一旦发生改变，this.container中的“disabled”类就会发生来回切换，它是这个元素影子DOM的div元素。 下面详细探讨一下影子DOM。 影子DOM 影子DOM可以将自定义元素的HTML和CSS完全封装在组件中。这意味着，元素以单个HTML标签的形式呈现在文件的DOM结构树中，其内部HTML结构放在#shadow-root中。 实际上，一些本地HTML元素也使用了影子DOM。例如，网页的&lt;video&gt;元素，它显示为一个单独的标签，但它也是显示播放和暂停视频的控件，但在浏览器的开发工具中是找不到&lt;video&gt;元素的。 实际上，控件&lt;video&gt;元素是影子DOM的一部分，因此在默认情况下它们时不可见的。要在Chrome中显示出影子DOM，可进入开发工具设置中的“首选项”，选中“显示用户代理影子DOM”复选框。此时在开发工具中查找&lt;video&gt;元素，我们可以找到并检查该元素的影子DOM。 影子DOM还可看出CSS的真正作用域。所有在组件内部定义的CSS只作用于组件本身。元素将从组件外部定义的CSS中继承最小数量的属性，甚至可以将这些属性配置为不从外层的CSS中继承任何值。不过，我们可以露出CSS属性，以便用户对组件进行样式设置。这解决了当前许多CSS问题，同时仍然支持给组件自定义样式。 定义一个影子根： const&nbsp;shadowRoot&nbsp;=&nbsp;this.attachShadow({mode:&nbsp;&#39;open&#39;});shadowRoot.innerHTML&nbsp;=&nbsp;`&lt;p&gt;Hello&nbsp;world&lt;/p&gt;`; 这里用mode:’open’定义了一个影子根，这意味着，可以在开发工具检出它并做交互，也可以发请求、配置共用CSS属性或监听事件。也可以用mode:’close’来定义影子根，但不建议这样定义，因为它不支持任何方式的交互，甚至不能监听其抛出的事件。 要将HTM添加到影子根中，我们可以给innerHTML属性分配HTML字符串，或者使用&lt;template&gt;元素。HTML模板基本上算是一个惰性的HTML片段，我们可先定义以供后续使用。在实际插入DOM结构树之前，它是不可见或不被解析的，这意味着在它内部定义的任何外部资源都不会被获取，任何CSS和JavaScript也都不会被解析。当组件的HTML随着状态发生改变时，我们可以定义多个&lt;template&gt;元素以便根据不同状态来做引入。如此一来，我们可以轻松的对组件HTML进行更改，而无需修改单个DOM节点。 一旦创建了影子根，我们可以像通常作用于document对象的方法一样，对其应用所有的DOM方法，例如，通过this.shadowRoot.querySelector方法来查找元素。组件的CSS都定义在&lt;style&gt;标签中，但如果希望使用常规的&lt;link rel=”stylesheet”&gt;标签，也可以获取到外部样式表。除了常规CSS之外，还可以使用:host选择器对组件本身进行样式设置。例如，自定义元素默认使用display: inline而将组件显示为块元素，可以写为: :host&nbsp;{&nbsp;&nbsp;display:&nbsp;block;} 它也支持为上下文设置样式。例如，如果希望在组件定义了disabled属性后显示为灰色，写为： :host([disabled])&nbsp;{&nbsp;&nbsp;opacity:&nbsp;0.5;} 默认情况下，自定义元素会继承一些外层CSS样式，比如颜色和字体等。但如果希望清空样式，将组件中所有的CSS样式重置为默认状态，可以写为： :host&nbsp;{&nbsp;&nbsp;all:&nbsp;initial;} 值得注意的是，外部定义于组件本身上的样式优先于使用:host在影子DOM中定义的样式。因此，如果定义： my-element&nbsp;{&nbsp;&nbsp;display:&nbsp;inline-block;} 它将覆盖： :host&nbsp;{&nbsp;&nbsp;display:&nbsp;block;} 我们不能从外部对自定义元素内的任何节点设置样式。如果想要支持用户对组件样式（某部分）进行设置，我们可以通过露出CSS变量来实现。例如，为便于用户选择组件的背景颜色，我们可以露出background-color这一CSS变量。 假设组件中影子DOM的根节点是&lt;div id=&quot;container&quot;&gt;： #container&nbsp;{&nbsp;&nbsp;background-color:&nbsp;var(--background-color);} 现在用户从外部设置组件的背景颜色: my-element&nbsp;{&nbsp;&nbsp;--background-color:&nbsp;#ff0000;} 我们要在组件内部为它设置一个默认值以防用户不对其设置： :host&nbsp;{&nbsp;&nbsp;--background-color:&nbsp;#ffffff;}#container&nbsp;{&nbsp;&nbsp;background-color:&nbsp;var(--background-color);} 当然，CSS变量的名称可以是任意的。它的唯一限制是要以“--”开头。 通过限定CSS和HTML的作用域，影子DOM解决了CSS全局特性带来的问题，即通常是只添加样式表而其中包含越来越多的特定选择器和覆盖问题。影子DOM支持在自包含组件中捆绑标记和样式，而无需任何工具或命名约定。因此，我们不必担心新的类或id会与现有类发生冲突。 我们可以通过CSS变量来给web组件设置内部样式，除此之外，还可以将HTML注入到web组件中。 组成元素slot 组成是将影子DOM结构树和用户标记组合在一起的过程。它可以通过&lt;slot&gt;元素实现，&lt;slot&gt;元素是在影子DOM中用来呈现用户所做标记的基本占位符。用户所做的标记被称为自然DOM。组合将自然DOM和影子DOM合成为新的DOM结构树。 例如，我们可以创建一个&lt;image-gallery&gt;组件，并提供标准的&lt;image&gt;标签用以渲染呈现： &lt;image-gallery&gt;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;bar.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&lt;/image-gallery&gt; 组件将会获取这两个图像，并通过slot在组件的影子DOM中渲染出来。注意图像上的slot=&quot;image&quot;属性。该属性告诉组件应该在影子DOM中的哪个位置呈现，比如可以是这样的： &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&nbsp;name=&quot;image&quot;&gt;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 当自然DOM中的节点被分布到元素的影子DOM中时，得到的DOM树看起来是这样的： &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&nbsp;name=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;bar.jpg&quot;&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 正如我们看到的，用户提供的元素都具有slot属性，它们都将在slot元素中呈现，而slot元素具有name属性，其值与slot属性值一致。 &lt;select&gt;元素的运行方式与在Chrome开发工具中查看它时所看到的完全一致（用户代理拿到用户选择的影子DOM时，如图）： 它获取用户提供的&lt;option&gt;元素并将它们呈现到下拉菜单中。 带有name属性的slot元素被称为命名slot，但此属性不是必须的。它仅用于在特定位置呈现内容。当一个或多个slot没有name属性时，其中内容的渲染顺序将遵循用户提供的顺序。当用户提供的内容少于slot时，slot甚至可以提供回退内容。 假设&lt;image-gallery&gt;的影子DOM是这样的: &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;No&nbsp;image&nbsp;here!&lt;/strong&gt;&nbsp;&lt;--&nbsp;fallback&nbsp;content&nbsp;--&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 同样提供两个图像，得到的影子DOM树将是： &lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;images&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;bar.jpg&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;slot&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;No&nbsp;image&nbsp;here!&lt;/strong&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/slot&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt; 通过slot在影子DOM中呈现的元素称为分布式节点。这些节点在组件的影子DOM (分布式)中呈现之前，应用于它们的所有样式也将在分布之后得到应用。在影子DOM中，分布式节点可以通过::sloated()选择器获得额外的样式： ::slotted(img)&nbsp;{&nbsp;&nbsp;float:&nbsp;left;} :: sloated()可以接受任何有效的CSS选择器，但是它只能选择最高级的节点。例如::sloated (section img)将无法处理以下内容: &lt;image-gallery&gt;&nbsp;&nbsp;&lt;section&nbsp;slot=&quot;image&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=&quot;foo.jpg&quot;&gt;&nbsp;&nbsp;&lt;/section&gt;&lt;/image-gallery&gt; JavaScript作用于slot 我们可以通过JavaScript与slot进行交互，通过查看节点分配到哪个slot，该slot对应哪个元素以及slotchange事件。 调用slot.assignedNodes()方法可以找出该slot对应的元素。如果还需要检索回调内容，可以调用slot.assignedNodes({flatten: true})。 查找slot中是否包含某个特定元素可以使用element.assignedSlot。 当slot节点发生变更时，即添加或删除节点将会触发slotchange事件。这里要注意，该事件会触发仅针对slot节点本身，而非slot节点的子节点。 slot.addEventListener(&#39;slotchange&#39;,&nbsp;e&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;const&nbsp;changedSlot&nbsp;=&nbsp;e.target;&nbsp;&nbsp;console.log(changedSlot.assignedNodes());}); 当元素是首次初始化时，Chrome会触发slotchange事件，而Safari和Firefox则不会。 影子DOM事件 默认情况下，自定义元素中诸如鼠标事件和键盘事件等标准事件会从影子DOM中弹出。影子DOM节点触发的事件会被重定向，所以该事件看起来像是源自自定义元素本身。如果想找出是影子DOM中由哪个元素触发了此事件，我们可以调用event.composedPath()来检索事件经过的节点数组。事件的target属性始终指向自定义元素本身。 我们可以使用CustomEvent从自定义元素中抛出任意事件。 class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.dispatchEvent(new&nbsp;CustomEvent(&#39;custom&#39;,&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detail:&nbsp;{message:&nbsp;&#39;a&nbsp;custom&nbsp;event&#39;}&nbsp;&nbsp;&nbsp;&nbsp;}));&nbsp;&nbsp;}}//&nbsp;on&nbsp;the&nbsp;outsidedocument.querySelector(&#39;my-element&#39;).addEventListener(&#39;custom&#39;,&nbsp;e&nbsp;=&gt;&nbsp;console.log(&#39;message&nbsp;from&nbsp;event:&#39;,&nbsp;e.detail.message)); 但是，当事件是从影子DOM中的节点抛出而不是其自定义元素本身时，它不会从影子DOM中弹出，除非它是用composition: true创建的： class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#container&#39;);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;dispatchEvent&nbsp;is&nbsp;now&nbsp;called&nbsp;on&nbsp;this.container&nbsp;instead&nbsp;of&nbsp;this&nbsp;&nbsp;&nbsp;&nbsp;this.container.dispatchEvent(new&nbsp;CustomEvent(&#39;custom&#39;,&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detail:&nbsp;{message:&nbsp;&#39;a&nbsp;custom&nbsp;event&#39;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;composed:&nbsp;true&nbsp;&nbsp;//&nbsp;without&nbsp;composed:&nbsp;true&nbsp;this&nbsp;event&nbsp;will&nbsp;not&nbsp;bubble&nbsp;out&nbsp;of&nbsp;Shadow&nbsp;DOM&nbsp;&nbsp;&nbsp;&nbsp;}));&nbsp;&nbsp;}} 模块元素 除了可以使用this.shadowRoot.innerHTML将HTML添加到影子根中，我们也可以用&lt;template&gt;元素。模板可保存HTML以供后续使用。它并未渲染出来，而最初的解析是为了确保其内容的有效性。模板中的JavaScript不执行，也不会获取任何外部资源。默认情况下它是隐性的。 当一个web组件需要根据不同的情况呈现完全不同的标记时，可以使用不同的模板来完成: class&nbsp;MyElement&nbsp;extends&nbsp;HTMLElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;shadowRoot&nbsp;=&nbsp;this.attachShadow({mode:&nbsp;&#39;open&#39;});&nbsp;&nbsp;&nbsp;&nbsp;this.shadowRoot.innerHTML&nbsp;=&nbsp;`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;template&nbsp;id=&quot;view1&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;is&nbsp;view&nbsp;1&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/template&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;template&nbsp;id=&quot;view1&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;is&nbsp;view&nbsp;1&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/template&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;container&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;is&nbsp;the&nbsp;container&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;`;&nbsp;&nbsp;}&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;content&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#view1&#39;).content.clondeNode(true);&nbsp;&nbsp;&nbsp;&nbsp;this.container&nbsp;=&nbsp;this.shadowRoot.querySelector(&#39;#container&#39;);&nbsp;&nbsp;&nbsp;&nbsp;this.container.appendChild(content);&nbsp;&nbsp;}} 在这里，两个模板都通过innerHTML置于元素的影子根中。起初，这两个模板都是不可见的，只看得到容器。connectedCallback方法中，我们通过this.shadowRoot.querySelector(&#39;#view1&#39;).content.clondeNode(true)获取#view1的内容。模板的content属性以DocumentFragment返回模板的内容，可以使用appendChild将其添加到另一个元素中。当某元素已存在于DOM中时，使用appendChild将会移动它，所以我们要先使用cloneNode(true)克隆它。否则，模板的内容将会被移动而不是附加，这就意味着我们只能使用一次了。 模板对于快速更改大多数HTML或可复用的标签非常有用。它们不仅限于web组件，而且可以在DOM中的任何地方使用。 本地元素的扩展 到目前为止，我们一直在扩展HTMLElement来创建一个全新的HTML元素。自定义元素还支持扩展原生内置元素，支持增强已经存在的HTML元素，例如图像和按钮。在撰写本文时，此功能仅有Chrome和Firefox浏览器支持。 扩展现有HTML元素的好处是其继承了元素的所有属性和方法。这允许对现有元素进行逐步增强，这意味着即使在不支持自定义元素的浏览器中加载元素，它仍然是可用的。它只会退回到默认的内置行为，而如果它是一个全新的HTML标记，那么它根本就不能使用。 例如，我们希望增强HTML中的&lt;button&gt;元素： class&nbsp;MyButton&nbsp;extends&nbsp;HTMLButtonElement&nbsp;{&nbsp;&nbsp;...&nbsp;&nbsp;constructor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;super();&nbsp;&nbsp;//&nbsp;always&nbsp;call&nbsp;super()&nbsp;to&nbsp;run&nbsp;the&nbsp;parent&#39;s&nbsp;constructor&nbsp;as&nbsp;well&nbsp;&nbsp;}&nbsp;&nbsp;connectedCallback()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;}&nbsp;&nbsp;someMethod()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;}}customElements.define(&#39;my-button&#39;,&nbsp;MyButton,&nbsp;{extends:&nbsp;&#39;button&#39;}); 我们的web组件不再扩展更通用的HTMLElement，而是扩展HTMLButtonElement。对customElements.define的调用还需要一个额外的参数{extends: &#39;button&#39;}，以此表示我们的类扩展了&lt;button&gt;元素。这看起来可能有些多余，因为我们已经表明了我们想要扩展HTMLButtonElement，但是这是必要的，因为有一些元素共享相同的DOM接口。例如，&lt;q&gt;和&lt;blockquote&gt;共用HTMLQuoteElement接口。 增强后的按钮可以与is属性一起使用: &lt;button&nbsp;is=&quot;my-button&quot;&gt; 现在它将被我们的MyElement类增强，如果它加载在一个不兼容自定义元素的浏览器中，它将简单地退回到一个标准按钮，真正意义上的渐进增强！ 注意，在扩展现有元素时，不能使用影子DOM。这只是一种扩展原生HTML元素的方法，它继承了所有现有的属性、方法和事件，并提供了额外的功能。当然，可以在组件中修改元素的DOM和CSS，但是试图创建一个影子根的话，它将会抛出一个错误。 扩展内置元素的另一个好处是，这些元素也可以用于应用元素子元素限制的地方。例如，&lt;thead&gt;&nbsp;元素只允许将&lt;tr&gt;&nbsp;元素作为其子元素，因此&lt;awesome-tr&gt;元素将呈现无效的标记。在这种情况下，我们可以扩展内置的&lt;tr&gt;&nbsp;元素，并像这样使用它: &lt;table&gt;&nbsp;&nbsp;&lt;thead&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&nbsp;is=&quot;awesome-tr&quot;&gt;&lt;/tr&gt;&nbsp;&nbsp;&lt;/thead&gt;&lt;/table&gt; 这种创建web组件的方式带来了巨大的渐进式增强，但正如前面提到的，目前这仅有Chrome和Firefox支持实现。Edge也将能兼容它，但不幸的是，在Safari中不能支持实现。 测试web组件 与为Angular和React之类的框架编写测试用例相比，测试web组件既简单又直接，而且坦率地说，这是一件轻而易举的事情。这无需换位或进行复杂的设置。只需创建元素，将其附加到DOM中并运行测试。 下面是一个使用Mocha测试的例子: import&nbsp;&#39;path/to/my-element.js&#39;;describe(&#39;my-element&#39;,&nbsp;()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;let&nbsp;element;&nbsp;&nbsp;beforeEach(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;element&nbsp;=&nbsp;document.createElement(&#39;my-element&#39;);&nbsp;&nbsp;&nbsp;&nbsp;document.body.appendChild(element);&nbsp;&nbsp;});&nbsp;&nbsp;afterEach(()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;document.body.removeChild(element);&nbsp;&nbsp;});&nbsp;&nbsp;it(&#39;should&nbsp;test&nbsp;my-element&#39;,&nbsp;()&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;run&nbsp;your&nbsp;test&nbsp;here&nbsp;&nbsp;});}); 在这里，第一行导入my-element.js文件，该文件将我们的web组件露出为一个ES6模块。这意味着测试文件本身也需要作为一个ES6模块加载到浏览器中。这需要以下index.html能够在浏览器中运行测试。除了Mocha，这个设置还加载WebcomponentsJS &nbsp;polyfill和Chai用于测试判断，以及Sinon用来检测和模拟: &lt;!doctype&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;charset=&quot;utf-8&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;link&nbsp;rel=&quot;stylesheet&quot;&nbsp;href=&quot;../node_modules/mocha/mocha.css&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/sinon/pkg/sinon.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/chai/chai.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=&quot;../node_modules/mocha/mocha.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.assert&nbsp;=&nbsp;chai.assert;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mocha.setup(&#39;bdd&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;module&quot;&nbsp;src=&quot;path/to/my-element.test.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;module&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mocha.run();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;mocha&quot;&gt;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt; 加载所需的脚本后，我们将露出chai.assert作为一个全局变量，因此我们可以在测试中简单地使用assert()，并设置Mocha来使用BDD接口。然后加载测试文件(在本例中只有一个)，并通过调用mocha.run()运行测试。 请注意，在使用ES6模块时，还需要将mocha.run()放在type=&quot;module&quot;的脚本中。这是因为ES6模块在默认情况下是延迟的，如果mocha.run()放在一个正则脚本标记中，它将在加载my-element.test.js之前执行。 Polyfill老式浏览器 目前，Chrome、Firefox、Safari和Opera的最新版本都支持自定义元素，即将推出的Edge 19也将支持自定义元素。在iOS和Android上，Safari、Chrome和Firefox都能兼容它们。 旧版本浏览器的WebcomponentsJS polyfill可通过以下途径安装: npm&nbsp;install&nbsp;--save&nbsp;@webcomponents/webcomponentsjs 我们可以引入webcomponents-loader.js文件，该文件将进行特性检测，只加载必要的填充内容。使用此方法，我们可以使用自定义元素，而不需要向源代码添加任何东西。但是，它没有提供真正的CSS作用域，这意味着如果在不同的web组件中包含有相同的类名和id，并将它们加载到相同的文档中，它们将发生冲突。此外，影子DOM的 CSS选择器:host()和:sloated()可能无法正常工作。 为了使其正常运行，我们需要使用Shady CSS polyfill，这也意味着必须(稍微)修改源代码才能使用它。我个人认为这是不可取的，所以我创建了一个webpack加载器，它可以处理这个问题。这表明必须进行转置，但是我们可以保持代码不变。 webpack加载器会做这三件事:它在web组件的影子DOM中为所有CSS规则加上前缀，这些CSS规则不是以元素名加::host或::slotted&nbsp;开头的，他们提供适当的范围。然后，它解析所有::host和::slot规则，以确保它们也能正确工作。 工作示例1:lazy-img 我创建了一个web组件，当图像在浏览器的视图中完全可见时，它就会惰性地加载图像。具体请参考Github。 组件的主体将本地&lt;img&gt;&nbsp;标签封装在&lt;lazy-img&gt;&nbsp;自定义元素中: &lt;lazy-img&nbsp;&nbsp;src=&quot;path/to/image.jpg&quot;&nbsp;&nbsp;width=&quot;480&quot;&nbsp;&nbsp;height=&quot;320&quot;&nbsp;&nbsp;delay=&quot;500&quot;&nbsp;&nbsp;margin=&quot;0px&quot;&gt;&lt;/lazy-img&gt; 下例还包含了extend-native分支，其中包含lazy-img，它使用is属性扩展原生&lt;img&gt;标签: &lt;img&nbsp;&nbsp;is=&quot;lazy-img&quot;&nbsp;&nbsp;src=&quot;path/to/img.jpg&quot;&nbsp;&nbsp;width=&quot;480&quot;&nbsp;&nbsp;height=&quot;320&quot;&nbsp;&nbsp;delay=&quot;500&quot;&nbsp;&nbsp;margin=&quot;0px&quot;&gt; 这是一个说明原生web组件强大功能的很好的例子:只需导入JavaScript文件、添加HTML标签或使用is属性扩展原生web组件，大功告成! 工作示例2:material-webcomponents 我使用自定义元素实现了谷歌的材质设计，具体也请参考Github。 这个库还展示了CSS自定义属性的强大功能，其中包含大量的自定义属性。 那么，应该抛弃框架吗? 当然，这要视情况而定。 目前的前端框架因具有数据绑定、状态管理和相当标准化的代码库等功能而带来了额外的价值。但问题是你的应用程序是否真的需要它。 如果还需要问自己，我的应用程序是否真的需要Redux之类的状态管理，那么你可能就是不需要它的。你渐渐就明白了。 使用数据绑定可能有好处，但是对于数组和对象等非基本值，原生web组件已经支持用户直接设置属性。我们可以在属性上设置基本值，并且可以通过attributeChangedCallback观察这些属性的更改。 虽然这种方法看起来非常合理，但是与React和Angular的声明式方法相比，它会使得更新DOM的某一部分变得非常麻烦和冗长。这些框架支持定义一个视图，它包含当表达式变更时更新的表达式。 原生web组件(还)不提供这样的功能，尽管有人建议扩展&lt;template&gt;元素，使其可以用数据实例化和更新： &lt;template&nbsp;id=&quot;example&quot;&gt;&nbsp;&nbsp;&lt;h1&gt;{{title}}&lt;/h1&gt;&nbsp;&nbsp;&lt;p&gt;{{text}}&lt;/p&gt;&lt;/template&gt;const&nbsp;template&nbsp;=&nbsp;document.querySelector(&#39;#example&#39;);const&nbsp;instance&nbsp;=&nbsp;template.createInstance({title:&nbsp;&#39;The&nbsp;title&#39;,&nbsp;text:&nbsp;&#39;Hello&nbsp;world&#39;});shadowRoot.appendChild(instance.content);//updateinstance.update({title:&nbsp;&#39;A&nbsp;new&nbsp;title&#39;,&nbsp;text:&nbsp;&#39;Hi&nbsp;there&#39;}); 当前可以支持有效DOM更新的库是lit -html。 另一个经常提到前端框架的好处是，它们提供了一个标准的代码基，团队中的每个新开发人员都将从一开始就熟悉这个代码基。虽然我相信这是真的，但我也认为这种好处是相当有限的。 我曾经用Angular、React和Polymer做过很多项目，虽然大家对它们都很熟悉，但是尽管使用了相同的框架，这些代码库还是有很大的不同。清晰定义的工作方式和样式指南比简单地使用框架更有助于代码库的一致性。框架也带来了额外的复杂性，所以问问自己这是否真的值得 现在web组件得到了广泛的支持，我们可能会得出这样的结论:原生代码可以提供与框架相同的功能，但是性能更好、代码更少、复杂度更低。 本地web组件的好处很明显: 原生，不需要框架； 易于集成，不需要移位； CSS有真正的作用域； 规范，只有HTML, CSS和JavaScript。 jQuery及其尤为出色的资源将会继续存在一段时间，但是没有太多人会使用它构建的新项目，因为现在有了更好的选择。我不认为目前的框架会很快消失，但是以原生web组件形式出现的更优选择正在出现，并且迅速获得关注。我确实期望这些前端框架的角色会发生巨大变化，届时它们将仅给本地web组件提供一个薄外层。 原文：https://www.dannymoerkerke.com/blog/web-components-will-replace-your-frontend-framework 本文为 CSDN 翻译，转载请注明来源出处。 【END】 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞互联网出海十年 ☞面试一线互联网大厂？那这道题目你必须得会！ ☞华为在剑桥建芯片厂；小米公布出货量反驳调研机构； 中移动否认限制号 | 极客头条 ☞天才程序员：25 岁进贝尔实验室，32 岁创建信息论 ☞&nbsp;扎心！工作 10 年，月薪过万者不足三成，程序员却笑了 ☞6张图告诉你, 区块链的未来在哪里 ☞我们应聘BAT等互联网公司，关于Spring到底需要掌握什么？ ☞如何确定最佳训练数据集规模？6 大必备“锦囊”全给你了 | 技术头条 ☞&nbsp;她说：为啥程序员都特想要机械键盘？这答案我服！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 点击阅读原文，输入关键词，即可搜索您想要的 CSDN 文章。 你点的每个“在看”，我都认真当成了喜欢","@type":"BlogPosting","url":"/2019/05/06/729687.html","headline":"Web 组件即将取代前端框架？！  技术头条","dateModified":"2019-05-06T00:00:00+08:00","datePublished":"2019-05-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/05/06/729687.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Web&nbsp;组件即将取代前端框架？！|&nbsp;技术头条</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);text-align: center;line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="__bg_gif " data-copyright="0" data-ratio="0.15644171779141106" data-type="gif" data-w="652" data-src="https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAug5zOzy32A3RIVhRwowK5ogg1hJ631uGyu9zOMKfTddDnSrsxicbCQNm59Qeo3lDYCvF70I9ibGvA9g/640?wx_fmt=gif" style="box-sizing: border-box !important;overflow-wrap: break-word !important;visibility: visible !important;width: 652px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAug5zOzy32A3RIVhRwowK5ogg1hJ631uGyu9zOMKfTddDnSrsxicbCQNm59Qeo3lDYCvF70I9ibGvA9g/640?wx_fmt=gif"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;">【CSDN 编者按】提起前端开发，不少开发者首先会对主流技术框架如 Vue、React、Angular 进行一番对比之后，选择相应的技术架构。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;">在此，随着前端框架的不断升级，其也变得越来越臃肿与复杂，那么，未来前端框架是否会被取而代之？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="rich_pages" data-copyright="0" data-ratio="0.7875" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAugMJsWIQHLmGeJjyjOj6aevylBRXMPiaiatPyxksOOZXQanUyvU8urgco2DsDukbsGOBj5jib640x0ibg/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" style="text-align: center;white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAugMJsWIQHLmGeJjyjOj6aevylBRXMPiaiatPyxksOOZXQanUyvU8urgco2DsDukbsGOBj5jib640x0ibg/640?wx_fmt=jpeg"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;text-align: right;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;">作者 |&nbsp;Danny Moerkerke</span><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;text-align: right;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;">译者 |&nbsp;谭开朗</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;text-align: right;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;">责编 | 屠敏<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;text-align: right;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;">出品 | CSDN（ID：CSDNnews）</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong>以下为译文：</strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">还记得吗？当时document.querySelector首次被浏览器广泛采用，就此终结了jQuery的通用时代。对于多年来一直沿用jQuery来实现的功能，document.querySelector提供了原生方法：轻松的选取DOM元素。我相信，类似的情况也将会发生在诸如Angular和React的前端框架上。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">前端框架为我们一直想做却未能做到的事情提供了可能：创建可复用的自动化前端组件，但它复杂性较高，还有专属语法和较高的有效负载。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">前端框架正渐渐被取代。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">现代Web API发展至今，我们已无需依赖框架来创建可复用的前端组件。我们所需创建的自定义组件就是自定义元素和影子DOM，这可以在任意地方复用。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">2011年开始推出的Web组件，它支持仅通过HTML、CSS和JavaScript就能创建出可复用组件。这意味着，我们无需使用诸如React或Angular的框架就能构建出组件。更锦上添花的是，这些组件可以无缝集成到框架中。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">有史以来第一次，我们仅通过HTML，CSS和JavaScript就成功构建了可兼容任意浏览器的可复用组件。Web组件现在可以兼容桌面最新的Chrome、Safari、Firefox和Opera浏览器，还有iOS的Safari浏览器和Android的Chrome浏览器。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">Edge浏览器即将发布的第19版中也将得到兼容。对于较老的浏览器，它将会通过polyfill将其引入到IE 11浏览器中。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">这意味着，目前基本任一浏览器都可以使用Web组件，包括移动端浏览器。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">只需简单的引入一个脚本，我们就可以创建自定义HTML标签，它不仅继承了HTML元素扩展出的所有属性，还能在其支持的任意浏览器中使用。组件中定义的所有HTML，CSS和JavaScript都完全限定在组件的作用域内。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">组件在浏览器的开发工具中显示为单个HTML标签，样式和逻辑是完全封装好的，无需方法转换，框架或换位。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">一起来学习Web组件的主要特性吧。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LXSAriayI15u06ibNNlXzIcor2tTtgJBKFxkIicJ8tiaRKRaictbrQEssdSg/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LXSAriayI15u06ibNNlXzIcor2tTtgJBKFxkIicJ8tiaRKRaictbrQEssdSg/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">自定义元素</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">自定义元素单纯是用户定义的HTML元素。其可通过CustomElementRegistry来定义。要定义新元素，先通过window.customElements来获取注册实例，再调用它的define方法：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs coffeescript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">window</span>.customElements.define(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'my-element'</span>,&nbsp;MyElement);</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">上述define方法中的第一个参数是新建元素的标签名。可这样来实现简单的添加：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs apache" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-section" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">&lt;my-element&gt;&lt;/my-element&gt;</span>&nbsp;<br></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">名称中的破折号（-）是必不可少的，它可以避免与原生HTML元素发生重名。</span><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">MyElement构造函数必须是一个ES6类，因为Javascript类（暂时还）不像传统的OOP类，而且容易混淆。此外，如果它支持使用object，那么也可以使用Proxy为自定义元素启用简单的数据绑定。但是需要对此作出限制，以便启用原生HTML的拓展属性并确保元素继承了整个DOM API。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">为自定义元素编写类:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs javascript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">MyElement</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">extends</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">HTMLElement</span>&nbsp;</span>{<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">super</span>();<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;connectedCallback()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;here&nbsp;the&nbsp;element&nbsp;has&nbsp;been&nbsp;inserted&nbsp;into&nbsp;the&nbsp;DOM</span><br>&nbsp;&nbsp;}<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">自定义元素的类只是一个扩展了原生HTMLElement的常规JavaScript类。除了它的构造函数之外，还有一个名为connectedCallback的方法，当有元素插入到DOM中时，这个方法就会被调用。我们可以将其与React的componentDidMount方法进行比较。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">通常情况下，组件的设置尽量放在connectedCallback中，因为connectedCallback是唯一能拿到稳定属性且子元素可用的地方。构造函数通常只用于初始化状态和设置影子DOM。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">元素的constructor函数和connectedCallback函数之间的区别是，创建元素时调用构造函数（例如调用document.createElement），而connectedCallback函数是在元素已插入DOM后调用，比如声明文件被解析或已通过document.body.appendChild添加。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">也可通过引用构造函数customElements.get('my-element')来创建元素，前提是它已经注册了customelelements.define()。然后用new element()方法实例化元素，而非document.createElement()方法：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs dart" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">customElements.define(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'my-element'</span>,&nbsp;<span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">extends</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">HTMLElement</span>&nbsp;</span>{...});<br><br>...<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;el&nbsp;=&nbsp;customElements.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">get</span>(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'my-element'</span>);<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;myElement&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">new</span>&nbsp;el();&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;same&nbsp;as&nbsp;document.createElement('my-element');</span><br><span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">document</span>.body.appendChild(myElement);</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">connectedCallback的对应函数是disconnectedCallback，当元素从DOM中删除时会调用它。此方法支持执行任何必要的清除工作，但请记住，用户关闭浏览器或关闭浏览器选项卡并不会调用此方法。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">还有adoptedCallback函数，它是在通过调用document. adoptnode(element)来将元素引入到文档中时被调用。到目前为止，我还从未遇到过使用该回调的情况。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">另一个有用的生命周期函数是attributeChangedCallback函数。它在observedAttributes数组的属性发生变更时被调用。调用时需传入属性名、旧值和新值：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs java" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">MyElement</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">extends</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">HTMLElement</span>&nbsp;</span>{<br>&nbsp;&nbsp;<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">static</span>&nbsp;get&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">observedAttributes</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;[<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'foo'</span>,&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'bar'</span>];<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">switch</span>(attr)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">case</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'foo'</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;do&nbsp;something&nbsp;with&nbsp;'foo'&nbsp;attribute</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">case</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'bar'</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;do&nbsp;something&nbsp;with&nbsp;'bar'&nbsp;attribute</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">这个回调只会在observedAttributes数组包含的属性中发生调用，在本例中是foo和bar。如果是其他任意的属性变化，此回调不会发生调用。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">属性主要用于声明元素的初始配置/状态。理论上，可以通过序列化将复杂的值传递给属性，但这可能会影响性能，因为我们可以通过访问组件的方法来替代。但是，如果确实希望通过像React和Angular这样的框架提供的属性来绑定，那么可以试试Polymer。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LwYnW1VvkaHWiaL6W1Mr1yiaNLQpxwhyqice9F1yJzMHticssPX515qyvog/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LwYnW1VvkaHWiaL6W1Mr1yiaNLQpxwhyqice9F1yJzMHticssPX515qyvog/640?wx_fmt=png"></span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">生命周期方法的执行顺序</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">生命周期方法的执行顺序是：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs delphi" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">constructor</span>&nbsp;-&gt;&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">attributeChangedCallback</span>&nbsp;-&gt;&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">connectedCallback</span><br></span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">为什么attributeChangedCallback方法会在connectedCallback方法之前执行？</span><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">回想一下，web组件属性的主要用途是初始化配置。这意味着，当组件引入到DOM中时此配置必须是可用的，因此需要在connectedCallback方法之前调用attributeChangedCallback方法。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">这也意味着，如果需要基于某特定属性在影子DOM中配置节点，我们需要在constructor函数中引入该节点，而非在connectedCallback中。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">例如，组件中有一个id=”container”的元素，我们需要在其可见属性禁用的情况下给它添加一个灰色背景，我们可以在constructor函数中引入这个元素，以便在attributeChangedCallback函数中可以调用:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs kotlin" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.container&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.shadowRoot.querySelector(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'#container'</span>);<br>}<br><br>attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">if</span>(attr&nbsp;===&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'disabled'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">if</span>(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.hasAttribute(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'disabled'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.container.style.background&nbsp;=&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'#808080'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.container.style.background&nbsp;=&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'#ffffff'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">如果等到connectedCallback方法中才创建this.container，那么在首次调用attributeChangedCallback方法时，它还是不可用的。因此，尽管我们尽可能的将组件的设置放在connectedCallback中，但在这种情况下也是不可行的。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">同样重要的是，在通过customelelements.define()注册之前，我们就可以使用该web组件。当该元素出现在DOM中或插入到DOM中，且尚未注册时，它将是HTMLUnknownElement的一个实例。浏览器将会处理这类它不认识的HTML元素，我们可以和其他元素一样为它设置交互逻辑，但除此之外，它没有任何方法或默认的样式。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">当通过customelelements .define()注册它时，可通过定义类来增强它。这个过程称为升级。当使用customElements.whenDefined升级元素时，可以调用回调，它会返回元素升级后的Promise方法：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs coffeescript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">customElements.whenDefined(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'my-element'</span>)<br>.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">then</span>(<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-regexp" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">//</span>&nbsp;my-element&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">is</span>&nbsp;now&nbsp;defined<br>})</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lb4ybNEVGnaAvEDwENKzW27LUKFDGZPKcBneWwTaTpaJyG2C3em7libQ/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lb4ybNEVGnaAvEDwENKzW27LUKFDGZPKcBneWwTaTpaJyG2C3em7libQ/640?wx_fmt=png"></span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">Web组件的公共API</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">除了上述生命周期方法，我们可以给元素定义外部访问的方法，这是使用React或Angular等框架定义元素所实现不了的。例如，我们定义一个名为doSomething的方法：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs coffeescript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">MyElement</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">extends</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">HTMLElement</span>&nbsp;{</span><br>&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;doSomething()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-regexp" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">//</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">do</span>&nbsp;something&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">in</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>&nbsp;method<br>&nbsp;&nbsp;}<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">并从组件外部来调用它：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs dart" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;element&nbsp;=&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">document</span>.<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">querySelector</span>(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'my-element'</span>);<br>element.doSomething();</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">在元素上定义的方法都将是其公共JavaScript API的一部分。通过这种方式，我们可以通过为元素的属性提供setter来实现数据绑定，例如，设置setter将在元素的HTML中呈现属性值。由于在本质上不可能向属性提供字符串以外的任何其他值，所以应该将像对象这样的复杂值作为属性传递给自定义元素。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">除了声明web组件的初始状态外，属性还用于反映相应属性的值，以便将元素的JavaScript状态反映到它的DOM表示。input元素中的disabled属性就是其中一个例子:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs lua" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">&lt;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">input</span>&nbsp;name=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"name"</span>&gt;<br><br>const&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">input</span>&nbsp;=&nbsp;document.querySelector(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'input'</span>);<br><span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">input</span>.disabled&nbsp;=&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">true</span>;</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">将input的属性disabled设置为true后，此更改将映射到相应的disabled 属性中:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs xml" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">input</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">name</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"name"</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">disabled</span>&gt;</span><br></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">通过setter可以很容易地实现属性到属性的反射:</span><br></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs kotlin" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">MyElement</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">extends</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">HTMLElement</span>&nbsp;</span>{<br>&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">set</span>&nbsp;disabled(isDisabled)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">if</span>(isDisabled)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.setAttribute(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'disabled'</span>,&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">''</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.removeAttribute(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'disabled'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">get</span>&nbsp;disabled()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.hasAttribute(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'disabled'</span>);<br>&nbsp;&nbsp;}<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">当属性发生改变而需要执行某些操作时，可将其添加到observedAttributes数组中。作为一种性能优化，只能监听该数组列出的属性。当属性的值发生变化时，attributeChangedCallback将通过传入属性名及其当前值和新值来调用：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs kotlin" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">MyElement</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">extends</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">HTMLElement</span>&nbsp;</span>{&nbsp;&nbsp;<br>&nbsp;&nbsp;static&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">get</span>&nbsp;observedAttributes()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;[<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'disabled'</span>];&nbsp;&nbsp;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">constructor</span>()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;shadowRoot&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.attachShadow({mode:&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'open'</span>});<br>&nbsp;&nbsp;&nbsp;&nbsp;shadowRoot.innerHTML&nbsp;=&nbsp;`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.disabled&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opacity:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">0.4</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"container"</span>&gt;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;`;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.container&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.shadowRoot(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'#container'</span>);&nbsp;&nbsp;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;attributeChangedCallback(attr,&nbsp;oldVal,&nbsp;newVal)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">if</span>(attr&nbsp;===&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'disabled'</span>)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">if</span>(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.disabled)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.container.classList.add(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'disabled'</span>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">else</span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.container.classList.remove(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'disabled'</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">现在，disabled属性一旦发生改变，this.container中的“disabled”类就会发生来回切换，它是这个元素影子DOM的div元素。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">下面详细探讨一下影子DOM。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LLqyf6BY4rMfY2LsU81MibFjicKDLjMjib5R23h8uo6GtGDY8OufWJfpEw/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LLqyf6BY4rMfY2LsU81MibFjicKDLjMjib5R23h8uo6GtGDY8OufWJfpEw/640?wx_fmt=png"></span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">影子DOM</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">影子DOM可以将自定义元素的HTML和CSS完全封装在组件中。这意味着，元素以单个HTML标签的形式呈现在文件的DOM结构树中，其内部HTML结构放在#shadow-root中。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">实际上，一些本地HTML元素也使用了影子DOM。例如，网页的&lt;video&gt;元素，它显示为一个单独的标签，但它也是显示播放和暂停视频的控件，但在浏览器的开发工具中是找不到&lt;video&gt;元素的。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">实际上，控件&lt;video&gt;元素是影子DOM的一部分，因此在默认情况下它们时不可见的。要在Chrome中显示出影子DOM，可进入开发工具设置中的“首选项”，选中“显示用户代理影子DOM”复选框。此时在开发工具中查找&lt;video&gt;元素，我们可以找到并检查该元素的影子DOM。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">影子DOM还可看出CSS的真正作用域。所有在组件内部定义的CSS只作用于组件本身。元素将从组件外部定义的CSS中继承最小数量的属性，甚至可以将这些属性配置为不从外层的CSS中继承任何值。不过，我们可以露出CSS属性，以便用户对组件进行样式设置。这解决了当前许多CSS问题，同时仍然支持给组件自定义样式。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">定义一个影子根：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs javascript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;shadowRoot&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.attachShadow({<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">mode</span>:&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'open'</span>});<br>shadowRoot.innerHTML&nbsp;=&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">`&lt;p&gt;Hello&nbsp;world&lt;/p&gt;`</span>;</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">这里用mode:’open’定义了一个影子根，这意味着，可以在开发工具检出它并做交互，也可以发请求、配置共用CSS属性或监听事件。也可以用mode:’close’来定义影子根，但不建议这样定义，因为它不支持任何方式的交互，甚至不能监听其抛出的事件。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">要将HTM添加到影子根中，我们可以给innerHTML属性分配HTML字符串，或者使用&lt;template&gt;元素。HTML模板基本上算是一个惰性的HTML片段，我们可先定义以供后续使用。在实际插入DOM结构树之前，它是不可见或不被解析的，这意味着在它内部定义的任何外部资源都不会被获取，任何CSS和JavaScript也都不会被解析。当组件的HTML随着状态发生改变时，我们可以定义多个&lt;template&gt;元素以便根据不同状态来做引入。如此一来，我们可以轻松的对组件HTML进行更改，而无需修改单个DOM节点。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">一旦创建了影子根，我们可以像通常作用于document对象的方法一样，对其应用所有的DOM方法，例如，通过this.shadowRoot.querySelector方法来查找元素。组件的CSS都定义在&lt;style&gt;标签中，但如果希望使用常规的&lt;link rel=”stylesheet”&gt;标签，也可以获取到外部样式表。除了常规CSS之外，还可以使用:host选择器对组件本身进行样式设置。例如，自定义元素默认使用display: inline而将组件显示为块元素，可以写为:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs css" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-selector-pseudo" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">:host</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">display</span>:&nbsp;block;<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">它也支持为上下文设置样式。例如，如果希望在组件定义了disabled属性后显示为灰色，写为：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs css" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-selector-pseudo" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">:host([disabled]</span>)&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">opacity</span>:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">0.5</span>;<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">默认情况下，自定义元素会继承一些外层CSS样式，比如颜色和字体等。但如果希望清空样式，将组件中所有的CSS样式重置为默认状态，可以写为：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs css" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-selector-pseudo" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">:host</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">all</span>:&nbsp;initial;<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">值得注意的是，外部定义于组件本身上的样式优先于使用:host在影子DOM中定义的样式。因此，如果定义：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs css" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-selector-tag" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">my-element</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">display</span>:&nbsp;inline-block;<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">它将覆盖：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs css" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-selector-pseudo" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">:host</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">display</span>:&nbsp;block;<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">我们不能从外部对自定义元素内的任何节点设置样式。如果想要支持用户对组件样式（某部分）进行设置，我们可以通过露出CSS变量来实现。例如，为便于用户选择组件的背景颜色，我们可以露出background-color这一CSS变量。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">假设组件中影子DOM的根节点是&lt;div id="container"&gt;：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs css" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-selector-id" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">#container</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">background-color</span>:&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">var</span>(--background-color);<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">现在用户从外部设置组件的背景颜色:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs css" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-selector-tag" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">my-element</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">--background-color</span>:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">#ff0000</span>;<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">我们要在组件内部为它设置一个默认值以防用户不对其设置：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs css" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-selector-pseudo" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">:host</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">--background-color</span>:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">#ffffff</span>;<br>}<br><br><span class="hljs-selector-id" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">#container</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">background-color</span>:&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">var</span>(--background-color);<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">当然，CSS变量的名称可以是任意的。它的唯一限制是要以“--”开头。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">通过限定CSS和HTML的作用域，影子DOM解决了CSS全局特性带来的问题，即通常是只添加样式表而其中包含越来越多的特定选择器和覆盖问题。影子DOM支持在自包含组件中捆绑标记和样式，而无需任何工具或命名约定。因此，我们不必担心新的类或id会与现有类发生冲突。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">我们可以通过CSS变量来给web组件设置内部样式，除此之外，还可以将HTML注入到web组件中。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LzUzfol6q1COlZYpeYXqe0aia45DXyhcTQW8voWvibFJvEjfmkhPvCrEg/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LzUzfol6q1COlZYpeYXqe0aia45DXyhcTQW8voWvibFJvEjfmkhPvCrEg/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">组成元素slot</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">组成是将影子DOM结构树和用户标记组合在一起的过程。它可以通过&lt;slot&gt;元素实现，&lt;slot&gt;元素是在影子DOM中用来呈现用户所做标记的基本占位符。用户所做的标记被称为自然DOM。组合将自然DOM和影子DOM合成为新的DOM结构树。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">例如，我们可以创建一个&lt;image-gallery&gt;组件，并提供标准的&lt;image&gt;标签用以渲染呈现：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs xml" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">image-gallery</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">img</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"foo.jpg"</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">slot</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"image"</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">img</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"bar.jpg"</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">slot</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"image"</span>&gt;</span><br><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">image-gallery</span>&gt;</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">组件将会获取这两个图像，并通过slot在组件的影子DOM中渲染出来。注意图像上的slot="image"属性。该属性告诉组件应该在影子DOM中的哪个位置呈现，比如可以是这样的：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs xml" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">id</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"container"</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">class</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"images"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">name</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"image"</span>&gt;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&gt;</span><br><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&gt;</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">当自然DOM中的节点被分布到元素的影子DOM中时，得到的DOM树看起来是这样的：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs xml" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">id</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"container"</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">class</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"images"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">name</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"image"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">img</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"foo.jpg"</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">slot</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"image"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">img</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"bar.jpg"</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">slot</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"image"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&gt;</span><br><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&gt;</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">正如我们看到的，用户提供的元素都具有slot属性，它们都将在slot元素中呈现，而slot元素具有name属性，其值与slot属性值一致。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">&lt;select&gt;元素的运行方式与在Chrome开发工具中查看它时所看到的完全一致（用户代理拿到用户选择的影子DOM时，如图）：</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><img class="rich_pages" data-copyright="0" data-ratio="0.5" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhAQBuzjXdONwGTsm497v7cop42RD99DDyibHh6TYHsEGJPia1MNHgJd5GCFJEG7L6Ug13lTYibXgZfw/640?wx_fmt=png" data-type="png" data-w="812" style="text-align: center;white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhAQBuzjXdONwGTsm497v7cop42RD99DDyibHh6TYHsEGJPia1MNHgJd5GCFJEG7L6Ug13lTYibXgZfw/640?wx_fmt=png"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">它获取用户提供的&lt;option&gt;元素并将它们呈现到下拉菜单中。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">带有name属性的slot元素被称为命名slot，但此属性不是必须的。它仅用于在特定位置呈现内容。当一个或多个slot没有name属性时，其中内容的渲染顺序将遵循用户提供的顺序。当用户提供的内容少于slot时，slot甚至可以提供回退内容。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">假设&lt;image-gallery&gt;的影子DOM是这样的:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs xml" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">id</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"container"</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">class</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"images"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">strong</span>&gt;</span>No&nbsp;image&nbsp;here!<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">strong</span>&gt;</span>&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">--</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">fallback</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">content</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">--</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&gt;</span><br><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&gt;</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">同样提供两个图像，得到的影子DOM树将是：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs xml" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">id</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"container"</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">class</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"images"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">img</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"foo.jpg"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">img</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"bar.jpg"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">strong</span>&gt;</span>No&nbsp;image&nbsp;here!<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">strong</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">slot</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&gt;</span><br><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&gt;</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">通过slot在影子DOM中呈现的元素称为分布式节点。这些节点在组件的影子DOM (分布式)中呈现之前，应用于它们的所有样式也将在分布之后得到应用。在影子DOM中，分布式节点可以通过::sloated()选择器获得额外的样式：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs css" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-selector-pseudo" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">::slotted(img)</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-attribute" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">float</span>:&nbsp;left;<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">:: sloated()可以接受任何有效的CSS选择器，但是它只能选择最高级的节点。例如::sloated (section img)将无法处理以下内容:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs xml" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">image-gallery</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">section</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">slot</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"image"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">img</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"foo.jpg"</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">section</span>&gt;</span><br><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">image-gallery</span>&gt;</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L8DRknQu3FB9eZicibvOSlVrgnllB3XcGnsrw4zCk19ic0QjZkTPoqFMWw/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L8DRknQu3FB9eZicibvOSlVrgnllB3XcGnsrw4zCk19ic0QjZkTPoqFMWw/640?wx_fmt=png"></span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">JavaScript作用于slot</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">我们可以通过JavaScript与slot进行交互，通过查看节点分配到哪个slot，该slot对应哪个元素以及slotchange事件。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">调用slot.assignedNodes()方法可以找出该slot对应的元素。如果还需要检索回调内容，可以调用slot.assignedNodes({flatten: true})。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">查找slot中是否包含某个特定元素可以使用element.assignedSlot。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">当slot节点发生变更时，即添加或删除节点将会触发slotchange事件。这里要注意，该事件会触发仅针对slot节点本身，而非slot节点的子节点。</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs javascript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">slot.addEventListener(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'slotchange'</span>,&nbsp;e&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;changedSlot&nbsp;=&nbsp;e.target;<br>&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">console</span>.log(changedSlot.assignedNodes());<br>});</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">当元素是首次初始化时，Chrome会触发slotchange事件，而Safari和Firefox则不会。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LFV97HltQYlNPKDzX97K1Ll0EicLrBIuWQtgLtQYdFKkkLcWKGUeMTfg/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LFV97HltQYlNPKDzX97K1Ll0EicLrBIuWQtgLtQYdFKkkLcWKGUeMTfg/640?wx_fmt=png"></span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">影子DOM事件</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">默认情况下，自定义元素中诸如鼠标事件和键盘事件等标准事件会从影子DOM中弹出。影子DOM节点触发的事件会被重定向，所以该事件看起来像是源自自定义元素本身。如果想找出是影子DOM中由哪个元素触发了此事件，我们可以调用event.composedPath()来检索事件经过的节点数组。事件的target属性始终指向自定义元素本身。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">我们可以使用CustomEvent从自定义元素中抛出任意事件。</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs dart" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">MyElement</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">extends</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">HTMLElement</span>&nbsp;</span>{<br>&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;connectedCallback()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.dispatchEvent(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">new</span>&nbsp;CustomEvent(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'custom'</span>,&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detail:&nbsp;{message:&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'a&nbsp;custom&nbsp;event'</span>}<br>&nbsp;&nbsp;&nbsp;&nbsp;}));<br>&nbsp;&nbsp;}<br>}<br><br><span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;on&nbsp;the&nbsp;outside</span><br><span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">document</span>.<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">querySelector</span>(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'my-element'</span>).addEventListener(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'custom'</span>,&nbsp;e&nbsp;=&gt;&nbsp;console.log(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'message&nbsp;from&nbsp;event:'</span>,&nbsp;e.detail.message));</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">但是，当事件是从影子DOM中的节点抛出而不是其自定义元素本身时，它不会从影子DOM中弹出，除非它是用composition: true创建的：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs coffeescript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">MyElement</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">extends</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">HTMLElement</span>&nbsp;{</span><br>&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;connectedCallback()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.container&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.shadowRoot.querySelector(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'#container'</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-regexp" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">//</span>&nbsp;dispatchEvent&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">is</span>&nbsp;now&nbsp;called&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">on</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.container&nbsp;instead&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">of</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.container.dispatchEvent(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">new</span>&nbsp;CustomEvent(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'custom'</span>,&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detail:&nbsp;{message:&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'a&nbsp;custom&nbsp;event'</span>},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;composed:&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">true</span>&nbsp;&nbsp;<span class="hljs-regexp" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">//</span>&nbsp;without&nbsp;composed:&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">true</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>&nbsp;event&nbsp;will&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">not</span>&nbsp;bubble&nbsp;out&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">of</span>&nbsp;Shadow&nbsp;DOM<br>&nbsp;&nbsp;&nbsp;&nbsp;}));<br>&nbsp;&nbsp;}<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lf6AGBpotDb1DGltQgly1vKzgCCOtT3OQn43luu8r1JxUV1PmiaSAViaw/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lf6AGBpotDb1DGltQgly1vKzgCCOtT3OQn43luu8r1JxUV1PmiaSAViaw/640?wx_fmt=png"></span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">模块元素</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">除了可以使用this.shadowRoot.innerHTML将HTML添加到影子根中，我们也可以用&lt;template&gt;元素。模板可保存HTML以供后续使用。它并未渲染出来，而最初的解析是为了确保其内容的有效性。模板中的JavaScript不执行，也不会获取任何外部资源。默认情况下它是隐性的。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">当一个web组件需要根据不同的情况呈现完全不同的标记时，可以使用不同的模板来完成:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs kotlin" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">MyElement</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">extends</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">HTMLElement</span>&nbsp;</span>{<br>&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;shadowRoot&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.attachShadow({mode:&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'open'</span>});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.shadowRoot.innerHTML&nbsp;=&nbsp;`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;template&nbsp;id=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"view1"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">is</span>&nbsp;view&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">1</span>&lt;/p&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/template&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;template&nbsp;id=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"view1"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">is</span>&nbsp;view&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">1</span>&lt;/p&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/template&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"container"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;This&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">is</span>&nbsp;the&nbsp;container&lt;/p&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;`;<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;connectedCallback()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;content&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.shadowRoot.querySelector(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'#view1'</span>).content.clondeNode(<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);word-wrap: inherit !important;word-break: inherit !important;">true</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.container&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.shadowRoot.querySelector(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'#container'</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">this</span>.container.appendChild(content);<br>&nbsp;&nbsp;}<br>}</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">在这里，两个模板都通过innerHTML置于元素的影子根中。起初，这两个模板都是不可见的，只看得到容器。connectedCallback方法中，我们通过this.shadowRoot.querySelector('#view1').content.clondeNode(true)获取#view1的内容。模板的content属性以DocumentFragment返回模板的内容，可以使用appendChild将其添加到另一个元素中。当某元素已存在于DOM中时，使用appendChild将会移动它，所以我们要先使用cloneNode(true)克隆它。否则，模板的内容将会被移动而不是附加，这就意味着我们只能使用一次了。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">模板对于快速更改大多数HTML或可复用的标签非常有用。它们不仅限于web组件，而且可以在DOM中的任何地方使用。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L7H0ibIdQobyzuicxzGicfibXUugu11UNG7jA3g0M1ibp02QOr8UTuTDiaDwA/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L7H0ibIdQobyzuicxzGicfibXUugu11UNG7jA3g0M1ibp02QOr8UTuTDiaDwA/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">本地元素的扩展</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">到目前为止，我们一直在扩展HTMLElement来创建一个全新的HTML元素。自定义元素还支持扩展原生内置元素，支持增强已经存在的HTML元素，例如图像和按钮。在撰写本文时，此功能仅有Chrome和Firefox浏览器支持。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">扩展现有HTML元素的好处是其继承了元素的所有属性和方法。这允许对现有元素进行逐步增强，这意味着即使在不支持自定义元素的浏览器中加载元素，它仍然是可用的。它只会退回到默认的内置行为，而如果它是一个全新的HTML标记，那么它根本就不能使用。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">例如，我们希望增强HTML中的&lt;button&gt;元素：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs dart" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">MyButton</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">extends</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">HTMLButtonElement</span>&nbsp;</span>{<br>&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;constructor()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">super</span>();&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//&nbsp;always&nbsp;call&nbsp;super()&nbsp;to&nbsp;run&nbsp;the&nbsp;parent's&nbsp;constructor&nbsp;as&nbsp;well</span><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;connectedCallback()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;someMethod()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;}<br>}<br><br>customElements.define(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'my-button'</span>,&nbsp;MyButton,&nbsp;{<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">extends</span>:&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'button'</span>});</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">我们的web组件不再扩展更通用的HTMLElement，而是扩展HTMLButtonElement。对customElements.define的调用还需要一个额外的参数{extends: 'button'}，以此表示我们的类扩展了&lt;button&gt;元素。这看起来可能有些多余，因为我们已经表明了我们想要扩展HTMLButtonElement，但是这是必要的，因为有一些元素共享相同的DOM接口。例如，&lt;q&gt;和&lt;blockquote&gt;共用HTMLQuoteElement接口。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">增强后的按钮可以与is属性一起使用:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs coffeescript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">&lt;button&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">is</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"my-button"</span>&gt;<br></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">现在它将被我们的MyElement类增强，如果它加载在一个不兼容自定义元素的浏览器中，它将简单地退回到一个标准按钮，真正意义上的渐进增强！</span><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">注意，在扩展现有元素时，不能使用影子DOM。这只是一种扩展原生HTML元素的方法，它继承了所有现有的属性、方法和事件，并提供了额外的功能。当然，可以在组件中修改元素的DOM和CSS，但是试图创建一个影子根的话，它将会抛出一个错误。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">扩展内置元素的另一个好处是，这些元素也可以用于应用元素子元素限制的地方。例如，&lt;thead&gt;&nbsp;元素只允许将&lt;tr&gt;&nbsp;元素作为其子元素，因此&lt;awesome-tr&gt;元素将呈现无效的标记。在这种情况下，我们可以扩展内置的&lt;tr&gt;&nbsp;元素，并像这样使用它:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs xml" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">table</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">thead</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">tr</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">is</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"awesome-tr"</span>&gt;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">tr</span>&gt;</span><br>&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">thead</span>&gt;</span><br><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">table</span>&gt;</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">这种创建web组件的方式带来了巨大的渐进式增强，但正如前面提到的，目前这仅有Chrome和Firefox支持实现。Edge也将能兼容它，但不幸的是，在Safari中不能支持实现。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LdGlIRH3ub4BRGNibIPlF0AfOJV8WbVoznnD26JxrWdZEXJDpfUxaWqw/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LdGlIRH3ub4BRGNibIPlF0AfOJV8WbVoznnD26JxrWdZEXJDpfUxaWqw/640?wx_fmt=png"></span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">测试web组件</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">与为Angular和React之类的框架编写测试用例相比，测试web组件既简单又直接，而且坦率地说，这是一件轻而易举的事情。这无需换位或进行复杂的设置。只需创建元素，将其附加到DOM中并运行测试。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">下面是一个使用Mocha测试的例子:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs coffeescript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'path/to/my-element.js'</span>;<br><br>describe(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'my-element'</span>,&nbsp;<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;let&nbsp;element;<br><br>&nbsp;&nbsp;beforeEach(<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;element&nbsp;=&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">document</span>.createElement(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'my-element'</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">document</span>.body.appendChild(element);<br>&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;afterEach(<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">document</span>.body.removeChild(element);<br>&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;it(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'should&nbsp;test&nbsp;my-element'</span>,&nbsp;<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);word-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-regexp" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">//</span>&nbsp;run&nbsp;your&nbsp;test&nbsp;here<br>&nbsp;&nbsp;});<br>});</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">在这里，第一行导入my-element.js文件，该文件将我们的web组件露出为一个ES6模块。这意味着测试文件本身也需要作为一个ES6模块加载到浏览器中。这需要以下index.html能够在浏览器中运行测试。除了Mocha，这个设置还加载WebcomponentsJS &nbsp;polyfill和Chai用于测试判断，以及Sinon用来检测和模拟:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs xml" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-meta" style="font-size: inherit;line-height: inherit;color: rgb(91, 218, 237);word-wrap: inherit !important;word-break: inherit !important;">&lt;!doctype&nbsp;html&gt;</span><br><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">html</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">head</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">meta</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">charset</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"utf-8"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">link</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">rel</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"stylesheet"</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">href</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"../node_modules/mocha/mocha.css"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"</span>&gt;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"../node_modules/sinon/pkg/sinon.js"</span>&gt;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"../node_modules/chai/chai.js"</span>&gt;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"../node_modules/mocha/mocha.js"</span>&gt;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&gt;</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">window</span>.assert&nbsp;=&nbsp;chai.assert;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mocha.setup(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'bdd'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">type</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"module"</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"path/to/my-element.test.js"</span>&gt;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">type</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"module"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mocha.run();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">script</span>&gt;</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">head</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">body</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">id</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"mocha"</span>&gt;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">div</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">body</span>&gt;</span><br><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">html</span>&gt;</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">加载所需的脚本后，我们将露出chai.assert作为一个全局变量，因此我们可以在测试中简单地使用assert()，并设置Mocha来使用BDD接口。然后加载测试文件(在本例中只有一个)，并通过调用mocha.run()运行测试。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">请注意，在使用ES6模块时，还需要将mocha.run()放在type="module"的脚本中。这是因为ES6模块在默认情况下是延迟的，如果mocha.run()放在一个正则脚本标记中，它将在加载my-element.test.js之前执行。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhzGbHK1kg8LtrlfLZaLaRRqtuKZHv3FrpfkX3ck2hJnYQq5wV1VlHmAwFlWGNpQFLYZIQQSItic6Q/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhzGbHK1kg8LtrlfLZaLaRRqtuKZHv3FrpfkX3ck2hJnYQq5wV1VlHmAwFlWGNpQFLYZIQQSItic6Q/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">Polyfill老式浏览器</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">目前，Chrome、Firefox、Safari和Opera的最新版本都支持自定义元素，即将推出的Edge 19也将支持自定义元素。在iOS和Android上，Safari、Chrome和Firefox都能兼容它们。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">旧版本浏览器的WebcomponentsJS polyfill可通过以下途径安装:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs coffeescript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">npm</span>&nbsp;install&nbsp;--save&nbsp;@webcomponents/webcomponentsjs<br></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">我们可以引入webcomponents-loader.js文件，该文件将进行特性检测，只加载必要的填充内容。使用此方法，我们可以使用自定义元素，而不需要向源代码添加任何东西。但是，它没有提供真正的CSS作用域，这意味着如果在不同的web组件中包含有相同的类名和id，并将它们加载到相同的文档中，它们将发生冲突。此外，影子DOM的 CSS选择器:host()和:sloated()可能无法正常工作。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">为了使其正常运行，我们需要使用Shady CSS polyfill，这也意味着必须(稍微)修改源代码才能使用它。我个人认为这是不可取的，所以我创建了一个webpack加载器，它可以处理这个问题。这表明必须进行转置，但是我们可以保持代码不变。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">webpack加载器会做这三件事:它在web组件的影子DOM中为所有CSS规则加上前缀，这些CSS规则不是以元素名加::host或::slotted&nbsp;开头的，他们提供适当的范围。然后，它解析所有::host和::slot规则，以确保它们也能正确工作。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhzGbHK1kg8LtrlfLZaLaRR5J7EfMhQwNOWRNL05fvbyhXCstHlRbdAvLd3RaWy2x771KReA4YEPg/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhzGbHK1kg8LtrlfLZaLaRR5J7EfMhQwNOWRNL05fvbyhXCstHlRbdAvLd3RaWy2x771KReA4YEPg/640?wx_fmt=png"></span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">工作示例1:lazy-img</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">我创建了一个web组件，当图像在浏览器的视图中完全可见时，它就会惰性地加载图像。具体请参考Github。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">组件的主体将本地&lt;img&gt;&nbsp;标签封装在&lt;lazy-img&gt;&nbsp;自定义元素中:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs xml" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">lazy-img</span><br>&nbsp;&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">src</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"path/to/image.jpg"</span><br>&nbsp;&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">width</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"480"</span><br>&nbsp;&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">height</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"320"</span><br>&nbsp;&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">delay</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"500"</span><br>&nbsp;&nbsp;<span class="hljs-attr" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);word-wrap: inherit !important;word-break: inherit !important;">margin</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"0px"</span>&gt;&lt;/<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">lazy-img</span>&gt;</span></code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">下例还包含了extend-native分支，其中包含lazy-img，它使用is属性扩展原生&lt;img&gt;标签:</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs coffeescript" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">&lt;img<br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">is</span>=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"lazy-img"</span><br>&nbsp;&nbsp;src=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"path/to/img.jpg"</span><br>&nbsp;&nbsp;width=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"480"</span><br>&nbsp;&nbsp;height=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"320"</span><br>&nbsp;&nbsp;delay=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"500"</span><br>&nbsp;&nbsp;margin=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"0px"</span>&gt;</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">这是一个说明原生web组件强大功能的很好的例子:只需导入JavaScript文件、添加HTML标签或使用is属性扩展原生web组件，大功告成!</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhzGbHK1kg8LtrlfLZaLaRR3ic2G3zywgVw88GVVjm2qSn590Yr11rqwqudFIckfHZDYWb7Tibkf6Tw/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhzGbHK1kg8LtrlfLZaLaRR3ic2G3zywgVw88GVVjm2qSn590Yr11rqwqudFIckfHZDYWb7Tibkf6Tw/640?wx_fmt=png"></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">工作示例2:material-webcomponents</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">我使用自定义元素实现了谷歌的材质设计，具体也请参考Github。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">这个库还展示了CSS自定义属性的强大功能，其中包含大量的自定义属性。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhzGbHK1kg8LtrlfLZaLaRRGcofP4Wydk8MLLN5WiaKcVkyXkqRQjRmqb5MpNuUjzbYINJJ1L9bE8w/640?wx_fmt=png" data-type="png" data-w="160" style="white-space: normal;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhzGbHK1kg8LtrlfLZaLaRRGcofP4Wydk8MLLN5WiaKcVkyXkqRQjRmqb5MpNuUjzbYINJJ1L9bE8w/640?wx_fmt=png"></span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;text-align: center;"><strong><span style="max-width: 100%;font-size: 18px;box-sizing: border-box !important;overflow-wrap: break-word !important;">那么，应该抛弃框架吗?</span></strong></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><br></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">当然，这要视情况而定。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">目前的前端框架因具有数据绑定、状态管理和相当标准化的代码库等功能而带来了额外的价值。但问题是你的应用程序是否真的需要它。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">如果还需要问自己，我的应用程序是否真的需要Redux之类的状态管理，那么你可能就是不需要它的。你渐渐就明白了。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">使用数据绑定可能有好处，但是对于数组和对象等非基本值，原生web组件已经支持用户直接设置属性。我们可以在属性上设置基本值，并且可以通过attributeChangedCallback观察这些属性的更改。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">虽然这种方法看起来非常合理，但是与React和Angular的声明式方法相比，它会使得更新DOM的某一部分变得非常麻烦和冗长。这些框架支持定义一个视图，它包含当表达式变更时更新的表达式。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">原生web组件(还)不提供这样的功能，尽管有人建议扩展&lt;template&gt;元素，使其可以用数据实例化和更新：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs dart" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;word-wrap: normal !important;word-break: normal !important;overflow: auto !important;">&lt;template&nbsp;id=<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">"example"</span>&gt;<br>&nbsp;&nbsp;&lt;h1&gt;{{title}}&lt;/h1&gt;<br><br>&nbsp;&nbsp;&lt;p&gt;{{text}}&lt;/p&gt;<br>&lt;/template&gt;<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;template&nbsp;=&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">document</span>.<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">querySelector</span>(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'#example'</span>);<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);word-wrap: inherit !important;word-break: inherit !important;">const</span>&nbsp;instance&nbsp;=&nbsp;template.createInstance({title:&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'The&nbsp;title'</span>,&nbsp;text:&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'Hello&nbsp;world'</span>});<br>shadowRoot.appendChild(instance.content);<br><br><span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);word-wrap: inherit !important;word-break: inherit !important;">//update</span><br>instance.update({title:&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'A&nbsp;new&nbsp;title'</span>,&nbsp;text:&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);word-wrap: inherit !important;word-break: inherit !important;">'Hi&nbsp;there'</span>});</code></pre> 
</section> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">当前可以支持有效DOM更新的库是lit -html。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">另一个经常提到前端框架的好处是，它们提供了一个标准的代码基，团队中的每个新开发人员都将从一开始就熟悉这个代码基。虽然我相信这是真的，但我也认为这种好处是相当有限的。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">我曾经用Angular、React和Polymer做过很多项目，虽然大家对它们都很熟悉，但是尽管使用了相同的框架，这些代码库还是有很大的不同。清晰定义的工作方式和样式指南比简单地使用框架更有助于代码库的一致性。框架也带来了额外的复杂性，所以问问自己这是否真的值得</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">现在web组件得到了广泛的支持，我们可能会得出这样的结论:原生代码可以提供与框架相同的功能，但是性能更好、代码更少、复杂度更低。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">本地web组件的好处很明显:</span></p> 
<ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
 <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">原生，不需要框架；</span></p></li> 
 <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">易于集成，不需要移位；</span></p></li> 
 <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">CSS有真正的作用域；</span></p></li> 
 <li><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">规范，只有HTML, CSS和JavaScript。</span></p></li> 
</ul> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">jQuery及其尤为出色的资源将会继续存在一段时间，但是没有太多人会使用它构建的新项目，因为现在有了更好的选择。我不认为目前的框架会很快消失，但是以原生web组件形式出现的更优选择正在出现，并且迅速获得关注。我确实期望这些前端框架的角色会发生巨大变化，届时它们将仅给本地web组件提供一个薄外层。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="font-size: 15px;letter-spacing: 1px;background-color: rgb(255, 255, 255);color: rgb(136, 136, 136);">原文：https://www.dannymoerkerke.com/blog/web-components-will-replace-your-frontend-framework</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="font-size: 15px;letter-spacing: 1px;background-color: rgb(255, 255, 255);color: rgb(136, 136, 136);">本文为 CSDN 翻译，转载请注明来源出处。</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;text-align: center;line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(136, 136, 136);box-sizing: border-box !important;overflow-wrap: break-word !important;">【END】</span></p> 
<p style="text-align: center;"><img class="rich_pages" data-copyright="0" data-ratio="0.5482233502538071" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuha00icpm13kvibNc1ebfcQjpEwnKLxKl5j3IeULmEO9FKTyE5LZTOiaR6mriaLaxZSOjStabiaAXCI5tw/640?wx_fmt=jpeg" data-type="jpeg" data-w="591" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuha00icpm13kvibNc1ebfcQjpEwnKLxKl5j3IeULmEO9FKTyE5LZTOiaR6mriaLaxZSOjStabiaAXCI5tw/640?wx_fmt=jpeg"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 1px;text-align: center;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">作为码一代，想教码二代却无从下手：</span><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 1px;text-align: center;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">听说少儿编程很火，可它有哪些好处呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 1px;text-align: center;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">孩子多大开始学习比较好呢？又该如何学习呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 1px;text-align: center;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">最新的编程教育政策又有哪些呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 1px;text-align: center;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;">下面给大家介绍CSDN新成员：<strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">极客宝宝（ID：</strong><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">geek_baby）</strong></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;text-align: center;letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">戳他了解更多↓↓↓</span></strong><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;text-align: center;line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img class="rich_pages" data-copyright="0" data-cropselx1="180" data-cropselx2="438" data-cropsely1="0" data-cropsely2="258" data-ratio="0.3697916666666667" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vbbgCLnCbTPs0mGuVrLHntraYT5MIPrhkqQCmnqobLOf7nkWPh5j6vw/640?wx_fmt=jpeg" data-type="jpeg" data-w="960" style="box-sizing: border-box !important;overflow-wrap: break-word !important;visibility: visible !important;width: 618px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vbbgCLnCbTPs0mGuVrLHntraYT5MIPrhkqQCmnqobLOf7nkWPh5j6vw/640?wx_fmt=jpeg"></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;text-align: center;letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;background-color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">&nbsp;热 文</strong>&nbsp;推 荐&nbsp;</strong></span></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650719490&amp;idx=1&amp;sn=dc628b2516de6aaf4d458bfad0e4ad1a&amp;chksm=bea6b4d189d13dc7659a5a63f52443e16834ad43dd5cf4502227cc4442b9d671fa256b428dd7&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">互联网出海十年</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650719490&amp;idx=2&amp;sn=14ca3838d9e020f19f0fce73bde9e432&amp;chksm=bea6b4d189d13dc71cb988dcabfeff1ded76720c4b7703f135f3ff4d326f06e3b253cbf8124a&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="11" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">面试一线互联网大厂？那这道题目你必须得会！</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650719488&amp;idx=1&amp;sn=6ffee753e0bc941c3e118a1eebd6f64d&amp;chksm=bea6b4d389d13dc556b31a55dbf57a1b241f1f8ac5a594b5c7bcc57e7d051fccbbcc07099af8&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">华为在剑桥建芯片厂；小米公布出货量反驳调研机构； 中移动否认限制号 | 极客头条</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(0, 82, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">☞</span><a href="http://mp.weixin.qq.com/s?__biz=Mzg3MDA4NDkxMQ==&amp;mid=2247483906&amp;idx=1&amp;sn=028974f5b9a583116b453ea947113916&amp;chksm=ce927a42f9e5f354515bea6a993a29d8358602ba87db2f0ad480d01b4fa80503cf1b679ca39f&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">天才程序员：25 岁进贝尔实验室，32 岁创建信息论</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(0, 82, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">☞&nbsp;</span><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&amp;mid=2651010694&amp;idx=1&amp;sn=2961fbd0a2c64aab2fb9029e3087886b&amp;chksm=8bad8571bcda0c6728507245c9ef8d31513b9c9ba2b0569f63e5d9a30f8650110d2a49df7132&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">扎心！工作 10 年，月薪过万者不足三成，程序员却笑了</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247494910&amp;idx=1&amp;sn=b5de3589f59b15a4e5a2f203d4fd87d2&amp;chksm=fc7fb203cb083b15f1764c3da56a3a93298248469ccbb4652b119598e61c1748997b223c8636&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">6张图告诉你, 区块链的未来在哪里</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MzA3MjY1MTQwNQ==&amp;mid=2649827523&amp;idx=2&amp;sn=27f4a1910fc8c352b2cc87a00fe6a3df&amp;chksm=871e8f21b06906370895d2776392b5cea29da2197eec2f63b7681c614ed2fd5bc93a36838fd7&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">我们应聘BAT等互联网公司，关于Spring到底需要掌握什么？</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&amp;mid=2247504786&amp;idx=1&amp;sn=7eb90f5189c22a76ba0d63cff3c0a69f&amp;chksm=e99ee06bdee9697d3c88a257907bc4e139caa03c2604a634b7378e7b5daabb58d0e4a93ebf76&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">如何确定最佳训练数据集规模？6 大必备“锦囊”全给你了 | 技术头条</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);color: rgb(0, 82, 255);font-size: 14px;box-sizing: border-box !important;overflow-wrap: break-word !important;">☞&nbsp;</span><a href="http://mp.weixin.qq.com/s?__biz=MzA5MjcxNjc2Ng==&amp;mid=2650559816&amp;idx=1&amp;sn=380cfd3d18fb987c0073bf1b8289155a&amp;chksm=88601ef9bf1797ef9e671113fdeed0dac0e1750691de9c6a594dd46706f72aeafa9028b57fe5&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">她说：为啥程序员都特想要机械键盘？这答案我服！</span></a></p> 
<section style="white-space: normal;max-width: 100%;letter-spacing: 0.544px;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
 <section class="" style="max-width: 100%;font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
  <pre style="max-width: 100%;font-size: inherit;color: inherit;line-height: inherit;box-sizing: border-box !important;overflow-wrap: break-word !important;"><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;padding: 0.5em;max-width: 100%;min-height: 1em;font-size: 14px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;background: rgb(34, 34, 34);color: rgb(170, 170, 170);line-height: 1.75em;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">System.out.println(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个在看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">console.log(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(50, 170, 238);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">print</span>(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(50, 170, 238);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">printf</span>(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！\n"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">cout&nbsp;&lt;&lt;&nbsp;<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span>&nbsp;&lt;&lt;&nbsp;endl;<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">Console.WriteLine(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">Response.Write(<span class="" style="max-width: 100%;font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span>);<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;overflow-wrap: break-word !important;">alert(</span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: break-word !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;overflow-wrap: break-word !important;">)</span><br style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span class="" style="max-width: 100%;font-size: inherit;font-variant-numeric: normal;line-height: inherit;widows: 1;color: rgb(50, 170, 238);box-sizing: border-box !important;overflow-wrap: inherit !important;word-break: inherit !important;">echo </span><span style="max-width: 100%;font-variant-numeric: normal;line-height: 24.5px;widows: 1;color: rgb(255, 204, 51);box-sizing: border-box !important;overflow-wrap: break-word !important;">"点个<span style="max-width: 100%;">在</span>看吧！"</span></p></pre> 
 </section> 
</section> 
<p style="white-space: normal;max-width: 100%;min-height: 1em;letter-spacing: 0.544px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><img border="0" class="__bg_gif" data-ratio="0.8" data-src="https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAujr9dOtwUGfl03zJzLBRXbZs8g1RcNcLr7qm5qEy419tofZ8dq1sIW75xZwq2K4zIzcTtaDOy4OTg/640?wx_fmt=gif" data-type="gif" data-w="200" height="" title="" width="45" style="box-sizing: border-box;text-align: left;background-color: rgb(255, 255, 255);font-family: 微软雅黑;font-size: 16px;letter-spacing: 0.544px;vertical-align: middle;overflow-wrap: break-word !important;visibility: visible !important;width: 45px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAujr9dOtwUGfl03zJzLBRXbZs8g1RcNcLr7qm5qEy419tofZ8dq1sIW75xZwq2K4zIzcTtaDOy4OTg/640?wx_fmt=gif"><strong style="max-width: 100%;text-align: left;background-color: rgb(255, 255, 255);color: rgb(55, 55, 93);font-family: 微软雅黑;font-size: 16px;letter-spacing: 0.544px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 1px;box-sizing: border-box !important;overflow-wrap: break-word !important;"><span style="max-width: 100%;widows: 1;box-sizing: border-box !important;overflow-wrap: break-word !important;">点击阅读原文，输入关键词，即可搜索您想要的 CSDN 文章。</span></strong></strong></p> 
<section class="" data-tools="135编辑器" data-id="94250" style="white-space: normal;max-width: 100%;box-sizing: border-box;letter-spacing: 0.544px;border-width: 0px;border-style: none;border-color: initial;overflow-wrap: break-word !important;"> 
 <section class="" data-tools="135编辑器" data-id="91842" style="max-width: 100%;box-sizing: border-box;border-width: 0px;border-style: none;border-color: initial;text-align: right;overflow-wrap: break-word !important;"> 
  <section style="max-width: 100%;display: inline-block;clear: both;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
   <section class="" data-brushtype="text" style="padding: 18px 15px 20px 10px;max-width: 100%;box-sizing: border-box;color: rgb(86, 146, 214);background-image: url(&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdy66AHd7QqL7A2s5icSBE0aw4iaKOKPnXGYxQPhG7VMpbbYV6VJprSh7w/640?wx_fmt=png&quot;);background-repeat: no-repeat;text-align: center;background-size: 100% 100%;font-size: 16px;letter-spacing: 1.5px;overflow-wrap: break-word !important;"> 
    <section style="max-width: 100%;display: flex;justify-content: center;align-items: center;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
     <section style="margin-left: 2px;max-width: 100%;width: 20px;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
      <img class="" data-ratio="0.8936170212765957" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdvAd0o9e1LlUGA2k0Yib222agOxzweXhahA9GuzJcGBg0dA4DzlibxRqw/640?wx_fmt=png" data-type="png" data-w="47" style="margin-bottom: -6px;box-sizing: border-box !important;overflow-wrap: break-word !important;visibility: visible !important;width: 20px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdvAd0o9e1LlUGA2k0Yib222agOxzweXhahA9GuzJcGBg0dA4DzlibxRqw/640?wx_fmt=png"> 
     </section> 
     <section class="" data-brushtype="text" style="max-width: 100%;font-size: 14px;color: rgb(51, 51, 51);text-align: right;box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
      <span style="max-width: 100%;font-family: 楷体, 楷体_GB2312, SimKai;box-sizing: border-box !important;overflow-wrap: break-word !important;">你点的每个“在看”，我都认真当成了喜欢</span> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section> 
<section data-role="outer" label="Powered by 135editor.com" style="white-space: normal;max-width: 100%;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;"> 
 <section data-role="outer" label="Powered by 135editor.com" style="max-width: 100%;font-size: 16px;font-family: 微软雅黑;text-align: right;box-sizing: border-box !important;word-wrap: break-word !important;"> 
  <section style="max-width: 100%;display: inline-block;box-sizing: border-box !important;word-wrap: break-word !important;"> 
   <section style="margin-top: -0.4em;margin-left: -1em;max-width: 100%;width: 1em;float: right;transform: rotate(0deg);box-sizing: border-box !important;word-wrap: break-word !important;"> 
    <img class="" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAujO0pvtNCLzZCiaWxGBfq2xaPwze1NRLTSQZYbzWNnTJwDwsReHiam91Wojzvw3RLibjicWkLWJjicgsvw/640?wx_fmt=png" data-type="png" data-w="23" data-width="100%" style="display: block;box-sizing: border-box !important;word-wrap: break-word !important;overflow-wrap: break-word !important;visibility: visible !important;width: 15.9954px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAujO0pvtNCLzZCiaWxGBfq2xaPwze1NRLTSQZYbzWNnTJwDwsReHiam91Wojzvw3RLibjicWkLWJjicgsvw/640?wx_fmt=png"> 
   </section> 
  </section> 
 </section> 
</section>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
